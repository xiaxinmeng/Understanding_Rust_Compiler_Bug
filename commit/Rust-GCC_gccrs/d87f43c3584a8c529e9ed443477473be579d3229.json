{"sha": "d87f43c3584a8c529e9ed443477473be579d3229", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg3ZjQzYzM1ODRhOGM1MjllOWVkNDQzNDc3NDczYmU1NzlkMzIyOQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2009-11-04T18:48:21Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2009-11-04T18:48:21Z"}, "message": "multiway_merge.h: Simple formatting and uglification fixes.\n\n2009-11-04  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/parallel/multiway_merge.h: Simple formatting and\n\tuglification fixes.\n\t* include/parallel/losertree.h: Likewise.\n\nFrom-SVN: r153907", "tree": {"sha": "7aed94aa6aa1569a0e2c555aee2eb27108c2f9be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7aed94aa6aa1569a0e2c555aee2eb27108c2f9be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d87f43c3584a8c529e9ed443477473be579d3229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d87f43c3584a8c529e9ed443477473be579d3229", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d87f43c3584a8c529e9ed443477473be579d3229", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d87f43c3584a8c529e9ed443477473be579d3229/comments", "author": null, "committer": null, "parents": [{"sha": "0e159e0f2bfa8b235fef752c8a67d190ec869d15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e159e0f2bfa8b235fef752c8a67d190ec869d15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e159e0f2bfa8b235fef752c8a67d190ec869d15"}], "stats": {"total": 2784, "additions": 1376, "deletions": 1408}, "files": [{"sha": "c61685e20d0368b1afcb6bc993bc66fa0c8788c7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d87f43c3584a8c529e9ed443477473be579d3229/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d87f43c3584a8c529e9ed443477473be579d3229/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d87f43c3584a8c529e9ed443477473be579d3229", "patch": "@@ -1,3 +1,9 @@\n+2009-11-04  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/parallel/multiway_merge.h: Simple formatting and\n+\tuglification fixes.\n+\t* include/parallel/losertree.h: Likewise.\n+\n 2009-11-03  David Krauss  <potswa@mac.com>\n \t    Paolo Carlini  <paolo.carlini@oracle.com>\n "}, {"sha": "f83333bcb2f86498819aa345b5f53259d7321e3e", "filename": "libstdc++-v3/include/parallel/losertree.h", "status": "modified", "additions": 791, "deletions": 791, "changes": 1582, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d87f43c3584a8c529e9ed443477473be579d3229/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d87f43c3584a8c529e9ed443477473be579d3229/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h?ref=d87f43c3584a8c529e9ed443477473be579d3229", "patch": "@@ -40,7 +40,6 @@\n \n namespace __gnu_parallel\n {\n-\n /**\n  * @brief Guarded loser/tournament tree.\n  *\n@@ -54,498 +53,501 @@ namespace __gnu_parallel\n  * @param _Compare the comparator to use, defaults to std::less<_Tp>\n  */\n template<typename _Tp, typename _Compare>\n-class _LoserTreeBase\n-{\n-protected:\n-  /** @brief Internal representation of a _LoserTree element. */\n-  struct _Loser\n+  class _LoserTreeBase\n   {\n-    /** @brief flag, true iff this is a \"maximum\" __sentinel. */\n-    bool _M_sup;\n-    /** @brief __index of the __source __sequence. */\n-    int _M_source;\n-    /** @brief _M_key of the element in the _LoserTree. */\n-    _Tp _M_key;\n-  };\n-\n-  unsigned int _M_ik, _M_k, _M_offset;\n-\n-  /** log_2{_M_k} */\n-  unsigned int _M_log_k;\n-\n-  /** @brief _LoserTree __elements. */\n-  _Loser* _M_losers;\n-\n-  /** @brief _Compare to use. */\n-  _Compare _M_comp;\n-\n-  /**\n-   * @brief State flag that determines whether the _LoserTree is empty.\n-   *\n-   * Only used for building the _LoserTree.\n-   */\n-  bool _M_first_insert;\n-\n-public:\n-  /**\n-   * @brief The constructor.\n-   *\n-   * @param __k The number of sequences to merge.\n-   * @param __comp The comparator to use.\n-   */\n-  _LoserTreeBase(unsigned int __k, _Compare __comp)\n-  : _M_comp(__comp)\n-  {\n-    _M_ik = __k;\n+  protected:\n+    /** @brief Internal representation of a _LoserTree element. */\n+    struct _Loser\n+    {\n+      /** @brief flag, true iff this is a \"maximum\" __sentinel. */\n+      bool _M_sup;\n+      /** @brief __index of the __source __sequence. */\n+      int _M_source;\n+      /** @brief _M_key of the element in the _LoserTree. */\n+      _Tp _M_key;\n+    };\n+\n+    unsigned int _M_ik, _M_k, _M_offset;\n+\n+    /** log_2{_M_k} */\n+    unsigned int _M_log_k;\n+\n+    /** @brief _LoserTree __elements. */\n+    _Loser* _M_losers;\n+\n+    /** @brief _Compare to use. */\n+    _Compare _M_comp;\n+\n+    /**\n+     * @brief State flag that determines whether the _LoserTree is empty.\n+     *\n+     * Only used for building the _LoserTree.\n+     */\n+    bool _M_first_insert;\n+\n+  public:\n+    /**\n+     * @brief The constructor.\n+     *\n+     * @param __k The number of sequences to merge.\n+     * @param __comp The comparator to use.\n+     */\n+    _LoserTreeBase(unsigned int __k, _Compare __comp)\n+    : _M_comp(__comp)\n+    {\n+      _M_ik = __k;\n \n-    // Compute log_2{_M_k} for the _Loser Tree\n-    _M_log_k = __rd_log2(_M_ik - 1) + 1;\n+      // Compute log_2{_M_k} for the _Loser Tree\n+      _M_log_k = __rd_log2(_M_ik - 1) + 1;\n \n-    // Next greater power of 2.\n-    _M_k = 1 << _M_log_k;\n-    _M_offset = _M_k;\n+      // Next greater power of 2.\n+      _M_k = 1 << _M_log_k;\n+      _M_offset = _M_k;\n \n-    // Avoid default-constructing _M_losers[]._M_key\n-    _M_losers\n+      // Avoid default-constructing _M_losers[]._M_key\n+      _M_losers\n         = static_cast<_Loser*>(::operator new(2 * _M_k * sizeof(_Loser)));\n-    for (unsigned int __i = _M_ik - 1; __i < _M_k; ++__i)\n-      _M_losers[__i + _M_k]._M_sup = true;\n-\n-    _M_first_insert = true;\n-  }\n-\n-  /**\n-   * @brief The destructor.\n-   */\n-  ~_LoserTreeBase()\n-  { ::operator delete(_M_losers); }\n+      for (unsigned int __i = _M_ik - 1; __i < _M_k; ++__i)\n+\t_M_losers[__i + _M_k]._M_sup = true;\n \n-  /**\n-   * @brief Initializes the sequence \"_M_source\" with the element \"_M_key\".\n-   *\n-   * @param _M_key the element to insert\n-   * @param _M_source __index of the __source __sequence\n-   * @param _M_sup flag that determines whether the value to insert is an\n-   *   explicit __supremum.\n-   */\n-  inline void\n-  __insert_start(const _Tp& _M_key, int _M_source, bool _M_sup)\n-  {\n-    unsigned int __pos = _M_k + _M_source;\n-\n-    if(_M_first_insert)\n-      {\n-        // Construct all keys, so we can easily deconstruct them.\n-        for (unsigned int __i = 0; __i < (2 * _M_k); ++__i)\n-          new(&(_M_losers[__i]._M_key)) _Tp(_M_key);\n-        _M_first_insert = false;\n-      }\n-    else\n-      new(&(_M_losers[__pos]._M_key)) _Tp(_M_key);\n-\n-    _M_losers[__pos]._M_sup = _M_sup;\n-    _M_losers[__pos]._M_source = _M_source;\n-  }\n-\n-  /**\n-   * @return the index of the sequence with the smallest element.\n-   */\n-  int __get_min_source()\n-  { return _M_losers[0]._M_source; }\n-};\n-\n-/**\n- * @brief Stable _LoserTree variant.\n- *\n- * Provides the stable implementations of insert_start, __init_winner,\n- * __init and __delete_min_insert.\n- *\n- * Unstable variant is done using partial specialisation below.\n- */\n-template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n-class _LoserTree : public _LoserTreeBase<_Tp, _Compare>\n-{\n-  typedef _LoserTreeBase<_Tp, _Compare> Base;\n-  using Base::_M_k;\n-  using Base::_M_losers;\n-  using Base::_M_first_insert;\n+      _M_first_insert = true;\n+    }\n \n-public:\n-  _LoserTree(unsigned int __k, _Compare __comp)\n-  : Base::_LoserTreeBase(__k, __comp)\n-  {}\n+    /**\n+     * @brief The destructor.\n+     */\n+    ~_LoserTreeBase()\n+    { ::operator delete(_M_losers); }\n+\n+    /**\n+     * @brief Initializes the sequence \"_M_source\" with the element \"_M_key\".\n+     *\n+     * @param _M_key the element to insert\n+     * @param _M_source __index of the __source __sequence\n+     * @param _M_sup flag that determines whether the value to insert is an\n+     *   explicit __supremum.\n+     */\n+    void\n+    __insert_start(const _Tp& _M_key, int _M_source, bool _M_sup)\n+    {\n+      unsigned int __pos = _M_k + _M_source;\n+\n+      if(_M_first_insert)\n+\t{\n+\t  // Construct all keys, so we can easily deconstruct them.\n+\t  for (unsigned int __i = 0; __i < (2 * _M_k); ++__i)\n+\t    new(&(_M_losers[__i]._M_key)) _Tp(_M_key);\n+\t  _M_first_insert = false;\n+\t}\n+      else\n+\tnew(&(_M_losers[__pos]._M_key)) _Tp(_M_key);\n+\n+      _M_losers[__pos]._M_sup = _M_sup;\n+      _M_losers[__pos]._M_source = _M_source;\n+    }\n \n-  unsigned int\n-  __init_winner(unsigned int __root)\n-  {\n-    if (__root >= _M_k)\n-      {\n-        return __root;\n-      }\n-    else\n-      {\n-        unsigned int __left = __init_winner (2 * __root);\n-        unsigned int __right = __init_winner (2 * __root + 1);\n-        if (_M_losers[__right]._M_sup\n-            || (!_M_losers[__left]._M_sup\n-             && !_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key)))\n-          {\n-            // Left one is less or equal.\n-            _M_losers[__root] = _M_losers[__right];\n-            return __left;\n-          }\n-        else\n-          {\n-            // Right one is less.\n-            _M_losers[__root] = _M_losers[__left];\n-            return __right;\n-          }\n-      }\n-  }\n-\n-  void __init()\n-  { _M_losers[0] = _M_losers[__init_winner(1)]; }\n+    /**\n+     * @return the index of the sequence with the smallest element.\n+     */\n+    int __get_min_source()\n+    { return _M_losers[0]._M_source; }\n+  };\n \n   /**\n-   * @brief Delete the smallest element and insert a new element from\n-   *   the previously smallest element's sequence.\n+   * @brief Stable _LoserTree variant.\n    *\n-   * This implementation is stable.\n+   * Provides the stable implementations of insert_start, __init_winner,\n+   * __init and __delete_min_insert.\n+   *\n+   * Unstable variant is done using partial specialisation below.\n    */\n-  // Do not pass a const reference since _M_key will be used as local variable.\n-  void __delete_min_insert(_Tp _M_key, bool _M_sup)\n+template<bool __stable/* default == true */, typename _Tp,\n+\t typename _Compare>\n+  class _LoserTree : public _LoserTreeBase<_Tp, _Compare>\n   {\n+    typedef _LoserTreeBase<_Tp, _Compare> _Base;\n+    using _Base::_M_k;\n+    using _Base::_M_losers;\n+    using _Base::_M_first_insert;\n+\n+  public:\n+    _LoserTree(unsigned int __k, _Compare __comp)\n+    : _Base::_LoserTreeBase(__k, __comp)\n+    { }\n+\n+    unsigned int\n+    __init_winner(unsigned int __root)\n+    {\n+      if (__root >= _M_k)\n+\treturn __root;\n+      else\n+\t{\n+\t  unsigned int __left = __init_winner (2 * __root);\n+\t  unsigned int __right = __init_winner (2 * __root + 1);\n+\t  if (_M_losers[__right]._M_sup\n+\t      || (!_M_losers[__left]._M_sup\n+\t\t  && !_M_comp(_M_losers[__right]._M_key,\n+\t\t\t      _M_losers[__left]._M_key)))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      _M_losers[__root] = _M_losers[__right];\n+\t      return __left;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Right one is less.\n+\t      _M_losers[__root] = _M_losers[__left];\n+\t      return __right;\n+\t    }\n+\t}\n+    }\n+\n+    void __init()\n+    { _M_losers[0] = _M_losers[__init_winner(1)]; }\n+\n+    /**\n+     * @brief Delete the smallest element and insert a new element from\n+     *   the previously smallest element's sequence.\n+     *\n+     * This implementation is stable.\n+     */\n+    // Do not pass a const reference since _M_key will be used as\n+    // local variable.\n+    void\n+    __delete_min_insert(_Tp _M_key, bool _M_sup)\n+    {\n #if _GLIBCXX_ASSERTIONS\n-    // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+      // no dummy sequence can ever be at the top!\n+      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-    int _M_source = _M_losers[0]._M_source;\n-    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n-      {\n-        // The smaller one gets promoted, ties are broken by _M_source.\n-        if ((_M_sup && (!_M_losers[__pos]._M_sup\n-                || _M_losers[__pos]._M_source < _M_source))\n-              || (!_M_sup && !_M_losers[__pos]._M_sup\n-                && ((_M_comp(_M_losers[__pos]._M_key, _M_key))\n-                  || (!_M_comp(_M_key, _M_losers[__pos]._M_key)\n-                    && _M_losers[__pos]._M_source < _M_source))))\n-          {\n-            // The other one is smaller.\n-            std::swap(_M_losers[__pos]._M_sup, _M_sup);\n-            std::swap(_M_losers[__pos]._M_source, _M_source);\n-            std::swap(_M_losers[__pos]._M_key, _M_key);\n-          }\n-      }\n-\n-    _M_losers[0]._M_sup = _M_sup;\n-    _M_losers[0]._M_source = _M_source;\n-    _M_losers[0]._M_key = _M_key;\n-  }\n-};\n-\n-/**\n- * @brief Unstable _LoserTree variant.\n- *\n- * Stability (non-stable here) is selected with partial specialization.\n- */\n-template<typename _Tp, typename _Compare>\n-class _LoserTree</* __stable == */false, _Tp, _Compare> :\n-    public _LoserTreeBase<_Tp, _Compare>\n-{\n-  typedef _LoserTreeBase<_Tp, _Compare> Base;\n-  using Base::_M_log_k;\n-  using Base::_M_k;\n-  using Base::_M_losers;\n-  using Base::_M_first_insert;\n-\n-public:\n-  _LoserTree(unsigned int __k, _Compare __comp)\n-  : Base::_LoserTreeBase(__k, __comp)\n-  {}\n+      int _M_source = _M_losers[0]._M_source;\n+      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0;\n+\t   __pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted, ties are broken by _M_source.\n+\t  if ((_M_sup && (!_M_losers[__pos]._M_sup\n+\t\t\t  || _M_losers[__pos]._M_source < _M_source))\n+\t      || (!_M_sup && !_M_losers[__pos]._M_sup\n+\t\t  && ((_M_comp(_M_losers[__pos]._M_key, _M_key))\n+\t\t      || (!_M_comp(_M_key, _M_losers[__pos]._M_key)\n+\t\t\t  && _M_losers[__pos]._M_source < _M_source))))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(_M_losers[__pos]._M_sup, _M_sup);\n+\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n+\t      std::swap(_M_losers[__pos]._M_key, _M_key);\n+\t    }\n+\t}\n+\n+      _M_losers[0]._M_sup = _M_sup;\n+      _M_losers[0]._M_source = _M_source;\n+      _M_losers[0]._M_key = _M_key;\n+    }\n+  };\n \n   /**\n-   * Computes the winner of the competition at position \"__root\".\n-   *\n-   * Called recursively (starting at 0) to build the initial tree.\n+   * @brief Unstable _LoserTree variant.\n    *\n-   * @param __root __index of the \"game\" to start.\n+   * Stability (non-stable here) is selected with partial specialization.\n    */\n-  unsigned int\n-  __init_winner (unsigned int __root)\n+template<typename _Tp, typename _Compare>\n+  class _LoserTree</* __stable == */false, _Tp, _Compare>\n+  : public _LoserTreeBase<_Tp, _Compare>\n   {\n-    if (__root >= _M_k)\n-      {\n-        return __root;\n-      }\n-    else\n-      {\n-        unsigned int __left = __init_winner (2 * __root);\n-        unsigned int __right = __init_winner (2 * __root + 1);\n-        if (_M_losers[__right]._M_sup\n-           || (!_M_losers[__left]._M_sup\n-             && !_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key)))\n-          {\n-            // Left one is less or equal.\n-            _M_losers[__root] = _M_losers[__right];\n-            return __left;\n-          }\n-        else\n-          {\n-            // Right one is less.\n-            _M_losers[__root] = _M_losers[__left];\n-            return __right;\n-          }\n-      }\n-  }\n-\n-  inline void\n-  __init()\n-  { _M_losers[0] = _M_losers[__init_winner(1)]; }\n+    typedef _LoserTreeBase<_Tp, _Compare> _Base;\n+    using _Base::_M_log_k;\n+    using _Base::_M_k;\n+    using _Base::_M_losers;\n+    using _Base::_M_first_insert;\n+\n+  public:\n+    _LoserTree(unsigned int __k, _Compare __comp)\n+    : _Base::_LoserTreeBase(__k, __comp)\n+    { }\n+\n+    /**\n+     * Computes the winner of the competition at position \"__root\".\n+     *\n+     * Called recursively (starting at 0) to build the initial tree.\n+     *\n+     * @param __root __index of the \"game\" to start.\n+     */\n+    unsigned int\n+    __init_winner(unsigned int __root)\n+    {\n+      if (__root >= _M_k)\n+\treturn __root;\n+      else\n+\t{\n+\t  unsigned int __left = __init_winner (2 * __root);\n+\t  unsigned int __right = __init_winner (2 * __root + 1);\n+\t  if (_M_losers[__right]._M_sup\n+\t      || (!_M_losers[__left]._M_sup\n+\t\t  && !_M_comp(_M_losers[__right]._M_key,\n+\t\t\t      _M_losers[__left]._M_key)))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      _M_losers[__root] = _M_losers[__right];\n+\t      return __left;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Right one is less.\n+\t      _M_losers[__root] = _M_losers[__left];\n+\t      return __right;\n+\t    }\n+\t}\n+    }\n \n-  /**\n-   * Delete the _M_key smallest element and insert the element _M_key instead.\n-   *\n-   * @param _M_key the _M_key to insert\n-   * @param _M_sup true iff _M_key is an explicitly marked supremum\n-   */\n-  // Do not pass a const reference since _M_key will be used as local variable.\n-  inline void\n-  __delete_min_insert(_Tp _M_key, bool _M_sup)\n-  {\n+    void\n+    __init()\n+    { _M_losers[0] = _M_losers[__init_winner(1)]; }\n+\n+    /**\n+     * Delete the _M_key smallest element and insert the element _M_key\n+     * instead.\n+     *\n+     * @param _M_key the _M_key to insert\n+     * @param _M_sup true iff _M_key is an explicitly marked supremum\n+     */\n+    // Do not pass a const reference since _M_key will be used as local\n+    // variable.\n+    void\n+    __delete_min_insert(_Tp _M_key, bool _M_sup)\n+    {\n #if _GLIBCXX_ASSERTIONS\n-    // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+      // no dummy sequence can ever be at the top!\n+      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-    int _M_source = _M_losers[0]._M_source;\n-    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n-    {\n-        // The smaller one gets promoted.\n-      if (_M_sup || (!_M_losers[__pos]._M_sup\n-                     && _M_comp(_M_losers[__pos]._M_key, _M_key)))\n-      {\n-            // The other one is smaller.\n-        std::swap(_M_losers[__pos]._M_sup, _M_sup);\n-        std::swap(_M_losers[__pos]._M_source, _M_source);\n-        std::swap(_M_losers[__pos]._M_key, _M_key);\n-      }\n+      int _M_source = _M_losers[0]._M_source;\n+      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0;\n+\t   __pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted.\n+\t  if (_M_sup || (!_M_losers[__pos]._M_sup\n+\t\t\t && _M_comp(_M_losers[__pos]._M_key, _M_key)))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(_M_losers[__pos]._M_sup, _M_sup);\n+\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n+\t      std::swap(_M_losers[__pos]._M_key, _M_key);\n+\t    }\n+\t}\n+\n+      _M_losers[0]._M_sup = _M_sup;\n+      _M_losers[0]._M_source = _M_source;\n+      _M_losers[0]._M_key = _M_key;\n     }\n-\n-    _M_losers[0]._M_sup = _M_sup;\n-    _M_losers[0]._M_source = _M_source;\n-    _M_losers[0]._M_key = _M_key;\n-  }\n-};\n-\n+  };\n \n /**\n  * @brief Base class of _Loser Tree implementation using pointers.\n  */\n template<typename _Tp, typename _Compare>\n-class _LoserTreePointerBase\n-{\n-protected:\n-  /** @brief Internal representation of _LoserTree __elements. */\n-  struct _Loser\n+  class _LoserTreePointerBase\n   {\n-    bool _M_sup;\n-    int _M_source;\n-    const _Tp* _M_keyp;\n-  };\n-\n-  unsigned int _M_ik, _M_k, _M_offset;\n-  _Loser* _M_losers;\n-  _Compare _M_comp;\n-\n-public:\n-  _LoserTreePointerBase(unsigned int __k, _Compare __comp = std::less<_Tp>())\n+  protected:\n+    /** @brief Internal representation of _LoserTree __elements. */\n+    struct _Loser\n+    {\n+      bool _M_sup;\n+      int _M_source;\n+      const _Tp* _M_keyp;\n+    };\n+\n+    unsigned int _M_ik, _M_k, _M_offset;\n+    _Loser* _M_losers;\n+    _Compare _M_comp;\n+\n+  public:\n+    _LoserTreePointerBase(unsigned int __k,\n+\t\t\t  _Compare __comp = std::less<_Tp>())\n     : _M_comp(__comp)\n-  {\n-    _M_ik = __k;\n-\n-    // Next greater power of 2.\n-    _M_k = 1 << (__rd_log2(_M_ik - 1) + 1);\n-    _M_offset = _M_k;\n-    _M_losers = new _Loser[_M_k * 2];\n-    for (unsigned int __i = _M_ik - 1; __i < _M_k; __i++)\n-      _M_losers[__i + _M_k]._M_sup = true;\n-  }\n+    {\n+      _M_ik = __k;\n+\n+      // Next greater power of 2.\n+      _M_k = 1 << (__rd_log2(_M_ik - 1) + 1);\n+      _M_offset = _M_k;\n+      _M_losers = new _Loser[_M_k * 2];\n+      for (unsigned int __i = _M_ik - 1; __i < _M_k; __i++)\n+\t_M_losers[__i + _M_k]._M_sup = true;\n+    }\n \n-  ~_LoserTreePointerBase()\n-  { ::operator delete[](_M_losers); }\n+    ~_LoserTreePointerBase()\n+    { ::operator delete[](_M_losers); }\n \n-  int __get_min_source()\n-  { return _M_losers[0]._M_source; }\n+    int __get_min_source()\n+    { return _M_losers[0]._M_source; }\n \n-  void __insert_start(const _Tp& _M_key, int _M_source, bool _M_sup)\n-  {\n-    unsigned int __pos = _M_k + _M_source;\n+    void __insert_start(const _Tp& _M_key, int _M_source, bool _M_sup)\n+    {\n+      unsigned int __pos = _M_k + _M_source;\n \n-    _M_losers[__pos]._M_sup = _M_sup;\n-    _M_losers[__pos]._M_source = _M_source;\n-    _M_losers[__pos]._M_keyp = &_M_key;\n-  }\n-};\n+      _M_losers[__pos]._M_sup = _M_sup;\n+      _M_losers[__pos]._M_source = _M_source;\n+      _M_losers[__pos]._M_keyp = &_M_key;\n+    }\n+  };\n \n /**\n  * @brief Stable _LoserTree implementation.\n  *\n  * The unstable variant is implemented using partial instantiation below.\n  */\n template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n-class _LoserTreePointer : public _LoserTreePointerBase<_Tp, _Compare>\n-{\n-  typedef _LoserTreePointerBase<_Tp, _Compare> Base;\n-  using Base::_M_k;\n-  using Base::_M_losers;\n+  class _LoserTreePointer\n+  : public _LoserTreePointerBase<_Tp, _Compare>\n+  {\n+    typedef _LoserTreePointerBase<_Tp, _Compare> _Base;\n+    using _Base::_M_k;\n+    using _Base::_M_losers;\n \n-public:\n-  _LoserTreePointer(unsigned int __k, _Compare __comp = std::less<_Tp>())\n-    : Base::_LoserTreePointerBase(__k, __comp)\n-  {}\n+  public:\n+    _LoserTreePointer(unsigned int __k, _Compare __comp = std::less<_Tp>())\n+    : _Base::_LoserTreePointerBase(__k, __comp)\n+    { }\n \n-  unsigned int\n-  __init_winner(unsigned int __root)\n-  {\n-    if (__root >= _M_k)\n-      {\n-        return __root;\n-      }\n-    else\n-      {\n-        unsigned int __left = __init_winner (2 * __root);\n-        unsigned int __right = __init_winner (2 * __root + 1);\n-        if (_M_losers[__right]._M_sup\n-            || (!_M_losers[__left]._M_sup\n-                && !_M_comp(*_M_losers[__right]._M_keyp,\n-                            *_M_losers[__left]._M_keyp)))\n-          {\n-            // Left one is less or equal.\n-            _M_losers[__root] = _M_losers[__right];\n-            return __left;\n-          }\n-        else\n-          {\n-            // Right one is less.\n-            _M_losers[__root] = _M_losers[__left];\n-            return __right;\n-          }\n-      }\n-  }\n-\n-  void __init()\n-  { _M_losers[0] = _M_losers[__init_winner(1)]; }\n-\n-  void __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n-  {\n+    unsigned int\n+    __init_winner(unsigned int __root)\n+    {\n+      if (__root >= _M_k)\n+\treturn __root;\n+      else\n+\t{\n+\t  unsigned int __left = __init_winner (2 * __root);\n+\t  unsigned int __right = __init_winner (2 * __root + 1);\n+\t  if (_M_losers[__right]._M_sup\n+\t      || (!_M_losers[__left]._M_sup\n+\t\t  && !_M_comp(*_M_losers[__right]._M_keyp,\n+\t\t\t      *_M_losers[__left]._M_keyp)))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      _M_losers[__root] = _M_losers[__right];\n+\t      return __left;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Right one is less.\n+\t      _M_losers[__root] = _M_losers[__left];\n+\t      return __right;\n+\t    }\n+\t}\n+    }\n+\n+    void __init()\n+    { _M_losers[0] = _M_losers[__init_winner(1)]; }\n+\n+    void __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n+    {\n #if _GLIBCXX_ASSERTIONS\n-    // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+      // no dummy sequence can ever be at the top!\n+      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-    const _Tp* _M_keyp = &_M_key;\n-    int _M_source = _M_losers[0]._M_source;\n-    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n-      {\n-        // The smaller one gets promoted, ties are broken by _M_source.\n-        if ((_M_sup && (!_M_losers[__pos]._M_sup ||\n-                _M_losers[__pos]._M_source < _M_source)) ||\n+      const _Tp* _M_keyp = &_M_key;\n+      int _M_source = _M_losers[0]._M_source;\n+      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted, ties are broken by _M_source.\n+\t  if ((_M_sup && (!_M_losers[__pos]._M_sup ||\n+\t\t\t  _M_losers[__pos]._M_source < _M_source)) ||\n               (!_M_sup && !_M_losers[__pos]._M_sup &&\n-              ((_M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)) ||\n+\t       ((_M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)) ||\n                 (!_M_comp(*_M_keyp, *_M_losers[__pos]._M_keyp)\n-                && _M_losers[__pos]._M_source < _M_source))))\n-          {\n-            // The other one is smaller.\n-            std::swap(_M_losers[__pos]._M_sup, _M_sup);\n-            std::swap(_M_losers[__pos]._M_source, _M_source);\n-            std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n-          }\n-      }\n-\n-    _M_losers[0]._M_sup = _M_sup;\n-    _M_losers[0]._M_source = _M_source;\n-    _M_losers[0]._M_keyp = _M_keyp;\n-  }\n-};\n+\t\t && _M_losers[__pos]._M_source < _M_source))))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(_M_losers[__pos]._M_sup, _M_sup);\n+\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n+\t      std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n+\t    }\n+\t}\n+\n+      _M_losers[0]._M_sup = _M_sup;\n+      _M_losers[0]._M_source = _M_source;\n+      _M_losers[0]._M_keyp = _M_keyp;\n+    }\n+  };\n \n /**\n  * @brief Unstable _LoserTree implementation.\n  *\n  * The stable variant is above.\n  */\n template<typename _Tp, typename _Compare>\n-class _LoserTreePointer</* __stable == */false, _Tp, _Compare> :\n-    public _LoserTreePointerBase<_Tp, _Compare>\n-{\n-  typedef _LoserTreePointerBase<_Tp, _Compare> Base;\n-  using Base::_M_k;\n-  using Base::_M_losers;\n+  class _LoserTreePointer</* __stable == */false, _Tp, _Compare>\n+  : public _LoserTreePointerBase<_Tp, _Compare>\n+  {\n+    typedef _LoserTreePointerBase<_Tp, _Compare> _Base;\n+    using _Base::_M_k;\n+    using _Base::_M_losers;\n \n-public:\n-  _LoserTreePointer(unsigned int __k, _Compare __comp = std::less<_Tp>())\n-    : Base::_LoserTreePointerBase(__k, __comp)\n-  {}\n+  public:\n+    _LoserTreePointer(unsigned int __k, _Compare __comp = std::less<_Tp>())\n+    : _Base::_LoserTreePointerBase(__k, __comp)\n+    { }\n \n-  unsigned int\n-  __init_winner(unsigned int __root)\n-  {\n-    if (__root >= _M_k)\n-      {\n-        return __root;\n-      }\n-    else\n-      {\n-        unsigned int __left = __init_winner (2 * __root);\n-        unsigned int __right = __init_winner (2 * __root + 1);\n-        if (_M_losers[__right]._M_sup\n+    unsigned int\n+    __init_winner(unsigned int __root)\n+    {\n+      if (__root >= _M_k)\n+\treturn __root;\n+      else\n+\t{\n+\t  unsigned int __left = __init_winner (2 * __root);\n+\t  unsigned int __right = __init_winner (2 * __root + 1);\n+\t  if (_M_losers[__right]._M_sup\n               || (!_M_losers[__left]._M_sup\n-                && !_M_comp(*_M_losers[__right]._M_keyp,\n-                            *_M_losers[__left]._M_keyp)))\n-          {\n-            // Left one is less or equal.\n-            _M_losers[__root] = _M_losers[__right];\n-            return __left;\n-          }\n-        else\n-          {\n-            // Right one is less.\n-            _M_losers[__root] = _M_losers[__left];\n-            return __right;\n-          }\n-      }\n-  }\n-\n-  void __init()\n-  { _M_losers[0] = _M_losers[__init_winner(1)]; }\n-\n-  void __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n-  {\n+\t\t  && !_M_comp(*_M_losers[__right]._M_keyp,\n+\t\t\t      *_M_losers[__left]._M_keyp)))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      _M_losers[__root] = _M_losers[__right];\n+\t      return __left;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Right one is less.\n+\t      _M_losers[__root] = _M_losers[__left];\n+\t      return __right;\n+\t    }\n+\t}\n+    }\n+\n+    void __init()\n+    { _M_losers[0] = _M_losers[__init_winner(1)]; }\n+\n+    void __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n+    {\n #if _GLIBCXX_ASSERTIONS\n-    // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+      // no dummy sequence can ever be at the top!\n+      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-    const _Tp* _M_keyp = &_M_key;\n-    int _M_source = _M_losers[0]._M_source;\n-    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n-      {\n-        // The smaller one gets promoted.\n-        if (_M_sup || (!_M_losers[__pos]._M_sup\n-                       && _M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)))\n-          {\n-            // The other one is smaller.\n-            std::swap(_M_losers[__pos]._M_sup, _M_sup);\n-            std::swap(_M_losers[__pos]._M_source, _M_source);\n-            std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n-          }\n-      }\n-\n-    _M_losers[0]._M_sup = _M_sup;\n-    _M_losers[0]._M_source = _M_source;\n-    _M_losers[0]._M_keyp = _M_keyp;\n-  }\n-};\n+      const _Tp* _M_keyp = &_M_key;\n+      int _M_source = _M_losers[0]._M_source;\n+      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0;\n+\t   __pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted.\n+\t  if (_M_sup || (!_M_losers[__pos]._M_sup\n+\t\t\t && _M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(_M_losers[__pos]._M_sup, _M_sup);\n+\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n+\t      std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n+\t    }\n+\t}\n+\n+      _M_losers[0]._M_sup = _M_sup;\n+      _M_losers[0]._M_source = _M_source;\n+      _M_losers[0]._M_keyp = _M_keyp;\n+    }\n+  };\n \n /** @brief Base class for unguarded _LoserTree implementation.\n  * \n@@ -558,235 +560,235 @@ class _LoserTreePointer</* __stable == */false, _Tp, _Compare> :\n  * This is a very fast variant.\n  */\n template<typename _Tp, typename _Compare>\n-class _LoserTreeUnguardedBase\n-{\n-protected:\n-  struct _Loser\n+  class _LoserTreeUnguardedBase\n   {\n-    int _M_source;\n-    _Tp _M_key;\n-  };\n+  protected:\n+    struct _Loser\n+    {\n+      int _M_source;\n+      _Tp _M_key;\n+    };\n \n-  unsigned int _M_ik, _M_k, _M_offset;\n-  _Loser* _M_losers;\n-  _Compare _M_comp;\n+    unsigned int _M_ik, _M_k, _M_offset;\n+    _Loser* _M_losers;\n+    _Compare _M_comp;\n \n-public:\n-  inline\n-  _LoserTreeUnguardedBase(unsigned int __k, const _Tp _sentinel,\n-                         _Compare __comp = std::less<_Tp>())\n+  public:\n+    _LoserTreeUnguardedBase(unsigned int __k, const _Tp _sentinel,\n+\t\t\t    _Compare __comp = std::less<_Tp>())\n     : _M_comp(__comp)\n-  {\n-    _M_ik = __k;\n+    {\n+      _M_ik = __k;\n \n-    // Next greater power of 2.\n-    _M_k = 1 << (__rd_log2(_M_ik - 1) + 1);\n-    _M_offset = _M_k;\n-    // Avoid default-constructing _M_losers[]._M_key\n-    _M_losers\n+      // Next greater power of 2.\n+      _M_k = 1 << (__rd_log2(_M_ik - 1) + 1);\n+      _M_offset = _M_k;\n+      // Avoid default-constructing _M_losers[]._M_key\n+      _M_losers\n         = static_cast<_Loser*>(::operator new(2 * _M_k * sizeof(_Loser)));\n \n-    for (unsigned int __i = _M_k + _M_ik - 1; __i < (2 * _M_k); ++__i)\n-      {\n-        _M_losers[__i]._M_key = _sentinel;\n-        _M_losers[__i]._M_source = -1;\n-      }\n-  }\n+      for (unsigned int __i = _M_k + _M_ik - 1; __i < (2 * _M_k); ++__i)\n+\t{\n+\t  _M_losers[__i]._M_key = _sentinel;\n+\t  _M_losers[__i]._M_source = -1;\n+\t}\n+    }\n \n-  inline ~_LoserTreeUnguardedBase()\n-  { ::operator delete(_M_losers); }\n+    ~_LoserTreeUnguardedBase()\n+    { ::operator delete(_M_losers); }\n \n-  inline int\n-  __get_min_source()\n-  {\n+    int\n+    __get_min_source()\n+    {\n #if _GLIBCXX_ASSERTIONS\n-    // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+      // no dummy sequence can ever be at the top!\n+      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n-    return _M_losers[0]._M_source;\n-  }\n+      return _M_losers[0]._M_source;\n+    }\n \n-  inline void\n-  __insert_start(const _Tp& _M_key, int _M_source, bool)\n-  {\n-    unsigned int __pos = _M_k + _M_source;\n+    void\n+    __insert_start(const _Tp& _M_key, int _M_source, bool)\n+    {\n+      unsigned int __pos = _M_k + _M_source;\n \n-    new(&(_M_losers[__pos]._M_key)) _Tp(_M_key);\n-    _M_losers[__pos]._M_source = _M_source;\n-  }\n-};\n+      new(&(_M_losers[__pos]._M_key)) _Tp(_M_key);\n+      _M_losers[__pos]._M_source = _M_source;\n+    }\n+  };\n \n /**\n  * @brief Stable implementation of unguarded _LoserTree.\n  *\n  * Unstable variant is selected below with partial specialization.\n  */\n template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n-class _LoserTreeUnguarded : public _LoserTreeUnguardedBase<_Tp, _Compare>\n-{\n-  typedef _LoserTreeUnguardedBase<_Tp, _Compare> Base;\n-  using Base::_M_k;\n-  using Base::_M_losers;\n+  class _LoserTreeUnguarded\n+  : public _LoserTreeUnguardedBase<_Tp, _Compare>\n+  {\n+    typedef _LoserTreeUnguardedBase<_Tp, _Compare> _Base;\n+    using _Base::_M_k;\n+    using _Base::_M_losers;\n \n public:\n-  _LoserTreeUnguarded(unsigned int __k, const _Tp _sentinel,\n-                     _Compare __comp = std::less<_Tp>())\n-    : Base::_LoserTreeUnguardedBase(__k, _sentinel, __comp)\n-  {}\n+    _LoserTreeUnguarded(unsigned int __k, const _Tp _sentinel,\n+\t\t\t_Compare __comp = std::less<_Tp>())\n+    : _Base::_LoserTreeUnguardedBase(__k, _sentinel, __comp)\n+    { }\n \n-  unsigned int\n-  __init_winner(unsigned int __root)\n-  {\n-    if (__root >= _M_k)\n-      {\n-        return __root;\n-      }\n-    else\n-      {\n-        unsigned int __left = __init_winner (2 * __root);\n-        unsigned int __right = __init_winner (2 * __root + 1);\n-        if (!_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key))\n-          {\n-            // Left one is less or equal.\n-            _M_losers[__root] = _M_losers[__right];\n-            return __left;\n-          }\n-        else\n-          {\n-            // Right one is less.\n-            _M_losers[__root] = _M_losers[__left];\n-            return __right;\n-          }\n-      }\n-  }\n-\n-  inline void\n-  __init()\n-  {\n-    _M_losers[0] = _M_losers[__init_winner(1)];\n+    unsigned int\n+    __init_winner(unsigned int __root)\n+    {\n+      if (__root >= _M_k)\n+\treturn __root;\n+      else\n+\t{\n+\t  unsigned int __left = __init_winner (2 * __root);\n+\t  unsigned int __right = __init_winner (2 * __root + 1);\n+\t  if (!_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      _M_losers[__root] = _M_losers[__right];\n+\t      return __left;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Right one is less.\n+\t      _M_losers[__root] = _M_losers[__left];\n+\t      return __right;\n+\t    }\n+\t}\n+    }\n \n+    void\n+    __init()\n+    {\n+      _M_losers[0] = _M_losers[__init_winner(1)];\n+      \n #if _GLIBCXX_ASSERTIONS\n-    // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n-    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+      // no dummy sequence can ever be at the top at the beginning\n+      // (0 sequences!)\n+      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n-  }\n+    }\n \n-  // Do not pass a const reference since _M_key will be used as local variable.\n-  inline void\n-  __delete_min_insert(_Tp _M_key, bool)\n-  {\n+    // Do not pass a const reference since _M_key will be used as\n+    // local variable.\n+    void\n+    __delete_min_insert(_Tp _M_key, bool)\n+    {\n #if _GLIBCXX_ASSERTIONS\n-    // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+      // no dummy sequence can ever be at the top!\n+      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-    int _M_source = _M_losers[0]._M_source;\n-    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n-      {\n-        // The smaller one gets promoted, ties are broken by _M_source.\n-        if (_M_comp(_M_losers[__pos]._M_key, _M_key)\n+      int _M_source = _M_losers[0]._M_source;\n+      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted, ties are broken by _M_source.\n+\t  if (_M_comp(_M_losers[__pos]._M_key, _M_key)\n               || (!_M_comp(_M_key, _M_losers[__pos]._M_key)\n                   && _M_losers[__pos]._M_source < _M_source))\n-          {\n-            // The other one is smaller.\n-            std::swap(_M_losers[__pos]._M_source, _M_source);\n-            std::swap(_M_losers[__pos]._M_key, _M_key);\n-          }\n-      }\n-\n-    _M_losers[0]._M_source = _M_source;\n-    _M_losers[0]._M_key = _M_key;\n-  }\n-};\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n+\t      std::swap(_M_losers[__pos]._M_key, _M_key);\n+\t    }\n+\t}\n+\n+      _M_losers[0]._M_source = _M_source;\n+      _M_losers[0]._M_key = _M_key;\n+    }\n+  };\n \n /**\n  * @brief Non-Stable implementation of unguarded _LoserTree.\n  *\n  * Stable implementation is above.\n  */\n template<typename _Tp, typename _Compare>\n-class _LoserTreeUnguarded</* __stable == */false, _Tp, _Compare> :\n-    public _LoserTreeUnguardedBase<_Tp, _Compare>\n-{\n-  typedef _LoserTreeUnguardedBase<_Tp, _Compare> Base;\n-  using Base::_M_k;\n-  using Base::_M_losers;\n+  class _LoserTreeUnguarded</* __stable == */false, _Tp, _Compare>\n+  : public _LoserTreeUnguardedBase<_Tp, _Compare>\n+  {\n+    typedef _LoserTreeUnguardedBase<_Tp, _Compare> _Base;\n+    using _Base::_M_k;\n+    using _Base::_M_losers;\n \n public:\n-  _LoserTreeUnguarded(unsigned int __k, const _Tp _sentinel,\n-                     _Compare __comp = std::less<_Tp>())\n-    : Base::_LoserTreeUnguardedBase(__k, _sentinel, __comp)\n-  {}\n+    _LoserTreeUnguarded(unsigned int __k, const _Tp _sentinel,\n+\t\t\t_Compare __comp = std::less<_Tp>())\n+    : _Base::_LoserTreeUnguardedBase(__k, _sentinel, __comp)\n+    { }\n \n-  unsigned int\n-  __init_winner (unsigned int __root)\n-  {\n-    if (__root >= _M_k)\n-      {\n-        return __root;\n-      }\n-    else\n-      {\n-        unsigned int __left = __init_winner (2 * __root);\n-        unsigned int __right = __init_winner (2 * __root + 1);\n+    unsigned int\n+    __init_winner(unsigned int __root)\n+    {\n+      if (__root >= _M_k)\n+\treturn __root;\n+      else\n+\t{\n+\t  unsigned int __left = __init_winner (2 * __root);\n+\t  unsigned int __right = __init_winner (2 * __root + 1);\n \n #if _GLIBCXX_ASSERTIONS\n-        // If __left one is sentinel then __right one must be, too.\n-        if (_M_losers[__left]._M_source == -1)\n-          _GLIBCXX_PARALLEL_ASSERT(_M_losers[__right]._M_source == -1);\n+\t  // If __left one is sentinel then __right one must be, too.\n+\t  if (_M_losers[__left]._M_source == -1)\n+\t    _GLIBCXX_PARALLEL_ASSERT(_M_losers[__right]._M_source == -1);\n #endif\n \n-        if (!_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key))\n-          {\n-            // Left one is less or equal.\n-            _M_losers[__root] = _M_losers[__right];\n-            return __left;\n-          }\n-        else\n-          {\n-            // Right one is less.\n-            _M_losers[__root] = _M_losers[__left];\n-            return __right;\n-          }\n-      }\n-  }\n-\n-  inline void\n-  __init()\n-  {\n-    _M_losers[0] = _M_losers[__init_winner(1)];\n+\t  if (!_M_comp(_M_losers[__right]._M_key, _M_losers[__left]._M_key))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      _M_losers[__root] = _M_losers[__right];\n+\t      return __left;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Right one is less.\n+\t      _M_losers[__root] = _M_losers[__left];\n+\t      return __right;\n+\t    }\n+\t}\n+    }\n+\n+    void\n+    __init()\n+    {\n+      _M_losers[0] = _M_losers[__init_winner(1)];\n \n #if _GLIBCXX_ASSERTIONS\n-    // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n-    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+      // no dummy sequence can ever be at the top at the beginning\n+      // (0 sequences!)\n+      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n-  }\n+    }\n \n-  // Do not pass a const reference since _M_key will be used as local variable.\n-  inline void\n-  __delete_min_insert(_Tp _M_key, bool)\n-  {\n+    // Do not pass a const reference since _M_key will be used as\n+    // local variable.\n+    void\n+    __delete_min_insert(_Tp _M_key, bool)\n+    {\n #if _GLIBCXX_ASSERTIONS\n-    // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+      // no dummy sequence can ever be at the top!\n+      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-    int _M_source = _M_losers[0]._M_source;\n-    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n-      {\n-        // The smaller one gets promoted.\n-        if (_M_comp(_M_losers[__pos]._M_key, _M_key))\n-          {\n-            // The other one is smaller.\n-            std::swap(_M_losers[__pos]._M_source, _M_source);\n-            std::swap(_M_losers[__pos]._M_key, _M_key);\n-          }\n-      }\n-\n-    _M_losers[0]._M_source = _M_source;\n-    _M_losers[0]._M_key = _M_key;\n-  }\n-};\n+      int _M_source = _M_losers[0]._M_source;\n+      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted.\n+\t  if (_M_comp(_M_losers[__pos]._M_key, _M_key))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n+\t      std::swap(_M_losers[__pos]._M_key, _M_key);\n+\t    }\n+\t}\n+\n+      _M_losers[0]._M_source = _M_source;\n+      _M_losers[0]._M_key = _M_key;\n+    }\n+  };\n \n /** @brief Unguarded loser tree, keeping only pointers to the\n * elements in the tree structure.\n@@ -795,237 +797,235 @@ class _LoserTreeUnguarded</* __stable == */false, _Tp, _Compare> :\n *  run empty.  This is a very fast variant.\n */\n template<typename _Tp, typename _Compare>\n-class LoserTreePointerUnguardedBase\n-{\n-protected:\n-  struct _Loser\n+  class LoserTreePointerUnguardedBase\n   {\n-    int _M_source;\n-    const _Tp* _M_keyp;\n-  };\n+  protected:\n+    struct _Loser\n+    {\n+      int _M_source;\n+      const _Tp* _M_keyp;\n+    };\n \n-  unsigned int _M_ik, _M_k, _M_offset;\n-  _Loser* _M_losers;\n-  _Compare _M_comp;\n+    unsigned int _M_ik, _M_k, _M_offset;\n+    _Loser* _M_losers;\n+    _Compare _M_comp;\n \n-public:\n+  public:\n \n-  inline\n-  LoserTreePointerUnguardedBase(unsigned int __k, const _Tp& _sentinel,\n-      _Compare __comp = std::less<_Tp>())\n+    LoserTreePointerUnguardedBase(unsigned int __k, const _Tp& _sentinel,\n+\t\t\t\t  _Compare __comp = std::less<_Tp>())\n     : _M_comp(__comp)\n-  {\n-    _M_ik = __k;\n-\n-    // Next greater power of 2.\n-    _M_k = 1 << (__rd_log2(_M_ik - 1) + 1);\n-    _M_offset = _M_k;\n-    // Avoid default-constructing _M_losers[]._M_key\n-    _M_losers = new _Loser[2 * _M_k];\n-\n-    for (unsigned int __i = _M_k + _M_ik - 1; __i < (2 * _M_k); ++__i)\n-      {\n-        _M_losers[__i]._M_keyp = &_sentinel;\n-        _M_losers[__i]._M_source = -1;\n-      }\n-  }\n-\n-  inline ~LoserTreePointerUnguardedBase()\n-  { delete[] _M_losers; }\n-\n-  inline int\n-  __get_min_source()\n-  {\n+    {\n+      _M_ik = __k;\n+\n+      // Next greater power of 2.\n+      _M_k = 1 << (__rd_log2(_M_ik - 1) + 1);\n+      _M_offset = _M_k;\n+      // Avoid default-constructing _M_losers[]._M_key\n+      _M_losers = new _Loser[2 * _M_k];\n+\n+      for (unsigned int __i = _M_k + _M_ik - 1; __i < (2 * _M_k); ++__i)\n+\t{\n+\t  _M_losers[__i]._M_keyp = &_sentinel;\n+\t  _M_losers[__i]._M_source = -1;\n+\t}\n+    }\n+\n+    ~LoserTreePointerUnguardedBase()\n+    { delete[] _M_losers; }\n+\n+    int\n+    __get_min_source()\n+    {\n #if _GLIBCXX_ASSERTIONS\n-    // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+      // no dummy sequence can ever be at the top!\n+      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n-    return _M_losers[0]._M_source;\n-  }\n+      return _M_losers[0]._M_source;\n+    }\n \n-  inline void\n-  __insert_start(const _Tp& _M_key, int _M_source, bool)\n-  {\n-    unsigned int __pos = _M_k + _M_source;\n+    void\n+    __insert_start(const _Tp& _M_key, int _M_source, bool)\n+    {\n+      unsigned int __pos = _M_k + _M_source;\n \n-    _M_losers[__pos]._M_keyp = &_M_key;\n-    _M_losers[__pos]._M_source = _M_source;\n-  }\n-};\n+      _M_losers[__pos]._M_keyp = &_M_key;\n+      _M_losers[__pos]._M_source = _M_source;\n+    }\n+  };\n \n /**\n  * @brief Stable unguarded _LoserTree variant storing pointers.\n  *\n  * Unstable variant is implemented below using partial specialization.\n  */\n template<bool __stable/* default == true */, typename _Tp, typename _Compare>\n-class _LoserTreePointerUnguarded :\n-    public LoserTreePointerUnguardedBase<_Tp, _Compare>\n-{\n-  typedef LoserTreePointerUnguardedBase<_Tp, _Compare> Base;\n-  using Base::_M_k;\n-  using Base::_M_losers;\n-\n-public:\n-  _LoserTreePointerUnguarded(unsigned int __k, const _Tp& _sentinel,\n-      _Compare __comp = std::less<_Tp>())\n-    : Base::LoserTreePointerUnguardedBase(__k, _sentinel, __comp)\n-  {}\n-\n-  unsigned int\n-  __init_winner(unsigned int __root)\n-  {\n-    if (__root >= _M_k)\n-      {\n-        return __root;\n-      }\n-    else\n-      {\n-        unsigned int __left = __init_winner (2 * __root);\n-        unsigned int __right = __init_winner (2 * __root + 1);\n-        if (!_M_comp(*_M_losers[__right]._M_keyp, *_M_losers[__left]._M_keyp))\n-          {\n-            // Left one is less or equal.\n-            _M_losers[__root] = _M_losers[__right];\n-            return __left;\n-          }\n-        else\n-          {\n-            // Right one is less.\n-            _M_losers[__root] = _M_losers[__left];\n-            return __right;\n-          }\n-      }\n-  }\n-\n-  inline void\n-  __init()\n+  class _LoserTreePointerUnguarded\n+  : public LoserTreePointerUnguardedBase<_Tp, _Compare>\n   {\n-    _M_losers[0] = _M_losers[__init_winner(1)];\n+    typedef LoserTreePointerUnguardedBase<_Tp, _Compare> _Base;\n+    using _Base::_M_k;\n+    using _Base::_M_losers;\n+\n+  public:\n+    _LoserTreePointerUnguarded(unsigned int __k, const _Tp& _sentinel,\n+\t\t\t       _Compare __comp = std::less<_Tp>())\n+    : _Base::LoserTreePointerUnguardedBase(__k, _sentinel, __comp)\n+    { }\n+\n+    unsigned int\n+    __init_winner(unsigned int __root)\n+    {\n+      if (__root >= _M_k)\n+\treturn __root;\n+      else\n+\t{\n+\t  unsigned int __left = __init_winner (2 * __root);\n+\t  unsigned int __right = __init_winner (2 * __root + 1);\n+\t  if (!_M_comp(*_M_losers[__right]._M_keyp,\n+\t\t       *_M_losers[__left]._M_keyp))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      _M_losers[__root] = _M_losers[__right];\n+\t      return __left;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Right one is less.\n+\t      _M_losers[__root] = _M_losers[__left];\n+\t      return __right;\n+\t    }\n+\t}\n+    }\n+    \n+    void\n+    __init()\n+    {\n+      _M_losers[0] = _M_losers[__init_winner(1)];\n \n #if _GLIBCXX_ASSERTIONS\n-    // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n-    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+      // no dummy sequence can ever be at the top at the beginning\n+      // (0 sequences!)\n+      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n-  }\n+    }\n \n-  inline void\n-  __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n-  {\n+    void\n+    __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n+    {\n #if _GLIBCXX_ASSERTIONS\n-    // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+      // no dummy sequence can ever be at the top!\n+      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-    const _Tp* _M_keyp = &_M_key;\n-    int _M_source = _M_losers[0]._M_source;\n-    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n-      {\n-        // The smaller one gets promoted, ties are broken by _M_source.\n-        if (_M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)\n-          || (!_M_comp(*_M_keyp, *_M_losers[__pos]._M_keyp)\n-              && _M_losers[__pos]._M_source < _M_source))\n-          {\n-            // The other one is smaller.\n-            std::swap(_M_losers[__pos]._M_source, _M_source);\n-            std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n-          }\n-      }\n-\n-    _M_losers[0]._M_source = _M_source;\n-    _M_losers[0]._M_keyp = _M_keyp;\n-  }\n-};\n+      const _Tp* _M_keyp = &_M_key;\n+      int _M_source = _M_losers[0]._M_source;\n+      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted, ties are broken by _M_source.\n+\t  if (_M_comp(*_M_losers[__pos]._M_keyp, *_M_keyp)\n+\t      || (!_M_comp(*_M_keyp, *_M_losers[__pos]._M_keyp)\n+\t\t  && _M_losers[__pos]._M_source < _M_source))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n+\t      std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n+\t    }\n+\t}\n+\n+      _M_losers[0]._M_source = _M_source;\n+      _M_losers[0]._M_keyp = _M_keyp;\n+    }\n+  };\n \n /**\n  * @brief Unstable unguarded _LoserTree variant storing pointers.\n  *\n  * Stable variant is above.\n  */\n template<typename _Tp, typename _Compare>\n-class _LoserTreePointerUnguarded</* __stable == */false, _Tp, _Compare> :\n-    public LoserTreePointerUnguardedBase<_Tp, _Compare>\n-{\n-  typedef LoserTreePointerUnguardedBase<_Tp, _Compare> Base;\n-  using Base::_M_k;\n-  using Base::_M_losers;\n+  class _LoserTreePointerUnguarded</* __stable == */false, _Tp, _Compare>\n+  : public LoserTreePointerUnguardedBase<_Tp, _Compare>\n+  {\n+    typedef LoserTreePointerUnguardedBase<_Tp, _Compare> _Base;\n+    using _Base::_M_k;\n+    using _Base::_M_losers;\n \n public:\n-  _LoserTreePointerUnguarded(unsigned int __k, const _Tp& _sentinel,\n-      _Compare __comp = std::less<_Tp>())\n-    : Base::LoserTreePointerUnguardedBase(__k, _sentinel, __comp)\n-  {}\n+    _LoserTreePointerUnguarded(unsigned int __k, const _Tp& _sentinel,\n+\t\t\t       _Compare __comp = std::less<_Tp>())\n+    : _Base::LoserTreePointerUnguardedBase(__k, _sentinel, __comp)\n+    { }\n \n-  unsigned int\n-  __init_winner(unsigned int __root)\n-  {\n-    if (__root >= _M_k)\n-      {\n-        return __root;\n-      }\n-    else\n-      {\n-        unsigned int __left = __init_winner (2 * __root);\n-        unsigned int __right = __init_winner (2 * __root + 1);\n+    unsigned int\n+    __init_winner(unsigned int __root)\n+    {\n+      if (__root >= _M_k)\n+\treturn __root;\n+      else\n+\t{\n+\t  unsigned int __left = __init_winner (2 * __root);\n+\t  unsigned int __right = __init_winner (2 * __root + 1);\n \n #if _GLIBCXX_ASSERTIONS\n-        // If __left one is sentinel then __right one must be, too.\n-        if (_M_losers[__left]._M_source == -1)\n-          _GLIBCXX_PARALLEL_ASSERT(_M_losers[__right]._M_source == -1);\n+\t  // If __left one is sentinel then __right one must be, too.\n+\t  if (_M_losers[__left]._M_source == -1)\n+\t    _GLIBCXX_PARALLEL_ASSERT(_M_losers[__right]._M_source == -1);\n #endif\n \n-        if (!_M_comp(*_M_losers[__right]._M_keyp, *_M_losers[__left]._M_keyp))\n-          {\n-            // Left one is less or equal.\n-            _M_losers[__root] = _M_losers[__right];\n-            return __left;\n-          }\n-        else\n-          {\n-            // Right one is less.\n-            _M_losers[__root] = _M_losers[__left];\n-            return __right;\n-          }\n-      }\n-  }\n-\n-  inline void\n-  __init()\n-  {\n-    _M_losers[0] = _M_losers[__init_winner(1)];\n+\t  if (!_M_comp(*_M_losers[__right]._M_keyp,\n+\t\t       *_M_losers[__left]._M_keyp))\n+\t    {\n+\t      // Left one is less or equal.\n+\t      _M_losers[__root] = _M_losers[__right];\n+\t      return __left;\n+\t    }\n+\t  else\n+\t    {\n+\t      // Right one is less.\n+\t      _M_losers[__root] = _M_losers[__left];\n+\t      return __right;\n+\t    }\n+\t}\n+    }\n+\n+    void\n+    __init()\n+    {\n+      _M_losers[0] = _M_losers[__init_winner(1)];\n \n #if _GLIBCXX_ASSERTIONS\n-    // no dummy sequence can ever be at the top at the beginning (0 sequences!)\n-    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+      // no dummy sequence can ever be at the top at the beginning\n+      // (0 sequences!)\n+      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n-  }\n+    }\n \n-  inline void\n-  __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n-  {\n+    void\n+    __delete_min_insert(const _Tp& _M_key, bool _M_sup)\n+    {\n #if _GLIBCXX_ASSERTIONS\n-    // no dummy sequence can ever be at the top!\n-    _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n+      // no dummy sequence can ever be at the top!\n+      _GLIBCXX_PARALLEL_ASSERT(_M_losers[0]._M_source != -1);\n #endif\n \n-    const _Tp* _M_keyp = &_M_key;\n-    int _M_source = _M_losers[0]._M_source;\n-    for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n-      {\n-        // The smaller one gets promoted.\n-        if (_M_comp(*(_M_losers[__pos]._M_keyp), *_M_keyp))\n-          {\n-            // The other one is smaller.\n-            std::swap(_M_losers[__pos]._M_source, _M_source);\n-            std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n-          }\n-      }\n-\n-    _M_losers[0]._M_source = _M_source;\n-    _M_losers[0]._M_keyp = _M_keyp;\n-  }\n-};\n-\n+      const _Tp* _M_keyp = &_M_key;\n+      int _M_source = _M_losers[0]._M_source;\n+      for (unsigned int __pos = (_M_k + _M_source) / 2; __pos > 0; __pos /= 2)\n+\t{\n+\t  // The smaller one gets promoted.\n+\t  if (_M_comp(*(_M_losers[__pos]._M_keyp), *_M_keyp))\n+\t    {\n+\t      // The other one is smaller.\n+\t      std::swap(_M_losers[__pos]._M_source, _M_source);\n+\t      std::swap(_M_losers[__pos]._M_keyp, _M_keyp);\n+\t    }\n+\t}\n+\n+      _M_losers[0]._M_source = _M_source;\n+      _M_losers[0]._M_keyp = _M_keyp;\n+    }\n+  };\n } // namespace __gnu_parallel\n \n #endif /* _GLIBCXX_PARALLEL_LOSERTREE_H */"}, {"sha": "71ef90c8ae7b65f316eb0d60ef4b7379d16d7058", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "modified", "additions": 579, "deletions": 617, "changes": 1196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d87f43c3584a8c529e9ed443477473be579d3229/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d87f43c3584a8c529e9ed443477473be579d3229/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=d87f43c3584a8c529e9ed443477473be579d3229", "patch": "@@ -510,9 +510,9 @@ template<template<typename RAI, typename C> class iterator,\n /** @brief Multi-way merging procedure for a high branching factor,\n  *         guarded case.\n  *\n- * This merging variant uses a LoserTree class as selected by <tt>LT</tt>.\n+ * This merging variant uses a LoserTree class as selected by <tt>_LT</tt>.\n  *\n- * Stability is selected through the used LoserTree class <tt>LT</tt>.\n+ * Stability is selected through the used LoserTree class <tt>_LT</tt>.\n  *\n  * At least one non-empty sequence is required.\n  *\n@@ -525,7 +525,7 @@ template<template<typename RAI, typename C> class iterator,\n  *\n  * @return End iterator of output sequence.\n  */\n-template<typename LT,\n+template<typename _LT,\n          typename _RAIterIterator,\n          typename _RAIter3,\n          typename _DifferenceTp,\n@@ -547,7 +547,7 @@ template<typename LT,\n \n     int __k = static_cast<int>(__seqs_end - __seqs_begin);\n \n-    LT __lt(__k, __comp);\n+    _LT __lt(__k, __comp);\n \n     // Default value for potentially non-default-constructible types.\n     _ValueType* __arbitrary_element = NULL;\n@@ -592,7 +592,7 @@ template<typename LT,\n /** @brief Multi-way merging procedure for a high branching factor,\n  *         unguarded case.\n  *\n- * Merging is done using the LoserTree class <tt>LT</tt>.\n+ * Merging is done using the LoserTree class <tt>_LT</tt>.\n  *\n  * Stability is selected by the used LoserTrees.\n  *\n@@ -607,10 +607,10 @@ template<typename LT,\n  *\n  * @return End iterator of output sequence.\n  */\n-template<typename LT,\n-    typename _RAIterIterator,\n-    typename _RAIter3,\n-    typename _DifferenceTp, typename _Compare>\n+template<typename _LT,\n+\t typename _RAIterIterator,\n+\t typename _RAIter3,\n+\t typename _DifferenceTp, typename _Compare>\n   _RAIter3\n   multiway_merge_loser_tree_unguarded(\n     _RAIterIterator __seqs_begin,\n@@ -633,7 +633,7 @@ template<typename LT,\n \n     int __k = __seqs_end - __seqs_begin;\n \n-    LT __lt(__k, __sentinel, __comp);\n+    _LT __lt(__k, __sentinel, __comp);\n \n     for (int __t = 0; __t < __k; ++__t)\n       {\n@@ -696,12 +696,11 @@ template<typename LT,\n  *\n  * @return End iterator of output sequence.\n  */\n-template<\n-    typename UnguardedLoserTree,\n-    typename _RAIterIterator,\n-    typename _RAIter3,\n-    typename _DifferenceTp,\n-    typename _Compare>\n+template<typename UnguardedLoserTree,\n+\t typename _RAIterIterator,\n+\t typename _RAIter3,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n   _RAIter3\n   multiway_merge_loser_tree_sentinel(\n     _RAIterIterator __seqs_begin,\n@@ -790,172 +789,159 @@ struct _LoserTreeTraits\n  *\n  * Note that 3-way merging is always stable!\n  */\n-template<\n-  bool __sentinels /*default == false*/,\n-  typename _RAIterIterator,\n-  typename _RAIter3,\n-  typename _DifferenceTp,\n-  typename _Compare>\n-struct __multiway_merge_3_variant_sentinel_switch\n-{\n-  _RAIter3 operator()(\n-      _RAIterIterator __seqs_begin,\n-      _RAIterIterator __seqs_end,\n-      _RAIter3 __target,\n-      _DifferenceTp __length, _Compare __comp)\n+template<bool __sentinels /*default == false*/,\n+\t typename _RAIterIterator,\n+\t typename _RAIter3,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  struct __multiway_merge_3_variant_sentinel_switch\n   {\n-    return multiway_merge_3_variant<_GuardedIterator>(\n-        __seqs_begin, __seqs_end, __target, __length, __comp);\n-  }\n-};\n+    _RAIter3 operator()(_RAIterIterator __seqs_begin,\n+\t\t\t_RAIterIterator __seqs_end,\n+\t\t\t_RAIter3 __target,\n+\t\t\t_DifferenceTp __length, _Compare __comp)\n+    {\n+      return multiway_merge_3_variant<_GuardedIterator>\n+\t(__seqs_begin, __seqs_end, __target, __length, __comp);\n+    }\n+  };\n \n /**\n  * @brief Switch for 3-way merging with __sentinels turned on.\n  *\n  * Note that 3-way merging is always stable!\n  */\n-template<\n-  typename _RAIterIterator,\n-  typename _RAIter3,\n-  typename _DifferenceTp,\n-  typename _Compare>\n-struct __multiway_merge_3_variant_sentinel_switch\n-    <true, _RAIterIterator, _RAIter3,\n-     _DifferenceTp, _Compare>\n-{\n-  _RAIter3 operator()(\n-      _RAIterIterator __seqs_begin,\n-      _RAIterIterator __seqs_end,\n-      _RAIter3 __target,\n-      _DifferenceTp __length, _Compare __comp)\n+template<typename _RAIterIterator,\n+\t typename _RAIter3,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  struct __multiway_merge_3_variant_sentinel_switch\n+         <true, _RAIterIterator, _RAIter3, _DifferenceTp, _Compare>\n   {\n-    return multiway_merge_3_variant<_UnguardedIterator>(\n-        __seqs_begin, __seqs_end, __target, __length, __comp);\n-  }\n-};\n+    _RAIter3 operator()(_RAIterIterator __seqs_begin,\n+\t\t\t_RAIterIterator __seqs_end,\n+\t\t\t_RAIter3 __target,\n+\t\t\t_DifferenceTp __length, _Compare __comp)\n+    {\n+      return multiway_merge_3_variant<_UnguardedIterator>\n+\t(__seqs_begin, __seqs_end, __target, __length, __comp);\n+    }\n+  };\n \n /**\n  * @brief Switch for 4-way merging with __sentinels turned off.\n  *\n  * Note that 4-way merging is always stable!\n  */\n-template<\n-  bool __sentinels /*default == false*/,\n-  typename _RAIterIterator,\n-  typename _RAIter3,\n-  typename _DifferenceTp,\n-  typename _Compare>\n-struct __multiway_merge_4_variant_sentinel_switch\n-{\n-  _RAIter3 operator()(\n-      _RAIterIterator __seqs_begin,\n-      _RAIterIterator __seqs_end,\n-      _RAIter3 __target,\n-      _DifferenceTp __length, _Compare __comp)\n+template<bool __sentinels /*default == false*/,\n+\t typename _RAIterIterator,\n+\t typename _RAIter3,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  struct __multiway_merge_4_variant_sentinel_switch\n   {\n-    return multiway_merge_4_variant<_GuardedIterator>(\n-        __seqs_begin, __seqs_end, __target, __length, __comp);\n-  }\n-};\n+    _RAIter3 operator()(_RAIterIterator __seqs_begin,\n+\t\t\t_RAIterIterator __seqs_end,\n+\t\t\t_RAIter3 __target,\n+\t\t\t_DifferenceTp __length, _Compare __comp)\n+    {\n+      return multiway_merge_4_variant<_GuardedIterator>\n+\t(__seqs_begin, __seqs_end, __target, __length, __comp);\n+    }\n+  };\n \n /**\n  * @brief Switch for 4-way merging with __sentinels turned on.\n  *\n  * Note that 4-way merging is always stable!\n  */\n-template<\n-  typename _RAIterIterator,\n-  typename _RAIter3,\n-  typename _DifferenceTp,\n-  typename _Compare>\n-struct __multiway_merge_4_variant_sentinel_switch\n-    <true, _RAIterIterator, _RAIter3,\n-     _DifferenceTp, _Compare>\n-{\n-  _RAIter3 operator()(\n-      _RAIterIterator __seqs_begin,\n-      _RAIterIterator __seqs_end,\n-      _RAIter3 __target,\n-      _DifferenceTp __length, _Compare __comp)\n+template<typename _RAIterIterator,\n+\t typename _RAIter3,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  struct __multiway_merge_4_variant_sentinel_switch\n+    <true, _RAIterIterator, _RAIter3, _DifferenceTp, _Compare>\n   {\n-    return multiway_merge_4_variant<_UnguardedIterator>(\n-        __seqs_begin, __seqs_end, __target, __length, __comp);\n-  }\n-};\n+    _RAIter3 operator()(_RAIterIterator __seqs_begin,\n+\t\t\t_RAIterIterator __seqs_end,\n+\t\t\t_RAIter3 __target,\n+\t\t\t_DifferenceTp __length, _Compare __comp)\n+    {\n+      return multiway_merge_4_variant<_UnguardedIterator>\n+\t(__seqs_begin, __seqs_end, __target, __length, __comp);\n+    }\n+  };\n \n /**\n  * @brief Switch for k-way merging with __sentinels turned on.\n  */\n-template<\n-  bool __sentinels,\n-  bool __stable,\n-  typename _RAIterIterator,\n-  typename _RAIter3,\n-  typename _DifferenceTp,\n-  typename _Compare>\n-struct __multiway_merge_k_variant_sentinel_switch\n-{\n-  _RAIter3 operator()(\n-      _RAIterIterator __seqs_begin,\n+template<bool __sentinels,\n+\t bool __stable,\n+\t typename _RAIterIterator,\n+\t typename _RAIter3,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  struct __multiway_merge_k_variant_sentinel_switch\n+   {\n+     _RAIter3 operator()\n+     (_RAIterIterator __seqs_begin,\n       _RAIterIterator __seqs_end,\n       _RAIter3 __target,\n       const typename std::iterator_traits<typename std::iterator_traits<\n-        _RAIterIterator>::value_type::first_type>::value_type&\n-          __sentinel,\n+      _RAIterIterator>::value_type::first_type>::value_type&\n+      __sentinel,\n       _DifferenceTp __length, _Compare __comp)\n-  {\n-    typedef typename std::iterator_traits<_RAIterIterator>\n-      ::value_type::first_type\n-      _RAIter1;\n-    typedef typename std::iterator_traits<_RAIter1>::value_type\n-      _ValueType;\n-\n-    return multiway_merge_loser_tree_sentinel<\n-        typename __gnu_cxx::__conditional_type<\n-            _LoserTreeTraits<_ValueType>::_M_use_pointer\n-          , _LoserTreePointerUnguarded<__stable, _ValueType, _Compare>\n-          , _LoserTreeUnguarded<__stable, _ValueType, _Compare>\n+     {\n+       typedef typename std::iterator_traits<_RAIterIterator>\n+\t ::value_type::first_type\n+\t _RAIter1;\n+       typedef typename std::iterator_traits<_RAIter1>::value_type\n+\t _ValueType;\n+\n+       return multiway_merge_loser_tree_sentinel<\n+       typename __gnu_cxx::__conditional_type<\n+       _LoserTreeTraits<_ValueType>::_M_use_pointer,\n+\t _LoserTreePointerUnguarded<__stable, _ValueType, _Compare>,\n+\t _LoserTreeUnguarded<__stable, _ValueType, _Compare>\n         >::__type>(\n             __seqs_begin, __seqs_end, __target, __sentinel, __length, __comp);\n-  }\n-};\n+     }\n+  };\n \n /**\n  * @brief Switch for k-way merging with __sentinels turned off.\n  */\n-template<\n-  bool __stable,\n-  typename _RAIterIterator,\n-  typename _RAIter3,\n-  typename _DifferenceTp,\n-  typename _Compare>\n-struct __multiway_merge_k_variant_sentinel_switch\n-    <false, __stable, _RAIterIterator, _RAIter3,\n-     _DifferenceTp, _Compare>\n-{\n-  _RAIter3 operator()(\n-      _RAIterIterator __seqs_begin,\n-      _RAIterIterator __seqs_end,\n-      _RAIter3 __target,\n-      const typename std::iterator_traits<typename std::iterator_traits<\n-        _RAIterIterator>::value_type::first_type>::value_type&\n-          __sentinel,\n-      _DifferenceTp __length, _Compare __comp)\n+template<bool __stable,\n+\t typename _RAIterIterator,\n+\t typename _RAIter3,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  struct __multiway_merge_k_variant_sentinel_switch\n+         <false, __stable, _RAIterIterator, _RAIter3, _DifferenceTp, _Compare>\n   {\n-    typedef typename std::iterator_traits<_RAIterIterator>\n-      ::value_type::first_type\n-      _RAIter1;\n-    typedef typename std::iterator_traits<_RAIter1>::value_type\n-      _ValueType;\n-\n-    return multiway_merge_loser_tree<\n-        typename __gnu_cxx::__conditional_type<\n-            _LoserTreeTraits<_ValueType>::_M_use_pointer\n-          , _LoserTreePointer<__stable, _ValueType, _Compare>\n-          , _LoserTree<__stable, _ValueType, _Compare>\n+    _RAIter3 operator()\n+    (_RAIterIterator __seqs_begin,\n+     _RAIterIterator __seqs_end,\n+     _RAIter3 __target,\n+     const typename std::iterator_traits<typename std::iterator_traits<\n+     _RAIterIterator>::value_type::first_type>::value_type&\n+     __sentinel,\n+     _DifferenceTp __length, _Compare __comp)\n+    {\n+      typedef typename std::iterator_traits<_RAIterIterator>\n+\t::value_type::first_type\n+\t_RAIter1;\n+      typedef typename std::iterator_traits<_RAIter1>::value_type\n+\t_ValueType;\n+\n+      return multiway_merge_loser_tree<\n+      typename __gnu_cxx::__conditional_type<\n+      _LoserTreeTraits<_ValueType>::_M_use_pointer,\n+\t_LoserTreePointer<__stable, _ValueType, _Compare>,\n+\t_LoserTree<__stable, _ValueType, _Compare>\n         >::__type >(__seqs_begin, __seqs_end, __target, __length, __comp);\n-  }\n-};\n+    }\n+  };\n \n /** @brief Sequential multi-way merging switch.\n  *\n@@ -970,13 +956,12 @@ struct __multiway_merge_k_variant_sentinel_switch\n  *  @param __stable Stable merging incurs a performance penalty.\n  *  @param __sentinel The sequences have __a __sentinel element.\n  *  @return End iterator of output sequence. */\n-template<\n-    bool __stable,\n-    bool __sentinels,\n-    typename _RAIterIterator,\n-    typename _RAIter3,\n-    typename _DifferenceTp,\n-    typename _Compare>\n+template<bool __stable,\n+\t bool __sentinels,\n+\t typename _RAIterIterator,\n+\t typename _RAIter3,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n   _RAIter3\n   __sequential_multiway_merge(\n     _RAIterIterator __seqs_begin,\n@@ -1035,30 +1020,30 @@ template<\n         break;\n       case 3:\n         __return_target = __multiway_merge_3_variant_sentinel_switch<\n-            __sentinels\n-          , _RAIterIterator\n-          , _RAIter3\n-          , _DifferenceTp\n-          , _Compare>()(__seqs_begin, __seqs_end, __target, __length, __comp);\n+\t  __sentinels,\n+\t  _RAIterIterator,\n+\t  _RAIter3,\n+\t  _DifferenceTp,\n+\t  _Compare>()(__seqs_begin, __seqs_end, __target, __length, __comp);\n         break;\n       case 4:\n         __return_target = __multiway_merge_4_variant_sentinel_switch<\n-            __sentinels\n-          , _RAIterIterator\n-          , _RAIter3\n-          , _DifferenceTp\n-          , _Compare>()(__seqs_begin, __seqs_end, __target, __length, __comp);\n+\t  __sentinels,\n+\t  _RAIterIterator,\n+\t  _RAIter3,\n+\t  _DifferenceTp,\n+\t  _Compare>()(__seqs_begin, __seqs_end, __target, __length, __comp);\n         break;\n       default:\n-          __return_target = __multiway_merge_k_variant_sentinel_switch<\n-              __sentinels\n-            , __stable\n-            , _RAIterIterator\n-            , _RAIter3\n-            , _DifferenceTp\n-            , _Compare>()(__seqs_begin, __seqs_end, __target, __sentinel,\n-                          __length, __comp);\n-          break;\n+\t__return_target = __multiway_merge_k_variant_sentinel_switch<\n+\t  __sentinels,\n+\t  __stable,\n+\t  _RAIterIterator,\n+\t  _RAIter3,\n+\t  _DifferenceTp,\n+\t  _Compare>()(__seqs_begin, __seqs_end, __target, __sentinel,\n+\t\t      __length, __comp);\n+\tbreak;\n       }\n #if _GLIBCXX_ASSERTIONS\n     _GLIBCXX_PARALLEL_ASSERT(\n@@ -1074,191 +1059,189 @@ template<\n  * Used to reduce code instanciation in multiway_merge_sampling_splitting.\n  */\n template<bool __stable, class _RAIter, class _StrictWeakOrdering>\n-struct _SamplingSorter\n-{\n-  void operator()(_RAIter __first, _RAIter __last,\n-                  _StrictWeakOrdering __comp)\n-  { __gnu_sequential::stable_sort(__first, __last, __comp); }\n-};\n+  struct _SamplingSorter\n+  {\n+    void operator()(_RAIter __first, _RAIter __last,\n+\t\t    _StrictWeakOrdering __comp)\n+    { __gnu_sequential::stable_sort(__first, __last, __comp); }\n+  };\n \n /**\n  * @brief Non-__stable sorting functor.\n  *\n  * Used to reduce code instantiation in multiway_merge_sampling_splitting.\n  */\n template<class _RAIter, class _StrictWeakOrdering>\n-struct _SamplingSorter<false, _RAIter, _StrictWeakOrdering>\n-{\n-  void operator()(_RAIter __first, _RAIter __last,\n-                  _StrictWeakOrdering __comp)\n-  { __gnu_sequential::sort(__first, __last, __comp); }\n-};\n+  struct _SamplingSorter<false, _RAIter, _StrictWeakOrdering>\n+  {\n+    void operator()(_RAIter __first, _RAIter __last,\n+\t\t    _StrictWeakOrdering __comp)\n+    { __gnu_sequential::sort(__first, __last, __comp); }\n+  };\n \n /**\n  * @brief Sampling based splitting for parallel multiway-merge routine.\n  */\n-template<\n-    bool __stable\n-  , typename _RAIterIterator\n-  , typename _Compare\n-  , typename _DifferenceType>\n-void multiway_merge_sampling_splitting(\n-    _RAIterIterator __seqs_begin,\n-    _RAIterIterator __seqs_end,\n-    _DifferenceType __length, _DifferenceType __total_length, _Compare __comp,\n-    std::vector<std::pair<_DifferenceType, _DifferenceType> > *__pieces)\n-{\n-  typedef typename std::iterator_traits<_RAIterIterator>\n-    ::value_type::first_type\n-    _RAIter1;\n-  typedef typename std::iterator_traits<_RAIter1>::value_type\n-    _ValueType;\n+template<bool __stable,\n+\t typename _RAIterIterator,\n+\t typename _Compare,\n+\t typename _DifferenceType>\n+  void\n+  multiway_merge_sampling_splitting\n+  (_RAIterIterator __seqs_begin,\n+   _RAIterIterator __seqs_end,\n+   _DifferenceType __length, _DifferenceType __total_length, _Compare __comp,\n+   std::vector<std::pair<_DifferenceType, _DifferenceType> > *__pieces)\n+  {\n+    typedef typename std::iterator_traits<_RAIterIterator>\n+      ::value_type::first_type\n+      _RAIter1;\n+    typedef typename std::iterator_traits<_RAIter1>::value_type\n+      _ValueType;\n \n-  // __k sequences.\n-  int __k = static_cast<int>(__seqs_end - __seqs_begin);\n+    // __k sequences.\n+    int __k = static_cast<int>(__seqs_end - __seqs_begin);\n \n-  int __num_threads = omp_get_num_threads();\n+    int __num_threads = omp_get_num_threads();\n \n-  _DifferenceType __num_samples =\n+    _DifferenceType __num_samples =\n       __gnu_parallel::_Settings::get().merge_oversampling * __num_threads;\n \n-  _ValueType* __samples = static_cast<_ValueType*>(\n-    ::operator new(sizeof(_ValueType) * __k * __num_samples));\n-  // Sample.\n-  for (int __s = 0; __s < __k; ++__s)\n-    for (_DifferenceType __i = 0; __i < __num_samples; ++__i)\n-      {\n-        _DifferenceType sample_index =\n-            static_cast<_DifferenceType>(\n-                _GLIBCXX_PARALLEL_LENGTH(__seqs_begin[__s])\n-                    * (double(__i + 1) / (__num_samples + 1))\n-                    * (double(__length) / __total_length));\n-        new(&(__samples[__s * __num_samples + __i]))\n+    _ValueType* __samples = static_cast<_ValueType*>\n+      (::operator new(sizeof(_ValueType) * __k * __num_samples));\n+    // Sample.\n+    for (int __s = 0; __s < __k; ++__s)\n+      for (_DifferenceType __i = 0; __i < __num_samples; ++__i)\n+\t{\n+\t  _DifferenceType sample_index =\n+            static_cast<_DifferenceType>\n+\t    (_GLIBCXX_PARALLEL_LENGTH(__seqs_begin[__s])\n+\t     * (double(__i + 1) / (__num_samples + 1))\n+\t     * (double(__length) / __total_length));\n+\t  new(&(__samples[__s * __num_samples + __i]))\n             _ValueType(__seqs_begin[__s].first[sample_index]);\n-      }\n+\t}\n \n-  // Sort stable or non-stable, depending on value of template parameter\n-  // \"__stable\".\n-  _SamplingSorter<__stable, _ValueType*, _Compare>()(\n-      __samples, __samples + (__num_samples * __k), __comp);\n+    // Sort stable or non-stable, depending on value of template parameter\n+    // \"__stable\".\n+    _SamplingSorter<__stable, _ValueType*, _Compare>()\n+      (__samples, __samples + (__num_samples * __k), __comp);\n \n-  for (int __slab = 0; __slab < __num_threads; ++__slab)\n-    // For each slab / processor.\n-    for (int __seq = 0; __seq < __k; ++__seq)\n-      {\n-        // For each sequence.\n-        if (__slab > 0)\n-          __pieces[__slab][__seq].first =\n-              std::upper_bound(\n-                __seqs_begin[__seq].first,\n-                __seqs_begin[__seq].second,\n-                __samples[__num_samples * __k * __slab / __num_threads],\n-                  __comp)\n-              - __seqs_begin[__seq].first;\n-        else\n-          // Absolute beginning.\n-          __pieces[__slab][__seq].first = 0;\n-        if ((__slab + 1) < __num_threads)\n-          __pieces[__slab][__seq].second =\n-              std::upper_bound(\n-                  __seqs_begin[__seq].first,\n-                  __seqs_begin[__seq].second,\n-                  __samples[__num_samples * __k * (__slab + 1) /\n-                      __num_threads], __comp)\n+    for (int __slab = 0; __slab < __num_threads; ++__slab)\n+      // For each slab / processor.\n+      for (int __seq = 0; __seq < __k; ++__seq)\n+\t{\n+\t  // For each sequence.\n+\t  if (__slab > 0)\n+\t    __pieces[__slab][__seq].first =\n+              std::upper_bound\n+\t      (__seqs_begin[__seq].first,\n+\t       __seqs_begin[__seq].second,\n+\t       __samples[__num_samples * __k * __slab / __num_threads],\n+\t       __comp) - __seqs_begin[__seq].first;\n+\t  else\n+\t    // Absolute beginning.\n+\t    __pieces[__slab][__seq].first = 0;\n+\t  if ((__slab + 1) < __num_threads)\n+\t    __pieces[__slab][__seq].second =\n+              std::upper_bound\n+\t      (__seqs_begin[__seq].first,\n+\t       __seqs_begin[__seq].second,\n+\t       __samples[__num_samples * __k * (__slab + 1) /\n+\t\t\t __num_threads], __comp)\n               - __seqs_begin[__seq].first;\n-        else\n+\t  else\n             // Absolute end.\n-          __pieces[__slab][__seq].second\n-            = _GLIBCXX_PARALLEL_LENGTH(__seqs_begin[__seq]);\n-      }\n+\t    __pieces[__slab][__seq].second\n+\t      = _GLIBCXX_PARALLEL_LENGTH(__seqs_begin[__seq]);\n+\t}\n     ::operator delete(__samples);\n-}\n+  }\n \n /**\n  * @brief Exact splitting for parallel multiway-merge routine.\n  *\n  * None of the passed sequences may be empty.\n  */\n-template<\n-    bool __stable\n-  , typename _RAIterIterator\n-  , typename _Compare\n-  , typename _DifferenceType>\n-void multiway_merge_exact_splitting(\n-    _RAIterIterator __seqs_begin,\n-    _RAIterIterator __seqs_end,\n-    _DifferenceType __length, _DifferenceType __total_length, _Compare __comp,\n-    std::vector<std::pair<_DifferenceType, _DifferenceType> > *__pieces)\n-{\n-  typedef typename std::iterator_traits<_RAIterIterator>\n-    ::value_type::first_type\n-    _RAIter1;\n+template<bool __stable,\n+\t typename _RAIterIterator,\n+\t typename _Compare,\n+\t typename _DifferenceType>\n+  void\n+  multiway_merge_exact_splitting\n+    (_RAIterIterator __seqs_begin,\n+     _RAIterIterator __seqs_end,\n+     _DifferenceType __length, _DifferenceType __total_length,\n+     _Compare __comp,\n+     std::vector<std::pair<_DifferenceType, _DifferenceType> > *__pieces)\n+  {\n+    typedef typename std::iterator_traits<_RAIterIterator>\n+      ::value_type::first_type\n+      _RAIter1;\n \n-  const bool __tight = (__total_length == __length);\n+    const bool __tight = (__total_length == __length);\n \n-  // __k sequences.\n-  const int __k = static_cast<int>(__seqs_end - __seqs_begin);\n+    // __k sequences.\n+    const int __k = static_cast<int>(__seqs_end - __seqs_begin);\n \n-  const int __num_threads = omp_get_num_threads();\n+    const int __num_threads = omp_get_num_threads();\n \n-  // (Settings::multiway_merge_splitting == __gnu_parallel::_Settings::EXACT).\n-  std::vector<_RAIter1>* __offsets =\n+    // (Settings::multiway_merge_splitting == __gnu_parallel::_Settings::EXACT).\n+    std::vector<_RAIter1>* __offsets =\n       new std::vector<_RAIter1>[__num_threads];\n-  std::vector<\n-      std::pair<_RAIter1, _RAIter1>\n-      > __se(__k);\n+    std::vector<std::pair<_RAIter1, _RAIter1> > __se(__k);\n \n-  copy(__seqs_begin, __seqs_end, __se.begin());\n+    copy(__seqs_begin, __seqs_end, __se.begin());\n \n-  _DifferenceType* __borders =\n+    _DifferenceType* __borders =\n       new _DifferenceType[__num_threads + 1];\n-  equally_split(__length, __num_threads, __borders);\n-\n-  for (int __s = 0; __s < (__num_threads - 1); ++__s)\n-    {\n-      __offsets[__s].resize(__k);\n-      multiseq_partition(\n-          __se.begin(), __se.end(), __borders[__s + 1],\n-          __offsets[__s].begin(), __comp);\n+    equally_split(__length, __num_threads, __borders);\n \n-      // Last one also needed and available.\n-      if (!__tight)\n-        {\n-          __offsets[__num_threads - 1].resize(__k);\n-          multiseq_partition(__se.begin(), __se.end(),\n-                _DifferenceType(__length),\n-                __offsets[__num_threads - 1].begin(),  __comp);\n-        }\n-    }\n-  delete[] __borders;\n+    for (int __s = 0; __s < (__num_threads - 1); ++__s)\n+      {\n+\t__offsets[__s].resize(__k);\n+\tmultiseq_partition\n+\t  (__se.begin(), __se.end(), __borders[__s + 1],\n+\t   __offsets[__s].begin(), __comp);\n+\n+\t// Last one also needed and available.\n+\tif (!__tight)\n+\t  {\n+\t    __offsets[__num_threads - 1].resize(__k);\n+\t    multiseq_partition(__se.begin(), __se.end(),\n+\t\t\t       _DifferenceType(__length),\n+\t\t\t       __offsets[__num_threads - 1].begin(), __comp);\n+\t  }\n+      }\n+    delete[] __borders;\n \n-  for (int __slab = 0; __slab < __num_threads; ++__slab)\n-    {\n-      // For each slab / processor.\n-      for (int __seq = 0; __seq < __k; ++__seq)\n-        {\n-          // For each sequence.\n-          if (__slab == 0)\n-            {\n-              // Absolute beginning.\n-              __pieces[__slab][__seq].first = 0;\n-            }\n-          else\n-            __pieces[__slab][__seq].first =\n+    for (int __slab = 0; __slab < __num_threads; ++__slab)\n+      {\n+\t// For each slab / processor.\n+\tfor (int __seq = 0; __seq < __k; ++__seq)\n+\t  {\n+\t    // For each sequence.\n+\t    if (__slab == 0)\n+\t      {\n+\t\t// Absolute beginning.\n+\t\t__pieces[__slab][__seq].first = 0;\n+\t      }\n+\t    else\n+\t      __pieces[__slab][__seq].first =\n                 __pieces[__slab - 1][__seq].second;\n-          if (!__tight || __slab < (__num_threads - 1))\n-            __pieces[__slab][__seq].second =\n+\t    if (!__tight || __slab < (__num_threads - 1))\n+\t      __pieces[__slab][__seq].second =\n                 __offsets[__slab][__seq] - __seqs_begin[__seq].first;\n-          else\n-            {\n-              // __slab == __num_threads - 1\n-              __pieces[__slab][__seq].second =\n+\t    else\n+\t      {\n+\t\t// __slab == __num_threads - 1\n+\t\t__pieces[__slab][__seq].second =\n                   _GLIBCXX_PARALLEL_LENGTH(__seqs_begin[__seq]);\n-            }\n-        }\n-    }\n-  delete[] __offsets;\n-}\n+\t      }\n+\t  }\n+      }\n+    delete[] __offsets;\n+  }\n \n /** @brief Parallel multi-way merge routine.\n  *\n@@ -1279,15 +1262,13 @@ void multiway_merge_exact_splitting(\n  * @param __sentinel Ignored.\n  * @return End iterator of output sequence.\n  */\n-template<\n-    bool __stable,\n-    bool __sentinels,\n-    typename _RAIterIterator,\n-    typename _RAIter3,\n-    typename _DifferenceTp,\n-    typename _Splitter,\n-    typename _Compare\n-    >\n+template<bool __stable,\n+\t bool __sentinels,\n+\t typename _RAIterIterator,\n+\t typename _RAIter3,\n+\t typename _DifferenceTp,\n+\t typename _Splitter,\n+\t typename _Compare>\n   _RAIter3\n   parallel_multiway_merge(_RAIterIterator __seqs_begin,\n                           _RAIterIterator __seqs_end,\n@@ -1475,45 +1456,43 @@ template<\n  */\n // multiway_merge\n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-multiway_merge(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , __gnu_parallel::sequential_tag)\n-{\n-  typedef _DifferenceTp _DifferenceType;\n-  _GLIBCXX_CALL(__seqs_end - __seqs_begin)\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  multiway_merge(_RAIterPairIterator __seqs_begin,\n+\t\t _RAIterPairIterator __seqs_end,\n+\t\t _RAIterOut __target,\n+\t\t _DifferenceTp __length, _Compare __comp,\n+\t\t __gnu_parallel::sequential_tag)\n+  {\n+    typedef _DifferenceTp _DifferenceType;\n+    _GLIBCXX_CALL(__seqs_end - __seqs_begin)\n \n-  // catch special case: no sequences\n-  if (__seqs_begin == __seqs_end)\n-    return __target;\n+      // catch special case: no sequences\n+      if (__seqs_begin == __seqs_end)\n+\treturn __target;\n \n-  // Execute multiway merge *sequentially*.\n-  return __sequential_multiway_merge\n-    </* __stable = */ false, /* __sentinels = */ false>\n+    // Execute multiway merge *sequentially*.\n+    return __sequential_multiway_merge\n+      </* __stable = */ false, /* __sentinels = */ false>\n       (__seqs_begin, __seqs_end, __target,\n-      *(__seqs_begin->second), __length, __comp);\n-}\n+       *(__seqs_begin->second), __length, __comp);\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-multiway_merge(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , __gnu_parallel::exact_tag __tag)\n-{\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  multiway_merge(_RAIterPairIterator __seqs_begin,\n+\t\t _RAIterPairIterator __seqs_end,\n+\t\t _RAIterOut __target,\n+\t\t _DifferenceTp __length, _Compare __comp,\n+\t\t __gnu_parallel::exact_tag __tag)\n+  {\n     typedef _DifferenceTp _DifferenceType;\n     _GLIBCXX_CALL(__seqs_end - __seqs_begin)\n \n@@ -1543,21 +1522,20 @@ multiway_merge(_RAIterPairIterator __seqs_begin\n                       </* __stable = */ false, /* __sentinels = */ false>(\n                __seqs_begin, __seqs_end, __target, *(__seqs_begin->second),\n                __length, __comp);\n-}\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-multiway_merge(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , __gnu_parallel::sampling_tag __tag)\n-{\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  multiway_merge(_RAIterPairIterator __seqs_begin,\n+\t\t _RAIterPairIterator __seqs_end,\n+\t\t _RAIterOut __target,\n+\t\t _DifferenceTp __length, _Compare __comp,\n+\t\t __gnu_parallel::sampling_tag __tag)\n+  {\n     typedef _DifferenceTp _DifferenceType;\n     _GLIBCXX_CALL(__seqs_end - __seqs_begin)\n \n@@ -1588,56 +1566,53 @@ multiway_merge(_RAIterPairIterator __seqs_begin\n                       </* __stable = */ false, /* __sentinels = */ false>(\n           __seqs_begin, __seqs_end,\n           __target, *(__seqs_begin->second), __length, __comp);\n-}\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-multiway_merge(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , parallel_tag __tag = parallel_tag(0))\n-{\n-  return multiway_merge(__seqs_begin, __seqs_end, __target, __length, __comp,\n-                         exact_tag(__tag.__get_num_threads()));\n-}\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  multiway_merge(_RAIterPairIterator __seqs_begin,\n+\t\t _RAIterPairIterator __seqs_end,\n+\t\t _RAIterOut __target,\n+\t\t _DifferenceTp __length, _Compare __comp,\n+\t\t parallel_tag __tag = parallel_tag(0))\n+  {\n+    return multiway_merge(__seqs_begin, __seqs_end, __target, __length,\n+\t\t\t  __comp, exact_tag(__tag.__get_num_threads()));\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-multiway_merge(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , default_parallel_tag __tag)\n-{\n-  return multiway_merge(__seqs_begin, __seqs_end, __target, __length, __comp,\n-                         exact_tag(__tag.__get_num_threads()));\n-}\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  multiway_merge(_RAIterPairIterator __seqs_begin,\n+\t\t _RAIterPairIterator __seqs_end,\n+\t\t _RAIterOut __target,\n+\t\t _DifferenceTp __length, _Compare __comp,\n+\t\t default_parallel_tag __tag)\n+  {\n+    return multiway_merge(__seqs_begin, __seqs_end, __target, __length,\n+\t\t\t  __comp, exact_tag(__tag.__get_num_threads()));\n+  }\n \n // stable_multiway_merge\n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-stable_multiway_merge(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , __gnu_parallel::sequential_tag)\n-{\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  stable_multiway_merge(_RAIterPairIterator __seqs_begin,\n+\t\t\t_RAIterPairIterator __seqs_end,\n+\t\t\t_RAIterOut __target,\n+\t\t\t_DifferenceTp __length, _Compare __comp,\n+\t\t\t__gnu_parallel::sequential_tag)\n+  {\n     typedef _DifferenceTp _DifferenceType;\n     _GLIBCXX_CALL(__seqs_end - __seqs_begin)\n \n@@ -1650,21 +1625,20 @@ stable_multiway_merge(_RAIterPairIterator __seqs_begin\n       </* __stable = */ true, /* __sentinels = */ false>\n         (__seqs_begin, __seqs_end, __target, *(__seqs_begin->second), __length,\n          __comp);\n-}\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-stable_multiway_merge(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , __gnu_parallel::exact_tag __tag)\n-{\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  stable_multiway_merge(_RAIterPairIterator __seqs_begin,\n+\t\t\t_RAIterPairIterator __seqs_end,\n+\t\t\t_RAIterOut __target,\n+\t\t\t_DifferenceTp __length, _Compare __comp,\n+\t\t\t__gnu_parallel::exact_tag __tag)\n+  {\n     typedef _DifferenceTp _DifferenceType;\n     _GLIBCXX_CALL(__seqs_end - __seqs_begin)\n \n@@ -1695,21 +1669,20 @@ stable_multiway_merge(_RAIterPairIterator __seqs_begin\n         /* __sentinels = */ false>(\n           __seqs_begin, __seqs_end,\n           __target, *(__seqs_begin->second), __length, __comp);\n-}\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-stable_multiway_merge(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , sampling_tag __tag)\n-{\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  stable_multiway_merge(_RAIterPairIterator __seqs_begin,\n+\t\t\t_RAIterPairIterator __seqs_end,\n+\t\t\t_RAIterOut __target,\n+\t\t\t_DifferenceTp __length, _Compare __comp,\n+\t\t\tsampling_tag __tag)\n+  {\n     typedef _DifferenceTp _DifferenceType;\n     _GLIBCXX_CALL(__seqs_end - __seqs_begin)\n \n@@ -1740,44 +1713,41 @@ stable_multiway_merge(_RAIterPairIterator __seqs_begin\n         </* __stable = */ true, /* __sentinels = */ false>(\n           __seqs_begin, __seqs_end,\n           __target, *(__seqs_begin->second), __length, __comp);\n-}\n-\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-stable_multiway_merge(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , parallel_tag __tag = parallel_tag(0))\n-{\n-  return stable_multiway_merge(\n-           __seqs_begin, __seqs_end, __target, __length, __comp,\n-           exact_tag(__tag.__get_num_threads()));\n-}\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  stable_multiway_merge(_RAIterPairIterator __seqs_begin,\n+\t\t\t_RAIterPairIterator __seqs_end,\n+\t\t\t_RAIterOut __target,\n+\t\t\t_DifferenceTp __length, _Compare __comp,\n+\t\t\tparallel_tag __tag = parallel_tag(0))\n+  {\n+    return stable_multiway_merge\n+      (__seqs_begin, __seqs_end, __target, __length, __comp,\n+       exact_tag(__tag.__get_num_threads()));\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-stable_multiway_merge(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , default_parallel_tag __tag)\n-{\n-  return stable_multiway_merge(\n-           __seqs_begin, __seqs_end, __target, __length, __comp,\n-           exact_tag(__tag.__get_num_threads()));\n-}\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  stable_multiway_merge(_RAIterPairIterator __seqs_begin,\n+\t\t\t_RAIterPairIterator __seqs_end,\n+\t\t\t_RAIterOut __target,\n+\t\t\t_DifferenceTp __length, _Compare __comp,\n+\t\t\tdefault_parallel_tag __tag)\n+  {\n+    return stable_multiway_merge\n+      (__seqs_begin, __seqs_end, __target, __length, __comp,\n+       exact_tag(__tag.__get_num_threads()));\n+  }\n \n /**\n  * @brief Multiway Merge Frontend.\n@@ -1856,18 +1826,17 @@ stable_multiway_merge(_RAIterPairIterator __seqs_begin\n  */\n // multiway_merge_sentinels\n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , __gnu_parallel::sequential_tag)\n-{\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  multiway_merge_sentinels(_RAIterPairIterator __seqs_begin,\n+\t\t\t   _RAIterPairIterator __seqs_end,\n+\t\t\t   _RAIterOut __target,\n+\t\t\t   _DifferenceTp __length, _Compare __comp,\n+\t\t\t   __gnu_parallel::sequential_tag)\n+  {\n     typedef _DifferenceTp _DifferenceType;\n     _GLIBCXX_CALL(__seqs_end - __seqs_begin)\n \n@@ -1880,21 +1849,20 @@ multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n       </* __stable = */ false, /* __sentinels = */ true>\n         (__seqs_begin, __seqs_end,\n          __target, *(__seqs_begin->second), __length, __comp);\n-}\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , __gnu_parallel::exact_tag __tag)\n-{\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  multiway_merge_sentinels(_RAIterPairIterator __seqs_begin,\n+\t\t\t   _RAIterPairIterator __seqs_end,\n+\t\t\t   _RAIterOut __target,\n+\t\t\t   _DifferenceTp __length, _Compare __comp,\n+\t\t\t   __gnu_parallel::exact_tag __tag)\n+  {\n     typedef _DifferenceTp _DifferenceType;\n     _GLIBCXX_CALL(__seqs_end - __seqs_begin)\n \n@@ -1925,21 +1893,20 @@ multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n         </* __stable = */ false, /* __sentinels = */ true>(\n           __seqs_begin, __seqs_end,\n           __target, *(__seqs_begin->second), __length, __comp);\n-}\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , sampling_tag __tag)\n-{\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  multiway_merge_sentinels(_RAIterPairIterator __seqs_begin,\n+\t\t\t   _RAIterPairIterator __seqs_end,\n+\t\t\t   _RAIterOut __target,\n+\t\t\t   _DifferenceTp __length, _Compare __comp,\n+\t\t\t   sampling_tag __tag)\n+  {\n     typedef _DifferenceTp _DifferenceType;\n     _GLIBCXX_CALL(__seqs_end - __seqs_begin)\n \n@@ -1969,58 +1936,55 @@ multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n         </* __stable = */false, /* __sentinels = */ true>(\n           __seqs_begin, __seqs_end,\n           __target, *(__seqs_begin->second), __length, __comp);\n-}\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , parallel_tag __tag = parallel_tag(0))\n-{\n-  return multiway_merge_sentinels(\n-           __seqs_begin, __seqs_end, __target, __length, __comp,\n-           exact_tag(__tag.__get_num_threads()));\n-}\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  multiway_merge_sentinels(_RAIterPairIterator __seqs_begin,\n+\t\t\t   _RAIterPairIterator __seqs_end,\n+\t\t\t   _RAIterOut __target,\n+\t\t\t   _DifferenceTp __length, _Compare __comp,\n+\t\t\t   parallel_tag __tag = parallel_tag(0))\n+  {\n+    return multiway_merge_sentinels\n+      (__seqs_begin, __seqs_end, __target, __length, __comp,\n+       exact_tag(__tag.__get_num_threads()));\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , default_parallel_tag __tag)\n-{\n-  return multiway_merge_sentinels(\n-           __seqs_begin, __seqs_end, __target, __length, __comp,\n-           exact_tag(__tag.__get_num_threads()));\n-}\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  multiway_merge_sentinels(_RAIterPairIterator __seqs_begin,\n+\t\t\t   _RAIterPairIterator __seqs_end,\n+\t\t\t   _RAIterOut __target,\n+\t\t\t   _DifferenceTp __length, _Compare __comp,\n+\t\t\t   default_parallel_tag __tag)\n+  {\n+    return multiway_merge_sentinels\n+      (__seqs_begin, __seqs_end, __target, __length, __comp,\n+       exact_tag(__tag.__get_num_threads()));\n+  }\n \n // stable_multiway_merge_sentinels\n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , __gnu_parallel::sequential_tag)\n-{\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin,\n+\t\t\t\t  _RAIterPairIterator __seqs_end,\n+\t\t\t\t  _RAIterOut __target,\n+\t\t\t\t  _DifferenceTp __length, _Compare __comp,\n+\t\t\t\t  __gnu_parallel::sequential_tag)\n+  {\n     typedef _DifferenceTp _DifferenceType;\n     _GLIBCXX_CALL(__seqs_end - __seqs_begin)\n \n@@ -2031,23 +1995,22 @@ stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n     // Execute multiway merge *sequentially*.\n     return __sequential_multiway_merge\n       </* __stable = */ true, /* __sentinels = */ true>\n-        (__seqs_begin, __seqs_end, __target, *(__seqs_begin->second), __length,\n-         __comp);\n-}\n+        (__seqs_begin, __seqs_end, __target, *(__seqs_begin->second),\n+\t __length, __comp);\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , __gnu_parallel::exact_tag __tag)\n-{\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin,\n+\t\t\t\t  _RAIterPairIterator __seqs_end,\n+\t\t\t\t  _RAIterOut __target,\n+\t\t\t\t  _DifferenceTp __length, _Compare __comp,\n+\t\t\t\t  __gnu_parallel::exact_tag __tag)\n+  {\n     typedef _DifferenceTp _DifferenceType;\n     _GLIBCXX_CALL(__seqs_end - __seqs_begin)\n \n@@ -2078,21 +2041,21 @@ stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n         </* __stable = */ true, /* __sentinels = */ true>(\n           __seqs_begin, __seqs_end, __target, *(__seqs_begin->second),\n           __length, __comp);\n-}\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , sampling_tag __tag)\n-{\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin,\n+\t\t\t\t  _RAIterPairIterator __seqs_end,\n+\t\t\t\t  _RAIterOut __target,\n+\t\t\t\t  _DifferenceTp __length,\n+\t\t\t\t  _Compare __comp,\n+\t\t\t\t  sampling_tag __tag)\n+  {\n     typedef _DifferenceTp _DifferenceType;\n     _GLIBCXX_CALL(__seqs_end - __seqs_begin)\n \n@@ -2123,43 +2086,42 @@ stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n         </* __stable = */ true, /* __sentinels = */ true>(\n           __seqs_begin, __seqs_end,\n           __target, *(__seqs_begin->second), __length, __comp);\n-}\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , parallel_tag __tag = parallel_tag(0))\n-{\n-  return stable_multiway_merge_sentinels(\n-           __seqs_begin, __seqs_end, __target, __length, __comp,\n-           exact_tag(__tag.__get_num_threads()));\n-}\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin,\n+\t\t\t\t  _RAIterPairIterator __seqs_end,\n+\t\t\t\t  _RAIterOut __target,\n+\t\t\t\t  _DifferenceTp __length,\n+\t\t\t\t  _Compare __comp,\n+\t\t\t\t  parallel_tag __tag = parallel_tag(0))\n+  {\n+    return stable_multiway_merge_sentinels\n+      (__seqs_begin, __seqs_end, __target, __length, __comp,\n+       exact_tag(__tag.__get_num_threads()));\n+  }\n \n // public interface\n-template<\n-    typename _RAIterPairIterator\n-  , typename _RAIterOut\n-  , typename _DifferenceTp\n-  , typename _Compare>\n-_RAIterOut\n-stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin\n-    , _RAIterPairIterator __seqs_end\n-    , _RAIterOut __target\n-    , _DifferenceTp __length, _Compare __comp\n-    , default_parallel_tag __tag)\n-{\n-  return stable_multiway_merge_sentinels(\n-           __seqs_begin, __seqs_end, __target, __length, __comp,\n-           exact_tag(__tag.__get_num_threads()));\n-}\n+template<typename _RAIterPairIterator,\n+\t typename _RAIterOut,\n+\t typename _DifferenceTp,\n+\t typename _Compare>\n+  _RAIterOut\n+  stable_multiway_merge_sentinels(_RAIterPairIterator __seqs_begin,\n+\t\t\t\t  _RAIterPairIterator __seqs_end,\n+\t\t\t\t  _RAIterOut __target,\n+\t\t\t\t  _DifferenceTp __length, _Compare __comp,\n+\t\t\t\t  default_parallel_tag __tag)\n+  {\n+    return stable_multiway_merge_sentinels\n+      (__seqs_begin, __seqs_end, __target, __length, __comp,\n+       exact_tag(__tag.__get_num_threads()));\n+  }\n \n }; // namespace __gnu_parallel\n "}]}