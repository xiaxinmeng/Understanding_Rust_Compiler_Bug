{"sha": "7a41fcde6c67faafab8c8ee2a31140999383dcef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E0MWZjZGU2YzY3ZmFhZmFiOGM4ZWUyYTMxMTQwOTk5MzgzZGNlZg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-05-18T21:24:12Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-05-18T21:24:12Z"}, "message": "PR middle-end/92815 - spurious -Wstringop-overflow writing into a flexible array of an extern struct\n\ngcc/ChangeLog:\n\n\tPR middle-end/92815\n\t* tree-object-size.c (decl_init_size): New function.\n\t(addr_object_size): Call it.\n\t* tree.h (last_field): Declare.\n\t(first_field): Add attribute nonnull.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/92815\n\t* gcc.dg/Warray-bounds-56.c: Remove xfails.\n\t* gcc.dg/builtin-object-size-20.c: New test.\n\t* gcc.dg/builtin-object-size-21.c: New test.", "tree": {"sha": "05c39a4f7d249ebd4878d1b392aa0ba747a96a85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05c39a4f7d249ebd4878d1b392aa0ba747a96a85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a41fcde6c67faafab8c8ee2a31140999383dcef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a41fcde6c67faafab8c8ee2a31140999383dcef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a41fcde6c67faafab8c8ee2a31140999383dcef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a41fcde6c67faafab8c8ee2a31140999383dcef/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3956244c58acceebf1ef2cf9a63e99f0f82abcb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3956244c58acceebf1ef2cf9a63e99f0f82abcb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3956244c58acceebf1ef2cf9a63e99f0f82abcb7"}], "stats": {"total": 456, "additions": 439, "deletions": 17}, "files": [{"sha": "c100737c4316fc7a5432f1fa3bdc5f6dc272ada7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a41fcde6c67faafab8c8ee2a31140999383dcef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a41fcde6c67faafab8c8ee2a31140999383dcef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a41fcde6c67faafab8c8ee2a31140999383dcef", "patch": "@@ -1,3 +1,11 @@\n+2020-05-18  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/92815\n+\t* tree-object-size.c (decl_init_size): New function.\n+\t(addr_object_size): Call it.\n+\t* tree.h (last_field): Declare.\n+\t(first_field): Add attribute nonnull.\n+\n 2020-05-18  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/94940"}, {"sha": "453e581a3facbb922720c94c159c48b0bb28bf54", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a41fcde6c67faafab8c8ee2a31140999383dcef/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a41fcde6c67faafab8c8ee2a31140999383dcef/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7a41fcde6c67faafab8c8ee2a31140999383dcef", "patch": "@@ -1,3 +1,10 @@\n+2020-05-18  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/92815\n+\t* gcc.dg/Warray-bounds-56.c: Remove xfails.\n+\t* gcc.dg/builtin-object-size-20.c: New test.\n+\t* gcc.dg/builtin-object-size-21.c: New test.\n+\n 2020-05-18  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/94940"}, {"sha": "04c26a659adc0b225e11923432ff83cae55cf493", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-56.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a41fcde6c67faafab8c8ee2a31140999383dcef/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-56.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a41fcde6c67faafab8c8ee2a31140999383dcef/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-56.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-56.c?ref=7a41fcde6c67faafab8c8ee2a31140999383dcef", "patch": "@@ -42,8 +42,8 @@ struct Flex f3 = { 3, { 1, 2, 3 } };\n \n NOIPA void test_strcpy_flexarray (void)\n {\n-  T (S (0), fx);                // { dg-bogus \"\\\\\\[-Warray-bounds\" \"pr92815\" { xfail *-*-*} }\n-  T (S (9), fx);                // { dg-bogus \"\\\\\\[-Warray-bounds\" \"pr92815\" { xfail *-*-*} }\n+  T (S (0), fx);                // { dg-bogus \"\\\\\\[-Warray-bounds\" \"pr92815\" }\n+  T (S (9), fx);                // { dg-bogus \"\\\\\\[-Warray-bounds\" \"pr92815\" }\n \n   T (S (0), f1);\n   T (S (1), f1);                // { dg-warning \"\\\\\\[-Warray-bounds\" }"}, {"sha": "47821c06d7685d58f50474461085c68997594c28", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-20.c", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a41fcde6c67faafab8c8ee2a31140999383dcef/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a41fcde6c67faafab8c8ee2a31140999383dcef/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-20.c?ref=7a41fcde6c67faafab8c8ee2a31140999383dcef", "patch": "@@ -0,0 +1,315 @@\n+/* PR middle-end/92815 - spurious -Wstringop-overflow writing into\n+   a flexible array of an extern struct\n+   { dg-do compile }\n+   { dg-options \"-Wall -fdump-tree-optimized\" } */\n+\n+#define ASSERT(expr) ((expr) ? (void)0 : fail (__LINE__))\n+#define bos0(expr) __builtin_object_size (expr, 1)\n+#define bos1(expr) __builtin_object_size (expr, 1)\n+#define bos2(expr) __builtin_object_size (expr, 2)\n+#define bos3(expr) __builtin_object_size (expr, 3)\n+\n+typedef __INT16_TYPE__ int16_t;\n+typedef __INT32_TYPE__ int32_t;\n+typedef __INT64_TYPE__ int64_t;\n+typedef __SIZE_TYPE__  size_t;\n+\n+\n+extern void fail (int);\n+\n+\n+/* Verify sizes of a struct with a flexible array member and no padding.  */\n+\n+struct ACX { char n, a[]; };\n+\n+struct ACX ac0 = { };\n+struct ACX ac1 = { 1, { 1 } };\n+struct ACX ac2 = { 2, { 1, 2 } };\n+struct ACX ac3 = { 3, { 1, 2, 3 } };\n+\n+extern struct ACX eacx;\n+\n+void facx (void)\n+{\n+  ASSERT (bos0 (&ac0) == sizeof ac0);\n+  ASSERT (bos0 (&ac1) == 2);\n+  ASSERT (bos0 (&ac2) == 3);\n+  ASSERT (bos0 (&ac3) == 4);\n+  ASSERT (bos0 (&eacx) == (size_t)-1);\n+\n+  ASSERT (bos1 (&ac0) == sizeof ac0);\n+  ASSERT (bos1 (&ac1) == 2);\n+  ASSERT (bos1 (&ac2) == 3);\n+  ASSERT (bos1 (&ac3) == 4);\n+  ASSERT (bos1 (&eacx) == (size_t)-1);\n+\n+  ASSERT (bos2 (&ac0) == sizeof ac0);\n+  ASSERT (bos2 (&ac1) == 2);\n+  ASSERT (bos2 (&ac2) == 3);\n+  ASSERT (bos2 (&ac3) == 4);\n+  ASSERT (bos2 (&eacx) == sizeof eacx);\n+\n+  ASSERT (bos3 (&ac0) == sizeof ac0);\n+  ASSERT (bos3 (&ac1) == 2);\n+  ASSERT (bos3 (&ac2) == 3);\n+  ASSERT (bos3 (&ac3) == 4);\n+  ASSERT (bos3 (&eacx) == sizeof eacx);\n+}\n+\n+\n+\n+/* Verify sizes of a struct with a flexible array member and 1 byte\n+   of tail padding.  */\n+\n+struct AI16CX { int16_t i; char n, a[]; };\n+\n+struct AI16CX ai16c0 = { 0 };\n+struct AI16CX ai16c1 = { 0, 1, { 1 } };\n+struct AI16CX ai16c2 = { 0, 2, { 1, 2 } };\n+struct AI16CX ai16c3 = { 0, 3, { 1, 2, 3 } };\n+struct AI16CX ai16c4 = { 0, 4, { 1, 2, 3, 4 } };\n+struct AI16CX ai16c5 = { 0, 5, { 1, 2, 3, 4, 5 } };\n+struct AI16CX ai16c6 = { 0, 6, { 1, 2, 3, 4, 5, 6 } };\n+struct AI16CX ai16c7 = { 0, 7, { 1, 2, 3, 4, 5, 6, 7 } };\n+struct AI16CX ai16c8 = { 0, 8, { 1, 2, 3, 4, 5, 6, 7, 8 } };\n+\n+extern struct AI16CX eai16cx;\n+\n+void fai16cx (void)\n+{\n+  ASSERT (bos0 (&ai16c0) == sizeof ai16c0);\n+  ASSERT (bos0 (&ai16c1) == sizeof ai16c1);\n+  ASSERT (bos0 (&ai16c2) == sizeof ai16c2 + 1);\n+  ASSERT (bos0 (&ai16c3) == sizeof ai16c3 + 2);\n+\n+  ASSERT (bos0 (&ai16c4) == sizeof ai16c4 + 3);\n+  ASSERT (bos0 (&ai16c5) == sizeof ai16c5 + 4);\n+  ASSERT (bos0 (&ai16c6) == sizeof ai16c6 + 5);\n+  ASSERT (bos0 (&ai16c7) == sizeof ai16c6 + 6);\n+  ASSERT (bos0 (&ai16c8) == sizeof ai16c6 + 7);\n+\n+  ASSERT (bos0 (&eai16cx) == (size_t)-1);\n+\n+\n+  ASSERT (bos1 (&ai16c0) == sizeof ai16c0);\n+  ASSERT (bos1 (&ai16c1) == sizeof ai16c1);\n+  ASSERT (bos1 (&ai16c2) == sizeof ai16c2 + 1);\n+  ASSERT (bos1 (&ai16c3) == sizeof ai16c3 + 2);\n+\n+  ASSERT (bos1 (&ai16c4) == sizeof ai16c4 + 3);\n+  ASSERT (bos1 (&ai16c5) == sizeof ai16c5 + 4);\n+  ASSERT (bos1 (&ai16c6) == sizeof ai16c6 + 5);\n+  ASSERT (bos1 (&ai16c7) == sizeof ai16c6 + 6);\n+  ASSERT (bos1 (&ai16c8) == sizeof ai16c6 + 7);\n+\n+  ASSERT (bos1 (&eai16cx) == (size_t)-1);\n+\n+\n+  ASSERT (bos2 (&ai16c0) == sizeof ai16c0);\n+  ASSERT (bos2 (&ai16c1) == sizeof ai16c1);\n+  ASSERT (bos2 (&ai16c2) == sizeof ai16c2 + 1);\n+  ASSERT (bos2 (&ai16c3) == sizeof ai16c3 + 2);\n+\n+  ASSERT (bos2 (&ai16c4) == sizeof ai16c4 + 3);\n+  ASSERT (bos2 (&ai16c5) == sizeof ai16c5 + 4);\n+  ASSERT (bos2 (&ai16c6) == sizeof ai16c6 + 5);\n+  ASSERT (bos2 (&ai16c7) == sizeof ai16c6 + 6);\n+  ASSERT (bos2 (&ai16c8) == sizeof ai16c6 + 7);\n+\n+  ASSERT (bos2 (&eai16cx) == sizeof eai16cx);\n+\n+\n+  ASSERT (bos3 (&ai16c0) == sizeof ai16c0);\n+  ASSERT (bos3 (&ai16c1) == sizeof ai16c1);\n+  ASSERT (bos3 (&ai16c2) == sizeof ai16c2 + 1);\n+  ASSERT (bos3 (&ai16c3) == sizeof ai16c3 + 2);\n+\n+  ASSERT (bos3 (&ai16c4) == sizeof ai16c4 + 3);\n+  ASSERT (bos3 (&ai16c5) == sizeof ai16c5 + 4);\n+  ASSERT (bos3 (&ai16c6) == sizeof ai16c6 + 5);\n+  ASSERT (bos3 (&ai16c7) == sizeof ai16c6 + 6);\n+  ASSERT (bos3 (&ai16c8) == sizeof ai16c6 + 7);\n+\n+  ASSERT (bos3 (&eai16cx) == sizeof eai16cx);\n+}\n+\n+\n+/* Verify sizes of a struct with a flexible array member and 3 bytes\n+   of tail padding.  */\n+\n+struct AI32CX { int32_t i; char n, a[]; };\n+\n+struct AI32CX ai32c0 = { 0 };\n+struct AI32CX ai32c1 = { 0, 1, { 1 } };\n+struct AI32CX ai32c2 = { 0, 2, { 1, 2 } };\n+struct AI32CX ai32c3 = { 0, 3, { 1, 2, 3 } };\n+struct AI32CX ai32c4 = { 0, 4, { 1, 2, 3, 4 } };\n+struct AI32CX ai32c5 = { 0, 5, { 1, 2, 3, 4, 5 } };\n+struct AI32CX ai32c6 = { 0, 6, { 1, 2, 3, 4, 5, 6 } };\n+struct AI32CX ai32c7 = { 0, 7, { 1, 2, 3, 4, 5, 6, 7 } };\n+struct AI32CX ai32c8 = { 0, 8, { 1, 2, 3, 4, 5, 6, 7, 8 } };\n+\n+extern struct AI32CX eai32cx;\n+\n+void fai32cx (void)\n+{\n+  ASSERT (bos0 (&ai32c0) == sizeof ai32c0);\n+  ASSERT (bos0 (&ai32c1) == sizeof ai32c1);\n+  ASSERT (bos0 (&ai32c2) == sizeof ai32c2);\n+  ASSERT (bos0 (&ai32c3) == sizeof ai32c3);\n+\n+  ASSERT (bos0 (&ai32c4) == sizeof ai32c4 + 1);\n+  ASSERT (bos0 (&ai32c5) == sizeof ai32c5 + 2);\n+  ASSERT (bos0 (&ai32c6) == sizeof ai32c6 + 3);\n+  ASSERT (bos0 (&ai32c7) == sizeof ai32c6 + 4);\n+  ASSERT (bos0 (&ai32c8) == sizeof ai32c6 + 5);\n+\n+  ASSERT (bos0 (&eai32cx) == (size_t)-1);\n+\n+\n+  ASSERT (bos1 (&ai32c0) == sizeof ai32c0);\n+  ASSERT (bos1 (&ai32c1) == sizeof ai32c1);\n+  ASSERT (bos1 (&ai32c2) == sizeof ai32c2);\n+  ASSERT (bos1 (&ai32c3) == sizeof ai32c3);\n+\n+  ASSERT (bos1 (&ai32c4) == sizeof ai32c4 + 1);\n+  ASSERT (bos1 (&ai32c5) == sizeof ai32c5 + 2);\n+  ASSERT (bos1 (&ai32c6) == sizeof ai32c6 + 3);\n+  ASSERT (bos1 (&ai32c7) == sizeof ai32c6 + 4);\n+  ASSERT (bos1 (&ai32c8) == sizeof ai32c6 + 5);\n+\n+  ASSERT (bos1 (&eai32cx) == (size_t)-1);\n+\n+\n+  ASSERT (bos2 (&ai32c0) == sizeof ai32c0);\n+  ASSERT (bos2 (&ai32c1) == sizeof ai32c1);\n+  ASSERT (bos2 (&ai32c2) == sizeof ai32c2);\n+  ASSERT (bos2 (&ai32c3) == sizeof ai32c3);\n+\n+  ASSERT (bos2 (&ai32c4) == sizeof ai32c4 + 1);\n+  ASSERT (bos2 (&ai32c5) == sizeof ai32c5 + 2);\n+  ASSERT (bos2 (&ai32c6) == sizeof ai32c6 + 3);\n+  ASSERT (bos2 (&ai32c7) == sizeof ai32c6 + 4);\n+  ASSERT (bos2 (&ai32c8) == sizeof ai32c6 + 5);\n+\n+  ASSERT (bos2 (&eai32cx) == sizeof eai32cx);\n+\n+\n+  ASSERT (bos3 (&ai32c0) == sizeof ai32c0);\n+  ASSERT (bos3 (&ai32c1) == sizeof ai32c1);\n+  ASSERT (bos3 (&ai32c2) == sizeof ai32c2);\n+  ASSERT (bos3 (&ai32c3) == sizeof ai32c3);\n+\n+  ASSERT (bos3 (&ai32c4) == sizeof ai32c4 + 1);\n+  ASSERT (bos3 (&ai32c5) == sizeof ai32c5 + 2);\n+  ASSERT (bos3 (&ai32c6) == sizeof ai32c6 + 3);\n+  ASSERT (bos3 (&ai32c7) == sizeof ai32c6 + 4);\n+  ASSERT (bos3 (&ai32c8) == sizeof ai32c6 + 5);\n+\n+  ASSERT (bos3 (&eai32cx) == sizeof eai32cx);\n+}\n+\n+\n+/* Verify sizes of a struct with a flexible array member and 7 bytes\n+   of tail padding.  */\n+\n+struct AI64CX { int64_t i; char n, a[]; };\n+\n+struct AI64CX ai64c0 = { 0 };\n+struct AI64CX ai64c1 = { 0, 1, { 1 } };\n+struct AI64CX ai64c2 = { 0, 2, { 1, 2 } };\n+struct AI64CX ai64c3 = { 0, 3, { 1, 2, 3 } };\n+struct AI64CX ai64c4 = { 0, 4, { 1, 2, 3, 4 } };\n+struct AI64CX ai64c5 = { 0, 5, { 1, 2, 3, 4, 5 } };\n+struct AI64CX ai64c6 = { 0, 6, { 1, 2, 3, 4, 5, 6 } };\n+struct AI64CX ai64c7 = { 0, 7, { 1, 2, 3, 4, 5, 6, 7 } };\n+struct AI64CX ai64c8 = { 0, 8, { 1, 2, 3, 4, 5, 6, 7, 8 } };\n+struct AI64CX ai64c9 = { 0, 8, { 1, 2, 3, 4, 5, 6, 7, 8, 9 } };\n+\n+extern struct AI64CX eai64cx;\n+\n+void fai64cx (void)\n+{\n+  ASSERT (bos0 (&ai64c0) == sizeof ai64c0);\n+  ASSERT (bos0 (&ai64c1) == sizeof ai64c1);\n+  ASSERT (bos0 (&ai64c2) == sizeof ai64c2);\n+  ASSERT (bos0 (&ai64c3) == sizeof ai64c3);\n+  ASSERT (bos0 (&ai64c4) == sizeof ai64c4);\n+  ASSERT (bos0 (&ai64c5) == sizeof ai64c5);\n+  ASSERT (bos0 (&ai64c6) == sizeof ai64c6);\n+  ASSERT (bos0 (&ai64c7) == sizeof ai64c7);\n+\n+  ASSERT (bos0 (&ai64c8) == sizeof ai64c8 + 1);\n+  ASSERT (bos0 (&ai64c9) == sizeof ai64c9 + 2);\n+\n+  ASSERT (bos0 (&eai64cx) == (size_t)-1);\n+\n+\n+  ASSERT (bos1 (&ai64c0) == sizeof ai64c0);\n+  ASSERT (bos1 (&ai64c1) == sizeof ai64c1);\n+  ASSERT (bos1 (&ai64c2) == sizeof ai64c2);\n+  ASSERT (bos1 (&ai64c3) == sizeof ai64c3);\n+  ASSERT (bos1 (&ai64c4) == sizeof ai64c4);\n+  ASSERT (bos1 (&ai64c5) == sizeof ai64c5);\n+  ASSERT (bos1 (&ai64c6) == sizeof ai64c6);\n+  ASSERT (bos1 (&ai64c7) == sizeof ai64c7);\n+\n+  ASSERT (bos1 (&ai64c8) == sizeof ai64c8 + 1);\n+  ASSERT (bos1 (&ai64c9) == sizeof ai64c9 + 2);\n+\n+  ASSERT (bos1 (&eai64cx) == (size_t)-1);\n+\n+\n+  ASSERT (bos2 (&ai64c0) == sizeof ai64c0);\n+  ASSERT (bos2 (&ai64c1) == sizeof ai64c1);\n+  ASSERT (bos2 (&ai64c2) == sizeof ai64c2);\n+  ASSERT (bos2 (&ai64c3) == sizeof ai64c3);\n+  ASSERT (bos2 (&ai64c4) == sizeof ai64c4);\n+  ASSERT (bos2 (&ai64c5) == sizeof ai64c5);\n+  ASSERT (bos2 (&ai64c6) == sizeof ai64c6);\n+  ASSERT (bos2 (&ai64c7) == sizeof ai64c7);\n+\n+  ASSERT (bos2 (&ai64c8) == sizeof ai64c8 + 1);\n+  ASSERT (bos2 (&ai64c9) == sizeof ai64c9 + 2);\n+\n+  ASSERT (bos2 (&eai64cx) == sizeof eai64cx);\n+\n+  ASSERT (bos3 (&ai64c0) == sizeof ai64c0);\n+  ASSERT (bos3 (&ai64c1) == sizeof ai64c1);\n+  ASSERT (bos3 (&ai64c2) == sizeof ai64c2);\n+  ASSERT (bos3 (&ai64c3) == sizeof ai64c3);\n+  ASSERT (bos3 (&ai64c4) == sizeof ai64c4);\n+  ASSERT (bos3 (&ai64c5) == sizeof ai64c5);\n+  ASSERT (bos3 (&ai64c6) == sizeof ai64c6);\n+  ASSERT (bos3 (&ai64c7) == sizeof ai64c7);\n+\n+  ASSERT (bos3 (&ai64c8) == sizeof ai64c8 + 1);\n+  ASSERT (bos3 (&ai64c9) == sizeof ai64c9 + 2);\n+\n+  ASSERT (bos3 (&eai64cx) == sizeof eai64cx);\n+}\n+\n+\n+/* Also verify sizes of a struct with a zero length array member.  */\n+\n+struct A0C0 { char n, a[0]; };\n+\n+struct A0C0 a0c0 = { };\n+extern struct A0C0 ea0c0;\n+\n+void fa0c0 (void)\n+{\n+  ASSERT (bos0 (&a0c0) == sizeof a0c0);\n+  ASSERT (bos0 (&ea0c0) == sizeof ea0c0);\n+\n+  ASSERT (bos1 (&a0c0) == sizeof a0c0);\n+  ASSERT (bos1 (&a0c0) == sizeof ea0c0);\n+\n+  ASSERT (bos2 (&a0c0) == sizeof a0c0);\n+  ASSERT (bos2 (&a0c0) == sizeof ea0c0);\n+\n+  ASSERT (bos3 (&a0c0) == sizeof a0c0);\n+  ASSERT (bos3 (&a0c0) == sizeof ea0c0);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"fail\" \"optimized\" } } */"}, {"sha": "1c42374ba892294f50aeb8d2c58f109b56359152", "filename": "gcc/testsuite/gcc.dg/builtin-object-size-21.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a41fcde6c67faafab8c8ee2a31140999383dcef/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a41fcde6c67faafab8c8ee2a31140999383dcef/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-object-size-21.c?ref=7a41fcde6c67faafab8c8ee2a31140999383dcef", "patch": "@@ -0,0 +1,51 @@\n+/* PR middle-end/92815 - spurious -Wstringop-overflow writing into\n+   a flexible array of an extern struct\n+   { dg-do compile }\n+   { dg-options \"-Wall -fdump-tree-optimized\" } */\n+\n+#define PTRDIFF_MAX __PTRDIFF_MAX__\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define bos0(expr) __builtin_object_size (expr, 0)\n+#define bos1(expr) __builtin_object_size (expr, 1)\n+#define bos2(expr) __builtin_object_size (expr, 2)\n+#define bos3(expr) __builtin_object_size (expr, 3)\n+\n+void fail (const char*, ...);\n+\n+#define A(x, n01, n23)\t\t\t\t\t\t\t\\\n+  ((bos0 (&x) == n01 ? (void)0 : fail (#x, __LINE__, bos0 (&x), n01)),\t\\\n+   (bos1 (&x) == n01 ? (void)0 : fail (#x, __LINE__, bos1 (&x), n01)),\t\\\n+   (bos2 (&x) == n23 ? (void)0 : fail (#x, __LINE__, bos2 (&x), n23)),\t\\\n+   (bos3 (&x) == n23 ? (void)0 : fail (#x, __LINE__, bos3 (&x), n23)))\n+\n+struct Ax_m3 { char a[PTRDIFF_MAX - 3], ax[]; };\n+\n+struct Ax_m3 xm3_0 = { { 0 } };\n+struct Ax_m3 xm3_1 = { { 0 }, { 1 } };\n+struct Ax_m3 xm3_2 = { { 0 }, { 1, 2 } };\n+struct Ax_m3 xm3_3 = { { 0 }, { 1, 2, 3 } };\n+struct Ax_m3 xm3_4 = { { 0 }, { 1, 2, 3, 3 } };   // { dg-error \"too large\" }\n+\n+void test_axm3 (void)\n+{\n+  A (xm3_0, sizeof xm3_0, sizeof xm3_0);\n+  A (xm3_1, sizeof xm3_1 + 1, sizeof xm3_1 + 1);\n+  A (xm3_2, sizeof xm3_2 + 2, sizeof xm3_2 + 2);\n+  A (xm3_3, (size_t)-1, 0);   // expect failure\n+  A (xm3_4, (size_t)-1, 0);   // expect failure\n+}\n+\n+\n+struct Ax_mx { char a[PTRDIFF_MAX], ax[]; };\n+struct Ax_mx xmx_0 = { { 0 } };\n+struct Ax_mx xmx_1 = { { 0 }, { 1 } };            // { dg-error \"too large\" }\n+extern struct Ax_mx xmx_x;\n+\n+void test_axmx (void)\n+{\n+  A (xmx_0, (size_t)-1, 0);   // expect failure\n+  A (xmx_1, (size_t)-1, 0);   // expect failure\n+  A (xmx_x, (size_t)-1, 0);   // expect failure\n+}"}, {"sha": "8855065f5774a328e156477b18e7a701ca7f20b5", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 53, "deletions": 13, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a41fcde6c67faafab8c8ee2a31140999383dcef/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a41fcde6c67faafab8c8ee2a31140999383dcef/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=7a41fcde6c67faafab8c8ee2a31140999383dcef", "patch": "@@ -166,6 +166,42 @@ compute_object_offset (const_tree expr, const_tree var)\n   return size_binop (code, base, off);\n }\n \n+/* Returns the size of the object designated by DECL considering its\n+   initializer if it either has one or if it would not affect its size,\n+   otherwise the size of the object without the initializer when MIN\n+   is true, else null.  An object's initializer affects the object's\n+   size if it's a struct type with a flexible array member.  */\n+\n+static tree\n+decl_init_size (tree decl, bool min)\n+{\n+  tree size = DECL_SIZE_UNIT (decl);\n+  tree type = TREE_TYPE (decl);\n+  if (TREE_CODE (type) != RECORD_TYPE)\n+    return size;\n+\n+  tree last = last_field (type);\n+  if (!last)\n+    return size;\n+\n+  tree last_type = TREE_TYPE (last);\n+  if (TREE_CODE (last_type) != ARRAY_TYPE\n+      || TYPE_SIZE (last_type))\n+    return size;\n+\n+  /* Use TYPE_SIZE_UNIT; DECL_SIZE_UNIT sometimes reflects the size\n+     of the initializer and sometimes doesn't.  */\n+  size = TYPE_SIZE_UNIT (type);\n+  tree ref = build3 (COMPONENT_REF, type, decl, last, NULL_TREE);\n+  tree compsize = component_ref_size (ref);\n+  if (!compsize)\n+    return min ? size : NULL_TREE;\n+\n+  /* The size includes tail padding and initializer elements.  */\n+  tree pos = byte_position (last);\n+  size = fold_build2 (PLUS_EXPR, TREE_TYPE (size), pos, compsize);\n+  return size;\n+}\n \n /* Compute __builtin_object_size for PTR, which is a ADDR_EXPR.\n    OBJECT_SIZE_TYPE is the second argument from __builtin_object_size.\n@@ -194,8 +230,10 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n   while (handled_component_p (pt_var))\n     pt_var = TREE_OPERAND (pt_var, 0);\n \n-  if (pt_var\n-      && TREE_CODE (pt_var) == MEM_REF)\n+  if (!pt_var)\n+    return false;\n+\n+  if (TREE_CODE (pt_var) == MEM_REF)\n     {\n       unsigned HOST_WIDE_INT sz;\n \n@@ -236,24 +274,26 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n       if (sz != unknown[object_size_type] && sz < offset_limit)\n \tpt_var_size = size_int (sz);\n     }\n-  else if (pt_var\n-\t   && DECL_P (pt_var)\n-\t   && tree_fits_uhwi_p (DECL_SIZE_UNIT (pt_var))\n-\t   && tree_to_uhwi (DECL_SIZE_UNIT (pt_var)) < offset_limit)\n+  else if (DECL_P (pt_var))\n     {\n       *pdecl = pt_var;\n-      pt_var_size = DECL_SIZE_UNIT (pt_var);\n+      pt_var_size = decl_init_size (pt_var, object_size_type & 2);\n+      if (!pt_var_size)\n+\treturn false;\n     }\n-  else if (pt_var\n-\t   && TREE_CODE (pt_var) == STRING_CST\n-\t   && TYPE_SIZE_UNIT (TREE_TYPE (pt_var))\n-\t   && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (pt_var)))\n-\t   && tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (pt_var)))\n-\t      < offset_limit)\n+  else if (TREE_CODE (pt_var) == STRING_CST)\n     pt_var_size = TYPE_SIZE_UNIT (TREE_TYPE (pt_var));\n   else\n     return false;\n \n+  if (pt_var_size)\n+    {\n+      /* Validate the size determined above.  */\n+      if (!tree_fits_uhwi_p (pt_var_size)\n+\t  || tree_to_uhwi (pt_var_size) >= offset_limit)\n+\treturn false;\n+    }\n+\n   if (pt_var != TREE_OPERAND (ptr, 0))\n     {\n       tree var;"}, {"sha": "0c8585f6e22788fd1ebf10fe26d47f41f2efb7b8", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a41fcde6c67faafab8c8ee2a31140999383dcef/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a41fcde6c67faafab8c8ee2a31140999383dcef/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=7a41fcde6c67faafab8c8ee2a31140999383dcef", "patch": "@@ -4700,9 +4700,10 @@ extern tree nreverse (tree);\n \n extern int list_length (const_tree);\n \n-/* Returns the first FIELD_DECL in a type.  */\n+/* Returns the first/last FIELD_DECL in a RECORD_TYPE.  */\n \n-extern tree first_field (const_tree);\n+extern tree first_field (const_tree) ATTRIBUTE_NONNULL (1);\n+extern tree last_field (const_tree) ATTRIBUTE_NONNULL (1);\n \n /* Given an initializer INIT, return TRUE if INIT is zero or some\n    aggregate of zeros.  Otherwise return FALSE.  If NONZERO is not"}]}