{"sha": "b40d90e6c569c434002f968a197d58eed0d2aaa3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQwZDkwZTZjNTY5YzQzNDAwMmY5NjhhMTk3ZDU4ZWVkMGQyYWFhMw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-05-20T14:07:56Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-05-20T14:07:56Z"}, "message": "Introduce can_implement_as_sibling_call_p\n\ngcc/ChangeLog:\n\t* calls.c (expand_call): Move \"Rest of purposes for tail call\n\toptimizations to fail\" to...\n\t(can_implement_as_sibling_call_p): ...this new function, and\n\tsplit into multiple \"if\" statements.\n\nFrom-SVN: r236513", "tree": {"sha": "ff2cbead9be65762a5a3649f4f2cea8c789cb8fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff2cbead9be65762a5a3649f4f2cea8c789cb8fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b40d90e6c569c434002f968a197d58eed0d2aaa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40d90e6c569c434002f968a197d58eed0d2aaa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b40d90e6c569c434002f968a197d58eed0d2aaa3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b40d90e6c569c434002f968a197d58eed0d2aaa3/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "97c53806a296af266da77377d7258d52712ba648", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c53806a296af266da77377d7258d52712ba648", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97c53806a296af266da77377d7258d52712ba648"}], "stats": {"total": 121, "additions": 83, "deletions": 38}, "files": [{"sha": "1b5959dce8bde20292bf5c255f9f1d9a5700c596", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40d90e6c569c434002f968a197d58eed0d2aaa3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40d90e6c569c434002f968a197d58eed0d2aaa3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b40d90e6c569c434002f968a197d58eed0d2aaa3", "patch": "@@ -1,3 +1,10 @@\n+2016-05-20  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* calls.c (expand_call): Move \"Rest of purposes for tail call\n+\toptimizations to fail\" to...\n+\t(can_implement_as_sibling_call_p): ...this new function, and\n+\tsplit into multiple \"if\" statements.\n+\n 2016-05-20  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* cfgloop.h (expected_loop_iterations_unbounded,"}, {"sha": "ac8092c696ed296f78a1de4c63df8dc479ddab07", "filename": "gcc/calls.c", "status": "modified", "additions": 76, "deletions": 38, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b40d90e6c569c434002f968a197d58eed0d2aaa3/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b40d90e6c569c434002f968a197d58eed0d2aaa3/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=b40d90e6c569c434002f968a197d58eed0d2aaa3", "patch": "@@ -2344,6 +2344,78 @@ avoid_likely_spilled_reg (rtx x)\n   return x;\n }\n \n+/* Helper function for expand_call.\n+   Return false is EXP is not implementable as a sibling call.  */\n+\n+static bool\n+can_implement_as_sibling_call_p (tree exp,\n+\t\t\t\t rtx structure_value_addr,\n+\t\t\t\t tree funtype,\n+\t\t\t\t int reg_parm_stack_space,\n+\t\t\t\t tree fndecl,\n+\t\t\t\t int flags,\n+\t\t\t\t tree addr,\n+\t\t\t\t const args_size &args_size)\n+{\n+  if (!targetm.have_sibcall_epilogue ())\n+    return false;\n+\n+  /* Doing sibling call optimization needs some work, since\n+     structure_value_addr can be allocated on the stack.\n+     It does not seem worth the effort since few optimizable\n+     sibling calls will return a structure.  */\n+  if (structure_value_addr != NULL_RTX)\n+    return false;\n+\n+#ifdef REG_PARM_STACK_SPACE\n+  /* If outgoing reg parm stack space changes, we can not do sibcall.  */\n+  if (OUTGOING_REG_PARM_STACK_SPACE (funtype)\n+      != OUTGOING_REG_PARM_STACK_SPACE (TREE_TYPE (current_function_decl))\n+      || (reg_parm_stack_space != REG_PARM_STACK_SPACE (current_function_decl)))\n+    return false;\n+#endif\n+\n+  /* Check whether the target is able to optimize the call\n+     into a sibcall.  */\n+  if (!targetm.function_ok_for_sibcall (fndecl, exp))\n+    return false;\n+\n+  /* Functions that do not return exactly once may not be sibcall\n+     optimized.  */\n+  if (flags & (ECF_RETURNS_TWICE | ECF_NORETURN))\n+    return false;\n+\n+  if (TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (addr))))\n+    return false;\n+\n+  /* If the called function is nested in the current one, it might access\n+     some of the caller's arguments, but could clobber them beforehand if\n+     the argument areas are shared.  */\n+  if (fndecl && decl_function_context (fndecl) == current_function_decl)\n+    return false;\n+\n+  /* If this function requires more stack slots than the current\n+     function, we cannot change it into a sibling call.\n+     crtl->args.pretend_args_size is not part of the\n+     stack allocated by our caller.  */\n+  if (args_size.constant > (crtl->args.size - crtl->args.pretend_args_size))\n+    return false;\n+\n+  /* If the callee pops its own arguments, then it must pop exactly\n+     the same number of arguments as the current function.  */\n+  if (targetm.calls.return_pops_args (fndecl, funtype, args_size.constant)\n+      != targetm.calls.return_pops_args (current_function_decl,\n+\t\t\t\t\t TREE_TYPE (current_function_decl),\n+\t\t\t\t\t crtl->args.size))\n+    return false;\n+\n+  if (!lang_hooks.decls.ok_for_sibcall (fndecl))\n+    return false;\n+\n+  /* All checks passed.  */\n+  return true;\n+}\n+\n /* Generate all the code for a CALL_EXPR exp\n    and return an rtx for its value.\n    Store the value in TARGET (specified as an rtx) if convenient.\n@@ -2740,44 +2812,10 @@ expand_call (tree exp, rtx target, int ignore)\n     try_tail_call = 0;\n \n   /*  Rest of purposes for tail call optimizations to fail.  */\n-  if (!try_tail_call\n-      || !targetm.have_sibcall_epilogue ()\n-      /* Doing sibling call optimization needs some work, since\n-\t structure_value_addr can be allocated on the stack.\n-\t It does not seem worth the effort since few optimizable\n-\t sibling calls will return a structure.  */\n-      || structure_value_addr != NULL_RTX\n-#ifdef REG_PARM_STACK_SPACE\n-      /* If outgoing reg parm stack space changes, we can not do sibcall.  */\n-      || (OUTGOING_REG_PARM_STACK_SPACE (funtype)\n-\t  != OUTGOING_REG_PARM_STACK_SPACE (TREE_TYPE (current_function_decl)))\n-      || (reg_parm_stack_space != REG_PARM_STACK_SPACE (current_function_decl))\n-#endif\n-      /* Check whether the target is able to optimize the call\n-\t into a sibcall.  */\n-      || !targetm.function_ok_for_sibcall (fndecl, exp)\n-      /* Functions that do not return exactly once may not be sibcall\n-\t optimized.  */\n-      || (flags & (ECF_RETURNS_TWICE | ECF_NORETURN))\n-      || TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (addr)))\n-      /* If the called function is nested in the current one, it might access\n-\t some of the caller's arguments, but could clobber them beforehand if\n-\t the argument areas are shared.  */\n-      || (fndecl && decl_function_context (fndecl) == current_function_decl)\n-      /* If this function requires more stack slots than the current\n-\t function, we cannot change it into a sibling call.\n-\t crtl->args.pretend_args_size is not part of the\n-\t stack allocated by our caller.  */\n-      || args_size.constant > (crtl->args.size\n-\t\t\t       - crtl->args.pretend_args_size)\n-      /* If the callee pops its own arguments, then it must pop exactly\n-\t the same number of arguments as the current function.  */\n-      || (targetm.calls.return_pops_args (fndecl, funtype, args_size.constant)\n-\t  != targetm.calls.return_pops_args (current_function_decl,\n-\t\t\t\t\t     TREE_TYPE (current_function_decl),\n-\t\t\t\t\t     crtl->args.size))\n-      || !lang_hooks.decls.ok_for_sibcall (fndecl))\n-    try_tail_call = 0;\n+  if (try_tail_call)\n+    try_tail_call = can_implement_as_sibling_call_p (exp, structure_value_addr, funtype,\n+\t\t\t\t\t\t     reg_parm_stack_space, fndecl,\n+\t\t\t\t\t\t     flags, addr, args_size);\n \n   /* Check if caller and callee disagree in promotion of function\n      return value.  */"}]}