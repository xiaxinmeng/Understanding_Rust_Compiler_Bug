{"sha": "c6285bd7bbc2823f6146a30fe06a8b6b871a06d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYyODViZDdiYmMyODIzZjYxNDZhMzBmZTA2YThiNmI4NzFhMDZkMA==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2013-09-28T01:05:07Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2013-09-28T01:05:07Z"}, "message": "expr.h (extract_bit_field): Remove packedp parameter.\n\n2013-09-28  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tgcc/\n\t* expr.h (extract_bit_field): Remove packedp parameter.\n\t* expmed.c (extract_fixed_bit_field): Remove packedp parameter\n\tfrom forward declaration.\n\t(store_split_bit_field): Remove packedp arg from calls to\n\textract_fixed_bit_field.\n\t(extract_bit_field_1): Remove packedp parameter and packedp\n\targument from recursive calls and calls to extract_fixed_bit_field.\n\t(extract_bit_field): Remove packedp parameter and corresponding\n\targ to extract_bit_field_1.\n\t(extract_fixed_bit_field): Remove packedp parameter.  Remove code\n\tto issue warnings.\n\t(extract_split_bit_field): Remove packedp arg from call to\n\textract_fixed_bit_field.\n\t* expr.c (emit_group_load_1): Adjust calls to extract_bit_field.\n\t(copy_blkmode_from_reg): Likewise.\n\t(copy_blkmode_to_reg): Likewise.\n\t(read_complex_part): Likewise.\n\t(store_field): Likewise.\n\t(expand_expr_real_1): Likewise.\n\t* calls.c (store_unaligned_arguments_into_pseudos): Adjust call\n\tto extract_bit_field.\n\t* config/tilegx/tilegx.c (tilegx_expand_unaligned_load): Adjust\n\tcall to extract_bit_field.\n\t* config/tilepro/tilepro.c (tilepro_expand_unaligned_load): Adjust\n\tcall to extract_bit_field.\n\t* doc/invoke.texi (Code Gen Options): Remove mention of warnings\n\tand special packedp behavior from -fstrict-volatile-bitfields\n\tdocumentation.\n\nFrom-SVN: r203003", "tree": {"sha": "3967a0cd7307647091f6146d6d906b34c15c329f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3967a0cd7307647091f6146d6d906b34c15c329f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ec110af7d13b28fe77cf4c18647adfa1d4b8ea9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec110af7d13b28fe77cf4c18647adfa1d4b8ea9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec110af7d13b28fe77cf4c18647adfa1d4b8ea9c"}], "stats": {"total": 142, "additions": 60, "deletions": 82}, "files": [{"sha": "125ac6123885cdc523f9c82d481c9824a6bdd91b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6285bd7bbc2823f6146a30fe06a8b6b871a06d0", "patch": "@@ -1,3 +1,34 @@\n+2013-09-28  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\t* expr.h (extract_bit_field): Remove packedp parameter.\n+\t* expmed.c (extract_fixed_bit_field): Remove packedp parameter\n+\tfrom forward declaration.\n+\t(store_split_bit_field): Remove packedp arg from calls to\n+\textract_fixed_bit_field.\n+\t(extract_bit_field_1): Remove packedp parameter and packedp\n+\targument from recursive calls and calls to extract_fixed_bit_field.\n+\t(extract_bit_field): Remove packedp parameter and corresponding\n+\targ to extract_bit_field_1.\n+\t(extract_fixed_bit_field): Remove packedp parameter.  Remove code\n+\tto issue warnings.\n+\t(extract_split_bit_field): Remove packedp arg from call to\n+\textract_fixed_bit_field.\n+\t* expr.c (emit_group_load_1): Adjust calls to extract_bit_field.\n+\t(copy_blkmode_from_reg): Likewise.\n+\t(copy_blkmode_to_reg): Likewise.\n+\t(read_complex_part): Likewise.\n+\t(store_field): Likewise.\n+\t(expand_expr_real_1): Likewise.\n+\t* calls.c (store_unaligned_arguments_into_pseudos): Adjust call\n+\tto extract_bit_field.\n+\t* config/tilegx/tilegx.c (tilegx_expand_unaligned_load): Adjust\n+\tcall to extract_bit_field.\n+\t* config/tilepro/tilepro.c (tilepro_expand_unaligned_load): Adjust\n+\tcall to extract_bit_field.\n+\t* doc/invoke.texi (Code Gen Options): Remove mention of warnings\n+\tand special packedp behavior from -fstrict-volatile-bitfields\n+\tdocumentation.\n+\n 2013-09-27  Jan-Benedict Glaw  <jbglaw@lug-owl.de>\n \n \t* lra-eliminations.c (init_elim_table): Guard value_p."}, {"sha": "3c083e6d53eebad127d64953d548967a012a52aa", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=c6285bd7bbc2823f6146a30fe06a8b6b871a06d0", "patch": "@@ -1026,7 +1026,7 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n \t    int bitsize = MIN (bytes * BITS_PER_UNIT, BITS_PER_WORD);\n \n \t    args[i].aligned_regs[j] = reg;\n-\t    word = extract_bit_field (word, bitsize, 0, 1, false, NULL_RTX,\n+\t    word = extract_bit_field (word, bitsize, 0, 1, NULL_RTX,\n \t\t\t\t      word_mode, word_mode);\n \n \t    /* There is no need to restrict this code to loading items"}, {"sha": "e15755e5cf4074027b65dd842f76727756e06ded", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=c6285bd7bbc2823f6146a30fe06a8b6b871a06d0", "patch": "@@ -1872,7 +1872,7 @@ tilegx_expand_unaligned_load (rtx dest_reg, rtx mem, HOST_WIDE_INT bitsize,\n       rtx extracted =\n \textract_bit_field (gen_lowpart (DImode, wide_result),\n \t\t\t   bitsize, bit_offset % BITS_PER_UNIT,\n-\t\t\t   !sign, false, gen_lowpart (DImode, dest_reg),\n+\t\t\t   !sign, gen_lowpart (DImode, dest_reg),\n \t\t\t   DImode, DImode);\n \n       if (extracted != dest_reg)"}, {"sha": "99ce5a0685723045cf17eb26c6fb33837df02ff7", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=c6285bd7bbc2823f6146a30fe06a8b6b871a06d0", "patch": "@@ -1676,7 +1676,7 @@ tilepro_expand_unaligned_load (rtx dest_reg, rtx mem, HOST_WIDE_INT bitsize,\n       rtx extracted =\n \textract_bit_field (gen_lowpart (SImode, wide_result),\n \t\t\t   bitsize, bit_offset % BITS_PER_UNIT,\n-\t\t\t   !sign, false, gen_lowpart (SImode, dest_reg),\n+\t\t\t   !sign, gen_lowpart (SImode, dest_reg),\n \t\t\t   SImode, SImode);\n \n       if (extracted != dest_reg)"}, {"sha": "d301278b13f3557b5b222d53e5ba46a2581f1763", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c6285bd7bbc2823f6146a30fe06a8b6b871a06d0", "patch": "@@ -21169,14 +21169,6 @@ instruction, even though that accesses bytes that do not contain\n any portion of the bit-field, or memory-mapped registers unrelated to\n the one being updated.\n \n-If the target requires strict alignment, and honoring the field\n-type would require violating this alignment, a warning is issued.\n-If the field has @code{packed} attribute, the access is done without\n-honoring the field type.  If the field doesn't have @code{packed}\n-attribute, the access is done honoring the field type.  In both cases,\n-GCC assumes that the user knows something about the target hardware\n-that it is unaware of.\n-\n The default value of this option is determined by the application binary\n interface for the target processor.\n "}, {"sha": "e83d064addcb3818c9980951d1d490e9c63c795d", "filename": "gcc/expmed.c", "status": "modified", "additions": 15, "deletions": 54, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=c6285bd7bbc2823f6146a30fe06a8b6b871a06d0", "patch": "@@ -54,7 +54,7 @@ static void store_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t   rtx);\n static rtx extract_fixed_bit_field (enum machine_mode, rtx,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n-\t\t\t\t    unsigned HOST_WIDE_INT, rtx, int, bool);\n+\t\t\t\t    unsigned HOST_WIDE_INT, rtx, int);\n static rtx mask_rtx (enum machine_mode, int, int, int);\n static rtx lshift_value (enum machine_mode, unsigned HOST_WIDE_INT, int);\n static rtx extract_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n@@ -1128,7 +1128,7 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t endianness compensation) to fetch the piece we want.  */\n \t      part = extract_fixed_bit_field (word_mode, value, thissize,\n \t\t\t\t\t      total_bits - bitsize + bitsdone,\n-\t\t\t\t\t      NULL_RTX, 1, false);\n+\t\t\t\t\t      NULL_RTX, 1);\n \t    }\n \t}\n       else\n@@ -1140,7 +1140,7 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t\t    & (((HOST_WIDE_INT) 1 << thissize) - 1));\n \t  else\n \t    part = extract_fixed_bit_field (word_mode, value, thissize,\n-\t\t\t\t\t    bitsdone, NULL_RTX, 1, false);\n+\t\t\t\t\t    bitsdone, NULL_RTX, 1);\n \t}\n \n       /* If OP0 is a register, then handle OFFSET here.\n@@ -1301,8 +1301,7 @@ extract_bit_field_using_extv (const extraction_insn *extv, rtx op0,\n \n static rtx\n extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n-\t\t     unsigned HOST_WIDE_INT bitnum,\n-\t\t     int unsignedp, bool packedp, rtx target,\n+\t\t     unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n \t\t     enum machine_mode mode, enum machine_mode tmode,\n \t\t     bool fallback_p)\n {\n@@ -1517,7 +1516,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  rtx result_part\n \t    = extract_bit_field_1 (op0, MIN (BITS_PER_WORD,\n \t\t\t\t\t     bitsize - i * BITS_PER_WORD),\n-\t\t\t\t   bitnum + bit_offset, 1, false, target_part,\n+\t\t\t\t   bitnum + bit_offset, 1, target_part,\n \t\t\t\t   mode, word_mode, fallback_p);\n \n \t  gcc_assert (target_part);\n@@ -1621,7 +1620,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t{\n \t  xop0 = copy_to_reg (xop0);\n \t  rtx result = extract_bit_field_1 (xop0, bitsize, bitpos,\n-\t\t\t\t\t    unsignedp, packedp, target,\n+\t\t\t\t\t    unsignedp, target,\n \t\t\t\t\t    mode, tmode, false);\n \t  if (result)\n \t    return result;\n@@ -1641,7 +1640,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n   gcc_assert (int_mode != BLKmode);\n \n   target = extract_fixed_bit_field (int_mode, op0, bitsize, bitnum,\n-\t\t\t\t    target, unsignedp, packedp);\n+\t\t\t\t    target, unsignedp);\n   return convert_extracted_bit_field (target, mode, tmode, unsignedp);\n }\n \n@@ -1652,7 +1651,6 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n    STR_RTX is the structure containing the byte (a REG or MEM).\n    UNSIGNEDP is nonzero if this is an unsigned bit field.\n-   PACKEDP is nonzero if the field has the packed attribute.\n    MODE is the natural mode of the field value once extracted.\n    TMODE is the mode the caller would like the value to have;\n    but the value may be returned with type MODE instead.\n@@ -1664,19 +1662,17 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n rtx\n extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n-\t\t   unsigned HOST_WIDE_INT bitnum, int unsignedp, bool packedp,\n-\t\t   rtx target, enum machine_mode mode, enum machine_mode tmode)\n+\t\t   unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n+\t\t   enum machine_mode mode, enum machine_mode tmode)\n {\n-  return extract_bit_field_1 (str_rtx, bitsize, bitnum, unsignedp, packedp,\n+  return extract_bit_field_1 (str_rtx, bitsize, bitnum, unsignedp,\n \t\t\t      target, mode, tmode, true);\n }\n \f\n /* Use shifts and boolean operations to extract a field of BITSIZE bits\n    from bit BITNUM of OP0.\n \n    UNSIGNEDP is nonzero for an unsigned bit field (don't sign-extend value).\n-   PACKEDP is true if the field has the packed attribute.\n-\n    If TARGET is nonzero, attempts to store the value there\n    and return TARGET, but this is not guaranteed.\n    If TARGET is not used, create a pseudo-reg of mode TMODE for the value.  */\n@@ -1685,7 +1681,7 @@ static rtx\n extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \t\t\t unsigned HOST_WIDE_INT bitsize,\n \t\t\t unsigned HOST_WIDE_INT bitnum, rtx target,\n-\t\t\t int unsignedp, bool packedp)\n+\t\t\t int unsignedp)\n {\n   enum machine_mode mode;\n \n@@ -1726,45 +1722,10 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \t  && bitnum % BITS_PER_UNIT + bitsize <= total_bits\n \t  && bitnum % GET_MODE_BITSIZE (mode) + bitsize > total_bits)\n \t{\n+\t  /* If the target doesn't support unaligned access, give up and\n+\t     split the access into two.  */\n \t  if (STRICT_ALIGNMENT)\n-\t    {\n-\t      static bool informed_about_misalignment = false;\n-\n-\t      if (packedp)\n-\t\t{\n-\t\t  if (bitsize == total_bits)\n-\t\t    warning_at (input_location, OPT_fstrict_volatile_bitfields,\n-\t\t\t\t\"multiple accesses to volatile structure\"\n-\t\t\t\t\" member because of packed attribute\");\n-\t\t  else\n-\t\t    warning_at (input_location, OPT_fstrict_volatile_bitfields,\n-\t\t\t\t\"multiple accesses to volatile structure\"\n-\t\t\t\t\" bitfield because of packed attribute\");\n-\n-\t\t  return extract_split_bit_field (op0, bitsize, bitnum,\n-\t\t\t\t\t\t  unsignedp);\n-\t\t}\n-\n-\t      if (bitsize == total_bits)\n-\t\twarning_at (input_location, OPT_fstrict_volatile_bitfields,\n-\t\t\t    \"mis-aligned access used for structure member\");\n-\t      else\n-\t\twarning_at (input_location, OPT_fstrict_volatile_bitfields,\n-\t\t\t    \"mis-aligned access used for structure bitfield\");\n-\n-\t      if (! informed_about_misalignment)\n-\t\t{\n-\t\t  informed_about_misalignment = true;\n-\t\t  inform (input_location,\n-\t\t\t  \"when a volatile object spans multiple type-sized\"\n-\t\t\t  \" locations, the compiler must choose between using\"\n-\t\t\t  \" a single mis-aligned access to preserve the\"\n-\t\t\t  \" volatility, or using multiple aligned accesses\"\n-\t\t\t  \" to avoid runtime faults; this code may fail at\"\n-\t\t\t  \" runtime if the hardware does not allow this\"\n-\t\t\t  \" access\");\n-\t\t}\n-\t    }\n+\t    return extract_split_bit_field (op0, bitsize, bitnum, unsignedp);\n \t  bit_offset = bitnum - bitnum % BITS_PER_UNIT;\n \t}\n       op0 = adjust_bitfield_address (op0, mode, bit_offset / BITS_PER_UNIT);\n@@ -1940,7 +1901,7 @@ extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t whose meaning is determined by BYTES_PER_UNIT.\n \t OFFSET is in UNITs, and UNIT is in bits.  */\n       part = extract_fixed_bit_field (word_mode, word, thissize,\n-\t\t\t\t      offset * unit + thispos, 0, 1, false);\n+\t\t\t\t      offset * unit + thispos, 0, 1);\n       bitsdone += thissize;\n \n       /* Shift this part into place for the result.  */"}, {"sha": "bb5f8a88855960ed5d506e8ec378c37be0d07444", "filename": "gcc/expr.c", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c6285bd7bbc2823f6146a30fe06a8b6b871a06d0", "patch": "@@ -1710,7 +1710,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \t\t  && (!REG_P (tmps[i]) || GET_MODE (tmps[i]) != mode))\n \t\ttmps[i] = extract_bit_field (tmps[i], bytelen * BITS_PER_UNIT,\n \t\t\t\t\t     (bytepos % slen0) * BITS_PER_UNIT,\n-\t\t\t\t\t     1, false, NULL_RTX, mode, mode);\n+\t\t\t\t\t     1, NULL_RTX, mode, mode);\n \t    }\n \t  else\n \t    {\n@@ -1720,7 +1720,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \t      mem = assign_stack_temp (GET_MODE (src), slen);\n \t      emit_move_insn (mem, src);\n \t      tmps[i] = extract_bit_field (mem, bytelen * BITS_PER_UNIT,\n-\t\t\t\t\t   0, 1, false, NULL_RTX, mode, mode);\n+\t\t\t\t\t   0, 1, NULL_RTX, mode, mode);\n \t    }\n \t}\n       /* FIXME: A SIMD parallel will eventually lead to a subreg of a\n@@ -1761,7 +1761,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \ttmps[i] = src;\n       else\n \ttmps[i] = extract_bit_field (src, bytelen * BITS_PER_UNIT,\n-\t\t\t\t     bytepos * BITS_PER_UNIT, 1, false, NULL_RTX,\n+\t\t\t\t     bytepos * BITS_PER_UNIT, 1, NULL_RTX,\n \t\t\t\t     mode, mode);\n \n       if (shift)\n@@ -2204,7 +2204,7 @@ copy_blkmode_from_reg (rtx target, rtx srcreg, tree type)\n \t bitpos for the destination store (left justified).  */\n       store_bit_field (dst, bitsize, bitpos % BITS_PER_WORD, 0, 0, copy_mode,\n \t\t       extract_bit_field (src, bitsize,\n-\t\t\t\t\t  xbitpos % BITS_PER_WORD, 1, false,\n+\t\t\t\t\t  xbitpos % BITS_PER_WORD, 1,\n \t\t\t\t\t  NULL_RTX, copy_mode, copy_mode));\n     }\n }\n@@ -2281,7 +2281,7 @@ copy_blkmode_to_reg (enum machine_mode mode, tree src)\n       store_bit_field (dst_word, bitsize, xbitpos % BITS_PER_WORD,\n \t\t       0, 0, word_mode,\n \t\t       extract_bit_field (src_word, bitsize,\n-\t\t\t\t\t  bitpos % BITS_PER_WORD, 1, false,\n+\t\t\t\t\t  bitpos % BITS_PER_WORD, 1,\n \t\t\t\t\t  NULL_RTX, word_mode, word_mode));\n     }\n \n@@ -3029,7 +3029,7 @@ read_complex_part (rtx cplx, bool imag_p)\n     }\n \n   return extract_bit_field (cplx, ibitsize, imag_p ? ibitsize : 0,\n-\t\t\t    true, false, NULL_RTX, imode, imode);\n+\t\t\t    true, NULL_RTX, imode, imode);\n }\n \f\n /* A subroutine of emit_move_insn_1.  Yet another lowpart generator.\n@@ -6470,7 +6470,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t      temp_target = gen_reg_rtx (mode);\n \t      temp_target\n \t        = extract_bit_field (temp, size * BITS_PER_UNIT, 0, 1,\n-\t\t\t\t     false, temp_target, mode, mode);\n+\t\t\t\t     temp_target, mode, mode);\n \t      temp = temp_target;\n \t    }\n \t}\n@@ -9672,8 +9672,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    else if (SLOW_UNALIGNED_ACCESS (mode, align))\n \t      temp = extract_bit_field (temp, GET_MODE_BITSIZE (mode),\n \t\t\t\t\t0, TYPE_UNSIGNED (TREE_TYPE (exp)),\n-\t\t\t\t\ttrue, (modifier == EXPAND_STACK_PARM\n-\t\t\t\t\t       ? NULL_RTX : target),\n+\t\t\t\t\t(modifier == EXPAND_STACK_PARM\n+\t\t\t\t\t ? NULL_RTX : target),\n \t\t\t\t\tmode, mode);\n \t  }\n \treturn temp;\n@@ -9864,7 +9864,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \tHOST_WIDE_INT bitsize, bitpos;\n \ttree offset;\n \tint volatilep = 0, must_force_mem;\n-\tbool packedp = false;\n \ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n \t\t\t\t\t&mode1, &unsignedp, &volatilep, true);\n \trtx orig_op0, memloc;\n@@ -9875,11 +9874,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t   infinitely recurse.  */\n \tgcc_assert (tem != exp);\n \n-\tif (TYPE_PACKED (TREE_TYPE (TREE_OPERAND (exp, 0)))\n-\t    || (TREE_CODE (TREE_OPERAND (exp, 1)) == FIELD_DECL\n-\t\t&& DECL_PACKED (TREE_OPERAND (exp, 1))))\n-\t  packedp = true;\n-\n \t/* If TEM's type is a union of variable size, pass TARGET to the inner\n \t   computation, since it will need a temporary and TARGET is known\n \t   to have to do.  This occurs in unchecked conversion in Ada.  */\n@@ -10104,7 +10098,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    if (MEM_P (op0) && REG_P (XEXP (op0, 0)))\n \t      mark_reg_pointer (XEXP (op0, 0), MEM_ALIGN (op0));\n \n-\t    op0 = extract_bit_field (op0, bitsize, bitpos, unsignedp, packedp,\n+\t    op0 = extract_bit_field (op0, bitsize, bitpos, unsignedp,\n \t\t\t\t     (modifier == EXPAND_STACK_PARM\n \t\t\t\t      ? NULL_RTX : target),\n \t\t\t\t     ext_mode, ext_mode);"}, {"sha": "218984402c5485db71d2190d27a98ece39c9f5dc", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6285bd7bbc2823f6146a30fe06a8b6b871a06d0/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=c6285bd7bbc2823f6146a30fe06a8b6b871a06d0", "patch": "@@ -704,7 +704,7 @@ extern void store_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t     unsigned HOST_WIDE_INT,\n \t\t\t     enum machine_mode, rtx);\n extern rtx extract_bit_field (rtx, unsigned HOST_WIDE_INT,\n-\t\t\t      unsigned HOST_WIDE_INT, int, bool, rtx,\n+\t\t\t      unsigned HOST_WIDE_INT, int, rtx,\n \t\t\t      enum machine_mode, enum machine_mode);\n extern rtx extract_low_bits (enum machine_mode, enum machine_mode, rtx);\n extern rtx expand_mult (enum machine_mode, rtx, rtx, rtx, int);"}]}