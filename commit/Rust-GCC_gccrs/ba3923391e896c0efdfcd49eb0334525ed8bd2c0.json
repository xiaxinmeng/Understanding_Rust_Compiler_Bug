{"sha": "ba3923391e896c0efdfcd49eb0334525ed8bd2c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmEzOTIzMzkxZTg5NmMwZWZkZmNkNDllYjAzMzQ1MjVlZDhiZDJjMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-09-25T01:48:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-09-25T01:48:34Z"}, "message": "cgraph.h (class ipa_polymorphic_call_context): Move here from ipa-utils.h; add stream_int and stream_out methods.\n\n\n\t* cgraph.h (class ipa_polymorphic_call_context): Move here from\n\tipa-utils.h; add stream_int and stream_out methods.\n\t(cgraph_indirect_call_info): Remove SPECILATIVE_OFFSET,\n\tOUTER_TYPE, SPECULATIVE_OUTER_TYPE, MAYBE_IN_CONSTRUCTION\n\tMAYBE_DERIVED_TYPE and SPECULATIEVE_MAYBE_DERIVED_TYPE;\n\tadd CONTEXT.\n\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context,\n\tipa_polymorphic_call_context::ipa_polymorphic_call_context,\n\tipa_polymorphic_call_context::clear_speculation,\n\tipa_polymorphic_call_context::clear_outer_type): Move here from\n\tipa-utils.h\n\t* ipa-utils.h (class ipa_polymorphic_call_context): Move to cgraph.h\n\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context,\n\tipa_polymorphic_call_context::ipa_polymorphic_call_context,\n\tipa_polymorphic_call_context::clear_speculation,\n\tipa_polymorphic_call_context::clear_outer_type): Likewise.\n\t* ipa-devirt.c: Include data-streamer.h, lto-streamer.h and\n\tstreamer-hooks.h\n\t(ipa_polymorphic_call_context::stream_out): New method.\n\t(ipa_polymorphic_call_context::stream_in): New method.\n\t(noncall_stmt_may_be_vtbl_ptr_store): Add forgotten static.\n\t* ipa-prop.c (ipa_analyze_indirect_call_uses): Do not care about\n\tOUTER_TYPE.\n\t(ipa_analyze_call_uses): Simplify.\n\t(update_indirect_edges_after_inlining): Do not care about outer_type.\n\t(ipa_write_indirect_edge_info): Update.\n\t(ipa_write_indirect_edge_info): Likewise.\n\t* cgraph.c (cgraph_node::create_indirect_edge): Simplify.\n\t(dump_edge_flags): Break out from ...\n\t(cgraph_node::dump): ... here; dump indirect edges.\n\nFrom-SVN: r215575", "tree": {"sha": "d4102419e20affeb7736989b54eabee0db65012a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4102419e20affeb7736989b54eabee0db65012a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba3923391e896c0efdfcd49eb0334525ed8bd2c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba3923391e896c0efdfcd49eb0334525ed8bd2c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba3923391e896c0efdfcd49eb0334525ed8bd2c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba3923391e896c0efdfcd49eb0334525ed8bd2c0/comments", "author": null, "committer": null, "parents": [{"sha": "20149bd284864c06f0051f50d73ff50be46505f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20149bd284864c06f0051f50d73ff50be46505f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20149bd284864c06f0051f50d73ff50be46505f8"}], "stats": {"total": 484, "additions": 278, "deletions": 206}, "files": [{"sha": "220027e8a30801cae5de5e314191a139d1d39e7f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3923391e896c0efdfcd49eb0334525ed8bd2c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3923391e896c0efdfcd49eb0334525ed8bd2c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba3923391e896c0efdfcd49eb0334525ed8bd2c0", "patch": "@@ -1,3 +1,36 @@\n+2014-09-24  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraph.h (class ipa_polymorphic_call_context): Move here from\n+\tipa-utils.h; add stream_int and stream_out methods.\n+\t(cgraph_indirect_call_info): Remove SPECILATIVE_OFFSET,\n+\tOUTER_TYPE, SPECULATIVE_OUTER_TYPE, MAYBE_IN_CONSTRUCTION\n+\tMAYBE_DERIVED_TYPE and SPECULATIEVE_MAYBE_DERIVED_TYPE;\n+\tadd CONTEXT.\n+\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context,\n+\tipa_polymorphic_call_context::ipa_polymorphic_call_context,\n+\tipa_polymorphic_call_context::clear_speculation,\n+\tipa_polymorphic_call_context::clear_outer_type): Move here from\n+\tipa-utils.h\n+\t* ipa-utils.h (class ipa_polymorphic_call_context): Move to cgraph.h\n+\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context,\n+\tipa_polymorphic_call_context::ipa_polymorphic_call_context,\n+\tipa_polymorphic_call_context::clear_speculation,\n+\tipa_polymorphic_call_context::clear_outer_type): Likewise.\n+\t* ipa-devirt.c: Include data-streamer.h, lto-streamer.h and\n+\tstreamer-hooks.h\n+\t(ipa_polymorphic_call_context::stream_out): New method.\n+\t(ipa_polymorphic_call_context::stream_in): New method.\n+\t(noncall_stmt_may_be_vtbl_ptr_store): Add forgotten static.\n+\t* ipa-prop.c (ipa_analyze_indirect_call_uses): Do not care about\n+\tOUTER_TYPE.\n+\t(ipa_analyze_call_uses): Simplify.\n+\t(update_indirect_edges_after_inlining): Do not care about outer_type.\n+\t(ipa_write_indirect_edge_info): Update.\n+\t(ipa_write_indirect_edge_info): Likewise.\n+\t* cgraph.c (cgraph_node::create_indirect_edge): Simplify.\n+\t(dump_edge_flags): Break out from ...\n+\t(cgraph_node::dump): ... here; dump indirect edges.\n+\n 2014-09-24  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-utils.h (polymorphic_call_context): Add"}, {"sha": "1cfc783f80a220f6d9dab6d010b99352bc3329f5", "filename": "gcc/cgraph.c", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3923391e896c0efdfcd49eb0334525ed8bd2c0/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3923391e896c0efdfcd49eb0334525ed8bd2c0/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=ba3923391e896c0efdfcd49eb0334525ed8bd2c0", "patch": "@@ -893,16 +893,7 @@ cgraph_node::create_indirect_edge (gimple call_stmt, int ecf_flags,\n \t = tree_to_uhwi (OBJ_TYPE_REF_TOKEN (target));\n       edge->indirect_info->otr_type = obj_type_ref_class (target);\n       gcc_assert (TREE_CODE (edge->indirect_info->otr_type) == RECORD_TYPE);\n-      edge->indirect_info->outer_type = context.outer_type;\n-      edge->indirect_info->speculative_outer_type\n-\t = context.speculative_outer_type;\n-      edge->indirect_info->offset = context.offset;\n-      edge->indirect_info->speculative_offset = context.speculative_offset;\n-      edge->indirect_info->maybe_in_construction\n-\t = context.maybe_in_construction;\n-      edge->indirect_info->maybe_derived_type = context.maybe_derived_type;\n-      edge->indirect_info->speculative_maybe_derived_type\n-\t = context.speculative_maybe_derived_type;\n+      edge->indirect_info->context = context;\n     }\n \n   edge->next_callee = indirect_calls;\n@@ -1851,14 +1842,33 @@ cgraph_inline_failed_type (cgraph_inline_failed_t reason)\n const char * const cgraph_availability_names[] =\n   {\"unset\", \"not_available\", \"overwritable\", \"available\", \"local\"};\n \n+/* Output flags of edge E.  */\n+\n+static void\n+dump_edge_flags (FILE *f, struct cgraph_edge *edge)\n+{\n+  if (edge->speculative)\n+    fprintf (f, \"(speculative) \");\n+  if (!edge->inline_failed)\n+    fprintf (f, \"(inlined) \");\n+  if (edge->indirect_inlining_edge)\n+    fprintf (f, \"(indirect_inlining) \");\n+  if (edge->count)\n+    fprintf (f, \"(%\"PRId64\"x) \",\n+\t     (int64_t)edge->count);\n+  if (edge->frequency)\n+    fprintf (f, \"(%.2f per call) \",\n+\t     edge->frequency / (double)CGRAPH_FREQ_BASE);\n+  if (edge->can_throw_external)\n+    fprintf (f, \"(can throw external) \");\n+}\n \n /* Dump call graph node to file F.  */\n \n void\n cgraph_node::dump (FILE *f)\n {\n   cgraph_edge *edge;\n-  int indirect_calls_count = 0;\n \n   dump_base (f);\n \n@@ -1937,49 +1947,42 @@ cgraph_node::dump (FILE *f)\n     {\n       fprintf (f, \"%s/%i \", edge->caller->asm_name (),\n \t       edge->caller->order);\n-      if (count)\n-\tfprintf (f, \"(%\"PRId64\"x) \",\n-\t\t (int64_t)count);\n-      if (frequency)\n-\tfprintf (f, \"(%.2f per call) \",\n-\t\t frequency / (double)CGRAPH_FREQ_BASE);\n-      if (edge->speculative)\n-\tfprintf (f, \"(speculative) \");\n-      if (!edge->inline_failed)\n-\tfprintf (f, \"(inlined) \");\n-      if (edge->indirect_inlining_edge)\n-\tfprintf (f, \"(indirect_inlining) \");\n-      if (edge->can_throw_external)\n-\tfprintf (f, \"(can throw external) \");\n+      dump_edge_flags (f, edge);\n     }\n \n   fprintf (f, \"\\n  Calls: \");\n   for (edge = callees; edge; edge = edge->next_callee)\n     {\n       fprintf (f, \"%s/%i \", edge->callee->asm_name (),\n \t       edge->callee->order);\n-      if (edge->speculative)\n-\tfprintf (f, \"(speculative) \");\n-      if (!edge->inline_failed)\n-\tfprintf (f, \"(inlined) \");\n-      if (edge->indirect_inlining_edge)\n-\tfprintf (f, \"(indirect_inlining) \");\n-      if (edge->count)\n-\tfprintf (f, \"(%\"PRId64\"x) \",\n-\t\t (int64_t)count);\n-      if (edge->frequency)\n-\tfprintf (f, \"(%.2f per call) \",\n-\t\t frequency / (double)CGRAPH_FREQ_BASE);\n-      if (edge->can_throw_external)\n-\tfprintf (f, \"(can throw external) \");\n+      dump_edge_flags (f, edge);\n     }\n   fprintf (f, \"\\n\");\n \n   for (edge = indirect_calls; edge; edge = edge->next_callee)\n-    indirect_calls_count++;\n-  if (indirect_calls_count)\n-    fprintf (f, \"  Has %i outgoing edges for indirect calls.\\n\",\n-\t     indirect_calls_count);\n+    {\n+      if (edge->indirect_info->polymorphic)\n+\t{\n+          fprintf (f, \"   Polymorphic indirect call of type \");\n+\t  print_generic_expr (f, edge->indirect_info->otr_type, TDF_SLIM);\n+\t  fprintf (f, \" token:%i\", (int) edge->indirect_info->otr_token);\n+\t}\n+      else\n+        fprintf (f, \"   Indirect call\");\n+      dump_edge_flags (f, edge);\n+      if (edge->indirect_info->param_index != -1)\n+\t{\n+\t  fprintf (f, \" of param:%i\", edge->indirect_info->param_index);\n+\t  if (edge->indirect_info->agg_contents)\n+\t   fprintf (f, \" loaded from %s %s at offset %i\",\n+\t\t    edge->indirect_info->member_ptr ? \"member ptr\" : \"aggregate\",\n+\t\t    edge->indirect_info->by_ref ? \"passed by reference\":\"\",\n+\t\t    (int)edge->indirect_info->offset);\n+\t}\n+      fprintf (f, \"\\n\");\n+      if (edge->indirect_info->polymorphic)\n+\tedge->indirect_info->context.dump (f);\n+    }\n }\n \n /* Dump call graph node NODE to stderr.  */"}, {"sha": "74819064fffb4da9adb914ddfa2763e3fc6e6fb3", "filename": "gcc/cgraph.h", "status": "modified", "additions": 111, "deletions": 9, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3923391e896c0efdfcd49eb0334525ed8bd2c0/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3923391e896c0efdfcd49eb0334525ed8bd2c0/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=ba3923391e896c0efdfcd49eb0334525ed8bd2c0", "patch": "@@ -1267,19 +1267,83 @@ struct varpool_node_set_iterator\n   unsigned index;\n };\n \n+/* Context of polymorphic call. It represent information about the type of\n+   instance that may reach the call.  This is used by ipa-devirt walkers of the\n+   type inheritance graph.  */\n+\n+class GTY(()) ipa_polymorphic_call_context {\n+public:\n+  /* The called object appears in an object of type OUTER_TYPE\n+     at offset OFFSET.  When information is not 100% reliable, we\n+     use SPECULATIVE_OUTER_TYPE and SPECULATIVE_OFFSET. */\n+  HOST_WIDE_INT offset;\n+  HOST_WIDE_INT speculative_offset;\n+  tree outer_type;\n+  tree speculative_outer_type;\n+  /* True if outer object may be in construction or destruction.  */\n+  bool maybe_in_construction;\n+  /* True if outer object may be of derived type.  */\n+  bool maybe_derived_type;\n+  /* True if speculative outer object may be of derived type.  We always\n+     speculate that construction does not happen.  */\n+  bool speculative_maybe_derived_type;\n+  /* True if the context is invalid and all calls should be redirected\n+     to BUILTIN_UNREACHABLE.  */\n+  bool invalid;\n+\n+  /* Build empty \"I know nothing\" context.  */\n+  ipa_polymorphic_call_context ();\n+  /* Build polymorphic call context for indirect call E.  */\n+  ipa_polymorphic_call_context (cgraph_edge *e);\n+  /* Build polymorphic call context for IP invariant CST.\n+     If specified, OTR_TYPE specify the type of polymorphic call\n+     that takes CST+OFFSET as a prameter.  */\n+  ipa_polymorphic_call_context (tree cst, tree otr_type = NULL,\n+\t\t\t\tHOST_WIDE_INT offset = 0);\n+  /* Build context for pointer REF contained in FNDECL at statement STMT.\n+     if INSTANCE is non-NULL, return pointer to the object described by\n+     the context.  */\n+  ipa_polymorphic_call_context (tree fndecl, tree ref, gimple stmt,\n+\t\t\t\ttree *instance = NULL);\n+\n+  /* Look for vtable stores or constructor calls to work out dynamic type\n+     of memory location.  */\n+  bool get_dynamic_type (tree, tree, tree, gimple);\n+\n+  /* Make context non-speculative.  */\n+  void clear_speculation ();\n+\n+  /* Walk container types and modify context to point to actual class\n+     containing EXPECTED_TYPE as base class.  */\n+  bool restrict_to_inner_class (tree expected_type);\n+\n+  /* Dump human readable context to F.  */\n+  void dump (FILE *f) const;\n+  void DEBUG_FUNCTION debug () const;\n+\n+  /* LTO streaming.  */\n+  void stream_out (struct output_block *) const;\n+  void stream_in (struct lto_input_block *, struct data_in *data_in);\n+\n+private:\n+  void set_by_decl (tree, HOST_WIDE_INT);\n+  bool set_by_invariant (tree, tree, HOST_WIDE_INT);\n+  void clear_outer_type (tree otr_type = NULL);\n+};\n+\n /* Structure containing additional information about an indirect call.  */\n \n struct GTY(()) cgraph_indirect_call_info\n {\n-  /* When polymorphic is set, this field contains offset where the object which\n-     was actually used in the polymorphic resides within a larger structure.\n-     If agg_contents is set, the field contains the offset within the aggregate\n-     from which the address to call was loaded.  */\n-  HOST_WIDE_INT offset, speculative_offset;\n+  /* When agg_content is set, an offset where the call pointer is located\n+     within the aggregate.  */\n+  HOST_WIDE_INT offset;\n+  /* Context of the polymorphic call; use only when POLYMORPHIC flag is set.  */\n+  ipa_polymorphic_call_context context;\n   /* OBJ_TYPE_REF_TOKEN of a polymorphic call (if polymorphic is set).  */\n   HOST_WIDE_INT otr_token;\n   /* Type of the object from OBJ_TYPE_REF_OBJECT. */\n-  tree otr_type, outer_type, speculative_outer_type;\n+  tree otr_type;\n   /* Index of the parameter that is called.  */\n   int param_index;\n   /* ECF flags determined from the caller.  */\n@@ -1300,9 +1364,6 @@ struct GTY(()) cgraph_indirect_call_info\n   /* When the previous bit is set, this one determines whether the destination\n      is loaded from a parameter passed by reference. */\n   unsigned by_ref : 1;\n-  unsigned int maybe_in_construction : 1;\n-  unsigned int maybe_derived_type : 1;\n-  unsigned int speculative_maybe_derived_type : 1;\n };\n \n struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgraph_edge {\n@@ -2532,4 +2593,45 @@ inline symtab_node * symtab_node::get_create (tree node)\n     return cgraph_node::get_create (node);\n }\n \n+/* Build polymorphic call context for indirect call E.  */\n+\n+inline\n+ipa_polymorphic_call_context::ipa_polymorphic_call_context (cgraph_edge *e)\n+{\n+  gcc_checking_assert (e->indirect_info->polymorphic);\n+  *this = e->indirect_info->context;\n+}\n+\n+/* Build empty \"I know nothing\" context.  */\n+\n+inline\n+ipa_polymorphic_call_context::ipa_polymorphic_call_context ()\n+{\n+  clear_speculation ();\n+  clear_outer_type ();\n+  invalid = false;\n+}\n+\n+/* Make context non-speculative.  */\n+\n+inline void\n+ipa_polymorphic_call_context::clear_speculation ()\n+{\n+  speculative_outer_type = NULL;\n+  speculative_offset = 0;\n+  speculative_maybe_derived_type = false;\n+}\n+\n+/* Produce context specifying all derrived types of OTR_TYPE.\n+   If OTR_TYPE is NULL or type of the OBJ_TYPE_REF, the context is set\n+   to dummy \"I know nothing\" setting.  */\n+\n+inline void\n+ipa_polymorphic_call_context::clear_outer_type (tree otr_type)\n+{\n+  outer_type = otr_type ? TYPE_MAIN_VARIANT (otr_type) : NULL;\n+  offset = 0;\n+  maybe_derived_type = true;\n+  maybe_in_construction = true;\n+}\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "954cd5409871fbde265ef44e22ab068f80ba5efe", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3923391e896c0efdfcd49eb0334525ed8bd2c0/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3923391e896c0efdfcd49eb0334525ed8bd2c0/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=ba3923391e896c0efdfcd49eb0334525ed8bd2c0", "patch": "@@ -135,6 +135,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stor-layout.h\"\n #include \"intl.h\"\n #include \"hash-map.h\"\n+#include \"data-streamer.h\"\n+#include \"lto-streamer.h\"\n+#include \"streamer-hooks.h\"\n \n /* Hash based set of pairs of types.  */\n typedef struct\n@@ -2570,6 +2573,71 @@ ipa_polymorphic_call_context::debug () const\n   dump (stderr);\n }\n \n+/* Stream out the context to OB.  */\n+\n+void\n+ipa_polymorphic_call_context::stream_out (struct output_block *ob) const\n+{\n+  struct bitpack_d bp = bitpack_create (ob->main_stream);\n+\n+  bp_pack_value (&bp, invalid, 1);\n+  bp_pack_value (&bp, maybe_in_construction, 1);\n+  bp_pack_value (&bp, maybe_derived_type, 1);\n+  bp_pack_value (&bp, speculative_maybe_derived_type, 1);\n+  bp_pack_value (&bp, outer_type != NULL, 1);\n+  bp_pack_value (&bp, offset != 0, 1);\n+  bp_pack_value (&bp, speculative_outer_type != NULL, 1);\n+  streamer_write_bitpack (&bp);\n+\n+  if (outer_type != NULL)\n+    stream_write_tree (ob, outer_type, true);\n+  if (offset)\n+    streamer_write_hwi (ob, offset);\n+  if (speculative_outer_type != NULL)\n+    {\n+      stream_write_tree (ob, speculative_outer_type, true);\n+      streamer_write_hwi (ob, speculative_offset);\n+    }\n+  else\n+    gcc_assert (!speculative_offset);\n+}\n+\n+/* Stream in the context from IB and DATA_IN.  */\n+\n+void\n+ipa_polymorphic_call_context::stream_in (struct lto_input_block *ib,\n+\t\t\t\t\t struct data_in *data_in)\n+{\n+  struct bitpack_d bp = streamer_read_bitpack (ib);\n+\n+  invalid = bp_unpack_value (&bp, 1);\n+  maybe_in_construction = bp_unpack_value (&bp, 1);\n+  maybe_derived_type = bp_unpack_value (&bp, 1);\n+  speculative_maybe_derived_type = bp_unpack_value (&bp, 1);\n+  bool outer_type_p = bp_unpack_value (&bp, 1);\n+  bool offset_p = bp_unpack_value (&bp, 1);\n+  bool speculative_outer_type_p = bp_unpack_value (&bp, 1);\n+\n+  if (outer_type_p)\n+    outer_type = stream_read_tree (ib, data_in);\n+  else\n+    outer_type = NULL;\n+  if (offset_p)\n+    offset = (HOST_WIDE_INT) streamer_read_hwi (ib);\n+  else\n+    offset = 0;\n+  if (speculative_outer_type_p)\n+    {\n+      speculative_outer_type = stream_read_tree (ib, data_in);\n+      speculative_offset = (HOST_WIDE_INT) streamer_read_hwi (ib);\n+    }\n+  else\n+    {\n+      speculative_outer_type = NULL;\n+      speculative_offset = 0;\n+    }\n+}\n+\n /* Proudce polymorphic call context for call method of instance\n    that is located within BASE (that is assumed to be a decl) at offset OFF. */\n \n@@ -2894,7 +2962,7 @@ struct type_change_info\n    We take advantage of fact that vtable stores must appear within constructor\n    and destructor functions.  */\n \n-bool\n+static bool\n noncall_stmt_may_be_vtbl_ptr_store (gimple stmt)\n {\n   if (is_gimple_assign (stmt))"}, {"sha": "36949e32709649f971ae6ff79ac997fa1930ecfe", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 19, "deletions": 45, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3923391e896c0efdfcd49eb0334525ed8bd2c0/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3923391e896c0efdfcd49eb0334525ed8bd2c0/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=ba3923391e896c0efdfcd49eb0334525ed8bd2c0", "patch": "@@ -416,6 +416,8 @@ ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n \t}\n       else\n \tfprintf (f, \"\\n\");\n+      if (ii->polymorphic)\n+\tii->context.dump (f);\n       ipa_print_node_jump_functions_for_edge (f, cs);\n     }\n }\n@@ -2153,8 +2155,6 @@ ipa_analyze_indirect_call_uses (struct func_body_info *fbi, gimple call,\n \t\t\t\t   NULL, &by_ref))\n     {\n       struct cgraph_edge *cs = ipa_note_param_call (fbi->node, index, call);\n-      if (cs->indirect_info->offset != offset)\n-\tcs->indirect_info->outer_type = NULL;\n       cs->indirect_info->offset = offset;\n       cs->indirect_info->agg_contents = 1;\n       cs->indirect_info->by_ref = by_ref;\n@@ -2255,8 +2255,6 @@ ipa_analyze_indirect_call_uses (struct func_body_info *fbi, gimple call,\n       && parm_preserved_before_stmt_p (fbi, index, call, rec))\n     {\n       struct cgraph_edge *cs = ipa_note_param_call (fbi->node, index, call);\n-      if (cs->indirect_info->offset != offset)\n-\tcs->indirect_info->outer_type = NULL;\n       cs->indirect_info->offset = offset;\n       cs->indirect_info->agg_contents = 1;\n       cs->indirect_info->member_ptr = 1;\n@@ -2345,36 +2343,20 @@ ipa_analyze_call_uses (struct func_body_info *fbi, gimple call)\n \n   if (cs->indirect_info->polymorphic)\n     {\n-      tree otr_type;\n-      HOST_WIDE_INT otr_token;\n       tree instance;\n       tree target = gimple_call_fn (call);\n       ipa_polymorphic_call_context context (current_function_decl,\n \t\t\t\t\t    target, call, &instance);\n \n-      otr_type = obj_type_ref_class (target);\n-      otr_token = tree_to_uhwi (OBJ_TYPE_REF_TOKEN (target));\n+      gcc_checking_assert (cs->indirect_info->otr_type\n+\t\t\t   == obj_type_ref_class (target));\n+      gcc_checking_assert (cs->indirect_info->otr_token\n+\t\t\t   == tree_to_shwi (OBJ_TYPE_REF_TOKEN (target)));\n \n       if (context.get_dynamic_type (instance,\n \t\t\t\t    OBJ_TYPE_REF_OBJECT (target),\n-\t\t\t\t    otr_type, call)\n-\t  && context.offset == cs->indirect_info->offset)\n-\t{\n-\t  gcc_assert (TREE_CODE (otr_type) == RECORD_TYPE);\n-\t  cs->indirect_info->polymorphic = true;\n-\t  cs->indirect_info->param_index = -1;\n-\t  cs->indirect_info->otr_token = otr_token;\n-\t  cs->indirect_info->otr_type = otr_type;\n-\t  cs->indirect_info->outer_type = context.outer_type;\n-\t  cs->indirect_info->speculative_outer_type = context.speculative_outer_type;\n-\t  cs->indirect_info->offset = context.offset;\n-\t  cs->indirect_info->speculative_offset = context.speculative_offset;\n-\t  cs->indirect_info->maybe_in_construction\n-\t     = context.maybe_in_construction;\n-\t  cs->indirect_info->maybe_derived_type = context.maybe_derived_type;\n-\t  cs->indirect_info->speculative_maybe_derived_type\n-\t     = context.speculative_maybe_derived_type;\n-\t}\n+\t\t\t\t    obj_type_ref_class (target), call))\n+\tcs->indirect_info->context = context;\n     }\n \n   if (TREE_CODE (target) == SSA_NAME)\n@@ -3253,8 +3235,6 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t  else\n \t    {\n \t      ici->param_index = ipa_get_jf_ancestor_formal_id (jfunc);\n-\t      if (ipa_get_jf_ancestor_offset (jfunc))\n-\t        ici->outer_type = NULL;\n \t      ici->offset += ipa_get_jf_ancestor_offset (jfunc);\n \t    }\n \t}\n@@ -4735,25 +4715,22 @@ ipa_write_indirect_edge_info (struct output_block *ob,\n   struct bitpack_d bp;\n \n   streamer_write_hwi (ob, ii->param_index);\n-  streamer_write_hwi (ob, ii->offset);\n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, ii->polymorphic, 1);\n   bp_pack_value (&bp, ii->agg_contents, 1);\n   bp_pack_value (&bp, ii->member_ptr, 1);\n   bp_pack_value (&bp, ii->by_ref, 1);\n-  bp_pack_value (&bp, ii->maybe_in_construction, 1);\n-  bp_pack_value (&bp, ii->maybe_derived_type, 1);\n-  bp_pack_value (&bp, ii->speculative_maybe_derived_type, 1);\n   streamer_write_bitpack (&bp);\n+  if (ii->agg_contents || ii->polymorphic)\n+    streamer_write_hwi (ob, ii->offset);\n+  else\n+    gcc_assert (ii->offset == 0);\n \n   if (ii->polymorphic)\n     {\n       streamer_write_hwi (ob, ii->otr_token);\n       stream_write_tree (ob, ii->otr_type, true);\n-      stream_write_tree (ob, ii->outer_type, true);\n-      stream_write_tree (ob, ii->speculative_outer_type, true);\n-      if (ii->speculative_outer_type)\n-        streamer_write_hwi (ob, ii->speculative_offset);\n+      ii->context.stream_out (ob);\n     }\n }\n \n@@ -4762,30 +4739,27 @@ ipa_write_indirect_edge_info (struct output_block *ob,\n \n static void\n ipa_read_indirect_edge_info (struct lto_input_block *ib,\n-\t\t\t     struct data_in *data_in ATTRIBUTE_UNUSED,\n+\t\t\t     struct data_in *data_in,\n \t\t\t     struct cgraph_edge *cs)\n {\n   struct cgraph_indirect_call_info *ii = cs->indirect_info;\n   struct bitpack_d bp;\n \n   ii->param_index = (int) streamer_read_hwi (ib);\n-  ii->offset = (HOST_WIDE_INT) streamer_read_hwi (ib);\n   bp = streamer_read_bitpack (ib);\n   ii->polymorphic = bp_unpack_value (&bp, 1);\n   ii->agg_contents = bp_unpack_value (&bp, 1);\n   ii->member_ptr = bp_unpack_value (&bp, 1);\n   ii->by_ref = bp_unpack_value (&bp, 1);\n-  ii->maybe_in_construction = bp_unpack_value (&bp, 1);\n-  ii->maybe_derived_type = bp_unpack_value (&bp, 1);\n-  ii->speculative_maybe_derived_type = bp_unpack_value (&bp, 1);\n+  if (ii->agg_contents || ii->polymorphic)\n+    ii->offset = (HOST_WIDE_INT) streamer_read_hwi (ib);\n+  else\n+    ii->offset = 0;\n   if (ii->polymorphic)\n     {\n       ii->otr_token = (HOST_WIDE_INT) streamer_read_hwi (ib);\n       ii->otr_type = stream_read_tree (ib, data_in);\n-      ii->outer_type = stream_read_tree (ib, data_in);\n-      ii->speculative_outer_type = stream_read_tree (ib, data_in);\n-      if (ii->speculative_outer_type)\n-        ii->speculative_offset = (HOST_WIDE_INT) streamer_read_hwi (ib);\n+      ii->context.stream_in (ib, data_in);\n     }\n }\n "}, {"sha": "7ff29f8c147ee2f15b626adfaa603a59b52da7b4", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3923391e896c0efdfcd49eb0334525ed8bd2c0/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3923391e896c0efdfcd49eb0334525ed8bd2c0/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=ba3923391e896c0efdfcd49eb0334525ed8bd2c0", "patch": "@@ -34,114 +34,6 @@ struct ipa_dfs_info {\n   PTR aux;\n };\n \n-/* Context of polymorphic call.  This is used by ipa-devirt walkers of the\n-   type inheritance graph.  */\n-\n-class ipa_polymorphic_call_context {\n-public:\n-  /* The called object appears in an object of type OUTER_TYPE\n-     at offset OFFSET.  When information is not 100% reliable, we\n-     use SPECULATIVE_OUTER_TYPE and SPECULATIVE_OFFSET. */\n-  HOST_WIDE_INT offset;\n-  HOST_WIDE_INT speculative_offset;\n-  tree outer_type;\n-  tree speculative_outer_type;\n-  /* True if outer object may be in construction or destruction.  */\n-  bool maybe_in_construction;\n-  /* True if outer object may be of derived type.  */\n-  bool maybe_derived_type;\n-  /* True if speculative outer object may be of derived type.  We always\n-     speculate that construction does not happen.  */\n-  bool speculative_maybe_derived_type;\n-  /* True if the context is invalid and all calls should be redirected\n-     to BUILTIN_UNREACHABLE.  */\n-  bool invalid;\n-\n-  /* Build empty \"I know nothing\" context.  */\n-  ipa_polymorphic_call_context ();\n-  /* Build polymorphic call context for indirect call E.  */\n-  ipa_polymorphic_call_context (cgraph_edge *e);\n-  /* Build polymorphic call context for IP invariant CST.\n-     If specified, OTR_TYPE specify the type of polymorphic call\n-     that takes CST+OFFSET as a prameter.  */\n-  ipa_polymorphic_call_context (tree cst, tree otr_type = NULL,\n-\t\t\t\tHOST_WIDE_INT offset = 0);\n-  /* Build context for pointer REF contained in FNDECL at statement STMT.\n-     if INSTANCE is non-NULL, return pointer to the object described by\n-     the context.  */\n-  ipa_polymorphic_call_context (tree fndecl, tree ref, gimple stmt,\n-\t\t\t\ttree *instance = NULL);\n-\n-  /* Look for vtable stores or constructor calls to work out dynamic type\n-     of memory location.  */\n-  bool get_dynamic_type (tree, tree, tree, gimple);\n-\n-  /* Make context non-speculative.  */\n-  void clear_speculation ();\n-\n-  /* Walk container types and modify context to point to actual class\n-     containing EXPECTED_TYPE as base class.  */\n-  bool restrict_to_inner_class (tree expected_type);\n-\n-  /* Dump human readable context to F.  */\n-  void dump (FILE *f) const;\n-  void DEBUG_FUNCTION debug () const;\n-\n-private:\n-  void set_by_decl (tree, HOST_WIDE_INT);\n-  bool set_by_invariant (tree, tree, HOST_WIDE_INT);\n-  void clear_outer_type (tree otr_type = NULL);\n-};\n-\n-/* Build polymorphic call context for indirect call E.  */\n-\n-inline\n-ipa_polymorphic_call_context::ipa_polymorphic_call_context (cgraph_edge *e)\n-{\n-  gcc_checking_assert (e->indirect_info->polymorphic);\n-\n-  offset = e->indirect_info->offset;\n-  speculative_offset = e->indirect_info->speculative_offset;\n-  outer_type = e->indirect_info->outer_type;\n-  speculative_outer_type = e->indirect_info->speculative_outer_type;\n-  maybe_in_construction = e->indirect_info->maybe_in_construction;\n-  maybe_derived_type = e->indirect_info->maybe_derived_type;\n-  speculative_maybe_derived_type = e->indirect_info->speculative_maybe_derived_type;\n-  invalid = false;\n-}\n-\n-/* Build empty \"I know nothing\" context.  */\n-\n-inline\n-ipa_polymorphic_call_context::ipa_polymorphic_call_context ()\n-{\n-  clear_speculation ();\n-  clear_outer_type ();\n-  invalid = false;\n-}\n-\n-/* Make context non-speculative.  */\n-\n-inline void\n-ipa_polymorphic_call_context::clear_speculation ()\n-{\n-  speculative_outer_type = NULL;\n-  speculative_offset = 0;\n-  speculative_maybe_derived_type = false;\n-}\n-\n-/* Produce context specifying all derrived types of OTR_TYPE.\n-   If OTR_TYPE is NULL or type of the OBJ_TYPE_REF, the context is set\n-   to dummy \"I know nothing\" setting.  */\n-\n-inline void\n-ipa_polymorphic_call_context::clear_outer_type (tree otr_type)\n-{\n-  outer_type = otr_type ? TYPE_MAIN_VARIANT (otr_type) : NULL;\n-  offset = 0;\n-  maybe_derived_type = true;\n-  maybe_in_construction = true;\n-}\n \n /* In ipa-utils.c  */\n void ipa_print_order (FILE*, const char *, struct cgraph_node**, int);"}]}