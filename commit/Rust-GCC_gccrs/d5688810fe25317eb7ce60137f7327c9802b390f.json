{"sha": "d5688810fe25317eb7ce60137f7327c9802b390f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU2ODg4MTBmZTI1MzE3ZWI3Y2U2MDEzN2Y3MzI3Yzk4MDJiMzkwZg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2006-09-12T05:54:00Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2006-09-12T05:54:00Z"}, "message": "dwarf2out.c (dwarf_file_data): New.\n\n\t* dwarf2out.c (dwarf_file_data): New.\n\t(enum dw_val_class): Add dw_val_class_file.\n\t(struct dw_val_struct): Add val_file.\n\t(file_table): Change to a hash table.\n\t(file_table_emitted): Delete.\n\t(file_table_last_lookup_index): Delete.\n\t(emitcount): Delete.\n\t(last_emitted_file): New.\n\t(lookup_filename): Change prototype to return a struct dwarf_file_data.\n\t(init_file_table): Delete.\n\t(maybe_emit_file): Change prototype to take a struct dwarf_file_data.\n\t(AT_addr): Add comment.\n\t(add_AT_file): New.\n\t(AT_file): New.\n\t(get_AT_file): New.\n\t(print_die): Handle dw_val_class_file.\n\t(print_dwarf_line_table): Update for new file table structure.\n\t(attr_checksum): Do checksum a filename.\n\t(same_dw_val_p, same_attr_p): Do compare a filename.\n\t(size_of_die): Handle dw_val_class_file.\n\t(value_format): Likewise.\n\t(output_die): Likewise.  Also, call maybe_emit_file here.\n\t(struct file_info): Constify filenames.  Make file_idx a pointer\n\tto a struct dwarf_file_data.\n\t(struct dir_info): Constify directory names.  Remove 'used' field.\n\t(struct file_name_acquire_data): New.\n\t(file_name_acquire): New.\n\t(output_file_names): Modify to handle new file data structures.\n\t(add_src_coords_attributes): Use add_AT_file.\n\t(add_call_src_coords_attributes): Likewise.\n\t(dwarf2out_imported_module_or_decl): Likewise.\n\t(gen_subprogram_die): Modify for new file data structures.\n\t(gen_variable_die): Likewise.\n\t(file_table_eq): New.\n\t(file_table_hash): New.\n\t(file_table_last_lookup): New.\n\t(lookup_filename): Rewrite to handle new file data structures.\n\t(maybe_emit_file): Rewrite to handle new file data structures.\n\t(dwarf2out_source_line): Always call lookup_filename and\n\tmaybe_emit_file.\n\t(dwarf2out_init): Create file_table here.\n\t(prune_unused_types_walk_attribs): Don't call maybe_emit_file here.\n\t(file_table_relative_p): New.\n\t(dwarf2out_finish): Change detection of relative filenames\n\tto work with new file data structures.  Move output_line_info call\n\tafter debug_info output.\n\nFrom-SVN: r116873", "tree": {"sha": "32dbd4aecb040fd4bba28686cb9220cb4a7f9316", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32dbd4aecb040fd4bba28686cb9220cb4a7f9316"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5688810fe25317eb7ce60137f7327c9802b390f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5688810fe25317eb7ce60137f7327c9802b390f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5688810fe25317eb7ce60137f7327c9802b390f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5688810fe25317eb7ce60137f7327c9802b390f/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df29fa4d8befc793568795e22db56186e4d3961b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df29fa4d8befc793568795e22db56186e4d3961b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df29fa4d8befc793568795e22db56186e4d3961b"}], "stats": {"total": 555, "additions": 337, "deletions": 218}, "files": [{"sha": "b937ee587a16d2970bb7852f46bf5cb496c81fa1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5688810fe25317eb7ce60137f7327c9802b390f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5688810fe25317eb7ce60137f7327c9802b390f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5688810fe25317eb7ce60137f7327c9802b390f", "patch": "@@ -1,3 +1,52 @@\n+2006-09-11  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* dwarf2out.c (dwarf_file_data): New.\n+\t(enum dw_val_class): Add dw_val_class_file.\n+\t(struct dw_val_struct): Add val_file.\n+\t(file_table): Change to a hash table.\n+\t(file_table_emitted): Delete.\n+\t(file_table_last_lookup_index): Delete.\n+\t(emitcount): Delete.\n+\t(last_emitted_file): New.\n+\t(lookup_filename): Change prototype to return a struct dwarf_file_data.\n+\t(init_file_table): Delete.\n+\t(maybe_emit_file): Change prototype to take a struct dwarf_file_data.\n+\t(AT_addr): Add comment.\n+\t(add_AT_file): New.\n+\t(AT_file): New.\n+\t(get_AT_file): New.\n+\t(print_die): Handle dw_val_class_file.\n+\t(print_dwarf_line_table): Update for new file table structure.\n+\t(attr_checksum): Do checksum a filename.\n+\t(same_dw_val_p, same_attr_p): Do compare a filename.\n+\t(size_of_die): Handle dw_val_class_file.\n+\t(value_format): Likewise.\n+\t(output_die): Likewise.  Also, call maybe_emit_file here.\n+\t(struct file_info): Constify filenames.  Make file_idx a pointer\n+\tto a struct dwarf_file_data.\n+\t(struct dir_info): Constify directory names.  Remove 'used' field.\n+\t(struct file_name_acquire_data): New.\n+\t(file_name_acquire): New.\n+\t(output_file_names): Modify to handle new file data structures.\n+\t(add_src_coords_attributes): Use add_AT_file.\n+\t(add_call_src_coords_attributes): Likewise.\n+\t(dwarf2out_imported_module_or_decl): Likewise.\n+\t(gen_subprogram_die): Modify for new file data structures.\n+\t(gen_variable_die): Likewise.\n+\t(file_table_eq): New.\n+\t(file_table_hash): New.\n+\t(file_table_last_lookup): New.\n+\t(lookup_filename): Rewrite to handle new file data structures.\n+\t(maybe_emit_file): Rewrite to handle new file data structures.\n+\t(dwarf2out_source_line): Always call lookup_filename and\n+\tmaybe_emit_file.\n+\t(dwarf2out_init): Create file_table here.\n+\t(prune_unused_types_walk_attribs): Don't call maybe_emit_file here.\n+\t(file_table_relative_p): New.\n+\t(dwarf2out_finish): Change detection of relative filenames\n+\tto work with new file data structures.  Move output_line_info call\n+\tafter debug_info output.\n+\n 2006-09-11  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/13685"}, {"sha": "9bf5ffc212059cbab9d432f4b25b3c15d512b7da", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 279, "deletions": 218, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5688810fe25317eb7ce60137f7327c9802b390f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5688810fe25317eb7ce60137f7327c9802b390f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d5688810fe25317eb7ce60137f7327c9802b390f", "patch": "@@ -2653,6 +2653,13 @@ dwarf2out_frame_finish (void)\n /* And now, the subset of the debugging information support code necessary\n    for emitting location expressions.  */\n \n+/* Data about a single source file.  */\n+struct dwarf_file_data GTY(())\n+{\n+  const char * filename;\n+  int emitted_number;\n+};\n+\n /* We need some way to distinguish DW_OP_addr with a direct symbol\n    relocation from DW_OP_addr with a dtp-relative symbol relocation.  */\n #define INTERNAL_DW_OP_tls_addr\t\t(0x100 + DW_OP_addr)\n@@ -2684,7 +2691,8 @@ enum dw_val_class\n   dw_val_class_lbl_id,\n   dw_val_class_lineptr,\n   dw_val_class_str,\n-  dw_val_class_macptr\n+  dw_val_class_macptr,\n+  dw_val_class_file\n };\n \n /* Describe a double word constant value.  */\n@@ -2732,6 +2740,7 @@ typedef struct dw_val_struct GTY(())\n       struct indirect_string_node * GTY ((tag (\"dw_val_class_str\"))) val_str;\n       char * GTY ((tag (\"dw_val_class_lbl_id\"))) val_lbl_id;\n       unsigned char GTY ((tag (\"dw_val_class_flag\"))) val_flag;\n+      struct dwarf_file_data * GTY ((tag (\"dw_val_class_file\"))) val_file;\n     }\n   GTY ((desc (\"%1.val_class\"))) v;\n }\n@@ -3851,9 +3860,7 @@ static GTY(()) dw_die_ref comp_unit_die;\n static GTY(()) limbo_die_node *limbo_die_list;\n \n /* Filenames referenced by this compilation unit.  */\n-static GTY(()) varray_type file_table;\n-static GTY(()) varray_type file_table_emitted;\n-static GTY(()) size_t file_table_last_lookup_index;\n+static GTY((param_is (struct dwarf_file_data))) htab_t file_table;\n \n /* A hash table of references to DIE's that describe declarations.\n    The key is a DECL_UID() which is a unique number identifying each decl.  */\n@@ -3985,8 +3992,8 @@ static int current_function_has_inlines;\n static int comp_unit_has_inlines;\n #endif\n \n-/* Number of file tables emitted in maybe_emit_file().  */\n-static GTY(()) int emitcount = 0;\n+/* The last file entry emitted by maybe_emit_file().  */\n+static GTY(()) struct dwarf_file_data * last_emitted_file;\n \n /* Number of internal labels generated by gen_internal_sym().  */\n static GTY(()) int label_num;\n@@ -4219,8 +4226,7 @@ static dw_die_ref force_decl_die (tree);\n static dw_die_ref force_type_die (tree);\n static dw_die_ref setup_namespace_context (tree, dw_die_ref);\n static void declare_in_namespace (tree, dw_die_ref);\n-static unsigned lookup_filename (const char *);\n-static void init_file_table (void);\n+static struct dwarf_file_data * lookup_filename (const char *);\n static void retry_incomplete_types (void);\n static void gen_type_die_for_member (tree, tree, dw_die_ref);\n static void splice_child_die (dw_die_ref, dw_die_ref);\n@@ -4239,7 +4245,7 @@ static void prune_unused_types_walk (dw_die_ref);\n static void prune_unused_types_walk_attribs (dw_die_ref);\n static void prune_unused_types_prune (dw_die_ref);\n static void prune_unused_types (void);\n-static int maybe_emit_file (int);\n+static int maybe_emit_file (struct dwarf_file_data *fd);\n \n /* Section names used to hold DWARF debugging information.  */\n #ifndef DEBUG_INFO_SECTION\n@@ -5180,13 +5186,38 @@ add_AT_addr (dw_die_ref die, enum dwarf_attribute attr_kind, rtx addr)\n   add_dwarf_attr (die, &attr);\n }\n \n+/* Get the RTX from to an address DIE attribute.  */\n+\n static inline rtx\n AT_addr (dw_attr_ref a)\n {\n   gcc_assert (a && AT_class (a) == dw_val_class_addr);\n   return a->dw_attr_val.v.val_addr;\n }\n \n+/* Add a file attribute value to a DIE.  */\n+\n+static inline void\n+add_AT_file (dw_die_ref die, enum dwarf_attribute attr_kind,\n+\t     struct dwarf_file_data *fd)\n+{\n+  dw_attr_node attr;\n+\n+  attr.dw_attr = attr_kind;\n+  attr.dw_attr_val.val_class = dw_val_class_file;\n+  attr.dw_attr_val.v.val_file = fd;\n+  add_dwarf_attr (die, &attr);\n+}\n+\n+/* Get the dwarf_file_data from a file DIE attribute.  */\n+\n+static inline struct dwarf_file_data *\n+AT_file (dw_attr_ref a)\n+{\n+  gcc_assert (a && AT_class (a) == dw_val_class_file);\n+  return a->dw_attr_val.v.val_file;\n+}\n+\n /* Add a label identifier attribute value to a DIE.  */\n \n static inline void\n@@ -5357,6 +5388,14 @@ get_AT_ref (dw_die_ref die, enum dwarf_attribute attr_kind)\n   return a ? AT_ref (a) : NULL;\n }\n \n+static inline struct dwarf_file_data *\n+get_AT_file (dw_die_ref die, enum dwarf_attribute attr_kind)\n+{\n+  dw_attr_ref a = get_AT (die, attr_kind);\n+\n+  return a ? AT_file (a) : NULL;\n+}\n+\n /* Return TRUE if the language is C or C++.  */\n \n static inline bool\n@@ -5766,6 +5805,10 @@ print_die (dw_die_ref die, FILE *outfile)\n \t  else\n \t    fprintf (outfile, \"<null>\");\n \t  break;\n+\tcase dw_val_class_file:\n+\t  fprintf (outfile, \"\\\"%s\\\" (%d)\", AT_file (a)->filename,\n+\t\t   AT_file (a)->emitted_number);\n+\t  break;\n \tdefault:\n \t  break;\n \t}\n@@ -5796,11 +5839,9 @@ print_dwarf_line_table (FILE *outfile)\n   for (i = 1; i < line_info_table_in_use; i++)\n     {\n       line_info = &line_info_table[i];\n-      fprintf (outfile, \"%5d: \", i);\n-      fprintf (outfile, \"%-20s\",\n-\t       VARRAY_CHAR_PTR (file_table, line_info->dw_file_num));\n-      fprintf (outfile, \"%6ld\", line_info->dw_line_num);\n-      fprintf (outfile, \"\\n\");\n+      fprintf (outfile, \"%5d: %4ld %6ld\\n\", i,\n+\t       line_info->dw_file_num,\n+\t       line_info->dw_line_num);\n     }\n \n   fprintf (outfile, \"\\n\\n\");\n@@ -5874,11 +5915,9 @@ attr_checksum (dw_attr_ref at, struct md5_ctx *ctx, int *mark)\n \n   CHECKSUM (at->dw_attr);\n \n-  /* We don't care about differences in file numbering.  */\n-  if (at->dw_attr == DW_AT_decl_file\n-      /* Or that this was compiled with a different compiler snapshot; if\n-\t the output is the same, that's what matters.  */\n-      || at->dw_attr == DW_AT_producer)\n+  /* We don't care that this was compiled with a different compiler\n+     snapshot; if the output is the same, that's what matters.  */\n+  if (at->dw_attr == DW_AT_producer)\n     return;\n \n   switch (AT_class (at))\n@@ -5927,6 +5966,10 @@ attr_checksum (dw_attr_ref at, struct md5_ctx *ctx, int *mark)\n     case dw_val_class_macptr:\n       break;\n \n+    case dw_val_class_file:\n+      CHECKSUM_STRING (AT_file (at)->filename);\n+      break;\n+\n     default:\n       break;\n     }\n@@ -6029,6 +6072,9 @@ same_dw_val_p (dw_val_node *v1, dw_val_node *v2, int *mark)\n     case dw_val_class_macptr:\n       return 1;\n \n+    case dw_val_class_file:\n+      return v1->v.val_file == v2->v.val_file;\n+\n     default:\n       return 1;\n     }\n@@ -6042,11 +6088,9 @@ same_attr_p (dw_attr_ref at1, dw_attr_ref at2, int *mark)\n   if (at1->dw_attr != at2->dw_attr)\n     return 0;\n \n-  /* We don't care about differences in file numbering.  */\n-  if (at1->dw_attr == DW_AT_decl_file\n-      /* Or that this was compiled with a different compiler snapshot; if\n-\t the output is the same, that's what matters.  */\n-      || at1->dw_attr == DW_AT_producer)\n+  /* We don't care that this was compiled with a different compiler\n+     snapshot; if the output is the same, that's what matters. */\n+  if (at1->dw_attr == DW_AT_producer)\n     return 1;\n \n   return same_dw_val_p (&at1->dw_attr_val, &at2->dw_attr_val, mark);\n@@ -6622,6 +6666,9 @@ size_of_die (dw_die_ref die)\n \t  else\n \t    size += strlen (a->dw_attr_val.v.val_str->str) + 1;\n \t  break;\n+\tcase dw_val_class_file:\n+\t  size += constant_size (maybe_emit_file (a->dw_attr_val.v.val_file));\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -6804,6 +6851,18 @@ value_format (dw_attr_ref a)\n       return DW_FORM_data;\n     case dw_val_class_str:\n       return AT_string_form (a);\n+    case dw_val_class_file:\n+      switch (constant_size (maybe_emit_file (a->dw_attr_val.v.val_file)))\n+\t{\n+\tcase 1:\n+\t  return DW_FORM_data1;\n+\tcase 2:\n+\t  return DW_FORM_data2;\n+\tcase 4:\n+\t  return DW_FORM_data4;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n \n     default:\n       gcc_unreachable ();\n@@ -7163,6 +7222,15 @@ output_die (dw_die_ref die)\n \t    dw2_asm_output_nstring (AT_string (a), -1, \"%s\", name);\n \t  break;\n \n+\tcase dw_val_class_file:\n+\t  {\n+\t    int f = maybe_emit_file (a->dw_attr_val.v.val_file);\n+\t    \n+\t    dw2_asm_output_data (constant_size (f), f, \"%s (%s)\", name,\n+\t\t\t\t a->dw_attr_val.v.val_file->filename);\n+\t    break;\n+\t  }\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -7502,23 +7570,22 @@ output_ranges (void)\n /* Data structure containing information about input files.  */\n struct file_info\n {\n-  char *path;\t\t/* Complete file name.  */\n-  char *fname;\t\t/* File name part.  */\n+  const char *path;\t/* Complete file name.  */\n+  const char *fname;\t/* File name part.  */\n   int length;\t\t/* Length of entire string.  */\n-  int file_idx;\t\t/* Index in input file table.  */\n+  struct dwarf_file_data * file_idx;\t/* Index in input file table.  */\n   int dir_idx;\t\t/* Index in directory table.  */\n };\n \n /* Data structure containing information about directories with source\n    files.  */\n struct dir_info\n {\n-  char *path;\t\t/* Path including directory name.  */\n+  const char *path;\t/* Path including directory name.  */\n   int length;\t\t/* Path length.  */\n   int prefix;\t\t/* Index of directory entry which is a prefix.  */\n   int count;\t\t/* Number of files in this directory.  */\n   int dir_idx;\t\t/* Index of directory used as base.  */\n-  int used;\t\t/* Used in the end?  */\n };\n \n /* Callback function for file_info comparison.  We sort by looking at\n@@ -7559,69 +7626,98 @@ file_info_cmp (const void *p1, const void *p2)\n     }\n }\n \n+struct file_name_acquire_data \n+{\n+  struct file_info *files;\n+  int used_files;\n+  int max_files;\n+};\n+\n+/* Traversal function for the hash table.  */\n+\n+static int\n+file_name_acquire (void ** slot, void *data)\n+{\n+  struct file_name_acquire_data *fnad = data;\n+  struct dwarf_file_data *d = *slot;\n+  struct file_info *fi;\n+  const char *f;\n+\n+  gcc_assert (fnad->max_files >= d->emitted_number);\n+\n+  if (! d->emitted_number)\n+    return 1;\n+\n+  gcc_assert (fnad->max_files != fnad->used_files);\n+\n+  fi = fnad->files + fnad->used_files++;\n+\n+  /* Skip all leading \"./\".  */\n+  f = d->filename;\n+  while (f[0] == '.' && f[1] == '/')\n+    f += 2;\n+  \n+  /* Create a new array entry.  */\n+  fi->path = f;\n+  fi->length = strlen (f);\n+  fi->file_idx = d;\n+  \n+  /* Search for the file name part.  */\n+  f = strrchr (f, '/');\n+  fi->fname = f == NULL ? fi->path : f + 1;\n+  return 1;\n+}\n+\n /* Output the directory table and the file name table.  We try to minimize\n    the total amount of memory needed.  A heuristic is used to avoid large\n    slowdowns with many input files.  */\n \n static void\n output_file_names (void)\n {\n+  struct file_name_acquire_data fnad;\n+  int numfiles;\n   struct file_info *files;\n   struct dir_info *dirs;\n   int *saved;\n   int *savehere;\n   int *backmap;\n-  size_t ndirs;\n+  int ndirs;\n   int idx_offset;\n-  size_t i;\n+  int i;\n   int idx;\n \n-  /* Handle the case where file_table is empty.  */\n-  if (VARRAY_ACTIVE_SIZE (file_table) <= 1)\n+  if (!last_emitted_file)\n     {\n       dw2_asm_output_data (1, 0, \"End directory table\");\n       dw2_asm_output_data (1, 0, \"End file name table\");\n       return;\n     }\n \n-  /* Allocate the various arrays we need.  */\n-  files = alloca (VARRAY_ACTIVE_SIZE (file_table) * sizeof (struct file_info));\n-  dirs = alloca (VARRAY_ACTIVE_SIZE (file_table) * sizeof (struct dir_info));\n-\n-  /* Sort the file names.  */\n-  for (i = 1; i < VARRAY_ACTIVE_SIZE (file_table); i++)\n-    {\n-      char *f;\n-\n-      /* Skip all leading \"./\".  */\n-      f = VARRAY_CHAR_PTR (file_table, i);\n-      while (f[0] == '.' && f[1] == '/')\n-\tf += 2;\n+  numfiles = last_emitted_file->emitted_number;\n \n-      /* Create a new array entry.  */\n-      files[i].path = f;\n-      files[i].length = strlen (f);\n-      files[i].file_idx = i;\n+  /* Allocate the various arrays we need.  */\n+  files = alloca (numfiles * sizeof (struct file_info));\n+  dirs = alloca (numfiles * sizeof (struct dir_info));\n \n-      /* Search for the file name part.  */\n-      f = strrchr (f, '/');\n-      files[i].fname = f == NULL ? files[i].path : f + 1;\n-    }\n+  fnad.files = files;\n+  fnad.used_files = 0;\n+  fnad.max_files = numfiles;\n+  htab_traverse (file_table, file_name_acquire, &fnad);\n+  gcc_assert (fnad.used_files == fnad.max_files);\n \n-  qsort (files + 1, VARRAY_ACTIVE_SIZE (file_table) - 1,\n-\t sizeof (files[0]), file_info_cmp);\n+  qsort (files, numfiles, sizeof (files[0]), file_info_cmp);\n \n   /* Find all the different directories used.  */\n-  dirs[0].path = files[1].path;\n-  dirs[0].length = files[1].fname - files[1].path;\n+  dirs[0].path = files[0].path;\n+  dirs[0].length = files[0].fname - files[0].path;\n   dirs[0].prefix = -1;\n   dirs[0].count = 1;\n   dirs[0].dir_idx = 0;\n-  dirs[0].used = 0;\n-  files[1].dir_idx = 0;\n+  files[0].dir_idx = 0;\n   ndirs = 1;\n \n-  for (i = 2; i < VARRAY_ACTIVE_SIZE (file_table); i++)\n+  for (i = 1; i < numfiles; i++)\n     if (files[i].fname - files[i].path == dirs[ndirs - 1].length\n \t&& memcmp (dirs[ndirs - 1].path, files[i].path,\n \t\t   dirs[ndirs - 1].length) == 0)\n@@ -7632,14 +7728,13 @@ output_file_names (void)\n       }\n     else\n       {\n-\tsize_t j;\n+\tint j;\n \n \t/* This is a new directory.  */\n \tdirs[ndirs].path = files[i].path;\n \tdirs[ndirs].length = files[i].fname - files[i].path;\n \tdirs[ndirs].count = 1;\n \tdirs[ndirs].dir_idx = ndirs;\n-\tdirs[ndirs].used = 0;\n \tfiles[i].dir_idx = ndirs;\n \n \t/* Search for a prefix.  */\n@@ -7667,7 +7762,7 @@ output_file_names (void)\n   memset (saved, '\\0', ndirs * sizeof (saved[0]));\n   for (i = 0; i < ndirs; i++)\n     {\n-      size_t j;\n+      int j;\n       int total;\n \n       /* We can always save some space for the current directory.  But this\n@@ -7690,7 +7785,7 @@ output_file_names (void)\n \n \t      if (k == (int) i)\n \t\t{\n-\t\t  /* Yes it is.  We can possibly safe some memory but\n+\t\t  /* Yes it is.  We can possibly save some memory by\n \t\t     writing the filenames in dirs[j] relative to\n \t\t     dirs[i].  */\n \t\t  savehere[j] = dirs[i].length;\n@@ -7699,7 +7794,7 @@ output_file_names (void)\n \t    }\n \t}\n \n-      /* Check whether we can safe enough to justify adding the dirs[i]\n+      /* Check whether we can save enough to justify adding the dirs[i]\n \t directory.  */\n       if (total > dirs[i].length + 1)\n \t{\n@@ -7716,51 +7811,33 @@ output_file_names (void)\n \t}\n     }\n \n-  /* We have to emit them in the order they appear in the file_table array\n-     since the index is used in the debug info generation.  To do this\n-     efficiently we generate a back-mapping of the indices first.  */\n-  backmap = alloca (VARRAY_ACTIVE_SIZE (file_table) * sizeof (int));\n-  for (i = 1; i < VARRAY_ACTIVE_SIZE (file_table); i++)\n-    {\n-      backmap[files[i].file_idx] = i;\n-\n-      /* Mark this directory as used.  */\n-      dirs[dirs[files[i].dir_idx].dir_idx].used = 1;\n-    }\n-\n-  /* That was it.  We are ready to emit the information.  First emit the\n-     directory name table.  We have to make sure the first actually emitted\n-     directory name has index one; zero is reserved for the current working\n-     directory.  Make sure we do not confuse these indices with the one for the\n-     constructed table (even though most of the time they are identical).  */\n+  /* Emit the directory name table.  */\n   idx = 1;\n   idx_offset = dirs[0].length > 0 ? 1 : 0;\n   for (i = 1 - idx_offset; i < ndirs; i++)\n-    if (dirs[i].used != 0)\n-      {\n-\tdirs[i].used = idx++;\n-\tdw2_asm_output_nstring (dirs[i].path, dirs[i].length - 1,\n-\t\t\t\t\"Directory Entry: 0x%x\", dirs[i].used);\n-      }\n+    dw2_asm_output_nstring (dirs[i].path, dirs[i].length - 1,\n+\t\t\t    \"Directory Entry: 0x%x\", i + idx_offset);\n \n   dw2_asm_output_data (1, 0, \"End directory table\");\n \n-  /* Correct the index for the current working directory entry if it\n-     exists.  */\n-  if (idx_offset == 0)\n-    dirs[0].used = 0;\n+  /* We have to emit them in the order of emitted_number since that's\n+     used in the debug info generation.  To do this efficiently we\n+     generate a back-mapping of the indices first.  */\n+  backmap = alloca (numfiles * sizeof (int));\n+  for (i = 0; i < numfiles; i++)\n+    backmap[files[i].file_idx->emitted_number - 1] = i;\n \n   /* Now write all the file names.  */\n-  for (i = 1; i < VARRAY_ACTIVE_SIZE (file_table); i++)\n+  for (i = 0; i < numfiles; i++)\n     {\n       int file_idx = backmap[i];\n       int dir_idx = dirs[files[file_idx].dir_idx].dir_idx;\n \n       dw2_asm_output_nstring (files[file_idx].path + dirs[dir_idx].length, -1,\n-\t\t\t      \"File Entry: 0x%lx\", (unsigned long) i);\n+\t\t\t      \"File Entry: 0x%x\", (unsigned) i + 1);\n \n       /* Include directory index.  */\n-      dw2_asm_output_data_uleb128 (dirs[dir_idx].used, NULL);\n+      dw2_asm_output_data_uleb128 (dir_idx + idx_offset, NULL);\n \n       /* Modification time.  */\n       dw2_asm_output_data_uleb128 (0, NULL);\n@@ -7916,9 +7993,7 @@ output_line_info (void)\n \t{\n \t  current_file = line_info->dw_file_num;\n \t  dw2_asm_output_data (1, DW_LNS_set_file, \"DW_LNS_set_file\");\n-\t  dw2_asm_output_data_uleb128 (current_file, \"(\\\"%s\\\")\",\n-\t\t\t\t       VARRAY_CHAR_PTR (file_table,\n-\t\t\t\t\t\t\tcurrent_file));\n+\t  dw2_asm_output_data_uleb128 (current_file, \"%lu\", current_file);\n \t}\n \n       /* Emit debug info for the current line number, choosing the encoding\n@@ -8025,9 +8100,7 @@ output_line_info (void)\n \t{\n \t  current_file = line_info->dw_file_num;\n \t  dw2_asm_output_data (1, DW_LNS_set_file, \"DW_LNS_set_file\");\n-\t  dw2_asm_output_data_uleb128 (current_file, \"(\\\"%s\\\")\",\n-\t\t\t\t       VARRAY_CHAR_PTR (file_table,\n-\t\t\t\t\t\t\tcurrent_file));\n+\t  dw2_asm_output_data_uleb128 (current_file, \"%lu\", current_file);\n \t}\n \n       /* Emit debug info for the current line number, choosing the encoding\n@@ -10843,9 +10916,8 @@ static void\n add_src_coords_attributes (dw_die_ref die, tree decl)\n {\n   expanded_location s = expand_location (DECL_SOURCE_LOCATION (decl));\n-  unsigned file_index = lookup_filename (s.file);\n \n-  add_AT_unsigned (die, DW_AT_decl_file, file_index);\n+  add_AT_file (die, DW_AT_decl_file, lookup_filename (s.file));\n   add_AT_unsigned (die, DW_AT_decl_line, s.line);\n }\n \n@@ -11591,7 +11663,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n   else if (old_die)\n     {\n       expanded_location s = expand_location (DECL_SOURCE_LOCATION (decl));\n-      unsigned file_index = lookup_filename (s.file);\n+      struct dwarf_file_data * file_index = lookup_filename (s.file);\n \n       if (!get_AT_flag (old_die, DW_AT_declaration)\n \t  /* We can have a normal definition following an inline one in the\n@@ -11613,7 +11685,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t apply; we just use the old DIE.  */\n       if ((old_die->die_parent == comp_unit_die || context_die == NULL)\n \t  && (DECL_ARTIFICIAL (decl)\n-\t      || (get_AT_unsigned (old_die, DW_AT_decl_file) == file_index\n+\t      || (get_AT_file (old_die, DW_AT_decl_file) == file_index\n \t\t  && (get_AT_unsigned (old_die, DW_AT_decl_line)\n \t\t      == (unsigned) s.line))))\n \t{\n@@ -11631,12 +11703,10 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t{\n \t  subr_die = new_die (DW_TAG_subprogram, context_die, decl);\n \t  add_AT_specification (subr_die, old_die);\n-\t  if (get_AT_unsigned (old_die, DW_AT_decl_file) != file_index)\n-\t    add_AT_unsigned (subr_die, DW_AT_decl_file, file_index);\n-\t  if (get_AT_unsigned (old_die, DW_AT_decl_line)\n-\t      != (unsigned) s.line)\n-\t    add_AT_unsigned\n-\t      (subr_die, DW_AT_decl_line, s.line);\n+\t  if (get_AT_file (old_die, DW_AT_decl_file) != file_index)\n+\t    add_AT_file (subr_die, DW_AT_decl_file, file_index);\n+\t  if (get_AT_unsigned (old_die, DW_AT_decl_line) != (unsigned) s.line)\n+\t    add_AT_unsigned (subr_die, DW_AT_decl_line, s.line);\n \t}\n     }\n   else\n@@ -11925,13 +11995,12 @@ gen_variable_die (tree decl, dw_die_ref context_die)\n       if (DECL_NAME (decl))\n \t{\n \t  expanded_location s = expand_location (DECL_SOURCE_LOCATION (decl));\n-\t  unsigned file_index = lookup_filename (s.file);\n+\t  struct dwarf_file_data * file_index = lookup_filename (s.file);\n \n-\t  if (get_AT_unsigned (old_die, DW_AT_decl_file) != file_index)\n-\t    add_AT_unsigned (var_die, DW_AT_decl_file, file_index);\n+\t  if (get_AT_file (old_die, DW_AT_decl_file) != file_index)\n+\t    add_AT_file (var_die, DW_AT_decl_file, file_index);\n \n-\t  if (get_AT_unsigned (old_die, DW_AT_decl_line)\n-\t      != (unsigned) s.line)\n+\t  if (get_AT_unsigned (old_die, DW_AT_decl_line) != (unsigned) s.line)\n \n \t    add_AT_unsigned (var_die, DW_AT_decl_line, s.line);\n \t}\n@@ -12019,9 +12088,8 @@ static inline void\n add_call_src_coords_attributes (tree stmt, dw_die_ref die)\n {\n   expanded_location s = expand_location (BLOCK_SOURCE_LOCATION (stmt));\n-  unsigned file_index = lookup_filename (s.file);\n \n-  add_AT_unsigned (die, DW_AT_call_file, file_index);\n+  add_AT_file (die, DW_AT_call_file, lookup_filename (s.file));\n   add_AT_unsigned (die, DW_AT_call_line, s.line);\n }\n \n@@ -13207,7 +13275,6 @@ dwarf2out_imported_module_or_decl (tree decl, tree context)\n {\n   dw_die_ref imported_die, at_import_die;\n   dw_die_ref scope_die;\n-  unsigned file_index;\n   expanded_location xloc;\n \n   if (debug_info_level <= DINFO_LEVEL_TERSE)\n@@ -13263,8 +13330,7 @@ dwarf2out_imported_module_or_decl (tree decl, tree context)\n     imported_die = new_die (DW_TAG_imported_declaration, scope_die, context);\n \n   xloc = expand_location (input_location);\n-  file_index = lookup_filename (xloc.file);\n-  add_AT_unsigned (imported_die, DW_AT_decl_file, file_index);\n+  add_AT_file (imported_die, DW_AT_decl_file, lookup_filename (xloc.file));\n   add_AT_unsigned (imported_die, DW_AT_decl_line, xloc.line);\n   add_AT_die_ref (imported_die, DW_AT_import, at_import_die);\n }\n@@ -13428,6 +13494,23 @@ dwarf2out_ignore_block (tree block)\n   return 1;\n }\n \n+/* Hash table routines for file_hash.  */\n+\n+static int\n+file_table_eq (const void *p1_p, const void *p2_p)\n+{\n+  const struct dwarf_file_data * p1 = p1_p;\n+  const char * p2 = p2_p;\n+  return strcmp (p1->filename, p2) == 0;\n+}\n+\n+static hashval_t\n+file_table_hash (const void *p_p)\n+{\n+  const struct dwarf_file_data * p = p_p;\n+  return htab_hash_string (p->filename);\n+}\n+\n /* Lookup FILE_NAME (in the list of filenames that we know about here in\n    dwarf2out.c) and return its \"index\".  The index of each (known) filename is\n    just a unique number which is associated with only that one filename.  We\n@@ -13439,46 +13522,32 @@ dwarf2out_ignore_block (tree block)\n    the index of the filename was looked up last.  This handles the majority of\n    all searches.  */\n \n-static unsigned\n+static GTY(()) struct dwarf_file_data * file_table_last_lookup;\n+\n+static struct dwarf_file_data *\n lookup_filename (const char *file_name)\n {\n-  size_t i, n;\n-  char *save_file_name;\n+  void ** slot;\n+  struct dwarf_file_data * created;\n \n   /* Check to see if the file name that was searched on the previous\n      call matches this file name.  If so, return the index.  */\n-  if (file_table_last_lookup_index != 0)\n-    {\n-      const char *last\n-\t= VARRAY_CHAR_PTR (file_table, file_table_last_lookup_index);\n-      if (strcmp (file_name, last) == 0)\n-\treturn file_table_last_lookup_index;\n-    }\n+  if (file_table_last_lookup\n+      && (file_name == file_table_last_lookup->filename\n+\t  || strcmp (file_table_last_lookup->filename, file_name) == 0))\n+    return file_table_last_lookup;\n \n   /* Didn't match the previous lookup, search the table.  */\n-  n = VARRAY_ACTIVE_SIZE (file_table);\n-  for (i = 1; i < n; i++)\n-    if (strcmp (file_name, VARRAY_CHAR_PTR (file_table, i)) == 0)\n-      {\n-\tfile_table_last_lookup_index = i;\n-\treturn i;\n-      }\n+  slot = htab_find_slot_with_hash (file_table, file_name,\n+\t\t\t\t   htab_hash_string (file_name), INSERT);\n+  if (*slot)\n+    return *slot;\n \n-  /* Add the new entry to the end of the filename table.  */\n-  file_table_last_lookup_index = n;\n-  save_file_name = (char *) ggc_strdup (file_name);\n-  VARRAY_PUSH_CHAR_PTR (file_table, save_file_name);\n-  VARRAY_PUSH_UINT (file_table_emitted, 0);\n-\n-  /* If the assembler is emitting the file table, and we aren't eliminating\n-     unused debug types, then we must emit .file here.  If we are eliminating\n-     unused debug types, then this will be done by the maybe_emit_file call in\n-     prune_unused_types_walk_attribs.  */\n-\n-  if (DWARF2_ASM_LINE_DEBUG_INFO && ! flag_eliminate_unused_debug_types)\n-    return maybe_emit_file (i);\n-\n-  return i;\n+  created = ggc_alloc (sizeof (struct dwarf_file_data));\n+  created->filename = file_name;\n+  created->emitted_number = 0;\n+  *slot = created;\n+  return created;\n }\n \n /* If the assembler will construct the file table, then translate the compiler\n@@ -13488,38 +13557,25 @@ lookup_filename (const char *file_name)\n    types, which may include filenames.  */\n \n static int\n-maybe_emit_file (int fileno)\n+maybe_emit_file (struct dwarf_file_data * fd)\n {\n-  if (DWARF2_ASM_LINE_DEBUG_INFO && fileno > 0)\n+  if (! fd->emitted_number)\n     {\n-      if (!VARRAY_UINT (file_table_emitted, fileno))\n+      if (last_emitted_file)\n+\tfd->emitted_number = last_emitted_file->emitted_number + 1;\n+      else\n+\tfd->emitted_number = 1;\n+      last_emitted_file = fd;\n+      \n+      if (DWARF2_ASM_LINE_DEBUG_INFO)\n \t{\n-\t  VARRAY_UINT (file_table_emitted, fileno) = ++emitcount;\n-\t  fprintf (asm_out_file, \"\\t.file %u \",\n-\t\t   VARRAY_UINT (file_table_emitted, fileno));\n-\t  output_quoted_string (asm_out_file,\n-\t\t\t\tVARRAY_CHAR_PTR (file_table, fileno));\n+\t  fprintf (asm_out_file, \"\\t.file %u \", fd->emitted_number);\n+\t  output_quoted_string (asm_out_file, fd->filename);\n \t  fputc ('\\n', asm_out_file);\n \t}\n-      return VARRAY_UINT (file_table_emitted, fileno);\n     }\n-  else\n-    return fileno;\n-}\n-\n-/* Initialize the compiler internal file table.  */\n-\n-static void\n-init_file_table (void)\n-{\n-  /* Allocate the initial hunk of the file_table.  */\n-  VARRAY_CHAR_PTR_INIT (file_table, 64, \"file_table\");\n-  VARRAY_UINT_INIT (file_table_emitted, 64, \"file_table_emitted\");\n-\n-  /* Skip the first entry - file numbers begin at 1.  */\n-  VARRAY_PUSH_CHAR_PTR (file_table, NULL);\n-  VARRAY_PUSH_UINT (file_table_emitted, 0);\n-  file_table_last_lookup_index = 0;\n+  \n+  return fd->emitted_number;\n }\n \n /* Called by the final INSN scan whenever we see a var location.  We\n@@ -13596,6 +13652,8 @@ dwarf2out_source_line (unsigned int line, const char *filename)\n   if (debug_info_level >= DINFO_LEVEL_NORMAL\n       && line != 0)\n     {\n+      int file_num = maybe_emit_file (lookup_filename (filename));\n+      \n       switch_to_section (current_function_section ());\n \n       /* If requested, emit something human-readable.  */\n@@ -13605,10 +13663,6 @@ dwarf2out_source_line (unsigned int line, const char *filename)\n \n       if (DWARF2_ASM_LINE_DEBUG_INFO)\n \t{\n-\t  unsigned file_num = lookup_filename (filename);\n-\n-\t  file_num = maybe_emit_file (file_num);\n-\n \t  /* Emit the .loc directive understood by GNU as.  */\n \t  fprintf (asm_out_file, \"\\t.loc %d %d 0\\n\", file_num, line);\n \n@@ -13618,8 +13672,9 @@ dwarf2out_source_line (unsigned int line, const char *filename)\n       else if (function_section (current_function_decl) != text_section)\n \t{\n \t  dw_separate_line_info_ref line_info;\n-\t  targetm.asm_out.internal_label (asm_out_file, SEPARATE_LINE_CODE_LABEL,\n-\t\t\t\t     separate_line_info_table_in_use);\n+\t  targetm.asm_out.internal_label (asm_out_file, \n+\t\t\t\t\t  SEPARATE_LINE_CODE_LABEL,\n+\t\t\t\t\t  separate_line_info_table_in_use);\n \n \t  /* Expand the line info table if necessary.  */\n \t  if (separate_line_info_table_in_use\n@@ -13640,7 +13695,7 @@ dwarf2out_source_line (unsigned int line, const char *filename)\n \t  /* Add the new entry at the end of the line_info_table.  */\n \t  line_info\n \t    = &separate_line_info_table[separate_line_info_table_in_use++];\n-\t  line_info->dw_file_num = lookup_filename (filename);\n+\t  line_info->dw_file_num = file_num;\n \t  line_info->dw_line_num = line;\n \t  line_info->function = current_function_funcdef_no;\n \t}\n@@ -13665,7 +13720,7 @@ dwarf2out_source_line (unsigned int line, const char *filename)\n \n \t  /* Add the new entry at the end of the line_info_table.  */\n \t  line_info = &line_info_table[line_info_table_in_use++];\n-\t  line_info->dw_file_num = lookup_filename (filename);\n+\t  line_info->dw_file_num = file_num;\n \t  line_info->dw_line_num = line;\n \t}\n     }\n@@ -13687,15 +13742,14 @@ dwarf2out_start_source_file (unsigned int lineno, const char *filename)\n \n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     {\n-      int fileno;\n+      int file_num = maybe_emit_file (lookup_filename (filename));\n \n       switch_to_section (debug_macinfo_section);\n       dw2_asm_output_data (1, DW_MACINFO_start_file, \"Start new file\");\n       dw2_asm_output_data_uleb128 (lineno, \"Included from line number %d\",\n \t\t\t\t   lineno);\n \n-      fileno = maybe_emit_file (lookup_filename (filename));\n-      dw2_asm_output_data_uleb128 (fileno, \"Filename we just started\");\n+      dw2_asm_output_data_uleb128 (file_num, \"file %s\", filename);\n     }\n }\n \n@@ -13754,7 +13808,9 @@ dwarf2out_undef (unsigned int lineno ATTRIBUTE_UNUSED,\n static void\n dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n {\n-  init_file_table ();\n+  /* Allocate the file_table.  */\n+  file_table = htab_create_ggc (50, file_table_hash,\n+\t\t\t\tfile_table_eq, NULL);\n \n   /* Allocate the decl_die_table.  */\n   decl_die_table = htab_create_ggc (10, decl_die_table_hash,\n@@ -13914,12 +13970,6 @@ prune_unused_types_walk_attribs (dw_die_ref die)\n \t     Make sure that it will get emitted.  */\n \t  prune_unused_types_mark (a->dw_attr_val.v.val_die_ref.die, 1);\n \t}\n-      else if (a->dw_attr == DW_AT_decl_file || a->dw_attr == DW_AT_call_file)\n-\t{\n-\t  /* A reference to a file.  Make sure the file name is emitted.  */\n-\t  a->dw_attr_val.v.val_unsigned =\n-\t    maybe_emit_file (a->dw_attr_val.v.val_unsigned);\n-\t}\n       /* Set the string's refcount to 0 so that prune_unused_types_mark\n \t accounts properly for it.  */\n       if (AT_class (a) == dw_val_class_str)\n@@ -14129,6 +14179,21 @@ prune_unused_types (void)\n     prune_unmark_dies (node->die);\n }\n \n+/* Set the parameter to true if there are any relative pathnames in\n+   the file table.  */\n+static int\n+file_table_relative_p (void ** slot, void *param)\n+{\n+  bool *p = param;\n+  struct dwarf_file_data *d = *slot;\n+  if (d->emitted_number && d->filename[0] != DIR_SEPARATOR)\n+    {\n+      *p = true;\n+      return 0;\n+    }\n+  return 1;\n+}\n+\n /* Output stuff that dwarf requires at the end of every file,\n    and generate the DWARF-2 debugging info.  */\n \n@@ -14145,15 +14210,10 @@ dwarf2out_finish (const char *filename)\n     add_comp_dir_attribute (comp_unit_die);\n   else if (get_AT (comp_unit_die, DW_AT_comp_dir) == NULL)\n     {\n-      size_t i;\n-      for (i = 1; i < VARRAY_ACTIVE_SIZE (file_table); i++)\n-\tif (VARRAY_CHAR_PTR (file_table, i)[0] != DIR_SEPARATOR\n-\t    /* Don't add cwd for <built-in>.  */\n-\t    && VARRAY_CHAR_PTR (file_table, i)[0] != '<')\n-\t  {\n-\t    add_comp_dir_attribute (comp_unit_die);\n-\t    break;\n-\t  }\n+      bool p = false;\n+      htab_traverse (file_table, file_table_relative_p, &p);\n+      if (p)\n+\tadd_comp_dir_attribute (comp_unit_die);\n     }\n \n   /* Traverse the limbo die list, and add parent/child links.  The only\n@@ -14238,17 +14298,6 @@ dwarf2out_finish (const char *filename)\n       targetm.asm_out.internal_label (asm_out_file, COLD_END_LABEL, 0);\n     }\n \n-  /* Output the source line correspondence table.  We must do this\n-     even if there is no line information.  Otherwise, on an empty\n-     translation unit, we will generate a present, but empty,\n-     .debug_info section.  IRIX 6.5 `nm' will then complain when\n-     examining the file.  */\n-  if (! DWARF2_ASM_LINE_DEBUG_INFO)\n-    {\n-      switch_to_section (debug_line_section);\n-      output_line_info ();\n-    }\n-\n   /* We can only use the low/high_pc attributes if all of the code was\n      in .text.  */\n   if (!have_multiple_function_sections)\n@@ -14314,6 +14363,18 @@ dwarf2out_finish (const char *filename)\n       output_ranges ();\n     }\n \n+  /* Output the source line correspondence table.  We must do this\n+     even if there is no line information.  Otherwise, on an empty\n+     translation unit, we will generate a present, but empty,\n+     .debug_info section.  IRIX 6.5 `nm' will then complain when\n+     examining the file.  This is done late so that any filenames\n+     used by the debug_info section are marked as 'used'.  */\n+  if (! DWARF2_ASM_LINE_DEBUG_INFO)\n+    {\n+      switch_to_section (debug_line_section);\n+      output_line_info ();\n+    }\n+\n   /* Have to end the macro section.  */\n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     {"}, {"sha": "d67ebb75ad57f81bdc03b42d288c1515cd11c0b4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5688810fe25317eb7ce60137f7327c9802b390f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5688810fe25317eb7ce60137f7327c9802b390f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d5688810fe25317eb7ce60137f7327c9802b390f", "patch": "@@ -1,3 +1,7 @@\n+2006-09-11  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* gcc.dg/debug/dwarf2/dwarf-file1.c: New.\n+\n 2006-09-11  Jack Howarth  <howarth@bromo.med.uc.edu>\n \n         PR testsuite/28950"}, {"sha": "96a2b5ab2f1d871ad3c4dde56002459b903a65b2", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/dwarf-file1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5688810fe25317eb7ce60137f7327c9802b390f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fdwarf-file1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5688810fe25317eb7ce60137f7327c9802b390f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fdwarf-file1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fdwarf-file1.c?ref=d5688810fe25317eb7ce60137f7327c9802b390f", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -gdwarf-2 -dA\" } */\n+/* { dg-final { scan-assembler \"File Entry:\" } } */\n+/* Verify that a file entry is output for this file.  */\n+int bar = 3;"}]}