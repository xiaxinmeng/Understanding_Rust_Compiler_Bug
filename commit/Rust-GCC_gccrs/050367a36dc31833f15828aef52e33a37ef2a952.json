{"sha": "050367a36dc31833f15828aef52e33a37ef2a952", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUwMzY3YTM2ZGMzMTgzM2YxNTgyOGFlZjUyZTMzYTM3ZWYyYTk1Mg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-03-24T10:25:44Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-03-24T10:25:44Z"}, "message": "cplus-dem.c (optable): Add sizeof.\n\n\t* cplus-dem.c (optable): Add sizeof.\n\t(demangle_template_value_parm): New function containing code\n\tpreviously found in demangle_template.\n\t(demangle_integral_value): New function which handles complicated\n\tintegral expressions.\n\t(demangle_template): Use them.\n\t* error.c (dump_expr): Remove unused variable `l'.\n\t* pt.c (for_each_template_parm): New function, created by\n\tconverting uses_template_parms.\n\t(tree_fn_t): New typedef.\n\t(uses_template_parms): Use it.\n\t(mark_template_parm): New function.\n\t(push_template_decl): Check that the argument list of a partial\n\tspecialization uses all the template parameters.\n\t* Make-lang.in (c++filt): Don't delete cxxmain.c after we're done\n\twith it; we might want it for debugging.\n\t* cp-tree.h (type_unification): Change interface.\n\t* class.c (finish_struct_1): Skip nested template types, just like\n\tordinary nested types.\n\t(instantiate_type): Use new interface to type_unification.\n\t* lex.c (init_lex): Add __sz as opname for sizeof.\n\t* method.c (build_overload_scope_ref): New function.\n\t(build_overload_int): Handle complex expressions.  Set\n\tnumeric_output_need_bar if necessary.\n\t(build_overload_value): Handle non-PARM_DECL nodes; this\n\troutine is now used by build_overload_int.  Remove some\n\tassignments to numeric_output_need_bar.  Use\n\tbuild_overload_scope_ref.\n\t(build_qualified_name): Note that some template mangled names end\n\twith digits, and set numeric_output_need_bar appropriately.  Use\n\tbuild_underscore_int.\n\t* pt.c (unify): Change interface.\n\t(type_unification_real): Likewise.\n\t(determine_specialization): Use new interfaces.\n\t(tsubst): Deal gracefully with situations in which the argument\n\tvector is not fully filled.\n\t(fn_type_unification): Use new interfaces.\n\t(type_unification): Likewise.  Remove NOP_EXPR hack.\n\t(type_unification_real): Likewise.\n\t(unify): Likewise.  Deal with unification of complex expresions.\n\nFrom-SVN: r18795", "tree": {"sha": "28c2266d2091a5affc7ff055388b2d8a8fd6ff0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28c2266d2091a5affc7ff055388b2d8a8fd6ff0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/050367a36dc31833f15828aef52e33a37ef2a952", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/050367a36dc31833f15828aef52e33a37ef2a952", "html_url": "https://github.com/Rust-GCC/gccrs/commit/050367a36dc31833f15828aef52e33a37ef2a952", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/050367a36dc31833f15828aef52e33a37ef2a952/comments", "author": null, "committer": null, "parents": [{"sha": "0b93b64e20444a5a105b0cb9935b7841486559aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b93b64e20444a5a105b0cb9935b7841486559aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b93b64e20444a5a105b0cb9935b7841486559aa"}], "stats": {"total": 1528, "additions": 1175, "deletions": 353}, "files": [{"sha": "78a37f2f076ef22b6fac2ce1a22e391cf1bc5eae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=050367a36dc31833f15828aef52e33a37ef2a952", "patch": "@@ -1,3 +1,12 @@\n+1998-03-24  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* cplus-dem.c (optable): Add sizeof.\n+\t(demangle_template_value_parm): New function containing code\n+\tpreviously found in demangle_template.\n+\t(demangle_integral_value): New function which handles complicated \n+\tintegral expressions.\n+\t(demangle_template): Use them.\n+\n Tue Mar 24 12:13:18 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n         * Makefile.in (genconfig.o, genflags.o, gencodes.o, genemit.o,"}, {"sha": "320bcf6fc60ee7540072b07be098088f3e92f15f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=050367a36dc31833f15828aef52e33a37ef2a952", "patch": "@@ -1,3 +1,42 @@\n+Tue Mar 24 10:23:47 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* error.c (dump_expr): Remove unused variable `l'.\n+\n+\t* pt.c (for_each_template_parm): New function, created by\n+\tconverting uses_template_parms.\n+\t(tree_fn_t): New typedef.\n+\t(uses_template_parms): Use it.\n+\t(mark_template_parm): New function.\n+\t(push_template_decl): Check that the argument list of a partial\n+\tspecialization uses all the template parameters.\n+\n+\t* Make-lang.in (c++filt): Don't delete cxxmain.c after we're done\n+\twith it; we might want it for debugging.\n+\t* cp-tree.h (type_unification): Change interface.\n+\t* class.c (finish_struct_1): Skip nested template types, just like\n+\tordinary nested types.\n+\t(instantiate_type): Use new interface to type_unification.\n+\t* lex.c (init_lex): Add __sz as opname for sizeof.\n+\t* method.c (build_overload_scope_ref): New function.\n+\t(build_overload_int): Handle complex expressions.  Set\n+\tnumeric_output_need_bar if necessary.\n+\t(build_overload_value): Handle non-PARM_DECL nodes; this\n+\troutine is now used by build_overload_int.  Remove some\n+\tassignments to numeric_output_need_bar.  Use\n+\tbuild_overload_scope_ref.\n+\t(build_qualified_name): Note that some template mangled names end\n+\twith digits, and set numeric_output_need_bar appropriately.  Use\n+\tbuild_underscore_int.\n+\t* pt.c (unify): Change interface.\n+\t(type_unification_real): Likewise.\n+\t(determine_specialization): Use new interfaces.\n+\t(tsubst): Deal gracefully with situations in which the argument\n+\tvector is not fully filled.\n+\t(fn_type_unification): Use new interfaces.\n+\t(type_unification): Likewise.  Remove NOP_EXPR hack.\n+\t(type_unification_real): Likewise.\n+\t(unify): Likewise.  Deal with unification of complex expresions.\n+\n Mon Mar 23 12:24:37 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (complete_template_args): Initialize skip properly."}, {"sha": "215bc950a524ff107431febe72a190066715968a", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=050367a36dc31833f15828aef52e33a37ef2a952", "patch": "@@ -107,7 +107,6 @@ cxxmain.o: cplus-dem.c demangle.h\n \t$(LN_S) $(srcdir)/cplus-dem.c cxxmain.c\n \t$(CC) -c -DMAIN $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t  -DVERSION=\\\"$(version)\\\" cxxmain.c\n-\trm -f cxxmain.c\n \n $(DEMANGLER_PROG): cxxmain.o underscore.o getopt.o getopt1.o $(LIBDEPS)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) $(LIBS) -o $@ \\"}, {"sha": "37f8086db445f5b38393994e8ce1cc5c52ff0165", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=050367a36dc31833f15828aef52e33a37ef2a952", "patch": "@@ -3322,7 +3322,8 @@ finish_struct_1 (t, warn_anon)\n \n       last_x = x;\n \n-      if (TREE_CODE (x) == TYPE_DECL)\n+      if (TREE_CODE (x) == TYPE_DECL\n+\t  || TREE_CODE (x) == TEMPLATE_DECL)\n \tcontinue;\n \n       /* If we've gotten this far, it's a data member, possibly static,\n@@ -5174,8 +5175,8 @@ instantiate_type (lhstype, rhs, complain)\n \t\t    tree t = make_scratch_vec (n);\n \t\t    int i;\n \t\t    i = type_unification\n-\t\t      (DECL_INNERMOST_TEMPLATE_PARMS (elem), \n-\t\t       &TREE_VEC_ELT (t, 0), TYPE_ARG_TYPES (TREE_TYPE (elem)),\n+\t\t      (DECL_INNERMOST_TEMPLATE_PARMS (elem), t,\n+\t\t       TYPE_ARG_TYPES (TREE_TYPE (elem)),\n \t\t       TYPE_ARG_TYPES (lhstype), explicit_targs, 1, 1);\n \t\t    if (i == 0)\n \t\t      {"}, {"sha": "1d2d24764952940e2f402bdf45b84362571b6a86", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=050367a36dc31833f15828aef52e33a37ef2a952", "patch": "@@ -2463,7 +2463,7 @@ extern tree instantiate_class_template\t\tPROTO((tree));\n extern tree instantiate_template\t\tPROTO((tree, tree));\n extern void overload_template_name\t\tPROTO((tree));\n extern int fn_type_unification                  PROTO((tree, tree, tree, tree, tree, int, tree));\n-extern int type_unification\t\t\tPROTO((tree, tree *, tree, tree, tree, int, int));\n+extern int type_unification\t\t\tPROTO((tree, tree, tree, tree, tree, int, int));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n extern void mark_decl_instantiated\t\tPROTO((tree, int));\n extern int more_specialized\t\t\tPROTO((tree, tree, tree));"}, {"sha": "d97ed3804aa91da598d1617dba38f834c7ac32b9", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=050367a36dc31833f15828aef52e33a37ef2a952", "patch": "@@ -1533,12 +1533,7 @@ dump_expr (t, nop)\n       }\n \n     case TEMPLATE_PARM_INDEX:\n-      {\n-\tint l = current_template_parms ? \n-\t  list_length (current_template_parms) : 0;\n-\n-\tdump_decl (TEMPLATE_PARM_DECL (t), -1);\n-      }\n+      dump_decl (TEMPLATE_PARM_DECL (t), -1);\n       break;\n \n     case IDENTIFIER_NODE:"}, {"sha": "2b5059814c50d9f7fe736cf41e4114b23d3264a7", "filename": "gcc/cp/method.c", "status": "modified", "additions": 86, "deletions": 24, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=050367a36dc31833f15828aef52e33a37ef2a952", "patch": "@@ -471,6 +471,16 @@ build_underscore_int (i)\n     OB_PUTC ('_');\n }\n \n+static void\n+build_overload_scope_ref (value)\n+     tree value;\n+{\n+  OB_PUTC2 ('Q', '2');\n+  numeric_output_need_bar = 0;\n+  build_mangled_name (TREE_OPERAND (value, 0), 0, 0);\n+  build_overload_identifier (TREE_OPERAND (value, 1));\n+}\n+\n /* Encoding for an INTEGER_CST value.  */\n \n static void\n@@ -479,13 +489,70 @@ build_overload_int (value, in_template)\n      int in_template;\n {\n   if (in_template && TREE_CODE (value) != INTEGER_CST)\n-    /* We don't ever want this output, but it's inconvenient not to\n-       be able to build the string.  This should cause assembler\n-       errors we'll notice.  */\n     {\n-      static int n;\n-      sprintf (digit_buffer, \" *%d\", n++);\n-      OB_PUTCP (digit_buffer);\n+      if (TREE_CODE (value) == SCOPE_REF)\n+\t{\n+\t  build_overload_scope_ref (value);\n+\t  return;\n+\t}\n+\n+      OB_PUTC ('E');\n+      numeric_output_need_bar = 0;\n+\n+      if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (value))))\n+\t{\n+\t  int i;\n+\t  int operands = tree_code_length[(int) TREE_CODE (value)];\n+\t  tree id;\n+\t  char* name;\n+\n+\t  id = ansi_opname [(int) TREE_CODE (value)];\n+\t  my_friendly_assert (id != NULL_TREE, 0);\n+\t  name = IDENTIFIER_POINTER (id);\n+\t  my_friendly_assert (name[0] == '_' && name[1] == '_', 0);\n+\n+\t  for (i = 0; i < operands; ++i)\n+\t    {\n+\t      tree operand;\n+\t      enum tree_code tc;\n+\n+\t      /* We just outputted either the `E' or the name of the\n+\t\t operator.  */\n+\t      numeric_output_need_bar = 0;\n+\n+\t      if (i != 0)\n+\t\t/* Skip the leading underscores.  */\n+\t\tOB_PUTCP (name + 2);\n+\n+\t      operand = TREE_OPERAND (value, i);\n+\t      tc = TREE_CODE (operand);\n+\n+\t      if (TREE_CODE_CLASS (tc) == 't')\n+\t\t/* We can get here with sizeof, e.g.:\n+\t\t     \n+\t\t   template <class T> void f(A<sizeof(T)>);  */\n+\t\tprocess_overload_item (operand, 0);\n+\t      else if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (tc)))\n+\t\tbuild_overload_int (operand, in_template);\n+\t      else\n+\t\tbuild_overload_value (TREE_TYPE (operand),\n+\t\t\t\t      operand,\n+\t\t\t\t      in_template);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* We don't ever want this output, but it's\n+\t     inconvenient not to be able to build the string.\n+\t     This should cause assembler errors we'll notice.  */\n+\t    \n+\t  static int n;\n+\t  sprintf (digit_buffer, \" *%d\", n++);\n+\t  OB_PUTCP (digit_buffer);\n+\t}\n+\n+      OB_PUTC ('W');\n+      numeric_output_need_bar = 0;\n       return;\n     }\n \n@@ -497,12 +564,14 @@ build_overload_int (value, in_template)\n \t{\n \t  /* need to print a DImode value in decimal */\n \t  dicat (TREE_INT_CST_LOW (value), TREE_INT_CST_HIGH (value));\n+\t  numeric_output_need_bar = 1;\n \t  return;\n \t}\n       /* else fall through to print in smaller mode */\n     }\n   /* Wordsize or smaller */\n   icat (TREE_INT_CST_LOW (value));\n+  numeric_output_need_bar = 1;\n }\n \n \n@@ -531,8 +600,11 @@ build_overload_value (type, value, in_template)\n   while (TREE_CODE (value) == NON_LVALUE_EXPR\n \t || TREE_CODE (value) == NOP_EXPR)\n     value = TREE_OPERAND (value, 0);\n-  my_friendly_assert (TREE_CODE (type) == PARM_DECL, 242);\n-  type = TREE_TYPE (type);\n+\n+  if (TREE_CODE (type) == PARM_DECL)\n+    type = TREE_TYPE (type);\n+\n+  my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (type)) == 't', 0);\n \n   if (numeric_output_need_bar)\n     {\n@@ -569,7 +641,6 @@ build_overload_value (type, value, in_template)\n     case BOOLEAN_TYPE:\n       {\n \tbuild_overload_int (value, in_template);\n-\tnumeric_output_need_bar = 1;\n \treturn;\n       }\n     case REAL_TYPE:\n@@ -672,7 +743,6 @@ build_overload_value (type, value, in_template)\n \t\t    {\n \t\t      OB_PUTC ('i');\n \t\t      build_overload_int (a3, in_template);\n-\t\t      numeric_output_need_bar = 1;\n \t\t      return;\n \t\t    }\n \t\t}\n@@ -683,7 +753,6 @@ build_overload_value (type, value, in_template)\n       if (TREE_CODE (value) == INTEGER_CST)\n \t{\n \t  build_overload_int (value, in_template);\n-\t  numeric_output_need_bar = 1;\n \t  return;\n \t}\n       else if (TREE_CODE (value) == TEMPLATE_PARM_INDEX)\n@@ -707,13 +776,7 @@ build_overload_value (type, value, in_template)\n \t  return;\n \t}\n       else if (TREE_CODE (value) == SCOPE_REF)\n-\t{\n-\t  OB_PUTC2 ('Q', '1');\n-\t  numeric_output_need_bar = 0;\n-\t  build_mangled_name (TREE_OPERAND (value, 0), 0, 0);\n-\t  build_overload_identifier (TREE_OPERAND (value, 1));\n-\t  return;\n-\t}\n+\tbuild_overload_scope_ref (value);\n       else\n \tmy_friendly_abort (71);\n       break; /* not really needed */\n@@ -865,7 +928,10 @@ build_qualified_name (decl)\n   if (TREE_CODE (decl) == TYPE_DECL\n       && DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl) && !flag_do_squangling)\n     {\n-      OB_PUTID (DECL_ASSEMBLER_NAME (decl));\n+      tree id = DECL_ASSEMBLER_NAME (decl);\n+      OB_PUTID (id);\n+      if (isdigit (IDENTIFIER_POINTER (id) [IDENTIFIER_LENGTH (id) - 1]))\n+\tnumeric_output_need_bar = 1;\n       return;\n     }\n \n@@ -907,11 +973,7 @@ build_qualified_name (decl)\n   if (i > 1)\n     {\n       OB_PUTC ('Q');\n-      if (i > 9)\n-\tOB_PUTC ('_');\n-      icat (i);\n-      if (i > 9)\n-\tOB_PUTC ('_');\n+      build_underscore_int (i);\n       numeric_output_need_bar = 0;\n     }\n   build_overload_nested_name (decl);"}, {"sha": "2e44007b3c508abf295b2d70f14f791a93379263", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 308, "deletions": 118, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=050367a36dc31833f15828aef52e33a37ef2a952", "patch": "@@ -43,6 +43,10 @@ Boston, MA 02111-1307, USA.  */\n #include <stdlib.h>\n #endif\n \n+/* The type of functions taking a tree, and some additional data, and\n+   returning an int.  */\n+typedef int (*tree_fn_t) PROTO((tree, void*));\n+\n extern struct obstack permanent_obstack;\n \n extern int lineno;\n@@ -69,7 +73,7 @@ static tree saved_trees;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-static int unify PROTO((tree, tree *, int, tree, tree, int));\n+static int unify PROTO((tree, tree, int, tree, tree, int, int*));\n static void add_pending_template PROTO((tree));\n static int push_tinst_level PROTO((tree));\n static tree classtype_mangled_name PROTO((tree));\n@@ -81,13 +85,14 @@ static tree get_class_bindings PROTO((tree, tree, tree, tree));\n static tree coerce_template_parms PROTO((tree, tree, tree, int, int, int));\n static tree tsubst_enum\tPROTO((tree, tree, tree *));\n static tree add_to_template_args PROTO((tree, tree));\n+static int  type_unification_real PROTO((tree, tree, tree, tree,\n+\t\t\t\t\t int, int, int, int*));\n static tree complete_template_args PROTO((tree, tree, int));\n-static int  type_unification_real PROTO((tree, tree *, tree, tree,\n-\t\t\t\t\t int, int, int));\n static void note_template_header PROTO((int));\n static tree maybe_fold_nontype_arg PROTO((tree));\n static tree convert_nontype_argument PROTO((tree, tree));\n static tree get_bindings_overload PROTO((tree, tree, tree));\n+static int for_each_template_parm PROTO((tree, tree_fn_t, void*));\n \n /* Do any processing required when DECL (a member template declaration\n    using TEMPLATE_PARAMETERS as its innermost parameter list) is\n@@ -719,7 +724,7 @@ determine_specialization (template_id, decl, targs_out,\n \t  /* We allow incomplete unification here, because we are going to\n \t     check all the functions. */\n \t  i = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (tmpl),\n-\t\t\t\t&TREE_VEC_ELT (targs, 0),\n+\t\t\t\ttargs,\n \t\t\t\tNULL_TREE,\n \t\t\t\tNULL_TREE,  \n \t\t\t\ttargs_in,\n@@ -1464,7 +1469,46 @@ build_template_decl (decl, parms)\n   return tmpl;\n }\n \n-  \n+struct template_parm_data\n+{\n+  int level;\n+  int* parms;\n+};\n+\n+/* Subroutine of push_template_decl used to see if each template\n+   parameter in a partial specialization is used in the explicit\n+   argument list.  If T is of the LEVEL given in DATA (which is\n+   treated as a template_parm_data*), then DATA->PARMS is marked\n+   appropriately.  */\n+\n+static int\n+mark_template_parm (t, data)\n+     tree t;\n+     void* data;\n+{\n+  int level;\n+  int idx;\n+  struct template_parm_data* tpd = (struct template_parm_data*) data;\n+\n+  if (TREE_CODE (t) == TEMPLATE_PARM_INDEX)\n+    {\n+      level = TEMPLATE_PARM_LEVEL (t);\n+      idx = TEMPLATE_PARM_IDX (t);\n+    }\n+  else\n+    {\n+      level = TEMPLATE_TYPE_LEVEL (t);\n+      idx = TEMPLATE_TYPE_IDX (t);\n+    }\n+\n+  if (level == tpd->level)\n+    tpd->parms[idx] = 1;\n+\n+  /* Return zero so that for_each_template_parm will continue the\n+     traversal of the tree; we want to mark *every* template parm.  */\n+  return 0;\n+}\n+\n /* Creates a TEMPLATE_DECL for the indicated DECL using the template\n    parameters given by current_template_args, or reuses a\n    previously existing one, if appropriate.  Returns the DECL, or an\n@@ -1529,6 +1573,66 @@ push_template_decl (decl)\n       tree mainargs = CLASSTYPE_TI_ARGS (type);\n       tree spec = DECL_TEMPLATE_SPECIALIZATIONS (maintmpl);\n \n+      /* We check that each of the template parameters given in the\n+\t partial specialization is used in the argument list to the\n+\t specialization.  For example:\n+\t \n+\t   template <class T> struct S;\n+\t   template <class T> struct S<T*>;\n+\n+\t The second declaration is OK because `T*' uses the template\n+\t parameter T, whereas\n+       \n+           template <class T> struct S<int>;\n+\n+\t is no good.  Even trickier is:\n+\n+\t   template <class T>\n+\t   struct S1\n+\t   {\n+\t      template <class U>\n+\t      struct S2;\n+\t      template <class U>\n+\t      struct S2<T>;\n+\t   };\n+\t   \n+\t The S2<T> declaration is actually illegal; it is a\n+\t full-specialization.  Of course, \n+\n+              template <class U>\n+              struct S2<T (*)(U)>;\n+\n+         or some such would have been OK.  */\n+      int  i;\n+      struct template_parm_data tpd;\n+      int ntparms = TREE_VEC_LENGTH (TREE_VALUE (current_template_parms));\n+      int did_error_intro = 0;\n+\n+      tpd.level = TREE_INT_CST_HIGH (TREE_PURPOSE (current_template_parms));\n+      tpd.parms = alloca (sizeof (int) * ntparms);\n+      for (i = 0; i < ntparms; ++i)\n+\ttpd.parms[i] = 0;\n+      for (i = 0; i < TREE_VEC_LENGTH (mainargs); ++i)\n+\tfor_each_template_parm (TREE_VEC_ELT (mainargs, i),\n+\t\t\t\t&mark_template_parm,\n+\t\t\t\t&tpd);\n+      for (i = 0; i < ntparms; ++i)\n+\tif (tpd.parms[i] == 0)\n+\t  {\n+\t    /* One of the template parms was not used in the\n+\t       specialization.  */\n+\t    if (!did_error_intro)\n+\t      {\n+\t\tcp_error (\"template parameters not used in partial specialization:\");\n+\t\tdid_error_intro = 1;\n+\t      }\n+\n+\t    cp_error (\"        `%D'\", \n+\t\t      TREE_VALUE (TREE_VEC_ELT \n+\t\t\t\t  (TREE_VALUE (current_template_parms),\n+\t\t\t\t   i)));\n+\t  }\n+\n       for (; spec; spec = TREE_CHAIN (spec))\n \t{\n \t  /* purpose: args to main template\n@@ -2505,6 +2609,8 @@ tree\n lookup_template_function (fns, arglist)\n      tree fns, arglist;\n {\n+  tree t;\n+\n   if (fns == NULL_TREE)\n     {\n       cp_error (\"non-template used as template\");\n@@ -2737,9 +2843,19 @@ lookup_template_class (d1, arglist, in_decl, context)\n /* Should be defined in parse.h.  */\n extern int yychar;\n \n+/* For each TEMPLATE_TYPE_PARM, TEMPLATE_TEMPLATE_PARM, or\n+   TEMPLATE_PARM_INDEX in T, call FN with the parameter and the DATA.\n+   If FN returns non-zero, the iteration is terminated, and\n+   for_each_template_parm returns 1.  Otherwise, the iteration\n+   continues.  If FN never returns a non-zero value, the value\n+   returned by for_each_template_parm is 0.  If FN is NULL, it is\n+   considered to be the function which always returns 1.  */\n+\n int\n-uses_template_parms (t)\n+for_each_template_parm (t, fn, data)\n      tree t;\n+     tree_fn_t fn;\n+     void* data;\n {\n   if (!t)\n     return 0;\n@@ -2750,7 +2866,7 @@ uses_template_parms (t)\n       /* We assume that the object must be instantiated in order to build\n \t the COMPONENT_REF, so we test only whether the type of the\n \t COMPONENT_REF uses template parms.  */\n-      return uses_template_parms (TREE_TYPE (t));\n+      return for_each_template_parm (TREE_TYPE (t), fn, data);\n \n     case IDENTIFIER_NODE:\n       if (!IDENTIFIER_TEMPLATE (t))\n@@ -2762,49 +2878,52 @@ uses_template_parms (t)\n       {\n \tint i = TREE_VEC_LENGTH (t);\n \twhile (i--)\n-\t  if (uses_template_parms (TREE_VEC_ELT (t, i)))\n+\t  if (for_each_template_parm (TREE_VEC_ELT (t, i), fn, data))\n \t    return 1;\n \treturn 0;\n       }\n     case TREE_LIST:\n-      if (uses_template_parms (TREE_PURPOSE (t))\n-\t  || uses_template_parms (TREE_VALUE (t)))\n+      if (for_each_template_parm (TREE_PURPOSE (t), fn, data)\n+\t  || for_each_template_parm (TREE_VALUE (t), fn, data))\n \treturn 1;\n-      return uses_template_parms (TREE_CHAIN (t));\n+      return for_each_template_parm (TREE_CHAIN (t), fn, data);\n \n       /* constructed type nodes */\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n-      return uses_template_parms (TREE_TYPE (t));\n+      return for_each_template_parm (TREE_TYPE (t), fn, data);\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_FLAG (t))\n-\treturn uses_template_parms (TYPE_PTRMEMFUNC_FN_TYPE (t));\n+\treturn for_each_template_parm (TYPE_PTRMEMFUNC_FN_TYPE (t),\n+\t\t\t\t       fn, data);\n     case UNION_TYPE:\n       if (! CLASSTYPE_TEMPLATE_INFO (t))\n \treturn 0;\n-      return uses_template_parms (TREE_VALUE (CLASSTYPE_TEMPLATE_INFO (t)));\n+      return for_each_template_parm (TREE_VALUE\n+\t\t\t\t     (CLASSTYPE_TEMPLATE_INFO (t)),\n+\t\t\t\t     fn, data);\n     case FUNCTION_TYPE:\n-      if (uses_template_parms (TYPE_ARG_TYPES (t)))\n+      if (for_each_template_parm (TYPE_ARG_TYPES (t), fn, data))\n \treturn 1;\n-      return uses_template_parms (TREE_TYPE (t));\n+      return for_each_template_parm (TREE_TYPE (t), fn, data);\n     case ARRAY_TYPE:\n-      if (uses_template_parms (TYPE_DOMAIN (t)))\n+      if (for_each_template_parm (TYPE_DOMAIN (t), fn, data))\n \treturn 1;\n-      return uses_template_parms (TREE_TYPE (t));\n+      return for_each_template_parm (TREE_TYPE (t), fn, data);\n     case OFFSET_TYPE:\n-      if (uses_template_parms (TYPE_OFFSET_BASETYPE (t)))\n+      if (for_each_template_parm (TYPE_OFFSET_BASETYPE (t), fn, data))\n \treturn 1;\n-      return uses_template_parms (TREE_TYPE (t));\n+      return for_each_template_parm (TREE_TYPE (t), fn, data);\n     case METHOD_TYPE:\n-      if (uses_template_parms (TYPE_METHOD_BASETYPE (t)))\n+      if (for_each_template_parm (TYPE_METHOD_BASETYPE (t), fn, data))\n \treturn 1;\n-      if (uses_template_parms (TYPE_ARG_TYPES (t)))\n+      if (for_each_template_parm (TYPE_ARG_TYPES (t), fn, data))\n \treturn 1;\n-      return uses_template_parms (TREE_TYPE (t));\n+      return for_each_template_parm (TREE_TYPE (t), fn, data);\n \n       /* decl nodes */\n     case TYPE_DECL:\n-      return uses_template_parms (TREE_TYPE (t));\n+      return for_each_template_parm (TREE_TYPE (t), fn, data);\n \n     case TEMPLATE_DECL:\n       /* A template template parameter is encountered */\n@@ -2816,41 +2935,45 @@ uses_template_parms (t)\n       return 0;\n       \n     case CONST_DECL:\n-      if (uses_template_parms (DECL_INITIAL (t)))\n+      if (for_each_template_parm (DECL_INITIAL (t), fn, data))\n \treturn 1;\n       goto check_type_and_context;\n \n     case FUNCTION_DECL:\n     case VAR_DECL:\n       /* ??? What about FIELD_DECLs?  */\n       if (DECL_LANG_SPECIFIC (t) && DECL_TEMPLATE_INFO (t)\n-\t  && uses_template_parms (DECL_TI_ARGS (t)))\n+\t  && for_each_template_parm (DECL_TI_ARGS (t), fn, data))\n \treturn 1;\n       /* fall through */\n     case PARM_DECL:\n     check_type_and_context:\n-      if (uses_template_parms (TREE_TYPE (t)))\n+      if (for_each_template_parm (TREE_TYPE (t), fn, data))\n \treturn 1;\n-      if (DECL_CONTEXT (t) && uses_template_parms (DECL_CONTEXT (t)))\n+      if (DECL_CONTEXT (t) \n+\t  && for_each_template_parm (DECL_CONTEXT (t), fn, data))\n \treturn 1;\n       return 0;\n \n     case CALL_EXPR:\n-      return uses_template_parms (TREE_TYPE (t));\n+      return for_each_template_parm (TREE_TYPE (t), fn, data);\n     case ADDR_EXPR:\n-      return uses_template_parms (TREE_OPERAND (t, 0));\n+      return for_each_template_parm (TREE_OPERAND (t, 0), fn, data);\n \n       /* template parm nodes */\n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_TEMPLATE_PARM:\n     case TEMPLATE_PARM_INDEX:\n-      return 1;\n+      if (fn)\n+\treturn (*fn)(t, data);\n+      else\n+\treturn 1;\n \n       /* simple type nodes */\n     case INTEGER_TYPE:\n-      if (uses_template_parms (TYPE_MIN_VALUE (t)))\n+      if (for_each_template_parm (TYPE_MIN_VALUE (t), fn, data))\n \treturn 1;\n-      return uses_template_parms (TYPE_MAX_VALUE (t));\n+      return for_each_template_parm (TYPE_MAX_VALUE (t), fn, data);\n \n     case REAL_TYPE:\n     case COMPLEX_TYPE:\n@@ -2863,7 +2986,7 @@ uses_template_parms (t)\n \ttree v;\n \n \tfor (v = TYPE_VALUES (t); v != NULL_TREE; v = TREE_CHAIN (v))\n-\t  if (uses_template_parms (TREE_VALUE (v)))\n+\t  if (for_each_template_parm (TREE_VALUE (v), fn, data))\n \t    return 1;\n       }\n       return 0;\n@@ -2885,12 +3008,13 @@ uses_template_parms (t)\n       return 1;\n \n     case SCOPE_REF:\n-      return uses_template_parms (TREE_OPERAND (t, 0));\n+      return for_each_template_parm (TREE_OPERAND (t, 0), fn, data);\n \n     case CONSTRUCTOR:\n       if (TREE_TYPE (t) && TYPE_PTRMEMFUNC_P (TREE_TYPE (t)))\n-\treturn uses_template_parms (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (t)));\n-      return uses_template_parms (TREE_OPERAND (t, 1));\n+\treturn for_each_template_parm (TYPE_PTRMEMFUNC_FN_TYPE\n+\t\t\t\t       (TREE_TYPE (t)), fn, data);\n+      return for_each_template_parm (TREE_OPERAND (t, 1), fn, data);\n \n     case MODOP_EXPR:\n     case CAST_EXPR:\n@@ -2905,7 +3029,7 @@ uses_template_parms (t)\n \n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n-      return uses_template_parms (TREE_OPERAND (t, 0));\n+      return for_each_template_parm (TREE_OPERAND (t, 0), fn, data);\n \n     default:\n       switch (TREE_CODE_CLASS (TREE_CODE (t)))\n@@ -2917,7 +3041,7 @@ uses_template_parms (t)\n \t  {\n \t    int i;\n \t    for (i = tree_code_length[(int) TREE_CODE (t)]; --i >= 0;)\n-\t      if (uses_template_parms (TREE_OPERAND (t, i)))\n+\t      if (for_each_template_parm (TREE_OPERAND (t, i), fn, data))\n \t\treturn 1;\n \t    return 0;\n \t  }\n@@ -2932,6 +3056,13 @@ uses_template_parms (t)\n     }\n }\n \n+int\n+uses_template_parms (t)\n+     tree t;\n+{\n+  return for_each_template_parm (t, 0, 0);\n+}\n+\n static struct tinst_level *current_tinst_level = 0;\n static struct tinst_level *free_tinst_level = 0;\n static int tinst_depth = 0;\n@@ -3549,7 +3680,7 @@ tsubst (t, args, in_decl)\n \t  r = lookup_template_class (t, argvec, in_decl, context);\n \n \t  return cp_build_type_variant (r, TYPE_READONLY (t),\n-\t\t\t\t\tTYPE_VOLATILE (t));\n+\t\t\t\tTYPE_VOLATILE (t));\n \t}\n \n       /* else fall through */\n@@ -3625,7 +3756,8 @@ tsubst (t, args, in_decl)\n \t  {\n \t    tree arg = NULL_TREE;\n \n-\t    if (TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+\t    if (TREE_VEC_ELT (args, 0) != NULL_TREE\n+\t\t&& TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n \t      {\n \t\tlevels = TREE_VEC_LENGTH (args);\n \t\tif (level <= levels)\n@@ -3678,12 +3810,15 @@ tsubst (t, args, in_decl)\n \t      }\n \t  }\n \n+\tif (level == 1)\n+\t  /* This can happen during the attempted tsubst'ing in\n+\t     unify.  This means that we don't yet have any information\n+\t     about the template parameter in question.  */\n+\t  return t;\n+\n \t/* If we get here, we must have been looking at a parm for a\n-\t   more deeply nested template.  */\n-\tmy_friendly_assert(level > 1, 0);\n-\t\n-\t/* Make a new version of this template parameter, but with a\n-\t   lower level.  */\n+\t   more deeply nested template.  Make a new version of this\n+\t   template parameter, but with a lower level.  */\n \tswitch (TREE_CODE (t))\n \t  {\n \t  case TEMPLATE_TYPE_PARM:\n@@ -5111,7 +5246,7 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n \t\t\t\t      fn_arg_types); \n \n   i = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (fn), \n-\t\t\t&TREE_VEC_ELT (targs, 0), \n+\t\t\ttargs,\n \t\t\tfn_arg_types,\n \t\t\tdecl_arg_types,\n \t\t\texplicit_targs,\n@@ -5147,15 +5282,17 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n int\n type_unification (tparms, targs, parms, args, targs_in,\n \t\t  strict, allow_incomplete)\n-     tree tparms, *targs, parms, args, targs_in;\n+     tree tparms, targs, parms, args, targs_in;\n      int strict, allow_incomplete;\n {\n   int ntparms = TREE_VEC_LENGTH (tparms);\n   tree arg;\n+  int* explicit_mask;\n   int i;\n   int r;\n \n-  bzero ((char *) targs, sizeof (tree) * ntparms);\n+  for (i = 0; i < ntparms; i++)\n+    TREE_VEC_ELT (targs, i) = NULL_TREE;\n \n   if (targs_in != NULL_TREE)\n     {\n@@ -5166,34 +5303,38 @@ type_unification (tparms, targs, parms, args, targs_in,\n       if (arg_vec == error_mark_node)\n \treturn 1;\n \n+      explicit_mask = alloca (sizeof (int) * TREE_VEC_LENGTH (targs));\n+      bzero (explicit_mask, sizeof(int) * TREE_VEC_LENGTH (targs));\n+\n       for (i = 0; \n \t   i < TREE_VEC_LENGTH (arg_vec) \n-\t     && TREE_VEC_ELT (arg_vec, i) != NULL_TREE; \n+\t     && TREE_VEC_ELT (arg_vec, i) != NULL_TREE;  \n \t   ++i)\n-\t/* Insert the template argument.  It is encoded as the operands\n-\t   of NOP_EXPRs so that unify can tell that it is an explicit\n-\t   arguments.  */\n-\ttargs[i] = build1 (NOP_EXPR, NULL_TREE, TREE_VEC_ELT (arg_vec, i));\n+\t{\n+\t  TREE_VEC_ELT (targs, i) = TREE_VEC_ELT (arg_vec, i);\n+\t  /* Let unify know that this argument was explicit.  */\n+\t  explicit_mask [i] = 1;\n+\t}\n     }\n-  \n-  r = type_unification_real (tparms, targs, parms, args, 0,\n-\t\t\t     strict, allow_incomplete); \n+  else\n+    explicit_mask = 0;\n \n-  for (i = 0, arg = targs_in; \n-       arg != NULL_TREE; \n-       arg = TREE_CHAIN (arg), ++i)\n-    if (TREE_CODE (targs[i]) == NOP_EXPR)\n-      targs[i] = TREE_OPERAND (targs[i], 0);\n+  r = type_unification_real (tparms, targs, parms, args, 0,\n+\t\t\t     strict, allow_incomplete, explicit_mask); \n \n   return r;\n }\n \n+/* Like type_unfication.  EXPLICIT_MASK, if non-NULL, is an array of\n+   integers, with ones in positions corresponding to arguments in\n+   targs that were provided explicitly, and zeros elsewhere.  */\n \n static int\n type_unification_real (tparms, targs, parms, args, subr,\n-\t\t       strict, allow_incomplete)\n-     tree tparms, *targs, parms, args;\n+\t\t       strict, allow_incomplete, explicit_mask)\n+     tree tparms, targs, parms, args;\n      int subr, strict, allow_incomplete;\n+     int* explicit_mask;\n {\n   tree parm, arg;\n   int i;\n@@ -5267,12 +5408,12 @@ type_unification_real (tparms, targs, parms, args, subr,\n \t      && TREE_CODE (TREE_VALUE (arg)) == TEMPLATE_DECL)\n \t    {\n \t      int ntparms;\n-\t      tree *targs;\n+\t      tree targs;\n \n \t      /* Have to back unify here */\n \t      arg = TREE_VALUE (arg);\n \t      ntparms = DECL_NTPARMS (arg);\n-\t      targs = (tree *) alloca (sizeof (tree) * ntparms);\n+\t      targs = make_scratch_vec (ntparms);\n \t      parm = expr_tree_cons (NULL_TREE, parm, NULL_TREE);\n \t      return \n \t\ttype_unification (DECL_INNERMOST_TEMPLATE_PARMS (arg), \n@@ -5304,7 +5445,8 @@ type_unification_real (tparms, targs, parms, args, subr,\n \t    arg = TYPE_MAIN_VARIANT (arg);\n \t}\n \n-      switch (unify (tparms, targs, ntparms, parm, arg, strict))\n+      switch (unify (tparms, targs, ntparms, parm, arg, strict,\n+\t\t     explicit_mask)) \n \t{\n \tcase 0:\n \t  break;\n@@ -5323,7 +5465,7 @@ type_unification_real (tparms, targs, parms, args, subr,\n     return 1;\n   if (!subr)\n     for (i = 0; i < ntparms; i++)\n-      if (!targs[i])\n+      if (TREE_VEC_ELT (targs, i) == NULL_TREE)\n \t{\n \t  if (!allow_incomplete)\n \t    error (\"incomplete type unification\");\n@@ -5335,11 +5477,13 @@ type_unification_real (tparms, targs, parms, args, subr,\n /* Tail recursion is your friend.  */\n \n static int\n-unify (tparms, targs, ntparms, parm, arg, strict)\n-     tree tparms, *targs, parm, arg;\n+unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n+     tree tparms, targs, parm, arg;\n      int ntparms, strict;\n+     int* explicit_mask;\n {\n   int idx;\n+  tree targ;\n \n   /* I don't think this will do the right thing with respect to types.\n      But the only case I've seen it in so far has been array bounds, where\n@@ -5372,12 +5516,13 @@ unify (tparms, targs, ntparms, parm, arg, strict)\n \n     case TEMPLATE_TYPE_PARM:\n       idx = TEMPLATE_TYPE_IDX (parm);\n+      targ = TREE_VEC_ELT (targs, idx);\n       /* Check for mixed types and values.  */\n       if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (tparms, idx))) != TYPE_DECL)\n \treturn 1;\n \n-      if (!strict && targs[idx] != NULL_TREE && \n-\t  TREE_CODE (targs[idx]) == NOP_EXPR)\n+      if (!strict && targ != NULL_TREE \n+\t  && explicit_mask && explicit_mask[idx])\n \t/* An explicit template argument.  Don't even try to match\n \t   here; the overload resolution code will manage check to\n \t   see whether the call is legal.  */ \n@@ -5402,24 +5547,23 @@ unify (tparms, targs, ntparms, parm, arg, strict)\n       }\n #endif\n       /* Simple cases: Value already set, does match or doesn't.  */\n-      if (targs[idx] == arg \n-\t  || (targs[idx] \n-\t      && TREE_CODE (targs[idx]) == NOP_EXPR \n-\t      && TREE_OPERAND (targs[idx], 0) == arg))\n+      if (targ == arg || (targ && explicit_mask && explicit_mask[idx]))\n \treturn 0;\n-      else if (targs[idx])\n+      else if (targ)\n \treturn 1;\n-      targs[idx] = arg;\n+      TREE_VEC_ELT (targs, idx) = arg;\n       return 0;\n \n     case TEMPLATE_TEMPLATE_PARM:\n       idx = TEMPLATE_TYPE_IDX (parm);\n+      targ = TREE_VEC_ELT (targs, idx);\n+\n       /* Check for mixed types and values.  */\n       if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (tparms, idx))) != TEMPLATE_DECL)\n \treturn 1;\n \n-      if (!strict && targs[idx] != NULL_TREE && \n-\t  TREE_CODE (targs[idx]) == NOP_EXPR)\n+      if (!strict && targ != NULL_TREE \n+\t  && explicit_mask && explicit_mask[idx])\n \t/* An explicit template argument.  Don't even try to match\n \t   here; the overload resolution code will manage check to\n \t   see whether the call is legal.  */ \n@@ -5465,29 +5609,27 @@ unify (tparms, targs, ntparms, parm, arg, strict)\n \t\t/* This argument can be deduced.  */\n \n \t\tif (unify (tparms, targs, ntparms, t, \n-\t\t\t   TREE_VEC_ELT (argvec, i), strict))\n+\t\t\t   TREE_VEC_ELT (argvec, i), strict, explicit_mask))\n \t\t  return 1;\n \t      }\n \t  }\n \t  arg = CLASSTYPE_TI_TEMPLATE (arg);\n \t}\n \n       /* Simple cases: Value already set, does match or doesn't.  */\n-      if (targs[idx] == arg \n-\t  || (targs[idx] \n-\t      && TREE_CODE (targs[idx]) == NOP_EXPR \n-\t      && TREE_OPERAND (targs[idx], 0) == arg))\n+      if (targ == arg || (targ && explicit_mask && explicit_mask[idx]))\n \treturn 0;\n-      else if (targs[idx])\n+      else if (targ)\n \treturn 1;\n-      targs[idx] = arg;\n+      TREE_VEC_ELT (targs, idx) = arg;\n       return 0;\n \n     case TEMPLATE_PARM_INDEX:\n       idx = TEMPLATE_PARM_IDX (parm);\n-      if (targs[idx])\n+      targ = TREE_VEC_ELT (targs, idx);\n+      if (targ)\n \t{\n-\t  int i = cp_tree_equal (targs[idx], arg);\n+\t  int i = cp_tree_equal (targ, arg);\n \t  if (i == 1)\n \t    return 0;\n \t  else if (i == 0)\n@@ -5496,24 +5638,24 @@ unify (tparms, targs, ntparms, parm, arg, strict)\n \t    my_friendly_abort (42);\n \t}\n \n-      targs[idx] = copy_to_permanent (arg);\n+      TREE_VEC_ELT (targs, idx) = copy_to_permanent (arg);\n       return 0;\n \n     case POINTER_TYPE:\n       if (TREE_CODE (arg) == RECORD_TYPE && TYPE_PTRMEMFUNC_FLAG (arg))\n \treturn unify (tparms, targs, ntparms, parm,\n-\t\t      TYPE_PTRMEMFUNC_FN_TYPE (arg), strict);\n+\t\t      TYPE_PTRMEMFUNC_FN_TYPE (arg), strict, explicit_mask);\n \n       if (TREE_CODE (arg) != POINTER_TYPE)\n \treturn 1;\n       return unify (tparms, targs, ntparms, TREE_TYPE (parm), TREE_TYPE (arg),\n-\t\t    strict);\n+\t\t    strict, explicit_mask);\n \n     case REFERENCE_TYPE:\n       if (TREE_CODE (arg) == REFERENCE_TYPE)\n \targ = TREE_TYPE (arg);\n       return unify (tparms, targs, ntparms, TREE_TYPE (parm), arg,\n-\t\t    strict);\n+\t\t    strict, explicit_mask);\n \n     case ARRAY_TYPE:\n       if (TREE_CODE (arg) != ARRAY_TYPE)\n@@ -5523,10 +5665,10 @@ unify (tparms, targs, ntparms, parm, arg, strict)\n \treturn 1;\n       if (TYPE_DOMAIN (parm) != NULL_TREE\n \t  && unify (tparms, targs, ntparms, TYPE_DOMAIN (parm),\n-\t\t    TYPE_DOMAIN (arg), strict) != 0)\n+\t\t    TYPE_DOMAIN (arg), strict, explicit_mask) != 0)\n \treturn 1;\n       return unify (tparms, targs, ntparms, TREE_TYPE (parm), TREE_TYPE (arg),\n-\t\t    strict);\n+\t\t    strict, explicit_mask);\n \n     case REAL_TYPE:\n     case COMPLEX_TYPE:\n@@ -5540,11 +5682,11 @@ unify (tparms, targs, ntparms, parm, arg, strict)\n \t{\n \t  if (TYPE_MIN_VALUE (parm) && TYPE_MIN_VALUE (arg)\n \t      && unify (tparms, targs, ntparms, TYPE_MIN_VALUE (parm),\n-\t\t\tTYPE_MIN_VALUE (arg), strict))\n+\t\t\tTYPE_MIN_VALUE (arg), strict, explicit_mask))\n \t    return 1;\n \t  if (TYPE_MAX_VALUE (parm) && TYPE_MAX_VALUE (arg)\n \t      && unify (tparms, targs, ntparms, TYPE_MAX_VALUE (parm),\n-\t\t\tTYPE_MAX_VALUE (arg), strict))\n+\t\t\tTYPE_MAX_VALUE (arg), strict, explicit_mask))\n \t    return 1;\n \t}\n       else if (TREE_CODE (parm) == REAL_TYPE\n@@ -5565,16 +5707,6 @@ unify (tparms, targs, ntparms, parm, arg, strict)\n \treturn 1;\n       return !tree_int_cst_equal (parm, arg);\n \n-    case MINUS_EXPR:\n-      {\n-\ttree t1, t2;\n-\tt1 = TREE_OPERAND (parm, 0);\n-\tt2 = TREE_OPERAND (parm, 1);\n-\treturn unify (tparms, targs, ntparms, t1,\n-\t\t      fold (build (PLUS_EXPR, integer_type_node, arg, t2)),\n-\t\t      strict);\n-      }\n-\n     case TREE_VEC:\n       {\n \tint i;\n@@ -5585,15 +5717,15 @@ unify (tparms, targs, ntparms, parm, arg, strict)\n \tfor (i = TREE_VEC_LENGTH (parm) - 1; i >= 0; i--)\n \t  if (unify (tparms, targs, ntparms,\n \t\t     TREE_VEC_ELT (parm, i), TREE_VEC_ELT (arg, i),\n-\t\t     strict))\n+\t\t     strict, explicit_mask))\n \t    return 1;\n \treturn 0;\n       }\n \n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_FLAG (parm))\n \treturn unify (tparms, targs, ntparms, TYPE_PTRMEMFUNC_FN_TYPE (parm),\n-\t\t      arg, strict);\n+\t\t      arg, strict, explicit_mask);\n \n       /* Allow trivial conversions.  */\n       if (TREE_CODE (arg) != RECORD_TYPE\n@@ -5614,7 +5746,7 @@ unify (tparms, targs, ntparms, parm, arg, strict)\n \t    return 1;\n \n \t  return unify (tparms, targs, ntparms, CLASSTYPE_TI_ARGS (parm),\n-\t\t\tCLASSTYPE_TI_ARGS (t), strict);\n+\t\t\tCLASSTYPE_TI_ARGS (t), strict, explicit_mask);\n \t}\n       else if (TYPE_MAIN_VARIANT (parm) != TYPE_MAIN_VARIANT (arg))\n \treturn 1;\n@@ -5630,20 +5762,20 @@ unify (tparms, targs, ntparms, parm, arg, strict)\n \treturn 1;\n      check_args:\n       if (unify (tparms, targs, ntparms, TREE_TYPE (parm),\n-\t\t TREE_TYPE (arg), strict))\n+\t\t TREE_TYPE (arg), strict, explicit_mask))\n \treturn 1;\n       return type_unification_real (tparms, targs, TYPE_ARG_TYPES (parm),\n \t\t\t\t    TYPE_ARG_TYPES (arg), 1, \n-\t\t\t\t    strict, 0);\n+\t\t\t\t    strict, 0, explicit_mask);\n \n     case OFFSET_TYPE:\n       if (TREE_CODE (arg) != OFFSET_TYPE)\n \treturn 1;\n       if (unify (tparms, targs, ntparms, TYPE_OFFSET_BASETYPE (parm),\n-\t\t TYPE_OFFSET_BASETYPE (arg), strict))\n+\t\t TYPE_OFFSET_BASETYPE (arg), strict, explicit_mask))\n \treturn 1;\n       return unify (tparms, targs, ntparms, TREE_TYPE (parm),\n-\t\t    TREE_TYPE (arg), strict);\n+\t\t    TREE_TYPE (arg), strict, explicit_mask);\n \n     case CONST_DECL:\n       if (arg != decl_constant_value (parm))\n@@ -5655,8 +5787,65 @@ unify (tparms, targs, ntparms, parm, arg, strict)\n       return 1;\n \n     default:\n-      sorry (\"use of `%s' in template type unification\",\n-\t     tree_code_name [(int) TREE_CODE (parm)]);\n+      if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (parm))))\n+\t{\n+\t  /* We're looking at an expression.  This can happen with\n+\t     something like:\n+\n+\t       template <int I>\n+\t       void foo(S<I>, S<I + 2>);\n+\n+             If the call looked like:\n+\n+               foo(S<2>(), S<4>());\n+\n+\t     we would have already matched `I' with `2'.  Now, we'd\n+\t     like to know if `4' matches `I + 2'.  So, we substitute\n+\t     into that expression, and fold constants, in the hope of\n+\t     figuring it out.  */\n+\t  tree t = \n+\t    maybe_fold_nontype_arg (tsubst_expr (parm, targs, NULL_TREE)); \n+\t  enum tree_code tc = TREE_CODE (t);\n+\n+\t  if (tc == MINUS_EXPR \n+\t      && TREE_CODE (TREE_OPERAND (t, 0)) == TEMPLATE_PARM_INDEX\n+\t      && TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST)\n+\t    {\n+\t      /* We handle this case specially, since it comes up with\n+\t\t arrays.  In particular, something like:\n+\n+\t\t template <int N> void f(int (&x)[N]);\n+\n+\t\t Here, we are trying to unify the range type, which\n+\t\t looks like [0 ... (N - 1)].  */\n+\t      tree t1, t2;\n+\t      t1 = TREE_OPERAND (parm, 0);\n+\t      t2 = TREE_OPERAND (parm, 1);\n+\n+\t      t = maybe_fold_nontype_arg (build (PLUS_EXPR,\n+\t\t\t\t\t\t integer_type_node,\n+\t\t\t\t\t\t arg, t2));\n+\n+\t      return unify (tparms, targs, ntparms, t1, t,\n+\t\t\t    strict, explicit_mask);\n+\t    }\n+\n+\t  if (!IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (tc)))\n+\t    /* Good, we mangaged to simplify the exression.  */\n+\t    return unify (tparms, targs, ntparms, t, arg, strict,\n+\t\t\t  explicit_mask);\n+\t  else\n+\t    /* Bad, we couldn't simplify this.  Assume it doesn't\n+\t       unify.  */\n+\t    return 1;\n+\t}\n+      else\n+\t{\n+\t  sorry (\"use of `%s' in template type unification\",\n+\t\t tree_code_name [(int) TREE_CODE (parm)]);\n+\t  break;\n+\t}\n+\n       return 1;\n     }\n }\n@@ -5837,8 +6026,9 @@ get_class_bindings (tparms, parms, args, outer_args)\n \n   for (i = 0; i < TREE_VEC_LENGTH (parms); ++i)\n     {\n-      switch (unify (tparms, &TREE_VEC_ELT (vec, 0), ntparms,\n-\t\t     TREE_VEC_ELT (parms, i), TREE_VEC_ELT (args, i), 1))\n+      switch (unify (tparms, vec, ntparms,\n+\t\t     TREE_VEC_ELT (parms, i), TREE_VEC_ELT (args, i),\n+\t\t     1, 0))\n \t{\n \tcase 0:\n \t  break;"}, {"sha": "898ab4bd500c490534a6042e8fde1990e3fa7ef5", "filename": "gcc/cplus-dem.c", "status": "modified", "additions": 278, "deletions": 200, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcplus-dem.c?ref=050367a36dc31833f15828aef52e33a37ef2a952", "patch": "@@ -197,7 +197,8 @@ static const struct optable\n   {\"min\",\t  \"<?\",\t\t0},\t\t/* old */\n   {\"mn\",\t  \"<?\",\t\tDMGL_ANSI},\t/* pseudo-ansi */\n   {\"nop\",\t  \"\",\t\t0},\t\t/* old (for operator=) */\n-  {\"rm\",\t  \"->*\",\tDMGL_ANSI}\t/* ansi */\n+  {\"rm\",\t  \"->*\",\tDMGL_ANSI},\t/* ansi */\n+  {\"sz\",          \"sizeof \",    DMGL_ANSI}      /* pseudo-ansi */\n };\n \n \n@@ -330,6 +331,10 @@ forget_types PARAMS ((struct work_stuff *));\n static void\n string_prepends PARAMS ((string *, string *));\n \n+static int \n+demangle_template_value_parm PARAMS ((struct work_stuff*, \n+\t\t\t\t      const char**, string*)); \n+\n /*  Translate count to integer, consuming tokens in the process.\n     Conversion terminates on the first non-digit character.\n     Trying to consume something that isn't a count results in\n@@ -995,6 +1000,270 @@ demangle_template_template_parm (work, mangled, tname)\n   return (success);\n }\n \n+static int\n+demangle_integral_value (work, mangled, s)\n+     struct work_stuff *work;\n+     const char** mangled;\n+     string* s;\n+{\n+  int success;\n+\n+  if (**mangled == 'E')\n+    {\n+      int need_operator = 0;\n+      \n+      success = 1;\n+      string_appendn (s, \"(\", 1);\n+      (*mangled)++;\n+      while (success && **mangled != 'W' && **mangled != '\\0')\n+\t{\n+\t  if (need_operator)\n+\t    {\n+\t      size_t i;\n+\t      size_t len;\n+\n+\t      success = 0;\n+\n+\t      len = strlen (*mangled);\n+\n+\t      for (i = 0; \n+\t\t   i < sizeof (optable) / sizeof (optable [0]);\n+\t\t   ++i)\n+\t\t{\n+\t\t  size_t l = strlen (optable[i].in);\n+\n+\t\t  if (l <= len\n+\t\t      && memcmp (optable[i].in, *mangled, l) == 0)\n+\t\t    {\n+\t\t      string_appendn (s, \" \", 1);\n+\t\t      string_append (s, optable[i].out);\n+\t\t      string_appendn (s, \" \", 1);\n+\t\t      success = 1;\n+\t\t      (*mangled) += l;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\n+\t      if (!success)\n+\t\tbreak;\n+\t    }\n+\t  else\n+\t    need_operator = 1;\n+\n+\t  success = demangle_template_value_parm (work, mangled, s);\n+\t}\n+\n+      if (**mangled != 'W')\n+\t  success = 0;\n+      else \n+\t{\n+\t  string_appendn (s, \")\", 1);\n+\t  (*mangled)++;\n+\t}\n+    }\n+  else if (**mangled == 'Q')\n+    success = demangle_qualified (work, mangled, s, 0, 1);\n+  else\n+    {\n+      success = 0;\n+\n+      if (**mangled == 'm')\n+\t{\n+\t  string_appendn (s, \"-\", 1);\n+\t  (*mangled)++;\n+\t}\n+      while (isdigit (**mangled))\t\n+\t{\n+\t  string_appendn (s, *mangled, 1);\n+\t  (*mangled)++;\n+\t  success = 1;\n+\t}\n+    }\n+  \n+  return success;\n+}\n+\n+static int \n+demangle_template_value_parm (work, mangled, s)\n+     struct work_stuff *work;\n+     const char **mangled;\n+     string* s;\n+{\n+  const char *old_p = *mangled;\n+  int is_pointer = 0;\n+  int is_real = 0;\n+  int is_integral = 0;\n+  int is_char = 0;\n+  int is_bool = 0;\n+  int done = 0;\n+  int success = 1;\n+\n+  while (*old_p && !done)\n+    {\t\n+      switch (*old_p)\n+\t{\n+\tcase 'P':\n+\tcase 'p':\n+\tcase 'R':\n+\t  done = is_pointer = 1;\n+\t  break;\n+\tcase 'C':\t/* const */\n+\tcase 'S':\t/* explicitly signed [char] */\n+\tcase 'U':\t/* unsigned */\n+\tcase 'V':\t/* volatile */\n+\tcase 'F':\t/* function */\n+\tcase 'M':\t/* member function */\n+\tcase 'O':\t/* ??? */\n+\tcase 'J':\t/* complex */\n+\t  old_p++;\n+\t  continue;\n+\tcase 'E':       /* expression */\n+\tcase 'Q':\t/* qualified name */\n+\t  done = is_integral = 1;\n+\t  break;\n+\tcase 'T':\t/* remembered type */\n+\t  abort ();\n+\t  break;\n+\tcase 'v':\t/* void */\n+\t  abort ();\n+\t  break;\n+\tcase 'x':\t/* long long */\n+\tcase 'l':\t/* long */\n+\tcase 'i':\t/* int */\n+\tcase 's':\t/* short */\n+\tcase 'w':\t/* wchar_t */\n+\t  done = is_integral = 1;\n+\t  break;\n+\tcase 'b':\t/* bool */\n+\t  done = is_bool = 1;\n+\t  break;\n+\tcase 'c':\t/* char */\n+\t  done = is_char = 1;\n+\t  break;\n+\tcase 'r':\t/* long double */\n+\tcase 'd':\t/* double */\n+\tcase 'f':\t/* float */\n+\t  done = is_real = 1;\n+\t  break;\n+\tdefault:\n+\t  /* it's probably user defined type, let's assume\n+\t     it's integral, it seems hard to figure out\n+\t     what it really is */\n+\t  done = is_integral = 1;\n+\t}\n+    }\n+  if (**mangled == 'Y')\n+    {\n+      /* The next argument is a template parameter. */\n+      int idx;\n+\n+      (*mangled)++;\n+      idx = consume_count_with_underscores (mangled);\n+      if (idx == -1 \n+\t  || (work->tmpl_argvec && idx >= work->ntmpl_args)\n+\t  || consume_count_with_underscores (mangled) == -1)\n+\treturn -1;\n+      if (work->tmpl_argvec)\n+\tstring_append (s, work->tmpl_argvec[idx]);\n+      else\n+\t{\n+\t  char buf[10];\n+\t  sprintf(buf, \"T%d\", idx);\n+\t  string_append (s, buf);\n+\t}\n+    }\n+  else if (is_integral)\n+    success = demangle_integral_value (work, mangled, s);\n+  else if (is_char)\n+    {\n+      char tmp[2];\n+      int val;\n+      if (**mangled == 'm')\n+\t{\n+\t  string_appendn (s, \"-\", 1);\n+\t  (*mangled)++;\n+\t}\n+      string_appendn (s, \"'\", 1);\n+      val = consume_count(mangled);\n+      if (val == 0)\n+\treturn -1;\n+      tmp[0] = (char)val;\n+      tmp[1] = '\\0';\n+      string_appendn (s, &tmp[0], 1);\n+      string_appendn (s, \"'\", 1);\n+    }\n+  else if (is_bool)\n+    {\n+      int val = consume_count (mangled);\n+      if (val == 0)\n+\tstring_appendn (s, \"false\", 5);\n+      else if (val == 1)\n+\tstring_appendn (s, \"true\", 4);\n+      else\n+\tsuccess = 0;\n+    }\n+  else if (is_real)\n+    {\n+      if (**mangled == 'm')\n+\t{\n+\t  string_appendn (s, \"-\", 1);\n+\t  (*mangled)++;\n+\t}\n+      while (isdigit (**mangled))\t\n+\t{\n+\t  string_appendn (s, *mangled, 1);\n+\t  (*mangled)++;\n+\t}\n+      if (**mangled == '.') /* fraction */\n+\t{\n+\t  string_appendn (s, \".\", 1);\n+\t  (*mangled)++;\n+\t  while (isdigit (**mangled))\t\n+\t    {\n+\t      string_appendn (s, *mangled, 1);\n+\t      (*mangled)++;\n+\t    }\n+\t}\n+      if (**mangled == 'e') /* exponent */\n+\t{\n+\t  string_appendn (s, \"e\", 1);\n+\t  (*mangled)++;\n+\t  while (isdigit (**mangled))\t\n+\t    {\n+\t      string_appendn (s, *mangled, 1);\n+\t      (*mangled)++;\n+\t    }\n+\t}\n+    }\n+  else if (is_pointer)\n+    {\n+      int symbol_len = consume_count (mangled);\n+      if (symbol_len == 0)\n+\treturn -1;\n+      if (symbol_len == 0)\n+\tstring_appendn (s, \"0\", 1);\n+      else\n+\t{\n+\t  char *p = xmalloc (symbol_len + 1), *q;\n+\t  strncpy (p, *mangled, symbol_len);\n+\t  p [symbol_len] = '\\0';\n+\t  q = cplus_demangle (p, work->options);\n+\t  string_appendn (s, \"&\", 1);\n+\t  if (q)\n+\t    {\n+\t      string_append (s, q);\n+\t      free (q);\n+\t    }\n+\t  else\n+\t    string_append (s, p);\n+\t  free (p);\n+\t}\n+      *mangled += symbol_len;\n+    }\n+\n+  return success;\n+}\n+\n static int\n demangle_template (work, mangled, tname, trawname, is_type)\n      struct work_stuff *work;\n@@ -1004,18 +1273,10 @@ demangle_template (work, mangled, tname, trawname, is_type)\n      int is_type;\n {\n   int i;\n-  int is_pointer;\n-  int is_real;\n-  int is_integral;\n-  int is_char;\n-  int is_bool;\n   int r;\n   int need_comma = 0;\n   int success = 0;\n-  int done;\n-  const char *old_p;\n   const char *start;\n-  int symbol_len;\n   int is_java_array = 0;\n   string temp;\n \n@@ -1148,13 +1409,7 @@ demangle_template (work, mangled, tname, trawname, is_type)\n \t  string* s;\n \n \t  /* otherwise, value parameter */\n-\t  old_p  = *mangled;\n-\t  is_pointer = 0;\n-\t  is_real = 0;\n-\t  is_integral = 0;\n-          is_char = 0;\n-\t  is_bool = 0;\n-\t  done = 0;\n+\n \t  /* temp is initialized in do_type */\n \t  success = do_type (work, mangled, &temp);\n \t  /*\n@@ -1180,193 +1435,16 @@ demangle_template (work, mangled, tname, trawname, is_type)\n \t  else\n \t    s = tname;\n \n-\t  while (*old_p && !done)\n-\t    {\t\n-\t      switch (*old_p)\n-\t\t{\n-\t\tcase 'P':\n-\t\tcase 'p':\n-\t\tcase 'R':\n-\t\t  done = is_pointer = 1;\n-\t\t  break;\n-\t\tcase 'C':\t/* const */\n-\t\tcase 'S':\t/* explicitly signed [char] */\n-\t\tcase 'U':\t/* unsigned */\n-\t\tcase 'V':\t/* volatile */\n-\t\tcase 'F':\t/* function */\n-\t\tcase 'M':\t/* member function */\n-\t\tcase 'O':\t/* ??? */\n-\t\tcase 'J':\t/* complex */\n-\t\t  old_p++;\n-\t\t  continue;\n-\t\tcase 'Q':\t/* qualified name */\n-\t\t  done = is_integral = 1;\n-\t\t  break;\n-\t\tcase 'T':\t/* remembered type */\n-\t\t  abort ();\n-\t\t  break;\n-\t\tcase 'v':\t/* void */\n-\t\t  abort ();\n-\t\t  break;\n-\t\tcase 'x':\t/* long long */\n-\t\tcase 'l':\t/* long */\n-\t\tcase 'i':\t/* int */\n-\t\tcase 's':\t/* short */\n-\t\tcase 'w':\t/* wchar_t */\n-\t\t  done = is_integral = 1;\n-\t\t  break;\n-\t\tcase 'b':\t/* bool */\n-\t\t  done = is_bool = 1;\n-\t\t  break;\n-\t\tcase 'c':\t/* char */\n-\t\t  done = is_char = 1;\n-\t\t  break;\n-\t\tcase 'r':\t/* long double */\n-\t\tcase 'd':\t/* double */\n-\t\tcase 'f':\t/* float */\n-\t\t  done = is_real = 1;\n-\t\t  break;\n-\t\tdefault:\n-\t\t  /* it's probably user defined type, let's assume\n-\t\t     it's integral, it seems hard to figure out\n-\t\t     what it really is */\n-\t\t  done = is_integral = 1;\n-\t\t}\n-\t    }\n-\t  if (**mangled == 'Y')\n-\t    {\n-\t      /* The next argument is a template parameter. */\n-\t      int idx;\n+\t  success = demangle_template_value_parm (work, mangled, s);\n \n-\t      (*mangled)++;\n-\t      idx = consume_count_with_underscores (mangled);\n-\t      if (idx == -1 \n-\t\t  || (work->tmpl_argvec && idx >= work->ntmpl_args)\n-\t\t  || consume_count_with_underscores (mangled) == -1)\n-\t\t{\n-\t\t  success = 0;\n-\t\t  if (!is_type)\n-\t\t    string_delete (s);\n-\t\t  break;\n-\t\t}\n-\t      if (work->tmpl_argvec)\n-\t\tstring_append (s, work->tmpl_argvec[idx]);\n-\t      else\n-\t\t{\n-\t\t  char buf[10];\n-\t\t  sprintf(buf, \"T%d\", idx);\n-\t\t  string_append (s, buf);\n-\t\t}\n-\t    }\n-\t  else if (is_integral)\n-\t    {\n-\t      if (**mangled == 'm')\n-\t\t{\n-\t\t  string_appendn (s, \"-\", 1);\n-\t\t  (*mangled)++;\n-\t\t}\n-\t      while (isdigit (**mangled))\t\n-\t\t{\n-\t\t  string_appendn (s, *mangled, 1);\n-\t\t  (*mangled)++;\n-\t\t}\n-\t    }\n-\t  else if (is_char)\n-\t    {\n-\t      char tmp[2];\n-\t      int val;\n-              if (**mangled == 'm')\n-                {\n-                  string_appendn (s, \"-\", 1);\n-                  (*mangled)++;\n-                }\n-\t      string_appendn (s, \"'\", 1);\n-              val = consume_count(mangled);\n-\t      if (val == 0)\n-\t\t{\n-\t\t  success = 0;\n-\t\t  if (!is_type)\n-\t\t    string_delete (s);\n-\t\t  break;\n-                }\n-              tmp[0] = (char)val;\n-              tmp[1] = '\\0';\n-              string_appendn (s, &tmp[0], 1);\n-\t      string_appendn (s, \"'\", 1);\n-\t    }\n-\t  else if (is_bool)\n-\t    {\n-\t      int val = consume_count (mangled);\n-\t      if (val == 0)\n-\t\tstring_appendn (s, \"false\", 5);\n-\t      else if (val == 1)\n-\t\tstring_appendn (s, \"true\", 4);\n-\t      else\n-\t\tsuccess = 0;\n-\t    }\n-\t  else if (is_real)\n-\t    {\n-\t      if (**mangled == 'm')\n-\t\t{\n-\t\t  string_appendn (s, \"-\", 1);\n-\t\t  (*mangled)++;\n-\t\t}\n-\t      while (isdigit (**mangled))\t\n-\t\t{\n-\t\t  string_appendn (s, *mangled, 1);\n-\t\t  (*mangled)++;\n-\t\t}\n-\t      if (**mangled == '.') /* fraction */\n-\t\t{\n-\t\t  string_appendn (s, \".\", 1);\n-\t\t  (*mangled)++;\n-\t\t  while (isdigit (**mangled))\t\n-\t\t    {\n-\t\t      string_appendn (s, *mangled, 1);\n-\t\t      (*mangled)++;\n-\t\t    }\n-\t\t}\n-\t      if (**mangled == 'e') /* exponent */\n-\t\t{\n-\t\t  string_appendn (s, \"e\", 1);\n-\t\t  (*mangled)++;\n-\t\t  while (isdigit (**mangled))\t\n-\t\t    {\n-\t\t      string_appendn (s, *mangled, 1);\n-\t\t      (*mangled)++;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else if (is_pointer)\n+\t  if (!success)\n \t    {\n-\t      symbol_len = consume_count (mangled);\n-\t      if (symbol_len == 0)\n-\t\t{\n-\t\t  success = 0;\n-\t\t  if (!is_type)\n-\t\t    string_delete (s);\n-\t\t  break;\n-\t\t}\n-\t      if (symbol_len == 0)\n-\t\tstring_appendn (s, \"0\", 1);\n-\t      else\n-\t\t{\n-\t\t  char *p = xmalloc (symbol_len + 1), *q;\n-\t\t  strncpy (p, *mangled, symbol_len);\n-\t\t  p [symbol_len] = '\\0';\n-\t\t  q = cplus_demangle (p, work->options);\n-\t\t  string_appendn (s, \"&\", 1);\n-\t\t  if (q)\n-\t\t    {\n-\t\t      string_append (s, q);\n-\t\t      free (q);\n-\t\t    }\n-\t\t  else\n-\t\t    string_append (s, p);\n-\t\t  free (p);\n-\t\t}\n-\t      *mangled += symbol_len;\n+\t      if (!is_type)\n+\t\tstring_delete (s);\n+\t      success = 0;\n+\t      break;\n \t    }\n+\n \t  if (!is_type)\n \t    {\n \t      int len = s->p - s->b;"}, {"sha": "510d4cdd8363413f492d1ddb6ed7a07cd6ca1791", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash4.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash4.C?ref=050367a36dc31833f15828aef52e33a37ef2a952", "patch": "@@ -0,0 +1,11 @@\n+// Build don't link:\n+\n+template <unsigned rank>\n+class Tensor\n+{\n+};\n+\n+template <unsigned rank>\n+class Tensor<2> : Tensor<rank> { // ERROR - template parameters not used\n+};\n+"}, {"sha": "cdb868770bcde30a1153ae29016973b37faaa09d", "filename": "gcc/testsuite/g++.old-deja/g++.pt/expr1.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr1.C?ref=050367a36dc31833f15828aef52e33a37ef2a952", "patch": "@@ -0,0 +1,33 @@\n+template <int n> class vec {\n+    double x[n];\n+\n+    public:\n+    vec() {\n+ for (int i=0; i<n-1; ++i) x[i]=0;\n+    }\n+\n+    vec(const vec<n>& v) {\n+ for (int i=0; i<n; ++i) x[i]=v(i);\n+    }\n+\n+    vec(const vec<n-1>& v, const double& y) {\n+ for (int i=0; i<n-1; ++i) x[i]=v(i);\n+ x[n-1]=y;\n+    }\n+\n+    inline double operator()(const int i) const {\n+ return x[i];\n+    }\n+};\n+\n+\n+template <int n> vec<n + 1>& operator,(const vec<n>& v, const double& y) {\n+    return *(new vec<n + 1>(v, y));\n+}\n+\n+\n+int main() {\n+    vec<4> v;\n+    vec<5> w;\n+    w=(v,3.);\n+}"}, {"sha": "d6e5593b242293ebdce0ba41778d51a29b25432f", "filename": "gcc/testsuite/g++.old-deja/g++.pt/expr2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr2.C?ref=050367a36dc31833f15828aef52e33a37ef2a952", "patch": "@@ -0,0 +1,12 @@\n+// Build don't link:\n+\n+template <int I>\n+struct S {};\n+\n+template <int J>\n+void foo(S<J + 2>);\n+\n+void bar()\n+{\n+  foo(S<3>()); // ERROR - no way to deduce J from this.\n+}"}, {"sha": "4d77370e1864f28d5f8ab8406cb54dbfa9e41e33", "filename": "gcc/testsuite/g++.old-deja/g++.pt/expr3.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr3.C?ref=050367a36dc31833f15828aef52e33a37ef2a952", "patch": "@@ -0,0 +1,20 @@\n+// Build don't link:\n+\n+template <int I>\n+struct S {};\n+\n+template <int J>\n+void foo(S<J - 1>);\n+\n+template <class T>\n+void baz(S<sizeof(T)>);\n+\n+template <int J>\n+void fun(S<J>, S<J * 2>);\n+\n+void bar()\n+{\n+  foo<5>(S<4>()); // OK - 4 is 5 - 1.\n+  baz<int>(S<sizeof(int)>()); // OK\n+  fun(S<4>(), S<8>()); // OK - deduce J from first argument.\n+}"}, {"sha": "13298febe4d6be2c7aff3a28c5bcdf24c1be84fc", "filename": "gcc/testsuite/g++.old-deja/g++.pt/expr4.C", "status": "added", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/050367a36dc31833f15828aef52e33a37ef2a952/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fexpr4.C?ref=050367a36dc31833f15828aef52e33a37ef2a952", "patch": "@@ -0,0 +1,373 @@\n+template<class View, class W>\n+class TinyContainer {\n+public:\n+\n+  typedef W T_Wrapped;\n+\n+  TinyContainer() { }\n+  TinyContainer(View data) : m_data(data) { }\n+\n+  T_Wrapped &unwrap() \n+  { \n+    return *static_cast<T_Wrapped *>(this);\n+  }\n+  const T_Wrapped &unwrap() const \n+  { \n+    return *static_cast<const T_Wrapped *>(this);\n+  }\n+\n+protected:\n+\n+  mutable View m_data;\n+};\n+\n+template<class Op, class Left, class Right>\n+class TinyBinaryExpr :\n+  public TinyContainer< Op, TinyBinaryExpr<Op, Left, Right> > {\n+public:\n+\n+  typedef typename Left::T_Return T_Return;\n+  typedef TinyBinaryExpr<Op, Left, Right> T_Expr;\n+  \n+  T_Expr makeExpr() const { return *this; }\n+\n+  TinyBinaryExpr(const Op &op, const Left &left, const Right &right)\n+  : TinyContainer< Op, TinyBinaryExpr<Op, Left, Right> >(op),\n+    m_left(left), m_right(right)\n+  { }\n+\n+  TinyBinaryExpr(const Left &left, const Right &right)\n+  : m_left(left), m_right(right)\n+  { }\n+  \n+  Op op() const { return m_data; }\n+  Left left() const { return m_left; }\n+  Right right() const { return m_right; }\n+\n+private:\n+\n+  Left m_left;\n+  Right m_right;\n+};\n+\n+struct OpAdd {\n+\n+  template<class T1, class T2>\n+  static T1 apply(const T1 &l, const T2 &r)\n+  {\n+    return l + r;\n+  }\n+\n+};\n+\n+template<class V1, class T1, class V2, class T2>\n+inline TinyBinaryExpr<OpAdd, typename T1::T_Expr, typename T2::T_Expr>\n+operator+(const TinyContainer<V1,T1>& l, const TinyContainer<V2,T2>& r)\n+{\n+  typedef TinyBinaryExpr<OpAdd, typename T1::T_Expr, typename T2::T_Expr> ret;\n+  return ret(l.unwrap().makeExpr(), r.unwrap().makeExpr());\n+}\n+\n+\n+template<class Op, class T1, class T2, class Functor>\n+inline\n+typename T1::T_Return\n+for_each(const TinyBinaryExpr<Op,T1,T2>& node, Functor f)\n+{\n+  return Op::apply(for_each(node.left(),f), for_each(node.right(),f));\n+}\n+\n+template<class T, unsigned Nrows, unsigned Ncols, unsigned S1, unsigned S2>\n+class DenseDataView\n+  : public TinyContainer< T*, DenseDataView<T, Nrows, Ncols, S1, S2> > {\n+public:\n+\n+  typedef T T_Return;\n+  typedef DenseDataView<T, Nrows, Ncols, S1, S2> T_Expr;\n+\n+  T_Expr makeExpr() const { return *this; }\n+\n+  T *beginLoc(unsigned i, unsigned j) const \n+  { return m_data + S1 * i + S2 * j; }\n+\n+  DenseDataView(T *pData) \n+  : TinyContainer< T*, DenseDataView<T, Nrows, Ncols, S1, S2> >(pData) { }\n+\n+  T &offset(unsigned i, unsigned j)\n+  {\n+    return m_data[S1 * i + S2 * j];\n+  }\n+\n+  T offset(unsigned i, unsigned j) const\n+  {\n+    return m_data[S1 * i + S2 * j];\n+  }\n+\n+  template<unsigned I, unsigned J>\n+  struct Offset {\n+\n+    static T &apply(DenseDataView<T, Nrows, Ncols, S1, S2> &d)\n+    {\n+      return d.m_data[S1 * I + S2 * J];\n+    }\n+\n+    static T constApply(const DenseDataView<T, Nrows, Ncols, S1, S2> &d)\n+    {\n+      return d.m_data[S1 * I + S2 * J];\n+    }\n+\n+  };\n+\n+};\n+\n+template<unsigned I, unsigned J>\n+struct Eval2 { };\n+\n+template<class T, unsigned Nrows, unsigned Ncols, unsigned S1, unsigned S2,\n+  unsigned I, unsigned J>\n+inline T\n+for_each(const DenseDataView<T, Nrows, Ncols, S1, S2> &d, \n+  const Eval2<I,J> &e)\n+{\n+  return d.offset(I, J);\n+}\n+\n+template<class T, unsigned Nrows, unsigned Ncols>\n+class DenseData\n+  : public TinyContainer< T[Nrows * Ncols], DenseData<T, Nrows, Ncols> > {\n+public:\n+\n+  typedef T T_Return;\n+  typedef DenseDataView<T, Nrows, Ncols, 1, Nrows> T_Expr;\n+\n+  T_Expr makeExpr() const { return T_Expr(m_data); }\n+\n+  T *beginLoc(unsigned i, unsigned j) const \n+  { return &m_data[i + Nrows * j]; }\n+\n+  T &operator[](unsigned i)\n+  {\n+    return m_data[i];\n+  }\n+\n+  T operator[](unsigned i) const\n+  {\n+    return m_data[i];\n+  }\n+\n+  T &offset(unsigned i, unsigned j)\n+  {\n+    return m_data[i + Nrows * j];\n+  }\n+\n+  T offset(unsigned i, unsigned j) const\n+  {\n+    return m_data[i + Nrows * j];\n+  }\n+\n+  template<unsigned I, unsigned J>\n+  struct Offset {\n+\n+    static T &apply(DenseData<T, Nrows, Ncols> &d)\n+    {\n+      return d.m_data[I + Nrows * J];\n+    }\n+\n+    static T constApply(const DenseData<T, Nrows, Ncols> &d)\n+    {\n+      return d.m_data[I + Nrows * J];\n+    }\n+\n+  };\n+\n+};\n+\n+template<class T, unsigned Nrc>\n+class DiagonalData {\n+public:\n+\n+  T &offset(unsigned i, unsigned j)\n+  {\n+    assert(i == j);\n+    return m_data[i];\n+  }\n+\n+  T offset(unsigned i, unsigned j) const\n+  {\n+    return (i == j) ? m_data[i] : T(0);\n+  }\n+\n+  template<unsigned I, unsigned J>\n+  struct Offset {\n+\n+    static T &apply(DiagonalData<T,Nrc> &d)\n+    {\n+      assert(I == J);\n+      return d.m_data[I];\n+    }\n+\n+    static T constApply(const DiagonalData<T,Nrc> &d)\n+    {\n+      return (I == J) ? d.m_data[I] : T(0);\n+    }\n+\n+  };\n+\n+private:\n+  \n+  T m_data[Nrc];\n+};\n+\n+template<unsigned I, unsigned J, unsigned C1>\n+struct InnerLoop {\n+\n+  template<class LHS, class RHS>\n+  static inline void eval(LHS &l, const RHS &r)\n+  {\n+    l.offset(I,J) = for_each(r, Eval2<I,J>());\n+    InnerLoop<I + 1, J, C1 - 1>::eval(l, r);\n+  }\n+\n+};\n+\n+template<unsigned I, unsigned J>\n+struct InnerLoop<I, J, 0> {\n+\n+  template<class LHS, class RHS>\n+  static inline void eval(LHS &, const RHS &) { }\n+\n+};\n+\n+template<unsigned I, unsigned J, unsigned C1, unsigned C2>\n+struct Loop2 {\n+\n+  template<class LHS, class RHS>\n+  static inline void eval(LHS &l, const RHS &r)\n+  {\n+    InnerLoop<I, J, C1>::eval(l, r);\n+    Loop2<I, J + 1, C1, C2 - 1>::eval(l, r);\n+  }\n+};\n+\n+template<unsigned I, unsigned J, unsigned C1>\n+struct Loop2<I, J, C1, 0> {\n+\n+  template<class LHS, class RHS>\n+  static inline void eval(LHS &l, const RHS &r) { }\n+\n+};\n+\n+\n+template<unsigned Begin, unsigned End, unsigned Stride = 1>\n+class TinyRange {\n+public:\n+\n+  static const unsigned b = Begin;\n+  static const unsigned e = End;\n+  static const unsigned s = Stride;\n+  static const unsigned n = (End - Begin) / Stride + 1;\n+\n+  static unsigned index(unsigned i)\n+    {\n+      return b + s * i;\n+    }\n+};\n+\n+template<class Range1, class Range2, class Data>\n+struct Merge { };\n+\n+template<class Range1, class Range2, class T, unsigned Nrows, unsigned Ncols>\n+struct Merge<Range1, Range2, DenseData<T, Nrows, Ncols> >\n+{\n+  static const unsigned s2 = Nrows * Range2::s;\n+  typedef \n+    DenseDataView<T, Range1::n, Range2::n, Range1::s, s2> type;\n+};\n+\n+template<class Range1, class Range2, class T, unsigned Nrows, unsigned Ncols,\n+  unsigned S1, unsigned S2>\n+struct Merge<Range1, Range2, DenseDataView<T, Nrows, Ncols, S1, S2> >\n+{\n+  static const unsigned s1 = S1 * Range1::s;\n+  static const unsigned s2 = S2 * Range2::s;\n+\n+  typedef\n+    DenseDataView<T, Range1::n, Range2::n, s1, s2> type;\n+};\n+\n+template<class T, unsigned Nrows, unsigned Ncols, \n+  class Data = DenseData<T, Nrows, Ncols> >\n+class TinyMatrix :\n+  public TinyContainer< Data, TinyMatrix<T, Nrows, Ncols, Data> > {\n+public:\n+\n+  typedef T T_Return;\n+  typedef typename Data::T_Expr T_Expr;\n+  typedef TinyContainer< Data, TinyMatrix<T, Nrows, Ncols, Data> > T_Base;\n+  \n+  T_Expr makeExpr() const { return m_data.makeExpr(); }\n+\n+  TinyMatrix() { }\n+\n+  TinyMatrix(const T &a0, const T &a1, const T &a2, \n+\t     const T &a3, const T &a4, const T &a5)\n+  {\n+    m_data[0] = a0; m_data[1] = a1; m_data[2] = a2;\n+    m_data[3] = a3; m_data[4] = a4; m_data[5] = a5;\n+  }\n+\n+  TinyMatrix(const T &a0, const T &a1)\n+  {\n+    m_data[0] = a0; m_data[1] = a1;\n+  }\n+\n+  TinyMatrix(const Data &d) : T_Base(d) { }\n+\n+  T operator()(unsigned i, unsigned j) const\n+  {\n+    return m_data.offset(i, j);\n+  }\n+\n+  template<unsigned B1, unsigned E1, unsigned S1,\n+    unsigned B2, unsigned E2, unsigned S2>\n+  TinyMatrix<T, TinyRange<B1, E1, S1>::n,\n+      TinyRange<B2, E2, S2>::n, \n+      typename \n+      Merge< TinyRange<B1, E1, S1>, TinyRange<B2, E2, S2>, Data>::type>  \n+  operator()(const TinyRange<B1, E1, S1> &r1, const TinyRange<B2, E2, S2> &r2)\n+  {\n+    typedef typename \n+      Merge< TinyRange<B1, E1, S1>, TinyRange<B2, E2, S2>, Data>::type\n+      T_DataType;\n+    typedef TinyMatrix<T, TinyRange<B1, E1, S1>::n,\n+      TinyRange<B2, E2, S2>::n, T_DataType> T_RetType;\n+\n+    return T_RetType(T_DataType(m_data.beginLoc(B1, B2)));\n+  }\n+\n+  template<class V1, class T1>\n+  void operator=(const TinyContainer<V1, T1> &rhs)\n+  {\n+    Loop2<0, 0, Nrows, Ncols>::eval(m_data, rhs.unwrap().makeExpr());\n+  }\n+\n+};\n+\n+    \n+int main()\n+{\n+  TinyMatrix<double, 2, 3> a, b(1.0, 2.0, 3.0, 4.0, 5.0, 6.0),\n+    c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6), d(0.01, 0.02, 0.03, 0.04, 0.05, 0.06);\n+  TinyMatrix<double, 1, 2> e, f(17.0, 48.3);\n+\n+  a = b + c + d;\n+\n+  a(TinyRange<0,1>(), TinyRange<0,2,2>());\n+  \n+  a(TinyRange<0,1>(), TinyRange<0,2,2>())\n+    (TinyRange<0,0>(), TinyRange<0,1>());\n+  \n+  e = f + a(TinyRange<0,1>(), TinyRange<0,2,2>())\n+    (TinyRange<0,0>(), TinyRange<0,1>());\n+}\n+"}]}