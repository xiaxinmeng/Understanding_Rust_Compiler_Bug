{"sha": "b7fc9ae0aabaf8c95c524031659b0a17bf597c9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdmYzlhZTBhYWJhZjhjOTVjNTI0MDMxNjU5YjBhMTdiZjU5N2M5ZQ==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2017-05-24T08:49:56Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2017-05-24T08:49:56Z"}, "message": "check_GNU_style.py: print usage if no file specified\n\n2017-05-24  Tom de Vries  <tom@codesourcery.com>\n\n\t* check_GNU_style_lib.py: New file, factored out of ...\n\t* check_GNU_style.py: ... here.  Call main unconditionally.\n\nFrom-SVN: r248403", "tree": {"sha": "e0cc58d00f712c28e7fd9adfd4562e5dd5062154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0cc58d00f712c28e7fd9adfd4562e5dd5062154"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7fc9ae0aabaf8c95c524031659b0a17bf597c9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7fc9ae0aabaf8c95c524031659b0a17bf597c9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7fc9ae0aabaf8c95c524031659b0a17bf597c9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7fc9ae0aabaf8c95c524031659b0a17bf597c9e/comments", "author": null, "committer": null, "parents": [{"sha": "258dfcb78d62909fc80092b4512093c0c85ad83a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/258dfcb78d62909fc80092b4512093c0c85ad83a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/258dfcb78d62909fc80092b4512093c0c85ad83a"}], "stats": {"total": 521, "additions": 275, "deletions": 246}, "files": [{"sha": "ae0c246f4eb1004aea1274ea4b468cabf5df7e7e", "filename": "contrib/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7fc9ae0aabaf8c95c524031659b0a17bf597c9e/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7fc9ae0aabaf8c95c524031659b0a17bf597c9e/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=b7fc9ae0aabaf8c95c524031659b0a17bf597c9e", "patch": "@@ -1,3 +1,8 @@\n+2017-05-24  Tom de Vries  <tom@codesourcery.com>\n+\n+\t* check_GNU_style_lib.py: New file, factored out of ...\n+\t* check_GNU_style.py: ... here.  Call main unconditionally.\n+\n 2017-05-19  Martin Liska  <mliska@suse.cz>\n \n \t* check_GNU_style.py: New file."}, {"sha": "6970ddfe1f4cbb667c5c7d41e1ecbbd1e8f427ab", "filename": "contrib/check_GNU_style.py", "status": "modified", "additions": 3, "deletions": 246, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7fc9ae0aabaf8c95c524031659b0a17bf597c9e/contrib%2Fcheck_GNU_style.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7fc9ae0aabaf8c95c524031659b0a17bf597c9e/contrib%2Fcheck_GNU_style.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fcheck_GNU_style.py?ref=b7fc9ae0aabaf8c95c524031659b0a17bf597c9e", "patch": "@@ -19,198 +19,9 @@\n # You should have received a copy of the GNU General Public License\n # along with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.  */\n-#\n-# The script requires python packages, which can be installed via pip3\n-# like this:\n-# $ pip3 install unidiff termcolor \n \n-import sys\n-import re\n import argparse\n-import unittest\n-\n-try:\n-    from termcolor import colored\n-except ImportError:\n-    print('termcolor module is missing (run: pip3 install termcolor)')\n-    exit(3)\n-\n-try:\n-    from unidiff import PatchSet\n-except ImportError:\n-    print('unidiff module is missing (run: pip3 install unidiff)')\n-    exit(3)\n-\n-from itertools import *\n-\n-ws_char = '\u2588'\n-ts = 8\n-\n-def error_string(s):\n-    return colored(s, 'red', attrs = ['bold'])\n-\n-class CheckError:\n-    def __init__(self, filename, lineno, console_error, error_message,\n-        column = -1):\n-        self.filename = filename\n-        self.lineno = lineno\n-        self.console_error = console_error\n-        self.error_message = error_message\n-        self.column = column\n-\n-    def error_location(self):\n-        return '%s:%d:%d:' % (self.filename, self.lineno,\n-            self.column if self.column != -1 else -1)\n-\n-class LineLengthCheck:\n-    def __init__(self):\n-        self.limit = 80\n-        self.expanded_tab = ' ' * ts\n-\n-    def check(self, filename, lineno, line):\n-        line_expanded = line.replace('\\t', self.expanded_tab)\n-        if len(line_expanded) > self.limit:\n-            return CheckError(filename, lineno,\n-                line_expanded[:self.limit]\n-                    + error_string(line_expanded[self.limit:]),\n-                'lines should not exceed 80 characters', self.limit)\n-\n-        return None\n-\n-class SpacesCheck:\n-    def __init__(self):\n-        self.expanded_tab = ' ' * ts\n-\n-    def check(self, filename, lineno, line):\n-        i = line.find(self.expanded_tab)\n-        if i != -1:\n-            return CheckError(filename, lineno,\n-                line.replace(self.expanded_tab, error_string(ws_char * ts)),\n-                'blocks of 8 spaces should be replaced with tabs', i)\n-\n-class TrailingWhitespaceCheck:\n-    def __init__(self):\n-        self.re = re.compile('(\\s+)$')\n-\n-    def check(self, filename, lineno, line):\n-        m = self.re.search(line)\n-        if m != None:\n-            return CheckError(filename, lineno,\n-                line[:m.start(1)] + error_string(ws_char * len(m.group(1)))\n-                + line[m.end(1):],\n-                'trailing whitespace', m.start(1))\n-\n-class SentenceSeparatorCheck:\n-    def __init__(self):\n-        self.re = re.compile('\\w\\.(\\s|\\s{3,})\\w')\n-\n-    def check(self, filename, lineno, line):\n-        m = self.re.search(line)\n-        if m != None:\n-            return CheckError(filename, lineno,\n-                line[:m.start(1)] + error_string(ws_char * len(m.group(1)))\n-                + line[m.end(1):],\n-                'dot, space, space, new sentence', m.start(1))\n-\n-class SentenceEndOfCommentCheck:\n-    def __init__(self):\n-        self.re = re.compile('\\w\\.(\\s{0,1}|\\s{3,})\\*/')\n-\n-    def check(self, filename, lineno, line):\n-        m = self.re.search(line)\n-        if m != None:\n-            return CheckError(filename, lineno,\n-                line[:m.start(1)] + error_string(ws_char * len(m.group(1)))\n-                + line[m.end(1):],\n-                'dot, space, space, end of comment', m.start(1))\n-\n-class SentenceDotEndCheck:\n-    def __init__(self):\n-        self.re = re.compile('\\w(\\s*\\*/)')\n-\n-    def check(self, filename, lineno, line):\n-        m = self.re.search(line)\n-        if m != None:\n-            return CheckError(filename, lineno,\n-                line[:m.start(1)] + error_string(m.group(1)) + line[m.end(1):],\n-                'dot, space, space, end of comment', m.start(1))\n-\n-class FunctionParenthesisCheck:\n-    # TODO: filter out GTY stuff\n-    def __init__(self):\n-        self.re = re.compile('\\w(\\s{2,})?(\\()')\n-\n-    def check(self, filename, lineno, line):\n-        if '#define' in line:\n-            return None\n-\n-        m = self.re.search(line)\n-        if m != None:\n-            return CheckError(filename, lineno,\n-                line[:m.start(2)] + error_string(m.group(2)) + line[m.end(2):],\n-                'there should be exactly one space between function name ' \\\n-                'and parenthesis', m.start(2))\n-\n-class SquareBracketCheck:\n-    def __init__(self):\n-        self.re = re.compile('\\w\\s+(\\[)')\n-\n-    def check(self, filename, lineno, line):\n-        m = self.re.search(line)\n-        if m != None:\n-            return CheckError(filename, lineno,\n-                line[:m.start(1)] + error_string(m.group(1)) + line[m.end(1):],\n-                'there should be no space before a left square bracket',\n-                m.start(1))\n-\n-class ClosingParenthesisCheck:\n-    def __init__(self):\n-        self.re = re.compile('\\S\\s+(\\))')\n-\n-    def check(self, filename, lineno, line):\n-        m = self.re.search(line)\n-        if m != None:\n-            return CheckError(filename, lineno,\n-                line[:m.start(1)] + error_string(m.group(1)) + line[m.end(1):],\n-                'there should be no space before closing parenthesis',\n-                m.start(1))\n-\n-class BracesOnSeparateLineCheck:\n-    # This will give false positives for C99 compound literals.\n-\n-    def __init__(self):\n-        self.re = re.compile('(\\)|else)\\s*({)')\n-\n-    def check(self, filename, lineno, line):\n-        m = self.re.search(line)\n-        if m != None:\n-            return CheckError(filename, lineno,\n-                line[:m.start(2)] + error_string(m.group(2)) + line[m.end(2):],\n-                'braces should be on a separate line', m.start(2))\n-\n-class TrailinigOperatorCheck:\n-    def __init__(self):\n-        regex = '^\\s.*(([^a-zA-Z_]\\*)|([-%<=&|^?])|([^*]/)|([^:][+]))$'\n-        self.re = re.compile(regex)\n-\n-    def check(self, filename, lineno, line):\n-        m = self.re.search(line)\n-        if m != None:\n-            return CheckError(filename, lineno,\n-                line[:m.start(1)] + error_string(m.group(1)) + line[m.end(1):],\n-                'trailing operator', m.start(1))\n-\n-class LineLengthTest(unittest.TestCase):\n-    def setUp(self):\n-        self.check = LineLengthCheck()\n-\n-    def test_line_length_check_basic(self):\n-        r = self.check.check('foo', 123, self.check.limit * 'a' + ' = 123;')\n-        self.assertIsNotNone(r)\n-        self.assertEqual('foo', r.filename)\n-        self.assertEqual(80, r.column)\n-        self.assertEqual(r.console_error,\n-            self.check.limit * 'a' + error_string(' = 123;'))\n+from check_GNU_style_lib import check_GNU_style_file\n \n def main():\n     parser = argparse.ArgumentParser(description='Check GNU coding style.')\n@@ -219,60 +30,6 @@ def main():\n         help = 'Display format',\n         choices = ['stdio', 'quickfix'])\n     args = parser.parse_args()\n+    check_GNU_style_file(args.file, args.format)\n \n-    checks = [LineLengthCheck(), SpacesCheck(), TrailingWhitespaceCheck(),\n-        SentenceSeparatorCheck(), SentenceEndOfCommentCheck(),\n-        SentenceDotEndCheck(), FunctionParenthesisCheck(),\n-        SquareBracketCheck(), ClosingParenthesisCheck(),\n-        BracesOnSeparateLineCheck(), TrailinigOperatorCheck()]\n-    errors = []\n-\n-    with open(args.file, 'rb') as diff_file:\n-        patch = PatchSet(diff_file, encoding = 'utf-8')\n-\n-    for pfile in patch.added_files + patch.modified_files:\n-        t = pfile.target_file.lstrip('b/')\n-        # Skip testsuite files\n-        if 'testsuite' in t:\n-            continue\n-\n-        for hunk in pfile:\n-            delta = 0\n-            for line in hunk:\n-                if line.is_added and line.target_line_no != None:\n-                    for check in checks:\n-                        e = check.check(t, line.target_line_no, line.value)\n-                        if e != None:\n-                            errors.append(e)\n-\n-    if args.format == 'stdio':\n-        fn = lambda x: x.error_message\n-        i = 1\n-        for (k, errors) in groupby(sorted(errors, key = fn), fn):\n-            errors = list(errors)\n-            print('=== ERROR type #%d: %s (%d error(s)) ==='\n-                % (i, k, len(errors)))\n-            i += 1\n-            for e in errors:\n-                print(e.error_location () + e.console_error)\n-            print()\n-\n-        exit(0 if len(errors) == 0 else 1)\n-    elif args.format == 'quickfix':\n-        f = 'errors.err'\n-        with open(f, 'w+') as qf:\n-            for e in errors:\n-                qf.write('%s%s\\n' % (e.error_location(), e.error_message))\n-        if len(errors) == 0:\n-            exit(0)\n-        else:\n-            print('%d error(s) written to %s file.' % (len(errors), f))\n-            exit(1)\n-    else:\n-        assert False\n-\n-if __name__ == '__main__':\n-    if len(sys.argv) > 1:\n-        main()\n-    else:\n-        unittest.main()\n+main()"}, {"sha": "a1224c11008c95819e4c8ab49df764527d2fa26f", "filename": "contrib/check_GNU_style_lib.py", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7fc9ae0aabaf8c95c524031659b0a17bf597c9e/contrib%2Fcheck_GNU_style_lib.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7fc9ae0aabaf8c95c524031659b0a17bf597c9e/contrib%2Fcheck_GNU_style_lib.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fcheck_GNU_style_lib.py?ref=b7fc9ae0aabaf8c95c524031659b0a17bf597c9e", "patch": "@@ -0,0 +1,267 @@\n+#!/usr/bin/env python3\n+#\n+# Checks some of the GNU style formatting rules in a set of patches.\n+# The script is a rewritten of the same bash script and should eventually\n+# replace the former script.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it under\n+# the terms of the GNU General Public License as published by the Free\n+# Software Foundation; either version 3, or (at your option) any later\n+# version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.  */\n+#\n+# The script requires python packages, which can be installed via pip3\n+# like this:\n+# $ pip3 install unidiff termcolor\n+\n+import sys\n+import re\n+import unittest\n+\n+try:\n+    from termcolor import colored\n+except ImportError:\n+    print('termcolor module is missing (run: pip3 install termcolor)')\n+    exit(3)\n+\n+try:\n+    from unidiff import PatchSet\n+except ImportError:\n+    print('unidiff module is missing (run: pip3 install unidiff)')\n+    exit(3)\n+\n+from itertools import *\n+\n+ws_char = '\u2588'\n+ts = 8\n+\n+def error_string(s):\n+    return colored(s, 'red', attrs = ['bold'])\n+\n+class CheckError:\n+    def __init__(self, filename, lineno, console_error, error_message,\n+        column = -1):\n+        self.filename = filename\n+        self.lineno = lineno\n+        self.console_error = console_error\n+        self.error_message = error_message\n+        self.column = column\n+\n+    def error_location(self):\n+        return '%s:%d:%d:' % (self.filename, self.lineno,\n+            self.column if self.column != -1 else -1)\n+\n+class LineLengthCheck:\n+    def __init__(self):\n+        self.limit = 80\n+        self.expanded_tab = ' ' * ts\n+\n+    def check(self, filename, lineno, line):\n+        line_expanded = line.replace('\\t', self.expanded_tab)\n+        if len(line_expanded) > self.limit:\n+            return CheckError(filename, lineno,\n+                line_expanded[:self.limit]\n+                    + error_string(line_expanded[self.limit:]),\n+                'lines should not exceed 80 characters', self.limit)\n+\n+        return None\n+\n+class SpacesCheck:\n+    def __init__(self):\n+        self.expanded_tab = ' ' * ts\n+\n+    def check(self, filename, lineno, line):\n+        i = line.find(self.expanded_tab)\n+        if i != -1:\n+            return CheckError(filename, lineno,\n+                line.replace(self.expanded_tab, error_string(ws_char * ts)),\n+                'blocks of 8 spaces should be replaced with tabs', i)\n+\n+class TrailingWhitespaceCheck:\n+    def __init__(self):\n+        self.re = re.compile('(\\s+)$')\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(1)] + error_string(ws_char * len(m.group(1)))\n+                + line[m.end(1):],\n+                'trailing whitespace', m.start(1))\n+\n+class SentenceSeparatorCheck:\n+    def __init__(self):\n+        self.re = re.compile('\\w\\.(\\s|\\s{3,})\\w')\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(1)] + error_string(ws_char * len(m.group(1)))\n+                + line[m.end(1):],\n+                'dot, space, space, new sentence', m.start(1))\n+\n+class SentenceEndOfCommentCheck:\n+    def __init__(self):\n+        self.re = re.compile('\\w\\.(\\s{0,1}|\\s{3,})\\*/')\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(1)] + error_string(ws_char * len(m.group(1)))\n+                + line[m.end(1):],\n+                'dot, space, space, end of comment', m.start(1))\n+\n+class SentenceDotEndCheck:\n+    def __init__(self):\n+        self.re = re.compile('\\w(\\s*\\*/)')\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(1)] + error_string(m.group(1)) + line[m.end(1):],\n+                'dot, space, space, end of comment', m.start(1))\n+\n+class FunctionParenthesisCheck:\n+    # TODO: filter out GTY stuff\n+    def __init__(self):\n+        self.re = re.compile('\\w(\\s{2,})?(\\()')\n+\n+    def check(self, filename, lineno, line):\n+        if '#define' in line:\n+            return None\n+\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(2)] + error_string(m.group(2)) + line[m.end(2):],\n+                'there should be exactly one space between function name ' \\\n+                'and parenthesis', m.start(2))\n+\n+class SquareBracketCheck:\n+    def __init__(self):\n+        self.re = re.compile('\\w\\s+(\\[)')\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(1)] + error_string(m.group(1)) + line[m.end(1):],\n+                'there should be no space before a left square bracket',\n+                m.start(1))\n+\n+class ClosingParenthesisCheck:\n+    def __init__(self):\n+        self.re = re.compile('\\S\\s+(\\))')\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(1)] + error_string(m.group(1)) + line[m.end(1):],\n+                'there should be no space before closing parenthesis',\n+                m.start(1))\n+\n+class BracesOnSeparateLineCheck:\n+    # This will give false positives for C99 compound literals.\n+\n+    def __init__(self):\n+        self.re = re.compile('(\\)|else)\\s*({)')\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(2)] + error_string(m.group(2)) + line[m.end(2):],\n+                'braces should be on a separate line', m.start(2))\n+\n+class TrailinigOperatorCheck:\n+    def __init__(self):\n+        regex = '^\\s.*(([^a-zA-Z_]\\*)|([-%<=&|^?])|([^*]/)|([^:][+]))$'\n+        self.re = re.compile(regex)\n+\n+    def check(self, filename, lineno, line):\n+        m = self.re.search(line)\n+        if m != None:\n+            return CheckError(filename, lineno,\n+                line[:m.start(1)] + error_string(m.group(1)) + line[m.end(1):],\n+                'trailing operator', m.start(1))\n+\n+class LineLengthTest(unittest.TestCase):\n+    def setUp(self):\n+        self.check = LineLengthCheck()\n+\n+    def test_line_length_check_basic(self):\n+        r = self.check.check('foo', 123, self.check.limit * 'a' + ' = 123;')\n+        self.assertIsNotNone(r)\n+        self.assertEqual('foo', r.filename)\n+        self.assertEqual(80, r.column)\n+        self.assertEqual(r.console_error,\n+            self.check.limit * 'a' + error_string(' = 123;'))\n+\n+def check_GNU_style_file(file, format):\n+    checks = [LineLengthCheck(), SpacesCheck(), TrailingWhitespaceCheck(),\n+        SentenceSeparatorCheck(), SentenceEndOfCommentCheck(),\n+        SentenceDotEndCheck(), FunctionParenthesisCheck(),\n+        SquareBracketCheck(), ClosingParenthesisCheck(),\n+        BracesOnSeparateLineCheck(), TrailinigOperatorCheck()]\n+    errors = []\n+\n+    with open(file, 'rb') as diff_file:\n+        patch = PatchSet(diff_file, encoding = 'utf-8')\n+\n+    for pfile in patch.added_files + patch.modified_files:\n+        t = pfile.target_file.lstrip('b/')\n+        # Skip testsuite files\n+        if 'testsuite' in t:\n+            continue\n+\n+        for hunk in pfile:\n+            delta = 0\n+            for line in hunk:\n+                if line.is_added and line.target_line_no != None:\n+                    for check in checks:\n+                        e = check.check(t, line.target_line_no, line.value)\n+                        if e != None:\n+                            errors.append(e)\n+\n+    if format == 'stdio':\n+        fn = lambda x: x.error_message\n+        i = 1\n+        for (k, errors) in groupby(sorted(errors, key = fn), fn):\n+            errors = list(errors)\n+            print('=== ERROR type #%d: %s (%d error(s)) ==='\n+                % (i, k, len(errors)))\n+            i += 1\n+            for e in errors:\n+                print(e.error_location () + e.console_error)\n+            print()\n+\n+        exit(0 if len(errors) == 0 else 1)\n+    elif format == 'quickfix':\n+        f = 'errors.err'\n+        with open(f, 'w+') as qf:\n+            for e in errors:\n+                qf.write('%s%s\\n' % (e.error_location(), e.error_message))\n+        if len(errors) == 0:\n+            exit(0)\n+        else:\n+            print('%d error(s) written to %s file.' % (len(errors), f))\n+            exit(1)\n+    else:\n+        assert False\n+\n+if __name__ == '__main__':\n+    unittest.main()"}]}