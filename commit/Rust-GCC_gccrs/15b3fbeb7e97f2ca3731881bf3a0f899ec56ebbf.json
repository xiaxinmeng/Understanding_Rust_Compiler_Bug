{"sha": "15b3fbeb7e97f2ca3731881bf3a0f899ec56ebbf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTViM2ZiZWI3ZTk3ZjJjYTM3MzE4ODFiZjNhMGY4OTllYzU2ZWJiZg==", "commit": {"author": {"name": "Cary Coutant", "email": "ccoutant@google.com", "date": "2009-10-02T20:44:09Z"}, "committer": {"name": "Cary Coutant", "email": "ccoutant@gcc.gnu.org", "date": "2009-10-02T20:44:09Z"}, "message": "Add support for comdat type sections for DWARF v4.\n\n\tAdd support for comdat type sections for DWARF v4.  Merge from dwarf4\n\tbranch.\n\t* dwarf2out.c (DWARF_TYPE_SIGNATURE_SIZE): New constant.\n\t(dw_die_ref): Define vector type.\n\t(enum dw_val_class): Add dw_val_class_data8.\n\t(struct dw_val_struct): Add v.val_data8.\n\t(comdat_type_node_ref): New type.\n\t(struct die_struct): Move die_symbol into a union; add new field\n\tdie_type_node.  Change all uses.\n\t(comdat_type_node): New type.\n\t(skeleton_chain_node): New type.\n\t(DWARF_COMDAT_TYPE_UNIT_HEADER_SIZE): New constant.\n\t(comdat_type_list): New variable.\n\t(dwarf_tag_name): Add DW_TAG_type_unit.\n\t(dwarf_attr_name): Add DW_AT_signature.\n\t(add_AT_data8): New function.\n\t(replace_child): New function.\n\t(move_all_children): New function.\n\t(print_signature): New function.\n\t(print_die): Print signature information; add dw_val_class_data8.\n\t(attr_checksum): Support dw_val_class_data8.\n\t(CHECKSUM_STRING): Redefine for DWARF-4 to include\n\ttrailing NULL byte.\n\t(CHECKSUM_SLEB128, CHECKSUM_ULEB128): New macros.\n\t(checksum_sleb128, checksum_uleb128): New functions.\n\t(checksum_die_context): New function.\n\t(loc_checksum_ordered): New function.\n\t(attr_checksum_ordered): New function.\n\t(struct checksum_attributes): New structure.\n\t(collect_checksum_attributes): New function.\n\t(die_checksum_ordered): New function.\n\t(generate_type_signature): New function.\n\t(same_dw_val_p): Add dw_val_class_data8.\n\t(is_symbol_die): Use new is_declaration_die function.\n\t(is_declaration_die): New function.\n\t(should_move_die_to_comdat): New function.\n\t(clone_die): New function.\n\t(clone_tree): New function.\n\t(clone_as_declaration): New function.\n\t(copy_declaration_context): New function.\n\t(generate_skeleton_ancestor_tree): New function.\n\t(generate_skeleton_bottom_up): New function.\n\t(generate_skeleton): New function.\n\t(remove_child_or_replace_with_skeleton): New function.\n\t(break_out_comdat_types): New function.\n\t(struct decl_table_entry): New type.\n\t(htab_decl_hash): New function.\n\t(htab_decl_eq): New function.\n\t(htab_decl_del): New function.\n\t(copy_ancestor_tree): New function.\n\t(copy_decls_walk): New function.\n\t(copy_decls_for_unworthy_types): New function.\n\t(build_abbrev_table): Don't assert on missing die_symbol when doing\n\tcomdat type sections.\n\t(size_of_die): Use DW_FORM_sig8 for external references; Add\n\tdw_val_class_data8.\n\t(unmark_dies): Don't assert for unmarked dies when doing comdat\n\ttype sections.\n\t(value_format): Support DW_FORM_sig8 and dw_val_class_data8.\n\t(output_signature): New function.\n\t(output_die): Likewise.\n\t(output_compilation_unit_header): Mark output as DWARF version 3\n\teven if generating DWARF 4.\n\t(output_comdat_type_unit): New function.\n\t(output_line_info): Mark output as DWARF version 3 even if generating\n\tDWARF 4.\n\t(dwarf2out_start_source_file): Don't do eliminate_dwarf2_dups with\n\tDWARF-4.\n\t(dwarf2out_end_source_file): Likewise.\n\t(prune_unused_types_walk_attribs): Don't follow references into\n\tcomdat type sections.\n\t(prune_unused_types_mark): When generating type units, do not mark\n\tchildren of non-defining declarations of types; do mark children of\n\ttype entries.\n\t(prune_unused_types): Process comdat type sections.\n\t(htab_ct_hash): New function.\n\t(htab_ct_eq): New function.\n\t(dwarf2out_finish): Move types to comdat sections when using DWARF-4.\n\tAdd a pointer to the line table from type unit entries so\n\tDW_AT_decl_file has meaning.\n\t* varasm.c (default_elf_asm_named_section): Use identifier name as\n\tcomdat key instead of lang hook.\n\nFrom-SVN: r152421", "tree": {"sha": "4468285ea24669cbd92f07d38982098e08547294", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4468285ea24669cbd92f07d38982098e08547294"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15b3fbeb7e97f2ca3731881bf3a0f899ec56ebbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15b3fbeb7e97f2ca3731881bf3a0f899ec56ebbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15b3fbeb7e97f2ca3731881bf3a0f899ec56ebbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15b3fbeb7e97f2ca3731881bf3a0f899ec56ebbf/comments", "author": null, "committer": null, "parents": [{"sha": "e9cfc9b5f4d7eca860c207ee89ad7ca0b24e481e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9cfc9b5f4d7eca860c207ee89ad7ca0b24e481e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9cfc9b5f4d7eca860c207ee89ad7ca0b24e481e"}], "stats": {"total": 2186, "additions": 1902, "deletions": 284}, "files": [{"sha": "7263e90833f20d1eb65ad3a38c46ed843adf9008", "filename": "gcc/ChangeLog", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b3fbeb7e97f2ca3731881bf3a0f899ec56ebbf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b3fbeb7e97f2ca3731881bf3a0f899ec56ebbf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15b3fbeb7e97f2ca3731881bf3a0f899ec56ebbf", "patch": "@@ -1,3 +1,88 @@\n+2009-10-02  Cary Coutant  <ccoutant@google.com>\n+\n+\tAdd support for comdat type sections for DWARF v4.  Merge from dwarf4\n+\tbranch.\n+\t* dwarf2out.c (DWARF_TYPE_SIGNATURE_SIZE): New constant.\n+\t(dw_die_ref): Define vector type.\n+\t(enum dw_val_class): Add dw_val_class_data8.\n+\t(struct dw_val_struct): Add v.val_data8.\n+\t(comdat_type_node_ref): New type.\n+\t(struct die_struct): Move die_symbol into a union; add new field\n+\tdie_type_node.  Change all uses.\n+\t(comdat_type_node): New type.\n+\t(skeleton_chain_node): New type.\n+\t(DWARF_COMDAT_TYPE_UNIT_HEADER_SIZE): New constant.\n+\t(comdat_type_list): New variable.\n+\t(dwarf_tag_name): Add DW_TAG_type_unit.\n+\t(dwarf_attr_name): Add DW_AT_signature.\n+\t(add_AT_data8): New function.\n+\t(replace_child): New function.\n+\t(move_all_children): New function.\n+\t(print_signature): New function.\n+\t(print_die): Print signature information; add dw_val_class_data8.\n+\t(attr_checksum): Support dw_val_class_data8.\n+\t(CHECKSUM_STRING): Redefine for DWARF-4 to include\n+\ttrailing NULL byte.\n+\t(CHECKSUM_SLEB128, CHECKSUM_ULEB128): New macros.\n+\t(checksum_sleb128, checksum_uleb128): New functions.\n+\t(checksum_die_context): New function.\n+\t(loc_checksum_ordered): New function.\n+\t(attr_checksum_ordered): New function.\n+\t(struct checksum_attributes): New structure.\n+\t(collect_checksum_attributes): New function.\n+\t(die_checksum_ordered): New function.\n+\t(generate_type_signature): New function.\n+\t(same_dw_val_p): Add dw_val_class_data8.\n+\t(is_symbol_die): Use new is_declaration_die function.\n+\t(is_declaration_die): New function.\n+\t(should_move_die_to_comdat): New function.\n+\t(clone_die): New function.\n+\t(clone_tree): New function.\n+\t(clone_as_declaration): New function.\n+\t(copy_declaration_context): New function.\n+\t(generate_skeleton_ancestor_tree): New function.\n+\t(generate_skeleton_bottom_up): New function.\n+\t(generate_skeleton): New function.\n+\t(remove_child_or_replace_with_skeleton): New function.\n+\t(break_out_comdat_types): New function.\n+\t(struct decl_table_entry): New type.\n+\t(htab_decl_hash): New function.\n+\t(htab_decl_eq): New function.\n+\t(htab_decl_del): New function.\n+\t(copy_ancestor_tree): New function.\n+\t(copy_decls_walk): New function.\n+\t(copy_decls_for_unworthy_types): New function.\n+\t(build_abbrev_table): Don't assert on missing die_symbol when doing\n+\tcomdat type sections.\n+\t(size_of_die): Use DW_FORM_sig8 for external references; Add\n+\tdw_val_class_data8.\n+\t(unmark_dies): Don't assert for unmarked dies when doing comdat\n+\ttype sections.\n+\t(value_format): Support DW_FORM_sig8 and dw_val_class_data8.\n+\t(output_signature): New function.\n+\t(output_die): Likewise.\n+\t(output_compilation_unit_header): Mark output as DWARF version 3\n+\teven if generating DWARF 4.\n+\t(output_comdat_type_unit): New function.\n+\t(output_line_info): Mark output as DWARF version 3 even if generating\n+\tDWARF 4.\n+\t(dwarf2out_start_source_file): Don't do eliminate_dwarf2_dups with\n+\tDWARF-4.\n+\t(dwarf2out_end_source_file): Likewise.\n+\t(prune_unused_types_walk_attribs): Don't follow references into\n+\tcomdat type sections.\n+\t(prune_unused_types_mark): When generating type units, do not mark\n+\tchildren of non-defining declarations of types; do mark children of\n+\ttype entries.\n+\t(prune_unused_types): Process comdat type sections.\n+\t(htab_ct_hash): New function.\n+\t(htab_ct_eq): New function.\n+\t(dwarf2out_finish): Move types to comdat sections when using DWARF-4.\n+\tAdd a pointer to the line table from type unit entries so\n+\tDW_AT_decl_file has meaning.\n+\t* varasm.c (default_elf_asm_named_section): Use identifier name as\n+\tcomdat key instead of lang hook.\n+\n 2009-10-02  Neil Vachharajani  <nvachhar@google.com>\n \n \t* gcov-io.c (gcov_open): Open files read-only when MODE < 0"}, {"sha": "26e85940c23deed0d30cdd89d00c737a02a23ba4", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1810, "deletions": 282, "changes": 2092, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b3fbeb7e97f2ca3731881bf3a0f899ec56ebbf/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b3fbeb7e97f2ca3731881bf3a0f899ec56ebbf/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=15b3fbeb7e97f2ca3731881bf3a0f899ec56ebbf", "patch": "@@ -348,6 +348,12 @@ dw_fde_node;\n #define DWARF_OFFSET_SIZE 4\n #endif\n \n+/* The size in bytes of a DWARF 4 type signature.  */\n+\n+#ifndef DWARF_TYPE_SIGNATURE_SIZE\n+#define DWARF_TYPE_SIGNATURE_SIZE 8\n+#endif\n+\n /* According to the (draft) DWARF 3 specification, the initial length\n    should either be 4 or 12 bytes.  When it's 12 bytes, the first 4\n    bytes are 0xffffffff, followed by the length stored in the next 8\n@@ -4155,6 +4161,9 @@ DEF_VEC_ALLOC_O(deferred_locations,gc);\n \n static GTY(()) VEC(deferred_locations, gc) *deferred_locations_list;\n \n+DEF_VEC_P(dw_die_ref);\n+DEF_VEC_ALLOC_P(dw_die_ref,heap);\n+\n /* Each DIE may have a series of attribute/value pairs.  Values\n    can take on several forms.  The forms that are used in this\n    implementation are listed below.  */\n@@ -4177,7 +4186,8 @@ enum dw_val_class\n   dw_val_class_lineptr,\n   dw_val_class_str,\n   dw_val_class_macptr,\n-  dw_val_class_file\n+  dw_val_class_file,\n+  dw_val_class_data8\n };\n \n /* Describe a floating point constant value, or a vector constant value.  */\n@@ -4214,6 +4224,7 @@ typedef struct GTY(()) dw_val_struct {\n       char * GTY ((tag (\"dw_val_class_lbl_id\"))) val_lbl_id;\n       unsigned char GTY ((tag (\"dw_val_class_flag\"))) val_flag;\n       struct dwarf_file_data * GTY ((tag (\"dw_val_class_file\"))) val_file;\n+      unsigned char GTY ((tag (\"dw_val_class_data8\"))) val_data8[8];\n     }\n   GTY ((desc (\"%1.val_class\"))) v;\n }\n@@ -5464,6 +5475,7 @@ typedef struct dw_separate_line_info_struct *dw_separate_line_info_ref;\n typedef struct pubname_struct *pubname_ref;\n typedef struct dw_ranges_struct *dw_ranges_ref;\n typedef struct dw_ranges_by_label_struct *dw_ranges_by_label_ref;\n+typedef struct comdat_type_struct *comdat_type_node_ref;\n \n /* Each entry in the line_info_table maintains the file and\n    line number associated with the label generated for that\n@@ -5504,7 +5516,12 @@ DEF_VEC_ALLOC_O(dw_attr_node,gc);\n \n typedef struct GTY((chain_circular (\"%h.die_sib\"))) die_struct {\n   enum dwarf_tag die_tag;\n-  char *die_symbol;\n+  union die_symbol_or_type_node\n+    {\n+      char * GTY ((tag (\"0\"))) die_symbol;\n+      comdat_type_node_ref GTY ((tag (\"1\"))) die_type_node;\n+    }\n+  GTY ((desc (\"dwarf_version >= 4\"))) die_id;\n   VEC(dw_attr_node,gc) * die_attr;\n   dw_die_ref die_parent;\n   dw_die_ref die_child;\n@@ -5550,6 +5567,16 @@ struct GTY(()) dw_ranges_by_label_struct {\n   const char *end;\n };\n \n+/* The comdat type node structure.  */\n+typedef struct GTY(()) comdat_type_struct\n+{\n+  dw_die_ref root_die;\n+  dw_die_ref type_die;\n+  char signature[DWARF_TYPE_SIGNATURE_SIZE];\n+  struct comdat_type_struct *next;\n+}\n+comdat_type_node;\n+\n /* The limbo die list structure.  */\n typedef struct GTY(()) limbo_die_struct {\n   dw_die_ref die;\n@@ -5558,6 +5585,14 @@ typedef struct GTY(()) limbo_die_struct {\n }\n limbo_die_node;\n \n+typedef struct GTY(()) skeleton_chain_struct\n+{\n+  dw_die_ref old_die;\n+  dw_die_ref new_die;\n+  struct skeleton_chain_struct *parent;\n+}\n+skeleton_chain_node;\n+\n /* How to start an assembler comment.  */\n #ifndef ASM_COMMENT_START\n #define ASM_COMMENT_START \";#\"\n@@ -5591,6 +5626,11 @@ limbo_die_node;\n #define DWARF_COMPILE_UNIT_HEADER_SIZE \\\n   (DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE + 3)\n \n+/* Fixed size portion of the DWARF comdat type unit header.  */\n+#define DWARF_COMDAT_TYPE_UNIT_HEADER_SIZE \\\n+  (DWARF_COMPILE_UNIT_HEADER_SIZE + DWARF_TYPE_SIGNATURE_SIZE \\\n+   + DWARF_OFFSET_SIZE)\n+\n /* Fixed size portion of public names info.  */\n #define DWARF_PUBNAMES_HEADER_SIZE (2 * DWARF_OFFSET_SIZE + 2)\n \n@@ -5641,6 +5681,9 @@ static unsigned long next_die_offset;\n /* Record the root of the DIE's built for the current compilation unit.  */\n static GTY(()) dw_die_ref comp_unit_die;\n \n+/* A list of type DIEs that have been separated into comdat sections.  */\n+static GTY(()) comdat_type_node *comdat_type_list;\n+\n /* A list of DIEs with a NULL parent waiting to be relocated.  */\n static GTY(()) limbo_die_node *limbo_die_list;\n \n@@ -5832,6 +5875,7 @@ static void add_AT_double (dw_die_ref, enum dwarf_attribute,\n \t\t\t   HOST_WIDE_INT, unsigned HOST_WIDE_INT);\n static inline void add_AT_vec (dw_die_ref, enum dwarf_attribute, unsigned int,\n \t\t\t       unsigned int, unsigned char *);\n+static void add_AT_data8 (dw_die_ref, enum dwarf_attribute, unsigned char *);\n static hashval_t debug_str_do_hash (const void *);\n static int debug_str_eq (const void *, const void *);\n static void add_AT_string (dw_die_ref, enum dwarf_attribute, const char *);\n@@ -5894,6 +5938,16 @@ static dw_die_ref pop_compile_unit (dw_die_ref);\n static void loc_checksum (dw_loc_descr_ref, struct md5_ctx *);\n static void attr_checksum (dw_attr_ref, struct md5_ctx *, int *);\n static void die_checksum (dw_die_ref, struct md5_ctx *, int *);\n+static void checksum_sleb128 (HOST_WIDE_INT, struct md5_ctx *);\n+static void checksum_uleb128 (unsigned HOST_WIDE_INT, struct md5_ctx *);\n+static void loc_checksum_ordered (dw_loc_descr_ref, struct md5_ctx *);\n+static void attr_checksum_ordered (enum dwarf_tag, dw_attr_ref,\n+\t\t\t\t   struct md5_ctx *, int *);\n+struct checksum_attributes;\n+static void collect_checksum_attributes (struct checksum_attributes *, dw_die_ref);\n+static void die_checksum_ordered (dw_die_ref, struct md5_ctx *, int *);\n+static void checksum_die_context (dw_die_ref, struct md5_ctx *);\n+static void generate_type_signature (dw_die_ref, comdat_type_node *);\n static int same_loc_p (dw_loc_descr_ref, dw_loc_descr_ref, int *);\n static int same_dw_val_p (const dw_val_node *, const dw_val_node *, int *);\n static int same_attr_p (dw_attr_ref, dw_attr_ref, int *);\n@@ -5905,6 +5959,22 @@ static int is_comdat_die (dw_die_ref);\n static int is_symbol_die (dw_die_ref);\n static void assign_symbol_names (dw_die_ref);\n static void break_out_includes (dw_die_ref);\n+static int is_declaration_die (dw_die_ref);\n+static int should_move_die_to_comdat (dw_die_ref);\n+static dw_die_ref clone_as_declaration (dw_die_ref);\n+static dw_die_ref clone_die (dw_die_ref);\n+static dw_die_ref clone_tree (dw_die_ref);\n+static void copy_declaration_context (dw_die_ref, dw_die_ref);\n+static void generate_skeleton_ancestor_tree (skeleton_chain_node *);\n+static void generate_skeleton_bottom_up (skeleton_chain_node *);\n+static dw_die_ref generate_skeleton (dw_die_ref);\n+static dw_die_ref remove_child_or_replace_with_skeleton (dw_die_ref,\n+                                                         dw_die_ref);\n+static void break_out_comdat_types (dw_die_ref);\n+static dw_die_ref copy_ancestor_tree (dw_die_ref, dw_die_ref, htab_t);\n+static void copy_decls_walk (dw_die_ref, dw_die_ref, htab_t);\n+static void copy_decls_for_unworthy_types (dw_die_ref);\n+\n static hashval_t htab_cu_hash (const void *);\n static int htab_cu_eq (const void *, const void *);\n static void htab_cu_del (void *);\n@@ -5928,6 +5998,7 @@ static void output_die_symbol (dw_die_ref);\n static void output_die (dw_die_ref);\n static void output_compilation_unit_header (void);\n static void output_comp_unit (dw_die_ref, int);\n+static void output_comdat_type_unit (comdat_type_node *);\n static const char *dwarf2_name (tree, int);\n static void add_pubname (tree, dw_die_ref);\n static void add_pubname_string (const char *, dw_die_ref);\n@@ -6352,6 +6423,8 @@ dwarf_tag_name (unsigned int tag)\n       return \"DW_TAG_condition\";\n     case DW_TAG_shared_type:\n       return \"DW_TAG_shared_type\";\n+    case DW_TAG_type_unit:\n+      return \"DW_TAG_type_unit\";\n     case DW_TAG_GNU_template_parameter_pack:\n       return \"DW_TAG_GNU_template_parameter_pack\";\n     case DW_TAG_GNU_formal_parameter_pack:\n@@ -6534,6 +6607,9 @@ dwarf_attr_name (unsigned int attr)\n     case DW_AT_call_line:\n       return \"DW_AT_call_line\";\n \n+    case DW_AT_signature:\n+      return \"DW_AT_signature\";\n+\n     case DW_AT_MIPS_fde:\n       return \"DW_AT_MIPS_fde\";\n     case DW_AT_MIPS_loop_begin:\n@@ -6794,6 +6870,20 @@ add_AT_vec (dw_die_ref die, enum dwarf_attribute attr_kind,\n   add_dwarf_attr (die, &attr);\n }\n \n+/* Add an 8-byte data attribute value to a DIE.  */\n+\n+static inline void\n+add_AT_data8 (dw_die_ref die, enum dwarf_attribute attr_kind,\n+              unsigned char data8[8])\n+{\n+  dw_attr_node attr;\n+\n+  attr.dw_attr = attr_kind;\n+  attr.dw_attr_val.val_class = dw_val_class_data8;\n+  memcpy (attr.dw_attr_val.v.val_data8, data8, 8);\n+  add_dwarf_attr (die, &attr);\n+}\n+\n /* Hash and equality functions for debug_str_hash.  */\n \n static hashval_t\n@@ -7347,6 +7437,43 @@ remove_child_with_prev (dw_die_ref child, dw_die_ref prev)\n     child->die_parent->die_child = prev;\n }\n \n+/* Replace OLD_CHILD with NEW_CHILD.  PREV must have the property that\n+   PREV->DIE_SIB == OLD_CHILD.  Does not alter OLD_CHILD.  */\n+\n+static void\n+replace_child (dw_die_ref old_child, dw_die_ref new_child, dw_die_ref prev)\n+{\n+  dw_die_ref parent = old_child->die_parent;\n+\n+  gcc_assert (parent == prev->die_parent);\n+  gcc_assert (prev->die_sib == old_child);\n+\n+  new_child->die_parent = parent;\n+  if (prev == old_child)\n+    {\n+      gcc_assert (parent->die_child == old_child);\n+      new_child->die_sib = new_child;\n+    }\n+  else\n+    {\n+      prev->die_sib = new_child;\n+      new_child->die_sib = old_child->die_sib;\n+    }\n+  if (old_child->die_parent->die_child == old_child)\n+    old_child->die_parent->die_child = new_child;\n+}\n+\n+/* Move all children from OLD_PARENT to NEW_PARENT.  */\n+\n+static void\n+move_all_children (dw_die_ref old_parent, dw_die_ref new_parent)\n+{\n+  dw_die_ref c;\n+  new_parent->die_child = old_parent->die_child;\n+  old_parent->die_child = NULL;\n+  FOR_EACH_CHILD (new_parent, c, c->die_parent = new_parent);\n+}\n+\n /* Remove child DIE whose die_tag is TAG.  Do nothing if no child\n    matches TAG.  */\n \n@@ -7589,6 +7716,17 @@ print_spaces (FILE *outfile)\n   fprintf (outfile, \"%*s\", print_indent, \"\");\n }\n \n+/* Print a type signature in hex.  */\n+\n+static inline void\n+print_signature (FILE *outfile, char *sig)\n+{\n+  int i;\n+\n+  for (i = 0; i < DWARF_TYPE_SIGNATURE_SIZE; i++)\n+    fprintf (outfile, \"%02x\", sig[i] & 0xff);\n+}\n+\n /* Print the information associated with a given DIE, and its children.\n    This routine is a debugging aid only.  */\n \n@@ -7605,6 +7743,13 @@ print_die (dw_die_ref die, FILE *outfile)\n   print_spaces (outfile);\n   fprintf (outfile, \"  abbrev id: %lu\", die->die_abbrev);\n   fprintf (outfile, \" offset: %ld\\n\", die->die_offset);\n+  if (dwarf_version >= 4 && die->die_id.die_type_node)\n+    {\n+      print_spaces (outfile);\n+      fprintf (outfile, \"  signature: \");\n+      print_signature (outfile, die->die_id.die_type_node->signature);\n+      fprintf (outfile, \"\\n\");\n+    }\n \n   for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n     {\n@@ -7650,8 +7795,15 @@ print_die (dw_die_ref die, FILE *outfile)\n \tcase dw_val_class_die_ref:\n \t  if (AT_ref (a) != NULL)\n \t    {\n-\t      if (AT_ref (a)->die_symbol)\n-\t\tfprintf (outfile, \"die -> label: %s\", AT_ref (a)->die_symbol);\n+\t      if (dwarf_version >= 4 && AT_ref (a)->die_id.die_type_node)\n+\t        {\n+\t\t  fprintf (outfile, \"die -> signature: \");\n+\t\t  print_signature (outfile,\n+\t\t  \t\t   AT_ref (a)->die_id.die_type_node->signature);\n+                }\n+\t      else if (dwarf_version < 4 && AT_ref (a)->die_id.die_symbol)\n+\t\tfprintf (outfile, \"die -> label: %s\",\n+\t\t         AT_ref (a)->die_id.die_symbol);\n \t      else\n \t\tfprintf (outfile, \"die -> %ld\", AT_ref (a)->die_offset);\n \t    }\n@@ -7673,6 +7825,14 @@ print_die (dw_die_ref die, FILE *outfile)\n \t  fprintf (outfile, \"\\\"%s\\\" (%d)\", AT_file (a)->filename,\n \t\t   AT_file (a)->emitted_number);\n \t  break;\n+\tcase dw_val_class_data8:\n+\t  {\n+\t    int i;\n+\n+            for (i = 0; i < 8; i++)\n+              fprintf (outfile, \"%02x\", a->dw_attr_val.v.val_data8[i]);\n+\t    break;\n+          }\n \tdefault:\n \t  break;\n \t}\n@@ -7837,6 +7997,10 @@ attr_checksum (dw_attr_ref at, struct md5_ctx *ctx, int *mark)\n       CHECKSUM_STRING (AT_file (at)->filename);\n       break;\n \n+    case dw_val_class_data8:\n+      CHECKSUM (at->dw_attr_val.v.val_data8);\n+      break;\n+\n     default:\n       break;\n     }\n@@ -7870,143 +8034,766 @@ die_checksum (dw_die_ref die, struct md5_ctx *ctx, int *mark)\n #undef CHECKSUM\n #undef CHECKSUM_STRING\n \n-/* Do the location expressions look same?  */\n-static inline int\n-same_loc_p (dw_loc_descr_ref loc1, dw_loc_descr_ref loc2, int *mark)\n+/* For DWARF-4 types, include the trailing NULL when checksumming strings.  */\n+#define CHECKSUM(FOO) md5_process_bytes (&(FOO), sizeof (FOO), ctx)\n+#define CHECKSUM_STRING(FOO) md5_process_bytes ((FOO), strlen (FOO) + 1, ctx)\n+#define CHECKSUM_SLEB128(FOO) checksum_sleb128 ((FOO), ctx)\n+#define CHECKSUM_ULEB128(FOO) checksum_uleb128 ((FOO), ctx)\n+#define CHECKSUM_ATTR(FOO) \\\n+  if (FOO) attr_checksum_ordered (die->die_tag, (FOO), ctx, mark)\n+\n+/* Calculate the checksum of a number in signed LEB128 format.  */\n+\n+static void\n+checksum_sleb128 (HOST_WIDE_INT value, struct md5_ctx *ctx)\n {\n-  return loc1->dw_loc_opc == loc2->dw_loc_opc\n-\t && same_dw_val_p (&loc1->dw_loc_oprnd1, &loc2->dw_loc_oprnd1, mark)\n-\t && same_dw_val_p (&loc1->dw_loc_oprnd2, &loc2->dw_loc_oprnd2, mark);\n+  unsigned char byte;\n+  bool more;\n+\n+  while (1)\n+    {\n+      byte = (value & 0x7f);\n+      value >>= 7;\n+      more = !((value == 0 && (byte & 0x40) == 0)\n+\t\t|| (value == -1 && (byte & 0x40) != 0));\n+      if (more)\n+\tbyte |= 0x80;\n+      CHECKSUM (byte);\n+      if (!more)\n+\tbreak;\n+    }\n }\n \n-/* Do the values look the same?  */\n-static int\n-same_dw_val_p (const dw_val_node *v1, const dw_val_node *v2, int *mark)\n+/* Calculate the checksum of a number in unsigned LEB128 format.  */\n+\n+static void\n+checksum_uleb128 (unsigned HOST_WIDE_INT value, struct md5_ctx *ctx)\n {\n-  dw_loc_descr_ref loc1, loc2;\n-  rtx r1, r2;\n+  while (1)\n+    {\n+      unsigned char byte = (value & 0x7f);\n+      value >>= 7;\n+      if (value != 0)\n+\t/* More bytes to follow.  */\n+\tbyte |= 0x80;\n+      CHECKSUM (byte);\n+      if (value == 0)\n+\tbreak;\n+    }\n+}\n \n-  if (v1->val_class != v2->val_class)\n-    return 0;\n+/* Checksum the context of the DIE.  This adds the names of any\n+   surrounding namespaces or structures to the checksum.  */\n \n-  switch (v1->val_class)\n+static void\n+checksum_die_context (dw_die_ref die, struct md5_ctx *ctx)\n+{\n+  const char *name;\n+  dw_die_ref spec;\n+  int tag = die->die_tag;\n+\n+  if (tag != DW_TAG_namespace\n+      && tag != DW_TAG_structure_type\n+      && tag != DW_TAG_class_type)\n+    return;\n+\n+  name = get_AT_string (die, DW_AT_name);\n+\n+  spec = get_AT_ref (die, DW_AT_specification);\n+  if (spec != NULL)\n+    die = spec;\n+\n+  if (die->die_parent != NULL)\n+    checksum_die_context (die->die_parent, ctx);\n+\n+  CHECKSUM_ULEB128 ('C');\n+  CHECKSUM_ULEB128 (tag);\n+  if (name != NULL)\n+    CHECKSUM_STRING (name);\n+}\n+\n+/* Calculate the checksum of a location expression.  */\n+\n+static inline void\n+loc_checksum_ordered (dw_loc_descr_ref loc, struct md5_ctx *ctx)\n+{\n+  /* Special case for lone DW_OP_plus_uconst: checksum as if the location\n+     were emitted as a DW_FORM_sdata instead of a location expression.  */\n+  if (loc->dw_loc_opc == DW_OP_plus_uconst && loc->dw_loc_next == NULL)\n+    {\n+      CHECKSUM_ULEB128 (DW_FORM_sdata);\n+      CHECKSUM_SLEB128 ((HOST_WIDE_INT) loc->dw_loc_oprnd1.v.val_unsigned);\n+      return;\n+    }\n+\n+  /* Otherwise, just checksum the raw location expression.  */\n+  while (loc != NULL)\n+    {\n+      CHECKSUM_ULEB128 (loc->dw_loc_opc);\n+      CHECKSUM (loc->dw_loc_oprnd1);\n+      CHECKSUM (loc->dw_loc_oprnd2);\n+      loc = loc->dw_loc_next;\n+    }\n+}\n+\n+/* Calculate the checksum of an attribute.  */\n+\n+static void\n+attr_checksum_ordered (enum dwarf_tag tag, dw_attr_ref at,\n+\t\t       struct md5_ctx *ctx, int *mark)\n+{\n+  dw_loc_descr_ref loc;\n+  rtx r;\n+\n+  if (AT_class (at) == dw_val_class_die_ref)\n+    {\n+      dw_die_ref target_die = AT_ref (at);\n+\n+      /* For pointer and reference types, we checksum only the (qualified)\n+\t name of the target type (if there is a name).  For friend entries,\n+\t we checksum only the (qualified) name of the target type or function.\n+\t This allows the checksum to remain the same whether the target type\n+\t is complete or not.  */\n+      if ((at->dw_attr == DW_AT_type\n+\t   && (tag == DW_TAG_pointer_type\n+\t       || tag == DW_TAG_reference_type\n+\t       || tag == DW_TAG_ptr_to_member_type))\n+\t  || (at->dw_attr == DW_AT_friend\n+\t      && tag == DW_TAG_friend))\n+\t{\n+\t  dw_attr_ref name_attr = get_AT (target_die, DW_AT_name);\n+\n+\t  if (name_attr != NULL)\n+\t    {\n+\t      dw_die_ref decl = get_AT_ref (target_die, DW_AT_specification);\n+\n+\t      if (decl == NULL)\n+\t\tdecl = target_die;\n+\t      CHECKSUM_ULEB128 ('N');\n+\t      CHECKSUM_ULEB128 (at->dw_attr);\n+\t      if (decl->die_parent != NULL)\n+\t\tchecksum_die_context (decl->die_parent, ctx);\n+\t      CHECKSUM_ULEB128 ('E');\n+\t      CHECKSUM_STRING (AT_string (name_attr));\n+\t      return;\n+\t    }\n+\t}\n+\n+      /* For all other references to another DIE, we check to see if the\n+         target DIE has already been visited.  If it has, we emit a\n+         backward reference; if not, we descend recursively.  */\n+      if (target_die->die_mark > 0)\n+        {\n+\t  CHECKSUM_ULEB128 ('R');\n+\t  CHECKSUM_ULEB128 (at->dw_attr);\n+\t  CHECKSUM_ULEB128 (target_die->die_mark);\n+        }\n+      else\n+        {\n+\t  dw_die_ref decl = get_AT_ref (target_die, DW_AT_specification);\n+\n+\t  if (decl == NULL)\n+\t    decl = target_die;\n+\t  target_die->die_mark = ++(*mark);\n+\t  CHECKSUM_ULEB128 ('T');\n+\t  CHECKSUM_ULEB128 (at->dw_attr);\n+\t  if (decl->die_parent != NULL)\n+\t    checksum_die_context (decl->die_parent, ctx);\n+\t  die_checksum_ordered (target_die, ctx, mark);\n+        }\n+      return;\n+    }\n+\n+  CHECKSUM_ULEB128 ('A');\n+  CHECKSUM_ULEB128 (at->dw_attr);\n+\n+  switch (AT_class (at))\n     {\n     case dw_val_class_const:\n-      return v1->v.val_int == v2->v.val_int;\n+      CHECKSUM_ULEB128 (DW_FORM_sdata);\n+      CHECKSUM_SLEB128 (at->dw_attr_val.v.val_int);\n+      break;\n+\n     case dw_val_class_unsigned_const:\n-      return v1->v.val_unsigned == v2->v.val_unsigned;\n+      CHECKSUM_ULEB128 (DW_FORM_sdata);\n+      CHECKSUM_SLEB128 ((int) at->dw_attr_val.v.val_unsigned);\n+      break;\n+\n     case dw_val_class_const_double:\n-      return v1->v.val_double.high == v2->v.val_double.high\n-\t     && v1->v.val_double.low == v2->v.val_double.low;\n+      CHECKSUM_ULEB128 (DW_FORM_block);\n+      CHECKSUM_ULEB128 (sizeof (at->dw_attr_val.v.val_double));\n+      CHECKSUM (at->dw_attr_val.v.val_double);\n+      break;\n+\n     case dw_val_class_vec:\n-      if (v1->v.val_vec.length != v2->v.val_vec.length\n-\t  || v1->v.val_vec.elt_size != v2->v.val_vec.elt_size)\n-\treturn 0;\n-      if (memcmp (v1->v.val_vec.array, v2->v.val_vec.array,\n-\t\t  v1->v.val_vec.length * v1->v.val_vec.elt_size))\n-\treturn 0;\n-      return 1;\n+      CHECKSUM_ULEB128 (DW_FORM_block);\n+      CHECKSUM_ULEB128 (sizeof (at->dw_attr_val.v.val_vec));\n+      CHECKSUM (at->dw_attr_val.v.val_vec);\n+      break;\n+\n     case dw_val_class_flag:\n-      return v1->v.val_flag == v2->v.val_flag;\n+      CHECKSUM_ULEB128 (DW_FORM_flag);\n+      CHECKSUM_ULEB128 (at->dw_attr_val.v.val_flag ? 1 : 0);\n+      break;\n+\n     case dw_val_class_str:\n-      return !strcmp(v1->v.val_str->str, v2->v.val_str->str);\n+      CHECKSUM_ULEB128 (DW_FORM_string);\n+      CHECKSUM_STRING (AT_string (at));\n+      break;\n \n     case dw_val_class_addr:\n-      r1 = v1->v.val_addr;\n-      r2 = v2->v.val_addr;\n-      if (GET_CODE (r1) != GET_CODE (r2))\n-\treturn 0;\n-      return !rtx_equal_p (r1, r2);\n+      r = AT_addr (at);\n+      gcc_assert (GET_CODE (r) == SYMBOL_REF);\n+      CHECKSUM_ULEB128 (DW_FORM_string);\n+      CHECKSUM_STRING (XSTR (r, 0));\n+      break;\n \n     case dw_val_class_offset:\n-      return v1->v.val_offset == v2->v.val_offset;\n+      CHECKSUM_ULEB128 (DW_FORM_sdata);\n+      CHECKSUM_ULEB128 (at->dw_attr_val.v.val_offset);\n+      break;\n \n     case dw_val_class_loc:\n-      for (loc1 = v1->v.val_loc, loc2 = v2->v.val_loc;\n-\t   loc1 && loc2;\n-\t   loc1 = loc1->dw_loc_next, loc2 = loc2->dw_loc_next)\n-\tif (!same_loc_p (loc1, loc2, mark))\n-\t  return 0;\n-      return !loc1 && !loc2;\n-\n-    case dw_val_class_die_ref:\n-      return same_die_p (v1->v.val_die_ref.die, v2->v.val_die_ref.die, mark);\n+      for (loc = AT_loc (at); loc; loc = loc->dw_loc_next)\n+\tloc_checksum_ordered (loc, ctx);\n+      break;\n \n     case dw_val_class_fde_ref:\n     case dw_val_class_lbl_id:\n     case dw_val_class_lineptr:\n     case dw_val_class_macptr:\n-      return 1;\n+      break;\n \n     case dw_val_class_file:\n-      return v1->v.val_file == v2->v.val_file;\n+      CHECKSUM_ULEB128 (DW_FORM_string);\n+      CHECKSUM_STRING (AT_file (at)->filename);\n+      break;\n+\n+    case dw_val_class_data8:\n+      CHECKSUM (at->dw_attr_val.v.val_data8);\n+      break;\n \n     default:\n-      return 1;\n+      break;\n     }\n }\n \n-/* Do the attributes look the same?  */\n-\n-static int\n-same_attr_p (dw_attr_ref at1, dw_attr_ref at2, int *mark)\n-{\n-  if (at1->dw_attr != at2->dw_attr)\n-    return 0;\n-\n-  /* We don't care that this was compiled with a different compiler\n-     snapshot; if the output is the same, that's what matters. */\n-  if (at1->dw_attr == DW_AT_producer)\n-    return 1;\n-\n-  return same_dw_val_p (&at1->dw_attr_val, &at2->dw_attr_val, mark);\n-}\n+struct checksum_attributes\n+{\n+  dw_attr_ref at_name;\n+  dw_attr_ref at_type;\n+  dw_attr_ref at_friend;\n+  dw_attr_ref at_accessibility;\n+  dw_attr_ref at_address_class;\n+  dw_attr_ref at_allocated;\n+  dw_attr_ref at_artificial;\n+  dw_attr_ref at_associated;\n+  dw_attr_ref at_binary_scale;\n+  dw_attr_ref at_bit_offset;\n+  dw_attr_ref at_bit_size;\n+  dw_attr_ref at_bit_stride;\n+  dw_attr_ref at_byte_size;\n+  dw_attr_ref at_byte_stride;\n+  dw_attr_ref at_const_value;\n+  dw_attr_ref at_containing_type;\n+  dw_attr_ref at_count;\n+  dw_attr_ref at_data_location;\n+  dw_attr_ref at_data_member_location;\n+  dw_attr_ref at_decimal_scale;\n+  dw_attr_ref at_decimal_sign;\n+  dw_attr_ref at_default_value;\n+  dw_attr_ref at_digit_count;\n+  dw_attr_ref at_discr;\n+  dw_attr_ref at_discr_list;\n+  dw_attr_ref at_discr_value;\n+  dw_attr_ref at_encoding;\n+  dw_attr_ref at_endianity;\n+  dw_attr_ref at_explicit;\n+  dw_attr_ref at_is_optional;\n+  dw_attr_ref at_location;\n+  dw_attr_ref at_lower_bound;\n+  dw_attr_ref at_mutable;\n+  dw_attr_ref at_ordering;\n+  dw_attr_ref at_picture_string;\n+  dw_attr_ref at_prototyped;\n+  dw_attr_ref at_small;\n+  dw_attr_ref at_segment;\n+  dw_attr_ref at_string_length;\n+  dw_attr_ref at_threads_scaled;\n+  dw_attr_ref at_upper_bound;\n+  dw_attr_ref at_use_location;\n+  dw_attr_ref at_use_UTF8;\n+  dw_attr_ref at_variable_parameter;\n+  dw_attr_ref at_virtuality;\n+  dw_attr_ref at_visibility;\n+  dw_attr_ref at_vtable_elem_location;\n+};\n \n-/* Do the dies look the same?  */\n+/* Collect the attributes that we will want to use for the checksum.  */\n \n-static int\n-same_die_p (dw_die_ref die1, dw_die_ref die2, int *mark)\n+static void\n+collect_checksum_attributes (struct checksum_attributes *attrs, dw_die_ref die)\n {\n-  dw_die_ref c1, c2;\n-  dw_attr_ref a1;\n+  dw_attr_ref a;\n   unsigned ix;\n \n-  /* To avoid infinite recursion.  */\n-  if (die1->die_mark)\n-    return die1->die_mark == die2->die_mark;\n-  die1->die_mark = die2->die_mark = ++(*mark);\n-\n-  if (die1->die_tag != die2->die_tag)\n-    return 0;\n-\n-  if (VEC_length (dw_attr_node, die1->die_attr)\n-      != VEC_length (dw_attr_node, die2->die_attr))\n-    return 0;\n-\n-  for (ix = 0; VEC_iterate (dw_attr_node, die1->die_attr, ix, a1); ix++)\n-    if (!same_attr_p (a1, VEC_index (dw_attr_node, die2->die_attr, ix), mark))\n-      return 0;\n-\n-  c1 = die1->die_child;\n-  c2 = die2->die_child;\n-  if (! c1)\n+  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n     {\n-      if (c2)\n-\treturn 0;\n-    }\n-  else\n-    for (;;)\n-      {\n-\tif (!same_die_p (c1, c2, mark))\n-\t  return 0;\n-\tc1 = c1->die_sib;\n-\tc2 = c2->die_sib;\n-\tif (c1 == die1->die_child)\n-\t  {\n-\t    if (c2 == die2->die_child)\n-\t      break;\n-\t    else\n-\t      return 0;\n+      switch (a->dw_attr)\n+        {\n+        case DW_AT_name:\n+          attrs->at_name = a;\n+          break;\n+        case DW_AT_type:\n+          attrs->at_type = a;\n+          break;\n+        case DW_AT_friend:\n+          attrs->at_friend = a;\n+          break;\n+        case DW_AT_accessibility:\n+          attrs->at_accessibility = a;\n+          break;\n+        case DW_AT_address_class:\n+          attrs->at_address_class = a;\n+          break;\n+        case DW_AT_allocated:\n+          attrs->at_allocated = a;\n+          break;\n+        case DW_AT_artificial:\n+          attrs->at_artificial = a;\n+          break;\n+        case DW_AT_associated:\n+          attrs->at_associated = a;\n+          break;\n+        case DW_AT_binary_scale:\n+          attrs->at_binary_scale = a;\n+          break;\n+        case DW_AT_bit_offset:\n+          attrs->at_bit_offset = a;\n+          break;\n+        case DW_AT_bit_size:\n+          attrs->at_bit_size = a;\n+          break;\n+        case DW_AT_bit_stride:\n+          attrs->at_bit_stride = a;\n+          break;\n+        case DW_AT_byte_size:\n+          attrs->at_byte_size = a;\n+          break;\n+        case DW_AT_byte_stride:\n+          attrs->at_byte_stride = a;\n+          break;\n+        case DW_AT_const_value:\n+          attrs->at_const_value = a;\n+          break;\n+        case DW_AT_containing_type:\n+          attrs->at_containing_type = a;\n+          break;\n+        case DW_AT_count:\n+          attrs->at_count = a;\n+          break;\n+        case DW_AT_data_location:\n+          attrs->at_data_location = a;\n+          break;\n+        case DW_AT_data_member_location:\n+          attrs->at_data_member_location = a;\n+          break;\n+        case DW_AT_decimal_scale:\n+          attrs->at_decimal_scale = a;\n+          break;\n+        case DW_AT_decimal_sign:\n+          attrs->at_decimal_sign = a;\n+          break;\n+        case DW_AT_default_value:\n+          attrs->at_default_value = a;\n+          break;\n+        case DW_AT_digit_count:\n+          attrs->at_digit_count = a;\n+          break;\n+        case DW_AT_discr:\n+          attrs->at_discr = a;\n+          break;\n+        case DW_AT_discr_list:\n+          attrs->at_discr_list = a;\n+          break;\n+        case DW_AT_discr_value:\n+          attrs->at_discr_value = a;\n+          break;\n+        case DW_AT_encoding:\n+          attrs->at_encoding = a;\n+          break;\n+        case DW_AT_endianity:\n+          attrs->at_endianity = a;\n+          break;\n+        case DW_AT_explicit:\n+          attrs->at_explicit = a;\n+          break;\n+        case DW_AT_is_optional:\n+          attrs->at_is_optional = a;\n+          break;\n+        case DW_AT_location:\n+          attrs->at_location = a;\n+          break;\n+        case DW_AT_lower_bound:\n+          attrs->at_lower_bound = a;\n+          break;\n+        case DW_AT_mutable:\n+          attrs->at_mutable = a;\n+          break;\n+        case DW_AT_ordering:\n+          attrs->at_ordering = a;\n+          break;\n+        case DW_AT_picture_string:\n+          attrs->at_picture_string = a;\n+          break;\n+        case DW_AT_prototyped:\n+          attrs->at_prototyped = a;\n+          break;\n+        case DW_AT_small:\n+          attrs->at_small = a;\n+          break;\n+        case DW_AT_segment:\n+          attrs->at_segment = a;\n+          break;\n+        case DW_AT_string_length:\n+          attrs->at_string_length = a;\n+          break;\n+        case DW_AT_threads_scaled:\n+          attrs->at_threads_scaled = a;\n+          break;\n+        case DW_AT_upper_bound:\n+          attrs->at_upper_bound = a;\n+          break;\n+        case DW_AT_use_location:\n+          attrs->at_use_location = a;\n+          break;\n+        case DW_AT_use_UTF8:\n+          attrs->at_use_UTF8 = a;\n+          break;\n+        case DW_AT_variable_parameter:\n+          attrs->at_variable_parameter = a;\n+          break;\n+        case DW_AT_virtuality:\n+          attrs->at_virtuality = a;\n+          break;\n+        case DW_AT_visibility:\n+          attrs->at_visibility = a;\n+          break;\n+        case DW_AT_vtable_elem_location:\n+          attrs->at_vtable_elem_location = a;\n+          break;\n+        default:\n+          break;\n+        }\n+    }\n+}\n+\n+/* Calculate the checksum of a DIE, using an ordered subset of attributes.  */\n+\n+static void\n+die_checksum_ordered (dw_die_ref die, struct md5_ctx *ctx, int *mark)\n+{\n+  dw_die_ref c;\n+  dw_die_ref decl;\n+  struct checksum_attributes attrs;\n+\n+  CHECKSUM_ULEB128 ('D');\n+  CHECKSUM_ULEB128 (die->die_tag);\n+\n+  memset (&attrs, 0, sizeof (attrs));\n+\n+  decl = get_AT_ref (die, DW_AT_specification);\n+  if (decl != NULL)\n+    collect_checksum_attributes (&attrs, decl);\n+  collect_checksum_attributes (&attrs, die);\n+\n+  CHECKSUM_ATTR (attrs.at_name);\n+  CHECKSUM_ATTR (attrs.at_accessibility);\n+  CHECKSUM_ATTR (attrs.at_address_class);\n+  CHECKSUM_ATTR (attrs.at_allocated);\n+  CHECKSUM_ATTR (attrs.at_artificial);\n+  CHECKSUM_ATTR (attrs.at_associated);\n+  CHECKSUM_ATTR (attrs.at_binary_scale);\n+  CHECKSUM_ATTR (attrs.at_bit_offset);\n+  CHECKSUM_ATTR (attrs.at_bit_size);\n+  CHECKSUM_ATTR (attrs.at_bit_stride);\n+  CHECKSUM_ATTR (attrs.at_byte_size);\n+  CHECKSUM_ATTR (attrs.at_byte_stride);\n+  CHECKSUM_ATTR (attrs.at_const_value);\n+  CHECKSUM_ATTR (attrs.at_containing_type);\n+  CHECKSUM_ATTR (attrs.at_count);\n+  CHECKSUM_ATTR (attrs.at_data_location);\n+  CHECKSUM_ATTR (attrs.at_data_member_location);\n+  CHECKSUM_ATTR (attrs.at_decimal_scale);\n+  CHECKSUM_ATTR (attrs.at_decimal_sign);\n+  CHECKSUM_ATTR (attrs.at_default_value);\n+  CHECKSUM_ATTR (attrs.at_digit_count);\n+  CHECKSUM_ATTR (attrs.at_discr);\n+  CHECKSUM_ATTR (attrs.at_discr_list);\n+  CHECKSUM_ATTR (attrs.at_discr_value);\n+  CHECKSUM_ATTR (attrs.at_encoding);\n+  CHECKSUM_ATTR (attrs.at_endianity);\n+  CHECKSUM_ATTR (attrs.at_explicit);\n+  CHECKSUM_ATTR (attrs.at_is_optional);\n+  CHECKSUM_ATTR (attrs.at_location);\n+  CHECKSUM_ATTR (attrs.at_lower_bound);\n+  CHECKSUM_ATTR (attrs.at_mutable);\n+  CHECKSUM_ATTR (attrs.at_ordering);\n+  CHECKSUM_ATTR (attrs.at_picture_string);\n+  CHECKSUM_ATTR (attrs.at_prototyped);\n+  CHECKSUM_ATTR (attrs.at_small);\n+  CHECKSUM_ATTR (attrs.at_segment);\n+  CHECKSUM_ATTR (attrs.at_string_length);\n+  CHECKSUM_ATTR (attrs.at_threads_scaled);\n+  CHECKSUM_ATTR (attrs.at_upper_bound);\n+  CHECKSUM_ATTR (attrs.at_use_location);\n+  CHECKSUM_ATTR (attrs.at_use_UTF8);\n+  CHECKSUM_ATTR (attrs.at_variable_parameter);\n+  CHECKSUM_ATTR (attrs.at_virtuality);\n+  CHECKSUM_ATTR (attrs.at_visibility);\n+  CHECKSUM_ATTR (attrs.at_vtable_elem_location);\n+  CHECKSUM_ATTR (attrs.at_type);\n+  CHECKSUM_ATTR (attrs.at_friend);\n+\n+  /* Checksum the child DIEs, except for nested types and member functions.  */\n+  c = die->die_child;\n+  if (c) do {\n+    dw_attr_ref name_attr;\n+\n+    c = c->die_sib;\n+    name_attr = get_AT (c, DW_AT_name);\n+    if ((is_type_die (c) || c->die_tag == DW_TAG_subprogram)\n+        && name_attr != NULL)\n+      {\n+        CHECKSUM_ULEB128 ('S');\n+        CHECKSUM_ULEB128 (c->die_tag);\n+        CHECKSUM_STRING (AT_string (name_attr));\n+      }\n+    else\n+      {\n+        /* Mark this DIE so it gets processed when unmarking.  */\n+        if (c->die_mark == 0)\n+          c->die_mark = -1;\n+        die_checksum_ordered (c, ctx, mark);\n+      }\n+  } while (c != die->die_child);\n+\n+  CHECKSUM_ULEB128 (0);\n+}\n+\n+#undef CHECKSUM\n+#undef CHECKSUM_STRING\n+#undef CHECKSUM_ATTR\n+#undef CHECKSUM_LEB128\n+#undef CHECKSUM_ULEB128\n+\n+/* Generate the type signature for DIE.  This is computed by generating an\n+   MD5 checksum over the DIE's tag, its relevant attributes, and its\n+   children.  Attributes that are references to other DIEs are processed\n+   by recursion, using the MARK field to prevent infinite recursion.\n+   If the DIE is nested inside a namespace or another type, we also\n+   need to include that context in the signature.  The lower 64 bits\n+   of the resulting MD5 checksum comprise the signature.  */\n+\n+static void\n+generate_type_signature (dw_die_ref die, comdat_type_node *type_node)\n+{\n+  int mark;\n+  const char *name;\n+  unsigned char checksum[16];\n+  struct md5_ctx ctx;\n+  dw_die_ref decl;\n+\n+  name = get_AT_string (die, DW_AT_name);\n+  decl = get_AT_ref (die, DW_AT_specification);\n+\n+  /* First, compute a signature for just the type name (and its surrounding\n+     context, if any.  This is stored in the type unit DIE for link-time\n+     ODR (one-definition rule) checking.  */\n+\n+  if (is_cxx() && name != NULL)\n+    {\n+      md5_init_ctx (&ctx);\n+\n+      /* Checksum the names of surrounding namespaces and structures.  */\n+      if (decl != NULL && decl->die_parent != NULL)\n+        checksum_die_context (decl->die_parent, &ctx);\n+\n+      md5_process_bytes (&die->die_tag, sizeof (die->die_tag), &ctx);\n+      md5_process_bytes (name, strlen (name) + 1, &ctx);\n+      md5_finish_ctx (&ctx, checksum);\n+\n+      add_AT_data8 (type_node->root_die, DW_AT_GNU_odr_signature, &checksum[8]);\n+    }\n+\n+  /* Next, compute the complete type signature.  */\n+\n+  md5_init_ctx (&ctx);\n+  mark = 1;\n+  die->die_mark = mark;\n+\n+  /* Checksum the names of surrounding namespaces and structures.  */\n+  if (decl != NULL && decl->die_parent != NULL)\n+    checksum_die_context (decl->die_parent, &ctx);\n+\n+  /* Checksum the DIE and its children.  */\n+  die_checksum_ordered (die, &ctx, &mark);\n+  unmark_all_dies (die);\n+  md5_finish_ctx (&ctx, checksum);\n+\n+  /* Store the signature in the type node and link the type DIE and the\n+     type node together.  */\n+  memcpy (type_node->signature, &checksum[16 - DWARF_TYPE_SIGNATURE_SIZE],\n+          DWARF_TYPE_SIGNATURE_SIZE);\n+  die->die_id.die_type_node = type_node;\n+  type_node->type_die = die;\n+\n+  /* If the DIE is a specification, link its declaration to the type node\n+     as well.  */\n+  if (decl != NULL)\n+    decl->die_id.die_type_node = type_node;\n+}\n+\n+/* Do the location expressions look same?  */\n+static inline int\n+same_loc_p (dw_loc_descr_ref loc1, dw_loc_descr_ref loc2, int *mark)\n+{\n+  return loc1->dw_loc_opc == loc2->dw_loc_opc\n+\t && same_dw_val_p (&loc1->dw_loc_oprnd1, &loc2->dw_loc_oprnd1, mark)\n+\t && same_dw_val_p (&loc1->dw_loc_oprnd2, &loc2->dw_loc_oprnd2, mark);\n+}\n+\n+/* Do the values look the same?  */\n+static int\n+same_dw_val_p (const dw_val_node *v1, const dw_val_node *v2, int *mark)\n+{\n+  dw_loc_descr_ref loc1, loc2;\n+  rtx r1, r2;\n+\n+  if (v1->val_class != v2->val_class)\n+    return 0;\n+\n+  switch (v1->val_class)\n+    {\n+    case dw_val_class_const:\n+      return v1->v.val_int == v2->v.val_int;\n+    case dw_val_class_unsigned_const:\n+      return v1->v.val_unsigned == v2->v.val_unsigned;\n+    case dw_val_class_const_double:\n+      return v1->v.val_double.high == v2->v.val_double.high\n+\t     && v1->v.val_double.low == v2->v.val_double.low;\n+    case dw_val_class_vec:\n+      if (v1->v.val_vec.length != v2->v.val_vec.length\n+\t  || v1->v.val_vec.elt_size != v2->v.val_vec.elt_size)\n+\treturn 0;\n+      if (memcmp (v1->v.val_vec.array, v2->v.val_vec.array,\n+\t\t  v1->v.val_vec.length * v1->v.val_vec.elt_size))\n+\treturn 0;\n+      return 1;\n+    case dw_val_class_flag:\n+      return v1->v.val_flag == v2->v.val_flag;\n+    case dw_val_class_str:\n+      return !strcmp(v1->v.val_str->str, v2->v.val_str->str);\n+\n+    case dw_val_class_addr:\n+      r1 = v1->v.val_addr;\n+      r2 = v2->v.val_addr;\n+      if (GET_CODE (r1) != GET_CODE (r2))\n+\treturn 0;\n+      return !rtx_equal_p (r1, r2);\n+\n+    case dw_val_class_offset:\n+      return v1->v.val_offset == v2->v.val_offset;\n+\n+    case dw_val_class_loc:\n+      for (loc1 = v1->v.val_loc, loc2 = v2->v.val_loc;\n+\t   loc1 && loc2;\n+\t   loc1 = loc1->dw_loc_next, loc2 = loc2->dw_loc_next)\n+\tif (!same_loc_p (loc1, loc2, mark))\n+\t  return 0;\n+      return !loc1 && !loc2;\n+\n+    case dw_val_class_die_ref:\n+      return same_die_p (v1->v.val_die_ref.die, v2->v.val_die_ref.die, mark);\n+\n+    case dw_val_class_fde_ref:\n+    case dw_val_class_lbl_id:\n+    case dw_val_class_lineptr:\n+    case dw_val_class_macptr:\n+      return 1;\n+\n+    case dw_val_class_file:\n+      return v1->v.val_file == v2->v.val_file;\n+\n+    case dw_val_class_data8:\n+      return !memcmp (v1->v.val_data8, v2->v.val_data8, 8);\n+\n+    default:\n+      return 1;\n+    }\n+}\n+\n+/* Do the attributes look the same?  */\n+\n+static int\n+same_attr_p (dw_attr_ref at1, dw_attr_ref at2, int *mark)\n+{\n+  if (at1->dw_attr != at2->dw_attr)\n+    return 0;\n+\n+  /* We don't care that this was compiled with a different compiler\n+     snapshot; if the output is the same, that's what matters. */\n+  if (at1->dw_attr == DW_AT_producer)\n+    return 1;\n+\n+  return same_dw_val_p (&at1->dw_attr_val, &at2->dw_attr_val, mark);\n+}\n+\n+/* Do the dies look the same?  */\n+\n+static int\n+same_die_p (dw_die_ref die1, dw_die_ref die2, int *mark)\n+{\n+  dw_die_ref c1, c2;\n+  dw_attr_ref a1;\n+  unsigned ix;\n+\n+  /* To avoid infinite recursion.  */\n+  if (die1->die_mark)\n+    return die1->die_mark == die2->die_mark;\n+  die1->die_mark = die2->die_mark = ++(*mark);\n+\n+  if (die1->die_tag != die2->die_tag)\n+    return 0;\n+\n+  if (VEC_length (dw_attr_node, die1->die_attr)\n+      != VEC_length (dw_attr_node, die2->die_attr))\n+    return 0;\n+\n+  for (ix = 0; VEC_iterate (dw_attr_node, die1->die_attr, ix, a1); ix++)\n+    if (!same_attr_p (a1, VEC_index (dw_attr_node, die2->die_attr, ix), mark))\n+      return 0;\n+\n+  c1 = die1->die_child;\n+  c2 = die2->die_child;\n+  if (! c1)\n+    {\n+      if (c2)\n+\treturn 0;\n+    }\n+  else\n+    for (;;)\n+      {\n+\tif (!same_die_p (c1, c2, mark))\n+\t  return 0;\n+\tc1 = c1->die_sib;\n+\tc2 = c2->die_sib;\n+\tif (c1 == die1->die_child)\n+\t  {\n+\t    if (c2 == die2->die_child)\n+\t      break;\n+\t    else\n+\t      return 0;\n \t  }\n     }\n \n@@ -8067,7 +8854,7 @@ compute_section_prefix (dw_die_ref unit_die)\n       p += 2;\n     }\n \n-  comdat_symbol_id = unit_die->die_symbol = xstrdup (name);\n+  comdat_symbol_id = unit_die->die_id.die_symbol = xstrdup (name);\n   comdat_symbol_number = 0;\n }\n \n@@ -8126,213 +8913,751 @@ is_comdat_die (dw_die_ref c)\n     {\n       dw_die_ref t = get_AT_ref (c, DW_AT_type);\n \n-      return t ? is_comdat_die (t) : 0;\n-    }\n+      return t ? is_comdat_die (t) : 0;\n+    }\n+\n+  return is_type_die (c);\n+}\n+\n+/* Returns 1 iff C is the sort of DIE that might be referred to from another\n+   compilation unit.  */\n+\n+static int\n+is_symbol_die (dw_die_ref c)\n+{\n+  return (is_type_die (c)\n+\t  || is_declaration_die (c)\n+\t  || c->die_tag == DW_TAG_namespace\n+\t  || c->die_tag == DW_TAG_module);\n+}\n+\n+static char *\n+gen_internal_sym (const char *prefix)\n+{\n+  char buf[256];\n+\n+  ASM_GENERATE_INTERNAL_LABEL (buf, prefix, label_num++);\n+  return xstrdup (buf);\n+}\n+\n+/* Assign symbols to all worthy DIEs under DIE.  */\n+\n+static void\n+assign_symbol_names (dw_die_ref die)\n+{\n+  dw_die_ref c;\n+\n+  if (is_symbol_die (die))\n+    {\n+      if (comdat_symbol_id)\n+\t{\n+\t  char *p = XALLOCAVEC (char, strlen (comdat_symbol_id) + 64);\n+\n+\t  sprintf (p, \"%s.%s.%x\", DIE_LABEL_PREFIX,\n+\t\t   comdat_symbol_id, comdat_symbol_number++);\n+\t  die->die_id.die_symbol = xstrdup (p);\n+\t}\n+      else\n+\tdie->die_id.die_symbol = gen_internal_sym (\"LDIE\");\n+    }\n+\n+  FOR_EACH_CHILD (die, c, assign_symbol_names (c));\n+}\n+\n+struct cu_hash_table_entry\n+{\n+  dw_die_ref cu;\n+  unsigned min_comdat_num, max_comdat_num;\n+  struct cu_hash_table_entry *next;\n+};\n+\n+/* Routines to manipulate hash table of CUs.  */\n+static hashval_t\n+htab_cu_hash (const void *of)\n+{\n+  const struct cu_hash_table_entry *const entry =\n+    (const struct cu_hash_table_entry *) of;\n+\n+  return htab_hash_string (entry->cu->die_id.die_symbol);\n+}\n+\n+static int\n+htab_cu_eq (const void *of1, const void *of2)\n+{\n+  const struct cu_hash_table_entry *const entry1 =\n+    (const struct cu_hash_table_entry *) of1;\n+  const struct die_struct *const entry2 = (const struct die_struct *) of2;\n+\n+  return !strcmp (entry1->cu->die_id.die_symbol, entry2->die_id.die_symbol);\n+}\n+\n+static void\n+htab_cu_del (void *what)\n+{\n+  struct cu_hash_table_entry *next,\n+    *entry = (struct cu_hash_table_entry *) what;\n+\n+  while (entry)\n+    {\n+      next = entry->next;\n+      free (entry);\n+      entry = next;\n+    }\n+}\n+\n+/* Check whether we have already seen this CU and set up SYM_NUM\n+   accordingly.  */\n+static int\n+check_duplicate_cu (dw_die_ref cu, htab_t htable, unsigned int *sym_num)\n+{\n+  struct cu_hash_table_entry dummy;\n+  struct cu_hash_table_entry **slot, *entry, *last = &dummy;\n+\n+  dummy.max_comdat_num = 0;\n+\n+  slot = (struct cu_hash_table_entry **)\n+    htab_find_slot_with_hash (htable, cu, htab_hash_string (cu->die_id.die_symbol),\n+\tINSERT);\n+  entry = *slot;\n+\n+  for (; entry; last = entry, entry = entry->next)\n+    {\n+      if (same_die_p_wrap (cu, entry->cu))\n+\tbreak;\n+    }\n+\n+  if (entry)\n+    {\n+      *sym_num = entry->min_comdat_num;\n+      return 1;\n+    }\n+\n+  entry = XCNEW (struct cu_hash_table_entry);\n+  entry->cu = cu;\n+  entry->min_comdat_num = *sym_num = last->max_comdat_num;\n+  entry->next = *slot;\n+  *slot = entry;\n+\n+  return 0;\n+}\n+\n+/* Record SYM_NUM to record of CU in HTABLE.  */\n+static void\n+record_comdat_symbol_number (dw_die_ref cu, htab_t htable, unsigned int sym_num)\n+{\n+  struct cu_hash_table_entry **slot, *entry;\n+\n+  slot = (struct cu_hash_table_entry **)\n+    htab_find_slot_with_hash (htable, cu, htab_hash_string (cu->die_id.die_symbol),\n+\tNO_INSERT);\n+  entry = *slot;\n+\n+  entry->max_comdat_num = sym_num;\n+}\n+\n+/* Traverse the DIE (which is always comp_unit_die), and set up\n+   additional compilation units for each of the include files we see\n+   bracketed by BINCL/EINCL.  */\n+\n+static void\n+break_out_includes (dw_die_ref die)\n+{\n+  dw_die_ref c;\n+  dw_die_ref unit = NULL;\n+  limbo_die_node *node, **pnode;\n+  htab_t cu_hash_table;\n+\n+  c = die->die_child;\n+  if (c) do {\n+    dw_die_ref prev = c;\n+    c = c->die_sib;\n+    while (c->die_tag == DW_TAG_GNU_BINCL || c->die_tag == DW_TAG_GNU_EINCL\n+\t   || (unit && is_comdat_die (c)))\n+      {\n+\tdw_die_ref next = c->die_sib;\n+\n+\t/* This DIE is for a secondary CU; remove it from the main one.  */\n+\tremove_child_with_prev (c, prev);\n+\n+\tif (c->die_tag == DW_TAG_GNU_BINCL)\n+\t  unit = push_new_compile_unit (unit, c);\n+\telse if (c->die_tag == DW_TAG_GNU_EINCL)\n+\t  unit = pop_compile_unit (unit);\n+\telse\n+\t  add_child_die (unit, c);\n+\tc = next;\n+\tif (c == die->die_child)\n+\t  break;\n+      }\n+  } while (c != die->die_child);\n+\n+#if 0\n+  /* We can only use this in debugging, since the frontend doesn't check\n+     to make sure that we leave every include file we enter.  */\n+  gcc_assert (!unit);\n+#endif\n+\n+  assign_symbol_names (die);\n+  cu_hash_table = htab_create (10, htab_cu_hash, htab_cu_eq, htab_cu_del);\n+  for (node = limbo_die_list, pnode = &limbo_die_list;\n+       node;\n+       node = node->next)\n+    {\n+      int is_dupl;\n+\n+      compute_section_prefix (node->die);\n+      is_dupl = check_duplicate_cu (node->die, cu_hash_table,\n+\t\t\t&comdat_symbol_number);\n+      assign_symbol_names (node->die);\n+      if (is_dupl)\n+\t*pnode = node->next;\n+      else\n+\t{\n+\t  pnode = &node->next;\n+\t  record_comdat_symbol_number (node->die, cu_hash_table,\n+\t\tcomdat_symbol_number);\n+\t}\n+    }\n+  htab_delete (cu_hash_table);\n+}\n+\n+/* Return non-zero if this DIE is a declaration.  */\n+\n+static int\n+is_declaration_die (dw_die_ref die)\n+{\n+  dw_attr_ref a;\n+  unsigned ix;\n+\n+  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+    if (a->dw_attr == DW_AT_declaration)\n+      return 1;\n+\n+  return 0;\n+}\n+\n+/* Return non-zero if this is a type DIE that should be moved to a\n+   COMDAT .debug_types section.  */\n+\n+static int\n+should_move_die_to_comdat (dw_die_ref die)\n+{\n+  switch (die->die_tag)\n+    {\n+    case DW_TAG_class_type:\n+    case DW_TAG_structure_type:\n+    case DW_TAG_enumeration_type:\n+    case DW_TAG_union_type:\n+      /* Don't move declarations or inlined instances.  */\n+      if (is_declaration_die (die) || get_AT (die, DW_AT_abstract_origin))\n+        return 0;\n+      return 1;\n+    case DW_TAG_array_type:\n+    case DW_TAG_interface_type:\n+    case DW_TAG_pointer_type:\n+    case DW_TAG_reference_type:\n+    case DW_TAG_string_type:\n+    case DW_TAG_subroutine_type:\n+    case DW_TAG_ptr_to_member_type:\n+    case DW_TAG_set_type:\n+    case DW_TAG_subrange_type:\n+    case DW_TAG_base_type:\n+    case DW_TAG_const_type:\n+    case DW_TAG_file_type:\n+    case DW_TAG_packed_type:\n+    case DW_TAG_volatile_type:\n+    case DW_TAG_typedef:\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Make a clone of DIE.  */\n+\n+static dw_die_ref\n+clone_die (dw_die_ref die)\n+{\n+  dw_die_ref clone;\n+  dw_attr_ref a;\n+  unsigned ix;\n+\n+  clone = GGC_CNEW (die_node);\n+  clone->die_tag = die->die_tag;\n+\n+  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+    add_dwarf_attr (clone, a);\n+\n+  return clone;\n+}\n+\n+/* Make a clone of the tree rooted at DIE.  */\n+\n+static dw_die_ref\n+clone_tree (dw_die_ref die)\n+{\n+  dw_die_ref c;\n+  dw_die_ref clone = clone_die (die);\n+\n+  FOR_EACH_CHILD (die, c, add_child_die (clone, clone_tree(c)));\n+\n+  return clone;\n+}\n+\n+/* Make a clone of DIE as a declaration.  */\n+\n+static dw_die_ref\n+clone_as_declaration (dw_die_ref die)\n+{\n+  dw_die_ref clone;\n+  dw_die_ref decl;\n+  dw_attr_ref a;\n+  unsigned ix;\n+\n+  /* If the DIE is already a declaration, just clone it.  */\n+  if (is_declaration_die (die))\n+    return clone_die (die);\n+\n+  /* If the DIE is a specification, just clone its declaration DIE.  */\n+  decl = get_AT_ref (die, DW_AT_specification);\n+  if (decl != NULL)\n+    return clone_die (decl);\n+\n+  clone = GGC_CNEW (die_node);\n+  clone->die_tag = die->die_tag;\n+\n+  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+    {\n+      /* We don't want to copy over all attributes.\n+         For example we don't want DW_AT_byte_size because otherwise we will no\n+         longer have a declaration and GDB will treat it as a definition.  */\n+\n+      switch (a->dw_attr)\n+        {\n+        case DW_AT_artificial:\n+        case DW_AT_containing_type:\n+        case DW_AT_external:\n+        case DW_AT_name:\n+        case DW_AT_type:\n+        case DW_AT_virtuality:\n+        case DW_AT_MIPS_linkage_name:\n+          add_dwarf_attr (clone, a);\n+          break;\n+        case DW_AT_byte_size:\n+        default:\n+          break;\n+        }\n+    }\n+\n+  if (die->die_id.die_type_node)\n+    add_AT_die_ref (clone, DW_AT_signature, die);\n+\n+  add_AT_flag (clone, DW_AT_declaration, 1);\n+  return clone;\n+}\n+\n+/* Copy the declaration context to the new compile unit DIE.  This includes\n+   any surrounding namespace or type declarations.  If the DIE has an\n+   AT_specification attribute, it also includes attributes and children\n+   attached to the specification.  */\n+\n+static void\n+copy_declaration_context (dw_die_ref unit, dw_die_ref die)\n+{\n+  dw_die_ref decl;\n+  dw_die_ref new_decl;\n+\n+  decl = get_AT_ref (die, DW_AT_specification);\n+  if (decl == NULL)\n+    decl = die;\n+  else\n+    {\n+      unsigned ix;\n+      dw_die_ref c;\n+      dw_attr_ref a;\n+\n+      /* Copy the type node pointer from the new DIE to the original\n+         declaration DIE so we can forward references later.  */\n+      decl->die_id.die_type_node = die->die_id.die_type_node;\n+\n+      remove_AT (die, DW_AT_specification);\n+\n+      for (ix = 0; VEC_iterate (dw_attr_node, decl->die_attr, ix, a); ix++)\n+        {\n+          if (a->dw_attr != DW_AT_name\n+              && a->dw_attr != DW_AT_declaration\n+              && a->dw_attr != DW_AT_external)\n+            add_dwarf_attr (die, a);\n+        }\n+\n+      FOR_EACH_CHILD (decl, c, add_child_die (die, clone_tree(c)));\n+    }\n+\n+  if (decl->die_parent != NULL\n+      && decl->die_parent->die_tag != DW_TAG_compile_unit\n+      && decl->die_parent->die_tag != DW_TAG_type_unit)\n+    {\n+      new_decl = copy_ancestor_tree (unit, decl, NULL);\n+      if (new_decl != NULL)\n+        {\n+          remove_AT (new_decl, DW_AT_signature);\n+          add_AT_specification (die, new_decl);\n+        }\n+    }\n+}\n+\n+/* Generate the skeleton ancestor tree for the given NODE, then clone\n+   the DIE and add the clone into the tree.  */\n+\n+static void\n+generate_skeleton_ancestor_tree (skeleton_chain_node *node)\n+{\n+  if (node->new_die != NULL)\n+    return;\n+\n+  node->new_die = clone_as_declaration (node->old_die);\n+\n+  if (node->parent != NULL)\n+    {\n+      generate_skeleton_ancestor_tree (node->parent);\n+      add_child_die (node->parent->new_die, node->new_die);\n+    }\n+}\n+\n+/* Generate a skeleton tree of DIEs containing any declarations that are\n+   found in the original tree.  We traverse the tree looking for declaration\n+   DIEs, and construct the skeleton from the bottom up whenever we find one.  */\n+\n+static void\n+generate_skeleton_bottom_up (skeleton_chain_node *parent)\n+{\n+  skeleton_chain_node node;\n+  dw_die_ref c;\n+  dw_die_ref first;\n+  dw_die_ref prev = NULL;\n+  dw_die_ref next = NULL;\n+\n+  node.parent = parent;\n \n-  return is_type_die (c);\n+  first = c = parent->old_die->die_child;\n+  if (c)\n+    next = c->die_sib;\n+  if (c) do {\n+    if (prev == NULL || prev->die_sib == c)\n+      prev = c;\n+    c = next;\n+    next = (c == first ? NULL : c->die_sib);\n+    node.old_die = c;\n+    node.new_die = NULL;\n+    if (is_declaration_die (c))\n+      {\n+        /* Clone the existing DIE, move the original to the skeleton\n+           tree (which is in the main CU), and put the clone, with\n+           all the original's children, where the original came from.  */\n+        dw_die_ref clone = clone_die (c);\n+        move_all_children (c, clone);\n+\n+        replace_child (c, clone, prev);\n+        generate_skeleton_ancestor_tree (parent);\n+        add_child_die (parent->new_die, c);\n+        node.new_die = c;\n+        c = clone;\n+      }\n+    generate_skeleton_bottom_up (&node);\n+  } while (next != NULL);\n }\n \n-/* Returns 1 iff C is the sort of DIE that might be referred to from another\n-   compilation unit.  */\n+/* Wrapper function for generate_skeleton_bottom_up.  */\n \n-static int\n-is_symbol_die (dw_die_ref c)\n+static dw_die_ref\n+generate_skeleton (dw_die_ref die)\n {\n-  return (is_type_die (c)\n-\t  || (get_AT (c, DW_AT_declaration)\n-\t      && !get_AT (c, DW_AT_specification))\n-\t  || c->die_tag == DW_TAG_namespace\n-\t  || c->die_tag == DW_TAG_module);\n+  skeleton_chain_node node;\n+\n+  node.old_die = die;\n+  node.new_die = NULL;\n+  node.parent = NULL;\n+\n+  /* If this type definition is nested inside another type,\n+     always leave at least a declaration in its place.  */\n+  if (die->die_parent != NULL && is_type_die (die->die_parent))\n+    node.new_die = clone_as_declaration (die);\n+\n+  generate_skeleton_bottom_up (&node);\n+  return node.new_die;\n }\n \n-static char *\n-gen_internal_sym (const char *prefix)\n+/* Remove the DIE from its parent, possibly replacing it with a cloned\n+   declaration.  The original DIE will be moved to a new compile unit\n+   so that existing references to it follow it to the new location.  If\n+   any of the original DIE's descendants is a declaration, we need to\n+   replace the original DIE with a skeleton tree and move the\n+   declarations back into the skeleton tree.  */\n+\n+static dw_die_ref\n+remove_child_or_replace_with_skeleton (dw_die_ref child, dw_die_ref prev)\n {\n-  char buf[256];\n+  dw_die_ref skeleton;\n \n-  ASM_GENERATE_INTERNAL_LABEL (buf, prefix, label_num++);\n-  return xstrdup (buf);\n+  skeleton = generate_skeleton (child);\n+  if (skeleton == NULL)\n+    remove_child_with_prev (child, prev);\n+  else\n+    {\n+      skeleton->die_id.die_type_node = child->die_id.die_type_node;\n+      replace_child (child, skeleton, prev);\n+    }\n+\n+  return skeleton;\n }\n \n-/* Assign symbols to all worthy DIEs under DIE.  */\n+/* Traverse the DIE and set up additional .debug_types sections for each\n+   type worthy of being placed in a COMDAT section.  */\n \n static void\n-assign_symbol_names (dw_die_ref die)\n+break_out_comdat_types (dw_die_ref die)\n {\n   dw_die_ref c;\n+  dw_die_ref first;\n+  dw_die_ref prev = NULL;\n+  dw_die_ref next = NULL;\n+  dw_die_ref unit = NULL;\n \n-  if (is_symbol_die (die))\n-    {\n-      if (comdat_symbol_id)\n-\t{\n-\t  char *p = XALLOCAVEC (char, strlen (comdat_symbol_id) + 64);\n+  first = c = die->die_child;\n+  if (c)\n+    next = c->die_sib;\n+  if (c) do {\n+    if (prev == NULL || prev->die_sib == c)\n+      prev = c;\n+    c = next;\n+    next = (c == first ? NULL : c->die_sib);\n+    if (should_move_die_to_comdat (c))\n+      {\n+        dw_die_ref replacement;\n+\tcomdat_type_node_ref type_node;\n \n-\t  sprintf (p, \"%s.%s.%x\", DIE_LABEL_PREFIX,\n-\t\t   comdat_symbol_id, comdat_symbol_number++);\n-\t  die->die_symbol = xstrdup (p);\n-\t}\n-      else\n-\tdie->die_symbol = gen_internal_sym (\"LDIE\");\n-    }\n+        /* Create a new type unit DIE as the root for the new tree, and\n+           add it to the list of comdat types.  */\n+        unit = new_die (DW_TAG_type_unit, NULL, NULL);\n+        add_AT_unsigned (unit, DW_AT_language,\n+                         get_AT_unsigned (comp_unit_die, DW_AT_language));\n+        type_node = GGC_CNEW (comdat_type_node);\n+        type_node->root_die = unit;\n+        type_node->next = comdat_type_list;\n+        comdat_type_list = type_node;\n \n-  FOR_EACH_CHILD (die, c, assign_symbol_names (c));\n+        /* Generate the type signature.  */\n+        generate_type_signature (c, type_node);\n+\n+        /* Copy the declaration context, attributes, and children of the\n+           declaration into the new compile unit DIE.  */\n+\tcopy_declaration_context (unit, c);\n+\n+        /* Remove this DIE from the main CU.  */\n+\treplacement = remove_child_or_replace_with_skeleton (c, prev);\n+\n+        /* Break out nested types into their own type units.  */\n+        break_out_comdat_types (c);\n+\n+        /* Add the DIE to the new compunit.  */\n+\tadd_child_die (unit, c);\n+\n+        if (replacement != NULL)\n+          c = replacement;\n+      }\n+    else if (c->die_tag == DW_TAG_namespace\n+             || c->die_tag == DW_TAG_class_type\n+             || c->die_tag == DW_TAG_structure_type\n+             || c->die_tag == DW_TAG_union_type)\n+      {\n+        /* Look for nested types that can be broken out.  */\n+        break_out_comdat_types (c);\n+      }\n+  } while (next != NULL);\n }\n \n-struct cu_hash_table_entry\n+/* Structure to map a DIE in one CU to its copy in a comdat type unit.  */\n+\n+struct decl_table_entry\n {\n-  dw_die_ref cu;\n-  unsigned min_comdat_num, max_comdat_num;\n-  struct cu_hash_table_entry *next;\n+  dw_die_ref orig;\n+  dw_die_ref copy;\n };\n \n-/* Routines to manipulate hash table of CUs.  */\n+/* Routines to manipulate hash table of copied declarations.  */\n+\n static hashval_t\n-htab_cu_hash (const void *of)\n+htab_decl_hash (const void *of)\n {\n-  const struct cu_hash_table_entry *const entry =\n-    (const struct cu_hash_table_entry *) of;\n+  const struct decl_table_entry *const entry =\n+    (const struct decl_table_entry *) of;\n \n-  return htab_hash_string (entry->cu->die_symbol);\n+  return htab_hash_pointer (entry->orig);\n }\n \n static int\n-htab_cu_eq (const void *of1, const void *of2)\n+htab_decl_eq (const void *of1, const void *of2)\n {\n-  const struct cu_hash_table_entry *const entry1 =\n-    (const struct cu_hash_table_entry *) of1;\n+  const struct decl_table_entry *const entry1 =\n+    (const struct decl_table_entry *) of1;\n   const struct die_struct *const entry2 = (const struct die_struct *) of2;\n \n-  return !strcmp (entry1->cu->die_symbol, entry2->die_symbol);\n+  return entry1->orig == entry2;\n }\n \n static void\n-htab_cu_del (void *what)\n+htab_decl_del (void *what)\n {\n-  struct cu_hash_table_entry *next,\n-    *entry = (struct cu_hash_table_entry *) what;\n+  struct decl_table_entry *entry = (struct decl_table_entry *) what;\n \n-  while (entry)\n-    {\n-      next = entry->next;\n-      free (entry);\n-      entry = next;\n-    }\n+  free (entry);\n }\n \n-/* Check whether we have already seen this CU and set up SYM_NUM\n-   accordingly.  */\n-static int\n-check_duplicate_cu (dw_die_ref cu, htab_t htable, unsigned int *sym_num)\n-{\n-  struct cu_hash_table_entry dummy;\n-  struct cu_hash_table_entry **slot, *entry, *last = &dummy;\n-\n-  dummy.max_comdat_num = 0;\n+/* Copy DIE and its ancestors, up to, but not including, the compile unit \n+   or type unit entry, to a new tree.  Adds the new tree to UNIT and returns\n+   a pointer to the copy of DIE.  If DECL_TABLE is provided, it is used\n+   to check if the ancestor has already been copied into UNIT.  */\n \n-  slot = (struct cu_hash_table_entry **)\n-    htab_find_slot_with_hash (htable, cu, htab_hash_string (cu->die_symbol),\n-\tINSERT);\n-  entry = *slot;\n+static dw_die_ref\n+copy_ancestor_tree (dw_die_ref unit, dw_die_ref die, htab_t decl_table)\n+{\n+  dw_die_ref parent = die->die_parent;\n+  dw_die_ref new_parent = unit;\n+  dw_die_ref copy;\n+  void **slot = NULL;\n+  struct decl_table_entry *entry = NULL;\n \n-  for (; entry; last = entry, entry = entry->next)\n+  if (decl_table)\n     {\n-      if (same_die_p_wrap (cu, entry->cu))\n-\tbreak;\n+      /* Check if the entry has already been copied to UNIT.  */\n+      slot = htab_find_slot_with_hash (decl_table, die,\n+                                       htab_hash_pointer (die), INSERT);\n+      if (*slot != HTAB_EMPTY_ENTRY)\n+        {\n+          entry = (struct decl_table_entry *) *slot;\n+          return entry->copy;\n+        }\n+\n+      /* Record in DECL_TABLE that DIE has been copied to UNIT.  */\n+      entry = XCNEW (struct decl_table_entry);\n+      entry->orig = die;\n+      entry->copy = NULL;\n+      *slot = entry;\n     }\n \n-  if (entry)\n+  if (parent != NULL)\n     {\n-      *sym_num = entry->min_comdat_num;\n-      return 1;\n+      dw_die_ref spec = get_AT_ref (parent, DW_AT_specification);\n+      if (spec != NULL)\n+        parent = spec;\n+      if (parent->die_tag != DW_TAG_compile_unit\n+          && parent->die_tag != DW_TAG_type_unit)\n+        new_parent = copy_ancestor_tree (unit, parent, decl_table);\n     }\n \n-  entry = XCNEW (struct cu_hash_table_entry);\n-  entry->cu = cu;\n-  entry->min_comdat_num = *sym_num = last->max_comdat_num;\n-  entry->next = *slot;\n-  *slot = entry;\n-\n-  return 0;\n-}\n-\n-/* Record SYM_NUM to record of CU in HTABLE.  */\n-static void\n-record_comdat_symbol_number (dw_die_ref cu, htab_t htable, unsigned int sym_num)\n-{\n-  struct cu_hash_table_entry **slot, *entry;\n+  copy = clone_as_declaration (die);\n+  add_child_die (new_parent, copy);\n \n-  slot = (struct cu_hash_table_entry **)\n-    htab_find_slot_with_hash (htable, cu, htab_hash_string (cu->die_symbol),\n-\tNO_INSERT);\n-  entry = *slot;\n+  if (decl_table != NULL)\n+    {\n+      /* Make sure the copy is marked as part of the type unit.  */\n+      copy->die_mark = 1;\n+      /* Record the pointer to the copy.  */\n+      entry->copy = copy;\n+    }\n \n-  entry->max_comdat_num = sym_num;\n+  return copy;\n }\n \n-/* Traverse the DIE (which is always comp_unit_die), and set up\n-   additional compilation units for each of the include files we see\n-   bracketed by BINCL/EINCL.  */\n+/* Walk the DIE and its children, looking for references to incomplete\n+   or trivial types that are unmarked (i.e., that are not in the current\n+   type_unit).  */\n \n static void\n-break_out_includes (dw_die_ref die)\n+copy_decls_walk (dw_die_ref unit, dw_die_ref die, htab_t decl_table)\n {\n   dw_die_ref c;\n-  dw_die_ref unit = NULL;\n-  limbo_die_node *node, **pnode;\n-  htab_t cu_hash_table;\n+  dw_attr_ref a;\n+  unsigned ix;\n \n-  c = die->die_child;\n-  if (c) do {\n-    dw_die_ref prev = c;\n-    c = c->die_sib;\n-    while (c->die_tag == DW_TAG_GNU_BINCL || c->die_tag == DW_TAG_GNU_EINCL\n-\t   || (unit && is_comdat_die (c)))\n-      {\n-\tdw_die_ref next = c->die_sib;\n+  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+    {\n+      if (AT_class (a) == dw_val_class_die_ref)\n+        {\n+          dw_die_ref targ = AT_ref (a);\n+          comdat_type_node_ref type_node = targ->die_id.die_type_node;\n+          void **slot;\n+          struct decl_table_entry *entry;\n \n-\t/* This DIE is for a secondary CU; remove it from the main one.  */\n-\tremove_child_with_prev (c, prev);\n+          if (targ->die_mark != 0 || type_node != NULL)\n+            continue;\n \n-\tif (c->die_tag == DW_TAG_GNU_BINCL)\n-\t  unit = push_new_compile_unit (unit, c);\n-\telse if (c->die_tag == DW_TAG_GNU_EINCL)\n-\t  unit = pop_compile_unit (unit);\n-\telse\n-\t  add_child_die (unit, c);\n-\tc = next;\n-\tif (c == die->die_child)\n-\t  break;\n-      }\n-  } while (c != die->die_child);\n+          slot = htab_find_slot_with_hash (decl_table, targ,\n+                                           htab_hash_pointer (targ), INSERT);\n \n-#if 0\n-  /* We can only use this in debugging, since the frontend doesn't check\n-     to make sure that we leave every include file we enter.  */\n-  gcc_assert (!unit);\n-#endif\n+          if (*slot != HTAB_EMPTY_ENTRY)\n+            {\n+              /* TARG has already been copied, so we just need to\n+                 modify the reference to point to the copy.  */\n+              entry = (struct decl_table_entry *) *slot;\n+              a->dw_attr_val.v.val_die_ref.die = entry->copy;\n+            }\n+          else\n+            {\n+              dw_die_ref parent = unit;\n+              dw_die_ref copy = clone_tree (targ);\n+\n+              /* Make sure the cloned tree is marked as part of the\n+                 type unit.  */\n+              mark_dies (copy);\n+\n+              /* Record in DECL_TABLE that TARG has been copied.\n+                 Need to do this now, before the recursive call,\n+                 because DECL_TABLE may be expanded and SLOT\n+                 would no longer be a valid pointer.  */\n+              entry = XCNEW (struct decl_table_entry);\n+              entry->orig = targ;\n+              entry->copy = copy;\n+              *slot = entry;\n+\n+              /* If TARG has surrounding context, copy its ancestor tree\n+                 into the new type unit.  */\n+              if (targ->die_parent != NULL\n+                  && targ->die_parent->die_tag != DW_TAG_compile_unit\n+                  && targ->die_parent->die_tag != DW_TAG_type_unit)\n+                parent = copy_ancestor_tree (unit, targ->die_parent,\n+                                             decl_table);\n+\n+              add_child_die (parent, copy);\n+              a->dw_attr_val.v.val_die_ref.die = copy;\n+\n+              /* Make sure the newly-copied DIE is walked.  If it was\n+                 installed in a previously-added context, it won't\n+                 get visited otherwise.  */\n+              if (parent != unit)\n+                copy_decls_walk (unit, parent, decl_table);\n+            }\n+        }\n+    }\n \n-  assign_symbol_names (die);\n-  cu_hash_table = htab_create (10, htab_cu_hash, htab_cu_eq, htab_cu_del);\n-  for (node = limbo_die_list, pnode = &limbo_die_list;\n-       node;\n-       node = node->next)\n-    {\n-      int is_dupl;\n+  FOR_EACH_CHILD (die, c, copy_decls_walk (unit, c, decl_table));\n+}\n \n-      compute_section_prefix (node->die);\n-      is_dupl = check_duplicate_cu (node->die, cu_hash_table,\n-\t\t\t&comdat_symbol_number);\n-      assign_symbol_names (node->die);\n-      if (is_dupl)\n-\t*pnode = node->next;\n-      else\n-\t{\n-\t  pnode = &node->next;\n-\t  record_comdat_symbol_number (node->die, cu_hash_table,\n-\t\tcomdat_symbol_number);\n-\t}\n-    }\n-  htab_delete (cu_hash_table);\n+/* Copy declarations for \"unworthy\" types into the new comdat section.\n+   Incomplete types, modified types, and certain other types aren't broken\n+   out into comdat sections of their own, so they don't have a signature,\n+   and we need to copy the declaration into the same section so that we\n+   don't have an external reference.  */\n+\n+static void\n+copy_decls_for_unworthy_types (dw_die_ref unit)\n+{\n+  htab_t decl_table;\n+\n+  mark_dies (unit);\n+  decl_table = htab_create (10, htab_decl_hash, htab_decl_eq, htab_decl_del);\n+  copy_decls_walk (unit, unit, decl_table);\n+  htab_delete (decl_table);\n+  unmark_dies (unit);\n }\n \n /* Traverse the DIE and add a sibling attribute if it may have the\n@@ -8389,7 +9714,7 @@ build_abbrev_table (dw_die_ref die)\n     if (AT_class (a) == dw_val_class_die_ref\n \t&& AT_ref (a)->die_mark == 0)\n       {\n-\tgcc_assert (AT_ref (a)->die_symbol);\n+\tgcc_assert (dwarf_version >= 4 || AT_ref (a)->die_id.die_symbol);\n \tset_AT_ref_external (a, 1);\n       }\n \n@@ -8519,10 +9844,19 @@ size_of_die (dw_die_ref die)\n \t  size += 1;\n \t  break;\n \tcase dw_val_class_die_ref:\n-\t  /* In DWARF2, DW_FORM_ref_addr is sized by target address length,\n-\t     whereas in DWARF3 it's always sized as an offset.  */\n-\t  if (AT_ref_external (a) && dwarf_version == 2)\n-\t    size += DWARF2_ADDR_SIZE;\n+\t  if (AT_ref_external (a))\n+\t    {\n+\t      /* In DWARF4, we use DW_FORM_sig8; for earlier versions\n+\t\t we use DW_FORM_ref_addr.  In DWARF2, DW_FORM_ref_addr\n+\t\t is sized by target address length, whereas in DWARF3\n+\t\t it's always sized as an offset.  */\n+\t      if (dwarf_version >= 4)\n+\t\tsize += DWARF_TYPE_SIGNATURE_SIZE;\n+\t      else if (dwarf_version == 2)\n+\t\tsize += DWARF2_ADDR_SIZE;\n+\t      else\n+\t\tsize += DWARF_OFFSET_SIZE;\n+\t    }\n \t  else\n \t    size += DWARF_OFFSET_SIZE;\n \t  break;\n@@ -8545,6 +9879,9 @@ size_of_die (dw_die_ref die)\n \tcase dw_val_class_file:\n \t  size += constant_size (maybe_emit_file (a->dw_attr_val.v.val_file));\n \t  break;\n+\tcase dw_val_class_data8:\n+\t  size += 8;\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -8596,7 +9933,8 @@ unmark_dies (dw_die_ref die)\n {\n   dw_die_ref c;\n \n-  gcc_assert (die->die_mark);\n+  if (dwarf_version < 4)\n+    gcc_assert (die->die_mark);\n \n   die->die_mark = 0;\n   FOR_EACH_CHILD (die, c, unmark_dies (c));\n@@ -8764,7 +10102,7 @@ value_format (dw_attr_ref a)\n       return DW_FORM_flag;\n     case dw_val_class_die_ref:\n       if (AT_ref_external (a))\n-\treturn DW_FORM_ref_addr;\n+\treturn dwarf_version >= 4 ? DW_FORM_sig8 : DW_FORM_ref_addr;\n       else\n \treturn DW_FORM_ref;\n     case dw_val_class_fde_ref:\n@@ -8789,6 +10127,9 @@ value_format (dw_attr_ref a)\n \t  gcc_unreachable ();\n \t}\n \n+    case dw_val_class_data8:\n+      return DW_FORM_data8;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -8848,7 +10189,7 @@ output_abbrev_section (void)\n static inline void\n output_die_symbol (dw_die_ref die)\n {\n-  char *sym = die->die_symbol;\n+  char *sym = die->die_id.die_symbol;\n \n   if (sym == 0)\n     return;\n@@ -8950,6 +10291,17 @@ output_loc_list (dw_loc_list_ref list_head)\n \t\t       list_head->ll_symbol);\n }\n \n+/* Output a type signature.  */\n+\n+static inline void\n+output_signature (const char *sig, const char *name)\n+{\n+  int i;\n+\n+  for (i = 0; i < DWARF_TYPE_SIGNATURE_SIZE; i++)\n+    dw2_asm_output_data (1, sig[i], \"%s\", name);\n+}\n+\n /* Output the DIE and its attributes.  Called recursively to generate\n    the definitions of each child DIE.  */\n \n@@ -8963,7 +10315,7 @@ output_die (dw_die_ref die)\n \n   /* If someone in another CU might refer to us, set up a symbol for\n      them to point to.  */\n-  if (die->die_symbol)\n+  if (dwarf_version < 4 && die->die_id.die_symbol)\n     output_die_symbol (die);\n \n   dw2_asm_output_data_uleb128 (die->die_abbrev, \"(DIE (0x%lx) %s)\",\n@@ -9085,18 +10437,30 @@ output_die (dw_die_ref die)\n \tcase dw_val_class_die_ref:\n \t  if (AT_ref_external (a))\n \t    {\n-\t      char *sym = AT_ref (a)->die_symbol;\n-\t      int size;\n-\n-\t      gcc_assert (sym);\n+\t      if (dwarf_version >= 4)\n+\t        {\n+\t          comdat_type_node_ref type_node =\n+\t            AT_ref (a)->die_id.die_type_node;\n \n-\t      /* In DWARF2, DW_FORM_ref_addr is sized by target address\n-\t\t length, whereas in DWARF3 it's always sized as an offset.  */\n-\t      if (dwarf_version == 2)\n-\t\tsize = DWARF2_ADDR_SIZE;\n+\t          gcc_assert (type_node);\n+\t          output_signature (type_node->signature, name);\n+\t        }\n \t      else\n-\t\tsize = DWARF_OFFSET_SIZE;\n-\t      dw2_asm_output_offset (size, sym, debug_info_section, \"%s\", name);\n+\t        {\n+\t\t  char *sym = AT_ref (a)->die_id.die_symbol;\n+\t\t  int size;\n+\n+\t\t  gcc_assert (sym);\n+\t\t  /* In DWARF2, DW_FORM_ref_addr is sized by target address\n+\t\t     length, whereas in DWARF3 it's always sized as an\n+\t\t     offset.  */\n+\t\t  if (dwarf_version == 2)\n+\t\t    size = DWARF2_ADDR_SIZE;\n+\t\t  else\n+\t\t    size = DWARF_OFFSET_SIZE;\n+\t\t  dw2_asm_output_offset (size, sym, debug_info_section, \"%s\",\n+\t\t\t\t\t name);\n+\t\t}\n \t    }\n \t  else\n \t    {\n@@ -9150,6 +10514,16 @@ output_die (dw_die_ref die)\n \t    break;\n \t  }\n \n+\tcase dw_val_class_data8:\n+\t  {\n+\t    int i;\n+\n+\t    for (i = 0; i < 8; i++)\n+\t      dw2_asm_output_data (1, a->dw_attr_val.v.val_data8[i],\n+\t                           \"%s\", name);\n+\t    break;\n+\t  }\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -9169,13 +10543,20 @@ output_die (dw_die_ref die)\n static void\n output_compilation_unit_header (void)\n {\n+  int ver = dwarf_version;\n+\n+  /* Don't mark the output as DWARF-4 until we make full use of the\n+     version 4 extensions, and gdb supports them.  For now, -gdwarf-4\n+     selects only a few extensions from the DWARF-4 spec.  */\n+  if (ver > 3)\n+    ver = 3;\n   if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n     dw2_asm_output_data (4, 0xffffffff,\n       \"Initial length escape value indicating 64-bit DWARF extension\");\n   dw2_asm_output_data (DWARF_OFFSET_SIZE,\n \t\t       next_die_offset - DWARF_INITIAL_LENGTH_SIZE,\n \t\t       \"Length of Compilation Unit Info\");\n-  dw2_asm_output_data (2, dwarf_version, \"DWARF version number\");\n+  dw2_asm_output_data (2, ver, \"DWARF version number\");\n   dw2_asm_output_offset (DWARF_OFFSET_SIZE, abbrev_section_label,\n \t\t\t debug_abbrev_section,\n \t\t\t \"Offset Into Abbrev. Section\");\n@@ -9207,14 +10588,14 @@ output_comp_unit (dw_die_ref die, int output_if_empty)\n   next_die_offset = DWARF_COMPILE_UNIT_HEADER_SIZE;\n   calc_die_sizes (die);\n \n-  oldsym = die->die_symbol;\n+  oldsym = die->die_id.die_symbol;\n   if (oldsym)\n     {\n       tmp = XALLOCAVEC (char, strlen (oldsym) + 24);\n \n       sprintf (tmp, \".gnu.linkonce.wi.%s\", oldsym);\n       secname = tmp;\n-      die->die_symbol = NULL;\n+      die->die_id.die_symbol = NULL;\n       switch_to_section (get_section (secname, SECTION_DEBUG, NULL));\n     }\n   else\n@@ -9229,10 +10610,60 @@ output_comp_unit (dw_die_ref die, int output_if_empty)\n   if (oldsym)\n     {\n       unmark_dies (die);\n-      die->die_symbol = oldsym;\n+      die->die_id.die_symbol = oldsym;\n     }\n }\n \n+/* Output a comdat type unit DIE and its children.  */\n+\n+static void\n+output_comdat_type_unit (comdat_type_node *node)\n+{\n+  const char *secname;\n+  char *tmp;\n+  int i;\n+#if defined (OBJECT_FORMAT_ELF)\n+  tree comdat_key;\n+#endif\n+\n+  /* First mark all the DIEs in this CU so we know which get local refs.  */\n+  mark_dies (node->root_die);\n+\n+  build_abbrev_table (node->root_die);\n+\n+  /* Initialize the beginning DIE offset - and calculate sizes/offsets.  */\n+  next_die_offset = DWARF_COMDAT_TYPE_UNIT_HEADER_SIZE;\n+  calc_die_sizes (node->root_die);\n+\n+#if defined (OBJECT_FORMAT_ELF)\n+  secname = \".debug_types\";\n+  tmp = XALLOCAVEC (char, 4 + DWARF_TYPE_SIGNATURE_SIZE * 2);\n+  sprintf (tmp, \"wt.\");\n+  for (i = 0; i < DWARF_TYPE_SIGNATURE_SIZE; i++)\n+    sprintf (tmp + 3 + i * 2, \"%02x\", node->signature[i] & 0xff);\n+  comdat_key = get_identifier (tmp);\n+  targetm.asm_out.named_section (secname,\n+                                 SECTION_DEBUG | SECTION_LINKONCE,\n+                                 comdat_key);\n+#else\n+  tmp = XALLOCAVEC (char, 18 + DWARF_TYPE_SIGNATURE_SIZE * 2);\n+  sprintf (tmp, \".gnu.linkonce.wt.\");\n+  for (i = 0; i < DWARF_TYPE_SIGNATURE_SIZE; i++)\n+    sprintf (tmp + 17 + i * 2, \"%02x\", node->signature[i] & 0xff);\n+  secname = tmp;\n+  switch_to_section (get_section (secname, SECTION_DEBUG, NULL));\n+#endif\n+\n+  /* Output debugging information.  */\n+  output_compilation_unit_header ();\n+  output_signature (node->signature, \"Type Signature\");\n+  dw2_asm_output_data (DWARF_OFFSET_SIZE, node->type_die->die_offset,\n+\t\t       \"Offset to Type DIE\");\n+  output_die (node->root_die);\n+\n+  unmark_dies (node->root_die);\n+}\n+\n /* Return the DWARF2/3 pubname associated with a decl.  */\n \n static const char *\n@@ -9950,6 +11381,13 @@ output_line_info (void)\n   long line_delta;\n   unsigned long current_file;\n   unsigned long function;\n+  int ver = dwarf_version;\n+\n+  /* Don't mark the output as DWARF-4 until we make full use of the\n+     version 4 extensions, and gdb supports them.  For now, -gdwarf-4\n+     selects only a few extensions from the DWARF-4 spec.  */\n+  if (ver > 3)\n+    ver = 3;\n \n   ASM_GENERATE_INTERNAL_LABEL (l1, LINE_NUMBER_BEGIN_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (l2, LINE_NUMBER_END_LABEL, 0);\n@@ -9963,7 +11401,7 @@ output_line_info (void)\n \t\t\t\"Length of Source Line Info\");\n   ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n-  dw2_asm_output_data (2, dwarf_version, \"DWARF Version\");\n+  dw2_asm_output_data (2, ver, \"DWARF Version\");\n   dw2_asm_output_delta (DWARF_OFFSET_SIZE, p2, p1, \"Prolog Length\");\n   ASM_OUTPUT_LABEL (asm_out_file, p1);\n \n@@ -18457,7 +19895,7 @@ dwarf2out_source_line (unsigned int line, const char *filename,\n static void\n dwarf2out_start_source_file (unsigned int lineno, const char *filename)\n {\n-  if (flag_eliminate_dwarf2_dups)\n+  if (flag_eliminate_dwarf2_dups && dwarf_version < 4)\n     {\n       /* Record the beginning of the file for break_out_includes.  */\n       dw_die_ref bincl_die;\n@@ -18484,7 +19922,7 @@ dwarf2out_start_source_file (unsigned int lineno, const char *filename)\n static void\n dwarf2out_end_source_file (unsigned int lineno ATTRIBUTE_UNUSED)\n {\n-  if (flag_eliminate_dwarf2_dups)\n+  if (flag_eliminate_dwarf2_dups && dwarf_version < 4)\n     /* Record the end of the file for break_out_includes.  */\n     new_die (DW_TAG_GNU_EINCL, comp_unit_die, NULL);\n \n@@ -18708,8 +20146,12 @@ prune_unused_types_walk_attribs (dw_die_ref die)\n       if (a->dw_attr_val.val_class == dw_val_class_die_ref)\n \t{\n \t  /* A reference to another DIE.\n-\t     Make sure that it will get emitted.  */\n-\t  prune_unused_types_mark (a->dw_attr_val.v.val_die_ref.die, 1);\n+\t     Make sure that it will get emitted.\n+\t     If it was broken out into a comdat group, don't follow it.  */\n+          if (dwarf_version < 4\n+              || a->dw_attr == DW_AT_specification\n+              || a->dw_attr_val.v.val_die_ref.die->die_id.die_type_node == NULL)\n+\t    prune_unused_types_mark (a->dw_attr_val.v.val_die_ref.die, 1);\n \t}\n       /* Set the string's refcount to 0 so that prune_unused_types_mark\n \t accounts properly for it.  */\n@@ -18753,8 +20195,12 @@ prune_unused_types_mark (dw_die_ref die, int dokids)\n       die->die_mark = 2;\n \n       /* If this is an array type, we need to make sure our\n-\t kids get marked, even if they're types.  */\n-      if (die->die_tag == DW_TAG_array_type)\n+\t kids get marked, even if they're types.  If we're\n+\t breaking out types into comdat sections, do this\n+\t for all type definitions.  */\n+      if (die->die_tag == DW_TAG_array_type\n+          || (dwarf_version >= 4 \n+              && is_type_die (die) && ! is_declaration_die (die)))\n \tFOR_EACH_CHILD (die, c, prune_unused_types_mark (c, 1));\n       else\n \tFOR_EACH_CHILD (die, c, prune_unused_types_walk (c));\n@@ -18958,13 +20404,16 @@ prune_unused_types (void)\n {\n   unsigned int i;\n   limbo_die_node *node;\n+  comdat_type_node *ctnode;\n   pubname_ref pub;\n \n #if ENABLE_ASSERT_CHECKING\n   /* All the marks should already be clear.  */\n   verify_marks_clear (comp_unit_die);\n   for (node = limbo_die_list; node; node = node->next)\n     verify_marks_clear (node->die);\n+  for (ctnode = comdat_type_list; ctnode; ctnode = ctnode->next)\n+    verify_marks_clear (ctnode->root_die);\n #endif /* ENABLE_ASSERT_CHECKING */\n \n   /* Mark types that are used in global variables.  */\n@@ -18974,6 +20423,11 @@ prune_unused_types (void)\n   prune_unused_types_walk (comp_unit_die);\n   for (node = limbo_die_list; node; node = node->next)\n     prune_unused_types_walk (node->die);\n+  for (ctnode = comdat_type_list; ctnode; ctnode = ctnode->next)\n+    {\n+      prune_unused_types_walk (ctnode->root_die);\n+      prune_unused_types_mark (ctnode->type_die, 1);\n+    }\n \n   /* Also set the mark on nodes referenced from the\n      pubname_table or arange_table.  */\n@@ -18990,11 +20444,15 @@ prune_unused_types (void)\n   prune_unused_types_prune (comp_unit_die);\n   for (node = limbo_die_list; node; node = node->next)\n     prune_unused_types_prune (node->die);\n+  for (ctnode = comdat_type_list; ctnode; ctnode = ctnode->next)\n+    prune_unused_types_prune (ctnode->root_die);\n \n   /* Leave the marks clear.  */\n   prune_unmark_dies (comp_unit_die);\n   for (node = limbo_die_list; node; node = node->next)\n     prune_unmark_dies (node->die);\n+  for (ctnode = comdat_type_list; ctnode; ctnode = ctnode->next)\n+    prune_unmark_dies (ctnode->root_die);\n }\n \n /* Set the parameter to true if there are any relative pathnames in\n@@ -19012,6 +20470,28 @@ file_table_relative_p (void ** slot, void *param)\n   return 1;\n }\n \n+/* Routines to manipulate hash table of comdat type units.  */\n+\n+static hashval_t\n+htab_ct_hash (const void *of)\n+{\n+  hashval_t h;\n+  const comdat_type_node *const type_node = (const comdat_type_node *) of;\n+\n+  memcpy (&h, type_node->signature, sizeof (h));\n+  return h;\n+}\n+\n+static int\n+htab_ct_eq (const void *of1, const void *of2)\n+{\n+  const comdat_type_node *const type_node_1 = (const comdat_type_node *) of1;\n+  const comdat_type_node *const type_node_2 = (const comdat_type_node *) of2;\n+\n+  return (! memcmp (type_node_1->signature, type_node_2->signature,\n+                    DWARF_TYPE_SIGNATURE_SIZE));\n+}\n+\n /* Move a DW_AT_MIPS_linkage_name attribute just added to dw_die_ref\n    to the location it would have been added, should we know its\n    DECL_ASSEMBLER_NAME when we added other attributes.  This will\n@@ -19147,6 +20627,8 @@ static void\n dwarf2out_finish (const char *filename)\n {\n   limbo_die_node *node, *next_node;\n+  comdat_type_node *ctnode;\n+  htab_t comdat_type_table;\n   dw_die_ref die = 0;\n   unsigned int i;\n \n@@ -19254,14 +20736,39 @@ dwarf2out_finish (const char *filename)\n \n   /* Generate separate CUs for each of the include files we've seen.\n      They will go into limbo_die_list.  */\n-  if (flag_eliminate_dwarf2_dups)\n+  if (flag_eliminate_dwarf2_dups && dwarf_version < 4)\n     break_out_includes (comp_unit_die);\n \n+  /* Generate separate COMDAT sections for type DIEs. */\n+  if (dwarf_version >= 4)\n+    {\n+      break_out_comdat_types (comp_unit_die);\n+\n+      /* Each new type_unit DIE was added to the limbo die list when created.\n+         Since these have all been added to comdat_type_list, clear the\n+         limbo die list.  */\n+      limbo_die_list = NULL;\n+\n+      /* For each new comdat type unit, copy declarations for incomplete\n+         types to make the new unit self-contained (i.e., no direct\n+         references to the main compile unit).  */\n+      for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)\n+        copy_decls_for_unworthy_types (ctnode->root_die);\n+      copy_decls_for_unworthy_types (comp_unit_die);\n+\n+      /* In the process of copying declarations from one unit to another,\n+         we may have left some declarations behind that are no longer\n+         referenced.  Prune them.  */\n+      prune_unused_types ();\n+    }\n+\n   /* Traverse the DIE's and add add sibling attributes to those DIE's\n      that have children.  */\n   add_sibling_attributes (comp_unit_die);\n   for (node = limbo_die_list; node; node = node->next)\n     add_sibling_attributes (node->die);\n+  for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)\n+    add_sibling_attributes (ctnode->root_die);\n \n   /* Output a terminator label for the .text section.  */\n   switch_to_section (text_section);\n@@ -19344,6 +20851,27 @@ dwarf2out_finish (const char *filename)\n   for (node = limbo_die_list; node; node = node->next)\n     output_comp_unit (node->die, 0);\n \n+  comdat_type_table = htab_create (100, htab_ct_hash, htab_ct_eq, NULL);\n+  for (ctnode = comdat_type_list; ctnode != NULL; ctnode = ctnode->next)\n+    {\n+      void **slot = htab_find_slot (comdat_type_table, ctnode, INSERT);\n+\n+      /* Don't output duplicate types.  */\n+      if (*slot != HTAB_EMPTY_ENTRY)\n+        continue;\n+\n+      /* Add a pointer to the line table for the main compilation unit\n+         so that the debugger can make sense of DW_AT_decl_file\n+         attributes.  */\n+      if (debug_info_level >= DINFO_LEVEL_NORMAL)\n+        add_AT_lineptr (ctnode->root_die, DW_AT_stmt_list,\n+\t\t        debug_line_section_label);\n+\n+      output_comdat_type_unit (ctnode);\n+      *slot = ctnode;\n+    }\n+  htab_delete (comdat_type_table);\n+\n   /* Output the main compilation unit if non-empty or if .debug_macinfo\n      has been emitted.  */\n   output_comp_unit (comp_unit_die, debug_info_level >= DINFO_LEVEL_VERBOSE);"}, {"sha": "46ec00da18043b182765b1326985585980951d81", "filename": "gcc/varasm.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b3fbeb7e97f2ca3731881bf3a0f899ec56ebbf/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b3fbeb7e97f2ca3731881bf3a0f899ec56ebbf/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=15b3fbeb7e97f2ca3731881bf3a0f899ec56ebbf", "patch": "@@ -5997,8 +5997,13 @@ default_elf_asm_named_section (const char *name, unsigned int flags,\n       if (flags & SECTION_ENTSIZE)\n \tfprintf (asm_out_file, \",%d\", flags & SECTION_ENTSIZE);\n       if (HAVE_COMDAT_GROUP && (flags & SECTION_LINKONCE))\n-\tfprintf (asm_out_file, \",%s,comdat\",\n-\t\t IDENTIFIER_POINTER (DECL_COMDAT_GROUP (decl)));\n+\t{\n+\t  if (TREE_CODE (decl) == IDENTIFIER_NODE)\n+\t    fprintf (asm_out_file, \",%s,comdat\", IDENTIFIER_POINTER (decl));\n+\t  else\n+\t    fprintf (asm_out_file, \",%s,comdat\",\n+\t\t     IDENTIFIER_POINTER (DECL_COMDAT_GROUP (decl)));\n+\t}\n     }\n \n   putc ('\\n', asm_out_file);"}]}