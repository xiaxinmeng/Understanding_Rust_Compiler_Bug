{"sha": "cacb4a794f079490a56eb99294947ba5acb4269a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FjYjRhNzk0ZjA3OTQ5MGE1NmViOTkyOTQ5NDdiYTVhY2I0MjY5YQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2018-01-30T17:40:50Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-01-30T17:40:50Z"}, "message": "[PR81611] accept copies in simple_iv_increment_p\n\nIf there are copies between the GIMPLE_PHI at the loop body and the\nincrement that reaches it (presumably through a back edge), still\nregard it as a simple_iv_increment, so that we won't consider the\nvalue in the back edge eligible for forwprop.  Doing so would risk\nmaking the phi node and the incremented conflicting value live\nwithin the loop, and the phi node to be preserved for propagated\nuses after the loop.\n\nfor  gcc/ChangeLog\n\n\tPR tree-optimization/81611\n\t* tree-ssa-dom.c (simple_iv_increment_p): Skip intervening\n\tcopies.\n\nFrom-SVN: r257194", "tree": {"sha": "fecd6616032e0c9bded68f1e029a06cf46d8ed5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fecd6616032e0c9bded68f1e029a06cf46d8ed5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cacb4a794f079490a56eb99294947ba5acb4269a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cacb4a794f079490a56eb99294947ba5acb4269a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cacb4a794f079490a56eb99294947ba5acb4269a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cacb4a794f079490a56eb99294947ba5acb4269a/comments", "author": null, "committer": null, "parents": [{"sha": "a5d37900ad8b09446297217a1748920bf58c99cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5d37900ad8b09446297217a1748920bf58c99cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5d37900ad8b09446297217a1748920bf58c99cc"}], "stats": {"total": 24, "additions": 20, "deletions": 4}, "files": [{"sha": "c9068360d01a2ba4459f3ed9181aab594b2c530b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacb4a794f079490a56eb99294947ba5acb4269a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacb4a794f079490a56eb99294947ba5acb4269a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cacb4a794f079490a56eb99294947ba5acb4269a", "patch": "@@ -1,3 +1,9 @@\n+2018-01-30  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR tree-optimization/81611\n+\t* tree-ssa-dom.c (simple_iv_increment_p): Skip intervening\n+\tcopies.\n+\n 2018-01-30  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.c (rs6000_internal_arg_pointer): Only return"}, {"sha": "a6f176c5def054339a2bd08280de93ad64c35e8c", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacb4a794f079490a56eb99294947ba5acb4269a/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacb4a794f079490a56eb99294947ba5acb4269a/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=cacb4a794f079490a56eb99294947ba5acb4269a", "patch": "@@ -1276,8 +1276,11 @@ record_equality (tree x, tree y, class const_and_copies *const_and_copies)\n /* Returns true when STMT is a simple iv increment.  It detects the\n    following situation:\n \n-   i_1 = phi (..., i_2)\n-   i_2 = i_1 +/- ...  */\n+   i_1 = phi (..., i_k)\n+   [...]\n+   i_j = i_{j-1}  for each j : 2 <= j <= k-1\n+   [...]\n+   i_k = i_{k-1} +/- ...  */\n \n bool\n simple_iv_increment_p (gimple *stmt)\n@@ -1305,8 +1308,15 @@ simple_iv_increment_p (gimple *stmt)\n     return false;\n \n   phi = SSA_NAME_DEF_STMT (preinc);\n-  if (gimple_code (phi) != GIMPLE_PHI)\n-    return false;\n+  while (gimple_code (phi) != GIMPLE_PHI)\n+    {\n+      /* Follow trivial copies, but not the DEF used in a back edge,\n+\t so that we don't prevent coalescing.  */\n+      if (!gimple_assign_ssa_name_copy_p (phi))\n+\treturn false;\n+      preinc = gimple_assign_rhs1 (phi);\n+      phi = SSA_NAME_DEF_STMT (preinc);\n+    }\n \n   for (i = 0; i < gimple_phi_num_args (phi); i++)\n     if (gimple_phi_arg_def (phi, i) == lhs)"}]}