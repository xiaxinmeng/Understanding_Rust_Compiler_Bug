{"sha": "ffe0891751ac18c53d688349bd4aaf6a4ce17af7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZlMDg5MTc1MWFjMThjNTNkNjg4MzQ5YmQ0YWFmNmE0Y2UxN2FmNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-09-14T22:28:10Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-09-14T22:28:10Z"}, "message": "Fix handling of structs with embedded global types.\n\nFrom-SVN: r178870", "tree": {"sha": "8cfeff8cbb8f4589275ca984068b5ddb92b8a76a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cfeff8cbb8f4589275ca984068b5ddb92b8a76a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffe0891751ac18c53d688349bd4aaf6a4ce17af7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe0891751ac18c53d688349bd4aaf6a4ce17af7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffe0891751ac18c53d688349bd4aaf6a4ce17af7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe0891751ac18c53d688349bd4aaf6a4ce17af7/comments", "author": null, "committer": null, "parents": [{"sha": "fe0aee6ca023fde313998a497a8a65c301e923c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe0aee6ca023fde313998a497a8a65c301e923c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe0aee6ca023fde313998a497a8a65c301e923c2"}], "stats": {"total": 178, "additions": 112, "deletions": 66}, "files": [{"sha": "32f0612a1b03261f6e4dfc8f6898d9d2fa9b1f85", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe0891751ac18c53d688349bd4aaf6a4ce17af7/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe0891751ac18c53d688349bd4aaf6a4ce17af7/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=ffe0891751ac18c53d688349bd4aaf6a4ce17af7", "patch": "@@ -12640,6 +12640,16 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n \t\t      {\n \t\t\tconst Struct_field* sf = st->field(fre->field_index());\n \t\t\tname = sf->field_name();\n+\n+\t\t\t// See below.  FIXME.\n+\t\t\tif (!Gogo::is_hidden_name(name)\n+\t\t\t    && name[0] >= 'a'\n+\t\t\t    && name[0] <= 'z')\n+\t\t\t  {\n+\t\t\t    if (gogo->lookup_global(name.c_str()) != NULL)\n+\t\t\t      name = gogo->pack_hidden_name(name, false);\n+\t\t\t  }\n+\n \t\t\tchar buf[20];\n \t\t\tsnprintf(buf, sizeof buf, \"%u\", fre->field_index());\n \t\t\tsize_t buflen = strlen(buf);\n@@ -12671,7 +12681,7 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n \n \t  // A predefined name won't be packed.  If it starts with a\n \t  // lower case letter we need to check for that case, because\n-\t  // the field name will be packed.\n+\t  // the field name will be packed.  FIXME.\n \t  if (!Gogo::is_hidden_name(name)\n \t      && name[0] >= 'a'\n \t      && name[0] <= 'z')\n@@ -13505,7 +13515,10 @@ Struct_field_offset_expression::do_dump_expression(\n     Ast_dump_context* ast_dump_context) const\n {\n   ast_dump_context->ostream() <<  \"unsafe.Offsetof(\";\n-  ast_dump_context->ostream() << this->field_->field_name();\n+  ast_dump_context->dump_type(this->type_);\n+  ast_dump_context->ostream() << '.';\n+  ast_dump_context->ostream() <<\n+    Gogo::message_name(this->field_->field_name());\n   ast_dump_context->ostream() << \")\";\n }\n "}, {"sha": "21c5ba200308a1d55301027c707bdd789369cfb7", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 93, "deletions": 64, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe0891751ac18c53d688349bd4aaf6a4ce17af7/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe0891751ac18c53d688349bd4aaf6a4ce17af7/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=ffe0891751ac18c53d688349bd4aaf6a4ce17af7", "patch": "@@ -1297,28 +1297,28 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   if (!this->has_pointer())\n     runtime_type_kind |= RUNTIME_TYPE_KIND_NO_POINTERS;\n   Struct_field_list::const_iterator p = fields->begin();\n-  go_assert(p->field_name() == \"Kind\");\n+  go_assert(p->is_field_name(\"Kind\"));\n   mpz_t iv;\n   mpz_init_set_ui(iv, runtime_type_kind);\n   vals->push_back(Expression::make_integer(&iv, p->type(), bloc));\n \n   ++p;\n-  go_assert(p->field_name() == \"align\");\n+  go_assert(p->is_field_name(\"align\"));\n   Expression::Type_info type_info = Expression::TYPE_INFO_ALIGNMENT;\n   vals->push_back(Expression::make_type_info(this, type_info));\n \n   ++p;\n-  go_assert(p->field_name() == \"fieldAlign\");\n+  go_assert(p->is_field_name(\"fieldAlign\"));\n   type_info = Expression::TYPE_INFO_FIELD_ALIGNMENT;\n   vals->push_back(Expression::make_type_info(this, type_info));\n \n   ++p;\n-  go_assert(p->field_name() == \"size\");\n+  go_assert(p->is_field_name(\"size\"));\n   type_info = Expression::TYPE_INFO_SIZE;\n   vals->push_back(Expression::make_type_info(this, type_info));\n \n   ++p;\n-  go_assert(p->field_name() == \"hash\");\n+  go_assert(p->is_field_name(\"hash\"));\n   mpz_set_ui(iv, this->hash_for_method(gogo));\n   vals->push_back(Expression::make_integer(&iv, p->type(), bloc));\n \n@@ -1327,7 +1327,7 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   this->type_functions(&hash_fn, &equal_fn);\n \n   ++p;\n-  go_assert(p->field_name() == \"hashfn\");\n+  go_assert(p->is_field_name(\"hashfn\"));\n   Function_type* fntype = p->type()->function_type();\n   Named_object* no = Named_object::make_function_declaration(hash_fn, NULL,\n \t\t\t\t\t\t\t     fntype,\n@@ -1336,22 +1336,22 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   vals->push_back(Expression::make_func_reference(no, NULL, bloc));\n \n   ++p;\n-  go_assert(p->field_name() == \"equalfn\");\n+  go_assert(p->is_field_name(\"equalfn\"));\n   fntype = p->type()->function_type();\n   no = Named_object::make_function_declaration(equal_fn, NULL, fntype, bloc);\n   no->func_declaration_value()->set_asm_name(equal_fn);\n   vals->push_back(Expression::make_func_reference(no, NULL, bloc));\n \n   ++p;\n-  go_assert(p->field_name() == \"string\");\n+  go_assert(p->is_field_name(\"string\"));\n   Expression* s = Expression::make_string((name != NULL\n \t\t\t\t\t   ? name->reflection(gogo)\n \t\t\t\t\t   : this->reflection(gogo)),\n \t\t\t\t\t  bloc);\n   vals->push_back(Expression::make_unary(OPERATOR_AND, s, bloc));\n \n   ++p;\n-  go_assert(p->field_name() == \"uncommonType\");\n+  go_assert(p->is_field_name(\"uncommonType\"));\n   if (name == NULL && methods == NULL)\n     vals->push_back(Expression::make_nil(bloc));\n   else\n@@ -1365,7 +1365,7 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n     }\n \n   ++p;\n-  go_assert(p->field_name() == \"ptrToThis\");\n+  go_assert(p->is_field_name(\"ptrToThis\"));\n   if (name == NULL)\n     vals->push_back(Expression::make_nil(bloc));\n   else\n@@ -1402,10 +1402,10 @@ Type::uncommon_type_constructor(Gogo* gogo, Type* uncommon_type,\n   vals->reserve(3);\n \n   Struct_field_list::const_iterator p = fields->begin();\n-  go_assert(p->field_name() == \"name\");\n+  go_assert(p->is_field_name(\"name\"));\n \n   ++p;\n-  go_assert(p->field_name() == \"pkgPath\");\n+  go_assert(p->is_field_name(\"pkgPath\"));\n \n   if (name == NULL)\n     {\n@@ -1444,7 +1444,7 @@ Type::uncommon_type_constructor(Gogo* gogo, Type* uncommon_type,\n     }\n \n   ++p;\n-  go_assert(p->field_name() == \"methods\");\n+  go_assert(p->is_field_name(\"methods\"));\n   vals->push_back(this->methods_constructor(gogo, p->type(), methods,\n \t\t\t\t\t    only_value_methods));\n \n@@ -1532,13 +1532,13 @@ Type::method_constructor(Gogo*, Type* method_type,\n   vals->reserve(5);\n \n   Struct_field_list::const_iterator p = fields->begin();\n-  go_assert(p->field_name() == \"name\");\n+  go_assert(p->is_field_name(\"name\"));\n   const std::string n = Gogo::unpack_hidden_name(method_name);\n   Expression* s = Expression::make_string(n, bloc);\n   vals->push_back(Expression::make_unary(OPERATOR_AND, s, bloc));\n \n   ++p;\n-  go_assert(p->field_name() == \"pkgPath\");\n+  go_assert(p->is_field_name(\"pkgPath\"));\n   if (!Gogo::is_hidden_name(method_name))\n     vals->push_back(Expression::make_nil(bloc));\n   else\n@@ -1560,11 +1560,11 @@ Type::method_constructor(Gogo*, Type* method_type,\n   Type* nonmethod_type = mtype->copy_without_receiver();\n \n   ++p;\n-  go_assert(p->field_name() == \"mtyp\");\n+  go_assert(p->is_field_name(\"mtyp\"));\n   vals->push_back(Expression::make_type_descriptor(nonmethod_type, bloc));\n \n   ++p;\n-  go_assert(p->field_name() == \"typ\");\n+  go_assert(p->is_field_name(\"typ\"));\n   if (!only_value_methods && m->is_value_method())\n     {\n       // This is a value method on a pointer type.  Change the type of\n@@ -1587,7 +1587,7 @@ Type::method_constructor(Gogo*, Type* method_type,\n   vals->push_back(Expression::make_type_descriptor(mtype, bloc));\n \n   ++p;\n-  go_assert(p->field_name() == \"tfn\");\n+  go_assert(p->is_field_name(\"tfn\"));\n   vals->push_back(Expression::make_func_reference(no, NULL, bloc));\n \n   ++p;\n@@ -2752,22 +2752,22 @@ Function_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   vals->reserve(4);\n \n   Struct_field_list::const_iterator p = fields->begin();\n-  go_assert(p->field_name() == \"commonType\");\n+  go_assert(p->is_field_name(\"commonType\"));\n   vals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t    RUNTIME_TYPE_KIND_FUNC,\n \t\t\t\t\t\t    name, NULL, true));\n \n   ++p;\n-  go_assert(p->field_name() == \"dotdotdot\");\n+  go_assert(p->is_field_name(\"dotdotdot\"));\n   vals->push_back(Expression::make_boolean(this->is_varargs(), bloc));\n \n   ++p;\n-  go_assert(p->field_name() == \"in\");\n+  go_assert(p->is_field_name(\"in\"));\n   vals->push_back(this->type_descriptor_params(p->type(), this->receiver(),\n \t\t\t\t\t       this->parameters()));\n \n   ++p;\n-  go_assert(p->field_name() == \"out\");\n+  go_assert(p->is_field_name(\"out\"));\n   vals->push_back(this->type_descriptor_params(p->type(), NULL,\n \t\t\t\t\t       this->results()));\n \n@@ -3159,13 +3159,13 @@ Pointer_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n       vals->reserve(2);\n \n       Struct_field_list::const_iterator p = fields->begin();\n-      go_assert(p->field_name() == \"commonType\");\n+      go_assert(p->is_field_name(\"commonType\"));\n       vals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t\tRUNTIME_TYPE_KIND_PTR,\n \t\t\t\t\t\t\tname, methods, false));\n \n       ++p;\n-      go_assert(p->field_name() == \"elem\");\n+      go_assert(p->is_field_name(\"elem\"));\n       vals->push_back(Expression::make_type_descriptor(deref, bloc));\n \n       return Expression::make_struct_composite_literal(ptr_tdt, vals, bloc);\n@@ -3373,6 +3373,34 @@ Struct_field::field_name() const\n     }\n }\n \n+// Return whether this field is named NAME.\n+\n+bool\n+Struct_field::is_field_name(const std::string& name) const\n+{\n+  const std::string& me(this->typed_identifier_.name());\n+  if (!me.empty())\n+    return me == name;\n+  else\n+    {\n+      Type* t = this->typed_identifier_.type();\n+      if (t->points_to() != NULL)\n+\tt = t->points_to();\n+      Named_type* nt = t->named_type();\n+      if (nt != NULL && nt->name() == name)\n+\treturn true;\n+\n+      // This is a horrible hack caused by the fact that we don't pack\n+      // the names of builtin types.  FIXME.\n+      if (nt != NULL\n+\t  && nt->is_builtin()\n+\t  && nt->name() == Gogo::unpack_hidden_name(name))\n+\treturn true;\n+\n+      return false;\n+    }\n+}\n+\n // Class Struct_type.\n \n // Traversal.\n@@ -3567,7 +3595,7 @@ Struct_type::find_local_field(const std::string& name,\n        pf != fields->end();\n        ++pf, ++i)\n     {\n-      if (pf->field_name() == name)\n+      if (pf->is_field_name(name))\n \t{\n \t  if (pindex != NULL)\n \t    *pindex = i;\n@@ -3608,7 +3636,7 @@ Struct_type::field_reference_depth(Expression* struct_expr,\n        pf != fields->end();\n        ++pf, ++i)\n     {\n-      if (pf->field_name() == name)\n+      if (pf->is_field_name(name))\n \t{\n \t  *depth = 0;\n \t  return Expression::make_field_reference(struct_expr, i, location);\n@@ -3854,13 +3882,13 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   go_assert(methods == NULL || name == NULL);\n \n   Struct_field_list::const_iterator ps = fields->begin();\n-  go_assert(ps->field_name() == \"commonType\");\n+  go_assert(ps->is_field_name(\"commonType\"));\n   vals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t    RUNTIME_TYPE_KIND_STRUCT,\n \t\t\t\t\t\t    name, methods, true));\n \n   ++ps;\n-  go_assert(ps->field_name() == \"fields\");\n+  go_assert(ps->is_field_name(\"fields\"));\n \n   Expression_list* elements = new Expression_list();\n   elements->reserve(this->fields_->size());\n@@ -3875,7 +3903,7 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n       fvals->reserve(5);\n \n       Struct_field_list::const_iterator q = f->begin();\n-      go_assert(q->field_name() == \"name\");\n+      go_assert(q->is_field_name(\"name\"));\n       if (pf->is_anonymous())\n \tfvals->push_back(Expression::make_nil(bloc));\n       else\n@@ -3886,7 +3914,7 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \t}\n \n       ++q;\n-      go_assert(q->field_name() == \"pkgPath\");\n+      go_assert(q->is_field_name(\"pkgPath\"));\n       if (!Gogo::is_hidden_name(pf->field_name()))\n \tfvals->push_back(Expression::make_nil(bloc));\n       else\n@@ -3897,11 +3925,11 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \t}\n \n       ++q;\n-      go_assert(q->field_name() == \"typ\");\n+      go_assert(q->is_field_name(\"typ\"));\n       fvals->push_back(Expression::make_type_descriptor(pf->type(), bloc));\n \n       ++q;\n-      go_assert(q->field_name() == \"tag\");\n+      go_assert(q->is_field_name(\"tag\"));\n       if (!pf->has_tag())\n \tfvals->push_back(Expression::make_nil(bloc));\n       else\n@@ -3911,7 +3939,7 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \t}\n \n       ++q;\n-      go_assert(q->field_name() == \"offset\");\n+      go_assert(q->is_field_name(\"offset\"));\n       fvals->push_back(Expression::make_struct_field_offset(this, &*pf));\n \n       Expression* v = Expression::make_struct_composite_literal(element_type,\n@@ -4561,22 +4589,22 @@ Array_type::array_type_descriptor(Gogo* gogo, Named_type* name)\n   vals->reserve(3);\n \n   Struct_field_list::const_iterator p = fields->begin();\n-  go_assert(p->field_name() == \"commonType\");\n+  go_assert(p->is_field_name(\"commonType\"));\n   vals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t    RUNTIME_TYPE_KIND_ARRAY,\n \t\t\t\t\t\t    name, NULL, true));\n \n   ++p;\n-  go_assert(p->field_name() == \"elem\");\n+  go_assert(p->is_field_name(\"elem\"));\n   vals->push_back(Expression::make_type_descriptor(this->element_type_, bloc));\n \n   ++p;\n-  go_assert(p->field_name() == \"slice\");\n+  go_assert(p->is_field_name(\"slice\"));\n   Type* slice_type = Type::make_array_type(this->element_type_, NULL);\n   vals->push_back(Expression::make_type_descriptor(slice_type, bloc));\n \n   ++p;\n-  go_assert(p->field_name() == \"len\");\n+  go_assert(p->is_field_name(\"len\"));\n   vals->push_back(Expression::make_cast(p->type(), this->length_, bloc));\n \n   ++p;\n@@ -4600,13 +4628,13 @@ Array_type::slice_type_descriptor(Gogo* gogo, Named_type* name)\n   vals->reserve(2);\n \n   Struct_field_list::const_iterator p = fields->begin();\n-  go_assert(p->field_name() == \"commonType\");\n+  go_assert(p->is_field_name(\"commonType\"));\n   vals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t    RUNTIME_TYPE_KIND_SLICE,\n \t\t\t\t\t\t    name, NULL, true));\n \n   ++p;\n-  go_assert(p->field_name() == \"elem\");\n+  go_assert(p->is_field_name(\"elem\"));\n   vals->push_back(Expression::make_type_descriptor(this->element_type_, bloc));\n \n   ++p;\n@@ -4810,17 +4838,17 @@ Map_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   vals->reserve(3);\n \n   Struct_field_list::const_iterator p = fields->begin();\n-  go_assert(p->field_name() == \"commonType\");\n+  go_assert(p->is_field_name(\"commonType\"));\n   vals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t    RUNTIME_TYPE_KIND_MAP,\n \t\t\t\t\t\t    name, NULL, true));\n \n   ++p;\n-  go_assert(p->field_name() == \"key\");\n+  go_assert(p->is_field_name(\"key\"));\n   vals->push_back(Expression::make_type_descriptor(this->key_type_, bloc));\n \n   ++p;\n-  go_assert(p->field_name() == \"elem\");\n+  go_assert(p->is_field_name(\"elem\"));\n   vals->push_back(Expression::make_type_descriptor(this->val_type_, bloc));\n \n   ++p;\n@@ -4883,27 +4911,27 @@ Map_type::map_descriptor(Gogo* gogo)\n \n   Struct_field_list::const_iterator p = fields->begin();\n \n-  go_assert(p->field_name() == \"__map_descriptor\");\n+  go_assert(p->is_field_name(\"__map_descriptor\"));\n   vals->push_back(Expression::make_type_descriptor(this, bloc));\n \n   ++p;\n-  go_assert(p->field_name() == \"__entry_size\");\n+  go_assert(p->is_field_name(\"__entry_size\"));\n   Expression::Type_info type_info = Expression::TYPE_INFO_SIZE;\n   vals->push_back(Expression::make_type_info(map_entry_type, type_info));\n \n   Struct_field_list::const_iterator pf = map_entry_type->fields()->begin();\n   ++pf;\n-  go_assert(pf->field_name() == \"__key\");\n+  go_assert(pf->is_field_name(\"__key\"));\n \n   ++p;\n-  go_assert(p->field_name() == \"__key_offset\");\n+  go_assert(p->is_field_name(\"__key_offset\"));\n   vals->push_back(Expression::make_struct_field_offset(map_entry_type, &*pf));\n \n   ++pf;\n-  go_assert(pf->field_name() == \"__val\");\n+  go_assert(pf->is_field_name(\"__val\"));\n \n   ++p;\n-  go_assert(p->field_name() == \"__val_offset\");\n+  go_assert(p->is_field_name(\"__val_offset\"));\n   vals->push_back(Expression::make_struct_field_offset(map_entry_type, &*pf));\n \n   ++p;\n@@ -5093,17 +5121,17 @@ Channel_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   vals->reserve(3);\n \n   Struct_field_list::const_iterator p = fields->begin();\n-  go_assert(p->field_name() == \"commonType\");\n+  go_assert(p->is_field_name(\"commonType\"));\n   vals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t    RUNTIME_TYPE_KIND_CHAN,\n \t\t\t\t\t\t    name, NULL, true));\n \n   ++p;\n-  go_assert(p->field_name() == \"elem\");\n+  go_assert(p->is_field_name(\"elem\"));\n   vals->push_back(Expression::make_type_descriptor(this->element_type_, bloc));\n \n   ++p;\n-  go_assert(p->field_name() == \"dir\");\n+  go_assert(p->is_field_name(\"dir\"));\n   // These bits must match the ones in libgo/runtime/go-type.h.\n   int val = 0;\n   if (this->may_receive_)\n@@ -5771,13 +5799,13 @@ Interface_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   ivals->reserve(2);\n \n   Struct_field_list::const_iterator pif = ifields->begin();\n-  go_assert(pif->field_name() == \"commonType\");\n+  go_assert(pif->is_field_name(\"commonType\"));\n   ivals->push_back(this->type_descriptor_constructor(gogo,\n \t\t\t\t\t\t     RUNTIME_TYPE_KIND_INTERFACE,\n \t\t\t\t\t\t     name, NULL, true));\n \n   ++pif;\n-  go_assert(pif->field_name() == \"methods\");\n+  go_assert(pif->is_field_name(\"methods\"));\n \n   Expression_list* methods = new Expression_list();\n   if (this->methods_ != NULL && !this->methods_->empty())\n@@ -5795,13 +5823,13 @@ Interface_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \t  mvals->reserve(3);\n \n \t  Struct_field_list::const_iterator pmf = mfields->begin();\n-\t  go_assert(pmf->field_name() == \"name\");\n+\t  go_assert(pmf->is_field_name(\"name\"));\n \t  std::string s = Gogo::unpack_hidden_name(pm->name());\n \t  Expression* e = Expression::make_string(s, bloc);\n \t  mvals->push_back(Expression::make_unary(OPERATOR_AND, e, bloc));\n \n \t  ++pmf;\n-\t  go_assert(pmf->field_name() == \"pkgPath\");\n+\t  go_assert(pmf->is_field_name(\"pkgPath\"));\n \t  if (!Gogo::is_hidden_name(pm->name()))\n \t    mvals->push_back(Expression::make_nil(bloc));\n \t  else\n@@ -5812,7 +5840,7 @@ Interface_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n \t    }\n \n \t  ++pmf;\n-\t  go_assert(pmf->field_name() == \"typ\");\n+\t  go_assert(pmf->is_field_name(\"typ\"));\n \t  mvals->push_back(Expression::make_type_descriptor(pm->type(), bloc));\n \n \t  ++pmf;\n@@ -7571,9 +7599,8 @@ Type::bind_field_or_method(Gogo* gogo, const Type* type, Expression* expr,\n     {\n       if (!ambig1.empty())\n \terror_at(location, \"%qs is ambiguous via %qs and %qs\",\n-\t\t Gogo::message_name(name).c_str(),\n-\t\t Gogo::message_name(ambig1).c_str(),\n-\t\t Gogo::message_name(ambig2).c_str());\n+\t\t Gogo::message_name(name).c_str(), ambig1.c_str(),\n+\t\t ambig2.c_str());\n       else if (found_pointer_method)\n \terror_at(location, \"method requires a pointer\");\n       else if (nt == NULL && st == NULL && it == NULL)\n@@ -7701,7 +7728,7 @@ Type::find_field_or_method(const Type* type,\n        pf != fields->end();\n        ++pf)\n     {\n-      if (pf->field_name() == name)\n+      if (pf->is_field_name(name))\n \t{\n \t  *is_method = false;\n \t  if (nt != NULL)\n@@ -7744,8 +7771,10 @@ Type::find_field_or_method(const Type* type,\n \t      // pass the ambiguity back to the caller.\n \t      if (found_level == 0 || sublevel <= found_level)\n \t\t{\n-\t\t  found_ambig1 = pf->field_name() + '.' + subambig1;\n-\t\t  found_ambig2 = pf->field_name() + '.' + subambig2;\n+\t\t  found_ambig1 = (Gogo::message_name(pf->field_name())\n+\t\t\t\t  + '.' + subambig1);\n+\t\t  found_ambig2 = (Gogo::message_name(pf->field_name())\n+\t\t\t\t  + '.' + subambig2);\n \t\t  found_level = sublevel;\n \t\t}\n \t    }\n@@ -7769,8 +7798,8 @@ Type::find_field_or_method(const Type* type,\n \t    {\n \t      // We found an ambiguity.\n \t      go_assert(found_parent != NULL);\n-\t      found_ambig1 = found_parent->field_name();\n-\t      found_ambig2 = pf->field_name();\n+\t      found_ambig1 = Gogo::message_name(found_parent->field_name());\n+\t      found_ambig2 = Gogo::message_name(pf->field_name());\n \t    }\n \t  else\n \t    {"}, {"sha": "f6c8642c86d659d95370912f688abe4ccd0876e1", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe0891751ac18c53d688349bd4aaf6a4ce17af7/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe0891751ac18c53d688349bd4aaf6a4ce17af7/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=ffe0891751ac18c53d688349bd4aaf6a4ce17af7", "patch": "@@ -1732,6 +1732,10 @@ class Struct_field\n   const std::string&\n   field_name() const;\n \n+  // Return whether this struct field is named NAME.\n+  bool\n+  is_field_name(const std::string& name) const;\n+\n   // The field type.\n   Type*\n   type() const"}]}