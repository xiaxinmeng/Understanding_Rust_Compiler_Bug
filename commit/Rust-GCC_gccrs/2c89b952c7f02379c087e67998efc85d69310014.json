{"sha": "2c89b952c7f02379c087e67998efc85d69310014", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM4OWI5NTJjN2YwMjM3OWMwODdlNjc5OThlZmM4NWQ2OTMxMDAxNA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-01-25T19:19:09Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-01-25T19:19:09Z"}, "message": "re PR tree-optimization/69196 (code size regression with jump threading at -O2)\n\n\tPR tree-optimization/69196\n\tPR tree-optimization/68398\n\t* tree-ssa-threadupdate.h (enum bb_dom_status): Moved here from\n\ttree-ssa-threadupdate.c.\n\t(determine_bb_domination_status): Prototype\n\t* tree-ssa-threadupdate.c (enum bb_dom_status): Remove\n\t(determine_bb_domination_status): No longer static.\n\t(valid_jump_thread_path): Remove code to detect characteristics\n\tof the jump thread path not associated with correctness.\n\t* tree-ssa-threadbackward.c (fsm_find_control_statment_thread_paths):\n\tCorrect test for thread path length.  Count PHIs for real operands as\n\tstatements that need to be copied.  Do not count ASSERT_EXPRs.\n\tLook at all the blocks in the thread path.  Compute and selectively\n\tfilter thread paths based on threading through the latch, threading\n\ta multiway branch or crossing a multiway branch.\n\n\tPR tree-optimization/69196\n\tPR tree-optimization/68398\n\t* gcc.dg/tree-ssa/pr66752-3.c: Update expected output\n\t* gcc.dg/tree-ssa/pr68198.c: Likewise.\n\nFrom-SVN: r232802", "tree": {"sha": "39cff29e36960823dc612da3db132b0db43ab126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39cff29e36960823dc612da3db132b0db43ab126"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c89b952c7f02379c087e67998efc85d69310014", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c89b952c7f02379c087e67998efc85d69310014", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c89b952c7f02379c087e67998efc85d69310014", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c89b952c7f02379c087e67998efc85d69310014/comments", "author": null, "committer": null, "parents": [{"sha": "2944621e2c2dd73c3162eb052d9250ea4e15fda6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2944621e2c2dd73c3162eb052d9250ea4e15fda6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2944621e2c2dd73c3162eb052d9250ea4e15fda6"}], "stats": {"total": 274, "additions": 169, "deletions": 105}, "files": [{"sha": "d9d59d77710d24c6794b9de39cd58653698dbf66", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c89b952c7f02379c087e67998efc85d69310014/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c89b952c7f02379c087e67998efc85d69310014/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c89b952c7f02379c087e67998efc85d69310014", "patch": "@@ -1,3 +1,21 @@\n+2016-01-25  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/69196\n+\tPR tree-optimization/68398\n+\t* tree-ssa-threadupdate.h (enum bb_dom_status): Moved here from\n+\ttree-ssa-threadupdate.c.\n+\t(determine_bb_domination_status): Prototype\n+\t* tree-ssa-threadupdate.c (enum bb_dom_status): Remove\n+\t(determine_bb_domination_status): No longer static.\n+\t(valid_jump_thread_path): Remove code to detect characteristics\n+\tof the jump thread path not associated with correctness.\n+\t* tree-ssa-threadbackward.c (fsm_find_control_statment_thread_paths):\n+\tCorrect test for thread path length.  Count PHIs for real operands as\n+\tstatements that need to be copied.  Do not count ASSERT_EXPRs.\n+\tLook at all the blocks in the thread path.  Compute and selectively\n+\tfilter thread paths based on threading through the latch, threading\n+\ta multiway branch or crossing a multiway branch.\n+\n 2016-01-25  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.c (rs6000_keep_leaf_when_profiled):  Add"}, {"sha": "7e5daa9f3d4629fc357567e1e0f9f789c414f29a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c89b952c7f02379c087e67998efc85d69310014/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c89b952c7f02379c087e67998efc85d69310014/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c89b952c7f02379c087e67998efc85d69310014", "patch": "@@ -1,3 +1,10 @@\n+2016-01-25  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/69196\n+\tPR tree-optimization/68398\n+\t* gcc.dg/tree-ssa/pr66752-3.c: Update expected output\n+\t* gcc.dg/tree-ssa/pr68198.c: Likewise.\n+\n 2016-01-25  David Edelsohn  <dje.gcc@gmail.com>\n \n \tPR target/69469"}, {"sha": "6eeaca50c5fdb8c70b8e99aa5e6c2d9f43cb3f38", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr66752-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c89b952c7f02379c087e67998efc85d69310014/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66752-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c89b952c7f02379c087e67998efc85d69310014/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66752-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66752-3.c?ref=2c89b952c7f02379c087e67998efc85d69310014", "patch": "@@ -33,9 +33,9 @@ foo (int N, int c, int b, int *a)\n }\n \n /* There are 3 FSM jump threading opportunities, one of which will\n-   get cancelled.  */\n-/* { dg-final { scan-tree-dump-times \"Registering FSM\" 3 \"vrp1\"} } */\n-/* { dg-final { scan-tree-dump-times \"Cancelling FSM\" 1 \"vrp1\"} } */\n+   get filtered.  */\n+/* { dg-final { scan-tree-dump-times \"Registering FSM\" 2 \"vrp1\"} } */\n+/* { dg-final { scan-tree-dump-times \"FSM would create irreducible loop\" 1 \"vrp1\"} } */\n \n /* There should be no assignments or references to FLAG.  */\n /* { dg-final { scan-tree-dump-not \"flag\" \"optimized\"} } */"}, {"sha": "227ffeb65652b9054c685ad7ddcd4f9052ee2463", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr68198.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c89b952c7f02379c087e67998efc85d69310014/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68198.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c89b952c7f02379c087e67998efc85d69310014/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68198.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68198.c?ref=2c89b952c7f02379c087e67998efc85d69310014", "patch": "@@ -38,6 +38,6 @@ c_finish_omp_clauses (tree clauses)\n }\n \n /* There are 3 FSM jump threading opportunities, two of which will\n-  get cancelled.  */\n-/* { dg-final { scan-tree-dump-times \"Registering FSM\" 3 \"vrp1\"} } */\n-/* { dg-final { scan-tree-dump-times \"Cancelling FSM\" 2 \"vrp1\"} } */\n+  get filtered out.  */\n+/* { dg-final { scan-tree-dump-times \"Registering FSM\" 1 \"vrp1\"} } */\n+/* { dg-final { scan-tree-dump-times \"FSM Thread through multiway branch without threading a multiway branch\" 2 \"vrp1\"} } */"}, {"sha": "131630e160334a4b29d8eceafe9ff184909c9203", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 124, "deletions": 29, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c89b952c7f02379c087e67998efc85d69310014/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c89b952c7f02379c087e67998efc85d69310014/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=2c89b952c7f02379c087e67998efc85d69310014", "patch": "@@ -223,8 +223,10 @@ fsm_find_control_statement_thread_paths (tree name,\n       if (TREE_CODE (arg) != INTEGER_CST)\n \tcontinue;\n \n+      /* Note BBI is not in the path yet, hence the +1 in the test below\n+\t to make sure BBI is accounted for in the path length test.  */\n       int path_length = path->length ();\n-      if (path_length > PARAM_VALUE (PARAM_MAX_FSM_THREAD_LENGTH))\n+      if (path_length + 1 > PARAM_VALUE (PARAM_MAX_FSM_THREAD_LENGTH))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n@@ -251,32 +253,113 @@ fsm_find_control_statement_thread_paths (tree name,\n       int j;\n       loop_p loop = (*path)[0]->loop_father;\n       bool path_crosses_loops = false;\n+      bool threaded_through_latch = false;\n+      bool multiway_branch_in_path = false;\n+      bool threaded_multiway_branch = false;\n \n       /* Count the number of instructions on the path: as these instructions\n \t will have to be duplicated, we will not record the path if there are\n \t too many instructions on the path.  Also check that all the blocks in\n \t the path belong to a single loop.  */\n-      for (j = 1; j < path_length - 1; j++)\n+      for (j = 0; j < path_length; j++)\n \t{\n \t  basic_block bb = (*path)[j];\n \n-\t  if (bb->loop_father != loop)\n+\t  /* Remember, blocks in the path are stored in opposite order\n+\t     in the PATH array.  The last entry in the array reprensents\n+\t     the block with an outgoing edge that we will redirect to the\n+\t     jump threading path.  Thus we don't care about that block's\n+\t     loop father, nor how many statements are in that block because\n+\t     it will not be copied or whether or not it ends in a multiway\n+\t     branch.  */\n+\t  if (j < path_length - 1)\n \t    {\n-\t      path_crosses_loops = true;\n-\t      break;\n+\t      if (bb->loop_father != loop)\n+\t\t{\n+\t\t  path_crosses_loops = true;\n+\t\t  break;\n+\t\t}\n+\n+\t      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t\t{\n+\t\t  gimple *stmt = gsi_stmt (gsi);\n+\t\t  /* Do not count empty statements and labels.  */\n+\t\t  if (gimple_code (stmt) != GIMPLE_NOP\n+\t\t      && gimple_code (stmt) != GIMPLE_LABEL\n+\t\t      && !(gimple_code (stmt) == GIMPLE_ASSIGN\n+\t\t\t   && gimple_assign_rhs_code (stmt) == ASSERT_EXPR)\n+\t\t      && !is_gimple_debug (stmt))\n+\t\t    ++n_insns;\n+\t\t}\n+\n+\t      gphi_iterator gsip;\n+\t      for (gsip = gsi_start_phis (bb);\n+\t\t   !gsi_end_p (gsip);\n+\t\t   gsi_next (&gsip))\n+\t\t{\n+\t\t  gphi *phi = gsip.phi ();\n+\t\t  tree dst = gimple_phi_result (phi);\n+\n+\t\t  /* We consider any non-virtual PHI as a statement since it\n+\t\t     count result in a constant assignment or copy\n+\t\t     operation.  */\n+\t\t  if (!virtual_operand_p (dst))\n+\t\t    ++n_insns;\n+\t\t}\n+\n+\t      /* We do not look at the block with the threaded branch\n+\t\t in this loop.  So if any block with a last statement that\n+\t\t is a GIMPLE_SWITCH or GIMPLE_GOTO is seen, then we have a\n+\t\t multiway branch on our path.\n+\n+\t\t The block in PATH[0] is special, it's the block were we're\n+\t\t going to be able to eliminate its branch.  */\n+\t      gimple *last = last_stmt (bb);\n+\t      if (last && (gimple_code (last) == GIMPLE_SWITCH\n+\t\t\t   || gimple_code (last) == GIMPLE_GOTO))\n+\t\t{\n+\t\t  if (j == 0)\n+\t\t    threaded_multiway_branch = true;\n+\t\t  else\n+\t\t    multiway_branch_in_path = true;\n+\t\t}\n \t    }\n \n-\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t    {\n-\t      gimple *stmt = gsi_stmt (gsi);\n-\t      /* Do not count empty statements and labels.  */\n-\t      if (gimple_code (stmt) != GIMPLE_NOP\n-\t\t  && gimple_code (stmt) != GIMPLE_LABEL\n-\t\t  && !is_gimple_debug (stmt))\n-\t\t++n_insns;\n-\t    }\n+\t  /* Note if we thread through the latch, we will want to include\n+\t     the last entry in the array when determining if we thread\n+\t     through the loop latch.  */\n+\t  if (loop->latch == bb)\n+\t    threaded_through_latch = true;\n+\t}\n+\n+      gimple *stmt = get_gimple_control_stmt ((*path)[0]);\n+      gcc_assert (stmt);\n+      /* We have found a constant value for ARG.  For GIMPLE_SWITCH\n+\t and GIMPLE_GOTO, we use it as-is.  However, for a GIMPLE_COND\n+\t we need to substitute, fold and simplify so we can determine\n+\t the edge taken out of the last block.  */\n+      if (gimple_code (stmt) == GIMPLE_COND)\n+\t{\n+\t  enum tree_code cond_code = gimple_cond_code (stmt);\n+\n+\t  /* We know the underyling format of the condition.  */\n+\t  arg = fold_binary (cond_code, boolean_type_node,\n+\t\t\t     arg, gimple_cond_rhs (stmt));\n \t}\n \n+      /* If this path threaded through the loop latch back into the\n+\t same loop and the destination does not dominate the loop\n+\t latch, then this thread would create an irreducible loop.\n+\n+\t We have to know the outgoing edge to figure this out.  */\n+      edge taken_edge = find_taken_edge ((*path)[0], arg);\n+      bool creates_irreducible_loop = false;\n+      if (threaded_through_latch\n+\t  && loop == taken_edge->dest->loop_father\n+\t  && (determine_bb_domination_status (loop, taken_edge->dest)\n+\t      == DOMST_NONDOMINATING))\n+\tcreates_irreducible_loop = true;\n+\n       if (path_crosses_loops)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -296,6 +379,33 @@ fsm_find_control_statement_thread_paths (tree name,\n \t  continue;\n \t}\n \n+      /* We avoid creating irreducible loops unless we thread through\n+\t a multiway branch, in which case we have deemed it worth losing other\n+\t loop optimizations later.  */\n+      if (!threaded_multiway_branch && creates_irreducible_loop)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"FSM would create irreducible loop without threading \"\n+\t\t     \"multiway branch.\\n\");\n+\t  path->pop ();\n+\t  continue;\n+\t}\n+\n+      /* When there is a multi-way branch on the path, then threading can\n+\t explode the CFG due to duplicating the edges for that multi-way\n+\t branch.  So like above, only allow a multi-way branch on the path\n+\t if we actually thread a multi-way branch.  */\n+      if (!threaded_multiway_branch && multiway_branch_in_path)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"FSM Thread through multiway branch without threading \"\n+\t\t     \"a multiway branch.\\n\");\n+\t  path->pop ();\n+\t  continue;\n+\t}\n+\n       vec<jump_thread_edge *> *jump_thread_path\n \t= new vec<jump_thread_edge *> ();\n \n@@ -309,22 +419,7 @@ fsm_find_control_statement_thread_paths (tree name,\n \t  jump_thread_path->safe_push (x);\n \t}\n \n-      gimple *stmt = get_gimple_control_stmt ((*path)[0]);\n-      gcc_assert (stmt);\n-      /* We have found a constant value for ARG.  For GIMPLE_SWITCH\n-\t and GIMPLE_GOTO, we use it as-is.  However, for a GIMPLE_COND\n-\t we need to substitute, fold and simplify.  */\n-      if (gimple_code (stmt) == GIMPLE_COND)\n-\t{\n-\t  enum tree_code cond_code = gimple_cond_code (stmt);\n-\n-\t  /* We know the underyling format of the condition.  */\n-\t  arg = fold_binary (cond_code, boolean_type_node,\n-\t\t\t     arg, gimple_cond_rhs (stmt));\n-\t}\n-\n       /* Add the edge taken when the control variable has value ARG.  */\n-      edge taken_edge = find_taken_edge ((*path)[0], arg);\n       jump_thread_edge *x\n \t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n       jump_thread_path->safe_push (x);"}, {"sha": "620948c254e35358ec6350e6e07139da2a44467d", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 1, "deletions": 70, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c89b952c7f02379c087e67998efc85d69310014/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c89b952c7f02379c087e67998efc85d69310014/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=2c89b952c7f02379c087e67998efc85d69310014", "patch": "@@ -1663,16 +1663,6 @@ dbds_continue_enumeration_p (const_basic_block bb, const void *stop)\n    returns the state.  */\n \n enum bb_dom_status\n-{\n-  /* BB does not dominate latch of the LOOP.  */\n-  DOMST_NONDOMINATING,\n-  /* The LOOP is broken (there is no path from the header to its latch.  */\n-  DOMST_LOOP_BROKEN,\n-  /* BB dominates the latch of the LOOP.  */\n-  DOMST_DOMINATING\n-};\n-\n-static enum bb_dom_status\n determine_bb_domination_status (struct loop *loop, basic_block bb)\n {\n   basic_block *bblocks;\n@@ -2389,73 +2379,14 @@ static bool\n valid_jump_thread_path (vec<jump_thread_edge *> *path)\n {\n   unsigned len = path->length ();\n-  bool threaded_multiway_branch = false;\n-  bool multiway_branch_in_path = false;\n-  bool threaded_through_latch = false;\n \n-  /* Check that the path is connected and see if there's a multi-way\n-     branch on the path and whether or not a multi-way branch\n-     is threaded.  */\n+  /* Check that the path is connected.  */\n   for (unsigned int j = 0; j < len - 1; j++)\n     {\n       edge e = (*path)[j]->e;\n-      struct loop *loop = e->dest->loop_father;\n-\n       if (e->dest != (*path)[j+1]->e->src)\n \treturn false;\n-\n-      /* If we're threading through the loop latch back into the\n-\t same loop and the destination does not dominate the loop\n-\t latch, then this thread would create an irreducible loop.  */\n-      if (loop->latch\n-\t  && loop_latch_edge (loop) == e\n-\t  && loop == path->last()->e->dest->loop_father\n-\t  && (determine_bb_domination_status (loop, path->last ()->e->dest)\n-\t       == DOMST_NONDOMINATING))\n-\tthreaded_through_latch = true;\n-\n-      gimple *last = last_stmt (e->dest);\n-      if (j == len - 2)\n-\tthreaded_multiway_branch\n-\t  |= (last && gimple_code (last) == GIMPLE_SWITCH);\n-      else\n-\tmultiway_branch_in_path\n-\t  |= (last && gimple_code (last) == GIMPLE_SWITCH);\n     }\n-\n-  /* If we are trying to thread through the loop latch to a block in the\n-     loop that does not dominate the loop latch, then that will create an\n-     irreducible loop.  We avoid that unless the jump thread has a multi-way\n-     branch, in which case we have deemed it worth losing other\n-     loop optimizations later if we can eliminate the multi-way branch.  */\n-  if (!threaded_multiway_branch && threaded_through_latch)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file,\n-\t\t   \"Thread through latch without threading a multiway \"\n-\t\t   \"branch.\\n\");\n-\t  dump_jump_thread_path (dump_file, *path, false);\n-\t}\n-      return false;\n-    }\n-\n-  /* When there is a multi-way branch on the path, then threading can\n-     explode the CFG due to duplicating the edges for that multi-way\n-     branch.  So like above, only allow a multi-way branch on the path\n-     if we actually thread a multi-way branch.  */\n-  if (!threaded_multiway_branch && multiway_branch_in_path)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file,\n-\t\t   \"Thread through multiway branch without threading \"\n-\t\t   \"a multiway branch.\\n\");\n-\t  dump_jump_thread_path (dump_file, *path, false);\n-\t}\n-      return false;\n-    }\n-\n   return true;\n }\n "}, {"sha": "fbad9f6bf34d639e801c5a1dd9ad1ee75d4be287", "filename": "gcc/tree-ssa-threadupdate.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c89b952c7f02379c087e67998efc85d69310014/gcc%2Ftree-ssa-threadupdate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c89b952c7f02379c087e67998efc85d69310014/gcc%2Ftree-ssa-threadupdate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.h?ref=2c89b952c7f02379c087e67998efc85d69310014", "patch": "@@ -47,4 +47,17 @@ extern void remove_jump_threads_including (edge);\n extern void delete_jump_thread_path (vec <class jump_thread_edge *> *);\n extern void remove_ctrl_stmt_and_useless_edges (basic_block, basic_block);\n extern void free_dom_edge_info (edge);\n+\n+enum bb_dom_status\n+{\n+  /* BB does not dominate latch of the LOOP.  */\n+  DOMST_NONDOMINATING,\n+  /* The LOOP is broken (there is no path from the header to its latch.  */\n+  DOMST_LOOP_BROKEN,\n+  /* BB dominates the latch of the LOOP.  */\n+  DOMST_DOMINATING\n+};\n+\n+enum bb_dom_status determine_bb_domination_status (struct loop *, basic_block);\n+\n #endif"}]}