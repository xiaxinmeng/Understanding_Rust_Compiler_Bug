{"sha": "11b4899f8af0a089ddbbdd10c2c23564f72c9cd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFiNDg5OWY4YWYwYTA4OWRkYmJkZDEwYzJjMjM1NjRmNzJjOWNkOA==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2007-06-06T10:22:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:22:41Z"}, "message": "checks.ads, checks.adb (Apply_Address_Clause_Check): Handle case in which the address-clause is applied to in-mode actuals (allowed...\n\n2007-04-20  Javier Miranda  <miranda@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* checks.ads, checks.adb (Apply_Address_Clause_Check): Handle case in\n\twhich the address-clause is applied to in-mode actuals (allowed by\n\t13.1(22)).\n\t(Apply_Discriminant_Check): Do not generate a check if the type is\n\tconstrained by a current instance.\n\t(Activate_Division_Check): New procedure\n\t(Activate_Overflow_Check): New procedure\n\t(Activate_Range_Check): New procedure\n\tCall these new Activate procedures instead of setting flags directly\n\t(Apply_Array_Size_Check): Removed, no longer needed.\n\tCode clean up: remove obsolete code related to GCC 2.\n\t(Get_E_Length): Protect against bomb in case scope is standard\n\t(Selected_Range_Checks): If the node to be checked is a conversion to\n\tan unconstrained array type, and the expression is a slice, use the\n\tbounds of the slice to construct the required constraint checks.\n\tImprove NOT NULL error messages\n\t(Apply_Constraint_Check): If the context is a null-excluding access\n\ttype, diagnose properly the literal null.\n\nFrom-SVN: r125388", "tree": {"sha": "7bee10dc496684afc4a3a6997b07500098601600", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bee10dc496684afc4a3a6997b07500098601600"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11b4899f8af0a089ddbbdd10c2c23564f72c9cd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11b4899f8af0a089ddbbdd10c2c23564f72c9cd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11b4899f8af0a089ddbbdd10c2c23564f72c9cd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11b4899f8af0a089ddbbdd10c2c23564f72c9cd8/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47eb2d8d9a68384b8e9dc8e7e617b363c94cc10f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47eb2d8d9a68384b8e9dc8e7e617b363c94cc10f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47eb2d8d9a68384b8e9dc8e7e617b363c94cc10f"}], "stats": {"total": 460, "additions": 149, "deletions": 311}, "files": [{"sha": "ca0549501c8ac83fe5382a861f19e26f54cbe094", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 122, "deletions": 305, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11b4899f8af0a089ddbbdd10c2c23564f72c9cd8/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11b4899f8af0a089ddbbdd10c2c23564f72c9cd8/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=11b4899f8af0a089ddbbdd10c2c23564f72c9cd8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,12 +29,14 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Exp_Ch2;  use Exp_Ch2;\n+with Exp_Ch11; use Exp_Ch11;\n with Exp_Pakd; use Exp_Pakd;\n with Exp_Util; use Exp_Util;\n with Elists;   use Elists;\n with Eval_Fat; use Eval_Fat;\n with Freeze;   use Freeze;\n with Lib;      use Lib;\n+with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n@@ -336,6 +338,36 @@ package body Checks is\n       end if;\n    end Accessibility_Checks_Suppressed;\n \n+   -----------------------------\n+   -- Activate_Division_Check --\n+   -----------------------------\n+\n+   procedure Activate_Division_Check (N : Node_Id) is\n+   begin\n+      Set_Do_Division_Check (N, True);\n+      Possible_Local_Raise (N, Standard_Constraint_Error);\n+   end Activate_Division_Check;\n+\n+   -----------------------------\n+   -- Activate_Overflow_Check --\n+   -----------------------------\n+\n+   procedure Activate_Overflow_Check (N : Node_Id) is\n+   begin\n+      Set_Do_Overflow_Check (N, True);\n+      Possible_Local_Raise (N, Standard_Constraint_Error);\n+   end Activate_Overflow_Check;\n+\n+   --------------------------\n+   -- Activate_Range_Check --\n+   --------------------------\n+\n+   procedure Activate_Range_Check (N : Node_Id) is\n+   begin\n+      Set_Do_Range_Check (N, True);\n+      Possible_Local_Raise (N, Standard_Constraint_Error);\n+   end Activate_Range_Check;\n+\n    ---------------------------------\n    -- Alignment_Checks_Suppressed --\n    ---------------------------------\n@@ -674,12 +706,17 @@ package body Checks is\n       else\n          --  If the original expression is a non-static constant, use the\n          --  name of the constant itself rather than duplicating its\n-         --  defining expression, which was extracted above..\n+         --  defining expression, which was extracted above.\n \n-         if Is_Entity_Name (Expression (AC))\n-           and then Ekind (Entity (Expression (AC))) = E_Constant\n-           and then\n-             Nkind (Parent (Entity (Expression (AC)))) = N_Object_Declaration\n+         --  Note: Expr is empty if the address-clause is applied to in-mode\n+         --  actuals (allowed by 13.1(22)).\n+\n+         if not Present (Expr)\n+           or else\n+             (Is_Entity_Name (Expression (AC))\n+               and then Ekind (Entity (Expression (AC))) = E_Constant\n+               and then Nkind (Parent (Entity (Expression (AC))))\n+                                 = N_Object_Declaration)\n          then\n             Expr := New_Copy_Tree (Expression (AC));\n          else\n@@ -738,8 +775,11 @@ package body Checks is\n    begin\n       --  Skip this if overflow checks are done in back end, or the overflow\n       --  flag is not set anyway, or we are not doing code expansion.\n+      --  Special case CLI target, where arithmetic overflow checks can be\n+      --  performed for integer and long_integer\n \n       if Backend_Overflow_Checks_On_Target\n+        or else (VM_Target = CLI_Target and then Siz >= Standard_Integer_Size)\n         or else not Do_Overflow_Check (N)\n         or else not Expander_Active\n       then\n@@ -858,266 +898,6 @@ package body Checks is\n          return;\n    end Apply_Arithmetic_Overflow_Check;\n \n-   ----------------------------\n-   -- Apply_Array_Size_Check --\n-   ----------------------------\n-\n-   --  The situation is as follows. In GNAT 3 (GCC 2.x), the size in bits is\n-   --  computed in 32 bits without an overflow check. That's a real problem for\n-   --  Ada. So what we do in GNAT 3 is to approximate the size of an array by\n-   --  manually multiplying the element size by the number of elements, and\n-   --  comparing that against the allowed limits.\n-\n-   --  In GNAT 5, the size in byte is still computed in 32 bits without an\n-   --  overflow check in the dynamic case, but the size in bits is computed in\n-   --  64 bits. We assume that's good enough, and we do not bother to generate\n-   --  any front end test.\n-\n-   procedure Apply_Array_Size_Check (N : Node_Id; Typ : Entity_Id) is\n-      Loc  : constant Source_Ptr := Sloc (N);\n-      Ctyp : constant Entity_Id  := Component_Type (Typ);\n-      Ent  : constant Entity_Id  := Defining_Identifier (N);\n-      Decl : Node_Id;\n-      Lo   : Node_Id;\n-      Hi   : Node_Id;\n-      Lob  : Uint;\n-      Hib  : Uint;\n-      Siz  : Uint;\n-      Xtyp : Entity_Id;\n-      Indx : Node_Id;\n-      Sizx : Node_Id;\n-      Code : Node_Id;\n-\n-      Static : Boolean := True;\n-      --  Set false if any index subtye bound is non-static\n-\n-      Umark : constant Uintp.Save_Mark := Uintp.Mark;\n-      --  We can throw away all the Uint computations here, since they are done\n-      --  only to generate boolean test results.\n-\n-      Check_Siz : Uint;\n-      --  Size to check against\n-\n-      function Is_Address_Or_Import (Decl : Node_Id) return Boolean;\n-      --  Determines if Decl is an address clause or Import/Interface pragma\n-      --  that references the defining identifier of the current declaration.\n-\n-      --------------------------\n-      -- Is_Address_Or_Import --\n-      --------------------------\n-\n-      function Is_Address_Or_Import (Decl : Node_Id) return Boolean is\n-      begin\n-         if Nkind (Decl) = N_At_Clause then\n-            return Chars (Identifier (Decl)) = Chars (Ent);\n-\n-         elsif Nkind (Decl) = N_Attribute_Definition_Clause then\n-            return\n-              Chars (Decl) = Name_Address\n-                and then\n-              Nkind (Name (Decl)) = N_Identifier\n-                and then\n-              Chars (Name (Decl)) = Chars (Ent);\n-\n-         elsif Nkind (Decl) = N_Pragma then\n-            if (Chars (Decl) = Name_Import\n-                 or else\n-                Chars (Decl) = Name_Interface)\n-              and then Present (Pragma_Argument_Associations (Decl))\n-            then\n-               declare\n-                  F : constant Node_Id :=\n-                        First (Pragma_Argument_Associations (Decl));\n-               begin\n-                  return\n-                    Present (F)\n-                      and then\n-                    Present (Next (F))\n-                      and then\n-                    Nkind (Expression (Next (F))) = N_Identifier\n-                      and then\n-                    Chars (Expression (Next (F))) = Chars (Ent);\n-               end;\n-\n-            else\n-               return False;\n-            end if;\n-\n-         else\n-            return False;\n-         end if;\n-      end Is_Address_Or_Import;\n-\n-   --  Start of processing for Apply_Array_Size_Check\n-\n-   begin\n-      --  Do size check on local arrays. We only need this in the GCC 2 case,\n-      --  since in GCC 3, we expect the back end to properly handle things.\n-      --  This routine can be removed when we baseline GNAT 3.\n-\n-      --  Shouldn't we remove GCC 2 crud at this stage ???\n-\n-      if Opt.GCC_Version >= 3 then\n-         return;\n-      end if;\n-\n-      --  No need for a check if not expanding\n-\n-      if not Expander_Active then\n-         return;\n-      end if;\n-\n-      --  No need for a check if checks are suppressed\n-\n-      if Storage_Checks_Suppressed (Typ) then\n-         return;\n-      end if;\n-\n-      --  It is pointless to insert this check inside an init proc, because\n-      --  that's too late, we have already built the object to be the right\n-      --  size, and if it's too large, too bad!\n-\n-      if Inside_Init_Proc then\n-         return;\n-      end if;\n-\n-      --  Look head for pragma interface/import or address clause applying to\n-      --  this entity. If found, we suppress the check entirely. For now we\n-      --  only look ahead 20 declarations to stop this becoming too slow Note\n-      --  that eventually this whole routine gets moved to gigi.\n-\n-      Decl := N;\n-      for Ctr in 1 .. 20 loop\n-         Next (Decl);\n-         exit when No (Decl);\n-\n-         if Is_Address_Or_Import (Decl) then\n-            return;\n-         end if;\n-      end loop;\n-\n-      --  First step is to calculate the maximum number of elements. For this\n-      --  calculation, we use the actual size of the subtype if it is static,\n-      --  and if a bound of a subtype is non-static, we go to the bound of the\n-      --  base type.\n-\n-      Siz := Uint_1;\n-      Indx := First_Index (Typ);\n-      while Present (Indx) loop\n-         Xtyp := Etype (Indx);\n-         Lo := Type_Low_Bound (Xtyp);\n-         Hi := Type_High_Bound (Xtyp);\n-\n-         --  If any bound raises constraint error, we will never get this far,\n-         --  so there is no need to generate any kind of check.\n-\n-         if Raises_Constraint_Error (Lo)\n-           or else\n-             Raises_Constraint_Error (Hi)\n-         then\n-            Uintp.Release (Umark);\n-            return;\n-         end if;\n-\n-         --  Otherwise get bounds values\n-\n-         if Is_Static_Expression (Lo) then\n-            Lob := Expr_Value (Lo);\n-         else\n-            Lob := Expr_Value (Type_Low_Bound (Base_Type (Xtyp)));\n-            Static := False;\n-         end if;\n-\n-         if Is_Static_Expression (Hi) then\n-            Hib := Expr_Value (Hi);\n-         else\n-            Hib := Expr_Value (Type_High_Bound (Base_Type (Xtyp)));\n-            Static := False;\n-         end if;\n-\n-         Siz := Siz *  UI_Max (Hib - Lob + 1, Uint_0);\n-         Next_Index (Indx);\n-      end loop;\n-\n-      --  Compute the limit against which we want to check. For subprograms,\n-      --  where the array will go on the stack, we use 8*2**24, which (in\n-      --  bits) is the size of a 16 megabyte array.\n-\n-      if Is_Subprogram (Scope (Ent)) then\n-         Check_Siz := Uint_2 ** 27;\n-      else\n-         Check_Siz := Uint_2 ** 31;\n-      end if;\n-\n-      --  If we have all static bounds and Siz is too large, then we know we\n-      --  have a storage error right now, so generate message\n-\n-      if Static and then Siz >= Check_Siz then\n-         Insert_Action (N,\n-           Make_Raise_Storage_Error (Loc,\n-             Reason => SE_Object_Too_Large));\n-         Error_Msg_N (\"?Storage_Error will be raised at run-time\", N);\n-         Uintp.Release (Umark);\n-         return;\n-      end if;\n-\n-      --  Case of component size known at compile time. If the array size is\n-      --  definitely in range, then we do not need a check.\n-\n-      if Known_Esize (Ctyp)\n-        and then Siz * Esize (Ctyp) < Check_Siz\n-      then\n-         Uintp.Release (Umark);\n-         return;\n-      end if;\n-\n-      --  Here if a dynamic check is required\n-\n-      --  What we do is to build an expression for the size of the array, which\n-      --  is computed as the 'Size of the array component, times the size of\n-      --  each dimension.\n-\n-      Uintp.Release (Umark);\n-\n-      Sizx :=\n-        Make_Attribute_Reference (Loc,\n-          Prefix =>         New_Occurrence_Of (Ctyp, Loc),\n-          Attribute_Name => Name_Size);\n-\n-      Indx := First_Index (Typ);\n-      for J in 1 .. Number_Dimensions (Typ) loop\n-         if Sloc (Etype (Indx)) = Sloc (N) then\n-            Ensure_Defined (Etype (Indx), N);\n-         end if;\n-\n-         Sizx :=\n-           Make_Op_Multiply (Loc,\n-             Left_Opnd  => Sizx,\n-             Right_Opnd =>\n-               Make_Attribute_Reference (Loc,\n-                 Prefix         => New_Occurrence_Of (Typ, Loc),\n-                 Attribute_Name => Name_Length,\n-                 Expressions    => New_List (\n-                   Make_Integer_Literal (Loc, J))));\n-         Next_Index (Indx);\n-      end loop;\n-\n-      --  Emit the check\n-\n-      Code :=\n-        Make_Raise_Storage_Error (Loc,\n-          Condition =>\n-            Make_Op_Ge (Loc,\n-              Left_Opnd  => Sizx,\n-              Right_Opnd =>\n-                Make_Integer_Literal (Loc,\n-                  Intval    => Check_Siz)),\n-          Reason => SE_Object_Too_Large);\n-\n-      Set_Size_Check_Code (Defining_Identifier (N), Code);\n-      Insert_Action (N, Code, Suppress => All_Checks);\n-   end Apply_Array_Size_Check;\n-\n    ----------------------------\n    -- Apply_Constraint_Check --\n    ----------------------------\n@@ -1174,7 +954,9 @@ package body Checks is\n          --  No checks necessary if expression statically null\n \n          if Nkind (N) = N_Null then\n-            null;\n+            if Can_Never_Be_Null (Typ) then\n+               Install_Null_Excluding_Check (N);\n+            end if;\n \n          --  No sliding possible on access to arrays\n \n@@ -1191,8 +973,14 @@ package body Checks is\n             Apply_Discriminant_Check (N, Typ);\n          end if;\n \n+         --  Apply the the 2005 Null_Excluding check. Note that we do not apply\n+         --  this check if the constraint node is illegal, as shown by having\n+         --  an error posted. This additional guard prevents cascaded errors\n+         --  and compiler aborts on illegal programs involving Ada 2005 checks.\n+\n          if Can_Never_Be_Null (Typ)\n            and then not Can_Never_Be_Null (Etype (N))\n+           and then not Error_Posted (N)\n          then\n             Install_Null_Excluding_Check (N);\n          end if;\n@@ -1439,6 +1227,18 @@ package body Checks is\n                ItemS := Node (DconS);\n                ItemT := Node (DconT);\n \n+               --  For a discriminated component type constrained by the\n+               --  current instance of an enclosing type, there is no\n+               --  applicable discriminant check.\n+\n+               if Nkind (ItemT) = N_Attribute_Reference\n+                 and then Is_Access_Type (Etype (ItemT))\n+                 and then Is_Entity_Name (Prefix (ItemT))\n+                 and then Is_Type (Entity (Prefix (ItemT)))\n+               then\n+                  return;\n+               end if;\n+\n                exit when\n                  not Is_OK_Static_Expression (ItemS)\n                    or else\n@@ -2166,15 +1966,14 @@ package body Checks is\n             --  We do this by replacing the if statement by a null statement\n \n             elsif Do_Static or else not Checks_On then\n+               Remove_Warning_Messages (R_Cno);\n                Rewrite (R_Cno, Make_Null_Statement (Loc));\n             end if;\n \n          else\n             Install_Static_Check (R_Cno, Loc);\n          end if;\n-\n       end loop;\n-\n    end Apply_Selected_Length_Checks;\n \n    ---------------------------------\n@@ -2258,6 +2057,7 @@ package body Checks is\n             --  We do this by replacing the if statement by a null statement\n \n             elsif Do_Static or else not Checks_On then\n+               Remove_Warning_Messages (R_Cno);\n                Rewrite (R_Cno, Make_Null_Statement (Loc));\n             end if;\n \n@@ -2351,7 +2151,7 @@ package body Checks is\n               and then not In_Subrange_Of (Expr_Type, Target_Base, Conv_OK)\n               and then not Float_To_Int\n             then\n-               Set_Do_Overflow_Check (N);\n+               Activate_Overflow_Check (N);\n             end if;\n \n             if not Range_Checks_Suppressed (Target_Type)\n@@ -2838,8 +2638,7 @@ package body Checks is\n \n          if not Is_Access_Type (Typ) then\n             Error_Msg_N\n-              (\"null-exclusion must be applied to an access type\",\n-               Error_Node);\n+              (\"`NOT NULL` allowed only for an access type\", Error_Node);\n \n          --  Enforce legality rule RM 3.10(14/1): A null exclusion can only\n          --  be applied to a [sub]type that does not exclude null already.\n@@ -2851,9 +2650,9 @@ package body Checks is\n \n            and then not Is_Itype (Typ)\n          then\n-            Error_Msg_N\n-              (\"null-exclusion cannot be applied to a null excluding type\",\n-               Error_Node);\n+            Error_Msg_NE\n+              (\"`NOT NULL` not allowed (& already excludes null)\",\n+               Error_Node, Typ);\n          end if;\n       end if;\n \n@@ -3498,7 +3297,7 @@ package body Checks is\n          w (\"Enable_Overflow_Check for node \", Int (N));\n          Write_Str (\"  Source location = \");\n          wl (Sloc (N));\n-         pg (N);\n+         pg (Union_Id (N));\n       end if;\n \n       --  Nothing to do if the range of the result is known OK. We skip this\n@@ -3549,7 +3348,7 @@ package body Checks is\n         or else not Is_Discrete_Type (Etype (N))\n         or else Num_Saved_Checks = Saved_Checks'Last\n       then\n-         Set_Do_Overflow_Check (N, True);\n+         Activate_Overflow_Check (N);\n \n          if Debug_Flag_CC then\n             w (\"Optimization off\");\n@@ -3584,7 +3383,7 @@ package body Checks is\n       --  If check is not of form to optimize, then set flag and we are done\n \n       if not OK then\n-         Set_Do_Overflow_Check (N, True);\n+         Activate_Overflow_Check (N);\n          return;\n       end if;\n \n@@ -3600,7 +3399,7 @@ package body Checks is\n \n       --  Here we will make a new entry for the new check\n \n-      Set_Do_Overflow_Check (N, True);\n+      Activate_Overflow_Check (N);\n       Num_Saved_Checks := Num_Saved_Checks + 1;\n       Saved_Checks (Num_Saved_Checks) :=\n         (Killed      => False,\n@@ -3625,7 +3424,7 @@ package body Checks is\n \n    exception\n       when others =>\n-         Set_Do_Overflow_Check (N, True);\n+         Activate_Overflow_Check (N);\n \n          if Debug_Flag_CC then\n             w (\"  exception occurred, overflow flag set\");\n@@ -3697,7 +3496,7 @@ package body Checks is\n          w (\"Enable_Range_Check for node \", Int (N));\n          Write_Str (\"  Source location = \");\n          wl (Sloc (N));\n-         pg (N);\n+         pg (Union_Id (N));\n       end if;\n \n       --  If not in optimizing mode, set flag and we are done. We are also done\n@@ -3712,7 +3511,7 @@ package body Checks is\n         or else not Is_Discrete_Type (Etype (N))\n         or else Num_Saved_Checks = Saved_Checks'Last\n       then\n-         Set_Do_Range_Check (N, True);\n+         Activate_Range_Check (N);\n \n          if Debug_Flag_CC then\n             w (\"Optimization off\");\n@@ -3752,7 +3551,7 @@ package body Checks is\n                --  may be redundant.\n \n                if not Is_Constrained (Atyp) then\n-                  Set_Do_Range_Check (N, True);\n+                  Activate_Range_Check (N);\n                   return;\n                end if;\n \n@@ -3762,7 +3561,7 @@ package body Checks is\n             elsif Nkind (Prefix (P)) = N_Explicit_Dereference\n               and then not Is_Constrained (Atyp)\n             then\n-               Set_Do_Range_Check (N, True);\n+               Activate_Range_Check (N);\n                return;\n             end if;\n \n@@ -3786,7 +3585,7 @@ package body Checks is\n             w (\"  target type not found, flag set\");\n          end if;\n \n-         Set_Do_Range_Check (N, True);\n+         Activate_Range_Check (N);\n          return;\n       end if;\n \n@@ -3821,7 +3620,7 @@ package body Checks is\n             w (\"  expression not of optimizable type, flag set\");\n          end if;\n \n-         Set_Do_Range_Check (N, True);\n+         Activate_Range_Check (N);\n          return;\n       end if;\n \n@@ -3837,7 +3636,7 @@ package body Checks is\n \n       --  Here we will make a new entry for the new check\n \n-      Set_Do_Range_Check (N, True);\n+      Activate_Range_Check (N);\n       Num_Saved_Checks := Num_Saved_Checks + 1;\n       Saved_Checks (Num_Saved_Checks) :=\n         (Killed      => False,\n@@ -3853,7 +3652,7 @@ package body Checks is\n          pid (Ofs);\n          w (\"  Check_Type = R\");\n          w (\"  Target_Type = \", Int (Ttyp));\n-         pg (Ttyp);\n+         pg (Union_Id (Ttyp));\n       end if;\n \n    --  If we get an exception, then something went wrong, probably because of\n@@ -3863,7 +3662,7 @@ package body Checks is\n \n    exception\n       when others =>\n-         Set_Do_Range_Check (N, True);\n+         Activate_Range_Check (N);\n \n          if Debug_Flag_CC then\n             w (\"  exception occurred, range flag set\");\n@@ -5077,6 +4876,9 @@ package body Checks is\n          --  operand is within its declared range (an assumption that validity\n          --  checking is all about NOT assuming!)\n \n+         --  Note: no need to worry about Possible_Local_Raise here, it will\n+         --  already have been called if original node has Do_Range_Check set.\n+\n          Set_Do_Range_Check (Exp, DRC);\n       end;\n    end Insert_Valid_Check;\n@@ -5508,7 +5310,7 @@ package body Checks is\n       ------------------\n \n       function Get_E_Length (E : Entity_Id; Indx : Nat) return Node_Id is\n-         Pt : constant Entity_Id := Scope (Scope (E));\n+         SE : constant Entity_Id := Scope (E);\n          N  : Node_Id;\n          E1 : Entity_Id := E;\n \n@@ -5529,12 +5331,12 @@ package body Checks is\n               Make_Integer_Literal (Loc,\n                 Intval => String_Literal_Length (E1));\n \n-         elsif Ekind (Pt) = E_Protected_Type\n-           and then Has_Discriminants (Pt)\n-           and then Has_Completion (Pt)\n+         elsif SE /= Standard_Standard\n+           and then Ekind (Scope (SE)) = E_Protected_Type\n+           and then Has_Discriminants (Scope (SE))\n+           and then Has_Completion (Scope (SE))\n            and then not Inside_Init_Proc\n          then\n-\n             --  If the type whose length is needed is a private component\n             --  constrained by a discriminant, we must expand the 'Length\n             --  attribute into an explicit computation, using the discriminal\n@@ -6756,37 +6558,52 @@ package body Checks is\n                declare\n                   Opnd_Index : Node_Id;\n                   Targ_Index : Node_Id;\n+                  Opnd_Range : Node_Id;\n \n                begin\n                   Opnd_Index := First_Index (Get_Actual_Subtype (Ck_Node));\n                   Targ_Index := First_Index (T_Typ);\n-                  while Opnd_Index /= Empty loop\n-                     if Nkind (Opnd_Index) = N_Range then\n+\n+                  while Present (Opnd_Index) loop\n+\n+                     --  If the index is a range, use its bounds. If it is an\n+                     --  entity (as will be the case if it is a named subtype\n+                     --  or an itype created for a slice) retrieve its range.\n+\n+                     if Is_Entity_Name (Opnd_Index)\n+                       and then Is_Type (Entity (Opnd_Index))\n+                     then\n+                        Opnd_Range := Scalar_Range (Entity (Opnd_Index));\n+                     else\n+                        Opnd_Range := Opnd_Index;\n+                     end if;\n+\n+                     if Nkind (Opnd_Range) = N_Range then\n                         if Is_In_Range\n-                             (Low_Bound (Opnd_Index), Etype (Targ_Index))\n+                             (Low_Bound (Opnd_Range), Etype (Targ_Index))\n                           and then\n                             Is_In_Range\n-                             (High_Bound (Opnd_Index), Etype (Targ_Index))\n+                             (High_Bound (Opnd_Range), Etype (Targ_Index))\n                         then\n                            null;\n \n                         --  If null range, no check needed\n \n                         elsif\n-                          Compile_Time_Known_Value (High_Bound (Opnd_Index))\n+                          Compile_Time_Known_Value (High_Bound (Opnd_Range))\n                             and then\n-                          Compile_Time_Known_Value (Low_Bound (Opnd_Index))\n+                          Compile_Time_Known_Value (Low_Bound (Opnd_Range))\n                             and then\n-                              Expr_Value (High_Bound (Opnd_Index)) <\n-                                  Expr_Value (Low_Bound (Opnd_Index))\n+                              Expr_Value (High_Bound (Opnd_Range)) <\n+                                  Expr_Value (Low_Bound (Opnd_Range))\n                         then\n                            null;\n \n                         elsif Is_Out_Of_Range\n-                                (Low_Bound (Opnd_Index), Etype (Targ_Index))\n+                                (Low_Bound (Opnd_Range), Etype (Targ_Index))\n                           or else\n                               Is_Out_Of_Range\n-                                (High_Bound (Opnd_Index), Etype (Targ_Index))\n+                                (High_Bound (Opnd_Range), Etype (Targ_Index))\n                         then\n                            Add_Check\n                              (Compile_Time_Constraint_Error\n@@ -6796,7 +6613,7 @@ package body Checks is\n                            Evolve_Or_Else\n                              (Cond,\n                               Discrete_Range_Cond\n-                                (Opnd_Index, Etype (Targ_Index)));\n+                                (Opnd_Range, Etype (Targ_Index)));\n                         end if;\n                      end if;\n "}, {"sha": "d981c3b5e9c4c77a164103873e1d0e1c23550492", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11b4899f8af0a089ddbbdd10c2c23564f72c9cd8/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11b4899f8af0a089ddbbdd10c2c23564f72c9cd8/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=11b4899f8af0a089ddbbdd10c2c23564f72c9cd8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -65,6 +65,32 @@ package Checks is\n    --  reason we insist on specifying Empty is to force the caller to think\n    --  about whether there is any relevant entity that should be checked.\n \n+   -------------------------------------------\n+   -- Procedures to Activate Checking Flags --\n+   -------------------------------------------\n+\n+   procedure Activate_Division_Check (N : Node_Id);\n+   pragma Inline (Activate_Division_Check);\n+   --  Sets Do_Division_Check flag in node N, and handles possible local raise.\n+   --  Always call this routine rather than calling Set_Do_Division_Check to\n+   --  set an explicit value of True, to ensure handling the local raise case.\n+\n+   procedure Activate_Overflow_Check (N : Node_Id);\n+   pragma Inline (Activate_Overflow_Check);\n+   --  Sets Do_Overflow_Check flag in node N, and handles possible local raise.\n+   --  Always call this routine rather than calling Set_Do_Overflow_Check to\n+   --  set an explicit value of True, to ensure handling the local raise case.\n+\n+   procedure Activate_Range_Check (N : Node_Id);\n+   pragma Inline (Activate_Range_Check);\n+   --  Sets Do_Range_Check flag in node N, and handles possible local raise\n+   --  Always call this routine rather than calling Set_Do_Range_Check to\n+   --  set an explicit value of True, to ensure handling the local raise case.\n+\n+   --------------------------------\n+   -- Procedures to Apply Checks --\n+   --------------------------------\n+\n    --  General note on following checks. These checks are always active if\n    --  Expander_Active and not Inside_A_Generic. They are inactive and have\n    --  no effect Inside_A_Generic. In the case where not Expander_Active\n@@ -90,11 +116,6 @@ package Checks is\n    --  a clear overlay situation that the size of the overlaying object is not\n    --  larger than the overlaid object.\n \n-   procedure Apply_Array_Size_Check (N : Node_Id; Typ : Entity_Id);\n-   --  N is the node for an object declaration that declares an object of\n-   --  array type Typ. This routine generates, if necessary, a check that\n-   --  the size of the array is not too large, raising Storage_Error if so.\n-\n    procedure Apply_Arithmetic_Overflow_Check (N : Node_Id);\n    --  Given a binary arithmetic operator (+ - *) expand a software integer\n    --  overflow check using range checks on a larger checking type or a call"}]}