{"sha": "9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRiZjFjM2U3ZjcwYmY5ZWNkZjhhNjEzNDBjOWY3NmZmMDQyNTFkMw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2010-01-26T10:30:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-01-26T10:30:04Z"}, "message": "par_sco.adb (Traverse_Declarations_Or_Statments): Implement new format of statement sequence SCO entries (one location/statement).\n\n2010-01-26  Robert Dewar  <dewar@adacore.com>\n\n\t* par_sco.adb (Traverse_Declarations_Or_Statments): Implement new\n\tformat of statement sequence SCO entries (one location/statement).\n\t* put_scos.adb (Put_SCOs): Implement new format of CS lines\n\t* scos.ads: Update comments.\n\t* sem_eval.adb: Minor reformatting.\n\nFrom-SVN: r156242", "tree": {"sha": "963edbdd97ee79d244b828be3c7396e9fe24f6ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/963edbdd97ee79d244b828be3c7396e9fe24f6ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3/comments", "author": null, "committer": null, "parents": [{"sha": "7ef50d41f3c2f5d1c4e28e4e296536aca9486888", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ef50d41f3c2f5d1c4e28e4e296536aca9486888", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ef50d41f3c2f5d1c4e28e4e296536aca9486888"}], "stats": {"total": 233, "additions": 180, "deletions": 53}, "files": [{"sha": "3914678a7e0b4c9dbd6160dc1a2ce2e0b437d1ad", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3", "patch": "@@ -1,3 +1,11 @@\n+2010-01-26  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par_sco.adb (Traverse_Declarations_Or_Statments): Implement new\n+\tformat of statement sequence SCO entries (one location/statement).\n+\t* put_scos.adb (Put_SCOs): Implement new format of CS lines\n+\t* scos.ads: Update comments.\n+\t* sem_eval.adb: Minor reformatting.\n+\n 2010-01-26  Robert Dewar  <dewar@adacore.com>\n \n \t* par_sco.ads, par_sco.adb (Set_Statement_Entry): New handling of exits"}, {"sha": "bee56cd540a5d4c0693df198868628f0a194f466", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 138, "deletions": 34, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3", "patch": "@@ -757,14 +757,41 @@ package body Par_SCO is\n \n    procedure Traverse_Declarations_Or_Statements (L : List_Id) is\n       N     : Node_Id;\n-      Start : Source_Ptr;\n       Dummy : Source_Ptr;\n-      Stop  : Source_Ptr;\n \n-      procedure Extend_Statement_Sequence (N : Node_Id);\n-      --  Extend the current statement sequence to encompass the node N\n-\n-      procedure Extend_Statement_Sequence (From : Node_Id; To : Node_Id);\n+      type SC_Entry is record\n+         From : Source_Ptr;\n+         To   : Source_Ptr;\n+         Typ  : Character;\n+      end record;\n+      --  Used to store a single entry in the following array\n+\n+      SC_Array : array (Nat range 1 .. 100) of SC_Entry;\n+      SC_Last  : Nat;\n+      --  Used to store statement components for a CS entry to be output\n+      --  as a result of the call to this procedure. SC_Last is the last\n+      --  entry stored, so the current statement sequence is represented\n+      --  by SC_Array (1 .. SC_Last). Extend_Statement_Sequence adds an\n+      --  entry to this array, and Set_Statement_Entry clears it, copying\n+      --  the entries to the main SCO output table. The reason that we do\n+      --  the temporary caching of results in this array is that we want\n+      --  the SCO table entries for a given CS line to be contiguous, and\n+      --  the processing may output intermediate entries such as decision\n+      --  entries. Note that the limit of 100 here is arbitrary, but does\n+      --  not cause any trouble, if we encounter more than 100 statements\n+      --  we simply break the current CS sequence at that point, which is\n+      --  harmless, since this is only used for back annotation and it is\n+      --  not critical that back annotation always work in all cases.\n+\n+      procedure Extend_Statement_Sequence (N : Node_Id; Typ : Character);\n+      --  Extend the current statement sequence to encompass the node N. Typ\n+      --  is the letter that identifies the type of statement/declaration that\n+      --  is being added to the sequence.\n+\n+      procedure Extend_Statement_Sequence\n+        (From : Node_Id;\n+         To   : Node_Id;\n+         Typ  : Character);\n       --  This version extends the current statement sequence with an entry\n       --  that starts with the first token of From, and ends with the last\n       --  token of To. It is used for example in a CASE statement to cover\n@@ -782,45 +809,80 @@ package body Par_SCO is\n       -------------------------\n \n       procedure Set_Statement_Entry is\n+         C1   : Character;\n+\n       begin\n-         if Start /= No_Location then\n-            Set_Table_Entry ('S', ' ', Start, Stop, False);\n-            Start := No_Location;\n-            Stop  := No_Location;\n+         if SC_Last /= 0 then\n+            for J in 1 .. SC_Last loop\n+               if J = 1 then\n+                  C1 := 'S';\n+               else\n+                  C1 := 's';\n+               end if;\n+\n+               Set_Table_Entry\n+                 (C1   => C1,\n+                  C2   => SC_Array (J).Typ,\n+                  From => SC_Array (J).From,\n+                  To   => SC_Array (J).To,\n+                  Last => (J = SC_Last));\n+            end loop;\n+\n+            SC_Last := 0;\n          end if;\n       end Set_Statement_Entry;\n \n       -------------------------------\n       -- Extend_Statement_Sequence --\n       -------------------------------\n \n-      procedure Extend_Statement_Sequence (N : Node_Id) is\n+      procedure Extend_Statement_Sequence (N : Node_Id; Typ : Character) is\n       begin\n-         if Start = No_Location then\n-            Sloc_Range (N, Start, Stop);\n+         --  Clear out statement sequence if array full\n+\n+         if SC_Last = SC_Array'Last then\n+            Set_Statement_Entry;\n          else\n-            Sloc_Range (N, Dummy, Stop);\n+            SC_Last := SC_Last + 1;\n          end if;\n+\n+         --  Record new entry\n+\n+         Sloc_Range\n+           (N, SC_Array (SC_Last).From, SC_Array (SC_Last).To);\n+         SC_Array (SC_Last).Typ := Typ;\n       end Extend_Statement_Sequence;\n \n-      procedure Extend_Statement_Sequence (From : Node_Id; To : Node_Id) is\n+      procedure Extend_Statement_Sequence\n+        (From : Node_Id;\n+         To   : Node_Id;\n+         Typ  : Character)\n+      is\n       begin\n-         if Start = No_Location then\n-            Sloc_Range (From, Start, Dummy);\n+         --  Clear out statement sequence if array full\n+\n+         if SC_Last = SC_Array'Last then\n+            Set_Statement_Entry;\n+         else\n+            SC_Last := SC_Last + 1;\n          end if;\n \n-         Sloc_Range (To, Dummy, Stop);\n+         --  Make new entry\n+\n+         Sloc_Range (From, SC_Array (SC_Last).From, Dummy);\n+         Sloc_Range (To, Dummy, SC_Array (SC_Last).To);\n+         SC_Array (SC_Last).Typ := Typ;\n       end Extend_Statement_Sequence;\n \n    --  Start of processing for Traverse_Declarations_Or_Statements\n \n    begin\n       if Is_Non_Empty_List (L) then\n-         N := First (L);\n-         Start := No_Location;\n+         SC_Last := 0;\n \n          --  Loop through statements or declarations\n \n+         N := First (L);\n          while Present (N) loop\n \n             --  Initialize or extend current statement sequence. Note that for\n@@ -875,7 +937,7 @@ package body Par_SCO is\n                --  any decisions in the exit statement expression.\n \n                when N_Exit_Statement =>\n-                  Extend_Statement_Sequence (N);\n+                  Extend_Statement_Sequence (N, ' ');\n                   Set_Statement_Entry;\n                   Process_Decisions (Condition (N), 'E');\n \n@@ -884,7 +946,7 @@ package body Par_SCO is\n \n                when N_Label =>\n                   Set_Statement_Entry;\n-                  Extend_Statement_Sequence (N);\n+                  Extend_Statement_Sequence (N, ' ');\n \n                --  Block statement, which breaks the current statement seqeunce\n                --  it probably does not need to, but for now it does.\n@@ -899,7 +961,7 @@ package body Par_SCO is\n                --  but we include the condition in the current sequence.\n \n                when N_If_Statement =>\n-                  Extend_Statement_Sequence (N, Condition (N));\n+                  Extend_Statement_Sequence (N, Condition (N), 'I');\n                   Set_Statement_Entry;\n                   Process_Decisions (Condition (N), 'I');\n                   Traverse_Declarations_Or_Statements (Then_Statements (N));\n@@ -923,8 +985,7 @@ package body Par_SCO is\n                --  but we include the expression in the current sequence.\n \n                when N_Case_Statement =>\n-\n-                  Extend_Statement_Sequence (N, Expression (N));\n+                  Extend_Statement_Sequence (N, Expression (N), 'C');\n                   Set_Statement_Entry;\n                   Process_Decisions (Expression (N), 'X');\n \n@@ -947,23 +1008,31 @@ package body Par_SCO is\n                when N_Requeue_Statement |\n                     N_Goto_Statement    |\n                     N_Raise_Statement   =>\n-                  Extend_Statement_Sequence (N);\n+                  Extend_Statement_Sequence (N, ' ');\n                   Set_Statement_Entry;\n \n                --  Simple return statement. which is an exit point, but we\n                --  have to process the return expression for decisions.\n \n                when N_Simple_Return_Statement =>\n-                  Extend_Statement_Sequence (N);\n+                  Extend_Statement_Sequence (N, ' ');\n                   Set_Statement_Entry;\n                   Process_Decisions (Expression (N), 'X');\n \n                --  Extended return statement\n \n                when N_Extended_Return_Statement =>\n-                  Set_Statement_Entry;\n-                  Traverse_Declarations_Or_Statements\n-                    (Return_Object_Declarations (N));\n+                  declare\n+                     Odecl : constant Node_Id :=\n+                               First (Return_Object_Declarations (N));\n+                  begin\n+                     if Present (Expression (Odecl)) then\n+                        Extend_Statement_Sequence\n+                          (N, Expression (Odecl), 'R');\n+                        Process_Decisions (Expression (Odecl), 'X');\n+                     end if;\n+                  end;\n+\n                   Traverse_Handled_Statement_Sequence\n                     (Handled_Statement_Sequence (N));\n \n@@ -974,9 +1043,8 @@ package body Par_SCO is\n \n                when N_Loop_Statement =>\n                   if Present (Iteration_Scheme (N)) then\n-                     Extend_Statement_Sequence (N, Iteration_Scheme (N));\n-                     Process_Decisions\n-                       (Condition (Iteration_Scheme (N)), 'W');\n+                     Extend_Statement_Sequence (N, Iteration_Scheme (N), 'F');\n+                     Process_Decisions (Condition (Iteration_Scheme (N)), 'W');\n                   end if;\n \n                   Set_Statement_Entry;\n@@ -986,7 +1054,43 @@ package body Par_SCO is\n                --  but do not terminate it, even if they have nested decisions.\n \n                when others =>\n-                  Extend_Statement_Sequence (N);\n+\n+                  --  Determine required type character code\n+\n+                  declare\n+                     Typ : Character;\n+\n+                  begin\n+                     case Nkind (N) is\n+                        when N_Full_Type_Declaration         |\n+                             N_Incomplete_Type_Declaration   |\n+                             N_Private_Type_Declaration      |\n+                             N_Private_Extension_Declaration =>\n+                           Typ := 't';\n+\n+                        when N_Subtype_Declaration           =>\n+                           Typ := 's';\n+\n+                        when N_Object_Declaration            =>\n+                           Typ := 'o';\n+\n+                        when N_Renaming_Declaration          =>\n+                           Typ := 'r';\n+\n+                        when N_Generic_Instantiation         =>\n+                           Typ := 'i';\n+\n+                        when N_Pragma                        =>\n+                           Typ := 'P';\n+\n+                        when others                          =>\n+                           Typ := ' ';\n+                     end case;\n+\n+                     Extend_Statement_Sequence (N, Typ);\n+                  end;\n+\n+                  --  Process any embedded decisions\n \n                   if Has_Decision (N) then\n                      Process_Decisions (N, 'X');"}, {"sha": "3be6d8b3b3a4df7c7802ac093d5bc7960acdb492", "filename": "gcc/ada/put_scos.adb", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3/gcc%2Fada%2Fput_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3/gcc%2Fada%2Fput_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_scos.adb?ref=9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3", "patch": "@@ -90,13 +90,30 @@ begin\n \n                case T.C1 is\n \n-                  --  Statements, exit\n+                  --  Statements\n \n-                  when 'S' | 'T' =>\n-                     Write_Info_Char (' ');\n-                     Output_Range (T);\n+                  when 'S' =>\n+                     loop\n+                        Write_Info_Char (' ');\n+\n+                        if SCO_Table.Table (Start).C2 /= ' ' then\n+                           Write_Info_Char (SCO_Table.Table (Start).C2);\n+                        end if;\n+\n+                        Output_Range (SCO_Table.Table (Start));\n+                        exit when SCO_Table.Table (Start).Last;\n+\n+                        Start := Start + 1;\n+                        pragma Assert (SCO_Table.Table (Start).C1 = 's');\n+                     end loop;\n+\n+                  --  Statement continuations should not occur since they\n+                  --  are supposed to have been handled in the loop above.\n+\n+                  when 's' =>\n+                     raise Program_Error;\n \n-                     --  Decision\n+                  --  Decision\n \n                   when 'I' | 'E' | 'W' | 'X' =>\n                      if T.C2 = ' ' then"}, {"sha": "e9c1d159215dd01be16443a4620250baeefc9634", "filename": "gcc/ada/scos.ads", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3/gcc%2Fada%2Fscos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3/gcc%2Fada%2Fscos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.ads?ref=9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3", "patch": "@@ -48,10 +48,6 @@ package SCOs is\n    --  Put_SCO reads the internal tables and generates text lines in the ALI\n    --  format.\n \n-   --  ??? The specification below for the SCO ALI format and the internal\n-   --  data structures have been modified, but the implementation has not been\n-   --  updated yet to reflect these specification changes.\n-\n    --------------------\n    -- SCO ALI Format --\n    --------------------\n@@ -150,8 +146,10 @@ package SCOs is\n    --      o  object declaration\n    --      r  renaming declaration\n    --      i  generic instantiation\n-   --      C  CASE statement\n-   --      F  FOR loop statement\n+   --      C  CASE statement (includes only the expression)\n+   --      F  FOR/WHILE loop statement (includes only the iteration scheme)\n+   --      I  IF statement (includes only the condition [in the RM sense, which\n+   --         is a decision in the SCO sense])\n    --      P  PRAGMA\n    --      R  extended RETURN statement\n \n@@ -279,9 +277,9 @@ package SCOs is\n \n    --    Statements\n    --      C1   = 'S' for entry point, 's' otherwise\n-   --      C2   = 't', 's', 'o', 'r', 'i', 'C', 'F', 'P', 'R', ' '\n+   --      C2   = 't', 's', 'o', 'r', 'i', 'C', 'F', 'I', 'P', 'R', ' '\n    --             (type/subtype/object/renaming/instantiation/\n-   --              CASE/FOR/PRAGMA/RETURN/other)\n+   --              CASE/FOR or WHILE/IF/PRAGMA/RETURN/other)\n    --      From = starting source location\n    --      To   = ending source location\n    --      Last = False for all but the last entry, True for last entry\n@@ -316,7 +314,7 @@ package SCOs is\n \n    --    Note: the sequence starting with a decision, and continuing with\n    --    operators and elements up to and including the first one labeled with\n-   --    Last=True, indicate the sequence to be output for a complex decision\n+   --    Last = True, indicate the sequence to be output for a complex decision\n    --    on a single CD decision line.\n \n    ----------------"}, {"sha": "c9054f387a88d667c987de2ebb182b00008ac143", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=9dbf1c3e7f70bf9ecdf8a61340c9f76ff04251d3", "patch": "@@ -1911,9 +1911,9 @@ package body Sem_Eval is\n                Atyp := Designated_Type (Atyp);\n             end if;\n \n-            --  If we have an array type (we should have but perhaps there\n-            --  are error cases where this is not the case), then see if we\n-            --  can do a constant evaluation of the array reference.\n+            --  If we have an array type (we should have but perhaps there are\n+            --  error cases where this is not the case), then see if we can do\n+            --  a constant evaluation of the array reference.\n \n             if Is_Array_Type (Atyp) and then Atyp /= Any_Composite then\n                if Ekind (Atyp) = E_String_Literal_Subtype then\n@@ -1983,8 +1983,8 @@ package body Sem_Eval is\n    --  Numeric literals are static (RM 4.9(1)), and have already been marked\n    --  as static by the analyzer. The reason we did it that early is to allow\n    --  the possibility of turning off the Is_Static_Expression flag after\n-   --  analysis, but before resolution, when integer literals are generated\n-   --  in the expander that do not correspond to static expressions.\n+   --  analysis, but before resolution, when integer literals are generated in\n+   --  the expander that do not correspond to static expressions.\n \n    procedure Eval_Integer_Literal (N : Node_Id) is\n       T : constant Entity_Id := Etype (N);"}]}