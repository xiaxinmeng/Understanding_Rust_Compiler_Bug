{"sha": "2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY5MmViN2QwZWExNzU3Y2JmMjUwOGYwMDFiZTllZTlmMmY4N2VkMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2004-06-17T22:35:55Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2004-06-17T22:35:55Z"}, "message": "re PR c++/16015 (xfailed g++.dg/ext/stmtexpr1.C)\n\n        PR c++/16015\n        * gimplify.c (gimplify_target_expr): Handle void initializer.\n        * expr.c (expand_expr_real_1) [TARGET_EXPR]: Likewise.\n        * doc/c-tree.texi (Expression trees): Update TARGET_EXPR\n        and AGGR_INIT_EXPR.\n        * cp/semantics.c (simplify_aggr_init_expr): Don't return the slot.\n        (finish_stmt_expr_expr): Update type after conversions.\n        (finish_stmt_expr): Wrap initializer in CLEANUP_POINT_EXPR.\n        Handle void initializer.\n        * cp/tree.c (build_cplus_new): Make AGGR_INIT_EXPRs void.\n\nFrom-SVN: r83320", "tree": {"sha": "2b8aade990ea880a225c9d2959e1a6b93ece70bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b8aade990ea880a225c9d2959e1a6b93ece70bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6ffbdf03e5d6863c7441dce9adab8fbf724bc8a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ffbdf03e5d6863c7441dce9adab8fbf724bc8a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ffbdf03e5d6863c7441dce9adab8fbf724bc8a4"}], "stats": {"total": 124, "additions": 80, "deletions": 44}, "files": [{"sha": "aadf8534b3631b4f8b622380309ff1452eaa31e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3", "patch": "@@ -1,3 +1,11 @@\n+2004-06-17  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/16015\n+\t* gimplify.c (gimplify_target_expr): Handle void initializer.\n+\t* expr.c (expand_expr_real_1) [TARGET_EXPR]: Likewise.\n+\t* doc/c-tree.texi (Expression trees): Update TARGET_EXPR\n+\tand AGGR_INIT_EXPR.\n+\n 2004-06-17  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (fold_relational_const): Use constant_boolean_node."}, {"sha": "b8f955c790d13f35228538b3c3a872109c9116ea", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3", "patch": "@@ -1,3 +1,12 @@\n+2004-06-17  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/16015\n+\t* semantics.c (simplify_aggr_init_expr): Don't return the slot.\n+\t(finish_stmt_expr_expr): Update type after conversions.\n+\t(finish_stmt_expr): Wrap initializer in CLEANUP_POINT_EXPR.\n+\tHandle void initializer.\n+\t* tree.c (build_cplus_new): Make AGGR_INIT_EXPRs void.\n+\n 2004-06-17  Geoffrey Keating  <geoffk@apple.com>\n \n \t* class.c (build_clone): Don't call defer_fn, let mark_used do it."}, {"sha": "ec5ef7a3c4147aba4faf8d6fb86173348d26255d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3", "patch": "@@ -1374,21 +1374,22 @@ tree\n finish_stmt_expr_expr (tree expr, tree stmt_expr)\n {\n   tree result = NULL_TREE;\n-  tree type = void_type_node;\n \n   if (expr)\n     {\n-      type = TREE_TYPE (expr);\n-      \n       if (!processing_template_decl && !VOID_TYPE_P (TREE_TYPE (expr)))\n \t{\n+\t  tree type = TREE_TYPE (expr);\n+\n \t  if (TREE_CODE (type) == ARRAY_TYPE\n \t      || TREE_CODE (type) == FUNCTION_TYPE)\n \t    expr = decay_conversion (expr);\n \n \t  expr = convert_from_reference (expr);\n \t  expr = require_complete_type (expr);\n \n+\t  type = TREE_TYPE (expr);\n+\n \t  /* Build a TARGET_EXPR for this aggregate.  finish_stmt_expr\n \t     will then pull it apart so the lifetime of the target is\n \t     within the scope of the expression containing this statement\n@@ -1489,25 +1490,40 @@ finish_stmt_expr (tree stmt_expr, bool has_no_scope)\n \t the target's init_expr as the final expression and then put\n \t the statement expression itself as the target's init\n \t expr. Finally, return the target expression.  */\n-      tree last_expr = EXPR_STMT_EXPR (result_stmt);\n-      \n-      my_friendly_assert (TREE_CODE (last_expr) == TARGET_EXPR, 20030729);\n-      *result_stmt_p = TREE_OPERAND (last_expr, 1);\n-\n-      if (TREE_CODE (result) == BIND_EXPR)\n+      tree init, target_expr = EXPR_STMT_EXPR (result_stmt);\n+      my_friendly_assert (TREE_CODE (target_expr) == TARGET_EXPR, 20030729);\n+\n+      /* The initializer will be void if the initialization is done by\n+\t AGGR_INIT_EXPR; propagate that out to the statement-expression as\n+\t a whole.  */\n+      init = TREE_OPERAND (target_expr, 1);\n+      type = TREE_TYPE (init);\n+\n+      if (stmts_are_full_exprs_p ())\n+\tinit = fold (build1 (CLEANUP_POINT_EXPR, type, init));\n+      *result_stmt_p = init;\n+\n+      if (VOID_TYPE_P (type))\n+\t/* No frobbing needed.  */;\n+      else if (TREE_CODE (result) == BIND_EXPR)\n \t{\n+\t  /* The BIND_EXPR created in finish_compound_stmt is void; if we're\n+\t     returning a value directly, give it the appropriate type.  */\n \t  if (VOID_TYPE_P (TREE_TYPE (result)))\n-\t    TREE_TYPE (result) = TREE_TYPE (last_expr);\n-\t  else if (same_type_p (TREE_TYPE (result), TREE_TYPE (last_expr)))\n+\t    TREE_TYPE (result) = type;\n+\t  else if (same_type_p (TREE_TYPE (result), type))\n \t    ;\n \t  else\n \t    abort ();\n \t}\n       else if (TREE_CODE (result) == STATEMENT_LIST)\n-\tresult = build (BIND_EXPR, TREE_TYPE (last_expr), NULL, result, NULL);\n+\t/* We need to wrap a STATEMENT_LIST in a BIND_EXPR so it can have a\n+\t   type other than void.  FIXME why can't we just return a value\n+\t   from STATEMENT_LIST?  */\n+\tresult = build3 (BIND_EXPR, type, NULL, result, NULL);\n \n-      TREE_OPERAND (last_expr, 1) = result;\n-      result = last_expr;\n+      TREE_OPERAND (target_expr, 1) = result;\n+      result = target_expr;\n     }\n \n   return result;\n@@ -2722,7 +2738,7 @@ simplify_aggr_init_expr (tree *tp)\n   tree fn = TREE_OPERAND (aggr_init_expr, 0);\n   tree args = TREE_OPERAND (aggr_init_expr, 1);\n   tree slot = TREE_OPERAND (aggr_init_expr, 2);\n-  tree type = TREE_TYPE (aggr_init_expr);\n+  tree type = TREE_TYPE (slot);\n \n   tree call_expr;\n   enum style_t { ctor, arg, pcc } style;\n@@ -2750,7 +2766,7 @@ simplify_aggr_init_expr (tree *tp)\n \targs = TREE_CHAIN (args);\n \n       cxx_mark_addressable (slot);\n-      addr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (slot)), slot);\n+      addr = build1 (ADDR_EXPR, build_pointer_type (type), slot);\n       if (style == arg)\n \t{\n \t  /* The return type might have different cv-quals from the slot.  */\n@@ -2785,10 +2801,6 @@ simplify_aggr_init_expr (tree *tp)\n       pop_deferring_access_checks ();\n     }\n \n-  /* We want to use the value of the initialized location as the\n-     result.  */\n-  call_expr = build (COMPOUND_EXPR, type, call_expr, slot);\n-\n   *tp = call_expr;\n }\n "}, {"sha": "61f751aa3f69b116495e4eb30a24f1476fe49506", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3", "patch": "@@ -302,7 +302,8 @@ build_cplus_new (tree type, tree init)\n      type, don't mess with AGGR_INIT_EXPR.  */\n   if (is_ctor || TREE_ADDRESSABLE (type))\n     {\n-      rval = build (AGGR_INIT_EXPR, type, fn, TREE_OPERAND (init, 1), slot);\n+      rval = build (AGGR_INIT_EXPR, void_type_node, fn,\n+\t\t    TREE_OPERAND (init, 1), slot);\n       TREE_SIDE_EFFECTS (rval) = 1;\n       AGGR_INIT_VIA_CTOR_P (rval) = is_ctor;\n     }"}, {"sha": "dae858a42924e9b97aa3ee4d123d36301b229844", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3", "patch": "@@ -2302,8 +2302,9 @@ depth-first preorder traversal of the expression tree.\n @item TARGET_EXPR\n A @code{TARGET_EXPR} represents a temporary object.  The first operand\n is a @code{VAR_DECL} for the temporary variable.  The second operand is\n-the initializer for the temporary.  The initializer is evaluated, and\n-copied (bitwise) into the temporary.\n+the initializer for the temporary.  The initializer is evaluated and,\n+if non-void, copied (bitwise) into the temporary.  If the initializer\n+is void, that means that it will perform the initialization itself.\n \n Often, a @code{TARGET_EXPR} occurs on the right-hand side of an\n assignment, or as the second operand to a comma-expression which is\n@@ -2329,21 +2330,20 @@ cleanups.\n @item AGGR_INIT_EXPR\n An @code{AGGR_INIT_EXPR} represents the initialization as the return\n value of a function call, or as the result of a constructor.  An\n-@code{AGGR_INIT_EXPR} will only appear as the second operand of a\n-@code{TARGET_EXPR}.  The first operand to the @code{AGGR_INIT_EXPR} is\n-the address of a function to call, just as in a @code{CALL_EXPR}.  The\n-second operand are the arguments to pass that function, as a\n-@code{TREE_LIST}, again in a manner similar to that of a\n-@code{CALL_EXPR}.  The value of the expression is that returned by the\n-function.\n+@code{AGGR_INIT_EXPR} will only appear as a full-expression, or as the\n+second operand of a @code{TARGET_EXPR}.  The first operand to the\n+@code{AGGR_INIT_EXPR} is the address of a function to call, just as in\n+a @code{CALL_EXPR}.  The second operand are the arguments to pass that\n+function, as a @code{TREE_LIST}, again in a manner similar to that of\n+a @code{CALL_EXPR}.\n \n If @code{AGGR_INIT_VIA_CTOR_P} holds of the @code{AGGR_INIT_EXPR}, then\n the initialization is via a constructor call.  The address of the third\n operand of the @code{AGGR_INIT_EXPR}, which is always a @code{VAR_DECL},\n is taken, and this value replaces the first argument in the argument\n-list.  In this case, the value of the expression is the @code{VAR_DECL}\n-given by the third operand to the @code{AGGR_INIT_EXPR}; constructors do\n-not return a value.\n+list.\n+\n+In either case, the expression is void.\n \n @item VTABLE_REF\n A @code{VTABLE_REF} indicates that the interior expression computes"}, {"sha": "651d6cd01423080e46e098162cedf4c0c2c6aa73", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3", "patch": "@@ -8862,7 +8862,12 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t/* Mark it as expanded.  */\n \tTREE_OPERAND (exp, 1) = NULL_TREE;\n \n-\tstore_expr (exp1, target, modifier == EXPAND_STACK_PARM ? 2 : 0);\n+\tif (VOID_TYPE_P (TREE_TYPE (exp1)))\n+\t  /* If the initializer is void, just expand it; it will initialize\n+\t     the object directly.  */\n+\t  expand_expr (exp1, const0_rtx, VOIDmode, 0);\n+\telse\n+\t  store_expr (exp1, target, modifier == EXPAND_STACK_PARM ? 2 : 0);\n \n \texpand_decl_cleanup_eh (NULL_TREE, cleanups, CLEANUP_EH_ONLY (exp));\n "}, {"sha": "45d5e6ec1a9c962df896482881bef5d3d99981dd", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3", "patch": "@@ -3018,7 +3018,8 @@ gimplify_target_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \tgimplify_bind_expr (&init, temp, pre_p);\n       if (init != temp)\n \t{\n-\t  init = build (MODIFY_EXPR, void_type_node, temp, init);\n+\t  if (! VOID_TYPE_P (TREE_TYPE (init)))\n+\t    init = build (MODIFY_EXPR, void_type_node, temp, init);\n \t  ret = gimplify_expr (&init, pre_p, post_p, is_gimple_stmt, fb_none);\n \t  if (ret == GS_ERROR)\n \t    return GS_ERROR;"}, {"sha": "fe9f3c3aa89cacfc92c6583f2d78aab099718139", "filename": "gcc/testsuite/g++.dg/ext/stmtexpr1.C", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fstmtexpr1.C?ref=2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3", "patch": "@@ -1,10 +1,10 @@\n-// { dg-do run { xfail *-*-* } }\n-// { dg-options \"\" }\n-\n // Copyright (C) 2003 Free Software Foundation, Inc.\n // Contributed by Nathan Sidwell 30 Jul 2003 <nathan@codesourcery.com>\n \n-// make statement expressions work properly\n+// make sure statement expressions work properly\n+\n+// { dg-do run }\n+// { dg-options \"\" }\n \n extern \"C\" int printf (char const *, ...);\n extern \"C\" void abort ();\n@@ -51,4 +51,3 @@ int main ()\n   ({A<14> a; a; });\n   Check (0, 0, 0, \"end\");\n }\n-"}, {"sha": "3e911113ee4a4690b8fa1b1d9d338ba616d832f6", "filename": "gcc/tree.def", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=2692eb7d0ea1757cbf2508f001be9ee9f2f87ed3", "patch": "@@ -435,10 +435,11 @@ DEFTREECODE (MODIFY_EXPR, \"modify_expr\", 'e', 2)\n DEFTREECODE (INIT_EXPR, \"init_expr\", 'e', 2)\n \n /* For TARGET_EXPR, operand 0 is the target of an initialization,\n-   operand 1 is the initializer for the target,\n-   and operand 2 is the cleanup for this node, if any.\n-   and operand 3 is the saved initializer after this node has been\n-   expanded once, this is so we can re-expand the tree later.  */\n+   operand 1 is the initializer for the target, which may be void\n+     if simplify expanding it initializes the target.\n+   operand 2 is the cleanup for this node, if any.\n+   operand 3 is the saved initializer after this node has been\n+   expanded once; this is so we can re-expand the tree later.  */\n DEFTREECODE (TARGET_EXPR, \"target_expr\", 'e', 4)\n \n /* Conditional expression ( ... ? ... : ...  in C)."}]}