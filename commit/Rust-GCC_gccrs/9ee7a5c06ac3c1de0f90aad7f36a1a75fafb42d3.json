{"sha": "9ee7a5c06ac3c1de0f90aad7f36a1a75fafb42d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVlN2E1YzA2YWMzYzFkZTBmOTBhYWQ3ZjM2YTFhNzVmYWZiNDJkMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2004-08-07T20:47:48Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2004-08-07T20:47:48Z"}, "message": "revert: gimplify.c (gimplify_call_expr): Make return in memory explicit.\n\nRevert:\n        * gimplify.c (gimplify_call_expr): Make return in memory explicit.\n        (gimplify_modify_expr_rhs): Likewise.\n\nFrom-SVN: r85676", "tree": {"sha": "a4eaadd11eb5c435da6a78fccf45eaa2961338d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4eaadd11eb5c435da6a78fccf45eaa2961338d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ee7a5c06ac3c1de0f90aad7f36a1a75fafb42d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee7a5c06ac3c1de0f90aad7f36a1a75fafb42d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ee7a5c06ac3c1de0f90aad7f36a1a75fafb42d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee7a5c06ac3c1de0f90aad7f36a1a75fafb42d3/comments", "author": null, "committer": null, "parents": [{"sha": "cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f"}], "stats": {"total": 65, "additions": 0, "deletions": 65}, "files": [{"sha": "db17d3e15a5b5e9f55c5b4677e3e4f5709dbf562", "filename": "gcc/ChangeLog", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee7a5c06ac3c1de0f90aad7f36a1a75fafb42d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee7a5c06ac3c1de0f90aad7f36a1a75fafb42d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ee7a5c06ac3c1de0f90aad7f36a1a75fafb42d3", "patch": "@@ -29,8 +29,6 @@\n \tDon't dereference a RESULT_DECL directly inside a RETURN_EXPR.\n \t(cp_genericize): Handle the RESULT_DECL.  Unset TREE_ADDRESSABLE.\n \n-\t* gimplify.c (gimplify_call_expr): Make return in memory explicit.\n-\t(gimplify_modify_expr_rhs): Likewise.\n \t* c-common.c (c_warn_unused_result): Check TREE_USED before\n \twarning about a CALL_EXPR with an unused value.\n "}, {"sha": "3675c8a942f8e917f2bca9e896735e765d6ac626", "filename": "gcc/gimplify.c", "status": "modified", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ee7a5c06ac3c1de0f90aad7f36a1a75fafb42d3/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ee7a5c06ac3c1de0f90aad7f36a1a75fafb42d3/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=9ee7a5c06ac3c1de0f90aad7f36a1a75fafb42d3", "patch": "@@ -1808,7 +1808,6 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n   tree decl;\n   tree arglist;\n   enum gimplify_status ret;\n-  tree slot;\n \n #if defined ENABLE_CHECKING\n   if (TREE_CODE (*expr_p) != CALL_EXPR)\n@@ -1871,19 +1870,6 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n   ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, NULL,\n \t\t       is_gimple_call_addr, fb_rvalue);\n \n-  /* Make the return slot explicit if it isn't already.  */\n-  if (aggregate_value_p (*expr_p, decl)\n-      && !CALL_EXPR_HAS_RETURN_SLOT_ADDR (*expr_p))\n-    {\n-      slot = create_tmp_var (TREE_TYPE (*expr_p), NULL);\n-      arglist = build_fold_addr_expr (slot);\n-      arglist = tree_cons (NULL_TREE, arglist, TREE_OPERAND (*expr_p, 1));\n-      TREE_OPERAND (*expr_p, 1) = arglist;\n-      CALL_EXPR_HAS_RETURN_SLOT_ADDR (*expr_p) = 1;\n-    }\n-  else\n-    slot = NULL_TREE;\n-\n   if (PUSH_ARGS_REVERSED)\n     TREE_OPERAND (*expr_p, 1) = nreverse (TREE_OPERAND (*expr_p, 1));\n   for (arglist = TREE_OPERAND (*expr_p, 1); arglist;\n@@ -1921,22 +1907,6 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n       && (call_expr_flags (*expr_p) & (ECF_CONST | ECF_PURE)))\n     TREE_SIDE_EFFECTS (*expr_p) = 0;\n \n-  /* If we have a return slot, use it in the containing expression.  */\n-  if (want_value && CALL_EXPR_HAS_RETURN_SLOT_ADDR (*expr_p))\n-    {\n-      /* Don't warn about an unused return value.  */\n-      TREE_USED (*expr_p) = 1;\n-\n-      if (slot == NULL_TREE)\n-\t{\n-\t  slot = TREE_OPERAND (*expr_p, 1);\n-\t  slot = TREE_VALUE (slot);\n-\t  slot = build_fold_indirect_ref (slot);\n-\t}\n-      append_to_statement_list (*expr_p, pre_p);\n-      *expr_p = slot;\n-    }\n-\n   return ret;\n }\n \n@@ -2739,39 +2709,6 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n \t  ret = GS_UNHANDLED;\n \tbreak;\n \n-      case CALL_EXPR:\n-\t/* Transform 'a = f();' to 'f(&a), a' if f returns in memory.  */\n-\tif (aggregate_value_p (*from_p, *from_p))\n-\t  {\n-\t    tree arg;\n-\t    if (CALL_EXPR_HAS_RETURN_SLOT_ADDR (*from_p))\n-\t      abort ();\n-\n-\t    ret = gimplify_expr (to_p, pre_p, post_p, is_gimple_lvalue,\n-\t\t\t\t fb_lvalue);\n-\t    if (ret == GS_ERROR)\n-\t      return ret;\n-\n-\t    arg = build_fold_addr_expr (*to_p);\n-\t    arg = tree_cons (NULL_TREE, arg, TREE_OPERAND (*from_p, 1));\n-\t    TREE_OPERAND (*from_p, 1) = arg;\n-\t    CALL_EXPR_HAS_RETURN_SLOT_ADDR (*from_p) = 1;\n-\t    /* Don't warn about an unused return value.  */\n-\t    TREE_USED (*from_p) = 1;\n-\n-\t    if (want_value)\n-\t      {\n-\t\tgimplify_and_add (*from_p, pre_p);\n-\t\t*expr_p = *to_p;\n-\t      }\n-\t    else\n-\t      *expr_p = *from_p;\n-\t    return GS_OK;\n-\t  }\n-\telse\n-\t  ret = GS_UNHANDLED;\n-\tbreak;\n-\n       default:\n \tret = GS_UNHANDLED;\n \tbreak;"}]}