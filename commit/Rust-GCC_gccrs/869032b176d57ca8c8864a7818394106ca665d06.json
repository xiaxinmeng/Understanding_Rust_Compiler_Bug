{"sha": "869032b176d57ca8c8864a7818394106ca665d06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY5MDMyYjE3NmQ1N2NhOGM4ODY0YTc4MTgzOTQxMDZjYTY2NWQwNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-04-15T10:09:08Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-04-15T10:09:08Z"}, "message": "re PR ipa/88936 (-fipa-pta breaks bash (incorrect optimisation of recursive static function))\n\n2019-04-15  Richard Biener  <rguenther@suse.de>\n\n\tPR ipa/88936\n\t* tree.h (auto_var_p): Declare.\n\t* tree.c (auto_var_p): New function, split out from ...\n\t(auto_var_in_fn_p): ... here.\n\t* tree-ssa-structalias.c (struct variable_info): Add shadow_var_uid\n\tmember.\n\t(new_var_info): Initialize it.\n\t(set_uids_in_ptset): Also set the shadow variable uid if required.\n\t(ipa_pta_execute): Postprocess points-to solutions assigning\n\tshadow variable uids for locals that may reach their containing\n\tfunction recursively.\n\t* tree-ssa-ccp.c (fold_builtin_alloca_with_align): Do not\n\tassert but instead check whether the points-to solution is\n\ta singleton.\n\n\t* gcc.dg/torture/pr88936-1.c: New testcase.\n\t* gcc.dg/torture/pr88936-2.c: Likewise.\n\t* gcc.dg/torture/pr88936-3.c: Likewise.\n\nFrom-SVN: r270366", "tree": {"sha": "091ea0a9c663a03956c774a6a3a164628d4e9f04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/091ea0a9c663a03956c774a6a3a164628d4e9f04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/869032b176d57ca8c8864a7818394106ca665d06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/869032b176d57ca8c8864a7818394106ca665d06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/869032b176d57ca8c8864a7818394106ca665d06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/869032b176d57ca8c8864a7818394106ca665d06/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "79a18702006d53bc378affcd5dd6c8df7883b58f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79a18702006d53bc378affcd5dd6c8df7883b58f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79a18702006d53bc378affcd5dd6c8df7883b58f"}], "stats": {"total": 210, "additions": 194, "deletions": 16}, "files": [{"sha": "8f8ec28afceaa6a9619de7bcadce99655957632c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/869032b176d57ca8c8864a7818394106ca665d06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/869032b176d57ca8c8864a7818394106ca665d06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=869032b176d57ca8c8864a7818394106ca665d06", "patch": "@@ -1,3 +1,20 @@\n+2019-04-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR ipa/88936\n+\t* tree.h (auto_var_p): Declare.\n+\t* tree.c (auto_var_p): New function, split out from ...\n+\t(auto_var_in_fn_p): ... here.\n+\t* tree-ssa-structalias.c (struct variable_info): Add shadow_var_uid\n+\tmember.\n+\t(new_var_info): Initialize it.\n+\t(set_uids_in_ptset): Also set the shadow variable uid if required.\n+\t(ipa_pta_execute): Postprocess points-to solutions assigning\n+\tshadow variable uids for locals that may reach their containing\n+\tfunction recursively.\n+\t* tree-ssa-ccp.c (fold_builtin_alloca_with_align): Do not\n+\tassert but instead check whether the points-to solution is\n+\ta singleton.\n+\n 2019-04-15  Martin Jambor  <mjambor@suse.cz>\n \n \tPR ipa/pr89693"}, {"sha": "5513a934f738162e9711219c22f368a7d47bc300", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=869032b176d57ca8c8864a7818394106ca665d06", "patch": "@@ -1,3 +1,10 @@\n+2019-04-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR ipa/88936\n+\t* gcc.dg/torture/pr88936-1.c: New testcase.\n+\t* gcc.dg/torture/pr88936-2.c: Likewise.\n+\t* gcc.dg/torture/pr88936-3.c: Likewise.\n+\n 2019-04-15  Martin Jambor  <mjambor@suse.cz>\n \n \tPR ipa/pr89693"}, {"sha": "20d6aa5435d14a2c0ed674d1197f43fc6b414f5a", "filename": "gcc/testsuite/gcc.dg/torture/pr88936-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr88936-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr88936-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr88936-1.c?ref=869032b176d57ca8c8864a7818394106ca665d06", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-fipa-pta\" } */\n+\n+static long bug (long depth, long * v)\n+{\n+  if (depth == 0)\n+    {\n+      *v = 0;\n+      return 1;\n+    }\n+\n+  long r = 1;\n+  long val = bug(depth - 1, &r);\n+  return 2 * r + val;\n+}\n+\n+static long ff (long depth)\n+{\n+  return bug(depth, (long*)0);\n+}\n+\n+int main()\n+{\n+  if (ff(1) != 1)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "7802e90fb26849f5ee97a247a9aa8eb4a532c322", "filename": "gcc/testsuite/gcc.dg/torture/pr88936-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr88936-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr88936-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr88936-2.c?ref=869032b176d57ca8c8864a7818394106ca665d06", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-fipa-pta\" } */\n+\n+static int *p;\n+void bar(int cnt)\n+{\n+  int i = 0;\n+  if (cnt == 0)\n+    {\n+      p = &i;\n+      bar (1);\n+      if (i != 1)\n+\t__builtin_abort ();\n+    }\n+  else if (cnt == 1)\n+    *p = 1;\n+}\n+int main()\n+{\n+  bar (0);\n+  return 0;\n+}"}, {"sha": "737b03e8ac07ef1fbcc934ea3ff7b6b25a93157f", "filename": "gcc/testsuite/gcc.dg/torture/pr88936-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr88936-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr88936-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr88936-3.c?ref=869032b176d57ca8c8864a7818394106ca665d06", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-fipa-pta\" } */\n+\n+static int *p;\n+void bar(int cnt)\n+{\n+  if (cnt == 0)\n+    {\n+      p = &cnt;\n+      bar (1);\n+      if (cnt != 1)\n+\t__builtin_abort ();\n+    }\n+  else if (cnt == 1)\n+    *p = 1;\n+}\n+int main()\n+{\n+  bar (0);\n+  return 0;\n+}"}, {"sha": "e6bcc216e7cb9bfaec204158f0b24d16fbc7c186", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=869032b176d57ca8c8864a7818394106ca665d06", "patch": "@@ -2170,23 +2170,26 @@ fold_builtin_alloca_with_align (gimple *stmt)\n   if (size > threshold)\n     return NULL_TREE;\n \n+  /* We have to be able to move points-to info.  We used to assert\n+     that we can but IPA PTA might end up with two UIDs here\n+     as it might need to handle more than one instance being\n+     live at the same time.  Instead of trying to detect this case\n+     (using the first UID would be OK) just give up for now.  */\n+  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (lhs);\n+  unsigned uid = 0;\n+  if (pi != NULL\n+      && !pi->pt.anything\n+      && !pt_solution_singleton_or_null_p (&pi->pt, &uid))\n+    return NULL_TREE;\n+\n   /* Declare array.  */\n   elem_type = build_nonstandard_integer_type (BITS_PER_UNIT, 1);\n   n_elem = size * 8 / BITS_PER_UNIT;\n   array_type = build_array_type_nelts (elem_type, n_elem);\n   var = create_tmp_var (array_type);\n   SET_DECL_ALIGN (var, TREE_INT_CST_LOW (gimple_call_arg (stmt, 1)));\n-  {\n-    struct ptr_info_def *pi = SSA_NAME_PTR_INFO (lhs);\n-    if (pi != NULL && !pi->pt.anything)\n-      {\n-\tbool singleton_p;\n-\tunsigned uid;\n-\tsingleton_p = pt_solution_singleton_or_null_p (&pi->pt, &uid);\n-\tgcc_assert (singleton_p);\n-\tSET_DECL_PT_UID (var, uid);\n-      }\n-  }\n+  if (uid != 0)\n+    SET_DECL_PT_UID (var, uid);\n \n   /* Fold alloca to the address of the array.  */\n   return fold_convert (TREE_TYPE (lhs), build_fold_addr_expr (var));"}, {"sha": "4a0b02e9b03ce464f8ab78cdc2e96d610282e8a0", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=869032b176d57ca8c8864a7818394106ca665d06", "patch": "@@ -299,6 +299,11 @@ struct variable_info\n   /* Full size of the base variable, in bits.  */\n   unsigned HOST_WIDE_INT fullsize;\n \n+  /* In IPA mode the shadow UID in case the variable needs to be duplicated in\n+     the final points-to solution because it reaches its containing\n+     function recursively.  Zero if none is needed.  */\n+  unsigned int shadow_var_uid;\n+\n   /* Name of this variable */\n   const char *name;\n \n@@ -397,6 +402,7 @@ new_var_info (tree t, const char *name, bool add_id)\n   ret->solution = BITMAP_ALLOC (&pta_obstack);\n   ret->oldsolution = NULL;\n   ret->next = 0;\n+  ret->shadow_var_uid = 0;\n   ret->head = ret->id;\n \n   stats.total_vars++;\n@@ -6452,6 +6458,16 @@ set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt,\n \t      && (TREE_STATIC (vi->decl) || DECL_EXTERNAL (vi->decl))\n \t      && ! decl_binds_to_current_def_p (vi->decl))\n \t    pt->vars_contains_interposable = true;\n+\n+\t  /* If this is a local variable we can have overlapping lifetime\n+\t     of different function invocations through recursion duplicate\n+\t     it with its shadow variable.  */\n+\t  if (in_ipa_mode\n+\t      && vi->shadow_var_uid != 0)\n+\t    {\n+\t      bitmap_set_bit (into, vi->shadow_var_uid);\n+\t      pt->vars_contains_nonlocal = true;\n+\t    }\n \t}\n \n       else if (TREE_CODE (vi->decl) == FUNCTION_DECL\n@@ -8076,6 +8092,62 @@ ipa_pta_execute (void)\n   /* From the constraints compute the points-to sets.  */\n   solve_constraints ();\n \n+  /* Now post-process solutions to handle locals from different\n+     runtime instantiations coming in through recursive invocations.  */\n+  unsigned shadow_var_cnt = 0;\n+  for (unsigned i = 1; i < varmap.length (); ++i)\n+    {\n+      varinfo_t fi = get_varinfo (i);\n+      if (fi->is_fn_info\n+\t  && fi->decl)\n+\t/* Automatic variables pointed to by their containing functions\n+\t   parameters need this treatment.  */\n+\tfor (varinfo_t ai = first_vi_for_offset (fi, fi_parm_base);\n+\t     ai; ai = vi_next (ai))\n+\t  {\n+\t    varinfo_t vi = get_varinfo (find (ai->id));\n+\t    bitmap_iterator bi;\n+\t    unsigned j;\n+\t    EXECUTE_IF_SET_IN_BITMAP (vi->solution, 0, j, bi)\n+\t      {\n+\t\tvarinfo_t pt = get_varinfo (j);\n+\t\tif (pt->shadow_var_uid == 0\n+\t\t    && pt->decl\n+\t\t    && auto_var_in_fn_p (pt->decl, fi->decl))\n+\t\t  {\n+\t\t    pt->shadow_var_uid = allocate_decl_uid ();\n+\t\t    shadow_var_cnt++;\n+\t\t  }\n+\t      }\n+\t  }\n+      /* As well as global variables which are another way of passing\n+         arguments to recursive invocations.  */\n+      else if (fi->is_global_var)\n+\t{\n+\t  for (varinfo_t ai = fi; ai; ai = vi_next (ai))\n+\t    {\n+\t      varinfo_t vi = get_varinfo (find (ai->id));\n+\t      bitmap_iterator bi;\n+\t      unsigned j;\n+\t      EXECUTE_IF_SET_IN_BITMAP (vi->solution, 0, j, bi)\n+\t\t{\n+\t\t  varinfo_t pt = get_varinfo (j);\n+\t\t  if (pt->shadow_var_uid == 0\n+\t\t      && pt->decl\n+\t\t      && auto_var_p (pt->decl))\n+\t\t    {\n+\t\t      pt->shadow_var_uid = allocate_decl_uid ();\n+\t\t      shadow_var_cnt++;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  if (shadow_var_cnt && dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Allocated %u shadow variables for locals \"\n+\t     \"maybe leaking into recursive invocations of their containing \"\n+\t     \"functions\\n\", shadow_var_cnt);\n+\n   /* Compute the global points-to sets for ESCAPED.\n      ???  Note that the computed escape set is not correct\n      for the whole unit as we fail to consider graph edges to"}, {"sha": "a483cc1f225b65550fb84fb10148a7ac026d71f3", "filename": "gcc/tree.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=869032b176d57ca8c8864a7818394106ca665d06", "patch": "@@ -9268,17 +9268,25 @@ get_type_static_bounds (const_tree type, mpz_t min, mpz_t max)\n     }\n }\n \n+/* Return true if VAR is an automatic variable.  */\n+\n+bool\n+auto_var_p (const_tree var)\n+{\n+  return ((((VAR_P (var) && ! DECL_EXTERNAL (var))\n+\t    || TREE_CODE (var) == PARM_DECL)\n+\t   && ! TREE_STATIC (var))\n+\t  || TREE_CODE (var) == RESULT_DECL);\n+}\n+\n /* Return true if VAR is an automatic variable defined in function FN.  */\n \n bool\n auto_var_in_fn_p (const_tree var, const_tree fn)\n {\n   return (DECL_P (var) && DECL_CONTEXT (var) == fn\n-\t  && ((((VAR_P (var) && ! DECL_EXTERNAL (var))\n-\t\t|| TREE_CODE (var) == PARM_DECL)\n-\t       && ! TREE_STATIC (var))\n-\t      || TREE_CODE (var) == LABEL_DECL\n-\t      || TREE_CODE (var) == RESULT_DECL));\n+\t  && (auto_var_p (var)\n+\t      || TREE_CODE (var) == LABEL_DECL));\n }\n \n /* Subprogram of following function.  Called by walk_tree."}, {"sha": "7c00c292eb9aa45aead60699ea39f815715b9d60", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/869032b176d57ca8c8864a7818394106ca665d06/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=869032b176d57ca8c8864a7818394106ca665d06", "patch": "@@ -4893,6 +4893,7 @@ extern bool stdarg_p (const_tree);\n extern bool prototype_p (const_tree);\n extern bool is_typedef_decl (const_tree x);\n extern bool typedef_variant_p (const_tree);\n+extern bool auto_var_p (const_tree);\n extern bool auto_var_in_fn_p (const_tree, const_tree);\n extern tree build_low_bits_mask (tree, unsigned);\n extern bool tree_nop_conversion_p (const_tree, const_tree);"}]}