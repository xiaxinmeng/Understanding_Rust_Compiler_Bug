{"sha": "a1281f45033c96419e4a6feab46fbd1f308d26ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTEyODFmNDUwMzNjOTY0MTllNGE2ZmVhYjQ2ZmJkMWYzMDhkMjZmZg==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2000-09-05T01:01:39Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-09-05T01:01:39Z"}, "message": "cp-tree.def (BOUND_TEMPLATE_TEMPLATE_PARM): New tree code.\n\n        * cp-tree.def (BOUND_TEMPLATE_TEMPLATE_PARM): New tree code.\n        (TEMPLATE_TEMPLATE_PARM): Adjust comment.\n        * cp-tree.h (TYPE_BINFO): Adjust comment.\n        (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO): Likewise.\n        (TEMPLATE_TYPE_PARM_INDEX): Likewise.\n        (IS_AGGR_TYPE): Use BOUND_TEMPLATE_TEMPLATE_PARM instead.\n        (TYPE_TEMPLATE_INFO): Likewise.\n        (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL): Likewise.\n        * class.c (push_nested_class): Likewise.\n        * decl.c (lookup_name_real): Likewise.\n        (grokdeclarator): Likewise.\n        (grok_op_properties): Likewise.\n        (xref_tag): Likewise.\n        (xref_basetypes): Likewise.\n        * decl2.c (constructor_name_full): Likewise.\n        (arg_assoc_template_arg): Add TEMPLATE_TEMPLATE_PARM case.\n        (arg_assoc_type): Use BOUND_TEMPLATE_TEMPLATE_PARM instead.\n        * error.c (dump_type): Split TEMPLATE_TEMPLATE_PARM case.\n        (dump_type_prefix): Add BOUND_TEMPLATE_TEMPLATE_PARM.\n        (dump_type_suffix): Likewise.\n        * init.c (is_aggr_type): Use BOUND_TEMPLATE_TEMPLATE_PARM\n        instead.\n        (get_aggr_from_typedef): Likewise.\n        * mangle.c (write_type): Split TEMPLATE_TEMPLATE_PARM case.\n        (write_expression): Add BOUND_TEMPLATE_TEMPLATE_PARM.\n        (write_template_parm): Likewise.\n        (write_template_template_parm): Check tree code instead of\n        using TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n        * method.c (build_overload_nested_name): Add\n        BOUND_TEMPLATE_TEMPLATE_PARM.\n        (process_overload_item): Split TEMPLATE_TEMPLATE_PARM case.\n        * parse.y (bad_parm): Add BOUND_TEMPLATE_TEMPLATE_PARM.\n        * pt.c (convert_template_argument): Check tree code instead of\n        using TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n        (for_each_template_parm_r): Split TEMPLATE_TEMPLATE_PARM case.\n        (for_each_template_parm): Adjust comment.\n        (tsubst): Add BOUND_TEMPLATE_TEMPLATE_PARM.  Reorganize.\n        (tsubst_copy): Add BOUND_TEMPLATE_TEMPLATE_PARM.\n        (unify): Add BOUND_TEMPLATE_TEMPLATE_PARM.  Reorganize.  Use\n        template_args_equal to compare template template parameter cases.\n        * ptree.c (print_lang_type): Add BOUND_TEMPLATE_TEMPLATE_PARM.\n        * search.c (lookup_field_1): Use BOUND_TEMPLATE_TEMPLATE_PARM\n        instead.\n        * tree.c (copy_template_template_parm): Decide whether to create\n        a TEMPLATE_TEMPLATE_PARM or BOUND_TEMPLATE_TEMPLATE_PARM node.\n        (walk_tree): Add BOUND_TEMPLATE_TEMPLATE_PARM.\n        (copy_tree_r): Likewise.\n        * typeck.c (comptypes): Likewise.  Check tree code instead of\n        using TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n\nFrom-SVN: r36149", "tree": {"sha": "74aa1d28311f0e2a44c3219022844b51d65b544a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74aa1d28311f0e2a44c3219022844b51d65b544a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1281f45033c96419e4a6feab46fbd1f308d26ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1281f45033c96419e4a6feab46fbd1f308d26ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1281f45033c96419e4a6feab46fbd1f308d26ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1281f45033c96419e4a6feab46fbd1f308d26ff/comments", "author": null, "committer": null, "parents": [{"sha": "31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31e0ab1f7699e3ed1bf4b47ec0701348d0dd7c2c"}], "stats": {"total": 410, "additions": 254, "deletions": 156}, "files": [{"sha": "d4388fc6de9f074f1009b9d8f0a4f800d9532d57", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -1,3 +1,55 @@\n+2000-09-04  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\t* cp-tree.def (BOUND_TEMPLATE_TEMPLATE_PARM): New tree code.\n+\t(TEMPLATE_TEMPLATE_PARM): Adjust comment.\n+\t* cp-tree.h (TYPE_BINFO): Adjust comment.\n+\t(TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO): Likewise.\n+\t(TEMPLATE_TYPE_PARM_INDEX): Likewise.\n+\t(IS_AGGR_TYPE): Use BOUND_TEMPLATE_TEMPLATE_PARM instead.\n+\t(TYPE_TEMPLATE_INFO): Likewise.\n+\t(TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL): Likewise.\n+\t* class.c (push_nested_class): Likewise.\n+\t* decl.c (lookup_name_real): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t(grok_op_properties): Likewise.\n+\t(xref_tag): Likewise.\n+\t(xref_basetypes): Likewise.\n+\t* decl2.c (constructor_name_full): Likewise.\n+\t(arg_assoc_template_arg): Add TEMPLATE_TEMPLATE_PARM case.\n+\t(arg_assoc_type): Use BOUND_TEMPLATE_TEMPLATE_PARM instead.\n+\t* error.c (dump_type): Split TEMPLATE_TEMPLATE_PARM case.\n+\t(dump_type_prefix): Add BOUND_TEMPLATE_TEMPLATE_PARM.\n+\t(dump_type_suffix): Likewise.\n+\t* init.c (is_aggr_type): Use BOUND_TEMPLATE_TEMPLATE_PARM\n+\tinstead.\n+\t(get_aggr_from_typedef): Likewise.\n+\t* mangle.c (write_type): Split TEMPLATE_TEMPLATE_PARM case.\n+\t(write_expression): Add BOUND_TEMPLATE_TEMPLATE_PARM.\n+\t(write_template_parm): Likewise.\n+\t(write_template_template_parm): Check tree code instead of\n+\tusing TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n+\t* method.c (build_overload_nested_name): Add \n+\tBOUND_TEMPLATE_TEMPLATE_PARM.\n+\t(process_overload_item): Split TEMPLATE_TEMPLATE_PARM case.\n+\t* parse.y (bad_parm): Add BOUND_TEMPLATE_TEMPLATE_PARM.\n+\t* pt.c (convert_template_argument): Check tree code instead of\n+\tusing TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n+\t(for_each_template_parm_r): Split TEMPLATE_TEMPLATE_PARM case.\n+\t(for_each_template_parm): Adjust comment.\n+\t(tsubst): Add BOUND_TEMPLATE_TEMPLATE_PARM.  Reorganize.\n+\t(tsubst_copy): Add BOUND_TEMPLATE_TEMPLATE_PARM.\n+\t(unify): Add BOUND_TEMPLATE_TEMPLATE_PARM.  Reorganize.  Use\n+\ttemplate_args_equal to compare template template parameter cases.\n+\t* ptree.c (print_lang_type): Add BOUND_TEMPLATE_TEMPLATE_PARM.\n+\t* search.c (lookup_field_1): Use BOUND_TEMPLATE_TEMPLATE_PARM\n+\tinstead.\n+\t* tree.c (copy_template_template_parm): Decide whether to create\n+\ta TEMPLATE_TEMPLATE_PARM or BOUND_TEMPLATE_TEMPLATE_PARM node.\n+\t(walk_tree): Add BOUND_TEMPLATE_TEMPLATE_PARM.\n+\t(copy_tree_r): Likewise.\n+\t* typeck.c (comptypes): Likewise.  Check tree code instead of\n+\tusing TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n+\n 2000-09-04  Mark Elbrecht  <snowball3@bigfoot.com>\n \n \t* decl.c (finish_function): Move the code for handling functions"}, {"sha": "d4c2ad2a436df18476fc542fa5b003bb92d744dd", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -5644,7 +5644,7 @@ push_nested_class (type, modify)\n       || TREE_CODE (type) == NAMESPACE_DECL\n       || ! IS_AGGR_TYPE (type)\n       || TREE_CODE (type) == TEMPLATE_TYPE_PARM\n-      || TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM)\n+      || TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM)\n     return;\n   \n   context = DECL_CONTEXT (TYPE_MAIN_DECL (type));"}, {"sha": "07ec1eae6299839649e707c6079b7e9e048e9844", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -144,14 +144,16 @@ DEFTREECODE (TEMPLATE_TYPE_PARM, \"template_type_parm\", 't', 0)\n    This parameter must be a type.  The TYPE_FIELDS value will be a \n    TEMPLATE_PARM_INDEX.\n \n-   If it is used without template arguments like TT in C<TT>, \n+   It is used without template arguments like TT in C<TT>, \n    TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO is NULL_TREE\n-   and TYPE_NAME is a TEMPLATE_DECL.\n+   and TYPE_NAME is a TEMPLATE_DECL.  */\n+DEFTREECODE (TEMPLATE_TEMPLATE_PARM, \"template_template_parm\", 't', 0)\n \n-   Otherwise it is used with bound template arguments like TT<int>.\n+/* Like TEMPLATE_TEMPLATE_PARM it is used with bound template arguments \n+   like TT<int>.\n    In this case, TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO contains the\n    template name and its bound arguments.  TYPE_NAME is a TYPE_DECL.  */\n-DEFTREECODE (TEMPLATE_TEMPLATE_PARM, \"template_template_parm\", 't', 0)\n+DEFTREECODE (BOUND_TEMPLATE_TEMPLATE_PARM, \"bound_template_template_parm\", 't', 0)\n \n /* A type designated by `typename T::t'.  TYPE_CONTEXT is `T',\n    TYPE_NAME is an IDENTIFIER_NODE for `t'.  If the type was named via"}, {"sha": "2da46defd2f5842aa344d9cc4a59795fdc93eead", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -112,8 +112,8 @@ Boston, MA 02111-1307, USA.  */\n    TYPE_BINFO\n      For an ENUMERAL_TYPE, this is ENUM_TEMPLATE_INFO.\n      For a TYPENAME_TYPE, this is TYPENAME_TYPE_FULLNAME.\n-     For a TEMPLATE_TEMPLATE_PARM, this is\n-     TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n+     For a TEMPLATE_TEMPLATE_PARM or BOUND_TEMPLATE_TEMPLATE_PARM, \n+     this is TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO.\n \n   BINFO_VIRTUALS\n      For a binfo, this is a TREE_LIST.  The BV_DELTA of each node\n@@ -1241,8 +1241,7 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n   (TREE_CODE (t) == TEMPLATE_TYPE_PARM\t\t\\\n    || TREE_CODE (t) == TYPENAME_TYPE\t\t\\\n    || TREE_CODE (t) == TYPEOF_TYPE\t\t\\\n-   || (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM\t\\\n-       && TYPE_TEMPLATE_INFO (t))\t\t\\\n+   || TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM\t\\\n    || TYPE_LANG_FLAG_5 (t))\n \n /* Set IS_AGGR_TYPE for T to VAL.  T must be a class, struct, or \n@@ -2298,14 +2297,14 @@ struct lang_decl\n    non-type template parameters.  */\n #define ENUM_TEMPLATE_INFO(NODE) (TYPE_BINFO (ENUMERAL_TYPE_CHECK (NODE)))\n \n-/* Template information for a template template parameter.  */\n+/* Template information for a bound template template parameter.  */\n #define TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO(NODE) (TYPE_BINFO (NODE))\n \n /* Template information for an ENUMERAL_, RECORD_, or UNION_TYPE.  */\n #define TYPE_TEMPLATE_INFO(NODE)\t\t\t\\\n   (TREE_CODE (NODE) == ENUMERAL_TYPE\t\t\t\\\n    ? ENUM_TEMPLATE_INFO (NODE) :\t\t\t\\\n-   (TREE_CODE (NODE) == TEMPLATE_TEMPLATE_PARM\t\t\\\n+   (TREE_CODE (NODE) == BOUND_TEMPLATE_TEMPLATE_PARM\t\\\n     ? TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (NODE) :\t\\\n     (TYPE_LANG_SPECIFIC (NODE)\t\t\t\t\\\n      ? CLASSTYPE_TEMPLATE_INFO (NODE)\t\t\t\\\n@@ -3716,8 +3715,8 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n #define TEMPLATE_PARM_ORIG_LEVEL(NODE) (TEMPLATE_PARM_INDEX_CAST (NODE)->orig_level)\n #define TEMPLATE_PARM_DECL(NODE) (TEMPLATE_PARM_INDEX_CAST (NODE)->decl)\n \n-/* These macros are for accessing the fields of TEMPLATE_TYPE_PARM \n-   and TEMPLATE_TEMPLATE_PARM nodes.  */\n+/* These macros are for accessing the fields of TEMPLATE_TYPE_PARM, \n+   TEMPLATE_TEMPLATE_PARM and BOUND_TEMPLATE_TEMPLATE_PARM nodes.  */\n #define TEMPLATE_TYPE_PARM_INDEX(NODE) (TYPE_FIELDS (NODE))\n #define TEMPLATE_TYPE_IDX(NODE) \\\n   (TEMPLATE_PARM_IDX (TEMPLATE_TYPE_PARM_INDEX (NODE)))\n@@ -3755,7 +3754,7 @@ enum tree_string_flags\n /* Returns the TEMPLATE_DECL associated to a TEMPLATE_TEMPLATE_PARM\n    node.  */\n #define TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL(NODE) \t\\\n-  (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (NODE) \t\t\\\n+  ((TREE_CODE (NODE) == BOUND_TEMPLATE_TEMPLATE_PARM)\t\\\n    ? TYPE_TI_TEMPLATE (NODE) \t\t\t\t\\\n    : TYPE_NAME (NODE))\n "}, {"sha": "664d125564411a25e8948fd29b81ff3b25ae4eb8", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -5925,7 +5925,7 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n \t    }\n \t  else if (! IS_AGGR_TYPE (type)\n \t\t   || TREE_CODE (type) == TEMPLATE_TYPE_PARM\n-\t\t   || TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM\n+\t\t   || TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM\n \t\t   || TREE_CODE (type) == TYPENAME_TYPE)\n \t    /* Someone else will give an error about this if needed.  */\n \t    val = NULL_TREE;\n@@ -9873,7 +9873,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t       && TREE_CODE (TREE_OPERAND (decl, 1)) == INDIRECT_REF)\n \t\tctype = cname;\n \t      else if (TREE_CODE (cname) == TEMPLATE_TYPE_PARM\n-\t\t       || TREE_CODE (cname) == TEMPLATE_TEMPLATE_PARM)\n+\t\t       || TREE_CODE (cname) == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t\t{\n \t\t  cp_error (\"`%T::%D' is not a valid declarator\", cname,\n \t\t\t    TREE_OPERAND (decl, 1));\n@@ -12461,7 +12461,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t\t    if (IS_AGGR_TYPE (arg)\n \t\t\t|| TREE_CODE (arg) == ENUMERAL_TYPE\n \t\t\t|| TREE_CODE (arg) == TEMPLATE_TYPE_PARM\n-\t\t\t|| TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n+\t\t\t|| TREE_CODE (arg) == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t\t      goto foundaggr;\n \t\t  }\n \t      cp_error\n@@ -12768,7 +12768,7 @@ xref_tag (code_type_node, name, globalize)\n     t = IDENTIFIER_TYPE_VALUE (name);\n \n   if (t && TREE_CODE (t) != code && TREE_CODE (t) != TEMPLATE_TYPE_PARM\n-      && TREE_CODE (t) != TEMPLATE_TEMPLATE_PARM)\n+      && TREE_CODE (t) != BOUND_TEMPLATE_TEMPLATE_PARM)\n     t = NULL_TREE;\n \n   if (! globalize)\n@@ -13014,7 +13014,7 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t  || (TREE_CODE (basetype) != RECORD_TYPE\n \t      && TREE_CODE (basetype) != TYPENAME_TYPE\n \t      && TREE_CODE (basetype) != TEMPLATE_TYPE_PARM\n-\t      && TREE_CODE (basetype) != TEMPLATE_TEMPLATE_PARM))\n+\t      && TREE_CODE (basetype) != BOUND_TEMPLATE_TEMPLATE_PARM))\n \t{\n \t  cp_error (\"base type `%T' fails to be a struct or class type\",\n \t\t    TREE_VALUE (binfo));"}, {"sha": "7fbd80c33ce5f7b7f74d3346208b29fb4b3267a3", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -2043,7 +2043,7 @@ constructor_name_full (thing)\n      tree thing;\n {\n   if (TREE_CODE (thing) == TEMPLATE_TYPE_PARM\n-      || TREE_CODE (thing) == TEMPLATE_TEMPLATE_PARM\n+      || TREE_CODE (thing) == BOUND_TEMPLATE_TEMPLATE_PARM\n       || TREE_CODE (thing) == TYPENAME_TYPE)\n     thing = TYPE_NAME (thing);\n   else if (IS_AGGR_TYPE_CODE (TREE_CODE (thing)))\n@@ -4860,7 +4860,9 @@ arg_assoc_template_arg (k, arg)\n      contribute to the set of associated namespaces.  ]  */\n \n   /* Consider first template template arguments.  */\n-  if (TREE_CODE (arg) == TEMPLATE_DECL)\n+  if (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n+    return 0;\n+  else if (TREE_CODE (arg) == TEMPLATE_DECL)\n     {\n       tree ctx = CP_DECL_CONTEXT (arg);\n \n@@ -4976,7 +4978,7 @@ arg_assoc_type (k, type)\n       /* Associate the return type. */\n       return arg_assoc_type (k, TREE_TYPE (type));\n     case TEMPLATE_TYPE_PARM:\n-    case TEMPLATE_TEMPLATE_PARM:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n       return 0;\n     case TYPENAME_TYPE:\n       return 0;"}, {"sha": "873f787de1450b1792fdd4959e6d710dcfb1b263", "filename": "gcc/cp/error.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -462,22 +462,21 @@ dump_type (t, flags)\n       break;\n \n     case TEMPLATE_TEMPLATE_PARM:\n-      if (!TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t))\n-\t{\n-\t  /* For parameters inside template signature. */\n-\t  if (TYPE_IDENTIFIER (t))\n-\t    OB_PUTID (TYPE_IDENTIFIER (t));\n-\t  else\n-\t    OB_PUTS (\"{anonymous template template parameter}\");\n-\t}\n+      /* For parameters inside template signature. */\n+      if (TYPE_IDENTIFIER (t))\n+\tOB_PUTID (TYPE_IDENTIFIER (t));\n       else\n-\t{\n-\t  tree args = TYPE_TI_ARGS (t);\n-\t  OB_PUTID (TYPE_IDENTIFIER (t));\n-\t  OB_PUTC ('<');\n-          dump_template_argument_list (args, flags);\n-\t  OB_END_TEMPLATE_ID ();\n-\t}\n+\tOB_PUTS (\"{anonymous template template parameter}\");\n+      break;\n+\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n+      {\n+\ttree args = TYPE_TI_ARGS (t);\n+\tOB_PUTID (TYPE_IDENTIFIER (t));\n+\tOB_PUTC ('<');\n+        dump_template_argument_list (args, flags);\n+\tOB_END_TEMPLATE_ID ();\n+      }\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n@@ -704,6 +703,7 @@ dump_type_prefix (t, flags)\n     case RECORD_TYPE:\n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_TEMPLATE_PARM:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n     case TREE_LIST:\n     case TYPE_DECL:\n     case TREE_VEC:"}, {"sha": "7d1e3b4b546243daddca2c3b343f16d86c6ab64a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -1390,7 +1390,7 @@ is_aggr_type (type, or_else)\n \n   if (! IS_AGGR_TYPE (type)\n       && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n-      && TREE_CODE (type) != TEMPLATE_TEMPLATE_PARM)\n+      && TREE_CODE (type) != BOUND_TEMPLATE_TEMPLATE_PARM)\n     {\n       if (or_else)\n \tcp_error (\"`%T' is not an aggregate type\", type);\n@@ -1422,7 +1422,7 @@ get_aggr_from_typedef (name, or_else)\n \n   if (! IS_AGGR_TYPE (type)\n       && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n-      && TREE_CODE (type) != TEMPLATE_TEMPLATE_PARM)\n+      && TREE_CODE (type) != BOUND_TEMPLATE_TEMPLATE_PARM)\n     {\n       if (or_else)\n \tcp_error (\"type `%T' is of non-aggregate type\", type);"}, {"sha": "da0448047405cbb6a66a5096c97d4470c926b72a", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -1319,9 +1319,12 @@ write_type (type)\n \n \tcase TEMPLATE_TEMPLATE_PARM:\n \t  write_template_template_param (type);\n-\t  if (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (type))\n-\t    write_template_args \n-\t      (TI_ARGS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (type)));\n+\t  break;\n+\n+\tcase BOUND_TEMPLATE_TEMPLATE_PARM:\n+\t  write_template_template_param (type);\n+\t  write_template_args \n+\t    (TI_ARGS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (type)));\n \t  break;\n \n \tcase OFFSET_TYPE:\n@@ -1624,7 +1627,8 @@ write_expression (expr)\n   /* Handle template parameters. */\n   if (code == TEMPLATE_TYPE_PARM \n       || code == TEMPLATE_TEMPLATE_PARM\n-      ||  code == TEMPLATE_PARM_INDEX)\n+      || code == BOUND_TEMPLATE_TEMPLATE_PARM\n+      || code == TEMPLATE_PARM_INDEX)\n     write_template_param (expr);\n   /* Handle literals.  */\n   else if (TREE_CODE_CLASS (code) == 'c')\n@@ -1863,7 +1867,8 @@ write_pointer_to_member_type (type)\n }\n \n /* Non-terminal <template-param>.  PARM is a TEMPLATE_TYPE_PARM,\n-   TEMPLATE_TEMPLATE_PARM, or a TEMPLATE_PARM_INDEX.\n+   TEMPLATE_TEMPLATE_PARM, BOUND_TEMPLATE_TEMPLATE_PARM or a\n+   TEMPLATE_PARM_INDEX.\n \n      <template-param> ::= T </parameter/ number> _  */\n \n@@ -1879,6 +1884,7 @@ write_template_param (parm)\n     {\n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_TEMPLATE_PARM:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n       parm_index = TEMPLATE_TYPE_IDX (parm);\n       break;\n \n@@ -1911,7 +1917,7 @@ write_template_template_param (parm)\n   /* PARM, a TEMPLATE_TEMPLATE_PARM, is an instantiation of the\n      template template parameter.  The substitution candidate here is\n      only the template.  */\n-  if (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (parm))\n+  if (TREE_CODE (parm) == BOUND_TEMPLATE_TEMPLATE_PARM)\n     {\n       template \n \t= TI_TEMPLATE (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (parm));"}, {"sha": "1e5c4e36070092663678c2a09cfd098a928918cb", "filename": "gcc/cp/method.c", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -446,7 +446,8 @@ build_overload_nested_name (decl)\n     /* For a template type parameter, we want to output an 'Xn'\n        rather than 'T' or some such. */\n     if (TREE_CODE (context) == TEMPLATE_TYPE_PARM\n-        || TREE_CODE (context) == TEMPLATE_TEMPLATE_PARM)\n+        || TREE_CODE (context) == TEMPLATE_TEMPLATE_PARM\n+        || TREE_CODE (context) == BOUND_TEMPLATE_TEMPLATE_PARM)\n       build_mangled_name_for_type (context);\n     else\n     {\n@@ -1512,26 +1513,23 @@ process_overload_item (parmtype, extra_Gcode)\n       OB_PUTC ('?');\n       break;\n \n-    case TEMPLATE_TEMPLATE_PARM:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n       /* Find and output the original template parameter \n          declaration. */\n-      if (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (parmtype))\n-        {\n-\t  build_mangled_template_parm_index (\"tzX\",\n-\t\t\t\t\t     TEMPLATE_TYPE_PARM_INDEX \n-\t\t\t\t\t     (parmtype));\n-          build_template_parm_names\n-            (DECL_INNERMOST_TEMPLATE_PARMS (TYPE_TI_TEMPLATE (parmtype)),\n-\t     TYPE_TI_ARGS (parmtype));\n-        }\n-      else\n-        {\n-\t  build_mangled_template_parm_index (\"ZzX\",\n-\t\t\t\t\t     TEMPLATE_TYPE_PARM_INDEX \n-\t\t\t\t\t     (parmtype));\n-          build_template_template_parm_names\n-            (DECL_INNERMOST_TEMPLATE_PARMS (TYPE_STUB_DECL (parmtype)));\n-        }\n+      build_mangled_template_parm_index (\"tzX\",\n+\t\t\t\t\t TEMPLATE_TYPE_PARM_INDEX \n+\t\t\t\t\t (parmtype));\n+      build_template_parm_names\n+\t(DECL_INNERMOST_TEMPLATE_PARMS (TYPE_TI_TEMPLATE (parmtype)),\n+\t TYPE_TI_ARGS (parmtype));\n+      break;\n+\n+    case TEMPLATE_TEMPLATE_PARM:\n+      build_mangled_template_parm_index (\"ZzX\",\n+\t\t\t\t\t TEMPLATE_TYPE_PARM_INDEX \n+\t\t\t\t\t (parmtype));\n+      build_template_template_parm_names\n+\t(DECL_INNERMOST_TEMPLATE_PARMS (TYPE_STUB_DECL (parmtype)));\n       break;\n \n     case TEMPLATE_TYPE_PARM:"}, {"sha": "eb6a01a6b1ad8a6c20bf9c9b13faf08611a99aa7", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -3713,7 +3713,7 @@ bad_parm:\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  if (TREE_CODE ($$) == SCOPE_REF\n \t\t      && (TREE_CODE (TREE_OPERAND ($$, 0)) == TEMPLATE_TYPE_PARM\n-\t\t\t  || TREE_CODE (TREE_OPERAND ($$, 0)) == TEMPLATE_TEMPLATE_PARM))\n+\t\t\t  || TREE_CODE (TREE_OPERAND ($$, 0)) == BOUND_TEMPLATE_TEMPLATE_PARM))\n \t\t    cp_error (\"  perhaps you want `typename %E' to make it a type\", $$);\n \t\t  $$ = build_tree_list (integer_type_node, $$);\n \t\t}"}, {"sha": "cddf0f9ebd0a21936d1bfe661860cdd60f553feb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 91, "deletions": 84, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -3206,8 +3206,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n   is_tmpl_type \n     = ((TREE_CODE (arg) == TEMPLATE_DECL\n \t&& TREE_CODE (DECL_TEMPLATE_RESULT (arg)) == TYPE_DECL)\n-       || (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n-\t   && !TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (arg))\n+       || TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n        || (TREE_CODE (arg) == RECORD_TYPE\n \t   && CLASSTYPE_TEMPLATE_INFO (arg)\n \t   && TREE_CODE (TYPE_NAME (arg)) == TYPE_DECL\n@@ -4187,13 +4186,13 @@ for_each_template_parm_r (tp, walk_subtrees, d)\n \treturn error_mark_node;\n       break;\n \n-    case TEMPLATE_TEMPLATE_PARM:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n       /* Record template parameters such as `T' inside `TT<T>'.  */\n-      if (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t)\n-\t  && for_each_template_parm (TYPE_TI_ARGS (t), fn, data))\n+      if (for_each_template_parm (TYPE_TI_ARGS (t), fn, data))\n \treturn error_mark_node;\n       /* Fall through.  */\n \n+    case TEMPLATE_TEMPLATE_PARM:\n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_PARM_INDEX:\n       if (fn && (*fn)(t, data))\n@@ -4255,8 +4254,9 @@ for_each_template_parm_r (tp, walk_subtrees, d)\n   return NULL_TREE;\n }\n \n-/* For each TEMPLATE_TYPE_PARM, TEMPLATE_TEMPLATE_PARM, or\n-   TEMPLATE_PARM_INDEX in T, call FN with the parameter and the DATA.\n+/* For each TEMPLATE_TYPE_PARM, TEMPLATE_TEMPLATE_PARM, \n+   BOUND_TEMPLATE_TEMPLATE_PARM or TEMPLATE_PARM_INDEX in T, \n+   call FN with the parameter and the DATA.\n    If FN returns non-zero, the iteration is terminated, and\n    for_each_template_parm returns 1.  Otherwise, the iteration\n    continues.  If FN never returns a non-zero value, the value\n@@ -6222,6 +6222,7 @@ tsubst (t, args, complain, in_decl)\n \n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_TEMPLATE_PARM:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n     case TEMPLATE_PARM_INDEX:\n       {\n \tint idx;\n@@ -6231,7 +6232,8 @@ tsubst (t, args, complain, in_decl)\n \tr = NULL_TREE;\n \n \tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n-\t    || TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n+\t    || TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM\n+\t    || TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t  {\n \t    idx = TEMPLATE_TYPE_IDX (t);\n \t    level = TEMPLATE_TYPE_LEVEL (t);\n@@ -6261,38 +6263,33 @@ tsubst (t, args, complain, in_decl)\n \t\t      (arg, CP_TYPE_QUALS (arg) | CP_TYPE_QUALS (t),\n \t\t       complain);\n \t\t  }\n-\t\telse if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n+\t\telse if (TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t\t  {\n-\t\t    if (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t))\n-\t\t      {\n-\t\t\t/* We are processing a type constructed from\n-\t\t\t   a template template parameter */\n-\t\t\ttree argvec = tsubst (TYPE_TI_ARGS (t),\n-\t\t\t\t\t      args, complain, in_decl);\n-\t\t\tif (argvec == error_mark_node)\n-\t\t\t  return error_mark_node;\n+\t\t    /* We are processing a type constructed from\n+\t\t       a template template parameter */\n+\t\t    tree argvec = tsubst (TYPE_TI_ARGS (t),\n+\t\t\t\t\t  args, complain, in_decl);\n+\t\t    if (argvec == error_mark_node)\n+\t\t      return error_mark_node;\n \t\t\t\n-\t\t\t/* We can get a TEMPLATE_TEMPLATE_PARM here when \n-\t\t\t   we are resolving nested-types in the signature of \n-\t\t\t   a member function templates.\n-\t\t\t   Otherwise ARG is a TEMPLATE_DECL and is the real \n-\t\t\t   template to be instantiated.  */\n-\t\t\tif (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n-\t\t\t  arg = TYPE_NAME (arg);\n-\n-\t\t\tr = lookup_template_class (arg, \n-\t\t\t\t\t\t   argvec, in_decl, \n-\t\t\t\t\t\t   DECL_CONTEXT (arg),\n-\t\t\t\t\t\t   /*entering_scope=*/0);\n-\t\t\treturn cp_build_qualified_type_real (r, \n-\t\t\t\t\t\t\t     TYPE_QUALS (t),\n-\t\t\t\t\t\t\t     complain);\n-\t\t      }\n-\t\t    else\n-\t\t      /* We are processing a template argument list.  */ \n-\t\t      return arg;\n+\t\t    /* We can get a TEMPLATE_TEMPLATE_PARM here when \n+\t\t       we are resolving nested-types in the signature of \n+\t\t       a member function templates.\n+\t\t       Otherwise ARG is a TEMPLATE_DECL and is the real \n+\t\t       template to be instantiated.  */\n+\t\t    if (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n+\t\t      arg = TYPE_NAME (arg);\n+\n+\t\t    r = lookup_template_class (arg, \n+\t\t\t\t\t       argvec, in_decl, \n+\t\t\t\t\t       DECL_CONTEXT (arg),\n+\t\t\t\t\t       /*entering_scope=*/0);\n+\t\t    return cp_build_qualified_type_real (r, \n+\t\t\t\t\t\t         TYPE_QUALS (t),\n+\t\t\t\t\t\t         complain);\n \t\t  }\n \t\telse\n+\t\t  /* TEMPLATE_TEMPLATE_PARM or TEMPLATE_PARM_INDEX.  */\n \t\t  return arg;\n \t      }\n \t  }\n@@ -6312,6 +6309,7 @@ tsubst (t, args, complain, in_decl)\n \t  {\n \t  case TEMPLATE_TYPE_PARM:\n \t  case TEMPLATE_TEMPLATE_PARM:\n+\t  case BOUND_TEMPLATE_TEMPLATE_PARM:\n \t    if (CP_TYPE_QUALS (t))\n \t      {\n \t\tr = tsubst (TYPE_MAIN_VARIANT (t), args, complain, in_decl);\n@@ -6329,8 +6327,7 @@ tsubst (t, args, complain, in_decl)\n \t\tTYPE_POINTER_TO (r) = NULL_TREE;\n \t\tTYPE_REFERENCE_TO (r) = NULL_TREE;\n \n-\t\tif (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM\n-\t\t    && TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t))\n+\t\tif (TREE_CODE (t) == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t\t  {\n \t\t    tree argvec = tsubst (TYPE_TI_ARGS (t), args,\n \t\t\t\t\t  complain, in_decl); \n@@ -7032,6 +7029,7 @@ tsubst_copy (t, args, complain, in_decl)\n     case INTEGER_TYPE:\n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_TEMPLATE_PARM:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n     case TEMPLATE_PARM_INDEX:\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n@@ -8302,6 +8300,7 @@ unify (tparms, targs, parm, arg, strict)\n \n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_TEMPLATE_PARM:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n       tparm = TREE_VALUE (TREE_VEC_ELT (tparms, 0));\n \n       if (TEMPLATE_TYPE_LEVEL (parm)\n@@ -8321,53 +8320,61 @@ unify (tparms, targs, parm, arg, strict)\n \t      && TREE_CODE (tparm) != TEMPLATE_DECL))\n \treturn 1;\n \n-      if (TREE_CODE (parm) == TEMPLATE_TEMPLATE_PARM)\n+      if (TREE_CODE (parm) == BOUND_TEMPLATE_TEMPLATE_PARM)\n \t{\n-\t  if (TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (parm))\n-\t    {\n-\t      /* We arrive here when PARM does not involve template \n-\t\t specialization.  */\n+\t  /* ARG must be constructed from a template class.  */\n+\t  if (TREE_CODE (arg) != RECORD_TYPE || !CLASSTYPE_TEMPLATE_INFO (arg))\n+\t    return 1;\n \n-\t      /* ARG must be constructed from a template class.  */\n-\t      if (TREE_CODE (arg) != RECORD_TYPE || !CLASSTYPE_TEMPLATE_INFO (arg))\n-\t\treturn 1;\n+\t  {\n+\t    tree parmtmpl = TYPE_TI_TEMPLATE (parm);\n+\t    tree parmvec = TYPE_TI_ARGS (parm);\n+\t    tree argvec = CLASSTYPE_TI_ARGS (arg);\n+\t    tree argtmplvec\n+\t      = DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (arg));\n+\t    int i;\n \n-\t      {\n-\t\ttree parmtmpl = TYPE_TI_TEMPLATE (parm);\n-\t\ttree parmvec = TYPE_TI_ARGS (parm);\n-\t\ttree argvec = CLASSTYPE_TI_ARGS (arg);\n-\t\ttree argtmplvec\n-\t\t  = DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (arg));\n-\t\tint i;\n-\n-\t\t/* The parameter and argument roles have to be switched here \n-\t\t   in order to handle default arguments properly.  For example, \n-\t\t   template<template <class> class TT> void f(TT<int>) \n-\t\t   should be able to accept vector<int> which comes from \n-\t\t   template <class T, class Allocator = allocator> \n-\t\t   class vector.  */\n-\n-\t\tif (coerce_template_parms (argtmplvec, parmvec, parmtmpl, 0, 1)\n-\t\t    == error_mark_node)\n-\t\t  return 1;\n+\t    /* The parameter and argument roles have to be switched here \n+\t       in order to handle default arguments properly.  For example, \n+\t       template<template <class> class TT> void f(TT<int>) \n+\t       should be able to accept vector<int> which comes from \n+\t       template <class T, class Allocator = allocator> \n+\t       class vector.  */\n+\n+\t    if (coerce_template_parms (argtmplvec, parmvec, parmtmpl, 0, 1)\n+\t        == error_mark_node)\n+\t      return 1;\n \t  \n-\t\t/* Deduce arguments T, i from TT<T> or TT<i>.  \n-\t\t   We check each element of PARMVEC and ARGVEC individually\n-\t\t   rather than the whole TREE_VEC since they can have\n-\t\t   different number of elements.  */\n+\t    /* Deduce arguments T, i from TT<T> or TT<i>.  \n+\t       We check each element of PARMVEC and ARGVEC individually\n+\t       rather than the whole TREE_VEC since they can have\n+\t       different number of elements.  */\n \n-\t\tfor (i = 0; i < TREE_VEC_LENGTH (parmvec); ++i)\n-\t\t  {\n-\t\t    tree t = TREE_VEC_ELT (parmvec, i);\n+\t    for (i = 0; i < TREE_VEC_LENGTH (parmvec); ++i)\n+\t      {\n+\t        tree t = TREE_VEC_ELT (parmvec, i);\n \n-\t\t    if (unify (tparms, targs, t, \n-\t\t\t       TREE_VEC_ELT (argvec, i), \n-\t\t\t       UNIFY_ALLOW_NONE))\n-\t\t      return 1;\n-\t\t  }\n+\t        if (unify (tparms, targs, t, \n+\t\t\t   TREE_VEC_ELT (argvec, i), \n+\t\t\t   UNIFY_ALLOW_NONE))\n+\t\t  return 1;\n \t      }\n-\t      arg = CLASSTYPE_TI_TEMPLATE (arg);\n-\t    }\n+\t  }\n+\t  arg = CLASSTYPE_TI_TEMPLATE (arg);\n+\n+\t  /* Fall through to deduce template name.  */\n+\t}\n+\n+      if (TREE_CODE (parm) == TEMPLATE_TEMPLATE_PARM\n+\t  || TREE_CODE (parm) == BOUND_TEMPLATE_TEMPLATE_PARM)\n+\t{\n+\t  /* Deduce template name TT from TT, TT<>, TT<T> and TT<i>.  */\n+\n+\t  /* Simple cases: Value already set, does match or doesn't.  */\n+\t  if (targ != NULL_TREE && template_args_equal (targ, arg))\n+\t    return 0;\n+\t  else if (targ)\n+\t    return 1;\n \t}\n       else\n \t{\n@@ -8388,13 +8395,13 @@ unify (tparms, targs, parm, arg, strict)\n \t\t\t\t\t  /*complain=*/0);\n \t  if (arg == error_mark_node)\n \t    return 1;\n-\t}\n \n-      /* Simple cases: Value already set, does match or doesn't.  */\n-      if (targ != NULL_TREE && same_type_p (targ, arg))\n-\treturn 0;\n-      else if (targ)\n-\treturn 1;\n+\t  /* Simple cases: Value already set, does match or doesn't.  */\n+\t  if (targ != NULL_TREE && same_type_p (targ, arg))\n+\t    return 0;\n+\t  else if (targ)\n+\t    return 1;\n+\t}\n \n       /* Make sure that ARG is not a variable-sized array.  (Note that\n \t were talking about variable-sized arrays (like `int[n]'),"}, {"sha": "5c4ac8467010fd63e92d562931e4692bc0f2f2a2", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -75,6 +75,7 @@ print_lang_type (file, node, indent)\n     {\n     case TEMPLATE_TYPE_PARM:\n     case TEMPLATE_TEMPLATE_PARM:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n       indent_to (file, indent + 3);\n       fputs (\"index \", file);\n       fprintf (file, HOST_WIDE_INT_PRINT_DEC, TEMPLATE_TYPE_IDX (node));"}, {"sha": "befcb99eef3d9051d69c91453348f56d1372d56f", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -587,7 +587,7 @@ lookup_field_1 (type, name)\n   register tree field;\n \n   if (TREE_CODE (type) == TEMPLATE_TYPE_PARM\n-      || TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM)\n+      || TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM)\n     /* The TYPE_FIELDS of a TEMPLATE_TYPE_PARM are not fields at all;\n        instead TYPE_FIELDS is the TEMPLATE_PARM_INDEX.  (Miraculously,\n        the code often worked even when we treated the index as a list"}, {"sha": "be2459aba98b2f190b54c81b7c840b1f53342160", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -1176,7 +1176,8 @@ build_exception_variant (type, raises)\n   return v;\n }\n \n-/* Given a TEMPLATE_TEMPLATE_PARM node T, create a new one together with its \n+/* Given a TEMPLATE_TEMPLATE_PARM or BOUND_TEMPLATE_TEMPLATE_PARM\n+   node T, create a new one together with its \n    lang_specific field and its corresponding *_DECL node.\n    If NEWARGS is not NULL_TREE, this parameter is bound with new set of\n    arguments.  */\n@@ -1189,9 +1190,9 @@ copy_template_template_parm (t, newargs)\n   tree decl = TYPE_NAME (t);\n   tree t2;\n \n-  t2 = make_aggr_type (TEMPLATE_TEMPLATE_PARM);\n   if (newargs == NULL_TREE)\n     {\n+      t2 = make_aggr_type (TREE_CODE (t));\n       decl = copy_decl (decl);\n \n       /* No need to copy these.  */\n@@ -1201,6 +1202,7 @@ copy_template_template_parm (t, newargs)\n     }\n   else\n     {\n+      t2 = make_aggr_type (BOUND_TEMPLATE_TEMPLATE_PARM);\n       decl = build_decl (TYPE_DECL, DECL_NAME (decl), NULL_TREE);\n \n       /* These nodes have to be created to reflect new TYPE_DECL and template\n@@ -1329,6 +1331,7 @@ walk_tree (tp, func, data)\n     case STRING_CST:\n     case DEFAULT_ARG:\n     case TEMPLATE_TEMPLATE_PARM:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n     case TEMPLATE_PARM_INDEX:\n     case TEMPLATE_TYPE_PARM:\n     case REAL_TYPE:\n@@ -1581,7 +1584,8 @@ copy_tree_r (tp, walk_subtrees, data)\n       if (TREE_CODE (*tp) == SCOPE_STMT)\n \tSCOPE_STMT_BLOCK (*tp) = NULL_TREE;\n     }\n-  else if (code == TEMPLATE_TEMPLATE_PARM)\n+  else if (code == TEMPLATE_TEMPLATE_PARM\n+\t   || code == BOUND_TEMPLATE_TEMPLATE_PARM)\n     /* These must be copied specially.  */\n     *tp = copy_template_template_parm (*tp, NULL_TREE);\n   else if (TREE_CODE_CLASS (code) == 't')"}, {"sha": "823aaec624fb74a872c3b2c1471392344c3e15bd", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -1012,15 +1012,15 @@ comptypes (t1, t2, strict)\n   switch (TREE_CODE (t1))\n     {\n     case TEMPLATE_TEMPLATE_PARM:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n       if (TEMPLATE_TYPE_IDX (t1) != TEMPLATE_TYPE_IDX (t2)\n \t  || TEMPLATE_TYPE_LEVEL (t1) != TEMPLATE_TYPE_LEVEL (t2))\n \treturn 0;\n       if (! comp_template_parms\n \t      (DECL_TEMPLATE_PARMS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (t1)),\n \t       DECL_TEMPLATE_PARMS (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (t2))))\n \treturn 0;\n-      if (!TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t1) \n-\t  && ! TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t2))\n+      if (TREE_CODE (t1) == TEMPLATE_TEMPLATE_PARM)\n \treturn 1;\n       /* Don't check inheritance.  */\n       strict = COMPARE_STRICT;\n@@ -1030,7 +1030,7 @@ comptypes (t1, t2, strict)\n     case UNION_TYPE:\n       if (TYPE_TEMPLATE_INFO (t1) && TYPE_TEMPLATE_INFO (t2)\n \t  && (TYPE_TI_TEMPLATE (t1) == TYPE_TI_TEMPLATE (t2)\n-\t      || TREE_CODE (t1) == TEMPLATE_TEMPLATE_PARM))\n+\t      || TREE_CODE (t1) == BOUND_TEMPLATE_TEMPLATE_PARM))\n \tval = comp_template_args (TYPE_TI_ARGS (t1),\n \t\t\t\t  TYPE_TI_ARGS (t2));\n     look_hard:"}, {"sha": "77013c4248d7f3f84738db6c8e59108ad43fd211", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ttp62.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp62.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1281f45033c96419e4a6feab46fbd1f308d26ff/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp62.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp62.C?ref=a1281f45033c96419e4a6feab46fbd1f308d26ff", "patch": "@@ -0,0 +1,27 @@\n+// Origin: Ewgenij Gawrilow <gawrilow@math.TU-Berlin.DE>\n+\n+#include <iostream>\n+\n+template <template <class X> class B, class A>\n+struct is_instance_of {\n+   enum { answer=false };\n+};\n+\n+template <template <class X> class B, class T>\n+struct is_instance_of<B, B<T> > {\n+   enum { answer=true };\n+};\n+\n+template <class X> struct C { };\n+template <class X> struct D { };\n+\n+template <class T>\n+bool is_C (const T&) {\n+   return is_instance_of<C,T>::answer;\n+};\n+\n+int main() {\n+   cout << \"should be true: \" << is_C(C<int>()) << endl;\n+   cout << \"should be false: \" << is_C(D<int>()) << endl;\n+   return 0;\n+}"}]}