{"sha": "4cf36211354241794588bab658e807ac550dc9de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNmMzYyMTEzNTQyNDE3OTQ1ODhiYWI2NThlODA3YWM1NTBkYzlkZQ==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2007-12-18T21:19:41Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2007-12-18T21:19:41Z"}, "message": "re PR c++/32565 (ICE with specialization of variadic template)\n\n2007-12-18  Douglas Gregor  <doug.gregor@gmail.com>\n            Jakub Jelinek  <jakub@redhat.com>\n\t\n\tPR c++/32565\n\tPR c++/33943\n\tPR c++/33965\n\t* pt.c (template_template_parm_bindings_ok_p): New; verifies\n\tbindings of template template parameters after all template\n\targuments have been deduced.\n\t(coerce_template_parms): Don't complain when COMPLAIN doesn't\n\tinclude tf_error.\n\t(fn_type_unification): Use template_template_parm_bindings_ok_p. \n\t(unify): Deal with variadic, bound template template parameters. \n\t(get_class_bindings): Use template_template_parm_bindings_ok_p. \t\n\t\n2007-12-18  Douglas Gregor  <doug.gregor@gmail.com>\n\t    Jakub Jelinek  <jakub@redhat.com>\n\t\n\tPR c++/32565\n\tPR c++/33943\n\tPR c++/33965\n\t* g++.dg/cpp0x/variadic86.C: New.\n\t* g++.dg/cpp0x/variadic87.C: New.\n\t* g++.dg/cpp0x/variadic84.C: New.\n\t* g++.dg/cpp0x/variadic85.C: New.\n\t* g++.dg/template/ttp25.C: New.\n\t\n\t\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r131041", "tree": {"sha": "23b50a2f189bbdb5981c84f3f3cf60d440a43c0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23b50a2f189bbdb5981c84f3f3cf60d440a43c0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cf36211354241794588bab658e807ac550dc9de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cf36211354241794588bab658e807ac550dc9de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cf36211354241794588bab658e807ac550dc9de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cf36211354241794588bab658e807ac550dc9de/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3615b8c2004057ce9cc64a449d0f9a88214e8997", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3615b8c2004057ce9cc64a449d0f9a88214e8997", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3615b8c2004057ce9cc64a449d0f9a88214e8997"}], "stats": {"total": 272, "additions": 260, "deletions": 12}, "files": [{"sha": "011ef2fbc032c56541f76c0167ad63f8e262f5ea", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 144, "deletions": 12, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cf36211354241794588bab658e807ac550dc9de/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cf36211354241794588bab658e807ac550dc9de/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4cf36211354241794588bab658e807ac550dc9de", "patch": "@@ -158,6 +158,7 @@ static tree get_template_base (tree, tree, tree, tree);\n static tree try_class_unification (tree, tree, tree, tree);\n static int coerce_template_template_parms (tree, tree, tsubst_flags_t,\n \t\t\t\t\t   tree, tree);\n+static bool template_template_parm_bindings_ok_p (tree, tree);\n static int template_args_equal (tree, tree);\n static void tsubst_default_arguments (tree);\n static tree for_each_template_parm_r (tree *, int *, void *);\n@@ -4750,6 +4751,77 @@ coerce_template_template_parms (tree parm_parms,\n   return 1;\n }\n \n+/* Verifies that the deduced template arguments (in TARGS) for the\n+   template template parameters (in TPARMS) represent valid bindings,\n+   by comparing the template parameter list of each template argument\n+   to the template parameter list of its corresponding template\n+   template parameter, in accordance with DR150. This\n+   routine can only be called after all template arguments have been\n+   deduced. It will return TRUE if all of the template template\n+   parameter bindings are okay, FALSE otherwise.  */\n+bool \n+template_template_parm_bindings_ok_p (tree tparms, tree targs)\n+{\n+  int i, ntparms = TREE_VEC_LENGTH (tparms);\n+\n+  targs = INNERMOST_TEMPLATE_ARGS (targs);\n+\n+  for (i = 0; i < ntparms; ++i)\n+    {\n+      tree tparm = TREE_VALUE (TREE_VEC_ELT (tparms, i));\n+      tree targ = TREE_VEC_ELT (targs, i);\n+\n+      if (TREE_CODE (tparm) == TEMPLATE_DECL && targ)\n+\t{\n+\t  tree packed_args = NULL_TREE;\n+\t  int idx, len = 1;\n+\n+\t  if (ARGUMENT_PACK_P (targ))\n+\t    {\n+\t      /* Look inside the argument pack.  */\n+\t      packed_args = ARGUMENT_PACK_ARGS (targ);\n+\t      len = TREE_VEC_LENGTH (packed_args);\n+\t    }\n+\n+\t  for (idx = 0; idx < len; ++idx)\n+\t    {\n+\t      tree targ_parms = NULL_TREE;\n+\n+\t      if (packed_args)\n+\t\t/* Extract the next argument from the argument\n+\t\t   pack.  */\n+\t\ttarg = TREE_VEC_ELT (packed_args, idx);\n+\n+\t      if (PACK_EXPANSION_P (targ))\n+\t\t/* Look at the pattern of the pack expansion.  */\n+\t\ttarg = PACK_EXPANSION_PATTERN (targ);\n+\n+\t      /* Extract the template parameters from the template\n+\t\t argument.  */\n+\t      if (TREE_CODE (targ) == TEMPLATE_DECL)\n+\t\ttarg_parms = DECL_INNERMOST_TEMPLATE_PARMS (targ);\n+\t      else if (TREE_CODE (targ) == TEMPLATE_TEMPLATE_PARM)\n+\t\ttarg_parms = DECL_INNERMOST_TEMPLATE_PARMS (TYPE_NAME (targ));\n+\n+\t      /* Verify that we can coerce the template template\n+\t\t parameters from the template argument to the template\n+\t\t parameter.  This requires an exact match.  */\n+\t      if (targ_parms\n+\t\t  && !coerce_template_template_parms\n+\t\t       (DECL_INNERMOST_TEMPLATE_PARMS (tparm),\n+\t\t\ttarg_parms,\n+\t\t\ttf_none,\n+\t\t\ttparm,\n+\t\t\ttargs))\n+\t\treturn false;\n+\t    }\n+\t}\n+    }\n+\n+  /* Everything is okay.  */\n+  return true;\n+}\n+\n /* Convert the indicated template ARG as necessary to match the\n    indicated template PARM.  Returns the converted ARG, or\n    error_mark_node if the conversion was unsuccessful.  Error and\n@@ -5183,16 +5255,19 @@ coerce_template_parms (tree parms,\n \n           if (arg && PACK_EXPANSION_P (arg))\n             {\n-              /* If ARG is a pack expansion, but PARM is not a\n-                 template parameter pack (if it were, we would have\n-                 handled it above), we're trying to expand into a\n-                 fixed-length argument list.  */\n-              if (TREE_CODE (arg) == EXPR_PACK_EXPANSION)\n-                error (\"cannot expand %<%E%> into a fixed-length \"\n-                       \"argument list\", arg);\n-              else\n-                error (\"cannot expand %<%T%> into a fixed-length \"\n-                       \"argument list\", arg);\n+\t      if (complain & tf_error)\n+\t\t{\n+\t\t  /* If ARG is a pack expansion, but PARM is not a\n+\t\t     template parameter pack (if it were, we would have\n+\t\t     handled it above), we're trying to expand into a\n+\t\t     fixed-length argument list.  */\n+\t\t  if (TREE_CODE (arg) == EXPR_PACK_EXPANSION)\n+\t\t    error (\"cannot expand %<%E%> into a fixed-length \"\n+\t\t\t   \"argument list\", arg);\n+\t\t  else\n+\t\t    error (\"cannot expand %<%T%> into a fixed-length \"\n+\t\t\t   \"argument list\", arg);\n+\t\t}\n \t      return error_mark_node;\n             }\n         }\n@@ -11627,6 +11702,32 @@ fn_type_unification (tree fn,\n         }\n     }\n \n+  /* Now that we have bindings for all of the template arguments,\n+     ensure that the arguments deduced for the template template\n+     parameters have compatible template parameter lists.  We cannot\n+     check this property before we have deduced all template\n+     arguments, because the template parameter types of a template\n+     template parameter might depend on prior template parameters\n+     deduced after the template template parameter.  The following\n+     ill-formed example illustrates this issue:\n+\n+       template<typename T, template<T> class C> void f(C<5>, T);\n+\n+       template<int N> struct X {};\n+\n+       void g() {\n+         f(X<5>(), 5l); // error: template argument deduction fails\n+       }\n+\n+     The template parameter list of 'C' depends on the template type\n+     parameter 'T', but 'C' is deduced to 'X' before 'T' is deduced to\n+     'long'.  Thus, we can't check that 'C' cannot bind to 'X' at the\n+     time that we deduce 'C'.  */\n+  if (result == 0\n+      && !template_template_parm_bindings_ok_p \n+           (DECL_INNERMOST_TEMPLATE_PARMS (fn), targs))\n+    return 1;\n+\n   if (result == 0)\n     /* All is well so far.  Now, check:\n \n@@ -12711,7 +12812,8 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t    tree argvec = INNERMOST_TEMPLATE_ARGS (TYPE_TI_ARGS (arg));\n \t    tree argtmplvec\n \t      = DECL_INNERMOST_TEMPLATE_PARMS (TYPE_TI_TEMPLATE (arg));\n-\t    int i;\n+\t    int i, len;\n+            int parm_variadic_p = 0;\n \n \t    /* The resolution to DR150 makes clear that default\n \t       arguments for an N-argument may not be used to bind T\n@@ -12753,14 +12855,36 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t       rather than the whole TREE_VEC since they can have\n \t       different number of elements.  */\n \n-\t    for (i = 0; i < TREE_VEC_LENGTH (parmvec); ++i)\n+            parmvec = expand_template_argument_pack (parmvec);\n+            argvec = expand_template_argument_pack (argvec);\n+\n+            len = TREE_VEC_LENGTH (parmvec);\n+\n+            /* Check if the parameters end in a pack, making them\n+               variadic.  */\n+            if (len > 0\n+                && PACK_EXPANSION_P (TREE_VEC_ELT (parmvec, len - 1)))\n+              parm_variadic_p = 1;\n+            \n+            if (TREE_VEC_LENGTH (argvec) < len - parm_variadic_p)\n+              return 1;\n+\n+             for (i = 0; i < len - parm_variadic_p; ++i)\n \t      {\n \t\tif (unify (tparms, targs,\n \t\t\t   TREE_VEC_ELT (parmvec, i),\n \t\t\t   TREE_VEC_ELT (argvec, i),\n \t\t\t   UNIFY_ALLOW_NONE))\n \t\t  return 1;\n \t      }\n+\n+\t    if (parm_variadic_p\n+\t\t&& unify_pack_expansion (tparms, targs,\n+\t\t\t\t\t parmvec, argvec,\n+\t\t\t\t\t UNIFY_ALLOW_NONE,\n+\t\t\t\t\t /*call_args_p=*/false,\n+\t\t\t\t\t /*subr=*/false))\n+\t      return 1;\n \t  }\n \t  arg = TYPE_TI_TEMPLATE (arg);\n \n@@ -13783,6 +13907,14 @@ get_class_bindings (tree tparms, tree spec_args, tree args)\n \t\t\t      INNERMOST_TEMPLATE_ARGS (args)))\n     return NULL_TREE;\n \n+  /* Now that we have bindings for all of the template arguments,\n+     ensure that the arguments deduced for the template template\n+     parameters have compatible template parameter lists.  See the use\n+     of template_template_parm_bindings_ok_p in fn_type_unification\n+     for more information.  */\n+  if (!template_template_parm_bindings_ok_p (tparms, deduced_args))\n+    return NULL_TREE;\n+\n   return deduced_args;\n }\n "}, {"sha": "02f906bd06bf1e71bc8df313747b3f8c509b3994", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cf36211354241794588bab658e807ac550dc9de/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cf36211354241794588bab658e807ac550dc9de/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4cf36211354241794588bab658e807ac550dc9de", "patch": "@@ -1,3 +1,15 @@\n+2007-12-18  Douglas Gregor  <doug.gregor@gmail.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\t\n+\tPR c++/32565\n+\tPR c++/33943\n+\tPR c++/33965\n+\t* g++.dg/cpp0x/variadic86.C: New.\n+\t* g++.dg/cpp0x/variadic87.C: New.\n+\t* g++.dg/cpp0x/variadic84.C: New.\n+\t* g++.dg/cpp0x/variadic85.C: New.\n+\t* g++.dg/template/ttp25.C: New.\n+\n 2007-12-18  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR tree-optimization/34123"}, {"sha": "d5be7646156b33132651cdab44f2d6090afd44be", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic84.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cf36211354241794588bab658e807ac550dc9de/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic84.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cf36211354241794588bab658e807ac550dc9de/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic84.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic84.C?ref=4cf36211354241794588bab658e807ac550dc9de", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/32565\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template<typename...> struct A1;\n+template<template<int...> class T> struct A1<T<0> > {};\n+template<typename...> struct A2;\n+template<template<int...> class T> struct A2<T<0, 1> > {};\n+template<typename...> struct A3;\n+template<template<int, int...> class T> struct A3<T<0, 1> > {};\n+template<typename...> struct A4;\n+template<template<typename...> class T> struct A4<T<int> > {};\n+template<typename...> struct A5;\n+template<template<typename...> class T> struct A5<T<int, long> > {};\n+template<typename...> struct A6;\n+template<template<typename, typename...> class T> struct A6<T<int, long> > {};\n+template<int> struct B1 {};\n+template<int, int> struct B2 {};\n+template<typename> struct B3 {};\n+template<typename, typename> struct B4 {};\n+A1<B1<0> > a1; // { dg-error \"incomplete type\" }\n+A2<B2<0, 1> > a2; // { dg-error \"incomplete type\" }\n+A3<B2<0, 1> > a3; // { dg-error \"incomplete type\" }\n+A4<B3<int> > a4; // { dg-error \"incomplete type\" }\n+A5<B4<int, long> > a5; // { dg-error \"incomplete type\" }\n+A6<B4<int, long> > a6; // { dg-error \"incomplete type\" }"}, {"sha": "7004d086a0f648c4d1eb98ed3aaa8ebe3e253263", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic85.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cf36211354241794588bab658e807ac550dc9de/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic85.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cf36211354241794588bab658e807ac550dc9de/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic85.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic85.C?ref=4cf36211354241794588bab658e807ac550dc9de", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/32565\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template<typename...> struct A1;\n+template<template<int, int...> class T> struct A1<T<0, 1> > {};\n+template<int, int, int...> struct B1 {};\n+A1<B1<0, 1> > a1; // { dg-error \"incomplete type\" }\n+template<int...> struct B2 {};\n+A1<B2<0, 1> > a2; // { dg-error \"incomplete type\" }"}, {"sha": "d8fcd620e95fcba49e0e03fb0f8b372bf582dda5", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic86.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cf36211354241794588bab658e807ac550dc9de/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic86.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cf36211354241794588bab658e807ac550dc9de/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic86.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic86.C?ref=4cf36211354241794588bab658e807ac550dc9de", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/33943\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template<typename... A> struct foo {};\n+\n+template<typename A0, typename... A1> struct bar {};\n+\n+template<typename U> struct baz;\n+\n+template<template<typename...> class T, typename... U> struct baz< T<U...> >\n+{};\n+\n+template<template<typename, typename...> class T, typename U, typename... V>\n+struct baz< T<U, V...> >\n+{};\n+\n+baz< foo<int, short> > b1;\n+baz< bar<int, short> > b2;"}, {"sha": "1defa23da2924f1adcb0970ee7b9f519a5215b50", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic87.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cf36211354241794588bab658e807ac550dc9de/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic87.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cf36211354241794588bab658e807ac550dc9de/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic87.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic87.C?ref=4cf36211354241794588bab658e807ac550dc9de", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/33965\n+// { dg-options -std=c++0x }\n+template<typename T>\n+struct foo\n+{\n+    static bool const value = false;\n+};\n+\n+template<template<typename...> class T, typename... Args>\n+struct foo<T<Args...> >\n+{\n+    static bool const value = true;\n+};\n+\n+template<int I>\n+struct int_\n+{};\n+\n+int main()\n+{\n+  static_assert(foo<int_<0> >::value == false, \n+\t\t\"picked up partial specialization, but should not have\");\n+}"}, {"sha": "89153037913cae849953c5fdcec718e600d96f90", "filename": "gcc/testsuite/g++.dg/template/ttp25.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cf36211354241794588bab658e807ac550dc9de/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cf36211354241794588bab658e807ac550dc9de/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp25.C?ref=4cf36211354241794588bab658e807ac550dc9de", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile }\n+template<typename T, template<T> class C>\n+void f1(T, C<5>);\n+\n+template<typename T, template<T> class C>\n+void f2(C<5>, T);\n+\n+template<typename T, template<T> class C>\n+void f3(C<5>, T);\n+\n+template<typename T> struct metafun { typedef T type; };\n+\n+template<> struct metafun<short> { typedef int type; };\n+\n+template<typename T, template<typename metafun<T>::type> class C>\n+void f4(T, C<5>);\n+\n+template<int N> struct X {};\n+void g() {\n+  f1(5l, X<5>()); // { dg-error \"no matching\" }\n+  f2(X<5>(), 5);\n+  f3(X<5>(), 5l); // { dg-error \"no matching\" }\n+  f4(5, X<5>());\n+  f4(5l, X<5>()); // { dg-error \"no matching\" }\n+  f4((short)5, X<5>());\n+}"}]}