{"sha": "2d01edd7600090f4c938d232da3df3aeff3e1fe8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQwMWVkZDc2MDAwOTBmNGM5MzhkMjMyZGEzZGYzYWVmZjNlMWZlOA==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2004-10-04T06:04:43Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2004-10-04T06:04:43Z"}, "message": "Convert diagnostics to use quoting flag q 3/n\n\ncp/\n        Convert diagnostics to use quoting flag q 3/n\n        * decl.c (pop_label, duplicate_decls,\n        redeclaration_error_message,\n        redeclaration_error_message, lookup_label, check_goto,\n        make_typename_type, make_unbound_class_template,\n        fixup_anonymous_aggr, check_tag_decl, start_decl,\n        start_decl_1,\n        grok_reference_init, layout_var_decl, maybe_commonize_var,\n        check_for_uninitialized_const_var, reshape_init_array,\n        reshape_init, check_initializer, cp_finish_decl,\n        member_function_or_else, bad_specifiers, grokfndecl,\n        grokvardecl,\n        check_static_variable_definition, compute_array_index_type,\n        create_array_type_for_decl,\n        check_special_function_return_type,\n        grokdeclarator, check_default_argument, grokparms,\n        grok_ctor_properties, grok_op_properties,\n        check_elaborated_type_specifier, xref_tag, finish_enum,\n        build_enumerator, check_function_type,\n        start_preparsed_function,\n        store_parm_decls): Use quoting formats.\n        * decl2.c (grok_array_decl, delete_sanity,\n        check_member_template,\n        check_java_method, check_classfn,\n        finish_static_data_member_decl,\n        grokfield, grokbitfield, grok_function_init,\n        build_anon_union_vars, coerce_new_type, coerce_delete_type,\n        check_default_args): Likewise.\n        * parser.c (cp_parser_decl_specifier_seq): Likewise.\n\ntestsuite/\n        * g++.dg/template/local1.C: Adjust quoting marks in\n        testing for diagnostics.\n        * g++.dg/tls/diag-2.C: Likewise.\n        * g++.dg/other/error8.C: Likewise.\n\nFrom-SVN: r88478", "tree": {"sha": "30a8d8de55edc18faba87a0274ef38a5796c2c39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30a8d8de55edc18faba87a0274ef38a5796c2c39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d01edd7600090f4c938d232da3df3aeff3e1fe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d01edd7600090f4c938d232da3df3aeff3e1fe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d01edd7600090f4c938d232da3df3aeff3e1fe8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d01edd7600090f4c938d232da3df3aeff3e1fe8/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9e6959bf6e59b5122ca60f05d2926fc3b48f848", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9e6959bf6e59b5122ca60f05d2926fc3b48f848", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9e6959bf6e59b5122ca60f05d2926fc3b48f848"}], "stats": {"total": 792, "additions": 424, "deletions": 368}, "files": [{"sha": "ea32ec8f35097243f6de6ad1ee1a3c4d4e37bb78", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2d01edd7600090f4c938d232da3df3aeff3e1fe8", "patch": "@@ -1,3 +1,28 @@\n+2004-10-03  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\tConvert diagnostics to use quoting flag q 3/n\n+\t* decl.c (pop_label, duplicate_decls, redeclaration_error_message,\n+\tredeclaration_error_message, lookup_label, check_goto,\n+\tmake_typename_type, make_unbound_class_template,\n+\tfixup_anonymous_aggr, check_tag_decl, start_decl, start_decl_1, \n+\tgrok_reference_init, layout_var_decl, maybe_commonize_var, \n+\tcheck_for_uninitialized_const_var, reshape_init_array, \n+\treshape_init, check_initializer, cp_finish_decl,\n+\tmember_function_or_else, bad_specifiers, grokfndecl, grokvardecl, \n+\tcheck_static_variable_definition, compute_array_index_type, \n+\tcreate_array_type_for_decl, check_special_function_return_type, \n+\tgrokdeclarator, check_default_argument, grokparms, \n+\tgrok_ctor_properties, grok_op_properties, \n+\tcheck_elaborated_type_specifier, xref_tag, finish_enum, \n+\tbuild_enumerator, check_function_type, start_preparsed_function, \n+\tstore_parm_decls): Use quoting formats.\n+\t* decl2.c (grok_array_decl, delete_sanity, check_member_template, \n+\tcheck_java_method, check_classfn, finish_static_data_member_decl, \n+\tgrokfield, grokbitfield, grok_function_init,\n+\tbuild_anon_union_vars, coerce_new_type, coerce_delete_type,\n+\tcheck_default_args): Likewise.\n+\t* parser.c (cp_parser_decl_specifier_seq): Likewise.\n+\n 2004-10-03  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \tConvert diagnostics to use quoting flag q 2/n"}, {"sha": "078e2f9326d1d129cf8eb07a0ec508286421876f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 337, "deletions": 321, "changes": 658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2d01edd7600090f4c938d232da3df3aeff3e1fe8", "patch": "@@ -364,7 +364,7 @@ pop_label (tree label, tree old_value)\n \t{\n \t  location_t location;\n \n-\t  cp_error_at (\"label `%D' used but not defined\", label);\n+\t  cp_error_at (\"label %qD used but not defined\", label);\n #ifdef USE_MAPPED_LOCATION\n \t  location = input_location; /* FIXME want (input_filename, (line)0) */\n #else\n@@ -375,7 +375,7 @@ pop_label (tree label, tree old_value)\n \t  define_label (location, DECL_NAME (label));\n \t}\n       else if (warn_unused_label && !TREE_USED (label))\n-\tcp_warning_at (\"label `%D' defined but not used\", label);\n+\tcp_warning_at (\"label %qD defined but not used\", label);\n     }\n \n   SET_IDENTIFIER_LABEL_VALUE (DECL_NAME (label), old_value);\n@@ -571,7 +571,7 @@ poplevel (int keep, int reverse, int functionbody)\n \t  && ! TREE_USED (decl)\n \t  && ! DECL_IN_SYSTEM_HEADER (decl)\n \t  && DECL_NAME (decl) && ! DECL_ARTIFICIAL (decl))\n-\twarning (\"%Junused variable '%D'\", decl, decl);\n+\twarning (\"%Junused variable %qD\", decl, decl);\n \n   /* Remove declarations for all the DECLs in this level.  */\n   for (link = decls; link; link = TREE_CHAIN (link))\n@@ -1134,8 +1134,8 @@ warn_extern_redeclared_static (tree newdecl, tree olddecl)\n     return;\n \n   name = DECL_ASSEMBLER_NAME (newdecl);\n-  pedwarn (\"`%D' was declared `extern' and later `static'\", newdecl);\n-  cp_pedwarn_at (\"previous declaration of `%D'\", olddecl);\n+  pedwarn (\"%qD was declared %<extern%> and later %<static%>\", newdecl);\n+  cp_pedwarn_at (\"previous declaration of %qD\", olddecl);\n }\n \n /* If NEWDECL is a redeclaration of OLDDECL, merge the declarations.\n@@ -1183,17 +1183,17 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t       && DECL_UNINLINABLE (olddecl)\n \t       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (olddecl)))\n \t{\n-\t  warning (\"%Jfunction '%D' redeclared as inline\", newdecl, newdecl);\n-\t  warning (\"%Jprevious declaration of '%D' with attribute noinline\",\n+\t  warning (\"%Jfunction %qD redeclared as inline\", newdecl, newdecl);\n+\t  warning (\"%Jprevious declaration of %qD with attribute noinline\",\n                    olddecl, olddecl);\n \t}\n       else if (DECL_DECLARED_INLINE_P (olddecl)\n \t       && DECL_UNINLINABLE (newdecl)\n \t       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (newdecl)))\n \t{\n-\t  warning (\"%Jfunction '%D' redeclared with attribute noinline\",\n+\t  warning (\"%Jfunction %qD redeclared with attribute noinline\",\n \t\t   newdecl, newdecl);\n-\t  warning (\"%Jprevious declaration of '%D' was inline\",\n+\t  warning (\"%Jprevious declaration of %qD was inline\",\n \t\t   olddecl, olddecl);\n \t}\n     }\n@@ -1214,22 +1214,22 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t  if (! TREE_PUBLIC (newdecl))\n \t    {\n \t      if (warn_shadow)\n-\t\twarning (\"shadowing %s function `%#D'\",\n-\t\t\t    DECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n-\t\t\t    olddecl);\n+                warning (\"shadowing %s function %q#D\",\n+                         DECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n+                         olddecl);\n \t      /* Discard the old built-in function.  */\n \t      return NULL_TREE;\n \t    }\n \t  /* If the built-in is not ansi, then programs can override\n \t     it even globally without an error.  */\n \t  else if (! DECL_BUILT_IN (olddecl))\n-\t    warning (\"library function `%#D' redeclared as non-function `%#D'\",\n-\t\t\tolddecl, newdecl);\n+\t    warning (\"library function %q#D redeclared as non-function %q#D\",\n+                     olddecl, newdecl);\n \t  else\n \t    {\n-\t      error (\"declaration of `%#D'\", newdecl);\n-\t      error (\"conflicts with built-in declaration `%#D'\",\n-\t\t\tolddecl);\n+\t      error (\"declaration of %q#D\", newdecl);\n+\t      error (\"conflicts with built-in declaration %q#D\",\n+                     olddecl);\n \t    }\n \t  return NULL_TREE;\n \t}\n@@ -1280,14 +1280,14 @@ duplicate_decls (tree newdecl, tree olddecl)\n \n \t      if (TREE_PUBLIC (newdecl))\n \t\t{\n-\t\t  warning (\"new declaration `%#D'\", newdecl);\n-\t\t  warning (\"ambiguates built-in declaration `%#D'\",\n-\t\t\t      olddecl);\n+\t\t  warning (\"new declaration %q#D\", newdecl);\n+\t\t  warning (\"ambiguates built-in declaration %q#D\",\n+                           olddecl);\n \t\t}\n \t      else if (warn_shadow)\n-\t\twarning (\"shadowing %s function `%#D'\",\n-\t\t\t    DECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n-\t\t\t    olddecl);\n+\t\twarning (\"shadowing %s function %q#D\",\n+                         DECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n+                         olddecl);\n \t    }\n \t  else\n \t    /* Discard the old built-in function.  */\n@@ -1352,10 +1352,10 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      && DECL_FUNCTION_TEMPLATE_P (newdecl)))\n \treturn NULL_TREE;\n \n-      error (\"`%#D' redeclared as different kind of symbol\", newdecl);\n+      error (\"%q#D redeclared as different kind of symbol\", newdecl);\n       if (TREE_CODE (olddecl) == TREE_LIST)\n \tolddecl = TREE_VALUE (olddecl);\n-      cp_error_at (\"previous declaration of `%#D'\", olddecl);\n+      cp_error_at (\"previous declaration of %q#D\", olddecl);\n \n       return error_mark_node;\n     }\n@@ -1374,8 +1374,8 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t  if (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == TYPE_DECL\n \t      || TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)\n \t    {\n-\t      error (\"declaration of template `%#D'\", newdecl);\n-\t      cp_error_at (\"conflicts with previous declaration `%#D'\",\n+\t      error (\"declaration of template %q#D\", newdecl);\n+\t      cp_error_at (\"conflicts with previous declaration %q#D\",\n \t\t\t   olddecl);\n \t    }\n \t  else if (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == FUNCTION_DECL\n@@ -1389,32 +1389,32 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t\t   && same_type_p (TREE_TYPE (TREE_TYPE (newdecl)),\n \t\t\t\t   TREE_TYPE (TREE_TYPE (olddecl))))\n \t    {\n-\t      error (\"new declaration `%#D'\", newdecl);\n-\t      cp_error_at (\"ambiguates old declaration `%#D'\", olddecl);\n+\t      error (\"new declaration %q#D\", newdecl);\n+\t      cp_error_at (\"ambiguates old declaration %q#D\", olddecl);\n \t    }\n \t  return NULL_TREE;\n \t}\n       if (TREE_CODE (newdecl) == FUNCTION_DECL)\n \t{\n \t  if (DECL_EXTERN_C_P (newdecl) && DECL_EXTERN_C_P (olddecl))\n \t    {\n-\t      error (\"declaration of C function `%#D' conflicts with\",\n-\t\t\tnewdecl);\n-\t      cp_error_at (\"previous declaration `%#D' here\", olddecl);\n+\t      error (\"declaration of C function %q#D conflicts with\",\n+                     newdecl);\n+\t      cp_error_at (\"previous declaration %q#D here\", olddecl);\n \t    }\n \t  else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n \t\t\t      TYPE_ARG_TYPES (TREE_TYPE (olddecl))))\n \t    {\n-\t      error (\"new declaration `%#D'\", newdecl);\n-\t      cp_error_at (\"ambiguates old declaration `%#D'\", olddecl);\n+\t      error (\"new declaration %q#D\", newdecl);\n+\t      cp_error_at (\"ambiguates old declaration %q#D\", olddecl);\n \t    }\n \t  else\n \t    return NULL_TREE;\n \t}\n       else\n \t{\n-\t  error (\"conflicting declaration '%#D'\", newdecl);\n-\t  cp_error_at (\"'%D' has a previous declaration as `%#D'\",\n+\t  error (\"conflicting declaration %q#D\", newdecl);\n+\t  cp_error_at (\"%qD has a previous declaration as %q#D\",\n                        olddecl, olddecl);\n           return NULL_TREE;\n \t}\n@@ -1467,8 +1467,8 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t A namespace-name defined at global scope shall not be\n \t declared as the name of any other entity in any global scope\n \t of the program.  */\n-      error (\"declaration of `namespace %D' conflicts with\", newdecl);\n-      cp_error_at (\"previous declaration of `namespace %D' here\", olddecl);\n+      error (\"declaration of namespace %qD conflicts with\", newdecl);\n+      cp_error_at (\"previous declaration of namespace %qD here\", olddecl);\n       return error_mark_node;\n     }\n   else\n@@ -1480,8 +1480,8 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t  if (DECL_NAME (olddecl) != NULL_TREE)\n \t    cp_error_at ((DECL_INITIAL (olddecl)\n \t\t\t  && namespace_bindings_p ())\n-\t\t\t ? \"`%#D' previously defined here\"\n-\t\t\t : \"`%#D' previously declared here\", olddecl);\n+\t\t\t ? \"%q#D previously defined here\"\n+\t\t\t : \"%q#D previously declared here\", olddecl);\n \t  return error_mark_node;\n \t}\n       else if (TREE_CODE (olddecl) == FUNCTION_DECL\n@@ -1490,7 +1490,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t       && TYPE_ARG_TYPES (TREE_TYPE (newdecl)) != NULL_TREE)\n \t{\n \t  /* Prototype decl follows defn w/o prototype.  */\n-\t  cp_warning_at (\"prototype for `%#D'\", newdecl);\n+\t  cp_warning_at (\"prototype for %q#D\", newdecl);\n \t  warning (\"%Jfollows non-prototype definition here\", olddecl);\n \t}\n       else if (TREE_CODE (olddecl) == FUNCTION_DECL\n@@ -1503,10 +1503,10 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t    SET_DECL_LANGUAGE (newdecl, DECL_LANGUAGE (olddecl));\n \t  else\n \t    {\n-\t      cp_error_at (\"previous declaration of `%#D' with %L linkage\",\n+\t      cp_error_at (\"previous declaration of %q#D with %qL linkage\",\n \t\t\t   olddecl, DECL_LANGUAGE (olddecl));\n-\t      error (\"conflicts with new declaration with %L linkage\",\n-\t\t\tDECL_LANGUAGE (newdecl));\n+\t      error (\"conflicts with new declaration with %qL linkage\",\n+                     DECL_LANGUAGE (newdecl));\n \t    }\n \t}\n \n@@ -1528,16 +1528,16 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t\tif (1 == simple_cst_equal (TREE_PURPOSE (t1),\n \t\t\t\t\t   TREE_PURPOSE (t2)))\n \t\t  {\n-\t\t    pedwarn (\"default argument given for parameter %d of `%#D'\",\n+\t\t    pedwarn (\"default argument given for parameter %d of %q#D\",\n \t\t\t     i, newdecl);\n-\t\t    cp_pedwarn_at (\"after previous specification in `%#D'\",\n+\t\t    cp_pedwarn_at (\"after previous specification in %q#D\",\n \t\t\t           olddecl);\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    error (\"default argument given for parameter %d of `%#D'\",\n-\t\t\t      i, newdecl);\n-\t\t    cp_error_at (\"after previous specification in `%#D'\",\n+\t\t    error (\"default argument given for parameter %d of %q#D\",\n+                           i, newdecl);\n+\t\t    cp_error_at (\"after previous specification in %q#D\",\n \t\t\t\t olddecl);\n \t\t  }\n \t      }\n@@ -1546,7 +1546,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      && ! DECL_DECLARED_INLINE_P (olddecl)\n \t      && TREE_ADDRESSABLE (olddecl) && warn_inline)\n \t    {\n-\t      warning (\"`%#D' was used before it was declared inline\", newdecl);\n+\t      warning (\"%q#D was used before it was declared inline\", newdecl);\n \t      warning (\"%Jprevious non-inline declaration here\", olddecl);\n \t    }\n \t}\n@@ -1599,8 +1599,8 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t  /* Don't warn about friends, let add_friend take care of it.  */\n \t  && ! (DECL_FRIEND_P (newdecl) || DECL_FRIEND_P (olddecl)))\n \t{\n-\t  warning (\"redundant redeclaration of `%D' in same scope\", newdecl);\n-\t  cp_warning_at (\"previous declaration of `%D'\", olddecl);\n+\t  warning (\"redundant redeclaration of %qD in same scope\", newdecl);\n+\t  cp_warning_at (\"previous declaration of %qD\", olddecl);\n \t}\n     }\n \n@@ -1693,9 +1693,9 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      && !comp_except_specs (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (newdecl)),\n \t                             TYPE_RAISES_EXCEPTIONS (TREE_TYPE (olddecl)), 1))\n \t    {\n-\t      error (\"declaration of `%F' throws different exceptions\",\n-\t\t\tnewdecl);\n-\t      cp_error_at (\"than previous declaration `%F'\", olddecl);\n+\t      error (\"declaration of %qF throws different exceptions\",\n+                     newdecl);\n+\t      cp_error_at (\"than previous declaration %qF\", olddecl);\n \t    }\n \t}\n       TREE_TYPE (newdecl) = TREE_TYPE (olddecl) = newtype;\n@@ -1927,7 +1927,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n       && DECL_VISIBILITY_SPECIFIED (newdecl)\n       && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))\n     {\n-      warning (\"%J'%D': visibility attribute ignored because it\",\n+      warning (\"%J%qD: visibility attribute ignored because it\",\n \t       newdecl, newdecl);\n       warning (\"%Jconflicts with previous declaration here\", olddecl);\n     }\n@@ -2019,7 +2019,7 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n       if (same_type_p (TREE_TYPE (newdecl), TREE_TYPE (olddecl)))\n \treturn 0;\n       else\n-\treturn \"redefinition of `%#D'\";\n+\treturn \"redefinition of %q#D\";\n     }\n   else if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n@@ -2033,7 +2033,7 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n \t a redeclaration - this is a conflict with a used function.  */\n       if (DECL_NAMESPACE_SCOPE_P (olddecl)\n \t  && DECL_CONTEXT (olddecl) != DECL_CONTEXT (newdecl))\n-\treturn \"`%D' conflicts with used function\";\n+\treturn \"%qD conflicts with used function\";\n \n       /* We'll complain about linkage mismatches in\n          warn_extern_redeclared_static.  */\n@@ -2043,9 +2043,9 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n \t  && DECL_INITIAL (newdecl) != NULL_TREE)\n \t{\n \t  if (DECL_NAME (olddecl) == NULL_TREE)\n-\t    return \"`%#D' not declared in class\";\n+\t    return \"%q#D not declared in class\";\n \t  else\n-\t    return \"redefinition of `%#D'\";\n+\t    return \"redefinition of %q#D\";\n \t}\n       return 0;\n     }\n@@ -2057,7 +2057,7 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n \t{\n \t  if (COMPLETE_TYPE_P (TREE_TYPE (newdecl))\n \t      && COMPLETE_TYPE_P (TREE_TYPE (olddecl)))\n-\t    return \"redefinition of `%#D'\";\n+\t    return \"redefinition of %q#D\";\n \t  return NULL;\n \t}\n \n@@ -2073,7 +2073,7 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n       if (DECL_TEMPLATE_INFO (ot))\n \tot = DECL_TEMPLATE_RESULT (template_for_substitution (ot));\n       if (DECL_INITIAL (nt) && DECL_INITIAL (ot))\n-\treturn \"redefinition of `%#D'\";\n+\treturn \"redefinition of %q#D\";\n \n       return NULL;\n     }\n@@ -2084,15 +2084,15 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n       if (DECL_EXTERNAL (newdecl) || DECL_EXTERNAL (olddecl))\n \treturn 0;\n       /* Reject two definitions.  */\n-      return \"redefinition of `%#D'\";\n+      return \"redefinition of %q#D\";\n     }\n   else\n     {\n       /* Objects declared with block scope:  */\n       /* Reject two definitions, and reject a definition\n \t together with an external reference.  */\n       if (!(DECL_EXTERNAL (newdecl) && DECL_EXTERNAL (olddecl)))\n-\treturn \"redeclaration of `%#D'\";\n+\treturn \"redeclaration of %q#D\";\n       return 0;\n     }\n }\n@@ -2157,7 +2157,7 @@ lookup_label (tree id)\n   /* You can't use labels at global scope.  */\n   if (current_function_decl == NULL_TREE)\n     {\n-      error (\"label `%E' referenced outside of any function\", id);\n+      error (\"label %qE referenced outside of any function\", id);\n       POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n     }\n \n@@ -2253,7 +2253,7 @@ check_previous_goto_1 (tree decl,\n \t  if (! identified)\n \t    {\n \t      if (decl)\n-\t\tpedwarn (\"jump to label `%D'\", decl);\n+\t\tpedwarn (\"jump to label %qD\", decl);\n \t      else\n \t\tpedwarn (\"jump to case label\");\n \n@@ -2263,10 +2263,10 @@ check_previous_goto_1 (tree decl,\n \t    }\n \n \t  if (problem > 1)\n-\t    cp_error_at (\"  crosses initialization of `%#D'\",\n+\t    cp_error_at (\"  crosses initialization of %q#D\",\n \t\t\t new_decls);\n \t  else\n-\t    cp_pedwarn_at (\"  enters scope of non-POD `%#D'\",\n+\t    cp_pedwarn_at (\"  enters scope of non-POD %q#D\",\n \t\t\t   new_decls);\n \t}\n \n@@ -2277,7 +2277,7 @@ check_previous_goto_1 (tree decl,\n \t  if (! identified)\n \t    {\n \t      if (decl)\n-\t\tpedwarn (\"jump to label `%D'\", decl);\n+\t\tpedwarn (\"jump to label %qD\", decl);\n \t      else\n \t\tpedwarn (\"jump to case label\");\n \n@@ -2365,7 +2365,7 @@ check_goto (tree decl)\n   if ((lab->in_try_scope || lab->in_catch_scope || lab->bad_decls)\n       && !identified)\n     {\n-      cp_pedwarn_at (\"jump to label `%D'\", decl);\n+      cp_pedwarn_at (\"jump to label %qD\", decl);\n       pedwarn (\"  from here\");\n       identified = 1;\n     }\n@@ -2379,9 +2379,9 @@ check_goto (tree decl)\n \t/* Can't skip init of __exception_info.  */\n \terror (\"%J  enters catch block\", b);\n       else if (u > 1)\n-\tcp_error_at (\"  skips initialization of `%#D'\", b);\n+\tcp_error_at (\"  skips initialization of %q#D\", b);\n       else\n-\tcp_pedwarn_at (\"  enters scope of non-POD `%#D'\", b);\n+\tcp_pedwarn_at (\"  enters scope of non-POD %q#D\", b);\n     }\n \n   if (lab->in_try_scope)\n@@ -2647,7 +2647,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n     }\n   if (TREE_CODE (name) == TEMPLATE_DECL)\n     {\n-      error (\"`%D' used without template parameters\", name);\n+      error (\"%qD used without template parameters\", name);\n       return error_mark_node;\n     }\n   gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n@@ -2657,8 +2657,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n       /* We can get here from typename_sub0 in the explicit_template_type\n \t expansion.  Just fail.  */\n       if (complain & tf_error)\n-\terror (\"no class template named `%#T' in `%#T'\",\n-\t\t  name, context);\n+\terror (\"no class template named %q#T in %q#T\", name, context);\n       return error_mark_node;\n     }\n \n@@ -2673,8 +2672,8 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n \t  if (!tmpl || !DECL_CLASS_TEMPLATE_P (tmpl))\n \t    {\n \t      if (complain & tf_error)\n-\t\terror (\"no class template named `%#T' in `%#T'\",\n-\t\t\t  name, context);\n+\t\terror (\"no class template named %q#T in %q#T\",\n+                       name, context);\n \t      return error_mark_node;\n \t    }\n \n@@ -2694,7 +2693,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n \t  if (!IS_AGGR_TYPE (context))\n \t    {\n \t      if (complain & tf_error)\n-\t\terror (\"no type named `%#T' in `%#T'\", name, context);\n+\t\terror (\"no type named %q#T in %q#T\", name, context);\n \t      return error_mark_node;\n \t    }\n \n@@ -2704,7 +2703,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n \t      if (TREE_CODE (t) != TYPE_DECL)\n \t\t{\n \t\t  if (complain & tf_error)\n-\t\t    error (\"no type named `%#T' in `%#T'\", name, context);\n+\t\t    error (\"no type named %q#T in %q#T\", name, context);\n \t\t  return error_mark_node;\n \t\t}\n \n@@ -2724,7 +2723,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n   if (!dependent_type_p (context))\n     {\n       if (complain & tf_error)\n-\terror (\"no type named `%#T' in `%#T'\", name, context);\n+\terror (\"no type named %q#T in %q#T\", name, context);\n       return error_mark_node;\n     }\n \n@@ -2760,7 +2759,7 @@ make_unbound_class_template (tree context, tree name, tsubst_flags_t complain)\n       if (!tmpl || !DECL_CLASS_TEMPLATE_P (tmpl))\n \t{\n \t  if (complain & tf_error)\n-\t    error (\"no class template named `%#T' in `%#T'\", name, context);\n+\t    error (\"no class template named %q#T in %q#T\", name, context);\n \t  return error_mark_node;\n \t}\n \n@@ -3448,13 +3447,16 @@ fixup_anonymous_aggr (tree t)\n \t    if (CLASS_TYPE_P (type))\n \t      {\n \t        if (TYPE_NEEDS_CONSTRUCTING (type))\n-\t\t  cp_error_at (\"member %#D' with constructor not allowed in anonymous aggregate\",\n+\t\t  cp_error_at (\"member %q#D with constructor not allowed \"\n+                               \"in anonymous aggregate\",\n \t\t\t       field);\n \t\tif (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n-\t\t  cp_error_at (\"member %#D' with destructor not allowed in anonymous aggregate\",\n+\t\t  cp_error_at (\"member %q#D with destructor not allowed \"\n+                               \"in anonymous aggregate\",\n \t\t\t       field);\n \t\tif (TYPE_HAS_COMPLEX_ASSIGN_REF (type))\n-\t\t  cp_error_at (\"member %#D' with copy assignment operator not allowed in anonymous aggregate\",\n+\t\t  cp_error_at (\"member %q#D with copy assignment operator \"\n+                               \"not allowed in anonymous aggregate\",\n \t\t\t       field);\n \t      }\n \t  }\n@@ -3534,15 +3536,15 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n     {\n       if (declspecs->specs[(int)ds_inline]\n \t  || declspecs->specs[(int)ds_virtual])\n-\terror (\"`%s' can only be specified for functions\",\n+\terror (\"%qs can only be specified for functions\",\n \t       declspecs->specs[(int)ds_inline]\n \t       ? \"inline\" : \"virtual\");\n       else if (saw_friend\n \t       && (!current_class_type\n \t\t   || current_scope () != current_class_type))\n-\terror (\"`friend' can only be specified inside a class\");\n+\terror (\"%<friend%> can only be specified inside a class\");\n       else if (declspecs->specs[(int)ds_explicit])\n-\terror (\"`explicit' can only be specified for constructors\");\n+\terror (\"%<explicit%> can only be specified for constructors\");\n       else if (declspecs->storage_class)\n \terror (\"a storage class can only be specified for objects \"\n \t       \"and functions\");\n@@ -3688,12 +3690,12 @@ start_decl (const cp_declarator *declarator,\n     switch (TREE_CODE (decl))\n       {\n       case TYPE_DECL:\n-\terror (\"typedef `%D' is initialized (use __typeof__ instead)\", decl);\n+\terror (\"typedef %qD is initialized (use __typeof__ instead)\", decl);\n \tinitialized = 0;\n \tbreak;\n \n       case FUNCTION_DECL:\n-\terror (\"function `%#D' is initialized like a variable\", decl);\n+\terror (\"function %q#D is initialized like a variable\", decl);\n \tinitialized = 0;\n \tbreak;\n \n@@ -3705,8 +3707,8 @@ start_decl (const cp_declarator *declarator,\n     {\n       if (! toplevel_bindings_p ()\n \t  && DECL_EXTERNAL (decl))\n-\twarning (\"declaration of `%#D' has `extern' and is initialized\",\n-\t\t    decl);\n+\twarning (\"declaration of %q#D has %<extern%> and is initialized\",\n+                 decl);\n       DECL_EXTERNAL (decl) = 0;\n       if (toplevel_bindings_p ())\n \tTREE_STATIC (decl) = 1;\n@@ -3728,21 +3730,22 @@ start_decl (const cp_declarator *declarator,\n       && DECL_DECLARED_INLINE_P (decl)\n       && DECL_UNINLINABLE (decl)\n       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (decl)))\n-    warning (\"%Jinline function '%D' given attribute noinline\", decl, decl);\n+    warning (\"%Jinline function %qD given attribute noinline\", decl, decl);\n \n   if (context && COMPLETE_TYPE_P (complete_type (context)))\n     {\n       if (TREE_CODE (decl) == VAR_DECL)\n \t{\n \t  tree field = lookup_field (context, DECL_NAME (decl), 0, false);\n \t  if (field == NULL_TREE || TREE_CODE (field) != VAR_DECL)\n-\t    error (\"`%#D' is not a static member of `%#T'\", decl, context);\n+\t    error (\"%q#D is not a static member of %q#T\", decl, context);\n \t  else\n \t    {\n \t      if (DECL_CONTEXT (field) != context)\n \t\t{\n \t\t  if (!same_type_p (DECL_CONTEXT (field), context))\n-\t\t    pedwarn (\"ISO C++ does not permit `%T::%D' to be defined as `%T::%D'\",\n+\t\t    pedwarn (\"ISO C++ does not permit %<%T::%D%> \"\n+                             \"to be defined as %<%T::%D%>\",\n \t\t\t     DECL_CONTEXT (field), DECL_NAME (decl),\n \t\t\t     context, DECL_NAME (decl));\n \t\t  DECL_CONTEXT (decl) = DECL_CONTEXT (field);\n@@ -3786,8 +3789,8 @@ start_decl (const cp_declarator *declarator,\n \t}\n \n       if (DECL_EXTERNAL (decl) && ! DECL_TEMPLATE_SPECIALIZATION (decl))\n-\tpedwarn (\"declaration of `%#D' outside of class is not definition\",\n-\t\t    decl);\n+\tpedwarn (\"declaration of %q#D outside of class is not definition\",\n+                 decl);\n     }\n \n   /* Enter this declaration into the symbol table.  */\n@@ -3835,15 +3838,14 @@ start_decl_1 (tree decl)\n \t;\t\t\t/* A complete type is ok.  */\n       else if (TREE_CODE (type) != ARRAY_TYPE)\n \t{\n-\t  error (\"variable `%#D' has initializer but incomplete type\",\n-\t\t    decl);\n+\t  error (\"variable %q#D has initializer but incomplete type\", decl);\n \t  initialized = 0;\n \t  type = TREE_TYPE (decl) = error_mark_node;\n \t}\n       else if (!COMPLETE_TYPE_P (complete_type (TREE_TYPE (type))))\n \t{\n \t  if (DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl))\n-\t    error (\"elements of array `%#D' have incomplete type\", decl);\n+\t    error (\"elements of array %q#D have incomplete type\", decl);\n \t  /* else we already gave an error in start_decl.  */\n \t  initialized = 0;\n \t}\n@@ -3859,7 +3861,7 @@ start_decl_1 (tree decl)\n       if ((! processing_template_decl || ! uses_template_parms (type))\n \t  && !COMPLETE_TYPE_P (complete_type (type)))\n \t{\n-\t  error (\"aggregate `%#D' has incomplete type and cannot be defined\",\n+\t  error (\"aggregate %q#D has incomplete type and cannot be defined\",\n \t\t decl);\n \t  /* Change the type so that assemble_variable will give\n \t     DECL an rtl we can live with: (mem (const_int 0)).  */\n@@ -3915,7 +3917,8 @@ grok_reference_init (tree decl, tree type, tree init, tree *cleanup)\n \n   if (TREE_CODE (init) == CONSTRUCTOR)\n     {\n-      error (\"ISO C++ forbids use of initializer list to initialize reference `%D'\", decl);\n+      error (\"ISO C++ forbids use of initializer list to \"\n+             \"initialize reference %qD\", decl);\n       return NULL_TREE;\n     }\n \n@@ -3943,7 +3946,7 @@ grok_reference_init (tree decl, tree type, tree init, tree *cleanup)\n     return NULL_TREE;\n   else if (tmp == NULL_TREE)\n     {\n-      error (\"cannot initialize `%T' from `%T'\", type, TREE_TYPE (init));\n+      error (\"cannot initialize %qT from %qT\", type, TREE_TYPE (init));\n       return NULL_TREE;\n     }\n \n@@ -3975,7 +3978,7 @@ maybe_deduce_size_from_array_init (tree decl, tree init)\n       int failure = complete_array_type (type, initializer, do_default);\n \n       if (failure == 1)\n-\terror (\"initializer fails to determine size of `%D'\", decl);\n+\terror (\"initializer fails to determine size of %qD\", decl);\n \n       if (failure == 2)\n \t{\n@@ -3992,7 +3995,7 @@ maybe_deduce_size_from_array_init (tree decl, tree init)\n       if (pedantic && TYPE_DOMAIN (type) != NULL_TREE\n \t  && tree_int_cst_lt (TYPE_MAX_VALUE (TYPE_DOMAIN (type)),\n \t\t\t      integer_zero_node))\n-\terror (\"zero-size array `%D'\", decl);\n+\terror (\"zero-size array %qD\", decl);\n \n       layout_decl (decl, 0);\n     }\n@@ -4029,7 +4032,7 @@ layout_var_decl (tree decl)\n       /* An automatic variable with an incomplete type: that is an error.\n \t Don't talk about array types here, since we took care of that\n \t message in grokdeclarator.  */\n-      error (\"storage size of `%D' isn't known\", decl);\n+      error (\"storage size of %qD isn't known\", decl);\n       TREE_TYPE (decl) = error_mark_node;\n     }\n #if 0\n@@ -4051,7 +4054,7 @@ layout_var_decl (tree decl)\n       if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST)\n \tconstant_expression_warning (DECL_SIZE (decl));\n       else\n-\terror (\"storage size of `%D' isn't constant\", decl);\n+\terror (\"storage size of %qD isn't constant\", decl);\n     }\n \n   if (TREE_STATIC (decl)\n@@ -4106,8 +4109,11 @@ maybe_commonize_var (tree decl)\n \t\t be merged.  */\n \t      TREE_PUBLIC (decl) = 0;\n \t      DECL_COMMON (decl) = 0;\n-\t      cp_warning_at (\"sorry: semantics of inline function static data `%#D' are wrong (you'll wind up with multiple copies)\", decl);\n-\t      warning (\"%J  you can work around this by removing the initializer\",\n+\t      cp_warning_at (\"sorry: semantics of inline function static \"\n+                             \"data %q#D are wrong (you'll wind up \"\n+                             \"with multiple copies)\", decl);\n+\t      warning (\"%J  you can work around this by removing \"\n+                       \"the initializer\",\n \t\t       decl);\n \t    }\n \t}\n@@ -4133,7 +4139,7 @@ check_for_uninitialized_const_var (tree decl)\n       && CP_TYPE_CONST_P (type)\n       && !TYPE_NEEDS_CONSTRUCTING (type)\n       && !DECL_INITIAL (decl))\n-    error (\"uninitialized const `%D'\", decl);\n+    error (\"uninitialized const %qD\", decl);\n }\n \n /* FIELD is a FIELD_DECL or NULL.  In the former case, the value\n@@ -4193,8 +4199,8 @@ reshape_init_array (tree elt_type, tree max_index,\n \t  /* Handle array designated initializers (GNU extension).  */\n \t  if (TREE_CODE (designated_index) == IDENTIFIER_NODE)\n \t    {\n-\t      error (\"name `%D' used in a GNU-style designated \"\n-\t\t    \"initializer for an array\", designated_index);\n+\t      error (\"name %qD used in a GNU-style designated \"\n+                     \"initializer for an array\", designated_index);\n \t      TREE_PURPOSE (element_init) = NULL_TREE;\n \t    }\n \t  else\n@@ -4203,7 +4209,7 @@ reshape_init_array (tree elt_type, tree max_index,\n \t      if (sized_array_p\n \t\t  && tree_int_cst_lt (max_index, designated_index))\n \t\t{\n-\t\t  error (\"Designated initializer `%E' larger than array \"\n+\t\t  error (\"Designated initializer %qE larger than array \"\n \t\t\t \"size\", designated_index);\n \t\t  TREE_PURPOSE (element_init) = NULL_TREE;\n \t\t}\n@@ -4274,7 +4280,7 @@ reshape_init (tree type, tree *initp)\n \t   brace-enclosed initializer.  */\n \tif (brace_enclosed_p)\n \t  {\n-\t    error (\"brace-enclosed initializer used to initialize `%T'\",\n+\t    error (\"brace-enclosed initializer used to initialize %qT\",\n \t\t   type);\n \t    if (TREE_CODE (old_init) == TREE_LIST)\n \t      TREE_VALUE (old_init) = error_mark_node;\n@@ -4337,8 +4343,7 @@ reshape_init (tree type, tree *initp)\n \t\t initializer-list {}.  */\n \t      if (!brace_enclosed_p)\n \t\t{\n-\t\t  error (\"initializer for `%T' must be brace-enclosed\",\n-\t\t\t type);\n+\t\t  error (\"initializer for %qT must be brace-enclosed\", type);\n \t\t  return error_mark_node;\n \t\t}\n \t    }\n@@ -4358,7 +4363,7 @@ reshape_init (tree type, tree *initp)\n \t\t      field = lookup_field_1 (type, TREE_PURPOSE (*initp),\n \t\t\t\t\t      /*want_type=*/false);\n \t\t      if (!field || TREE_CODE (field) != FIELD_DECL)\n-\t\t\terror (\"`%T' has no non-static data member named `%D'\",\n+\t\t\terror (\"%qT has no non-static data member named %qD\",\n \t\t\t       type, TREE_PURPOSE (*initp));\n \t\t    }\n \t\t  if (!field)\n@@ -4420,7 +4425,7 @@ reshape_init (tree type, tree *initp)\n   /* If this was a brace-enclosed initializer and all of the\n      initializers were not used up, there is a problem.  */\n   if (brace_enclosed_p && *initp)\n-    error (\"too many initializers for `%T'\", type);\n+    error (\"too many initializers for %qT\", type);\n \n   return new_init;\n }\n@@ -4458,18 +4463,18 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n   else if (init && COMPLETE_TYPE_P (type)\n \t   && !TREE_CONSTANT (TYPE_SIZE (type)))\n     {\n-      error (\"variable-sized object `%D' may not be initialized\", decl);\n+      error (\"variable-sized object %qD may not be initialized\", decl);\n       init = NULL_TREE;\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE\n \t   && !COMPLETE_TYPE_P (complete_type (TREE_TYPE (type))))\n     {\n-      error (\"elements of array `%#D' have incomplete type\", decl);\n+      error (\"elements of array %q#D have incomplete type\", decl);\n       init = NULL_TREE;\n     }\n   else if (TREE_CODE (type) != ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n     {\n-      error (\"`%D' has incomplete type\", decl);\n+      error (\"%qD has incomplete type\", decl);\n       TREE_TYPE (decl) = error_mark_node;\n       init = NULL_TREE;\n     }\n@@ -4523,7 +4528,8 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n \t    {\n \t      if (TYPE_NON_AGGREGATE_CLASS (type))\n \t\t{\n-\t\t  error (\"`%D' must be initialized by constructor, not by `{...}'\",\n+\t\t  error (\"%qD must be initialized by constructor, \"\n+                         \"not by %<{...}%>\",\n \t\t\t decl);\n \t\t  init = error_mark_node;\n \t\t}\n@@ -4567,10 +4573,9 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n       tree core_type = strip_array_types (type);\n \n       if (CLASSTYPE_READONLY_FIELDS_NEED_INIT (core_type))\n-\terror (\"structure `%D' with uninitialized const members\", decl);\n+\terror (\"structure %qD with uninitialized const members\", decl);\n       if (CLASSTYPE_REF_FIELDS_NEED_INIT (core_type))\n-\terror (\"structure `%D' with uninitialized reference members\",\n-\t       decl);\n+\terror (\"structure %qD with uninitialized reference members\", decl);\n \n       check_for_uninitialized_const_var (decl);\n     }\n@@ -4781,8 +4786,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \n   if (init && TREE_CODE (init) == NAMESPACE_DECL)\n     {\n-      error (\"cannot initialize `%D' to namespace `%D'\",\n-\t\tdecl, init);\n+      error (\"cannot initialize %qD to namespace %qD\", decl, init);\n       init = NULL_TREE;\n     }\n \n@@ -4825,7 +4829,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t  && IS_AGGR_TYPE (type) && DECL_NAME (decl))\n \t{\n \t  if (TREE_TYPE (DECL_NAME (decl)) && TREE_TYPE (decl) != type)\n-\t    warning (\"shadowing previous type declaration of `%#D'\", decl);\n+\t    warning (\"shadowing previous type declaration of %q#D\", decl);\n \t  set_identifier_type_value (DECL_NAME (decl), decl);\n \t}\n \n@@ -4862,7 +4866,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n       /* Only PODs can have thread-local storage.  Other types may require\n \t various kinds of non-trivial initialization.  */\n       if (DECL_THREAD_LOCAL (decl) && !pod_type_p (TREE_TYPE (decl)))\n-\terror (\"`%D' cannot be thread-local because it has non-POD type `%T'\",\n+\terror (\"%qD cannot be thread-local because it has non-POD type %qT\",\n \t       decl, TREE_TYPE (decl));\n       /* Convert the initializer to the type of DECL, if we have not\n \t already initialized DECL.  */\n@@ -4877,7 +4881,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \t  /* Thread-local storage cannot be dynamically initialized.  */\n \t  if (DECL_THREAD_LOCAL (decl) && init)\n \t    {\n-\t      error (\"`%D' is thread-local and so cannot be dynamically \"\n+\t      error (\"%qD is thread-local and so cannot be dynamically \"\n \t\t     \"initialized\", decl);\n \t      init = NULL_TREE;\n \t    }\n@@ -5468,11 +5472,9 @@ member_function_or_else (tree ctype, tree cur_type, enum overload_flags flags)\n   if (ctype && ctype != cur_type)\n     {\n       if (flags == DTOR_FLAG)\n-\terror (\"destructor for alien class `%T' cannot be a member\",\n-\t          ctype);\n+\terror (\"destructor for alien class %qT cannot be a member\", ctype);\n       else\n-\terror (\"constructor for alien class `%T' cannot be a member\",\n-\t          ctype);\n+\terror (\"constructor for alien class %qT cannot be a member\", ctype);\n       return 0;\n     }\n   return 1;\n@@ -5493,20 +5495,21 @@ bad_specifiers (tree object,\n                 int raises)\n {\n   if (virtualp)\n-    error (\"`%D' declared as a `virtual' %s\", object, type);\n+    error (\"%qD declared as a %<virtual%> %s\", object, type);\n   if (inlinep)\n-    error (\"`%D' declared as an `inline' %s\", object, type);\n+    error (\"%qD declared as an %<inline%> %s\", object, type);\n   if (quals)\n-    error (\"`const' and `volatile' function specifiers on `%D' invalid in %s declaration\",\n-\t      object, type);\n+    error (\"%<const%> and %<volatile%> function specifiers on \"\n+           \"q%D invalid in %s declaration\",\n+           object, type);\n   if (friendp)\n-    cp_error_at (\"`%D' declared as a friend\", object);\n+    cp_error_at (\"%qD declared as a friend\", object);\n   if (raises\n       && (TREE_CODE (object) == TYPE_DECL\n \t  || (!TYPE_PTRFN_P (TREE_TYPE (object))\n \t      && !TYPE_REFFN_P (TREE_TYPE (object))\n \t      && !TYPE_PTRMEMFUNC_P (TREE_TYPE (object)))))\n-    cp_error_at (\"`%D' declared with an exception specification\", object);\n+    cp_error_at (\"%qD declared with an exception specification\", object);\n }\n \n /* CTYPE is class type, or null if non-class.\n@@ -5589,15 +5592,15 @@ grokfndecl (tree ctype,\n   if (ctype == NULL_TREE && DECL_MAIN_P (decl))\n     {\n       if (processing_template_decl)\n-\terror (\"cannot declare `::main' to be a template\");\n+\terror (\"cannot declare %<::main%> to be a template\");\n       if (inlinep)\n-\terror (\"cannot declare `::main' to be inline\");\n+\terror (\"cannot declare %<::main%> to be inline\");\n       if (!publicp)\n-\terror (\"cannot declare `::main' to be static\");\n+\terror (\"cannot declare %<::main%> to be static\");\n       if (!same_type_p (TREE_TYPE (TREE_TYPE (decl)),\n \t\t\tinteger_type_node))\n \t{\n-\t  error (\"`::main' must return `int'\");\n+\t  error (\"%<::main%> must return %<int%>\");\n \t  TREE_TYPE (TREE_TYPE (decl)) = integer_type_node;\n \t}\n       inlinep = 0;\n@@ -5627,17 +5630,16 @@ grokfndecl (tree ctype,\n \t\t/* Allow this; it's pretty common in C.  */;\n \t      else\n \t\t{\n-\t\t  pedwarn (\"non-local function `%#D' uses anonymous type\",\n+\t\t  pedwarn (\"non-local function %q#D uses anonymous type\",\n \t\t\t      decl);\n \t\t  if (DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n-\t\t    cp_pedwarn_at (\"\\\n-`%#D' does not refer to the unqualified type, so it is not used for linkage\",\n-\t\t\t\tTYPE_NAME (t));\n+\t\t    cp_pedwarn_at (\"%q#D does not refer to the unqualified \"\n+                                   \"type, so it is not used for linkage\",\n+                                   TYPE_NAME (t));\n \t\t}\n \t    }\n \t  else\n-\t    pedwarn (\"non-local function `%#D' uses local type `%T'\",\n-\t\t\tdecl, t);\n+\t    pedwarn (\"non-local function %q#D uses local type %qT\", decl, t);\n \t}\n     }\n \n@@ -5660,7 +5662,7 @@ grokfndecl (tree ctype,\n   DECL_EXTERNAL (decl) = 1;\n   if (quals && TREE_CODE (type) == FUNCTION_TYPE)\n     {\n-      error (\"%smember function `%D' cannot have cv-qualifier\",\n+      error (\"%smember function %qD cannot have cv-qualifier\",\n \t     (ctype ? \"static \" : \"non-\"), decl);\n       quals = TYPE_UNQUALIFIED;\n     }\n@@ -5684,7 +5686,7 @@ grokfndecl (tree ctype,\n     {\n       if (funcdef_flag)\n \terror\n-\t  (\"defining explicit specialization `%D' in friend declaration\",\n+\t  (\"defining explicit specialization %qD in friend declaration\",\n \t   orig_declarator);\n       else\n \t{\n@@ -5694,8 +5696,9 @@ grokfndecl (tree ctype,\n \t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t    {\n \t      /* Something like `template <class T> friend void f<T>()'.  */\n-\t      error (\"invalid use of template-id `%D' in declaration of primary template\",\n-\t\t\torig_declarator);\n+\t      error (\"invalid use of template-id %qD in declaration \"\n+                     \"of primary template\",\n+                     orig_declarator);\n \t      return NULL_TREE;\n \t    }\n \n@@ -5721,15 +5724,17 @@ grokfndecl (tree ctype,\n \n \t  if (has_default_arg)\n \t    {\n-\t      error (\"default arguments are not allowed in declaration of friend template specialization `%D'\",\n-\t\t\tdecl);\n+\t      error (\"default arguments are not allowed in declaration \"\n+                     \"of friend template specialization %qD\",\n+                     decl);\n \t      return NULL_TREE;\n \t    }\n \n \t  if (inlinep)\n \t    {\n-\t      error (\"`inline' is not allowed in declaration of friend template specialization `%D'\",\n-\t\t\tdecl);\n+\t      error (\"%<inline%> is not allowed in declaration of friend \"\n+                     \"template specialization %qD\",\n+                     decl);\n \t      return NULL_TREE;\n \t    }\n \t}\n@@ -5794,7 +5799,7 @@ grokfndecl (tree ctype,\n \t   XXX Isn't this done in start_function, too?  */\n \trevert_static_member_fn (decl);\n       if (old_decl && DECL_ARTIFICIAL (old_decl))\n-\terror (\"definition of implicitly-declared `%D'\", old_decl);\n+\terror (\"definition of implicitly-declared %qD\", old_decl);\n \n       if (old_decl)\n \t{\n@@ -5814,7 +5819,7 @@ grokfndecl (tree ctype,\n \t    pop_scope (ctype);\n \t  if (!ok)\n \t    {\n-\t      error (\"no `%#D' member function declared in class `%T'\",\n+\t      error (\"no %q#D member function declared in class %qT\",\n \t\t     decl, ctype);\n \t      return NULL_TREE;\n \t    }\n@@ -5971,17 +5976,16 @@ grokvardecl (tree type,\n \t      else\n \t\t{\n \t\t  /* It's a typedef referring to an anonymous type. */\n-\t\t  pedwarn (\"non-local variable `%#D' uses anonymous type\",\n+\t\t  pedwarn (\"non-local variable %q#D uses anonymous type\",\n \t\t\t   decl);\n \t\t  if (DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n-\t\t    cp_pedwarn_at (\"\\\n-`%#D' does not refer to the unqualified type, so it is not used for linkage\",\n+\t\t    cp_pedwarn_at (\"%q#D does not refer to the unqualified \"\n+                                   \"type, so it is not used for linkage\",\n \t\t\t\t   TYPE_NAME (t));\n \t\t}\n \t    }\n \t  else\n-\t    pedwarn (\"non-local variable `%#D' uses local type `%T'\",\n-\t\t\tdecl, t);\n+\t    pedwarn (\"non-local variable %q#D uses local type %qT\", decl, t);\n \t}\n     }\n \n@@ -6096,7 +6100,8 @@ check_static_variable_definition (tree decl, tree type)\n      required.  */\n   if (!ARITHMETIC_TYPE_P (type) && TREE_CODE (type) != ENUMERAL_TYPE)\n     {\n-      error (\"invalid in-class initialization of static data member of non-integral type `%T'\",\n+      error (\"invalid in-class initialization of static data member \"\n+             \"of non-integral type %qT\",\n \t     type);\n       /* If we just return the declaration, crashes will sometimes\n \t occur.  We therefore return void_type_node, as if this were a\n@@ -6105,10 +6110,12 @@ check_static_variable_definition (tree decl, tree type)\n       return 1;\n     }\n   else if (!CP_TYPE_CONST_P (type))\n-    error (\"ISO C++ forbids in-class initialization of non-const static member `%D'\",\n-\t      decl);\n+    error (\"ISO C++ forbids in-class initialization of non-const \"\n+           \"static member %qD\",\n+           decl);\n   else if (pedantic && !INTEGRAL_TYPE_P (type))\n-    pedwarn (\"ISO C++ forbids initialization of member constant `%D' of non-integral type `%T'\", decl, type);\n+    pedwarn (\"ISO C++ forbids initialization of member constant \"\n+             \"%qD of non-integral type %qT\", decl, type);\n \n   return 0;\n }\n@@ -6127,9 +6134,9 @@ compute_array_index_type (tree name, tree size)\n   if (!dependent_type_p (type) && !INTEGRAL_TYPE_P (type))\n     {\n       if (name)\n-\terror (\"size of array `%D' has non-integral type `%T'\", name, type);\n+\terror (\"size of array %qD has non-integral type %qT\", name, type);\n       else\n-\terror (\"size of array has non-integral type `%T'\", type);\n+\terror (\"size of array has non-integral type %qT\", type);\n       size = integer_one_node;\n       type = TREE_TYPE (size);\n     }\n@@ -6165,7 +6172,7 @@ compute_array_index_type (tree name, tree size)\n       if (INT_CST_LT (size, integer_zero_node))\n \t{\n \t  if (name)\n-\t    error (\"size of array `%D' is negative\", name);\n+\t    error (\"size of array %qD is negative\", name);\n \t  else\n \t    error (\"size of array is negative\");\n \t  size = integer_one_node;\n@@ -6175,7 +6182,7 @@ compute_array_index_type (tree name, tree size)\n       else if (integer_zerop (size) && pedantic && !in_system_header)\n \t{\n \t  if (name)\n-\t    pedwarn (\"ISO C++ forbids zero-size array `%D'\", name);\n+\t    pedwarn (\"ISO C++ forbids zero-size array %qD\", name);\n \t  else\n \t    pedwarn (\"ISO C++ forbids zero-size array\");\n \t}\n@@ -6184,15 +6191,15 @@ compute_array_index_type (tree name, tree size)\n     {\n       /* `(int) &fn' is not a valid array bound.  */\n       if (name)\n-\terror (\"size of array `%D' is not an integral constant-expression\",\n-\t\t  name);\n+\terror (\"size of array %qD is not an integral constant-expression\",\n+               name);\n       else\n \terror (\"size of array is not an integral constant-expression\");\n     }\n   else if (pedantic)\n     {\n       if (name)\n-\tpedwarn (\"ISO C++ forbids variable-size array `%D'\", name);\n+\tpedwarn (\"ISO C++ forbids variable-size array %qD\", name);\n       else\n \tpedwarn (\"ISO C++ forbids variable-size array\");\n     }\n@@ -6299,7 +6306,7 @@ create_array_type_for_decl (tree name, tree type, tree size)\n   if (error_msg)\n     {\n       if (name)\n-\terror (\"declaration of `%D' as %s\", name, error_msg);\n+\terror (\"declaration of %qD as %s\", name, error_msg);\n       else\n \terror (\"creating %s\", error_msg);\n \n@@ -6313,10 +6320,12 @@ create_array_type_for_decl (tree name, tree type, tree size)\n   if (TREE_CODE (type) == ARRAY_TYPE && !TYPE_DOMAIN (type))\n     {\n       if (name)\n-\terror (\"declaration of `%D' as multidimensional array must have bounds for all dimensions except the first\",\n-\t\t  name);\n+\terror (\"declaration of %qD as multidimensional array must \"\n+               \"have bounds for all dimensions except the first\",\n+               name);\n       else\n-\terror (\"multidimensional array must have bounds for all dimensions except the first\");\n+\terror (\"multidimensional array must have bounds for all \"\n+               \"dimensions except the first\");\n \n       return error_mark_node;\n     }\n@@ -6373,9 +6382,9 @@ check_special_function_return_type (special_function_kind sfk,\n \n     case sfk_conversion:\n       if (type && !same_type_p (type, optype))\n-\terror (\"operator `%T' declared to return `%T'\", optype, type);\n+\terror (\"operator %qT declared to return %qT\", optype, type);\n       else if (type)\n-\tpedwarn (\"return type specified for `operator %T'\",  optype);\n+\tpedwarn (\"return type specified for %<operator %T%>\",  optype);\n       type = optype;\n       break;\n \n@@ -6545,7 +6554,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t&& !UNIQUELY_DERIVED_FROM_P (ctype,\n \t\t\t\t\t\t     current_class_type))\n \t\t      {\n-\t\t\terror (\"type `%T' is not derived from type `%T'\",\n+\t\t\terror (\"type %qT is not derived from type %qT\",\n \t\t\t       ctype, current_class_type);\n \t\t\tctype = NULL_TREE;\n \t\t      }\n@@ -6590,7 +6599,7 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t\tif (C_IS_RESERVED_WORD (dname))\n \t\t  {\n-\t\t    error (\"declarator-id missing; using reserved word `%D'\",\n+\t\t    error (\"declarator-id missing; using reserved word %qD\",\n \t\t\t   dname);\n \t\t    name = IDENTIFIER_POINTER (dname);\n \t\t  }\n@@ -6646,7 +6655,7 @@ grokdeclarator (const cp_declarator *declarator,\n       && innermost_code != cdk_function\n       && ! (ctype && !declspecs->any_specifiers_p))\n     {\n-      error (\"declaration of `%D' as non-function\", dname);\n+      error (\"declaration of %qD as non-function\", dname);\n       return void_type_node;\n     }\n \n@@ -6679,7 +6688,7 @@ grokdeclarator (const cp_declarator *declarator,\n   /* If there were multiple types specified in the decl-specifier-seq,\n      issue an error message.  */\n   if (declspecs->multiple_types_p)\n-    error (\"two or more data types in declaration of `%s'\", name);\n+    error (\"two or more data types in declaration of %qs\", name);\n   /* Extract the basic type from the decl-specifier-seq.  */\n   type = declspecs->type;\n   if (type == error_mark_node)\n@@ -6720,9 +6729,9 @@ grokdeclarator (const cp_declarator *declarator,\n       if (ds == ds_long)\n \t{\n \t  if (count > 2)\n-\t    error (\"`long long long' is too long for GCC\");\n+\t    error (\"%<long long long%> is too long for GCC\");\n \t  else if (pedantic && !in_system_header && warn_long_long)\n-\t    pedwarn (\"ISO C++ does not support `long long'\");\n+\t    pedwarn (\"ISO C++ does not support %<long long%>\");\n \t  else\n \t    longlong = 1;\n \t}\n@@ -6744,7 +6753,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    \"__complex\",\n \t    \"__thread\"\n \t  };\n-\t  error (\"duplicate `%s'\", decl_spec_names[(int)ds]);\n+\t  error (\"duplicate %qs\", decl_spec_names[(int)ds]);\n \t}\n     }\n \n@@ -6782,11 +6791,9 @@ grokdeclarator (const cp_declarator *declarator,\n       else if (in_system_header || flag_ms_extensions)\n \t/* Allow it, sigh.  */;\n       else if (pedantic || ! is_main)\n-\tpedwarn (\"ISO C++ forbids declaration of `%s' with no type\",\n-\t\t    name);\n+\tpedwarn (\"ISO C++ forbids declaration of %qs with no type\", name);\n       else if (warn_return_type)\n-\twarning (\"ISO C++ forbids declaration of `%s' with no type\",\n-\t\t    name);\n+\twarning (\"ISO C++ forbids declaration of %qs with no type\", name);\n \n       type = integer_type_node;\n     }\n@@ -6811,23 +6818,23 @@ grokdeclarator (const cp_declarator *declarator,\n       int ok = 0;\n \n       if (TREE_CODE (type) == REAL_TYPE)\n-\terror (\"short, signed or unsigned invalid for `%s'\", name);\n+\terror (\"short, signed or unsigned invalid for %qs\", name);\n       else if (TREE_CODE (type) != INTEGER_TYPE)\n-\terror (\"long, short, signed or unsigned invalid for `%s'\", name);\n+\terror (\"long, short, signed or unsigned invalid for %qs\", name);\n       else if (long_p && short_p)\n-\terror (\"long and short specified together for `%s'\", name);\n+\terror (\"long and short specified together for %qs\", name);\n       else if ((long_p || short_p) && explicit_char)\n-\terror (\"long or short specified with char for `%s'\", name);\n+\terror (\"long or short specified with char for %qs\", name);\n       else if ((long_p|| short_p) && TREE_CODE (type) == REAL_TYPE)\n-\terror (\"long or short specified with floating type for `%s'\", name);\n+\terror (\"long or short specified with floating type for %qs\", name);\n       else if (signed_p && unsigned_p)\n-\terror (\"signed and unsigned given together for `%s'\", name);\n+\terror (\"signed and unsigned given together for %qs\", name);\n       else\n \t{\n \t  ok = 1;\n \t  if (!explicit_int && !defaulted_int && !explicit_char && pedantic)\n \t    {\n-\t      pedwarn (\"long, short, signed or unsigned used invalidly for `%s'\",\n+\t      pedwarn (\"long, short, signed or unsigned used invalidly for %qs\",\n \t\t       name);\n \t      if (flag_pedantic_errors)\n \t\tok = 0;\n@@ -6892,7 +6899,7 @@ grokdeclarator (const cp_declarator *declarator,\n   if (declspecs->specs[(int)ds_complex])\n     {\n       if (TREE_CODE (type) != INTEGER_TYPE && TREE_CODE (type) != REAL_TYPE)\n-\terror (\"complex invalid for `%s'\", name);\n+\terror (\"complex invalid for %qs\", name);\n       /* If we just have \"complex\", it is equivalent to\n \t \"complex double\", but if any modifiers at all are specified it is\n \t the complex form of TYPE.  E.g, \"complex short\" is\n@@ -6921,8 +6928,8 @@ grokdeclarator (const cp_declarator *declarator,\n   if (declspecs->specs[(int)ds_restrict])\n     type_quals |= TYPE_QUAL_RESTRICT;\n   if (sfk == sfk_conversion && type_quals != TYPE_UNQUALIFIED)\n-    error (\"qualifiers are not allowed on declaration of `operator %T'\",\n-\t      ctor_return_type);\n+    error (\"qualifiers are not allowed on declaration of %<operator %T%>\",\n+           ctor_return_type);\n \n   type_quals |= cp_type_quals (type);\n   type = cp_build_qualified_type_real\n@@ -6942,15 +6949,14 @@ grokdeclarator (const cp_declarator *declarator,\n \n   if (virtualp && staticp == 2)\n     {\n-      error (\"member `%D' cannot be declared both virtual and static\",\n-\t\tdname);\n+      error (\"member %qD cannot be declared both virtual and static\", dname);\n       staticp = 0;\n     }\n   friendp = !! declspecs->specs[(int)ds_friend];\n \n   if (dependant_name && !friendp)\n     {\n-      error (\"`%T::%D' is not a valid declarator\", ctype, dependant_name);\n+      error (\"%<%T::%D%> is not a valid declarator\", ctype, dependant_name);\n       return void_type_node;\n     }\n \n@@ -6989,7 +6995,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t&& storage_class != sc_static)\n \t       || declspecs->specs[(int)ds_typedef]))\n     {\n-      error (\"multiple storage classes in declaration of `%s'\", name);\n+      error (\"multiple storage classes in declaration of %qs\", name);\n       thread_p = false;\n     }\n   else if (decl_context != NORMAL\n@@ -7032,14 +7038,14 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\tname = \"<invalid operator>\";\n \t\t    }\n \t\t}\n-\t      error (\"storage class specified for %s `%s'\",\n+\t      error (\"storage class specified for %s %qs\",\n \t\t     op ? \"member operator\" : \"field\",\n \t\t     name);\n \t    }\n \t  else\n \t    {\n \t      if (decl_context == PARM || decl_context == CATCHPARM)\n-\t\terror (\"storage class specified for parameter `%s'\", name);\n+\t\terror (\"storage class specified for parameter %qs\", name);\n \t      else\n \t\terror (\"storage class specified for typename\");\n \t    }\n@@ -7058,24 +7064,24 @@ grokdeclarator (const cp_declarator *declarator,\n \t  /* It's common practice (and completely valid) to have a const\n \t     be initialized and declared extern.  */\n \t  if (!(type_quals & TYPE_QUAL_CONST))\n-\t    warning (\"`%s' initialized and declared `extern'\", name);\n+\t    warning (\"%qs initialized and declared %<extern%>\", name);\n \t}\n       else\n-\terror (\"`%s' has both `extern' and initializer\", name);\n+\terror (\"%qs has both %<extern%> and initializer\", name);\n     }\n   else if (storage_class == sc_extern && funcdef_flag\n \t   && ! toplevel_bindings_p ())\n-    error (\"nested function `%s' declared `extern'\", name);\n+    error (\"nested function %qs declared %<extern%>\", name);\n   else if (toplevel_bindings_p ())\n     {\n       if (storage_class == sc_auto)\n-\terror (\"top-level declaration of `%s' specifies `auto'\", name);\n+\terror (\"top-level declaration of %qs specifies %<auto%>\", name);\n     }\n   else if (thread_p\n \t   && storage_class != sc_extern\n \t   && storage_class != sc_static)\n     {\n-      error (\"function-scope `%s' implicitly auto and declared `__thread'\",\n+      error (\"function-scope %qs implicitly auto and declared %<__thread%>\",\n \t     name);\n       thread_p = false;\n     }\n@@ -7174,12 +7180,12 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t    if (TREE_CODE (type) == FUNCTION_TYPE)\n \t      {\n-\t\terror (\"`%s' declared as function returning a function\", name);\n+\t\terror (\"%qs declared as function returning a function\", name);\n \t\ttype = integer_type_node;\n \t      }\n \t    if (TREE_CODE (type) == ARRAY_TYPE)\n \t      {\n-\t\terror (\"`%s' declared as function returning an array\", name);\n+\t\terror (\"%qs declared as function returning an array\", name);\n \t\ttype = integer_type_node;\n \t      }\n \n@@ -7266,7 +7272,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    else if (friendp)\n \t      {\n \t\tif (initialized)\n-\t\t  error (\"can't initialize friend function `%s'\", name);\n+\t\t  error (\"can't initialize friend function %qs\", name);\n \t\tif (virtualp)\n \t\t  {\n \t\t    /* Cannot be both friend and virtual.  */\n@@ -7276,8 +7282,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t\tif (decl_context == NORMAL)\n \t\t  error (\"friend declaration not in class definition\");\n \t\tif (current_function_decl && funcdef_flag)\n-\t\t  error (\"can't define friend function `%s' in a local class definition\",\n-\t\t\t    name);\n+\t\t  error (\"can't define friend function %qs in a local \"\n+                         \"class definition\",\n+                         name);\n \t      }\n \n \t    arg_types = grokparms (declarator->u.function.parameters,\n@@ -7306,16 +7313,16 @@ grokdeclarator (const cp_declarator *declarator,\n \t  if (TREE_CODE (type) == REFERENCE_TYPE)\n \t    {\n \t      error (declarator->kind == cdk_reference\n-\t\t     ? \"cannot declare reference to `%#T'\"\n-\t\t     : \"cannot declare pointer to `%#T'\", type);\n+\t\t     ? \"cannot declare reference to %q#T\"\n+\t\t     : \"cannot declare pointer to %q#T\", type);\n \t      type = TREE_TYPE (type);\n \t    }\n \t  else if (VOID_TYPE_P (type))\n \t    {\n \t      if (declarator->kind == cdk_reference)\n-\t\terror (\"cannot declare reference to `%#T'\", type);\n+\t\terror (\"cannot declare reference to %q#T\", type);\n \t      else if (declarator->kind == cdk_ptrmem)\n-\t\terror (\"cannot declare pointer to `%#T' member\", type);\n+\t\terror (\"cannot declare pointer to %q#T member\", type);\n \t    }\n \n \t  /* We now know that the TYPE_QUALS don't apply to the decl,\n@@ -7371,7 +7378,7 @@ grokdeclarator (const cp_declarator *declarator,\n       && TREE_CODE (type) != FUNCTION_TYPE\n       && TREE_CODE (type) != METHOD_TYPE)\n     {\n-      error (\"template-id `%D' used as a declarator\",\n+      error (\"template-id %qD used as a declarator\",\n \t     unqualified_id);\n       unqualified_id = dname;\n     }\n@@ -7422,7 +7429,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t     Is this ill-formed?  */\n \n \t  if (pedantic)\n-\t    pedwarn (\"extra qualification `%T::' on member `%s' ignored\",\n+\t    pedwarn (\"extra qualification %<%T::%> on member %qs ignored\",\n \t\t\tctype, name);\n \t}\n       else if (TREE_CODE (type) == FUNCTION_TYPE)\n@@ -7441,7 +7448,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t\t\t    TYPE_ARG_TYPES (type));\n \t  else\n \t    {\n-\t      error (\"cannot declare member function `%T::%s' within `%T'\",\n+\t      error (\"cannot declare member function %<%T::%s%> within %<%T%>\",\n  \t\t     ctype, name, current_class_type);\n \t      return error_mark_node;\n \t    }\n@@ -7456,7 +7463,7 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t  if (current_class_type)\n \t    {\n-\t      error (\"cannot declare member `%T::%s' within `%T'\",\n+\t      error (\"cannot declare member %<%T::%s%> within %qT\",\n \t\t     ctype, name, current_class_type);\n \t      return void_type_node;\n \t    }\n@@ -7484,7 +7491,7 @@ grokdeclarator (const cp_declarator *declarator,\n       && COMPLETE_TYPE_P (type)\n       && TREE_OVERFLOW (TYPE_SIZE (type)))\n     {\n-      error (\"size of array `%s' is too large\", name);\n+      error (\"size of array %qs is too large\", name);\n       /* If we proceed with the array type as it is, we'll eventually\n \t crash in tree_low_cst().  */\n       type = error_mark_node;\n@@ -7495,46 +7502,46 @@ grokdeclarator (const cp_declarator *declarator,\n       && variably_modified_type_p (type, NULL_TREE))\n     {\n       if (decl_context == FIELD)\n-\terror (\"data member may not have variably modified type `%T'\", type);\n+\terror (\"data member may not have variably modified type %qT\", type);\n       else\n-\terror (\"parameter may not have variably modified type `%T'\", type);\n+\terror (\"parameter may not have variably modified type %qT\", type);\n       type = error_mark_node;\n     }\n \n   if (explicitp == 1 || (explicitp && friendp))\n     {\n       /* [dcl.fct.spec] The explicit specifier shall only be used in\n          declarations of constructors within a class definition.  */\n-      error (\"only declarations of constructors can be `explicit'\");\n+      error (\"only declarations of constructors can be %<explicit%>\");\n       explicitp = 0;\n     }\n \n   if (storage_class == sc_mutable)\n     {\n       if (decl_context != FIELD || friendp)\n         {\n-\t  error (\"non-member `%s' cannot be declared `mutable'\", name);\n+\t  error (\"non-member %qs cannot be declared %<mutable%>\", name);\n \t  storage_class = sc_none;\n         }\n       else if (decl_context == TYPENAME || declspecs->specs[(int)ds_typedef])\n \t{\n-\t  error (\"non-object member `%s' cannot be declared `mutable'\", name);\n+\t  error (\"non-object member %qs cannot be declared %<mutable%>\", name);\n \t  storage_class = sc_none;\n \t}\n       else if (TREE_CODE (type) == FUNCTION_TYPE\n                || TREE_CODE (type) == METHOD_TYPE)\n         {\n-\t  error (\"function `%s' cannot be declared `mutable'\", name);\n+\t  error (\"function %qs cannot be declared %<mutable%>\", name);\n \t  storage_class = sc_none;\n         }\n       else if (staticp)\n \t{\n-\t  error (\"static `%s' cannot be declared `mutable'\", name);\n+\t  error (\"static %qs cannot be declared %<mutable%>\", name);\n \t  storage_class = sc_none;\n \t}\n       else if (type_quals & TYPE_QUAL_CONST)\n \t{\n-\t  error (\"const `%s' cannot be declared `mutable'\", name);\n+\t  error (\"const %qs cannot be declared %<mutable%>\", name);\n \t  storage_class = sc_none;\n \t}\n     }\n@@ -7552,7 +7559,8 @@ grokdeclarator (const cp_declarator *declarator,\n       if (decl_context == FIELD)\n \t{\n \t  if (constructor_name_p (unqualified_id, current_class_type))\n-\t    pedwarn (\"ISO C++ forbids nested type `%D' with same name as enclosing class\",\n+\t    pedwarn (\"ISO C++ forbids nested type %qD with same name \"\n+                     \"as enclosing class\",\n \t\t     unqualified_id);\n \t  decl = build_lang_decl (TYPE_DECL, unqualified_id, type);\n \t}\n@@ -7674,7 +7682,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    }\n \t  if (inlinep)\n \t    {\n-\t      error (\"`inline' specified for friend class declaration\");\n+\t      error (\"%<inline%> specified for friend class declaration\");\n \t      inlinep = 0;\n \t    }\n \n@@ -7685,11 +7693,11 @@ grokdeclarator (const cp_declarator *declarator,\n \t\tpedwarn (\"template parameters cannot be friends\");\n \t      else if (TREE_CODE (type) == TYPENAME_TYPE)\n \t        pedwarn (\"friend declaration requires class-key, \"\n-\t\t\t \"i.e. `friend class %T::%D'\",\n+\t\t\t \"i.e. %<friend class %T::%D%>\",\n \t\t\t TYPE_CONTEXT (type), TYPENAME_TYPE_FULLNAME (type));\n \t      else\n \t        pedwarn (\"friend declaration requires class-key, \"\n-\t\t\t \"i.e. `friend %#T'\",\n+\t\t\t \"i.e. %<friend %#T%>\",\n \t\t\t type);\n \t    }\n \n@@ -7701,8 +7709,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t\tmake_friend_class (current_class_type, TYPE_MAIN_VARIANT (type),\n \t\t\t\t   /*complain=*/true);\n \t      else\n-\t\terror (\"trying to make class `%T' a friend of global scope\",\n-\t\t          type);\n+\t\terror (\"trying to make class %qT a friend of global scope\",\n+                       type);\n \n \t      type = void_type_node;\n \t    }\n@@ -7731,7 +7739,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t   && TREE_CODE (type) != UNION_TYPE\n \t   && ! bitfield)\n     {\n-      error (\"abstract declarator `%T' used as declaration\", type);\n+      error (\"abstract declarator %qT used as declaration\", type);\n       unqualified_id = make_anon_name ();\n     }\n \n@@ -7747,7 +7755,7 @@ grokdeclarator (const cp_declarator *declarator,\n       else if (TREE_CODE (unqualified_id) == IDENTIFIER_NODE)\n \t{\n \t  gcc_assert (!IDENTIFIER_OPNAME_P (unqualified_id));\n-\t  error (\"variable or field `%s' declared void\", name);\n+\t  error (\"variable or field %qs declared void\", name);\n \t}\n       else\n \terror (\"variable or field declared void\");\n@@ -7760,7 +7768,7 @@ grokdeclarator (const cp_declarator *declarator,\n   if (decl_context == PARM || decl_context == CATCHPARM)\n     {\n       if (ctype || in_namespace)\n-\terror (\"cannot use `::' in parameter declaration\");\n+\terror (\"cannot use %<::%> in parameter declaration\");\n \n       /* A parameter declared as an array of T is really a pointer to T.\n \t One declared as a function is really a pointer to a function.\n@@ -7805,7 +7813,7 @@ grokdeclarator (const cp_declarator *declarator,\n \telse if (in_namespace && !friendp)\n \t  {\n \t    /* Something like struct S { int N::j; };  */\n-\t    error (\"invalid use of `::'\");\n+\t    error (\"invalid use of %<::%>\");\n \t    decl = NULL_TREE;\n \t  }\n \telse if (TREE_CODE (type) == FUNCTION_TYPE)\n@@ -7817,7 +7825,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t       typedefs.  */\n \t    if (friendp && unqualified_id == ridpointers[(int) RID_SIGNED])\n \t      {\n-\t\terror (\"function `%D' cannot be declared friend\",\n+\t\terror (\"function %qD cannot be declared friend\",\n \t\t       unqualified_id);\n \t\tfriendp = 0;\n \t      }\n@@ -7829,7 +7837,7 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t\tif (ctype == NULL_TREE)\n \t\t  {\n-\t\t    error (\"can't make `%D' into a method -- not in a class\",\n+\t\t    error (\"can't make %qD into a method -- not in a class\",\n \t\t\t   unqualified_id);\n \t\t    return void_type_node;\n \t\t  }\n@@ -7838,7 +7846,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t   ARM 9.5 */\n \t\tif (virtualp && TREE_CODE (ctype) == UNION_TYPE)\n \t\t  {\n-\t\t    error (\"function `%D' declared virtual inside a union\",\n+\t\t    error (\"function %qD declared virtual inside a union\",\n \t\t\t   unqualified_id);\n \t\t    return void_type_node;\n \t\t  }\n@@ -7847,7 +7855,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  {\n \t\t    if (virtualp)\n \t\t      {\n-\t\t\terror (\"`%D' cannot be declared virtual, since it is always static\",\n+\t\t\terror (\"%qD cannot be declared virtual, since it \"\n+                               \"is always static\",\n \t\t\t       unqualified_id);\n \t\t\tvirtualp = 0;\n \t\t      }\n@@ -7926,9 +7935,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t && (TREE_CODE (type) != ARRAY_TYPE || initialized == 0))\n \t  {\n \t    if (unqualified_id)\n-\t      error (\"field `%D' has incomplete type\", unqualified_id);\n+\t      error (\"field %qD has incomplete type\", unqualified_id);\n \t    else\n-\t      error (\"name `%T' has incomplete type\", type);\n+\t      error (\"name %qT has incomplete type\", type);\n \n \t    /* If we're instantiating a template, tell them which\n \t       instantiation made the field's type be incomplete.  */\n@@ -7937,8 +7946,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t&& IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (current_class_type))\n \t\t&& declspecs->type\n \t\t&& declspecs->type == type)\n-\t      error (\"  in instantiation of template `%T'\",\n-\t\t\tcurrent_class_type);\n+\t      error (\"  in instantiation of template %qT\",\n+                     current_class_type);\n \n \t    type = error_mark_node;\n \t    decl = NULL_TREE;\n@@ -7947,7 +7956,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  {\n \t    if (friendp)\n \t      {\n-\t\terror (\"`%E' is neither function nor member function; \"\n+\t\terror (\"%qE is neither function nor member function; \"\n                        \"cannot be declared friend\", unqualified_id);\n \t\tfriendp = 0;\n \t      }\n@@ -7998,9 +8007,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t       the rest of the compiler does not correctly\n \t\t       handle the initialization unless the member is\n \t\t       static so we make it static below.  */\n-\t\t    pedwarn (\"ISO C++ forbids initialization of member `%D'\",\n+\t\t    pedwarn (\"ISO C++ forbids initialization of member %qD\",\n \t\t\t     unqualified_id);\n-\t\t    pedwarn (\"making `%D' static\", unqualified_id);\n+\t\t    pedwarn (\"making %qD static\", unqualified_id);\n \t\t    staticp = 1;\n \t\t  }\n \n@@ -8058,11 +8067,11 @@ grokdeclarator (const cp_declarator *declarator,\n \t  original_name = unqualified_id;\n \n \tif (storage_class == sc_auto)\n-\t  error (\"storage class `auto' invalid for function `%s'\", name);\n+\t  error (\"storage class %<auto%> invalid for function %qs\", name);\n \telse if (storage_class == sc_register)\n-\t  error (\"storage class `register' invalid for function `%s'\", name);\n+\t  error (\"storage class %<register%> invalid for function %qs\", name);\n \telse if (thread_p)\n-\t  error (\"storage class `__thread' invalid for function `%s'\", name);\n+\t  error (\"storage class %<__thread%> invalid for function %qs\", name);\n \n \t/* Function declaration not at top level.\n \t   Storage classes other than `extern' are not allowed\n@@ -8073,16 +8082,18 @@ grokdeclarator (const cp_declarator *declarator,\n \t    && pedantic)\n \t  {\n \t    if (storage_class == sc_static)\n-\t      pedwarn (\"`static' specified invalid for function `%s' declared out of global scope\", name);\n+\t      pedwarn (\"%<static%> specified invalid for function %qs \"\n+                       \"declared out of global scope\", name);\n \t    else\n-\t      pedwarn (\"`inline' specifier invalid for function `%s' declared out of global scope\", name);\n+\t      pedwarn (\"%<inline%> specifier invalid for function %qs \"\n+                       \"declared out of global scope\", name);\n \t  }\n \n \tif (ctype == NULL_TREE)\n \t  {\n \t    if (virtualp)\n \t      {\n-\t\terror (\"virtual non-class function `%s'\", name);\n+\t\terror (\"virtual non-class function %qs\", name);\n \t\tvirtualp = 0;\n \t      }\n \t  }\n@@ -8113,7 +8124,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t       declaring main to be static.  */\n \t    if (TREE_CODE (type) == METHOD_TYPE)\n \t      {\n-\t\tpedwarn (\"cannot declare member function `%D' to have static linkage\", decl);\n+\t\tpedwarn (\"cannot declare member function %qD to have \"\n+                         \"static linkage\", decl);\n \t\tinvalid_static = 1;\n \t      }\n \t    else if (current_function_decl)\n@@ -8148,19 +8160,21 @@ grokdeclarator (const cp_declarator *declarator,\n \t    DECL_CONTEXT (decl) = ctype;\n \t    if (staticp == 1)\n \t      {\n-                pedwarn (\"`static' may not be used when defining (as opposed to declaring) a static data member\");\n+                pedwarn (\"%<static%> may not be used when defining \"\n+                         \"(as opposed to declaring) a static data member\");\n \t        staticp = 0;\n \t\tstorage_class = sc_none;\n \t      }\n \t    if (storage_class == sc_register && TREE_STATIC (decl))\n \t      {\n-\t\terror (\"static member `%D' declared `register'\", decl);\n+\t\terror (\"static member %qD declared %<register%>\", decl);\n \t\tstorage_class = sc_none;\n \t      }\n \t    if (storage_class == sc_extern && pedantic)\n \t      {\n-\t        pedwarn (\"cannot explicitly declare member `%#D' to have extern linkage\",\n-\t\t\t    decl);\n+\t        pedwarn (\"cannot explicitly declare member %q#D to have \"\n+                         \"extern linkage\",\n+                         decl);\n \t\tstorage_class = sc_none;\n \t      }\n \t  }\n@@ -8299,11 +8313,11 @@ check_default_argument (tree decl, tree arg)\n       || !can_convert_arg (decl_type, TREE_TYPE (arg), arg))\n     {\n       if (decl)\n-\terror (\"default argument for `%#D' has type `%T'\",\n-\t\t  decl, TREE_TYPE (arg));\n+\terror (\"default argument for %q#D has type %qT\",\n+               decl, TREE_TYPE (arg));\n       else\n-\terror (\"default argument for parameter of type `%T' has type `%T'\",\n-\t\t  decl_type, TREE_TYPE (arg));\n+\terror (\"default argument for parameter of type %qT has type %qT\",\n+               decl_type, TREE_TYPE (arg));\n \n       return error_mark_node;\n     }\n@@ -8319,8 +8333,7 @@ check_default_argument (tree decl, tree arg)\n \t\t\t\t      NULL);\n   if (var)\n     {\n-      error (\"default argument `%E' uses local variable `%D'\",\n-\t\targ, var);\n+      error (\"default argument %qE uses local variable %qD\", arg, var);\n       return error_mark_node;\n     }\n \n@@ -8388,7 +8401,7 @@ grokparms (cp_parameter_declarator *first_parm, tree *parms)\n \t  type = cp_build_qualified_type (type, 0);\n \t  if (TREE_CODE (type) == METHOD_TYPE)\n \t    {\n-\t      error (\"parameter `%D' invalidly declared method type\", decl);\n+\t      error (\"parameter %qD invalidly declared method type\", decl);\n \t      type = build_pointer_type (type);\n \t      TREE_TYPE (decl) = type;\n \t    }\n@@ -8412,8 +8425,9 @@ grokparms (cp_parameter_declarator *first_parm, tree *parms)\n \t          t = TREE_TYPE (t);\n \t        }\n \t      if (TREE_CODE (t) == ARRAY_TYPE)\n-\t\terror (\"parameter `%D' includes %s to array of unknown bound `%T'\",\n-\t\t\t  decl, ptr ? \"pointer\" : \"reference\", t);\n+\t\terror (\"parameter %qD includes %s to array of unknown \"\n+                       \"bound %qT\",\n+                       decl, ptr ? \"pointer\" : \"reference\", t);\n \t    }\n \n \t  if (!any_error && init)\n@@ -8569,7 +8583,7 @@ grok_ctor_properties (tree ctype, tree decl)\n      \t or implicitly defined), there's no need to worry about their\n      \t existence.  Theoretically, they should never even be\n      \t instantiated, but that's hard to forestall.  */\n-      error (\"invalid constructor; you probably meant `%T (const %T&)'\",\n+      error (\"invalid constructor; you probably meant %<%T (const %T&)%>\",\n \t\tctype, ctype);\n       return 0;\n     }\n@@ -8693,9 +8707,9 @@ grok_op_properties (tree decl, int friendp, bool complain)\n       if (DECL_NAMESPACE_SCOPE_P (decl))\n \t{\n \t  if (CP_DECL_CONTEXT (decl) != global_namespace)\n-\t    error (\"`%D' may not be declared within a namespace\", decl);\n+\t    error (\"%qD may not be declared within a namespace\", decl);\n \t  else if (!TREE_PUBLIC (decl))\n-\t    error (\"`%D' may not be declared as static\", decl);\n+\t    error (\"%qD may not be declared as static\", decl);\n \t}\n     }\n \n@@ -8715,13 +8729,14 @@ grok_op_properties (tree decl, int friendp, bool complain)\n \t      || operator_code == COMPONENT_REF\n \t      || operator_code == ARRAY_REF\n \t      || operator_code == NOP_EXPR)\n-\t    error (\"`%D' must be a nonstatic member function\", decl);\n+\t    error (\"%qD must be a nonstatic member function\", decl);\n \t  else\n \t    {\n \t      tree p;\n \n \t      if (DECL_STATIC_FUNCTION_P (decl))\n-\t\terror (\"`%D' must be either a non-static member function or a non-member function\", decl);\n+\t\terror (\"%qD must be either a non-static member \"\n+                       \"function or a non-member function\", decl);\n \n \t      for (p = argtypes; p && p != void_list_node; p = TREE_CHAIN (p))\n \t\t{\n@@ -8738,7 +8753,7 @@ grok_op_properties (tree decl, int friendp, bool complain)\n \t\t  if (!complain)\n \t\t    return false;\n \n-\t\t  error (\"`%D' must have an argument of class or \"\n+\t\t  error (\"%qD must have an argument of class or \"\n \t\t\t \"enumerated type\",\n \t\t\t decl);\n \t\t  ok = false;\n@@ -8773,7 +8788,8 @@ grok_op_properties (tree decl, int friendp, bool complain)\n \t\twhat = \"a base class\";\n \n \t      if (what && warn_conversion)\n-\t\twarning (\"conversion to %s%s will never use a type conversion operator\",\n+\t\twarning (\"conversion to %s%s will never use a type \"\n+                         \"conversion operator\",\n \t\t\t ref ? \"a reference to \" : \"\", what);\n \t    }\n \t}\n@@ -8830,20 +8846,20 @@ grok_op_properties (tree decl, int friendp, bool complain)\n \t\t  && ! same_type_p (TREE_VALUE (TREE_CHAIN (argtypes)), integer_type_node))\n \t\t{\n \t\t  if (methodp)\n-\t\t    error (\"postfix `%D' must take `int' as its argument\",\n+\t\t    error (\"postfix %qD must take %<int%> as its argument\",\n \t\t\t      decl);\n \t\t  else\n \t\t    error\n-\t\t      (\"postfix `%D' must take `int' as its second argument\",\n+\t\t      (\"postfix %qD must take %<int%> as its second argument\",\n \t\t       decl);\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      if (methodp)\n-\t\terror (\"`%D' must take either zero or one argument\", decl);\n+\t\terror (\"%qD must take either zero or one argument\", decl);\n \t      else\n-\t\terror (\"`%D' must take either one or two arguments\", decl);\n+\t\terror (\"%qD must take either one or two arguments\", decl);\n \t    }\n \n \t  /* More Effective C++ rule 6.  */\n@@ -8864,13 +8880,13 @@ grok_op_properties (tree decl, int friendp, bool complain)\n \t\t  if (TREE_CODE (ret) != REFERENCE_TYPE\n \t\t      || !same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (ret)),\n \t\t\t\t       arg))\n-\t\t    warning (\"prefix `%D' should return `%T'\", decl,\n-\t\t\t\tbuild_reference_type (arg));\n+\t\t    warning (\"prefix %qD should return %qT\", decl,\n+                             build_reference_type (arg));\n \t\t}\n \t      else\n \t\t{\n \t\t  if (!same_type_p (TYPE_MAIN_VARIANT (ret), arg))\n-\t\t    warning (\"postfix `%D' should return `%T'\", decl, arg);\n+\t\t    warning (\"postfix %qD should return %qT\", decl, arg);\n \t\t}\n \t    }\n \t}\n@@ -8879,28 +8895,28 @@ grok_op_properties (tree decl, int friendp, bool complain)\n \t  if (arity != 1)\n \t    {\n \t      if (methodp)\n-\t\terror (\"`%D' must take `void'\", decl);\n+\t\terror (\"%qD must take %<void%>\", decl);\n \t      else\n-\t\terror (\"`%D' must take exactly one argument\", decl);\n+\t\terror (\"%qD must take exactly one argument\", decl);\n \t    }\n \t}\n       else /* if (binary_op_p (operator_code)) */\n \t{\n \t  if (arity != 2)\n \t    {\n \t      if (methodp)\n-\t\terror (\"`%D' must take exactly one argument\", decl);\n+\t\terror (\"%qD must take exactly one argument\", decl);\n \t      else\n-\t\terror (\"`%D' must take exactly two arguments\", decl);\n+\t\terror (\"%qD must take exactly two arguments\", decl);\n \t    }\n \n \t  /* More Effective C++ rule 7.  */\n \t  if (warn_ecpp\n \t      && (operator_code == TRUTH_ANDIF_EXPR\n \t\t  || operator_code == TRUTH_ORIF_EXPR\n \t\t  || operator_code == COMPOUND_EXPR))\n-\t    warning (\"user-defined `%D' always evaluates both arguments\",\n-\t\t\tdecl);\n+\t    warning (\"user-defined %qD always evaluates both arguments\",\n+                     decl);\n \t}\n \n       /* Effective C++ rule 23.  */\n@@ -8913,7 +8929,7 @@ grok_op_properties (tree decl, int friendp, bool complain)\n \t      || operator_code == MULT_EXPR\n \t      || operator_code == TRUNC_MOD_EXPR)\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) == REFERENCE_TYPE)\n-\twarning (\"`%D' should return by value\", decl);\n+\twarning (\"%qD should return by value\", decl);\n \n       /* [over.oper]/8 */\n       for (; argtypes && argtypes != void_list_node;\n@@ -8925,10 +8941,10 @@ grok_op_properties (tree decl, int friendp, bool complain)\n \t\t|| operator_code == POSTDECREMENT_EXPR)\n               {\n                 if (pedantic)\n-                  pedwarn (\"`%D' cannot have default arguments\", decl);\n+                  pedwarn (\"%qD cannot have default arguments\", decl);\n               }\n             else\n-              error (\"`%D' cannot have default arguments\", decl);\n+              error (\"%qD cannot have default arguments\", decl);\n           }\n \n     }\n@@ -8988,27 +9004,27 @@ check_elaborated_type_specifier (enum tag_types tag_code,\n      the type is declared.  */\n   if (!DECL_IMPLICIT_TYPEDEF_P (decl))\n     {\n-      error (\"using typedef-name `%D' after `%s'\", decl, tag_name (tag_code));\n+      error (\"using typedef-name %qD after %qs\", decl, tag_name (tag_code));\n       return IS_AGGR_TYPE (type) ? type : error_mark_node;\n     }\n \n   if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n     {\n-      error (\"using template type parameter `%T' after `%s'\",\n+      error (\"using template type parameter %qT after %qs\",\n \t     type, tag_name (tag_code));\n       return error_mark_node;\n     }\n   else if (TREE_CODE (type) != RECORD_TYPE\n \t   && TREE_CODE (type) != UNION_TYPE\n \t   && tag_code != enum_type)\n     {\n-      error (\"`%T' referred to as `%s'\", type, tag_name (tag_code));\n+      error (\"%qT referred to as %qs\", type, tag_name (tag_code));\n       return error_mark_node;\n     }\n   else if (TREE_CODE (type) != ENUMERAL_TYPE\n \t   && tag_code == enum_type)\n     {\n-      error (\"`%T' referred to as enum\", type);\n+      error (\"%qT referred to as enum\", type);\n       return error_mark_node;\n     }\n   else if (!allow_template_p\n@@ -9023,7 +9039,7 @@ check_elaborated_type_specifier (enum tag_types tag_code,\n \n \t then the required template argument is missing.  */\n \n-      error (\"template argument required for `%s %T'\",\n+      error (\"template argument required for %<%s %T%>\",\n \t     tag_name (tag_code),\n \t     DECL_NAME (CLASSTYPE_TI_TEMPLATE (type)));\n       return error_mark_node;\n@@ -9168,7 +9184,7 @@ xref_tag (enum tag_types tag_code, tree name,\n \t the forward-reference will be altered into a real type.  */\n       if (code == ENUMERAL_TYPE)\n \t{\n-\t  error (\"use of enum `%#D' without previous declaration\", name);\n+\t  error (\"use of enum %q#D without previous declaration\", name);\n \t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \t}\n       else\n@@ -9186,7 +9202,7 @@ xref_tag (enum tag_types tag_code, tree name,\n \t       && CLASS_TYPE_P (t)\n \t       && CLASSTYPE_IS_TEMPLATE (t))\n \t{\n-\t  error (\"redeclaration of `%T' as a non-template\", t);\n+\t  error (\"redeclaration of %qT as a non-template\", t);\n \t  t = error_mark_node;\n \t}\n     }\n@@ -9279,21 +9295,21 @@ xref_basetypes (tree ref, tree base_list)\n       CLASSTYPE_NON_AGGREGATE (ref) = 1;\n \n       if (TREE_CODE (ref) == UNION_TYPE)\n-\terror (\"derived union `%T' invalid\", ref);\n+\terror (\"derived union %qT invalid\", ref);\n     }\n \n   if (max_bases > 1)\n     {\n       if (TYPE_FOR_JAVA (ref))\n-\terror (\"Java class '%T' cannot have multiple bases\", ref);\n+\terror (\"Java class %qT cannot have multiple bases\", ref);\n     }\n \n   if (max_vbases)\n     {\n       CLASSTYPE_VBASECLASSES (ref) = VEC_alloc (tree, max_vbases);\n \n       if (TYPE_FOR_JAVA (ref))\n-\terror (\"Java class '%T' cannot have virtual bases\", ref);\n+\terror (\"Java class %qT cannot have virtual bases\", ref);\n     }\n \n   for (igo_prev = binfo; base_list; base_list = TREE_CHAIN (base_list))\n@@ -9312,7 +9328,7 @@ xref_basetypes (tree ref, tree base_list)\n \t  && TREE_CODE (basetype) != TEMPLATE_TYPE_PARM\n \t  && TREE_CODE (basetype) != BOUND_TEMPLATE_TEMPLATE_PARM)\n \t{\n-\t  error (\"base type `%T' fails to be a struct or class type\",\n+\t  error (\"base type %qT fails to be a struct or class type\",\n \t\t basetype);\n \t  continue;\n \t}\n@@ -9345,9 +9361,9 @@ xref_basetypes (tree ref, tree base_list)\n       if (TYPE_MARKED_P (basetype))\n \t{\n \t  if (basetype == ref)\n-\t    error (\"recursive type `%T' undefined\", basetype);\n+\t    error (\"recursive type %qT undefined\", basetype);\n \t  else\n-\t    error (\"duplicate base type `%T' invalid\", basetype);\n+\t    error (\"duplicate base type %qT invalid\", basetype);\n \t  continue;\n \t}\n       TYPE_MARKED_P (basetype) = 1;\n@@ -9415,7 +9431,7 @@ start_enum (tree name)\n \n   if (enumtype != NULL_TREE && TREE_CODE (enumtype) == ENUMERAL_TYPE)\n     {\n-      error (\"multiple definition of `%#T'\", enumtype);\n+      error (\"multiple definition of %q#T\", enumtype);\n       error (\"%Jprevious definition here\", TYPE_MAIN_DECL (enumtype));\n       /* Clear out TYPE_VALUES, and start again.  */\n       TYPE_VALUES (enumtype) = NULL_TREE;\n@@ -9542,7 +9558,7 @@ finish_enum (tree enumtype)\n \t IF no integral type can represent all the enumerator values, the\n \t enumeration is ill-formed.  */\n       error (\"no integral type can represent all of the enumerator values \"\n-\t     \"for `%T'\", enumtype);\n+\t     \"for %qT\", enumtype);\n       precision = TYPE_PRECISION (long_long_integer_type_node);\n       underlying_type = integer_types[itk_unsigned_long_long];\n     }\n@@ -9642,7 +9658,7 @@ build_enumerator (tree name, tree value, tree enumtype)\n \t    }\n \t  else\n \t    {\n-\t      error (\"enumerator value for `%D' not integer constant\", name);\n+\t      error (\"enumerator value for %qD not integer constant\", name);\n \t      value = NULL_TREE;\n \t    }\n \t}\n@@ -9669,7 +9685,7 @@ build_enumerator (tree name, tree value, tree enumtype)\n \t      overflowed |= !int_fits_type_p (value, TREE_TYPE (prev_value));\n \n \t      if (overflowed)\n-\t\terror (\"overflow in enumeration values at `%D'\", name);\n+\t\terror (\"overflow in enumeration values at %qD\", name);\n \t    }\n \t  else\n \t    value = integer_zero_node;\n@@ -9740,7 +9756,7 @@ check_function_type (tree decl, tree current_function_parms)\n \n   if (!COMPLETE_OR_VOID_TYPE_P (return_type))\n     {\n-      error (\"return type `%#T' is incomplete\", TREE_TYPE (fntype));\n+      error (\"return type %q#T is incomplete\", TREE_TYPE (fntype));\n \n       /* Make it return void instead, but don't change the\n \t type of the DECL_RESULT, in case we have a named return value.  */\n@@ -9818,7 +9834,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \n   if (DECL_DECLARED_INLINE_P (decl1)\n       && lookup_attribute (\"noinline\", attrs))\n-    warning (\"%Jinline function '%D' given attribute noinline\", decl1, decl1);\n+    warning (\"%Jinline function %qD given attribute noinline\", decl1, decl1);\n \n   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl1))\n     /* This is a constructor, we must ensure that any default args\n@@ -9855,7 +9871,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n   if (warn_ecpp\n       && DECL_OVERLOADED_OPERATOR_P (decl1) == NOP_EXPR\n       && TREE_CODE (TREE_TYPE (fntype)) == VOID_TYPE)\n-    warning (\"`operator=' should return a reference to `*this'\");\n+    warning (\"%<operator=%> should return a reference to %<*this%>\");\n \n   /* Make the init_value nonzero so pushdecl knows this is not tentative.\n      error_mark_node is replaced below (in poplevel) with the BLOCK.  */\n@@ -10179,7 +10195,7 @@ store_parm_decls (tree current_function_parms)\n \t\t  || TREE_CODE (parm) != VOID_TYPE)\n \t\tpushdecl (parm);\n \t      else\n-\t\terror (\"parameter `%D' declared void\", parm);\n+\t\terror (\"parameter %qD declared void\", parm);\n \t    }\n \t  else\n \t    {\n@@ -10676,7 +10692,7 @@ start_method (cp_decl_specifier_seq *declspecs,\n     {\n       if (DECL_CONTEXT (fndecl)\n \t  && TREE_CODE( DECL_CONTEXT (fndecl)) != NAMESPACE_DECL)\n-\terror (\"`%D' is already defined in class `%T'\", fndecl,\n+\terror (\"%qD is already defined in class %qT\", fndecl,\n \t       DECL_CONTEXT (fndecl));\n       return void_type_node;\n     }"}, {"sha": "3c1f9b4ed9ae92d15a29888a6aae8437161151dc", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=2d01edd7600090f4c938d232da3df3aeff3e1fe8", "patch": "@@ -378,8 +378,8 @@ grok_array_decl (tree array_expr, tree index_exp)\n \tarray_expr = p2, index_exp = i1;\n       else\n \t{\n-\t  error (\"invalid types `%T[%T]' for array subscript\",\n-\t\t    type, TREE_TYPE (index_exp));\n+\t  error (\"invalid types %<%T[%T]%> for array subscript\",\n+                 type, TREE_TYPE (index_exp));\n \t  return error_mark_node;\n \t}\n \n@@ -423,14 +423,14 @@ delete_sanity (tree exp, tree size, bool doing_vec, int use_global_delete)\n   /* An array can't have been allocated by new, so complain.  */\n   if (TREE_CODE (exp) == VAR_DECL\n       && TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)\n-    warning (\"deleting array `%#D'\", exp);\n+    warning (\"deleting array %q#D\", exp);\n \n   t = build_expr_type_conversion (WANT_POINTER, exp, true);\n \n   if (t == NULL_TREE || t == error_mark_node)\n     {\n-      error (\"type `%#T' argument given to `delete', expected pointer\",\n-\t\tTREE_TYPE (exp));\n+      error (\"type %q#T argument given to %<delete%>, expected pointer\",\n+             TREE_TYPE (exp));\n       return error_mark_node;\n     }\n \n@@ -441,14 +441,15 @@ delete_sanity (tree exp, tree size, bool doing_vec, int use_global_delete)\n   /* You can't delete functions.  */\n   if (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n     {\n-      error (\"cannot delete a function.  Only pointer-to-objects are valid arguments to `delete'\");\n+      error (\"cannot delete a function.  Only pointer-to-objects are \"\n+             \"valid arguments to %<delete%>\");\n       return error_mark_node;\n     }\n \n   /* Deleting ptr to void is undefined behavior [expr.delete/3].  */\n   if (TREE_CODE (TREE_TYPE (type)) == VOID_TYPE)\n     {\n-      warning (\"deleting `%T' is undefined\", type);\n+      warning (\"deleting %qT is undefined\", type);\n       doing_vec = 0;\n     }\n \n@@ -484,16 +485,16 @@ check_member_template (tree tmpl)\n \t/* 14.5.2.2 [temp.mem]\n \t   \n \t   A local class shall not have member templates.  */\n-\terror (\"invalid declaration of member template `%#D' in local class\",\n-\t\t  decl);\n+\terror (\"invalid declaration of member template %q#D in local class\",\n+               decl);\n       \n       if (TREE_CODE (decl) == FUNCTION_DECL && DECL_VIRTUAL_P (decl))\n \t{\n \t  /* 14.5.2.3 [temp.mem]\n \n \t     A member function template shall not be virtual.  */\n \t  error \n-\t    (\"invalid use of `virtual' in template declaration of `%#D'\",\n+\t    (\"invalid use of %<virtual%> in template declaration of %q#D\",\n \t     decl);\n \t  DECL_VIRTUAL_P (decl) = 0;\n \t}\n@@ -503,7 +504,7 @@ check_member_template (tree tmpl)\n       DECL_IGNORED_P (tmpl) = 1;\n     } \n   else\n-    error (\"template declaration of `%#D'\", decl);\n+    error (\"template declaration of %q#D\", decl);\n }\n \n /* Return true iff TYPE is a valid Java parameter or return type.  */\n@@ -552,8 +553,8 @@ check_java_method (tree method)\n \n   if (!acceptable_java_type (ret_type))\n     {\n-      error (\"Java method '%D' has non-Java return type `%T'\",\n-\t\tmethod, ret_type);\n+      error (\"Java method %qD has non-Java return type %qT\",\n+             method, ret_type);\n       jerr = true;\n     }\n \n@@ -568,8 +569,8 @@ check_java_method (tree method)\n       tree type = TREE_VALUE (arg_types);\n       if (!acceptable_java_type (type))\n \t{\n-\t  error (\"Java method '%D' has non-Java parameter type `%T'\",\n-\t\t    method, type);\n+          error (\"Java method %qD has non-Java parameter type %qT\",\n+                 method, type);\n \t  jerr = true;\n \t}\n     }\n@@ -715,7 +716,7 @@ check_classfn (tree ctype, tree function, tree template_parms)\n   else if (!COMPLETE_TYPE_P (ctype))\n     cxx_incomplete_type_error (function, ctype);\n   else\n-    error (\"no `%#D' member function declared in class `%T'\",\n+    error (\"no %q#D member function declared in class %qT\",\n \t   function, ctype);\n \n   /* If we did not find the method in the class, add it to avoid\n@@ -778,7 +779,7 @@ finish_static_data_member_decl (tree decl, tree init, tree asmspec_tree,\n     note_vague_linkage_var (decl);\n \n   if (LOCAL_CLASS_P (current_class_type))\n-    pedwarn (\"local class `%#T' shall not have static data member `%#D'\",\n+    pedwarn (\"local class %q#T shall not have static data member %q#D\",\n \t     current_class_type, decl);\n \n   /* Static consts need not be initialized in the class definition.  */\n@@ -853,7 +854,7 @@ grokfield (const cp_declarator *declarator,\n \n   if (TREE_CODE (value) == TYPE_DECL && init)\n     {\n-      error (\"typedef `%D' is initialized (use __typeof__ instead)\", value);\n+      error (\"typedef %qD is initialized (use __typeof__ instead)\", value);\n       init = NULL_TREE;\n     }\n \n@@ -870,8 +871,8 @@ grokfield (const cp_declarator *declarator,\n   if (DECL_NAME (value) != NULL_TREE\n       && IDENTIFIER_POINTER (DECL_NAME (value))[0] == '_'\n       && ! strcmp (IDENTIFIER_POINTER (DECL_NAME (value)), \"_vptr\"))\n-    error (\"member `%D' conflicts with virtual function table field name\",\n-\t      value);\n+    error (\"member %qD conflicts with virtual function table field name\",\n+           value);\n \n   /* Stash away type declarations.  */\n   if (TREE_CODE (value) == TYPE_DECL)\n@@ -887,8 +888,7 @@ grokfield (const cp_declarator *declarator,\n \n   if (DECL_IN_AGGR_P (value))\n     {\n-      error (\"`%D' is already defined in `%T'\", value,\n-\t\tDECL_CONTEXT (value));\n+      error (\"%qD is already defined in %qT\", value, DECL_CONTEXT (value));\n       return void_type_node;\n     }\n \n@@ -1008,7 +1008,7 @@ grokbitfield (const cp_declarator *declarator,\n \n   if (TREE_CODE (value) == TYPE_DECL)\n     {\n-      error (\"cannot declare `%D' to be a bit-field type\", value);\n+      error (\"cannot declare %qD to be a bit-field type\", value);\n       return NULL_TREE;\n     }\n \n@@ -1018,21 +1018,21 @@ grokbitfield (const cp_declarator *declarator,\n      check here.  */\n   if (TREE_CODE (value) == FUNCTION_DECL)\n     {\n-      error (\"cannot declare bit-field `%D' with function type\",\n+      error (\"cannot declare bit-field %qD with function type\",\n \t     DECL_NAME (value));\n       return NULL_TREE;\n     }\n \n   if (DECL_IN_AGGR_P (value))\n     {\n-      error (\"`%D' is already defined in the class %T\", value,\n-\t\t  DECL_CONTEXT (value));\n+      error (\"%qD is already defined in the class %qT\", value,\n+             DECL_CONTEXT (value));\n       return void_type_node;\n     }\n \n   if (TREE_STATIC (value))\n     {\n-      error (\"static member `%D' cannot be a bit-field\", value);\n+      error (\"static member %qD cannot be a bit-field\", value);\n       return NULL_TREE;\n     }\n   cp_finish_decl (value, NULL_TREE, NULL_TREE, 0);\n@@ -1091,11 +1091,11 @@ grok_function_init (tree decl, tree init)\n   tree type = TREE_TYPE (decl);\n \n   if (TREE_CODE (type) == FUNCTION_TYPE)\n-    error (\"initializer specified for non-member function `%D'\", decl);\n+    error (\"initializer specified for non-member function %qD\", decl);\n   else if (integer_zerop (init))\n     DECL_PURE_VIRTUAL_P (decl) = 1;\n   else\n-    error (\"invalid initializer for virtual method `%D'\", decl);\n+    error (\"invalid initializer for virtual method %qD\", decl);\n }\n \f\n void\n@@ -1140,16 +1140,16 @@ build_anon_union_vars (tree object)\n \tcontinue;\n       if (TREE_CODE (field) != FIELD_DECL)\n \t{\n-\t  cp_pedwarn_at (\"\\\n-`%#D' invalid; an anonymous union can only have non-static data members\",\n+\t  cp_pedwarn_at (\"%q#D invalid; an anonymous union can only \"\n+                         \"have non-static data members\",\n \t\t\t field);\n \t  continue;\n \t}\n \n       if (TREE_PRIVATE (field))\n-\tcp_pedwarn_at (\"private member `%#D' in anonymous union\", field);\n+\tcp_pedwarn_at (\"private member %q#D in anonymous union\", field);\n       else if (TREE_PROTECTED (field))\n-\tcp_pedwarn_at (\"protected member `%#D' in anonymous union\", field);\n+\tcp_pedwarn_at (\"protected member %q#D in anonymous union\", field);\n \n       if (processing_template_decl)\n \tref = build_min_nt (COMPONENT_REF, object,\n@@ -1239,15 +1239,19 @@ coerce_new_type (tree type)\n   gcc_assert (TREE_CODE (type) == FUNCTION_TYPE);\n   \n   if (!same_type_p (TREE_TYPE (type), ptr_type_node))\n-    e = 1, error (\"`operator new' must return type `%T'\", ptr_type_node);\n+    {\n+      e = 1;\n+      error (\"%<operator new%> must return type %qT\", ptr_type_node);\n+    }\n \n   if (!args || args == void_list_node\n       || !same_type_p (TREE_VALUE (args), size_type_node))\n     {\n       e = 2;\n       if (args && args != void_list_node)\n         args = TREE_CHAIN (args);\n-      pedwarn (\"`operator new' takes type `size_t' (`%T') as first parameter\", size_type_node);\n+      pedwarn (\"%<operator new%> takes type %<size_t%> (%qT) \"\n+               \"as first parameter\", size_type_node);\n     }\n   switch (e)\n   {\n@@ -1273,15 +1277,19 @@ coerce_delete_type (tree type)\n   gcc_assert (TREE_CODE (type) == FUNCTION_TYPE);\n \n   if (!same_type_p (TREE_TYPE (type), void_type_node))\n-    e = 1, error (\"`operator delete' must return type `%T'\", void_type_node);\n+    {\n+      e = 1;\n+      error (\"%<operator delete%> must return type %qT\", void_type_node);\n+    }\n \n   if (!args || args == void_list_node\n       || !same_type_p (TREE_VALUE (args), ptr_type_node))\n     {\n       e = 2;\n       if (args && args != void_list_node)\n         args = TREE_CHAIN (args);\n-      error (\"`operator delete' takes type `%T' as first parameter\", ptr_type_node);\n+      error (\"%<operator delete%> takes type %qT as first parameter\",\n+             ptr_type_node);\n     }\n   switch (e)\n   {\n@@ -3167,7 +3175,7 @@ check_default_args (tree x)\n \tsaw_def = true;\n       else if (saw_def)\n \t{\n-\t  cp_error_at (\"default argument missing for parameter %P of `%+#D'\",\n+\t  cp_error_at (\"default argument missing for parameter %P of %q+#D\",\n \t\t       i, x);\n \t  break;\n \t}"}, {"sha": "192855de52a0013ffcb41e97020edb0a25212ab8", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=2d01edd7600090f4c938d232da3df3aeff3e1fe8", "patch": "@@ -7157,7 +7157,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t  cp_lexer_consume_token (parser->lexer);\n \t  if (decl_specs->specs[(int) ds_thread])\n \t    {\n-\t      error (\"`__thread' before `static'\");\n+\t      error (\"%<__thread%> before %<static%>\");\n \t      decl_specs->specs[(int) ds_thread] = 0;\n \t    }\n \t  cp_parser_set_storage_class (decl_specs, sc_static);\n@@ -7167,7 +7167,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t  cp_lexer_consume_token (parser->lexer);\n \t  if (decl_specs->specs[(int) ds_thread])\n \t    {\n-\t      error (\"`__thread' before `extern'\");\n+\t      error (\"%<__thread%> before %<extern%>\");\n \t      decl_specs->specs[(int) ds_thread] = 0;\n \t    }\n \t  cp_parser_set_storage_class (decl_specs, sc_extern);"}, {"sha": "4d1a7ce243008eb4c6004532b4c3686169f1872a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2d01edd7600090f4c938d232da3df3aeff3e1fe8", "patch": "@@ -1,3 +1,10 @@\n+2004-10-03  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* g++.dg/template/local1.C: Adjust quoting marks in\n+\ttesting for diagnostics.\n+\t* g++.dg/tls/diag-2.C: Likewise.\n+\t* g++.dg/other/error8.C: Likewise.\n+\n 2004-10-03  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR c/17178"}, {"sha": "1ccfe99befe55b6f0b08f9a42c3d00a1f2011950", "filename": "gcc/testsuite/g++.dg/other/error8.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror8.C?ref=2d01edd7600090f4c938d232da3df3aeff3e1fe8", "patch": "@@ -5,7 +5,7 @@\n \n void foo(void)\n {\n-  union { int alpha; int beta; }; // { dg-error \"previous declaration of `int alpha'\" }\n+  union { int alpha; int beta; }; // { dg-error \"previous declaration of 'int alpha'\" }\n   double alpha;  // { dg-error \"redeclared\" }\n }\n "}, {"sha": "4293aca2403694210591ccfd7b008e20532bd519", "filename": "gcc/testsuite/g++.dg/template/local1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flocal1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flocal1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Flocal1.C?ref=2d01edd7600090f4c938d232da3df3aeff3e1fe8", "patch": "@@ -14,7 +14,7 @@ template<class T> void A::f()\n   struct B\n   {\n     void g() {}\n-    static int x;\t// { dg-error \"static.*`int A::f\\\\(\\\\)::B::x'\" \"\" }\n+    static int x;\t// { dg-error \"static.*int A::f\\\\(\\\\)::B::x\" \"\" }\n   };\n }\n "}, {"sha": "6cd539d6fbe1d15b2129bb0ba46b20037c9caf03", "filename": "gcc/testsuite/g++.dg/tls/diag-2.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d01edd7600090f4c938d232da3df3aeff3e1fe8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fdiag-2.C?ref=2d01edd7600090f4c938d232da3df3aeff3e1fe8", "patch": "@@ -1,15 +1,15 @@\n /* Invalid __thread specifiers.  */\n \n-__thread extern int g1;\t\t/* { dg-error \"`__thread' before `extern'\" } */\n-__thread static int g2;\t\t/* { dg-error \"`__thread' before `static'\" } */\n-__thread __thread int g3;\t/* { dg-error \"duplicate `__thread'\" } */\n+__thread extern int g1;\t\t/* { dg-error \"'__thread' before 'extern'\" } */\n+__thread static int g2;\t\t/* { dg-error \"'__thread' before 'static'\" } */\n+__thread __thread int g3;\t/* { dg-error \"duplicate '__thread'\" } */\n typedef __thread int g4;\t/* { dg-error \"multiple storage classes\" } */\n \n void foo()\n {\n-  __thread int l1;\t\t/* { dg-error \"implicitly auto and declared `__thread'\" } */\n+  __thread int l1;\t\t/* { dg-error \"implicitly auto and declared '__thread'\" } */\n   auto __thread int l2;\t\t/* { dg-error \"multiple storage classes\" } */\n-  __thread extern int l3;\t/* { dg-error \"`__thread' before `extern'\" } */\n+  __thread extern int l3;\t/* { dg-error \"'__thread' before 'extern'\" } */\n   register __thread int l4;\t/* { dg-error \"multiple storage classes\" } */\n }\n "}]}