{"sha": "47598145be96f39a73809240153e5af12bfbcedd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc1OTgxNDViZTk2ZjM5YTczODA5MjQwMTUzZTVhZjEyYmZiY2VkZA==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2011-11-08T16:47:16Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2011-11-08T16:47:16Z"}, "message": "gengtype.c (write_field_root): Avoid out-of-scope access of newv.\n\n\t* gengtype.c (write_field_root): Avoid out-of-scope access of newv.\n\n\t* tree-stdarg.c (execute_optimize_stdarg): Accept clobbers.\n\n\t* tree.h (TREE_CLOBBER_P): New macro.\n\t* gimple.h (gimple_clobber_p): New inline function.\n\t* gimplify.c (gimplify_bind_expr): Add clobbers for all variables\n\tthat go out of scope and live in memory.\n\t* tree-ssa-operands.c (get_expr_operands): Transfer volatility also\n\tfor constructors.\n\t* cfgexpand.c (decl_to_stack_part): New static variable.\n\t(add_stack_var): Allocate it, and remember mapping.\n\t(fini_vars_expansion): Deallocate it.\n\t(stack_var_conflict_p): Add early outs.\n\t(visit_op, visit_conflict, add_scope_conflicts_1,\n\tadd_scope_conflicts): New static functions.\n\t(expand_used_vars_for_block): Don't call add_stack_var_conflict, tidy.\n\t(expand_used_vars): Add scope conflicts.\n\t(expand_gimple_stmt_1): Expand clobbers to nothing.\n\t(expand_debug_expr): Ditto.\n\n\t* tree-pretty-print.c (dump_generic_node): Dump clobbers nicely.\n\t* tree-ssa-live.c (remove_unused_locals): Remove clobbers that\n\trefer to otherwise unused locals.\n\t* tree-sra.c (build_accesses_from_assign): Ignore clobbers.\n\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Clobbers of\n\tSSA names aren't necessary.\n\t(propagate_necessity): Accept and ignore constructors on the rhs,\n\ttidy.\n\t* gimple.c (walk_gimple_op): Accept constructors like mem_rhs.\n\t* tree-ssa-structalias.c (find_func_aliases): Clobbers don't store\n\tany known value.\n\t* tree-ssa-sccvn.c (vn_reference_lookup_3): Ditto, in particular they\n\tdon't zero-initialize something.\n\t* tree-ssa-phiopt.c (cond_if_else_store_replacement_1): Ignore\n\tclobber RHS, we don't want PHI nodes with those.\n\ntestsuite/\n\t* gcc.dg/tree-ssa/20031015-1.c: Adjust.\n\t* g++.dg/tree-ssa/ehcleanup-1.C: Ditto.\n\t* g++.dg/eh/builtin1.C: Rewrite to not use local variables.\n\t* g++.dg/eh/builtin2.C: Ditto.\n\t* g++.dg/eh/builtin3.C: Ditto.\n\nFrom-SVN: r181172", "tree": {"sha": "4dc2b97edd33ddeabf08fbbf07022528b2b4431c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4dc2b97edd33ddeabf08fbbf07022528b2b4431c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47598145be96f39a73809240153e5af12bfbcedd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47598145be96f39a73809240153e5af12bfbcedd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47598145be96f39a73809240153e5af12bfbcedd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47598145be96f39a73809240153e5af12bfbcedd/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a58a38b32c7ed8b4843e8d2b2658323204fa96ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a58a38b32c7ed8b4843e8d2b2658323204fa96ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a58a38b32c7ed8b4843e8d2b2658323204fa96ed"}], "stats": {"total": 471, "additions": 406, "deletions": 65}, "files": [{"sha": "abbc82c67e4a3791ea288e74884c86b3e978d84e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -1,3 +1,42 @@\n+2011-11-08  Michael Matz  <matz@suse.de>\n+\n+\t* gengtype.c (write_field_root): Avoid out-of-scope access of newv.\n+\n+\t* tree-stdarg.c (execute_optimize_stdarg): Accept clobbers.\n+\n+\t* tree.h (TREE_CLOBBER_P): New macro.\n+\t* gimple.h (gimple_clobber_p): New inline function.\n+\t* gimplify.c (gimplify_bind_expr): Add clobbers for all variables\n+\tthat go out of scope and live in memory.\n+\t* tree-ssa-operands.c (get_expr_operands): Transfer volatility also\n+\tfor constructors.\n+\t* cfgexpand.c (decl_to_stack_part): New static variable.\n+\t(add_stack_var): Allocate it, and remember mapping.\n+\t(fini_vars_expansion): Deallocate it.\n+\t(stack_var_conflict_p): Add early outs.\n+\t(visit_op, visit_conflict, add_scope_conflicts_1,\n+\tadd_scope_conflicts): New static functions.\n+\t(expand_used_vars_for_block): Don't call add_stack_var_conflict, tidy.\n+\t(expand_used_vars): Add scope conflicts.\n+\t(expand_gimple_stmt_1): Expand clobbers to nothing.\n+\t(expand_debug_expr): Ditto.\n+\n+\t* tree-pretty-print.c (dump_generic_node): Dump clobbers nicely.\n+\t* tree-ssa-live.c (remove_unused_locals): Remove clobbers that\n+\trefer to otherwise unused locals.\n+\t* tree-sra.c (build_accesses_from_assign): Ignore clobbers.\n+\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Clobbers of\n+\tSSA names aren't necessary.\n+\t(propagate_necessity): Accept and ignore constructors on the rhs,\n+\ttidy.\n+\t* gimple.c (walk_gimple_op): Accept constructors like mem_rhs.\n+\t* tree-ssa-structalias.c (find_func_aliases): Clobbers don't store\n+\tany known value.\n+\t* tree-ssa-sccvn.c (vn_reference_lookup_3): Ditto, in particular they\n+\tdon't zero-initialize something.\n+\t* tree-ssa-phiopt.c (cond_if_else_store_replacement_1): Ignore\n+\tclobber RHS, we don't want PHI nodes with those.\n+\n 2011-11-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.c (ix86_preferred_simd_mode): Even for TARGET_AVX"}, {"sha": "2a82b032f5d974a6a893c39fc11bbd735e1eb632", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 184, "deletions": 22, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -135,7 +135,7 @@ set_rtl (tree t, rtx x)\n \t  /* If we don't yet have something recorded, just record it now.  */\n \t  if (!DECL_RTL_SET_P (var))\n \t    SET_DECL_RTL (var, x);\n-\t  /* If we have it set alrady to \"multiple places\" don't\n+\t  /* If we have it set already to \"multiple places\" don't\n \t     change this.  */\n \t  else if (DECL_RTL (var) == pc_rtx)\n \t    ;\n@@ -184,6 +184,7 @@ struct stack_var\n static struct stack_var *stack_vars;\n static size_t stack_vars_alloc;\n static size_t stack_vars_num;\n+static struct pointer_map_t *decl_to_stack_part;\n \n /* An array of indices such that stack_vars[stack_vars_sorted[i]].size\n    is non-decreasing.  */\n@@ -262,7 +263,11 @@ add_stack_var (tree decl)\n       stack_vars\n \t= XRESIZEVEC (struct stack_var, stack_vars, stack_vars_alloc);\n     }\n+  if (!decl_to_stack_part)\n+    decl_to_stack_part = pointer_map_create ();\n+\n   v = &stack_vars[stack_vars_num];\n+  * (size_t *)pointer_map_insert (decl_to_stack_part, decl) = stack_vars_num;\n \n   v->decl = decl;\n   v->size = tree_low_cst (DECL_SIZE_UNIT (SSAVAR (decl)), 1);\n@@ -309,6 +314,14 @@ stack_var_conflict_p (size_t x, size_t y)\n {\n   struct stack_var *a = &stack_vars[x];\n   struct stack_var *b = &stack_vars[y];\n+  if (x == y)\n+    return false;\n+  /* Partitions containing an SSA name result from gimple registers\n+     with things like unsupported modes.  They are top-level and\n+     hence conflict with everything else.  */\n+  if (TREE_CODE (a->decl) == SSA_NAME || TREE_CODE (b->decl) == SSA_NAME)\n+    return true;\n+\n   if (!a->conflicts || !b->conflicts)\n     return false;\n   return bitmap_bit_p (a->conflicts, y);\n@@ -379,6 +392,163 @@ add_alias_set_conflicts (void)\n     }\n }\n \n+/* Callback for walk_stmt_ops.  If OP is a decl touched by add_stack_var\n+   enter its partition number into bitmap DATA.  */\n+\n+static bool\n+visit_op (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+{\n+  bitmap active = (bitmap)data;\n+  op = get_base_address (op);\n+  if (op\n+      && DECL_P (op)\n+      && DECL_RTL_IF_SET (op) == pc_rtx)\n+    {\n+      size_t *v = (size_t *) pointer_map_contains (decl_to_stack_part, op);\n+      if (v)\n+\tbitmap_set_bit (active, *v);\n+    }\n+  return false;\n+}\n+\n+/* Callback for walk_stmt_ops.  If OP is a decl touched by add_stack_var\n+   record conflicts between it and all currently active other partitions\n+   from bitmap DATA.  */\n+\n+static bool\n+visit_conflict (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+{\n+  bitmap active = (bitmap)data;\n+  op = get_base_address (op);\n+  if (op\n+      && DECL_P (op)\n+      && DECL_RTL_IF_SET (op) == pc_rtx)\n+    {\n+      size_t *v =\n+\t(size_t *) pointer_map_contains (decl_to_stack_part, op);\n+      if (v && bitmap_set_bit (active, *v))\n+\t{\n+\t  size_t num = *v;\n+\t  bitmap_iterator bi;\n+\t  unsigned i;\n+\t  gcc_assert (num < stack_vars_num);\n+\t  EXECUTE_IF_SET_IN_BITMAP (active, 0, i, bi)\n+\t    add_stack_var_conflict (num, i);\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Helper routine for add_scope_conflicts, calculating the active partitions\n+   at the end of BB, leaving the result in WORK.  We're called to generate\n+   conflicts when FOR_CONFLICT is true, otherwise we're just tracking\n+   liveness.  */\n+\n+static void\n+add_scope_conflicts_1 (basic_block bb, bitmap work, bool for_conflict)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  gimple_stmt_iterator gsi;\n+  bool (*visit)(gimple, tree, void *);\n+\n+  bitmap_clear (work);\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    bitmap_ior_into (work, (bitmap)e->src->aux);\n+\n+  if (for_conflict)\n+    {\n+      /* We need to add conflicts for everything life at the start of\n+         this block.  Unlike classical lifeness for named objects we can't\n+\t rely on seeing a def/use of the names we're interested in.\n+\t There might merely be indirect loads/stores.  We'd not add any\n+\t conflicts for such partitions.  */\n+      bitmap_iterator bi;\n+      unsigned i;\n+      EXECUTE_IF_SET_IN_BITMAP (work, 0, i, bi)\n+\t{\n+\t  unsigned j;\n+\t  bitmap_iterator bj;\n+\t  EXECUTE_IF_SET_IN_BITMAP (work, i, j, bj)\n+\t    add_stack_var_conflict (i, j);\n+\t}\n+      visit = visit_conflict;\n+    }\n+  else\n+    visit = visit_op;\n+\n+  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      if (!is_gimple_debug (stmt))\n+\twalk_stmt_load_store_addr_ops (stmt, work, visit, visit, visit);\n+    }\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+\n+      if (gimple_clobber_p (stmt))\n+\t{\n+\t  tree lhs = gimple_assign_lhs (stmt);\n+\t  size_t *v;\n+\t  /* Nested function lowering might introduce LHSs\n+\t     that are COMPONENT_REFs.  */\n+\t  if (TREE_CODE (lhs) != VAR_DECL)\n+\t    continue;\n+\t  if (DECL_RTL_IF_SET (lhs) == pc_rtx\n+\t      && (v = (size_t *)\n+\t\t  pointer_map_contains (decl_to_stack_part, lhs)))\n+\t    bitmap_clear_bit (work, *v);\n+\t}\n+      else if (!is_gimple_debug (stmt))\n+\twalk_stmt_load_store_addr_ops (stmt, work, visit, visit, visit);\n+    }\n+}\n+\n+/* Generate stack partition conflicts between all partitions that are\n+   simultaneously live.  */\n+\n+static void\n+add_scope_conflicts (void)\n+{\n+  basic_block bb;\n+  bool changed;\n+  bitmap work = BITMAP_ALLOC (NULL);\n+\n+  /* We approximate the life range of a stack variable by taking the first\n+     mention of its name as starting point(s), and by the end-of-scope\n+     death clobber added by gimplify as ending point(s) of the range.\n+     This overapproximates in the case we for instance moved an address-taken\n+     operation upward, without also moving a dereference to it upwards.\n+     But it's conservatively correct as a variable never can hold values\n+     before its name is mentioned at least once.\n+\n+     We then do a mostly classical bitmap lifeness algorithm.  */\n+\n+  FOR_ALL_BB (bb)\n+    bb->aux = BITMAP_ALLOC (NULL);\n+\n+  changed = true;\n+  while (changed)\n+    {\n+      changed = false;\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  bitmap active = (bitmap)bb->aux;\n+\t  add_scope_conflicts_1 (bb, work, false);\n+\t  if (bitmap_ior_into (active, work))\n+\t    changed = true;\n+\t}\n+    }\n+\n+  FOR_EACH_BB (bb)\n+    add_scope_conflicts_1 (bb, work, true);\n+\n+  BITMAP_FREE (work);\n+  FOR_ALL_BB (bb)\n+    BITMAP_FREE (bb->aux);\n+}\n+\n /* A subroutine of partition_stack_vars.  A comparison function for qsort,\n    sorting an array of indices by the properties of the object.  */\n \n@@ -1095,36 +1265,18 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n static void\n expand_used_vars_for_block (tree block, bool toplevel)\n {\n-  size_t i, j, old_sv_num, this_sv_num, new_sv_num;\n   tree t;\n \n-  old_sv_num = toplevel ? 0 : stack_vars_num;\n-\n   /* Expand all variables at this level.  */\n   for (t = BLOCK_VARS (block); t ; t = DECL_CHAIN (t))\n     if (TREE_USED (t)\n         && ((TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != RESULT_DECL)\n \t    || !DECL_NONSHAREABLE (t)))\n       expand_one_var (t, toplevel, true);\n \n-  this_sv_num = stack_vars_num;\n-\n   /* Expand all variables at containing levels.  */\n   for (t = BLOCK_SUBBLOCKS (block); t ; t = BLOCK_CHAIN (t))\n     expand_used_vars_for_block (t, false);\n-\n-  /* Since we do not track exact variable lifetimes (which is not even\n-     possible for variables whose address escapes), we mirror the block\n-     tree in the interference graph.  Here we cause all variables at this\n-     level, and all sublevels, to conflict.  */\n-  if (old_sv_num < this_sv_num)\n-    {\n-      new_sv_num = stack_vars_num;\n-\n-      for (i = old_sv_num; i < new_sv_num; ++i)\n-\tfor (j = i < this_sv_num ? i : this_sv_num; j-- > old_sv_num ;)\n-\t  add_stack_var_conflict (i, j);\n-    }\n }\n \n /* A subroutine of expand_used_vars.  Walk down through the BLOCK tree\n@@ -1312,6 +1464,8 @@ fini_vars_expansion (void)\n   XDELETEVEC (stack_vars_sorted);\n   stack_vars = NULL;\n   stack_vars_alloc = stack_vars_num = 0;\n+  pointer_map_destroy (decl_to_stack_part);\n+  decl_to_stack_part = NULL;\n }\n \n /* Make a fair guess for the size of the stack frame of the function\n@@ -1466,6 +1620,7 @@ expand_used_vars (void)\n \n   if (stack_vars_num > 0)\n     {\n+      add_scope_conflicts ();\n       /* Due to the way alias sets work, no variables with non-conflicting\n \t alias sets may be assigned the same address.  Add conflicts to\n \t reflect this.  */\n@@ -2008,8 +2163,13 @@ expand_gimple_stmt_1 (gimple stmt)\n \t\t\t== GIMPLE_SINGLE_RHS);\n \t    if (gimple_has_location (stmt) && CAN_HAVE_LOCATION_P (rhs))\n \t      SET_EXPR_LOCATION (rhs, gimple_location (stmt));\n-\t    expand_assignment (lhs, rhs,\n-\t\t\t       gimple_assign_nontemporal_move_p (stmt));\n+\t    if (TREE_CLOBBER_P (rhs))\n+\t      /* This is a clobber to mark the going out of scope for\n+\t\t this LHS.  */\n+\t      ;\n+\t    else\n+\t      expand_assignment (lhs, rhs,\n+\t\t\t\t gimple_assign_nontemporal_move_p (stmt));\n \t  }\n \telse\n \t  {\n@@ -3199,7 +3359,9 @@ expand_debug_expr (tree exp)\n       /* Fall through.  */\n \n     case CONSTRUCTOR:\n-      if (TREE_CODE (TREE_TYPE (exp)) == VECTOR_TYPE)\n+      if (TREE_CLOBBER_P (exp))\n+\treturn NULL;\n+      else if (TREE_CODE (TREE_TYPE (exp)) == VECTOR_TYPE)\n \t{\n \t  unsigned i;\n \t  tree val;"}, {"sha": "7450eebac4f919b900e863549772e512d7afabc0", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -3651,14 +3651,13 @@ write_field_root (outf_p f, pair_p v, type_p type, const char *name,\n \t\t  int has_length, struct fileloc *line, const char *if_marked,\n \t\t  bool emit_pch, type_p field_type, const char *field_name)\n {\n+  struct pair newv;\n   /* If the field reference is relative to V, rather than to some\n      subcomponent of V, we can mark any subarrays with a single stride.\n      We're effectively treating the field as a global variable in its\n      own right.  */\n   if (v && type == v->type)\n     {\n-      struct pair newv;\n-\n       newv = *v;\n       newv.type = field_type;\n       newv.name = ACONCAT ((v->name, \".\", field_name, NULL));"}, {"sha": "57f15af313c4ed72e9f3d1f4adc251adf3036a1b", "filename": "gcc/gimple.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -1499,7 +1499,9 @@ walk_gimple_op (gimple stmt, walk_tree_fn callback_op,\n \t{\n           /* If the RHS has more than 1 operand, it is not appropriate\n              for the memory.  */\n-\t  wi->val_only = !is_gimple_mem_rhs (gimple_assign_rhs1 (stmt))\n+\t  wi->val_only = !(is_gimple_mem_rhs (gimple_assign_rhs1 (stmt))\n+\t\t\t   || TREE_CODE (gimple_assign_rhs1 (stmt))\n+\t\t\t      == CONSTRUCTOR)\n                          || !gimple_assign_single_p (stmt);\n \t  wi->is_lhs = true;\n \t}"}, {"sha": "8536c70e87e21bdc421cbf90026bb346cb701744", "filename": "gcc/gimple.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -2053,6 +2053,14 @@ gimple_assign_cast_p (gimple s)\n   return false;\n }\n \n+/* Return true if S is a clobber statement.  */\n+\n+static inline bool\n+gimple_clobber_p (gimple s)\n+{\n+  return gimple_assign_single_p (s)\n+         && TREE_CLOBBER_P (gimple_assign_rhs1 (s));\n+}\n \n /* Return true if GS is a GIMPLE_CALL.  */\n "}, {"sha": "9845b6922117cb3925739a5b236f7369c39cad36", "filename": "gcc/gimplify.c", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -1135,7 +1135,8 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n   bool old_save_stack = gimplify_ctxp->save_stack;\n   tree t;\n   gimple gimple_bind;\n-  gimple_seq body;\n+  gimple_seq body, cleanup;\n+  gimple stack_save;\n \n   tree temp = voidify_wrapper_expr (bind_expr, NULL);\n \n@@ -1181,22 +1182,50 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n   gimplify_stmt (&BIND_EXPR_BODY (bind_expr), &body);\n   gimple_bind_set_body (gimple_bind, body);\n \n+  cleanup = NULL;\n+  stack_save = NULL;\n   if (gimplify_ctxp->save_stack)\n     {\n-      gimple stack_save, stack_restore, gs;\n-      gimple_seq cleanup, new_body;\n+      gimple stack_restore;\n \n       /* Save stack on entry and restore it on exit.  Add a try_finally\n \t block to achieve this.  Note that mudflap depends on the\n \t format of the emitted code: see mx_register_decls().  */\n       build_stack_save_restore (&stack_save, &stack_restore);\n \n-      cleanup = new_body = NULL;\n       gimplify_seq_add_stmt (&cleanup, stack_restore);\n+    }\n+\n+  /* Add clobbers for all variables that go out of scope.  */\n+  for (t = BIND_EXPR_VARS (bind_expr); t ; t = DECL_CHAIN (t))\n+    {\n+      if (TREE_CODE (t) == VAR_DECL\n+\t  && !is_global_var (t)\n+\t  && DECL_CONTEXT (t) == current_function_decl\n+\t  && !DECL_HARD_REGISTER (t)\n+\t  && !TREE_THIS_VOLATILE (t)\n+\t  && !DECL_HAS_VALUE_EXPR_P (t)\n+\t  /* Only care for variables that have to be in memory.  Others\n+\t     will be rewritten into SSA names, hence moved to the top-level.  */\n+\t  && needs_to_live_in_memory (t))\n+\t{\n+\t  tree clobber = build_constructor (TREE_TYPE (t), NULL);\n+\t  TREE_THIS_VOLATILE (clobber) = 1;\n+\t  gimplify_seq_add_stmt (&cleanup, gimple_build_assign (t, clobber));\n+\t}\n+    }\n+\n+  if (cleanup)\n+    {\n+      gimple gs;\n+      gimple_seq new_body;\n+\n+      new_body = NULL;\n       gs = gimple_build_try (gimple_bind_body (gimple_bind), cleanup,\n \t  \t\t     GIMPLE_TRY_FINALLY);\n \n-      gimplify_seq_add_stmt (&new_body, stack_save);\n+      if (stack_save)\n+\tgimplify_seq_add_stmt (&new_body, stack_save);\n       gimplify_seq_add_stmt (&new_body, gs);\n       gimple_bind_set_body (gimple_bind, new_body);\n     }"}, {"sha": "0cc8b6e234d27718f4fd0b2ded06601fe735e371", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -1,3 +1,11 @@\n+2011-11-08  Michael Matz  <matz@suse.de>\n+\n+\t* gcc.dg/tree-ssa/20031015-1.c: Adjust.\n+\t* g++.dg/tree-ssa/ehcleanup-1.C: Ditto.\n+\t* g++.dg/eh/builtin1.C: Rewrite to not use local variables.\n+\t* g++.dg/eh/builtin2.C: Ditto.\n+\t* g++.dg/eh/builtin3.C: Ditto.\n+\n 2011-11-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.target/i386/avx-cvt-2.c: Adjust for 32-byte integer vectors"}, {"sha": "c0516eb6063b79e86dd5577f56bc75a94b720df4", "filename": "gcc/testsuite/g++.dg/eh/builtin1.C", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin1.C?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -6,20 +6,26 @@\n \n extern \"C\" int printf (const char *, ...);\n \n-struct A { A (); ~A (); int i; };\n+extern void callme (void) throw();\n \n int\n-foo ()\n+foo (int i)\n {\n-  A a;\n-  printf (\"foo %d\\n\", a.i);\n+  try {\n+    printf (\"foo %d\\n\", i);\n+  } catch (...) {\n+    callme();\n+  }\n }\n \n int\n-bar ()\n+bar (int i)\n {\n-  A a;\n-  __builtin_printf (\"foo %d\\n\", a.i);\n+  try {\n+    __builtin_printf (\"foo %d\\n\", i);\n+  } catch (...) {\n+    callme();\n+  }\n }\n \n /* { dg-final { scan-tree-dump-times \"resx\" 2 \"eh\" } } */"}, {"sha": "66104495289418ebeb1f94a9d77457fdb4a14c61", "filename": "gcc/testsuite/g++.dg/eh/builtin2.C", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin2.C?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -5,20 +5,26 @@\n \n extern \"C\" int printf (const char *, ...) throw();\n \n-struct A { A (); ~A (); int i; };\n+extern void callme (void) throw();\n \n int\n-foo ()\n+foo (int i)\n {\n-  A a;\n-  printf (\"foo %d\\n\", a.i);\n+  try {\n+    printf (\"foo %d\\n\", i);\n+  } catch (...) {\n+    callme();\n+  }\n }\n \n int\n-bar ()\n+bar (int i)\n {\n-  A a;\n-  __builtin_printf (\"foo %d\\n\", a.i);\n+  try {\n+    __builtin_printf (\"foo %d\\n\", i);\n+  } catch (...) {\n+    callme();\n+  }\n }\n \n /* { dg-final { scan-tree-dump-times \"resx\" 0 \"eh\" } } */"}, {"sha": "4b382d982318abfc06aabecdd38578301501e473", "filename": "gcc/testsuite/g++.dg/eh/builtin3.C", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fbuiltin3.C?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -3,13 +3,16 @@\n // { dg-do compile }\n // { dg-options \"-fdump-tree-eh\" }\n \n-struct A { A (); ~A (); int i; };\n+extern void callme (void) throw();\n \n int\n-bar ()\n+bar (int i)\n {\n-  A a;\n-  __builtin_printf (\"foo %d\\n\", a.i);\n+  try {\n+    __builtin_printf (\"foo %d\\n\", i);\n+  } catch (...) {\n+    callme();\n+  }\n }\n \n /* { dg-final { scan-tree-dump-times \"resx\" 1 \"eh\" } } */"}, {"sha": "cc492a80975f97db23379638173f31ac65c73cff", "filename": "gcc/testsuite/g++.dg/tree-ssa/ehcleanup-1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fehcleanup-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fehcleanup-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fehcleanup-1.C?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -16,9 +16,9 @@ t (void)\n   can_throw ();\n }\n // We ought to remove implicit cleanup, since destructor is empty. \n-// { dg-final { scan-tree-dump-times \"Empty EH handler\" 1 \"ehcleanup1\" } }\n+// { dg-final { scan-tree-dump-times \"Empty EH handler\" 2 \"ehcleanup1\" } }\n //\n // And as a result also contained control flow.\n-// { dg-final { scan-tree-dump-times \"Removing unreachable\" 2 \"ehcleanup1\" } }\n+// { dg-final { scan-tree-dump-times \"Removing unreachable\" 4 \"ehcleanup1\" } }\n //\n // { dg-final { cleanup-tree-dump \"ehcleanup1\" } }"}, {"sha": "3cc2ae9468750c94e6b4bb22c04226cad3a9c8ef", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20031015-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20031015-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20031015-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20031015-1.c?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -13,6 +13,6 @@ main(void)\n   return 0;\n }\n \n-/* The VDEF comes from the initial assignment and the asm.  */\n-/* { dg-final { scan-tree-dump-times \"DEF\" 2 \"alias\" } } */\n+/* The VDEF comes from the initial assignment, the asm, and the clobber.  */\n+/* { dg-final { scan-tree-dump-times \"DEF\" 3 \"alias\" } } */\n /* { dg-final { cleanup-tree-dump \"alias\" } } */"}, {"sha": "9abe004280bd3a725a49ac518483c4e72210e02a", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -1271,8 +1271,10 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \tbool is_array_init = false;\n \tdouble_int curidx = double_int_zero;\n \tpp_character (buffer, '{');\n-\tif (TREE_CODE (TREE_TYPE (node)) == RECORD_TYPE\n-\t    || TREE_CODE (TREE_TYPE (node)) == UNION_TYPE)\n+\tif (TREE_CLOBBER_P (node))\n+\t  pp_string (buffer, \"CLOBBER\");\n+\telse if (TREE_CODE (TREE_TYPE (node)) == RECORD_TYPE\n+\t\t || TREE_CODE (TREE_TYPE (node)) == UNION_TYPE)\n \t  is_struct_init = true;\n         else if (TREE_CODE (TREE_TYPE (node)) == ARRAY_TYPE\n \t\t && TYPE_DOMAIN (TREE_TYPE (node))"}, {"sha": "472ad5d6f5d0c9092b3f0fcdea2c3e7eae2249d6", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -1103,7 +1103,9 @@ build_accesses_from_assign (gimple stmt)\n   tree lhs, rhs;\n   struct access *lacc, *racc;\n \n-  if (!gimple_assign_single_p (stmt))\n+  if (!gimple_assign_single_p (stmt)\n+      /* Scope clobbers don't influence scalarization.  */\n+      || gimple_clobber_p (stmt))\n     return false;\n \n   lhs = gimple_assign_lhs (stmt);"}, {"sha": "d6fbe622df0242da38f15789e66a315c0763641c", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -351,6 +351,12 @@ mark_stmt_if_obviously_necessary (gimple stmt, bool aggressive)\n \tmark_stmt_necessary (stmt, true);\n       break;\n \n+    case GIMPLE_ASSIGN:\n+      if (TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME\n+\t  && TREE_CLOBBER_P (gimple_assign_rhs1 (stmt)))\n+\treturn;\n+      break;\n+\n     default:\n       break;\n     }\n@@ -917,27 +923,26 @@ propagate_necessity (struct edge_list *el)\n \t  else if (gimple_assign_single_p (stmt))\n \t    {\n \t      tree rhs;\n-\t      bool rhs_aliased = false;\n \t      /* If this is a load mark things necessary.  */\n \t      rhs = gimple_assign_rhs1 (stmt);\n \t      if (TREE_CODE (rhs) != SSA_NAME\n-\t\t  && !is_gimple_min_invariant (rhs))\n+\t\t  && !is_gimple_min_invariant (rhs)\n+\t\t  && TREE_CODE (rhs) != CONSTRUCTOR)\n \t\t{\n \t\t  if (!ref_may_be_aliased (rhs))\n \t\t    mark_aliased_reaching_defs_necessary (stmt, rhs);\n \t\t  else\n-\t\t    rhs_aliased = true;\n+\t\t    mark_all_reaching_defs_necessary (stmt);\n \t\t}\n-\t      if (rhs_aliased)\n-\t\tmark_all_reaching_defs_necessary (stmt);\n \t    }\n \t  else if (gimple_code (stmt) == GIMPLE_RETURN)\n \t    {\n \t      tree rhs = gimple_return_retval (stmt);\n \t      /* A return statement may perform a load.  */\n \t      if (rhs\n \t\t  && TREE_CODE (rhs) != SSA_NAME\n-\t\t  && !is_gimple_min_invariant (rhs))\n+\t\t  && !is_gimple_min_invariant (rhs)\n+\t\t  && TREE_CODE (rhs) != CONSTRUCTOR)\n \t\t{\n \t\t  if (!ref_may_be_aliased (rhs))\n \t\t    mark_aliased_reaching_defs_necessary (stmt, rhs);\n@@ -955,6 +960,7 @@ propagate_necessity (struct edge_list *el)\n \t\t  tree op = TREE_VALUE (gimple_asm_input_op (stmt, i));\n \t\t  if (TREE_CODE (op) != SSA_NAME\n \t\t      && !is_gimple_min_invariant (op)\n+\t\t      && TREE_CODE (op) != CONSTRUCTOR\n \t\t      && !ref_may_be_aliased (op))\n \t\t    mark_aliased_reaching_defs_necessary (stmt, op);\n \t\t}"}, {"sha": "2a2c13393fea431f98aabcc121508a173bc85e76", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -688,6 +688,7 @@ remove_unused_locals (void)\n   referenced_var_iterator rvi;\n   bitmap global_unused_vars = NULL;\n   unsigned srcidx, dstidx, num;\n+  bool have_local_clobbers = false;\n \n   /* Removing declarations from lexical blocks when not optimizing is\n      not only a waste of time, it actually causes differences in stack\n@@ -720,6 +721,12 @@ remove_unused_locals (void)\n \t  if (is_gimple_debug (stmt))\n \t    continue;\n \n+\t  if (gimple_clobber_p (stmt))\n+\t    {\n+\t      have_local_clobbers = true;\n+\t      continue;\n+\t    }\n+\n \t  if (b)\n \t    TREE_USED (b) = true;\n \n@@ -753,6 +760,41 @@ remove_unused_locals (void)\n \t  TREE_USED (e->goto_block) = true;\n     }\n \n+  /* We do a two-pass approach about the out-of-scope clobbers.  We want\n+     to remove them if they are the only references to a local variable,\n+     but we want to retain them when there's any other.  So the first pass\n+     ignores them, and the second pass (if there were any) tries to remove\n+     them.  */\n+  if (have_local_clobbers)\n+    FOR_EACH_BB (bb)\n+      {\n+\tgimple_stmt_iterator gsi;\n+\n+\tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n+\t  {\n+\t    gimple stmt = gsi_stmt (gsi);\n+\t    tree b = gimple_block (stmt);\n+\n+\t    if (gimple_clobber_p (stmt))\n+\t      {\n+\t\ttree lhs = gimple_assign_lhs (stmt);\n+\t\tlhs = get_base_address (lhs);\n+\t\tif (TREE_CODE (lhs) == SSA_NAME)\n+\t\t  lhs = SSA_NAME_VAR (lhs);\n+\t\tif (DECL_P (lhs) && (!var_ann (lhs) || !is_used_p (lhs)))\n+\t\t  {\n+\t\t    unlink_stmt_vdef (stmt);\n+\t\t    gsi_remove (&gsi, true);\n+\t\t    release_defs (stmt);\n+\t\t    continue;\n+\t\t  }\n+\t\tif (b)\n+\t\t  TREE_USED (b) = true;\n+\t      }\n+\t    gsi_next (&gsi);\n+\t  }\n+      }\n+\n   cfun->has_local_explicit_reg_vars = false;\n \n   /* Remove unmarked local vars from local_decls.  */"}, {"sha": "9012bfe26fe527c39b80242cbbe0394a5ca688b2", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -956,6 +956,12 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n \tconstructor_elt *ce;\n \tunsigned HOST_WIDE_INT idx;\n \n+\t/* A volatile constructor is actually TREE_CLOBBER_P, transfer\n+\t   the volatility to the statement, don't use TREE_CLOBBER_P for\n+\t   mirroring the other uses of THIS_VOLATILE in this file.  */\n+\tif (TREE_THIS_VOLATILE (expr))\n+\t  gimple_set_has_volatile_ops (stmt, true);\n+\n \tfor (idx = 0;\n \t     VEC_iterate (constructor_elt, CONSTRUCTOR_ELTS (expr), idx, ce);\n \t     idx++)"}, {"sha": "96d461221952b41bba6c395f433d48cb3e01cb70", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -1318,8 +1318,10 @@ cond_if_else_store_replacement_1 (basic_block then_bb, basic_block else_bb,\n \n   if (then_assign == NULL\n       || !gimple_assign_single_p (then_assign)\n+      || gimple_clobber_p (then_assign)\n       || else_assign == NULL\n-      || !gimple_assign_single_p (else_assign))\n+      || !gimple_assign_single_p (else_assign)\n+      || gimple_clobber_p (else_assign))\n     return false;\n \n   lhs = gimple_assign_lhs (then_assign);"}, {"sha": "fa268c2ef8b0f535f1a6e999278d15fc5aa30f8d", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -1388,8 +1388,12 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_)\n   if (maxsize == -1)\n     return (void *)-1;\n \n+  /* We can't deduce anything useful from clobbers.  */\n+  if (gimple_clobber_p (def_stmt))\n+    return (void *)-1;\n+\n   /* def_stmt may-defs *ref.  See if we can derive a value for *ref\n-     from that defintion.\n+     from that definition.\n      1) Memset.  */\n   if (is_gimple_reg_type (vr->type)\n       && gimple_call_builtin_p (def_stmt, BUILT_IN_MEMSET)"}, {"sha": "08d480a0d860571bb8b350bd6fc1b6e631ca77a0", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -4484,7 +4484,11 @@ find_func_aliases (gimple origt)\n       tree lhsop = gimple_assign_lhs (t);\n       tree rhsop = (gimple_num_ops (t) == 2) ? gimple_assign_rhs1 (t) : NULL;\n \n-      if (rhsop && AGGREGATE_TYPE_P (TREE_TYPE (lhsop)))\n+      if (rhsop && TREE_CLOBBER_P (rhsop))\n+\t/* Ignore clobbers, they don't actually store anything into\n+\t   the LHS.  */\n+\t;\n+      else if (rhsop && AGGREGATE_TYPE_P (TREE_TYPE (lhsop)))\n \tdo_structure_copy (lhsop, rhsop);\n       else\n \t{"}, {"sha": "ef898ee5bbdf2d29d5bb760150b75f2a14425735", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -872,8 +872,11 @@ execute_optimize_stdarg (void)\n \t\t  if (get_gimple_rhs_class (gimple_assign_rhs_code (stmt))\n \t\t      == GIMPLE_SINGLE_RHS)\n \t\t    {\n+\t\t      /* Check for ap ={v} {}.  */\n+\t\t      if (TREE_CLOBBER_P (rhs))\n+\t\t\tcontinue;\n \t\t      /* Check for ap[0].field = temp.  */\n-\t\t      if (va_list_counter_struct_op (&si, lhs, rhs, true))\n+\t\t      else if (va_list_counter_struct_op (&si, lhs, rhs, true))\n \t\t\tcontinue;\n \n \t\t      /* Check for temp = ap[0].field.  */"}, {"sha": "a76b0bc891a3f11924abab840c0a9f2203830552", "filename": "gcc/tree.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47598145be96f39a73809240153e5af12bfbcedd/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=47598145be96f39a73809240153e5af12bfbcedd", "patch": "@@ -1643,6 +1643,14 @@ struct GTY(()) tree_vec {\n #define CONSTRUCTOR_BITFIELD_P(NODE) \\\n   (DECL_BIT_FIELD (FIELD_DECL_CHECK (NODE)) && DECL_MODE (NODE) != BLKmode)\n \n+/* True if NODE is a clobber right hand side, an expression of indeterminate\n+   value that clobbers the LHS in a copy instruction.  We use a volatile\n+   empty CONSTRUCTOR for this, as it matches most of the necessary semantic.\n+   In particular the volatile flag causes us to not prematurely remove\n+   such clobber instructions.  */\n+#define TREE_CLOBBER_P(NODE) \\\n+  (TREE_CODE (NODE) == CONSTRUCTOR && TREE_THIS_VOLATILE (NODE))\n+\n /* A single element of a CONSTRUCTOR. VALUE holds the actual value of the\n    element. INDEX can optionally design the position of VALUE: in arrays,\n    it is the index where VALUE has to be placed; in structures, it is the"}]}