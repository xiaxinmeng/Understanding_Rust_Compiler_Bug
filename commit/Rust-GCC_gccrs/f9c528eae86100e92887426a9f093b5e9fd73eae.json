{"sha": "f9c528eae86100e92887426a9f093b5e9fd73eae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjljNTI4ZWFlODYxMDBlOTI4ODc0MjZhOWYwOTNiNWU5ZmQ3M2VhZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-12-29T08:28:50Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-12-29T08:28:50Z"}, "message": "cp-tree.h (lang_type): Add nearly_empty_p.\n\n\t* cp-tree.h (lang_type): Add nearly_empty_p.  Adjust dummy.\n\t(CLASSTYPE_NEARLY_EMPTY_P): New macro.\n\t* class.c (check_bases): Update CLASSTYPE_NEARLY_EMPTY_P.\n\t(check_field_decls): Likewise.\n\t(check_bases_and_members): Likewise.\n\nFrom-SVN: r31116", "tree": {"sha": "8e433272cbbb01e3e71decf73d9702f66933c2ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e433272cbbb01e3e71decf73d9702f66933c2ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9c528eae86100e92887426a9f093b5e9fd73eae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9c528eae86100e92887426a9f093b5e9fd73eae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9c528eae86100e92887426a9f093b5e9fd73eae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9c528eae86100e92887426a9f093b5e9fd73eae/comments", "author": null, "committer": null, "parents": [{"sha": "2ef161408c2096be9b57848af32d5923046db7dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ef161408c2096be9b57848af32d5923046db7dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ef161408c2096be9b57848af32d5923046db7dc"}], "stats": {"total": 48, "additions": 46, "deletions": 2}, "files": [{"sha": "e6df5baaaf8e10286f094a2218fcb6643ad0ca57", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9c528eae86100e92887426a9f093b5e9fd73eae/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9c528eae86100e92887426a9f093b5e9fd73eae/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f9c528eae86100e92887426a9f093b5e9fd73eae", "patch": "@@ -1,3 +1,11 @@\n+1999-12-29  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (lang_type): Add nearly_empty_p.  Adjust dummy.\n+\t(CLASSTYPE_NEARLY_EMPTY_P): New macro.\n+\t* class.c (check_bases): Update CLASSTYPE_NEARLY_EMPTY_P.\n+\t(check_field_decls): Likewise.\n+\t(check_bases_and_members): Likewise.\n+\n 1999-12-28  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (do_inline_function_hair): Remove."}, {"sha": "88b566ece4b0093c297f31b1ec9d1e96fff01187", "filename": "gcc/cp/class.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9c528eae86100e92887426a9f093b5e9fd73eae/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9c528eae86100e92887426a9f093b5e9fd73eae/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f9c528eae86100e92887426a9f093b5e9fd73eae", "patch": "@@ -1511,10 +1511,12 @@ check_bases (t, cant_have_default_ctor_p, cant_have_const_ctor_p,\n {\n   int n_baseclasses;\n   int i;\n+  int seen_nearly_empty_base_p;\n   tree binfos;\n \n   binfos = TYPE_BINFO_BASETYPES (t);\n   n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n+  seen_nearly_empty_base_p = 0;\n \n   /* An aggregate cannot have baseclasses.  */\n   CLASSTYPE_NON_AGGREGATE (t) |= (n_baseclasses != 0);\n@@ -1578,6 +1580,20 @@ check_bases (t, cant_have_default_ctor_p, cant_have_const_ctor_p,\n \t    }\n \t}\n \n+      /* If the base class is not empty or nearly empty, then this\n+\t class cannot be nearly empty.  */\n+      if (!CLASSTYPE_NEARLY_EMPTY_P (basetype) && !is_empty_class (basetype))\n+\tCLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n+      /* And if there is more than one nearly empty base, then the\n+\t derived class is not nearly empty either.  */\n+      else if (CLASSTYPE_NEARLY_EMPTY_P (basetype) \n+\t       && seen_nearly_empty_base_p)\n+\tCLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n+      /* If this is the first nearly empty base class, then remember\n+\t that we saw it.  */\n+      else if (CLASSTYPE_NEARLY_EMPTY_P (basetype))\n+\tseen_nearly_empty_base_p = 1;\n+\n       /* A lot of properties from the bases also apply to the derived\n \t class.  */\n       TYPE_NEEDS_CONSTRUCTING (t) |= TYPE_NEEDS_CONSTRUCTING (basetype);\n@@ -3480,7 +3496,12 @@ check_field_decls (t, access_decls, empty_p,\n \t       non-empty.  */\n \t    ;\n \t  else\n-\t    *empty_p = 0;\n+\t    {\n+\t      /* The class is non-empty.  */\n+\t      *empty_p = 0;\n+\t      /* The class is not even nearly empty.  */\n+\t      CLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n+\t    }\n \t}\n \n       if (TREE_CODE (x) == USING_DECL)\n@@ -3986,6 +4007,10 @@ check_bases_and_members (t, empty_p)\n   cant_have_const_ctor = 0;\n   no_const_asn_ref = 0;\n \n+  /* Assume that the class is nearly empty; we'll clear this flag if\n+     it turns out not to be nearly empty.  */\n+  CLASSTYPE_NEARLY_EMPTY_P (t) = 1;\n+\n   /* Check all the base-classes. */\n   check_bases (t, &cant_have_default_ctor, &cant_have_const_ctor,\n \t       &no_const_asn_ref);\n@@ -3999,6 +4024,11 @@ check_bases_and_members (t, empty_p)\n   /* Check all the method declarations.  */\n   check_methods (t);\n \n+  /* A nearly-empty class has to be polymorphic; a nearly empty class\n+     contains a vptr.  */\n+  if (!TYPE_POLYMORPHIC_P (t))\n+    CLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n+\n   /* Do some bookkeeping that will guide the generation of implicitly\n      declared member functions.  */\n   TYPE_HAS_COMPLEX_INIT_REF (t)"}, {"sha": "d5be18cb0747c12eb44d1cdc2f81891274b6687d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9c528eae86100e92887426a9f093b5e9fd73eae/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9c528eae86100e92887426a9f093b5e9fd73eae/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f9c528eae86100e92887426a9f093b5e9fd73eae", "patch": "@@ -1218,6 +1218,7 @@ struct lang_type\n \n   unsigned com_interface : 1;\n   unsigned non_pod_class : 1;\n+  unsigned nearly_empty_p : 1;\n \n   /* When adding a flag here, consider whether or not it ought to\n      apply to a template instance if it applies to the template.  If\n@@ -1226,7 +1227,7 @@ struct lang_type\n   /* There are six bits left to fill out a 32-bit word.  Keep track of\n      this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 6;\n+  unsigned dummy : 5;\n       \n   int vsize;\n   int vfield_parent;\n@@ -1461,6 +1462,11 @@ struct lang_type\n /*  Nonzero means that this class type is a non-POD class.  */\n #define CLASSTYPE_NON_POD_P(NODE) (TYPE_LANG_SPECIFIC (NODE)->non_pod_class)\n \n+/* Nonzero if this class is \"nearly empty\", i.e., contains only a\n+   virtual function table pointer.  */\n+#define CLASSTYPE_NEARLY_EMPTY_P(NODE) \\\n+  (TYPE_LANG_SPECIFIC (NODE)->nearly_empty_p)\n+\n /* Nonzero means that this type is meant for communication via COM.  */\n #define CLASSTYPE_COM_INTERFACE(NODE) \\\n   (TYPE_LANG_SPECIFIC(NODE)->com_interface)"}]}