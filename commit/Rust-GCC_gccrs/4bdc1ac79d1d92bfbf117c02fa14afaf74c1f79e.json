{"sha": "4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJkYzFhYzc5ZDFkOTJiZmJmMTE3YzAyZmExNGFmYWY3NGMxZjc5ZQ==", "commit": {"author": {"name": "Philip Blundell", "email": "pb@nexus.co.uk", "date": "1999-07-26T16:35:08Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-07-26T16:35:08Z"}, "message": "Apply Philip Blundell  <pb@nexus.co.uk>'s patch to add PIC support to the Thumb.\n\nFrom-SVN: r28268", "tree": {"sha": "1ddb82df982660cc8ea0cd8ab442c44cda11c6d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ddb82df982660cc8ea0cd8ab442c44cda11c6d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e/comments", "author": null, "committer": null, "parents": [{"sha": "3a27d5755d9376f866c5cfe7941c23a5b8322140", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a27d5755d9376f866c5cfe7941c23a5b8322140", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a27d5755d9376f866c5cfe7941c23a5b8322140"}], "stats": {"total": 513, "additions": 488, "deletions": 25}, "files": [{"sha": "76e8aeef2ba8cc679140cbc6e2bc3c1d90f98af4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e", "patch": "@@ -1,3 +1,51 @@\n+Mon Jul 26 17:24:51 1999  Philip Blundell  <pb@nexus.co.uk>\n+\n+\t* config/arm/thumb.h (THUMB_FLAG_SINGLE_PIC_BASE): Define.\n+\t(TARGET_SINGLE_PIC_BASE): Likewise.\n+\t(GOT_PCREL, NEED_GOT_RELOC, NEED_PLT_RELOC): Provide default\n+\tdefinitions.\n+\t(TARGET_CALLEE_INTERWORKING): Fix typo in comment.\n+\t(TARGET_SWITCHES): Add -m{no-}single-pic-base.\n+\t(TARGET_OPTIONS): Add -mpic-register=N.\n+\t(OUTPUT_INT_ADDR_CONST): New macro.\n+\t(INDEX_REGISTER_RTX_P, PIC_OFFSET_TABLE_REGNUM, FINALIZE_PIC,\n+\tLEGITIMATE_PIC_OPERAND_P): Likewise.\n+\t(LEGITIMIZE_ADDRESS, GOT_IF_LEGITIMATE_ADDRESS): Support PIC.\n+\t(ASM_OUTPUT_INT): Use OUTPUT_INT_ADDR_CONST rather than calling\n+\toutput_addr_const directly.\n+\t(PRINT_OPERAND_PUNCT_VALID_P): Accept `|' for compatibility with \n+\tARM port.\n+\t(thumb_pic_register, thumb_pic_register_string): Declare.\n+\t\n+\t* config/arm/thumb.c (symbol_mentioned_p): New function: Imported\n+\tfrom arm.c.\n+\t(label_mentioned_p): New function: Imported from arm.c.\n+\t(legitimize_pic_address): New function: Imported from arm.c.\n+\t(is_pic):New function: Imported\tfrom arm.c.\n+\t(thumb_finalize_pic):New function: Imported from arm.c.\n+\t(add_constant): Cope with PIC constants.\n+\t(fixit): Cope with PIC constants.\n+\t(output_return): Do not treat the PIC register as live if\n+\tTARGET_SINGLE_PIC_BASE is true.\n+\t(thumb_function_prologue): Do not treat the PIC register as live if\n+\tTARGET_SINGLE_PIC_BASE is true.\n+\t(thumb_expand_prologue): Do not treat the PIC register as live if\n+\tTARGET_SINGLE_PIC_BASE is true.\n+\t(thumb_unexpand_epilogue): Do not treat the PIC register as live if\n+\tTARGET_SINGLE_PIC_BASE is true.\n+\t(thumb_print_operand): Accept '|'.\n+\t(thumb_override_options): Process PIC options.\n+\t\n+\t* config/arm/thumb.md (movsi): Support PIC.\n+\t(call_insn): Change \"i\" constraint to \"X\".\n+\t(call_value_insn): Likewise.\n+\t(consttable_4, consttable_8, consttable_end): Set and clear\n+\t\"making_const_table\" as appropriate.\n+\t(pic_load_addr, pic_add_dot_plus_four): New insns.\n+\t\n+\t* invoke.texi (Thumb Options): Fix spelling.  Document new \n+\toptions -msingle-pic-base and -mpic-register=.\n+\t\n 1999-07-26  Andrew Haley  <aph@cygnus.com>\n \n \t* config/m32r/initfini.c (__init): Use a full word immediate for"}, {"sha": "fa09524eea3cb736a157ede1e9f0d8a9a6f990ae", "filename": "gcc/config/arm/thumb.c", "status": "modified", "additions": 276, "deletions": 15, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e/gcc%2Fconfig%2Farm%2Fthumb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e/gcc%2Fconfig%2Farm%2Fthumb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.c?ref=4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e", "patch": "@@ -32,6 +32,9 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"tree.h\"\n #include \"expr.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"toplev.h\"\n \n \f\n int current_function_anonymous_args = 0;\n@@ -40,12 +43,19 @@ int current_function_anonymous_args = 0;\n char * structure_size_string = NULL;\n int    arm_structure_size_boundary = 32; /* Used to be 8 */\n \n+/* The register number to be used for the PIC offset register.  */\n+const char * thumb_pic_register_string = NULL;\n+int thumb_pic_register = 10;\n+\n+/* True if we are currently building a constant table. */\n+int making_const_table;\n+\n \f\n /* Predicates */\n int\n reload_memory_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED ;\n {\n   int regno = true_regnum (op);\n \n@@ -70,7 +80,6 @@ int\n thumb_shiftable_const (val)\n      HOST_WIDE_INT val;\n {\n-  unsigned HOST_WIDE_INT x = val;\n   unsigned HOST_WIDE_INT mask = 0xff;\n   int i;\n \n@@ -105,6 +114,221 @@ thumb_trivial_epilogue ()\n #endif\n }\n \n+\f\n+/* Return TRUE if X references a SYMBOL_REF.  */\n+int\n+symbol_mentioned_p (x)\n+     rtx x;\n+{\n+  register char * fmt;\n+  register int i;\n+\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    return 1;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    if (symbol_mentioned_p (XVECEXP (x, i, j)))\n+\t      return 1;\n+\t}\n+      else if (fmt[i] == 'e' && symbol_mentioned_p (XEXP (x, i)))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return TRUE if X references a LABEL_REF.  */\n+int\n+label_mentioned_p (x)\n+     rtx x;\n+{\n+  register char * fmt;\n+  register int i;\n+\n+  if (GET_CODE (x) == LABEL_REF)\n+    return 1;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    if (label_mentioned_p (XVECEXP (x, i, j)))\n+\t      return 1;\n+\t}\n+      else if (fmt[i] == 'e' && label_mentioned_p (XEXP (x, i)))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n+rtx\n+legitimize_pic_address (orig, mode, reg)\n+     rtx orig;\n+     enum machine_mode mode;\n+     rtx reg;\n+{\n+  if (GET_CODE (orig) == SYMBOL_REF)\n+    {\n+      rtx pic_ref, address;\n+      rtx insn;\n+      int subregs = 0;\n+\n+      if (reg == 0)\n+\t{\n+\t  if (reload_in_progress || reload_completed)\n+\t    abort ();\n+\t  else\n+\t    reg = gen_reg_rtx (Pmode);\n+\n+\t  subregs = 1;\n+\t}\n+\n+#ifdef AOF_ASSEMBLER\n+      /* The AOF assembler can generate relocations for these directly, and\n+\t understands that the PIC register has to be added into the offset.\n+\t */\n+      insn = emit_insn (gen_pic_load_addr_based (reg, orig));\n+#else\n+      if (subregs)\n+\taddress = gen_reg_rtx (Pmode);\n+      else\n+\taddress = reg;\n+\n+      emit_insn (gen_pic_load_addr (address, orig));\n+\n+      pic_ref = gen_rtx_MEM (Pmode,\n+\t\t\t     gen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n+\t\t\t\t\t   address));\n+      RTX_UNCHANGING_P (pic_ref) = 1;\n+      insn = emit_move_insn (reg, pic_ref);\n+#endif\n+      current_function_uses_pic_offset_table = 1;\n+      /* Put a REG_EQUAL note on this insn, so that it can be optimized\n+\t by loop.  */\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, orig,\n+\t\t\t\t\t    REG_NOTES (insn));\n+      return reg;\n+    }\n+  else if (GET_CODE (orig) == CONST)\n+    {\n+      rtx base, offset;\n+\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS\n+\t  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)\n+\treturn orig;\n+\n+      if (reg == 0)\n+\t{\n+\t  if (reload_in_progress || reload_completed)\n+\t    abort ();\n+\t  else\n+\t    reg = gen_reg_rtx (Pmode);\n+\t}\n+\n+      if (GET_CODE (XEXP (orig, 0)) == PLUS)\n+\t{\n+\t  base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n+\t  offset = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n+\t\t\t\t\t   base == reg ? 0 : reg);\n+\t}\n+      else\n+\tabort ();\n+\n+      if (GET_CODE (offset) == CONST_INT)\n+\t{\n+\t  /* The base register doesn't really matter, we only want to\n+\t     test the index for the appropriate mode.  */\n+\t  if (INDEX_REGISTER_RTX_P (offset) && GET_MODE_SIZE (mode) <= 4)\n+\t    goto win;\n+\n+\t  if (! reload_in_progress && ! reload_completed)\n+\t    offset = force_reg (Pmode, offset);\n+\t  else\n+\t    abort ();\n+\n+\twin:\n+\t  if (GET_CODE (offset) == CONST_INT)\n+\t    return plus_constant_for_output (base, INTVAL (offset));\n+\t}\n+\n+      if (GET_MODE_SIZE (mode) > 4)\n+\t{\n+\t  emit_insn (gen_addsi3 (reg, base, offset));\n+\t  return reg;\n+\t}\n+\n+      return gen_rtx_PLUS (Pmode, base, offset);\n+    }\n+  else if (GET_CODE (orig) == LABEL_REF)\n+    current_function_uses_pic_offset_table = 1;\n+\n+  return orig;\n+}\n+\n+static rtx pic_rtx;\n+\n+int\n+is_pic(x)\n+     rtx x;\n+{\n+  if (x == pic_rtx)\n+    return 1;\n+  return 0;\n+}\n+\n+void\n+thumb_finalize_pic ()\n+{\n+#ifndef AOF_ASSEMBLER\n+  rtx l1, pic_tmp, pic_tmp2, seq;\n+  rtx global_offset_table;\n+\n+  if (current_function_uses_pic_offset_table == 0 || TARGET_SINGLE_PIC_BASE)\n+    return;\n+\n+  if (! flag_pic)\n+    abort ();\n+\n+  start_sequence ();\n+  l1 = gen_label_rtx ();\n+\n+  global_offset_table = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n+  /* On the Thumb the PC register contains 'dot + 4' at the time of the\n+     addition.  XXX Is this true?  */\n+  pic_tmp = plus_constant (gen_rtx_LABEL_REF (Pmode, l1), 4);\n+  if (GOT_PCREL)\n+    pic_tmp2 = gen_rtx_CONST (VOIDmode,\n+\t\t\t    gen_rtx_PLUS (Pmode, global_offset_table, pc_rtx));\n+  else\n+    pic_tmp2 = gen_rtx_CONST (VOIDmode, global_offset_table);\n+\n+  pic_rtx = gen_rtx_CONST (Pmode, gen_rtx_MINUS (Pmode, pic_tmp2, pic_tmp));\n+  \n+  emit_insn (gen_pic_load_addr (pic_offset_table_rtx, pic_rtx));\n+  emit_insn (gen_pic_add_dot_plus_four (pic_offset_table_rtx, l1));\n+\n+  seq = gen_sequence ();\n+  end_sequence ();\n+  emit_insn_after (seq, get_insns ());\n+\n+  /* Need to emit this whether or not we obey regdecls,\n+     since setjmp/longjmp can cause life info to screw up.  */\n+  emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n+#endif /* AOF_ASSEMBLER */\n+}\n+\n \f\n /* Routines for handling the constant pool */\n /* This is unashamedly hacked from the version in sh.c, since the problem is\n@@ -194,6 +418,10 @@ add_constant (x, mode)\n   if (mode == SImode && GET_CODE (x) == MEM && CONSTANT_P (XEXP (x, 0))\n       && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n     x = get_pool_constant (XEXP (x, 0));\n+#ifndef AOF_ASSEMBLER\n+  else if (GET_CODE (x) == UNSPEC && XINT (x, 1) == 3)\n+    x = XVECEXP (x, 0, 0);\n+#endif\n \n   /* First see if we've already got it */\n  \n@@ -272,6 +500,10 @@ fixit (src, mode)\n      rtx src;\n      enum machine_mode mode;\n {\n+#ifndef AOF_ASSEMBLER\n+  if (GET_CODE (src) == UNSPEC && XINT (src, 1) == 3)\n+    return 1;\n+#endif\n   return ((CONSTANT_P (src)\n \t   && (GET_CODE (src) != CONST_INT\n \t       || ! (CONST_OK_FOR_LETTER_P (INTVAL (src), 'I')\n@@ -1004,7 +1236,8 @@ output_return ()\n   return_used_this_function = 1;\n \n   for (regno = 0; regno < 8; regno++)\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+    if (regs_ever_live[regno] && ! call_used_regs[regno]\n+\t&& ! (TARGET_SINGLE_PIC_BASE && (regno == thumb_pic_register)))\n       live_regs_mask |= 1 << regno;\n \n   if (live_regs_mask == 0)\n@@ -1120,7 +1353,8 @@ thumb_function_prologue (f, frame_size)\n     }\n \n   for (regno = 0; regno < 8; regno++)\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+    if (regs_ever_live[regno] && ! call_used_regs[regno]\n+\t&& ! (TARGET_SINGLE_PIC_BASE && (regno == thumb_pic_register)))\n       live_regs_mask |= 1 << regno;\n \n   if (live_regs_mask || ! leaf_function_p () || far_jump_used_p())\n@@ -1214,7 +1448,8 @@ thumb_function_prologue (f, frame_size)\n \n   for (regno = 8; regno < 13; regno++)\n     {\n-      if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      if (regs_ever_live[regno] && ! call_used_regs[regno]\n+\t  && ! (TARGET_SINGLE_PIC_BASE && (regno == thumb_pic_register)))\n \thigh_regs_pushed++;\n     }\n \n@@ -1226,7 +1461,8 @@ thumb_function_prologue (f, frame_size)\n \n       for (next_hi_reg = 12; next_hi_reg > 7; next_hi_reg--)\n \t{\n-\t  if (regs_ever_live[next_hi_reg] && ! call_used_regs[next_hi_reg])\n+\t  if (regs_ever_live[next_hi_reg] && ! call_used_regs[next_hi_reg]\n+\t      && ! (TARGET_SINGLE_PIC_BASE && (next_hi_reg == thumb_pic_register)))\n \t    break;\n \t}\n \n@@ -1253,7 +1489,9 @@ thumb_function_prologue (f, frame_size)\n \t\t    for (next_hi_reg--; next_hi_reg > 7; next_hi_reg--)\n \t\t      {\n \t\t\tif (regs_ever_live[next_hi_reg]\n-\t\t\t    && ! call_used_regs[next_hi_reg])\n+\t\t\t    && ! call_used_regs[next_hi_reg]\n+\t\t\t    && ! (TARGET_SINGLE_PIC_BASE \n+\t\t\t\t  && (next_hi_reg == thumb_pic_register)))\n \t\t\t  break;\n \t\t      }\n \t\t  else\n@@ -1289,7 +1527,8 @@ thumb_expand_prologue ()\n     {\n       live_regs_mask = 0;\n       for (regno = 0; regno < 8; regno++)\n-\tif (regs_ever_live[regno] && ! call_used_regs[regno])\n+\tif (regs_ever_live[regno] && ! call_used_regs[regno]\n+\t    && ! (TARGET_SINGLE_PIC_BASE && (regno == thumb_pic_register)))\n \t  live_regs_mask |= 1 << regno;\n \n       if (amount < 512)\n@@ -1399,12 +1638,14 @@ thumb_unexpanded_epilogue ()\n     return \"\";\n \n   for (regno = 0; regno < 8; regno++)\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+    if (regs_ever_live[regno] && ! call_used_regs[regno]\n+\t&& ! (TARGET_SINGLE_PIC_BASE && (regno == thumb_pic_register)))\n       live_regs_mask |= 1 << regno;\n \n   for (regno = 8; regno < 13; regno++)\n     {\n-      if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      if (regs_ever_live[regno] && ! call_used_regs[regno]\n+\t  && ! (TARGET_SINGLE_PIC_BASE && (regno == thumb_pic_register)))\n \thigh_regs_pushed ++;\n     }\n \n@@ -1455,7 +1696,8 @@ thumb_unexpanded_epilogue ()\n \t}\n       \n       for (next_hi_reg = 8; next_hi_reg < 13; next_hi_reg++)\n-\tif (regs_ever_live[next_hi_reg] && ! call_used_regs[next_hi_reg])\n+\tif (regs_ever_live[next_hi_reg] && ! call_used_regs[next_hi_reg]\n+\t    && ! (TARGET_SINGLE_PIC_BASE && (next_hi_reg == thumb_pic_register)))\n \t  break;\n \n       while (high_regs_pushed)\n@@ -1483,7 +1725,9 @@ thumb_unexpanded_epilogue ()\n \t\t\t       reg_names[next_hi_reg], reg_names[regno]);\n \t\t  for (next_hi_reg++; next_hi_reg < 13; next_hi_reg++)\n \t\t    if (regs_ever_live[next_hi_reg] && \n-\t\t\t! call_used_regs[next_hi_reg])\n+\t\t\t! call_used_regs[next_hi_reg]\n+\t\t\t&& ! (TARGET_SINGLE_PIC_BASE \n+\t\t\t      && (next_hi_reg == thumb_pic_register)))\n \t\t      break;\n \t\t}\n \t    }\n@@ -1788,6 +2032,10 @@ thumb_print_operand (f, x, code)\n \t  fputs (ASM_COMMENT_START, f);\n \t  return;\n \n+\tcase '|':\n+\t  /* fputs (REGISTER_PREFIX, f); */\n+\t  return;\n+\n \tcase '_':\n \t  fputs (user_label_prefix, f);\n \t  return;\n@@ -2042,10 +2290,23 @@ thumb_override_options ()\n \twarning (\"Structure size boundary can only be set to 8 or 32\");\n     }\n \n-  if (flag_pic)\n+  if (thumb_pic_register_string != NULL)\n     {\n-      warning (\"Position independent code not supported.  Ignored\");\n-      flag_pic = 0;\n+      int pic_register;\n+\n+      if (! flag_pic)\n+\twarning (\"-mpic-register= is useless without -fpic\");\n+\n+      pic_register = decode_reg_name (thumb_pic_register_string);\n+      \n+      /* Prevent the user from choosing an obviously stupid PIC register.  */\n+      if (pic_register < 0 || call_used_regs[pic_register]\n+\t  || pic_register == HARD_FRAME_POINTER_REGNUM\n+\t  || pic_register == STACK_POINTER_REGNUM\n+\t  || pic_register >= PC_REGNUM)\n+\terror (\"Unable to use '%s' for PIC register\", thumb_pic_register_string);\n+      else\n+\tthumb_pic_register = pic_register;\n     }\n }\n \f"}, {"sha": "434bd5ee2201a6ba6a99d0a5ba6c4239407194ed", "filename": "gcc/config/arm/thumb.h", "status": "modified", "additions": 116, "deletions": 5, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e/gcc%2Fconfig%2Farm%2Fthumb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e/gcc%2Fconfig%2Farm%2Fthumb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.h?ref=4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e", "patch": "@@ -59,6 +59,7 @@ Boston, MA 02111-1307, USA.  */\n #define THUMB_FLAG_BACKTRACE    \t\t0x0002\n #define THUMB_FLAG_LEAF_BACKTRACE\t\t0x0004\n #define ARM_FLAG_THUMB\t\t\t\t0x1000\t/* same as in arm.h */\n+#define THUMB_FLAG_SINGLE_PIC_BASE\t\t0x4000  /* same as in arm.h */\n #define THUMB_FLAG_CALLEE_SUPER_INTERWORKING\t0x40000 \n #define THUMB_FLAG_CALLER_SUPER_INTERWORKING\t0x80000 \n \n@@ -71,8 +72,17 @@ extern int target_flags;\n #define TARGET_BACKTRACE\t(leaf_function_p()\t\t\t      \\\n \t\t\t\t ? (target_flags & THUMB_FLAG_LEAF_BACKTRACE) \\\n \t\t\t\t : (target_flags & THUMB_FLAG_BACKTRACE))\n+#define TARGET_SINGLE_PIC_BASE\t(target_flags & THUMB_FLAG_SINGLE_PIC_BASE)\n \n-/* Set if externally visable functions should assume that they\n+#ifndef GOT_PCREL\n+#define GOT_PCREL\t\t0\n+#endif\n+\n+#ifndef NEED_GOT_RELOC\n+#define NEED_GOT_RELOC\t\t1\n+#endif\n+\n+/* Set if externally visible functions should assume that they\n    might be called in ARM mode, from a non-thumb aware code.  */\n #define TARGET_CALLEE_INTERWORKING\t\\\n      (target_flags & THUMB_FLAG_CALLEE_SUPER_INTERWORKING)\n@@ -101,13 +111,18 @@ extern int target_flags;\n   {\"no-callee-super-interworking\", -THUMB_FLAG_CALLEE_SUPER_INTERWORKING}, \\\n   {\"caller-super-interworking\",\t    THUMB_FLAG_CALLER_SUPER_INTERWORKING}, \\\n   {\"no-caller-super-interworking\", -THUMB_FLAG_CALLER_SUPER_INTERWORKING}, \\\n+  {\"single-pic-base\",\t\t    THUMB_FLAG_SINGLE_PIC_BASE,\t\\\n+     \"Do not load the PIC register in function prologues\" },\t\\\n+  {\"no-single-pic-base\",\t   -THUMB_FLAG_SINGLE_PIC_BASE, \"\" }, \\\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n   {\"\",                          TARGET_DEFAULT}         \t\\\n }\n \n #define TARGET_OPTIONS\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n   { \"structure-size-boundary=\", & structure_size_string }, \t\\\n+  { \"pic-register=\", & thumb_pic_register_string,\t\t\\\n+     \"Specify the register to be used for PIC addressing\" }\t\\\n }\n \n #define REGISTER_PREFIX \"\"\n@@ -170,7 +185,7 @@ extern int target_flags;\n #define ASM_OUTPUT_INT(STREAM,VALUE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   fprintf (STREAM, \"\\t.word\\t\");\t\t\t\t\t\\\n-  output_addr_const (STREAM, (VALUE));\t\t\t\t\t\\\n+  OUTPUT_INT_ADDR_CONST (STREAM, (VALUE));\t\t\t\t\\\n   fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n }\n \n@@ -556,6 +571,9 @@ enum reg_class\n   ((REGNO) < 8\t\t\t\t\t\\\n    || (unsigned) reg_renumber[REGNO] < 8)\n \n+#define INDEX_REGISTER_RTX_P(X)  \\\n+  (GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\n+\n /* ??? This looks suspiciously wrong.  */\n /* We need to leave BASE_REGS reloads alone, in order to avoid caller_save\n    lossage.  Caller_saves requests a BASE_REGS reload (caller_save_spill_class)\n@@ -633,6 +651,9 @@ int thumb_shiftable_const ();\n \n #define STATIC_CHAIN_REGNUM 9\n \n+/* Define this if the program counter is overloaded on a register.  */\n+#define PC_REGNUM\t\t15\n+\n #define FRAME_POINTER_REQUIRED 0\n \n #define ELIMINABLE_REGS\t\t\t\t\\\n@@ -797,6 +818,39 @@ int thumb_shiftable_const ();\n \t\t  (FNADDR));\t\t\t\t\t\t\\\n }\n \n+\f\n+/* Position Independent Code.  */\n+/* We decide which register to use based on the compilation options and\n+   the assembler in use.  @@@ Actually, we don't currently for Thumb.  */\n+extern int thumb_pic_register;\n+\n+/* The register number of the register used to address a table of static\n+   data addresses in memory.  */\n+#define PIC_OFFSET_TABLE_REGNUM thumb_pic_register\n+\n+#define FINALIZE_PIC thumb_finalize_pic ()\n+\n+/* We can't directly access anything that contains a symbol,\n+   nor can we indirect via the constant pool.  */\n+#define LEGITIMATE_PIC_OPERAND_P(X)\t\t\t\t\\\n+\t(! symbol_mentioned_p (X)\t\t\t\t\\\n+\t && (! CONSTANT_POOL_ADDRESS_P (X)\t\t\t\\\n+\t     || ! symbol_mentioned_p (get_pool_constant (X))))\n+\n+/* We need to know when we are making a constant pool; this determines\n+   whether data needs to be in the GOT or can be referenced via a GOT\n+   offset.  */\n+extern int making_const_table;\n+\n+#define CONDITIONAL_REGISTER_USAGE  \\\n+{\t\t\t\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n+      call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 0;\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\n+\n \f\n /* Implicit Calls to Library Routines */\n \n@@ -884,7 +938,7 @@ int thumb_shiftable_const ();\n     goto WIN;\t\t\t\t\t\t\t\t\\\n   /* This is PC relative data before MACHINE_DEPENDENT_REORG runs.  */\t\\\n   else if (GET_MODE_SIZE (MODE) >= 4 && CONSTANT_P (X)\t\t\t\\\n-\t   && CONSTANT_POOL_ADDRESS_P (X))\t\t\t\t\\\n+\t   && CONSTANT_POOL_ADDRESS_P (X) && ! flag_pic)\t\t\\\n     goto WIN;\t\t\t\t\t\t\t\t\\\n   /* This is PC relative data after MACHINE_DEPENDENT_REORG runs.  */\t\\\n   else if (GET_MODE_SIZE (MODE) >= 4 && reload_completed\t\t\\\n@@ -955,6 +1009,12 @@ int thumb_shiftable_const ();\n \t       && (INTVAL (XEXP (X, 1)) & 3) == 0)\t\t\t\\\n \tgoto WIN;\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\t\\\n+\t   && GET_CODE (X) == SYMBOL_REF\t\t\t\t\\\n+\t   && CONSTANT_POOL_ADDRESS_P (X)\t\t\t\t\\\n+\t   && ! (flag_pic\t\t\t\t\t\t\\\n+\t\t && symbol_mentioned_p (get_pool_constant (X))))\t\\\n+    goto WIN;\t\t\t\t\t\t\t\t\\\n }\n \n /* ??? If an HImode FP+large_offset address is converted to an HImode\n@@ -985,7 +1045,10 @@ int thumb_shiftable_const ();\n   \n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n \n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\n+extern struct rtx_def * legitimize_pic_address ();\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\t\t\t\t\\\n+    (X) = legitimize_pic_address (OLDX, MODE, NULL_RTX);\n \n #define LEGITIMATE_CONSTANT_P(X)\t\\\n  (GET_CODE (X) == CONST_INT\t\t\\\n@@ -1078,6 +1141,28 @@ int thumb_shiftable_const ();\n \f\n /* Position Independent Code */\n \n+extern const char * thumb_pic_register_string;\n+extern int thumb_pic_register;\n+\n+/* The register number of the register used to address a table of static\n+   data addresses in memory.  */\n+#define PIC_OFFSET_TABLE_REGNUM thumb_pic_register\n+\n+#define FINALIZE_PIC thumb_finalize_pic ()\n+\n+/* We can't directly access anything that contains a symbol,\n+   nor can we indirect via the constant pool.  */\n+#define LEGITIMATE_PIC_OPERAND_P(X)\t\t\t\t\\\n+\t(! symbol_mentioned_p (X)\t\t\t\t\\\n+\t && (! CONSTANT_POOL_ADDRESS_P (X)\t\t\t\\\n+\t     || ! symbol_mentioned_p (get_pool_constant (X))))\n+ \n+/* We need to know when we are making a constant pool; this determines\n+   whether data needs to be in the GOT or can be referenced via a GOT\n+   offset.  */\n+extern int making_const_table;\n+\n+\f\n #define PRINT_OPERAND(STREAM,X,CODE) \\\n   thumb_print_operand((STREAM), (X), (CODE))\n \n@@ -1102,7 +1187,33 @@ int thumb_shiftable_const ();\n     output_addr_const ((STREAM), (X));\t\t\t\t\\\n }\n \n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '@' || ((CODE) == '_'))\n+/* Handles PIC addr specially */\n+#define OUTPUT_INT_ADDR_CONST(STREAM,X) \\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (flag_pic && GET_CODE(X) == CONST && is_pic(X))\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\toutput_addr_const(STREAM, XEXP (XEXP (XEXP (X, 0), 0), 0));\t\\\n+\tfputs(\" - (\", STREAM);\t\t\t\t\t\t\\\n+\toutput_addr_const(STREAM, XEXP (XEXP (XEXP (X, 0), 1), 0));\t\\\n+\tfputs(\")\", STREAM);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else output_addr_const(STREAM, X);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* Mark symbols as position independent.  We only do this in the\t\\\n+      .text segment, not in the .data segment. */\t\t\t\\\n+    if (NEED_GOT_RELOC && flag_pic && making_const_table &&\t\t\\\n+    \t(GET_CODE(X) == SYMBOL_REF || GET_CODE(X) == LABEL_REF))\t\\\n+     {\t\t\t\t\t\t\t\t\t\\\n+        if (GET_CODE(X) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P(X))\t\\\n+          fprintf(STREAM, \"(GOTOFF)\");\t\t\t\t\t\\\n+        else if (GET_CODE (X) == LABEL_REF)\t\t\t\t\\\n+          fprintf(STREAM, \"(GOTOFF)\");\t\t\t\t\t\\\n+        else\t\t\t\t\t\t\t\t\\\n+          fprintf(STREAM, \"(GOT)\");\t\t\t\t\t\\\n+     }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '@' || ((CODE) == '_') || ((CODE) == '|'))\n \n /* Emit a special directive when defining a function name.\n    This is used by the assembler to assit with interworking.  */"}, {"sha": "d655c47584e8ab738c803546f9c99721cceaa1cf", "filename": "gcc/config/arm/thumb.md", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e/gcc%2Fconfig%2Farm%2Fthumb.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e/gcc%2Fconfig%2Farm%2Fthumb.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.md?ref=4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e", "patch": "@@ -43,6 +43,11 @@\n       if (GET_CODE (operands[0]) != REG)\n \toperands[1] = force_reg (SImode, operands[1]);\n     }\n+  if (CONSTANT_P (operands[1]) && flag_pic)\n+    operands[1] = legitimize_pic_address (operands[1], SImode,\n+\t\t\t\t\t  ((reload_in_progress\n+\t\t\t\t\t    || reload_completed)\n+\t\t\t\t\t   ? operands[0] : 0));\n \")\n \n (define_insn \"*movsi_insn\"\n@@ -1051,15 +1056,15 @@\n \n \n (define_insn \"*call_insn\"\n-  [(call (mem:SI (match_operand:SI 0 \"\" \"i\"))\n+  [(call (mem:SI (match_operand:SI 0 \"\" \"X\"))\n \t (match_operand:SI 1 \"\" \"\"))]\n   \"GET_CODE (operands[0]) == SYMBOL_REF\"\n   \"bl\\\\t%a0\"\n [(set_attr \"length\" \"4\")])\n \n (define_insn \"*call_value_insn\"\n   [(set (match_operand 0 \"register_operand\" \"=l\")\n-\t(call (mem:SI (match_operand 1 \"\" \"i\"))\n+\t(call (mem:SI (match_operand 1 \"\" \"X\"))\n \t      (match_operand 2 \"\" \"\")))]\n   \"GET_CODE (operands[1]) == SYMBOL_REF\"\n   \"bl\\\\t%a1\"\n@@ -1110,6 +1115,7 @@\n  \"\"\n  \"*\n {\n+  making_const_table = TRUE;\n   switch (GET_MODE_CLASS (GET_MODE (operands[0])))\n     {\n     case MODE_FLOAT:\n@@ -1132,6 +1138,7 @@\n  \"\"\n  \"*\n {\n+  making_const_table = TRUE;\n   switch (GET_MODE_CLASS (GET_MODE (operands[0])))\n     {\n     case MODE_FLOAT:\n@@ -1153,7 +1160,7 @@\n   [(unspec_volatile [(const_int 0)] 4)]\n   \"\"\n   \"*\n-  /* Nothing to do (currently).  */\n+  making_const_table = FALSE;\n   return \\\"\\\";\n \")\n \n@@ -1164,3 +1171,26 @@\n    assemble_align (32);\n    return \\\"\\\";\n \")\n+\n+/* When generating pic, we need to load the symbol offset into a register.\n+   So that the optimizer does not confuse this with a normal symbol load\n+   we use an unspec.  The offset will be loaded from a constant pool entry,\n+   since that is the only type of relocation we can use.  */\n+\n+(define_insn \"pic_load_addr\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand 1 \"\" \"\")] 3))]\n+  \"flag_pic\"\n+  \"ldr\\\\t%0, %a1\")\n+\n+(define_insn \"pic_add_dot_plus_four\"\n+  [(set (match_operand 0 \"register_operand\" \"+r\")\n+\t(plus:SI (match_dup 0) (const (plus:SI (pc) (const_int 4)))))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"flag_pic\"\n+  \"*\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"L\\\",\n+\t\t\t     CODE_LABEL_NUMBER (operands[1]));\n+  return \\\"add\\\\t%0, %|pc\\\";\n+\")\n+"}, {"sha": "06ce6bf6b116d95257778efa5a9824143db3850d", "filename": "gcc/invoke.texi", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=4bdc1ac79d1d92bfbf117c02fa14afaf74c1f79e", "patch": "@@ -276,6 +276,8 @@ in the following sections.\n -mnop-fun-dllimport -mno-nop-fun-dllimport\n -mcallee-super-interworking -mno-callee-super-interworking\n -mcaller-super-interworking -mno-caller-super-interworking\n+-msingle-pic-base -mno-single-pic-base\n+-mpic-register=\n \n @emph{MN10200 Options}\n -mrelax\n@@ -4395,7 +4397,7 @@ Generate code for a processor running in big-endian mode.\n @item -mstructure-size-boundary=<n>\n @kindex -mstructure-size-boundary\n The size of all structures and unions will be rounded up to a multiple\n-of the number of bits set by this option.  Permissable values are 8 and\n+of the number of bits set by this option.  Permissible values are 8 and\n 32.  The default value varies for different toolchains.  For the COFF\n targeted toolchain the default value is 8.  Specifying the larger number\n can produced faster, more efficient code, but can also increase the size\n@@ -4421,7 +4423,18 @@ non-interworking code.\n Allows calls via function pointers (including virtual functions) to\n execute correctly regardless of whether the target code has been\n compiled for interworking or not.  There is a small overhead in the cost\n-of executing a funciton pointer if this option is enabled.\n+of executing a function pointer if this option is enabled.\n+\n+@item -msingle-pic-base\n+@kindex -msingle-pic-base\n+Treat the register used for PIC addressing as read-only, rather than\n+loading it in the prologue for each function.  The run-time system is\n+responsible for initialising this register with an appropriate value\n+before execution begins.\n+\n+@item -mpic-register=<reg>\n+@kindex -mpic-register=\n+Specify the register to be used for PIC addressing.  The default is R10.\n \n @end table\n "}]}