{"sha": "fef37404e93aaaa06378bfeaf4ad8db32c184775", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVmMzc0MDRlOTNhYWFhMDYzNzhiZmVhZjRhZDhkYjMyYzE4NDc3NQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2014-01-15T17:32:47Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2014-01-15T17:32:47Z"}, "message": "re PR rtl-optimization/59511 (FAIL: gcc.target/i386/pr36222-1.c scan-assembler-not movdqa with -mtune=corei7)\n\n2014-01-15  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/59511\n\t* ira.c (ira_init_register_move_cost): Use memory costs for some\n\tcases of register move cost calculations.\n\t* lra-constraints.c (lra_constraints): Use REG_FREQ_FROM_BB\n\tinstead of BB frequency.\n\t* lra-coalesce.c (move_freq_compare_func, lra_coalesce): Ditto.\n\t* lra-assigns.c (find_hard_regno_for): Ditto.\n\nFrom-SVN: r206636", "tree": {"sha": "4b6cdf1a3a3ac85f215b25daa4443679c1411cc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b6cdf1a3a3ac85f215b25daa4443679c1411cc8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fef37404e93aaaa06378bfeaf4ad8db32c184775", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef37404e93aaaa06378bfeaf4ad8db32c184775", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fef37404e93aaaa06378bfeaf4ad8db32c184775", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef37404e93aaaa06378bfeaf4ad8db32c184775/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "348aa1da38633b3756f3f1fb6de22d8d318384c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/348aa1da38633b3756f3f1fb6de22d8d318384c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/348aa1da38633b3756f3f1fb6de22d8d318384c2"}], "stats": {"total": 161, "additions": 88, "deletions": 73}, "files": [{"sha": "8fe6aca218ce5ef9a518078838544c45a0a67164", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef37404e93aaaa06378bfeaf4ad8db32c184775/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef37404e93aaaa06378bfeaf4ad8db32c184775/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fef37404e93aaaa06378bfeaf4ad8db32c184775", "patch": "@@ -1,3 +1,13 @@\n+2014-01-15  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/59511\n+\t* ira.c (ira_init_register_move_cost): Use memory costs for some\n+\tcases of register move cost calculations.\n+\t* lra-constraints.c (lra_constraints): Use REG_FREQ_FROM_BB\n+\tinstead of BB frequency.\n+\t* lra-coalesce.c (move_freq_compare_func, lra_coalesce): Ditto.\n+\t* lra-assigns.c (find_hard_regno_for): Ditto.\n+\n 2014-01-15  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/59822"}, {"sha": "41e05f43c4088c6e18011435d3cdc97f4fbf7a42", "filename": "gcc/ira.c", "status": "modified", "additions": 68, "deletions": 66, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef37404e93aaaa06378bfeaf4ad8db32c184775/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef37404e93aaaa06378bfeaf4ad8db32c184775/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=fef37404e93aaaa06378bfeaf4ad8db32c184775", "patch": "@@ -1574,21 +1574,30 @@ ira_init_register_move_cost (enum machine_mode mode)\n \t      && ira_may_move_out_cost[mode] == NULL);\n   ira_assert (have_regs_of_mode[mode]);\n   for (cl1 = 0; cl1 < N_REG_CLASSES; cl1++)\n-    if (contains_reg_of_mode[cl1][mode])\n-      for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n-\t{\n-\t  int cost;\n-\t  if (!contains_reg_of_mode[cl2][mode])\n-\t    cost = 65535;\n-\t  else\n-\t    {\n-\t      cost = register_move_cost (mode, (enum reg_class) cl1,\n-\t\t\t\t\t (enum reg_class) cl2);\n-\t      ira_assert (cost < 65535);\n-\t    }\n-\t  all_match &= (last_move_cost[cl1][cl2] == cost);\n-\t  last_move_cost[cl1][cl2] = cost;\n-\t}\n+    for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n+      {\n+\tint cost;\n+\tif (!contains_reg_of_mode[cl1][mode]\n+\t    || !contains_reg_of_mode[cl2][mode])\n+\t  {\n+\t    if ((ira_reg_class_max_nregs[cl1][mode]\n+\t\t > ira_class_hard_regs_num[cl1])\n+\t\t|| (ira_reg_class_max_nregs[cl2][mode]\n+\t\t    > ira_class_hard_regs_num[cl2]))\n+\t      cost = 65535;\n+\t    else\n+\t      cost = (ira_memory_move_cost[mode][cl1][0]\n+\t\t      + ira_memory_move_cost[mode][cl2][1]);\n+\t  }\n+\telse\n+\t  {\n+\t    cost = register_move_cost (mode, (enum reg_class) cl1,\n+\t\t\t\t       (enum reg_class) cl2);\n+\t    ira_assert (cost < 65535);\n+\t  }\n+\tall_match &= (last_move_cost[cl1][cl2] == cost);\n+\tlast_move_cost[cl1][cl2] = cost;\n+      }\n   if (all_match && last_mode_for_init_move_cost != -1)\n     {\n       ira_register_move_cost[mode]\n@@ -1604,58 +1613,51 @@ ira_init_register_move_cost (enum machine_mode mode)\n   ira_may_move_in_cost[mode] = XNEWVEC (move_table, N_REG_CLASSES);\n   ira_may_move_out_cost[mode] = XNEWVEC (move_table, N_REG_CLASSES);\n   for (cl1 = 0; cl1 < N_REG_CLASSES; cl1++)\n-    if (contains_reg_of_mode[cl1][mode])\n-      for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n-\t{\n-\t  int cost;\n-\t  enum reg_class *p1, *p2;\n-\n-\t  if (last_move_cost[cl1][cl2] == 65535)\n-\t    {\n-\t      ira_register_move_cost[mode][cl1][cl2] = 65535;\n-\t      ira_may_move_in_cost[mode][cl1][cl2] = 65535;\n-\t      ira_may_move_out_cost[mode][cl1][cl2] = 65535;\n-\t    }\n-\t  else\n-\t    {\n-\t      cost = last_move_cost[cl1][cl2];\n-\n-\t      for (p2 = &reg_class_subclasses[cl2][0];\n-\t\t   *p2 != LIM_REG_CLASSES; p2++)\n-\t\tif (ira_class_hard_regs_num[*p2] > 0\n-\t\t    && (ira_reg_class_max_nregs[*p2][mode]\n-\t\t\t<= ira_class_hard_regs_num[*p2]))\n-\t\t  cost = MAX (cost, ira_register_move_cost[mode][cl1][*p2]);\n-\n-\t      for (p1 = &reg_class_subclasses[cl1][0];\n-\t\t   *p1 != LIM_REG_CLASSES; p1++)\n-\t\tif (ira_class_hard_regs_num[*p1] > 0\n-\t\t    && (ira_reg_class_max_nregs[*p1][mode]\n-\t\t\t<= ira_class_hard_regs_num[*p1]))\n-\t\t  cost = MAX (cost, ira_register_move_cost[mode][*p1][cl2]);\n-\n-\t      ira_assert (cost <= 65535);\n-\t      ira_register_move_cost[mode][cl1][cl2] = cost;\n-\n-\t      if (ira_class_subset_p[cl1][cl2])\n-\t\tira_may_move_in_cost[mode][cl1][cl2] = 0;\n-\t      else\n-\t\tira_may_move_in_cost[mode][cl1][cl2] = cost;\n-\n-\t      if (ira_class_subset_p[cl2][cl1])\n-\t\tira_may_move_out_cost[mode][cl1][cl2] = 0;\n-\t      else\n-\t\tira_may_move_out_cost[mode][cl1][cl2] = cost;\n-\t    }\n-\t}\n-    else\n-      for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n-\t{\n-\t  ira_register_move_cost[mode][cl1][cl2] = 65535;\n-\t  ira_may_move_in_cost[mode][cl1][cl2] = 65535;\n-\t  ira_may_move_out_cost[mode][cl1][cl2] = 65535;\n-\t}\n+    for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n+      {\n+\tint cost;\n+\tenum reg_class *p1, *p2;\n+\t\n+\tif (last_move_cost[cl1][cl2] == 65535)\n+\t  {\n+\t    ira_register_move_cost[mode][cl1][cl2] = 65535;\n+\t    ira_may_move_in_cost[mode][cl1][cl2] = 65535;\n+\t    ira_may_move_out_cost[mode][cl1][cl2] = 65535;\n+\t  }\n+\telse\n+\t  {\n+\t    cost = last_move_cost[cl1][cl2];\n+\t    \n+\t    for (p2 = &reg_class_subclasses[cl2][0];\n+\t\t *p2 != LIM_REG_CLASSES; p2++)\n+\t      if (ira_class_hard_regs_num[*p2] > 0\n+\t\t  && (ira_reg_class_max_nregs[*p2][mode]\n+\t\t      <= ira_class_hard_regs_num[*p2]))\n+\t\tcost = MAX (cost, ira_register_move_cost[mode][cl1][*p2]);\n+\t    \n+\t    for (p1 = &reg_class_subclasses[cl1][0];\n+\t\t *p1 != LIM_REG_CLASSES; p1++)\n+\t      if (ira_class_hard_regs_num[*p1] > 0\n+\t\t  && (ira_reg_class_max_nregs[*p1][mode]\n+\t\t      <= ira_class_hard_regs_num[*p1]))\n+\t\tcost = MAX (cost, ira_register_move_cost[mode][*p1][cl2]);\n+\t    \n+\t    ira_assert (cost <= 65535);\n+\t    ira_register_move_cost[mode][cl1][cl2] = cost;\n+\t    \n+\t    if (ira_class_subset_p[cl1][cl2])\n+\t      ira_may_move_in_cost[mode][cl1][cl2] = 0;\n+\t    else\n+\t      ira_may_move_in_cost[mode][cl1][cl2] = cost;\n+\t    \n+\t    if (ira_class_subset_p[cl2][cl1])\n+\t      ira_may_move_out_cost[mode][cl1][cl2] = 0;\n+\t    else\n+\t      ira_may_move_out_cost[mode][cl1][cl2] = cost;\n+\t  }\n+      }\n }\n+\n \f\n \n /* This is called once during compiler work.  It sets up"}, {"sha": "268edccd6063eb2ea4285b2abbdb256085f963d2", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef37404e93aaaa06378bfeaf4ad8db32c184775/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef37404e93aaaa06378bfeaf4ad8db32c184775/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=fef37404e93aaaa06378bfeaf4ad8db32c184775", "patch": "@@ -612,7 +612,9 @@ find_hard_regno_for (int regno, int *cost, int try_only_hard_regno)\n \t\t&& ! df_regs_ever_live_p (hard_regno + j))\n \t      /* It needs save restore.\t */\n \t      hard_regno_costs[hard_regno]\n-\t\t+= 2 * ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb->frequency + 1;\n+\t\t+= (2\n+\t\t    * REG_FREQ_FROM_BB (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb)\n+\t\t    + 1);\n \t  priority = targetm.register_priority (hard_regno);\n \t  if (best_hard_regno < 0 || hard_regno_costs[hard_regno] < best_cost\n \t      || (hard_regno_costs[hard_regno] == best_cost"}, {"sha": "350977ca220eefe44138c269266924a0e2fa4e1d", "filename": "gcc/lra-coalesce.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef37404e93aaaa06378bfeaf4ad8db32c184775/gcc%2Flra-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef37404e93aaaa06378bfeaf4ad8db32c184775/gcc%2Flra-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-coalesce.c?ref=fef37404e93aaaa06378bfeaf4ad8db32c184775", "patch": "@@ -79,8 +79,8 @@ move_freq_compare_func (const void *v1p, const void *v2p)\n   rtx mv2 = *(const rtx *) v2p;\n   int pri1, pri2;\n \n-  pri1 = BLOCK_FOR_INSN (mv1)->frequency;\n-  pri2 = BLOCK_FOR_INSN (mv2)->frequency;\n+  pri1 = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (mv1));\n+  pri2 = REG_FREQ_FROM_BB (BLOCK_FOR_INSN (mv2));\n   if (pri2 - pri1)\n     return pri2 - pri1;\n \n@@ -277,7 +277,7 @@ lra_coalesce (void)\n \t    fprintf\n \t      (lra_dump_file, \"      Coalescing move %i:r%d-r%d (freq=%d)\\n\",\n \t       INSN_UID (mv), sregno, dregno,\n-\t       BLOCK_FOR_INSN (mv)->frequency);\n+\t       REG_FREQ_FROM_BB (BLOCK_FOR_INSN (mv)));\n \t  /* We updated involved_insns_bitmap when doing the merge.  */\n \t}\n       else if (!(lra_intersected_live_ranges_p\n@@ -291,7 +291,7 @@ lra_coalesce (void)\n \t       \"  Coalescing move %i:r%d(%d)-r%d(%d) (freq=%d)\\n\",\n \t       INSN_UID (mv), sregno, ORIGINAL_REGNO (SET_SRC (set)),\n \t       dregno, ORIGINAL_REGNO (SET_DEST (set)),\n-\t       BLOCK_FOR_INSN (mv)->frequency);\n+\t       REG_FREQ_FROM_BB (BLOCK_FOR_INSN (mv)));\n \t  bitmap_ior_into (&involved_insns_bitmap,\n \t\t\t   &lra_reg_info[sregno].insn_bitmap);\n \t  bitmap_ior_into (&involved_insns_bitmap,\n@@ -316,7 +316,8 @@ lra_coalesce (void)\n \t\t/* Coalesced move.  */\n \t\tif (lra_dump_file != NULL)\n \t\t  fprintf (lra_dump_file, \"\t Removing move %i (freq=%d)\\n\",\n-\t\t\t INSN_UID (insn), BLOCK_FOR_INSN (insn)->frequency);\n+\t\t\t   INSN_UID (insn),\n+\t\t\t   REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn)));\n \t\tlra_set_insn_deleted (insn);\n \t      }\n \t  }"}, {"sha": "07815fe3b1dc546594326fa3be3321b6a416a703", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef37404e93aaaa06378bfeaf4ad8db32c184775/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef37404e93aaaa06378bfeaf4ad8db32c184775/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=fef37404e93aaaa06378bfeaf4ad8db32c184775", "patch": "@@ -4077,7 +4077,7 @@ lra_constraints (bool first_p)\n \t\t      fprintf (lra_dump_file,\n \t\t\t       \"      Removing equiv init insn %i (freq=%d)\\n\",\n \t\t\t       INSN_UID (curr_insn),\n-\t\t\t       BLOCK_FOR_INSN (curr_insn)->frequency);\n+\t\t\t       REG_FREQ_FROM_BB (BLOCK_FOR_INSN (curr_insn)));\n \t\t      dump_insn_slim (lra_dump_file, curr_insn);\n \t\t    }\n \t\t  if (contains_reg_p (x, true, false))"}]}