{"sha": "8251199e44be354aafd37dd69b56a4b1f9620120", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI1MTE5OWU0NGJlMzU0YWFmZDM3ZGQ2OWI1NmE0YjFmOTYyMDEyMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-09-07T14:25:35Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-09-07T14:25:35Z"}, "message": "revert error reporting patch\n\nFrom-SVN: r22310", "tree": {"sha": "4f332f822cd36c92b7c27eee6c003577c1fec279", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f332f822cd36c92b7c27eee6c003577c1fec279"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8251199e44be354aafd37dd69b56a4b1f9620120", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8251199e44be354aafd37dd69b56a4b1f9620120", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8251199e44be354aafd37dd69b56a4b1f9620120", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8251199e44be354aafd37dd69b56a4b1f9620120/comments", "author": null, "committer": null, "parents": [{"sha": "5db17173c6fbef5fd203e486fe8407347edd7142", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5db17173c6fbef5fd203e486fe8407347edd7142", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5db17173c6fbef5fd203e486fe8407347edd7142"}], "stats": {"total": 4794, "additions": 2323, "deletions": 2471}, "files": [{"sha": "7315d2549c922d7cca9cfb906bd28b5748916a51", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -1,63 +1,3 @@\n-1998-09-07  Mark Mitchell  <mark@markmitchell.com>\n-\t    and Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n-\t\n-\t* cp-tree.h (cp_error): Prototype.\n-\t(cp_error_at): Likewise.\n-\t(cp_warning): Likewise.\n-\t(cp_warning_at): Likewise.\n-\t(cp_pedwarn): Likewise.\n-\t(cp_pedwarn_at): Likewise.\n-\t(cp_compiler_error): Likewise.\n-\t(cp_sprintf): Likewise.\n-\t(cp_enable_warning): Likewise.\n-\t* errfn.c: Remove hack to avoid error-function prototypes when\n-\tincluding cp-tree.h.\n-\t\n-1998-09-06  Mark Mitchell  <mark@markmitchell.com>\n-\n-\t* cp-error.def: New file.\n-\t* Make-lang.in (cc1plus): Add dependency on it.\n-\t* Makefile.in (CXX_TREE_H): Likewise.\n-\t* cp-tree.h (error_code): New type.\n-\tInclude cp-error.def to get error codes.  Make it possible to\n-\tinclude cp-tree.h in errfn.c.\n-\t(enable_warning): New function.\n-\t(flag_diag_codes): New variable.\n-\t* errfn.c: Include cp-tree.h.\n-\t(cp_err_msg): New type.  Include cp-error.def to define it.\n-\t(err_msgs): New variable.\n-\t(is_warning_enabled): New function.\n-\t(cp_thing): Take an error_code, not a format string.  Output the\n-\tdiagnostic code if flag_diag_codes.\n-\t(cp_error, cp_compiler_error, cp_sprintf, cp_error_at): Take\n-\terror_codes, not format strings.\n-\t(cp_warning, cp_pedwarn, cp_warning_at, cp_pedwarn_at): Likewise.\n-\tCall is_warning_enabled.\n-\t* decl2.c (flag_diag_codes): New variable.\n-\t(lang_decode_option): Handle -fdiag-codes and -Wnumber.\n-\t* lang-options.h: Add -fdiag-codes, -fno-diag-codes, and\n-\t-W-number-, and -Wno-number.\n-\t\n-\t* class.c: Update all calls to error-functions.\n-\t* cvt.c: Likewise.\n-\t* decl.c: Likewise.\n-\t* decl2.c: Likewise.\n-\t* except.c: Likewise.\n-\t* expr.c: Likewise.\n-\t* friend.c: Likewise.\n-\t* lex.c: Likewise.\n-\t* parse.y: Likewise.\n-\t* pt.c: Likewise.\n-\t* repo.c: Likewise.\n-\t* rtti.c: Likewise.\n-\t* search.c: Likewise.\n-\t* semantics.c: Likewise.\n-\t* sig.c: Likewise.\n-\t* tree.c: Likewise.\n-\t* typeck.c: Likewise.\n-\t* typeck2.c: Likewise.\n-\t* xref.c: Likewise.\n-\t\n Sun Sep  6 00:00:51 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* Makefile.in (INCLUDES): Update after recent toplevel gcc"}, {"sha": "2bea6a675a9977a052a3b4177affb0f05b0a3781", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -125,7 +125,7 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/decl2.c \\\n  $(srcdir)/cp/repo.c $(srcdir)/cp/semantics.c\n \n cc1plus$(exeext): $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o c-pragma.o \\\n-\t$(srcdir)/cp/cp-tree.h $(srcdir)/cp/cp-tree.def $(srcdir)/cp/cp-error.def\n+\t$(srcdir)/cp/cp-tree.h $(srcdir)/cp/cp-tree.def\n \tcd cp; $(MAKE) $(FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) ../cc1plus$(exeext)\n #\f\n # Build hooks:"}, {"sha": "f7e09414cb75904794526f884f59b8248bb25016", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -208,7 +208,7 @@ RTL_H = $(srcdir)/../rtl.h $(srcdir)/../rtl.def \\\n \t$(srcdir)/../machmode.h $(srcdir)/../machmode.def\n TREE_H = $(srcdir)/../tree.h $(srcdir)/../real.h $(srcdir)/../tree.def \\\n \t$(srcdir)/../machmode.h $(srcdir)/../machmode.def\n-CXX_TREE_H = $(TREE_H) cp-tree.h cp-tree.def cp-error.def\n+CXX_TREE_H = $(TREE_H) cp-tree.h cp-tree.def\n PARSE_H = $(srcdir)/parse.h\n PARSE_C = $(srcdir)/parse.c\n EXPR_H = $(srcdir)/../expr.h ../insn-codes.h"}, {"sha": "d27d61614542ac404489e7ca54a8f425a950e21d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -132,7 +132,7 @@ build_field_call (basetype_path, instance_ptr, name, parms)\n \n       if (field == NULL_TREE)\n \t{\n-\t  cp_error (ec_this_has_no_member_named, name);\n+\t  cp_error (\"`this' has no member named `%D'\", name);\n \t  return error_mark_node;\n \t}\n \n@@ -203,7 +203,7 @@ build_field_call (basetype_path, instance_ptr, name, parms)\n \t}\n       else if (TREE_CODE (ftype) == METHOD_TYPE)\n \t{\n-\t  cp_error (ec_invalid_call_via_pointertomember_function);\n+\t  error (\"invalid call via pointer-to-member function\");\n \t  return error_mark_node;\n \t}\n       else\n@@ -421,7 +421,7 @@ build_scoped_method_call (exp, basetype, name, parms)\n \treturn build_method_call (exp, name, parms, NULL_TREE, LOOKUP_NORMAL);\n \n       if (! check_dtor_name (basetype, name))\n-\tcp_error (ec_qualified_type_does_not_match_destructor_name,\n+\tcp_error (\"qualified type `%T' does not match destructor name `~%T'\",\n \t\t  basetype, TREE_OPERAND (name, 0));\n \n       /* Destructors can be \"called\" for simple types; see 5.2.4 and 12.4 Note\n@@ -430,7 +430,7 @@ build_scoped_method_call (exp, basetype, name, parms)\n       if (! IS_AGGR_TYPE (basetype))\n \t{\n \t  if (TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (basetype))\n-\t    cp_error (ec_type_of_does_not_match_destructor_type_type_was,\n+\t    cp_error (\"type of `%E' does not match destructor type `%T' (type was `%T')\",\n \t\t      exp, basetype, type);\n \n \t  return cp_convert (void_type_node, exp);\n@@ -442,7 +442,7 @@ build_scoped_method_call (exp, basetype, name, parms)\n \n   if (! IS_AGGR_TYPE (type))\n     {\n-      cp_error (ec_base_object_of_scoped_method_call_is_of_nonaggregate_type,\n+      cp_error (\"base object `%E' of scoped method call is of non-aggregate type `%T'\",\n \t\texp, type);\n       return error_mark_node;\n     }\n@@ -661,14 +661,15 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n       if (parms)\n-\tcp_error (ec_destructors_take_no_parameters);\n+\terror (\"destructors take no parameters\");\n       basetype = TREE_TYPE (instance);\n       if (TREE_CODE (basetype) == REFERENCE_TYPE)\n \tbasetype = TREE_TYPE (basetype);\n \n       if (! check_dtor_name (basetype, name))\n-\tcp_error (ec_destructor_name_does_not_match_type,\n-\t\t  TREE_OPERAND (name, 0), basetype);\n+\tcp_error\n+\t  (\"destructor name `~%T' does not match type `%T' of expression\",\n+\t   TREE_OPERAND (name, 0), basetype);\n \n       if (! TYPE_HAS_DESTRUCTOR (complete_type (basetype)))\n \treturn cp_convert (void_type_node, instance);\n@@ -2018,20 +2019,20 @@ print_z_candidates (candidates)\n       if (TREE_CODE (candidates->fn) == IDENTIFIER_NODE)\n \t{\n \t  if (candidates->fn == ansi_opname [COND_EXPR])\n-\t    cp_error (ec_builtin_3, str, candidates->fn,\n+\t    cp_error (\"%s %D(%T, %T, %T) <builtin>\", str, candidates->fn,\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)),\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 2)));\n \t  else if (TREE_VEC_LENGTH (candidates->convs) == 2)\n-\t    cp_error (ec_builtin_2, str, candidates->fn,\n+\t    cp_error (\"%s %D(%T, %T) <builtin>\", str, candidates->fn,\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)));\n \t  else\n-\t    cp_error (ec_builtin_1, str, candidates->fn,\n+\t    cp_error (\"%s %D(%T) <builtin>\", str, candidates->fn,\n \t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)));\n \t}\n       else\n-\tcp_error_at (ec_candidate_1, str, candidates->fn,\n+\tcp_error_at (\"%s %+D%s\", str, candidates->fn,\n \t\t     candidates->viable == -1 ? \" <near match>\" : \"\");\n       str = \"               \"; \n     }\n@@ -2168,7 +2169,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n \t  if (candidates && ! candidates->next)\n \t    /* say why this one won't work or try to be loose */;\n \t  else\n-\t    cp_error (ec_no_viable_candidates);\n+\t    cp_error (\"no viable candidates\");\n \t}\n #endif\n \n@@ -2182,7 +2183,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n     {\n       if (flags & LOOKUP_COMPLAIN)\n \t{\n-\t  cp_error (ec_conversion_from_to_is_ambiguous,\n+\t  cp_error (\"conversion from `%T' to `%T' is ambiguous\",\n \t\t    fromtype, totype);\n \t  print_z_candidates (candidates);\n \t}\n@@ -2248,7 +2249,7 @@ resolve_args (args)\n \treturn error_mark_node;\n       else if (TREE_CODE (TREE_TYPE (TREE_VALUE (t))) == VOID_TYPE)\n \t{\n-\t  cp_error (ec_invalid_use_of_void_expression);\n+\t  error (\"invalid use of void expression\");\n \t  return error_mark_node;\n \t}\n       else if (TREE_CODE (TREE_VALUE (t)) == OFFSET_REF)\n@@ -2301,7 +2302,7 @@ build_new_function_call (fn, args)\n \t{\n \t  if (candidates && ! candidates->next)\n \t    return build_function_call (candidates->fn, args);\n-\t  cp_error (ec_no_matching_function_for_call_to,\n+\t  cp_error (\"no matching function for call to `%D (%A)'\",\n \t\t    DECL_NAME (OVL_FUNCTION (fn)), args);\n \t  if (candidates)\n \t    print_z_candidates (candidates);\n@@ -2312,7 +2313,7 @@ build_new_function_call (fn, args)\n \n       if (cand == 0)\n \t{\n-\t  cp_error (ec_call_of_overloaded_is_ambiguous,\n+\t  cp_error (\"call of overloaded `%D (%A)' is ambiguous\",\n \t\t    DECL_NAME (OVL_FUNCTION (fn)), args);\n \t  print_z_candidates (candidates);\n \t  return error_mark_node;\n@@ -2347,8 +2348,8 @@ build_object_call (obj, args)\n     {\n       /* It's no good looking for an overloaded operator() on a\n \t pointer-to-member-function.  */\n-      cp_error (ec_pointertomember_function_cannot_be_called, obj);\n-      cp_error (ec_without_an_object_consider_using_or);\n+      cp_error (\"pointer-to-member function %E cannot be called\", obj);\n+      cp_error (\"without an object; consider using .* or ->*\");\n       return error_mark_node;\n     }\n \n@@ -2418,7 +2419,7 @@ build_object_call (obj, args)\n \n   if (! any_viable (candidates))\n     {\n-      cp_error (ec_no_match_for_call_to, TREE_TYPE (obj), args);\n+      cp_error (\"no match for call to `(%T) (%A)'\", TREE_TYPE (obj), args);\n       print_z_candidates (candidates);\n       return error_mark_node;\n     }\n@@ -2428,7 +2429,7 @@ build_object_call (obj, args)\n \n   if (cand == 0)\n     {\n-      cp_error (ec_call_of_is_ambiguous, TREE_TYPE (obj), args);\n+      cp_error (\"call of `(%T) (%A)' is ambiguous\", TREE_TYPE (obj), args);\n       print_z_candidates (candidates);\n       return error_mark_node;\n     }\n@@ -2454,23 +2455,23 @@ op_error (code, code2, arg1, arg2, arg3, problem)\n   switch (code)\n     {\n     case COND_EXPR:\n-      cp_error (ec_for_1, problem,\n+      cp_error (\"%s for `%T ? %T : %T'\", problem,\n \t\terror_type (arg1), error_type (arg2), error_type (arg3));\n       break;\n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n-      cp_error (ec_for_2, problem, error_type (arg1), opname);\n+      cp_error (\"%s for `%T%s'\", problem, error_type (arg1), opname);\n       break;\n     case ARRAY_REF:\n-      cp_error (ec_for_3, problem,\n+      cp_error (\"%s for `%T[%T]'\", problem,\n \t\terror_type (arg1), error_type (arg2));\n       break;\n     default:\n       if (arg2)\n-\tcp_error (ec_for_4, problem,\n+\tcp_error (\"%s for `%T %s %T'\", problem,\n \t\t  error_type (arg1), opname, error_type (arg2));\n       else\n-\tcp_error (ec_for_5, problem, opname, error_type (arg1));\n+\tcp_error (\"%s for `%s%T'\", problem, opname, error_type (arg1));\n     }\n }\n \n@@ -2495,7 +2496,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n      undeclared_template<1, 5, 72>a;  */\n   if (code == LT_EXPR && TREE_CODE (arg1) == TEMPLATE_DECL)\n     {\n-      cp_error (ec_must_be_declared_before_use, arg1);\n+      cp_error (\"`%D' must be declared before use\", arg1);\n       return error_mark_node;\n     }\n \n@@ -2712,7 +2713,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t  /* Look for an `operator++ (int)'.  If they didn't have\n \t     one, then we fall back to the old way of doing things.  */\n \t  if (flags & LOOKUP_COMPLAIN)\n-\t    cp_pedwarn (ec_no_int_declared_for_postfix_s_trying_prefix_operator_instead,\n+\t    cp_pedwarn (\"no `%D (int)' declared for postfix `%s', trying prefix operator instead\",\n \t\t\tfnname, opname_tab [code]);\n \t  if (code == POSTINCREMENT_EXPR)\n \t    code = PREINCREMENT_EXPR;\n@@ -2758,9 +2759,9 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t  && candidates->next\n \t  && ! candidates->next->next)\n \t{\n-\t  cp_warning (ec_using_synthesized_for_copy_assignment,\n+\t  cp_warning (\"using synthesized `%#D' for copy assignment\",\n \t\t      cand->fn);\n-\t  cp_warning_at (ec_where_cfront_would_use,\n+\t  cp_warning_at (\"  where cfront would use `%#D'\",\n \t\t\t cand == candidates\n \t\t\t ? candidates->next->fn\n \t\t\t : candidates->fn);\n@@ -2795,7 +2796,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t  && (TYPE_MAIN_VARIANT (TREE_TYPE (arg1))\n \t      != TYPE_MAIN_VARIANT (TREE_TYPE (arg2))))\n \t{\n-\t  cp_warning (ec_comparison_between_and, \n+\t  cp_warning (\"comparison between `%#T' and `%#T'\", \n \t\t      TREE_TYPE (arg1), TREE_TYPE (arg2));\n \t}\n       break;\n@@ -3022,7 +3023,7 @@ build_op_delete_call (code, addr, size, flags, placement)\n   if (flags & LOOKUP_SPECULATIVELY)\n     return NULL_TREE;\n \n-  cp_error (ec_no_suitable_operator_delete_for, type);\n+  cp_error (\"no suitable operator delete for `%T'\", type);\n   return error_mark_node;\n }\n \n@@ -3037,17 +3038,17 @@ enforce_access (basetype_path, decl)\n \n   if (access == access_private_node)\n     {\n-      cp_error_at (ec_access_is_1, decl, \n+      cp_error_at (\"`%+#D' is %s\", decl, \n \t\t   TREE_PRIVATE (decl) ? \"private\"\n \t\t   : \"from private base class\");\n-      cp_error (ec_within_this_context);\n+      error (\"within this context\");\n     }\n   else if (access == access_protected_node)\n     {\n-      cp_error_at (ec_access_is_2, decl,\n+      cp_error_at (\"`%+#D' %s\", decl,\n \t\t   TREE_PROTECTED (decl) ? \"is protected\"\n \t\t   : \"has protected accessibility\");\n-      cp_error (ec_within_this_context);\n+      error (\"within this context\");\n     }\n }\n \n@@ -3150,11 +3151,11 @@ convert_like (convs, expr)\n \t\tif (comptypes (TREE_TYPE (expr), TREE_TYPE (convs), 1))\n \t\t  incomplete_type_error (expr, TREE_TYPE (expr));\n \t\telse\n-\t\t  cp_error (ec_could_not_convert_with_incomplete_type_to,\n+\t\t  cp_error (\"could not convert `%E' (with incomplete type `%T') to `%T'\",\n \t\t\t    expr, TREE_TYPE (expr), TREE_TYPE (convs));\n \t      }\n \t    else\n-\t      cp_error (ec_could_not_convert_to,\n+\t      cp_error (\"could not convert `%E' to `%T'\",\n \t\t\texpr, TREE_TYPE (convs));\n \t    return error_mark_node;\n \t  }\n@@ -3195,7 +3196,7 @@ convert_arg_to_ellipsis (arg)\n     arg = cp_convert (double_type_node, arg);\n   else if (IS_AGGR_TYPE (TREE_TYPE (arg))\n \t   && ! TYPE_HAS_TRIVIAL_INIT_REF (TREE_TYPE (arg)))\n-    cp_warning (ec_cannot_pass_objects_of_type_through,\n+    cp_warning (\"cannot pass objects of type `%T' through `...'\",\n \t\tTREE_TYPE (arg));\n   else\n     /* Convert `short' and `char' to full-size `int'.  */\n@@ -3295,7 +3296,7 @@ build_over_call (cand, args, flags)\n \t  char *p = (dv && dc ? \"const and volatile\"\n \t\t              : dc ? \"const\" : dv ? \"volatile\" : \"\");\n \n-\t  cp_pedwarn (ec_passing_as_this_argument_of_discards_s,\n+\t  cp_pedwarn (\"passing `%T' as `this' argument of `%#D' discards %s\",\n \t\t      TREE_TYPE (argtype), fn, p);\n \t}\n       /* [class.mfct.nonstatic]: If a nonstatic member function of a class\n@@ -3347,7 +3348,7 @@ build_over_call (cand, args, flags)\n \t  /* Issue warnings about peculiar, but legal, uses of NULL.  */\n \t  if (ARITHMETIC_TYPE_P (TREE_VALUE (parm))\n \t      && TREE_VALUE (arg) == null_node)\n-\t    cp_warning (ec_converting_null_to_nonpointer_type);\n+\t    cp_warning (\"converting NULL to non-pointer type\");\n \t    \n \t  val = convert_like (conv, TREE_VALUE (arg));\n \t}\n@@ -3597,7 +3598,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \t\t    || IS_SIGNATURE_REFERENCE (basetype))))\n \t{\n \t  if ((flags & LOOKUP_COMPLAIN) && basetype != error_mark_node)\n-\t    cp_error (ec_request_for_member_in_which_is_of_nonaggregate_type,\n+\t    cp_error (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n \t\t      name, instance, basetype);\n \n \t  return error_mark_node;\n@@ -3688,7 +3689,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n       /* XXX will LOOKUP_SPECULATIVELY be needed when this is done?  */\n       if (flags & LOOKUP_SPECULATIVELY)\n \treturn NULL_TREE;\n-      cp_error (ec_no_matching_function_for_call_to_member, basetype,\n+      cp_error (\"no matching function for call to `%T::%D (%A)%V'\", basetype,\n \t\tpretty_name, user_args, TREE_TYPE (TREE_TYPE (instance_ptr)));\n       print_z_candidates (candidates);\n       return error_mark_node;\n@@ -3698,7 +3699,7 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \n   if (cand == 0)\n     {\n-      cp_error (ec_call_of_overloaded_is_ambiguous_2, pretty_name,\n+      cp_error (\"call of overloaded `%D(%A)' is ambiguous\", pretty_name,\n \t\tuser_args);\n       print_z_candidates (candidates);\n       return error_mark_node;\n@@ -3709,11 +3710,11 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n       && DECL_CONSTRUCTOR_P (current_function_decl)\n       && ! (flags & LOOKUP_NONVIRTUAL)\n       && value_member (cand->fn, get_abstract_virtuals (basetype)))\n-    cp_error (ec_abstract_virtual_called_from_constructor, cand->fn);\n+    cp_error (\"abstract virtual `%#D' called from constructor\", cand->fn);\n   if (TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n       && TREE_CODE (instance_ptr) == NOP_EXPR\n       && TREE_OPERAND (instance_ptr, 0) == error_mark_node)\n-    cp_error (ec_cannot_call_member_function_without_object, cand->fn);\n+    cp_error (\"cannot call member function `%D' without object\", cand->fn);\n \n   if (DECL_VINDEX (cand->fn) && ! (flags & LOOKUP_NONVIRTUAL)\n       && ((instance == current_class_ref && (dtor_label || ctor_label))\n@@ -4326,9 +4327,9 @@ joust (cand1, cand2, warn)\n \n \t      if (warn)\n \t\t{\n-\t\t  cp_warning (ec_passing_chooses_over,\n+\t\t  cp_warning (\"passing `%T' chooses `%T' over `%T'\",\n \t\t\t      type, type1, type2);\n-\t\t  cp_warning (ec_in_call_to, w->fn);\n+\t\t  cp_warning (\"  in call to `%D'\", w->fn);\n \t\t}\n \t      else\n \t\tadd_warning (w, l);\n@@ -4367,10 +4368,10 @@ joust (cand1, cand2, warn)\n \t      tree source = source_type (TREE_VEC_ELT (w->convs, 0));\n \t      if (! DECL_CONSTRUCTOR_P (w->fn))\n \t\tsource = TREE_TYPE (source);\n-\t      cp_warning (ec_choosing_over, w->fn, l->fn);\n-\t      cp_warning (ec_for_conversion_from_to,\n+\t      cp_warning (\"choosing `%D' over `%D'\", w->fn, l->fn);\n+\t      cp_warning (\"  for conversion from `%T' to `%T'\",\n \t\t\t  source, TREE_TYPE (w->second_conv));\n-\t      cp_warning (ec_because_conversion_sequence_for_the_argument_is_better);\n+\t      cp_warning (\"  because conversion sequence for the argument is better\");\n \t    }\n \t  else\n \t    add_warning (w, l);"}, {"sha": "173c69a283091ead42ba0d8d61d73cb895878ce2", "filename": "gcc/cp/class.c", "status": "modified", "additions": 94, "deletions": 91, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -285,7 +285,7 @@ build_vbase_path (code, type, expr, path, nonnull)\n \t    }\n \t  else\n \t    {\n-\t      cp_error (ec_cannot_cast_up_from_virtual_baseclass,\n+\t      cp_error (\"cannot cast up from virtual baseclass `%T'\",\n \t\t\t  last_virtual);\n \t      return error_mark_node;\n \t    }\n@@ -859,7 +859,7 @@ prepare_fresh_vtable (binfo, for_type)\n \t ensure that the binfo is from for_type's binfos, not from any\n \t base type's.  We can remove all this code after a while.  */\n       if (binfo1 != binfo)\n-\tcp_warning (ec_internal_inconsistency_binfo_offset_error_for_rtti);\n+\twarning (\"internal inconsistency: binfo offset error for rtti\");\n \n       offset = BINFO_OFFSET (binfo1);\n     }\n@@ -925,7 +925,7 @@ modify_vtable_entry (old_entry_in_list, new_entry, fndecl)\n   tree base_fndecl = TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (old_entry_in_list)), 0);\n \n #ifdef NOTQUITE\n-  cp_warning (ec_replaced_with, DECL_ASSEMBLER_NAME (base_fndecl),\n+  cp_warning (\"replaced %D with %D\", DECL_ASSEMBLER_NAME (base_fndecl),\n \t      DECL_ASSEMBLER_NAME (fndecl));\n #endif\n   TREE_VALUE (old_entry_in_list) = new_entry;\n@@ -980,10 +980,10 @@ add_virtual_function (pv, phv, has_virtual, fndecl, t)\n \n #ifndef DUMB_USER\n   if (current_class_type == 0)\n-    cp_warning (ec_internal_problem_current_class_type_is_zero_when_adding_please_report,\n+    cp_warning (\"internal problem, current_class_type is zero when adding `%D', please report\",\n \t\tfndecl);\n   if (current_class_type && t != current_class_type)\n-    cp_warning (ec_internal_problem_current_class_type_differs_when_adding_please_report,\n+    cp_warning (\"internal problem, current_class_type differs when adding `%D', please report\",\n \t\tfndecl);\n #endif\n \n@@ -1218,17 +1218,17 @@ delete_duplicate_fields_1 (field, fields)\n \t\t{\n \t\t  if (TREE_CODE (field) == CONST_DECL\n \t\t      && TREE_CODE (x) == CONST_DECL)\n-\t\t    cp_error_at (ec_duplicate_enum_value, x);\n+\t\t    cp_error_at (\"duplicate enum value `%D'\", x);\n \t\t  else if (TREE_CODE (field) == CONST_DECL\n \t\t\t   || TREE_CODE (x) == CONST_DECL)\n-\t\t    cp_error_at (ec_duplicate_field_as_enum_and_nonenum,\n+\t\t    cp_error_at (\"duplicate field `%D' (as enum and non-enum)\",\n \t\t\t\tx);\n \t\t  else if (DECL_DECLARES_TYPE_P (field)\n \t\t\t   && DECL_DECLARES_TYPE_P (x))\n \t\t    {\n \t\t      if (comptypes (TREE_TYPE (field), TREE_TYPE (x), 1))\n \t\t\tcontinue;\n-\t\t      cp_error_at (ec_duplicate_nested_type, x);\n+\t\t      cp_error_at (\"duplicate nested type `%D'\", x);\n \t\t    }\n \t\t  else if (DECL_DECLARES_TYPE_P (field)\n \t\t\t   || DECL_DECLARES_TYPE_P (x))\n@@ -1239,11 +1239,11 @@ delete_duplicate_fields_1 (field, fields)\n \t\t\t  || (TREE_CODE (x) == TYPE_DECL\n \t\t\t      && DECL_ARTIFICIAL (x)))\n \t\t\tcontinue;\n-\t\t      cp_error_at (ec_duplicate_field_as_type_and_nontype,\n+\t\t      cp_error_at (\"duplicate field `%D' (as type and non-type)\",\n \t\t\t\t   x);\n \t\t    }\n \t\t  else\n-\t\t    cp_error_at (ec_duplicate_member, x);\n+\t\t    cp_error_at (\"duplicate member `%D'\", x);\n \t\t  if (prev == 0)\n \t\t    fields = TREE_CHAIN (fields);\n \t\t  else\n@@ -1281,9 +1281,9 @@ alter_access (t, binfo, fdecl, access)\n       if (TREE_VALUE (elem) != access)\n \t{\n \t  if (TREE_CODE (TREE_TYPE (fdecl)) == FUNCTION_DECL)\n-\t    cp_error_at (ec_conflicting_access_specifications_for_method_ignored, TREE_TYPE (fdecl));\n+\t    cp_error_at (\"conflicting access specifications for method `%D', ignored\", TREE_TYPE (fdecl));\n \t  else\n-\t    cp_error (ec_conflicting_access_specifications_for_field_s_ignored,\n+\t    error (\"conflicting access specifications for field `%s', ignored\",\n \t\t   IDENTIFIER_POINTER (DECL_NAME (fdecl)));\n \t}\n       else\n@@ -1332,13 +1332,13 @@ handle_using_decl (using_decl, t, method_vec, fields)\n   \n   if (name == constructor_name (ctype)\n       || name == constructor_name_full (ctype))\n-    cp_error_at (ec_usingdeclaration_for_constructor, using_decl);\n+    cp_error_at (\"using-declaration for constructor\", using_decl);\n   \n   fdecl = lookup_member (binfo, name, 0, 0);\n   \n   if (!fdecl)\n     {\n-      cp_error_at (ec_no_members_matching_in, using_decl, ctype);\n+      cp_error_at (\"no members matching `%D' in `%#T'\", using_decl, ctype);\n       return;\n     }\n \n@@ -1362,8 +1362,8 @@ handle_using_decl (using_decl, t, method_vec, fields)\n     if (DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, i)))\n \t== name)\n       {\n-\tcp_error (ec_cannot_adjust_access_to_in, fdecl, t);\n-\tcp_error_at (ec_because_of_local_method_with_same_name,\n+\tcp_error (\"cannot adjust access to `%#D' in `%#T'\", fdecl, t);\n+\tcp_error_at (\"  because of local method `%#D' with same name\",\n \t\t     OVL_CURRENT (TREE_VEC_ELT (method_vec, i)));\n \treturn;\n       }\n@@ -1375,8 +1375,8 @@ handle_using_decl (using_decl, t, method_vec, fields)\n   for (tmp = fields; tmp; tmp = TREE_CHAIN (tmp))\n     if (DECL_NAME (tmp) == name)\n       {\n-\tcp_error (ec_cannot_adjust_access_to_in, fdecl, t);\n-\tcp_error_at (ec_because_of_local_field_with_same_name, tmp);\n+\tcp_error (\"cannot adjust access to `%#D' in `%#T'\", fdecl, t);\n+\tcp_error_at (\"  because of local field `%#D' with same name\", tmp);\n \treturn;\n       }\n   \n@@ -1606,7 +1606,7 @@ finish_base_struct (t, b)\n \t dtor is handled in finish_struct_1.  */\n       if (warn_ecpp && ! TYPE_VIRTUAL_P (basetype)\n \t  && TYPE_HAS_DESTRUCTOR (basetype))\n-\tcp_warning (ec_base_class_has_a_nonvirtual_destructor, basetype);\n+\tcp_warning (\"base class `%#T' has a non-virtual destructor\", basetype);\n \n       /* If the type of basetype is incomplete, then\n \t we already complained about that fact\n@@ -1634,9 +1634,9 @@ finish_base_struct (t, b)\n \t  b->cant_have_default_ctor = 1;\n \t  if (! TYPE_HAS_CONSTRUCTOR (t))\n \t    {\n-\t      cp_pedwarn (ec_base_with_only_nondefault_constructor,\n+\t      cp_pedwarn (\"base `%T' with only non-default constructor\",\n \t\t\t  basetype);\n-\t      cp_pedwarn (ec_in_class_without_a_constructor);\n+\t      cp_pedwarn (\"in class without a constructor\");\n \t    }\n \t}\n \n@@ -2037,7 +2037,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \t  }\n       if (nonprivate_method == 0 \n \t  && warn_ctor_dtor_privacy)\n-\tcp_warning (ec_all_member_functions_in_class_are_private, t);\n+\tcp_warning (\"all member functions in class `%T' are private\", t);\n     }\n \n   /* Warn if all destructors are private (in which case this class is\n@@ -2053,7 +2053,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \t       && CLASSTYPE_FRIEND_CLASSES (t) == NULL_TREE\n \t       && DECL_FRIENDLIST (TYPE_MAIN_DECL (t)) == NULL_TREE\n \t       && warn_ctor_dtor_privacy)\n-\tcp_warning (ec_only_defines_a_private_destructor_and_has_no_friends,\n+\tcp_warning (\"`%#T' only defines a private destructor and has no friends\",\n \t\t    t);\n     }\n \n@@ -2091,8 +2091,8 @@ void\n duplicate_tag_error (t)\n      tree t;\n {\n-  cp_error (ec_redefinition_of, t);\n-  cp_error_at (ec_previous_definition_here, t);\n+  cp_error (\"redefinition of `%#T'\", t);\n+  cp_error_at (\"previous definition here\", t);\n \n   /* Pretend we haven't defined this type.  */\n \n@@ -2247,9 +2247,9 @@ get_class_offset_1 (parent, binfo, context, t, fndecl)\n \t      && ! tree_int_cst_equal (nrval, rval))\n \t    {\n \t      /* Only give error if the two offsets are different */\n-\t      cp_error (ec_every_virtual_function_must_have_a_unique_final_overrider);\n-\t      cp_error (ec_found_two_or_more_class_subobjects_in, context, t);\n-\t      cp_error (ec_with_virtual_from_virtual_base_class, fndecl);\n+\t      error (\"every virtual function must have a unique final overrider\");\n+\t      cp_error (\"  found two (or more) `%T' class subobjects in `%T'\", context, t);\n+\t      cp_error (\"  with virtual `%D' from virtual base class\", fndecl);\n \t      return rval;\n \t    }\n \t  rval = nrval;\n@@ -2396,7 +2396,7 @@ modify_one_vtable (binfo, t, fndecl, pfn)\n \t    }\n \n #ifdef NOTQUITE\n-\t  cp_warning (ec_in, DECL_NAME (BINFO_VTABLE (binfo)));\n+\t  cp_warning (\"in %D\", DECL_NAME (BINFO_VTABLE (binfo)));\n #endif\n \t  modify_vtable_entry (get_vtable_entry_n (BINFO_VIRTUALS (binfo), n),\n \t\t\t       build_vtable_entry (this_offset, pfn),\n@@ -2829,9 +2829,9 @@ check_for_override (decl, ctype)\n \t\t path to its virtual baseclass.  */\n \t      if (TREE_CODE (TREE_TYPE (decl)) == FUNCTION_TYPE)\n \t\t{\n-\t\t  cp_error_at (ec_method_may_not_be_declared_static,\n+\t\t  cp_error_at (\"method `%D' may not be declared static\",\n \t\t\t       decl);\n-\t\t  cp_error_at (ec_since_declared_virtual_in_base_class,\n+\t\t  cp_error_at (\"(since `%D' declared virtual in base class.)\",\n \t\t\t       tmp);\n \t\t  break;\n \t\t}\n@@ -2932,8 +2932,8 @@ warn_hidden (t)\n \t\t\t   TREE_PURPOSE (base_fndecls)))\n \t    {\n \t      /* Here we know it is a hider, and no overrider exists.  */\n-\t      cp_warning_at (ec_was_hidden, TREE_VALUE (base_fndecls));\n-\t      cp_warning_at (ec_by, TREE_PURPOSE (base_fndecls));\n+\t      cp_warning_at (\"`%D' was hidden\", TREE_VALUE (base_fndecls));\n+\t      cp_warning_at (\"  by `%D'\", TREE_PURPOSE (base_fndecls));\n \t    }\n \n \t  base_fndecls = TREE_CHAIN (base_fndecls);\n@@ -2966,10 +2966,10 @@ finish_struct_anon (t)\n \t\tcontinue;\n \n \t      if (TREE_PRIVATE (*uelt))\n-\t\tcp_pedwarn_at (ec_private_member_in_anonymous_union,\n+\t\tcp_pedwarn_at (\"private member `%#D' in anonymous union\",\n \t\t\t       *uelt);\n \t      else if (TREE_PROTECTED (*uelt))\n-\t\tcp_pedwarn_at (ec_protected_member_in_anonymous_union,\n+\t\tcp_pedwarn_at (\"protected member `%#D' in anonymous union\",\n \t\t\t       *uelt);\n \n \t      TREE_PRIVATE (*uelt) = TREE_PRIVATE (field);\n@@ -3049,12 +3049,12 @@ finish_struct_1 (t, warn_anon)\n   int has_pointers = 0;\n \n   if (warn_anon && code != UNION_TYPE && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n-    cp_pedwarn (ec_anonymous_class_type_not_used_to_declare_any_objects);\n+    pedwarn (\"anonymous class type not used to declare any objects\");\n \n   if (TYPE_SIZE (t))\n     {\n       if (IS_AGGR_TYPE (t))\n-\tcp_error (ec_redefinition_of, t);\n+\tcp_error (\"redefinition of `%#T'\", t);\n       else\n \tmy_friendly_abort (172);\n       popclass (0);\n@@ -3161,7 +3161,7 @@ finish_struct_1 (t, warn_anon)\n \n       check_for_override (x, t);\n       if (DECL_ABSTRACT_VIRTUAL_P (x) && ! DECL_VINDEX (x))\n-\tcp_error_at (ec_initializer_specified_for_nonvirtual_method, x);\n+\tcp_error_at (\"initializer specified for non-virtual method `%D'\", x);\n \n       /* The name of the field is the original field name\n \t Save this in auxiliary field for later overloading.  */\n@@ -3218,24 +3218,24 @@ finish_struct_1 (t, warn_anon)\n \n       /* ``A local class cannot have static data members.'' ARM 9.4 */\n       if (current_function_decl && TREE_STATIC (x))\n-\tcp_error_at (ec_field_in_local_class_cannot_be_static, x);\n+\tcp_error_at (\"field `%D' in local class cannot be static\", x);\n \n       /* Perform error checking that did not get done in\n \t grokdeclarator.  */\n       if (TREE_CODE (TREE_TYPE (x)) == FUNCTION_TYPE)\n \t{\n-\t  cp_error_at (ec_field_invalidly_declared_function_type,\n+\t  cp_error_at (\"field `%D' invalidly declared function type\",\n \t\t       x);\n \t  TREE_TYPE (x) = build_pointer_type (TREE_TYPE (x));\n \t}\n       else if (TREE_CODE (TREE_TYPE (x)) == METHOD_TYPE)\n \t{\n-\t  cp_error_at (ec_field_invalidly_declared_method_type, x);\n+\t  cp_error_at (\"field `%D' invalidly declared method type\", x);\n \t  TREE_TYPE (x) = build_pointer_type (TREE_TYPE (x));\n \t}\n       else if (TREE_CODE (TREE_TYPE (x)) == OFFSET_TYPE)\n \t{\n-\t  cp_error_at (ec_field_invalidly_declared_offset_type, x);\n+\t  cp_error_at (\"field `%D' invalidly declared offset type\", x);\n \t  TREE_TYPE (x) = build_pointer_type (TREE_TYPE (x));\n \t}\n \n@@ -3260,7 +3260,7 @@ finish_struct_1 (t, warn_anon)\n \t{\n \t  if (TREE_CODE (t) == UNION_TYPE)\n \t    /* Unions cannot have static members.  */\n-\t    cp_error_at (ec_field_declared_static_in_union, x);\n+\t    cp_error_at (\"field `%D' declared static in union\", x);\n \t      \n \t  continue;\n \t}\n@@ -3287,9 +3287,9 @@ finish_struct_1 (t, warn_anon)\n \t  if (! TYPE_HAS_CONSTRUCTOR (t) && extra_warnings)\n \t    {\n \t      if (DECL_NAME (x))\n-\t\tcp_warning_at (ec_nonstatic_reference_name_in_class_without_a_constructor, x);\n+\t\tcp_warning_at (\"non-static reference `%#D' in class without a constructor\", x);\n \t      else\n-\t\tcp_warning_at (ec_nonstatic_reference_in_class_without_a_constructor, x);\n+\t\tcp_warning_at (\"non-static reference in class without a constructor\", x);\n \t    }\n \t}\n \n@@ -3314,9 +3314,9 @@ finish_struct_1 (t, warn_anon)\n \t      && extra_warnings)\n \t    {\n \t      if (DECL_NAME (x))\n-\t\tcp_warning_at (ec_nonstatic_const_member_name_in_class_without_a_constructor, x);\n+\t\tcp_warning_at (\"non-static const member `%#D' in class without a constructor\", x);\n \t      else\n-\t\tcp_warning_at (ec_nonstatic_const_member_in_class_without_a_constructor, x);\n+\t\tcp_warning_at (\"non-static const member in class without a constructor\", x);\n \t    }\n \t}\n       else\n@@ -3346,7 +3346,7 @@ finish_struct_1 (t, warn_anon)\n \t  if (DECL_INITIAL (x)\n \t      && ! INTEGRAL_TYPE_P (TREE_TYPE (x)))\n \t    {\n-\t      cp_error_at (ec_bitfield_with_nonintegral_type, x);\n+\t      cp_error_at (\"bit-field `%#D' with non-integral type\", x);\n \t      DECL_INITIAL (x) = NULL;\n \t    }\n \n@@ -3367,20 +3367,20 @@ finish_struct_1 (t, warn_anon)\n \n \t      if (TREE_CODE (w) != INTEGER_CST)\n \t\t{\n-\t\t  cp_error_at (ec_bitfield_width_not_an_integer_constant,\n+\t\t  cp_error_at (\"bit-field `%D' width not an integer constant\",\n \t\t\t       x);\n \t\t  DECL_INITIAL (x) = NULL_TREE;\n \t\t}\n \t      else if (width = TREE_INT_CST_LOW (w),\n \t\t       width < 0)\n \t\t{\n \t\t  DECL_INITIAL (x) = NULL;\n-\t\t  cp_error_at (ec_negative_width_in_bitfield, x);\n+\t\t  cp_error_at (\"negative width in bit-field `%D'\", x);\n \t\t}\n \t      else if (width == 0 && DECL_NAME (x) != 0)\n \t\t{\n \t\t  DECL_INITIAL (x) = NULL;\n-\t\t  cp_error_at (ec_zero_width_for_bitfield, x);\n+\t\t  cp_error_at (\"zero width for bit-field `%D'\", x);\n \t\t}\n \t      else if (width\n \t\t       > TYPE_PRECISION (long_long_unsigned_type_node))\n@@ -3390,21 +3390,21 @@ finish_struct_1 (t, warn_anon)\n \t\t  DECL_INITIAL (x) = NULL;\n \t\t  sorry (\"bit-fields larger than %d bits\",\n \t\t\t TYPE_PRECISION (long_long_unsigned_type_node));\n-\t\t  cp_error_at (ec_in_declaration_of, x);\n+\t\t  cp_error_at (\"  in declaration of `%D'\", x);\n \t\t}\n \t      else if (width > TYPE_PRECISION (TREE_TYPE (x))\n \t\t       && TREE_CODE (TREE_TYPE (x)) != ENUMERAL_TYPE\n \t\t       && TREE_CODE (TREE_TYPE (x)) != BOOLEAN_TYPE)\n \t\t{\n-\t\t  cp_warning_at (ec_width_of_exceeds_its_type, x);\n+\t\t  cp_warning_at (\"width of `%D' exceeds its type\", x);\n \t\t}\n \t      else if (TREE_CODE (TREE_TYPE (x)) == ENUMERAL_TYPE\n \t\t       && ((min_precision (TYPE_MIN_VALUE (TREE_TYPE (x)),\n \t\t\t\t\t   TREE_UNSIGNED (TREE_TYPE (x))) > width)\n \t\t\t   || (min_precision (TYPE_MAX_VALUE (TREE_TYPE (x)),\n \t\t\t\t\t      TREE_UNSIGNED (TREE_TYPE (x))) > width)))\n \t\t{\n-\t\t  cp_warning_at (ec_is_too_small_to_hold_all_values_of,\n+\t\t  cp_warning_at (\"`%D' is too small to hold all values of `%#T'\",\n \t\t\t\t x, TREE_TYPE (x));\n \t\t}\n \n@@ -3460,7 +3460,7 @@ finish_struct_1 (t, warn_anon)\n \t\t  else if (TYPE_HAS_REAL_ASSIGNMENT (type))\n \t\t    fie = \"assignment operator\";\n \t\t  if (fie)\n-\t\t    cp_error_at (ec_member_with_s_not_allowed_in_union, x,\n+\t\t    cp_error_at (\"member `%#D' with %s not allowed in union\", x,\n \t\t\t\t fie);\n \t\t}\n \t      else\n@@ -3486,10 +3486,10 @@ finish_struct_1 (t, warn_anon)\n \t\t  if (! TYPE_HAS_CONSTRUCTOR (t))\n \t\t    {\n \t\t      if (DECL_NAME (x))\n-\t\t\tcp_pedwarn_at (ec_member_decl_with_only_nondefault_constructor, x);\n+\t\t\tcp_pedwarn_at (\"member `%#D' with only non-default constructor\", x);\n \t\t      else\n-\t\t\tcp_pedwarn_at (ec_member_with_only_nondefault_constructor, x);\n-\t\t      cp_pedwarn_at (ec_in_class_without_a_constructor,\n+\t\t\tcp_pedwarn_at (\"member with only non-default constructor\", x);\n+\t\t      cp_pedwarn_at (\"in class without a constructor\",\n \t\t\t\t     x);\n \t\t    }\n #endif\n@@ -3500,7 +3500,7 @@ finish_struct_1 (t, warn_anon)\n \t      /* `build_class_init_list' does not recognize\n \t\t non-FIELD_DECLs.  */\n \t      if (code == UNION_TYPE && any_default_members != 0)\n-\t\tcp_error_at (ec_multiple_fields_in_union_initialized);\n+\t\tcp_error_at (\"multiple fields in union `%T' initialized\");\n \t      any_default_members = 1;\n \t    }\n \t}\n@@ -3548,16 +3548,16 @@ finish_struct_1 (t, warn_anon)\n   if (has_pointers && warn_ecpp && TYPE_HAS_CONSTRUCTOR (t)\n       && ! (TYPE_HAS_INIT_REF (t) && TYPE_HAS_ASSIGN_REF (t)))\n     {\n-      cp_warning (ec_has_pointer_data_members, t);\n+      cp_warning (\"`%#T' has pointer data members\", t);\n       \n       if (! TYPE_HAS_INIT_REF (t))\n \t{\n-\t  cp_warning (ec_but_does_not_override_const, t, t);\n+\t  cp_warning (\"  but does not override `%T(const %T&)'\", t, t);\n \t  if (! TYPE_HAS_ASSIGN_REF (t))\n-\t    cp_warning (ec_or_operatorconst, t);\n+\t    cp_warning (\"  or `operator=(const %T&)'\", t);\n \t}\n       else if (! TYPE_HAS_ASSIGN_REF (t))\n-\tcp_warning (ec_but_does_not_override_operatorconst, t);\n+\tcp_warning (\"  but does not override `operator=(const %T&)'\", t);\n     }\n \n   TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_HAS_DESTRUCTOR (t);\n@@ -3630,7 +3630,7 @@ finish_struct_1 (t, warn_anon)\n \t      }\n \n \t  if (nonprivate_ctor == 0 && warn_ctor_dtor_privacy)\n-\t    cp_warning (ec_only_defines_private_constructors_and_has_no_friends,\n+\t    cp_warning (\"`%#T' only defines private constructors and has no friends\",\n \t\t\tt);\n \t}\n     }\n@@ -3727,8 +3727,8 @@ finish_struct_1 (t, warn_anon)\n \t    if (DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, i)))\n \t\t== name)\n \t      {\n-\t\tcp_error_at (ec_data_member_conflicts_with, x);\n-\t\tcp_error_at (ec_function_member,\n+\t\tcp_error_at (\"data member `%#D' conflicts with\", x);\n+\t\tcp_error_at (\"function member `%#D'\",\n \t\t\t     OVL_CURRENT (TREE_VEC_ELT (method_vec, i)));\n \t\tbreak;\n \t      }\n@@ -3845,7 +3845,7 @@ finish_struct_1 (t, warn_anon)\n     }\n     \n #ifdef NOTQUITE\n-  cp_warning (ec_oing_hard_virtuals_for, t);\n+  cp_warning (\"Doing hard virtuals for %T...\", t);\n #endif\n \n   if (has_virtual > max_has_virtual)\n@@ -4075,7 +4075,7 @@ finish_struct_1 (t, warn_anon)\n \n       if (warn_nonvdtor && TYPE_HAS_DESTRUCTOR (t)\n \t  && DECL_VINDEX (TREE_VEC_ELT (method_vec, 1)) == NULL_TREE)\n-\tcp_warning (ec_has_virtual_functions_but_nonvirtual_destructor,\n+\tcp_warning (\"`%#T' has virtual functions but non-virtual destructor\",\n \t\t    t);\n     }\n \n@@ -4242,9 +4242,9 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t\t  && !(TREE_CODE (icv) == TYPE_DECL\n \t\t       && DECL_CONTEXT (icv) == t))\n \t\t{\n-\t\t  cp_pedwarn_at (ec_declaration_of_identifier_as,\n+\t\t  cp_pedwarn_at (\"declaration of identifier `%D' as `%+#D'\",\n \t\t\t\t name, x);\n-\t\t  cp_pedwarn_at (ec_conflicts_with_other_use_in_class_as,\n+\t\t  cp_pedwarn_at (\"conflicts with other use in class as `%#D'\",\n \t\t\t\t icv);\n \t\t}\n \t    }\n@@ -4347,7 +4347,7 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n   if (current_class_type)\n     popclass (0);\n   else\n-    cp_error (ec_trying_to_finish_struct_but_kicked_out_due_to_previous_parse_errors);\n+    error (\"trying to finish struct, but kicked out due to previous parse errors.\");\n \n   return t;\n }\n@@ -4787,7 +4787,7 @@ push_lang_context (name)\n       current_lang_name = name;\n     }\n   else\n-    cp_error (ec_language_string_not_recognized, IDENTIFIER_POINTER (name));\n+    error (\"language string `\\\"%s\\\"' not recognized\", IDENTIFIER_POINTER (name));\n }\n   \n /* Get out of the current language scope.  */\n@@ -4821,7 +4821,7 @@ validate_lhs (lhstype, complain)\n       else\n \t{\n \t  if (complain)\n-\t    cp_error (ec_invalid_type_combination_for_overload);\n+\t    error (\"invalid type combination for overload\");\n \t  return error_mark_node;\n \t}\n     }\n@@ -4849,7 +4849,7 @@ instantiate_type (lhstype, rhs, complain)\n   if (TREE_CODE (lhstype) == UNKNOWN_TYPE)\n     {\n       if (complain)\n-\tcp_error (ec_not_enough_type_information);\n+\terror (\"not enough type information\");\n       return error_mark_node;\n     }\n \n@@ -4858,7 +4858,7 @@ instantiate_type (lhstype, rhs, complain)\n       if (comptypes (lhstype, TREE_TYPE (rhs), 1))\n \treturn rhs;\n       if (complain)\n-\tcp_error (ec_argument_of_type_does_not_match,\n+\tcp_error (\"argument of type `%T' does not match `%T'\",\n \t\t  TREE_TYPE (rhs), lhstype);\n       return error_mark_node;\n     }\n@@ -4960,14 +4960,14 @@ instantiate_type (lhstype, rhs, complain)\n \t    if (field)\n \t      {\n \t\tif (complain)\n-\t\t  cp_error (ec_ambiguous_overload_for_requested);\n+\t\t  error (\"ambiguous overload for COMPONENT_REF requested\");\n \t\treturn error_mark_node;\n \t      }\n \t  }\n \telse\n \t  {\n \t    if (complain)\n-\t      cp_error (ec_no_appropriate_overload_exists_for);\n+\t      error (\"no appropriate overload exists for COMPONENT_REF\");\n \t    return error_mark_node;\n \t  }\n #endif\n@@ -5004,8 +5004,9 @@ instantiate_type (lhstype, rhs, complain)\n \t    && TREE_CODE (lhstype) != METHOD_TYPE)\n \t  {\n \t    if (complain)\n-\t      cp_error (ec_cannot_resolve_overloaded_function,\n-\t\t\tDECL_NAME (OVL_FUNCTION (rhs)));\n+\t      cp_error(\"cannot resolve overloaded function `%D' \" \n+\t\t       \"based on non-function type\", \n+\t\t       DECL_NAME (OVL_FUNCTION (rhs)));\n \t    return error_mark_node;\n \t  }\n \t\n@@ -5047,7 +5048,7 @@ instantiate_type (lhstype, rhs, complain)\n \t\t  {\n \t\t    if (save_elem)\n \t\t      {\n-\t\t\tcp_error (ec_ambiguous_template_instantiation_converting_to, lhstype);\n+\t\t\tcp_error (\"ambiguous template instantiation converting to `%#T'\", lhstype);\n \t\t\treturn error_mark_node;\n \t\t      }\n \t\t    save_elem = instantiate_template (elem, t);\n@@ -5091,10 +5092,11 @@ instantiate_type (lhstype, rhs, complain)\n \t\t  {\n \t\t    if (complain)\n \t\t      {\n-\t\t\tcp_error (ec_cannot_resolve_overload_to_target_type,\n+\t\t\tcp_error \n+\t\t\t  (\"cannot resolve overload to target type `%#T'\",\n \t\t\t   lhstype);\n-\t\t\tcp_error_at (ec_ambiguity_between, save_elem); \n-\t\t\tcp_error_at (ec_and_at_least, elem);\n+\t\t\tcp_error_at (\"  ambiguity between `%#D'\", save_elem); \n+\t\t\tcp_error_at (\"  and `%#D', at least\", elem);\n \t\t      }\n \t\t    return error_mark_node;\n \t\t  }\n@@ -5106,8 +5108,9 @@ instantiate_type (lhstype, rhs, complain)\n \t/* We failed to find a match.  */\n \tif (complain)\n \t  {\n-\t    cp_error (ec_cannot_resolve_overload_to_target_type, lhstype);\n-\t    cp_error (ec_because_no_suitable_overload_of_function_exists,\n+\t    cp_error (\"cannot resolve overload to target type `%#T'\", lhstype);\n+\t    cp_error \n+\t      (\"  because no suitable overload of function `%D' exists\",\n \t       DECL_NAME (OVL_FUNCTION (rhs)));\n \t  }\n \treturn error_mark_node;\n@@ -5176,7 +5179,7 @@ instantiate_type (lhstype, rhs, complain)\n \t\tif (elem)\n \t\t  {\n \t\t    if (complain)\n-\t\t      cp_error (ec_ambiguous_overload_for_overloaded_method_requested);\n+\t\t      error (\"ambiguous overload for overloaded method requested\");\n \t\t    return error_mark_node;\n \t\t  }\n \t\tmark_used (save_elem);\n@@ -5201,7 +5204,7 @@ instantiate_type (lhstype, rhs, complain)\n #endif\n \t  }\n \tif (complain)\n-\t  cp_error (ec_no_compatible_member_functions_named, name);\n+\t  cp_error (\"no compatible member functions named `%D'\", name);\n \treturn error_mark_node;\n       }\n \n@@ -5259,7 +5262,7 @@ instantiate_type (lhstype, rhs, complain)\n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n       if (complain)\n-\tcp_error (ec_invalid_operation_on_uninstantiated_type);\n+\terror (\"invalid operation on uninstantiated type\");\n       return error_mark_node;\n \n     case TRUTH_AND_EXPR:\n@@ -5275,14 +5278,14 @@ instantiate_type (lhstype, rhs, complain)\n     case TRUTH_ORIF_EXPR:\n     case TRUTH_NOT_EXPR:\n       if (complain)\n-\tcp_error (ec_not_enough_type_information);\n+\terror (\"not enough type information\");\n       return error_mark_node;\n \n     case COND_EXPR:\n       if (type_unknown_p (TREE_OPERAND (rhs, 0)))\n \t{\n \t  if (complain)\n-\t    cp_error (ec_not_enough_type_information);\n+\t    error (\"not enough type information\");\n \t  return error_mark_node;\n \t}\n       TREE_OPERAND (rhs, 1)\n@@ -5312,7 +5315,7 @@ instantiate_type (lhstype, rhs, complain)\n       else if (TREE_CODE (lhstype) != POINTER_TYPE)\n \t{\n \t  if (complain)\n-\t    cp_error (ec_type_for_resolving_address_of_overloaded_function_must_be_pointer_type);\n+\t    error (\"type for resolving address of overloaded function must be pointer type\");\n \t  return error_mark_node;\n \t}\n       {"}, {"sha": "3c3a8588139a35f60b8931bb6288f566e5d6bf83", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -493,16 +493,6 @@ enum cplus_tree_code {\n };\n #undef DEFTREECODE\n \n-/* Error codes.  */\n-typedef enum error_code {\n-#undef DEFERROR\n-#undef DEFERRORNUM\n-#define DEFERROR(code, string) code,\n-#define DEFERRORNUM(code, string, num) DEFERROR(code, string)\n-#include \"cp-error.def\"\n-  ec_last_error_code\n-} error_code;\n-\n enum languages { lang_c, lang_cplusplus, lang_java };\n \n /* Macros to make error reporting functions' lives easier.  */\n@@ -2250,9 +2240,6 @@ extern int flag_new_abi;\n \n extern int flag_honor_std;\n \n-/* Nonzero means show diagnostic codes when printing error messages.  */\n-extern int flag_diag_codes;\n-\n /* Nonzero if we're done parsing and into end-of-file activities.  */\n \n extern int at_eof;\n@@ -2640,15 +2627,14 @@ extern tree handle_class_head\t\t\tPROTO((tree, tree, tree));\n extern tree lookup_arg_dependent                PROTO((tree, tree, tree));\n \n /* in errfn.c */\n-extern void cp_error\t\t\t\tPVPROTO((error_code, ...));\n-extern void cp_error_at\t\t\t\tPVPROTO((error_code, ...));\n-extern void cp_warning\t\t\t\tPVPROTO((error_code, ...));\n-extern void cp_warning_at\t\t\tPVPROTO((error_code, ...));\n-extern void cp_pedwarn\t\t\t\tPVPROTO((error_code, ...));\n-extern void cp_pedwarn_at\t\t\tPVPROTO((error_code, ...));\n-extern void cp_compiler_error\t\t\tPVPROTO((error_code, ...));\n-extern void cp_sprintf\t\t\t\tPVPROTO((error_code, ...));\n-extern void cp_enable_warning                   PROTO((int, int));\n+extern void cp_error\t\t\t\t();\n+extern void cp_error_at\t\t\t\t();\n+extern void cp_warning\t\t\t\t();\n+extern void cp_warning_at\t\t\t();\n+extern void cp_pedwarn\t\t\t\t();\n+extern void cp_pedwarn_at\t\t\t();\n+extern void cp_compiler_error\t\t\t();\n+extern void cp_sprintf\t\t\t\t();\n \n /* in error.c */\n extern void init_error\t\t\t\tPROTO((void));"}, {"sha": "edb2d5b22ad764a68a1dbe2626bd092494f0c308", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -80,7 +80,7 @@ cp_convert_to_pointer (type, expr)\n       intype = complete_type (intype);\n       if (TYPE_SIZE (intype) == NULL_TREE)\n \t{\n-\t  cp_error (ec_cant_convert_from_incomplete_type_to,\n+\t  cp_error (\"can't convert from incomplete type `%T' to `%T'\",\n \t\t    intype, type);\n \t  return error_mark_node;\n \t}\n@@ -89,7 +89,7 @@ cp_convert_to_pointer (type, expr)\n       if (rval)\n \t{\n \t  if (rval == error_mark_node)\n-\t    cp_error (ec_conversion_of_from_to_is_ambiguous,\n+\t    cp_error (\"conversion of `%E' from `%T' to `%T' is ambiguous\",\n \t\t      expr, intype, type);\n \t  return rval;\n \t}\n@@ -134,7 +134,7 @@ cp_convert_to_pointer (type, expr)\n \t{\n \t  if (TREE_CODE (TREE_TYPE (TREE_TYPE (expr))) == METHOD_TYPE)\n \t    if (pedantic || warn_pmf2ptr)\n-\t      cp_pedwarn (ec_converting_from_to, TREE_TYPE (expr),\n+\t      cp_pedwarn (\"converting from `%T' to `%T'\", TREE_TYPE (expr),\n \t\t\t  type);\n \t  return build1 (NOP_EXPR, type, expr);\n \t}\n@@ -223,7 +223,7 @@ cp_convert_to_pointer (type, expr)\n \t  || (TREE_CODE (type) == POINTER_TYPE\n \t      && TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE))\n \t{\n-\t  cp_error (ec_cannot_convert_from_type_to_type,\n+\t  cp_error (\"cannot convert `%E' from type `%T' to type `%T'\",\n \t\t    expr, intype, type);\n \t  return error_mark_node;\n \t}\n@@ -262,7 +262,7 @@ cp_convert_to_pointer (type, expr)\n       return convert_to_pointer (type, expr);\n     }\n \n-  cp_error (ec_cannot_convert_from_type_to_type,\n+  cp_error (\"cannot convert `%E' from type `%T' to type `%T'\",\n \t    expr, intype, type);\n   return error_mark_node;\n }\n@@ -311,7 +311,7 @@ convert_to_pointer_force (type, expr)\n \t  if (distance == -2)\n \t    {\n \t    ambig:\n-\t      cp_error (ec_type_is_ambiguous_baseclass_of_s,\n+\t      cp_error (\"type `%T' is ambiguous baseclass of `%s'\",\n \t\t\tTREE_TYPE (type),\n \t\t\tTYPE_NAME_STRING (TREE_TYPE (intype)));\n \t      return error_mark_node;\n@@ -454,19 +454,19 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t    {\n \t      if (decl)\n \t\t/* Ensure semantics of [dcl.init.ref] */\n-\t\tcp_pedwarn (ec_initialization_of_nonconst_reference_from_rvalue,\n+\t\tcp_pedwarn (\"initialization of non-const reference `%#T' from rvalue `%T'\",\n \t\t\t    reftype, intype);\n \t      else\n-\t\tcp_pedwarn (ec_conversion_to_nonconst_from_rvalue,\n+\t\tcp_pedwarn (\"conversion to non-const `%T' from rvalue `%T'\",\n \t\t\t    reftype, intype);\n \t    }\n \t  else if (! (convtype & CONV_CONST))\n \t    {\n \t      if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n-\t\tcp_pedwarn (ec_conversion_from_to_discards_const,\n+\t\tcp_pedwarn (\"conversion from `%T' to `%T' discards const\",\n \t\t\t    ttr, reftype);\n \t      else if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n-\t\tcp_pedwarn (ec_conversion_from_to_discards_volatile,\n+\t\tcp_pedwarn (\"conversion from `%T' to `%T' discards volatile\",\n \t\t\t    ttr, reftype);\n \t    }\n \t}\n@@ -485,7 +485,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n          meant.  */\n       if (TREE_CODE (intype) == POINTER_TYPE\n \t  && (comptypes (TREE_TYPE (intype), type, -1)))\n-\tcp_warning (ec_casting_to_does_not_dereference_pointer,\n+\tcp_warning (\"casting `%T' to `%T' does not dereference pointer\",\n \t\t    intype, reftype);\n \t  \n       rval = build_unary_op (ADDR_EXPR, expr, 0);\n@@ -504,7 +504,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n       rval = build_up_reference (reftype, rval, flags, 1);\n \n       if (rval && ! TYPE_READONLY (TREE_TYPE (reftype)))\n-\tcp_pedwarn (ec_initializing_nonconst_with_will_use_a_temporary,\n+\tcp_pedwarn (\"initializing non-const `%T' with `%T' will use a temporary\",\n \t\t    reftype, intype);\n     }\n \n@@ -517,7 +517,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n   my_friendly_assert (TREE_CODE (intype) != OFFSET_TYPE, 189);\n \n   if (flags & LOOKUP_COMPLAIN)\n-    cp_error (ec_cannot_convert_type_to_type, intype, reftype);\n+    cp_error (\"cannot convert type `%T' to type `%T'\", intype, reftype);\n \n   if (flags & LOOKUP_SPECULATIVELY)\n     return NULL_TREE;\n@@ -592,11 +592,11 @@ convert_pointer_to_real (binfo, expr)\n \t but if it is, give them an error message that they can read.  */\n       if (distance < 0)\n \t{\n-\t  cp_error (ec_cannot_convert_a_pointer_of_type_to_a_pointer_of_type,\n+\t  cp_error (\"cannot convert a pointer of type `%T' to a pointer of type `%T'\",\n \t\t    intype, type);\n \n \t  if (distance == -2)\n-\t    cp_error (ec_because_is_an_ambiguous_base_class, type);\n+\t    cp_error (\"because `%T' is an ambiguous base class\", type);\n \t  return error_mark_node;\n \t}\n \n@@ -704,7 +704,7 @@ ocp_convert (type, expr, convtype, flags)\n \t  && ((ARITHMETIC_TYPE_P (intype) && ! (convtype & CONV_STATIC))\n \t      || (TREE_CODE (intype) == POINTER_TYPE)))\n \t{\n-\t  cp_pedwarn (ec_conversion_from_to, intype, type);\n+\t  cp_pedwarn (\"conversion from `%#T' to `%#T'\", intype, type);\n \n \t  if (flag_pedantic_errors)\n \t    return error_mark_node;\n@@ -716,7 +716,7 @@ ocp_convert (type, expr, convtype, flags)\n \t  if (rval)\n \t    return rval;\n \t  if (flags & LOOKUP_COMPLAIN)\n-\t    cp_error (ec_used_where_a_was_expected, intype, type);\n+\t    cp_error (\"`%#T' used where a `%T' was expected\", intype, type);\n \t  if (flags & LOOKUP_SPECULATIVELY)\n \t    return NULL_TREE;\n \t  return error_mark_node;\n@@ -726,7 +726,7 @@ ocp_convert (type, expr, convtype, flags)\n \t  /* Common Ada/Pascal programmer's mistake.  We always warn\n              about this since it is so bad.  */\n \t  if (TREE_CODE (expr) == FUNCTION_DECL)\n-\t    cp_warning (ec_the_address_of_will_always_be_true, expr);\n+\t    cp_warning (\"the address of `%D', will always be `true'\", expr);\n \t  return truthvalue_conversion (e);\n \t}\n       return fold (convert_to_integer (type, e));\n@@ -744,7 +744,7 @@ ocp_convert (type, expr, convtype, flags)\n \t    return rval;\n \t  else\n \t    if (flags & LOOKUP_COMPLAIN)\n-\t      cp_error (ec_used_where_a_floating_point_value_was_expected,\n+\t      cp_error (\"`%#T' used where a floating point value was expected\",\n \t\t\tTREE_TYPE (e));\n \t}\n       if (code == REAL_TYPE)\n@@ -818,7 +818,7 @@ ocp_convert (type, expr, convtype, flags)\n     return e;\n \n   if (flags & LOOKUP_COMPLAIN)\n-    cp_error (ec_conversion_from_to_nonscalar_type_requested,\n+    cp_error (\"conversion from `%T' to non-scalar type `%T' requested\",\n \t      TREE_TYPE (expr), type);\n   if (flags & LOOKUP_SPECULATIVELY)\n     return NULL_TREE;\n@@ -948,7 +948,7 @@ build_expr_type_conversion (desires, expr, complain)\n   if (expr == null_node \n       && (desires & WANT_INT) \n       && !(desires & WANT_NULL))\n-    cp_warning (ec_converting_null_to_nonpointer_type);\n+    cp_warning (\"converting NULL to non-pointer type\");\n     \n   if (TREE_CODE (basetype) == OFFSET_TYPE)\n     expr = resolve_offset_ref (expr);\n@@ -1021,9 +1021,9 @@ build_expr_type_conversion (desires, expr, complain)\n \t    {\n \t      if (complain)\n \t\t{\n-\t\t  cp_error (ec_ambiguous_default_type_conversion_from,\n+\t\t  cp_error (\"ambiguous default type conversion from `%T'\",\n \t\t\t    basetype);\n-\t\t  cp_error (ec_candidate_conversions_include_and,\n+\t\t  cp_error (\"  candidate conversions include `%D' and `%D'\",\n \t\t\t    winner, cand);\n \t\t}\n \t      return error_mark_node;"}, {"sha": "42748ff151666c79f4d3875e90e3cf624b68b59d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 400, "deletions": 388, "changes": 788, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120"}, {"sha": "be8689ce189a2c48c2ea3a65824b2257a93a6bc7", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 87, "deletions": 109, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -181,9 +181,6 @@ int flag_init_priority = 1;\n int flag_init_priority;\n #endif\n \n-/* Nonzero means show diagnostic codes when printing error messages.  */\n-int flag_diag_codes;\n-\n /* Nonzero means warn about implicit declarations.  */\n \n int warn_implicit = 1;\n@@ -490,8 +487,7 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"check-new\", &flag_check_new, 1},\n   {\"repo\", &flag_use_repository, 1},\n   {\"for-scope\", &flag_new_for_scope, 2},\n-  {\"weak\", &flag_weak, 1},\n-  {\"diag-codes\", &flag_diag_codes, 1}\n+  {\"weak\", &flag_weak, 1}\n };\n \n /* Decode the string P as a language-specific option.\n@@ -534,7 +530,7 @@ lang_decode_option (argc, argv)\n \n       if (!strcmp (p, \"handle-exceptions\")\n \t  || !strcmp (p, \"no-handle-exceptions\"))\n-\tcp_warning (ec_fhandleexceptions_has_been_renamed_to_fexceptions_and_is_now_on_by_default);\n+\twarning (\"-fhandle-exceptions has been renamed to -fexceptions (and is now on by default)\");\n \n       if (!strcmp (p, \"memoize-lookups\")\n \t  || !strcmp (p, \"no-memoize-lookups\")\n@@ -553,7 +549,7 @@ lang_decode_option (argc, argv)\n \t       || !strcmp (p, \"no-nonnull-objects\")\n \t       || !strcmp (p, \"no-ansi-overloading\"))\n \t{\n-\t  cp_warning (ec_fs_is_no_longer_supported, p);\n+\t  warning (\"-f%s is no longer supported\", p);\n \t  found = 1;\n \t}\n       else if (! strcmp (p, \"alt-external-templates\"))\n@@ -606,7 +602,7 @@ lang_decode_option (argc, argv)\n \t\tendp++;\n \t      else\n \t\t{\n-\t\t  cp_error (ec_invalid_option_s, p - 2);\n+\t\t  error (\"Invalid option `%s'\", p - 2);\n \t\t  goto template_depth_lose;\n \t\t}\n \t    }\n@@ -622,7 +618,7 @@ lang_decode_option (argc, argv)\n \t\tendp++;\n \t      else\n \t\t{\n-\t\t  cp_error (ec_invalid_option_s, p - 2);\n+\t\t  error (\"Invalid option `%s'\", p - 2);\n \t\t  goto mangling_version_lose;\n \t\t}\n \t    }\n@@ -715,25 +711,6 @@ lang_decode_option (argc, argv)\n \twarn_unknown_pragmas = setting * 2;\n       else if (!strcmp (p, \"non-template-friend\"))\n \twarn_nontemplate_friend = setting;\n-      else if (!strncmp (p, \"number-\", strlen (\"number-\")))\n-\t{\n-\t  char *endp = p + strlen (\"number-\");\n-\t  while (*endp)\n-\t    {\n-\t      if (*endp >= '0' && *endp <= '9')\n-\t\tendp++;\n-\t      else \n-\t\t{\n-\t\t  cp_error (ec_invalid_option_s, p - 2);\n-\t\t  endp = 0;\n-\t\t}\n-\t    }\n-\t  if (endp)\n-\t    {\n-\t      int warning_number = atoi (p + strlen (\"number-\"));\n-\t      cp_enable_warning (warning_number, setting);\n-\t    }\n-\t}\n       else if (!strcmp (p, \"comment\"))\n \t;\t\t\t/* cpp handles this one.  */\n       else if (!strcmp (p, \"comments\"))\n@@ -804,7 +781,7 @@ grok_method_quals (ctype, function, quals)\n       if (TREE_VALUE (quals) == ridpointers[(int)RID_CONST])\n \t{\n \t  if (TYPE_READONLY (ctype))\n-\t    cp_error (ec_duplicate_s_s,\n+\t    error (\"duplicate `%s' %s\",\n \t\t   IDENTIFIER_POINTER (TREE_VALUE (quals)),\n \t\t   (TREE_CODE (function) == FUNCTION_DECL\n \t\t    ? \"for member function\" : \"in type declaration\"));\n@@ -814,7 +791,7 @@ grok_method_quals (ctype, function, quals)\n       else if (TREE_VALUE (quals) == ridpointers[(int)RID_VOLATILE])\n \t{\n \t  if (TYPE_VOLATILE (ctype))\n-\t    cp_error (ec_duplicate_s_s,\n+\t    error (\"duplicate `%s' %s\",\n \t\t   IDENTIFIER_POINTER (TREE_VALUE (quals)),\n \t\t   (TREE_CODE (function) == FUNCTION_DECL\n \t\t    ? \"for member function\" : \"in type declaration\"));\n@@ -860,13 +837,13 @@ warn_if_unknown_interface (decl)\n \t  lineno = til->line;\n \t  input_filename = til->file;\n \t}\n-      cp_warning (ec_template_instantiated_in_file_without_pragma_interface,\n+      cp_warning (\"template `%#D' instantiated in file without #pragma interface\",\n \t\t  decl);\n       lineno = sl;\n       input_filename = sf;\n     }\n   else\n-    cp_warning_at (ec_template_defined_in_file_without_pragma_interface,\n+    cp_warning_at (\"template `%#D' defined in file without #pragma interface\",\n \t\t   decl);\n }\n \n@@ -889,7 +866,7 @@ grok_x_components (specs, components)\n \n       if (t == NULL_TREE)\n \t{\n-\t  cp_error (ec_error_in_component_specification);\n+\t  error (\"error in component specification\");\n \t  return NULL_TREE;\n \t}\n \n@@ -956,7 +933,7 @@ grok_x_components (specs, components)\n \t\t    q = &TREE_CHAIN (*q);\n \t\t}\n \t      if (TYPE_METHODS (t))\n-\t\tcp_error (ec_an_anonymous_union_cannot_have_function_members);\n+\t\terror (\"an anonymous union cannot have function members\");\n \n \t      p = &pending_inlines;\n \t      for (; *p; *p = (*p)->next)\n@@ -978,7 +955,7 @@ grok_x_components (specs, components)\n \n \tdefault:\n \t  if (t != void_type_node)\n-\t    cp_error (ec_empty_component_declaration);\n+\t    error (\"empty component declaration\");\n \t  return NULL_TREE;\n \t}\n     }\n@@ -1075,7 +1052,7 @@ grokclassfn (ctype, cname, function, flags, quals)\n \n   if (fn_name == NULL_TREE)\n     {\n-      cp_error (ec_name_missing_for_member_function);\n+      error (\"name missing for member function\");\n       fn_name = get_identifier (\"<anonymous>\");\n       DECL_NAME (function) = fn_name;\n     }\n@@ -1145,7 +1122,7 @@ grok_alignof (expr)\n \n   if (TREE_CODE (expr) == COMPONENT_REF\n       && DECL_BIT_FIELD (TREE_OPERAND (expr, 1)))\n-    cp_error (ec_alignof_applied_to_a_bitfield);\n+    error (\"`__alignof__' applied to a bit-field\");\n \n   if (TREE_CODE (expr) == INDIRECT_REF)\n     {\n@@ -1197,7 +1174,7 @@ grok_array_decl (array_expr, index_exp)\n     {\n       /* Something has gone very wrong.  Assume we are mistakenly reducing\n \t an expression instead of a declaration.  */\n-      cp_error (ec_parser_may_be_lost_is_there_a_missing_somewhere);\n+      error (\"parser may be lost: is there a '{' missing somewhere?\");\n       return NULL_TREE;\n     }\n \n@@ -1228,21 +1205,21 @@ grok_array_decl (array_expr, index_exp)\n   i2 = build_expr_type_conversion (WANT_INT | WANT_ENUM, index_exp, 0);\n \n   if ((p1 && i2) && (i1 && p2))\n-    cp_error (ec_ambiguous_conversion_for_array_subscript);\n+    error (\"ambiguous conversion for array subscript\");\n \n   if (p1 && i2)\n     array_expr = p1, index_exp = i2;\n   else if (i1 && p2)\n     array_expr = p2, index_exp = i1;\n   else\n     {\n-      cp_error (ec_invalid_types_for_array_subscript,\n+      cp_error (\"invalid types `%T[%T]' for array subscript\",\n \t\ttype, TREE_TYPE (index_exp));\n       return error_mark_node;\n     }\n \n   if (array_expr == error_mark_node || index_exp == error_mark_node)\n-    cp_error (ec_ambiguous_conversion_for_array_subscript);\n+    error (\"ambiguous conversion for array subscript\");\n \n   return build_array_ref (array_expr, index_exp);\n }\n@@ -1284,15 +1261,15 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n \n   if (t == NULL_TREE || t == error_mark_node)\n     {\n-      cp_error (ec_type_argument_given_to_delete_expected_pointer,\n+      cp_error (\"type `%#T' argument given to `delete', expected pointer\",\n \t\tTREE_TYPE (exp));\n       return error_mark_node;\n     }\n \n   if (doing_vec == 2)\n     {\n       maxindex = build_binary_op (MINUS_EXPR, size, integer_one_node, 1);\n-      cp_pedwarn (ec_anachronistic_use_of_array_size_in_vector_delete);\n+      pedwarn (\"anachronistic use of array size in vector delete\");\n     }\n \n   type = TREE_TYPE (t);\n@@ -1302,15 +1279,15 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n   /* You can't delete functions.  */\n   if (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n     {\n-      cp_error (ec_cannot_delete_a_function);\n+      error (\"cannot delete a function\");\n       return error_mark_node;\n     }\n \n   /* An array can't have been allocated by new, so complain.  */\n   if (TREE_CODE (t) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (t, 0)) == VAR_DECL\n       && TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == ARRAY_TYPE)\n-    cp_warning (ec_deleting_array, TREE_OPERAND (t, 0));\n+    cp_warning (\"deleting array `%#D'\", TREE_OPERAND (t, 0));\n \n   /* Deleting a pointer with the value zero is valid and has no effect.  */\n   if (integer_zerop (t))\n@@ -1357,15 +1334,16 @@ check_member_template (tmpl)\n \t/* 14.5.2.2 [temp.mem]\n \t   \n \t   A local class shall not have member templates. */\n-\tcp_error (ec_declaration_of_member_template_in_local_class,\n+\tcp_error (\"declaration of member template `%#D' in local class\",\n \t\t  decl);\n       \n       if (TREE_CODE (decl) == FUNCTION_DECL && DECL_VIRTUAL_P (decl))\n \t{\n \t  /* 14.5.2.3 [temp.mem]\n \n \t     A member function template shall not be virtual.  */\n-\t  cp_error (ec_invalid_use_of_virtual_in_template_declaration_of,\n+\t  cp_error \n+\t    (\"invalid use of `virtual' in template declaration of `%#D'\",\n \t     decl);\n \t  DECL_VIRTUAL_P (decl) = 0;\n \t}\n@@ -1375,7 +1353,7 @@ check_member_template (tmpl)\n       DECL_IGNORED_P (tmpl) = 1;\n     } \n   else\n-    cp_error (ec_template_declaration_of, decl);\n+    cp_error (\"template declaration of `%#D'\", decl);\n }\n \n /* Return true iff TYPE is a valid Java parameter or return type. */\n@@ -1425,7 +1403,7 @@ check_java_method (ctype, method)\n   tree ret_type = TREE_TYPE (TREE_TYPE (method));\n   if (! acceptable_java_type (ret_type))\n     {\n-      cp_error (ec_ava_method_has_nonava_return_type,\n+      cp_error (\"Java method '%D' has non-Java return type `%T'\",\n \t\tmethod, ret_type);\n       jerr++;\n     }\n@@ -1434,7 +1412,7 @@ check_java_method (ctype, method)\n       tree type = TREE_VALUE (arg_types);\n       if (! acceptable_java_type (type))\n \t{\n-\t  cp_error (ec_ava_method_has_nonava_parameter_type,\n+\t  cp_error (\"Java method '%D' has non-Java parameter type `%T'\",\n \t\t    method, type);\n \t  jerr++;\n \t}\n@@ -1548,17 +1526,17 @@ check_classfn (ctype, function)\n   if (methods != end)\n     {\n       tree fndecl = *methods;\n-      cp_error (ec_prototype_for_does_not_match_any_in_class,\n+      cp_error (\"prototype for `%#D' does not match any in class `%T'\",\n \t\tfunction, ctype);\n-      cp_error_at (ec_candidates, OVL_NEXT (fndecl) ? \"s are\" : \" is\",\n+      cp_error_at (\"candidate%s: %+#D\", OVL_NEXT (fndecl) ? \"s are\" : \" is\",\n \t\t   OVL_CURRENT (fndecl));\n       while (fndecl = OVL_NEXT (fndecl), fndecl)\n-\tcp_error_at (ec_candidate_2, OVL_CURRENT(fndecl));\n+\tcp_error_at (\"                %#D\", OVL_CURRENT(fndecl));\n     }\n   else\n     {\n       methods = 0;\n-      cp_error (ec_no_member_function_declared_in_class,\n+      cp_error (\"no `%#D' member function declared in class `%T'\",\n \t\tfunction, ctype);\n     }\n \n@@ -1638,7 +1616,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n   if (DECL_NAME (value) != NULL_TREE\n       && IDENTIFIER_POINTER (DECL_NAME (value))[0] == '_'\n       && ! strcmp (IDENTIFIER_POINTER (DECL_NAME (value)), \"_vptr\"))\n-    cp_error (ec_member_conflicts_with_virtual_function_table_field_name,\n+    cp_error (\"member `%D' conflicts with virtual function table field name\",\n \t      value);\n \n   /* Stash away type declarations.  */\n@@ -1663,13 +1641,13 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n   if (IS_SIGNATURE (current_class_type)\n       && TREE_CODE (value) != FUNCTION_DECL)\n     {\n-      cp_error (ec_field_declaration_not_allowed_in_signature);\n+      error (\"field declaration not allowed in signature\");\n       return void_type_node;\n     }\n \n   if (DECL_IN_AGGR_P (value))\n     {\n-      cp_error (ec_is_already_defined_in_the_class, value,\n+      cp_error (\"`%D' is already defined in the class %T\", value,\n \t\t  DECL_CONTEXT (value));\n       return void_type_node;\n     }\n@@ -1682,7 +1660,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n       if (IS_SIGNATURE (current_class_type)\n \t  && TREE_CODE (value) == FUNCTION_DECL)\n \t{\n-\t  cp_error (ec_function_declarations_cannot_have_initializers_in_signature);\n+\t  error (\"function declarations cannot have initializers in signature\");\n \t  init = NULL_TREE;\n \t}\n       else if (TREE_CODE (value) == FUNCTION_DECL)\n@@ -1728,7 +1706,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \t\t      && (TREE_CODE_CLASS (TREE_CODE (init)) != 'd'\n \t\t\t  || DECL_EXTERNAL (init) == 0)))\n \t\t{\n-\t\t  cp_error (ec_field_initializer_is_not_constant);\n+\t\t  error (\"field initializer is not constant\");\n \t\t  init = error_mark_node;\n \t\t}\n \t    }\n@@ -1750,8 +1728,8 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \ttree olddecl = IDENTIFIER_LOCAL_VALUE (declarator);\n \tif (decl_template_parm_p (olddecl))\n \t  {\n-\t    cp_error (ec_redeclaration_of_template_parameter, declarator);\n-\t    cp_error_at (ec_previously_declared_here, olddecl);\n+\t    cp_error (\"redeclaration of template parameter `%T'\", declarator);\n+\t    cp_error_at (\" previously declared here `%#D'\", olddecl);\n \t  }\n       }\n \n@@ -1783,9 +1761,9 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \t{\n \t  static int explanation = 0;\n \t  \n-\t  cp_error (ec_initializer_invalid_for_static_member_with_constructor);\n+\t  error (\"initializer invalid for static member with constructor\");\n \t  if (explanation++ == 0)\n-\t    cp_error (ec_you_really_want_to_initialize_it_separately);\n+\t    error (\"(you really want to initialize it separately)\");\n \t  init = 0;\n \t}\n       /* Force the compiler to know when an uninitialized static\n@@ -1834,7 +1812,7 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \n #if 0 /* Just because a fn is declared doesn't mean we'll try to define it.  */\n       if (current_function_decl && ! IS_SIGNATURE (current_class_type))\n-\tcp_error (ec_method_of_local_class_must_be_defined_in_class_body,\n+\tcp_error (\"method `%#D' of local class must be defined in class body\",\n \t\t  value);\n #endif\n \n@@ -1864,7 +1842,7 @@ grokbitfield (declarator, declspecs, width)\n \n   if (TREE_CODE (value) == TYPE_DECL)\n     {\n-      cp_error (ec_cannot_declare_to_be_a_bitfield_type, value);\n+      cp_error (\"cannot declare `%D' to be a bitfield type\", value);\n       return NULL_TREE;\n     }\n \n@@ -1874,20 +1852,20 @@ grokbitfield (declarator, declspecs, width)\n      check here.  */\n   if (TREE_CODE (value) == FUNCTION_DECL)\n     {\n-      cp_error (ec_cannot_declare_bitfield_with_funcion_type,\n+      cp_error (\"cannot declare bitfield `%D' with funcion type\",\n \t\tDECL_NAME (value));\n       return NULL_TREE;\n     }\n \n   if (IS_SIGNATURE (current_class_type))\n     {\n-      cp_error (ec_field_declaration_not_allowed_in_signature);\n+      error (\"field declaration not allowed in signature\");\n       return void_type_node;\n     }\n \n   if (DECL_IN_AGGR_P (value))\n     {\n-      cp_error (ec_is_already_defined_in_the_class, value,\n+      cp_error (\"`%D' is already defined in the class %T\", value,\n \t\t  DECL_CONTEXT (value));\n       return void_type_node;\n     }\n@@ -1896,7 +1874,7 @@ grokbitfield (declarator, declspecs, width)\n \n   if (TREE_STATIC (value))\n     {\n-      cp_error (ec_static_member_cannot_be_a_bitfield, value);\n+      cp_error (\"static member `%D' cannot be a bitfield\", value);\n       return NULL_TREE;\n     }\n   cp_finish_decl (value, NULL_TREE, NULL_TREE, 0, 0);\n@@ -1987,11 +1965,11 @@ grok_function_init (decl, init)\n   tree type = TREE_TYPE (decl);\n \n   if (TREE_CODE (type) == FUNCTION_TYPE)\n-    cp_error (ec_initializer_specified_for_nonmember_function, decl);\n+    cp_error (\"initializer specified for non-member function `%D'\", decl);\n #if 0\n   /* We'll check for this in finish_struct_1.  */\n   else if (DECL_VINDEX (decl) == NULL_TREE)\n-    cp_error (ec_initializer_specified_for_nonvirtual_method, decl);\n+    cp_error (\"initializer specified for non-virtual method `%D'\", decl);\n #endif\n   else if (integer_zerop (init))\n     {\n@@ -2019,7 +1997,7 @@ grok_function_init (decl, init)\n \t}\n     }\n   else\n-    cp_error (ec_invalid_initializer_for_virtual_method, decl);\n+    cp_error (\"invalid initializer for virtual method `%D'\", decl);\n }\n \f\n void\n@@ -2242,9 +2220,9 @@ build_anon_union_vars (anon_decl, elems, static_p, external_p)\n \tcontinue;\n \n       if (TREE_PRIVATE (field))\n-\tcp_pedwarn_at (ec_private_member_in_anonymous_union, field);\n+\tcp_pedwarn_at (\"private member `%#D' in anonymous union\", field);\n       else if (TREE_PROTECTED (field))\n-\tcp_pedwarn_at (ec_protected_member_in_anonymous_union, field);\n+\tcp_pedwarn_at (\"protected member `%#D' in anonymous union\", field);\n \n       if (DECL_NAME (field) == NULL_TREE\n \t  && TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n@@ -2314,7 +2292,7 @@ finish_anon_union (anon_union_decl)\n \n   if (public_p)\n     {\n-      cp_error (ec_global_anonymous_unions_must_be_declared_static);\n+      error (\"global anonymous unions must be declared static\");\n       return;\n     }\n \n@@ -2330,7 +2308,7 @@ finish_anon_union (anon_union_decl)\n \t}\n       else\n \t{\n-\t  cp_warning (ec_anonymous_union_with_no_members);\n+\t  warning (\"anonymous union with no members\");\n \t  return;\n \t}\n     }\n@@ -2390,15 +2368,15 @@ coerce_new_type (type)\n   if (TREE_CODE (type) == METHOD_TYPE)\n     type = build_function_type (TREE_TYPE (type), TREE_CHAIN (TYPE_ARG_TYPES (type)));\n   if (TREE_TYPE (type) != ptr_type_node)\n-    e1 = 1, cp_error (ec_operator_new_must_return_type_void);\n+    e1 = 1, error (\"`operator new' must return type `void *'\");\n \n   /* Technically the type must be `size_t', but we may not know\n      what that is.  */\n   if (TYPE_ARG_TYPES (type) == NULL_TREE)\n-    e1 = 1, cp_error (ec_operator_new_takes_type_size_t_parameter);\n+    e1 = 1, error (\"`operator new' takes type `size_t' parameter\");\n   else if (TREE_CODE (TREE_VALUE (TYPE_ARG_TYPES (type))) != INTEGER_TYPE\n \t   || TYPE_PRECISION (TREE_VALUE (TYPE_ARG_TYPES (type))) != TYPE_PRECISION (sizetype))\n-    e2 = 1, cp_error (ec_operator_new_takes_type_size_t_as_first_parameter);\n+    e2 = 1, error (\"`operator new' takes type `size_t' as first parameter\");\n   if (e2)\n     type = build_function_type (ptr_type_node, tree_cons (NULL_TREE, sizetype, TREE_CHAIN (TYPE_ARG_TYPES (type))));\n   else if (e1)\n@@ -2423,11 +2401,11 @@ coerce_delete_type (type)\n     }\n \n   if (TREE_TYPE (type) != void_type_node)\n-    e1 = 1, cp_error (ec_operator_delete_must_return_type_void);\n+    e1 = 1, error (\"`operator delete' must return type `void'\");\n \n   if (arg_types == NULL_TREE\n       || TREE_VALUE (arg_types) != ptr_type_node)\n-    e2 = 1, cp_error (ec_operator_delete_takes_type_void_as_first_parameter);\n+    e2 = 1, error (\"`operator delete' takes type `void *' as first parameter\");\n \n #if 0\n   if (arg_types\n@@ -2439,14 +2417,14 @@ coerce_delete_type (type)\n       tree t2 = TREE_VALUE (TREE_CHAIN (arg_types));\n       if (TREE_CODE (t2) != INTEGER_TYPE\n \t  || TYPE_PRECISION (t2) != TYPE_PRECISION (sizetype))\n-\te3 = 1, cp_error (ec_second_argument_to_operator_delete_must_be_of_type_size_t);\n+\te3 = 1, error (\"second argument to `operator delete' must be of type `size_t'\");\n       else if (TREE_CHAIN (TREE_CHAIN (arg_types)) != void_list_node)\n \t{\n \t  e3 = 1;\n \t  if (TREE_CHAIN (TREE_CHAIN (arg_types)))\n-\t    cp_error (ec_too_many_arguments_in_declaration_of_operator_delete);\n+\t    error (\"too many arguments in declaration of `operator delete'\");\n \t  else\n-\t    cp_error (ec_invalid_in_specification_of_operator_delete);\n+\t    error (\"`...' invalid in specification of `operator delete'\");\n \t}\n     }\n \n@@ -3003,7 +2981,7 @@ setup_initp ()\n   if (! flag_init_priority)\n     {\n       for (t = static_aggregates_initp; t; t = TREE_CHAIN (t))\n-\tcp_warning (ec_init_priority_for_ignored_without_finitpriority,\n+\tcp_warning (\"init_priority for `%#D' ignored without -finit-priority\",\n \t\t    TREE_VALUE (t));\n       return;\n     }\n@@ -3684,7 +3662,7 @@ reparse_absdcl_as_casts (decl, expr)\n \n       if (IS_SIGNATURE (type))\n \t{\n-\t  cp_error (ec_cast_specifies_signature_type);\n+\t  error (\"cast specifies signature type\");\n \t  return error_mark_node;\n \t}\n \n@@ -3705,7 +3683,7 @@ reparse_absdcl_as_casts (decl, expr)\n     }\n \n   if (warn_old_style_cast)\n-    cp_warning (ec_use_of_oldstyle_cast);\n+    warning (\"use of old-style cast\");\n \n   return expr;\n }\n@@ -4046,7 +4024,7 @@ check_cp_case_value (value)\n   if (TREE_CODE (value) != INTEGER_CST\n       && value != error_mark_node)\n     {\n-      cp_error (ec_case_label_does_not_reduce_to_an_integer_constant,\n+      cp_error (\"case label `%E' does not reduce to an integer constant\",\n \t\tvalue);\n       value = error_mark_node;\n     }\n@@ -4210,10 +4188,10 @@ ambiguous_decl (name, old, new, flags)\n \t  /* Some declarations are functions, some are not. */\n           if (flags & LOOKUP_COMPLAIN)\n             {\n-              cp_error (ec_use_of_is_ambiguous, name);\n-              cp_error_at (ec_first_declared_as_here,\n+              cp_error (\"use of `%D' is ambiguous\", name);\n+              cp_error_at (\"  first declared as `%#D' here\",\n                            BINDING_VALUE (old));\n-              cp_error_at (ec_also_declared_as_here, val);\n+              cp_error_at (\"  also declared as `%#D' here\", val);\n             }\n \t  return error_mark_node;\n \t}\n@@ -4228,9 +4206,9 @@ ambiguous_decl (name, old, new, flags)\n     {\n       if (flags & LOOKUP_COMPLAIN)\n         {\n-          cp_error (ec_denotes_an_ambiguous_type,name);\n-          cp_error_at (ec_first_type_here, BINDING_TYPE (old));\n-          cp_error_at (ec_other_type_here, type);\n+          cp_error (\"`%D' denotes an ambiguous type\",name);\n+          cp_error_at (\"  first type here\", BINDING_TYPE (old));\n+          cp_error_at (\"  other type here\", type);\n         }\n     }\n   return old;\n@@ -4317,7 +4295,7 @@ set_decl_namespace (decl, scope)\n   scope = ORIGINAL_NAMESPACE (scope);\n   \n   if (!is_namespace_ancestor (current_namespace, scope))\n-    cp_error (ec_declaration_of_not_in_a_namespace_surrounding,\n+    cp_error (\"declaration of `%D' not in a namespace surrounding `%D'\",\n \t      decl, scope);\n   DECL_CONTEXT (decl) = FROB_CONTEXT (scope);\n   if (scope != current_namespace)\n@@ -4342,7 +4320,7 @@ set_decl_namespace (decl, scope)\n   else\n     return;\n  complain:\n-  cp_error (ec_should_have_been_declared_inside,\n+  cp_error (\"`%D' should have been declared inside `%D'\",\n \t    decl, scope);\n } \n \n@@ -4445,9 +4423,9 @@ add_function (k, fn)\n \t  {\n \t    fn = f1; f1 = f2; f2 = fn;\n \t  }\n-\tcp_error_at (ec_is_not_a_function, f1);\n-\tcp_error_at (ec_conflict_with, f2);\n-\tcp_error (ec_in_call_to, k->name);\n+\tcp_error_at (\"`%D' is not a function,\", f1);\n+\tcp_error_at (\"  conflict with `%D'\", f2);\n+\tcp_error (\"  in call to `%D'\", k->name);\n \treturn 1;\n       }\n     else\n@@ -4715,7 +4693,7 @@ do_namespace_alias (alias, namespace)\n   if (TREE_CODE (namespace) != NAMESPACE_DECL)\n     {\n       /* The parser did not find it, so it's not there. */\n-      cp_error (ec_unknown_namespace, namespace);\n+      cp_error (\"unknown namespace `%D'\", namespace);\n       return;\n     }\n \n@@ -4777,7 +4755,7 @@ do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n \n   if (!BINDING_VALUE (decls) && !BINDING_TYPE (decls))\n     {\n-      cp_error (ec_not_declared, name);\n+      cp_error (\"`%D' not declared\", name);\n       return;\n     }\n \n@@ -4825,7 +4803,7 @@ do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n   *newtype = BINDING_TYPE (decls);\n   if (oldtype && *newtype && oldtype != *newtype)\n     {\n-      cp_error (ec_using_directive_introduced_ambiguous_type,\n+      cp_error (\"using directive `%D' introduced ambiguous type `%T'\",\n \t\tname, oldtype);\n       return;\n     }\n@@ -4892,13 +4870,13 @@ do_class_using_decl (decl)\n   if (TREE_CODE (decl) != SCOPE_REF\n       || TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (decl, 0))) != 't')\n     {\n-      cp_error (ec_usingdeclaration_for_nonmember_at_class_scope);\n+      cp_error (\"using-declaration for non-member at class scope\");\n       return NULL_TREE;\n     }\n   name = TREE_OPERAND (decl, 1);\n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n-      cp_error (ec_usingdeclaration_for_destructor);\n+      cp_error (\"using-declaration for destructor\");\n       return NULL_TREE;\n     }\n   if (TREE_CODE (name) == TYPE_DECL)\n@@ -4925,12 +4903,12 @@ do_using_directive (namespace)\n   if (TREE_CODE (namespace) == IDENTIFIER_NODE)\n     {\n       /* Lookup in lexer did not find a namespace. */\n-      cp_error (ec_namespace_undeclared, namespace);\n+      cp_error (\"namespace `%T' undeclared\", namespace);\n       return;\n     }\n   if (TREE_CODE (namespace) != NAMESPACE_DECL)\n     {\n-      cp_error (ec_is_not_a_namespace, namespace);\n+      cp_error (\"`%T' is not a namespace\", namespace);\n       return;\n     }\n   namespace = ORIGINAL_NAMESPACE (namespace);\n@@ -4953,7 +4931,7 @@ check_default_args (x)\n \tsaw_def = 1;\n       else if (saw_def)\n \t{\n-\t  cp_error_at (ec_default_argument_missing_for_parameter_of,\n+\t  cp_error_at (\"default argument missing for parameter %P of `%+#D'\",\n \t\t       i, x);\n \t  break;\n \t}\n@@ -4998,9 +4976,9 @@ handle_class_head (aggr, scope, id)\n     return id;\n \n   if (scope)\n-    cp_error (ec_does_not_have_a_nested_type_named, scope, id);\n+    cp_error (\"`%T' does not have a nested type named `%D'\", scope, id);\n   else\n-    cp_error (ec_no_filescope_type_named, id);\n+    cp_error (\"no file-scope type named `%D'\", id);\n \n   id = xref_tag\n     (aggr, make_anon_name (), 1);"}, {"sha": "10de8a9d12be660a0fe307465426f4fd93fb4132", "filename": "gcc/cp/errfn.c", "status": "modified", "additions": 20, "deletions": 97, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Ferrfn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Ferrfn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferrfn.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -23,7 +23,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"tree.h\"\n #include \"toplev.h\"\n-#include \"cp-tree.h\"\n \n /* cp_printer is the type of a function which converts an argument into\n    a string for digestion by printf.  The cp_printer function should deal\n@@ -38,36 +37,10 @@ extern cp_printer * cp_printers[256];\n    when we're computing the conversion costs for a method call.  */\n int cp_silent = 0;\n \n-/* The error messages themselves.  */\n-typedef struct cp_err_msg {\n-  /* The format of the error message.  */\n-  char* format;\n-\n-  /* The code which we should check when deciding whether or not to\n-     issue this message.  Used to indicate that some errors are \"the\n-     same\" even though they have different formats.  */\n-  error_code equiv_code;\n-\n-  /* A count of how many more times this warning has been enabled than\n-     disabled.  (Ignored for errors.)  */\n-  int enabled;\n-} cp_err_msg;\n-\n-static cp_err_msg err_msgs[] = {\n-#undef DEFERROR\n-#undef DEFERRORNUM\n-#define DEFERROR(code, format) DEFERRORNUM(code, format, code)\n-#define DEFERRORNUM(code, format, equiv_code) \\\n-  { format, equiv_code, 1 },\n-#include \"cp-error.def\"\n-  { 0, 0, 0 }\n-};\n-\n typedef void errorfn ();\t/* deliberately vague */\n \n extern char* cp_file_of PROTO((tree));\n extern int   cp_line_of PROTO((tree));\n-static int   is_warning_enabled PROTO((error_code));\n \n #define STRDUP(f) (ap = (char *) alloca (strlen (f) +1), strcpy (ap, (f)), ap)\n \n@@ -76,13 +49,13 @@ static int   is_warning_enabled PROTO((error_code));\n \n #ifdef __STDC__\n static void\n-cp_thing (errorfn *errfn, int atarg1, error_code ec, va_list ap)\n+cp_thing (errorfn *errfn, int atarg1, const char *format, va_list ap)\n #else\n static void\n-cp_thing (errfn, atarg1, ec, ap)\n+cp_thing (errfn, atarg1, format, ap)\n      errorfn *errfn;\n      int atarg1;\n-     error_code ec;\n+     const char *format;\n      va_list ap;\n #endif\n {\n@@ -93,29 +66,14 @@ cp_thing (errfn, atarg1, ec, ap)\n   long offset;\n   const char *f;\n   tree atarg = 0;\n-  char* format;\n-\n-  my_friendly_assert ((int) ec >= 0 && (int) ec < ec_last_error_code, \n-\t\t      0);\n-    \n-  format = err_msgs[(int) ec].format;\n-\n-  my_friendly_assert (format != 0, 0);\n \n-  len = strlen (format) + 1 /* '\\0' */ + 16 /* code number */;\n+  len = strlen (format) + 1;\n   if (len > buflen)\n     {\n       buflen = len;\n       buf = xrealloc (buf, buflen);\n     }\n-  if (flag_diag_codes) \n-    {\n-      sprintf (buf, \"[%d] \", (int) ec);\n-      for (offset = 0; buf[offset]; ++offset)\n-\t;\n-    }\n-  else\n-    offset = 0;\n+  offset = 0;\n \n   for (f = format; *f; ++f)\n     {\n@@ -240,10 +198,10 @@ cp_thing (errfn, atarg1, ec, ap)\n }\n \n #ifdef __STDC__\n-#define DECLARE(name) void name (error_code ec, ...)\n-#define INIT va_start (ap, ec)\n+#define DECLARE(name) void name (const char *format, ...)\n+#define INIT va_start (ap, format)\n #else\n-#define DECLARE(name) void name (ec, va_alist) error_code ec; va_dcl\n+#define DECLARE(name) void name (format, va_alist) char *format; va_dcl\n #define INIT va_start (ap)\n #endif\n \n@@ -252,25 +210,25 @@ DECLARE (cp_error)\n   va_list ap;\n   INIT;\n   if (! cp_silent)\n-    cp_thing ((errorfn *) error, 0, ec, ap);\n+    cp_thing ((errorfn *) error, 0, format, ap);\n   va_end (ap);\n }\n \n DECLARE (cp_warning)\n {\n   va_list ap;\n   INIT;\n-  if (! cp_silent && is_warning_enabled (ec))\n-    cp_thing ((errorfn *) warning, 0, ec, ap);\n+  if (! cp_silent)\n+    cp_thing ((errorfn *) warning, 0, format, ap);\n   va_end (ap);\n }\n \n DECLARE (cp_pedwarn)\n {\n   va_list ap;\n   INIT;\n-  if (! cp_silent && is_warning_enabled (ec))\n-    cp_thing ((errorfn *) pedwarn, 0, ec, ap);\n+  if (! cp_silent)\n+    cp_thing ((errorfn *) pedwarn, 0, format, ap);\n   va_end (ap);\n }\n \n@@ -280,15 +238,15 @@ DECLARE (cp_compiler_error)\n   va_list ap;\n   INIT;\n   if (! cp_silent)\n-    cp_thing (compiler_error, 0, ec, ap);\n+    cp_thing (compiler_error, 0, format, ap);\n   va_end (ap);\n }\n \n DECLARE (cp_sprintf)\n {\n   va_list ap;\n   INIT;\n-  cp_thing ((errorfn *) sprintf, 0, ec, ap);\n+  cp_thing ((errorfn *) sprintf, 0, format, ap);\n   va_end (ap);\n }\n \n@@ -297,59 +255,24 @@ DECLARE (cp_error_at)\n   va_list ap;\n   INIT;\n   if (! cp_silent)\n-    cp_thing ((errorfn *) error_with_file_and_line, 1, ec, ap);\n+    cp_thing ((errorfn *) error_with_file_and_line, 1, format, ap);\n   va_end (ap);\n }\n \n DECLARE (cp_warning_at)\n {\n   va_list ap;\n   INIT;\n-  if (! cp_silent && is_warning_enabled (ec))\n-    cp_thing ((errorfn *) warning_with_file_and_line, 1, ec, ap);\n+  if (! cp_silent)\n+    cp_thing ((errorfn *) warning_with_file_and_line, 1, format, ap);\n   va_end (ap);\n }\n \n DECLARE (cp_pedwarn_at)\n {\n   va_list ap;\n   INIT;\n-  if (! cp_silent && is_warning_enabled (ec))\n-    cp_thing ((errorfn *) pedwarn_with_file_and_line, 1, ec, ap);\n+  if (! cp_silent)\n+    cp_thing ((errorfn *) pedwarn_with_file_and_line, 1, format, ap);\n   va_end (ap);\n }\n-\n-/* If ON is non-zero, enable the warning with the indicated NUMBER.\n-   If OFF is zero, disable it.  Actually, this function manipulates a\n-   counter, so that enabling/disabling of warnings can nest\n-   appropriately.  */\n-\n-void \n-cp_enable_warning (number, on)\n-     int number;\n-     int on;\n-{\n-  if (number < 0 || number > (int) ec_last_error_code)\n-    error (\"invalid warning number %d\", number);\n-  else if (on)\n-    err_msgs[number].enabled++;\n-  else\n-    {\n-      if (!err_msgs[number].enabled)\n-\twarning (\"warning %d not enabled\", number);\n-      else\n-\terr_msgs[number].enabled--;\n-    }\n-}\n-\n-/* Returns non-zero if EC corresponds to an enabled error message.  */\n-\n-int\n-is_warning_enabled (ec)\n-     error_code ec;\n-{\n-  my_friendly_assert ((int) ec >= 0 && (int) ec < ec_last_error_code, \n-\t\t      0);\n-    \n-  return err_msgs[(int) ec].enabled;\n-}"}, {"sha": "69315beba39d3995198a8e438b1693708a700f14", "filename": "gcc/cp/except.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -633,7 +633,7 @@ process_start_catch_block_old (declspecs, declarator)\n       decl = grokdeclarator (declarator, declspecs, CATCHPARM, 1, NULL_TREE);\n \n       if (decl == NULL_TREE)\n-\tcp_error (ec_invalid_catch_parameter);\n+\terror (\"invalid catch parameter\");\n     }\n \n   if (decl)\n@@ -745,7 +745,7 @@ process_start_catch_block (declspecs, declarator)\n       decl = grokdeclarator (declarator, declspecs, CATCHPARM, 1, NULL_TREE);\n \n       if (decl == NULL_TREE)\n-\tcp_error (ec_invalid_catch_parameter);\n+\terror (\"invalid catch parameter\");\n     }\n \n   if (decl)\n@@ -1173,7 +1173,7 @@ expand_throw (exp)\n \t  exp = build_modify_expr (object, INIT_EXPR, exp);\n \n \t  if (exp == error_mark_node)\n-\t    cp_error (ec_in_thrown_expression);\n+\t    error (\"  in thrown expression\");\n \n \t  expand_expr (exp, const0_rtx, VOIDmode, 0);\n \t  expand_eh_region_end (build_terminate_handler ());\n@@ -1277,7 +1277,7 @@ build_throw (e)\n     return build_min (THROW_EXPR, void_type_node, e);\n \n   if (e == null_node)\n-    cp_warning (ec_throwing_which_has_integral_not_pointer_type);\n+    cp_warning (\"throwing NULL, which has integral, not pointer type\");\n \n   e = build1 (THROW_EXPR, void_type_node, e);\n   TREE_SIDE_EFFECTS (e) = 1;"}, {"sha": "4c3d8b602cefcc72005327f8c24ce1b079594793", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -331,10 +331,10 @@ do_case (start, end)\n \n   if (start != NULL_TREE && TREE_TYPE (start) != NULL_TREE \n       && POINTER_TYPE_P (TREE_TYPE (start)))\n-    cp_error (ec_pointers_are_not_permitted_as_case_values);\n+    error (\"pointers are not permitted as case values\");\n \n   if (end && pedantic)\n-    cp_pedwarn (ec_forbids_range_expressions_in_switch_statement);\n+    pedwarn (\"ANSI C++ forbids range expressions in switch statement\");\n \n   if (processing_template_decl)\n     {\n@@ -366,43 +366,43 @@ do_case (start, end)\n       if (success == 1)\n \t{\n \t  if (end)\n-\t    cp_error (ec_case_label_not_within_a_switch_statement);\n+\t    error (\"case label not within a switch statement\");\n \t  else if (start)\n-\t    cp_error (ec_case_label_not_within_a_switch_statement, start);\n+\t    cp_error (\"case label `%E' not within a switch statement\", start);\n \t  else\n-\t    cp_error (ec_default_label_not_within_a_switch_statement);\n+\t    error (\"default label not within a switch statement\");\n \t}\n       else if (success == 2)\n \t{\n \t  if (end)\n \t    {\n-\t      cp_error (ec_duplicate_or_overlapping_case_value);\n-\t      cp_error_at (ec_this_is_the_first_entry_overlapping_that_value,\n+\t      error (\"duplicate (or overlapping) case value\");\n+\t      cp_error_at (\"this is the first entry overlapping that value\",\n \t\t\t   duplicate);\n \t    }\n \t  else if (start)\n \t    {\n-\t      cp_error (ec_duplicate_case_value, start);\n-\t      cp_error_at (ec_previously_used_here, duplicate);\n+\t      cp_error (\"duplicate case value `%E'\", start);\n+\t      cp_error_at (\"previously used here\", duplicate);\n \t    }\n \t  else\n \t    {\n-\t      cp_error (ec_multiple_default_labels_in_one_switch);\n-\t      cp_error_at (ec_this_is_the_first_default_label, duplicate);\n+\t      error (\"multiple default labels in one switch\");\n+\t      cp_error_at (\"this is the first default label\", duplicate);\n \t    }\n \t}\n       else if (success == 3)\n-\tcp_warning (ec_case_value_out_of_range);\n+\twarning (\"case value out of range\");\n       else if (success == 4)\n-\tcp_warning (ec_empty_range_specified);\n+\twarning (\"empty range specified\");\n       else if (success == 5)\n \t{\n \t  if (end)\n-\t    cp_error (ec_case_label_within_scope_of_cleanup_or_variable_array);\n+\t    error (\"case label within scope of cleanup or variable array\");\n \t  else if (! start)\n-\t    cp_error (ec_default_label_within_scope_of_cleanup_or_variable_array);\n+\t    error (\"`default' label within scope of cleanup or variable array\");\n \t  else\n-\t    cp_error (ec_case_label_within_scope_of_cleanup_or_variable_array, start);\n+\t    cp_error (\"case label `%E' within scope of cleanup or variable array\", start);\n \t}\n     }\n   if (start)"}, {"sha": "d01ecdafdf1646734bacfd35d75a4a0ff551bf19", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -155,9 +155,9 @@ add_friend (type, decl)\n \t    {\n \t      if (decl == TREE_VALUE (friends))\n \t\t{\n-\t\t  cp_warning (ec_is_already_a_friend_of_class,\n+\t\t  cp_warning (\"`%D' is already a friend of class `%T'\",\n \t\t\t      decl, type);\n-\t\t  cp_warning_at (ec_previous_friend_declaration_of,\n+\t\t  cp_warning_at (\"previous friend declaration of `%D'\",\n \t\t\t\t TREE_VALUE (friends));\n \t\t  return;\n \t\t}\n@@ -205,11 +205,11 @@ add_friends (type, name, friend_type)\n \t  if (friends)\n \t    {\n \t      if (friend_type)\n-\t\tcp_warning (ec_method_ss_is_already_a_friend_of_class,\n+\t\twarning (\"method `%s::%s' is already a friend of class\",\n \t\t\t TYPE_NAME_STRING (friend_type),\n \t\t\t IDENTIFIER_POINTER (name));\n \t      else\n-\t\tcp_warning (ec_function_s_is_already_a_friend_of_class_s,\n+\t\twarning (\"function `%s' is already a friend of class `%s'\",\n \t\t\t IDENTIFIER_POINTER (name),\n \t\t\t IDENTIFIER_POINTER (DECL_NAME (typedecl)));\n \t    }\n@@ -252,12 +252,12 @@ make_friend_class (type, friend_type)\n \n   if (IS_SIGNATURE (type))\n     {\n-      cp_error (ec_friend_declaration_in_signature_definition);\n+      error (\"`friend' declaration in signature definition\");\n       return;\n     }\n   if (IS_SIGNATURE (friend_type))\n     {\n-      cp_error (ec_signature_type_s_declared_friend,\n+      error (\"signature type `%s' declared `friend'\",\n \t     IDENTIFIER_POINTER (TYPE_IDENTIFIER (friend_type)));\n       return;\n     }\n@@ -269,7 +269,7 @@ make_friend_class (type, friend_type)\n \t \n \t Friend declarations shall not declare partial\n \t specializations.  */\n-      cp_error (ec_partial_specialization_declared_friend,\n+      cp_error (\"partial specialization `%T' declared `friend'\",\n \t\tfriend_type);\n       return;\n     }\n@@ -281,7 +281,7 @@ make_friend_class (type, friend_type)\n     is_template_friend = 1;\n   else if (comptypes (type, friend_type, 1))\n     {\n-      cp_pedwarn (ec_class_s_is_implicitly_friends_with_itself,\n+      pedwarn (\"class `%s' is implicitly friends with itself\",\n \t       TYPE_NAME_STRING (type));\n       return;\n     }\n@@ -301,7 +301,7 @@ make_friend_class (type, friend_type)\n \t      comptypes (TREE_VALUE (classes), friend_type, 1)))\n     classes = TREE_CHAIN (classes);\n   if (classes) \n-    cp_warning (ec_is_already_a_friend_of,\n+    cp_warning (\"`%T' is already a friend of `%T'\",\n \t\tTREE_VALUE (classes), type);\n   else\n     {\n@@ -384,7 +384,7 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n \t\t  TYPE_SIZE (ctype) || template_class_depth (ctype) > 0)\n \t\tadd_friend (current_class_type, decl);\n \t      else\n-\t\tcp_error (ec_member_declared_as_friend_before_type_defined,\n+\t\tcp_error (\"member `%D' declared as friend before type `%T' defined\",\n \t\t\t  decl, ctype);\n \t    }\n \t}\n@@ -399,7 +399,7 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n \t  if (fields)\n \t    add_friends (current_class_type, declarator, ctype);\n \t  else\n-\t    cp_error (ec_method_is_not_a_member_of_class,\n+\t    cp_error (\"method `%D' is not a member of class `%T'\",\n \t\t      declarator, ctype);\n \t  decl = void_type_node;\n \t}\n@@ -452,14 +452,14 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n \t      && current_template_parms && uses_template_parms (decl))\n \t    {\n \t      static int explained;\n-\t      cp_warning (ec_friend_declaration, decl);\n-\t      cp_warning (ec_declares_a_nontemplate_function);\n+\t      cp_warning (\"friend declaration `%#D'\", decl);\n+\t      warning (\"  declares a non-template function\");\n \t      if (! explained)\n \t\t{\n-\t\t  cp_warning (ec_if_this_is_not_what_you_intended_make_sure);\n-\t\t  cp_warning (ec_the_function_template_has_already_been_declared);\n-\t\t  cp_warning (ec_and_add_after_the_function_name_here);\n- \t\t  cp_warning (ec_o_disable_warning_use_nonontemplatefriend);\n+\t\t  warning (\"  (if this is not what you intended, make sure\");\n+\t\t  warning (\"  the function template has already been declared,\");\n+\t\t  warning (\"  and add <> after the function name here)\");\n+ \t\t  warning (\"  To disable warning use -Wno-non-template-friend\");\n \t\t  explained = 1;\n \t\t}\n \t    }\n@@ -477,7 +477,7 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n       tree decl = lookup_name_nonclass (declarator);\n       if (decl == NULL_TREE)\n \t{\n-\t  cp_warning (ec_implicitly_declaring_as_struct, declarator);\n+\t  cp_warning (\"implicitly declaring `%T' as struct\", declarator);\n \t  decl = xref_tag (record_type_node, declarator, 1);\n \t  decl = TYPE_MAIN_DECL (decl);\n \t}\n@@ -486,7 +486,7 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n \t but not if those functions are really class names.  */\n       if (TREE_CODE (decl) == TREE_LIST && TREE_TYPE (TREE_PURPOSE (decl)))\n \t{\n-\t  cp_warning (ec_friend_archaic_use_friend_class_instead,\n+\t  cp_warning (\"`friend %T' archaic, use `friend class %T' instead\",\n \t\t      declarator, declarator);\n \t  decl = TREE_TYPE (TREE_PURPOSE (decl));\n \t}"}, {"sha": "0c15675c736003230fbbe67240f800b45ba11d6c", "filename": "gcc/cp/init.c", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -190,7 +190,7 @@ perform_member_init (member, name, init, explicit)\n \t\tinit = build (CONSTRUCTOR, type, NULL_TREE, NULL_TREE);\n \t      else if (TREE_CODE (type) == REFERENCE_TYPE)\n \t\t{\n-\t\t  cp_error (ec_defaultinitialization_of_which_has_reference_type,\n+\t\t  cp_error (\"default-initialization of `%#D', which has reference type\",\n \t\t\t    member);\n \t\t  init = error_mark_node;\n \t\t}\n@@ -199,15 +199,15 @@ perform_member_init (member, name, init, explicit)\n \t    }\n \t  /* member traversal: note it leaves init NULL */\n \t  else if (TREE_CODE (TREE_TYPE (member)) == REFERENCE_TYPE)\n-\t    cp_pedwarn (ec_uninitialized_reference_member, member);\n+\t    cp_pedwarn (\"uninitialized reference member `%D'\", member);\n \t}\n       else if (TREE_CODE (init) == TREE_LIST)\n \t{\n \t  /* There was an explicit member initialization.  Do some\n \t     work in that case.  */\n \t  if (TREE_CHAIN (init))\n \t    {\n-\t      cp_warning (ec_initializer_list_treated_as_compound_expression);\n+\t      warning (\"initializer list treated as compound expression\");\n \t      init = build_compound_expr (init);\n \t    }\n \t  else\n@@ -298,9 +298,9 @@ sort_member_init (t)\n \t\t{\n \t\t  if (pos < last_pos)\n \t\t    {\n-\t\t      cp_warning_at (ec_member_initializers_for, last_field);\n-\t\t      cp_warning_at (ec_and, field);\n-\t\t      cp_warning (ec_will_be_reordered_to_match_declaration_order);\n+\t\t      cp_warning_at (\"member initializers for `%#D'\", last_field);\n+\t\t      cp_warning_at (\"  and `%#D'\", field);\n+\t\t      warning (\"  will be re-ordered to match declaration order\");\n \t\t    }\n \t\t  last_pos = pos;\n \t\t  last_field = field;\n@@ -329,7 +329,7 @@ sort_member_init (t)\n \t{\n \t  if (purpose_member (name, init_list))\n \t    {\n-\t      cp_error (ec_multiple_initializations_given_for_member,\n+\t      cp_error (\"multiple initializations given for member `%D'\",\n \t\t\tIDENTIFIER_CLASS_VALUE (name));\n \t      continue;\n \t    }\n@@ -377,13 +377,13 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n \t  switch (n_baseclasses)\n \t    {\n \t    case 0:\n-\t      cp_error (ec_does_not_have_a_base_class_to_initialize,\n+\t      cp_error (\"`%T' does not have a base class to initialize\",\n \t\t\tcurrent_class_type);\n \t      return;\n \t    case 1:\n \t      break;\n \t    default:\n-\t      cp_error (ec_unnamed_initializer_ambiguous_for_which_uses_multiple_inheritance,\n+\t      cp_error (\"unnamed initializer ambiguous for `%T' which uses multiple inheritance\",\n \t\t\tcurrent_class_type);\n \t      return;\n \t    }\n@@ -415,7 +415,7 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n \t\t  break;\n \t      if (i < 0)\n \t\t{\n-\t\t  cp_error (ec_is_not_an_immediate_base_class_of,\n+\t\t  cp_error (\"`%T' is not an immediate base class of `%T'\",\n \t\t\t    basetype, current_class_type);\n \t\t  continue;\n \t\t}\n@@ -453,9 +453,9 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n \t\t{\n \t\t  if (pos < last_pos)\n \t\t    {\n-\t\t      cp_warning_at (ec_base_initializers_for, last_base);\n-\t\t      cp_warning_at (ec_and, BINFO_TYPE (binfo));\n-\t\t      cp_warning (ec_will_be_reordered_to_match_inheritance_order);\n+\t\t      cp_warning_at (\"base initializers for `%#T'\", last_base);\n+\t\t      cp_warning_at (\"  and `%#T'\", BINFO_TYPE (binfo));\n+\t\t      warning (\"  will be re-ordered to match inheritance order\");\n \t\t    }\n \t\t  last_pos = pos;\n \t\t  last_base = BINFO_TYPE (binfo);\n@@ -578,7 +578,7 @@ emit_base_init (t, immediately)\n \t{\n \t  init = NULL_TREE;\n \t  if (extra_warnings && copy_args_p (current_function_decl))\n-\t    cp_warning (ec_base_class_should_be_explicitly_initialized_in_the_copy_constructor,\n+\t    cp_warning (\"base class `%#T' should be explicitly initialized in the copy constructor\",\n \t\t\tBINFO_TYPE (base_binfo));\n \t}\n \n@@ -658,7 +658,7 @@ emit_base_init (t, immediately)\n \t  if (warn_ecpp && init == NULL_TREE\n \t      && !DECL_ARTIFICIAL (member)\n \t      && TREE_CODE (TREE_TYPE (member)) != ARRAY_TYPE)\n-\t    cp_warning (ec_should_be_initialized_in_the_member_initialization_list, member);\t    \n+\t    cp_warning (\"`%D' should be initialized in the member initialization list\", member);\t    \n \t}\n \n       perform_member_init (member, name, init, from_init_list);\n@@ -683,7 +683,7 @@ emit_base_init (t, immediately)\n \t    {\n \t      field = TREE_VALUE (field);\n \t      if (decl_type_context (field) != current_class_type)\n-\t\tcp_error (ec_field_not_in_immediate_context, field);\n+\t\tcp_error (\"field `%D' not in immediate context\", field);\n \t    }\n \n #if 0\n@@ -731,7 +731,7 @@ check_base_init (t)\n   tree member;\n   for (member = TYPE_FIELDS (t); member; member = TREE_CHAIN (member))\n     if (DECL_NAME (member) && TREE_USED (member))\n-      cp_error (ec_field_used_before_initialized_after_assignment_to_this,\n+      cp_error (\"field `%D' used before initialized (after assignment to `this')\",\n \t\tmember);\n }\n \n@@ -855,13 +855,13 @@ member_init_ok_or_else (field, type, member_name)\n     return 0;\n   if (field == NULL_TREE || initializing_context (field) != type)\n     {\n-      cp_error (ec_class_does_not_have_any_field_named_s, type,\n+      cp_error (\"class `%T' does not have any field named `%s'\", type,\n \t\tmember_name);\n       return 0;\n     }\n   if (TREE_STATIC (field))\n     {\n-      cp_error (ec_field_is_static_only_point_of_initialization_is_its_declaration,\n+      cp_error (\"field `%#D' is static; only point of initialization is its declaration\",\n \t\tfield);\n       return 0;\n     }\n@@ -907,14 +907,14 @@ expand_member_init (exp, name, init)\n     switch (CLASSTYPE_N_BASECLASSES (type))\n       {\n       case 0:\n-\tcp_error (ec_base_class_initializer_specified_but_no_base_class_to_initialize);\n+\terror (\"base class initializer specified, but no base class to initialize\");\n \treturn;\n       case 1:\n \tbasetype = TYPE_BINFO_BASETYPE (type, 0);\n \tbreak;\n       default:\n-\tcp_error (ec_initializer_for_unnamed_base_class_ambiguous);\n-\tcp_error (ec_type_uses_multiple_inheritance, type);\n+\terror (\"initializer for unnamed base class ambiguous\");\n+\tcp_error (\"(type `%T' uses multiple inheritance)\", type);\n \treturn;\n       }\n \n@@ -940,7 +940,7 @@ expand_member_init (exp, name, init)\n \t    name = TYPE_IDENTIFIER (basetype);\n \t  else\n \t    {\n-\t      cp_error (ec_no_base_class_to_initialize);\n+\t      error (\"no base class to initialize\");\n \t      return;\n \t    }\n #endif\n@@ -954,24 +954,24 @@ expand_member_init (exp, name, init)\n \t  if (IDENTIFIER_CLASS_VALUE (name))\n \t    goto try_member;\n \t  if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n-\t    cp_error (ec_type_is_not_an_immediate_or_virtual_basetype_for,\n+\t    cp_error (\"type `%T' is not an immediate or virtual basetype for `%T'\",\n \t\t      basetype, type);\n \t  else\n-\t    cp_error (ec_type_is_not_an_immediate_basetype_for,\n+\t    cp_error (\"type `%T' is not an immediate basetype for `%T'\",\n \t\t      basetype, type);\n \t  return;\n \t}\n \n       if (purpose_member (basetype, current_base_init_list))\n \t{\n-\t  cp_error (ec_base_class_already_initialized, basetype);\n+\t  cp_error (\"base class `%T' already initialized\", basetype);\n \t  return;\n \t}\n \n       if (warn_reorder && current_member_init_list)\n \t{\n-\t  cp_warning (ec_base_initializer_for, basetype);\n-\t  cp_warning (ec_will_be_reordered_to_precede_member_initializations);\n+\t  cp_warning (\"base initializer for `%T'\", basetype);\n+\t  warning (\"   will be re-ordered to precede member initializations\");\n \t}\n \n       base_init = build_tree_list (basetype, init);\n@@ -989,7 +989,7 @@ expand_member_init (exp, name, init)\n \n       if (purpose_member (name, current_member_init_list))\n \t{\n-\t  cp_error (ec_field_already_initialized, field);\n+\t  cp_error (\"field `%D' already initialized\", field);\n \t  return;\n \t}\n \n@@ -1080,7 +1080,7 @@ expand_aggr_init (exp, init, alias_this, flags)\n \t       COMPLEX zees(1.0, 0.0)[10];\n \t     }\n \t  */\n-\t  cp_error (ec_bad_array_initializer);\n+\t  error (\"bad array initializer\");\n \t  return;\n \t}\n       expand_vec_init (exp, exp, array_type_nelts (type), init,\n@@ -1268,7 +1268,7 @@ is_aggr_typedef (name, or_else)\n   else\n     {\n       if (or_else)\n-\tcp_error (ec_is_not_an_aggregate_typedef, name);\n+\tcp_error (\"`%T' is not an aggregate typedef\", name);\n       return 0;\n     }\n \n@@ -1277,7 +1277,7 @@ is_aggr_typedef (name, or_else)\n       && TREE_CODE (type) != TEMPLATE_TEMPLATE_PARM)\n     {\n       if (or_else)\n-\tcp_error (ec_is_not_an_aggregate_type, type);\n+\tcp_error (\"`%T' is not an aggregate type\", type);\n       return 0;\n     }\n   return 1;\n@@ -1299,7 +1299,7 @@ is_aggr_type (type, or_else)\n       && TREE_CODE (type) != TEMPLATE_TEMPLATE_PARM)\n     {\n       if (or_else)\n-\tcp_error (ec_is_not_an_aggregate_type, type);\n+\tcp_error (\"`%T' is not an aggregate type\", type);\n       return 0;\n     }\n   return 1;\n@@ -1322,7 +1322,7 @@ get_aggr_from_typedef (name, or_else)\n   else\n     {\n       if (or_else)\n-\tcp_error (ec_fails_to_be_an_aggregate_typedef, name);\n+\tcp_error (\"`%T' fails to be an aggregate typedef\", name);\n       return NULL_TREE;\n     }\n \n@@ -1331,7 +1331,7 @@ get_aggr_from_typedef (name, or_else)\n       && TREE_CODE (type) != TEMPLATE_TEMPLATE_PARM)\n     {\n       if (or_else)\n-\tcp_error (ec_type_is_of_nonaggregate_type, type);\n+\tcp_error (\"type `%T' is of non-aggregate type\", type);\n       return NULL_TREE;\n     }\n   return type;\n@@ -1415,7 +1415,7 @@ build_member_call (type, name, parmlist)\n \n   if (dtor)\n     {\n-      cp_error (ec_cannot_call_destructor_without_object, type,\n+      cp_error (\"cannot call destructor `%T::~%T' without object\", type,\n \t\tmethod_name);\n       return error_mark_node;\n     }\n@@ -1470,7 +1470,7 @@ build_member_call (type, name, parmlist)\n \t{\n \t  if (dont_use_this)\n \t    {\n-\t      cp_error (ec_invalid_use_of_nonstatic_field, t);\n+\t      cp_error (\"invalid use of non-static field `%D'\", t);\n \t      return error_mark_node;\n \t    }\n \t  decl = build (COMPONENT_REF, TREE_TYPE (t), decl, t);\n@@ -1479,7 +1479,7 @@ build_member_call (type, name, parmlist)\n \tdecl = t;\n       else\n \t{\n-\t  cp_error (ec_invalid_use_of_member, t);\n+\t  cp_error (\"invalid use of member `%D'\", t);\n \t  return error_mark_node;\n \t}\n       if (TYPE_LANG_SPECIFIC (TREE_TYPE (decl)))\n@@ -1489,7 +1489,7 @@ build_member_call (type, name, parmlist)\n     }\n   else\n     {\n-      cp_error (ec_no_method, type, name);\n+      cp_error (\"no method `%T::%D'\", type, name);\n       return error_mark_node;\n     }\n }\n@@ -1555,7 +1555,7 @@ build_offset_ref (type, name)\n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n       if (! check_dtor_name (type, name))\n-\tcp_error (ec_qualified_type_does_not_match_destructor_name,\n+\tcp_error (\"qualified type `%T' does not match destructor name `~%T'\",\n \t\t  type, TREE_OPERAND (name, 0));\n       name = dtor_identifier;\n     }\n@@ -1574,7 +1574,7 @@ build_offset_ref (type, name)\n \tt = NULL_TREE;\n       if (t == 0)\n \t{\n-\t  cp_error (ec_incomplete_type_does_not_have_member, type,\n+\t  cp_error (\"incomplete type `%T' does not have member `%D'\", type,\n \t\t      name);\n \t  return error_mark_node;\n \t}\n@@ -1652,14 +1652,14 @@ build_offset_ref (type, name)\n \t  access = compute_access (basebinfo, t);\n \t  if (access == access_protected_node)\n \t    {\n-\t      cp_error_at (ec_member_function_is_protected, t);\n-\t      cp_error (ec_in_this_context);\n+\t      cp_error_at (\"member function `%#D' is protected\", t);\n+\t      error (\"in this context\");\n \t      return error_mark_node;\n \t    }\n \t  if (access == access_private_node)\n \t    {\n-\t      cp_error_at (ec_member_function_is_private, t);\n-\t      cp_error (ec_in_this_context);\n+\t      cp_error_at (\"member function `%#D' is private\", t);\n+\t      error (\"in this context\");\n \t      return error_mark_node;\n \t    }\n \t  mark_used (t);\n@@ -1693,7 +1693,7 @@ build_offset_ref (type, name)\n \n   if (t == NULL_TREE)\n     {\n-      cp_error (ec_is_not_a_member_of_type, name, type);\n+      cp_error (\"`%D' is not a member of type `%T'\", name, type);\n       return error_mark_node;\n     }\n \n@@ -1712,7 +1712,7 @@ build_offset_ref (type, name)\n \n   if (TREE_CODE (t) == FIELD_DECL && DECL_BIT_FIELD (t))\n     {\n-      cp_error (ec_illegal_pointer_to_bit_field, t);\n+      cp_error (\"illegal pointer to bit field `%D'\", t);\n       return error_mark_node;\n     }\n \n@@ -1741,7 +1741,7 @@ resolve_offset_ref (exp)\n \n   if (TREE_CODE (exp) == TREE_LIST)\n     {\n-      cp_pedwarn (ec_assuming_on_overloaded_member_function);\n+      cp_pedwarn (\"assuming & on overloaded member function\");\n       return build_unary_op (ADDR_EXPR, exp, 0);\n     }\n \n@@ -1755,7 +1755,7 @@ resolve_offset_ref (exp)\n       my_friendly_assert (TREE_CODE (type) == OFFSET_TYPE, 214);\n       if (TYPE_OFFSET_BASETYPE (type) != current_class_type)\n \t{\n-\t  cp_error (ec_object_missing_in_use_of_pointertomember_construct);\n+\t  error (\"object missing in use of pointer-to-member construct\");\n \t  return error_mark_node;\n \t}\n       member = exp;\n@@ -1784,9 +1784,9 @@ resolve_offset_ref (exp)\n     {\n       if (TREE_ADDRESSABLE (member) == 0)\n \t{\n-\t  cp_error_at (ec_member_is_nonstatic_but_referenced_as_a_static_member,\n+\t  cp_error_at (\"member `%D' is non-static but referenced as a static member\",\n \t\t       member);\n-\t  cp_error (ec_at_this_point_in_file);\n+\t  error (\"at this point in file\");\n \t  TREE_ADDRESSABLE (member) = 1;\n \t}\n       return error_mark_node;\n@@ -1822,11 +1822,11 @@ resolve_offset_ref (exp)\n       /* Issue errors if there was an access violation.  */\n       if (access != access_public_node)\n \t{\n-\t  cp_error_at (ec_member_is_s, \n+\t  cp_error_at (\"member `%D' is %s\", \n \t\t       access == access_private_node \n \t\t       ? \"private\" : \"protected\",\n \t\t       member);\n-\t  cp_error (ec_in_this_context);\n+\t  cp_error (\"in this context\");\n \t} \n \n       /* Even in the case of illegal access, we form the\n@@ -1852,7 +1852,7 @@ resolve_offset_ref (exp)\n     {\n       if (addr == error_mark_node)\n \t{\n-\t  cp_error (ec_object_missing_in, exp);\n+\t  cp_error (\"object missing in `%E'\", exp);\n \t  return error_mark_node;\n \t}\n \n@@ -2012,7 +2012,7 @@ build_new (placement, decl, init, use_global_new)\n \t  if (this_nelts != error_mark_node)\n \t    {\n \t      if (this_nelts == NULL_TREE)\n-\t\tcp_error (ec_new_of_array_type_fails_to_specify_size);\n+\t\terror (\"new of array type fails to specify size\");\n \t      else if (processing_template_decl)\n \t\t{\n \t\t  nelts = this_nelts;\n@@ -2024,7 +2024,7 @@ build_new (placement, decl, init, use_global_new)\n \t\t  absdcl = TREE_OPERAND (absdcl, 0);\n \t          if (this_nelts == integer_zero_node)\n \t\t    {\n-\t\t      cp_warning (ec_zero_size_array_reserves_no_space);\n+\t\t      warning (\"zero size array reserves no space\");\n \t\t      nelts = integer_zero_node;\n \t\t    }\n \t\t  else\n@@ -2099,13 +2099,13 @@ build_new (placement, decl, init, use_global_new)\n      returned by new.'' ARM 5.3.3 */\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n-      cp_error (ec_new_cannot_be_applied_to_a_reference_type);\n+      error (\"new cannot be applied to a reference type\");\n       type = TREE_TYPE (type);\n     }\n \n   if (TREE_CODE (type) == FUNCTION_TYPE)\n     {\n-      cp_error (ec_new_cannot_be_applied_to_a_function_type);\n+      error (\"new cannot be applied to a function type\");\n       return error_mark_node;\n     }\n \n@@ -2232,7 +2232,7 @@ build_new_1 (exp)\n \n   if (TREE_CODE (true_type) == VOID_TYPE)\n     {\n-      cp_error (ec_invalid_type_void_for_new);\n+      error (\"invalid type `void' for new\");\n       return error_mark_node;\n     }\n \n@@ -2276,7 +2276,7 @@ build_new_1 (exp)\n       code = VEC_NEW_EXPR;\n \n       if (init && pedantic)\n-\tcp_pedwarn (ec_initialization_in_array_new);\n+\tcp_pedwarn (\"initialization in array new\");\n     }\n \n   /* Allocate the object.  */\n@@ -2288,7 +2288,7 @@ build_new_1 (exp)\n \trval = NULL_TREE;\n       else\n \t{\n-\t  cp_error (ec_constructors_take_parameter_lists);\n+\t  error (\"constructors take parameter lists\");\n \t  return error_mark_node;\n \t}\n     }\n@@ -2405,10 +2405,10 @@ build_new_1 (exp)\n \t  TREE_READONLY (deref) = 0;\n \n \t  if (TREE_CHAIN (init) != NULL_TREE)\n-\t    cp_pedwarn (ec_initializer_list_being_treated_as_compound_expression);\n+\t    pedwarn (\"initializer list being treated as compound expression\");\n \t  else if (TREE_CODE (init) == CONSTRUCTOR)\n \t    {\n-\t      cp_pedwarn (ec_initializer_list_appears_where_operand_should_be_used);\n+\t      pedwarn (\"initializer list appears where operand should be used\");\n \t      init = TREE_OPERAND (init, 1);\n \t    }\n \t  init = build_compound_expr (init);\n@@ -2533,7 +2533,7 @@ build_new_1 (exp)\n \t}\n     }\n   else if (TYPE_READONLY (true_type))\n-    cp_error (ec_uninitialized_const_in_new_of, true_type);\n+    cp_error (\"uninitialized const in `new' of `%#T'\", true_type);\n \n  done:\n \n@@ -2856,7 +2856,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t\t   && TYPE_NEEDS_CONSTRUCTING (type)\n \t\t   && ! TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n \t    {\n-\t      cp_error (ec_initializer_ends_prematurely);\n+\t      error (\"initializer ends prematurely\");\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -3047,7 +3047,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \taddr = save_expr (addr);\n       if (TYPE_DOMAIN (type) == NULL_TREE)\n \t{\n-\t  cp_error (ec_unknown_array_size_in_delete);\n+\t  error (\"unknown array size in delete\");\n \t  return error_mark_node;\n \t}\n       return build_vec_delete (addr, array_type_nelts (type),\n@@ -3295,7 +3295,7 @@ build_vec_delete (base, maxindex, auto_delete_vec, auto_delete,\n   else\n     {\n       if (base != error_mark_node)\n-\tcp_error (ec_type_to_vector_delete_is_neither_pointer_or_array_type);\n+\terror (\"type to vector delete is neither pointer or array type\");\n       return error_mark_node;\n     }\n "}, {"sha": "32f5ff9050928baf41e9457f9e22169ccdc7b7fa", "filename": "gcc/cp/lang-options.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-options.h?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -101,8 +101,6 @@ DEFINE_LANG_NAME (\"C++\")\n   { \"-fno-weak\", \"\" },\n   { \"-fxref\", \"Emit cross referencing information\" },\n   { \"-fno-xref\", \"\" },\n-  { \"-fdiag-codes\", \"Show code numbers when printing diagnostics\" },\n-  { \"-fno-diag-codes\", \"\" },\n \n   { \"-Wreturn-type\", \"Warn about inconsistent return types\" },\n   { \"-Wno-return-type\", \"\" },\n@@ -128,6 +126,4 @@ DEFINE_LANG_NAME (\"C++\")\n   { \"-Wno-old-style-cast\", \"\" },\n   { \"-Wnon-template-friend\", \"\" }, \n   { \"-Wno-non-template-friend\", \"Don't warn when non-templatized friend functions are declared within a template\" },\n-  { \"-Wnumber-\" },\n-  { \"-Wno-number-\" },\n "}, {"sha": "e2ab945a0cdc2b768b5a539f5ff3f32b792927b9", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 97, "deletions": 97, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -186,7 +186,7 @@ make_pointer_declarator (cv_qualifiers, target)\n {\n   if (target && TREE_CODE (target) == IDENTIFIER_NODE\n       && ANON_AGGRNAME_P (target))\n-    cp_error (ec_type_name_expected_before_star);\n+    error (\"type name expected before `*'\");\n   target = build_parse_node (INDIRECT_REF, target);\n   TREE_TYPE (target) = cv_qualifiers;\n   return target;\n@@ -208,16 +208,16 @@ make_reference_declarator (cv_qualifiers, target)\n     {\n       if (TREE_CODE (target) == ADDR_EXPR)\n \t{\n-\t  cp_error (ec_cannot_declare_references_to_references);\n+\t  error (\"cannot declare references to references\");\n \t  return target;\n \t}\n       if (TREE_CODE (target) == INDIRECT_REF)\n \t{\n-\t  cp_error (ec_cannot_declare_pointers_to_references);\n+\t  error (\"cannot declare pointers to references\");\n \t  return target;\n \t}\n       if (TREE_CODE (target) == IDENTIFIER_NODE && ANON_AGGRNAME_P (target))\n-\t  cp_error (ec_type_name_expected_before_amp);\n+\t  error (\"type name expected before `&'\");\n     }\n   target = build_parse_node (ADDR_EXPR, target);\n   TREE_TYPE (target) = cv_qualifiers;\n@@ -1082,7 +1082,7 @@ set_yydebug (value)\n   extern int yydebug;\n   yydebug = value;\n #else\n-  cp_warning (ec_yydebug_not_defined);\n+  warning (\"YYDEBUG not defined.\");\n #endif\n }\n \n@@ -1293,7 +1293,7 @@ process_next_inline (t)\n     yychar = yylex ();\n   if (yychar != END_OF_SAVED_INPUT)\n     {\n-      cp_error (ec_parse_error_at_end_of_saved_function_text);\n+      error (\"parse error at end of saved function text\");\n \n       /* restore_pending_input will abort unless yychar is either\n          END_OF_SAVED_INPUT or YYEMPTY; since we already know we're\n@@ -1350,9 +1350,9 @@ consume_string (this_obstack, matching_char)\n \t  int save_lineno = lineno;\n \t  lineno = starting_lineno;\n \t  if (matching_char == '\"')\n-\t    cp_error (ec_end_of_file_encountered_inside_string_constant);\n+\t    error (\"end of file encountered inside string constant\");\n \t  else\n-\t    cp_error (ec_end_of_file_encountered_inside_character_constant);\n+\t    error (\"end of file encountered inside character constant\");\n \t  lineno = save_lineno;\n \t  return;\n \t}\n@@ -1369,7 +1369,7 @@ consume_string (this_obstack, matching_char)\n       if (c == '\\n')\n \t{\n \t  if (pedantic)\n-\t    cp_pedwarn (ec_forbids_newline_in_string_constant);\n+\t    pedwarn (\"ANSI C++ forbids newline in string constant\");\n \t  lineno++;\n \t}\n       obstack_1grow (this_obstack, c);\n@@ -1660,7 +1660,7 @@ reinit_parse_for_block (pyychar, obstackp)\n \t    {\n \t      if (look_for_lbrac)\n \t\t{\n-\t\t  cp_error (ec_function_body_for_constructor_missing);\n+\t\t  error (\"function body for constructor missing\");\n \t\t  obstack_1grow (obstackp, '{');\n \t\t  obstack_1grow (obstackp, '}');\n \t\t  len += 2;\n@@ -1877,7 +1877,7 @@ finish_defarg ()\n     yychar = yylex ();\n   if (yychar != END_OF_SAVED_INPUT)\n     {\n-      cp_error (ec_parse_error_at_end_of_saved_function_text);\n+      error (\"parse error at end of saved function text\");\n \n       /* restore_pending_input will abort unless yychar is either\n          END_OF_SAVED_INPUT or YYEMPTY; since we already know we're\n@@ -2105,10 +2105,10 @@ check_for_missing_semicolon (type)\n       || end_of_file)\n     {\n       if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (type)))\n-\tcp_error (ec_semicolon_missing_after_s_declaration,\n+\terror (\"semicolon missing after %s declaration\",\n \t       TREE_CODE (type) == ENUMERAL_TYPE ? \"enum\" : \"struct\");\n       else\n-\tcp_error (ec_semicolon_missing_after_declaration_of, type);\n+\tcp_error (\"semicolon missing after declaration of `%T'\", type);\n       shadow_tag (build_tree_list (0, type));\n     }\n   /* Could probably also hack cases where class { ... } f (); appears.  */\n@@ -2171,7 +2171,7 @@ skip_white_space (c)\n \t  if (c == '\\n')\n \t    lineno++;\n \t  else\n-\t    cp_error (ec_stray_in_program);\n+\t    error (\"stray '\\\\' in program\");\n \t  c = getch ();\n \t  break;\n \n@@ -2328,7 +2328,7 @@ check_newline ()\n \t\t an explcit -Wunknown-pragmas has been given. */\n \t      if (warn_unknown_pragmas > 1\n \t\t  || (warn_unknown_pragmas && ! in_system_header))\n-\t\tcp_warning (ec_ignoring_pragma_s, token_buffer);\n+\t\twarning (\"ignoring pragma: %s\", token_buffer);\n \t    }\n \t  \n \t  goto skipline;\n@@ -2385,7 +2385,7 @@ check_newline ()\n \t      if (token != STRING\n \t\t  || TREE_CODE (yylval.ttype) != STRING_CST)\n \t\t{\n-\t\t  cp_error (ec_invalid_ident);\n+\t\t  error (\"invalid #ident\");\n \t\t  goto skipline;\n \t\t}\n \n@@ -2417,7 +2417,7 @@ check_newline ()\n \t      goto skipline;\n \t    }\n \t}\n-      cp_error (ec_undefined_or_invalid_directive);\n+      error (\"undefined or invalid # directive\");\n       goto skipline;\n     }\n \n@@ -2468,7 +2468,7 @@ check_newline ()\n \n       if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n \t{\n-\t  cp_error (ec_invalid_line);\n+\t  error (\"invalid #line\");\n \t  goto skipline;\n \t}\n \n@@ -2610,7 +2610,7 @@ check_newline ()\n \t\t  if (c_header_level && --c_header_level == 0)\n \t\t    {\n \t\t      if (entering_c_header)\n-\t\t\tcp_warning (ec_badly_nested_headers_from_preprocessor);\n+\t\t\twarning (\"badly nested C headers from preprocessor\");\n \t\t      --pending_lang_change;\n \t\t    }\n \t\t  in_system_header = entering_system_header;\n@@ -2622,7 +2622,7 @@ check_newline ()\n \t\t  debug_end_source_file (input_file_stack->line);\n \t\t}\n \t      else\n-\t\tcp_error (ec_lines_for_entering_and_leaving_files_dont_match);\n+\t\terror (\"#-lines for entering and leaving files don't match\");\n \t    }\n \t  else\n \t    in_system_header = entering_system_header;\n@@ -2633,7 +2633,7 @@ check_newline ()\n \tc = EOF;\n     }\n   else\n-    cp_error (ec_invalid_line);\n+    error (\"invalid #-line\");\n \n   /* skip the rest of this line.  */\n  skipline:\n@@ -2698,15 +2698,15 @@ readescape (ignore_ptr)\n \t  nonnull = 1;\n \t}\n       if (! nonnull)\n-\tcp_error (ec_x_used_with_no_following_hex_digits);\n+\terror (\"\\\\x used with no following hex digits\");\n       else if (count == 0)\n \t/* Digits are all 0's.  Ok.  */\n \t;\n       else if ((count - 1) * 4 >= TYPE_PRECISION (integer_type_node)\n \t       || (count > 1\n \t\t   && ((1 << (TYPE_PRECISION (integer_type_node) - (count - 1) * 4))\n \t\t       <= firstdig)))\n-\tcp_pedwarn (ec_hex_escape_out_of_range);\n+\tpedwarn (\"hex escape out of range\");\n       return code;\n \n     case '0':  case '1':  case '2':  case '3':  case '4':\n@@ -2753,7 +2753,7 @@ readescape (ignore_ptr)\n     case 'e':\n     case 'E':\n       if (pedantic)\n-\tcp_pedwarn (ec_nonstandard_escape_sequence_c, c);\n+\tpedwarn (\"non-ANSI-standard escape sequence, `\\\\%c'\", c);\n       return 033;\n \n     case '?':\n@@ -2766,13 +2766,13 @@ readescape (ignore_ptr)\n       /* `\\%' is used to prevent SCCS from getting confused.  */\n     case '%':\n       if (pedantic)\n-\tcp_pedwarn (ec_unknown_escape_sequence_c, c);\n+\tpedwarn (\"unknown escape sequence `\\\\%c'\", c);\n       return c;\n     }\n   if (c >= 040 && c < 0177)\n-    cp_pedwarn (ec_unknown_escape_sequence_c, c);\n+    pedwarn (\"unknown escape sequence `\\\\%c'\", c);\n   else\n-    cp_pedwarn (ec_unknown_escape_sequence_followed_by_char_code_0xx, c);\n+    pedwarn (\"unknown escape sequence: `\\\\' followed by char code 0x%x\", c);\n   return c;\n }\n \n@@ -2899,7 +2899,7 @@ do_identifier (token, parsing, args)\n \tmy_friendly_abort (61);\n       else\n \t{\n-\t  cp_error (ec_invalid_use_of_member_from_base_class, field,\n+\t  cp_error (\"invalid use of member `%D' from base class `%T'\", field,\n \t\t      DECL_FIELD_CONTEXT (field));\n \t  id = error_mark_node;\n \t  return id;\n@@ -2943,7 +2943,7 @@ do_identifier (token, parsing, args)\n       else if (IDENTIFIER_OPNAME_P (token))\n \t{\n \t  if (token != ansi_opname[ERROR_MARK])\n-\t    cp_error (ec_not_defined, token);\n+\t    cp_error (\"`%D' not defined\", token);\n \t  id = error_mark_node;\n \t}\n       else if (in_call && ! flag_strict_prototype)\n@@ -2952,7 +2952,7 @@ do_identifier (token, parsing, args)\n \t}\n       else if (current_function_decl == 0)\n \t{\n-\t  cp_error (ec_was_not_declared_in_this_scope, token);\n+\t  cp_error (\"`%D' was not declared in this scope\", token);\n \t  id = error_mark_node;\n \t}\n       else\n@@ -2962,12 +2962,12 @@ do_identifier (token, parsing, args)\n \t    {\n \t      static int undeclared_variable_notice;\n \n-\t      cp_error (ec_undeclared_first_use_this_function, token);\n+\t      cp_error (\"`%D' undeclared (first use this function)\", token);\n \n \t      if (! undeclared_variable_notice)\n \t\t{\n-\t\t  cp_error (ec_ach_undeclared_identifier_is_reported_only_once);\n-\t\t  cp_error (ec_for_each_function_it_appears_in);\n+\t\t  error (\"(Each undeclared identifier is reported only once\");\n+\t\t  error (\"for each function it appears in.)\");\n \t\t  undeclared_variable_notice = 1;\n \t\t}\n \t    }\n@@ -2990,11 +2990,11 @@ do_identifier (token, parsing, args)\n \t{\n \t  if (!DECL_ERROR_REPORTED (id))\n \t    {\n-\t      cp_warning (ec_name_lookup_of_s_changed,\n+\t      warning (\"name lookup of `%s' changed\",\n \t\t       IDENTIFIER_POINTER (token));\n-\t      cp_warning_at (ec_matches_this_under_current_rules,\n+\t      cp_warning_at (\"  matches this `%D' under current ANSI rules\",\n \t\t\t     shadowed);\n-\t      cp_warning_at (ec_matches_this_under_old_rules, id);\n+\t      cp_warning_at (\"  matches this `%D' under old rules\", id);\n \t      DECL_ERROR_REPORTED (id) = 1;\n \t    }\n \t  id = shadowed;\n@@ -3007,13 +3007,13 @@ do_identifier (token, parsing, args)\n \t  if (TYPE_NEEDS_DESTRUCTOR (TREE_TYPE (id)))\n \t    {\n \t      error (msg, IDENTIFIER_POINTER (token));\n-\t      cp_error_at (ec_cannot_use_obsolete_binding_at_because_it_has_a_destructor, id);\n+\t      cp_error_at (\"  cannot use obsolete binding at `%D' because it has a destructor\", id);\n \t      id = error_mark_node;\n \t    }\n \t  else\n \t    {\n \t      pedwarn (msg, IDENTIFIER_POINTER (token));\n-\t      cp_pedwarn_at (ec_using_obsolete_binding_at, id);\n+\t      cp_pedwarn_at (\"  using obsolete binding at `%D'\", id);\n \t    }\n \t}\n     }\n@@ -3025,7 +3025,7 @@ do_identifier (token, parsing, args)\n \t  /* Check access.  */\n \t  tree access = compute_access (TYPE_BINFO (current_class_type), id);\n \t  if (access == access_private_node)\n-\t    cp_error (ec_enum_is_private, id);\n+\t    cp_error (\"enum `%D' is private\", id);\n \t  /* protected is OK, since it's an enum of `this'.  */\n \t}\n       if (!processing_template_decl\n@@ -3104,7 +3104,7 @@ do_scoped_id (token, parsing)\n       else\n \t{\n \t  if (IDENTIFIER_NAMESPACE_VALUE (token) != error_mark_node)\n-\t    cp_error (ec_undeclared_first_use_here, token);\n+\t    cp_error (\"`::%D' undeclared (first use here)\", token);\n \t  id = error_mark_node;\n \t  /* Prevent repeated error messages.  */\n \t  SET_IDENTIFIER_NAMESPACE_VALUE (token, error_mark_node);\n@@ -3226,9 +3226,9 @@ real_yylex ()\n \n     case '$':\n       if (! dollars_in_ident)\n-\tcp_error (ec_in_identifier);\n+\terror (\"`$' in identifier\");\n       else if (pedantic)\n-\tcp_pedwarn (ec_in_identifier);\n+\tpedwarn (\"`$' in identifier\");\n       dollar_seen = 1;\n       goto letter;\n \n@@ -3284,9 +3284,9 @@ real_yylex ()\n \t\tif (c == '$')\n \t\t  {\n \t\t    if (! dollars_in_ident)\n-\t\t      cp_error (ec_in_identifier);\n+\t\t      error (\"`$' in identifier\");\n \t\t    else if (pedantic)\n-\t\t      cp_pedwarn (ec_in_identifier);\n+\t\t      pedwarn (\"`$' in identifier\");\n \t\t  }\n \n \t\tif (p >= token_buffer + maxtoken)\n@@ -3314,9 +3314,9 @@ real_yylex ()\n \t\tif (c == '$')\n \t\t  {\n \t\t    if (! dollars_in_ident)\n-\t\t      cp_error (ec_in_identifier);\n+\t\t      error (\"`$' in identifier\");\n \t\t    else if (pedantic)\n-\t\t      cp_pedwarn (ec_in_identifier);\n+\t\t      pedwarn (\"`$' in identifier\");\n \t\t  }\n \n \t\tif (p >= token_buffer + maxtoken)\n@@ -3366,7 +3366,7 @@ real_yylex ()\n \t\t\t obstack.  */\n \n \t\t      if (ptr->rid != RID_EXTERN)\n-\t\t\tcp_error (ec_invalid_modifier_s_for_language_string,\n+\t\t\terror (\"invalid modifier `%s' for language string\",\n \t\t\t       ptr->name);\n \t\t      real_yylex ();\n \t\t      value = EXTERN_LANG_STRING;\n@@ -3465,7 +3465,7 @@ real_yylex ()\n \t\t    || TEMP_NAME_P (tmp)\n \t\t    || ANON_AGGRNAME_P (tmp)\n \t\t    || ANON_PARMNAME_P (tmp)))\n-\t      cp_warning (ec_identifier_name_s_conflicts_with_internal_naming_strategy,\n+\t      warning (\"identifier name `%s' conflicts with GNU C++ internal naming strategy\",\n \t\t       token_buffer);\n #endif\n \n@@ -3500,7 +3500,7 @@ real_yylex ()\n \t\tvalue = ELLIPSIS;\n \t\tgoto done;\n \t      }\n-\t    cp_error (ec_parse_error_at);\n+\t    error (\"parse error at `..'\");\n \t  }\n \tif (ISDIGIT (c1))\n \t  {\n@@ -3589,13 +3589,13 @@ real_yylex ()\n \t    if (c == '.')\n \t      {\n \t\tif (base == 16)\n-\t\t  cp_error (ec_floating_constant_may_not_be_in_radix_16);\n+\t\t  error (\"floating constant may not be in radix 16\");\n \t\tif (floatflag == TOO_MANY_POINTS)\n \t\t  /* We have already emitted an error.  Don't need another.  */\n \t\t  ;\n \t\telse if (floatflag == AFTER_POINT)\n \t\t  {\n-\t\t    cp_error (ec_malformed_floating_constant);\n+\t\t    error (\"malformed floating constant\");\n \t\t    floatflag = TOO_MANY_POINTS;\n \t\t    /* Avoid another error from atof by forcing all characters\n \t\t       from here on to be ignored.  */\n@@ -3622,7 +3622,7 @@ real_yylex ()\n \t\t\t    value = ELLIPSIS;\n \t\t\t    goto done;\n \t\t\t  }\n-\t\t\tcp_error (ec_parse_error_at);\n+\t\t\terror (\"parse error at `..'\");\n \t\t      }\n \t\t    nextchar = c;\n \t\t    token_buffer[1] = '\\0';\n@@ -3647,7 +3647,7 @@ real_yylex ()\n \t\t\tfloatflag = AFTER_POINT;\n \t\t\tbreak;   /* start of exponent */\n \t\t      }\n-\t\t    cp_error (ec_nondigits_in_number_and_not_hexadecimal);\n+\t\t    error (\"nondigits in number and not hexadecimal\");\n \t\t    c = 0;\n \t\t  }\n \t\telse if (c >= 'a')\n@@ -3688,10 +3688,10 @@ real_yylex ()\n \t  }\n \n \tif (numdigits == 0)\n-\t  cp_error (ec_numeric_constant_with_no_digits);\n+\t  error (\"numeric constant with no digits\");\n \n \tif (largest_digit >= base)\n-\t  cp_error (ec_numeric_constant_contains_digits_beyond_the_radix);\n+\t  error (\"numeric constant contains digits beyond the radix\");\n \n \t/* Remove terminating char from the token buffer and delimit the string */\n \t*--p = 0;\n@@ -3718,7 +3718,7 @@ real_yylex ()\n \t\t    c = getch ();\n \t\t  }\n \t\tif (! ISDIGIT (c))\n-\t\t  cp_error (ec_floating_constant_exponent_has_no_digits);\n+\t\t  error (\"floating constant exponent has no digits\");\n \t        while (ISDIGIT (c))\n \t\t  {\n \t\t    if (p >= token_buffer + maxtoken - 3)\n@@ -3734,7 +3734,7 @@ real_yylex ()\n \t    /* Convert string to a double, checking for overflow.  */\n \t    if (setjmp (handler))\n \t      {\n-\t\tcp_error (ec_floating_constant_out_of_range);\n+\t\terror (\"floating constant out of range\");\n \t\tvalue = dconst0;\n \t      }\n \t    else\n@@ -3757,21 +3757,21 @@ real_yylex ()\n \t\t      {\n \t\t      case 'f': case 'F':\n \t\t\tif (fflag)\n-\t\t\t  cp_error (ec_more_than_one_f_in_numeric_constant);\n+\t\t\t  error (\"more than one `f' in numeric constant\");\n \t\t\tfflag = 1;\n \t\t\tbreak;\n \n \t\t      case 'l': case 'L':\n \t\t\tif (lflag)\n-\t\t\t  cp_error (ec_more_than_one_l_in_numeric_constant);\n+\t\t\t  error (\"more than one `l' in numeric constant\");\n \t\t\tlflag = 1;\n \t\t\tbreak;\n \n \t\t      case 'i': case 'I':\n \t\t\tif (imag)\n-\t\t\t  cp_error (ec_more_than_one_i_or_j_in_numeric_constant);\n+\t\t\t  error (\"more than one `i' or `j' in numeric constant\");\n \t\t\telse if (pedantic)\n-\t\t\t  cp_pedwarn (ec_forbids_imaginary_numeric_constants);\n+\t\t\t  pedwarn (\"ANSI C++ forbids imaginary numeric constants\");\n \t\t\timag = 1;\n \t\t\tbreak;\n \n@@ -3796,28 +3796,28 @@ real_yylex ()\n \t\tif (fflag)\n \t\t  {\n \t\t    if (lflag)\n-\t\t      cp_error (ec_both_f_and_l_in_floating_constant);\n+\t\t      error (\"both `f' and `l' in floating constant\");\n \n \t\t    type = float_type_node;\n \t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n \t\t    /* A diagnostic is required here by some ANSI C testsuites.\n \t\t       This is not pedwarn, become some people don't want\n \t\t       an error for this.  */\n \t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n-\t\t      cp_warning (ec_floating_point_number_exceeds_range_of_float);\n+\t\t      warning (\"floating point number exceeds range of `float'\");\n \t\t  }\n \t\telse if (lflag)\n \t\t  {\n \t\t    type = long_double_type_node;\n \t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n \t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n-\t\t      cp_warning (ec_floating_point_number_exceeds_range_of_long_double);\n+\t\t      warning (\"floating point number exceeds range of `long double'\");\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    value = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n \t\t    if (REAL_VALUE_ISINF (value) && pedantic)\n-\t\t      cp_warning (ec_floating_point_number_exceeds_range_of_double);\n+\t\t      warning (\"floating point number exceeds range of `double'\");\n \t\t  }\n \n \t\tset_float_handler (NULL_PTR);\n@@ -3830,7 +3830,7 @@ real_yylex ()\n \t\tif (REAL_VALUES_LESS (dconst1, value)\n \t\t    || REAL_VALUES_LESS (value, dconstm1))\n \t\t  {\n-\t\t    cp_pedwarn (ec_floating_point_number_exceeds_range_of_s,\n+\t\t    pedwarn (\"floating point number exceeds range of `%s'\",\n \t\t\t     IDENTIFIER_POINTER (TYPE_IDENTIFIER (type)));\n \t\t    exceeds_double = 1;\n \t\t  }\n@@ -3866,27 +3866,27 @@ real_yylex ()\n \t\tif (c == 'u' || c == 'U')\n \t\t  {\n \t\t    if (spec_unsigned)\n-\t\t      cp_error (ec_two_us_in_integer_constant);\n+\t\t      error (\"two `u's in integer constant\");\n \t\t    spec_unsigned = 1;\n \t\t  }\n \t\telse if (c == 'l' || c == 'L')\n \t\t  {\n \t\t    if (spec_long)\n \t\t      {\n \t\t\tif (spec_long_long)\n-\t\t\t  cp_error (ec_three_ls_in_integer_constant);\n+\t\t\t  error (\"three `l's in integer constant\");\n \t\t\telse if (pedantic && ! in_system_header && warn_long_long)\n-\t\t\t  cp_pedwarn (ec_forbids_long_long_integer_constants);\n+\t\t\t  pedwarn (\"ANSI C++ forbids long long integer constants\");\n \t\t\tspec_long_long = 1;\n \t\t      }\n \t\t    spec_long = 1;\n \t\t  }\n \t\telse if (c == 'i' || c == 'j' || c == 'I' || c == 'J')\n \t\t  {\n \t\t    if (spec_imag)\n-\t\t      cp_error (ec_more_than_one_i_or_j_in_numeric_constant);\n+\t\t      error (\"more than one `i' or `j' in numeric constant\");\n \t\t    else if (pedantic)\n-\t\t      cp_pedwarn (ec_forbids_imaginary_numeric_constants);\n+\t\t      pedwarn (\"ANSI C++ forbids imaginary numeric constants\");\n \t\t    spec_imag = 1;\n \t\t  }\n \t\telse\n@@ -3917,7 +3917,7 @@ real_yylex ()\n \t      if (parts[i])\n \t\twarn = 1;\n \t    if (warn)\n-\t      cp_pedwarn (ec_integer_constant_out_of_range);\n+\t      pedwarn (\"integer constant out of range\");\n \n \t    /* This is simplified by the fact that our constant\n \t       is always positive.  */\n@@ -3958,10 +3958,10 @@ real_yylex ()\n \t      type = long_long_unsigned_type_node;\n \n \t    if (!int_fits_type_p (yylval.ttype, type) && !warn)\n-\t      cp_pedwarn (ec_integer_constant_out_of_range);\n+\t      pedwarn (\"integer constant out of range\");\n \n \t    if (base == 10 && ! spec_unsigned && TREE_UNSIGNED (type))\n-\t      cp_warning (ec_decimal_integer_constant_is_so_large_that_it_is_unsigned);\n+\t      warning (\"decimal integer constant is so large that it is unsigned\");\n \n \t    if (spec_imag)\n \t      {\n@@ -3972,7 +3972,7 @@ real_yylex ()\n \t\t\t\t     cp_convert (integer_type_node,\n \t\t\t\t\t\t yylval.ttype));\n \t\telse\n-\t\t  cp_error (ec_complex_integer_constant_is_too_wide_for_complex_int);\n+\t\t  error (\"complex integer constant is too wide for `__complex int'\");\n \t      }\n \t    else\n \t      TREE_TYPE (yylval.ttype) = type;\n@@ -4018,7 +4018,7 @@ real_yylex ()\n \t\t  goto tryagain;\n \t\tif (width < HOST_BITS_PER_INT\n \t\t    && (unsigned) c >= (1 << width))\n-\t\t  cp_pedwarn (ec_escape_sequence_out_of_range_for_character);\n+\t\t  pedwarn (\"escape sequence out of range for character\");\n #ifdef MAP_CHARACTER\n \t\tif (ISPRINT (c))\n \t\t  c = MAP_CHARACTER (c);\n@@ -4027,7 +4027,7 @@ real_yylex ()\n \t    else if (c == '\\n')\n \t      {\n \t\tif (pedantic)\n-\t\t  cp_pedwarn (ec_forbids_newline_in_character_constant);\n+\t\t  pedwarn (\"ANSI C forbids newline in character constant\");\n \t\tlineno++;\n \t      }\n \t    else\n@@ -4076,7 +4076,7 @@ real_yylex ()\n \t\telse\n \t\t  {\n \t\t    if (char_len == -1)\n-\t\t      cp_warning (ec_gnoring_invalid_multibyte_character);\n+\t\t      warning (\"Ignoring invalid multibyte character\");\n \t\t    if (wide_flag)\n \t\t      c = wc;\n #ifdef MAP_CHARACTER\n@@ -4110,16 +4110,16 @@ real_yylex ()\n \t  }\n \n \tif (c != '\\'')\n-\t  cp_error (ec_malformatted_character_constant);\n+\t  error (\"malformatted character constant\");\n \telse if (chars_seen == 0)\n-\t  cp_error (ec_empty_character_constant);\n+\t  error (\"empty character constant\");\n \telse if (num_chars > max_chars)\n \t  {\n \t    num_chars = max_chars;\n-\t    cp_error (ec_character_constant_too_long);\n+\t    error (\"character constant too long\");\n \t  }\n \telse if (chars_seen != 1 && warn_multichar)\n-\t  cp_warning (ec_multicharacter_character_constant);\n+\t  warning (\"multi-character character constant\");\n \n \t/* If char type is signed, sign-extend the constant.  */\n \tif (! wide_flag)\n@@ -4179,12 +4179,12 @@ real_yylex ()\n \t\t  goto skipnewline;\n \t\tif (width < HOST_BITS_PER_INT\n \t\t    && (unsigned) c >= (1 << width))\n-\t\t  cp_warning (ec_escape_sequence_out_of_range_for_character);\n+\t\t  warning (\"escape sequence out of range for character\");\n \t      }\n \t    else if (c == '\\n')\n \t      {\n \t\tif (pedantic)\n-\t\t  cp_pedwarn (ec_forbids_newline_in_string_constant);\n+\t\t  pedwarn (\"ANSI C++ forbids newline in string constant\");\n \t\tlineno++;\n \t      }\n \t    else\n@@ -4205,7 +4205,7 @@ real_yylex ()\n \t\t    c = getch ();\n \t\t  }\n \t\tif (char_len == -1)\n-\t\t  cp_warning (ec_gnoring_invalid_multibyte_character);\n+\t\t  warning (\"Ignoring invalid multibyte character\");\n \t\telse\n \t\t  {\n \t\t    /* mbtowc sometimes needs an extra char before accepting */\n@@ -4259,7 +4259,7 @@ real_yylex ()\n \t  skipnewline:\n \t    c = getch ();\n \t    if (c == EOF) {\n-\t\tcp_error (ec_nterminated_string);\n+\t\terror (\"Unterminated string\");\n \t\tbreak;\n \t    }\n \t  }\n@@ -4408,7 +4408,7 @@ real_yylex ()\n \t\tnextchar = c1;\n \t      }\n \t    if (pedantic)\n-\t      cp_pedwarn (ec_use_of_operator_s_is_not_standard,\n+\t      pedwarn (\"use of `operator %s' is not standard C++\",\n \t\t       token_buffer);\n \t    goto done;\n \t  }\n@@ -4772,13 +4772,13 @@ handle_cp_pragma (pname)\n       token = real_yylex ();\n       if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n \t{\n-\t  cp_error (ec_invalid_pragma_vtable);\n+\t  error (\"invalid #pragma vtable\");\n \t  return -1;\n \t}\n \n       if (write_virtuals != 2)\n \t{\n-\t  cp_warning (ec_use_e2_option_to_enable_pragma_vtable);\n+\t  warning (\"use `+e2' option to enable #pragma vtable\");\n \t  return -1;\n \t}\n       pending_vtables\n@@ -4787,7 +4787,7 @@ handle_cp_pragma (pname)\n \t\t\t  pending_vtables);\n       token = real_yylex ();\n       if (token != END_OF_LINE)\n-\tcp_warning (ec_trailing_characters_ignored);\n+\twarning (\"trailing characters ignored\");\n       return 1;\n     }\n   else if (! strcmp (pname, \"unit\"))\n@@ -4796,12 +4796,12 @@ handle_cp_pragma (pname)\n       token = real_yylex ();\n       if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n \t{\n-\t  cp_error (ec_invalid_pragma_unit);\n+\t  error (\"invalid #pragma unit\");\n \t  return -1;\n \t}\n       token = real_yylex ();\n       if (token != END_OF_LINE)\n-\tcp_warning (ec_trailing_characters_ignored);\n+\twarning (\"trailing characters ignored\");\n       return 1;\n     }\n   else if (! strcmp (pname, \"interface\"))\n@@ -4818,15 +4818,15 @@ handle_cp_pragma (pname)\n \t  if (token != STRING\n \t      || TREE_CODE (yylval.ttype) != STRING_CST)\n \t    {\n-\t      cp_error (ec_invalid_pragma_interface);\n+\t      error (\"invalid `#pragma interface'\");\n \t      return -1;\n \t    }\n \t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n \t  token = real_yylex ();\n \t}\n \n       if (token != END_OF_LINE)\n-\tcp_warning (ec_garbage_after_pragma_interface_ignored);\n+\twarning (\"garbage after `#pragma interface' ignored\");\n \n #ifndef NO_LINKAGE_HEURISTICS\n       write_virtuals = 3;\n@@ -4871,15 +4871,15 @@ handle_cp_pragma (pname)\n \t  if (token != STRING\n \t      || TREE_CODE (yylval.ttype) != STRING_CST)\n \t    {\n-\t      cp_error (ec_invalid_pragma_implementation);\n+\t      error (\"invalid `#pragma implementation'\");\n \t      return -1;\n \t    }\n \t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n \t  token = real_yylex ();\n \t}\n \n       if (token != END_OF_LINE)\n-\tcp_warning (ec_garbage_after_pragma_implementation_ignored);\n+\twarning (\"garbage after `#pragma implementation' ignored\");\n \n #ifndef NO_LINKAGE_HEURISTICS\n       if (write_virtuals == 3)\n@@ -4912,7 +4912,7 @@ handle_cp_pragma (pname)\n \t    }\n \t}\n       else\n-\tcp_error (ec_pragma_implementation_can_only_appear_at_toplevel);\n+\terror (\"`#pragma implementation' can only appear at top-level\");\n       interface_only = 0;\n #if 1\n       /* We make this non-zero so that we infer decl linkage"}, {"sha": "0b7260cf4902e407384dd732756ff201e4e79a42", "filename": "gcc/cp/method.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -679,7 +679,7 @@ build_overload_value (type, value, in_template)\n \tREAL_VALUE_TYPE val;\n \tchar *bufp = digit_buffer;\n \n-\tcp_pedwarn (ec_forbids_floatingpoint_template_arguments);\n+\tpedwarn (\"ANSI C++ forbids floating-point template arguments\");\n \n \tmy_friendly_assert (TREE_CODE (value) == REAL_CST, 244);\n \tval = TREE_REAL_CST (value);\n@@ -1814,12 +1814,12 @@ hack_identifier (value, name)\n #ifdef DEAD\n \t      if (DECL_CHAIN (fndecl) == NULL_TREE)\n \t\t{\n-\t\t  cp_warning (ec_methods_cannot_be_converted_to_function_pointers);\n+\t\t  warning (\"methods cannot be converted to function pointers\");\n \t\t  return fndecl;\n \t\t}\n \t      else\n \t\t{\n-\t\t  cp_error (ec_ambiguous_request_for_method_pointer_s,\n+\t\t  error (\"ambiguous request for method pointer `%s'\",\n \t\t\t IDENTIFIER_POINTER (name));\n \t\t  return error_mark_node;\n \t\t}\n@@ -1840,13 +1840,13 @@ hack_identifier (value, name)\n \t{\n \t  if (current_function_decl \n \t      && DECL_STATIC_FUNCTION_P (current_function_decl))\n-\t    cp_error (ec_invalid_use_of_member_in_static_member_function,\n+\t    cp_error (\"invalid use of member `%D' in static member function\",\n \t\t      value);\n \t  else\n \t    /* We can get here when processing a bad default\n \t       argument, like:\n \t         struct S { int a; void f(int i = a); }  */\n-\t    cp_error (ec_invalid_use_of_member, value);\n+\t    cp_error (\"invalid use of member `%D'\", value);\n \n \t  return error_mark_node;\n \t}\n@@ -1887,12 +1887,12 @@ hack_identifier (value, name)\n     }\n   else if (TREE_CODE (value) == NAMESPACE_DECL)\n     {\n-      cp_error (ec_use_of_namespace_as_expression, value);\n+      cp_error (\"use of namespace `%D' as expression\", value);\n       return error_mark_node;\n     }\n   else if (DECL_CLASS_TEMPLATE_P (value))\n     {\n-      cp_error (ec_use_of_class_template_as_expression, value);\n+      cp_error (\"use of class template `%T' as expression\", value);\n       return error_mark_node;\n     }\n   else\n@@ -1904,10 +1904,10 @@ hack_identifier (value, name)\n       if (context != NULL_TREE && context != current_function_decl\n \t  && ! TREE_STATIC (value))\n \t{\n-\t  cp_error (ec_use_of_s_from_containing_function,\n+\t  cp_error (\"use of %s from containing function\",\n \t\t      (TREE_CODE (value) == VAR_DECL\n \t\t       ? \"`auto' variable\" : \"parameter\"));\n-\t  cp_error_at (ec_declared_here, value);\n+\t  cp_error_at (\"  `%#D' declared here\", value);\n \t  value = error_mark_node;\n \t}\n     }\n@@ -1930,12 +1930,12 @@ hack_identifier (value, name)\n \t      if (access != access_public_node)\n \t\t{\n \t\t  if (TREE_CODE (value) == VAR_DECL)\n-\t\t    cp_error (ec_static_member_s_is_s,\n+\t\t    error (\"static member `%s' is %s\",\n \t\t\t   IDENTIFIER_POINTER (name),\n \t\t\t   TREE_PRIVATE (value) ? \"private\"\n \t\t\t\t\t\t: \"from a private base class\");\n \t\t  else\n-\t\t    cp_error (ec_enum_s_is_from_private_base_class,\n+\t\t    error (\"enum `%s' is from private base class\",\n \t\t\t   IDENTIFIER_POINTER (name));\n \t\t  return error_mark_node;\n \t\t}\n@@ -1946,7 +1946,7 @@ hack_identifier (value, name)\n     {\n       if (type == 0)\n \t{\n-\t  cp_error (ec_request_for_member_s_is_ambiguous_in_multiple_inheritance_lattice,\n+\t  error (\"request for member `%s' is ambiguous in multiple inheritance lattice\",\n \t\t IDENTIFIER_POINTER (name));\n \t  return error_mark_node;\n \t}\n@@ -1992,7 +1992,7 @@ make_thunk (function, delta)\n   thunk = IDENTIFIER_GLOBAL_VALUE (thunk_id);\n   if (thunk && TREE_CODE (thunk) != THUNK_DECL)\n     {\n-      cp_error (ec_implementationreserved_name_used, thunk_id);\n+      cp_error (\"implementation-reserved name `%D' used\", thunk_id);\n       thunk = NULL_TREE;\n       SET_IDENTIFIER_GLOBAL_VALUE (thunk_id, thunk);\n     }\n@@ -2061,7 +2061,7 @@ emit_thunk (thunk_fndecl)\n     tree a, t;\n \n     if (varargs_function_p (function))\n-      cp_error (ec_generic_thunk_code_fails_for_method_which_uses,\n+      cp_error (\"generic thunk code fails for method `%#D' which uses `...'\",\n \t\tfunction);\n \n     /* Set up clone argument trees for the thunk.  */\n@@ -2173,7 +2173,7 @@ do_build_copy_constructor (fndecl)\n \t  p = convert_from_reference (p);\n \n \t  if (p == error_mark_node)\n-\t    cp_error (ec_in_default_copy_constructor);\n+\t    cp_error (\"in default copy constructor\");\n \t  else \n \t    current_base_init_list = tree_cons (basetype,\n \t\t\t\t\t\tp, current_base_init_list);\n@@ -2191,7 +2191,7 @@ do_build_copy_constructor (fndecl)\n \t     CONV_IMPLICIT|CONV_CONST, LOOKUP_COMPLAIN, NULL_TREE);\n \n \t  if (p == error_mark_node) \n-\t    cp_error (ec_in_default_copy_constructor);\n+\t    cp_error (\"in default copy constructor\");\n \t  else \n \t    {\n \t      p = convert_from_reference (p);\n@@ -2299,17 +2299,17 @@ do_build_assign_ref (fndecl)\n \t  if (TREE_READONLY (field))\n \t    {\n \t      if (DECL_NAME (field))\n-\t\tcp_error (ec_nonstatic_const_member_cant_use_default_assignment_operator, field);\n+\t\tcp_error (\"non-static const member `%#D', can't use default assignment operator\", field);\n \t      else\n-\t\tcp_error (ec_nonstatic_const_member_in_type_cant_use_default_assignment_operator, current_class_type);\n+\t\tcp_error (\"non-static const member in type `%T', can't use default assignment operator\", current_class_type);\n \t      continue;\n \t    }\n \t  else if (TREE_CODE (TREE_TYPE (field)) == REFERENCE_TYPE)\n \t    {\n \t      if (DECL_NAME (field))\n-\t\tcp_error (ec_nonstatic_reference_member_cant_use_default_assignment_operator, field);\n+\t\tcp_error (\"non-static reference member `%#D', can't use default assignment operator\", field);\n \t      else\n-\t\tcp_error (ec_nonstatic_reference_member_in_type_cant_use_default_assignment_operator, current_class_type);\n+\t\tcp_error (\"non-static reference member in type `%T', can't use default assignment operator\", current_class_type);\n \t      continue;\n \t    }\n "}, {"sha": "c73312cd92cb198dad875af26a5702e5cf3b6cad", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 821, "deletions": 824, "changes": 1645, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120"}, {"sha": "5bc8cb0bd93f4dec89d0a5d5cb9ea600e0397e21", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 65, "deletions": 68, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -489,8 +489,7 @@ extern_lang_string:\n \t\t{ push_lang_context ($1); }\n \t| extern_lang_string EXTERN_LANG_STRING\n \t\t{ if (current_lang_name != $2)\n-\t\t    cp_error\n-\t\t      (ec_use_of_linkage_spec_is_different_from_previous_spec, $2, current_lang_name); \n+\t\t    cp_error (\"use of linkage spec `%D' is different from previous spec `%D'\", $2, current_lang_name);\n \t\t  pop_lang_context (); push_lang_context ($2); }\n \t;\n \n@@ -553,7 +552,7 @@ template_parm:\n \t\t      && TREE_CODE ($3) != TEMPLATE_TEMPLATE_PARM\n \t\t      && TREE_CODE ($3) != TYPE_DECL)\n \t\t    {\n-\t\t      cp_error (ec_invalid_default_template_argument);\n+\t\t      error (\"invalid default template argument\");\n \t\t      $3 = error_mark_node;\n \t\t    }\n \t\t  $$ = build_tree_list ($3, $1);\n@@ -602,7 +601,7 @@ datadef:\n \t| typed_declspecs initdecls ';'\n                 { note_list_got_semicolon ($1.t); }\n         | declmods ';'\n-\t\t{ cp_pedwarn (ec_empty_declaration); }\n+\t\t{ pedwarn (\"empty declaration\"); }\n \t| explicit_instantiation ';'\n \t| typed_declspecs ';'\n \t\t{\n@@ -758,7 +757,7 @@ base_init:\n \t  ':' .set_base_init member_init_list\n \t\t{\n \t\t  if ($3 == 0)\n-\t\t    cp_error (ec_no_base_initializers_given_following);\n+\t\t    error (\"no base initializers given following ':'\");\n \t\t  setup_vtbl_ptr ();\n \t\t  /* Always keep the BLOCK node associated with the outermost\n \t\t     pair of curley braces of a function.  These are needed\n@@ -781,9 +780,9 @@ base_init:\n \t\t      expand_start_bindings (0);\n \t\t    }\n \t\t  else if (current_class_type == NULL_TREE)\n-\t\t    cp_error (ec_base_initializers_not_allowed_for_nonmember_functions);\n+\t\t    error (\"base initializers not allowed for non-member functions\");\n \t\t  else if (! DECL_CONSTRUCTOR_P (current_function_decl))\n-\t\t    cp_error (ec_only_constructors_take_base_initializers);\n+\t\t    error (\"only constructors take base initializers\");\n \t\t}\n \t;\n \n@@ -800,13 +799,13 @@ member_init:\n \t  '(' nonnull_exprlist ')'\n \t\t{\n \t\t  if (current_class_name)\n-\t\t    cp_pedwarn (ec_anachronistic_old_style_base_class_initializer);\n+\t\t    pedwarn (\"anachronistic old style base class initializer\");\n \t\t  expand_member_init (current_class_ref, NULL_TREE, $2);\n \t\t}\n \t| LEFT_RIGHT\n \t\t{\n \t\t  if (current_class_name)\n-\t\t    cp_pedwarn (ec_anachronistic_old_style_base_class_initializer);\n+\t\t    pedwarn (\"anachronistic old style base class initializer\");\n \t\t  expand_member_init (current_class_ref, NULL_TREE, void_type_node);\n \t\t}\n \t| notype_identifier '(' nonnull_exprlist ')'\n@@ -917,7 +916,7 @@ template_close_bracket:\n \t| RSHIFT \n \t\t{\n \t\t  /* Handle `Class<Class<Type>>' without space in the `>>' */\n-\t\t  cp_pedwarn (ec_should_be_in_template_class_name);\n+\t\t  pedwarn (\"`>>' should be `> >' in template class name\");\n \t\t  yyungetc ('>', 1);\n \t\t}\n \t;\n@@ -964,7 +963,7 @@ expr:\n \n paren_expr_or_null:\n \tLEFT_RIGHT\n-\t\t{ cp_error (ec_forbids_an_empty_condition_for_s,\n+\t\t{ error (\"ANSI C++ forbids an empty condition for `%s'\",\n \t\t\t cond_stmt_keyword);\n \t\t  $$ = integer_zero_node; }\n \t| '(' expr ')'\n@@ -973,7 +972,7 @@ paren_expr_or_null:\n \n paren_cond_or_null:\n \tLEFT_RIGHT\n-\t\t{ cp_error (ec_forbids_an_empty_condition_for_s,\n+\t\t{ error (\"ANSI C++ forbids an empty condition for `%s'\",\n \t\t\t cond_stmt_keyword);\n \t\t  $$ = integer_zero_node; }\n \t| '(' condition ')'\n@@ -996,9 +995,9 @@ condition:\n \t\t    if (TREE_CODE (d) == TYPE_DECL) {\n \t\t      tree s = TREE_TYPE (d);\n \t\t      if (TREE_CODE (s) == RECORD_TYPE)\n-\t\t\tcp_error (ec_definition_of_class_in_condition, s);\n+\t\t\tcp_error (\"definition of class `%T' in condition\", s);\n \t\t      else if (TREE_CODE (s) == ENUMERAL_TYPE)\n-\t\t\tcp_error (ec_definition_of_enum_in_condition, s);\n+\t\t\tcp_error (\"definition of enum `%T' in condition\", s);\n \t\t    }\n \t\t  }\n \t\t  current_declspecs = $1.t;\n@@ -1012,7 +1011,7 @@ condition:\n \t\t  resume_momentary ($<itype>5);\n \t\t  $$ = $<ttype>6; \n \t\t  if (TREE_CODE (TREE_TYPE ($$)) == ARRAY_TYPE)\n-\t\t    cp_error (ec_definition_of_array_in_condition, $$); \n+\t\t    cp_error (\"definition of array `%#D' in condition\", $$); \n \t\t}\n \t| expr\n \t;\n@@ -1070,7 +1069,7 @@ unary_expr:\n \t/* Refer to the address of a label as a pointer.  */\n \t| ANDAND identifier\n \t\t{ if (pedantic)\n-\t\t    cp_pedwarn (ec_forbids);\n+\t\t    pedwarn (\"ANSI C++ forbids `&&'\");\n   \t\t  $$ = finish_label_address_expr ($2); }\n \t| SIZEOF unary_expr  %prec UNARY\n \t\t{ $$ = expr_sizeof ($2); }\n@@ -1155,7 +1154,7 @@ new_placement:\n \t  '(' .begin_new_placement nonnull_exprlist ')'\n                 { $$ = finish_new_placement ($3, $2); }\n \t| '{' .begin_new_placement nonnull_exprlist '}'\n-                { cp_pedwarn (ec_old_style_placement_syntax_use_instead);\n+                { cp_pedwarn (\"old style placement syntax, use () instead\");\n \t\t  $$ = finish_new_placement ($3, $2); }\n \t;\n \n@@ -1166,7 +1165,7 @@ new_initializer:\n \t\t{ $$ = NULL_TREE; }\n \t| '(' typespec ')'\n \t\t{\n-\t\t  cp_error (ec_is_not_a_valid_expression, $2.t);\n+\t\t  cp_error (\"`%T' is not a valid expression\", $2.t);\n \t\t  $$ = error_mark_node;\n \t\t}\n \t/* GNU extension so people can use initializer lists.  Note that\n@@ -1175,7 +1174,7 @@ new_initializer:\n \t| '=' init\n \t\t{\n \t\t  if (pedantic)\n-\t\t    cp_pedwarn (ec_forbids_initialization_of_new_expression_with);\n+\t\t    pedwarn (\"ANSI C++ forbids initialization of new expression with `='\");\n \t\t  if (TREE_CODE ($2) != TREE_LIST\n \t\t      && TREE_CODE ($2) != CONSTRUCTOR)\n \t\t    $$ = build_expr_list (NULL_TREE, $2);\n@@ -1205,7 +1204,7 @@ cast_expr:\n \t\t  tree init = build_nt (CONSTRUCTOR, NULL_TREE,\n \t\t\t\t\tnreverse ($3)); \n \t\t  if (pedantic)\n-\t\t    cp_pedwarn (ec_forbids_constructorexpressions);\n+\t\t    pedwarn (\"ANSI C++ forbids constructor-expressions\");\n \t\t  /* Indicate that this was a GNU C constructor expression.  */\n \t\t  TREE_HAS_CONSTRUCTOR (init) = 1;\n \n@@ -1381,11 +1380,11 @@ primary:\n \t\t{ tree scope = current_scope ();\n \t\t  if (!scope || TREE_CODE (scope) != FUNCTION_DECL)\n \t\t    {\n-\t\t      cp_error (ec_bracedgroup_within_expression_allowed_only_inside_a_function);\n+\t\t      error (\"braced-group within expression allowed only inside a function\");\n \t\t      YYERROR;\n \t\t    }\n \t\t  if (pedantic)\n-\t\t    cp_pedwarn (ec_forbids_bracedgroups_within_expressions);  \n+\t\t    pedwarn (\"ANSI C++ forbids braced-groups within expressions\");  \n \t\t  $<ttype>$ = begin_stmt_expr (); \n \t\t}\n \t  compstmt ')'\n@@ -1424,7 +1423,7 @@ primary:\n #if 0\n \t\t  if ($3 == NULL_TREE)\n \t\t    {\n-\t\t      cp_error (ec_cannot_cast_null_list_to_type_s,\n+\t\t      error (\"cannot cast null list to type `%s'\",\n \t\t             IDENTIFIER_POINTER (TYPE_NAME (id)));\n \t\t      $$ = error_mark_node;\n \t\t      break;\n@@ -1445,7 +1444,7 @@ primary:\n \t\t      /* should not be able to get here (mrs) */\n \t\t      else if (id == ridpointers[(int) RID_FRIEND])\n \t\t        {\n-\t\t          cp_error (ec_cannot_cast_expression_to_friend_type);\n+\t\t          error (\"cannot cast expression to `friend' type\");\n \t\t          $$ = error_mark_node;\n \t\t          break;\n \t\t        }\n@@ -1539,13 +1538,13 @@ primary_no_id:\n \t| '('\n \t\t{ if (current_function_decl == 0)\n \t\t    {\n-\t\t      cp_error (ec_bracedgroup_within_expression_allowed_only_inside_a_function);\n+\t\t      error (\"braced-group within expression allowed only inside a function\");\n \t\t      YYERROR;\n \t\t    }\n \t\t  $<ttype>$ = expand_start_stmt_expr (); }\n \t  compstmt ')'\n \t\t{ if (pedantic)\n-\t\t    cp_pedwarn (ec_forbids_bracedgroups_within_expressions);\n+\t\t    pedwarn (\"ANSI C++ forbids braced-groups within expressions\");\n \t\t  $$ = expand_end_stmt_expr ($<ttype>2); }\n \t| primary_no_id '(' nonnull_exprlist ')'\n \t\t{ $$ = build_x_function_call ($$, $3, current_class_ref); }\n@@ -1638,7 +1637,7 @@ decl:\n \t\t  note_list_got_semicolon ($1.t);\n \t\t}\n \t| declmods ';'\n-\t\t{ cp_warning (ec_empty_declaration); }\n+\t\t{ warning (\"empty declaration\"); }\n \t| extension decl\n \t\t{ pedantic = $<itype>1; }\n \t;\n@@ -1715,14 +1714,14 @@ typed_declspecs1:\n reserved_declspecs:\n \t  SCSPEC\n \t\t{ if (extra_warnings)\n-\t\t    cp_warning (ec_s_is_not_at_beginning_of_declaration,\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER ($$));\n \t\t  $$ = build_decl_list (NULL_TREE, $$); }\n \t| reserved_declspecs typespecqual_reserved\n \t\t{ $$ = decl_tree_cons (NULL_TREE, $2.t, $$); }\n \t| reserved_declspecs SCSPEC\n \t\t{ if (extra_warnings)\n-\t\t    cp_warning (ec_s_is_not_at_beginning_of_declaration,\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER ($2));\n \t\t  $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n \t| reserved_declspecs attributes\n@@ -1746,7 +1745,7 @@ declmods:\n \t\t  TREE_STATIC ($$) = 1; }\n \t| declmods SCSPEC\n \t\t{ if (extra_warnings && TREE_STATIC ($$))\n-\t\t    cp_warning (ec_s_is_not_at_beginning_of_declaration,\n+\t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER ($2));\n \t\t  $$ = decl_tree_cons (NULL_TREE, $2, $$);\n \t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n@@ -1811,7 +1810,7 @@ typespec:\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      cp_error (ec_sigof_applied_to_nonaggregate_expression);\n+\t\t      error (\"`sigof' applied to non-aggregate expression\");\n \t\t      $$.t = error_mark_node;\n \t\t    }\n \t\t}\n@@ -1826,7 +1825,7 @@ typespec:\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      cp_error (ec_sigof_applied_to_nonaggregate_type);\n+\t\t      error(\"`sigof' applied to non-aggregate type\");\n \t\t      $$.t = error_mark_node;\n \t\t    }\n \t\t}\n@@ -2102,7 +2101,7 @@ structsp:\n \t\t{ $$.t = $2;\n \t\t  $$.new_type_flag = 0; \n \t\t  if (!processing_template_decl)\n-\t\t    cp_pedwarn (ec_using_typename_outside_of_template); }\n+\t\t    cp_pedwarn (\"using `typename' outside of template\"); }\n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n \t| class_head left_curly \n           opt.component_decl_list '}' maybe_attribute\n@@ -2126,7 +2125,7 @@ structsp:\n \t\t  $$.new_type_flag = 0;\n \t\t  if (TYPE_BINFO ($1) == NULL_TREE)\n \t\t    {\n-\t\t      cp_error (ec_is_not_a_class_type, $1);\n+\t\t      cp_error (\"%T is not a class type\", $1);\n \t\t      $$.t = error_mark_node;\n \t\t    } \n \t\t  else\n@@ -2135,7 +2134,7 @@ structsp:\n \t\t      /* struct B: public A; is not accepted by the WP grammar.  */\n \t\t      if (TYPE_BINFO_BASETYPES ($$.t) && !TYPE_SIZE ($$.t)\n \t\t\t  && ! TYPE_BEING_DEFINED ($$.t))\n-\t\t\tcp_error (ec_base_clause_without_member_specification_for,\n+\t\t\tcp_error (\"base clause without member specification for `%#T'\",\n \t\t\t\t  $$.t);\n \t\t    }\n \t\t}\n@@ -2150,19 +2149,19 @@ maybecomma_warn:\n \t  /* empty */\n \t| ','\n \t\t{ if (pedantic && !in_system_header)\n-\t\t    cp_pedwarn (ec_comma_at_end_of_enumerator_list); }\n+\t\t    pedwarn (\"comma at end of enumerator list\"); }\n \t;\n \n aggr:\n \t  AGGR\n \t| aggr SCSPEC\n-\t\t{ cp_error (ec_storage_class_specifier_s_not_allowed_after_struct_or_class, IDENTIFIER_POINTER ($2)); }\n+\t\t{ error (\"storage class specifier `%s' not allowed after struct or class\", IDENTIFIER_POINTER ($2)); }\n \t| aggr TYPESPEC\n-\t\t{ cp_error (ec_type_specifier_s_not_allowed_after_struct_or_class, IDENTIFIER_POINTER ($2)); }\n+\t\t{ error (\"type specifier `%s' not allowed after struct or class\", IDENTIFIER_POINTER ($2)); }\n \t| aggr CV_QUALIFIER\n-\t\t{ cp_error (ec_type_qualifier_s_not_allowed_after_struct_or_class, IDENTIFIER_POINTER ($2)); }\n+\t\t{ error (\"type qualifier `%s' not allowed after struct or class\", IDENTIFIER_POINTER ($2)); }\n \t| aggr AGGR\n-\t\t{ cp_error (ec_no_body_nor_separates_two_class_struct_or_union_declarations); }\n+\t\t{ error (\"no body nor ';' separates two class, struct or union declarations\"); }\n \t| aggr attributes\n \t\t{ $$ = build_decl_list ($2, $1); }\n \t;\n@@ -2223,10 +2222,10 @@ named_class_head:\n \t\t  $$ = TREE_TYPE ($1);\n \t\t  if (TREE_INT_CST_LOW (current_aggr) == union_type \n \t\t      && TREE_CODE ($$) != UNION_TYPE)\n-\t\t    cp_pedwarn (ec_union_tag_used_in_declaring, $$);\n+\t\t    cp_pedwarn (\"`union' tag used in declaring `%#T'\", $$);\n \t\t  else if (TREE_CODE ($$) == UNION_TYPE\n \t\t\t   && TREE_INT_CST_LOW (current_aggr) != union_type)\n-\t\t    cp_pedwarn (ec_nonunion_tag_used_in_declaring, $$);\n+\t\t    cp_pedwarn (\"non-`union' tag used in declaring `%#T'\", $$);\n \t\t  if ($2)\n \t\t    {\n \t\t      maybe_process_partial_specialization ($$);\n@@ -2287,13 +2286,13 @@ base_class.1:\n \t\t\t}\n \t\t      else\n \t\t\t{\n-\t\t\t  cp_error (ec_sigof_applied_to_nonaggregate_expression);\n+\t\t\t  error (\"`sigof' applied to non-aggregate expression\");\n \t\t\t  $$ = error_mark_node;\n \t\t\t}\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      cp_error (ec_sigof_in_struct_or_class_declaration);\n+\t\t      error (\"`sigof' in struct or class declaration\");\n \t\t      $$ = error_mark_node;\n \t\t    }\n \t\t}\n@@ -2308,13 +2307,13 @@ base_class.1:\n \t\t\t}\n \t\t      else\n \t\t\t{\n-\t\t\t  cp_error (ec_sigof_applied_to_nonaggregate_expression);\n+\t\t\t  error (\"`sigof' applied to non-aggregate expression\");\n \t\t\t  $$ = error_mark_node;\n \t\t\t}\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      cp_error (ec_sigof_in_struct_or_class_declaration);\n+\t\t      error (\"`sigof' in struct or class declaration\");\n \t\t      $$ = error_mark_node;\n \t\t    }\n \t\t}\n@@ -2324,12 +2323,12 @@ base_class_access_list:\n \t  VISSPEC see_typename\n \t| SCSPEC see_typename\n \t\t{ if ($1 != ridpointers[(int)RID_VIRTUAL])\n-\t\t    cp_error (ec_access, $1);\n+\t\t    cp_error (\"`%D' access\", $1);\n \t\t  $$ = access_default_virtual_node; }\n \t| base_class_access_list VISSPEC see_typename\n \t\t{\n \t\t  if ($1 != access_default_virtual_node)\n-\t\t    cp_error (ec_multiple_access_specifiers);\n+\t\t    error (\"multiple access specifiers\");\n \t\t  else if ($2 == access_public_node)\n \t\t    $$ = access_public_virtual_node;\n \t\t  else if ($2 == access_protected_node)\n@@ -2339,15 +2338,15 @@ base_class_access_list:\n \t\t}\n \t| base_class_access_list SCSPEC see_typename\n \t\t{ if ($2 != ridpointers[(int)RID_VIRTUAL])\n-\t\t    cp_error (ec_access, $2);\n+\t\t    cp_error (\"`%D' access\", $2);\n \t\t  else if ($$ == access_public_node)\n \t\t    $$ = access_public_virtual_node;\n \t\t  else if ($$ == access_protected_node)\n \t\t    $$ = access_protected_virtual_node;\n \t\t  else if ($$ == access_private_node)\n \t\t    $$ = access_private_virtual_node;\n \t\t  else\n-\t\t    cp_error (ec_multiple_virtual_specifiers);\n+\t\t    error (\"multiple `virtual' specifiers\");\n \t\t}\n \t;\n \n@@ -2380,15 +2379,15 @@ opt.component_decl_list:\n \n \t\t  if (current_aggr == signature_type_node)\n \t\t    {\n-\t\t      cp_error (ec_access_specifier_not_allowed_in_signature);\n+\t\t      error (\"access specifier not allowed in signature\");\n \t\t      visspec = access_public_node;\n \t\t    }\n \t\t  $$ = chainon ($$, build_tree_list (visspec, $4));\n \t\t}\n \t| opt.component_decl_list VISSPEC ':'\n \t\t{\n \t\t  if (current_aggr == signature_type_node)\n-\t\t    cp_error (ec_access_specifier_not_allowed_in_signature);\n+\t\t    error (\"access specifier not allowed in signature\");\n \t\t}\n \t;\n \n@@ -2417,7 +2416,7 @@ component_decl:\n \t  component_decl_1 ';'\n \t\t{ }\n \t| component_decl_1 '}'\n-\t\t{ cp_error (ec_missing_before_right_brace);\n+\t\t{ error (\"missing ';' before right brace\");\n \t\t  yyungetc ('}', 0); }\n \t/* C++: handle constructors, destructors and inline functions */\n \t/* note that INLINE is like a TYPESPEC */\n@@ -2615,7 +2614,7 @@ new_type_id:\n \t      '[' expr ']'\n \t\t{\n \t\t  if (pedantic)\n-\t\t    cp_pedwarn (ec_forbids_array_dimensions_with_parenthesized_type_in_new);\n+\t\t    pedwarn (\"ANSI C++ forbids array dimensions with parenthesized type in new\");\n \t\t  $$.t = build_parse_node (ARRAY_REF, TREE_VALUE ($3.t), $6);\n \t\t  $$.t = build_decl_list (TREE_PURPOSE ($3.t), $$.t);\n \t\t  $$.new_type_flag = $3.new_type_flag;\n@@ -2871,7 +2870,7 @@ nested_name_specifier_1:\n \t| IDENTIFIER SCOPE\n \t\t{\n \t\t failed_scope:\n-\t\t  cp_error (ec_is_not_an_aggregate_typedef, \n+\t\t  cp_error (\"`%D' is not an aggregate typedef\", \n \t\t\t    lastiddecl ? lastiddecl : $$);\n \t\t  $$ = error_mark_node;\n \t\t}\n@@ -2891,7 +2890,7 @@ typename_sub0:\n \t\t  if (TREE_CODE_CLASS (TREE_CODE ($1)) == 't')\n \t\t    $$ = make_typename_type ($1, $2);\n \t\t  else if (TREE_CODE ($2) == IDENTIFIER_NODE)\n-\t\t    cp_error (ec_is_not_a_class_or_namespace, $2);\n+\t\t    cp_error (\"`%T' is not a class or namespace\", $2);\n \t\t  else\n \t\t    {\n \t\t      $$ = $2;\n@@ -2911,14 +2910,14 @@ typename_sub1:\n \t  typename_sub2\n \t\t{\n \t\t  if (TREE_CODE ($1) == IDENTIFIER_NODE)\n-\t\t    cp_error (ec_is_not_a_class_or_namespace, $1);\n+\t\t    cp_error (\"`%T' is not a class or namespace\", $1);\n \t\t}\n \t| typename_sub1 typename_sub2\n \t\t{\n \t\t  if (TREE_CODE_CLASS (TREE_CODE ($1)) == 't')\n \t\t    $$ = make_typename_type ($1, $2);\n \t\t  else if (TREE_CODE ($2) == IDENTIFIER_NODE)\n-\t\t    cp_error (ec_is_not_a_class_or_namespace, $2);\n+\t\t    cp_error (\"`%T' is not a class or namespace\", $2);\n \t\t  else\n \t\t    {\n \t\t      $$ = $2;\n@@ -2943,7 +2942,7 @@ typename_sub2:\n \t\t  got_scope = $$ = complete_type (IDENTIFIER_TYPE_VALUE ($1));\n \n \t\t  if ($$ == error_mark_node)\n-\t\t    cp_error (ec_is_not_a_class_or_namespace, $1);\n+\t\t    cp_error (\"`%T' is not a class or namespace\", $1);\n \t\t}\n \t| SELFNAME SCOPE\n \t\t{\n@@ -3101,7 +3100,7 @@ maybe_label_decls:\n \t  /* empty */\n \t| label_decls\n \t\t{ if (pedantic)\n-\t\t    cp_pedwarn (ec_forbids_label_declarations); }\n+\t\t    pedwarn (\"ANSI C++ forbids label declarations\"); }\n \t;\n \n label_decls:\n@@ -3247,15 +3246,15 @@ simple_stmt:\n \t| GOTO '*' expr ';'\n                 { \n \t\t  if (pedantic)\n-\t\t    cp_pedwarn (ec_forbids_computed_gotos);\n+\t\t    pedwarn (\"ANSI C++ forbids computed gotos\");\n \t\t  finish_goto_stmt ($3);\n \t\t}\n \t| GOTO identifier ';'\n                 { finish_goto_stmt ($2); }\n \t| label_colon stmt\n \t\t{ finish_stmt (); }\n \t| label_colon '}'\n-\t\t{ cp_error (ec_label_must_be_followed_by_statement);\n+\t\t{ error (\"label must be followed by statement\");\n \t\t  yyungetc ('}', 0);\n \t\t  finish_stmt (); }\n \t| ';'\n@@ -3360,7 +3359,7 @@ for.init.statement:\n \t| decl\n \t| '{' compstmtend\n \t\t{ if (pedantic)\n-\t\t    cp_pedwarn (ec_forbids_compound_statements_inside_for_initializations);\n+\t\t    pedwarn (\"ANSI C++ forbids compound statements inside for initializations\");\n \t\t}\n \t;\n \n@@ -3551,18 +3550,16 @@ see_typename:\n bad_parm:\n \t  /* empty */ %prec EMPTY\n \t\t{\n-\t\t  cp_error (ec_type_specifier_omitted_for_parameter);\n+\t\t  error (\"type specifier omitted for parameter\");\n \t\t  $$ = build_tree_list (integer_type_node, NULL_TREE);\n \t\t}\n \t| notype_declarator\n \t\t{\n-\t\t  cp_error (ec_type_specifier_omitted_for_parameter);\n+\t\t  error (\"type specifier omitted for parameter\");\n \t\t  if (TREE_CODE ($$) == SCOPE_REF\n \t\t      && (TREE_CODE (TREE_OPERAND ($$, 0)) == TEMPLATE_TYPE_PARM\n \t\t\t  || TREE_CODE (TREE_OPERAND ($$, 0)) == TEMPLATE_TEMPLATE_PARM))\n-\t\t    cp_error\n-\t\t      (ec_perhaps_you_want_typename_expr_to_make_it_a_type, \n-\t\t       $$);\n+\t\t    cp_error (\"  perhaps you want `typename %E' to make it a type\", $$);\n \t\t  $$ = build_tree_list (integer_type_node, $$);\n \t\t}\n \t;"}, {"sha": "04c9fd65fdabfef2d543f57c3487f8b678a01f14", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 115, "deletions": 112, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -228,7 +228,7 @@ finish_member_template_decl (template_parameters, decl)\n \treturn decl;\n     } \n   else\n-    cp_error (ec_invalid_member_template_declaration, decl);\n+    cp_error (\"invalid member template declaration `%D'\", decl);\n \t\n \n   return error_mark_node;\n@@ -594,7 +594,7 @@ check_specialization_scope ()\n      shall be declared in the namespace of which the class template\n      is a member.  */\n   if (scope && TREE_CODE (scope) != NAMESPACE_DECL)\n-    cp_error (ec_explicit_specialization_in_nonnamespace_scope,\n+    cp_error (\"explicit specialization in non-namespace scope `%D'\",\n \t      scope);\n   /* [temp.expl.spec] \n \n@@ -605,7 +605,7 @@ check_specialization_scope ()\n      explicitly specialize a class member template if its enclosing\n      class templates are not explicitly specialized as well.  */\n   if (current_template_parms) \n-    cp_error (ec_enclosing_class_templates_are_not_explicit_specialized);\n+    cp_error (\"enclosing class templates are not explicit specialized\");\n }\n \n /* We've just seen template <>. */\n@@ -680,7 +680,7 @@ maybe_process_partial_specialization (type)\n \t    push_template_decl (TYPE_MAIN_DECL (type));\n \t}\n       else if (CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n-\tcp_error (ec_specialization_of_type_after_instantiation, type);\n+\tcp_error (\"specialization of `%T' after instantiation\", type);\n     }\n }\n \n@@ -797,7 +797,7 @@ register_specialization (spec, tmpl, args)\n \t\tif (TREE_USED (fn) \n \t\t    || DECL_EXPLICIT_INSTANTIATION (fn))\n \t\t  {\n-\t\t    cp_error (ec_specialization_of_decl_after_instantiation,\n+\t\t    cp_error (\"specialization of %D after instantiation\",\n \t\t\t      fn);\n \t\t    return spec;\n \t\t  }\n@@ -875,7 +875,7 @@ print_candidates (fns)\n \n   for (fn = fns; fn != NULL_TREE; fn = TREE_CHAIN (fn))\n     {\n-      cp_error_at (ec_decl, str, TREE_VALUE (fn));\n+      cp_error_at (\"%s %+#D\", str, TREE_VALUE (fn));\n       str = \"               \";\n     }\n }\n@@ -997,7 +997,7 @@ determine_specialization (template_id, decl, targs_out,\n     no_match:\n       if (complain)\n \t{\n-\t  cp_error_at (ec_templateid_for_does_not_match_any_template_declaration,\n+\t  cp_error_at (\"template-id `%D' for `%+D' does not match any template declaration\",\n \t\t       template_id, decl);\n \t  return error_mark_node;\n \t}\n@@ -1008,7 +1008,7 @@ determine_specialization (template_id, decl, targs_out,\n     ambiguous:\n       if (complain)\n \t{\n-\t  cp_error_at (ec_ambiguous_template_specialization_for,\n+\t  cp_error_at (\"ambiguous template specialization `%D' for `%+D'\",\n \t\t       template_id, decl);\n \t  print_candidates (templates);\n \t  return error_mark_node;\n@@ -1095,7 +1095,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t\t   lists.  There can be at most one parameter list for\n \t\t   every qualifying class, plus one for the function\n \t\t   itself.  */\n-\t\tcp_error (ec_too_many_template_parameter_lists_in_declaration_of, decl);\n+\t\tcp_error (\"too many template parameter lists in declaration of `%D'\", decl);\n \n \t      SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n \t      if (ctype)\n@@ -1127,17 +1127,17 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t\t void S<int>::T<char>::f();\n \n \t\t But, we're missing another template <>.  */\n-\t      cp_error (ec_too_few_template_parameter_lists_in_declaration_of, decl);\n+\t      cp_error(\"too few template parameter lists in declaration of `%D'\", decl);\n \t      return decl;\n \t    } \n \t}\n       else if (processing_explicit_instantiation)\n \t{\n \t  if (template_header_count)\n-\t    cp_error (ec_template_parameter_list_used_in_explicit_instantiation);\n+\t    cp_error (\"template parameter list used in explicit instantiation\");\n \t  \n \t  if (have_def)\n-\t    cp_error (ec_definition_provided_for_explicit_instantiation);\n+\t    cp_error (\"definition provided for explicit instantiation\");\n \n \t  explicit_instantiation = 1;\n \t}\n@@ -1163,12 +1163,13 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t     that's bogus.  */\n \t  if (template_header_count)\n \t    {\n-\t      cp_error (ec_template_parameters_specified_in_specialization);\n+\t      cp_error (\"template parameters specified in specialization\");\n \t      return decl;\n \t    }\n \n \t  if (pedantic)\n-\t    cp_pedwarn (ec_explicit_specialization_not_preceded_by_template);\n+\t    cp_pedwarn\n+\t      (\"explicit specialization not preceded by `template <>'\");\n \t  specialization = 1;\n \t  SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n \t}\n@@ -1185,7 +1186,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t      /* This case handles bogus declarations like template <>\n \t\t template <class T> void f<int>(); */\n \n-\t      cp_error (ec_templateid_in_declaration_of_primary_template,\n+\t      cp_error (\"template-id `%D' in declaration of primary template\",\n \t\t\tdeclarator);\n \t      return decl;\n \t    }\n@@ -1198,7 +1199,8 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n       for (; t; t = TREE_CHAIN (t))\n \tif (TREE_PURPOSE (t))\n \t  {\n-\t    cp_pedwarn (ec_default_argument_specified_in_explicit_specialization);\n+\t    cp_pedwarn\n+\t      (\"default argument specified in explicit specialization\");\n \t    break;\n \t  }\n     }\n@@ -1287,7 +1289,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t\t     program is ill-formed.  \n \n \t\t     Similar language is found in [temp.explicit].  */\n-\t\t  cp_error (ec_specialization_of_implicitlydeclared_special_member_function);\n+\t\t  cp_error (\"specialization of implicitly-declared special member function\");\n \n \t\t  return decl;\n \t\t}\n@@ -1299,7 +1301,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t  \n \t  if (fns == NULL_TREE) \n \t    {\n-\t      cp_error (ec_no_member_function_s_declared_in,\n+\t      cp_error (\"no member function `%s' declared in `%T'\",\n \t\t\tIDENTIFIER_POINTER (name),\n \t\t\tctype);\n \t      return decl;\n@@ -1423,9 +1425,7 @@ maybe_check_template_type (type)\n \t; \n       else if (template_header_count > context_depth + 1)\n \t/* There are two many template parameter lists.  */\n-\tcp_error\n-\t  (ec_too_many_template_parameter_lists_in_declaration_of_type,\n-\t   type); \n+\tcp_error (\"too many template parameter lists in declaration of `%T'\", type); \n     }\n }\n \n@@ -1610,16 +1610,16 @@ process_template_parm (list, next)\n \t  && TREE_CODE (TREE_TYPE (parm)) != TEMPLATE_TYPE_PARM\n \t  && TREE_CODE (TREE_TYPE (parm)) != TYPENAME_TYPE)\n \t{\n-\t  cp_error (ec_is_not_a_valid_type_for_a_template_constant_parameter,\n+\t  cp_error (\"`%#T' is not a valid type for a template constant parameter\",\n \t\t    TREE_TYPE (parm));\n \t  if (DECL_NAME (parm) == NULL_TREE)\n-\t    cp_error (ec_a_template_type_parameter_must_begin_with_class_or_typename);\n+\t    error (\"  a template type parameter must begin with `class' or `typename'\");\n \t  TREE_TYPE (parm) = void_type_node;\n \t}\n       else if (pedantic\n \t       && (TREE_CODE (TREE_TYPE (parm)) == REAL_TYPE\n \t\t   || TREE_CODE (TREE_TYPE (parm)) == COMPLEX_TYPE))\n-\tcp_pedwarn (ec_is_not_a_valid_type_for_a_template_constant_parameter,\n+\tcp_pedwarn (\"`%T' is not a valid type for a template constant parameter\",\n \t\t    TREE_TYPE (parm));\n       if (TREE_PERMANENT (parm) == 0)\n         {\n@@ -1872,7 +1872,7 @@ process_partial_specialization (decl)\n \t{\n \t  if (!issued_default_arg_message)\n \t    {\n-\t      cp_error (ec_default_argument_in_partial_specialization, \n+\t      cp_error (\"default argument in partial specialization `%T'\", \n \t\t\ttype);\n \t      issued_default_arg_message = 1;\n \t    }\n@@ -1930,11 +1930,11 @@ process_partial_specialization (decl)\n            specialization.  */\n \tif (!did_error_intro)\n \t  {\n-\t    cp_error (ec_template_parameters_not_used_in_partial_specialization);\n+\t    cp_error (\"template parameters not used in partial specialization:\");\n \t    did_error_intro = 1;\n \t  }\n \n-\tcp_error (ec_template_parm,\n+\tcp_error (\"        `%D'\", \n \t\t  TREE_VALUE (TREE_VEC_ELT (inner_parms, i)));\n       }\n \n@@ -1945,7 +1945,7 @@ process_partial_specialization (decl)\n   if (comp_template_args (inner_args, \n \t\t\t  innermost_args (CLASSTYPE_TI_ARGS (TREE_TYPE\n \t\t\t\t\t\t\t     (maintmpl)))))\n-    cp_error (ec_partial_specialization_does_not_specialize_any_template_arguments, type);\n+    cp_error (\"partial specialization `%T' does not specialize any template arguments\", type);\n \n   /* [temp.class.spec]\n \n@@ -1970,7 +1970,7 @@ process_partial_specialization (decl)\n \t  && TREE_CODE (arg) != TEMPLATE_PARM_INDEX)\n \t{\n \t  if (tpd.arg_uses_template_parms[i])\n-\t    cp_error (ec_template_argument_involves_template_parameters, arg);\n+\t    cp_error (\"template argument `%E' involves template parameter(s)\", arg);\n \t  else \n \t    {\n \t      /* Look at the corresponding template parameter,\n@@ -2010,7 +2010,7 @@ process_partial_specialization (decl)\n \t\t    if (tpd2.parms[j] != 0\n \t\t\t&& tpd.arg_uses_template_parms [j])\n \t\t      {\n-\t\t\tcp_error (ec_type_of_template_argument_depends_on_template_paramters, \n+\t\t\tcp_error (\"type `%T' of template argument `%E' depends on template paramter(s)\", \n \t\t\t\t  type,\n \t\t\t\t  arg);\n \t\t\tbreak;\n@@ -2090,12 +2090,12 @@ push_template_decl_real (decl, is_friend)\n   if (primary)\n     {\n       if (current_lang_name == lang_name_c)\n-\tcp_error (ec_template_with_linkage);\n+\tcp_error (\"template with C linkage\");\n       if (TREE_CODE (decl) == TYPE_DECL && ANON_AGGRNAME_P (DECL_NAME (decl)))\n-\tcp_error (ec_template_class_without_a_name);\n+\tcp_error (\"template class without a name\");\n       if (TREE_CODE (decl) == TYPE_DECL \n \t  && TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)\n-\tcp_error (ec_template_declaration_of_type, TREE_TYPE (decl));\n+\tcp_error (\"template declaration of `%#T'\", TREE_TYPE (decl));\n     }\n \n   /* Partial specialization.  */\n@@ -2136,7 +2136,7 @@ push_template_decl_real (decl, is_friend)\n       tree a;\n \n       if (CLASSTYPE_TEMPLATE_INSTANTIATION (ctx))\n-\tcp_error (ec_must_specialize_before_defining_member,\n+\tcp_error (\"must specialize `%#T' before defining member `%#D'\",\n \t\t  ctx, decl);\n       if (TREE_CODE (decl) == TYPE_DECL)\n \t{\n@@ -2147,13 +2147,13 @@ push_template_decl_real (decl, is_friend)\n \t    tmpl = TYPE_TI_TEMPLATE (TREE_TYPE (decl));\n \t  else\n \t    {\n-\t      cp_error (ec_does_not_declare_a_template_type, decl);\n+\t      cp_error (\"`%D' does not declare a template type\", decl);\n \t      return decl;\n \t    }\n \t}\n       else if (! DECL_TEMPLATE_INFO (decl))\n \t{\n-\t  cp_error (ec_template_definition_of_nontemplate, decl);\n+\t  cp_error (\"template definition of non-template `%#D'\", decl);\n \t  return decl;\n \t}\n       else\n@@ -2191,9 +2191,9 @@ push_template_decl_real (decl, is_friend)\n \t  t = DECL_INNERMOST_TEMPLATE_PARMS (tmpl);\n \t  if (TREE_VEC_LENGTH (t) != TREE_VEC_LENGTH (a))\n \t    {\n-\t      cp_error (ec_got_d_template_parameters_for,\n+\t      cp_error (\"got %d template parameters for `%#D'\",\n \t\t\tTREE_VEC_LENGTH (a), decl);\n-\t      cp_error (ec_but_d_required, TREE_VEC_LENGTH (t));\n+\t      cp_error (\"  but %d required\", TREE_VEC_LENGTH (t));\n \t    }\n \t  if (TMPL_ARGS_DEPTH (args) > 1)\n \t    /* Get the template parameters for the enclosing template\n@@ -2224,9 +2224,9 @@ push_template_decl_real (decl, is_friend)\n       if (t != NULL_TREE \n \t  && TREE_VEC_LENGTH (t) != TREE_VEC_LENGTH (a))\n \t{\n-\t  cp_error (ec_got_d_template_parameters_for,\n+\t  cp_error (\"got %d template parameters for `%#D'\",\n \t\t    TREE_VEC_LENGTH (a), decl);\n-\t  cp_error (ec_but_has_d, ctx, TREE_VEC_LENGTH (t));\n+\t  cp_error (\"  but `%#T' has %d\", ctx, TREE_VEC_LENGTH (t));\n \t}\n     }\n \n@@ -2254,7 +2254,7 @@ push_template_decl_real (decl, is_friend)\n \tDECL_NAME (decl) = classtype_mangled_name (TREE_TYPE (decl));\n     }\n   else if (! DECL_LANG_SPECIFIC (decl))\n-    cp_error (ec_template_declaration_of, decl);\n+    cp_error (\"template declaration of `%#D'\", decl);\n   else\n     DECL_TEMPLATE_INFO (decl) = info;\n \n@@ -2294,8 +2294,8 @@ redeclare_class_template (type, parms)\n \n   if (TREE_VEC_LENGTH (parms) != TREE_VEC_LENGTH (tmpl_parms))\n     {\n-      cp_error_at (ec_previous_declaration, tmpl);\n-      cp_error (ec_used_d_template_parameters_instead_of_d,\n+      cp_error_at (\"previous declaration `%D'\", tmpl);\n+      cp_error (\"used %d template parameter%s instead of %d\",\n \t\tTREE_VEC_LENGTH (tmpl_parms), \n \t\tTREE_VEC_LENGTH (tmpl_parms) == 1 ? \"\" : \"s\",\n \t\tTREE_VEC_LENGTH (parms));\n@@ -2311,8 +2311,8 @@ redeclare_class_template (type, parms)\n \n       if (TREE_CODE (tmpl_parm) != TREE_CODE (parm))\n \t{\n-\t  cp_error_at (ec_template_parameter, tmpl_parm);\n-\t  cp_error (ec_redeclared_here_as, parm);\n+\t  cp_error_at (\"template parameter `%#D'\", tmpl_parm);\n+\t  cp_error (\"redeclared here as `%#D'\", parm);\n \t  return;\n \t}\n \n@@ -2322,8 +2322,8 @@ redeclare_class_template (type, parms)\n \n \t     A template-parameter may not be given default arguments\n \t     by two different declarations in the same scope.  */\n-\t  cp_error (ec_redefinition_of_default_argument_for, parm);\n-\t  cp_error_at (ec_original_definition_appeared_here, tmpl_parm);\n+\t  cp_error (\"redefinition of default argument for `%#D'\", parm);\n+\t  cp_error_at (\"  original definition appeared here\", tmpl_parm);\n \t  return;\n \t}\n \n@@ -2392,7 +2392,7 @@ convert_nontype_argument (type, expr)\n       if (! TREE_CONSTANT (expr))\n \t{\n \tnon_constant:\n-\t  cp_error (ec_nonconstant_cannot_be_used_as_template_argument,\n+\t  cp_error (\"non-constant `%E' cannot be used as template argument\",\n \t\t    expr);\n \t  return NULL_TREE;\n \t}\n@@ -2409,8 +2409,8 @@ convert_nontype_argument (type, expr)\n       if (TREE_CODE (e) != ADDR_EXPR)\n \t{\n \tbad_argument:\n-\t  cp_error (ec_is_not_a_valid_template_argument, expr);\n-\t  cp_error (ec_it_must_be_ss_with_external_linkage,\n+\t  cp_error (\"`%E' is not a valid template argument\", expr);\n+\t  error (\"it must be %s%s with external linkage\",\n \t\t TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE\n \t\t ? \"a pointer to \" : \"\",\n \t\t TREE_CODE (TREE_TYPE (TREE_TYPE (expr))) == FUNCTION_TYPE\n@@ -2423,9 +2423,9 @@ convert_nontype_argument (type, expr)\n       \n       if (TREE_CODE (referent) == STRING_CST)\n \t{\n-\t  cp_error (ec_string_literal_is_not_a_valid_template_argument, \n+\t  cp_error (\"string literal %E is not a valid template argument\", \n \t\t    referent);\n-\t  cp_error (ec_because_it_is_the_address_of_an_object_with_static_linkage);\n+\t  error (\"because it is the address of an object with static linkage\");\n \t  return NULL_TREE;\n \t}\n \n@@ -2436,7 +2436,7 @@ convert_nontype_argument (type, expr)\n \tgoto bad_argument;\n       else if (!TREE_PUBLIC (referent))\n \t{\n-\t  cp_error (ec_address_of_nonextern_cannot_be_used_as_template_argument, referent); \n+\t  cp_error (\"address of non-extern `%E' cannot be used as template argument\", referent); \n \t  return error_mark_node;\n \t}\n     }\n@@ -2447,7 +2447,7 @@ convert_nontype_argument (type, expr)\n     }\n   else \n     {\n-      cp_error (ec_object_cannot_be_used_as_template_argument, expr);\n+      cp_error (\"object `%E' cannot be used as template argument\", expr);\n       return NULL_TREE;\n     }\n \n@@ -2816,8 +2816,8 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n   if (requires_type && ! is_type && TREE_CODE (arg) == SCOPE_REF\n       && TREE_CODE (TREE_OPERAND (arg, 0)) == TEMPLATE_TYPE_PARM)\n     {\n-      cp_pedwarn (ec_to_refer_to_a_type_member_of_a_template_parameter);\n-      cp_pedwarn (ec_use_typename, arg);\n+      cp_pedwarn (\"to refer to a type member of a template parameter,\");\n+      cp_pedwarn (\"  use `typename %E'\", arg);\n       \n       arg = make_typename_type (TREE_OPERAND (arg, 0),\n \t\t\t\tTREE_OPERAND (arg, 1));\n@@ -2829,14 +2829,14 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n \t{\n \t  if (complain)\n \t    {\n-\t      cp_error (ec_typevalue_mismatch_at_argument_d_in_template_parameter_list_for,\n+\t      cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n \t\t\ti + 1, in_decl);\n \t      if (is_type)\n-\t\tcp_error (ec_expected_a_constant_of_type_got,\n+\t\tcp_error (\"  expected a constant of type `%T', got `%T'\",\n \t\t\t  TREE_TYPE (parm),\n \t\t\t  (is_tmpl_type ? DECL_NAME (arg) : arg));\n \t      else\n-\t\tcp_error (ec_expected_a_type_got_expr, arg);\n+\t\tcp_error (\"  expected a type, got `%E'\", arg);\n \t    }\n \t}\n       return error_mark_node;\n@@ -2845,12 +2845,12 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n     {\n       if (in_decl && complain)\n \t{\n-\t  cp_error (ec_typevalue_mismatch_at_argument_d_in_template_parameter_list_for,\n+\t  cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n \t\t    i + 1, in_decl);\n \t  if (is_tmpl_type)\n-\t    cp_error (ec_expected_a_type_got_type, DECL_NAME (arg));\n+\t    cp_error (\"  expected a type, got `%T'\", DECL_NAME (arg));\n \t  else\n-\t    cp_error (ec_expected_a_class_template_got, arg);\n+\t    cp_error (\"  expected a class template, got `%T'\", arg);\n \t}\n       return error_mark_node;\n     }\n@@ -2877,9 +2877,9 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n \t    {\n \t      if (in_decl && complain)\n \t\t{\n-\t\t  cp_error (ec_typevalue_mismatch_at_argument_d_in_template_parameter_list_for,\n+\t\t  cp_error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n \t\t\t    i + 1, in_decl);\n-\t\t  cp_error (ec_expected_a_template_of_type_got, parm, arg);\n+\t\t  cp_error (\"  expected a template of type `%D', got `%D'\", parm, arg);\n \t\t}\n \t\t  \n \t      val = error_mark_node;\n@@ -2899,9 +2899,11 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n \t      if (t)\n \t\t{\n \t\t  if (ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n-\t\t    cp_pedwarn (ec_templateargument_uses_anonymous_type, val);\n+\t\t    cp_pedwarn\n+\t\t      (\"template-argument `%T' uses anonymous type\", val);\n \t\t  else\n-\t\t    cp_error (ec_templateargument_uses_local_type,\n+\t\t    cp_error\n+\t\t      (\"template-argument `%T' uses local type `%T'\",\n \t\t       val, t);\n \t\t  return error_mark_node;\n \t\t}\n@@ -2933,7 +2935,7 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n       if (val == NULL_TREE)\n \tval = error_mark_node;\n       else if (val == error_mark_node && complain)\n-\tcp_error (ec_could_not_convert_template_argument_to, \n+\tcp_error (\"could not convert template argument `%E' to `%T'\", \n \t\t  arg, t);\n     }\n \n@@ -2980,11 +2982,11 @@ coerce_template_parms (parms, args, in_decl,\n     {\n       if (complain) \n \t{\n-\t  cp_error (ec_wrong_number_of_template_arguments_d_should_be_d,\n+\t  cp_error (\"wrong number of template arguments (%d, should be %d)\",\n \t\t    nargs, nparms);\n \t  \n \t  if (in_decl)\n-\t    cp_error_at (ec_provided_for, in_decl);\n+\t    cp_error_at (\"provided for `%D'\", in_decl);\n \t}\n \n       return error_mark_node;\n@@ -3030,7 +3032,7 @@ coerce_template_parms (parms, args, in_decl,\n \t}\n       else if (arg == error_mark_node)\n \t{\n-\t  cp_error (ec_template_argument_d_is_invalid, i + 1);\n+\t  cp_error (\"template argument %d is invalid\", i + 1);\n \t  arg = error_mark_node;\n \t}\n       else \n@@ -3235,7 +3237,7 @@ lookup_template_function (fns, arglist)\n \n   if (fns == NULL_TREE)\n     {\n-      cp_error (ec_nontemplate_used_as_template);\n+      cp_error (\"non-template used as template\");\n       return error_mark_node;\n     }\n \n@@ -3354,9 +3356,9 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \n   if (TREE_CODE (template) != TEMPLATE_DECL)\n     {\n-      cp_error (ec_nontemplate_type_used_as_a_template, d1);\n+      cp_error (\"non-template type `%T' used as a template\", d1);\n       if (in_decl)\n-\tcp_error_at (ec_for_template_declaration, in_decl);\n+\tcp_error_at (\"for template declaration `%D'\", in_decl);\n       return error_mark_node;\n     }\n \n@@ -3431,7 +3433,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t       We should catch this error sooner (at the opening curly\n \t       for `S', but it is better to be safe than sorry here.  */\n \t    {\n-\t      cp_error (ec_invalid_use_of, template);\n+\t      cp_error (\"invalid use of `%D'\", template);\n \t      return error_mark_node;\n \t    }\n \n@@ -3954,10 +3956,10 @@ push_tinst_level (d)\n \treturn 0;\n \n       last_template_error_tick = tinst_level_tick;\n-      cp_error (ec_template_instantiation_depth_exceeds_maximum_of_d,\n+      error (\"template instantiation depth exceeds maximum of %d\",\n \t     max_tinst_depth);\n-      cp_error (ec_use_ftemplatedepth_to_increase_the_maximum);\n-      cp_error (ec_instantiating, d);\n+      error (\" (use -ftemplate-depth-NN to increase the maximum)\");\n+      cp_error (\"  instantiating `%D'\", d);\n \n       print_template_context (0);\n \n@@ -4274,13 +4276,13 @@ instantiate_class_template (type)\n   if (t == error_mark_node)\n     {\n       char *str = \"candidates are:\";\n-      cp_error (ec_ambiguous_class_template_instantiation_for, type);\n+      cp_error (\"ambiguous class template instantiation for `%#T'\", type);\n       for (t = DECL_TEMPLATE_SPECIALIZATIONS (template); t; t = TREE_CHAIN (t))\n \t{\n \t  if (get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t),\n \t\t\t\t  args))\n \t    {\n-\t      cp_error_at (ec_type, str, TREE_TYPE (t));\n+\t      cp_error_at (\"%s %+#T\", str, TREE_TYPE (t));\n \t      str = \"               \";\n \t    }\n \t}\n@@ -4431,10 +4433,11 @@ instantiate_class_template (type)\n \t    basetype = TREE_TYPE (elt);\n \n \t    if (! IS_AGGR_TYPE (basetype))\n-\t      cp_error (ec_base_type_of_fails_to_be_a_struct_or_class_type,\n+\t      cp_error\n+\t\t(\"base type `%T' of `%T' fails to be a struct or class type\",\n \t\t basetype, type);\n \t    else if (TYPE_SIZE (complete_type (basetype)) == NULL_TREE)\n-\t      cp_error (ec_base_class_of_has_incomplete_type,\n+\t      cp_error (\"base class `%T' of `%T' has incomplete type\",\n \t\t\tbasetype, type);\n \n \t    /* These are set up in xref_basetypes for normal classes, so\n@@ -5254,7 +5257,7 @@ tsubst_decl (t, args, type, in_decl)\n \tDECL_INITIAL (r) = tsubst_expr (DECL_INITIAL (t), args, in_decl);\n \tTREE_CHAIN (r) = NULL_TREE;\n \tif (TREE_CODE (type) == VOID_TYPE)\n-\t  cp_error_at (ec_instantiation_of_as_type_void, r);\n+\t  cp_error_at (\"instantiation of `%D' as type void\", r);\n       }\n       break;\n \n@@ -5313,7 +5316,7 @@ tsubst_decl (t, args, type, in_decl)\n \n \tTREE_CHAIN (r) = NULL_TREE;\n \tif (TREE_CODE (type) == VOID_TYPE)\n-\t  cp_error_at (ec_instantiation_of_as_type_void, r);\n+\t  cp_error_at (\"instantiation of `%D' as type void\", r);\n       }\n       break;\n \n@@ -5644,7 +5647,7 @@ tsubst (t, args, in_decl)\n \t    if (last_line != lineno ||\n \t\tlast_file != input_filename)\n \t      {\n-\t\tcp_error (ec_cannot_form_type_s_to_reference_type_during_template_instantiation,\n+\t\tcp_error (\"cannot form type %s to reference type %T during template instantiation\",\n \t\t\t  (code == POINTER_TYPE) ? \"pointer\" : \"reference\",\n \t\t\t  type);\n \t\tlast_line = lineno;\n@@ -6425,8 +6428,8 @@ instantiate_template (tmpl, targ_ptr)\n \t  tree nt = target_type (t);\n \t  if (IS_AGGR_TYPE (nt) && decl_function_context (TYPE_MAIN_DECL (nt)))\n \t    {\n-\t      cp_error (ec_type_composed_from_a_local_class_is_not_a_valid_templateargument, t);\n-\t      cp_error (ec_trying_to_instantiate, gen_tmpl);\n+\t      cp_error (\"type `%T' composed from a local class is not a valid template-argument\", t);\n+\t      cp_error (\"  trying to instantiate `%D'\", gen_tmpl);\n \t      fndecl = error_mark_node;\n \t      goto out;\n \t    }\n@@ -6829,7 +6832,7 @@ type_unification_real (tparms, targs, parms, args, subr,\n       if (TREE_VEC_ELT (targs, i) == NULL_TREE)\n \t{\n \t  if (!allow_incomplete)\n-\t    cp_error (ec_incomplete_type_unification);\n+\t    error (\"incomplete type unification\");\n \t  return 2;\n \t}\n   return 0;\n@@ -7661,7 +7664,7 @@ do_decl_instantiation (declspecs, declarator, storage)\n \n   if (! DECL_LANG_SPECIFIC (decl))\n     {\n-      cp_error (ec_explicit_instantiation_of_nontemplate, decl);\n+      cp_error (\"explicit instantiation of non-template `%#D'\", decl);\n       return;\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n@@ -7677,13 +7680,13 @@ do_decl_instantiation (declspecs, declarator, storage)\n       result = lookup_field (DECL_CONTEXT (decl), DECL_NAME (decl), 0, 0);\n       if (result && TREE_CODE (result) != VAR_DECL)\n \t{\n-\t  cp_error (ec_no_matching_template_for_found, result);\n+\t  cp_error (\"no matching template for `%D' found\", result);\n \t  return;\n \t}\n     }\n   else if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n-      cp_error (ec_explicit_instantiation_of, decl);\n+      cp_error (\"explicit instantiation of `%#D'\", decl);\n       return;\n     }\n   else\n@@ -7700,8 +7703,8 @@ do_decl_instantiation (declspecs, declarator, storage)\n \n \t No program shall both explicitly instantiate and explicitly\n \t specialize a template.  */\n-      cp_error (ec_explicit_instantiation_of_after, result);\n-      cp_error_at (ec_explicit_specialization_here, result);\n+      cp_error (\"explicit instantiation of `%#D' after\", result);\n+      cp_error_at (\"explicit specialization here\", result);\n       return;\n     }\n   else if (DECL_EXPLICIT_INSTANTIATION (result))\n@@ -7715,20 +7718,20 @@ do_decl_instantiation (declspecs, declarator, storage)\n \t first instantiation was `extern' and the second is not, and\n \t EXTERN_P for the opposite case.  */\n       if (DECL_INTERFACE_KNOWN (result) && !extern_p)\n-\tcp_error (ec_duplicate_explicit_instantiation_of, result);\n+\tcp_error (\"duplicate explicit instantiation of `%#D'\", result);\n \n       /* If we've already instantiated the template, just return now.  */\n       if (DECL_INTERFACE_KNOWN (result))\n \treturn;\n     }\n   else if (!DECL_IMPLICIT_INSTANTIATION (result))\n     {\n-      cp_error (ec_no_matching_template_for_found, result);\n+      cp_error (\"no matching template for `%D' found\", result);\n       return;\n     }\n   else if (!DECL_TEMPLATE_INFO (result))\n     {\n-      cp_pedwarn (ec_explicit_instantiation_of_nontemplate, result);\n+      cp_pedwarn (\"explicit instantiation of non-template `%#D'\", result);\n       return;\n     }\n \n@@ -7740,11 +7743,11 @@ do_decl_instantiation (declspecs, declarator, storage)\n   else if (storage == ridpointers[(int) RID_EXTERN])\n     {\n       if (pedantic)\n-\tcp_pedwarn (ec_forbids_the_use_of_extern_on_explicit_instantiations);\n+\tcp_pedwarn (\"ANSI C++ forbids the use of `extern' on explicit instantiations\");\n       extern_p = 1;\n     }\n   else\n-    cp_error (ec_storage_class_applied_to_template_instantiation,\n+    cp_error (\"storage class `%D' applied to template instantiation\",\n \t      storage);\n \n   SET_DECL_EXPLICIT_INSTANTIATION (result);\n@@ -7784,7 +7787,7 @@ do_type_instantiation (t, storage)\n \n   if (! IS_AGGR_TYPE (t) || ! CLASSTYPE_TEMPLATE_INFO (t))\n     {\n-      cp_error (ec_explicit_instantiation_of_nontemplate_type, t);\n+      cp_error (\"explicit instantiation of non-template type `%T'\", t);\n       return;\n     }\n \n@@ -7797,16 +7800,16 @@ do_type_instantiation (t, storage)\n \n   if (TYPE_SIZE (t) == NULL_TREE)\n     {\n-      cp_error (ec_explicit_instantiation_of_before_definition_of_template,\n+      cp_error (\"explicit instantiation of `%#T' before definition of template\",\n \t\tt);\n       return;\n     }\n \n   if (storage != NULL_TREE)\n     {\n       if (pedantic)\n-\tcp_pedwarn (ec_forbids_the_use_of_s_on_explicit_instantiations, \n-\t\t    IDENTIFIER_POINTER (storage));\n+\tcp_pedwarn(\"ANSI C++ forbids the use of `%s' on explicit instantiations\", \n+\t\t   IDENTIFIER_POINTER (storage));\n \n       if (storage == ridpointers[(int) RID_INLINE])\n \tnomem_p = 1;\n@@ -7816,7 +7819,7 @@ do_type_instantiation (t, storage)\n \tstatic_p = 1;\n       else\n \t{\n-\t  cp_error (ec_storage_class_applied_to_template_instantiation,\n+\t  cp_error (\"storage class `%D' applied to template instantiation\",\n \t\t    storage);\n \t  extern_p = 0;\n \t}\n@@ -7828,8 +7831,8 @@ do_type_instantiation (t, storage)\n \n \t No program shall both explicitly instantiate and explicitly\n \t specialize a template.  */\n-      cp_error (ec_explicit_instantiation_of_type_after, t);\n-      cp_error_at (ec_explicit_specialization_here, t);\n+      cp_error (\"explicit instantiation of `%#T' after\", t);\n+      cp_error_at (\"explicit specialization here\", t);\n       return;\n     }\n   else if (CLASSTYPE_EXPLICIT_INSTANTIATION (t))\n@@ -7843,7 +7846,7 @@ do_type_instantiation (t, storage)\n \t instantiation was `extern', and if EXTERN_P then the second\n \t is.  Both cases are OK.  */\n       if (!CLASSTYPE_INTERFACE_ONLY (t) && !extern_p)\n-\tcp_error (ec_duplicate_explicit_instantiation_of_type, t);\n+\tcp_error (\"duplicate explicit instantiation of `%#T'\", t);\n       \n       /* If we've already instantiated the template, just return now.  */\n       if (!CLASSTYPE_INTERFACE_ONLY (t))\n@@ -7939,11 +7942,11 @@ regenerate_decl_from_template (decl, tmpl)\n   args = DECL_TI_ARGS (decl);\n   code_pattern = DECL_TEMPLATE_RESULT (tmpl);\n \n-  /* Unregister the specialization so that when we call tsubst we will\n-     not just return DECL.  We don't have to unregister DECL from TMPL\n-     (as opposed to GEN_TMPL) because if would only be registered\n-     there if it were a partial instantiation of a specialization,\n-     which it isn't: it's a full instantiation.  */\n+  /* Unregister the specialization so that when we tsubst we will not\n+     just return DECL.  We don't have to unregister DECL from TMPL\n+     because if would only be registered there if it were a partial\n+     instantiation of a specialization, which it isn't: it's a full\n+     instantiation.  */\n   gen_tmpl = most_general_template (tmpl);\n   unregistered = unregister_specialization (decl, gen_tmpl);\n \n@@ -8155,7 +8158,7 @@ instantiate_decl (d)\n \t   member function or static data member of a class template\n \t   shall be present in every translation unit in which it is\n \t   explicitly instantiated.  */\n-\tcp_error (ec_explicit_instantiation_of_but_no_definition_available,\n+\tcp_error (\"explicit instantiation of `%D' but no definition available\",\n \t\t  d);\n \n       add_pending_template (d);\n@@ -8311,7 +8314,7 @@ add_maybe_template (d, fns)\n     return;\n   if (t == error_mark_node)\n     {\n-      cp_error (ec_ambiguous_template_instantiation_for, d);\n+      cp_error (\"ambiguous template instantiation for `%D'\", d);\n       return;\n     }\n "}, {"sha": "742250dc6328fea0ca2dea3a88800c536e2c65d5", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -254,7 +254,7 @@ get_base_filename (filename)\n \n   if (p && ! compiling)\n     {\n-      cp_warning (ec_frepo_must_be_used_with_c);\n+      warning (\"-frepo must be used with -c\");\n       flag_use_repository = 0;\n       return NULL;\n     }\n@@ -344,7 +344,7 @@ init_repo (filename)\n \t  }\n \t  break;\n \tdefault:\n-\t  cp_error (ec_mysterious_repository_information_in_s, repo_name);\n+\t  error (\"mysterious repository information in %s\", repo_name);\n \t}\n       obstack_free (&temporary_obstack, buf);\n     }\n@@ -359,7 +359,7 @@ reopen_repo_file_for_write ()\n \n   if (repo_file == 0)\n     {\n-      cp_error (ec_cant_create_repository_information_file_s, repo_name);\n+      error (\"can't create repository information file `%s'\", repo_name);\n       flag_use_repository = 0;\n     }\n }"}, {"sha": "01c4a861ec25b0e1091c2369b0fdf013aea0382d", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -101,7 +101,7 @@ build_headof (exp)\n \n   if (TREE_CODE (type) != POINTER_TYPE)\n     {\n-      cp_error (ec_headof_applied_to_nonpointer_type);\n+      error (\"`headof' applied to non-pointer type\");\n       return error_mark_node;\n     }\n   type = TREE_TYPE (type);\n@@ -190,7 +190,7 @@ get_tinfo_fn_dynamic (exp)\n \n   if (type_unknown_p (exp))\n     {\n-      cp_error (ec_typeid_of_overloaded_function);\n+      error (\"typeid of overloaded function\");\n       return error_mark_node;\n     }\n \n@@ -211,7 +211,7 @@ get_tinfo_fn_dynamic (exp)\n \n       if (! flag_rtti)\n \t{\n-\t  cp_warning (ec_taking_dynamic_typeid_of_object_without_frtti);\n+\t  warning (\"taking dynamic typeid of object without -frtti\");\n \t  push_obstacks (&permanent_obstack, &permanent_obstack);\n \t  init_rtti_processing ();\n \t  pop_obstacks ();\n@@ -401,7 +401,7 @@ get_typeid (type)\n   \n   if (! flag_rtti)\n     {\n-      cp_warning (ec_requesting_typeid_of_object_without_frtti);\n+      warning (\"requesting typeid of object without -frtti\");\n       push_obstacks (&permanent_obstack, &permanent_obstack);\n       init_rtti_processing ();\n       pop_obstacks ();\n@@ -554,7 +554,7 @@ build_dynamic_cast_1 (type, expr)\n \t      if (TREE_CODE (expr) == VAR_DECL\n \t\t  && TREE_CODE (TREE_TYPE (expr)) == RECORD_TYPE)\n \t\t{\n-\t\t  cp_warning (ec_dynamic_cast_of_to_can_never_succeed,\n+\t\t  cp_warning (\"dynamic_cast of `%#D' to `%#T' can never succeed\",\n \t\t\t      expr, type);\n \t\t  return throw_bad_cast ();\n \t\t}\n@@ -566,7 +566,7 @@ build_dynamic_cast_1 (type, expr)\n \t      if (TREE_CODE (op) == VAR_DECL\n \t\t  && TREE_CODE (TREE_TYPE (op)) == RECORD_TYPE)\n \t\t{\n-\t\t  cp_warning (ec_dynamic_cast_of_to_can_never_succeed,\n+\t\t  cp_warning (\"dynamic_cast of `%#D' to `%#T' can never succeed\",\n \t\t\t      expr, type);\n \t\t  retval = build_int_2 (0, 0); \n \t\t  TREE_TYPE (retval) = type; \n@@ -650,7 +650,7 @@ build_dynamic_cast_1 (type, expr)\n     }\n \n  fail:\n-  cp_error (ec_cannot_dynamic_cast_of_type_to_type,\n+  cp_error (\"cannot dynamic_cast `%E' (of type `%#T') to type `%#T'\",\n \t    expr, exprtype, type);\n   return error_mark_node;\n }"}, {"sha": "c472bf04360bdebe2d544c3ea2af4b33839e264c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 49, "deletions": 37, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -278,13 +278,13 @@ get_binfo (parent, binfo, protect)\n \n   if (dist == -3)\n     {\n-      cp_error (ec_fields_of_are_inaccessible_in_due_to_private_inheritance,\n+      cp_error (\"fields of `%T' are inaccessible in `%T' due to private inheritance\",\n \t\tparent, type);\n       return error_mark_node;\n     }\n   else if (dist == -2 && protect)\n     {\n-      cp_error (ec_type_is_ambiguous_base_class_for_type, parent,\n+      cp_error (\"type `%T' is ambiguous base class for type `%T'\", parent,\n \t\ttype);\n       return error_mark_node;\n     }\n@@ -884,7 +884,7 @@ lookup_field (xbasetype, name, protect, want_type)\n      we know that binfo of a virtual base class will always == itself when\n      found along any line.  (mrs)  */\n \n-  error_code ec = ec_last_error_code;\n+  char *errstr = 0;\n \n #if 0\n   /* We cannot search for constructor/destructor names like this.  */\n@@ -952,10 +952,20 @@ lookup_field (xbasetype, name, protect, want_type)\n \t{\n \t  if (TREE_PRIVATE (rval) | TREE_PROTECTED (rval))\n \t    this_v = compute_access (basetype_path, rval);\n-\t  if (this_v == access_private_node)\n-\t    ec = ec_private_in_class;\n-\t  else if (this_v == access_protected_node)\n-\t    ec = ec_protected_in_class;\n+\t  if (TREE_CODE (rval) == CONST_DECL)\n+\t    {\n+\t      if (this_v == access_private_node)\n+\t\terrstr = \"enum `%D' is a private value of class `%T'\";\n+\t      else if (this_v == access_protected_node)\n+\t\terrstr = \"enum `%D' is a protected value of class `%T'\";\n+\t    }\n+\t  else\n+\t    {\n+\t      if (this_v == access_private_node)\n+\t\terrstr = \"member `%D' is a private member of class `%T'\";\n+\t      else if (this_v == access_protected_node)\n+\t\terrstr = \"member `%D' is a protected member of class `%T'\";\n+\t    }\n \t}\n \n       rval_binfo = basetype_path;\n@@ -1064,7 +1074,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \t  else\n \t    {\n \t      /* This is ambiguous.  */\n-\t      ec = ec_ambiguous_member;\n+\t      errstr = \"request for member `%D' is ambiguous\";\n \t      protect += 2;\n \t      break;\n \t    }\n@@ -1099,10 +1109,10 @@ lookup_field (xbasetype, name, protect, want_type)\n       }\n \n     if (rval == NULL_TREE)\n-      ec = ec_last_error_code;\n+      errstr = 0;\n \n     /* If this FIELD_DECL defines its own access level, deal with that.  */\n-    if (rval && ec == ec_last_error_code\n+    if (rval && errstr == 0\n \t&& (protect & 1)\n \t&& DECL_LANG_SPECIFIC (rval)\n \t&& DECL_ACCESS (rval))\n@@ -1118,7 +1128,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \t      new_v = compute_access (TREE_VALUE (TREE_CHAIN (*tp)), rval);\n \t    if (this_v != access_default_node && new_v != this_v)\n \t      {\n-\t\tec = ec_conflicting_access;\n+\t\terrstr = \"conflicting access to member `%D'\";\n \t\tthis_v = access_default_node;\n \t      }\n \t    own_access = new_v;\n@@ -1137,18 +1147,20 @@ lookup_field (xbasetype, name, protect, want_type)\n   }\n   search_stack = pop_search_level (search_stack);\n \n-  if (ec == ec_last_error_code)\n+  if (errstr == 0)\n     {\n       if (own_access == access_private_node)\n-\tec = ec_member_private;\n+\terrstr = \"member `%D' declared private\";\n       else if (own_access == access_protected_node)\n-\tec = ec_member_protected;\n+\terrstr = \"member `%D' declared protected\";\n       else if (this_v == access_private_node)\n-\tec = TREE_PRIVATE (rval)\n-\t  ? ec_member_private : ec_member_in_private_base;\n+\terrstr = TREE_PRIVATE (rval)\n+\t  ? \"member `%D' is private\"\n+\t    : \"member `%D' is from private base class\";\n       else if (this_v == access_protected_node)\n-\tec = TREE_PROTECTED (rval)\n-\t  ? ec_member_protected : ec_member_in_protected_base;\n+\terrstr = TREE_PROTECTED (rval)\n+\t  ? \"member `%D' is protected\"\n+\t    : \"member `%D' is from protected base class\";\n     }\n \n  out:\n@@ -1160,9 +1172,9 @@ lookup_field (xbasetype, name, protect, want_type)\n       protect = 0;\n     }\n \n-  if (ec != ec_last_error_code && protect)\n+  if (errstr && protect)\n     {\n-      cp_error (ec, name, type);\n+      cp_error (errstr, name, type);\n       rval = error_mark_node;\n     }\n \n@@ -1231,7 +1243,7 @@ lookup_nested_field (name, complain)\n \t\t\t enums in nested classes) when we do need to call\n \t\t\t this fn at parse time.  So, in those cases, we pass\n \t\t\t complain as a 0 and just return a NULL_TREE.  */\n-\t\t      cp_error (ec_assignment_to_nonstatic_member_of_enclosing_class,\n+\t\t      cp_error (\"assignment to non-static member `%D' of enclosing class `%T'\",\n \t\t\t\tid, DECL_CONTEXT (t));\n \t\t      /* Mark this for do_identifier().  It would otherwise\n \t\t\t claim that the variable was undeclared.  */\n@@ -1355,7 +1367,7 @@ lookup_fnfields (basetype_path, name, complain)\n   /* For now, don't try this.  */\n   int protect = complain;\n \n-  error_code ec = ec_last_error_code;\n+  char *errstr = 0;\n \n   if (complain == -1)\n     {\n@@ -1512,7 +1524,7 @@ lookup_fnfields (basetype_path, name, complain)\n \t  else\n \t    {\n \t      /* This is ambiguous.  */\n-\t      ec = ec_ambiguous_member;\n+\t      errstr = \"request for method `%D' is ambiguous\";\n \t      rvals = error_mark_node;\n \t      break;\n \t    }\n@@ -1530,9 +1542,9 @@ lookup_fnfields (basetype_path, name, complain)\n   }\n   search_stack = pop_search_level (search_stack);\n \n-  if (ec != ec_last_error_code && protect)\n+  if (errstr && protect)\n     {\n-      cp_error (ec, name);\n+      cp_error (errstr, name);\n       rvals = error_mark_node;\n     }\n \n@@ -1842,21 +1854,21 @@ get_matching_virtual (binfo, fndecl, dtorp)\n \n \t\t      if (pedantic && i == -1)\n \t\t\t{\n-\t\t\t  cp_pedwarn_at (ec_invalid_covariant_return_type_for_must_be_pointer_or_reference_to_class, fndecl);\n-\t\t\t  cp_pedwarn_at (ec_overriding, tmp);\n+\t\t\t  cp_pedwarn_at (\"invalid covariant return type for `%#D' (must be pointer or reference to class)\", fndecl);\n+\t\t\t  cp_pedwarn_at (\"  overriding `%#D'\", tmp);\n \t\t\t}\n \t\t    }\n \t\t  else if (IS_AGGR_TYPE_2 (brettype, drettype)\n \t\t\t   && comptypes (brettype, drettype, 0))\n \t\t    {\n-\t\t      cp_error (ec_invalid_covariant_return_type_must_use_pointer_or_reference);\n-\t\t      cp_error_at (ec_overriding, tmp);\n-\t\t      cp_error_at (ec_with, fndecl);\n+\t\t      error (\"invalid covariant return type (must use pointer or reference)\");\n+\t\t      cp_error_at (\"  overriding `%#D'\", tmp);\n+\t\t      cp_error_at (\"  with `%#D'\", fndecl);\n \t\t    }\n \t\t  else if (IDENTIFIER_ERROR_LOCUS (name) == NULL_TREE)\n \t\t    {\n-\t\t      cp_error_at (ec_conflicting_return_type_specified_for_virtual_function, fndecl);\n-\t\t      cp_error_at (ec_overriding_definition_as, tmp);\n+\t\t      cp_error_at (\"conflicting return type specified for virtual function `%#D'\", fndecl);\n+\t\t      cp_error_at (\"  overriding definition as `%#D'\", tmp);\n \t\t      SET_IDENTIFIER_ERROR_LOCUS (name, basetype);\n \t\t    }\n \t\t  break;\n@@ -2434,7 +2446,7 @@ virtual_context (fndecl, t, vbase)\n \t    }\n \t}\n       /* This shouldn't happen, I don't want errors! */\n-      cp_warning (ec_recoverable_compiler_error_fixups_for_virtual_function);\n+      warning (\"recoverable compiler error, fixups for virtual function\");\n       return vbase;\n     }\n   while (path)\n@@ -2697,7 +2709,7 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr)\n \t  tree in_charge_node = lookup_name (in_charge_identifier, 0);\n \t  if (! in_charge_node)\n \t    {\n-\t      cp_warning (ec_recoverable_internal_compiler_error_nobodys_in_charge);\n+\t      warning (\"recoverable internal compiler error, nobody's in charge!\");\n \t      in_charge_node = integer_zero_node;\n \t    }\n \t  in_charge_node = build_binary_op (EQ_EXPR, in_charge_node, integer_zero_node, 1);\n@@ -2825,9 +2837,9 @@ envelope_add_decl (type, decl, values)\n \t      || ! TREE_PRIVATE (value)))\n \t/* Should figure out access control more accurately.  */\n \t{\n-\t  cp_warning_at (ec_member_is_shadowed, value);\n-\t  cp_warning_at (ec_by_member_function, decl);\n-\t  cp_warning (ec_in_this_context);\n+\t  cp_warning_at (\"member `%#D' is shadowed\", value);\n+\t  cp_warning_at (\"by member function `%#D'\", decl);\n+\t  warning (\"in this context\");\n \t}\n \n       context = DECL_REAL_CONTEXT (value);"}, {"sha": "eee6616698e05dcaec977b0f70440094ec4c2373", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -453,7 +453,7 @@ finish_break_stmt ()\n   if (processing_template_decl)\n     add_tree (build_min_nt (BREAK_STMT));\n   else if ( ! expand_exit_something ())\n-    cp_error (ec_break_statement_not_within_loop_or_switch);\n+    cp_error (\"break statement not within loop or switch\");\n }\n \n /* Finish a continue-statement.  */\n@@ -465,7 +465,7 @@ finish_continue_stmt ()\n   if (processing_template_decl)\n     add_tree (build_min_nt (CONTINUE_STMT));\n   else if (! expand_continue_loop (0))\n-    cp_error (ec_continue_statement_not_within_a_loop);   \n+    cp_error (\"continue statement not within a loop\");   \n }\n \n /* Begin a switch-statement.  */\n@@ -735,7 +735,7 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n \t{\n \t  if (cv_qualifier != NULL_TREE\n \t      && cv_qualifier != ridpointers[(int) RID_VOLATILE])\n-\t    cp_warning (ec_qualifier_ignored_on_asm,\n+\t    cp_warning (\"%s qualifier ignored on asm\",\n \t\t\tIDENTIFIER_POINTER (cv_qualifier));\n \t    \n \t  c_expand_asm_operands (string, output_operands,\n@@ -748,7 +748,7 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n       else\n \t{\n \t  if (cv_qualifier != NULL_TREE)\n-\t    cp_warning (ec_qualifier_ignored_on_asm,\n+\t    cp_warning (\"%s qualifier ignored on asm\",\n \t\t\tIDENTIFIER_POINTER (cv_qualifier));\n \t  expand_asm (string);\n \t}\n@@ -895,15 +895,15 @@ finish_this_expr ()\n   else if (current_function_decl\n \t   && DECL_STATIC_FUNCTION_P (current_function_decl))\n     {\n-      cp_error (ec_this_is_unavailable_for_static_member_functions);\n+      error (\"`this' is unavailable for static member functions\");\n       result = error_mark_node;\n     }\n   else\n     {\n       if (current_function_decl)\n-\tcp_error (ec_invalid_use_of_this_in_nonmember_function);\n+\terror (\"invalid use of `this' in non-member function\");\n       else\n-\tcp_error (ec_invalid_use_of_this_at_top_level);\n+\terror (\"invalid use of `this' at top level\");\n       result = error_mark_node;\n     }\n \n@@ -941,7 +941,7 @@ finish_object_call_expr (fn, object, args)\n \tfn = DECL_NAME (fn);\n       else\n \t{\n-\t  cp_error (ec_calling_type_like_a_method, fn);\n+\t  cp_error (\"calling type `%T' like a method\", fn);\n \t  return error_mark_node;\n \t}\n     }\n@@ -961,7 +961,7 @@ finish_qualified_object_call_expr (fn, object, args)\n {\n   if (IS_SIGNATURE (TREE_OPERAND (fn, 0)))\n     {\n-      cp_warning (ec_signature_name_in_scope_resolution_ignored);\n+      warning (\"signature name in scope resolution ignored\");\n       return finish_object_call_expr (TREE_OPERAND (fn, 1), object, args);\n     }\n   else\n@@ -980,13 +980,13 @@ finish_pseudo_destructor_call_expr (object, scope, destructor)\n      tree destructor;\n {\n   if (scope && scope != destructor)\n-    cp_error (ec_destructor_specifier_must_have_matching_names, \n+    cp_error (\"destructor specifier `%T::~%T()' must have matching names\", \n \t      scope, destructor);\n \n   if ((scope == NULL_TREE || IDENTIFIER_GLOBAL_VALUE (destructor))\n       && (TREE_CODE (TREE_TYPE (object)) !=\n \t  TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (destructor)))))\n-    cp_error (ec_is_not_of_type, object, destructor);\n+    cp_error (\"`%E' is not of type `%T'\", object, destructor);\n \n   return cp_convert (void_type_node, object);\n }\n@@ -1159,7 +1159,7 @@ finish_template_type_parm (aggr, identifier)\n     sorry (\"signature as template type parameter\");\n   else if (aggr != class_type_node)\n     {\n-      cp_pedwarn (ec_template_type_parameters_must_use_the_keyword_class_or_typename);\n+      pedwarn (\"template type parameters must use the keyword `class' or `typename'\");\n       aggr = class_type_node;\n     }\n \n@@ -1459,19 +1459,19 @@ finish_base_specifier (access_specifier, base_class,\n \n   if (base_class == NULL_TREE)\n     {\n-      cp_error (ec_invalid_base_class);\n+      error (\"invalid base class\");\n       type = error_mark_node;\n     }\n   else\n     type = TREE_TYPE (base_class);\n   if (current_aggr_is_signature && access_specifier)\n-    cp_error (ec_access_and_source_specifiers_not_allowed_in_signature);\n+    error (\"access and source specifiers not allowed in signature\");\n   if (! is_aggr_type (type, 1))\n     result = NULL_TREE;\n   else if (current_aggr_is_signature\n \t   && (! type) && (! IS_SIGNATURE (type)))\n     {\n-      cp_error (ec_class_name_not_allowed_as_base_signature);\n+      error (\"class name not allowed as base signature\");\n       result = NULL_TREE;\n     }\n   else if (current_aggr_is_signature)\n@@ -1482,7 +1482,7 @@ finish_base_specifier (access_specifier, base_class,\n     }\n   else if (type && IS_SIGNATURE (type))\n     {\n-      cp_error (ec_signature_name_not_allowed_as_base_class);\n+      error (\"signature name not allowed as base class\");\n       result = NULL_TREE;\n     }\n   else"}, {"sha": "65350db79625580c69f0ae996b91d6f6acb898a1", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -492,7 +492,7 @@ build_signature_table_constructor (sig_ty, rhs)\n \n \t      if (oty_type == NULL_TREE || oty_type == error_mark_node)\n \t\t{\n-\t\t  cp_error (ec_class_does_not_contain_type,\n+\t\t  cp_error (\"class `%T' does not contain type `%T'\",\n \t\t\t    rhstype, oty_type);\n \t\t  undo_casts (sig_ty);\n \t\t  return error_mark_node;\n@@ -518,7 +518,7 @@ build_signature_table_constructor (sig_ty, rhs)\n \t{\n \t  if (! IS_DEFAULT_IMPLEMENTATION (sig_method))\n \t    {\n-\t      cp_error (ec_class_does_not_contain_method,\n+\t      cp_error (\"class `%T' does not contain method `%D'\",\n \t\t\trhstype, sig_mname);\n \t      undo_casts (sig_ty);\n \t      return error_mark_node;\n@@ -549,7 +549,7 @@ build_signature_table_constructor (sig_ty, rhs)\n \t      || (compute_access (basetypes, rhs_method)\n \t\t  != access_public_node))\n \t    {\n-\t      cp_error (ec_class_s_does_not_contain_a_method_conforming_to_s,\n+\t      error (\"class `%s' does not contain a method conforming to `%s'\",\n \t\t     TYPE_NAME_STRING (rhstype),\n \t\t     fndecl_as_string (sig_method, 1));\n \t      undo_casts (sig_ty);\n@@ -735,7 +735,7 @@ build_sigtable (sig_type, rhs_type, init_from)\n       if (SIGNATURE_HAS_OPAQUE_TYPEDECLS (sig_type)\n \t  && SIGTABLE_HAS_BEEN_GENERATED (sig_type))\n \t{\n-\t  cp_error (ec_signature_with_opaque_type_implemented_by_multiple_classes);\n+\t  error (\"signature with opaque type implemented by multiple classes\");\n \t  return error_mark_node;\n \t}\n       SIGTABLE_HAS_BEEN_GENERATED (sig_type) = 1;\n@@ -806,13 +806,13 @@ build_signature_pointer_constructor (lhs, rhs)\n \t     && (IS_SIGNATURE_POINTER (rhstype)\n \t\t || IS_SIGNATURE_REFERENCE (rhstype)))))\n     {\n-      cp_error (ec_invalid_assignment_to_signature_pointer_or_reference);\n+      error (\"invalid assignment to signature pointer or reference\");\n       return error_mark_node;\n     }\n \n   if (TYPE_SIZE (sig_ty) == NULL_TREE)\n     {\n-      cp_error (ec_undefined_signature_used_in_signature_s_declaration,\n+      cp_error (\"undefined signature `%T' used in signature %s declaration\",\n \t\tsig_ty,\n \t\tIS_SIGNATURE_POINTER (lhstype) ? \"pointer\" : \"reference\");\n       return error_mark_node;\n@@ -1018,7 +1018,7 @@ build_signature_method_call (function, parms)\n       || (IS_DEFAULT_IMPLEMENTATION (function)\n \t  && (!deflt_call || deflt_call == error_mark_node)))\n     {\n-      cp_compiler_error (ec_cannot_build_call_of_signature_member_function_s,\n+      compiler_error (\"cannot build call of signature member function `%s'\",\n \t\t      fndecl_as_string (function, 1));\n       return error_mark_node;\n     }"}, {"sha": "41475b5f46782f29b6c1c8f56fb5c434a64128c8", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -221,7 +221,7 @@ lvalue_or_else (ref, string)\n {\n   int win = lvalue_p (ref);\n   if (! win)\n-    cp_error (ec_nonlvalue_in_s, string);\n+    error (\"non-lvalue in %s\", string);\n   return win;\n }\n \n@@ -755,7 +755,7 @@ layout_basetypes (rec, max)\n       my_friendly_assert (TREE_TYPE (field) == basetype, 23897);\n \n       if (get_base_distance (basetype, rec, 0, (tree*)0) == -2)\n-\tcp_warning (ec_direct_base_inaccessible_in_due_to_ambiguity,\n+\tcp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n \t\t    basetype, rec);\n \n       BINFO_OFFSET (base_binfo)\n@@ -776,7 +776,7 @@ layout_basetypes (rec, max)\n \t{\n \t  tree basetype = BINFO_TYPE (vbase_types);\n \t  if (get_base_distance (basetype, rec, 0, (tree*)0) == -2)\n-\t    cp_warning (ec_virtual_base_inaccessible_in_due_to_ambiguity,\n+\t    cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n \t\t\tbasetype, rec);\n \t}\n     }\n@@ -1240,7 +1240,7 @@ binfo_value (elem, type)\n      tree type;\n {\n   if (get_base_distance (elem, type, 0, (tree *)0) == -2)\n-    cp_compiler_error (ec_base_class_s_ambiguous_in_binfo_value,\n+    compiler_error (\"base class `%s' ambiguous in binfo_value\",\n \t\t    TYPE_NAME_STRING (elem));\n   if (elem == type)\n     return TYPE_BINFO (type);"}, {"sha": "50ab3e6d14403a777a548f4130c36055d6e2fe74", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 224, "deletions": 224, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -216,7 +216,7 @@ require_instantiated_type (type, exp, errval)\n {\n   if (TREE_TYPE (exp) == NULL_TREE)\n     {\n-      cp_error (ec_argument_list_may_not_have_an_initializer_list);\n+      error (\"argument list may not have an initializer list\");\n       return errval;\n     }\n \n@@ -590,7 +590,7 @@ common_type (t1, t2)\n \treturn build_type_attribute_variant (t2, attributes);\n       else\n \t{\n-\t  cp_compiler_error (ec_common_type_called_with_uncommon_aggregate_types);\n+\t  compiler_error (\"common_type called with uncommon aggregate types\");\n \t  return error_mark_node;\n \t}\n \n@@ -611,7 +611,7 @@ common_type (t1, t2)\n \t  else\n \t    {\n \t      if (binfo_or_else (b2, b1) == NULL_TREE)\n-\t\tcp_compiler_error (ec_common_type_called_with_uncommon_method_types);\n+\t\tcompiler_error (\"common_type called with uncommon method types\");\n \t      basetype = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t1)));\n \t    }\n \n@@ -630,7 +630,7 @@ common_type (t1, t2)\n \t  t1 = build_exception_variant (t3, raises);\n \t}\n       else\n-        cp_compiler_error (ec_common_type_called_with_uncommon_method_types);\n+        compiler_error (\"common_type called with uncommon method types\");\n \n       return build_type_attribute_variant (t1, attributes);\n \n@@ -646,7 +646,7 @@ common_type (t1, t2)\n \t  else if (binfo_or_else (b2, b1))\n \t    return build_type_attribute_variant (t1, attributes);\n \t}\n-      cp_compiler_error (ec_common_type_called_with_uncommon_member_types);\n+      compiler_error (\"common_type called with uncommon member types\");\n \n     default:\n       return build_type_attribute_variant (t1, attributes);\n@@ -1269,7 +1269,7 @@ comp_target_parms (parms1, parms2, strict)\n \n   if (t1 == 0 && t2 != 0)\n     {\n-      cp_pedwarn (ec_prohibits_conversion_from_to,\n+      cp_pedwarn (\"ANSI C++ prohibits conversion from `(%#T)' to `(...)'\",\n \t\t  parms2);\n       return self_promoting_args_p (t2);\n     }\n@@ -1470,19 +1470,19 @@ c_sizeof (type)\n   if (code == FUNCTION_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n-\tcp_pedwarn (ec_forbids_taking_the_sizeof_a_function_type);\n+\tpedwarn (\"ANSI C++ forbids taking the sizeof a function type\");\n       return size_int (1);\n     }\n   if (code == METHOD_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n-\tcp_pedwarn (ec_forbids_taking_the_sizeof_a_method_type);\n+\tpedwarn (\"ANSI C++ forbids taking the sizeof a method type\");\n       return size_int (1);\n     }\n   if (code == VOID_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n-\tcp_pedwarn (ec_forbids_taking_the_sizeof_a_void_type);\n+\tpedwarn (\"ANSI C++ forbids taking the sizeof a void type\");\n       return size_int (1);\n     }\n   if (code == ERROR_MARK)\n@@ -1507,13 +1507,13 @@ c_sizeof (type)\n         In that case we should be able to do better.  */\n   if (IS_SIGNATURE (type))\n     {\n-      cp_error (ec_sizeof_applied_to_a_signature_type);\n+      error (\"`sizeof' applied to a signature type\");\n       return size_int (0);\n     }\n \n   if (TYPE_SIZE (complete_type (type)) == 0)\n     {\n-      cp_error (ec_sizeof_applied_to_incomplete_type, type);\n+      cp_error (\"`sizeof' applied to incomplete type `%T'\", type);\n       return size_int (0);\n     }\n \n@@ -1536,7 +1536,7 @@ expr_sizeof (e)\n \n   if (TREE_CODE (e) == COMPONENT_REF\n       && DECL_BIT_FIELD (TREE_OPERAND (e, 1)))\n-    cp_error (ec_sizeof_applied_to_a_bitfield);\n+    error (\"sizeof applied to a bit-field\");\n   /* ANSI says arrays and functions are converted inside comma.\n      But we can't really convert them in build_compound_expr\n      because that would break commas in lvalues.\n@@ -1552,7 +1552,7 @@ expr_sizeof (e)\n \t  && ((TREE_TYPE (t)\n \t       && TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n \t      || is_overloaded_fn (t)))\n-\tcp_pedwarn (ec_forbids_taking_the_sizeof_a_function_type);\n+\tpedwarn (\"ANSI C++ forbids taking the sizeof a function type\");\n     }\n   return c_sizeof (TREE_TYPE (e));\n }\n@@ -1610,7 +1610,7 @@ c_alignof (type)\n         In that case we should be able to do better.  */\n   if (IS_SIGNATURE (type))\n     {\n-      cp_error (ec_alignof_applied_to_a_signature_type);\n+      error (\"`__alignof' applied to a signature type\");\n       return size_int (1);\n     }\n \n@@ -1643,7 +1643,7 @@ decay_conversion (exp)\n \n       if (type == unknown_type_node)\n \t{\n-\t  cp_pedwarn (ec_assuming_on_overloaded_member_function);\n+\t  cp_pedwarn (\"assuming & on overloaded member function\");\n \t  return build_unary_op (ADDR_EXPR, exp, 0);\n \t}\n     }\n@@ -1670,7 +1670,7 @@ decay_conversion (exp)\n \n   if (code == VOID_TYPE)\n     {\n-      cp_error (ec_void_value_not_ignored_as_it_ought_to_be);\n+      error (\"void value not ignored as it ought to be\");\n       return error_mark_node;\n     }\n   if (code == FUNCTION_TYPE)\n@@ -1679,7 +1679,7 @@ decay_conversion (exp)\n     }\n   if (code == METHOD_TYPE)\n     {\n-      cp_pedwarn (ec_assuming_on, exp);\n+      cp_pedwarn (\"assuming & on `%E'\", exp);\n       return build_unary_op (ADDR_EXPR, exp, 0);\n     }\n   if (code == ARRAY_TYPE)\n@@ -1715,7 +1715,7 @@ decay_conversion (exp)\n       if (!lvalue_p (exp)\n \t  && ! (TREE_CODE (exp) == CONSTRUCTOR && TREE_STATIC (exp)))\n \t{\n-\t  cp_error (ec_invalid_use_of_nonlvalue_array);\n+\t  error (\"invalid use of non-lvalue array\");\n \t  return error_mark_node;\n \t}\n \n@@ -1826,7 +1826,7 @@ string_conv_p (totype, exp, warn)\n \n   /* This warning is not very useful, as it complains about printf.  */\n   if (warn && warn_write_strings)\n-    cp_warning (ec_deprecated_conversion_from_string_constant_to_char);\n+    cp_warning (\"deprecated conversion from string constant to `char *'\");\n \n   return 1;\n }\n@@ -1844,13 +1844,13 @@ build_object_ref (datum, basetype, field)\n     dtype = TREE_TYPE (dtype);\n   if (! IS_AGGR_TYPE_CODE (TREE_CODE (dtype)))\n     {\n-      cp_error (ec_request_for_member_in_expression_of_nonaggregate_type,\n+      cp_error (\"request for member `%T::%D' in expression of non-aggregate type `%T'\",\n \t\tbasetype, field, dtype);\n       return error_mark_node;\n     }\n   else if (IS_SIGNATURE (basetype))\n     {\n-      cp_warning (ec_signature_name_in_scope_resolution_ignored);\n+      warning (\"signature name in scope resolution ignored\");\n       return build_component_ref (datum, field, NULL_TREE, 1);\n     }\n   else if (is_aggr_type (basetype, 1))\n@@ -1983,7 +1983,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t\t      basetype_path, protect));\n \n     case TEMPLATE_DECL:\n-      cp_error (ec_invalid_use_of, datum);\n+      cp_error (\"invalid use of %D\", datum);\n       datum = error_mark_node;\n       break;\n \n@@ -2021,7 +2021,7 @@ build_component_ref (datum, component, basetype_path, protect)\n   if (! IS_AGGR_TYPE_CODE (code))\n     {\n       if (code != ERROR_MARK)\n-\tcp_error (ec_request_for_member_in_which_is_of_nonaggregate_type,\n+\tcp_error (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n \t\t  component, datum, basetype);\n       return error_mark_node;\n     }\n@@ -2033,13 +2033,13 @@ build_component_ref (datum, component, basetype_path, protect)\n     {\n       if (TYPE_IDENTIFIER (basetype) != TREE_OPERAND (component, 0))\n \t{\n-\t  cp_error (ec_destructor_specifier_must_have_matching_names,\n+\t  cp_error (\"destructor specifier `%T::~%T' must have matching names\",\n \t\t    basetype, TREE_OPERAND (component, 0));\n \t  return error_mark_node;\n \t}\n       if (! TYPE_HAS_DESTRUCTOR (basetype))\n \t{\n-\t  cp_error (ec_type_has_no_destructor, basetype);\n+\t  cp_error (\"type `%T' has no destructor\", basetype);\n \t  return error_mark_node;\n \t}\n       return TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 1);\n@@ -2056,7 +2056,7 @@ build_component_ref (datum, component, basetype_path, protect)\n     field = component;\n   else if (TREE_CODE (component) == TYPE_DECL)\n     {\n-      cp_pedwarn (ec_invalid_use_of_type_decl_as_expression, component);\n+      cp_pedwarn (\"invalid use of type decl `%#D' as expression\", component);\n       return component;\n     }\n   else\n@@ -2117,9 +2117,9 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t\t\t    datum, fndecl);\n \t\t    }\n \t\t  if (access == access_protected_node)\n-\t\t    cp_error (ec_member_function_is_protected, fndecl);\n+\t\t    cp_error (\"member function `%D' is protected\", fndecl);\n \t\t  else\n-\t\t    cp_error (ec_member_function_is_private, fndecl);\n+\t\t    cp_error (\"member function `%D' is private\", fndecl);\n \t\t  return error_mark_node;\n \t\t}\n \t      else\n@@ -2135,7 +2135,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t}\n \t    }\n \n-\t  cp_error (ec_has_no_member_named, basetype, name);\n+\t  cp_error (\"`%#T' has no member named `%D'\", basetype, name);\n \t  return error_mark_node;\n \t}\n       else if (TREE_TYPE (field) == error_mark_node)\n@@ -2144,7 +2144,7 @@ build_component_ref (datum, component, basetype_path, protect)\n       if (TREE_CODE (field) != FIELD_DECL)\n \t{\n \t  if (TREE_CODE (field) == TYPE_DECL)\n-\t    cp_pedwarn (ec_invalid_use_of_type_decl_as_expression, field);\n+\t    cp_pedwarn (\"invalid use of type decl `%#D' as expression\", field);\n \t  else if (DECL_RTL (field) != 0)\n \t    mark_used (field);\n \t  else\n@@ -2171,7 +2171,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t  tree addr = build_unary_op (ADDR_EXPR, datum, 0);\n \t  if (integer_zerop (addr))\n \t    {\n-\t      cp_error (ec_invalid_reference_to_ptr_use_ptrtomember_instead);\n+\t      error (\"invalid reference to NULL ptr, use ptr-to-member instead\");\n \t      return error_mark_node;\n \t    }\n \t  if (VBASE_NAME_P (DECL_NAME (field)))\n@@ -2300,16 +2300,16 @@ build_indirect_ref (ptr, errorstring)\n   /* `pointer' won't be an error_mark_node if we were given a\n      pointer to member, so it's cool to check for this here.  */\n   else if (TYPE_PTRMEMFUNC_P (type))\n-    cp_error (ec_invalid_use_of_s_on_pointer_to_member_function, errorstring);\n+    error (\"invalid use of `%s' on pointer to member function\", errorstring);\n   else if (TREE_CODE (type) == RECORD_TYPE\n \t   && (IS_SIGNATURE_POINTER (type) || IS_SIGNATURE_REFERENCE (type)))\n-    cp_error (ec_cannot_dereference_signature_pointerreference);\n+    error (\"cannot dereference signature pointer/reference\");\n   else if (pointer != error_mark_node)\n     {\n       if (errorstring)\n-\tcp_error (ec_invalid_type_argument_of_s, errorstring);\n+\terror (\"invalid type argument of `%s'\", errorstring);\n       else\n-\tcp_error (ec_invalid_type_argument);\n+\terror (\"invalid type argument\");\n     }\n   return error_mark_node;\n }\n@@ -2333,7 +2333,7 @@ build_array_ref (array, idx)\n {\n   if (idx == 0)\n     {\n-      cp_error (ec_subscript_missing_in_array_reference);\n+      error (\"subscript missing in array reference\");\n       return error_mark_node;\n     }\n \n@@ -2354,14 +2354,14 @@ build_array_ref (array, idx)\n \t must have done so deliberately.  */\n       if (warn_char_subscripts\n \t  && TYPE_MAIN_VARIANT (TREE_TYPE (idx)) == char_type_node)\n-\tcp_warning (ec_array_subscript_has_type_char);\n+\twarning (\"array subscript has type `char'\");\n \n       /* Apply default promotions *after* noticing character types.  */\n       idx = default_conversion (idx);\n \n       if (TREE_CODE (TREE_TYPE (idx)) != INTEGER_TYPE)\n \t{\n-\t  cp_error (ec_array_subscript_is_not_an_integer);\n+\t  error (\"array subscript is not an integer\");\n \t  return error_mark_node;\n \t}\n \n@@ -2390,7 +2390,7 @@ build_array_ref (array, idx)\n \t}\n \n       if (pedantic && !lvalue_p (array))\n-\tcp_pedwarn (ec_forbids_subscripting_nonlvalue_array);\n+\tpedwarn (\"ANSI C++ forbids subscripting non-lvalue array\");\n \n       /* Note in C++ it is valid to subscript a `register' array, since\n \t it is valid to take the address of something with that\n@@ -2401,7 +2401,7 @@ build_array_ref (array, idx)\n \t  while (TREE_CODE (foo) == COMPONENT_REF)\n \t    foo = TREE_OPERAND (foo, 0);\n \t  if (TREE_CODE (foo) == VAR_DECL && DECL_REGISTER (foo))\n-\t    cp_warning (ec_subscripting_array_declared_register);\n+\t    warning (\"subscripting array declared `register'\");\n \t}\n \n       type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (array)));\n@@ -2441,12 +2441,12 @@ build_array_ref (array, idx)\n \n     if (TREE_CODE (TREE_TYPE (ar)) != POINTER_TYPE)\n       {\n-\tcp_error (ec_subscripted_value_is_neither_array_nor_pointer);\n+\terror (\"subscripted value is neither array nor pointer\");\n \treturn error_mark_node;\n       }\n     if (TREE_CODE (TREE_TYPE (ind)) != INTEGER_TYPE)\n       {\n-\tcp_error (ec_array_subscript_is_not_an_integer);\n+\terror (\"array subscript is not an integer\");\n \treturn error_mark_node;\n       }\n \n@@ -2573,7 +2573,7 @@ build_x_function_call (function, params, decl)\n \t  /* Call via a pointer to member function.  */\n \t  if (decl == NULL_TREE)\n \t    {\n-\t      cp_error (ec_pointer_to_member_function_called_but_not_in_class_scope);\n+\t      error (\"pointer to member function called, but not in class scope\");\n \t      return error_mark_node;\n \t    }\n \t  /* What other type of POINTER_TYPE could this be? */\n@@ -2597,7 +2597,7 @@ build_x_function_call (function, params, decl)\n \t{\n \t  if (current_class_type == NULL_TREE)\n \t    {\n-\t      cp_error (ec_object_missing_in_call_to_method_s,\n+\t      error (\"object missing in call to method `%s'\",\n \t\t     IDENTIFIER_POINTER (function));\n \t      return error_mark_node;\n \t    }\n@@ -2629,7 +2629,7 @@ build_x_function_call (function, params, decl)\n     {\n       if (OVL_FUNCTION (function) == NULL_TREE)\n \t{\n-\t  cp_error (ec_function_declared_overloaded_but_no_definitions_appear_with_which_to_resolve_it,\n+\t  cp_error (\"function `%D' declared overloaded, but no definitions appear with which to resolve it?!?\",\n \t\t    TREE_PURPOSE (function));\n \t  return error_mark_node;\n \t}\n@@ -2709,9 +2709,9 @@ build_x_function_call (function, params, decl)\n \t{\n \t  if (current_function_decl\n \t      && DECL_STATIC_FUNCTION_P (current_function_decl))\n-\t    cp_error (ec_invalid_call_to_member_function_needing_this_in_static_member_function_scope);\n+\t    error (\"invalid call to member function needing `this' in static member function scope\");\n \t  else\n-\t    cp_error (ec_pointer_to_member_function_called_but_not_in_class_scope);\n+\t    error (\"pointer to member function called, but not in class scope\");\n \t  return error_mark_node;\n \t}\n       if (TREE_CODE (TREE_TYPE (decl)) != POINTER_TYPE\n@@ -2829,7 +2829,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n       if (instance_ptr == error_mark_node\n \t  && TREE_CODE (e1) != ADDR_EXPR\n \t  && TREE_CODE (TREE_OPERAND (e1, 0)) != FUNCTION_DECL)\n-\tcp_error (ec_object_missing_in, function);\n+\tcp_error (\"object missing in `%E'\", function);\n \n       function = e1;\n     }\n@@ -2867,7 +2867,7 @@ build_function_call_real (function, params, require_complete, flags)\n \n       /* Convert anything with function type to a pointer-to-function.  */\n       if (pedantic && DECL_MAIN_P (function))\n-\tcp_pedwarn (ec_forbids_calling_main_from_within_program);\n+\tpedwarn (\"ANSI C++ forbids calling `main' from within program\");\n \n       /* Differs from default_conversion by not setting TREE_ADDRESSABLE\n \t (because calling an inline function does not mean the function\n@@ -2892,7 +2892,7 @@ build_function_call_real (function, params, require_complete, flags)\n \n   if (TYPE_PTRMEMFUNC_P (fntype))\n     {\n-      cp_error (ec_must_use_or_to_call_pointertomember_function_in,\n+      cp_error (\"must use .* or ->* to call pointer-to-member function in `%E (...)'\",\n \t\tfunction);\n       return error_mark_node;\n     }\n@@ -2905,7 +2905,7 @@ build_function_call_real (function, params, require_complete, flags)\n \t|| is_method\n \t|| TREE_CODE (function) == TEMPLATE_ID_EXPR))\n     {\n-      cp_error (ec_cannot_be_used_as_a_function, function);\n+      cp_error (\"`%E' cannot be used as a function\", function);\n       return error_mark_node;\n     }\n \n@@ -3038,12 +3038,12 @@ convert_arguments (typelist, values, fndecl, flags)\n \t{\n \t  if (fndecl)\n \t    {\n-\t      cp_error_at (ec_too_many_arguments_to_s, called_thing,\n+\t      cp_error_at (\"too many arguments to %s `%+D'\", called_thing,\n \t\t\t   fndecl);\n-\t      cp_error (ec_at_this_point_in_file);\n+\t      error (\"at this point in file\");\n \t    }\n \t  else\n-\t    cp_error (ec_too_many_arguments_to_function);\n+\t    error (\"too many arguments to function\");\n \t  /* In case anybody wants to know if this argument\n \t     list is valid.  */\n \t  if (result)\n@@ -3063,10 +3063,10 @@ convert_arguments (typelist, values, fndecl, flags)\n \t  if (TREE_CODE (val) == ADDR_EXPR)\n \t    val = TREE_OPERAND (val, 0);\n \t  if (really_overloaded_fn (val))\n-\t    cp_error (ec_insufficient_type_information_to_resolve_address_of_overloaded_function,\n+\t    cp_error (\"insufficient type information to resolve address of overloaded function `%D'\",\n \t\t      DECL_NAME (get_first_fn (val)));\n \t  else\n-\t    cp_error (ec_insufficient_type_information_in_parameter_list);\n+\t    error (\"insufficient type information in parameter list\");\n \t  val = integer_zero_node;\n \t}\n       else if (TREE_CODE (val) == OFFSET_REF\n@@ -3105,7 +3105,7 @@ convert_arguments (typelist, values, fndecl, flags)\n \n \t  if (TYPE_SIZE (complete_type (type)) == 0)\n \t    {\n-\t      cp_error (ec_parameter_type_of_called_function_is_incomplete);\n+\t      error (\"parameter type of called function is incomplete\");\n \t      parmval = val;\n \t    }\n \t  else\n@@ -3166,13 +3166,13 @@ convert_arguments (typelist, values, fndecl, flags)\n \t{\n \t  if (fndecl)\n \t    {\n-\t      cp_error_at (ec_too_few_arguments, \n-\t\t\t   called_thing,\n-\t\t\t   fndecl);\n-\t      cp_error (ec_at_this_point_in_file);\n+\t      char *buf = (char *)alloca (32 + strlen (called_thing));\n+\t      sprintf (buf, \"too few arguments to %s `%%#D'\", called_thing);\n+\t      cp_error_at (buf, fndecl);\n+\t      error (\"at this point in file\");\n \t    }\n \t  else\n-\t    cp_error (ec_too_few_arguments_to_function);\n+\t    error (\"too few arguments to function\");\n \t  return error_mark_list;\n \t}\n     }\n@@ -3245,7 +3245,7 @@ build_binary_op (code, arg1, arg2, convert_p)\n    are done in the narrower type when that gives the same result).\n    Constant folding is also done before the result is returned.\n \n-   ERR_CODE is the code that determines what to say in error messages.\n+   ERROR_CODE is the code that determines what to say in error messages.\n    It is usually, but not always, the same as CODE.\n \n    Note that the operands will never have enumeral types\n@@ -3257,10 +3257,10 @@ build_binary_op (code, arg1, arg2, convert_p)\n    multiple inheritance, and deal with pointer to member functions.  */\n \n tree\n-build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n+build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n      enum tree_code code;\n      tree orig_op0, orig_op1;\n-     enum tree_code err_code;\n+     enum tree_code error_code;\n {\n   tree op0, op1;\n   register enum tree_code code0, code1;\n@@ -3380,9 +3380,9 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n \t      || code1 == COMPLEX_TYPE))\n \t{\n \t  if (TREE_CODE (op1) == INTEGER_CST && integer_zerop (op1))\n-\t    cp_warning (ec_division_by_zero_in_div, op0);\n+\t    cp_warning (\"division by zero in `%E / 0'\", op0);\n \t  else if (TREE_CODE (op1) == REAL_CST && real_zerop (op1))\n-\t    cp_warning (ec_division_by_zero_in_div, op0);\n+\t    cp_warning (\"division by zero in `%E / 0.'\", op0);\n \t      \n \t  if (!(code0 == INTEGER_TYPE && code1 == INTEGER_TYPE))\n \t    resultcode = RDIV_EXPR;\n@@ -3437,9 +3437,9 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n     case TRUNC_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n       if (code1 == INTEGER_TYPE && integer_zerop (op1))\n-\tcp_warning (ec_division_by_zero_in_mod, op0);\n+\tcp_warning (\"division by zero in `%E %% 0'\", op0);\n       else if (code1 == REAL_TYPE && real_zerop (op1))\n-\tcp_warning (ec_division_by_zero_in_mod, op0);\n+\tcp_warning (\"division by zero in `%E %% 0.'\", op0);\n       \n       if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \t{\n@@ -3474,15 +3474,15 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n \t  if (TREE_CODE (op1) == INTEGER_CST)\n \t    {\n \t      if (tree_int_cst_lt (op1, integer_zero_node))\n-\t\tcp_warning (ec_right_shift_count_is_negative);\n+\t\twarning (\"right shift count is negative\");\n \t      else\n \t\t{\n \t\t  if (TREE_INT_CST_LOW (op1) | TREE_INT_CST_HIGH (op1))\n \t\t    short_shift = 1;\n \t\t  if (TREE_INT_CST_HIGH (op1) != 0\n \t\t      || ((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (op1)\n \t\t\t  >= TYPE_PRECISION (type0)))\n-\t\t    cp_warning (ec_right_shift_count_width_of_type);\n+\t\t    warning (\"right shift count >= width of type\");\n \t\t}\n \t    }\n \t  /* Convert the shift-count to an integer, regardless of\n@@ -3501,11 +3501,11 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n \t  if (TREE_CODE (op1) == INTEGER_CST)\n \t    {\n \t      if (tree_int_cst_lt (op1, integer_zero_node))\n-\t\tcp_warning (ec_left_shift_count_is_negative);\n+\t\twarning (\"left shift count is negative\");\n \t      else if (TREE_INT_CST_HIGH (op1) != 0\n \t\t       || ((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (op1)\n \t\t\t   >= TYPE_PRECISION (type0)))\n-\t\tcp_warning (ec_left_shift_count_width_of_type);\n+\t\twarning (\"left shift count >= width of type\");\n \t    }\n \t  /* Convert the shift-count to an integer, regardless of\n \t     size of value being shifted.  */\n@@ -3524,12 +3524,12 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n \t  if (TREE_CODE (op1) == INTEGER_CST)\n \t    {\n \t      if (tree_int_cst_lt (op1, integer_zero_node))\n-\t\tcp_warning (ec_s_rotate_count_is_negative,\n+\t\twarning (\"%s rotate count is negative\",\n \t\t\t (code == LROTATE_EXPR) ? \"left\" : \"right\");\n \t      else if (TREE_INT_CST_HIGH (op1) != 0\n \t\t       || ((unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (op1)\n \t\t\t   >= TYPE_PRECISION (type0)))\n-\t\tcp_warning (ec_s_rotate_count_width_of_type,\n+\t\twarning (\"%s rotate count >= width of type\",\n \t\t\t (code == LROTATE_EXPR) ? \"left\" : \"right\");\n \t    }\n \t  /* Convert the shift-count to an integer, regardless of\n@@ -3558,18 +3558,18 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n \t    {\n \t      if (pedantic && TREE_CODE (tt1) == FUNCTION_TYPE\n \t\t  && tree_int_cst_lt (TYPE_SIZE (type0), TYPE_SIZE (type1)))\n-\t\tcp_pedwarn (ec_forbids_comparison_of_void_with_function_pointer);\n+\t\tpedwarn (\"ANSI C++ forbids comparison of `void *' with function pointer\");\n \t      else if (TREE_CODE (tt1) == OFFSET_TYPE)\n-\t\tcp_pedwarn (ec_forbids_conversion_of_a_pointer_to_member_to_void);\n+\t\tpedwarn (\"ANSI C++ forbids conversion of a pointer to member to `void *'\");\n \t    }\n \t  else if (tt1 == void_type_node)\n \t    {\n \t      if (pedantic && TREE_CODE (tt0) == FUNCTION_TYPE\n \t\t  && tree_int_cst_lt (TYPE_SIZE (type1), TYPE_SIZE (type0)))\n-\t\tcp_pedwarn (ec_forbids_comparison_of_void_with_function_pointer);\n+\t\tpedwarn (\"ANSI C++ forbids comparison of `void *' with function pointer\");\n \t    }\n \t  else\n-\t    cp_pedwarn (ec_comparison_of_distinct_pointer_types_and_lacks_a_cast,\n+\t    cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n \t\t\ttype0, type1);\n \n \t  if (result_type == NULL_TREE)\n@@ -3584,12 +3584,12 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  result_type = type0;\n-\t  cp_error (ec_forbids_comparison_between_pointer_and_integer);\n+\t  error (\"ANSI C++ forbids comparison between pointer and integer\");\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n-\t  cp_error (ec_forbids_comparison_between_pointer_and_integer);\n+\t  error (\"ANSI C++ forbids comparison between pointer and integer\");\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type0) && TREE_CODE (op1) == INTEGER_CST\n \t       && integer_zerop (op1))\n@@ -3705,7 +3705,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n \t    result_type = common_type (type0, type1);\n \t  else\n \t    {\n-\t      cp_pedwarn (ec_comparison_of_distinct_pointer_types_and_lacks_a_cast,\n+\t      cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n \t\t\t  type0, type1);\n \t      result_type = ptr_type_node;\n \t    }\n@@ -3726,7 +3726,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n \t    result_type = common_type (type0, type1);\n \t  else\n \t    {\n-\t      cp_pedwarn (ec_comparison_of_distinct_pointer_types_and_lacks_a_cast,\n+\t      cp_pedwarn (\"comparison of distinct pointer types `%T' and `%T' lacks a cast\",\n \t\t\t  type0, type1);\n \t      result_type = ptr_type_node;\n \t    }\n@@ -3740,12 +3740,12 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  result_type = type0;\n-\t  cp_pedwarn (ec_forbids_comparison_between_pointer_and_integer);\n+\t  pedwarn (\"ANSI C++ forbids comparison between pointer and integer\");\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n-\t  cp_pedwarn (ec_forbids_comparison_between_pointer_and_integer);\n+\t  pedwarn (\"ANSI C++ forbids comparison between pointer and integer\");\n \t}\n       break;\n \n@@ -3909,7 +3909,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n \t      && TYPE_MAIN_VARIANT (TREE_TYPE (orig_op0))\n \t         != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1)))\n \t    {\n-\t      cp_warning (ec_comparison_between_and, \n+\t      cp_warning (\"comparison between `%#T' and `%#T'\", \n \t\t\t  TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n \t    }\n \n@@ -3946,7 +3946,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n \t\t\t\t\t\tsigned_type (result_type)))))\n \t    /* OK */;\n \t  else\n-\t    cp_warning (ec_comparison_between_signed_and_unsigned);\n+\t    warning (\"comparison between signed and unsigned\");\n \n \t  /* Warn if two unsigned values are being compared in a size\n \t     larger than their original size, and one (and only one) is the\n@@ -3991,15 +3991,15 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n \t\t    {\n \t\t      mask = (~ (HOST_WIDE_INT) 0) << bits;\n \t\t      if ((mask & constant) != mask)\n-\t\t\tcp_warning (ec_comparison_of_promoted_unsigned_with_constant);\n+\t\t\twarning (\"comparison of promoted ~unsigned with constant\");\n \t\t    }\n \t\t}\n \t      else if (unsignedp0 && unsignedp1\n \t\t       && (TYPE_PRECISION (TREE_TYPE (primop0))\n \t\t\t   < TYPE_PRECISION (result_type))\n \t\t       && (TYPE_PRECISION (TREE_TYPE (primop1))\n \t\t\t   < TYPE_PRECISION (result_type)))\n-\t\tcp_warning (ec_comparison_of_promoted_unsigned_with_unsigned);\n+\t\twarning (\"comparison of promoted ~unsigned with unsigned\");\n \t    }\n \t}\n     }\n@@ -4012,8 +4012,8 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n \n   if (!result_type)\n     {\n-      cp_error (ec_invalid_operands_and_to_binary,\n-\t\tTREE_TYPE (orig_op0), TREE_TYPE (orig_op1), err_code);\n+      cp_error (\"invalid operands `%T' and `%T' to binary `%O'\",\n+\t\tTREE_TYPE (orig_op0), TREE_TYPE (orig_op1), error_code);\n       return error_mark_node;\n     }\n \n@@ -4034,7 +4034,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, err_code)\n        performed.  Note that pointer-difference and pointer-addition\n        have already been handled above, and so we don't end up here in\n        that case.  */\n-    cp_warning (ec_used_in_arithmetic);\n+    cp_warning (\"NULL used in arithmetic\");\n \n   if (! converted)\n     {\n@@ -4083,25 +4083,25 @@ pointer_int_sum (resultcode, ptrop, intop)\n   if (TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n-\tcp_pedwarn (ec_forbids_using_pointer_of_type_void_in_arithmetic);\n+\tpedwarn (\"ANSI C++ forbids using pointer of type `void *' in arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == FUNCTION_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n-\tcp_pedwarn (ec_forbids_using_pointer_to_a_function_in_arithmetic);\n+\tpedwarn (\"ANSI C++ forbids using pointer to a function in arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == METHOD_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n-\tcp_pedwarn (ec_forbids_using_pointer_to_a_method_in_arithmetic);\n+\tpedwarn (\"ANSI C++ forbids using pointer to a method in arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == OFFSET_TYPE)\n     {\n       if (pedantic || warn_pointer_arith)\n-\tcp_pedwarn (ec_forbids_using_pointer_to_a_member_in_arithmetic);\n+\tpedwarn (\"ANSI C++ forbids using pointer to a member in arithmetic\");\n       size_exp = integer_one_node;\n     }\n   else\n@@ -4175,13 +4175,13 @@ pointer_diff (op0, op1, ptrtype)\n   if (pedantic || warn_pointer_arith)\n     {\n       if (TREE_CODE (target_type) == VOID_TYPE)\n-\tcp_pedwarn (ec_forbids_using_pointer_of_type_void_in_subtraction);\n+\tpedwarn (\"ANSI C++ forbids using pointer of type `void *' in subtraction\");\n       if (TREE_CODE (target_type) == FUNCTION_TYPE)\n-\tcp_pedwarn (ec_forbids_using_pointer_to_a_function_in_subtraction);\n+\tpedwarn (\"ANSI C++ forbids using pointer to a function in subtraction\");\n       if (TREE_CODE (target_type) == METHOD_TYPE)\n-\tcp_pedwarn (ec_forbids_using_pointer_to_a_method_in_subtraction);\n+\tpedwarn (\"ANSI C++ forbids using pointer to a method in subtraction\");\n       if (TREE_CODE (target_type) == OFFSET_TYPE)\n-\tcp_pedwarn (ec_forbids_using_pointer_to_a_member_in_subtraction);\n+\tpedwarn (\"ANSI C++ forbids using pointer to a member in subtraction\");\n     }\n \n   /* First do the subtraction as integers;\n@@ -4192,7 +4192,7 @@ pointer_diff (op0, op1, ptrtype)\n \n   /* This generates an error if op1 is a pointer to an incomplete type.  */\n   if (TYPE_SIZE (TREE_TYPE (TREE_TYPE (op1))) == 0)\n-    cp_error (ec_arithmetic_on_pointer_to_an_incomplete_type);\n+    error (\"arithmetic on pointer to an incomplete type\");\n \n   op1 = ((TREE_CODE (target_type) == VOID_TYPE\n \t  || TREE_CODE (target_type) == FUNCTION_TYPE\n@@ -4294,7 +4294,7 @@ build_x_unary_op (code, xarg)\n   if (code == ADDR_EXPR)\n     {\n       if (TREE_CODE (xarg) == TARGET_EXPR)\n-\tcp_warning (ec_taking_address_of_temporary);\n+\twarning (\"taking address of temporary\");\n     }\n \n   return build_unary_op (code, xarg, 0);\n@@ -4477,7 +4477,7 @@ build_unary_op (code, xarg, noconvert)\n \n \t/* ARM $5.2.5 last annotation says this should be forbidden.  */\n \tif (TREE_CODE (argtype) == ENUMERAL_TYPE)\n-\t  cp_pedwarn (ec_forbids_sing_an_enum,\n+\t  pedwarn (\"ANSI C++ forbids %sing an enum\",\n \t\t   (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n \t\t   ? \"increment\" : \"decrement\");\n \t    \n@@ -4487,14 +4487,14 @@ build_unary_op (code, xarg, noconvert)\n \t  {\n \t    enum tree_code tmp = TREE_CODE (TREE_TYPE (argtype));\n \t    if (TYPE_SIZE (complete_type (TREE_TYPE (argtype))) == 0)\n-\t      cp_error (ec_cannot_s_a_pointer_to_incomplete_type,\n+\t      cp_error (\"cannot %s a pointer to incomplete type `%T'\",\n \t\t\t((code == PREINCREMENT_EXPR\n \t\t\t  || code == POSTINCREMENT_EXPR)\n \t\t\t ? \"increment\" : \"decrement\"), TREE_TYPE (argtype));\n \t    else if ((pedantic || warn_pointer_arith)\n \t\t     && (tmp == FUNCTION_TYPE || tmp == METHOD_TYPE\n \t\t\t || tmp == VOID_TYPE || tmp == OFFSET_TYPE))\n-\t      cp_pedwarn (ec_forbids_sing_a_pointer_of_type,\n+\t      cp_pedwarn (\"ANSI C++ forbids %sing a pointer of type `%T'\",\n \t\t\t  ((code == PREINCREMENT_EXPR\n \t\t\t    || code == POSTINCREMENT_EXPR)\n \t\t\t   ? \"increment\" : \"decrement\"), argtype);\n@@ -4519,7 +4519,7 @@ build_unary_op (code, xarg, noconvert)\n \t    {\n \t      tree incremented, modify, value, compound;\n \t      if (! lvalue_p (arg) && pedantic)\n-\t\tcp_pedwarn (ec_cast_to_nonreference_type_used_as_lvalue);\n+\t\tpedwarn (\"cast to non-reference type used as lvalue\");\n \t      arg = stabilize_reference (arg);\n \t      if (code == PREINCREMENT_EXPR || code == PREDECREMENT_EXPR)\n \t\tvalue = arg;\n@@ -4554,7 +4554,7 @@ build_unary_op (code, xarg, noconvert)\n \t  {\n \t    if (code == POSTDECREMENT_EXPR || code == PREDECREMENT_EXPR)\n \t      {\n-\t\tcp_error (ec_invalid_use_of_on_bool_variable, arg);\n+\t\tcp_error (\"invalid use of `--' on bool variable `%D'\", arg);\n \t\treturn error_mark_node;\n \t      }\n #if 0\n@@ -4599,7 +4599,7 @@ build_unary_op (code, xarg, noconvert)\n \t}\n       else if (pedantic && DECL_MAIN_P (arg))\n \t/* ARM $3.4 */\n-\tcp_pedwarn (ec_taking_address_of_function_main);\n+\tpedwarn (\"taking address of function `main'\");\n \n       /* Let &* cancel out to simplify resulting code.  */\n       if (TREE_CODE (arg) == INDIRECT_REF)\n@@ -4702,7 +4702,7 @@ build_unary_op (code, xarg, noconvert)\n \tcase FIX_ROUND_EXPR:\n \tcase FIX_CEIL_EXPR:\n \t  if (! lvalue_p (arg) && pedantic)\n-\t    cp_pedwarn (ec_taking_the_address_of_a_cast_to_nonreference_type);\n+\t    pedwarn (\"taking the address of a cast to non-reference type\");\n \t  break;\n \t  \n \tdefault:\n@@ -4859,7 +4859,7 @@ unary_complex_lvalue (code, arg)\n       if (TREE_CODE (t) == FUNCTION_DECL)\n \t{\n \t  if (DECL_DESTRUCTOR_P (t))\n-\t    cp_error (ec_taking_address_of_destructor);\n+\t    cp_error (\"taking address of destructor\");\n \t  return build_unary_op (ADDR_EXPR, t, 0);\n \t}\n       if (TREE_CODE (t) == VAR_DECL)\n@@ -4956,7 +4956,7 @@ mark_addressable (exp)\n \tif (x == current_class_ptr)\n \t  {\n \t    if (! flag_this_is_variable)\n-\t      cp_error (ec_address_of_this_not_available);\n+\t      error (\"address of `this' not available\");\n \t    TREE_ADDRESSABLE (x) = 1; /* so compiler doesn't die later */\n \t    put_var_into_stack (x);\n \t    return 1;\n@@ -4992,7 +4992,7 @@ mark_addressable (exp)\n       case RESULT_DECL:\n \tif (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x)\n \t    && !DECL_ARTIFICIAL (x) && extra_warnings)\n-\t  cp_warning (ec_address_requested_for_which_is_declared_register,\n+\t  cp_warning (\"address requested for `%D', which is declared `register'\",\n \t\t      x);\n \tput_var_into_stack (x);\n \tTREE_ADDRESSABLE (x) = 1;\n@@ -5054,7 +5054,7 @@ build_conditional_expr (ifexp, op1, op2)\n   if (op1 == 0)\n     {\n       if (pedantic)\n-\tcp_pedwarn (ec_forbids_omitting_the_middle_term_of_a_expression);\n+\tpedwarn (\"ANSI C++ forbids omitting the middle term of a ?: expression\");\n       ifexp = op1 = save_expr (ifexp);\n     }\n \n@@ -5141,18 +5141,18 @@ build_conditional_expr (ifexp, op1, op2)\n     {\n       if (code2 == ENUMERAL_TYPE)\n \t{\n-\t  cp_error (ec_enumeral_mismatch_in_conditional_expression_vs,\n+\t  cp_error (\"enumeral mismatch in conditional expression: `%T' vs `%T'\",\n \t\t    type1, type2);\n \t  return error_mark_node;\n \t}\n       else if (extra_warnings && ! IS_AGGR_TYPE_CODE (code2)\n \t       && type2 != type_promotes_to (type1))\n-\tcp_warning (ec_enumeral_and_nonenumeral_type_in_conditional_expression);\n+\twarning (\"enumeral and non-enumeral type in conditional expression\");\n     }\n   else if (extra_warnings\n \t   && code2 == ENUMERAL_TYPE && ! IS_AGGR_TYPE_CODE (code1)\n \t   && type1 != type_promotes_to (type2))\n-    cp_warning (ec_enumeral_and_nonenumeral_type_in_conditional_expression);\n+    warning (\"enumeral and non-enumeral type in conditional expression\");\n \n   if (code1 != VOID_TYPE)\n     {\n@@ -5203,7 +5203,7 @@ build_conditional_expr (ifexp, op1, op2)\n   else if (code1 == VOID_TYPE || code2 == VOID_TYPE)\n     {\n       if (pedantic && (code1 != VOID_TYPE || code2 != VOID_TYPE))\n-\tcp_pedwarn (ec_forbids_conditional_expr_with_only_one_void_side);\n+\tpedwarn (\"ANSI C++ forbids conditional expr with only one void side\");\n       result_type = void_type_node;\n     }\n   else if (code1 == POINTER_TYPE && null_ptr_cst_p (op2))\n@@ -5217,13 +5217,13 @@ build_conditional_expr (ifexp, op1, op2)\n       else if (TYPE_MAIN_VARIANT (TREE_TYPE (type1)) == void_type_node)\n \t{\n \t  if (pedantic && TREE_CODE (type2) == FUNCTION_TYPE)\n-\t    cp_pedwarn (ec_forbids_conditional_expr_between_void_and_function_pointer);\n+\t    pedwarn (\"ANSI C++ forbids conditional expr between `void *' and function pointer\");\n \t  result_type = qualify_type (type1, type2);\n \t}\n       else if (TYPE_MAIN_VARIANT (TREE_TYPE (type2)) == void_type_node)\n \t{\n \t  if (pedantic && TREE_CODE (type1) == FUNCTION_TYPE)\n-\t    cp_pedwarn (ec_forbids_conditional_expr_between_void_and_function_pointer);\n+\t    pedwarn (\"ANSI C++ forbids conditional expr between `void *' and function pointer\");\n \t  result_type = qualify_type (type2, type1);\n \t}\n       /* C++ */\n@@ -5236,7 +5236,7 @@ build_conditional_expr (ifexp, op1, op2)\n \t{\n \t  if (result_type == error_mark_node)\n \t    {\n-\t      cp_error (ec_common_base_type_of_types_and_is_ambiguous,\n+\t      cp_error (\"common base type of types `%T' and `%T' is ambiguous\",\n \t\t\tTREE_TYPE (type1), TREE_TYPE (type2));\n \t      result_type = ptr_type_node;\n \t    }\n@@ -5245,26 +5245,26 @@ build_conditional_expr (ifexp, op1, op2)\n \t      if (pedantic\n \t\t  && result_type != TREE_TYPE (type1)\n \t\t  && result_type != TREE_TYPE (type2))\n-\t\tcp_pedwarn (ec_and_converted_to_in_conditional_expression,\n+\t\tcp_pedwarn (\"`%T' and `%T' converted to `%T *' in conditional expression\",\n \t\t\t    type1, type2, result_type);\n \n \t      result_type = build_pointer_type (result_type);\n \t    }\n \t}\n       else\n \t{\n-\t  cp_pedwarn (ec_pointer_type_mismatch_in_conditional_expression);\n+\t  pedwarn (\"pointer type mismatch in conditional expression\");\n \t  result_type = ptr_type_node;\n \t}\n     }\n   else if (code1 == POINTER_TYPE && code2 == INTEGER_TYPE)\n     {\n-      cp_pedwarn (ec_pointerinteger_type_mismatch_in_conditional_expression);\n+      pedwarn (\"pointer/integer type mismatch in conditional expression\");\n       result_type = type1;\n     }\n   else if (code2 == POINTER_TYPE && code1 == INTEGER_TYPE)\n     {\n-      cp_pedwarn (ec_pointerinteger_type_mismatch_in_conditional_expression);\n+      pedwarn (\"pointer/integer type mismatch in conditional expression\");\n       result_type = type2;\n     }\n \n@@ -5274,7 +5274,7 @@ build_conditional_expr (ifexp, op1, op2)\n \t an aggregate value, try converting to a scalar type.  */\n       if (code1 == RECORD_TYPE && code2 == RECORD_TYPE)\n \t{\n-\t  cp_error (ec_aggregate_mismatch_in_conditional_expression_vs,\n+\t  cp_error (\"aggregate mismatch in conditional expression: `%T' vs `%T'\",\n \t\t    type1, type2);\n \t  return error_mark_node;\n \t}\n@@ -5292,12 +5292,12 @@ build_conditional_expr (ifexp, op1, op2)\n \t  tmp = build_type_conversion (CONVERT_EXPR, tmp, op1, 0);\n \t  if (tmp == NULL_TREE)\n \t    {\n-\t      cp_error (ec_incompatible_types_and_in,\n+\t      cp_error (\"incompatible types `%T' and `%T' in `?:'\",\n \t\t\ttype1, type2);\n \t      return error_mark_node;\n \t    }\n \t  if (tmp == error_mark_node)\n-\t    cp_error (ec_ambiguous_pointer_conversion);\n+\t    error (\"ambiguous pointer conversion\");\n \t  else\n \t    STRIP_NOPS (tmp);\n \t  result_type = common_type (type2, TREE_TYPE (tmp));\n@@ -5315,12 +5315,12 @@ build_conditional_expr (ifexp, op1, op2)\n \t  tmp = build_type_conversion (CONVERT_EXPR, tmp, op2, 0);\n \t  if (tmp == NULL_TREE)\n \t    {\n-\t      cp_error (ec_incompatible_types_and_in,\n+\t      cp_error (\"incompatible types `%T' and `%T' in `?:'\",\n \t\t\ttype1, type2);\n \t      return error_mark_node;\n \t    }\n \t  if (tmp == error_mark_node)\n-\t    cp_error (ec_ambiguous_pointer_conversion);\n+\t    error (\"ambiguous pointer conversion\");\n \t  else\n \t    STRIP_NOPS (tmp);\n \t  result_type = common_type (type1, TREE_TYPE (tmp));\n@@ -5330,7 +5330,7 @@ build_conditional_expr (ifexp, op1, op2)\n \tresult_type = void_type_node;\n       else\n \t{\n-\t  cp_error (ec_type_mismatch_in_conditional_expression);\n+\t  error (\"type mismatch in conditional expression\");\n \t  return error_mark_node;\n \t}\n     }\n@@ -5383,7 +5383,7 @@ build_x_compound_expr (list)\n       if ((extra_warnings || warn_unused)\n            && !(TREE_CODE (TREE_VALUE(list)) == CONVERT_EXPR\n                 && TREE_TYPE (TREE_VALUE(list)) == void_type_node))\n-        cp_warning (ec_lefthand_operand_of_comma_expression_has_no_effect);\n+        warning(\"left-hand operand of comma expression has no effect\");\n     }\n #if 0 /* this requires a gcc backend patch to export warn_if_unused_value */\n   else if (warn_unused)\n@@ -5523,7 +5523,7 @@ build_static_cast (type, expr)\n   if (ok)\n     return build_c_cast (type, expr);\n \n-  cp_error (ec_static_cast_from_to, intype, type);\n+  cp_error (\"static_cast from `%T' to `%T'\", intype, type);\n   return error_mark_node;\n }\n \n@@ -5570,7 +5570,7 @@ build_reinterpret_cast (type, expr)\n     {\n       if (! real_lvalue_p (expr))\n \t{\n-\t  cp_error (ec_reinterpret_cast_from_rvalue_to, intype, type);\n+\t  cp_error (\"reinterpret_cast from `%T' rvalue to `%T'\", intype, type);\n \t  return error_mark_node;\n \t}\n       expr = build_unary_op (ADDR_EXPR, expr, 0);\n@@ -5590,7 +5590,7 @@ build_reinterpret_cast (type, expr)\n   else if (TREE_CODE (type) == INTEGER_TYPE && TYPE_PTR_P (intype))\n     {\n       if (TYPE_PRECISION (type) < TYPE_PRECISION (intype))\n-\tcp_pedwarn (ec_reinterpret_cast_from_to_loses_precision,\n+\tcp_pedwarn (\"reinterpret_cast from `%T' to `%T' loses precision\",\n \t\t    intype, type);\n     }\n   else if ((TYPE_PTRFN_P (type) && TYPE_PTRFN_P (intype))\n@@ -5604,7 +5604,7 @@ build_reinterpret_cast (type, expr)\n \t   || (TYPE_PTROBV_P (type) && TYPE_PTROBV_P (intype)))\n     {\n       if (! comp_ptr_ttypes_reinterpret (TREE_TYPE (type), TREE_TYPE (intype)))\n-\tcp_pedwarn (ec_reinterpret_cast_from_to_casts_away_const_or_volatile,\n+\tcp_pedwarn (\"reinterpret_cast from `%T' to `%T' casts away const (or volatile)\",\n \t\t    intype, type);\n \n       if (TREE_READONLY_DECL_P (expr))\n@@ -5614,14 +5614,14 @@ build_reinterpret_cast (type, expr)\n   else if ((TYPE_PTRFN_P (type) && TYPE_PTROBV_P (intype))\n \t   || (TYPE_PTRFN_P (type) && TYPE_PTROBV_P (intype)))\n     {\n-      cp_pedwarn (ec_forbids_casting_between_pointers_to_functions_and_objects);\n+      pedwarn (\"ANSI C++ forbids casting between pointers to functions and objects\");\n       if (TREE_READONLY_DECL_P (expr))\n \texpr = decl_constant_value (expr);\n       return fold (build1 (NOP_EXPR, type, expr));\n     }\n   else\n     {\n-      cp_error (ec_reinterpret_cast_from_to, intype, type);\n+      cp_error (\"reinterpret_cast from `%T' to `%T'\", intype, type);\n       return error_mark_node;\n     }\n       \n@@ -5673,7 +5673,7 @@ build_const_cast (type, expr)\n     {\n       if (! real_lvalue_p (expr))\n \t{\n-\t  cp_error (ec_const_cast_from_rvalue_to, intype, type);\n+\t  cp_error (\"const_cast from `%T' rvalue to `%T'\", intype, type);\n \t  return error_mark_node;\n \t}\n \n@@ -5689,7 +5689,7 @@ build_const_cast (type, expr)\n \t   && comp_ptr_ttypes_const (TREE_TYPE (type), TREE_TYPE (intype)))\n     return cp_convert (type, expr);\n \n-  cp_error (ec_const_cast_from_to, intype, type);\n+  cp_error (\"const_cast from `%T' to `%T'\", intype, type);\n   return error_mark_node;\n }\n \n@@ -5727,26 +5727,26 @@ build_c_cast (type, expr)\n       if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n \t{\n \t  if (pedantic)\n-\t    cp_pedwarn (ec_forbids_casting_to_an_array_type);\n+\t    pedwarn (\"ANSI C++ forbids casting to an array type\");\n \t  type = build_pointer_type (TREE_TYPE (type));\n \t}\n       else\n \t{\n-\t  cp_error (ec_forbids_casting_to_an_array_type);\n+\t  error (\"ANSI C++ forbids casting to an array type\");\n \t  return error_mark_node;\n \t}\n     }\n \n   if (TREE_CODE (type) == FUNCTION_TYPE\n       || TREE_CODE (type) == METHOD_TYPE)\n     {\n-      cp_error (ec_casting_to_function_type, type);\n+      cp_error (\"casting to function type `%T'\", type);\n       return error_mark_node;\n     }\n \n   if (IS_SIGNATURE (type))\n     {\n-      cp_error (ec_cast_specifies_signature_type);\n+      error (\"cast specifies signature type\");\n       return error_mark_node;\n     }\n \n@@ -5815,10 +5815,10 @@ build_c_cast (type, expr)\n \t     softening them into pedwarns.  */\n \t  if (TYPE_VOLATILE (TREE_TYPE (otype))\n \t      && ! TYPE_VOLATILE (TREE_TYPE (type)))\n-\t    cp_warning (ec_cast_discards_volatile_from_pointer_target_type);\n+\t    warning (\"cast discards `volatile' from pointer target type\");\n \t  if (TYPE_READONLY (TREE_TYPE (otype))\n \t      && ! TYPE_READONLY (TREE_TYPE (type)))\n-\t    cp_warning (ec_cast_discards_const_from_pointer_target_type);\n+\t    warning (\"cast discards `const' from pointer target type\");\n \t}\n \n       /* Warn about possible alignment problems.  */\n@@ -5828,23 +5828,23 @@ build_c_cast (type, expr)\n \t  && TREE_CODE (TREE_TYPE (otype)) != VOID_TYPE\n \t  && TREE_CODE (TREE_TYPE (otype)) != FUNCTION_TYPE\n \t  && TYPE_ALIGN (TREE_TYPE (type)) > TYPE_ALIGN (TREE_TYPE (otype)))\n-\tcp_warning (ec_cast_increases_required_alignment_of_target_type);\n+\twarning (\"cast increases required alignment of target type\");\n \n #if 0\n       /* We should see about re-enabling these, they seem useful to\n          me.  */\n       if (TREE_CODE (type) == INTEGER_TYPE\n \t  && TREE_CODE (otype) == POINTER_TYPE\n \t  && TYPE_PRECISION (type) != TYPE_PRECISION (otype))\n-\tcp_warning (ec_cast_from_pointer_to_integer_of_different_size);\n+\twarning (\"cast from pointer to integer of different size\");\n \n       if (TREE_CODE (type) == POINTER_TYPE\n \t  && TREE_CODE (otype) == INTEGER_TYPE\n \t  && TYPE_PRECISION (type) != TYPE_PRECISION (otype)\n \t  /* Don't warn about converting 0 to pointer,\n \t     provided the 0 was explicit--not cast or made by folding.  */\n \t  && !(TREE_CODE (value) == INTEGER_CST && integer_zerop (value)))\n-\tcp_warning (ec_cast_to_pointer_from_integer_of_different_size);\n+\twarning (\"cast to pointer from integer of different size\");\n #endif\n \n       if (TREE_CODE (type) == REFERENCE_TYPE)\n@@ -5983,7 +5983,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t    lhs = member;\n \t  else\n \t    {\n-\t      cp_compiler_error (ec_invalid_static_class_member);\n+\t      compiler_error (\"invalid static class member\");\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -6042,7 +6042,7 @@ build_modify_expr (lhs, modifycode, rhs)\n       newrhs = build_binary_op (modifycode, lhs, rhs, 1);\n       if (newrhs == error_mark_node)\n \t{\n-\t  cp_error (ec_in_evaluation_of, modifycode,\n+\t  cp_error (\"  in evaluation of `%Q(%#T, %#T)'\", modifycode,\n \t\t    TREE_TYPE (lhs), TREE_TYPE (rhs));\n \t  return error_mark_node;\n \t}\n@@ -6076,7 +6076,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t/* WP 5.4.1:  The result is an lvalue if T is a reference type,\n \t   otherwise the result is an rvalue.   */\n \tif (! lvalue_p (lhs))\n-\t  cp_pedwarn (ec_forbids_cast_to_nonreference_type_used_as_lvalue);\n+\t  pedwarn (\"ANSI C++ forbids cast to non-reference type used as lvalue\");\n \n \tresult = build_modify_expr (inner_lhs, NOP_EXPR,\n \t\t\t\t    cp_convert (TREE_TYPE (inner_lhs),\n@@ -6143,7 +6143,7 @@ build_modify_expr (lhs, modifycode, rhs)\n \t  && DECL_NAME (current_function_decl) != NULL_TREE\n \t  && (DECL_NAME (current_function_decl)\n \t      != constructor_name (current_class_type)))\n-\tcp_warning (ec_assignment_to_this_not_in_constructor_or_destructor);\n+\twarning (\"assignment to `this' not in constructor or destructor\");\n       current_function_just_assigned_this = 1;\n     }\n \n@@ -6197,14 +6197,14 @@ build_modify_expr (lhs, modifycode, rhs)\n       \n       if (! comptypes (lhstype, TREE_TYPE (rhs), 0))\n \t{\n-\t  cp_error (ec_incompatible_types_in_assignment_of_to,\n+\t  cp_error (\"incompatible types in assignment of `%T' to `%T'\",\n \t\t    TREE_TYPE (rhs), lhstype);\n \t  return error_mark_node;\n \t}\n \n       /* Allow array assignment in compiler-generated code.  */\n       if (pedantic && ! DECL_ARTIFICIAL (current_function_decl))\n-\tcp_pedwarn (ec_forbids_assignment_of_arrays);\n+\tpedwarn (\"ANSI C++ forbids assignment of arrays\");\n \n       /* Have to wrap this in RTL_EXPR for two cases:\n \t in base or member initialization and if we\n@@ -6241,7 +6241,7 @@ build_modify_expr (lhs, modifycode, rhs)\n       if (lhs == DECL_RESULT (current_function_decl))\n \t{\n \t  if (DECL_INITIAL (lhs))\n-\t    cp_warning (ec_return_value_from_function_receives_multiple_initializations);\n+\t    warning (\"return value from function receives multiple initializations\");\n \t  DECL_INITIAL (lhs) = newrhs;\n \t}\n     }\n@@ -6388,15 +6388,15 @@ get_delta_difference (from, to, force)\n   binfo = get_binfo (from, to, 1);\n   if (binfo == error_mark_node)\n     {\n-      cp_error (ec_in_pointer_to_member_function_conversion);\n+      error (\"   in pointer to member function conversion\");\n       return delta;\n     }\n   if (binfo == 0)\n     {\n       if (!force)\n \t{\n \t  error_not_base_type (from, to);\n-\t  cp_error (ec_in_pointer_to_member_conversion);\n+\t  error (\"   in pointer to member conversion\");\n \t  return delta;\n \t}\n       binfo = get_binfo (to, from, 1);\n@@ -6406,9 +6406,9 @@ get_delta_difference (from, to, force)\n \t{\n \t  binfo = binfo_member (BINFO_TYPE (binfo),\n \t\t\t\tCLASSTYPE_VBASECLASSES (from));\n-\t  cp_warning (ec_pointer_to_member_cast_to_virtual_base,\n+\t  cp_warning (\"pointer to member cast to virtual base `%T'\",\n \t\t      BINFO_TYPE (binfo));\n-\t  cp_warning (ec_will_only_work_if_you_are_very_careful);\n+\t  warning (\"  will only work if you are very careful\");\n \t}\n       delta = BINFO_OFFSET (binfo);\n       delta = cp_convert (ptrdiff_type_node, delta);\n@@ -6422,12 +6422,12 @@ get_delta_difference (from, to, force)\n     {\n       if (force)\n \t{\n-\t  cp_warning (ec_pointer_to_member_cast_from_virtual_base,\n+\t  cp_warning (\"pointer to member cast from virtual base `%T'\",\n \t\t      BINFO_TYPE (binfo));\n-\t  cp_warning (ec_will_only_work_if_you_are_very_careful);\n+\t  warning (\"  will only work if you are very careful\");\n \t}\n       else\n-\tcp_error (ec_pointer_to_member_conversion_from_virtual_base,\n+\tcp_error (\"pointer to member conversion from virtual base `%T'\",\n \t\t  BINFO_TYPE (binfo));\n     }\n \n@@ -6543,7 +6543,7 @@ build_ptrmemfunc (type, pfn, force)\n       pfn_type = TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn));\n       if (!force\n \t  && comp_target_types (type, pfn_type, 1) != 1)\n-\tcp_error (ec_conversion_to_from, type, pfn_type);\n+\tcp_error (\"conversion to `%T' from `%T'\", type, pfn_type);\n \n       ndelta = cp_convert (ptrdiff_type_node, build_component_ref (pfn, delta_identifier, NULL_TREE, 0));\n       ndelta2 = cp_convert (ptrdiff_type_node, DELTA2_FROM_PTRMEMFUNC (pfn));\n@@ -6585,7 +6585,7 @@ build_ptrmemfunc (type, pfn, force)\n \n   if (!force \n       && comp_target_types (type, TREE_TYPE (pfn), 0) != 1)\n-    cp_error (ec_conversion_to_from, type, TREE_TYPE (pfn));\n+    cp_error (\"conversion to `%T' from `%T'\", type, TREE_TYPE (pfn));\n \n   /* Allow pointer to member conversions here.  */\n   delta = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TREE_TYPE (pfn))),\n@@ -6594,7 +6594,7 @@ build_ptrmemfunc (type, pfn, force)\n   delta2 = build_binary_op (PLUS_EXPR, delta2, delta, 1);\n \n   if (TREE_CODE (TREE_OPERAND (pfn, 0)) != FUNCTION_DECL)\n-    cp_warning (ec_assuming_pointer_to_member_function_is_nonvirtual);\n+    warning (\"assuming pointer to member function is non-virtual\");\n \n   if (TREE_CODE (TREE_OPERAND (pfn, 0)) == FUNCTION_DECL\n       && DECL_VINDEX (TREE_OPERAND (pfn, 0)))\n@@ -6655,7 +6655,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \n   /* Issue warnings about peculiar, but legal, uses of NULL.  */\n   if (ARITHMETIC_TYPE_P (type) && rhs == null_node)\n-    cp_warning (ec_converting_null_to_nonpointer_type);\n+    cp_warning (\"converting NULL to non-pointer type\");\n \n   if (coder == UNKNOWN_TYPE)\n     rhs = instantiate_type (type, rhs, 1);\n@@ -6712,7 +6712,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \n   if (coder == VOID_TYPE)\n     {\n-      cp_error (ec_void_value_not_ignored_as_it_ought_to_be);\n+      error (\"void value not ignored as it ought to be\");\n       return error_mark_node;\n     }\n   /* Arithmetic types all interconvert.  */\n@@ -6725,10 +6725,10 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n       if (coder == REAL_TYPE && codel == INTEGER_TYPE)\n \t{\n \t  if (fndecl)\n-\t    cp_warning (ec_used_for_argument_of,\n+\t    cp_warning (\"`%T' used for argument %P of `%D'\",\n \t\t\trhstype, parmnum, fndecl);\n \t  else\n-\t    cp_warning (ec_s_to_from, errtype, type, rhstype);\n+\t    cp_warning (\"%s to `%T' from `%T'\", errtype, type, rhstype);\n \t}\n       /* And we should warn if assigning a negative value to\n \t an unsigned variable.  */\n@@ -6738,10 +6738,10 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t      && TREE_NEGATED_INT (rhs))\n \t    {\n \t      if (fndecl)\n-\t\tcp_warning (ec_negative_value_passed_as_argument_of,\n+\t\tcp_warning (\"negative value `%E' passed as argument %P of `%D'\",\n \t\t\t    rhs, parmnum, fndecl);\n \t      else\n-\t\tcp_warning (ec_s_of_negative_value_to,\n+\t\tcp_warning (\"%s of negative value `%E' to `%T'\",\n \t\t\t    errtype, rhs, type);\n \t    }\n \t  overflow_warning (rhs);\n@@ -6799,19 +6799,19 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t  if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n \t    {\n \t      if (fndecl)\n-\t\tcp_pedwarn (ec_passing_as_argument_of_discards_const,\n+\t\tcp_pedwarn (\"passing `%T' as argument %P of `%D' discards const\",\n \t\t\t    rhstype, parmnum, fndecl);\n \t      else\n-\t\tcp_pedwarn (ec_s_to_from_discards_const,\n+\t\tcp_pedwarn (\"%s to `%T' from `%T' discards const\",\n \t\t\t    errtype, type, rhstype);\n \t    }\n \t  if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n \t    {\n \t      if (fndecl)\n-\t\tcp_pedwarn (ec_passing_as_argument_of_discards_volatile,\n+\t\tcp_pedwarn (\"passing `%T' as argument %P of `%D' discards volatile\",\n \t\t\t    rhstype, parmnum, fndecl);\n \t      else\n-\t\tcp_pedwarn (ec_s_to_from_discards_volatile,\n+\t\tcp_pedwarn (\"%s to `%T' from `%T' discards volatile\",\n \t\t\t    errtype, type, rhstype);\n \t    }\n \t}\n@@ -6829,23 +6829,23 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t  if (TYPE_MAIN_VARIANT (ttl) == void_type_node\n \t      && TREE_CODE (ttr) == OFFSET_TYPE)\n \t    {\n-\t      cp_error (ec_no_standard_conversion_from_to_void, ttr);\n+\t      cp_error (\"no standard conversion from `%T' to `void *'\", ttr);\n \t      return error_mark_node;\n \t    }\n \n \t  if (ctt < 0 && TYPE_MAIN_VARIANT (ttl) != TYPE_MAIN_VARIANT (ttr))\n-\t    cp_pedwarn (ec_converting_to_is_a_contravariance_violation,\n+\t    cp_pedwarn (\"converting `%T' to `%T' is a contravariance violation\",\n \t\t\trhstype, type);\n \n \t  if (TYPE_MAIN_VARIANT (ttl) != void_type_node\n \t      && TYPE_MAIN_VARIANT (ttr) == void_type_node\n \t      && ! null_ptr_cst_p (rhs))\n \t    {\n \t      if (coder == RECORD_TYPE)\n-\t\tcp_pedwarn (ec_implicit_conversion_of_signature_pointer_to_type,\n+\t\tcp_pedwarn (\"implicit conversion of signature pointer to type `%T'\",\n \t\t\t    type);\n \t      else\n-\t\tcp_pedwarn (ec_forbids_implicit_conversion_from_void_in_s,\n+\t\tpedwarn (\"ANSI C++ forbids implicit conversion from `void *' in %s\",\n \t\t\t errtype);\n \t    }\n \t  /* Const and volatile mean something different for function types,\n@@ -6857,37 +6857,37 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\t  && binfo_member (TYPE_OFFSET_BASETYPE (ttr),\n \t\t\t\t   CLASSTYPE_VBASECLASSES (TYPE_OFFSET_BASETYPE (ttl))))\n \t\t{\n-\t\t  cp_error (ec_s_between_pointer_to_members_converting_across_virtual_baseclasses, errtype);\n+\t\t  error (\"%s between pointer to members converting across virtual baseclasses\", errtype);\n \t\t  return error_mark_node;\n \t\t}\n \t      else if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n \t\t{\n \t\t  if (string_conv_p (type, rhs, 1))\n \t\t    /* converting from string constant to char *, OK.  */;\n \t\t  else if (fndecl)\n-\t\t    cp_pedwarn (ec_passing_as_argument_of_discards_const,\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards const\",\n \t\t\t\trhstype, parmnum, fndecl);\n \t\t  else\n-\t\t    cp_pedwarn (ec_s_to_from_discards_const,\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' discards const\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n \t      else if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n \t\t{\n \t\t  if (fndecl)\n-\t\t    cp_pedwarn (ec_passing_as_argument_of_discards_volatile,\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards volatile\",\n \t\t\t\trhstype, parmnum, fndecl);\n \t\t  else\n-\t\t    cp_pedwarn (ec_s_to_from_discards_volatile,\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' discards volatile\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n \t      else if (TREE_CODE (ttl) == TREE_CODE (ttr)\n \t\t       && ! comp_target_types (type, rhstype, 1))\n \t\t{\n \t\t  if (fndecl)\n-\t\t    cp_pedwarn (ec_passing_as_argument_of_changes_signedness,\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' changes signedness\",\n \t\t\t\trhstype, parmnum, fndecl);\n \t\t  else\n-\t\t    cp_pedwarn (ec_s_to_from_changes_signedness,\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' changes signedness\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n \t    }\n@@ -6930,46 +6930,46 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t      if (add_quals)\n \t\t{\n \t\t  if (fndecl)\n-\t\t    cp_pedwarn (ec_passing_as_argument_of_adds_cvquals_without_intervening_const,\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' adds cv-quals without intervening `const'\",\n \t\t\t\trhstype, parmnum, fndecl);\n \t\t  else\n-\t\t    cp_pedwarn (ec_s_to_from_adds_cvquals_without_intervening_const,\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' adds cv-quals without intervening `const'\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n \t      if (const_parity)\n \t\t{\n \t\t  if (fndecl)\n-\t\t    cp_pedwarn (ec_passing_as_argument_of_discards_const,\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards const\",\n \t\t\t\trhstype, parmnum, fndecl);\n \t\t  else\n-\t\t    cp_pedwarn (ec_s_to_from_discards_const,\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' discards const\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n \t      if (volatile_parity)\n \t\t{\n \t\t  if (fndecl)\n-\t\t    cp_pedwarn (ec_passing_as_argument_of_discards_volatile,\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' discards volatile\",\n \t\t\t\trhstype, parmnum, fndecl);\n \t\t  else\n-\t\t    cp_pedwarn (ec_s_to_from_discards_volatile,\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' discards volatile\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n \t      if (unsigned_parity > 0)\n \t\t{\n \t\t  if (fndecl)\n-\t\t    cp_pedwarn (ec_passing_as_argument_of_changes_signed_to_unsigned,\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' changes signed to unsigned\",\n \t\t\t\trhstype, parmnum, fndecl);\n \t\t  else\n-\t\t    cp_pedwarn (ec_s_to_from_changes_signed_to_unsigned,\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' changes signed to unsigned\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n \t      else if (unsigned_parity < 0)\n \t\t{\n \t\t  if (fndecl)\n-\t\t    cp_pedwarn (ec_passing_as_argument_of_changes_unsigned_to_signed,\n+\t\t    cp_pedwarn (\"passing `%T' as argument %P of `%D' changes unsigned to signed\",\n \t\t\t\trhstype, parmnum, fndecl);\n \t\t  else\n-\t\t    cp_pedwarn (ec_s_to_from_changes_unsigned_to_signed,\n+\t\t    cp_pedwarn (\"%s to `%T' from `%T' changes unsigned to signed\",\n \t\t\t\terrtype, type, rhstype);\n \t\t}\n \n@@ -6979,17 +6979,17 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\t  || TREE_CODE (ttl) == METHOD_TYPE)\n \t\tif (! comptypes (ttl, ttr, 0))\n \t\t  {\n-\t\t    cp_warning (ec_conflicting_function_types_in_s, errtype);\n-\t\t    cp_warning (ec_t, type, rhstype);\n+\t\t    warning (\"conflicting function types in %s:\", errtype);\n+\t\t    cp_warning (\"\\t`%T' != `%T'\", type, rhstype);\n \t\t  }\n \t    }\n \t  else\n \t    {\n \t      if (fndecl)\n-\t\tcp_error (ec_passing_as_argument_of,\n+\t\tcp_error (\"passing `%T' as argument %P of `%D'\",\n \t\t\t  rhstype, parmnum, fndecl);\n \t      else\n-\t\tcp_error (ec_s_to_from, errtype, type, rhstype);\n+\t\tcp_error (\"%s to `%T' from `%T'\", errtype, type, rhstype);\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -7002,10 +7002,10 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n       if (! (TREE_CODE (rhs) == INTEGER_CST && integer_zerop (rhs)))\n \t{\n \t  if (fndecl)\n-\t    cp_pedwarn (ec_passing_to_argument_of_lacks_a_cast,\n+\t    cp_pedwarn (\"passing `%T' to argument %P of `%D' lacks a cast\",\n \t\t\trhstype, parmnum, fndecl);\n \t  else\n-\t    cp_pedwarn (ec_s_to_from_lacks_a_cast,\n+\t    cp_pedwarn (\"%s to `%T' from `%T' lacks a cast\",\n \t\t\terrtype, type, rhstype);\n \t}\n       return cp_convert (type, rhs);\n@@ -7018,10 +7018,10 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\t       || IS_SIGNATURE_REFERENCE (rhstype)))))\n     {\n       if (fndecl)\n-\tcp_pedwarn (ec_passing_to_argument_of_lacks_a_cast,\n+\tcp_pedwarn (\"passing `%T' to argument %P of `%D' lacks a cast\",\n \t\t    rhstype, parmnum, fndecl);\n       else\n-\tcp_pedwarn (ec_s_to_from_lacks_a_cast,\n+\tcp_pedwarn (\"%s to `%T' from `%T' lacks a cast\",\n \t\t    errtype, type, rhstype);\n       return cp_convert (type, rhs);\n     }\n@@ -7048,10 +7048,10 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\t : comp_target_types (ttl, ttr, 1));\n \n       if (ctt < 0)\n-\tcp_pedwarn (ec_converting_to_is_a_contravariance_violation,\n+\tcp_pedwarn (\"converting `%T' to `%T' is a contravariance violation\",\n \t\t    ttr, ttl);\n       else if (ctt == 0)\n-\tcp_error (ec_s_to_from, errtype, ttl, ttr);\n+\tcp_error (\"%s to `%T' from `%T'\", errtype, ttl, ttr);\n \n       /* compatible pointer to member functions.  */\n       return build_ptrmemfunc (ttl, rhs, 0);\n@@ -7080,7 +7080,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t   && TYPE_PTRMEMFUNC_P (TREE_TYPE (rhs)))\n     return cp_convert (type, rhs);\n \n-  cp_error (ec_s_to_from, errtype, type, rhstype);\n+  cp_error (\"%s to `%T' from `%T'\", errtype, type, rhstype);\n   return error_mark_node;\n }\n \n@@ -7170,9 +7170,9 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n       if (fndecl)\n \t{\n \t  if (warningcount > savew)\n-\t    cp_warning_at (ec_in_passing_argument_of, parmnum, fndecl);\n+\t    cp_warning_at (\"in passing argument %P of `%+D'\", parmnum, fndecl);\n \t  else if (errorcount > savee)\n-\t    cp_error_at (ec_in_passing_argument_of, parmnum, fndecl);\n+\t    cp_error_at (\"in passing argument %P of `%+D'\", parmnum, fndecl);\n \t}\n       return rhs;\n     }      \n@@ -7204,7 +7204,7 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \t avoid duplicate warnings on code like `const int I = NULL;\n \t f(I);'.  */\n       if (ARITHMETIC_TYPE_P (type) && rhs == null_node)\n-\tcp_warning (ec_converting_null_to_nonpointer_type);\n+\tcp_warning (\"converting NULL to non-pointer type\");\n \n       if (TREE_READONLY_DECL_P (rhs))\n \trhs = decl_constant_value (rhs);\n@@ -7293,7 +7293,7 @@ c_expand_return (retval)\n   tree valtype = TREE_TYPE (result);\n \n   if (TREE_THIS_VOLATILE (current_function_decl))\n-    cp_warning (ec_function_declared_noreturn_has_a_return_statement);\n+    warning (\"function declared `noreturn' has a `return' statement\");\n \n   if (retval == error_mark_node)\n     {\n@@ -7310,7 +7310,7 @@ c_expand_return (retval)\n   if (dtor_label)\n     {\n       if (retval)\n-\tcp_error (ec_returning_a_value_from_a_destructor);\n+\terror (\"returning a value from a destructor\");\n \n       /* Can't just return from a destructor.  */\n       expand_goto (dtor_label);\n@@ -7334,7 +7334,7 @@ c_expand_return (retval)\n \t    {\n \t      if (DECL_NAME (DECL_RESULT (current_function_decl)) == NULL_TREE)\n \t\t{\n-\t\t  cp_pedwarn (ec_return_with_no_value_in_function_returning_nonvoid);\n+\t\t  pedwarn (\"`return' with no value, in function returning non-void\");\n \t\t  /* Clear this, so finish_function won't say that we\n \t\t     reach the end of a non-void function (which we don't,\n \t\t     we gave a return!).  */\n@@ -7349,23 +7349,23 @@ c_expand_return (retval)\n   else if (DECL_CONSTRUCTOR_P (current_function_decl))\n     {\n       if (flag_this_is_variable)\n-\tcp_error (ec_return_from_a_constructor_use_this_instead);\n+\terror (\"return from a constructor: use `this = ...' instead\");\n       else\n-\tcp_error (ec_returning_a_value_from_a_constructor);\n+\terror (\"returning a value from a constructor\");\n       retval = current_class_ptr;\n     }\n \n   /* Effective C++ rule 15.  See also start_function.  */\n   if (warn_ecpp\n       && DECL_NAME (current_function_decl) == ansi_opname[(int) MODIFY_EXPR]\n       && retval != current_class_ref)\n-    cp_warning (ec_operator_should_return_a_reference_to_this);\n+    cp_warning (\"`operator=' should return a reference to `*this'\");\n \n   if (valtype == NULL_TREE || TREE_CODE (valtype) == VOID_TYPE)\n     {\n       current_function_returns_null = 1;\n       if (TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)\n-\tcp_pedwarn (ec_return_with_a_value_in_function_returning_void);\n+\tpedwarn (\"`return' with a value, in function returning void\");\n       expand_return (retval);\n       return;\n     }\n@@ -7383,7 +7383,7 @@ c_expand_return (retval)\n     /* It's already done for us.  */;\n   else if (TREE_TYPE (retval) == void_type_node)\n     {\n-      cp_pedwarn (ec_return_of_void_value_in_function_returning_nonvoid);\n+      pedwarn (\"return of void value in function returning non-void\");\n       expand_expr_stmt (retval);\n       retval = 0;\n     }\n@@ -7440,19 +7440,19 @@ c_expand_return (retval)\n \t\t{\n \t\t  /* Get the target.  */\n \t\t  whats_returned = TREE_OPERAND (whats_returned, 0);\n-\t\t  cp_warning (ec_returning_reference_to_temporary);\n+\t\t  warning (\"returning reference to temporary\");\n \t\t}\n \t    }\n \n \t  if (TREE_CODE (whats_returned) == VAR_DECL && DECL_NAME (whats_returned))\n \t    {\n \t      if (TEMP_NAME_P (DECL_NAME (whats_returned)))\n-\t\tcp_warning (ec_reference_to_nonlvalue_returned);\n+\t\twarning (\"reference to non-lvalue returned\");\n \t      else if (TREE_CODE (TREE_TYPE (whats_returned)) != REFERENCE_TYPE\n \t\t       && ! TREE_STATIC (whats_returned)\n \t\t       && IDENTIFIER_LOCAL_VALUE (DECL_NAME (whats_returned))\n \t\t       && !TREE_PUBLIC (whats_returned))\n-\t\tcp_warning_at (ec_reference_to_local_variable_returned, whats_returned);\n+\t\tcp_warning_at (\"reference to local variable `%D' returned\", whats_returned);\n \t    }\n \t}\n       else if (TREE_CODE (retval) == ADDR_EXPR)\n@@ -7464,7 +7464,7 @@ c_expand_return (retval)\n \t      && IDENTIFIER_LOCAL_VALUE (DECL_NAME (whats_returned))\n \t      && !TREE_STATIC (whats_returned)\n \t      && !TREE_PUBLIC (whats_returned))\n-\t    cp_warning_at (ec_address_of_local_variable_returned, whats_returned);\n+\t    cp_warning_at (\"address of local variable `%D' returned\", whats_returned);\n \t}\n     }\n \n@@ -7514,15 +7514,15 @@ c_expand_start_case (exp)\n \n   if (exp == NULL_TREE)\n     {\n-      cp_error (ec_switch_quantity_not_an_integer);\n+      error (\"switch quantity not an integer\");\n       exp = error_mark_node;\n     }\n   type = TREE_TYPE (exp);\n   code = TREE_CODE (type);\n \n   if (code != INTEGER_TYPE && code != ENUMERAL_TYPE && code != ERROR_MARK)\n     {\n-      cp_error (ec_switch_quantity_not_an_integer);\n+      error (\"switch quantity not an integer\");\n       exp = error_mark_node;\n     }\n   else"}, {"sha": "265b387fd232585367ea4951b7c164018e250b14", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 102, "deletions": 98, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -51,7 +51,7 @@ error_not_base_type (basetype, type)\n {\n   if (TREE_CODE (basetype) == FUNCTION_DECL)\n     basetype = DECL_CLASS_CONTEXT (basetype);\n-  cp_error (ec_type_is_not_a_base_type_for_type, basetype, type);\n+  cp_error (\"type `%T' is not a base type for type `%T'\", basetype, type);\n   return error_mark_node;\n }\n \n@@ -83,7 +83,7 @@ readonly_error (arg, string, soft)\n      char *string;\n      int soft;\n {\n-  error_code ec;\n+  char *fmt;\n   void (*fn)();\n \n   if (soft)\n@@ -94,32 +94,32 @@ readonly_error (arg, string, soft)\n   if (TREE_CODE (arg) == COMPONENT_REF)\n     {\n       if (TYPE_READONLY (TREE_TYPE (TREE_OPERAND (arg, 0))))\n-\tec = ec_member_in_readonly_structure;\n+        fmt = \"%s of member `%D' in read-only structure\";\n       else\n-\tec = ec_readonly_member;\n-      (*fn) (ec, string, TREE_OPERAND (arg, 1));\n+        fmt = \"%s of read-only member `%D'\";\n+      (*fn) (fmt, string, TREE_OPERAND (arg, 1));\n     }\n   else if (TREE_CODE (arg) == VAR_DECL)\n     {\n       if (DECL_LANG_SPECIFIC (arg)\n \t  && DECL_IN_AGGR_P (arg)\n \t  && !TREE_STATIC (arg))\n-\tec = ec_constant_field;\n+\tfmt = \"%s of constant field `%D'\";\n       else\n-\tec = ec_readonly_variable;\n-      (*fn) (ec, string, arg);\n+\tfmt = \"%s of read-only variable `%D'\";\n+      (*fn) (fmt, string, arg);\n     }\n   else if (TREE_CODE (arg) == PARM_DECL)\n-    (*fn) (ec_readonly_parameter, string, arg);\n+    (*fn) (\"%s of read-only parameter `%D'\", string, arg);\n   else if (TREE_CODE (arg) == INDIRECT_REF\n            && TREE_CODE (TREE_TYPE (TREE_OPERAND (arg, 0))) == REFERENCE_TYPE\n            && (TREE_CODE (TREE_OPERAND (arg, 0)) == VAR_DECL\n                || TREE_CODE (TREE_OPERAND (arg, 0)) == PARM_DECL))\n-    (*fn) (ec_readonly_reference, string, TREE_OPERAND (arg, 0));\n+    (*fn) (\"%s of read-only reference `%D'\", string, TREE_OPERAND (arg, 0));\n   else if (TREE_CODE (arg) == RESULT_DECL)\n-    (*fn) (ec_readonly_named_return_val, string, arg);\n+    (*fn) (\"%s of read-only named return value `%D'\", string, arg);\n   else\t       \n-    (*fn) (ec_readonly_location, string);\n+    (*fn) (\"%s of read-only location\", string);\n }\n \n /* Print an error message for invalid use of a type which declares\n@@ -161,51 +161,51 @@ abstract_virtuals_error (decl, type)\n \treturn;\n \n       if (TREE_CODE (decl) == VAR_DECL)\n-\tcp_error (ec_cannot_declare_variable_to_be_of_type,\n+\tcp_error (\"cannot declare variable `%D' to be of type `%T'\",\n \t\t    decl, type);\n       else if (TREE_CODE (decl) == PARM_DECL)\n-\tcp_error (ec_cannot_declare_parameter_to_be_of_type,\n+\tcp_error (\"cannot declare parameter `%D' to be of type `%T'\",\n \t\t    decl, type);\n       else if (TREE_CODE (decl) == FIELD_DECL)\n-\tcp_error (ec_cannot_declare_field_to_be_of_type,\n+\tcp_error (\"cannot declare field `%D' to be of type `%T'\",\n \t\t    decl, type);\n       else if (TREE_CODE (decl) == FUNCTION_DECL\n \t       && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n-\tcp_error (ec_invalid_return_type_for_method, decl);\n+\tcp_error (\"invalid return type for method `%#D'\", decl);\n       else if (TREE_CODE (decl) == FUNCTION_DECL)\n-\tcp_error (ec_invalid_return_type_for_function, decl);\n+\tcp_error (\"invalid return type for function `%#D'\", decl);\n     }\n   else\n-    cp_error (ec_cannot_allocate_an_object_of_type, type);\n+    cp_error (\"cannot allocate an object of type `%T'\", type);\n \n   /* Only go through this once.  */\n   if (TREE_PURPOSE (u) == NULL_TREE)\n     {\n       TREE_PURPOSE (u) = error_mark_node;\n \n       if (has_abstract_virtuals)\n-\tcp_error (ec_since_the_following_virtual_functions_are_abstract);\n+\terror (\"  since the following virtual functions are abstract:\");\n       tu = u;\n       while (tu)\n \t{\n \t  if (DECL_ABSTRACT_VIRTUAL_P (TREE_VALUE (tu))\n \t      && ! DECL_NEEDS_FINAL_OVERRIDER_P (TREE_VALUE (tu)))\n-\t    cp_error (ec_virtual, TREE_VALUE (tu));\n+\t    cp_error (\"\\t%#D\", TREE_VALUE (tu));\n \t  tu = TREE_CHAIN (tu);\n \t}\n \n       if (needs_final_overriders)\n \t{\n \t  if (has_abstract_virtuals)\n-\t    cp_error (ec_and_the_following_virtual_functions_need_a_final_overrider);\n+\t    error (\"  and the following virtual functions need a final overrider:\");\n \t  else\n-\t    cp_error (ec_since_the_following_virtual_functions_need_a_final_overrider);\n+\t    error (\"  since the following virtual functions need a final overrider:\");\n \t}\n       tu = u;\n       while (tu)\n \t{\n \t  if (DECL_NEEDS_FINAL_OVERRIDER_P (TREE_VALUE (tu)))\n-\t    cp_error (ec_virtual, TREE_VALUE (tu));\n+\t    cp_error (\"\\t%#D\", TREE_VALUE (tu));\n \t  tu = TREE_CHAIN (tu);\n \t}\n     }\n@@ -214,12 +214,12 @@ abstract_virtuals_error (decl, type)\n       if (has_abstract_virtuals)\n \t{\n \t  if (needs_final_overriders)\n-\t    cp_error (ec_since_type_has_abstract_virtual_functions_and_must_override_virtual_functions, type);\n+\t    cp_error (\"  since type `%T' has abstract virtual functions and must override virtual functions\", type);\n \t  else\n-\t    cp_error (ec_since_type_has_abstract_virtual_functions, type);\n+\t    cp_error (\"  since type `%T' has abstract virtual functions\", type);\n \t}\n       else\n-\tcp_error (ec_since_type_must_override_virtual_functions, type);\n+\tcp_error (\"  since type `%T' must override virtual functions\", type);\n     }\n }\n \n@@ -238,22 +238,22 @@ signature_error (decl, type)\n \treturn;\n \n       if (TREE_CODE (decl) == VAR_DECL)\n-\tcp_error (ec_cannot_declare_variable_to_be_of_signature_type,\n+\tcp_error (\"cannot declare variable `%D' to be of signature type `%T'\",\n \t\t  decl, type);\n       else if (TREE_CODE (decl) == PARM_DECL)\n-\tcp_error (ec_cannot_declare_parameter_to_be_of_signature_type,\n+\tcp_error (\"cannot declare parameter `%D' to be of signature type `%T'\",\n \t\t  decl, type);\n       else if (TREE_CODE (decl) == FIELD_DECL)\n-\tcp_error (ec_cannot_declare_field_to_be_of_signature_type,\n+\tcp_error (\"cannot declare field `%D' to be of signature type `%T'\",\n \t\t  decl, type);\n       else if (TREE_CODE (decl) == FUNCTION_DECL\n \t       && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n-\tcp_error (ec_invalid_return_type_for_method, decl);\n+\tcp_error (\"invalid return type for method `%#D'\", decl);\n       else if (TREE_CODE (decl) == FUNCTION_DECL)\n-\tcp_error (ec_invalid_return_type_for_function, decl);\n+\tcp_error (\"invalid return type for function `%#D'\", decl);\n     }\n   else\n-    cp_error (ec_cannot_allocate_an_object_of_signature_type, type);\n+    cp_error (\"cannot allocate an object of signature type `%T'\", type);\n }\n \n /* Print an error message for invalid use of an incomplete type.\n@@ -265,13 +265,15 @@ incomplete_type_error (value, type)\n      tree value;\n      tree type;\n {\n+  char *errmsg = 0;\n+\n   /* Avoid duplicate error message.  */\n   if (TREE_CODE (type) == ERROR_MARK)\n     return;\n \n   if (value != 0 && (TREE_CODE (value) == VAR_DECL\n \t\t     || TREE_CODE (value) == PARM_DECL))\n-    cp_error (ec_has_incomplete_type, value);\n+    cp_error (\"`%D' has incomplete type\", value);\n   else\n     {\n     retry:\n@@ -282,11 +284,11 @@ incomplete_type_error (value, type)\n \tcase RECORD_TYPE:\n \tcase UNION_TYPE:\n \tcase ENUMERAL_TYPE:\n-\t  cp_error (ec_invalid_use_of_undefined_type, type);\n-\t  return;\n+\t  errmsg = \"invalid use of undefined type `%#T'\";\n+\t  break;\n \n \tcase VOID_TYPE:\n-\t  cp_error (ec_invalid_use_of_void_expression);\n+\t  error (\"invalid use of void expression\");\n \t  return;\n \n \tcase ARRAY_TYPE:\n@@ -295,20 +297,22 @@ incomplete_type_error (value, type)\n \t      type = TREE_TYPE (type);\n \t      goto retry;\n \t    }\n-\t  cp_error (ec_invalid_use_of_array_with_unspecified_bounds);\n+\t  error (\"invalid use of array with unspecified bounds\");\n \t  return;\n \n \tcase OFFSET_TYPE:\n-\t  cp_error (ec_invalid_use_of_member_type_did_you_forget_the);\n+\t  error (\"invalid use of member type (did you forget the `&' ?)\");\n \t  return;\n \n \tcase TEMPLATE_TYPE_PARM:\n-\t  cp_error (ec_invalid_use_of_template_type_parameter);\n+\t  error (\"invalid use of template type parameter\");\n \t  return;\n \n \tdefault:\n \t  my_friendly_abort (108);\n \t}\n+\n+      cp_error (errmsg, type);\n     }\n }\n \n@@ -382,16 +386,16 @@ my_friendly_abort (i)\n \t  ack (\"Please submit a full bug report to `egcs-bugs@cygnus.com'.\");\n \t}\n       else\n-\tcp_error (ec_confused_by_earlier_errors_bailing_out);\n+\terror (\"confused by earlier errors, bailing out\");\n       \n       exit (34);\n     }\n   ++abortcount;\n \n   if (i == 0)\n-    cp_error (ec_nternal_compiler_error);\n+    error (\"Internal compiler error.\");\n   else\n-    cp_error (ec_nternal_compiler_error_d, i);\n+    error (\"Internal compiler error %d.\", i);\n \n   fatal (\"Please submit a full bug report to `egcs-bugs@cygnus.com'.\");\n }\n@@ -592,13 +596,13 @@ store_init_value (decl, init)\n       if (TREE_CODE (init) == TREE_LIST\n \t  && IS_SIGNATURE (type))\n \t{\n-\t  cp_error (ec_constructor_syntax_cannot_be_used_with_signature_type,\n+\t  cp_error (\"constructor syntax cannot be used with signature type `%T'\",\n \t\t    type);\n \t  init = error_mark_node;\n \t}\n       else if (TREE_CODE (init) == TREE_LIST)\n \t{\n-\t  cp_error (ec_constructor_syntax_used_but_no_constructor_declared_for_type, type);\n+\t  cp_error (\"constructor syntax used, but no constructor declared for type `%T'\", type);\n \t  init = build_nt (CONSTRUCTOR, NULL_TREE, nreverse (init));\n \t}\n #if 0\n@@ -608,25 +612,25 @@ store_init_value (decl, init)\n \n \t  /* Check that we're really an aggregate as ARM 8.4.1 defines it.  */\n \t  if (CLASSTYPE_N_BASECLASSES (type))\n-\t    cp_error_at (ec_initializer_list_construction_invalid_for_derived_class_object, decl);\n+\t    cp_error_at (\"initializer list construction invalid for derived class object `%D'\", decl);\n \t  if (CLASSTYPE_VTBL_PTR (type))\n-\t    cp_error_at (ec_initializer_list_construction_invalid_for_polymorphic_class_object, decl);\n+\t    cp_error_at (\"initializer list construction invalid for polymorphic class object `%D'\", decl);\n \t  if (TYPE_NEEDS_CONSTRUCTING (type))\n \t    {\n-\t      cp_error_at (ec_initializer_list_construction_invalid_for, decl);\n-\t      cp_error (ec_due_to_the_presence_of_a_constructor);\n+\t      cp_error_at (\"initializer list construction invalid for `%D'\", decl);\n+\t      error (\"due to the presence of a constructor\");\n \t    }\n \t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n \t    if (TREE_PRIVATE (field) || TREE_PROTECTED (field))\n \t      {\n-\t\tcp_error_at (ec_initializer_list_construction_invalid_for, decl);\n-\t\tcp_error_at (ec_due_to_nonpublic_access_of_member, field);\n+\t\tcp_error_at (\"initializer list construction invalid for `%D'\", decl);\n+\t\tcp_error_at (\"due to non-public access of member `%D'\", field);\n \t      }\n \t  for (field = TYPE_METHODS (type); field; field = TREE_CHAIN (field))\n \t    if (TREE_PRIVATE (field) || TREE_PROTECTED (field))\n \t      {\n-\t\tcp_error_at (ec_initializer_list_construction_invalid_for, decl);\n-\t\tcp_error_at (ec_due_to_nonpublic_access_of_member, field);\n+\t\tcp_error_at (\"initializer list construction invalid for `%D'\", decl);\n+\t\tcp_error_at (\"due to non-public access of member `%D'\", field);\n \t      }\n \t}\n #endif\n@@ -638,7 +642,7 @@ store_init_value (decl, init)\n \t{\n \t  if (TREE_CHAIN (init))\n \t    {\n-\t      cp_warning (ec_comma_expression_used_to_initialize_return_value);\n+\t      warning (\"comma expression used to initialize return value\");\n \t      init = build_compound_expr (init);\n \t    }\n \t  else\n@@ -654,7 +658,7 @@ store_init_value (decl, init)\n       else if (TREE_CODE (init) == TREE_LIST\n \t       && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n \t{\n-\t  cp_error (ec_cannot_initialize_arrays_using_this_syntax);\n+\t  error (\"cannot initialize arrays using this syntax\");\n \t  return NULL_TREE;\n \t}\n       else\n@@ -663,7 +667,7 @@ store_init_value (decl, init)\n \t     \n \t  if (TREE_CHAIN (init) != NULL_TREE)\n \t    {\n-\t      cp_pedwarn (ec_initializer_list_being_treated_as_compound_expression);\n+\t      pedwarn (\"initializer list being treated as compound expression\");\n \t      init = build_compound_expr (init);\n \t    }\n \t  else\n@@ -716,7 +720,7 @@ store_init_value (decl, init)\n \t\t    || IS_SIGNATURE_REFERENCE (type))))\n \t{\n \t  if (! TREE_CONSTANT (value) || ! TREE_STATIC (value))\n-\t    cp_pedwarn (ec_forbids_nonconstant_aggregate_initializer_expressions);\n+\t    pedwarn (\"ANSI C++ forbids non-constant aggregate initializer expressions\");\n \t}\n     }\n #endif\n@@ -784,7 +788,7 @@ digest_init (type, init, tail)\n \n       if (TREE_CODE (init) == TREE_LIST)\n \t{\n-\t  cp_error (ec_initializing_array_with_parameter_list);\n+\t  error (\"initializing array with parameter list\");\n \t  return error_mark_node;\n \t}\n \n@@ -803,14 +807,14 @@ digest_init (type, init, tail)\n \t       != char_type_node)\n \t      && TYPE_PRECISION (typ1) == BITS_PER_UNIT)\n \t    {\n-\t      cp_error (ec_chararray_initialized_from_wide_string);\n+\t      error (\"char-array initialized from wide string\");\n \t      return error_mark_node;\n \t    }\n \t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (string)))\n \t       == char_type_node)\n \t      && TYPE_PRECISION (typ1) != BITS_PER_UNIT)\n \t    {\n-\t      cp_error (ec_intarray_initialized_from_nonwide_string);\n+\t      error (\"int-array initialized from non-wide string\");\n \t      return error_mark_node;\n \t    }\n \n@@ -826,7 +830,7 @@ digest_init (type, init, tail)\n \t\t counted in the length of the constant, but in C++ this would\n \t\t be invalid.  */\n \t      if (size < TREE_STRING_LENGTH (string))\n-\t\tcp_pedwarn (ec_initializerstring_for_array_of_chars_is_too_long);\n+\t\tpedwarn (\"initializer-string for array of chars is too long\");\n \t    }\n \t  return string;\n \t}\n@@ -846,17 +850,17 @@ digest_init (type, init, tail)\n \t{\n \t  if (element == 0)\n \t    {\n-\t      cp_error (ec_initializer_for_scalar_variable_requires_one_element);\n+\t      error (\"initializer for scalar variable requires one element\");\n \t      return error_mark_node;\n \t    }\n \t  init = element;\n \t}\n       while (TREE_CODE (init) == CONSTRUCTOR && TREE_HAS_CONSTRUCTOR (init))\n \t{\n-\t  cp_pedwarn (ec_braces_around_scalar_initializer_for, type);\n+\t  cp_pedwarn (\"braces around scalar initializer for `%T'\", type);\n \t  init = CONSTRUCTOR_ELTS (init);\n \t  if (TREE_CHAIN (init))\n-\t    cp_pedwarn (ec_ignoring_extra_initializers_for, type);\n+\t    cp_pedwarn (\"ignoring extra initializers for `%T'\", type);\n \t  init = TREE_VALUE (init);\n \t}\n \n@@ -868,7 +872,7 @@ digest_init (type, init, tail)\n \n   if (TYPE_SIZE (type) && ! TREE_CONSTANT (TYPE_SIZE (type)))\n     {\n-      cp_error (ec_variablesized_object_of_type_may_not_be_initialized,\n+      cp_error (\"variable-sized object of type `%T' may not be initialized\",\n \t\ttype);\n       return error_mark_node;\n     }\n@@ -877,7 +881,7 @@ digest_init (type, init, tail)\n     {\n       if (raw_constructor && TYPE_NON_AGGREGATE_CLASS (type))\n \t{\n-\t  cp_error (ec_subobject_of_type_must_be_initialized_by_constructor_not_by,\n+\t  cp_error (\"subobject of type `%T' must be initialized by constructor, not by `%E'\",\n \t\t    type, init);\n \t  return error_mark_node;\n \t}\n@@ -904,7 +908,7 @@ digest_init (type, init, tail)\n \t}\n     }\n \n-  cp_error (ec_invalid_initializer);\n+  error (\"invalid initializer\");\n   return error_mark_node;\n }\n \f\n@@ -942,7 +946,7 @@ process_init_constructor (type, init, elts)\n   if (elts)\n     {\n       if (warn_missing_braces)\n-\tcp_warning (ec_aggregate_has_a_partly_bracketed_initializer);\n+\twarning (\"aggregate has a partly bracketed initializer\");\n       tail = *elts;\n     }\n   else\n@@ -990,7 +994,7 @@ process_init_constructor (type, init, elts)\n \t\t\t\t  || TREE_CODE (tail1) == TREE_LIST, 319);\n \t      if (tail == tail1 && len < 0)\n \t\t{\n-\t\t  cp_error (ec_nonempty_initializer_for_array_of_empty_elements);\n+\t\t  error (\"non-empty initializer for array of empty elements\");\n \t\t  /* Just ignore what we were supposed to use.  */\n \t\t  tail1 = NULL_TREE;\n \t\t}\n@@ -1097,19 +1101,19 @@ process_init_constructor (type, init, elts)\n \t      members = expr_tree_cons (field, next1, members);\n \t    }\n \t  else if (TREE_READONLY (field))\n-\t    cp_error (ec_uninitialized_const_member_s,\n+\t    error (\"uninitialized const member `%s'\",\n \t\t   IDENTIFIER_POINTER (DECL_NAME (field)));\n \t  else if (TYPE_LANG_SPECIFIC (TREE_TYPE (field))\n \t\t   && CLASSTYPE_READONLY_FIELDS_NEED_INIT (TREE_TYPE (field)))\n-\t    cp_error (ec_member_s_with_uninitialized_const_fields,\n+\t    error (\"member `%s' with uninitialized const fields\",\n \t\t   IDENTIFIER_POINTER (DECL_NAME (field)));\n \t  else if (TREE_CODE (TREE_TYPE (field)) == REFERENCE_TYPE)\n-\t    cp_error (ec_member_s_is_uninitialized_reference,\n+\t    error (\"member `%s' is uninitialized reference\",\n \t\t   IDENTIFIER_POINTER (DECL_NAME (field)));\n \t  /* Warn when some struct elements are implicitly initialized\n \t      to zero.  */\n \t  else if (extra_warnings)\n-\t    cp_warning (ec_missing_initializer_for_member_s,\n+\t    warning (\"missing initializer for member `%s'\",\n \t\t     IDENTIFIER_POINTER (DECL_NAME (field)));\n \t}\n     }\n@@ -1134,7 +1138,7 @@ process_init_constructor (type, init, elts)\n \t    /* Handle the case of a call by build_c_cast.  */\n \t    field = TREE_PURPOSE (tail), win = 1;\n \t  else if (TREE_CODE (TREE_PURPOSE (tail)) != IDENTIFIER_NODE)\n-\t    cp_error (ec_index_value_instead_of_field_name_in_union_initializer);\n+\t    error (\"index value instead of field name in union initializer\");\n \t  else\n \t    {\n \t      tree temp;\n@@ -1146,15 +1150,15 @@ process_init_constructor (type, init, elts)\n \t      if (temp)\n \t\tfield = temp, win = 1;\n \t      else\n-\t\tcp_error (ec_no_field_s_in_union_being_initialized,\n+\t\terror (\"no field `%s' in union being initialized\",\n \t\t       IDENTIFIER_POINTER (TREE_PURPOSE (tail)));\n \t    }\n \t  if (!win)\n \t    TREE_VALUE (tail) = error_mark_node;\n \t}\n       else if (field == 0)\n \t{\n-\t  cp_error (ec_union_with_no_named_members_cannot_be_initialized,\n+\t  cp_error (\"union `%T' with no named members cannot be initialized\",\n \t\t    type);\n \t  TREE_VALUE (tail) = error_mark_node;\n \t}\n@@ -1190,7 +1194,7 @@ process_init_constructor (type, init, elts)\n   /* If arguments were specified as a constructor,\n      complain unless we used all the elements of the constructor.  */\n   else if (tail)\n-    cp_pedwarn (ec_excess_elements_in_aggregate_initializer);\n+    pedwarn (\"excess elements in aggregate initializer\");\n \n   if (erroneous)\n     return error_mark_node;\n@@ -1317,7 +1321,7 @@ build_x_arrow (datum)\n \n \t  if (value_member (TREE_TYPE (rval), types_memoized))\n \t    {\n-\t      cp_error (ec_circular_pointer_delegation_detected);\n+\t      error (\"circular pointer delegation detected\");\n \t      return error_mark_node;\n \t    }\n \t  else\n@@ -1330,7 +1334,7 @@ build_x_arrow (datum)\n \n       if (last_rval == NULL_TREE)\n \t{\n-\t  cp_error (ec_base_operand_of_has_nonpointer_type, type);\n+\t  cp_error (\"base operand of `->' has non-pointer type `%T'\", type);\n \t  return error_mark_node;\n \t}\n \n@@ -1349,9 +1353,9 @@ build_x_arrow (datum)\n     return build_indirect_ref (last_rval, NULL_PTR);\n \n   if (types_memoized)\n-    cp_error (ec_result_of_operator_yields_nonpointer_result);\n+    error (\"result of `operator->()' yields non-pointer result\");\n   else\n-    cp_error (ec_base_operand_of_is_not_a_pointer);\n+    error (\"base operand of `->' is not a pointer\");\n   return error_mark_node;\n }\n \n@@ -1396,7 +1400,7 @@ build_m_component_ref (datum, component)\n \n   if (TREE_CODE (type) != OFFSET_TYPE && TREE_CODE (type) != METHOD_TYPE)\n     {\n-      cp_error (ec_cannot_be_used_as_a_member_pointer_since_it_is_of_type, component, type);\n+      cp_error (\"`%E' cannot be used as a member pointer, since it is of type `%T'\", component, type);\n       return error_mark_node;\n     }\n \n@@ -1406,15 +1410,15 @@ build_m_component_ref (datum, component)\n \n   if (! IS_AGGR_TYPE (objtype))\n     {\n-      cp_error (ec_cannot_apply_member_pointer_to, component, datum);\n-      cp_error (ec_which_is_of_nonaggregate_type, objtype);\n+      cp_error (\"cannot apply member pointer `%E' to `%E'\", component, datum);\n+      cp_error (\"which is of non-aggregate type `%T'\", objtype);\n       return error_mark_node;\n     }\n \n   binfo = get_binfo (TYPE_METHOD_BASETYPE (type), objtype, 1);\n   if (binfo == NULL_TREE)\n     {\n-      cp_error (ec_member_type_incompatible_with_object_type,\n+      cp_error (\"member type `%T::' incompatible with object type `%T'\",\n \t\tTYPE_METHOD_BASETYPE (type), objtype);\n       return error_mark_node;\n     }\n@@ -1451,7 +1455,7 @@ build_functional_cast (exp, parms)\n \t  type = lookup_name (exp, 1);\n \t  if (!type || TREE_CODE (type) != TYPE_DECL)\n \t    {\n-\t      cp_error (ec_fails_to_be_a_typedef_or_builtin_type, exp);\n+\t      cp_error (\"`%T' fails to be a typedef or built-in type\", exp);\n \t      return error_mark_node;\n \t    }\n \t  type = TREE_TYPE (type);\n@@ -1467,7 +1471,7 @@ build_functional_cast (exp, parms)\n \n   if (IS_SIGNATURE (type))\n     {\n-      cp_error (ec_signature_type_not_allowed_in_cast_or_constructor_expression);\n+      error (\"signature type not allowed in cast or constructor expression\");\n       return error_mark_node;\n     }\n \n@@ -1479,7 +1483,7 @@ build_functional_cast (exp, parms)\n       else\n \t{\n \t  if (TREE_CHAIN (parms) != NULL_TREE)\n-\t    cp_pedwarn (ec_initializer_list_being_treated_as_compound_expression);\n+\t    pedwarn (\"initializer list being treated as compound expression\");\n \t  parms = build_compound_expr (parms);\n \t}\n \n@@ -1495,7 +1499,7 @@ build_functional_cast (exp, parms)\n \n   if (TYPE_SIZE (complete_type (type)) == NULL_TREE)\n     {\n-      cp_error (ec_type_is_not_yet_defined, type);\n+      cp_error (\"type `%T' is not yet defined\", type);\n       return error_mark_node;\n     }\n \n@@ -1564,15 +1568,15 @@ report_case_error (code, type, new_value, old_value)\n   if (code == 1)\n     {\n       if (new_value)\n-\tcp_error (ec_case_label_not_within_a_switch_statement);\n+\terror (\"case label not within a switch statement\");\n       else\n-\tcp_error (ec_default_label_not_within_a_switch_statement);\n+\terror (\"default label not within a switch statement\");\n     }\n   else if (code == 2)\n     {\n       if (new_value == 0)\n \t{\n-\t  cp_error (ec_multiple_default_labels_in_one_switch);\n+\t  error (\"multiple default labels in one switch\");\n \t  return;\n \t}\n       if (TREE_CODE (new_value) == RANGE_EXPR)\n@@ -1626,29 +1630,29 @@ report_case_error (code, type, new_value, old_value)\n       else\n \t{\n \t  if (TREE_CODE (type) == ENUMERAL_TYPE)\n-\t    cp_error (ec_duplicate_label_s_in_switch_statement,\n+\t    error (\"duplicate label `%s' in switch statement\",\n \t\t   enum_name_string (new_value, type));\n \t  else\n-\t    cp_error (ec_duplicate_label_d_in_switch_statement,\n+\t    error (\"duplicate label (%d) in switch statement\",\n \t\t   TREE_INT_CST_LOW (new_value));\n \t}\n     }\n   else if (code == 3)\n     {\n       if (TREE_CODE (type) == ENUMERAL_TYPE)\n-\tcp_warning (ec_case_value_out_of_range_for_enum_s,\n+\twarning (\"case value out of range for enum %s\",\n \t\t TYPE_NAME_STRING (type));\n       else\n-\tcp_warning (ec_case_value_out_of_range);\n+\twarning (\"case value out of range\");\n     }\n   else if (code == 4)\n     {\n       if (TREE_CODE (type) == ENUMERAL_TYPE)\n-\tcp_error (ec_range_values_s_and_s_reversed,\n+\terror (\"range values `%s' and `%s' reversed\",\n \t       enum_name_string (new_value, type),\n \t       enum_name_string (old_value, type));\n       else\n-\tcp_error (ec_range_values_reversed);\n+\terror (\"range values reversed\");\n     }\n }\n #endif\n@@ -1659,5 +1663,5 @@ check_for_new_type (string, inptree)\n      flagged_type_tree inptree;\n {\n   if (pedantic && inptree.new_type_flag)\n-    cp_pedwarn (ec_forbids_defining_types_within_s,string);\n+    pedwarn (\"ANSI C++ forbids defining types within %s\",string);\n }"}, {"sha": "14915d6a8629d74d57f6c20171cb61810fa3a5aa", "filename": "gcc/cp/xref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8251199e44be354aafd37dd69b56a4b1f9620120/gcc%2Fcp%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fxref.c?ref=8251199e44be354aafd37dd69b56a4b1f9620120", "patch": "@@ -832,7 +832,7 @@ open_xref_file(file)\n \n   if (xref_file == NULL)\n     {\n-      cp_error (ec_ant_create_crossreference_file_s, xref_name);\n+      error(\"Can't create cross-reference file `%s'\", xref_name);\n       doing_xref = 0;\n     }\n }"}]}