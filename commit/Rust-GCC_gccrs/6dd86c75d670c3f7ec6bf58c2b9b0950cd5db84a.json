{"sha": "6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRkODZjNzVkNjcwYzNmN2VjNmJmNThjMmI5YjA5NTBjZDVkYjg0YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T10:56:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T10:56:46Z"}, "message": "[multiple changes]\n\n2017-04-27  Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.adb (Build_Inherited_Condition_Pragmas): New procedure,\n\tsubsidiary of Check_Inherited_Conditions, to build pragmas for an\n\toperation whose ancestor has classwide pre/postconditions. This\n\tis used both to check the legality of the inheritance in Ada\n\tand in SPARK, and to determine whether a wrapper is needed for\n\tan inherited operation.\n\t* exp_util.adb (Build_Class_Wide_Expression, Replace_Entity):\n\tImprove placement of error message for inherited classwide\n\tconditions that become illegal on type derivation.\n\n2017-04-27  Yannick Moy  <moy@adacore.com>\n\n\t* sem_ch12.adb (Analyze_Generic_Package_Declaration): Set\n\tSPARK_Mode from context on generic package.\n\t* sem_ch7.adb (Analyze_Package_Declaration): Simplify code to remove\n\tuseless test.\n\n2017-04-27  Claire Dross  <dross@adacore.com>\n\n\t* a-cofuve.ads (Range_Shifted): Rewrite precondition to avoid\n\toverflows in computations.\n\t* a-cofove.ads (Capacity_Range): Rewrite last bound to avoid\n\toverflows in computations.\n\t(Insert): Rewrite precondition to avoid overflows in computations.\n\t* a-cfinve.ads (Capacity_Range): Rewrite last bound to avoid\n\toverflows in computations.\n\t(Insert): Rewrite precondition to avoid overflows in computations.\n\nFrom-SVN: r247318", "tree": {"sha": "06f3f57e65874c60b41360378a505c831660823d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06f3f57e65874c60b41360378a505c831660823d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/comments", "author": null, "committer": null, "parents": [{"sha": "f24745230fe28ddd92d28ff681bd95d10578e3b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f24745230fe28ddd92d28ff681bd95d10578e3b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f24745230fe28ddd92d28ff681bd95d10578e3b0"}], "stats": {"total": 280, "additions": 200, "deletions": 80}, "files": [{"sha": "d4025dc378daad0875835d295c84651b87d32389", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a", "patch": "@@ -1,3 +1,33 @@\n+2017-04-27  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* freeze.adb (Build_Inherited_Condition_Pragmas): New procedure,\n+\tsubsidiary of Check_Inherited_Conditions, to build pragmas for an\n+\toperation whose ancestor has classwide pre/postconditions. This\n+\tis used both to check the legality of the inheritance in Ada\n+\tand in SPARK, and to determine whether a wrapper is needed for\n+\tan inherited operation.\n+\t* exp_util.adb (Build_Class_Wide_Expression, Replace_Entity):\n+\tImprove placement of error message for inherited classwide\n+\tconditions that become illegal on type derivation.\n+\n+2017-04-27  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_ch12.adb (Analyze_Generic_Package_Declaration): Set\n+\tSPARK_Mode from context on generic package.\n+\t* sem_ch7.adb (Analyze_Package_Declaration): Simplify code to remove\n+\tuseless test.\n+\n+2017-04-27  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cofuve.ads (Range_Shifted): Rewrite precondition to avoid\n+\toverflows in computations.\n+\t* a-cofove.ads (Capacity_Range): Rewrite last bound to avoid\n+\toverflows in computations.\n+\t(Insert): Rewrite precondition to avoid overflows in computations.\n+\t* a-cfinve.ads (Capacity_Range): Rewrite last bound to avoid\n+\toverflows in computations.\n+\t(Insert): Rewrite precondition to avoid overflows in computations.\n+\n 2017-04-27  Steve Baird  <baird@adacore.com>\n \n \t* exp_ch9.adb (Expand_N_Asynchronous_Select): Initialize the Cancel"}, {"sha": "5ef2b1edd793abfaaca1dfff458f4ef11aa8a1b2", "filename": "gcc/ada/a-cfinve.ads", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2Fa-cfinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2Fa-cfinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfinve.ads?ref=6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a", "patch": "@@ -63,8 +63,18 @@ is\n \n    No_Index : constant Extended_Index := Extended_Index'First;\n \n-   subtype Capacity_Range is\n-     Count_Type range 0 .. Count_Type (Index_Type'Last - Index_Type'First + 1);\n+   Last_Count : constant Count_Type :=\n+     (if Index_Type'Last < Index_Type'First then 0\n+      elsif Index_Type'Last < -1\n+        or else Index_Type'Pos (Index_Type'First) >\n+          Index_Type'Pos (Index_Type'Last) - Count_Type'Last\n+      then Index_Type'Pos (Index_Type'Last) -\n+          Index_Type'Pos (Index_Type'First) + 1\n+      else Count_Type'Last);\n+   --  Maximal capacity of any vector. It is the minimum of the size of the\n+   --  index range and the last possible Count_Type.\n+\n+   subtype Capacity_Range is Count_Type range 0 .. Last_Count;\n \n    type Vector (Capacity : Capacity_Range) is limited private with\n      Default_Initial_Condition => Is_Empty (Vector);\n@@ -295,7 +305,8 @@ is\n      Pre    =>\n        Length (Container) <= Capacity (Container) - Length (New_Item)\n          and (Before in Index_Type'First .. Last_Index (Container)\n-              or Before - 1 = Last_Index (Container)),\n+              or (Before /= No_Index\n+                    and then Before - 1 = Last_Index (Container))),\n      Post   =>\n        Length (Container) = Length (Container)'Old + Length (New_Item)\n \n@@ -369,7 +380,8 @@ is\n      Pre    =>\n        Length (Container) <= Capacity (Container) - Count\n          and (Before in Index_Type'First .. Last_Index (Container)\n-              or Before - 1 = Last_Index (Container)),\n+              or (Before /= No_Index\n+                    and then Before - 1 = Last_Index (Container))),\n      Post   =>\n        Length (Container) = Length (Container)'Old + Count\n "}, {"sha": "5ad0e87c37796c532fe5bb79d2fdcbb5b3060239", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a", "patch": "@@ -57,8 +57,18 @@ is\n \n    No_Index : constant Extended_Index := Extended_Index'First;\n \n-   subtype Capacity_Range is\n-     Count_Type range 0 .. Count_Type (Index_Type'Last - Index_Type'First + 1);\n+   Last_Count : constant Count_Type :=\n+     (if Index_Type'Last < Index_Type'First then 0\n+      elsif Index_Type'Last < -1\n+        or else Index_Type'Pos (Index_Type'First) >\n+          Index_Type'Pos (Index_Type'Last) - Count_Type'Last\n+      then Index_Type'Pos (Index_Type'Last) -\n+          Index_Type'Pos (Index_Type'First) + 1\n+      else Count_Type'Last);\n+   --  Maximal capacity of any vector. It is the minimum of the size of the\n+   --  index range and the last possible Count_Type.\n+\n+   subtype Capacity_Range is Count_Type range 0 .. Last_Count;\n \n    type Vector (Capacity : Capacity_Range) is limited private with\n      Default_Initial_Condition => Is_Empty (Vector);\n@@ -289,7 +299,8 @@ is\n      Pre    =>\n        Length (Container) <= Capacity (Container) - Length (New_Item)\n          and (Before in Index_Type'First .. Last_Index (Container)\n-              or Before - 1 = Last_Index (Container)),\n+              or (Before /= No_Index\n+                    and then Before - 1 = Last_Index (Container))),\n      Post   =>\n        Length (Container) = Length (Container)'Old + Length (New_Item)\n \n@@ -363,7 +374,8 @@ is\n      Pre    =>\n        Length (Container) <= Capacity (Container) - Count\n          and (Before in Index_Type'First .. Last_Index (Container)\n-              or Before - 1 = Last_Index (Container)),\n+              or (Before /= No_Index\n+                    and then Before - 1 = Last_Index (Container))),\n      Post   =>\n        Length (Container) = Length (Container)'Old + Count\n "}, {"sha": "db1edd5f1224523a103c853af4dbe00d595ee32b", "filename": "gcc/ada/a-cofuve.ads", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2Fa-cofuve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2Fa-cofuve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuve.ads?ref=6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a", "patch": "@@ -225,10 +225,16 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n      Global => null,\n      Pre    =>\n        Lst <= Last (Left)\n-         and Offset in\n-           Index_Type'Pos (Index_Type'First) - Index_Type'Pos (Fst) ..\n-             (Index_Type'Pos (Index_Type'First) - 1) + Length (Right) -\n-              Index_Type'Pos (Lst),\n+         and then\n+           (if Offset < 0 then\n+              Index_Type'Pos (Index_Type'Base'First) - Offset <=\n+              Index_Type'Pos (Index_Type'First))\n+         and then\n+           (if Fst <= Lst then\n+              Offset in\n+                Index_Type'Pos (Index_Type'First) - Index_Type'Pos (Fst) ..\n+                  (Index_Type'Pos (Index_Type'First) - 1) + Length (Right) -\n+                   Index_Type'Pos (Lst)),\n      Post   =>\n        Range_Shifted'Result =\n          ((for all I in Fst .. Lst =>"}, {"sha": "0828c9b5b7f3f1cd3c7ee1ee2e040e9eafcc8ed5", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a", "patch": "@@ -1135,9 +1135,17 @@ package body Exp_Util is\n                  and then Is_Abstract_Subprogram (Entity (N))\n                then\n                   Error_Msg_Sloc := Sloc (Current_Scope);\n-                  Error_Msg_NE\n-                    (\"cannot call abstract subprogram in inherited condition \"\n-                      & \"for&#\", N, Current_Scope);\n+                  --  Error_Msg_Node_1 := Entity (N);\n+                  Error_Msg_Node_2 := Subp;\n+                  if Comes_From_Source (Subp) then\n+                     Error_Msg_NE\n+                       (\"cannot call abstract subprogram& in inherited \"\n+                         & \"condition for&#\", Subp, Entity (N));\n+                  else\n+                     Error_Msg_NE\n+                       (\"cannot call abstract subprogram& in inherited \"\n+                         & \"condition for inherited&#\", Subp, Entity (N));\n+                  end if;\n \n                --  In SPARK mode, reject an inherited condition for an\n                --  inherited operation if it contains a call to an overriding"}, {"sha": "b1fb3d38fcfcd7711355e1cc1db5974dee534e69", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 99, "deletions": 52, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a", "patch": "@@ -1400,103 +1400,150 @@ package body Freeze is\n \n    procedure Check_Inherited_Conditions (R : Entity_Id) is\n       Prim_Ops      : constant Elist_Id := Primitive_Operations (R);\n-      A_Post        : Node_Id;\n-      A_Pre         : Node_Id;\n       Decls         : List_Id;\n       Needs_Wrapper : Boolean;\n-      New_Prag      : Node_Id;\n       Op_Node       : Elmt_Id;\n       Par_Prim      : Entity_Id;\n       Prim          : Entity_Id;\n \n+      ---------------------------------------\n+      -- Build_Inherited_Condition_Pragmas --\n+      ---------------------------------------\n+\n+      procedure Build_Inherited_Condition_Pragmas (Subp : Entity_Id);\n+      --  Build corresponding pragmas for an operation whose ancestor has\n+      --  class-wide pre/postconditions. If the operation is inherited, the\n+      --  pragmas force the creation of a wrapper for the inherited operation.\n+      --  If the ancestor is being overridden, the pragmas are constructed only\n+      --  to verify their legality, in case they contain calls to other\n+      --  primitives that may haven been overridden.\n+\n+      procedure Build_Inherited_Condition_Pragmas (Subp : Entity_Id) is\n+         A_Post   : Node_Id;\n+         A_Pre    : Node_Id;\n+         New_Prag : Node_Id;\n+\n+      begin\n+         A_Pre := Get_Pragma (Par_Prim, Pragma_Precondition);\n+         if Present (A_Pre) and then Class_Present (A_Pre) then\n+            New_Prag := New_Copy_Tree (A_Pre);\n+            Build_Class_Wide_Expression\n+              (Prag          => New_Prag,\n+               Subp          => Prim,\n+               Par_Subp      => Par_Prim,\n+               Adjust_Sloc   => False,\n+               Needs_Wrapper => Needs_Wrapper);\n+\n+            if Needs_Wrapper\n+              and then not Comes_From_Source (Subp)\n+              and then Expander_Active\n+            then\n+               Append (New_Prag, Decls);\n+            end if;\n+         end if;\n+\n+         A_Post := Get_Pragma (Par_Prim, Pragma_Postcondition);\n+\n+         if Present (A_Post) and then Class_Present (A_Post) then\n+            New_Prag := New_Copy_Tree (A_Post);\n+            Build_Class_Wide_Expression\n+              (Prag           => New_Prag,\n+               Subp           => Prim,\n+               Par_Subp       => Par_Prim,\n+               Adjust_Sloc    => False,\n+               Needs_Wrapper  => Needs_Wrapper);\n+\n+            if Needs_Wrapper\n+              and then not Comes_From_Source (Subp)\n+              and then Expander_Active\n+            then\n+               Append (New_Prag, Decls);\n+            end if;\n+         end if;\n+      end Build_Inherited_Condition_Pragmas;\n+\n    begin\n       Op_Node := First_Elmt (Prim_Ops);\n       while Present (Op_Node) loop\n-         Prim          := Node (Op_Node);\n-         Needs_Wrapper := False;\n+         Prim := Node (Op_Node);\n \n          --  Map the overridden primitive to the overriding one. This takes\n          --  care of all overridings and is done only once.\n \n          if Present (Overridden_Operation (Prim))\n            and then Comes_From_Source (Prim)\n          then\n-            Update_Primitives_Mapping (Overridden_Operation (Prim), Prim);\n+            Par_Prim := Overridden_Operation (Prim);\n+            Update_Primitives_Mapping (Par_Prim, Prim);\n+         end if;\n+\n+         Next_Elmt (Op_Node);\n+      end loop;\n+\n+      --  Now perform validity checks on the inherited conditions of\n+      --  overriding operations, for conformance with LSP, and apply\n+      --  SPARK-specific restrictions on inherited conditions.\n+\n+      Op_Node := First_Elmt (Prim_Ops);\n+      while Present (Op_Node) loop\n+         Prim := Node (Op_Node);\n+         if Present (Overridden_Operation (Prim))\n+           and then Comes_From_Source (Prim)\n+         then\n+            Par_Prim := Overridden_Operation (Prim);\n+\n+            --  Analyze the contract items of the overridden operation, before\n+            --  they are rewritten as pragmas.\n+\n+            Analyze_Entry_Or_Subprogram_Contract (Par_Prim);\n \n             --  In SPARK mode this is where we can collect the inherited\n             --  conditions, because we do not create the Check pragmas that\n             --  normally convey the the modified class-wide conditions on\n             --  overriding operations.\n \n             if SPARK_Mode = On then\n+               Collect_Inherited_Class_Wide_Conditions (Prim);\n \n-               --  Analyze the contract items of the parent operation, before\n-               --  they are rewritten when inherited.\n-\n-               Analyze_Entry_Or_Subprogram_Contract\n-                 (Overridden_Operation (Prim));\n+            else\n \n-               --  Now verify the legality of inherited contracts for LSP\n-               --  conformance.\n+               --  Build the corresponding pragmas to check for legality\n+               --  of the inherited condition.\n \n-               Collect_Inherited_Class_Wide_Conditions (Prim);\n+               Build_Inherited_Condition_Pragmas (Prim);\n             end if;\n          end if;\n \n          Next_Elmt (Op_Node);\n       end loop;\n \n-      --  In all cases, we examine inherited operations to check whether they\n-      --  require a wrapper to handle inherited conditions that call other\n-      --  primitives, so that LSP can be verified/enforced.\n+      --  Now examine the inherited operations to check whether they require\n+      --  a wrapper to handle inherited conditions that call other primitives,\n+      --  so that LSP can be verified/enforced.\n \n       Op_Node := First_Elmt (Prim_Ops);\n+      Needs_Wrapper := False;\n+\n       while Present (Op_Node) loop\n          Decls := Empty_List;\n          Prim  := Node (Op_Node);\n \n          if not Comes_From_Source (Prim) and then Present (Alias (Prim)) then\n             Par_Prim := Alias (Prim);\n \n-            --  Analyze the contract items of the parent operation, before\n-            --  they are rewritten when inherited.\n+            --  Analyze the contract items of the parent operation, and\n+            --  determine whether a wrapper is needed. This is determined\n+            --  when the condition is rewritten in sem_prag, using the\n+            --  mapping between overridden and overriding operations built\n+            --  in the loop above.\n \n             Analyze_Entry_Or_Subprogram_Contract (Par_Prim);\n-\n-            A_Pre := Get_Pragma (Par_Prim, Pragma_Precondition);\n-\n-            if Present (A_Pre) and then Class_Present (A_Pre) then\n-               New_Prag := New_Copy_Tree (A_Pre);\n-               Build_Class_Wide_Expression\n-                 (Prag          => New_Prag,\n-                  Subp          => Prim,\n-                  Par_Subp      => Par_Prim,\n-                  Adjust_Sloc   => False,\n-                  Needs_Wrapper => Needs_Wrapper);\n-\n-               if Needs_Wrapper then\n-                  Append (New_Prag, Decls);\n-               end if;\n-            end if;\n-\n-            A_Post := Get_Pragma (Par_Prim, Pragma_Postcondition);\n-\n-            if Present (A_Post) and then Class_Present (A_Post) then\n-               New_Prag := New_Copy_Tree (A_Post);\n-               Build_Class_Wide_Expression\n-                 (Prag           => New_Prag,\n-                  Subp           => Prim,\n-                  Par_Subp       => Par_Prim,\n-                  Adjust_Sloc    => False,\n-                  Needs_Wrapper  => Needs_Wrapper);\n-\n-               if Needs_Wrapper then\n-                  Append (New_Prag, Decls);\n-               end if;\n-            end if;\n+            Build_Inherited_Condition_Pragmas (Prim);\n          end if;\n \n-         if Needs_Wrapper and then not Is_Abstract_Subprogram (Par_Prim) then\n+         if Needs_Wrapper and then not Is_Abstract_Subprogram (Par_Prim)\n+           and then Expander_Active\n+         then\n \n             --  We need to build a new primitive that overrides the inherited\n             --  one, and whose inherited expression has been updated above."}, {"sha": "17b559c529232c9425ef0a669a122f935950596a", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a", "patch": "@@ -3382,6 +3382,13 @@ package body Sem_Ch12 is\n       Set_Ekind  (Id, E_Generic_Package);\n       Set_Etype  (Id, Standard_Void_Type);\n \n+      --  Set SPARK_Mode from context\n+\n+      Set_SPARK_Pragma               (Id, SPARK_Mode_Pragma);\n+      Set_SPARK_Aux_Pragma           (Id, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited     (Id);\n+      Set_SPARK_Aux_Pragma_Inherited (Id);\n+\n       --  Analyze aspects now, so that generated pragmas appear in the\n       --  declarations before building and analyzing the generic copy.\n "}, {"sha": "6b2383a3903adb06425a3dd176c7fa4079c20617", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=6dd86c75d670c3f7ec6bf58c2b9b0950cd5db84a", "patch": "@@ -975,22 +975,20 @@ package body Sem_Ch7 is\n       Set_Ekind  (Id, E_Package);\n       Set_Etype  (Id, Standard_Void_Type);\n \n-      --  Set SPARK_Mode from context only for non-generic package\n+      --  Set SPARK_Mode from context\n \n-      if Ekind (Id) = E_Package then\n-         Set_SPARK_Pragma               (Id, SPARK_Mode_Pragma);\n-         Set_SPARK_Aux_Pragma           (Id, SPARK_Mode_Pragma);\n-         Set_SPARK_Pragma_Inherited     (Id);\n-         Set_SPARK_Aux_Pragma_Inherited (Id);\n+      Set_SPARK_Pragma               (Id, SPARK_Mode_Pragma);\n+      Set_SPARK_Aux_Pragma           (Id, SPARK_Mode_Pragma);\n+      Set_SPARK_Pragma_Inherited     (Id);\n+      Set_SPARK_Aux_Pragma_Inherited (Id);\n \n-         --  Save the state of flag Ignore_SPARK_Mode_Pragmas_In_Instance in\n-         --  case the body of this package is instantiated or inlined later and\n-         --  out of context. The body uses this attribute to restore the value\n-         --  of the global flag.\n+      --  Save the state of flag Ignore_SPARK_Mode_Pragmas_In_Instance in case\n+      --  the body of this package is instantiated or inlined later and out\n+      --  of context. The body uses this attribute to restore the value of\n+      --  the global flag.\n \n-         if Ignore_SPARK_Mode_Pragmas_In_Instance then\n-            Set_Ignore_SPARK_Mode_Pragmas (Id);\n-         end if;\n+      if Ignore_SPARK_Mode_Pragmas_In_Instance then\n+         Set_Ignore_SPARK_Mode_Pragmas (Id);\n       end if;\n \n       --  Analyze aspect specifications immediately, since we need to recognize"}]}