{"sha": "6be492abc282a97ddc84c4e28ce7f0f0594ea5eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJlNDkyYWJjMjgyYTk3ZGRjODRjNGUyOGNlN2YwZjA1OTRlYTVlYg==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-03-22T01:06:47Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-03-22T01:06:47Z"}, "message": "Merged in earlier cccp.c changes\n\nFrom-SVN: r9218", "tree": {"sha": "e2ea112a7f6446fc690d656a0d4f3ff822cebbb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2ea112a7f6446fc690d656a0d4f3ff822cebbb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6be492abc282a97ddc84c4e28ce7f0f0594ea5eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be492abc282a97ddc84c4e28ce7f0f0594ea5eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6be492abc282a97ddc84c4e28ce7f0f0594ea5eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be492abc282a97ddc84c4e28ce7f0f0594ea5eb/comments", "author": null, "committer": null, "parents": [{"sha": "7e1278231a96fa407fb907a36f1ff5d67c13161d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e1278231a96fa407fb907a36f1ff5d67c13161d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e1278231a96fa407fb907a36f1ff5d67c13161d"}], "stats": {"total": 114, "additions": 68, "deletions": 46}, "files": [{"sha": "78ac53591c60759886ffbc5de1f1d69ff3808374", "filename": "gcc/cpplib.c", "status": "modified", "additions": 68, "deletions": 44, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be492abc282a97ddc84c4e28ce7f0f0594ea5eb/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be492abc282a97ddc84c4e28ce7f0f0594ea5eb/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=6be492abc282a97ddc84c4e28ce7f0f0594ea5eb", "patch": "@@ -291,7 +291,7 @@ static void pcstring_used ();\n static int check_macro_name ();\n static int compare_defs ();\n static int compare_token_lists ();\n-static int eval_if_expression ();\n+static HOST_WIDE_INT eval_if_expression ();\n static int change_newlines ();\n static int line_for_error ();\n extern int hashf ();\n@@ -313,6 +313,8 @@ enum file_change_code {same_file, enter_file, leave_file};\n \n /* External declarations.  */\n \n+extern HOST_WIDE_INT cpp_parse_expr PARAMS ((cpp_reader*));\n+\n extern char *getenv ();\n extern FILE *fdopen ();\n extern char *version_string;\n@@ -1696,9 +1698,31 @@ create_definition (buf, limit, pfile, predefinition)\n       defn->args.argnames[i] = 0;\n     }\n   } else {\n-    /* simple expansion or empty definition; gobble it */\n-    if (is_hor_space[*bp])\n-      ++bp;\t\t/* skip exactly one blank/tab char */\n+    /* Simple expansion or empty definition.  */\n+\n+    if (bp < limit)\n+      {\n+\tif (is_hor_space[*bp]) {\n+\t  bp++;\n+\t  SKIP_WHITE_SPACE (bp);\n+\t} else {\n+\t  switch (*bp) {\n+\t    case '!':  case '\"':  case '#':  case '%':  case '&':  case '\\'':\n+\t    case ')':  case '*':  case '+':  case ',':  case '-':  case '.':\n+\t    case '/':  case ':':  case ';':  case '<':  case '=':  case '>':\n+\t    case '?':  case '[':  case '\\\\': case ']':  case '^':  case '{':\n+\t    case '|':  case '}':  case '~':\n+\t      cpp_warning (pfile, \"missing white space after `#define %.*s'\",\n+\t\t\t   sym_length, symname);\n+\t      break;\n+\n+\t    default:\n+\t      cpp_pedwarn (pfile, \"missing white space after `#define %.*s'\",\n+\t\t\t   sym_length, symname);\n+\t      break;\n+\t  }\n+\t}\n+      }\n     /* now everything from bp before limit is the definition. */\n     defn = collect_expansion (pfile, bp, limit, -1, NULL_PTR);\n     defn->args.argnames = (U_CHAR *) \"\";\n@@ -3184,7 +3208,7 @@ do_include (pfile, keyword, unused1, unused2)\n   int angle_brackets = 0;\t/* 0 for \"...\", 1 for <...> */\n   int pcf = -1;\n   char *pcfbuf;\n-  int pcfbuflimit;\n+  char *pcfbuflimit;\n   int pcfnum;\n   f= -1;\t\t\t/* JF we iz paranoid! */\n \n@@ -3383,6 +3407,11 @@ do_include (pfile, keyword, unused1, unused2)\n \t}\n       }\n #endif /* VMS */\n+      /* ??? There are currently 3 separate mechanisms for avoiding processing\n+\t of redundant include files: #import, #pragma once, and\n+\t redundant_include_p.  It would be nice if they were unified.  */\n+      if (redundant_include_p (pfile, fname))\n+\treturn 0;\n       if (importing)\n \tf = lookup_import (pfile, fname, searchptr);\n       else\n@@ -3394,10 +3423,6 @@ do_include (pfile, keyword, unused1, unused2)\n \tcpp_warning (pfile, \"Header file %s exists, but is not readable\",\n \t\t     fname);\n #endif\n-      if (redundant_include_p (pfile, fname)) {\n-\tclose (f);\n-\treturn 0;\n-      }\n       if (f >= 0)\n \tbreak;\n     }\n@@ -3462,8 +3487,6 @@ do_include (pfile, keyword, unused1, unused2)\n \tcpp_error (pfile, \"No include path in which to find %s\", fname);\n     }\n   else {\n-    struct stat stat_f;\n-\n     /* Check to see if this include file is a once-only include file.\n        If so, give up.  */\n \n@@ -3520,34 +3543,39 @@ do_include (pfile, keyword, unused1, unused2)\n     pcfbuf = 0;\n     pcfnum = 0;\n \n-    fstat (f, &stat_f);\n-\n #if 0\n     if (!no_precomp)\n-      do {\n-\tsprintf (pcftry, \"%s%d\", fname, pcfnum++);\n-\t\n-\tpcf = open (pcftry, O_RDONLY, 0666);\n-\tif (pcf != -1)\n-\t  {\n-\t    struct stat s;\n+      {\n+\tstruct stat stat_f;\n \n-\t    fstat (pcf, &s);\n-\t    if (bcmp (&stat_f.st_ino, &s.st_ino, sizeof (s.st_ino))\n-\t\t|| stat_f.st_dev != s.st_dev)\n-\t      {\n-\t\tpcfbuf = check_precompiled (pcf, fname, &pcfbuflimit);\n-\t\t/* Don't need it any more.  */\n-\t\tclose (pcf);\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* Don't need it at all.  */\n-\t\tclose (pcf);\n-\t\tbreak;\n-\t      }\n-\t  }\n-      } while (pcf != -1 && !pcfbuf);\n+\tfstat (f, &stat_f);\n+\n+\tdo {\n+\t  sprintf (pcftry, \"%s%d\", fname, pcfnum++);\n+\n+\t  pcf = open (pcftry, O_RDONLY, 0666);\n+\t  if (pcf != -1)\n+\t    {\n+\t      struct stat s;\n+\n+\t      fstat (pcf, &s);\n+\t      if (bcmp ((char *) &stat_f.st_ino, (char *) &s.st_ino,\n+\t\t\tsizeof (s.st_ino))\n+\t\t  || stat_f.st_dev != s.st_dev)\n+\t\t{\n+\t\t  pcfbuf = check_precompiled (pcf, fname, &pcfbuflimit);\n+\t\t  /* Don't need it any more.  */\n+\t\t  close (pcf);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Don't need it at all.  */\n+\t\t  close (pcf);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t} while (pcf != -1 && !pcfbuf);\n+      }\n #endif\n     \n     /* Actually process the file */\n@@ -4123,9 +4151,7 @@ do_if (pfile, keyword, buf, limit)\n      struct directive *keyword;\n      U_CHAR *buf, *limit;\n {\n-  int value;\n-\n-  value = eval_if_expression (pfile, buf, limit - buf);\n+  HOST_WIDE_INT value = eval_if_expression (pfile, buf, limit - buf);\n   conditional_skip (pfile, value == 0, T_IF, NULL_PTR);\n   return 0;\n }\n@@ -4141,8 +4167,6 @@ do_elif (pfile, keyword, buf, limit)\n      struct directive *keyword;\n      U_CHAR *buf, *limit;\n {\n-  int value;\n-\n   if (pfile->if_stack == CPP_BUFFER (pfile)->if_stack) {\n     cpp_error (pfile, \"`#elif' not within a conditional\");\n     return 0;\n@@ -4164,7 +4188,7 @@ do_elif (pfile, keyword, buf, limit)\n   if (pfile->if_stack->if_succeeded)\n     skip_if_group (pfile, 0);\n   else {\n-    value = eval_if_expression (pfile, buf, limit - buf);\n+    HOST_WIDE_INT value = eval_if_expression (pfile, buf, limit - buf);\n     if (value == 0)\n       skip_if_group (pfile, 0);\n     else {\n@@ -4179,14 +4203,14 @@ do_elif (pfile, keyword, buf, limit)\n  * evaluate a #if expression in BUF, of length LENGTH,\n  * then parse the result as a C expression and return the value as an int.\n  */\n-static int\n+static HOST_WIDE_INT\n eval_if_expression (pfile, buf, length)\n      cpp_reader *pfile;\n      U_CHAR *buf;\n      int length;\n {\n   HASHNODE *save_defined;\n-  int value;\n+  HOST_WIDE_INT value;\n   long old_written = CPP_WRITTEN (pfile);\n \n   save_defined = install (\"defined\", -1, T_SPEC_DEFINED, 0, 0, -1);"}, {"sha": "68f946418f3704f2a7aca5822d0a447eb862e78a", "filename": "gcc/cpplib.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be492abc282a97ddc84c4e28ce7f0f0594ea5eb/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be492abc282a97ddc84c4e28ce7f0f0594ea5eb/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=6be492abc282a97ddc84c4e28ce7f0f0594ea5eb", "patch": "@@ -650,8 +650,6 @@ extern cpp_buffer* cpp_pop_buffer PARAMS ((cpp_reader *));\n extern cpp_hashnode* cpp_lookup PARAMS ((cpp_reader*, const U_CHAR*,\n \t\t\t\t\t int, int));\n \n-extern long cpp_parse_expr PARAMS ((cpp_reader*));\n-\n #ifdef __cplusplus\n }\n #endif"}]}