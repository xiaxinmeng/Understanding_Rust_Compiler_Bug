{"sha": "571d3fb1f40fa85c769a7dbefd84da6c6e99665d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTcxZDNmYjFmNDBmYTg1Yzc2OWE3ZGJlZmQ4NGRhNmM2ZTk5NjY1ZA==", "commit": {"author": {"name": "Joffrey Huguet", "email": "huguet@adacore.com", "date": "2020-11-12T09:40:16Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-12-16T13:01:04Z"}, "message": "[Ada] Add contracts to Ada.Strings.Fixed\n\ngcc/ada/\n\n\t* libgnat/a-strfix.ads: Add postconditions and contract cases to\n\tsubprograms.", "tree": {"sha": "87abf93fe1d3f06c3a4b7e51e6c320e4e184a071", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87abf93fe1d3f06c3a4b7e51e6c320e4e184a071"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/571d3fb1f40fa85c769a7dbefd84da6c6e99665d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/571d3fb1f40fa85c769a7dbefd84da6c6e99665d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/571d3fb1f40fa85c769a7dbefd84da6c6e99665d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/571d3fb1f40fa85c769a7dbefd84da6c6e99665d/comments", "author": {"login": "joffreyhuguet", "id": 36951399, "node_id": "MDQ6VXNlcjM2OTUxMzk5", "avatar_url": "https://avatars.githubusercontent.com/u/36951399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joffreyhuguet", "html_url": "https://github.com/joffreyhuguet", "followers_url": "https://api.github.com/users/joffreyhuguet/followers", "following_url": "https://api.github.com/users/joffreyhuguet/following{/other_user}", "gists_url": "https://api.github.com/users/joffreyhuguet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joffreyhuguet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joffreyhuguet/subscriptions", "organizations_url": "https://api.github.com/users/joffreyhuguet/orgs", "repos_url": "https://api.github.com/users/joffreyhuguet/repos", "events_url": "https://api.github.com/users/joffreyhuguet/events{/privacy}", "received_events_url": "https://api.github.com/users/joffreyhuguet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1d0c4c80058923fbf681d1d80ff90eeb7883949", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1d0c4c80058923fbf681d1d80ff90eeb7883949", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1d0c4c80058923fbf681d1d80ff90eeb7883949"}], "stats": {"total": 894, "additions": 848, "deletions": 46}, "files": [{"sha": "4214157501152276944e393fc4730acf21811f15", "filename": "gcc/ada/libgnat/a-strfix.ads", "status": "modified", "additions": 848, "deletions": 46, "changes": 894, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d3fb1f40fa85c769a7dbefd84da6c6e99665d/gcc%2Fada%2Flibgnat%2Fa-strfix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d3fb1f40fa85c769a7dbefd84da6c6e99665d/gcc%2Fada%2Flibgnat%2Fa-strfix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strfix.ads?ref=571d3fb1f40fa85c769a7dbefd84da6c6e99665d", "patch": "@@ -108,10 +108,57 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       Going   : Direction := Forward;\n       Mapping : Maps.Character_Mapping_Function) return Natural\n    with\n-     Pre    =>\n+     Pre            =>\n        Pattern'Length /= 0\n          and then (if Source'Length /= 0 then From in Source'Range),\n-     Global => null;\n+\n+     Post           => Index'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+        --  If no slice in the considered range of Source matches Pattern,\n+        --  then 0 is returned.\n+\n+       ((for all J in Source'Range =>\n+           (if (if Going = Forward\n+                then J in From .. Source'Last - Pattern'Length + 1\n+                else J <= From - Pattern'Length + 1)\n+            then Translate (Source (J .. J - 1 + Pattern'Length), Mapping)\n+                 /= Pattern))\n+        =>\n+          Index'Result = 0,\n+\n+        --  Otherwise, a valid index is returned\n+\n+        others\n+        =>\n+\n+          --  The result is in the considered range of Source\n+\n+          (if Going = Forward\n+           then Index'Result in From .. Source'Last - Pattern'Length + 1\n+           else Index'Result in Source'First .. From - Pattern'Length + 1)\n+\n+            --  The slice beginning at the returned index matches Pattern\n+\n+            and then\n+              Translate (Source (Index'Result\n+                                 .. Index'Result - 1 + Pattern'Length),\n+                         Mapping)\n+              = Pattern\n+\n+            --  The result is the smallest or largest index which satisfies the\n+            --  matching, respectively when Going = Forward and\n+            --  Going = Backwards.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if (if Going = Forward\n+                      then J in From .. Index'Result - 1\n+                      else J - 1 in Index'Result .. From - Pattern'Length)\n+                  then Translate (Source (J .. J - 1 + Pattern'Length),\n+                                  Mapping)\n+                       /= Pattern))),\n+     Global         => null;\n    pragma Ada_05 (Index);\n \n    function Index\n@@ -121,10 +168,57 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       Going   : Direction := Forward;\n       Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n    with\n-     Pre    =>\n+     Pre            =>\n        Pattern'Length /= 0\n          and then (if Source'Length /= 0 then From in Source'Range),\n-     Global => null;\n+\n+     Post           => Index'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+        --  If no slice in the considered range of Source matches Pattern,\n+        --  then 0 is returned.\n+\n+       ((for all J in Source'Range =>\n+           (if (if Going = Forward\n+                then J in From .. Source'Last - Pattern'Length + 1\n+                else J <= From - Pattern'Length + 1)\n+            then Translate (Source (J .. J - 1 + Pattern'Length), Mapping)\n+                 /= Pattern))\n+        =>\n+          Index'Result = 0,\n+\n+        --  Otherwise, a valid index is returned\n+\n+        others\n+        =>\n+\n+          --  The result is in the considered range of Source\n+\n+          (if Going = Forward\n+           then Index'Result in From .. Source'Last - Pattern'Length + 1\n+           else Index'Result in Source'First .. From - Pattern'Length + 1)\n+\n+            --  The slice beginning at the returned index matches Pattern\n+\n+            and then\n+              Translate (Source (Index'Result\n+                                 .. Index'Result - 1 + Pattern'Length),\n+                         Mapping)\n+              = Pattern\n+\n+            --  The result is the smallest or largest index which satisfies the\n+            --  matching, respectively when Going = Forward and\n+            --  Going = Backwards.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if (if Going = Forward\n+                      then J in From .. Index'Result - 1\n+                      else J - 1 in Index'Result .. From - Pattern'Length)\n+                  then Translate (Source (J .. J - 1 + Pattern'Length),\n+                                  Mapping)\n+                       /= Pattern))),\n+     Global         => null;\n    pragma Ada_05 (Index);\n \n    --  Each Index function searches, starting from From, for a slice of\n@@ -146,17 +240,107 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       Going   : Direction := Forward;\n       Mapping : Maps.Character_Mapping := Maps.Identity) return Natural\n    with\n-     Pre    => Pattern'Length > 0,\n-     Global => null;\n+     Pre            => Pattern'Length > 0,\n+\n+     Post           => Index'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+        --  If Source is empty, or if no slice of Source matches Pattern, then\n+        --  0 is returned.\n+\n+       (Source'Length = 0\n+          or else\n+            (for all J in Source'First .. Source'Last - Pattern'Length + 1 =>\n+               Translate (Source (J .. J - 1 + Pattern'Length), Mapping)\n+               /= Pattern)\n+        =>\n+          Index'Result = 0,\n+\n+        --  Otherwise, a valid index is returned\n+\n+        others\n+        =>\n+\n+          --  The result is in the considered range of Source\n+\n+          Index'Result in Source'First .. Source'Last - Pattern'Length + 1\n+\n+            --  The slice beginning at the returned index matches Pattern\n+\n+            and then\n+              Translate (Source (Index'Result\n+                                 .. Index'Result - 1 + Pattern'Length),\n+                         Mapping)\n+              = Pattern\n+\n+            --  The result is the smallest or largest index which satisfies the\n+            --  matching, respectively when Going = Forward and\n+            --  Going = Backwards.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if (if Going = Forward\n+                      then J <= Index'Result - 1\n+                      else J - 1 in Index'Result\n+                                    .. Source'Last - Pattern'Length)\n+                  then Translate (Source (J .. J - 1 + Pattern'Length),\n+                                  Mapping)\n+                       /= Pattern))),\n+     Global         => null;\n \n    function Index\n      (Source  : String;\n       Pattern : String;\n       Going   : Direction := Forward;\n       Mapping : Maps.Character_Mapping_Function) return Natural\n    with\n-     Pre    => Pattern'Length /= 0,\n-     Global => null;\n+     Pre            => Pattern'Length > 0,\n+\n+     Post           => Index'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+        --  If Source is empty, or if no slice of Source matches Pattern, then\n+        --  0 is returned.\n+\n+       (Source'Length = 0\n+          or else\n+            (for all J in Source'First .. Source'Last - Pattern'Length + 1 =>\n+               Translate (Source (J .. J - 1 + Pattern'Length), Mapping)\n+               /= Pattern)\n+        =>\n+          Index'Result = 0,\n+\n+        --  Otherwise, a valid index is returned\n+\n+        others\n+        =>\n+\n+          --  The result is in the considered range of Source\n+\n+          Index'Result in Source'First .. Source'Last - Pattern'Length + 1\n+\n+            --  The slice beginning at the returned index matches Pattern\n+\n+            and then\n+              Translate (Source (Index'Result\n+                                 .. Index'Result - 1 + Pattern'Length),\n+                         Mapping)\n+              = Pattern\n+\n+            --  The result is the smallest or largest index which satisfies the\n+            --  matching, respectively when Going = Forward and\n+            --  Going = Backwards.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if (if Going = Forward\n+                      then J <= Index'Result - 1\n+                      else J - 1 in Index'Result\n+                                    .. Source'Last - Pattern'Length)\n+                  then Translate (Source (J .. J - 1 + Pattern'Length),\n+                                  Mapping)\n+                       /= Pattern))),\n+     Global         => null;\n \n    --  If Going = Forward, returns:\n    --\n@@ -172,7 +356,44 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       Test   : Membership := Inside;\n       Going  : Direction  := Forward) return Natural\n    with\n-     Global => null;\n+     Post           => Index'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+        --  If no character of Source satisfies the property Test on Set, then\n+        --  0 is returned.\n+\n+       ((for all C of Source =>\n+           (Test = Inside) /= Ada.Strings.Maps.Is_In (C, Set))\n+        =>\n+          Index'Result = 0,\n+\n+        --  Otherwise, a index in the range of Source is returned\n+\n+        others\n+        =>\n+\n+          --  The result is in the range of Source\n+\n+          Index'Result in Source'Range\n+\n+            --  The character at the returned index satisfies the property\n+            --  Test on Set\n+\n+            and then\n+              (Test = Inside)\n+              = Ada.Strings.Maps.Is_In (Source (Index'Result), Set)\n+\n+            --  The result is the smallest or largest index which satisfies the\n+            --  property, respectively when Going = Forward and\n+            --  Going = Backwards.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if J /= Index'Result\n+                       and then (J < Index'Result) = (Going = Forward)\n+                  then (Test = Inside)\n+                       /= Ada.Strings.Maps.Is_In (Source (J), Set)))),\n+     Global         => null;\n \n    function Index\n      (Source  : String;\n@@ -181,8 +402,53 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       Test    : Membership := Inside;\n       Going   : Direction := Forward) return Natural\n    with\n-     Pre    => (if Source'Length /= 0 then From in Source'Range),\n-     Global => null;\n+     Pre            => (if Source'Length /= 0 then From in Source'Range),\n+\n+     Post           => Index'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+        --  If no character in the considered slice of Source satisfies the\n+        --  property Test on Set, then 0 is returned.\n+\n+       ((for all I in Source'Range =>\n+           (if I = From\n+                 or else (I > From) = (Going = Forward)\n+            then (Test = Inside) /= Ada.Strings.Maps.Is_In (Source (I), Set)))\n+        =>\n+          Index'Result = 0,\n+\n+        --  Otherwise, an index in the range of Source is returned\n+\n+        others\n+        =>\n+\n+          --  The result is in the considered range of Source\n+\n+          Index'Result in Source'Range\n+            and then (Index'Result = From\n+                        or else (Index'Result > From) = (Going = Forward))\n+\n+            --  The character at the returned index satisfies the property\n+            --  Test on Set.\n+\n+            and then\n+              (Test = Inside)\n+              = Ada.Strings.Maps.Is_In (Source (Index'Result), Set)\n+\n+            --  The result is the smallest or largest index which satisfies the\n+            --  property, respectively when Going = Forward and\n+            --  Going = Backwards.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if J /= Index'Result\n+                       and then (J < Index'Result) = (Going = Forward)\n+                       and then (J = From\n+                                   or else (J > From) = (Going = Forward))\n+                  then\n+                    (Test = Inside)\n+                    /= Ada.Strings.Maps.Is_In (Source (J), Set)))),\n+     Global         => null;\n    pragma Ada_05 (Index);\n    --  Index searches for the first or last occurrence of any of a set of\n    --  characters (when Test=Inside), or any of the complement of a set of\n@@ -198,16 +464,87 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       From   : Positive;\n       Going  : Direction := Forward) return Natural\n    with\n-     Pre   => (if Source'Length /= 0 then From in Source'Range),\n-     Global => null;\n+     Pre            => (if Source'Length /= 0 then From in Source'Range),\n+\n+     Post           => Index_Non_Blank'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+        --  If all characters in the considered slice of Source are Space\n+        --  characters, then 0 is returned.\n+\n+       ((for all J in Source'Range =>\n+           (if J = From or else (J > From) = (Going = Forward)\n+            then Source (J) = ' '))\n+        =>\n+          Index_Non_Blank'Result = 0,\n+\n+        --  Otherwise, a valid index is returned\n+\n+        others\n+        =>\n+\n+          --  The result is in the considered range of Source\n+\n+          Index_Non_Blank'Result in Source'Range\n+            and then (Index_Non_Blank'Result = From\n+                        or else (Index_Non_Blank'Result > From)\n+                                = (Going = Forward))\n+\n+            --  The character at the returned index is not a Space character\n+\n+            and then Source (Index_Non_Blank'Result) /= ' '\n+\n+            --  The result is the smallest or largest index which is not a\n+            --  Space character, respectively when Going = Forward and\n+            --  Going = Backwards.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if J /= Index_Non_Blank'Result\n+                       and then (J < Index_Non_Blank'Result)\n+                                = (Going = Forward)\n+                       and then (J = From or else (J > From)\n+                                = (Going = Forward))\n+                  then Source (J) = ' '))),\n+     Global         => null;\n    pragma Ada_05 (Index_Non_Blank);\n    --  Returns Index (Source, Maps.To_Set(Space), From, Outside, Going)\n \n    function Index_Non_Blank\n      (Source : String;\n       Going  : Direction := Forward) return Natural\n    with\n-     Global => null;\n+     Post           => Index_Non_Blank'Result in 0 | Source'Range,\n+     Contract_Cases =>\n+\n+        --  If all characters of Source are Space characters, then 0 is\n+        --  returned.\n+\n+       ((for all C of Source => C = ' ') => Index_Non_Blank'Result = 0,\n+\n+        --  Otherwise, a valid index is returned\n+\n+        others                           =>\n+\n+          --  The result is in the range of Source\n+\n+          Index_Non_Blank'Result in Source'Range\n+\n+            --  The character at the returned index is not a Space character\n+\n+            and then Source (Index_Non_Blank'Result) /= ' '\n+\n+            --  The result is the smallest or largest index which is not a\n+            --  Space character, respectively when Going = Forward and\n+            --  Going = Backwards.\n+\n+            and then\n+              (for all J in Source'Range =>\n+                 (if J /= Index_Non_Blank'Result\n+                       and then (J < Index_Non_Blank'Result)\n+                              = (Going = Forward)\n+                  then Source (J) = ' '))),\n+     Global         => null;\n    --  Returns Index (Source, Maps.To_Set(Space), Outside, Going)\n \n    function Count\n@@ -246,8 +583,53 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       First  : out Positive;\n       Last   : out Natural)\n    with\n-     Pre    => (if Source'Length /= 0 then From in Source'Range),\n-     Global => null;\n+     Pre            => (if Source'Length /= 0 then From in Source'Range),\n+     Contract_Cases =>\n+\n+        --  If Source is the empty string, or if no character of the considered\n+        --  slice of Source satisfies the property Test on Set, then First is\n+        --  set to From and Last is set to 0.\n+\n+       (Source'Length = 0\n+          or else\n+            (for all C of Source (From .. Source'Last) =>\n+               (Test = Inside) /= Ada.Strings.Maps.Is_In (C, Set))\n+        =>\n+          First = From and then Last = 0,\n+\n+        --  Otherwise, First and Last are set to valid indexes\n+\n+        others\n+        =>\n+\n+          --  First and Last are in the considered range of Source\n+\n+          First in From .. Source'Last\n+            and then Last in First .. Source'Last\n+\n+            --  No character between From and First satisfies the property Test\n+            --  on Set.\n+\n+            and then\n+              (for all C of Source (From .. First - 1) =>\n+                 (Test = Inside) /= Ada.Strings.Maps.Is_In (C, Set))\n+\n+            --  All characters between First and Last satisfy the property Test\n+            --  on Set.\n+\n+            and then\n+              (for all C of Source (First .. Last) =>\n+                 (Test = Inside) = Ada.Strings.Maps.Is_In (C, Set))\n+\n+            --  If Last is not Source'Last, then the character at position\n+            --  Last + 1 does not satify the property Test on Set.\n+\n+            and then\n+              (if Last < Source'Last\n+               then\n+                 (Test = Inside)\n+                 /= Ada.Strings.Maps.Is_In (Source (Last + 1), Set))),\n+     Global         => null;\n    pragma Ada_2012 (Find_Token);\n    --  If Source is not the null string and From is not in Source'Range, then\n    --  Index_Error is raised. Otherwise, First is set to the index of the first\n@@ -264,6 +646,50 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       First  : out Positive;\n       Last   : out Natural)\n    with\n+     Contract_Cases =>\n+\n+        --  If Source is the empty string, or if no character of Source\n+        --  satisfies the property Test on Set, then First is set to From and\n+        --  Last is set to 0.\n+\n+       (Source'Length = 0\n+          or else\n+            (for all C of Source =>\n+               (Test = Inside) /= Ada.Strings.Maps.Is_In (C, Set))\n+        =>\n+          First = Source'First and then Last = 0,\n+\n+        --  Otherwise, First and Last are set to valid indexes\n+\n+        others\n+        =>\n+\n+          --  First and Last are in the considered range of Source\n+\n+          First in Source'Range\n+            and then Last in First .. Source'Last\n+\n+            --  No character before First satisfies the property Test on Set\n+\n+            and then\n+              (for all C of Source (Source'First .. First - 1) =>\n+                 (Test = Inside) /= Ada.Strings.Maps.Is_In (C, Set))\n+\n+            --  All characters between First and Last satisfy the property Test\n+            --  on Set.\n+\n+            and then\n+              (for all C of Source (First .. Last) =>\n+                 (Test = Inside) = Ada.Strings.Maps.Is_In (C, Set))\n+\n+            --  If Last is not Source'Last, then the character at position\n+            --  Last + 1 does not satify the property Test on Set.\n+\n+            and then\n+              (if Last < Source'Last\n+               then\n+                 (Test = Inside)\n+                 /= Ada.Strings.Maps.Is_In (Source (Last + 1), Set))),\n      Global => null;\n    --  Equivalent to Find_Token (Source, Set, Source'First, Test, First, Last)\n \n@@ -275,14 +701,46 @@ package Ada.Strings.Fixed with SPARK_Mode is\n      (Source  : String;\n       Mapping : Maps.Character_Mapping_Function) return String\n    with\n-     Post   => Translate'Result'Length = Source'Length,\n+     Post   =>\n+\n+       --  Lower bound of the returned string is 1\n+\n+       Translate'Result'First = 1\n+\n+         --  The returned string has the same length as Source\n+\n+         and then Translate'Result'Last = Source'Length\n+\n+         --  Each character in the returned string is the translation of the\n+         --  character at the same position in Source through Mapping.\n+\n+         and then\n+           (for all J in Source'Range =>\n+              Translate'Result (J - Source'First + 1)\n+              = Mapping (Source (J))),\n      Global => null;\n \n    function Translate\n      (Source  : String;\n       Mapping : Maps.Character_Mapping) return String\n    with\n-     Post   => Translate'Result'Length = Source'Length,\n+     Post   =>\n+\n+       --  Lower bound of the returned string is 1\n+\n+       Translate'Result'First = 1\n+\n+         --  The returned string has the same length as Source\n+\n+         and then Translate'Result'Last = Source'Length\n+\n+         --  Each character in the returned string is the translation of the\n+         --  character at the same position in Source through Mapping.\n+\n+         and then\n+           (for all J in Source'Range =>\n+              Translate'Result (J - Source'First + 1)\n+              = Ada.Strings.Maps.Value (Mapping, Source (J))),\n      Global => null;\n \n    --  Returns the string S whose length is Source'Length and such that S (I)\n@@ -293,12 +751,25 @@ package Ada.Strings.Fixed with SPARK_Mode is\n      (Source  : in out String;\n       Mapping : Maps.Character_Mapping_Function)\n    with\n+     Post   =>\n+\n+       --  Each character in Source after the call is the translation of\n+       --  the character at the same position before the call, through Mapping.\n+\n+       (for all J in Source'Range => Source (J) = Mapping (Source'Old (J))),\n      Global => null;\n \n    procedure Translate\n      (Source  : in out String;\n       Mapping : Maps.Character_Mapping)\n    with\n+     Post   =>\n+\n+       --  Each character in Source after the call is the translation of\n+       --  the character at the same position before the call, through Mapping.\n+\n+       (for all J in Source'Range =>\n+          Source (J) = Ada.Strings.Maps.Value (Mapping, Source'Old (J))),\n      Global => null;\n \n    --  Equivalent to Source := Translate(Source, Mapping)\n@@ -344,17 +815,80 @@ package Ada.Strings.Fixed with SPARK_Mode is\n          and then High >= Source'First - 1\n          and then (if High >= Low\n                    then Natural'Max (0, Low - Source'First)\n-                     <= Natural'Last - By'Length\n-                      - Natural'Max (Source'Last - High, 0)\n+                        <= Natural'Last\n+                           - By'Length\n+                           - Natural'Max (Source'Last - High, 0)\n                    else Source'Length <= Natural'Last - By'Length),\n+\n+     --  Lower bound of the returned string is 1\n+\n+     Post           => Replace_Slice'Result'First = 1,\n      Contract_Cases =>\n+\n+        --  If High >= Low, then the returned string comprises\n+        --  Source (Source'First .. Low - 1) & By\n+        --  & Source(High + 1 .. Source'Last).\n+\n        (High >= Low =>\n+\n+          --  Length of the returned string\n+\n           Replace_Slice'Result'Length\n-        = Natural'Max (0, Low - Source'First)\n-        + By'Length\n-        + Natural'Max (Source'Last - High, 0),\n+          = Natural'Max (0, Low - Source'First)\n+            + By'Length\n+            + Natural'Max (Source'Last - High, 0)\n+\n+            --  Elements starting at Low are replaced by elements of By\n+\n+            and then\n+              Replace_Slice'Result (1 .. Natural'Max (0, Low - Source'First))\n+              = Source (Source'First .. Low - 1)\n+            and then\n+              Replace_Slice'Result\n+                (Natural'Max (0, Low - Source'First) + 1\n+                 .. Natural'Max (0, Low - Source'First) + By'Length)\n+              = By\n+\n+            --  When there are remaining characters after the replaced slice,\n+            --  they are appended to the result.\n+\n+            and then\n+              (if High < Source'Last\n+               then\n+                 Replace_Slice'Result\n+                   (Natural'Max (0, Low - Source'First) + By'Length + 1\n+                    .. Replace_Slice'Result'Last)\n+                 = Source (High + 1 .. Source'Last)),\n+\n+        --  If High < Low, then the returned string is\n+        --  Insert (Source, Before => Low, New_Item => By).\n+\n         others      =>\n-          Replace_Slice'Result'Length = Source'Length + By'Length),\n+\n+          --  Length of the returned string\n+\n+          Replace_Slice'Result'Length = Source'Length + By'Length\n+\n+            --  Elements of By are inserted after the element at Low\n+\n+            and then\n+              Replace_Slice'Result (1 .. Low - Source'First)\n+              = Source (Source'First .. Low - 1)\n+            and then\n+              Replace_Slice'Result\n+                (Low - Source'First + 1 .. Low - Source'First + By'Length)\n+              = By\n+\n+            --  When there are remaining characters after Low in Source, they\n+            --  are appended to the result.\n+\n+            and then\n+              (if Low < Source'Last\n+               then\n+                Replace_Slice'Result\n+                  (Low - Source'First + By'Length + 1\n+                   .. Replace_Slice'Result'Last)\n+                = Source (Low .. Source'Last))),\n      Global         => null;\n    --  Equivalent to:\n    --\n@@ -369,7 +903,38 @@ package Ada.Strings.Fixed with SPARK_Mode is\n      Pre    =>\n        Before - 1 in Source'First - 1 .. Source'Last\n          and then Source'Length <= Natural'Last - New_Item'Length,\n-     Post   => Insert'Result'Length = Source'Length + New_Item'Length,\n+\n+     Post   =>\n+\n+       --  Lower bound of the returned string is 1\n+\n+       Insert'Result'First = 1\n+\n+         --  Length of the returned string\n+\n+         and then Insert'Result'Length = Source'Length + New_Item'Length\n+\n+         --  Elements of New_Item are inserted after element at Before\n+\n+         and then\n+           Insert'Result (1 .. Before - Source'First)\n+           = Source (Source'First .. Before - 1)\n+         and then\n+           Insert'Result\n+             (Before - Source'First + 1\n+              .. Before - Source'First + New_Item'Length)\n+           = New_Item\n+\n+         --  When there are remaining characters after Before in Source, they\n+         --  are appended to the returned string.\n+\n+         and then\n+           (if Before - 1 < Source'Last\n+            then\n+              Insert'Result\n+                (Before - Source'First + New_Item'Length + 1\n+                 .. Insert'Result'Last)\n+              = Source (Before .. Source'Last)),\n      Global => null;\n    --  Propagates Index_Error if Before is not in\n    --  Source'First .. Source'Last+1; otherwise, returns\n@@ -397,12 +962,44 @@ package Ada.Strings.Fixed with SPARK_Mode is\n      Pre    =>\n        Position - 1 in Source'First - 1 .. Source'Last\n          and then\n-       (if Position - Source'First >= Source'Length - New_Item'Length\n-        then Position - Source'First <= Natural'Last - New_Item'Length),\n+           (if Position - Source'First >= Source'Length - New_Item'Length\n+            then Position - Source'First <= Natural'Last - New_Item'Length),\n+\n      Post   =>\n-       Overwrite'Result'Length\n-     = Integer'Max (Source'Length,\n-                    Position - Source'First + New_Item'Length),\n+\n+       --  Lower bound of the returned string is 1\n+\n+       Overwrite'Result'First = 1\n+\n+         --  Length of the returned string\n+\n+         and then\n+           Overwrite'Result'Length\n+           = Integer'Max (Source'Length,\n+                          Position - Source'First + New_Item'Length)\n+\n+         --  Elements after Position are replaced by elements of New_Item\n+\n+         and then\n+           Overwrite'Result (1 .. Position - Source'First)\n+           = Source (Source'First .. Position - 1)\n+         and then\n+           Overwrite'Result\n+             (Position - Source'First + 1\n+              .. Position - Source'First + New_Item'Length)\n+           = New_Item\n+\n+         --  If the end of Source is reached before the characters in New_Item\n+         --  are exhausted, the remaining characters from New_Item are appended\n+         --  to the string.\n+\n+         and then\n+           (if Position <= Source'Last - New_Item'Length\n+            then\n+              Overwrite'Result\n+                (Position - Source'First + New_Item'Length + 1\n+                 .. Overwrite'Result'Last)\n+              = Source (Position + New_Item'Length .. Source'Last)),\n      Global => null;\n    --  Propagates Index_Error if Position is not in\n    --  Source'First .. Source'Last + 1; otherwise, returns the string obtained\n@@ -429,15 +1026,47 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       From    : Positive;\n       Through : Natural) return String\n    with\n-     Pre    => (if From <= Through\n-                then (From in Source'Range\n-                        and then Through <= Source'Last)),\n-     Post   =>\n-       Delete'Result'Length\n-     = Source'Length - (if From <= Through\n-                        then Through - From + 1\n-                        else 0),\n-     Global => null;\n+     Pre            => (if From <= Through\n+                        then (From in Source'Range\n+                                and then Through <= Source'Last)),\n+\n+     --  Lower bound of the returned string is 1\n+\n+     Post           =>\n+       Delete'Result'First = 1,\n+\n+     Contract_Cases =>\n+\n+        --  If From <= Through, the characters between From and Through are\n+        --  removed.\n+\n+       (From <= Through =>\n+\n+          --  Length of the returned string\n+\n+          Delete'Result'Length = Source'Length - (Through - From + 1)\n+\n+            --  Elements before From are preserved\n+\n+            and then\n+              Delete'Result (1 .. From - Source'First)\n+              = Source (Source'First .. From - 1)\n+\n+            --  If there are remaining characters after Through, they are\n+            --  appended to the returned string.\n+\n+            and then\n+              (if Through < Source'Last\n+               then Delete'Result\n+                      (From - Source'First + 1 .. Delete'Result'Last)\n+                    = Source (Through + 1 .. Source'Last)),\n+\n+        --  Otherwise, the returned string is Source with lower bound 1\n+\n+        others          =>\n+          Delete'Result'Length = Source'Length\n+            and then Delete'Result = Source),\n+     Global         => null;\n    --  If From <= Through, the returned string is\n    --  Replace_Slice(Source, From, Through, \"\"); otherwise, it is Source with\n    --  lower bound 1.\n@@ -469,7 +1098,47 @@ package Ada.Strings.Fixed with SPARK_Mode is\n      (Source : String;\n       Side   : Trim_End) return String\n    with\n-     Post   => Trim'Result'Length <= Source'Length,\n+     Post   =>\n+\n+       --  Lower bound of the returned string is 1\n+\n+       Trim'Result'First = 1\n+\n+       --  If all characters in Source are Space, the returned string is\n+       --  empty.\n+\n+         and then\n+           (if (for all J in Source'Range => Source (J) = ' ')\n+            then Trim'Result = \"\"\n+\n+            --  Otherwise, the returned string is a slice of Source\n+\n+            else\n+              (for some Low in Source'Range =>\n+                 (for some High in Source'Range =>\n+\n+                    --  Trim returns the slice of Source between Low and High\n+\n+                    Trim'Result = Source (Low .. High)\n+\n+                      --  Values of Low and High and the characters at their\n+                      --  position depend on Side.\n+\n+                      and then\n+                        (if Side = Left then High = Source'Last\n+                         else Source (High) /= ' ')\n+                      and then\n+                        (if Side = Right then Low = Source'First\n+                         else Source (Low) /= ' ')\n+\n+                      --  All characters outside range Low .. High are\n+                      --  Space characters.\n+\n+                      and then\n+                        (for all J in Source'Range =>\n+                           (if J < Low then Source (J) = ' ')\n+                              and then\n+                                (if J > High then Source (J) = ' '))))),\n      Global => null;\n    --  Returns the string obtained by removing from Source all leading Space\n    --  characters (if Side = Left), all trailing Space characters (if\n@@ -495,7 +1164,50 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       Left   : Maps.Character_Set;\n       Right  : Maps.Character_Set) return String\n    with\n-     Post   => Trim'Result'Length <= Source'Length,\n+     Post   =>\n+\n+       --  Lower bound of the returned string is 1\n+\n+       Trim'Result'First = 1\n+\n+         --  If all characters are contained in one of the sets Left and Right,\n+         --  then the returned string is empty.\n+\n+         and then\n+           (if (for all K in Source'Range =>\n+                  Ada.Strings.Maps.Is_In (Source (K), Left))\n+                 or\n+                   (for all K in Source'Range =>\n+                      Ada.Strings.Maps.Is_In (Source (K), Right))\n+            then Trim'Result = \"\"\n+\n+        --  Otherwise, the returned string is a slice of Source\n+\n+        else\n+          (for some Low in Source'Range =>\n+             (for some High in Source'Range =>\n+\n+                --  Trim returns the slice of Source between Low and High\n+\n+                Trim'Result = Source (Low .. High)\n+\n+                  --  Characters at the bounds of the returned string are\n+                  --  not contained in Left or Right.\n+\n+                  and then not Ada.Strings.Maps.Is_In (Source (Low), Left)\n+                  and then not Ada.Strings.Maps.Is_In (Source (High), Right)\n+\n+                  --  All characters before Low are contained in Left.\n+                  --  All characters after High are contained in Right.\n+\n+                  and then\n+                    (for all K in Source'Range =>\n+                       (if K < Low\n+                        then\n+                          Ada.Strings.Maps.Is_In (Source (K), Left))\n+                            and then\n+                              (if K > High then\n+                               Ada.Strings.Maps.Is_In (Source (K), Right)))))),\n      Global => null;\n    --  Returns the string obtained by removing from Source all leading\n    --  characters in Left and all trailing characters in Right.\n@@ -521,8 +1233,33 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       Count  : Natural;\n       Pad    : Character := Space) return String\n    with\n-     Post   => Head'Result'Length = Count,\n-     Global => null;\n+     Post           =>\n+\n+       --  Lower bound of the returned string is 1\n+\n+       Head'Result'First = 1\n+\n+         --  Length of the returned string is Count.\n+\n+         and then Head'Result'Length = Count,\n+\n+     Contract_Cases =>\n+\n+        --  If Count <= Source'Length, then the first Count characters of\n+        --  Source are returned.\n+\n+       (Count <= Source'Length =>\n+          Head'Result = Source (Source'First .. Source'First - 1 + Count),\n+\n+        --  Otherwise, the returned string is Source concatenated with\n+        --  Count - Source'Length Pad characters.\n+\n+        others                 =>\n+          Head'Result (1 .. Source'Length) = Source\n+            and then\n+              Head'Result (Source'Length + 1 .. Count)\n+              = (1 .. Count - Source'Length => Pad)),\n+     Global         => null;\n    --  Returns a string of length Count. If Count <= Source'Length, the string\n    --  comprises the first Count characters of Source. Otherwise, its contents\n    --  are Source concatenated with Count - Source'Length Pad characters.\n@@ -547,7 +1284,44 @@ package Ada.Strings.Fixed with SPARK_Mode is\n       Count  : Natural;\n       Pad    : Character := Space) return String\n    with\n-     Post   => Tail'Result'Length = Count,\n+     Post   =>\n+\n+       --  Lower bound of the returned string is 1\n+\n+       Tail'Result'First = 1\n+\n+         --  Length of the returned string is Count\n+\n+         and then Tail'Result'Length = Count,\n+     Contract_Cases =>\n+\n+       --  If Count is zero, then the returned string is empty\n+\n+       (Count = 0                     =>\n+          Tail'Result = \"\",\n+\n+        --  Otherwise, if Count <= Source'Length, then the last Count\n+        --  characters of Source are returned.\n+\n+        (Count in 1 .. Source'Length) =>\n+          Tail'Result = Source (Source'Last - Count + 1 .. Source'Last),\n+\n+        --  Otherwise, the returned string is Count - Source'Length Pad\n+        --  characters concatenated with Source.\n+\n+        others                        =>\n+\n+           --  If Source is empty, then the returned string is Count Pad\n+           --  characters.\n+\n+          (if Source'Length = 0\n+           then Tail'Result = (1 .. Count => Pad)\n+           else\n+             Tail'Result (1 .. Count - Source'Length)\n+             = (1 .. Count - Source'Length => Pad)\n+               and then\n+                 Tail'Result (Count - Source'Length + 1 .. Tail'Result'Last)\n+                 = Source)),\n      Global => null;\n    --  Returns a string of length Count. If Count <= Source'Length, the string\n    --  comprises the last Count characters of Source. Otherwise, its contents\n@@ -576,15 +1350,43 @@ package Ada.Strings.Fixed with SPARK_Mode is\n      (Left  : Natural;\n       Right : Character) return String\n    with\n-     Post   => \"*\"'Result'Length = Left,\n+     Post   =>\n+\n+       --  Lower bound of the returned string is 1\n+\n+       \"*\"'Result'First = 1\n+\n+         --  Length of the returned string\n+\n+         and then \"*\"'Result'Length = Left\n+\n+         --  All characters of the returned string are Right\n+\n+         and then (for all C of \"*\"'Result => C = Right),\n      Global => null;\n \n    function \"*\"\n      (Left  : Natural;\n       Right : String) return String\n    with\n      Pre    => (if Right'Length /= 0 then Left <= Natural'Last / Right'Length),\n-     Post   => \"*\"'Result'Length = Left * Right'Length,\n+\n+     Post   =>\n+\n+       --  Lower bound of the returned string is 1\n+\n+       \"*\"'Result'First = 1\n+\n+         --  Length of the returned string\n+\n+         and then \"*\"'Result'Length = Left * Right'Length\n+\n+         --  Content of the string is Right concatenated with itself Left times\n+\n+         and then\n+           (for all J in 0 .. Left - 1 =>\n+              \"*\"'Result (J * Right'Length + 1 .. (J + 1) * Right'Length)\n+              = Right),\n      Global => null;\n \n    --  These functions replicate a character or string a specified number of"}]}