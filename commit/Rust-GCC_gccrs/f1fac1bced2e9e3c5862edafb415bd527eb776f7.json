{"sha": "f1fac1bced2e9e3c5862edafb415bd527eb776f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFmYWMxYmNlZDJlOWUzYzU4NjJlZGFmYjQxNWJkNTI3ZWI3NzZmNw==", "commit": {"author": {"name": "Chung-Ju Wu", "email": "jasonwucj@gmail.com", "date": "2014-07-04T07:38:06Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2014-07-04T07:38:06Z"}, "message": "Move memory related implementation to nds32-memory-manipulation.c module.\n\ngcc/\n\t* config/nds32/nds32.c (nds32_expand_load_multiple): Move to ...\n\t(nds32_expand_store_multiple): Move to ...\n\t(nds32_expand_movmemqi): Move to ...\n\t* config/nds32/nds32-memory-manipulation.c: ... here.\n\nCo-Authored-By: Kito Cheng <kito@0xlab.org>\nCo-Authored-By: Monk Chiang <sh.chiang04@gmail.com>\n\nFrom-SVN: r212287", "tree": {"sha": "0736471c037355c209e84bcd589bd6c455bb01aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0736471c037355c209e84bcd589bd6c455bb01aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1fac1bced2e9e3c5862edafb415bd527eb776f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1fac1bced2e9e3c5862edafb415bd527eb776f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1fac1bced2e9e3c5862edafb415bd527eb776f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1fac1bced2e9e3c5862edafb415bd527eb776f7/comments", "author": {"login": "jasonwucj", "id": 5520732, "node_id": "MDQ6VXNlcjU1MjA3MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5520732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jasonwucj", "html_url": "https://github.com/jasonwucj", "followers_url": "https://api.github.com/users/jasonwucj/followers", "following_url": "https://api.github.com/users/jasonwucj/following{/other_user}", "gists_url": "https://api.github.com/users/jasonwucj/gists{/gist_id}", "starred_url": "https://api.github.com/users/jasonwucj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jasonwucj/subscriptions", "organizations_url": "https://api.github.com/users/jasonwucj/orgs", "repos_url": "https://api.github.com/users/jasonwucj/repos", "events_url": "https://api.github.com/users/jasonwucj/events{/privacy}", "received_events_url": "https://api.github.com/users/jasonwucj/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9e9dbc429c50e227857ea7f4302042f09d463163", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9dbc429c50e227857ea7f4302042f09d463163", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e9dbc429c50e227857ea7f4302042f09d463163"}], "stats": {"total": 261, "additions": 154, "deletions": 107}, "files": [{"sha": "e7029bf6a68579bca47cfefc6a0f4e46aabbe362", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1fac1bced2e9e3c5862edafb415bd527eb776f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1fac1bced2e9e3c5862edafb415bd527eb776f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1fac1bced2e9e3c5862edafb415bd527eb776f7", "patch": "@@ -1,3 +1,12 @@\n+2014-07-04  Chung-Ju Wu  <jasonwucj@gmail.com>\n+\t    Kito Cheng  <kito@0xlab.org>\n+\t    Monk Chiang  <sh.chiang04@gmail.com>\n+\n+\t* config/nds32/nds32.c (nds32_expand_load_multiple): Move to ...\n+\t(nds32_expand_store_multiple): Move to ...\n+\t(nds32_expand_movmemqi): Move to ...\n+\t* config/nds32/nds32-memory-manipulation.c: ... here.\n+\n 2014-07-04  Chung-Ju Wu  <jasonwucj@gmail.com>\n \t    Kito Cheng  <kito@0xlab.org>\n \t    Monk Chiang  <sh.chiang04@gmail.com>"}, {"sha": "d4450e1899b58ce9171b5736987219d1b57f8b3d", "filename": "gcc/config/nds32/nds32-memory-manipulation.c", "status": "modified", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1fac1bced2e9e3c5862edafb415bd527eb776f7/gcc%2Fconfig%2Fnds32%2Fnds32-memory-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1fac1bced2e9e3c5862edafb415bd527eb776f7/gcc%2Fconfig%2Fnds32%2Fnds32-memory-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-memory-manipulation.c?ref=f1fac1bced2e9e3c5862edafb415bd527eb776f7", "patch": "@@ -18,3 +18,148 @@\n    You should have received a copy of the GNU General Public License\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n+\n+/* ------------------------------------------------------------------------ */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"stor-layout.h\"\n+#include \"varasm.h\"\n+#include \"calls.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"insn-config.h\"\t/* Required by recog.h.  */\n+#include \"conditions.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\t\t/* For DFA state_t.  */\n+#include \"insn-codes.h\"\t\t/* For CODE_FOR_xxx.  */\n+#include \"reload.h\"\t\t/* For push_reload().  */\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"recog.h\"\n+#include \"diagnostic-core.h\"\n+#include \"df.h\"\n+#include \"tm_p.h\"\n+#include \"tm-constrs.h\"\n+#include \"optabs.h\"\t\t/* For GEN_FCN.  */\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"langhooks.h\"\t\t/* For add_builtin_function().  */\n+#include \"ggc.h\"\n+#include \"builtins.h\"\n+\n+/* ------------------------------------------------------------------------ */\n+\n+/* Functions to expand load_multiple and store_multiple.\n+   They are auxiliary extern functions to help create rtx template.\n+   Check nds32-multiple.md file for the patterns.  */\n+rtx\n+nds32_expand_load_multiple (int base_regno, int count,\n+\t\t\t    rtx base_addr, rtx basemem)\n+{\n+  int par_index;\n+  int offset;\n+  rtx result;\n+  rtx new_addr, mem, reg;\n+\n+  /* Create the pattern that is presented in nds32-multiple.md.  */\n+\n+  result = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n+\n+  for (par_index = 0; par_index < count; par_index++)\n+    {\n+      offset   = par_index * 4;\n+      /* 4-byte for loading data to each register.  */\n+      new_addr = plus_constant (Pmode, base_addr, offset);\n+      mem      = adjust_automodify_address_nv (basemem, SImode,\n+\t\t\t\t\t       new_addr, offset);\n+      reg      = gen_rtx_REG (SImode, base_regno + par_index);\n+\n+      XVECEXP (result, 0, par_index) = gen_rtx_SET (VOIDmode, reg, mem);\n+    }\n+\n+  return result;\n+}\n+\n+rtx\n+nds32_expand_store_multiple (int base_regno, int count,\n+\t\t\t     rtx base_addr, rtx basemem)\n+{\n+  int par_index;\n+  int offset;\n+  rtx result;\n+  rtx new_addr, mem, reg;\n+\n+  /* Create the pattern that is presented in nds32-multiple.md.  */\n+\n+  result = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n+\n+  for (par_index = 0; par_index < count; par_index++)\n+    {\n+      offset   = par_index * 4;\n+      /* 4-byte for storing data to memory.  */\n+      new_addr = plus_constant (Pmode, base_addr, offset);\n+      mem      = adjust_automodify_address_nv (basemem, SImode,\n+\t\t\t\t\t       new_addr, offset);\n+      reg      = gen_rtx_REG (SImode, base_regno + par_index);\n+\n+      XVECEXP (result, 0, par_index) = gen_rtx_SET (VOIDmode, mem, reg);\n+    }\n+\n+  return result;\n+}\n+\n+/* Function to move block memory content by\n+   using load_multiple and store_multiple.\n+   This is auxiliary extern function to help create rtx template.\n+   Check nds32-multiple.md file for the patterns.  */\n+int\n+nds32_expand_movmemqi (rtx dstmem, rtx srcmem, rtx total_bytes, rtx alignment)\n+{\n+  HOST_WIDE_INT in_words, out_words;\n+  rtx dst_base_reg, src_base_reg;\n+  int maximum_bytes;\n+\n+  /* Because reduced-set regsiters has few registers\n+     (r0~r5, r6~10, r15, r28~r31, where 'r15' and 'r28~r31'\n+      cannot be used for register allocation),\n+     using 8 registers (32 bytes) for moving memory block\n+     may easily consume all of them.\n+     It makes register allocation/spilling hard to work.\n+     So we only allow maximum=4 registers (16 bytes) for\n+     moving memory block under reduced-set registers.  */\n+  if (TARGET_REDUCED_REGS)\n+    maximum_bytes = 16;\n+  else\n+    maximum_bytes = 32;\n+\n+  /* 1. Total_bytes is integer for sure.\n+     2. Alignment is integer for sure.\n+     3. Maximum 4 or 8 registers, 4 * 4 = 16 bytes, 8 * 4 = 32 bytes.\n+     4. Requires (n * 4) block size.\n+     5. Requires 4-byte alignment.  */\n+  if (GET_CODE (total_bytes) != CONST_INT\n+      || GET_CODE (alignment) != CONST_INT\n+      || INTVAL (total_bytes) > maximum_bytes\n+      || INTVAL (total_bytes) & 3\n+      || INTVAL (alignment) & 3)\n+    return 0;\n+\n+  dst_base_reg = copy_to_mode_reg (SImode, XEXP (dstmem, 0));\n+  src_base_reg = copy_to_mode_reg (SImode, XEXP (srcmem, 0));\n+\n+  out_words = in_words = INTVAL (total_bytes) / UNITS_PER_WORD;\n+\n+  emit_insn (nds32_expand_load_multiple (0, in_words, src_base_reg, srcmem));\n+  emit_insn (nds32_expand_store_multiple (0, out_words, dst_base_reg, dstmem));\n+\n+  /* Successfully create patterns, return 1.  */\n+  return 1;\n+}\n+\n+/* ------------------------------------------------------------------------ */"}, {"sha": "ad05eb135f20603257d2c6f9282a3879baf50a9b", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1fac1bced2e9e3c5862edafb415bd527eb776f7/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1fac1bced2e9e3c5862edafb415bd527eb776f7/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=f1fac1bced2e9e3c5862edafb415bd527eb776f7", "patch": "@@ -3133,113 +3133,6 @@ nds32_ls_333_p (rtx rt, rtx ra, rtx imm, enum machine_mode mode)\n }\n \n \n-/* Functions to expand load_multiple and store_multiple.\n-   They are auxiliary extern functions to help create rtx template.\n-   Check nds32-multiple.md file for the patterns.  */\n-rtx\n-nds32_expand_load_multiple (int base_regno, int count,\n-\t\t\t    rtx base_addr, rtx basemem)\n-{\n-  int par_index;\n-  int offset;\n-  rtx result;\n-  rtx new_addr, mem, reg;\n-\n-  /* Create the pattern that is presented in nds32-multiple.md.  */\n-\n-  result = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n-\n-  for (par_index = 0; par_index < count; par_index++)\n-    {\n-      offset   = par_index * 4;\n-      /* 4-byte for loading data to each register.  */\n-      new_addr = plus_constant (Pmode, base_addr, offset);\n-      mem      = adjust_automodify_address_nv (basemem, SImode,\n-\t\t\t\t\t       new_addr, offset);\n-      reg      = gen_rtx_REG (SImode, base_regno + par_index);\n-\n-      XVECEXP (result, 0, par_index) = gen_rtx_SET (VOIDmode, reg, mem);\n-    }\n-\n-  return result;\n-}\n-\n-rtx\n-nds32_expand_store_multiple (int base_regno, int count,\n-\t\t\t     rtx base_addr, rtx basemem)\n-{\n-  int par_index;\n-  int offset;\n-  rtx result;\n-  rtx new_addr, mem, reg;\n-\n-  /* Create the pattern that is presented in nds32-multiple.md.  */\n-\n-  result = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n-\n-  for (par_index = 0; par_index < count; par_index++)\n-    {\n-      offset   = par_index * 4;\n-      /* 4-byte for storing data to memory.  */\n-      new_addr = plus_constant (Pmode, base_addr, offset);\n-      mem      = adjust_automodify_address_nv (basemem, SImode,\n-\t\t\t\t\t       new_addr, offset);\n-      reg      = gen_rtx_REG (SImode, base_regno + par_index);\n-\n-      XVECEXP (result, 0, par_index) = gen_rtx_SET (VOIDmode, mem, reg);\n-    }\n-\n-  return result;\n-}\n-\n-/* Function to move block memory content by\n-   using load_multiple and store_multiple.\n-   This is auxiliary extern function to help create rtx template.\n-   Check nds32-multiple.md file for the patterns.  */\n-int\n-nds32_expand_movmemqi (rtx dstmem, rtx srcmem, rtx total_bytes, rtx alignment)\n-{\n-  HOST_WIDE_INT in_words, out_words;\n-  rtx dst_base_reg, src_base_reg;\n-  int maximum_bytes;\n-\n-  /* Because reduced-set regsiters has few registers\n-     (r0~r5, r6~10, r15, r28~r31, where 'r15' and 'r28~r31'\n-      cannot be used for register allocation),\n-     using 8 registers (32 bytes) for moving memory block\n-     may easily consume all of them.\n-     It makes register allocation/spilling hard to work.\n-     So we only allow maximum=4 registers (16 bytes) for\n-     moving memory block under reduced-set registers.  */\n-  if (TARGET_REDUCED_REGS)\n-    maximum_bytes = 16;\n-  else\n-    maximum_bytes = 32;\n-\n-  /* 1. Total_bytes is integer for sure.\n-     2. Alignment is integer for sure.\n-     3. Maximum 4 or 8 registers, 4 * 4 = 16 bytes, 8 * 4 = 32 bytes.\n-     4. Requires (n * 4) block size.\n-     5. Requires 4-byte alignment.  */\n-  if (GET_CODE (total_bytes) != CONST_INT\n-      || GET_CODE (alignment) != CONST_INT\n-      || INTVAL (total_bytes) > maximum_bytes\n-      || INTVAL (total_bytes) & 3\n-      || INTVAL (alignment) & 3)\n-    return 0;\n-\n-  dst_base_reg = copy_to_mode_reg (SImode, XEXP (dstmem, 0));\n-  src_base_reg = copy_to_mode_reg (SImode, XEXP (srcmem, 0));\n-\n-  out_words = in_words = INTVAL (total_bytes) / UNITS_PER_WORD;\n-\n-  emit_insn (nds32_expand_load_multiple (0, in_words, src_base_reg, srcmem));\n-  emit_insn (nds32_expand_store_multiple (0, out_words, dst_base_reg, dstmem));\n-\n-  /* Successfully create patterns, return 1.  */\n-  return 1;\n-}\n-\n /* Computing the Length of an Insn.\n    Modifies the length assigned to instruction INSN.\n    LEN is the initially computed length of the insn.  */"}]}