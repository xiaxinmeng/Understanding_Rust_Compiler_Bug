{"sha": "3bf40d18826c0f6cfad45d8d3a5e604c854b8d34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JmNDBkMTg4MjZjMGY2Y2ZhZDQ1ZDhkM2E1ZTYwNGM4NTRiOGQzNA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-08-26T06:03:24Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-08-26T06:03:24Z"}, "message": "(poplevel): Store into BLOCK iff it is non-null.\n\n(current_block): New function.\n(struct binding_level): New field this_block.\n(poplevel): Use this_block if nonzero, rather than making new BLOCK.\n(insert_block, delete_block): New functions.\n\nFrom-SVN: r1958", "tree": {"sha": "11fff3fda4ebdc61422920349f82cff61b4c6d61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11fff3fda4ebdc61422920349f82cff61b4c6d61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bf40d18826c0f6cfad45d8d3a5e604c854b8d34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bf40d18826c0f6cfad45d8d3a5e604c854b8d34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bf40d18826c0f6cfad45d8d3a5e604c854b8d34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bf40d18826c0f6cfad45d8d3a5e604c854b8d34/comments", "author": null, "committer": null, "parents": [{"sha": "ec08cf0a394af90602849cd0688b3093ead8e6b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec08cf0a394af90602849cd0688b3093ead8e6b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec08cf0a394af90602849cd0688b3093ead8e6b0"}], "stats": {"total": 70, "additions": 65, "deletions": 5}, "files": [{"sha": "9f70713e57ea07fde78b7693af9dd14c09ef8e45", "filename": "gcc/c-decl.c", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bf40d18826c0f6cfad45d8d3a5e604c854b8d34/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bf40d18826c0f6cfad45d8d3a5e604c854b8d34/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=3bf40d18826c0f6cfad45d8d3a5e604c854b8d34", "patch": "@@ -310,6 +310,10 @@ struct binding_level\n        that were entered and exited one level down.  */\n     tree blocks;\n \n+    /* The BLOCK node for this level, if one has been preallocated.\n+       If 0, the BLOCK is allocated (if needed) when the level is popped.  */\n+    tree this_block;\n+\n     /* The binding level which this one is contained in (inherits from).  */\n     struct binding_level *level_chain;\n \n@@ -361,7 +365,7 @@ static struct binding_level *global_binding_level;\n /* Binding level structures are initialized by copying this one.  */\n \n static struct binding_level clear_binding_level\n-  = {NULL, NULL, NULL, NULL, NULL, 0, 0, 0};\n+  = {NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0};\n \n /* Nonzero means unconditionally make a BLOCK for the next level pushed.  */\n \n@@ -868,10 +872,18 @@ poplevel (keep, reverse, functionbody)\n      or if this level is a function body,\n      create a BLOCK to record them for the life of this function.  */\n \n-  if (keep || functionbody\n-      || (current_binding_level->keep_if_subblocks && subblocks != 0))\n-    block = build_block (keep ? decls : NULL_TREE, keep ? tags : NULL_TREE,\n-\t\t\t subblocks, NULL_TREE, NULL_TREE);\n+  block = 0;\n+  if (current_binding_level->this_block != 0)\n+    block = current_binding_level->this_block;\n+  else if (keep || functionbody\n+\t   || (current_binding_level->keep_if_subblocks && subblocks != 0))\n+    block = make_node (BLOCK);\n+  if (block != 0)\n+    {\n+      BLOCK_VARS (block) = decls;\n+      BLOCK_TYPE_TAGS (block) = tags;\n+      BLOCK_SUBBLOCKS (block) = subblocks;\n+    }\n \n   /* In each subblock, record that this is its superior.  */\n \n@@ -993,6 +1005,54 @@ poplevel (keep, reverse, functionbody)\n     TREE_USED (block) = 1;\n   return block;\n }\n+\n+/* Delete the node BLOCK from the current binding level.\n+   This is used for the block inside a stmt expr ({...})\n+   so that the block can be reinserted where appropriate.  */\n+\n+void\n+delete_block (block)\n+     tree block;\n+{\n+  tree t;\n+  if (current_binding_level->blocks == block)\n+    current_binding_level->blocks = TREE_CHAIN (block);\n+  for (t = current_binding_level->blocks; t;)\n+    {\n+      if (TREE_CHAIN (t) == block)\n+\tTREE_CHAIN (t) = TREE_CHAIN (block);\n+      else\n+\tt = TREE_CHAIN (t);\n+    }\n+  TREE_CHAIN (block) = NULL;\n+  /* Clear TREE_USED which is always set by poplevel.\n+     The flag is set again if insert_block is called.  */\n+  TREE_USED (block) = 0;\n+}\n+\n+/* Insert BLOCK at the end of the list of subblocks of the\n+   current binding level.  This is used when a BIND_EXPR is expanded,\n+   to handle the BLOCK node inside teh BIND_EXPR.  */\n+\n+void\n+insert_block (block)\n+     tree block;\n+{\n+  TREE_USED (block) = 1;\n+  current_binding_level->blocks\n+    = chainon (current_binding_level->blocks, block);\n+}\n+\n+/* Return the BLOCK node for the innermost scope\n+   (the one we are currently in).  */\n+\n+tree\n+current_block ()\n+{\n+  if (current_binding_level->this_block == 0)\n+    current_binding_level->this_block = make_node (BLOCK);\n+  return current_binding_level->this_block;\n+}\n \f\n void\n push_label_level ()"}]}