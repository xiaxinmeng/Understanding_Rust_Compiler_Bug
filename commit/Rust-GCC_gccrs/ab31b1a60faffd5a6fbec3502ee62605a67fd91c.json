{"sha": "ab31b1a60faffd5a6fbec3502ee62605a67fd91c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIzMWIxYTYwZmFmZmQ1YTZmYmVjMzUwMmVlNjI2MDVhNjdmZDkxYw==", "commit": {"author": {"name": "Pat Rogers", "email": "rogers@adacore.com", "date": "2006-10-31T18:14:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T18:14:09Z"}, "message": "a-rttiev.ads, [...]: This is a significant redesign primarily for the sake of automatic timer task...\n\n2006-10-31  Pat Rogers  <rogers@adacore.com>\n\n\t* a-rttiev.ads, a-rttiev.adb: \n\tThis is a significant redesign primarily for the sake of automatic\n\ttimer task termination but also to fix a design flaw.\n\tTherefore we are now using an RTS lock, instead of a protected\n\tobject, to provide mutual exclusion to the queue of pending events\n\tand the type Timing_Event is no longer a protected type.\n\nFrom-SVN: r118327", "tree": {"sha": "8d996a610392ed685d80543ddaa0be48ff5f097a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d996a610392ed685d80543ddaa0be48ff5f097a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab31b1a60faffd5a6fbec3502ee62605a67fd91c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab31b1a60faffd5a6fbec3502ee62605a67fd91c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab31b1a60faffd5a6fbec3502ee62605a67fd91c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab31b1a60faffd5a6fbec3502ee62605a67fd91c/comments", "author": {"login": "pat-rogers", "id": 14908705, "node_id": "MDQ6VXNlcjE0OTA4NzA1", "avatar_url": "https://avatars.githubusercontent.com/u/14908705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pat-rogers", "html_url": "https://github.com/pat-rogers", "followers_url": "https://api.github.com/users/pat-rogers/followers", "following_url": "https://api.github.com/users/pat-rogers/following{/other_user}", "gists_url": "https://api.github.com/users/pat-rogers/gists{/gist_id}", "starred_url": "https://api.github.com/users/pat-rogers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pat-rogers/subscriptions", "organizations_url": "https://api.github.com/users/pat-rogers/orgs", "repos_url": "https://api.github.com/users/pat-rogers/repos", "events_url": "https://api.github.com/users/pat-rogers/events{/privacy}", "received_events_url": "https://api.github.com/users/pat-rogers/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7440d86c98ffaef74b1f49beed9f64694cb39e7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7440d86c98ffaef74b1f49beed9f64694cb39e7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7440d86c98ffaef74b1f49beed9f64694cb39e7a"}], "stats": {"total": 368, "additions": 174, "deletions": 194}, "files": [{"sha": "f8cd699497a4af6100d633d869ab62910905a563", "filename": "gcc/ada/a-rttiev.adb", "status": "modified", "additions": 173, "deletions": 148, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab31b1a60faffd5a6fbec3502ee62605a67fd91c/gcc%2Fada%2Fa-rttiev.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab31b1a60faffd5a6fbec3502ee62605a67fd91c/gcc%2Fada%2Fa-rttiev.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rttiev.adb?ref=ab31b1a60faffd5a6fbec3502ee62605a67fd91c", "patch": "@@ -31,48 +31,65 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with System.Task_Primitives.Operations;\n with System.Tasking.Utilities;\n---  for Make_Independent\n+with System.Soft_Links;\n+--  used for Abort_Defer/Undefer\n \n with Ada.Containers.Doubly_Linked_Lists;\n pragma Elaborate_All (Ada.Containers.Doubly_Linked_Lists);\n \n+---------------------------------\n+-- Ada.Real_Time.Timing_Events --\n+---------------------------------\n+\n package body Ada.Real_Time.Timing_Events is\n \n+   use System.Task_Primitives.Operations;\n+   --  for Write_Lock and Unlock\n+\n+   package SSL renames System.Soft_Links;\n+\n    type Any_Timing_Event is access all Timing_Event'Class;\n    --  We must also handle user-defined types derived from Timing_Event\n \n    ------------\n    -- Events --\n    ------------\n \n-   package Events is\n-      new Ada.Containers.Doubly_Linked_Lists (Any_Timing_Event);\n+   package Events is new Ada.Containers.Doubly_Linked_Lists (Any_Timing_Event);\n+   --  Provides the type for the container holding pointers to events\n \n-   -----------------\n-   -- Event_Queue --\n-   -----------------\n+   All_Events : Events.List;\n+   --  The queue of pending events, ordered by increasing timeout value, that\n+   --  have been \"set\" by the user via Set_Handler.\n \n-   protected Event_Queue is\n-      pragma Priority (System.Priority'Last);\n+   Event_Queue_Lock : aliased System.Task_Primitives.RTS_Lock;\n+   --  Used for mutually exclusive access to All_Events\n \n-      procedure Insert (This : Any_Timing_Event);\n-      --  Inserts This into the queue in ascending order by Timeout\n+   procedure Process_Queued_Events;\n+   --  Examine the queue of pending events for any that have timed-out. For\n+   --  those that have timed-out, remove them from the queue and invoke their\n+   --  handler (unless the user has cancelled the event by setting the handler\n+   --  pointer to null). Mutually exclusive access is held via Event_Queue_Lock\n+   --  during part of the processing.\n \n-      procedure Process_Events;\n-      --  Iterates over the list of events and calls the handlers for any of\n-      --  those that have timed out. Deletes those that have timed out.\n+   procedure Insert_Into_Queue (This : Any_Timing_Event);\n+   --  Insert the specified event pointer into the queue of pending events\n+   --  with mutually exclusive access via Event_Queue_Lock.\n \n-    private\n-      All_Events : Events.List;\n-   end Event_Queue;\n+   procedure Remove_From_Queue (This : Any_Timing_Event);\n+   --  Remove the specified event pointer from the queue of pending events\n+   --  with mutually exclusive access via Event_Queue_Lock.\n+   --  This procedure is used by the client-side routines (Set_Handler, etc.).\n \n    -----------\n    -- Timer --\n    -----------\n \n    task Timer is\n       pragma Priority (System.Priority'Last);\n+      entry Start;\n    end Timer;\n \n    task body Timer is\n@@ -81,104 +98,158 @@ package body Ada.Real_Time.Timing_Events is\n       --  selected is arbitrary and could be changed to suit the application\n       --  requirements. Obviously a shorter period would give better resolution\n       --  at the cost of more overhead.\n-\n    begin\n       System.Tasking.Utilities.Make_Independent;\n+\n+      --  We await the call to Start to ensure that Event_Queue_Lock has been\n+      --  initialized by the package executable part prior to accessing it in\n+      --  the loop. The task is activated before the first statement of the\n+      --  executable part so it would otherwise be possible for the task to\n+      --  call EnterCriticalSection in Process_Queued_Events before the\n+      --  initialization.\n+\n+      --  We don't simply put the initialization here, prior to the loop,\n+      --  because other application tasks could call the visible routines that\n+      --  also call Enter/LeaveCriticalSection prior to this task doing the\n+      --  initialization.\n+\n+      accept Start;\n+\n       loop\n-         Event_Queue.Process_Events;\n+         Process_Queued_Events;\n          delay until Clock + Period;\n       end loop;\n    end Timer;\n \n-   ------------\n-   -- Sooner --\n-   ------------\n+   ---------------------------\n+   -- Process_Queued_Events --\n+   ---------------------------\n \n-   function Sooner (Left, Right : Any_Timing_Event) return Boolean;\n-   --  Used by the Event_Queue insertion routine to keep the events in\n-   --  ascending order by timeout value.\n+   procedure Process_Queued_Events is\n+      Next_Event : Any_Timing_Event;\n \n-   -----------------\n-   -- Event_Queue --\n-   -----------------\n+   begin\n+      loop\n+         SSL.Abort_Defer.all;\n \n-   protected body Event_Queue is\n+         Write_Lock (Event_Queue_Lock'Access);\n \n-      procedure Insert (This : Any_Timing_Event) is\n-         package By_Timeout is new Events.Generic_Sorting (Sooner);\n-         --  Used to keep the events in ascending order by timeout value\n+         if All_Events.Is_Empty then\n+            Unlock (Event_Queue_Lock'Access);\n+            SSL.Abort_Undefer.all;\n+            return;\n+         else\n+            Next_Event := All_Events.First_Element;\n+         end if;\n \n-      begin\n-         All_Events.Append (This);\n+         if Next_Event.Timeout > Clock then\n \n-         --  A critical property of the implementation of this package is that\n-         --  all occurrences are in ascending order by Timeout. Thus the first\n-         --  event in the queue always has the \"next\" value for the Timer task\n-         --  to use in its delay statement.\n+            --  We found one that has not yet timed-out. The queue is in\n+            --  ascending order by Timeout so there is no need to continue\n+            --  processing (and indeed we must not continue since we always\n+            --  delete the first element).\n \n-         By_Timeout.Sort (All_Events);\n-      end Insert;\n+            Unlock (Event_Queue_Lock'Access);\n+            SSL.Abort_Undefer.all;\n+            return;\n+         end if;\n \n-      procedure Process_Events is\n-         Next_Event : Any_Timing_Event;\n-      begin\n-         while not All_Events.Is_Empty loop\n-            Next_Event := All_Events.First_Element;\n+         --  We have an event that has timed out so we will process it. It\n+         --  must be the first in the queue so no search is needed.\n+\n+         All_Events.Delete_First;\n \n-            --  Clients can cancel a timeout (setting the handler to null) but\n-            --  cannot otherwise change the timeout/handler tuple until the\n-            --  call to Reset below.\n+         --  A fundamental issue is that the invocation of the event's handler\n+         --  might call Set_Handler on itself to re-insert itself back into the\n+         --  queue of future events. Thus we cannot hold the lock on the queue\n+         --  while invoking the event's handler.\n \n-            if Next_Event.Control.Current_Timeout > Clock then\n+         Unlock (Event_Queue_Lock'Access);\n \n-               --  We found one that has not yet timed-out. The queue is in\n-               --  ascending order by Timeout so there is no need to continue\n-               --  processing (and indeed we must not continue since we always\n-               --  delete the first element).\n+         SSL.Abort_Undefer.all;\n \n-               return;\n+         --  There is no race condition with the user changing the handler\n+         --  pointer while we are processing because we are executing at the\n+         --  highest possible application task priority and are not doing\n+         --  anything to block prior to invoking their handler.\n+\n+         declare\n+            Handler : constant Timing_Event_Handler := Next_Event.Handler;\n+         begin\n+            --  The first act is to clear the event, per D.15 (13/2). Besides,\n+            --  we cannot clear the handler pointer *after* invoking the\n+            --  handler because the handler may have re-inserted the event via\n+            --  Set_Event. Thus we take a copy and then clear the component.\n+\n+            Next_Event.Handler := null;\n+\n+            if Handler /= null then\n+               Handler (Timing_Event (Next_Event.all));\n             end if;\n+         exception\n+            when others =>\n+               null;\n+         end;\n+      end loop;\n+   end Process_Queued_Events;\n+\n+   -----------------------\n+   -- Insert_Into_Queue --\n+   -----------------------\n+\n+   procedure Insert_Into_Queue (This : Any_Timing_Event) is\n+\n+      function Sooner (Left, Right : Any_Timing_Event) return Boolean;\n+      --  Compares events in terms of timeout values\n \n-            declare\n-               Response : Timing_Event_Handler;\n+      package By_Timeout is new Events.Generic_Sorting (Sooner);\n+      --  Used to keep the events in ascending order by timeout value\n \n-            begin\n-               --  We take a local snapshot of the handler to avoid a race\n-               --  condition because we evaluate the handler value in the\n-               --  if-statement and again in the call and the client might have\n-               --  set it to null between those two evaluations.\n+      function Sooner (Left, Right : Any_Timing_Event) return Boolean is\n+      begin\n+         return Left.Timeout < Right.Timeout;\n+      end Sooner;\n+\n+   begin\n+      SSL.Abort_Defer.all;\n+\n+      Write_Lock (Event_Queue_Lock'Access);\n \n-               Response := Next_Event.Control.Current_Handler;\n+      All_Events.Append (This);\n \n-               if Response /= null then\n+      --  A critical property of the implementation of this package is that\n+      --  all occurrences are in ascending order by Timeout. Thus the first\n+      --  event in the queue always has the \"next\" value for the Timer task\n+      --  to use in its delay statement.\n \n-                  --  D.15 (13/2) says we only invoke the handler if it is\n-                  --  set when the timeout expires.\n+      By_Timeout.Sort (All_Events);\n \n-                  Response (Timing_Event (Next_Event.all));\n-               end if;\n+      Unlock (Event_Queue_Lock'Access);\n \n-            exception\n-               when others =>\n-                  null;  --  per D.15 (21/2)\n-            end;\n+      SSL.Abort_Undefer.all;\n+   end Insert_Into_Queue;\n \n-            Next_Event.Control.Reset;\n+   -----------------------\n+   -- Remove_From_Queue --\n+   -----------------------\n \n-            --  Clients can now change the timeout/handler pair for this event\n+   procedure Remove_From_Queue (This : Any_Timing_Event) is\n+      use Events;\n+      Location : Cursor;\n+   begin\n+      SSL.Abort_Defer.all;\n+\n+      Write_Lock (Event_Queue_Lock'Access);\n \n-            --  And now we can delete the event from the queue. Any item we\n-            --  delete would be the first in the queue because we exit the loop\n-            --  when we first find one that is not yet timed-out. This fact\n-            --  allows us to use these \"First oriented\" list processing\n-            --  routines instead of the cursor oriented versions because we can\n-            --  avoid handling the way deletion affects cursors.\n+      Location := All_Events.Find (This);\n+      if Location /= No_Element then\n+         All_Events.Delete (Location);\n+      end if;\n \n-            All_Events.Delete_First;\n-         end loop;\n-      end Process_Events;\n+      Unlock (Event_Queue_Lock'Access);\n \n-   end Event_Queue;\n+      SSL.Abort_Undefer.all;\n+   end Remove_From_Queue;\n \n    -----------------\n    -- Set_Handler --\n@@ -190,18 +261,18 @@ package body Ada.Real_Time.Timing_Events is\n       Handler : Timing_Event_Handler)\n    is\n    begin\n-      Event.Control.Cancel;\n-\n+      Remove_From_Queue (Event'Unchecked_Access);\n+      Event.Handler := null;\n       if At_Time <= Clock then\n          if Handler /= null then\n             Handler (Event);\n          end if;\n          return;\n       end if;\n-\n       if Handler /= null then\n-         Event.Control.Set (At_Time, Handler);\n-         Event_Queue.Insert (Event'Unchecked_Access);\n+         Event.Timeout := At_Time;\n+         Event.Handler := Handler;\n+         Insert_Into_Queue (Event'Unchecked_Access);\n       end if;\n    end Set_Handler;\n \n@@ -215,63 +286,21 @@ package body Ada.Real_Time.Timing_Events is\n       Handler : Timing_Event_Handler)\n    is\n    begin\n-      Event.Control.Cancel;\n-\n+      Remove_From_Queue (Event'Unchecked_Access);\n+      Event.Handler := null;\n       if In_Time <= Time_Span_Zero then\n          if Handler /= null then\n             Handler (Event);\n          end if;\n          return;\n       end if;\n-\n       if Handler /= null then\n-         Event.Control.Set (Clock + In_Time, Handler);\n-         Event_Queue.Insert (Event'Unchecked_Access);\n+         Event.Timeout := Clock + In_Time;\n+         Event.Handler := Handler;\n+         Insert_Into_Queue (Event'Unchecked_Access);\n       end if;\n    end Set_Handler;\n \n-   -----------------\n-   -- Event_State --\n-   -----------------\n-\n-   protected body Event_State is\n-\n-      entry Set\n-        (Timeout : Time;\n-         Handler : Timing_Event_Handler)\n-      when\n-         Available\n-      is\n-      begin\n-         Event_State.Timeout := Set.Timeout;\n-         Event_State.Handler := Set.Handler;\n-         Available := False;\n-      end Set;\n-\n-      procedure Reset is\n-      begin\n-         Cancel;\n-         Available := True;\n-      end Reset;\n-\n-      procedure Cancel is\n-      begin\n-         Handler := null;\n-         Timeout := Time_First;\n-      end Cancel;\n-\n-      function Current_Timeout return Time is\n-      begin\n-         return Timeout;\n-      end Current_Timeout;\n-\n-      function Current_Handler return Timing_Event_Handler is\n-      begin\n-         return Handler;\n-      end Current_Handler;\n-\n-   end Event_State;\n-\n    ---------------------\n    -- Current_Handler --\n    ---------------------\n@@ -280,7 +309,7 @@ package body Ada.Real_Time.Timing_Events is\n      (Event : Timing_Event) return Timing_Event_Handler\n    is\n    begin\n-      return Event.Control.Current_Handler;\n+      return Event.Handler;\n    end Current_Handler;\n \n    --------------------\n@@ -292,8 +321,9 @@ package body Ada.Real_Time.Timing_Events is\n       Cancelled : out Boolean)\n    is\n    begin\n-      Cancelled := Event.Control.Current_Handler /= null;\n-      Event.Control.Cancel;\n+      Remove_From_Queue (Event'Unchecked_Access);\n+      Cancelled := Event.Handler /= null;\n+      Event.Handler := null;\n    end Cancel_Handler;\n \n    -------------------\n@@ -302,18 +332,9 @@ package body Ada.Real_Time.Timing_Events is\n \n    function Time_Of_Event (Event : Timing_Event) return Time is\n    begin\n-      return Event.Control.Current_Timeout;\n+      return Event.Timeout;\n    end Time_Of_Event;\n \n-   ------------\n-   -- Sooner --\n-   ------------\n-\n-   function Sooner (Left, Right : Any_Timing_Event) return Boolean is\n-   begin\n-      return Left.Control.Current_Timeout < Right.Control.Current_Timeout;\n-   end Sooner;\n-\n    --------------\n    -- Finalize --\n    --------------\n@@ -322,7 +343,11 @@ package body Ada.Real_Time.Timing_Events is\n    begin\n       --  D.15 (19/2) says finalization clears the event\n \n-      This.Control.Cancel;\n+      This.Handler := null;\n+      Remove_From_Queue (This'Unchecked_Access);\n    end Finalize;\n \n+begin\n+   Initialize_Lock (Event_Queue_Lock'Access, Level => PO_Level);\n+   Timer.Start;\n end Ada.Real_Time.Timing_Events;"}, {"sha": "19274bcebf2d075d13855aa4f48cd22ba3d54590", "filename": "gcc/ada/a-rttiev.ads", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab31b1a60faffd5a6fbec3502ee62605a67fd91c/gcc%2Fada%2Fa-rttiev.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab31b1a60faffd5a6fbec3502ee62605a67fd91c/gcc%2Fada%2Fa-rttiev.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-rttiev.ads?ref=ab31b1a60faffd5a6fbec3502ee62605a67fd91c", "patch": "@@ -65,42 +65,7 @@ package Ada.Real_Time.Timing_Events is\n \n private\n \n-   protected type Event_State is\n-\n-      --  D.15 (22/2) requires atomicity with respect to the operations\n-      --  provided by the package and the timing events they manipulate. On\n-      --  real-time operating systems suitable for implementing this package, a\n-      --  different implementation strategy would be employed to meet that\n-      --  requirement.\n-\n-      entry Set (Timeout : Time;  Handler : Timing_Event_Handler);\n-      --  Changes the timeout and handler values for procedure Set_Handler. Can\n-      --  only execute when the event is 'available', to prevent a race\n-      --  condition between the caller of Set_Handler and the internal Timer\n-      --  task that processes the events. In particular, D.15 (22/2) requires\n-      --  that there be no possibility of a new handler executing in response\n-      --  to an old timeout.\n-\n-      procedure Reset;\n-      --  First resets the timeout to Time_First and the handler to\n-      --  null. Indicates that Set (for Set_Handler) can now change the timeout\n-      --  and/or handler.  Called only by the interal Timer task.\n-\n-      procedure Cancel;\n-      --  Resets the timeout to Time_First and the handler to\n-      --  null. Called by procedure Cancel_Handler and by procedure Reset.\n-\n-      function Current_Timeout return Time;\n-      --  Returns the currently set timeout. The value Time_First is returned\n-      --  if the Timing_Event is in the \"cleared\" state. Called by function\n-      --  Time_of_Event.\n-\n-      function Current_Handler return Timing_Event_Handler;\n-      --  Returns the currently set handler. The value null is returned if the\n-      --  Timing_Event is in the \"cleared\" state. Called by function\n-      --  Curent_Handler.\n-\n-   private\n+   type Timing_Event is new Ada.Finalization.Limited_Controlled with record\n       Timeout : Time := Time_First;\n       --  The time at which the user's handler should be invoked when the\n       --  event is \"set\" (i.e., when Handler is not null).\n@@ -109,16 +74,6 @@ private\n       --  An access value designating the protected procedure to be invoked\n       --  at the Timeout time in the future.  When this value is null the event\n       --  is said to be \"cleared\" and no timeout is processed.\n-\n-      Available : Boolean := True;\n-      --  A flag controlling when users can change the Timeout and Handler\n-      --  tuple. In particular the entry Set, called by procedure Set_Handler,\n-      --  is controlled by this flag.\n-\n-   end Event_State;\n-\n-   type Timing_Event is new Ada.Finalization.Limited_Controlled with record\n-      Control : Event_State;\n    end record;\n \n    overriding procedure Finalize (This : in out Timing_Event);"}]}