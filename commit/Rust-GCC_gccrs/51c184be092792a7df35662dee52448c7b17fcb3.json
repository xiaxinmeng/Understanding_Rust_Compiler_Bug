{"sha": "51c184be092792a7df35662dee52448c7b17fcb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFjMTg0YmUwOTI3OTJhN2RmMzU2NjJkZWU1MjQ0OGM3YjE3ZmNiMw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-03-23T23:33:53Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-03-23T23:33:53Z"}, "message": "30th Cygnus<->FSF merge.\n\nFrom-SVN: r6859", "tree": {"sha": "50fb55018ee5664cebe5d87e245abecdf1af7630", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50fb55018ee5664cebe5d87e245abecdf1af7630"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51c184be092792a7df35662dee52448c7b17fcb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51c184be092792a7df35662dee52448c7b17fcb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51c184be092792a7df35662dee52448c7b17fcb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51c184be092792a7df35662dee52448c7b17fcb3/comments", "author": null, "committer": null, "parents": [{"sha": "d7a58f30d1ba7672aeee5a6c68c8dd56690601e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7a58f30d1ba7672aeee5a6c68c8dd56690601e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7a58f30d1ba7672aeee5a6c68c8dd56690601e7"}], "stats": {"total": 2797, "additions": 1708, "deletions": 1089}, "files": [{"sha": "5b2a422836d14cc56c315e1c91c95498be55bcf5", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -44,10 +44,9 @@ X_CPPFLAGS =\n T_CPPFLAGS =\n \n CC = cc\n-# CYGNUS LOCAL: we use byacc instead of bison, DO NOT SEND TO RMS\n-BISON = `if [ -f ../../byacc/byacc ] ; then echo ../../byacc/byacc ;  else echo byacc ; fi`\n+BISON = bison\n BISONFLAGS =\n-LEX = `if [ -f ../../flex/flex ] ; then echo ../../flex/flex ;  else echo flex ; fi`\n+LEX = flex\n LEXFLAGS=\n AR = ar\n OLDAR_FLAGS = qc\n@@ -204,7 +203,7 @@ parse.o : $(srcdir)/parse.c $(CONFIG_H) $(CXX_TREE_H) ../flags.h lex.h\n   `echo $(srcdir)/parse.c | sed 's,^\\./,,'`\n \n $(srcdir)/parse.c $(srcdir)/parse.h : $(srcdir)/parse.y\n-\t@echo expect 28 shift/reduce conflicts, 14 reduce/reduce conflicts.\n+\t@echo expect 24 reduce/reduce conflicts.\n \tcd $(srcdir); $(BISON) $(BISONFLAGS) -d -o parse.c parse.y\n \tcd $(srcdir); grep '^#define[ \t]*YYEMPTY' parse.c >>parse.h\n "}, {"sha": "663b727aa95a926d7911fbccd609308f28bd93d1", "filename": "gcc/cp/call.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -39,7 +39,7 @@ extern int inhibit_warnings;\n extern int flag_assume_nonnull_objects;\n extern tree ctor_label, dtor_label;\n \n-/* From cp-typeck.c:  */\n+/* From typeck.c:  */\n extern tree unary_complex_lvalue ();\n \n /* Compute the ease with which a conversion can be performed\n@@ -2821,6 +2821,8 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  cp_error (\"call to destructor for non-type `%D'\", name);\n \t  return void_zero_node;\n \t}\n+      if (basetype != TREE_TYPE(instance))\n+\tbasetype = TREE_TYPE(instance);\n       if (! TYPE_HAS_DESTRUCTOR (basetype))\n \treturn void_zero_node;\n       instance = default_conversion (instance);\n@@ -3096,6 +3098,11 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  TREE_VALUE (parm) = resolve_offset_ref (TREE_VALUE (parm));\n \t  t = TREE_TYPE (TREE_VALUE (parm));\n \t}\n+      if (TREE_CODE (TREE_VALUE (parm)) == OFFSET_REF\n+\t  && TREE_CODE (t) == METHOD_TYPE)\n+\t{\n+\t  TREE_VALUE (parm) = build_unary_op (ADDR_EXPR, TREE_VALUE (parm), 0);\n+\t}\n       if (TREE_CODE (t) == ARRAY_TYPE)\n \t{\n \t  /* Perform the conversion from ARRAY_TYPE to POINTER_TYPE in place."}, {"sha": "0c5cc264408077c5e037418973553a1a1a46ac96", "filename": "gcc/cp/class.c", "status": "modified", "additions": 46, "deletions": 24, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -83,7 +83,7 @@ tree the_null_vtable_entry;\n \n /* Way of stacking language names.  */\n tree *current_lang_base, *current_lang_stack;\n-static int current_lang_stacksize;\n+int current_lang_stacksize;\n \n /* Names of languages we recognize.  */\n tree lang_name_c, lang_name_cplusplus;\n@@ -94,7 +94,7 @@ tree current_lang_name;\n    via this node.  */\n static tree base_layout_decl;\n \n-/* Variables shared between cp-class.c and cp-call.c.  */\n+/* Variables shared between class.c and call.c.  */\n \n int n_vtables = 0;\n int n_vtable_entries = 0;\n@@ -471,7 +471,8 @@ build_vfn_ref (ptr_to_instptr, instance, idx)\n \tvtbl = build_indirect_ref (build_vfield_ref (instance, basetype),\n \t\t\t\t   NULL_PTR);\n     }\n-  assemble_external (vtbl);\n+  if (!flag_vtable_hack)\n+    assemble_external (vtbl);\n   aref = build_array_ref (vtbl, idx);\n \n   /* Save the intermediate result in a SAVE_EXPR so we don't have to\n@@ -777,7 +778,8 @@ prepare_fresh_vtable (binfo, base_binfo, for_type)\n \n /* Access the virtual function table entry that logically\n    contains BASE_FNDECL.  VIRTUALS is the virtual function table's\n-   initializer.  */\n+   initializer.  We can run off the end, when dealing with virtual\n+   destructors in MI situations, return NULL_TREE in that case.  */\n static tree\n get_vtable_entry (virtuals, base_fndecl)\n      tree virtuals, base_fndecl;\n@@ -794,7 +796,7 @@ get_vtable_entry (virtuals, base_fndecl)\n   n_vtable_searches += i;\n #endif\n \n-  while (i > 0)\n+  while (i > 0 && virtuals)\n     {\n       virtuals = TREE_CHAIN (virtuals);\n       i -= 1;\n@@ -1276,13 +1278,15 @@ modify_vtable_entries (t, fndecl, base_fndecl, pfn)\n \t    prepare_fresh_vtable (binfo, base, t);\n \t}\n \n-      saved_pfn = TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (get_vtable_entry (BINFO_VIRTUALS (binfo), base_fndecl))), 0);\n+      saved_pfn = get_vtable_entry (BINFO_VIRTUALS (binfo), base_fndecl);\n+      if (saved_pfn)\n+\tsaved_pfn = TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (saved_pfn)), 0);\n #ifdef NOTQUITE\n       cp_warning (\"in %D\", DECL_NAME (BINFO_VTABLE (binfo)));\n #endif\n       /* The this_offset can be wrong, if we try and modify an entry\n \t that had been modified once before. */\n-      if (! SAME_FN (saved_pfn, fndecl))\n+      if (saved_pfn && ! SAME_FN (saved_pfn, fndecl))\n         {\n \t  modify_vtable_entry (get_vtable_entry (BINFO_VIRTUALS (binfo), base_fndecl),\n \t\t\t       build_vtable_entry (this_offset, pfn),\n@@ -1738,12 +1742,15 @@ alter_access (t, fdecl, access)\n   return 0;\n }\n \n-static tree\n+/* Return the offset to the main vtable for a given base BINFO.  */\n+tree\n get_vfield_offset (binfo)\n      tree binfo;\n {\n   return size_binop (PLUS_EXPR,\n-\t\t     DECL_FIELD_BITPOS (CLASSTYPE_VFIELD (BINFO_TYPE (binfo))),\n+\t\t     size_binop (FLOOR_DIV_EXPR,\n+\t\t\t\t DECL_FIELD_BITPOS (CLASSTYPE_VFIELD (BINFO_TYPE (binfo))),\n+\t\t\t\t size_int (BITS_PER_UNIT)),\n \t\t     BINFO_OFFSET (binfo));\n }\n \n@@ -2148,6 +2155,22 @@ finish_base_struct (t, b, t_binfo)\n \t  b->cant_synth_copy_ctor = 1;\n \t}\n     }\n+  {\n+    tree v = get_vbase_types (t_binfo);\n+\n+    for (; v; v = TREE_CHAIN (v))\n+      {\n+\ttree basetype = BINFO_TYPE (v);\n+\tif (get_base_distance (basetype, t_binfo, 0, (tree*)0) == -2)\n+\t  {\n+\t    if (extra_warnings)\n+\t      cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n+\t\t\t  basetype, t);\n+\t    b->cant_synth_asn_ref = 1;\n+\t    b->cant_synth_copy_ctor = 1;\n+\t  }\n+      }\n+  }    \n \n   {\n     tree vfields;\n@@ -2726,7 +2749,8 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   enum tree_code code = TREE_CODE (t);\n   register tree x, last_x, method_vec;\n   int needs_virtual_dtor;\n-  tree name = TYPE_NAME (t), fields, fn_fields, tail;\n+  tree name = TYPE_NAME (t), fields, fn_fields, *tail;\n+  tree *tail_user_methods = &CLASSTYPE_METHODS (t);\n   enum access_type access;\n   int all_virtual;\n   int has_virtual;\n@@ -2902,8 +2926,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   CLASSTYPE_VFIELDS (t) = vfields;\n   CLASSTYPE_VFIELD (t) = vfield;\n \n-  fn_fields = NULL_TREE;\n-  tail = NULL_TREE;\n+  tail = &fn_fields;\n   if (last_x && list_of_fieldlists)\n     TREE_CHAIN (last_x) = TREE_VALUE (list_of_fieldlists);\n \n@@ -2961,11 +2984,11 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \n \t      if (last_x)\n \t\tTREE_CHAIN (last_x) = TREE_CHAIN (x);\n-\t      if (! fn_fields)\n-\t\tfn_fields = x;\n-\t      else\n-\t\tTREE_CHAIN (tail) = x;\n-\t      tail = x;\n+\t      /* Link x onto end of fn_fields and CLASSTYPE_METHODS. */\n+\t      *tail = x;\n+\t      tail = &TREE_CHAIN (x);\n+\t      *tail_user_methods = x;\n+\t      tail_user_methods = &DECL_NEXT_METHOD (x);\n \n #if 0\n \t      /* ??? What if we have duplicate declarations\n@@ -3284,8 +3307,6 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t}\n     }\n \n-  if (tail) TREE_CHAIN (tail) = NULL_TREE;\n-\n   /* If this type has any constant members which did not come\n      with their own initialization, mark that fact here.  It is\n      not an error here, since such types can be saved either by their\n@@ -3306,11 +3327,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \tTYPE_NEEDS_DESTRUCTOR (t) = 0;\n       else\n \t{\n-\t  if (! fn_fields)\n-\t    fn_fields = dtor;\n-\t  else\n-\t    TREE_CHAIN (tail) = dtor;\n-\t  tail = dtor;\n+\t  /* Link dtor onto end of fn_fields. */\n+\t  *tail = dtor;\n+\t  tail = &TREE_CHAIN (dtor);\n \n \t  if (DECL_VINDEX (dtor) == NULL_TREE\n \t      && ! CLASSTYPE_DECLARED_EXCEPTION (t)\n@@ -3325,6 +3344,9 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t}\n     }\n \n+  *tail = NULL_TREE;\n+  *tail_user_methods = NULL_TREE;\n+\n   TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_HAS_DESTRUCTOR (t);\n \n   /* Synthesize any needed methods.  Note that methods will be synthesized"}, {"sha": "7e138243c011732a779d734c787cc399ff461d5f", "filename": "gcc/cp/class.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fclass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fclass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.h?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -149,7 +149,7 @@ struct candidate\n };\n int rank_for_overload ();\n \n-/* Variables shared between cp-class.c and cp-call.c.  */\n+/* Variables shared between class.c and call.c.  */\n \n extern int n_vtables;\n extern int n_vtable_entries;"}, {"sha": "e4db0dc8c9721be5502fa51ddf8c32374cc12638", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -259,6 +259,11 @@ extern int flag_signed_bitfields;\n \n extern int write_virtuals;\n \n+/* True if we want output of vtables to be controlled by whether\n+   we seen the class's first non-inline virtual function.\n+   0 is old behavior; 1 is new behavior. */\n+extern flag_vtable_hack;\n+\n /* INTERFACE_ONLY nonzero means that we are in an \"interface\"\n    section of the compiler.  INTERFACE_UNKNOWN nonzero means\n    we cannot trust the value of INTERFACE_ONLY.  If INTERFACE_UNKNOWN\n@@ -486,6 +491,8 @@ struct lang_type\n \n   union tree_node *dossier;\n \n+  union tree_node *methods;\n+\n   union tree_node *signature;\n   union tree_node *signature_pointer_to;\n   union tree_node *signature_reference_to;\n@@ -604,6 +611,10 @@ struct lang_type\n /* The is the VAR_DECL that contains NODE's dossier.  */\n #define CLASSTYPE_DOSSIER(NODE) (TYPE_LANG_SPECIFIC(NODE)->dossier)\n \n+/* List of all explicit methods (chained using DECL_NEXT_METHOD),\n+   in order they were parsed. */\n+#define CLASSTYPE_METHODS(NODE) (TYPE_LANG_SPECIFIC(NODE)->methods)\n+\n /* Nonzero means that this _CLASSTYPE node overloads operator().  */\n #define TYPE_OVERLOADS_CALL_EXPR(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_call_overloaded)\n \n@@ -927,7 +938,7 @@ struct lang_decl\n   struct template_info *template_info;\n   tree main_decl_variant;\n   struct pending_inline *pending_inline_info;\n-  tree vbase_init_list;\n+  tree next_method;\n   tree chain;\n };\n \n@@ -1007,6 +1018,9 @@ struct lang_decl\n #define DECL_CHAIN(NODE) (TREE_CHAIN (NODE))\n #endif\n \n+/* Next method in CLASSTYPE_METHODS list. */\n+#define DECL_NEXT_METHOD(NODE) (DECL_LANG_SPECIFIC(NODE)->next_method)\n+\n /* Points back to the decl which caused this lang_decl to be allocated.  */\n #define DECL_MAIN_VARIANT(NODE) (DECL_LANG_SPECIFIC(NODE)->main_decl_variant)\n \n@@ -1024,11 +1038,6 @@ struct lang_decl\n    which this signature member function pointer was created.  */\n #define DECL_MEMFUNC_POINTING_TO(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.memfunc_pointer_to)\n \n-/* Holds information about how virtual base classes should be initialized\n-   by this constructor *if* this constructor is the one to perform\n-   such initialization.  */\n-#define DECL_VBASE_INIT_LIST(NODE) (DECL_LANG_SPECIFIC(NODE)->vbase_init_list)\n-\n /* For a TEMPLATE_DECL: template-specific information.  */\n #define DECL_TEMPLATE_INFO(NODE) (DECL_LANG_SPECIFIC(NODE)->template_info)\n \n@@ -1218,7 +1227,7 @@ struct lang_decl\n #define DECL_TEMPLATE_IS_CLASS(NODE)    (DECL_RESULT(NODE) == NULL_TREE)\n #define DECL_TEMPLATE_PARMS(NODE)       DECL_ARGUMENTS(NODE)\n /* For class templates.  */\n-#define DECL_TEMPLATE_MEMBERS(NODE)     DECL_INITIAL(NODE)\n+#define DECL_TEMPLATE_MEMBERS(NODE)     DECL_SIZE(NODE)\n /* For function, method, class-data templates.  */\n #define DECL_TEMPLATE_RESULT(NODE)      DECL_RESULT(NODE)\n #define DECL_TEMPLATE_INSTANTIATIONS(NODE) DECL_VINDEX(NODE)\n@@ -1279,7 +1288,7 @@ extern tree truthvalue_conversion               PROTO((tree));\n extern tree type_for_mode                       PROTO((enum machine_mode, int));\n extern tree type_for_size                       PROTO((unsigned, int));\n \n-/* in cp-decl{2}.c */\n+/* in decl{2}.c */\n extern tree void_list_node;\n extern tree void_zero_node;\n extern tree default_function_type;\n@@ -1319,12 +1328,12 @@ extern tree long_long_integer_type_node, long_long_unsigned_type_node;\n /* For building calls to `delete'.  */\n extern tree integer_two_node, integer_three_node;\n \n-/* in cp-except.c */\n+/* in except.c */\n extern tree current_exception_type;\n extern tree current_exception_decl;\n extern tree current_exception_object;\n \n-/* in cp-pt.c  */\n+/* in pt.c  */\n /* PARM_VEC is a vector of template parameters, either IDENTIFIER_NODEs or\n    PARM_DECLs.  BINDINGS, if non-null, is a vector of bindings for those\n    parameters.  */\n@@ -1358,7 +1367,7 @@ struct tinst_level\n \n extern struct tinst_level *current_tinst_level;\n \n-/* in cp-class.c */\n+/* in class.c */\n extern tree current_class_name;\n extern tree current_class_type;\n extern tree previous_class_type;\n@@ -1372,7 +1381,7 @@ extern tree original_function_name;\n extern tree current_class_name, current_class_type, current_class_decl, C_C_D;\n extern tree current_vtable_decl;\n \n-/* in cp-init.c  */\n+/* in init.c  */\n extern tree global_base_init_list;\n extern tree current_base_init_list, current_member_init_list;\n \n@@ -1568,7 +1577,7 @@ enum access_type {\n   access_private_virtual\n };\n \n-/* in cp-lex.c  */\n+/* in lex.c  */\n extern tree current_unit_name, current_unit_language;\n \n /* Things for handling inline functions.  */\n@@ -1590,7 +1599,7 @@ struct pending_inline\n   unsigned int interface : 2;\t/* 0=interface 1=unknown 2=implementation */\n };\n \n-/* in cp-method.c */\n+/* in method.c */\n extern struct pending_inline *pending_inlines;\n \n /* 1 for -fall-virtual: make every member function (except\n@@ -1695,7 +1704,7 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n   (TEMPLATE_CONST_TPARMLIST (NODE) = saved_parmlist, \\\n    TEMPLATE_CONST_IDX (NODE) = I)\n \n-/* in cp-lex.c  */\n+/* in lex.c  */\n /* Indexed by TREE_CODE, these tables give C-looking names to\n    operators represented by TREE_CODES.  For example,\n    opname_tab[(int) MINUS_EXPR] == \"-\".  */\n@@ -1706,7 +1715,7 @@ extern tree convert_and_check\t\t\tPROTO((tree, tree));\n extern void overflow_warning\t\t\tPROTO((tree));\n extern void unsigned_conversion_warning\t\tPROTO((tree, tree));\n \n-/* in cp-call.c */\n+/* in call.c */\n extern struct candidate *ansi_c_bullshit;\n \n extern int rank_for_overload\t\t\tPROTO((struct candidate *, struct candidate *));\n@@ -1721,12 +1730,13 @@ extern tree build_overload_call_real\t\tPROTO((tree, tree, int, struct candidate *\n extern tree build_overload_call\t\t\tPROTO((tree, tree, int, struct candidate *));\n extern tree build_overload_call_maybe\t\tPROTO((tree, tree, int, struct candidate *));\n \n-/* in cp-class.c */\n+/* in class.c */\n extern tree build_vbase_pointer\t\t\tPROTO((tree, tree));\n extern tree build_vbase_path\t\t\tPROTO((enum tree_code, tree, tree, tree, int));\n extern tree build_vtable_entry\t\t\tPROTO((tree, tree));\n extern tree build_vfn_ref\t\t\tPROTO((tree *, tree, tree));\n extern void add_method\t\t\t\tPROTO((tree, tree *, tree));\n+extern tree get_vfield_offset\t\t\tPROTO((tree));\n extern void duplicate_tag_error\t\t\tPROTO((tree));\n extern tree finish_struct\t\t\tPROTO((tree, tree, int));\n extern int resolves_to_fixed_type_p\t\tPROTO((tree, int *));\n@@ -1742,7 +1752,7 @@ extern tree instantiate_type\t\t\tPROTO((tree, tree, int));\n extern void print_class_statistics\t\tPROTO((void));\n extern void maybe_push_cache_obstack\t\tPROTO((void));\n \n-/* in cp-cvt.c */\n+/* in cvt.c */\n extern tree convert_to_reference\t\tPROTO((tree, tree, tree, tree, int, char *, int, int));\n extern tree convert_from_reference\t\tPROTO((tree));\n extern tree convert_to_aggr\t\t\tPROTO((tree, tree, char **, int));\n@@ -1755,7 +1765,7 @@ extern tree build_type_conversion\t\tPROTO((enum tree_code, tree, tree, int));\n extern int build_default_binary_type_conversion\tPROTO((enum tree_code, tree *, tree *));\n extern int build_default_unary_type_conversion\tPROTO((enum tree_code, tree *));\n \n-/* cp-decl.c */\n+/* decl.c */\n extern int global_bindings_p\t\t\tPROTO((void));\n extern void keep_next_level\t\t\tPROTO((void));\n extern int kept_level_p\t\t\t\tPROTO((void));\n@@ -1833,7 +1843,7 @@ extern void pop_implicit_try_blocks\t\tPROTO((tree));\n extern void push_exception_cleanup\t\tPROTO((tree));\n extern void revert_static_member_fn\t\tPROTO((tree *, tree *, tree *));\n \n-/* in cp-decl2.c */\n+/* in decl2.c */\n extern int lang_decode_option\t\t\tPROTO((char *));\n extern tree grok_method_quals\t\t\tPROTO((tree, tree, tree));\n extern void grokclassfn\t\t\t\tPROTO((tree, tree, tree, enum overload_flags, tree));\n@@ -1844,7 +1854,7 @@ extern void check_classfn\t\t\tPROTO((tree, tree, tree));\n extern tree grokfield\t\t\t\tPROTO((tree, tree, tree, tree, tree));\n extern tree grokbitfield\t\t\tPROTO((tree, tree, tree));\n extern tree groktypefield\t\t\tPROTO((tree, tree));\n-extern tree grokoptypename\t\t\tPROTO((tree, int));\n+extern tree grokoptypename\t\t\tPROTO((tree, tree));\n extern tree build_push_scope\t\t\tPROTO((tree, tree));\n extern tree constructor_name_full\t\tPROTO((tree));\n extern tree constructor_name\t\t\tPROTO((tree));\n@@ -1862,10 +1872,14 @@ extern void walk_vtables\t\t\tPROTO((void (*)(), void (*)()));\n extern void finish_file\t\t\t\tPROTO((void));\n extern void warn_if_unknown_interface\t\tPROTO((void));\n extern tree grok_x_components\t\t\tPROTO((tree, tree));\n+extern tree reparse_absdcl_as_expr\t\tPROTO((tree, tree));\n+extern tree reparse_absdcl_as_casts\t\tPROTO((tree, tree));\n+extern tree reparse_decl_as_expr\t\tPROTO((tree, tree));\n+extern tree finish_decl_parsing\t\t\tPROTO((tree));\n \n-/* in cp-edsel.c */\n+/* in edsel.c */\n \n-/* in cp-except.c */\n+/* in except.c */\n extern tree lookup_exception_cname\t\tPROTO((tree, tree, tree));\n extern tree lookup_exception_tname\t\tPROTO((tree));\n extern tree lookup_exception_object\t\tPROTO((tree, tree, int));\n@@ -1888,13 +1902,13 @@ extern void setup_exception_throw_decl\t\tPROTO((void));\n extern void init_exception_processing\t\tPROTO((void));\n extern void init_exception_processing_1\t\tPROTO((void));\n \n-/* in cp-expr.c */\n+/* in expr.c */\n /* skip cplus_expand_expr */\n extern void init_cplus_expand\t\t\tPROTO((void));\n extern void fixup_result_decl\t\t\tPROTO((tree, struct rtx_def *));\n extern int decl_in_memory_p\t\t\tPROTO((tree));\n \n-/* in cp-gc.c */\n+/* in gc.c */\n extern int type_needs_gc_entry\t\t\tPROTO((tree));\n extern int value_safe_from_gc\t\t\tPROTO((tree, tree));\n extern void build_static_gc_entry\t\tPROTO((tree, tree));\n@@ -1911,7 +1925,7 @@ extern tree build_typeid\t\t\tPROTO((tree));\n extern tree get_typeid\t\t\t\tPROTO((tree));\n extern tree build_dynamic_cast\t\t\tPROTO((tree, tree));\n \n-/* in cp-init.c */\n+/* in init.c */\n extern void emit_base_init\t\t\tPROTO((tree, int));\n extern void check_base_init\t\t\tPROTO((tree));\n extern tree build_virtual_init\t\t\tPROTO((tree, tree, tree));\n@@ -1941,9 +1955,9 @@ extern tree build_delete\t\t\tPROTO((tree, tree, tree, int, int));\n extern tree build_vbase_delete\t\t\tPROTO((tree, tree));\n extern tree build_vec_delete\t\t\tPROTO((tree, tree, tree, tree, tree, tree));\n \n-/* in cp-input.c */\n+/* in input.c */\n \n-/* in cp-lex.c */\n+/* in lex.c */\n extern tree make_pointer_declarator\t\tPROTO((tree, tree));\n extern tree make_reference_declarator\t\tPROTO((tree, tree));\n extern char *operator_name_string\t\tPROTO((tree));\n@@ -1986,7 +2000,7 @@ extern void dump_time_statistics\t\tPROTO((void));\n extern void compiler_error_with_decl\t\tPROTO((tree, char *));\n extern void yyerror\t\t\t\tPROTO((char *));\n \n-/* in cp-error.c */\n+/* in error.c */\n extern void init_error\t\t\t\tPROTO((void));\n extern char *fndecl_as_string\t\t\tPROTO((tree, tree, int));\n extern char *type_as_string\t\t\tPROTO((tree, int));\n@@ -1998,7 +2012,7 @@ extern char *language_as_string\t\t\tPROTO((enum languages, int));\n extern char *parm_as_string\t\t\tPROTO((int, int));\n extern char *op_as_string\t\t\tPROTO((enum tree_code, int));\n \n-/* in cp-method.c */\n+/* in method.c */\n extern void init_method\t\t\t\tPROTO((void));\n extern tree make_anon_parm_name\t\t\tPROTO((void));\n extern void clear_anon_parm_name\t\tPROTO((void));\n@@ -2017,11 +2031,11 @@ extern tree build_opfncall\t\t\tPROTO((enum tree_code, int, tree, tree, tree));\n extern tree hack_identifier\t\t\tPROTO((tree, tree, int));\n extern tree build_component_type_expr\t\tPROTO((tree, tree, tree, int));\n \n-/* in cp-pt.c */\n+/* in pt.c */\n extern void begin_template_parm_list\t\tPROTO((void));\n extern tree process_template_parm\t\tPROTO((tree, tree));\n extern tree end_template_parm_list\t\tPROTO((tree));\n-extern void end_template_decl\t\t\tPROTO((tree, tree, tree));\n+extern void end_template_decl\t\t\tPROTO((tree, tree, tree, int));\n extern tree lookup_template_class\t\tPROTO((tree, tree, tree));\n extern void push_template_decls\t\t\tPROTO((tree, tree, int));\n extern void pop_template_decls\t\t\tPROTO((tree, tree, int));\n@@ -2039,7 +2053,7 @@ extern void do_pending_templates\t\tPROTO((void));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n extern void do_function_instantiation\t\tPROTO((tree, tree));\n \n-/* in cp-search.c */\n+/* in search.c */\n extern tree make_memoized_table_entry\t\tPROTO((tree, tree, int));\n extern void push_memoized_context\t\tPROTO((tree, int));\n extern void pop_memoized_context\t\tPROTO((int));\n@@ -2075,7 +2089,7 @@ extern void init_search_processing\t\tPROTO((void));\n extern void reinit_search_statistics\t\tPROTO((void));\n extern tree current_scope\t\t\tPROTO((void));\n \n-/* in cp-sig.c */\n+/* in sig.c */\n extern tree build_signature_pointer_type\tPROTO((tree, int, int));\n extern tree build_signature_reference_type\tPROTO((tree, int, int));\n extern tree build_signature_pointer_constructor\tPROTO((tree, tree));\n@@ -2084,12 +2098,12 @@ extern tree build_optr_ref\t\t\tPROTO((tree));\n extern tree build_sptr_ref\t\t\tPROTO((tree));\n extern tree build_vptr_ref\t\t\tPROTO((tree));\n \n-/* in cp-spew.c */\n+/* in spew.c */\n extern void init_spew\t\t\t\tPROTO((void));\n extern int yylex\t\t\t\tPROTO((void));\n extern tree arbitrate_lookup\t\t\tPROTO((tree, tree, tree));\n \n-/* in cp-tree.c */\n+/* in tree.c */\n extern int lvalue_p\t\t\t\tPROTO((tree));\n extern int lvalue_or_else\t\t\tPROTO((tree, char *));\n extern tree build_cplus_new\t\t\tPROTO((tree, tree, int));\n@@ -2135,7 +2149,7 @@ extern void print_lang_statistics\t\tPROTO((void));\n extern tree array_type_nelts_total\t\tPROTO((tree));\n extern tree array_type_nelts_top\t\tPROTO((tree));\n \n-/* in cp-typeck.c */\n+/* in typeck.c */\n extern tree target_type\t\t\t\tPROTO((tree));\n extern tree require_complete_type\t\tPROTO((tree));\n extern int type_unknown_p\t\t\tPROTO((tree));\n@@ -2191,7 +2205,7 @@ extern tree c_expand_start_case\t\t\tPROTO((tree));\n extern tree build_component_ref\t\t\tPROTO((tree, tree, tree, int));\n extern tree build_ptrmemfunc\t\t\tPROTO((tree, tree, int));\n \n-/* in cp-type2.c */\n+/* in typeck2.c */\n extern tree error_not_base_type\t\t\tPROTO((tree, tree));\n extern tree binfo_or_else\t\t\tPROTO((tree, tree));\n extern void error_with_aggr_type\t\t(); /* PROTO((tree, char *, HOST_WIDE_INT)); */\n@@ -2209,7 +2223,7 @@ extern tree build_functional_cast\t\tPROTO((tree, tree));\n extern char *enum_name_string\t\t\tPROTO((tree, tree));\n extern void report_case_error\t\t\tPROTO((int, tree, tree, tree));\n \n-/* in cp-xref.c */\n+/* in xref.c */\n extern void GNU_xref_begin\t\t\tPROTO((char *));\n extern void GNU_xref_end\t\t\tPROTO((int));\n extern void GNU_xref_file\t\t\tPROTO((char *));"}, {"sha": "5e41618a63139019c6b3f354c76bbc118ecd200b", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -581,7 +581,11 @@ build_up_reference (type, arg, flags, checkconst)\n   if (TYPE_USES_COMPLEX_INHERITANCE (argtype))\n     {\n       TREE_TYPE (rval) = TYPE_POINTER_TO (argtype);\n-      rval = convert_pointer_to (target_type, rval);\n+      if (flags & LOOKUP_PROTECT)\n+\trval = convert_pointer_to (target_type, rval);\n+      else\n+\trval\n+\t  = convert_to_pointer_force (build_pointer_type (target_type), rval);\n       TREE_TYPE (rval) = type;\n     }\n   TREE_CONSTANT (rval) = literal_flag;\n@@ -1439,18 +1443,16 @@ convert_force (type, expr)\n   if (code == POINTER_TYPE)\n     return fold (convert_to_pointer_force (type, e));\n \n-  /* From cp-typeck.c convert_for_assignment */\n+  /* From typeck.c convert_for_assignment */\n   if (((TREE_CODE (TREE_TYPE (e)) == POINTER_TYPE && TREE_CODE (e) == ADDR_EXPR\n \t&& TREE_CODE (TREE_TYPE (e)) == POINTER_TYPE\n \t&& TREE_CODE (TREE_TYPE (TREE_TYPE (e))) == METHOD_TYPE)\n-       || integer_zerop (e))\n+       || integer_zerop (e)\n+       || TYPE_PTRMEMFUNC_P (TREE_TYPE (e)))\n       && TYPE_PTRMEMFUNC_P (type))\n     {\n       /* compatible pointer to member functions. */\n-      e = build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), e, 1);\n-      if (e == 0)\n-\treturn error_mark_node;\n-      return digest_init (type, e, (tree *)0);\n+      return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), e, 1);\n     }\n   {\n     int old_equiv = flag_int_enum_equivalence;"}, {"sha": "1ad7849f8f315474b71240622846b0ba917c9339", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 184, "deletions": 124, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -444,7 +444,7 @@ extern int flag_conserve_space;\n \n extern tree *current_lang_base, *current_lang_stack;\n \f\n-/* C and C++ flags are in cp-decl2.c.  */\n+/* C and C++ flags are in decl2.c.  */\n \n /* Set to 0 at beginning of a constructor, set to 1\n    if that function does an allocation before referencing its\n@@ -465,7 +465,7 @@ int current_function_obstack_index;\n \n int current_function_obstack_usage;\n \n-/* Flag used when debugging cp-spew.c */\n+/* Flag used when debugging spew.c */\n \n extern int spew_debug;\n \n@@ -1471,13 +1471,17 @@ struct saved_scope {\n   tree class_name, class_type, class_decl, function_decl;\n   struct binding_level *class_bindings;\n   tree previous_class_type;\n+  tree *lang_base, *lang_stack, lang_name;\n+  int lang_stacksize;\n+  tree named_labels;\n };\n static struct saved_scope *current_saved_scope;\n extern tree prev_class_type;\n \n void\n push_to_top_level ()\n {\n+  extern int current_lang_stacksize;\n   struct saved_scope *s =\n     (struct saved_scope *) xmalloc (sizeof (struct saved_scope));\n   struct binding_level *b = current_binding_level;\n@@ -1543,10 +1547,21 @@ push_to_top_level ()\n   s->function_decl = current_function_decl;\n   s->class_bindings = class_binding_level;\n   s->previous_class_type = previous_class_type;\n+  s->lang_stack = current_lang_stack;\n+  s->lang_base = current_lang_base;\n+  s->lang_stacksize = current_lang_stacksize;\n+  s->lang_name = current_lang_name;\n+  s->named_labels = named_labels;\n   current_class_name = current_class_type = current_class_decl = NULL_TREE;\n   current_function_decl = NULL_TREE;\n   class_binding_level = (struct binding_level *)0;\n   previous_class_type = NULL_TREE;\n+  current_lang_stacksize = 10;\n+  current_lang_stack = current_lang_base\n+    = (tree *) xmalloc (current_lang_stacksize * sizeof (tree));\n+  current_lang_name = lang_name_cplusplus;\n+  strict_prototype = strict_prototypes_lang_cplusplus;\n+  named_labels = NULL_TREE;\n \n   s->prev = current_saved_scope;\n   s->old_bindings = old_bindings;\n@@ -1556,6 +1571,7 @@ push_to_top_level ()\n void\n pop_from_top_level ()\n {\n+  extern int current_lang_stacksize;\n   struct saved_scope *s = current_saved_scope;\n   tree t;\n \n@@ -1584,6 +1600,17 @@ pop_from_top_level ()\n   current_function_decl = s->function_decl;\n   class_binding_level = s->class_bindings;\n   previous_class_type = s->previous_class_type;\n+  free (current_lang_base);\n+  current_lang_base = s->lang_base;\n+  current_lang_stack = s->lang_stack;\n+  current_lang_name = s->lang_name;\n+  current_lang_stacksize = s->lang_stacksize;\n+  if (current_lang_name == lang_name_cplusplus)\n+    strict_prototype = strict_prototypes_lang_cplusplus;\n+  else if (current_lang_name == lang_name_c)\n+    strict_prototype = strict_prototypes_lang_c;\n+  named_labels = s->named_labels;\n+\n   free (s);\n }\n \f\n@@ -1661,7 +1688,7 @@ set_nested_typename (decl, classname, name, type)\n    incorrect results with `-g' unless they duplicate this code.\n \n    This is currently needed mainly for dbxout.c, but we can make\n-   use of it in cp-method.c later as well.  */\n+   use of it in method.c later as well.  */\n tree\n make_type_decl (name, type)\n      tree name, type;\n@@ -1958,6 +1985,37 @@ decls_match (newdecl, olddecl)\n       else\n \ttypes_match = 0;\n     }\n+  else if (TREE_CODE (newdecl) == TEMPLATE_DECL\n+\t   && TREE_CODE (olddecl) == TEMPLATE_DECL)\n+    {\n+\ttree newargs = DECL_TEMPLATE_PARMS (newdecl);\n+\ttree oldargs = DECL_TEMPLATE_PARMS (olddecl);\n+\tint i, len = TREE_VEC_LENGTH (newargs);\n+\n+\tif (TREE_VEC_LENGTH (oldargs) != len)\n+\t  return 0;\n+\t\n+\tfor (i = 0; i < len; i++)\n+\t  {\n+\t    tree newarg = TREE_VEC_ELT (newargs, i);\n+\t    tree oldarg = TREE_VEC_ELT (oldargs, i);\n+\t    if (TREE_CODE (newarg) != TREE_CODE (oldarg))\n+\t      return 0;\n+\t    else if (TREE_CODE (newarg) == IDENTIFIER_NODE)\n+\t      /* continue */;\n+\t    else if (! comptypes (TREE_TYPE (newarg), TREE_TYPE (oldarg), 1))\n+\t      return 0;\n+\t  }\n+\n+\tif (DECL_TEMPLATE_IS_CLASS (newdecl)\n+\t    != DECL_TEMPLATE_IS_CLASS (olddecl))\n+\t  types_match = 0;\n+\telse if (DECL_TEMPLATE_IS_CLASS (newdecl))\n+\t  types_match = 1;\n+\telse\n+\t  types_match = decls_match (DECL_TEMPLATE_RESULT (olddecl),\n+\t\t\t\t     DECL_TEMPLATE_RESULT (newdecl));\n+    }\n   else\n     {\n       if (TREE_TYPE (newdecl) == error_mark_node)\n@@ -2028,7 +2086,7 @@ warn_extern_redeclared_static (newdecl, olddecl)\n    If safely possible, alter OLDDECL to look like NEWDECL, and return 1.\n    Otherwise, return 0.  */\n \n-static int\n+int\n duplicate_decls (newdecl, olddecl)\n      register tree newdecl, olddecl;\n {\n@@ -2038,8 +2096,7 @@ duplicate_decls (newdecl, olddecl)\n   int new_defines_function;\n   tree previous_c_decl = NULL_TREE;\n \n-  if (TREE_CODE (newdecl) == FUNCTION_DECL\n-      && is_overloaded_fn (olddecl))\n+  if (TREE_CODE (newdecl) == FUNCTION_DECL && is_overloaded_fn (olddecl))\n     {\n       olddecl = get_first_fn (olddecl);\n \n@@ -2144,6 +2201,8 @@ duplicate_decls (newdecl, olddecl)\n       cp_error (\"declaration of C function `%#D' conflicts with\", newdecl);\n       cp_error_at (\"previous declaration `%#D' here\", previous_c_decl);\n     }\n+  else if (!types_match && TREE_CODE (newdecl) == TEMPLATE_DECL)\n+    return 0;\n   else if (!types_match)\n     {\n       tree oldtype = TREE_TYPE (olddecl);\n@@ -2238,7 +2297,7 @@ duplicate_decls (newdecl, olddecl)\n       char *errmsg = redeclaration_error_message (newdecl, olddecl);\n       if (errmsg)\n \t{\n-\t  error_with_decl (newdecl, errmsg);\n+\t  cp_error (errmsg, newdecl);\n \t  if (DECL_NAME (olddecl) != NULL_TREE)\n \t    cp_error_at ((DECL_INITIAL (olddecl)\n \t\t\t  && current_binding_level == global_binding_level)\n@@ -2295,6 +2354,8 @@ duplicate_decls (newdecl, olddecl)\n \tDECL_CLASS_CONTEXT (newdecl) = DECL_CLASS_CONTEXT (olddecl);\n       if (DECL_CHAIN (newdecl) == NULL_TREE)\n \tDECL_CHAIN (newdecl) = DECL_CHAIN (olddecl);\n+      if (DECL_NEXT_METHOD (newdecl) == NULL_TREE)\n+\tDECL_NEXT_METHOD (newdecl) = DECL_NEXT_METHOD (olddecl);\n       if (DECL_PENDING_INLINE_INFO (newdecl) == (struct pending_inline *)0)\n \tDECL_PENDING_INLINE_INFO (newdecl) = DECL_PENDING_INLINE_INFO (olddecl);\n     }\n@@ -2325,6 +2386,10 @@ duplicate_decls (newdecl, olddecl)\n #endif\n     }\n \n+  if (TREE_CODE (olddecl) == TEMPLATE_DECL\n+      && DECL_TEMPLATE_INFO (olddecl)->length)\n+    DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n+  \n   /* Special handling ensues if new decl is a function definition.  */\n   new_defines_function = (TREE_CODE (newdecl) == FUNCTION_DECL\n \t\t\t  && DECL_INITIAL (newdecl) != NULL_TREE);\n@@ -2381,7 +2446,8 @@ duplicate_decls (newdecl, olddecl)\n \t    layout_type (TREE_TYPE (newdecl));\n \t  if (TREE_CODE (newdecl) != FUNCTION_DECL\n \t      && TREE_CODE (newdecl) != TYPE_DECL\n-\t      && TREE_CODE (newdecl) != CONST_DECL)\n+\t      && TREE_CODE (newdecl) != CONST_DECL\n+\t      && TREE_CODE (newdecl) != TEMPLATE_DECL)\n \t    layout_decl (newdecl, 0);\n \t}\n       else\n@@ -2630,7 +2696,7 @@ pushdecl (x)\n \t  cp_error_at (\"`%#D' used prior to declaration\", x);\n \t}\n \n-      if (t != NULL_TREE)\n+      else if (t != NULL_TREE)\n \t{\n \t  if (TREE_CODE (t) == PARM_DECL)\n \t    {\n@@ -2639,25 +2705,23 @@ pushdecl (x)\n \t    }\n \t  file = DECL_SOURCE_FILE (t);\n \t  line = DECL_SOURCE_LINE (t);\n-\t}\n \n-      if (t != NULL_TREE\n-\t  && (TREE_CODE (t) != TREE_CODE (x) || is_overloaded_fn (t)))\n-\t{\n-\t  if (TREE_CODE (t) == TYPE_DECL || TREE_CODE (x) == TYPE_DECL)\n+\t  if (TREE_CODE (t) != TREE_CODE (x))\n \t    {\n-\t      /* We do nothing special here, because C++ does such nasty\n-\t\t things with TYPE_DECLs.  Instead, just let the TYPE_DECL\n-\t\t get shadowed, and know that if we need to find a TYPE_DECL\n-\t\t for a given name, we can look in the IDENTIFIER_TYPE_VALUE\n-\t\t slot of the identifier.  */\n-\t      ;\n+\t      if (TREE_CODE (t) == TYPE_DECL || TREE_CODE (x) == TYPE_DECL)\n+\t\t{\n+\t\t  /* We do nothing special here, because C++ does such nasty\n+\t\t     things with TYPE_DECLs.  Instead, just let the TYPE_DECL\n+\t\t     get shadowed, and know that if we need to find a TYPE_DECL\n+\t\t     for a given name, we can look in the IDENTIFIER_TYPE_VALUE\n+\t\t     slot of the identifier.  */\n+\t\t  ;\n+\t\t}\n+\t      else if (duplicate_decls (x, t))\n+\t\treturn t;\n \t    }\n \t  else if (duplicate_decls (x, t))\n-\t    return t;\n-\t}\n-      else if (t != NULL_TREE && duplicate_decls (x, t))\n-\t{\n+\t    {\n #if 0\n \t  /* This is turned off until I have time to do it right (bpk).  */\n \n@@ -2682,14 +2746,16 @@ pushdecl (x)\n \t    }\n #endif\n \n-\t  /* Due to interference in memory reclamation (X may be\n-\t     obstack-deallocated at this point), we must guard against\n-\t     one really special case.  */\n-\t  if (current_function_decl == x)\n-\t    current_function_decl = t;\n-\n-\t  return t;\n+\t      /* Due to interference in memory reclamation (X may be\n+\t\t obstack-deallocated at this point), we must guard against\n+\t\t one really special case.  */\n+\t      if (current_function_decl == x)\n+\t\tcurrent_function_decl = t;\n+\t      \n+\t      return t;\n+\t    }\n \t}\n+      \n \n       /* If declaring a type as a typedef, and the type has no known\n \t typedef name, install this TYPE_DECL as its typedef name.  */\n@@ -3272,7 +3338,7 @@ redeclaration_error_message (newdecl, olddecl)\n       if (comptypes (newdecl, olddecl, 0))\n \treturn 0;\n       else\n-\treturn \"redefinition of `%s'\";\n+\treturn \"redefinition of `%#D'\";\n     }\n   else if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n@@ -3294,12 +3360,18 @@ redeclaration_error_message (newdecl, olddecl)\n \t       && !(DECL_INLINE (newdecl) && DECL_EXTERNAL (newdecl))))\n \t{\n \t  if (DECL_NAME (olddecl) == NULL_TREE)\n-\t    return \"`%s' not declared in class\";\n+\t    return \"`%#D' not declared in class\";\n \t  else\n-\t    return \"redefinition of `%s'\";\n+\t    return \"redefinition of `%#D'\";\n \t}\n       return 0;\n     }\n+  else if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n+    {\n+      if (DECL_INITIAL (olddecl) && DECL_INITIAL (newdecl))\n+\treturn \"redefinition of `%#D'\";\n+      return 0;\n+    }\n   else if (current_binding_level == global_binding_level)\n     {\n       /* Objects declared at top level:  */\n@@ -3309,11 +3381,11 @@ redeclaration_error_message (newdecl, olddecl)\n       /* Reject two definitions.  */\n       if (DECL_INITIAL (olddecl) != NULL_TREE\n \t  && DECL_INITIAL (newdecl) != NULL_TREE)\n-\treturn \"redefinition of `%s'\";\n+\treturn \"redefinition of `%#D'\";\n       /* Now we have two tentative defs, or one tentative and one real def.  */\n       /* Insist that the linkage match.  */\n       if (TREE_PUBLIC (olddecl) != TREE_PUBLIC (newdecl))\n-\treturn \"conflicting declarations of `%s'\";\n+\treturn \"conflicting declarations of `%#D'\";\n       return 0;\n     }\n   else\n@@ -3322,7 +3394,7 @@ redeclaration_error_message (newdecl, olddecl)\n       /* Reject two definitions, and reject a definition\n \t together with an external reference.  */\n       if (!(DECL_EXTERNAL (newdecl) && DECL_EXTERNAL (olddecl)))\n-\treturn \"redeclaration of `%s'\";\n+\treturn \"redeclaration of `%#D'\";\n       return 0;\n     }\n }\n@@ -3780,8 +3852,7 @@ lookup_nested_type (type, context)\n    definitions if there are many, or return 0 if it is undefined.\n \n    If PREFER_TYPE is > 0, we prefer TYPE_DECLs.\n-   If PREFER_TYPE is = 0, we prefer non-TYPE_DECLs.\n-   If PREFER_TYPE is < 0, we arbitrate according to lexical context.  */\n+   Otherwise we prefer non-TYPE_DECLs.  */\n \n tree\n lookup_name (name, prefer_type)\n@@ -3840,9 +3911,8 @@ lookup_name (name, prefer_type)\n \t  if (val == val_as_type || prefer_type > 0\n \t      || looking_for_typename > 0)\n \t    return val_as_type;\n-\t  if (prefer_type == 0)\n-\t    return val;\n-\t  return arbitrate_lookup (name, val, val_as_type);\n+\n+\t  return val;\n \t}\n       if (TREE_TYPE (val) == error_mark_node)\n \treturn error_mark_node;\n@@ -5233,7 +5303,7 @@ start_decl (declarator, declspecs, initialized, raises)\n           my_friendly_abort (13);\n         }\n       else if (TREE_CODE (result) == FUNCTION_DECL)\n-        tem = push_overloaded_decl (tem, 0);\n+        /*tem = push_overloaded_decl (tem, 0)*/;\n       else if (TREE_CODE (result) == VAR_DECL\n \t       || TREE_CODE (result) == TYPE_DECL)\n \t{\n@@ -6329,9 +6399,17 @@ complete_array_type (type, initial_value, do_default)\n \n   if (maxindex)\n     {\n+      tree itype;\n+\n       TYPE_DOMAIN (type) = build_index_type (maxindex);\n       if (!TREE_TYPE (maxindex))\n \tTREE_TYPE (maxindex) = TYPE_DOMAIN (type);\n+      if (initial_value)\n+        itype = TREE_TYPE (initial_value);\n+      else\n+\titype = NULL;\n+      if (itype && !TYPE_DOMAIN (itype))\n+\tTYPE_DOMAIN (itype) = TYPE_DOMAIN (type);\n     }\n \n   /* Lay out the type now that we can get the real answer.  */\n@@ -6947,8 +7025,20 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n \tcase IDENTIFIER_NODE:\n \t  dname = decl;\n-\t  name = IDENTIFIER_POINTER (decl);\n \t  decl = NULL_TREE;\n+\n+\t  if (IDENTIFIER_TYPENAME_P (dname))\n+\t    {\n+\t      my_friendly_assert (flags == NO_SPECIAL, 154);\n+\t      flags = TYPENAME_FLAG;\n+\t      ctor_return_type = TREE_TYPE (dname);\n+\t      return_type = return_conversion;\n+\t    }\n+\n+\t  if (IDENTIFIER_OPNAME_P (dname))\n+\t    name = operator_name_string (dname);\n+\t  else\n+\t    name = IDENTIFIER_POINTER (dname);\n \t  break;\n \n \tcase RECORD_TYPE:\n@@ -6965,15 +7055,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  decl = NULL_TREE;\n \t  break;\n \n-\tcase TYPE_EXPR:\n-\t  my_friendly_assert (flags == NO_SPECIAL, 154);\n-\t  flags = TYPENAME_FLAG;\n-\t  name = \"operator <typename>\";\t/* We don't know the type yet.  */\n-\t  /* Go to the absdcl.  */\n-\t  decl = TREE_OPERAND (decl, 0);\n-\t  return_type = return_conversion;\n-\t  break;\n-\n \t  /* C++ extension */\n \tcase SCOPE_REF:\n /*\n@@ -7214,6 +7295,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \ttype = void_type_node;\n       else if (return_type == return_ctor)\n \ttype = TYPE_POINTER_TO (ctor_return_type);\n+      else if (return_type == return_conversion)\n+\ttype = ctor_return_type;\n       else if (current_class_type\n \t       && IS_SIGNATURE (current_class_type)\n \t       && (RIDBIT_SETP (RID_TYPEDEF, specbits)\n@@ -7247,6 +7330,17 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n       error (\"return type specification for constructor invalid\");\n       type = TYPE_POINTER_TO (ctor_return_type);\n     }\n+  else if (return_type == return_conversion)\n+    {\n+      if (comp_target_types (type, ctor_return_type, 1) == 0)\n+\tcp_error (\"operator `%T' declared to return `%T'\",\n+\t\t  ctor_return_type, type);\n+      else\n+\tcp_pedwarn (\"return type specified for `operator %T'\",\n+\t\t    ctor_return_type);\n+\n+      type = ctor_return_type;\n+    }\n \n   ctype = NULL_TREE;\n \n@@ -7508,11 +7602,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t    error (\"typedef declaration includes an initializer\");\n   \n \t  /* To process a class-local typedef declaration, we descend down\n-\t     the chain of declspecs looking for the `typedef' spec.  When we\n-\t     find it, we splice it out of the chain of declspecs, and then\n-\t     recursively call `grokdeclarator' with the original declarator\n-\t     and with the newly adjusted declspecs.  This call should return\n-\t     a FIELD_DECL node with the TREE_TYPE (and other parts) set\n+\t     the chain of declspecs looking for the `typedef' spec.  When\n+\t     we find it, we replace it with `static', and then recursively\n+\t     call `grokdeclarator' with the original declarator and with\n+\t     the newly adjusted declspecs.  This call should return a\n+\t     FIELD_DECL node with the TREE_TYPE (and other parts) set\n \t     appropriately.  We can then just change the TREE_CODE on that\n \t     from FIELD_DECL to TYPE_DECL and we're done.  */\n \n@@ -7523,11 +7617,19 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t      if (TREE_VALUE (scanner) == ridpointers[(int) RID_TYPEDEF])\n \t\tbreak;\n   \t    }\n-\t  if (previous_declspec)\n-\t    TREE_CHAIN (previous_declspec) = TREE_CHAIN (scanner);\n+\n+\t  if (scanner == IDENTIFIER_AS_LIST (ridpointers [(int) RID_TYPEDEF]))\n+\t    {\n+\t      if (previous_declspec)\n+\t\tTREE_CHAIN (previous_declspec)\n+\t\t  = IDENTIFIER_AS_LIST (ridpointers [(int) RID_STATIC]);\n+\t      else\n+\t\tdeclspecs\n+\t\t  = IDENTIFIER_AS_LIST (ridpointers [(int) RID_STATIC]);\n+\t    }\n \t  else\n-\t    declspecs = TREE_CHAIN (scanner);\n-  \n+\t    TREE_VALUE (scanner) = ridpointers[(int) RID_STATIC];\n+\n \t  /* In the recursive call to grokdeclarator we need to know\n \t     whether we are working on a signature-local typedef.  */\n \t  if (IS_SIGNATURE (current_class_type))\n@@ -7650,7 +7752,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t qualify the member name.\n \t an ADDR_EXPR (for &...),\n \t a BIT_NOT_EXPR (for destructors)\n-\t a TYPE_EXPR (for operator typenames)\n \n \t At this point, TYPE is the type of elements of an array,\n \t or for a function to return, or for a pointer to point to.\n@@ -7854,7 +7955,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t&& (friendp == 0 || dname == current_class_name))\n \t      ctype = current_class_type;\n \n-\t    if (ctype && flags == TYPENAME_FLAG)\n+\t    if (ctype && return_type == return_conversion)\n \t      TYPE_HAS_CONVERSION (ctype) = 1;\n \t    if (ctype && constructor_name (ctype) == dname)\n \t      {\n@@ -7910,17 +8011,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t\treturn void_type_node;\n \t\t      }\n \t\t    {\n-\t\t      int inlinep, staticp;\n-\t\t      inlinep = RIDBIT_SETP (RID_INLINE, specbits);\n-\t\t      staticp = RIDBIT_SETP (RID_STATIC, specbits);\n-\t\t      RIDBIT_RESET (RID_INLINE, specbits);\n-\t\t      RIDBIT_RESET (RID_STATIC, specbits);\n-\t\t      if (RIDBIT_ANY_SET (specbits))\n+\t\t      RID_BIT_TYPE tmp_bits;\n+\t\t      bcopy ((void*)&specbits, (void*)&tmp_bits, sizeof(RID_BIT_TYPE));\n+\t\t      RIDBIT_RESET (RID_INLINE, tmp_bits);\n+\t\t      RIDBIT_RESET (RID_STATIC, tmp_bits);\n+\t\t      if (RIDBIT_ANY_SET (tmp_bits))\n \t\t\terror (\"return value type specifier for constructor ignored\");\n-\t\t      if (inlinep)\n-\t\t\tRIDBIT_SET (RID_INLINE, specbits);\n-\t\t      if (staticp)\n-\t\t\tRIDBIT_SET (RID_STATIC, specbits);\n \t\t    }\n \t\t    type = TYPE_POINTER_TO (ctype);\n \t\t    if (decl_context == FIELD &&\n@@ -7982,9 +8078,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t      /* Say it's a definition only for the CALL_EXPR\n \t\t closest to the identifier.  */\n \t      funcdef_p =\n-\t\t(inner_decl &&\n-\t\t (TREE_CODE (inner_decl) == IDENTIFIER_NODE\n-\t\t  || TREE_CODE (inner_decl) == TYPE_EXPR)) ? funcdef_flag : 0;\n+\t\t(inner_decl && TREE_CODE (inner_decl) == IDENTIFIER_NODE)\n+\t\t  ? funcdef_flag : 0;\n \n \t      /* FIXME: This is where default args should be fully\n \t\t processed.  */\n@@ -8242,12 +8337,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t\t    return t;\n \t\t\t  }\n \n-\t\t\tif (flags == TYPENAME_FLAG)\n-\t\t\t  cp_error (\"type conversion is not a member of structure `%T'\", ctype);\n-\t\t\telse\n-\t\t\t  cp_error\n-\t\t\t    (\"field `%D' is not a member of structure `%T'\",\n-\t\t\t     sname, ctype);\n+\t\t\tcp_error\n+\t\t\t  (\"field `%D' is not a member of structure `%T'\",\n+\t\t\t   sname, ctype);\n \t\t      }\n \n \t\t    if (current_class_type)\n@@ -8283,28 +8375,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n \t\tdeclarator = sname;\n \t      }\n-\t    else if (TREE_CODE (sname) == TYPE_EXPR)\n-\t      {\n-\t\t/* A TYPE_EXPR will change types out from under us.\n-\t\t   So do the TYPE_EXPR now, and make this SCOPE_REF\n-\t\t   inner to the TYPE_EXPR's CALL_EXPR.\n-\n-\t\t   This does not work if we don't get a CALL_EXPR back.\n-\t\t   I did not think about error recovery, hence the\n-\t\t   my_friendly_abort.  */\n-\n-\t\t/* Get the CALL_EXPR.  */\n-\t\tsname = grokoptypename (sname, 0);\n-\t\tmy_friendly_assert (TREE_CODE (sname) == CALL_EXPR, 157);\n-\t\ttype = TREE_TYPE (TREE_OPERAND (sname, 0));\n-\t\t/* Scope the CALL_EXPR's name.  */\n-\t\tTREE_OPERAND (declarator, 1) = TREE_OPERAND (sname, 0);\n-\t\t/* Put the SCOPE_EXPR in the CALL_EXPR's innermost position.  */\n-\t\tTREE_OPERAND (sname, 0) = declarator;\n-\t\t/* Now work from the CALL_EXPR.  */\n-\t\tdeclarator = sname;\n-\t\tcontinue;\n-\t      }\n \t    else if (TREE_CODE (sname) == SCOPE_REF)\n \t      my_friendly_abort (17);\n \t    else\n@@ -8329,21 +8399,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  declarator = TREE_OPERAND (declarator, 0);\n \t  break;\n \n-\tcase TYPE_EXPR:\n-\t  declarator = grokoptypename (declarator, 0);\n-\t  if (explicit_int != -1)\n-\t    {\n-\t      tree stype = TREE_TYPE (TREE_OPERAND (declarator, 0));\n-\t      if (comp_target_types (type, stype, 1) == 0)\n-\t\tcp_error (\"`operator %T' declared to return `%T'\", stype,\n-\t\t\t  type);\n-\t      else\n-\t\tcp_pedwarn (\"return type specified for `operator %T'\", type);\n-\t    }\n-\t  dname = declarator;\n-\t  type = TREE_TYPE (TREE_OPERAND (declarator, 0));\n-\t  break;\n-\n \tcase RECORD_TYPE:\n \tcase UNION_TYPE:\n \tcase ENUMERAL_TYPE:\n@@ -8667,6 +8722,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t\t   && ! funcdef_flag\n \t\t\t   && RIDBIT_NOTSETP (RID_STATIC, specbits)\n \t\t\t   && RIDBIT_NOTSETP (RID_INLINE, specbits)));\n+\t    if (TREE_CODE (type) == METHOD_TYPE)\n+\t      publicp \n+\t\t|= (ctype && CLASSTYPE_INTERFACE_KNOWN (ctype))\n+\t\t  || (!funcdef_flag && RIDBIT_NOTSETP (RID_INLINE, specbits));\n \t    decl = grokfndecl (ctype, type, declarator,\n \t\t\t       virtualp, flags, quals,\n \t\t\t       raises, friendp ? -1 : 0, publicp);\n@@ -8843,8 +8902,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t   into some other file, so we don't clear TREE_PUBLIC for them.  */\n \tpublicp\n \t  = ((ctype\n-\t      && CLASSTYPE_INTERFACE_KNOWN (ctype)\n-\t      && ! CLASSTYPE_INTERFACE_ONLY (ctype))\n+\t      && CLASSTYPE_INTERFACE_KNOWN (ctype))\n \t     || !(RIDBIT_SETP (RID_STATIC, specbits)\n \t\t  || RIDBIT_SETP (RID_INLINE, specbits)));\n \n@@ -10212,7 +10270,7 @@ build_enumerator (name, value)\n   if (value)\n     STRIP_TYPE_NOPS (value);\n \n-  /* Make up for hacks in cp-lex.c.  */\n+  /* Make up for hacks in lex.c.  */\n   if (value == integer_zero_node)\n     value = build_int_2 (0, 0);\n   else if (value == integer_one_node)\n@@ -10573,7 +10631,9 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n   else if (pre_parsed_p == 0)\n     {\n       current_function_decl = pushdecl (decl1);\n-      if (TREE_CODE (current_function_decl) == TREE_LIST)\n+      if (TREE_CODE (current_function_decl) == TREE_LIST\n+\t  || (DECL_ASSEMBLER_NAME (current_function_decl)\n+\t      != DECL_ASSEMBLER_NAME (decl1)))\n \t{\n \t  /* @@ revert to modified original declaration.  */\n \t  decl1 = DECL_MAIN_VARIANT (decl1);"}, {"sha": "c752e2303f827b484411882aa4dd6ac0e4cf8461", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 160, "deletions": 101, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -58,7 +58,7 @@ static int temp_name_counter;\n    can have the same name.  */\n static int global_temp_name_counter;\n \n-/* Flag used when debugging cp-spew.c */\n+/* Flag used when debugging spew.c */\n \n extern int spew_debug;\n \f\n@@ -129,6 +129,10 @@ int warn_implicit = 1;\n \n int warn_ctor_dtor_privacy = 1;\n \n+/* True if we want output of vtables to be controlled by whether\n+   we seen the class's first non-inline virtual function. */\n+int flag_vtable_hack = 0;\n+\n /* Nonzero means give string constants the type `const char *'\n    to get extra warnings from them.  These warnings will be too numerous\n    to be useful, except in thoroughly ANSIfied programs.  */\n@@ -360,6 +364,7 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"ansi-overloading\", &flag_ansi_overloading, 1},\n   {\"huge-objects\", &flag_huge_objects, 1},\n   {\"conserve-space\", &flag_conserve_space, 1},\n+  {\"vtable-hack\", &flag_vtable_hack, 1},\n };\n \n /* Decode the string P as a language-specific option.\n@@ -1619,107 +1624,12 @@ groktypefield (declspecs, parmlist)\n   return decl;\n }\n \n-/* The precedence rules of this grammar (or any other deterministic LALR\n-   grammar, for that matter), place the CALL_EXPR somewhere where we\n-   may not want it.  The solution is to grab the first CALL_EXPR we see,\n-   pretend that that is the one that belongs to the parameter list of\n-   the type conversion function, and leave everything else alone.\n-   We pull it out in place.\n-\n-   CALL_REQUIRED is non-zero if we should complain if a CALL_EXPR\n-   does not appear in DECL.  */\n tree\n-grokoptypename (decl, call_required)\n-     tree decl;\n-     int call_required;\n+grokoptypename (declspecs, declarator)\n+     tree declspecs, declarator;\n {\n-  tree tmp, last;\n-\n-  my_friendly_assert (TREE_CODE (decl) == TYPE_EXPR, 195);\n-\n-  tmp = TREE_OPERAND (decl, 0);\n-  last = NULL_TREE;\n-\n-  while (tmp)\n-    {\n-      switch (TREE_CODE (tmp))\n-\t{\n-\tcase CALL_EXPR:\n-\t  {\n-\t    tree parms = TREE_OPERAND (tmp, 1);\n-\n-\t    if (last)\n-\t      TREE_OPERAND (last, 0) = TREE_OPERAND (tmp, 0);\n-\t    else\n-\t      TREE_OPERAND (decl, 0) = TREE_OPERAND (tmp, 0);\n-\n-\t    last = grokdeclarator (TREE_OPERAND (decl, 0),\n-\t\t\t\t   TREE_TYPE (decl),\n-\t\t\t\t   TYPENAME, 0, NULL_TREE);\n-\t    TREE_OPERAND (tmp, 0) = build_typename_overload (last);\n-\t    TREE_TYPE (TREE_OPERAND (tmp, 0)) = last;\n-\n-\t    if (parms\n-\t\t&& TREE_CODE (TREE_VALUE (parms)) == TREE_LIST)\n-\t      TREE_VALUE (parms)\n-\t\t= grokdeclarator (TREE_VALUE (TREE_VALUE (parms)),\n-\t\t\t\t  TREE_PURPOSE (TREE_VALUE (parms)),\n-\t\t\t\t  TYPENAME, 0, NULL_TREE);\n-\t    if (parms)\n-\t      {\n-\t\tif (TREE_VALUE (parms) != void_type_node)\n-\t\t  cp_error (\"`operator %T' requires empty parameter list\",\n-\t\t\t    last);\n-\t\telse\n-\t\t  /* Canonicalize parameter lists.  */\n-\t\t  TREE_OPERAND (tmp, 1) = void_list_node;\n-\t      }\n-\n-\t    return tmp;\n-\t  }\n-\n-\tcase INDIRECT_REF:\n-\tcase ADDR_EXPR:\n-\tcase ARRAY_REF:\n-\t  break;\n-\n-\tcase SCOPE_REF:\n-\t  /* This is legal when declaring a conversion to\n-\t     something of type pointer-to-member.  */\n-\t  if (TREE_CODE (TREE_OPERAND (tmp, 1)) == INDIRECT_REF)\n-\t    {\n-\t      tmp = TREE_OPERAND (tmp, 1);\n-\t    }\n-\t  else\n-\t    {\n-#if 0\n-\t      /* We may need to do this if grokdeclarator cannot handle this.  */\n-\t      error (\"type `member of class %s' invalid return type\",\n-\t\t     TYPE_NAME_STRING (TREE_OPERAND (tmp, 0)));\n-\t      TREE_OPERAND (tmp, 1) = build_parse_node (INDIRECT_REF, TREE_OPERAND (tmp, 1));\n-#endif\n-\t      tmp = TREE_OPERAND (tmp, 1);\n-\t    }\n-\t  break;\n-\n-\tdefault:\n-\t  my_friendly_abort (196);\n-\t}\n-      last = tmp;\n-      tmp = TREE_OPERAND (tmp, 0);\n-    }\n-\n-  last = grokdeclarator (TREE_OPERAND (decl, 0),\n-\t\t\t TREE_TYPE (decl),\n-\t\t\t TYPENAME, 0, NULL_TREE);\n-\n-  if (call_required)\n-    cp_error (\"`operator %T' construct requires parameter list\", last);\n-\n-  tmp = build_parse_node (CALL_EXPR, build_typename_overload (last),\n-\t\t\t  void_list_node, NULL_TREE);\n-  TREE_TYPE (TREE_OPERAND (tmp, 0)) = last;\n-  return tmp;\n+  tree t = grokdeclarator (declarator, declspecs, TYPENAME, 0, NULL_TREE);\n+  return build_typename_overload (t);\n }\n \n /* When a function is declared with an initializer,\n@@ -2420,6 +2330,22 @@ static void\n finish_vtable_vardecl (prev, vars)\n      tree prev, vars;\n {\n+  tree ctype = DECL_CONTEXT (vars);\n+  if (flag_vtable_hack && !CLASSTYPE_INTERFACE_KNOWN (ctype))\n+    {\n+      tree method;\n+      for (method = CLASSTYPE_METHODS (ctype); method != NULL_TREE;\n+\t   method = DECL_NEXT_METHOD (method))\n+\t{\n+\t  if (DECL_VINDEX (method) != NULL_TREE && !DECL_SAVED_INSNS (method))\n+\t    {\n+\t      TREE_PUBLIC (vars) = 1;\n+\t      DECL_EXTERNAL (vars) = DECL_EXTERNAL (method);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n   if (write_virtuals >= 0\n       && ! DECL_EXTERNAL (vars) && (TREE_PUBLIC (vars) || TREE_USED (vars)))\n     {\n@@ -2468,6 +2394,8 @@ finish_vtable_vardecl (prev, vars)\n \n       rest_of_decl_compilation (vars, 0, 1, 1);\n     }\n+  else if (TREE_USED (vars) && flag_vtable_hack)\n+    assemble_external (vars);\n   /* We know that PREV must be non-zero here.  */\n   TREE_CHAIN (prev) = TREE_CHAIN (vars);\n }\n@@ -2783,7 +2711,7 @@ finish_file ()\n      There are several ways of getting the same effect, from changing the\n      way that iterators over the chain treat the elements that pertain to\n      virtual function tables, moving the implementation of this code to\n-     cp-decl.c (where we can manipulate global_binding_level directly),\n+     decl.c (where we can manipulate global_binding_level directly),\n      popping the garbage after pushing it and slicing away the vtable\n      stuff, or just leaving it alone. */\n \n@@ -2821,3 +2749,134 @@ finish_file ()\n   if (flag_detailed_statistics)\n     dump_time_statistics ();\n }\n+\n+/* This is something of the form 'A()()()()()+1' that has turned out to be an\n+   expr.  Since it was parsed like a type, we need to wade through and fix\n+   that.  Unfortunately, since operator() is left-associative, we can't use\n+   tail recursion.  In the above example, TYPE is `A', and DECL is\n+   `()()()()()'.\n+\n+   Maybe this shouldn't be recursive, but how often will it actually be\n+   used?  (jason) */\n+tree\n+reparse_absdcl_as_expr (type, decl)\n+     tree type, decl;\n+{\n+  /* do build_functional_cast (type, NULL_TREE) at bottom */\n+  if (TREE_OPERAND (decl, 0) == NULL_TREE)\n+    return build_functional_cast (type, NULL_TREE);\n+\n+  /* recurse */\n+  decl = reparse_decl_as_expr (type, TREE_OPERAND (decl, 0));\n+\n+  decl = build_x_function_call (decl, NULL_TREE, current_class_decl);\n+\n+  if (TREE_CODE (decl) == CALL_EXPR && TREE_TYPE (decl) != void_type_node)\n+    decl = require_complete_type (decl);\n+\n+  return decl;\n+}\n+\n+/* This is something of the form `int ((int)(int)(int)1)' that has turned\n+   out to be an expr.  Since it was parsed like a type, we need to wade\n+   through and fix that.  Since casts are right-associative, we are\n+   reversing the order, so we don't have to recurse.\n+\n+   In the above example, DECL is the `(int)(int)(int)', and EXPR is the\n+   `1'.  */\n+tree\n+reparse_absdcl_as_casts (decl, expr)\n+     tree decl, expr;\n+{\n+  tree type;\n+  \n+  if (TREE_CODE (expr) == CONSTRUCTOR)\n+    {\n+      type = groktypename (TREE_VALUE (TREE_OPERAND (decl, 1)));\n+      decl = TREE_OPERAND (decl, 0);\n+\n+      if (IS_SIGNATURE (type))\n+\t{\n+\t  error (\"cast specifies signature type\");\n+\t  return error_mark_node;\n+\t}\n+\n+      expr = digest_init (type, expr, (tree *) 0);\n+      if (TREE_CODE (type) == ARRAY_TYPE && TYPE_SIZE (type) == 0)\n+\t{\n+\t  int failure = complete_array_type (type, expr, 1);\n+\t  if (failure)\n+\t    my_friendly_abort (78);\n+\t}\n+    }\n+\n+  while (decl)\n+    {\n+      type = groktypename (TREE_VALUE (TREE_OPERAND (decl, 1)));\n+      decl = TREE_OPERAND (decl, 0);\n+      expr = build_c_cast (type, expr);\n+    }\n+\n+  return expr;\n+}\n+\n+/* Recursive helper function for reparse_decl_as_expr.  It may be a good\n+   idea to reimplement this using an explicit stack, rather than recursion. */\n+static tree\n+reparse_decl_as_expr1 (decl)\n+     tree decl;\n+{\n+  switch (TREE_CODE (decl))\n+    {\n+    case IDENTIFIER_NODE:\n+      return do_identifier (decl);\n+    case INDIRECT_REF:\n+      return build_x_indirect_ref\n+\t(reparse_decl_as_expr1 (TREE_OPERAND (decl, 0)), \"unary *\");\n+    case ADDR_EXPR:\n+      return build_x_unary_op (ADDR_EXPR,\n+\t\t\t       reparse_decl_as_expr1 (TREE_OPERAND (decl, 0)));\n+    case BIT_NOT_EXPR:\n+      return build_x_unary_op (BIT_NOT_EXPR,\n+\t\t\t       reparse_decl_as_expr1 (TREE_OPERAND (decl, 0)));\n+    }\n+  my_friendly_abort (5);\n+}\n+\n+/* This is something of the form `int (*a)++' that has turned out to be an\n+   expr.  It was only converted into parse nodes, so we need to go through\n+   and build up the semantics.  Most of the work is done by\n+   reparse_decl_as_expr1, above.\n+\n+   In the above example, TYPE is `int' and DECL is `*a'.  */\n+tree\n+reparse_decl_as_expr (type, decl)\n+     tree type, decl;\n+{\n+  decl = build_tree_list (NULL_TREE, reparse_decl_as_expr1 (decl));\n+  return build_functional_cast (type, decl);\n+}\n+\n+/* This is something of the form `int (*a)' that has turned out to be a\n+   decl.  It was only converted into parse nodes, so we need to do the\n+   checking that make_{pointer,reference}_declarator do. */\n+\n+tree\n+finish_decl_parsing (decl)\n+     tree decl;\n+{\n+  switch (TREE_CODE (decl))\n+    {\n+    case IDENTIFIER_NODE:\n+      return decl;\n+    case INDIRECT_REF:\n+      return make_pointer_declarator\n+\t(NULL_TREE, finish_decl_parsing (TREE_OPERAND (decl, 0)));\n+    case ADDR_EXPR:\n+      return make_reference_declarator\n+\t(NULL_TREE, finish_decl_parsing (TREE_OPERAND (decl, 0)));\n+    case BIT_NOT_EXPR:\n+      TREE_OPERAND (decl, 0) = finish_decl_parsing (TREE_OPERAND (decl, 0));\n+      return decl;\n+    }\n+}"}, {"sha": "335a304798aa37df2a4d12140ffdef15ca673df8", "filename": "gcc/cp/errfn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Ferrfn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Ferrfn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferrfn.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -25,7 +25,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* cp_printer is the type of a function which converts an argument into\n    a string for digestion by printf.  The cp_printer function should deal\n    with all memory management; the functions in this file will not free\n-   the char*s returned.  See cp-error.c for an example use of this code.  */\n+   the char*s returned.  See error.c for an example use of this code.  */\n \n typedef char* cp_printer PROTO((HOST_WIDE_INT, int));\n extern cp_printer * cp_printers[256];"}, {"sha": "3cc3ce8e05e47fc930ec74264ce1b206c5c28121", "filename": "gcc/cp/error.c", "status": "modified", "additions": 89, "deletions": 42, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -76,6 +76,7 @@ static char *scratch_firstobj;\n # define OB_FINISH() (obstack_1grow (&scratch_obstack, '\\0'))\n # define OB_PUTI(CST) do { sprintf (digit_buffer, \"%d\", (CST)); \\\n \t\t\t   OB_PUTCP (digit_buffer); } while (0)\n+# define OB_UNPUT(N) obstack_blank (&scratch_obstack, - (N));\n \n # define NEXT_CODE(t) (TREE_CODE (TREE_TYPE (t)))\n \n@@ -131,11 +132,11 @@ dump_type (t, v)\n   switch (TREE_CODE (t))\n     {\n     case ERROR_MARK:\n-      OB_PUTS (\"<error>\");\n+      OB_PUTS (\"{error}\");\n       break;\n \n     case UNKNOWN_TYPE:\n-      OB_PUTS (\"<unknown type>\");\n+      OB_PUTS (\"{unknown type}\");\n       break;\n \n     case TREE_LIST:\n@@ -206,9 +207,7 @@ dump_type (t, v)\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n-      OB_PUTS (\"<template type parm \");\n       OB_PUTID (TYPE_IDENTIFIER (t));\n-      OB_PUTC ('>');\n       break;\n \n     case UNINSTANTIATED_P_TYPE:\n@@ -230,30 +229,35 @@ dump_type (t, v)\n       break;\n \n     default:\n-      my_friendly_abort (68);\n-      \n+      sorry (\"`%s' not supported by dump_type\",\n+\t     tree_code_name[(int) TREE_CODE (t)]);\n     }\n }\n \n-/* Print out a class declaration, in the form `class foo'. */\n-static void\n-dump_aggr_type (t, v)\n+static char *\n+aggr_variety (t)\n      tree t;\n-     int v;\t\t\t/* verbose? */\n {\n-  tree name;\n-  char *variety;\n-\n   if (TREE_CODE (t) == ENUMERAL_TYPE)\n-    variety = \"enum\";\n+    return \"enum\";\n   else if (TREE_CODE (t) == UNION_TYPE)\n-    variety = \"union\";\n+    return \"union\";\n   else if (TYPE_LANG_SPECIFIC (t) && CLASSTYPE_DECLARED_CLASS (t))\n-    variety = \"class\";\n+    return \"class\";\n   else if (TYPE_LANG_SPECIFIC (t) && IS_SIGNATURE (t))\n-    variety = \"signature\";\n+    return \"signature\";\n   else\n-    variety = \"struct\";\n+    return \"struct\";\n+}\n+\n+/* Print out a class declaration, in the form `class foo'. */\n+static void\n+dump_aggr_type (t, v)\n+     tree t;\n+     int v;\t\t\t/* verbose? */\n+{\n+  tree name;\n+  char *variety = aggr_variety (t);\n \n   dump_readonly_or_volatile (t, after);\n \n@@ -278,13 +282,13 @@ dump_aggr_type (t, v)\n \n   if (ANON_AGGRNAME_P (name))\n     {\n-      OB_PUTS (\"<anonymous\");\n+      OB_PUTS (\"{anonymous\");\n       if (!v)\n \t{\n \t  OB_PUTC (' ');\n \t  OB_PUTCP (variety);\n \t}\n-      OB_PUTC ('>');\n+      OB_PUTC ('}');\n     }\n   else\n     OB_PUTID (name);\n@@ -369,13 +373,12 @@ dump_type_prefix (t, v)\n     case OFFSET_TYPE:\n     offset_type:\n       dump_type_prefix (TREE_TYPE (t), v);\n-      if (NEXT_CODE (t) != FUNCTION_TYPE && NEXT_CODE (t) != METHOD_TYPE)\n-\tOB_PUTC (' ');\n-      if (TREE_CODE (t) == OFFSET_TYPE)\n-\tdump_type (TYPE_OFFSET_BASETYPE (t), 0);\n-      else\t\t\t/* pointer to member function */\n-\tdump_type (TYPE_METHOD_BASETYPE (TREE_TYPE (t)), 0);\n-      OB_PUTC2 (':', ':');\n+      if (TREE_CODE (t) == OFFSET_TYPE)\t/* pmfs deal with this in d_t_p */\n+\t{\n+\t  OB_PUTC (' ');\n+\t  dump_type (TYPE_OFFSET_BASETYPE (t), 0);\n+\t  OB_PUTC2 (':', ':');\n+\t}\n       OB_PUTC ('*');\n       dump_readonly_or_volatile (t, none);\n       break;\n@@ -416,7 +419,8 @@ dump_type_prefix (t, v)\n       break;\n       \n     default:\n-      my_friendly_abort (65);\n+      sorry (\"`%s' not supported by dump_type_prefix\",\n+\t     tree_code_name[(int) TREE_CODE (t)]);\n     }\n }\n \n@@ -483,7 +487,8 @@ dump_type_suffix (t, v)\n       break;\n \n     default:\n-      my_friendly_abort (67);\n+      sorry (\"`%s' not supported by dump_type_suffix\",\n+\t     tree_code_name[(int) TREE_CODE (t)]);\n     }\n }\n \n@@ -576,7 +581,7 @@ dump_decl (t, v)\n       if (DECL_NAME (t))\n \tdump_decl (DECL_NAME (t), v);\n       else\n-\tOB_PUTS (\"<anon>\");\n+\tOB_PUTS (\"{anon}\");\n       if (v > 0) dump_type_suffix (TREE_TYPE (t), v);\n       break;\n \n@@ -636,16 +641,41 @@ dump_decl (t, v)\n       break;\n \n     case TEMPLATE_DECL:\n-      switch (NEXT_CODE (t))\n-\t{\n-\tcase METHOD_TYPE:\n-\tcase FUNCTION_TYPE:\n-\t  dump_function_decl (t, v);\n-\t  break;\n+      {\n+\ttree args = DECL_TEMPLATE_PARMS (t);\n+\tint i, len = TREE_VEC_LENGTH (args);\n+\tOB_PUTS (\"template <\");\n+\tfor (i = 0; i < len; i++)\n+\t  {\n+\t    tree arg = TREE_VEC_ELT (args, i);\n+\t    if (TREE_CODE (arg) == IDENTIFIER_NODE)\n+\t      {\n+\t\tOB_PUTS (\"class \");\n+\t\tOB_PUTID (arg);\n+\t      }\n+\t    else\n+\t      dump_decl (arg, 1);\n+\t    OB_PUTC2 (',', ' ');\n+\t  }\n+\tOB_UNPUT (2);\n+\tOB_PUTC2 ('>', ' ');\n \n-\tdefault:\n-\t  my_friendly_abort (353);\n-\t}\n+\tif (DECL_TEMPLATE_IS_CLASS (t))\n+\t  {\n+\t    OB_PUTS (\"class \");\n+\t    OB_PUTID (DECL_NAME (t));\n+\t  }\n+\telse switch (NEXT_CODE (t))\n+\t  {\n+\t  case METHOD_TYPE:\n+\t  case FUNCTION_TYPE:\n+\t    dump_function_decl (t, v);\n+\t    break;\n+\n+\t  default:\n+\t    my_friendly_abort (353);\n+\t  }\n+      }\n       break;\n \n     case LABEL_DECL:\n@@ -667,7 +697,8 @@ dump_decl (t, v)\n       break;\n \n     default:\n-      my_friendly_abort (70);\n+      sorry (\"`%s' not supported by dump_decl\",\n+\t     tree_code_name[(int) TREE_CODE (t)]);\n     }\n }\n \n@@ -1157,6 +1188,22 @@ dump_expr (t, nop)\n       OB_PUTC ('}');\n       break;\n \n+    case OFFSET_REF:\n+      {\n+\ttree ob = TREE_OPERAND (t, 0);\n+\tif (TREE_CODE (ob) == NOP_EXPR\n+\t    && TREE_OPERAND (ob, 0) == error_mark_node\n+\t    && TREE_CODE (TREE_OPERAND (t, 1)) == FUNCTION_DECL)\n+\t    /* A::f */\n+\t  dump_expr (TREE_OPERAND (t, 1), 0);\n+\telse\n+\t  {\n+\t    sorry (\"operand of OFFSET_REF not understood\");\n+\t    goto error;\n+\t  }\n+\tbreak;\n+      }\n+\n       /*  This list is incomplete, but should suffice for now.\n \t  It is very important that `sorry' does not call\n \t  `report_error_function'.  That could cause an infinite loop.  */\n@@ -1167,7 +1214,7 @@ dump_expr (t, nop)\n       /* fall through to ERROR_MARK...  */\n     case ERROR_MARK:\n     error:\n-      OB_PUTCP (\"/* error */\");\n+      OB_PUTCP (\"{error}\");\n       break;\n     }\n }\n@@ -1321,7 +1368,7 @@ op_as_string (p, v)\n   static char buf[] = \"operator                \";\n \n   if (p == 0)\n-    return \"<unknown>\";\n+    return \"{unknown}\";\n   \n   strcpy (buf + 9, opname_tab [p]);\n   return buf;"}, {"sha": "d0fe130add8575070e04e02d4f0b63f21b202244", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -349,7 +349,7 @@ void\n finish_exception_decl (cname, decl)\n      tree cname, decl;\n {\n-  /* In cp-decl.h.  */\n+  /* In decl.h.  */\n   extern tree last_function_parms;\n \n   /* An exception declaration.  */"}, {"sha": "1878c86a5142074430a9663f0d06441955ed0bf8", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 114, "deletions": 9, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -22,6 +22,8 @@ Questions and comments to mrs@@cygnus.com.\n * Templates::                   \n * Access Control::              \n * Error Reporting::             \n+* Parser::                      \n+* Copying Objects::             \n * Concept Index::               \n @end menu\n \n@@ -77,19 +79,19 @@ An example would be:\n \n @example\n extern \"C\" int printf(const char*, ...);\n-struct A { virtual void f() { } };\n-struct B : virtual A { int b; B() : b(0) {} void f() { b++; } };\n-struct C : B {};\n-struct D : B {};\n-struct E : C, D {};\n+struct A @{ virtual void f() @{ @} @};\n+struct B : virtual A @{ int b; B() : b(0) @{@} void f() @{ b++; @} @};\n+struct C : B @{@};\n+struct D : B @{@};\n+struct E : C, D @{@};\n int main()\n-{\n+@{\n   E e;\n   C& c = e; D& d = e;\n   c.f(); d.f();\n   printf (\"C::b = %d, D::b = %d\\n\", e.C::b, e.D::b);\n   return 0;\n-}\n+@}\n @end example\n \n This will print out 2, 0, instead of 1,1.\n@@ -984,7 +986,7 @@ TREE_PROTECTED and TREE_PRIVATE are used to record the access levels\n granted by the containing class.  BEWARE: TREE_PUBLIC means something\n completely unrelated to access control!\n \n-@node Error Reporting, Concept Index, Access Control, Top\n+@node Error Reporting, Parser, Access Control, Top\n @section Error Reporting\n \n The C++ frontend uses a call-back mechanism to allow functions to print\n@@ -1022,7 +1024,110 @@ To have the line number on the error message indicate the line of the\n DECL, use @code{cp_error_at} and its ilk; to indicate which argument you want,\n use @code{%+D}, or it will default to the first.\n \n-@node Concept Index,  , Error Reporting, Top\n+@node Parser, Copying Objects, Error Reporting, Top\n+@section Parser\n+\n+Some comments on the parser:\n+\n+The @code{after_type_declarator} / @code{notype_declarator} hack is\n+necessary in order to allow redeclarations of @code{TYPENAME}s, for\n+instance\n+\n+@example\n+typedef int foo;\n+class A @{\n+  char *foo;\n+@};\n+@end example\n+\n+In the above, the first @code{foo} is parsed as a @code{notype_declarator},\n+and the second as a @code{after_type_declarator}.\n+\n+Ambiguities:\n+\n+There are currently four reduce/reduce ambiguities in the parser.  They are:\n+\n+1) Between @code{template_parm} and\n+@code{named_class_head_sans_basetype}, for the tokens @code{aggr\n+identifier}.  This situation occurs in code looking like\n+\n+@example\n+template <class T> class A @{ @};\n+@end example\n+\n+It is ambiguous whether @code{class T} should be parsed as the\n+declaration of a template type parameter named @code{T} or an unnamed\n+constant parameter of type @code{class T}.  Section 14.6, paragraph 3 of\n+the January '94 working paper states that the first interpretation is\n+the correct one.  This ambiguity results in four reduce/reduce conflicts.\n+\n+2) Between @code{primary} and @code{typename} for code like @samp{int()}\n+in places where both can be accepted, such as the argument to\n+@code{sizeof}.  Section 8.1 of the pre-San Diego working paper specifies\n+that these ambiguous constructs will be interpreted as @code{typename}s.\n+This ambiguity results in six reduce/reduce conflicts.\n+\n+3) Between @code{primary}/@code{functional_cast} and\n+@code{expr_or_declarator}/@code{complex_direct_notype_declarator}, for\n+various token strings.  This situation occurs in code looking like\n+\n+@example\n+int (*a);\n+@end example\n+\n+This code is ambiguous; it could be a declaration of the variable\n+@samp{a} as a pointer to @samp{int}, or it could be a functional cast of\n+@samp{*a} to @samp{int}.  Section 6.8 specifies that the former\n+interpretation is correct.  This ambiguity results in 12 reduce/reduce\n+conflicts.  Ack.\n+\n+4) Between @code{after_type_declarator} and @code{parm}, for the token\n+@code{TYPENAME}.  This occurs in (as one example) code like\n+\n+@example\n+typedef int foo, bar;\n+class A @{\n+  foo (bar);\n+@};\n+@end example\n+\n+What is @code{bar} inside the class definition?  We currently interpret\n+it as a @code{parm}, as does Cfront, but IBM xlC interprets it as an\n+@code{after_type_declarator}.  I suspect that xlC is correct, in light\n+of 7.1p2, which says \"The longest sequence of @i{decl-specifiers} that\n+could possibly be a type name is taken as the @i{decl-specifier-seq} of\n+a @i{declaration}.\"  However, it seems clear that this rule must be\n+violated in the case of constructors, so...\n+\n+Unlike the others, this ambiguity is not recognized by the Working Paper.\n+\n+@node  Copying Objects, Concept Index, Parser, Top\n+@section Copying Objects\n+\n+The generated copy assignment operator in g++ does not currently do the\n+right thing for multiple inheritance involving virtual bases; it just\n+calls the copy assignment operators for its direct bases.  What it\n+should probably do is:\n+\n+1) Split up the copy assignment operator for all classes that have\n+vbases into \"copy my vbases\" and \"copy everything else\" parts.  Or do\n+the trickiness that the constructors do to ensure that vbases don't get\n+initialized by intermediate bases.\n+\n+2) Wander through the class lattice, find all vbases for which no\n+intermediate base has a user-defined copy assignment operator, and call\n+their \"copy everything else\" routines.  If not all of my vbases satisfy\n+this criterion, warn, because this may be surprising behavior.\n+\n+3) Call the \"copy everything else\" routine for my direct bases.\n+\n+If we only have one direct base, we can just foist everything off onto\n+them.\n+\n+This issue is currently under discussion in the core reflector\n+(2/28/94).\n+\n+@node Concept Index,  , Copying Objects, Top\n @section Concept Index\n \n @printindex cp"}, {"sha": "eeb5de65a2110da92305bfe482fcccee80133ad7", "filename": "gcc/cp/init.c", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -1872,7 +1872,7 @@ get_type_value (name)\n }\n   \n \f\n-/* This code could just as well go in `cp-class.c', but is placed here for\n+/* This code could just as well go in `class.c', but is placed here for\n    modularity.  */\n \n /* For an expression of the form CNAME :: NAME (PARMLIST), build\n@@ -1992,7 +1992,7 @@ build_member_call (cname, name, parmlist)\n    @@ Prints out lousy diagnostics for operator <typename>\n    @@ fields.\n \n-   @@ This function should be rewritten and placed in cp-search.c.  */\n+   @@ This function should be rewritten and placed in search.c.  */\n tree\n build_offset_ref (cname, name)\n      tree cname, name;\n@@ -2024,12 +2024,8 @@ build_offset_ref (cname, name)\n \t\t      name);\n \t  return error_mark_node;\n \t}\n-      if (TREE_CODE (t) == TYPE_DECL)\n-\t{\n-\t  cp_error (\"member `%D' is just a type declaration\", t);\n-\t  return error_mark_node;\n-\t}\n-      if (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == CONST_DECL)\n+      if (TREE_CODE (t) == TYPE_DECL || TREE_CODE (t) == VAR_DECL\n+\t  || TREE_CODE (t) == CONST_DECL)\n \t{\n \t  TREE_USED (t) = 1;\n \t  return t;\n@@ -2170,8 +2166,8 @@ build_offset_ref (cname, name)\n \n   if (TREE_CODE (t) == TYPE_DECL)\n     {\n-      cp_error (\"member `%D' is just a type declaration\", t);\n-      return error_mark_node;\n+      TREE_USED (t) = 1;\n+      return t;\n     }\n   /* static class members and class-specific enum\n      values can be returned without further ado.  */\n@@ -3036,6 +3032,13 @@ build_new (placement, decl, init, use_global_new)\n \t  /* probably meant to be a vec new */\n \t  tree this_nelts;\n \n+\t  while (TREE_OPERAND (absdcl, 0)\n+\t\t && TREE_CODE (TREE_OPERAND (absdcl, 0)) == ARRAY_REF)\n+\t    {\n+\t      last_absdcl = absdcl;\n+\t      absdcl = TREE_OPERAND (absdcl, 0);\n+\t    }\n+\n \t  has_array = 1;\n \t  this_nelts = TREE_OPERAND (absdcl, 1);\n \t  if (this_nelts != error_mark_node)\n@@ -3369,6 +3372,12 @@ build_new (placement, decl, init, use_global_new)\n \t}\n     }\n  done:\n+  if (rval && TREE_TYPE (rval) != build_pointer_type (type))\n+    {\n+      /* The type of new int [3][3] is not int *, but int [3] * */\n+      rval = build_c_cast (build_pointer_type (type), rval);\n+    }\n+\n   if (pending_sizes)\n     rval = build_compound_expr (chainon (pending_sizes,\n \t\t\t\t\t build_tree_list (NULL_TREE, rval)));"}, {"sha": "1570489fc2a6cbd82f1f4f58ed3b98d848da3e71", "filename": "gcc/cp/input.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finput.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -25,7 +25,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    the GNU library available, so FILE objects just don't cut it.\n \n    This file is written as a separate module, but can be included by\n-   cp-lex.c for very minor efficiency gains (primarily in function\n+   lex.c for very minor efficiency gains (primarily in function\n    inlining).  */\n \n #include <stdio.h>\n@@ -97,7 +97,7 @@ free_input (inp)\n static int putback_char = -1;\n \n /* Some of these external functions are declared inline in case this file\n-   is included in cp-lex.c.  */\n+   is included in lex.c.  */\n \n inline\n void"}, {"sha": "8f7c2bea92a10055d66562cc4cbc6af53bd9c622", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 48, "deletions": 15, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -313,7 +313,7 @@ my_get_run_time ()\n \f\n /* Table indexed by tree code giving a string containing a character\n    classifying the tree code.  Possibilities are\n-   t, d, s, c, r, <, 1 and 2.  See cp-tree.def for details.  */\n+   t, d, s, c, r, <, 1 and 2.  See cp/tree.def for details.  */\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n@@ -1036,7 +1036,7 @@ extract_interface_info ()\n     interface_unknown = TREE_INT_CST_HIGH (fileinfo);\n }\n \n-/* Return nonzero if S and T are not considered part of an\n+/* Return nonzero if S is not considered part of an\n    INTERFACE/IMPLEMENTATION pair.  Otherwise, return 0.  */\n static int\n interface_strcmp (s)\n@@ -1046,8 +1046,6 @@ interface_strcmp (s)\n   struct impl_files *ifiles;\n   char *s1;\n \n-  s = FILE_NAME_NONDIRECTORY (s);\n-\n   for (ifiles = impl_file_chain; ifiles; ifiles = ifiles->next)\n     {\n       char *t1 = ifiles->filename;\n@@ -1087,7 +1085,7 @@ set_typedecl_interface_info (prev, vars)\n   tree type = TREE_TYPE (vars);\n \n   CLASSTYPE_INTERFACE_ONLY (type) = TREE_INT_CST_LOW (fileinfo)\n-    = interface_strcmp (DECL_SOURCE_FILE (vars));\n+    = interface_strcmp (FILE_NAME_NONDIRECTORY (DECL_SOURCE_FILE (vars)));\n }\n \n void\n@@ -1109,7 +1107,7 @@ set_vardecl_interface_info (prev, vars)\n \f\n /* Called from the top level: if there are any pending inlines to\n    do, set up to process them now.  This function sets up the first function\n-   to be parsed; after it has been, the rule for fndef in cp-parse.y will\n+   to be parsed; after it has been, the rule for fndef in parse.y will\n    call process_next_inline to start working on the next one.  */\n void\n do_pending_inlines ()\n@@ -2432,19 +2430,39 @@ check_newline ()\n \t\t      && getch () == 'e'\n \t\t      && ((c = getch ()) == ' ' || c == '\\t' || c == '\\n'))\n \t\t    {\n-\t\t      int warned_interface = 0;\n+\t\t      int warned_already = 0;\n+\t\t      char *main_filename = input_filename;\n \n-\t\t      /* Read to newline.  */\n+\t\t      main_filename = FILE_NAME_NONDIRECTORY (main_filename);\n+\t\t      while (c == ' ' || c == '\\t')\n+\t\t\tc = getch ();\n+\t\t      if (c != '\\n')\n+\t\t\t{\n+\t\t\t  put_back (c);\n+\t\t\t  token = real_yylex ();\n+\t\t\t  if (token != STRING\n+\t\t\t      || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t\t\t    {\n+\t\t\t      error (\"invalid `#pragma interface'\");\n+\t\t\t      goto skipline;\n+\t\t\t    }\n+\t\t\t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n+\t\t\t  c = getch();\n+\t\t\t  put_back (c);\n+\t\t\t}\n+\n+\t\t      while (c == ' ' || c == '\\t')\n+\t\t\tc = getch ();\n \n \t\t      while (c != '\\n')\n \t\t\t{\n-\t\t\t  c = getch ();\n-\t\t\t  if (!warned_interface && extra_warnings\n+\t\t\t  if (!warned_already && extra_warnings\n \t\t\t      && c != ' ' && c != '\\t' && c != '\\n')\n \t\t\t    {\n \t\t\t      warning (\"garbage after `#pragma interface' ignored\");\n-\t\t\t      warned_interface = 1;\n+\t\t\t      warned_already = 1;\n \t\t\t    }\n+\t\t\t  c = getch ();\n \t\t\t}\n \n \t\t      write_virtuals = 3;\n@@ -2459,6 +2477,7 @@ check_newline ()\n \t\t\t  if (main_input_filename == 0)\n \t\t\t    main_input_filename = input_filename;\n \n+#ifdef AUTO_IMPLEMENT\n \t\t\t  filename = FILE_NAME_NONDIRECTORY (main_input_filename);\n \t\t\t  fi = get_time_identifier (filename);\n \t\t\t  fi = IDENTIFIER_CLASS_VALUE (fi);\n@@ -2468,9 +2487,10 @@ check_newline ()\n \t\t\t  impl_file_chain = (struct impl_files *)permalloc (sizeof (struct impl_files));\n \t\t\t  impl_file_chain->filename = filename;\n \t\t\t  impl_file_chain->next = 0;\n+#endif\n \t\t\t}\n \n-\t\t      interface_only = interface_strcmp (input_filename);\n+\t\t      interface_only = interface_strcmp (main_filename);\n \t\t      interface_unknown = 0;\n \t\t      TREE_INT_CST_LOW (fileinfo) = interface_only;\n \t\t      TREE_INT_CST_HIGH (fileinfo) = interface_unknown;\n@@ -2490,8 +2510,10 @@ check_newline ()\n \t\t\t   && getch () == 'n'\n \t\t\t   && ((c = getch ()) == ' ' || c == '\\t' || c == '\\n'))\n \t\t    {\n+\t\t      int warned_already = 0;\n \t\t      char *main_filename = main_input_filename ? main_input_filename : input_filename;\n \n+\t\t      main_filename = FILE_NAME_NONDIRECTORY (main_filename);\n \t\t      while (c == ' ' || c == '\\t')\n \t\t\tc = getch ();\n \t\t      if (c != '\\n')\n@@ -2505,13 +2527,24 @@ check_newline ()\n \t\t\t      goto skipline;\n \t\t\t    }\n \t\t\t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n+\t\t\t  c = getch();\n+\t\t\t  put_back (c);\n \t\t\t}\n-\t\t      main_filename = FILE_NAME_NONDIRECTORY (main_filename);\n \n-\t\t      /* read to newline.  */\n-\t\t      while (c != '\\n')\n+\t\t      while (c == ' ' || c == '\\t')\n \t\t\tc = getch ();\n \n+\t\t      while (c != '\\n')\n+\t\t\t{\n+\t\t\t  if (!warned_already && extra_warnings\n+\t\t\t      && c != ' ' && c != '\\t' && c != '\\n')\n+\t\t\t    {\n+\t\t\t      warning (\"garbage after `#pragma implementation' ignored\");\n+\t\t\t      warned_already = 1;\n+\t\t\t    }\n+\t\t\t  c = getch ();\n+\t\t\t}\n+\n \t\t      if (write_virtuals == 3)\n \t\t\t{\n \t\t\t  struct impl_files *ifiles = impl_file_chain;"}, {"sha": "457fa39502ddc5226bbd0ed39b0fbf3c73036437", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -1,4 +1,4 @@\n-/* Define constants and variables for communication with cp-parse.y.\n+/* Define constants and variables for communication with parse.y.\n    Copyright (C) 1987, 1992, 1993 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n    and by Brendan Kehoe (brendan@cygnus.com)."}, {"sha": "03450659777b97fbf5802351f52cec625c1e1996", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -929,6 +929,8 @@ build_typename_overload (type)\n   build_overload_name (type, 0, 1);\n   id = get_identifier (obstack_base (&scratch_obstack));\n   IDENTIFIER_OPNAME_P (id) = 1;\n+  IDENTIFIER_GLOBAL_VALUE (id) = TYPE_NAME (type);\n+  TREE_TYPE (id) = type;\n   return id;\n }\n "}, {"sha": "70026d345f761496fdbaf24b3cbef156ea015044", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 641, "deletions": 387, "changes": 1028, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -177,7 +177,7 @@ empty_parms ()\n %nonassoc IF\n %nonassoc ELSE\n \n-%left IDENTIFIER TYPENAME PTYPENAME TYPENAME_COLON SCSPEC TYPESPEC TYPE_QUAL ENUM AGGR ELLIPSIS\n+%left IDENTIFIER TYPENAME PTYPENAME TYPENAME_COLON SCSPEC TYPESPEC TYPE_QUAL ENUM AGGR ELLIPSIS SCOPED_TYPENAME TYPEOF SIGOF START_DECLARATOR OPERATOR\n \n %left '{' ',' ';'\n \n@@ -194,10 +194,11 @@ empty_parms ()\n %left <code> LSHIFT RSHIFT\n %left <code> '+' '-'\n %left <code> '*' '/' '%'\n-%right <code> UNARY PLUSPLUS MINUSMINUS\n+%left <code> POINTSAT_STAR DOT_STAR\n+%right <code> UNARY PLUSPLUS MINUSMINUS '~'\n %left HYPERUNARY\n %left <ttype> PAREN_STAR_PAREN LEFT_RIGHT\n-%left <code> POINTSAT POINTSAT_STAR '.' DOT_STAR '(' '['\n+%left <code> POINTSAT '.' '(' '['\n \n %right SCOPE\t\t\t/* C++ extension */\n %nonassoc NEW DELETE RAISE RAISES RERAISE TRY EXCEPT CATCH THROW\n@@ -206,7 +207,7 @@ empty_parms ()\n %type <code> unop\n \n %type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist\n-%type <ttype> optional_identifier paren_expr_or_null\n+%type <ttype> optional_identifier paren_expr_or_null nontrivial_exprlist\n %type <ttype> expr_no_commas cast_expr unary_expr primary string STRING\n %type <ttype> typed_declspecs reserved_declspecs\n %type <ttype> typed_typespecs reserved_typespecquals\n@@ -216,18 +217,29 @@ empty_parms ()\n %type <ttype> init initlist maybeasm\n %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n %type <ttype> maybe_attribute attribute_list attrib\n-%type <ttype> abs_member_declarator after_type_member_declarator\n \n %type <ttype> compstmt except_stmts ansi_except_stmts implicitly_scoped_stmt\n \n %type <ttype> declarator notype_declarator after_type_declarator\n+%type <ttype> notype_declarator1 after_type_declarator1\n+%type <ttype> direct_notype_declarator direct_after_type_declarator\n \n %type <ttype> structsp opt.component_decl_list component_decl_list\n %type <ttype> component_decl components component_declarator\n+%type <ttype> notype_components notype_component_declarator\n+%type <ttype> after_type_component_declarator after_type_component_declarator0\n+%type <ttype> notype_component_declarator0\n %type <ttype> enumlist enumerator\n-%type <ttype> typename absdcl absdcl1 type_quals abs_or_notype_decl\n-%type <ttype> xexpr see_typename parmlist parms parm bad_parm\n+%type <ttype> type_id absdcl absdcl1 type_quals\n+%type <ttype> direct_abstract_declarator conversion_declarator\n+%type <ttype> new_type_id new_declarator direct_new_declarator\n+%type <ttype> xexpr parmlist parms parm bad_parm\n %type <ttype> identifiers_or_typenames\n+%type <ttype> fcast_or_absdcl regcast_or_absdcl sub_cast_expr\n+%type <ttype> expr_or_declarator complex_notype_declarator1\n+%type <ttype> notype_unqualified_id\n+%type <ttype> complex_direct_notype_declarator functional_cast\n+%type <ttype> named_parm complex_parmlist typed_declspecs1 parms_comma\n \n /* C++ extensions */\n %type <ttype> typename_scope\n@@ -242,11 +254,10 @@ empty_parms ()\n %type <ttype> class_head base_class_list\n %type <itype> base_class_access_list\n %type <ttype> base_class maybe_base_class_list base_class.1\n-%type <ttype> after_type_declarator_no_typename\n %type <ttype> maybe_raises raise_identifier raise_identifiers ansi_raise_identifier ansi_raise_identifiers\n %type <ttype> component_declarator0 id_scope scoped_typename scoped_base_class\n %type <ttype> forhead.1 identifier_or_opname operator_name\n-%type <ttype> new delete object object_star aggr\n+%type <ttype> new delete object aggr\n /* %type <ttype> primary_no_id */\n %type <ttype> nonmomentary_expr\n %type <itype> forhead.2 initdcl0 notype_initdcl0 member_init_list\n@@ -267,7 +278,7 @@ empty_parms ()\n \n %type <strtype> .pushlevel\n \n-/* cp-spew.c depends on this being the last token.  Define\n+/* spew.c depends on this being the last token.  Define\n    any new tokens before this one!  */\n %token END_OF_SAVED_INPUT\n \f\n@@ -373,8 +384,9 @@ template_parm_list:\n \n template_parm:\n \t/* The following rules introduce a new reduce/reduce\n-\t   conflict: they are valid prefixes for a `structsp',\n-\t   which means they could match a nameless parameter.\n+\t   conflict on the ',' and '>' input tokens: they are valid\n+\t   prefixes for a `structsp', which means they could match a\n+\t   nameless parameter.  See 14.6, paragraph 3.\n \t   By putting them before the `parm' rule, we get\n \t   their match before considering them nameless parameter\n \t   declarations.  */\n@@ -440,19 +452,19 @@ template_def:\n \t\t    sorry (\"template type defining a signature\");\n \t\t  /* Maybe pedantic warning for union?\n \t\t     How about an enum? :-)  */\n-\t\t  end_template_decl ($1, $2, current_aggr);\n+\t\t  end_template_decl ($1, $2, current_aggr, 1);\n \t\t  reinit_parse_for_template (yychar, $1, $2);\n \t\t  yychar = YYEMPTY;\n \t\t}\n \t  ';'\n \t| template_header named_class_head_sans_basetype ';'\n \t\t{\n-\t\t  end_template_decl ($1, $2, current_aggr);\n+\t\t  end_template_decl ($1, $2, current_aggr, 0);\n \t\t  /* declare $2 as template name with $1 parm list */\n \t\t}\n \t| template_header named_class_head_sans_basetype_defn ';'\n \t\t{\n-\t\t  end_template_decl ($1, $2, current_aggr);\n+\t\t  end_template_decl ($1, $2, current_aggr, 0);\n \t\t  /* declare $2 as template name with $1 parm list */\n \t\t}\n \t| template_header /* notype_initdcl0 ';' */\n@@ -461,12 +473,14 @@ template_def:\n \t\t{\n \t\t  tree d;\n \t\t  int momentary;\n+\t\t  int def = ($6 != ';');\n \t\t  momentary = suspend_momentary ();\n-\t\t  d = start_decl ($<ttype>2, /*current_declspecs*/NULL_TREE, 0, $3);\n+\t\t  d = start_decl ($<ttype>2, /*current_declspecs*/NULL_TREE, 0,\n+\t\t\t\t  $3);\n \t\t  cplus_decl_attributes (d, $5);\n \t\t  finish_decl (d, NULL_TREE, $4, 0);\n-\t\t  end_template_decl ($1, d, 0);\n-\t\t  if ($6 != ';')\n+\t\t  end_template_decl ($1, d, 0, def);\n+\t\t  if (def)\n \t\t    reinit_parse_for_template ((int) $6, $1, d);\n \t\t  resume_momentary (momentary);\n \t\t}\n@@ -476,6 +490,7 @@ template_def:\n \t\t{\n \t\t  tree d;\n \t\t  int momentary;\n+\t\t  int def = ($7 != ';');\n \n \t\t  current_declspecs = $2;\n \t\t  momentary = suspend_momentary ();\n@@ -484,26 +499,27 @@ template_def:\n \t\t  cplus_decl_attributes (d, $6);\n \t\t  finish_decl (d, NULL_TREE, $5, 0);\n \t\t  end_exception_decls ();\n-\t\t  end_template_decl ($1, d, 0);\n-\t\t  if ($7 != ';')\n+\t\t  end_template_decl ($1, d, 0, def);\n+\t\t  if (def)\n \t\t    {\n \t\t      reinit_parse_for_template ((int) $7, $1, d);\n \t\t      yychar = YYEMPTY;\n \t\t    }\n \t\t  note_list_got_semicolon ($<ttype>2);\n \t\t  resume_momentary (momentary);\n \t\t}\n-\t| template_header declmods declarator fn_tmpl_end\n+\t| template_header declmods notype_declarator fn_tmpl_end\n \t\t{\n+\t\t  int def = ($4 != ';');\n \t\t  tree d = start_decl ($<ttype>3, $<ttype>2, 0, NULL_TREE);\n \t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0);\n-\t\t  end_template_decl ($1, d, 0);\n-\t\t  if ($4 != ';')\n+\t\t  end_template_decl ($1, d, 0, def);\n+\t\t  if (def)\n \t\t    reinit_parse_for_template ((int) $4, $1, d);\n \t\t}\n \t/* Try to recover from syntax errors in templates.  */\n-\t| template_header error '}'\t{ end_template_decl ($1, 0, 0); }\n-\t| template_header error ';'\t{ end_template_decl ($1, 0, 0); }\n+\t| template_header error '}'\t{ end_template_decl ($1, 0, 0, 0); }\n+\t| template_header error ';'\t{ end_template_decl ($1, 0, 0, 0); }\n \t;\n \n fn_tmpl_end: '{'\t\t{ $$ = '{'; }\n@@ -521,8 +537,8 @@ datadef:\n   \t\t    warning (\"data definition has no type or storage class\"); }\n \t| declmods notype_initdecls ';'\n \t\t{}\n-\t/* Normal case to make fast: \"int i;\".  */\n-\t| declmods declarator ';'\n+\t/* Normal case to make fast: \"const i;\".  */\n+\t| declmods notype_declarator ';'\n \t\t{ tree d;\n \t\t  d = start_decl ($<ttype>2, $<ttype>$, 0, NULL_TREE);\n \t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0);\n@@ -660,7 +676,8 @@ fn.def1:\n \t\t  reinit_parse_for_function (); }\n \t;\n \n-/* more C++ complexity */\n+/* more C++ complexity.  See component_decl for a comment on the\n+   reduce/reduce conflict introduced by these rules.  */\n fn.def2:\n \t  typed_declspecs '(' parmlist ')' type_quals maybe_raises\n \t\t{\n@@ -705,7 +722,7 @@ fn.def2:\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX;\n \t\t  reinit_parse_for_method (yychar, $$); }\n-\t| declmods declarator maybe_raises\n+\t| declmods notype_declarator maybe_raises\n \t\t{ $$ = start_method ($$, $2, $3);\n \t\t  if (! $$)\n \t\t    YYERROR1;\n@@ -907,7 +924,7 @@ template_arg_list:\n \t;\n \n template_arg:\n-\t  typename\n+\t  type_id\n \t\t{ $$ = groktypename ($$); }\n \t| expr_no_commas  %prec UNARY\n \t;\n@@ -986,9 +1003,8 @@ unop:     '-'\n \t\t{ $$ = TRUTH_NOT_EXPR; }\n \t;\n \n-expr:\t  nonnull_exprlist\n+expr:\t  nontrivial_exprlist\n \t\t{ $$ = build_x_compound_expr ($$); }\n-\t/* Ugly, but faster.  */\n \t| expr_no_commas\n \t;\n \n@@ -1097,13 +1113,23 @@ already_scoped_stmt:\n \t| simple_stmt\n \t;\n \n+nontrivial_exprlist:\n+\t  expr_no_commas ',' expr_no_commas\n+\t\t{ $$ = tree_cons (NULL_TREE, $$, \n+\t\t                  build_tree_list (NULL_TREE, $3)); }\n+\t| expr_no_commas ',' error\n+\t\t{ $$ = tree_cons (NULL_TREE, $$, \n+\t\t                  build_tree_list (NULL_TREE, error_mark_node)); }\n+\t| nontrivial_exprlist ',' expr_no_commas\n+\t\t{ chainon ($$, build_tree_list (NULL_TREE, $3)); }\n+\t| nontrivial_exprlist ',' error\n+\t\t{ chainon ($$, build_tree_list (NULL_TREE, error_mark_node)); }\n+\t;\n+\n nonnull_exprlist:\n \t  expr_no_commas\n \t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n-\t| nonnull_exprlist ',' expr_no_commas\n-\t\t{ chainon ($$, build_tree_list (NULL_TREE, $3)); }\n-\t| nonnull_exprlist ',' error\n-\t\t{ chainon ($$, build_tree_list (NULL_TREE, error_mark_node)); }\n+\t| nontrivial_exprlist\n \t;\n \n unary_expr:\n@@ -1123,7 +1149,7 @@ unary_expr:\n \t\t{ $$ = build_x_indirect_ref ($2, \"unary *\"); }\n \t| '&' cast_expr   %prec UNARY\n \t\t{ $$ = build_x_unary_op (ADDR_EXPR, $2); }\n-\t| '~' cast_expr   %prec UNARY\n+\t| '~' cast_expr\n \t\t{ $$ = build_x_unary_op (BIT_NOT_EXPR, $2); }\n \t| unop cast_expr  %prec UNARY\n \t\t{ $$ = build_x_unary_op ((enum tree_code) $$, $2);\n@@ -1163,16 +1189,16 @@ unary_expr:\n \t\t\tpedwarn (\"ANSI C++ forbids using sizeof() on a function\");\n \t\t    }\n \t\t  $$ = c_sizeof (TREE_TYPE ($2)); }\n-\t| SIZEOF '(' typename ')'  %prec HYPERUNARY\n+\t| SIZEOF '(' type_id ')'  %prec HYPERUNARY\n \t\t{ $$ = c_sizeof (groktypename ($3)); }\n \t| ALIGNOF unary_expr  %prec UNARY\n \t\t{ $$ = grok_alignof ($2); }\n-\t| ALIGNOF '(' typename ')'  %prec HYPERUNARY\n+\t| ALIGNOF '(' type_id ')'  %prec HYPERUNARY\n \t\t{ $$ = c_alignof (groktypename ($3)); }\n \n-\t| .scope new typename %prec '='\n+\t| .scope new new_type_id %prec '='\n \t\t{ $$ = build_new ($2, $3, NULL_TREE, $$ != NULL_TREE); }\n-\t| .scope new '(' nonnull_exprlist ')' typename %prec '='\n+\t| .scope new '(' nonnull_exprlist ')' new_type_id %prec '='\n \t\t{ $$ = build_new ($4, $6, NULL_TREE, $$ != NULL_TREE); }\n \t| .scope new typespec '(' nonnull_exprlist ')'\n \t\t{ $$ = build_new ($2, $3, $5, $$ != NULL_TREE); }\n@@ -1185,37 +1211,24 @@ unary_expr:\n \t\t{ $$ = build_new ($2, $3, NULL_TREE, $$ != NULL_TREE); }\n \t| .scope new '(' nonnull_exprlist ')' typespec LEFT_RIGHT\n \t\t{ $$ = build_new ($4, $6, NULL_TREE, $$ != NULL_TREE); }\n-\t| .scope new typename '=' init %prec '='\n+\t| .scope new new_type_id '=' init %prec '='\n \t\t{ $$ = build_new ($2, $3, $5, $$ != NULL_TREE); }\n-\t| .scope new '(' nonnull_exprlist ')' typename '=' init %prec '='\n+\t| .scope new '(' nonnull_exprlist ')' new_type_id '=' init %prec '='\n \t\t{ $$ = build_new ($4, $6, $8, $$ != NULL_TREE); }\n-\n-\t/* I am not going to add placement syntax to the below complex rules\n-\t   because Ken says the syntax is illegal. (mrs) */\n-\t/* I'm not sure why this is disallowed.  But since it is, and it\n-\t   doesn't seem difficult to catch it, let's give a message, so\n-\t   the programmer can fix it.  --Ken Raeburn  */\n-\t| .scope new '(' typed_typespecs absdcl ')' '[' nonmomentary_expr ']'\n-\t\t{\n+\t/* If you don't understand why this is illegal, read 5.3.4. (jason) */\n+\t| .scope new '(' type_id ')' '[' nonmomentary_expr ']'\n+\t\t{ \n \t\t  tree absdcl, typename;\n \n-\t\tillegal_new_array:\n-\t\t  absdcl = build_parse_node (ARRAY_REF, $5, $8);\n-\t\t  typename = build_decl_list ($4, absdcl);\n+\t\t  absdcl = build_parse_node (ARRAY_REF, TREE_VALUE ($4), $7);\n+\t\t  typename = build_decl_list (TREE_PURPOSE ($4), absdcl);\n \t\t  pedwarn (\"ANSI C++ forbids array dimensions with parenthesized type\");\n \t\t  $$ = build_new ($2, typename, NULL_TREE, $$ != NULL_TREE);\n \t\t}\n-\t| .scope new '(' nonempty_type_quals absdcl ')' '[' nonmomentary_expr ']'\n-\t\t{ goto illegal_new_array; }\n-\n-\t| .scope new '(' typed_typespecs absdcl ')'\n-\t\t{ $$ = build_new ($2, build_decl_list ($4, $5), NULL_TREE, $$ != NULL_TREE); }\n-\t| .scope new '(' nonnull_exprlist ')' '(' typed_typespecs absdcl ')'\n-\t\t{ $$ = build_new ($4, build_decl_list ($7, $8), NULL_TREE, $$ != NULL_TREE); }\n-\t| .scope new '(' nonempty_type_quals absdcl ')'\n-\t\t{ $$ = build_new ($2, build_decl_list ($4, $5), NULL_TREE, $$ != NULL_TREE); }\n-\t| .scope new '(' nonnull_exprlist ')' '(' nonempty_type_quals absdcl ')'\n-\t\t{ $$ = build_new ($4, build_decl_list ($7, $8), NULL_TREE, $$ != NULL_TREE); }\n+\t| .scope new '(' type_id ')'\n+\t\t{ $$ = build_new ($2, $4, NULL_TREE, $$ != NULL_TREE); }\n+\t| .scope new '(' nonnull_exprlist ')' '(' type_id ')'\n+\t\t{ $$ = build_new ($4, $7, NULL_TREE, $$ != NULL_TREE); }\n \t/* Unswallow a ':' which is probably meant for ?: expression.  */\n \t| .scope new TYPENAME_COLON\n \t\t{ yyungetc (':', 1); $$ = build_new ($2, $3, NULL_TREE, $$ != NULL_TREE); }\n@@ -1234,37 +1247,38 @@ unary_expr:\n \t\t    yychar = YYLEX; }\n \t;\n \n+/* This is necessary to postpone reduction of `int ((int)(int)(int))'.  */\n+regcast_or_absdcl:\n+\t  '(' type_id ')' %prec EMPTY\n+\t\t{ $2 = tree_cons (NULL_TREE, $2, void_list_node);\n+\t\t  TREE_PARMLIST ($2) = 1;\n+\t\t  $$ = build_parse_node (CALL_EXPR, NULL_TREE, $2, \n+\t\t\t\t\t NULL_TREE); }\n+\t| regcast_or_absdcl '(' type_id ')' %prec EMPTY\n+\t\t{ $3 = tree_cons (NULL_TREE, $3, void_list_node);\n+\t\t  TREE_PARMLIST ($3) = 1;\n+\t\t  $$ = build_parse_node (CALL_EXPR, $$, $3, NULL_TREE); }\n+\t;\n+\n cast_expr:\n-\t  unary_expr\n-\t| '(' typename ')' expr_no_commas  %prec UNARY\n-\t\t{ tree type = groktypename ($2);\n-\t\t  $$ = build_c_cast (type, $4); }\n-\t| '(' typename ')' '{' initlist maybecomma '}'  %prec UNARY\n-\t\t{ tree type = groktypename ($2);\n+\t  sub_cast_expr\n+\t| regcast_or_absdcl sub_cast_expr  %prec UNARY\n+\t\t{ $$ = reparse_absdcl_as_casts ($$, $2); }\n+\t| regcast_or_absdcl '{' initlist maybecomma '}'  %prec UNARY\n+\t\t{ \n+\t\t  tree init = build_nt (CONSTRUCTOR, NULL_TREE,\n+\t\t\t\t\tnreverse ($3)); \n+\t\t  if (pedantic)\n+\t\t    pedwarn (\"ANSI C++ forbids constructor-expressions\");\n+\t\t  /* Indicate that this was a GNU C constructor expression.  */\n+\t\t  TREE_HAS_CONSTRUCTOR (init) = 1;\n \n-\t\t  if (IS_SIGNATURE (type))\n-\t\t    {\n-\t\t      error (\"cast specifies signature type\");\n-\t\t      $$ = error_mark_node;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      tree init;\n-\t\t      init = build_nt (CONSTRUCTOR, NULL_TREE, nreverse ($5));\n-\t\t      if (pedantic)\n-\t\t\tpedwarn (\"ANSI C++ forbids constructor-expressions\");\n-\t\t      /* Indicate that this was a GNU C constructor expression.  */\n-\t\t      TREE_HAS_CONSTRUCTOR (init) = 1;\n-\t\t      $$ = digest_init (type, init, (tree *) 0);\n-\t\t      if (TREE_CODE (type) == ARRAY_TYPE\n-\t\t\t  && TYPE_SIZE (type) == 0)\n-\t\t\t{\n-\t\t\t  int failure = complete_array_type (type, $$, 1);\n-\t\t\t  if (failure)\n-\t\t\t    my_friendly_abort (78);\n-\t\t\t}\n-\t\t    }\n+\t\t  $$ = reparse_absdcl_as_casts ($$, init);\n \t\t}\n+\t;\n+\n+sub_cast_expr:\n+\t  unary_expr\n \t| HEADOF '(' expr ')'\n \t\t{ $$ = build_headof ($3); }\n \t| CLASSOF '(' expr ')'\n@@ -1288,6 +1302,11 @@ cast_expr:\n \n expr_no_commas:\n \t  cast_expr\n+\t/* Handle general members.  */\n+\t| expr_no_commas POINTSAT_STAR expr_no_commas\n+\t\t{ $$ = build_x_binary_op (MEMBER_REF, $$, $3); }\n+\t| expr_no_commas DOT_STAR expr_no_commas\n+\t\t{ $$ = build_m_component_ref ($$, $3); }\n \t| expr_no_commas '+' expr_no_commas\n \t\t{ $$ = build_x_binary_op ($2, $$, $3); }\n \t| expr_no_commas '-' expr_no_commas\n@@ -1333,36 +1352,59 @@ expr_no_commas:\n \t\t    $$ = rval;\n \t\t  else\n \t\t    $$ = build_modify_expr ($$, $2, $3); }\n-\t| primary DOT_STAR expr_no_commas %prec UNARY\n-\t\t{ $$ = build_m_component_ref ($$, $3); }\n-\t/* Handle general members.  */\n-\t| object_star expr_no_commas   %prec UNARY\n-\t\t{ $$ = build_x_binary_op (MEMBER_REF, $$, $2); }\n /* These extensions are not defined.  The second arg to build_m_component_ref\n    is old, build_m_component_ref now does an implicit\n    build_indirect_ref (x, NULL_PTR) on the second argument.\n \t| object '&' expr_no_commas   %prec UNARY\n \t\t{ $$ = build_m_component_ref ($$, build_x_unary_op (ADDR_EXPR, $3)); }\n \t| object unop expr_no_commas  %prec UNARY\n \t\t{ $$ = build_m_component_ref ($$, build_x_unary_op ($2, $3)); }\n-\t| object '(' typename ')' expr_no_commas  %prec UNARY\n+\t| object '(' type_id ')' expr_no_commas  %prec UNARY\n \t\t{ tree type = groktypename ($3);\n \t\t  $$ = build_m_component_ref ($$, build_c_cast (type, $5)); }\n \t| object primary_no_id  %prec UNARY\n \t\t{ $$ = build_m_component_ref ($$, $2); }\n */\n \t;\n \n-primary:\n-\tIDENTIFIER\n-\t\t{ $$ = do_identifier ($$); }\n+notype_unqualified_id:\n+\t  '~' see_typename TYPENAME\n+\t\t{\n+\t\tdestructor_name:\n+\t\t  $$ = build_parse_node (BIT_NOT_EXPR, $3);\n+\t\t}\n+\t| '~' see_typename IDENTIFIER\n+                { goto destructor_name; }\n+\t| '~' see_typename PTYPENAME\n+                { goto destructor_name; }\n \t| operator_name\n+\t| IDENTIFIER\n+\t| PTYPENAME %prec EMPTY\n+\t;\n+\n+expr_or_declarator:\n+\t  '*' expr_or_declarator %prec UNARY\n+\t\t{ $$ = build_parse_node (INDIRECT_REF, $2); }\n+\t| '&' expr_or_declarator %prec UNARY\n+\t\t{ $$ = build_parse_node (ADDR_EXPR, $2); }\n+\t| notype_unqualified_id\n+\t\t{ see_typename (); }\n+\t;\n+\n+direct_notype_declarator:\n+\t  complex_direct_notype_declarator\n+\t| notype_unqualified_id\n+\t\t{ see_typename (); }\n+\t;\n+\n+primary:\n+\t  notype_unqualified_id\n \t\t{\n-\t\t  tree op = $$;\n-\t\t  if (TREE_CODE (op) != IDENTIFIER_NODE)\n-\t\t    $$ = op;\n-\t\t  else\n+\t\t  if (TREE_CODE ($$) == BIT_NOT_EXPR)\n+\t\t    $$ = build_x_unary_op (BIT_NOT_EXPR, TREE_OPERAND ($$, 0));\n+\t\t  else if (IDENTIFIER_OPNAME_P ($$))\n \t\t    {\n+\t\t      tree op = $$;\n \t\t      $$ = lookup_name (op, 0);\n \t\t      if ($$ == NULL_TREE)\n \t\t\t{\n@@ -1372,7 +1414,9 @@ primary:\n \t\t\t  $$ = error_mark_node;\n \t\t\t}\n \t\t    }\n-\t\t}\n+\t\t  else\n+\t\t    $$ = do_identifier ($$);\n+\t\t}\t\t\n \t| CONSTANT\n \t| string\n \t\t{ $$ = combine_strings ($$); }\n@@ -1516,17 +1560,14 @@ primary:\n \t\t      $$ = build_c_cast (type, build_compound_expr ($3));\n \t\t    }\n \t\t}\n-\t| typespec '(' nonnull_exprlist ')'\n-\t\t{ $$ = build_functional_cast ($$, $3); }\n-\t| typespec LEFT_RIGHT\n-\t\t{ $$ = build_functional_cast ($$, NULL_TREE); }\n+\t| functional_cast\n \t/* Stroustrup RTTI */\n-\t| DYNAMIC_CAST '<' typename '>' '(' expr ')'\n+\t| DYNAMIC_CAST '<' type_id '>' '(' expr ')'\n \t\t{ tree type = groktypename ($3);\n \t\t  $$ = build_dynamic_cast (type, $6); }\n \t| TYPEID '(' expr ')'\n \t\t{ $$ = build_typeid ($3); }\n-\t| TYPEID '(' typename ')'\n+\t| TYPEID '(' type_id ')'\n \t\t{ tree type = groktypename ($3);\n \t\t  $$ = get_typeid (type); }\n \t| SCOPE typespec '(' nonnull_exprlist ')'\n@@ -1746,28 +1787,40 @@ object:\t  primary '.'\n \t\t}\n \t;\n \n-object_star: primary POINTSAT_STAR\n-\t;\n-\n decl:\n \t  typed_declspecs initdecls ';'\n \t\t{\n \t\t  resume_momentary ($2);\n-\t\t  note_list_got_semicolon ($<ttype>$);\n+\t\t  note_list_got_semicolon ($1);\n+\t\t}\n+\t| typespec initdecls ';'\n+\t\t{\n+\t\t  resume_momentary ($2);\n+\t\t  if (IS_AGGR_TYPE_CODE (TREE_CODE ($1)))\n+\t\t    note_got_semicolon ($1);\n \t\t}\n \t/* Normal case: make this fast.  */\n \t| typed_declspecs declarator ';'\n-\t\t{ tree d;\n+\t\t{ tree d = $1;\n \t\t  int yes = suspend_momentary ();\n-\t\t  d = start_decl ($<ttype>2, $<ttype>$, 0, NULL_TREE);\n+\t\t  d = start_decl ($2, d, 0, NULL_TREE);\n \t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0);\n \t\t  resume_momentary (yes);\n-\t\t  note_list_got_semicolon ($<ttype>$);\n+\t\t  note_list_got_semicolon ($1);\n+\t\t}\n+\t| typespec declarator ';'\n+\t\t{ tree d = get_decl_list ($1);\n+\t\t  int yes = suspend_momentary ();\n+\t\t  d = start_decl ($2, d, 0, NULL_TREE);\n+\t\t  finish_decl (d, NULL_TREE, NULL_TREE, 0);\n+\t\t  resume_momentary (yes);\n+\t\t  if (IS_AGGR_TYPE_CODE (TREE_CODE ($1)))\n+\t\t    note_got_semicolon ($1);\n \t\t}\n \t| declmods notype_initdecls ';'\n \t\t{ resume_momentary ((int) $<itype>2); }\n \t/* Normal case: make this fast.  */\n-\t| declmods declarator ';'\n+\t| declmods notype_declarator ';'\n \t\t{ tree d;\n \t\t  int yes = suspend_momentary ();\n \t\t  d = start_decl ($<ttype>2, $<ttype>$, 0, NULL_TREE);\n@@ -1787,34 +1840,58 @@ decl:\n    after an explicit typespec).  */\n \n declarator:\n-\t  after_type_declarator\n-\t| notype_declarator\n-\t| START_DECLARATOR after_type_declarator\n-\t\t{ $$ = $2; }\n-\t| START_DECLARATOR notype_declarator\n-\t\t{ $$ = $2; }\n+\t  after_type_declarator %prec EMPTY\n+\t| notype_declarator %prec EMPTY\n+\t;\n+\n+/* This is necessary to postpone reduction of `int()()()()'.  */\n+fcast_or_absdcl:\n+\t  LEFT_RIGHT %prec EMPTY\n+\t\t{ $$ = build_parse_node (CALL_EXPR, NULL_TREE, empty_parms (),\n+\t\t\t\t\t NULL_TREE); }\n+\t| fcast_or_absdcl LEFT_RIGHT %prec EMPTY\n+\t\t{ $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), \n+\t\t\t\t\t NULL_TREE); }\n+\t;\n+\n+/* ANSI type-id (8.1) */\n+type_id:\n+\t  typed_typespecs absdcl\n+\t\t{ $$ = build_decl_list ($$, $2); }\n+\t| nonempty_type_quals absdcl\n+\t\t{ $$ = build_decl_list ($$, $2); }\n+\t| typespec absdcl\n+\t\t{ $$ = build_decl_list (get_decl_list ($$), $2); }\n+\t| typed_typespecs %prec EMPTY\n+\t\t{ $$ = build_decl_list ($$, NULL_TREE); }\n+\t| nonempty_type_quals %prec EMPTY\n+\t\t{ $$ = build_decl_list ($$, NULL_TREE); }\n \t;\n \n /* Declspecs which contain at least one type specifier or typedef name.\n    (Just `const' or `volatile' is not enough.)\n    A typedef'd name following these is taken as a name to be declared.  */\n \n typed_declspecs:\n-\t  typespec\t%prec HYPERUNARY\n-\t\t{ if ($$) $$ = list_hash_lookup_or_cons ($$); }\n-\t| declmods typespec\n-\t\t{ $$ = hash_tree_chain ($2, $$); }\n+\t  typed_typespecs %prec EMPTY\n+\t| typed_declspecs1\n+\n+typed_declspecs1:\n+\t  declmods typespec\n+\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n \t| typespec reserved_declspecs\t%prec HYPERUNARY\n-\t\t{ $$ = hash_tree_chain ($$, $2); }\n+\t\t{ $$ = decl_tree_cons (NULL_TREE, $$, $2); }\n \t| declmods typespec reserved_declspecs\n-\t\t{ $$ = hash_tree_chain ($2, hash_chainon ($3, $$)); }\n+\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, chainon ($3, $$)); }\n+ \t| declmods typespec reserved_typespecquals\n+ \t\t{ $$ = decl_tree_cons (NULL_TREE, $2, chainon ($3, $$)); }\n+ \t| declmods typespec reserved_typespecquals reserved_declspecs\n+ \t\t{ $$ = decl_tree_cons (NULL_TREE, $2, \n+\t\t\t\t       chainon ($3, chainon ($4, $$))); }\n \t;\n \n-reserved_declspecs:  /* empty\n-\t\t{ $$ = NULL_TREE; } */\n-\t  typespecqual_reserved\n-\t\t{ $$ = build_decl_list (NULL_TREE, $$); }\n-\t| SCSPEC\n+reserved_declspecs:\n+\t  SCSPEC\n \t\t{ if (extra_warnings)\n \t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER ($$));\n@@ -1833,19 +1910,18 @@ reserved_declspecs:  /* empty\n    to redeclare a typedef-name.  */\n \n declmods:\n-\t  TYPE_QUAL\n-\t\t{ $$ = IDENTIFIER_AS_LIST ($$);\n-\t\t  TREE_STATIC ($$) = 1; }\n+\t  nonempty_type_quals %prec EMPTY\n+\t\t{ TREE_STATIC ($$) = 1; }\n \t| SCSPEC\n \t\t{ $$ = IDENTIFIER_AS_LIST ($$); }\n \t| declmods TYPE_QUAL\n-\t\t{ $$ = hash_tree_chain ($2, $$);\n+\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, $$);\n \t\t  TREE_STATIC ($$) = 1; }\n \t| declmods SCSPEC\n \t\t{ if (extra_warnings && TREE_STATIC ($$))\n \t\t    warning (\"`%s' is not at beginning of declaration\",\n \t\t\t     IDENTIFIER_POINTER ($2));\n-\t\t  $$ = hash_tree_chain ($2, $$);\n+\t\t  $$ = decl_tree_cons (NULL_TREE, $2, $$);\n \t\t  TREE_STATIC ($$) = TREE_STATIC ($1); }\n \t;\n \n@@ -1864,12 +1940,12 @@ typed_typespecs:\n \t| typespec reserved_typespecquals\n \t\t{ $$ = decl_tree_cons (NULL_TREE, $$, $2); }\n \t| nonempty_type_quals typespec reserved_typespecquals\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, hash_chainon ($3, $$)); }\n+\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, chainon ($3, $$)); }\n \t;\n \n reserved_typespecquals:\n \t  typespecqual_reserved\n-\t\t{ $$ = get_decl_list ($$); }\n+\t\t{ $$ = build_decl_list (NULL_TREE, $$); }\n \t| reserved_typespecquals typespecqual_reserved\n \t\t{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n \t;\n@@ -1881,12 +1957,26 @@ reserved_typespecquals:\n typespec: structsp\n \t| TYPESPEC  %prec EMPTY\n \t| TYPENAME  %prec EMPTY\n-\t| scoped_typename\n+\t| scoped_typename %prec EMPTY\n+\t| SCOPE TYPENAME %prec EMPTY\n+\t\t{ $$ = IDENTIFIER_GLOBAL_VALUE ($2);\n+                  if (!$$)\n+\t\t    {\n+                      error (\"undeclared variable `%s' (first use here)\",\n+                      IDENTIFIER_POINTER ($2));\n+                      $$ = error_mark_node;\n+                      IDENTIFIER_GLOBAL_VALUE ($2) = error_mark_node;\n+\t\t    }\n+\t\t  else \n+\t\t    {\n+\t\t      $$ = TREE_TYPE($$);\n+\t\t    }\n+\t\t}\n \t| TYPEOF '(' expr ')'\n \t\t{ $$ = TREE_TYPE ($3);\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids `typeof'\"); }\n-\t| TYPEOF '(' typename ')'\n+\t| TYPEOF '(' type_id ')'\n \t\t{ $$ = groktypename ($3);\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids `typeof'\"); }\n@@ -1904,7 +1994,7 @@ typespec: structsp\n \t\t      $$ = error_mark_node;\n \t\t    }\n \t\t}\n-\t| SIGOF '(' typename ')'\n+\t| SIGOF '(' type_id ')'\n \t\t{ tree type = groktypename ($3);\n \n \t\t  if (IS_AGGR_TYPE (type))\n@@ -1948,6 +2038,8 @@ maybeasm:\n initdcl0:\n \t  declarator maybe_raises maybeasm maybe_attribute '='\n \t\t{ current_declspecs = $<ttype>0;\n+\t\t  if (TREE_CODE (current_declspecs) != TREE_LIST)\n+\t\t    current_declspecs = get_decl_list (current_declspecs);\n \t\t  $<itype>5 = suspend_momentary ();\n \t\t  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1, $2);\n \t\t  cplus_decl_attributes ($<ttype>$, $4); }\n@@ -1958,6 +2050,8 @@ initdcl0:\n \t| declarator maybe_raises maybeasm maybe_attribute\n \t\t{ tree d;\n \t\t  current_declspecs = $<ttype>0;\n+\t\t  if (TREE_CODE (current_declspecs) != TREE_LIST)\n+\t\t    current_declspecs = get_decl_list (current_declspecs);\n \t\t  $$ = suspend_momentary ();\n \t\t  d = start_decl ($<ttype>1, current_declspecs, 0, $2);\n \t\t  cplus_decl_attributes (d, $4);\n@@ -2233,15 +2327,18 @@ named_class_head_sans_basetype:\n \t;\n \n named_class_head_sans_basetype_defn:\n-\t  aggr identifier_defn\n+\t  aggr identifier_defn %prec EMPTY\n \t\t{ current_aggr = $$; $$ = $2; }\n \t;\n \n+do_xref: /* empty */ %prec EMPTY\n+\t{ $<ttype>$ = xref_tag (current_aggr, $<ttype>0, NULL_TREE, 1); }\n+\n+do_xref_defn: /* empty */ %prec EMPTY\n+\t{ $<ttype>$ = xref_defn_tag (current_aggr, $<ttype>0, NULL_TREE); }\n+\n named_class_head:\n-\t  named_class_head_sans_basetype\n-\t\t{\n-\t\t  $<ttype>$ = xref_tag (current_aggr, $1, NULL_TREE, 1);\n-\t\t}\n+\t  named_class_head_sans_basetype do_xref\n \t  maybe_base_class_list %prec EMPTY\n \t\t{\n \t\t  if ($3)\n@@ -2250,10 +2347,7 @@ named_class_head:\n \t\t    $$ = $<ttype>2;\n \t\t}\n \t|\n-\t  named_class_head_sans_basetype_defn\n-\t\t{\n-\t\t  $<ttype>$ = xref_defn_tag (current_aggr, $1, NULL_TREE);\n-\t\t}\n+\t  named_class_head_sans_basetype_defn do_xref_defn\n \t  maybe_base_class_list %prec EMPTY\n \t\t{\n \t\t  if ($3)\n@@ -2398,7 +2492,7 @@ base_class.1:\n \t\t      $$ = error_mark_node;\n \t\t    }\n \t\t}\n-\t| SIGOF '(' typename ')'\n+\t| SIGOF '(' type_id ')'\n \t\t{\n \t\t  if (current_aggr == signature_type_node)\n \t\t    {\n@@ -2540,11 +2634,21 @@ component_decl_list:\n \t;\n \n component_decl:\n+\t/* Do not add a \"typed_declspecs declarator ';'\" rule here for\n+\t   speed; we need to call grok_x_components for enums, so the\n+\t   speedup would be insignificant.  */\n \t  typed_declspecs components ';'\n \t\t{\n \t\t  $$ = grok_x_components ($$, $2);\n \t\t  end_exception_decls ();\n \t\t}\n+\t/* These rules introduce a reduce/reduce conflict; in\n+\t\ttypedef int foo, bar;\n+\t\tclass A {\n+\t\t  foo (bar);\n+\t\t};\n+\t   should \"A::foo\" be declared as a function or data member?  \n+\t   In other words, is \"bar\" an after_type_declarator or a parmlist? */\n \t| typed_declspecs '(' parmlist ')' ';'\n \t\t{ $$ = groktypefield ($$, $3); }\n \t| typed_declspecs '(' parmlist ')' '}'\n@@ -2557,16 +2661,16 @@ component_decl:\n \t\t{ error (\"missing ';' before right brace\");\n \t\t  yyungetc ('}', 0);\n \t\t  $$ = groktypefield ($$, empty_parms ()); }\n-\t| declmods components ';'\n+\t| declmods notype_components ';'\n \t\t{ \n \t\t  $$ = grok_x_components ($$, $2);\n \t\t  end_exception_decls ();\n \t\t}\n \t/* Normal case: make this fast.  */\n-\t| declmods declarator ';'\n+\t| declmods notype_declarator ';'\n \t\t{ $$ = grokfield ($<ttype>2, $<ttype>$,\n \t\t\t\t  NULL_TREE, NULL_TREE, NULL_TREE); }\n-\t| declmods components '}'\n+\t| declmods notype_components '}'\n \t\t{ error (\"missing ';' before right brace\");\n \t\t  yyungetc ('}', 0);\n \t\t  $$ = grok_x_components ($$, $2);\n@@ -2607,6 +2711,7 @@ component_decl:\n \t\t  $$ = grokfield ($$, NULL_TREE, $2, NULL_TREE, NULL_TREE); }\n \t;\n \n+/* The case of exactly one component is handled directly by component_decl. */\n components:\n \t  /* empty: possibly anonymous */\n \t\t{ $$ = NULL_TREE; }\n@@ -2622,20 +2727,56 @@ components:\n \t\t}\n \t;\n \n+notype_components:\n+\t  /* empty: possibly anonymous */\n+\t\t{ $$ = NULL_TREE; }\n+\t| notype_component_declarator0\n+\t| notype_components ',' notype_component_declarator\n+\t\t{\n+\t\t  /* In this context, void_type_node encodes\n+\t\t     friends.  They have been recorded elsewhere.  */\n+\t\t  if ($$ == void_type_node)\n+\t\t    $$ = $3;\n+\t\t  else\n+\t\t    $$ = chainon ($$, $3);\n+\t\t}\n+\t;\n+\n component_declarator0:\n-\t  declarator maybe_raises maybeasm maybe_attribute\n+\t  after_type_component_declarator0\n+\t| notype_component_declarator0\n+\t;\n+\n+component_declarator:\n+\t  after_type_component_declarator\n+\t| notype_component_declarator\n+\t;\n+\n+after_type_component_declarator0:\n+\t  after_type_declarator maybe_raises maybeasm maybe_attribute\n \t\t{ current_declspecs = $<ttype>0;\n \t\t  $$ = grokfield ($$, current_declspecs, $2, NULL_TREE, $3);\n \t\t  cplus_decl_attributes ($$, $4); }\n-\t| declarator maybe_raises maybeasm maybe_attribute '=' init\n+\t| after_type_declarator maybe_raises maybeasm maybe_attribute '=' init\n \t\t{ current_declspecs = $<ttype>0;\n \t\t  $$ = grokfield ($$, current_declspecs, $2, $6, $3);\n \t\t  cplus_decl_attributes ($$, $4); }\n-\t| IDENTIFIER ':' expr_no_commas maybe_attribute\n+\t| TYPENAME ':' expr_no_commas maybe_attribute\n \t\t{ current_declspecs = $<ttype>0;\n \t\t  $$ = grokbitfield ($$, current_declspecs, $3);\n \t\t  cplus_decl_attributes ($$, $4); }\n-\t| TYPENAME ':' expr_no_commas maybe_attribute\n+\t;\n+\n+notype_component_declarator0:\n+\t  notype_declarator maybe_raises maybeasm maybe_attribute\n+\t\t{ current_declspecs = $<ttype>0;\n+\t\t  $$ = grokfield ($$, current_declspecs, $2, NULL_TREE, $3);\n+\t\t  cplus_decl_attributes ($$, $4); }\n+\t| notype_declarator maybe_raises maybeasm maybe_attribute '=' init\n+\t\t{ current_declspecs = $<ttype>0;\n+\t\t  $$ = grokfield ($$, current_declspecs, $2, $6, $3);\n+\t\t  cplus_decl_attributes ($$, $4); }\n+\t| IDENTIFIER ':' expr_no_commas maybe_attribute\n \t\t{ current_declspecs = $<ttype>0;\n \t\t  $$ = grokbitfield ($$, current_declspecs, $3);\n \t\t  cplus_decl_attributes ($$, $4); }\n@@ -2645,17 +2786,26 @@ component_declarator0:\n \t\t  cplus_decl_attributes ($$, $3); }\n \t;\n \n-component_declarator:\n-\t  declarator maybe_raises maybeasm maybe_attribute\n+after_type_component_declarator:\n+\t  after_type_declarator maybe_raises maybeasm maybe_attribute\n \t\t{ $$ = grokfield ($$, current_declspecs, $2, NULL_TREE, $3);\n \t\t  cplus_decl_attributes ($$, $4); }\n-\t| declarator maybe_raises maybeasm maybe_attribute '=' init\n+\t| after_type_declarator maybe_raises maybeasm maybe_attribute '=' init\n \t\t{ $$ = grokfield ($$, current_declspecs, $2, $6, $3);\n \t\t  cplus_decl_attributes ($$, $4); }\n-\t| IDENTIFIER ':' expr_no_commas maybe_attribute\n+\t| TYPENAME ':' expr_no_commas maybe_attribute\n \t\t{ $$ = grokbitfield ($$, current_declspecs, $3);\n \t\t  cplus_decl_attributes ($$, $4); }\n-\t| TYPENAME ':' expr_no_commas maybe_attribute\n+\t;\n+\n+notype_component_declarator:\n+\t  notype_declarator maybe_raises maybeasm maybe_attribute\n+\t\t{ $$ = grokfield ($$, current_declspecs, $2, NULL_TREE, $3);\n+\t\t  cplus_decl_attributes ($$, $4); }\n+\t| notype_declarator maybe_raises maybeasm maybe_attribute '=' init\n+\t\t{ $$ = grokfield ($$, current_declspecs, $2, $6, $3);\n+\t\t  cplus_decl_attributes ($$, $4); }\n+\t| IDENTIFIER ':' expr_no_commas maybe_attribute\n \t\t{ $$ = grokbitfield ($$, current_declspecs, $3);\n \t\t  cplus_decl_attributes ($$, $4); }\n \t| ':' expr_no_commas maybe_attribute\n@@ -2680,140 +2830,166 @@ enumerator:\n \t\t{ $$ = build_enumerator ($$, $3); }\n \t;\n \n-/* ANSI type-id (8.1) */\n-typename:\n-\t  typed_typespecs absdcl\n+/* ANSI new-type-id (5.3.4) */\n+new_type_id:\n+\t  typed_typespecs new_declarator\n \t\t{ $$ = build_decl_list ($$, $2); }\n-\t| nonempty_type_quals absdcl\n+\t| nonempty_type_quals new_declarator\n \t\t{ $$ = build_decl_list ($$, $2); }\n+\t| typed_typespecs %prec EMPTY\n+\t\t{ $$ = build_decl_list ($$, NULL_TREE); }\n+\t| nonempty_type_quals %prec EMPTY\n+\t\t{ $$ = build_decl_list ($$, NULL_TREE); }\n \t;\n \n /* ANSI abstract-declarator (8.1) */\n-absdcl:   /* an abstract declarator */\n-\t/* empty */ %prec EMPTY\n-\t\t{ $$ = NULL_TREE; }\n-\t| absdcl1  %prec EMPTY\n+absdcl:\n+\t  absdcl1  %prec EMPTY\n \t| START_DECLARATOR absdcl1  %prec EMPTY\n \t\t{ $$ = $2; }\n \t;\n \n+type_quals:\n+\t  /* empty */ %prec EMPTY\n+\t\t{ $$ = NULL_TREE; }\n+\t| type_quals TYPE_QUAL\n+\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n+\t;\n+\n nonempty_type_quals:\n \t  TYPE_QUAL\n \t\t{ $$ = IDENTIFIER_AS_LIST ($$); }\n \t| nonempty_type_quals TYPE_QUAL\n \t\t{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n \t;\n \n-type_quals:\n-\t  /* empty */\n-\t\t{ $$ = NULL_TREE; }\n-\t| type_quals TYPE_QUAL\n-\t\t{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n-\t;\n-\n /* These rules must follow the rules for function declarations\n    and component declarations.  That way, longer rules are preferred.  */\n \n /* An expression which will not live on the momentary obstack.  */\n nonmomentary_expr:\n \t{ $<itype>$ = suspend_momentary (); } expr\n \t{ resume_momentary ((int) $<itype>1); $$ = $2; }\n+\t;\n \n /* A declarator that is allowed only after an explicit typespec.  */\n /* may all be followed by prec '.' */\n after_type_declarator:\n-\t  after_type_declarator '(' nonnull_exprlist ')' type_quals  %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, $3, $5); }\n-\t| after_type_declarator '(' parmlist ')' type_quals  %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, $3, $5); }\n-\t| after_type_declarator LEFT_RIGHT type_quals  %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $3); }\n-\t| after_type_declarator '(' error ')' type_quals  %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, NULL_TREE, NULL_TREE); }\n-\t| after_type_declarator '[' nonmomentary_expr ']'\n-\t\t{ $$ = build_parse_node (ARRAY_REF, $$, $3); }\n-\t| after_type_declarator '[' ']'\n-\t\t{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }\n-\t| '(' after_type_declarator_no_typename ')'\n+\t  after_type_declarator1\n+\t| START_DECLARATOR after_type_declarator1\n \t\t{ $$ = $2; }\n-\t| '(' '*' type_quals after_type_declarator ')'\n-\t\t{ $$ = make_pointer_declarator ($3, $4); }\n-\t| PAREN_STAR_PAREN\n-\t\t{ see_typename (); }\n-\t| after_type_member_declarator\n-\t| '(' '&' type_quals after_type_declarator ')'\n-\t\t{ $$ = make_reference_declarator ($3, $4); }\n-\t| '*' type_quals after_type_declarator  %prec UNARY\n+\t;\n+\n+after_type_declarator1:\n+\t  '*' nonempty_type_quals after_type_declarator1  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| '&' type_quals after_type_declarator  %prec UNARY\n+\t| '&' nonempty_type_quals after_type_declarator1  %prec UNARY\n \t\t{ $$ = make_reference_declarator ($2, $3); }\n-\t| TYPENAME %prec EMPTY\n+\t| '*' after_type_declarator1  %prec UNARY\n+\t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n+\t| '&' after_type_declarator1  %prec UNARY\n+\t\t{ $$ = make_reference_declarator (NULL_TREE, $2); }\n+\t| id_scope '*' type_quals after_type_declarator1\n+\t\t{ tree arg = make_pointer_declarator ($3, $4);\n+\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n+\t\t    $$ = build_push_scope ($$, arg);\n+\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n+\t\t    TREE_OPERAND ($$, 1) = arg;\n+\t\t  else\n+\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t\t}\n+\t| direct_after_type_declarator\n \t;\n \n-after_type_declarator_no_typename:\n-\t  after_type_declarator_no_typename '(' nonnull_exprlist ')' type_quals  %prec '.'\n+direct_after_type_declarator:\n+\t  direct_after_type_declarator '(' nonnull_exprlist ')' type_quals %prec '.'\n \t\t{ $$ = build_parse_node (CALL_EXPR, $$, $3, $5); }\n-\t| after_type_declarator_no_typename '(' parmlist ')' type_quals  %prec '.'\n+\t| direct_after_type_declarator '(' parmlist ')' type_quals %prec '.'\n \t\t{ $$ = build_parse_node (CALL_EXPR, $$, $3, $5); }\n-\t| after_type_declarator_no_typename LEFT_RIGHT type_quals  %prec '.'\n+\t| direct_after_type_declarator LEFT_RIGHT type_quals %prec '.'\n \t\t{ $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $3); }\n-\t| after_type_declarator_no_typename '(' error ')' type_quals  %prec '.'\n+\t| direct_after_type_declarator '(' error ')' type_quals %prec '.'\n \t\t{ $$ = build_parse_node (CALL_EXPR, $$, NULL_TREE, NULL_TREE); }\n-\t| after_type_declarator_no_typename '[' nonmomentary_expr ']'\n+\t| direct_after_type_declarator '[' nonmomentary_expr ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, $3); }\n-\t| after_type_declarator_no_typename '[' ']'\n+\t| direct_after_type_declarator '[' ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }\n-\t| '(' after_type_declarator_no_typename ')'\n+\t| '(' after_type_declarator1 ')'\n \t\t{ $$ = $2; }\n-\t| PAREN_STAR_PAREN\n-\t\t{ see_typename (); }\n-\t| after_type_member_declarator\n-\t| '*' type_quals after_type_declarator  %prec UNARY\n-\t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| '&' type_quals after_type_declarator  %prec UNARY\n-\t\t{ $$ = make_reference_declarator ($2, $3); }\n+\t| TYPENAME %prec EMPTY\n \t;\n \n /* A declarator allowed whether or not there has been\n    an explicit typespec.  These cannot redeclare a typedef-name.  */\n \n notype_declarator:\n-\t  notype_declarator '(' nonnull_exprlist ')' type_quals  %prec '.'\n+          notype_declarator1\n+        | START_DECLARATOR notype_declarator1\n+\t\t{ $$ = $2; }\n+\t;\n+\n+notype_declarator1:\n+\t  '*' nonempty_type_quals notype_declarator1  %prec UNARY\n+\t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t| '&' nonempty_type_quals notype_declarator1  %prec UNARY\n+\t\t{ $$ = make_reference_declarator ($2, $3); }\n+\t| '*' notype_declarator1  %prec UNARY\n+\t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n+\t| '&' notype_declarator1  %prec UNARY\n+\t\t{ $$ = make_reference_declarator (NULL_TREE, $2); }\n+\t| id_scope '*' type_quals notype_declarator1\n+\t\t{ tree arg = make_pointer_declarator ($3, $4);\n+\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n+\t\t    $$ = build_push_scope ($$, arg);\n+\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n+\t\t    TREE_OPERAND ($$, 1) = arg;\n+\t\t  else\n+\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t\t}\n+\t| direct_notype_declarator\n+\t;\n+\n+complex_notype_declarator1:\n+\t  '*' nonempty_type_quals notype_declarator1  %prec UNARY\n+\t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t| '&' nonempty_type_quals notype_declarator1  %prec UNARY\n+\t\t{ $$ = make_reference_declarator ($2, $3); }\n+\t| '*' complex_notype_declarator1  %prec UNARY\n+\t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n+\t| '&' complex_notype_declarator1  %prec UNARY\n+\t\t{ $$ = make_reference_declarator (NULL_TREE, $2); }\n+\t| id_scope '*' type_quals notype_declarator1\n+\t\t{ tree arg = make_pointer_declarator ($3, $4);\n+\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n+\t\t    $$ = build_push_scope ($$, arg);\n+\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n+\t\t    TREE_OPERAND ($$, 1) = arg;\n+\t\t  else\n+\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t\t}\n+\t| complex_direct_notype_declarator\n+\t;\n+\n+complex_direct_notype_declarator:\n+\t  direct_notype_declarator '(' nonnull_exprlist ')' type_quals  %prec '.'\n \t\t{ $$ = build_parse_node (CALL_EXPR, $$, $3, $5); }\n-\t| notype_declarator '(' parmlist ')' type_quals  %prec '.'\n+\t| direct_notype_declarator '(' parmlist ')' type_quals  %prec '.'\n \t\t{ $$ = build_parse_node (CALL_EXPR, $$, $3, $5); }\n-\t| notype_declarator LEFT_RIGHT type_quals  %prec '.'\n+\t| direct_notype_declarator LEFT_RIGHT type_quals  %prec '.'\n \t\t{ $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $3); }\n-\t| notype_declarator '(' error ')' type_quals  %prec '.'\n+\t| direct_notype_declarator '(' error ')' type_quals  %prec '.'\n \t\t{ $$ = build_parse_node (CALL_EXPR, $$, NULL_TREE, NULL_TREE); }\n-\t| '(' notype_declarator ')'\n+\t| '(' expr_or_declarator ')'\n+\t\t{ $$ = finish_decl_parsing ($2); }\n+\t| '(' complex_notype_declarator1 ')'\n \t\t{ $$ = $2; }\n-\t| '*' type_quals notype_declarator  %prec UNARY\n-\t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| '&' type_quals notype_declarator  %prec UNARY\n-\t\t{ $$ = make_reference_declarator ($2, $3); }\n-\t| notype_declarator '[' nonmomentary_expr ']'\n+\t| direct_notype_declarator '[' nonmomentary_expr ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, $3); }\n-\t| notype_declarator '[' ']'\n+\t| direct_notype_declarator '[' ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }\n-\t| IDENTIFIER\n-\t\t{ see_typename (); }\n \n \t/* C++ extensions.  */\n-\t| operator_name\n-\t\t{ see_typename (); }\n-\n-\t| '~' TYPENAME\n-\t\t{\n-\t\tdestructor_name:\n-\t\t  see_typename ();\n-\t\t  $$ = build_parse_node (BIT_NOT_EXPR, $2);\n-\t\t}\n-\t| '~' IDENTIFIER\n-\t\t{ goto destructor_name; }\n-        | '~' PTYPENAME\n-                { goto destructor_name; }\n-\t| id_scope see_typename notype_declarator  %prec '('\n+\t| id_scope see_typename notype_unqualified_id\n \t\t{ see_typename ();\n \t\t  if (TREE_CODE ($$) != SCOPE_REF)\n \t\t    $$ = build_push_scope ($$, $3);\n@@ -2822,34 +2998,35 @@ notype_declarator:\n \t\t  else\n \t\t    $$ = build_parse_node (SCOPE_REF, $$, $3);\n \t\t}\n-\t| id_scope see_typename TYPENAME  %prec '('\n-\t\t{ $$ = build_push_scope ($$, $3); }\n-\t| id_scope see_typename TYPENAME '(' nonnull_exprlist ')' type_quals  %prec '.'\n-\t\t{ $$ = build_push_scope ($$, build_parse_node (CALL_EXPR, $3, $5, $7)); }\n-\t| id_scope see_typename TYPENAME '(' parmlist ')' type_quals  %prec '.'\n-\t\t{ $$ = build_push_scope ($$, build_parse_node (CALL_EXPR, $3, $5, $7)); }\n-\t| id_scope see_typename TYPENAME LEFT_RIGHT type_quals  %prec '.'\n-\t\t{ $$ = build_push_scope ($$, build_parse_node (CALL_EXPR, $3, empty_parms (), $5)); }\n-\t| id_scope see_typename TYPENAME '(' error ')' type_quals  %prec '.'\n-\t\t{ $$ = build_push_scope ($$, build_parse_node (CALL_EXPR, $3, NULL_TREE, NULL_TREE)); }\n-\t/* For constructor templates.  */\n-\t| id_scope see_typename PTYPENAME  %prec '('\n+\t| id_scope see_typename TYPENAME\n \t\t{ $$ = build_push_scope ($$, $3); }\n-\t| id_scope see_typename PTYPENAME '(' nonnull_exprlist ')' type_quals  %prec '.'\n-\t\t{ $$ = build_push_scope ($$, build_parse_node (CALL_EXPR, $3, $5, $7)); }\n-\t| id_scope see_typename PTYPENAME '(' parmlist ')' type_quals  %prec '.'\n-\t\t{ $$ = build_push_scope ($$, build_parse_node (CALL_EXPR, $3, $5, $7)); }\n-\t| id_scope see_typename PTYPENAME LEFT_RIGHT type_quals  %prec '.'\n-\t\t{ $$ = build_push_scope ($$, build_parse_node (CALL_EXPR, $3, empty_parms (), $5)); }\n-\t| id_scope see_typename PTYPENAME '(' error ')' type_quals  %prec '.'\n-\t\t{ $$ = build_push_scope ($$, build_parse_node (CALL_EXPR, $3, NULL_TREE, NULL_TREE)); }\n-\t| SCOPE see_typename notype_declarator\n+\t| SCOPE see_typename direct_notype_declarator\n \t\t{ $$ = build_parse_node (SCOPE_REF, NULL_TREE, $3); }\n \t| template_type SCOPED_NAME \n-\t\t{ $$ = $2; }\n+\t\t{ tree t;\n+\t\t  extern int current_class_depth;\n+\n+\t\t  t = TREE_TYPE(TREE_OPERAND($2, 0));\n+\t\t  if (t != current_class_type &&\n+\t\t      TREE_CODE(t) != TEMPLATE_TYPE_PARM)\n+\t\t    {\n+\t\t      push_nested_class(t, 3);\n+\t\t      TREE_COMPLEXITY ($2) = current_class_depth;\n+\t\t    }\n+\t\t  $$ = $2; \n+\t\t}\n+\t;\n+\n+functional_cast:\n+\t  typespec '(' nonnull_exprlist ')'\n+\t\t{ $$ = build_functional_cast ($$, $3); }\n+\t| typespec '(' expr_or_declarator ')'\n+\t\t{ $$ = reparse_decl_as_expr ($$, $3); }\n+\t| typespec fcast_or_absdcl %prec EMPTY\n+\t\t{ $$ = reparse_absdcl_as_expr ($$, $2); }\n \t;\n \n-id_scope:\ttypename_scope\n+id_scope: typename_scope\n \t\t{ tree t;\n                   do_id_scope:\n \n@@ -2906,97 +3083,108 @@ scoped_typename: SCOPED_TYPENAME\n \t\t} */\n \t;\n \n-absdcl1:  /* a nonempty abstract declarator */\n-\t  '(' absdcl1 ')'\n-\t\t{ see_typename ();\n-\t\t  $$ = $2; }\n-\t  /* `(typedef)1' is `int'.  */\n-\t| '*' type_quals absdcl1  %prec EMPTY\n+/* ANSI new-declarator (5.3.4) */\n+new_declarator:\n+\t  '*' type_quals new_declarator\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n \t| '*' type_quals  %prec EMPTY\n \t\t{ $$ = make_pointer_declarator ($2, NULL_TREE); }\n-/*\n-\t| id_scope '*' type_quals absdcl1 %prec EMPTY\n-\t\t{ $3 = make_pointer_declarator ($3, $4);\n-\t\t  $$ = build_parse_node (SCOPE_REF, $$, $3); }\n+\t| '&' type_quals new_declarator %prec EMPTY\n+\t\t{ $$ = make_reference_declarator ($2, $3); }\n+\t| '&' type_quals %prec EMPTY\n+\t\t{ $$ = make_reference_declarator ($2, NULL_TREE); }\n \t| id_scope '*' type_quals %prec EMPTY\n-\t\t{ $3 = make_pointer_declarator ($3, NULL_TREE);\n-\t\t  $$ = build_parse_node (SCOPE_REF, $$, $3); }\n-*/\n-\t| PAREN_STAR_PAREN\n-\t\t{ see_typename (); }\n-\t| '(' abs_member_declarator ')'\n-\t\t{ $$ = $2; }\n-\t| '&' type_quals absdcl1 %prec EMPTY\n+\t\t{ tree arg = make_pointer_declarator ($3, NULL_TREE);\n+\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n+\t\t    $$ = build_push_scope ($$, arg);\n+\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n+\t\t    TREE_OPERAND ($$, 1) = arg;\n+\t\t  else\n+\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t\t}\n+\t| id_scope '*' type_quals new_declarator\n+\t\t{ tree arg = make_pointer_declarator ($3, $4);\n+\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n+\t\t    $$ = build_push_scope ($$, arg);\n+\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n+\t\t    TREE_OPERAND ($$, 1) = arg;\n+\t\t  else\n+\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t\t}\n+\t| direct_new_declarator %prec EMPTY\n+\t;\n+\n+/* ANSI direct-new-declarator (5.3.4) */\n+direct_new_declarator:\n+\t  '[' expr ']'\n+\t\t{ $$ = build_parse_node (ARRAY_REF, NULL_TREE, $2); }\n+\t| direct_new_declarator '[' nonmomentary_expr ']'\n+\t\t{ $$ = build_parse_node (ARRAY_REF, $$, $3); }\n+\t;\n+\n+/* ANSI abstract-declarator (8.1) */\n+absdcl1:\n+\t  '*' nonempty_type_quals absdcl1\n+\t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t| '*' absdcl1\n+\t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n+\t| '*' type_quals  %prec EMPTY\n+\t\t{ $$ = make_pointer_declarator ($2, NULL_TREE); }\n+\t| '&' nonempty_type_quals absdcl1\n \t\t{ $$ = make_reference_declarator ($2, $3); }\n+\t| '&' absdcl1\n+\t\t{ $$ = make_reference_declarator (NULL_TREE, $2); }\n \t| '&' type_quals %prec EMPTY\n \t\t{ $$ = make_reference_declarator ($2, NULL_TREE); }\n-\t| absdcl1 '(' parmlist ')' type_quals  %prec '.'\n+\t| id_scope '*' type_quals %prec EMPTY\n+\t\t{ tree arg = make_pointer_declarator ($3, NULL_TREE);\n+\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n+\t\t    $$ = build_push_scope ($$, arg);\n+\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n+\t\t    TREE_OPERAND ($$, 1) = arg;\n+\t\t  else\n+\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t\t}\n+\t| id_scope '*' type_quals absdcl1\n+\t\t{ tree arg = make_pointer_declarator ($3, $4);\n+\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n+\t\t    $$ = build_push_scope ($$, arg);\n+\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n+\t\t    TREE_OPERAND ($$, 1) = arg;\n+\t\t  else\n+\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t\t}\n+\t| direct_abstract_declarator %prec EMPTY\n+\t;\n+\n+/* ANSI direct-abstract-declarator (8.1) */\n+direct_abstract_declarator:\n+\t  '(' absdcl1 ')'\n+\t\t{ see_typename ();\n+\t\t  $$ = $2; }\n+\t  /* `(typedef)1' is `int'.  */\n+\t| PAREN_STAR_PAREN\n+\t\t{ see_typename (); }\n+\t| direct_abstract_declarator '(' parmlist ')' type_quals  %prec '.'\n \t\t{ $$ = build_parse_node (CALL_EXPR, $$, $3, $5); }\n-\t| absdcl1 LEFT_RIGHT type_quals  %prec '.'\n+\t| direct_abstract_declarator LEFT_RIGHT type_quals  %prec '.'\n \t\t{ $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $3); }\n-\t| absdcl1 '[' nonmomentary_expr ']'  %prec '.'\n+\t| direct_abstract_declarator '[' nonmomentary_expr ']'  %prec '.'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, $3); }\n-\t| absdcl1 '[' ']'  %prec '.'\n+\t| direct_abstract_declarator '[' ']'  %prec '.'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }\n-\t| '(' parmlist ')' type_quals  %prec '.'\n+\t| '(' complex_parmlist ')' type_quals  %prec '.'\n \t\t{ $$ = build_parse_node (CALL_EXPR, NULL_TREE, $2, $4); }\n-\t| LEFT_RIGHT type_quals  %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, NULL_TREE, empty_parms (), $2); }\n+\t| regcast_or_absdcl type_quals %prec '.'\n+\t\t{ TREE_OPERAND ($$, 2) = $2; }\n+\t| fcast_or_absdcl type_quals %prec '.'\n+\t\t{ TREE_OPERAND ($$, 2) = $2; }\n \t| '[' nonmomentary_expr ']'  %prec '.'\n \t\t{ $$ = build_parse_node (ARRAY_REF, NULL_TREE, $2); }\n \t| '[' ']'  %prec '.'\n \t\t{ $$ = build_parse_node (ARRAY_REF, NULL_TREE, NULL_TREE); }\n \t;\n \n-abs_member_declarator:\n-\t  id_scope see_typename '*' type_quals\n-\t\t{ tree t;\n-\t\t  t = $$;\n-\t\t  while (TREE_OPERAND (t, 1))\n-\t\t    t = TREE_OPERAND (t, 1);\n-\t\t  TREE_OPERAND (t, 1) = build_parse_node (INDIRECT_REF, 0);\n-\t\t}\n-\t| id_scope see_typename '*' type_quals absdcl1\n-\t\t{ tree t;\n-\t\t  t = $$;\n-\t\t  while (TREE_OPERAND (t, 1))\n-\t\t    t = TREE_OPERAND (t, 1);\n-\t\t  TREE_OPERAND (t, 1) = build_parse_node (INDIRECT_REF, $5);\n-\t\t}\n-\t| id_scope see_typename '&' type_quals\n-\t\t{ tree t;\n-\t\t  t = $$;\n-\t\t  while (TREE_OPERAND (t, 1))\n-\t\t    t = TREE_OPERAND (t, 1);\n-\t\t  TREE_OPERAND (t, 1) = build_parse_node (ADDR_EXPR, 0);\n-\t\t}\n-\t| id_scope see_typename '&' type_quals absdcl1\n-\t\t{ tree t;\n-\t\t  t = $$;\n-\t\t  while (TREE_OPERAND (t, 1))\n-\t\t    t = TREE_OPERAND (t, 1);\n-\t\t  TREE_OPERAND (t, 1) = build_parse_node (ADDR_EXPR, $5);\n-\t\t}\n-\t;\n-\n-after_type_member_declarator:\n-\t  id_scope see_typename '*' type_quals after_type_declarator\n-\t\t{ tree t;\n-\t\t  t = $$;\n-\t\t  while (TREE_OPERAND (t, 1))\n-\t\t    t = TREE_OPERAND (t, 1);\n-\t\t  TREE_OPERAND (t, 1) = build_parse_node (INDIRECT_REF, $5);\n-\t\t}\n-\t| id_scope see_typename '&' type_quals after_type_declarator\n-\t\t{ tree t;\n-\t\t  t = $$;\n-\t\t  while (TREE_OPERAND (t, 1))\n-\t\t    t = TREE_OPERAND (t, 1);\n-\t\t  TREE_OPERAND (t, 1) = build_parse_node (ADDR_EXPR, $5);\n-\t\t}\n-\t;\n-\n /* For C++, decls and stmts can be intermixed, so we don't need to\n    have a special rule that won't start parsing the stmt section\n    until we have a stmt that parses without errors.  */\n@@ -3734,7 +3922,7 @@ optional_identifier:\n ansi_except_stmts:\n \t  /* empty */\n \t\t{ $$ = NULL_TREE; }\n-\t| ansi_except_stmts CATCH '(' typename optional_identifier ')'\n+\t| ansi_except_stmts CATCH '(' type_id optional_identifier ')'\n \t\t{\n \t\t  tree type = groktypename ($4);\n \t\t  if (IS_SIGNATURE (type))\n@@ -3842,19 +4030,29 @@ asm_clobbers:\n \n    In C++, declaring a function with no parameters\n    means that that function takes *no* parameters.  */\n+\n parmlist:  /* empty */\n \t\t{\n \t\t  if (strict_prototype)\n \t\t    $$ = void_list_node;\n \t\t  else\n \t\t    $$ = NULL_TREE;\n \t\t}\n-\t| parms\n+\t| complex_parmlist\n+\t| type_id\n+\t\t{ $$ = tree_cons (NULL_TREE, $$, void_list_node);\n+\t\t  TREE_PARMLIST ($$) = 1; }\n+\t;\n+\n+/* This nonterminal does not include the common sequence '(' type_id ')',\n+   as it is ambiguous and must be disambiguated elsewhere.  */\n+complex_parmlist:\n+\t  parms\n   \t\t{\n \t\t  $$ = chainon ($$, void_list_node);\n \t\t  TREE_PARMLIST ($$) = 1;\n \t\t}\n-\t| parms ',' ELLIPSIS\n+\t| parms_comma ELLIPSIS\n \t\t{\n \t\t  TREE_PARMLIST ($$) = 1;\n \t\t}\n@@ -3863,6 +4061,11 @@ parmlist:  /* empty */\n \t\t{\n \t\t  TREE_PARMLIST ($$) = 1;\n \t\t}\n+\t| type_id ELLIPSIS\n+\t\t{\n+\t\t  $$ = build_tree_list (NULL_TREE, $$); \n+\t\t  TREE_PARMLIST ($$) = 1;\n+\t\t}\n \t| ELLIPSIS\n \t\t{\n \t\t  /* ARM $8.2.5 has this as a boxed-off comment.  */\n@@ -3878,6 +4081,11 @@ parmlist:  /* empty */\n \t\t{\n \t\t  TREE_PARMLIST ($$) = 1;\n \t\t}\n+\t| type_id TYPENAME_ELLIPSIS\n+\t\t{\n+\t\t  $$ = build_tree_list (NULL_TREE, $$);\n+\t\t  TREE_PARMLIST ($$) = 1;\n+\t\t}\n \t| parms ':'\n \t\t{\n \t\t  /* This helps us recover from really nasty\n@@ -3889,29 +4097,46 @@ parmlist:  /* empty */\n \t\t  yyungetc (':', 0);\n \t\t  yychar = ')';\n \t\t}\n+\t| type_id ':'\n+\t\t{\n+\t\t  /* This helps us recover from really nasty\n+\t\t     parse errors, for example, a missing right\n+\t\t     parenthesis.  */\n+\t\t  yyerror (\"possibly missing ')'\");\n+\t\t  $$ = tree_cons (NULL_TREE, $$, void_list_node);\n+\t\t  TREE_PARMLIST ($$) = 1;\n+\t\t  yyungetc (':', 0);\n+\t\t  yychar = ')';\n+\t\t}\n \t;\n \n /* A nonempty list of parameter declarations or type names.  */\n parms:\n-\t  parm\n+\t  named_parm\n \t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n \t| parm '=' init\n \t\t{ $$ = build_tree_list ($3, $$); }\n-\t| parms ',' parm\n-\t\t{ $$ = chainon ($$, build_tree_list (NULL_TREE, $3)); }\n-\t| parms ',' parm '=' init\n-\t\t{ $$ = chainon ($$, build_tree_list ($5, $3)); }\n-\t| parms ',' bad_parm\n-\t\t{ $$ = chainon ($$, build_tree_list (NULL_TREE, $3)); }\n-\t| parms ',' bad_parm '=' init\n-\t\t{ $$ = chainon ($$, build_tree_list ($5, $3)); }\n+\t| parms_comma parm\n+\t\t{ $$ = chainon ($$, build_tree_list (NULL_TREE, $2)); }\n+\t| parms_comma parm '=' init\n+\t\t{ $$ = chainon ($$, build_tree_list ($4, $2)); }\n+\t| parms_comma bad_parm\n+\t\t{ $$ = chainon ($$, build_tree_list (NULL_TREE, $2)); }\n+\t| parms_comma bad_parm '=' init\n+\t\t{ $$ = chainon ($$, build_tree_list ($4, $2)); }\n+\t;\n+\n+parms_comma:\n+\t  parms ','\n+\t| type_id ','\n+\t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n \t;\n \n /* A single parameter declaration or parameter type name,\n    as found in a parmlist.  The first four cases make up for 10%\n    of the time spent parsing C++.  We cannot use them because\n    of `int id[]' which won't get parsed properly.  */\n-parm:\n+named_parm:\n /*\n \t  typed_declspecs dont_see_typename '*' IDENTIFIER\n \t\t{ $$ = build_tree_list ($$, build_parse_node (INDIRECT_REF, $4));\n@@ -3920,33 +4145,46 @@ parm:\n \t\t{ $$ = build_tree_list ($$, build_parse_node (ADDR_EXPR, $4));\n \t\t  see_typename (); }\n \t| TYPENAME IDENTIFIER\n-\t\t{ $$ = build_tree_list (list_hash_lookup_or_cons ($$), $2);  }\n+\t\t{ $$ = build_tree_list (get_decl_list ($$), $2);  }\n \t| TYPESPEC IDENTIFIER\n-\t\t{ $$ = build_tree_list (list_hash_lookup_or_cons ($$), $2); }\n+\t\t{ $$ = build_tree_list (get_decl_list ($$), $2); }\n \t| */\n-\t  typed_declspecs dont_see_typename abs_or_notype_decl\n-\t\t{ $$ = build_tree_list ($$, $3);\n+\t/* Here we expand typed_declspecs inline to avoid mis-parsing of\n+\t   TYPESPEC IDENTIFIER.  */\n+\t  typed_declspecs1 declarator\n+\t\t{ $$ = build_tree_list ($$, $2);\n+\t\t  see_typename (); }\n+\t| typed_typespecs declarator\n+\t\t{ $$ = build_tree_list ($$, $2);\n+\t\t  see_typename (); }\n+\t| typespec declarator\n+\t\t{ $$ = build_tree_list (get_decl_list ($$), $2);\n+\t\t  see_typename (); }\n+\t| typed_declspecs1 absdcl\n+\t\t{ $$ = build_tree_list ($$, $2);\n+\t\t  see_typename (); }\n+\t| typed_declspecs1 %prec EMPTY\n+\t\t{ $$ = build_tree_list ($$, NULL_TREE);\n \t\t  see_typename (); }\n-\t| declmods dont_see_typename abs_or_notype_decl\n-\t\t{ $$ = build_tree_list ($$, $3);\n+\t| declmods notype_declarator\n+\t\t{ $$ = build_tree_list ($$, $2);\n \t\t  see_typename (); }\n \t;\n \n-abs_or_notype_decl: absdcl\n-\t| notype_declarator\n-\t| START_DECLARATOR notype_declarator\n-\t\t{ $$ = $2; }\n+parm:\n+\tnamed_parm\n+\t| type_id\n \t;\n \n-see_typename: type_quals\n+see_typename: %prec EMPTY\n \t{ see_typename (); }\n \t;\n \n-dont_see_typename: %prec EMPTY /* empty */\n+/* \n+dont_see_typename: %prec EMPTY\n \t{ dont_see_typename (); }\n-\t;\n+\t; \n \n-/*\n try_for_typename:\n         {\n \t  if ($<ttype>-1 == error_mark_node)\n@@ -3961,7 +4199,12 @@ try_for_typename:\n */\n \n bad_parm:\n-\t  abs_or_notype_decl\n+\t  /* empty */ %prec EMPTY\n+\t\t{\n+\t\t  warning (\"type specifier omitted for parameter\");\n+\t\t  $$ = build_tree_list (TREE_PURPOSE (TREE_VALUE ($<ttype>-1)), NULL_TREE);\n+\t\t}\n+\t| notype_declarator\n \t\t{\n \t\t  warning (\"type specifier omitted for parameter\");\n \t\t  $$ = build_tree_list (TREE_PURPOSE (TREE_VALUE ($<ttype>-1)), $$);\n@@ -3994,7 +4237,7 @@ raise_identifier:\n \t;\n \n ansi_raise_identifier:\n-\t  typename\n+\t  type_id\n \t\t{ $$ = build_decl_list (NULL_TREE, $$); }\n \t;\n \n@@ -4016,6 +4259,24 @@ ansi_raise_identifiers:\n \t\t}\n \t;\n \n+conversion_declarator:\n+\t  /* empty */ %prec EMPTY\n+\t\t{ $$ = NULL_TREE; }\n+\t| '*' type_quals conversion_declarator\n+\t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t| '&' type_quals conversion_declarator\n+\t\t{ $$ = make_reference_declarator ($2, $3); }\n+\t| id_scope '*' type_quals conversion_declarator\n+\t\t{ tree arg = make_pointer_declarator ($3, $4);\n+\t\t  if (TREE_CODE ($$) != SCOPE_REF)\n+\t\t    $$ = build_push_scope ($$, arg);\n+\t\t  else if (TREE_OPERAND ($$, 1) == NULL_TREE)\n+\t\t    TREE_OPERAND ($$, 1) = arg;\n+\t\t  else\n+\t\t    $$ = build_parse_node (SCOPE_REF, $$, arg);\n+\t\t}\n+\t;\n+\n operator_name:\n \t  OPERATOR '*'\n \t\t{ $$ = ansi_opname[MULT_EXPR]; }\n@@ -4077,21 +4338,14 @@ operator_name:\n \t\t{ $$ = ansi_opname[ARRAY_REF]; }\n \t| OPERATOR NEW\n \t\t{ $$ = ansi_opname[NEW_EXPR]; }\n-/*\n-\t| OPERATOR NEW '[' ']'\n-\t\t{ $$ = ansi_opname[VEC_NEW_EXPR]; }\n-*/\n \t| OPERATOR DELETE\n \t\t{ $$ = ansi_opname[DELETE_EXPR]; }\n-/*\n+/*\t| OPERATOR NEW '[' ']'\n+\t\t{ $$ = ansi_opname[VEC_NEW_EXPR]; }\n \t| OPERATOR DELETE '[' ']'\n-\t\t{ $$ = ansi_opname[VEC_DELETE_EXPR]; }\n-*/\n-\n-\t/* These should do `groktypename' and set up TREE_HAS_X_CONVERSION\n-\t   here, rather than doing it in class.c .  */\n-\t| OPERATOR typed_typespecs absdcl\n-\t\t{ $$ = build1 (TYPE_EXPR, $2, $3); }\n+\t\t{ $$ = ansi_opname[VEC_DELETE_EXPR]; }  */\n+\t| OPERATOR typed_typespecs conversion_declarator\n+\t\t{ $$ = grokoptypename ($2, $3); }\n \t| OPERATOR error\n \t\t{ $$ = ansi_opname[ERROR_MARK]; }\n \t;"}, {"sha": "90fe017112ff2d9c1ad9afacd1253f68bdc3afe2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -169,8 +169,9 @@ end_template_parm_list (parms)\n    D1 is template header; D2 is class_head_sans_basetype or a\n    TEMPLATE_DECL with its DECL_RESULT field set.  */\n void\n-end_template_decl (d1, d2, is_class)\n+end_template_decl (d1, d2, is_class, defn)\n      tree d1, d2, is_class;\n+     int defn;\n {\n   tree decl;\n   struct template_info *tmpl;\n@@ -254,37 +255,47 @@ end_template_decl (d1, d2, is_class)\n     }\n   DECL_TEMPLATE_INFO (decl) = tmpl;\n   DECL_TEMPLATE_PARMS (decl) = d1;\n-lose:\n-  if (decl)\n+\n+  /* So that duplicate_decls can do the right thing.  */\n+  if (defn)\n+    DECL_INITIAL (decl) = error_mark_node;\n+  \n+  /* If context of decl is non-null (i.e., method template), add it\n+     to the appropriate class template, and pop the binding levels.  */\n+  if (! DECL_TEMPLATE_IS_CLASS (decl)\n+      && DECL_CONTEXT (DECL_TEMPLATE_RESULT (decl)) != NULL_TREE)\n     {\n-      /* If context of decl is non-null (i.e., method template), add it\n-\t to the appropriate class template, and pop the binding levels.  */\n-      if (! DECL_TEMPLATE_IS_CLASS (decl)\n-\t  && DECL_CONTEXT (DECL_TEMPLATE_RESULT (decl)) != NULL_TREE)\n+      tree ctx = DECL_CONTEXT (DECL_TEMPLATE_RESULT (decl));\n+      tree tmpl;\n+      my_friendly_assert (TREE_CODE (ctx) == UNINSTANTIATED_P_TYPE, 266);\n+      tmpl = UPT_TEMPLATE (ctx);\n+      DECL_TEMPLATE_MEMBERS (tmpl) =\n+\tperm_tree_cons (DECL_NAME (decl), decl,\n+\t\t\tDECL_TEMPLATE_MEMBERS (tmpl));\n+      poplevel (0, 0, 0);\n+      poplevel (0, 0, 0);\n+    }\n+  /* Otherwise, go back to top level first, and push the template decl\n+     again there.  */\n+  else\n+    {\n+      poplevel (0, 0, 0);\n+      poplevel (0, 0, 0);\n+      if (TREE_TYPE (decl))\n \t{\n-\t  tree ctx = DECL_CONTEXT (DECL_TEMPLATE_RESULT (decl));\n-\t  tree tmpl;\n-\t  my_friendly_assert (TREE_CODE (ctx) == UNINSTANTIATED_P_TYPE, 266);\n-\t  tmpl = UPT_TEMPLATE (ctx);\n-\t  DECL_TEMPLATE_MEMBERS (tmpl) =\n-\t    perm_tree_cons (DECL_NAME (decl), decl,\n-\t\t\t    DECL_TEMPLATE_MEMBERS (tmpl));\n-\t  poplevel (0, 0, 0);\n-\t  poplevel (0, 0, 0);\n+\t  /* Function template */\n+\t  tree t = IDENTIFIER_GLOBAL_VALUE (DECL_NAME (decl));\n+\t  if (t && is_overloaded_fn (t))\n+\t    for (t = get_first_fn (t); t; t = DECL_CHAIN (t))\n+\t      if (TREE_CODE (t) == TEMPLATE_DECL\n+\t\t  && duplicate_decls (decl, t))\n+\t\tdecl = t;\n+\t  push_overloaded_decl (decl, 0);\n \t}\n-      /* Otherwise, go back to top level first, and push the template decl\n-\t again there.  */\n       else\n-\t{\n-\t  poplevel (0, 0, 0);\n-\t  poplevel (0, 0, 0);\n-\t  if (TREE_TYPE (decl)\n-\t      && IDENTIFIER_GLOBAL_VALUE (DECL_NAME (decl)) != NULL_TREE)\n-\t    push_overloaded_decl (decl, 0);\n-\t  else\n-\t    pushdecl (decl);\n-\t}\n+\tpushdecl (decl);\n     }\n+ lose:\n #if 0 /* It happens sometimes, with syntactic or semantic errors.\n \n \t One specific case:\n@@ -671,7 +682,7 @@ pop_template_decls (parmlist, arglist, class_level)\n     poplevel (0, 0, 0);\n }\n \f\n-/* Should be defined in cp-parse.h.  */\n+/* Should be defined in parse.h.  */\n extern int yychar;\n \n int\n@@ -1842,16 +1853,15 @@ end_template_instantiation (name)\n   extract_interface_info ();\n }\n \f\n-/* Store away the text of an inline template function.\tNo rtl is\n-   generated for this function until it is actually needed.  */\n+/* Store away the text of an template.  */\n \n void\n reinit_parse_for_template (yychar, d1, d2)\n      int yychar;\n      tree d1, d2;\n {\n   struct template_info *template_info;\n-  extern struct obstack inline_text_obstack; /* see comment in cp-lex.c */\n+  extern struct obstack inline_text_obstack; /* see comment in lex.c */\n \n   if (d2 == NULL_TREE || d2 == error_mark_node)\n     {\n@@ -1912,7 +1922,7 @@ type_unification (tparms, targs, parms, args, nsubsts, subr)\n \n   my_friendly_assert (TREE_CODE (tparms) == TREE_VEC, 289);\n   my_friendly_assert (TREE_CODE (parms) == TREE_LIST, 290);\n-  /* ARGS could be NULL (via a call from cp-parse.y to\n+  /* ARGS could be NULL (via a call from parse.y to\n      build_x_function_call).  */\n   if (args)\n     my_friendly_assert (TREE_CODE (args) == TREE_LIST, 291);"}, {"sha": "048e0a4000e3c11004192225eb555bdc0354516b", "filename": "gcc/cp/search.c", "status": "modified", "additions": 27, "deletions": 93, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -435,6 +435,8 @@ get_binfo (parent, binfo, protect)\n     type = BINFO_TYPE (binfo);\n   else if (TREE_CODE (binfo) == RECORD_TYPE)\n     type = binfo;\n+  else if (TREE_CODE (binfo) == UNION_TYPE)\n+    return NULL_TREE;\n   else\n     my_friendly_abort (90);\n   \n@@ -479,9 +481,10 @@ get_base_distance_recursive (binfo, depth, is_private, basetype_path, rval,\n \t}\n       else\n \t{\n-\t  int same_object = tree_int_cst_equal (BINFO_OFFSET (*new_binfo_ptr),\n-\t\t\t\t\t\tBINFO_OFFSET (binfo));\n-\n+\t  int same_object = (tree_int_cst_equal (BINFO_OFFSET (*new_binfo_ptr),\n+\t\t\t\t\t\t BINFO_OFFSET (binfo))\n+\t\t\t     && *via_virtual_ptr && via_virtual);\n+\t\t\t     \n \t  if (*via_virtual_ptr && via_virtual==0)\n \t    {\n \t      *rval_private_ptr = is_private;\n@@ -2535,7 +2538,8 @@ build_vbase_vtables_init (main_binfo, binfo, true_exp, decl_ptr,\n \t      tree addr;\n \t      tree vtbl = BINFO_VTABLE (vbases);\n \t      tree init = build_unary_op (ADDR_EXPR, vtbl, 0);\n-\t      assemble_external (vtbl);\n+\t      if (!flag_vtable_hack)\n+\t\tassemble_external (vtbl);\n \t      TREE_USED (vtbl) = 1;\n \n \t      if (use_computed_offsets)\n@@ -2580,112 +2584,42 @@ static void\n dfs_get_vbase_types (binfo)\n      tree binfo;\n {\n-  tree binfos = BINFO_BASETYPES (binfo);\n-  tree type = BINFO_TYPE (binfo);\n-  tree these_vbase_types = CLASSTYPE_VBASECLASSES (type);\n-  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-  if (these_vbase_types)\n-    {\n-      while (these_vbase_types)\n-\t{\n-\t  tree this_type = BINFO_TYPE (these_vbase_types);\n-\n-\t  /* We really need to start from a fresh copy of this\n-\t     virtual basetype!  CLASSTYPE_MARKED2 is the shortcut\n-\t     for BINFO_VBASE_MARKED.  */\n-\t  if (! CLASSTYPE_MARKED2 (this_type))\n-\t    {\n-\t      vbase_types = make_binfo (integer_zero_node,\n-\t\t\t\t\tthis_type,\n-\t\t\t\t\tTYPE_BINFO_VTABLE (this_type),\n-\t\t\t\t\tTYPE_BINFO_VIRTUALS (this_type),\n-\t\t\t\t\tvbase_types);\n-\t      TREE_VIA_VIRTUAL (vbase_types) = 1;\n-\t      SET_CLASSTYPE_MARKED2 (this_type);\n-\t    }\n-\t  these_vbase_types = TREE_CHAIN (these_vbase_types);\n-\t}\n-    }\n-  else for (i = 0; i < n_baselinks; i++)\n+  if (TREE_VIA_VIRTUAL (binfo) && ! BINFO_VBASE_MARKED (binfo))\n     {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      if (TREE_VIA_VIRTUAL (base_binfo) && ! BINFO_VBASE_MARKED (base_binfo))\n-\t{\n-\t  vbase_types = make_binfo (integer_zero_node, BINFO_TYPE (base_binfo),\n-\t\t\t\t    BINFO_VTABLE (base_binfo),\n-\t\t\t\t    BINFO_VIRTUALS (base_binfo), vbase_types);\n-\t  TREE_VIA_VIRTUAL (vbase_types) = 1;\n-\t  SET_BINFO_VBASE_MARKED (base_binfo);\n-\t}\n+      vbase_types = make_binfo (integer_zero_node, BINFO_TYPE (binfo),\n+\t\t\t\tBINFO_VTABLE (binfo),\n+\t\t\t\tBINFO_VIRTUALS (binfo), vbase_types);\n+      TREE_VIA_VIRTUAL (vbase_types) = 1;\n+      SET_BINFO_VBASE_MARKED (binfo);\n     }\n   SET_BINFO_MARKED (binfo);\n }\n \n-/* Some virtual baseclasses might be virtual baseclasses for\n-   other virtual baseclasses.  We sort the virtual baseclasses\n-   topologically: in the list returned, the first virtual base\n-   classes have no virtual baseclasses themselves, and any entry\n-   on the list has no dependency on virtual base classes later in the\n-   list.  */\n+/* get a list of virtual base classes in dfs order.  */\n tree\n get_vbase_types (type)\n      tree type;\n {\n-  tree ordered_vbase_types = NULL_TREE, prev, next;\n   tree vbases;\n+  tree binfo;\n+\n+  if (TREE_CODE (type) == TREE_VEC)\n+    binfo = type;\n+  else\n+    binfo = TYPE_BINFO (type);\n \n   vbase_types = NULL_TREE;\n-  dfs_walk (TYPE_BINFO (type), dfs_get_vbase_types, unmarkedp);\n-  dfs_walk (TYPE_BINFO (type), dfs_unmark, markedp);\n+  dfs_walk (binfo, dfs_get_vbase_types, unmarkedp);\n+  dfs_walk (binfo, dfs_unmark, markedp);\n   /* Rely upon the reverse dfs ordering from dfs_get_vbase_types, and now\n      reverse it so that we get normal dfs ordering.  */\n   vbase_types = nreverse (vbase_types);\n \n-  /* Almost all of the below is not needed now.  We should be able to just\n-     return vbase_types directly... (mrs) */\n-  while (vbase_types)\n-    {\n-      /* Now sort these types.  This is essentially a bubble merge.  */\n-\n-      /* Farm out virtual baseclasses which have no marked ancestors.  */\n-      for (vbases = vbase_types, prev = NULL_TREE;\n-\t   vbases; vbases = next)\n-\t{\n-\t  next = TREE_CHAIN (vbases);\n-\t  /* If VBASES does not have any vbases itself, or it's\n-\t     topologically safe, it goes into the sorted list.  */\n-\t  if (1 /* ANSI C++ specifies dfs ordering now. */\n-\t      || ! CLASSTYPE_VBASECLASSES (BINFO_TYPE (vbases))\n-\t      || BINFO_VBASE_MARKED (vbases) == 0)\n-\t    {\n-\t      if (prev)\n-\t\tTREE_CHAIN (prev) = TREE_CHAIN (vbases);\n-\t      else\n-\t\tvbase_types = TREE_CHAIN (vbases);\n-\t      TREE_CHAIN (vbases) = NULL_TREE;\n-\t      ordered_vbase_types = chainon (ordered_vbase_types, vbases);\n-\t      CLEAR_BINFO_VBASE_MARKED (vbases);\n-\t    }\n-\t  else\n-\t    prev = vbases;\n-\t}\n-\n-      /* Now unmark types all of whose ancestors are now on the\n-\t `ordered_vbase_types' list.  */\n-      for (vbases = vbase_types; vbases; vbases = TREE_CHAIN (vbases))\n-\t{\n-\t  /* If all our virtual baseclasses are unmarked, ok.  */\n-\t  tree t = CLASSTYPE_VBASECLASSES (BINFO_TYPE (vbases));\n-\t  while (t && (BINFO_VBASE_MARKED (t) == 0\n-\t\t       || ! CLASSTYPE_VBASECLASSES (BINFO_TYPE (t))))\n-\t    t = TREE_CHAIN (t);\n-\t  if (t == NULL_TREE)\n-\t    CLEAR_BINFO_VBASE_MARKED (vbases);\n-\t}\n-    }\n+  /* unmark marked vbases */\n+  for (vbases = vbase_types; vbases; vbases = TREE_CHAIN (vbases))\n+    CLEAR_BINFO_VBASE_MARKED (vbases);\n \n-  return ordered_vbase_types;\n+  return vbase_types;\n }\n \f\n static void"}, {"sha": "fd0cafae40ad141f6792b3304c8098bdefdc9b95", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -20,7 +20,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n \n /* This file is the type analyzer for GNU C++.  To debug it, define SPEW_DEBUG\n-   when compiling cp-parse.c and cp-spew.c.  */\n+   when compiling parse.c and spew.c.  */\n \n #include \"config.h\"\n #include <stdio.h>\n@@ -50,7 +50,7 @@ static struct token hack_scope ();\n static tree hack_ptype ();\n static tree hack_more_ids ();\n \n-/* From cp-lex.c: */\n+/* From lex.c: */\n /* the declaration found for the last IDENTIFIER token read in.\n    yylex must look this up to detect typedefs, which get token type TYPENAME,\n    so it is left around in case the identifier is not a typedef but is\n@@ -74,7 +74,7 @@ static char follows_typename[END_OF_SAVED_INPUT+1];\n static char follows_identifier[END_OF_SAVED_INPUT+1];\n \n /* This is a hack!!! TEMPLATE_TYPE_SEEN_BEFORE_SCOPE consists of the name\n- * of the last template_type parsed in cp-parse.y if it is followed by a\n+ * of the last template_type parsed in parse.y if it is followed by a\n  * scope operator.  It will be reset inside the next invocation of yylex().\n  * This is used for recognizing nested types inside templates.\n  * - niklas@appli.se */\n@@ -271,7 +271,7 @@ probe_obstack (h, obj, nlevels)\n   return nlevels != 0 && lp != 0;\n }\n \n-/* from cp-lex.c: */\n+/* from lex.c: */\n /* Value is 1 if we should try to make the next identifier look like a\n    typename (when it may be a local variable or a class variable).\n    Value is 0 if we treat this name in a default fashion.\n@@ -306,7 +306,7 @@ yylex()\n \t{\n \t  /* Sync back again, leaving SCOPE on the token stream, because we\n \t   * failed to substitute the original SCOPE token with a\n-\t   * SCOPED_TYPENAME.  See rule \"template_type\" in cp-parse.y */\n+\t   * SCOPED_TYPENAME.  See rule \"template_type\" in parse.y */\n \t  consume_token ();\n \t}\n       else\n@@ -364,7 +364,6 @@ yylex()\n       goto retry;\n \n     case IDENTIFIER:\n-      /* Note: this calls arbitrate_lookup.  */\n       trrr = lookup_name (tmp_token.yylval.ttype, -2);\n       if (trrr)\n \t{\n@@ -436,6 +435,7 @@ yylex()\n     case TYPESPEC:\n       consume_token ();\n     finish_typename_processing:\n+#if 0\n       /* Now see if we should insert a START_DECLARATOR token.\n          Here are the cases caught:\n \n@@ -487,6 +487,7 @@ yylex()\n \t      nth_token (0)->yychar = START_DECLARATOR;\n \t    }\n \t}\n+#endif\n       break;\n \n #if 0\n@@ -708,6 +709,7 @@ frob_identifier ()\n   return rt;\n }\n \n+#if 0\n /* When this function is called, nth_token(0) is the current\n    token we are scanning.  This means that the next token we'll\n    scan is nth_token (1).  Usually the next token we'll scan\n@@ -874,6 +876,7 @@ arbitrate_lookup (name, exp_decl, type_decl)\n       return t;\n     }\n }\n+#endif\n \n /* now returns decl_node */\n \n@@ -1125,7 +1128,7 @@ static int\n debug_yychar (yy)\n      int yy;\n {\n-  /* In cp-parse.y: */\n+  /* In parse.y: */\n   extern char *debug_yytranslate ();\n   \n   int i;"}, {"sha": "785033cf86dde3a66d433f0b108b99c3860362ca", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 40, "deletions": 67, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -83,13 +83,8 @@ lvalue_p (ref)\n       case OFFSET_REF:\n \tif (TREE_CODE (TREE_OPERAND (ref, 1)) == FUNCTION_DECL)\n \t  return 1;\n-\tif (TREE_CODE (TREE_OPERAND (ref, 1)) == VAR_DECL)\n-\t  if (TREE_READONLY (ref) && ! TREE_STATIC (ref)\n-\t      && DECL_LANG_SPECIFIC (ref)\n-\t      && DECL_IN_AGGR_P (ref))\n-\t    return 0;\n-\t  else\n-\t    return 1;\n+\treturn lvalue_p (TREE_OPERAND (ref, 0))\n+\t  && lvalue_p (TREE_OPERAND (ref, 1));\n \tbreak;\n \n       case ADDR_EXPR:\n@@ -940,42 +935,52 @@ hash_chainon (list1, list2)\n \t\t\t  hash_chainon (TREE_CHAIN (list1), list2));\n }\n \n-tree\n-get_decl_list (value)\n+static tree\n+get_identifier_list (value)\n      tree value;\n {\n-  tree list = NULL_TREE;\n-\n-  if (TREE_CODE (value) == IDENTIFIER_NODE)\n+  tree list = IDENTIFIER_AS_LIST (value);\n+  if (list != NULL_TREE\n+      && (TREE_CODE (list) != TREE_LIST\n+\t  || TREE_VALUE (list) != value))\n+    list = NULL_TREE;\n+  else if (IDENTIFIER_HAS_TYPE_VALUE (value)\n+\t   && TREE_CODE (IDENTIFIER_TYPE_VALUE (value)) == RECORD_TYPE)\n     {\n-      list = IDENTIFIER_AS_LIST (value);\n-      if (list != NULL_TREE\n-\t  && (TREE_CODE (list) != TREE_LIST\n-\t      || TREE_VALUE (list) != value))\n+      tree type = IDENTIFIER_TYPE_VALUE (value);\n+\n+      if (TYPE_PTRMEMFUNC_P (type))\n \tlist = NULL_TREE;\n-      else if (IDENTIFIER_HAS_TYPE_VALUE (value)\n-\t       && TREE_CODE (IDENTIFIER_TYPE_VALUE (value)) == RECORD_TYPE)\n+      else if (type == current_class_type)\n+\t/* Don't mess up the constructor name.  */\n+\tlist = tree_cons (NULL_TREE, value, NULL_TREE);\n+      else\n \t{\n \t  register tree id;\n-\t  tree type = IDENTIFIER_TYPE_VALUE (value);\n-\n-\t  if (TYPE_PTRMEMFUNC_P (type))\n-\t    list = NULL_TREE;\n+\t  /* This will return the correct thing for regular types,\n+\t     nested types, and templates.  Yay! */\n+\t  if (TYPE_NESTED_NAME (type))\n+\t    id = TYPE_NESTED_NAME (type);\n \t  else\n-\t    {\n-\t      /* This will return the correct thing for regular types,\n-\t\t nested types, and templates.  Yay! */\n-\t      if (DECL_NESTED_TYPENAME (TYPE_NAME (type)))\n-\t\tvalue = DECL_NESTED_TYPENAME (TYPE_NAME (type));\n-\t      id = value;\n-\n-\t      if (CLASSTYPE_ID_AS_LIST (type) == NULL_TREE)\n-\t\tCLASSTYPE_ID_AS_LIST (type) = perm_tree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t      id, NULL_TREE);\n-\t      list = CLASSTYPE_ID_AS_LIST (type);\n-\t    }\n+\t    id = TYPE_IDENTIFIER (type);\n+\n+\t  if (CLASSTYPE_ID_AS_LIST (type) == NULL_TREE)\n+\t    CLASSTYPE_ID_AS_LIST (type)\n+\t      = perm_tree_cons (NULL_TREE, id, NULL_TREE);\n+\t  list = CLASSTYPE_ID_AS_LIST (type);\n \t}\n     }\n+  return list;\n+}\n+\n+tree\n+get_decl_list (value)\n+     tree value;\n+{\n+  tree list = NULL_TREE;\n+\n+  if (TREE_CODE (value) == IDENTIFIER_NODE)\n+    list = get_identifier_list (value);\n   else if (TREE_CODE (value) == RECORD_TYPE\n \t   && TYPE_LANG_SPECIFIC (value))\n     list = CLASSTYPE_AS_LIST (value);\n@@ -1003,39 +1008,7 @@ list_hash_lookup_or_cons (value)\n   tree list = NULL_TREE;\n \n   if (TREE_CODE (value) == IDENTIFIER_NODE)\n-    {\n-      list = IDENTIFIER_AS_LIST (value);\n-      if (list != NULL_TREE\n-\t  && (TREE_CODE (list) != TREE_LIST\n-\t      || TREE_VALUE (list) != value))\n-\tlist = NULL_TREE;\n-      else if (IDENTIFIER_HAS_TYPE_VALUE (value)\n-\t       && TREE_CODE (IDENTIFIER_TYPE_VALUE (value)) == RECORD_TYPE)\n-\t{\n-\t  /* If the type name and constructor name are different, don't\n-\t     write constructor name into type.  */\n-\t  if (identifier_typedecl_value (value)\n-\t      && identifier_typedecl_value (value) != constructor_name (value))\n-\t    list = tree_cons (NULL_TREE, value, NULL_TREE);\n-\t  else\n-\t    {\n-\t      tree type = IDENTIFIER_TYPE_VALUE (value);\n-\t      if (TYPE_PTRMEMFUNC_P (type))\n-\t\tlist = NULL_TREE;\n-\t      else\n-\t\t{\n-\t\t  if (CLASSTYPE_ID_AS_LIST (type) == NULL_TREE)\n-\t\t    {\n-\t\t      /* Not just `value', which could be a template parm.  */\n-\t\t      tree id = DECL_NAME (TYPE_NAME (type));\n-\t\t      CLASSTYPE_ID_AS_LIST (type) =\n-\t\t\tperm_tree_cons (NULL_TREE, id, NULL_TREE);\n-\t\t    }\n-\t\t  list = CLASSTYPE_ID_AS_LIST (type);\n-\t\t}\n-\t    }\n-\t}\n-    }\n+    list = get_identifier_list (value);\n   else if (TREE_CODE (value) == TYPE_DECL\n \t   && TREE_CODE (TREE_TYPE (value)) == RECORD_TYPE\n \t   && TYPE_LANG_SPECIFIC (TREE_TYPE (value)))"}, {"sha": "f7f1505cce13ee28024f63c107083616be82d449", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 190, "deletions": 97, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -541,10 +541,10 @@ comptypes (type1, type2, strict)\n \tt1 = type_for_size (TYPE_PRECISION (t1), 1);\n       if (TREE_CODE (t2) == ENUMERAL_TYPE)\n \tt2 = type_for_size (TYPE_PRECISION (t2), 1);\n-    }\n \n-  if (t1 == t2)\n-    return 1;\n+      if (t1 == t2)\n+\treturn 1;\n+    }\n \n   /* Different classes of types can't be compatible.  */\n \n@@ -643,6 +643,8 @@ comptypes (type1, type2, strict)\n       /* Target types must match incl. qualifiers.  */\n       return comp_array_types (comptypes, t1, t2, strict);\n \n+    case TEMPLATE_TYPE_PARM:\n+      return 1;\n     }\n   return 0;\n }\n@@ -2109,8 +2111,15 @@ get_member_function_from_ptrfunc (instance_ptrptr, instance, function)\n       tree e2;\n       tree e3;\n       tree aref, vtbl;\n+      tree aux_delta;\n \n-      vtbl = build1 (ADDR_EXPR, ptr_type_node, instance);\n+      /* convert down to the right base, before using the instance. */\n+      instance = convert_pointer_to_real (TYPE_METHOD_BASETYPE (TREE_TYPE (fntype)),\n+\t\t\t\t\t  build_unary_op (ADDR_EXPR, instance, 0));\n+      if (instance == error_mark_node)\n+\treturn instance;\n+\n+      vtbl = convert_pointer_to (ptr_type_node, instance);\n       vtbl = build (PLUS_EXPR,\n \t\t    build_pointer_type (build_pointer_type (vtable_entry_type)),\n \t\t    vtbl, convert (sizetype, delta2));\n@@ -2398,6 +2407,12 @@ convert_arguments (return_loc, typelist, values, fndecl, flags)\n \t      val = integer_zero_node;\n \t    }\n \t}\n+      else if (TREE_CODE (val) == OFFSET_REF\n+\t    && TREE_CODE (TREE_TYPE (val)) == METHOD_TYPE)\n+\t{\n+\t  /* This is unclean.  Should be handled elsewhere. */\n+\t  val = build_unary_op (ADDR_EXPR, val, 0);\n+\t}\n       else if (TREE_CODE (val) == OFFSET_REF)\n \tval = resolve_offset_ref (val);\n \n@@ -3075,7 +3090,11 @@ build_binary_op_nodefault (code, op0, op1, error_code)\n \t    }\n \t  else\n \t    index1 = integer_neg_one_node;\n-\t  op1 = build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type0), op1);\n+\t  {\n+\t    tree nop1 = build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type0), op1);\n+\t    TREE_CONSTANT (nop1) = TREE_CONSTANT (op1);\n+\t    op1 = nop1;\n+\t  }\n \t  e1 = build_binary_op (EQ_EXPR, index0, index1, 1);\n \t  e2 = build_binary_op (NE_EXPR, index1, integer_neg_one_node, 1);\n \t  e2 = build_binary_op (TRUTH_ANDIF_EXPR, e2, build_binary_op (EQ_EXPR, delta20, delta21, 1), 1);\n@@ -3577,11 +3596,14 @@ build_component_addr (arg, argtype, msg)\n \n   if (TREE_CODE (field) == FIELD_DECL\n       && TYPE_USES_COMPLEX_INHERITANCE (basetype))\n-    /* Can't convert directly to ARGTYPE, since that\n-       may have the same pointer type as one of our\n-       baseclasses.  */\n-    rval = build1 (NOP_EXPR, argtype,\n-\t\t   convert_pointer_to (basetype, rval));\n+    {\n+      /* Can't convert directly to ARGTYPE, since that\n+\t may have the same pointer type as one of our\n+\t baseclasses.  */\n+      rval = build1 (NOP_EXPR, argtype,\n+\t\t     convert_pointer_to (basetype, rval));\n+      TREE_CONSTANT (rval) == TREE_CONSTANT (TREE_OPERAND (rval, 0));\n+    }\n   else\n     /* This conversion is harmless.  */\n     rval = convert (argtype, rval);\n@@ -4787,20 +4809,6 @@ build_c_cast (type, expr)\n \t}\n     }\n \n-  /* When converting into a reference type, just convert into a pointer to\n-     the new type and deference it.  While this is not exactly what ARM 5.4\n-     calls for [why not? -jason], it is pretty close for now.\n-     (int &)ri ---> *(int*)&ri  */\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    {\n-      value = build_unary_op (ADDR_EXPR, value, 0);\n-      if (value != error_mark_node)\n-\tvalue = convert (build_pointer_type (TREE_TYPE (type)), value);\n-      if (value != error_mark_node)\n-\tvalue = build_indirect_ref (value, \"reference conversion\");\n-      return value;\n-    }\n-\n   if (IS_SIGNATURE (type))\n     {\n       error (\"cast specifies signature type\");\n@@ -5819,69 +5827,164 @@ language_lvalue_valid (exp)\n   return 1;\n }\n \f\n+/* Get differnce in deltas for different pointer to member function\n+   types.  Return inetger_zero_node, if FROM cannot be converted to a\n+   TO type.  If FORCE is true, then allow reverse conversions as well.  */\n+static tree\n+get_delta_difference (from, to, force)\n+     tree from, to;\n+{\n+  tree delta = integer_zero_node;\n+  tree binfo;\n+  \n+  if (to == from)\n+    return delta;\n+\n+  binfo = get_binfo (from, to, 1);\n+  if (binfo == error_mark_node)\n+    {\n+      error (\"   in pointer to member function conversion\");\n+      return delta;\n+    }\n+  if (binfo == 0)\n+    {\n+      if (!force)\n+\t{\n+\t  error_not_base_type (from, to);\n+\t  error (\"   in pointer to member function conversion\");\n+\t  return delta;\n+\t}\n+      binfo = get_binfo (to, from, 1);\n+      if (binfo == error_mark_node)\n+\t{\n+\t  error (\"   in pointer to member function conversion\");\n+\t  return delta;\n+\t}\n+      if (binfo == 0)\n+\t{\n+\t  error (\"cannot convert pointer to member of type %T to unrelated pointer to member of type %T\", from, to);\n+\t  return delta;\n+\t}\n+      if (TREE_VIA_VIRTUAL (binfo))\n+\t{\n+\t  warning (\"pointer to member conversion from virtual base class will only work if your very careful\");\n+\t}\n+      return fold (size_binop (MINUS_EXPR,\n+\t\t\t       integer_zero_node,\n+\t\t\t       BINFO_OFFSET (binfo)));\n+    }\n+  if (TREE_VIA_VIRTUAL (binfo))\n+    {\n+      warning (\"pointer to member conversion from virtual base class will only work if your very careful\");\n+    }\n+  return BINFO_OFFSET (binfo);\n+}\n+\n /* Build a constructor for a pointer to member function.  It can be\n    used to initialize global variables, local variable, or used\n    as a value in expressions.  TYPE is the POINTER to METHOD_TYPE we\n    want to be.\n \n    If FORCE is non-zero, then force this conversion, even if\n    we would rather not do it.  Usually set when using an explicit\n-   cast.  */\n+   cast.\n+\n+   Return error_mark_node, if something goes wrong.  */\n \n tree\n build_ptrmemfunc (type, pfn, force)\n      tree type, pfn;\n      int force;\n {\n-  tree index;\n+  tree index = integer_zero_node;\n   tree delta = integer_zero_node;\n   tree delta2 = integer_zero_node;\n   tree vfield_offset;\n   tree npfn;\n   tree u;\n \n-  /* Handle null pointer to member function conversions. */\n-  if (integer_zerop (pfn))\n-    {\n-      pfn = build_c_cast (type, integer_zero_node);\n-      u = build_nt (CONSTRUCTOR, 0, tree_cons (pfn_identifier, pfn, NULL_TREE));\n-      return build_nt (CONSTRUCTOR, 0, tree_cons (NULL_TREE, integer_zero_node,\n-\t\t\t\t\t\t  tree_cons (NULL_TREE, integer_zero_node,\n-\t\t\t\t\t\t\t     tree_cons (NULL_TREE, u, NULL_TREE))));\n-    }\n-\n-  /* Allow pointer to member conversions here. */\n-  if (type != TREE_TYPE (pfn))\n+  /* Handle multiple conversions of pointer to member fucntions. */\n+  if (TYPE_PTRMEMFUNC_P (TREE_TYPE (pfn)))\n     {\n-      tree binfo\n-\t= get_binfo (TYPE_METHOD_BASETYPE (TREE_TYPE (TREE_TYPE (pfn))),\n-\t\t     TYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n-\t\t     1);\n-      if (binfo == error_mark_node)\n-\t{\n-\t  error (\"   in pointer to member function conversion\");\n-\t  return NULL_TREE;\n-\t}\n-      if (binfo == 0)\n+      tree ndelta, ndelta2, nindex;\n+      /* Is is already the right type? */\n+#if 0\n+      /* Sorry, can't do this, the backend is too stupid. */\n+      if (TYPE_METHOD_BASETYPE (TREE_TYPE (type))\n+\t  == TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))))\n \t{\n-\t  if (!force)\n+\t  if (type != TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))\n \t    {\n-\t      error_not_base_type (TYPE_METHOD_BASETYPE (TREE_TYPE (TREE_TYPE (pfn))),\n-\t\t\t\t   TYPE_METHOD_BASETYPE (TREE_TYPE (type)));\n-\t      error (\"   in pointer to member function conversion\");\n-\t      return NULL_TREE;\n+\t      npfn = build1 (NOP_EXPR, TYPE_GET_PTRMEMFUNC_TYPE (type), pfn);\n+\t      TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n \t    }\n-\t  /* Just something handy with an offset of zero. */\n-\t  binfo = TYPE_BINFO (TYPE_METHOD_BASETYPE (TREE_TYPE (type)));\n+\t  return pfn;\n \t}\n-      if (TREE_VIA_VIRTUAL (binfo))\n+#else\n+      if (type == TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))\n+\treturn pfn;\n+#endif\n+\n+      if (TREE_CODE (pfn) != CONSTRUCTOR)\n \t{\n-\t  sorry (\"pointer to member conversion from virtual base class\");\n+\t  tree e1, e2, e3;\n+\t  ndelta = convert (sizetype, build_component_ref (pfn, delta_identifier, 0, 0));\n+\t  ndelta2 = convert (sizetype, DELTA2_FROM_PTRMEMFUNC (pfn));\n+\t  index = build_component_ref (pfn, index_identifier, 0, 0);\n+\t  delta = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))),\n+\t\t\t\t\tTYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n+\t\t\t\t\tforce);\n+\t  delta = fold (size_binop (PLUS_EXPR, delta, ndelta));\n+\t  delta2 = fold (size_binop (PLUS_EXPR, ndelta2, delta2));\n+\t  e1 = fold (build (GT_EXPR, integer_type_node, index, integer_zero_node));\n+\t  \n+\t  u = build_nt (CONSTRUCTOR, 0, tree_cons (delta2_identifier, delta2, NULL_TREE));\n+\t  u = build_nt (CONSTRUCTOR, 0, tree_cons (NULL_TREE, delta,\n+\t\t\t\t\t\t   tree_cons (NULL_TREE, index,\n+\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n+\t  e2 = digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n+\n+\t  pfn = PFN_FROM_PTRMEMFUNC (pfn);\n+\t  npfn = build1 (NOP_EXPR, type, pfn);\n+\t  TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n+\n+\t  u = build_nt (CONSTRUCTOR, 0, tree_cons (pfn_identifier, npfn, NULL_TREE));\n+\t  u = build_nt (CONSTRUCTOR, 0, tree_cons (NULL_TREE, delta,\n+\t\t\t\t\t\t   tree_cons (NULL_TREE, index,\n+\t\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n+\t  e3 = digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n+\t  return build_conditional_expr (e1, e2, e3);\n+\t}\n+\n+      ndelta = TREE_VALUE (CONSTRUCTOR_ELTS (pfn));\n+      nindex = TREE_VALUE (TREE_CHAIN (CONSTRUCTOR_ELTS (pfn)));\n+      npfn = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (CONSTRUCTOR_ELTS (pfn))));\n+      npfn = TREE_VALUE (CONSTRUCTOR_ELTS (npfn));\n+      if (integer_zerop (nindex))\n+\tpfn = integer_zero_node;\n+      else\n+\t{\n+\t  sorry (\"value casting of varible nonnull pointer to member functions not supported\");\n+\t  return error_mark_node;\n \t}\n-      delta = BINFO_OFFSET (binfo);\n-      delta2 = size_binop (PLUS_EXPR, delta2, delta);\n     }\n-  \n+\n+  /* Handle null pointer to member function conversions. */\n+  if (integer_zerop (pfn))\n+    {\n+      pfn = build_c_cast (type, integer_zero_node);\n+      u = build_nt (CONSTRUCTOR, 0, tree_cons (pfn_identifier, pfn, NULL_TREE));\n+      u = build_nt (CONSTRUCTOR, 0, tree_cons (NULL_TREE, integer_zero_node,\n+\t\t\t\t\t       tree_cons (NULL_TREE, integer_zero_node,\n+\t\t\t\t\t\t\t  tree_cons (NULL_TREE, u, NULL_TREE))));\n+      return digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n+    }\n+\n+  /* Allow pointer to member conversions here. */\n+  delta = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TREE_TYPE (pfn))),\n+\t\t\t\tTYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n+\t\t\t\tforce);\n+  delta2 = fold (size_binop (PLUS_EXPR, delta2, delta));\n \n   if (TREE_CODE (TREE_OPERAND (pfn, 0)) != FUNCTION_DECL)\n     warning (\"assuming pointer to member function is non-virtual\");\n@@ -5890,33 +5993,32 @@ build_ptrmemfunc (type, pfn, force)\n       && DECL_VINDEX (TREE_OPERAND (pfn, 0)))\n     {\n       /* Find the offset to the vfield pointer in the object. */\n-      vfield_offset = TYPE_METHOD_BASETYPE (TREE_TYPE (TREE_TYPE (pfn)));\n-      vfield_offset = CLASSTYPE_VFIELD (vfield_offset);\n-      vfield_offset = DECL_FIELD_BITPOS (vfield_offset);\n-      vfield_offset = size_binop (FLOOR_DIV_EXPR, vfield_offset, size_int (BITS_PER_UNIT));\n+      vfield_offset = get_binfo (DECL_CONTEXT (TREE_OPERAND (pfn, 0)),\n+\t\t\t\t DECL_CLASS_CONTEXT (TREE_OPERAND (pfn, 0)),\n+\t\t\t\t 0);\n+      vfield_offset = get_vfield_offset (vfield_offset);\n       delta2 = size_binop (PLUS_EXPR, vfield_offset, delta2);\n \n       /* Map everything down one to make room for the null pointer to member.  */\n       index = size_binop (PLUS_EXPR,\n \t\t\t  DECL_VINDEX (TREE_OPERAND (pfn, 0)),\n \t\t\t  integer_one_node);\n       u = build_nt (CONSTRUCTOR, 0, tree_cons (delta2_identifier, delta2, NULL_TREE));\n-\n-      return build_nt (CONSTRUCTOR, 0, tree_cons (NULL_TREE, delta,\n-\t\t\t\t\t\t  tree_cons (NULL_TREE, index,\n-\t\t\t\t\t\t\t     tree_cons (NULL_TREE, u, NULL_TREE))));\n     }\n   else\n-    index = size_binop (MINUS_EXPR, integer_zero_node, integer_one_node);\n+    {\n+      index = fold (size_binop (MINUS_EXPR, integer_zero_node, integer_one_node));\n \n-  npfn = build1 (NOP_EXPR, type, pfn);\n-  TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n+      npfn = build1 (NOP_EXPR, type, pfn);\n+      TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n \n-  u = build_nt (CONSTRUCTOR, 0, tree_cons (pfn_identifier, npfn, NULL_TREE));\n+      u = build_nt (CONSTRUCTOR, 0, tree_cons (pfn_identifier, npfn, NULL_TREE));\n+    }\n \n-  return build_nt (CONSTRUCTOR, 0, tree_cons (NULL_TREE, delta,\n-\t\t\t\t\t      tree_cons (NULL_TREE, index,\n-\t\t\t\t\t\t\t tree_cons (NULL_TREE, u, NULL_TREE))));\n+  u = build_nt (CONSTRUCTOR, 0, tree_cons (NULL_TREE, delta,\n+\t\t\t\t\t   tree_cons (NULL_TREE, index,\n+\t\t\t\t\t\t      tree_cons (NULL_TREE, u, NULL_TREE))));\n+  return digest_init (TYPE_GET_PTRMEMFUNC_TYPE (type), u, (tree*)0);\n }\n \n /* Convert value RHS to type TYPE as preparation for an assignment\n@@ -6125,21 +6227,6 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t    else\n \t      pedwarn (\"ANSI C++ forbids implicit conversion from `void *' in %s\",\n \t\t       errtype);\n-\t  else if (pedantic\n-\t      && ((TYPE_MAIN_VARIANT (ttl) == void_type_node\n-\t\t   && (TREE_CODE (ttr) == FUNCTION_TYPE\n-\t\t       || TREE_CODE (ttr) == METHOD_TYPE))\n-\t\t  ||\n-\t\t  (TYPE_MAIN_VARIANT (ttr) == void_type_node\n-\t\t   && (TREE_CODE (ttl) == FUNCTION_TYPE\n-\t\t       || TREE_CODE (ttl) == METHOD_TYPE))))\n-\t    {\n-\t      if (fndecl)\n-\t\tcp_pedwarn (\"passing `%T' as argument %P of `%D'\",\n-\t\t\t    rhstype, parmnum, fndecl);\n-\t      else\n-\t\tcp_pedwarn (\"%s to `void *' from `%T'\", errtype, rhstype);\n-\t    }\n \t  /* Const and volatile mean something different for function types,\n \t     so the usual warnings are not appropriate.  */\n \t  else if ((TREE_CODE (ttr) != FUNCTION_TYPE && TREE_CODE (ttr) != METHOD_TYPE)\n@@ -6334,14 +6421,12 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n   else if (((coder == POINTER_TYPE && TREE_CODE (rhs) == ADDR_EXPR\n \t     && TREE_CODE (rhstype) == POINTER_TYPE\n \t     && TREE_CODE (TREE_TYPE (rhstype)) == METHOD_TYPE)\n-\t    || integer_zerop (rhs))\n+\t    || integer_zerop (rhs)\n+\t    || TYPE_PTRMEMFUNC_P (TREE_TYPE (rhs)))\n \t   && TYPE_PTRMEMFUNC_P (type))\n     {\n       /* compatible pointer to member functions. */\n-      rhs = build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), rhs, 0);\n-      if (rhs == 0)\n-\treturn error_mark_node;\n-      return digest_init (type, rhs, (tree *)0);\n+      return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), rhs, 0);\n     }\n   else if (codel == ERROR_MARK || coder == ERROR_MARK)\n     return error_mark_node;\n@@ -6353,7 +6438,11 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n     /* Force an abort.  */\n     my_friendly_assert (codel != REFERENCE_TYPE, 317);\n   else if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (rhs)))\n-    return build1 (NOP_EXPR, type, rhs);\n+    {\n+      tree nrhs = build1 (NOP_EXPR, type, rhs);\n+      TREE_CONSTANT (nrhs) = TREE_CONSTANT (rhs);\n+      return nrhs;\n+    }\n   else if (TYPE_HAS_CONSTRUCTOR (type) || IS_AGGR_TYPE (TREE_TYPE (rhs)))\n     return convert (type, rhs);\n \n@@ -6512,7 +6601,11 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n \t  if (TREE_CODE (TREE_TYPE (rhs)) == REFERENCE_TYPE)\n \t    rhs = convert_from_reference (rhs);\n \t  if (type != rhstype)\n-\t    return build1 (NOP_EXPR, type, rhs);\n+\t    {\n+\t      tree nrhs = build1 (NOP_EXPR, type, rhs);\n+\t      TREE_CONSTANT (nrhs) = TREE_CONSTANT (rhs);\n+\t      rhs = nrhs;\n+\t    }\n \t  return rhs;\n \t}\n "}, {"sha": "f9f9be7f9b9ca1dc8cbabfd948e6118bd3b3099d", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51c184be092792a7df35662dee52448c7b17fcb3/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=51c184be092792a7df35662dee52448c7b17fcb3", "patch": "@@ -329,7 +329,7 @@ ack (s, v, v2)\n    silly.  So instead, we just do the equivalent of a call to fatal in the\n    same situation (call exit).  */\n \n-/* First used: 0 (reserved), Last used: 355.  Free: 5.  */\n+/* First used: 0 (reserved), Last used: 355.  */\n \n static int abortcount = 0;\n \n@@ -641,13 +641,17 @@ digest_init (type, init, tail)\n   if (TREE_CODE (init) == NON_LVALUE_EXPR)\n     init = TREE_OPERAND (init, 0);\n \n+  if (init && TREE_TYPE (init) && TYPE_PTRMEMFUNC_P (type))\n+    init = default_conversion (init);\n+\n   if (init && TYPE_PTRMEMFUNC_P (type)\n       && ((TREE_CODE (init) == ADDR_EXPR\n \t   && TREE_CODE (TREE_TYPE (init)) == POINTER_TYPE\n \t   && TREE_CODE (TREE_TYPE (TREE_TYPE (init))) == METHOD_TYPE)\n-\t  || integer_zerop (init)))\n+\t  || integer_zerop (init)\n+\t  || (TREE_TYPE (init) && TYPE_PTRMEMFUNC_P (TREE_TYPE (init)))))\n     {\n-      init = build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), init, 0);\n+      return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), init, 0);\n     }\n \n   raw_constructor = TREE_CODE (init) == CONSTRUCTOR && TREE_TYPE (init) == 0;\n@@ -999,19 +1003,8 @@ process_init_constructor (type, init, elts)\n \t    {\n \t      tree tail1 = tail;\n \n-\t      if (TYPE_PTRMEMFUNC_P (TREE_TYPE (field)))\n-\t\t{\n-\t\t  tree t\n-\t\t    = build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (field)),\n-\t\t\t\t\tdefault_conversion (TREE_VALUE (tail)),\n-\t\t\t\t\t0);\n-\t\t  if (t == NULL_TREE)\n-\t\t    return error_mark_node;\n-\t\t  next1 = digest_init (TREE_TYPE (field), t, &tail1);\n-\t\t}\n-\t      else\n-\t\tnext1 = digest_init (TREE_TYPE (field),\n-\t\t\t\t     TREE_VALUE (tail), &tail1);\n+\t      next1 = digest_init (TREE_TYPE (field),\n+\t\t\t\t   TREE_VALUE (tail), &tail1);\n \t      my_friendly_assert (tail1 == 0\n \t\t\t\t  || TREE_CODE (tail1) == TREE_LIST, 320);\n \t      tail = tail1;\n@@ -1377,22 +1370,22 @@ build_m_component_ref (datum, component)\n   if (datum == error_mark_node || component == error_mark_node)\n     return error_mark_node;\n \n-  if (! IS_AGGR_TYPE (objtype))\n-    {\n-      cp_error (\"cannot apply member pointer `%D' to `%E'\", component, datum);\n-      cp_error (\"which is of non-aggregate type `%T'\", objtype);\n-      return error_mark_node;\n-    }\n-  \n   if (TREE_CODE (type) != OFFSET_TYPE && TREE_CODE (type) != METHOD_TYPE)\n     {\n-      error (\"non-member type composed with object\");\n+      cp_error (\"`%E' cannot be used as a member pointer, since it is of type `%T'\", component, type);\n       return error_mark_node;\n     }\n \n   if (TREE_CODE (objtype) == REFERENCE_TYPE)\n     objtype = TREE_TYPE (objtype);\n \n+  if (! IS_AGGR_TYPE (objtype))\n+    {\n+      cp_error (\"cannot apply member pointer `%E' to `%E'\", component, datum);\n+      cp_error (\"which is of non-aggregate type `%T'\", objtype);\n+      return error_mark_node;\n+    }\n+  \n   if (! comptypes (TYPE_METHOD_BASETYPE (type), objtype, 0))\n     {\n       cp_error (\"member type `%T::' incompatible with object type `%T'\","}]}