{"sha": "6f312d18d4788838bbd51c409a29b11ad8ccf009", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYzMTJkMThkNDc4ODgzOGJiZDUxYzQwOWEyOWIxMWFkOGNjZjAwOQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-05-22T18:16:39Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-05-22T18:16:39Z"}, "message": "[multiple changes]\n\n2004-05-22  Andrew Pinski  <pinskia@physics.uc.edu>\n\n\t* c-common.c (c_common_truthvalue_conversion): Handle\n\tUNEQ_EXPR, UNLE_EXPR, UNGE_EXPR, UNLT_EXPR, UNGT_EXPR,\n\tORDERED_EXPR, and UNORDERED_EXPR as comparison operators,\n\ti.e. set the type to truthvalue_type_node and return.\n\n2004-05-22  Zack Weinberg  <zack@codesourcery.com>\n\n       * tree.h (struct tree_decl): Add possibly_inlined bit.\n\t(DECL_POSSIBLY_INLINED): New accessor macro.\n\t* cgraph.h: Remove declaration of cgraph_inline_hash.\n\t* cgraph.c: Remove definition of cgraph_inline_hash.\n\t(hash_node): Revert to hashing DECL_UID.\n\t(eq_node): Take two pointers to cgraph_node structures.\n\tCompare DECL_UIDs.\n\t(cgraph_remove_node): Pass the node directly to htab_find_slot.\n\t(cgraph_varpool_hash_node): Rename hash_varpool_node;\n\thash on DECL_UID.\n\t(eq_cgraph_varpool_node): Rename eq_varpool_node; take two\n\tpointers to cgraph_varpool_node structures; compare DECL_UIDs.\n\t(cgraph_node): Allocate a temporary node on the stack, fill in\n\tits DECL field, and pass that to htab_find_slot.\n\t(cgraph_varpool_node): Likewise.\n\t(cgraph_function_possibly_inlined_p): If global info is ready,\n\treturn the DECL_POSSIBLY_INLINED bit.\n\t* cgraphunit.c (cgraph_mark_inline_edge): Set DECL_POSSIBLY_INLINED\n\tinstead of mucking with cgraph_inline_hash.\n\nFrom-SVN: r82140", "tree": {"sha": "409d944e4e6302902eb8e16c793a145c374d08c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/409d944e4e6302902eb8e16c793a145c374d08c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f312d18d4788838bbd51c409a29b11ad8ccf009", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f312d18d4788838bbd51c409a29b11ad8ccf009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f312d18d4788838bbd51c409a29b11ad8ccf009", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f312d18d4788838bbd51c409a29b11ad8ccf009/comments", "author": null, "committer": null, "parents": [{"sha": "c1c52409c7f80e9656eb8a1a9e09f7f29f1c866a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1c52409c7f80e9656eb8a1a9e09f7f29f1c866a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1c52409c7f80e9656eb8a1a9e09f7f29f1c866a"}], "stats": {"total": 105, "additions": 64, "deletions": 41}, "files": [{"sha": "2acb431be3d3d8c80c58dbbf61cf6f918d1c5299", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f312d18d4788838bbd51c409a29b11ad8ccf009/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f312d18d4788838bbd51c409a29b11ad8ccf009/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f312d18d4788838bbd51c409a29b11ad8ccf009", "patch": "@@ -1,3 +1,32 @@\n+2004-05-22  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\t* c-common.c (c_common_truthvalue_conversion): Handle\n+\tUNEQ_EXPR, UNLE_EXPR, UNGE_EXPR, UNLT_EXPR, UNGT_EXPR,\n+\tORDERED_EXPR, and UNORDERED_EXPR as comparison operators,\n+\ti.e. set the type to truthvalue_type_node and return.\n+\n+2004-05-22  Zack Weinberg  <zack@codesourcery.com>\n+\n+       * tree.h (struct tree_decl): Add possibly_inlined bit.\n+\t(DECL_POSSIBLY_INLINED): New accessor macro.\n+\t* cgraph.h: Remove declaration of cgraph_inline_hash.\n+\t* cgraph.c: Remove definition of cgraph_inline_hash.\n+\t(hash_node): Revert to hashing DECL_UID.\n+\t(eq_node): Take two pointers to cgraph_node structures.\n+\tCompare DECL_UIDs.\n+\t(cgraph_remove_node): Pass the node directly to htab_find_slot.\n+\t(cgraph_varpool_hash_node): Rename hash_varpool_node;\n+\thash on DECL_UID.\n+\t(eq_cgraph_varpool_node): Rename eq_varpool_node; take two\n+\tpointers to cgraph_varpool_node structures; compare DECL_UIDs.\n+\t(cgraph_node): Allocate a temporary node on the stack, fill in\n+\tits DECL field, and pass that to htab_find_slot.\n+\t(cgraph_varpool_node): Likewise.\n+\t(cgraph_function_possibly_inlined_p): If global info is ready,\n+\treturn the DECL_POSSIBLY_INLINED bit.\n+\t* cgraphunit.c (cgraph_mark_inline_edge): Set DECL_POSSIBLY_INLINED\n+\tinstead of mucking with cgraph_inline_hash.\n+\n 2004-05-22  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* doc/contrib.texi: Add g77 contributors."}, {"sha": "afd91827c9db1c3faf81310de04ce0fed5739253", "filename": "gcc/c-common.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f312d18d4788838bbd51c409a29b11ad8ccf009/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f312d18d4788838bbd51c409a29b11ad8ccf009/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=6f312d18d4788838bbd51c409a29b11ad8ccf009", "patch": "@@ -2582,8 +2582,10 @@ c_common_truthvalue_conversion (tree expr)\n \n   switch (TREE_CODE (expr))\n     {\n-    case EQ_EXPR:\n-    case NE_EXPR: case LE_EXPR: case GE_EXPR: case LT_EXPR: case GT_EXPR:\n+    case EQ_EXPR:   case NE_EXPR:   case UNEQ_EXPR:\n+    case LE_EXPR:   case GE_EXPR:   case LT_EXPR:   case GT_EXPR:\n+    case UNLE_EXPR: case UNGE_EXPR: case UNLT_EXPR: case UNGT_EXPR:\n+    case ORDERED_EXPR: case UNORDERED_EXPR:\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n     case TRUTH_AND_EXPR:"}, {"sha": "37008e2df7d2815716ce50096bca6c92202e5822", "filename": "gcc/cgraph.c", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f312d18d4788838bbd51c409a29b11ad8ccf009/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f312d18d4788838bbd51c409a29b11ad8ccf009/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=6f312d18d4788838bbd51c409a29b11ad8ccf009", "patch": "@@ -99,11 +99,6 @@ The varpool data structure:\n /* Hash table used to convert declarations into nodes.  */\n static GTY((param_is (struct cgraph_node))) htab_t cgraph_hash;\n \n-/* We destructively update the callgraph during inlining, thus we need to\n-   keep a separate table with information on whether inlining happened.\n-   ??? Do this with a bit in the DECL instead of a hash table.  */\n-htab_t cgraph_inline_hash;\n-\n /* The linked list of cgraph nodes.  */\n struct cgraph_node *cgraph_nodes;\n \n@@ -139,15 +134,17 @@ static int eq_node (const void *, const void *);\n static hashval_t\n hash_node (const void *p)\n {\n-  return htab_hash_pointer (((struct cgraph_node *) p)->decl);\n+  const struct cgraph_node *n = p;\n+  return (hashval_t) DECL_UID (n->decl);\n }\n \n /* Returns nonzero if P1 and P2 are equal.  */\n \n static int\n eq_node (const void *p1, const void *p2)\n {\n-  return (void *)((struct cgraph_node *) p1)->decl == p2;\n+  const struct cgraph_node *n1 = p1, *n2 = p2;\n+  return DECL_UID (n1->decl) == DECL_UID (n2->decl);\n }\n \n /* Allocate new callgraph node and insert it into basic data structures.  */\n@@ -171,18 +168,18 @@ cgraph_create_node (void)\n struct cgraph_node *\n cgraph_node (tree decl)\n {\n-  struct cgraph_node *node;\n-  struct cgraph_node **slot;\n+  struct cgraph_node key, *node, **slot;\n \n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     abort ();\n \n   if (!cgraph_hash)\n     cgraph_hash = htab_create_ggc (10, hash_node, eq_node, NULL);\n \n-  slot = (struct cgraph_node **)\n-    htab_find_slot_with_hash (cgraph_hash, decl,\n-\t\t\t      htab_hash_pointer (decl), INSERT);\n+  key.decl = decl;\n+\n+  slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, &key, INSERT);\n+\n   if (*slot)\n     return *slot;\n \n@@ -323,9 +320,7 @@ cgraph_remove_node (struct cgraph_node *node)\n     cgraph_nodes = node->next;\n   if (node->next)\n     node->next->previous = node->previous;\n-  slot = \n-    htab_find_slot_with_hash (cgraph_hash, node->decl,\n-\t\t\t      htab_hash_pointer (node->decl), NO_INSERT);\n+  slot = htab_find_slot (cgraph_hash, node, NO_INSERT);\n   if (*slot == node)\n     {\n       if (node->next_clone)\n@@ -526,35 +521,36 @@ dump_cgraph (FILE *f)\n /* Returns a hash code for P.  */\n \n static hashval_t\n-cgraph_varpool_hash_node (const void *p)\n+hash_varpool_node (const void *p)\n {\n-  return htab_hash_pointer (((struct cgraph_varpool_node *) p)->decl);\n+  const struct cgraph_varpool_node *n = p;\n+  return (hashval_t) DECL_UID (n->decl);\n }\n \n /* Returns nonzero if P1 and P2 are equal.  */\n \n static int\n-eq_cgraph_varpool_node (const void *p1, const void *p2)\n+eq_varpool_node (const void *p1, const void *p2)\n {\n-  return (void *)((struct cgraph_varpool_node *) p1)->decl == p2;\n+  const struct cgraph_varpool_node *n1 = p1, *n2 = p2;\n+  return DECL_UID (n1->decl) == DECL_UID (n2->decl);\n }\n \n /* Return cgraph_varpool node assigned to DECL.  Create new one when needed.  */\n struct cgraph_varpool_node *\n cgraph_varpool_node (tree decl)\n {\n-  struct cgraph_varpool_node *node;\n-  struct cgraph_varpool_node **slot;\n+  struct cgraph_varpool_node key, *node, **slot;\n \n   if (!DECL_P (decl) || TREE_CODE (decl) == FUNCTION_DECL)\n     abort ();\n \n   if (!cgraph_varpool_hash)\n-    cgraph_varpool_hash = htab_create_ggc (10, cgraph_varpool_hash_node,\n-\t\t\t\t           eq_cgraph_varpool_node, NULL);\n+    cgraph_varpool_hash = htab_create_ggc (10, hash_varpool_node,\n+\t\t\t\t           eq_varpool_node, NULL);\n+  key.decl = decl;\n   slot = (struct cgraph_varpool_node **)\n-    htab_find_slot_with_hash (cgraph_varpool_hash, decl,\n-\t\t\t      htab_hash_pointer (decl), INSERT);\n+    htab_find_slot (cgraph_varpool_hash, &key, INSERT);\n   if (*slot)\n     return *slot;\n   node = ggc_alloc_cleared (sizeof (*node));\n@@ -657,9 +653,7 @@ cgraph_function_possibly_inlined_p (tree decl)\n {\n   if (!cgraph_global_info_ready)\n     return (DECL_INLINE (decl) && !flag_really_no_inline);\n-  if (!cgraph_inline_hash)\n-    return false;\n-  return (htab_find_slot (cgraph_inline_hash, decl, NO_INSERT) != NULL);\n+  return DECL_POSSIBLY_INLINED (decl);\n }\n \n /* Create clone of E in the node N represented by CALL_EXPR the callgraph.  */"}, {"sha": "ed114cbbeecc50f473ef0d5c1a542a11a35bf529", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f312d18d4788838bbd51c409a29b11ad8ccf009/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f312d18d4788838bbd51c409a29b11ad8ccf009/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=6f312d18d4788838bbd51c409a29b11ad8ccf009", "patch": "@@ -151,8 +151,6 @@ extern FILE *cgraph_dump_file;\n \n extern GTY(()) int cgraph_varpool_n_nodes;\n extern GTY(()) struct cgraph_varpool_node *cgraph_varpool_nodes_queue;\n-extern GTY((param_is (union tree_node))) htab_t cgraph_inline_hash;\n-\n \n /* In cgraph.c  */\n void dump_cgraph (FILE *);"}, {"sha": "e1fe22f434a06e453d86376993bb804e2e02ddcd", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f312d18d4788838bbd51c409a29b11ad8ccf009/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f312d18d4788838bbd51c409a29b11ad8ccf009/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=6f312d18d4788838bbd51c409a29b11ad8ccf009", "patch": "@@ -1071,14 +1071,7 @@ cgraph_mark_inline_edge (struct cgraph_edge *e)\n   e->inline_failed = NULL;\n \n   if (!e->callee->global.inlined && flag_unit_at_a_time)\n-    {\n-      void **slot;\n-      if (!cgraph_inline_hash)\n-        cgraph_inline_hash = htab_create_ggc (42, htab_hash_pointer,\n-\t\t\t\t\t      htab_eq_pointer, NULL);\n-      slot = htab_find_slot (cgraph_inline_hash, e->callee->decl, INSERT);\n-      *slot = e->callee->decl;\n-    }\n+    DECL_POSSIBLY_INLINED (e->callee->decl) = true;\n   e->callee->global.inlined = true;\n \n   cgraph_clone_inlined_nodes (e, true);"}, {"sha": "f667a7974a040acd3adb60015ac425b9b887747f", "filename": "gcc/tree.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f312d18d4788838bbd51c409a29b11ad8ccf009/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f312d18d4788838bbd51c409a29b11ad8ccf009/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6f312d18d4788838bbd51c409a29b11ad8ccf009", "patch": "@@ -2212,6 +2212,12 @@ struct tree_type GTY(())\n #define DECL_NEEDS_TO_LIVE_IN_MEMORY_INTERNAL(DECL)\t\t\\\n   DECL_CHECK (DECL)->decl.needs_to_live_in_memory\n \n+/* Nonzero for a decl that cgraph has decided should be inlined into\n+   at least one call site.  It is not meaningful to look at this\n+   directly; always use cgraph_function_possibly_inlined_p.  */\n+#define DECL_POSSIBLY_INLINED(DECL) \\\n+  FUNCTION_DECL_CHECK (DECL)->decl.possibly_inlined\n+\n /* Enumerate visibility settings.  */\n \n enum symbol_visibility\n@@ -2276,7 +2282,8 @@ struct tree_decl GTY(())\n   unsigned lang_flag_7 : 1;\n \n   unsigned needs_to_live_in_memory : 1;\n-  /* 15 unused bits.  */\n+  unsigned possibly_inlined : 1;\n+  /* 14 unused bits.  */\n \n   union tree_decl_u1 {\n     /* In a FUNCTION_DECL for which DECL_BUILT_IN holds, this is"}]}