{"sha": "392f673a0cbbc5f0d31836ad7f90df7d9eb9dd17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkyZjY3M2EwY2JiYzVmMGQzMTgzNmFkN2Y5MGRmN2Q5ZWI5ZGQxNw==", "commit": {"author": {"name": "Matthew Heaney", "email": "heaney@adacore.com", "date": "2006-02-15T09:33:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:33:04Z"}, "message": "a-cgcaso.adb, [...]: Implemented using heapsort instead of quicksort.\n\n2006-02-13  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-cgcaso.adb, a-cgaaso.adb: Implemented using heapsort instead of\n\tquicksort.\n\nFrom-SVN: r111036", "tree": {"sha": "928bffb60a8df9299b553fa5c404d42bff177781", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/928bffb60a8df9299b553fa5c404d42bff177781"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/392f673a0cbbc5f0d31836ad7f90df7d9eb9dd17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/392f673a0cbbc5f0d31836ad7f90df7d9eb9dd17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/392f673a0cbbc5f0d31836ad7f90df7d9eb9dd17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/392f673a0cbbc5f0d31836ad7f90df7d9eb9dd17/comments", "author": null, "committer": null, "parents": [{"sha": "ffabcde5e102cd7cc8a283ddc89861a727226913", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffabcde5e102cd7cc8a283ddc89861a727226913", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffabcde5e102cd7cc8a283ddc89861a727226913"}], "stats": {"total": 308, "additions": 145, "deletions": 163}, "files": [{"sha": "b91de5fc55a9e5e0e773df0b0faef9ce13367810", "filename": "gcc/ada/a-cgaaso.adb", "status": "modified", "additions": 76, "deletions": 66, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392f673a0cbbc5f0d31836ad7f90df7d9eb9dd17/gcc%2Fada%2Fa-cgaaso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392f673a0cbbc5f0d31836ad7f90df7d9eb9dd17/gcc%2Fada%2Fa-cgaaso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cgaaso.adb?ref=392f673a0cbbc5f0d31836ad7f90df7d9eb9dd17", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -34,93 +34,103 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n+--  This algorithm was adapted from GNAT.Heap_Sort (see g-heasor.ad[sb]).\n+\n+with System;\n+\n procedure Ada.Containers.Generic_Anonymous_Array_Sort\n   (First, Last : Index_Type'Base)\n is\n-   Pivot, Lo, Mid, Hi : Index_Type;\n+   type T is range System.Min_Int .. System.Max_Int;\n \n-begin\n-   if Last <= First then\n-      return;\n-   end if;\n-\n-   Lo := First;\n-   Hi := Last;\n-\n-   if Last = Index_Type'Succ (First) then\n-      if not Less (Lo, Hi) then\n-         Swap (Lo, Hi);\n-      end if;\n-\n-      return;\n-   end if;\n-\n-   Mid := Index_Type'Val\n-     (Index_Type'Pos (Lo) +\n-      (Index_Type'Pos (Hi) - Index_Type'Pos (Lo)) / 2);\n-\n-   --  We need to figure out which case we have:\n-   --  x < y < z\n-   --  x < z < y\n-   --  z < x < y\n-   --  y < x < z\n-   --  y < z < x\n-   --  z < y < x\n-\n-   if Less (Lo, Mid) then\n-      if Less (Lo, Hi) then\n-         if Less (Mid, Hi) then\n-            Swap (Lo, Mid);\n+   function To_Index (J : T) return Index_Type;\n+   pragma Inline (To_Index);\n \n-         else\n-            Swap (Lo, Hi);\n+   function Lt (J, K : T) return Boolean;\n+   pragma Inline (Lt);\n \n-         end if;\n+   procedure Xchg (J, K : T);\n+   pragma Inline (Xchg);\n+\n+   procedure Sift (S : T);\n+\n+   --------------\n+   -- To_Index --\n+   --------------\n+\n+   function To_Index (J : T) return Index_Type is\n+      K : constant T'Base := Index_Type'Pos (First) + J - T'(1);\n+   begin\n+      return Index_Type'Val (K);\n+   end To_Index;\n \n-      else\n-         null;  --  lo is median\n-      end if;\n+   --------\n+   -- Lt --\n+   --------\n \n-   elsif Less (Lo, Hi) then\n-      null; --  lo is median\n+   function Lt (J, K : T) return Boolean is\n+   begin\n+      return Less (To_Index (J), To_Index (K));\n+   end Lt;\n \n-   elsif Less (Mid, Hi) then\n-      Swap (Lo, Hi);\n+   ----------\n+   -- Xchg --\n+   ----------\n \n-   else\n-      Swap (Lo, Mid);\n-   end if;\n+   procedure Xchg (J, K : T) is\n+   begin\n+      Swap (To_Index (J), To_Index (K));\n+   end Xchg;\n \n-   Pivot := Lo;\n-   Outer : loop\n+   Max : T := Index_Type'Pos (Last) - Index_Type'Pos (First) + T'(1);\n+\n+   ----------\n+   -- Sift --\n+   ----------\n+\n+   procedure Sift (S : T) is\n+      C      : T := S;\n+      Son    : T;\n+      Father : T;\n+\n+   begin\n       loop\n-         exit Outer when not (Pivot < Hi);\n+         Son := C + C;\n \n-         if Less (Hi, Pivot) then\n-            Swap (Hi, Pivot);\n-            Pivot := Hi;\n-            Lo := Index_Type'Succ (Lo);\n+         if Son < Max then\n+            if Lt (Son, Son + 1) then\n+               Son := Son + 1;\n+            end if;\n+         elsif Son > Max then\n             exit;\n-         else\n-            Hi := Index_Type'Pred (Hi);\n          end if;\n+\n+         Xchg (Son, C);\n+         C := Son;\n       end loop;\n \n-      loop\n-         exit Outer when not (Lo < Pivot);\n+      while C /= S loop\n+         Father := C / 2;\n \n-         if Less (Lo, Pivot) then\n-            Lo := Index_Type'Succ (Lo);\n+         if Lt (Father, C) then\n+            Xchg (Father, C);\n+            C := Father;\n          else\n-            Swap (Lo, Pivot);\n-            Pivot := Lo;\n-            Hi := Index_Type'Pred (Hi);\n             exit;\n          end if;\n       end loop;\n-   end loop Outer;\n+   end Sift;\n \n-   Generic_Anonymous_Array_Sort (First, Index_Type'Pred (Pivot));\n-   Generic_Anonymous_Array_Sort (Index_Type'Succ (Pivot), Last);\n+--  Start of processing for Generic_Anonymous_Array_Sort\n \n+begin\n+   for J in reverse 1 .. Max / 2 loop\n+      Sift (J);\n+   end loop;\n+\n+   while Max > 1 loop\n+      Xchg (1, Max);\n+      Max := Max - 1;\n+      Sift (1);\n+   end loop;\n end Ada.Containers.Generic_Anonymous_Array_Sort;"}, {"sha": "43ddb645b045016a2f89f769246b40806ff9375d", "filename": "gcc/ada/a-cgcaso.adb", "status": "modified", "additions": 69, "deletions": 97, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/392f673a0cbbc5f0d31836ad7f90df7d9eb9dd17/gcc%2Fada%2Fa-cgcaso.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/392f673a0cbbc5f0d31836ad7f90df7d9eb9dd17/gcc%2Fada%2Fa-cgcaso.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cgcaso.adb?ref=392f673a0cbbc5f0d31836ad7f90df7d9eb9dd17", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -34,130 +34,102 @@\n -- This unit has originally being developed by Matthew J Heaney.            --\n ------------------------------------------------------------------------------\n \n+--  This algorithm was adapted from GNAT.Heap_Sort_G (see g-hesorg.ad[sb]).\n+\n+with System;\n+\n procedure Ada.Containers.Generic_Constrained_Array_Sort\n   (Container : in out Array_Type)\n is\n-   function Is_Less (I, J : Index_Type) return Boolean;\n-   pragma Inline (Is_Less);\n+   type T is range System.Min_Int .. System.Max_Int;\n \n-   procedure Swap (I, J : Index_Type);\n-   pragma Inline (Swap);\n+   function To_Index (J : T) return Index_Type;\n+   pragma Inline (To_Index);\n \n-   procedure Sort (First, Last : Index_Type'Base);\n+   procedure Sift (S : T);\n \n-   -------------\n-   -- Is_Less --\n-   -------------\n+   A : Array_Type renames Container;\n \n-   function Is_Less (I, J : Index_Type) return Boolean is\n+   --------------\n+   -- To_Index --\n+   --------------\n+\n+   function To_Index (J : T) return Index_Type is\n+      K : constant T'Base := Index_Type'Pos (A'First) + J - T'(1);\n    begin\n-      return Container (I) < Container (J);\n-   end Is_Less;\n+      return Index_Type'Val (K);\n+   end To_Index;\n+\n+   Max  : T := A'Length;\n+   Temp : Element_Type;\n \n    ----------\n-   -- Sort --\n+   -- Sift --\n    ----------\n \n-   procedure Sort (First, Last : Index_Type'Base) is\n-      Pivot, Lo, Mid, Hi : Index_Type;\n+   procedure Sift (S : T) is\n+      C   : T := S;\n+      Son : T;\n \n    begin\n-      if Last <= First then\n-         return;\n-      end if;\n-\n-      Lo := First;\n-      Hi := Last;\n-\n-      if Last = Index_Type'Succ (First) then\n-         if not Is_Less (Lo, Hi) then\n-            Swap (Lo, Hi);\n-         end if;\n-\n-         return;\n-      end if;\n-\n-      Mid := Index_Type'Val\n-               (Index_Type'Pos (Lo) +\n-                (Index_Type'Pos (Hi) - Index_Type'Pos (Lo)) / 2);\n-\n-      --  We need to figure out which case we have:\n-      --  x < y < z\n-      --  x < z < y\n-      --  z < x < y\n-      --  y < x < z\n-      --  y < z < x\n-      --  z < y < x\n-\n-      if Is_Less (Lo, Mid) then\n-         if Is_Less (Lo, Hi) then\n-            if Is_Less (Mid, Hi) then\n-               Swap (Lo, Mid);\n-            else\n-               Swap (Lo, Hi);\n-            end if;\n+      loop\n+         Son := 2 * C;\n \n-         else\n-            null;  --  lo is median\n-         end if;\n+         exit when Son > Max;\n \n-      elsif Is_Less (Lo, Hi) then\n-         null; --  lo is median\n+         declare\n+            Son_Index : Index_Type := To_Index (Son);\n \n-      elsif Is_Less (Mid, Hi) then\n-         Swap (Lo, Hi);\n-\n-      else\n-         Swap (Lo, Mid);\n-      end if;\n+         begin\n+            if Son < Max then\n+               if A (Son_Index) < A (Index_Type'Succ (Son_Index)) then\n+                  Son := Son + 1;\n+                  Son_Index := Index_Type'Succ (Son_Index);\n+               end if;\n+            end if;\n \n-      Pivot := Lo;\n+            A (To_Index (C)) := A (Son_Index);  -- Move (Son, C);\n+         end;\n \n-      Outer : loop\n-         loop\n-            exit Outer when not (Pivot < Hi);\n+         C := Son;\n+      end loop;\n \n-            if Is_Less (Hi, Pivot) then\n-               Swap (Hi, Pivot);\n-               Pivot := Hi;\n-               Lo := Index_Type'Succ (Lo);\n-               exit;\n-            else\n-               Hi := Index_Type'Pred (Hi);\n-            end if;\n-         end loop;\n+      while C /= S loop\n+         declare\n+            Father      : constant T := C / 2;\n+            Father_Elem : Element_Type renames A (To_Index (Father));\n \n-         loop\n-            exit Outer when not (Lo < Pivot);\n+         begin\n+            if Father_Elem < Temp then           -- Lt (Father, 0)\n+               A (To_Index (C)) := Father_Elem;  -- Move (Father, C)\n+               C := Father;\n \n-            if Is_Less (Lo, Pivot) then\n-               Lo := Index_Type'Succ (Lo);\n             else\n-               Swap (Lo, Pivot);\n-               Pivot := Lo;\n-               Hi := Index_Type'Pred (Hi);\n                exit;\n             end if;\n-         end loop;\n-      end loop Outer;\n-\n-      Sort (First, Index_Type'Pred (Pivot));\n-      Sort (Index_Type'Succ (Pivot), Last);\n-   end Sort;\n+         end;\n+      end loop;\n \n-   ----------\n-   -- Swap --\n-   ----------\n-\n-   procedure Swap (I, J : Index_Type) is\n-      EI : constant Element_Type := Container (I);\n-   begin\n-      Container (I) := Container (J);\n-      Container (J) := EI;\n-   end Swap;\n+      A (To_Index (C)) := Temp; -- Move (0, C);\n+   end Sift;\n \n --  Start of processing for Generic_Constrained_Array_Sort\n \n begin\n-   Sort (Container'First, Container'Last);\n+   for J in reverse 1 .. Max / 2 loop\n+      Temp := Container (To_Index (J)); --  Move (J, 0);\n+      Sift (J);\n+   end loop;\n+\n+   while Max > 1 loop\n+      declare\n+         Max_Elem : Element_Type renames A (To_Index (Max));\n+      begin\n+         Temp := Max_Elem;         --  Move (Max, 0);\n+         Max_Elem := A (A'First);  --  Move (1, Max);\n+      end;\n+\n+      Max := Max - 1;\n+      Sift (1);\n+   end loop;\n end Ada.Containers.Generic_Constrained_Array_Sort;"}]}