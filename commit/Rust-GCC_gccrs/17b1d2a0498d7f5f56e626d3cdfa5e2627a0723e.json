{"sha": "17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdiMWQyYTA0OThkN2Y1ZjU2ZTYyNmQzY2RmYTVlMjYyN2EwNzIzZQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-07-29T00:45:52Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-07-29T00:45:52Z"}, "message": "gfortran.h (try): Remove macro.\n\n\t* gfortran.h (try): Remove macro.  Replace try with gfc_try\n\tthroughout.\n\t* array.c: Likewise.\n\t* check.c: Likewise.\n\t* cpp.c: Likewise.\n\t* cpp.h: Likewise.\n\t* data.c: Likewise.\n\t* data.h: Likewise.\n\t* decl.c: Likewise.\n\t* error.c: Likewise.\n\t* expr.c: Likewise.\n\t* interface.c: Likewise.\n\t* intrinsic.c: Likewise.\n\t* intrinsic.h: Likewise.\n\t* io.c: Likewise.\n\t* match.h: Likewise.\n\t* parse.c: Likewise.\n\t* parse.h: Likewise.\n\t* resolve.c: Likewise.\n\t* scanner.c: Likewise.\n\t* simplify.c: Likewise.\n\t* symbol.c: Likewise.\n\t* trans-openmp.c: Likewise.\n\t* trans-types.c: Likewise.\n\nFrom-SVN: r138226", "tree": {"sha": "b8d1d37ff2f87a02075cf96d6a0b1ac5b3faff15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8d1d37ff2f87a02075cf96d6a0b1ac5b3faff15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/comments", "author": null, "committer": null, "parents": [{"sha": "4889854852f709c488acbedd5bec67517d4eebd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4889854852f709c488acbedd5bec67517d4eebd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4889854852f709c488acbedd5bec67517d4eebd7"}], "stats": {"total": 1469, "additions": 747, "deletions": 722}, "files": [{"sha": "720626302f3c9d4a58ee1ad28cd2dbd150fb8ed3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -1,3 +1,30 @@\n+2008-07-28  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gfortran.h (try): Remove macro.  Replace try with gfc_try\n+\tthroughout.\n+\t* array.c: Likewise.\n+\t* check.c: Likewise.\n+\t* cpp.c: Likewise.\n+\t* cpp.h: Likewise.\n+\t* data.c: Likewise.\n+\t* data.h: Likewise.\n+\t* decl.c: Likewise.\n+\t* error.c: Likewise.\n+\t* expr.c: Likewise.\n+\t* interface.c: Likewise.\n+\t* intrinsic.c: Likewise.\n+\t* intrinsic.h: Likewise.\n+\t* io.c: Likewise.\n+\t* match.h: Likewise.\n+\t* parse.c: Likewise.\n+\t* parse.h: Likewise.\n+\t* resolve.c: Likewise.\n+\t* scanner.c: Likewise.\n+\t* simplify.c: Likewise.\n+\t* symbol.c: Likewise.\n+\t* trans-openmp.c: Likewise.\n+\t* trans-types.c: Likewise.\n+\n 2008-07-28  Tobias Burnus  <burnus@net-b.de>\n \n \t* Make-lang.in: Remove -Wno-* from fortran-warn."}, {"sha": "1cafe2b8dbc44b598c57f7ddf2d29fecf2c575b1", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -208,7 +208,7 @@ gfc_free_array_spec (gfc_array_spec *as)\n /* Take an array bound, resolves the expression, that make up the\n    shape and check associated constraints.  */\n \n-static try\n+static gfc_try\n resolve_array_bound (gfc_expr *e, int check_constant)\n {\n   if (e == NULL)\n@@ -232,7 +232,7 @@ resolve_array_bound (gfc_expr *e, int check_constant)\n /* Takes an array specification, resolves the expressions that make up\n    the shape and make sure everything is integral.  */\n \n-try\n+gfc_try\n gfc_resolve_array_spec (gfc_array_spec *as, int check_constant)\n {\n   gfc_expr *e;\n@@ -469,7 +469,7 @@ gfc_match_array_spec (gfc_array_spec **asp)\n    have that array specification.  The error locus is needed in case\n    something goes wrong.  On failure, the caller must free the spec.  */\n \n-try\n+gfc_try\n gfc_set_array_spec (gfc_symbol *sym, gfc_array_spec *as, locus *error_loc)\n {\n   if (as == NULL)\n@@ -1038,7 +1038,7 @@ check_element_type (gfc_expr *expr, bool convert)\n \n /* Recursive work function for gfc_check_constructor_type().  */\n \n-static try\n+static gfc_try\n check_constructor_type (gfc_constructor *c, bool convert)\n {\n   gfc_expr *e;\n@@ -1066,10 +1066,10 @@ check_constructor_type (gfc_constructor *c, bool convert)\n /* Check that all elements of an array constructor are the same type.\n    On FAILURE, an error has been generated.  */\n \n-try\n+gfc_try\n gfc_check_constructor_type (gfc_expr *e)\n {\n-  try t;\n+  gfc_try t;\n \n   if (e->ts.type != BT_UNKNOWN)\n     {\n@@ -1102,12 +1102,12 @@ cons_stack;\n \n static cons_stack *base;\n \n-static try check_constructor (gfc_constructor *, try (*) (gfc_expr *));\n+static gfc_try check_constructor (gfc_constructor *, gfc_try (*) (gfc_expr *));\n \n /* Check an EXPR_VARIABLE expression in a constructor to make sure\n    that that variable is an iteration variables.  */\n \n-try\n+gfc_try\n gfc_check_iter_variable (gfc_expr *expr)\n {\n   gfc_symbol *sym;\n@@ -1127,12 +1127,12 @@ gfc_check_iter_variable (gfc_expr *expr)\n    to calling the check function for each expression in the\n    constructor, giving variables with the names of iterators a pass.  */\n \n-static try\n-check_constructor (gfc_constructor *c, try (*check_function) (gfc_expr *))\n+static gfc_try\n+check_constructor (gfc_constructor *c, gfc_try (*check_function) (gfc_expr *))\n {\n   cons_stack element;\n   gfc_expr *e;\n-  try t;\n+  gfc_try t;\n \n   for (; c; c = c->next)\n     {\n@@ -1165,11 +1165,11 @@ check_constructor (gfc_constructor *c, try (*check_function) (gfc_expr *))\n    expression -- specification, restricted, or initialization as\n    determined by the check_function.  */\n \n-try\n-gfc_check_constructor (gfc_expr *expr, try (*check_function) (gfc_expr *))\n+gfc_try\n+gfc_check_constructor (gfc_expr *expr, gfc_try (*check_function) (gfc_expr *))\n {\n   cons_stack *base_save;\n-  try t;\n+  gfc_try t;\n \n   base_save = base;\n   base = NULL;\n@@ -1197,19 +1197,19 @@ typedef struct\n   gfc_component *component;\n   mpz_t *repeat;\n \n-  try (*expand_work_function) (gfc_expr *);\n+  gfc_try (*expand_work_function) (gfc_expr *);\n }\n expand_info;\n \n static expand_info current_expand;\n \n-static try expand_constructor (gfc_constructor *);\n+static gfc_try expand_constructor (gfc_constructor *);\n \n \n /* Work function that counts the number of elements present in a\n    constructor.  */\n \n-static try\n+static gfc_try\n count_elements (gfc_expr *e)\n {\n   mpz_t result;\n@@ -1236,7 +1236,7 @@ count_elements (gfc_expr *e)\n /* Work function that extracts a particular element from an array\n    constructor, freeing the rest.  */\n \n-static try\n+static gfc_try\n extract_element (gfc_expr *e)\n {\n \n@@ -1259,7 +1259,7 @@ extract_element (gfc_expr *e)\n /* Work function that constructs a new constructor out of the old one,\n    stringing new elements together.  */\n \n-static try\n+static gfc_try\n expand (gfc_expr *e)\n {\n   if (current_expand.new_head == NULL)\n@@ -1307,7 +1307,7 @@ gfc_simplify_iterator_var (gfc_expr *e)\n /* Expand an expression with that is inside of a constructor,\n    recursing into other constructors if present.  */\n \n-static try\n+static gfc_try\n expand_expr (gfc_expr *e)\n {\n   if (e->expr_type == EXPR_ARRAY)\n@@ -1325,13 +1325,13 @@ expand_expr (gfc_expr *e)\n }\n \n \n-static try\n+static gfc_try\n expand_iterator (gfc_constructor *c)\n {\n   gfc_expr *start, *end, *step;\n   iterator_stack frame;\n   mpz_t trip;\n-  try t;\n+  gfc_try t;\n \n   end = step = NULL;\n \n@@ -1409,7 +1409,7 @@ expand_iterator (gfc_constructor *c)\n    expressions.  The work function needs to either save or free the\n    passed expression.  */\n \n-static try\n+static gfc_try\n expand_constructor (gfc_constructor *c)\n {\n   gfc_expr *e;\n@@ -1452,12 +1452,12 @@ expand_constructor (gfc_constructor *c)\n /* Top level subroutine for expanding constructors.  We only expand\n    constructor if they are small enough.  */\n \n-try\n+gfc_try\n gfc_expand_constructor (gfc_expr *e)\n {\n   expand_info expand_save;\n   gfc_expr *f;\n-  try rc;\n+  gfc_try rc;\n \n   f = gfc_get_array_element (e, GFC_MAX_AC_EXPAND);\n   if (f != NULL)\n@@ -1496,7 +1496,7 @@ gfc_expand_constructor (gfc_expr *e)\n    constant, after removal of any iteration variables.  We return\n    FAILURE if not so.  */\n \n-static try\n+static gfc_try\n constant_element (gfc_expr *e)\n {\n   int rv;\n@@ -1518,7 +1518,7 @@ int\n gfc_constant_ac (gfc_expr *e)\n {\n   expand_info expand_save;\n-  try rc;\n+  gfc_try rc;\n \n   iter_stack = NULL;\n   expand_save = current_expand;\n@@ -1556,10 +1556,10 @@ gfc_expanded_ac (gfc_expr *e)\n /* Recursive array list resolution function.  All of the elements must\n    be of the same type.  */\n \n-static try\n+static gfc_try\n resolve_array_list (gfc_constructor *p)\n {\n-  try t;\n+  gfc_try t;\n \n   t = SUCCESS;\n \n@@ -1581,7 +1581,7 @@ resolve_array_list (gfc_constructor *p)\n    all elements are of compile-time known length, emit an error as this is\n    invalid.  */\n \n-try\n+gfc_try\n gfc_resolve_character_array_constructor (gfc_expr *expr)\n {\n   gfc_constructor *p;\n@@ -1711,10 +1711,10 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n \n /* Resolve all of the expressions in an array list.  */\n \n-try\n+gfc_try\n gfc_resolve_array_constructor (gfc_expr *expr)\n {\n-  try t;\n+  gfc_try t;\n \n   t = resolve_array_list (expr->value.constructor);\n   if (t == SUCCESS)\n@@ -1795,7 +1795,7 @@ gfc_get_array_element (gfc_expr *array, int element)\n {\n   expand_info expand_save;\n   gfc_expr *e;\n-  try rc;\n+  gfc_try rc;\n \n   expand_save = current_expand;\n   current_expand.extract_n = element;\n@@ -1826,7 +1826,7 @@ gfc_get_array_element (gfc_expr *array, int element)\n /* Get the size of single dimension of an array specification.  The\n    array is guaranteed to be one dimensional.  */\n \n-try\n+gfc_try\n spec_dimen_size (gfc_array_spec *as, int dimen, mpz_t *result)\n {\n   if (as == NULL)\n@@ -1853,7 +1853,7 @@ spec_dimen_size (gfc_array_spec *as, int dimen, mpz_t *result)\n }\n \n \n-try\n+gfc_try\n spec_size (gfc_array_spec *as, mpz_t *result)\n {\n   mpz_t size;\n@@ -1879,11 +1879,11 @@ spec_size (gfc_array_spec *as, mpz_t *result)\n \n /* Get the number of elements in an array section.  */\n \n-static try\n+static gfc_try\n ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result)\n {\n   mpz_t upper, lower, stride;\n-  try t;\n+  gfc_try t;\n \n   if (dimen < 0 || ar == NULL || dimen > ar->dimen - 1)\n     gfc_internal_error (\"ref_dimen_size(): Bad dimension\");\n@@ -1967,7 +1967,7 @@ ref_dimen_size (gfc_array_ref *ar, int dimen, mpz_t *result)\n }\n \n \n-static try\n+static gfc_try\n ref_size (gfc_array_ref *ar, mpz_t *result)\n {\n   mpz_t size;\n@@ -1996,7 +1996,7 @@ ref_size (gfc_array_ref *ar, mpz_t *result)\n    able to return a result in the 'result' variable, FAILURE\n    otherwise.  */\n \n-try\n+gfc_try\n gfc_array_dimen_size (gfc_expr *array, int dimen, mpz_t *result)\n {\n   gfc_ref *ref;\n@@ -2064,13 +2064,13 @@ gfc_array_dimen_size (gfc_expr *array, int dimen, mpz_t *result)\n    array.  Returns SUCCESS if this is possible, and sets the 'result'\n    variable.  Otherwise returns FAILURE.  */\n \n-try\n+gfc_try\n gfc_array_size (gfc_expr *array, mpz_t *result)\n {\n   expand_info expand_save;\n   gfc_ref *ref;\n   int i, flag;\n-  try t;\n+  gfc_try t;\n \n   switch (array->expr_type)\n     {\n@@ -2129,7 +2129,7 @@ gfc_array_size (gfc_expr *array, mpz_t *result)\n /* Given an array reference, return the shape of the reference in an\n    array of mpz_t integers.  */\n \n-try\n+gfc_try\n gfc_array_ref_shape (gfc_array_ref *ar, mpz_t *shape)\n {\n   int d;"}, {"sha": "1f9ce2fff6ab4c4326b51289cb85ec94f8535df2", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 179, "deletions": 179, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -35,7 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Make sure an expression is a scalar.  */\n \n-static try\n+static gfc_try\n scalar_check (gfc_expr *e, int n)\n {\n   if (e->rank == 0)\n@@ -50,7 +50,7 @@ scalar_check (gfc_expr *e, int n)\n \n /* Check the type of an expression.  */\n \n-static try\n+static gfc_try\n type_check (gfc_expr *e, int n, bt type)\n {\n   if (e->ts.type == type)\n@@ -66,7 +66,7 @@ type_check (gfc_expr *e, int n, bt type)\n \n /* Check that the expression is a numeric type.  */\n \n-static try\n+static gfc_try\n numeric_check (gfc_expr *e, int n)\n {\n   if (gfc_numeric_ts (&e->ts))\n@@ -93,7 +93,7 @@ numeric_check (gfc_expr *e, int n)\n \n /* Check that an expression is integer or real.  */\n \n-static try\n+static gfc_try\n int_or_real_check (gfc_expr *e, int n)\n {\n   if (e->ts.type != BT_INTEGER && e->ts.type != BT_REAL)\n@@ -110,7 +110,7 @@ int_or_real_check (gfc_expr *e, int n)\n \n /* Check that an expression is real or complex.  */\n \n-static try\n+static gfc_try\n real_or_complex_check (gfc_expr *e, int n)\n {\n   if (e->ts.type != BT_REAL && e->ts.type != BT_COMPLEX)\n@@ -128,7 +128,7 @@ real_or_complex_check (gfc_expr *e, int n)\n /* Check that the expression is an optional constant integer\n    and that it specifies a valid kind for that type.  */\n \n-static try\n+static gfc_try\n kind_check (gfc_expr *k, int n, bt type)\n {\n   int kind;\n@@ -164,7 +164,7 @@ kind_check (gfc_expr *k, int n, bt type)\n \n /* Make sure the expression is a double precision real.  */\n \n-static try\n+static gfc_try\n double_check (gfc_expr *d, int n)\n {\n   if (type_check (d, n, BT_REAL) == FAILURE)\n@@ -184,7 +184,7 @@ double_check (gfc_expr *d, int n)\n \n /* Make sure the expression is a logical array.  */\n \n-static try\n+static gfc_try\n logical_array_check (gfc_expr *array, int n)\n {\n   if (array->ts.type != BT_LOGICAL || array->rank == 0)\n@@ -201,7 +201,7 @@ logical_array_check (gfc_expr *array, int n)\n \n /* Make sure an expression is an array.  */\n \n-static try\n+static gfc_try\n array_check (gfc_expr *e, int n)\n {\n   if (e->rank != 0)\n@@ -216,7 +216,7 @@ array_check (gfc_expr *e, int n)\n \n /* Make sure two expressions have the same type.  */\n \n-static try\n+static gfc_try\n same_type_check (gfc_expr *e, int n, gfc_expr *f, int m)\n {\n   if (gfc_compare_types (&e->ts, &f->ts))\n@@ -232,7 +232,7 @@ same_type_check (gfc_expr *e, int n, gfc_expr *f, int m)\n \n /* Make sure that an expression has a certain (nonzero) rank.  */\n \n-static try\n+static gfc_try\n rank_check (gfc_expr *e, int n, int rank)\n {\n   if (e->rank == rank)\n@@ -248,7 +248,7 @@ rank_check (gfc_expr *e, int n, int rank)\n \n /* Make sure a variable expression is not an optional dummy argument.  */\n \n-static try\n+static gfc_try\n nonoptional_check (gfc_expr *e, int n)\n {\n   if (e->expr_type == EXPR_VARIABLE && e->symtree->n.sym->attr.optional)\n@@ -266,7 +266,7 @@ nonoptional_check (gfc_expr *e, int n)\n \n /* Check that an expression has a particular kind.  */\n \n-static try\n+static gfc_try\n kind_value_check (gfc_expr *e, int n, int k)\n {\n   if (e->ts.kind == k)\n@@ -282,7 +282,7 @@ kind_value_check (gfc_expr *e, int n, int k)\n \n /* Make sure an expression is a variable.  */\n \n-static try\n+static gfc_try\n variable_check (gfc_expr *e, int n)\n {\n   if ((e->expr_type == EXPR_VARIABLE\n@@ -309,7 +309,7 @@ variable_check (gfc_expr *e, int n)\n \n /* Check the common DIM parameter for correctness.  */\n \n-static try\n+static gfc_try\n dim_check (gfc_expr *dim, int n, bool optional)\n {\n   if (dim == NULL)\n@@ -333,7 +333,7 @@ dim_check (gfc_expr *dim, int n, bool optional)\n    allow_assumed is zero then dim must be less than the rank of the array\n    for assumed size arrays.  */\n \n-static try\n+static gfc_try\n dim_rank_check (gfc_expr *dim, gfc_expr *array, int allow_assumed)\n {\n   gfc_array_ref *ar;\n@@ -396,7 +396,7 @@ identical_dimen_shape (gfc_expr *a, int ai, gfc_expr *b, int bi)\n /* Check whether two character expressions have the same length;\n    returns SUCCESS if they have or if the length cannot be determined.  */\n \n-static try\n+static gfc_try\n check_same_strlen (const gfc_expr *a, const gfc_expr *b, const char *name)\n {\n    long len_a, len_b;\n@@ -434,7 +434,7 @@ check_same_strlen (const gfc_expr *a, const gfc_expr *b, const char *name)\n /* Check subroutine suitable for intrinsics taking a real argument and\n    a kind argument for the result.  */\n \n-static try\n+static gfc_try\n check_a_kind (gfc_expr *a, gfc_expr *kind, bt type)\n {\n   if (type_check (a, 0, BT_REAL) == FAILURE)\n@@ -448,7 +448,7 @@ check_a_kind (gfc_expr *a, gfc_expr *kind, bt type)\n \n /* Check subroutine suitable for ceiling, floor and nint.  */\n \n-try\n+gfc_try\n gfc_check_a_ikind (gfc_expr *a, gfc_expr *kind)\n {\n   return check_a_kind (a, kind, BT_INTEGER);\n@@ -457,14 +457,14 @@ gfc_check_a_ikind (gfc_expr *a, gfc_expr *kind)\n \n /* Check subroutine suitable for aint, anint.  */\n \n-try\n+gfc_try\n gfc_check_a_xkind (gfc_expr *a, gfc_expr *kind)\n {\n   return check_a_kind (a, kind, BT_REAL);\n }\n \n \n-try\n+gfc_try\n gfc_check_abs (gfc_expr *a)\n {\n   if (numeric_check (a, 0) == FAILURE)\n@@ -474,7 +474,7 @@ gfc_check_abs (gfc_expr *a)\n }\n \n \n-try\n+gfc_try\n gfc_check_achar (gfc_expr *a, gfc_expr *kind)\n {\n   if (type_check (a, 0, BT_INTEGER) == FAILURE)\n@@ -486,7 +486,7 @@ gfc_check_achar (gfc_expr *a, gfc_expr *kind)\n }\n \n \n-try\n+gfc_try\n gfc_check_access_func (gfc_expr *name, gfc_expr *mode)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE\n@@ -505,7 +505,7 @@ gfc_check_access_func (gfc_expr *name, gfc_expr *mode)\n }\n \n \n-try\n+gfc_try\n gfc_check_all_any (gfc_expr *mask, gfc_expr *dim)\n {\n   if (logical_array_check (mask, 0) == FAILURE)\n@@ -518,7 +518,7 @@ gfc_check_all_any (gfc_expr *mask, gfc_expr *dim)\n }\n \n \n-try\n+gfc_try\n gfc_check_allocated (gfc_expr *array)\n {\n   symbol_attribute attr;\n@@ -545,7 +545,7 @@ gfc_check_allocated (gfc_expr *array)\n /* Common check function where the first argument must be real or\n    integer and the second argument must be the same as the first.  */\n \n-try\n+gfc_try\n gfc_check_a_p (gfc_expr *a, gfc_expr *p)\n {\n   if (int_or_real_check (a, 0) == FAILURE)\n@@ -571,7 +571,7 @@ gfc_check_a_p (gfc_expr *a, gfc_expr *p)\n }\n \n \n-try\n+gfc_try\n gfc_check_x_yd (gfc_expr *x, gfc_expr *y)\n {\n   if (double_check (x, 0) == FAILURE || double_check (y, 1) == FAILURE)\n@@ -581,12 +581,12 @@ gfc_check_x_yd (gfc_expr *x, gfc_expr *y)\n }\n \n \n-try\n+gfc_try\n gfc_check_associated (gfc_expr *pointer, gfc_expr *target)\n {\n   symbol_attribute attr1, attr2;\n   int i;\n-  try t;\n+  gfc_try t;\n   locus *where;\n \n   where = &pointer->where;\n@@ -664,7 +664,7 @@ gfc_check_associated (gfc_expr *pointer, gfc_expr *target)\n }\n \n \n-try\n+gfc_try\n gfc_check_atan2 (gfc_expr *y, gfc_expr *x)\n {\n   if (type_check (y, 0, BT_REAL) == FAILURE)\n@@ -678,7 +678,7 @@ gfc_check_atan2 (gfc_expr *y, gfc_expr *x)\n \n /* BESJN and BESYN functions.  */\n \n-try\n+gfc_try\n gfc_check_besn (gfc_expr *n, gfc_expr *x)\n {\n   if (type_check (n, 0, BT_INTEGER) == FAILURE)\n@@ -691,7 +691,7 @@ gfc_check_besn (gfc_expr *n, gfc_expr *x)\n }\n \n \n-try\n+gfc_try\n gfc_check_btest (gfc_expr *i, gfc_expr *pos)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n@@ -703,7 +703,7 @@ gfc_check_btest (gfc_expr *i, gfc_expr *pos)\n }\n \n \n-try\n+gfc_try\n gfc_check_char (gfc_expr *i, gfc_expr *kind)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n@@ -715,7 +715,7 @@ gfc_check_char (gfc_expr *i, gfc_expr *kind)\n }\n \n \n-try\n+gfc_try\n gfc_check_chdir (gfc_expr *dir)\n {\n   if (type_check (dir, 0, BT_CHARACTER) == FAILURE)\n@@ -727,7 +727,7 @@ gfc_check_chdir (gfc_expr *dir)\n }\n \n \n-try\n+gfc_try\n gfc_check_chdir_sub (gfc_expr *dir, gfc_expr *status)\n {\n   if (type_check (dir, 0, BT_CHARACTER) == FAILURE)\n@@ -747,7 +747,7 @@ gfc_check_chdir_sub (gfc_expr *dir, gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_chmod (gfc_expr *name, gfc_expr *mode)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n@@ -764,7 +764,7 @@ gfc_check_chmod (gfc_expr *name, gfc_expr *mode)\n }\n \n \n-try\n+gfc_try\n gfc_check_chmod_sub (gfc_expr *name, gfc_expr *mode, gfc_expr *status)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n@@ -790,7 +790,7 @@ gfc_check_chmod_sub (gfc_expr *name, gfc_expr *mode, gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_cmplx (gfc_expr *x, gfc_expr *y, gfc_expr *kind)\n {\n   if (numeric_check (x, 0) == FAILURE)\n@@ -817,7 +817,7 @@ gfc_check_cmplx (gfc_expr *x, gfc_expr *y, gfc_expr *kind)\n }\n \n \n-try\n+gfc_try\n gfc_check_complex (gfc_expr *x, gfc_expr *y)\n {\n   if (x->ts.type != BT_INTEGER && x->ts.type != BT_REAL)\n@@ -844,7 +844,7 @@ gfc_check_complex (gfc_expr *x, gfc_expr *y)\n }\n \n \n-try\n+gfc_try\n gfc_check_count (gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n {\n   if (logical_array_check (mask, 0) == FAILURE)\n@@ -862,7 +862,7 @@ gfc_check_count (gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n }\n \n \n-try\n+gfc_try\n gfc_check_cshift (gfc_expr *array, gfc_expr *shift, gfc_expr *dim)\n {\n   if (array_check (array, 0) == FAILURE)\n@@ -893,7 +893,7 @@ gfc_check_cshift (gfc_expr *array, gfc_expr *shift, gfc_expr *dim)\n }\n \n \n-try\n+gfc_try\n gfc_check_ctime (gfc_expr *time)\n {\n   if (scalar_check (time, 0) == FAILURE)\n@@ -906,15 +906,15 @@ gfc_check_ctime (gfc_expr *time)\n }\n \n \n-try gfc_check_datan2 (gfc_expr *y, gfc_expr *x)\n+gfc_try gfc_check_datan2 (gfc_expr *y, gfc_expr *x)\n {\n   if (double_check (y, 0) == FAILURE || double_check (x, 1) == FAILURE)\n     return FAILURE;\n \n   return SUCCESS;\n }\n \n-try\n+gfc_try\n gfc_check_dcmplx (gfc_expr *x, gfc_expr *y)\n {\n   if (numeric_check (x, 0) == FAILURE)\n@@ -938,7 +938,7 @@ gfc_check_dcmplx (gfc_expr *x, gfc_expr *y)\n }\n \n \n-try\n+gfc_try\n gfc_check_dble (gfc_expr *x)\n {\n   if (numeric_check (x, 0) == FAILURE)\n@@ -948,7 +948,7 @@ gfc_check_dble (gfc_expr *x)\n }\n \n \n-try\n+gfc_try\n gfc_check_digits (gfc_expr *x)\n {\n   if (int_or_real_check (x, 0) == FAILURE)\n@@ -958,7 +958,7 @@ gfc_check_digits (gfc_expr *x)\n }\n \n \n-try\n+gfc_try\n gfc_check_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)\n {\n   switch (vector_a->ts.type)\n@@ -1000,7 +1000,7 @@ gfc_check_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)\n }\n \n \n-try\n+gfc_try\n gfc_check_dprod (gfc_expr *x, gfc_expr *y)\n {\n   if (type_check (x, 0, BT_REAL) == FAILURE\n@@ -1027,7 +1027,7 @@ gfc_check_dprod (gfc_expr *x, gfc_expr *y)\n }\n \n \n-try\n+gfc_try\n gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n \t\t   gfc_expr *dim)\n {\n@@ -1092,7 +1092,7 @@ gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n \n /* A single complex argument.  */\n \n-try\n+gfc_try\n gfc_check_fn_c (gfc_expr *a)\n {\n   if (type_check (a, 0, BT_COMPLEX) == FAILURE)\n@@ -1104,7 +1104,7 @@ gfc_check_fn_c (gfc_expr *a)\n \n /* A single real argument.  */\n \n-try\n+gfc_try\n gfc_check_fn_r (gfc_expr *a)\n {\n   if (type_check (a, 0, BT_REAL) == FAILURE)\n@@ -1115,7 +1115,7 @@ gfc_check_fn_r (gfc_expr *a)\n \n /* A single double argument.  */\n \n-try\n+gfc_try\n gfc_check_fn_d (gfc_expr *a)\n {\n   if (double_check (a, 0) == FAILURE)\n@@ -1126,7 +1126,7 @@ gfc_check_fn_d (gfc_expr *a)\n \n /* A single real or complex argument.  */\n \n-try\n+gfc_try\n gfc_check_fn_rc (gfc_expr *a)\n {\n   if (real_or_complex_check (a, 0) == FAILURE)\n@@ -1136,7 +1136,7 @@ gfc_check_fn_rc (gfc_expr *a)\n }\n \n \n-try\n+gfc_try\n gfc_check_fnum (gfc_expr *unit)\n {\n   if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n@@ -1149,7 +1149,7 @@ gfc_check_fnum (gfc_expr *unit)\n }\n \n \n-try\n+gfc_try\n gfc_check_huge (gfc_expr *x)\n {\n   if (int_or_real_check (x, 0) == FAILURE)\n@@ -1159,7 +1159,7 @@ gfc_check_huge (gfc_expr *x)\n }\n \n \n-try\n+gfc_try\n gfc_check_hypot (gfc_expr *x, gfc_expr *y)\n {\n   if (type_check (x, 0, BT_REAL) == FAILURE)\n@@ -1173,7 +1173,7 @@ gfc_check_hypot (gfc_expr *x, gfc_expr *y)\n \n /* Check that the single argument is an integer.  */\n \n-try\n+gfc_try\n gfc_check_i (gfc_expr *i)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n@@ -1183,7 +1183,7 @@ gfc_check_i (gfc_expr *i)\n }\n \n \n-try\n+gfc_try\n gfc_check_iand (gfc_expr *i, gfc_expr *j)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n@@ -1203,7 +1203,7 @@ gfc_check_iand (gfc_expr *i, gfc_expr *j)\n }\n \n \n-try\n+gfc_try\n gfc_check_ibclr (gfc_expr *i, gfc_expr *pos)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n@@ -1216,7 +1216,7 @@ gfc_check_ibclr (gfc_expr *i, gfc_expr *pos)\n }\n \n \n-try\n+gfc_try\n gfc_check_ibits (gfc_expr *i, gfc_expr *pos, gfc_expr *len)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n@@ -1232,7 +1232,7 @@ gfc_check_ibits (gfc_expr *i, gfc_expr *pos, gfc_expr *len)\n }\n \n \n-try\n+gfc_try\n gfc_check_ibset (gfc_expr *i, gfc_expr *pos)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n@@ -1245,7 +1245,7 @@ gfc_check_ibset (gfc_expr *i, gfc_expr *pos)\n }\n \n \n-try\n+gfc_try\n gfc_check_ichar_iachar (gfc_expr *c, gfc_expr *kind)\n {\n   int i;\n@@ -1316,7 +1316,7 @@ gfc_check_ichar_iachar (gfc_expr *c, gfc_expr *kind)\n }\n \n \n-try\n+gfc_try\n gfc_check_idnint (gfc_expr *a)\n {\n   if (double_check (a, 0) == FAILURE)\n@@ -1326,7 +1326,7 @@ gfc_check_idnint (gfc_expr *a)\n }\n \n \n-try\n+gfc_try\n gfc_check_ieor (gfc_expr *i, gfc_expr *j)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n@@ -1346,7 +1346,7 @@ gfc_check_ieor (gfc_expr *i, gfc_expr *j)\n }\n \n \n-try\n+gfc_try\n gfc_check_index (gfc_expr *string, gfc_expr *substring, gfc_expr *back,\n \t\t gfc_expr *kind)\n {\n@@ -1377,7 +1377,7 @@ gfc_check_index (gfc_expr *string, gfc_expr *substring, gfc_expr *back,\n }\n \n \n-try\n+gfc_try\n gfc_check_int (gfc_expr *x, gfc_expr *kind)\n {\n   if (numeric_check (x, 0) == FAILURE)\n@@ -1390,7 +1390,7 @@ gfc_check_int (gfc_expr *x, gfc_expr *kind)\n }\n \n \n-try\n+gfc_try\n gfc_check_intconv (gfc_expr *x)\n {\n   if (numeric_check (x, 0) == FAILURE)\n@@ -1400,7 +1400,7 @@ gfc_check_intconv (gfc_expr *x)\n }\n \n \n-try\n+gfc_try\n gfc_check_ior (gfc_expr *i, gfc_expr *j)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n@@ -1420,7 +1420,7 @@ gfc_check_ior (gfc_expr *i, gfc_expr *j)\n }\n \n \n-try\n+gfc_try\n gfc_check_ishft (gfc_expr *i, gfc_expr *shift)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE\n@@ -1431,7 +1431,7 @@ gfc_check_ishft (gfc_expr *i, gfc_expr *shift)\n }\n \n \n-try\n+gfc_try\n gfc_check_ishftc (gfc_expr *i, gfc_expr *shift, gfc_expr *size)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE\n@@ -1445,7 +1445,7 @@ gfc_check_ishftc (gfc_expr *i, gfc_expr *shift, gfc_expr *size)\n }\n \n \n-try\n+gfc_try\n gfc_check_kill (gfc_expr *pid, gfc_expr *sig)\n {\n   if (type_check (pid, 0, BT_INTEGER) == FAILURE)\n@@ -1458,7 +1458,7 @@ gfc_check_kill (gfc_expr *pid, gfc_expr *sig)\n }\n \n \n-try\n+gfc_try\n gfc_check_kill_sub (gfc_expr *pid, gfc_expr *sig, gfc_expr *status)\n {\n   if (type_check (pid, 0, BT_INTEGER) == FAILURE)\n@@ -1486,7 +1486,7 @@ gfc_check_kill_sub (gfc_expr *pid, gfc_expr *sig, gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_kind (gfc_expr *x)\n {\n   if (x->ts.type == BT_DERIVED)\n@@ -1501,7 +1501,7 @@ gfc_check_kind (gfc_expr *x)\n }\n \n \n-try\n+gfc_try\n gfc_check_lbound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n {\n   if (array_check (array, 0) == FAILURE)\n@@ -1527,7 +1527,7 @@ gfc_check_lbound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n }\n \n \n-try\n+gfc_try\n gfc_check_len_lentrim (gfc_expr *s, gfc_expr *kind)\n {\n   if (type_check (s, 0, BT_CHARACTER) == FAILURE)\n@@ -1544,7 +1544,7 @@ gfc_check_len_lentrim (gfc_expr *s, gfc_expr *kind)\n }\n \n \n-try\n+gfc_try\n gfc_check_lge_lgt_lle_llt (gfc_expr *a, gfc_expr *b)\n {\n   if (type_check (a, 0, BT_CHARACTER) == FAILURE)\n@@ -1561,7 +1561,7 @@ gfc_check_lge_lgt_lle_llt (gfc_expr *a, gfc_expr *b)\n }\n \n \n-try\n+gfc_try\n gfc_check_link (gfc_expr *path1, gfc_expr *path2)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n@@ -1578,7 +1578,7 @@ gfc_check_link (gfc_expr *path1, gfc_expr *path2)\n }\n \n \n-try\n+gfc_try\n gfc_check_link_sub (gfc_expr *path1, gfc_expr *path2, gfc_expr *status)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n@@ -1604,14 +1604,14 @@ gfc_check_link_sub (gfc_expr *path1, gfc_expr *path2, gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_loc (gfc_expr *expr)\n {\n   return variable_check (expr, 0);\n }\n \n \n-try\n+gfc_try\n gfc_check_symlnk (gfc_expr *path1, gfc_expr *path2)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n@@ -1628,7 +1628,7 @@ gfc_check_symlnk (gfc_expr *path1, gfc_expr *path2)\n }\n \n \n-try\n+gfc_try\n gfc_check_symlnk_sub (gfc_expr *path1, gfc_expr *path2, gfc_expr *status)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n@@ -1654,7 +1654,7 @@ gfc_check_symlnk_sub (gfc_expr *path1, gfc_expr *path2, gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_logical (gfc_expr *a, gfc_expr *kind)\n {\n   if (type_check (a, 0, BT_LOGICAL) == FAILURE)\n@@ -1668,7 +1668,7 @@ gfc_check_logical (gfc_expr *a, gfc_expr *kind)\n \n /* Min/max family.  */\n \n-static try\n+static gfc_try\n min_max_args (gfc_actual_arglist *arg)\n {\n   if (arg == NULL || arg->next == NULL)\n@@ -1682,7 +1682,7 @@ min_max_args (gfc_actual_arglist *arg)\n }\n \n \n-static try\n+static gfc_try\n check_rest (bt type, int kind, gfc_actual_arglist *arglist)\n {\n   gfc_actual_arglist *arg, *tmp;\n@@ -1727,7 +1727,7 @@ check_rest (bt type, int kind, gfc_actual_arglist *arglist)\n }\n \n \n-try\n+gfc_try\n gfc_check_min_max (gfc_actual_arglist *arg)\n {\n   gfc_expr *x;\n@@ -1755,21 +1755,21 @@ gfc_check_min_max (gfc_actual_arglist *arg)\n }\n \n \n-try\n+gfc_try\n gfc_check_min_max_integer (gfc_actual_arglist *arg)\n {\n   return check_rest (BT_INTEGER, gfc_default_integer_kind, arg);\n }\n \n \n-try\n+gfc_try\n gfc_check_min_max_real (gfc_actual_arglist *arg)\n {\n   return check_rest (BT_REAL, gfc_default_real_kind, arg);\n }\n \n \n-try\n+gfc_try\n gfc_check_min_max_double (gfc_actual_arglist *arg)\n {\n   return check_rest (BT_REAL, gfc_default_double_kind, arg);\n@@ -1778,7 +1778,7 @@ gfc_check_min_max_double (gfc_actual_arglist *arg)\n \n /* End of min/max family.  */\n \n-try\n+gfc_try\n gfc_check_malloc (gfc_expr *size)\n {\n   if (type_check (size, 0, BT_INTEGER) == FAILURE)\n@@ -1791,7 +1791,7 @@ gfc_check_malloc (gfc_expr *size)\n }\n \n \n-try\n+gfc_try\n gfc_check_matmul (gfc_expr *matrix_a, gfc_expr *matrix_b)\n {\n   if ((matrix_a->ts.type != BT_LOGICAL) && !gfc_numeric_ts (&matrix_b->ts))\n@@ -1870,7 +1870,7 @@ gfc_check_matmul (gfc_expr *matrix_a, gfc_expr *matrix_b)\n    I.e. in the case of minloc(array,mask), mask will be in the second\n    position of the argument list and we'll have to fix that up.  */\n \n-try\n+gfc_try\n gfc_check_minloc_maxloc (gfc_actual_arglist *ap)\n {\n   gfc_expr *a, *m, *d;\n@@ -1929,7 +1929,7 @@ gfc_check_minloc_maxloc (gfc_actual_arglist *ap)\n    I.e. in the case of minval(array,mask), mask will be in the second\n    position of the argument list and we'll have to fix that up.  */\n \n-static try\n+static gfc_try\n check_reduction (gfc_actual_arglist *ap)\n {\n   gfc_expr *a, *m, *d;\n@@ -1970,7 +1970,7 @@ check_reduction (gfc_actual_arglist *ap)\n }\n \n \n-try\n+gfc_try\n gfc_check_minval_maxval (gfc_actual_arglist *ap)\n {\n   if (int_or_real_check (ap->expr, 0) == FAILURE\n@@ -1981,7 +1981,7 @@ gfc_check_minval_maxval (gfc_actual_arglist *ap)\n }\n \n \n-try\n+gfc_try\n gfc_check_product_sum (gfc_actual_arglist *ap)\n {\n   if (numeric_check (ap->expr, 0) == FAILURE\n@@ -1992,7 +1992,7 @@ gfc_check_product_sum (gfc_actual_arglist *ap)\n }\n \n \n-try\n+gfc_try\n gfc_check_merge (gfc_expr *tsource, gfc_expr *fsource, gfc_expr *mask)\n {\n   if (same_type_check (tsource, 0, fsource, 1) == FAILURE)\n@@ -2008,7 +2008,7 @@ gfc_check_merge (gfc_expr *tsource, gfc_expr *fsource, gfc_expr *mask)\n }\n \n \n-try\n+gfc_try\n gfc_check_move_alloc (gfc_expr *from, gfc_expr *to)\n {\n   symbol_attribute attr;\n@@ -2068,7 +2068,7 @@ gfc_check_move_alloc (gfc_expr *from, gfc_expr *to)\n }\n \n \n-try\n+gfc_try\n gfc_check_nearest (gfc_expr *x, gfc_expr *s)\n {\n   if (type_check (x, 0, BT_REAL) == FAILURE)\n@@ -2081,7 +2081,7 @@ gfc_check_nearest (gfc_expr *x, gfc_expr *s)\n }\n \n \n-try\n+gfc_try\n gfc_check_new_line (gfc_expr *a)\n {\n   if (type_check (a, 0, BT_CHARACTER) == FAILURE)\n@@ -2091,7 +2091,7 @@ gfc_check_new_line (gfc_expr *a)\n }\n \n \n-try\n+gfc_try\n gfc_check_null (gfc_expr *mold)\n {\n   symbol_attribute attr;\n@@ -2116,7 +2116,7 @@ gfc_check_null (gfc_expr *mold)\n }\n \n \n-try\n+gfc_try\n gfc_check_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)\n {\n   char buffer[80];\n@@ -2148,7 +2148,7 @@ gfc_check_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)\n }\n \n \n-try\n+gfc_try\n gfc_check_precision (gfc_expr *x)\n {\n   if (x->ts.type != BT_REAL && x->ts.type != BT_COMPLEX)\n@@ -2163,7 +2163,7 @@ gfc_check_precision (gfc_expr *x)\n }\n \n \n-try\n+gfc_try\n gfc_check_present (gfc_expr *a)\n {\n   gfc_symbol *sym;\n@@ -2208,7 +2208,7 @@ gfc_check_present (gfc_expr *a)\n }\n \n \n-try\n+gfc_try\n gfc_check_radix (gfc_expr *x)\n {\n   if (int_or_real_check (x, 0) == FAILURE)\n@@ -2218,7 +2218,7 @@ gfc_check_radix (gfc_expr *x)\n }\n \n \n-try\n+gfc_try\n gfc_check_range (gfc_expr *x)\n {\n   if (numeric_check (x, 0) == FAILURE)\n@@ -2229,7 +2229,7 @@ gfc_check_range (gfc_expr *x)\n \n \n /* real, float, sngl.  */\n-try\n+gfc_try\n gfc_check_real (gfc_expr *a, gfc_expr *kind)\n {\n   if (numeric_check (a, 0) == FAILURE)\n@@ -2242,7 +2242,7 @@ gfc_check_real (gfc_expr *a, gfc_expr *kind)\n }\n \n \n-try\n+gfc_try\n gfc_check_rename (gfc_expr *path1, gfc_expr *path2)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n@@ -2259,7 +2259,7 @@ gfc_check_rename (gfc_expr *path1, gfc_expr *path2)\n }\n \n \n-try\n+gfc_try\n gfc_check_rename_sub (gfc_expr *path1, gfc_expr *path2, gfc_expr *status)\n {\n   if (type_check (path1, 0, BT_CHARACTER) == FAILURE)\n@@ -2285,7 +2285,7 @@ gfc_check_rename_sub (gfc_expr *path1, gfc_expr *path2, gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_repeat (gfc_expr *x, gfc_expr *y)\n {\n   if (type_check (x, 0, BT_CHARACTER) == FAILURE)\n@@ -2304,7 +2304,7 @@ gfc_check_repeat (gfc_expr *x, gfc_expr *y)\n }\n \n \n-try\n+gfc_try\n gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \t\t   gfc_expr *pad, gfc_expr *order)\n {\n@@ -2383,7 +2383,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n }\n \n \n-try\n+gfc_try\n gfc_check_scale (gfc_expr *x, gfc_expr *i)\n {\n   if (type_check (x, 0, BT_REAL) == FAILURE)\n@@ -2396,7 +2396,7 @@ gfc_check_scale (gfc_expr *x, gfc_expr *i)\n }\n \n \n-try\n+gfc_try\n gfc_check_scan (gfc_expr *x, gfc_expr *y, gfc_expr *z, gfc_expr *kind)\n {\n   if (type_check (x, 0, BT_CHARACTER) == FAILURE)\n@@ -2422,7 +2422,7 @@ gfc_check_scan (gfc_expr *x, gfc_expr *y, gfc_expr *z, gfc_expr *kind)\n }\n \n \n-try\n+gfc_try\n gfc_check_secnds (gfc_expr *r)\n {\n   if (type_check (r, 0, BT_REAL) == FAILURE)\n@@ -2438,7 +2438,7 @@ gfc_check_secnds (gfc_expr *r)\n }\n \n \n-try\n+gfc_try\n gfc_check_selected_char_kind (gfc_expr *name)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n@@ -2454,7 +2454,7 @@ gfc_check_selected_char_kind (gfc_expr *name)\n }\n \n \n-try\n+gfc_try\n gfc_check_selected_int_kind (gfc_expr *r)\n {\n   if (type_check (r, 0, BT_INTEGER) == FAILURE)\n@@ -2467,7 +2467,7 @@ gfc_check_selected_int_kind (gfc_expr *r)\n }\n \n \n-try\n+gfc_try\n gfc_check_selected_real_kind (gfc_expr *p, gfc_expr *r)\n {\n   if (p == NULL && r == NULL)\n@@ -2488,7 +2488,7 @@ gfc_check_selected_real_kind (gfc_expr *p, gfc_expr *r)\n }\n \n \n-try\n+gfc_try\n gfc_check_set_exponent (gfc_expr *x, gfc_expr *i)\n {\n   if (type_check (x, 0, BT_REAL) == FAILURE)\n@@ -2501,7 +2501,7 @@ gfc_check_set_exponent (gfc_expr *x, gfc_expr *i)\n }\n \n \n-try\n+gfc_try\n gfc_check_shape (gfc_expr *source)\n {\n   gfc_array_ref *ar;\n@@ -2522,7 +2522,7 @@ gfc_check_shape (gfc_expr *source)\n }\n \n \n-try\n+gfc_try\n gfc_check_sign (gfc_expr *a, gfc_expr *b)\n {\n   if (int_or_real_check (a, 0) == FAILURE)\n@@ -2535,7 +2535,7 @@ gfc_check_sign (gfc_expr *a, gfc_expr *b)\n }\n \n \n-try\n+gfc_try\n gfc_check_size (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n {\n   if (array_check (array, 0) == FAILURE)\n@@ -2562,14 +2562,14 @@ gfc_check_size (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n }\n \n \n-try\n+gfc_try\n gfc_check_sizeof (gfc_expr *arg ATTRIBUTE_UNUSED)\n {\n   return SUCCESS;\n }\n \n \n-try\n+gfc_try\n gfc_check_sleep_sub (gfc_expr *seconds)\n {\n   if (type_check (seconds, 0, BT_INTEGER) == FAILURE)\n@@ -2582,7 +2582,7 @@ gfc_check_sleep_sub (gfc_expr *seconds)\n }\n \n \n-try\n+gfc_try\n gfc_check_spread (gfc_expr *source, gfc_expr *dim, gfc_expr *ncopies)\n {\n   if (source->rank >= GFC_MAX_DIMENSIONS)\n@@ -2613,7 +2613,7 @@ gfc_check_spread (gfc_expr *source, gfc_expr *dim, gfc_expr *ncopies)\n /* Functions for checking FGETC, FPUTC, FGET and FPUT (subroutines and\n    functions).  */\n \n-try\n+gfc_try\n gfc_check_fgetputc_sub (gfc_expr *unit, gfc_expr *c, gfc_expr *status)\n {\n   if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n@@ -2639,14 +2639,14 @@ gfc_check_fgetputc_sub (gfc_expr *unit, gfc_expr *c, gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_fgetputc (gfc_expr *unit, gfc_expr *c)\n {\n   return gfc_check_fgetputc_sub (unit, c, NULL);\n }\n \n \n-try\n+gfc_try\n gfc_check_fgetput_sub (gfc_expr *c, gfc_expr *status)\n {\n   if (type_check (c, 0, BT_CHARACTER) == FAILURE)\n@@ -2666,14 +2666,14 @@ gfc_check_fgetput_sub (gfc_expr *c, gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_fgetput (gfc_expr *c)\n {\n   return gfc_check_fgetput_sub (c, NULL);\n }\n \n \n-try\n+gfc_try\n gfc_check_fseek_sub (gfc_expr *unit, gfc_expr *offset, gfc_expr *whence, gfc_expr *status)\n {\n   if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n@@ -2711,7 +2711,7 @@ gfc_check_fseek_sub (gfc_expr *unit, gfc_expr *offset, gfc_expr *whence, gfc_exp\n \n \n \n-try\n+gfc_try\n gfc_check_fstat (gfc_expr *unit, gfc_expr *array)\n {\n   if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n@@ -2731,7 +2731,7 @@ gfc_check_fstat (gfc_expr *unit, gfc_expr *array)\n }\n \n \n-try\n+gfc_try\n gfc_check_fstat_sub (gfc_expr *unit, gfc_expr *array, gfc_expr *status)\n {\n   if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n@@ -2761,7 +2761,7 @@ gfc_check_fstat_sub (gfc_expr *unit, gfc_expr *array, gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_ftell (gfc_expr *unit)\n {\n   if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n@@ -2774,7 +2774,7 @@ gfc_check_ftell (gfc_expr *unit)\n }\n \n \n-try\n+gfc_try\n gfc_check_ftell_sub (gfc_expr *unit, gfc_expr *offset)\n {\n   if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n@@ -2793,7 +2793,7 @@ gfc_check_ftell_sub (gfc_expr *unit, gfc_expr *offset)\n }\n \n \n-try\n+gfc_try\n gfc_check_stat (gfc_expr *name, gfc_expr *array)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n@@ -2812,7 +2812,7 @@ gfc_check_stat (gfc_expr *name, gfc_expr *array)\n }\n \n \n-try\n+gfc_try\n gfc_check_stat_sub (gfc_expr *name, gfc_expr *array, gfc_expr *status)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n@@ -2841,7 +2841,7 @@ gfc_check_stat_sub (gfc_expr *name, gfc_expr *array, gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_transfer (gfc_expr *source ATTRIBUTE_UNUSED,\n \t\t    gfc_expr *mold ATTRIBUTE_UNUSED, gfc_expr *size)\n {\n@@ -2868,7 +2868,7 @@ gfc_check_transfer (gfc_expr *source ATTRIBUTE_UNUSED,\n }\n \n \n-try\n+gfc_try\n gfc_check_transpose (gfc_expr *matrix)\n {\n   if (rank_check (matrix, 0, 2) == FAILURE)\n@@ -2878,7 +2878,7 @@ gfc_check_transpose (gfc_expr *matrix)\n }\n \n \n-try\n+gfc_try\n gfc_check_ubound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n {\n   if (array_check (array, 0) == FAILURE)\n@@ -2904,7 +2904,7 @@ gfc_check_ubound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n }\n \n \n-try\n+gfc_try\n gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n {\n   if (rank_check (vector, 0, 1) == FAILURE)\n@@ -2942,7 +2942,7 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n }\n \n \n-try\n+gfc_try\n gfc_check_verify (gfc_expr *x, gfc_expr *y, gfc_expr *z, gfc_expr *kind)\n {\n   if (type_check (x, 0, BT_CHARACTER) == FAILURE)\n@@ -2965,7 +2965,7 @@ gfc_check_verify (gfc_expr *x, gfc_expr *y, gfc_expr *z, gfc_expr *kind)\n }\n \n \n-try\n+gfc_try\n gfc_check_trim (gfc_expr *x)\n {\n   if (type_check (x, 0, BT_CHARACTER) == FAILURE)\n@@ -2978,7 +2978,7 @@ gfc_check_trim (gfc_expr *x)\n }\n \n \n-try\n+gfc_try\n gfc_check_ttynam (gfc_expr *unit)\n {\n   if (scalar_check (unit, 0) == FAILURE)\n@@ -2994,7 +2994,7 @@ gfc_check_ttynam (gfc_expr *unit)\n /* Common check function for the half a dozen intrinsics that have a\n    single real argument.  */\n \n-try\n+gfc_try\n gfc_check_x (gfc_expr *x)\n {\n   if (type_check (x, 0, BT_REAL) == FAILURE)\n@@ -3006,7 +3006,7 @@ gfc_check_x (gfc_expr *x)\n \n /************* Check functions for intrinsic subroutines *************/\n \n-try\n+gfc_try\n gfc_check_cpu_time (gfc_expr *time)\n {\n   if (scalar_check (time, 0) == FAILURE)\n@@ -3022,7 +3022,7 @@ gfc_check_cpu_time (gfc_expr *time)\n }\n \n \n-try\n+gfc_try\n gfc_check_date_and_time (gfc_expr *date, gfc_expr *time,\n \t\t\t gfc_expr *zone, gfc_expr *values)\n {\n@@ -3078,7 +3078,7 @@ gfc_check_date_and_time (gfc_expr *date, gfc_expr *time,\n }\n \n \n-try\n+gfc_try\n gfc_check_mvbits (gfc_expr *from, gfc_expr *frompos, gfc_expr *len,\n \t\t  gfc_expr *to, gfc_expr *topos)\n {\n@@ -3104,7 +3104,7 @@ gfc_check_mvbits (gfc_expr *from, gfc_expr *frompos, gfc_expr *len,\n }\n \n \n-try\n+gfc_try\n gfc_check_random_number (gfc_expr *harvest)\n {\n   if (type_check (harvest, 0, BT_REAL) == FAILURE)\n@@ -3117,7 +3117,7 @@ gfc_check_random_number (gfc_expr *harvest)\n }\n \n \n-try\n+gfc_try\n gfc_check_random_seed (gfc_expr *size, gfc_expr *put, gfc_expr *get)\n {\n   unsigned int nargs = 0;\n@@ -3197,7 +3197,7 @@ gfc_check_random_seed (gfc_expr *size, gfc_expr *put, gfc_expr *get)\n }\n \n \n-try\n+gfc_try\n gfc_check_second_sub (gfc_expr *time)\n {\n   if (scalar_check (time, 0) == FAILURE)\n@@ -3216,7 +3216,7 @@ gfc_check_second_sub (gfc_expr *time)\n /* The arguments of SYSTEM_CLOCK are scalar, integer variables.  Note,\n    count, count_rate, and count_max are all optional arguments */\n \n-try\n+gfc_try\n gfc_check_system_clock (gfc_expr *count, gfc_expr *count_rate,\n \t\t\tgfc_expr *count_max)\n {\n@@ -3273,7 +3273,7 @@ gfc_check_system_clock (gfc_expr *count, gfc_expr *count_rate,\n }\n \n \n-try\n+gfc_try\n gfc_check_irand (gfc_expr *x)\n {\n   if (x == NULL)\n@@ -3292,7 +3292,7 @@ gfc_check_irand (gfc_expr *x)\n }\n \n \n-try\n+gfc_try\n gfc_check_alarm_sub (gfc_expr *seconds, gfc_expr *handler, gfc_expr *status)\n {\n   if (scalar_check (seconds, 0) == FAILURE)\n@@ -3328,7 +3328,7 @@ gfc_check_alarm_sub (gfc_expr *seconds, gfc_expr *handler, gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_rand (gfc_expr *x)\n {\n   if (x == NULL)\n@@ -3347,7 +3347,7 @@ gfc_check_rand (gfc_expr *x)\n }\n \n \n-try\n+gfc_try\n gfc_check_srand (gfc_expr *x)\n {\n   if (scalar_check (x, 0) == FAILURE)\n@@ -3363,7 +3363,7 @@ gfc_check_srand (gfc_expr *x)\n }\n \n \n-try\n+gfc_try\n gfc_check_ctime_sub (gfc_expr *time, gfc_expr *result)\n {\n   if (scalar_check (time, 0) == FAILURE)\n@@ -3380,7 +3380,7 @@ gfc_check_ctime_sub (gfc_expr *time, gfc_expr *result)\n }\n \n \n-try\n+gfc_try\n gfc_check_dtime_etime (gfc_expr *x)\n {\n   if (array_check (x, 0) == FAILURE)\n@@ -3402,7 +3402,7 @@ gfc_check_dtime_etime (gfc_expr *x)\n }\n \n \n-try\n+gfc_try\n gfc_check_dtime_etime_sub (gfc_expr *values, gfc_expr *time)\n {\n   if (array_check (values, 0) == FAILURE)\n@@ -3433,7 +3433,7 @@ gfc_check_dtime_etime_sub (gfc_expr *values, gfc_expr *time)\n }\n \n \n-try\n+gfc_try\n gfc_check_fdate_sub (gfc_expr *date)\n {\n   if (type_check (date, 0, BT_CHARACTER) == FAILURE)\n@@ -3445,7 +3445,7 @@ gfc_check_fdate_sub (gfc_expr *date)\n }\n \n \n-try\n+gfc_try\n gfc_check_gerror (gfc_expr *msg)\n {\n   if (type_check (msg, 0, BT_CHARACTER) == FAILURE)\n@@ -3457,7 +3457,7 @@ gfc_check_gerror (gfc_expr *msg)\n }\n \n \n-try\n+gfc_try\n gfc_check_getcwd_sub (gfc_expr *cwd, gfc_expr *status)\n {\n   if (type_check (cwd, 0, BT_CHARACTER) == FAILURE)\n@@ -3478,7 +3478,7 @@ gfc_check_getcwd_sub (gfc_expr *cwd, gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_getarg (gfc_expr *pos, gfc_expr *value)\n {\n   if (type_check (pos, 0, BT_INTEGER) == FAILURE)\n@@ -3502,7 +3502,7 @@ gfc_check_getarg (gfc_expr *pos, gfc_expr *value)\n }\n \n \n-try\n+gfc_try\n gfc_check_getlog (gfc_expr *msg)\n {\n   if (type_check (msg, 0, BT_CHARACTER) == FAILURE)\n@@ -3514,7 +3514,7 @@ gfc_check_getlog (gfc_expr *msg)\n }\n \n \n-try\n+gfc_try\n gfc_check_exit (gfc_expr *status)\n {\n   if (status == NULL)\n@@ -3530,7 +3530,7 @@ gfc_check_exit (gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_flush (gfc_expr *unit)\n {\n   if (unit == NULL)\n@@ -3546,7 +3546,7 @@ gfc_check_flush (gfc_expr *unit)\n }\n \n \n-try\n+gfc_try\n gfc_check_free (gfc_expr *i)\n {\n   if (type_check (i, 0, BT_INTEGER) == FAILURE)\n@@ -3559,7 +3559,7 @@ gfc_check_free (gfc_expr *i)\n }\n \n \n-try\n+gfc_try\n gfc_check_hostnm (gfc_expr *name)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n@@ -3571,7 +3571,7 @@ gfc_check_hostnm (gfc_expr *name)\n }\n \n \n-try\n+gfc_try\n gfc_check_hostnm_sub (gfc_expr *name, gfc_expr *status)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n@@ -3592,7 +3592,7 @@ gfc_check_hostnm_sub (gfc_expr *name, gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_itime_idate (gfc_expr *values)\n {\n   if (array_check (values, 0) == FAILURE)\n@@ -3614,7 +3614,7 @@ gfc_check_itime_idate (gfc_expr *values)\n }\n \n \n-try\n+gfc_try\n gfc_check_ltime_gmtime (gfc_expr *time, gfc_expr *values)\n {\n   if (type_check (time, 0, BT_INTEGER) == FAILURE)\n@@ -3645,7 +3645,7 @@ gfc_check_ltime_gmtime (gfc_expr *time, gfc_expr *values)\n }\n \n \n-try\n+gfc_try\n gfc_check_ttynam_sub (gfc_expr *unit, gfc_expr *name)\n {\n   if (scalar_check (unit, 0) == FAILURE)\n@@ -3663,7 +3663,7 @@ gfc_check_ttynam_sub (gfc_expr *unit, gfc_expr *name)\n }\n \n \n-try\n+gfc_try\n gfc_check_isatty (gfc_expr *unit)\n {\n   if (unit == NULL)\n@@ -3679,7 +3679,7 @@ gfc_check_isatty (gfc_expr *unit)\n }\n \n \n-try\n+gfc_try\n gfc_check_isnan (gfc_expr *x)\n {\n   if (type_check (x, 0, BT_REAL) == FAILURE)\n@@ -3689,7 +3689,7 @@ gfc_check_isnan (gfc_expr *x)\n }\n \n \n-try\n+gfc_try\n gfc_check_perror (gfc_expr *string)\n {\n   if (type_check (string, 0, BT_CHARACTER) == FAILURE)\n@@ -3701,7 +3701,7 @@ gfc_check_perror (gfc_expr *string)\n }\n \n \n-try\n+gfc_try\n gfc_check_umask (gfc_expr *mask)\n {\n   if (type_check (mask, 0, BT_INTEGER) == FAILURE)\n@@ -3714,7 +3714,7 @@ gfc_check_umask (gfc_expr *mask)\n }\n \n \n-try\n+gfc_try\n gfc_check_umask_sub (gfc_expr *mask, gfc_expr *old)\n {\n   if (type_check (mask, 0, BT_INTEGER) == FAILURE)\n@@ -3736,7 +3736,7 @@ gfc_check_umask_sub (gfc_expr *mask, gfc_expr *old)\n }\n \n \n-try\n+gfc_try\n gfc_check_unlink (gfc_expr *name)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n@@ -3748,7 +3748,7 @@ gfc_check_unlink (gfc_expr *name)\n }\n \n \n-try\n+gfc_try\n gfc_check_unlink_sub (gfc_expr *name, gfc_expr *status)\n {\n   if (type_check (name, 0, BT_CHARACTER) == FAILURE)\n@@ -3769,7 +3769,7 @@ gfc_check_unlink_sub (gfc_expr *name, gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_signal (gfc_expr *number, gfc_expr *handler)\n {\n   if (scalar_check (number, 0) == FAILURE)\n@@ -3793,7 +3793,7 @@ gfc_check_signal (gfc_expr *number, gfc_expr *handler)\n }\n \n \n-try\n+gfc_try\n gfc_check_signal_sub (gfc_expr *number, gfc_expr *handler, gfc_expr *status)\n {\n   if (scalar_check (number, 0) == FAILURE)\n@@ -3826,7 +3826,7 @@ gfc_check_signal_sub (gfc_expr *number, gfc_expr *handler, gfc_expr *status)\n }\n \n \n-try\n+gfc_try\n gfc_check_system_sub (gfc_expr *cmd, gfc_expr *status)\n {\n   if (type_check (cmd, 0, BT_CHARACTER) == FAILURE)\n@@ -3848,7 +3848,7 @@ gfc_check_system_sub (gfc_expr *cmd, gfc_expr *status)\n \n \n /* This is used for the GNU intrinsics AND, OR and XOR.  */\n-try\n+gfc_try\n gfc_check_and (gfc_expr *i, gfc_expr *j)\n {\n   if (i->ts.type != BT_INTEGER && i->ts.type != BT_LOGICAL)"}, {"sha": "86e0335dc9fd22d4c0b3a9e7fb682e3ee1e7f137", "filename": "gcc/fortran/cpp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcpp.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -574,7 +574,7 @@ gfc_cpp_init (void)\n     pp_dir_change (cpp_in, get_src_pwd ());\n }\n \n-try\n+gfc_try\n gfc_cpp_preprocess (const char *source_file)\n {\n   if (!gfc_cpp_enabled ())"}, {"sha": "db245021110c2ba9ec997c17f56af173a1f9076f", "filename": "gcc/fortran/cpp.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fcpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fcpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcpp.h?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -36,7 +36,7 @@ int gfc_cpp_handle_option(size_t scode, const char *arg, int value);\n \n void gfc_cpp_post_options (void);\n \n-try gfc_cpp_preprocess (const char *source_file);\n+gfc_try gfc_cpp_preprocess (const char *source_file);\n \n void gfc_cpp_done (void);\n "}, {"sha": "09dde150b225b628fc924bcaefcdc6ced582859e", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -46,7 +46,7 @@ get_array_index (gfc_array_ref *ar, mpz_t *offset)\n {\n   gfc_expr *e;\n   int i;\n-  try re;\n+  gfc_try re;\n   mpz_t delta;\n   mpz_t tmp;\n \n@@ -247,7 +247,7 @@ create_character_intializer (gfc_expr *init, gfc_typespec *ts,\n    LVALUE already has an initialization, we extend this, otherwise we\n    create a new one.  */\n \n-try\n+gfc_try\n gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n {\n   gfc_ref *ref;"}, {"sha": "0d31a920e6dc931c64067579589ac51d16f0ac0a", "filename": "gcc/fortran/data.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fdata.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fdata.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.h?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -19,6 +19,6 @@ along with GCC; see the file COPYING3.  If not see\n \n void gfc_formalize_init_value (gfc_symbol *);\n void gfc_get_section_index (gfc_array_ref *, mpz_t *, mpz_t *);\n-try gfc_assign_data_value (gfc_expr *, gfc_expr *, mpz_t);\n+gfc_try gfc_assign_data_value (gfc_expr *, gfc_expr *, mpz_t);\n void gfc_assign_data_value_range (gfc_expr *, gfc_expr *, mpz_t, mpz_t);\n void gfc_advance_section (mpz_t *, gfc_array_ref *, mpz_t *);"}, {"sha": "9b1e5853b1d6a5c70ea399200811ca0e5c9a1da8", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -867,11 +867,11 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n    the compiler could have automatically handled the varying sizes\n    across platforms.  */\n \n-try\n+gfc_try\n verify_c_interop_param (gfc_symbol *sym)\n {\n   int is_c_interop = 0;\n-  try retval = SUCCESS;\n+  gfc_try retval = SUCCESS;\n \n   /* We check implicitly typed variables in symbol.c:gfc_set_default_type().\n      Don't repeat the checks here.  */\n@@ -1009,7 +1009,7 @@ verify_c_interop_param (gfc_symbol *sym)\n \n /* Function called by variable_decl() that adds a name to the symbol table.  */\n \n-static try\n+static gfc_try\n build_sym (const char *name, gfc_charlen *cl,\n \t   gfc_array_spec **as, locus *var_locus)\n {\n@@ -1185,7 +1185,7 @@ gfc_free_enum_history (void)\n /* Function called by variable_decl() that adds an initialization\n    expression to a symbol.  */\n \n-static try\n+static gfc_try\n add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n {\n   symbol_attribute attr;\n@@ -1362,7 +1362,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n /* Function called by variable_decl() that adds a name to a structure\n    being built.  */\n \n-static try\n+static gfc_try\n build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n \t      gfc_array_spec **as)\n {\n@@ -1548,7 +1548,7 @@ variable_decl (int elem)\n   gfc_charlen *cl;\n   locus var_locus;\n   match m;\n-  try t;\n+  gfc_try t;\n   gfc_symbol *sym;\n   locus old_locus;\n \n@@ -2786,7 +2786,7 @@ match_attr_spec (void)\n   decl_types d;\n   const char *attr;\n   match m;\n-  try t;\n+  gfc_try t;\n \n   gfc_clear_attr (&current_attr);\n   start = gfc_current_locus;\n@@ -3248,7 +3248,7 @@ match_attr_spec (void)\n    (J3/04-007, section 15.4.1).  If a binding label was given and\n    there is more than one argument (num_idents), it is an error.  */\n \n-try\n+gfc_try\n set_binding_label (char *dest_label, const char *sym_name, int num_idents)\n {\n   if (num_idents > 1 && has_name_equals)\n@@ -3288,10 +3288,10 @@ set_com_block_bind_c (gfc_common_head *com_block, int is_bind_c)\n \n /* Verify that the given gfc_typespec is for a C interoperable type.  */\n \n-try\n+gfc_try\n verify_c_interop (gfc_typespec *ts, const char *name, locus *where)\n {\n-  try t;\n+  gfc_try t;\n \n   /* Make sure the kind used is appropriate for the type.\n      The f90_type is unknown if an integer constant was\n@@ -3326,11 +3326,11 @@ verify_c_interop (gfc_typespec *ts, const char *name, locus *where)\n    interoperable type.  Errors will be reported here, if\n    encountered.  */\n \n-try\n+gfc_try\n verify_com_block_vars_c_interop (gfc_common_head *com_block)\n {\n   gfc_symbol *curr_sym = NULL;\n-  try retval = SUCCESS;\n+  gfc_try retval = SUCCESS;\n \n   curr_sym = com_block->head;\n   \n@@ -3354,11 +3354,11 @@ verify_com_block_vars_c_interop (gfc_common_head *com_block)\n /* Verify that a given BIND(C) symbol is C interoperable.  If it is not,\n    an appropriate error message is reported.  */\n \n-try\n+gfc_try\n verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n                    int is_in_common, gfc_common_head *com_block)\n {\n-  try retval = SUCCESS;\n+  gfc_try retval = SUCCESS;\n \n   if (tmp_sym->attr.function && tmp_sym->result != NULL)\n     {\n@@ -3478,10 +3478,10 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n    the type is C interoperable.  Errors are reported by the functions\n    used to set/test these fields.  */\n \n-try\n+gfc_try\n set_verify_bind_c_sym (gfc_symbol *tmp_sym, int num_idents)\n {\n-  try retval = SUCCESS;\n+  gfc_try retval = SUCCESS;\n   \n   /* TODO: Do we need to make sure the vars aren't marked private?  */\n \n@@ -3499,10 +3499,10 @@ set_verify_bind_c_sym (gfc_symbol *tmp_sym, int num_idents)\n /* Set the fields marking the given common block as BIND(C), including\n    a binding label, and report any errors encountered.  */\n \n-try\n+gfc_try\n set_verify_bind_c_com_block (gfc_common_head *com_block, int num_idents)\n {\n-  try retval = SUCCESS;\n+  gfc_try retval = SUCCESS;\n   \n   /* destLabel, common name, typespec (which may have binding label).  */\n   if (set_binding_label (com_block->binding_label, com_block->name, num_idents)\n@@ -3519,7 +3519,7 @@ set_verify_bind_c_com_block (gfc_common_head *com_block, int num_idents)\n /* Retrieve the list of one or more identifiers that the given bind(c)\n    attribute applies to.  */\n \n-try\n+gfc_try\n get_bind_c_idents (void)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n@@ -3792,7 +3792,7 @@ gfc_match_prefix (gfc_typespec *ts)\n \n /* Copy attributes matched by gfc_match_prefix() to attributes on a symbol.  */\n \n-static try\n+static gfc_try\n copy_prefix (symbol_attribute *dest, locus *where)\n {\n   if (current_attr.pure && gfc_add_pure (dest, where) == FAILURE)\n@@ -6400,7 +6400,7 @@ gfc_match_derived_decl (void)\n    is the case. Since there is no bounds-checking for Cray Pointees,\n    this will be okay.  */\n \n-try\n+gfc_try\n gfc_mod_pointee_as (gfc_array_spec *as)\n {\n   as->cray_pointee = true; /* This will be useful to know later.  */\n@@ -6454,7 +6454,7 @@ enumerator_decl (void)\n   gfc_symbol *sym;\n   locus var_locus;\n   match m;\n-  try t;\n+  gfc_try t;\n   locus old_locus;\n \n   initializer = NULL;\n@@ -6537,7 +6537,7 @@ match\n gfc_match_enumerator_def (void)\n {\n   match m;\n-  try t;\n+  gfc_try t;\n \n   gfc_clear_ts (&current_ts);\n "}, {"sha": "7a5fbd347111e1547a5cca9825ab227d922586b3", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -754,7 +754,7 @@ gfc_notification_std (int std)\n    standard does not contain the requested bits.  Return FAILURE if\n    an error is generated.  */\n \n-try\n+gfc_try\n gfc_notify_std (int std, const char *nocmsgid, ...)\n {\n   va_list argp;"}, {"sha": "1e92e1470d9beaed9130b0f6389f75d8c3b5a0f0", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -824,7 +824,7 @@ is_subref_array (gfc_expr * e)\n \n /* Try to collapse intrinsic expressions.  */\n \n-static try\n+static gfc_try\n simplify_intrinsic_op (gfc_expr *p, int type)\n {\n   gfc_intrinsic_op op;\n@@ -960,7 +960,7 @@ simplify_intrinsic_op (gfc_expr *p, int type)\n /* Subroutine to simplify constructor expressions.  Mutually recursive\n    with gfc_simplify_expr().  */\n \n-static try\n+static gfc_try\n simplify_constructor (gfc_constructor *c, int type)\n {\n   gfc_expr *p;\n@@ -996,7 +996,7 @@ simplify_constructor (gfc_constructor *c, int type)\n \n /* Pull a single array element out of an array constructor.  */\n \n-static try\n+static gfc_try\n find_array_element (gfc_constructor *cons, gfc_array_ref *ar,\n \t\t    gfc_constructor **rval)\n {\n@@ -1007,7 +1007,7 @@ find_array_element (gfc_constructor *cons, gfc_array_ref *ar,\n   mpz_t span;\n   mpz_t tmp;\n   gfc_expr *e;\n-  try t;\n+  gfc_try t;\n \n   t = SUCCESS;\n   e = NULL;\n@@ -1115,7 +1115,7 @@ remove_subobject_ref (gfc_expr *p, gfc_constructor *cons)\n \n /* Pull an array section out of an array constructor.  */\n \n-static try\n+static gfc_try\n find_array_section (gfc_expr *expr, gfc_ref *ref)\n {\n   int idx;\n@@ -1142,7 +1142,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n   gfc_expr *upper;\n   gfc_expr *lower;\n   gfc_constructor *vecsub[GFC_MAX_DIMENSIONS], *c;\n-  try t;\n+  gfc_try t;\n \n   t = SUCCESS;\n \n@@ -1373,7 +1373,7 @@ find_array_section (gfc_expr *expr, gfc_ref *ref)\n \n /* Pull a substring out of an expression.  */\n \n-static try\n+static gfc_try\n find_substring_ref (gfc_expr *p, gfc_expr **newp)\n {\n   int end;\n@@ -1405,7 +1405,7 @@ find_substring_ref (gfc_expr *p, gfc_expr **newp)\n /* Simplify a subobject reference of a constructor.  This occurs when\n    parameter variable values are substituted.  */\n \n-static try\n+static gfc_try\n simplify_const_ref (gfc_expr *p)\n {\n   gfc_constructor *cons;\n@@ -1479,7 +1479,7 @@ simplify_const_ref (gfc_expr *p)\n \n /* Simplify a chain of references.  */\n \n-static try\n+static gfc_try\n simplify_ref_chain (gfc_ref *ref, int type)\n {\n   int n;\n@@ -1517,11 +1517,11 @@ simplify_ref_chain (gfc_ref *ref, int type)\n \n /* Try to substitute the value of a parameter variable.  */\n \n-static try\n+static gfc_try\n simplify_parameter_variable (gfc_expr *p, int type)\n {\n   gfc_expr *e;\n-  try t;\n+  gfc_try t;\n \n   e = gfc_copy_expr (p->symtree->n.sym->value);\n   if (e == NULL)\n@@ -1562,7 +1562,7 @@ simplify_parameter_variable (gfc_expr *p, int type)\n    Returns FAILURE on error, SUCCESS otherwise.\n    NOTE: Will return SUCCESS even if the expression can not be simplified.  */\n \n-try\n+gfc_try\n gfc_simplify_expr (gfc_expr *p, int type)\n {\n   gfc_actual_arglist *ap;\n@@ -1693,12 +1693,12 @@ et0 (gfc_expr *e)\n /* Check an intrinsic arithmetic operation to see if it is consistent\n    with some type of expression.  */\n \n-static try check_init_expr (gfc_expr *);\n+static gfc_try check_init_expr (gfc_expr *);\n \n \n /* Scalarize an expression for an elemental intrinsic call.  */\n \n-static try\n+static gfc_try\n scalarize_intrinsic_call (gfc_expr *e)\n {\n   gfc_actual_arglist *a, *b;\n@@ -1831,8 +1831,8 @@ scalarize_intrinsic_call (gfc_expr *e)\n }\n \n \n-static try\n-check_intrinsic_op (gfc_expr *e, try (*check_function) (gfc_expr *))\n+static gfc_try\n+check_intrinsic_op (gfc_expr *e, gfc_try (*check_function) (gfc_expr *))\n {\n   gfc_expr *op1 = e->value.op.op1;\n   gfc_expr *op2 = e->value.op.op2;\n@@ -2155,11 +2155,11 @@ check_conversion (gfc_expr *e)\n    intrinsics in the context of initialization expressions.  If\n    FAILURE is returned an error message has been generated.  */\n \n-static try\n+static gfc_try\n check_init_expr (gfc_expr *e)\n {\n   match m;\n-  try t;\n+  gfc_try t;\n \n   if (e == NULL)\n     return SUCCESS;\n@@ -2334,7 +2334,7 @@ gfc_match_init_expr (gfc_expr **result)\n {\n   gfc_expr *expr;\n   match m;\n-  try t;\n+  gfc_try t;\n \n   m = gfc_match_expr (&expr);\n   if (m != MATCH_YES)\n@@ -2375,13 +2375,13 @@ gfc_match_init_expr (gfc_expr **result)\n }\n \n \n-static try check_restricted (gfc_expr *);\n+static gfc_try check_restricted (gfc_expr *);\n \n /* Given an actual argument list, test to see that each argument is a\n    restricted expression and optionally if the expression type is\n    integer or character.  */\n \n-static try\n+static gfc_try\n restricted_args (gfc_actual_arglist *a)\n {\n   for (; a; a = a->next)\n@@ -2399,7 +2399,7 @@ restricted_args (gfc_actual_arglist *a)\n \n /* Make sure a non-intrinsic function is a specification function.  */\n \n-static try\n+static gfc_try\n external_spec_function (gfc_expr *e)\n {\n   gfc_symbol *f;\n@@ -2441,7 +2441,7 @@ external_spec_function (gfc_expr *e)\n /* Check to see that a function reference to an intrinsic is a\n    restricted expression.  */\n \n-static try\n+static gfc_try\n restricted_intrinsic (gfc_expr *e)\n {\n   /* TODO: Check constraints on inquiry functions.  7.1.6.2 (7).  */\n@@ -2456,11 +2456,11 @@ restricted_intrinsic (gfc_expr *e)\n    cousin check_init_expr(), an error message is generated if we\n    return FAILURE.  */\n \n-static try\n+static gfc_try\n check_restricted (gfc_expr *e)\n {\n   gfc_symbol *sym;\n-  try t;\n+  gfc_try t;\n \n   if (e == NULL)\n     return SUCCESS;\n@@ -2568,7 +2568,7 @@ check_restricted (gfc_expr *e)\n /* Check to see that an expression is a specification expression.  If\n    we return FAILURE, an error has been generated.  */\n \n-try\n+gfc_try\n gfc_specification_expr (gfc_expr *e)\n {\n \n@@ -2611,12 +2611,12 @@ gfc_specification_expr (gfc_expr *e)\n \n /* Given two expressions, make sure that the arrays are conformable.  */\n \n-try\n+gfc_try\n gfc_check_conformance (const char *optype_msgid, gfc_expr *op1, gfc_expr *op2)\n {\n   int op1_flag, op2_flag, d;\n   mpz_t op1_size, op2_size;\n-  try t;\n+  gfc_try t;\n \n   if (op1->rank == 0 || op2->rank == 0)\n     return SUCCESS;\n@@ -2661,7 +2661,7 @@ gfc_check_conformance (const char *optype_msgid, gfc_expr *op1, gfc_expr *op2)\n /* Given an assignable expression and an arbitrary expression, make\n    sure that the assignment can take place.  */\n \n-try\n+gfc_try\n gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n {\n   gfc_symbol *sym;\n@@ -2870,7 +2870,7 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n    we only check rvalue if it's not an assignment to NULL() or a\n    NULLIFY statement.  */\n \n-try\n+gfc_try\n gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n {\n   symbol_attribute attr;\n@@ -3018,11 +3018,11 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n /* Relative of gfc_check_assign() except that the lvalue is a single\n    symbol.  Used for initialization assignments.  */\n \n-try\n+gfc_try\n gfc_check_assign_symbol (gfc_symbol *sym, gfc_expr *rvalue)\n {\n   gfc_expr lvalue;\n-  try r;\n+  gfc_try r;\n \n   memset (&lvalue, '\\0', sizeof (gfc_expr));\n "}, {"sha": "72cd871acc20f44ac4c4941ad0fd8fc9cfb917e1", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 105, "deletions": 107, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -114,8 +114,6 @@ io_kind;\n    following enum makes things much more readable.  We also start\n    values off at one instead of zero.  */\n \n-/* FIXME: This macro is temporary until we convert everything.  */\n-#define try gfc_try\n typedef enum\n { SUCCESS = 1, FAILURE }\n gfc_try;\n@@ -1347,16 +1345,16 @@ gfc_intrinsic_arg;\n \n typedef union\n {\n-  try (*f0)(void);\n-  try (*f1)(struct gfc_expr *);\n-  try (*f1m)(gfc_actual_arglist *);\n-  try (*f2)(struct gfc_expr *, struct gfc_expr *);\n-  try (*f3)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *);\n-  try (*f3ml)(gfc_actual_arglist *);\n-  try (*f3red)(gfc_actual_arglist *);\n-  try (*f4)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *,\n+  gfc_try (*f0)(void);\n+  gfc_try (*f1)(struct gfc_expr *);\n+  gfc_try (*f1m)(gfc_actual_arglist *);\n+  gfc_try (*f2)(struct gfc_expr *, struct gfc_expr *);\n+  gfc_try (*f3)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *);\n+  gfc_try (*f3ml)(gfc_actual_arglist *);\n+  gfc_try (*f3red)(gfc_actual_arglist *);\n+  gfc_try (*f4)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *,\n \t    struct gfc_expr *);\n-  try (*f5)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *,\n+  gfc_try (*f5)(struct gfc_expr *, struct gfc_expr *, struct gfc_expr *,\n \t    struct gfc_expr *, struct gfc_expr *);\n }\n gfc_check_f;\n@@ -2011,7 +2009,7 @@ gfc_char_t gfc_peek_char (void);\n char gfc_peek_ascii_char (void);\n void gfc_error_recovery (void);\n void gfc_gobble_whitespace (void);\n-try gfc_new_file (void);\n+gfc_try gfc_new_file (void);\n const char * gfc_read_orig_filename (const char *, const char **);\n \n extern gfc_source_form gfc_current_form;\n@@ -2078,7 +2076,7 @@ int gfc_error_check (void);\n int gfc_error_flag_test (void);\n \n notification gfc_notification_std (int);\n-try gfc_notify_std (int, const char *, ...) ATTRIBUTE_GCC_GFC(2,3);\n+gfc_try gfc_notify_std (int, const char *, ...) ATTRIBUTE_GCC_GFC(2,3);\n \n /* A general purpose syntax error.  */\n #define gfc_syntax_error(ST)\t\\\n@@ -2098,8 +2096,8 @@ arith gfc_check_integer_range (mpz_t p, int kind);\n bool gfc_check_character_range (gfc_char_t, int);\n \n /* trans-types.c */\n-try gfc_validate_c_kind (gfc_typespec *);\n-try gfc_check_any_c_kind (gfc_typespec *);\n+gfc_try gfc_validate_c_kind (gfc_typespec *);\n+gfc_try gfc_check_any_c_kind (gfc_typespec *);\n int gfc_validate_kind (bt, int, bool);\n extern int gfc_index_integer_kind;\n extern int gfc_default_integer_kind;\n@@ -2117,77 +2115,77 @@ extern int gfc_character_storage_size;\n \n /* symbol.c */\n void gfc_clear_new_implicit (void);\n-try gfc_add_new_implicit_range (int, int);\n-try gfc_merge_new_implicit (gfc_typespec *);\n+gfc_try gfc_add_new_implicit_range (int, int);\n+gfc_try gfc_merge_new_implicit (gfc_typespec *);\n void gfc_set_implicit_none (void);\n void gfc_check_function_type (gfc_namespace *);\n bool gfc_is_intrinsic_typename (const char *);\n \n gfc_typespec *gfc_get_default_type (gfc_symbol *, gfc_namespace *);\n-try gfc_set_default_type (gfc_symbol *, int, gfc_namespace *);\n+gfc_try gfc_set_default_type (gfc_symbol *, int, gfc_namespace *);\n \n void gfc_set_component_attr (gfc_component *, symbol_attribute *);\n void gfc_get_component_attr (symbol_attribute *, gfc_component *);\n \n void gfc_set_sym_referenced (gfc_symbol *);\n \n-try gfc_add_attribute (symbol_attribute *, locus *);\n-try gfc_add_allocatable (symbol_attribute *, locus *);\n-try gfc_add_dimension (symbol_attribute *, const char *, locus *);\n-try gfc_add_external (symbol_attribute *, locus *);\n-try gfc_add_intrinsic (symbol_attribute *, locus *);\n-try gfc_add_optional (symbol_attribute *, locus *);\n-try gfc_add_pointer (symbol_attribute *, locus *);\n-try gfc_add_cray_pointer (symbol_attribute *, locus *);\n-try gfc_add_cray_pointee (symbol_attribute *, locus *);\n-try gfc_mod_pointee_as (gfc_array_spec *);\n-try gfc_add_protected (symbol_attribute *, const char *, locus *);\n-try gfc_add_result (symbol_attribute *, const char *, locus *);\n-try gfc_add_save (symbol_attribute *, const char *, locus *);\n-try gfc_add_threadprivate (symbol_attribute *, const char *, locus *);\n-try gfc_add_saved_common (symbol_attribute *, locus *);\n-try gfc_add_target (symbol_attribute *, locus *);\n-try gfc_add_dummy (symbol_attribute *, const char *, locus *);\n-try gfc_add_generic (symbol_attribute *, const char *, locus *);\n-try gfc_add_common (symbol_attribute *, locus *);\n-try gfc_add_in_common (symbol_attribute *, const char *, locus *);\n-try gfc_add_in_equivalence (symbol_attribute *, const char *, locus *);\n-try gfc_add_data (symbol_attribute *, const char *, locus *);\n-try gfc_add_in_namelist (symbol_attribute *, const char *, locus *);\n-try gfc_add_sequence (symbol_attribute *, const char *, locus *);\n-try gfc_add_elemental (symbol_attribute *, locus *);\n-try gfc_add_pure (symbol_attribute *, locus *);\n-try gfc_add_recursive (symbol_attribute *, locus *);\n-try gfc_add_function (symbol_attribute *, const char *, locus *);\n-try gfc_add_subroutine (symbol_attribute *, const char *, locus *);\n-try gfc_add_volatile (symbol_attribute *, const char *, locus *);\n-try gfc_add_proc (symbol_attribute *attr, const char *name, locus *where);\n-\n-try gfc_add_access (symbol_attribute *, gfc_access, const char *, locus *);\n-try gfc_add_is_bind_c(symbol_attribute *, const char *, locus *, int);\n-try gfc_add_value (symbol_attribute *, const char *, locus *);\n-try gfc_add_flavor (symbol_attribute *, sym_flavor, const char *, locus *);\n-try gfc_add_entry (symbol_attribute *, const char *, locus *);\n-try gfc_add_procedure (symbol_attribute *, procedure_type,\n+gfc_try gfc_add_attribute (symbol_attribute *, locus *);\n+gfc_try gfc_add_allocatable (symbol_attribute *, locus *);\n+gfc_try gfc_add_dimension (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_external (symbol_attribute *, locus *);\n+gfc_try gfc_add_intrinsic (symbol_attribute *, locus *);\n+gfc_try gfc_add_optional (symbol_attribute *, locus *);\n+gfc_try gfc_add_pointer (symbol_attribute *, locus *);\n+gfc_try gfc_add_cray_pointer (symbol_attribute *, locus *);\n+gfc_try gfc_add_cray_pointee (symbol_attribute *, locus *);\n+gfc_try gfc_mod_pointee_as (gfc_array_spec *);\n+gfc_try gfc_add_protected (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_result (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_save (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_threadprivate (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_saved_common (symbol_attribute *, locus *);\n+gfc_try gfc_add_target (symbol_attribute *, locus *);\n+gfc_try gfc_add_dummy (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_generic (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_common (symbol_attribute *, locus *);\n+gfc_try gfc_add_in_common (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_in_equivalence (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_data (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_in_namelist (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_sequence (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_elemental (symbol_attribute *, locus *);\n+gfc_try gfc_add_pure (symbol_attribute *, locus *);\n+gfc_try gfc_add_recursive (symbol_attribute *, locus *);\n+gfc_try gfc_add_function (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_subroutine (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_volatile (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_proc (symbol_attribute *attr, const char *name, locus *where);\n+\n+gfc_try gfc_add_access (symbol_attribute *, gfc_access, const char *, locus *);\n+gfc_try gfc_add_is_bind_c(symbol_attribute *, const char *, locus *, int);\n+gfc_try gfc_add_value (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_flavor (symbol_attribute *, sym_flavor, const char *, locus *);\n+gfc_try gfc_add_entry (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_procedure (symbol_attribute *, procedure_type,\n \t\t       const char *, locus *);\n-try gfc_add_intent (symbol_attribute *, sym_intent, locus *);\n-try gfc_add_explicit_interface (gfc_symbol *, ifsrc,\n+gfc_try gfc_add_intent (symbol_attribute *, sym_intent, locus *);\n+gfc_try gfc_add_explicit_interface (gfc_symbol *, ifsrc,\n \t\t\t\tgfc_formal_arglist *, locus *);\n-try gfc_add_type (gfc_symbol *, gfc_typespec *, locus *);\n+gfc_try gfc_add_type (gfc_symbol *, gfc_typespec *, locus *);\n \n void gfc_clear_attr (symbol_attribute *);\n-try gfc_missing_attr (symbol_attribute *, locus *);\n-try gfc_copy_attr (symbol_attribute *, symbol_attribute *, locus *);\n+gfc_try gfc_missing_attr (symbol_attribute *, locus *);\n+gfc_try gfc_copy_attr (symbol_attribute *, symbol_attribute *, locus *);\n \n-try gfc_add_component (gfc_symbol *, const char *, gfc_component **);\n+gfc_try gfc_add_component (gfc_symbol *, const char *, gfc_component **);\n gfc_symbol *gfc_use_derived (gfc_symbol *);\n gfc_symtree *gfc_use_derived_tree (gfc_symtree *);\n gfc_component *gfc_find_component (gfc_symbol *, const char *);\n \n gfc_st_label *gfc_get_st_label (int);\n void gfc_free_st_label (gfc_st_label *);\n void gfc_define_st_label (gfc_st_label *, gfc_sl_type, locus *);\n-try gfc_reference_st_label (gfc_st_label *, gfc_sl_type);\n+gfc_try gfc_reference_st_label (gfc_st_label *, gfc_sl_type);\n \n gfc_expr * gfc_lval_expr_from_sym (gfc_symbol *);\n \n@@ -2203,11 +2201,11 @@ gfc_symbol *gfc_new_symbol (const char *, gfc_namespace *);\n int gfc_find_symbol (const char *, gfc_namespace *, int, gfc_symbol **);\n int gfc_find_sym_tree (const char *, gfc_namespace *, int, gfc_symtree **);\n int gfc_get_symbol (const char *, gfc_namespace *, gfc_symbol **);\n-try verify_c_interop (gfc_typespec *, const char *name, locus *where);\n-try verify_c_interop_param (gfc_symbol *);\n-try verify_bind_c_sym (gfc_symbol *, gfc_typespec *, int, gfc_common_head *);\n-try verify_bind_c_derived_type (gfc_symbol *);\n-try verify_com_block_vars_c_interop (gfc_common_head *);\n+gfc_try verify_c_interop (gfc_typespec *, const char *name, locus *where);\n+gfc_try verify_c_interop_param (gfc_symbol *);\n+gfc_try verify_bind_c_sym (gfc_symbol *, gfc_typespec *, int, gfc_common_head *);\n+gfc_try verify_bind_c_derived_type (gfc_symbol *);\n+gfc_try verify_com_block_vars_c_interop (gfc_common_head *);\n void generate_isocbinding_symbol (const char *, iso_c_binding_symbol, const char *);\n gfc_symbol *get_iso_c_sym (gfc_symbol *, char *, char *, int);\n int gfc_get_sym_tree (const char *, gfc_namespace *, gfc_symtree **);\n@@ -2252,9 +2250,9 @@ void gfc_intrinsic_done_1 (void);\n \n char gfc_type_letter (bt);\n gfc_symbol * gfc_get_intrinsic_sub_symbol (const char *);\n-try gfc_convert_type (gfc_expr *, gfc_typespec *, int);\n-try gfc_convert_type_warn (gfc_expr *, gfc_typespec *, int, int);\n-try gfc_convert_chartype (gfc_expr *, gfc_typespec *);\n+gfc_try gfc_convert_type (gfc_expr *, gfc_typespec *, int);\n+gfc_try gfc_convert_type_warn (gfc_expr *, gfc_typespec *, int, int);\n+gfc_try gfc_convert_chartype (gfc_expr *, gfc_typespec *);\n int gfc_generic_intrinsic (const char *);\n int gfc_specific_intrinsic (const char *);\n bool gfc_is_intrinsic (gfc_symbol*, int, locus);\n@@ -2266,8 +2264,8 @@ match gfc_intrinsic_func_interface (gfc_expr *, int);\n match gfc_intrinsic_sub_interface (gfc_code *, int);\n \n void gfc_warn_intrinsic_shadow (const gfc_symbol*, bool, bool);\n-try gfc_check_intrinsic_standard (const gfc_intrinsic_sym*, const char**,\n-\t\t\t\t  bool, locus);\n+gfc_try gfc_check_intrinsic_standard (const gfc_intrinsic_sym*, const char**,\n+\t\t\t\t      bool, locus);\n \n /* match.c -- FIXME */\n void gfc_free_iterator (gfc_iterator *, int);\n@@ -2299,7 +2297,7 @@ gfc_expr *gfc_build_conversion (gfc_expr *);\n void gfc_free_ref_list (gfc_ref *);\n void gfc_type_convert_binary (gfc_expr *);\n int gfc_is_constant_expr (gfc_expr *);\n-try gfc_simplify_expr (gfc_expr *, int);\n+gfc_try gfc_simplify_expr (gfc_expr *, int);\n int gfc_has_vector_index (gfc_expr *);\n \n gfc_expr *gfc_get_expr (void);\n@@ -2311,15 +2309,15 @@ mpz_t *gfc_copy_shape (mpz_t *, int);\n mpz_t *gfc_copy_shape_excluding (mpz_t *, int, gfc_expr *);\n gfc_expr *gfc_copy_expr (gfc_expr *);\n \n-try gfc_specification_expr (gfc_expr *);\n+gfc_try gfc_specification_expr (gfc_expr *);\n \n int gfc_numeric_ts (gfc_typespec *);\n int gfc_kind_max (gfc_expr *, gfc_expr *);\n \n-try gfc_check_conformance (const char *, gfc_expr *, gfc_expr *);\n-try gfc_check_assign (gfc_expr *, gfc_expr *, int);\n-try gfc_check_pointer_assign (gfc_expr *, gfc_expr *);\n-try gfc_check_assign_symbol (gfc_symbol *, gfc_expr *);\n+gfc_try gfc_check_conformance (const char *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_assign (gfc_expr *, gfc_expr *, int);\n+gfc_try gfc_check_pointer_assign (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_assign_symbol (gfc_symbol *, gfc_expr *);\n \n gfc_expr *gfc_default_initializer (gfc_typespec *);\n gfc_expr *gfc_get_variable_expr (gfc_symtree *);\n@@ -2339,16 +2337,16 @@ void gfc_free_statement (gfc_code *);\n void gfc_free_statements (gfc_code *);\n \n /* resolve.c */\n-try gfc_resolve_expr (gfc_expr *);\n+gfc_try gfc_resolve_expr (gfc_expr *);\n void gfc_resolve (gfc_namespace *);\n void gfc_resolve_blocks (gfc_code *, gfc_namespace *);\n int gfc_impure_variable (gfc_symbol *);\n int gfc_pure (gfc_symbol *);\n int gfc_elemental (gfc_symbol *);\n-try gfc_resolve_iterator (gfc_iterator *, bool);\n-try find_forall_index (gfc_expr *, gfc_symbol *, int);\n-try gfc_resolve_index (gfc_expr *, int);\n-try gfc_resolve_dim_arg (gfc_expr *);\n+gfc_try gfc_resolve_iterator (gfc_iterator *, bool);\n+gfc_try find_forall_index (gfc_expr *, gfc_symbol *, int);\n+gfc_try gfc_resolve_index (gfc_expr *, int);\n+gfc_try gfc_resolve_dim_arg (gfc_expr *);\n int gfc_is_formal_arg (void);\n void gfc_resolve_substring_charlen (gfc_expr *);\n match gfc_iso_c_sub_interface(gfc_code *, gfc_symbol *);\n@@ -2358,35 +2356,35 @@ match gfc_iso_c_sub_interface(gfc_code *, gfc_symbol *);\n void gfc_free_array_spec (gfc_array_spec *);\n gfc_array_ref *gfc_copy_array_ref (gfc_array_ref *);\n \n-try gfc_set_array_spec (gfc_symbol *, gfc_array_spec *, locus *);\n+gfc_try gfc_set_array_spec (gfc_symbol *, gfc_array_spec *, locus *);\n gfc_array_spec *gfc_copy_array_spec (gfc_array_spec *);\n-try gfc_resolve_array_spec (gfc_array_spec *, int);\n+gfc_try gfc_resolve_array_spec (gfc_array_spec *, int);\n \n int gfc_compare_array_spec (gfc_array_spec *, gfc_array_spec *);\n \n gfc_expr *gfc_start_constructor (bt, int, locus *);\n void gfc_append_constructor (gfc_expr *, gfc_expr *);\n void gfc_free_constructor (gfc_constructor *);\n void gfc_simplify_iterator_var (gfc_expr *);\n-try gfc_expand_constructor (gfc_expr *);\n+gfc_try gfc_expand_constructor (gfc_expr *);\n int gfc_constant_ac (gfc_expr *);\n int gfc_expanded_ac (gfc_expr *);\n-try gfc_resolve_character_array_constructor (gfc_expr *);\n-try gfc_resolve_array_constructor (gfc_expr *);\n-try gfc_check_constructor_type (gfc_expr *);\n-try gfc_check_iter_variable (gfc_expr *);\n-try gfc_check_constructor (gfc_expr *, try (*)(gfc_expr *));\n+gfc_try gfc_resolve_character_array_constructor (gfc_expr *);\n+gfc_try gfc_resolve_array_constructor (gfc_expr *);\n+gfc_try gfc_check_constructor_type (gfc_expr *);\n+gfc_try gfc_check_iter_variable (gfc_expr *);\n+gfc_try gfc_check_constructor (gfc_expr *, gfc_try (*)(gfc_expr *));\n gfc_constructor *gfc_copy_constructor (gfc_constructor *);\n gfc_expr *gfc_get_array_element (gfc_expr *, int);\n-try gfc_array_size (gfc_expr *, mpz_t *);\n-try gfc_array_dimen_size (gfc_expr *, int, mpz_t *);\n-try gfc_array_ref_shape (gfc_array_ref *, mpz_t *);\n+gfc_try gfc_array_size (gfc_expr *, mpz_t *);\n+gfc_try gfc_array_dimen_size (gfc_expr *, int, mpz_t *);\n+gfc_try gfc_array_ref_shape (gfc_array_ref *, mpz_t *);\n gfc_array_ref *gfc_find_array_ref (gfc_expr *);\n void gfc_insert_constructor (gfc_expr *, gfc_constructor *);\n gfc_constructor *gfc_get_constructor (void);\n tree gfc_conv_array_initializer (tree type, gfc_expr *);\n-try spec_size (gfc_array_spec *, mpz_t *);\n-try spec_dimen_size (gfc_array_spec *, int, mpz_t *);\n+gfc_try spec_size (gfc_array_spec *, mpz_t *);\n+gfc_try spec_dimen_size (gfc_array_spec *, int, mpz_t *);\n int gfc_is_compile_time_shape (gfc_array_spec *);\n \n /* interface.c -- FIXME: some of these should be in symbol.c */\n@@ -2397,28 +2395,28 @@ void gfc_check_interfaces (gfc_namespace *);\n void gfc_procedure_use (gfc_symbol *, gfc_actual_arglist **, locus *);\n gfc_symbol *gfc_search_interface (gfc_interface *, int,\n \t\t\t\t  gfc_actual_arglist **);\n-try gfc_extend_expr (gfc_expr *);\n+gfc_try gfc_extend_expr (gfc_expr *);\n void gfc_free_formal_arglist (gfc_formal_arglist *);\n-try gfc_extend_assign (gfc_code *, gfc_namespace *);\n-try gfc_add_interface (gfc_symbol *);\n+gfc_try gfc_extend_assign (gfc_code *, gfc_namespace *);\n+gfc_try gfc_add_interface (gfc_symbol *);\n gfc_interface *gfc_current_interface_head (void);\n void gfc_set_current_interface_head (gfc_interface *);\n \n /* io.c */\n extern gfc_st_label format_asterisk;\n \n void gfc_free_open (gfc_open *);\n-try gfc_resolve_open (gfc_open *);\n+gfc_try gfc_resolve_open (gfc_open *);\n void gfc_free_close (gfc_close *);\n-try gfc_resolve_close (gfc_close *);\n+gfc_try gfc_resolve_close (gfc_close *);\n void gfc_free_filepos (gfc_filepos *);\n-try gfc_resolve_filepos (gfc_filepos *);\n+gfc_try gfc_resolve_filepos (gfc_filepos *);\n void gfc_free_inquire (gfc_inquire *);\n-try gfc_resolve_inquire (gfc_inquire *);\n+gfc_try gfc_resolve_inquire (gfc_inquire *);\n void gfc_free_dt (gfc_dt *);\n-try gfc_resolve_dt (gfc_dt *);\n+gfc_try gfc_resolve_dt (gfc_dt *);\n void gfc_free_wait (gfc_wait *);\n-try gfc_resolve_wait (gfc_wait *);\n+gfc_try gfc_resolve_wait (gfc_wait *);\n \n /* module.c */\n void gfc_module_init_2 (void);\n@@ -2445,7 +2443,7 @@ void gfc_delete_bbt (void *, void *, compare_fn);\n void gfc_dump_parse_tree (gfc_namespace *, FILE *);\n \n /* parse.c */\n-try gfc_parse_file (void);\n+gfc_try gfc_parse_file (void);\n void gfc_global_used (gfc_gsymbol *, locus *);\n \n /* dependency.c */"}, {"sha": "84fa660dfafb27b6feaadd161cf0792de333694e", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -2218,7 +2218,7 @@ pair_cmp (const void *p1, const void *p2)\n    refer to the same expression. The analysis is conservative.\n    Returning FAILURE will produce no warning.  */\n \n-static try\n+static gfc_try\n compare_actual_expr (gfc_expr *e1, gfc_expr *e2)\n {\n   const gfc_ref *r1, *r2;\n@@ -2267,15 +2267,15 @@ compare_actual_expr (gfc_expr *e1, gfc_expr *e2)\n    another, check that identical actual arguments aren't not\n    associated with some incompatible INTENTs.  */\n \n-static try\n+static gfc_try\n check_some_aliasing (gfc_formal_arglist *f, gfc_actual_arglist *a)\n {\n   sym_intent f1_intent, f2_intent;\n   gfc_formal_arglist *f1;\n   gfc_actual_arglist *a1;\n   size_t n, i, j;\n   argpair *p;\n-  try t = SUCCESS;\n+  gfc_try t = SUCCESS;\n \n   n = 0;\n   for (f1 = f, a1 = a;; f1 = f1->next, a1 = a1->next)\n@@ -2355,7 +2355,7 @@ compare_parameter_intent (gfc_symbol *formal, gfc_expr *actual)\n    another, check that they are compatible in the sense that intents\n    are not mismatched.  */\n \n-static try\n+static gfc_try\n check_intents (gfc_formal_arglist *f, gfc_actual_arglist *a)\n {\n   sym_intent f_intent;\n@@ -2546,7 +2546,7 @@ find_sym_in_symtree (gfc_symbol *sym)\n    interface.  If one is found, the expression node is replaced with\n    the appropriate function call.  */\n \n-try\n+gfc_try\n gfc_extend_expr (gfc_expr *e)\n {\n   gfc_actual_arglist *actual;\n@@ -2677,7 +2677,7 @@ gfc_extend_expr (gfc_expr *e)\n    SUCCESS if the node was replaced.  On FAILURE, no error is\n    generated.  */\n \n-try\n+gfc_try\n gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n {\n   gfc_actual_arglist *actual;\n@@ -2731,7 +2731,7 @@ gfc_extend_assign (gfc_code *c, gfc_namespace *ns)\n    the given interface list.  Ambiguity isn't checked yet since module\n    procedures can be present without interfaces.  */\n \n-static try\n+static gfc_try\n check_new_interface (gfc_interface *base, gfc_symbol *new_sym)\n {\n   gfc_interface *ip;\n@@ -2752,7 +2752,7 @@ check_new_interface (gfc_interface *base, gfc_symbol *new_sym)\n \n /* Add a symbol to the current interface.  */\n \n-try\n+gfc_try\n gfc_add_interface (gfc_symbol *new_sym)\n {\n   gfc_interface **head, *intr;"}, {"sha": "9b11db4bb644cb8c597deef642cc6b3375550391", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -175,7 +175,7 @@ find_char_conv (gfc_typespec *from, gfc_typespec *to)\n    and call the proper check function rather than forcing each\n    function to manipulate the argument list.  */\n \n-static try\n+static gfc_try\n do_check (gfc_intrinsic_sym *specific, gfc_actual_arglist *arg)\n {\n   gfc_expr *a1, *a2, *a3, *a4, *a5;\n@@ -334,7 +334,7 @@ add_sym (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type\n static void\n add_sym_0 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t   int kind, int standard,\n-\t   try (*check) (void),\n+\t   gfc_try (*check) (void),\n \t   gfc_expr *(*simplify) (void),\n \t   void (*resolve) (gfc_expr *))\n {\n@@ -376,7 +376,7 @@ add_sym_0s (const char *name, gfc_isym_id id, int standard, void (*resolve) (gfc\n static void\n add_sym_1 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t   int kind, int standard,\n-\t   try (*check) (gfc_expr *),\n+\t   gfc_try (*check) (gfc_expr *),\n \t   gfc_expr *(*simplify) (gfc_expr *),\n \t   void (*resolve) (gfc_expr *, gfc_expr *),\n \t   const char *a1, bt type1, int kind1, int optional1)\n@@ -400,7 +400,7 @@ add_sym_1 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt ty\n \n static void\n add_sym_1s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind, int standard,\n-\t    try (*check) (gfc_expr *),\n+\t    gfc_try (*check) (gfc_expr *),\n \t    gfc_expr *(*simplify) (gfc_expr *),\n \t    void (*resolve) (gfc_code *),\n \t    const char *a1, bt type1, int kind1, int optional1)\n@@ -425,7 +425,7 @@ add_sym_1s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind,\n static void\n add_sym_1m (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t    int kind, int standard,\n-\t    try (*check) (gfc_actual_arglist *),\n+\t    gfc_try (*check) (gfc_actual_arglist *),\n \t    gfc_expr *(*simplify) (gfc_expr *),\n \t    void (*resolve) (gfc_expr *, gfc_actual_arglist *),\n \t    const char *a1, bt type1, int kind1, int optional1,\n@@ -452,7 +452,7 @@ add_sym_1m (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt t\n static void\n add_sym_2 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t   int kind, int standard,\n-\t   try (*check) (gfc_expr *, gfc_expr *),\n+\t   gfc_try (*check) (gfc_expr *, gfc_expr *),\n \t   gfc_expr *(*simplify) (gfc_expr *, gfc_expr *),\n \t   void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *),\n \t   const char *a1, bt type1, int kind1, int optional1,\n@@ -478,7 +478,7 @@ add_sym_2 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt ty\n \n static void\n add_sym_2s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind, int standard,\n-\t    try (*check) (gfc_expr *, gfc_expr *),\n+\t    gfc_try (*check) (gfc_expr *, gfc_expr *),\n \t    gfc_expr *(*simplify) (gfc_expr *, gfc_expr *),\n \t    void (*resolve) (gfc_code *),\n \t    const char *a1, bt type1, int kind1, int optional1,\n@@ -505,7 +505,7 @@ add_sym_2s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind,\n static void\n add_sym_3 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t   int kind, int standard,\n-\t   try (*check) (gfc_expr *, gfc_expr *, gfc_expr *),\n+\t   gfc_try (*check) (gfc_expr *, gfc_expr *, gfc_expr *),\n \t   gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *),\n \t   void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n \t   const char *a1, bt type1, int kind1, int optional1,\n@@ -534,7 +534,7 @@ add_sym_3 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt ty\n static void\n add_sym_3ml (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t     int kind, int standard,\n-\t     try (*check) (gfc_actual_arglist *),\n+\t     gfc_try (*check) (gfc_actual_arglist *),\n \t     gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *),\n \t     void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n \t     const char *a1, bt type1, int kind1, int optional1,\n@@ -563,7 +563,7 @@ add_sym_3ml (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt\n static void\n add_sym_3red (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t      int kind, int standard,\n-\t      try (*check) (gfc_actual_arglist *),\n+\t      gfc_try (*check) (gfc_actual_arglist *),\n \t      gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *),\n \t      void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n \t      const char *a1, bt type1, int kind1, int optional1,\n@@ -591,7 +591,7 @@ add_sym_3red (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt\n \n static void\n add_sym_3s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind, int standard,\n-\t    try (*check) (gfc_expr *, gfc_expr *, gfc_expr *),\n+\t    gfc_try (*check) (gfc_expr *, gfc_expr *, gfc_expr *),\n \t    gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *),\n \t    void (*resolve) (gfc_code *),\n \t    const char *a1, bt type1, int kind1, int optional1,\n@@ -620,7 +620,7 @@ add_sym_3s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind,\n static void\n add_sym_4 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt type,\n \t   int kind, int standard,\n-\t   try (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n+\t   gfc_try (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n \t   gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t\t\t  gfc_expr *),\n \t   void (*resolve) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n@@ -652,7 +652,7 @@ add_sym_4 (const char *name, gfc_isym_id id, enum klass cl, int actual_ok, bt ty\n \n static void\n add_sym_4s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind, int standard,\n-\t    try (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n+\t    gfc_try (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *),\n \t    gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t\t\t   gfc_expr *),\n \t    void (*resolve) (gfc_code *),\n@@ -683,7 +683,7 @@ add_sym_4s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind,\n \n static void\n add_sym_5s (const char *name, gfc_isym_id id, enum klass cl, bt type, int kind, int standard,\n-\t    try (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+\t    gfc_try (*check) (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t\t  gfc_expr *),\n \t    gfc_expr *(*simplify) (gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t\t\t   gfc_expr *, gfc_expr *),\n@@ -3024,7 +3024,7 @@ remove_nullargs (gfc_actual_arglist **ap)\n    wrong (say, a missing required argument) we abort sorting and\n    return FAILURE.  */\n \n-static try\n+static gfc_try\n sort_actual (const char *name, gfc_actual_arglist **ap,\n \t     gfc_intrinsic_arg *formal, locus *where)\n {\n@@ -3145,7 +3145,7 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n    list.  The lists are checked for agreement of type.  We don't check\n    for arrayness here.  */\n \n-static try\n+static gfc_try\n check_arglist (gfc_actual_arglist **ap, gfc_intrinsic_sym *sym,\n \t       int error_flag)\n {\n@@ -3277,7 +3277,7 @@ resolve_intrinsic (gfc_intrinsic_sym *specific, gfc_expr *e)\n    of the simplification, SUCCESS if the simplification worked, even\n    if nothing has changed in the expression itself.  */\n \n-static try\n+static gfc_try\n do_simplify (gfc_intrinsic_sym *specific, gfc_expr *e)\n {\n   gfc_expr *result, *a1, *a2, *a3, *a4, *a5;\n@@ -3406,11 +3406,11 @@ init_arglist (gfc_intrinsic_sym *isym)\n    intrinsic's formal argument list.  Return SUCCESS if the expression\n    and intrinsic match, FAILURE otherwise.  */\n \n-static try\n+static gfc_try\n check_specific (gfc_intrinsic_sym *specific, gfc_expr *expr, int error_flag)\n {\n   gfc_actual_arglist *arg, **ap;\n-  try t;\n+  gfc_try t;\n \n   ap = &expr->value.function.actual;\n \n@@ -3487,7 +3487,7 @@ check_specific (gfc_intrinsic_sym *specific, gfc_expr *expr, int error_flag)\n    can be used to construct a detailed warning/error message in case of\n    a FAILURE.  */\n \n-try\n+gfc_try\n gfc_check_intrinsic_standard (const gfc_intrinsic_sym* isym,\n \t\t\t      const char** symstd, bool silent, locus where)\n {\n@@ -3744,7 +3744,7 @@ gfc_intrinsic_sub_interface (gfc_code *c, int error_flag)\n \n /* Call gfc_convert_type() with warning enabled.  */\n \n-try\n+gfc_try\n gfc_convert_type (gfc_expr *expr, gfc_typespec *ts, int eflag)\n {\n   return gfc_convert_type_warn (expr, ts, eflag, 1);\n@@ -3761,7 +3761,7 @@ gfc_convert_type (gfc_expr *expr, gfc_typespec *ts, int eflag)\n \n    'wflag' controls the warning related to conversion.  */\n \n-try\n+gfc_try\n gfc_convert_type_warn (gfc_expr *expr, gfc_typespec *ts, int eflag, int wflag)\n {\n   gfc_intrinsic_sym *sym;\n@@ -3860,7 +3860,7 @@ gfc_convert_type_warn (gfc_expr *expr, gfc_typespec *ts, int eflag, int wflag)\n }\n \n \n-try\n+gfc_try\n gfc_convert_chartype (gfc_expr *expr, gfc_typespec *ts)\n {\n   gfc_intrinsic_sym *sym;"}, {"sha": "5994cf66a79f8cc9c3106280bb1a64b93fd623ac", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 158, "deletions": 158, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -26,169 +26,169 @@ extern gfc_expr gfc_bad_expr;\n \n \n /* Check functions.  */\n-try gfc_check_a_ikind (gfc_expr *, gfc_expr *);\n-try gfc_check_a_xkind (gfc_expr *, gfc_expr *);\n-try gfc_check_a_p (gfc_expr *, gfc_expr *);\n-try gfc_check_x_yd (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_a_ikind (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_a_xkind (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_a_p (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_x_yd (gfc_expr *, gfc_expr *);\n \n-try gfc_check_abs (gfc_expr *);\n-try gfc_check_access_func (gfc_expr *, gfc_expr *);\n-try gfc_check_achar (gfc_expr *, gfc_expr *);\n-try gfc_check_all_any (gfc_expr *, gfc_expr *);\n-try gfc_check_allocated (gfc_expr *);\n-try gfc_check_associated (gfc_expr *, gfc_expr *);\n-try gfc_check_atan2 (gfc_expr *, gfc_expr *);\n-try gfc_check_besn (gfc_expr *, gfc_expr *);\n-try gfc_check_btest (gfc_expr *, gfc_expr *);\n-try gfc_check_char (gfc_expr *, gfc_expr *);\n-try gfc_check_chdir (gfc_expr *);\n-try gfc_check_chmod (gfc_expr *, gfc_expr *);\n-try gfc_check_cmplx (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_complex (gfc_expr *, gfc_expr *);\n-try gfc_check_count (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_cshift (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_ctime (gfc_expr *);\n-try gfc_check_datan2 (gfc_expr *, gfc_expr *);\n-try gfc_check_dcmplx (gfc_expr *, gfc_expr *);\n-try gfc_check_dble (gfc_expr *);\n-try gfc_check_digits (gfc_expr *);\n-try gfc_check_dot_product (gfc_expr *, gfc_expr *);\n-try gfc_check_dprod (gfc_expr *, gfc_expr *);\n-try gfc_check_eoshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_dtime_etime (gfc_expr *);\n-try gfc_check_fgetputc (gfc_expr *, gfc_expr *);\n-try gfc_check_fgetput (gfc_expr *);\n-try gfc_check_fstat (gfc_expr *, gfc_expr *);\n-try gfc_check_ftell (gfc_expr *);\n-try gfc_check_fn_c (gfc_expr *);\n-try gfc_check_fn_d (gfc_expr *);\n-try gfc_check_fn_r (gfc_expr *);\n-try gfc_check_fn_rc (gfc_expr *);\n-try gfc_check_fnum (gfc_expr *);\n-try gfc_check_hostnm (gfc_expr *);\n-try gfc_check_huge (gfc_expr *);\n-try gfc_check_hypot (gfc_expr *, gfc_expr *);\n-try gfc_check_i (gfc_expr *);\n-try gfc_check_iand (gfc_expr *, gfc_expr *);\n-try gfc_check_and (gfc_expr *, gfc_expr *);\n-try gfc_check_ibclr (gfc_expr *, gfc_expr *);\n-try gfc_check_ibits (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_ibset (gfc_expr *, gfc_expr *);\n-try gfc_check_ichar_iachar (gfc_expr *, gfc_expr *);\n-try gfc_check_idnint (gfc_expr *);\n-try gfc_check_ieor (gfc_expr *, gfc_expr *);\n-try gfc_check_index (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_int (gfc_expr *, gfc_expr *);\n-try gfc_check_intconv (gfc_expr *);\n-try gfc_check_ior (gfc_expr *, gfc_expr *);\n-try gfc_check_irand (gfc_expr *);\n-try gfc_check_isatty (gfc_expr *);\n-try gfc_check_isnan (gfc_expr *);\n-try gfc_check_ishft (gfc_expr *, gfc_expr *);\n-try gfc_check_ishftc (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_kill (gfc_expr *, gfc_expr *);\n-try gfc_check_kind (gfc_expr *);\n-try gfc_check_lbound (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_len_lentrim (gfc_expr *, gfc_expr *);\n-try gfc_check_link (gfc_expr *, gfc_expr *);\n-try gfc_check_lge_lgt_lle_llt (gfc_expr *, gfc_expr *);\n-try gfc_check_loc (gfc_expr *);\n-try gfc_check_logical (gfc_expr *, gfc_expr *);\n-try gfc_check_min_max (gfc_actual_arglist *);\n-try gfc_check_min_max_integer (gfc_actual_arglist *);\n-try gfc_check_min_max_real (gfc_actual_arglist *);\n-try gfc_check_min_max_double (gfc_actual_arglist *);\n-try gfc_check_malloc (gfc_expr *);\n-try gfc_check_matmul (gfc_expr *, gfc_expr *);\n-try gfc_check_merge (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_minloc_maxloc (gfc_actual_arglist *);\n-try gfc_check_minval_maxval (gfc_actual_arglist *);\n-try gfc_check_nearest (gfc_expr *, gfc_expr *);\n-try gfc_check_new_line (gfc_expr *);\n-try gfc_check_null (gfc_expr *);\n-try gfc_check_pack (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_precision (gfc_expr *);\n-try gfc_check_present (gfc_expr *);\n-try gfc_check_product_sum (gfc_actual_arglist *);\n-try gfc_check_radix (gfc_expr *);\n-try gfc_check_rand (gfc_expr *);\n-try gfc_check_range (gfc_expr *);\n-try gfc_check_real (gfc_expr *, gfc_expr *);\n-try gfc_check_rename (gfc_expr *, gfc_expr *);\n-try gfc_check_repeat (gfc_expr *, gfc_expr *);\n-try gfc_check_reshape (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_scale (gfc_expr *, gfc_expr *);\n-try gfc_check_scan (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_second_sub (gfc_expr *);\n-try gfc_check_secnds (gfc_expr *);\n-try gfc_check_selected_char_kind (gfc_expr *);\n-try gfc_check_selected_int_kind (gfc_expr *);\n-try gfc_check_selected_real_kind (gfc_expr *, gfc_expr *);\n-try gfc_check_set_exponent (gfc_expr *, gfc_expr *);\n-try gfc_check_shape (gfc_expr *);\n-try gfc_check_size (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_sign (gfc_expr *, gfc_expr *);\n-try gfc_check_signal (gfc_expr *, gfc_expr *);\n-try gfc_check_sizeof (gfc_expr *);\n-try gfc_check_spread (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_srand (gfc_expr *);\n-try gfc_check_stat (gfc_expr *, gfc_expr *);\n-try gfc_check_sum (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_symlnk (gfc_expr *, gfc_expr *);\n-try gfc_check_transfer (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_transpose (gfc_expr *);\n-try gfc_check_trim (gfc_expr *);\n-try gfc_check_ttynam (gfc_expr *);\n-try gfc_check_ubound (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_umask (gfc_expr *);\n-try gfc_check_unlink (gfc_expr *);\n-try gfc_check_unpack (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_verify (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_x (gfc_expr *);\n+gfc_try gfc_check_abs (gfc_expr *);\n+gfc_try gfc_check_access_func (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_achar (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_all_any (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_allocated (gfc_expr *);\n+gfc_try gfc_check_associated (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_atan2 (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_besn (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_btest (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_char (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_chdir (gfc_expr *);\n+gfc_try gfc_check_chmod (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_cmplx (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_complex (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_count (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_cshift (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_ctime (gfc_expr *);\n+gfc_try gfc_check_datan2 (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_dcmplx (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_dble (gfc_expr *);\n+gfc_try gfc_check_digits (gfc_expr *);\n+gfc_try gfc_check_dot_product (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_dprod (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_eoshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_dtime_etime (gfc_expr *);\n+gfc_try gfc_check_fgetputc (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_fgetput (gfc_expr *);\n+gfc_try gfc_check_fstat (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_ftell (gfc_expr *);\n+gfc_try gfc_check_fn_c (gfc_expr *);\n+gfc_try gfc_check_fn_d (gfc_expr *);\n+gfc_try gfc_check_fn_r (gfc_expr *);\n+gfc_try gfc_check_fn_rc (gfc_expr *);\n+gfc_try gfc_check_fnum (gfc_expr *);\n+gfc_try gfc_check_hostnm (gfc_expr *);\n+gfc_try gfc_check_huge (gfc_expr *);\n+gfc_try gfc_check_hypot (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_i (gfc_expr *);\n+gfc_try gfc_check_iand (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_and (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_ibclr (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_ibits (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_ibset (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_ichar_iachar (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_idnint (gfc_expr *);\n+gfc_try gfc_check_ieor (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_index (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_int (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_intconv (gfc_expr *);\n+gfc_try gfc_check_ior (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_irand (gfc_expr *);\n+gfc_try gfc_check_isatty (gfc_expr *);\n+gfc_try gfc_check_isnan (gfc_expr *);\n+gfc_try gfc_check_ishft (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_ishftc (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_kill (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_kind (gfc_expr *);\n+gfc_try gfc_check_lbound (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_len_lentrim (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_link (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_lge_lgt_lle_llt (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_loc (gfc_expr *);\n+gfc_try gfc_check_logical (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_min_max (gfc_actual_arglist *);\n+gfc_try gfc_check_min_max_integer (gfc_actual_arglist *);\n+gfc_try gfc_check_min_max_real (gfc_actual_arglist *);\n+gfc_try gfc_check_min_max_double (gfc_actual_arglist *);\n+gfc_try gfc_check_malloc (gfc_expr *);\n+gfc_try gfc_check_matmul (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_merge (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_minloc_maxloc (gfc_actual_arglist *);\n+gfc_try gfc_check_minval_maxval (gfc_actual_arglist *);\n+gfc_try gfc_check_nearest (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_new_line (gfc_expr *);\n+gfc_try gfc_check_null (gfc_expr *);\n+gfc_try gfc_check_pack (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_precision (gfc_expr *);\n+gfc_try gfc_check_present (gfc_expr *);\n+gfc_try gfc_check_product_sum (gfc_actual_arglist *);\n+gfc_try gfc_check_radix (gfc_expr *);\n+gfc_try gfc_check_rand (gfc_expr *);\n+gfc_try gfc_check_range (gfc_expr *);\n+gfc_try gfc_check_real (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_rename (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_repeat (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_reshape (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_scale (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_scan (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_second_sub (gfc_expr *);\n+gfc_try gfc_check_secnds (gfc_expr *);\n+gfc_try gfc_check_selected_char_kind (gfc_expr *);\n+gfc_try gfc_check_selected_int_kind (gfc_expr *);\n+gfc_try gfc_check_selected_real_kind (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_set_exponent (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_shape (gfc_expr *);\n+gfc_try gfc_check_size (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_sign (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_signal (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_sizeof (gfc_expr *);\n+gfc_try gfc_check_spread (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_srand (gfc_expr *);\n+gfc_try gfc_check_stat (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_sum (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_symlnk (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_transfer (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_transpose (gfc_expr *);\n+gfc_try gfc_check_trim (gfc_expr *);\n+gfc_try gfc_check_ttynam (gfc_expr *);\n+gfc_try gfc_check_ubound (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_umask (gfc_expr *);\n+gfc_try gfc_check_unlink (gfc_expr *);\n+gfc_try gfc_check_unpack (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_verify (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_x (gfc_expr *);\n \n \n /* Intrinsic subroutines.  */\n-try gfc_check_alarm_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_chdir_sub (gfc_expr *, gfc_expr *);\n-try gfc_check_chmod_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_cpu_time (gfc_expr *);\n-try gfc_check_ctime_sub (gfc_expr *, gfc_expr *);\n-try gfc_check_system_clock (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_date_and_time (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_exit (gfc_expr *);\n-try gfc_check_fdate_sub (gfc_expr *);\n-try gfc_check_flush (gfc_expr *);\n-try gfc_check_free (gfc_expr *);\n-try gfc_check_fstat_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_gerror (gfc_expr *);\n-try gfc_check_getarg (gfc_expr *, gfc_expr *);\n-try gfc_check_getlog (gfc_expr *);\n-try gfc_check_move_alloc (gfc_expr *, gfc_expr *);\n-try gfc_check_mvbits (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+gfc_try gfc_check_alarm_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_chdir_sub (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_chmod_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_cpu_time (gfc_expr *);\n+gfc_try gfc_check_ctime_sub (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_system_clock (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_date_and_time (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_exit (gfc_expr *);\n+gfc_try gfc_check_fdate_sub (gfc_expr *);\n+gfc_try gfc_check_flush (gfc_expr *);\n+gfc_try gfc_check_free (gfc_expr *);\n+gfc_try gfc_check_fstat_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_gerror (gfc_expr *);\n+gfc_try gfc_check_getarg (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_getlog (gfc_expr *);\n+gfc_try gfc_check_move_alloc (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_mvbits (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t      gfc_expr *);\n-try gfc_check_random_number (gfc_expr *);\n-try gfc_check_random_seed (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_dtime_etime_sub (gfc_expr *, gfc_expr *);\n-try gfc_check_fgetputc_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_fgetput_sub (gfc_expr *, gfc_expr *);\n-try gfc_check_fseek_sub (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_ftell_sub (gfc_expr *, gfc_expr *);\n-try gfc_check_getcwd_sub (gfc_expr *, gfc_expr *);\n-try gfc_check_hostnm_sub (gfc_expr *, gfc_expr *);\n-try gfc_check_itime_idate (gfc_expr *);\n-try gfc_check_kill_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_ltime_gmtime (gfc_expr *, gfc_expr *);\n-try gfc_check_perror (gfc_expr *);\n-try gfc_check_rename_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_link_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_symlnk_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_signal_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_sleep_sub (gfc_expr *);\n-try gfc_check_stat_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_system_sub (gfc_expr *, gfc_expr *);\n-try gfc_check_ttynam_sub (gfc_expr *, gfc_expr *);\n-try gfc_check_umask_sub (gfc_expr *, gfc_expr *);\n-try gfc_check_unlink_sub (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_random_number (gfc_expr *);\n+gfc_try gfc_check_random_seed (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_dtime_etime_sub (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_fgetputc_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_fgetput_sub (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_fseek_sub (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_ftell_sub (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_getcwd_sub (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_hostnm_sub (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_itime_idate (gfc_expr *);\n+gfc_try gfc_check_kill_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_ltime_gmtime (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_perror (gfc_expr *);\n+gfc_try gfc_check_rename_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_link_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_symlnk_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_signal_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_sleep_sub (gfc_expr *);\n+gfc_try gfc_check_stat_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_system_sub (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_ttynam_sub (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_umask_sub (gfc_expr *, gfc_expr *);\n+gfc_try gfc_check_unlink_sub (gfc_expr *, gfc_expr *);\n \n \n /* Simplification functions.  */"}, {"sha": "58326b707f5104234ea34baffd058381212c55dd", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -474,7 +474,7 @@ format_lex (void)\n    by itself, and we are checking it for validity.  The dual origin\n    means that the warning message is a little less than great.  */\n \n-static try\n+static gfc_try\n check_format (bool is_input)\n {\n   const char *posint_required\t  = _(\"Positive width required\");\n@@ -489,7 +489,7 @@ check_format (bool is_input)\n   format_token t, u;\n   int level;\n   int repeat;\n-  try rv;\n+  gfc_try rv;\n \n   use_last_char = 0;\n   saved_token = FMT_NONE;\n@@ -981,7 +981,7 @@ check_format (bool is_input)\n /* Given an expression node that is a constant string, see if it looks\n    like a format string.  */\n \n-static try\n+static gfc_try\n check_format_string (gfc_expr *e, bool is_input)\n {\n   if (!e || e->ts.type != BT_CHARACTER || e->expr_type != EXPR_CONSTANT)\n@@ -1191,7 +1191,7 @@ match_ltag (const io_tag *tag, gfc_st_label ** label)\n \n /* Resolution of the FORMAT tag, to be called from resolve_tag.  */\n \n-static try\n+static gfc_try\n resolve_tag_format (const gfc_expr *e)\n {\n   if (e->expr_type == EXPR_CONSTANT\n@@ -1260,7 +1260,7 @@ resolve_tag_format (const gfc_expr *e)\n \n /* Do expression resolution and type-checking on an expression tag.  */\n \n-static try\n+static gfc_try\n resolve_tag (const io_tag *tag, gfc_expr *e)\n {\n   if (e == NULL)\n@@ -1417,7 +1417,7 @@ gfc_free_open (gfc_open *open)\n \n /* Resolve everything in a gfc_open structure.  */\n \n-try\n+gfc_try\n gfc_resolve_open (gfc_open *open)\n {\n \n@@ -2017,7 +2017,7 @@ gfc_match_close (void)\n \n /* Resolve everything in a gfc_close structure.  */\n \n-try\n+gfc_try\n gfc_resolve_close (gfc_close *close)\n {\n   RESOLVE_TAG (&tag_unit, close->unit);\n@@ -2141,7 +2141,7 @@ match_filepos (gfc_statement st, gfc_exec_op op)\n }\n \n \n-try\n+gfc_try\n gfc_resolve_filepos (gfc_filepos *fp)\n {\n   RESOLVE_TAG (&tag_unit, fp->unit);\n@@ -2467,7 +2467,7 @@ gfc_free_dt (gfc_dt *dt)\n \n /* Resolve everything in a gfc_dt structure.  */\n \n-try\n+gfc_try\n gfc_resolve_dt (gfc_dt *dt)\n {\n   gfc_expr *e;\n@@ -3705,7 +3705,7 @@ gfc_match_inquire (void)\n \n /* Resolve everything in a gfc_inquire structure.  */\n \n-try\n+gfc_try\n gfc_resolve_inquire (gfc_inquire *inquire)\n {\n   RESOLVE_TAG (&tag_unit, inquire->unit);\n@@ -3764,7 +3764,7 @@ gfc_free_wait (gfc_wait *wait)\n }\n \n \n-try\n+gfc_try\n gfc_resolve_wait (gfc_wait *wait)\n {\n   RESOLVE_TAG (&tag_unit, wait->unit);"}, {"sha": "cc51072dff4c55f8f4d9934521856da8cf6e0fb7", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -175,10 +175,10 @@ match gfc_match_volatile (void);\n /* Fortran 2003 c interop.\n    TODO: some of these should be moved to another file rather than decl.c */\n void set_com_block_bind_c (gfc_common_head *, int);\n-try set_binding_label (char *, const char *, int);\n-try set_verify_bind_c_sym (gfc_symbol *, int);\n-try set_verify_bind_c_com_block (gfc_common_head *, int);\n-try get_bind_c_idents (void);\n+gfc_try set_binding_label (char *, const char *, int);\n+gfc_try set_verify_bind_c_sym (gfc_symbol *, int);\n+gfc_try set_verify_bind_c_com_block (gfc_common_head *, int);\n+gfc_try get_bind_c_idents (void);\n match gfc_match_bind_c_stmt (void);\n match gfc_match_suffix (gfc_symbol *, gfc_symbol **);\n match gfc_match_bind_c (gfc_symbol *, bool);"}, {"sha": "965e733ea7805805dce7cc6ed2797ac6d6eac03e", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -923,7 +923,7 @@ pop_state (void)\n \n /* Try to find the given state in the state stack.  */\n \n-try\n+gfc_try\n gfc_find_state (gfc_compile_state state)\n {\n   gfc_state_data *p;\n@@ -1575,7 +1575,7 @@ typedef struct\n }\n st_state;\n \n-static try\n+static gfc_try\n verify_st_order (st_state *p, gfc_statement st)\n {\n \n@@ -3563,7 +3563,7 @@ add_global_program (void)\n \n /* Top level parser.  */\n \n-try\n+gfc_try\n gfc_parse_file (void)\n {\n   int seen_program, errors_before, errors;"}, {"sha": "1ac3e948e9add686d049927c5ecf00808c8cb994", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -61,7 +61,7 @@ extern gfc_state_data *gfc_state_stack;\n #define gfc_current_state() (gfc_state_stack->state)\n \n int gfc_check_do_variable (gfc_symtree *);\n-try gfc_find_state (gfc_compile_state);\n+gfc_try gfc_find_state (gfc_compile_state);\n gfc_state_data *gfc_enclosing_unit (gfc_compile_state *);\n const char *gfc_ascii_statement (gfc_statement);\n match gfc_match_enum (void);"}, {"sha": "f977de56ce2bd0d5c1d42836523b953c7753aa0b", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -298,7 +298,7 @@ resolve_formal_arglists (gfc_namespace *ns)\n static void\n resolve_contained_fntype (gfc_symbol *sym, gfc_namespace *ns)\n {\n-  try t;\n+  gfc_try t;\n \n   /* If this namespace is not a function or an entry master function,\n      ignore it.  */\n@@ -767,12 +767,12 @@ resolve_contained_functions (gfc_namespace *ns)\n /* Resolve all of the elements of a structure constructor and make sure that\n    the types are correct.  */\n \n-static try\n+static gfc_try\n resolve_structure_cons (gfc_expr *expr)\n {\n   gfc_constructor *cons;\n   gfc_component *comp;\n-  try t;\n+  gfc_try t;\n   symbol_attribute a;\n \n   t = SUCCESS;\n@@ -1017,7 +1017,7 @@ resolve_assumed_size_actual (gfc_expr *e)\n    that look like procedure arguments are really simple variable\n    references.  */\n \n-static try\n+static gfc_try\n resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n {\n   gfc_symbol *sym;\n@@ -1261,7 +1261,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n    procedures.  If called with c == NULL, we have a function, otherwise if\n    expr == NULL, we have a subroutine.  */\n \n-static try\n+static gfc_try\n resolve_elemental_actual (gfc_expr *expr, gfc_code *c)\n {\n   gfc_actual_arglist *arg0;\n@@ -1506,7 +1506,7 @@ resolve_generic_f0 (gfc_expr *expr, gfc_symbol *sym)\n }\n \n \n-static try\n+static gfc_try\n resolve_generic_f (gfc_expr *expr)\n {\n   gfc_symbol *sym;\n@@ -1622,7 +1622,7 @@ resolve_specific_f0 (gfc_symbol *sym, gfc_expr *expr)\n }\n \n \n-static try\n+static gfc_try\n resolve_specific_f (gfc_expr *expr)\n {\n   gfc_symbol *sym;\n@@ -1656,7 +1656,7 @@ resolve_specific_f (gfc_expr *expr)\n \n /* Resolve a procedure call not known to be generic nor specific.  */\n \n-static try\n+static gfc_try\n resolve_unknown_f (gfc_expr *expr)\n {\n   gfc_symbol *sym;\n@@ -1796,10 +1796,10 @@ pure_stmt_function (gfc_expr *e, gfc_symbol *sym)\n }\n \n \n-static try\n+static gfc_try\n is_scalar_expr_ptr (gfc_expr *expr)\n {\n-  try retval = SUCCESS;\n+  gfc_try retval = SUCCESS;\n   gfc_ref *ref;\n   int start;\n   int end;\n@@ -1897,14 +1897,14 @@ is_scalar_expr_ptr (gfc_expr *expr)\n    and, in the case of c_associated, set the binding label based on\n    the arguments.  */\n \n-static try\n+static gfc_try\n gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n                           gfc_symbol **new_sym)\n {\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   char binding_label[GFC_MAX_BINDING_LABEL_LEN + 1];\n   int optional_arg = 0;\n-  try retval = SUCCESS;\n+  gfc_try retval = SUCCESS;\n   gfc_symbol *args_sym;\n   gfc_typespec *arg_ts;\n   gfc_ref *parent_ref;\n@@ -2161,13 +2161,13 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n /* TODO: Check procedure arguments so that an INTENT(IN) isn't passed\n    to INTENT(OUT) or INTENT(INOUT).  */\n \n-static try\n+static gfc_try\n resolve_function (gfc_expr *expr)\n {\n   gfc_actual_arglist *arg;\n   gfc_symbol *sym;\n   const char *name;\n-  try t;\n+  gfc_try t;\n   int temp;\n   procedure_type p = PROC_INTRINSIC;\n \n@@ -2438,7 +2438,7 @@ resolve_generic_s0 (gfc_code *c, gfc_symbol *sym)\n }\n \n \n-static try\n+static gfc_try\n resolve_generic_s (gfc_code *c)\n {\n   gfc_symbol *sym;\n@@ -2698,7 +2698,7 @@ resolve_specific_s0 (gfc_code *c, gfc_symbol *sym)\n }\n \n \n-static try\n+static gfc_try\n resolve_specific_s (gfc_code *c)\n {\n   gfc_symbol *sym;\n@@ -2733,7 +2733,7 @@ resolve_specific_s (gfc_code *c)\n \n /* Resolve a subroutine call not known to be generic nor specific.  */\n \n-static try\n+static gfc_try\n resolve_unknown_s (gfc_code *c)\n {\n   gfc_symbol *sym;\n@@ -2772,10 +2772,10 @@ resolve_unknown_s (gfc_code *c)\n    for functions, subroutines and functions are stored differently and this\n    makes things awkward.  */\n \n-static try\n+static gfc_try\n resolve_call (gfc_code *c)\n {\n-  try t;\n+  gfc_try t;\n   procedure_type ptype = PROC_INTRINSIC;\n \n   if (c->symtree && c->symtree->n.sym\n@@ -2864,10 +2864,10 @@ resolve_call (gfc_code *c)\n    if their shapes do not match.  If either op1->shape or op2->shape is\n    NULL, return SUCCESS.  */\n \n-static try\n+static gfc_try\n compare_shapes (gfc_expr *op1, gfc_expr *op2)\n {\n-  try t;\n+  gfc_try t;\n   int i;\n \n   t = SUCCESS;\n@@ -2893,13 +2893,13 @@ compare_shapes (gfc_expr *op1, gfc_expr *op2)\n /* Resolve an operator expression node.  This can involve replacing the\n    operation with a user defined function call.  */\n \n-static try\n+static gfc_try\n resolve_operator (gfc_expr *e)\n {\n   gfc_expr *op1, *op2;\n   char msg[200];\n   bool dual_locus_error;\n-  try t;\n+  gfc_try t;\n \n   /* Resolve all subnodes-- give them types.  */\n \n@@ -3338,7 +3338,7 @@ compute_last_value_for_triplet (gfc_expr *start, gfc_expr *end,\n /* Compare a single dimension of an array reference to the array\n    specification.  */\n \n-static try\n+static gfc_try\n check_dimension (int i, gfc_array_ref *ar, gfc_array_spec *as)\n {\n   mpz_t last_value;\n@@ -3456,7 +3456,7 @@ check_dimension (int i, gfc_array_ref *ar, gfc_array_spec *as)\n \n /* Compare an array reference with an array specification.  */\n \n-static try\n+static gfc_try\n compare_spec_to_ref (gfc_array_ref *ar)\n {\n   gfc_array_spec *as;\n@@ -3495,7 +3495,7 @@ compare_spec_to_ref (gfc_array_ref *ar)\n \n /* Resolve one part of an array index.  */\n \n-try\n+gfc_try\n gfc_resolve_index (gfc_expr *index, int check_scalar)\n {\n   gfc_typespec ts;\n@@ -3539,7 +3539,7 @@ gfc_resolve_index (gfc_expr *index, int check_scalar)\n \n /* Resolve a dim argument to an intrinsic function.  */\n \n-try\n+gfc_try\n gfc_resolve_dim_arg (gfc_expr *dim)\n {\n   if (dim == NULL)\n@@ -3644,7 +3644,7 @@ find_array_spec (gfc_expr *e)\n \n /* Resolve an array reference.  */\n \n-static try\n+static gfc_try\n resolve_array_ref (gfc_array_ref *ar)\n {\n   int i, check_scalar;\n@@ -3705,7 +3705,7 @@ resolve_array_ref (gfc_array_ref *ar)\n }\n \n \n-static try\n+static gfc_try\n resolve_substring (gfc_ref *ref)\n {\n   if (ref->u.ss.start != NULL)\n@@ -3837,7 +3837,7 @@ gfc_resolve_substring_charlen (gfc_expr *e)\n \n /* Resolve subtype references.  */\n \n-static try\n+static gfc_try\n resolve_ref (gfc_expr *expr)\n {\n   int current_part_dimension, n_components, seen_part_dimension;\n@@ -4035,11 +4035,11 @@ expression_rank (gfc_expr *e)\n \n /* Resolve a variable expression.  */\n \n-static try\n+static gfc_try\n resolve_variable (gfc_expr *e)\n {\n   gfc_symbol *sym;\n-  try t;\n+  gfc_try t;\n \n   t = SUCCESS;\n \n@@ -4285,10 +4285,10 @@ fixup_charlen (gfc_expr *e)\n    with their operators, intrinsic operators are converted to function calls\n    for overloaded types and unresolved function references are resolved.  */\n \n-try\n+gfc_try\n gfc_resolve_expr (gfc_expr *e)\n {\n-  try t;\n+  gfc_try t;\n \n   if (e == NULL)\n     return SUCCESS;\n@@ -4373,7 +4373,7 @@ gfc_resolve_expr (gfc_expr *e)\n /* Resolve an expression from an iterator.  They must be scalar and have\n    INTEGER or (optionally) REAL type.  */\n \n-static try\n+static gfc_try\n gfc_resolve_iterator_expr (gfc_expr *expr, bool real_ok,\n \t\t\t   const char *name_msgid)\n {\n@@ -4414,7 +4414,7 @@ gfc_resolve_iterator_expr (gfc_expr *expr, bool real_ok,\n /* Resolve the expressions in an iterator structure.  If REAL_OK is\n    false allow only INTEGER type iterators, otherwise allow REAL types.  */\n \n-try\n+gfc_try\n gfc_resolve_iterator (gfc_iterator *iter, bool real_ok)\n {\n   if (gfc_resolve_iterator_expr (iter->var, real_ok, \"Loop variable\")\n@@ -4497,7 +4497,7 @@ forall_index (gfc_expr *expr, gfc_symbol *sym, int *f)\n /* Check whether the FORALL index appears in the expression or not.\n    Returns SUCCESS if SYM is found in EXPR.  */\n \n-try\n+gfc_try\n find_forall_index (gfc_expr *expr, gfc_symbol *sym, int f)\n {\n   if (gfc_traverse_expr (expr, sym, forall_index, f))\n@@ -4597,7 +4597,7 @@ derived_inaccessible (gfc_symbol *sym)\n /* Resolve the argument of a deallocate expression.  The expression must be\n    a pointer or a full array.  */\n \n-static try\n+static gfc_try\n resolve_deallocate_expr (gfc_expr *e)\n {\n   symbol_attribute attr;\n@@ -4712,7 +4712,7 @@ expr_to_initialize (gfc_expr *e)\n    checks to see whether the expression is OK or not.  The expression must\n    have a trailing array reference that gives the size of the array.  */\n \n-static try\n+static gfc_try\n resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n {\n   int i, pointer, allocatable, dimension, check_intent_in;\n@@ -5112,7 +5112,7 @@ check_case_overlap (gfc_case *list)\n    Makes sure that all case expressions are scalar constants of the same\n    type.  Return FAILURE if anything is wrong.  */\n \n-static try\n+static gfc_try\n validate_case_label_expr (gfc_expr *e, gfc_expr *case_expr)\n {\n   if (e == NULL) return SUCCESS;\n@@ -5181,7 +5181,7 @@ resolve_select (gfc_code *code)\n   int seen_logical;\n   int ncases;\n   bt type;\n-  try t;\n+  gfc_try t;\n \n   if (code->expr == NULL)\n     {\n@@ -5622,12 +5622,12 @@ resolve_branch (gfc_st_label *label, gfc_code *code)\n \n /* Check whether EXPR1 has the same shape as EXPR2.  */\n \n-static try\n+static gfc_try\n resolve_where_shape (gfc_expr *expr1, gfc_expr *expr2)\n {\n   mpz_t shape[GFC_MAX_DIMENSIONS];\n   mpz_t shape2[GFC_MAX_DIMENSIONS];\n-  try result = FAILURE;\n+  gfc_try result = FAILURE;\n   int i;\n \n   /* Compare the rank.  */\n@@ -5934,7 +5934,7 @@ static void resolve_code (gfc_code *, gfc_namespace *);\n void\n gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n {\n-  try t;\n+  gfc_try t;\n \n   for (; b; b = b->block)\n     {\n@@ -6148,7 +6148,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n   int omp_workshare_save;\n   int forall_save;\n   code_stack frame;\n-  try t;\n+  gfc_try t;\n \n   frame.prev = cs_base;\n   frame.head = code;\n@@ -6666,7 +6666,7 @@ gfc_verify_binding_labels (gfc_symbol *sym)\n \n /* Resolve an index expression.  */\n \n-static try\n+static gfc_try\n resolve_index_expr (gfc_expr *e)\n {\n   if (gfc_resolve_expr (e) == FAILURE)\n@@ -6683,7 +6683,7 @@ resolve_index_expr (gfc_expr *e)\n \n /* Resolve a charlen structure.  */\n \n-static try\n+static gfc_try\n resolve_charlen (gfc_charlen *cl)\n {\n   int i;\n@@ -6983,7 +6983,7 @@ apply_default_init_local (gfc_symbol *sym)\n \n /* Resolution of common features of flavors variable and procedure.  */\n \n-static try\n+static gfc_try\n resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n {\n   /* Constraints on deferred shape variable.  */\n@@ -7025,7 +7025,7 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n /* Additional checks for symbols with flavor variable and derived\n    type.  To be called from resolve_fl_variable.  */\n \n-static try\n+static gfc_try\n resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)\n {\n   gcc_assert (sym->ts.type == BT_DERIVED);\n@@ -7084,7 +7084,7 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)\n \n /* Resolve symbols with flavor variable.  */\n \n-static try\n+static gfc_try\n resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n {\n   int no_init_flag, automatic_flag;\n@@ -7209,7 +7209,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n \n /* Resolve a procedure.  */\n \n-static try\n+static gfc_try\n resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n {\n   gfc_formal_arglist *arg;\n@@ -7451,12 +7451,12 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n    been defined and we now know their defined arguments, check that they fulfill\n    the requirements of the standard for procedures used as finalizers.  */\n \n-static try\n+static gfc_try\n gfc_resolve_finalizers (gfc_symbol* derived)\n {\n   gfc_finalizer* list;\n   gfc_finalizer** prev_link; /* For removing wrong entries from the list.  */\n-  try result = SUCCESS;\n+  gfc_try result = SUCCESS;\n   bool seen_scalar = false;\n \n   if (!derived->f2k_derived || !derived->f2k_derived->finalizers)\n@@ -7610,7 +7610,7 @@ add_dt_to_dt_list (gfc_symbol *derived)\n \n /* Resolve the components of a derived type.  */\n \n-static try\n+static gfc_try\n resolve_fl_derived (gfc_symbol *sym)\n {\n   gfc_component *c;\n@@ -7707,7 +7707,7 @@ resolve_fl_derived (gfc_symbol *sym)\n }\n \n \n-static try\n+static gfc_try\n resolve_fl_namelist (gfc_symbol *sym)\n {\n   gfc_namelist *nl;\n@@ -7826,7 +7826,7 @@ resolve_fl_namelist (gfc_symbol *sym)\n }\n \n \n-static try\n+static gfc_try\n resolve_fl_parameter (gfc_symbol *sym)\n {\n   /* A parameter array's shape needs to be constant.  */\n@@ -8098,7 +8098,7 @@ resolve_symbol (gfc_symbol *sym)\n       sym->attr.use_assoc == 0 && sym->attr.dummy == 0 &&\n       sym->attr.flavor != FL_PROCEDURE && sym->attr.flavor != FL_DERIVED)\n     {\n-      try t = SUCCESS;\n+      gfc_try t = SUCCESS;\n       \n       /* First, make sure the variable is declared at the\n \t module-level scope (J3/04-007, Section 15.3).\t*/\n@@ -8311,7 +8311,7 @@ values;\n \n /* Advance the values structure to point to the next value in the data list.  */\n \n-static try\n+static gfc_try\n next_data_value (void)\n {\n \n@@ -8328,13 +8328,13 @@ next_data_value (void)\n }\n \n \n-static try\n+static gfc_try\n check_data_variable (gfc_data_variable *var, locus *where)\n {\n   gfc_expr *e;\n   mpz_t size;\n   mpz_t offset;\n-  try t;\n+  gfc_try t;\n   ar_type mark = AR_UNKNOWN;\n   int i;\n   mpz_t section_index[GFC_MAX_DIMENSIONS];\n@@ -8491,17 +8491,17 @@ check_data_variable (gfc_data_variable *var, locus *where)\n }\n \n \n-static try traverse_data_var (gfc_data_variable *, locus *);\n+static gfc_try traverse_data_var (gfc_data_variable *, locus *);\n \n /* Iterate over a list of elements in a DATA statement.  */\n \n-static try\n+static gfc_try\n traverse_data_list (gfc_data_variable *var, locus *where)\n {\n   mpz_t trip;\n   iterator_stack frame;\n   gfc_expr *e, *start, *end, *step;\n-  try retval = SUCCESS;\n+  gfc_try retval = SUCCESS;\n \n   mpz_init (frame.value);\n \n@@ -8581,10 +8581,10 @@ traverse_data_list (gfc_data_variable *var, locus *where)\n \n /* Type resolve variables in the variable list of a DATA statement.  */\n \n-static try\n+static gfc_try\n traverse_data_var (gfc_data_variable *var, locus *where)\n {\n-  try t;\n+  gfc_try t;\n \n   for (; var; var = var->next)\n     {\n@@ -8605,7 +8605,7 @@ traverse_data_var (gfc_data_variable *var, locus *where)\n    This is separate from the assignment checking because data lists should\n    only be resolved once.  */\n \n-static try\n+static gfc_try\n resolve_data_variables (gfc_data_variable *d)\n {\n   for (; d; d = d->next)\n@@ -8821,7 +8821,7 @@ sequence_type (gfc_typespec ts)\n \n /* Resolve derived type EQUIVALENCE object.  */\n \n-static try\n+static gfc_try\n resolve_equivalence_derived (gfc_symbol *derived, gfc_symbol *sym, gfc_expr *e)\n {\n   gfc_symbol *d;"}, {"sha": "8c702ca3f3382a8a659181f5f6b6b779e11ddd70", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -1672,7 +1672,7 @@ preprocessor_line (gfc_char_t *c)\n }\n \n \n-static try load_file (const char *, const char *, bool);\n+static gfc_try load_file (const char *, const char *, bool);\n \n /* include_line()-- Checks a line buffer to see if it is an include\n    line.  If so, we call load_file() recursively to load the included\n@@ -1751,7 +1751,7 @@ include_line (gfc_char_t *line)\n \n /* Load a file into memory by calling load_line until the file ends.  */\n \n-static try\n+static gfc_try\n load_file (const char *realfilename, const char *displayedname, bool initial)\n {\n   gfc_char_t *line;\n@@ -1921,10 +1921,10 @@ load_file (const char *realfilename, const char *displayedname, bool initial)\n    it tries to determine the source form from the filename, defaulting\n    to free form.  */\n \n-try\n+gfc_try\n gfc_new_file (void)\n {\n-  try result;\n+  gfc_try result;\n \n   if (gfc_cpp_enabled ())\n     {"}, {"sha": "1690003dbac50706b82dbfd9fe64fc414beb84c2", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -3942,7 +3942,7 @@ gfc_simplify_shape (gfc_expr *source)\n   gfc_expr *result, *e, *f;\n   gfc_array_ref *ar;\n   int n;\n-  try t;\n+  gfc_try t;\n \n   if (source->rank == 0)\n     return gfc_start_constructor (BT_INTEGER, gfc_default_integer_kind,"}, {"sha": "58c54f4d42bc7bb4d4a9d6816cd7e6e7dbe5ab7a", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -145,7 +145,7 @@ gfc_clear_new_implicit (void)\n \n /* Prepare for a new implicit range.  Sets flags in new_flag[].  */\n \n-try\n+gfc_try\n gfc_add_new_implicit_range (int c1, int c2)\n {\n   int i;\n@@ -172,7 +172,7 @@ gfc_add_new_implicit_range (int c1, int c2)\n /* Add a matched implicit range for gfc_set_implicit().  Check if merging\n    the new implicit types back into the existing types will work.  */\n \n-try\n+gfc_try\n gfc_merge_new_implicit (gfc_typespec *ts)\n {\n   int i;\n@@ -230,7 +230,7 @@ gfc_get_default_type (gfc_symbol *sym, gfc_namespace *ns)\n    letter of its name.  Fails if the letter in question has no default\n    type.  */\n \n-try\n+gfc_try\n gfc_set_default_type (gfc_symbol *sym, int error_flag, gfc_namespace *ns)\n {\n   gfc_typespec *ts;\n@@ -336,7 +336,7 @@ gfc_check_function_type (gfc_namespace *ns)\n                                 goto conflict_std;\\\n                               }\n \n-static try\n+static gfc_try\n check_conflict (symbol_attribute *attr, const char *name, locus *where)\n {\n   static const char *dummy = \"DUMMY\", *save = \"SAVE\", *pointer = \"POINTER\",\n@@ -790,7 +790,7 @@ duplicate_attr (const char *attr, locus *where)\n /* Called from decl.c (attr_decl1) to check attributes, when declared\n    separately.  */\n \n-try\n+gfc_try\n gfc_add_attribute (symbol_attribute *attr, locus *where)\n {\n \n@@ -800,7 +800,7 @@ gfc_add_attribute (symbol_attribute *attr, locus *where)\n   return check_conflict (attr, NULL, where);\n }\n \n-try\n+gfc_try\n gfc_add_allocatable (symbol_attribute *attr, locus *where)\n {\n \n@@ -826,7 +826,7 @@ gfc_add_allocatable (symbol_attribute *attr, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_dimension (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -852,7 +852,7 @@ gfc_add_dimension (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_external (symbol_attribute *attr, locus *where)\n {\n \n@@ -877,7 +877,7 @@ gfc_add_external (symbol_attribute *attr, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_intrinsic (symbol_attribute *attr, locus *where)\n {\n \n@@ -896,7 +896,7 @@ gfc_add_intrinsic (symbol_attribute *attr, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_optional (symbol_attribute *attr, locus *where)\n {\n \n@@ -914,7 +914,7 @@ gfc_add_optional (symbol_attribute *attr, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_pointer (symbol_attribute *attr, locus *where)\n {\n \n@@ -939,7 +939,7 @@ gfc_add_pointer (symbol_attribute *attr, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_cray_pointer (symbol_attribute *attr, locus *where)\n {\n \n@@ -951,7 +951,7 @@ gfc_add_cray_pointer (symbol_attribute *attr, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_cray_pointee (symbol_attribute *attr, locus *where)\n {\n \n@@ -970,7 +970,7 @@ gfc_add_cray_pointee (symbol_attribute *attr, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_protected (symbol_attribute *attr, const char *name, locus *where)\n {\n   if (check_used (attr, name, where))\n@@ -990,7 +990,7 @@ gfc_add_protected (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_result (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1002,7 +1002,7 @@ gfc_add_result (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_save (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1031,7 +1031,7 @@ gfc_add_save (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_value (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1052,7 +1052,7 @@ gfc_add_value (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_volatile (symbol_attribute *attr, const char *name, locus *where)\n {\n   /* No check_used needed as 11.2.1 of the F2003 standard allows\n@@ -1071,7 +1071,7 @@ gfc_add_volatile (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_threadprivate (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1089,7 +1089,7 @@ gfc_add_threadprivate (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_target (symbol_attribute *attr, locus *where)\n {\n \n@@ -1107,7 +1107,7 @@ gfc_add_target (symbol_attribute *attr, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_dummy (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1120,7 +1120,7 @@ gfc_add_dummy (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_in_common (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1139,7 +1139,7 @@ gfc_add_in_common (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_in_equivalence (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1155,7 +1155,7 @@ gfc_add_in_equivalence (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_data (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1167,7 +1167,7 @@ gfc_add_data (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_in_namelist (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1176,7 +1176,7 @@ gfc_add_in_namelist (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_sequence (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1188,7 +1188,7 @@ gfc_add_sequence (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_elemental (symbol_attribute *attr, locus *where)\n {\n \n@@ -1206,7 +1206,7 @@ gfc_add_elemental (symbol_attribute *attr, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_pure (symbol_attribute *attr, locus *where)\n {\n \n@@ -1224,7 +1224,7 @@ gfc_add_pure (symbol_attribute *attr, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_recursive (symbol_attribute *attr, locus *where)\n {\n \n@@ -1242,7 +1242,7 @@ gfc_add_recursive (symbol_attribute *attr, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_entry (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1260,7 +1260,7 @@ gfc_add_entry (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_function (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1273,7 +1273,7 @@ gfc_add_function (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_subroutine (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1286,7 +1286,7 @@ gfc_add_subroutine (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_generic (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1299,7 +1299,7 @@ gfc_add_generic (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n-try\n+gfc_try\n gfc_add_proc (symbol_attribute *attr, const char *name, locus *where)\n {\n \n@@ -1325,7 +1325,7 @@ gfc_add_proc (symbol_attribute *attr, const char *name, locus *where)\n /* Flavors are special because some flavors are not what Fortran\n    considers attributes and can be reaffirmed multiple times.  */\n \n-try\n+gfc_try\n gfc_add_flavor (symbol_attribute *attr, sym_flavor f, const char *name,\n \t\tlocus *where)\n {\n@@ -1361,7 +1361,7 @@ gfc_add_flavor (symbol_attribute *attr, sym_flavor f, const char *name,\n }\n \n \n-try\n+gfc_try\n gfc_add_procedure (symbol_attribute *attr, procedure_type t,\n \t\t   const char *name, locus *where)\n {\n@@ -1397,7 +1397,7 @@ gfc_add_procedure (symbol_attribute *attr, procedure_type t,\n }\n \n \n-try\n+gfc_try\n gfc_add_intent (symbol_attribute *attr, sym_intent intent, locus *where)\n {\n \n@@ -1423,7 +1423,7 @@ gfc_add_intent (symbol_attribute *attr, sym_intent intent, locus *where)\n \n /* No checks for use-association in public and private statements.  */\n \n-try\n+gfc_try\n gfc_add_access (symbol_attribute *attr, gfc_access access,\n \t\tconst char *name, locus *where)\n {\n@@ -1444,7 +1444,7 @@ gfc_add_access (symbol_attribute *attr, gfc_access access,\n \n /* Set the is_bind_c field for the given symbol_attribute.  */\n \n-try\n+gfc_try\n gfc_add_is_bind_c (symbol_attribute *attr, const char *name, locus *where,\n                    int is_proc_lang_bind_spec)\n {\n@@ -1468,7 +1468,7 @@ gfc_add_is_bind_c (symbol_attribute *attr, const char *name, locus *where,\n }\n \n \n-try\n+gfc_try\n gfc_add_explicit_interface (gfc_symbol *sym, ifsrc source,\n \t\t\t    gfc_formal_arglist * formal, locus *where)\n {\n@@ -1503,7 +1503,7 @@ gfc_add_explicit_interface (gfc_symbol *sym, ifsrc source,\n \n /* Add a type to a symbol.  */\n \n-try\n+gfc_try\n gfc_add_type (gfc_symbol *sym, gfc_typespec *ts, locus *where)\n {\n   sym_flavor flavor;\n@@ -1555,7 +1555,7 @@ gfc_clear_attr (symbol_attribute *attr)\n /* Check for missing attributes in the new symbol.  Currently does\n    nothing, but it's not clear that it is unnecessary yet.  */\n \n-try\n+gfc_try\n gfc_missing_attr (symbol_attribute *attr ATTRIBUTE_UNUSED,\n \t\t  locus *where ATTRIBUTE_UNUSED)\n {\n@@ -1568,7 +1568,7 @@ gfc_missing_attr (symbol_attribute *attr ATTRIBUTE_UNUSED,\n    attributes have a lot of side-effects but cannot be present given\n    where we are called from, so we ignore some bits.  */\n \n-try\n+gfc_try\n gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n {\n   int is_proc_lang_bind_spec;\n@@ -1681,7 +1681,7 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n    already present.  On success, the component pointer is modified to\n    point to the additional component structure.  */\n \n-try\n+gfc_try\n gfc_add_component (gfc_symbol *sym, const char *name,\n \t\t   gfc_component **component)\n {\n@@ -2034,12 +2034,12 @@ gfc_define_st_label (gfc_st_label *lp, gfc_sl_type type, locus *label_locus)\n    updating the unknown state.  Returns FAILURE if something goes\n    wrong.  */\n \n-try\n+gfc_try\n gfc_reference_st_label (gfc_st_label *lp, gfc_sl_type type)\n {\n   gfc_sl_type label_type;\n   int labelno;\n-  try rc;\n+  gfc_try rc;\n \n   if (lp == NULL)\n     return SUCCESS;\n@@ -3257,12 +3257,12 @@ get_iso_c_binding_dt (int sym_id)\n    for such.  If an error occurs, the errors are reported here, allowing for\n    multiple errors to be handled for a single derived type.  */\n \n-try\n+gfc_try\n verify_bind_c_derived_type (gfc_symbol *derived_sym)\n {\n   gfc_component *curr_comp = NULL;\n-  try is_c_interop = FAILURE;\n-  try retval = SUCCESS;\n+  gfc_try is_c_interop = FAILURE;\n+  gfc_try retval = SUCCESS;\n    \n   if (derived_sym == NULL)\n     gfc_internal_error (\"verify_bind_c_derived_type(): Given symbol is \"\n@@ -3406,7 +3406,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n \n /* Generate symbols for the named constants c_null_ptr and c_null_funptr.  */\n \n-static try\n+static gfc_try\n gen_special_c_interop_ptr (int ptr_id, const char *ptr_name,\n                            const char *module_name)\n {"}, {"sha": "e559a2afcb8e0fc7be61b4b84ff96788f7728f04", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -454,7 +454,7 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n   tree decl, backend_decl, stmt;\n   locus old_loc = gfc_current_locus;\n   const char *iname;\n-  try t;\n+  gfc_try t;\n \n   decl = OMP_CLAUSE_DECL (c);\n   gfc_current_locus = where;"}, {"sha": "0fa290c861290fd21812775600a13c6c80832cd8", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=17b1d2a0498d7f5f56e626d3cdfa5e2627a0723e", "patch": "@@ -124,14 +124,14 @@ int gfc_character_storage_size;\n    if a mismatch occurs between ts->f90_type and ts->type; SUCCESS if\n    they match.  */\n \n-try\n+gfc_try\n gfc_validate_c_kind (gfc_typespec *ts)\n {\n    return ((ts->type == ts->f90_type) ? SUCCESS : FAILURE);\n }\n \n \n-try\n+gfc_try\n gfc_check_any_c_kind (gfc_typespec *ts)\n {\n   int i;"}]}