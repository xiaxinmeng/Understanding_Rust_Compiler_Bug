{"sha": "e04ca094deb8860f36d28aa71cfdd66e8a6c55fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA0Y2EwOTRkZWI4ODYwZjM2ZDI4YWE3MWNmZGQ2NmU4YTZjNTVmZA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "2000-08-21T13:42:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-21T13:42:29Z"}, "message": "global.c (global_alloc): Avoid passing dumpfile argument to reload routines.\n\n        * global.c (global_alloc): Avoid passing dumpfile argument to\n        reload routines.\n        * toplev.c (rest_of_compilation): Likewise.\n        * reload.h (reload): Remove dumpfile argument.  Callers changed.\n        (debug_reload, debug_reload_to_stream): Move prototypes here.\n        * rtl.h  (reload): Remove dumpfile argument.\n        * reload.c (debug_reload): Remove prototype.\n        (debug_reload_to_stream): Likewise.\n        * reload1.c: Avoid passing dumpfile around, rely on rtl_dump_file\n        instead.\n\nFrom-SVN: r35840", "tree": {"sha": "df6727ef9c7c1a0110978c0130d936f8504b1fe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df6727ef9c7c1a0110978c0130d936f8504b1fe8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd/comments", "author": null, "committer": null, "parents": [{"sha": "029ccdb3329b1efda30811e9e4d60eb61b12fae6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/029ccdb3329b1efda30811e9e4d60eb61b12fae6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/029ccdb3329b1efda30811e9e4d60eb61b12fae6"}], "stats": {"total": 116, "additions": 57, "deletions": 59}, "files": [{"sha": "e3e9114dece5635c01fe93ec226cd8d13d3820b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e04ca094deb8860f36d28aa71cfdd66e8a6c55fd", "patch": "@@ -1,3 +1,16 @@\n+Mon Aug 21 07:41:12 2000  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* global.c (global_alloc): Avoid passing dumpfile argument to\n+\treload routines.\n+\t* toplev.c (rest_of_compilation): Likewise.\n+\t* reload.h (reload): Remove dumpfile argument.  Callers changed.\n+\t(debug_reload, debug_reload_to_stream): Move prototypes here.\n+\t* rtl.h  (reload): Remove dumpfile argument.\n+\t* reload.c (debug_reload): Remove prototype.\n+\t(debug_reload_to_stream): Likewise.\n+\t* reload1.c: Avoid passing dumpfile around, rely on rtl_dump_file\n+\tinstead.\n+\n 2000-08-21  Gabriel Dos Reis  <gdr@merlin.codesourcery.com>\n \n \t* diagnostic.c (context_as_prefix): Export."}, {"sha": "62e80afd2f068398ce16220b1f99379d0d03c53e", "filename": "gcc/global.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=e04ca094deb8860f36d28aa71cfdd66e8a6c55fd", "patch": "@@ -578,7 +578,7 @@ global_alloc (file)\n #endif\n     {\n       build_insn_chain (get_insns ());\n-      retval = reload (get_insns (), 1, file);\n+      retval = reload (get_insns (), 1);\n     }\n \n   /* Clean up.  */"}, {"sha": "3577af144ce8cab1bcd81886af8df6037ea530a0", "filename": "gcc/reload.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=e04ca094deb8860f36d28aa71cfdd66e8a6c55fd", "patch": "@@ -272,8 +272,6 @@ static void find_reloads_address_part PARAMS ((rtx, rtx *, enum reg_class,\n static rtx find_reloads_subreg_address PARAMS ((rtx, int, int, enum reload_type,\n \t\t\t\t\t      int, rtx));\n static int find_inc_amount\tPARAMS ((rtx, rtx));\n-extern void debug_reload_to_stream PARAMS ((FILE *));\n-extern void debug_reload PARAMS ((void));\n \f\n #ifdef HAVE_SECONDARY_RELOADS\n "}, {"sha": "5561197d298602c6d65f8a33e9e4334c5eb76790", "filename": "gcc/reload.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=e04ca094deb8860f36d28aa71cfdd66e8a6c55fd", "patch": "@@ -348,7 +348,7 @@ extern int reloads_conflict\t\tPARAMS ((int, int));\n extern void init_reload PARAMS ((void));\n \n /* The reload pass itself.  */\n-extern int reload PARAMS ((rtx, int, FILE *));\n+extern int reload PARAMS ((rtx, int));\n \n /* Mark the slots in regs_ever_live for the hard regs\n    used by pseudo-reg number REGNO.  */\n@@ -382,3 +382,7 @@ extern void save_call_clobbered_regs PARAMS ((void));\n \n /* Replace (subreg (reg)) with the appropriate (reg) for any operands.  */\n extern void cleanup_subreg_operands PARAMS ((rtx));\n+\n+/* Debugging support.  */\n+extern void debug_reload_to_stream PARAMS ((FILE *));\n+extern void debug_reload PARAMS ((void));"}, {"sha": "5639d2f3740187c75be9fefef926bf86da2c2e96", "filename": "gcc/reload1.c", "status": "modified", "additions": 36, "deletions": 51, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e04ca094deb8860f36d28aa71cfdd66e8a6c55fd", "patch": "@@ -373,10 +373,9 @@ static int num_labels;\n static void maybe_fix_stack_asms\tPARAMS ((void));\n static void copy_reloads\t\tPARAMS ((struct insn_chain *));\n static void calculate_needs_all_insns\tPARAMS ((int));\n-static int find_reg\t\t\tPARAMS ((struct insn_chain *, int,\n-\t\t\t\t\t       FILE *));\n-static void find_reload_regs\t\tPARAMS ((struct insn_chain *, FILE *));\n-static void select_reload_regs\t\tPARAMS ((FILE *));\n+static int find_reg\t\t\tPARAMS ((struct insn_chain *, int));\n+static void find_reload_regs\t\tPARAMS ((struct insn_chain *));\n+static void select_reload_regs\t\tPARAMS ((void));\n static void delete_caller_save_insns\tPARAMS ((void));\n \n static void spill_failure\t\tPARAMS ((rtx, enum reg_class));\n@@ -395,13 +394,13 @@ static void set_initial_label_offsets\tPARAMS ((void));\n static void set_offsets_for_label\tPARAMS ((rtx));\n static void init_elim_table\t\tPARAMS ((void));\n static void update_eliminables\t\tPARAMS ((HARD_REG_SET *));\n-static void spill_hard_reg\t\tPARAMS ((unsigned int, FILE *, int));\n-static int finish_spills\t\tPARAMS ((int, FILE *));\n+static void spill_hard_reg\t\tPARAMS ((unsigned int, int));\n+static int finish_spills\t\tPARAMS ((int));\n static void ior_hard_reg_set\t\tPARAMS ((HARD_REG_SET *, HARD_REG_SET *));\n static void scan_paradoxical_subregs\tPARAMS ((rtx));\n static void count_pseudo\t\tPARAMS ((int));\n static void order_regs_for_reload\tPARAMS ((struct insn_chain *));\n-static void reload_as_needed\t\tPARAMS ((int, FILE *));\n+static void reload_as_needed\t\tPARAMS ((int));\n static void forget_old_reloads_1\tPARAMS ((rtx, rtx, void *));\n static int reload_reg_class_lower\tPARAMS ((const PTR, const PTR));\n static void mark_reload_reg_in_use\tPARAMS ((unsigned int, int,\n@@ -431,7 +430,7 @@ static void do_input_reload\t\tPARAMS ((struct insn_chain *,\n \t\t\t\t\t\t struct reload *, int));\n static void do_output_reload\t\tPARAMS ((struct insn_chain *,\n \t\t\t\t\t\t struct reload *, int));\n-static void emit_reload_insns\t\tPARAMS ((struct insn_chain *, FILE *));\n+static void emit_reload_insns\t\tPARAMS ((struct insn_chain *));\n static void delete_output_reload\tPARAMS ((rtx, int, int));\n static void delete_address_reloads\tPARAMS ((rtx, rtx));\n static void delete_address_reloads_1\tPARAMS ((rtx, rtx, rtx));\n@@ -455,7 +454,7 @@ static void failed_reload\t\tPARAMS ((rtx, int));\n static int set_reload_reg\t\tPARAMS ((int, int));\n static void reload_cse_delete_noop_set\tPARAMS ((rtx, rtx));\n static void reload_cse_simplify\t\tPARAMS ((rtx));\n-extern void dump_needs\t\t\tPARAMS ((struct insn_chain *, FILE *));\n+extern void dump_needs\t\t\tPARAMS ((struct insn_chain *));\n \f\n /* Initialize the reload pass once per compilation.  */\n \n@@ -595,19 +594,13 @@ static int failure;\n    If GLOBAL is zero, we do not have enough information to do that,\n    so any pseudo reg that is spilled must go to the stack.\n \n-   DUMPFILE is the global-reg debugging dump file stream, or 0.\n-   If it is nonzero, messages are written to it to describe\n-   which registers are seized as reload regs, which pseudo regs\n-   are spilled from them, and where the pseudo regs are reallocated to.\n-\n    Return value is nonzero if reload failed\n    and we must not do any more for this function.  */\n \n int\n-reload (first, global, dumpfile)\n+reload (first, global)\n      rtx first;\n      int global;\n-     FILE *dumpfile;\n {\n   register int i;\n   register rtx insn;\n@@ -824,13 +817,13 @@ reload (first, global, dumpfile)\n   CLEAR_HARD_REG_SET (used_spill_regs);\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     if (! ep->can_eliminate)\n-      spill_hard_reg (ep->from, dumpfile, 1);\n+      spill_hard_reg (ep->from, 1);\n \n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n   if (frame_pointer_needed)\n-    spill_hard_reg (HARD_FRAME_POINTER_REGNUM, dumpfile, 1);\n+    spill_hard_reg (HARD_FRAME_POINTER_REGNUM, 1);\n #endif\n-  finish_spills (global, dumpfile);\n+  finish_spills (global);\n \n   /* From now on, we may need to generate moves differently.  We may also\n      allow modifications of insns which cause them to not be recognized.\n@@ -946,7 +939,7 @@ reload (first, global, dumpfile)\n \tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t  if (TEST_HARD_REG_BIT (to_spill, i))\n \t    {\n-\t      spill_hard_reg (i, dumpfile, 1);\n+\t      spill_hard_reg (i, 1);\n \t      did_spill = 1;\n \n \t      /* Regardless of the state of spills, if we previously had\n@@ -962,12 +955,12 @@ reload (first, global, dumpfile)\n \t    }\n       }\n \n-      select_reload_regs (dumpfile);\n+      select_reload_regs ();\n       if (failure)\n \tgoto failed;\n \n       if (insns_need_reload != 0 || did_spill)\n-\tsomething_changed |= finish_spills (global, dumpfile);\n+\tsomething_changed |= finish_spills (global);\n \n       if (! something_changed)\n \tbreak;\n@@ -1023,7 +1016,7 @@ reload (first, global, dumpfile)\n     {\n       int old_frame_size = get_frame_size ();\n \n-      reload_as_needed (global, dumpfile);\n+      reload_as_needed (global);\n \n       if (old_frame_size != get_frame_size ())\n \tabort ();\n@@ -1585,10 +1578,9 @@ count_spilled_pseudo (spilled, spilled_nregs, reg)\n /* Find reload register to use for reload number ORDER.  */\n \n static int\n-find_reg (chain, order, dumpfile)\n+find_reg (chain, order)\n      struct insn_chain *chain;\n      int order;\n-     FILE *dumpfile;\n {\n   int rnum = reload_order[order];\n   struct reload *rl = rld + rnum;\n@@ -1659,8 +1651,8 @@ find_reg (chain, order, dumpfile)\n   if (best_reg == -1)\n     return 0;\n \n-  if (dumpfile)\n-    fprintf (dumpfile, \"Using reg %d for reload %d\\n\", best_reg, rnum);\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Using reg %d for reload %d\\n\", best_reg, rnum);\n \n   rl->nregs = HARD_REGNO_NREGS (best_reg, rl->mode);\n   rl->regno = best_reg;\n@@ -1694,9 +1686,8 @@ find_reg (chain, order, dumpfile)\n    for a smaller class even though it belongs to that class.  */\n \n static void\n-find_reload_regs (chain, dumpfile)\n+find_reload_regs (chain)\n      struct insn_chain *chain;\n-     FILE *dumpfile;\n {\n   int i;\n \n@@ -1724,8 +1715,8 @@ find_reload_regs (chain, dumpfile)\n \n   CLEAR_HARD_REG_SET (used_spill_regs_local);\n \n-  if (dumpfile)\n-    fprintf (dumpfile, \"Spilling for insn %d.\\n\", INSN_UID (chain->insn));\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Spilling for insn %d.\\n\", INSN_UID (chain->insn));\n \n   qsort (reload_order, n_reloads, sizeof (short), reload_reg_class_lower);\n \n@@ -1741,7 +1732,7 @@ find_reload_regs (chain, dumpfile)\n       if ((rld[r].out != 0 || rld[r].in != 0 || rld[r].secondary_p)\n \t  && ! rld[r].optional\n \t  && rld[r].regno == -1)\n-\tif (! find_reg (chain, i, dumpfile))\n+\tif (! find_reg (chain, i))\n \t  {\n \t    spill_failure (chain->insn, rld[r].class);\n \t    failure = 1;\n@@ -1756,15 +1747,14 @@ find_reload_regs (chain, dumpfile)\n }\n \n static void\n-select_reload_regs (dumpfile)\n-     FILE *dumpfile;\n+select_reload_regs ()\n {\n   struct insn_chain *chain;\n \n   /* Try to satisfy the needs for each insn.  */\n   for (chain = insns_need_reload; chain != 0;\n        chain = chain->next_need_reload)\n-    find_reload_regs (chain, dumpfile);\n+    find_reload_regs (chain);\n }\n \f\n /* Delete all insns that were inserted by emit_caller_save_insns during\n@@ -3450,7 +3440,6 @@ init_elim_table ()\n }\n \f\n /* Kick all pseudos out of hard register REGNO.\n-   If DUMPFILE is nonzero, log actions taken on that file.\n \n    If CANT_ELIMINATE is nonzero, it means that we are doing this spill\n    because we found we can't eliminate some register.  In the case, no pseudos\n@@ -3461,9 +3450,8 @@ init_elim_table ()\n    Return nonzero if any pseudos needed to be kicked out.  */\n \n static void\n-spill_hard_reg (regno, dumpfile, cant_eliminate)\n+spill_hard_reg (regno, cant_eliminate)\n      unsigned int regno;\n-     FILE *dumpfile ATTRIBUTE_UNUSED;\n      int cant_eliminate;\n {\n   register int i;\n@@ -3503,9 +3491,8 @@ ior_hard_reg_set (set1, set2)\n    spill_regs array for use by choose_reload_regs.  */\n \n static int\n-finish_spills (global, dumpfile)\n+finish_spills (global)\n      int global;\n-     FILE *dumpfile;\n {\n   struct insn_chain *chain;\n   int something_changed = 0;\n@@ -3636,12 +3623,12 @@ finish_spills (global, dumpfile)\n \n       alter_reg (i, reg_old_renumber[i]);\n       reg_old_renumber[i] = regno;\n-      if (dumpfile)\n+      if (rtl_dump_file)\n \t{\n \t  if (regno == -1)\n-\t    fprintf (dumpfile, \" Register %d now on stack.\\n\\n\", i);\n+\t    fprintf (rtl_dump_file, \" Register %d now on stack.\\n\\n\", i);\n \t  else\n-\t    fprintf (dumpfile, \" Register %d now in %d.\\n\\n\",\n+\t    fprintf (rtl_dump_file, \" Register %d now in %d.\\n\\n\",\n \t\t     i, reg_renumber[i]);\n \t}\n     }\n@@ -3717,9 +3704,8 @@ scan_paradoxical_subregs (x)\n    as the insns are scanned.  */\n \n static void\n-reload_as_needed (live_known, dumpfile)\n+reload_as_needed (live_known)\n      int live_known;\n-     FILE *dumpfile;\n {\n   struct insn_chain *chain;\n #if defined (AUTO_INC_DEC)\n@@ -3820,7 +3806,7 @@ reload_as_needed (live_known, dumpfile)\n \n \t      /* Generate the insns to reload operands into or out of\n \t\t their reload regs.  */\n-\t      emit_reload_insns (chain, dumpfile);\n+\t      emit_reload_insns (chain);\n \n \t      /* Substitute the chosen reload regs from reload_reg_rtx\n \t\t into the insn's body (or perhaps into the bodies of other\n@@ -6771,9 +6757,8 @@ do_output_reload (chain, rl, j)\n /* Output insns to reload values in and out of the chosen reload regs.  */\n \n static void\n-emit_reload_insns (chain, dumpfile)\n+emit_reload_insns (chain)\n      struct insn_chain *chain;\n-     FILE *dumpfile;\n {\n   rtx insn = chain->insn;\n \n@@ -6795,10 +6780,10 @@ emit_reload_insns (chain, dumpfile)\n   other_operand_reload_insns = 0;\n \n   /* Dump reloads into the dump file.  */\n-  if (dumpfile)\n+  if (rtl_dump_file)\n     {\n-      fprintf (dumpfile, \"\\nReloads for insn # %d\\n\", INSN_UID (insn));\n-      debug_reload_to_stream (dumpfile);\n+      fprintf (rtl_dump_file, \"\\nReloads for insn # %d\\n\", INSN_UID (insn));\n+      debug_reload_to_stream (rtl_dump_file);\n     }\n \n   /* Now output the instructions to copy the data into and out of the"}, {"sha": "92ee5838417c9912a4032281aa134e1e94ad0d4f", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e04ca094deb8860f36d28aa71cfdd66e8a6c55fd", "patch": "@@ -1847,9 +1847,7 @@ extern int function_invariant_p\t\tPARAMS ((rtx));\n extern void reload_cse_regs\t\tPARAMS ((rtx));\n extern void init_reload\t\t\tPARAMS ((void));\n extern void mark_home_live\t\tPARAMS ((int));\n-#ifdef BUFSIZ\n-extern int reload\t\t\tPARAMS ((rtx, int, FILE *));\n-#endif\n+extern int reload\t\t\tPARAMS ((rtx, int));\n \n /* In caller-save.c */\n extern void init_caller_save\t\tPARAMS ((void));"}, {"sha": "bff4b3187ae64a9af9b5ea016b7be2d0af37bd58", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04ca094deb8860f36d28aa71cfdd66e8a6c55fd/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e04ca094deb8860f36d28aa71cfdd66e8a6c55fd", "patch": "@@ -3362,7 +3362,7 @@ rest_of_compilation (decl)\n   else\n     {\n       build_insn_chain (insns);\n-      failure = reload (insns, 0, rtl_dump_file);\n+      failure = reload (insns, 0);\n     }\n \n   timevar_pop (TV_GLOBAL_ALLOC);"}]}