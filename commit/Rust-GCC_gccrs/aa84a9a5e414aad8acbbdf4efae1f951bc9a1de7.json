{"sha": "aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE4NGE5YTVlNDE0YWFkOGFjYmJkZjRlZmFlMWY5NTFiYzlhMWRlNw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-08-04T20:46:11Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-08-04T20:46:11Z"}, "message": "re PR fortran/31214 (User-defined operator using entry leads to ICE)\n\n2007-08-04  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31214\n\t* symbol.c (get_unique_symtree): Moved from module.c.\n\t* module.c (get_unique_symtree): Moved to symbol.c.\n\t* decl.c (get_proc_name): Transfer the typespec from the local\n\tsymbol to the module symbol, in the case that an entry is also\n\ta module procedure.  Ensure the local symbol is cleaned up by\n\tpointing to it with a unique symtree.\n\n\t* dump_parse_tree (gfc_show_code_node): Add EXEC_ASSIGN_CALL.\n\n2007-08-04  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/31214\n\t* gfortran.dg/entry_13.f90: New test.\n\n\t* gfortran.dg/entry_12.f90: Clean up .mod file.\n\nFrom-SVN: r127213", "tree": {"sha": "df679370a76da565ff23a0cbbdd8f61a1c342b7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df679370a76da565ff23a0cbbdd8f61a1c342b7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/comments", "author": null, "committer": null, "parents": [{"sha": "6b44ad312f943d9ae65ad6db8f4be0640eefec6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b44ad312f943d9ae65ad6db8f4be0640eefec6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b44ad312f943d9ae65ad6db8f4be0640eefec6e"}], "stats": {"total": 214, "additions": 161, "deletions": 53}, "files": [{"sha": "e9b2ed30682ef21baeb23f9ffc0a3b900b4aafdc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7", "patch": "@@ -1,3 +1,10 @@\n+2007-08-04  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31214\n+\t* gfortran.dg/entry_13.f90: New test.\n+\n+\t* gfortran.dg/entry_12.f90: Clean up .mod file.\n+\n 2008-08-04  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/32969"}, {"sha": "d674aeb92e15fb872bac71c444802629aba88ca8", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7", "patch": "@@ -681,8 +681,27 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n     {\n       /* Present if entry is declared to be a module procedure.  */\n       rc = gfc_find_symbol (name, gfc_current_ns->parent, 0, result);\n+\n       if (*result == NULL)\n \trc = gfc_get_symbol (name, NULL, result);\n+      else if (gfc_get_symbol (name, NULL, &sym) == 0\n+\t\t && sym\n+\t\t && sym->ts.type != BT_UNKNOWN\n+\t\t && (*result)->ts.type == BT_UNKNOWN\n+\t\t && sym->attr.flavor == FL_UNKNOWN)\n+\t/* Pick up the typespec for the entry, if declared in the function\n+\t   body.  Note that this symbol is FL_UNKNOWN because it will\n+\t   only have appeared in a type declaration.  The local symtree\n+\t   is set to point to the module symbol and a unique symtree\n+\t   to the local version.  This latter ensures a correct clearing\n+\t   of the symbols.  */\n+\t  {\n+\t    (*result)->ts = sym->ts;\n+\t    gfc_find_sym_tree (name, gfc_current_ns, 0, &st);\n+\t    st->n.sym = *result;\n+\t    st = gfc_get_unique_symtree (gfc_current_ns);\n+\t    st->n.sym = sym;\n+\t  }\n     }\n   else\n     rc = gfc_get_symbol (name, gfc_current_ns->parent, result);"}, {"sha": "ac6a6f5d7b8e9358274816626ac26e26172551c8", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7", "patch": "@@ -1084,6 +1084,7 @@ gfc_show_code_node (int level, gfc_code *c)\n       break;\n \n     case EXEC_CALL:\n+    case EXEC_ASSIGN_CALL:\n       if (c->resolved_sym)\n \tgfc_status (\"CALL %s \", c->resolved_sym->name);\n       else if (c->symtree)"}, {"sha": "329fae2103f755fea726a5a9f16b7b5f52927442", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7", "patch": "@@ -2124,6 +2124,7 @@ gfc_expr * gfc_lval_expr_from_sym (gfc_symbol *);\n gfc_namespace *gfc_get_namespace (gfc_namespace *, int);\n gfc_symtree *gfc_new_symtree (gfc_symtree **, const char *);\n gfc_symtree *gfc_find_symtree (gfc_symtree *, const char *);\n+gfc_symtree *gfc_get_unique_symtree (gfc_namespace *);\n gfc_user_op *gfc_get_uop (const char *);\n gfc_user_op *gfc_find_uop (const char *, gfc_namespace *);\n void gfc_free_symbol (gfc_symbol *);"}, {"sha": "baba5c7434ca7ede1ec370a99e2e98f60b67d557", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7", "patch": "@@ -1822,20 +1822,6 @@ mio_charlen (gfc_charlen **clp)\n }\n \n \n-/* Return a symtree node with a name that is guaranteed to be unique\n-   within the namespace and corresponds to an illegal fortran name.  */\n-\n-static gfc_symtree *\n-get_unique_symtree (gfc_namespace *ns)\n-{\n-  char name[GFC_MAX_SYMBOL_LEN + 1];\n-  static int serial = 0;\n-\n-  sprintf (name, \"@%d\", serial++);\n-  return gfc_new_symtree (&ns->sym_root, name);\n-}\n-\n-\n /* See if a name is a generated name.  */\n \n static int\n@@ -2287,7 +2273,7 @@ mio_symtree_ref (gfc_symtree **stp)\n       if (in_load_equiv && p->u.rsym.symtree == NULL)\n \t{\n \t  /* Since this is not used, it must have a unique name.  */\n-\t  p->u.rsym.symtree = get_unique_symtree (gfc_current_ns);\n+\t  p->u.rsym.symtree = gfc_get_unique_symtree (gfc_current_ns);\n \n \t  /* Make the symbol.  */\n \t  if (p->u.rsym.sym == NULL)\n@@ -3418,7 +3404,7 @@ read_cleanup (pointer_info *p)\n     {\n       /* Add hidden symbols to the symtree.  */\n       q = get_integer (p->u.rsym.ns);\n-      st = get_unique_symtree ((gfc_namespace *) q->u.pointer);\n+      st = gfc_get_unique_symtree ((gfc_namespace *) q->u.pointer);\n \n       st->n.sym = p->u.rsym.sym;\n       st->n.sym->refs++;\n@@ -3598,7 +3584,7 @@ read_module (void)\n \t      /* Create a symtree node in the current namespace for this\n \t\t symbol.  */\n \t      st = check_unique_name (p)\n-\t\t   ? get_unique_symtree (gfc_current_ns)\n+\t\t   ? gfc_get_unique_symtree (gfc_current_ns)\n \t\t   : gfc_new_symtree (&gfc_current_ns->sym_root, p);\n \n \t      st->ambiguous = ambiguous;"}, {"sha": "3aae04c4923c605cd137bae0878291e89c712770", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7", "patch": "@@ -2129,6 +2129,20 @@ gfc_find_symtree (gfc_symtree *st, const char *name)\n }\n \n \n+/* Return a symtree node with a name that is guaranteed to be unique\n+   within the namespace and corresponds to an illegal fortran name.  */\n+\n+gfc_symtree *\n+gfc_get_unique_symtree (gfc_namespace *ns)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  static int serial = 0;\n+\n+  sprintf (name, \"@%d\", serial++);\n+  return gfc_new_symtree (&ns->sym_root, name);\n+}\n+\n+\n /* Given a name find a user operator node, creating it if it doesn't\n    exist.  These are much simpler than symbols because they can't be\n    ambiguous with one another.  */"}, {"sha": "3dabc56d37c51bb70baa205da4ebb6028d6dfc11", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7", "patch": "@@ -1,10 +1,9 @@\n-2007-08-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+2007-08-04  Paul Thomas  <pault@gcc.gnu.org>\n \n-\tPR fortran/32770\n-\t* gfortran.dg/streamio_8.f90:  Adjust so test case passes\n-\tfor -fdefault-integer-8 and -fdefault-real-8.\n-\t* gfortran.dg/streamio_10.f90:  Likewise.\n-\t* gfortran.dg/sizeof.f90:  Likewise.\n+\tPR fortran/31214\n+\t* gfortran.dg/entry_13.f90: New test.\n+\n+\t* gfortran.dg/entry_12.f90: Clean up .mod file.\n \n 2007-08-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n "}, {"sha": "5513697a17cd096d759e2d049b67e5d885af43da", "filename": "gcc/testsuite/gfortran.dg/entry_12.f90", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_12.f90?ref=aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7", "patch": "@@ -1,30 +1,31 @@\n-! { dg-do run }\r\n-! Tests the fix for pr31609, where module procedure entries found\r\n-! themselves in the wrong namespace.  This test checks that all\r\n-! combinations of generic and specific calls work correctly.\r\n-!\r\n-! Contributed by Paul Thomas <pault@gcc.gnu.org> as comment #8 to the pr.\r\n-!\r\n-MODULE ksbin1_aux_mod\r\n-  interface foo\r\n-    module procedure j\r\n-  end interface\r\n-  interface bar\r\n-    module procedure k\r\n-  end interface\r\n-  interface foobar\r\n-    module procedure j, k\r\n-  end interface\r\n-  CONTAINS\r\n-    FUNCTION j () \r\n-    j = 1\r\n-    return\r\n-    ENTRY k (i) \r\n-    k = 2\r\n-    END FUNCTION j\r\n-END MODULE ksbin1_aux_mod\r\n-\r\n-    use ksbin1_aux_mod\r\n-    if (any ((/foo (), bar (99), foobar (), foobar (99), j (), k (99)/) .ne. &\r\n-             (/1, 2, 1, 2, 1, 2/))) Call abort ()\r\n-end\r\n+! { dg-do run }\n+! Tests the fix for pr31609, where module procedure entries found\n+! themselves in the wrong namespace.  This test checks that all\n+! combinations of generic and specific calls work correctly.\n+!\n+! Contributed by Paul Thomas <pault@gcc.gnu.org> as comment #8 to the pr.\n+!\n+MODULE ksbin1_aux_mod\n+  interface foo\n+    module procedure j\n+  end interface\n+  interface bar\n+    module procedure k\n+  end interface\n+  interface foobar\n+    module procedure j, k\n+  end interface\n+  CONTAINS\n+    FUNCTION j () \n+    j = 1\n+    return\n+    ENTRY k (i) \n+    k = 2\n+    END FUNCTION j\n+END MODULE ksbin1_aux_mod\n+\n+    use ksbin1_aux_mod\n+    if (any ((/foo (), bar (99), foobar (), foobar (99), j (), k (99)/) .ne. &\n+             (/1, 2, 1, 2, 1, 2/))) Call abort ()\n+end\n+! { dg-final { cleanup-modules \"ksbin1_aux_mod\" } }"}, {"sha": "2d2aedaf3d8b0625b9bf85c5ab91e69416dec4db", "filename": "gcc/testsuite/gfortran.dg/entry_13.f90", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_13.f90?ref=aa84a9a5e414aad8acbbdf4efae1f951bc9a1de7", "patch": "@@ -0,0 +1,80 @@\n+! { dg-do run }\n+! Tests the fix for pr31214, in which the typespec for the entry would be lost,\n+! thereby causing the function to be disallowed, since the function and entry\n+! types did not match.\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+module type_mod\n+  implicit none\n+\n+  type x\n+     real x\n+  end type x\n+  type y\n+     real x\n+  end type y\n+  type z\n+     real x\n+  end type z\n+\n+  interface assignment(=)\n+     module procedure equals\n+  end interface assignment(=)\n+\n+  interface operator(//)\n+     module procedure a_op_b, b_op_a\n+  end interface operator(//)\n+\n+  interface operator(==)\n+     module procedure a_po_b, b_po_a\n+  end interface operator(==)\n+\n+  contains\n+     subroutine equals(x,y)\n+        type(z), intent(in) :: y\n+        type(z), intent(out) :: x\n+\n+        x%x = y%x\n+     end subroutine equals\n+\n+     function a_op_b(a,b)\n+        type(x), intent(in) :: a\n+        type(y), intent(in) :: b\n+        type(z) a_op_b\n+        type(z) b_op_a\n+        a_op_b%x = a%x + b%x\n+        return\n+     entry b_op_a(b,a)\n+        b_op_a%x = a%x - b%x\n+     end function a_op_b\n+\n+     function a_po_b(a,b)\n+        type(x), intent(in) :: a\n+        type(y), intent(in) :: b\n+        type(z) a_po_b\n+        type(z) b_po_a\n+     entry b_po_a(b,a)\n+        a_po_b%x = a%x/b%x\n+     end function a_po_b\n+end module type_mod\n+\n+program test\n+  use type_mod\n+  implicit none\n+  type(x) :: x1 = x(19.0_4)\n+  type(y) :: y1 = y(7.0_4)\n+  type(z) z1\n+\n+  z1 = x1//y1\n+  if (z1%x .ne. 19.0_4 + 7.0_4) call abort ()\n+  z1 = y1//x1\n+  if (z1%x .ne. 19.0_4 - 7.0_4) call abort ()\n+\n+  z1 = x1==y1\n+  if (z1%x .ne. 19.0_4/7.0_4) call abort ()\n+  z1 = y1==x1\n+  if (z1%x .ne. 19.0_4/7.0_4) call abort ()\n+end program test\n+! { dg-final { cleanup-modules \"type_mod\" } }\n+"}]}