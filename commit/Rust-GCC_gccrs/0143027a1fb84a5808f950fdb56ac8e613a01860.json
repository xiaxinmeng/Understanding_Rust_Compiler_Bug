{"sha": "0143027a1fb84a5808f950fdb56ac8e613a01860", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE0MzAyN2ExZmI4NGE1ODA4Zjk1MGZkYjU2YWM4ZTYxM2EwMTg2MA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-09T21:50:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-09T21:50:29Z"}, "message": "Add port done awhile ago for the ARC cpu.\n\n        * arc/arc.h: New file.\n        * arc/arc.c: New file.\n        * arc/arc.md: New file.\n        * arc/initfini.c: New file.\n        * arc/lib1funcs.asm: New file.\n        * arc/t-arc: New file.\n        * arc/xm-arc.h: New file.\n        * ginclude/va-arc.h: New file.\n        * ginclude/stdarg.h: Include va-arc.h ifdef __arc__.\n        * ginclude/varargs.h: Likewise.\n        * Makefile.in (USER_H): Add va-arc.h.\n        * configure.in (arc-*-elf*): Recognize.\n        * longlong.h: Add ARC support.\nMostly so I can test changes in snapshot scripts.\n\n        * expr.c (clear_storage): Use CONST0_RTX instead of const0_rtx.\n        when clearing non-BLKmode data.\nFixes sparc problem.\n\nFrom-SVN: r15185", "tree": {"sha": "897c5a0c99d6e79302eec00ef80db5b048566b64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/897c5a0c99d6e79302eec00ef80db5b048566b64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0143027a1fb84a5808f950fdb56ac8e613a01860", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0143027a1fb84a5808f950fdb56ac8e613a01860", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0143027a1fb84a5808f950fdb56ac8e613a01860", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0143027a1fb84a5808f950fdb56ac8e613a01860/comments", "author": null, "committer": null, "parents": [{"sha": "d7ad6040df4c6cdca2da4ee2801860da2c0164ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7ad6040df4c6cdca2da4ee2801860da2c0164ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7ad6040df4c6cdca2da4ee2801860da2c0164ba"}], "stats": {"total": 1643, "additions": 1643, "deletions": 0}, "files": [{"sha": "d92fbdc0b988d86a6e9c4b67aa2cb7308a0597b6", "filename": "gcc/config/arc/arc.h", "status": "added", "additions": 1643, "deletions": 0, "changes": 1643, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0143027a1fb84a5808f950fdb56ac8e613a01860/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0143027a1fb84a5808f950fdb56ac8e613a01860/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=0143027a1fb84a5808f950fdb56ac8e613a01860", "patch": "@@ -0,0 +1,1643 @@\n+/* Definitions of target machine for GNU compiler, for the ARC cpu.\n+   Copyright (C) 1994, 1995, 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* ??? This is an old port, and is undoubtedly suffering from bit rot.  */\n+\n+/* Things to do:\n+\n+   - PREDICATE_CODES\n+   - incscc, decscc?\n+   - print active compiler options in assembler output\n+*/\n+\n+/* FIXME: Create elf.h and have svr4.h include it.  */\n+#include \"svr4.h\"\n+\n+#undef ASM_SPEC\n+#undef LINK_SPEC\n+#undef STARTFILE_SPEC\n+#undef ENDFILE_SPEC\n+#undef SIZE_TYPE\n+#undef PTRDIFF_TYPE\n+#undef WCHAR_TYPE\n+#undef WCHAR_TYPE_SIZE\n+\f\n+/* Print subsidiary information on the compiler version in use.  */\n+#define TARGET_VERSION fprintf (stderr, \" (arc)\")\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+#define CPP_PREDEFINES \"-Acpu(arc) -Amachine(arc) -D__arc__\"\n+\n+/* Additional flags for the preprocessor.  */\n+#define CPP_SPEC \"\\\n+%{!mcpu=*:-D__base__} %{mcpu=base:-D__base__} \\\n+%{EB:-D__big_endian__} \\\n+\"\n+\n+/* Pass -mmangle-cpu if we get -mcpu=*.\n+   Doing it this way lets one have it on as default with -mcpu=*,\n+   but also lets one turn it off with -mno-mangle-cpu.  */\n+#define CC1_SPEC \"\\\n+%{mcpu=*:-mmangle-cpu} \\\n+%{EB:%{EL:%emay not use both -EB and -EL}} \\\n+%{EB:-mbig-endian} %{EL:-mlittle-endian} \\\n+\"\n+\n+#define ASM_SPEC \"%{v} %{EB} %{EL}\"\n+\n+#define LINK_SPEC \"%{v} %{EB} %{EL}\"\n+\n+#define STARTFILE_SPEC \"%{!shared:crt0.o%s} crtinit.o%s\"\n+\n+#define ENDFILE_SPEC \"crtfini.o%s\"\n+\f\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Mangle all user symbols for the specified cpu.\n+   ARC's can be shipped in which a collection of cpus are coupled together.\n+   Each CPU may be different in some way, and thus we may need to distinguish\n+   code compiled for one to ensure it isn't linked with code compiled for\n+   another.  */\n+#define TARGET_MASK_MANGLE_CPU 1\n+#define TARGET_MANGLE_CPU (target_flags & TARGET_MASK_MANGLE_CPU)\n+\n+#if 0\n+/* Mangle libgcc symbols by adding a suffix for the specified cpu.  */\n+#define TARGET_MASK_MANGLE_CPU_LIBGCC 2\n+#define TARGET_MANGLE_CPU_LIBGCC (target_flags & TARGET_MASK_MANGLE_CPU_LIBGCC)\n+#endif\n+\n+/* Align loops to 32 byte boundaries (cache line size).  */\n+#define TARGET_MASK_ALIGN_LOOPS 4\n+#define TARGET_ALIGN_LOOPS (target_flags & TARGET_MASK_ALIGN_LOOPS)\n+\n+/* Big Endian.  */\n+#define TARGET_MASK_BIG_ENDIAN 8\n+#define TARGET_BIG_ENDIAN (target_flags & TARGET_MASK_BIG_ENDIAN)\n+\n+/* Turn off conditional execution optimization,\n+   so we can see how well it does, or in case it's buggy.  */\n+#define TARGET_MASK_NO_COND_EXEC 0x10\n+#define TARGET_NO_COND_EXEC (target_flags & TARGET_MASK_NO_COND_EXEC)\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES \\\n+{ \\\n+    { \"mangle-cpu\",\t\tTARGET_MASK_MANGLE_CPU },\t\t\\\n+    { \"no-mangle-cpu\",\t\t-TARGET_MASK_MANGLE_CPU },\t\t\\\n+/*  { \"mangle-cpu-libgcc\",\tTARGET_MASK_MANGLE_CPU_LIBGCC }, */\t\\\n+/*  { \"no-mangle-cpu-libgcc\",\t-TARGET_MASK_MANGLE_CPU_LIBGCC }, */\t\\\n+    { \"align-loops\",\t\tTARGET_MASK_ALIGN_LOOPS },\t\t\\\n+    { \"no-align-loops\",\t\t-TARGET_MASK_ALIGN_LOOPS },\t\t\\\n+    { \"big-endian\",\t\tTARGET_MASK_BIG_ENDIAN },\t\t\\\n+    { \"little-endian\",\t\t-TARGET_MASK_BIG_ENDIAN },\t\t\\\n+    { \"no-cond-exec\",\t\tTARGET_MASK_NO_COND_EXEC },\t\t\\\n+    SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n+    { \"\", TARGET_DEFAULT }\t\t\t\t\t\t\\\n+}\n+\n+#define TARGET_DEFAULT (0)\n+\n+#define SUBTARGET_SWITCHES\n+\n+/* Instruction set characteristics.\n+   These are internal macros, set by the appropriate -mcpu= option.  */\n+\n+/* Non-zero means the cpu has a barrel shifter.  */\n+#define TARGET_SHIFTER 0\n+\n+/* This macro is similar to `TARGET_SWITCHES' but defines names of\n+   command options that have values.  Its definition is an\n+   initializer with a subgrouping for each command option.\n+\n+   Each subgrouping contains a string constant, that defines the\n+   fixed part of the option name, and the address of a variable. \n+   The variable, type `char *', is set to the variable part of the\n+   given option if the fixed part matches.  The actual option name\n+   is made by appending `-m' to the specified name.\n+\n+   Here is an example which defines `-mshort-data-NUMBER'.  If the\n+   given option is `-mshort-data-512', the variable `m88k_short_data'\n+   will be set to the string `\"512\"'.\n+\n+\textern char *m88k_short_data;\n+\t#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n+\n+extern char *arc_cpu_string;\n+extern char *arc_text_string,*arc_data_string,*arc_rodata_string;\n+\n+#define TARGET_OPTIONS \\\n+{\t\t\t\t\t\t\\\n+  { \"cpu=\",\t&arc_cpu_string\t\t},\t\\\n+  { \"text=\",\t&arc_text_string\t},\t\\\n+  { \"data=\",\t&arc_data_string\t},\t\\\n+  { \"rodata=\",\t&arc_rodata_string\t},\t\\\n+}\n+\n+/* Which cpu we're compiling for.  */\n+extern int arc_cpu_type;\n+\n+/* Check if CPU is an extension and set `arc_cpu_type' and `arc_mangle_cpu'\n+   appropriately.  The result should be non-zero if the cpu is recognized,\n+   otherwise zero.  This is intended to be redefined in a cover file.\n+   This is used by arc_init.  */\n+#define ARC_EXTENSION_CPU(cpu) 0\n+\n+/* Sometimes certain combinations of command options do not make\n+   sense on a particular target machine.  You can define a macro\n+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n+   defined, is executed once just after all the command options have\n+   been parsed.\n+\n+   Don't use this macro to turn on various extra optimizations for\n+   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n+\n+extern void arc_init ();\n+\n+#define OVERRIDE_OPTIONS \\\n+do {\t\t\t\t\\\n+  /* These need to be done at start up.  It's convenient to do them here.  */ \\\n+  arc_init ();\t\t\t\\\n+} while (0)\n+\f\n+/* Target machine storage layout.  */\n+\n+/* Define to use software floating point emulator for REAL_ARITHMETIC and\n+   decimal <-> binary conversion. */\n+#define REAL_ARITHMETIC\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.  */\n+#define BITS_BIG_ENDIAN 1\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+#define BYTES_BIG_ENDIAN (TARGET_BIG_ENDIAN)\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+#define WORDS_BIG_ENDIAN (TARGET_BIG_ENDIAN)\n+\n+/* Define this to set the endianness to use in libgcc2.c, which can\n+   not depend on target_flags.  */\n+#ifdef __big_endian__\n+#define LIBGCC2_WORDS_BIG_ENDIAN 1\n+#else\n+#define LIBGCC2_WORDS_BIG_ENDIAN 0\n+#endif\n+\n+/* Number of bits in an addressable storage unit.  */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Define this macro if it is advisable to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases, \n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.  */\n+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE) \\\n+if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+    && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\\\n+{\t\t\t\t\t\t\\\n+  (MODE) = SImode;\t\t\t\t\\\n+}\n+\n+/* Define this macro if the promotion described by `PROMOTE_MODE'\n+   should also be done for outgoing function arguments.  */\n+#define PROMOTE_FUNCTION_ARGS\n+\n+/* Likewise, if the function return value is promoted.  */\n+#define PROMOTE_FUNCTION_RETURN\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 64\n+\n+/* ALIGN FRAMES on word boundaries */\n+#define ARC_STACK_ALIGN(LOC) (((LOC)+7) & ~7)\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* No data type wants to be aligned rounder than this.  */\n+/* This is bigger than currently necessary for the ARC.  If 8 byte floats are\n+   ever added it's not clear whether they'll need such alignment or not.  For\n+   now we assume they will.  We can always relax it if necessary but the\n+   reverse isn't true.  */\n+#define BIGGEST_ALIGNMENT 64\n+\n+/* The best alignment to use in cases where we have a choice.  */\n+#define FASTEST_ALIGNMENT 32\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  ((TREE_CODE (EXP) == STRING_CST\t\\\n+    && (ALIGN) < FASTEST_ALIGNMENT)\t\\\n+   ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Set this nonzero if move instructions will actually fail to work\n+   when given unaligned data.  */\n+/* On the ARC the lower address bits are masked to 0 as necessary.  The chip\n+   won't croak when given an unaligned address, but the insn will still fail\n+   to produce the correct result.  */\n+#define STRICT_ALIGNMENT 1\n+\f\n+/* Layout of source language data types.  */\n+\n+#define SHORT_TYPE_SIZE\t\t16\n+#define INT_TYPE_SIZE\t\t32\n+#define LONG_TYPE_SIZE\t\t32\n+#define LONG_LONG_TYPE_SIZE\t64\n+#define FLOAT_TYPE_SIZE\t\t32\n+#define DOUBLE_TYPE_SIZE\t64\n+#define LONG_DOUBLE_TYPE_SIZE\t64\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+#define SIZE_TYPE \"long unsigned int\"\n+#define PTRDIFF_TYPE \"long int\"\n+#define WCHAR_TYPE \"short unsigned int\"\n+#define WCHAR_TYPE_SIZE 16\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.  */\n+/* Registers 61, 62, and 63 are not really registers and we needn't treat\n+   them as such.  We still need a register for the condition code.  */\n+#define FIRST_PSEUDO_REGISTER 62\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+\n+   0-28  - general purpose registers\n+   29    - ilink1 (interrupt link register)\n+   30    - ilink2 (interrupt link register)\n+   31    - blink (branch link register)\n+   32-59 - reserved for extensions\n+   60    - LP_COUNT\n+   61    - condition code\n+\n+   For doc purposes:\n+   61    - short immediate data indicator (setting flags)\n+   62    - long immediate data indicator\n+   63    - short immediate data indicator (not setting flags).\n+\n+   The general purpose registers are further broken down into:\n+   0-7   - arguments/results\n+   8-15  - call used\n+   16-23 - call saved\n+   24    - call used, static chain pointer\n+   25    - call used, gptmp\n+   26    - global pointer\n+   27    - frame pointer\n+   28    - stack pointer\n+\n+   By default, the extension registers are not available.  */\n+\n+#define FIXED_REGISTERS \\\n+{ 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  0, 0, 0, 1, 1, 1, 1, 0,\t\\\n+\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1 }\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+\n+#define CALL_USED_REGISTERS \\\n+{ 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+  1, 1, 1, 1, 1, 1 }\n+\n+/* If defined, an initializer for a vector of integers, containing the\n+   numbers of hard registers in the order in which GNU CC should\n+   prefer to use them (from most preferred to least).  */\n+#define REG_ALLOC_ORDER \\\n+{ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1,\t\t\t\\\n+  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 31,\t\t\t\\\n+  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\t\\\n+  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\t\t\\\n+  27, 28, 29, 30 }\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE) \\\n+((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n+extern unsigned int arc_hard_regno_mode_ok[];\n+extern unsigned int arc_mode_class[];\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+((arc_hard_regno_mode_ok[REGNO] & arc_mode_class[MODE]) != 0)\n+\n+/* A C expression that is nonzero if it is desirable to choose\n+   register allocation so as to avoid move instructions between a\n+   value of mode MODE1 and a value of mode MODE2.\n+\n+   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R,\n+   MODE2)' are ever different for any R, then `MODES_TIEABLE_P (MODE1,\n+   MODE2)' must be zero.  */\n+\n+/* Tie QI/HI/SI modes together.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+(GET_MODE_CLASS (MODE1) == MODE_INT\t\t\\\n+ && GET_MODE_CLASS (MODE2) == MODE_INT\t\t\\\n+ && GET_MODE_SIZE (MODE1) <= UNITS_PER_WORD\t\\\n+ && GET_MODE_SIZE (MODE2) <= UNITS_PER_WORD)\n+\f\n+/* Register classes and constants.  */\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.\n+\n+   It is important that any condition codes have class NO_REGS.\n+   See `register_operand'.  */\n+\n+enum reg_class {\n+  NO_REGS, LPCOUNT_REG, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+#define REG_CLASS_NAMES \\\n+{ \"NO_REGS\", \"LPCOUNT_REG\", \"GENERAL_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS \\\n+{ {0, 0}, {0, 0x10000000}, {0xffffffff, 0xfffffff}, \\\n+  {0xffffffff, 0x1fffffff} }\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+extern enum reg_class arc_regno_reg_class[];\n+#define REGNO_REG_CLASS(REGNO) \\\n+(arc_regno_reg_class[REGNO])\n+\n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS GENERAL_REGS\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+#define REG_CLASS_FROM_LETTER(C) \\\n+((C) == 'l' ? LPCOUNT_REG /* ??? needed? */ \\\n+ : NO_REGS)\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n+((REGNO) < 29 || (unsigned) reg_renumber[REGNO] < 29)\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n+((REGNO) < 29 || (unsigned) reg_renumber[REGNO] < 29)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+#define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n+(CLASS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE) \\\n+((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* The letters I, J, K, L, M, N, O, P in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.  */\n+/* 'I' is used for short immediates (always signed).\n+   'J' is used for long immediates.\n+   'K' is used for any constant up to 64 bits (for 64x32 situations?).  */\n+\n+/* local to this file */\n+#define SMALL_INT(X) ((unsigned) ((X) + 0x100) < 0x200)\n+/* local to this file */\n+#define LARGE_INT(X) \\\n+((X) >= (-(HOST_WIDE_INT) 0x7fffffff - 1) \\\n+ && (X) <= (unsigned HOST_WIDE_INT) 0xffffffff)\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n+((C) == 'I' ? SMALL_INT (VALUE)\t\t\\\n+ : (C) == 'J' ? LARGE_INT (VALUE)\t\\\n+ : (C) == 'K' ? 1\t\t\t\\\n+ : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+/* 'G' is used for integer values for the multiplication insns where the\n+   operands are extended from 4 bytes to 8 bytes.\n+   'H' is used when any 64 bit constant is allowed.  */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n+((C) == 'G' ? arc_double_limm_p (VALUE) \\\n+ : (C) == 'H' ? 1 \\\n+ : 0)\n+\n+/* A C expression that defines the optional machine-dependent constraint\n+   letters that can be used to segregate specific types of operands,\n+   usually memory references, for the target machine.  It should return 1 if\n+   VALUE corresponds to the operand type represented by the constraint letter\n+   C.  If C is not defined as an extra constraint, the value returned should\n+   be 0 regardless of VALUE.  */\n+/* ??? This currently isn't used.  Waiting for PIC.  */\n+#if 0\n+#define EXTRA_CONSTRAINT(VALUE, C) \\\n+((C) == 'R' ? (SYMBOL_REF_FLAG (VALUE) || GET_CODE (VALUE) == LABEL_REF) \\\n+ : 0)\n+#endif\n+\f\n+/* Stack layout and stack pointer usage.  */\n+\n+/* Define this macro if pushing a word onto the stack moves the stack\n+   pointer to a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* Offset from the stack pointer register to the first location at which\n+   outgoing arguments are placed.  */\n+#define STACK_POINTER_OFFSET FIRST_PARM_OFFSET (0)\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+/* 4 bytes for each of previous fp, return address, and previous gp.\n+   4 byte reserved area for future considerations.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 16\n+\n+/* A C expression whose value is RTL representing the address in a\n+   stack frame where the pointer to the caller's frame is stored.\n+   Assume that FRAMEADDR is an RTL expression for the address of the\n+   stack frame itself.\n+\n+   If you don't define this macro, the default is to return the value\n+   of FRAMEADDR--that is, the stack frame address is also the address\n+   of the stack word that points to the previous frame.  */\n+/* FIXME: unfinished */\n+/*define DYNAMIC_CHAIN_ADDRESS (FRAMEADDR)*/\n+\n+/* A C expression whose value is RTL representing the value of the\n+   return address for the frame COUNT steps up from the current frame.\n+   FRAMEADDR is the frame pointer of the COUNT frame, or the frame\n+   pointer of the COUNT - 1 frame if `RETURN_ADDR_IN_PREVIOUS_FRAME'\n+   is defined.  */\n+/* The current return address is in r31.  The return address of anything\n+   farther back is at [%fp,4].  */\n+#if 0 /* The default value should work.  */\n+#define RETURN_ADDR_RTX(COUNT, FRAME) \\\n+(((COUNT) == -1)\t\t\t\t\\\n+ ? gen_rtx (REG, Pmode, 31)\t\t\t\\\n+ : copy_to_reg (gen_rtx (MEM, Pmode,\t\t\\\n+\t\t\t memory_address (Pmode, plus_constant ((FRAME), UNITS_PER_WORD)))))\n+#endif\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 28\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 27\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM\n+\n+/* Register in which static-chain is passed to a function.  This must\n+   not be a register used by the prologue.  */\n+#define STATIC_CHAIN_REGNUM 24\n+\n+/* A C expression which is nonzero if a function must have and use a\n+   frame pointer.  This expression is evaluated in the reload pass.\n+   If its value is nonzero the function will have a frame pointer.  */\n+#define FRAME_POINTER_REQUIRED \\\n+(current_function_calls_alloca)\n+\n+/* C statement to store the difference between the frame pointer\n+   and the stack pointer values immediately after the function prologue.  */\n+#define INITIAL_FRAME_POINTER_OFFSET(VAR) \\\n+((VAR) = arc_compute_frame_size (get_frame_size ()))\n+\f\n+/* Function argument passing.  */\n+\n+/* When a prototype says `char' or `short', really pass an `int'.  */\n+#define PROMOTE_PROTOTYPES\n+\n+/* If defined, the maximum amount of space required for outgoing\n+   arguments will be computed and placed into the variable\n+   `current_function_outgoing_args_size'.  No space will be pushed\n+   onto the stack for each call; instead, the function prologue should\n+   increase the stack frame size by this amount.  */\n+#define ACCUMULATE_OUTGOING_ARGS\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNDECL is the declaration node of the function (as a tree),\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.  */\n+#define RETURN_POPS_ARGS(DECL, FUNTYPE, SIZE) 0\n+\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.  */\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.  */\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT) \\\n+((CUM) = 0)\n+\n+/* The number of registers used for parameter passing.  Local to this file.  */\n+#define MAX_ARC_PARM_REGS 8\n+\n+/* 1 if N is a possible register number for function argument passing.  */\n+#define FUNCTION_ARG_REGNO_P(N) \\\n+((unsigned) (N) < MAX_ARC_PARM_REGS)\n+\n+/* The ROUND_ADVANCE* macros are local to this file.  */\n+/* Round SIZE up to a word boundary.  */\n+#define ROUND_ADVANCE(SIZE) \\\n+(((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Round arg MODE/TYPE up to the next word boundary.  */\n+#define ROUND_ADVANCE_ARG(MODE, TYPE) \\\n+((MODE) == BLKmode\t\t\t\t\\\n+ ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\\\n+ : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))\n+\n+/* Round CUM up to the necessary point for argument MODE/TYPE.  */\n+#define ROUND_ADVANCE_CUM(CUM, MODE, TYPE) \\\n+((((MODE) == BLKmode ? TYPE_ALIGN (TYPE) : GET_MODE_BITSIZE (MODE)) \\\n+  > BITS_PER_WORD)\t\\\n+ ? ((CUM) + 1 & ~1)\t\\\n+ : (CUM))\n+\n+/* Return boolean indicating arg of type TYPE and mode MODE will be passed in\n+   a reg.  This includes arguments that have to be passed by reference as the\n+   pointer to them is passed in a reg if one is available (and that is what\n+   we're given).\n+   When passing arguments NAMED is always 1.  When receiving arguments NAMED\n+   is 1 for each argument except the last in a stdarg/varargs function.  In\n+   a stdarg function we want to treat the last named arg as named.  In a\n+   varargs function we want to treat the last named arg (which is\n+   `__builtin_va_alist') as unnamed.\n+   This macro is only used in this file.  */\n+extern int current_function_varargs;\n+#define PASS_IN_REG_P(CUM, MODE, TYPE, NAMED) \\\n+((!current_function_varargs || (NAMED))\t\t\t\t\t\\\n+ && (CUM) < MAX_ARC_PARM_REGS\t\t\t\t\t\t\\\n+ && ((ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE))\t\t\t\t\\\n+      + ROUND_ADVANCE_ARG ((MODE), (TYPE))\t\t\t\t\\\n+      <= MAX_ARC_PARM_REGS)))\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+/* On the ARC the first MAX_ARC_PARM_REGS args are normally in registers\n+   and the rest are pushed.  */\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+(PASS_IN_REG_P ((CUM), (MODE), (TYPE), (NAMED))\t\t\t\t\\\n+ ? gen_rtx (REG, (MODE), ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)))\t\\\n+ : 0)\n+\n+/* A C expression for the number of words, at the beginning of an\n+   argument, must be put in registers.  The value must be zero for\n+   arguments that are passed entirely in registers or that are entirely\n+   pushed on the stack.\n+\n+   On some machines, certain arguments must be passed partially in\n+   registers and partially in memory.  On these machines, typically the\n+   first @var{n} words of arguments are passed in registers, and the rest\n+   on the stack.  If a multi-word argument (a @code{double} or a\n+   structure) crosses that boundary, its first few words must be passed\n+   in registers and the rest must be pushed.  This macro tells the\n+   compiler when this occurs, and how many of the words should go in\n+   registers.  */\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n+\n+/* A C expression that indicates when an argument must be passed by\n+   reference.  If nonzero for an argument, a copy of that argument is\n+   made in memory and a pointer to the argument is passed instead of\n+   the argument itself.  The pointer is passed in whatever way is\n+   appropriate for passing a pointer to that type.  */\n+/* All aggregates and arguments greater than 8 bytes are passed this way.  */\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n+(TYPE\t\t\t\t\t\\\n+ && (AGGREGATE_TYPE_P (TYPE)\t\t\\\n+     || int_size_in_bytes (TYPE) > 8))\n+\n+/* A C expression that indicates when it is the called function's\n+   responsibility to make copies of arguments passed by reference.\n+   If the callee can determine that the argument won't be modified, it can\n+   avoid the copy.  */\n+/* ??? We'd love to be able to use NAMED here.  Unfortunately, it doesn't\n+   include the last named argument so we keep track of the args ourselves.  */\n+\n+#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \\\n+FUNCTION_ARG_PASS_BY_REFERENCE ((CUM), (MODE), (TYPE), (NAMED))\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \\\n+((CUM) = (ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE)) \\\n+\t  + ROUND_ADVANCE_ARG ((MODE), (TYPE))))\n+\n+/* If defined, a C expression that gives the alignment boundary, in bits,\n+   of an argument with the specified mode and type.  If it is not defined, \n+   PARM_BOUNDARY is used for all arguments.  */\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n+(((TYPE) ? TYPE_ALIGN (TYPE) : GET_MODE_BITSIZE (MODE)) <= PARM_BOUNDARY \\\n+ ? PARM_BOUNDARY \\\n+ : 2 * PARM_BOUNDARY)\n+\n+/* This macro offers an alternative\n+   to using `__builtin_saveregs' and defining the macro\n+   `EXPAND_BUILTIN_SAVEREGS'.  Use it to store the anonymous register\n+   arguments into the stack so that all the arguments appear to have\n+   been passed consecutively on the stack.  Once this is done, you\n+   can use the standard implementation of varargs that works for\n+   machines that pass all their arguments on the stack.\n+\n+   The argument ARGS_SO_FAR is the `CUMULATIVE_ARGS' data structure,\n+   containing the values that obtain after processing of the named\n+   arguments.  The arguments MODE and TYPE describe the last named\n+   argument--its machine mode and its data type as a tree node.\n+\n+   The macro implementation should do two things: first, push onto the\n+   stack all the argument registers *not* used for the named\n+   arguments, and second, store the size of the data thus pushed into\n+   the `int'-valued variable whose name is supplied as the argument\n+   PRETEND_SIZE.  The value that you store here will serve as\n+   additional offset for setting up the stack frame.\n+\n+   If the argument NO_RTL is nonzero, it means that the\n+   arguments of the function are being analyzed for the second time.\n+   This happens for an inline function, which is not actually\n+   compiled until the end of the source file.  The macro\n+   `SETUP_INCOMING_VARARGS' should not generate any instructions in\n+   this case.  */\n+\n+#define SETUP_INCOMING_VARARGS(ARGS_SO_FAR, MODE, TYPE, PRETEND_SIZE, NO_RTL) \\\n+arc_setup_incoming_varargs(&ARGS_SO_FAR, MODE, TYPE, &PRETEND_SIZE, NO_RTL)\n+\f\n+/* Function results.  */\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+#define FUNCTION_VALUE(VALTYPE, FUNC) gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+#define LIBCALL_VALUE(MODE) gen_rtx (REG, MODE, 0)\n+\n+/* 1 if N is a possible register number for a function value\n+   as seen by the caller.  */\n+/* ??? What about r1 in DI/DF values.  */\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n+\n+/* A C expression which can inhibit the returning of certain function\n+   values in registers, based on the type of value.  A nonzero value says\n+   to return the function value in memory, just as large structures are\n+   always returned.  Here TYPE will be a C expression of type `tree',\n+   representing the data type of the value.  */\n+#define RETURN_IN_MEMORY(TYPE) \\\n+(AGGREGATE_TYPE_P (TYPE) \\\n+ || int_size_in_bytes (TYPE) > 8 \\\n+ || TREE_ADDRESSABLE (TYPE))\n+\n+/* Tell GCC to use RETURN_IN_MEMORY.  */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/* Register in which address to store a structure value\n+   is passed to a function, or 0 to use `invisible' first argument.  */\n+#define STRUCT_VALUE 0\n+\f\n+/* Function entry and exit.  */\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n+arc_output_function_prologue (FILE, SIZE)\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+#define EXIT_IGNORE_STACK 0\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n+arc_output_function_epilogue (FILE, SIZE)\n+\n+/* Epilogue delay slots.  */\n+#define DELAY_SLOTS_FOR_EPILOGUE arc_delay_slots_for_epilogue ()\n+\n+#define ELIGIBLE_FOR_EPILOGUE_DELAY(TRIAL, SLOTS_FILLED) \\\n+arc_eligible_for_epilogue_delay (TRIAL, SLOTS_FILLED)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+#define FUNCTION_PROFILER(FILE, LABELNO)\n+\f\n+/* Trampolines.  */\n+/* ??? This doesn't work yet because GCC will use as the address of a nested\n+   function the address of the trampoline.  We need to use that address\n+   right shifted by 2.  It looks like we'll need PSImode after all. :-(  */\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+/* On the ARC, the trampoline is quite simple as we have 32 bit immediate\n+   constants.\n+\n+\tmov r24,STATIC\n+\tj.nd FUNCTION\n+*/\n+#define TRAMPOLINE_TEMPLATE(FILE) \\\n+do { \\\n+  ASM_OUTPUT_INT (FILE, GEN_INT (0x631f7c00)); \\\n+  ASM_OUTPUT_INT (FILE, const0_rtx); \\\n+  ASM_OUTPUT_INT (FILE, GEN_INT (0x381f0000)); \\\n+  ASM_OUTPUT_INT (FILE, const0_rtx); \\\n+} while (0)\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+#define TRAMPOLINE_SIZE 16\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n+do { \\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 4)), CXT); \\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 12)), FNADDR); \\\n+  emit_insn (gen_flush_icache (validize_mem (gen_rtx (MEM, SImode, TRAMP)))); \\\n+} while (0)\n+\f\n+/* Library calls.  */\n+\n+/* Generate calls to memcpy, memcmp and memset.  */\n+#define TARGET_MEM_FUNCTIONS\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+/* The `ld' insn allows 2, but the `st' insn only allows 1.  */\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* We have pre inc/dec (load/store with update).  */\n+#define HAVE_PRE_INCREMENT\n+#define HAVE_PRE_DECREMENT\n+\n+/* Recognize any constant value that is a valid address.  */\n+#define CONSTANT_ADDRESS_P(X) \\\n+(GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\\\n+ || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   We can handle any 32 or 64 bit constant.  */\n+/* \"1\" should work since the largest constant should be a 64 bit critter.  */\n+/* ??? Not sure what to do for 64x32 compiler.  */\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) \\\n+((unsigned) REGNO (X) - 29 >= FIRST_PSEUDO_REGISTER - 29)\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) \\\n+((unsigned) REGNO (X) - 29 >= FIRST_PSEUDO_REGISTER - 29)\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.  */\n+/* The `ld' insn allows [reg],[reg+shimm],[reg+limm],[reg+reg],[limm]\n+   but the `st' insn only allows [reg],[reg+shimm],[limm].\n+   The only thing we can do is only allow the most strict case `st' and hope\n+   other parts optimize out the restrictions for `ld'.  */\n+\n+/* local to this file */\n+#define RTX_OK_FOR_BASE_P(X) \\\n+(REG_P (X) && REG_OK_FOR_BASE_P (X))\n+\n+/* local to this file */\n+#define RTX_OK_FOR_INDEX_P(X) \\\n+(0 && /*FIXME*/ REG_P (X) && REG_OK_FOR_INDEX_P (X))\n+\n+/* local to this file */\n+/* ??? Loads can handle any constant, stores can only handle small ones.  */\n+#define RTX_OK_FOR_OFFSET_P(X) \\\n+(GET_CODE (X) == CONST_INT && SMALL_INT (INTVAL (X)))\n+\n+#define LEGITIMATE_OFFSET_ADDRESS_P(MODE, X) \\\n+(GET_CODE (X) == PLUS\t\t\t\t\\\n+ && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\\\n+ && (RTX_OK_FOR_INDEX_P (XEXP (X, 1))\t\t\\\n+     || RTX_OK_FOR_OFFSET_P (XEXP (X, 1))))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n+{ if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  if (LEGITIMATE_OFFSET_ADDRESS_P ((MODE), (X)))\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == CONST_INT && LARGE_INT (INTVAL (X))) \\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == SYMBOL_REF\t\t\t\\\n+\t   || GET_CODE (X) == LABEL_REF\t\t\t\\\n+\t   || GET_CODE (X) == CONST)\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+  if ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == PRE_INC) \\\n+      /* We're restricted here by the `st' insn.  */\t\\\n+      && RTX_OK_FOR_BASE_P (XEXP ((X), 0)))\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\\\n+}\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.  */\n+\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.  */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL) \\\n+{ if (GET_CODE (ADDR) == PRE_DEC)\t\\\n+    goto LABEL;\t\t\t\t\\\n+  if (GET_CODE (ADDR) == PRE_INC)\t\\\n+    goto LABEL;\t\t\t\t\\\n+}\n+\f\n+/* Condition code usage.  */\n+\n+/* Some insns set all condition code flags, some only set the ZNC flags, and\n+   some only set the ZN flags.  */\n+\n+#define EXTRA_CC_MODES CCZNCmode, CCZNmode\n+\n+#define EXTRA_CC_NAMES \"CCZNC\", \"CCZN\"\n+\n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison.  */\n+extern enum machine_mode arc_select_cc_mode ();\n+#define SELECT_CC_MODE(OP, X, Y) \\\n+arc_select_cc_mode (OP, X, Y)\n+\n+/* Return non-zero if SELECT_CC_MODE will never return MODE for a\n+   floating point inequality comparison.  */\n+#define REVERSIBLE_CC_MODE(MODE) 1 /*FIXME*/\n+\f\n+/* Costs.  */\n+\n+/* An insn is define to cost 4 \"units\", and we work from there.\n+   COSTS_N_INSNS (N) is defined as (N) * 4 - 2 so that seems reasonable.\n+   Some values are supposed to be defined relative to each other and thus\n+   aren't necessarily related to COSTS_N_INSNS.  */\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+/* Small integers are as cheap as registers.  4 byte values can be fetched\n+   as immediate constants - let's give that the cost of an extra insn. */\n+#define CONST_COSTS(X, CODE, OUTER_CODE) \\\n+  case CONST_INT :\t\t\t\t\t\t\\\n+    if (SMALL_INT (INTVAL (X)))\t\t\t\t\t\\\n+      return 0;\t\t\t\t\t\t\t\\\n+    /* fall through */\t\t\t\t\t\t\\\n+  case CONST :\t\t\t\t\t\t\t\\\n+  case LABEL_REF :\t\t\t\t\t\t\\\n+  case SYMBOL_REF :\t\t\t\t\t\t\\\n+    return 4;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE :\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      rtx high, low;\t\t\t\t\t\t\\\n+      split_double (X, &high, &low);\t\t\t\t\\\n+      return 4 * (!SMALL_INT (INTVAL (high))\t\t\t\\\n+\t\t  + !SMALL_INT (INTVAL (low)));\t\t\t\\\n+    }\n+\n+/* Compute the cost of an address.  */\n+#define ADDRESS_COST(ADDR) (REG_P (ADDR) ? 1 : arc_address_cost (ADDR))\n+\n+/* Compute extra cost of moving data between one register class\n+   and another.  */\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2) 2\n+\n+/* Compute the cost of moving data between registers and memory.  */\n+/* Memory is 3 times as expensive as registers.\n+   ??? Is that the right way to look at it?  */\n+#define MEMORY_MOVE_COST(MODE) \\\n+(GET_MODE_SIZE (MODE) <= UNITS_PER_WORD ? 6 : 12)\n+\n+/* The cost of a branch insn.  */\n+/* ??? What's the right value here?  Branches are certainly more\n+   expensive than reg->reg moves.  */\n+#define BRANCH_COST 2\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE.  The purpose for the cost of MULT is to encourage\n+   `synth_mult' to find a synthetic multiply when reasonable.\n+\n+   If we need more than 12 insns to do a multiply, then go out-of-line,\n+   since the call overhead will be < 10% of the cost of the multiply.  */\n+#define RTX_COSTS(X, CODE, OUTER_CODE) \\\n+  case ASHIFT :\t\t\t\t\t\t\\\n+  case ASHIFTRT :\t\t\t\t\t\\\n+  case LSHIFTRT :\t\t\t\t\t\\\n+    if (TARGET_SHIFTER)\t\t\t\t\t\\\n+      return COSTS_N_INSNS (1);\t\t\t\t\\\n+    if (GET_CODE (XEXP ((X), 1)) != CONST_INT)\t\t\\\n+      return COSTS_N_INSNS (16);\t\t\t\\\n+    return COSTS_N_INSNS (INTVAL (XEXP ((X), 1)));\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.\n+   For RISC chips, it means that access to memory by bytes is no\n+   better than access by words when possible, so grab a whole word\n+   and maybe make use of that.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Define this macro if it is as good or better to call a constant\n+   function address than to call an address kept in a register.  */\n+/* On the ARC, calling through registers is slow.  */\n+#define NO_FUNCTION_CSE\n+\n+/* Define this macro if it is as good or better for a function to call\n+   itself with an explicit address than to call an address kept in a\n+   register.  */\n+/* On the ARC, calling through registers is slow.  */\n+#define NO_RECURSIVE_FUNCTION_CSE\n+\f\n+/* Section selection.  */\n+/* WARNING: These section names also appear in dwarfout.c.  */\n+\n+/* The names of the text, data, and readonly-data sections are runtime\n+   selectable.  */\n+\n+#define ARC_SECTION_FORMAT\t\t\"\\t.section %s\"\n+#define ARC_DEFAULT_TEXT_SECTION\t\".text\"\n+#define ARC_DEFAULT_DATA_SECTION\t\".data\"\n+#define ARC_DEFAULT_RODATA_SECTION\t\".rodata\"\n+\n+extern char *arc_text_section,*arc_data_section,*arc_rodata_section;\n+\n+/* initfini.c uses this in an asm.  */\n+#if defined (CRT_INIT) || defined (CRT_FINI)\n+#define TEXT_SECTION_ASM_OP\t\"\\t.section .text\"\n+#else\n+#define TEXT_SECTION_ASM_OP\tarc_text_section /*\"\\t.section .text\"*/\n+#endif\n+#define DATA_SECTION_ASM_OP\tarc_data_section /*\"\\t.section .data\"*/\n+\n+#undef CONST_SECTION_ASM_OP\n+#define CONST_SECTION_ASM_OP\tarc_rodata_section /*\"\\t.section .rodata\"*/\n+\n+#define BSS_SECTION_ASM_OP\t\"\\t.section .bss\"\n+\n+/* Define this macro if jump tables (for tablejump insns) should be\n+   output in the text section, along with the assembler instructions.\n+   Otherwise, the readonly data section is used.\n+   This macro is irrelevant if there is no separate readonly data section.  */\n+/*#define JUMP_TABLES_IN_TEXT_SECTION*/\n+\n+/* Define this macro if references to a symbol must be treated\n+   differently depending on something about the variable or\n+   function named by the symbol (such as what section it is in).\n+\n+   The macro definition, if any, is executed immediately after the\n+   rtl for DECL or other node is created.\n+   The value of the rtl will be a `mem' whose address is a\n+   `symbol_ref'.\n+\n+   The usual thing for this macro to do is to store a flag in the\n+   `symbol_ref' (such as `SYMBOL_REF_FLAG') or to store a modified\n+   name string in the `symbol_ref' (if one bit is not enough\n+   information).  */\n+\n+/* On the ARC, function addresses are not the same as normal addresses.\n+   Branch to absolute address insns take an address that is right-shifted\n+   by 2.  We encode the fact that we have a function here, and then emit a\n+   special assembler op when outputting the address.  */\n+#define ENCODE_SECTION_INFO(DECL) \\\n+do {\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n+    SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\t\\\n+} while (0)\n+\n+/* Decode SYM_NAME and store the real name part in VAR, sans\n+   the characters that encode section info.  Define this macro if\n+   ENCODE_SECTION_INFO alters the symbol's name string.  */\n+/*#define STRIP_NAME_ENCODING(VAR, SYM_NAME)*/\n+\n+/* For DWARF.  Marginally different than default so output is \"prettier\"\n+   (and consistent with above).  */\n+#define PUSHSECTION_FORMAT \"\\t%s %s\\n\"\n+\n+/* Tell crtstuff.c we're using ELF.  */\n+#define OBJECT_FORMAT_ELF\n+\f\n+/* PIC */\n+\n+/* The register number of the register used to address a table of static\n+   data addresses in memory.  In some cases this register is defined by a\n+   processor's ``application binary interface'' (ABI).  When this macro\n+   is defined, RTL is generated for this register once, as with the stack\n+   pointer and frame pointer registers.  If this macro is not defined, it\n+   is up to the machine-dependent files to allocate such a register (if\n+   necessary).  */\n+#define PIC_OFFSET_TABLE_REGNUM 26\n+\n+/* Define this macro if the register defined by PIC_OFFSET_TABLE_REGNUM is\n+   clobbered by calls.  Do not define this macro if PIC_OFFSET_TABLE_REGNUM\n+   is not defined.  */\n+/* This register is call-saved on the ARC.  */\n+/*#define PIC_OFFSET_TABLE_REG_CALL_CLOBBERED*/\n+\n+/* By generating position-independent code, when two different programs (A\n+   and B) share a common library (libC.a), the text of the library can be\n+   shared whether or not the library is linked at the same address for both\n+   programs.  In some of these environments, position-independent code\n+   requires not only the use of different addressing modes, but also\n+   special code to enable the use of these addressing modes.\n+\n+   The FINALIZE_PIC macro serves as a hook to emit these special\n+   codes once the function is being compiled into assembly code, but not\n+   before.  (It is not done before, because in the case of compiling an\n+   inline function, it would lead to multiple PIC prologues being\n+   included in functions which used inline functions and were compiled to\n+   assembly language.)  */\n+\n+#define INITIALIZE_PIC arc_initialize_pic ()\n+#define FINALIZE_PIC arc_finalize_pic ()\n+\n+/* A C expression that is nonzero if X is a legitimate immediate\n+   operand on the target machine when generating position independent code.\n+   You can assume that X satisfies CONSTANT_P, so you need not\n+   check this.  You can also assume `flag_pic' is true, so you need not\n+   check it either.  You need not define this macro if all constants\n+   (including SYMBOL_REF) can be immediate operands when generating\n+   position independent code.  */\n+/*#define LEGITIMATE_PIC_OPERAND_P(X)*/\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.  */\n+extern void arc_asm_file_start ();\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE) arc_asm_file_start (FILE)\n+\n+/* A C statement to output assembler commands which will identify the\n+   object file as having been compiled with GNU CC (or another GNU\n+   compiler).  */\n+#undef ASM_IDENTIFY_GCC\n+#define ASM_IDENTIFY_GCC(FILE) /* nothing */\n+\n+/* Needed because we define ASM_IDENTIFY_GCC.  */\n+#define ASM_IDENTIFY_LANGUAGE(FILE) output_lang_identify (FILE)\n+\n+/* A C string constant describing how to begin a comment in the target\n+   assembler language.  The compiler assumes that the comment will\n+   end at the end of the line.  */\n+#define ASM_COMMENT_START \";\"\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+#define ASM_APP_ON \"\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+#define ASM_APP_OFF \"\"\n+\n+/* This is how to output an assembler line defining a `char' constant.  */\n+#define ASM_OUTPUT_CHAR(FILE, VALUE) \\\n+( fprintf (FILE, \"\\t.byte\\t\"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line defining a `short' constant.  */\n+#define ASM_OUTPUT_SHORT(FILE, VALUE) \\\n+( fprintf (FILE, \"\\t.hword\\t\"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line defining an `int' constant.\n+   We also handle symbol output here.  Code addresses must be right shifted\n+   by 2 because that's how the jump instruction wants them.  */\n+#define ASM_OUTPUT_INT(FILE, VALUE) \\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\t\t\\\n+  if ((GET_CODE (VALUE) == SYMBOL_REF && SYMBOL_REF_FLAG (VALUE))\t\\\n+      || GET_CODE (VALUE) == LABEL_REF)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"%%st(\");\t\t\t\t\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\t\t\t\\\n+      fprintf (FILE, \")\");\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    output_addr_const (FILE, (VALUE));\t\t\t\t\t\\\n+  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+#define ASM_OUTPUT_FLOAT(FILE, VALUE) \\\n+{\t\t\t\t\t\t\t\\\n+  long t;\t\t\t\t\t\t\\\n+  char str[30];\t\t\t\t\t\t\\\n+  REAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\\\n+  REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\\\n+  fprintf (FILE, \"\\t.word\\t0x%lx %s %s\\n\",\t\t\\\n+\t   t, ASM_COMMENT_START, str);\t\t\t\\\n+}\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+#define ASM_OUTPUT_DOUBLE(FILE, VALUE) \\\n+{\t\t\t\t\t\t\t\\\n+  long t[2];\t\t\t\t\t\t\\\n+  char str[30];\t\t\t\t\t\t\\\n+  REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\\\n+  REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\\\n+  fprintf (FILE, \"\\t.word\\t0x%lx %s %s\\n\\t.word\\t0x%lx\\n\", \\\n+\t   t[0], ASM_COMMENT_START, str, t[1]);\t\t\\\n+}\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+#define ASM_BYTE_OP\t\".byte\"\n+#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t%s\\t0x%x\\n\", ASM_BYTE_OP, (VALUE))\n+\n+/* The assembler's parentheses characters.  */\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+#define ASM_OUTPUT_LABEL(FILE, NAME) \\\n+do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+#define ASM_GLOBALIZE_LABEL(FILE, NAME) \\\n+do {\t\t\t\t\\\n+  fputs (\"\\t.global\\t\", FILE);\t\\\n+  assemble_name (FILE, NAME);\t\\\n+  fputs (\"\\n\", FILE);\t\t\\\n+} while (0)\n+\n+/* A C statement (sans semicolon) to output on FILE an assembler pseudo-op to\n+   declare a library function name external.  The name of the library function\n+   is given by SYMREF, which has type RTX and is a SYMBOL_REF.  */\n+#if 0\n+/* On the ARC we want to have libgcc's for multiple cpus in one binary.\n+   We can't use `assemble_name' here as that will call ASM_OUTPUT_LABELREF\n+   and we'll get another suffix added on if -mmangle-cpu.  */\n+extern char *arc_mangle_cpu;\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, SYMREF) \\\n+do {\t\t\t\t\t\t\t\\\n+  if (TARGET_MANGLE_CPU_LIBGCC)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.rename\\t_%s, _%s%s\\n\",\t\t\\\n+\t       XSTR (SYMREF, 0), XSTR (SYMREF, 0),\t\\\n+\t       arc_mangle_suffix);\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+} while (0)\n+#endif\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+/* We mangle all user labels to provide protection from linking code\n+   compiled for different cpus.  */\n+/* We work around a dwarfout.c deficiency by watching for labels from it and\n+   not adding the '_' prefix nor the cpu suffix.  There is a comment in\n+   dwarfout.c that says it should be using ASM_OUTPUT_INTERNAL_LABEL.  */\n+extern char *arc_mangle_cpu;\n+#define ASM_OUTPUT_LABELREF(FILE, NAME) \\\n+do {\t\t\t\t\t\t\t\\\n+  if ((NAME)[0] == '.' && (NAME)[1] == 'L')\t\t\\\n+    fprintf (FILE, \"%s\", NAME);\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fputc ('_', FILE);\t\t\t\t\\\n+      if (TARGET_MANGLE_CPU && arc_mangle_cpu != NULL)\t\\\n+\tfprintf (FILE, \"%s_\", arc_mangle_cpu);\t\t\\\n+      fprintf (FILE, \"%s\", NAME);\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to output a definition of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+#undef ASM_OUTPUT_INTERNAL_LABEL\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM) \\\n+do {\t\t\t\t\t\t\\\n+  arc_ccfsm_at_label (PREFIX, NUM);\t\t\\\n+  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM);\t\\\n+} while (0)\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO) \\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Assembler pseudo-op to equate one value with another.  */\n+/* ??? This is needed because dwarfout.c provides a default definition too\n+   late for defaults.h (which contains the default definition of ASM_OUTPUT_DEF\n+   that we use).  */\n+#define SET_ASM_OP \".set\"\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global constructors.  */\n+#undef ASM_OUTPUT_CONSTRUCTOR\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE, NAME) \\\n+do {\t\t\t\t\t\\\n+  ctors_section ();\t\t\t\\\n+  fprintf (FILE, \"\\t.word\\t%%st(\");\t\\\n+  assemble_name (FILE, NAME);\t\t\\\n+  fprintf (FILE, \")\\n\");\t\t\\\n+} while (0)\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+#undef ASM_OUTPUT_DESTRUCTOR\n+#define ASM_OUTPUT_DESTRUCTOR(FILE, NAME) \\\n+do {\t\t\t\t\t\\\n+  dtors_section ();\t\t\t\\\n+  fprintf (FILE, \"\\t.word\\t%%st(\");\t\\\n+  assemble_name (FILE, NAME);\t\t\\\n+  fprintf (FILE, \")\\n\");\t\t\\\n+} while (0)\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+#define REGISTER_NAMES \\\n+{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",\t\t\\\n+ \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n+ \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\t\\\n+ \"r24\", \"r25\", \"r26\", \"fp\", \"sp\", \"ilink1\", \"ilink2\", \"blink\",\t\\\n+ \"r32\", \"r33\", \"r34\", \"r35\", \"r36\", \"r37\", \"r38\", \"r39\",\t\\\n+ \"r40\", \"r41\", \"r42\", \"r43\", \"r44\", \"r45\", \"r46\", \"r47\",\t\\\n+ \"r48\", \"r49\", \"r50\", \"r51\", \"r52\", \"r53\", \"r54\", \"r55\",\t\\\n+ \"r56\", \"r57\", \"r58\", \"r59\", \"lp_count\", \"cc\"}\n+\n+/* Entry to the insn conditionalizer.  */\n+#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \\\n+arc_final_prescan_insn (INSN, OPVEC, NOPERANDS)\n+\n+/* A C expression which evaluates to true if CODE is a valid\n+   punctuation character for use in the `PRINT_OPERAND' macro.  */\n+extern char arc_punct_chars[];\n+#define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n+arc_punct_chars[(unsigned char) (CHAR)]\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+#define PRINT_OPERAND(FILE, X, CODE) \\\n+arc_print_operand (FILE, X, CODE)\n+\n+/* A C compound statement to output to stdio stream STREAM the\n+   assembler syntax for an instruction operand that is a memory\n+   reference whose address is ADDR.  ADDR is an RTL expression.\n+\n+   On some machines, the syntax for a symbolic address depends on\n+   the section that the address refers to.  On these machines,\n+   define the macro `ENCODE_SECTION_INFO' to store the information\n+   into the `symbol_ref', and then check for it here.  */\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) \\\n+arc_print_operand_address (FILE, ADDR)\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+do {\t\t\t\t\t\t\t\\\n+  char label[30];\t\t\t\t\t\\\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\\\n+  fprintf (FILE, \"\\t.word %%st(\");\t\t\t\\\n+  assemble_name (FILE, label);\t\t\t\t\\\n+  fprintf (FILE, \")\\n\");\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+do {\t\t\t\t\t\t\t\\\n+  char label[30];\t\t\t\t\t\\\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\\\n+  fprintf (FILE, \"\\t.word %%st(\");\t\t\t\\\n+  assemble_name (FILE, label);\t\t\t\t\\\n+  fprintf (FILE, \"-\");\t\t\t\t\t\\\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", REL);\t\\\n+  assemble_name (FILE, label);\t\t\t\t\\\n+  fprintf (FILE, \")\\n\");\t\t\t\t\\\n+} while (0)\n+\n+/* A C expression to output text to align the location counter in the way\n+   that is desirable at the beginning of a loop.  */\n+/* On the ARC, align loops to 32 byte boundaries (cache line size)\n+   if -malign-loops.  */\n+#define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n+do { if (TARGET_ALIGN_LOOPS) ASM_OUTPUT_SKIP (FILE, 5); } while (0)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+#define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n+do { if ((LOG) != 0) fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG)); } while (0)\n+\f\n+/* Debugging information.  */\n+\n+/* Generate DBX and DWARF debugging information.  */\n+#define DBX_DEBUGGING_INFO\n+#define DWARF_DEBUGGING_INFO\n+\n+/* Prefer STABS (for now).  */\n+#undef PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+/* How to renumber registers for dbx and gdb.  */\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* Turn off splitting of long stabs.  */\n+#define DBX_CONTIN_LENGTH 0\n+\f\n+/* Miscellaneous.  */\n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE Pmode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* It's not clear what PIC will look like or whether we want to use -fpic\n+   for the embedded form currently being talked about.  For now require -fpic\n+   to get pc relative switch tables.  */\n+/*#define CASE_VECTOR_PC_RELATIVE*/\n+\n+/* Define if operations between registers always perform the operation\n+   on the full register even if a narrower mode is specified.  */\n+#define WORD_REGISTER_OPERATIONS\n+\n+/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n+   will either zero-extend or sign-extend.  The value of this macro should\n+   be the code that says which one of the two operations is implicitly\n+   done, NIL if none.  */\n+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 4\n+\n+/* Define this to be nonzero if shift instructions ignore all but the low-order\n+   few bits. */\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+#define STORE_FLAG_VALUE 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+/* ??? The arc doesn't have full 32 bit pointers, but making this PSImode has\n+   it's own problems (you have to add extendpsisi2 and trucnsipsi2 but how does\n+   one do it without getting excess code?).  Try to avoid it.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction.  */\n+#define FUNCTION_MODE SImode\n+\n+/* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n+   is a valid machine specific attribute for DECL.\n+   The attributes in ATTRIBUTES have previously been assigned to TYPE.  */\n+extern int arc_valid_machine_attribute ();\n+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n+arc_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n+\n+/* A C expression that returns zero if the attributes on TYPE1 and TYPE2 are\n+   incompatible, one if they are compatible, and two if they are\n+   nearly compatible (which causes a warning to be generated).  */\n+extern int arc_comp_type_attributes ();\n+#define COMP_TYPE_ATTRIBUTES(TYPE1, TYPE2) \\\n+arc_comp_type_attributes (TYPE1, TYPE2)\n+\n+/* Give newly defined TYPE some default attributes.  */\n+extern void arc_set_default_type_attributes ();\n+#define SET_DEFAULT_TYPE_ATTRIBUTES(TYPE) \\\n+arc_set_default_type_attributes (TYPE)\n+\n+/* Define this if the target system supports the function\n+   atexit from the ANSI C standard.  If this is not defined,\n+   and INIT_SECTION_ASM_OP is not defined, a default\n+   exit function will be provided to support C++.  */\n+#define HAVE_ATEXIT\n+\n+/* alloca should avoid clobbering the old register save area.  */\n+/* ??? Not defined in tm.texi.  */\n+#define SETJMP_VIA_SAVE_AREA\n+\f\n+/* Define the information needed to generate branch and scc insns.  This is\n+   stored from the compare operation.  Note that we can't use \"rtx\" here\n+   since it hasn't been defined!  */\n+extern struct rtx_def *arc_compare_op0, *arc_compare_op1;\n+\n+/* Define the function that build the compare insn for scc and bcc.  */\n+extern struct rtx_def *gen_compare_reg ();\n+\n+/* Declarations for various fns used in the .md file.  */\n+extern char *output_shift ();\n+\n+/* ARC function types.   */\n+enum arc_function_type {\n+  ARC_FUNCTION_UNKNOWN, ARC_FUNCTION_NORMAL,\n+  /* These are interrupt handlers.  The name corresponds to the register\n+     name that contains the return address.  */\n+  ARC_FUNCTION_ILINK1, ARC_FUNCTION_ILINK2\n+};\n+#define ARC_INTERRUPT_P(TYPE) \\\n+((TYPE) == ARC_FUNCTION_ILINK1 || (TYPE) == ARC_FUNCTION_ILINK2)\n+/* Compute the type of a function from its DECL.  */\n+enum arc_function_type arc_compute_function_type ();"}]}