{"sha": "90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBhYTY3MTlhMDNjYTM3YTAxYmY5NDI0MGRiZjAyZmI0YjFlYjNlMA==", "commit": {"author": {"name": "Danny Smith", "email": "dannysmith@users.sourceforge.net", "date": "2004-06-05T07:28:27Z"}, "committer": {"name": "Danny Smith", "email": "dannysmith@gcc.gnu.org", "date": "2004-06-05T07:28:27Z"}, "message": "toplev.c (init_asm_output): Add explicit 'b' to mode when opening asm_out_file.\n\n        * toplev.c (init_asm_output): Add explicit 'b' to mode when\n        opening asm_out_file.\n        * c-pch.c (c_common_write_pch): Remove unnecessary fflush before\n        reading asm_out_file. Replace fflush after reading asm_out_file\n        with fseek.\n        * hosthooks-def.h (HOST_HOOKS_GT_PCH_ALLOC_GRANULARITY): Define\n        default and add to HOST_HOOKS_INITIALIZER.\n        * hosthooks.h (gt_pch_alloc_granularity): Declare hook function.\n        * ggc-common.c (default_gt_pch_alloc_granularity): New function.\n        (gt_pch_save): Use host_hooks.gt_pch_alloc_granularity\n        to set mmi.offset padding.\n         * config.gcc (i[34567]86-*-mingw32*): Set target_gtfiles to\n        $(srcdir)/config/i386/winnt.c.\n        (i[34567]86-*-pe | i[34567]86-*-cygwin*): Likewise.\n        (i[34567]86-*-uwin*): Likewise.\n        *i[34567]86-*-interix3*): Likewise.\n        * config.host (i[34567]86-*-mingw32*): Set out_host_hook_obj.\n        * config/i386/host-mingw32.c: New file.\n        * config/i386/x-mingw32: Add rule for host-mingw32.o.\n        * config/i386/winnt.c: (struct extern_list) Tag as GTY.\n        (extern_head): Likewise.\n        (struct export_list) Likewise.\n        (export_head): Likewise.\n        (i386_pe_record_external_function): Use ggc_alloc.\n        (i386_pe_record_exported_symbol): Likewise.\n        Include \"gt-winnt.h\" at end.\n        * doc/hostconfig.texi: Document\n\tHOST_HOOKS_GT_PCH_ALLOC_GRANULARITY.\n\nFrom-SVN: r82643", "tree": {"sha": "546ccfa4f253ff907aa47680a32cadae4b2a9bc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/546ccfa4f253ff907aa47680a32cadae4b2a9bc1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/comments", "author": null, "committer": null, "parents": [{"sha": "859711c519c44dfd3fbe764d5ab508a8c7789dc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/859711c519c44dfd3fbe764d5ab508a8c7789dc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/859711c519c44dfd3fbe764d5ab508a8c7789dc3"}], "stats": {"total": 249, "additions": 234, "deletions": 15}, "files": [{"sha": "4b1360aeec3315aeefef9244ffed7a6db902e70f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "patch": "@@ -1,3 +1,34 @@\n+2004-06-05  Danny Smith  <dannysmith@users.sourceforge.net>\n+\n+        * toplev.c (init_asm_output): Add explicit 'b' to mode when\n+        opening asm_out_file. \n+        * c-pch.c (c_common_write_pch): Remove unnecessary fflush before\n+        reading asm_out_file. Replace fflush after reading asm_out_file\n+        with fseek.\n+        * hosthooks-def.h (HOST_HOOKS_GT_PCH_ALLOC_GRANULARITY): Define\n+        default and add to HOST_HOOKS_INITIALIZER. \n+        * hosthooks.h (gt_pch_alloc_granularity): Declare hook function.\n+        * ggc-common.c (default_gt_pch_alloc_granularity): New function.\n+        (gt_pch_save): Use host_hooks.gt_pch_alloc_granularity \n+        to set mmi.offset padding.\n+         * config.gcc (i[34567]86-*-mingw32*): Set target_gtfiles to\n+        $(srcdir)/config/i386/winnt.c.\n+        (i[34567]86-*-pe | i[34567]86-*-cygwin*): Likewise.\n+        (i[34567]86-*-uwin*): Likewise.\n+        *i[34567]86-*-interix3*): Likewise.\n+        * config.host (i[34567]86-*-mingw32*): Set out_host_hook_obj.\n+        * config/i386/host-mingw32.c: New file.\n+        * config/i386/x-mingw32: Add rule for host-mingw32.o.\n+        * config/i386/winnt.c: (struct extern_list) Tag as GTY.\n+        (extern_head): Likewise.\n+        (struct export_list) Likewise.\n+        (export_head): Likewise.\n+        (i386_pe_record_external_function): Use ggc_alloc.\n+        (i386_pe_record_exported_symbol): Likewise.\n+        Include \"gt-winnt.h\" at end.\n+        * doc/hostconfig.texi: Document\n+\tHOST_HOOKS_GT_PCH_ALLOC_GRANULARITY.\n+\n 2004-06-04  Bernardo Innocenti  <bernie@develer.com>\n \n \t* config/m68k/m68k.h: Remove comments copied over from tm.texi."}, {"sha": "03cf3bf08bcae4379cedfd1c4fb2ddb65e8e5a90", "filename": "gcc/c-pch.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "patch": "@@ -194,7 +194,6 @@ c_common_write_pch (void)\n     fatal_error (\"can't write %s: %m\", pch_file);\n   \n   buf = xmalloc (16384);\n-  fflush (asm_out_file);\n \n   if (fseek (asm_out_file, asm_file_startpos, SEEK_SET) != 0)\n     fatal_error (\"can't seek in %s: %m\", asm_file_name);\n@@ -211,8 +210,10 @@ c_common_write_pch (void)\n       written += size;\n     }\n   free (buf);\n-  /* asm_out_file can be written afterwards, so must be flushed first.  */\n-  fflush (asm_out_file);\n+  /* asm_out_file can be written afterwards, so fseek to clear\n+     _IOREAD flag.  */\n+  if (fseek (asm_out_file, 0, SEEK_END) != 0)\n+    fatal_error (\"can't seek in %s: %m\", asm_file_name);\n \n   gt_pch_save (pch_outfile);\n   cpp_write_pch_state (parse_in, pch_outfile);"}, {"sha": "8bf7d0eb85e06ce5b96b8d07087d2eba0a4175fe", "filename": "gcc/config.gcc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "patch": "@@ -1035,6 +1035,7 @@ i[34567]86-*-pe | i[34567]86-*-cygwin*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/cygming.h i386/cygwin.h\"\n \txm_file=i386/xm-cygwin.h\n \ttmake_file=\"i386/t-cygwin i386/t-cygming\"\n+\ttarget_gtfiles=\"\\$(srcdir)/config/i386/winnt.c\"\n \textra_objs=winnt.o\n \tc_target_objs=cygwin2.o\n \tcxx_target_objs=cygwin2.o\n@@ -1047,6 +1048,7 @@ i[34567]86-*-mingw32*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/cygming.h i386/mingw32.h\"\n \txm_file=i386/xm-mingw32.h\n \ttmake_file=\"i386/t-cygming i386/t-mingw32\"\n+\ttarget_gtfiles=\"\\$(srcdir)/config/i386/winnt.c\"\n \textra_objs=winnt.o\n \tif test x$enable_threads = xyes; then\n \t\tthread_file='win32'\n@@ -1063,6 +1065,7 @@ i[34567]86-*-uwin*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/cygwin.h i386/uwin.h\"\n \ttmake_file=\"i386/t-cygwin i386/t-uwin\"\n \textra_objs=winnt.o\n+\ttarget_gtfiles=\"\\$(srcdir)/config/i386/winnt.c\"\n \tif test x$enable_threads = xyes; then\n \t\tthread_file='win32'\n \tfi\n@@ -1072,6 +1075,7 @@ i[34567]86-*-interix3*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/i386-interix.h i386/i386-interix3.h interix.h interix3.h\"\n \ttmake_file=\"i386/t-interix\"\n \textra_objs=winnt.o\n+\ttarget_gtfiles=\"\\$(srcdir)/config/i386/winnt.c\"\n \tif test x$enable_threads = xyes ; then\n \t\tthread_file='posix'\n \tfi"}, {"sha": "67a067c169ffe9ebc17f633fd49c887c6de51f73", "filename": "gcc/config.host", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.host?ref=90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "patch": "@@ -143,6 +143,7 @@ case ${host} in\n     host_xmake_file=i386/x-mingw32\n     host_exeext=.exe\n     host_can_use_collect2=no\n+    out_host_hook_obj=host-mingw32.o\n     ;;\n   i[34567]86-*-uwin*)\n     echo \"*** UWIN may not be used as a host platform because\""}, {"sha": "0e3fdd7caf199f3593d8704919c1512832a28deb", "filename": "gcc/config/i386/host-mingw32.c", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fconfig%2Fi386%2Fhost-mingw32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fconfig%2Fi386%2Fhost-mingw32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fhost-mingw32.c?ref=90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "patch": "@@ -0,0 +1,148 @@\n+/* mingw32 host-specific hook definitions.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the\n+   Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"hosthooks.h\"\n+#include \"hosthooks-def.h\"\n+#include \"toplev.h\"\n+#include \"diagnostic.h\"\n+\n+\n+#define WIN32_LEAN_AND_MEAN  /* Not so important if we have windows.h.gch.  */\n+#include <windows.h>\n+\n+static void * mingw32_gt_pch_get_address (size_t, int);\n+static int mingw32_gt_pch_use_address (void *, size_t, int, size_t);\n+static size_t mingw32_gt_pch_alloc_granularity (void);\n+\n+#undef HOST_HOOKS_GT_PCH_GET_ADDRESS\n+#define HOST_HOOKS_GT_PCH_GET_ADDRESS mingw32_gt_pch_get_address\n+#undef HOST_HOOKS_GT_PCH_USE_ADDRESS\n+#define HOST_HOOKS_GT_PCH_USE_ADDRESS mingw32_gt_pch_use_address\n+#undef HOST_HOOKS_GT_PCH_ALLOC_GRANULARITY\n+#define HOST_HOOKS_GT_PCH_ALLOC_GRANULARITY mingw32_gt_pch_alloc_granularity\n+\n+static inline void w32_error(const char*, const char*, int, const char*);\n+\n+/* FIXME: Is this big enough?  */\n+static const size_t pch_VA_max_size  = 128 * 1024 * 1024;\n+\n+/* Granularity for reserving address space.  */\n+static const size_t va_granularity = 0x10000;\n+\n+/* Print out the GetLastError() translation.  */ \n+static inline void\n+w32_error (const char* function, const char* file, int line,\n+\t   const char* my_msg)\n+{\n+  LPSTR w32_msgbuf;\n+  FormatMessageA (FORMAT_MESSAGE_ALLOCATE_BUFFER\n+\t\t  | FORMAT_MESSAGE_FROM_SYSTEM\n+\t\t  | FORMAT_MESSAGE_IGNORE_INSERTS\n+\t\t  | FORMAT_MESSAGE_MAX_WIDTH_MASK,\n+    \t\t  NULL, GetLastError(),\n+\t\t  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n+\t\t  (LPSTR) &w32_msgbuf, 0, NULL);\n+  fprintf(stderr, \"internal error in %s, at %s:%d: %s: %s\\n\",\n+\t  function, trim_filename (file), line, my_msg, w32_msgbuf);\n+  LocalFree ((HLOCAL)w32_msgbuf);\n+}\n+\n+/* Granularity for reserving address space.  */\n+static size_t mingw32_gt_pch_alloc_granularity (void)\n+{\n+  return va_granularity;\n+}\n+\n+/* Identify an address that's likely to be free in a subsequent invocation\n+   of the compiler.  The area should be able to hold SIZE bytes.  FD is an\n+   open file descriptor if the host would like to probe with mmap.  */\n+\n+static void *\n+mingw32_gt_pch_get_address (size_t size, int fd  ATTRIBUTE_UNUSED)\n+{\n+  void* res;\n+  size = (size + va_granularity - 1) & ~(va_granularity - 1);\n+  if (size > pch_VA_max_size)\n+    return NULL;\n+\n+  /* FIXME: We let system determine base by setting first arg to NULL.\n+     Allocating at top of available address space avoids unnecessary\n+     fragmentation of \"ordinary\" (malloc's)  address space but may not be safe\n+     with delayed load of system dll's. Preferred addresses for NT system\n+     dlls is in 0x70000000 to 0x78000000 range.\n+     If we allocate at bottom we need to reserve the address as early as possible\n+     and at the same point in each invocation. */\n+ \n+  res = VirtualAlloc (NULL, pch_VA_max_size,\n+\t\t      MEM_RESERVE | MEM_TOP_DOWN,\n+\t\t      PAGE_NOACCESS);\n+  if (!res)\n+    w32_error (__FUNCTION__, __FILE__, __LINE__, \"VirtualAlloc\");\n+  else\n+    /* We do not need the address space for now, so free it.  */\n+    VirtualFree (res, 0, MEM_RELEASE);\n+\n+  return res; \n+}\n+\n+/* ADDR is an address returned by gt_pch_get_address.  Attempt to allocate\n+   SIZE bytes at the same address and load it with the data from FD at \n+   OFFSET.  Return -1 if we couldn't allocate memory at ADDR, return 0\n+   if the memory is allocated but the data not loaded, return 1 if done.  */\n+\n+static int\n+mingw32_gt_pch_use_address (void *addr, size_t size, int fd,\n+\t\t\t    size_t offset)\n+{\n+  void * mmap_addr;\n+  static HANDLE mmap_handle;\n+\n+  if (size == 0)\n+    return 0;\n+  \n+  /* Offset must be also be a multiple of allocation granularity for\n+     this to work.  We can't change the offset. */ \n+  if ((offset & (va_granularity - 1)) != 0 || size > pch_VA_max_size)\n+    return -1;\n+\n+  mmap_handle = CreateFileMapping ((HANDLE) _get_osfhandle (fd),\n+\t\t\t\t   NULL, PAGE_WRITECOPY | SEC_COMMIT,\n+\t\t\t\t   0, 0,  NULL);\n+  if (mmap_handle == NULL)\n+    {\n+      w32_error (__FUNCTION__,  __FILE__, __LINE__, \"CreateFileMapping\");\n+      return -1; \n+    }\n+  mmap_addr = MapViewOfFileEx (mmap_handle, FILE_MAP_COPY, 0, offset,\n+\t\t\t       size, addr);\n+  if (mmap_addr != addr)\n+    {\n+      w32_error (__FUNCTION__, __FILE__, __LINE__, \"MapViewOfFileEx\");\n+      CloseHandle(mmap_handle);\n+      return  -1;\n+    }\n+\n+  return 1;\n+}\n+\n+const struct host_hooks host_hooks = HOST_HOOKS_INITIALIZER;"}, {"sha": "0b51aa420708d8100a9f1fa29dbf726f28b4417c", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "patch": "@@ -769,13 +769,13 @@ i386_pe_declare_function_type (FILE *file, const char *name, int public)\n \n /* Keep a list of external functions.  */\n \n-struct extern_list\n+struct extern_list GTY(())\n {\n   struct extern_list *next;\n   const char *name;\n };\n \n-static struct extern_list *extern_head;\n+static GTY(()) struct extern_list *extern_head;\n \n /* Assemble an external function reference.  We need to keep a list of\n    these, so that we can output the function types at the end of the\n@@ -788,22 +788,22 @@ i386_pe_record_external_function (const char *name)\n {\n   struct extern_list *p;\n \n-  p = (struct extern_list *) xmalloc (sizeof *p);\n+  p = (struct extern_list *) ggc_alloc (sizeof *p);\n   p->next = extern_head;\n   p->name = name;\n   extern_head = p;\n }\n \n /* Keep a list of exported symbols.  */\n \n-struct export_list\n+struct export_list GTY(())\n {\n   struct export_list *next;\n   const char *name;\n   int is_data;\t\t/* used to type tag exported symbols.  */\n };\n \n-static struct export_list *export_head;\n+static GTY(()) struct export_list *export_head;\n \n /* Assemble an export symbol entry.  We need to keep a list of\n    these, so that we can output the export list at the end of the\n@@ -816,7 +816,7 @@ i386_pe_record_exported_symbol (const char *name, int is_data)\n {\n   struct export_list *p;\n \n-  p = (struct export_list *) xmalloc (sizeof *p);\n+  p = (struct export_list *) ggc_alloc (sizeof *p);\n   p->next = export_head;\n   p->name = name;\n   p->is_data = is_data;\n@@ -861,3 +861,5 @@ i386_pe_file_end (void)\n \t}\n     }\n }\n+\n+#include \"gt-winnt.h\""}, {"sha": "8b6a98565ef82a137908b69b525920957cd42e58", "filename": "gcc/config/i386/x-mingw32", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fconfig%2Fi386%2Fx-mingw32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fconfig%2Fi386%2Fx-mingw32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx-mingw32?ref=90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "patch": "@@ -2,3 +2,8 @@\n # Make local_includedir relative to EXEC_PREFIX \n #\n local_includedir=$(libsubdir)/$(unlibsubdir)/..`echo $(exec_prefix) | sed -e 's|^$(prefix)||' -e 's|/[^/]*|/..|g'`/include\n+\n+host-mingw32.o : $(srcdir)/config/i386/host-mingw32.c $(CONFIG_H) $(SYSTEM_H) \\\n+  coretypes.h hosthooks.h hosthooks-def.h toplev.h diagnostic.h\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t\t$(srcdir)/config/i386/host-mingw32.c"}, {"sha": "a016e561777ee00225dcf04b9879fcc5b213bef7", "filename": "gcc/doc/hostconfig.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fdoc%2Fhostconfig.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fdoc%2Fhostconfig.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fhostconfig.texi?ref=90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "patch": "@@ -71,6 +71,13 @@ indicate an out-of-date PCH file (built by some other GCC executable),\n and such a PCH file won't work.\n @end deftypefn\n \n+@deftypefn {Host Hook} size_t HOST_HOOKS_GT_PCH_ALLOC_GRANULARITY (void);\n+This host hook returns the alignment required for allocating virtual\n+memory. Usually this is the same as getpagesize, but on some hosts the\n+alignment for reserving memory differs from the pagesize for committing\n+memory.\n+@end deftypefn\n+\n @node Filesystem\n @section Host Filesystem\n @cindex configuration file"}, {"sha": "cc0dc93be84177b531ffa64699980d571f83a927", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "patch": "@@ -431,7 +431,7 @@ gt_pch_save (FILE *f)\n   char *this_object = NULL;\n   size_t this_object_size = 0;\n   struct mmap_info mmi;\n-  size_t page_size = getpagesize();\n+  const size_t mmap_offset_alignment = host_hooks.gt_pch_alloc_granularity();\n \n   gt_pch_save_stringpool ();\n \n@@ -481,14 +481,15 @@ gt_pch_save (FILE *f)\n \n   ggc_pch_prepare_write (state.d, state.f);\n \n-  /* Pad the PCH file so that the mmapped area starts on a page boundary.  */\n+  /* Pad the PCH file so that the mmapped area starts on an allocation\n+     granularity (usually page) boundary.  */\n   {\n     long o;\n     o = ftell (state.f) + sizeof (mmi);\n     if (o == -1)\n       fatal_error (\"can't get position in PCH file: %m\");\n-    mmi.offset = page_size - o % page_size;\n-    if (mmi.offset == page_size)\n+    mmi.offset = mmap_offset_alignment - o % mmap_offset_alignment;\n+    if (mmi.offset == mmap_offset_alignment)\n       mmi.offset = 0;\n     mmi.offset += o;\n   }\n@@ -612,6 +613,16 @@ default_gt_pch_use_address (void *base, size_t size, int fd ATTRIBUTE_UNUSED,\n   return (addr == base) - 1;\n }\n \n+/* Default version of HOST_HOOKS_GT_PCH_GET_ADDRESS.   Return the\n+   alignment required for allocating virtual memory. Usually this is the\n+   same as pagesize.  */\n+\n+size_t\n+default_gt_pch_alloc_granularity (void)\n+{\n+  return getpagesize();\n+}\n+\n #if HAVE_MMAP_FILE\n /* Default version of HOST_HOOKS_GT_PCH_GET_ADDRESS when mmap is present.\n    We temporarily allocate SIZE bytes, and let the kernel place the data"}, {"sha": "910f7830ec74f7a6a4af7ddb3316919fdec4f6bf", "filename": "gcc/hosthooks-def.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fhosthooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fhosthooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhosthooks-def.h?ref=90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "patch": "@@ -32,16 +32,21 @@ Boston, MA 02111-1307, USA.  */\n #define HOST_HOOKS_GT_PCH_USE_ADDRESS default_gt_pch_use_address\n #endif\n \n+#define HOST_HOOKS_GT_PCH_ALLOC_GRANULARITY \\\n+  default_gt_pch_alloc_granularity\n+\n extern void* default_gt_pch_get_address (size_t, int);\n extern int default_gt_pch_use_address (void *, size_t, int, size_t);\n+extern size_t default_gt_pch_alloc_granularity (void);\n extern void* mmap_gt_pch_get_address (size_t, int);\n extern int mmap_gt_pch_use_address (void *, size_t, int, size_t);\n \n /* The structure is defined in hosthooks.h.  */\n #define HOST_HOOKS_INITIALIZER {\t\t\\\n   HOST_HOOKS_EXTRA_SIGNALS,\t\t\t\\\n   HOST_HOOKS_GT_PCH_GET_ADDRESS,\t\t\\\n-  HOST_HOOKS_GT_PCH_USE_ADDRESS\t\t\t\\\n+  HOST_HOOKS_GT_PCH_USE_ADDRESS,\t\t\\\n+  HOST_HOOKS_GT_PCH_ALLOC_GRANULARITY\t\t\\\n }\n \n #endif /* GCC_HOST_HOOKS_DEF_H */"}, {"sha": "0ac89f5e7c75fd1a6e679b52a60509c86c6e3e4f", "filename": "gcc/hosthooks.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fhosthooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Fhosthooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhosthooks.h?ref=90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "patch": "@@ -36,6 +36,10 @@ struct host_hooks\n      if the memory is allocated but the data not loaded, return 1 if done.  */\n   int (*gt_pch_use_address) (void *addr, size_t size, int fd, size_t offset);\n \n+  /*  Return the alignment required for allocating virtual memory. Usually\n+      this is the same as pagesize.  */\n+  size_t (*gt_pch_alloc_granularity) (void);\n+\n   /* Whenever you add entries here, make sure you adjust hosthooks-def.h.  */\n };\n "}, {"sha": "2741be5047fd8d169caced4dd84911eda80ee95a", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=90aa6719a03ca37a01bf94240dbf02fb4b1eb3e0", "patch": "@@ -2039,7 +2039,7 @@ init_asm_output (const char *name)\n       if (!strcmp (asm_file_name, \"-\"))\n \tasm_out_file = stdout;\n       else\n-\tasm_out_file = fopen (asm_file_name, \"w+\");\n+\tasm_out_file = fopen (asm_file_name, \"w+b\");\n       if (asm_out_file == 0)\n \tfatal_error (\"can't open %s for writing: %m\", asm_file_name);\n     }"}]}