{"sha": "475b8f37f3f4085df385dbb122e0401a63d24edd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc1YjhmMzdmM2Y0MDg1ZGYzODVkYmIxMjJlMDQwMWE2M2QyNGVkZA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2013-04-18T14:29:54Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2013-04-18T14:29:54Z"}, "message": "Simplified GIMPLE IL builder functions.\n\n\t* gimple.c (create_gimple_tmp): New.\n\t(get_expr_type): New.\n\t(build_assign): New.\n\t(build_type_cast): New.\n\t* gimple.h (enum ssa_mode): Define.\n\t(gimple_seq_set_location): New.\n\t* asan.c (build_check_stmt): Change some gimple_build_* calls\n        to use build_assign and build_type_cast.\n\nFrom-SVN: r198056", "tree": {"sha": "09e712c2649b544f356460fea4ffacbd8c9364d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09e712c2649b544f356460fea4ffacbd8c9364d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/475b8f37f3f4085df385dbb122e0401a63d24edd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/475b8f37f3f4085df385dbb122e0401a63d24edd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/475b8f37f3f4085df385dbb122e0401a63d24edd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/475b8f37f3f4085df385dbb122e0401a63d24edd/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "13957435839e1dc1d3bad23510640a1d09a84772", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13957435839e1dc1d3bad23510640a1d09a84772", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13957435839e1dc1d3bad23510640a1d09a84772"}], "stats": {"total": 210, "additions": 159, "deletions": 51}, "files": [{"sha": "9ddfe0287b2feed340343273642ee702d732abda", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475b8f37f3f4085df385dbb122e0401a63d24edd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475b8f37f3f4085df385dbb122e0401a63d24edd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=475b8f37f3f4085df385dbb122e0401a63d24edd", "patch": "@@ -1,3 +1,14 @@\n+2013-04-18  Diego Novillo  <dnovillo@google.com>\n+\n+\t* gimple.c (create_gimple_tmp): New.\n+\t(get_expr_type): New.\n+\t(build_assign): New.\n+\t(build_type_cast): New.\n+\t* gimple.h (enum ssa_mode): Define.\n+\t(gimple_seq_set_location): New.\n+\t* asan.c (build_check_stmt): Change some gimple_build_* calls\n+        to use build_assign and build_type_cast.\n+\n 2013-04-18  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-data-refs.c (vect_analyze_group_access): Properly"}, {"sha": "b8acaf7700835a813dfedf3f0bf5f06b008f1bbf", "filename": "gcc/asan.c", "status": "modified", "additions": 16, "deletions": 50, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475b8f37f3f4085df385dbb122e0401a63d24edd/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475b8f37f3f4085df385dbb122e0401a63d24edd/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=475b8f37f3f4085df385dbb122e0401a63d24edd", "patch": "@@ -1380,57 +1380,23 @@ build_check_stmt (location_t location, tree base, gimple_stmt_iterator *iter,\n       /* Slow path for 1, 2 and 4 byte accesses.\n \t Test (shadow != 0)\n \t      & ((base_addr & 7) + (size_in_bytes - 1)) >= shadow).  */\n-      g = gimple_build_assign_with_ops (NE_EXPR,\n-\t\t\t\t\tmake_ssa_name (boolean_type_node,\n-\t\t\t\t\t\t       NULL),\n-\t\t\t\t\tshadow,\n-\t\t\t\t\tbuild_int_cst (shadow_type, 0));\n-      gimple_set_location (g, location);\n-      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-      t = gimple_assign_lhs (g);\n-\n-      g = gimple_build_assign_with_ops (BIT_AND_EXPR,\n-\t\t\t\t\tmake_ssa_name (uintptr_type,\n-\t\t\t\t\t\t       NULL),\n-\t\t\t\t\tbase_addr,\n-\t\t\t\t\tbuild_int_cst (uintptr_type, 7));\n-      gimple_set_location (g, location);\n-      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-\n-      g = gimple_build_assign_with_ops (NOP_EXPR,\n-\t\t\t\t\tmake_ssa_name (shadow_type,\n-\t\t\t\t\t\t       NULL),\n-\t\t\t\t\tgimple_assign_lhs (g), NULL_TREE);\n-      gimple_set_location (g, location);\n-      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-\n+      gimple_seq seq = NULL;\n+      gimple shadow_test = build_assign (NE_EXPR, shadow, 0);\n+      gimple_seq_add_stmt (&seq, shadow_test);\n+      gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, base_addr, 7));\n+      gimple_seq_add_stmt (&seq, build_type_cast (shadow_type,\n+                                                  gimple_seq_last (seq)));\n       if (size_in_bytes > 1)\n-\t{\n-\t  g = gimple_build_assign_with_ops (PLUS_EXPR,\n-\t\t\t\t\t    make_ssa_name (shadow_type,\n-\t\t\t\t\t\t\t   NULL),\n-\t\t\t\t\t    gimple_assign_lhs (g),\n-\t\t\t\t\t    build_int_cst (shadow_type,\n-\t\t\t\t\t\t\t   size_in_bytes - 1));\n-\t  gimple_set_location (g, location);\n-\t  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-\t}\n-\n-      g = gimple_build_assign_with_ops (GE_EXPR,\n-\t\t\t\t\tmake_ssa_name (boolean_type_node,\n-\t\t\t\t\t\t       NULL),\n-\t\t\t\t\tgimple_assign_lhs (g),\n-\t\t\t\t\tshadow);\n-      gimple_set_location (g, location);\n-      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-\n-      g = gimple_build_assign_with_ops (BIT_AND_EXPR,\n-\t\t\t\t\tmake_ssa_name (boolean_type_node,\n-\t\t\t\t\t\t       NULL),\n-\t\t\t\t\tt, gimple_assign_lhs (g));\n-      gimple_set_location (g, location);\n-      gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n-      t = gimple_assign_lhs (g);\n+        gimple_seq_add_stmt (&seq,\n+                             build_assign (PLUS_EXPR, gimple_seq_last (seq),\n+                                           size_in_bytes - 1));\n+      gimple_seq_add_stmt (&seq, build_assign (GE_EXPR, gimple_seq_last (seq),\n+                                               shadow));\n+      gimple_seq_add_stmt (&seq, build_assign (BIT_AND_EXPR, shadow_test,\n+                                               gimple_seq_last (seq)));\n+      t = gimple_assign_lhs (gimple_seq_last (seq));\n+      gimple_seq_set_location (seq, location);\n+      gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n     }\n   else\n     t = shadow;"}, {"sha": "64f7b1a19f2ada391b12510c9724c5c292f52090", "filename": "gcc/gimple.c", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475b8f37f3f4085df385dbb122e0401a63d24edd/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475b8f37f3f4085df385dbb122e0401a63d24edd/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=475b8f37f3f4085df385dbb122e0401a63d24edd", "patch": "@@ -4207,4 +4207,105 @@ gimple_asm_clobbers_memory_p (const_gimple stmt)\n \n   return false;\n }\n+\n+\n+/* Create and return an unnamed temporary.  MODE indicates whether\n+   this should be an SSA or NORMAL temporary.  TYPE is the type to use\n+   for the new temporary.  */\n+\n+tree\n+create_gimple_tmp (tree type, enum ssa_mode mode)\n+{\n+  return (mode == M_SSA)\n+         ? make_ssa_name (type, NULL)\n+         : create_tmp_var (type, NULL);\n+}\n+\n+\n+/* Return the expression type to use based on the CODE and type of\n+   the given operand OP.  If the expression CODE is a comparison,\n+   the returned type is boolean_type_node.  Otherwise, it returns\n+   the type of OP.  */\n+\n+static tree\n+get_expr_type (enum tree_code code, tree op)\n+{\n+  return (TREE_CODE_CLASS (code) == tcc_comparison)\n+\t ? boolean_type_node\n+\t : TREE_TYPE (op);\n+}\n+\n+\n+/* Build a new gimple assignment.  The LHS of the assignment is a new\n+   temporary whose type matches the given expression.  MODE indicates\n+   whether the LHS should be an SSA or a normal temporary.  CODE is\n+   the expression code for the RHS.  OP1 is the first operand and VAL\n+   is an integer value to be used as the second operand.  */\n+\n+gimple\n+build_assign (enum tree_code code, tree op1, int val, enum ssa_mode mode)\n+{\n+  tree op2 = build_int_cst (TREE_TYPE (op1), val);\n+  tree lhs = create_gimple_tmp (get_expr_type (code, op1), mode);\n+  return gimple_build_assign_with_ops (code, lhs, op1, op2);\n+}\n+\n+gimple\n+build_assign (enum tree_code code, gimple g, int val, enum ssa_mode mode)\n+{\n+  return build_assign (code, gimple_assign_lhs (g), val, mode);\n+}\n+\n+\n+/* Build and return a new GIMPLE assignment.  The new assignment will\n+   have the opcode CODE and operands OP1 and OP2.  The type of the\n+   expression on the RHS is inferred to be the type of OP1.\n+\n+   The LHS of the statement will be an SSA name or a GIMPLE temporary\n+   in normal form depending on the type of builder invoking this\n+   function.  */\n+\n+gimple\n+build_assign (enum tree_code code, tree op1, tree op2, enum ssa_mode mode)\n+{\n+  tree lhs = create_gimple_tmp (get_expr_type (code, op1), mode);\n+  return gimple_build_assign_with_ops (code, lhs, op1, op2);\n+}\n+\n+gimple\n+build_assign (enum tree_code code, gimple op1, tree op2, enum ssa_mode mode)\n+{\n+  return build_assign (code, gimple_assign_lhs (op1), op2, mode);\n+}\n+\n+gimple\n+build_assign (enum tree_code code, tree op1, gimple op2, enum ssa_mode mode)\n+{\n+  return build_assign (code, op1, gimple_assign_lhs (op2), mode);\n+}\n+\n+gimple\n+build_assign (enum tree_code code, gimple op1, gimple op2, enum ssa_mode mode)\n+{\n+  return build_assign (code, gimple_assign_lhs (op1), gimple_assign_lhs (op2),\n+                       mode);\n+}\n+\n+\n+/* Create and return a type cast assignment. This creates a NOP_EXPR\n+   that converts OP to TO_TYPE.  */\n+\n+gimple\n+build_type_cast (tree to_type, tree op, enum ssa_mode mode)\n+{\n+  tree lhs = create_gimple_tmp (to_type, mode);\n+  return gimple_build_assign_with_ops (NOP_EXPR, lhs, op, NULL_TREE);\n+}\n+\n+gimple\n+build_type_cast (tree to_type, gimple op, enum ssa_mode mode)\n+{\n+  return build_type_cast (to_type, gimple_assign_lhs (op), mode);\n+}\n+\n #include \"gt-gimple.h\""}, {"sha": "3a65e3ccace7758e625fec3a8fe7aa839f56f104", "filename": "gcc/gimple.h", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475b8f37f3f4085df385dbb122e0401a63d24edd/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475b8f37f3f4085df385dbb122e0401a63d24edd/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=475b8f37f3f4085df385dbb122e0401a63d24edd", "patch": "@@ -33,6 +33,15 @@ along with GCC; see the file COPYING3.  If not see\n \n typedef gimple gimple_seq_node;\n \n+/* Types of supported temporaries.  GIMPLE temporaries may be symbols\n+   in normal form (i.e., regular decls) or SSA names.  This enum is\n+   used by create_gimple_tmp to tell it what kind of temporary the\n+   caller wants.  */\n+enum ssa_mode {\n+    M_SSA = 0,\n+    M_NORMAL\n+};\n+\n /* For each block, the PHI nodes that need to be rewritten are stored into\n    these vectors.  */\n typedef vec<gimple> gimple_vec;\n@@ -720,6 +729,17 @@ union GTY ((desc (\"gimple_statement_structure (&%h)\"),\n \n /* In gimple.c.  */\n \n+/* Helper functions to build GIMPLE statements.  */\n+tree create_gimple_tmp (tree, enum ssa_mode = M_SSA);\n+gimple build_assign (enum tree_code, tree, int, enum ssa_mode = M_SSA);\n+gimple build_assign (enum tree_code, gimple, int, enum ssa_mode = M_SSA);\n+gimple build_assign (enum tree_code, tree, tree, enum ssa_mode = M_SSA);\n+gimple build_assign (enum tree_code, gimple, tree, enum ssa_mode = M_SSA);\n+gimple build_assign (enum tree_code, tree, gimple, enum ssa_mode = M_SSA);\n+gimple build_assign (enum tree_code, gimple, gimple, enum ssa_mode = M_SSA);\n+gimple build_type_cast (tree, tree, enum ssa_mode = M_SSA);\n+gimple build_type_cast (tree, gimple, enum ssa_mode = M_SSA);\n+\n /* Offset in bytes to the location of the operand vector.\n    Zero if there is no operand vector for this tuple structure.  */\n extern size_t const gimple_ops_offset_[];\n@@ -1096,7 +1116,6 @@ gimple_seq_empty_p (gimple_seq s)\n   return s == NULL;\n }\n \n-\n void gimple_seq_add_stmt (gimple_seq *, gimple);\n \n /* Link gimple statement GS to the end of the sequence *SEQ_P.  If\n@@ -5326,4 +5345,15 @@ extern tree maybe_fold_or_comparisons (enum tree_code, tree, tree,\n \t\t\t\t       enum tree_code, tree, tree);\n \n bool gimple_val_nonnegative_real_p (tree);\n+\n+\n+/* Set the location of all statements in SEQ to LOC.  */\n+\n+static inline void\n+gimple_seq_set_location (gimple_seq seq, location_t loc)\n+{\n+  for (gimple_stmt_iterator i = gsi_start (seq); !gsi_end_p (i); gsi_next (&i))\n+    gimple_set_location (gsi_stmt (i), loc);\n+}\n+\n #endif  /* GCC_GIMPLE_H */"}]}