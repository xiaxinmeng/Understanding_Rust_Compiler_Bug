{"sha": "65d3dce8e80d0a697d63c92abfde078a11e37e64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVkM2RjZThlODBkMGE2OTdkNjNjOTJhYmZkZTA3OGExMWUzN2U2NA==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2017-08-22T17:32:26Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2017-08-22T17:32:26Z"}, "message": "re PR tree-optimization/81488 (gcc goes off the limits allocating memory in gimple-ssa-strength-reduction.c)\n\n2017-08-22  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/81488\n\t* gimple-ssa-strength-reduction (struct slsr_cand_d): Add visited\n\tand cached_basis fields.\n\t(MAX_SPREAD): New constant.\n\t(alloc_cand_and_find_basis): Initialize new fields.\n\t(clear_visited): New function.\n\t(create_phi_basis_1): Rename from create_phi_basis, set visited\n\tand cached_basis fields.\n\t(create_phi_basis): New wrapper function.\n\t(phi_add_costs_1): Rename from phi_add_costs, add spread\n\tparameter, set visited field, short-circuit when limits reached.\n\t(phi_add_costs): New wrapper function.\n\t(record_phi_increments_1): Rename from record_phi_increments, set\n\tvisited field.\n\t(record_phi_increments): New wrapper function.\n\t(phi_incr_cost_1): Rename from phi_incr_cost, set visited field.\n\t(phi_incr_cost): New wrapper function.\n\t(all_phi_incrs_profitable_1): Rename from\n\tall_phi_incrs_profitable, set visited field.\n\t(all_phi_incrs_profitable): New wrapper function.\n\nFrom-SVN: r251286", "tree": {"sha": "7bd5a8c89e8a944692ebd11c33f6ee68b3b8092b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bd5a8c89e8a944692ebd11c33f6ee68b3b8092b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65d3dce8e80d0a697d63c92abfde078a11e37e64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d3dce8e80d0a697d63c92abfde078a11e37e64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65d3dce8e80d0a697d63c92abfde078a11e37e64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d3dce8e80d0a697d63c92abfde078a11e37e64/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "03a9562184454fe5395e30b8a3429c4570979d86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03a9562184454fe5395e30b8a3429c4570979d86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03a9562184454fe5395e30b8a3429c4570979d86"}], "stats": {"total": 227, "additions": 187, "deletions": 40}, "files": [{"sha": "e7681ce860a792451fe02d5bf384757cace21ae9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d3dce8e80d0a697d63c92abfde078a11e37e64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d3dce8e80d0a697d63c92abfde078a11e37e64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65d3dce8e80d0a697d63c92abfde078a11e37e64", "patch": "@@ -1,3 +1,26 @@\n+2017-08-22  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/81488\n+\t* gimple-ssa-strength-reduction (struct slsr_cand_d): Add visited\n+\tand cached_basis fields.\n+\t(MAX_SPREAD): New constant.\n+\t(alloc_cand_and_find_basis): Initialize new fields.\n+\t(clear_visited): New function.\n+\t(create_phi_basis_1): Rename from create_phi_basis, set visited\n+\tand cached_basis fields.\n+\t(create_phi_basis): New wrapper function.\n+\t(phi_add_costs_1): Rename from phi_add_costs, add spread\n+\tparameter, set visited field, short-circuit when limits reached.\n+\t(phi_add_costs): New wrapper function.\n+\t(record_phi_increments_1): Rename from record_phi_increments, set\n+\tvisited field.\n+\t(record_phi_increments): New wrapper function.\n+\t(phi_incr_cost_1): Rename from phi_incr_cost, set visited field.\n+\t(phi_incr_cost): New wrapper function.\n+\t(all_phi_incrs_profitable_1): Rename from\n+\tall_phi_incrs_profitable, set visited field.\n+\t(all_phi_incrs_profitable): New wrapper function.\n+\n 2017-08-22  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "9adb455a909154e9dc256d8add6145a17527431a", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 164, "deletions": 40, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d3dce8e80d0a697d63c92abfde078a11e37e64/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d3dce8e80d0a697d63c92abfde078a11e37e64/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=65d3dce8e80d0a697d63c92abfde078a11e37e64", "patch": "@@ -281,6 +281,14 @@ struct slsr_cand_d\n   /* Savings that can be expected from eliminating dead code if this\n      candidate is replaced.  */\n   int dead_savings;\n+\n+  /* For PHI candidates, use a visited flag to keep from processing the\n+     same PHI twice from multiple paths.  */\n+  int visited;\n+\n+  /* We sometimes have to cache a phi basis with a phi candidate to\n+     avoid processing it twice.  Valid only if visited==1.  */\n+  tree cached_basis;\n };\n \n typedef struct slsr_cand_d slsr_cand, *slsr_cand_t;\n@@ -369,7 +377,11 @@ enum count_phis_status\n   DONT_COUNT_PHIS = 0,\n   COUNT_PHIS = 1\n };\n- \n+\n+/* Constrain how many PHI nodes we will visit for a conditional\n+   candidate (depth and breadth).  */\n+const int MAX_SPREAD = 16;\n+\n /* Pointer map embodying a mapping from statements to candidates.  */\n static hash_map<gimple *, slsr_cand_t> *stmt_cand_map;\n \n@@ -671,6 +683,8 @@ alloc_cand_and_find_basis (enum cand_kind kind, gimple *gs, tree base,\n   c->sibling = 0;\n   c->def_phi = kind == CAND_MULT ? find_phi_def (base) : 0;\n   c->dead_savings = savings;\n+  c->visited = 0;\n+  c->cached_basis = NULL_TREE;\n \n   cand_vec.safe_push (c);\n \n@@ -2317,19 +2331,33 @@ create_add_on_incoming_edge (slsr_cand_t c, tree basis_name,\n   return lhs;\n }\n \n-/* Given a candidate C with BASIS_NAME being the LHS of C's basis which\n-   is hidden by the phi node FROM_PHI, create a new phi node in the same\n-   block as FROM_PHI.  The new phi is suitable for use as a basis by C,\n-   with its phi arguments representing conditional adjustments to the\n-   hidden basis along conditional incoming paths.  Those adjustments are\n-   made by creating add statements (and sometimes recursively creating\n-   phis) along those incoming paths.  LOC is the location to attach to\n-   the introduced statements.  KNOWN_STRIDE is true iff C's stride is a\n-   constant.  */\n+/* Clear the visited field for a tree of PHI candidates.  */\n+\n+static void\n+clear_visited (gphi *phi)\n+{\n+  unsigned i;\n+  slsr_cand_t phi_cand = *stmt_cand_map->get (phi);\n+\n+  if (phi_cand->visited)\n+    {\n+      phi_cand->visited = 0;\n+\n+      for (i = 0; i < gimple_phi_num_args (phi); i++)\n+\t{\n+\t  tree arg = gimple_phi_arg_def (phi, i);\n+\t  gimple *arg_def = SSA_NAME_DEF_STMT (arg);\n+\t  if (gimple_code (arg_def) == GIMPLE_PHI)\n+\t    clear_visited (as_a <gphi *> (arg_def));\n+\t}\n+    }\n+}\n+\n+/* Recursive helper function for create_phi_basis.  */\n \n static tree\n-create_phi_basis (slsr_cand_t c, gimple *from_phi, tree basis_name,\n-\t\t  location_t loc, bool known_stride)\n+create_phi_basis_1 (slsr_cand_t c, gimple *from_phi, tree basis_name,\n+\t\t    location_t loc, bool known_stride)\n {\n   int i;\n   tree name, phi_arg;\n@@ -2340,6 +2368,10 @@ create_phi_basis (slsr_cand_t c, gimple *from_phi, tree basis_name,\n   slsr_cand_t phi_cand = *stmt_cand_map->get (from_phi);\n   auto_vec<tree> phi_args (nargs);\n \n+  if (phi_cand->visited)\n+    return phi_cand->cached_basis;\n+  phi_cand->visited = 1;\n+\n   /* Process each argument of the existing phi that represents\n      conditionally-executed add candidates.  */\n   for (i = 0; i < nargs; i++)\n@@ -2367,8 +2399,8 @@ create_phi_basis (slsr_cand_t c, gimple *from_phi, tree basis_name,\n \t     process it in the same fashion to ensure that all basis\n \t     adjustments are made along its incoming edges.  */\n \t  if (gimple_code (arg_def) == GIMPLE_PHI)\n-\t    feeding_def = create_phi_basis (c, arg_def, basis_name,\n-\t\t\t\t\t    loc, known_stride);\n+\t    feeding_def = create_phi_basis_1 (c, arg_def, basis_name,\n+\t\t\t\t\t      loc, known_stride);\n \t  else\n \t    {\n \t      slsr_cand_t arg_cand = base_cand_from_table (arg);\n@@ -2403,9 +2435,31 @@ create_phi_basis (slsr_cand_t c, gimple *from_phi, tree basis_name,\n       print_gimple_stmt (dump_file, phi, 0);\n     }\n \n+  phi_cand->cached_basis = name;\n   return name;\n }\n \n+/* Given a candidate C with BASIS_NAME being the LHS of C's basis which\n+   is hidden by the phi node FROM_PHI, create a new phi node in the same\n+   block as FROM_PHI.  The new phi is suitable for use as a basis by C,\n+   with its phi arguments representing conditional adjustments to the\n+   hidden basis along conditional incoming paths.  Those adjustments are\n+   made by creating add statements (and sometimes recursively creating\n+   phis) along those incoming paths.  LOC is the location to attach to\n+   the introduced statements.  KNOWN_STRIDE is true iff C's stride is a\n+   constant.  */\n+\n+static tree\n+create_phi_basis (slsr_cand_t c, gimple *from_phi, tree basis_name,\n+\t\t  location_t loc, bool known_stride)\n+{\n+  tree retval = create_phi_basis_1 (c, from_phi, basis_name, loc,\n+\t\t\t\t    known_stride);\n+  gcc_assert (retval);\n+  clear_visited (as_a <gphi *> (from_phi));\n+  return retval;\n+}\n+\n /* Given a candidate C whose basis is hidden by at least one intervening\n    phi, introduce a matching number of new phis to represent its basis\n    adjusted by conditional increments along possible incoming paths.  Then\n@@ -2429,25 +2483,29 @@ replace_conditional_candidate (slsr_cand_t c)\n   loc = gimple_location (c->cand_stmt);\n   name = create_phi_basis (c, lookup_cand (c->def_phi)->cand_stmt,\n \t\t\t   basis_name, loc, KNOWN_STRIDE);\n+\n   /* Replace C with an add of the new basis phi and a constant.  */\n   widest_int bump = c->index * wi::to_widest (c->stride);\n \n   replace_mult_candidate (c, name, bump);\n }\n \n-/* Compute the expected costs of inserting basis adjustments for\n-   candidate C with phi-definition PHI.  The cost of inserting \n-   one adjustment is given by ONE_ADD_COST.  If PHI has arguments\n-   which are themselves phi results, recursively calculate costs\n-   for those phis as well.  */\n+/* Recursive helper function for phi_add_costs.  SPREAD is a measure of\n+   how many PHI nodes we have visited at this point in the tree walk.  */\n \n static int\n-phi_add_costs (gimple *phi, slsr_cand_t c, int one_add_cost)\n+phi_add_costs_1 (gimple *phi, slsr_cand_t c, int one_add_cost, int *spread)\n {\n   unsigned i;\n   int cost = 0;\n   slsr_cand_t phi_cand = *stmt_cand_map->get (phi);\n \n+  if (phi_cand->visited)\n+    return 0;\n+\n+  phi_cand->visited = 1;\n+  (*spread)++;\n+\n   /* If we work our way back to a phi that isn't dominated by the hidden\n      basis, this isn't a candidate for replacement.  Indicate this by\n      returning an unreasonably high cost.  It's not easy to detect\n@@ -2469,7 +2527,12 @@ phi_add_costs (gimple *phi, slsr_cand_t c, int one_add_cost)\n \t  gimple *arg_def = SSA_NAME_DEF_STMT (arg);\n \n \t  if (gimple_code (arg_def) == GIMPLE_PHI)\n-\t    cost += phi_add_costs (arg_def, c, one_add_cost);\n+\t    {\n+\t      cost += phi_add_costs_1 (arg_def, c, one_add_cost, spread);\n+\n+\t      if (cost >= COST_INFINITE || *spread > MAX_SPREAD)\n+\t\treturn COST_INFINITE;\n+\t    }\n \t  else\n \t    {\n \t      slsr_cand_t arg_cand = base_cand_from_table (arg);\n@@ -2483,6 +2546,20 @@ phi_add_costs (gimple *phi, slsr_cand_t c, int one_add_cost)\n   return cost;\n }\n \n+/* Compute the expected costs of inserting basis adjustments for\n+   candidate C with phi-definition PHI.  The cost of inserting \n+   one adjustment is given by ONE_ADD_COST.  If PHI has arguments\n+   which are themselves phi results, recursively calculate costs\n+   for those phis as well.  */\n+\n+static int\n+phi_add_costs (gimple *phi, slsr_cand_t c, int one_add_cost)\n+{\n+  int spread = 0;\n+  int retval = phi_add_costs_1 (phi, c, one_add_cost, &spread);\n+  clear_visited (as_a <gphi *> (phi));\n+  return retval;\n+}\n /* For candidate C, each sibling of candidate C, and each dependent of\n    candidate C, determine whether the candidate is dependent upon a \n    phi that hides its basis.  If not, replace the candidate unconditionally.\n@@ -2648,18 +2725,18 @@ record_increment (slsr_cand_t c, widest_int increment, bool is_phi_adjust)\n     }\n }\n \n-/* Given phi statement PHI that hides a candidate from its BASIS, find\n-   the increments along each incoming arc (recursively handling additional\n-   phis that may be present) and record them.  These increments are the\n-   difference in index between the index-adjusting statements and the\n-   index of the basis.  */\n+/* Recursive helper function for record_phi_increments.  */\n \n static void\n-record_phi_increments (slsr_cand_t basis, gimple *phi)\n+record_phi_increments_1 (slsr_cand_t basis, gimple *phi)\n {\n   unsigned i;\n   slsr_cand_t phi_cand = *stmt_cand_map->get (phi);\n   \n+  if (phi_cand->visited)\n+    return;\n+  phi_cand->visited = 1;\n+\n   for (i = 0; i < gimple_phi_num_args (phi); i++)\n     {\n       tree arg = gimple_phi_arg_def (phi, i);\n@@ -2669,7 +2746,7 @@ record_phi_increments (slsr_cand_t basis, gimple *phi)\n \t  gimple *arg_def = SSA_NAME_DEF_STMT (arg);\n \n \t  if (gimple_code (arg_def) == GIMPLE_PHI)\n-\t    record_phi_increments (basis, arg_def);\n+\t    record_phi_increments_1 (basis, arg_def);\n \t  else\n \t    {\n \t      slsr_cand_t arg_cand = base_cand_from_table (arg);\n@@ -2680,6 +2757,19 @@ record_phi_increments (slsr_cand_t basis, gimple *phi)\n     }\n }\n \n+/* Given phi statement PHI that hides a candidate from its BASIS, find\n+   the increments along each incoming arc (recursively handling additional\n+   phis that may be present) and record them.  These increments are the\n+   difference in index between the index-adjusting statements and the\n+   index of the basis.  */\n+\n+static void\n+record_phi_increments (slsr_cand_t basis, gimple *phi)\n+{\n+  record_phi_increments_1 (basis, phi);\n+  clear_visited (as_a <gphi *> (phi));\n+}\n+\n /* Determine how many times each unique increment occurs in the set\n    of candidates rooted at C's parent, recording the data in the\n    increment vector.  For each unique increment I, if an initializer\n@@ -2717,21 +2807,21 @@ record_increments (slsr_cand_t c)\n     record_increments (lookup_cand (c->dependent));\n }\n \n-/* Add up and return the costs of introducing add statements that\n-   require the increment INCR on behalf of candidate C and phi\n-   statement PHI.  Accumulate into *SAVINGS the potential savings\n-   from removing existing statements that feed PHI and have no other\n-   uses.  */\n+/* Recursive helper function for phi_incr_cost.  */\n \n static int\n-phi_incr_cost (slsr_cand_t c, const widest_int &incr, gimple *phi,\n-\t       int *savings)\n+phi_incr_cost_1 (slsr_cand_t c, const widest_int &incr, gimple *phi,\n+\t\t int *savings)\n {\n   unsigned i;\n   int cost = 0;\n   slsr_cand_t basis = lookup_cand (c->basis);\n   slsr_cand_t phi_cand = *stmt_cand_map->get (phi);\n \n+  if (phi_cand->visited)\n+    return 0;\n+  phi_cand->visited = 1;\n+\n   for (i = 0; i < gimple_phi_num_args (phi); i++)\n     {\n       tree arg = gimple_phi_arg_def (phi, i);\n@@ -2744,7 +2834,7 @@ phi_incr_cost (slsr_cand_t c, const widest_int &incr, gimple *phi,\n \t    {\n \t      int feeding_savings = 0;\n \t      tree feeding_var = gimple_phi_result (arg_def);\n-\t      cost += phi_incr_cost (c, incr, arg_def, &feeding_savings);\n+\t      cost += phi_incr_cost_1 (c, incr, arg_def, &feeding_savings);\n \t      if (uses_consumed_by_stmt (feeding_var, phi))\n \t\t*savings += feeding_savings;\n \t    }\n@@ -2768,6 +2858,21 @@ phi_incr_cost (slsr_cand_t c, const widest_int &incr, gimple *phi,\n   return cost;\n }\n \n+/* Add up and return the costs of introducing add statements that\n+   require the increment INCR on behalf of candidate C and phi\n+   statement PHI.  Accumulate into *SAVINGS the potential savings\n+   from removing existing statements that feed PHI and have no other\n+   uses.  */\n+\n+static int\n+phi_incr_cost (slsr_cand_t c, const widest_int &incr, gimple *phi,\n+\t       int *savings)\n+{\n+  int retval = phi_incr_cost_1 (c, incr, phi, savings);\n+  clear_visited (as_a <gphi *> (phi));\n+  return retval;\n+}\n+\n /* Return the first candidate in the tree rooted at C that has not\n    already been replaced, favoring siblings over dependents.  */\n \n@@ -3309,16 +3414,21 @@ insert_initializers (slsr_cand_t c)\n     }\n }\n \n-/* Return TRUE iff all required increments for candidates feeding PHI\n-   are profitable (and legal!) to replace on behalf of candidate C.  */\n+/* Recursive helper function for all_phi_incrs_profitable.  */\n \n static bool\n-all_phi_incrs_profitable (slsr_cand_t c, gphi *phi)\n+all_phi_incrs_profitable_1 (slsr_cand_t c, gphi *phi, int *spread)\n {\n   unsigned i;\n   slsr_cand_t basis = lookup_cand (c->basis);\n   slsr_cand_t phi_cand = *stmt_cand_map->get (phi);\n \n+  if (phi_cand->visited)\n+    return true;\n+\n+  phi_cand->visited = 1;\n+  (*spread)++;\n+\n   /* If the basis doesn't dominate the PHI (including when the PHI is\n      in the same block as the basis), we won't be able to create a PHI\n      using the basis here.  */\n@@ -3346,7 +3456,9 @@ all_phi_incrs_profitable (slsr_cand_t c, gphi *phi)\n \n \t  if (gimple_code (arg_def) == GIMPLE_PHI)\n \t    {\n-\t      if (!all_phi_incrs_profitable (c, as_a <gphi *> (arg_def)))\n+\t      if (!all_phi_incrs_profitable_1 (c, as_a <gphi *> (arg_def),\n+\t\t\t\t\t       spread)\n+\t\t  || *spread > MAX_SPREAD)\n \t\treturn false;\n \t    }\n \t  else\n@@ -3388,6 +3500,18 @@ all_phi_incrs_profitable (slsr_cand_t c, gphi *phi)\n   return true;\n }\n   \n+/* Return TRUE iff all required increments for candidates feeding PHI\n+   are profitable (and legal!) to replace on behalf of candidate C.  */\n+\n+static bool\n+all_phi_incrs_profitable (slsr_cand_t c, gphi *phi)\n+{\n+  int spread = 0;\n+  bool retval = all_phi_incrs_profitable_1 (c, phi, &spread);\n+  clear_visited (phi);\n+  return retval;\n+}\n+\n /* Create a NOP_EXPR that copies FROM_EXPR into a new SSA name of\n    type TO_TYPE, and insert it in front of the statement represented\n    by candidate C.  Use *NEW_VAR to create the new SSA name.  Return"}]}