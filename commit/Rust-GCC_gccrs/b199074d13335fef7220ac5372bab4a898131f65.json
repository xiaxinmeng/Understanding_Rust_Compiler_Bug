{"sha": "b199074d13335fef7220ac5372bab4a898131f65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE5OTA3NGQxMzMzNWZlZjcyMjBhYzUzNzJiYWI0YTg5ODEzMWY2NQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-03-19T15:35:55Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-03-19T15:35:55Z"}, "message": "tree.def (REALPART_EXPR, [...]): Move.\n\n\t* tree.def (REALPART_EXPR, IMAGPART_EXPR, VIEW_CONVERT_EXPR): Move.\n\t* tree.h (handled_component_p): Reorder cases.\n\t* dwarf2out.c (loc_list_for_address_of_addr_expr_of_indirect_ref): Do\n\tnot initialize unsignedp.\n\t(loc_list_from_tree): Likewise.\n\t(fortran_common): Likewise.\n\t* simplify-rtx.c (delegitimize_mem_from_attrs): Likewise.\n\nFrom-SVN: r185522", "tree": {"sha": "5aa9a6ef1c91b2af73ac56b6bdb2e671558e7e91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5aa9a6ef1c91b2af73ac56b6bdb2e671558e7e91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b199074d13335fef7220ac5372bab4a898131f65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b199074d13335fef7220ac5372bab4a898131f65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b199074d13335fef7220ac5372bab4a898131f65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b199074d13335fef7220ac5372bab4a898131f65/comments", "author": null, "committer": null, "parents": [{"sha": "79f3658a243933ec102cf7c8d2e702645020169e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f3658a243933ec102cf7c8d2e702645020169e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79f3658a243933ec102cf7c8d2e702645020169e"}], "stats": {"total": 64, "additions": 36, "deletions": 28}, "files": [{"sha": "670361eb04af19cd4d441f6d389e5730ebd71ddc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b199074d13335fef7220ac5372bab4a898131f65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b199074d13335fef7220ac5372bab4a898131f65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b199074d13335fef7220ac5372bab4a898131f65", "patch": "@@ -1,3 +1,13 @@\n+2012-03-19  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree.def (REALPART_EXPR, IMAGPART_EXPR, VIEW_CONVERT_EXPR): Move.\n+\t* tree.h (handled_component_p): Reorder cases.\n+\t* dwarf2out.c (loc_list_for_address_of_addr_expr_of_indirect_ref): Do\n+\tnot initialize unsignedp.\n+\t(loc_list_from_tree): Likewise.\n+\t(fortran_common): Likewise.\n+\t* simplify-rtx.c (delegitimize_mem_from_attrs): Likewise.\n+\n 2012-03-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (ix86_expand_prologue) <CM_LARGE_PIC>: Use Pmode\n@@ -32,7 +42,7 @@\n \n 2012-03-16  Martin Jambor  <mjambor@suse.cz>\n \n-\t* expr.c (expand_expr_real_1): handle misaligned scalar reads from\n+\t* expr.c (expand_expr_real_1): Handle misaligned scalar reads from\n \tmemory through MEM_REFs by calling extract_bit_field.\n \n 2012-03-16  Richard Guenther  <rguenther@suse.de>"}, {"sha": "828e996edb4cccaf21aed6e2a102df32fac096b4", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b199074d13335fef7220ac5372bab4a898131f65/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b199074d13335fef7220ac5372bab4a898131f65/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b199074d13335fef7220ac5372bab4a898131f65", "patch": "@@ -13328,17 +13328,16 @@ cst_pool_loc_descr (tree loc)\n }\n \n /* Return dw_loc_list representing address of addr_expr LOC\n-   by looking for innder INDIRECT_REF expression and turing it\n-   into simple arithmetics.  */\n+   by looking for inner INDIRECT_REF expression and turning\n+   it into simple arithmetics.  */\n \n static dw_loc_list_ref\n loc_list_for_address_of_addr_expr_of_indirect_ref (tree loc, bool toplev)\n {\n   tree obj, offset;\n   HOST_WIDE_INT bitsize, bitpos, bytepos;\n   enum machine_mode mode;\n-  int volatilep;\n-  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (loc));\n+  int unsignedp, volatilep = 0;\n   dw_loc_list_ref list_ret = NULL, list_ret1 = NULL;\n \n   obj = get_inner_reference (TREE_OPERAND (loc, 0),\n@@ -13628,8 +13627,7 @@ loc_list_from_tree (tree loc, int want_address)\n \ttree obj, offset;\n \tHOST_WIDE_INT bitsize, bitpos, bytepos;\n \tenum machine_mode mode;\n-\tint volatilep;\n-\tint unsignedp = TYPE_UNSIGNED (TREE_TYPE (loc));\n+\tint unsignedp, volatilep = 0;\n \n \tobj = get_inner_reference (loc, &bitsize, &bitpos, &offset, &mode,\n \t\t\t\t   &unsignedp, &volatilep, false);\n@@ -14927,7 +14925,7 @@ fortran_common (tree decl, HOST_WIDE_INT *value)\n   enum machine_mode mode;\n   HOST_WIDE_INT bitsize, bitpos;\n   tree offset;\n-  int volatilep = 0, unsignedp = 0;\n+  int unsignedp, volatilep = 0;\n \n   /* If the decl isn't a VAR_DECL, or if it isn't static, or if\n      it does not have a value (the offset into the common area), or if it"}, {"sha": "35b7f2cdd2980bbcc063c2e31cd9035b0256d8ea", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b199074d13335fef7220ac5372bab4a898131f65/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b199074d13335fef7220ac5372bab4a898131f65/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=b199074d13335fef7220ac5372bab4a898131f65", "patch": "@@ -293,7 +293,7 @@ delegitimize_mem_from_attrs (rtx x)\n \t  {\n \t    HOST_WIDE_INT bitsize, bitpos;\n \t    tree toffset;\n-\t    int unsignedp = 0, volatilep = 0;\n+\t    int unsignedp, volatilep = 0;\n \n \t    decl = get_inner_reference (decl, &bitsize, &bitpos, &toffset,\n \t\t\t\t\t&mode, &unsignedp, &volatilep, false);"}, {"sha": "fd7cbbd12653f3ba869bcfde3e594946f76bd1f2", "filename": "gcc/tree.def", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b199074d13335fef7220ac5372bab4a898131f65/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b199074d13335fef7220ac5372bab4a898131f65/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=b199074d13335fef7220ac5372bab4a898131f65", "patch": "@@ -400,11 +400,6 @@ DEFTREECODE (COMPONENT_REF, \"component_ref\", tcc_reference, 3)\n    to its mode width.  */\n DEFTREECODE (BIT_FIELD_REF, \"bit_field_ref\", tcc_reference, 3)\n \n-/* Used only on an operand of complex type, these return\n-   a value of the corresponding component type.  */\n-DEFTREECODE (REALPART_EXPR, \"realpart_expr\", tcc_reference, 1)\n-DEFTREECODE (IMAGPART_EXPR, \"imagpart_expr\", tcc_reference, 1)\n-\n /* Array indexing.\n    Operand 0 is the array; operand 1 is a (single) array index.\n    Operand 2, if present, is a copy of TYPE_MIN_VALUE of the index.\n@@ -417,6 +412,23 @@ DEFTREECODE (ARRAY_REF, \"array_ref\", tcc_reference, 4)\n    of the range is taken from the type of the expression.  */\n DEFTREECODE (ARRAY_RANGE_REF, \"array_range_ref\", tcc_reference, 4)\n \n+/* Used only on an operand of complex type, these return\n+   a value of the corresponding component type.  */\n+DEFTREECODE (REALPART_EXPR, \"realpart_expr\", tcc_reference, 1)\n+DEFTREECODE (IMAGPART_EXPR, \"imagpart_expr\", tcc_reference, 1)\n+\n+/* Represents viewing something of one type as being of a second type.\n+   This corresponds to an \"Unchecked Conversion\" in Ada and roughly to\n+   the idiom *(type2 *)&X in C.  The only operand is the value to be\n+   viewed as being of another type.  It is undefined if the type of the\n+   input and of the expression have different sizes.\n+\n+   This code may also be used within the LHS of a MODIFY_EXPR, in which\n+   case no actual data motion may occur.  TREE_ADDRESSABLE will be set in\n+   this case and GCC must abort if it could not do the operation without\n+   generating insns.  */\n+DEFTREECODE (VIEW_CONVERT_EXPR, \"view_convert_expr\", tcc_reference, 1)\n+\n /* C unary `*' or Pascal `^'.  One operand, an expression for a pointer.  */\n DEFTREECODE (INDIRECT_REF, \"indirect_ref\", tcc_reference, 1)\n \n@@ -769,18 +781,6 @@ DEFTREECODE (NOP_EXPR, \"nop_expr\", tcc_unary, 1)\n /* Value is same as argument, but guaranteed not an lvalue.  */\n DEFTREECODE (NON_LVALUE_EXPR, \"non_lvalue_expr\", tcc_unary, 1)\n \n-/* Represents viewing something of one type as being of a second type.\n-   This corresponds to an \"Unchecked Conversion\" in Ada and roughly to\n-   the idiom *(type2 *)&X in C.  The only operand is the value to be\n-   viewed as being of another type.  It is undefined if the type of the\n-   input and of the expression have different sizes.\n-\n-   This code may also be used within the LHS of a MODIFY_EXPR, in which\n-   case no actual data motion may occur.  TREE_ADDRESSABLE will be set in\n-   this case and GCC must abort if it could not do the operation without\n-   generating insns.  */\n-DEFTREECODE (VIEW_CONVERT_EXPR, \"view_convert_expr\", tcc_reference, 1)\n-\n /* A COMPOUND_LITERAL_EXPR represents a literal that is placed in a DECL.  The\n    COMPOUND_LITERAL_EXPR_DECL_EXPR is the a DECL_EXPR containing the decl\n    for the anonymous object represented by the COMPOUND_LITERAL;"}, {"sha": "8a1cbb80c236f084d6eaf4cbeb7b3f3807963cb8", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b199074d13335fef7220ac5372bab4a898131f65/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b199074d13335fef7220ac5372bab4a898131f65/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b199074d13335fef7220ac5372bab4a898131f65", "patch": "@@ -5029,13 +5029,13 @@ handled_component_p (const_tree t)\n {\n   switch (TREE_CODE (t))\n     {\n-    case BIT_FIELD_REF:\n     case COMPONENT_REF:\n+    case BIT_FIELD_REF:\n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:\n-    case VIEW_CONVERT_EXPR:\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n+    case VIEW_CONVERT_EXPR:\n       return true;\n \n     default:"}]}