{"sha": "ed63c387aa0bc1846082524455a6ff1fcec40f9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ2M2MzODdhYTBiYzE4NDYwODI1MjQ0NTVhNmZmMWZjZWM0MGY5ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-05-19T18:28:05Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-05-19T18:39:15Z"}, "message": "preprocessor: Reimplement raw string lexing [pr95149]\n\npr95149 is a false positive static analysis checker.  But it\nencouranged me to fix raw string lexing, which does contain a\ncomplicated macro and pointers to local variables.  The\nreimplementation does away with that macro.  Part of the complication\nis we need to undo some of the fresh line processing -- trigraph notes\nand escaped line continuations.  But the undone characters need to go\nthrough the raw string processing, as they can legitimately be part of\nthe prefix marker.  however, in this reformulation we only process one\nline marker at a time[*], so there's a limited number of undone\ncharacters.  We can arrange the buffering to make sure we don't split\nsuch an append sequence, and then simply take the characters from the\nappend buffer.\n\nThe prefix scanner had a switch statement, which I discovered was not\noptimized as well as an if of a bunch of explicit comparisons (pr\n95208 filed).\n\nFinally I adjusted the failure mode.  When we get a bad prefix, we lex\nup until the next '\"', thus often swallowing the whole raw string.\nPreviously we'd bail and then the lexer would usually generate stupid\ntokens, particularly when meeting the ending '\"'.\n\n\tlibcpp/\n\t* lex.c (struct lit_accum): New.\n\t(bufring_append): Replace by lit_accum::append.\n\t(lex_raw_string): Reimplement, using fragments of the old version.\n\t(lex_string): Adjust lex_raw_string call.\n\n\tgcc/testsuite/\n\t* c-c++-common/raw-string-14.c: Adjust errors.\n\t* c-c++-common/raw-string-16.c: Likewise.\n\t* c-c++-common/raw-string-5.c: Likewise.", "tree": {"sha": "c719e1e942b4b6c31305810786b212b933faae78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c719e1e942b4b6c31305810786b212b933faae78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed63c387aa0bc1846082524455a6ff1fcec40f9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed63c387aa0bc1846082524455a6ff1fcec40f9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed63c387aa0bc1846082524455a6ff1fcec40f9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed63c387aa0bc1846082524455a6ff1fcec40f9d/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e7ae154dc5ef8d92ba5405b71154dc2f46b8d1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e7ae154dc5ef8d92ba5405b71154dc2f46b8d1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e7ae154dc5ef8d92ba5405b71154dc2f46b8d1f"}], "stats": {"total": 601, "additions": 317, "deletions": 284}, "files": [{"sha": "4bf896417f5196f3a89c44e3cd7f0b70bae79d9c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed63c387aa0bc1846082524455a6ff1fcec40f9d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed63c387aa0bc1846082524455a6ff1fcec40f9d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ed63c387aa0bc1846082524455a6ff1fcec40f9d", "patch": "@@ -1,3 +1,9 @@\n+2020-05-19  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* c-c++-common/raw-string-14.c: Adjust errors.\n+\t* c-c++-common/raw-string-16.c: Likewise.\n+\t* c-c++-common/raw-string-5.c: Likewise.\n+\n 2020-05-19  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.target/i386/pr92645-4.c: Adjust expected pattern."}, {"sha": "fba826c4c5133ed5dd978e67de68d481b9232dda", "filename": "gcc/testsuite/c-c++-common/raw-string-14.c", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed63c387aa0bc1846082524455a6ff1fcec40f9d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fraw-string-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed63c387aa0bc1846082524455a6ff1fcec40f9d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fraw-string-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fraw-string-14.c?ref=ed63c387aa0bc1846082524455a6ff1fcec40f9d", "patch": "@@ -4,36 +4,33 @@\n // { dg-options \"-std=c++11\" { target c++ } }\n \n const void *s0 = R\"abc\\\n-def()abcdef\";\n-\t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } 6 }\n-\t// { dg-error \"stray\" \"stray\" { target *-*-* } 6 }\n+def()abcdef\" 0;\n+\t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } .-2 }\n+\t// { dg-error \"stray\" \"stray\" { target *-*-* } .-3 }\n const void *s1 = R\"??/\n-()??/\";\n-\t// { dg-error \"invalid new-line\" \"invalid\" { target *-*-* } 10 }\n-\t// { dg-error \"stray\" \"stray\" { target *-*-* } 10 }\n-\t// { dg-warning \"missing terminating\" \"missing\" { target *-*-* } 10 }\n-\t// { dg-error \"19:missing terminating\" \"missing\" { target *-*-* } 10 }\n-const void *s2 = R\"abcdefghijklmn??/(a)abcdefghijklmn???\";\n+()??/\" 0;\n+\t// { dg-error \"invalid new-line\" \"invalid\" { target *-*-* } .-2 }\n+\t// { dg-error \"stray\" \"stray\" { target *-*-* } .-3 }\n+const void *s2 = R\"abcdefghijklmn??/(a)abcdefghijklmn???\" 0;\n \t// { dg-error \"raw string delimiter longer\" \"longer\" { target *-*-* } .-1 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } .-2 }\n-\t// { dg-error \"expected\" \"expected\" { target *-*-* } .-3 }\n-const void *s3 = R\"abcdefghijklmno??/(a)abcdefghijklmno???\";\n+const void *s3 = R\"abcdefghijklmno??/(a)abcdefghijklmno???\" 0;\n \t// { dg-error \"raw string delimiter longer\" \"longer\" { target *-*-* } .-1 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } .-2 }\n-const void *s4 = R\"abcdefghijklmnop??=(a)abcdefghijklmnop??=\";\n+const void *s4 = R\"abcdefghijklmnop??=(a)abcdefghijklmnop??=\" 0;\n \t// { dg-error \"raw string delimiter longer\" \"longer\" { target *-*-* } .-1 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } .-2 }\n const void *s5 = R\"abc\\\n-()abcdef\";\n-\t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } 26 }\n-\t// { dg-error \"stray\" \"stray\" { target *-*-* } 26 }\n+()abcdef\" 0;\n+\t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } .-2 }\n+\t// { dg-error \"stray\" \"stray\" { target *-*-* } .-3 }\n const void *s6 = R\"\\\n-()\";\n-\t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } 30 }\n-\t// { dg-error \"stray\" \"stray\" { target *-*-* } 30 }\n+()\" 0;\n+\t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } .-2 }\n+\t// { dg-error \"stray\" \"stray\" { target *-*-* } .-3 }\n const void *s7 = R\"\\\n-a()a\";\n-\t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } 34 }\n-\t// { dg-error \"stray\" \"stray\" { target *-*-* } 34 }\n+a()a\" 0;\n+\t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } .-2 }\n+\t// { dg-error \"stray\" \"stray\" { target *-*-* } .-3 }\n \n int main () {}"}, {"sha": "1bf16dd5a1ed33f670305bd54fd4d0b01b0af3fd", "filename": "gcc/testsuite/c-c++-common/raw-string-16.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed63c387aa0bc1846082524455a6ff1fcec40f9d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fraw-string-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed63c387aa0bc1846082524455a6ff1fcec40f9d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fraw-string-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fraw-string-16.c?ref=ed63c387aa0bc1846082524455a6ff1fcec40f9d", "patch": "@@ -4,29 +4,29 @@\n // { dg-options \"-std=gnu++11 -Wtrigraphs\" { target c++ } }\n \n const void *s0 = R\"abc\\\n-def()abcdef\";\n+def()abcdef\" 0;\n \t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } 6 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } 6 }\n-const void *s1 = R\"abcdefghijklmn??/(a)abcdefghijklmn???\";\n+const void *s1 = R\"abcdefghijklmn??/(a)abcdefghijklmn???\" 0;\n \t// { dg-error \"raw string delimiter longer\" \"longer\" { target *-*-* } .-1 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } .-2 }\n \n-const void *s2 = R\"abcdefghijklmno??/(a)abcdefghijklmno???\";\n+const void *s2 = R\"abcdefghijklmno??/(a)abcdefghijklmno???\" 0;\n \t// { dg-error \"raw string delimiter longer\" \"longer\" { target *-*-* } .-1 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } .-2 }\n-const void *s3 = R\"abcdefghijklmnop??=(a)abcdefghijklmnop??=?\"; // { dg-warning \"trigraph ..= ignored\" }\n+const void *s3 = R\"abcdefghijklmnop??=(a)abcdefghijklmnop??=?\" 0;\n \t// { dg-error \"raw string delimiter longer\" \"longer\" { target *-*-* } .-1 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } .-2 }\n const void *s4 = R\"abc\\\n-()abcdef\";\n+()abcdef\" 0;\n \t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } 20 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } 20 }\n const void *s5 = R\"\\\n-()\";\n+()\" 0;\n \t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } 24 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } 24 }\n const void *s6 = R\"\\\n-a()a\";\n+a()a\" 0;\n \t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } 28 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } 28 }\n "}, {"sha": "dbf31333213dcd372a9e984775fe2c4bde21486b", "filename": "gcc/testsuite/c-c++-common/raw-string-5.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed63c387aa0bc1846082524455a6ff1fcec40f9d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fraw-string-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed63c387aa0bc1846082524455a6ff1fcec40f9d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fraw-string-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fraw-string-5.c?ref=ed63c387aa0bc1846082524455a6ff1fcec40f9d", "patch": "@@ -2,25 +2,25 @@\n // { dg-options \"-std=gnu99\" { target c } }\n // { dg-options \"-std=c++0x\" { target c++ } }\n \n-const void *s0 = R\"0123456789abcdefg()0123456789abcdefg\";\n+const void *s0 = R\"0123456789abcdefg()0123456789abcdefg\" 0;\n \t// { dg-error \"raw string delimiter longer\" \"longer\" { target *-*-* } .-1 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } .-2 }\n-const void *s1 = R\" () \";\n+const void *s1 = R\" () \" 0;\n \t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } .-1 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } .-2 }\n-const void *s2 = R\"\t()\t\";\n+const void *s2 = R\"\t()\t\" 0;\n \t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } .-1 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } .-2 }\n-const void *s3 = R\")())\";\n+const void *s3 = R\")())\" 0;\n \t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } .-1 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } .-2 }\n-const void *s4 = R\"@()@\";\n+const void *s4 = R\"@()@\" 0;\n \t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } .-1 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } .-2 }\n-const void *s5 = R\"$()$\";\n+const void *s5 = R\"$()$\" 0;\n \t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } .-1 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } .-2 }\n-const void *s6 = R\"\\u0040()\\u0040\";\n+const void *s6 = R\"\\u0040()\\u0040\" 0;\n \t// { dg-error \"invalid character\" \"invalid\" { target *-*-* } .-1 }\n \t// { dg-error \"stray\" \"stray\" { target *-*-* } .-2 }\n "}, {"sha": "5bfa1842a6a9c38a8e2d6452fcf9e68c54a7f627", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed63c387aa0bc1846082524455a6ff1fcec40f9d/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed63c387aa0bc1846082524455a6ff1fcec40f9d/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=ed63c387aa0bc1846082524455a6ff1fcec40f9d", "patch": "@@ -1,5 +1,11 @@\n 2020-05-18  Nathan Sidwell  <nathan@acm.org>\n \n+\tPR preprocessor/95149\n+\t* lex.c (struct lit_accum): New.\n+\t(bufring_append): Replace by lit_accum::append.\n+\t(lex_raw_string): Reimplement, using fragments of the old version.\n+\t(lex_string): Adjust lex_raw_string call.\n+\n \tPR preprocessor/95182\n \t* macro.c (collect_args): Preserve EOFif we fell out of the main\n \tfile."}, {"sha": "5d94882abe8a8f1827c800ab0ec05b26cae92d41", "filename": "libcpp/lex.c", "status": "modified", "additions": 273, "deletions": 249, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed63c387aa0bc1846082524455a6ff1fcec40f9d/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed63c387aa0bc1846082524455a6ff1fcec40f9d/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=ed63c387aa0bc1846082524455a6ff1fcec40f9d", "patch": "@@ -1586,35 +1586,74 @@ create_literal (cpp_reader *pfile, cpp_token *token, const uchar *base,\n   token->val.str.text = dest;\n }\n \n+/* A pair of raw buffer pointers.  The currently open one is [1], the\n+   first one is [0].  Used for string literal lexing.  */\n+struct lit_accum {\n+  _cpp_buff *first;\n+  _cpp_buff *last;\n+  const uchar *rpos;\n+  size_t accum;\n+\n+  lit_accum ()\n+    : first (NULL), last (NULL), rpos (0), accum (0)\n+  {\n+  }\n+\n+  void append (cpp_reader *, const uchar *, size_t);\n+\n+  void read_begin (cpp_reader *);\n+  bool reading_p () const\n+  {\n+    return rpos != NULL;\n+  }\n+  char read_char ()\n+  {\n+    char c = *rpos++;\n+    if (rpos == BUFF_FRONT (last))\n+      rpos = NULL;\n+    return c;\n+  }\n+};\n+\n /* Subroutine of lex_raw_string: Append LEN chars from BASE to the buffer\n    sequence from *FIRST_BUFF_P to LAST_BUFF_P.  */\n \n-static void\n-bufring_append (cpp_reader *pfile, const uchar *base, size_t len,\n-\t\t_cpp_buff **first_buff_p, _cpp_buff **last_buff_p)\n+void\n+lit_accum::append (cpp_reader *pfile, const uchar *base, size_t len)\n {\n-  _cpp_buff *first_buff = *first_buff_p;\n-  _cpp_buff *last_buff = *last_buff_p;\n-\n-  if (first_buff == NULL)\n-    first_buff = last_buff = _cpp_get_buff (pfile, len);\n-  else if (len > BUFF_ROOM (last_buff))\n+  if (!last)\n+    /* Starting.  */\n+    first = last = _cpp_get_buff (pfile, len);\n+  else if (len > BUFF_ROOM (last))\n     {\n-      size_t room = BUFF_ROOM (last_buff);\n-      memcpy (BUFF_FRONT (last_buff), base, room);\n-      BUFF_FRONT (last_buff) += room;\n+      /* There is insufficient room in the buffer.  Copy what we can,\n+\t and then either extend or create a new one.  */\n+      size_t room = BUFF_ROOM (last);\n+      memcpy (BUFF_FRONT (last), base, room);\n+      BUFF_FRONT (last) += room;\n       base += room;\n       len -= room;\n-      last_buff = _cpp_append_extend_buff (pfile, last_buff, len);\n-    }\n+      accum += room;\n+\n+      gcc_checking_assert (!rpos);\n \n-  memcpy (BUFF_FRONT (last_buff), base, len);\n-  BUFF_FRONT (last_buff) += len;\n+      last = _cpp_append_extend_buff (pfile, last, len);\n+    }\n \n-  *first_buff_p = first_buff;\n-  *last_buff_p = last_buff;\n+  memcpy (BUFF_FRONT (last), base, len);\n+  BUFF_FRONT (last) += len;\n+  accum += len;\n }\n \n+void\n+lit_accum::read_begin (cpp_reader *pfile)\n+{\n+  /* We never accumulate more than 4 chars to read.  */\n+  if (BUFF_ROOM (last) < 4)\n+\n+    last = _cpp_append_extend_buff (pfile, last, 4);\n+  rpos = BUFF_FRONT (last);\n+}\n \n /* Returns true if a macro has been defined.\n    This might not work if compile with -save-temps,\n@@ -1657,247 +1696,231 @@ is_macro_not_literal_suffix(cpp_reader *pfile, const uchar *base)\n   return is_macro (pfile, base);\n }\n \n-/* Lexes a raw string.  The stored string contains the spelling, including\n-   double quotes, delimiter string, '(' and ')', any leading\n-   'L', 'u', 'U' or 'u8' and 'R' modifier.  It returns the type of the\n-   literal, or CPP_OTHER if it was not properly terminated.\n+/* Lexes a raw string.  The stored string contains the spelling,\n+   including double quotes, delimiter string, '(' and ')', any leading\n+   'L', 'u', 'U' or 'u8' and 'R' modifier.  The created token contains\n+   the type of the literal, or CPP_OTHER if it was not properly\n+   terminated.\n+\n+   BASE is the start of the token.  Updates pfile->buffer->cur to just\n+   after the lexed string.\n \n    The spelling is NUL-terminated, but it is not guaranteed that this\n    is the first NUL since embedded NULs are preserved.  */\n \n static void\n-lex_raw_string (cpp_reader *pfile, cpp_token *token, const uchar *base,\n-\t\tconst uchar *cur)\n+lex_raw_string (cpp_reader *pfile, cpp_token *token, const uchar *base)\n {\n-  uchar raw_prefix[17];\n-  uchar temp_buffer[18];\n-  const uchar *orig_base;\n-  unsigned int raw_prefix_len = 0, raw_suffix_len = 0;\n-  enum raw_str_phase { RAW_STR_PREFIX, RAW_STR, RAW_STR_SUFFIX };\n-  raw_str_phase phase = RAW_STR_PREFIX;\n-  enum cpp_ttype type;\n-  size_t total_len = 0;\n-  /* Index into temp_buffer during phases other than RAW_STR,\n-     during RAW_STR phase 17 to tell BUF_APPEND that nothing should\n-     be appended to temp_buffer.  */\n-  size_t temp_buffer_len = 0;\n-  _cpp_buff *first_buff = NULL, *last_buff = NULL;\n-  size_t raw_prefix_start;\n+  const uchar *pos = base;\n+\n+  /* 'tis a pity this information isn't passed down from the lexer's\n+     initial categorization of the token.  */\n+  enum cpp_ttype type = CPP_STRING;\n+\n+  if (*pos == 'L')\n+    {\n+      type = CPP_WSTRING;\n+      pos++;\n+    }\n+  else if (*pos == 'U')\n+    {\n+      type = CPP_STRING32;\n+      pos++;\n+    }\n+  else if (*pos == 'u')\n+    {\n+      if (pos[1] == '8')\n+\t{\n+\t  type = CPP_UTF8STRING;\n+\t  pos++;\n+\t}\n+      else\n+\ttype = CPP_STRING16;\n+      pos++;\n+    }\n+\n+  gcc_checking_assert (pos[0] == 'R' && pos[1] == '\"');\n+  pos += 2;\n+\n   _cpp_line_note *note = &pfile->buffer->notes[pfile->buffer->cur_note];\n \n-  type = (*base == 'L' ? CPP_WSTRING :\n-\t  *base == 'U' ? CPP_STRING32 :\n-\t  *base == 'u' ? (base[1] == '8' ? CPP_UTF8STRING : CPP_STRING16)\n-\t  : CPP_STRING);\n-\n-#define BUF_APPEND(STR,LEN)\t\t\t\t\t\\\n-      do {\t\t\t\t\t\t\t\\\n-\tbufring_append (pfile, (const uchar *)(STR), (LEN),\t\\\n-\t\t\t&first_buff, &last_buff);\t\t\\\n-\ttotal_len += (LEN);\t\t\t\t\t\\\n-\tif (__builtin_expect (temp_buffer_len < 17, 0)\t\t\\\n-\t    && (const uchar *)(STR) != base\t\t\t\\\n-\t    && (LEN) <= 2)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    memcpy (temp_buffer + temp_buffer_len,\t\t\\\n-\t\t    (const uchar *)(STR), (LEN));\t\t\\\n-\t    temp_buffer_len += (LEN);\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-      } while (0)\n-\n-  orig_base = base;\n-  ++cur;\n-  raw_prefix_start = cur - base;\n+  /* Skip notes before the \".  */\n+  while (note->pos < pos)\n+    ++note;\n+\n+  lit_accum accum;\n+  \n+  uchar prefix[17];\n+  unsigned prefix_len = 0;\n+  enum Phase\n+  {\n+   PHASE_PREFIX = -2,\n+   PHASE_NONE = -1,\n+   PHASE_SUFFIX = 0\n+  } phase = PHASE_PREFIX;\n+\n   for (;;)\n     {\n-      cppchar_t c;\n-\n-      /* If we previously performed any trigraph or line splicing\n-\t transformations, undo them in between the opening and closing\n-\t double quote.  */\n-      while (note->pos < cur)\n-\t++note;\n-      for (; note->pos == cur; ++note)\n-\t{\n-\t  switch (note->type)\n-\t    {\n-\t    case '\\\\':\n-\t    case ' ':\n-\t      /* Restore backslash followed by newline.  */\n-\t      BUF_APPEND (base, cur - base);\n-\t      base = cur;\n-\t      BUF_APPEND (\"\\\\\", 1);\n-\t    after_backslash:\n-\t      if (note->type == ' ')\n-\t\t{\n-\t\t  /* GNU backslash whitespace newline extension.  FIXME\n-\t\t     could be any sequence of non-vertical space.  When we\n-\t\t     can properly restore any such sequence, we should mark\n-\t\t     this note as handled so _cpp_process_line_notes\n-\t\t     doesn't warn.  */\n-\t\t  BUF_APPEND (\" \", 1);\n-\t\t}\n+      gcc_checking_assert (note->pos >= pos);\n \n-\t      BUF_APPEND (\"\\n\", 1);\n-\t      break;\n+      /* Undo any escaped newlines and trigraphs.  */\n+      if (!accum.reading_p () && note->pos == pos)\n+\tswitch (note->type)\n+\t  {\n+\t  case '\\\\':\n+\t  case ' ':\n+\t    /* Restore backslash followed by newline.  */\n+\t    accum.append (pfile, base, pos - base);\n+\t    base = pos;\n+\t    accum.read_begin (pfile);\n+\t    accum.append (pfile, UC\"\\\\\", 1);\n+\n+\t  after_backslash:\n+\t    if (note->type == ' ')\n+\t      /* GNU backslash whitespace newline extension.  FIXME\n+\t\t could be any sequence of non-vertical space.  When we\n+\t\t can properly restore any such sequence, we should\n+\t\t mark this note as handled so _cpp_process_line_notes\n+\t\t doesn't warn.  */\n+\t      accum.append (pfile, UC\" \", 1);\n+\n+\t    accum.append (pfile, UC\"\\n\", 1);\n+\t    note++;\n+\t    break;\n \n-\t    case 0:\n-\t      /* Already handled.  */\n-\t      break;\n+\t  case '\\n':\n+\t    /* This can happen for ??/<NEWLINE> when trigraphs are not\n+\t       being interpretted.  */\n+\t    gcc_checking_assert (!CPP_OPTION (pfile, trigraphs));\n+\t    note->type = 0;\n+\t    note++;\n+\t    break;\n \n-\t    default:\n-\t      if (_cpp_trigraph_map[note->type])\n-\t\t{\n-\t\t  /* Don't warn about this trigraph in\n-\t\t     _cpp_process_line_notes, since trigraphs show up as\n-\t\t     trigraphs in raw strings.  */\n-\t\t  uchar type = note->type;\n-\t\t  note->type = 0;\n-\n-\t\t  if (!CPP_OPTION (pfile, trigraphs))\n-\t\t    /* If we didn't convert the trigraph in the first\n-\t\t       place, don't do anything now either.  */\n-\t\t    break;\n+\t  default:\n+\t    gcc_checking_assert (_cpp_trigraph_map[note->type]);\n \n-\t\t  BUF_APPEND (base, cur - base);\n-\t\t  base = cur;\n-\t\t  BUF_APPEND (\"??\", 2);\n+\t    /* Don't warn about this trigraph in\n+\t       _cpp_process_line_notes, since trigraphs show up as\n+\t       trigraphs in raw strings.  */\n+\t    uchar type = note->type;\n+\t    note->type = 0;\n \n-\t\t  /* ??/ followed by newline gets two line notes, one for\n-\t\t     the trigraph and one for the backslash/newline.  */\n-\t\t  if (type == '/' && note[1].pos == cur)\n-\t\t    {\n-\t\t      if (note[1].type != '\\\\'\n-\t\t\t  && note[1].type != ' ')\n-\t\t\tabort ();\n-\t\t      BUF_APPEND (\"/\", 1);\n-\t\t      ++note;\n-\t\t      goto after_backslash;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* Skip the replacement character.  */\n-\t\t      base = ++cur;\n-\t\t      BUF_APPEND (&type, 1);\n-\t\t      c = type;\n-\t\t      goto check_c;\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tabort ();\n-\t      break;\n-\t    }\n-\t}\n-      c = *cur++;\n-      if (__builtin_expect (temp_buffer_len < 17, 0))\n-\ttemp_buffer[temp_buffer_len++] = c;\n+\t    if (CPP_OPTION (pfile, trigraphs))\n+\t      {\n+\t\taccum.append (pfile, base, pos - base);\n+\t\tbase = pos;\n+\t\taccum.read_begin (pfile);\n+\t\taccum.append (pfile, UC\"??\", 2);\n+\t\taccum.append (pfile, &type, 1);\n+\n+\t\t/* ??/ followed by newline gets two line notes, one for\n+\t\t   the trigraph and one for the backslash/newline.  */\n+\t\tif (type == '/' && note[1].pos == pos)\n+\t\t  {\n+\t\t    note++;\n+\t\t    gcc_assert (note->type == '\\\\' || note->type == ' ');\n+\t\t    goto after_backslash;\n+\t\t  }\n+\t\t/* Skip the replacement character.  */\n+\t\tbase = ++pos;\n+\t      }\n \n-     check_c:\n-      if (phase == RAW_STR_PREFIX)\n+\t    note++;\n+\t    break;\n+\t  }\n+\n+      /* Now get a char to process.  Either from an expanded note, or\n+\t from the line buffer.  */\n+      bool read_note = accum.reading_p ();\n+      char c = read_note ? accum.read_char () : *pos++;\n+\n+      if (phase == PHASE_PREFIX)\n \t{\n-\t  while (raw_prefix_len < temp_buffer_len)\n+\t  if (c == '(')\n \t    {\n-\t      raw_prefix[raw_prefix_len] = temp_buffer[raw_prefix_len];\n-\t      switch (raw_prefix[raw_prefix_len])\n-\t\t{\n-\t\tcase ' ': case '(': case ')': case '\\\\': case '\\t':\n-\t\tcase '\\v': case '\\f': case '\\n': default:\n-\t\t  break;\n-\t\t/* Basic source charset except the above chars.  */\n-\t\tcase 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n-\t\tcase 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n-\t\tcase 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n-\t\tcase 's': case 't': case 'u': case 'v': case 'w': case 'x':\n-\t\tcase 'y': case 'z':\n-\t\tcase 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n-\t\tcase 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n-\t\tcase 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n-\t\tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n-\t\tcase 'Y': case 'Z':\n-\t\tcase '0': case '1': case '2': case '3': case '4': case '5':\n-\t\tcase '6': case '7': case '8': case '9':\n-\t\tcase '_': case '{': case '}': case '#': case '[': case ']':\n-\t\tcase '<': case '>': case '%': case ':': case ';': case '.':\n-\t\tcase '?': case '*': case '+': case '-': case '/': case '^':\n-\t\tcase '&': case '|': case '~': case '!': case '=': case ',':\n-\t\tcase '\"': case '\\'':\n-\t\t  if (raw_prefix_len < 16)\n-\t\t    {\n-\t\t      raw_prefix_len++;\n-\t\t      continue;\n-\t\t    }\n-\t\t  break;\n-\t\t}\n-\n-\t      if (raw_prefix[raw_prefix_len] != '(')\n-\t\t{\n-\t\t  int col = CPP_BUF_COLUMN (pfile->buffer, cur) + 1;\n-\t\t  if (raw_prefix_len == 16)\n-\t\t    cpp_error_with_line (pfile, CPP_DL_ERROR, token->src_loc,\n-\t\t\t\t\t col, \"raw string delimiter longer \"\n-\t\t\t\t\t      \"than 16 characters\");\n-\t\t  else if (raw_prefix[raw_prefix_len] == '\\n')\n-\t\t    cpp_error_with_line (pfile, CPP_DL_ERROR, token->src_loc,\n-\t\t\t\t\t col, \"invalid new-line in raw \"\n-\t\t\t\t\t      \"string delimiter\");\n-\t\t  else\n-\t\t    cpp_error_with_line (pfile, CPP_DL_ERROR, token->src_loc,\n-\t\t\t\t\t col, \"invalid character '%c' in \"\n-\t\t\t\t\t      \"raw string delimiter\",\n-\t\t\t\t\t (int) raw_prefix[raw_prefix_len]);\n-\t\t  pfile->buffer->cur = orig_base + raw_prefix_start - 1;\n-\t\t  create_literal (pfile, token, orig_base,\n-\t\t\t\t  raw_prefix_start - 1, CPP_OTHER);\n-\t\t  if (first_buff)\n-\t\t    _cpp_release_buff (pfile, first_buff);\n-\t\t  return;\n-\t\t}\n-\t      raw_prefix[raw_prefix_len] = '\"';\n-\t      phase = RAW_STR;\n-\t      /* Nothing should be appended to temp_buffer during\n-\t\t RAW_STR phase.  */\n-\t      temp_buffer_len = 17;\n-\t      break;\n+\t      /* Done.  */\n+\t      phase = PHASE_NONE;\n+\t      prefix[prefix_len++] = '\"';\n+\t    }\n+\t  else if (prefix_len < 16\n+\t\t   /* Prefix chars are any of the basic character set,\n+\t\t      [lex.charset] except for '\n+\t\t      ()\\\\\\t\\v\\f\\n'. Optimized for a contiguous\n+\t\t      alphabet.  */\n+\t\t   /* Unlike a switch, this collapses down to one or\n+\t\t      two shift and bitmask operations on an ASCII\n+\t\t      system, with an outlier or two.   */\n+\t\t   && (('Z' - 'A' == 25\n+\t\t\t? ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n+\t\t\t: ISIDST (c))\n+\t\t       || (c >= '0' && c <= '9')\n+\t\t       || c == '_' || c == '{' || c == '}'\n+\t\t       || c == '[' || c == ']' || c == '#'\n+\t\t       || c == '<' || c == '>' || c == '%'\n+\t\t       || c == ':' || c == ';' || c == '.' || c == '?'\n+\t\t       || c == '*' || c == '+' || c == '-' || c == '/'\n+\t\t       || c == '^' || c == '&' || c == '|' || c == '~'\n+\t\t       || c == '!' || c == '=' || c == ','\n+\t\t       || c == '\"' || c == '\\''))\n+\t    prefix[prefix_len++] = c;\n+\t  else\n+\t    {\n+\t      /* Something is wrong.  */\n+\t      int col = CPP_BUF_COLUMN (pfile->buffer, pos) + read_note;\n+\t      if (prefix_len == 16)\n+\t\tcpp_error_with_line (pfile, CPP_DL_ERROR, token->src_loc,\n+\t\t\t\t     col, \"raw string delimiter longer \"\n+\t\t\t\t     \"than 16 characters\");\n+\t      else if (c == '\\n')\n+\t\tcpp_error_with_line (pfile, CPP_DL_ERROR, token->src_loc,\n+\t\t\t\t     col, \"invalid new-line in raw \"\n+\t\t\t\t     \"string delimiter\");\n+\t      else\n+\t\tcpp_error_with_line (pfile, CPP_DL_ERROR, token->src_loc,\n+\t\t\t\t     col, \"invalid character '%c' in \"\n+\t\t\t\t     \"raw string delimiter\", c);\n+\t      type = CPP_OTHER;\n+\t      phase = PHASE_NONE;\n+\t      /* Continue until we get a close quote, that's probably\n+\t\t the best failure mode.  */\n+\t      prefix_len = 0;\n \t    }\n \t  continue;\n \t}\n-      else if (phase == RAW_STR_SUFFIX)\n+\n+      if (phase != PHASE_NONE)\n \t{\n-\t  while (raw_suffix_len <= raw_prefix_len\n-\t\t && raw_suffix_len < temp_buffer_len\n-\t\t && temp_buffer[raw_suffix_len] == raw_prefix[raw_suffix_len])\n-\t    raw_suffix_len++;\n-\t  if (raw_suffix_len > raw_prefix_len)\n+\t  if (prefix[phase] != c)\n+\t    phase = PHASE_NONE;\n+\t  else if (unsigned (phase + 1) == prefix_len)\n \t    break;\n-\t  if (raw_suffix_len == temp_buffer_len)\n-\t    continue;\n-\t  phase = RAW_STR;\n-\t  /* Nothing should be appended to temp_buffer during\n-\t     RAW_STR phase.  */\n-\t  temp_buffer_len = 17;\n-\t}\n-      if (c == ')')\n-\t{\n-\t  phase = RAW_STR_SUFFIX;\n-\t  raw_suffix_len = 0;\n-\t  temp_buffer_len = 0;\n+\t  else\n+\t    {\n+\t      phase = Phase (phase + 1);\n+\t      continue;\n+\t    }\n \t}\n-      else if (c == '\\n')\n+\n+      if (!prefix_len && c == '\"')\n+\t/* Failure mode lexing.  */\n+\tgoto out;\n+      else if (prefix_len && c == ')')\n+\tphase = PHASE_SUFFIX;\n+      else if (!read_note && c == '\\n')\n \t{\n+\t  pos--;\n+\t  pfile->buffer->cur = pos;\n \t  if (pfile->state.in_directive\n \t      || (pfile->state.parsing_args\n \t\t  && pfile->buffer->next_line >= pfile->buffer->rlimit))\n \t    {\n-\t      cur--;\n-\t      type = CPP_OTHER;\n \t      cpp_error_with_line (pfile, CPP_DL_ERROR, token->src_loc, 0,\n \t\t\t\t   \"unterminated raw string\");\n-\t      break;\n+\t      type = CPP_OTHER;\n+\t      goto out;\n \t    }\n \n-\t  BUF_APPEND (base, cur - base);\n-\n-\t  pfile->buffer->cur = cur-1;\n+\t  accum.append (pfile, base, pos - base + 1);\n \t  _cpp_process_line_notes (pfile, false);\n \n \t  if (pfile->buffer->next_line < pfile->buffer->rlimit)\n@@ -1906,21 +1929,22 @@ lex_raw_string (cpp_reader *pfile, cpp_token *token, const uchar *base,\n \n \t  if (!_cpp_get_fresh_line (pfile))\n \t    {\n+\t      /* We ran out of file and failed to get a line.  */\n \t      location_t src_loc = token->src_loc;\n \t      token->type = CPP_EOF;\n \t      /* Tell the compiler the line number of the EOF token.  */\n \t      token->src_loc = pfile->line_table->highest_line;\n \t      token->flags = BOL;\n-\t      if (first_buff != NULL)\n-\t\t_cpp_release_buff (pfile, first_buff);\n+\t      if (accum.first)\n+\t\t_cpp_release_buff (pfile, accum.first);\n \t      cpp_error_with_line (pfile, CPP_DL_ERROR, src_loc, 0,\n \t\t\t\t   \"unterminated raw string\");\n \t      /* Now pop the buffer that _cpp_get_fresh_line did not.  */\n \t      _cpp_pop_buffer (pfile);\n \t      return;\n \t    }\n \n-\t  cur = base = pfile->buffer->cur;\n+\t  pos = base = pfile->buffer->cur;\n \t  note = &pfile->buffer->notes[pfile->buffer->cur_note];\n \t}\n     }\n@@ -1930,7 +1954,7 @@ lex_raw_string (cpp_reader *pfile, cpp_token *token, const uchar *base,\n       /* If a string format macro, say from inttypes.h, is placed touching\n \t a string literal it could be parsed as a C++11 user-defined string\n \t literal thus breaking the program.  */\n-      if (is_macro_not_literal_suffix (pfile, cur))\n+      if (is_macro_not_literal_suffix (pfile, pos))\n \t{\n \t  /* Raise a warning, but do not consume subsequent tokens.  */\n \t  if (CPP_OPTION (pfile, warn_literal_suffix) && !pfile->state.skipping)\n@@ -1940,37 +1964,37 @@ lex_raw_string (cpp_reader *pfile, cpp_token *token, const uchar *base,\n \t\t\t\t   \"a space between literal and string macro\");\n \t}\n       /* Grab user defined literal suffix.  */\n-      else if (ISIDST (*cur))\n+      else if (ISIDST (*pos))\n \t{\n \t  type = cpp_userdef_string_add_type (type);\n-\t  ++cur;\n+\t  ++pos;\n \n-\t  while (ISIDNUM (*cur))\n-\t    ++cur;\n+\t  while (ISIDNUM (*pos))\n+\t    ++pos;\n \t}\n     }\n \n-  pfile->buffer->cur = cur;\n-  if (first_buff == NULL)\n-    create_literal (pfile, token, base, cur - base, type);\n+ out:\n+  pfile->buffer->cur = pos;\n+  if (!accum.accum)\n+    create_literal (pfile, token, base, pos - base, type);\n   else\n     {\n-      uchar *dest = _cpp_unaligned_alloc (pfile, total_len + (cur - base) + 1);\n+      size_t extra_len = pos - base;\n+      uchar *dest = _cpp_unaligned_alloc (pfile, accum.accum + extra_len + 1);\n \n       token->type = type;\n-      token->val.str.len = total_len + (cur - base);\n+      token->val.str.len = accum.accum + extra_len;\n       token->val.str.text = dest;\n-      last_buff = first_buff;\n-      while (last_buff != NULL)\n+      for (_cpp_buff *buf = accum.first; buf; buf = buf->next)\n \t{\n-\t  memcpy (dest, last_buff->base,\n-\t\t  BUFF_FRONT (last_buff) - last_buff->base);\n-\t  dest += BUFF_FRONT (last_buff) - last_buff->base;\n-\t  last_buff = last_buff->next;\n+\t  size_t len = BUFF_FRONT (buf) - buf->base;\n+\t  memcpy (dest, buf->base, len);\n+\t  dest += len;\n \t}\n-      _cpp_release_buff (pfile, first_buff);\n-      memcpy (dest, base, cur - base);\n-      dest[cur - base] = '\\0';\n+      _cpp_release_buff (pfile, accum.first);\n+      memcpy (dest, base, extra_len);\n+      dest[extra_len] = '\\0';\n     }\n }\n \n@@ -2003,7 +2027,7 @@ lex_string (cpp_reader *pfile, cpp_token *token, const uchar *base)\n     }\n   if (terminator == 'R')\n     {\n-      lex_raw_string (pfile, token, base, cur);\n+      lex_raw_string (pfile, token, base);\n       return;\n     }\n   if (terminator == '\"')"}]}