{"sha": "473574ee05f41d301c44713323b92a872f395508", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDczNTc0ZWUwNWY0MWQzMDFjNDQ3MTMzMjNiOTJhODcyZjM5NTUwOA==", "commit": {"author": {"name": "Steve Ellcey", "email": "sellcey@marvell.com", "date": "2019-01-11T16:50:17Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2019-01-11T16:50:17Z"}, "message": "aarch64.c (aarch64_simd_call_p): New function.\n\n2019-01-11  Steve Ellcey  <sellcey@marvell.com>\n\n\t* config/aarch64/aarch64.c (aarch64_simd_call_p): New function.\n\t(aarch64_hard_regno_call_part_clobbered): Add insn argument.\n\t(aarch64_return_call_with_max_clobbers): New function.\n\t(TARGET_RETURN_CALL_WITH_MAX_CLOBBERS): New macro.\n\t* config/avr/avr.c (avr_hard_regno_call_part_clobbered): Add insn\n\targument.\n\t* config/i386/i386.c (ix86_hard_regno_call_part_clobbered): Ditto.\n\t* config/mips/mips.c (mips_hard_regno_call_part_clobbered): Ditto.\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_call_part_clobbered): Ditto.\n\t* config/s390/s390.c (s390_hard_regno_call_part_clobbered): Ditto.\n\t* cselib.c (cselib_process_insn): Add argument to\n\ttargetm.hard_regno_call_part_clobbered call.\n\t* ira-conflicts.c (ira_build_conflicts): Ditto.\n\t* ira-costs.c (ira_tune_allocno_costs): Ditto.\n\t* lra-constraints.c (inherit_reload_reg): Ditto.\n\t* lra-int.h (struct lra_reg): Add call_insn field, remove call_p field.\n\t* lra-lives.c (check_pseudos_live_through_calls): Add call_insn\n\targument.  Call targetm.return_call_with_max_clobbers.\n\tAdd argument to targetm.hard_regno_call_part_clobbered call.\n\t(calls_have_same_clobbers_p): New function.\n\t(process_bb_lives): Add call_insn and last_call_insn variables.\n\tPass call_insn to check_pseudos_live_through_calls.\n\tModify if stmt to check targetm.return_call_with_max_clobbers.\n\tUpdate setting of flush variable.\n\t(lra_create_live_ranges_1): Set call_insn to NULL instead of call_p\n\tto false.\n\t* lra.c (initialize_lra_reg_info_element): Set call_insn to NULL.\n\t* regcprop.c (copyprop_hardreg_forward_1): Add argument to\n        targetm.hard_regno_call_part_clobbered call.\n\t* reginfo.c (choose_hard_reg_mode): Ditto.\n\t* regrename.c (check_new_reg_p): Ditto.\n\t* reload.c (find_equiv_reg): Ditto.\n\t* reload1.c (emit_reload_insns): Ditto.\n\t* sched-deps.c (deps_analyze_insn): Ditto.\n\t* sel-sched.c (init_regs_for_mode): Ditto.\n\t(mark_unavailable_hard_regs): Ditto.\n\t* targhooks.c (default_dwarf_frame_reg_mode): Ditto.\n\t* target.def (hard_regno_call_part_clobbered): Add insn argument.\n\t(return_call_with_max_clobbers): New target function.\n\t* doc/tm.texi: Regenerate.\n\t* doc/tm.texi.in (TARGET_RETURN_CALL_WITH_MAX_CLOBBERS): New hook.\n\t* hooks.c (hook_bool_uint_mode_false): Change to\n\thook_bool_insn_uint_mode_false.\n\t* hooks.h (hook_bool_uint_mode_false): Ditto.\n\nFrom-SVN: r267848", "tree": {"sha": "3ea1e075f7dbc24d457868f43921885fc322b63a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ea1e075f7dbc24d457868f43921885fc322b63a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/473574ee05f41d301c44713323b92a872f395508", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473574ee05f41d301c44713323b92a872f395508", "html_url": "https://github.com/Rust-GCC/gccrs/commit/473574ee05f41d301c44713323b92a872f395508", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473574ee05f41d301c44713323b92a872f395508/comments", "author": null, "committer": null, "parents": [{"sha": "134a6f7b107d265cfc55fd07744d9b8fd0283a0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/134a6f7b107d265cfc55fd07744d9b8fd0283a0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/134a6f7b107d265cfc55fd07744d9b8fd0283a0e"}], "stats": {"total": 260, "additions": 203, "deletions": 57}, "files": [{"sha": "42af06bbc4827724003e3eb9cda3261d9e82850e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -1,3 +1,50 @@\n+2019-01-11  Steve Ellcey  <sellcey@marvell.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_simd_call_p): New function.\n+\t(aarch64_hard_regno_call_part_clobbered): Add insn argument.\n+\t(aarch64_return_call_with_max_clobbers): New function.\n+\t(TARGET_RETURN_CALL_WITH_MAX_CLOBBERS): New macro.\n+\t* config/avr/avr.c (avr_hard_regno_call_part_clobbered): Add insn\n+\targument.\n+\t* config/i386/i386.c (ix86_hard_regno_call_part_clobbered): Ditto.\n+\t* config/mips/mips.c (mips_hard_regno_call_part_clobbered): Ditto.\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_call_part_clobbered): Ditto.\n+\t* config/s390/s390.c (s390_hard_regno_call_part_clobbered): Ditto.\n+\t* cselib.c (cselib_process_insn): Add argument to\n+\ttargetm.hard_regno_call_part_clobbered call.\n+\t* ira-conflicts.c (ira_build_conflicts): Ditto.\n+\t* ira-costs.c (ira_tune_allocno_costs): Ditto.\n+\t* lra-constraints.c (inherit_reload_reg): Ditto.\n+\t* lra-int.h (struct lra_reg): Add call_insn field, remove call_p field.\n+\t* lra-lives.c (check_pseudos_live_through_calls): Add call_insn\n+\targument.  Call targetm.return_call_with_max_clobbers.\n+\tAdd argument to targetm.hard_regno_call_part_clobbered call.\n+\t(calls_have_same_clobbers_p): New function.\n+\t(process_bb_lives): Add call_insn and last_call_insn variables.\n+\tPass call_insn to check_pseudos_live_through_calls.\n+\tModify if stmt to check targetm.return_call_with_max_clobbers.\n+\tUpdate setting of flush variable.\n+\t(lra_create_live_ranges_1): Set call_insn to NULL instead of call_p\n+\tto false.\n+\t* lra.c (initialize_lra_reg_info_element): Set call_insn to NULL.\n+\t* regcprop.c (copyprop_hardreg_forward_1): Add argument to\n+        targetm.hard_regno_call_part_clobbered call.\n+\t* reginfo.c (choose_hard_reg_mode): Ditto.\n+\t* regrename.c (check_new_reg_p): Ditto.\n+\t* reload.c (find_equiv_reg): Ditto.\n+\t* reload1.c (emit_reload_insns): Ditto.\n+\t* sched-deps.c (deps_analyze_insn): Ditto.\n+\t* sel-sched.c (init_regs_for_mode): Ditto.\n+\t(mark_unavailable_hard_regs): Ditto.\n+\t* targhooks.c (default_dwarf_frame_reg_mode): Ditto.\n+\t* target.def (hard_regno_call_part_clobbered): Add insn argument.\n+\t(return_call_with_max_clobbers): New target function.\n+\t* doc/tm.texi: Regenerate.\n+\t* doc/tm.texi.in (TARGET_RETURN_CALL_WITH_MAX_CLOBBERS): New hook.\n+\t* hooks.c (hook_bool_uint_mode_false): Change to\n+\thook_bool_insn_uint_mode_false.\n+\t* hooks.h (hook_bool_uint_mode_false): Ditto.\n+\n 2019-01-11  Steve Ellcey  <sellcey@marvell.com>\n \n \t* config/aarch64/aarch64.c (aarch64_simd_call_p): New function."}, {"sha": "fd60bddb1e1cbcb3dd46c319ccd182c7b9d1cd41", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -1699,9 +1699,25 @@ aarch64_remove_extra_call_preserved_regs (rtx_insn *insn,\n    clobbers the top 64 bits when restoring the bottom 64 bits.  */\n \n static bool\n-aarch64_hard_regno_call_part_clobbered (unsigned int regno, machine_mode mode)\n+aarch64_hard_regno_call_part_clobbered (rtx_insn *insn, unsigned int regno,\n+\t\t\t\t\tmachine_mode mode)\n {\n-  return FP_REGNUM_P (regno) && maybe_gt (GET_MODE_SIZE (mode), 8);\n+  bool simd_p = insn && CALL_P (insn) && aarch64_simd_call_p (insn);\n+  return FP_REGNUM_P (regno)\n+\t && maybe_gt (GET_MODE_SIZE (mode), simd_p ? 16 : 8);\n+}\n+\n+/* Implement TARGET_RETURN_CALL_WITH_MAX_CLOBBERS.  */\n+\n+rtx_insn *\n+aarch64_return_call_with_max_clobbers (rtx_insn *call_1, rtx_insn *call_2)\n+{\n+  gcc_assert (CALL_P (call_1) && CALL_P (call_2));\n+\n+  if (!aarch64_simd_call_p (call_1) || aarch64_simd_call_p (call_2))\n+    return call_1;\n+  else\n+    return call_2;\n }\n \n /* Implement REGMODE_NATURAL_SIZE.  */\n@@ -18868,6 +18884,10 @@ aarch64_libgcc_floating_mode_supported_p\n #define TARGET_REMOVE_EXTRA_CALL_PRESERVED_REGS \\\n   aarch64_remove_extra_call_preserved_regs\n \n+#undef TARGET_RETURN_CALL_WITH_MAX_CLOBBERS\n+#define TARGET_RETURN_CALL_WITH_MAX_CLOBBERS \\\n+  aarch64_return_call_with_max_clobbers\n+\n #undef TARGET_CONSTANT_ALIGNMENT\n #define TARGET_CONSTANT_ALIGNMENT aarch64_constant_alignment\n "}, {"sha": "a53b9092e2f6d76a8e02ff6db764f7406c8214a8", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -12181,7 +12181,8 @@ avr_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n /* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  */\n \n static bool\n-avr_hard_regno_call_part_clobbered (unsigned regno, machine_mode mode)\n+avr_hard_regno_call_part_clobbered (rtx_insn *insn ATTRIBUTE_UNUSED,\n+\t\t\t\t    unsigned regno, machine_mode mode)\n {\n   /* FIXME: This hook gets called with MODE:REGNO combinations that don't\n         represent valid hard registers like, e.g. HI:29.  Returning TRUE"}, {"sha": "1bb535a8d8184bd65f9c3bf9bfc4c58dfe75da13", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -40216,7 +40216,8 @@ ix86_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n    the low 16 bytes are saved.  */\n \n static bool\n-ix86_hard_regno_call_part_clobbered (unsigned int regno, machine_mode mode)\n+ix86_hard_regno_call_part_clobbered (rtx_insn *insn ATTRIBUTE_UNUSED,\n+\t\t\t\t     unsigned int regno, machine_mode mode)\n {\n   return SSE_REGNO_P (regno) && GET_MODE_SIZE (mode) > 16;\n }"}, {"sha": "a8022b88ae88b097fd52e3806730fe9e027bdbbd", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -12906,7 +12906,8 @@ mips_hard_regno_scratch_ok (unsigned int regno)\n    registers with MODE > 64 bits are part clobbered too.  */\n \n static bool\n-mips_hard_regno_call_part_clobbered (unsigned int regno, machine_mode mode)\n+mips_hard_regno_call_part_clobbered (rtx_insn *insn ATTRIBUTE_UNUSED,\n+\t\t\t\t     unsigned int regno, machine_mode mode)\n {\n   if (TARGET_FLOATXX\n       && hard_regno_nregs (regno, mode) == 1"}, {"sha": "3330b680d61b874f5d737145851ed2376f2c3815", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -2197,7 +2197,8 @@ rs6000_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n /* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  */\n \n static bool\n-rs6000_hard_regno_call_part_clobbered (unsigned int regno, machine_mode mode)\n+rs6000_hard_regno_call_part_clobbered (rtx_insn *insn ATTRIBUTE_UNUSED,\n+\t\t\t\t       unsigned int regno, machine_mode mode)\n {\n   if (TARGET_32BIT\n       && TARGET_POWERPC64"}, {"sha": "6a571a3e05438bb6e9db2797cdb367acd6f71177", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -10098,7 +10098,8 @@ s390_hard_regno_scratch_ok (unsigned int regno)\n    bytes are saved across calls, however.  */\n \n static bool\n-s390_hard_regno_call_part_clobbered (unsigned int regno, machine_mode mode)\n+s390_hard_regno_call_part_clobbered (rtx_insn *insn ATTRIBUTE_UNUSED,\n+\t\t\t\t     unsigned int regno, machine_mode mode)\n {\n   if (!TARGET_64BIT\n       && TARGET_ZARCH"}, {"sha": "84c17c23f6d54de3e62be8d9478473bc13909cad", "filename": "gcc/cselib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -2770,7 +2770,7 @@ cselib_process_insn (rtx_insn *insn)\n \tif (call_used_regs[i]\n \t    || (REG_VALUES (i) && REG_VALUES (i)->elt\n \t\t&& (targetm.hard_regno_call_part_clobbered\n-\t\t    (i, GET_MODE (REG_VALUES (i)->elt->val_rtx)))))\n+\t\t    (insn, i, GET_MODE (REG_VALUES (i)->elt->val_rtx)))))\n \t  cselib_invalidate_regno (i, reg_raw_mode[i]);\n \n       /* Since it is not clear how cselib is going to be used, be"}, {"sha": "07a4442f09a5693a9f3ee997636a6be6d32ca4a9", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -1894,12 +1894,14 @@ of @code{CALL_USED_REGISTERS}.\n @cindex call-used register\n @cindex call-clobbered register\n @cindex call-saved register\n-@deftypefn {Target Hook} bool TARGET_HARD_REGNO_CALL_PART_CLOBBERED (unsigned int @var{regno}, machine_mode @var{mode})\n+@deftypefn {Target Hook} bool TARGET_HARD_REGNO_CALL_PART_CLOBBERED (rtx_insn *@var{insn}, unsigned int @var{regno}, machine_mode @var{mode})\n This hook should return true if @var{regno} is partly call-saved and\n partly call-clobbered, and if a value of mode @var{mode} would be partly\n-clobbered by a call.  For example, if the low 32 bits of @var{regno} are\n-preserved across a call but higher bits are clobbered, this hook should\n-return true for a 64-bit mode but false for a 32-bit mode.\n+clobbered by call instruction @var{insn}.  If @var{insn} is NULL then it\n+should return true if any call could partly clobber the register.\n+For example, if the low 32 bits of @var{regno} are preserved across a call\n+but higher bits are clobbered, this hook should return true for a 64-bit\n+mode but false for a 32-bit mode.\n \n The default implementation returns false, which is correct\n for targets that don't have partly call-clobbered registers.\n@@ -1917,6 +1919,18 @@ This hook removes registers from the set of call-clobbered registers\n  Defining the hook is purely an optimization.\n @end deftypefn\n \n+@deftypefn {Target Hook} {rtx_insn *} TARGET_RETURN_CALL_WITH_MAX_CLOBBERS (rtx_insn *@var{call_1}, rtx_insn *@var{call_2})\n+This hook returns a pointer to the call that partially clobbers the\n+most registers.  If a platform supports multiple ABIs where the registers\n+that are partially clobbered may vary, this function compares two\n+calls and returns a pointer to the one that clobbers the most registers.\n+If both calls clobber the same registers, @var{call_1} must be returned.\n+\n+The registers clobbered in different ABIs must be a proper subset or\n+superset of all other ABIs.  @var{call_1} must always be a call insn,\n+call_2 may be NULL or a call insn.\n+@end deftypefn\n+\n @findex fixed_regs\n @findex call_used_regs\n @findex global_regs"}, {"sha": "41a6cb11cb0fe696b3033a0926c3ae715d65f2a2", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -1709,6 +1709,8 @@ of @code{CALL_USED_REGISTERS}.\n \n @hook TARGET_REMOVE_EXTRA_CALL_PRESERVED_REGS\n \n+@hook TARGET_RETURN_CALL_WITH_MAX_CLOBBERS\n+\n @findex fixed_regs\n @findex call_used_regs\n @findex global_regs"}, {"sha": "f95659b3807949c615f15ba36b7a1d55e49daa5e", "filename": "gcc/hooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -142,7 +142,7 @@ hook_bool_puint64_puint64_true (poly_uint64, poly_uint64)\n \n /* Generic hook that takes (unsigned int, machine_mode) and returns false.  */\n bool\n-hook_bool_uint_mode_false (unsigned int, machine_mode)\n+hook_bool_insn_uint_mode_false (rtx_insn *, unsigned int, machine_mode)\n {\n   return false;\n }"}, {"sha": "0bc8117c2c821c5e960c002dac04a2bedec4e673", "filename": "gcc/hooks.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -40,7 +40,8 @@ extern bool hook_bool_const_rtx_insn_const_rtx_insn_true (const rtx_insn *,\n extern bool hook_bool_mode_uhwi_false (machine_mode,\n \t\t\t\t       unsigned HOST_WIDE_INT);\n extern bool hook_bool_puint64_puint64_true (poly_uint64, poly_uint64);\n-extern bool hook_bool_uint_mode_false (unsigned int, machine_mode);\n+extern bool hook_bool_insn_uint_mode_false (rtx_insn *, unsigned int,\n+\t\t\t\t\t    machine_mode);\n extern bool hook_bool_uint_mode_true (unsigned int, machine_mode);\n extern bool hook_bool_tree_false (tree);\n extern bool hook_bool_const_tree_false (const_tree);"}, {"sha": "5bd6c0c3d7a864bc6b5e20f33e333ab2b45e4e89", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -808,7 +808,7 @@ ira_build_conflicts (void)\n \t\t regs must conflict with them.  */\n \t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t\tif (!TEST_HARD_REG_BIT (call_used_reg_set, regno)\n-\t\t    && targetm.hard_regno_call_part_clobbered (regno,\n+\t\t    && targetm.hard_regno_call_part_clobbered (NULL, regno,\n \t\t\t\t\t\t\t       obj_mode))\n \t\t  {\n \t\t    SET_HARD_REG_BIT (OBJECT_CONFLICT_HARD_REGS (obj), regno);"}, {"sha": "a17dae3302cd61a441705a895542c04ffccc0eee", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -2379,7 +2379,7 @@ ira_tune_allocno_costs (void)\n \t\t\t\t\t\t   *crossed_calls_clobber_regs)\n \t\t  && (ira_hard_reg_set_intersection_p (regno, mode,\n \t\t\t\t\t\t       call_used_reg_set)\n-\t\t      || targetm.hard_regno_call_part_clobbered (regno,\n+\t\t      || targetm.hard_regno_call_part_clobbered (NULL, regno,\n \t\t\t\t\t\t\t\t mode)))\n \t\tcost += (ALLOCNO_CALL_FREQ (a)\n \t\t\t * (ira_memory_move_cost[mode][rclass][0]"}, {"sha": "bcd81450c06eb224c18af96e848b6ef0b41b965b", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -1640,7 +1640,7 @@ lra_assign (bool &fails_p)\n        asm is removed and it can result in incorrect allocation.  */\n     for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n       if (lra_reg_info[i].nrefs != 0 && reg_renumber[i] >= 0\n-\t  && lra_reg_info[i].call_p\n+\t  && lra_reg_info[i].call_insn\n \t  && overlaps_hard_reg_set_p (call_used_reg_set,\n \t\t\t\t      PSEUDO_REGNO_MODE (i), reg_renumber[i]))\n \tgcc_unreachable ();"}, {"sha": "0ef13439b5055dd2c5d5049d7f62f6b3b1ddfe2a", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -5379,7 +5379,8 @@ need_for_call_save_p (int regno)\n \t       : call_used_reg_set,\n \t       PSEUDO_REGNO_MODE (regno), reg_renumber[regno])\n \t      || (targetm.hard_regno_call_part_clobbered\n-\t\t  (reg_renumber[regno], PSEUDO_REGNO_MODE (regno)))));\n+\t\t  (lra_reg_info[regno].call_insn,\n+\t\t   reg_renumber[regno], PSEUDO_REGNO_MODE (regno)))));\n }\n \n /* Global registers occurring in the current EBB.  */"}, {"sha": "d0a8facc50e5ec429fa5e3b6ddb0ef80fe6b22c7", "filename": "gcc/lra-int.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -91,10 +91,6 @@ struct lra_reg\n   /* True if the pseudo should not be assigned to a stack register.  */\n   bool no_stack_p;\n #endif\n-  /* True if the pseudo crosses a call.\t It is setup in lra-lives.c\n-     and used to check that the pseudo crossing a call did not get a\n-     call used hard register.  */\n-  bool call_p;\n   /* Number of references and execution frequencies of the register in\n      *non-debug* insns.\t */\n   int nrefs, freq;\n@@ -107,6 +103,8 @@ struct lra_reg\n   int val;\n   /* Offset from relative eliminate register to pesudo reg.  */\n   poly_int64 offset;\n+  /* Call instruction, if any, that may affect this psuedo reg.  */\n+  rtx_insn *call_insn;\n   /* These members are set up in lra-lives.c and updated in\n      lra-coalesce.c.  */\n   /* The biggest size mode in which each pseudo reg is referred in"}, {"sha": "55b2adc2a5beca5953ffbc276041440e563337aa", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 51, "deletions": 13, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -576,25 +576,39 @@ lra_setup_reload_pseudo_preferenced_hard_reg (int regno,\n \n /* Check that REGNO living through calls and setjumps, set up conflict\n    regs using LAST_CALL_USED_REG_SET, and clear corresponding bits in\n-   PSEUDOS_LIVE_THROUGH_CALLS and PSEUDOS_LIVE_THROUGH_SETJUMPS.  */\n+   PSEUDOS_LIVE_THROUGH_CALLS and PSEUDOS_LIVE_THROUGH_SETJUMPS.\n+   CALL_INSN is a call that is representative of all calls in the region\n+   described by the PSEUDOS_LIVE_THROUGH_* sets, in terms of the registers\n+   that it preserves and clobbers.  */\n+\n static inline void\n check_pseudos_live_through_calls (int regno,\n-\t\t\t\t  HARD_REG_SET last_call_used_reg_set)\n+\t\t\t\t  HARD_REG_SET last_call_used_reg_set,\n+\t\t\t\t  rtx_insn *call_insn)\n {\n   int hr;\n+  rtx_insn *old_call_insn;\n \n   if (! sparseset_bit_p (pseudos_live_through_calls, regno))\n     return;\n+\n+  gcc_assert (call_insn && CALL_P (call_insn));\n+  old_call_insn = lra_reg_info[regno].call_insn;\n+  if (!old_call_insn\n+      || (targetm.return_call_with_max_clobbers\n+\t  && targetm.return_call_with_max_clobbers (old_call_insn, call_insn)\n+\t     == call_insn))\n+    lra_reg_info[regno].call_insn = call_insn;\n+\n   sparseset_clear_bit (pseudos_live_through_calls, regno);\n   IOR_HARD_REG_SET (lra_reg_info[regno].conflict_hard_regs,\n \t\t    last_call_used_reg_set);\n \n   for (hr = 0; HARD_REGISTER_NUM_P (hr); hr++)\n-    if (targetm.hard_regno_call_part_clobbered (hr,\n+    if (targetm.hard_regno_call_part_clobbered (call_insn, hr,\n \t\t\t\t\t\tPSEUDO_REGNO_MODE (regno)))\n       add_to_hard_reg_set (&lra_reg_info[regno].conflict_hard_regs,\n \t\t\t   PSEUDO_REGNO_MODE (regno), hr);\n-  lra_reg_info[regno].call_p = true;\n   if (! sparseset_bit_p (pseudos_live_through_setjumps, regno))\n     return;\n   sparseset_clear_bit (pseudos_live_through_setjumps, regno);\n@@ -615,6 +629,19 @@ reg_early_clobber_p (const struct lra_insn_reg *reg, int n_alt)\n \t\t  && TEST_BIT (reg->early_clobber_alts, n_alt))));\n }\n \n+/* Return true if call instructions CALL1 and CALL2 use ABIs that\n+   preserve the same set of registers.  */\n+\n+static bool\n+calls_have_same_clobbers_p (rtx_insn *call1, rtx_insn *call2)\n+{\n+  if (!targetm.return_call_with_max_clobbers)\n+    return false;\n+\n+  return (targetm.return_call_with_max_clobbers (call1, call2) == call1\n+          && targetm.return_call_with_max_clobbers (call2, call1) == call2);\n+}\n+\n /* Process insns of the basic block BB to update pseudo live ranges,\n    pseudo hard register conflicts, and insn notes.  We do it on\n    backward scan of BB insns.  CURR_POINT is the program point where\n@@ -635,6 +662,8 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n   rtx link, *link_loc;\n   bool need_curr_point_incr;\n   HARD_REG_SET last_call_used_reg_set;\n+  rtx_insn *call_insn = NULL;\n+  rtx_insn *last_call_insn = NULL;\n \n   reg_live_out = df_get_live_out (bb);\n   sparseset_clear (pseudos_live);\n@@ -847,7 +876,8 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t      update_pseudo_point (reg->regno, curr_point, USE_POINT);\n \t      mark_regno_live (reg->regno, reg->biggest_mode);\n \t      check_pseudos_live_through_calls (reg->regno,\n-\t\t\t\t\t\tlast_call_used_reg_set);\n+\t\t\t\t\t\tlast_call_used_reg_set,\n+\t\t\t\t\t\tcall_insn);\n \t    }\n \n \t  if (!HARD_REGISTER_NUM_P (reg->regno))\n@@ -896,7 +926,8 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \n       if (call_p)\n \t{\n-\t  if (! flag_ipa_ra)\n+\t  call_insn = curr_insn;\n+\t  if (! flag_ipa_ra && ! targetm.return_call_with_max_clobbers)\n \t    COPY_HARD_REG_SET(last_call_used_reg_set, call_used_reg_set);\n \t  else\n \t    {\n@@ -905,18 +936,24 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t\t\t\t      call_used_reg_set);\n \n \t      bool flush = (! hard_reg_set_empty_p (last_call_used_reg_set)\n-\t\t\t    && ! hard_reg_set_equal_p (last_call_used_reg_set,\n-\t\t\t\t\t\t       this_call_used_reg_set));\n+\t\t\t    && ( ! hard_reg_set_equal_p (last_call_used_reg_set,\n+\t\t\t\t\t\t       this_call_used_reg_set)))\n+\t\t\t   || (last_call_insn && ! calls_have_same_clobbers_p\n+\t\t\t\t\t\t     (call_insn,\n+\t\t\t\t\t\t      last_call_insn));\n \n \t      EXECUTE_IF_SET_IN_SPARSESET (pseudos_live, j)\n \t\t{\n \t\t  IOR_HARD_REG_SET (lra_reg_info[j].actual_call_used_reg_set,\n \t\t\t\t    this_call_used_reg_set);\n+\n \t\t  if (flush)\n-\t\t    check_pseudos_live_through_calls\n-\t\t      (j, last_call_used_reg_set);\n+\t\t    check_pseudos_live_through_calls (j,\n+\t\t\t\t\t\t      last_call_used_reg_set,\n+\t\t\t\t\t\t      last_call_insn);\n \t\t}\n \t      COPY_HARD_REG_SET(last_call_used_reg_set, this_call_used_reg_set);\n+\t      last_call_insn = call_insn;\n \t    }\n \n \t  sparseset_ior (pseudos_live_through_calls,\n@@ -956,7 +993,8 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t      update_pseudo_point (reg->regno, curr_point, USE_POINT);\n \t    mark_regno_live (reg->regno, reg->biggest_mode);\n \t    check_pseudos_live_through_calls (reg->regno,\n-\t\t\t\t\t      last_call_used_reg_set);\n+\t\t\t\t\t      last_call_used_reg_set,\n+\t\t\t\t\t      call_insn);\n \t  }\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n@@ -1125,7 +1163,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       if (sparseset_cardinality (pseudos_live_through_calls) == 0)\n \tbreak;\n       if (sparseset_bit_p (pseudos_live_through_calls, j))\n-\tcheck_pseudos_live_through_calls (j, last_call_used_reg_set);\n+\tcheck_pseudos_live_through_calls (j, last_call_used_reg_set, call_insn);\n     }\n \n   for (i = 0; HARD_REGISTER_NUM_P (i); ++i)\n@@ -1359,7 +1397,7 @@ lra_create_live_ranges_1 (bool all_p, bool dead_insn_p)\n \tlra_reg_info[i].biggest_mode = GET_MODE (regno_reg_rtx[i]);\n       else\n \tlra_reg_info[i].biggest_mode = VOIDmode;\n-      lra_reg_info[i].call_p = false;\n+      lra_reg_info[i].call_insn = NULL;\n       if (!HARD_REGISTER_NUM_P (i)\n \t  && lra_reg_info[i].nrefs != 0)\n \t{"}, {"sha": "e00e6e77e9f8f24528d84794a9b7fa9bb763db2d", "filename": "gcc/lra.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -1344,6 +1344,7 @@ initialize_lra_reg_info_element (int i)\n   lra_reg_info[i].val = get_new_reg_value ();\n   lra_reg_info[i].offset = 0;\n   lra_reg_info[i].copies = NULL;\n+  lra_reg_info[i].call_insn = NULL;\n }\n \n /* Initialize common reg info and copies.  */"}, {"sha": "e6bdeb07d8fc1960038318ee66aecca68b3120d1", "filename": "gcc/regcprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -1054,7 +1054,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t    if ((TEST_HARD_REG_BIT (regs_invalidated_by_this_call, regno)\n \t\t || (targetm.hard_regno_call_part_clobbered\n-\t\t     (regno, vd->e[regno].mode)))\n+\t\t     (insn, regno, vd->e[regno].mode)))\n \t\t&& (regno < set_regno || regno >= set_regno + set_nregs))\n \t      kill_value_regno (regno, 1, vd);\n "}, {"sha": "315c5ecabe6d7bb220f3accc8b01674876606605", "filename": "gcc/reginfo.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -639,31 +639,31 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n     if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n-\t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n+\t    || !targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n \t&& maybe_gt (GET_MODE_SIZE (mode), GET_MODE_SIZE (found_mode)))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_FLOAT)\n     if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n-\t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n+\t    || !targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n \t&& maybe_gt (GET_MODE_SIZE (mode), GET_MODE_SIZE (found_mode)))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_FLOAT)\n     if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n-\t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n+\t    || !targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n \t&& maybe_gt (GET_MODE_SIZE (mode), GET_MODE_SIZE (found_mode)))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_INT)\n     if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n-\t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n+\t    || !targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n \t&& maybe_gt (GET_MODE_SIZE (mode), GET_MODE_SIZE (found_mode)))\n       found_mode = mode;\n \n@@ -677,7 +677,7 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n       if (hard_regno_nregs (regno, mode) == nregs\n \t  && targetm.hard_regno_mode_ok (regno, mode)\n \t  && (!call_saved\n-\t      || !targetm.hard_regno_call_part_clobbered (regno, mode)))\n+\t      || !targetm.hard_regno_call_part_clobbered (NULL, regno, mode)))\n \treturn mode;\n     }\n "}, {"sha": "637b3cbe6d74bd0c09165529fc40985354563a9a", "filename": "gcc/regrename.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -339,9 +339,9 @@ check_new_reg_p (int reg ATTRIBUTE_UNUSED, int new_reg,\n \t && ! DEBUG_INSN_P (tmp->insn))\n \t|| (this_head->need_caller_save_reg\n \t    && ! (targetm.hard_regno_call_part_clobbered\n-\t\t  (reg, GET_MODE (*tmp->loc)))\n+\t\t  (NULL, reg, GET_MODE (*tmp->loc)))\n \t    && (targetm.hard_regno_call_part_clobbered\n-\t\t(new_reg, GET_MODE (*tmp->loc)))))\n+\t\t(NULL, new_reg, GET_MODE (*tmp->loc)))))\n       return false;\n \n   return true;"}, {"sha": "72cc38a0e093b93cc9785ad9f47e0c185ce74651", "filename": "gcc/reload.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -6912,13 +6912,14 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n \t  if (regno >= 0 && regno < FIRST_PSEUDO_REGISTER)\n \t    for (i = 0; i < nregs; ++i)\n \t      if (call_used_regs[regno + i]\n-\t\t  || targetm.hard_regno_call_part_clobbered (regno + i, mode))\n+\t\t  || targetm.hard_regno_call_part_clobbered (NULL, regno + i,\n+\t\t\t\t\t\t\t     mode))\n \t\treturn 0;\n \n \t  if (valueno >= 0 && valueno < FIRST_PSEUDO_REGISTER)\n \t    for (i = 0; i < valuenregs; ++i)\n \t      if (call_used_regs[valueno + i]\n-\t\t  || targetm.hard_regno_call_part_clobbered (valueno + i,\n+\t\t  || targetm.hard_regno_call_part_clobbered (NULL, valueno + i,\n \t\t\t\t\t\t\t     mode))\n \t\treturn 0;\n \t}"}, {"sha": "bb112d817cf596d997ea8fc64a29d09228a0bdf6", "filename": "gcc/reload1.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -8289,7 +8289,8 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t\t   : out_regno + k);\n \t\t      reg_reloaded_insn[regno + k] = insn;\n \t\t      SET_HARD_REG_BIT (reg_reloaded_valid, regno + k);\n-\t\t      if (targetm.hard_regno_call_part_clobbered (regno + k,\n+\t\t      if (targetm.hard_regno_call_part_clobbered (NULL,\n+\t\t\t\t\t\t\t\t  regno + k,\n \t\t\t\t\t\t\t\t  mode))\n \t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n \t\t\t\t\t  regno + k);\n@@ -8369,7 +8370,8 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t\t   : in_regno + k);\n \t\t      reg_reloaded_insn[regno + k] = insn;\n \t\t      SET_HARD_REG_BIT (reg_reloaded_valid, regno + k);\n-\t\t      if (targetm.hard_regno_call_part_clobbered (regno + k,\n+\t\t      if (targetm.hard_regno_call_part_clobbered (NULL,\n+\t\t\t\t\t\t\t\t  regno + k,\n \t\t\t\t\t\t\t\t  mode))\n \t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n \t\t\t\t\t  regno + k);\n@@ -8485,7 +8487,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t      CLEAR_HARD_REG_BIT (reg_reloaded_dead, src_regno + k);\n \t\t      SET_HARD_REG_BIT (reg_reloaded_valid, src_regno + k);\n \t\t      if (targetm.hard_regno_call_part_clobbered\n-\t\t\t  (src_regno + k, mode))\n+\t\t\t  (NULL, src_regno + k, mode))\n \t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered,\n \t\t\t\t\t  src_regno + k);\n \t\t      else"}, {"sha": "6cf4cafbff303ef6e2278344aa48102588f2717c", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -3728,7 +3728,7 @@ deps_analyze_insn (struct deps_desc *deps, rtx_insn *insn)\n              Since we only have a choice between 'might be clobbered'\n              and 'definitely not clobbered', we must include all\n              partly call-clobbered registers here.  */\n-\t    else if (targetm.hard_regno_call_part_clobbered (i,\n+\t    else if (targetm.hard_regno_call_part_clobbered (insn, i,\n \t\t\t\t\t\t\t     reg_raw_mode[i])\n                      || TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n               SET_REGNO_REG_SET (reg_pending_clobbers, i);"}, {"sha": "315f2c0c0ab41b649b6404ae5ee605f00d1d6830", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -1102,7 +1102,7 @@ init_regs_for_mode (machine_mode mode)\n       if (i >= 0)\n         continue;\n \n-      if (targetm.hard_regno_call_part_clobbered (cur_reg, mode))\n+      if (targetm.hard_regno_call_part_clobbered (NULL, cur_reg, mode))\n         SET_HARD_REG_BIT (sel_hrd.regs_for_call_clobbered[mode],\n                           cur_reg);\n \n@@ -1251,7 +1251,7 @@ mark_unavailable_hard_regs (def_t def, struct reg_rename *reg_rename_p,\n \n   /* Exclude registers that are partially call clobbered.  */\n   if (def->crosses_call\n-      && !targetm.hard_regno_call_part_clobbered (regno, mode))\n+      && !targetm.hard_regno_call_part_clobbered (NULL, regno, mode))\n     AND_COMPL_HARD_REG_SET (reg_rename_p->available_for_renaming,\n                             sel_hrd.regs_for_call_clobbered[mode]);\n "}, {"sha": "ebda60e52ca23c543b270fc57f349c096aa51855", "filename": "gcc/target.def", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -5766,14 +5766,30 @@ DEFHOOK\n (hard_regno_call_part_clobbered,\n  \"This hook should return true if @var{regno} is partly call-saved and\\n\\\n partly call-clobbered, and if a value of mode @var{mode} would be partly\\n\\\n-clobbered by a call.  For example, if the low 32 bits of @var{regno} are\\n\\\n-preserved across a call but higher bits are clobbered, this hook should\\n\\\n-return true for a 64-bit mode but false for a 32-bit mode.\\n\\\n+clobbered by call instruction @var{insn}.  If @var{insn} is NULL then it\\n\\\n+should return true if any call could partly clobber the register.\\n\\\n+For example, if the low 32 bits of @var{regno} are preserved across a call\\n\\\n+but higher bits are clobbered, this hook should return true for a 64-bit\\n\\\n+mode but false for a 32-bit mode.\\n\\\n \\n\\\n The default implementation returns false, which is correct\\n\\\n for targets that don't have partly call-clobbered registers.\",\n- bool, (unsigned int regno, machine_mode mode),\n- hook_bool_uint_mode_false)\n+ bool, (rtx_insn *insn, unsigned int regno, machine_mode mode),\n+ hook_bool_insn_uint_mode_false)\n+\n+DEFHOOK\n+(return_call_with_max_clobbers,\n+ \"This hook returns a pointer to the call that partially clobbers the\\n\\\n+most registers.  If a platform supports multiple ABIs where the registers\\n\\\n+that are partially clobbered may vary, this function compares two\\n\\\n+calls and returns a pointer to the one that clobbers the most registers.\\n\\\n+If both calls clobber the same registers, @var{call_1} must be returned.\\n\\\n+\\n\\\n+The registers clobbered in different ABIs must be a proper subset or\\n\\\n+superset of all other ABIs.  @var{call_1} must always be a call insn,\\n\\\n+call_2 may be NULL or a call insn.\",\n+ rtx_insn *, (rtx_insn *call_1, rtx_insn *call_2),\n+ NULL)\n \n DEFHOOK\n (remove_extra_call_preserved_regs,"}, {"sha": "529590b55df064371d51e0ae0e0570615eb5276c", "filename": "gcc/targhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/473574ee05f41d301c44713323b92a872f395508/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/473574ee05f41d301c44713323b92a872f395508/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=473574ee05f41d301c44713323b92a872f395508", "patch": "@@ -1930,7 +1930,7 @@ default_dwarf_frame_reg_mode (int regno)\n {\n   machine_mode save_mode = reg_raw_mode[regno];\n \n-  if (targetm.hard_regno_call_part_clobbered (regno, save_mode))\n+  if (targetm.hard_regno_call_part_clobbered (NULL, regno, save_mode))\n     save_mode = choose_hard_reg_mode (regno, 1, true);\n   return save_mode;\n }"}]}