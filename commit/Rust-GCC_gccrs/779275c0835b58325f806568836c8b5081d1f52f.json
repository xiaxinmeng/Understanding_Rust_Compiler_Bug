{"sha": "779275c0835b58325f806568836c8b5081d1f52f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc5Mjc1YzA4MzViNTgzMjVmODA2NTY4ODM2YzhiNTA4MWQxZjUyZg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-03T08:57:33Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-03T15:19:54Z"}, "message": "Improve backwards threader debugging dumps.\n\nThis patch adds debugging helpers to the backwards threader.  I have\nalso noticed that profitable_path_p() can bail early on paths that\ncrosses loops and leave the dump of blocks incomplete.  Fixed as\nwell.\n\nUnfortunately the new methods cannot be marked const, because we call\nthe solver's dump which is not const.  I believe this was because the\nranger dump calls m_cache.block_range().  This could probably use a\ncleanup at a later time.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-threadbackward.c (back_threader::dump): New.\n\t(back_threader::debug): New.\n\t(back_threader_profitability::profitable_path_p): Dump blocks\n\teven if we are bailing early.", "tree": {"sha": "0de8f433344a2410254741114a2822fbb60c418d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0de8f433344a2410254741114a2822fbb60c418d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/779275c0835b58325f806568836c8b5081d1f52f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/779275c0835b58325f806568836c8b5081d1f52f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/779275c0835b58325f806568836c8b5081d1f52f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/779275c0835b58325f806568836c8b5081d1f52f/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3ff15afb4c697117aa8916c47b358045dbf0fe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3ff15afb4c697117aa8916c47b358045dbf0fe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3ff15afb4c697117aa8916c47b358045dbf0fe9"}], "stats": {"total": 35, "additions": 35, "deletions": 0}, "files": [{"sha": "b9a0d9a60ad5756246512134b64a6baf77140096", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/779275c0835b58325f806568836c8b5081d1f52f/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/779275c0835b58325f806568836c8b5081d1f52f/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=779275c0835b58325f806568836c8b5081d1f52f", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-range-path.h\"\n #include \"ssa.h\"\n #include \"tree-cfgcleanup.h\"\n+#include \"tree-pretty-print.h\"\n \n // Path registry for the backwards threader.  After all paths have been\n // registered with register_path(), thread_through_all_blocks() is called\n@@ -89,6 +90,8 @@ class back_threader\n   edge find_taken_edge (const vec<basic_block> &path);\n   edge find_taken_edge_cond (const vec<basic_block> &path, gcond *);\n   edge find_taken_edge_switch (const vec<basic_block> &path, gswitch *);\n+  virtual void debug ();\n+  virtual void dump (FILE *out);\n \n   back_threader_registry m_registry;\n   back_threader_profitability m_profit;\n@@ -519,6 +522,30 @@ debug (const vec <basic_block> &path)\n   dump_path (stderr, path);\n }\n \n+void\n+back_threader::dump (FILE *out)\n+{\n+  m_solver.dump (out);\n+  fprintf (out, \"\\nCandidates for pre-computation:\\n\");\n+  fprintf (out, \"===================================\\n\");\n+\n+  bitmap_iterator bi;\n+  unsigned i;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (m_imports, 0, i, bi)\n+    {\n+      tree name = ssa_name (i);\n+      print_generic_expr (out, name, TDF_NONE);\n+      fprintf (out, \"\\n\");\n+    }\n+}\n+\n+void\n+back_threader::debug ()\n+{\n+  dump (stderr);\n+}\n+\n back_threader_registry::back_threader_registry (int max_allowable_paths)\n   : m_max_allowable_paths (max_allowable_paths)\n {\n@@ -607,6 +634,14 @@ back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n \t  if (bb->loop_father != loop)\n \t    {\n \t      path_crosses_loops = true;\n+\n+\t      // Dump rest of blocks.\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfor (j++; j < m_path.length (); j++)\n+\t\t  {\n+\t\t    bb = m_path[j];\n+\t\t    fprintf (dump_file, \" bb:%i\", bb->index);\n+\t\t  }\n \t      break;\n \t    }\n "}]}