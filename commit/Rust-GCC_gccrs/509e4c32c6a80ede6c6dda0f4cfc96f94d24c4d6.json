{"sha": "509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6", "node_id": "C_kwDOANBUbNoAKDUwOWU0YzMyYzZhODBlZGU2YzZkZGEwZjRjZmM5NmY5NGQyNGM0ZDY", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-23T15:36:29Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:06Z"}, "message": "gccrs: Add metadata output pass\n\nExtern crates statements to tell the front-end to look for another library.\nThe mechanism here is heavily inspired from gccgo, so when we compile a\nlibrary for example we invoke:\n\n  gccrs -g -O2 -frust-crate=mylib -c src/lib.rs -o src/mylib.o\n\nAll going well this object file will now contain extra data inside\n.rust-export section inside the object file which will be preserved inside\narchives and shared objects. When we have another application which uses\nthis library 'mylib'.\n\n  extern crate mylib;\n  use mylib::foo;\n\n  fn main() {\n    foo();\n  }\n\nWe compile using:\n\n  gcc -g -O2 -frust-crate=test -c src/main.rs -o src/main.o\n\nWhen the extern crate line is hit the front-end will look for mylib.o,\nlibmylib.a, mylib.rox. If it finds a raw object file it will read the\n.rust-export section directly from the object for the public metadata\nsuch as public functions, types constants etc. If it fails to find an\nobject it might find .rox which is the objdump of the .rust-export to a\nraw file, it might even find libmylib.a and read the export directly out\nof the archive file reusing code from gccgo to do so.\n\nThe full compiler pipeline is reused here, so the metatadata is actually\njust real rust code. The benifit here is that Rust supports exporting,\nmacros and generics so this requires the name-resolution and type info\nall to be generated and inserted into the apropriate context classes. Since\nthe metadata is real rust code it means we can reuse the full pipeline to\ngenerate the code as necessary. So for the simple case of a public struct\nwe simply emit the AST dump of this struct directly into the metadata. If\nits a non-generic public function we emit and extern rust abi block for\nthat function. If its a trait we can simply emit the trait with the public\nmemebers. Generics are more complicated since we need to emit the function\nfully for it to be compiled correctly this still needs tests to be added.\nThe hardest part is non generic impl blocks which is still a WIP.\n\nTo finally link the two crates together you run:\n\n  gcc -g -O2 -o rust-program.exe src/main.o src/mylib.o\n\n\tgcc/rust/\n\t* metadata/rust-export-metadata.cc: New.\n\t* metadata/rust-export-metadata.h: New.\n\t* metadata/rust-extern-crate.cc: New.\n\t* metadata/rust-extern-crate.h: New.\n\t* metadata/rust-import-archive.cc: New.\n\t* metadata/rust-imports.cc: New.\n\t* metadata/rust-imports.h: New.\n\t* rust-object-export.cc: New.\n\t* rust-object-export.h: New.", "tree": {"sha": "3f7098374abe40dd509147ba01526ffad98e6b36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f7098374abe40dd509147ba01526ffad98e6b36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d67468d1d40f4d60a3760d47b74912c13621ada", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d67468d1d40f4d60a3760d47b74912c13621ada", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d67468d1d40f4d60a3760d47b74912c13621ada"}], "stats": {"total": 2490, "additions": 2490, "deletions": 0}, "files": [{"sha": "4856bc26149a12584dfdf57203344ff77782a6e9", "filename": "gcc/rust/metadata/rust-export-metadata.cc", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Fmetadata%2Frust-export-metadata.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Fmetadata%2Frust-export-metadata.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-export-metadata.cc?ref=509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6", "patch": "@@ -0,0 +1,385 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-export-metadata.h\"\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-ast-dump.h\"\n+#include \"rust-abi.h\"\n+#include \"rust-object-export.h\"\n+\n+#include \"md5.h\"\n+\n+namespace Rust {\n+namespace Metadata {\n+\n+static const std::string extension_path = \".rox\";\n+\n+ExportContext::ExportContext () : mappings (Analysis::Mappings::get ()) {}\n+\n+ExportContext::~ExportContext () {}\n+\n+void\n+ExportContext::push_module_scope (const HIR::Module &module)\n+{\n+  module_stack.push_back (module);\n+}\n+\n+const HIR::Module &\n+ExportContext::pop_module_scope ()\n+{\n+  rust_assert (!module_stack.empty ());\n+  const HIR::Module &poped = module_stack.back ();\n+  module_stack.pop_back ();\n+  return poped;\n+}\n+\n+void\n+ExportContext::emit_trait (const HIR::Trait &trait)\n+{\n+  // lookup the AST node for this\n+  AST::Item *item = nullptr;\n+  bool ok\n+    = mappings->lookup_ast_item (trait.get_mappings ().get_nodeid (), &item);\n+  rust_assert (ok);\n+\n+  std::stringstream oss;\n+  AST::Dump dumper (oss);\n+  dumper.go (*item);\n+\n+  public_interface_buffer += oss.str ();\n+}\n+\n+void\n+ExportContext::emit_function (const HIR::Function &fn)\n+{\n+  // lookup the AST node for this\n+  AST::Item *item = nullptr;\n+  bool ok = mappings->lookup_ast_item (fn.get_mappings ().get_nodeid (), &item);\n+  rust_assert (ok);\n+\n+  // is this a CFG macro or not\n+  if (item->is_marked_for_strip ())\n+    return;\n+\n+  // FIXME add assertion that item must be a vis_item;\n+  AST::VisItem &vis_item = static_cast<AST::VisItem &> (*item);\n+\n+  // if its a generic function we need to output the full declaration\n+  // otherwise we can let people link against this\n+\n+  std::stringstream oss;\n+  AST::Dump dumper (oss);\n+  if (!fn.has_generics ())\n+    {\n+      // FIXME assert that this is actually an AST::Function\n+      AST::Function &function = static_cast<AST::Function &> (vis_item);\n+\n+      // we can emit an extern block with abi of \"rust\"\n+      Identifier item_name = function.get_function_name ();\n+\n+      // always empty for extern linkage\n+      AST::WhereClause where_clause = AST::WhereClause::create_empty ();\n+      std::vector<std::unique_ptr<AST::GenericParam>> generic_params;\n+\n+      AST::Visibility vis = function.get_visibility ();\n+      std::unique_ptr<AST::Type> return_type\n+\t= std::unique_ptr<AST::Type> (nullptr);\n+      if (function.has_return_type ())\n+\t{\n+\t  return_type = function.get_return_type ()->clone_type ();\n+\t}\n+\n+      std::vector<AST::NamedFunctionParam> function_params;\n+      for (AST::FunctionParam &param : function.get_function_params ())\n+\t{\n+\t  std::string name = param.get_pattern ()->as_string ();\n+\t  std::unique_ptr<AST::Type> param_type\n+\t    = param.get_type ()->clone_type ();\n+\n+\t  AST::NamedFunctionParam p (name, std::move (param_type), {},\n+\t\t\t\t     param.get_locus ());\n+\t  function_params.push_back (std::move (p));\n+\t}\n+\n+      AST::ExternalItem *external_item = new AST::ExternalFunctionItem (\n+\titem_name, {} /* generic_params */, std::move (return_type),\n+\twhere_clause, std::move (function_params), false /* has_variadics */,\n+\t{} /* variadic_outer_attrs */, vis, function.get_outer_attrs (),\n+\tfunction.get_locus ());\n+\n+      std::vector<std::unique_ptr<AST::ExternalItem>> external_items;\n+      external_items.push_back (\n+\tstd::unique_ptr<AST::ExternalItem> (external_item));\n+\n+      AST::ExternBlock extern_block (get_string_from_abi (Rust::ABI::RUST),\n+\t\t\t\t     std::move (external_items),\n+\t\t\t\t     vis_item.get_visibility (), {}, {},\n+\t\t\t\t     fn.get_locus ());\n+\n+      dumper.go (extern_block);\n+    }\n+  else\n+    {\n+      dumper.go (*item);\n+    }\n+\n+  // store the dump\n+  public_interface_buffer += oss.str ();\n+}\n+\n+const std::string &\n+ExportContext::get_interface_buffer () const\n+{\n+  return public_interface_buffer;\n+}\n+\n+// implicitly by using HIR nodes we know that these have passed CFG expansion\n+// and they exist in the compilation unit\n+class ExportVisItems : public HIR::HIRVisItemVisitor\n+{\n+public:\n+  ExportVisItems (ExportContext &context) : ctx (context) {}\n+\n+  void visit (HIR::Module &module) override {}\n+  void visit (HIR::ExternCrate &crate) override {}\n+  void visit (HIR::UseDeclaration &use_decl) override {}\n+  void visit (HIR::TypeAlias &type_alias) override {}\n+  void visit (HIR::StructStruct &struct_item) override {}\n+  void visit (HIR::TupleStruct &tuple_struct) override {}\n+  void visit (HIR::Enum &enum_item) override {}\n+  void visit (HIR::Union &union_item) override {}\n+  void visit (HIR::ConstantItem &const_item) override {}\n+  void visit (HIR::StaticItem &static_item) override {}\n+  void visit (HIR::ImplBlock &impl) override {}\n+  void visit (HIR::ExternBlock &block) override {}\n+\n+  void visit (HIR::Trait &trait) override { ctx.emit_trait (trait); }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    ctx.emit_function (function);\n+  }\n+\n+private:\n+  ExportContext &ctx;\n+};\n+\n+PublicInterface::PublicInterface (HIR::Crate &crate)\n+  : crate (crate), mappings (*Analysis::Mappings::get ()), context ()\n+{}\n+\n+void\n+PublicInterface::Export (HIR::Crate &crate)\n+{\n+  PublicInterface interface (crate);\n+  interface.gather_export_data ();\n+  interface.write_to_object_file ();\n+}\n+\n+void\n+PublicInterface::ExportTo (HIR::Crate &crate, const std::string &output_path)\n+{\n+  PublicInterface interface (crate);\n+  interface.gather_export_data ();\n+  interface.write_to_path (output_path);\n+}\n+\n+void\n+PublicInterface::gather_export_data ()\n+{\n+  ExportVisItems visitor (context);\n+  for (auto &item : crate.items)\n+    {\n+      bool is_vis_item = item->get_hir_kind () == HIR::Node::BaseKind::VIS_ITEM;\n+      if (!is_vis_item)\n+\tcontinue;\n+\n+      HIR::VisItem &vis_item = static_cast<HIR::VisItem &> (*item.get ());\n+      if (is_crate_public (vis_item))\n+\tvis_item.accept_vis (visitor);\n+    }\n+}\n+\n+void\n+PublicInterface::write_to_object_file () const\n+{\n+  // done\n+  const auto &buf = context.get_interface_buffer ();\n+  std::string size_buffer = std::to_string (buf.size ());\n+\n+  // md5 this\n+  struct md5_ctx chksm;\n+  unsigned char checksum[16];\n+\n+  md5_init_ctx (&chksm);\n+  md5_process_bytes (buf.c_str (), buf.size (), &chksm);\n+  md5_finish_ctx (&chksm, checksum);\n+\n+  // MAGIC MD5 DLIM  DLIM buffer-size DELIM contents\n+  const std::string current_crate_name = mappings.get_current_crate_name ();\n+\n+  // extern void\n+  rust_write_export_data (kMagicHeader, sizeof (kMagicHeader));\n+  rust_write_export_data ((const char *) checksum, sizeof (checksum));\n+  rust_write_export_data (kSzDelim, sizeof (kSzDelim));\n+  rust_write_export_data (current_crate_name.c_str (),\n+\t\t\t  current_crate_name.size ());\n+  rust_write_export_data (kSzDelim, sizeof (kSzDelim));\n+  rust_write_export_data (size_buffer.c_str (), size_buffer.size ());\n+  rust_write_export_data (kSzDelim, sizeof (kSzDelim));\n+  rust_write_export_data (buf.c_str (), buf.size ());\n+}\n+\n+void\n+PublicInterface::write_to_path (const std::string &path) const\n+{\n+  // validate path contains correct extension\n+  const std::string expected_file_name = expected_metadata_filename ();\n+  const char *path_base_name = basename (path.c_str ());\n+  if (strcmp (path_base_name, expected_file_name.c_str ()) != 0)\n+    {\n+      rust_error_at (Location (),\n+\t\t     \"expected metadata-output path to have base file name of: \"\n+\t\t     \"%<%s%> got %<%s%>\",\n+\t\t     expected_file_name.c_str (), path_base_name);\n+      return;\n+    }\n+\n+  // done\n+  const auto &buf = context.get_interface_buffer ();\n+  std::string size_buffer = std::to_string (buf.size ());\n+\n+  // md5 this\n+  struct md5_ctx chksm;\n+  unsigned char checksum[16];\n+\n+  md5_init_ctx (&chksm);\n+  md5_process_bytes (buf.c_str (), buf.size (), &chksm);\n+  md5_finish_ctx (&chksm, checksum);\n+\n+  // MAGIC MD5 DLIM  DLIM buffer-size DELIM contents\n+  const std::string current_crate_name = mappings.get_current_crate_name ();\n+\n+  // write to path\n+  FILE *nfd = fopen (path.c_str (), \"wb\");\n+  if (nfd == NULL)\n+    {\n+      rust_error_at (Location (), \"failed to open file %<%s%> for writing: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      return;\n+    }\n+\n+  // write data\n+  if (fwrite (kMagicHeader, sizeof (kMagicHeader), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (checksum, sizeof (checksum), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (kSzDelim, sizeof (kSzDelim), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (current_crate_name.c_str (), current_crate_name.size (), 1, nfd)\n+      < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (kSzDelim, sizeof (kSzDelim), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (size_buffer.c_str (), size_buffer.size (), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (kSzDelim, sizeof (kSzDelim), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (!buf.empty ())\n+    if (fwrite (buf.c_str (), buf.size (), 1, nfd) < 1)\n+      {\n+\trust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t       path.c_str (), xstrerror (errno));\n+\tfclose (nfd);\n+\treturn;\n+      }\n+\n+  // done\n+  fclose (nfd);\n+}\n+\n+bool\n+PublicInterface::is_crate_public (const HIR::VisItem &item)\n+{\n+  const HIR::Visibility &visibility = item.get_visibility ();\n+\n+  bool is_public\n+    = visibility.get_vis_type () == HIR::Visibility::VisType::PUBLIC;\n+  bool has_path = !visibility.get_path ().is_error ();\n+\n+  // FIXME this might be pub(crate)\n+  // Arthur magic required here\n+\n+  return is_public && !has_path;\n+}\n+\n+std::string\n+PublicInterface::expected_metadata_filename ()\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+\n+  const std::string current_crate_name = mappings->get_current_crate_name ();\n+  return current_crate_name + extension_path;\n+}\n+\n+} // namespace Metadata\n+} // namespace Rust"}, {"sha": "cbb6ecd65a6826d8542caed892ba6cb6dc3c4f0a", "filename": "gcc/rust/metadata/rust-export-metadata.h", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Fmetadata%2Frust-export-metadata.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Fmetadata%2Frust-export-metadata.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-export-metadata.h?ref=509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6", "patch": "@@ -0,0 +1,85 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_EXPORT_METADATA_H\n+#define RUST_EXPORT_METADATA_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-hir-full-decls.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace Metadata {\n+\n+static const char kMagicHeader[4] = {'G', 'R', 'S', 'T'};\n+static const char kSzDelim[1] = {'$'};\n+\n+class ExportContext\n+{\n+public:\n+  ExportContext ();\n+\n+  ~ExportContext ();\n+\n+  void push_module_scope (const HIR::Module &module);\n+\n+  const HIR::Module &pop_module_scope ();\n+\n+  void emit_trait (const HIR::Trait &trait);\n+\n+  void emit_function (const HIR::Function &fn);\n+\n+  const std::string &get_interface_buffer () const;\n+\n+private:\n+  Analysis::Mappings *mappings;\n+\n+  std::vector<std::reference_wrapper<const HIR::Module>> module_stack;\n+  std::string public_interface_buffer;\n+};\n+\n+class PublicInterface\n+{\n+public:\n+  static void Export (HIR::Crate &crate);\n+\n+  static void ExportTo (HIR::Crate &crate, const std::string &output_path);\n+\n+  static bool is_crate_public (const HIR::VisItem &item);\n+\n+  static std::string expected_metadata_filename ();\n+\n+protected:\n+  void gather_export_data ();\n+\n+  void write_to_object_file () const;\n+\n+  void write_to_path (const std::string &path) const;\n+\n+private:\n+  PublicInterface (HIR::Crate &crate);\n+\n+  HIR::Crate &crate;\n+  Analysis::Mappings &mappings;\n+  ExportContext context;\n+};\n+\n+} // namespace Metadata\n+} // namespace Rust\n+\n+#endif // RUST_EXPORT_METADATA_H"}, {"sha": "614a6d917297da54c802d13564a5aa9b66170d84", "filename": "gcc/rust/metadata/rust-extern-crate.cc", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Fmetadata%2Frust-extern-crate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Fmetadata%2Frust-extern-crate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-extern-crate.cc?ref=509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6", "patch": "@@ -0,0 +1,173 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-extern-crate.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-export-metadata.h\"\n+\n+#include \"md5.h\"\n+\n+namespace Rust {\n+namespace Imports {\n+\n+ExternCrate::ExternCrate (Import::Stream &stream) : import_stream (stream) {}\n+\n+ExternCrate::~ExternCrate () {}\n+\n+bool\n+ExternCrate::ok () const\n+{\n+  return !import_stream.saw_error ();\n+}\n+\n+bool\n+ExternCrate::load (Location locus)\n+{\n+  // match header\n+  import_stream.require_bytes (locus, Metadata::kMagicHeader,\n+\t\t\t       sizeof (Metadata::kMagicHeader));\n+  if (import_stream.saw_error ())\n+    return false;\n+\n+  // parse 16 bytes md5\n+  unsigned char checksum[16];\n+  bool ok\n+    = import_stream.do_peek (sizeof (checksum), (const char **) &checksum);\n+  if (!ok)\n+    return false;\n+\n+  import_stream.advance (sizeof (checksum));\n+\n+  // parse delim\n+  import_stream.require_bytes (locus, Metadata::kSzDelim,\n+\t\t\t       sizeof (Metadata::kSzDelim));\n+  if (import_stream.saw_error ())\n+    return false;\n+\n+  // parse crate name\n+  bool saw_delim = false;\n+  while (!import_stream.saw_error () && !import_stream.at_eof ())\n+    {\n+      unsigned char byte = import_stream.get_char ();\n+      saw_delim\n+\t= memcmp (&byte, Metadata::kSzDelim, sizeof (Metadata::kSzDelim)) == 0;\n+      if (saw_delim)\n+\tbreak;\n+\n+      crate_name += byte;\n+    }\n+  if (!saw_delim || crate_name.empty ())\n+    {\n+      import_stream.set_saw_error ();\n+      rust_error_at (locus, \"failed to read crate name field\");\n+\n+      return false;\n+    }\n+\n+  // read until delim which is the size of the meta data\n+  std::string metadata_length_buffer;\n+  saw_delim = false;\n+  while (!import_stream.saw_error () && !import_stream.at_eof ())\n+    {\n+      unsigned char byte = import_stream.get_char ();\n+      saw_delim\n+\t= memcmp (&byte, Metadata::kSzDelim, sizeof (Metadata::kSzDelim)) == 0;\n+      if (saw_delim)\n+\tbreak;\n+\n+      metadata_length_buffer += byte;\n+    }\n+  if (!saw_delim || metadata_length_buffer.empty ())\n+    {\n+      import_stream.set_saw_error ();\n+      rust_error_at (locus, \"failed to read metatadata size\");\n+\n+      return false;\n+    }\n+\n+  // interpret the string size\n+  int expected_buffer_length = -1;\n+  ok = ExternCrate::string_to_int (locus, metadata_length_buffer, false,\n+\t\t\t\t   &expected_buffer_length);\n+  if (!ok)\n+    return false;\n+\n+  // read the parsed size and it should be eof\n+  metadata_buffer.reserve (expected_buffer_length);\n+  for (int i = 0; i < expected_buffer_length && !import_stream.saw_error ()\n+\t\t  && !import_stream.at_eof ();\n+       i++)\n+    {\n+      metadata_buffer += import_stream.get_char ();\n+    }\n+\n+  // compute the md5\n+  struct md5_ctx chksm;\n+  unsigned char computed_checksum[16];\n+\n+  md5_init_ctx (&chksm);\n+  md5_process_bytes (metadata_buffer.c_str (), metadata_buffer.size (), &chksm);\n+  md5_finish_ctx (&chksm, computed_checksum);\n+\n+  // FIXME i think the encoding and decoding of md5 is going wrong or else we\n+  // are not computing it correctly\n+  //\n+  // compare the checksums\n+  // if (memcmp(computed_checksum, checksum, sizeof (checksum)) != 0)\n+  //   {\n+  //     rust_error_at (locus,\n+  //       \t     \"checksum mismatch in metadata: %<%.*s%> vs %<%.*s%>\",\n+  //       \t     sizeof (computed_checksum), computed_checksum,\n+  //       \t     sizeof (checksum), checksum);\n+  //     return false;\n+  //   }\n+\n+  // all good\n+  return true;\n+}\n+\n+const std::string &\n+ExternCrate::get_crate_name () const\n+{\n+  return crate_name;\n+}\n+\n+const std::string &\n+ExternCrate::get_metadata () const\n+{\n+  return metadata_buffer;\n+}\n+\n+// Turn a string into a integer with appropriate error handling.\n+bool\n+ExternCrate::string_to_int (Location locus, const std::string &s,\n+\t\t\t    bool is_neg_ok, int *ret)\n+{\n+  char *end;\n+  long prio = strtol (s.c_str (), &end, 10);\n+  if (*end != '\\0' || prio > 0x7fffffff || (prio < 0 && !is_neg_ok))\n+    {\n+      rust_error_at (locus, \"invalid integer in import data\");\n+      return false;\n+    }\n+  *ret = prio;\n+  return true;\n+}\n+\n+} // namespace Imports\n+} // namespace Rust"}, {"sha": "66da83894c1bade306733e95822999dbcdef8db8", "filename": "gcc/rust/metadata/rust-extern-crate.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Fmetadata%2Frust-extern-crate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Fmetadata%2Frust-extern-crate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-extern-crate.h?ref=509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_EXTERN_CRATE_H\n+#define RUST_EXTERN_CRATE_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-imports.h\"\n+\n+namespace Rust {\n+namespace Imports {\n+\n+class ExternCrate\n+{\n+public:\n+  ExternCrate (Import::Stream &stream);\n+  ~ExternCrate ();\n+\n+  bool ok () const;\n+\n+  bool load (Location locus);\n+\n+  const std::string &get_crate_name () const;\n+\n+  const std::string &get_metadata () const;\n+\n+  static bool string_to_int (Location locus, const std::string &s,\n+\t\t\t     bool is_neg_ok, int *ret);\n+\n+private:\n+  Import::Stream &import_stream;\n+\n+  std::string crate_name;\n+  std::string metadata_buffer;\n+};\n+\n+} // namespace Imports\n+} // namespace Rust\n+\n+#endif // RUST_EXTERN_CRATE_H"}, {"sha": "5678d486f17d38b78a5f87fbbb8194b4b9095492", "filename": "gcc/rust/metadata/rust-import-archive.cc", "status": "added", "additions": 885, "deletions": 0, "changes": 885, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Fmetadata%2Frust-import-archive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Fmetadata%2Frust-import-archive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-import-archive.cc?ref=509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6", "patch": "@@ -0,0 +1,885 @@\n+// import-archive.cc -- Go frontend read import data from an archive file.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"rust-system.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-imports.h\"\n+\n+#ifndef O_BINARY\n+#define O_BINARY 0\n+#endif\n+\n+// Archive magic numbers.\n+\n+static const char armag[] = {'!', '<', 'a', 'r', 'c', 'h', '>', '\\n'};\n+static const char armagt[] = {'!', '<', 't', 'h', 'i', 'n', '>', '\\n'};\n+static const char armagb[] = {'<', 'b', 'i', 'g', 'a', 'f', '>', '\\n'};\n+static const char arfmag[2] = {'`', '\\n'};\n+\n+namespace Rust {\n+\n+// Archive fixed length header for AIX big format.\n+\n+struct Archive_fl_header\n+{\n+  // Archive magic string.\n+  char fl_magic[8];\n+  // Offset to member table.\n+  char fl_memoff[20];\n+  // Offset to global symbol table.\n+  char fl_gstoff[20];\n+  // Offset to global symbol table for 64-bit objects.\n+  char fl_gst64off[20];\n+  // Offset to first archive member.\n+  char fl_fstmoff[20];\n+  // Offset to last archive member.\n+  char fl_lstmoff[20];\n+  // Offset to first member on free list.\n+  char fl_freeoff[20];\n+};\n+\n+// The header of an entry in an archive.  This is all readable text,\n+// padded with spaces where necesary.\n+\n+struct Archive_header\n+{\n+  // The entry name.\n+  char ar_name[16];\n+  // The file modification time.\n+  char ar_date[12];\n+  // The user's UID in decimal.\n+  char ar_uid[6];\n+  // The user's GID in decimal.\n+  char ar_gid[6];\n+  // The file mode in octal.\n+  char ar_mode[8];\n+  // The file size in decimal.\n+  char ar_size[10];\n+  // The final magic code.\n+  char ar_fmag[2];\n+};\n+\n+// The header of an entry in an AIX big archive.\n+// This is followed by ar_namlen bytes + 2 bytes for arfmag.\n+\n+struct Archive_big_header\n+{\n+  // The file size in decimal.\n+  char ar_size[20];\n+  // The next member offset in decimal.\n+  char ar_nxtmem[20];\n+  // The previous member offset in decimal.\n+  char ar_prvmem[20];\n+  // The file modification time in decimal.\n+  char ar_date[12];\n+  // The user's UID in decimal.\n+  char ar_uid[12];\n+  // The user's GID in decimal.\n+  char ar_gid[12];\n+  // The file mode in octal.\n+  char ar_mode[12];\n+  // The file name length in decimal.\n+  char ar_namlen[4];\n+};\n+\n+// Return true if BYTES, which are from the start of the file, are an\n+// archive magic number.\n+\n+bool\n+Import::is_archive_magic (const char *bytes)\n+{\n+  const int archive_magic_len = 8;\n+  return (memcmp (bytes, armag, archive_magic_len) == 0\n+\t  || memcmp (bytes, armagt, archive_magic_len) == 0\n+\t  || memcmp (bytes, armagb, archive_magic_len) == 0);\n+}\n+\n+// An object used to read an archive file.\n+\n+class Archive_file\n+{\n+public:\n+  Archive_file (const std::string &filename, int fd, Location location)\n+    : filename_ (filename), fd_ (fd), filesize_ (-1), first_member_offset_ (0),\n+      extended_names_ (), is_thin_archive_ (false), is_big_archive_ (false),\n+      location_ (location), nested_archives_ ()\n+  {}\n+\n+  // Initialize.\n+  bool initialize ();\n+\n+  // Return the file name.\n+  const std::string &filename () const { return this->filename_; }\n+\n+  // Get the file size.\n+  off_t filesize () const { return this->filesize_; }\n+\n+  // Return the offset of the first member.\n+  off_t first_member_offset () const { return this->first_member_offset_; }\n+\n+  // Return whether this is a thin archive.\n+  bool is_thin_archive () const { return this->is_thin_archive_; }\n+\n+  // Return whether this is a big archive.\n+  bool is_big_archive () const { return this->is_big_archive_; }\n+\n+  // Return the location of the import statement.\n+  Location location () const { return this->location_; }\n+\n+  // Read bytes.\n+  bool read (off_t offset, off_t size, char *);\n+\n+  // Parse a decimal in readable text.\n+  bool parse_decimal (const char *str, off_t size, long *res) const;\n+\n+  // Read the archive header at OFF, setting *PNAME, *SIZE,\n+  // *NESTED_OFF and *NEXT_OFF.\n+  bool read_header (off_t off, std::string *pname, off_t *size,\n+\t\t    off_t *nested_off, off_t *next_off);\n+\n+  // Interpret the header of HDR, the header of the archive member at\n+  // file offset OFF.  Return whether it succeeded.  Set *SIZE to the\n+  // size of the member.  Set *PNAME to the name of the member.  Set\n+  // *NESTED_OFF to the offset in a nested archive.\n+  bool interpret_header (const Archive_header *hdr, off_t off,\n+\t\t\t std::string *pname, off_t *size,\n+\t\t\t off_t *nested_off) const;\n+\n+  // Get the file and offset for an archive member.\n+  bool get_file_and_offset (off_t off, const std::string &hdrname,\n+\t\t\t    off_t nested_off, int *memfd, off_t *memoff,\n+\t\t\t    std::string *memname);\n+\n+private:\n+  // Initialize a big archive (AIX)\n+  bool initialize_big_archive ();\n+\n+  // Initialize a normal archive\n+  bool initialize_archive ();\n+\n+  // Read the big archive header at OFF, setting *PNAME, *SIZE and *NEXT_OFF.\n+  bool read_big_archive_header (off_t off, std::string *pname, off_t *size,\n+\t\t\t\toff_t *next_off);\n+\n+  // Read the normal archive header at OFF, setting *PNAME, *SIZE,\n+  // *NESTED_OFF and *NEXT_OFF.\n+  bool read_archive_header (off_t off, std::string *pname, off_t *size,\n+\t\t\t    off_t *nested_off, off_t *next_off);\n+\n+  // For keeping track of open nested archives in a thin archive file.\n+  typedef std::map<std::string, Archive_file *> Nested_archive_table;\n+\n+  // The name of the file.\n+  std::string filename_;\n+  // The file descriptor.\n+  int fd_;\n+  // The file size;\n+  off_t filesize_;\n+  // The first member offset;\n+  off_t first_member_offset_;\n+  // The extended name table.\n+  std::string extended_names_;\n+  // Whether this is a thin archive.\n+  bool is_thin_archive_;\n+  // Whether this is a big archive.\n+  bool is_big_archive_;\n+  // The location of the import statements.\n+  Location location_;\n+  // Table of nested archives.\n+  Nested_archive_table nested_archives_;\n+};\n+\n+bool\n+Archive_file::initialize ()\n+{\n+  struct stat st;\n+  if (fstat (this->fd_, &st) < 0)\n+    {\n+      rust_error_at (this->location_, \"%s: %m\", this->filename_.c_str ());\n+      return false;\n+    }\n+  this->filesize_ = st.st_size;\n+\n+  char buf[sizeof (armagt)];\n+  if (::lseek (this->fd_, 0, SEEK_SET) < 0\n+      || ::read (this->fd_, buf, sizeof (armagt)) != sizeof (armagt))\n+    {\n+      rust_error_at (this->location_, \"%s: %m\", this->filename_.c_str ());\n+      return false;\n+    }\n+  if (memcmp (buf, armagt, sizeof (armagt)) == 0)\n+    this->is_thin_archive_ = true;\n+  else if (memcmp (buf, armagb, sizeof (armagb)) == 0)\n+    this->is_big_archive_ = true;\n+\n+  if (this->is_big_archive_)\n+    return this->initialize_big_archive ();\n+  else\n+    return this->initialize_archive ();\n+}\n+\n+// Initialize a big archive (AIX).\n+\n+bool\n+Archive_file::initialize_big_archive ()\n+{\n+  Archive_fl_header flhdr;\n+\n+  // Read the fixed length header.\n+  if (::lseek (this->fd_, 0, SEEK_SET) < 0\n+      || ::read (this->fd_, &flhdr, sizeof (flhdr)) != sizeof (flhdr))\n+    {\n+      rust_error_at (this->location_, \"%s: could not read archive header\",\n+\t\t     this->filename_.c_str ());\n+      return false;\n+    }\n+\n+  // Parse offset of the first member.\n+  long off;\n+  if (!this->parse_decimal (flhdr.fl_fstmoff, sizeof (flhdr.fl_fstmoff), &off))\n+    {\n+      char *buf = new char[sizeof (flhdr.fl_fstmoff) + 1];\n+      memcpy (buf, flhdr.fl_fstmoff, sizeof (flhdr.fl_fstmoff));\n+      rust_error_at (this->location_,\n+\t\t     (\"%s: malformed first member offset in archive header\"\n+\t\t      \" (expected decimal, got %s)\"),\n+\t\t     this->filename_.c_str (), buf);\n+      delete[] buf;\n+      return false;\n+    }\n+  if (off == 0) // Empty archive.\n+    this->first_member_offset_ = this->filesize_;\n+  else\n+    this->first_member_offset_ = off;\n+  return true;\n+}\n+\n+// Initialize a normal archive.\n+\n+bool\n+Archive_file::initialize_archive ()\n+{\n+  this->first_member_offset_ = sizeof (armag);\n+  if (this->first_member_offset_ == this->filesize_)\n+    {\n+      // Empty archive.\n+      return true;\n+    }\n+\n+  // Look for the extended name table.\n+  std::string filename;\n+  off_t size;\n+  off_t next_off;\n+  if (!this->read_header (this->first_member_offset_, &filename, &size, NULL,\n+\t\t\t  &next_off))\n+    return false;\n+  if (filename.empty ())\n+    {\n+      // We found the symbol table.\n+      if (!this->read_header (next_off, &filename, &size, NULL, NULL))\n+\tfilename.clear ();\n+    }\n+  if (filename == \"/\")\n+    {\n+      char *rdbuf = new char[size];\n+      if (::read (this->fd_, rdbuf, size) != size)\n+\t{\n+\t  rust_error_at (this->location_, \"%s: could not read extended names\",\n+\t\t\t filename.c_str ());\n+\t  delete[] rdbuf;\n+\t  return false;\n+\t}\n+      this->extended_names_.assign (rdbuf, size);\n+      delete[] rdbuf;\n+    }\n+\n+  return true;\n+}\n+\n+// Read bytes from the file.\n+\n+bool\n+Archive_file::read (off_t offset, off_t size, char *buf)\n+{\n+  if (::lseek (this->fd_, offset, SEEK_SET) < 0\n+      || ::read (this->fd_, buf, size) != size)\n+    {\n+      rust_error_at (this->location_, \"%s: %m\", this->filename_.c_str ());\n+      return false;\n+    }\n+  return true;\n+}\n+\n+// Parse a decimal in readable text.\n+\n+bool\n+Archive_file::parse_decimal (const char *str, off_t size, long *res) const\n+{\n+  char *buf = new char[size + 1];\n+  memcpy (buf, str, size);\n+  char *ps = buf + size;\n+  while (ps > buf && ps[-1] == ' ')\n+    --ps;\n+  *ps = '\\0';\n+\n+  errno = 0;\n+  char *end;\n+  *res = strtol (buf, &end, 10);\n+  if (*end != '\\0' || *res < 0 || (*res == LONG_MAX && errno == ERANGE))\n+    {\n+      delete[] buf;\n+      return false;\n+    }\n+  delete[] buf;\n+  return true;\n+}\n+\n+// Read the header at OFF.  Set *PNAME to the name, *SIZE to the size,\n+// *NESTED_OFF to the nested offset, and *NEXT_OFF to the next member offset.\n+\n+bool\n+Archive_file::read_header (off_t off, std::string *pname, off_t *size,\n+\t\t\t   off_t *nested_off, off_t *next_off)\n+{\n+  if (::lseek (this->fd_, off, SEEK_SET) < 0)\n+    {\n+      rust_error_at (this->location_, \"%s: %m\", this->filename_.c_str ());\n+      return false;\n+    }\n+  if (this->is_big_archive_)\n+    return this->read_big_archive_header (off, pname, size, next_off);\n+  else\n+    return this->read_archive_header (off, pname, size, nested_off, next_off);\n+}\n+\n+// Read the big archive header at OFF, setting *PNAME, *SIZE and *NEXT_OFF.\n+\n+bool\n+Archive_file::read_big_archive_header (off_t off, std::string *pname,\n+\t\t\t\t       off_t *size, off_t *next_off)\n+{\n+  Archive_big_header hdr;\n+  ssize_t got;\n+\n+  got = ::read (this->fd_, &hdr, sizeof hdr);\n+  if (got != sizeof hdr)\n+    {\n+      if (got < 0)\n+\trust_error_at (this->location_, \"%s: %m\", this->filename_.c_str ());\n+      else if (got > 0)\n+\trust_error_at (this->location_, \"%s: short entry header at %ld\",\n+\t\t       this->filename_.c_str (), static_cast<long> (off));\n+      else\n+\trust_error_at (this->location_, \"%s: unexpected EOF at %ld\",\n+\t\t       this->filename_.c_str (), static_cast<long> (off));\n+    }\n+\n+  long local_size;\n+  if (!this->parse_decimal (hdr.ar_size, sizeof (hdr.ar_size), &local_size))\n+    {\n+      char *buf = new char[sizeof (hdr.ar_size) + 1];\n+      memcpy (buf, hdr.ar_size, sizeof (hdr.ar_size));\n+      rust_error_at (this->location_,\n+\t\t     (\"%s: malformed size in entry header at %ld\"\n+\t\t      \" (expected decimal, got %s)\"),\n+\t\t     this->filename_.c_str (), static_cast<long> (off), buf);\n+      delete[] buf;\n+      return false;\n+    }\n+  *size = local_size;\n+\n+  long namlen;\n+  if (!this->parse_decimal (hdr.ar_namlen, sizeof (hdr.ar_namlen), &namlen))\n+    {\n+      char *buf = new char[sizeof (hdr.ar_namlen) + 1];\n+      memcpy (buf, hdr.ar_namlen, sizeof (hdr.ar_namlen));\n+      rust_error_at (this->location_,\n+\t\t     (\"%s: malformed name length in entry header at %ld\"\n+\t\t      \" (expected decimal, got %s)\"),\n+\t\t     this->filename_.c_str (), static_cast<long> (off), buf);\n+      delete[] buf;\n+      return false;\n+    }\n+  // Read member name following member header.\n+  char *rdbuf = new char[namlen];\n+  got = ::read (this->fd_, rdbuf, namlen);\n+  if (got != namlen)\n+    {\n+      rust_error_at (this->location_,\n+\t\t     \"%s: malformed member name in entry header at %ld\",\n+\t\t     this->filename_.c_str (), static_cast<long> (off));\n+      delete[] rdbuf;\n+      return false;\n+    }\n+  pname->assign (rdbuf, namlen);\n+  delete[] rdbuf;\n+\n+  long local_next_off;\n+  if (!this->parse_decimal (hdr.ar_nxtmem, sizeof (hdr.ar_nxtmem),\n+\t\t\t    &local_next_off))\n+    {\n+      char *buf = new char[sizeof (hdr.ar_nxtmem) + 1];\n+      memcpy (buf, hdr.ar_nxtmem, sizeof (hdr.ar_nxtmem));\n+      rust_error_at (this->location_,\n+\t\t     (\"%s: malformed next member offset in entry header at %ld\"\n+\t\t      \" (expected decimal, got %s)\"),\n+\t\t     this->filename_.c_str (), static_cast<long> (off), buf);\n+      delete[] buf;\n+      return false;\n+    }\n+  if (next_off != NULL)\n+    {\n+      if (local_next_off == 0) // Last member.\n+\t*next_off = this->filesize_;\n+      else\n+\t*next_off = local_next_off;\n+    }\n+  return true;\n+}\n+\n+// Read the normal archive header at OFF, setting *PNAME, *SIZE,\n+// *NESTED_OFF and *NEXT_OFF.\n+\n+bool\n+Archive_file::read_archive_header (off_t off, std::string *pname, off_t *size,\n+\t\t\t\t   off_t *nested_off, off_t *next_off)\n+{\n+  Archive_header hdr;\n+  ssize_t got = ::read (this->fd_, &hdr, sizeof hdr);\n+  if (got != sizeof hdr)\n+    {\n+      if (got < 0)\n+\trust_error_at (this->location_, \"%s: %m\", this->filename_.c_str ());\n+      else if (got > 0)\n+\trust_error_at (this->location_, \"%s: short archive header at %ld\",\n+\t\t       this->filename_.c_str (), static_cast<long> (off));\n+      else\n+\trust_error_at (this->location_, \"%s: unexpected EOF at %ld\",\n+\t\t       this->filename_.c_str (), static_cast<long> (off));\n+    }\n+  off_t local_nested_off;\n+  if (!this->interpret_header (&hdr, off, pname, size, &local_nested_off))\n+    return false;\n+  if (nested_off != NULL)\n+    *nested_off = local_nested_off;\n+\n+  off_t local_next_off;\n+  local_next_off = off + sizeof (Archive_header);\n+  if (!this->is_thin_archive_ || pname->empty () || *pname == \"/\")\n+    local_next_off += *size;\n+  if ((local_next_off & 1) != 0)\n+    ++local_next_off;\n+  if (local_next_off > this->filesize_) // Last member.\n+    local_next_off = this->filesize_;\n+  if (next_off != NULL)\n+    *next_off = local_next_off;\n+  return true;\n+}\n+\n+// Interpret the header of HDR, the header of the archive member at\n+// file offset OFF.\n+\n+bool\n+Archive_file::interpret_header (const Archive_header *hdr, off_t off,\n+\t\t\t\tstd::string *pname, off_t *size,\n+\t\t\t\toff_t *nested_off) const\n+{\n+  if (memcmp (hdr->ar_fmag, arfmag, sizeof arfmag) != 0)\n+    {\n+      rust_error_at (this->location_, \"%s: malformed archive header at %lu\",\n+\t\t     this->filename_.c_str (),\n+\t\t     static_cast<unsigned long> (off));\n+      return false;\n+    }\n+\n+  long local_size;\n+  if (!this->parse_decimal (hdr->ar_size, sizeof hdr->ar_size, &local_size))\n+    {\n+      rust_error_at (this->location_,\n+\t\t     \"%s: malformed archive header size at %lu\",\n+\t\t     this->filename_.c_str (),\n+\t\t     static_cast<unsigned long> (off));\n+      return false;\n+    }\n+  *size = local_size;\n+\n+  *nested_off = 0;\n+  if (hdr->ar_name[0] != '/')\n+    {\n+      const char *name_end = strchr (hdr->ar_name, '/');\n+      if (name_end == NULL\n+\t  || name_end - hdr->ar_name >= static_cast<int> (sizeof hdr->ar_name))\n+\t{\n+\t  rust_error_at (this->location_,\n+\t\t\t \"%s: malformed archive header name at %lu\",\n+\t\t\t this->filename_.c_str (),\n+\t\t\t static_cast<unsigned long> (off));\n+\t  return false;\n+\t}\n+      pname->assign (hdr->ar_name, name_end - hdr->ar_name);\n+    }\n+  else if (hdr->ar_name[1] == ' ')\n+    {\n+      // This is the symbol table.\n+      pname->clear ();\n+    }\n+  else if (hdr->ar_name[1] == 'S' && hdr->ar_name[2] == 'Y'\n+\t   && hdr->ar_name[3] == 'M' && hdr->ar_name[4] == '6'\n+\t   && hdr->ar_name[5] == '4' && hdr->ar_name[6] == '/'\n+\t   && hdr->ar_name[7] == ' ')\n+    {\n+      // 64-bit symbol table.\n+      pname->clear ();\n+    }\n+  else if (hdr->ar_name[1] == '/')\n+    {\n+      // This is the extended name table.\n+      pname->assign (1, '/');\n+    }\n+  else\n+    {\n+      char *end;\n+      errno = 0;\n+      long x = strtol (hdr->ar_name + 1, &end, 10);\n+      long y = 0;\n+      if (*end == ':')\n+\ty = strtol (end + 1, &end, 10);\n+      if (*end != ' ' || x < 0 || (x == LONG_MAX && errno == ERANGE)\n+\t  || static_cast<size_t> (x) >= this->extended_names_.size ())\n+\t{\n+\t  rust_error_at (this->location_, \"%s: bad extended name index at %lu\",\n+\t\t\t this->filename_.c_str (),\n+\t\t\t static_cast<unsigned long> (off));\n+\t  return false;\n+\t}\n+\n+      const char *name = this->extended_names_.data () + x;\n+      const char *name_end = strchr (name, '\\n');\n+      if (static_cast<size_t> (name_end - name) > this->extended_names_.size ()\n+\t  || name_end[-1] != '/')\n+\t{\n+\t  rust_error_at (this->location_,\n+\t\t\t \"%s: bad extended name entry at header %lu\",\n+\t\t\t this->filename_.c_str (),\n+\t\t\t static_cast<unsigned long> (off));\n+\t  return false;\n+\t}\n+      pname->assign (name, name_end - 1 - name);\n+      *nested_off = y;\n+    }\n+\n+  return true;\n+}\n+\n+// Get the file and offset for an archive member.\n+\n+bool\n+Archive_file::get_file_and_offset (off_t off, const std::string &hdrname,\n+\t\t\t\t   off_t nested_off, int *memfd, off_t *memoff,\n+\t\t\t\t   std::string *memname)\n+{\n+  if (this->is_big_archive_)\n+    {\n+      *memfd = this->fd_;\n+      *memoff = (off + sizeof (Archive_big_header) + hdrname.length ()\n+\t\t + sizeof (arfmag));\n+      if ((*memoff & 1) != 0)\n+\t++*memoff;\n+      *memname = this->filename_ + '(' + hdrname + ')';\n+      return true;\n+    }\n+  else if (!this->is_thin_archive_)\n+    {\n+      *memfd = this->fd_;\n+      *memoff = off + sizeof (Archive_header);\n+      *memname = this->filename_ + '(' + hdrname + ')';\n+      return true;\n+    }\n+\n+  std::string filename = hdrname;\n+  if (!IS_ABSOLUTE_PATH (filename.c_str ()))\n+    {\n+      const char *archive_path = this->filename_.c_str ();\n+      const char *basename = lbasename (archive_path);\n+      if (basename > archive_path)\n+\tfilename.replace (0, 0,\n+\t\t\t  this->filename_.substr (0, basename - archive_path));\n+    }\n+\n+  if (nested_off > 0)\n+    {\n+      // This is a member of a nested archive.\n+      Archive_file *nfile;\n+      Nested_archive_table::const_iterator p\n+\t= this->nested_archives_.find (filename);\n+      if (p != this->nested_archives_.end ())\n+\tnfile = p->second;\n+      else\n+\t{\n+\t  int nfd = open (filename.c_str (), O_RDONLY | O_BINARY);\n+\t  if (nfd < 0)\n+\t    {\n+\t      rust_error_at (this->location_,\n+\t\t\t     \"%s: cannot open nested archive %s\",\n+\t\t\t     this->filename_.c_str (), filename.c_str ());\n+\t      return false;\n+\t    }\n+\t  nfile = new Archive_file (filename, nfd, this->location_);\n+\t  if (!nfile->initialize ())\n+\t    {\n+\t      delete nfile;\n+\t      return false;\n+\t    }\n+\t  this->nested_archives_[filename] = nfile;\n+\t}\n+\n+      std::string nname;\n+      off_t nsize;\n+      off_t nnested_off;\n+      if (!nfile->read_header (nested_off, &nname, &nsize, &nnested_off, NULL))\n+\treturn false;\n+      return nfile->get_file_and_offset (nested_off, nname, nnested_off, memfd,\n+\t\t\t\t\t memoff, memname);\n+    }\n+\n+  // An external member of a thin archive.\n+  *memfd = open (filename.c_str (), O_RDONLY | O_BINARY);\n+  if (*memfd < 0)\n+    {\n+      rust_error_at (this->location_, \"%s: %m\", filename.c_str ());\n+      return false;\n+    }\n+  *memoff = 0;\n+  *memname = filename;\n+  return true;\n+}\n+\n+// An archive member iterator.  This is more-or-less copied from gold.\n+\n+class Archive_iterator\n+{\n+public:\n+  // The header of an archive member.  This is what this iterator\n+  // points to.\n+  struct Header\n+  {\n+    // The name of the member.\n+    std::string name;\n+    // The file offset of the member.\n+    off_t off;\n+    // The file offset of a nested archive member.\n+    off_t nested_off;\n+    // The size of the member.\n+    off_t size;\n+  };\n+\n+  Archive_iterator (Archive_file *afile, off_t off) : afile_ (afile), off_ (off)\n+  {\n+    this->read_next_header ();\n+  }\n+\n+  const Header &operator* () const { return this->header_; }\n+\n+  const Header *operator-> () const { return &this->header_; }\n+\n+  Archive_iterator &operator++ ()\n+  {\n+    if (this->off_ == this->afile_->filesize ())\n+      return *this;\n+    this->off_ = this->next_off_;\n+    this->read_next_header ();\n+    return *this;\n+  }\n+\n+  Archive_iterator operator++ (int)\n+  {\n+    Archive_iterator ret = *this;\n+    ++*this;\n+    return ret;\n+  }\n+\n+  bool operator== (const Archive_iterator &p) const\n+  {\n+    return this->off_ == p->off;\n+  }\n+\n+  bool operator!= (const Archive_iterator &p) const\n+  {\n+    return this->off_ != p->off;\n+  }\n+\n+private:\n+  void read_next_header ();\n+\n+  // The underlying archive file.\n+  Archive_file *afile_;\n+  // The current offset in the file.\n+  off_t off_;\n+  // The offset of the next member.\n+  off_t next_off_;\n+  // The current archive header.\n+  Header header_;\n+};\n+\n+// Read the next archive header.\n+\n+void\n+Archive_iterator::read_next_header ()\n+{\n+  off_t filesize = this->afile_->filesize ();\n+  while (true)\n+    {\n+      if (this->off_ == filesize)\n+\t{\n+\t  this->header_.off = filesize;\n+\t  return;\n+\t}\n+\n+      if (!this->afile_->read_header (this->off_, &this->header_.name,\n+\t\t\t\t      &this->header_.size,\n+\t\t\t\t      &this->header_.nested_off,\n+\t\t\t\t      &this->next_off_))\n+\t{\n+\t  this->header_.off = filesize;\n+\t  this->off_ = filesize;\n+\t  return;\n+\t}\n+      this->header_.off = this->off_;\n+\n+      // Skip special members.\n+      if (!this->header_.name.empty () && this->header_.name != \"/\")\n+\treturn;\n+\n+      this->off_ = this->next_off_;\n+    }\n+}\n+\n+// Initial iterator.\n+\n+Archive_iterator\n+archive_begin (Archive_file *afile)\n+{\n+  return Archive_iterator (afile, afile->first_member_offset ());\n+}\n+\n+// Final iterator.\n+\n+Archive_iterator\n+archive_end (Archive_file *afile)\n+{\n+  return Archive_iterator (afile, afile->filesize ());\n+}\n+\n+// A type of Import_stream which concatenates other Import_streams\n+// together.\n+\n+class Stream_concatenate : public Import::Stream\n+{\n+public:\n+  Stream_concatenate () : inputs_ () {}\n+\n+  // Add a new stream.\n+  void add (Import::Stream *is) { this->inputs_.push_back (is); }\n+\n+protected:\n+  bool do_peek (size_t, const char **);\n+\n+  void do_advance (size_t);\n+\n+private:\n+  std::list<Import::Stream *> inputs_;\n+};\n+\n+// Peek ahead.\n+\n+bool\n+Stream_concatenate::do_peek (size_t length, const char **bytes)\n+{\n+  while (true)\n+    {\n+      if (this->inputs_.empty ())\n+\treturn false;\n+      if (this->inputs_.front ()->peek (length, bytes))\n+\treturn true;\n+      delete this->inputs_.front ();\n+      this->inputs_.pop_front ();\n+    }\n+}\n+\n+// Advance.\n+\n+void\n+Stream_concatenate::do_advance (size_t skip)\n+{\n+  while (true)\n+    {\n+      if (this->inputs_.empty ())\n+\treturn;\n+      if (!this->inputs_.front ()->at_eof ())\n+\t{\n+\t  // We just assume that this will do the right thing.  It\n+\t  // should be OK since we should never want to skip past\n+\t  // multiple streams.\n+\t  this->inputs_.front ()->advance (skip);\n+\t  return;\n+\t}\n+      delete this->inputs_.front ();\n+      this->inputs_.pop_front ();\n+    }\n+}\n+\n+// Import data from an archive.  We walk through the archive and\n+// import data from each member.\n+\n+Import::Stream *\n+Import::find_archive_export_data (const std::string &filename, int fd,\n+\t\t\t\t  Location location)\n+{\n+  Archive_file afile (filename, fd, location);\n+  if (!afile.initialize ())\n+    return NULL;\n+\n+  Stream_concatenate *ret = new Stream_concatenate;\n+\n+  bool any_data = false;\n+  bool any_members = false;\n+  Archive_iterator pend = archive_end (&afile);\n+  for (Archive_iterator p = archive_begin (&afile); p != pend; p++)\n+    {\n+      any_members = true;\n+      int member_fd;\n+      off_t member_off;\n+      std::string member_name;\n+      if (!afile.get_file_and_offset (p->off, p->name, p->nested_off,\n+\t\t\t\t      &member_fd, &member_off, &member_name))\n+\treturn NULL;\n+\n+      Import::Stream *is\n+\t= Import::find_object_export_data (member_name, member_fd, member_off,\n+\t\t\t\t\t   location);\n+      if (is != NULL)\n+\t{\n+\t  ret->add (is);\n+\t  any_data = true;\n+\t}\n+    }\n+\n+  if (!any_members)\n+    {\n+      // It's normal to have an empty archive file when using gobuild.\n+      return new Stream_from_string (\"\");\n+    }\n+\n+  if (!any_data)\n+    {\n+      delete ret;\n+      return NULL;\n+    }\n+\n+  return ret;\n+}\n+\n+} // namespace Rust"}, {"sha": "b44165b1fa2ce39ba2efdd241b22ad5d18d05ba2", "filename": "gcc/rust/metadata/rust-imports.cc", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Fmetadata%2Frust-imports.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Fmetadata%2Frust-imports.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-imports.cc?ref=509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6", "patch": "@@ -0,0 +1,441 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-system.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-imports.h\"\n+#include \"rust-object-export.h\"\n+#include \"rust-export-metadata.h\"\n+\n+#ifndef O_BINARY\n+#define O_BINARY 0\n+#endif\n+\n+namespace Rust {\n+\n+// The list of paths we search for import files.\n+static std::vector<std::string> search_path;\n+\n+// Add a directory to the search path.  This is called from the option\n+// handling language hook.\n+void\n+add_search_path (const std::string &path)\n+{\n+  search_path.push_back (path);\n+}\n+\n+// Find import data.  This searches the file system for FILENAME and\n+// returns a pointer to a Stream object to read the data that it\n+// exports.  If the file is not found, it returns NULL.\n+\n+// When FILENAME is not an absolute path and does not start with ./ or\n+// ../, we use the search path provided by -I and -L options.\n+\n+// When FILENAME does start with ./ or ../, we use\n+// RELATIVE_IMPORT_PATH as a prefix.\n+\n+// When FILENAME does not exist, we try modifying FILENAME to find the\n+// file.  We use the first of these which exists:\n+//   * We append \".gox\".\n+//   * We turn the base of FILENAME into libFILENAME.so.\n+//   * We turn the base of FILENAME into libFILENAME.a.\n+//   * We append \".o\".\n+\n+// When using a search path, we apply each of these transformations at\n+// each entry on the search path before moving on to the next entry.\n+// If the file exists, but does not contain any Go export data, we\n+// stop; we do not keep looking for another file with the same name\n+// later in the search path.\n+\n+Import::Stream *\n+Import::open_package (const std::string &filename, Location location,\n+\t\t      const std::string &relative_import_path)\n+{\n+  bool is_local;\n+  if (IS_ABSOLUTE_PATH (filename))\n+    is_local = true;\n+  else if (filename[0] == '.'\n+\t   && (filename[1] == '\\0' || IS_DIR_SEPARATOR (filename[1])))\n+    is_local = true;\n+  else if (filename[0] == '.' && filename[1] == '.'\n+\t   && (filename[2] == '\\0' || IS_DIR_SEPARATOR (filename[2])))\n+    is_local = true;\n+  else\n+    is_local = false;\n+\n+  std::string fn = filename;\n+  if (is_local && !IS_ABSOLUTE_PATH (filename)\n+      && !relative_import_path.empty ())\n+    {\n+      if (fn == \".\")\n+\t{\n+\t  // A special case.\n+\t  fn = relative_import_path;\n+\t}\n+      else if (fn[0] == '.' && fn[1] == '.'\n+\t       && (fn[2] == '\\0' || IS_DIR_SEPARATOR (fn[2])))\n+\t{\n+\t  // We are going to join relative_import_path and fn, and it\n+\t  // will look like DIR/../PATH.  But DIR does not necessarily\n+\t  // exist in this case, and if it doesn't the use of .. will\n+\t  // fail although it shouldn't.  The gc compiler uses\n+\t  // path.Join here, which cleans up the .., so we need to do\n+\t  // the same.\n+\t  size_t index;\n+\t  for (index = relative_import_path.length () - 1;\n+\t       index > 0 && !IS_DIR_SEPARATOR (relative_import_path[index]);\n+\t       index--)\n+\t    ;\n+\t  if (index > 0)\n+\t    fn = relative_import_path.substr (0, index) + fn.substr (2);\n+\t  else\n+\t    fn = relative_import_path + '/' + fn;\n+\t}\n+      else\n+\tfn = relative_import_path + '/' + fn;\n+      is_local = false;\n+    }\n+\n+  if (!is_local)\n+    {\n+      for (std::vector<std::string>::const_iterator p = search_path.begin ();\n+\t   p != search_path.end (); ++p)\n+\t{\n+\t  std::string indir = *p;\n+\t  if (!indir.empty () && indir[indir.size () - 1] != '/')\n+\t    indir += '/';\n+\t  indir += fn;\n+\t  Stream *s = Import::try_package_in_directory (indir, location);\n+\t  if (s != NULL)\n+\t    return s;\n+\t}\n+    }\n+\n+  Stream *s = Import::try_package_in_directory (fn, location);\n+  if (s != NULL)\n+    return s;\n+\n+  return NULL;\n+}\n+\n+// Try to find the export data for FILENAME.\n+\n+Import::Stream *\n+Import::try_package_in_directory (const std::string &filename,\n+\t\t\t\t  Location location)\n+{\n+  std::string found_filename = filename;\n+  int fd = open (found_filename.c_str (), O_RDONLY | O_BINARY);\n+\n+  if (fd >= 0)\n+    {\n+      struct stat s;\n+      if (fstat (fd, &s) >= 0 && S_ISDIR (s.st_mode))\n+\t{\n+\t  close (fd);\n+\t  fd = -1;\n+\t  errno = EISDIR;\n+\t}\n+    }\n+\n+  if (fd < 0)\n+    {\n+      if (errno != ENOENT && errno != EISDIR)\n+\trust_warning_at (location, 0, \"%s: %m\", filename.c_str ());\n+\n+      fd = Import::try_suffixes (&found_filename);\n+      if (fd < 0)\n+\treturn NULL;\n+    }\n+\n+  // The export data may not be in this file.\n+  Stream *s = Import::find_export_data (found_filename, fd, location);\n+  if (s != NULL)\n+    return s;\n+\n+  close (fd);\n+\n+  rust_error_at (location, \"%s exists but does not contain any Go export data\",\n+\t\t found_filename.c_str ());\n+\n+  return NULL;\n+}\n+\n+// Given import \"*PFILENAME\", where *PFILENAME does not exist, try\n+// various suffixes.  If we find one, set *PFILENAME to the one we\n+// found.  Return the open file descriptor.\n+\n+int\n+Import::try_suffixes (std::string *pfilename)\n+{\n+  std::string filename = *pfilename + \".rox\";\n+  int fd = open (filename.c_str (), O_RDONLY | O_BINARY);\n+  if (fd >= 0)\n+    {\n+      *pfilename = filename;\n+      return fd;\n+    }\n+\n+  const char *basename = lbasename (pfilename->c_str ());\n+  size_t basename_pos = basename - pfilename->c_str ();\n+  filename = pfilename->substr (0, basename_pos) + \"lib\" + basename + \".so\";\n+  fd = open (filename.c_str (), O_RDONLY | O_BINARY);\n+  if (fd >= 0)\n+    {\n+      *pfilename = filename;\n+      return fd;\n+    }\n+\n+  filename = pfilename->substr (0, basename_pos) + \"lib\" + basename + \".a\";\n+  fd = open (filename.c_str (), O_RDONLY | O_BINARY);\n+  if (fd >= 0)\n+    {\n+      *pfilename = filename;\n+      return fd;\n+    }\n+\n+  filename = *pfilename + \".o\";\n+  fd = open (filename.c_str (), O_RDONLY | O_BINARY);\n+  if (fd >= 0)\n+    {\n+      *pfilename = filename;\n+      return fd;\n+    }\n+\n+  return -1;\n+}\n+\n+// Look for export data in the file descriptor FD.\n+\n+Import::Stream *\n+Import::find_export_data (const std::string &filename, int fd,\n+\t\t\t  Location location)\n+{\n+  // See if we can read this as an object file.\n+  Import::Stream *stream\n+    = Import::find_object_export_data (filename, fd, 0, location);\n+  if (stream != NULL)\n+    return stream;\n+\n+  const int len = sizeof (Metadata::kMagicHeader);\n+  if (lseek (fd, 0, SEEK_SET) < 0)\n+    {\n+      rust_error_at (location, \"lseek %s failed: %m\", filename.c_str ());\n+      return NULL;\n+    }\n+\n+  char buf[len];\n+  ssize_t c = ::read (fd, buf, len);\n+  if (c < len)\n+    return NULL;\n+\n+  // Check for a file containing nothing but Go export data.\n+  // if (memcmp (buf, Export::cur_magic, Export::magic_len) == 0\n+  //     || memcmp (buf, Export::v1_magic, Export::magic_len) == 0\n+  //     || memcmp (buf, Export::v2_magic, Export::magic_len) == 0)\n+  //\n+  // FIXME we need to work out a better header\n+  //\n+  if (memcmp (buf, Metadata::kMagicHeader, sizeof (Metadata::kMagicHeader))\n+      == 0)\n+    return new Stream_from_file (fd);\n+\n+  // See if we can read this as an archive.\n+  if (Import::is_archive_magic (buf))\n+    return Import::find_archive_export_data (filename, fd, location);\n+\n+  return NULL;\n+}\n+\n+// Look for export data in an object file.\n+\n+Import::Stream *\n+Import::find_object_export_data (const std::string &filename, int fd,\n+\t\t\t\t off_t offset, Location location)\n+{\n+  char *buf;\n+  size_t len;\n+  int err;\n+  const char *errmsg = rust_read_export_data (fd, offset, &buf, &len, &err);\n+  if (errmsg != NULL)\n+    {\n+      if (err == 0)\n+\trust_error_at (location, \"%s: %s\", filename.c_str (), errmsg);\n+      else\n+\trust_error_at (location, \"%s: %s: %s\", filename.c_str (), errmsg,\n+\t\t       xstrerror (err));\n+      return NULL;\n+    }\n+\n+  if (buf == NULL)\n+    return NULL;\n+\n+  return new Stream_from_buffer (buf, len);\n+}\n+\n+// Class Import.\n+\n+// Construct an Import object.  We make the builtin_types_ vector\n+// large enough to hold all the builtin types.\n+\n+Import::Import (Stream *stream, Location location)\n+  : stream_ (stream), location_ (location)\n+{}\n+\n+// Import the data in the associated stream.\n+\n+// Read LENGTH bytes from the stream.\n+\n+void\n+Import::read (size_t length, std::string *out)\n+{\n+  const char *data;\n+  if (!this->stream_->peek (length, &data))\n+    {\n+      if (!this->stream_->saw_error ())\n+\trust_error_at (this->location_, \"import error at %d: expected %d bytes\",\n+\t\t       this->stream_->pos (), static_cast<int> (length));\n+      this->stream_->set_saw_error ();\n+      *out = std::string (\"\");\n+      return;\n+    }\n+  *out = std::string (data, length);\n+  this->advance (length);\n+}\n+\n+// Class Import::Stream.\n+\n+Import::Stream::Stream () : pos_ (0), saw_error_ (false) {}\n+\n+Import::Stream::~Stream () {}\n+\n+// Return the next character to come from the stream.\n+\n+int\n+Import::Stream::peek_char ()\n+{\n+  const char *read;\n+  if (!this->do_peek (1, &read))\n+    return -1;\n+  // Make sure we return an unsigned char, so that we don't get\n+  // confused by \\xff.\n+  unsigned char ret = *read;\n+  return ret;\n+}\n+\n+// Return true if the next LENGTH characters from the stream match\n+// BYTES\n+\n+bool\n+Import::Stream::match_bytes (const char *bytes, size_t length)\n+{\n+  const char *read;\n+  if (!this->do_peek (length, &read))\n+    return false;\n+  return memcmp (bytes, read, length) == 0;\n+}\n+\n+// Require that the next LENGTH bytes from the stream match BYTES.\n+\n+void\n+Import::Stream::require_bytes (Location location, const char *bytes,\n+\t\t\t       size_t length)\n+{\n+  const char *read;\n+  if (!this->do_peek (length, &read) || memcmp (bytes, read, length) != 0)\n+    {\n+      if (!this->saw_error_)\n+\trust_error_at (location, \"import error at %d: expected %<%.*s%>\",\n+\t\t       this->pos (), static_cast<int> (length), bytes);\n+      this->saw_error_ = true;\n+      return;\n+    }\n+  this->advance (length);\n+}\n+\n+// Class Stream_from_file.\n+\n+Stream_from_file::Stream_from_file (int fd) : fd_ (fd), data_ ()\n+{\n+  if (lseek (fd, 0, SEEK_SET) != 0)\n+    {\n+      rust_fatal_error (Linemap::unknown_location (), \"lseek failed: %m\");\n+      this->set_saw_error ();\n+    }\n+}\n+\n+Stream_from_file::~Stream_from_file () { close (this->fd_); }\n+\n+// Read next bytes.\n+\n+bool\n+Stream_from_file::do_peek (size_t length, const char **bytes)\n+{\n+  if (this->data_.length () >= length)\n+    {\n+      *bytes = this->data_.data ();\n+      return true;\n+    }\n+\n+  this->data_.resize (length);\n+  ssize_t got = ::read (this->fd_, &this->data_[0], length);\n+\n+  if (got < 0)\n+    {\n+      if (!this->saw_error ())\n+\trust_fatal_error (Linemap::unknown_location (), \"read failed: %m\");\n+      this->set_saw_error ();\n+      return false;\n+    }\n+\n+  if (lseek (this->fd_, -got, SEEK_CUR) < 0)\n+    {\n+      if (!this->saw_error ())\n+\trust_fatal_error (Linemap::unknown_location (), \"lseek failed: %m\");\n+      this->set_saw_error ();\n+      return false;\n+    }\n+\n+  if (static_cast<size_t> (got) < length)\n+    return false;\n+\n+  *bytes = this->data_.data ();\n+  return true;\n+}\n+\n+// Advance.\n+\n+void\n+Stream_from_file::do_advance (size_t skip)\n+{\n+  if (lseek (this->fd_, skip, SEEK_CUR) < 0)\n+    {\n+      if (!this->saw_error ())\n+\trust_fatal_error (Linemap::unknown_location (), \"lseek failed: %m\");\n+      this->set_saw_error ();\n+    }\n+  if (!this->data_.empty ())\n+    {\n+      if (this->data_.length () > skip)\n+\tthis->data_.erase (0, skip);\n+      else\n+\tthis->data_.clear ();\n+    }\n+}\n+\n+} // namespace Rust"}, {"sha": "51cc4fc761383292112d135b9194ebc0a51806c1", "filename": "gcc/rust/metadata/rust-imports.h", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Fmetadata%2Frust-imports.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Fmetadata%2Frust-imports.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-imports.h?ref=509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6", "patch": "@@ -0,0 +1,257 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef RUST_IMPORTS_H\n+#define RUST_IMPORTS_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-location.h\"\n+\n+namespace Rust {\n+\n+extern void\n+add_search_path (const std::string &path);\n+\n+class Import\n+{\n+public:\n+  // The Stream class is an interface used to read the data.  The\n+  // caller should instantiate a child of this class.\n+  class Stream\n+  {\n+  public:\n+    Stream ();\n+    virtual ~Stream ();\n+\n+    // Set the position, for error messages.\n+    void set_pos (int pos) { this->pos_ = pos; }\n+\n+    // Return whether we have seen an error.\n+    bool saw_error () const { return this->saw_error_; }\n+\n+    // Record that we've seen an error.\n+    void set_saw_error () { this->saw_error_ = true; }\n+\n+    // Return the next character (a value from 0 to 0xff) without\n+    // advancing.  Returns -1 at end of stream.\n+    int peek_char ();\n+\n+    // Look for LENGTH characters, setting *BYTES to point to them.\n+    // Returns false if the bytes are not available.  Does not\n+    // advance.\n+    bool peek (size_t length, const char **bytes)\n+    {\n+      return this->do_peek (length, bytes);\n+    }\n+\n+    // Return the next character (a value from 0 to 0xff) and advance\n+    // the read position by 1.  Returns -1 at end of stream.\n+    int get_char ()\n+    {\n+      int c = this->peek_char ();\n+      this->advance (1);\n+      return c;\n+    }\n+\n+    // Return true if at the end of the stream.\n+    bool at_eof () { return this->peek_char () == -1; }\n+\n+    // Return true if the next bytes match STR.\n+    bool match_c_string (const char *str)\n+    {\n+      return this->match_bytes (str, strlen (str));\n+    }\n+\n+    // Return true if the next LENGTH bytes match BYTES.\n+    bool match_bytes (const char *bytes, size_t length);\n+\n+    // Give an error if the next bytes do not match STR.  Advance the\n+    // read position by the length of STR.\n+    void require_c_string (Location location, const char *str)\n+    {\n+      this->require_bytes (location, str, strlen (str));\n+    }\n+\n+    // Given an error if the next LENGTH bytes do not match BYTES.\n+    // Advance the read position by LENGTH.\n+    void require_bytes (Location, const char *bytes, size_t length);\n+\n+    // Advance the read position by SKIP bytes.\n+    void advance (size_t skip)\n+    {\n+      this->do_advance (skip);\n+      this->pos_ += skip;\n+    }\n+\n+    // Return the current read position.  This returns int because it\n+    // is more convenient in error reporting.  FIXME.\n+    int pos () { return static_cast<int> (this->pos_); }\n+\n+    // This function should set *BYTES to point to a buffer holding\n+    // the LENGTH bytes at the current read position.  It should\n+    // return false if the bytes are not available.  This should not\n+    // change the current read position.\n+    virtual bool do_peek (size_t length, const char **bytes) = 0;\n+\n+    // This function should advance the current read position LENGTH\n+    // bytes.\n+    virtual void do_advance (size_t skip) = 0;\n+\n+  private:\n+    // The current read position.\n+    size_t pos_;\n+    // True if we've seen an error reading from this stream.\n+    bool saw_error_;\n+  };\n+\n+  // Find import data.  This searches the file system for FILENAME and\n+  // returns a pointer to a Stream object to read the data that it\n+  // exports.  LOCATION is the location of the import statement.\n+  // RELATIVE_IMPORT_PATH is used as a prefix for a relative import.\n+  static Stream *open_package (const std::string &filename, Location location,\n+\t\t\t       const std::string &relative_import_path);\n+\n+  // Constructor.\n+  Import (Stream *, Location);\n+\n+  // The location of the import statement.\n+  Location location () const { return this->location_; }\n+\n+  // Return the next character.\n+  int peek_char () { return this->stream_->peek_char (); }\n+\n+  // Return the next character and advance.\n+  int get_char () { return this->stream_->get_char (); }\n+\n+  // Read LENGTH characters into *OUT and advance past them.  On\n+  // EOF reports an error and sets *OUT to an empty string.\n+  void read (size_t length, std::string *out);\n+\n+  // Return true at the end of the stream.\n+  bool at_eof () { return this->stream_->at_eof (); }\n+\n+  // Return whether the next bytes match STR.\n+  bool match_c_string (const char *str)\n+  {\n+    return this->stream_->match_c_string (str);\n+  }\n+\n+  // Require that the next bytes match STR.\n+  void require_c_string (const char *str)\n+  {\n+    this->stream_->require_c_string (this->location_, str);\n+  }\n+\n+  // Advance the stream SKIP bytes.\n+  void advance (size_t skip) { this->stream_->advance (skip); }\n+\n+  // Stream position, for error reporting.\n+  int pos () { return this->stream_->pos (); }\n+\n+  // Clear the stream when it is no longer accessible.\n+  void clear_stream () { this->stream_ = NULL; }\n+\n+private:\n+  static Stream *try_package_in_directory (const std::string &, Location);\n+\n+  static int try_suffixes (std::string *);\n+\n+  static Stream *find_export_data (const std::string &filename, int fd,\n+\t\t\t\t   Location);\n+\n+  static Stream *find_object_export_data (const std::string &filename, int fd,\n+\t\t\t\t\t  off_t offset, Location);\n+\n+  static bool is_archive_magic (const char *);\n+\n+  static Stream *find_archive_export_data (const std::string &filename, int fd,\n+\t\t\t\t\t   Location);\n+\n+  // The stream from which to read import data.\n+  Stream *stream_;\n+  // The location of the import statement we are processing.\n+  Location location_;\n+};\n+\n+// Read import data from a string.\n+\n+class Stream_from_string : public Import::Stream\n+{\n+public:\n+  Stream_from_string (const std::string &str) : str_ (str), pos_ (0) {}\n+\n+  bool do_peek (size_t length, const char **bytes)\n+  {\n+    if (this->pos_ + length > this->str_.length ())\n+      return false;\n+    *bytes = this->str_.data () + this->pos_;\n+    return true;\n+  }\n+\n+  void do_advance (size_t len) { this->pos_ += len; }\n+\n+private:\n+  // The string of data we are reading.\n+  std::string str_;\n+  // The current position within the string.\n+  size_t pos_;\n+};\n+\n+// Read import data from a buffer allocated using malloc.\n+\n+class Stream_from_buffer : public Import::Stream\n+{\n+public:\n+  Stream_from_buffer (char *buf, size_t length)\n+    : buf_ (buf), length_ (length), pos_ (0)\n+  {}\n+\n+  ~Stream_from_buffer () { free (this->buf_); }\n+\n+  bool do_peek (size_t length, const char **bytes)\n+  {\n+    if (this->pos_ + length > this->length_)\n+      return false;\n+    *bytes = this->buf_ + this->pos_;\n+    return true;\n+  }\n+\n+  void do_advance (size_t len) { this->pos_ += len; }\n+\n+private:\n+  // The data we are reading.\n+  char *buf_;\n+  // The length of the buffer.\n+  size_t length_;\n+  // The current position within the buffer.\n+  size_t pos_;\n+};\n+\n+// Read import data from an open file descriptor.\n+\n+class Stream_from_file : public Import::Stream\n+{\n+public:\n+  Stream_from_file (int fd);\n+\n+  ~Stream_from_file ();\n+\n+  bool do_peek (size_t, const char **);\n+\n+  void do_advance (size_t);\n+\n+private:\n+  // No copying.\n+  Stream_from_file (const Stream_from_file &);\n+  Stream_from_file &operator= (const Stream_from_file &);\n+\n+  // The file descriptor.\n+  int fd_;\n+  // Data read from the file.\n+  std::string data_;\n+};\n+\n+} // namespace Rust\n+\n+#endif // RUST_IMPORTS_H"}, {"sha": "e1c0a924c6ac940f8c4eadd659a4b06f1e8a234a", "filename": "gcc/rust/rust-object-export.cc", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Frust-object-export.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Frust-object-export.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-object-export.cc?ref=509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6", "patch": "@@ -0,0 +1,176 @@\n+/* rust-backend.c -- Rust frontend interface to gcc backend.\n+   Copyright (C) 2010-2022 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"rust-system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"tree.h\"\n+#include \"memmodel.h\"\n+#include \"tm_p.h\"\n+#include \"diagnostic.h\"\n+#include \"simple-object.h\"\n+#include \"stor-layout.h\"\n+#include \"intl.h\"\n+#include \"output.h\" /* for assemble_string */\n+#include \"common/common-target.h\"\n+\n+// satisfy intellisense\n+#include \"options.h\"\n+\n+/* The segment name we pass to simple_object_start_read to find Rust\n+   export data.  */\n+\n+#ifndef RUST_EXPORT_SEGMENT_NAME\n+#define RUST_EXPORT_SEGMENT_NAME \"__GNU_RUST\"\n+#endif\n+\n+/* The section name we use when reading and writing export data.  */\n+\n+#ifndef RUST_EXPORT_SECTION_NAME\n+#define RUST_EXPORT_SECTION_NAME \".rust_export\"\n+#endif\n+\n+#ifndef TARGET_AIX\n+#define TARGET_AIX 0\n+#endif\n+\n+/* Return whether or not GCC has reported any errors.  */\n+\n+bool\n+saw_errors (void)\n+{\n+  return errorcount != 0 || sorrycount != 0;\n+}\n+\n+/* Return the alignment in bytes of a struct field of type T.  */\n+\n+unsigned int\n+rust_field_alignment (tree t)\n+{\n+  unsigned int v;\n+\n+  v = TYPE_ALIGN (t);\n+\n+#ifdef BIGGEST_FIELD_ALIGNMENT\n+  if (v > BIGGEST_FIELD_ALIGNMENT)\n+    v = BIGGEST_FIELD_ALIGNMENT;\n+#endif\n+\n+#ifdef ADJUST_FIELD_ALIGN\n+  v = ADJUST_FIELD_ALIGN (NULL_TREE, t, v);\n+#endif\n+\n+  return v / BITS_PER_UNIT;\n+}\n+\n+/* This is called by the Rust frontend proper to add data to the\n+   section containing Rust export data.  */\n+\n+void\n+rust_write_export_data (const char *bytes, unsigned int size)\n+{\n+  static section *sec;\n+\n+  if (sec == NULL)\n+    {\n+      gcc_assert (targetm_common.have_named_sections);\n+      sec = get_section (RUST_EXPORT_SECTION_NAME,\n+\t\t\t TARGET_AIX ? SECTION_EXCLUDE : SECTION_DEBUG, NULL);\n+    }\n+\n+  switch_to_section (sec);\n+  assemble_string (bytes, size);\n+}\n+\n+/* The rust_read_export_data function is called by the Rust frontend\n+   proper to read Rust export data from an object file.  FD is a file\n+   descriptor open for reading.  OFFSET is the offset within the file\n+   where the object file starts; this will be 0 except when reading an\n+   archive.  On success this returns NULL and sets *PBUF to a buffer\n+   allocated using malloc, of size *PLEN, holding the export data.  If\n+   the data is not found, this returns NULL and sets *PBUF to NULL and\n+   *PLEN to 0.  If some error occurs, this returns an error message\n+   and sets *PERR to an errno value or 0 if there is no relevant\n+   errno.  */\n+\n+const char *\n+rust_read_export_data (int fd, off_t offset, char **pbuf, size_t *plen,\n+\t\t       int *perr)\n+{\n+  simple_object_read *sobj;\n+  const char *errmsg;\n+  off_t sec_offset;\n+  off_t sec_length;\n+  int found;\n+  char *buf;\n+  ssize_t c;\n+\n+  *pbuf = NULL;\n+  *plen = 0;\n+\n+  sobj = simple_object_start_read (fd, offset, RUST_EXPORT_SEGMENT_NAME,\n+\t\t\t\t   &errmsg, perr);\n+  if (sobj == NULL)\n+    {\n+      /* If we get an error here, just pretend that we didn't find any\n+\t export data.  This is the right thing to do if the error is\n+\t that the file was not recognized as an object file.  This\n+\t will ignore file I/O errors, but it's not too big a deal\n+\t because we will wind up giving some other error later.  */\n+      return NULL;\n+    }\n+\n+  found = simple_object_find_section (sobj, RUST_EXPORT_SECTION_NAME,\n+\t\t\t\t      &sec_offset, &sec_length, &errmsg, perr);\n+  simple_object_release_read (sobj);\n+  if (!found)\n+    return errmsg;\n+\n+  if (lseek (fd, offset + sec_offset, SEEK_SET) < 0)\n+    {\n+      *perr = errno;\n+      return _ (\"lseek failed while reading export data\");\n+    }\n+\n+  buf = XNEWVEC (char, sec_length);\n+  if (buf == NULL)\n+    {\n+      *perr = errno;\n+      return _ (\"memory allocation failed while reading export data\");\n+    }\n+\n+  c = read (fd, buf, sec_length);\n+  if (c < 0)\n+    {\n+      *perr = errno;\n+      free (buf);\n+      return _ (\"read failed while reading export data\");\n+    }\n+\n+  if (c < sec_length)\n+    {\n+      free (buf);\n+      return _ (\"short read while reading export data\");\n+    }\n+\n+  *pbuf = buf;\n+  *plen = sec_length;\n+\n+  return NULL;\n+}"}, {"sha": "fcede54ae5992bf2d7f18ed4c50f7a3fd56f78ef", "filename": "gcc/rust/rust-object-export.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Frust-object-export.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6/gcc%2Frust%2Frust-object-export.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-object-export.h?ref=509e4c32c6a80ede6c6dda0f4cfc96f94d24c4d6", "patch": "@@ -0,0 +1,33 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_OBJECT_EXPORT_H\n+#define RUST_OBJECT_EXPORT_H\n+\n+#include \"rust-system.h\"\n+\n+extern unsigned int\n+rust_field_alignment (tree t);\n+\n+extern const char *\n+rust_read_export_data (int fd, off_t offset, char **pbuf, size_t *plen,\n+\t\t       int *perr);\n+extern void\n+rust_write_export_data (const char *bytes, unsigned int size);\n+\n+#endif // RUST_OBJECT_EXPORT_H"}]}