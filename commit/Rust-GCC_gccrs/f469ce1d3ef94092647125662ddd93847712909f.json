{"sha": "f469ce1d3ef94092647125662ddd93847712909f", "node_id": "C_kwDOANBUbNoAKGY0NjljZTFkM2VmOTQwOTI2NDcxMjU2NjJkZGQ5Mzg0NzcxMjkwOWY", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2022-09-06T22:34:38Z"}, "committer": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2022-09-14T13:59:55Z"}, "message": "OpenMP/OpenACC: mapping group list-handling improvements\n\nThis patch adjusts OpenMP/OpenACC clause list handling in a couple of\nplaces, in preparation for the following mapping-clause expansion rework\npatch. Firstly mapping groups are removed as a whole in the C and C++\nfront-ends when an error is detected, which avoids leaving \"badly-formed\"\nmapping clause groups in the list.\n\nSecondly, reindexing of the omp_mapping_group hashmap (during\nomp_build_struct_sibling_lists) has been reimplemented, fixing some\ntricky corner-cases where mapping groups are removed from a list at the\nsame time as it is being reordered.\n\nThirdly, code to check if a different clause on the same directive maps\nthe whole of a struct that we have a component mapping for (for example)\nhas been outlined, removing a bit of code duplication.\n\n2022-09-13  Julian Brown  <julian@codesourcery.com>\n\ngcc/\n\t* gimplify.cc (omp_group_last): Allow GOMP_MAP_ATTACH_DETACH after\n\tGOMP_MAP_STRUCT (for reindexing).\n\t(omp_gather_mapping_groups): Reimplement using...\n\t(omp_gather_mapping_groups_1): This new function.  Stop processing at\n\tGATHER_SENTINEL.\n\t(omp_group_base): Allow GOMP_MAP_TO_PSET without any following node.\n\t(omp_index_mapping_groups): Reimplement using...\n\t(omp_index_mapping_groups_1): This new function.  Handle\n\tREINDEX_SENTINEL.\n\t(omp_reindex_mapping_groups, omp_mapped_by_containing_struct): New\n\tfunctions.\n\t(omp_tsort_mapping_groups_1): Adjust handling of base group being the\n\tsame as current group.  Use omp_mapped_by_containing_struct.\n\t(omp_build_struct_sibling_lists): Use omp_mapped_by_containing_struct\n\tand omp_reindex_mapping_groups.  Robustify group deletion for reordered\n\tlists.\n\t(gimplify_scan_omp_clauses): Update calls to\n\tomp_build_struct_sibling_lists.\n\ngcc/c/\n\t* c-typeck.cc (c_finish_omp_clauses): Remove whole mapping node group\n\ton error.\n\ngcc/cp/\n\t* semantics.cc (finish_omp_clauses): Likewise.", "tree": {"sha": "d4f00619fa555d863cf5ad7e25b480c3fab6b043", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4f00619fa555d863cf5ad7e25b480c3fab6b043"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f469ce1d3ef94092647125662ddd93847712909f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f469ce1d3ef94092647125662ddd93847712909f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f469ce1d3ef94092647125662ddd93847712909f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f469ce1d3ef94092647125662ddd93847712909f/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23baa717c991d77f206a9358ce2c04960ccf9eea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23baa717c991d77f206a9358ce2c04960ccf9eea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23baa717c991d77f206a9358ce2c04960ccf9eea"}], "stats": {"total": 281, "additions": 213, "deletions": 68}, "files": [{"sha": "43a910d5df20957412e66dca2cd040578bfb6cf0", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f469ce1d3ef94092647125662ddd93847712909f/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f469ce1d3ef94092647125662ddd93847712909f/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=f469ce1d3ef94092647125662ddd93847712909f", "patch": "@@ -14238,12 +14238,19 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  break;\n \t}\n \n+  tree *grp_start_p = NULL, grp_sentinel = NULL_TREE;\n+\n   for (pc = &clauses, c = clauses; c ; c = *pc)\n     {\n       bool remove = false;\n       bool need_complete = false;\n       bool need_implicitly_determined = false;\n \n+      /* We've reached the end of a list of expanded nodes.  Reset the group\n+\t start pointer.  */\n+      if (c == grp_sentinel)\n+\tgrp_start_p = NULL;\n+\n       switch (OMP_CLAUSE_CODE (c))\n \t{\n \tcase OMP_CLAUSE_SHARED:\n@@ -15001,6 +15008,9 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (t) == TREE_LIST)\n \t    {\n+\t      grp_start_p = pc;\n+\t      grp_sentinel = OMP_CLAUSE_CHAIN (c);\n+\n \t      if (handle_omp_array_sections (c, ort))\n \t\tremove = true;\n \t      else\n@@ -15644,7 +15654,19 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t}\n \n       if (remove)\n-\t*pc = OMP_CLAUSE_CHAIN (c);\n+\t{\n+\t  if (grp_start_p)\n+\t    {\n+\t      /* If we found a clause to remove, we want to remove the whole\n+\t\t expanded group, otherwise gimplify\n+\t\t (omp_resolve_clause_dependencies) can get confused.  */\n+\t      *grp_start_p = grp_sentinel;\n+\t      pc = grp_start_p;\n+\t      grp_start_p = NULL;\n+\t    }\n+\t  else\n+\t    *pc = OMP_CLAUSE_CHAIN (c);\n+\t}\n       else\n \tpc = &OMP_CLAUSE_CHAIN (c);\n     }"}, {"sha": "427b1ab5ebc3a61e38133345c5bfd8075a02bf2b", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f469ce1d3ef94092647125662ddd93847712909f/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f469ce1d3ef94092647125662ddd93847712909f/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=f469ce1d3ef94092647125662ddd93847712909f", "patch": "@@ -6755,11 +6755,18 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  break;\n \t}\n \n+  tree *grp_start_p = NULL, grp_sentinel = NULL_TREE;\n+\n   for (pc = &clauses, c = clauses; c ; c = *pc)\n     {\n       bool remove = false;\n       bool field_ok = false;\n \n+      /* We've reached the end of a list of expanded nodes.  Reset the group\n+\t start pointer.  */\n+      if (c == grp_sentinel)\n+\tgrp_start_p = NULL;\n+\n       switch (OMP_CLAUSE_CODE (c))\n \t{\n \tcase OMP_CLAUSE_SHARED:\n@@ -7982,6 +7989,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (t) == TREE_LIST)\n \t    {\n+\t      grp_start_p = pc;\n+\t      grp_sentinel = OMP_CLAUSE_CHAIN (c);\n+\n \t      if (handle_omp_array_sections (c, ort))\n \t\tremove = true;\n \t      else\n@@ -8353,6 +8363,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t       && (OMP_CLAUSE_MAP_KIND (c)\n \t\t\t   != GOMP_MAP_ATTACH_DETACH))\n \t\t{\n+\t\t  grp_start_p = pc;\n+\t\t  grp_sentinel = OMP_CLAUSE_CHAIN (c);\n+\n \t\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t      OMP_CLAUSE_MAP);\n \t\t  if (TREE_CODE (t) == COMPONENT_REF)\n@@ -8763,7 +8776,18 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t}\n \n       if (remove)\n-\t*pc = OMP_CLAUSE_CHAIN (c);\n+\t{\n+\t  if (grp_start_p)\n+\t    {\n+\t      /* If we found a clause to remove, we want to remove the whole\n+\t\t expanded group, otherwise gimplify can get confused.  */\n+\t      *grp_start_p = grp_sentinel;\n+\t      pc = grp_start_p;\n+\t      grp_start_p = NULL;\n+\t    }\n+\t  else\n+\t    *pc = OMP_CLAUSE_CHAIN (c);\n+\t}\n       else\n \tpc = &OMP_CLAUSE_CHAIN (c);\n     }"}, {"sha": "2ae0c8cb2507fa578a0a8a4ea1c4cdc67dfc1ff4", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 165, "deletions": 66, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f469ce1d3ef94092647125662ddd93847712909f/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f469ce1d3ef94092647125662ddd93847712909f/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=f469ce1d3ef94092647125662ddd93847712909f", "patch": "@@ -9154,7 +9154,8 @@ omp_group_last (tree *start_p)\n \tunsigned HOST_WIDE_INT num_mappings\n \t  = tree_to_uhwi (OMP_CLAUSE_SIZE (c));\n \tif (OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_FIRSTPRIVATE_POINTER\n-\t    || OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_FIRSTPRIVATE_REFERENCE)\n+\t    || OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_FIRSTPRIVATE_REFERENCE\n+\t    || OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_ATTACH_DETACH)\n \t  grp_last_p = &OMP_CLAUSE_CHAIN (*grp_last_p);\n \tfor (unsigned i = 0; i < num_mappings; i++)\n \t  grp_last_p = &OMP_CLAUSE_CHAIN (*grp_last_p);\n@@ -9170,12 +9171,13 @@ omp_group_last (tree *start_p)\n    associated GOMP_MAP_POINTER mappings).  Return a vector of omp_mapping_group\n    if we have more than one such group, else return NULL.  */\n \n-static vec<omp_mapping_group> *\n-omp_gather_mapping_groups (tree *list_p)\n+static void\n+omp_gather_mapping_groups_1 (tree *list_p, vec<omp_mapping_group> *groups,\n+\t\t\t     tree gather_sentinel)\n {\n-  vec<omp_mapping_group> *groups = new vec<omp_mapping_group> ();\n-\n-  for (tree *cp = list_p; *cp; cp = &OMP_CLAUSE_CHAIN (*cp))\n+  for (tree *cp = list_p;\n+       *cp && *cp != gather_sentinel;\n+       cp = &OMP_CLAUSE_CHAIN (*cp))\n     {\n       if (OMP_CLAUSE_CODE (*cp) != OMP_CLAUSE_MAP)\n \tcontinue;\n@@ -9193,6 +9195,14 @@ omp_gather_mapping_groups (tree *list_p)\n \n       cp = grp_last_p;\n     }\n+}\n+\n+static vec<omp_mapping_group> *\n+omp_gather_mapping_groups (tree *list_p)\n+{\n+  vec<omp_mapping_group> *groups = new vec<omp_mapping_group> ();\n+\n+  omp_gather_mapping_groups_1 (list_p, groups, NULL_TREE);\n \n   if (groups->length () > 0)\n     return groups;\n@@ -9241,7 +9251,8 @@ omp_group_base (omp_mapping_group *grp, unsigned int *chained,\n       node = OMP_CLAUSE_CHAIN (node);\n       if (node && OMP_CLAUSE_MAP_KIND (node) == GOMP_MAP_TO_PSET)\n \t{\n-\t  gcc_assert (node != grp->grp_end);\n+\t  if (node == grp->grp_end)\n+\t    return *grp->grp_start;\n \t  node = OMP_CLAUSE_CHAIN (node);\n \t}\n       if (node)\n@@ -9339,18 +9350,22 @@ omp_group_base (omp_mapping_group *grp, unsigned int *chained,\n /* Given a vector of omp_mapping_groups, build a hash table so we can look up\n    nodes by tree_operand_hash.  */\n \n-static hash_map<tree_operand_hash, omp_mapping_group *> *\n-omp_index_mapping_groups (vec<omp_mapping_group> *groups)\n+static void\n+omp_index_mapping_groups_1 (hash_map<tree_operand_hash,\n+\t\t\t\t     omp_mapping_group *> *grpmap,\n+\t\t\t    vec<omp_mapping_group> *groups,\n+\t\t\t    tree reindex_sentinel)\n {\n-  hash_map<tree_operand_hash, omp_mapping_group *> *grpmap\n-    = new hash_map<tree_operand_hash, omp_mapping_group *>;\n-\n   omp_mapping_group *grp;\n   unsigned int i;\n+  bool reindexing = reindex_sentinel != NULL_TREE, above_hwm = false;\n \n   FOR_EACH_VEC_ELT (*groups, i, grp)\n     {\n-      if (grp->deleted)\n+      if (reindexing && *grp->grp_start == reindex_sentinel)\n+\tabove_hwm = true;\n+\n+      if (reindexing && !above_hwm)\n \tcontinue;\n \n       tree fpp;\n@@ -9372,8 +9387,7 @@ omp_index_mapping_groups (vec<omp_mapping_group> *groups)\n \t     source instead.  FIXME.  */\n \t  if (TREE_CODE (decl) == MEM_REF\n \t      && integer_zerop (TREE_OPERAND (decl, 1)))\n-\t    decl = build1 (INDIRECT_REF, TREE_TYPE (decl),\n-\t\t\t   TREE_OPERAND (decl, 0));\n+\t    decl = build_fold_indirect_ref (TREE_OPERAND (decl, 0));\n \n \t  omp_mapping_group **prev = grpmap->get (decl);\n \n@@ -9402,14 +9416,56 @@ omp_index_mapping_groups (vec<omp_mapping_group> *groups)\n \tcontinue;\n \n       omp_mapping_group **prev = grpmap->get (fpp);\n-      if (prev)\n+      if (prev && *prev != grp)\n \t{\n \t  grp->sibling = (*prev)->sibling;\n \t  (*prev)->sibling = grp;\n \t}\n       else\n \tgrpmap->put (fpp, grp);\n     }\n+}\n+\n+static hash_map<tree_operand_hash, omp_mapping_group *> *\n+omp_index_mapping_groups (vec<omp_mapping_group> *groups)\n+{\n+  hash_map<tree_operand_hash, omp_mapping_group *> *grpmap\n+    = new hash_map<tree_operand_hash, omp_mapping_group *>;\n+\n+  omp_index_mapping_groups_1 (grpmap, groups, NULL_TREE);\n+\n+  return grpmap;\n+}\n+\n+/* Rebuild group map from partially-processed clause list (during\n+   omp_build_struct_sibling_lists).  We have already processed nodes up until\n+   a high-water mark (HWM).  This is a bit tricky because the list is being\n+   reordered as it is scanned, but we know:\n+\n+   1. The list after HWM has not been touched yet, so we can reindex it safely.\n+\n+   2. The list before and including HWM has been altered, but remains\n+      well-formed throughout the sibling-list building operation.\n+\n+   so, we can do the reindex operation in two parts, on the processed and\n+   then the unprocessed halves of the list.  */\n+\n+static hash_map<tree_operand_hash, omp_mapping_group *> *\n+omp_reindex_mapping_groups (tree *list_p,\n+\t\t\t    vec<omp_mapping_group> *groups,\n+\t\t\t    vec<omp_mapping_group> *processed_groups,\n+\t\t\t    tree sentinel)\n+{\n+  hash_map<tree_operand_hash, omp_mapping_group *> *grpmap\n+    = new hash_map<tree_operand_hash, omp_mapping_group *>;\n+\n+  processed_groups->truncate (0);\n+\n+  omp_gather_mapping_groups_1 (list_p, processed_groups, sentinel);\n+  omp_index_mapping_groups_1 (grpmap, processed_groups, NULL_TREE);\n+  if (sentinel)\n+    omp_index_mapping_groups_1 (grpmap, groups, sentinel);\n+\n   return grpmap;\n }\n \n@@ -9437,6 +9493,45 @@ omp_containing_struct (tree expr)\n   return expr;\n }\n \n+/* Return TRUE if DECL describes a component that is part of a whole structure\n+   that is mapped elsewhere in GRPMAP.  *MAPPED_BY_GROUP is set to the group\n+   that maps that structure, if present.  */\n+\n+static bool\n+omp_mapped_by_containing_struct (hash_map<tree_operand_hash,\n+\t\t\t\t\t  omp_mapping_group *> *grpmap,\n+\t\t\t\t tree decl,\n+\t\t\t\t omp_mapping_group **mapped_by_group)\n+{\n+  tree wsdecl = NULL_TREE;\n+\n+  *mapped_by_group = NULL;\n+\n+  while (true)\n+    {\n+      wsdecl = omp_containing_struct (decl);\n+      if (wsdecl == decl)\n+\tbreak;\n+      omp_mapping_group **wholestruct = grpmap->get (wsdecl);\n+      if (!wholestruct\n+\t  && TREE_CODE (wsdecl) == MEM_REF\n+\t  && integer_zerop (TREE_OPERAND (wsdecl, 1)))\n+\t{\n+\t  tree deref = TREE_OPERAND (wsdecl, 0);\n+\t  deref = build_fold_indirect_ref (deref);\n+\t  wholestruct = grpmap->get (deref);\n+\t}\n+      if (wholestruct)\n+\t{\n+\t  *mapped_by_group = *wholestruct;\n+\t  return true;\n+\t}\n+      decl = wsdecl;\n+    }\n+\n+  return false;\n+}\n+\n /* Helper function for omp_tsort_mapping_groups.  Returns TRUE on success, or\n    FALSE on error.  */\n \n@@ -9464,9 +9559,8 @@ omp_tsort_mapping_groups_1 (omp_mapping_group ***outlist,\n     {\n       omp_mapping_group **basep = grpmap->get (attaches_to);\n \n-      if (basep)\n+      if (basep && *basep != grp)\n \t{\n-\t  gcc_assert (*basep != grp);\n \t  for (omp_mapping_group *w = *basep; w; w = w->sibling)\n \t    if (!omp_tsort_mapping_groups_1 (outlist, groups, grpmap, w))\n \t      return false;\n@@ -9483,25 +9577,16 @@ omp_tsort_mapping_groups_1 (omp_mapping_group ***outlist,\n \tbreak;\n \n       omp_mapping_group **innerp = grpmap->get (base);\n+      omp_mapping_group *wholestruct;\n \n       /* We should treat whole-structure mappings as if all (pointer, in this\n \t case) members are mapped as individual list items.  Check if we have\n \t such a whole-structure mapping, if we don't have an explicit reference\n \t to the pointer member itself.  */\n-      if (!innerp && TREE_CODE (base) == COMPONENT_REF)\n-\t{\n-\t  base = omp_containing_struct (base);\n-\t  innerp = grpmap->get (base);\n-\n-\t  if (!innerp\n-\t      && TREE_CODE (base) == MEM_REF\n-\t      && integer_zerop (TREE_OPERAND (base, 1)))\n-\t    {\n-\t      tree ind = TREE_OPERAND (base, 0);\n-\t      ind = build1 (INDIRECT_REF, TREE_TYPE (base), ind);\n-\t      innerp = grpmap->get (ind);\n-\t    }\n-\t}\n+      if (!innerp\n+\t  && TREE_CODE (base) == COMPONENT_REF\n+\t  && omp_mapped_by_containing_struct (grpmap, base, &wholestruct))\n+\tinnerp = &wholestruct;\n \n       if (innerp && *innerp != grp)\n \t{\n@@ -10285,24 +10370,31 @@ omp_build_struct_sibling_lists (enum tree_code code,\n \t\t\t\tenum omp_region_type region_type,\n \t\t\t\tvec<omp_mapping_group> *groups,\n \t\t\t\thash_map<tree_operand_hash, omp_mapping_group *>\n-\t\t\t\t  **grpmap)\n+\t\t\t\t  **grpmap,\n+\t\t\t\ttree *list_p)\n {\n   unsigned i;\n   omp_mapping_group *grp;\n   hash_map<tree_operand_hash, tree> *struct_map_to_clause = NULL;\n   bool success = true;\n   tree *new_next = NULL;\n   tree *tail = &OMP_CLAUSE_CHAIN ((*groups)[groups->length () - 1].grp_end);\n+  auto_vec<omp_mapping_group> pre_hwm_groups;\n \n   FOR_EACH_VEC_ELT (*groups, i, grp)\n     {\n       tree c = grp->grp_end;\n       tree decl = OMP_CLAUSE_DECL (c);\n-      tree *grp_start_p = new_next ? new_next : grp->grp_start;\n       tree grp_end = grp->grp_end;\n+      tree sentinel = OMP_CLAUSE_CHAIN (grp_end);\n+\n+      if (new_next)\n+\tgrp->grp_start = new_next;\n \n       new_next = NULL;\n \n+      tree *grp_start_p = grp->grp_start;\n+\n       if (DECL_P (decl))\n \tcontinue;\n \n@@ -10342,36 +10434,16 @@ omp_build_struct_sibling_lists (enum tree_code code,\n       if (TREE_CODE (decl) != COMPONENT_REF)\n \tcontinue;\n \n-      omp_mapping_group **wholestruct = NULL;\n-      tree wsdecl = omp_containing_struct (OMP_CLAUSE_DECL (c));\n-\n-      if (!(region_type & ORT_ACC) && wsdecl != OMP_CLAUSE_DECL (c))\n-\t{\n-\t  wholestruct = (*grpmap)->get (wsdecl);\n-\t  if (!wholestruct\n-\t      && TREE_CODE (wsdecl) == MEM_REF\n-\t      && integer_zerop (TREE_OPERAND (wsdecl, 1)))\n-\t    {\n-\t      tree deref = TREE_OPERAND (wsdecl, 0);\n-\t      deref = build1 (INDIRECT_REF, TREE_TYPE (wsdecl), deref);\n-\t      wholestruct = (*grpmap)->get (deref);\n-\t    }\n-\t}\n-\n-      if (wholestruct)\n+      /* If we're mapping the whole struct in another node, skip creation of\n+\t sibling lists.  */\n+      omp_mapping_group *wholestruct;\n+      if (!(region_type & ORT_ACC)\n+\t  && omp_mapped_by_containing_struct (*grpmap, OMP_CLAUSE_DECL (c),\n+\t\t\t\t\t      &wholestruct))\n \t{\n \t  if (*grp_start_p == grp_end)\n-\t    {\n-\t      /* Remove the whole of this mapping -- redundant.  */\n-\t      if (i + 1 < groups->length ())\n-\t\t{\n-\t\t  omp_mapping_group *nextgrp = &(*groups)[i + 1];\n-\t\t  nextgrp->grp_start = grp_start_p;\n-\t\t}\n-\t      grp->deleted = true;\n-\t      new_next = grp_start_p;\n-\t      *grp_start_p = OMP_CLAUSE_CHAIN (grp_end);\n-\t    }\n+\t    /* Remove the whole of this mapping -- redundant.  */\n+\t    grp->deleted = true;\n \n \t  continue;\n \t}\n@@ -10416,7 +10488,6 @@ omp_build_struct_sibling_lists (enum tree_code code,\n \t\t*tail = inner;\n \n \t      OMP_CLAUSE_CHAIN (inner) = NULL_TREE;\n-\n \t      omp_mapping_group newgrp;\n \t      newgrp.grp_start = new_next ? new_next : tail;\n \t      newgrp.grp_end = inner;\n@@ -10430,13 +10501,39 @@ omp_build_struct_sibling_lists (enum tree_code code,\n \t\t map.  Rebuild it here.  This is a bit inefficient, but\n \t\t shouldn't happen very often.  */\n \t      delete (*grpmap);\n-\t      *grpmap = omp_index_mapping_groups (groups);\n+\t      *grpmap\n+\t\t= omp_reindex_mapping_groups (list_p, groups, &pre_hwm_groups,\n+\t\t\t\t\t      sentinel);\n \n \t      tail = &OMP_CLAUSE_CHAIN (inner);\n \t    }\n \t}\n     }\n \n+  /* Delete groups marked for deletion above.  At this point the order of the\n+     groups may no longer correspond to the order of the underlying list,\n+     which complicates this a little.  First clear out OMP_CLAUSE_DECL for\n+     deleted nodes...  */\n+\n+  FOR_EACH_VEC_ELT (*groups, i, grp)\n+    if (grp->deleted)\n+      for (tree d = *grp->grp_start;\n+\t   d != OMP_CLAUSE_CHAIN (grp->grp_end);\n+\t   d = OMP_CLAUSE_CHAIN (d))\n+\tOMP_CLAUSE_DECL (d) = NULL_TREE;\n+\n+  /* ...then sweep through the list removing the now-empty nodes.  */\n+\n+  tail = list_p;\n+  while (*tail)\n+    {\n+      if (OMP_CLAUSE_CODE (*tail) == OMP_CLAUSE_MAP\n+\t  && OMP_CLAUSE_DECL (*tail) == NULL_TREE)\n+\t*tail = OMP_CLAUSE_CHAIN (*tail);\n+      else\n+\ttail = &OMP_CLAUSE_CHAIN (*tail);\n+    }\n+\n error_out:\n   if (struct_map_to_clause)\n     delete struct_map_to_clause;\n@@ -10497,7 +10594,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  hash_map<tree_operand_hash, omp_mapping_group *> *grpmap;\n \t  grpmap = omp_index_mapping_groups (groups);\n \n-\t  omp_build_struct_sibling_lists (code, region_type, groups, &grpmap);\n+\t  omp_build_struct_sibling_lists (code, region_type, groups, &grpmap,\n+\t\t\t\t\t  list_p);\n \n \t  omp_mapping_group *outlist = NULL;\n \n@@ -10532,7 +10630,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t  hash_map<tree_operand_hash, omp_mapping_group *> *grpmap;\n \t  grpmap = omp_index_mapping_groups (groups);\n \n-\t  omp_build_struct_sibling_lists (code, region_type, groups, &grpmap);\n+\t  omp_build_struct_sibling_lists (code, region_type, groups, &grpmap,\n+\t\t\t\t\t  list_p);\n \n \t  delete groups;\n \t  delete grpmap;"}]}