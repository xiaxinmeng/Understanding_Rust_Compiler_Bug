{"sha": "041f74177072df1d66502319205990a4d970c92a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQxZjc0MTc3MDcyZGYxZDY2NTAyMzE5MjA1OTkwYTRkOTcwYzkyYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-06-16T08:45:27Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-06-16T08:45:27Z"}, "message": "libffi: Fix up x86_64 classify_argument\n\nAs the following testcase shows, libffi didn't handle properly\nclassify_arguments of structures at byte offsets not divisible by\nUNITS_PER_WORD.  The following patch adjusts it to match what\nconfig/i386/ classify_argument does for that and also ports the\nPR38781 fix there (the second chunk).\n\nThis has been committed to upstream libffi already:\nhttps://github.com/libffi/libffi/commit/5651bea284ad0822eafe768e3443c2f4d7da2c8f\n\n2021-06-16  Jakub Jelinek  <jakub@redhat.com>\n\n\t* src/x86/ffi64.c (classify_argument): For FFI_TYPE_STRUCT set words\n\tto number of words needed for type->size + byte_offset bytes rather\n\tthan just type->size bytes.  Compute pos before the loop and check\n\ttotal size of the structure.\n\t* testsuite/libffi.call/nested_struct12.c: New test.", "tree": {"sha": "60e47c68aa73269439f7c1cbd7f873f6121266e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60e47c68aa73269439f7c1cbd7f873f6121266e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/041f74177072df1d66502319205990a4d970c92a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/041f74177072df1d66502319205990a4d970c92a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/041f74177072df1d66502319205990a4d970c92a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/041f74177072df1d66502319205990a4d970c92a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccf0dee109ba0c71ca2b6e093a874daf1671ecf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccf0dee109ba0c71ca2b6e093a874daf1671ecf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccf0dee109ba0c71ca2b6e093a874daf1671ecf0"}], "stats": {"total": 116, "additions": 112, "deletions": 4}, "files": [{"sha": "243cbc7689a21a183f837522f2745788c940a6f3", "filename": "libffi/src/x86/ffi64.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041f74177072df1d66502319205990a4d970c92a/libffi%2Fsrc%2Fx86%2Fffi64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041f74177072df1d66502319205990a4d970c92a/libffi%2Fsrc%2Fx86%2Fffi64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi64.c?ref=041f74177072df1d66502319205990a4d970c92a", "patch": "@@ -217,7 +217,8 @@ classify_argument (ffi_type *type, enum x86_64_reg_class classes[],\n     case FFI_TYPE_STRUCT:\n       {\n \tconst size_t UNITS_PER_WORD = 8;\n-\tsize_t words = (type->size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\tsize_t words = (type->size + byte_offset + UNITS_PER_WORD - 1)\n+\t\t       / UNITS_PER_WORD;\n \tffi_type **ptr;\n \tint i;\n \tenum x86_64_reg_class subclasses[MAX_CLASSES];\n@@ -241,16 +242,16 @@ classify_argument (ffi_type *type, enum x86_64_reg_class classes[],\n \t/* Merge the fields of structure.  */\n \tfor (ptr = type->elements; *ptr != NULL; ptr++)\n \t  {\n-\t    size_t num;\n+\t    size_t num, pos;\n \n \t    byte_offset = ALIGN (byte_offset, (*ptr)->alignment);\n \n \t    num = classify_argument (*ptr, subclasses, byte_offset % 8);\n \t    if (num == 0)\n \t      return 0;\n-\t    for (i = 0; i < num; i++)\n+\t    pos = byte_offset / 8;\n+\t    for (i = 0; i < num && (i + pos) < words; i++)\n \t      {\n-\t\tsize_t pos = byte_offset / 8;\n \t\tclasses[i + pos] =\n \t\t  merge_classes (subclasses[i], classes[i + pos]);\n \t      }"}, {"sha": "6f3d7369f274c3ffab7fc505c84b08d6ae4e53fe", "filename": "libffi/testsuite/libffi.call/nested_struct12.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/041f74177072df1d66502319205990a4d970c92a/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/041f74177072df1d66502319205990a4d970c92a/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct12.c?ref=041f74177072df1d66502319205990a4d970c92a", "patch": "@@ -0,0 +1,107 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<jincheng@ca.ibm.com> and <jakub@redhat.com> 20210609\t */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct A {\n+  float a, b;\n+} A;\n+\n+typedef struct B {\n+  float x;\n+  struct A y;\n+} B;\n+\n+B B_fn(float b0, struct B b1)\n+{\n+  struct B result;\n+\n+  result.x = b0 + b1.x;\n+  result.y.a = b0 + b1.y.a;\n+  result.y.b = b0 + b1.y.b;\n+\n+  printf(\"%g %g %g %g: %g %g %g\\n\", b0, b1.x, b1.y.a, b1.y.b,\n+\t result.x, result.y.a, result.y.b);\n+\n+  return result;\n+}\n+\n+static void\n+B_gn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n+     void* userdata __UNUSED__)\n+{\n+  float b0;\n+  struct B b1;\n+\n+  b0 = *(float*)(args[0]);\n+  b1 = *(struct B*)(args[1]);\n+\n+  *(B*)resp = B_fn(b0, b1);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n+  void* args_dbl[3];\n+  ffi_type* cls_struct_fields[3];\n+  ffi_type* cls_struct_fields1[3];\n+  ffi_type cls_struct_type, cls_struct_type1;\n+  ffi_type* dbl_arg_types[3];\n+\n+  float e_dbl = 12.125f;\n+  struct B f_dbl = { 24.75f, { 31.625f, 32.25f } };\n+\n+  struct B res_dbl;\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  cls_struct_type1.size = 0;\n+  cls_struct_type1.alignment = 0;\n+  cls_struct_type1.type = FFI_TYPE_STRUCT;\n+  cls_struct_type1.elements = cls_struct_fields1;\n+\n+  cls_struct_fields[0] = &ffi_type_float;\n+  cls_struct_fields[1] = &ffi_type_float;\n+  cls_struct_fields[2] = NULL;\n+\n+  cls_struct_fields1[0] = &ffi_type_float;\n+  cls_struct_fields1[1] = &cls_struct_type;\n+  cls_struct_fields1[2] = NULL;\n+\n+\n+  dbl_arg_types[0] = &ffi_type_float;\n+  dbl_arg_types[1] = &cls_struct_type1;\n+  dbl_arg_types[2] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &e_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"12.125 24.75 31.625 32.25: 36.875 43.75 44.375\" } */\n+  CHECK( res_dbl.x == (e_dbl + f_dbl.x));\n+  CHECK( res_dbl.y.a == (e_dbl + f_dbl.y.a));\n+  CHECK( res_dbl.y.b == (e_dbl + f_dbl.y.b));\n+\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, B_gn, NULL, code) == FFI_OK);\n+\n+  res_dbl = ((B(*)(float, B))(code))(e_dbl, f_dbl);\n+  /* { dg-output \"\\n12.125 24.75 31.625 32.25: 36.875 43.75 44.375\" } */\n+  CHECK( res_dbl.x == (e_dbl + f_dbl.x));\n+  CHECK( res_dbl.y.a == (e_dbl + f_dbl.y.a));\n+  CHECK( res_dbl.y.b == (e_dbl + f_dbl.y.b));\n+\n+  exit(0);\n+}"}]}