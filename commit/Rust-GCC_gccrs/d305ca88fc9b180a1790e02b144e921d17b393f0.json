{"sha": "d305ca88fc9b180a1790e02b144e921d17b393f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMwNWNhODhmYzliMTgwYTE3OTBlMDJiMTQ0ZTkyMWQxN2IzOTNmMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:18:37Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:18:37Z"}, "message": "[59/77] Add a rtx_jump_table_data::get_data_mode helper\n\nThis patch adds a helper function to get the mode of the addresses\nor offsets in a jump table.  It also changes the final.c code to use\nrtx_jump_table_data over rtx or rtx_insn in cases where it needed\nto use the new helper.  This in turn meant adding a safe_dyn_cast\nequivalent of safe_as_a, to cope with null NEXT_INSNs.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* is-a.h (safe_dyn_cast): New function.\n\t* rtl.h (rtx_jump_table_data::get_data_mode): New function.\n\t(jump_table_for_label): Likewise.\n\t* final.c (final_addr_vec_align): Take an rtx_jump_table_data *\n\tinstead of an rtx_insn *.\n\t(shorten_branches): Use dyn_cast instead of LABEL_P and\n\tJUMP_TABLE_DATA_P.  Use jump_table_for_label and\n\trtx_jump_table_data::get_data_mode.\n\t(final_scan_insn): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251511", "tree": {"sha": "a2c9e2b70bbf121f659d36303df886bad0895c81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2c9e2b70bbf121f659d36303df886bad0895c81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d305ca88fc9b180a1790e02b144e921d17b393f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d305ca88fc9b180a1790e02b144e921d17b393f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d305ca88fc9b180a1790e02b144e921d17b393f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d305ca88fc9b180a1790e02b144e921d17b393f0/comments", "author": null, "committer": null, "parents": [{"sha": "2123a9a50fb35109af6c2ba3bcfd71a1d5432954", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2123a9a50fb35109af6c2ba3bcfd71a1d5432954", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2123a9a50fb35109af6c2ba3bcfd71a1d5432954"}], "stats": {"total": 131, "additions": 86, "deletions": 45}, "files": [{"sha": "612bd6922bd7a5732d964b3fb315de4f84b36dc7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d305ca88fc9b180a1790e02b144e921d17b393f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d305ca88fc9b180a1790e02b144e921d17b393f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d305ca88fc9b180a1790e02b144e921d17b393f0", "patch": "@@ -1,3 +1,17 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* is-a.h (safe_dyn_cast): New function.\n+\t* rtl.h (rtx_jump_table_data::get_data_mode): New function.\n+\t(jump_table_for_label): Likewise.\n+\t* final.c (final_addr_vec_align): Take an rtx_jump_table_data *\n+\tinstead of an rtx_insn *.\n+\t(shorten_branches): Use dyn_cast instead of LABEL_P and\n+\tJUMP_TABLE_DATA_P.  Use jump_table_for_label and\n+\trtx_jump_table_data::get_data_mode.\n+\t(final_scan_insn): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "8af1f17886b3b342f62c3026d833141fc12625fd", "filename": "gcc/final.c", "status": "modified", "additions": 39, "deletions": 45, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d305ca88fc9b180a1790e02b144e921d17b393f0/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d305ca88fc9b180a1790e02b144e921d17b393f0/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=d305ca88fc9b180a1790e02b144e921d17b393f0", "patch": "@@ -219,9 +219,6 @@ static void leaf_renumber_regs (rtx_insn *);\n #if HAVE_cc0\n static int alter_cond (rtx);\n #endif\n-#ifndef ADDR_VEC_ALIGN\n-static int final_addr_vec_align (rtx_insn *);\n-#endif\n static int align_fuzz (rtx, rtx, int, unsigned);\n static void collect_fn_hard_reg_usage (void);\n static tree get_call_fndecl (rtx_insn *);\n@@ -518,9 +515,9 @@ default_jump_align_max_skip (rtx_insn *insn ATTRIBUTE_UNUSED)\n \n #ifndef ADDR_VEC_ALIGN\n static int\n-final_addr_vec_align (rtx_insn *addr_vec)\n+final_addr_vec_align (rtx_jump_table_data *addr_vec)\n {\n-  int align = GET_MODE_SIZE (GET_MODE (PATTERN (addr_vec)));\n+  int align = GET_MODE_SIZE (addr_vec->get_data_mode ());\n \n   if (align > BIGGEST_ALIGNMENT / BITS_PER_UNIT)\n     align = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n@@ -937,45 +934,41 @@ shorten_branches (rtx_insn *first)\n       if (INSN_P (insn))\n \tcontinue;\n \n-      if (LABEL_P (insn))\n+      if (rtx_code_label *label = dyn_cast <rtx_code_label *> (insn))\n \t{\n-\t  rtx_insn *next;\n-\t  bool next_is_jumptable;\n-\n \t  /* Merge in alignments computed by compute_alignments.  */\n-\t  log = LABEL_TO_ALIGNMENT (insn);\n+\t  log = LABEL_TO_ALIGNMENT (label);\n \t  if (max_log < log)\n \t    {\n \t      max_log = log;\n-\t      max_skip = LABEL_TO_MAX_SKIP (insn);\n+\t      max_skip = LABEL_TO_MAX_SKIP (label);\n \t    }\n \n-\t  next = next_nonnote_insn (insn);\n-\t  next_is_jumptable = next && JUMP_TABLE_DATA_P (next);\n-\t  if (!next_is_jumptable)\n+\t  rtx_jump_table_data *table = jump_table_for_label (label);\n+\t  if (!table)\n \t    {\n-\t      log = LABEL_ALIGN (insn);\n+\t      log = LABEL_ALIGN (label);\n \t      if (max_log < log)\n \t\t{\n \t\t  max_log = log;\n-\t\t  max_skip = targetm.asm_out.label_align_max_skip (insn);\n+\t\t  max_skip = targetm.asm_out.label_align_max_skip (label);\n \t\t}\n \t    }\n \t  /* ADDR_VECs only take room if read-only data goes into the text\n \t     section.  */\n \t  if ((JUMP_TABLES_IN_TEXT_SECTION\n \t       || readonly_data_section == text_section)\n-\t      && next_is_jumptable)\n+\t      && table)\n \t    {\n-\t      log = ADDR_VEC_ALIGN (next);\n+\t      log = ADDR_VEC_ALIGN (table);\n \t      if (max_log < log)\n \t\t{\n \t\t  max_log = log;\n-\t\t  max_skip = targetm.asm_out.label_align_max_skip (insn);\n+\t\t  max_skip = targetm.asm_out.label_align_max_skip (label);\n \t\t}\n \t    }\n-\t  LABEL_TO_ALIGNMENT (insn) = max_log;\n-\t  LABEL_TO_MAX_SKIP (insn) = max_skip;\n+\t  LABEL_TO_ALIGNMENT (label) = max_log;\n+\t  LABEL_TO_MAX_SKIP (label) = max_skip;\n \t  max_log = 0;\n \t  max_skip = 0;\n \t}\n@@ -1131,15 +1124,15 @@ shorten_branches (rtx_insn *first)\n \tcontinue;\n \n       body = PATTERN (insn);\n-      if (JUMP_TABLE_DATA_P (insn))\n+      if (rtx_jump_table_data *table = dyn_cast <rtx_jump_table_data *> (insn))\n \t{\n \t  /* This only takes room if read-only data goes into the text\n \t     section.  */\n \t  if (JUMP_TABLES_IN_TEXT_SECTION\n \t      || readonly_data_section == text_section)\n \t    insn_lengths[uid] = (XVECLEN (body,\n \t\t\t\t\t  GET_CODE (body) == ADDR_DIFF_VEC)\n-\t\t\t\t * GET_MODE_SIZE (GET_MODE (body)));\n+\t\t\t\t * GET_MODE_SIZE (table->get_data_mode ()));\n \t  /* Alignment is handled by ADDR_VEC_ALIGN.  */\n \t}\n       else if (GET_CODE (body) == ASM_INPUT || asm_noperands (body) >= 0)\n@@ -1219,28 +1212,27 @@ shorten_branches (rtx_insn *first)\n \n \t  uid = INSN_UID (insn);\n \n-\t  if (LABEL_P (insn))\n+\t  if (rtx_code_label *label = dyn_cast <rtx_code_label *> (insn))\n \t    {\n-\t      int log = LABEL_TO_ALIGNMENT (insn);\n+\t      int log = LABEL_TO_ALIGNMENT (label);\n \n #ifdef CASE_VECTOR_SHORTEN_MODE\n \t      /* If the mode of a following jump table was changed, we\n \t\t may need to update the alignment of this label.  */\n-\t      rtx_insn *next;\n-\t      bool next_is_jumptable;\n-\n-\t      next = next_nonnote_insn (insn);\n-\t      next_is_jumptable = next && JUMP_TABLE_DATA_P (next);\n-\t      if ((JUMP_TABLES_IN_TEXT_SECTION\n-\t\t   || readonly_data_section == text_section)\n-\t\t  && next_is_jumptable)\n+\n+\t      if (JUMP_TABLES_IN_TEXT_SECTION\n+\t\t  || readonly_data_section == text_section)\n \t\t{\n-\t\t  int newlog = ADDR_VEC_ALIGN (next);\n-\t\t  if (newlog != log)\n+\t\t  rtx_jump_table_data *table = jump_table_for_label (label);\n+\t\t  if (table)\n \t\t    {\n-\t\t      log = newlog;\n-\t\t      LABEL_TO_ALIGNMENT (insn) = log;\n-\t\t      something_changed = 1;\n+\t\t      int newlog = ADDR_VEC_ALIGN (table);\n+\t\t      if (newlog != log)\n+\t\t\t{\n+\t\t\t  log = newlog;\n+\t\t\t  LABEL_TO_ALIGNMENT (insn) = log;\n+\t\t\t  something_changed = 1;\n+\t\t\t}\n \t\t    }\n \t\t}\n #endif\n@@ -1271,6 +1263,7 @@ shorten_branches (rtx_insn *first)\n \t      && JUMP_TABLE_DATA_P (insn)\n \t      && GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n \t    {\n+\t      rtx_jump_table_data *table = as_a <rtx_jump_table_data *> (insn);\n \t      rtx body = PATTERN (insn);\n \t      int old_length = insn_lengths[uid];\n \t      rtx_insn *rel_lab =\n@@ -1366,13 +1359,14 @@ shorten_branches (rtx_insn *first)\n \t\t\t\t\t\t   max_addr - rel_addr, body);\n \t      if (!increasing\n \t\t  || (GET_MODE_SIZE (vec_mode)\n-\t\t      >= GET_MODE_SIZE (GET_MODE (body))))\n+\t\t      >= GET_MODE_SIZE (table->get_data_mode ())))\n \t\tPUT_MODE (body, vec_mode);\n \t      if (JUMP_TABLES_IN_TEXT_SECTION\n \t\t  || readonly_data_section == text_section)\n \t\t{\n \t\t  insn_lengths[uid]\n-\t\t    = (XVECLEN (body, 1) * GET_MODE_SIZE (GET_MODE (body)));\n+\t\t    = (XVECLEN (body, 1)\n+\t\t       * GET_MODE_SIZE (table->get_data_mode ()));\n \t\t  insn_current_address += insn_lengths[uid];\n \t\t  if (insn_lengths[uid] != old_length)\n \t\t    something_changed = 1;\n@@ -2191,6 +2185,7 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n   rtx set;\n #endif\n   rtx_insn *next;\n+  rtx_jump_table_data *table;\n \n   insn_counter++;\n \n@@ -2448,11 +2443,11 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \n       app_disable ();\n \n-      next = next_nonnote_insn (insn);\n       /* If this label is followed by a jump-table, make sure we put\n \t the label in the read-only section.  Also possibly write the\n \t label and jump table together.  */\n-      if (next != 0 && JUMP_TABLE_DATA_P (next))\n+      table = jump_table_for_label (as_a <rtx_code_label *> (insn));\n+      if (table)\n \t{\n #if defined(ASM_OUTPUT_ADDR_VEC) || defined(ASM_OUTPUT_ADDR_DIFF_VEC)\n \t  /* In this case, the case vector is being moved by the\n@@ -2467,7 +2462,7 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t\t\t\t (current_function_decl));\n \n #ifdef ADDR_VEC_ALIGN\n-\t      log_align = ADDR_VEC_ALIGN (next);\n+\t      log_align = ADDR_VEC_ALIGN (table);\n #else\n \t      log_align = exact_log2 (BIGGEST_ALIGNMENT / BITS_PER_UNIT);\n #endif\n@@ -2477,8 +2472,7 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t    switch_to_section (current_function_section ());\n \n #ifdef ASM_OUTPUT_CASE_LABEL\n-\t  ASM_OUTPUT_CASE_LABEL (file, \"L\", CODE_LABEL_NUMBER (insn),\n-\t\t\t\t next);\n+\t  ASM_OUTPUT_CASE_LABEL (file, \"L\", CODE_LABEL_NUMBER (insn), table);\n #else\n \t  targetm.asm_out.internal_label (file, \"L\", CODE_LABEL_NUMBER (insn));\n #endif"}, {"sha": "2adc7409acbb2d6d8e2665da2989386184568adf", "filename": "gcc/is-a.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d305ca88fc9b180a1790e02b144e921d17b393f0/gcc%2Fis-a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d305ca88fc9b180a1790e02b144e921d17b393f0/gcc%2Fis-a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fis-a.h?ref=d305ca88fc9b180a1790e02b144e921d17b393f0", "patch": "@@ -103,6 +103,11 @@ TYPE dyn_cast <TYPE> (pointer)\n     Note that we have converted two sets of assertions in the calls to varpool\n     into safe and efficient use of a variable.\n \n+TYPE safe_dyn_cast <TYPE> (pointer)\n+\n+    Like dyn_cast <TYPE> (pointer), except that it accepts null pointers\n+    and returns null results for them.\n+\n \n If you use these functions and get a 'inline function not defined' or a\n 'missing symbol' error message for 'is_a_helper<....>::test', it means that\n@@ -222,4 +227,13 @@ dyn_cast (U *p)\n     return static_cast <T> (0);\n }\n \n+/* Similar to dyn_cast, except that the pointer may be null.  */\n+\n+template <typename T, typename U>\n+inline T\n+safe_dyn_cast (U *p)\n+{\n+  return p ? dyn_cast <T> (p) : 0;\n+}\n+\n #endif  /* GCC_IS_A_H  */"}, {"sha": "736134f5c5229280c4b449ec806e9f97c8bd9364", "filename": "gcc/rtl.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d305ca88fc9b180a1790e02b144e921d17b393f0/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d305ca88fc9b180a1790e02b144e921d17b393f0/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d305ca88fc9b180a1790e02b144e921d17b393f0", "patch": "@@ -634,6 +634,7 @@ class GTY(()) rtx_jump_table_data : public rtx_insn\n      This method gets the underlying vec.  */\n \n   inline rtvec get_labels () const;\n+  inline scalar_int_mode get_data_mode () const;\n };\n \n class GTY(()) rtx_barrier : public rtx_insn\n@@ -1477,6 +1478,24 @@ inline rtvec rtx_jump_table_data::get_labels () const\n     return XVEC (pat, 1); /* presumably an ADDR_DIFF_VEC */\n }\n \n+/* Return the mode of the data in the table, which is always a scalar\n+   integer.  */\n+\n+inline scalar_int_mode\n+rtx_jump_table_data::get_data_mode () const\n+{\n+  return as_a <scalar_int_mode> (GET_MODE (PATTERN (this)));\n+}\n+\n+/* If LABEL is followed by a jump table, return the table, otherwise\n+   return null.  */\n+\n+inline rtx_jump_table_data *\n+jump_table_for_label (const rtx_code_label *label)\n+{\n+  return safe_dyn_cast <rtx_jump_table_data *> (NEXT_INSN (label));\n+}\n+\n #define RTX_FRAME_RELATED_P(RTX)\t\t\t\t\t\\\n   (RTL_FLAG_CHECK6 (\"RTX_FRAME_RELATED_P\", (RTX), DEBUG_INSN, INSN,\t\\\n \t\t    CALL_INSN, JUMP_INSN, BARRIER, SET)->frame_related)"}]}