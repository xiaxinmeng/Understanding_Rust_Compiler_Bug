{"sha": "e04d2a35c884f075ebe12cd6f871e35f6d0362a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA0ZDJhMzVjODg0ZjA3NWViZTEyY2Q2Zjg3MWUzNWY2ZDAzNjJhNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-06-01T09:00:57Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-06-01T09:00:57Z"}, "message": "genmatch.c (comparison_code_p): New predicate.\n\n2016-06-01  Richard Biener  <rguenther@suse.de>\n\n\t* genmatch.c (comparison_code_p): New predicate.\n\t(swap_tree_comparison): New function.\n\t(commutate): Add for_vec parameter to append new for entries.\n\tSupport commutating relational operators by swapping it alongside\n\toperands.\n\t(lower_commutative): Adjust.\n\t(dt_simplify::gen): Do not pass artificial operators to gen\n\tfunctions.\n\t(decision_tree::gen): Do not add artificial operators as parameters.\n\t(parser::parse_expr): Verify operator commutativity when :c is\n\tapplied.  Allow :C to override this.\n\t* match.pd: Adjust patterns to use :C instead of :c where required.\n\nFrom-SVN: r236977", "tree": {"sha": "638943efbfc2fd09c79e79434b1bfd8ad43999e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/638943efbfc2fd09c79e79434b1bfd8ad43999e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e04d2a35c884f075ebe12cd6f871e35f6d0362a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e04d2a35c884f075ebe12cd6f871e35f6d0362a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e04d2a35c884f075ebe12cd6f871e35f6d0362a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e04d2a35c884f075ebe12cd6f871e35f6d0362a4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e4b631a5a80b0fe254b3e9a747df697780748c12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4b631a5a80b0fe254b3e9a747df697780748c12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4b631a5a80b0fe254b3e9a747df697780748c12"}], "stats": {"total": 172, "additions": 164, "deletions": 8}, "files": [{"sha": "d9142b9857b044c1afbecdff05ce2c27788bd0b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04d2a35c884f075ebe12cd6f871e35f6d0362a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04d2a35c884f075ebe12cd6f871e35f6d0362a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e04d2a35c884f075ebe12cd6f871e35f6d0362a4", "patch": "@@ -1,3 +1,18 @@\n+2016-06-01  Richard Biener  <rguenther@suse.de>\n+\n+\t* genmatch.c (comparison_code_p): New predicate.\n+\t(swap_tree_comparison): New function.\n+\t(commutate): Add for_vec parameter to append new for entries.\n+\tSupport commutating relational operators by swapping it alongside\n+\toperands.\n+\t(lower_commutative): Adjust.\n+\t(dt_simplify::gen): Do not pass artificial operators to gen\n+\tfunctions.\n+\t(decision_tree::gen): Do not add artificial operators as parameters.\n+\t(parser::parse_expr): Verify operator commutativity when :c is\n+\tapplied.  Allow :C to override this.\n+\t* match.pd: Adjust patterns to use :C instead of :c where required.\n+\n 2016-06-01  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \tPR tree-optimization/71077"}, {"sha": "9bb1279dc0021d45a837e3877997fe50efa8b673", "filename": "gcc/genmatch.c", "status": "modified", "additions": 147, "deletions": 6, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04d2a35c884f075ebe12cd6f871e35f6d0362a4/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04d2a35c884f075ebe12cd6f871e35f6d0362a4/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=e04d2a35c884f075ebe12cd6f871e35f6d0362a4", "patch": "@@ -291,6 +291,35 @@ commutative_ternary_tree_code (enum tree_code code)\n   return false;\n }\n \n+/* Return true if CODE is a comparison.  */\n+\n+bool\n+comparison_code_p (enum tree_code code)\n+{\n+  switch (code)\n+    {\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case ORDERED_EXPR:\n+    case UNORDERED_EXPR:\n+    case LTGT_EXPR:\n+    case UNEQ_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+      return true;\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n \n /* Base class for all identifiers the parser knows.  */\n \n@@ -528,6 +557,42 @@ get_operator (const char *id, bool allow_null = false)\n   return operators->find_with_hash (&tem, tem.hashval);\n }\n \n+/* Return the comparison operators that results if the operands are\n+   swapped.  This is safe for floating-point.  */\n+\n+id_base *\n+swap_tree_comparison (operator_id *p)\n+{\n+  switch (p->code)\n+    {\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case ORDERED_EXPR:\n+    case UNORDERED_EXPR:\n+    case LTGT_EXPR:\n+    case UNEQ_EXPR:\n+      return p;\n+    case GT_EXPR:\n+      return get_operator (\"LT_EXPR\");\n+    case GE_EXPR:\n+      return get_operator (\"LE_EXPR\");\n+    case LT_EXPR:\n+      return get_operator (\"GT_EXPR\");\n+    case LE_EXPR:\n+      return get_operator (\"GE_EXPR\");\n+    case UNGT_EXPR:\n+      return get_operator (\"UNLT_EXPR\");\n+    case UNGE_EXPR:\n+      return get_operator (\"UNLE_EXPR\");\n+    case UNLT_EXPR:\n+      return get_operator (\"UNGT_EXPR\");\n+    case UNLE_EXPR:\n+      return get_operator (\"UNGE_EXPR\");\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n typedef hash_map<nofree_string_hash, unsigned> cid_map_t;\n \n \n@@ -816,7 +881,7 @@ cartesian_product (const vec< vec<operand *> >& ops_vector,\n /* Lower OP to two operands in case it is marked as commutative.  */\n \n static vec<operand *>\n-commutate (operand *op)\n+commutate (operand *op, vec<vec<user_id *> > &for_vec)\n {\n   vec<operand *> ret = vNULL;\n \n@@ -827,7 +892,7 @@ commutate (operand *op)\n \t  ret.safe_push (op);\n \t  return ret;\n \t}\n-      vec<operand *> v = commutate (c->what);\n+      vec<operand *> v = commutate (c->what, for_vec);\n       for (unsigned i = 0; i < v.length (); ++i)\n \t{\n \t  capture *nc = new capture (c->location, c->where, v[i]);\n@@ -845,7 +910,7 @@ commutate (operand *op)\n \n   vec< vec<operand *> > ops_vector = vNULL;\n   for (unsigned i = 0; i < e->ops.length (); ++i)\n-    ops_vector.safe_push (commutate (e->ops[i]));\n+    ops_vector.safe_push (commutate (e->ops[i], for_vec));\n \n   auto_vec< vec<operand *> > result;\n   auto_vec<operand *> v (e->ops.length ());\n@@ -868,6 +933,50 @@ commutate (operand *op)\n   for (unsigned i = 0; i < result.length (); ++i)\n     {\n       expr *ne = new expr (e);\n+      if (operator_id *p = dyn_cast <operator_id *> (ne->operation))\n+\t{\n+\t  if (comparison_code_p (p->code))\n+\t    ne->operation = swap_tree_comparison (p);\n+\t}\n+      else if (user_id *p = dyn_cast <user_id *> (ne->operation))\n+\t{\n+\t  bool found_compare = false;\n+\t  for (unsigned j = 0; j < p->substitutes.length (); ++j)\n+\t    if (operator_id *q = dyn_cast <operator_id *> (p->substitutes[j]))\n+\t      {\n+\t\tif (comparison_code_p (q->code)\n+\t\t    && swap_tree_comparison (q) != q)\n+\t\t  {\n+\t\t    found_compare = true;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  if (found_compare)\n+\t    {\n+\t      user_id *newop = new user_id (\"<internal>\");\n+\t      for (unsigned j = 0; j < p->substitutes.length (); ++j)\n+\t\t{\n+\t\t  id_base *subst = p->substitutes[j];\n+\t\t  if (operator_id *q = dyn_cast <operator_id *> (subst))\n+\t\t    {\n+\t\t      if (comparison_code_p (q->code))\n+\t\t\tsubst = swap_tree_comparison (q);\n+\t\t    }\n+\t\t  newop->substitutes.safe_push (subst);\n+\t\t}\n+\t      ne->operation = newop;\n+\t      /* Search for 'p' inside the for vector and push 'newop'\n+\t         to the same level.  */\n+\t      for (unsigned j = 0; newop && j < for_vec.length (); ++j)\n+\t\tfor (unsigned k = 0; k < for_vec[j].length (); ++k)\n+\t\t  if (for_vec[j][k] == p)\n+\t\t    {\n+\t\t      for_vec[j].safe_push (newop);\n+\t\t      newop = NULL;\n+\t\t      break;\n+\t\t    }\n+\t    }\n+\t}\n       ne->is_commutative = false;\n       // result[i].length () is 2 since e->operation is binary\n       for (unsigned j = result[i].length (); j; --j)\n@@ -884,7 +993,7 @@ commutate (operand *op)\n static void\n lower_commutative (simplify *s, vec<simplify *>& simplifiers)\n {\n-  vec<operand *> matchers = commutate (s->match);\n+  vec<operand *> matchers = commutate (s->match, s->for_vec);\n   for (unsigned i = 0; i < matchers.length (); ++i)\n     {\n       simplify *ns = new simplify (s->kind, matchers[i], s->result,\n@@ -3248,7 +3357,8 @@ dt_simplify::gen (FILE *f, int indent, bool gimple)\n \t  fprintf_indent (f, indent, \"if (%s (res_code, res_ops, seq, \"\n \t\t\t  \"valueize, type, captures\", info->fname);\n \t  for (unsigned i = 0; i < s->for_subst_vec.length (); ++i)\n-\t    fprintf (f, \", %s\", s->for_subst_vec[i].second->id);\n+\t    if (s->for_subst_vec[i].first->used)\n+\t      fprintf (f, \", %s\", s->for_subst_vec[i].second->id);\n \t  fprintf (f, \"))\\n\");\n \t  fprintf_indent (f, indent, \"  return true;\\n\");\n \t}\n@@ -3260,7 +3370,10 @@ dt_simplify::gen (FILE *f, int indent, bool gimple)\n \t    fprintf (f, \", op%d\", i);\n \t  fprintf (f, \", captures\");\n \t  for (unsigned i = 0; i < s->for_subst_vec.length (); ++i)\n-\t    fprintf (f, \", %s\", s->for_subst_vec[i].second->id);\n+\t    {\n+\t      if (s->for_subst_vec[i].first->used)\n+\t\tfprintf (f, \", %s\", s->for_subst_vec[i].second->id);\n+\t    }\n \t  fprintf (f, \");\\n\");\n \t  fprintf_indent (f, indent, \"if (res) return res;\\n\");\n \t}\n@@ -3269,6 +3382,8 @@ dt_simplify::gen (FILE *f, int indent, bool gimple)\n     {\n       for (unsigned i = 0; i < s->for_subst_vec.length (); ++i)\n \t{\n+\t  if (! s->for_subst_vec[i].first->used)\n+\t    continue;\n \t  if (is_a <operator_id *> (s->for_subst_vec[i].second))\n \t    fprintf_indent (f, indent, \"enum tree_code %s = %s;\\n\",\n \t\t\t    s->for_subst_vec[i].first->id,\n@@ -3425,6 +3540,8 @@ decision_tree::gen (FILE *f, bool gimple)\n \t}\n       for (unsigned i = 0; i < s->s->s->for_subst_vec.length (); ++i)\n \t{\n+\t  if (! s->s->s->for_subst_vec[i].first->used)\n+\t    continue;\n \t  if (is_a <operator_id *> (s->s->s->for_subst_vec[i].second))\n \t    fprintf (f, \", enum tree_code ARG_UNUSED (%s)\",\n \t\t     s->s->s->for_subst_vec[i].first->id);\n@@ -3885,6 +4002,30 @@ parser::parse_expr ()\n \t      while (*sp)\n \t\t{\n \t\t  if (*sp == 'c')\n+\t\t    {\n+\t\t      if (operator_id *p\n+\t\t\t    = dyn_cast<operator_id *> (e->operation))\n+\t\t\t{\n+\t\t\t  if (!commutative_tree_code (p->code)\n+\t\t\t      && !comparison_code_p (p->code))\n+\t\t\t    fatal_at (token, \"operation is not commutative\");\n+\t\t\t}\n+\t\t      else if (user_id *p = dyn_cast<user_id *> (e->operation))\n+\t\t\tfor (unsigned i = 0;\n+\t\t\t     i < p->substitutes.length (); ++i)\n+\t\t\t  {\n+\t\t\t    if (operator_id *q\n+\t\t\t\t  = dyn_cast<operator_id *> (p->substitutes[i]))\n+\t\t\t      {\n+\t\t\t\tif (!commutative_tree_code (q->code)\n+\t\t\t\t    && !comparison_code_p (q->code))\n+\t\t\t\t  fatal_at (token, \"operation %s is not \"\n+\t\t\t\t\t    \"commutative\", q->id);\n+\t\t\t      }\n+\t\t\t  }\n+\t\t      is_commutative = true;\n+\t\t    }\n+\t\t  else if (*sp == 'C')\n \t\t    is_commutative = true;\n \t\t  else if (*sp == 's')\n \t\t    {"}, {"sha": "24e716e656559915566439c3d5ae3dee32fec376", "filename": "gcc/match.pd", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e04d2a35c884f075ebe12cd6f871e35f6d0362a4/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e04d2a35c884f075ebe12cd6f871e35f6d0362a4/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=e04d2a35c884f075ebe12cd6f871e35f6d0362a4", "patch": "@@ -189,7 +189,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n /* Optimize -A / A to -1.0 if we don't care about\n    NaNs or Infinities.  */\n (simplify\n- (rdiv:c @0 (negate @0))\n+ (rdiv:C @0 (negate @0))\n  (if (FLOAT_TYPE_P (type)\n       && ! HONOR_NANS (type)\n       && ! HONOR_INFINITIES (type))\n@@ -2830,7 +2830,7 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n \n /* cabs(x+0i) or cabs(0+xi) -> abs(x).  */\n (simplify\n- (CABS (complex:c @0 real_zerop@1))\n+ (CABS (complex:C @0 real_zerop@1))\n  (abs @0))\n \n /* trunc(trunc(x)) -> trunc(x), etc.  */"}]}