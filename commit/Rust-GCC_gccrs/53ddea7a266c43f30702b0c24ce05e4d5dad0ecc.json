{"sha": "53ddea7a266c43f30702b0c24ce05e4d5dad0ecc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNkZGVhN2EyNjZjNDNmMzA3MDJiMGMyNGNlMDVlNGQ1ZGFkMGVjYw==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-09T09:42:16Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-09T09:42:16Z"}, "message": "Fixed formatting to fit gcc style", "tree": {"sha": "df37183b3b068ea00f0e88e80d4bbb8f621fbbf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df37183b3b068ea00f0e88e80d4bbb8f621fbbf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b343d117f5cf7976d3c4c93d9595e2471d780acd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b343d117f5cf7976d3c4c93d9595e2471d780acd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b343d117f5cf7976d3c4c93d9595e2471d780acd"}], "stats": {"total": 8162, "additions": 4622, "deletions": 3540}, "files": [{"sha": "030b0b3707e41ddb9225423dd81d3ce22a91f64e", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 139, "deletions": 126, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=53ddea7a266c43f30702b0c24ce05e4d5dad0ecc", "patch": "@@ -171,21 +171,23 @@ Attribute::as_string () const\n {\n   std::string path_str = path.as_string ();\n   if (attr_input == nullptr)\n-      return path_str;\n+    return path_str;\n   else\n-      return path_str + attr_input->as_string ();\n+    return path_str + attr_input->as_string ();\n }\n \n // Copy constructor must deep copy attr_input as unique pointer\n-Attribute::Attribute (Attribute const &other) : path (other.path), locus (other.locus)\n+Attribute::Attribute (Attribute const &other)\n+  : path (other.path), locus (other.locus)\n {\n   // guard to protect from null pointer dereference\n   if (other.attr_input != nullptr)\n     attr_input = other.attr_input->clone_attr_input ();\n }\n \n // overload assignment operator to use custom clone method\n-Attribute &Attribute::operator= (Attribute const &other)\n+Attribute &\n+Attribute::operator= (Attribute const &other)\n {\n   path = other.path;\n   locus = other.locus;\n@@ -330,7 +332,7 @@ VisItem::as_string () const\n   if (!outer_attrs.empty ())\n     {\n       for (const auto &attr : outer_attrs)\n-\t  str += attr.as_string () + \"\\n\";\n+\tstr += attr.as_string () + \"\\n\";\n     }\n \n   if (has_visibility ())\n@@ -678,20 +680,20 @@ Method::as_string () const\n   else\n     {\n       for (const auto &param : function_params)\n-\t  str += \"\\n  \" + param.as_string ();\n+\tstr += \"\\n  \" + param.as_string ();\n     }\n \n   str += \"\\n Return type: \";\n   if (has_return_type ())\n-      str += return_type->as_string ();\n+    str += return_type->as_string ();\n   else\n-      str += \"none (void)\";\n+    str += \"none (void)\";\n \n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-      str += where_clause.as_string ();\n+    str += where_clause.as_string ();\n   else\n-      str += \"none\";\n+    str += \"none\";\n \n   str += \"\\n Block expr (body): \\n  \";\n   str += function_body->as_string ();\n@@ -1168,7 +1170,7 @@ Function::as_string () const\n     }\n \n   if (has_where_clause ())\n-      str += \" where \" + where_clause.as_string ();\n+    str += \" where \" + where_clause.as_string ();\n \n   str += \"\\n\";\n \n@@ -1199,7 +1201,7 @@ WhereClause::as_string () const\n   else\n     {\n       for (const auto &item : where_clause_items)\n-\t  str += \"\\n  \" + item->as_string ();\n+\tstr += \"\\n  \" + item->as_string ();\n     }\n \n   return str;\n@@ -1224,7 +1226,7 @@ BlockExpr::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t  str += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n+\tstr += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n     }\n \n   // statements\n@@ -1254,9 +1256,9 @@ BlockExpr::as_string () const\n   // final expression\n   str += \"\\n\" + indent_spaces (stay) + \"final expression: \";\n   if (expr == nullptr)\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += \"\\n\" + expr->as_string ();\n+    str += \"\\n\" + expr->as_string ();\n \n   str += \"\\n\" + indent_spaces (out) + \"}\";\n   return str;\n@@ -1268,7 +1270,7 @@ TraitImpl::as_string () const\n   std::string str = VisItem::as_string ();\n \n   if (has_unsafe)\n-      str += \"unsafe \";\n+    str += \"unsafe \";\n \n   str += \"impl \";\n \n@@ -1281,24 +1283,24 @@ TraitImpl::as_string () const\n   else\n     {\n       for (const auto &param : generic_params)\n-\t  str += \"\\n  \" + param->as_string ();\n+\tstr += \"\\n  \" + param->as_string ();\n     }\n \n   str += \"\\n Has exclam: \";\n   if (has_exclam)\n-      str += \"true\";\n+    str += \"true\";\n   else\n-      str += \"false\";\n+    str += \"false\";\n \n   str += \"\\n TypePath (to trait): \" + trait_path.as_string ();\n \n   str += \"\\n Type (struct to impl on): \" + trait_type->as_string ();\n \n   str += \"\\n Where clause: \";\n   if (!has_where_clause ())\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += where_clause.as_string ();\n+    str += where_clause.as_string ();\n \n   // inner attributes\n   str += \"\\n inner attributes: \";\n@@ -1311,7 +1313,7 @@ TraitImpl::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n+\tstr += \"\\n  \" + attr.as_string ();\n     }\n \n   str += \"\\n trait impl items: \";\n@@ -1322,7 +1324,7 @@ TraitImpl::as_string () const\n   else\n     {\n       for (const auto &item : impl_items)\n-\t  str += \"\\n  \" + item->as_string ();\n+\tstr += \"\\n  \" + item->as_string ();\n     }\n \n   return str;\n@@ -1378,7 +1380,7 @@ MacroInvocationSemi::as_string () const\n   if (!outer_attrs.empty ())\n     {\n       for (const auto &attr : outer_attrs)\n-\t  str += attr.as_string () + \"\\n\";\n+\tstr += attr.as_string () + \"\\n\";\n     }\n \n   str += \"\\n\" + path.as_string () + \"!\";\n@@ -1438,7 +1440,7 @@ ExternBlock::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n+\tstr += \"\\n  \" + attr.as_string ();\n     }\n \n   str += \"\\n external items: \";\n@@ -1449,7 +1451,7 @@ ExternBlock::as_string () const\n   else\n     {\n       for (const auto &item : extern_items)\n-\t  str += \"\\n  \" + item->as_string ();\n+\tstr += \"\\n  \" + item->as_string ();\n     }\n \n   return str;\n@@ -1478,7 +1480,7 @@ MacroRulesDefinition::as_string () const\n   if (!outer_attrs.empty ())\n     {\n       for (const auto &attr : outer_attrs)\n-\t  str += attr.as_string () + \"\\n\";\n+\tstr += attr.as_string () + \"\\n\";\n     }\n \n   str += \"macro_rules!\";\n@@ -1493,7 +1495,7 @@ MacroRulesDefinition::as_string () const\n   else\n     {\n       for (const auto &rule : rules)\n-\t  str += \"\\n  \" + rule.as_string ();\n+\tstr += \"\\n  \" + rule.as_string ();\n     }\n \n   str += \"\\n Delim type: \";\n@@ -1528,7 +1530,7 @@ PathInExpression::as_string () const\n   std::string str;\n \n   if (has_opening_scope_resolution)\n-      str = \"::\";\n+    str = \"::\";\n \n   return str + PathPattern::as_string ();\n }\n@@ -1559,7 +1561,7 @@ ClosureParam::as_string () const\n   std::string str (pattern->as_string ());\n \n   if (has_type_given ())\n-      str += \" : \" + type->as_string ();\n+    str += \" : \" + type->as_string ();\n \n   return str;\n }\n@@ -1569,9 +1571,9 @@ ClosureExpr::as_string () const\n {\n   std::string str (\"ClosureExpr:\\n Has move: \");\n   if (has_move)\n-      str += \"true\";\n+    str += \"true\";\n   else\n-      str += \"false\";\n+    str += \"false\";\n \n   str += \"\\n Params: \";\n   if (params.empty ())\n@@ -1581,7 +1583,7 @@ ClosureExpr::as_string () const\n   else\n     {\n       for (const auto &param : params)\n-\t  str += \"\\n  \" + param.as_string ();\n+\tstr += \"\\n  \" + param.as_string ();\n     }\n \n   return str;\n@@ -1605,7 +1607,7 @@ PathPattern::as_string () const\n   std::string str;\n \n   for (const auto &segment : segments)\n-      str += segment.as_string () + \"::\";\n+    str += segment.as_string () + \"::\";\n \n   // basically a hack - remove last two characters of string (remove final ::)\n   str.erase (str.length () - 2);\n@@ -1620,7 +1622,7 @@ QualifiedPathType::as_string () const\n   str += type_to_invoke_on->as_string ();\n \n   if (has_as_clause ())\n-      str += \" as \" + trait_path.as_string ();\n+    str += \" as \" + trait_path.as_string ();\n \n   return str + \">\";\n }\n@@ -1637,10 +1639,10 @@ BorrowExpr::as_string () const\n   std::string str (\"&\");\n \n   if (double_borrow)\n-      str += \"&\";\n+    str += \"&\";\n \n   if (is_mut)\n-      str += \"mut \";\n+    str += \"mut \";\n \n   str += main_or_left_expr->as_string ();\n \n@@ -1653,7 +1655,7 @@ ReturnExpr::as_string () const\n   std::string str (\"return \");\n \n   if (has_returned_expr ())\n-      str += return_expr->as_string ();\n+    str += return_expr->as_string ();\n \n   return str;\n }\n@@ -1674,7 +1676,7 @@ GroupedExpr::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n+\tstr += \"\\n  \" + attr.as_string ();\n     }\n \n   str += \"\\n Expr in parens: \" + expr_in_parens->as_string ();\n@@ -1694,7 +1696,7 @@ ContinueExpr::as_string () const\n   std::string str (\"continue \");\n \n   if (has_label ())\n-      str += label.as_string ();\n+    str += label.as_string ();\n \n   return str;\n }\n@@ -1829,7 +1831,7 @@ MethodCallExpr::as_string () const\n       for (const auto &param : params)\n \t{\n \t  if (param == nullptr)\n-\t      return \"ERROR_MARK_STRING - method call expr param is null\";\n+\t    return \"ERROR_MARK_STRING - method call expr param is null\";\n \n \t  str += \"\\n  \" + param->as_string ();\n \t}\n@@ -1968,7 +1970,7 @@ IfLetExpr::as_string () const\n   else\n     {\n       for (const auto &pattern : match_arm_patterns)\n-\t  str += \"\\n  \" + pattern->as_string ();\n+\tstr += \"\\n  \" + pattern->as_string ();\n     }\n \n   str += \"\\n Scrutinee expr: \" + value->as_string ();\n@@ -2157,7 +2159,7 @@ CallExpr::as_string () const\n       for (const auto &param : params)\n \t{\n \t  if (param == nullptr)\n-\t      return \"ERROR_MARK_STRING - call expr param is null\";\n+\t    return \"ERROR_MARK_STRING - call expr param is null\";\n \n \t  str += \"\\n  \" + param->as_string ();\n \t}\n@@ -2173,9 +2175,9 @@ WhileLoopExpr::as_string () const\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += loop_label.as_string ();\n+    str += loop_label.as_string ();\n \n   str += \"\\n Conditional expr: \" + condition->as_string ();\n \n@@ -2191,9 +2193,9 @@ WhileLetLoopExpr::as_string () const\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += loop_label.as_string ();\n+    str += loop_label.as_string ();\n \n   str += \"\\n Match arm patterns: \";\n   if (match_arm_patterns.empty ())\n@@ -2203,7 +2205,7 @@ WhileLetLoopExpr::as_string () const\n   else\n     {\n       for (const auto &pattern : match_arm_patterns)\n-\t  str += \"\\n  \" + pattern->as_string ();\n+\tstr += \"\\n  \" + pattern->as_string ();\n     }\n \n   str += \"\\n Scrutinee expr: \" + scrutinee->as_string ();\n@@ -2220,9 +2222,9 @@ LoopExpr::as_string () const\n \n   str += \"\\n Label: \";\n   if (!has_loop_label ())\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += loop_label.as_string ();\n+    str += loop_label.as_string ();\n \n   str += \"\\n Loop block: \" + loop_block->as_string ();\n \n@@ -2245,14 +2247,14 @@ ArrayExpr::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n+\tstr += \"\\n  \" + attr.as_string ();\n     }\n \n   str += \"\\n Array elems: \";\n   if (!has_array_elems ())\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += internal_elements->as_string ();\n+    str += internal_elements->as_string ();\n \n   return str;\n }\n@@ -2269,10 +2271,10 @@ BreakExpr::as_string () const\n   std::string str (\"break \");\n \n   if (has_label ())\n-      str += label.as_string () + \" \";\n+    str += label.as_string () + \" \";\n \n   if (has_break_expr ())\n-      str += break_expr->as_string ();\n+    str += break_expr->as_string ();\n \n   return str;\n }\n@@ -2297,7 +2299,7 @@ MatchArm::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t  str += \"\\n \" + attr.as_string ();\n+\tstr += \"\\n \" + attr.as_string ();\n     }\n \n   str += \"\\nPatterns: \";\n@@ -2308,14 +2310,14 @@ MatchArm::as_string () const\n   else\n     {\n       for (const auto &pattern : match_arm_patterns)\n-\t  str += \"\\n \" + pattern->as_string ();\n+\tstr += \"\\n \" + pattern->as_string ();\n     }\n \n   str += \"\\nGuard expr: \";\n   if (!has_match_arm_guard ())\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += guard_expr->as_string ();\n+    str += guard_expr->as_string ();\n \n   return str;\n }\n@@ -3629,7 +3631,7 @@ StructExprTuple::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t  str += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n+\tstr += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n     }\n   indent_spaces (out);\n   indent_spaces (out);\n@@ -3655,7 +3657,7 @@ StructExprStruct::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n+\tstr += \"\\n  \" + attr.as_string ();\n     }\n \n   return str;\n@@ -3665,9 +3667,9 @@ std::string\n StructBase::as_string () const\n {\n   if (base_struct != nullptr)\n-      return base_struct->as_string ();\n+    return base_struct->as_string ();\n   else\n-      return \"ERROR_MARK_STRING - invalid struct base had as string applied\";\n+    return \"ERROR_MARK_STRING - invalid struct base had as string applied\";\n }\n \n std::string\n@@ -3702,14 +3704,14 @@ StructExprStructFields::as_string () const\n   else\n     {\n       for (const auto &field : fields)\n-\t  str += \"\\n  \" + field->as_string ();\n+\tstr += \"\\n  \" + field->as_string ();\n     }\n \n   str += \"\\n Struct base: \";\n   if (!has_struct_base ())\n-      str += \"none\";\n+    str += \"none\";\n   else\n-      str += struct_base.as_string ();\n+    str += struct_base.as_string ();\n \n   return str;\n }\n@@ -3729,7 +3731,7 @@ EnumExprStruct::as_string () const\n   else\n     {\n       for (const auto &field : fields)\n-\t  str += \"\\n  \" + field->as_string ();\n+\tstr += \"\\n  \" + field->as_string ();\n     }\n \n   return str;\n@@ -3768,7 +3770,7 @@ EnumItem::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n+\tstr += \"\\n  \" + attr.as_string ();\n     }\n \n   str += \"\\n\" + variant_name;\n@@ -3940,7 +3942,7 @@ ExternalStaticItem::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n+\tstr += \"\\n  \" + attr.as_string ();\n     }\n \n   // start visibility on new line and with a space\n@@ -3949,7 +3951,7 @@ ExternalStaticItem::as_string () const\n   str += \"static \";\n \n   if (has_mut)\n-      str += \"mut \";\n+    str += \"mut \";\n \n   // add name\n   str += item_name;\n@@ -3974,7 +3976,7 @@ ExternalFunctionItem::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t  str += \"\\n  \" + attr.as_string ();\n+\tstr += \"\\n  \" + attr.as_string ();\n     }\n \n   // start visibility on new line and with a space\n@@ -4018,21 +4020,20 @@ ExternalFunctionItem::as_string () const\n   else\n     {\n       for (const auto &param : function_params)\n-\t  str += \"\\n  \" + param.as_string ();\n-      \n+\tstr += \"\\n  \" + param.as_string ();\n+\n       if (has_variadics)\n \t{\n-    str += \"\\n  variadic outer attrs: \";\n-    if (has_variadic_outer_attrs ()) \n-      {\n-        \n-        for (const auto &attr : variadic_outer_attrs)\n-\t  str += \"\\n   \" + attr.as_string ();\n-      }\n-    else\n-      {\n-        str += \"none\";\n-      }\n+\t  str += \"\\n  variadic outer attrs: \";\n+\t  if (has_variadic_outer_attrs ())\n+\t    {\n+\t      for (const auto &attr : variadic_outer_attrs)\n+\t\tstr += \"\\n   \" + attr.as_string ();\n+\t    }\n+\t  else\n+\t    {\n+\t      str += \"none\";\n+\t    }\n \t  str += \"\\n  ... (variadic)\";\n \t}\n     }\n@@ -4043,9 +4044,9 @@ ExternalFunctionItem::as_string () const\n   // where clause\n   str += \"\\n Where clause: \";\n   if (has_where_clause ())\n-      str += where_clause.as_string ();\n+    str += where_clause.as_string ();\n   else\n-      str += \"none\";\n+    str += \"none\";\n \n   return str;\n }\n@@ -4055,14 +4056,14 @@ NamedFunctionParam::as_string () const\n {\n   std::string str = \"outer attributes: \";\n \n-  if (!has_outer_attrs ()) \n+  if (!has_outer_attrs ())\n     {\n       str += \"none\";\n-    } \n-  else \n+    }\n+  else\n     {\n-      for (const auto& attr : outer_attrs)\n-        str += \"\\n \" + attr.as_string ();\n+      for (const auto &attr : outer_attrs)\n+\tstr += \"\\n \" + attr.as_string ();\n     }\n \n   str += \"\\n\" + name;\n@@ -4735,7 +4736,8 @@ MacroParser::parse_meta_item_inner ()\n   std::vector<MetaNameValueStr> meta_name_value_str_items;\n   for (const auto &item : meta_items)\n     {\n-      std::unique_ptr<MetaNameValueStr> converted_item = item->to_meta_name_value_str ();\n+      std::unique_ptr<MetaNameValueStr> converted_item\n+\t= item->to_meta_name_value_str ();\n       if (converted_item == nullptr)\n \t{\n \t  meta_name_value_str_items.clear ();\n@@ -5053,7 +5055,9 @@ MacroParser::parse_meta_item_lit ()\n bool\n AttrInputMetaItemContainer::check_cfg_predicate (const Session &session) const\n {\n-  /* NOTE: assuming that only first item must be true - cfg should only have one item, and cfg_attr only has first item as predicate. TODO ensure that this is correct. */\n+  /* NOTE: assuming that only first item must be true - cfg should only have one\n+   * item, and cfg_attr only has first item as predicate. TODO ensure that this\n+   * is correct. */\n   if (items.empty ())\n     return false;\n \n@@ -5352,52 +5356,61 @@ MetaItemPathLit::to_attribute () const\n \t\t\t    new AttrInputLiteral (lit)));\n }\n \n-std::vector<Attribute> AttrInputMetaItemContainer::separate_cfg_attrs () const {\n-    rust_assert (!items.empty ());\n+std::vector<Attribute>\n+AttrInputMetaItemContainer::separate_cfg_attrs () const\n+{\n+  rust_assert (!items.empty ());\n \n-    if (items.size () == 1)\n-      return {};\n+  if (items.size () == 1)\n+    return {};\n \n-    std::vector<Attribute> attrs;\n-    attrs.reserve (items.size () - 1);\n+  std::vector<Attribute> attrs;\n+  attrs.reserve (items.size () - 1);\n \n-    for (auto it = items.begin () + 1; it != items.end (); ++it) {\n+  for (auto it = items.begin () + 1; it != items.end (); ++it)\n+    {\n       Attribute attr = (*it)->to_attribute ();\n-      if (attr.is_empty ()) {\n-        // TODO should this be an error that causes us to chuck out everything?\n-        continue;\n-      }\n+      if (attr.is_empty ())\n+\t{\n+\t  // TODO should this be an error that causes us to chuck out\n+\t  // everything?\n+\t  continue;\n+\t}\n       attrs.push_back (std::move (attr));\n     }\n \n-    attrs.shrink_to_fit ();\n-    return attrs;\n-  }\n+  attrs.shrink_to_fit ();\n+  return attrs;\n+}\n \n-bool Attribute::check_cfg_predicate (const Session &session)\n-  {\n-    /* assume that cfg predicate actually can exist, i.e. attribute has cfg or\n-     * cfg_attr path */\n-    if (!has_attr_input () || (path.as_string () != \"cfg\" && path.as_string () != \"cfg_attr\"))\n-      return false;\n+bool\n+Attribute::check_cfg_predicate (const Session &session)\n+{\n+  /* assume that cfg predicate actually can exist, i.e. attribute has cfg or\n+   * cfg_attr path */\n+  if (!has_attr_input ()\n+      || (path.as_string () != \"cfg\" && path.as_string () != \"cfg_attr\"))\n+    return false;\n \n-    // TODO: maybe replace with storing a \"has been parsed\" variable?\n-    parse_attr_to_meta_item ();\n-    // can't be const because of this anyway\n+  // TODO: maybe replace with storing a \"has been parsed\" variable?\n+  parse_attr_to_meta_item ();\n+  // can't be const because of this anyway\n \n-    return attr_input->check_cfg_predicate (session);\n-  }\n+  return attr_input->check_cfg_predicate (session);\n+}\n \n-std::vector<Attribute> Attribute::separate_cfg_attrs () {\n-    if (!has_attr_input () || path.as_string () != \"cfg_attr\")\n-      return {};\n+std::vector<Attribute>\n+Attribute::separate_cfg_attrs ()\n+{\n+  if (!has_attr_input () || path.as_string () != \"cfg_attr\")\n+    return {};\n \n-    // TODO: maybe replace with storing a \"has been parsed\" variable?\n-    parse_attr_to_meta_item ();\n-    // can't be const because of this anyway\n+  // TODO: maybe replace with storing a \"has been parsed\" variable?\n+  parse_attr_to_meta_item ();\n+  // can't be const because of this anyway\n \n-    return attr_input->separate_cfg_attrs ();\n-  }\n+  return attr_input->separate_cfg_attrs ();\n+}\n \n /* Visitor implementations - these are short but inlining can't happen anyway\n  * due to virtual functions and I didn't want to make the ast header includes"}, {"sha": "d23cb81a00cdd878654fdd4988b679f9a81b28fb", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=53ddea7a266c43f30702b0c24ce05e4d5dad0ecc", "patch": "@@ -83,7 +83,7 @@ class TokenTree\n \n   /* Converts token tree to a flat token stream. Tokens must be pointer to avoid\n    * mutual dependency with Token. */\n-  virtual std::vector<std::unique_ptr<Token>> to_token_stream () const = 0;\n+  virtual std::vector<std::unique_ptr<Token> > to_token_stream () const = 0;\n \n protected:\n   // pure virtual clone implementation\n@@ -193,7 +193,7 @@ class Token : public TokenTree, public MacroMatch\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Return copy of itself but in token stream form.\n-  std::vector<std::unique_ptr<Token>> to_token_stream () const override;\n+  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n \n   TokenId get_id () const { return token_id; }\n \n@@ -526,7 +526,7 @@ class AttrInput\n class DelimTokenTree : public TokenTree, public AttrInput\n {\n   DelimType delim_type;\n-  std::vector<std::unique_ptr<TokenTree>> token_trees;\n+  std::vector<std::unique_ptr<TokenTree> > token_trees;\n   Location locus;\n \n protected:\n@@ -551,8 +551,8 @@ class DelimTokenTree : public TokenTree, public AttrInput\n \n public:\n   DelimTokenTree (DelimType delim_type,\n-\t\t  std::vector<std::unique_ptr<TokenTree>> token_trees\n-\t\t  = std::vector<std::unique_ptr<TokenTree>> (),\n+\t\t  std::vector<std::unique_ptr<TokenTree> > token_trees\n+\t\t  = std::vector<std::unique_ptr<TokenTree> > (),\n \t\t  Location locus = Location ())\n     : delim_type (delim_type), token_trees (std::move (token_trees)),\n       locus (locus)\n@@ -590,16 +590,15 @@ class DelimTokenTree : public TokenTree, public AttrInput\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  bool\n-  check_cfg_predicate (const Session&) const override\n+  bool check_cfg_predicate (const Session &) const override\n   {\n     // this should never be called - should be converted first\n     return false;\n   }\n \n   AttrInput *parse_to_meta_item () const override;\n \n-  std::vector<std::unique_ptr<Token>> to_token_stream () const override;\n+  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n \n   std::unique_ptr<DelimTokenTree> clone_delim_token_tree () const\n   {\n@@ -636,27 +635,30 @@ class MetaItemInner\n \n   /* HACK: used to simplify parsing - creates a copy of that type, or returns\n    * null */\n-  virtual std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const { return nullptr; }\n+  virtual std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const\n+  {\n+    return nullptr;\n+  }\n \n   // HACK: used to simplify parsing - same thing\n   virtual SimplePath to_path_item () const\n   {\n     return SimplePath::create_empty ();\n   }\n \n-  virtual Attribute to_attribute() const { return Attribute::create_empty (); }\n+  virtual Attribute to_attribute () const { return Attribute::create_empty (); }\n \n   virtual bool check_cfg_predicate (const Session &session) const = 0;\n };\n \n // Container used to store MetaItems as AttrInput (bridge-ish kinda thing)\n class AttrInputMetaItemContainer : public AttrInput\n {\n-  std::vector<std::unique_ptr<MetaItemInner>> items;\n+  std::vector<std::unique_ptr<MetaItemInner> > items;\n \n public:\n   AttrInputMetaItemContainer (\n-    std::vector<std::unique_ptr<MetaItemInner>> items)\n+    std::vector<std::unique_ptr<MetaItemInner> > items)\n     : items (std::move (items))\n   {}\n \n@@ -1001,10 +1003,7 @@ class Type\n \n   /* HACK: convert to trait bound. Virtual method overriden by classes that\n    * enable this. */\n-  virtual TraitBound *to_trait_bound (bool) const\n-  {\n-    return nullptr;\n-  }\n+  virtual TraitBound *to_trait_bound (bool) const { return nullptr; }\n   /* as pointer, shouldn't require definition beforehand, only forward\n    * declaration. */\n \n@@ -1220,7 +1219,7 @@ class MacroItem : public Item\n {\n   /*public:\n   std::string as_string() const;*/\n-  //std::vector<Attribute> outer_attrs;\n+  // std::vector<Attribute> outer_attrs;\n \n protected:\n   /*MacroItem (std::vector<Attribute> outer_attribs)\n@@ -1290,7 +1289,7 @@ class TraitImplItem\n   virtual TraitImplItem *clone_trait_impl_item_impl () const = 0;\n \n public:\n-  virtual ~TraitImplItem () {};\n+  virtual ~TraitImplItem (){};\n \n   // Unique pointer custom clone function\n   std::unique_ptr<TraitImplItem> clone_trait_impl_item () const\n@@ -1335,20 +1334,21 @@ class ExternalItem\n class MacroInvocationSemi : public MacroItem,\n \t\t\t    public TraitItem,\n \t\t\t    public InherentImplItem,\n-\t\t\t    public TraitImplItem, public ExternalItem\n+\t\t\t    public TraitImplItem,\n+\t\t\t    public ExternalItem\n {\n   std::vector<Attribute> outer_attrs;\n   SimplePath path;\n   // all delim types except curly must have invocation end with a semicolon\n   DelimType delim_type;\n-  std::vector<std::unique_ptr<TokenTree>> token_trees;\n+  std::vector<std::unique_ptr<TokenTree> > token_trees;\n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n   MacroInvocationSemi (SimplePath macro_path, DelimType delim_type,\n-\t\t       std::vector<std::unique_ptr<TokenTree>> token_trees,\n+\t\t       std::vector<std::unique_ptr<TokenTree> > token_trees,\n \t\t       std::vector<Attribute> outer_attribs, Location locus)\n     : outer_attrs (std::move (outer_attribs)), path (std::move (macro_path)),\n       delim_type (delim_type), token_trees (std::move (token_trees)),\n@@ -1358,8 +1358,8 @@ class MacroInvocationSemi : public MacroItem,\n   // Copy constructor with vector clone\n   MacroInvocationSemi (MacroInvocationSemi const &other)\n     : MacroItem (other), TraitItem (other), InherentImplItem (other),\n-      TraitImplItem (other), outer_attrs(other.outer_attrs), path (other.path), delim_type (other.delim_type),\n-      locus (other.locus)\n+      TraitImplItem (other), outer_attrs (other.outer_attrs), path (other.path),\n+      delim_type (other.delim_type), locus (other.locus)\n   {\n     token_trees.reserve (other.token_trees.size ());\n     for (const auto &e : other.token_trees)\n@@ -1458,11 +1458,11 @@ struct Crate\n   // dodgy spacing required here\n   /* TODO: is it better to have a vector of items here or a module (implicit\n    * top-level one)? */\n-  std::vector<std::unique_ptr<Item>> items;\n+  std::vector<std::unique_ptr<Item> > items;\n \n public:\n   // Constructor\n-  Crate (std::vector<std::unique_ptr<Item>> items,\n+  Crate (std::vector<std::unique_ptr<Item> > items,\n \t std::vector<Attribute> inner_attrs, bool has_utf8bom = false,\n \t bool has_shebang = false)\n     : has_utf8bom (has_utf8bom), has_shebang (has_shebang),\n@@ -1503,13 +1503,14 @@ struct Crate\n   std::string as_string () const;\n \n   // Delete all crate information, e.g. if fails cfg.\n-  void strip_crate () {\n+  void strip_crate ()\n+  {\n     inner_attrs.clear ();\n     inner_attrs.shrink_to_fit ();\n \n     items.clear ();\n     items.shrink_to_fit ();\n-    // TODO: is this the best way to do this? \n+    // TODO: is this the best way to do this?\n   }\n };\n "}, {"sha": "f129e8c3310fc75b9500744594f520bd6e3e6e94", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 334, "deletions": 158, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=53ddea7a266c43f30702b0c24ce05e4d5dad0ecc", "patch": "@@ -119,8 +119,7 @@ class AttrInputLiteral : public AttrInput\n \n   /* this can never be a cfg predicate - cfg and cfg_attr require a token-tree\n    * cfg */\n-  bool\n-  check_cfg_predicate (const Session&) const override { return false; }\n+  bool check_cfg_predicate (const Session &) const override { return false; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -241,7 +240,10 @@ class OperatorExpr : public ExprWithoutBlock\n \n   // Invalid if expr is null, so base stripping on that.\n   void mark_for_strip () override { main_or_left_expr = nullptr; }\n-  bool is_marked_for_strip () const override { return main_or_left_expr == nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return main_or_left_expr == nullptr;\n+  }\n };\n \n /* Unary prefix & or &mut (or && and &&mut) borrow operator. Cannot be\n@@ -257,14 +259,16 @@ class BorrowExpr : public OperatorExpr\n   BorrowExpr (std::unique_ptr<Expr> borrow_lvalue, bool is_mut_borrow,\n \t      bool is_double_borrow, std::vector<Attribute> outer_attribs,\n \t      Location locus)\n-    : OperatorExpr (std::move (borrow_lvalue), std::move (outer_attribs), \n-      locus), is_mut (is_mut_borrow), double_borrow (is_double_borrow)\n+    : OperatorExpr (std::move (borrow_lvalue), std::move (outer_attribs),\n+\t\t    locus),\n+      is_mut (is_mut_borrow), double_borrow (is_double_borrow)\n   {}\n \n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_borrowed_expr () {\n+  std::unique_ptr<Expr> &get_borrowed_expr ()\n+  {\n     rust_assert (main_or_left_expr != nullptr);\n     return main_or_left_expr;\n   }\n@@ -293,7 +297,8 @@ class DereferenceExpr : public OperatorExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_dereferenced_expr () {\n+  std::unique_ptr<Expr> &get_dereferenced_expr ()\n+  {\n     rust_assert (main_or_left_expr != nullptr);\n     return main_or_left_expr;\n   }\n@@ -323,7 +328,8 @@ class ErrorPropagationExpr : public OperatorExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_propagating_expr () {\n+  std::unique_ptr<Expr> &get_propagating_expr ()\n+  {\n     rust_assert (main_or_left_expr != nullptr);\n     return main_or_left_expr;\n   }\n@@ -369,7 +375,8 @@ class NegationExpr : public OperatorExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_negated_expr () {\n+  std::unique_ptr<Expr> &get_negated_expr ()\n+  {\n     rust_assert (main_or_left_expr != nullptr);\n     return main_or_left_expr;\n   }\n@@ -446,13 +453,15 @@ class ArithmeticOrLogicalExpr : public OperatorExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_left_expr () {\n+  std::unique_ptr<Expr> &get_left_expr ()\n+  {\n     rust_assert (main_or_left_expr != nullptr);\n     return main_or_left_expr;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_right_expr () {\n+  std::unique_ptr<Expr> &get_right_expr ()\n+  {\n     rust_assert (right_expr != nullptr);\n     return right_expr;\n   }\n@@ -528,13 +537,15 @@ class ComparisonExpr : public OperatorExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_left_expr () {\n+  std::unique_ptr<Expr> &get_left_expr ()\n+  {\n     rust_assert (main_or_left_expr != nullptr);\n     return main_or_left_expr;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_right_expr () {\n+  std::unique_ptr<Expr> &get_right_expr ()\n+  {\n     rust_assert (right_expr != nullptr);\n     return right_expr;\n   }\n@@ -604,13 +615,15 @@ class LazyBooleanExpr : public OperatorExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_left_expr () {\n+  std::unique_ptr<Expr> &get_left_expr ()\n+  {\n     rust_assert (main_or_left_expr != nullptr);\n     return main_or_left_expr;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_right_expr () {\n+  std::unique_ptr<Expr> &get_right_expr ()\n+  {\n     rust_assert (right_expr != nullptr);\n     return right_expr;\n   }\n@@ -657,20 +670,22 @@ class TypeCastExpr : public OperatorExpr\n     return *this;\n   }\n \n-  // move constructors \n+  // move constructors\n   TypeCastExpr (TypeCastExpr &&other) = default;\n   TypeCastExpr &operator= (TypeCastExpr &&other) = default;\n \n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_casted_expr () {\n+  std::unique_ptr<Expr> &get_casted_expr ()\n+  {\n     rust_assert (main_or_left_expr != nullptr);\n     return main_or_left_expr;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<TypeNoBounds> &get_type_to_cast_to () {\n+  std::unique_ptr<TypeNoBounds> &get_type_to_cast_to ()\n+  {\n     rust_assert (type_to_convert_to != nullptr);\n     return type_to_convert_to;\n   }\n@@ -727,13 +742,15 @@ class AssignmentExpr : public OperatorExpr\n   void visit_rhs (ASTVisitor &vis) { right_expr->accept_vis (vis); }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_left_expr () {\n+  std::unique_ptr<Expr> &get_left_expr ()\n+  {\n     rust_assert (main_or_left_expr != nullptr);\n     return main_or_left_expr;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_right_expr () {\n+  std::unique_ptr<Expr> &get_right_expr ()\n+  {\n     rust_assert (right_expr != nullptr);\n     return right_expr;\n   }\n@@ -811,13 +828,15 @@ class CompoundAssignmentExpr : public OperatorExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_left_expr () {\n+  std::unique_ptr<Expr> &get_left_expr ()\n+  {\n     rust_assert (main_or_left_expr != nullptr);\n     return main_or_left_expr;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_right_expr () {\n+  std::unique_ptr<Expr> &get_right_expr ()\n+  {\n     rust_assert (right_expr != nullptr);\n     return right_expr;\n   }\n@@ -891,10 +910,14 @@ class GroupedExpr : public ExprWithoutBlock\n \n   // Invalid if inner expr is null, so base stripping on that.\n   void mark_for_strip () override { expr_in_parens = nullptr; }\n-  bool is_marked_for_strip () const override { return expr_in_parens == nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return expr_in_parens == nullptr;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_expr_in_parens () {\n+  std::unique_ptr<Expr> &get_expr_in_parens ()\n+  {\n     rust_assert (expr_in_parens != nullptr);\n     return expr_in_parens;\n   }\n@@ -969,7 +992,10 @@ class ArrayElemsValues : public ArrayElems\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n-  const std::vector<std::unique_ptr<Expr> > &get_values () const { return values; }\n+  const std::vector<std::unique_ptr<Expr> > &get_values () const\n+  {\n+    return values;\n+  }\n   std::vector<std::unique_ptr<Expr> > &get_values () { return values; }\n \n   size_t get_num_values () const { return values.size (); }\n@@ -1030,13 +1056,15 @@ class ArrayElemsCopied : public ArrayElems\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_elem_to_copy () {\n+  std::unique_ptr<Expr> &get_elem_to_copy ()\n+  {\n     rust_assert (elem_to_copy != nullptr);\n     return elem_to_copy;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_num_copies () {\n+  std::unique_ptr<Expr> &get_num_copies ()\n+  {\n     rust_assert (num_copies != nullptr);\n     return num_copies;\n   }\n@@ -1055,7 +1083,7 @@ class ArrayExpr : public ExprWithoutBlock\n   std::unique_ptr<ArrayElems> internal_elements;\n \n   Location locus;\n-  \n+\n   // TODO: find another way to store this to save memory?\n   bool marked_for_strip = false;\n \n@@ -1121,7 +1149,8 @@ class ArrayExpr : public ExprWithoutBlock\n   bool is_marked_for_strip () const override { return marked_for_strip; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<ArrayElems> &get_array_elems () {\n+  std::unique_ptr<ArrayElems> &get_array_elems ()\n+  {\n     rust_assert (internal_elements != nullptr);\n     return internal_elements;\n   }\n@@ -1182,7 +1211,7 @@ class ArrayIndexExpr : public ExprWithoutBlock\n     // guard to prevent null dereference (only required if error state)\n     if (other.array_expr != nullptr)\n       array_expr = other.array_expr->clone_expr ();\n-    else \n+    else\n       array_expr = nullptr;\n     if (other.index_expr != nullptr)\n       index_expr = other.index_expr->clone_expr ();\n@@ -1202,17 +1231,26 @@ class ArrayIndexExpr : public ExprWithoutBlock\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Invalid if either expr is null, so base stripping on that.\n-  void mark_for_strip () override { array_expr = nullptr; index_expr = nullptr; }\n-  bool is_marked_for_strip () const override { return array_expr == nullptr && index_expr == nullptr; }\n+  void mark_for_strip () override\n+  {\n+    array_expr = nullptr;\n+    index_expr = nullptr;\n+  }\n+  bool is_marked_for_strip () const override\n+  {\n+    return array_expr == nullptr && index_expr == nullptr;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_array_expr () {\n+  std::unique_ptr<Expr> &get_array_expr ()\n+  {\n     rust_assert (array_expr != nullptr);\n     return array_expr;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_index_expr () {\n+  std::unique_ptr<Expr> &get_index_expr ()\n+  {\n     rust_assert (index_expr != nullptr);\n     return index_expr;\n   }\n@@ -1295,8 +1333,14 @@ class TupleExpr : public ExprWithoutBlock\n   bool is_marked_for_strip () const override { return marked_for_strip; }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n-  const std::vector<std::unique_ptr<Expr> > &get_tuple_elems () const { return tuple_elems; }\n-  std::vector<std::unique_ptr<Expr> > &get_tuple_elems () { return tuple_elems; }\n+  const std::vector<std::unique_ptr<Expr> > &get_tuple_elems () const\n+  {\n+    return tuple_elems;\n+  }\n+  std::vector<std::unique_ptr<Expr> > &get_tuple_elems ()\n+  {\n+    return tuple_elems;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -1332,7 +1376,8 @@ class TupleIndexExpr : public ExprWithoutBlock\n \n   // Copy constructor requires a clone for tuple_expr\n   TupleIndexExpr (TupleIndexExpr const &other)\n-    : ExprWithoutBlock (other), tuple_index (other.tuple_index), locus (other.locus)\n+    : ExprWithoutBlock (other), tuple_index (other.tuple_index),\n+      locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.tuple_expr != nullptr)\n@@ -1370,7 +1415,8 @@ class TupleIndexExpr : public ExprWithoutBlock\n   bool is_marked_for_strip () const override { return tuple_expr == nullptr; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_tuple_expr () {\n+  std::unique_ptr<Expr> &get_tuple_expr ()\n+  {\n     rust_assert (tuple_expr != nullptr);\n     return tuple_expr;\n   }\n@@ -1404,7 +1450,10 @@ class StructExpr : public ExprWithoutBlock\n   std::string as_string () const override;\n \n   // Invalid if path is empty, so base stripping on that.\n-  void mark_for_strip () override { struct_name = PathInExpression::create_error (); }\n+  void mark_for_strip () override\n+  {\n+    struct_name = PathInExpression::create_error ();\n+  }\n   bool is_marked_for_strip () const override { return struct_name.is_error (); }\n };\n \n@@ -1493,7 +1542,8 @@ struct StructBase\n   std::string as_string () const;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_base_struct () {\n+  std::unique_ptr<Expr> &get_base_struct ()\n+  {\n     rust_assert (base_struct != nullptr);\n     return base_struct;\n   }\n@@ -1577,7 +1627,8 @@ class StructExprFieldWithVal : public StructExprField\n   std::string as_string () const override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_value () {\n+  std::unique_ptr<Expr> &get_value ()\n+  {\n     rust_assert (value != nullptr);\n     return value;\n   }\n@@ -1693,8 +1744,14 @@ class StructExprStructFields : public StructExprStruct\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n-  std::vector<std::unique_ptr<StructExprField> > &get_fields () { return fields; }\n-  const std::vector<std::unique_ptr<StructExprField> > &get_fields () const { return fields; }\n+  std::vector<std::unique_ptr<StructExprField> > &get_fields ()\n+  {\n+    return fields;\n+  }\n+  const std::vector<std::unique_ptr<StructExprField> > &get_fields () const\n+  {\n+    return fields;\n+  }\n \n   StructBase &get_struct_base () { return struct_base; }\n   const StructBase &get_struct_base () const { return struct_base; }\n@@ -1709,7 +1766,7 @@ class StructExprStructFields : public StructExprStruct\n };\n \n // AST node of the functional update struct creator\n-/* TODO: remove and replace with StructExprStructFields, except with empty \n+/* TODO: remove and replace with StructExprStructFields, except with empty\n  * vector of fields? */\n class StructExprStructBase : public StructExprStruct\n {\n@@ -1795,7 +1852,10 @@ class StructExprTuple : public StructExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  const std::vector<std::unique_ptr<Expr> > &get_elems () const { return exprs; }\n+  const std::vector<std::unique_ptr<Expr> > &get_elems () const\n+  {\n+    return exprs;\n+  }\n   std::vector<std::unique_ptr<Expr> > &get_elems () { return exprs; }\n \n protected:\n@@ -1853,12 +1913,21 @@ class EnumVariantExpr : public ExprWithoutBlock\n   {}\n \n public:\n-  const PathInExpression& get_enum_variant_path () const { return enum_variant_path; }\n-  PathInExpression& get_enum_variant_path () { return enum_variant_path; }\n+  const PathInExpression &get_enum_variant_path () const\n+  {\n+    return enum_variant_path;\n+  }\n+  PathInExpression &get_enum_variant_path () { return enum_variant_path; }\n \n   // Invalid if path is in error state, so base stripping on that.\n-  void mark_for_strip () override { enum_variant_path = PathInExpression::create_error (); }\n-  bool is_marked_for_strip () const override { return enum_variant_path.is_error (); }\n+  void mark_for_strip () override\n+  {\n+    enum_variant_path = PathInExpression::create_error ();\n+  }\n+  bool is_marked_for_strip () const override\n+  {\n+    return enum_variant_path.is_error ();\n+  }\n };\n \n /* Base AST node for a single enum expression field (in enum instance creation)\n@@ -1942,7 +2011,8 @@ class EnumExprFieldWithVal : public EnumExprField\n   std::string as_string () const override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_value () {\n+  std::unique_ptr<Expr> &get_value ()\n+  {\n     rust_assert (value != nullptr);\n     return value;\n   }\n@@ -2054,7 +2124,10 @@ class EnumExprStruct : public EnumVariantExpr\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<std::unique_ptr<EnumExprField> > &get_fields () { return fields; }\n-  const std::vector<std::unique_ptr<EnumExprField> > &get_fields () const { return fields; }\n+  const std::vector<std::unique_ptr<EnumExprField> > &get_fields () const\n+  {\n+    return fields;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -2114,7 +2187,10 @@ class EnumExprTuple : public EnumVariantExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  const std::vector<std::unique_ptr<Expr> > &get_elems () const { return values; }\n+  const std::vector<std::unique_ptr<Expr> > &get_elems () const\n+  {\n+    return values;\n+  }\n   std::vector<std::unique_ptr<Expr> > &get_elems () { return values; }\n \n protected:\n@@ -2186,7 +2262,8 @@ class CallExpr : public ExprWithoutBlock\n \n   // copy constructor requires clone\n   CallExpr (CallExpr const &other)\n-    : ExprWithoutBlock (other), locus (other.locus) {\n+    : ExprWithoutBlock (other), locus (other.locus)\n+  {\n     // guard to prevent null dereference (only required if error state)\n     if (other.function != nullptr)\n       function = other.function->clone_expr ();\n@@ -2233,11 +2310,15 @@ class CallExpr : public ExprWithoutBlock\n   bool is_marked_for_strip () const override { return function == nullptr; }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n-  const std::vector<std::unique_ptr<Expr> > &get_params () const { return params; }\n+  const std::vector<std::unique_ptr<Expr> > &get_params () const\n+  {\n+    return params;\n+  }\n   std::vector<std::unique_ptr<Expr> > &get_params () { return params; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_function_expr () {\n+  std::unique_ptr<Expr> &get_function_expr ()\n+  {\n     rust_assert (function != nullptr);\n     return function;\n   }\n@@ -2276,7 +2357,9 @@ class MethodCallExpr : public ExprWithoutBlock\n \n   // copy constructor required due to cloning\n   MethodCallExpr (MethodCallExpr const &other)\n-    : ExprWithoutBlock (other), method_name (other.method_name), locus (other.locus) {\n+    : ExprWithoutBlock (other), method_name (other.method_name),\n+      locus (other.locus)\n+  {\n     // guard to prevent null dereference (only required if error state)\n     if (other.receiver != nullptr)\n       receiver = other.receiver->clone_expr ();\n@@ -2321,11 +2404,15 @@ class MethodCallExpr : public ExprWithoutBlock\n   bool is_marked_for_strip () const override { return receiver == nullptr; }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n-  const std::vector<std::unique_ptr<Expr> > &get_params () const { return params; }\n+  const std::vector<std::unique_ptr<Expr> > &get_params () const\n+  {\n+    return params;\n+  }\n   std::vector<std::unique_ptr<Expr> > &get_params () { return params; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_receiver_expr () {\n+  std::unique_ptr<Expr> &get_receiver_expr ()\n+  {\n     rust_assert (receiver != nullptr);\n     return receiver;\n   }\n@@ -2402,7 +2489,8 @@ class FieldAccessExpr : public ExprWithoutBlock\n   bool is_marked_for_strip () const override { return receiver == nullptr; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_receiver_expr () {\n+  std::unique_ptr<Expr> &get_receiver_expr ()\n+  {\n     rust_assert (receiver != nullptr);\n     return receiver;\n   }\n@@ -2438,14 +2526,14 @@ struct ClosureParam\n \n   // Constructor for closure parameter\n   ClosureParam (std::unique_ptr<Pattern> param_pattern,\n-\t\tstd::unique_ptr<Type> param_type = nullptr, std::vector<Attribute> outer_attrs = {})\n-    : outer_attrs (std::move(outer_attrs)), pattern (std::move (param_pattern)), \n-      type (std::move (param_type))\n+\t\tstd::unique_ptr<Type> param_type = nullptr,\n+\t\tstd::vector<Attribute> outer_attrs = {})\n+    : outer_attrs (std::move (outer_attrs)),\n+      pattern (std::move (param_pattern)), type (std::move (param_type))\n   {}\n \n   // Copy constructor required due to cloning as a result of unique_ptrs\n-  ClosureParam (ClosureParam const &other)\n-    : outer_attrs (other.outer_attrs)\n+  ClosureParam (ClosureParam const &other) : outer_attrs (other.outer_attrs)\n   {\n     // guard to protect from null pointer dereference\n     if (other.pattern != nullptr)\n@@ -2490,13 +2578,15 @@ struct ClosureParam\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Pattern> &get_pattern () {\n+  std::unique_ptr<Pattern> &get_pattern ()\n+  {\n     rust_assert (pattern != nullptr);\n     return pattern;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_type () {\n+  std::unique_ptr<Type> &get_type ()\n+  {\n     rust_assert (has_type_given ());\n     return type;\n   }\n@@ -2550,8 +2640,7 @@ class ClosureExprInner : public ClosureExpr\n   {}\n \n   // Copy constructor must be defined to allow copying via cloning of unique_ptr\n-  ClosureExprInner (ClosureExprInner const &other)\n-    : ClosureExpr (other)\n+  ClosureExprInner (ClosureExprInner const &other) : ClosureExpr (other)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.closure_inner != nullptr)\n@@ -2583,10 +2672,14 @@ class ClosureExprInner : public ClosureExpr\n \n   // Invalid if inner expr is null, so base stripping on that.\n   void mark_for_strip () override { closure_inner = nullptr; }\n-  bool is_marked_for_strip () const override { return closure_inner == nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return closure_inner == nullptr;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_definition_expr () {\n+  std::unique_ptr<Expr> &get_definition_expr ()\n+  {\n     rust_assert (closure_inner != nullptr);\n     return closure_inner;\n   }\n@@ -2633,7 +2726,8 @@ class BlockExpr : public ExprWithBlock\n \n   // Copy constructor with clone\n   BlockExpr (BlockExpr const &other)\n-    : ExprWithBlock (other), inner_attrs (other.inner_attrs), locus (other.locus)\n+    : ExprWithBlock (other), inner_attrs (other.inner_attrs),\n+      locus (other.locus)\n   {\n     // guard to protect from null pointer dereference\n     if (other.expr != nullptr)\n@@ -2681,23 +2775,30 @@ class BlockExpr : public ExprWithBlock\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Invalid if has no statements or final expr, so base stripping on that.\n-  void mark_for_strip () override \n-  { \n-    expr = nullptr; \n-    statements.clear (); \n-    statements.shrink_to_fit (); \n+  void mark_for_strip () override\n+  {\n+    expr = nullptr;\n+    statements.clear ();\n+    statements.shrink_to_fit ();\n+  }\n+  bool is_marked_for_strip () const override\n+  {\n+    return expr == nullptr && statements.empty ();\n   }\n-  bool is_marked_for_strip () const override { return expr == nullptr && statements.empty (); }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n-  const std::vector<std::unique_ptr<Stmt> > &get_statements () const { return statements; }\n+  const std::vector<std::unique_ptr<Stmt> > &get_statements () const\n+  {\n+    return statements;\n+  }\n   std::vector<std::unique_ptr<Stmt> > &get_statements () { return statements; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<ExprWithoutBlock> &get_tail_expr () {\n+  std::unique_ptr<ExprWithoutBlock> &get_tail_expr ()\n+  {\n     rust_assert (expr != nullptr);\n     return expr;\n   }\n@@ -2783,19 +2884,21 @@ class ClosureExprInnerTyped : public ClosureExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  /* Invalid if inner expr is null, so base stripping on that. Technically, \n+  /* Invalid if inner expr is null, so base stripping on that. Technically,\n    * type should also not be null. */\n   void mark_for_strip () override { expr = nullptr; }\n   bool is_marked_for_strip () const override { return expr == nullptr; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<BlockExpr> &get_definition_block () {\n+  std::unique_ptr<BlockExpr> &get_definition_block ()\n+  {\n     rust_assert (expr != nullptr);\n     return expr;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_return_type () {\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n     rust_assert (return_type != nullptr);\n     return return_type;\n   }\n@@ -2887,7 +2990,8 @@ class BreakExpr : public ExprWithoutBlock\n \n   // Copy constructor defined to use clone for unique pointer\n   BreakExpr (BreakExpr const &other)\n-    : ExprWithoutBlock (other), label (other.label), locus (other.locus), marked_for_strip (other.marked_for_strip)\n+    : ExprWithoutBlock (other), label (other.label), locus (other.locus),\n+      marked_for_strip (other.marked_for_strip)\n   {\n     // guard to protect from null pointer dereference\n     if (other.break_expr != nullptr)\n@@ -2926,7 +3030,8 @@ class BreakExpr : public ExprWithoutBlock\n   bool is_marked_for_strip () const override { return marked_for_strip; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_break_expr () {\n+  std::unique_ptr<Expr> &get_break_expr ()\n+  {\n     rust_assert (break_expr != nullptr);\n     return break_expr;\n   }\n@@ -2973,8 +3078,7 @@ class RangeFromToExpr : public RangeExpr\n   {}\n \n   // Copy constructor with cloning\n-  RangeFromToExpr (RangeFromToExpr const &other)\n-    : RangeExpr (other)\n+  RangeFromToExpr (RangeFromToExpr const &other) : RangeExpr (other)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.from != nullptr)\n@@ -3007,18 +3111,27 @@ class RangeFromToExpr : public RangeExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  // Invalid if either expr is null, so base stripping on that. \n-  void mark_for_strip () override { from = nullptr; to = nullptr; }\n-  bool is_marked_for_strip () const override { return from == nullptr && to == nullptr; }\n+  // Invalid if either expr is null, so base stripping on that.\n+  void mark_for_strip () override\n+  {\n+    from = nullptr;\n+    to = nullptr;\n+  }\n+  bool is_marked_for_strip () const override\n+  {\n+    return from == nullptr && to == nullptr;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_from_expr () {\n+  std::unique_ptr<Expr> &get_from_expr ()\n+  {\n     rust_assert (from != nullptr);\n     return from;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_to_expr () {\n+  std::unique_ptr<Expr> &get_to_expr ()\n+  {\n     rust_assert (to != nullptr);\n     return to;\n   }\n@@ -3046,8 +3159,7 @@ class RangeFromExpr : public RangeExpr\n   {}\n \n   // Copy constructor with clone\n-  RangeFromExpr (RangeFromExpr const &other)\n-    : RangeExpr (other)\n+  RangeFromExpr (RangeFromExpr const &other) : RangeExpr (other)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.from != nullptr)\n@@ -3058,7 +3170,7 @@ class RangeFromExpr : public RangeExpr\n   RangeFromExpr &operator= (RangeFromExpr const &other)\n   {\n     RangeExpr::operator= (other);\n-    \n+\n     // guard to prevent null dereference (only required if error state)\n     if (other.from != nullptr)\n       from = other.from->clone_expr ();\n@@ -3074,12 +3186,13 @@ class RangeFromExpr : public RangeExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  // Invalid if expr is null, so base stripping on that. \n+  // Invalid if expr is null, so base stripping on that.\n   void mark_for_strip () override { from = nullptr; }\n   bool is_marked_for_strip () const override { return from == nullptr; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_from_expr () {\n+  std::unique_ptr<Expr> &get_from_expr ()\n+  {\n     rust_assert (from != nullptr);\n     return from;\n   }\n@@ -3108,8 +3221,7 @@ class RangeToExpr : public RangeExpr\n   {}\n \n   // Copy constructor with clone\n-  RangeToExpr (RangeToExpr const &other)\n-    : RangeExpr (other)\n+  RangeToExpr (RangeToExpr const &other) : RangeExpr (other)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.to != nullptr)\n@@ -3120,7 +3232,7 @@ class RangeToExpr : public RangeExpr\n   RangeToExpr &operator= (RangeToExpr const &other)\n   {\n     RangeExpr::operator= (other);\n-    \n+\n     // guard to prevent null dereference (only required if error state)\n     if (other.to != nullptr)\n       to = other.to->clone_expr ();\n@@ -3136,12 +3248,13 @@ class RangeToExpr : public RangeExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  // Invalid if expr is null, so base stripping on that. \n+  // Invalid if expr is null, so base stripping on that.\n   void mark_for_strip () override { to = nullptr; }\n   bool is_marked_for_strip () const override { return to == nullptr; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_to_expr () {\n+  std::unique_ptr<Expr> &get_to_expr ()\n+  {\n     rust_assert (to != nullptr);\n     return to;\n   }\n@@ -3201,8 +3314,7 @@ class RangeFromToInclExpr : public RangeExpr\n   // outer attributes not allowed\n \n   // Copy constructor with clone\n-  RangeFromToInclExpr (RangeFromToInclExpr const &other)\n-    : RangeExpr (other)\n+  RangeFromToInclExpr (RangeFromToInclExpr const &other) : RangeExpr (other)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.from != nullptr)\n@@ -3215,7 +3327,7 @@ class RangeFromToInclExpr : public RangeExpr\n   RangeFromToInclExpr &operator= (RangeFromToInclExpr const &other)\n   {\n     RangeExpr::operator= (other);\n-    \n+\n     // guard to prevent null dereference (only required if error state)\n     if (other.from != nullptr)\n       from = other.from->clone_expr ();\n@@ -3235,18 +3347,27 @@ class RangeFromToInclExpr : public RangeExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  // Invalid if either expr is null, so base stripping on that. \n-  void mark_for_strip () override { from = nullptr; to = nullptr; }\n-  bool is_marked_for_strip () const override { return from == nullptr && to == nullptr; }\n+  // Invalid if either expr is null, so base stripping on that.\n+  void mark_for_strip () override\n+  {\n+    from = nullptr;\n+    to = nullptr;\n+  }\n+  bool is_marked_for_strip () const override\n+  {\n+    return from == nullptr && to == nullptr;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_from_expr () {\n+  std::unique_ptr<Expr> &get_from_expr ()\n+  {\n     rust_assert (from != nullptr);\n     return from;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_to_expr () {\n+  std::unique_ptr<Expr> &get_to_expr ()\n+  {\n     rust_assert (to != nullptr);\n     return to;\n   }\n@@ -3275,8 +3396,7 @@ class RangeToInclExpr : public RangeExpr\n   // outer attributes not allowed\n \n   // Copy constructor with clone\n-  RangeToInclExpr (RangeToInclExpr const &other)\n-    : RangeExpr (other)\n+  RangeToInclExpr (RangeToInclExpr const &other) : RangeExpr (other)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.to != nullptr)\n@@ -3287,7 +3407,7 @@ class RangeToInclExpr : public RangeExpr\n   RangeToInclExpr &operator= (RangeToInclExpr const &other)\n   {\n     RangeExpr::operator= (other);\n-    \n+\n     // guard to prevent null dereference (only required if error state)\n     if (other.to != nullptr)\n       to = other.to->clone_expr ();\n@@ -3303,12 +3423,13 @@ class RangeToInclExpr : public RangeExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  // Invalid if expr is null, so base stripping on that. \n+  // Invalid if expr is null, so base stripping on that.\n   void mark_for_strip () override { to = nullptr; }\n   bool is_marked_for_strip () const override { return to == nullptr; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_to_expr () {\n+  std::unique_ptr<Expr> &get_to_expr ()\n+  {\n     rust_assert (to != nullptr);\n     return to;\n   }\n@@ -3348,7 +3469,8 @@ class ReturnExpr : public ExprWithoutBlock\n \n   // Copy constructor with clone\n   ReturnExpr (ReturnExpr const &other)\n-    : ExprWithoutBlock (other), locus (other.locus), marked_for_strip (other.marked_for_strip)\n+    : ExprWithoutBlock (other), locus (other.locus),\n+      marked_for_strip (other.marked_for_strip)\n   {\n     // guard to protect from null pointer dereference\n     if (other.return_expr != nullptr)\n@@ -3386,7 +3508,8 @@ class ReturnExpr : public ExprWithoutBlock\n   bool is_marked_for_strip () const override { return marked_for_strip; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_returned_expr () {\n+  std::unique_ptr<Expr> &get_returned_expr ()\n+  {\n     rust_assert (return_expr != nullptr);\n     return return_expr;\n   }\n@@ -3453,12 +3576,13 @@ class UnsafeBlockExpr : public ExprWithBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  // Invalid if block is null, so base stripping on that. \n+  // Invalid if block is null, so base stripping on that.\n   void mark_for_strip () override { expr = nullptr; }\n   bool is_marked_for_strip () const override { return expr == nullptr; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<BlockExpr> &get_block_expr () {\n+  std::unique_ptr<BlockExpr> &get_block_expr ()\n+  {\n     rust_assert (expr != nullptr);\n     return expr;\n   }\n@@ -3555,12 +3679,13 @@ class BaseLoopExpr : public ExprWithBlock\n   Location get_locus () const { return locus; }\n   Location get_locus_slow () const override { return get_locus (); }\n \n-  // Invalid if loop block is null, so base stripping on that. \n+  // Invalid if loop block is null, so base stripping on that.\n   void mark_for_strip () override { loop_block = nullptr; }\n   bool is_marked_for_strip () const override { return loop_block == nullptr; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<BlockExpr> &get_loop_block () {\n+  std::unique_ptr<BlockExpr> &get_loop_block ()\n+  {\n     rust_assert (loop_block != nullptr);\n     return loop_block;\n   }\n@@ -3634,7 +3759,8 @@ class WhileLoopExpr : public BaseLoopExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_predicate_expr () {\n+  std::unique_ptr<Expr> &get_predicate_expr ()\n+  {\n     rust_assert (condition != nullptr);\n     return condition;\n   }\n@@ -3706,14 +3832,21 @@ class WhileLetLoopExpr : public BaseLoopExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_scrutinee_expr () {\n+  std::unique_ptr<Expr> &get_scrutinee_expr ()\n+  {\n     rust_assert (scrutinee != nullptr);\n     return scrutinee;\n   }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n-  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const { return match_arm_patterns; }\n-  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return match_arm_patterns; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const\n+  {\n+    return match_arm_patterns;\n+  }\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns ()\n+  {\n+    return match_arm_patterns;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -3771,13 +3904,15 @@ class ForLoopExpr : public BaseLoopExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_iterator_expr () {\n+  std::unique_ptr<Expr> &get_iterator_expr ()\n+  {\n     rust_assert (iterator_expr != nullptr);\n     return iterator_expr;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Pattern> &get_pattern () {\n+  std::unique_ptr<Pattern> &get_pattern ()\n+  {\n     rust_assert (pattern != nullptr);\n     return pattern;\n   }\n@@ -3814,8 +3949,7 @@ class IfExpr : public ExprWithBlock\n   // outer attributes are never allowed on IfExprs\n \n   // Copy constructor with clone\n-  IfExpr (IfExpr const &other)\n-    : ExprWithBlock (other), locus (other.locus)\n+  IfExpr (IfExpr const &other) : ExprWithBlock (other), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.condition != nullptr)\n@@ -3866,20 +4000,29 @@ class IfExpr : public ExprWithBlock\n   void vis_if_block (ASTVisitor &vis) { if_block->accept_vis (vis); }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_condition_expr () {\n+  std::unique_ptr<Expr> &get_condition_expr ()\n+  {\n     rust_assert (condition != nullptr);\n     return condition;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<BlockExpr> &get_if_block () {\n+  std::unique_ptr<BlockExpr> &get_if_block ()\n+  {\n     rust_assert (if_block != nullptr);\n     return if_block;\n   }\n \n-  // Invalid if if block or condition is null, so base stripping on that. \n-  void mark_for_strip () override { if_block = nullptr; condition = nullptr; }\n-  bool is_marked_for_strip () const override { return if_block == nullptr && condition == nullptr; }\n+  // Invalid if if block or condition is null, so base stripping on that.\n+  void mark_for_strip () override\n+  {\n+    if_block = nullptr;\n+    condition = nullptr;\n+  }\n+  bool is_marked_for_strip () const override\n+  {\n+    return if_block == nullptr && condition == nullptr;\n+  }\n \n protected:\n   // Base clone function but still concrete as concrete base class\n@@ -3934,7 +4077,8 @@ class IfExprConseqElse : public IfExpr\n   void vis_else_block (ASTVisitor &vis) { else_block->accept_vis (vis); }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<BlockExpr> &get_else_block () {\n+  std::unique_ptr<BlockExpr> &get_else_block ()\n+  {\n     rust_assert (else_block != nullptr);\n     return else_block;\n   }\n@@ -3992,7 +4136,8 @@ class IfExprConseqIf : public IfExpr\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<IfExpr> &get_conseq_if_expr () {\n+  std::unique_ptr<IfExpr> &get_conseq_if_expr ()\n+  {\n     rust_assert (conseq_if_expr != nullptr);\n     return conseq_if_expr;\n   }\n@@ -4080,25 +4225,40 @@ class IfLetExpr : public ExprWithBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  // Invalid if block or value is null, so base stripping on that. \n-  void mark_for_strip () override { if_block = nullptr; value = nullptr; }\n-  bool is_marked_for_strip () const override { return if_block == nullptr && value == nullptr; }\n+  // Invalid if block or value is null, so base stripping on that.\n+  void mark_for_strip () override\n+  {\n+    if_block = nullptr;\n+    value = nullptr;\n+  }\n+  bool is_marked_for_strip () const override\n+  {\n+    return if_block == nullptr && value == nullptr;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_value_expr () {\n+  std::unique_ptr<Expr> &get_value_expr ()\n+  {\n     rust_assert (value != nullptr);\n     return value;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<BlockExpr> &get_if_block () {\n+  std::unique_ptr<BlockExpr> &get_if_block ()\n+  {\n     rust_assert (if_block != nullptr);\n     return if_block;\n   }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n-  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const { return match_arm_patterns; }\n-  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return match_arm_patterns; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const\n+  {\n+    return match_arm_patterns;\n+  }\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns ()\n+  {\n+    return match_arm_patterns;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -4155,7 +4315,8 @@ class IfExprConseqIfLet : public IfExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<IfLetExpr> &get_conseq_if_let_expr () {\n+  std::unique_ptr<IfLetExpr> &get_conseq_if_let_expr ()\n+  {\n     rust_assert (if_let_expr != nullptr);\n     return if_let_expr;\n   }\n@@ -4213,7 +4374,8 @@ class IfLetExprConseqElse : public IfLetExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<BlockExpr> &get_else_block () {\n+  std::unique_ptr<BlockExpr> &get_else_block ()\n+  {\n     rust_assert (else_block != nullptr);\n     return else_block;\n   }\n@@ -4270,7 +4432,8 @@ class IfLetExprConseqIf : public IfLetExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<IfExpr> &get_conseq_if_expr () {\n+  std::unique_ptr<IfExpr> &get_conseq_if_expr ()\n+  {\n     rust_assert (if_expr != nullptr);\n     return if_expr;\n   }\n@@ -4327,7 +4490,8 @@ class IfLetExprConseqIfLet : public IfLetExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<IfLetExpr> &get_conseq_if_let_expr () {\n+  std::unique_ptr<IfLetExpr> &get_conseq_if_let_expr ()\n+  {\n     rust_assert (if_let_expr != nullptr);\n     return if_let_expr;\n   }\n@@ -4415,7 +4579,8 @@ struct MatchArm\n   std::string as_string () const;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_guard_expr () {\n+  std::unique_ptr<Expr> &get_guard_expr ()\n+  {\n     rust_assert (has_match_arm_guard ());\n     return guard_expr;\n   }\n@@ -4424,8 +4589,14 @@ struct MatchArm\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n \n-  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const { return match_arm_patterns; }\n-  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return match_arm_patterns; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const\n+  {\n+    return match_arm_patterns;\n+  }\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns ()\n+  {\n+    return match_arm_patterns;\n+  }\n };\n \n /*\n@@ -4493,13 +4664,15 @@ struct MatchCase\n   std::string as_string () const;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_expr () {\n+  std::unique_ptr<Expr> &get_expr ()\n+  {\n     rust_assert (expr != nullptr);\n     return expr;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  MatchArm &get_arm () {\n+  MatchArm &get_arm ()\n+  {\n     rust_assert (!arm.is_error ());\n     return arm;\n   }\n@@ -4628,7 +4801,7 @@ class MatchExpr : public ExprWithBlock\n \n   // Copy constructor requires clone due to unique_ptr\n   MatchExpr (MatchExpr const &other)\n-    : ExprWithBlock (other), inner_attrs (other.inner_attrs), \n+    : ExprWithBlock (other), inner_attrs (other.inner_attrs),\n       match_arms (other.match_arms), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n@@ -4671,7 +4844,7 @@ class MatchExpr : public ExprWithBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  // Invalid if branch value is null, so base stripping on that. \n+  // Invalid if branch value is null, so base stripping on that.\n   void mark_for_strip () override { branch_value = nullptr; }\n   bool is_marked_for_strip () const override { return branch_value == nullptr; }\n \n@@ -4680,7 +4853,8 @@ class MatchExpr : public ExprWithBlock\n   std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_scrutinee_expr () {\n+  std::unique_ptr<Expr> &get_scrutinee_expr ()\n+  {\n     rust_assert (branch_value != nullptr);\n     return branch_value;\n   }\n@@ -4746,12 +4920,13 @@ class AwaitExpr : public ExprWithoutBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  // Invalid if awaited expr is null, so base stripping on that. \n+  // Invalid if awaited expr is null, so base stripping on that.\n   void mark_for_strip () override { awaited_expr = nullptr; }\n   bool is_marked_for_strip () const override { return awaited_expr == nullptr; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_awaited_expr () {\n+  std::unique_ptr<Expr> &get_awaited_expr ()\n+  {\n     rust_assert (awaited_expr != nullptr);\n     return awaited_expr;\n   }\n@@ -4816,12 +4991,13 @@ class AsyncBlockExpr : public ExprWithBlock\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  // Invalid if block is null, so base stripping on that. \n+  // Invalid if block is null, so base stripping on that.\n   void mark_for_strip () override { block_expr = nullptr; }\n   bool is_marked_for_strip () const override { return block_expr == nullptr; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<BlockExpr> &get_block_expr () {\n+  std::unique_ptr<BlockExpr> &get_block_expr ()\n+  {\n     rust_assert (block_expr != nullptr);\n     return block_expr;\n   }"}, {"sha": "f18124dca2c135c82429ee14b8195a63894080fe", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 455, "deletions": 212, "changes": 667, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=53ddea7a266c43f30702b0c24ce05e4d5dad0ecc", "patch": "@@ -57,7 +57,7 @@ class TypeParam : public GenericParam\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound>>\n+  std::vector<std::unique_ptr<TypeParamBound> >\n     type_param_bounds; // inlined form\n \n   // bool has_type;\n@@ -76,8 +76,8 @@ class TypeParam : public GenericParam\n   bool has_outer_attribute () const { return !outer_attr.is_empty (); }\n \n   TypeParam (Identifier type_representation, Location locus = Location (),\n-\t     std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds\n-\t     = std::vector<std::unique_ptr<TypeParamBound>> (),\n+\t     std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds\n+\t     = std::vector<std::unique_ptr<TypeParamBound> > (),\n \t     std::unique_ptr<Type> type = nullptr,\n \t     Attribute outer_attr = Attribute::create_empty ())\n     : outer_attr (std::move (outer_attr)),\n@@ -89,8 +89,7 @@ class TypeParam : public GenericParam\n   // Copy constructor uses clone\n   TypeParam (TypeParam const &other)\n     : outer_attr (other.outer_attr),\n-      type_representation (other.type_representation),\n-      locus (other.locus)\n+      type_representation (other.type_representation), locus (other.locus)\n   {\n     // guard to prevent null pointer dereference\n     if (other.type != nullptr)\n@@ -132,14 +131,22 @@ class TypeParam : public GenericParam\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_type () {\n+  std::unique_ptr<Type> &get_type ()\n+  {\n     rust_assert (type != nullptr);\n     return type;\n   }\n \n   // TODO: mutable getter seems kinda dodgy\n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () { return type_param_bounds; }\n-  const std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () const { return type_param_bounds; }\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n@@ -211,7 +218,7 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound>>\n+  std::vector<std::unique_ptr<TypeParamBound> >\n     type_param_bounds; // inlined form\n \n   // should this store location info?\n@@ -225,7 +232,7 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n \n   TypeBoundWhereClauseItem (\n     std::vector<LifetimeParam> for_lifetimes, std::unique_ptr<Type> bound_type,\n-    std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds)\n+    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds)\n     : for_lifetimes (std::move (for_lifetimes)),\n       bound_type (std::move (bound_type)),\n       type_param_bounds (std::move (type_param_bounds))\n@@ -264,14 +271,22 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_type () {\n+  std::unique_ptr<Type> &get_type ()\n+  {\n     rust_assert (bound_type != nullptr);\n     return bound_type;\n   }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () { return type_param_bounds; }\n-  const std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () const { return type_param_bounds; }\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n@@ -285,13 +300,13 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n struct WhereClause\n {\n private:\n-  std::vector<std::unique_ptr<WhereClauseItem>> where_clause_items;\n+  std::vector<std::unique_ptr<WhereClauseItem> > where_clause_items;\n \n   // should this store location info?\n \n public:\n   WhereClause (\n-    std::vector<std::unique_ptr<WhereClauseItem>> where_clause_items)\n+    std::vector<std::unique_ptr<WhereClauseItem> > where_clause_items)\n     : where_clause_items (std::move (where_clause_items))\n   {}\n \n@@ -320,7 +335,7 @@ struct WhereClause\n   // Creates a WhereClause with no items.\n   static WhereClause create_empty ()\n   {\n-    return WhereClause (std::vector<std::unique_ptr<WhereClauseItem>> ());\n+    return WhereClause (std::vector<std::unique_ptr<WhereClauseItem> > ());\n   }\n \n   // Returns whether the WhereClause has no items.\n@@ -329,8 +344,14 @@ struct WhereClause\n   std::string as_string () const;\n \n   // TODO: this mutable getter seems kinda dodgy\n-  std::vector<std::unique_ptr<WhereClauseItem> > &get_items () { return where_clause_items; }\n-  const std::vector<std::unique_ptr<WhereClauseItem> > &get_items () const { return where_clause_items; }\n+  std::vector<std::unique_ptr<WhereClauseItem> > &get_items ()\n+  {\n+    return where_clause_items;\n+  }\n+  const std::vector<std::unique_ptr<WhereClauseItem> > &get_items () const\n+  {\n+    return where_clause_items;\n+  }\n };\n \n // A self parameter in a method\n@@ -423,7 +444,8 @@ struct SelfParam\n   Location get_locus () const { return locus; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_type () {\n+  std::unique_ptr<Type> &get_type ()\n+  {\n     rust_assert (has_type ());\n     return type;\n   }\n@@ -479,8 +501,9 @@ struct FunctionParam\n \n public:\n   FunctionParam (std::unique_ptr<Pattern> param_name,\n-\t\t std::unique_ptr<Type> param_type, std::vector<Attribute> outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)), locus (locus), \n+\t\t std::unique_ptr<Type> param_type,\n+\t\t std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)), locus (locus),\n       param_name (std::move (param_name)), type (std::move (param_type))\n   {}\n \n@@ -534,13 +557,15 @@ struct FunctionParam\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Pattern> &get_pattern () {\n+  std::unique_ptr<Pattern> &get_pattern ()\n+  {\n     rust_assert (param_name != nullptr);\n     return param_name;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_type () {\n+  std::unique_ptr<Type> &get_type ()\n+  {\n     rust_assert (type != nullptr);\n     return type;\n   }\n@@ -647,7 +672,7 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   SelfParam self_param;\n \n@@ -670,14 +695,15 @@ class Method : public InherentImplItem, public TraitImplItem\n   // Returns whether the method is in an error state.\n   bool is_error () const\n   {\n-    return function_body == nullptr || method_name.empty () || self_param.is_error ();\n+    return function_body == nullptr || method_name.empty ()\n+\t   || self_param.is_error ();\n   }\n \n   // Creates an error state method.\n   static Method create_error ()\n   {\n     return Method (\"\", FunctionQualifiers (FunctionQualifiers::NONE, true),\n-\t\t   std::vector<std::unique_ptr<GenericParam>> (),\n+\t\t   std::vector<std::unique_ptr<GenericParam> > (),\n \t\t   SelfParam::create_error (), std::vector<FunctionParam> (),\n \t\t   nullptr, WhereClause::create_empty (), nullptr,\n \t\t   Visibility::create_error (), std::vector<Attribute> (), {});\n@@ -700,7 +726,7 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   // Mega-constructor with all possible fields\n   Method (Identifier method_name, FunctionQualifiers qualifiers,\n-\t  std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t  std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t  SelfParam self_param, std::vector<FunctionParam> function_params,\n \t  std::unique_ptr<Type> return_type, WhereClause where_clause,\n \t  std::unique_ptr<BlockExpr> function_body, Visibility vis,\n@@ -712,8 +738,8 @@ class Method : public InherentImplItem, public TraitImplItem\n       self_param (std::move (self_param)),\n       function_params (std::move (function_params)),\n       return_type (std::move (return_type)),\n-      where_clause (std::move (where_clause)), function_body (std::move (function_body)),\n-      locus (locus)\n+      where_clause (std::move (where_clause)),\n+      function_body (std::move (function_body)), locus (locus)\n   {}\n \n   // TODO: add constructor with less fields\n@@ -728,7 +754,7 @@ class Method : public InherentImplItem, public TraitImplItem\n     // guard to prevent null dereference (always required)\n     if (other.return_type != nullptr)\n       return_type = other.return_type->clone_type ();\n-    \n+\n     // guard to prevent null dereference (only required if error state)\n     if (other.function_body != nullptr)\n       function_body = other.function_body->clone_block_expr ();\n@@ -779,20 +805,33 @@ class Method : public InherentImplItem, public TraitImplItem\n \n   // Invalid if block is null, so base stripping on that.\n   void mark_for_strip () override { function_body = nullptr; }\n-  bool is_marked_for_strip () const override { return function_body == nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return function_body == nullptr;\n+  }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n   std::vector<FunctionParam> &get_function_params () { return function_params; }\n-  const std::vector<FunctionParam> &get_function_params () const { return function_params; }\n+  const std::vector<FunctionParam> &get_function_params () const\n+  {\n+    return function_params;\n+  }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<BlockExpr> &get_definition () {\n+  std::unique_ptr<BlockExpr> &get_definition ()\n+  {\n     rust_assert (function_body != nullptr);\n     return function_body;\n   }\n@@ -801,13 +840,15 @@ class Method : public InherentImplItem, public TraitImplItem\n   const SelfParam &get_self_param () const { return self_param; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_return_type () {\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n     rust_assert (has_return_type ());\n     return return_type;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause () {\n+  WhereClause &get_where_clause ()\n+  {\n     rust_assert (has_where_clause ());\n     return where_clause;\n   }\n@@ -838,11 +879,12 @@ class VisItem : public Item\n   // Visibility constructor\n   VisItem (Visibility visibility,\n \t   std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n-    : visibility (std::move (visibility)), outer_attrs(std::move (outer_attrs))\n+    : visibility (std::move (visibility)), outer_attrs (std::move (outer_attrs))\n   {}\n \n   // Visibility copy constructor\n-  VisItem (VisItem const &other) : visibility (other.visibility), outer_attrs(other.outer_attrs)\n+  VisItem (VisItem const &other)\n+    : visibility (other.visibility), outer_attrs (other.outer_attrs)\n   {}\n \n   // Overload assignment operator to clone\n@@ -903,7 +945,7 @@ class ModuleBodied : public Module\n   // bool has_inner_attrs;\n   std::vector<Attribute> inner_attrs;\n   // bool has_items;\n-  std::vector<std::unique_ptr<Item>> items;\n+  std::vector<std::unique_ptr<Item> > items;\n \n public:\n   std::string as_string () const override;\n@@ -916,8 +958,8 @@ class ModuleBodied : public Module\n \n   // Full constructor\n   ModuleBodied (Identifier name, Location locus,\n-\t\tstd::vector<std::unique_ptr<Item>> items\n-\t\t= std::vector<std::unique_ptr<Item>> (),\n+\t\tstd::vector<std::unique_ptr<Item> > items\n+\t\t= std::vector<std::unique_ptr<Item> > (),\n \t\tVisibility visibility = Visibility::create_error (),\n \t\tstd::vector<Attribute> inner_attrs = std::vector<Attribute> (),\n \t\tstd::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n@@ -959,11 +1001,14 @@ class ModuleBodied : public Module\n   void add_crate_name (std::vector<std::string> &names) const override;\n \n   // TODO: think of better way to do this - mutable getter seems dodgy\n-  const std::vector<Attribute>& get_inner_attrs () const { return inner_attrs; }\n-  std::vector<Attribute>& get_inner_attrs () { return inner_attrs; }\n+  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n-  const std::vector<std::unique_ptr<Item>>& get_items () const { return items; }\n-  std::vector<std::unique_ptr<Item>>& get_items () { return items; }\n+  const std::vector<std::unique_ptr<Item> > &get_items () const\n+  {\n+    return items;\n+  }\n+  std::vector<std::unique_ptr<Item> > &get_items () { return items; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object\n@@ -977,9 +1022,11 @@ class ModuleBodied : public Module\n // Module without a body, loaded from external file\n class ModuleNoBody : public Module\n {\n-  /* TODO: are modules loaded from file unique? As in, can you load the same file into two different\n-   * other files? Because this may make the difference between simply replacing this with the module\n-   * \"definition\" (as loaded from another file) vs this having to \"reference\" a module with body. */\n+  /* TODO: are modules loaded from file unique? As in, can you load the same\n+   * file into two different other files? Because this may make the difference\n+   * between simply replacing this with the module\n+   * \"definition\" (as loaded from another file) vs this having to \"reference\" a\n+   * module with body. */\n public:\n   std::string as_string () const override;\n \n@@ -1048,7 +1095,10 @@ class ExternCrate : public VisItem\n \n   // Invalid if crate name is empty, so base stripping on that.\n   void mark_for_strip () override { referenced_crate = \"\"; }\n-  bool is_marked_for_strip () const override { return referenced_crate.empty (); }\n+  bool is_marked_for_strip () const override\n+  {\n+    return referenced_crate.empty ();\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object\n@@ -1149,11 +1199,11 @@ class UseTreeList : public UseTree\n   PathType path_type;\n   SimplePath path;\n \n-  std::vector<std::unique_ptr<UseTree>> trees;\n+  std::vector<std::unique_ptr<UseTree> > trees;\n \n public:\n   UseTreeList (PathType path_type, SimplePath path,\n-\t       std::vector<std::unique_ptr<UseTree>> trees, Location locus)\n+\t       std::vector<std::unique_ptr<UseTree> > trees, Location locus)\n     : UseTree (locus), path_type (path_type), path (std::move (path)),\n       trees (std::move (trees))\n   {\n@@ -1337,7 +1387,7 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_function_params;\n   // FunctionParams function_params;\n@@ -1372,7 +1422,7 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   // Mega-constructor with all possible fields\n   Function (Identifier function_name, FunctionQualifiers qualifiers,\n-\t    std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t    std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t    std::vector<FunctionParam> function_params,\n \t    std::unique_ptr<Type> return_type, WhereClause where_clause,\n \t    std::unique_ptr<BlockExpr> function_body, Visibility vis,\n@@ -1399,7 +1449,7 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n     // guard to prevent null dereference (always required)\n     if (other.return_type != nullptr)\n       return_type = other.return_type->clone_type ();\n-    \n+\n     // guard to prevent null dereference (only required if error state)\n     if (other.function_body != nullptr)\n       function_body = other.function_body->clone_block_expr ();\n@@ -1426,7 +1476,7 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n       return_type = other.return_type->clone_type ();\n     else\n       return_type = nullptr;\n-    \n+\n     // guard to prevent null dereference (only required if error state)\n     if (other.function_body != nullptr)\n       function_body = other.function_body->clone_block_expr ();\n@@ -1450,17 +1500,30 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   // Invalid if block is null, so base stripping on that.\n   void mark_for_strip () override { function_body = nullptr; }\n-  bool is_marked_for_strip () const override { return function_body == nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return function_body == nullptr;\n+  }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<FunctionParam> &get_function_params () { return function_params; }\n-  const std::vector<FunctionParam> &get_function_params () const { return function_params; }\n+  const std::vector<FunctionParam> &get_function_params () const\n+  {\n+    return function_params;\n+  }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<BlockExpr> &get_definition () {\n+  std::unique_ptr<BlockExpr> &get_definition ()\n+  {\n     rust_assert (function_body != nullptr);\n     return function_body;\n   }\n@@ -1470,13 +1533,15 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n   Identifier get_function_name () const { return function_name; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause () {\n+  WhereClause &get_where_clause ()\n+  {\n     rust_assert (has_where_clause ());\n     return where_clause;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_return_type () {\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n     rust_assert (has_return_type ());\n     return return_type;\n   }\n@@ -1508,7 +1573,7 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n@@ -1528,7 +1593,7 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   // Mega-constructor with all possible fields\n   TypeAlias (Identifier new_type_name,\n-\t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t     WhereClause where_clause, std::unique_ptr<Type> existing_type,\n \t     Visibility vis, std::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -1585,19 +1650,30 @@ class TypeAlias : public VisItem, public TraitImplItem\n \n   // Invalid if existing type is null, so base stripping on that.\n   void mark_for_strip () override { existing_type = nullptr; }\n-  bool is_marked_for_strip () const override { return existing_type == nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return existing_type == nullptr;\n+  }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause () {\n+  WhereClause &get_where_clause ()\n+  {\n     rust_assert (has_where_clause ());\n     return where_clause;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_type_aliased () {\n+  std::unique_ptr<Type> &get_type_aliased ()\n+  {\n     rust_assert (existing_type != nullptr);\n     return existing_type;\n   }\n@@ -1624,7 +1700,7 @@ class Struct : public VisItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n@@ -1647,18 +1723,25 @@ class Struct : public VisItem\n \n   Identifier get_struct_name () const { return struct_name; }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause () {\n+  WhereClause &get_where_clause ()\n+  {\n     rust_assert (has_where_clause ());\n     return where_clause;\n   }\n \n protected:\n   Struct (Identifier struct_name,\n-\t  std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t  std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t  WhereClause where_clause, Visibility vis, Location locus,\n \t  std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -1780,7 +1863,8 @@ struct StructField\n   Identifier get_field_name () const { return field_name; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_field_type () {\n+  std::unique_ptr<Type> &get_field_type ()\n+  {\n     rust_assert (field_type != nullptr);\n     return field_type;\n   }\n@@ -1799,7 +1883,7 @@ class StructStruct : public Struct\n \n   // Mega-constructor with all possible fields\n   StructStruct (std::vector<StructField> fields, Identifier struct_name,\n-\t\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n \t\tWhereClause where_clause, bool is_unit, Visibility vis,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n     : Struct (std::move (struct_name), std::move (generic_params),\n@@ -1810,12 +1894,13 @@ class StructStruct : public Struct\n \n   // Unit struct constructor\n   StructStruct (Identifier struct_name,\n-\t\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n \t\tWhereClause where_clause, Visibility vis,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n     : Struct (std::move (struct_name), std::move (generic_params),\n \t      std::move (where_clause), std::move (vis), locus,\n-\t      std::move (outer_attrs)), is_unit (true)\n+\t      std::move (outer_attrs)),\n+      is_unit (true)\n   {}\n   // TODO: can a unit struct have generic fields? assuming yes for now.\n \n@@ -1914,7 +1999,8 @@ struct TupleField\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_field_type () {\n+  std::unique_ptr<Type> &get_field_type ()\n+  {\n     rust_assert (field_type != nullptr);\n     return field_type;\n   }\n@@ -1930,7 +2016,7 @@ class TupleStruct : public Struct\n \n   // Mega-constructor with all possible fields\n   TupleStruct (std::vector<TupleField> fields, Identifier struct_name,\n-\t       std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t       std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t       WhereClause where_clause, Visibility vis,\n \t       std::vector<Attribute> outer_attrs, Location locus)\n     : Struct (std::move (struct_name), std::move (generic_params),\n@@ -2026,7 +2112,10 @@ class EnumItemTuple : public EnumItem\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<TupleField> &get_tuple_fields () { return tuple_fields; }\n-  const std::vector<TupleField> &get_tuple_fields () const { return tuple_fields; }\n+  const std::vector<TupleField> &get_tuple_fields () const\n+  {\n+    return tuple_fields;\n+  }\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n@@ -2059,7 +2148,10 @@ class EnumItemStruct : public EnumItem\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<StructField> &get_struct_fields () { return struct_fields; }\n-  const std::vector<StructField> &get_struct_fields () const { return struct_fields; }\n+  const std::vector<StructField> &get_struct_fields () const\n+  {\n+    return struct_fields;\n+  }\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n@@ -2106,7 +2198,8 @@ class EnumItemDiscriminant : public EnumItem\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_expr () {\n+  std::unique_ptr<Expr> &get_expr ()\n+  {\n     rust_assert (expression != nullptr);\n     return expression;\n   }\n@@ -2126,12 +2219,12 @@ class Enum : public VisItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n \n-  std::vector<std::unique_ptr<EnumItem>> items;\n+  std::vector<std::unique_ptr<EnumItem> > items;\n \n   Location locus;\n \n@@ -2150,8 +2243,8 @@ class Enum : public VisItem\n \n   // Mega-constructor\n   Enum (Identifier enum_name, Visibility vis,\n-\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n-\tWhereClause where_clause, std::vector<std::unique_ptr<EnumItem>> items,\n+\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n+\tWhereClause where_clause, std::vector<std::unique_ptr<EnumItem> > items,\n \tstd::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n       enum_name (std::move (enum_name)),\n@@ -2208,14 +2301,24 @@ class Enum : public VisItem\n   bool is_marked_for_strip () const override { return enum_name.empty (); }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n-  std::vector<std::unique_ptr<EnumItem>> &get_variants () { return items; }\n-  const std::vector<std::unique_ptr<EnumItem>> &get_variants () const { return items; }\n+  std::vector<std::unique_ptr<EnumItem> > &get_variants () { return items; }\n+  const std::vector<std::unique_ptr<EnumItem> > &get_variants () const\n+  {\n+    return items;\n+  }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause () {\n+  WhereClause &get_where_clause ()\n+  {\n     rust_assert (has_where_clause ());\n     return where_clause;\n   }\n@@ -2233,7 +2336,7 @@ class Union : public VisItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n@@ -2252,7 +2355,7 @@ class Union : public VisItem\n   bool has_where_clause () const { return !where_clause.is_empty (); }\n \n   Union (Identifier union_name, Visibility vis,\n-\t std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t WhereClause where_clause, std::vector<StructField> variants,\n \t std::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n@@ -2305,11 +2408,18 @@ class Union : public VisItem\n   std::vector<StructField> &get_variants () { return variants; }\n   const std::vector<StructField> &get_variants () const { return variants; }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause () {\n+  WhereClause &get_where_clause ()\n+  {\n     rust_assert (has_where_clause ());\n     return where_clause;\n   }\n@@ -2390,17 +2500,26 @@ class ConstantItem : public VisItem,\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Invalid if type or expression are null, so base stripping on that.\n-  void mark_for_strip () override { type = nullptr; const_expr = nullptr; }\n-  bool is_marked_for_strip () const override { return type == nullptr && const_expr == nullptr; }\n+  void mark_for_strip () override\n+  {\n+    type = nullptr;\n+    const_expr = nullptr;\n+  }\n+  bool is_marked_for_strip () const override\n+  {\n+    return type == nullptr && const_expr == nullptr;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_expr () {\n+  std::unique_ptr<Expr> &get_expr ()\n+  {\n     rust_assert (const_expr != nullptr);\n     return const_expr;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_type () {\n+  std::unique_ptr<Type> &get_type ()\n+  {\n     rust_assert (type != nullptr);\n     return type;\n   }\n@@ -2491,17 +2610,26 @@ class StaticItem : public VisItem\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Invalid if type or expression are null, so base stripping on that.\n-  void mark_for_strip () override { type = nullptr; expr = nullptr; }\n-  bool is_marked_for_strip () const override { return type == nullptr && expr == nullptr; }\n+  void mark_for_strip () override\n+  {\n+    type = nullptr;\n+    expr = nullptr;\n+  }\n+  bool is_marked_for_strip () const override\n+  {\n+    return type == nullptr && expr == nullptr;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_expr () {\n+  std::unique_ptr<Expr> &get_expr ()\n+  {\n     rust_assert (expr != nullptr);\n     return expr;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_type () {\n+  std::unique_ptr<Type> &get_type ()\n+  {\n     rust_assert (type != nullptr);\n     return type;\n   }\n@@ -2525,7 +2653,7 @@ struct TraitFunctionDecl\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_params;\n   // FunctionParams function_params;\n@@ -2554,7 +2682,7 @@ struct TraitFunctionDecl\n \n   // Mega-constructor\n   TraitFunctionDecl (Identifier function_name, FunctionQualifiers qualifiers,\n-\t\t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t\t     std::vector<FunctionParam> function_params,\n \t\t     std::unique_ptr<Type> return_type,\n \t\t     WhereClause where_clause)\n@@ -2569,8 +2697,7 @@ struct TraitFunctionDecl\n   // Copy constructor with clone\n   TraitFunctionDecl (TraitFunctionDecl const &other)\n     : qualifiers (other.qualifiers), function_name (other.function_name),\n-      function_params (other.function_params),\n-      where_clause (other.where_clause)\n+      function_params (other.function_params), where_clause (other.where_clause)\n   {\n     // guard to prevent nullptr dereference\n     if (other.return_type != nullptr)\n@@ -2616,19 +2743,30 @@ struct TraitFunctionDecl\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<FunctionParam> &get_function_params () { return function_params; }\n-  const std::vector<FunctionParam> &get_function_params () const { return function_params; }\n+  const std::vector<FunctionParam> &get_function_params () const\n+  {\n+    return function_params;\n+  }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_return_type () {\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n     rust_assert (has_return_type ());\n     return return_type;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause () {\n+  WhereClause &get_where_clause ()\n+  {\n     rust_assert (has_where_clause ());\n     return where_clause;\n   }\n@@ -2690,20 +2828,25 @@ class TraitItemFunc : public TraitItem\n \n   // Invalid if trait decl is empty, so base stripping on that.\n   void mark_for_strip () override { decl.mark_for_strip (); }\n-  bool is_marked_for_strip () const override { return decl.is_marked_for_strip (); }\n+  bool is_marked_for_strip () const override\n+  {\n+    return decl.is_marked_for_strip ();\n+  }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<BlockExpr> &get_definition () {\n+  std::unique_ptr<BlockExpr> &get_definition ()\n+  {\n     rust_assert (has_definition ());\n     return block_expr;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  TraitFunctionDecl &get_trait_function_decl () {\n+  TraitFunctionDecl &get_trait_function_decl ()\n+  {\n     // TODO: maybe only allow access if not marked for strip?\n     return decl;\n   }\n@@ -2726,7 +2869,7 @@ struct TraitMethodDecl\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   SelfParam self_param;\n \n@@ -2757,7 +2900,7 @@ struct TraitMethodDecl\n \n   // Mega-constructor\n   TraitMethodDecl (Identifier function_name, FunctionQualifiers qualifiers,\n-\t\t   std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t\t   std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t\t   SelfParam self_param,\n \t\t   std::vector<FunctionParam> function_params,\n \t\t   std::unique_ptr<Type> return_type, WhereClause where_clause)\n@@ -2821,19 +2964,30 @@ struct TraitMethodDecl\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<FunctionParam> &get_function_params () { return function_params; }\n-  const std::vector<FunctionParam> &get_function_params () const { return function_params; }\n+  const std::vector<FunctionParam> &get_function_params () const\n+  {\n+    return function_params;\n+  }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_return_type () {\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n     rust_assert (has_return_type ());\n     return return_type;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause () {\n+  WhereClause &get_where_clause ()\n+  {\n     rust_assert (has_where_clause ());\n     return where_clause;\n   }\n@@ -2862,8 +3016,7 @@ class TraitItemMethod : public TraitItem\n \n   // Copy constructor with clone\n   TraitItemMethod (TraitItemMethod const &other)\n-    : outer_attrs (other.outer_attrs), decl (other.decl),\n-      locus (other.locus)\n+    : outer_attrs (other.outer_attrs), decl (other.decl), locus (other.locus)\n   {\n     // guard to prevent null dereference\n     if (other.block_expr != nullptr)\n@@ -2899,21 +3052,26 @@ class TraitItemMethod : public TraitItem\n \n   // Invalid if trait decl is empty, so base stripping on that.\n   void mark_for_strip () override { decl.mark_for_strip (); }\n-  bool is_marked_for_strip () const override { return decl.is_marked_for_strip (); }\n+  bool is_marked_for_strip () const override\n+  {\n+    return decl.is_marked_for_strip ();\n+  }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  TraitMethodDecl &get_trait_method_decl () {\n+  TraitMethodDecl &get_trait_method_decl ()\n+  {\n     // TODO: maybe only allow access if not marked for strip?\n     return decl;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<BlockExpr> &get_definition () {\n-    rust_assert (has_definition());\n+  std::unique_ptr<BlockExpr> &get_definition ()\n+  {\n+    rust_assert (has_definition ());\n     return block_expr;\n   }\n \n@@ -2955,7 +3113,7 @@ class TraitItemConst : public TraitItem\n     // guard to prevent null dereference\n     if (other.expr != nullptr)\n       expr = other.expr->clone_expr ();\n-    \n+\n     // guard to prevent null dereference (only for error state)\n     if (other.type != nullptr)\n       type = other.type->clone_type ();\n@@ -3003,13 +3161,15 @@ class TraitItemConst : public TraitItem\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_expr () {\n+  std::unique_ptr<Expr> &get_expr ()\n+  {\n     rust_assert (expr != nullptr);\n     return expr;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_type () {\n+  std::unique_ptr<Type> &get_type ()\n+  {\n     rust_assert (type != nullptr);\n     return type;\n   }\n@@ -3031,7 +3191,7 @@ class TraitItemType : public TraitItem\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound>>\n+  std::vector<std::unique_ptr<TypeParamBound> >\n     type_param_bounds; // inlined form\n \n   Location locus;\n@@ -3042,7 +3202,7 @@ class TraitItemType : public TraitItem\n \n   TraitItemType (\n     Identifier name,\n-    std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n+    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n     std::vector<Attribute> outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)), name (std::move (name)),\n       type_param_bounds (std::move (type_param_bounds)), locus (locus)\n@@ -3091,8 +3251,15 @@ class TraitItemType : public TraitItem\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n   // TODO: mutable getter seems kinda dodgy\n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () { return type_param_bounds; }\n-  const std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () const { return type_param_bounds; }\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n@@ -3110,11 +3277,11 @@ class Trait : public VisItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound>>\n+  std::vector<std::unique_ptr<TypeParamBound> >\n     type_param_bounds; // inlined form\n \n   // bool has_where_clause;\n@@ -3123,7 +3290,7 @@ class Trait : public VisItem\n   std::vector<Attribute> inner_attrs;\n \n   // bool has_trait_items;\n-  std::vector<std::unique_ptr<TraitItem>> trait_items;\n+  std::vector<std::unique_ptr<TraitItem> > trait_items;\n \n   Location locus;\n \n@@ -3147,23 +3314,26 @@ class Trait : public VisItem\n \n   // Mega-constructor\n   Trait (Identifier name, bool is_unsafe,\n-\t std::vector<std::unique_ptr<GenericParam>> generic_params,\n-\t std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n+\t std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n \t WhereClause where_clause,\n-\t std::vector<std::unique_ptr<TraitItem>> trait_items, Visibility vis,\n-\t std::vector<Attribute> outer_attrs, std::vector<Attribute> inner_attrs, Location locus)\n+\t std::vector<std::unique_ptr<TraitItem> > trait_items, Visibility vis,\n+\t std::vector<Attribute> outer_attrs, std::vector<Attribute> inner_attrs,\n+\t Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n       has_unsafe (is_unsafe), name (std::move (name)),\n       generic_params (std::move (generic_params)),\n       type_param_bounds (std::move (type_param_bounds)),\n-      where_clause (std::move (where_clause)), inner_attrs (std::move (inner_attrs)),\n+      where_clause (std::move (where_clause)),\n+      inner_attrs (std::move (inner_attrs)),\n       trait_items (std::move (trait_items)), locus (locus)\n   {}\n \n   // Copy constructor with vector clone\n   Trait (Trait const &other)\n     : VisItem (other), has_unsafe (other.has_unsafe), name (other.name),\n-      where_clause (other.where_clause), inner_attrs (other.inner_attrs), locus (other.locus)\n+      where_clause (other.where_clause), inner_attrs (other.inner_attrs),\n+      locus (other.locus)\n   {\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n@@ -3216,20 +3386,40 @@ class Trait : public VisItem\n   bool is_marked_for_strip () const override { return name.empty (); }\n \n   // TODO: think of better way to do this\n-  const std::vector<Attribute>& get_inner_attrs () const { return inner_attrs; }\n-  std::vector<Attribute>& get_inner_attrs () { return inner_attrs; }\n+  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n-  const std::vector<std::unique_ptr<TraitItem>>& get_trait_items () const { return trait_items; }\n-  std::vector<std::unique_ptr<TraitItem>>& get_trait_items () { return trait_items; }\n+  const std::vector<std::unique_ptr<TraitItem> > &get_trait_items () const\n+  {\n+    return trait_items;\n+  }\n+  std::vector<std::unique_ptr<TraitItem> > &get_trait_items ()\n+  {\n+    return trait_items;\n+  }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n \n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () { return type_param_bounds; }\n-  const std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () const { return type_param_bounds; }\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause () {\n+  WhereClause &get_where_clause ()\n+  {\n     rust_assert (has_where_clause ());\n     return where_clause;\n   }\n@@ -3247,7 +3437,7 @@ class Impl : public VisItem\n protected:\n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   std::unique_ptr<Type> trait_type;\n \n@@ -3278,27 +3468,35 @@ class Impl : public VisItem\n   bool is_marked_for_strip () const override { return trait_type == nullptr; }\n \n   // TODO: think of better way to do this\n-  const std::vector<Attribute>& get_inner_attrs () const { return inner_attrs; }\n-  std::vector<Attribute>& get_inner_attrs () { return inner_attrs; }\n+  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause () {\n+  WhereClause &get_where_clause ()\n+  {\n     rust_assert (has_where_clause ());\n     return where_clause;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_type () {\n+  std::unique_ptr<Type> &get_type ()\n+  {\n     rust_assert (trait_type != nullptr);\n     return trait_type;\n   }\n \n protected:\n   // Mega-constructor\n-  Impl (std::vector<std::unique_ptr<GenericParam>> generic_params,\n+  Impl (std::vector<std::unique_ptr<GenericParam> > generic_params,\n \tstd::unique_ptr<Type> trait_type, WhereClause where_clause,\n \tVisibility vis, std::vector<Attribute> inner_attrs,\n \tstd::vector<Attribute> outer_attrs, Location locus)\n@@ -3311,7 +3509,7 @@ class Impl : public VisItem\n \n   // Copy constructor\n   Impl (Impl const &other)\n-    : VisItem (other), where_clause (other.where_clause), \n+    : VisItem (other), where_clause (other.where_clause),\n       inner_attrs (other.inner_attrs), locus (other.locus)\n   {\n     // guard to prevent null dereference (only required if error state)\n@@ -3353,7 +3551,7 @@ class Impl : public VisItem\n class InherentImpl : public Impl\n {\n   // bool has_impl_items;\n-  std::vector<std::unique_ptr<InherentImplItem>> impl_items;\n+  std::vector<std::unique_ptr<InherentImplItem> > impl_items;\n \n public:\n   std::string as_string () const override;\n@@ -3362,8 +3560,8 @@ class InherentImpl : public Impl\n   bool has_impl_items () const { return !impl_items.empty (); }\n \n   // Mega-constructor\n-  InherentImpl (std::vector<std::unique_ptr<InherentImplItem>> impl_items,\n-\t\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n+  InherentImpl (std::vector<std::unique_ptr<InherentImplItem> > impl_items,\n+\t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n \t\tstd::unique_ptr<Type> trait_type, WhereClause where_clause,\n \t\tVisibility vis, std::vector<Attribute> inner_attrs,\n \t\tstd::vector<Attribute> outer_attrs, Location locus)\n@@ -3400,8 +3598,14 @@ class InherentImpl : public Impl\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: think of better way to do this\n-  const std::vector<std::unique_ptr<InherentImplItem>>& get_impl_items () const { return impl_items; }\n-  std::vector<std::unique_ptr<InherentImplItem>>& get_impl_items () { return impl_items; }\n+  const std::vector<std::unique_ptr<InherentImplItem> > &get_impl_items () const\n+  {\n+    return impl_items;\n+  }\n+  std::vector<std::unique_ptr<InherentImplItem> > &get_impl_items ()\n+  {\n+    return impl_items;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object\n@@ -3420,7 +3624,7 @@ class TraitImpl : public Impl\n   TypePath trait_path;\n \n   // bool has_impl_items;\n-  std::vector<std::unique_ptr<TraitImplItem>> impl_items;\n+  std::vector<std::unique_ptr<TraitImplItem> > impl_items;\n \n public:\n   std::string as_string () const override;\n@@ -3430,8 +3634,8 @@ class TraitImpl : public Impl\n \n   // Mega-constructor\n   TraitImpl (TypePath trait_path, bool is_unsafe, bool has_exclam,\n-\t     std::vector<std::unique_ptr<TraitImplItem>> impl_items,\n-\t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t     std::vector<std::unique_ptr<TraitImplItem> > impl_items,\n+\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n \t     std::unique_ptr<Type> trait_type, WhereClause where_clause,\n \t     Visibility vis, std::vector<Attribute> inner_attrs,\n \t     std::vector<Attribute> outer_attrs, Location locus)\n@@ -3476,11 +3680,18 @@ class TraitImpl : public Impl\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: think of better way to do this\n-  const std::vector<std::unique_ptr<TraitImplItem>>& get_impl_items () const { return impl_items; }\n-  std::vector<std::unique_ptr<TraitImplItem>>& get_impl_items () { return impl_items; }\n+  const std::vector<std::unique_ptr<TraitImplItem> > &get_impl_items () const\n+  {\n+    return impl_items;\n+  }\n+  std::vector<std::unique_ptr<TraitImplItem> > &get_impl_items ()\n+  {\n+    return impl_items;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  TypePath &get_trait_path () {\n+  TypePath &get_trait_path ()\n+  {\n     // TODO: assert that trait path is not empty?\n     return trait_path;\n   }\n@@ -3587,17 +3798,17 @@ class ExternalStaticItem : public ExternalItem\n \n public:\n   ExternalStaticItem (Identifier item_name, std::unique_ptr<Type> item_type,\n-\t\t      bool is_mut, Visibility vis, std::vector<Attribute> outer_attrs, \n-          Location locus)\n-    : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)), \n-      item_name (std::move (item_name)), locus (locus), has_mut (is_mut), \n+\t\t      bool is_mut, Visibility vis,\n+\t\t      std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)),\n+      item_name (std::move (item_name)), locus (locus), has_mut (is_mut),\n       item_type (std::move (item_type))\n   {}\n \n   // Copy constructor\n   ExternalStaticItem (ExternalStaticItem const &other)\n-    : outer_attrs (other.outer_attrs), visibility (other.visibility), item_name (other.item_name), \n-      locus (other.locus), has_mut (other.has_mut)\n+    : outer_attrs (other.outer_attrs), visibility (other.visibility),\n+      item_name (other.item_name), locus (other.locus), has_mut (other.has_mut)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.item_type != nullptr)\n@@ -3647,7 +3858,8 @@ class ExternalStaticItem : public ExternalItem\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_type () {\n+  std::unique_ptr<Type> &get_type ()\n+  {\n     rust_assert (item_type != nullptr);\n     return item_type;\n   }\n@@ -3666,14 +3878,14 @@ struct NamedFunctionParam\n {\n private:\n   // bool has_name;   // otherwise is _\n-  std::string name; \n+  std::string name;\n \n   std::unique_ptr<Type> param_type;\n \n   // TODO: should this store location data?\n \n   // seemingly new since writing this node\n-  std::vector<Attribute> outer_attrs; \n+  std::vector<Attribute> outer_attrs;\n \n public:\n   /* Returns whether the named function parameter has a name (i.e. name is not\n@@ -3695,8 +3907,10 @@ struct NamedFunctionParam\n     return NamedFunctionParam (\"\", nullptr, {});\n   }\n \n-  NamedFunctionParam (std::string name, std::unique_ptr<Type> param_type, std::vector<Attribute> outer_attrs)\n-    : name (std::move (name)), param_type (std::move (param_type)), outer_attrs (std::move (outer_attrs))\n+  NamedFunctionParam (std::string name, std::unique_ptr<Type> param_type,\n+\t\t      std::vector<Attribute> outer_attrs)\n+    : name (std::move (name)), param_type (std::move (param_type)),\n+      outer_attrs (std::move (outer_attrs))\n   {}\n \n   // Copy constructor\n@@ -3741,7 +3955,8 @@ struct NamedFunctionParam\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_type () {\n+  std::unique_ptr<Type> &get_type ()\n+  {\n     rust_assert (param_type != nullptr);\n     return param_type;\n   }\n@@ -3761,7 +3976,7 @@ class ExternalFunctionItem : public ExternalItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n \n   // bool has_return_type;\n   // FunctionReturnType return_type;\n@@ -3794,33 +4009,41 @@ class ExternalFunctionItem : public ExternalItem\n   bool is_variadic () const { return has_variadics; }\n \n   // Returns whether item has outer attributes on its variadic parameters.\n-  bool has_variadic_outer_attrs () const { return !variadic_outer_attrs.empty (); }\n+  bool has_variadic_outer_attrs () const\n+  {\n+    return !variadic_outer_attrs.empty ();\n+  }\n \n   Location get_locus () const { return locus; }\n \n   ExternalFunctionItem (\n     Identifier item_name,\n-    std::vector<std::unique_ptr<GenericParam>> generic_params,\n+    std::vector<std::unique_ptr<GenericParam> > generic_params,\n     std::unique_ptr<Type> return_type, WhereClause where_clause,\n-    std::vector<NamedFunctionParam> function_params, bool has_variadics, std::vector<Attribute> variadic_outer_attrs,\n-    Visibility vis, std::vector<Attribute> outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)), \n+    std::vector<NamedFunctionParam> function_params, bool has_variadics,\n+    std::vector<Attribute> variadic_outer_attrs, Visibility vis,\n+    std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)), visibility (std::move (vis)),\n       item_name (std::move (item_name)), locus (locus),\n       generic_params (std::move (generic_params)),\n       return_type (std::move (return_type)),\n       where_clause (std::move (where_clause)),\n       function_params (std::move (function_params)),\n-      has_variadics (has_variadics), variadic_outer_attrs (std::move (variadic_outer_attrs))\n+      has_variadics (has_variadics),\n+      variadic_outer_attrs (std::move (variadic_outer_attrs))\n   {\n-    // TODO: assert that if has variadic outer attrs, then has_variadics is true?\n+    // TODO: assert that if has variadic outer attrs, then has_variadics is\n+    // true?\n   }\n \n   // Copy constructor with clone\n   ExternalFunctionItem (ExternalFunctionItem const &other)\n-    : outer_attrs (other.outer_attrs), visibility (other.visibility), item_name (other.item_name), \n-      locus (other.locus), where_clause (other.where_clause),\n+    : outer_attrs (other.outer_attrs), visibility (other.visibility),\n+      item_name (other.item_name), locus (other.locus),\n+      where_clause (other.where_clause),\n       function_params (other.function_params),\n-      has_variadics (other.has_variadics), variadic_outer_attrs (other.variadic_outer_attrs)\n+      has_variadics (other.has_variadics),\n+      variadic_outer_attrs (other.variadic_outer_attrs)\n   {\n     // guard to prevent null pointer dereference\n     if (other.return_type != nullptr)\n@@ -3872,20 +4095,34 @@ class ExternalFunctionItem : public ExternalItem\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n-  std::vector<NamedFunctionParam> &get_function_params () { return function_params; }\n-  const std::vector<NamedFunctionParam> &get_function_params () const { return function_params; }\n+  std::vector<NamedFunctionParam> &get_function_params ()\n+  {\n+    return function_params;\n+  }\n+  const std::vector<NamedFunctionParam> &get_function_params () const\n+  {\n+    return function_params;\n+  }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params () { return generic_params; }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const { return generic_params; }\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause () {\n+  WhereClause &get_where_clause ()\n+  {\n     rust_assert (has_where_clause ());\n     return where_clause;\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_return_type () {\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n     rust_assert (has_return_type ());\n     return return_type;\n   }\n@@ -3909,10 +4146,10 @@ class ExternBlock : public VisItem\n   std::vector<Attribute> inner_attrs;\n \n   // bool has_extern_items;\n-  std::vector<std::unique_ptr<ExternalItem>> extern_items;\n+  std::vector<std::unique_ptr<ExternalItem> > extern_items;\n \n   Location locus;\n-  \n+\n   // TODO: find another way to store this to save memory?\n   bool marked_for_strip = false;\n \n@@ -3929,7 +4166,7 @@ class ExternBlock : public VisItem\n   bool has_abi () const { return !abi.empty (); }\n \n   ExternBlock (std::string abi,\n-\t       std::vector<std::unique_ptr<ExternalItem>> extern_items,\n+\t       std::vector<std::unique_ptr<ExternalItem> > extern_items,\n \t       Visibility vis, std::vector<Attribute> inner_attrs,\n \t       std::vector<Attribute> outer_attrs, Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)), abi (std::move (abi)),\n@@ -3976,12 +4213,18 @@ class ExternBlock : public VisItem\n   bool is_marked_for_strip () const override { return marked_for_strip; }\n \n   // TODO: think of better way to do this\n-  const std::vector<std::unique_ptr<ExternalItem>>& get_extern_items () const { return extern_items; }\n-  std::vector<std::unique_ptr<ExternalItem>>& get_extern_items () { return extern_items; }\n+  const std::vector<std::unique_ptr<ExternalItem> > &get_extern_items () const\n+  {\n+    return extern_items;\n+  }\n+  std::vector<std::unique_ptr<ExternalItem> > &get_extern_items ()\n+  {\n+    return extern_items;\n+  }\n \n   // TODO: think of better way to do this\n-  const std::vector<Attribute>& get_inner_attrs () const { return inner_attrs; }\n-  std::vector<Attribute>& get_inner_attrs () { return inner_attrs; }\n+  const std::vector<Attribute> &get_inner_attrs () const { return inner_attrs; }\n+  std::vector<Attribute> &get_inner_attrs () { return inner_attrs; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object"}, {"sha": "576039219b3a0ff6f624610ea21e12b6e8f5847e", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=53ddea7a266c43f30702b0c24ce05e4d5dad0ecc", "patch": "@@ -132,8 +132,7 @@ class MacroMatchRepetition : public MacroMatch\n   {}\n \n   // Copy constructor with clone\n-  MacroMatchRepetition (MacroMatchRepetition const &other)\n-    : op (other.op)\n+  MacroMatchRepetition (MacroMatchRepetition const &other) : op (other.op)\n   {\n     // guard to protect from null pointer dereference\n     if (other.sep != nullptr)\n@@ -291,7 +290,7 @@ class MacroRulesDefinition : public MacroItem\n {\n   std::vector<Attribute> outer_attrs;\n   Identifier rule_name;\n-  // MacroRulesDef rules_def; \n+  // MacroRulesDef rules_def;\n   // only curly without required semicolon at end\n   DelimType delim_type;\n   // MacroRules rules;\n@@ -363,7 +362,7 @@ class MacroInvocation : public TypeNoBounds,\n   {\n     return new MacroInvocation (*this);\n   }\n-  \n+\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n   MacroInvocation *clone_expr_without_block_impl () const override"}, {"sha": "392fc18fc6423f52ee9f1ae986c90a3658726308", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 64, "deletions": 37, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=53ddea7a266c43f30702b0c24ce05e4d5dad0ecc", "patch": "@@ -101,7 +101,8 @@ struct GenericArgsBinding\n   std::string as_string () const;\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  std::unique_ptr<Type> &get_type () {\n+  std::unique_ptr<Type> &get_type ()\n+  {\n     rust_assert (type != nullptr);\n     return type;\n   }\n@@ -111,7 +112,7 @@ struct GenericArgsBinding\n struct GenericArgs\n {\n   std::vector<Lifetime> lifetime_args;\n-  std::vector<std::unique_ptr<Type>> type_args;\n+  std::vector<std::unique_ptr<Type> > type_args;\n   std::vector<GenericArgsBinding> binding_args;\n   Location locus;\n \n@@ -124,7 +125,7 @@ struct GenericArgs\n   }\n \n   GenericArgs (std::vector<Lifetime> lifetime_args,\n-\t       std::vector<std::unique_ptr<Type>> type_args,\n+\t       std::vector<std::unique_ptr<Type> > type_args,\n \t       std::vector<GenericArgsBinding> binding_args,\n \t       Location locus = Location ())\n     : lifetime_args (std::move (lifetime_args)),\n@@ -166,21 +167,17 @@ struct GenericArgs\n   static GenericArgs create_empty ()\n   {\n     return GenericArgs (std::vector<Lifetime> (),\n-\t\t\tstd::vector<std::unique_ptr<Type>> (),\n+\t\t\tstd::vector<std::unique_ptr<Type> > (),\n \t\t\tstd::vector<GenericArgsBinding> ());\n   }\n \n   std::string as_string () const;\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  std::vector<std::unique_ptr<Type>> &get_type_args () {\n-    return type_args;\n-  }\n+  std::vector<std::unique_ptr<Type> > &get_type_args () { return type_args; }\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  std::vector<GenericArgsBinding> &get_binding_args () {\n-    return binding_args;\n-  }\n+  std::vector<GenericArgsBinding> &get_binding_args () { return binding_args; }\n };\n \n /* A segment of a path in expression, including an identifier aspect and maybe\n@@ -213,8 +210,8 @@ class PathExprSegment\n   PathExprSegment (std::string segment_name, Location locus,\n \t\t   std::vector<Lifetime> lifetime_args\n \t\t   = std::vector<Lifetime> (),\n-\t\t   std::vector<std::unique_ptr<Type>> type_args\n-\t\t   = std::vector<std::unique_ptr<Type>> (),\n+\t\t   std::vector<std::unique_ptr<Type> > type_args\n+\t\t   = std::vector<std::unique_ptr<Type> > (),\n \t\t   std::vector<GenericArgsBinding> binding_args\n \t\t   = std::vector<GenericArgsBinding> ())\n     : segment_name (PathIdentSegment (std::move (segment_name))),\n@@ -238,7 +235,8 @@ class PathExprSegment\n   Location get_locus () const { return locus; }\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  GenericArgs &get_generic_args () {\n+  GenericArgs &get_generic_args ()\n+  {\n     rust_assert (has_generic_args ());\n     return generic_args;\n   }\n@@ -262,7 +260,11 @@ class PathPattern : public Pattern\n   SimplePath convert_to_simple_path (bool with_opening_scope_resolution) const;\n \n   // Removes all segments of the path.\n-  void remove_all_segments () { segments.clear (); segments.shrink_to_fit (); }\n+  void remove_all_segments ()\n+  {\n+    segments.clear ();\n+    segments.shrink_to_fit ();\n+  }\n \n public:\n   /* Returns whether the path is a single segment (excluding qualified path\n@@ -427,7 +429,7 @@ class TypePathSegmentGeneric : public TypePathSegment\n   TypePathSegmentGeneric (std::string segment_name,\n \t\t\t  bool has_separating_scope_resolution,\n \t\t\t  std::vector<Lifetime> lifetime_args,\n-\t\t\t  std::vector<std::unique_ptr<Type>> type_args,\n+\t\t\t  std::vector<std::unique_ptr<Type> > type_args,\n \t\t\t  std::vector<GenericArgsBinding> binding_args,\n \t\t\t  Location locus)\n     : TypePathSegment (std::move (segment_name),\n@@ -442,7 +444,8 @@ class TypePathSegmentGeneric : public TypePathSegment\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  GenericArgs &get_generic_args () {\n+  GenericArgs &get_generic_args ()\n+  {\n     rust_assert (has_generic_args ());\n     return generic_args;\n   }\n@@ -463,7 +466,7 @@ struct TypePathFunction\n   /*bool has_inputs;\n   TypePathFnInputs inputs;*/\n   // inlined from TypePathFnInputs\n-  std::vector<std::unique_ptr<Type>> inputs;\n+  std::vector<std::unique_ptr<Type> > inputs;\n \n   // bool has_type;\n   std::unique_ptr<Type> return_type;\n@@ -491,7 +494,7 @@ struct TypePathFunction\n   static TypePathFunction create_error () { return TypePathFunction (true); }\n \n   // Constructor\n-  TypePathFunction (std::vector<std::unique_ptr<Type>> inputs,\n+  TypePathFunction (std::vector<std::unique_ptr<Type> > inputs,\n \t\t    std::unique_ptr<Type> type = nullptr)\n     : inputs (std::move (inputs)), return_type (std::move (type)),\n       is_invalid (false)\n@@ -537,11 +540,15 @@ struct TypePathFunction\n   std::string as_string () const;\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n-  const std::vector<std::unique_ptr<Type>> &get_params () const { return inputs; }\n-  std::vector<std::unique_ptr<Type>> &get_params () { return inputs; }\n+  const std::vector<std::unique_ptr<Type> > &get_params () const\n+  {\n+    return inputs;\n+  }\n+  std::vector<std::unique_ptr<Type> > &get_params () { return inputs; }\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  std::unique_ptr<Type> &get_return_type () {\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n     rust_assert (has_return_type ());\n     return return_type;\n   }\n@@ -578,7 +585,8 @@ class TypePathSegmentFunction : public TypePathSegment\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  TypePathFunction &get_type_path_function () {\n+  TypePathFunction &get_type_path_function ()\n+  {\n     rust_assert (!function_path.is_error ());\n     return function_path;\n   }\n@@ -595,7 +603,7 @@ class TypePathSegmentFunction : public TypePathSegment\n class TypePath : public TypeNoBounds\n {\n   bool has_opening_scope_resolution;\n-  std::vector<std::unique_ptr<TypePathSegment>> segments;\n+  std::vector<std::unique_ptr<TypePathSegment> > segments;\n   Location locus;\n \n protected:\n@@ -620,12 +628,12 @@ class TypePath : public TypeNoBounds\n   // Creates an error state TypePath.\n   static TypePath create_error ()\n   {\n-    return TypePath (std::vector<std::unique_ptr<TypePathSegment>> (),\n+    return TypePath (std::vector<std::unique_ptr<TypePathSegment> > (),\n \t\t     Location ());\n   }\n \n   // Constructor\n-  TypePath (std::vector<std::unique_ptr<TypePathSegment>> segments,\n+  TypePath (std::vector<std::unique_ptr<TypePathSegment> > segments,\n \t    Location locus, bool has_opening_scope_resolution = false)\n     : has_opening_scope_resolution (has_opening_scope_resolution),\n       segments (std::move (segments)), locus (locus)\n@@ -673,8 +681,14 @@ class TypePath : public TypeNoBounds\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: this seems kinda dodgy\n-  std::vector<std::unique_ptr<TypePathSegment>> &get_segments () { return segments; }\n-  const std::vector<std::unique_ptr<TypePathSegment>> &get_segments () const { return segments; }\n+  std::vector<std::unique_ptr<TypePathSegment> > &get_segments ()\n+  {\n+    return segments;\n+  }\n+  const std::vector<std::unique_ptr<TypePathSegment> > &get_segments () const\n+  {\n+    return segments;\n+  }\n };\n \n struct QualifiedPathType\n@@ -744,13 +758,15 @@ struct QualifiedPathType\n   Location get_locus () const { return locus; }\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  std::unique_ptr<Type> &get_type () {\n+  std::unique_ptr<Type> &get_type ()\n+  {\n     rust_assert (type_to_invoke_on != nullptr);\n     return type_to_invoke_on;\n   }\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  TypePath &get_as_type_path () {\n+  TypePath &get_as_type_path ()\n+  {\n     rust_assert (has_as_clause ());\n     return trait_path;\n   }\n@@ -795,11 +811,15 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Invalid if path_type is error, so base stripping on that.\n-  void mark_for_strip () override { path_type = QualifiedPathType::create_error (); }\n+  void mark_for_strip () override\n+  {\n+    path_type = QualifiedPathType::create_error ();\n+  }\n   bool is_marked_for_strip () const override { return is_error (); }\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  QualifiedPathType &get_qualified_path_type () {\n+  QualifiedPathType &get_qualified_path_type ()\n+  {\n     rust_assert (!path_type.is_error ());\n     return path_type;\n   }\n@@ -825,7 +845,7 @@ class QualifiedPathInExpression : public PathPattern, public PathExpr\n class QualifiedPathInType : public TypeNoBounds\n {\n   QualifiedPathType path_type;\n-  std::vector<std::unique_ptr<TypePathSegment>> segments;\n+  std::vector<std::unique_ptr<TypePathSegment> > segments;\n   Location locus;\n \n protected:\n@@ -839,7 +859,7 @@ class QualifiedPathInType : public TypeNoBounds\n public:\n   QualifiedPathInType (\n     QualifiedPathType qual_path_type,\n-    std::vector<std::unique_ptr<TypePathSegment>> path_segments,\n+    std::vector<std::unique_ptr<TypePathSegment> > path_segments,\n     Location locus = Location ())\n     : path_type (std::move (qual_path_type)),\n       segments (std::move (path_segments)), locus (locus)\n@@ -882,22 +902,29 @@ class QualifiedPathInType : public TypeNoBounds\n   {\n     return QualifiedPathInType (\n       QualifiedPathType::create_error (),\n-      std::vector<std::unique_ptr<TypePathSegment>> ());\n+      std::vector<std::unique_ptr<TypePathSegment> > ());\n   }\n \n   std::string as_string () const override;\n \n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  QualifiedPathType &get_qualified_path_type () {\n+  QualifiedPathType &get_qualified_path_type ()\n+  {\n     rust_assert (!path_type.is_error ());\n     return path_type;\n   }\n \n   // TODO: this seems kinda dodgy\n-  std::vector<std::unique_ptr<TypePathSegment>> &get_segments () { return segments; }\n-  const std::vector<std::unique_ptr<TypePathSegment>> &get_segments () const { return segments; }\n+  std::vector<std::unique_ptr<TypePathSegment> > &get_segments ()\n+  {\n+    return segments;\n+  }\n+  const std::vector<std::unique_ptr<TypePathSegment> > &get_segments () const\n+  {\n+    return segments;\n+  }\n \n   Location get_locus () const { return locus; }\n   Location get_locus_slow () const final override { return get_locus (); }"}, {"sha": "3a87a835906ce757be827b8dfd0583b19610939e", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 126, "deletions": 65, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=53ddea7a266c43f30702b0c24ce05e4d5dad0ecc", "patch": "@@ -94,7 +94,7 @@ class IdentifierPattern : public Pattern\n     // fix to prevent null pointer dereference\n     if (other.to_bind != nullptr)\n       to_bind = other.to_bind->clone_pattern ();\n-    else \n+    else\n       to_bind = nullptr;\n \n     return *this;\n@@ -110,12 +110,13 @@ class IdentifierPattern : public Pattern\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  std::unique_ptr<Pattern> &get_pattern_to_bind () {\n+  std::unique_ptr<Pattern> &get_pattern_to_bind ()\n+  {\n     rust_assert (has_pattern_to_bind ());\n     return to_bind;\n   }\n \n-  Identifier get_ident() const { return variable_ident; }\n+  Identifier get_ident () const { return variable_ident; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -319,12 +320,14 @@ class RangePattern : public Pattern\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? or is a \"vis_bound\" better?\n-  std::unique_ptr<RangePatternBound>& get_lower_bound () {\n+  std::unique_ptr<RangePatternBound> &get_lower_bound ()\n+  {\n     rust_assert (lower != nullptr);\n     return lower;\n   }\n \n-  std::unique_ptr<RangePatternBound>& get_upper_bound () {\n+  std::unique_ptr<RangePatternBound> &get_upper_bound ()\n+  {\n     rust_assert (upper != nullptr);\n     return upper;\n   }\n@@ -382,7 +385,8 @@ class ReferencePattern : public Pattern\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  std::unique_ptr<Pattern> &get_referenced_pattern () {\n+  std::unique_ptr<Pattern> &get_referenced_pattern ()\n+  {\n     rust_assert (pattern != nullptr);\n     return pattern;\n   }\n@@ -508,10 +512,14 @@ class StructPatternFieldTuplePat : public StructPatternField\n \n   // based on idea of tuple pattern no longer existing\n   void mark_for_strip () override { tuple_pattern = nullptr; }\n-  bool is_marked_for_strip () const override { return tuple_pattern == nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return tuple_pattern == nullptr;\n+  }\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  std::unique_ptr<Pattern> &get_index_pattern () {\n+  std::unique_ptr<Pattern> &get_index_pattern ()\n+  {\n     rust_assert (tuple_pattern != nullptr);\n     return tuple_pattern;\n   }\n@@ -577,10 +585,14 @@ class StructPatternFieldIdentPat : public StructPatternField\n \n   // based on idea of identifier pattern no longer existing\n   void mark_for_strip () override { ident_pattern = nullptr; }\n-  bool is_marked_for_strip () const override { return ident_pattern == nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return ident_pattern == nullptr;\n+  }\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  std::unique_ptr<Pattern> &get_ident_pattern () {\n+  std::unique_ptr<Pattern> &get_ident_pattern ()\n+  {\n     rust_assert (ident_pattern != nullptr);\n     return ident_pattern;\n   }\n@@ -630,11 +642,11 @@ struct StructPatternElements\n {\n private:\n   // bool has_struct_pattern_fields;\n-  std::vector<std::unique_ptr<StructPatternField>> fields;\n+  std::vector<std::unique_ptr<StructPatternField> > fields;\n \n   bool has_struct_pattern_etc;\n   std::vector<Attribute> struct_pattern_etc_attrs;\n-  //StructPatternEtc etc;\n+  // StructPatternEtc etc;\n \n   // must have at least one of the two and maybe both\n \n@@ -655,22 +667,23 @@ struct StructPatternElements\n \n   // Constructor for StructPatternElements with both (potentially)\n   StructPatternElements (\n-    std::vector<std::unique_ptr<StructPatternField>> fields,\n+    std::vector<std::unique_ptr<StructPatternField> > fields,\n     std::vector<Attribute> etc_attrs)\n     : fields (std::move (fields)), has_struct_pattern_etc (true),\n       struct_pattern_etc_attrs (std::move (etc_attrs))\n   {}\n \n   // Constructor for StructPatternElements with no StructPatternEtc\n   StructPatternElements (\n-    std::vector<std::unique_ptr<StructPatternField>> fields)\n+    std::vector<std::unique_ptr<StructPatternField> > fields)\n     : fields (std::move (fields)), has_struct_pattern_etc (false),\n       struct_pattern_etc_attrs ()\n   {}\n \n   // Copy constructor with vector clone\n   StructPatternElements (StructPatternElements const &other)\n-    : has_struct_pattern_etc (other.has_struct_pattern_etc), struct_pattern_etc_attrs (other.struct_pattern_etc_attrs)\n+    : has_struct_pattern_etc (other.has_struct_pattern_etc),\n+      struct_pattern_etc_attrs (other.struct_pattern_etc_attrs)\n   {\n     fields.reserve (other.fields.size ());\n     for (const auto &e : other.fields)\n@@ -698,21 +711,35 @@ struct StructPatternElements\n   static StructPatternElements create_empty ()\n   {\n     return StructPatternElements (\n-      std::vector<std::unique_ptr<StructPatternField>> ());\n+      std::vector<std::unique_ptr<StructPatternField> > ());\n   }\n \n   std::string as_string () const;\n \n   // TODO: seems kinda dodgy. Think of better way.\n-  std::vector<std::unique_ptr<StructPatternField>> &get_struct_pattern_fields () { return fields; }\n-  const std::vector<std::unique_ptr<StructPatternField>> &get_struct_pattern_fields () const { return fields; }\n+  std::vector<std::unique_ptr<StructPatternField> > &\n+  get_struct_pattern_fields ()\n+  {\n+    return fields;\n+  }\n+  const std::vector<std::unique_ptr<StructPatternField> > &\n+  get_struct_pattern_fields () const\n+  {\n+    return fields;\n+  }\n \n-  std::vector<Attribute> &get_etc_outer_attrs () { return struct_pattern_etc_attrs; }\n-  const std::vector<Attribute> &get_etc_outer_attrs () const { return struct_pattern_etc_attrs; }\n+  std::vector<Attribute> &get_etc_outer_attrs ()\n+  {\n+    return struct_pattern_etc_attrs;\n+  }\n+  const std::vector<Attribute> &get_etc_outer_attrs () const\n+  {\n+    return struct_pattern_etc_attrs;\n+  }\n \n-  void strip_etc () \n-  { \n-    has_struct_pattern_etc = false; \n+  void strip_etc ()\n+  {\n+    has_struct_pattern_etc = false;\n     struct_pattern_etc_attrs.clear ();\n     struct_pattern_etc_attrs.shrink_to_fit ();\n   }\n@@ -752,7 +779,10 @@ class StructPattern : public Pattern\n \n   // TODO: seems kinda dodgy. Think of better way.\n   StructPatternElements &get_struct_pattern_elems () { return elems; }\n-  const StructPatternElements &get_struct_pattern_elems () const { return elems; }\n+  const StructPatternElements &get_struct_pattern_elems () const\n+  {\n+    return elems;\n+  }\n \n   PathInExpression &get_path () { return path; }\n   const PathInExpression &get_path () const { return path; }\n@@ -792,10 +822,10 @@ class TupleStructItems\n // Class for non-ranged tuple struct pattern patterns\n class TupleStructItemsNoRange : public TupleStructItems\n {\n-  std::vector<std::unique_ptr<Pattern>> patterns;\n+  std::vector<std::unique_ptr<Pattern> > patterns;\n \n public:\n-  TupleStructItemsNoRange (std::vector<std::unique_ptr<Pattern>> patterns)\n+  TupleStructItemsNoRange (std::vector<std::unique_ptr<Pattern> > patterns)\n     : patterns (std::move (patterns))\n   {}\n \n@@ -827,8 +857,11 @@ class TupleStructItemsNoRange : public TupleStructItems\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: seems kinda dodgy. Think of better way.\n-  std::vector<std::unique_ptr<Pattern>> &get_patterns () { return patterns; }\n-  const std::vector<std::unique_ptr<Pattern>> &get_patterns () const { return patterns; }\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return patterns; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const\n+  {\n+    return patterns;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -842,12 +875,12 @@ class TupleStructItemsNoRange : public TupleStructItems\n // Class for ranged tuple struct pattern patterns\n class TupleStructItemsRange : public TupleStructItems\n {\n-  std::vector<std::unique_ptr<Pattern>> lower_patterns;\n-  std::vector<std::unique_ptr<Pattern>> upper_patterns;\n+  std::vector<std::unique_ptr<Pattern> > lower_patterns;\n+  std::vector<std::unique_ptr<Pattern> > upper_patterns;\n \n public:\n-  TupleStructItemsRange (std::vector<std::unique_ptr<Pattern>> lower_patterns,\n-\t\t\t std::vector<std::unique_ptr<Pattern>> upper_patterns)\n+  TupleStructItemsRange (std::vector<std::unique_ptr<Pattern> > lower_patterns,\n+\t\t\t std::vector<std::unique_ptr<Pattern> > upper_patterns)\n     : lower_patterns (std::move (lower_patterns)),\n       upper_patterns (std::move (upper_patterns))\n   {}\n@@ -887,12 +920,24 @@ class TupleStructItemsRange : public TupleStructItems\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: seems kinda dodgy. Think of better way.\n-  std::vector<std::unique_ptr<Pattern>> &get_lower_patterns () { return lower_patterns; }\n-  const std::vector<std::unique_ptr<Pattern>> &get_lower_patterns () const { return lower_patterns; }\n+  std::vector<std::unique_ptr<Pattern> > &get_lower_patterns ()\n+  {\n+    return lower_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_lower_patterns () const\n+  {\n+    return lower_patterns;\n+  }\n \n   // TODO: seems kinda dodgy. Think of better way.\n-  std::vector<std::unique_ptr<Pattern>> &get_upper_patterns () { return upper_patterns; }\n-  const std::vector<std::unique_ptr<Pattern>> &get_upper_patterns () const { return upper_patterns; }\n+  std::vector<std::unique_ptr<Pattern> > &get_upper_patterns ()\n+  {\n+    return upper_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_upper_patterns () const\n+  {\n+    return upper_patterns;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -924,8 +969,7 @@ class TupleStructPattern : public Pattern\n   {}\n \n   // Copy constructor required to clone\n-  TupleStructPattern (TupleStructPattern const &other)\n-    : path (other.path)\n+  TupleStructPattern (TupleStructPattern const &other) : path (other.path)\n   {\n     // guard to protect from null dereference\n     if (other.items != nullptr)\n@@ -956,10 +1000,10 @@ class TupleStructPattern : public Pattern\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: seems kinda dodgy. Think of better way.\n-  std::unique_ptr<TupleStructItems> &get_items () \n-  { \n+  std::unique_ptr<TupleStructItems> &get_items ()\n+  {\n     rust_assert (has_items ());\n-    return items; \n+    return items;\n   }\n \n   PathInExpression &get_path () { return path; }\n@@ -1036,10 +1080,10 @@ TuplePatternItemsSingle(*this);\n // Class representing TuplePattern patterns where there are multiple patterns\n class TuplePatternItemsMultiple : public TuplePatternItems\n {\n-  std::vector<std::unique_ptr<Pattern>> patterns;\n+  std::vector<std::unique_ptr<Pattern> > patterns;\n \n public:\n-  TuplePatternItemsMultiple (std::vector<std::unique_ptr<Pattern>> patterns)\n+  TuplePatternItemsMultiple (std::vector<std::unique_ptr<Pattern> > patterns)\n     : patterns (std::move (patterns))\n   {}\n \n@@ -1071,8 +1115,11 @@ class TuplePatternItemsMultiple : public TuplePatternItems\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: seems kinda dodgy. Think of better way.\n-  std::vector<std::unique_ptr<Pattern>> &get_patterns () { return patterns; }\n-  const std::vector<std::unique_ptr<Pattern>> &get_patterns () const { return patterns; }\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return patterns; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const\n+  {\n+    return patterns;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -1086,13 +1133,13 @@ class TuplePatternItemsMultiple : public TuplePatternItems\n // Class representing TuplePattern patterns where there are a range of patterns\n class TuplePatternItemsRanged : public TuplePatternItems\n {\n-  std::vector<std::unique_ptr<Pattern>> lower_patterns;\n-  std::vector<std::unique_ptr<Pattern>> upper_patterns;\n+  std::vector<std::unique_ptr<Pattern> > lower_patterns;\n+  std::vector<std::unique_ptr<Pattern> > upper_patterns;\n \n public:\n   TuplePatternItemsRanged (\n-    std::vector<std::unique_ptr<Pattern>> lower_patterns,\n-    std::vector<std::unique_ptr<Pattern>> upper_patterns)\n+    std::vector<std::unique_ptr<Pattern> > lower_patterns,\n+    std::vector<std::unique_ptr<Pattern> > upper_patterns)\n     : lower_patterns (std::move (lower_patterns)),\n       upper_patterns (std::move (upper_patterns))\n   {}\n@@ -1133,12 +1180,24 @@ class TuplePatternItemsRanged : public TuplePatternItems\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: seems kinda dodgy. Think of better way.\n-  std::vector<std::unique_ptr<Pattern>> &get_lower_patterns () { return lower_patterns; }\n-  const std::vector<std::unique_ptr<Pattern>> &get_lower_patterns () const { return lower_patterns; }\n+  std::vector<std::unique_ptr<Pattern> > &get_lower_patterns ()\n+  {\n+    return lower_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_lower_patterns () const\n+  {\n+    return lower_patterns;\n+  }\n \n   // TODO: seems kinda dodgy. Think of better way.\n-  std::vector<std::unique_ptr<Pattern>> &get_upper_patterns () { return upper_patterns; }\n-  const std::vector<std::unique_ptr<Pattern>> &get_upper_patterns () const { return upper_patterns; }\n+  std::vector<std::unique_ptr<Pattern> > &get_upper_patterns ()\n+  {\n+    return upper_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_upper_patterns () const\n+  {\n+    return upper_patterns;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -1167,8 +1226,7 @@ class TuplePattern : public Pattern\n   {}\n \n   // Copy constructor requires clone\n-  TuplePattern (TuplePattern const &other)\n-    : locus (other.locus)\n+  TuplePattern (TuplePattern const &other) : locus (other.locus)\n   {\n     // guard to prevent null dereference\n     if (other.items != nullptr)\n@@ -1195,10 +1253,10 @@ class TuplePattern : public Pattern\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: seems kinda dodgy. Think of better way.\n-  std::unique_ptr<TuplePatternItems> &get_items () \n-  { \n+  std::unique_ptr<TuplePatternItems> &get_items ()\n+  {\n     rust_assert (has_tuple_pattern_items ());\n-    return items; \n+    return items;\n   }\n \n protected:\n@@ -1251,10 +1309,10 @@ class GroupedPattern : public Pattern\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: seems kinda dodgy. Think of better way.\n-  std::unique_ptr<Pattern> &get_pattern_in_parens () \n-  { \n+  std::unique_ptr<Pattern> &get_pattern_in_parens ()\n+  {\n     rust_assert (pattern_in_parens != nullptr);\n-    return pattern_in_parens; \n+    return pattern_in_parens;\n   }\n \n protected:\n@@ -1269,13 +1327,13 @@ class GroupedPattern : public Pattern\n // AST node representing patterns that can match slices and arrays\n class SlicePattern : public Pattern\n {\n-  std::vector<std::unique_ptr<Pattern>> items;\n+  std::vector<std::unique_ptr<Pattern> > items;\n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n-  SlicePattern (std::vector<std::unique_ptr<Pattern>> items, Location locus)\n+  SlicePattern (std::vector<std::unique_ptr<Pattern> > items, Location locus)\n     : items (std::move (items)), locus (locus)\n   {}\n \n@@ -1309,8 +1367,11 @@ class SlicePattern : public Pattern\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: seems kinda dodgy. Think of better way.\n-  std::vector<std::unique_ptr<Pattern>> &get_items () { return items; }\n-  const std::vector<std::unique_ptr<Pattern>> &get_items () const { return items; }\n+  std::vector<std::unique_ptr<Pattern> > &get_items () { return items; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_items () const\n+  {\n+    return items;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather"}, {"sha": "faea905d0552b610644fe79df5ede73a3fdab6d2", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=53ddea7a266c43f30702b0c24ce05e4d5dad0ecc", "patch": "@@ -80,7 +80,7 @@ class LetStmt : public Stmt\n     // guard to prevent null dereference (only required if error state)\n     if (other.variables_pattern != nullptr)\n       variables_pattern = other.variables_pattern->clone_pattern ();\n-    \n+\n     // guard to prevent null dereference (always required)\n     if (other.init_expr != nullptr)\n       init_expr = other.init_expr->clone_expr ();\n@@ -99,7 +99,7 @@ class LetStmt : public Stmt\n       variables_pattern = other.variables_pattern->clone_pattern ();\n     else\n       variables_pattern = nullptr;\n-    \n+\n     // guard to prevent null dereference (always required)\n     if (other.init_expr != nullptr)\n       init_expr = other.init_expr->clone_expr ();\n@@ -123,24 +123,30 @@ class LetStmt : public Stmt\n \n   // Invalid if pattern is null, so base stripping on that.\n   void mark_for_strip () override { variables_pattern = nullptr; }\n-  bool is_marked_for_strip () const override { return variables_pattern == nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return variables_pattern == nullptr;\n+  }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Expr> &get_init_expr () {\n+  std::unique_ptr<Expr> &get_init_expr ()\n+  {\n     rust_assert (has_init_expr ());\n     return init_expr;\n   }\n \n-  std::unique_ptr<Pattern> &get_pattern () {\n+  std::unique_ptr<Pattern> &get_pattern ()\n+  {\n     rust_assert (variables_pattern != nullptr);\n     return variables_pattern;\n   }\n \n-  std::unique_ptr<Type> &get_type () {\n+  std::unique_ptr<Type> &get_type ()\n+  {\n     rust_assert (has_type ());\n     return type;\n   }\n@@ -188,8 +194,7 @@ class ExprStmtWithoutBlock : public ExprStmt\n   {}*/\n \n   // Copy constructor with clone\n-  ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other)\n-    : ExprStmt (other)\n+  ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other) : ExprStmt (other)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.expr != nullptr)\n@@ -203,7 +208,7 @@ class ExprStmtWithoutBlock : public ExprStmt\n   ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock const &other)\n   {\n     ExprStmt::operator= (other);\n-    //expr = other.expr->clone_expr ();\n+    // expr = other.expr->clone_expr ();\n \n     // guard to prevent null dereference (only required if error state)\n     if (other.expr != nullptr)\n@@ -225,7 +230,8 @@ class ExprStmtWithoutBlock : public ExprStmt\n   bool is_marked_for_strip () const override { return expr == nullptr; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<ExprWithoutBlock> &get_expr () {\n+  std::unique_ptr<ExprWithoutBlock> &get_expr ()\n+  {\n     rust_assert (expr != nullptr);\n     return expr;\n   }\n@@ -254,8 +260,7 @@ class ExprStmtWithBlock : public ExprStmt\n   {}\n \n   // Copy constructor with clone\n-  ExprStmtWithBlock (ExprStmtWithBlock const &other)\n-    : ExprStmt (other)\n+  ExprStmtWithBlock (ExprStmtWithBlock const &other) : ExprStmt (other)\n   {\n     // guard to prevent null dereference (only required if error state)\n     if (other.expr != nullptr)\n@@ -266,7 +271,7 @@ class ExprStmtWithBlock : public ExprStmt\n   ExprStmtWithBlock &operator= (ExprStmtWithBlock const &other)\n   {\n     ExprStmt::operator= (other);\n-    \n+\n     // guard to prevent null dereference (only required if error state)\n     if (other.expr != nullptr)\n       expr = other.expr->clone_expr_with_block ();\n@@ -287,7 +292,8 @@ class ExprStmtWithBlock : public ExprStmt\n   bool is_marked_for_strip () const override { return expr == nullptr; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<ExprWithBlock> &get_expr () {\n+  std::unique_ptr<ExprWithBlock> &get_expr ()\n+  {\n     rust_assert (expr != nullptr);\n     return expr;\n   }"}, {"sha": "8c175d340434c6deb8fe92f1f07a0b885497641b", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 69, "deletions": 33, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=53ddea7a266c43f30702b0c24ce05e4d5dad0ecc", "patch": "@@ -115,8 +115,15 @@ class ImplTraitType : public Type\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: mutable getter seems kinda dodgy\n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () { return type_param_bounds; }\n-  const std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () const { return type_param_bounds; }\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n };\n \n // An opaque value of another type that implements a set of traits\n@@ -178,8 +185,15 @@ class TraitObjectType : public Type\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: mutable getter seems kinda dodgy\n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () { return type_param_bounds; }\n-  const std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () const { return type_param_bounds; }\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n };\n \n // A type with parentheses around it, used to avoid ambiguity.\n@@ -240,9 +254,10 @@ class ParenthesisedType : public TypeNoBounds\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: would a \"vis_type\" be better?\n-  std::unique_ptr<Type> &get_type_in_parens () { \n+  std::unique_ptr<Type> &get_type_in_parens ()\n+  {\n     rust_assert (type_in_parens != nullptr);\n-    return type_in_parens; \n+    return type_in_parens;\n   }\n };\n \n@@ -273,9 +288,10 @@ class ImplTraitTypeOneBound : public TypeNoBounds\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: would a \"vis_type\" be better?\n-  TraitBound &get_trait_bound () { \n+  TraitBound &get_trait_bound ()\n+  {\n     // TODO: check to ensure invariants are met?\n-    return trait_bound; \n+    return trait_bound;\n   }\n };\n \n@@ -318,9 +334,10 @@ class TraitObjectTypeOneBound : public TypeNoBounds\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: would a \"vis_type\" be better?\n-  TraitBound &get_trait_bound () { \n+  TraitBound &get_trait_bound ()\n+  {\n     // TODO: check to ensure invariants are met?\n-    return trait_bound; \n+    return trait_bound;\n   }\n };\n \n@@ -374,7 +391,10 @@ class TupleType : public TypeNoBounds\n \n   // TODO: mutable getter seems kinda dodgy\n   std::vector<std::unique_ptr<Type> > &get_elems () { return elems; }\n-  const std::vector<std::unique_ptr<Type> > &get_elems () const { return elems; }\n+  const std::vector<std::unique_ptr<Type> > &get_elems () const\n+  {\n+    return elems;\n+  }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -464,9 +484,10 @@ class RawPointerType : public TypeNoBounds\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: would a \"vis_type\" be better?\n-  std::unique_ptr<TypeNoBounds> &get_type_pointed_to () { \n+  std::unique_ptr<TypeNoBounds> &get_type_pointed_to ()\n+  {\n     rust_assert (type != nullptr);\n-    return type; \n+    return type;\n   }\n \n protected:\n@@ -531,9 +552,10 @@ class ReferenceType : public TypeNoBounds\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: would a \"vis_type\" be better?\n-  std::unique_ptr<TypeNoBounds> &get_type_referenced () { \n+  std::unique_ptr<TypeNoBounds> &get_type_referenced ()\n+  {\n     rust_assert (type != nullptr);\n-    return type; \n+    return type;\n   }\n \n protected:\n@@ -586,15 +608,17 @@ class ArrayType : public TypeNoBounds\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: would a \"vis_type\" be better?\n-  std::unique_ptr<Type> &get_elem_type () { \n+  std::unique_ptr<Type> &get_elem_type ()\n+  {\n     rust_assert (elem_type != nullptr);\n-    return elem_type; \n+    return elem_type;\n   }\n \n   // TODO: would a \"vis_expr\" be better?\n-  std::unique_ptr<Expr> &get_size_expr () { \n+  std::unique_ptr<Expr> &get_size_expr ()\n+  {\n     rust_assert (size != nullptr);\n-    return size; \n+    return size;\n   }\n \n protected:\n@@ -645,9 +669,10 @@ class SliceType : public TypeNoBounds\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: would a \"vis_type\" be better?\n-  std::unique_ptr<Type> &get_elem_type () { \n+  std::unique_ptr<Type> &get_elem_type ()\n+  {\n     rust_assert (elem_type != nullptr);\n-    return elem_type; \n+    return elem_type;\n   }\n \n protected:\n@@ -710,14 +735,17 @@ struct MaybeNamedParam\n \n public:\n   MaybeNamedParam (Identifier name, ParamKind param_kind,\n-\t\t   std::unique_ptr<Type> param_type, std::vector<Attribute> outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)), param_type (std::move (param_type)), param_kind (param_kind),\n+\t\t   std::unique_ptr<Type> param_type,\n+\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)),\n+      param_type (std::move (param_type)), param_kind (param_kind),\n       name (std::move (name)), locus (locus)\n   {}\n \n   // Copy constructor with clone\n   MaybeNamedParam (MaybeNamedParam const &other)\n-    : outer_attrs (other.outer_attrs), param_kind (other.param_kind), name (other.name), locus (other.locus)\n+    : outer_attrs (other.outer_attrs), param_kind (other.param_kind),\n+      name (other.name), locus (other.locus)\n   {\n     // guard to prevent null dereference\n     if (other.param_type != nullptr)\n@@ -765,9 +793,10 @@ struct MaybeNamedParam\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n \n   // TODO: would a \"vis_type\" be better?\n-  std::unique_ptr<Type> &get_type () { \n+  std::unique_ptr<Type> &get_type ()\n+  {\n     rust_assert (param_type != nullptr);\n-    return param_type; \n+    return param_type;\n   }\n };\n \n@@ -799,22 +828,25 @@ class BareFunctionType : public TypeNoBounds\n \n   BareFunctionType (std::vector<LifetimeParam> lifetime_params,\n \t\t    FunctionQualifiers qualifiers,\n-\t\t    std::vector<MaybeNamedParam> named_params, bool is_variadic, std::vector<Attribute> variadic_attrs,\n+\t\t    std::vector<MaybeNamedParam> named_params, bool is_variadic,\n+\t\t    std::vector<Attribute> variadic_attrs,\n \t\t    std::unique_ptr<TypeNoBounds> type, Location locus)\n     : for_lifetimes (std::move (lifetime_params)),\n       function_qualifiers (std::move (qualifiers)),\n       params (std::move (named_params)), is_variadic (is_variadic),\n-      variadic_attrs (std::move (variadic_attrs)), return_type (std::move (type)), locus (locus)\n+      variadic_attrs (std::move (variadic_attrs)),\n+      return_type (std::move (type)), locus (locus)\n   {\n-    if (!variadic_attrs.empty())\n+    if (!variadic_attrs.empty ())\n       is_variadic = true;\n   }\n \n   // Copy constructor with clone\n   BareFunctionType (BareFunctionType const &other)\n     : for_lifetimes (other.for_lifetimes),\n       function_qualifiers (other.function_qualifiers), params (other.params),\n-      is_variadic (other.is_variadic), variadic_attrs (other.variadic_attrs), locus (other.locus)\n+      is_variadic (other.is_variadic), variadic_attrs (other.variadic_attrs),\n+      locus (other.locus)\n   {\n     // guard to prevent null dereference\n     if (other.return_type != nullptr)\n@@ -853,12 +885,16 @@ class BareFunctionType : public TypeNoBounds\n \n   // TODO: this mutable getter seems kinda dodgy\n   std::vector<MaybeNamedParam> &get_function_params () { return params; }\n-  const std::vector<MaybeNamedParam> &get_function_params () const { return params; }\n+  const std::vector<MaybeNamedParam> &get_function_params () const\n+  {\n+    return params;\n+  }\n \n   // TODO: would a \"vis_type\" be better?\n-  std::unique_ptr<TypeNoBounds> &get_return_type () { \n+  std::unique_ptr<TypeNoBounds> &get_return_type ()\n+  {\n     rust_assert (has_return_type ());\n-    return return_type; \n+    return return_type;\n   }\n \n protected:"}, {"sha": "82941c72a549ca88972429199540697decbb51df", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 3378, "deletions": 2860, "changes": 6238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=53ddea7a266c43f30702b0c24ce05e4d5dad0ecc"}, {"sha": "c8c7f358643a204795ad009f48a953a3efb73ece", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=53ddea7a266c43f30702b0c24ce05e4d5dad0ecc", "patch": "@@ -27,7 +27,8 @@ struct MacroExpander\n   ExpansionCfg cfg;\n   unsigned int expansion_depth = 0;\n \n-  MacroExpander (AST::Crate &crate, ExpansionCfg cfg, Session &session) : cfg (cfg), crate (crate), session (session)\n+  MacroExpander (AST::Crate &crate, ExpansionCfg cfg, Session &session)\n+    : cfg (cfg), crate (crate), session (session)\n   {}\n \n   ~MacroExpander () = default;\n@@ -40,8 +41,8 @@ struct MacroExpander\n   // should this be public or private?\n   void expand_invoc (std::unique_ptr<AST::MacroInvocation> &invoc);\n \n-  void expand_cfg_attrs(std::vector<AST::Attribute>& attrs);\n-  bool fails_cfg(std::vector<AST::Attribute>& attr);\n+  void expand_cfg_attrs (std::vector<AST::Attribute> &attrs);\n+  bool fails_cfg (std::vector<AST::Attribute> &attr);\n \n   /* TODO: make it extend ASTVisitor so that individual items can be accessed\n    * properly? */"}, {"sha": "3e573a6aa4613e3e5f376581e0a63bb968cfaf6b", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53ddea7a266c43f30702b0c24ce05e4d5dad0ecc/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=53ddea7a266c43f30702b0c24ce05e4d5dad0ecc", "patch": "@@ -630,7 +630,8 @@ Session::injection (AST::Crate &crate)\n    * rustc also has a \"quote\" macro that is defined differently and is\n    * supposedly not stable so eh. */\n   /* TODO: actually implement injection of these macros. In particular, derive\n-   * macros, cfg, and test should be prioritised since they seem to be used the most. */\n+   * macros, cfg, and test should be prioritised since they seem to be used the\n+   * most. */\n \n   // crate injection\n   std::vector<std::string> names;"}]}