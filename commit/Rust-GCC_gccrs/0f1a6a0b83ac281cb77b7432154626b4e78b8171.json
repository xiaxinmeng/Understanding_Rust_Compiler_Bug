{"sha": "0f1a6a0b83ac281cb77b7432154626b4e78b8171", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYxYTZhMGI4M2FjMjgxY2I3N2I3NDMyMTU0NjI2YjRlNzhiODE3MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-11T10:34:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-11T10:34:53Z"}, "message": "[multiple changes]\n\n2010-10-11  Robert Dewar  <dewar@adacore.com>\n\n\t* aspects.ads, aspects.adb: Major revision of this package for 2nd\n\tstage of aspects implementation.\n\t* gcc-interface/Make-lang.in: Add entry for aspects.o\n\t* gcc-interface/Makefile.in: Add aspects.o to GNATMAKE_OBJS\n\t* par-ch13.adb (Aspect_Specifications_Present): New function\n\t(P_Aspect_Specifications): New procedure\n\t* par-ch3.adb (P_Type_Declaration): Handle aspect specifications\n\t(P_Derived_Type_Def_Or_Private_Ext_Decl): Handle aspect specifications\n\t(P_Identifier_Declarations): Handle aspect specifications\n\t(P_Component_Items): Handle aspect specifications\n\t(P_Subtype_Declaration): Handle aspect specifications\n\t* par-ch6.adb (P_Subprogram): Handle aspect specifications\n\t* par-ch9.adb (P_Entry_Declaration): Handle aspect specifications\n\t* par.adb (Aspect_Specifications_Present): New function\n\t(P_Aspect_Specifications): New procedure\n\t* sem.adb (Analyze_Full_Type_Declaration): New name for\n\tAnalyze_Type_Declaration.\n\t(Analyze_Formal_Package_Declaration): New name (add _Declaration)\n\t(Analyze_Formal_Subprogram_Declaration): New name (add _Declaration)\n\t(Analyze_Protected_Type_Declaration): New name (add _Declaration)\n\t(Analyze_Single_Protected_Declaration): New name (add _Declaration)\n\t(Analyze_Single_Task_Declaration): New name (add _Declaration)\n\t(Analyze_Task_Type_Declaration): New name (add _Declaration)\n\t* sem_cat.adb (Analyze_Full_Type_Declaration): New name for\n\tAnalyze_Type_Declaration.\n\t* sem_ch11.adb (Analyze_Exception_Declaration): Analyze aspect\n\tspecifications.\n\t* sem_ch12.adb (Analyze_Formal_Object_Declaration): Handle aspect\n\tspecifications.\n\t(Analyze_Formal_Package_Declaration): New name (add _Declaration)\n\t(Analyze_Formal_Package_Declaration): Handle aspect specifications\n\t(Analyze_Formal_Subprogram_Declaration): New name (add _Declaration)\n\t(Analyze_Formal_Subprogram_Declaration): Handle aspect specifications\n\t(Analyze_Formal_Type_Declaration): Handle aspect specifications\n\t(Analyze_Generic_Package_Declaration): Handle aspect specifications\n\t(Analyze_Generic_Subprogram_Declaration): Handle aspect specifications\n\t(Analyze_Package_Instantiation): Handle aspect specifications\n\t(Analyze_Subprogram_Instantiation): Handle aspect specifications\n\t* sem_ch12.ads (Analyze_Formal_Package_Declaration): New name (add\n\t_Declaration).\n\t(Analyze_Formal_Subprogram_Declaration): New name (add _Declaration)\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): New procedure\n\t(Duplicate_Clause): New function, calls to this function are added to\n\tprocessing for all aspects.\n\t* sem_ch13.ads (Analyze_Aspect_Specifications): New procedure\n\t* sem_ch3.adb (Analyze_Full_Type_Declaration): New name for\n\tAnalyze_Type_Declaration.\n\t* sem_ch3.ads (Analyze_Full_Type_Declaration): New name for\n\tAnalyze_Type_Declaration.\n\t* sem_ch6.adb (Analyze_Abstract_Subprogram_Declaration): Analyze aspect\n\tspecifications.\n\t(Analyze_Subprogram_Declaration): Analyze aspect specifications\n\t* sem_ch7.adb (Analyze_Package_Declaration): Analyze aspect\n\tspecifications.\n\t(Analyze_Private_Type_Declaration): Analyze aspect specifications\n\t* sem_ch9.adb (Analyze_Protected_Type_Declaration): Analyze aspect\n\tspecifications.\n\t(Analyze_Protected_Type_Declaration): New name (add _Declaration)\n\t(Analyze_Single_Protected_Declaration): Analyze aspect specifications\n\t(Analyze_Single_Protected_Declaration): New name (add _Declaration)\n\t(Analyze_Single_Task_Declaration): Analyze aspect specifications\n\t(Analyze_Single_Task_Declaration): New name (add _Declaration)\n\t(Analyze_Task_Type_Declaration): Analyze aspect specifications\n\t(Analyze_Task_Type_Declaration): New name (add _Declaration)\n\t* sem_ch9.ads (Analyze_Protected_Type_Declaration): New name (add\n\t_Declaration).\n\t(Analyze_Single_Protected_Declaration): New name (add _Declaration)\n\t(Analyze_Single_Task_Declaration): New name (add _Declaration)\n\t(Analyze_Task_Type_Declaration): New name (add _Declaration)\n\t* sem_prag.adb: Use Get_Pragma_Arg systematically so that we do not\n\thave to generate unnecessary pragma argument associations (this matches\n\tthe doc).\n\tThroughout do changes to accomodate aspect specifications, including\n\tspecializing messages, handling the case of not going through all\n\thomonyms, and allowing for cancellation.\n\t* sinfo.ads, sinfo.adb: Clean up obsolete documentation for Flag1,2,3\n\t(Aspect_Cancel): New flag\n\t(From_Aspect_Specification): New flag\n\t(First_Aspect): Removed flag\n\t(Last_Aspect): Removed flag\n\t* sprint.adb (Sprint_Aspect_Specifications): New procedure\n\t(Sprint_Node_Actual): Add calls to Sprint_Aspect_Specifications\n\n2010-10-11  Bob Duff  <duff@adacore.com>\n\n\t* sem_res.adb (Resolve_Actuals): Minor change to warning messages so\n\tthey match in Ada 95, 2005, and 2012 modes, in the case where the\n\tlanguage didn't change. Same thing for the run-time exception message.\n\n2010-10-11  Javier Miranda  <miranda@adacore.com>\n\n\t* debug.adb Document that switch -gnatd.p enables the CIL verifier.\n\n2010-10-11  Robert Dewar  <dewar@adacore.com>\n\n\t* s-htable.adb: Minor reformatting.\n\nFrom-SVN: r165299", "tree": {"sha": "b9165152a01271a67b69f898053fabda93f4ff3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9165152a01271a67b69f898053fabda93f4ff3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f1a6a0b83ac281cb77b7432154626b4e78b8171", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1a6a0b83ac281cb77b7432154626b4e78b8171", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f1a6a0b83ac281cb77b7432154626b4e78b8171", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f1a6a0b83ac281cb77b7432154626b4e78b8171/comments", "author": null, "committer": null, "parents": [{"sha": "1237d6ef3c2a5994c7d633b2de2b6db525c92d7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1237d6ef3c2a5994c7d633b2de2b6db525c92d7b"}], "stats": {"total": 8468, "additions": 4751, "deletions": 3717}, "files": [{"sha": "fe541b0506f9d28cb67e5f585227809516ce5fc8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -1,3 +1,102 @@\n+2010-10-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* aspects.ads, aspects.adb: Major revision of this package for 2nd\n+\tstage of aspects implementation.\n+\t* gcc-interface/Make-lang.in: Add entry for aspects.o\n+\t* gcc-interface/Makefile.in: Add aspects.o to GNATMAKE_OBJS\n+\t* par-ch13.adb (Aspect_Specifications_Present): New function\n+\t(P_Aspect_Specifications): New procedure\n+\t* par-ch3.adb (P_Type_Declaration): Handle aspect specifications\n+\t(P_Derived_Type_Def_Or_Private_Ext_Decl): Handle aspect specifications\n+\t(P_Identifier_Declarations): Handle aspect specifications\n+\t(P_Component_Items): Handle aspect specifications\n+\t(P_Subtype_Declaration): Handle aspect specifications\n+\t* par-ch6.adb (P_Subprogram): Handle aspect specifications\n+\t* par-ch9.adb (P_Entry_Declaration): Handle aspect specifications\n+\t* par.adb (Aspect_Specifications_Present): New function\n+\t(P_Aspect_Specifications): New procedure\n+\t* sem.adb (Analyze_Full_Type_Declaration): New name for\n+\tAnalyze_Type_Declaration.\n+\t(Analyze_Formal_Package_Declaration): New name (add _Declaration)\n+\t(Analyze_Formal_Subprogram_Declaration): New name (add _Declaration)\n+\t(Analyze_Protected_Type_Declaration): New name (add _Declaration)\n+\t(Analyze_Single_Protected_Declaration): New name (add _Declaration)\n+\t(Analyze_Single_Task_Declaration): New name (add _Declaration)\n+\t(Analyze_Task_Type_Declaration): New name (add _Declaration)\n+\t* sem_cat.adb (Analyze_Full_Type_Declaration): New name for\n+\tAnalyze_Type_Declaration.\n+\t* sem_ch11.adb (Analyze_Exception_Declaration): Analyze aspect\n+\tspecifications.\n+\t* sem_ch12.adb (Analyze_Formal_Object_Declaration): Handle aspect\n+\tspecifications.\n+\t(Analyze_Formal_Package_Declaration): New name (add _Declaration)\n+\t(Analyze_Formal_Package_Declaration): Handle aspect specifications\n+\t(Analyze_Formal_Subprogram_Declaration): New name (add _Declaration)\n+\t(Analyze_Formal_Subprogram_Declaration): Handle aspect specifications\n+\t(Analyze_Formal_Type_Declaration): Handle aspect specifications\n+\t(Analyze_Generic_Package_Declaration): Handle aspect specifications\n+\t(Analyze_Generic_Subprogram_Declaration): Handle aspect specifications\n+\t(Analyze_Package_Instantiation): Handle aspect specifications\n+\t(Analyze_Subprogram_Instantiation): Handle aspect specifications\n+\t* sem_ch12.ads (Analyze_Formal_Package_Declaration): New name (add\n+\t_Declaration).\n+\t(Analyze_Formal_Subprogram_Declaration): New name (add _Declaration)\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): New procedure\n+\t(Duplicate_Clause): New function, calls to this function are added to\n+\tprocessing for all aspects.\n+\t* sem_ch13.ads (Analyze_Aspect_Specifications): New procedure\n+\t* sem_ch3.adb (Analyze_Full_Type_Declaration): New name for\n+\tAnalyze_Type_Declaration.\n+\t* sem_ch3.ads (Analyze_Full_Type_Declaration): New name for\n+\tAnalyze_Type_Declaration.\n+\t* sem_ch6.adb (Analyze_Abstract_Subprogram_Declaration): Analyze aspect\n+\tspecifications.\n+\t(Analyze_Subprogram_Declaration): Analyze aspect specifications\n+\t* sem_ch7.adb (Analyze_Package_Declaration): Analyze aspect\n+\tspecifications.\n+\t(Analyze_Private_Type_Declaration): Analyze aspect specifications\n+\t* sem_ch9.adb (Analyze_Protected_Type_Declaration): Analyze aspect\n+\tspecifications.\n+\t(Analyze_Protected_Type_Declaration): New name (add _Declaration)\n+\t(Analyze_Single_Protected_Declaration): Analyze aspect specifications\n+\t(Analyze_Single_Protected_Declaration): New name (add _Declaration)\n+\t(Analyze_Single_Task_Declaration): Analyze aspect specifications\n+\t(Analyze_Single_Task_Declaration): New name (add _Declaration)\n+\t(Analyze_Task_Type_Declaration): Analyze aspect specifications\n+\t(Analyze_Task_Type_Declaration): New name (add _Declaration)\n+\t* sem_ch9.ads (Analyze_Protected_Type_Declaration): New name (add\n+\t_Declaration).\n+\t(Analyze_Single_Protected_Declaration): New name (add _Declaration)\n+\t(Analyze_Single_Task_Declaration): New name (add _Declaration)\n+\t(Analyze_Task_Type_Declaration): New name (add _Declaration)\n+\t* sem_prag.adb: Use Get_Pragma_Arg systematically so that we do not\n+\thave to generate unnecessary pragma argument associations (this matches\n+\tthe doc).\n+\tThroughout do changes to accomodate aspect specifications, including\n+\tspecializing messages, handling the case of not going through all\n+\thomonyms, and allowing for cancellation.\n+\t* sinfo.ads, sinfo.adb: Clean up obsolete documentation for Flag1,2,3\n+\t(Aspect_Cancel): New flag\n+\t(From_Aspect_Specification): New flag\n+\t(First_Aspect): Removed flag\n+\t(Last_Aspect): Removed flag\n+\t* sprint.adb (Sprint_Aspect_Specifications): New procedure\n+\t(Sprint_Node_Actual): Add calls to Sprint_Aspect_Specifications\n+\n+2010-10-11  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Actuals): Minor change to warning messages so\n+\tthey match in Ada 95, 2005, and 2012 modes, in the case where the\n+\tlanguage didn't change. Same thing for the run-time exception message.\n+\n+2010-10-11  Javier Miranda  <miranda@adacore.com>\n+\n+\t* debug.adb Document that switch -gnatd.p enables the CIL verifier.\n+\n+2010-10-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-htable.adb: Minor reformatting.\n+\n 2010-10-11  Javier Miranda  <miranda@adacore.com>\n \n \t* debug.adb: Update comment."}, {"sha": "4b08632c57f0cd9106610e75a2074418120782e3", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 126, "deletions": 14, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -29,10 +29,43 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Atree;  use Atree;\n+with Nlists; use Nlists;\n+with Sinfo;  use Sinfo;\n with Snames; use Snames;\n \n+with GNAT.HTable; use GNAT.HTable;\n+\n package body Aspects is\n \n+   ------------------------------------------\n+   -- Hash Table for Aspect Specifications --\n+   ------------------------------------------\n+\n+   type AS_Hash_Range is range 0 .. 510;\n+   --  Size of hash table headers\n+\n+   function AS_Hash (F : Node_Id) return AS_Hash_Range;\n+   --  Hash function for hash table\n+\n+   function AS_Hash (F : Node_Id) return AS_Hash_Range is\n+   begin\n+      return AS_Hash_Range (F mod 511);\n+   end AS_Hash;\n+\n+   package Aspect_Specifications_Hash_Table is new\n+     GNAT.HTable.Simple_HTable\n+       (Header_Num => AS_Hash_Range,\n+        Element    => List_Id,\n+        No_Element => No_List,\n+        Key        => Node_Id,\n+        Hash       => AS_Hash,\n+        Equal      => \"=\");\n+\n+   -----------------------------------------\n+   -- Table Linking Names and Aspect_Id's --\n+   -----------------------------------------\n+\n    type Aspect_Entry is record\n       Nam : Name_Id;\n       Asp : Aspect_Id;\n@@ -42,12 +75,10 @@ package body Aspects is\n      (Name_Ada_2005,                     Aspect_Ada_2005),\n      (Name_Ada_2012,                     Aspect_Ada_2012),\n      (Name_Address,                      Aspect_Address),\n-     (Name_Aliased,                      Aspect_Aliased),\n      (Name_Alignment,                    Aspect_Alignment),\n      (Name_Atomic,                       Aspect_Atomic),\n      (Name_Atomic_Components,            Aspect_Atomic_Components),\n      (Name_Bit_Order,                    Aspect_Bit_Order),\n-     (Name_C_Pass_By_Copy,               Aspect_C_Pass_By_Copy),\n      (Name_Component_Size,               Aspect_Component_Size),\n      (Name_Discard_Names,                Aspect_Discard_Names),\n      (Name_External_Tag,                 Aspect_External_Tag),\n@@ -60,12 +91,9 @@ package body Aspects is\n      (Name_Pack,                         Aspect_Pack),\n      (Name_Persistent_BSS,               Aspect_Persistent_BSS),\n      (Name_Post,                         Aspect_Post),\n-     (Name_Postcondition,                Aspect_Postcondition),\n      (Name_Pre,                          Aspect_Pre),\n-     (Name_Precondition,                 Aspect_Precondition),\n      (Name_Predicate,                    Aspect_Predicate),\n      (Name_Preelaborable_Initialization, Aspect_Preelaborable_Initialization),\n-     (Name_Psect_Object,                 Aspect_Psect_Object),\n      (Name_Pure_Function,                Aspect_Pure_Function),\n      (Name_Shared,                       Aspect_Shared),\n      (Name_Size,                         Aspect_Size),\n@@ -83,22 +111,106 @@ package body Aspects is\n      (Name_Value_Size,                   Aspect_Value_Size),\n      (Name_Volatile,                     Aspect_Volatile),\n      (Name_Volatile_Components,          Aspect_Volatile_Components),\n-     (Name_Warnings,                     Aspect_Warnings),\n-     (Name_Weak_External,                Aspect_Weak_External));\n+     (Name_Warnings,                     Aspect_Warnings));\n+\n+   -------------------------------------\n+   -- Hash Table for Aspect Id Values --\n+   -------------------------------------\n+\n+   type AI_Hash_Range is range 0 .. 112;\n+   --  Size of hash table headers\n+\n+   function AI_Hash (F : Name_Id) return AI_Hash_Range;\n+   --  Hash function for hash table\n+\n+   function AI_Hash (F : Name_Id) return AI_Hash_Range is\n+   begin\n+      return AI_Hash_Range (F mod 113);\n+   end AI_Hash;\n+\n+   package Aspect_Id_Hash_Table is new\n+     GNAT.HTable.Simple_HTable\n+       (Header_Num => AI_Hash_Range,\n+        Element    => Aspect_Id,\n+        No_Element => No_Aspect,\n+        Key        => Name_Id,\n+        Hash       => AI_Hash,\n+        Equal      => \"=\");\n \n    -------------------\n    -- Get_Aspect_Id --\n    -------------------\n \n    function Get_Aspect_Id (Name : Name_Id) return Aspect_Id is\n    begin\n-      for J in Aspect_Names'Range loop\n-         if Aspect_Names (J).Nam = Name then\n-            return Aspect_Names (J).Asp;\n-         end if;\n-      end loop;\n-\n-      return No_Aspect;\n+      return Aspect_Id_Hash_Table.Get (Name);\n    end Get_Aspect_Id;\n \n+   ---------------------------\n+   -- Aspect_Specifications --\n+   ---------------------------\n+\n+   function Aspect_Specifications (N : Node_Id) return List_Id is\n+   begin\n+      return Aspect_Specifications_Hash_Table.Get (N);\n+   end Aspect_Specifications;\n+\n+   -----------------------------------\n+   -- Permits_Aspect_Specifications --\n+   -----------------------------------\n+\n+   Has_Aspect_Specifications_Flag : constant array (Node_Kind) of Boolean :=\n+     (N_Abstract_Subprogram_Declaration        => True,\n+      N_Component_Declaration                  => True,\n+      N_Entry_Declaration                      => True,\n+      N_Exception_Declaration                  => True,\n+      N_Formal_Abstract_Subprogram_Declaration => True,\n+      N_Formal_Concrete_Subprogram_Declaration => True,\n+      N_Formal_Object_Declaration              => True,\n+      N_Formal_Package_Declaration             => True,\n+      N_Formal_Type_Declaration                => True,\n+      N_Full_Type_Declaration                  => True,\n+      N_Function_Instantiation                 => True,\n+      N_Generic_Package_Declaration            => True,\n+      N_Generic_Subprogram_Declaration         => True,\n+      N_Object_Declaration                     => True,\n+      N_Package_Declaration                    => True,\n+      N_Package_Instantiation                  => True,\n+      N_Private_Extension_Declaration          => True,\n+      N_Private_Type_Declaration               => True,\n+      N_Procedure_Instantiation                => True,\n+      N_Protected_Type_Declaration             => True,\n+      N_Single_Protected_Declaration           => True,\n+      N_Single_Task_Declaration                => True,\n+      N_Subprogram_Declaration                 => True,\n+      N_Subtype_Declaration                    => True,\n+      N_Task_Type_Declaration                  => True,\n+      others                                   => False);\n+\n+   function Permits_Aspect_Specifications (N : Node_Id) return Boolean is\n+   begin\n+      return Has_Aspect_Specifications_Flag (Nkind (N));\n+   end Permits_Aspect_Specifications;\n+\n+   -------------------------------\n+   -- Set_Aspect_Specifications --\n+   -------------------------------\n+\n+   procedure Set_Aspect_Specifications (N : Node_Id; L : List_Id) is\n+   begin\n+      pragma Assert (Permits_Aspect_Specifications (N));\n+      pragma Assert (not Has_Aspect_Specifications (N));\n+      pragma Assert (L /= No_List);\n+\n+      Set_Has_Aspect_Specifications (N);\n+      Set_Parent (L, N);\n+      Aspect_Specifications_Hash_Table.Set (N, L);\n+   end Set_Aspect_Specifications;\n+\n+--  Package initialization sets up Aspect Id hash table\n+\n+begin\n+   for J in Aspect_Names'Range loop\n+      Aspect_Id_Hash_Table.Set (Aspect_Names (J).Nam, Aspect_Names (J).Asp);\n+   end loop;\n end Aspects;"}, {"sha": "b8ee3888a20c34c7830069982803b54cf87b4835", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 54, "deletions": 21, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -29,25 +29,27 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package defines the aspects that are recognized in aspect\n---  specifications. We separate this off in its own packages to that\n---  it can be accessed by the parser without dragging in Sem_Asp\n+--  This package defines the aspects that are recognized by GNAT in aspect\n+--  specifications. It also contains the subprograms for storing/retrieving\n+--  aspect speciciations from the tree. The semantic processing for aspect\n+--  specifications is found in Sem_Ch13.Analyze_Aspect_Specifications.\n \n with Namet; use Namet;\n+with Types; use Types;\n \n package Aspects is\n \n+   --  Type defining recognized aspects\n+\n    type Aspect_Id is\n      (No_Aspect,                            -- Dummy entry for no aspect\n       Aspect_Ada_2005,                      -- GNAT\n       Aspect_Ada_2012,                      -- GNAT\n       Aspect_Address,\n-      Aspect_Aliased,\n       Aspect_Alignment,\n       Aspect_Atomic,\n       Aspect_Atomic_Components,\n       Aspect_Bit_Order,\n-      Aspect_C_Pass_By_Copy,\n       Aspect_Component_Size,\n       Aspect_Discard_Names,\n       Aspect_External_Tag,\n@@ -56,16 +58,14 @@ package Aspects is\n       Aspect_Inline_Always,                 -- GNAT\n       Aspect_Invariant,\n       Aspect_Machine_Radix,\n+      Aspect_No_Return,\n       Aspect_Object_Size,                   -- GNAT\n       Aspect_Pack,\n       Aspect_Persistent_BSS,                -- GNAT\n       Aspect_Post,\n-      Aspect_Postcondition,                 -- GNAT (equivalent to Post)\n       Aspect_Pre,\n-      Aspect_Precondition,                  -- GNAT (equivalent to Pre)\n       Aspect_Predicate,                     -- GNAT???\n       Aspect_Preelaborable_Initialization,\n-      Aspect_Psect_Object,                  -- GNAT\n       Aspect_Pure_Function,                 -- GNAT\n       Aspect_Shared,                        -- GNAT (equivalent to Atomic)\n       Aspect_Size,\n@@ -83,17 +83,15 @@ package Aspects is\n       Aspect_Value_Size,                    -- GNAT\n       Aspect_Volatile,\n       Aspect_Volatile_Components,\n-      Aspect_Warnings,                      -- GNAT\n-      Aspect_Weak_External);                -- GNAT\n+      Aspect_Warnings);                     -- GNAT\n \n    --  The following array indicates aspects that accept 'Class\n \n    Class_Aspect_OK : constant array (Aspect_Id) of Boolean :=\n                        (Aspect_Invariant     => True,\n                         Aspect_Pre           => True,\n-                        Aspect_Precondition  => True,\n+                        Aspect_Predicate     => True,\n                         Aspect_Post          => True,\n-                        Aspect_Postcondition => True,\n                         others               => False);\n \n    --  The following type is used for indicating allowed expression forms\n@@ -110,12 +108,10 @@ package Aspects is\n                         Aspect_Ada_2005                     => Optional,\n                         Aspect_Ada_2012                     => Optional,\n                         Aspect_Address                      => Expression,\n-                        Aspect_Aliased                      => Optional,\n                         Aspect_Alignment                    => Expression,\n                         Aspect_Atomic                       => Optional,\n                         Aspect_Atomic_Components            => Optional,\n                         Aspect_Bit_Order                    => Expression,\n-                        Aspect_C_Pass_By_Copy               => Optional,\n                         Aspect_Component_Size               => Expression,\n                         Aspect_Discard_Names                => Optional,\n                         Aspect_External_Tag                 => Expression,\n@@ -124,20 +120,18 @@ package Aspects is\n                         Aspect_Inline_Always                => Optional,\n                         Aspect_Invariant                    => Expression,\n                         Aspect_Machine_Radix                => Expression,\n+                        Aspect_No_Return                    => Optional,\n                         Aspect_Object_Size                  => Expression,\n-                        Aspect_Pack                         => Optional,\n                         Aspect_Persistent_BSS               => Optional,\n+                        Aspect_Pack                         => Optional,\n                         Aspect_Post                         => Expression,\n-                        Aspect_Postcondition                => Expression,\n                         Aspect_Pre                          => Expression,\n-                        Aspect_Precondition                 => Expression,\n                         Aspect_Predicate                    => Expression,\n                         Aspect_Preelaborable_Initialization => Optional,\n-                        Aspect_Psect_Object                 => Optional,\n                         Aspect_Pure_Function                => Optional,\n                         Aspect_Shared                       => Optional,\n                         Aspect_Size                         => Expression,\n-                        Aspect_Storage_Pool                 => Expression,\n+                        Aspect_Storage_Pool                 => Name,\n                         Aspect_Storage_Size                 => Expression,\n                         Aspect_Stream_Size                  => Expression,\n                         Aspect_Suppress                     => Name,\n@@ -151,11 +145,50 @@ package Aspects is\n                         Aspect_Value_Size                   => Expression,\n                         Aspect_Volatile                     => Optional,\n                         Aspect_Volatile_Components          => Optional,\n-                        Aspect_Warnings                     => Name,\n-                        Aspect_Weak_External                => Optional);\n+                        Aspect_Warnings                     => Name);\n \n    function Get_Aspect_Id (Name : Name_Id) return Aspect_Id;\n+   pragma Inline (Get_Aspect_Id);\n    --  Given a name Nam, returns the corresponding aspect id value. If the name\n    --  does not match any aspect, then No_Aspect is returned as the result.\n \n+   ---------------------------------------------------\n+   -- Handling of Aspect Specifications in the Tree --\n+   ---------------------------------------------------\n+\n+   --  Several kinds of declaration node permit aspect specifications in Ada\n+   --  2012 mode. If there was room in all the corresponding declaration nodes,\n+   --  we could just have a field Aspect_Specifications pointing to a list of\n+   --  nodes for the aspects (N_Aspect_Specification nodes). But there isn't\n+   --  room, so we adopt a different approach.\n+\n+   --  The following subprograms provide access to a specialized interface\n+   --  implemented internally with a hash table in the body, that provides\n+   --  access to aspect specifications.\n+\n+   function Permits_Aspect_Specifications (N : Node_Id) return Boolean;\n+   --  Returns True if the node N is a declaration node that permits aspect\n+   --  specifications. All such nodes have the Has_Aspect_Specifications\n+   --  flag defined. Returns False for all other nodes.\n+\n+   function Aspect_Specifications (N : Node_Id) return List_Id;\n+   --  Given a node N, returns the list of N_Aspect_Specification nodes that\n+   --  are attached to this declaration node. If the node is in the class of\n+   --  declaration nodes that permit aspect specifications, as defined by the\n+   --  predicate above, and if their Has_Aspect_Specifications flag is set to\n+   --  True, then this will always be a non-empty list. If this flag is set to\n+   --  False, or the node is not in the declaration class permitting aspect\n+   --  specifications, then No_List is returned.\n+\n+   procedure Set_Aspect_Specifications (N : Node_Id; L : List_Id);\n+   --  The node N must be in the class of declaration nodes that permit aspect\n+   --  specifications and the Has_Aspect_Specifications flag must be False on\n+   --  entry. L must be a non-empty list of N_Aspect_Specification nodes. This\n+   --  procedure sets the Has_Aspect_Specifications flag to True, and makes an\n+   --  entry that can be retrieved by a subsequent Aspect_Specifications call.\n+   --  The parent of list L is set to reference the declaration node N. It is\n+   --  an error to call this procedure with a node that does not permit aspect\n+   --  specifications, or a node that has its Has_Aspect_Specifications flag\n+   --  set True on entry, or with L being an empty list or No_List.\n+\n end Aspects;"}, {"sha": "41657c4d28c17a717b02e9b74cd97a771778606f", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -106,7 +106,7 @@ package body Debug is\n    --  d.m  For -gnatl, print full source only for main unit\n    --  d.n  Print source file names\n    --  d.o  Generate .NET listing of CIL code\n-   --  d.p\n+   --  d.p  Enable the .NET CIL verifier\n    --  d.q\n    --  d.r  Enable OK_To_Reorder_Components in non-variant records\n    --  d.s  Disable expansion of slice move, use memmove\n@@ -534,6 +534,10 @@ package body Debug is\n    --  d.o  Generate listing showing the IL instructions generated by the .NET\n    --       compiler for each subprogram.\n \n+   --  d.p  Enable the .NET CIL verifier. During development the verifier is\n+   --       disabled by default and this flag is used to enable it. In the\n+   --       future we will reverse this functionality.\n+\n    --  d.r  Forces the flag OK_To_Reorder_Components to be set in all record\n    --       base types that have no discriminants.\n "}, {"sha": "5fd4e94b08decc5bc20e9ebdcd35576842b4c4dd", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1469, "deletions": 1432, "changes": 2901, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171"}, {"sha": "fed952a1f8693c1dd903a337e4e271630e969c31", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -296,7 +296,7 @@ GNATLINK_OBJS = gnatlink.o \\\n  sdefault.o snames.o stylesw.o switch.o system.o table.o targparm.o tree_io.o \\\n  types.o validsw.o widechar.o\n \n-GNATMAKE_OBJS = a-except.o ali.o ali-util.o s-casuti.o \\\n+GNATMAKE_OBJS = a-except.o ali.o ali-util.o aspects.o s-casuti.o \\\n  alloc.o atree.o binderr.o butil.o casing.o csets.o debug.o elists.o einfo.o\\\n  erroutc.o errutil.o err_vars.o fmap.o fname.o fname-uf.o fname-sf.o \\\n  gnatmake.o gnatvsn.o hostparm.o interfac.o i-c.o i-cstrin.o krunch.o lib.o \\"}, {"sha": "059f004abcff4f47ffc029dc2eeb6a08774b8459", "filename": "gcc/ada/par-ch13.adb", "status": "modified", "additions": 243, "deletions": 1, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fpar-ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fpar-ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch13.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,6 +35,91 @@ package body Ch13 is\n    function P_Component_Clause return Node_Id;\n    function P_Mod_Clause return Node_Id;\n \n+   -----------------------------------\n+   -- Aspect_Specifications_Present --\n+   -----------------------------------\n+\n+   function Aspect_Specifications_Present return Boolean is\n+      Scan_State : Saved_Scan_State;\n+      Result     : Boolean;\n+\n+   begin\n+      Save_Scan_State (Scan_State);\n+\n+      --  If we have a semicolon, test for semicolon followed by Aspect\n+      --  Specifications, in which case we decide the semicolon is accidental.\n+\n+      if Token = Tok_Semicolon then\n+         Scan; -- past semicolon\n+\n+         if Aspect_Specifications_Present then\n+            Error_Msg_SP (\"|extra \"\";\"\" ignored\");\n+            return True;\n+\n+         else\n+            Restore_Scan_State (Scan_State);\n+            return False;\n+         end if;\n+      end if;\n+\n+      --  Definitely must have WITH to consider aspect specs to be present\n+\n+      if Token /= Tok_With then\n+         return False;\n+      end if;\n+\n+      --  Have a WITH, see if it looks like an aspect specification\n+\n+      Save_Scan_State (Scan_State);\n+      Scan; -- past WITH\n+\n+      --  If no identifier, then consider that we definitely do not have an\n+      --  aspect specification.\n+\n+      if Token /= Tok_Identifier then\n+         Result := False;\n+\n+      --  In Ada 2012 mode, we are less strict, and we consider that we have\n+      --  an aspect specification if the identifier is an aspect name (even if\n+      --  not followed by =>) or the identifier is not an aspect name but is\n+      --  followed by =>. P_Aspect_Specifications will generate messages if the\n+      --  aspect specification is ill-formed.\n+\n+      elsif Ada_Version >= Ada_2012 then\n+         if Get_Aspect_Id (Token_Name) /= No_Aspect then\n+            Result := True;\n+         else\n+            Scan; -- past identifier\n+            Result := Token = Tok_Arrow;\n+         end if;\n+\n+      --  If earlier than Ada 2012, check for valid aspect identifier followed\n+      --  by an arrow, and consider that this is still an aspect specification\n+      --  so we give an appropriate message.\n+\n+      else\n+         if Get_Aspect_Id (Token_Name) = No_Aspect then\n+            Result := False;\n+\n+         else\n+            Scan; -- past aspect name\n+\n+            if Token /= Tok_Arrow then\n+               Result := False;\n+\n+            else\n+               Restore_Scan_State (Scan_State);\n+               Error_Msg_SC (\"|aspect specification is an Ada 2012 feature\");\n+               Error_Msg_SC (\"\\|unit must be compiled with -gnat2012 switch\");\n+               return True;\n+            end if;\n+         end if;\n+      end if;\n+\n+      Restore_Scan_State (Scan_State);\n+      return Result;\n+   end Aspect_Specifications_Present;\n+\n    --------------------------------------------\n    -- 13.1  Representation Clause (also I.7) --\n    --------------------------------------------\n@@ -274,6 +359,163 @@ package body Ch13 is\n \n    --  Parsed by P_Representation_Clause (13.1)\n \n+   ------------------------------\n+   -- 13.1  Aspect Specifation --\n+   ------------------------------\n+\n+   --  ASPECT_SPECIFICATION ::=\n+   --    with ASPECT_MARK [=> ASPECT_DEFINITION] {.\n+   --         ASPECT_MARK [=> ASPECT_DEFINITION] }\n+\n+   --  ASPECT_MARK ::= aspect_IDENTIFIER['Class]\n+\n+   --  ASPECT_DEFINITION ::= NAME | EXPRESSION\n+\n+   --  Error recovery: cannot raise Error_Resync\n+\n+   procedure P_Aspect_Specifications (Decl : Node_Id) is\n+      Aspects : List_Id;\n+      Aspect  : Node_Id;\n+      A_Id    : Aspect_Id;\n+      OK      : Boolean;\n+\n+   begin\n+      --  Check if aspect specification present\n+\n+      if not Aspect_Specifications_Present then\n+         T_Semicolon;\n+         return;\n+      end if;\n+\n+      --  Aspect Specification is present\n+\n+      Scan; -- past WITH\n+\n+      --  Here we have an aspect specification to scan, note that we don;t\n+      --  set the flag till later, because it may turn out that we have no\n+      --  valid aspects in the list.\n+\n+      Aspects := Empty_List;\n+      loop\n+         OK := True;\n+\n+         if Token /= Tok_Identifier then\n+            Error_Msg_SC (\"aspect identifier expected\");\n+            Resync_Past_Semicolon;\n+            return;\n+         end if;\n+\n+         --  We have an identifier (which should be an aspect identifier)\n+\n+         Aspect := Token_Node;\n+         A_Id := Get_Aspect_Id (Token_Name);\n+         Aspect :=\n+           Make_Aspect_Specification (Sloc (Aspect),\n+             Identifier => Token_Node);\n+\n+         --  No valid aspect identifier present\n+\n+         if A_Id = No_Aspect then\n+            Error_Msg_SC (\"aspect identifier expected\");\n+\n+            if Token = Tok_Apostrophe then\n+               Scan; -- past '\n+               Scan; -- past presumably CLASS\n+            end if;\n+\n+            if Token = Tok_Arrow then\n+               Scan; -- Past arrow\n+               Set_Expression (Aspect, P_Expression);\n+               OK := False;\n+\n+            elsif Token = Tok_Comma then\n+               OK := False;\n+\n+            else\n+               Resync_Past_Semicolon;\n+               return;\n+            end if;\n+\n+         --  OK aspect scanned\n+\n+         else\n+            Scan; -- past identifier\n+\n+            --  Check for 'Class present\n+\n+            if Token = Tok_Apostrophe then\n+               if not Class_Aspect_OK (A_Id) then\n+                  Error_Msg_Node_1 := Identifier (Aspect);\n+                  Error_Msg_SC (\"aspect& does not permit attribute here\");\n+                  Scan; -- past apostophe\n+                  Scan; -- past presumed CLASS\n+                  OK := False;\n+\n+               else\n+                  Scan; -- past apostrophe\n+\n+                  if Token /= Tok_Identifier\n+                    or else Token_Name /= Name_Class\n+                  then\n+                     Error_Msg_SC (\"Class attribute expected here\");\n+                     OK := False;\n+\n+                     if Token = Tok_Identifier then\n+                        Scan; -- past identifier not CLASS\n+                     end if;\n+                  end if;\n+               end if;\n+            end if;\n+\n+            --  Test case of missing aspect definition\n+\n+            if Token = Tok_Comma or else Token = Tok_Semicolon then\n+               if Aspect_Argument (A_Id) /= Optional then\n+                  Error_Msg_Node_1 := Aspect;\n+                  Error_Msg_AP (\"aspect& requires an aspect definition\");\n+                  OK := False;\n+               end if;\n+\n+            --  Here we have an aspect definition\n+\n+            else\n+               if Token = Tok_Arrow then\n+                  Scan; -- past arrow\n+               else\n+                  T_Arrow;\n+                  OK := False;\n+               end if;\n+\n+               if Aspect_Argument (A_Id) = Name then\n+                  Set_Expression (Aspect, P_Name);\n+               else\n+                  Set_Expression (Aspect, P_Expression);\n+               end if;\n+            end if;\n+\n+            --  If OK clause scanned, add it to the list\n+\n+            if OK then\n+               Append (Aspect, Aspects);\n+            end if;\n+\n+            if Token = Tok_Comma then\n+               Scan; -- past comma\n+            else\n+               T_Semicolon;\n+               exit;\n+            end if;\n+         end if;\n+      end loop;\n+\n+      --  If aspects scanned, store them\n+\n+      if Is_Non_Empty_List (Aspects) then\n+         Set_Parent (Aspects, Decl);\n+         Set_Aspect_Specifications (Decl, Aspects);\n+      end if;\n+   end P_Aspect_Specifications;\n+\n    ---------------------------------------------\n    -- 13.4  Enumeration Representation Clause --\n    ---------------------------------------------"}, {"sha": "d09723d8fce1b4f9b2cda9af30b5137408b89932", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -327,7 +327,7 @@ package body Ch3 is\n       Type_Start_Col   : Column_Number;\n       Unknown_Dis      : Boolean;\n \n-      Typedef_Node     : Node_Id;\n+      Typedef_Node : Node_Id;\n       --  Normally holds type definition, except in the case of a private\n       --  extension declaration, in which case it holds the declaration itself\n \n@@ -476,22 +476,18 @@ package body Ch3 is\n             when Tok_Access |\n                  Tok_Not    => --  Ada 2005 (AI-231)\n                Typedef_Node := P_Access_Type_Definition;\n-               TF_Semicolon;\n                exit;\n \n             when Tok_Array =>\n                Typedef_Node := P_Array_Type_Definition;\n-               TF_Semicolon;\n                exit;\n \n             when Tok_Delta =>\n                Typedef_Node := P_Fixed_Point_Definition;\n-               TF_Semicolon;\n                exit;\n \n             when Tok_Digits =>\n                Typedef_Node := P_Floating_Point_Definition;\n-               TF_Semicolon;\n                exit;\n \n             when Tok_In =>\n@@ -500,12 +496,10 @@ package body Ch3 is\n             when Tok_Integer_Literal =>\n                T_Range;\n                Typedef_Node := P_Signed_Integer_Type_Definition;\n-               TF_Semicolon;\n                exit;\n \n             when Tok_Null =>\n                Typedef_Node := P_Record_Definition;\n-               TF_Semicolon;\n                exit;\n \n             when Tok_Left_Paren =>\n@@ -517,12 +511,10 @@ package body Ch3 is\n                Set_Comes_From_Source (End_Labl, False);\n \n                Set_End_Label (Typedef_Node, End_Labl);\n-               TF_Semicolon;\n                exit;\n \n             when Tok_Mod =>\n                Typedef_Node := P_Modular_Type_Definition;\n-               TF_Semicolon;\n                exit;\n \n             when Tok_New =>\n@@ -540,12 +532,10 @@ package body Ch3 is\n                     (Record_Extension_Part (Typedef_Node), End_Labl);\n                end if;\n \n-               TF_Semicolon;\n                exit;\n \n             when Tok_Range =>\n                Typedef_Node := P_Signed_Integer_Type_Definition;\n-               TF_Semicolon;\n                exit;\n \n             when Tok_Record =>\n@@ -557,7 +547,6 @@ package body Ch3 is\n                Set_Comes_From_Source (End_Labl, False);\n \n                Set_End_Label (Typedef_Node, End_Labl);\n-               TF_Semicolon;\n                exit;\n \n             when Tok_Tagged =>\n@@ -640,7 +629,6 @@ package body Ch3 is\n                   end if;\n                end if;\n \n-               TF_Semicolon;\n                exit;\n \n             when Tok_Limited =>\n@@ -733,7 +721,6 @@ package body Ch3 is\n                   T_Private; -- past PRIVATE (or complain if not there!)\n                end if;\n \n-               TF_Semicolon;\n                exit;\n \n             --  Here we have an identifier after the IS, which is certainly\n@@ -748,7 +735,6 @@ package body Ch3 is\n \n                if not Token_Is_At_Start_Of_Line then\n                   Typedef_Node := P_Derived_Type_Def_Or_Private_Ext_Decl;\n-                  TF_Semicolon;\n \n                --  If the identifier is at the start of the line, and is in the\n                --  same column as the type declaration itself then we consider\n@@ -769,7 +755,6 @@ package body Ch3 is\n \n                else\n                   Typedef_Node := P_Record_Definition;\n-                  TF_Semicolon;\n                end if;\n \n                exit;\n@@ -779,13 +764,11 @@ package body Ch3 is\n             when Tok_Interface =>\n                Typedef_Node := P_Interface_Type_Definition (Abstract_Present);\n                Abstract_Present := True;\n-               TF_Semicolon;\n                exit;\n \n             when Tok_Private =>\n                Decl_Node := New_Node (N_Private_Type_Declaration, Type_Loc);\n                Scan; -- past PRIVATE\n-               TF_Semicolon;\n                exit;\n \n             --  Ada 2005 (AI-345): Protected, synchronized or task interface\n@@ -849,7 +832,6 @@ package body Ch3 is\n                   end if;\n                end;\n \n-               TF_Semicolon;\n                exit;\n \n             --  Anything else is an error\n@@ -933,6 +915,7 @@ package body Ch3 is\n \n       Set_Defining_Identifier (Decl_Node, Ident_Node);\n       Set_Discriminant_Specifications (Decl_Node, Discr_List);\n+      P_Aspect_Specifications (Decl_Node);\n       return Decl_Node;\n    end P_Type_Declaration;\n \n@@ -980,7 +963,7 @@ package body Ch3 is\n \n       Set_Subtype_Indication\n         (Decl_Node, P_Subtype_Indication (Not_Null_Present));\n-      TF_Semicolon;\n+      P_Aspect_Specifications (Decl_Node);\n       return Decl_Node;\n    end P_Subtype_Declaration;\n \n@@ -1836,8 +1819,8 @@ package body Ch3 is\n             end if;\n          end if;\n \n-         TF_Semicolon;\n          Set_Defining_Identifier (Decl_Node, Idents (Ident));\n+         P_Aspect_Specifications (Decl_Node);\n \n          if List_OK then\n             if Ident < Num_Idents then\n@@ -1976,7 +1959,16 @@ package body Ch3 is\n       --  missing in the case of \"type X is new Y record ...\" or in the\n       --  case of \"type X is new Y null record\".\n \n-      if Token = Tok_With\n+      --  First make sure we don't have an aspect specification. If we do\n+      --  return now, so that our caller can check it (the WITH here is not\n+      --  part of a type extension).\n+\n+      if Aspect_Specifications_Present then\n+         return Typedef_Node;\n+\n+      --  OK, not an aspect specification, so continue test for extension\n+\n+      elsif Token = Tok_With\n         or else Token = Tok_Record\n         or else Token = Tok_Null\n       then\n@@ -3470,10 +3462,9 @@ package body Ch3 is\n          Ident := Ident + 1;\n          Restore_Scan_State (Scan_State);\n          T_Colon;\n-\n       end loop Ident_Loop;\n \n-      TF_Semicolon;\n+      P_Aspect_Specifications (Decl_Node);\n    end P_Component_Items;\n \n    --------------------------------"}, {"sha": "bada172c40cc807a7b7bc654421ddff22f1983d1", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -305,7 +305,7 @@ package body Ch6 is\n \n             Set_Defining_Unit_Name (Inst_Node, Name_Node);\n             Set_Generic_Associations (Inst_Node, P_Generic_Actual_Part_Opt);\n-            TF_Semicolon;\n+            P_Aspect_Specifications (Inst_Node);\n             Pop_Scope_Stack; -- Don't need scope stack entry in this case\n \n             if Is_Overriding then\n@@ -525,7 +525,7 @@ package body Ch6 is\n                Set_Specification (Absdec_Node, Specification_Node);\n                Pop_Scope_Stack; -- discard unneeded entry\n                Scan; -- past ABSTRACT\n-               TF_Semicolon;\n+               P_Aspect_Specifications (Absdec_Node);\n                return Absdec_Node;\n \n             --  Ada 2005 (AI-248): Parse a null procedure declaration"}, {"sha": "5b1d6c7bd1f366e6c9fa80fe27b03e982d0b9e3c", "filename": "gcc/ada/par-ch9.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fpar-ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fpar-ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch9.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -900,7 +900,7 @@ package body Ch9 is\n          Discard_Junk_Node (P_Expression_No_Right_Paren);\n       end if;\n \n-      TF_Semicolon;\n+      P_Aspect_Specifications (Decl_Node);\n       return Decl_Node;\n \n    exception"}, {"sha": "fb51469f5e216274f19304d86d7b3b5534abf132", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Casing;   use Casing;\n with Debug;    use Debug;\n@@ -836,6 +837,25 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n    package Ch13 is\n       function P_Representation_Clause                return Node_Id;\n \n+      function Aspect_Specifications_Present return Boolean;\n+      --  This function tests whether the next keyword is WITH followed by\n+      --  something that looks reasonably like an aspect specification. If so,\n+      --  True is returned. Otherwise False is returned. In either case control\n+      --  returns with the token pointer unchanged (i.e. pointing to the WITH\n+      --  token in the case where True is returned). This function takes care\n+      --  of generating appropriate messages if aspect specifications appear\n+      --  in versions of Ada prior to Ada 2012.\n+\n+      procedure P_Aspect_Specifications (Decl : Node_Id);\n+      --  This subprogram is called with the current token pointing to either a\n+      --  WITH keyword starting an aspect specification, or a semicolon. In the\n+      --  former case, the aspect specifications are scanned out including the\n+      --  terminating semicolon, the Has_Aspect_Specifications flag is set in\n+      --  the given declaration node, and the list of aspect specifications is\n+      --  constructed and associated with this declaration node using a call to\n+      --  Set_Aspect_Specifications. If no WITH keyword is present, then this\n+      --  call has no effect other than scanning out the semicolon.\n+\n       function P_Code_Statement (Subtype_Mark : Node_Id) return Node_Id;\n       --  Function to parse a code statement. The caller has scanned out\n       --  the name to be used as the subtype mark (but has not checked that"}, {"sha": "27a6aa75e64743f3f5e50f87d325576c36b545c4", "filename": "gcc/ada/s-htable.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fs-htable.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fs-htable.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-htable.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                    Copyright (C) 1995-2009, AdaCore                      --\n+--                    Copyright (C) 1995-2010, AdaCore                      --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -110,7 +110,7 @@ package body System.HTable is\n \n       function Get_Non_Null return Elmt_Ptr is\n       begin\n-         while Iterator_Ptr = Null_Ptr  loop\n+         while Iterator_Ptr = Null_Ptr loop\n             if Iterator_Index = Table'Last then\n                Iterator_Started := False;\n                return Null_Ptr;"}, {"sha": "42b8356941338c4df50dc9a725f138bf3fe1d180", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -237,10 +237,10 @@ package body Sem is\n             Analyze_Formal_Object_Declaration (N);\n \n          when N_Formal_Package_Declaration =>\n-            Analyze_Formal_Package (N);\n+            Analyze_Formal_Package_Declaration (N);\n \n          when N_Formal_Subprogram_Declaration =>\n-            Analyze_Formal_Subprogram (N);\n+            Analyze_Formal_Subprogram_Declaration (N);\n \n          when N_Formal_Type_Declaration =>\n             Analyze_Formal_Type_Declaration (N);\n@@ -252,7 +252,7 @@ package body Sem is\n             Analyze_Freeze_Entity (N);\n \n          when N_Full_Type_Declaration =>\n-            Analyze_Type_Declaration (N);\n+            Analyze_Full_Type_Declaration (N);\n \n          when N_Function_Call =>\n             Analyze_Function_Call (N);\n@@ -465,7 +465,7 @@ package body Sem is\n             Analyze_Protected_Definition (N);\n \n          when N_Protected_Type_Declaration =>\n-            Analyze_Protected_Type (N);\n+            Analyze_Protected_Type_Declaration (N);\n \n          when N_Qualified_Expression =>\n             Analyze_Qualified_Expression (N);\n@@ -505,10 +505,10 @@ package body Sem is\n             Analyze_Selective_Accept (N);\n \n          when N_Single_Protected_Declaration =>\n-            Analyze_Single_Protected (N);\n+            Analyze_Single_Protected_Declaration (N);\n \n          when N_Single_Task_Declaration =>\n-            Analyze_Single_Task (N);\n+            Analyze_Single_Task_Declaration (N);\n \n          when N_Slice =>\n             Analyze_Slice (N);\n@@ -550,7 +550,7 @@ package body Sem is\n             Analyze_Task_Definition (N);\n \n          when N_Task_Type_Declaration =>\n-            Analyze_Task_Type (N);\n+            Analyze_Task_Type_Declaration (N);\n \n          when N_Terminate_Alternative =>\n             Analyze_Terminate_Alternative (N);"}, {"sha": "aa62305b4c4e6155442405a6882d5ba41c53a4e2", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -1754,8 +1754,8 @@ package body Sem_Cat is\n    --  Start of processing for Validate_Remote_Access_Object_Type_Declaration\n \n    begin\n-      --  We are called from Analyze_Type_Declaration, and the Nkind of the\n-      --  given node is N_Access_To_Object_Definition.\n+      --  We are called from Analyze_Full_Type_Declaration, and the Nkind of\n+      --  the given node is N_Access_To_Object_Definition.\n \n       if not Comes_From_Source (T)\n         or else (not In_RCI_Declaration (Parent (T))\n@@ -2055,7 +2055,7 @@ package body Sem_Cat is\n    --  Start of processing for Validate_SP_Access_Object_Type_Decl\n \n    begin\n-      --  We are called from Sem_Ch3.Analyze_Type_Declaration, and the\n+      --  We are called from Sem_Ch3.Analyze_Full_Type_Declaration, and the\n       --  Nkind of the given entity is N_Access_To_Object_Definition.\n \n       if not Comes_From_Source (T)"}, {"sha": "d3661ff0835ffd9d97a18102dea79d5c38f346e2", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n@@ -39,6 +40,7 @@ with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch5;  use Sem_Ch5;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch13; use Sem_Ch13;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n@@ -55,6 +57,7 @@ package body Sem_Ch11 is\n    procedure Analyze_Exception_Declaration (N : Node_Id) is\n       Id : constant Entity_Id := Defining_Identifier (N);\n       PF : constant Boolean   := Is_Pure (Current_Scope);\n+      AS : constant List_Id   := Aspect_Specifications (N);\n    begin\n       Generate_Definition         (Id);\n       Enter_Name                  (Id);\n@@ -63,6 +66,7 @@ package body Sem_Ch11 is\n       Set_Etype                   (Id, Standard_Exception_Type);\n       Set_Is_Statically_Allocated (Id);\n       Set_Is_Pure                 (Id, PF);\n+      Analyze_Aspect_Specifications (N, Id, AS);\n    end Analyze_Exception_Declaration;\n \n    --------------------------------"}, {"sha": "a03971c97421b5f3d3ec4d51548af91e4a2e8eb9", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n@@ -1801,6 +1802,7 @@ package body Sem_Ch12 is\n    procedure Analyze_Formal_Object_Declaration (N : Node_Id) is\n       E  : constant Node_Id := Default_Expression (N);\n       Id : constant Node_Id := Defining_Identifier (N);\n+      AS : constant List_Id := Aspect_Specifications (N);\n       K  : Entity_Kind;\n       T  : Node_Id;\n \n@@ -1929,6 +1931,8 @@ package body Sem_Ch12 is\n               (\"initialization not allowed for `IN OUT` formals\", N);\n          end if;\n       end if;\n+\n+      Analyze_Aspect_Specifications (N, Id, AS);\n    end Analyze_Formal_Object_Declaration;\n \n    ----------------------------------------------\n@@ -1972,13 +1976,14 @@ package body Sem_Ch12 is\n       Check_Restriction (No_Fixed_Point, Def);\n    end Analyze_Formal_Ordinary_Fixed_Point_Type;\n \n-   ----------------------------\n-   -- Analyze_Formal_Package --\n-   ----------------------------\n+   ----------------------------------------\n+   -- Analyze_Formal_Package_Declaration --\n+   ----------------------------------------\n \n-   procedure Analyze_Formal_Package (N : Node_Id) is\n+   procedure Analyze_Formal_Package_Declaration (N : Node_Id) is\n       Loc              : constant Source_Ptr := Sloc (N);\n       Pack_Id          : constant Entity_Id  := Defining_Identifier (N);\n+      AS               : constant List_Id    := Aspect_Specifications (N);\n       Formal           : Entity_Id;\n       Gen_Id           : constant Node_Id    := Name (N);\n       Gen_Decl         : Node_Id;\n@@ -2115,14 +2120,14 @@ package body Sem_Ch12 is\n       if Ekind (Gen_Unit) /= E_Generic_Package then\n          Error_Msg_N (\"expect generic package name\", Gen_Id);\n          Restore_Env;\n-         return;\n+         goto Leave;\n \n       elsif  Gen_Unit = Current_Scope then\n          Error_Msg_N\n            (\"generic package cannot be used as a formal package of itself\",\n              Gen_Id);\n          Restore_Env;\n-         return;\n+         goto Leave;\n \n       elsif In_Open_Scopes (Gen_Unit) then\n          if Is_Compilation_Unit (Gen_Unit)\n@@ -2142,7 +2147,7 @@ package body Sem_Ch12 is\n                 & \"within itself\",\n                 Gen_Id);\n             Restore_Env;\n-            return;\n+            goto Leave;\n          end if;\n       end if;\n \n@@ -2190,7 +2195,7 @@ package body Sem_Ch12 is\n                Remove_Parent;\n             end if;\n \n-            return;\n+            goto Leave;\n       end;\n \n       Rewrite (N, New_N);\n@@ -2273,7 +2278,9 @@ package body Sem_Ch12 is\n       Set_Etype (Pack_Id, Standard_Void_Type);\n       Set_Scope (Pack_Id, Scope (Formal));\n       Set_Has_Completion (Pack_Id, True);\n-   end Analyze_Formal_Package;\n+\n+      <<Leave>> Analyze_Aspect_Specifications (N, Pack_Id, AS);\n+   end Analyze_Formal_Package_Declaration;\n \n    ---------------------------------\n    -- Analyze_Formal_Private_Type --\n@@ -2323,14 +2330,15 @@ package body Sem_Ch12 is\n       Set_Parent          (Base, Parent (Def));\n    end Analyze_Formal_Signed_Integer_Type;\n \n-   -------------------------------\n-   -- Analyze_Formal_Subprogram --\n-   -------------------------------\n+   -------------------------------------------\n+   -- Analyze_Formal_Subprogram_Declaration --\n+   -------------------------------------------\n \n-   procedure Analyze_Formal_Subprogram (N : Node_Id) is\n+   procedure Analyze_Formal_Subprogram_Declaration (N : Node_Id) is\n       Spec : constant Node_Id   := Specification (N);\n       Def  : constant Node_Id   := Default_Name (N);\n       Nam  : constant Entity_Id := Defining_Unit_Name (Spec);\n+      AS   : constant List_Id   := Aspect_Specifications (N);\n       Subp : Entity_Id;\n \n    begin\n@@ -2340,7 +2348,7 @@ package body Sem_Ch12 is\n \n       if Nkind (Nam) = N_Defining_Program_Unit_Name then\n          Error_Msg_N (\"name of formal subprogram must be a direct name\", Nam);\n-         return;\n+         goto Leave;\n       end if;\n \n       Analyze_Subprogram_Declaration (N);\n@@ -2384,7 +2392,7 @@ package body Sem_Ch12 is\n \n             Analyze (Prefix (Def));\n             Valid_Default_Attribute (Nam, Def);\n-            return;\n+            goto Leave;\n          end if;\n \n          --  Default name may be overloaded, in which case the interpretation\n@@ -2394,7 +2402,7 @@ package body Sem_Ch12 is\n          --  can be a protected operation.\n \n          if Etype (Def) = Any_Type then\n-            return;\n+            goto Leave;\n \n          elsif Nkind (Def) = N_Selected_Component then\n             if not Is_Overloadable (Entity (Selector_Name (Def))) then\n@@ -2416,7 +2424,7 @@ package body Sem_Ch12 is\n \n             else\n                Error_Msg_N (\"expect valid subprogram name as default\", Def);\n-               return;\n+               goto Leave;\n             end if;\n \n          elsif Nkind (Def) = N_Character_Literal then\n@@ -2429,7 +2437,7 @@ package body Sem_Ch12 is\n            or else not Is_Overloadable (Entity (Def))\n          then\n             Error_Msg_N (\"expect valid subprogram name as default\", Def);\n-            return;\n+            goto Leave;\n \n          elsif not Is_Overloaded (Def) then\n             Subp := Entity (Def);\n@@ -2491,14 +2499,17 @@ package body Sem_Ch12 is\n             end if;\n          end if;\n       end if;\n-   end Analyze_Formal_Subprogram;\n+\n+      <<Leave>> Analyze_Aspect_Specifications (N, Nam, AS);\n+   end Analyze_Formal_Subprogram_Declaration;\n \n    -------------------------------------\n    -- Analyze_Formal_Type_Declaration --\n    -------------------------------------\n \n    procedure Analyze_Formal_Type_Declaration (N : Node_Id) is\n       Def : constant Node_Id := Formal_Type_Definition (N);\n+      AS  : constant List_Id := Aspect_Specifications (N);\n       T   : Entity_Id;\n \n    begin\n@@ -2564,6 +2575,7 @@ package body Sem_Ch12 is\n       end case;\n \n       Set_Is_Generic_Type (T);\n+      Analyze_Aspect_Specifications (N, T, AS);\n    end Analyze_Formal_Type_Declaration;\n \n    ------------------------------------\n@@ -2630,6 +2642,7 @@ package body Sem_Ch12 is\n \n    procedure Analyze_Generic_Package_Declaration (N : Node_Id) is\n       Loc         : constant Source_Ptr := Sloc (N);\n+      AS          : constant List_Id    := Aspect_Specifications (N);\n       Id          : Entity_Id;\n       New_N       : Node_Id;\n       Save_Parent : Node_Id;\n@@ -2740,13 +2753,16 @@ package body Sem_Ch12 is\n             Check_References (Id);\n          end if;\n       end if;\n+\n+      Analyze_Aspect_Specifications (N, Id, AS);\n    end Analyze_Generic_Package_Declaration;\n \n    --------------------------------------------\n    -- Analyze_Generic_Subprogram_Declaration --\n    --------------------------------------------\n \n    procedure Analyze_Generic_Subprogram_Declaration (N : Node_Id) is\n+      AS          : constant List_Id := Aspect_Specifications (N);\n       Spec        : Node_Id;\n       Id          : Entity_Id;\n       Formals     : List_Id;\n@@ -2865,6 +2881,7 @@ package body Sem_Ch12 is\n       End_Scope;\n       Exit_Generic_Scope (Id);\n       Generate_Reference_To_Formals (Id);\n+      Analyze_Aspect_Specifications (N, Id, AS);\n    end Analyze_Generic_Subprogram_Declaration;\n \n    -----------------------------------\n@@ -2874,6 +2891,7 @@ package body Sem_Ch12 is\n    procedure Analyze_Package_Instantiation (N : Node_Id) is\n       Loc    : constant Source_Ptr := Sloc (N);\n       Gen_Id : constant Node_Id    := Name (N);\n+      AS     : constant List_Id    := Aspect_Specifications (N);\n \n       Act_Decl      : Node_Id;\n       Act_Decl_Name : Node_Id;\n@@ -3014,7 +3032,7 @@ package body Sem_Ch12 is\n \n       if Etype (Gen_Unit) = Any_Type then\n          Restore_Env;\n-         return;\n+         goto Leave;\n \n       elsif Ekind (Gen_Unit) /= E_Generic_Package then\n \n@@ -3029,7 +3047,7 @@ package body Sem_Ch12 is\n          end if;\n \n          Restore_Env;\n-         return;\n+         goto Leave;\n       end if;\n \n       if In_Extended_Main_Source_Unit (N) then\n@@ -3072,15 +3090,15 @@ package body Sem_Ch12 is\n       if In_Open_Scopes (Gen_Unit) then\n          Error_Msg_NE (\"instantiation of & within itself\", N, Gen_Unit);\n          Restore_Env;\n-         return;\n+         goto Leave;\n \n       elsif Contains_Instance_Of (Gen_Unit, Current_Scope, Gen_Id) then\n          Error_Msg_Node_2 := Current_Scope;\n          Error_Msg_NE\n            (\"circular Instantiation: & instantiated in &!\", N, Gen_Unit);\n          Circularity_Detected := True;\n          Restore_Env;\n-         return;\n+         goto Leave;\n \n       else\n          Gen_Decl := Unit_Declaration_Node (Gen_Unit);\n@@ -3537,6 +3555,8 @@ package body Sem_Ch12 is\n          Set_Defining_Identifier (N, Act_Decl_Id);\n       end if;\n \n+      <<Leave>> Analyze_Aspect_Specifications (N, Act_Decl_Id, AS);\n+\n    exception\n       when Instantiation_Error =>\n          if Parent_Installed then\n@@ -3890,6 +3910,7 @@ package body Sem_Ch12 is\n    is\n       Loc    : constant Source_Ptr := Sloc (N);\n       Gen_Id : constant Node_Id    := Name (N);\n+      AS     : constant List_Id    := Aspect_Specifications (N);\n \n       Anon_Id : constant Entity_Id :=\n                   Make_Defining_Identifier (Sloc (Defining_Entity (N)),\n@@ -4153,7 +4174,7 @@ package body Sem_Ch12 is\n             Error_Msg_NE\n               (\"circular Instantiation: & instantiated in &!\", N, Gen_Unit);\n             Circularity_Detected := True;\n-            return;\n+            goto Leave;\n          end if;\n \n          Gen_Decl := Unit_Declaration_Node (Gen_Unit);\n@@ -4311,6 +4332,8 @@ package body Sem_Ch12 is\n          Generic_Renamings_HTable.Reset;\n       end if;\n \n+      <<Leave>> Analyze_Aspect_Specifications (N, Act_Decl_Id, AS);\n+\n    exception\n       when Instantiation_Error =>\n          if Parent_Installed then"}, {"sha": "c57a1d0c30ab0f7f0cbf7ca2c655a68a9aad61f3", "filename": "gcc/ada/sem_ch12.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.ads?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -34,8 +34,8 @@ package Sem_Ch12 is\n    procedure Analyze_Function_Instantiation             (N : Node_Id);\n    procedure Analyze_Formal_Object_Declaration          (N : Node_Id);\n    procedure Analyze_Formal_Type_Declaration            (N : Node_Id);\n-   procedure Analyze_Formal_Subprogram                  (N : Node_Id);\n-   procedure Analyze_Formal_Package                     (N : Node_Id);\n+   procedure Analyze_Formal_Subprogram_Declaration      (N : Node_Id);\n+   procedure Analyze_Formal_Package_Declaration         (N : Node_Id);\n \n    procedure Start_Generic;\n    --  Must be invoked before starting to process a generic spec or body"}, {"sha": "6fcb998e1ddc1908d75236dc3ac873c14096ec07", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 300, "deletions": 45, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n@@ -618,6 +619,217 @@ package body Sem_Ch13 is\n       end if;\n    end Alignment_Check_For_Esize_Change;\n \n+   -----------------------------------\n+   -- Analyze_Aspect_Specifications --\n+   -----------------------------------\n+\n+   procedure Analyze_Aspect_Specifications\n+     (N : Node_Id;\n+      E : Entity_Id;\n+      L : List_Id)\n+   is\n+      Aspect : Node_Id;\n+      Ent    : Node_Id;\n+      Result : Boolean;\n+      Ritem  : Node_Id;\n+\n+      Ins_Node : Node_Id := N;\n+      --  Insert pragmas after this node\n+\n+   begin\n+      if L = No_List then\n+         return;\n+      end if;\n+\n+      Aspect := First (L);\n+      while Present (Aspect) loop\n+         declare\n+            Id   : constant Node_Id  := Identifier (Aspect);\n+            Expr : constant Node_Id  := Expression (Aspect);\n+            Nam  : constant Name_Id  := Chars (Id);\n+            Anod : Node_Id;\n+\n+         begin\n+            --  Check for duplicate aspect\n+\n+            Anod := First (L);\n+            while Anod /= Aspect loop\n+               if Nam = Chars (Identifier (Anod)) then\n+                  Error_Msg_Name_1 := Nam;\n+                  Error_Msg_Sloc := Sloc (Anod);\n+                  Error_Msg_NE\n+                    (\"aspect% for & ignored, already given at#\", Id, E);\n+                  goto Continue;\n+               end if;\n+\n+               Next (Anod);\n+            end loop;\n+\n+            --  Processing based on specific aspect\n+\n+            case Get_Aspect_Id (Nam) is\n+\n+               --  No_Aspect should be impossible\n+\n+               when No_Aspect =>\n+                  raise Program_Error;\n+\n+                  --  Aspects taking an optional boolean argument. For all of\n+                  --  these we just create a matching pragma and insert it,\n+                  --  setting flag Cancel_Aspect if the expression is False.\n+\n+               when Aspect_Ada_2005                     |\n+                    Aspect_Ada_2012                     |\n+                    Aspect_Atomic                       |\n+                    Aspect_Atomic_Components            |\n+                    Aspect_Discard_Names                |\n+                    Aspect_Favor_Top_Level              |\n+                    Aspect_Inline                       |\n+                    Aspect_Inline_Always                |\n+                    Aspect_No_Return                    |\n+                    Aspect_Pack                         |\n+                    Aspect_Persistent_BSS               |\n+                    Aspect_Preelaborable_Initialization |\n+                    Aspect_Pure_Function                |\n+                    Aspect_Shared                       |\n+                    Aspect_Suppress_Debug_Info          |\n+                    Aspect_Unchecked_Union              |\n+                    Aspect_Universal_Aliasing           |\n+                    Aspect_Unmodified                   |\n+                    Aspect_Unreferenced                 |\n+                    Aspect_Unreferenced_Objects         |\n+                    Aspect_Volatile                     |\n+                    Aspect_Volatile_Components          =>\n+\n+                  if No (Expr) then\n+                     Result := True;\n+\n+                  else\n+                     Analyze_And_Resolve (Expr);\n+\n+                     if not Is_OK_Static_Expression (Expr) then\n+                        Error_Msg_N\n+                          (\"static boolean expression required here\", Expr);\n+                        Result := True;\n+\n+                     else\n+                        Result := Is_True (Expr_Value (Expr));\n+                     end if;\n+                  end if;\n+\n+                  Ent := New_Occurrence_Of (E, Sloc (Id));\n+\n+                  Ritem :=\n+                    Make_Pragma (Sloc (Aspect),\n+                      Pragma_Argument_Associations => New_List (Ent),\n+                      Pragma_Identifier            =>\n+                         Make_Identifier (Sloc (Id), Chars (Id)));\n+\n+                  if Result = False then\n+                     Set_Aspect_Cancel (Ritem);\n+                  end if;\n+\n+               --  Aspects corresponding to attribute definition clauses. We\n+               --  create the matching clause and insert it following the\n+               --  declaration in the tree.\n+\n+               when Aspect_Address        |\n+                    Aspect_Alignment      |\n+                    Aspect_Bit_Order      |\n+                    Aspect_Component_Size |\n+                    Aspect_External_Tag   |\n+                    Aspect_Machine_Radix  |\n+                    Aspect_Object_Size    |\n+                    Aspect_Size           |\n+                    Aspect_Storage_Pool   |\n+                    Aspect_Storage_Size   |\n+                    Aspect_Stream_Size    |\n+                    Aspect_Value_Size     =>\n+\n+                  Ritem :=\n+                    Make_Attribute_Definition_Clause (Sloc (Aspect),\n+                      Name       => New_Occurrence_Of (E, Sloc (Id)),\n+                      Chars      => Chars (Id),\n+                      Expression => Relocate_Node (Expr));\n+\n+               --  Aspects corresponding to pragmas with two arguments, where\n+               --  the first argument is a local name referring to the entity,\n+               --  and the second argument is the aspect definition expression.\n+\n+               when Aspect_Suppress   |\n+                    Aspect_Unsuppress =>\n+\n+                  Ritem :=\n+                    Make_Pragma (Sloc (Aspect),\n+                      Pragma_Argument_Associations => New_List (\n+                        New_Occurrence_Of (E, Sloc (Expr)),\n+                        Relocate_Node (Expr)),\n+                      Pragma_Identifier            =>\n+                         Make_Identifier (Sloc (Id), Chars (Id)));\n+\n+               --  Aspects corresponding to pragmas with two arguments, where\n+               --  the second argument is a local name referring to the entity,\n+               --  and the first argument is the aspect definition expression.\n+\n+               when Aspect_Warnings =>\n+\n+                  Ritem :=\n+                    Make_Pragma (Sloc (Aspect),\n+                      Pragma_Argument_Associations => New_List (\n+                        Relocate_Node (Expr),\n+                        New_Occurrence_Of (E, Sloc (Expr))),\n+                      Pragma_Identifier            =>\n+                         Make_Identifier (Sloc (Id), Chars (Id)));\n+\n+               --  Aspect Post corresponds to pragma Postcondition with single\n+               --  argument that is the expression (we never give a message\n+               --  argument. This is inserted right after the declaration, to\n+               --  to get the required pragma placement.\n+\n+               when Aspect_Post =>\n+\n+                  Insert_After (N,\n+                    Make_Pragma (Sloc (Expr),\n+                      Pragma_Argument_Associations => New_List (\n+                        Relocate_Node (Expr)),\n+                      Pragma_Identifier            =>\n+                         Make_Identifier (Sloc (Id), Name_Postcondition)));\n+                  goto Continue;\n+\n+               --  Aspect Pre corresponds to pragma Precondition with single\n+               --  argument that is the expression (we never give a message\n+               --  argument. This is inserted right after the declaration, to\n+               --  get the required pragma placement.\n+\n+               when Aspect_Pre =>\n+\n+                  Insert_After (N,\n+                    Make_Pragma (Sloc (Expr),\n+                      Pragma_Argument_Associations => New_List (\n+                        Relocate_Node (Expr)),\n+                      Pragma_Identifier            =>\n+                        Make_Identifier (Sloc (Id), Name_Precondition)));\n+                  goto Continue;\n+\n+               --  Aspects currently unimplemented\n+\n+               when Aspect_Invariant |\n+                    Aspect_Predicate =>\n+\n+                  Error_Msg_N (\"aspect& not implemented\", Identifier (Aspect));\n+                  goto Continue;\n+            end case;\n+\n+            Set_From_Aspect_Specification (Ritem);\n+            Insert_After (Ins_Node, Ritem);\n+            Ins_Node := Ritem;\n+         end;\n+\n+         <<Continue>>\n+            Next (Aspect);\n+      end loop;\n+   end Analyze_Aspect_Specifications;\n+\n    -----------------------\n    -- Analyze_At_Clause --\n    -----------------------\n@@ -684,6 +896,12 @@ package body Sem_Ch13 is\n       --  Common processing for 'Read, 'Write, 'Input and 'Output attribute\n       --  definition clauses.\n \n+      function Duplicate_Clause return Boolean;\n+      --  This routine checks if the aspect for U_Ent being given by attribute\n+      --  definition clause N is for an aspect that has already been specified,\n+      --  and if so gives an error message. If there is a duplicate, True is\n+      --  returned, otherwise if there is no error, False is returned.\n+\n       -----------------------------------\n       -- Analyze_Stream_TSS_Definition --\n       -----------------------------------\n@@ -820,6 +1038,40 @@ package body Sem_Ch13 is\n          end if;\n       end Analyze_Stream_TSS_Definition;\n \n+      ----------------------\n+      -- Duplicate_Clause --\n+      ----------------------\n+\n+      function Duplicate_Clause return Boolean is\n+         A   : constant Node_Id :=\n+                 Get_Attribute_Definition_Clause\n+                   (U_Ent, Get_Attribute_Id (Chars (N)));\n+\n+      begin\n+         --  Nothing to do if this attribute definition clause comes from an\n+         --  aspect specification, since we could not be duplicating an\n+         --  explicit clause, and we dealt with the case of duplicated aspects\n+         --  in Analyze_Aspect_Specifications.\n+\n+         if From_Aspect_Specification (N) then\n+            return False;\n+         end if;\n+\n+         --  Otherwise current pragma may duplicate previous pragma or a\n+         --  previously given aspect specification for the same pragma.\n+\n+         if Present (A) then\n+            if Entity (A) = U_Ent then\n+               Error_Msg_Name_1 := Chars (N);\n+               Error_Msg_Sloc := Sloc (A);\n+               Error_Msg_NE (\"aspect% for & previously specified#\", N, U_Ent);\n+               return True;\n+            end if;\n+         end if;\n+\n+         return False;\n+      end Duplicate_Clause;\n+\n    --  Start of processing for Analyze_Attribute_Definition_Clause\n \n    begin\n@@ -928,6 +1180,8 @@ package body Sem_Ch13 is\n          return;\n       end if;\n \n+      Set_Entity (N, U_Ent);\n+\n       --  Switch on particular attribute\n \n       case Id is\n@@ -969,8 +1223,8 @@ package body Sem_Ch13 is\n                return;\n             end if;\n \n-            if Present (Address_Clause (U_Ent)) then\n-               Error_Msg_N (\"address already given for &\", Nam);\n+            if Duplicate_Clause then\n+               null;\n \n             --  Case of address clause for subprogram\n \n@@ -1235,9 +1489,8 @@ package body Sem_Ch13 is\n             then\n                Error_Msg_N (\"alignment cannot be given for &\", Nam);\n \n-            elsif Has_Alignment_Clause (U_Ent) then\n-               Error_Msg_Sloc := Sloc (Alignment_Clause (U_Ent));\n-               Error_Msg_N (\"alignment clause previously given#\", N);\n+            elsif Duplicate_Clause then\n+               null;\n \n             elsif Align /= No_Uint then\n                Set_Has_Alignment_Clause (U_Ent);\n@@ -1266,6 +1519,9 @@ package body Sem_Ch13 is\n                Error_Msg_N\n                  (\"Bit_Order can only be defined for record type\", Nam);\n \n+            elsif Duplicate_Clause then\n+               null;\n+\n             else\n                Analyze_And_Resolve (Expr, RTE (RE_Bit_Order));\n \n@@ -1307,9 +1563,8 @@ package body Sem_Ch13 is\n             Btype := Base_Type (U_Ent);\n             Ctyp := Component_Type (Btype);\n \n-            if Has_Component_Size_Clause (Btype) then\n-               Error_Msg_N\n-                 (\"component size clause for& previously given\", Nam);\n+            if Duplicate_Clause then\n+               null;\n \n             elsif Rep_Item_Too_Early (Btype, N) then\n                null;\n@@ -1391,28 +1646,33 @@ package body Sem_Ch13 is\n                Error_Msg_N (\"should be a tagged type\", Nam);\n             end if;\n \n-            Analyze_And_Resolve (Expr, Standard_String);\n-\n-            if not Is_Static_Expression (Expr) then\n-               Flag_Non_Static_Expr\n-                 (\"static string required for tag name!\", Nam);\n-            end if;\n+            if Duplicate_Clause then\n+               null;\n \n-            if VM_Target = No_VM then\n-               Set_Has_External_Tag_Rep_Clause (U_Ent);\n             else\n-               Error_Msg_Name_1 := Attr;\n-               Error_Msg_N\n-                 (\"% attribute unsupported in this configuration\", Nam);\n-            end if;\n+               Analyze_And_Resolve (Expr, Standard_String);\n \n-            if not Is_Library_Level_Entity (U_Ent) then\n-               Error_Msg_NE\n-                 (\"?non-unique external tag supplied for &\", N, U_Ent);\n-               Error_Msg_N\n-                 (\"?\\same external tag applies to all subprogram calls\", N);\n-               Error_Msg_N\n-                 (\"?\\corresponding internal tag cannot be obtained\", N);\n+               if not Is_Static_Expression (Expr) then\n+                  Flag_Non_Static_Expr\n+                    (\"static string required for tag name!\", Nam);\n+               end if;\n+\n+               if VM_Target = No_VM then\n+                  Set_Has_External_Tag_Rep_Clause (U_Ent);\n+               else\n+                  Error_Msg_Name_1 := Attr;\n+                  Error_Msg_N\n+                    (\"% attribute unsupported in this configuration\", Nam);\n+               end if;\n+\n+               if not Is_Library_Level_Entity (U_Ent) then\n+                  Error_Msg_NE\n+                    (\"?non-unique external tag supplied for &\", N, U_Ent);\n+                  Error_Msg_N\n+                    (\"?\\same external tag applies to all subprogram calls\", N);\n+                  Error_Msg_N\n+                    (\"?\\corresponding internal tag cannot be obtained\", N);\n+               end if;\n             end if;\n          end External_Tag;\n \n@@ -1437,9 +1697,8 @@ package body Sem_Ch13 is\n             if not Is_Decimal_Fixed_Point_Type (U_Ent) then\n                Error_Msg_N (\"decimal fixed-point type expected for &\", Nam);\n \n-            elsif Has_Machine_Radix_Clause (U_Ent) then\n-               Error_Msg_Sloc := Sloc (Alignment_Clause (U_Ent));\n-               Error_Msg_N (\"machine radix clause previously given#\", N);\n+            elsif Duplicate_Clause then\n+               null;\n \n             elsif Radix /= No_Uint then\n                Set_Has_Machine_Radix_Clause (U_Ent);\n@@ -1471,8 +1730,8 @@ package body Sem_Ch13 is\n             if not Is_Type (U_Ent) then\n                Error_Msg_N (\"Object_Size cannot be given for &\", Nam);\n \n-            elsif Has_Object_Size_Clause (U_Ent) then\n-               Error_Msg_N (\"Object_Size already given for &\", Nam);\n+            elsif Duplicate_Clause then\n+               null;\n \n             else\n                Check_Size (Expr, U_Ent, Size, Biased);\n@@ -1526,8 +1785,8 @@ package body Sem_Ch13 is\n          begin\n             FOnly := True;\n \n-            if Has_Size_Clause (U_Ent) then\n-               Error_Msg_N (\"size already given for &\", Nam);\n+            if Duplicate_Clause then\n+               null;\n \n             elsif not Is_Type (U_Ent)\n               and then Ekind (U_Ent) /= E_Variable\n@@ -1709,8 +1968,7 @@ package body Sem_Ch13 is\n                  (\"storage pool cannot be given for a derived access type\",\n                   Nam);\n \n-            elsif Has_Storage_Size_Clause (U_Ent) then\n-               Error_Msg_N (\"storage size already given for &\", Nam);\n+            elsif Duplicate_Clause then\n                return;\n \n             elsif Present (Associated_Storage_Pool (U_Ent)) then\n@@ -1839,8 +2097,8 @@ package body Sem_Ch13 is\n                  (\"storage size cannot be given for a derived access type\",\n                   Nam);\n \n-            elsif Has_Storage_Size_Clause (Btype) then\n-               Error_Msg_N (\"storage size already given for &\", Nam);\n+            elsif Duplicate_Clause then\n+               null;\n \n             else\n                Analyze_And_Resolve (Expr, Any_Integer);\n@@ -1884,8 +2142,8 @@ package body Sem_Ch13 is\n                Check_Restriction (No_Implementation_Attributes, N);\n             end if;\n \n-            if Has_Stream_Size_Clause (U_Ent) then\n-               Error_Msg_N (\"Stream_Size already given for &\", Nam);\n+            if Duplicate_Clause then\n+               null;\n \n             elsif Is_Elementary_Type (U_Ent) then\n                if Size /= System_Storage_Unit\n@@ -1929,11 +2187,8 @@ package body Sem_Ch13 is\n             if not Is_Type (U_Ent) then\n                Error_Msg_N (\"Value_Size cannot be given for &\", Nam);\n \n-            elsif Present\n-                   (Get_Attribute_Definition_Clause\n-                     (U_Ent, Attribute_Value_Size))\n-            then\n-               Error_Msg_N (\"Value_Size already given for &\", Nam);\n+            elsif Duplicate_Clause then\n+               null;\n \n             elsif Is_Array_Type (U_Ent)\n               and then not Is_Constrained (U_Ent)"}, {"sha": "108112b6f7bcf1ea071bc0c465d7ccb0f77146dc", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -36,6 +36,17 @@ package Sem_Ch13 is\n    procedure Analyze_Record_Representation_Clause       (N : Node_Id);\n    procedure Analyze_Code_Statement                     (N : Node_Id);\n \n+   procedure Analyze_Aspect_Specifications\n+     (N : Node_Id;\n+      E : Entity_Id;\n+      L : List_Id);\n+   --  This procedure is called to analyze aspect spefications for node N. E is\n+   --  the corresponding entity declared by the declaration node N, and L is\n+   --  the list of aspect specifications for this node. If L is No_List, the\n+   --  call is ignored. Note that we can't use a simpler interface of just\n+   --  passing the node N, since the analysis of the node may cause it to be\n+   --  rewritten to a node not permitting aspect specifications.\n+\n    procedure Adjust_Record_For_Reverse_Bit_Order (R : Entity_Id);\n    --  Called from Freeze where R is a record entity for which reverse bit\n    --  order is specified and there is at least one component clause. Adjusts"}, {"sha": "30127b4386fd9a54103373f877dbff1b7b4229b6", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1627, "deletions": 1611, "changes": 3238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171"}, {"sha": "7d163c1b90b31f2362d57dce9cc3f8746cf68d1b", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -28,14 +28,14 @@ with Types;  use Types;\n \n package Sem_Ch3 is\n    procedure Analyze_Component_Declaration         (N : Node_Id);\n+   procedure Analyze_Full_Type_Declaration         (N : Node_Id);\n    procedure Analyze_Incomplete_Type_Decl          (N : Node_Id);\n    procedure Analyze_Itype_Reference               (N : Node_Id);\n    procedure Analyze_Number_Declaration            (N : Node_Id);\n    procedure Analyze_Object_Declaration            (N : Node_Id);\n    procedure Analyze_Others_Choice                 (N : Node_Id);\n    procedure Analyze_Private_Extension_Declaration (N : Node_Id);\n    procedure Analyze_Subtype_Indication            (N : Node_Id);\n-   procedure Analyze_Type_Declaration              (N : Node_Id);\n    procedure Analyze_Variant_Part                  (N : Node_Id);\n \n    procedure Analyze_Subtype_Declaration"}, {"sha": "58cfae3957768c668c93d52928c0a0810119a0ee", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n@@ -59,6 +60,7 @@ with Sem_Ch5;  use Sem_Ch5;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch10; use Sem_Ch10;\n with Sem_Ch12; use Sem_Ch12;\n+with Sem_Ch13; use Sem_Ch13;\n with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n with Sem_Elim; use Sem_Elim;\n@@ -352,6 +354,7 @@ package body Sem_Ch6 is\n       Designator : constant Entity_Id :=\n                      Analyze_Subprogram_Specification (Specification (N));\n       Scop       : constant Entity_Id := Current_Scope;\n+      AS         : constant List_Id   := Aspect_Specifications (N);\n \n    begin\n       Generate_Definition (Designator);\n@@ -381,6 +384,7 @@ package body Sem_Ch6 is\n \n       Generate_Reference_To_Formals (Designator);\n       Check_Eliminated (Designator);\n+      Analyze_Aspect_Specifications (N, Designator, AS);\n    end Analyze_Abstract_Subprogram_Declaration;\n \n    ----------------------------------------\n@@ -2696,9 +2700,10 @@ package body Sem_Ch6 is\n \n    procedure Analyze_Subprogram_Declaration (N : Node_Id) is\n       Loc        : constant Source_Ptr := Sloc (N);\n+      AS         : constant List_Id    := Aspect_Specifications (N);\n+      Scop       : constant Entity_Id  := Current_Scope;\n       Designator : Entity_Id;\n       Form       : Node_Id;\n-      Scop       : constant Entity_Id := Current_Scope;\n       Null_Body  : Node_Id := Empty;\n \n    --  Start of processing for Analyze_Subprogram_Declaration\n@@ -2891,6 +2896,8 @@ package body Sem_Ch6 is\n          Write_Location (Sloc (N));\n          Write_Eol;\n       end if;\n+\n+      Analyze_Aspect_Specifications (N, Designator, AS);\n    end Analyze_Subprogram_Declaration;\n \n    --------------------------------------\n@@ -8334,20 +8341,19 @@ package body Sem_Ch6 is\n                      if Is_Tagged_Type (Formal_Type) then\n                         null;\n \n-                     elsif Nkind_In (Parent (Parent (T)),\n-                        N_Accept_Statement,\n-                        N_Entry_Body,\n-                        N_Subprogram_Body)\n+                     elsif Nkind_In (Parent (Parent (T)), N_Accept_Statement,\n+                                                          N_Entry_Body,\n+                                                          N_Subprogram_Body)\n                      then\n                         Error_Msg_NE\n                           (\"invalid use of untagged incomplete type&\",\n-                             Ptype, Formal_Type);\n+                           Ptype, Formal_Type);\n                      end if;\n \n                   else\n                      Error_Msg_NE\n                        (\"invalid use of incomplete type&\",\n-                          Param_Spec, Formal_Type);\n+                        Param_Spec, Formal_Type);\n \n                      --  Further checks on the legality of incomplete types\n                      --  in formal parts are delayed until the freeze point\n@@ -8356,8 +8362,9 @@ package body Sem_Ch6 is\n                end if;\n \n             elsif Ekind (Formal_Type) = E_Void then\n-               Error_Msg_NE (\"premature use of&\",\n-                 Parameter_Type (Param_Spec), Formal_Type);\n+               Error_Msg_NE\n+                 (\"premature use of&\",\n+                  Parameter_Type (Param_Spec), Formal_Type);\n             end if;\n \n             --  Ada 2005 (AI-231): Create and decorate an internal subtype\n@@ -8378,8 +8385,7 @@ package body Sem_Ch6 is\n                   then\n                      Error_Msg_NE\n                        (\"`NOT NULL` not allowed (& already excludes null)\",\n-                        Param_Spec,\n-                        Formal_Type);\n+                        Param_Spec, Formal_Type);\n                   end if;\n \n                   Formal_Type :="}, {"sha": "fc20f72cbf0a9f6bbdc6ff848cf6a4e8149f2db3", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -28,6 +28,7 @@\n --  handling of private and full declarations, and the construction of dispatch\n --  tables for tagged types.\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n@@ -51,6 +52,7 @@ with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch10; use Sem_Ch10;\n with Sem_Ch12; use Sem_Ch12;\n+with Sem_Ch13; use Sem_Ch13;\n with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n with Sem_Prag; use Sem_Prag;\n@@ -749,6 +751,7 @@ package body Sem_Ch7 is\n \n    procedure Analyze_Package_Declaration (N : Node_Id) is\n       Id : constant Node_Id := Defining_Entity (N);\n+      AS : constant List_Id := Aspect_Specifications (N);\n \n       PF : Boolean;\n       --  True when in the context of a declared pure library unit\n@@ -768,7 +771,7 @@ package body Sem_Ch7 is\n       --     package Pkg is ...\n \n       if From_With_Type (Id) then\n-         return;\n+         goto Leave;\n       end if;\n \n       if Debug_Flag_C then\n@@ -842,6 +845,8 @@ package body Sem_Ch7 is\n          Write_Location (Sloc (N));\n          Write_Eol;\n       end if;\n+\n+      <<Leave>> Analyze_Aspect_Specifications (N, Id, AS);\n    end Analyze_Package_Declaration;\n \n    -----------------------------------\n@@ -1412,6 +1417,7 @@ package body Sem_Ch7 is\n    procedure Analyze_Private_Type_Declaration (N : Node_Id) is\n       PF : constant Boolean   := Is_Pure (Enclosing_Lib_Unit_Entity);\n       Id : constant Entity_Id := Defining_Identifier (N);\n+      AS : constant List_Id   := Aspect_Specifications (N);\n \n    begin\n       Generate_Definition (Id);\n@@ -1426,6 +1432,7 @@ package body Sem_Ch7 is\n \n       New_Private_Type (N, Id, N);\n       Set_Depends_On_Private (Id);\n+      Analyze_Aspect_Specifications (N, Id, AS);\n    end Analyze_Private_Type_Declaration;\n \n    ----------------------------------"}, {"sha": "02f4483637960fa03f192bfaad952d3eead83b87", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n@@ -44,6 +45,7 @@ with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch5;  use Sem_Ch5;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n@@ -873,6 +875,7 @@ package body Sem_Ch9 is\n       D_Sdef  : constant Node_Id   := Discrete_Subtype_Definition (N);\n       Def_Id  : constant Entity_Id := Defining_Identifier (N);\n       Formals : constant List_Id   := Parameter_Specifications (N);\n+      AS      : constant List_Id   := Aspect_Specifications (N);\n \n    begin\n       Generate_Definition (Def_Id);\n@@ -904,6 +907,7 @@ package body Sem_Ch9 is\n       end if;\n \n       Generate_Reference_To_Formals (Def_Id);\n+      Analyze_Aspect_Specifications (N, Def_Id, AS);\n    end Analyze_Entry_Declaration;\n \n    ---------------------------------------\n@@ -1122,19 +1126,20 @@ package body Sem_Ch9 is\n       Process_End_Label (N, 'e', Current_Scope);\n    end Analyze_Protected_Definition;\n \n-   ----------------------------\n-   -- Analyze_Protected_Type --\n-   ----------------------------\n+   ----------------------------------------\n+   -- Analyze_Protected_Type_Declaration --\n+   ----------------------------------------\n \n-   procedure Analyze_Protected_Type (N : Node_Id) is\n+   procedure Analyze_Protected_Type_Declaration (N : Node_Id) is\n       Def_Id : constant Entity_Id := Defining_Identifier (N);\n+      AS     : constant List_Id   := Aspect_Specifications (N);\n       E      : Entity_Id;\n       T      : Entity_Id;\n \n    begin\n       if No_Run_Time_Mode then\n          Error_Msg_CRT (\"protected type\", N);\n-         return;\n+         goto Leave;\n       end if;\n \n       Tasking_Used := True;\n@@ -1254,7 +1259,9 @@ package body Sem_Ch9 is\n             Process_Full_View (N, T, Def_Id);\n          end if;\n       end if;\n-   end Analyze_Protected_Type;\n+\n+      <<Leave>> Analyze_Aspect_Specifications (N, Def_Id, AS);\n+   end Analyze_Protected_Type_Declaration;\n \n    ---------------------\n    -- Analyze_Requeue --\n@@ -1651,13 +1658,14 @@ package body Sem_Ch9 is\n       end if;\n    end Analyze_Selective_Accept;\n \n-   ------------------------------\n-   -- Analyze_Single_Protected --\n-   ------------------------------\n+   ------------------------------------------\n+   -- Analyze_Single_Protected_Declaration --\n+   ------------------------------------------\n \n-   procedure Analyze_Single_Protected (N : Node_Id) is\n+   procedure Analyze_Single_Protected_Declaration (N : Node_Id) is\n       Loc    : constant Source_Ptr := Sloc (N);\n       Id     : constant Node_Id    := Defining_Identifier (N);\n+      AS     : constant List_Id    := Aspect_Specifications (N);\n       T      : Entity_Id;\n       T_Decl : Node_Id;\n       O_Decl : Node_Id;\n@@ -1704,16 +1712,18 @@ package body Sem_Ch9 is\n       --  procedure directly. Otherwise the node would be expanded twice, with\n       --  disastrous result.\n \n-      Analyze_Protected_Type (N);\n-   end Analyze_Single_Protected;\n+      Analyze_Protected_Type_Declaration (N);\n+      Analyze_Aspect_Specifications (N, Id, AS);\n+   end Analyze_Single_Protected_Declaration;\n \n-   -------------------------\n-   -- Analyze_Single_Task --\n-   -------------------------\n+   -------------------------------------\n+   -- Analyze_Single_Task_Declaration --\n+   -------------------------------------\n \n-   procedure Analyze_Single_Task (N : Node_Id) is\n+   procedure Analyze_Single_Task_Declaration (N : Node_Id) is\n       Loc    : constant Source_Ptr := Sloc (N);\n       Id     : constant Node_Id    := Defining_Identifier (N);\n+      AS     : constant List_Id    := Aspect_Specifications (N);\n       T      : Entity_Id;\n       T_Decl : Node_Id;\n       O_Decl : Node_Id;\n@@ -1768,8 +1778,9 @@ package body Sem_Ch9 is\n       --  procedure directly. Otherwise the node would be expanded twice, with\n       --  disastrous result.\n \n-      Analyze_Task_Type (N);\n-   end Analyze_Single_Task;\n+      Analyze_Task_Type_Declaration (N);\n+      Analyze_Aspect_Specifications (N, Id, AS);\n+   end Analyze_Single_Task_Declaration;\n \n    -----------------------\n    -- Analyze_Task_Body --\n@@ -1935,12 +1946,13 @@ package body Sem_Ch9 is\n       Process_End_Label (N, 'e', Current_Scope);\n    end Analyze_Task_Definition;\n \n-   -----------------------\n-   -- Analyze_Task_Type --\n-   -----------------------\n+   -----------------------------------\n+   -- Analyze_Task_Type_Declaration --\n+   -----------------------------------\n \n-   procedure Analyze_Task_Type (N : Node_Id) is\n+   procedure Analyze_Task_Type_Declaration (N : Node_Id) is\n       Def_Id : constant Entity_Id := Defining_Identifier (N);\n+      AS     : constant List_Id   := Aspect_Specifications (N);\n       T      : Entity_Id;\n \n    begin\n@@ -2038,7 +2050,9 @@ package body Sem_Ch9 is\n             Process_Full_View (N, T, Def_Id);\n          end if;\n       end if;\n-   end Analyze_Task_Type;\n+\n+      Analyze_Aspect_Specifications (N, Def_Id, AS);\n+   end Analyze_Task_Type_Declaration;\n \n    -----------------------------------\n    -- Analyze_Terminate_Alternative --"}, {"sha": "34e921f69b6329a9b4c5aa623868cf6076436f1b", "filename": "gcc/ada/sem_ch9.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.ads?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,14 +41,14 @@ package Sem_Ch9  is\n    procedure Analyze_Entry_Index_Specification          (N : Node_Id);\n    procedure Analyze_Protected_Body                     (N : Node_Id);\n    procedure Analyze_Protected_Definition               (N : Node_Id);\n-   procedure Analyze_Protected_Type                     (N : Node_Id);\n+   procedure Analyze_Protected_Type_Declaration         (N : Node_Id);\n    procedure Analyze_Requeue                            (N : Node_Id);\n    procedure Analyze_Selective_Accept                   (N : Node_Id);\n-   procedure Analyze_Single_Protected                   (N : Node_Id);\n-   procedure Analyze_Single_Task                        (N : Node_Id);\n+   procedure Analyze_Single_Protected_Declaration       (N : Node_Id);\n+   procedure Analyze_Single_Task_Declaration            (N : Node_Id);\n    procedure Analyze_Task_Body                          (N : Node_Id);\n    procedure Analyze_Task_Definition                    (N : Node_Id);\n-   procedure Analyze_Task_Type                          (N : Node_Id);\n+   procedure Analyze_Task_Type_Declaration              (N : Node_Id);\n    procedure Analyze_Terminate_Alternative              (N : Node_Id);\n    procedure Analyze_Timed_Entry_Call                   (N : Node_Id);\n    procedure Analyze_Triggering_Alternative             (N : Node_Id);"}, {"sha": "6a613f9794886631fa631328ea29ac21ce431eee", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 398, "deletions": 215, "changes": 613, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -287,6 +287,13 @@ package body Sem_Prag is\n       Pname   : constant Name_Id    := Pragma_Name (N);\n       Prag_Id : Pragma_Id;\n \n+      Sense : constant Boolean := not Aspect_Cancel (N);\n+      --  Sense is True if we have the normal case of a pragma that is active\n+      --  and turns the corresponding aspect on. It is false only for the case\n+      --  of a pragma coming from an aspect which is explicitly turned off by\n+      --  using aspect => False. If Sense is False, the effect of the pragma\n+      --  is to turn the corresponding aspect off.\n+\n       Pragma_Exit : exception;\n       --  This exception is used to exit pragma processing completely. It is\n       --  used when an error is detected, and no further processing is\n@@ -410,7 +417,7 @@ package body Sem_Prag is\n       procedure Check_Duplicate_Pragma (E : Entity_Id);\n       --  Check if a pragma of the same name as the current pragma is already\n       --  chained as a rep pragma to the given entity. if so give a message\n-      --  about the duplicate, using Error_Pragma so the call does not return.\n+      --  about the duplicate, and then raise Pragma_Exit so does not return.\n \n       procedure Check_Duplicated_Export_Name (Nam : Node_Id);\n       --  Nam is an N_String_Literal node containing the external name set by\n@@ -562,6 +569,14 @@ package body Sem_Prag is\n       --  procedure identified by Name, returns it if it exists, otherwise\n       --  errors out and uses Arg as the pragma argument for the message.\n \n+      procedure Fix_Error (Msg : in out String);\n+      --  This is called prior to issuing an error message. Msg is a string\n+      --  which typically contains the substring pragma. If the current pragma\n+      --  comes from an aspect, each such \"pragma\" substring is replaced with\n+      --  the characters \"aspect\", and in addition, if Error_Msg_Name_1 is\n+      --  Name_Precondition (resp Name_Postcondition) it is replaced with\n+      --  Name_Pre (resp Name_Post).\n+\n       procedure Gather_Associations\n         (Names : Name_List;\n          Args  : out Args_List);\n@@ -817,10 +832,16 @@ package body Sem_Prag is\n \n             else\n                Error_Msg_Name_1 := Pname;\n-               Flag_Non_Static_Expr\n-                 (\"argument for pragma% must be a identifier or \" &\n-                  \"static string expression!\", Argx);\n-               raise Pragma_Exit;\n+\n+               declare\n+                  Msg : String :=\n+                          \"argument for pragma% must be a identifier or \"\n+                          & \"static string expression!\";\n+               begin\n+                  Fix_Error (Msg);\n+                  Flag_Non_Static_Expr (Msg, Argx);\n+                  raise Pragma_Exit;\n+               end;\n             end if;\n          end if;\n       end Check_Arg_Is_External_Name;\n@@ -864,7 +885,7 @@ package body Sem_Prag is\n       begin\n          Check_Arg_Is_Local_Name (Arg);\n \n-         if not Is_Library_Level_Entity (Entity (Expression (Arg)))\n+         if not Is_Library_Level_Entity (Entity (Get_Pragma_Arg (Arg)))\n            and then Comes_From_Source (N)\n          then\n             Error_Pragma_Arg\n@@ -1033,8 +1054,15 @@ package body Sem_Prag is\n \n          else\n             Error_Msg_Name_1 := Pname;\n-            Flag_Non_Static_Expr\n-              (\"argument for pragma% must be a static expression!\", Argx);\n+\n+            declare\n+               Msg : String :=\n+                       \"argument for pragma% must be a static expression!\";\n+            begin\n+               Fix_Error (Msg);\n+               Flag_Non_Static_Expr (Msg, Argx);\n+            end;\n+\n             raise Pragma_Exit;\n          end if;\n       end Check_Arg_Is_Static_Expression;\n@@ -1208,6 +1236,17 @@ package body Sem_Prag is\n          Arg : Node_Id;\n \n       begin\n+         --  Nothing to do if this pragma comes from an aspect specification,\n+         --  since we could not be duplicating a pragma, and we dealt with the\n+         --  case of duplicated aspects in Analyze_Aspect_Specifications.\n+\n+         if From_Aspect_Specification (N) then\n+            return;\n+         end if;\n+\n+         --  Otherwise current pragma may duplicate previous pragma or a\n+         --  previously given aspect specification for the same pragma.\n+\n          if Present (P) then\n \n             --  Make sure pragma is for this entity, and not for some parent\n@@ -1220,7 +1259,13 @@ package body Sem_Prag is\n             then\n                Error_Msg_Name_1 := Pname;\n                Error_Msg_Sloc := Sloc (P);\n-               Error_Msg_NE (\"pragma% for & duplicates one#\", N, E);\n+\n+               if From_Aspect_Specification (P) then\n+                  Error_Msg_NE (\"aspect% for & previously specified#\", N, E);\n+               else\n+                  Error_Msg_NE (\"pragma% for & duplicates pragma#\", N, E);\n+               end if;\n+\n                raise Pragma_Exit;\n             end if;\n          end if;\n@@ -1301,7 +1346,7 @@ package body Sem_Prag is\n       ---------------------------------------\n \n       procedure Check_Interrupt_Or_Attach_Handler is\n-         Arg1_X : constant Node_Id := Expression (Arg1);\n+         Arg1_X : constant Node_Id := Get_Pragma_Arg (Arg1);\n          Handler_Proc, Proc_Scope : Entity_Id;\n \n       begin\n@@ -1402,7 +1447,9 @@ package body Sem_Prag is\n \n       procedure Check_No_Identifier (Arg : Node_Id) is\n       begin\n-         if Chars (Arg) /= No_Name then\n+         if Nkind (Arg) = N_Pragma_Argument_Association\n+           and then Chars (Arg) /= No_Name\n+         then\n             Error_Pragma_Arg_Ident\n               (\"pragma% does not permit identifier& here\", Arg);\n          end if;\n@@ -1706,7 +1753,7 @@ package body Sem_Prag is\n                   Unit_Node := Unit (Parent (Parent_Node));\n                   Unit_Kind := Nkind (Unit_Node);\n \n-                  Analyze (Expression (Arg1));\n+                  Analyze (Get_Pragma_Arg (Arg1));\n \n                   if Unit_Kind = N_Generic_Subprogram_Declaration\n                     or else Unit_Kind = N_Subprogram_Declaration\n@@ -1721,7 +1768,7 @@ package body Sem_Prag is\n                   end if;\n \n                   if Chars (Unit_Name) /=\n-                     Chars (Entity (Expression (Arg1)))\n+                     Chars (Entity (Get_Pragma_Arg (Arg1)))\n                   then\n                      Error_Pragma_Arg\n                        (\"pragma% argument is not current unit name\", Arg1);\n@@ -1779,9 +1826,9 @@ package body Sem_Prag is\n                      Pragma_Misplaced;\n \n                   elsif Arg_Count > 0 then\n-                     Analyze (Expression (Arg1));\n+                     Analyze (Get_Pragma_Arg (Arg1));\n \n-                     if Entity (Expression (Arg1)) /= Current_Scope then\n+                     if Entity (Get_Pragma_Arg (Arg1)) /= Current_Scope then\n                         Error_Pragma_Arg\n                           (\"name in pragma% must be enclosing unit\", Arg1);\n                      end if;\n@@ -1834,9 +1881,11 @@ package body Sem_Prag is\n       ------------------\n \n       procedure Error_Pragma (Msg : String) is\n+         MsgF : String := Msg;\n       begin\n          Error_Msg_Name_1 := Pname;\n-         Error_Msg_N (Msg, N);\n+         Fix_Error (MsgF);\n+         Error_Msg_N (MsgF, N);\n          raise Pragma_Exit;\n       end Error_Pragma;\n \n@@ -1845,16 +1894,20 @@ package body Sem_Prag is\n       ----------------------\n \n       procedure Error_Pragma_Arg (Msg : String; Arg : Node_Id) is\n+         MsgF : String := Msg;\n       begin\n          Error_Msg_Name_1 := Pname;\n-         Error_Msg_N (Msg, Get_Pragma_Arg (Arg));\n+         Fix_Error (MsgF);\n+         Error_Msg_N (MsgF, Get_Pragma_Arg (Arg));\n          raise Pragma_Exit;\n       end Error_Pragma_Arg;\n \n       procedure Error_Pragma_Arg (Msg1, Msg2 : String; Arg : Node_Id) is\n+         MsgF : String := Msg1;\n       begin\n          Error_Msg_Name_1 := Pname;\n-         Error_Msg_N (Msg1, Get_Pragma_Arg (Arg));\n+         Fix_Error (MsgF);\n+         Error_Msg_N (MsgF, Get_Pragma_Arg (Arg));\n          Error_Pragma_Arg (Msg2, Arg);\n       end Error_Pragma_Arg;\n \n@@ -1863,9 +1916,11 @@ package body Sem_Prag is\n       ----------------------------\n \n       procedure Error_Pragma_Arg_Ident (Msg : String; Arg : Node_Id) is\n+         MsgF : String := Msg;\n       begin\n          Error_Msg_Name_1 := Pname;\n-         Error_Msg_N (Msg, Arg);\n+         Fix_Error (MsgF);\n+         Error_Msg_N (MsgF, Arg);\n          raise Pragma_Exit;\n       end Error_Pragma_Arg_Ident;\n \n@@ -1874,10 +1929,12 @@ package body Sem_Prag is\n       ----------------------\n \n       procedure Error_Pragma_Ref (Msg : String; Ref : Entity_Id) is\n+         MsgF : String := Msg;\n       begin\n          Error_Msg_Name_1 := Pname;\n+         Fix_Error (MsgF);\n          Error_Msg_Sloc   := Sloc (Ref);\n-         Error_Msg_NE (Msg, N, Ref);\n+         Error_Msg_NE (MsgF, N, Ref);\n          raise Pragma_Exit;\n       end Error_Pragma_Ref;\n \n@@ -2004,6 +2061,27 @@ package body Sem_Prag is\n          return Proc;\n       end Find_Unique_Parameterless_Procedure;\n \n+      ---------------\n+      -- Fix_Error --\n+      ---------------\n+\n+      procedure Fix_Error (Msg : in out String) is\n+      begin\n+         if From_Aspect_Specification (N) then\n+            for J in Msg'First .. Msg'Last - 5 loop\n+               if Msg (J .. J + 5) = \"pragma\" then\n+                  Msg (J .. J + 5) := \"aspect\";\n+               end if;\n+            end loop;\n+         end if;\n+\n+         if Error_Msg_Name_1 = Name_Precondition then\n+            Error_Msg_Name_1 := Name_Pre;\n+         elsif Error_Msg_Name_1 = Name_Postcondition then\n+            Error_Msg_Name_1 := Name_Post;\n+         end if;\n+      end Fix_Error;\n+\n       -------------------------\n       -- Gather_Associations --\n       -------------------------\n@@ -2032,7 +2110,7 @@ package body Sem_Prag is\n          Arg := First (Pragma_Argument_Associations (N));\n          for Index in Args'Range loop\n             exit when No (Arg) or else Chars (Arg) /= No_Name;\n-            Args (Index) := Expression (Arg);\n+            Args (Index) := Get_Pragma_Arg (Arg);\n             Next (Arg);\n          end loop;\n \n@@ -2059,7 +2137,7 @@ package body Sem_Prag is\n                         Error_Pragma_Arg\n                           (\"duplicate argument association for pragma%\", Arg);\n                      else\n-                        Args (Index) := Expression (Arg);\n+                        Args (Index) := Get_Pragma_Arg (Arg);\n                         exit;\n                      end if;\n                   end if;\n@@ -2240,9 +2318,9 @@ package body Sem_Prag is\n \n          procedure Set_Atomic (E : Entity_Id) is\n          begin\n-            Set_Is_Atomic (E);\n+            Set_Is_Atomic (E, Sense);\n \n-            if not Has_Alignment_Clause (E) then\n+            if Sense and then not Has_Alignment_Clause (E) then\n                Set_Alignment (E, Uint_0);\n             end if;\n          end Set_Atomic;\n@@ -2254,7 +2332,7 @@ package body Sem_Prag is\n          Check_No_Identifiers;\n          Check_Arg_Count (1);\n          Check_Arg_Is_Local_Name (Arg1);\n-         E_Id := Expression (Arg1);\n+         E_Id := Get_Pragma_Arg (Arg1);\n \n          if Etype (E_Id) = Any_Type then\n             return;\n@@ -2289,11 +2367,11 @@ package body Sem_Prag is\n             --  Attribute belongs on the base type. If the view of the type is\n             --  currently private, it also belongs on the underlying type.\n \n-            Set_Is_Volatile (Base_Type (E));\n-            Set_Is_Volatile (Underlying_Type (E));\n+            Set_Is_Volatile (Base_Type (E), Sense);\n+            Set_Is_Volatile (Underlying_Type (E), Sense);\n \n-            Set_Treat_As_Volatile (E);\n-            Set_Treat_As_Volatile (Underlying_Type (E));\n+            Set_Treat_As_Volatile (E, Sense);\n+            Set_Treat_As_Volatile (Underlying_Type (E), Sense);\n \n          elsif K = N_Object_Declaration\n            or else (K = N_Component_Declaration\n@@ -2304,14 +2382,15 @@ package body Sem_Prag is\n             end if;\n \n             if Prag_Id /= Pragma_Volatile then\n-               Set_Is_Atomic (E);\n+               Set_Is_Atomic (E, Sense);\n \n                --  If the object declaration has an explicit initialization, a\n                --  temporary may have to be created to hold the expression, to\n                --  ensure that access to the object remain atomic.\n \n                if Nkind (Parent (E)) = N_Object_Declaration\n                  and then Present (Expression (Parent (E)))\n+                 and then Sense\n                then\n                   Set_Has_Delayed_Freeze (E);\n                end if;\n@@ -2332,7 +2411,7 @@ package body Sem_Prag is\n                    Get_Source_File_Index (Sloc (E)) =\n                    Get_Source_File_Index (Sloc (Underlying_Type (Etype (E))))\n                then\n-                  Set_Is_Atomic (Underlying_Type (Etype (E)));\n+                  Set_Is_Atomic (Underlying_Type (Etype (E)), Sense);\n                end if;\n             end if;\n \n@@ -2715,7 +2794,7 @@ package body Sem_Prag is\n          Check_At_Least_N_Arguments (2);\n          Check_Optional_Identifier (Arg1, Name_Convention);\n          Check_Arg_Is_Identifier (Arg1);\n-         Cname := Chars (Expression (Arg1));\n+         Cname := Chars (Get_Pragma_Arg (Arg1));\n \n          --  C_Pass_By_Copy is treated as a synonym for convention C (this is\n          --  tested again below to set the critical flag).\n@@ -2725,7 +2804,7 @@ package body Sem_Prag is\n          --  Otherwise we must have something in the standard convention list\n \n          elsif Is_Convention_Name (Cname) then\n-            C := Get_Convention_Id (Chars (Expression (Arg1)));\n+            C := Get_Convention_Id (Chars (Get_Pragma_Arg (Arg1)));\n \n          --  In DEC VMS, it seems that there is an undocumented feature that\n          --  any unrecognized convention is treated as the default, which for\n@@ -2737,7 +2816,7 @@ package body Sem_Prag is\n             if Warn_On_Export_Import and not OpenVMS_On_Target then\n                Error_Msg_N\n                  (\"?unrecognized convention name, C assumed\",\n-                  Expression (Arg1));\n+                  Get_Pragma_Arg (Arg1));\n             end if;\n \n             C := Convention_C;\n@@ -2746,7 +2825,7 @@ package body Sem_Prag is\n          Check_Optional_Identifier (Arg2, Name_Entity);\n          Check_Arg_Is_Local_Name (Arg2);\n \n-         Id := Expression (Arg2);\n+         Id := Get_Pragma_Arg (Arg2);\n          Analyze (Id);\n \n          if not Is_Entity_Name (Id) then\n@@ -2923,6 +3002,10 @@ package body Sem_Prag is\n                      Generate_Reference (E1, Id, 'b');\n                   end if;\n                end if;\n+\n+               --  For aspect case, do NOT apply to homonyms\n+\n+               exit when From_Aspect_Specification (N);\n             end loop;\n          end if;\n       end Process_Convention;\n@@ -3613,7 +3696,7 @@ package body Sem_Prag is\n \n          Arg := Arg1;\n          while Present (Arg) loop\n-            Exp := Expression (Arg);\n+            Exp := Get_Pragma_Arg (Arg);\n             Analyze (Exp);\n \n             if not Is_Entity_Name (Exp)\n@@ -3643,7 +3726,7 @@ package body Sem_Prag is\n       begin\n          Process_Convention (C, Def_Id);\n          Kill_Size_Check_Code (Def_Id);\n-         Note_Possible_Modification (Expression (Arg2), Sure => False);\n+         Note_Possible_Modification (Get_Pragma_Arg (Arg2), Sure => False);\n \n          if Ekind_In (Def_Id, E_Variable, E_Constant) then\n \n@@ -3770,7 +3853,8 @@ package body Sem_Prag is\n                      --  is present, then this is handled by the back end.\n \n                      if No (Arg3) then\n-                        Check_Intrinsic_Subprogram (Def_Id, Expression (Arg2));\n+                        Check_Intrinsic_Subprogram\n+                          (Def_Id, Get_Pragma_Arg (Arg2));\n                      end if;\n                   end if;\n \n@@ -4074,6 +4158,11 @@ package body Sem_Prag is\n             --  entity (if declared in the same unit) is inlined.\n \n             if Is_Subprogram (Subp) then\n+\n+               if not Sense then\n+                  return;\n+               end if;\n+\n                Inner_Subp := Ultimate_Alias (Inner_Subp);\n \n                if In_Same_Source_Unit (Subp, Inner_Subp) then\n@@ -4134,16 +4223,16 @@ package body Sem_Prag is\n          procedure Set_Inline_Flags (Subp : Entity_Id) is\n          begin\n             if Active then\n-               Set_Is_Inlined (Subp, True);\n+               Set_Is_Inlined (Subp, Sense);\n             end if;\n \n             if not Has_Pragma_Inline (Subp) then\n-               Set_Has_Pragma_Inline (Subp);\n+               Set_Has_Pragma_Inline (Subp, Sense);\n                Effective := True;\n             end if;\n \n             if Prag_Id = Pragma_Inline_Always then\n-               Set_Has_Pragma_Inline_Always (Subp);\n+               Set_Has_Pragma_Inline_Always (Subp, Sense);\n             end if;\n          end Set_Inline_Flags;\n \n@@ -4159,7 +4248,7 @@ package body Sem_Prag is\n \n          Assoc := Arg1;\n          while Present (Assoc) loop\n-            Subp_Id := Expression (Assoc);\n+            Subp_Id := Get_Pragma_Arg (Assoc);\n             Analyze (Subp_Id);\n             Applies := False;\n \n@@ -4176,12 +4265,14 @@ package body Sem_Prag is\n                else\n                   Make_Inline (Subp);\n \n-                  while Present (Homonym (Subp))\n-                    and then Scope (Homonym (Subp)) = Current_Scope\n-                  loop\n-                     Make_Inline (Homonym (Subp));\n-                     Subp := Homonym (Subp);\n-                  end loop;\n+                  if not From_Aspect_Specification (N) then\n+                     while Present (Homonym (Subp))\n+                       and then Scope (Homonym (Subp)) = Current_Scope\n+                     loop\n+                        Make_Inline (Homonym (Subp));\n+                        Subp := Homonym (Subp);\n+                     end loop;\n+                  end if;\n                end if;\n             end if;\n \n@@ -4406,7 +4497,7 @@ package body Sem_Prag is\n       -----------------------------------------\n \n       procedure Process_Interrupt_Or_Attach_Handler is\n-         Arg1_X       : constant Node_Id   := Expression (Arg1);\n+         Arg1_X       : constant Node_Id   := Get_Pragma_Arg (Arg1);\n          Handler_Proc : constant Entity_Id := Entity (Arg1_X);\n          Proc_Scope   : constant Entity_Id := Scope (Handler_Proc);\n \n@@ -4478,7 +4569,7 @@ package body Sem_Prag is\n          Arg := Arg1;\n          while Present (Arg) loop\n             Id := Chars (Arg);\n-            Expr := Expression (Arg);\n+            Expr := Get_Pragma_Arg (Arg);\n \n             --  Case of no restriction identifier present\n \n@@ -4708,7 +4799,7 @@ package body Sem_Prag is\n          Check_No_Identifier (Arg1);\n          Check_Arg_Is_Identifier (Arg1);\n \n-         C := Get_Check_Id (Chars (Expression (Arg1)));\n+         C := Get_Check_Id (Chars (Get_Pragma_Arg (Arg1)));\n \n          if C = No_Check_Id then\n             Error_Pragma_Arg\n@@ -4766,7 +4857,7 @@ package body Sem_Prag is\n             end if;\n \n             Check_Optional_Identifier (Arg2, Name_On);\n-            E_Id := Expression (Arg2);\n+            E_Id := Get_Pragma_Arg (Arg2);\n             Analyze (E_Id);\n \n             if not Is_Entity_Name (E_Id) then\n@@ -4808,8 +4899,9 @@ package body Sem_Prag is\n                   Suppress_Unsuppress_Echeck (Alias (E), C);\n                end if;\n \n-               --  Move to next homonym\n+               --  Move to next homonym if not aspect spec case\n \n+               exit when From_Aspect_Specification (N);\n                E := Homonym (E);\n                exit when No (E);\n \n@@ -5480,7 +5572,7 @@ package body Sem_Prag is\n \n             if Arg_Count = 1 then\n                Check_Arg_Is_Local_Name (Arg1);\n-               E_Id := Expression (Arg1);\n+               E_Id := Get_Pragma_Arg (Arg1);\n \n                if Etype (E_Id) = Any_Type then\n                   return;\n@@ -5499,9 +5591,14 @@ package body Sem_Prag is\n \n                Check_Valid_Configuration_Pragma;\n \n-               --  Now set Ada 2005 mode\n+               --  Now set appropriate Ada mode\n+\n+               if Sense then\n+                  Ada_Version := Ada_2005;\n+               else\n+                  Ada_Version := Ada_Version_Default;\n+               end if;\n \n-               Ada_Version := Ada_2005;\n                Ada_Version_Explicit := Ada_2005;\n             end if;\n          end;\n@@ -5527,7 +5624,7 @@ package body Sem_Prag is\n \n             if Arg_Count = 1 then\n                Check_Arg_Is_Local_Name (Arg1);\n-               E_Id := Expression (Arg1);\n+               E_Id := Get_Pragma_Arg (Arg1);\n \n                if Etype (E_Id) = Any_Type then\n                   return;\n@@ -5547,9 +5644,14 @@ package body Sem_Prag is\n \n                Check_Valid_Configuration_Pragma;\n \n-               --  Now set Ada 2012 mode\n+               --  Now set appropriate Ada mode\n+\n+               if Sense then\n+                  Ada_Version := Ada_2012;\n+               else\n+                  Ada_Version := Ada_Version_Default;\n+               end if;\n \n-               Ada_Version := Ada_2012;\n                Ada_Version_Explicit := Ada_2012;\n             end if;\n          end;\n@@ -5620,7 +5722,7 @@ package body Sem_Prag is\n                else\n                   Arg := Next (Arg2);\n                   while Present (Arg) loop\n-                     Exp := Expression (Arg);\n+                     Exp := Get_Pragma_Arg (Arg);\n                      Analyze (Exp);\n \n                      if Is_Entity_Name (Exp) then\n@@ -5758,7 +5860,7 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Is_One_Of (Arg1, Name_On, Name_Off);\n \n-            if Chars (Expression (Arg1)) = Name_On then\n+            if Chars (Get_Pragma_Arg (Arg1)) = Name_On then\n                Assume_No_Invalid_Values := True;\n             else\n                Assume_No_Invalid_Values := False;\n@@ -5779,7 +5881,7 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_No_Identifiers;\n             Check_Arg_Is_Local_Name (Arg1);\n-            Ent := Entity (Expression (Arg1));\n+            Ent := Entity (Get_Pragma_Arg (Arg1));\n \n             --  Note: the implementation of the AST_Entry pragma could handle\n             --  the entry family case fine, but for now we are consistent with\n@@ -5882,8 +5984,8 @@ package body Sem_Prag is\n             end if;\n \n             C_Ent := Cunit_Entity (Current_Sem_Unit);\n-            Analyze (Expression (Arg1));\n-            Nm := Entity (Expression (Arg1));\n+            Analyze (Get_Pragma_Arg (Arg1));\n+            Nm := Entity (Get_Pragma_Arg (Arg1));\n \n             if not Is_Remote_Call_Interface (C_Ent)\n               and then not Is_Remote_Types (C_Ent)\n@@ -5995,7 +6097,7 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n             Check_Arg_Is_Local_Name (Arg1);\n-            E_Id := Expression (Arg1);\n+            E_Id := Get_Pragma_Arg (Arg1);\n \n             if Etype (E_Id) = Any_Type then\n                return;\n@@ -6028,10 +6130,10 @@ package body Sem_Prag is\n                   E := Base_Type (E);\n                end if;\n \n-               Set_Has_Volatile_Components (E);\n+               Set_Has_Volatile_Components (E, Sense);\n \n                if Prag_Id = Pragma_Atomic_Components then\n-                  Set_Has_Atomic_Components (E);\n+                  Set_Has_Atomic_Components (E, Sense);\n                end if;\n \n             else\n@@ -6055,24 +6157,23 @@ package body Sem_Prag is\n             else\n                Check_Interrupt_Or_Attach_Handler;\n \n-               --  The expression that designates the attribute may\n-               --  depend on a discriminant, and is therefore a per-\n-               --  object expression, to be expanded in the init proc.\n-               --  If expansion is enabled, perform semantic checks\n-               --  on a copy only.\n+               --  The expression that designates the attribute may depend on a\n+               --  discriminant, and is therefore a per- object expression, to\n+               --  be expanded in the init proc. If expansion is enabled, then\n+               --  perform semantic checks on a copy only.\n \n                if Expander_Active then\n                   declare\n                      Temp : constant Node_Id :=\n-                              New_Copy_Tree (Expression (Arg2));\n+                              New_Copy_Tree (Get_Pragma_Arg (Arg2));\n                   begin\n                      Set_Parent (Temp, N);\n                      Preanalyze_And_Resolve (Temp, RTE (RE_Interrupt_ID));\n                   end;\n \n                else\n-                  Analyze (Expression (Arg2));\n-                  Resolve (Expression (Arg2), RTE (RE_Interrupt_ID));\n+                  Analyze (Get_Pragma_Arg (Arg2));\n+                  Resolve (Get_Pragma_Arg (Arg2), RTE (RE_Interrupt_ID));\n                end if;\n \n                Process_Interrupt_Or_Attach_Handler;\n@@ -6094,7 +6195,7 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_Optional_Identifier (Arg1, \"max_size\");\n \n-            Arg := Expression (Arg1);\n+            Arg := Get_Pragma_Arg (Arg1);\n             Check_Arg_Is_Static_Expression (Arg, Any_Integer);\n \n             Val := Expr_Value (Arg);\n@@ -6174,7 +6275,7 @@ package body Sem_Prag is\n             --  compile time, and we do not want to delete this warning when we\n             --  delete the if statement.\n \n-            Expr := Expression (Arg2);\n+            Expr := Get_Pragma_Arg (Arg2);\n \n             if Expander_Active and then not Check_On then\n                Eloc := Sloc (Expr);\n@@ -6211,7 +6312,7 @@ package body Sem_Prag is\n             Check_Arg_Is_Identifier (Arg1);\n \n             declare\n-               Nam : constant Name_Id := Chars (Expression (Arg1));\n+               Nam : constant Name_Id := Chars (Get_Pragma_Arg (Arg1));\n \n             begin\n                for J in Check_Names.First .. Check_Names.Last loop\n@@ -6349,7 +6450,7 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Arg_Is_Local_Name (Arg1);\n-            E_Id := Expression (Arg1);\n+            E_Id := Get_Pragma_Arg (Arg1);\n \n             if Etype (E_Id) = Any_Type then\n                return;\n@@ -6497,7 +6598,7 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n             Check_Arg_Is_Local_Name (Arg1);\n-            Arg := Expression (Arg1);\n+            Arg := Get_Pragma_Arg (Arg1);\n \n             if not Is_Entity_Name (Arg)\n               or else not Is_Access_Type (Entity (Arg))\n@@ -6546,8 +6647,8 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg2, Name_Convention);\n             Check_Arg_Is_Identifier (Arg1);\n             Check_Arg_Is_Identifier (Arg2);\n-            Idnam := Chars (Expression (Arg1));\n-            Cname := Chars (Expression (Arg2));\n+            Idnam := Chars (Get_Pragma_Arg (Arg1));\n+            Cname := Chars (Get_Pragma_Arg (Arg2));\n \n             if Is_Convention_Name (Cname) then\n                Record_Convention_Identifier\n@@ -6580,7 +6681,7 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Arg_Is_Local_Name (Arg1);\n \n-            Arg := Expression (Arg1);\n+            Arg := Get_Pragma_Arg (Arg1);\n             Analyze (Arg);\n \n             if Etype (Arg) = Any_Type then\n@@ -6697,7 +6798,7 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Arg_Is_Local_Name (Arg1);\n \n-            Id := Expression (Arg1);\n+            Id := Get_Pragma_Arg (Arg1);\n             Find_Program_Unit_Name (Id);\n \n             --  If we did not find the name, we are done\n@@ -6819,7 +6920,7 @@ package body Sem_Prag is\n                Cond :=\n                  Make_And_Then (Loc,\n                    Left_Opnd   => Relocate_Node (Cond),\n-                   Right_Opnd  => Expression (Arg1));\n+                   Right_Opnd  => Get_Pragma_Arg (Arg1));\n             end if;\n \n             --  Rewrite into a conditional with an appropriate condition. We\n@@ -6848,7 +6949,8 @@ package body Sem_Prag is\n             GNAT_Pragma;\n             Check_Arg_Count (1);\n             Check_Arg_Is_One_Of (Arg1, Name_Check, Name_Ignore);\n-            Debug_Pragmas_Enabled := Chars (Expression (Arg1)) = Name_Check;\n+            Debug_Pragmas_Enabled :=\n+              Chars (Get_Pragma_Arg (Arg1)) = Name_Check;\n \n          ---------------------\n          -- Detect_Blocking --\n@@ -6911,15 +7013,15 @@ package body Sem_Prag is\n                   --  defined in the current declarative part, and recursively\n                   --  to any nested scope.\n \n-                  Set_Discard_Names (Current_Scope);\n+                  Set_Discard_Names (Current_Scope, Sense);\n                   return;\n \n                else\n                   Check_Arg_Count (1);\n                   Check_Optional_Identifier (Arg1, Name_On);\n                   Check_Arg_Is_Local_Name (Arg1);\n \n-                  E_Id := Expression (Arg1);\n+                  E_Id := Get_Pragma_Arg (Arg1);\n \n                   if Etype (E_Id) = Any_Type then\n                      return;\n@@ -6932,7 +7034,7 @@ package body Sem_Prag is\n                         (Is_Enumeration_Type (E) or else Is_Tagged_Type (E)))\n                     or else Ekind (E) = E_Exception\n                   then\n-                     Set_Discard_Names (E);\n+                     Set_Discard_Names (E, Sense);\n                   else\n                      Error_Pragma_Arg\n                        (\"inappropriate entity for pragma%\", Arg1);\n@@ -6997,10 +7099,10 @@ package body Sem_Prag is\n                Citem := First (List_Containing (N));\n                Inner : while Citem /= N loop\n                   if Nkind (Citem) = N_With_Clause\n-                    and then Same_Name (Name (Citem), Expression (Arg))\n+                    and then Same_Name (Name (Citem), Get_Pragma_Arg (Arg))\n                   then\n                      Set_Elaborate_Present (Citem, True);\n-                     Set_Unit_Name (Expression (Arg), Name (Citem));\n+                     Set_Unit_Name (Get_Pragma_Arg (Arg), Name (Citem));\n \n                      --  With the pragma present, elaboration calls on\n                      --  subprograms from the named unit need no further\n@@ -7079,10 +7181,10 @@ package body Sem_Prag is\n                Citem := First (List_Containing (N));\n                Innr : while Citem /= N loop\n                   if Nkind (Citem) = N_With_Clause\n-                    and then Same_Name (Name (Citem), Expression (Arg))\n+                    and then Same_Name (Name (Citem), Get_Pragma_Arg (Arg))\n                   then\n                      Set_Elaborate_All_Present (Citem, True);\n-                     Set_Unit_Name (Expression (Arg), Name (Citem));\n+                     Set_Unit_Name (Get_Pragma_Arg (Arg), Name (Citem));\n \n                      --  Suppress warnings and elaboration checks on the named\n                      --  unit if the pragma is in the current compilation, as\n@@ -7281,7 +7383,8 @@ package body Sem_Prag is\n             Process_Convention (C, Def_Id);\n \n             if Ekind (Def_Id) /= E_Constant then\n-               Note_Possible_Modification (Expression (Arg2), Sure => False);\n+               Note_Possible_Modification\n+                 (Get_Pragma_Arg (Arg2), Sure => False);\n             end if;\n \n             Process_Interface_Name (Def_Id, Arg3, Arg4);\n@@ -7619,13 +7722,13 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg1, Name_Name);\n             Check_Arg_Is_Identifier (Arg1);\n \n-            Get_Name_String (Chars (Expression (Arg1)));\n+            Get_Name_String (Chars (Get_Pragma_Arg (Arg1)));\n \n             if Name_Len > 4\n               and then Name_Buffer (1 .. 4) = \"aux_\"\n             then\n                if Present (System_Extend_Pragma_Arg) then\n-                  if Chars (Expression (Arg1)) =\n+                  if Chars (Get_Pragma_Arg (Arg1)) =\n                      Chars (Expression (System_Extend_Pragma_Arg))\n                   then\n                      null;\n@@ -7658,7 +7761,7 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Is_One_Of (Arg1, Name_On, Name_Off);\n \n-            if Chars (Expression (Arg1)) = Name_On then\n+            if Chars (Get_Pragma_Arg (Arg1)) = Name_On then\n                Extensions_Allowed := True;\n                Ada_Version := Ada_Version_Type'Last;\n \n@@ -7693,7 +7796,8 @@ package body Sem_Prag is\n             Check_At_Least_N_Arguments (2);\n             Check_At_Most_N_Arguments  (4);\n             Process_Convention (C, Def_Id);\n-            Note_Possible_Modification (Expression (Arg2), Sure => False);\n+            Note_Possible_Modification\n+              (Get_Pragma_Arg (Arg2), Sure => False);\n             Process_Interface_Name (Def_Id, Arg3, Arg4);\n             Set_Exported (Def_Id, Arg2);\n          end External;\n@@ -7761,19 +7865,22 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n             Check_Arg_Is_Local_Name (Arg1);\n-            Named_Entity := Entity (Expression (Arg1));\n+            Named_Entity := Entity (Get_Pragma_Arg (Arg1));\n \n             --  If it's an access-to-subprogram type (in particular, not a\n             --  subtype), set the flag on that type.\n \n             if Is_Access_Subprogram_Type (Named_Entity) then\n-               Set_Can_Use_Internal_Rep (Named_Entity, False);\n+               if Sense then\n+                  Set_Can_Use_Internal_Rep (Named_Entity, False);\n+               end if;\n \n             --  Otherwise it's an error (name denotes the wrong sort of entity)\n \n             else\n                Error_Pragma_Arg\n-                 (\"access-to-subprogram type expected\", Expression (Arg1));\n+                 (\"access-to-subprogram type expected\",\n+                  Get_Pragma_Arg (Arg1));\n             end if;\n          end Favor_Top_Level;\n \n@@ -7797,7 +7904,7 @@ package body Sem_Prag is\n \n          when Pragma_Finalize_Storage_Only => Finalize_Storage : declare\n             Assoc   : constant Node_Id := Arg1;\n-            Type_Id : constant Node_Id := Expression (Assoc);\n+            Type_Id : constant Node_Id := Get_Pragma_Arg (Assoc);\n             Typ     : Entity_Id;\n \n          begin\n@@ -7859,7 +7966,7 @@ package body Sem_Prag is\n             Check_Arg_Is_One_Of (Arg1, Name_VAX_Float, Name_IEEE_Float);\n \n             if not OpenVMS_On_Target then\n-               if Chars (Expression (Arg1)) = Name_VAX_Float then\n+               if Chars (Get_Pragma_Arg (Arg1)) = Name_VAX_Float then\n                   Error_Pragma\n                     (\"?pragma% ignored (applies only to Open'V'M'S)\");\n                end if;\n@@ -7870,7 +7977,7 @@ package body Sem_Prag is\n             --  One argument case\n \n             if Arg_Count = 1 then\n-               if Chars (Expression (Arg1)) = Name_VAX_Float then\n+               if Chars (Get_Pragma_Arg (Arg1)) = Name_VAX_Float then\n                   if Opt.Float_Format = 'I' then\n                      Error_Pragma (\"'I'E'E'E format previously specified\");\n                   end if;\n@@ -7905,7 +8012,7 @@ package body Sem_Prag is\n \n                --  Two arguments, VAX_Float case\n \n-               if Chars (Expression (Arg1)) = Name_VAX_Float then\n+               if Chars (Get_Pragma_Arg (Arg1)) = Name_VAX_Float then\n                   case Digs is\n                      when  6 => Set_F_Float (Ent);\n                      when  9 => Set_D_Float (Ent);\n@@ -7959,7 +8066,7 @@ package body Sem_Prag is\n                Check_Is_In_Decl_Part_Or_Package_Spec;\n             end if;\n \n-            Str := Expr_Value_S (Expression (Arg1));\n+            Str := Expr_Value_S (Get_Pragma_Arg (Arg1));\n \n             declare\n                CS : Node_Id;\n@@ -8061,7 +8168,7 @@ package body Sem_Prag is\n \n             --  Extract the name of the local procedure\n \n-            Proc_Id := Entity (Expression (Arg1));\n+            Proc_Id := Entity (Get_Pragma_Arg (Arg1));\n \n             --  Ada 2012 (AI05-0030): The procedure_LOCAL_NAME must denote a\n             --  primitive procedure of a synchronized tagged type.\n@@ -8459,7 +8566,7 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n             Check_Arg_Is_Local_Name (Arg1);\n-            E_Id := Expression (Arg1);\n+            E_Id := Get_Pragma_Arg (Arg1);\n \n             if Etype (E_Id) = Any_Type then\n                return;\n@@ -8521,7 +8628,7 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n             Check_Arg_Is_Local_Name (Arg1);\n-            E_Id := Expression (Arg1);\n+            E_Id := Get_Pragma_Arg (Arg1);\n \n             if Etype (E_Id) = Any_Type then\n                return;\n@@ -8634,7 +8741,7 @@ package body Sem_Prag is\n             if Arg_Count > 0 then\n                Arg := Arg1;\n                loop\n-                  Exp := Expression (Arg);\n+                  Exp := Get_Pragma_Arg (Arg);\n                   Analyze (Exp);\n \n                   if not Is_Entity_Name (Exp)\n@@ -8699,7 +8806,7 @@ package body Sem_Prag is\n               ((Name_Entity, Name_External_Name, Name_Link_Name));\n             Check_At_Least_N_Arguments (2);\n             Check_At_Most_N_Arguments  (3);\n-            Id := Expression (Arg1);\n+            Id := Get_Pragma_Arg (Arg1);\n             Analyze (Id);\n \n             if not Is_Entity_Name (Id) then\n@@ -8769,6 +8876,7 @@ package body Sem_Prag is\n                      Found := True;\n                   end if;\n \n+                  exit when From_Aspect_Specification (N);\n                   Hom_Id := Homonym (Hom_Id);\n \n                   exit when No (Hom_Id)\n@@ -8815,7 +8923,7 @@ package body Sem_Prag is\n             Check_Ada_83_Warning;\n \n             if Arg_Count /= 0 then\n-               Arg := Expression (Arg1);\n+               Arg := Get_Pragma_Arg (Arg1);\n                Check_Arg_Count (1);\n                Check_No_Identifiers;\n \n@@ -8990,7 +9098,7 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Arg_Is_Local_Name (Arg1);\n \n-            Id := Expression (Arg1);\n+            Id := Get_Pragma_Arg (Arg1);\n             Find_Program_Unit_Name (Id);\n \n             --  If we did not find the name, we are done\n@@ -9233,6 +9341,7 @@ package body Sem_Prag is\n                Set_Convention     (Def_Id, Convention);\n                Set_Is_Imported    (Def_Id);\n \n+               exit when From_Aspect_Specification (N);\n                Hom_Id := Homonym (Hom_Id);\n \n                exit when No (Hom_Id) or else Scope (Hom_Id) /= Current_Scope;\n@@ -9255,7 +9364,7 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Arg_Is_Local_Name (Arg1);\n \n-            Arg := Expression (Arg1);\n+            Arg := Get_Pragma_Arg (Arg1);\n             Analyze (Arg);\n \n             if Etype (Arg) = Any_Type then\n@@ -9307,7 +9416,7 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg1, Name_On);\n             Check_Arg_Is_Local_Name (Arg1);\n \n-            Arg := Expression (Arg1);\n+            Arg := Get_Pragma_Arg (Arg1);\n             Analyze (Arg);\n \n             if Etype (Arg) = Any_Type then\n@@ -9392,7 +9501,7 @@ package body Sem_Prag is\n                   Arg_Store : declare\n                      C : constant Char_Code := Get_Char_Code (' ');\n                      S : constant String_Id :=\n-                           Strval (Expr_Value_S (Expression (Arg)));\n+                           Strval (Expr_Value_S (Get_Pragma_Arg (Arg)));\n                      L : constant Nat := String_Length (S);\n                      F : Nat := 1;\n \n@@ -9465,10 +9574,10 @@ package body Sem_Prag is\n             --  by the call to Rep_Item_Too_Late (when no error is detected\n             --  and False is returned).\n \n-            if Rep_Item_Too_Late (Entity (Expression (Arg1)), N) then\n+            if Rep_Item_Too_Late (Entity (Get_Pragma_Arg (Arg1)), N) then\n                return;\n             else\n-               Set_Has_Gigi_Rep_Item (Entity (Expression (Arg1)));\n+               Set_Has_Gigi_Rep_Item (Entity (Get_Pragma_Arg (Arg1)));\n             end if;\n \n          ------------------------\n@@ -9496,7 +9605,7 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_No_Identifiers;\n             Check_Arg_Is_Local_Name (Arg1);\n-            Arg1_X := Expression (Arg1);\n+            Arg1_X := Get_Pragma_Arg (Arg1);\n             Analyze (Arg1_X);\n             Proc := Find_Unique_Parameterless_Procedure (Arg1_X, Arg1);\n \n@@ -9532,13 +9641,14 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_Is_In_Decl_Part_Or_Package_Spec;\n             Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n-            Start_String (Strval (Expr_Value_S (Expression (Arg1))));\n+            Start_String (Strval (Expr_Value_S (Get_Pragma_Arg (Arg1))));\n \n             Arg := Arg2;\n             while Present (Arg) loop\n                Check_Arg_Is_Static_Expression (Arg, Standard_String);\n                Store_String_Char (ASCII.NUL);\n-               Store_String_Chars (Strval (Expr_Value_S (Expression (Arg))));\n+               Store_String_Chars\n+                 (Strval (Expr_Value_S (Get_Pragma_Arg (Arg))));\n                Arg := Next (Arg);\n             end loop;\n \n@@ -9568,7 +9678,7 @@ package body Sem_Prag is\n \n             --  This pragma applies only to objects\n \n-            if not Is_Object (Entity (Expression (Arg1))) then\n+            if not Is_Object (Entity (Get_Pragma_Arg (Arg1))) then\n                Error_Pragma_Arg (\"pragma% applies only to objects\", Arg1);\n             end if;\n \n@@ -9577,10 +9687,10 @@ package body Sem_Prag is\n             --  by the call to Rep_Item_Too_Late (when no error is detected\n             --  and False is returned).\n \n-            if Rep_Item_Too_Late (Entity (Expression (Arg1)), N) then\n+            if Rep_Item_Too_Late (Entity (Get_Pragma_Arg (Arg1)), N) then\n                return;\n             else\n-               Set_Has_Gigi_Rep_Item (Entity (Expression (Arg1)));\n+               Set_Has_Gigi_Rep_Item (Entity (Get_Pragma_Arg (Arg1)));\n             end if;\n \n          ----------\n@@ -9611,7 +9721,7 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Is_Locking_Policy (Arg1);\n             Check_Valid_Configuration_Pragma;\n-            Get_Name_String (Chars (Expression (Arg1)));\n+            Get_Name_String (Chars (Get_Pragma_Arg (Arg1)));\n             LP := Fold_Upper (Name_Buffer (1));\n \n             if Locking_Policy /= ' '\n@@ -9651,7 +9761,7 @@ package body Sem_Prag is\n \n             --  D_Float case\n \n-            if Chars (Expression (Arg1)) = Name_D_Float then\n+            if Chars (Get_Pragma_Arg (Arg1)) = Name_D_Float then\n                if Opt.Float_Format_Long = 'G' then\n                   Error_Pragma (\"G_Float previously specified\");\n                end if;\n@@ -9697,7 +9807,7 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg2, Name_Attribute_Name);\n             Check_Arg_Is_Local_Name (Arg1);\n             Check_Arg_Is_Static_Expression (Arg2, Standard_String);\n-            Def_Id := Entity (Expression (Arg1));\n+            Def_Id := Entity (Get_Pragma_Arg (Arg1));\n \n             if Is_Access_Type (Def_Id) then\n                Def_Id := Designated_Type (Def_Id);\n@@ -9717,7 +9827,7 @@ package body Sem_Prag is\n             if Rep_Item_Too_Late (Def_Id, N) then\n                return;\n             else\n-               Set_Has_Gigi_Rep_Item (Entity (Expression (Arg1)));\n+               Set_Has_Gigi_Rep_Item (Entity (Get_Pragma_Arg (Arg1)));\n             end if;\n          end Machine_Attribute;\n \n@@ -9866,7 +9976,7 @@ package body Sem_Prag is\n             Arg := Arg1;\n             while Present (Arg) loop\n                Check_Arg_Is_Local_Name (Arg);\n-               Id := Expression (Arg);\n+               Id := Get_Pragma_Arg (Arg);\n                Analyze (Id);\n \n                if not Is_Entity_Name (Id) then\n@@ -9896,6 +10006,7 @@ package body Sem_Prag is\n                      Found := True;\n                   end if;\n \n+                  exit when From_Aspect_Specification (N);\n                   E := Homonym (E);\n                end loop;\n \n@@ -9957,7 +10068,7 @@ package body Sem_Prag is\n             else\n                Check_Optional_Identifier (Arg2, Name_Entity);\n                Check_Arg_Is_Local_Name (Arg1);\n-               E_Id := Entity (Expression (Arg1));\n+               E_Id := Entity (Get_Pragma_Arg (Arg1));\n \n                if E_Id = Any_Type then\n                   return;\n@@ -10068,7 +10179,7 @@ package body Sem_Prag is\n                   --  Deal with static string argument\n \n                   Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n-                  S := Strval (Expression (Arg1));\n+                  S := Strval (Get_Pragma_Arg (Arg1));\n \n                   for J in 1 .. String_Length (S) loop\n                      if not In_Character_Range (Get_String_Char (S, J)) then\n@@ -10079,7 +10190,7 @@ package body Sem_Prag is\n                   end loop;\n \n                   Obsolescent_Warnings.Append\n-                    ((Ent => Ent, Msg => Strval (Expression (Arg1))));\n+                    ((Ent => Ent, Msg => Strval (Get_Pragma_Arg (Arg1))));\n \n                   --  Check for Ada_05 parameter\n \n@@ -10272,7 +10383,7 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_Arg_Is_Local_Name (Arg1);\n \n-            Type_Id := Expression (Assoc);\n+            Type_Id := Get_Pragma_Arg (Assoc);\n             Find_Type (Type_Id);\n             Typ := Entity (Type_Id);\n \n@@ -10308,7 +10419,7 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_Arg_Is_Local_Name (Arg1);\n \n-            Type_Id := Expression (Assoc);\n+            Type_Id := Get_Pragma_Arg (Assoc);\n             Find_Type (Type_Id);\n             Typ := Entity (Type_Id);\n \n@@ -10325,13 +10436,11 @@ package body Sem_Prag is\n             end if;\n \n             Check_First_Subtype (Arg1);\n-\n-            if Has_Pragma_Pack (Typ) then\n-               Error_Pragma (\"duplicate pragma%, only one allowed\");\n+            Check_Duplicate_Pragma (Typ);\n \n             --  Array type\n \n-            elsif Is_Array_Type (Typ) then\n+            if Is_Array_Type (Typ) then\n                Ctyp := Component_Type (Typ);\n \n                --  Ignore pack that does nothing\n@@ -10357,36 +10466,96 @@ package body Sem_Prag is\n                   if CodePeer_Mode then\n                      null;\n \n-                  --  For normal non-VM target, do the packing\n+                  --  Don't attempt any packing for VM targets. We possibly\n+                  --  could deal with some cases of array bit-packing, but we\n+                  --  don't bother, since this is not a typical kind of\n+                  --  representation in the VM context anyway (and would not\n+                  --  for example work nicely with the debugger).\n+\n+                  elsif VM_Target /= No_VM then\n+                     if not GNAT_Mode then\n+                        Error_Pragma\n+                          (\"?pragma% ignored in this configuration\");\n+                     end if;\n \n-                  elsif VM_Target = No_VM then\n+                  --  Normal case where we do the pack action\n+\n+                  else\n                      if not Ignore then\n-                        Set_Is_Packed            (Base_Type (Typ));\n-                        Set_Has_Non_Standard_Rep (Base_Type (Typ));\n+                        Set_Is_Packed            (Base_Type (Typ), Sense);\n+                        Set_Has_Non_Standard_Rep (Base_Type (Typ), Sense);\n                      end if;\n \n-                     Set_Has_Pragma_Pack (Base_Type (Typ));\n+                     Set_Has_Pragma_Pack (Base_Type (Typ), Sense);\n \n-                  --  If we ignore the pack for VM_Targets, then warn about\n-                  --  this, except suppress the warning in GNAT mode.\n+                     --  Complete reset action for Aspect_Cancel case\n \n-                  elsif not GNAT_Mode then\n-                     Error_Pragma\n-                       (\"?pragma% ignored in this configuration\");\n+                     if Sense = False then\n+\n+                        --  Cancel size unless explicitly set\n+\n+                        if not Has_Size_Clause (Typ)\n+                           and then not Has_Object_Size_Clause (Typ)\n+                        then\n+                           Set_Esize     (Typ, Uint_0);\n+                           Set_RM_Size   (Typ, Uint_0);\n+                           Set_Alignment (Typ, Uint_0);\n+                           Set_Packed_Array_Type (Typ, Empty);\n+                        end if;\n+\n+                        --  Reset component size unless explicitly set\n+\n+                        if not Has_Component_Size_Clause (Typ) then\n+                           if Known_Static_Esize (Ctyp)\n+                             and then Known_Static_RM_Size (Ctyp)\n+                             and then Esize (Ctyp) = RM_Size (Ctyp)\n+                             and then Addressable (Esize (Ctyp))\n+                           then\n+                              Set_Component_Size\n+                                (Base_Type (Typ), Esize (Ctyp));\n+                           else\n+                              Set_Component_Size\n+                                (Base_Type (Typ), Uint_0);\n+                           end if;\n+                        end if;\n+                     end if;\n                   end if;\n                end if;\n \n             --  For record types, the pack is always effective\n \n             else pragma Assert (Is_Record_Type (Typ));\n                if not Rep_Item_Too_Late (Typ, N) then\n-                  if VM_Target = No_VM then\n-                     Set_Is_Packed            (Base_Type (Typ));\n-                     Set_Has_Pragma_Pack      (Base_Type (Typ));\n-                     Set_Has_Non_Standard_Rep (Base_Type (Typ));\n \n-                  elsif not GNAT_Mode then\n-                     Error_Pragma (\"?pragma% ignored in this configuration\");\n+                  --  Ignore pack request with warning in VM mode (skip warning\n+                  --  if we are compiling GNAT run time library).\n+\n+                  if VM_Target /= No_VM then\n+                     if not GNAT_Mode then\n+                        Error_Pragma\n+                          (\"?pragma% ignored in this configuration\");\n+                     end if;\n+\n+                  --  Normal case of pack request active\n+\n+                  else\n+                     Set_Is_Packed            (Base_Type (Typ), Sense);\n+                     Set_Has_Pragma_Pack      (Base_Type (Typ), Sense);\n+                     Set_Has_Non_Standard_Rep (Base_Type (Typ), Sense);\n+\n+                     --  Complete reset action for Aspect_Cancel case\n+\n+                     if Sense = False then\n+\n+                        --  Cancel size if not explicitly given\n+\n+                        if not Has_Size_Clause (Typ)\n+                          and then not Has_Object_Size_Clause (Typ)\n+                        then\n+                           Set_Esize     (Typ, Uint_0);\n+                           Set_Alignment (Typ, Uint_0);\n+                        end if;\n+                     end if;\n                   end if;\n                end if;\n             end if;\n@@ -10441,7 +10610,7 @@ package body Sem_Prag is\n             Check_Arg_Is_Identifier (Arg1);\n             Check_Arg_Is_Local_Name (Arg1);\n             Check_First_Subtype (Arg1);\n-            Ent := Entity (Expression (Arg1));\n+            Ent := Entity (Get_Pragma_Arg (Arg1));\n \n             if not Is_Private_Type (Ent)\n               and then not Is_Protected_Type (Ent)\n@@ -10498,15 +10667,15 @@ package body Sem_Prag is\n             if Arg_Count = 1 then\n                Check_Arg_Is_Library_Level_Local_Name (Arg1);\n \n-               if not Is_Entity_Name (Expression (Arg1))\n-                 or else\n-                  (Ekind (Entity (Expression (Arg1))) /= E_Variable\n-                    and then Ekind (Entity (Expression (Arg1))) /= E_Constant)\n+               if not Is_Entity_Name (Get_Pragma_Arg (Arg1))\n+                 or else not\n+                  Ekind_In (Entity (Get_Pragma_Arg (Arg1)), E_Variable,\n+                                                            E_Constant)\n                then\n                   Error_Pragma_Arg (\"pragma% only applies to objects\", Arg1);\n                end if;\n \n-               Ent := Entity (Expression (Arg1));\n+               Ent := Entity (Get_Pragma_Arg (Arg1));\n                Decl := Parent (Ent);\n \n                if Rep_Item_Too_Late (Ent, N) then\n@@ -10524,11 +10693,15 @@ package body Sem_Prag is\n                      Arg1);\n                end if;\n \n-               Prag :=\n-                 Make_Linker_Section_Pragma\n-                   (Ent, Sloc (N), \".persistent.bss\");\n-               Insert_After (N, Prag);\n-               Analyze (Prag);\n+               Check_Duplicate_Pragma (Ent);\n+\n+               if Sense then\n+                  Prag :=\n+                    Make_Linker_Section_Pragma\n+                      (Ent, Sloc (N), \".persistent.bss\");\n+                  Insert_After (N, Prag);\n+                  Analyze (Prag);\n+               end if;\n \n             --  Case of use as configuration pragma with no arguments\n \n@@ -10549,7 +10722,7 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_No_Identifiers;\n             Check_Arg_Is_One_Of (Arg1, Name_On, Name_Off);\n-            Polling_Required := (Chars (Expression (Arg1)) = Name_On);\n+            Polling_Required := (Chars (Get_Pragma_Arg (Arg1)) = Name_On);\n \n          -------------------\n          -- Postcondition --\n@@ -10648,6 +10821,7 @@ package body Sem_Prag is\n             end if;\n \n             Ent := Find_Lib_Unit_Name;\n+            Check_Duplicate_Pragma (Ent);\n \n             --  This filters out pragmas inside generic parent then\n             --  show up inside instantiation\n@@ -10657,8 +10831,8 @@ package body Sem_Prag is\n                               and then Present (Generic_Parent (Pa)))\n             then\n                if not Debug_Flag_U then\n-                  Set_Is_Preelaborated (Ent);\n-                  Set_Suppress_Elaboration_Warnings (Ent);\n+                  Set_Is_Preelaborated (Ent, Sense);\n+                  Set_Suppress_Elaboration_Warnings (Ent, Sense);\n                end if;\n             end if;\n          end Preelaborate;\n@@ -10720,7 +10894,7 @@ package body Sem_Prag is\n             if Nkind (P) = N_Subprogram_Body then\n                Check_In_Main_Program;\n \n-               Arg := Expression (Arg1);\n+               Arg := Get_Pragma_Arg (Arg1);\n                Analyze_And_Resolve (Arg, Standard_Integer);\n \n                --  Must be static\n@@ -10770,7 +10944,7 @@ package body Sem_Prag is\n             --  Task or Protected, must be of type Integer\n \n             elsif Nkind_In (P, N_Protected_Definition, N_Task_Definition) then\n-               Arg := Expression (Arg1);\n+               Arg := Get_Pragma_Arg (Arg1);\n \n                --  The expression must be analyzed in the special manner\n                --  described in \"Handling of Default and Per-Object\n@@ -10826,14 +11000,14 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Is_Task_Dispatching_Policy (Arg1);\n             Check_Valid_Configuration_Pragma;\n-            Get_Name_String (Chars (Expression (Arg1)));\n+            Get_Name_String (Chars (Get_Pragma_Arg (Arg1)));\n             DP := Fold_Upper (Name_Buffer (1));\n \n-            Lower_Bound := Expression (Arg2);\n+            Lower_Bound := Get_Pragma_Arg (Arg2);\n             Check_Arg_Is_Static_Expression (Lower_Bound, Standard_Integer);\n             Lower_Val := Expr_Value (Lower_Bound);\n \n-            Upper_Bound := Expression (Arg3);\n+            Upper_Bound := Get_Pragma_Arg (Arg3);\n             Check_Arg_Is_Static_Expression (Upper_Bound, Standard_Integer);\n             Upper_Val := Expr_Value (Upper_Bound);\n \n@@ -11219,7 +11393,7 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Arg_Is_Local_Name (Arg1);\n-            E_Id := Expression (Arg1);\n+            E_Id := Get_Pragma_Arg (Arg1);\n \n             if Error_Posted (E_Id) then\n                return;\n@@ -11241,18 +11415,19 @@ package body Sem_Prag is\n                        (\"pragma% requires a function name\", Arg1);\n                   end if;\n \n-                  Set_Is_Pure (Def_Id);\n+                  Set_Is_Pure (Def_Id, Sense);\n \n                   if not Has_Pragma_Pure_Function (Def_Id) then\n-                     Set_Has_Pragma_Pure_Function (Def_Id);\n-                     Effective := True;\n+                     Set_Has_Pragma_Pure_Function (Def_Id, Sense);\n+                     Effective := Sense;\n                   end if;\n \n+                  exit when From_Aspect_Specification (N);\n                   E := Homonym (E);\n                   exit when No (E) or else Scope (E) /= Current_Scope;\n                end loop;\n \n-               if not Effective\n+               if Sense and then not Effective\n                  and then Warn_On_Redundant_Constructs\n                then\n                   Error_Msg_NE\n@@ -11277,7 +11452,7 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Is_Queuing_Policy (Arg1);\n             Check_Valid_Configuration_Pragma;\n-            Get_Name_String (Chars (Expression (Arg1)));\n+            Get_Name_String (Chars (Get_Pragma_Arg (Arg1)));\n             QP := Fold_Upper (Name_Buffer (1));\n \n             if Queuing_Policy /= ' '\n@@ -11313,7 +11488,7 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n \n-            Arg := Expression (Arg1);\n+            Arg := Get_Pragma_Arg (Arg1);\n \n             --  The expression must be analyzed in the special manner described\n             --  in \"Handling of Default and Per-Object Expressions\" in sem.ads.\n@@ -11702,7 +11877,7 @@ package body Sem_Prag is\n             --  The expression must be analyzed in the special manner described\n             --  in \"Handling of Default Expressions\" in sem.ads.\n \n-            Arg := Expression (Arg1);\n+            Arg := Get_Pragma_Arg (Arg1);\n             Preanalyze_Spec_Expression (Arg, Any_Integer);\n \n             if not Is_Static_Expression (Arg) then\n@@ -11738,7 +11913,7 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_Arg_Is_Integer_Literal (Arg1);\n \n-            if Intval (Expression (Arg1)) /=\n+            if Intval (Get_Pragma_Arg (Arg1)) /=\n               UI_From_Int (Ttypes.System_Storage_Unit)\n             then\n                Error_Msg_Uint_1 := UI_From_Int (Ttypes.System_Storage_Unit);\n@@ -11772,7 +11947,7 @@ package body Sem_Prag is\n \n             begin\n                Check_Arg_Is_Local_Name (Arg);\n-               Ent := Entity (Expression (Arg));\n+               Ent := Entity (Get_Pragma_Arg (Arg));\n \n                if Has_Homonym (Ent) then\n                   Error_Pragma_Arg\n@@ -11804,9 +11979,9 @@ package body Sem_Prag is\n \n             declare\n                Typ   : constant Entity_Id :=\n-                         Underlying_Type (Entity (Expression (Arg1)));\n-               Read  : constant Entity_Id := Entity (Expression (Arg2));\n-               Write : constant Entity_Id := Entity (Expression (Arg3));\n+                         Underlying_Type (Entity (Get_Pragma_Arg (Arg1)));\n+               Read  : constant Entity_Id := Entity (Get_Pragma_Arg (Arg2));\n+               Write : constant Entity_Id := Entity (Get_Pragma_Arg (Arg3));\n \n             begin\n                Check_First_Subtype (Arg1);\n@@ -11869,7 +12044,7 @@ package body Sem_Prag is\n          --  we don't need to issue error messages here.\n \n          when Pragma_Style_Checks => Style_Checks : declare\n-            A  : constant Node_Id   := Expression (Arg1);\n+            A  : constant Node_Id   := Get_Pragma_Arg (Arg1);\n             S  : String_Id;\n             C  : Char_Code;\n \n@@ -11887,7 +12062,7 @@ package body Sem_Prag is\n                   E    : Entity_Id;\n \n                begin\n-                  E_Id := Expression (Arg2);\n+                  E_Id := Get_Pragma_Arg (Arg2);\n                   Analyze (E_Id);\n \n                   if not Is_Entity_Name (E_Id) then\n@@ -11903,7 +12078,7 @@ package body Sem_Prag is\n                   else\n                      loop\n                         Set_Suppress_Style_Checks (E,\n-                          (Chars (Expression (Arg1)) = Name_Off));\n+                          (Chars (Get_Pragma_Arg (Arg1)) = Name_Off));\n                         exit when No (Homonym (E));\n                         E := Homonym (E);\n                      end loop;\n@@ -12019,7 +12194,7 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Arg_Is_Local_Name (Arg1);\n-            Set_Debug_Info_Off (Entity (Get_Pragma_Arg (Arg1)));\n+            Set_Debug_Info_Off (Entity (Get_Pragma_Arg (Arg1)), Sense);\n \n          ----------------------------------\n          -- Suppress_Exception_Locations --\n@@ -12049,7 +12224,7 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Arg_Is_Local_Name (Arg1);\n \n-            E_Id := Expression (Arg1);\n+            E_Id := Get_Pragma_Arg (Arg1);\n \n             if Etype (E_Id) = Any_Type then\n                return;\n@@ -12106,7 +12281,7 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Is_Task_Dispatching_Policy (Arg1);\n             Check_Valid_Configuration_Pragma;\n-            Get_Name_String (Chars (Expression (Arg1)));\n+            Get_Name_String (Chars (Get_Pragma_Arg (Arg1)));\n             DP := Fold_Upper (Name_Buffer (1));\n \n             if Task_Dispatching_Policy /= ' '\n@@ -12147,9 +12322,10 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n \n-            Analyze_And_Resolve (Expression (Arg1), RTE (RE_Task_Info_Type));\n+            Analyze_And_Resolve\n+              (Get_Pragma_Arg (Arg1), RTE (RE_Task_Info_Type));\n \n-            if Etype (Expression (Arg1)) = Any_Type then\n+            if Etype (Get_Pragma_Arg (Arg1)) = Any_Type then\n                return;\n             end if;\n \n@@ -12174,7 +12350,7 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n \n-            Arg := Expression (Arg1);\n+            Arg := Get_Pragma_Arg (Arg1);\n \n             --  The expression is used in the call to Create_Task, and must be\n             --  expanded there, not in the context of the current spec. It must\n@@ -12262,7 +12438,7 @@ package body Sem_Prag is\n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Arg_Is_Library_Level_Local_Name (Arg1);\n \n-            Id := Expression (Arg1);\n+            Id := Get_Pragma_Arg (Arg1);\n             Analyze (Id);\n \n             if not Is_Entity_Name (Id)\n@@ -12318,7 +12494,7 @@ package body Sem_Prag is\n \n             if Get_Source_Unit (Loc) = Main_Unit then\n                Opt.Time_Slice_Set := True;\n-               Val := Expr_Value_R (Expression (Arg1));\n+               Val := Expr_Value_R (Get_Pragma_Arg (Arg1));\n \n                if Val <= Ureal_0 then\n                   Opt.Time_Slice_Value := 0;\n@@ -12369,7 +12545,7 @@ package body Sem_Prag is\n \n          when Pragma_Unchecked_Union => Unchecked_Union : declare\n             Assoc   : constant Node_Id := Arg1;\n-            Type_Id : constant Node_Id := Expression (Assoc);\n+            Type_Id : constant Node_Id := Get_Pragma_Arg (Assoc);\n             Typ     : Entity_Id;\n             Discr   : Entity_Id;\n             Tdef    : Node_Id;\n@@ -12433,6 +12609,7 @@ package body Sem_Prag is\n                        (\"Unchecked_Union discriminant must have default value\",\n                         Discr);\n                   end if;\n+\n                   Next_Discriminant (Discr);\n                end loop;\n \n@@ -12461,11 +12638,14 @@ package body Sem_Prag is\n                end loop;\n             end if;\n \n-            Set_Is_Unchecked_Union  (Typ, True);\n-            Set_Convention          (Typ, Convention_C);\n+            Set_Is_Unchecked_Union  (Typ, Sense);\n \n-            Set_Has_Unchecked_Union (Base_Type (Typ), True);\n-            Set_Is_Unchecked_Union  (Base_Type (Typ), True);\n+            if Sense then\n+               Set_Convention (Typ, Convention_C);\n+            end if;\n+\n+            Set_Has_Unchecked_Union (Base_Type (Typ), Sense);\n+            Set_Is_Unchecked_Union  (Base_Type (Typ), Sense);\n          end Unchecked_Union;\n \n          ------------------------\n@@ -12516,15 +12696,15 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_Optional_Identifier (Arg2, Name_Entity);\n             Check_Arg_Is_Local_Name (Arg1);\n-            E_Id := Entity (Expression (Arg1));\n+            E_Id := Entity (Get_Pragma_Arg (Arg1));\n \n             if E_Id = Any_Type then\n                return;\n             elsif No (E_Id) or else not Is_Type (E_Id) then\n                Error_Pragma_Arg (\"pragma% requires type\", Arg1);\n             end if;\n \n-            Set_Universal_Aliasing (Implementation_Base_Type (E_Id));\n+            Set_Universal_Aliasing (Implementation_Base_Type (E_Id), Sense);\n          end Universal_Alias;\n \n          --------------------\n@@ -12592,7 +12772,7 @@ package body Sem_Prag is\n                        (\"pragma% can only be applied to a variable\",\n                         Arg_Expr);\n                   else\n-                     Set_Has_Pragma_Unmodified (Arg_Ent);\n+                     Set_Has_Pragma_Unmodified (Arg_Ent, Sense);\n                   end if;\n                end if;\n \n@@ -12634,13 +12814,15 @@ package body Sem_Prag is\n                   Citem := First (List_Containing (N));\n                   while Citem /= N loop\n                      if Nkind (Citem) = N_With_Clause\n-                       and then Same_Name (Name (Citem), Expression (Arg_Node))\n+                       and then\n+                         Same_Name (Name (Citem), Get_Pragma_Arg (Arg_Node))\n                      then\n                         Set_Has_Pragma_Unreferenced\n                           (Cunit_Entity\n                              (Get_Source_Unit\n                                 (Library_Unit (Citem))));\n-                        Set_Unit_Name (Expression (Arg_Node), Name (Citem));\n+                        Set_Unit_Name\n+                          (Get_Pragma_Arg (Arg_Node), Name (Citem));\n                         exit;\n                      end if;\n \n@@ -12685,7 +12867,7 @@ package body Sem_Prag is\n                         Generate_Reference (Arg_Ent, N);\n                      end if;\n \n-                     Set_Has_Pragma_Unreferenced (Arg_Ent);\n+                     Set_Has_Pragma_Unreferenced (Arg_Ent, Sense);\n                   end if;\n \n                   Next (Arg_Node);\n@@ -12720,7 +12902,7 @@ package body Sem_Prag is\n                     (\"argument for pragma% must be type or subtype\", Arg_Node);\n                end if;\n \n-               Set_Has_Pragma_Unreferenced_Objects (Entity (Arg_Expr));\n+               Set_Has_Pragma_Unreferenced_Objects (Entity (Arg_Expr), Sense);\n                Next (Arg_Node);\n             end loop;\n          end Unreferenced_Objects;\n@@ -12768,7 +12950,7 @@ package body Sem_Prag is\n          --  pragma Validity_Checks (On | Off | ALL_CHECKS | STRING_LITERAL);\n \n          when Pragma_Validity_Checks => Validity_Checks : declare\n-            A  : constant Node_Id   := Expression (Arg1);\n+            A  : constant Node_Id   := Get_Pragma_Arg (Arg1);\n             S  : String_Id;\n             C  : Char_Code;\n \n@@ -12944,7 +13126,7 @@ package body Sem_Prag is\n                      Err  : Boolean;\n \n                   begin\n-                     E_Id := Expression (Arg2);\n+                     E_Id := Get_Pragma_Arg (Arg2);\n                      Analyze (E_Id);\n \n                      --  In the expansion of an inlined body, a reference to\n@@ -12968,9 +13150,10 @@ package body Sem_Prag is\n                         else\n                            loop\n                               Set_Warnings_Off\n-                                (E, (Chars (Expression (Arg1)) = Name_Off));\n+                                (E, (Chars (Get_Pragma_Arg (Arg1)) =\n+                                                              Name_Off));\n \n-                              if Chars (Expression (Arg1)) = Name_Off\n+                              if Chars (Get_Pragma_Arg (Arg1)) = Name_Off\n                                 and then Warn_On_Warnings_Off\n                               then\n                                  Warnings_Off_Pragmas.Append ((N, E));\n@@ -13004,7 +13187,7 @@ package body Sem_Prag is\n \n                      else\n                         String_To_Name_Buffer\n-                          (Strval (Expr_Value_S (Expression (Arg2))));\n+                          (Strval (Expr_Value_S (Get_Pragma_Arg (Arg2))));\n \n                         --  Note on configuration pragma case: If this is a\n                         --  configuration pragma, then for an OFF pragma, we\n@@ -13051,7 +13234,7 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Arg_Is_Library_Level_Local_Name (Arg1);\n-            Ent := Entity (Expression (Arg1));\n+            Ent := Entity (Get_Pragma_Arg (Arg1));\n \n             if Rep_Item_Too_Early (Ent, N) then\n                return;"}, {"sha": "5955070260a95b7a352df24eb49ccb7209bd3b95", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -3674,18 +3674,28 @@ package body Sem_Res is\n                   Apply_Range_Check (A, F_Typ);\n                end if;\n \n-               --  Ada 2005 (AI-231)\n+               --  Ada 2005 (AI-231): Note that the controlling parameter case\n+               --  already existed in Ada 95, which is partially checked\n+               --  elsewhere (see Checks), and we don't want the warning\n+               --  message to differ.\n \n-               if Ada_Version >= Ada_2005\n-                 and then Is_Access_Type (F_Typ)\n+               if Is_Access_Type (F_Typ)\n                  and then Can_Never_Be_Null (F_Typ)\n                  and then Known_Null (A)\n                then\n-                  Apply_Compile_Time_Constraint_Error\n-                    (N      => A,\n-                     Msg    => \"(Ada 2005) null not allowed in \"\n-                               & \"null-excluding formal?\",\n-                     Reason => CE_Null_Not_Allowed);\n+                  if Is_Controlling_Formal (F) then\n+                     Apply_Compile_Time_Constraint_Error\n+                       (N      => A,\n+                        Msg    => \"null value not allowed here?\",\n+                        Reason => CE_Access_Check_Failed);\n+\n+                  elsif Ada_Version >= Ada_2005 then\n+                     Apply_Compile_Time_Constraint_Error\n+                       (N      => A,\n+                        Msg    => \"(Ada 2005) null not allowed in \"\n+                                  & \"null-excluding formal?\",\n+                        Reason => CE_Null_Not_Allowed);\n+                  end if;\n                end if;\n             end if;\n "}, {"sha": "3a5ffc23be1afc1a91494b4a7b8d4f4ed6c7c5f8", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 36, "deletions": 121, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -32,10 +32,8 @@\n pragma Style_Checks (All_Checks);\n --  No subprogram ordering check, due to logical grouping\n \n-with Atree;  use Atree;\n-with Nlists; use Nlists;\n-\n-with GNAT.HTable;\n+with Aspects; use Aspects;\n+with Atree;   use Atree;\n \n package body Sinfo is\n \n@@ -56,30 +54,6 @@ package body Sinfo is\n    NT : Nodes.Table_Ptr renames Nodes.Table;\n    --  A short hand abbreviation, useful for the debugging checks\n \n-   ------------------------------------------\n-   -- Hash Table for Aspect Specifications --\n-   ------------------------------------------\n-\n-   type Hash_Range is range 0 .. 510;\n-   --  Size of hash table headers\n-\n-   function AS_Hash (F : Node_Id) return Hash_Range;\n-   --  Hash function for hash table\n-\n-   function AS_Hash (F : Node_Id) return Hash_Range is\n-   begin\n-      return Hash_Range (F mod 511);\n-   end AS_Hash;\n-\n-   package Aspect_Specifications_Hash_Table is new\n-     GNAT.HTable.Simple_HTable\n-       (Header_Num => Hash_Range,\n-        Element    => List_Id,\n-        No_Element => No_List,\n-        Key        => Node_Id,\n-        Hash       => AS_Hash,\n-        Equal      => \"=\");\n-\n    ----------------------------\n    -- Field Access Functions --\n    ----------------------------\n@@ -282,6 +256,14 @@ package body Sinfo is\n       return Node3 (N);\n    end Array_Aggregate;\n \n+   function Aspect_Cancel\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      return Flag11 (N);\n+   end Aspect_Cancel;\n+\n    function Assignment_OK\n       (N : Node_Id) return Boolean is\n    begin\n@@ -1251,14 +1233,6 @@ package body Sinfo is\n       return List1 (N);\n    end Expressions;\n \n-   function First_Aspect\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Aspect_Specification);\n-      return Flag4 (N);\n-   end First_Aspect;\n-\n    function First_Bit\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -1333,6 +1307,15 @@ package body Sinfo is\n       return Flag5 (N);\n    end Forwards_OK;\n \n+   function From_Aspect_Specification\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Attribute_Definition_Clause\n+        or else NT (N).Nkind = N_Pragma);\n+      return Flag13 (N);\n+   end From_Aspect_Specification;\n+\n    function From_At_End\n       (N : Node_Id) return Boolean is\n    begin\n@@ -1869,14 +1852,6 @@ package body Sinfo is\n       return Node2 (N);\n    end Label_Construct;\n \n-   function Last_Aspect\n-      (N : Node_Id) return Boolean is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Aspect_Specification);\n-      return Flag5 (N);\n-   end Last_Aspect;\n-\n    function Last_Bit\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -3229,6 +3204,14 @@ package body Sinfo is\n       Set_Node3_With_Parent (N, Val);\n    end Set_Array_Aggregate;\n \n+   procedure Set_Aspect_Cancel\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      Set_Flag11 (N, Val);\n+   end Set_Aspect_Cancel;\n+\n    procedure Set_Assignment_OK\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -4189,14 +4172,6 @@ package body Sinfo is\n       Set_List1_With_Parent (N, Val);\n    end Set_Expressions;\n \n-   procedure Set_First_Aspect\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Aspect_Specification);\n-      Set_Flag4 (N, Val);\n-   end Set_First_Aspect;\n-\n    procedure Set_First_Bit\n       (N : Node_Id; Val : Node_Id) is\n    begin\n@@ -4271,6 +4246,15 @@ package body Sinfo is\n       Set_Flag5 (N, Val);\n    end Set_Forwards_OK;\n \n+   procedure Set_From_Aspect_Specification\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Attribute_Definition_Clause\n+        or else NT (N).Nkind = N_Pragma);\n+      Set_Flag13 (N, Val);\n+   end Set_From_Aspect_Specification;\n+\n    procedure Set_From_At_End\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -4816,14 +4800,6 @@ package body Sinfo is\n       Set_Node4_With_Parent (N, Val);\n    end Set_Last_Bit;\n \n-   procedure Set_Last_Aspect\n-      (N : Node_Id; Val : Boolean := True) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_Aspect_Specification);\n-      Set_Flag5 (N, Val);\n-   end Set_Last_Aspect;\n-\n    procedure Set_Last_Name\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -6163,65 +6139,4 @@ package body Sinfo is\n       return Chars (Pragma_Identifier (N));\n    end Pragma_Name;\n \n-   -----------------------------------\n-   -- Permits_Aspect_Specifications --\n-   -----------------------------------\n-\n-   Has_Aspect_Specifications_Flag : constant array (Node_Kind) of Boolean :=\n-     (N_Abstract_Subprogram_Declaration        => True,\n-      N_Component_Declaration                  => True,\n-      N_Entry_Declaration                      => True,\n-      N_Exception_Declaration                  => True,\n-      N_Formal_Abstract_Subprogram_Declaration => True,\n-      N_Formal_Concrete_Subprogram_Declaration => True,\n-      N_Formal_Object_Declaration              => True,\n-      N_Formal_Package_Declaration             => True,\n-      N_Formal_Type_Declaration                => True,\n-      N_Full_Type_Declaration                  => True,\n-      N_Function_Instantiation                 => True,\n-      N_Generic_Package_Declaration            => True,\n-      N_Generic_Subprogram_Declaration         => True,\n-      N_Object_Declaration                     => True,\n-      N_Package_Declaration                    => True,\n-      N_Package_Instantiation                  => True,\n-      N_Private_Extension_Declaration          => True,\n-      N_Private_Type_Declaration               => True,\n-      N_Procedure_Instantiation                => True,\n-      N_Protected_Type_Declaration             => True,\n-      N_Single_Protected_Declaration           => True,\n-      N_Single_Task_Declaration                => True,\n-      N_Subprogram_Declaration                 => True,\n-      N_Subtype_Declaration                    => True,\n-      N_Task_Type_Declaration                  => True,\n-      others                                   => False);\n-\n-   function Permits_Aspect_Specifications (N : Node_Id) return Boolean is\n-   begin\n-      return Has_Aspect_Specifications_Flag (Nkind (N));\n-   end Permits_Aspect_Specifications;\n-\n-   ---------------------------\n-   -- Aspect_Specifications --\n-   ---------------------------\n-\n-   function Aspect_Specifications (N : Node_Id) return List_Id is\n-   begin\n-      return Aspect_Specifications_Hash_Table.Get (N);\n-   end Aspect_Specifications;\n-\n-   -------------------------------\n-   -- Set_Aspect_Specifications --\n-   -------------------------------\n-\n-   procedure Set_Aspect_Specifications (N : Node_Id; L : List_Id) is\n-   begin\n-      pragma Assert (Permits_Aspect_Specifications (N));\n-      pragma Assert (not Has_Aspect_Specifications (N));\n-      pragma Assert (L /= No_List);\n-\n-      Set_Has_Aspect_Specifications (N);\n-      Set_Parent (L, N);\n-      Aspect_Specifications_Hash_Table.Set (N, L);\n-   end Set_Aspect_Specifications;\n-\n end Sinfo;"}, {"sha": "04d892f29d21f41afd21576117785104ace63929", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -455,13 +455,13 @@ package Sinfo is\n \n    --  The following flag fields appear in all nodes\n \n-   --  Analyzed (Flag1)\n+   --  Analyzed\n    --    This flag is used to indicate that a node (and all its children have\n    --    been analyzed. It is used to avoid reanalysis of a node that has\n    --    already been analyzed, both for efficiency and functional correctness\n    --    reasons.\n \n-   --  Comes_From_Source (Flag2)\n+   --  Comes_From_Source\n    --    This flag is set if the node comes directly from an explicit construct\n    --    in the source. It is normally on for any nodes built by the scanner or\n    --    parser from the source program, with the exception that in a few cases\n@@ -475,7 +475,7 @@ package Sinfo is\n    --    from the source program (e.g. the allocator built for build-in-place\n    --    case), and the Comes_From_Source flag is deliberately set.\n \n-   --  Error_Posted (Flag3)\n+   --  Error_Posted\n    --    This flag is used to avoid multiple error messages being posted on or\n    --    referring to the same node. This flag is set if an error message\n    --    refers to a node or is posted on its source location, and has the\n@@ -587,6 +587,14 @@ package Sinfo is\n    --    is used for translation of the at end handler into a normal exception\n    --    handler.\n \n+   --  Aspect_Cancel (Flag11-Sem)\n+   --    Processing of aspect specifications typically generates pragmas and\n+   --    attribute definition clauses that are inserted into the tree after\n+   --    the declaration node to get the desired aspect effect. In the case\n+   --    of Boolean aspects that use \"=> False\" to cancel the effect of an\n+   --    aspect (i.e. turn if off), the generated pragma has the Aspect_Cancel\n+   --    flag set to indicate that the pragma operates in the opposite sense.\n+\n    --  Assignment_OK (Flag15-Sem)\n    --    This flag is set in a subexpression node for an object, indicating\n    --    that the associated object can be modified, even if this would not\n@@ -1056,6 +1064,12 @@ package Sinfo is\n    --    cannot figure it out. If both flags Forwards_OK and Backwards_OK are\n    --    set, it means that the front end can assure no overlap of operands.\n \n+   --  From_Aspect_Specification (Flag13-Sem)\n+   --    Processing of aspect specifications typically results in insertion in\n+   --    the tree of corresponding pragma or attribute definition clause nodes.\n+   --    These generated nodes have the From_Aspect_Specification flag set to\n+   --    indicate that they came from aspect specifications originally.\n+\n    --  From_At_End (Flag4-Sem)\n    --    This flag is set on an N_Raise_Statement node if it corresponds to\n    --    the reraise statement generated as the last statement of an AT END\n@@ -1996,11 +2010,13 @@ package Sinfo is\n       --  Sloc points to PRAGMA\n       --  Next_Pragma (Node1-Sem)\n       --  Pragma_Argument_Associations (List2) (set to No_List if none)\n-      --  Debug_Statement (Node3) (set to Empty if not Debug, Assert)\n+      --  Debug_Statement (Node3) (set to Empty if not Debug)\n       --  Pragma_Identifier (Node4)\n       --  Next_Rep_Item (Node5-Sem)\n       --  Pragma_Enabled (Flag5-Sem)\n+      --  From_Aspect_Specification (Flag13-Sem)\n       --  Import_Interface_Present (Flag16-Sem)\n+      --  Aspect_Cancel (Flag11-Sem)\n \n       --  Note: we should have a section on what pragmas are passed on to\n       --  the back end to be processed. This section should note that pragma\n@@ -2010,7 +2026,12 @@ package Sinfo is\n       --  Note: a utility function Pragma_Name may be applied to pragma nodes\n       --  to conveniently obtain the Chars field of the Pragma_Identifier.\n \n-      --------------------------------------\n+      --  Note: if From_Aspect_Specification is set, then Sloc points to the\n+      --  aspect name, as does the Pragma_Identifier. In this case if the\n+      --  pragma has a local name argument (such as pragma Inline), it is\n+      --  resolved to point to the specific entity affected by the pragma.\n+\n+   --------------------------------------\n       -- 2.8  Pragma Argument Association --\n       --------------------------------------\n \n@@ -2818,7 +2839,7 @@ package Sinfo is\n \n       --  COMPONENT_DECLARATION ::=\n       --    DEFINING_IDENTIFIER_LIST : COMPONENT_DEFINITION\n-      --      [:= DEFAULT_EXPRESSION]\n+      --      [:= DEFAULT_EXPRESSION];\n \n       --  Note: although the syntax does not permit a component definition to\n       --  be an anonymous array (and the parser will diagnose such an attempt\n@@ -6395,30 +6416,48 @@ package Sinfo is\n       --  Next_Rep_Item (Node5-Sem)\n       --  From_At_Mod (Flag4-Sem)\n       --  Check_Address_Alignment (Flag11-Sem)\n+      --  From_Aspect_Specification (Flag13-Sem)\n       --  Address_Warning_Posted (Flag18-Sem)\n \n-      ----------------------------------\n-      -- 13.3.1  Aspect Specification --\n-      ----------------------------------\n+      --  Note: if From_Aspect_Specification is set, then Sloc points to the\n+      --  aspect name, and Entity is resolved already to reference the entity\n+      --  to which the aspect applies.\n+\n+      -----------------------------------\n+      -- 13.3.1  Aspect Specifications --\n+      -----------------------------------\n+\n+      --  We modify the RM grammar here, the RM grammar is:\n+\n+      --     ASPECT_SPECIFICATION ::=\n+      --       with ASPECT_MARK [=> ASPECT_DEFINITION] {.\n+      --            ASPECT_MARK [=> ASPECT_DEFINITION] }\n+\n+      --     ASPECT_MARK ::= aspect_IDENTIFIER['Class]\n+\n+      --     ASPECT_DEFINITION ::= NAME | EXPRESSION\n+\n+      --  That's inconvenient, since there is no non-terminal name for a single\n+      --  entry in the list of aspects. So we use this grammar instead:\n+\n+      --     ASPECT_SPECIFICATIONS ::=\n+      --       with ASPECT_SPECIFICATION {, ASPECT_SPECIFICATION};\n \n-      --  ASPECT_SPECIFICATION ::=\n-      --    with ASPECT_MARK [=> ASPECT_DEFINITION] {.\n-      --         ASPECT_MARK [=> ASPECT_DEFINITION] }\n+      --     ASPECT_SPECIFICATION =>\n+      --       ASPECT_MARK [=> ASPECT_DEFINITION]\n \n-      --  ASPECT_MARK ::= aspect_IDENTIFIER['Class]\n+      --     ASPECT_MARK ::= aspect_IDENTIFIER['Class]\n \n-      --  ASPECT_DEFINITION ::= NAME | EXPRESSION\n+      --     ASPECT_DEFINITION ::= NAME | EXPRESSION\n \n-      --  See separate section \"Handling of Aspect Specifications\" for details\n-      --  on the incorporation of these nodes into the tree, and association\n-      --  with the related declaration node.\n+      --  See separate package Aspects for details on the incorporation of\n+      --  these nodes into the tree, and how aspect specifications for a given\n+      --  declaration node are associated with that node.\n \n       --  N_Aspect_Specification\n       --  Sloc points to aspect identifier\n       --  Identifier (Node1) aspect identifier\n       --  Expression (Node3) Aspect_Definition (set to Empty if none)\n-      --  First_Aspect (Flag4) Set for first aspect for a declaration\n-      --  Last_Aspect (Flag5) Set for last aspect for a declaration\n       --  Class_Present (Flag6) Set if 'Class present\n \n       --  Note: Aspect_Specification is an Ada 2012 feature\n@@ -7900,6 +7939,9 @@ package Sinfo is\n    function Array_Aggregate\n      (N : Node_Id) return Node_Id;    -- Node3\n \n+   function Aspect_Cancel\n+     (N : Node_Id) return Boolean;    -- Flag11\n+\n    function Assignment_OK\n      (N : Node_Id) return Boolean;    -- Flag15\n \n@@ -8197,9 +8239,6 @@ package Sinfo is\n    function Expressions\n      (N : Node_Id) return List_Id;    -- List1\n \n-   function First_Aspect\n-     (N : Node_Id) return Boolean;    -- Flag4\n-\n    function First_Bit\n      (N : Node_Id) return Node_Id;    -- Node3\n \n@@ -8227,6 +8266,9 @@ package Sinfo is\n    function Forwards_OK\n      (N : Node_Id) return Boolean;    -- Flag5\n \n+   function From_Aspect_Specification\n+     (N : Node_Id) return Boolean;    -- Flag13\n+\n    function From_At_End\n      (N : Node_Id) return Boolean;    -- Flag4\n \n@@ -8416,9 +8458,6 @@ package Sinfo is\n    function Left_Opnd\n      (N : Node_Id) return Node_Id;    -- Node2\n \n-   function Last_Aspect\n-     (N : Node_Id) return Boolean;    -- Flag5\n-\n    function Last_Bit\n      (N : Node_Id) return Node_Id;    -- Node4\n \n@@ -8845,6 +8884,9 @@ package Sinfo is\n    procedure Set_Has_Aspect_Specifications\n      (N : Node_Id; Val : Boolean := True);    -- Flag3\n \n+   procedure Set_Aspect_Cancel\n+     (N : Node_Id; Val : Boolean := True);    -- Flag11\n+\n    procedure Set_Assignment_OK\n      (N : Node_Id; Val : Boolean := True);    -- Flag15\n \n@@ -9139,9 +9181,6 @@ package Sinfo is\n    procedure Set_Expressions\n      (N : Node_Id; Val : List_Id);            -- List1\n \n-   procedure Set_First_Aspect\n-     (N : Node_Id; Val : Boolean := True);    -- Flag4\n-\n    procedure Set_First_Bit\n      (N : Node_Id; Val : Node_Id);            -- Node3\n \n@@ -9172,6 +9211,9 @@ package Sinfo is\n    procedure Set_From_At_Mod\n      (N : Node_Id; Val : Boolean := True);    -- Flag4\n \n+   procedure Set_From_Aspect_Specification\n+     (N : Node_Id; Val : Boolean := True);    -- Flag13\n+\n    procedure Set_From_At_End\n      (N : Node_Id; Val : Boolean := True);    -- Flag4\n \n@@ -9349,9 +9391,6 @@ package Sinfo is\n    procedure Set_Kill_Range_Check\n      (N : Node_Id; Val : Boolean := True);    -- Flag11\n \n-   procedure Set_Last_Aspect\n-     (N : Node_Id; Val : Boolean := True);    -- Flag5\n-\n    procedure Set_Last_Bit\n      (N : Node_Id; Val : Node_Id);            -- Node4\n \n@@ -11417,45 +11456,6 @@ package Sinfo is\n         4 => False,   --  unused\n         5 => False)); --  unused\n \n-   ---------------------------------------\n-   -- Handling of Aspect Specifications --\n-   ---------------------------------------\n-\n-   --  Several kinds of declaration node permit aspect specifications in Ada\n-   --  2012 mode. If there was room in all these declaration nodes, we could\n-   --  just have a field Aspect_Specifications pointing to a list of nodes\n-   --  for the aspects (N_Aspect_Specification nodes). But there isn't room,\n-   --  so we adopt a different approach.\n-\n-   --  The following subprograms provide access to a specialized interface\n-   --  implemented internally with a hash table in the body, that provides\n-   --  access to aspect specifications.\n-\n-   function Permits_Aspect_Specifications (N : Node_Id) return Boolean;\n-   --  Returns True if the node N is a declaration node that permits aspect\n-   --  specifications. All such nodes have the Has_Aspect_Specifications\n-   --  flag defined. Returns False for all other nodes.\n-\n-   function Aspect_Specifications (N : Node_Id) return List_Id;\n-   --  Given a node N, returns the list of N_Aspect_Specification nodes that\n-   --  are attached to this declaration node. If the node is in the class of\n-   --  declaration nodes that permit aspect specifications, as defined by the\n-   --  predicate above, and if their Has_Aspect_Specifications flag is set to\n-   --  True, then this will always be a non-empty list. If this flag is set to\n-   --  False, or the node is not in the declaration class permitting aspect\n-   --  specifications, then No_List is returned.\n-\n-   procedure Set_Aspect_Specifications (N : Node_Id; L : List_Id);\n-   --  The node N must be in the class of declaration nodes that permit aspect\n-   --  specifications and the Has_Aspect_Specifications flag must be False on\n-   --  entry. L must be a non-empty list of N_Aspect_Specification nodes. This\n-   --  procedure sets the Has_Aspect_Specifications flag to True, and makes an\n-   --  entry that can be retrieved by a subsequent Aspect_Specifications call.\n-   --  The parent of list L is set to reference the declaration node N. It is\n-   --  an error to call this procedure with a node that does not permit aspect\n-   --  specifications, or a node that has its Has_Aspect_Specifications flag\n-   --  set True on entry, or with L being an empty list or No_List.\n-\n    --------------------\n    -- Inline Pragmas --\n    --------------------\n@@ -11481,6 +11481,7 @@ package Sinfo is\n    pragma Inline (Alternatives);\n    pragma Inline (Ancestor_Part);\n    pragma Inline (Array_Aggregate);\n+   pragma Inline (Aspect_Cancel);\n    pragma Inline (Assignment_OK);\n    pragma Inline (Associated_Node);\n    pragma Inline (At_End_Proc);\n@@ -11580,7 +11581,6 @@ package Sinfo is\n    pragma Inline (Explicit_Generic_Actual_Parameter);\n    pragma Inline (Expression);\n    pragma Inline (Expressions);\n-   pragma Inline (First_Aspect);\n    pragma Inline (First_Bit);\n    pragma Inline (First_Inlined_Subprogram);\n    pragma Inline (First_Name);\n@@ -11590,6 +11590,7 @@ package Sinfo is\n    pragma Inline (Float_Truncate);\n    pragma Inline (Formal_Type_Definition);\n    pragma Inline (Forwards_OK);\n+   pragma Inline (From_Aspect_Specification);\n    pragma Inline (From_At_End);\n    pragma Inline (From_At_Mod);\n    pragma Inline (From_Default);\n@@ -11651,7 +11652,6 @@ package Sinfo is\n    pragma Inline (Iteration_Scheme);\n    pragma Inline (Itype);\n    pragma Inline (Kill_Range_Check);\n-   pragma Inline (Last_Aspect);\n    pragma Inline (Last_Bit);\n    pragma Inline (Last_Name);\n    pragma Inline (Library_Unit);\n@@ -11792,6 +11792,7 @@ package Sinfo is\n    pragma Inline (Set_Alternatives);\n    pragma Inline (Set_Ancestor_Part);\n    pragma Inline (Set_Array_Aggregate);\n+   pragma Inline (Set_Aspect_Cancel);\n    pragma Inline (Set_Assignment_OK);\n    pragma Inline (Set_Associated_Node);\n    pragma Inline (Set_At_End_Proc);\n@@ -11890,7 +11891,6 @@ package Sinfo is\n    pragma Inline (Set_Explicit_Generic_Actual_Parameter);\n    pragma Inline (Set_Expression);\n    pragma Inline (Set_Expressions);\n-   pragma Inline (Set_First_Aspect);\n    pragma Inline (Set_First_Bit);\n    pragma Inline (Set_First_Inlined_Subprogram);\n    pragma Inline (Set_First_Name);\n@@ -11900,6 +11900,7 @@ package Sinfo is\n    pragma Inline (Set_Float_Truncate);\n    pragma Inline (Set_Formal_Type_Definition);\n    pragma Inline (Set_Forwards_OK);\n+   pragma Inline (Set_From_Aspect_Specification);\n    pragma Inline (Set_From_At_End);\n    pragma Inline (Set_From_At_Mod);\n    pragma Inline (Set_From_Default);\n@@ -11961,7 +11962,6 @@ package Sinfo is\n    pragma Inline (Set_Iteration_Scheme);\n    pragma Inline (Set_Itype);\n    pragma Inline (Set_Kill_Range_Check);\n-   pragma Inline (Set_Last_Aspect);\n    pragma Inline (Set_Last_Bit);\n    pragma Inline (Set_Last_Name);\n    pragma Inline (Set_Library_Unit);"}, {"sha": "74da13ff47d567bef2aed165f2f34852bf7d9fa3", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 118, "deletions": 66, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f1a6a0b83ac281cb77b7432154626b4e78b8171/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=0f1a6a0b83ac281cb77b7432154626b4e78b8171", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;  use Aspects;\n with Atree;    use Atree;\n with Casing;   use Casing;\n with Csets;    use Csets;\n@@ -182,6 +183,12 @@ package body Sprint is\n    procedure Sprint_And_List (List : List_Id);\n    --  Print the given list with items separated by vertical \"and\"\n \n+   procedure Sprint_Aspect_Specifications (Node : Node_Id);\n+   --  Node is a declaration node that accepts aspect specifications. This\n+   --  procedure tests if aspect specifications are present, and if so prints\n+   --  them, with a terminating semicolon. If no aspect specifications are\n+   --  present, then a single semicolon is output.\n+\n    procedure Sprint_Bar_List (List : List_Id);\n    --  Print the given list with items separated by vertical bars\n \n@@ -619,6 +626,48 @@ package body Sprint is\n       end if;\n    end Sprint_And_List;\n \n+   ----------------------------------\n+   -- Sprint_Aspect_Specifications --\n+   ----------------------------------\n+\n+   procedure Sprint_Aspect_Specifications (Node : Node_Id) is\n+      AS : List_Id;\n+      A  : Node_Id;\n+\n+   begin\n+      if Has_Aspect_Specifications (Node) then\n+         AS := Aspect_Specifications (Node);\n+         Indent := Indent + 2;\n+         Write_Indent;\n+         Write_Str (\"with \");\n+         Indent := Indent + 5;\n+\n+         A := First (AS);\n+         loop\n+            Sprint_Node (Identifier (A));\n+\n+            if Class_Present (A) then\n+               Write_Str (\"'Class\");\n+            end if;\n+\n+            if Present (Expression (A)) then\n+               Write_Str (\" => \");\n+               Sprint_Node (Expression (A));\n+            end if;\n+\n+            Next (A);\n+\n+            exit when No (A);\n+            Write_Char (',');\n+            Write_Indent;\n+         end loop;\n+\n+         Indent := Indent - 7;\n+      end if;\n+\n+      Write_Char (';');\n+   end Sprint_Aspect_Specifications;\n+\n    ---------------------\n    -- Sprint_Bar_List --\n    ---------------------\n@@ -815,7 +864,8 @@ package body Sprint is\n             Write_Indent;\n             Sprint_Node (Specification (Node));\n             Write_Str_With_Col_Check (\" is \");\n-            Write_Str_Sloc (\"abstract;\");\n+            Write_Str_Sloc (\"abstract\");\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Accept_Alternative =>\n             Sprint_Node_List (Pragmas_Before (Node));\n@@ -1224,7 +1274,7 @@ package body Sprint is\n                   Sprint_Node (Expression (Node));\n                end if;\n \n-               Write_Char (';');\n+               Sprint_Aspect_Specifications (Node);\n             end if;\n \n          when N_Component_List =>\n@@ -1453,7 +1503,7 @@ package body Sprint is\n             end if;\n \n             Write_Param_Specs (Node);\n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Entry_Index_Specification =>\n             Write_Str_With_Col_Check_Sloc (\"for \");\n@@ -1499,7 +1549,7 @@ package body Sprint is\n                   Sprint_Node (Expression (Node));\n                end if;\n \n-               Write_Char (';');\n+               Sprint_Aspect_Specifications (Node);\n             end if;\n \n          when N_Exception_Handler =>\n@@ -1625,7 +1675,7 @@ package body Sprint is\n                Sprint_Node (Default_Name (Node));\n             end if;\n \n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Formal_Concrete_Subprogram_Declaration =>\n             Write_Indent_Str_Sloc (\"with \");\n@@ -1638,7 +1688,7 @@ package body Sprint is\n                Sprint_Node (Default_Name (Node));\n             end if;\n \n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Formal_Discrete_Type_Definition =>\n             Write_Str_With_Col_Check_Sloc (\"<>\");\n@@ -1686,7 +1736,7 @@ package body Sprint is\n                   Sprint_Node (Default_Expression (Node));\n                end if;\n \n-               Write_Char (';');\n+               Sprint_Aspect_Specifications (Node);\n             end if;\n \n          when N_Formal_Ordinary_Fixed_Point_Definition =>\n@@ -1697,7 +1747,8 @@ package body Sprint is\n             Write_Id (Defining_Identifier (Node));\n             Write_Str_With_Col_Check (\" is new \");\n             Sprint_Node (Name (Node));\n-            Write_Str_With_Col_Check (\" (<>);\");\n+            Write_Str_With_Col_Check (\" (<>)\");\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Formal_Private_Type_Definition =>\n             if Abstract_Present (Node) then\n@@ -1729,7 +1780,7 @@ package body Sprint is\n \n             Write_Str_With_Col_Check (\" is \");\n             Sprint_Node (Formal_Type_Definition (Node));\n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Free_Statement =>\n             Write_Indent_Str_Sloc (\"free \");\n@@ -1770,7 +1821,7 @@ package body Sprint is\n             Write_Discr_Specs (Node);\n             Write_Str_With_Col_Check (\" is \");\n             Sprint_Node (Type_Definition (Node));\n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Function_Call =>\n             Set_Debug_Sloc;\n@@ -1783,7 +1834,7 @@ package body Sprint is\n             Write_Str_With_Col_Check (\" is new \");\n             Sprint_Node (Name (Node));\n             Sprint_Opt_Paren_Comma_List (Generic_Associations (Node));\n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Function_Specification =>\n             Write_Str_With_Col_Check_Sloc (\"function \");\n@@ -1824,7 +1875,7 @@ package body Sprint is\n             Sprint_Indented_List (Generic_Formal_Declarations (Node));\n             Write_Indent;\n             Sprint_Node (Specification (Node));\n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Generic_Package_Renaming_Declaration =>\n             Write_Indent_Str_Sloc (\"generic package \");\n@@ -1846,7 +1897,7 @@ package body Sprint is\n             Sprint_Indented_List (Generic_Formal_Declarations (Node));\n             Write_Indent;\n             Sprint_Node (Specification (Node));\n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Goto_Statement =>\n             Write_Indent_Str_Sloc (\"goto \");\n@@ -2077,7 +2128,7 @@ package body Sprint is\n                      Sprint_Node (Expression (Node));\n                   end if;\n \n-                  Write_Char (';');\n+                  Sprint_Aspect_Specifications (Node);\n \n                   --  Handle implicit importation and implicit exportation of\n                   --  object declarations:\n@@ -2318,7 +2369,7 @@ package body Sprint is\n             Extra_Blank_Line;\n             Write_Indent;\n             Sprint_Node_Sloc (Specification (Node));\n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Package_Instantiation =>\n             Extra_Blank_Line;\n@@ -2327,7 +2378,7 @@ package body Sprint is\n             Write_Str (\" is new \");\n             Sprint_Node (Name (Node));\n             Sprint_Opt_Paren_Comma_List (Generic_Associations (Node));\n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Package_Renaming_Declaration =>\n             Write_Indent_Str_Sloc (\"package \");\n@@ -2410,6 +2461,50 @@ package body Sprint is\n          when N_Pop_Storage_Error_Label =>\n             Write_Indent_Str (\"%pop_storage_error_label\");\n \n+         when N_Private_Extension_Declaration =>\n+            Write_Indent_Str_Sloc (\"type \");\n+            Write_Id (Defining_Identifier (Node));\n+\n+            if Present (Discriminant_Specifications (Node)) then\n+               Write_Discr_Specs (Node);\n+            elsif Unknown_Discriminants_Present (Node) then\n+               Write_Str_With_Col_Check (\"(<>)\");\n+            end if;\n+\n+            Write_Str_With_Col_Check (\" is new \");\n+            Sprint_Node (Subtype_Indication (Node));\n+\n+            if Present (Interface_List (Node)) then\n+               Write_Str_With_Col_Check (\" and \");\n+               Sprint_And_List (Interface_List (Node));\n+            end if;\n+\n+            Write_Str_With_Col_Check (\" with private\");\n+            Sprint_Aspect_Specifications (Node);\n+\n+         when N_Private_Type_Declaration =>\n+            Write_Indent_Str_Sloc (\"type \");\n+            Write_Id (Defining_Identifier (Node));\n+\n+            if Present (Discriminant_Specifications (Node)) then\n+               Write_Discr_Specs (Node);\n+            elsif Unknown_Discriminants_Present (Node) then\n+               Write_Str_With_Col_Check (\"(<>)\");\n+            end if;\n+\n+            Write_Str (\" is \");\n+\n+            if Tagged_Present (Node) then\n+               Write_Str_With_Col_Check (\"tagged \");\n+            end if;\n+\n+            if Limited_Present (Node) then\n+               Write_Str_With_Col_Check (\"limited \");\n+            end if;\n+\n+            Write_Str_With_Col_Check (\"private\");\n+            Sprint_Aspect_Specifications (Node);\n+\n          when N_Push_Constraint_Error_Label =>\n             Write_Indent_Str (\"%push_constraint_error_label (\");\n \n@@ -2458,48 +2553,6 @@ package body Sprint is\n \n             Sprint_Node (Expression (Node));\n \n-         when N_Private_Type_Declaration =>\n-            Write_Indent_Str_Sloc (\"type \");\n-            Write_Id (Defining_Identifier (Node));\n-\n-            if Present (Discriminant_Specifications (Node)) then\n-               Write_Discr_Specs (Node);\n-            elsif Unknown_Discriminants_Present (Node) then\n-               Write_Str_With_Col_Check (\"(<>)\");\n-            end if;\n-\n-            Write_Str (\" is \");\n-\n-            if Tagged_Present (Node) then\n-               Write_Str_With_Col_Check (\"tagged \");\n-            end if;\n-\n-            if Limited_Present (Node) then\n-               Write_Str_With_Col_Check (\"limited \");\n-            end if;\n-\n-            Write_Str_With_Col_Check (\"private;\");\n-\n-         when N_Private_Extension_Declaration =>\n-            Write_Indent_Str_Sloc (\"type \");\n-            Write_Id (Defining_Identifier (Node));\n-\n-            if Present (Discriminant_Specifications (Node)) then\n-               Write_Discr_Specs (Node);\n-            elsif Unknown_Discriminants_Present (Node) then\n-               Write_Str_With_Col_Check (\"(<>)\");\n-            end if;\n-\n-            Write_Str_With_Col_Check (\" is new \");\n-            Sprint_Node (Subtype_Indication (Node));\n-\n-            if Present (Interface_List (Node)) then\n-               Write_Str_With_Col_Check (\" and \");\n-               Sprint_And_List (Interface_List (Node));\n-            end if;\n-\n-            Write_Str_With_Col_Check (\" with private;\");\n-\n          when N_Procedure_Call_Statement =>\n             Write_Indent;\n             Set_Debug_Sloc;\n@@ -2513,7 +2566,7 @@ package body Sprint is\n             Write_Str_With_Col_Check (\" is new \");\n             Sprint_Node (Name (Node));\n             Sprint_Opt_Paren_Comma_List (Generic_Associations (Node));\n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Procedure_Specification =>\n             Write_Str_With_Col_Check_Sloc (\"procedure \");\n@@ -2560,7 +2613,7 @@ package body Sprint is\n \n             Sprint_Node (Protected_Definition (Node));\n             Write_Id (Defining_Identifier (Node));\n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Qualified_Expression =>\n             Sprint_Node (Subtype_Mark (Node));\n@@ -2756,7 +2809,7 @@ package body Sprint is\n             Write_Str (\" is\");\n             Sprint_Node (Protected_Definition (Node));\n             Write_Id (Defining_Identifier (Node));\n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Single_Task_Declaration =>\n             Write_Indent_Str_Sloc (\"task \");\n@@ -2767,7 +2820,7 @@ package body Sprint is\n                Sprint_Node (Task_Definition (Node));\n             end if;\n \n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Selected_Component =>\n             Sprint_Node (Prefix (Node));\n@@ -2840,7 +2893,7 @@ package body Sprint is\n                Write_Str_With_Col_Check (\" is null\");\n             end if;\n \n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Subprogram_Info =>\n             Sprint_Node (Identifier (Node));\n@@ -2865,7 +2918,7 @@ package body Sprint is\n             end if;\n \n             Sprint_Node (Subtype_Indication (Node));\n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Subtype_Indication =>\n             Sprint_Node_Sloc (Subtype_Mark (Node));\n@@ -2928,11 +2981,10 @@ package body Sprint is\n                Sprint_Node (Task_Definition (Node));\n             end if;\n \n-            Write_Char (';');\n+            Sprint_Aspect_Specifications (Node);\n \n          when N_Terminate_Alternative =>\n             Sprint_Node_List (Pragmas_Before (Node));\n-\n             Write_Indent;\n \n             if Present (Condition (Node)) then"}]}