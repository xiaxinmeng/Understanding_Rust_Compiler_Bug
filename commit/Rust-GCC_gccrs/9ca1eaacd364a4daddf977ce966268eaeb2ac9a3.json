{"sha": "9ca1eaacd364a4daddf977ce966268eaeb2ac9a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNhMWVhYWNkMzY0YTRkYWRkZjk3N2NlOTY2MjY4ZWFlYjJhYzlhMw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-11-28T00:02:17Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-11-28T00:02:17Z"}, "message": "PR c++/83058 - ICE on C++ code with negative array index: in warn_placement_new_too_small\n\ngcc/cp/ChangeLog:\n\n\tPR c++/83058\n\t* init.c (warn_placement_new_too_small): Use offset_int instead of\n\tHOST_WIDE_INT.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/83058\n\t* g++.dg/warn/Wplacement-new-size-5.C: New test.\n\nFrom-SVN: r255182", "tree": {"sha": "9fa2b87c6c6296dbde32a54b14db3cd8f564e598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fa2b87c6c6296dbde32a54b14db3cd8f564e598"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ca1eaacd364a4daddf977ce966268eaeb2ac9a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ca1eaacd364a4daddf977ce966268eaeb2ac9a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ca1eaacd364a4daddf977ce966268eaeb2ac9a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ca1eaacd364a4daddf977ce966268eaeb2ac9a3/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "de3d4fd0f5439fcc8e3ae10d9f439c007dfacb1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de3d4fd0f5439fcc8e3ae10d9f439c007dfacb1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de3d4fd0f5439fcc8e3ae10d9f439c007dfacb1d"}], "stats": {"total": 373, "additions": 317, "deletions": 56}, "files": [{"sha": "0f91df7d7a7efa50a9bea8270cdf817ade4615d2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ca1eaacd364a4daddf977ce966268eaeb2ac9a3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ca1eaacd364a4daddf977ce966268eaeb2ac9a3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9ca1eaacd364a4daddf977ce966268eaeb2ac9a3", "patch": "@@ -1,3 +1,9 @@\n+2017-11-27  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/83058\n+\t* init.c (warn_placement_new_too_small): Use offset_int instead of\n+\tHOST_WIDE_INT.\n+\n 2017-11-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/81888"}, {"sha": "c417c6ba0d5d6d4f0583c893d67f501a816eade5", "filename": "gcc/cp/init.c", "status": "modified", "additions": 65, "deletions": 56, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ca1eaacd364a4daddf977ce966268eaeb2ac9a3/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ca1eaacd364a4daddf977ce966268eaeb2ac9a3/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9ca1eaacd364a4daddf977ce966268eaeb2ac9a3", "patch": "@@ -2498,9 +2498,9 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n \n   /* The number of bytes to add to or subtract from the size of the provided\n      buffer based on an offset into an array or an array element reference.\n-     Although intermediate results may be negative (as in a[3] - 2) the final\n-     result cannot be.  */\n-  HOST_WIDE_INT adjust = 0;\n+     Although intermediate results may be negative (as in a[3] - 2) a valid\n+     final result cannot be.  */\n+  offset_int adjust = 0;\n   /* True when the size of the entire destination object should be used\n      to compute the possibly optimistic estimate of the available space.  */\n   bool use_obj_size = false;\n@@ -2524,15 +2524,15 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n      is a constant.  */\n   if (TREE_CODE (oper) == POINTER_PLUS_EXPR)\n     {\n-      /* If the offset is comple-time constant, use it to compute a more\n+      /* If the offset is compile-time constant, use it to compute a more\n \t accurate estimate of the size of the buffer.  Since the operand\n \t of POINTER_PLUS_EXPR is represented as an unsigned type, convert\n \t it to signed first.\n \t Otherwise, use the size of the entire array as an optimistic\n \t estimate (this may lead to false negatives).  */\n       tree adj = TREE_OPERAND (oper, 1);\n       if (CONSTANT_CLASS_P (adj))\n-\tadjust += tree_to_shwi (convert (ssizetype, adj));\n+\tadjust += wi::to_offset (convert (ssizetype, adj));\n       else\n \tuse_obj_size = true;\n \n@@ -2559,9 +2559,9 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n \t not a compile-time constant, use the index to determine the\n \t size of the buffer.  Otherwise, use the entire array as\n \t an optimistic estimate of the size.  */\n-      const_tree adj = TREE_OPERAND (oper, 1);\n+      const_tree adj = fold_non_dependent_expr (TREE_OPERAND (oper, 1));\n       if (!use_obj_size && CONSTANT_CLASS_P (adj))\n-\tadjust += tree_to_shwi (adj);\n+\tadjust += wi::to_offset (adj);\n       else\n \t{\n \t  use_obj_size = true;\n@@ -2580,25 +2580,34 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n      members from arrays of unspecified size.  */\n   bool compref = TREE_CODE (oper) == COMPONENT_REF;\n \n+  /* For COMPONENT_REF (i.e., a struct member) the size of the entire\n+     enclosing struct.  Used to validate the adjustment (offset) into\n+     an array at the end of a struct.  */\n+  offset_int compsize = 0;\n+\n   /* Descend into a struct or union to find the member whose address\n      is being used as the argument.  */\n   if (TREE_CODE (oper) == COMPONENT_REF)\n     {\n+      tree comptype = TREE_TYPE (TREE_OPERAND (oper, 0));\n+      compsize = wi::to_offset (TYPE_SIZE_UNIT (comptype));\n+\n       tree op0 = oper;\n       while (TREE_CODE (op0 = TREE_OPERAND (op0, 0)) == COMPONENT_REF);\n       if (VAR_P (op0))\n \tvar_decl = op0;\n       oper = TREE_OPERAND (oper, 1);\n     }\n \n-  if ((addr_expr || !POINTER_TYPE_P (TREE_TYPE (oper)))\n+  tree opertype = TREE_TYPE (oper);\n+  if ((addr_expr || !POINTER_TYPE_P (opertype))\n       && (VAR_P (oper)\n \t  || TREE_CODE (oper) == FIELD_DECL\n \t  || TREE_CODE (oper) == PARM_DECL))\n     {\n       /* A possibly optimistic estimate of the number of bytes available\n \t in the destination buffer.  */\n-      unsigned HOST_WIDE_INT bytes_avail = 0;\n+      offset_int bytes_avail = 0;\n       /* True when the estimate above is in fact the exact size\n \t of the destination buffer rather than an estimate.  */\n       bool exact_size = true;\n@@ -2613,47 +2622,42 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n \t  /* Use the size of the entire array object when the expression\n \t     refers to a variable or its size depends on an expression\n \t     that's not a compile-time constant.  */\n-\t  bytes_avail = tree_to_uhwi (DECL_SIZE_UNIT (oper));\n+\t  bytes_avail = wi::to_offset (DECL_SIZE_UNIT (oper));\n \t  exact_size = !use_obj_size;\n \t}\n-      else if (TYPE_SIZE_UNIT (TREE_TYPE (oper))\n-\t       && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (oper))))\n+      else if (tree opersize = TYPE_SIZE_UNIT (opertype))\n \t{\n \t  /* Use the size of the type of the destination buffer object\n-\t     as the optimistic estimate of the available space in it.  */\n-\t  bytes_avail = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (oper)));\n+\t     as the optimistic estimate of the available space in it.\n+\t     Use the maximum possible size for zero-size arrays and\n+\t     flexible array members (except of initialized objects\n+\t     thereof).  */\n+\t  if (TREE_CODE (opersize) == INTEGER_CST)\n+\t    bytes_avail = wi::to_offset (opersize);\n \t}\n-      else if (var_decl)\n-\t{\n-\t  /* Constructing into a buffer provided by the flexible array\n-\t     member of a declared object (which is permitted as a G++\n-\t     extension).  If the array member has been initialized,\n-\t     determine its size from the initializer.  Otherwise,\n-\t     the array size is zero.  */\n-\t  bytes_avail = 0;\n-\n-\t  if (tree init = find_field_init (oper, DECL_INITIAL (var_decl)))\n-\t    bytes_avail = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (init)));\n-\t}\n-      else\n+\n+      if (bytes_avail == 0)\n \t{\n-\t  /* Bail if neither the size of the object nor its type is known.  */\n-\t  return;\n+\t  if (var_decl)\n+\t    {\n+\t      /* Constructing into a buffer provided by the flexible array\n+\t\t member of a declared object (which is permitted as a G++\n+\t\t extension).  If the array member has been initialized,\n+\t\t determine its size from the initializer.  Otherwise,\n+\t\t the array size is zero.  */\n+\t      if (tree init = find_field_init (oper, DECL_INITIAL (var_decl)))\n+\t\tbytes_avail = wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (init)));\n+\t    }\n+\t  else\n+\t    bytes_avail = (wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node))\n+\t\t\t   - compsize);\n \t}\n \n-      tree_code oper_code = TREE_CODE (TREE_TYPE (oper));\n+      tree_code oper_code = TREE_CODE (opertype);\n \n       if (compref && oper_code == ARRAY_TYPE)\n \t{\n-\t  /* Avoid diagnosing flexible array members (which are accepted\n-\t     as an extension and diagnosed with -Wpedantic) and zero-length\n-\t     arrays (also an extension).\n-\t     Overflowing construction in one-element arrays is diagnosed\n-\t     only at level 2.  */\n-\t  if (bytes_avail == 0 && !var_decl)\n-\t    return;\n-\n-\t  tree nelts = array_type_nelts_top (TREE_TYPE (oper));\n+\t  tree nelts = array_type_nelts_top (opertype);\n \t  tree nelts_cst = maybe_constant_value (nelts);\n \t  if (TREE_CODE (nelts_cst) == INTEGER_CST\n \t      && integer_onep (nelts_cst)\n@@ -2662,29 +2666,35 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n \t    return;\n \t}\n \n-      /* The size of the buffer can only be adjusted down but not up.  */\n-      gcc_checking_assert (0 <= adjust);\n-\n       /* Reduce the size of the buffer by the adjustment computed above\n \t from the offset and/or the index into the array.  */\n-      if (bytes_avail < static_cast<unsigned HOST_WIDE_INT>(adjust))\n+      if (bytes_avail < adjust || adjust < 0)\n \tbytes_avail = 0;\n       else\n-\tbytes_avail -= adjust;\n+\t{\n+\t  tree elttype = (TREE_CODE (opertype) == ARRAY_TYPE\n+\t\t\t  ? TREE_TYPE (opertype) : opertype);\n+\t  if (tree eltsize = TYPE_SIZE_UNIT (elttype))\n+\t    {\n+\t      bytes_avail -= adjust * wi::to_offset (eltsize);\n+\t      if (bytes_avail < 0)\n+\t\tbytes_avail = 0;\n+\t    }\n+\t}\n \n       /* The minimum amount of space needed for the allocation.  This\n \t is an optimistic estimate that makes it possible to detect\n \t placement new invocation for some undersize buffers but not\n \t others.  */\n-      unsigned HOST_WIDE_INT bytes_need;\n+      offset_int bytes_need;\n \n       if (CONSTANT_CLASS_P (size))\n-\tbytes_need = tree_to_uhwi (size);\n+\tbytes_need = wi::to_offset (size);\n       else if (nelts && CONSTANT_CLASS_P (nelts))\n-\t  bytes_need = tree_to_uhwi (nelts)\n-\t    * tree_to_uhwi (TYPE_SIZE_UNIT (type));\n+\tbytes_need = (wi::to_offset (nelts)\n+\t\t      * wi::to_offset (TYPE_SIZE_UNIT (type)));\n       else if (tree_fits_uhwi_p (TYPE_SIZE_UNIT (type)))\n-\tbytes_need = tree_to_uhwi (TYPE_SIZE_UNIT (type));\n+\tbytes_need = wi::to_offset (TYPE_SIZE_UNIT (type));\n       else\n \t{\n \t  /* The type is a VLA.  */\n@@ -2703,9 +2713,8 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n \t\t\t  : \"placement new constructing an object of type \"\n \t\t\t  \"%<%T [%wu]%> and size %qwu in a region of type %qT \"\n \t\t\t  \"and size at most %qwu\",\n-\t\t\t  type, tree_to_uhwi (nelts), bytes_need,\n-\t\t\t  TREE_TYPE (oper),\n-\t\t\t  bytes_avail);\n+\t\t\t  type, tree_to_uhwi (nelts), bytes_need.to_uhwi (),\n+\t\t\t  opertype, bytes_avail.to_uhwi ());\n \t    else\n \t      warning_at (loc, OPT_Wplacement_new_,\n \t\t\t  exact_size ?\n@@ -2715,8 +2724,8 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n \t\t\t  : \"placement new constructing an array of objects \"\n \t\t\t  \"of type %qT and size %qwu in a region of type %qT \"\n \t\t\t  \"and size at most %qwu\",\n-\t\t\t  type, bytes_need, TREE_TYPE (oper),\n-\t\t\t  bytes_avail);\n+\t\t\t  type, bytes_need.to_uhwi (), opertype,\n+\t\t\t  bytes_avail.to_uhwi ());\n \t  else\n \t    warning_at (loc, OPT_Wplacement_new_,\n \t\t\texact_size ?\n@@ -2725,8 +2734,8 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n \t\t\t: \"placement new constructing an object of type %qT \"\n \t\t\t\"and size %qwu in a region of type %qT and size \"\n \t\t\t\"at most %qwu\",\n-\t\t\ttype, bytes_need, TREE_TYPE (oper),\n-\t\t\tbytes_avail);\n+\t\t\ttype, bytes_need.to_uhwi (), opertype,\n+\t\t\tbytes_avail.to_uhwi ());\n \t}\n     }\n }"}, {"sha": "ab587a0d83f63be2f82906260e7ef5c66ff97567", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ca1eaacd364a4daddf977ce966268eaeb2ac9a3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ca1eaacd364a4daddf977ce966268eaeb2ac9a3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9ca1eaacd364a4daddf977ce966268eaeb2ac9a3", "patch": "@@ -1,3 +1,8 @@\n+2017-11-27  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/83058\n+\t* g++.dg/warn/Wplacement-new-size-5.C: New test.\n+\n 2017-11-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/81888"}, {"sha": "178d737527000567c98786d6c81ece7fe3d531bb", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size-5.C", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ca1eaacd364a4daddf977ce966268eaeb2ac9a3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ca1eaacd364a4daddf977ce966268eaeb2ac9a3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-5.C?ref=9ca1eaacd364a4daddf977ce966268eaeb2ac9a3", "patch": "@@ -0,0 +1,241 @@\n+// PR c++/83058 - ICE on C++ code with negative array index: in\n+// warn_placement_new_too_small\n+// { dg-do compile }\n+// { dg-additional-options \"-Wplacement-new -Wno-pedantic\" }\n+\n+#define SIZE_MAX   __SIZE_MAX__\n+#define DIFF_MAX   __PTRDIFF_MAX__\n+#define DIFF_MIN   (-DIFF_MAX - 1)\n+\n+void* operator new (__SIZE_TYPE__ n, void *p) { return p; }\n+void* operator new[] (__SIZE_TYPE__ n, void *p) { return p; }\n+\n+struct A { };\n+\n+char carr[2];\n+int iarr[2];\n+\n+struct C0 { char i, carr[0]; };\n+struct I0 { int i, iarr[0]; };\n+struct CX { char i, carr[]; };\n+struct IX { int i, iarr[]; };\n+\n+void test_single (C0 *pc, CX *qc, I0 *pi, IX *qi, int n)\n+{\n+  new (&carr[DIFF_MIN]) A ();       // { dg-warning \"placement new constructing an object of type .A. and size .1. in a region of type .char \\\\\\[2]. and size .0.\" }\n+  new (&carr[-1]) A;                // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (carr -1 ) A;                 // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&carr[0]) A;\n+  new (carr) A;\n+  new (&carr[1]) A;\n+  new (carr + 1) A;\n+  new (&carr[n]) A;\n+  new (carr + n) A;\n+  new (&carr[DIFF_MAX]) A;          // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (carr + DIFF_MAX) A;          // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&carr[SIZE_MAX]) A;          // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (carr + SIZE_MAX) A;          // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  new (&pc->carr[DIFF_MIN]) A;      // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pc->carr[-1]) A;            // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pc->carr[0]) A;\n+  new (&pc->carr[9]) A;\n+  new (&pc->carr[n]) A;\n+  new (&pc->carr[DIFF_MAX]) A;      // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pc->carr[SIZE_MAX]) A;      // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  {\n+    /* The highest index at which a single A can be constructed.  */\n+    enum { MAX = DIFF_MAX - sizeof *pc - sizeof (A) };\n+    new (&pc->carr[MAX]) A;\n+    new (&pc->carr[MAX + 1]) A;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  }\n+\n+  new (&qc->carr[DIFF_MIN]) A;      // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qc->carr[-1]) A;            // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qc->carr[0]) A;\n+  new (&qc->carr[9]) A;\n+  new (&qc->carr[n]) A;\n+  new (&qc->carr[DIFF_MAX]) A;      // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qc->carr[SIZE_MAX]) A;      // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  {\n+    /* The highest index at which a single A can be constructed.  */\n+    enum { MAX = DIFF_MAX - sizeof *qc - sizeof (A) };\n+    new (&qc->carr[MAX]) A;\n+    new (&qc->carr[MAX + 1]) A;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  }\n+\n+  new (&pi->iarr[DIFF_MIN]) A;      // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pi->iarr[-1]) A;            // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pi->iarr[0]) A;\n+  new (&pi->iarr[9]) A;\n+  new (&pi->iarr[n]) A;\n+  new (&pi->iarr[DIFF_MAX]) A;      // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pi->iarr[SIZE_MAX]) A;      // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  {\n+    enum { MAX = (DIFF_MAX - sizeof *pi) / sizeof *pi->iarr };\n+    new (&pi->iarr[MAX]) A;\n+    new (&pi->iarr[MAX + 1]) A;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  }\n+\n+  new (&qi->iarr[DIFF_MIN]) A;      // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qi->iarr[-1]) A;            // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qi->iarr[0]) A;\n+  new (&qi->iarr[9]) A;\n+  new (&qi->iarr[n]) A;\n+  new (&qi->iarr[DIFF_MAX]) A;      // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qi->iarr[SIZE_MAX]) A;      // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  {\n+    enum { MAX = (DIFF_MAX - sizeof *qi) / sizeof *qi->iarr };\n+    new (&qi->iarr[MAX]) A;\n+    new (&qi->iarr[MAX + 1]) A;     // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  }\n+\n+  new (&iarr[DIFF_MIN]) A;          // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&iarr[-1]) A;                // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&iarr[1]) A;\n+  new (&iarr[n]) A;\n+  new (&iarr[DIFF_MAX]) A;          // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&iarr[SIZE_MAX]) A;          // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+}\n+\n+void test_array_1 (C0 *pc, CX *qc, I0 *pi, IX *qi)\n+{\n+  enum { N = 1 };\n+\n+  new (&carr[DIFF_MIN]) A[N];       // { dg-warning \"placement new constructing an object of type .A \\\\\\[\\[0-9\\]+]. and size .\\[0-9\\]+. in a region of type .char \\\\\\[2]. and size .0.\" }\n+  new (&carr[-1]) A[N];             // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&carr[DIFF_MAX]) A[N];       // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&carr[SIZE_MAX]) A[N];       // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  new (&pc->carr[DIFF_MIN]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pc->carr[-1]) A[N];         // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pc->carr[DIFF_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pc->carr[SIZE_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  {\n+    enum { MAX = DIFF_MAX - sizeof *pc - sizeof (A[N]) };\n+    new (&pc->carr[MAX]) A[N];\n+    new (&pc->carr[MAX + 1]) A[N];  // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  }\n+\n+  new (&qc->carr[DIFF_MIN]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qc->carr[-1]) A[N];         // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qc->carr[DIFF_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qc->carr[SIZE_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  {\n+    enum { MAX = DIFF_MAX - sizeof *qc - sizeof (A[N]) };\n+    new (&qc->carr[MAX]) A[N];\n+    new (&qc->carr[MAX + 1]) A[N];  // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  }\n+\n+  new (&pi->iarr[DIFF_MIN]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pi->iarr[-1]) A[N];         // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pi->iarr[DIFF_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pi->iarr[SIZE_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  {\n+    enum { MAX = (DIFF_MAX - sizeof *pi) / sizeof *pi->iarr };\n+    new (&pi->iarr[MAX]) A[N];\n+    new (&pi->iarr[MAX + 1]) A[N];  // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  }\n+\n+  new (&qi->iarr[DIFF_MIN]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qi->iarr[-1]) A[N];         // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qi->iarr[DIFF_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qi->iarr[SIZE_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  {\n+    enum { MAX = (DIFF_MAX - sizeof *qi) / sizeof *qi->iarr };\n+    new (&qi->iarr[MAX]) A[N];\n+    new (&qi->iarr[MAX + 1]) A[N];  // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  }\n+\n+  new (&iarr[DIFF_MIN]) A[N];       // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&iarr[-1]) A[N];             // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&iarr[DIFF_MAX]) A[N];       // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&iarr[SIZE_MAX]) A[N];       // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+}\n+\n+\n+void test_array_3 (C0 *pc, CX *qc, I0 *pi, IX *qi)\n+{\n+  enum { N = 3 };\n+\n+  new (&carr[DIFF_MIN]) A[N];       // { dg-warning \"placement new constructing an object of type .A \\\\\\[\\[0-9\\]+]. and size .\\[0-9\\]+. in a region of type .char \\\\\\[2]. and size .0.\" }\n+  new (&carr[-1]) A[N];             // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&carr[DIFF_MAX]) A[N];       // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&carr[SIZE_MAX]) A[N];       // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  new (&pc->carr[DIFF_MIN]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pc->carr[-1]) A[N];         // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pc->carr[DIFF_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pc->carr[SIZE_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  {\n+    enum { MAX = DIFF_MAX - sizeof *pc - sizeof (A[N]) };\n+    new (&pc->carr[MAX]) A[N];\n+    new (&pc->carr[MAX + 1]) A[N];  // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  }\n+\n+  new (&qc->carr[DIFF_MIN]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qc->carr[-1]) A[N];         // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qc->carr[DIFF_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qc->carr[SIZE_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  {\n+    enum { MAX = DIFF_MAX - sizeof *qc - sizeof (A[N]) };\n+    new (&qc->carr[MAX]) A[N];\n+    new (&qc->carr[MAX + 1]) A[N];  // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  }\n+\n+  new (&pi->iarr[DIFF_MIN]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pi->iarr[-1]) A[N];         // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pi->iarr[DIFF_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&pi->iarr[SIZE_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  {\n+    enum { MAX = (DIFF_MAX - sizeof *pi) / sizeof *pi->iarr };\n+    new (&pi->iarr[MAX]) A[N];\n+    new (&pi->iarr[MAX + 1]) A[N];  // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  }\n+\n+  new (&qi->iarr[DIFF_MIN]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qi->iarr[-1]) A[N];         // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qi->iarr[DIFF_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&qi->iarr[SIZE_MAX]) A[N];   // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+\n+  {\n+    enum { MAX = (DIFF_MAX - sizeof *qi) / sizeof *qi->iarr };\n+    new (&qi->iarr[MAX]) A[N];\n+    new (&qi->iarr[MAX + 1]) A[N];  // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  }\n+\n+  new (&iarr[DIFF_MIN]) A[N];       // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&iarr[-1]) A[N];             // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&iarr[DIFF_MAX]) A[N];       // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&iarr[SIZE_MAX]) A[N];       // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+}\n+\n+\n+void test_vla (unsigned n)\n+{\n+  char cvla[n];\n+\n+  new (&cvla[DIFF_MIN]) A;          // { dg-warning \"placement new constructing an object of type .A. and size .1. in a region of type .char \\\\\\[n]. and size .0.\" }\n+  new (&cvla[-1]) A;                // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (cvla -1) A;                  // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&cvla[0]) A;\n+  new (&cvla[9]) A;\n+  new (&cvla[n - 1]) A;\n+  new (cvla + n - 1) A;\n+  new (&cvla[DIFF_MAX - 1]) A;\n+  new (&cvla[DIFF_MAX]) A;          // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (cvla + DIFF_MAX) A;          // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (&cvla[SIZE_MAX]) A;          // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+  new (cvla + SIZE_MAX) A;          // { dg-warning \"\\\\\\[-Wplacement-new\" }\n+}"}]}