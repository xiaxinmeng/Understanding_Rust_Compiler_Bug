{"sha": "10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBiNzYwMmYzZmNkMWU1YWFjMWQwN2UzMmIwYzdjM2M0ZDYwNDI2ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-04-06T13:18:41Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-04-06T13:18:41Z"}, "message": "gcov.c (struct arc_info): Replace local_span with cycle.\n\n.\t* gcov.c (struct arc_info): Replace local_span with cycle.\n\t(struct block_info): Replace u.span with u.cycle. Add is_call_return.\n\t(solve_flow_graph): Set is_call_return.\n\t(add_line_counts): Adjust. In block mode, blocks attach to last line.\n\t(accumulate_line_counts): Find graph cycles, not spanning tree.\n\t(output_branch_count): Adjust.\n\t(output_lines): Adjust.\n\t* doc/gcov.texi: Update.\ntestsuite:\n\t* gcc.misc-test/gcov-9.c: New test.\n\t* gcc.misc-test/gcov-10.c: New test\n\t* gcc.misc-test/gcov-11.c: New test.\n\nFrom-SVN: r65299", "tree": {"sha": "a6fbf3af5cdd76991bee5fa0747e84b86b53a463", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6fbf3af5cdd76991bee5fa0747e84b86b53a463"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d/comments", "author": null, "committer": null, "parents": [{"sha": "910c46b516b50e2ca38ade41c44c0f4194c1392e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/910c46b516b50e2ca38ade41c44c0f4194c1392e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/910c46b516b50e2ca38ade41c44c0f4194c1392e"}], "stats": {"total": 297, "additions": 201, "deletions": 96}, "files": [{"sha": "d186b36204a8556e3320bca56da2c4938b1bc890", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d", "patch": "@@ -1,3 +1,14 @@\n+2003-04-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* gcov.c (struct arc_info): Replace local_span with cycle.\n+\t(struct block_info): Replace u.span with u.cycle. Add is_call_return.\n+\t(solve_flow_graph): Set is_call_return.\n+\t(add_line_counts): Adjust. In block mode, blocks attach to last line.\n+\t(accumulate_line_counts): Find graph cycles, not spanning tree.\n+\t(output_branch_count): Adjust.\n+\t(output_lines): Adjust.\n+\t* doc/gcov.texi: Update.\n+\n 2003-04-06  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md (*zero_extendqisi2_h8300hs): Change"}, {"sha": "69dbcacaea754ec3c886aa5e3e90df08d55b4271", "filename": "gcc/doc/gcov.texi", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d/gcc%2Fdoc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d/gcc%2Fdoc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov.texi?ref=10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d", "patch": "@@ -152,11 +152,7 @@ and exit without doing any further processing.\n Write individual execution counts for every basic block. Normally gcov\n outputs execution counts only for the main blocks of a line. With this\n option you can determine if blocks within a single line are not being\n-executed. In this mode each block is shown, and contributes to the\n-occupancy and execution count of, the first line of source that it\n-contains. A multi-line block will only contribute to that first line,\n-and other lines will not be show to contain code, unless a subsequent\n-block begins on those lines.\n+executed.\n \n @item -b\n @itemx --branch-probabilities\n@@ -327,6 +323,17 @@ function main called 1 returned 1 blocks executed 75%\n         -:   17:@}\n @end smallexample\n \n+In this mode, each basic block is only shown on one line -- the last\n+line of the block. A multi-line block will only contribute to the\n+execution count of that last line, and other lines will not be shown\n+to contain code, unless previous blocks end on those lines.\n+The total execution count of a line is shown and subsequent lines show\n+the execution counts for individual blocks that end on that line. After each\n+block, the branch and call counts of the block will be shown, if the\n+@option{-b} option is given.\n+\n+Because of the way gcc instruments calls, a call count can be shown\n+after a line with no individual blocks.\n As you can see, line 13 contains a basic block that was not executed.\n \n @need 450"}, {"sha": "95968b585a60a4a30dd83873721ea6f2b0af7a33", "filename": "gcc/gcov.c", "status": "modified", "additions": 119, "deletions": 91, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d", "patch": "@@ -96,9 +96,9 @@ typedef struct arc_info\n   /* Is an unconditional branch.  */\n   unsigned int is_unconditional : 1;\n \n-  /* Arc on the local block spanning tree. */\n-  unsigned int local_span : 1;\n-  \n+  /* Loop making arc.  */\n+  unsigned int cycle : 1;\n+\n   /* Next branch on line.  */\n   struct arc_info *line_next;\n   \n@@ -128,7 +128,8 @@ typedef struct block_info\n   unsigned invalid_chain : 1;\n \n   /* Block is a call instrumenting site.  */\n-  unsigned is_call_site : 1;\n+  unsigned is_call_site : 1; /* Does the call.  */\n+  unsigned is_call_return : 1; /* Is the return.  */\n \n   /* Block is a landing pad for longjmp or throw.  */\n   unsigned is_nonlocal_return : 1;\n@@ -146,10 +147,11 @@ typedef struct block_info\n     } line; /* Valid until blocks are linked onto lines */\n     struct\n     {\n-      /* Single line spanning tree workspace.  Used for all-blocks mode. */\n-      struct block_info *root;\n-      unsigned siblings;\n-    } span; /* Used in all-blocks mode, after blocks are linked onto\n+      /* Single line graph cycle workspace.  Used for all-blocks\n+\t mode. */\n+      arc_t *arc;\n+      unsigned ident;\n+    } cycle; /* Used in all-blocks mode, after blocks are linked onto\n \t       lines. */\n   } u;\n \n@@ -1185,17 +1187,15 @@ solve_flow_graph (fn)\n \t\tarc->is_unconditional = 1;\n \t\t/* If this block is instrumenting a call, it might be\n \t\t   an artifical block. It is not artificial if it has\n-\t\t   a non-fallthrough exit, or the destination of the\n-\t\t   exit has more than one entry.  */\n-\t\tif (!arc->fall_through\n-\t\t    || arc->dst->pred != arc || arc->pred_next)\n-\t\t  blk->is_call_site = 0;\n+\t\t   a non-fallthrough exit, or the destination of this\n+\t\t   arc has more than one entry.  Mark the destination\n+\t\t   block as a return site, if none of those conditions\n+\t\t   hold.  */\n+\t\tif (blk->is_call_site && arc->fall_through\n+\t\t    && arc->dst->pred == arc && !arc->pred_next)\n+\t\t  arc->dst->is_call_return = 1;\n \t      }\n \t}\n-      else\n-\t/* If there is more than one exit, it cannot be an artificial\n-\t   call instrumenting site.  */\n-\tblk->is_call_site = 0;\n       \n       /* Sort the successor arcs into ascending dst order. profile.c\n \t normally produces arcs in the right order, but sometimes with\n@@ -1558,7 +1558,6 @@ add_line_counts (coverage, fn)\n       unsigned *encoding;\n       const source_t *src = NULL;\n       unsigned jx;\n-      line_t *first_line = NULL;\n \n       if (block->count && ix && ix + 1 != fn->num_blocks)\n \tfn->blocks_executed++;\n@@ -1585,23 +1584,19 @@ add_line_counts (coverage, fn)\n \t      }\n \t    line->exists = 1;\n \t    line->count += block->count;\n-\t    if (!first_line)\n-\t      first_line = line;\n \t  }\n       free (block->u.line.encoding);\n-      block->u.span.root = NULL;\n-      if (!first_line)\n-\tfirst_line = line;\n-\t  \n+      block->u.cycle.arc = NULL;\n+      block->u.cycle.ident = ~0U;\n+      \n       if (!ix || ix + 1 == fn->num_blocks)\n \t/* Entry or exit block */;\n       else if (flag_all_blocks)\n \t{\n-\t  if (!first_line)\n-\t    first_line = &fn->src->lines[fn->line];\n+\t  line_t *block_line = line ? line : &fn->src->lines[fn->line];\n \t  \n-\t  block->chain = first_line->u.blocks;\n-\t  first_line->u.blocks = block;\n+\t  block->chain = block_line->u.blocks;\n+\t  block_line->u.blocks = block;\n \t}\n       else if (flag_branches)\n \t{\n@@ -1661,10 +1656,10 @@ accumulate_line_counts (src)\n \t  /* The user expects the line count to be the number of times\n \t     a line has been executed. Simply summing the block count\n \t     will give an artificially high number.  The Right Thing\n-\t     is to generate the spanning tree of the blocks on this\n-\t     line, and the sum the entry arcs to that tree.  */\n+\t     is to sum the entry counts to the graph of blocks on this\n+\t     line, then find the elementary cycles of the local graph\n+\t     and add the transition counts of those cycles.  */\n \t  block_t *block, *block_p, *block_n;\n-\t  int changes = 1;\n \t  gcov_type count = 0;\n \t  \n \t  /* Reverse the block information */\n@@ -1673,77 +1668,110 @@ accumulate_line_counts (src)\n \t    {\n \t      block_n = block->chain;\n \t      block->chain = block_p;\n-\t      /* Each block is it's own spanning tree, with no siblings  */\n-\t      block->u.span.root = block;\n-\t      block->u.span.siblings = 0;\n+\t      block->u.cycle.ident = ix;\n \t    }\n \t  line->u.blocks = block_p;\n+\t  \n+\t  /* Sum the entry arcs.  */\n+\t  for (block = line->u.blocks; block; block = block->chain)\n+\t    {\n+\t      arc_t *arc;\n \n-\t  while (changes)\n+\t      for (arc = block->pred; arc; arc = arc->pred_next)\n+\t\t{\n+\t\t  if (arc->src->u.cycle.ident != ix)\n+\t\t    count += arc->count;\n+\t\t  if (flag_branches)\n+\t\t    add_branch_counts (&src->coverage, arc);\n+\t\t}\n+\t    }\n+\n+\t  /* Find the loops. This uses the algorithm described in\n+\t     Tiernan 'An Efficient Search Algorithm to Find the\n+\t     Elementary Circuits of a Graph', CACM Dec 1970. We hold\n+\t     the P array by having each block point to the arc that\n+\t     connects to the previous block. The H array is implicitly\n+\t     held because of the arc ordering, and the block's\n+\t     previous arc pointer.\n+\n+\t     Although the algorithm is O(N^3) for highly connected\n+\t     graphs, at worst we'll have O(N^2), as most blocks have\n+\t     only one or two exits. Most graphs will be small.\n+\n+\t     For each loop we find, locate the arc with the smallest\n+\t     transition count, and add that to the cumulative\n+\t     count. Remove the arc from consideration.  */\n+\t  for (block = line->u.blocks; block; block = block->chain)\n \t    {\n-\t      changes = 0;\n+\t      block_t *head = block;\n+\t      arc_t *arc;\n \t      \n-\t      for (block = line->u.blocks; block; block = block->chain)\n+\t    next_vertex:;\n+\t      arc = head->succ;\n+\t    current_vertex:;\n+\t      while (arc)\n \t\t{\n-\t\t  arc_t *arc;\n+\t\t  block_t *dst = arc->dst;\n+\t\t  if (/* Already used that arc.  */\n+\t\t      arc->cycle\n+\t\t      /* Not to same graph, or before first vertex.  */\n+\t\t      || dst->u.cycle.ident != ix\n+\t\t      /* Already in path.  */\n+\t\t      || dst->u.cycle.arc)\n+\t\t    {\n+\t\t      arc = arc->succ_next;\n+\t\t      continue;\n+\t\t    }\n \t\t  \n-\t\t  for (arc = block->succ; arc; arc = arc->succ_next)\n+\t\t  if (dst == block)\n \t\t    {\n-\t\t      block_t *dst = arc->dst;\n+\t\t      /* Found a closing arc.  */\n+\t\t      gcov_type cycle_count = arc->count;\n+\t\t      arc_t *cycle_arc = arc;\n+\t\t      arc_t *probe_arc;\n \t\t      \n-\t\t      if (!dst->u.span.root)\n-\t\t\t/* Not on this line.  */;\n-\t\t      else if (dst->u.span.root == block->u.span.root)\n-\t\t\t/* Same spanning tree.  */;\n-\t\t      else\n+\t\t      /* Locate the smallest arc count of the loop. */\n+\t\t      for (dst = head; (probe_arc = dst->u.cycle.arc);\n+\t\t\t   dst = probe_arc->src)\n+\t\t\tif (cycle_count > probe_arc->count)\n+\t\t\t  {\n+\t\t\t    cycle_count = probe_arc->count;\n+\t\t\t    cycle_arc = probe_arc;\n+\t\t\t  }\n+\t\t      \n+\t\t      count += cycle_count;\n+\t\t      cycle_arc->cycle = 1;\n+\t\t      /* Unwind to the cyclic arc.  */\n+\t\t      while (head != cycle_arc->src)\n \t\t\t{\n-\t\t\t  block_t *root = block->u.span.root;\n-\t\t\t  block_t *dst_root = dst->u.span.root;\n-\n-\t\t\t  /* Join spanning trees */\n-\t\t\t  if (root->u.span.siblings\n-\t\t\t      && !dst_root->u.span.siblings)\n-\t\t\t    {\n-\t\t\t      root = dst->u.span.root;\n-\t\t\t      dst_root = block->u.span.root;\n-\t\t\t    }\n-\t\t\t  \n-\t\t\t  dst_root->u.span.root = root;\n-\t\t\t  root->u.span.siblings\n-\t\t\t    += 1 + dst_root->u.span.siblings;\n-\t\t\t  \n-\t\t\t  if (dst_root->u.span.siblings)\n-\t\t\t    {\n-\t\t\t      block_t *dst_sib;\n-\t\t\t      \n-\t\t\t      dst_root->u.span.siblings = 0;\n-\t\t\t      for (dst_sib = line->u.blocks; dst_sib;\n-\t\t\t\t   dst_sib = dst_sib->chain)\n-\t\t\t\tif (dst_sib->u.span.root == dst_root)\n-\t\t\t\t  dst_sib->u.span.root = root;\n-\t\t\t    }\n-\t\t\t  arc->local_span = 1;\n-\t\t\t  changes = 1;\n+\t\t\t  arc = head->u.cycle.arc;\n+\t\t\t  head = arc->src;\n \t\t\t}\n+\t\t      /* Move on.  */\n+\t\t      arc = arc->succ_next;\n+\t\t      continue;\n \t\t    }\n+\t\t  \n+\t\t  /* Add new block to chain.  */\n+\t\t  dst->u.cycle.arc = arc;\n+\t\t  head = dst;\n+\t\t  goto next_vertex;\n \t\t}\n-\t    }\n-\n-\t  /* Now sum the entry counts */\n-\t  for (block = line->u.blocks; block; block = block->chain)\n-\t    {\n-\t      arc_t *arc;\n-\n-\t      for (arc = block->succ; arc; arc = arc->succ_next)\n+\t      /* We could not add another vertex to the path. Remove\n+\t\t the last vertex from the list.  */\n+\t      arc = head->u.cycle.arc;\n+\t      if (arc)\n \t\t{\n-\t\t  if (!arc->local_span)\n-\t\t    count += arc->count;\n-\t\t  if (flag_branches)\n-\t\t    add_branch_counts (&src->coverage, arc);\n+\t\t  /* It was not the first vertex. Move onto next arc. */\n+\t\t  head->u.cycle.arc = NULL;\n+\t\t  head = arc->src;\n+\t\t  arc = arc->succ_next;\n+\t\t  goto current_vertex;\n \t\t}\n-\t      block->u.span.root = NULL;\n+\t      /* Mark this block as unusable.  */\n+\t      block->u.cycle.ident = ~0U;\n \t    }\n-\t  \n+\n \t  line->count = count;\n \t}\n       \n@@ -1786,7 +1814,7 @@ output_branch_count (gcov_file, ix, arc)\n       else\n \tfnotice (gcov_file, \"branch %2d never executed\\n\", ix);\n     }\n-  else if (flag_unconditional && !arc->src->is_call_site)\n+  else if (flag_unconditional && !arc->dst->is_call_return)\n     {\n       if (arc->src->count)\n \tfnotice (gcov_file, \"unconditional %2d taken %s\\n\", ix,\n@@ -1895,17 +1923,17 @@ output_lines (gcov_file, src)\n       if (flag_all_blocks)\n \t{\n \t  block_t *block;\n+\t  arc_t *arc;\n \t  int ix, jx;\n \t  \n \t  for (ix = jx = 0, block = line->u.blocks; block;\n \t       block = block->chain)\n \t    {\n-\t      arc_t *arc;\n-\n-\t      if (!block->is_call_site)\n+\t      if (!block->is_call_return)\n \t\tfprintf (gcov_file, \"%9s:%5u-block %2d\\n\",\n \t\t\t !line->exists ? \"-\" : !block->count ? \"$$$$$\"\n-\t\t\t : format_gcov (block->count, 0, -1), line_num, ix++);\n+\t\t\t : format_gcov (block->count, 0, -1),\n+\t\t\t line_num, ix++);\n \t      if (flag_branches)\n \t\tfor (arc = block->succ; arc; arc = arc->succ_next)\n \t\t  jx += output_branch_count (gcov_file, jx, arc);"}, {"sha": "f0bafa1b086ab1ee5737e53a80b3db64c136417b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d", "patch": "@@ -1,3 +1,9 @@\n+2003-04-06  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* gcc.misc-test/gcov-9.c: New test.\n+\t* gcc.misc-test/gcov-10.c: New test\n+\t* gcc.misc-test/gcov-11.c: New test.\n+\n 2003-04-05  Zack Weinberg  <zack@codesourcery.com>\n \n \tPR optimization/10024"}, {"sha": "bd1d418f378a9cc9482b581205416fa2bd80c313", "filename": "gcc/testsuite/gcc.misc-tests/gcov-10.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-10.c?ref=10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d", "patch": "@@ -0,0 +1,15 @@\n+/* Test gcov block mode.  */\n+\n+/* { dg-options \"-fprofile-arcs -ftest-coverage\" } */\n+/* { dg-do run { target native } } */\n+\n+int main ()\n+{\n+  unsigned ix, jx = 0;\n+  \n+  for (ix = 10; ix--;) if (ix & 1) jx++; /* count(11) */\n+\n+  return jx != 5;\n+}\n+\n+/* { dg-final { run-gcov { -a gcov-10.c } } } */"}, {"sha": "a1037a552a94edcaab53228d849c0413185313b9", "filename": "gcc/testsuite/gcc.misc-tests/gcov-11.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-11.c?ref=10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d", "patch": "@@ -0,0 +1,23 @@\n+/* Test gcov block mode.  */\n+\n+/* { dg-options \"-fprofile-arcs -ftest-coverage\" } */\n+/* { dg-do run { target native } } */\n+\n+int one = 1; /* subvert constant folder. */\n+int zero = 0;\n+\n+int foo (int ix)\n+{\n+  return ix & 1 ? one : zero; /* count(10) */\n+}\n+\n+int main ()\n+{\n+  unsigned ix, jx = 0;\n+  \n+  for (ix = 10; ix--;) jx += foo (ix); /* count(11) */\n+\n+  return jx != 5;\n+}\n+\n+/* { dg-final { run-gcov { -a gcov-11.c } } } */"}, {"sha": "6e1b4a85c0c507195bbdf9a8c370a95c53fe548f", "filename": "gcc/testsuite/gcc.misc-tests/gcov-9.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.misc-tests%2Fgcov-9.c?ref=10b7602f3fcd1e5aac1d07e32b0c7c3c4d60426d", "patch": "@@ -0,0 +1,15 @@\n+/* Test gcov block mode.  */\n+\n+/* { dg-options \"-fprofile-arcs -ftest-coverage\" } */\n+/* { dg-do run { target native } } */\n+\n+int main ()\n+{\n+  unsigned ix;\n+  \n+  for (ix = 10; ix--;); /* count(11) */\n+\n+  return 0;\n+}\n+\n+/* { dg-final { run-gcov { -a gcov-9.c } } } */"}]}