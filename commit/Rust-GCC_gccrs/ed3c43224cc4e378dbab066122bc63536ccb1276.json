{"sha": "ed3c43224cc4e378dbab066122bc63536ccb1276", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQzYzQzMjI0Y2M0ZTM3OGRiYWIwNjYxMjJiYzYzNTM2Y2NiMTI3Ng==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-05-03T07:17:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-05-03T13:11:03Z"}, "message": "Perform reverse program order walk for GIMPLE DSE\n\nThe following changes the post-dominator domwalk done by GIMPLE DSE\nto a reverse program order walk.  This enables 2% more stmts do be\nDSEd during bootstrap and in particular for testcases like the one\nadded where it is important to visit post dominators in a particular\norder.\n\n2021-05-03  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-dse.c: Do not include domwalk.h but cfganal.h.\n\t(dse_dom_walker): Remove.\n\t(dse_dom_walker::dse_optimize_stmt): Rename...\n\t(dse_optimize_stmt): ... to this, pass in live_bytes sbitmap.\n\t(dse_dom_walker::before_dom_children): Inline ...\n\t(pass_dse::execute): ... here.  Perform a reverse program\n\torder walk.\n\n\t* gcc.dg/tree-ssa/ssa-dse-41.c: New testcase.", "tree": {"sha": "2165a02f756b5ccf068014f670bfc7fe4044bcea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2165a02f756b5ccf068014f670bfc7fe4044bcea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed3c43224cc4e378dbab066122bc63536ccb1276", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed3c43224cc4e378dbab066122bc63536ccb1276", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed3c43224cc4e378dbab066122bc63536ccb1276", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed3c43224cc4e378dbab066122bc63536ccb1276/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f570621352970945db657455e0570208ea2d70e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f570621352970945db657455e0570208ea2d70e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f570621352970945db657455e0570208ea2d70e"}], "stats": {"total": 198, "additions": 91, "deletions": 107}, "files": [{"sha": "9128eea1035dc11df9eb89046b24a41d683ba1d5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-41.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3c43224cc4e378dbab066122bc63536ccb1276/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-41.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3c43224cc4e378dbab066122bc63536ccb1276/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-41.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-41.c?ref=ed3c43224cc4e378dbab066122bc63536ccb1276", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-dse1\" } */\n+\n+int a[2];\n+void foo(int i, int k)\n+{\n+  a[0] = i;\n+  if (k)\n+    a[0] = a[i] + k;\n+  else\n+    a[0] = a[i] + 3;\n+  a[0] = 0;\n+}\n+\n+/* Only the last store remains.  */\n+/* { dg-final { scan-tree-dump-times \" = \" 1 \"dse1\" } } */"}, {"sha": "e0a944c704a14fd97091e272b75d6c38f058cfef", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 75, "deletions": 107, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3c43224cc4e378dbab066122bc63536ccb1276/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3c43224cc4e378dbab066122bc63536ccb1276/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=ed3c43224cc4e378dbab066122bc63536ccb1276", "patch": "@@ -31,7 +31,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-iterator.h\"\n #include \"tree-cfg.h\"\n #include \"tree-dfa.h\"\n-#include \"domwalk.h\"\n #include \"tree-cfgcleanup.h\"\n #include \"alias.h\"\n #include \"tree-ssa-loop.h\"\n@@ -40,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-fold.h\"\n #include \"gimplify.h\"\n #include \"tree-eh.h\"\n+#include \"cfganal.h\"\n \n /* This file implements dead store elimination.\n \n@@ -958,31 +958,6 @@ dse_classify_store (ao_ref *ref, gimple *stmt,\n }\n \n \n-class dse_dom_walker : public dom_walker\n-{\n-public:\n-  dse_dom_walker (cdi_direction direction)\n-    : dom_walker (direction),\n-    m_live_bytes (param_dse_max_object_size),\n-    m_byte_tracking_enabled (false),\n-    m_need_cfg_cleanup (false) {}\n-\n-  virtual edge before_dom_children (basic_block);\n-  unsigned todo () const;\n-\n-private:\n-  auto_sbitmap m_live_bytes;\n-  bool m_byte_tracking_enabled;\n-  bool m_need_cfg_cleanup;\n-  void dse_optimize_stmt (gimple_stmt_iterator *);\n-};\n-\n-unsigned\n-dse_dom_walker::todo () const\n-{\n-  return m_need_cfg_cleanup ? TODO_cleanup_cfg : 0;\n-}\n-\n /* Delete a dead call at GSI, which is mem* call of some kind.  */\n static void\n delete_dead_or_redundant_call (gimple_stmt_iterator *gsi, const char *type)\n@@ -1054,8 +1029,8 @@ delete_dead_or_redundant_assignment (gimple_stmt_iterator *gsi, const char *type\n    is used precisely once by a later store to the same location which\n    post dominates the first store, then the first store is dead.  */\n \n-void\n-dse_dom_walker::dse_optimize_stmt (gimple_stmt_iterator *gsi)\n+static void\n+dse_optimize_stmt (gimple_stmt_iterator *gsi, sbitmap live_bytes)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n \n@@ -1104,17 +1079,17 @@ dse_dom_walker::dse_optimize_stmt (gimple_stmt_iterator *gsi)\n \t      dse_optimize_redundant_stores (stmt);\n \n \t    enum dse_store_status store_status;\n-\t    m_byte_tracking_enabled\n-\t      = setup_live_bytes_from_ref (&ref, m_live_bytes);\n+\t    bool byte_tracking_enabled\n+\t      = setup_live_bytes_from_ref (&ref, live_bytes);\n \t    store_status = dse_classify_store (&ref, stmt,\n-\t\t\t\t\t       m_byte_tracking_enabled,\n-\t\t\t\t\t       m_live_bytes);\n+\t\t\t\t\t       byte_tracking_enabled,\n+\t\t\t\t\t       live_bytes);\n \t    if (store_status == DSE_STORE_LIVE)\n \t      return;\n \n \t    if (store_status == DSE_STORE_MAYBE_PARTIAL_DEAD)\n \t      {\n-\t\tmaybe_trim_memstar_call (&ref, m_live_bytes, stmt);\n+\t\tmaybe_trim_memstar_call (&ref, live_bytes, stmt);\n \t\treturn;\n \t      }\n \n@@ -1150,18 +1125,18 @@ dse_dom_walker::dse_optimize_stmt (gimple_stmt_iterator *gsi)\n \t;\n       else\n \t{\n-\t  m_byte_tracking_enabled\n-\t    = setup_live_bytes_from_ref (&ref, m_live_bytes);\n+\t  bool byte_tracking_enabled\n+\t    = setup_live_bytes_from_ref (&ref, live_bytes);\n \t  enum dse_store_status store_status;\n \t  store_status = dse_classify_store (&ref, stmt,\n-\t\t\t\t\t     m_byte_tracking_enabled,\n-\t\t\t\t\t     m_live_bytes, &by_clobber_p);\n+\t\t\t\t\t     byte_tracking_enabled,\n+\t\t\t\t\t     live_bytes, &by_clobber_p);\n \t  if (store_status == DSE_STORE_LIVE)\n \t    return;\n \n \t  if (store_status == DSE_STORE_MAYBE_PARTIAL_DEAD)\n \t    {\n-\t      maybe_trim_partially_dead_store (&ref, m_live_bytes, stmt);\n+\t      maybe_trim_partially_dead_store (&ref, live_bytes, stmt);\n \t      return;\n \t    }\n \t}\n@@ -1178,64 +1153,6 @@ dse_dom_walker::dse_optimize_stmt (gimple_stmt_iterator *gsi)\n     }\n }\n \n-edge\n-dse_dom_walker::before_dom_children (basic_block bb)\n-{\n-  gimple_stmt_iterator gsi;\n-\n-  for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi);)\n-    {\n-      gimple *stmt = gsi_stmt (gsi);\n-\n-      if (gimple_vdef (stmt))\n-\tdse_optimize_stmt (&gsi);\n-      else if (def_operand_p def_p = single_ssa_def_operand (stmt, SSA_OP_DEF))\n-\t{\n-\t  /* When we remove dead stores make sure to also delete trivially\n-\t     dead SSA defs.  */\n-\t  if (has_zero_uses (DEF_FROM_PTR (def_p))\n-\t      && !gimple_has_side_effects (stmt)\n-\t      && !stmt_unremovable_because_of_non_call_eh_p (cfun, stmt))\n-\t    {\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"  Deleted trivially dead stmt: \");\n-\t\t  print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n-\t\t  fprintf (dump_file, \"\\n\");\n-\t\t}\n-\t      if (gsi_remove (&gsi, true) && need_eh_cleanup)\n-\t\tbitmap_set_bit (need_eh_cleanup, bb->index);\n-\t      release_defs (stmt);\n-\t    }\n-\t}\n-      if (gsi_end_p (gsi))\n-\tgsi = gsi_last_bb (bb);\n-      else\n-\tgsi_prev (&gsi);\n-    }\n-  bool removed_phi = false;\n-  for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);)\n-    {\n-      gphi *phi = si.phi ();\n-      if (has_zero_uses (gimple_phi_result (phi)))\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"  Deleted trivially dead PHI: \");\n-\t      print_gimple_stmt (dump_file, phi, 0, dump_flags);\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\t  remove_phi_node (&si, true);\n-\t  removed_phi = true;\n-\t}\n-      else\n-\tgsi_next (&si);\n-    }\n-  if (removed_phi && gimple_seq_empty_p (phi_nodes (bb)))\n-    m_need_cfg_cleanup = true;\n-  return NULL;\n-}\n-\n namespace {\n \n const pass_data pass_data_dse =\n@@ -1268,24 +1185,75 @@ class pass_dse : public gimple_opt_pass\n unsigned int\n pass_dse::execute (function *fun)\n {\n+  unsigned todo = 0;\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n+  auto_sbitmap live_bytes (param_dse_max_object_size);\n \n   renumber_gimple_stmt_uids (cfun);\n \n-  /* We might consider making this a property of each pass so that it\n-     can be [re]computed on an as-needed basis.  Particularly since\n-     this pass could be seen as an extension of DCE which needs post\n-     dominators.  */\n-  calculate_dominance_info (CDI_POST_DOMINATORS);\n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  /* Dead store elimination is fundamentally a walk of the post-dominator\n-     tree and a backwards walk of statements within each block.  */\n-  dse_dom_walker walker (CDI_POST_DOMINATORS);\n-  walker.walk (fun->cfg->x_exit_block_ptr);\n-  free_dominance_info (CDI_POST_DOMINATORS);\n+  /* Dead store elimination is fundamentally a reverse program order walk.  */\n+  int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fun) - NUM_FIXED_BLOCKS);\n+  int n = pre_and_rev_post_order_compute_fn (fun, NULL, rpo, false);\n+  for (int i = n; i != 0; --i)\n+    {\n+      basic_block bb = BASIC_BLOCK_FOR_FN (fun, rpo[i-1]);\n+      gimple_stmt_iterator gsi;\n \n-  unsigned todo = walker.todo ();\n+      for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi);)\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\n+\t  if (gimple_vdef (stmt))\n+\t    dse_optimize_stmt (&gsi, live_bytes);\n+\t  else if (def_operand_p\n+\t\t     def_p = single_ssa_def_operand (stmt, SSA_OP_DEF))\n+\t    {\n+\t      /* When we remove dead stores make sure to also delete trivially\n+\t\t dead SSA defs.  */\n+\t      if (has_zero_uses (DEF_FROM_PTR (def_p))\n+\t\t  && !gimple_has_side_effects (stmt)\n+\t\t  && !stmt_unremovable_because_of_non_call_eh_p (cfun, stmt))\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file, \"  Deleted trivially dead stmt: \");\n+\t\t      print_gimple_stmt (dump_file, stmt, 0, dump_flags);\n+\t\t      fprintf (dump_file, \"\\n\");\n+\t\t    }\n+\t\t  if (gsi_remove (&gsi, true) && need_eh_cleanup)\n+\t\t    bitmap_set_bit (need_eh_cleanup, bb->index);\n+\t\t  release_defs (stmt);\n+\t\t}\n+\t    }\n+\t  if (gsi_end_p (gsi))\n+\t    gsi = gsi_last_bb (bb);\n+\t  else\n+\t    gsi_prev (&gsi);\n+\t}\n+      bool removed_phi = false;\n+      for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);)\n+\t{\n+\t  gphi *phi = si.phi ();\n+\t  if (has_zero_uses (gimple_phi_result (phi)))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"  Deleted trivially dead PHI: \");\n+\t\t  print_gimple_stmt (dump_file, phi, 0, dump_flags);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t      remove_phi_node (&si, true);\n+\t      removed_phi = true;\n+\t    }\n+\t  else\n+\t    gsi_next (&si);\n+\t}\n+      if (removed_phi && gimple_seq_empty_p (phi_nodes (bb)))\n+\ttodo |= TODO_cleanup_cfg;\n+    }\n+  free (rpo);\n \n   /* Removal of stores may make some EH edges dead.  Purge such edges from\n      the CFG as needed.  */"}]}