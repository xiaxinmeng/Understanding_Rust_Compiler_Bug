{"sha": "db7eb3e895d39dad0b52b97deed14220d70480d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI3ZWIzZTg5NWQzOWRhZDBiNTJiOTdkZWVkMTQyMjBkNzA0ODBkNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-15T00:34:45Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-15T00:34:45Z"}, "message": "sparc.md (*): Use {nonimmediate,register}_operand as appropriate instead of general_operand...\n\n        * sparc.md (*): Use {nonimmediate,register}_operand as appropriate\n        instead of general_operand in a SET_DEST.  Use const_double_operand\n        instead of an explicit test against CONST_DOUBLE.\n        (movsf_const_lo): Add missing register mode.\n        (goto_handler_and_restore): Add auxiliary test for Pmode.\n        (flush): Adjust to use address_operand.\n        (return_sf_no_fpu): Add missing output constraint.\n\nFrom-SVN: r29993", "tree": {"sha": "282589801f2a8f4d88c03cbc7846f61e1c4abb9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/282589801f2a8f4d88c03cbc7846f61e1c4abb9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db7eb3e895d39dad0b52b97deed14220d70480d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db7eb3e895d39dad0b52b97deed14220d70480d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db7eb3e895d39dad0b52b97deed14220d70480d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db7eb3e895d39dad0b52b97deed14220d70480d6/comments", "author": null, "committer": null, "parents": [{"sha": "2d1086d8b76c416d41f603cbd1b454e547d16786", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d1086d8b76c416d41f603cbd1b454e547d16786", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d1086d8b76c416d41f603cbd1b454e547d16786"}], "stats": {"total": 110, "additions": 51, "deletions": 59}, "files": [{"sha": "a6b28a77ca75456ead931e97e90d2c3830243e4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db7eb3e895d39dad0b52b97deed14220d70480d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db7eb3e895d39dad0b52b97deed14220d70480d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db7eb3e895d39dad0b52b97deed14220d70480d6", "patch": "@@ -1,3 +1,13 @@\n+Thu Oct 14 17:30:14 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* sparc.md (*): Use {nonimmediate,register}_operand as appropriate\n+\tinstead of general_operand in a SET_DEST.  Use const_double_operand\n+\tinstead of an explicit test against CONST_DOUBLE.\n+\t(movsf_const_lo): Add missing register mode.\n+\t(goto_handler_and_restore): Add auxiliary test for Pmode.\n+\t(flush): Adjust to use address_operand.\n+\t(return_sf_no_fpu): Add missing output constraint.\n+\n Thu Oct 14 17:21:26 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* rs6000.md (call_value_indirect_aix32): Use wildcard match_operand"}, {"sha": "bdfebefa9cdef67e64563afc3944e7623ac13f77", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 41, "deletions": 59, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db7eb3e895d39dad0b52b97deed14220d70480d6/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db7eb3e895d39dad0b52b97deed14220d70480d6/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=db7eb3e895d39dad0b52b97deed14220d70480d6", "patch": "@@ -1925,7 +1925,7 @@\n }\")\n \n (define_insn \"*movqi_insn\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,m\")\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,m\")\n \t(match_operand:QI 1 \"input_operand\"   \"rI,m,rJ\"))]\n   \"(register_operand (operands[0], QImode)\n     || reg_or_0_operand (operands[1], QImode))\"\n@@ -2002,7 +2002,7 @@\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"*movhi_insn\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r,r,r,m\")\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,m\")\n \t(match_operand:HI 1 \"input_operand\"   \"rI,K,m,rJ\"))]\n   \"(register_operand (operands[0], HImode)\n     || reg_or_0_operand (operands[1], HImode))\"\n@@ -2117,7 +2117,7 @@\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"*movsi_insn\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r,f,r,r,r,f,m,m,d\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,f,r,r,r,f,m,m,d\")\n \t(match_operand:SI 1 \"input_operand\"   \"rI,!f,K,J,m,!m,rJ,!f,J\"))]\n   \"(register_operand (operands[0], SImode)\n     || reg_or_0_operand (operands[1], SImode))\"\n@@ -2305,7 +2305,7 @@\n ;;      (reg:DI 2 %g2))\n ;;\n (define_insn \"*movdi_insn_sp32\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=T,U,o,r,r,r,?T,?f,?f,?o,?f\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=T,U,o,r,r,r,?T,?f,?f,?o,?f\")\n         (match_operand:DI 1 \"input_operand\"    \"U,T,r,o,i,r,f,T,o,f,f\"))]\n   \"! TARGET_ARCH64 &&\n    (register_operand (operands[0], DImode)\n@@ -2346,7 +2346,7 @@\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"*movdi_insn_sp64\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=r,r,r,r,m,?e,?e,?m,b\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,?e,?e,?m,b\")\n         (match_operand:DI 1 \"input_operand\"   \"rI,K,J,m,rJ,e,m,e,J\"))]\n   \"TARGET_ARCH64 &&\n    (register_operand (operands[0], DImode)\n@@ -2733,7 +2733,7 @@\n ;; Floating point move insns\n \n (define_insn \"*clear_sf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n         (match_operand:SF 1 \"\" \"\"))]\n   \"TARGET_VIS\n    && GET_CODE (operands[1]) == CONST_DOUBLE\n@@ -2744,11 +2744,9 @@\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"*movsf_const_intreg\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f,r\")\n-        (match_operand:SF 1 \"\"                 \"m,F\"))]\n-  \"TARGET_FPU\n-   && GET_CODE (operands[1]) == CONST_DOUBLE\n-   && GET_CODE (operands[0]) == REG\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=fr\")\n+        (match_operand:SF 1 \"const_double_operand\" \"F\"))]\n+  \"TARGET_FPU\"\n   \"*\n {\n   REAL_VALUE_TYPE r;\n@@ -2788,7 +2786,7 @@\n \n (define_insn \"*movsf_const_lo\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-        (unspec:SF [(match_operand 1 \"register_operand\" \"r\")\n+        (unspec:SF [(match_operand:SF 1 \"register_operand\" \"r\")\n                     (match_operand 2 \"const_int_operand\" \"\")] 17))]\n   \"\"\n   \"or\\\\t%1, %%lo(%a2), %0\"\n@@ -2872,7 +2870,7 @@\n }\")\n \n (define_insn \"*movsf_insn\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f,f,m,r,r,m\")\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,m,r,r,m\")\n \t(match_operand:SF 1 \"input_operand\"    \"f,m,f,r,m,r\"))]\n   \"TARGET_FPU\n    && (register_operand (operands[0], SFmode)\n@@ -2892,7 +2890,7 @@\n ;; when -mno-fpu.\n \n (define_insn \"*movsf_no_f_insn\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=r,r,m\")\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m\")\n \t(match_operand:SF 1 \"input_operand\"    \"r,m,r\"))]\n   \"! TARGET_FPU\n    && (register_operand (operands[0], SFmode)\n@@ -2905,56 +2903,40 @@\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"*clear_df\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=e\")\n-        (match_operand:DF 1 \"\" \"\"))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=e\")\n+        (match_operand:DF 1 \"const_double_operand\" \"\"))]\n   \"TARGET_VIS\n-   && GET_CODE (operands[1]) == CONST_DOUBLE\n-   && GET_CODE (operands[0]) == REG\n    && fp_zero_operand (operands[1])\"\n   \"fzero\\\\t%0\"\n   [(set_attr \"type\" \"fpmove\")\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"*movdf_const_intreg_sp32\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=e,e,r\")\n-        (match_operand:DF 1 \"\"                 \"T,o,F\"))]\n-  \"TARGET_FPU && ! TARGET_ARCH64\n-   && GET_CODE (operands[1]) == CONST_DOUBLE\n-   && GET_CODE (operands[0]) == REG\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    return \\\"ldd\\\\t%1, %0\\\";\n-  else\n-    return \\\"#\\\";\n-}\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=e,r\")\n+        (match_operand:DF 1 \"const_double_operand\" \"T,F\"))]\n+  \"TARGET_FPU && ! TARGET_ARCH64\"\n+  \"@\n+   ldd\\\\t%1, %0\n+   #\"\n   [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"1,2,2\")])\n+   (set_attr \"length\" \"1,2\")])\n \n ;; Now that we redo life analysis with a clean slate after\n ;; instruction splitting for sched2 this can work.\n (define_insn \"*movdf_const_intreg_sp64\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=e,e,r\")\n-        (match_operand:DF 1 \"\"                 \"m,o,F\"))]\n-  \"TARGET_FPU\n-   && TARGET_ARCH64\n-   && GET_CODE (operands[1]) == CONST_DOUBLE\n-   && GET_CODE (operands[0]) == REG\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    return \\\"ldd\\\\t%1, %0\\\";\n-  else\n-    return \\\"#\\\";\n-}\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=e,r\")\n+        (match_operand:DF 1 \"const_double_operand\" \"m,F\"))]\n+  \"TARGET_FPU && TARGET_ARCH64\"\n+  \"@\n+   ldd\\\\t%1, %0\n+   #\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n \n (define_split\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n         (match_operand:DF 1 \"const_double_operand\" \"\"))]\n   \"TARGET_FPU\n-   && GET_CODE (operands[1]) == CONST_DOUBLE\n    && (GET_CODE (operands[0]) == REG\n        && REGNO (operands[0]) < 32)\n    && reload_completed\"\n@@ -3067,7 +3049,7 @@\n \n ;; Be careful, fmovd does not exist when !v9.\n (define_insn \"*movdf_insn_sp32\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=e,T,U,T,e,r,r,o,e,o\")\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,T,U,T,e,r,r,o,e,o\")\n \t(match_operand:DF 1 \"input_operand\"    \"T,e,T,U,e,r,o,r,o,e\"))]\n   \"TARGET_FPU\n    && ! TARGET_V9\n@@ -3088,7 +3070,7 @@\n   (set_attr \"length\" \"1,1,1,1,2,2,2,2,2,2\")])\n \n (define_insn \"*movdf_no_e_insn_sp32\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=U,T,r,r,o\")\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=U,T,r,r,o\")\n \t(match_operand:DF 1 \"input_operand\"    \"T,U,r,o,r\"))]\n   \"! TARGET_FPU\n    && ! TARGET_ARCH64\n@@ -3106,7 +3088,7 @@\n ;; We have available v9 double floats but not 64-bit\n ;; integer registers.\n (define_insn \"*movdf_insn_v9only\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=e,e,m,U,T,r,r,o\")\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,e,m,U,T,r,r,o\")\n         (match_operand:DF 1 \"input_operand\"    \"e,m,e,T,U,r,o,r\"))]\n   \"TARGET_FPU\n    && TARGET_V9\n@@ -3128,7 +3110,7 @@\n ;; We have available both v9 double floats and 64-bit\n ;; integer registers.\n (define_insn \"*movdf_insn_sp64\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=e,e,m,r,r,m\")\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=e,e,m,r,r,m\")\n         (match_operand:DF 1 \"input_operand\"    \"e,m,e,r,m,r\"))]\n   \"TARGET_FPU\n    && TARGET_V9\n@@ -3146,7 +3128,7 @@\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"*movdf_no_e_insn_sp64\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=r,r,m\")\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,m\")\n         (match_operand:DF 1 \"input_operand\"    \"r,m,r\"))]\n   \"! TARGET_FPU\n    && TARGET_ARCH64\n@@ -3336,7 +3318,7 @@\n ;; Be careful, fmovq and {st,ld}{x,q} do not exist when !arch64 so\n ;; we must split them all.  :-(\n (define_insn \"*movtf_insn_sp32\"\n-  [(set (match_operand:TF 0 \"general_operand\" \"=e,o,U,o,e,r,r,o\")\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,o,U,o,e,r,r,o\")\n \t(match_operand:TF 1 \"input_operand\"    \"o,e,o,U,e,r,o,r\"))]\n   \"TARGET_FPU\n    && ! TARGET_ARCH64\n@@ -3350,7 +3332,7 @@\n ;; when -mno-fpu.\n \n (define_insn \"*movtf_no_e_insn_sp32\"\n-  [(set (match_operand:TF 0 \"general_operand\" \"=U,o,r,r,o\")\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=U,o,r,r,o\")\n \t(match_operand:TF 1 \"input_operand\"    \"o,U,r,o,r\"))]\n   \"! TARGET_FPU\n    && ! TARGET_ARCH64\n@@ -3362,7 +3344,7 @@\n ;; Now handle the float reg cases directly when arch64,\n ;; hard_quad, and proper reg number alignment are all true.\n (define_insn \"*movtf_insn_hq_sp64\"\n-  [(set (match_operand:TF 0 \"general_operand\" \"=e,e,m,r,r,o\")\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,e,m,r,r,o\")\n         (match_operand:TF 1 \"input_operand\"    \"e,m,e,r,o,r\"))]\n   \"TARGET_FPU\n    && TARGET_ARCH64\n@@ -3383,7 +3365,7 @@\n ;; Now we allow the integer register cases even when\n ;; only arch64 is true.\n (define_insn \"*movtf_insn_sp64\"\n-  [(set (match_operand:TF 0 \"general_operand\" \"=e,o,r,o,e,r\")\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=e,o,r,o,e,r\")\n         (match_operand:TF 1 \"input_operand\"    \"o,e,o,r,e,r\"))]\n   \"TARGET_FPU\n    && TARGET_ARCH64\n@@ -3394,7 +3376,7 @@\n   [(set_attr \"length\" \"2\")])\n \n (define_insn \"*movtf_no_e_insn_sp64\"\n-  [(set (match_operand:TF 0 \"general_operand\" \"=r,o,r\")\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=r,o,r\")\n         (match_operand:TF 1 \"input_operand\"    \"o,r,r\"))]\n   \"! TARGET_FPU\n    && TARGET_ARCH64\n@@ -7834,7 +7816,7 @@\n \n (define_insn \"goto_handler_and_restore\"\n   [(unspec_volatile [(match_operand 0 \"register_operand\" \"=r\")] 2)]\n-  \"\"\n+  \"GET_MODE (operands[0]) == Pmode\"\n   \"jmp\\\\t%0+0\\\\n\\\\trestore\"\n   [(set_attr \"type\" \"misc\")\n    (set_attr \"length\" \"2\")])\n@@ -7893,9 +7875,9 @@\n ;; Special pattern for the FLUSH instruction.\n \n (define_insn \"flush\"\n-  [(unspec_volatile [(match_operand 0 \"memory_operand\" \"m\")] 4)]\n+  [(unspec_volatile [(mem (match_operand 0 \"address_operand\" \"p\"))] 4)]\n   \"\"\n-  \"* return TARGET_V9 ? \\\"flush\\\\t%f0\\\" : \\\"iflush\\\\t%f0\\\";\"\n+  \"* return TARGET_V9 ? \\\"flush\\\\t%a0\\\" : \\\"iflush\\\\t%a0\\\";\"\n   [(set_attr \"type\" \"misc\")\n    (set_attr \"length\" \"1\")])\n \f\n@@ -8142,7 +8124,7 @@\n ;; ! TARGET_FPU because we move complex types around by parts using\n ;; SF mode SUBREGs.\n (define_insn \"*return_sf_no_fpu\"\n-  [(set (match_operand:SF 0 \"restore_operand\" \"r\")\n+  [(set (match_operand:SF 0 \"restore_operand\" \"=r\")\n \t(match_operand:SF 1 \"register_operand\" \"r\"))\n    (return)]\n   \"! TARGET_EPILOGUE && ! TARGET_LIVE_G0\""}]}