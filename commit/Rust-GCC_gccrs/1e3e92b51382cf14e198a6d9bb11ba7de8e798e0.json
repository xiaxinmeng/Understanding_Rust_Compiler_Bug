{"sha": "1e3e92b51382cf14e198a6d9bb11ba7de8e798e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUzZTkyYjUxMzgyY2YxNGUxOThhNmQ5YmIxMWJhN2RlOGU3OThlMA==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2014-12-19T04:56:26Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2014-12-19T04:56:26Z"}, "message": "* [SH] Split QI/HImode load/store via r0 when LRA is enabled.\n\nFrom-SVN: r218892", "tree": {"sha": "500eab9e57b28df315fca2ac7efd0c39b5966f45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/500eab9e57b28df315fca2ac7efd0c39b5966f45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e3e92b51382cf14e198a6d9bb11ba7de8e798e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e3e92b51382cf14e198a6d9bb11ba7de8e798e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e3e92b51382cf14e198a6d9bb11ba7de8e798e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e3e92b51382cf14e198a6d9bb11ba7de8e798e0/comments", "author": null, "committer": null, "parents": [{"sha": "74bd0da1fd3bdffc036f0449c4d3ea7c95129585", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74bd0da1fd3bdffc036f0449c4d3ea7c95129585", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74bd0da1fd3bdffc036f0449c4d3ea7c95129585"}], "stats": {"total": 37, "additions": 37, "deletions": 0}, "files": [{"sha": "e67e97c9d24d8b369483c8b4ac1f7ce2f4fe5084", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3e92b51382cf14e198a6d9bb11ba7de8e798e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3e92b51382cf14e198a6d9bb11ba7de8e798e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e3e92b51382cf14e198a6d9bb11ba7de8e798e0", "patch": "@@ -1,3 +1,8 @@\n+2014-12-19  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* config/sh/sh.c (prepare_move_operands): Split HI/QImode load/store\n+\tto two move insns via r0.\n+\n 2014-12-19  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/predicates.md (arith_or_int_operand): New predicate."}, {"sha": "8ad8afa5ac6ee671a03ffd54bda625e1ff496c36", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e3e92b51382cf14e198a6d9bb11ba7de8e798e0/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e3e92b51382cf14e198a6d9bb11ba7de8e798e0/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=1e3e92b51382cf14e198a6d9bb11ba7de8e798e0", "patch": "@@ -1778,6 +1778,38 @@ prepare_move_operands (rtx operands[], machine_mode mode)\n \t       && GET_CODE (XEXP (operands[0], 0)) == PLUS\n \t       && REG_P (XEXP (XEXP (operands[0], 0), 1)))\n \toperands[1] = copy_to_mode_reg (mode, operands[1]);\n+\n+      /* When the displacement addressing is used, RA will assign r0 to\n+\t the pseudo register operand for the QI/HImode load/store.\n+\t This tends to make a long live range for R0 and might cause\n+\t anomalous register spills in some case with LRA.  See PR\n+\t target/55212.\n+\t We split possible load/store to two move insns via r0 so as to\n+\t shorten R0 live range.  It will make some codes worse but will\n+\t win on avarage for LRA.  */\n+      else if (sh_lra_p ()\n+\t       && TARGET_SH1 && ! TARGET_SH2A\n+\t       && (mode == QImode || mode == HImode)\n+\t       && ((REG_P (operands[0]) && MEM_P (operands[1]))\n+\t\t   || (REG_P (operands[1]) && MEM_P (operands[0]))))\n+\t{\n+\t  bool load_p = REG_P (operands[0]);\n+\t  rtx reg = operands[load_p ? 0 : 1];\n+\t  rtx adr = XEXP (operands[load_p ? 1 : 0], 0);\n+\n+\t  if (REGNO (reg) >= FIRST_PSEUDO_REGISTER\n+\t      && GET_CODE (adr) == PLUS\n+\t      && REG_P (XEXP (adr, 0))\n+\t      && (REGNO (XEXP (adr, 0)) >= FIRST_PSEUDO_REGISTER)\n+\t      && CONST_INT_P (XEXP (adr, 1))\n+\t      && INTVAL (XEXP (adr, 1)) != 0\n+\t      && sh_legitimate_index_p (mode, XEXP (adr, 1), false, true))\n+\t    {\n+\t      rtx r0_rtx = gen_rtx_REG (mode, R0_REG);\n+\t      emit_move_insn (r0_rtx, operands[1]);\n+\t      operands[1] = r0_rtx;\n+\t    }\n+\t}\n     }\n \n   if (mode == Pmode || mode == ptr_mode)"}]}