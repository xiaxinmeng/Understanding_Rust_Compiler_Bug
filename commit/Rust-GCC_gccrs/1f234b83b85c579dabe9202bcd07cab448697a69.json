{"sha": "1f234b83b85c579dabe9202bcd07cab448697a69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYyMzRiODNiODVjNTc5ZGFiZTkyMDJiY2QwN2NhYjQ0ODY5N2E2OQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-10-19T17:26:26Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-10-19T17:26:26Z"}, "message": "regrename.h: New file.\n\n\t* regrename.h: New file.\n\t* regrename.c: Include it.  Also include \"emit-rtl.h\".\n\t(struct du_head, struct du_chain, du_head_p DEF_VEC and\n\tDEF_VEC_ALLOC_P): Move to regrename.h.\n\t(do_replace): Remove declaration.\n\t(insn_rr): New variable.\n\t(cur_operand): New static variable.\n\t(regrename_chain_from_id): Renamed from chain_from_id and no longer\n\tstatic.  All callers changed.\n\t(record_operand_use): New static function.\n\t(scan_rtx_reg): Use it.\n\t(find_best_rename_reg): New function, broken out of rename_chains.\n\t(rename_chains): Use it.  Don't update chain regno and nregs here, ...\n\t(regrename_do_replace): ... do it here instead.  Renamed from\n\tdo_replace, and no longer static.  All callers changed.\n\t(regrename_analyze): No longer static.  New arg bb_mask.\n\tAll callers changed.  If bb_mask is nonzero, use it to limit the\n\tnumber of basic blocks we analyze.  If we failed to analyze a block,\n\tclear insn operand data.\n\t(record_out_operands): New arg insn_info.  Update cur_operand if it is\n\tnonnull.\n\t(build_def_use): If insn_rr is nonnull, pass an insn_info to\n\trecord_out_operands, and update cur_operand here as well.\n\t(regrename_init, regrename_finish): New functions.\n\t(regrename_optimize): Use them.\n\t* Makefile.in (regrename.o): Adjust dependencies.\n\nFrom-SVN: r180198", "tree": {"sha": "4e8270a1658fafb2457bb5416e2aad0869b86a79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e8270a1658fafb2457bb5416e2aad0869b86a79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f234b83b85c579dabe9202bcd07cab448697a69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f234b83b85c579dabe9202bcd07cab448697a69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f234b83b85c579dabe9202bcd07cab448697a69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f234b83b85c579dabe9202bcd07cab448697a69/comments", "author": null, "committer": null, "parents": [{"sha": "40f73edd0c35d53f57a1c05b1b4a59c4d7a70d60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40f73edd0c35d53f57a1c05b1b4a59c4d7a70d60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40f73edd0c35d53f57a1c05b1b4a59c4d7a70d60"}], "stats": {"total": 427, "additions": 300, "deletions": 127}, "files": [{"sha": "1b69b069f7a8a8631bd4520c54f5facf4c1687fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f234b83b85c579dabe9202bcd07cab448697a69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f234b83b85c579dabe9202bcd07cab448697a69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f234b83b85c579dabe9202bcd07cab448697a69", "patch": "@@ -1,3 +1,32 @@\n+2011-10-19  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* regrename.h: New file.\n+\t* regrename.c: Include it.  Also include \"emit-rtl.h\".\n+\t(struct du_head, struct du_chain, du_head_p DEF_VEC and\n+\tDEF_VEC_ALLOC_P): Move to regrename.h.\n+\t(do_replace): Remove declaration.\n+\t(insn_rr): New variable.\n+\t(cur_operand): New static variable.\n+\t(regrename_chain_from_id): Renamed from chain_from_id and no longer\n+\tstatic.  All callers changed.\n+\t(record_operand_use): New static function.\n+\t(scan_rtx_reg): Use it.\n+\t(find_best_rename_reg): New function, broken out of rename_chains.\n+\t(rename_chains): Use it.  Don't update chain regno and nregs here, ...\n+\t(regrename_do_replace): ... do it here instead.  Renamed from\n+\tdo_replace, and no longer static.  All callers changed.\n+\t(regrename_analyze): No longer static.  New arg bb_mask.\n+\tAll callers changed.  If bb_mask is nonzero, use it to limit the\n+\tnumber of basic blocks we analyze.  If we failed to analyze a block,\n+\tclear insn operand data.\n+\t(record_out_operands): New arg insn_info.  Update cur_operand if it is\n+\tnonnull.\n+\t(build_def_use): If insn_rr is nonnull, pass an insn_info to\n+\trecord_out_operands, and update cur_operand here as well.\n+\t(regrename_init, regrename_finish): New functions.\n+\t(regrename_optimize): Use them.\n+\t* Makefile.in (regrename.o): Adjust dependencies.\n+\n 2011-10-19  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/50769"}, {"sha": "6b28ef5261890a2ec48240b34bf5fe98d8d91124", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f234b83b85c579dabe9202bcd07cab448697a69/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f234b83b85c579dabe9202bcd07cab448697a69/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1f234b83b85c579dabe9202bcd07cab448697a69", "patch": "@@ -3506,7 +3506,8 @@ regcprop.o : regcprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n regrename.o : regrename.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_ERROR_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n    output.h $(RECOG_H) $(FUNCTION_H) $(OBSTACK_H) $(FLAGS_H) $(TM_P_H) \\\n-   addresses.h reload.h $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H) $(TARGET_H)\n+   addresses.h reload.h $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H) $(TARGET_H) \\\n+   regrename.h $(EMIT_RTL_H)\n ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) $(DIAGNOSTIC_CORE_H) $(FLAGS_H) insn-config.h $(FUNCTION_H) $(RECOG_H) \\\n    $(TARGET_H) $(BASIC_BLOCK_H) $(EXPR_H) output.h $(EXCEPT_H) $(TM_P_H) \\"}, {"sha": "1823558f4517f2e4a62b84b808fcaa703bd3d24e", "filename": "gcc/regrename.c", "status": "modified", "additions": 168, "deletions": 126, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f234b83b85c579dabe9202bcd07cab448697a69/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f234b83b85c579dabe9202bcd07cab448697a69/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=1f234b83b85c579dabe9202bcd07cab448697a69", "patch": "@@ -39,6 +39,8 @@\n #include \"tree-pass.h\"\n #include \"df.h\"\n #include \"target.h\"\n+#include \"emit-rtl.h\"\n+#include \"regrename.h\"\n \n /* This file implements the RTL register renaming pass of the compiler.  It is\n    a semi-local pass whose goal is to maximize the usage of the register file\n@@ -73,47 +75,6 @@\n #error \"Use a different bitmap implementation for untracked_operands.\"\n #endif\n \n-/* We keep linked lists of DU_HEAD structures, each of which describes\n-   a chain of occurrences of a reg.  */\n-struct du_head\n-{\n-  /* The next chain.  */\n-  struct du_head *next_chain;\n-  /* The first and last elements of this chain.  */\n-  struct du_chain *first, *last;\n-  /* Describe the register being tracked, register number and count.  */\n-  unsigned regno;\n-  int nregs;\n-\n-  /* A unique id to be used as an index into the conflicts bitmaps.  */\n-  unsigned id;\n-  /* A bitmap to record conflicts with other chains.  */\n-  bitmap_head conflicts;\n-  /* Conflicts with untracked hard registers.  */\n-  HARD_REG_SET hard_conflicts;\n-\n-  /* Nonzero if the chain crosses a call.  */\n-  unsigned int need_caller_save_reg:1;\n-  /* Nonzero if the register is used in a way that prevents renaming,\n-     such as the SET_DEST of a CALL_INSN or an asm operand that used\n-     to be a hard register.  */\n-  unsigned int cannot_rename:1;\n-};\n-\n-/* This struct describes a single occurrence of a register.  */\n-struct du_chain\n-{\n-  /* Links to the next occurrence of the register.  */\n-  struct du_chain *next_use;\n-\n-  /* The insn where the register appears.  */\n-  rtx insn;\n-  /* The location inside the insn.  */\n-  rtx *loc;\n-  /* The register class required by the insn at this location.  */\n-  ENUM_BITFIELD(reg_class) cl : 16;\n-};\n-\n enum scan_actions\n {\n   terminate_write,\n@@ -144,15 +105,14 @@ static int this_tick = 0;\n \n static struct obstack rename_obstack;\n \n-static void do_replace (struct du_head *, int);\n+/* If nonnull, the code calling into the register renamer requested\n+   information about insn operands, and we store it here.  */\n+VEC(insn_rr_info, heap) *insn_rr;\n+\n static void scan_rtx (rtx, rtx *, enum reg_class, enum scan_actions,\n \t\t      enum op_type);\n static bool build_def_use (basic_block);\n \n-typedef struct du_head *du_head_p;\n-DEF_VEC_P (du_head_p);\n-DEF_VEC_ALLOC_P (du_head_p, heap);\n-\n /* The id to be given to the next opened chain.  */\n static unsigned current_id;\n \n@@ -173,10 +133,15 @@ static HARD_REG_SET live_in_chains;\n    between this and live_in_chains is empty.  */\n static HARD_REG_SET live_hard_regs;\n \n+/* Set while scanning RTL if INSN_RR is nonnull, i.e. if the current analysis\n+   is for a caller that requires operand data.  Used in\n+   record_operand_use.  */\n+static operand_rr_info *cur_operand;\n+\n /* Return the chain corresponding to id number ID.  Take into account that\n    chains may have been merged.  */\n-static du_head_p\n-chain_from_id (unsigned int id)\n+du_head_p\n+regrename_chain_from_id (unsigned int id)\n {\n   du_head_p first_chain = VEC_index (du_head_p, id_to_chain, id);\n   du_head_p chain = first_chain;\n@@ -237,6 +202,19 @@ mark_conflict (struct du_head *chains, unsigned id)\n     }\n }\n \n+/* Examine cur_operand, and if it is nonnull, record information about the\n+   use THIS_DU which is part of the chain HEAD.  */\n+\n+static void\n+record_operand_use (struct du_head *head, struct du_chain *this_du)\n+{\n+  if (cur_operand == NULL)\n+    return;\n+  gcc_assert (cur_operand->n_chains < MAX_REGS_PER_ADDRESS);\n+  cur_operand->heads[cur_operand->n_chains] = head;\n+  cur_operand->chains[cur_operand->n_chains++] = this_du;\n+}\n+\n /* Create a new chain for THIS_NREGS registers starting at THIS_REGNO,\n    and record its occurrence in *LOC, which is being written to in INSN.\n    This access requires a register of class CL.  */\n@@ -299,6 +277,7 @@ create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n   this_du->loc = loc;\n   this_du->insn = insn;\n   this_du->cl = cl;\n+  record_operand_use (head, this_du);\n   return head;\n }\n \n@@ -313,7 +292,7 @@ merge_overlapping_regs (HARD_REG_SET *pset, struct du_head *head)\n   IOR_HARD_REG_SET (*pset, head->hard_conflicts);\n   EXECUTE_IF_SET_IN_BITMAP (&head->conflicts, 0, i, bi)\n     {\n-      du_head_p other = chain_from_id (i);\n+      du_head_p other = regrename_chain_from_id (i);\n       unsigned j = other->nregs;\n       gcc_assert (other != head);\n       while (j-- > 0)\n@@ -368,6 +347,69 @@ check_new_reg_p (int reg ATTRIBUTE_UNUSED, int new_reg,\n   return true;\n }\n \n+/* For the chain THIS_HEAD, compute and return the best register to\n+   rename to.  SUPER_CLASS is the superunion of register classes in\n+   the chain.  UNAVAILABLE is a set of registers that cannot be used.\n+   OLD_REG is the register currently used for the chain.  */\n+\n+int\n+find_best_rename_reg (du_head_p this_head, enum reg_class super_class,\n+\t\t      HARD_REG_SET *unavailable, int old_reg)\n+{\n+  bool has_preferred_class;\n+  enum reg_class preferred_class;\n+  int pass;\n+  int best_new_reg = old_reg;\n+\n+  /* Further narrow the set of registers we can use for renaming.\n+     If the chain needs a call-saved register, mark the call-used\n+     registers as unavailable.  */\n+  if (this_head->need_caller_save_reg)\n+    IOR_HARD_REG_SET (*unavailable, call_used_reg_set);\n+\n+  /* Mark registers that overlap this chain's lifetime as unavailable.  */\n+  merge_overlapping_regs (unavailable, this_head);\n+\n+  /* Compute preferred rename class of super union of all the classes\n+     in the chain.  */\n+  preferred_class\n+    = (enum reg_class) targetm.preferred_rename_class (super_class);\n+\n+  /* If PREFERRED_CLASS is not NO_REGS, we iterate in the first pass\n+     over registers that belong to PREFERRED_CLASS and try to find the\n+     best register within the class.  If that failed, we iterate in\n+     the second pass over registers that don't belong to the class.\n+     If PREFERRED_CLASS is NO_REGS, we iterate over all registers in\n+     ascending order without any preference.  */\n+  has_preferred_class = (preferred_class != NO_REGS);\n+  for (pass = (has_preferred_class ? 0 : 1); pass < 2; pass++)\n+    {\n+      int new_reg;\n+      for (new_reg = 0; new_reg < FIRST_PSEUDO_REGISTER; new_reg++)\n+\t{\n+\t  if (has_preferred_class\n+\t      && (pass == 0)\n+\t      != TEST_HARD_REG_BIT (reg_class_contents[preferred_class],\n+\t\t\t\t    new_reg))\n+\t    continue;\n+\n+\t  /* In the first pass, we force the renaming of registers that\n+\t     don't belong to PREFERRED_CLASS to registers that do, even\n+\t     though the latters were used not very long ago.  */\n+\t  if (check_new_reg_p (old_reg, new_reg, this_head,\n+\t\t\t       *unavailable)\n+\t      && ((pass == 0\n+\t\t   && !TEST_HARD_REG_BIT (reg_class_contents[preferred_class],\n+\t\t\t\t\t  best_new_reg))\n+\t\t  || tick[best_new_reg] > tick[new_reg]))\n+\t    best_new_reg = new_reg;\n+\t}\n+      if (pass == 0 && best_new_reg != old_reg)\n+\tbreak;\n+    }\n+  return best_new_reg;\n+}\n+\n /* Perform register renaming on the current function.  */\n static void\n rename_chains (void)\n@@ -390,22 +432,16 @@ rename_chains (void)\n \n   FOR_EACH_VEC_ELT (du_head_p, id_to_chain, i, this_head)\n     {\n-      int new_reg, best_new_reg, best_nregs;\n+      int best_new_reg;\n       int n_uses;\n       struct du_chain *tmp;\n       HARD_REG_SET this_unavailable;\n       int reg = this_head->regno;\n-      int pass;\n       enum reg_class super_class = NO_REGS;\n-      enum reg_class preferred_class;\n-      bool has_preferred_class;\n \n       if (this_head->cannot_rename)\n \tcontinue;\n \n-      best_new_reg = reg;\n-      best_nregs = this_head->nregs;\n-\n       if (fixed_regs[reg] || global_regs[reg]\n #if !HARD_FRAME_POINTER_IS_FRAME_POINTER\n \t  || (frame_pointer_needed && reg == HARD_FRAME_POINTER_REGNUM)\n@@ -437,56 +473,8 @@ rename_chains (void)\n       if (n_uses < 2)\n \tcontinue;\n \n-      /* Further narrow the set of registers we can use for renaming.\n-\t If the chain needs a call-saved register, mark the call-used\n-\t registers as unavailable.  */\n-      if (this_head->need_caller_save_reg)\n-\tIOR_HARD_REG_SET (this_unavailable, call_used_reg_set);\n-\n-      /* And mark registers that overlap its lifetime as unavailable.  */\n-      merge_overlapping_regs (&this_unavailable, this_head);\n-\n-      /* Compute preferred rename class of super union of all the classes\n-\t in the chain.  */\n-      preferred_class\n-\t= (enum reg_class) targetm.preferred_rename_class (super_class);\n-\n-      /* If PREFERRED_CLASS is not NO_REGS, we iterate in the first pass\n-\t over registers that belong to PREFERRED_CLASS and try to find the\n-\t best register within the class.  If that failed, we iterate in\n-\t the second pass over registers that don't belong to the class.\n-\t If PREFERRED_CLASS is NO_REGS, we iterate over all registers in\n-\t ascending order without any preference.  */\n-      has_preferred_class = (preferred_class != NO_REGS);\n-      for (pass = (has_preferred_class ? 0 : 1); pass < 2; pass++)\n-\t{\n-\t  for (new_reg = 0; new_reg < FIRST_PSEUDO_REGISTER; new_reg++)\n-\t    {\n-\t      if (has_preferred_class\n-\t\t  && ((pass == 0) != TEST_HARD_REG_BIT\n-\t\t      (reg_class_contents[preferred_class], new_reg)))\n-\t\tcontinue;\n-\n-\t      /* In the first pass, we force the renaming of registers that\n-\t\t don't belong to PREFERRED_CLASS to registers that do, even\n-\t\t though the latters were used not very long ago.  */\n-\t      if (check_new_reg_p (reg, new_reg, this_head,\n-\t\t\t\t   this_unavailable)\n-\t\t  && ((pass == 0\n-\t\t       && (!TEST_HARD_REG_BIT\n-\t\t\t   (reg_class_contents[preferred_class],\n-\t\t\t    best_new_reg)))\n-\t\t      || tick[best_new_reg] > tick[new_reg]))\n-\t\t{\n-\t\t  enum machine_mode mode\n-\t\t    = GET_MODE (*this_head->first->loc);\n-\t\t  best_new_reg = new_reg;\n-\t\t  best_nregs = hard_regno_nregs[new_reg][mode];\n-\t\t}\n-\t    }\n-\t  if (pass == 0 && best_new_reg != reg)\n-\t    break;\n-\t}\n+      best_new_reg = find_best_rename_reg (this_head, super_class,\n+\t\t\t\t\t   &this_unavailable, reg);\n \n       if (dump_file)\n \t{\n@@ -507,9 +495,7 @@ rename_chains (void)\n       if (dump_file)\n \tfprintf (dump_file, \", renamed as %s\\n\", reg_names[best_new_reg]);\n \n-      do_replace (this_head, best_new_reg);\n-      this_head->regno = best_new_reg;\n-      this_head->nregs = best_nregs;\n+      regrename_do_replace (this_head, best_new_reg);\n       tick[best_new_reg] = ++this_tick;\n       df_set_regs_ever_live (best_new_reg, true);\n     }\n@@ -675,8 +661,8 @@ merge_chains (du_head_p c1, du_head_p c2)\n \n /* Analyze the current function and build chains for renaming.  */\n \n-static void\n-regrename_analyze (void)\n+void\n+regrename_analyze (bitmap bb_mask)\n {\n   struct bb_rename_info *rename_info;\n   int i;\n@@ -694,7 +680,10 @@ regrename_analyze (void)\n     {\n       struct bb_rename_info *ri = rename_info + i;\n       ri->bb = bb;\n-      bb->aux = ri;\n+      if (bb_mask != NULL && !bitmap_bit_p (bb_mask, bb->index))\n+\tbb->aux = NULL;\n+      else\n+\tbb->aux = ri;\n       i++;\n     }\n \n@@ -735,6 +724,16 @@ regrename_analyze (void)\n \t  current_id = old_length;\n \t  bitmap_clear (&this_info->incoming_open_chains_set);\n \t  open_chains = NULL;\n+\t  if (insn_rr != NULL)\n+\t    {\n+\t      rtx insn;\n+\t      FOR_BB_INSNS (bb1, insn)\n+\t\t{\n+\t\t  insn_rr_info *p = VEC_index (insn_rr_info, insn_rr,\n+\t\t\t\t\t       INSN_UID (insn));\n+\t\t  p->op_info = NULL;\n+\t\t}\n+\t    }\n \t  continue;\n \t}\n \n@@ -798,7 +797,7 @@ regrename_analyze (void)\n \t{\n \t  edge e;\n \t  edge_iterator ei;\n-\t  struct du_head *chain = chain_from_id (j);\n+\t  struct du_head *chain = regrename_chain_from_id (j);\n \t  int n_preds_used = 0, n_preds_joined = 0;\n \n \t  FOR_EACH_EDGE (e, ei, bb->preds)\n@@ -825,7 +824,7 @@ regrename_analyze (void)\n \t      EXECUTE_IF_SET_IN_BITMAP (&src_ri->open_chains_set,\n \t\t\t\t\t0, k, bi2)\n \t\t{\n-\t\t  struct du_head *outgoing_chain = chain_from_id (k);\n+\t\t  struct du_head *outgoing_chain = regrename_chain_from_id (k);\n \n \t\t  if (outgoing_chain->regno == chain->regno\n \t\t      && outgoing_chain->nregs == chain->nregs)\n@@ -863,7 +862,7 @@ regrename_analyze (void)\n \t{\n \t  edge e;\n \t  edge_iterator ei;\n-\t  struct du_head *chain = chain_from_id (j);\n+\t  struct du_head *chain = regrename_chain_from_id (j);\n \t  int n_succs_used = 0, n_succs_joined = 0;\n \n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -888,7 +887,7 @@ regrename_analyze (void)\n \t      EXECUTE_IF_SET_IN_BITMAP (&dest_ri->incoming_open_chains_set,\n \t\t\t\t\t0, k, bi2)\n \t\t{\n-\t\t  struct du_head *incoming_chain = chain_from_id (k);\n+\t\t  struct du_head *incoming_chain = regrename_chain_from_id (k);\n \n \t\t  if (incoming_chain->regno == chain->regno\n \t\t      && incoming_chain->nregs == chain->nregs)\n@@ -928,11 +927,12 @@ regrename_analyze (void)\n     bb->aux = NULL;\n }\n \n-static void\n-do_replace (struct du_head *head, int reg)\n+void\n+regrename_do_replace (struct du_head *head, int reg)\n {\n   struct du_chain *chain;\n   unsigned int base_regno = head->regno;\n+  enum machine_mode mode;\n \n   for (chain = head->first; chain; chain = chain->next_use)\n     {\n@@ -953,6 +953,10 @@ do_replace (struct du_head *head, int reg)\n \n       df_insn_rescan (chain->insn);\n     }\n+\n+  mode = GET_MODE (*head->first->loc);\n+  head->regno = reg;\n+  head->nregs = hard_regno_nregs[reg][mode];\n }\n \n \n@@ -1106,6 +1110,7 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \t\thead->first = this_du;\n \t      else\n \t\thead->last->next_use = this_du;\n+\t      record_operand_use (head, this_du);\n \t      head->last = this_du;\n \t    }\n \t  /* Avoid adding the same location in a DEBUG_INSN multiple times,\n@@ -1468,10 +1473,11 @@ restore_operands (rtx insn, int n_ops, rtx *old_operands, rtx *old_dups)\n \n /* For each output operand of INSN, call scan_rtx to create a new\n    open chain.  Do this only for normal or earlyclobber outputs,\n-   depending on EARLYCLOBBER.  */\n+   depending on EARLYCLOBBER.  If INSN_INFO is nonnull, use it to\n+   record information about the operands in the insn.  */\n \n static void\n-record_out_operands (rtx insn, bool earlyclobber)\n+record_out_operands (rtx insn, bool earlyclobber, insn_rr_info *insn_info)\n {\n   int n_ops = recog_data.n_operands;\n   int alt = which_alternative;\n@@ -1493,6 +1499,9 @@ record_out_operands (rtx insn, bool earlyclobber)\n \t  || recog_op_alt[opn][alt].earlyclobber != earlyclobber)\n \tcontinue;\n \n+      if (insn_info)\n+\tcur_operand = insn_info->op_info + i;\n+\n       prev_open = open_chains;\n       scan_rtx (insn, loc, cl, mark_write, OP_OUT);\n \n@@ -1510,6 +1519,7 @@ record_out_operands (rtx insn, bool earlyclobber)\n \t    open_chains->cannot_rename = 1;\n \t}\n     }\n+  cur_operand = NULL;\n }\n \n /* Build def/use chain.  */\n@@ -1535,6 +1545,7 @@ build_def_use (basic_block bb)\n \t  int predicated;\n \t  enum rtx_code set_code = SET;\n \t  enum rtx_code clobber_code = CLOBBER;\n+\t  insn_rr_info *insn_info = NULL;\n \n \t  /* Process the insn, determining its effect on the def-use\n \t     chains and live hard registers.  We perform the following\n@@ -1567,6 +1578,15 @@ build_def_use (basic_block bb)\n \t  n_ops = recog_data.n_operands;\n \t  untracked_operands = 0;\n \n+\t  if (insn_rr != NULL)\n+\t    {\n+\t      insn_info = VEC_index (insn_rr_info, insn_rr, INSN_UID (insn));\n+\t      insn_info->op_info = XOBNEWVEC (&rename_obstack, operand_rr_info,\n+\t\t\t\t\t      recog_data.n_operands);\n+\t      memset (insn_info->op_info, 0,\n+\t\t      sizeof (operand_rr_info) * recog_data.n_operands);\n+\t    }\n+\n \t  /* Simplify the code below by rewriting things to reflect\n \t     matching constraints.  Also promote OP_OUT to OP_INOUT in\n \t     predicated instructions, but only for register operands\n@@ -1625,7 +1645,7 @@ build_def_use (basic_block bb)\n \n \t  /* Step 1b: Begin new chains for earlyclobbered writes inside\n \t     operands.  */\n-\t  record_out_operands (insn, true);\n+\t  record_out_operands (insn, true, insn_info);\n \n \t  /* Step 2: Mark chains for which we have reads outside operands\n \t     as unrenamable.\n@@ -1674,11 +1694,14 @@ build_def_use (basic_block bb)\n \t\t  || untracked_operands & (1 << opn))\n \t\tcontinue;\n \n+\t      if (insn_info)\n+\t\tcur_operand = i == opn ? insn_info->op_info + i : NULL;\n \t      if (recog_op_alt[opn][alt].is_address)\n \t\tscan_rtx_address (insn, loc, cl, mark_read, VOIDmode);\n \t      else\n \t\tscan_rtx (insn, loc, cl, mark_read, type);\n \t    }\n+\t  cur_operand = NULL;\n \n \t  /* Step 3B: Record updates for regs in REG_INC notes, and\n \t     source regs in REG_FRAME_RELATED_EXPR notes.  */\n@@ -1729,7 +1752,7 @@ build_def_use (basic_block bb)\n \t  restore_operands (insn, n_ops, old_operands, old_dups);\n \n \t  /* Step 6b: Begin new chains for writes inside operands.  */\n-\t  record_out_operands (insn, false);\n+\t  record_out_operands (insn, false, insn_info);\n \n \t  /* Step 6c: Record destination regs in REG_FRAME_RELATED_EXPR\n \t     notes for update.  */\n@@ -1766,6 +1789,26 @@ build_def_use (basic_block bb)\n   return true;\n }\n \f\n+/* Initialize the register renamer.  If INSN_INFO is true, ensure that\n+   insn_rr is nonnull.  */\n+void\n+regrename_init (bool insn_info)\n+{\n+  gcc_obstack_init (&rename_obstack);\n+  insn_rr = NULL;\n+  if (insn_info)\n+    VEC_safe_grow_cleared (insn_rr_info, heap, insn_rr, get_max_uid ());\n+}\n+\n+/* Free all global data used by the register renamer.  */\n+void\n+regrename_finish (void)\n+{\n+  VEC_free (insn_rr_info, heap, insn_rr);\n+  free_chain_data ();\n+  obstack_free (&rename_obstack, NULL);\n+}\n+\n /* Perform register renaming on the current function.  */\n \n static unsigned int\n@@ -1776,14 +1819,13 @@ regrename_optimize (void)\n   df_analyze ();\n   df_set_flags (DF_DEFER_INSN_RESCAN);\n \n-  gcc_obstack_init (&rename_obstack);\n+  regrename_init (false);\n \n-  regrename_analyze ();\n+  regrename_analyze (NULL);\n \n   rename_chains ();\n \n-  free_chain_data ();\n-  obstack_free (&rename_obstack, NULL);\n+  regrename_finish ();\n \n   return 0;\n }"}, {"sha": "f3969a14fc27332146a9178c8b0e4b16deb280e9", "filename": "gcc/regrename.h", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f234b83b85c579dabe9202bcd07cab448697a69/gcc%2Fregrename.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f234b83b85c579dabe9202bcd07cab448697a69/gcc%2Fregrename.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.h?ref=1f234b83b85c579dabe9202bcd07cab448697a69", "patch": "@@ -0,0 +1,101 @@\n+/* This file contains definitions for the register renamer.\n+   Copyright (C) 2011\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_REGRENAME_H\n+#define GCC_REGRENAME_H\n+\n+/* We keep linked lists of DU_HEAD structures, each of which describes\n+   a chain of occurrences of a reg.  */\n+struct du_head\n+{\n+  /* The next chain.  */\n+  struct du_head *next_chain;\n+  /* The first and last elements of this chain.  */\n+  struct du_chain *first, *last;\n+  /* Describes the register being tracked.  */\n+  unsigned regno;\n+  int nregs;\n+\n+  /* A unique id to be used as an index into the conflicts bitmaps.  */\n+  unsigned id;\n+  /* A bitmap to record conflicts with other chains.  */\n+  bitmap_head conflicts;\n+  /* Conflicts with untracked hard registers.  */\n+  HARD_REG_SET hard_conflicts;\n+\n+  /* Nonzero if the chain crosses a call.  */\n+  unsigned int need_caller_save_reg:1;\n+  /* Nonzero if the register is used in a way that prevents renaming,\n+     such as the SET_DEST of a CALL_INSN or an asm operand that used\n+     to be a hard register.  */\n+  unsigned int cannot_rename:1;\n+};\n+\n+typedef struct du_head *du_head_p;\n+DEF_VEC_P (du_head_p);\n+DEF_VEC_ALLOC_P (du_head_p, heap);\n+\n+/* This struct describes a single occurrence of a register.  */\n+struct du_chain\n+{\n+  /* Links to the next occurrence of the register.  */\n+  struct du_chain *next_use;\n+\n+  /* The insn where the register appears.  */\n+  rtx insn;\n+  /* The location inside the insn.  */\n+  rtx *loc;\n+  /* The register class required by the insn at this location.  */\n+  ENUM_BITFIELD(reg_class) cl : 16;\n+};\n+\n+/* This struct describes data gathered during regrename_analyze about\n+   a single operand of an insn.  */\n+typedef struct\n+{\n+  /* The number of chains recorded for this operand.  */\n+  int n_chains;\n+  /* Holds either the chain for the operand itself, or for the registers in\n+     a memory operand.  */\n+  struct du_chain *chains[MAX_REGS_PER_ADDRESS];\n+  struct du_head *heads[MAX_REGS_PER_ADDRESS];\n+} operand_rr_info;\n+\n+/* A struct to hold a vector of operand_rr_info structures describing the\n+   operands of an insn.  */\n+typedef struct\n+{\n+  operand_rr_info *op_info;\n+} insn_rr_info;\n+\n+DEF_VEC_O (insn_rr_info);\n+DEF_VEC_ALLOC_O (insn_rr_info, heap);\n+\n+extern VEC(insn_rr_info, heap) *insn_rr;\n+\n+extern void regrename_init (bool);\n+extern void regrename_finish (void);\n+extern void regrename_analyze (bitmap);\n+extern du_head_p regrename_chain_from_id (unsigned int);\n+extern int find_best_rename_reg (du_head_p, enum reg_class, HARD_REG_SET *,\n+\t\t\t\t int);\n+extern void regrename_do_replace (du_head_p, int);\n+\n+#endif"}]}