{"sha": "e63ffc3836f06f9176692dbc6463f5ff61a9c277", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYzZmZjMzgzNmYwNmY5MTc2NjkyZGJjNjQ2M2Y1ZmY2MWE5YzI3Nw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-03-06T20:18:32Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-03-06T20:18:32Z"}, "message": "lib2funcs.asm (__outline_prologue): Remove frame pointer support.\n\n        * lib2funcs.asm (__outline_prologue): Remove frame pointer\n        support.\n        (__outline_prologue_fp): Out of line prologue with frame pointer.\n        (__outline_epilogue, outline_epilogue_fp): Similarly.\n        * pa.c (compute_frame_size): Allocate enough space to avoid holes\n        in the callee register saves.  Remove some special handling of %r3.\n        (hppa_expand_prologue): Don't do an out of line prologue/epilogue\n        if it would take more insns than an inline prologue/epilogue.\n        Don't leave holes in the callee register save set.\n        (hppa_expand_prologue): Corresponding changes.  Pass stack size\n        to out of line epilogue code.\n        * pa.h (FRAME_POINTER_REQUIRED): Revert last change.\n        * pa.md (outline_prologue_call): Handle outline prologues which\n        don't need frame pointers.\n        (outline_epilogue_call): Similarly.\n        * t-pro: Reenable multilib code.  Build a set of libraries that\n        optimize for space.\n\nFrom-SVN: r11483", "tree": {"sha": "67ca18226988d68bbaca827f022492f8510bbb7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67ca18226988d68bbaca827f022492f8510bbb7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e63ffc3836f06f9176692dbc6463f5ff61a9c277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e63ffc3836f06f9176692dbc6463f5ff61a9c277", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e63ffc3836f06f9176692dbc6463f5ff61a9c277", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e63ffc3836f06f9176692dbc6463f5ff61a9c277/comments", "author": null, "committer": null, "parents": [{"sha": "e4080ae4bb50e244456307cefd7fb1d9b5824d58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4080ae4bb50e244456307cefd7fb1d9b5824d58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4080ae4bb50e244456307cefd7fb1d9b5824d58"}], "stats": {"total": 561, "additions": 444, "deletions": 117}, "files": [{"sha": "7ea7fbf23dfa2ec779033f5af9a311cd04d09a9f", "filename": "gcc/config/pa/lib2funcs.asm", "status": "modified", "additions": 231, "deletions": 13, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63ffc3836f06f9176692dbc6463f5ff61a9c277/gcc%2Fconfig%2Fpa%2Flib2funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63ffc3836f06f9176692dbc6463f5ff61a9c277/gcc%2Fconfig%2Fpa%2Flib2funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Flib2funcs.asm?ref=e63ffc3836f06f9176692dbc6463f5ff61a9c277", "patch": "@@ -1,5 +1,6 @@\n ;  Subroutines for calling unbound dynamic functions from within GDB for HPPA.\n-;  Copyright (C) 1994, 1995 Free Software Foundation, Inc.\n+;  Subroutines for out of line prologues and epilogues on for the HPPA\n+;  Copyright (C) 1994, 1995, 1996 Free Software Foundation, Inc.\n \n ;  This file is part of GNU CC.\n \n@@ -75,15 +76,15 @@ L$foo\n ;\n ;\t* Creates a new stack frame (sp'), size of the frame is passed in %r21\n ;\n-;\t* The old stack pointer is saved at sp\n+;\t* The old stack pointer is saved at sp (frame pointer version only).\n ;\n ;\t* Saves grs (passed in low 16 bits of %r22 into the stack frame\n ;\tat sp' + local_fsize (passed in %r19).\n ;\n ;\t* Saves frs (passed in high 16 bits of %r22) into the stack\n ;\tframe at sp' + local_fsize (passed in %r19).\n ;\n-;\t* Sets up a frame pointer (in %r3).\n+;\t* Sets up a frame pointer (in %r3) (frame pointer version only).\n ;\n ;\t* Returns to the instruction _immediately_ after the call to\n ;\tthis function.\n@@ -107,9 +108,6 @@ __outline_prologue\n \t; Make our new frame.\n \tadd %r21,%r30,%r30\n \n-\t; Save our old stack pointer.\n-\tstw %r20,0(0,%r20)\n-\n \t; Add in local_fsize to our frame pointer so we do register\n \t; saves into the right place\n \tadd %r20,%r19,%r20\n@@ -192,20 +190,239 @@ L$0000\n \tfstws,ma %fr12,8(0,%r20)\n \tnop\n L$0001\n+\t; Return\n+\tbv,n 0(%r31)\n+\t.EXIT\n+\t.PROCEND\n+\n+\n+\n+\t.align 32\n+\t.NSUBSPA $MILLICODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY\n+\t.EXPORT __outline_prologue_fp,MILLICODE\n+__outline_prologue_fp\n+\t.PROC\n+\t.CALLINFO FRAME=0,NO_CALLS\n+\t.ENTRY\n+\tcopy %r30,%r20\n+\n+\t; Subtract 4 from our return pointer so that we return to\n+\t; the right location.\n+        ldo -4(%r31),%r31\n+\n+\t; Save off %r2\n+\tstw %r2,-20(0,%r30)\n+\n+\t; Make our new frame.\n+\tadd %r21,%r30,%r30\n+\n+\t; Save our old stack pointer.\n+\tstw %r20,0(0,%r20)\n+\n+\t; Add in local_fsize to our frame pointer so we do register\n+\t; saves into the right place\n+\tadd %r20,%r19,%r20\n+\n+\t; %r22 tells us what registers we need to save.  The upper half\n+\t; is for fp registers, the lower half for integer registers.\n+\t; We put the lower half in %r1 and the upper half into %r22\n+\t; for later use.\n+\textru %r22,31,16,%r1\n+\textrs %r22,15,16,%r22\n+\n+\t; %r1 now olds a value 0-18 which corresponds to the number\n+\t; of grs we need to save.  We need to reverse that value so\n+\t; we can just into the table and straight-line execute to the\n+\t; end of the gr saves.\n+\tcomb,= %r0,%r1,L$0002\n+\tsubi 18,%r1,%r1\n+\tblr,n %r1,%r0\n+\tb,n L$0002\n+\tstws,ma %r18,4(0,%r20)\n+\tnop\n+\tstws,ma %r17,4(0,%r20)\n+\tnop\n+\tstws,ma %r16,4(0,%r20)\n+\tnop\n+\tstws,ma %r15,4(0,%r20)\n+\tnop\n+\tstws,ma %r14,4(0,%r20)\n+\tnop\n+\tstws,ma %r13,4(0,%r20)\n+\tnop\n+\tstws,ma %r12,4(0,%r20)\n+\tnop\n+\tstws,ma %r11,4(0,%r20)\n+\tnop\n+\tstws,ma %r10,4(0,%r20)\n+\tnop\n+\tstws,ma %r9,4(0,%r20)\n+\tnop\n+\tstws,ma %r8,4(0,%r20)\n+\tnop\n+\tstws,ma %r7,4(0,%r20)\n+\tnop\n+\tstws,ma %r6,4(0,%r20)\n+\tnop\n+\tstws,ma %r5,4(0,%r20)\n+\tnop\n+\tstws,ma %r4,4(0,%r20)\n+\tnop\n+\tstws,ma %r3,4(0,%r20)\n+\tnop\n+L$0002\n+\t; All gr saves are done.  Align the temporary frame pointer and\n+\t; do the fr saves.\n+\tldo 7(%r20),%r20\n+\tdepi 0,31,3,%r20\n+\n+\tcomb,= %r0,%r22,L$0003\n+\tsubi 21,%r22,%r22\n+\tblr,n %r22,%r0\n+\tb,n L$0003\n+\tfstws,ma %fr21,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr20,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr19,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr18,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr17,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr16,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr15,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr14,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr13,8(0,%r20)\n+\tnop\n+\tfstws,ma %fr12,8(0,%r20)\n+\tnop\n+L$0003\n \t; Return, setting up a frame pointer in the delay slot\n \tbv 0(%r31)\n \tsub %r30,%r21,%r3\n-\n \t.EXIT\n \t.PROCEND\n \n+\n ; This is an out-of-line epilogue.  It's operation is basically the reverse\n ; of the out-of-line prologue.\n \n \t.align 32\n \t.NSUBSPA $MILLICODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY\n \t.EXPORT __outline_epilogue,MILLICODE\n __outline_epilogue\n+\t.PROC\n+\t.CALLINFO FRAME=0,NO_CALLS\n+\t.ENTRY\n+\t; Get our original stack pointer and put it in %r20\n+\tsub %r30,%r21,%r20\n+\n+\t; Subtract 4 from our return pointer so that we return to\n+\t; the right location.\n+        ldo -4(%r31),%r31\n+\n+\t; Reload %r2\n+\tldw -20(0,%r20),%r2\n+\n+\t; Add in local_fsize (%r19) to the frame pointer to find\n+\t; the saved registers.\n+\tadd %r20,%r19,%r20\n+\n+\t; %r22 tells us what registers we need to restore.  The upper half\n+\t; is for fp registers, the lower half for integer registers.\n+\t; We put the lower half in %r1 and the upper half into %r22\n+\t; for later use.\n+\textru %r22,31,16,%r1\n+\textrs %r22,15,16,%r22\n+\n+\t; %r1 now olds a value 0-18 which corresponds to the number\n+\t; of grs we need to restore.  We need to reverse that value so\n+\t; we can just into the table and straight-line execute to the\n+\t; end of the gr restore.\n+\tcomb,= %r0,%r1,L$0004\n+\tsubi 18,%r1,%r1\n+\tblr,n %r1,%r0\n+\tb,n L$0004\n+\tldws,ma 4(0,%r20),%r18\n+\tnop\n+\tldws,ma 4(0,%r20),%r17\n+\tnop\n+\tldws,ma 4(0,%r20),%r16\n+\tnop\n+\tldws,ma 4(0,%r20),%r15\n+\tnop\n+\tldws,ma 4(0,%r20),%r14\n+\tnop\n+\tldws,ma 4(0,%r20),%r13\n+\tnop\n+\tldws,ma 4(0,%r20),%r12\n+\tnop\n+\tldws,ma 4(0,%r20),%r11\n+\tnop\n+\tldws,ma 4(0,%r20),%r10\n+\tnop\n+\tldws,ma 4(0,%r20),%r9\n+\tnop\n+\tldws,ma 4(0,%r20),%r8\n+\tnop\n+\tldws,ma 4(0,%r20),%r7\n+\tnop\n+\tldws,ma 4(0,%r20),%r6\n+\tnop\n+\tldws,ma 4(0,%r20),%r5\n+\tnop\n+\tldws,ma 4(0,%r20),%r4\n+\tnop\n+\tldws,ma 4(0,%r20),%r3\n+\tnop\n+L$0004\n+\t; All gr restore are done.  Align the temporary frame pointer and\n+\t; do the fr restore.\n+\tldo 7(%r20),%r20\n+\tdepi 0,31,3,%r20\n+\n+\tcomb,= %r0,%r22,L$0005\n+\tsubi 21,%r22,%r22\n+\tblr,n %r22,%r0\n+\tb,n L$0005\n+\tfldws,ma 8(0,%r20),%fr21\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr20\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr19\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr18\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr17\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr16\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr15\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr14\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr13\n+\tnop\n+\tfldws,ma 8(0,%r20),%fr12\n+\tnop\n+L$0005\n+\t; Return and deallocate our frame.\n+\tbv 0(%r31)\n+\tsub %r30,%r21,%r30\n+\t.EXIT\n+\t.PROCEND\n+\n+; This is an out-of-line epilogue.  It's operation is basically the reverse\n+; of the out-of-line prologue.\n+\n+\t.align 32\n+\t.NSUBSPA $MILLICODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY\n+\t.EXPORT __outline_epilogue_fp,MILLICODE\n+__outline_epilogue_fp\n \t.PROC\n \t.CALLINFO FRAME=0,NO_CALLS\n \t.ENTRY\n@@ -238,10 +455,10 @@ __outline_epilogue\n \t; of grs we need to restore.  We need to reverse that value so\n \t; we can just into the table and straight-line execute to the\n \t; end of the gr restore.\n-\tcomb,= %r0,%r1,L$0002\n+\tcomb,= %r0,%r1,L$0006\n \tsubi 18,%r1,%r1\n \tblr,n %r1,%r0\n-\tb,n L$0002\n+\tb,n L$0006\n \tldws,ma 4(0,%r20),%r18\n \tnop\n \tldws,ma 4(0,%r20),%r17\n@@ -274,16 +491,16 @@ __outline_epilogue\n \tnop\n \tldws,ma 4(0,%r20),%r3\n \tnop\n-L$0002\n+L$0006\n \t; All gr restore are done.  Align the temporary frame pointer and\n \t; do the fr restore.\n \tldo 7(%r20),%r20\n \tdepi 0,31,3,%r20\n \n-\tcomb,= %r0,%r22,L$0003\n+\tcomb,= %r0,%r22,L$0007\n \tsubi 21,%r22,%r22\n \tblr,n %r22,%r0\n-\tb,n L$0003\n+\tb,n L$0007\n \tfldws,ma 8(0,%r20),%fr21\n \tnop\n \tfldws,ma 8(0,%r20),%fr20\n@@ -304,10 +521,11 @@ L$0002\n \tnop\n \tfldws,ma 8(0,%r20),%fr12\n \tnop\n-L$0003\n+L$0007\n \t; Return and deallocate our frame.\n \tbv 0(%r31)\n \tcopy %r21,%r30\n \t.EXIT\n \t.PROCEND\n \n+"}, {"sha": "679716d0b0a9a50f0fe31b72a60357f44d1367b6", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 139, "deletions": 83, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63ffc3836f06f9176692dbc6463f5ff61a9c277/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63ffc3836f06f9176692dbc6463f5ff61a9c277/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=e63ffc3836f06f9176692dbc6463f5ff61a9c277", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for HPPA.\n-   Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n    Contributed by Tim Moore (moore@cs.utah.edu), based on sparc.c\n \n This file is part of GNU CC.\n@@ -55,6 +55,10 @@ int hp_profile_labelno;\n    registers which were saved by the current function's prologue.  */\n static int gr_saved, fr_saved;\n \n+/* Whether or not the current function uses an out-of-line prologue\n+   and epilogue.  */\n+static int out_of_line_prologue_epilogue;\n+\n static rtx find_addr_reg ();\n \n /* Keep track of the number of bytes we have output in the CODE subspaces\n@@ -2042,52 +2046,30 @@ compute_frame_size (size, fregs_live)\n      we need to add this in because of STARTING_FRAME_OFFSET. */\n   fsize = size + (size || frame_pointer_needed ? 8 : 0);\n \n-  for (i = 18; i >= 4; i--)\n-    {\n-      if (regs_ever_live[i])\n-\t{\n-\t  /* For out of line prologues/epilogues we only need to\n-\t     compute the highest register number to save and\n-\t     allocate space for all the callee saved registers\n-\t     with a lower number.  */\n-\t  if (TARGET_SPACE)\n-\t    {\n-\t      fsize += 4 * (i - 3);\n-\t      break;\n-\t    }\n-\t  fsize += 4;\n-\t}\n-    }\n-\n-  /* We always save %r3, make room for it.  */\n-  if (TARGET_SPACE)\n-    fsize += 8;\n+  /* We do not want to create holes in the callee registers that\n+     get saved (confuses gdb), so once we know the highest we just\n+     save all the ones below it, whether they're used or not.  */\n+  for (i = 18; i >= 3; i--)\n+    if (regs_ever_live[i])\n+      {\n+\tfsize += 4 * (i - 2);\n+\tbreak;\n+      }\n \n-  /* If we don't have a frame pointer, the register normally used for that\n-     purpose is saved just like other registers, not in the \"frame marker\".  */\n-  if (! frame_pointer_needed)\n-    {\n-      if (regs_ever_live[FRAME_POINTER_REGNUM])\n-\tfsize += 4;\n-    }\n+  /* Round the stack.  */\n   fsize = (fsize + 7) & ~7;\n \n+  /* We do not want to create holes in the callee registers that\n+     get saved (confuses gdb), so once we know the highest we just\n+     save all the ones below it, whether they're used or not.  */\n   for (i = 66; i >= 48; i -= 2)\n     if (regs_ever_live[i] || regs_ever_live[i + 1])\n       {\n \tif (fregs_live)\n \t  *fregs_live = 1;\n \n-\t/* For out of line prologues/epilogues we only need to\n-\t   compute the highest register number to save and\n-\t   allocate space for all the callee saved registers\n-\t   with a lower number.  */\n-        if (TARGET_SPACE)\n-\t  {\n-\t    fsize += 4 * (i - 46);\n-\t    break;\n-\t  }\n-\tfsize += 8;\n+\tfsize += 4 * (i = 46);\n+\tbreak;\n       }\n \n   fsize += current_function_outgoing_args_size;\n@@ -2185,42 +2167,86 @@ hppa_expand_prologue()\n     {\n       rtx operands[2];\n       int saves = 0;\n+      int outline_insn_count = 0;\n+      int inline_insn_count = 0;\n \n-      /* Put the local_fisze into %r19.  */\n-      operands[0] = gen_rtx (REG, SImode, 19);\n-      operands[1] = GEN_INT (local_fsize);\n-      emit_move_insn (operands[0], operands[1]);\n+      /* Count the number of insns for the inline and out of line\n+\t variants so we can choose one appropriately.\n \n-      /* Put the stack size into %r21.  */\n-      operands[0] = gen_rtx (REG, SImode, 21);\n-      operands[1] = size_rtx;\n-      emit_move_insn (operands[0], operands[1]);\n+\t No need to screw with counting actual_fsize operations -- they're\n+\t done for both inline and out of line prologues.  */\n+      if (regs_ever_live[2])\n+\tinline_insn_count += 1;\n+\n+      if (! cint_ok_for_move (local_fsize))\n+\toutline_insn_count += 2;\n+      else\n+\toutline_insn_count += 1;\n \n       /* Put the register save info into %r22.  */\n       for (i = 18; i >= 3; i--)\n \tif (regs_ever_live[i] && ! call_used_regs[i])\n \t  {\n+\t    /* -1 because the stack adjustment is normally done in\n+\t       the same insn as a register save.  */\n+\t    inline_insn_count += (i - 2) - 1;\n \t    saves = i;\n             break;\n \t  }\n-\t  \n+  \n       for (i = 66; i >= 48; i -= 2)\n \tif (regs_ever_live[i] || regs_ever_live[i + 1])\n \t  {\n+\t    /* +1 needed as we load %r1 with the start of the freg\n+\t       save area.  */\n+\t    inline_insn_count += (i/2 - 23) + 1;\n \t    saves |= ((i/2 - 12 ) << 16);\n \t    break;\n \t  }\n \n-      operands[0] = gen_rtx (REG, SImode, 22);\n-      operands[1] = GEN_INT (saves);\n-      emit_move_insn (operands[0], operands[1]);\n+      if (frame_pointer_needed)\n+\tinline_insn_count += 3;\n \n-      /* Now call the out-of-line prologue.  */\n-      emit_insn (gen_outline_prologue_call ());\n-      emit_insn (gen_blockage ());\n-      return;     \n+      if (! cint_ok_for_move (saves))\n+\toutline_insn_count += 2;\n+      else\n+\toutline_insn_count += 1;\n+\n+      if (TARGET_PORTABLE_RUNTIME)\n+\toutline_insn_count += 2;\n+      else\n+\toutline_insn_count += 1;\n+\t\n+      /* If there's a lot of insns in the prologue, then do it as\n+\t an out-of-line sequence.  */\n+      if (inline_insn_count > outline_insn_count)\n+\t{\n+\t  /* Put the local_fisze into %r19.  */\n+\t  operands[0] = gen_rtx (REG, SImode, 19);\n+\t  operands[1] = GEN_INT (local_fsize);\n+\t  emit_move_insn (operands[0], operands[1]);\n+\n+\t  /* Put the stack size into %r21.  */\n+\t  operands[0] = gen_rtx (REG, SImode, 21);\n+\t  operands[1] = size_rtx;\n+\t  emit_move_insn (operands[0], operands[1]);\n+\n+\t  operands[0] = gen_rtx (REG, SImode, 22);\n+\t  operands[1] = GEN_INT (saves);\n+\t  emit_move_insn (operands[0], operands[1]);\n+\n+\t  /* Now call the out-of-line prologue.  */\n+\t  emit_insn (gen_outline_prologue_call ());\n+\t  emit_insn (gen_blockage ());\n+\n+\t  /* Note that we're using an out-of-line prologue.  */\n+\t  out_of_line_prologue_epilogue = 1;\n+\t  return;     \n+\t}\n     }\n \n+  out_of_line_prologue_epilogue = 0;\n+\n   /* Save RP first.  The calling conventions manual states RP will\n      always be stored into the caller's frame at sp-20.  */\n   if (regs_ever_live[2] || profile_flag)\n@@ -2345,22 +2371,28 @@ hppa_expand_prologue()\n      was done earlier.  */\n   if (frame_pointer_needed)\n     {\n+      int found_one = 0;\n       for (i = 18, offset = local_fsize; i >= 4; i--)\n-\tif (regs_ever_live[i] && ! call_used_regs[i])\n+\tif (regs_ever_live[i] && ! call_used_regs[i]\n+\t    || found_one)\n \t  {\n+\t    found_one = 1;\n \t    store_reg (i, offset, FRAME_POINTER_REGNUM);\n \t    offset += 4;\n \t    gr_saved++;\n \t  }\n-      /* Account for %r4 which is saved in a special place.  */\n+      /* Account for %r3 which is saved in a special place.  */\n       gr_saved++;\n     }\n   /* No frame pointer needed.  */\n   else\n     {\n+      int found_one = 0;\n       for (i = 18, offset = local_fsize - actual_fsize; i >= 3; i--)\n-      \tif (regs_ever_live[i] && ! call_used_regs[i])\n+      \tif (regs_ever_live[i] && ! call_used_regs[i]\n+\t    || found_one)\n \t  {\n+\t    found_one = 1;\n \t    /* If merge_sp_adjust_with_store is nonzero, then we can\n \t       optimize the first GR save.  */\n \t    if (merge_sp_adjust_with_store)\n@@ -2400,13 +2432,18 @@ hppa_expand_prologue()\n \n       /* Now actually save the FP registers.  */\n       for (i = 66; i >= 48; i -= 2)\n-\tif (regs_ever_live[i] || regs_ever_live[i + 1])\n-\t  {\n-\t    emit_move_insn (gen_rtx (MEM, DFmode,\n-\t\t\t\t     gen_rtx (POST_INC, DFmode, tmpreg)),\n-\t\t\t    gen_rtx (REG, DFmode, i));\n-\t    fr_saved++;\n-\t  }\n+\t{\n+\t  int found_one = 0;\n+\t  if (regs_ever_live[i] || regs_ever_live[i + 1]\n+\t      || found_one)\n+\t    {\n+\t      found_one = 1;\n+\t      emit_move_insn (gen_rtx (MEM, DFmode,\n+\t\t\t\t       gen_rtx (POST_INC, DFmode, tmpreg)),\n+\t\t\t      gen_rtx (REG, DFmode, i));\n+\t      fr_saved++;\n+\t    }\n+\t}\n     }\n \n   /* When generating PIC code it is necessary to save/restore the\n@@ -2490,7 +2527,7 @@ hppa_expand_epilogue ()\n   int merge_sp_adjust_with_load  = 0;\n \n   /* Handle out of line prologues and epilogues.  */\n-  if (TARGET_SPACE)\n+  if (TARGET_SPACE && out_of_line_prologue_epilogue)\n     {\n       int saves = 0;\n       rtx operands[2];\n@@ -2517,6 +2554,11 @@ hppa_expand_epilogue ()\n       operands[1] = GEN_INT (local_fsize);\n       emit_move_insn (operands[0], operands[1]);\n \n+      /* Put the stack size into %r21.  */\n+      operands[0] = gen_rtx (REG, SImode, 21);\n+      operands[1] = GEN_INT (actual_fsize);\n+      emit_move_insn (operands[0], operands[1]);\n+\n       operands[0] = gen_rtx (REG, SImode, 22);\n       operands[1] = GEN_INT (saves);\n       emit_move_insn (operands[0], operands[1]);\n@@ -2545,29 +2587,37 @@ hppa_expand_epilogue ()\n   /* General register restores.  */\n   if (frame_pointer_needed)\n     {\n+      int found_one = 0;\n       for (i = 18, offset = local_fsize; i >= 4; i--)\n-\tif (regs_ever_live[i] && ! call_used_regs[i])\n+\tif (regs_ever_live[i] && ! call_used_regs[i]\n+\t    || found_one)\n \t  {\n+\t    found_one = 1;\n \t    load_reg (i, offset, FRAME_POINTER_REGNUM);\n \t    offset += 4;\n \t  }\n     }\n   else\n     {\n       for (i = 18, offset = local_fsize - actual_fsize; i >= 3; i--)\n-\tif (regs_ever_live[i] && ! call_used_regs[i])\n-\t  {\n-\t    /* Only for the first load.\n-\t       merge_sp_adjust_with_load holds the register load\n-\t       with which we will merge the sp adjustment.  */\n-\t    if (VAL_14_BITS_P (actual_fsize + 20)\n-\t\t&& local_fsize == 0\n-\t\t&& ! merge_sp_adjust_with_load)\n-\t      merge_sp_adjust_with_load = i;\n-\t    else\n-\t      load_reg (i, offset, STACK_POINTER_REGNUM);\n-\t    offset += 4;\n-\t  }\n+\t{\n+\t  int found_one = 0;\n+\t  if (regs_ever_live[i] && ! call_used_regs[i]\n+\t      || found_one)\n+\t    {\n+\t      found_one = 1;\n+\t      /* Only for the first load.\n+\t         merge_sp_adjust_with_load holds the register load\n+\t         with which we will merge the sp adjustment.  */\n+\t      if (VAL_14_BITS_P (actual_fsize + 20)\n+\t\t  && local_fsize == 0\n+\t\t  && ! merge_sp_adjust_with_load)\n+\t        merge_sp_adjust_with_load = i;\n+\t      else\n+\t        load_reg (i, offset, STACK_POINTER_REGNUM);\n+\t      offset += 4;\n+\t    }\n+\t}\n     }\n \n   /* Align pointer properly (doubleword boundary).  */\n@@ -2584,10 +2634,16 @@ hppa_expand_epilogue ()\n \n       /* Actually do the restores now.  */\n       for (i = 66; i >= 48; i -= 2)\n-\tif (regs_ever_live[i] || regs_ever_live[i + 1])\n-\t  emit_move_insn (gen_rtx (REG, DFmode, i),\n-\t\t\t  gen_rtx (MEM, DFmode,\n-\t\t\t\t   gen_rtx (POST_INC, DFmode, tmpreg)));\n+\t{\n+\t  int found_one = 0;\n+\t  if (regs_ever_live[i] || regs_ever_live[i + 1])\n+\t    {\n+\t      found_one = 1;\n+\t      emit_move_insn (gen_rtx (REG, DFmode, i),\n+\t\t\t      gen_rtx (MEM, DFmode,\n+\t\t\t\t       gen_rtx (POST_INC, DFmode, tmpreg)));\n+\t    }\n+\t}\n     }\n \n   /* Emit a blockage insn here to keep these insns from being moved to"}, {"sha": "a464bda543f456f876968efc927ab2d1060fdcb8", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63ffc3836f06f9176692dbc6463f5ff61a9c277/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63ffc3836f06f9176692dbc6463f5ff61a9c277/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=e63ffc3836f06f9176692dbc6463f5ff61a9c277", "patch": "@@ -560,11 +560,9 @@ do {\t\t\t\t\t\t\t\t\\\n /* Base register for access to local variables of the function.  */\n #define FRAME_POINTER_REGNUM 3\n \n-/* Value should be nonzero if functions must have frame pointers.\n-   All functions have frame pointers when optimizing for space\n-   (for now).  */\n+/* Value should be nonzero if functions must have frame pointers.  */\n #define FRAME_POINTER_REQUIRED \\\n-  (current_function_calls_alloca || TARGET_SPACE)\n+  (current_function_calls_alloca)\n \n /* C statement to store the difference between the frame pointer\n    and the stack pointer values immediately after the function prologue."}, {"sha": "116f372c9e441ed57c7375e3427dc14046b1bb1a", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 63, "deletions": 17, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63ffc3836f06f9176692dbc6463f5ff61a9c277/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63ffc3836f06f9176692dbc6463f5ff61a9c277/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=e63ffc3836f06f9176692dbc6463f5ff61a9c277", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for HP PA-RISC architecture for GNU C compiler\n-;;   Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.\n+;;   Copyright (C) 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n ;;   Contributed by the Center for Software Science at the University\n ;;   of Utah.\n \n@@ -4850,18 +4850,39 @@\n   \"\"\n   \"*\n {\n-  /* Must import the magic millicode routine.  */\n-  output_asm_insn (\\\".IMPORT __outline_prologue,MILLICODE\\\", NULL);\n+  extern int frame_pointer_needed;\n \n-  /* The out-of-line prologue will make sure we return to the right\n-     instruction.  */\n-  if (TARGET_PORTABLE_RUNTIME)\n+  /* We need two different versions depending on whether or not we\n+     need a frame pointer.   Also note that we return to the instruction\n+     immediately after the branch rather than two instructions after the\n+     break as normally is the case.  */\n+  if (frame_pointer_needed)\n     {\n-      output_asm_insn (\\\"ldil L'__outline_prologue,%%r31\\\", NULL);\n-      output_asm_insn (\\\"ble,n R'__outline_prologue(%%sr0,%%r31)\\\", NULL);\n+      /* Must import the magic millicode routine(s).  */\n+      output_asm_insn (\\\".IMPORT __outline_prologue_fp,MILLICODE\\\", NULL);\n+\n+      if (TARGET_PORTABLE_RUNTIME)\n+\t{\n+\t  output_asm_insn (\\\"ldil L'__outline_prologue_fp,%%r31\\\", NULL);\n+\t  output_asm_insn (\\\"ble,n R'__outline_prologue_fp(%%sr0,%%r31)\\\",\n+\t\t\t   NULL);\n+\t}\n+      else\n+\toutput_asm_insn (\\\"bl,n __outline_prologue_fp,%%r31\\\", NULL);\n     }\n   else\n-    output_asm_insn (\\\"bl,n __outline_prologue,%%r31\\\", NULL);\n+    {\n+      /* Must import the magic millicode routine(s).  */\n+      output_asm_insn (\\\".IMPORT __outline_prologue,MILLICODE\\\", NULL);\n+\n+      if (TARGET_PORTABLE_RUNTIME)\n+\t{\n+\t  output_asm_insn (\\\"ldil L'__outline_prologue,%%r31\\\", NULL);\n+\t  output_asm_insn (\\\"ble,n R'__outline_prologue(%%sr0,%%r31)\\\", NULL);\n+\t}\n+      else\n+\toutput_asm_insn (\\\"bl,n __outline_prologue,%%r31\\\", NULL);\n+    }\n   return \\\"\\\";\n }\"\n   [(set_attr \"type\" \"multi\")\n@@ -4882,18 +4903,43 @@\n   \"\"\n   \"*\n {\n-  /* Must import the magic millicode routine.  */\n-  output_asm_insn (\\\".IMPORT __outline_epilogue,MILLICODE\\\", NULL);\n+  extern int frame_pointer_needed;\n \n-  /* The out-of-line prologue will make sure we return to the right\n-     instruction.  */\n-  if (TARGET_PORTABLE_RUNTIME)\n+  /* We need two different versions depending on whether or not we\n+     need a frame pointer.   Also note that we return to the instruction\n+     immediately after the branch rather than two instructions after the\n+     break as normally is the case.  */\n+  if (frame_pointer_needed)\n     {\n-      output_asm_insn (\\\"ldil L'__outline_epilogue,%%r31\\\", NULL);\n-      output_asm_insn (\\\"ble,n R'__outline_epilogue(%%sr0,%%r31)\\\", NULL);\n+      /* Must import the magic millicode routine.  */\n+      output_asm_insn (\\\".IMPORT __outline_epilogue_fp,MILLICODE\\\", NULL);\n+\n+      /* The out-of-line prologue will make sure we return to the right\n+\t instruction.  */\n+      if (TARGET_PORTABLE_RUNTIME)\n+\t{\n+\t  output_asm_insn (\\\"ldil L'__outline_epilogue_fp,%%r31\\\", NULL);\n+\t  output_asm_insn (\\\"ble,n R'__outline_epilogue_fp(%%sr0,%%r31)\\\",\n+\t\t\t   NULL);\n+\t}\n+      else\n+\toutput_asm_insn (\\\"bl,n __outline_epilogue_fp,%%r31\\\", NULL);\n     }\n   else\n-    output_asm_insn (\\\"bl,n __outline_epilogue,%%r31\\\", NULL);\n+    {\n+      /* Must import the magic millicode routine.  */\n+      output_asm_insn (\\\".IMPORT __outline_epilogue,MILLICODE\\\", NULL);\n+\n+      /* The out-of-line prologue will make sure we return to the right\n+\t instruction.  */\n+      if (TARGET_PORTABLE_RUNTIME)\n+\t{\n+\t  output_asm_insn (\\\"ldil L'__outline_epilogue,%%r31\\\", NULL);\n+\t  output_asm_insn (\\\"ble,n R'__outline_epilogue(%%sr0,%%r31)\\\", NULL);\n+\t}\n+      else\n+\toutput_asm_insn (\\\"bl,n __outline_epilogue,%%r31\\\", NULL);\n+    }\n   return \\\"\\\";\n }\"\n   [(set_attr \"type\" \"multi\")"}, {"sha": "f9a77324f759cffd4edcbc1ecaf20f120c244851", "filename": "gcc/config/pa/t-pro", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e63ffc3836f06f9176692dbc6463f5ff61a9c277/gcc%2Fconfig%2Fpa%2Ft-pro", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e63ffc3836f06f9176692dbc6463f5ff61a9c277/gcc%2Fconfig%2Fpa%2Ft-pro", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Ft-pro?ref=e63ffc3836f06f9176692dbc6463f5ff61a9c277", "patch": "@@ -19,3 +19,12 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n lib2funcs.asm: $(srcdir)/config/pa/lib2funcs.asm\n \trm -f lib2funcs.asm\n \tcp $(srcdir)/config/pa/lib2funcs.asm .\n+\n+# Build the libraries for both speed and space optimizations\n+\n+MULTILIB_OPTIONS=mspace\n+MULTILIB_DIRNAMES=space\n+MULTILIB_MATCHES=\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib"}]}