{"sha": "f7b6d10479f7db36e64a5943c60426a1e8cabc49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdiNmQxMDQ3OWY3ZGIzNmU2NGE1OTQzYzYwNDI2YTFlOGNhYmM0OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-09-30T18:03:48Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-09-30T18:03:48Z"}, "message": "function.c (purge_addressof_1): Use bitfield manipulation routines to handle mem mode < reg mode.\n\n        * function.c (purge_addressof_1): Use bitfield manipulation\n        routines to handle mem mode < reg mode.\n\nFrom-SVN: r22686", "tree": {"sha": "aa12f02c904c0630f987c5e88c9123d4dca0eded", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa12f02c904c0630f987c5e88c9123d4dca0eded"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7b6d10479f7db36e64a5943c60426a1e8cabc49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7b6d10479f7db36e64a5943c60426a1e8cabc49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7b6d10479f7db36e64a5943c60426a1e8cabc49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7b6d10479f7db36e64a5943c60426a1e8cabc49/comments", "author": null, "committer": null, "parents": [{"sha": "96960d10b790d45f670a348d66c81cbfa1e33d37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96960d10b790d45f670a348d66c81cbfa1e33d37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96960d10b790d45f670a348d66c81cbfa1e33d37"}], "stats": {"total": 97, "additions": 85, "deletions": 12}, "files": [{"sha": "4075787acd7eaace549b1b24cc03ffd605174dd8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b6d10479f7db36e64a5943c60426a1e8cabc49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b6d10479f7db36e64a5943c60426a1e8cabc49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7b6d10479f7db36e64a5943c60426a1e8cabc49", "patch": "@@ -1,3 +1,8 @@\n+Wed Sep 30 18:03:22 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* function.c (purge_addressof_1): Use bitfield manipulation\n+\troutines to handle mem mode < reg mode.\n+\n Wed Sep 30 18:43:32 1998  Herman ten Brugge <Haj.Ten.Brugge@net.HCC.nl> \n \n \t* reorg.c (try_merge_delay_insns): Account for resources referenced"}, {"sha": "3361fd857294c41b988d12165b440cf44a483b84", "filename": "gcc/function.c", "status": "modified", "additions": 80, "deletions": 12, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b6d10479f7db36e64a5943c60426a1e8cabc49/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b6d10479f7db36e64a5943c60426a1e8cabc49/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f7b6d10479f7db36e64a5943c60426a1e8cabc49", "patch": "@@ -457,7 +457,7 @@ static int *record_insns\tPROTO((rtx));\n static int contains\t\tPROTO((rtx, int *));\n #endif /* HAVE_prologue || HAVE_epilogue */\n static void put_addressof_into_stack PROTO((rtx));\n-static void purge_addressof_1\tPROTO((rtx *, rtx, int));\n+static void purge_addressof_1\tPROTO((rtx *, rtx, int, int));\n \f\n /* Pointer to chain of `struct function' for containing functions.  */\n struct function *outer_function_chain;\n@@ -2812,10 +2812,10 @@ put_addressof_into_stack (r)\n    the stack.  */\n \n static void\n-purge_addressof_1 (loc, insn, force)\n+purge_addressof_1 (loc, insn, force, store)\n      rtx *loc;\n      rtx insn;\n-     int force;\n+     int force, store;\n {\n   rtx x;\n   RTX_CODE code;\n@@ -2847,7 +2847,7 @@ purge_addressof_1 (loc, insn, force)\n \t\t\t     0))\n \tabort ();\n \n-      insns = get_insns ();\n+      insns = gen_sequence ();\n       end_sequence ();\n       emit_insns_before (insns, insn);\n       return;\n@@ -2867,11 +2867,73 @@ purge_addressof_1 (loc, insn, force)\n \t}\n       else if (GET_CODE (sub) == REG && GET_MODE (x) != GET_MODE (sub))\n \t{\n-\t  if (! BYTES_BIG_ENDIAN && ! WORDS_BIG_ENDIAN)\n+\t  int size_x, size_sub;\n+\n+\t  size_x = GET_MODE_BITSIZE (GET_MODE (x));\n+\t  size_sub = GET_MODE_BITSIZE (GET_MODE (sub));\n+\n+\t  /* Don't even consider working with paradoxical subregs,\n+\t     or the moral equivalent seen here.  */\n+\t  if (size_x < size_sub)\n \t    {\n-\t      rtx sub2 = gen_rtx_SUBREG (GET_MODE (x), sub, 0);\n-\t      if (validate_change (insn, loc, sub2, 0))\n-\t\tgoto restart;\n+\t      /* Do a bitfield insertion to mirror what would happen\n+\t\t in memory.  */\n+\n+\t      int bitpos;\n+\t      rtx val, seq;\n+\n+\t      bitpos = 0;\n+\t      if (WORDS_BIG_ENDIAN)\n+\t\t{\n+\t\t  bitpos += (size_sub / BITS_PER_WORD) * BITS_PER_WORD;\n+\t\t  bitpos += (size_x / BITS_PER_WORD) * BITS_PER_WORD;\n+\t\t}\n+\t      if (BYTES_BIG_ENDIAN)\n+\t\t{\n+\t\t  bitpos += size_sub % BITS_PER_WORD;\n+\t\t  bitpos -= size_x % BITS_PER_WORD;\n+\t\t}\n+\n+\t      if (store)\n+\t\t{\n+\t\t  /* If we can't replace with a register, be afraid.  */\n+\n+\t\t  start_sequence ();\n+\t\t  val = gen_reg_rtx (GET_MODE (x));\n+\t\t  if (! validate_change (insn, loc, val, 0))\n+\t\t    abort ();\n+\t\t  seq = gen_sequence ();\n+\t\t  end_sequence ();\n+\t\t  emit_insn_before (seq, insn);\n+\t      \n+\t\t  start_sequence ();\n+\t\t  store_bit_field (sub, size_x, bitpos, GET_MODE (x),\n+\t\t\t\t   val, GET_MODE_SIZE (GET_MODE (sub)),\n+\t\t\t\t   GET_MODE_SIZE (GET_MODE (sub)));\n+\n+\t\t  seq = gen_sequence ();\n+\t\t  end_sequence ();\n+\t\t  emit_insn_after (seq, insn);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  start_sequence ();\n+\t\t  val = extract_bit_field (sub, size_x, bitpos, 1, NULL_RTX,\n+\t\t\t\t\t   GET_MODE (x), GET_MODE (x),\n+\t\t\t\t\t   GET_MODE_SIZE (GET_MODE (sub)),\n+\t\t\t\t\t   GET_MODE_SIZE (GET_MODE (sub)));\n+\n+\t\t  /* If we can't replace with a register, be afraid.  */\n+\t\t  if (! validate_change (insn, loc, val, 0))\n+\t\t    abort ();\n+\n+\t\t  seq = gen_sequence ();\n+\t\t  end_sequence ();\n+\t\t  emit_insn_before (seq, insn);\n+\t\t}\n+\n+\t      /* We replaced with a reg -- all done.  */\n+\t      return;\n \t    }\n \t}\n       else if (validate_change (insn, loc, sub, 0))\n@@ -2883,16 +2945,22 @@ purge_addressof_1 (loc, insn, force)\n       put_addressof_into_stack (x);\n       return;\n     }\n+  else if (code == SET)\n+    {\n+      purge_addressof_1 (&SET_DEST (x), insn, force, 1);\n+      purge_addressof_1 (&SET_SRC (x), insn, force, 0);\n+      return;\n+    }\n \n   /* Scan all subexpressions. */\n   fmt = GET_RTX_FORMAT (code);\n   for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n     {\n       if (*fmt == 'e')\n-\tpurge_addressof_1 (&XEXP (x, i), insn, force);\n+\tpurge_addressof_1 (&XEXP (x, i), insn, force, 0);\n       else if (*fmt == 'E')\n \tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  purge_addressof_1 (&XVECEXP (x, i, j), insn, force);\n+\t  purge_addressof_1 (&XVECEXP (x, i, j), insn, force, 0);\n     }\n }\n \n@@ -2910,8 +2978,8 @@ purge_addressof (insns)\n \t|| GET_CODE (insn) == CALL_INSN)\n       {\n \tpurge_addressof_1 (&PATTERN (insn), insn,\n-\t\t\t   asm_noperands (PATTERN (insn)) > 0);\n-\tpurge_addressof_1 (&REG_NOTES (insn), NULL_RTX, 0);\n+\t\t\t   asm_noperands (PATTERN (insn)) > 0, 0);\n+\tpurge_addressof_1 (&REG_NOTES (insn), NULL_RTX, 0, 0);\n       }\n }\n \f"}]}