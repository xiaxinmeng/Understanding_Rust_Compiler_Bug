{"sha": "34fcf41e30ff56155e996f5e04f6ca13948a19b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRmY2Y0MWUzMGZmNTYxNTVlOTk2ZjVlMDRmNmNhMTM5NDhhMTliNg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-08-14T16:27:59Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-08-14T16:27:59Z"}, "message": "PR tree-optimization/91294 - [10 Regression] wrong strlen result of a conditional with an offset\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/91294\n\t* gcc.dg/strlenopt-44.c: Adjust tested result.\n\t* gcc.dg/strlenopt-70.c: Avoid exercising unimplemnted optimization.\n\t* gcc.dg/strlenopt-73.c: New test.\n\t* gcc.dg/strlenopt-74.c: New test.\n\t* gcc.dg/strlenopt-75.c: New test.\n\t* gcc.dg/strlenopt-76.c: New test.\n\t* gcc.dg/strlenopt-77.c: New test.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/91294\n\t* tree-ssa-strlen.c (handle_store): Avoid treating lower bound of\n\tsource length as exact.\n\nFrom-SVN: r274486", "tree": {"sha": "8a9f0642405ff0af870ba30ae6b2b919832c3b1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a9f0642405ff0af870ba30ae6b2b919832c3b1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34fcf41e30ff56155e996f5e04f6ca13948a19b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34fcf41e30ff56155e996f5e04f6ca13948a19b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34fcf41e30ff56155e996f5e04f6ca13948a19b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34fcf41e30ff56155e996f5e04f6ca13948a19b6/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b1c0d18515f6899bc8362d9dc861021c929127f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1c0d18515f6899bc8362d9dc861021c929127f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1c0d18515f6899bc8362d9dc861021c929127f9"}], "stats": {"total": 947, "additions": 847, "deletions": 100}, "files": [{"sha": "7e2158be4a1813d9b08ed5c37ee782253b93fa1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34fcf41e30ff56155e996f5e04f6ca13948a19b6", "patch": "@@ -1,3 +1,9 @@\n+2019-08-14  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/91294\n+\t* tree-ssa-strlen.c (handle_store): Avoid treating lower bound of\n+\tsource length as exact.\n+\n 2019-08-14  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* doc/extend.texi: Add \"noinit\" attribute documentation."}, {"sha": "d576b0842f9e8f2de9bdca0050b0804f4187a9a3", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=34fcf41e30ff56155e996f5e04f6ca13948a19b6", "patch": "@@ -3726,7 +3726,7 @@ gimple_fold_builtin_strlen (gimple_stmt_iterator *gsi)\n \n   /* Set the strlen() range to [0, MAXLEN].  */\n   if (tree lhs = gimple_call_lhs (stmt))\n-    set_strlen_range (lhs, maxlen);\n+    set_strlen_range (lhs, minlen, maxlen);\n \n   return false;\n }"}, {"sha": "ceb12b37eee9b5c4142e29639b42d448a656f459", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=34fcf41e30ff56155e996f5e04f6ca13948a19b6", "patch": "@@ -1,3 +1,14 @@\n+2019-08-14  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/91294\n+\t* gcc.dg/strlenopt-44.c: Adjust tested result.\n+\t* gcc.dg/strlenopt-70.c: Avoid exercising unimplemnted optimization.\n+\t* gcc.dg/strlenopt-73.c: New test.\n+\t* gcc.dg/strlenopt-74.c: New test.\n+\t* gcc.dg/strlenopt-75.c: New test.\n+\t* gcc.dg/strlenopt-76.c: New test.\n+\t* gcc.dg/strlenopt-77.c: New test.\n+\n 2019-08-14  Jakub Jelinek  <jakub@redhat.com>\n \t    Marek Polacek  <polacek@redhat.com>\n "}, {"sha": "0af78acaf1d1e40402c80345f15a9d985064eafb", "filename": "gcc/testsuite/gcc.dg/strlenopt-44.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-44.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-44.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-44.c?ref=34fcf41e30ff56155e996f5e04f6ca13948a19b6", "patch": "@@ -83,7 +83,7 @@ void test_keep (void)\n   size_t uchar_max = (unsigned char)-1;\n \n   KEEP (\"1\",     0, UR (1, uchar_max + 1), 1);\n-  KEEP (\"1\\0\\3\", 1, UR (1, 2), 1);\n+  KEEP (\"1\\0\\3\", 1, UR (1, 2), 2);\n }\n \n /* { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated_\" 0 \"optimized\" } }"}, {"sha": "0853023c3b6814ef35a53d76c6214f852fabf162", "filename": "gcc/testsuite/gcc.dg/strlenopt-70.c", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-70.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-70.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-70.c?ref=34fcf41e30ff56155e996f5e04f6ca13948a19b6", "patch": "@@ -201,14 +201,17 @@ void store_32bit (volatile int i)\n   T (\"xxx\",  uint32_t, 0, I32 (\"\\1\\2\\3\\0\"), == 3);\n   T (\"xxx\",  uint32_t, 0, I32 (\"\\0\\1\\2\\3\"), == 0);\n \n-  uint32_t x00332211 = I32 (\"123\\0\");\n-  uint32_t x00002211 = I32 (\"12\\0\\0\");\n-  uint32_t x00000011 = I32 (\"1\\0\\0\\0\");\n-\n-  T (\"xxxx\", uint32_t, 0, i ? x00332211 : x00002211, <= 3);\n-  T (\"xxxx\", uint32_t, 0, i ? x00332211 : x00002211, >= 2);\n-  T (\"xxxx\", uint32_t, 0, i ? x00332211 : x00000011, <= 3);\n-  T (\"xxxx\", uint32_t, 0, i ? x00332211 : x00000011, >= 1);\n+  uint32_t x123_ = I32 (\"123\\0\");\n+  uint32_t x12__ = I32 (\"12\\0\\0\");\n+  uint32_t x1___ = I32 (\"1\\0\\0\\0\");\n+\n+  // FIXME: Upper bound not implemented yet.\n+  /* T (\"xxxx\", uint32_t, 0, i ? x123_ : x12__, <= 3); */\n+  T (\"xxxx\", uint32_t, 0, i ? x123_ : x12__, >= 2);\n+  T (\"xxxx\", uint32_t, 0, i ? x12__ : x123_, >= 2);\n+  /* T (\"xxxx\", uint32_t, 0, i ? x123_ : x1___, <= 3); */\n+  T (\"xxxx\", uint32_t, 0, i ? x123_ : x1___, >= 1);\n+  T (\"xxxx\", uint32_t, 0, i ? x1___ : x123_, >= 1);\n \n   TX (\"abcde\",  uint32_t, 0, i ? I32 (\"1234\") : I32 (\"1235\"), == 5);\n   TX (\"abcde\",  uint32_t, 1, i ? I32 (\"1234\") : I32 (\"1235\"), == 5);\n@@ -220,7 +223,8 @@ void store_32bit (volatile int i)\n   TX (\"abcdef\", uint32_t, 3, i ? I32 (\"12\\0\\0\") : I32 (\"13\\0\\0\"), == 5);\n \n   TX (\"abcdef\", uint32_t, 3, i ? I32 (\"12\\0\\0\") : I32 (\"123\\0\"), >= 5);\n-  TX (\"abcdef\", uint32_t, 3, i ? I32 (\"12\\0\\0\") : I32 (\"123\\0\"), < 7);\n+  /* FIXME: Upper bound not implemented yet.  */\n+  /* TX (\"abcdef\", uint32_t, 3, i ? I32 (\"12\\0\\0\") : I32 (\"123\\0\"), < 7); */\n }\n \n void store_64bit (int i)\n@@ -246,17 +250,19 @@ void store_64bit (int i)\n   T (\"xxxxxxx\", uint64_t, 0, I64 (\"\\1\\2\\3\\4\\5\\6\\0\\0\\0\"), == 6);\n   T (\"xxxxxxx\", uint64_t, 0, I64 (\"\\1\\2\\3\\4\\5\\6\\7\\0\\0\"), == 7);\n \n-  uint64_t x7777777 = I64 (\"\\7\\7\\7\\7\\7\\7\\7\");\n-  uint64_t x666666 = I64 (\"\\6\\6\\6\\6\\6\\6\\0\");\n-  uint64_t x4444 = I64 (\"\\4\\4\\4\\4\\0\\0\\0\");\n-  uint64_t x3333 = I64 (\"\\3\\3\\3\\3\\0\\0\\0\");\n-  uint64_t x1 = I64 (\"\\1\\0\\0\\0\\0\\0\\0\");\n-\n-  T (\"x\\0xxxxxx\", uint64_t, 0, i ? x7777777 : x666666, <= 7);\n-  T (\"xx\\0xxxxx\", uint64_t, 0, i ? x7777777 : x666666, >= 6);\n-  T (\"xxx\\0xxxx\", uint64_t, 0, i ? x666666 : x1, <= 6);\n-  T (\"xxxx\\0xxx\", uint64_t, 0, i ? x666666 : x1, >= 1);\n-  T (\"xxxxxx\\0x\", uint64_t, 0, i ? x4444 : x3333, == 4);\n+  uint64_t x7777777_ = I64 (\"\\7\\7\\7\\7\\7\\7\\7\");\n+  uint64_t x666666__ = I64 (\"\\6\\6\\6\\6\\6\\6\\0\");\n+  uint64_t x4444____ = I64 (\"\\4\\4\\4\\4\\0\\0\\0\");\n+  uint64_t x4343____ = I64 (\"\\4\\3\\4\\3\\0\\0\\0\");\n+  uint64_t x1_______ = I64 (\"\\1\\0\\0\\0\\0\\0\\0\");\n+\n+  /* FIXME: Upper bound not implemented yet.  */\n+  /* T (\"x\\0xxxxxx\", uint64_t, 0, i ? x7777777_ : x666666__, <= 7); */\n+  T (\"xx\\0xxxxx\", uint64_t, 0, i ? x7777777_ : x666666__, >= 6);\n+  T (\"xxx\\0xxxx\", uint64_t, 1, i ? x7777777_ : x666666__, >= 7);\n+  /* T (\"xxx\\0xxxx\", uint64_t, 0, i ? x666666__ : x1, <= 6); */\n+  T (\"xxxx\\0xxx\", uint64_t, 0, i ? x666666__ : x1_______, >= 1);\n+  T (\"xxxxxx\\0x\", uint64_t, 0, i ? x4444____ : x4343____, == 4);\n }\n \n #if __SIZEOF_INT128__"}, {"sha": "4f13afd5ee5226065464741a4c68ee24bf3cd772", "filename": "gcc/testsuite/gcc.dg/strlenopt-73.c", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-73.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-73.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-73.c?ref=34fcf41e30ff56155e996f5e04f6ca13948a19b6", "patch": "@@ -0,0 +1,133 @@\n+/* PR tree-optimization/91183 - strlen of a strcpy result with a conditional\n+   source not folded\n+   Test to verify that strlen can determine string lengths from stores\n+   involving PHI nodes with distinct strings of the same length of at\n+   least 16 bytes.\n+\n+   { dg-do compile }\n+   { dg-options \"-O2 -fdump-tree-optimized\" }\n+   On strictly aligned targets the consecutive char assignments used\n+   by the test aren't merged.  When they involve multiple trailing nuls\n+   these assignments then defeat the strlen optimization as a result of\n+   pr83821.  When the bug is resolved the directive below can be removed.\n+   { dg-require-effective-target non_strict_align } */\n+\n+#include \"strlenopt.h\"\n+\n+#define CAT(x, y) x ## y\n+#define CONCAT(x, y) CAT (x, y)\n+#define FAILNAME(name) CONCAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macros to emit a call to function named\n+     call_failed_to_be_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr)\t\t\t\t\\\n+  if ((expr)) FAIL (not_eliminated); else (void)0\n+\n+#define T(expect, N, ncpy, cond) do {\t\t\\\n+    char CONCAT (arr_, __LINE__)[N];\t\t\\\n+    char *pa = CONCAT (arr_, __LINE__);\t\t\\\n+    memcpy (pa, cond, ncpy);\t\t\t\\\n+    ELIM (!(expect strlen (pa)));\t\t\\\n+    sink (pa);\t\t\t\t\t\\\n+  } while (0)\n+\n+void sink (void*);\n+\n+const char a32[33] = \"0123456789abcdef0123456789abcdef\";\n+const char b32[33] = \"fedcba9876543210fedcba9876543210\";\n+\n+const char a16[33] = \"0123456789abcdef\";\n+const char b16[33] = \"fedcba9876543210\";\n+\n+int i0, i1, i2;\n+\n+void test_copy_cond_equal_length (void)\n+{\n+  // The test below is represented as this:\n+  //   # iftmp.0_3 = PHI <&b16(2), &a16(3)>\n+  //   MEM <unsigned char[17]> [(char * {ref-all})&a]\n+  //     = MEM <unsigned char[17]> [(char * {ref-all})iftmp.0_3];\n+  //   _2 = strlen (&a);\n+  T (16 ==, 17, 17, i0 ? a16 : b16);\n+  T (16 ==, 17, 17, i0 ? a16 : b16);\n+  T (15 ==, 17, 16, (i0 ? a16 : b16) +  1);\n+  T (14 ==, 17, 15, (i0 ? a16 : b16) +  2);\n+  T ( 0 ==, 17,  1, (i0 ? a16 : b16) + 16);\n+\n+  T (31 ==, 33, 32, (i0 ? a32 : b32) +  1);\n+  T (30 ==, 33, 31, (i0 ? a32 : b32) +  2);\n+  T (29 ==, 33, 30, (i0 ? a32 : b32) +  3);\n+  T ( 1 ==, 33,  2, (i0 ? a32 : b32) + 31);\n+  T ( 0 ==, 33,  1, (i0 ? a32 : b32) + 32);\n+}\n+\n+\n+const char a4[16] = \"0123\";\n+const char b4[16] = \"3210\";\n+\n+void test_copy_cond_unequal_length_i64 (void)\n+{\n+  T (2 <, 16, 8, i0 ? a4 + 1 : b4 + 0);\n+  T (1 <, 16, 8, i0 ? a4 + 1 : b4 + 2);\n+  T (0 <, 16, 8, i0 ? a4 + 1 : b4 + 3);\n+\n+  T (1 <, 16, 8, i0 ? a4 + 2 : b4 + 0);\n+  T (1 <, 16, 8, i0 ? a4 + 2 : b4 + 1);\n+  T (0 <, 16, 8, i0 ? a4 + 2 : b4 + 3);\n+}\n+\n+\n+#if __SIZEOF_INT128__ == 16\n+\n+/* The following tests assume GCC transforms the memcpy calls into\n+   int128_t assignments which it does only when int128_t is supported.  */\n+\n+const char a8[32] = \"01234567\";\n+const char b8[32] = \"76543210\";\n+\n+void test_copy_cond_unequal_length_i128 (void)\n+{\n+  T (6 <, 32, 16, i0 ? a8 + 1 : b8 + 0);\n+  T (5 <, 32, 16, i0 ? a8 + 1 : b8 + 2);\n+  T (4 <, 32, 16, i0 ? a8 + 1 : b8 + 3);\n+  T (3 <, 32, 16, i0 ? a8 + 1 : b8 + 4);\n+  T (2 <, 32, 16, i0 ? a8 + 1 : b8 + 5);\n+  T (1 <, 32, 16, i0 ? a8 + 1 : b8 + 6);\n+  T (0 <, 32, 16, i0 ? a8 + 1 : b8 + 7);\n+\n+  T (5 <, 32, 16, i0 ? a8 + 2 : b8 + 0);\n+  T (5 <, 32, 16, i0 ? a8 + 2 : b8 + 1);\n+  T (3 <, 32, 16, i0 ? a8 + 2 : b8 + 3);\n+  T (2 <, 32, 16, i0 ? a8 + 2 : b8 + 4);\n+  T (1 <, 32, 16, i0 ? a8 + 2 : b8 + 5);\n+  T (0 <, 32, 16, i0 ? a8 + 2 : b8 + 6);\n+\n+  T (4 <, 32, 16, i0 ? a8 + 3 : b8 + 0);\n+  T (4 <, 32, 16, i0 ? a8 + 3 : b8 + 1);\n+  T (4 <, 32, 16, i0 ? a8 + 3 : b8 + 2);\n+  T (3 <, 32, 16, i0 ? a8 + 3 : b8 + 4);\n+  T (2 <, 32, 16, i0 ? a8 + 3 : b8 + 5);\n+  T (1 <, 32, 16, i0 ? a8 + 3 : b8 + 6);\n+  T (0 <, 32, 16, i0 ? a8 + 3 : b8 + 7);\n+\n+  T (3 <, 32, 16, i0 ? a8 + 4 : b8 + 0);\n+  T (3 <, 32, 16, i0 ? a8 + 4 : b8 + 1);\n+  T (3 <, 32, 16, i0 ? a8 + 4 : b8 + 2);\n+  T (3 <, 32, 16, i0 ? a8 + 4 : b8 + 3);\n+  T (2 <, 32, 16, i0 ? a8 + 4 : b8 + 5);\n+  T (1 <, 32, 16, i0 ? a8 + 4 : b8 + 6);\n+  T (0 <, 32, 16, i0 ? a8 + 4 : b8 + 7);\n+}\n+\n+#endif   /* int128_t exists */\n+\n+/* { dg-final { scan-tree-dump-times \"strlen\" 0 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"_not_eliminated_\" 0 \"optimized\" } } */"}, {"sha": "0a9ac6c1da201326ba6ebdeb0848fdd14a351969", "filename": "gcc/testsuite/gcc.dg/strlenopt-74.c", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-74.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-74.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-74.c?ref=34fcf41e30ff56155e996f5e04f6ca13948a19b6", "patch": "@@ -0,0 +1,175 @@\n+/* PR tree-optimization/91294 - wrong strlen result of a conditional with\n+   an offset\n+   { dg-do run }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define NOIPA __attribute__ ((noclone, noinline, noipa))\n+\n+#define CAT(a, b) a ## b\n+#define CONCAT(a, b) CAT (a, b)\n+#define UNIQ_NAME(name) CONCAT (name, __LINE__)\n+\n+extern int last_line;\n+int nfails;\n+\n+char buf[32];\n+\n+#define VERIFY(expr, nbytes, expect)\t\t\t\t\t\\\n+  NOIPA void UNIQ_NAME (test_)(void)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    memcpy (buf, (expr), (nbytes));\t\t\t\t\t\\\n+    const size_t len = strlen (buf);\t\t\t\t\t\\\n+    if (len != expect)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t++nfails;\t\t\t\t\t\t\t\\\n+\t__builtin_printf (\"line %i: strlen(%s) == %zu failed: \"\t\t\\\n+\t\t\t  \"got %zu\\n\",\t\t\t\t\t\\\n+\t\t\t  __LINE__ - 1000 + last_line + 2,\t\t\\\n+\t\t\t  #expr, (size_t)expect,\t\t\t\\\n+\t\t\t  len);\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } typedef void DummyType\n+\n+const char a8[12] = \"01234567\";\n+const char b8[12] = \"76543210\";\n+const char c4[12] = \"0123\";\n+\n+int i0, i1 = 1, i2 = 2;\n+\n+int last_line = __LINE__;\n+#line 1000\n+VERIFY (i0 ? (a8 + 0) : (b8 + 0), 9, 8);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 1), 8, 7);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 2), 8, 6);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 2), 7, 6);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 3), 8, 5);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 3), 7, 5);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 3), 6, 5);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 4), 8, 4);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 4), 7, 4);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 4), 6, 4);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 4), 5, 4);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 5), 7, 3);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 5), 6, 3);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 5), 5, 3);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 5), 4, 3);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 6), 3, 2);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 7), 2, 1);\n+VERIFY (i0 ? (a8 + 1) : (b8 + 0), 8, 8);\n+VERIFY (i0 ? (a8 + 2) : (b8 + 0), 7, 7);\n+VERIFY (i0 ? (a8 + 1) : (b8 + 1), 8, 7);\n+VERIFY (i0 ? (a8 + 1) : (b8 + 2), 7, 6);\n+VERIFY (i0 ? (a8 + 2) : (b8 + 1), 8, 7);   // FAIL\n+VERIFY (i0 ? (a8 + 2) : (b8 + 2), 7, 6);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 0), 9, 8);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 1), 8, 7);\n+VERIFY (i0 ? (a8 + 0) : (b8 + 2), 7, 6);\n+VERIFY (i0 ? (a8 + 1) : (b8 + 0), 9, 8);\n+VERIFY (i0 ? (a8 + 2) : (b8 + 0), 9, 8);\n+VERIFY (i0 ? (a8 + 1) : (b8 + 1), 8, 7);\n+VERIFY (i0 ? (a8 + 1) : (b8 + 2), 7, 6);\n+VERIFY (i0 ? (a8 + 2) : (b8 + 1), 8, 7);   // FAIL\n+VERIFY (i0 ? (a8 + 2) : (b8 + 2), 7, 6);\n+VERIFY (i0 ? (a8 + 0) : (c4 + 0), 9, 4);\n+VERIFY (i0 ? (a8 + 0) : (c4 + 1), 9, 3);\n+VERIFY (i0 ? (a8 + 0) : (c4 + 3), 9, 1);\n+VERIFY (i0 ? (a8 + 0) : (c4 + 4), 9, 0);\n+VERIFY (i0 ? (a8 + 1) : (c4 + 0), 8, 4);\n+VERIFY (i0 ? (a8 + 1) : (c4 + 1), 8, 3);\n+VERIFY (i0 ? (a8 + 1) : (c4 + 2), 8, 2);\n+VERIFY (i0 ? (a8 + 1) : (c4 + 3), 8, 1);\n+VERIFY (i0 ? (a8 + 1) : (c4 + 4), 8, 0);\n+VERIFY (i0 ? (a8 + 2) : (c4 + 0), 8, 4);\n+VERIFY (i0 ? (a8 + 2) : (c4 + 1), 8, 3);\n+VERIFY (i0 ? (a8 + 2) : (c4 + 2), 8, 2);\n+VERIFY (i0 ? (a8 + 2) : (c4 + 3), 8, 1);\n+VERIFY (i0 ? (a8 + 2) : (c4 + 4), 8, 0);\n+VERIFY ((i0 ? a8 : b8) + 1, 8, 7);\n+VERIFY ((i0 ? a8 : b8) + 2, 8, 6);\n+VERIFY ((i0 ? a8 : b8) + 2, 7, 6);\n+VERIFY ((i0 ? a8 : b8) + 3, 3, 3);\n+VERIFY ((i0 ? a8 : b8) + 3, 1, 1);\n+VERIFY ((i0 ? a8 : c4) + 1, 8, 3);\n+VERIFY ((i0 ? a8 : c4) + 3, 8, 1);\n+VERIFY ((i0 ? a8 : c4) + 4, 8, 0);\n+VERIFY ((i0 ? a8 + 1: b8 + 2) + 1, 9, 5);\n+VERIFY ((i0 ? a8 + i1: b8 + i2) + 1, 8, 5);\n+VERIFY ((i0 ? a8 + i1: b8 + 2) + 1, 8, 5);\n+VERIFY ((i0 ? a8 + i2: b8 + i1) + 1, 8, 6);\n+VERIFY ((i0 ? a8 + 2: b8 + i1) + 1, 8, 6);\n+\n+#define T(N) test_ ## N (); memset (buf, 0, sizeof buf)\n+\n+int main (void)\n+{\n+  T (1000);\n+  T (1001);\n+  T (1002);\n+  T (1003);\n+  T (1004);\n+  T (1005);\n+  T (1006);\n+  T (1007);\n+  T (1008);\n+  T (1009);\n+\n+  T (1010);\n+  T (1011);\n+  T (1012);\n+  T (1013);\n+  T (1014);\n+  T (1015);\n+  T (1016);\n+  T (1017);\n+  T (1018);\n+  T (1019);\n+\n+  T (1020);\n+  T (1021);\n+  T (1022);\n+  T (1023);\n+  T (1024);\n+  T (1025);\n+  T (1026);\n+  T (1027);\n+  T (1028);\n+  T (1029);\n+\n+  T (1030);\n+  T (1031);\n+  T (1032);\n+  T (1033);\n+  T (1034);\n+  T (1035);\n+  T (1036);\n+  T (1037);\n+  T (1038);\n+  T (1039);\n+\n+  T (1040);\n+  T (1041);\n+  T (1042);\n+  T (1043);\n+  T (1044);\n+  T (1045);\n+  T (1046);\n+  T (1047);\n+  T (1048);\n+  T (1049);\n+\n+  T (1050);\n+  T (1051);\n+  T (1052);\n+  T (1053);\n+  T (1054);\n+  T (1055);\n+  T (1056);\n+  T (1057);\n+  T (1058);\n+\n+  if (nfails)\n+    abort ();\n+}\n+"}, {"sha": "e57f0c4bcfb3cbff918c2c3c789730ab4b2dbb40", "filename": "gcc/testsuite/gcc.dg/strlenopt-75.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-75.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-75.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-75.c?ref=34fcf41e30ff56155e996f5e04f6ca13948a19b6", "patch": "@@ -0,0 +1,118 @@\n+/* PR tree-optimization/91294 - strlen result of a conditional with\n+   an offset\n+   { dg-do run }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define NOIPA __attribute__ ((noclone, noinline, noipa))\n+\n+int i = 0;\n+\n+const char s[] = \"1234567\";\n+\n+char a[32];\n+\n+/* Exercise a memcpy overwriting a destination string of known length\n+   with a source argument involving a conditional expression with strings\n+   of unqual lengths, with the selected one being the longer of the two\n+   and resulting in no change to the length of the overwritten destination\n+   string.  */\n+NOIPA void test_memcpy_same_length ()\n+{\n+  memcpy (a, \"123456789a\", 11);\n+  memcpy (a + 6, i ? \"78\\0\" : \"789\\0\", 4);\n+  if (strlen (a) != 9)\n+    abort ();\n+}\n+\n+/* Same as above but with strcpy/strcat.  */\n+\n+NOIPA void test_strcpy_strcat_same_length ()\n+{\n+  strcpy (a, \"12345678\");\n+  strcat (a, \"9a\");\n+  memcpy (a + 6, i ? \"78\\0\" : \"789\\0\", 4);\n+  if (strlen (a) != 9)\n+    abort ();\n+}\n+\n+/* Same as above but using a memcpy of a power-of-two size that gets\n+   (on some targets) transformed into a single MEM_REF assignment.  */\n+\n+NOIPA void test_assign_same_length ()\n+{\n+  memcpy (a, s, 8);\n+  memcpy (a + 5, i ? \"67\\0\" : \"678\\0\", 4);\n+  if (strlen (a) != 8)\n+    abort ();\n+}\n+\n+/* Same as above but resulting in increasing the length of the destination\n+   string.  */\n+\n+NOIPA void test_memcpy_lengthen ()\n+{\n+  memcpy (a, \"123456789a\", 11);\n+  memcpy (a + 8, i ? \"9a\\0\" : \"9ab\\0\", 4);\n+  if (strlen (a) != 11)\n+    abort ();\n+}\n+\n+NOIPA void test_strcpy_strcat_lengthen ()\n+{\n+  strcpy (a, \"12345678\");\n+  strcat (a, \"9a\");\n+  memcpy (a + 8, i ? \"9a\\0\" : \"9ab\\0\", 4);\n+  if (strlen (a) != 11)\n+    abort ();\n+}\n+\n+NOIPA void test_assign_lengthen ()\n+{\n+  memcpy (a, s, 8);\n+  memcpy (a + 6, i ? \"78\\0\" : \"789\\0\", 4);\n+  if (strlen (a) != 9)\n+    abort ();\n+}\n+\n+NOIPA void test_memcpy_shorten ()\n+{\n+  memcpy (a, \"123456789a\", 11);\n+  memcpy (a + 6, i ? \"789\\0\" : \"78\\0\", 4);\n+  if (strlen (a) != 8)\n+    abort ();\n+}\n+\n+NOIPA void test_strcpy_strcat_shorten ()\n+{\n+  strcpy (a, \"12345678\");\n+  strcat (a, \"9a\");\n+  memcpy (a + 6, i ? \"789\\0\" : \"78\\0\", 4);\n+  if (strlen (a) != 8)\n+    abort ();\n+}\n+\n+NOIPA void test_assign_shorten ()\n+{\n+  memcpy (a, s, 8);\n+  memcpy (a + 6, i ? \"789\\0\" : \"78\\0\", 4);\n+  if (strlen (a) != 8)\n+    abort ();\n+}\n+\n+\n+int main (void)\n+{\n+  test_memcpy_same_length ();\n+  test_strcpy_strcat_same_length ();\n+  test_assign_same_length ();\n+\n+  test_memcpy_lengthen ();\n+  test_strcpy_strcat_lengthen ();\n+  test_assign_lengthen ();\n+\n+  test_memcpy_shorten ();\n+  test_strcpy_strcat_shorten ();\n+  test_assign_shorten ();\n+}"}, {"sha": "30ccd166a1153b1917949ed5f9935015b315eab2", "filename": "gcc/testsuite/gcc.dg/strlenopt-76.c", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-76.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-76.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-76.c?ref=34fcf41e30ff56155e996f5e04f6ca13948a19b6", "patch": "@@ -0,0 +1,174 @@\n+/* PR tree-optimization/91294 - strlen result of a conditional with\n+   an offset\n+   { dg-do run }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define NOIPA __attribute__ ((noclone, noinline, noipa))\n+\n+#define assert(expr)\t\t\t\t\t\t\\\n+  ((expr)                                                       \\\n+   ? (void)0                                                    \\\n+   : (__builtin_printf (\"line %i %s: assertion failed: %s\\n\",\t\\\n+                        __LINE__, __func__, #expr),\t\t\\\n+      __builtin_abort ()))\n+\n+int i = 0;\n+\n+const char s[] = \"1234567\";\n+\n+char a[32];\n+\n+NOIPA void lower_bound_assign_into_empty (void)\n+{\n+  a[0] = '1';\n+  a[1] = '2';\n+  a[2] = '3';\n+  assert (strlen (a) == 3);\n+}\n+\n+NOIPA void lower_bound_assign_into_longest (void)\n+{\n+  a[0] = '1';\n+  a[1] = '2';\n+  a[2] = '3';\n+  assert (strlen (a) == 31);\n+}\n+\n+\n+NOIPA void lower_bound_assign_into_empty_idx_3 (int idx)\n+{\n+  a[0] = '1';\n+  a[1] = '2';\n+  a[2] = '3';\n+  a[idx] = 'x';\n+  assert (strlen (a) == 4);\n+}\n+\n+NOIPA void lower_bound_assign_into_longest_idx_2 (int idx)\n+{\n+  a[0] = '1';\n+  a[1] = '2';\n+  a[2] = '3';\n+  a[idx] = '\\0';\n+  assert (strlen (a) == 2);\n+}\n+\n+\n+NOIPA void lower_bound_memcpy_into_empty (void)\n+{\n+  memcpy (a, \"123\", 3);\n+  assert (strlen (a) == 3);\n+}\n+\n+NOIPA void lower_bound_memcpy_into_longest (void)\n+{\n+  memcpy (a, \"123\", 3);\n+  assert (strlen (a) == 31);\n+}\n+\n+\n+NOIPA void lower_bound_memcpy_memcpy_into_empty (void)\n+{\n+  memcpy (a, \"123\", 3);\n+  memcpy (a + 2, \"345\", 3);\n+  assert (strlen (a) == 5);\n+}\n+\n+NOIPA void lower_bound_memcpy_memcpy_into_longest (void)\n+{\n+  memcpy (a, \"123\", 3);\n+  memcpy (a + 2, \"345\", 3);\n+  assert (strlen (a) == 31);\n+}\n+\n+\n+NOIPA void memove_forward_strlen (void)\n+{\n+  char a[] = \"123456\";\n+\n+  memmove (a, a + 1, sizeof a - 1);\n+\n+  assert (strlen (a) == 5);\n+}\n+\n+NOIPA void memove_backward_into_empty_strlen (void)\n+{\n+  strcpy (a, \"123456\");\n+\n+  memmove (a + 1, a, 6);\n+\n+  assert (strlen (a) == 7);\n+}\n+\n+NOIPA void memove_backward_into_longest_strlen (void)\n+{\n+  memcpy (a, \"123456\", 6);\n+\n+  memmove (a + 1, a, 6);\n+\n+  assert (strlen (a) == 31);\n+}\n+\n+NOIPA void memove_strcmp (void)\n+{\n+  /* Test derived from libstdc++-v3's\n+     20_util/specialized_algorithms/memory_management_tools/1.cc  */\n+\n+  char a[] = \"123456\";\n+  char b[] = \"000000\";\n+\n+  memmove (b, a, sizeof a);\n+\n+  assert (strlen (a) == 6);\n+  assert (strlen (b) == 6);\n+  assert (strcmp (a, b) == 0);\n+}\n+\n+\n+int main (void)\n+{\n+  memset (a, '\\0', sizeof a);\n+  lower_bound_assign_into_empty ();\n+\n+  memset (a, 'x', sizeof a - 1);\n+  a[sizeof a - 1] = '\\0';\n+  lower_bound_assign_into_longest ();\n+\n+  memset (a, '\\0', sizeof a);\n+  lower_bound_assign_into_empty_idx_3 (3);\n+\n+  memset (a, 'x', sizeof a - 1);\n+  a[sizeof a - 1] = '\\0';\n+  lower_bound_assign_into_longest_idx_2 (2);\n+\n+  memset (a, '\\0', sizeof a);\n+  lower_bound_memcpy_into_empty ();\n+\n+  memset (a, 'x', sizeof a - 1);\n+  a[sizeof a - 1] = '\\0';\n+  lower_bound_memcpy_into_longest ();\n+\n+  memset (a, 'x', sizeof a - 1);\n+  a[sizeof a - 1] = '\\0';\n+  lower_bound_memcpy_into_longest ();\n+\n+  memset (a, '\\0', sizeof a);\n+  lower_bound_memcpy_memcpy_into_empty ();\n+\n+  memset (a, 'x', sizeof a - 1);\n+  a[sizeof a - 1] = '\\0';\n+  lower_bound_memcpy_memcpy_into_longest ();\n+\n+  memove_forward_strlen ();\n+\n+  memset (a, '\\0', sizeof a);\n+  memove_backward_into_empty_strlen ();\n+\n+  memset (a, 'x', sizeof a - 1);\n+  a[sizeof a - 1] = '\\0';\n+  memove_backward_into_longest_strlen ();\n+\n+  memove_strcmp ();\n+}"}, {"sha": "76cd11d6ac1ada089091c69878efb853e35a0ad3", "filename": "gcc/testsuite/gcc.dg/strlenopt-77.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-77.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-77.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-77.c?ref=34fcf41e30ff56155e996f5e04f6ca13948a19b6", "patch": "@@ -0,0 +1,84 @@\n+/* PR tree-optimization/91315 - missing strlen lower bound of a string\n+   known to be at least N characters\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define CAT(x, y) x ## y\n+#define CONCAT(x, y) CAT (x, y)\n+#define FAILNAME(name) CONCAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macro to emit a call to function named\n+     call_in_true_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ASSERT_ELIM(expr)\t\t\t\t\t\t\\\n+  if (!!(expr)) FAIL (in_true_branch_not_eliminated); else (void)0\n+\n+char a[32];\n+\n+void lower_bound_assign_1 (void)\n+{\n+  a[0] = '1';\n+  ASSERT_ELIM (strlen (a) < 1);\n+}\n+\n+void lower_bound_assign_2 (void)\n+{\n+  a[0] = '1';\n+  a[1] = '2';\n+  ASSERT_ELIM (strlen (a) < 2);\n+}\n+\n+void lower_bound_assign_3 (void)\n+{\n+  a[0] = '1';\n+  a[1] = '2';\n+  a[2] = '3';\n+  ASSERT_ELIM (strlen (a) < 3);\n+}\n+\n+void lower_bound_memcpy (void)\n+{\n+  memcpy (a, \"123\", 3);\n+  ASSERT_ELIM (strlen (a) < 3);\n+}\n+\n+void lower_bound_memcpy_memcpy_2 (void)\n+{\n+  memcpy (a, \"123\", 3);\n+  memcpy (a + 2, \"345\", 3);\n+  ASSERT_ELIM (strlen (a) < 5);\n+}\n+\n+void lower_bound_memcpy_memcpy_3 (void)\n+{\n+  memcpy (a, \"123\", 3);\n+  memcpy (a + 3, \"456\", 3);\n+  ASSERT_ELIM (strlen (a) < 6);\n+}\n+\n+/* FIXME: Not optimized yet.\n+void lower_bound_stpcpy_stpcpy_assign (void)\n+{\n+  *stpcpy (strcpy (a, \"123\"), \"4567\") = '8';\n+  ASSERT_ELIM (strlen (a) < 8);\n+}\n+*/\n+\n+void lower_bound_strcpy_strcat_assign (void)\n+{\n+  strcpy (a, \"123\");\n+  strcat (a, \"45\");\n+  a[5] = '6';\n+  ASSERT_ELIM (strlen (a) < 6);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated_\" 0 \"optimized\" } } */"}, {"sha": "ef2b6ae65f29709b2a1ce11ce868d8e903fb5cf4", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 117, "deletions": 77, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=34fcf41e30ff56155e996f5e04f6ca13948a19b6", "patch": "@@ -1195,14 +1195,13 @@ adjust_last_stmt (strinfo *si, gimple *stmt, bool is_strcat)\n    to constants.  */\n \n tree\n-set_strlen_range (tree lhs, wide_int max, tree bound /* = NULL_TREE */)\n+set_strlen_range (tree lhs, wide_int min, wide_int max,\n+\t\t  tree bound /* = NULL_TREE */)\n {\n   if (TREE_CODE (lhs) != SSA_NAME\n       || !INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n     return NULL_TREE;\n \n-  wide_int min = wi::zero (max.get_precision ());\n-\n   if (bound)\n     {\n       /* For strnlen, adjust MIN and MAX as necessary.  If the bound\n@@ -1312,7 +1311,8 @@ maybe_set_strlen_range (tree lhs, tree src, tree bound)\n \t}\n     }\n \n-  return set_strlen_range (lhs, max, bound);\n+  wide_int min = wi::zero (max.get_precision ());\n+  return set_strlen_range (lhs, min, max, bound);\n }\n \n /* Handle a strlen call.  If strlen of the argument is known, replace\n@@ -1434,6 +1434,12 @@ handle_builtin_strlen (gimple_stmt_iterator *gsi)\n \t\t  tree adj = fold_build2_loc (loc, MINUS_EXPR,\n \t\t\t\t\t      TREE_TYPE (lhs), lhs, old);\n \t\t  adjust_related_strinfos (loc, si, adj);\n+\t\t  /* Use the constant minimim length as the lower bound\n+\t\t     of the non-constant length.  */\n+\t\t  wide_int min = wi::to_wide (old);\n+\t\t  wide_int max\n+\t\t    = wi::to_wide (TYPE_MAX_VALUE (ptrdiff_type_node)) - 2;\n+\t\t  set_strlen_range (lhs, min, max);\n \t\t}\n \t      else\n \t\t{\n@@ -3386,9 +3392,51 @@ int ssa_name_limit_t::next_ssa_name (tree ssa_name)\n    on success and false otherwise.  */\n \n static bool\n-count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n+count_nonzero_bytes (tree exp, unsigned HOST_WIDE_INT offset,\n+\t\t     unsigned HOST_WIDE_INT nbytes,\n+\t\t     unsigned lenrange[3], bool *nulterm,\n \t\t     bool *allnul, bool *allnonnul, ssa_name_limit_t &snlim)\n {\n+  int idx = get_stridx (exp);\n+  if (idx > 0)\n+    {\n+      strinfo *si = get_strinfo (idx);\n+      /* FIXME: Handle non-constant lengths in some range.  */\n+      if (!si || !tree_fits_shwi_p (si->nonzero_chars))\n+\treturn false;\n+\n+      unsigned len = tree_to_shwi (si->nonzero_chars);\n+      unsigned size = len + si->full_string_p;\n+      if (size <= offset)\n+\treturn false;\n+\n+      len -= offset;\n+      size -= offset;\n+\n+      if (size < nbytes)\n+\treturn false;\n+\n+      if (len < lenrange[0])\n+\tlenrange[0] = len;\n+      if (lenrange[1] < len)\n+\tlenrange[1] = len;\n+\n+      if (!si->full_string_p)\n+\t*nulterm = false;\n+\n+      /* Since only the length of the string are known and\n+\t its contents, clear ALLNUL and ALLNONNUL purely on\n+\t the basis of the length.  */\n+      if (len)\n+\t*allnul = false;\n+      else\n+\t*allnonnul = false;\n+      return true;\n+    }\n+\n+  if (TREE_CODE (exp) == ADDR_EXPR)\n+    exp = TREE_OPERAND (exp, 0);\n+\n   if (TREE_CODE (exp) == SSA_NAME)\n     {\n       /* Handle a single-character specially.  */\n@@ -3401,7 +3449,8 @@ count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n \t     (even if its exact value is not known) and if so, recurse\n \t     once to set the range, etc.  */\n \t  if (tree_expr_nonzero_p (exp))\n-\t    return count_nonzero_bytes (build_int_cst (type, 1), lenrange,\n+\t    return count_nonzero_bytes (build_int_cst (type, 1),\n+\t\t\t\t\toffset, nbytes, lenrange,\n \t\t\t\t\tnulterm, allnul, allnonnul, snlim);\n \t  /* Don't know whether EXP is or isn't nonzero.  */\n \t  return false;\n@@ -3422,74 +3471,41 @@ count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n       for (unsigned i = 0; i != n; i++)\n \t{\n \t  tree def = gimple_phi_arg_def (stmt, i);\n-\t  if (!count_nonzero_bytes (def, lenrange, nulterm, allnul, allnonnul,\n-\t\t\t\t    snlim))\n+\t  if (!count_nonzero_bytes (def, offset, nbytes, lenrange, nulterm,\n+\t\t\t\t    allnul, allnonnul, snlim))\n \t    return false;\n \t}\n \n       return true;\n     }\n \n-  /* Offset from the beginning of the representation bytes, a pointer\n-     to the representation, and the number of bytes of the representation\n-     to consider (may be less than the object size for MEM_REF).  */\n-  unsigned HOST_WIDE_INT offset = 0;\n-  const char *prep = NULL;\n-  unsigned nbytes = 0;\n-\n   if (TREE_CODE (exp) == MEM_REF)\n     {\n-      /* If the MEM_REF operand is the address of an object such as\n-\t a string or integer, extract it and the offset into it.  */\n       tree arg = TREE_OPERAND (exp, 0);\n-      if (TREE_CODE (arg) != ADDR_EXPR)\n-\treturn false;\n-\n       tree off = TREE_OPERAND (exp, 1);\n+\n       if (TREE_CODE (off) != INTEGER_CST\n \t  || !tree_fits_uhwi_p (off))\n \treturn false;\n \n-      offset = tree_to_uhwi (off);\n+      unsigned HOST_WIDE_INT wioff = tree_to_uhwi (off);\n+      if (INT_MAX < wioff)\n+\treturn false;\n+\n+      offset += wioff;\n       if (INT_MAX < offset)\n \treturn false;\n \n       /* The size of the MEM_REF access determines the number of bytes.  */\n       tree type = TREE_TYPE (exp);\n       if (tree typesize = TYPE_SIZE_UNIT (type))\n \tnbytes = tree_to_uhwi (typesize);\n+      else\n+\treturn false;\n \n-      if (offset == 0 && TREE_CODE (exp) != STRING_CST)\n-\t{\n-\t  int idx = get_stridx (arg);\n-\t  if (idx > 0)\n-\t    {\n-\t      strinfo *si = get_strinfo (idx);\n-\t      if (si && tree_fits_shwi_p (si->nonzero_chars))\n-\t\t{\n-\t\t  unsigned len = tree_to_shwi (si->nonzero_chars);\n-\t\t  if (len < lenrange[0])\n-\t\t    lenrange[0] = len;\n-\t\t  if (lenrange[1] < len)\n-\t\t    lenrange[1] = len;\n-\n-\t\t  if (!si->full_string_p)\n-\t\t    *nulterm = false;\n-\n-\t\t  /* Since only the length of the string are known and\n-\t\t     its contents, clear ALLNUL and ALLNONNUL purely on\n-\t\t     the basis of the length.  */\n-\t\t  if (len)\n-\t\t    *allnul = false;\n-\t\t  else\n-\t\t    *allnonnul = false;\n-\t\t  return true;\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Proceed to extract the object representation below.  */\n-      exp = TREE_OPERAND (arg, 0);\n+      /* Handle MEM_REF = SSA_NAME types of assignments.  */\n+      return count_nonzero_bytes (arg, offset, nbytes, lenrange, nulterm,\n+\t\t\t\t  allnul, allnonnul, snlim);\n     }\n \n   if (TREE_CODE (exp) == VAR_DECL && TREE_READONLY (exp))\n@@ -3499,33 +3515,33 @@ count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n \treturn false;\n     }\n \n+  const char *prep = NULL;\n   if (TREE_CODE (exp) == STRING_CST)\n     {\n-      /* Set PREP and NBYTES to the string representation.  */\n-      gcc_assert (offset <= INT_MAX);\n+      unsigned nchars = TREE_STRING_LENGTH (exp);\n+      if (nchars < offset)\n+\treturn false;\n \n       if (!nbytes)\n-\t{\n-\t  /* Unless NBYTES has already been determined above from\n-\t     MEM_REF, set it here.  It includes all internal nuls,\n-\t     including the terminating one if the string has one.  */\n-\t  nbytes = TREE_STRING_LENGTH (exp);\n-\t  if (nbytes <= offset)\n-\t    return false;\n-\t}\n+\t/* If NBYTES hasn't been determined earlier from MEM_REF,\n+\t   set it here.  It includes all internal nuls, including\n+\t   the terminating one if the string has one.  */\n+\tnbytes = nchars - offset;\n \n       prep = TREE_STRING_POINTER (exp) + offset;\n     }\n \n   unsigned char buf[256];\n   if (!prep)\n     {\n-      /* Try to extract the representation of the constant object.  */\n-      nbytes = native_encode_expr (exp, buf, sizeof buf, -1);\n+      /* If the pointer to representation hasn't been set above\n+\t for STRING_CST point it at the buffer.  */\n+      prep = reinterpret_cast <char *>(buf);\n+      /* Try to extract the representation of the constant object\n+\t or expression starting from the offset.  */\n+      nbytes = native_encode_expr (exp, buf, sizeof buf, offset);\n       if (!nbytes)\n \treturn false;\n-\n-      prep = reinterpret_cast <char *>(buf);\n     }\n \n   /* Compute the number of leading nonzero bytes in the representation\n@@ -3591,7 +3607,8 @@ count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n   *allnonnul = true;\n \n   ssa_name_limit_t snlim;\n-  return count_nonzero_bytes (exp, lenrange, nulterm, allnul, allnonnul, snlim);\n+  return count_nonzero_bytes (exp, 0, 0, lenrange, nulterm, allnul, allnonnul,\n+\t\t\t      snlim);\n }\n \n /* Handle a single or multibyte store other than by a built-in function,\n@@ -3664,11 +3681,14 @@ handle_store (gimple_stmt_iterator *gsi)\n \n       if (tree dstsize = compute_objsize (lhs, 1))\n \tif (compare_tree_int (dstsize, lenrange[2]) < 0)\n-\t  warning_n (gimple_location (stmt), OPT_Wstringop_overflow_,\n-\t\t     lenrange[2],\n-\t\t     \"%Gwriting %u byte into a region of size %E\",\n-\t\t     \"%Gwriting %u bytes into a region of size %E\",\n-\t\t     stmt, lenrange[2], dstsize);\n+\t  {\n+\t    location_t loc = gimple_nonartificial_location (stmt);\n+\t    warning_n (loc, OPT_Wstringop_overflow_,\n+\t\t       lenrange[2],\n+\t\t       \"%Gwriting %u byte into a region of size %E\",\n+\t\t       \"%Gwriting %u bytes into a region of size %E\",\n+\t\t       stmt, lenrange[2], dstsize);\n+\t  }\n     }\n   else\n     {\n@@ -3795,7 +3815,14 @@ handle_store (gimple_stmt_iterator *gsi)\n \t    }\n \t  else\n \t    si->nonzero_chars = build_int_cst (size_type_node, offset);\n-\t  si->full_string_p = full_string_p;\n+\n+\t  /* Set FULL_STRING_P only if the length of the strings being\n+\t     written is the same, and clear it if the strings have\n+\t     different lengths.  In the latter case the length stored\n+\t     in si->NONZERO_CHARS becomes the lower bound.\n+\t     FIXME: Handle the upper bound of the length if possible.  */\n+\t  si->full_string_p = full_string_p && lenrange[0] == lenrange[1];\n+\n \t  if (storing_all_zeros_p\n \t      && ssaname\n \t      && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ssaname))\n@@ -3825,10 +3852,23 @@ handle_store (gimple_stmt_iterator *gsi)\n       if (idx != 0)\n \t{\n \t  tree ptr = (ssaname ? ssaname : build_fold_addr_expr (lhs));\n-\t  HOST_WIDE_INT slen = (storing_all_zeros_p\n-\t\t\t\t? 0\n-\t\t\t\t: (storing_nonzero_p\n-\t\t\t\t   && ranges_valid ? lenrange[0] : -1));\n+\n+\t  HOST_WIDE_INT slen;\n+\t  if (storing_all_zeros_p)\n+\t    slen = 0;\n+\t  else if (storing_nonzero_p && ranges_valid)\n+\t    {\n+\t      /* FIXME: Handle the upper bound of the length when\n+\t\t LENRANGE[0] != LENRANGE[1].  */\n+\t      slen = lenrange[0];\n+\t      if (lenrange[0] != lenrange[1])\n+\t\t/* Set the minimum length but ignore the maximum\n+\t\t   for now.  */\n+\t\tfull_string_p = false;\n+\t    }\n+\t  else\n+\t    slen = -1;\n+\n \t  tree len = (slen <= 0\n \t\t      ? size_zero_node\n \t\t      : build_int_cst (size_type_node, slen));"}, {"sha": "395c74e88e10e0f4d725935680c234d975cb0d93", "filename": "gcc/tree-ssa-strlen.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftree-ssa-strlen.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34fcf41e30ff56155e996f5e04f6ca13948a19b6/gcc%2Ftree-ssa-strlen.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.h?ref=34fcf41e30ff56155e996f5e04f6ca13948a19b6", "patch": "@@ -23,6 +23,6 @@\n \n extern bool is_strlen_related_p (tree, tree);\n extern bool maybe_diag_stxncpy_trunc (gimple_stmt_iterator, tree, tree);\n-extern tree set_strlen_range (tree, wide_int, tree = NULL_TREE);\n+extern tree set_strlen_range (tree, wide_int, wide_int, tree = NULL_TREE);\n \n #endif   // GCC_TREE_SSA_STRLEN_H"}]}