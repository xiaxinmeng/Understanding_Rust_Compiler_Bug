{"sha": "b690cc0f331d0f63e2de4f0aa2e3883444cfead2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY5MGNjMGYzMzFkMGY2M2UyZGU0ZjBhYTJlMzg4MzQ0NGNmZWFkMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-04-09T10:40:14Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-04-09T10:40:14Z"}, "message": "tree-vectorizer.h (struct _stmt_vec_info): Document that vectype is the type of the LHS.\n\n2010-04-09  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (struct _stmt_vec_info): Document\n\tthat vectype is the type of the LHS.\n\t(supportable_widening_operation, supportable_narrowing_operation): \n\tGet both input and output vector types as arguments.\n\t(vect_is_simple_use_1): Declare.\n\t(get_same_sized_vectype): Likewise.\n\t* tree-vect-loop.c (vect_determine_vectorization_factor):\n\tSet STMT_VINFO_VECTYPE to the vector type of the def.\n\t(vectorizable_reduction): Adjust.\n\t* tree-vect-patterns.c (vect_recog_widen_mult_pattern):\n\tAdjust.  Specify the output vector type.\n\t(vect_pattern_recog_1): Adjust.\n\t* tree-vect-stmts.c (get_same_sized_vectype): New function.\n\t(vectorizable_call): Adjust.\n\t(vectorizable_conversion): Likewise.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_type_demotion): Likewise.\n\t(vectorizable_type_promotion): Likewise.\n\t(vect_analyze_stmt): Set STMT_VINFO_VECTYPE to the vector type of\n\tthe def.\n\t(vect_is_simple_use_1): New function.\n\t(supportable_widening_operation): Get both input and output\n\tvector types.\n\t(supportable_narrowing_operation): Likewise.\n\t* tree-vect-slp.c (vect_schedule_slp_instance): Adjust.\n\nFrom-SVN: r158157", "tree": {"sha": "d8ea3d9ce37b8e002c9ace43434d9d7c2b6fca9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8ea3d9ce37b8e002c9ace43434d9d7c2b6fca9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b690cc0f331d0f63e2de4f0aa2e3883444cfead2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b690cc0f331d0f63e2de4f0aa2e3883444cfead2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b690cc0f331d0f63e2de4f0aa2e3883444cfead2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b690cc0f331d0f63e2de4f0aa2e3883444cfead2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ced572837c918c138eee3e901d4b11a9996d7f07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ced572837c918c138eee3e901d4b11a9996d7f07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ced572837c918c138eee3e901d4b11a9996d7f07"}], "stats": {"total": 505, "additions": 317, "deletions": 188}, "files": [{"sha": "bdf0c5839ecd176d4b0b44a140bea6d274014c33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b690cc0f331d0f63e2de4f0aa2e3883444cfead2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b690cc0f331d0f63e2de4f0aa2e3883444cfead2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b690cc0f331d0f63e2de4f0aa2e3883444cfead2", "patch": "@@ -1,3 +1,31 @@\n+2010-04-09  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (struct _stmt_vec_info): Document\n+\tthat vectype is the type of the LHS.\n+\t(supportable_widening_operation, supportable_narrowing_operation): \n+\tGet both input and output vector types as arguments.\n+\t(vect_is_simple_use_1): Declare.\n+\t(get_same_sized_vectype): Likewise.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor):\n+\tSet STMT_VINFO_VECTYPE to the vector type of the def.\n+\t(vectorizable_reduction): Adjust.\n+\t* tree-vect-patterns.c (vect_recog_widen_mult_pattern):\n+\tAdjust.  Specify the output vector type.\n+\t(vect_pattern_recog_1): Adjust.\n+\t* tree-vect-stmts.c (get_same_sized_vectype): New function.\n+\t(vectorizable_call): Adjust.\n+\t(vectorizable_conversion): Likewise.\n+\t(vectorizable_operation): Likewise.\n+\t(vectorizable_type_demotion): Likewise.\n+\t(vectorizable_type_promotion): Likewise.\n+\t(vect_analyze_stmt): Set STMT_VINFO_VECTYPE to the vector type of\n+\tthe def.\n+\t(vect_is_simple_use_1): New function.\n+\t(supportable_widening_operation): Get both input and output\n+\tvector types.\n+\t(supportable_narrowing_operation): Likewise.\n+\t* tree-vect-slp.c (vect_schedule_slp_instance): Adjust.\n+\n 2010-04-09  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* config/i386/cygming.h (TARGET_OS_CPP_BUILTINS): Add"}, {"sha": "c654795734143221964110d460d9056c72a8269b", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 69, "deletions": 36, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b690cc0f331d0f63e2de4f0aa2e3883444cfead2/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b690cc0f331d0f63e2de4f0aa2e3883444cfead2/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b690cc0f331d0f63e2de4f0aa2e3883444cfead2", "patch": "@@ -240,6 +240,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n         {\n+\t  tree vf_vectype;\n \t  gimple stmt = gsi_stmt (si);\n \t  stmt_info = vinfo_for_stmt (stmt);\n \n@@ -294,14 +295,12 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      gcc_assert (!STMT_VINFO_DATA_REF (stmt_info)\n \t\t\t  && !is_pattern_stmt_p (stmt_info));\n \n-\t      scalar_type = vect_get_smallest_scalar_type (stmt, &dummy,\n-                                                           &dummy);\n+\t      scalar_type = TREE_TYPE (gimple_get_lhs (stmt));\n \t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\t{\n \t\t  fprintf (vect_dump, \"get vectype for scalar type:  \");\n \t\t  print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n \t\t}\n-\n \t      vectype = get_vectype_for_scalar_type (scalar_type);\n \t      if (!vectype)\n \t\t{\n@@ -313,23 +312,60 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t\t    }\n \t\t  return false;\n \t\t}\n+\n \t      STMT_VINFO_VECTYPE (stmt_info) = vectype;\n             }\n \n+\t  /* The vectorization factor is according to the smallest\n+\t     scalar type (or the largest vector size, but we only\n+\t     support one vector size per loop).  */\n+\t  scalar_type = vect_get_smallest_scalar_type (stmt, &dummy,\n+\t\t\t\t\t\t       &dummy);\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    {\n+\t      fprintf (vect_dump, \"get vectype for scalar type:  \");\n+\t      print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+\t    }\n+\t  vf_vectype = get_vectype_for_scalar_type (scalar_type);\n+\t  if (!vf_vectype)\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+\t\t{\n+\t\t  fprintf (vect_dump,\n+\t\t\t   \"not vectorized: unsupported data-type \");\n+\t\t  print_generic_expr (vect_dump, scalar_type, TDF_SLIM);\n+\t\t}\n+\t      return false;\n+\t    }\n+\n+\t  if ((GET_MODE_SIZE (TYPE_MODE (vectype))\n+\t       != GET_MODE_SIZE (TYPE_MODE (vf_vectype))))\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+\t\t{\n+\t\t  fprintf (vect_dump,\n+\t\t\t   \"not vectorized: different sized vector \"\n+\t\t\t   \"types in statement, \");\n+\t\t  print_generic_expr (vect_dump, vectype, TDF_SLIM);\n+\t\t  fprintf (vect_dump, \" and \");\n+\t\t  print_generic_expr (vect_dump, vf_vectype, TDF_SLIM);\n+\t\t}\n+\t      return false;\n+\t    }\n+\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    {\n \t      fprintf (vect_dump, \"vectype: \");\n-\t      print_generic_expr (vect_dump, vectype, TDF_SLIM);\n+\t      print_generic_expr (vect_dump, vf_vectype, TDF_SLIM);\n \t    }\n \n-\t  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+\t  nunits = TYPE_VECTOR_SUBPARTS (vf_vectype);\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"nunits = %d\", nunits);\n \n \t  if (!vectorization_factor\n \t      || (nunits > vectorization_factor))\n \t    vectorization_factor = nunits;\n-\n         }\n     }\n \n@@ -3446,7 +3482,8 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   tree scalar_dest;\n   tree loop_vec_def0 = NULL_TREE, loop_vec_def1 = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  tree vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n+  tree vectype_in = NULL_TREE;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   enum tree_code code, orig_code, epilog_reduc_code;\n@@ -3464,8 +3501,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   stmt_vec_info orig_stmt_info;\n   tree expr = NULL_TREE;\n   int i;\n-  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+  int ncopies;\n   int epilog_copies;\n   stmt_vec_info prev_stmt_info, prev_phi_info;\n   gimple first_phi = NULL;\n@@ -3491,8 +3527,6 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       nested_cycle = true;\n     }\n \n-  gcc_assert (ncopies >= 1);\n-\n   /* FORNOW: SLP not supported.  */\n   if (STMT_SLP_TYPE (stmt_info))\n     return false;\n@@ -3579,12 +3613,16 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n      reduction variable.  */\n   for (i = 0; i < op_type-1; i++)\n     {\n+      tree tem;\n+\n       /* The condition of COND_EXPR is checked in vectorizable_condition().  */\n       if (i == 0 && code == COND_EXPR)\n         continue;\n \n-      is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, NULL, &def_stmt,\n-\t\t\t\t\t  &def, &dt);\n+      is_simple_use = vect_is_simple_use_1 (ops[i], loop_vinfo, NULL,\n+\t\t\t\t\t    &def_stmt, &def, &dt, &tem);\n+      if (!vectype_in)\n+\tvectype_in = tem;\n       gcc_assert (is_simple_use);\n       if (dt != vect_internal_def\n \t  && dt != vect_external_def\n@@ -3602,7 +3640,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n     }\n \n   is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, NULL, &def_stmt,\n-                                      &def, &dt);\n+\t\t\t\t      &def, &dt);\n   gcc_assert (is_simple_use);\n   gcc_assert (dt == vect_reduction_def\n               || dt == vect_nested_cycle\n@@ -3625,7 +3663,12 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   if (STMT_VINFO_LIVE_P (vinfo_for_stmt (reduc_def_stmt)))\n     return false;\n \n-  vec_mode = TYPE_MODE (vectype);\n+\n+  ncopies = (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t     / TYPE_VECTOR_SUBPARTS (vectype_in));\n+  gcc_assert (ncopies >= 1);\n+\n+  vec_mode = TYPE_MODE (vectype_in);\n \n   if (code == COND_EXPR)\n     {\n@@ -3642,7 +3685,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       /* 4. Supportable by target?  */\n \n       /* 4.1. check support for the operation in the loop  */\n-      optab = optab_for_tree_code (code, vectype, optab_default);\n+      optab = optab_for_tree_code (code, vectype_in, optab_default);\n       if (!optab)\n         {\n           if (vect_print_dump_info (REPORT_DETAILS))\n@@ -3666,7 +3709,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n         }\n \n       /* Worthwhile without SIMD support?  */\n-      if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n+      if (!VECTOR_MODE_P (TYPE_MODE (vectype_in))\n           && LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n    \t     < vect_min_worthwhile_factor (code))\n         {\n@@ -3716,18 +3759,8 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       /* This is a reduction pattern: get the vectype from the type of the\n          reduction variable, and get the tree-code from orig_stmt.  */\n       orig_code = gimple_assign_rhs_code (orig_stmt);\n-      vectype = get_vectype_for_scalar_type (TREE_TYPE (def));\n-      if (!vectype)\n-\t{\n-          if (vect_print_dump_info (REPORT_DETAILS))\n-            {\n-              fprintf (vect_dump, \"unsupported data-type \");\n-              print_generic_expr (vect_dump, TREE_TYPE (def), TDF_SLIM);\n-            }\n-          return false;\n-        }\n-\n-      vec_mode = TYPE_MODE (vectype);\n+      gcc_assert (vectype_out);\n+      vec_mode = TYPE_MODE (vectype_out);\n     }\n   else\n     {\n@@ -3755,7 +3788,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   epilog_reduc_code = ERROR_MARK;\n   if (reduction_code_for_scalar_code (orig_code, &epilog_reduc_code))\n     {\n-      reduc_optab = optab_for_tree_code (epilog_reduc_code, vectype,\n+      reduc_optab = optab_for_tree_code (epilog_reduc_code, vectype_out,\n                                          optab_default);\n       if (!reduc_optab)\n         {\n@@ -3812,7 +3845,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n     gcc_assert (ncopies == 1);\n \n   /* Create the destination vector  */\n-  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+  vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n \n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n@@ -3910,22 +3943,22 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       if (op_type == binary_op)\n         {\n           if (reduc_index == 0)\n-            expr = build2 (code, vectype, reduc_def, loop_vec_def0);\n+            expr = build2 (code, vectype_out, reduc_def, loop_vec_def0);\n           else\n-            expr = build2 (code, vectype, loop_vec_def0, reduc_def);\n+            expr = build2 (code, vectype_out, loop_vec_def0, reduc_def);\n         }\n       else\n         {\n           if (reduc_index == 0)\n-            expr = build3 (code, vectype, reduc_def, loop_vec_def0,\n+            expr = build3 (code, vectype_out, reduc_def, loop_vec_def0,\n                            loop_vec_def1);\n           else\n             {\n               if (reduc_index == 1)\n-                expr = build3 (code, vectype, loop_vec_def0, reduc_def,\n+                expr = build3 (code, vectype_out, loop_vec_def0, reduc_def,\n                                loop_vec_def1);\n               else\n-                expr = build3 (code, vectype, loop_vec_def0, loop_vec_def1,\n+                expr = build3 (code, vectype_out, loop_vec_def0, loop_vec_def1,\n \t     \t               reduc_def);\n             }\n         }"}, {"sha": "55b9d50cca03fb07c884c96a74b0bc7a51ce399d", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b690cc0f331d0f63e2de4f0aa2e3883444cfead2/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b690cc0f331d0f63e2de4f0aa2e3883444cfead2/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=b690cc0f331d0f63e2de4f0aa2e3883444cfead2", "patch": "@@ -362,7 +362,7 @@ vect_recog_widen_mult_pattern (gimple last_stmt,\n   tree oprnd0, oprnd1;\n   tree type, half_type0, half_type1;\n   gimple pattern_stmt;\n-  tree vectype;\n+  tree vectype, vectype_out;\n   tree dummy;\n   tree var;\n   enum tree_code dummy_code;\n@@ -405,14 +405,16 @@ vect_recog_widen_mult_pattern (gimple last_stmt,\n \n   /* Check target support  */\n   vectype = get_vectype_for_scalar_type (half_type0);\n+  vectype_out = get_vectype_for_scalar_type (type);\n   if (!vectype\n-      || !supportable_widening_operation (WIDEN_MULT_EXPR, last_stmt, vectype,\n+      || !supportable_widening_operation (WIDEN_MULT_EXPR, last_stmt,\n+\t\t\t\t\t  vectype_out, vectype,\n \t\t\t\t\t  &dummy, &dummy, &dummy_code,\n \t\t\t\t\t  &dummy_code, &dummy_int, &dummy_vec))\n     return NULL;\n \n   *type_in = vectype;\n-  *type_out = NULL_TREE;\n+  *type_out = vectype_out;\n \n   /* Pattern supported. Create a stmt to be used to replace the pattern: */\n   var = vect_recog_temp_ssa_var (type, NULL);\n@@ -677,7 +679,9 @@ vect_pattern_recog_1 (\n     {\n       /* No need to check target support (already checked by the pattern\n          recognition function).  */\n-      pattern_vectype = type_in;\n+      if (type_out)\n+\tgcc_assert (VECTOR_MODE_P (TYPE_MODE (type_out)));\n+      pattern_vectype = type_out ? type_out : type_in;\n     }\n   else\n     {\n@@ -686,9 +690,14 @@ vect_pattern_recog_1 (\n       optab optab;\n \n       /* Check target support  */\n-      pattern_vectype = get_vectype_for_scalar_type (type_in);\n-      if (!pattern_vectype)\n-        return;\n+      type_in = get_vectype_for_scalar_type (type_in);\n+      if (!type_in)\n+\treturn;\n+      if (type_out)\n+\ttype_out = get_vectype_for_scalar_type (type_out);\n+      else\n+\ttype_out = type_in;\n+      pattern_vectype = type_out;\n \n       if (is_gimple_assign (pattern_stmt))\n \tcode = gimple_assign_rhs_code (pattern_stmt);\n@@ -698,15 +707,12 @@ vect_pattern_recog_1 (\n \t  code = CALL_EXPR;\n \t}\n \n-      optab = optab_for_tree_code (code, pattern_vectype, optab_default);\n-      vec_mode = TYPE_MODE (pattern_vectype);\n+      optab = optab_for_tree_code (code, type_in, optab_default);\n+      vec_mode = TYPE_MODE (type_in);\n       if (!optab\n           || (icode = optab_handler (optab, vec_mode)->insn_code) ==\n               CODE_FOR_nothing\n-          || (type_out\n-              && (!get_vectype_for_scalar_type (type_out)\n-                  || (insn_data[icode].operand[0].mode !=\n-                      TYPE_MODE (get_vectype_for_scalar_type (type_out))))))\n+          || (insn_data[icode].operand[0].mode != TYPE_MODE (type_out)))\n \treturn;\n     }\n "}, {"sha": "0e4f6ce61513ff895949bec2eea68da555562ba9", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b690cc0f331d0f63e2de4f0aa2e3883444cfead2/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b690cc0f331d0f63e2de4f0aa2e3883444cfead2/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=b690cc0f331d0f63e2de4f0aa2e3883444cfead2", "patch": "@@ -1971,7 +1971,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n   stmt_info = vinfo_for_stmt (stmt);\n \n   /* VECTYPE is the type of the destination.  */\n-  vectype = get_vectype_for_scalar_type (TREE_TYPE (gimple_assign_lhs (stmt)));\n+  vectype = STMT_VINFO_VECTYPE (stmt_info);\n   nunits = (unsigned int) TYPE_VECTOR_SUBPARTS (vectype);\n   group_size = SLP_INSTANCE_GROUP_SIZE (instance);\n "}, {"sha": "26b9ca205209030e4c5a7cf649031c0a98c3465e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 192, "deletions": 133, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b690cc0f331d0f63e2de4f0aa2e3883444cfead2/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b690cc0f331d0f63e2de4f0aa2e3883444cfead2/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=b690cc0f331d0f63e2de4f0aa2e3883444cfead2", "patch": "@@ -1223,7 +1223,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n   int nunits_in;\n   int nunits_out;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  tree fndecl, new_temp, def, rhs_type, lhs_type;\n+  tree fndecl, new_temp, def, rhs_type;\n   gimple def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   gimple new_stmt = NULL;\n@@ -1252,8 +1252,11 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n   if (TREE_CODE (gimple_call_lhs (stmt)) != SSA_NAME)\n     return false;\n \n+  vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n+\n   /* Process function arguments.  */\n   rhs_type = NULL_TREE;\n+  vectype_in = NULL_TREE;\n   nargs = gimple_call_num_args (stmt);\n \n   /* Bail out if the function has more than two arguments, we\n@@ -1264,6 +1267,8 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n \n   for (i = 0; i < nargs; i++)\n     {\n+      tree opvectype;\n+\n       op = gimple_call_arg (stmt, i);\n \n       /* We can only handle calls with arguments of the same type.  */\n@@ -1274,28 +1279,35 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt)\n \t    fprintf (vect_dump, \"argument types differ.\");\n \t  return false;\n \t}\n-      rhs_type = TREE_TYPE (op);\n+      if (!rhs_type)\n+\trhs_type = TREE_TYPE (op);\n \n-      if (!vect_is_simple_use (op, loop_vinfo, NULL, &def_stmt, &def, &dt[i]))\n+      if (!vect_is_simple_use_1 (op, loop_vinfo, NULL,\n+\t\t\t\t &def_stmt, &def, &dt[i], &opvectype))\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"use not simple.\");\n \t  return false;\n \t}\n-    }\n \n-  vectype_in = get_vectype_for_scalar_type (rhs_type);\n+      if (!vectype_in)\n+\tvectype_in = opvectype;\n+      else if (opvectype\n+\t       && opvectype != vectype_in)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"argument vector types differ.\");\n+\t  return false;\n+\t}\n+    }\n+  /* If all arguments are external or constant defs use a vector type with\n+     the same size as the output vector type.  */\n   if (!vectype_in)\n-    return false;\n-  nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n-\n-  lhs_type = TREE_TYPE (gimple_call_lhs (stmt));\n-  vectype_out = get_vectype_for_scalar_type (lhs_type);\n-  if (!vectype_out)\n-    return false;\n-  nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n+    vectype_in = get_same_sized_vectype (rhs_type, vectype_out);\n \n   /* FORNOW */\n+  nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n+  nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n   if (nunits_in == nunits_out / 2)\n     modifier = NARROW;\n   else if (nunits_out == nunits_in)\n@@ -1546,7 +1558,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n   int nunits_out;\n   tree vectype_out, vectype_in;\n   int ncopies, j;\n-  tree rhs_type, lhs_type;\n+  tree rhs_type;\n   tree builtin_decl;\n   enum { NARROW, NONE, WIDEN } modifier;\n   int i;\n@@ -1578,21 +1590,27 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   /* Check types of lhs and rhs.  */\n+  scalar_dest = gimple_assign_lhs (stmt);\n+  vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n+\n   op0 = gimple_assign_rhs1 (stmt);\n   rhs_type = TREE_TYPE (op0);\n-  vectype_in = get_vectype_for_scalar_type (rhs_type);\n+  /* Check the operands of the operation.  */\n+  if (!vect_is_simple_use_1 (op0, loop_vinfo, NULL,\n+\t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"use not simple.\");\n+      return false;\n+    }\n+  /* If op0 is an external or constant defs use a vector type of\n+     the same size as the output vector type.  */\n   if (!vectype_in)\n-    return false;\n-  nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n-\n-  scalar_dest = gimple_assign_lhs (stmt);\n-  lhs_type = TREE_TYPE (scalar_dest);\n-  vectype_out = get_vectype_for_scalar_type (lhs_type);\n-  if (!vectype_out)\n-    return false;\n-  nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n+    vectype_in = get_same_sized_vectype (rhs_type, vectype_out);\n \n   /* FORNOW */\n+  nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n+  nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n   if (nunits_in == nunits_out / 2)\n     modifier = NARROW;\n   else if (nunits_out == nunits_in)\n@@ -1602,14 +1620,6 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n   else\n     return false;\n \n-  if (modifier == NONE)\n-    gcc_assert (STMT_VINFO_VECTYPE (stmt_info) == vectype_out);\n-\n-  /* Bail out if the types are both integral or non-integral.  */\n-  if ((INTEGRAL_TYPE_P (rhs_type) && INTEGRAL_TYPE_P (lhs_type))\n-      || (!INTEGRAL_TYPE_P (rhs_type) && !INTEGRAL_TYPE_P (lhs_type)))\n-    return false;\n-\n   integral_type = INTEGRAL_TYPE_P (rhs_type) ? vectype_in : vectype_out;\n \n   if (modifier == NARROW)\n@@ -1626,24 +1636,17 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n      needs to be generated.  */\n   gcc_assert (ncopies >= 1);\n \n-  /* Check the operands of the operation.  */\n-  if (!vect_is_simple_use (op0, loop_vinfo, NULL, &def_stmt, &def, &dt[0]))\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"use not simple.\");\n-      return false;\n-    }\n-\n   /* Supportable by target?  */\n   if ((modifier == NONE\n        && !targetm.vectorize.builtin_conversion (code, integral_type))\n       || (modifier == WIDEN\n-\t  && !supportable_widening_operation (code, stmt, vectype_in,\n+\t  && !supportable_widening_operation (code, stmt,\n+\t\t\t\t\t      vectype_out, vectype_in,\n \t\t\t\t\t      &decl1, &decl2,\n \t\t\t\t\t      &code1, &code2,\n                                               &dummy_int, &dummy))\n       || (modifier == NARROW\n-\t  && !supportable_narrowing_operation (code, stmt, vectype_in,\n+\t  && !supportable_narrowing_operation (code, vectype_out, vectype_in,\n \t\t\t\t\t       &code1, &dummy_int, &dummy)))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -1653,7 +1656,6 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \n   if (modifier != NONE)\n     {\n-      STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n       /* FORNOW: SLP not supported.  */\n       if (STMT_SLP_TYPE (stmt_info))\n \treturn false;\n@@ -1719,8 +1721,6 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t  else\n \t    vec_oprnd0 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n \n-\t  STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n-\n \t  /* Generate first half of the widened result:  */\n \t  new_stmt\n \t    = vect_gen_widened_results_half (code1, decl1,\n@@ -1918,7 +1918,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   tree op0, op1 = NULL;\n   tree vec_oprnd1 = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  tree vectype;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   enum tree_code code;\n   enum machine_mode vec_mode;\n@@ -1932,7 +1932,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n   gimple new_stmt = NULL;\n   stmt_vec_info prev_stmt_info;\n-  int nunits_in = TYPE_VECTOR_SUBPARTS (vectype);\n+  int nunits_in;\n   int nunits_out;\n   tree vectype_out;\n   int ncopies;\n@@ -1944,21 +1944,6 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   int vf;\n \n-  if (loop_vinfo)\n-    vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  else\n-    vf = 1;\n-\n-  /* Multiple types in SLP are handled by creating the appropriate number of\n-     vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n-     case of SLP.  */\n-  if (slp_node)\n-    ncopies = 1;\n-  else\n-    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n-\n-  gcc_assert (ncopies >= 1);\n-\n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n \n@@ -1972,14 +1957,6 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   if (TREE_CODE (gimple_assign_lhs (stmt)) != SSA_NAME)\n     return false;\n \n-  scalar_dest = gimple_assign_lhs (stmt);\n-  vectype_out = get_vectype_for_scalar_type (TREE_TYPE (scalar_dest));\n-  if (!vectype_out)\n-    return false;\n-  nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n-  if (nunits_out != nunits_in)\n-    return false;\n-\n   code = gimple_assign_rhs_code (stmt);\n \n   /* For pointer addition, we should use the normal plus for\n@@ -1996,13 +1973,27 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       return false;\n     }\n \n+  scalar_dest = gimple_assign_lhs (stmt);\n+  vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n+\n   op0 = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use (op0, loop_vinfo, bb_vinfo, &def_stmt, &def, &dt[0]))\n+  if (!vect_is_simple_use_1 (op0, loop_vinfo, bb_vinfo,\n+\t\t\t     &def_stmt, &def, &dt[0], &vectype))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"use not simple.\");\n       return false;\n     }\n+  /* If op0 is an external or constant def use a vector type with\n+     the same size as the output vector type.  */\n+  if (!vectype)\n+    vectype = get_same_sized_vectype (TREE_TYPE (op0), vectype_out);\n+  gcc_assert (vectype);\n+\n+  nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n+  nunits_in = TYPE_VECTOR_SUBPARTS (vectype);\n+  if (nunits_out != nunits_in)\n+    return false;\n \n   if (op_type == binary_op)\n     {\n@@ -2016,6 +2007,21 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t}\n     }\n \n+  if (loop_vinfo)\n+    vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  else\n+    vf = 1;\n+\n+  /* Multiple types in SLP are handled by creating the appropriate number of\n+     vectorized stmts for each SLP node. Hence, NCOPIES is always 1 in\n+     case of SLP.  */\n+  if (slp_node)\n+    ncopies = 1;\n+  else\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n+\n+  gcc_assert (ncopies >= 1);\n+\n   /* If this is a shift/rotate, determine whether the shift amount is a vector,\n      or scalar.  If the shift/rotate amount is a vector, use the vector/vector\n      shift optabs.  */\n@@ -2423,16 +2429,32 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!CONVERT_EXPR_CODE_P (code))\n     return false;\n \n+  scalar_dest = gimple_assign_lhs (stmt);\n+  vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n+\n+  /* Check the operands of the operation.  */\n   op0 = gimple_assign_rhs1 (stmt);\n-  vectype_in = get_vectype_for_scalar_type (TREE_TYPE (op0));\n+  if (! ((INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n+\t || (SCALAR_FLOAT_TYPE_P (TREE_TYPE (scalar_dest))\n+\t     && SCALAR_FLOAT_TYPE_P (TREE_TYPE (op0))\n+\t     && CONVERT_EXPR_CODE_P (code))))\n+    return false;\n+  if (!vect_is_simple_use_1 (op0, loop_vinfo, NULL,\n+\t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"use not simple.\");\n+      return false;\n+    }\n+  /* If op0 is an external def use a vector type with the\n+     same size as the output vector type if possible.  */\n+  if (!vectype_in)\n+    vectype_in = get_same_sized_vectype (TREE_TYPE (op0), vectype_out);\n   if (!vectype_in)\n     return false;\n-  nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n \n-  scalar_dest = gimple_assign_lhs (stmt);\n-  vectype_out = get_vectype_for_scalar_type (TREE_TYPE (scalar_dest));\n-  if (!vectype_out)\n-    return false;\n+  nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n   if (nunits_in >= nunits_out)\n     return false;\n@@ -2446,28 +2468,11 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n     ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_out;\n   gcc_assert (ncopies >= 1);\n \n-  if (! ((INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n-\t  && INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n-\t || (SCALAR_FLOAT_TYPE_P (TREE_TYPE (scalar_dest))\n-\t     && SCALAR_FLOAT_TYPE_P (TREE_TYPE (op0))\n-\t     && CONVERT_EXPR_CODE_P (code))))\n-    return false;\n-\n-  /* Check the operands of the operation.  */\n-  if (!vect_is_simple_use (op0, loop_vinfo, NULL, &def_stmt, &def, &dt[0]))\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"use not simple.\");\n-      return false;\n-    }\n-\n   /* Supportable by target?  */\n-  if (!supportable_narrowing_operation (code, stmt, vectype_in, &code1,\n-                                        &multi_step_cvt, &interm_types))\n+  if (!supportable_narrowing_operation (code, vectype_out, vectype_in,\n+\t\t\t\t\t&code1, &multi_step_cvt, &interm_types))\n     return false;\n \n-  STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n-\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = type_demotion_vec_info_type;\n@@ -2693,16 +2698,32 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n       && code != WIDEN_MULT_EXPR)\n     return false;\n \n+  scalar_dest = gimple_assign_lhs (stmt);\n+  vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n+\n+  /* Check the operands of the operation.  */\n   op0 = gimple_assign_rhs1 (stmt);\n-  vectype_in = get_vectype_for_scalar_type (TREE_TYPE (op0));\n+  if (! ((INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n+\t || (SCALAR_FLOAT_TYPE_P (TREE_TYPE (scalar_dest))\n+\t     && SCALAR_FLOAT_TYPE_P (TREE_TYPE (op0))\n+\t     && CONVERT_EXPR_CODE_P (code))))\n+    return false;\n+  if (!vect_is_simple_use_1 (op0, loop_vinfo, NULL,\n+\t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"use not simple.\");\n+      return false;\n+    }\n+  /* If op0 is an external or constant def use a vector type with\n+     the same size as the output vector type.  */\n+  if (!vectype_in)\n+    vectype_in = get_same_sized_vectype (TREE_TYPE (op0), vectype_out);\n   if (!vectype_in)\n     return false;\n-  nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n \n-  scalar_dest = gimple_assign_lhs (stmt);\n-  vectype_out = get_vectype_for_scalar_type (TREE_TYPE (scalar_dest));\n-  if (!vectype_out)\n-    return false;\n+  nunits_in = TYPE_VECTOR_SUBPARTS (vectype_in);\n   nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n   if (nunits_in <= nunits_out)\n     return false;\n@@ -2717,21 +2738,6 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n \n   gcc_assert (ncopies >= 1);\n \n-  if (! ((INTEGRAL_TYPE_P (TREE_TYPE (scalar_dest))\n-\t  && INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n-\t || (SCALAR_FLOAT_TYPE_P (TREE_TYPE (scalar_dest))\n-\t     && SCALAR_FLOAT_TYPE_P (TREE_TYPE (op0))\n-\t     && CONVERT_EXPR_CODE_P (code))))\n-    return false;\n-\n-  /* Check the operands of the operation.  */\n-  if (!vect_is_simple_use (op0, loop_vinfo, NULL, &def_stmt, &def, &dt[0]))\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"use not simple.\");\n-      return false;\n-    }\n-\n   op_type = TREE_CODE_LENGTH (code);\n   if (op_type == binary_op)\n     {\n@@ -2745,7 +2751,7 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n     }\n \n   /* Supportable by target?  */\n-  if (!supportable_widening_operation (code, stmt, vectype_in,\n+  if (!supportable_widening_operation (code, stmt, vectype_out, vectype_in,\n \t\t\t\t       &decl1, &decl2, &code1, &code2,\n                                        &multi_step_cvt, &interm_types))\n     return false;\n@@ -2754,8 +2760,6 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n      architecture.  */\n   gcc_assert (!(multi_step_cvt && op_type == binary_op));\n \n-  STMT_VINFO_VECTYPE (stmt_info) = vectype_in;\n-\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = type_promotion_vec_info_type;\n@@ -3944,7 +3948,6 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   enum vect_relevant relevance = STMT_VINFO_RELEVANT (stmt_info);\n   bool ok;\n-  HOST_WIDE_INT dummy;\n   tree scalar_type, vectype;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n@@ -4002,7 +4005,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n     {\n       gcc_assert (PURE_SLP_STMT (stmt_info));\n \n-      scalar_type = vect_get_smallest_scalar_type (stmt, &dummy, &dummy);\n+      scalar_type = TREE_TYPE (gimple_get_lhs (stmt));\n       if (vect_print_dump_info (REPORT_DETAILS))\n         {\n           fprintf (vect_dump, \"get vectype for scalar type:  \");\n@@ -4455,6 +4458,17 @@ get_vectype_for_scalar_type (tree scalar_type)\n   return vectype;\n }\n \n+/* Function get_same_sized_vectype\n+\n+   Returns a vector type corresponding to SCALAR_TYPE of size\n+   VECTOR_TYPE if supported by the target.  */\n+\n+tree\n+get_same_sized_vectype (tree scalar_type, tree vector_type ATTRIBUTE_UNUSED)\n+{\n+  return get_vectype_for_scalar_type (scalar_type);\n+}\n+\n /* Function vect_is_simple_use.\n \n    Input:\n@@ -4588,12 +4602,55 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo,\n   return true;\n }\n \n+/* Function vect_is_simple_use_1.\n+\n+   Same as vect_is_simple_use_1 but also determines the vector operand\n+   type of OPERAND and stores it to *VECTYPE.  If the definition of\n+   OPERAND is vect_uninitialized_def, vect_constant_def or\n+   vect_external_def *VECTYPE will be set to NULL_TREE and the caller\n+   is responsible to compute the best suited vector type for the\n+   scalar operand.  */\n+\n+bool\n+vect_is_simple_use_1 (tree operand, loop_vec_info loop_vinfo,\n+\t\t      bb_vec_info bb_vinfo, gimple *def_stmt,\n+\t\t      tree *def, enum vect_def_type *dt, tree *vectype)\n+{\n+  if (!vect_is_simple_use (operand, loop_vinfo, bb_vinfo, def_stmt, def, dt))\n+    return false;\n+\n+  /* Now get a vector type if the def is internal, otherwise supply\n+     NULL_TREE and leave it up to the caller to figure out a proper\n+     type for the use stmt.  */\n+  if (*dt == vect_internal_def\n+      || *dt == vect_induction_def\n+      || *dt == vect_reduction_def\n+      || *dt == vect_double_reduction_def\n+      || *dt == vect_nested_cycle)\n+    {\n+      stmt_vec_info stmt_info = vinfo_for_stmt (*def_stmt);\n+      if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n+\tstmt_info = vinfo_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n+      *vectype = STMT_VINFO_VECTYPE (stmt_info);\n+      gcc_assert (*vectype != NULL_TREE);\n+    }\n+  else if (*dt == vect_uninitialized_def\n+\t   || *dt == vect_constant_def\n+\t   || *dt == vect_external_def)\n+    *vectype = NULL_TREE;\n+  else\n+    gcc_unreachable ();\n+\n+  return true;\n+}\n+\n \n /* Function supportable_widening_operation\n \n    Check whether an operation represented by the code CODE is a\n    widening operation that is supported by the target platform in\n-   vector form (i.e., when operating on arguments of type VECTYPE).\n+   vector form (i.e., when operating on arguments of type VECTYPE_IN\n+   producing a result of type VECTYPE_OUT).\n \n    Widening operations we currently support are NOP (CONVERT), FLOAT\n    and WIDEN_MULT.  This function checks if these operations are supported\n@@ -4613,7 +4670,8 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo,\n    widening operation (short in the above example).  */\n \n bool\n-supportable_widening_operation (enum tree_code code, gimple stmt, tree vectype,\n+supportable_widening_operation (enum tree_code code, gimple stmt,\n+\t\t\t\ttree vectype_out, tree vectype_in,\n                                 tree *decl1, tree *decl2,\n                                 enum tree_code *code1, enum tree_code *code2,\n                                 int *multi_step_cvt,\n@@ -4626,8 +4684,8 @@ supportable_widening_operation (enum tree_code code, gimple stmt, tree vectype,\n   enum machine_mode vec_mode;\n   enum insn_code icode1, icode2;\n   optab optab1, optab2;\n-  tree type = gimple_expr_type (stmt);\n-  tree wide_vectype = get_vectype_for_scalar_type (type);\n+  tree vectype = vectype_in;\n+  tree wide_vectype = vectype_out;\n   enum tree_code c1, c2;\n \n   /* The result of a vectorized widening operation usually requires two vectors\n@@ -4726,8 +4784,8 @@ supportable_widening_operation (enum tree_code code, gimple stmt, tree vectype,\n   if (code == FIX_TRUNC_EXPR)\n     {\n       /* The signedness is determined from output operand.  */\n-      optab1 = optab_for_tree_code (c1, type, optab_default);\n-      optab2 = optab_for_tree_code (c2, type, optab_default);\n+      optab1 = optab_for_tree_code (c1, vectype_out, optab_default);\n+      optab2 = optab_for_tree_code (c2, vectype_out, optab_default);\n     }\n   else\n     {\n@@ -4809,7 +4867,8 @@ supportable_widening_operation (enum tree_code code, gimple stmt, tree vectype,\n \n    Check whether an operation represented by the code CODE is a\n    narrowing operation that is supported by the target platform in\n-   vector form (i.e., when operating on arguments of type VECTYPE).\n+   vector form (i.e., when operating on arguments of type VECTYPE_IN\n+   and producing a result of type VECTYPE_OUT).\n \n    Narrowing operations we currently support are NOP (CONVERT) and\n    FIX_TRUNC. This function checks if these operations are supported by\n@@ -4826,15 +4885,15 @@ supportable_widening_operation (enum tree_code code, gimple stmt, tree vectype,\n \n bool\n supportable_narrowing_operation (enum tree_code code,\n-\t\t\t\t const_gimple stmt, tree vectype,\n+\t\t\t\t tree vectype_out, tree vectype_in,\n \t\t\t\t enum tree_code *code1, int *multi_step_cvt,\n                                  VEC (tree, heap) **interm_types)\n {\n   enum machine_mode vec_mode;\n   enum insn_code icode1;\n   optab optab1, interm_optab;\n-  tree type = gimple_expr_type (stmt);\n-  tree narrow_vectype = get_vectype_for_scalar_type (type);\n+  tree vectype = vectype_in;\n+  tree narrow_vectype = vectype_out;\n   enum tree_code c1;\n   tree intermediate_type, prev_type;\n   int i;\n@@ -4860,7 +4919,7 @@ supportable_narrowing_operation (enum tree_code code,\n \n   if (code == FIX_TRUNC_EXPR)\n     /* The signedness is determined from output operand.  */\n-    optab1 = optab_for_tree_code (c1, type, optab_default);\n+    optab1 = optab_for_tree_code (c1, vectype_out, optab_default);\n   else\n     optab1 = optab_for_tree_code (c1, vectype, optab_default);\n "}, {"sha": "b46bc52c25b00fc0c5b9ba36445da1daf141622f", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b690cc0f331d0f63e2de4f0aa2e3883444cfead2/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b690cc0f331d0f63e2de4f0aa2e3883444cfead2/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=b690cc0f331d0f63e2de4f0aa2e3883444cfead2", "patch": "@@ -409,7 +409,7 @@ typedef struct _stmt_vec_info {\n      used outside the loop.  */\n   bool live;\n \n-  /* The vector type to be used.  */\n+  /* The vector type to be used for the LHS of this statement.  */\n   tree vectype;\n \n   /* The vectorized version of the stmt.  */\n@@ -760,15 +760,18 @@ extern bool vect_can_advance_ivs_p (loop_vec_info);\n \n /* In tree-vect-stmts.c.  */\n extern tree get_vectype_for_scalar_type (tree);\n+extern tree get_same_sized_vectype (tree, tree);\n extern bool vect_is_simple_use (tree, loop_vec_info, bb_vec_info, gimple *,\n                                 tree *,  enum vect_def_type *);\n-extern bool supportable_widening_operation (enum tree_code, gimple, tree,\n+extern bool vect_is_simple_use_1 (tree, loop_vec_info, bb_vec_info, gimple *,\n+\t\t\t\t  tree *,  enum vect_def_type *, tree *);\n+extern bool supportable_widening_operation (enum tree_code, gimple, tree, tree,\n                                             tree *, tree *, enum tree_code *,\n                                             enum tree_code *, int *,\n                                             VEC (tree, heap) **);\n-extern bool supportable_narrowing_operation (enum tree_code, const_gimple,\n-                                             tree, enum tree_code *, int *,\n-                                             VEC (tree, heap) **);\n+extern bool supportable_narrowing_operation (enum tree_code, tree, tree,\n+\t\t\t\t\t     enum tree_code *,\n+\t\t\t\t\t     int *, VEC (tree, heap) **);\n extern stmt_vec_info new_stmt_vec_info (gimple stmt, loop_vec_info,\n                                         bb_vec_info);\n extern void free_stmt_vec_info (gimple stmt);"}]}