{"sha": "d91ba7b021e59c8ab455b04214a8d0a1925befaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkxYmE3YjAyMWU1OWM4YWI0NTViMDQyMTRhOGQwYTE5MjViZWZhZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-23T22:48:14Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-23T22:48:14Z"}, "message": "re PR c++/16277 (Wrong code with conditionals in initializers)\n\n        PR c++/16277\n        * gimplify.c (gimplify_cond_expr): Gimplify TARGET to a min_lval;\n        unshare it properly.\n        (gimplify_modify_expr_rhs): Push assignment from a conditional into\n        the conditional for all non-register types.\n\nFrom-SVN: r85100", "tree": {"sha": "a1e7cce3196b368eebb0f45bdc5be95fda08408f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1e7cce3196b368eebb0f45bdc5be95fda08408f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d91ba7b021e59c8ab455b04214a8d0a1925befaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d91ba7b021e59c8ab455b04214a8d0a1925befaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d91ba7b021e59c8ab455b04214a8d0a1925befaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d91ba7b021e59c8ab455b04214a8d0a1925befaf/comments", "author": null, "committer": null, "parents": [{"sha": "ab8907ef75b71c987932a299bddf04cb73907c69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab8907ef75b71c987932a299bddf04cb73907c69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab8907ef75b71c987932a299bddf04cb73907c69"}], "stats": {"total": 33, "additions": 23, "deletions": 10}, "files": [{"sha": "5a563915de05895a19113261e356ad545cdde184", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91ba7b021e59c8ab455b04214a8d0a1925befaf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91ba7b021e59c8ab455b04214a8d0a1925befaf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d91ba7b021e59c8ab455b04214a8d0a1925befaf", "patch": "@@ -1,3 +1,11 @@\n+2004-07-23  Richard Henderson  <rth@redhat.com>\n+\n+\tPR c++/16277\n+\t* gimplify.c (gimplify_cond_expr): Gimplify TARGET to a min_lval;\n+\tunshare it properly.\n+\t(gimplify_modify_expr_rhs): Push assignment from a conditional into\n+\tthe conditional for all non-register types.\n+\n 2004-07-23  Richard Henderson  <rth@redhat.com>\n \n \t* expr.c (expand_expr_real_1): Don't handle non-local variables."}, {"sha": "fcbab025053a1bc0091fbae3290e0449ba16cc43", "filename": "gcc/gimplify.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91ba7b021e59c8ab455b04214a8d0a1925befaf/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91ba7b021e59c8ab455b04214a8d0a1925befaf/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=d91ba7b021e59c8ab455b04214a8d0a1925befaf", "patch": "@@ -2191,7 +2191,7 @@ static enum gimplify_status\n gimplify_cond_expr (tree *expr_p, tree *pre_p, tree target)\n {\n   tree expr = *expr_p;\n-  tree tmp, type;\n+  tree tmp, tmp2, type;\n   enum gimplify_status ret;\n \n   type = TREE_TYPE (expr);\n@@ -2204,12 +2204,16 @@ gimplify_cond_expr (tree *expr_p, tree *pre_p, tree target)\n     {\n       if (target)\n \t{\n+\t  ret = gimplify_expr (&target, pre_p, NULL,\n+\t\t\t       is_gimple_min_lval, fb_lvalue);\n+\t  if (ret != GS_ERROR)\n+\t    ret = GS_OK;\n \t  tmp = target;\n-\t  ret = GS_OK;\n+\t  tmp2 = unshare_expr (target);\n \t}\n       else\n \t{\n-\t  tmp = create_tmp_var (TREE_TYPE (expr), \"iftmp\");\n+\t  tmp2 = tmp = create_tmp_var (TREE_TYPE (expr), \"iftmp\");\n \t  ret = GS_ALL_DONE;\n \t}\n \n@@ -2222,15 +2226,15 @@ gimplify_cond_expr (tree *expr_p, tree *pre_p, tree target)\n       /* Build the else clause, 't1 = b;'.  */\n       if (TREE_TYPE (TREE_OPERAND (expr, 2)) != void_type_node)\n \tTREE_OPERAND (expr, 2)\n-\t  = build (MODIFY_EXPR, void_type_node, tmp, TREE_OPERAND (expr, 2));\n+\t  = build (MODIFY_EXPR, void_type_node, tmp2, TREE_OPERAND (expr, 2));\n \n       TREE_TYPE (expr) = void_type_node;\n       recalculate_side_effects (expr);\n \n-      /* Move the COND_EXPR to the prequeue and use the temp in its place.  */\n+      /* Move the COND_EXPR to the prequeue.  */\n       gimplify_and_add (expr, pre_p);\n-      *expr_p = tmp;\n \n+      *expr_p = tmp;\n       return ret;\n     }\n \n@@ -2689,10 +2693,11 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n \treturn gimplify_init_constructor (expr_p, pre_p, post_p, want_value);\n \n       case COND_EXPR:\n-\t/* If we're assigning from a ?: expression with ADDRESSABLE type, push\n-\t   the assignment down into the branches, since we can't generate a\n-\t   temporary of such a type.  */\n-\tif (TREE_ADDRESSABLE (TREE_TYPE (*from_p)))\n+\t/* If we're assigning to a non-register type, push the assignment\n+\t   down into the branches.  This is mandatory for ADDRESSABLE types,\n+\t   since we cannot generate temporaries for such, but it saves a \n+\t   copy in other cases as well.  */\n+\tif (!is_gimple_reg_type (TREE_TYPE (*from_p)))\n \t  {\n \t    *expr_p = *from_p;\n \t    return gimplify_cond_expr (expr_p, pre_p, *to_p);"}]}