{"sha": "fa0aee8996c4865098816ee9a5007aabe355925f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmEwYWVlODk5NmM0ODY1MDk4ODE2ZWU5YTUwMDdhYWJlMzU1OTI1Zg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-07-20T07:27:18Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-07-20T07:27:18Z"}, "message": "genattr.c (struct range, [...]): Remove them.\n\n2004-07-19  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* genattr.c (struct range, struct function_unit,\n\twrite_units, extend_range, init_range): Remove them.\n\t(main): Remove code dealing with DEFINE_FUNCTION_UNIT.\n\tOutput \"#define INSN_SCHEDULING\" here.\n\t* genattrtab.c (struct range, struct function_unit_op,\n\tstruct function_unit, struct dimension, enum operator,\n\toperate_exp, expand_units, simplify_knowing,\n\tencode_units_mask, simplify_by_exploding,\n\tfind_and_mark_used_attributes, unmark_used_attributes,\n\tadd_values_to_cover, increment_current_value,\n\ttest_for_current_value, simplify_with_current_value,\n\tsimplify_with_current_value_aux, gen_unit,\n\twrite_unit_name, write_function_unit_info,\n\twrite_complex_function, write_toplevel_expr,\n\tfind_single_value, extend_range): Remove.\n\t(write_attr_get): Do not handle common_av->value\n\tbeing an FFS.\n\t(struct attr_desc): Remove func_units_p and blockage_p.\n\t(write_attr_valueq): Do not handle them.\n\t(find_attr): Do not clear them.\n\t(make_internal_attr): Do not initialize them.\n\t(main): Remove code dealing with DEFINE_FUNCTION_UNIT.\n\t* sched-vis.c (init_target_units, insn_print_units,\n\tinit_block_visualization, print_block_visualization,\n\tvisualize_scheduled_insns, visualize_no_unit,\n\tvisualize_stall_cycles, visualize_alloc,\n\tvisualize_free, target_units, get_visual_tbl_length,\n\tMAX_VISUAL_LINES, INSN_LEN, n_visual_lines,\n\tvisual_tbl_line_length, visual_tbl, n_vis_no_unit,\n\tMAX_VISUAL_NO_UNIT, vis_no_unit): Remove.\n\t* haifa-sched.c (blockage_range, clear_units,\n\tschedule_unit, actual_hazard, potential_hazard,\n\tinsn_unit, unit_last_insn, unit_tick,\n\tactual_hazard_this_instance, potential_hazard,\n\tschedule_unit, max_insn_queue_index_value): Remove.\n\t(MAX_INSN_QUEUE_INDEX): Removed, renamed throughout to\n\tmax_insn_queue_index.\n\t* rtl.def (DEFINE_FUNCTION_UNIT): Remove.\n\t* doc/md.texi (Processor pipeline description): Remove\n\treferences to old pipeline descriptions.\n\t(Automaton pipeline description): Merge with the above.\n\t(Old pipeline description, Comparison of the two descriptions):\n\tRemove.\n\n\t* bt-load.c (migrate_btr_def): Remove references to\n\tuse_pipeline_interface.\n\t* haifa-sched.c (insn_cost, schedule_insn,\n\tschedule_block, advance_one_cycle, sched_init,\n\tqueue_to_ready, sched_finish): Likewise.\n\t* modulo-sched.c (sms_schedule, advance_one_cycle,\n\tps_has_conflicts): Likewise.\n\t* sched-rgn.c (init_ready): Likewise.\n\t(debug_dependencies): Likewise, and remove an \"if (1)\".\n\t* target.h (use_dfa_pipeline_interface): Remove.\n\t* config/alpha/alpha.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/arc/arc.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/arm/arm.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/c4x/c4x.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/frv/frv.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/i386/i386.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/ia64/ia64.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/iq2000/iq2000.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/m32r/m32r.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/mcore/mcore.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/mips/mips.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/pa/pa.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/rs6000/rs6000.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/s390/s390.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/sh/sh.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/sparc/sparc.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/v850/v850.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* config/xtensa/xtensa.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\t* doc/tm.texi (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n\nFrom-SVN: r84944", "tree": {"sha": "caaa05106e5030ca7ddaa15e73f4d0f45302ff30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/caaa05106e5030ca7ddaa15e73f4d0f45302ff30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa0aee8996c4865098816ee9a5007aabe355925f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa0aee8996c4865098816ee9a5007aabe355925f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa0aee8996c4865098816ee9a5007aabe355925f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa0aee8996c4865098816ee9a5007aabe355925f/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "31aedc36c0234bfa1b6902e748032b9c49ed2f03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31aedc36c0234bfa1b6902e748032b9c49ed2f03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31aedc36c0234bfa1b6902e748032b9c49ed2f03"}], "stats": {"total": 3526, "additions": 369, "deletions": 3157}, "files": [{"sha": "b609a50fce5998568f4698396261f08eb2114b02", "filename": "gcc/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -1,3 +1,79 @@\n+2004-07-19  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* genattr.c (struct range, struct function_unit,\n+\twrite_units, extend_range, init_range): Remove them.\n+\t(main): Remove code dealing with DEFINE_FUNCTION_UNIT.\n+\tOutput \"#define INSN_SCHEDULING\" here.\n+\t* genattrtab.c (struct range, struct function_unit_op,\n+\tstruct function_unit, struct dimension, enum operator,\n+\toperate_exp, expand_units, simplify_knowing,\n+\tencode_units_mask, simplify_by_exploding,\n+\tfind_and_mark_used_attributes, unmark_used_attributes,\n+\tadd_values_to_cover, increment_current_value,\n+\ttest_for_current_value, simplify_with_current_value,\n+\tsimplify_with_current_value_aux, gen_unit,\n+\twrite_unit_name, write_function_unit_info,\n+\twrite_complex_function, write_toplevel_expr,\n+\tfind_single_value, extend_range): Remove.\n+\t(write_attr_get): Do not handle common_av->value\n+\tbeing an FFS.\n+\t(struct attr_desc): Remove func_units_p and blockage_p.\n+\t(write_attr_valueq): Do not handle them.\n+\t(find_attr): Do not clear them.\n+\t(make_internal_attr): Do not initialize them.\n+\t(main): Remove code dealing with DEFINE_FUNCTION_UNIT.\n+\t* sched-vis.c (init_target_units, insn_print_units,\n+\tinit_block_visualization, print_block_visualization,\n+\tvisualize_scheduled_insns, visualize_no_unit,\n+\tvisualize_stall_cycles, visualize_alloc,\n+\tvisualize_free, target_units, get_visual_tbl_length,\n+\tMAX_VISUAL_LINES, INSN_LEN, n_visual_lines,\n+\tvisual_tbl_line_length, visual_tbl, n_vis_no_unit,\n+\tMAX_VISUAL_NO_UNIT, vis_no_unit): Remove.\n+\t* haifa-sched.c (blockage_range, clear_units,\n+\tschedule_unit, actual_hazard, potential_hazard,\n+\tinsn_unit, unit_last_insn, unit_tick,\n+\tactual_hazard_this_instance, potential_hazard,\n+\tschedule_unit, max_insn_queue_index_value): Remove.\n+\t(MAX_INSN_QUEUE_INDEX): Removed, renamed throughout to\n+\tmax_insn_queue_index.\n+\t* rtl.def (DEFINE_FUNCTION_UNIT): Remove.\n+\t* doc/md.texi (Processor pipeline description): Remove\n+\treferences to old pipeline descriptions.\n+\t(Automaton pipeline description): Merge with the above.\n+\t(Old pipeline description, Comparison of the two descriptions):\n+\tRemove.\n+\n+\t* bt-load.c (migrate_btr_def): Remove references to\n+\tuse_pipeline_interface.\n+\t* haifa-sched.c (insn_cost, schedule_insn,\n+\tschedule_block, advance_one_cycle, sched_init,\n+\tqueue_to_ready, sched_finish): Likewise.\n+\t* modulo-sched.c (sms_schedule, advance_one_cycle,\n+\tps_has_conflicts): Likewise.\n+\t* sched-rgn.c (init_ready): Likewise.\n+\t(debug_dependencies): Likewise, and remove an \"if (1)\".\n+\t* target.h (use_dfa_pipeline_interface): Remove.\n+\t* config/alpha/alpha.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/arc/arc.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/arm/arm.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/c4x/c4x.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/frv/frv.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/i386/i386.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/ia64/ia64.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/iq2000/iq2000.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/m32r/m32r.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/mcore/mcore.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/mips/mips.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/pa/pa.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/rs6000/rs6000.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/s390/s390.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/sh/sh.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/sparc/sparc.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/v850/v850.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* config/xtensa/xtensa.c (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\t* doc/tm.texi (TARGET_USE_DFA_PIPELINE_INTERFACE): Remove.\n+\n 2004-07-19  Roger Sayle  <roger@eyesopen.com>\n \n \t* rtlanal.c (reg_set_p): Add check for regs_invalidated_by_call."}, {"sha": "a3974293d6c945a34f3bcb594aad4e1661843b1f", "filename": "gcc/bt-load.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -1237,7 +1237,7 @@ migrate_btr_def (btr_def def, int min_cost)\n   int give_up = 0;\n   int def_moved = 0;\n   btr_user user;\n-  int def_latency = 1;\n+  int def_latency;\n \n   if (dump_file)\n     fprintf (dump_file,\n@@ -1267,14 +1267,11 @@ migrate_btr_def (btr_def def, int min_cost)\n   bitmap_copy (live_range, def->live_range);\n \n #ifdef INSN_SCHEDULING\n-  if (targetm.sched.use_dfa_pipeline_interface ())\n-    def_latency = insn_default_latency (def->insn);\n-  else\n-    def_latency = result_ready_cost (def->insn);\n+  def_latency = insn_default_latency (def->insn) * issue_rate;\n+#else\n+  def_latency = issue_rate;\n #endif\n \n-  def_latency *= issue_rate;\n-\n   for (user = def->uses; user != NULL; user = user->next)\n     {\n       if (user->bb == def->bb"}, {"sha": "5171fa3faeed24ea02eed9389987a0b399e66d6b", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -10152,8 +10152,6 @@ alpha_init_libfuncs (void)\n #define TARGET_SCHED_ADJUST_COST alpha_adjust_cost\n #undef TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE alpha_issue_rate\n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD \\\n   alpha_multipass_dfa_lookahead"}, {"sha": "9fc5ee2d1853262a70f8b356b97632a47bb7b06f", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -146,9 +146,6 @@ static bool arc_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n #undef TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS arc_setup_incoming_varargs\n \n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n-\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Called by OVERRIDE_OPTIONS to initialize various things.  */"}, {"sha": "460c3ef606235183293de5c582023cbebbf795a9", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -214,9 +214,6 @@ static bool arm_cookie_has_size (void);\n #undef  TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST arm_adjust_cost\n \n-#undef  TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n-\n #undef TARGET_ENCODE_SECTION_INFO\n #ifdef ARM_PE\n #define TARGET_ENCODE_SECTION_INFO  arm_pe_encode_section_info"}, {"sha": "11abe89a7ce750c955aee53282b0d4c964c5421b", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -237,9 +237,6 @@ static tree c4x_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n #undef TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST c4x_adjust_cost\n \n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n-\n #undef TARGET_ASM_GLOBALIZE_LABEL\n #define TARGET_ASM_GLOBALIZE_LABEL c4x_globalize_label\n "}, {"sha": "ccc26cffa5b1c71933fe672d8ef4350658d85150", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -319,8 +319,6 @@ static bool frv_must_pass_in_stack (enum machine_mode mode, tree type);\n \n #undef  TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE frv_issue_rate\n-#undef  TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n \n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL frv_function_ok_for_sibcall"}, {"sha": "86ea3890da8590681f0018f1c90c68e666e8c677", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -1019,8 +1019,6 @@ static void init_ext_80387_constants (void);\n #define TARGET_SCHED_ADJUST_COST ix86_adjust_cost\n #undef TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE ix86_issue_rate\n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD \\\n   ia32_multipass_dfa_lookahead"}, {"sha": "cb156b9e01bf704cb82b4a0979dc22d11911651d", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -342,9 +342,6 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK\n #define TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK ia64_dependencies_evaluation_hook\n \n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n-\n #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD ia64_first_cycle_multipass_dfa_lookahead\n "}, {"sha": "a13774474deb56d5c9474c873865fe11e78a3f10", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -205,9 +205,6 @@ static bool iq2000_pass_by_reference  (CUMULATIVE_ARGS *, enum machine_mode,\n #undef  TARGET_STRICT_ARGUMENT_NAMING\n #define TARGET_STRICT_ARGUMENT_NAMING\thook_bool_CUMULATIVE_ARGS_true\n \n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n-\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Return 1 if OP can be used as an operand where a register or 16 bit unsigned"}, {"sha": "a35c394cfa0841a58a5ca7a569906057e483ed95", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -123,8 +123,6 @@ static bool m32r_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n #define TARGET_SCHED_ADJUST_PRIORITY m32r_adjust_priority\n #undef  TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE m32r_issue_rate\n-#undef  TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n \n #undef  TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO m32r_encode_section_info"}, {"sha": "bdf50ccfac2653762304ee970de95d3c38e005f0", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -200,9 +200,6 @@ static bool       mcore_return_in_memory\t(tree, tree);\n #undef  TARGET_SETUP_INCOMING_VARARGS\n #define TARGET_SETUP_INCOMING_VARARGS\tmcore_setup_incoming_varargs\n \n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n-\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Adjust the stack and return the number of bytes taken to do it.  */"}, {"sha": "f5b2a08bc8529d5d07aab8591eebd9e97cd6e104", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -652,8 +652,6 @@ const struct mips_cpu_info mips_cpu_info_table[] = {\n #define TARGET_SCHED_ADJUST_COST mips_adjust_cost\n #undef TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE mips_issue_rate\n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD \\\n   mips_multipass_dfa_lookahead"}, {"sha": "bd8b0a40c8c9b4e9ac895c4648d9885ba899c75a", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -48,9 +48,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"target.h\"\n #include \"target-def.h\"\n \n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n-\n /* Return nonzero if there is a bypass for the output of \n    OUT_INSN and the fp store IN_INSN.  */\n int"}, {"sha": "e270f6949205bfa096a854411b5f3819abb49939", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -875,8 +875,6 @@ static const char alt_reg_names[][8] =\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE rs6000_output_function_epilogue\n \n-#undef  TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n #undef  TARGET_SCHED_VARIABLE_ISSUE\n #define TARGET_SCHED_VARIABLE_ISSUE rs6000_variable_issue\n "}, {"sha": "83e0c629e103ff6a6b7d754461e07fad08937d1d", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -132,8 +132,6 @@ static bool s390_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode mode,\n #define TARGET_SCHED_ADJUST_PRIORITY s390_adjust_priority\n #undef TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE s390_issue_rate\n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD s390_first_cycle_multipass_dfa_lookahead\n "}, {"sha": "913bb34d253c3ab3f580dc0a6ba4c3df0578b612", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -321,9 +321,6 @@ static bool sh_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n #undef TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST sh_adjust_cost\n \n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n-\n #undef TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE sh_issue_rate\n "}, {"sha": "1c5608779902335c5995e57eff27e59ba7294eb3", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -389,8 +389,6 @@ enum processor_type sparc_cpu;\n #define TARGET_SCHED_ISSUE_RATE sparc_issue_rate\n #undef TARGET_SCHED_INIT\n #define TARGET_SCHED_INIT sparc_sched_init\n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD sparc_use_sched_lookahead\n "}, {"sha": "398fe7e1c3e00c87c46b15e916d9f4e746eaf807", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -119,9 +119,6 @@ static int v850_interrupt_p = FALSE;\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST hook_int_rtx_0\n \n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n-\n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG v850_reorg\n "}, {"sha": "66b04cfd29c7b5b526a5f0a729faed45a44b9c45", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -266,9 +266,6 @@ static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n #undef TARGET_RETURN_IN_MSB\n #define TARGET_RETURN_IN_MSB xtensa_return_in_msb\n \n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n-\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n "}, {"sha": "0e35053aaad061b475e370763ddaf0aa951b933a", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 18, "deletions": 214, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -5533,172 +5533,31 @@ processors.\n The task of exploiting more processor parallelism is solved by an\n instruction scheduler.  For a better solution to this problem, the\n instruction scheduler has to have an adequate description of the\n-processor parallelism (or @dfn{pipeline description}).  Currently GCC\n-provides two alternative ways to describe processor parallelism,\n-both described below.  The first method is outlined in the next section;\n-it specifies functional unit reservations for groups of instructions\n-with the aid of @dfn{regular expressions}.  This is called the\n-@dfn{automaton based description}.  The second method is called the\n-@dfn{old pipeline description}.  This method specifies usage of\n-function units for classes of insns.  This description is not as\n-powerful or accurate as the automaton based description, because it\n-is impossible to model instructions that use more than one function\n-unit.  The second method is deprecated; new ports should use the\n-automaton based description.\n+processor parallelism (or @dfn{pipeline description}).  GCC\n+machine descriptions describe processor parallelism and functional\n+unit reservations for groups of instructions with the aid of\n+@dfn{regular expressions}.\n \n The GCC instruction scheduler uses a @dfn{pipeline hazard recognizer} to\n figure out the possibility of the instruction issue by the processor\n on a given simulated processor cycle.  The pipeline hazard recognizer is\n automatically generated from the processor pipeline description.  The\n-pipeline hazard recognizer generated from the automaton based\n-description is more sophisticated and based on a deterministic finite\n-state automaton (@acronym{DFA}) and therefore faster than one\n-generated from the old description.  Furthermore, its speed is not dependent\n-on processor complexity.  The instruction issue is possible if there is\n-a transition from one automaton state to another one.\n+pipeline hazard recognizer generated from the machine description\n+is based on a deterministic finite state automaton (@acronym{DFA}):\n+the instruction issue is possible if there is a transition from one\n+automaton state to another one.  This algorithm is very fast, and\n+furthermore, its speed is not dependent on processor\n+complexity@footnote{However, the size of the automaton depends on\n+  processor complexity.  To limit this effect, machine descriptions\n+  can split orthogonal parts of the machine description among several\n+  automata: but then, since each of these must be stepped independently,\n+  this does cause a small decrease in the algorithm's performance.}.\n \n-@menu\n-* Old pipeline description:: Specifying information for insn scheduling.\n-* Automaton pipeline description:: Describing insn pipeline characteristics.\n-* Comparison of the two descriptions:: Drawbacks of the old pipeline description\n-@end menu\n-\n-@end ifset\n-@ifset INTERNALS\n-@node Old pipeline description\n-@subsubsection Specifying Function Units\n-@cindex old pipeline description\n-@cindex function units, for scheduling\n-\n-@emph{Note:}The old pipeline description is deprecated.\n-\n-On most @acronym{RISC} machines, there are instructions whose results\n-are not available for a specific number of cycles.  Common cases are\n-instructions that load data from memory.  On many machines, a pipeline\n-stall will result if the data is referenced too soon after the load\n-instruction.\n-\n-In addition, many newer microprocessors have multiple function units, usually\n-one for integer and one for floating point, and often will incur pipeline\n-stalls when a result that is needed is not yet ready.\n-\n-The descriptions in this section allow the specification of how much\n-time must elapse between the execution of an instruction and the time\n-when its result is used.  It also allows specification of when the\n-execution of an instruction will delay execution of similar instructions\n-due to function unit conflicts.\n-\n-For the purposes of the specifications in this section, a machine is\n-divided into @dfn{function units}, each of which execute a specific\n-class of instructions in first-in-first-out order.  Function units\n-that accept one instruction each cycle and allow a result to be used\n-in the succeeding instruction (usually via forwarding) need not be\n-specified.  Classic @acronym{RISC} microprocessors will normally have\n-a single function unit, which we can call @samp{memory}.  The newer\n-``superscalar'' processors will often have function units for floating\n-point operations, usually at least a floating point adder and\n-multiplier.\n-\n-@findex define_function_unit\n-Each usage of a function units by a class of insns is specified with a\n-@code{define_function_unit} expression, which looks like this:\n-\n-@smallexample\n-(define_function_unit @var{name} @var{multiplicity} @var{simultaneity}\n-                      @var{test} @var{ready-delay} @var{issue-delay}\n-                     [@var{conflict-list}])\n-@end smallexample\n-\n-@var{name} is a string giving the name of the function unit.\n-\n-@var{multiplicity} is an integer specifying the number of identical\n-units in the processor.  If more than one unit is specified, they will\n-be scheduled independently.  Only truly independent units should be\n-counted; a pipelined unit should be specified as a single unit.  (The\n-only common example of a machine that has multiple function units for a\n-single instruction class that are truly independent and not pipelined\n-are the two multiply and two increment units of the CDC 6600.)\n-\n-@var{simultaneity} specifies the maximum number of insns that can be\n-executing in each instance of the function unit simultaneously or zero\n-if the unit is pipelined and has no limit.\n-\n-All @code{define_function_unit} definitions referring to function unit\n-@var{name} must have the same name and values for @var{multiplicity} and\n-@var{simultaneity}.\n-\n-@var{test} is an attribute test that selects the insns we are describing\n-in this definition.  Note that an insn may use more than one function\n-unit and a function unit may be specified in more than one\n-@code{define_function_unit}.\n-\n-@var{ready-delay} is an integer that specifies the number of cycles\n-after which the result of the instruction can be used without\n-introducing any stalls.\n-\n-@var{issue-delay} is an integer that specifies the number of cycles\n-after the instruction matching the @var{test} expression begins using\n-this unit until a subsequent instruction can begin.  A cost of @var{N}\n-indicates an @var{N-1} cycle delay.  A subsequent instruction may also\n-be delayed if an earlier instruction has a longer @var{ready-delay}\n-value.  This blocking effect is computed using the @var{simultaneity},\n-@var{ready-delay}, @var{issue-delay}, and @var{conflict-list} terms.\n-For a normal non-pipelined function unit, @var{simultaneity} is one, the\n-unit is taken to block for the @var{ready-delay} cycles of the executing\n-insn, and smaller values of @var{issue-delay} are ignored.\n-\n-@var{conflict-list} is an optional list giving detailed conflict costs\n-for this unit.  If specified, it is a list of condition test expressions\n-to be applied to insns chosen to execute in @var{name} following the\n-particular insn matching @var{test} that is already executing in\n-@var{name}.  For each insn in the list, @var{issue-delay} specifies the\n-conflict cost; for insns not in the list, the cost is zero.  If not\n-specified, @var{conflict-list} defaults to all instructions that use the\n-function unit.\n-\n-Typical uses of this vector are where a floating point function unit can\n-pipeline either single- or double-precision operations, but not both, or\n-where a memory unit can pipeline loads, but not stores, etc.\n-\n-As an example, consider a classic @acronym{RISC} machine where the\n-result of a load instruction is not available for two cycles (a single\n-``delay'' instruction is required) and where only one load instruction\n-can be executed simultaneously.  This would be specified as:\n-\n-@smallexample\n-(define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"load\") 2 0)\n-@end smallexample\n-\n-For the case of a floating point function unit that can pipeline either\n-single or double precision, but not both, the following could be specified:\n-\n-@smallexample\n-(define_function_unit\n-   \"fp\" 1 0 (eq_attr \"type\" \"sp_fp\") 4 4 [(eq_attr \"type\" \"dp_fp\")])\n-(define_function_unit\n-   \"fp\" 1 0 (eq_attr \"type\" \"dp_fp\") 4 4 [(eq_attr \"type\" \"sp_fp\")])\n-@end smallexample\n-\n-@strong{Note:} The scheduler attempts to avoid function unit conflicts\n-and uses all the specifications in the @code{define_function_unit}\n-expression.  It has recently been discovered that these\n-specifications may not allow modeling of some of the newer\n-``superscalar'' processors that have insns using multiple pipelined\n-units.  These insns will cause a potential conflict for the second unit\n-used during their execution and there is no way of representing that\n-conflict.  Any examples of how function unit conflicts work\n-in such processors and suggestions for their representation would be\n-welcomed.\n-\n-@end ifset\n-@ifset INTERNALS\n-@node Automaton pipeline description\n-@subsubsection Describing instruction pipeline characteristics\n @cindex automaton based pipeline description\n-\n-This section describes constructions of the automaton based processor\n-pipeline description.  The order of constructions within the machine\n-description file is not important.\n+The rest of this section describes the directives that constitute\n+an automaton-based processor pipeline description.  The order of\n+these constructions within the machine description file is not\n+important.\n \n @findex define_automaton\n @cindex pipeline hazard recognizer\n@@ -6114,61 +5973,6 @@ construction\n @end smallexample\n \n \n-@end ifset\n-@ifset INTERNALS\n-@node Comparison of the two descriptions\n-@subsubsection Drawbacks of the old pipeline description\n-@cindex old pipeline description\n-@cindex automaton based pipeline description\n-@cindex processor functional units\n-@cindex interlock delays\n-@cindex instruction latency time\n-@cindex pipeline hazard recognizer\n-@cindex data bypass\n-\n-The old instruction level parallelism description and the pipeline\n-hazards recognizer based on it have the following drawbacks in\n-comparison with the @acronym{DFA}-based ones:\n-\n-@itemize @bullet\n-@item\n-Each functional unit is believed to be reserved at the instruction\n-execution start.  This is a very inaccurate model for modern\n-processors.\n-\n-@item\n-An inadequate description of instruction latency times.  The latency\n-time is bound with a functional unit reserved by an instruction not\n-with the instruction itself.  In other words, the description is\n-oriented to describe at most one unit reservation by each instruction.\n-It also does not permit to describe special bypasses between\n-instruction pairs.\n-\n-@item\n-The implementation of the pipeline hazard recognizer interface has\n-constraints on number of functional units.  This is a number of bits\n-in integer on the host machine.\n-\n-@item\n-The interface to the pipeline hazard recognizer is more complex than\n-one to the automaton based pipeline recognizer.\n-\n-@item\n-An unnatural description when you write a unit and a condition which\n-selects instructions using the unit.  Writing all unit reservations\n-for an instruction (an instruction class) is more natural.\n-\n-@item\n-The recognition of the interlock delays has a slow implementation.  The GCC\n-scheduler supports structures which describe the unit reservations.\n-The more functional units a processor has, the slower its pipeline hazard\n-recognizer will be.  Such an implementation would become even slower when we\n-allowed to\n-reserve functional units not only at the instruction execution start.\n-In an automaton based pipeline hazard recognizer, speed is not dependent\n-on processor complexity.\n-@end itemize\n-\n @end ifset\n @ifset INTERNALS\n @node Conditional Execution"}, {"sha": "76fd3871f19e19bfbd6768aea09327de1c98a69b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -5542,8 +5542,8 @@ This value must be constant over the entire compilation.  If you need\n it to vary depending on what the instructions are, you must use\n @samp{TARGET_SCHED_VARIABLE_ISSUE}.\n \n-For the automaton based pipeline interface, you could define this hook\n-to return the value of the macro @code{MAX_DFA_ISSUE_RATE}.\n+You could define this hook to return the value of the macro\n+@code{MAX_DFA_ISSUE_RATE}.\n @end deftypefn\n \n @deftypefn {Target Hook} int TARGET_SCHED_VARIABLE_ISSUE (FILE *@var{file}, int @var{verbose}, rtx @var{insn}, int @var{more})\n@@ -5572,7 +5572,7 @@ description, the cost of anti-dependence is zero and the cost of\n output-dependence is maximum of one and the difference of latency\n times of the first and the second insns.  If these values are not\n acceptable, you could use the hook to modify them too.  See also\n-@pxref{Automaton pipeline description}.\n+@pxref{Processor pipeline description}.\n @end deftypefn\n \n @deftypefn {Target Hook} int TARGET_SCHED_ADJUST_PRIORITY (rtx @var{insn}, int @var{priority})\n@@ -5653,19 +5653,6 @@ This is the cleanup hook corresponding to TARGET_SCHED_INIT_GLOBAL.\n @var{verbose} is the verbose level provided by @option{-fsched-verbose-@var{n}}.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE (void)\n-This hook is called many times during insn scheduling.  If the hook\n-returns nonzero, the automaton based pipeline description is used for\n-insn scheduling.  Otherwise the traditional pipeline description is\n-used.  The default is usage of the traditional pipeline description.\n-\n-You should also remember that to simplify the insn scheduler sources\n-an empty traditional pipeline description interface is generated even\n-if there is no a traditional pipeline description in the @file{.md}\n-file.  The same is true for the automaton based pipeline description.\n-That means that you should be accurate in defining the hook.\n-@end deftypefn\n-\n @deftypefn {Target Hook} int TARGET_SCHED_DFA_PRE_CYCLE_INSN (void)\n The hook returns an RTL insn.  The automaton state used in the\n pipeline hazard recognizer is changed as if the insn were scheduled"}, {"sha": "0be3035256702daf3a926329f8c09bc5eb5701d7", "filename": "gcc/genattr.c", "status": "modified", "additions": 2, "deletions": 176, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -30,48 +30,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"gensupport.h\"\n \n \n-/* A range of values.  */\n-\n-struct range\n-{\n-  int min;\n-  int max;\n-};\n-\n-/* Record information about each function unit mentioned in a\n-   DEFINE_FUNCTION_UNIT.  */\n-\n-struct function_unit\n-{\n-  char *name;\t\t\t/* Function unit name.  */\n-  struct function_unit *next;\t/* Next function unit.  */\n-  int multiplicity;\t\t/* Number of units of this type.  */\n-  int simultaneity;\t\t/* Maximum number of simultaneous insns\n-\t\t\t\t   on this function unit or 0 if unlimited.  */\n-  struct range ready_cost;\t/* Range of ready cost values.  */\n-  struct range issue_delay;\t/* Range of issue delay values.  */\n-};\n-\n-static void extend_range (struct range *, int, int);\n-static void init_range (struct range *);\n static void write_upcase (const char *);\n static void gen_attr (rtx);\n-static void write_units (int, struct range *, struct range *,\n-\t\t\t struct range *, struct range *,\n-\t\t\t struct range *);\n-static void\n-extend_range (struct range *range, int min, int max)\n-{\n-  if (range->min > min) range->min = min;\n-  if (range->max < max) range->max = max;\n-}\n-\n-static void\n-init_range (struct range *range)\n-{\n-  range->min = 100000;\n-  range->max = -1;\n-}\n \n static void\n write_upcase (const char *str)\n@@ -125,53 +85,6 @@ extern int insn_current_length (rtx);\\n\\n\\\n     }\n }\n \n-static void\n-write_units (int num_units, struct range *multiplicity, struct range *simultaneity,\n-\t     struct range *ready_cost, struct range *issue_delay,\n-\t     struct range *blockage)\n-{\n-  int i, q_size;\n-\n-  printf (\"#define INSN_SCHEDULING\\n\\n\");\n-  printf (\"extern int result_ready_cost (rtx);\\n\");\n-  printf (\"extern int function_units_used (rtx);\\n\\n\");\n-  printf (\"extern const struct function_unit_desc\\n\");\n-  printf (\"{\\n\");\n-  printf (\"  const char *const name;\\n\");\n-  printf (\"  const int bitmask;\\n\");\n-  printf (\"  const int multiplicity;\\n\");\n-  printf (\"  const int simultaneity;\\n\");\n-  printf (\"  const int default_cost;\\n\");\n-  printf (\"  const int max_issue_delay;\\n\");\n-  printf (\"  int (*const ready_cost_function) (rtx);\\n\");\n-  printf (\"  int (*const conflict_cost_function) (rtx, rtx);\\n\");\n-  printf (\"  const int max_blockage;\\n\");\n-  printf (\"  unsigned int (*const blockage_range_function) (rtx);\\n\");\n-  printf (\"  int (*const blockage_function) (rtx, rtx);\\n\");\n-  printf (\"} function_units[];\\n\\n\");\n-  printf (\"#define FUNCTION_UNITS_SIZE %d\\n\", num_units);\n-  printf (\"#define MIN_MULTIPLICITY %d\\n\", multiplicity->min);\n-  printf (\"#define MAX_MULTIPLICITY %d\\n\", multiplicity->max);\n-  printf (\"#define MIN_SIMULTANEITY %d\\n\", simultaneity->min);\n-  printf (\"#define MAX_SIMULTANEITY %d\\n\", simultaneity->max);\n-  printf (\"#define MIN_READY_COST %d\\n\", ready_cost->min);\n-  printf (\"#define MAX_READY_COST %d\\n\", ready_cost->max);\n-  printf (\"#define MIN_ISSUE_DELAY %d\\n\", issue_delay->min);\n-  printf (\"#define MAX_ISSUE_DELAY %d\\n\", issue_delay->max);\n-  printf (\"#define MIN_BLOCKAGE %d\\n\", blockage->min);\n-  printf (\"#define MAX_BLOCKAGE %d\\n\", blockage->max);\n-  for (i = 0; (1 << i) < blockage->max; i++)\n-    ;\n-  printf (\"#define BLOCKAGE_BITS %d\\n\", i + 1);\n-\n-  /* INSN_QUEUE_SIZE is a power of two larger than MAX_BLOCKAGE and\n-     MAX_READY_COST.  This is the longest time an insn may be queued.  */\n-  i = MAX (blockage->max, ready_cost->max);\n-  for (q_size = 1; q_size <= i; q_size <<= 1)\n-    ;\n-  printf (\"#define INSN_QUEUE_SIZE %d\\n\", q_size);\n-}\n-\n int\n main (int argc, char **argv)\n {\n@@ -180,18 +93,8 @@ main (int argc, char **argv)\n   int have_annul_true = 0;\n   int have_annul_false = 0;\n   int num_insn_reservations = 0;\n-  int num_units = 0;\n-  struct range all_simultaneity, all_multiplicity;\n-  struct range all_ready_cost, all_issue_delay, all_blockage;\n-  struct function_unit *units = 0, *unit;\n   int i;\n \n-  init_range (&all_multiplicity);\n-  init_range (&all_simultaneity);\n-  init_range (&all_ready_cost);\n-  init_range (&all_issue_delay);\n-  init_range (&all_blockage);\n-\n   progname = \"genattr\";\n \n   if (argc <= 1)\n@@ -253,92 +156,15 @@ main (int argc, char **argv)\n \t    }\n         }\n \n-      else if (GET_CODE (desc) == DEFINE_FUNCTION_UNIT)\n-\t{\n-\t  const char *name = XSTR (desc, 0);\n-\t  int multiplicity = XINT (desc, 1);\n-\t  int simultaneity = XINT (desc, 2);\n-\t  int ready_cost = MAX (XINT (desc, 4), 1);\n-\t  int issue_delay = MAX (XINT (desc, 5), 1);\n-\t  int issueexp_p = (XVEC (desc, 6) != 0);\n-\n-\t  for (unit = units; unit; unit = unit->next)\n-\t    if (strcmp (unit->name, name) == 0)\n-\t      break;\n-\n-\t  if (unit == 0)\n-\t    {\n-\t      unit = xmalloc (sizeof (struct function_unit));\n-\t      unit->name = xstrdup (name);\n-\t      unit->multiplicity = multiplicity;\n-\t      unit->simultaneity = simultaneity;\n-\t      unit->ready_cost.min = unit->ready_cost.max = ready_cost;\n-\t      unit->issue_delay.min = unit->issue_delay.max = issue_delay;\n-\t      unit->next = units;\n-\t      units = unit;\n-\t      num_units++;\n-\n-\t      extend_range (&all_multiplicity, multiplicity, multiplicity);\n-\t      extend_range (&all_simultaneity, simultaneity, simultaneity);\n-\t    }\n-\t  else if (unit->multiplicity != multiplicity\n-\t\t   || unit->simultaneity != simultaneity)\n-\t    fatal (\"Differing specifications given for `%s' function unit\",\n-\t\t   unit->name);\n-\n-\t  extend_range (&unit->ready_cost, ready_cost, ready_cost);\n-\t  extend_range (&unit->issue_delay,\n-\t\t\tissueexp_p ? 1 : issue_delay, issue_delay);\n-\t  extend_range (&all_ready_cost,\n-\t\t\tunit->ready_cost.min, unit->ready_cost.max);\n-\t  extend_range (&all_issue_delay,\n-\t\t\tunit->issue_delay.min, unit->issue_delay.max);\n-\t}\n       else if (GET_CODE (desc) == DEFINE_INSN_RESERVATION)\n \tnum_insn_reservations++;\n     }\n \n-  if (num_units > 0 || num_insn_reservations > 0)\n+  if (num_insn_reservations > 0)\n     {\n-      /* Compute the range of blockage cost values.  See genattrtab.c\n-\t for the derivation.  BLOCKAGE (E,C) when SIMULTANEITY is zero is\n-\n-\t     MAX (ISSUE-DELAY (E,C),\n-\t\t  READY-COST (E) - (READY-COST (C) - 1))\n-\n-\t and otherwise\n-\n-\t     MAX (ISSUE-DELAY (E,C),\n-\t\t  READY-COST (E) - (READY-COST (C) - 1),\n-\t\t  READY-COST (E) - FILL-TIME)  */\n-\n-      for (unit = units; unit; unit = unit->next)\n-\t{\n-\t  struct range blockage;\n-\n-\t  blockage = unit->issue_delay;\n-\t  blockage.max = MAX (unit->ready_cost.max\n-\t\t\t      - (unit->ready_cost.min - 1),\n-\t\t\t      blockage.max);\n-\t  blockage.min = MAX (1, blockage.min);\n-\n-\t  if (unit->simultaneity != 0)\n-\t    {\n-\t      int fill_time = ((unit->simultaneity - 1)\n-\t\t\t       * unit->issue_delay.min);\n-\t      blockage.min = MAX (unit->ready_cost.min - fill_time,\n-\t\t\t\t  blockage.min);\n-\t      blockage.max = MAX (unit->ready_cost.max - fill_time,\n-\t\t\t\t  blockage.max);\n-\t    }\n-\t  extend_range (&all_blockage, blockage.min, blockage.max);\n-\t}\n-\n-      write_units (num_units, &all_multiplicity, &all_simultaneity,\n-\t\t   &all_ready_cost, &all_issue_delay, &all_blockage);\n-\n       /* Output interface for pipeline hazards recognition based on\n \t DFA (deterministic finite state automata.  */\n+      printf (\"\\n#define INSN_SCHEDULING\\n\");\n       printf (\"\\n/* DFA based pipeline interface.  */\");\n       printf (\"\\n#ifndef AUTOMATON_ALTS\\n\");\n       printf (\"#define AUTOMATON_ALTS 0\\n\");"}, {"sha": "f1bbaf523140e2a40fc780593171cb02fefa4db1", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 86, "deletions": 1691, "changes": 1777, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -21,7 +21,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n /* This program handles insn attributes and the DEFINE_DELAY and\n-   DEFINE_FUNCTION_UNIT definitions.\n+   DEFINE_INSN_RESERVATION definitions.\n \n    It produces a series of functions named `get_attr_...', one for each insn\n    attribute.  Each of these is given the rtx for an insn and returns a member\n@@ -54,7 +54,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    used.\n \n    Internal attributes are defined to handle DEFINE_DELAY and\n-   DEFINE_FUNCTION_UNIT.  Special routines are output for these cases.\n+   DEFINE_INSN_RESERVATION.  Special routines are output for these cases.\n \n    This program works by keeping a list of possible values for each attribute.\n    These include the basic attribute choices, default values for attribute, and\n@@ -70,9 +70,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    indicates when the attribute has the specified value for the insn.  This\n    avoids recursive calls during compilation.\n \n-   The strategy used when processing DEFINE_DELAY and DEFINE_FUNCTION_UNIT\n-   definitions is to create arbitrarily complex expressions and have the\n-   optimization simplify them.\n+   The strategy used when processing DEFINE_DELAY definitions is to create\n+   arbitrarily complex expressions and have the optimization simplify them.\n \n    Once optimization is complete, any required routines and definitions\n    will be written.\n@@ -193,21 +192,11 @@ struct attr_desc\n   unsigned unsigned_p\t: 1;\t/* Make the output function unsigned int.  */\n   unsigned is_const\t: 1;\t/* Attribute value constant for each run.  */\n   unsigned is_special\t: 1;\t/* Don't call `write_attr_set'.  */\n-  unsigned func_units_p\t: 1;\t/* This is the function_units attribute.  */\n-  unsigned blockage_p\t: 1;\t/* This is the blockage range function.  */\n   unsigned static_p\t: 1;\t/* Make the output function static.  */\n };\n \n #define NULL_ATTR (struct attr_desc *) NULL\n \n-/* A range of values.  */\n-\n-struct range\n-{\n-  int min;\n-  int max;\n-};\n-\n /* Structure for each DEFINE_DELAY.  */\n \n struct delay_desc\n@@ -218,94 +207,13 @@ struct delay_desc\n   int lineno;\t\t\t/* Line number.  */\n };\n \n-/* Record information about each DEFINE_FUNCTION_UNIT.  */\n-\n-struct function_unit_op\n-{\n-  rtx condexp;\t\t\t/* Expression TRUE for applicable insn.  */\n-  struct function_unit_op *next; /* Next operation for this function unit.  */\n-  int num;\t\t\t/* Ordinal for this operation type in unit.  */\n-  int ready;\t\t\t/* Cost until data is ready.  */\n-  int issue_delay;\t\t/* Cost until unit can accept another insn.  */\n-  rtx conflict_exp;\t\t/* Expression TRUE for insns incurring issue delay.  */\n-  rtx issue_exp;\t\t/* Expression computing issue delay.  */\n-  int lineno;\t\t\t/* Line number.  */\n-};\n-\n-/* Record information about each function unit mentioned in a\n-   DEFINE_FUNCTION_UNIT.  */\n-\n-struct function_unit\n-{\n-  const char *name;\t\t/* Function unit name.  */\n-  struct function_unit *next;\t/* Next function unit.  */\n-  int num;\t\t\t/* Ordinal of this unit type.  */\n-  int multiplicity;\t\t/* Number of units of this type.  */\n-  int simultaneity;\t\t/* Maximum number of simultaneous insns\n-\t\t\t\t   on this function unit or 0 if unlimited.  */\n-  rtx condexp;\t\t\t/* Expression TRUE for insn needing unit.  */\n-  int num_opclasses;\t\t/* Number of different operation types.  */\n-  struct function_unit_op *ops;\t/* Pointer to first operation type.  */\n-  int needs_conflict_function;\t/* Nonzero if a conflict function required.  */\n-  int needs_blockage_function;\t/* Nonzero if a blockage function required.  */\n-  int needs_range_function;\t/* Nonzero if blockage range function needed.  */\n-  rtx default_cost;\t\t/* Conflict cost, if constant.  */\n-  struct range issue_delay;\t/* Range of issue delay values.  */\n-  int max_blockage;\t\t/* Maximum time an insn blocks the unit.  */\n-  int first_lineno;\t\t/* First seen line number.  */\n-};\n-\n /* Listheads of above structures.  */\n \n /* This one is indexed by the first character of the attribute name.  */\n #define MAX_ATTRS_INDEX 256\n static struct attr_desc *attrs[MAX_ATTRS_INDEX];\n static struct insn_def *defs;\n static struct delay_desc *delays;\n-static struct function_unit *units;\n-\n-/* An expression where all the unknown terms are EQ_ATTR tests can be\n-   rearranged into a COND provided we can enumerate all possible\n-   combinations of the unknown values.  The set of combinations become the\n-   tests of the COND; the value of the expression given that combination is\n-   computed and becomes the corresponding value.  To do this, we must be\n-   able to enumerate all values for each attribute used in the expression\n-   (currently, we give up if we find a numeric attribute).\n-\n-   If the set of EQ_ATTR tests used in an expression tests the value of N\n-   different attributes, the list of all possible combinations can be made\n-   by walking the N-dimensional attribute space defined by those\n-   attributes.  We record each of these as a struct dimension.\n-\n-   The algorithm relies on sharing EQ_ATTR nodes: if two nodes in an\n-   expression are the same, the will also have the same address.  We find\n-   all the EQ_ATTR nodes by marking them ATTR_EQ_ATTR_P.  This bit later\n-   represents the value of an EQ_ATTR node, so once all nodes are marked,\n-   they are also given an initial value of FALSE.\n-\n-   We then separate the set of EQ_ATTR nodes into dimensions for each\n-   attribute and put them on the VALUES list.  Terms are added as needed by\n-   `add_values_to_cover' so that all possible values of the attribute are\n-   tested.\n-\n-   Each dimension also has a current value.  This is the node that is\n-   currently considered to be TRUE.  If this is one of the nodes added by\n-   `add_values_to_cover', all the EQ_ATTR tests in the original expression\n-   will be FALSE.  Otherwise, only the CURRENT_VALUE will be true.\n-\n-   NUM_VALUES is simply the length of the VALUES list and is there for\n-   convenience.\n-\n-   Once the dimensions are created, the algorithm enumerates all possible\n-   values and computes the current value of the given expression.  */\n-\n-struct dimension\n-{\n-  struct attr_desc *attr;\t/* Attribute for this dimension.  */\n-  rtx values;\t\t\t/* List of attribute values used.  */\n-  rtx current_value;\t\t/* Position in the list for the TRUE value.  */\n-  int num_values;\t\t/* Length of the values list.  */\n-};\n \n /* Other variables.  */\n \n@@ -318,15 +226,10 @@ static int address_used;\n static int length_used;\n static int num_delays;\n static int have_annul_true, have_annul_false;\n-static int num_units, num_unit_opclasses;\n static int num_insn_ents;\n \n int num_dfa_decls;\n \n-/* Used as operand to `operate_exp':  */\n-\n-enum operator {PLUS_OP, MINUS_OP, POS_MINUS_OP, EQ_OP, OR_OP, ORX_OP, MAX_OP, MIN_OP, RANGE_OP};\n-\n /* Stores, for each insn code, the number of constraint alternatives.  */\n \n static int *insn_n_alternatives;\n@@ -401,10 +304,6 @@ static struct attr_value *get_attr_value (rtx, struct attr_desc *, int);\n static rtx copy_rtx_unchanging\t(rtx);\n static rtx copy_boolean\t\t(rtx);\n static void expand_delays\t(void);\n-static rtx operate_exp\t\t(enum operator, rtx, rtx);\n-static void expand_units\t(void);\n-static rtx simplify_knowing\t(rtx, rtx);\n-static rtx encode_units_mask\t(rtx);\n static void fill_attr\t\t(struct attr_desc *);\n static rtx substitute_address\t(rtx, rtx (*) (rtx), rtx (*) (rtx));\n static void make_length_attrs\t(void);\n@@ -414,14 +313,6 @@ static rtx one_fn\t\t(rtx);\n static rtx max_fn\t\t(rtx);\n static void write_length_unit_log (void);\n static rtx simplify_cond\t(rtx, int, int);\n-static rtx simplify_by_exploding (rtx);\n-static int find_and_mark_used_attributes (rtx, rtx *, int *);\n-static void unmark_used_attributes (rtx, struct dimension *, int);\n-static int add_values_to_cover\t(struct dimension *);\n-static int increment_current_value (struct dimension *, int);\n-static rtx test_for_current_value (struct dimension *, int);\n-static rtx simplify_with_current_value (rtx, struct dimension *, int);\n-static rtx simplify_with_current_value_aux (rtx);\n static void clear_struct_flag (rtx);\n static void remove_insn_ent  (struct attr_value *, struct insn_ent *);\n static void insert_insn_ent  (struct attr_value *, struct insn_ent *);\n@@ -440,7 +331,6 @@ static int compares_alternatives_p (rtx);\n static int contained_in_p\t(rtx, rtx);\n static void gen_insn\t\t(rtx, int);\n static void gen_delay\t\t(rtx, int);\n-static void gen_unit\t\t(rtx, int);\n static void write_test_expr\t(rtx, int);\n static int max_attr_value\t(rtx, int*);\n static int or_attr_value\t(rtx, int*);\n@@ -452,23 +342,16 @@ static void write_attr_set\t(struct attr_desc *, int, rtx,\n \t\t\t\t int, int);\n static void write_attr_case\t(struct attr_desc *, struct attr_value *,\n \t\t\t\t int, const char *, const char *, int, rtx);\n-static void write_unit_name\t(const char *, int, const char *);\n static void write_attr_valueq\t(struct attr_desc *, const char *);\n static void write_attr_value\t(struct attr_desc *, rtx);\n static void write_upcase\t(const char *);\n static void write_indent\t(int);\n static void write_eligible_delay (const char *);\n-static void write_function_unit_info (void);\n-static void write_complex_function (struct function_unit *, const char *,\n-\t\t\t\t    const char *);\n static int write_expr_attr_cache (rtx, struct attr_desc *);\n-static void write_toplevel_expr\t(rtx);\n static void write_const_num_delay_slots (void);\n static char *next_comma_elt\t(const char **);\n static struct attr_desc *find_attr (const char **, int);\n static struct attr_value *find_most_used  (struct attr_desc *);\n-static rtx find_single_value\t(struct attr_desc *);\n-static void extend_range\t(struct range *, int, int);\n static rtx attr_eq\t\t(const char *, const char *);\n static const char *attr_numeral\t(int);\n static int attr_equal_p\t\t(rtx, rtx);\n@@ -1606,654 +1489,6 @@ expand_delays (void)\n     }\n }\n \n-/* This function is given a left and right side expression and an operator.\n-   Each side is a conditional expression, each alternative of which has a\n-   numerical value.  The function returns another conditional expression\n-   which, for every possible set of condition values, returns a value that is\n-   the operator applied to the values of the two sides.\n-\n-   Since this is called early, it must also support IF_THEN_ELSE.  */\n-\n-static rtx\n-operate_exp (enum operator op, rtx left, rtx right)\n-{\n-  int left_value, right_value;\n-  rtx newexp;\n-  int i;\n-\n-  /* If left is a string, apply operator to it and the right side.  */\n-  if (GET_CODE (left) == CONST_STRING)\n-    {\n-      /* If right is also a string, just perform the operation.  */\n-      if (GET_CODE (right) == CONST_STRING)\n-\t{\n-\t  left_value = atoi (XSTR (left, 0));\n-\t  right_value = atoi (XSTR (right, 0));\n-\t  switch (op)\n-\t    {\n-\t    case PLUS_OP:\n-\t      i = left_value + right_value;\n-\t      break;\n-\n-\t    case MINUS_OP:\n-\t      i = left_value - right_value;\n-\t      break;\n-\n-\t    case POS_MINUS_OP:  /* The positive part of LEFT - RIGHT.  */\n-\t      if (left_value > right_value)\n-\t\ti = left_value - right_value;\n-\t      else\n-\t\ti = 0;\n-\t      break;\n-\n-\t    case OR_OP:\n-\t    case ORX_OP:\n-\t      i = left_value | right_value;\n-\t      break;\n-\n-\t    case EQ_OP:\n-\t      i = left_value == right_value;\n-\t      break;\n-\n-\t    case RANGE_OP:\n-\t      i = (left_value << (HOST_BITS_PER_INT / 2)) | right_value;\n-\t      break;\n-\n-\t    case MAX_OP:\n-\t      if (left_value > right_value)\n-\t\ti = left_value;\n-\t      else\n-\t\ti = right_value;\n-\t      break;\n-\n-\t    case MIN_OP:\n-\t      if (left_value < right_value)\n-\t\ti = left_value;\n-\t      else\n-\t\ti = right_value;\n-\t      break;\n-\n-\t    default:\n-\t      abort ();\n-\t    }\n-\n-\t  if (i == left_value)\n-\t    return left;\n-\t  if (i == right_value)\n-\t    return right;\n-\t  return make_numeric_value (i);\n-\t}\n-      else if (GET_CODE (right) == IF_THEN_ELSE)\n-\t{\n-\t  /* Apply recursively to all values within.  */\n-\t  rtx newleft = operate_exp (op, left, XEXP (right, 1));\n-\t  rtx newright = operate_exp (op, left, XEXP (right, 2));\n-\t  if (rtx_equal_p (newleft, newright))\n-\t    return newleft;\n-\t  return attr_rtx (IF_THEN_ELSE, XEXP (right, 0), newleft, newright);\n-\t}\n-      else if (GET_CODE (right) == COND)\n-\t{\n-\t  int allsame = 1;\n-\t  rtx defval;\n-\n-\t  newexp = rtx_alloc (COND);\n-\t  XVEC (newexp, 0) = rtvec_alloc (XVECLEN (right, 0));\n-\t  defval = XEXP (newexp, 1) = operate_exp (op, left, XEXP (right, 1));\n-\n-\t  for (i = 0; i < XVECLEN (right, 0); i += 2)\n-\t    {\n-\t      XVECEXP (newexp, 0, i) = XVECEXP (right, 0, i);\n-\t      XVECEXP (newexp, 0, i + 1)\n-\t\t= operate_exp (op, left, XVECEXP (right, 0, i + 1));\n-\t      if (! rtx_equal_p (XVECEXP (newexp, 0, i + 1),\n-\t\t\t\t defval))\n-\t\tallsame = 0;\n-\t    }\n-\n-\t  /* If the resulting cond is trivial (all alternatives\n-\t     give the same value), optimize it away.  */\n-\t  if (allsame)\n-\t    return operate_exp (op, left, XEXP (right, 1));\n-\n-\t  return newexp;\n-\t}\n-      else\n-\tfatal (\"badly formed attribute value\");\n-    }\n-\n-  /* A hack to prevent expand_units from completely blowing up: ORX_OP does\n-     not associate through IF_THEN_ELSE.  */\n-  else if (op == ORX_OP && GET_CODE (right) == IF_THEN_ELSE)\n-    {\n-      return attr_rtx (IOR, left, right);\n-    }\n-\n-  /* Otherwise, do recursion the other way.  */\n-  else if (GET_CODE (left) == IF_THEN_ELSE)\n-    {\n-      rtx newleft = operate_exp (op, XEXP (left, 1), right);\n-      rtx newright = operate_exp (op, XEXP (left, 2), right);\n-      if (rtx_equal_p (newleft, newright))\n-\treturn newleft;\n-      return attr_rtx (IF_THEN_ELSE, XEXP (left, 0), newleft, newright);\n-    }\n-  else if (GET_CODE (left) == COND)\n-    {\n-      int allsame = 1;\n-      rtx defval;\n-\n-      newexp = rtx_alloc (COND);\n-      XVEC (newexp, 0) = rtvec_alloc (XVECLEN (left, 0));\n-      defval = XEXP (newexp, 1) = operate_exp (op, XEXP (left, 1), right);\n-\n-      for (i = 0; i < XVECLEN (left, 0); i += 2)\n-\t{\n-\t  XVECEXP (newexp, 0, i) = XVECEXP (left, 0, i);\n-\t  XVECEXP (newexp, 0, i + 1)\n-\t    = operate_exp (op, XVECEXP (left, 0, i + 1), right);\n-\t  if (! rtx_equal_p (XVECEXP (newexp, 0, i + 1),\n-\t\t\t     defval))\n-\t    allsame = 0;\n-\t}\n-\n-      /* If the cond is trivial (all alternatives give the same value),\n-\t optimize it away.  */\n-      if (allsame)\n-\treturn operate_exp (op, XEXP (left, 1), right);\n-\n-      /* If the result is the same as the LEFT operand,\n-\t just use that.  */\n-      if (rtx_equal_p (newexp, left))\n-\treturn left;\n-\n-      return newexp;\n-    }\n-\n-  else\n-    fatal (\"badly formed attribute value\");\n-  /* NOTREACHED */\n-  return NULL;\n-}\n-\n-/* Once all attributes and DEFINE_FUNCTION_UNITs have been read, we\n-   construct a number of attributes.\n-\n-   The first produces a function `function_units_used' which is given an\n-   insn and produces an encoding showing which function units are required\n-   for the execution of that insn.  If the value is non-negative, the insn\n-   uses that unit; otherwise, the value is a one's complement mask of units\n-   used.\n-\n-   The second produces a function `result_ready_cost' which is used to\n-   determine the time that the result of an insn will be ready and hence\n-   a worst-case schedule.\n-\n-   Both of these produce quite complex expressions which are then set as the\n-   default value of internal attributes.  Normal attribute simplification\n-   should produce reasonable expressions.\n-\n-   For each unit, a `<name>_unit_ready_cost' function will take an\n-   insn and give the delay until that unit will be ready with the result\n-   and a `<name>_unit_conflict_cost' function is given an insn already\n-   executing on the unit and a candidate to execute and will give the\n-   cost from the time the executing insn started until the candidate\n-   can start (ignore limitations on the number of simultaneous insns).\n-\n-   For each unit, a `<name>_unit_blockage' function is given an insn\n-   already executing on the unit and a candidate to execute and will\n-   give the delay incurred due to function unit conflicts.  The range of\n-   blockage cost values for a given executing insn is given by the\n-   `<name>_unit_blockage_range' function.  These values are encoded in\n-   an int where the upper half gives the minimum value and the lower\n-   half gives the maximum value.  */\n-\n-static void\n-expand_units (void)\n-{\n-  struct function_unit *unit, **unit_num;\n-  struct function_unit_op *op, **op_array, ***unit_ops;\n-  rtx unitsmask;\n-  rtx readycost;\n-  rtx newexp;\n-  const char *str;\n-  int i, j, u, num, nvalues;\n-\n-  /* Rebuild the condition for the unit to share the RTL expressions.\n-     Sharing is required by simplify_by_exploding.  Build the issue delay\n-     expressions.  Validate the expressions we were given for the conditions\n-     and conflict vector.  Then make attributes for use in the conflict\n-     function.  */\n-\n-  for (unit = units; unit; unit = unit->next)\n-    {\n-      unit->condexp = check_attr_test (unit->condexp, 0, unit->first_lineno);\n-\n-      for (op = unit->ops; op; op = op->next)\n-\t{\n-\t  rtx issue_delay = make_numeric_value (op->issue_delay);\n-\t  rtx issue_exp = issue_delay;\n-\n-\t  /* Build, validate, and simplify the issue delay expression.  */\n-\t  if (op->conflict_exp != true_rtx)\n-\t    issue_exp = attr_rtx (IF_THEN_ELSE, op->conflict_exp,\n-\t\t\t\t  issue_exp, make_numeric_value (0));\n-\t  issue_exp = check_attr_value (make_canonical (NULL_ATTR,\n-\t\t\t\t\t\t\tissue_exp),\n-\t\t\t\t\tNULL_ATTR);\n-\t  issue_exp = simplify_knowing (issue_exp, unit->condexp);\n-\t  op->issue_exp = issue_exp;\n-\n-\t  /* Make an attribute for use in the conflict function if needed.  */\n-\t  unit->needs_conflict_function = (unit->issue_delay.min\n-\t\t\t\t\t   != unit->issue_delay.max);\n-\t  if (unit->needs_conflict_function)\n-\t    {\n-\t      str = attr_printf ((strlen (unit->name) + sizeof \"*_cost_\"\n-\t\t\t\t  + MAX_DIGITS),\n-\t\t\t\t \"*%s_cost_%d\", unit->name, op->num);\n-\t      make_internal_attr (str, issue_exp, ATTR_SPECIAL);\n-\t    }\n-\n-\t  /* Validate the condition.  */\n-\t  op->condexp = check_attr_test (op->condexp, 0, op->lineno);\n-\t}\n-    }\n-\n-  /* Compute the mask of function units used.  Initially, the unitsmask is\n-     zero.   Set up a conditional to compute each unit's contribution.  */\n-  unitsmask = make_numeric_value (0);\n-  newexp = rtx_alloc (IF_THEN_ELSE);\n-  XEXP (newexp, 2) = make_numeric_value (0);\n-\n-  /* If we have just a few units, we may be all right expanding the whole\n-     thing.  But the expansion is 2**N in space on the number of opclasses,\n-     so we can't do this for very long -- Alpha and MIPS in particular have\n-     problems with this.  So in that situation, we fall back on an alternate\n-     implementation method.  */\n-#define NUM_UNITOP_CUTOFF 20\n-\n-  if (num_unit_opclasses < NUM_UNITOP_CUTOFF)\n-    {\n-      /* Merge each function unit into the unit mask attributes.  */\n-      for (unit = units; unit; unit = unit->next)\n-\t{\n-\t  XEXP (newexp, 0) = unit->condexp;\n-\t  XEXP (newexp, 1) = make_numeric_value (1 << unit->num);\n-\t  unitsmask = operate_exp (OR_OP, unitsmask, newexp);\n-\t}\n-    }\n-  else\n-    {\n-      /* Merge each function unit into the unit mask attributes.  */\n-      for (unit = units; unit; unit = unit->next)\n-\t{\n-\t  XEXP (newexp, 0) = unit->condexp;\n-\t  XEXP (newexp, 1) = make_numeric_value (1 << unit->num);\n-\t  unitsmask = operate_exp (ORX_OP, unitsmask, attr_copy_rtx (newexp));\n-\t}\n-    }\n-\n-  /* Simplify the unit mask expression, encode it, and make an attribute\n-     for the function_units_used function.  */\n-  unitsmask = simplify_by_exploding (unitsmask);\n-\n-  if (num_unit_opclasses < NUM_UNITOP_CUTOFF)\n-    unitsmask = encode_units_mask (unitsmask);\n-  else\n-    {\n-      /* We can no longer encode unitsmask at compile time, so emit code to\n-         calculate it at runtime.  Rather, put a marker for where we'd do\n-\t the code, and actually output it in write_attr_get().  */\n-      unitsmask = attr_rtx (FFS, unitsmask);\n-    }\n-\n-  make_internal_attr (\"*function_units_used\", unitsmask,\n-\t\t      (ATTR_NEGATIVE_OK | ATTR_FUNC_UNITS));\n-\n-  /* Create an array of ops for each unit.  Add an extra unit for the\n-     result_ready_cost function that has the ops of all other units.  */\n-  unit_ops = xmalloc ((num_units + 1) * sizeof (struct function_unit_op **));\n-  unit_num = xmalloc ((num_units + 1) * sizeof (struct function_unit *));\n-\n-  unit_num[num_units] = unit = xmalloc (sizeof (struct function_unit));\n-  unit->num = num_units;\n-  unit->num_opclasses = 0;\n-\n-  for (unit = units; unit; unit = unit->next)\n-    {\n-      unit_num[num_units]->num_opclasses += unit->num_opclasses;\n-      unit_num[unit->num] = unit;\n-      unit_ops[unit->num] = op_array =\n-\txmalloc (unit->num_opclasses * sizeof (struct function_unit_op *));\n-\n-      for (op = unit->ops; op; op = op->next)\n-\top_array[op->num] = op;\n-    }\n-\n-  /* Compose the array of ops for the extra unit.  */\n-  unit_ops[num_units] = op_array =\n-    xmalloc (unit_num[num_units]->num_opclasses\n-\t    * sizeof (struct function_unit_op *));\n-\n-  for (unit = units, i = 0; unit; i += unit->num_opclasses, unit = unit->next)\n-    memcpy (&op_array[i], unit_ops[unit->num],\n-\t    unit->num_opclasses * sizeof (struct function_unit_op *));\n-\n-  /* Compute the ready cost function for each unit by computing the\n-     condition for each non-default value.  */\n-  for (u = 0; u <= num_units; u++)\n-    {\n-      rtx orexp;\n-      int value;\n-\n-      unit = unit_num[u];\n-      op_array = unit_ops[unit->num];\n-      num = unit->num_opclasses;\n-\n-      /* Sort the array of ops into increasing ready cost order.  */\n-      for (i = 0; i < num; i++)\n-\tfor (j = num - 1; j > i; j--)\n-\t  if (op_array[j - 1]->ready < op_array[j]->ready)\n-\t    {\n-\t      op = op_array[j];\n-\t      op_array[j] = op_array[j - 1];\n-\t      op_array[j - 1] = op;\n-\t    }\n-\n-      /* Determine how many distinct non-default ready cost values there\n-\t are.  We use a default ready cost value of 1.  */\n-      nvalues = 0; value = 1;\n-      for (i = num - 1; i >= 0; i--)\n-\tif (op_array[i]->ready > value)\n-\t  {\n-\t    value = op_array[i]->ready;\n-\t    nvalues++;\n-\t  }\n-\n-      if (nvalues == 0)\n-\treadycost = make_numeric_value (1);\n-      else\n-\t{\n-\t  /* Construct the ready cost expression as a COND of each value from\n-\t     the largest to the smallest.  */\n-\t  readycost = rtx_alloc (COND);\n-\t  XVEC (readycost, 0) = rtvec_alloc (nvalues * 2);\n-\t  XEXP (readycost, 1) = make_numeric_value (1);\n-\n-\t  nvalues = 0;\n-\t  orexp = false_rtx;\n-\t  value = op_array[0]->ready;\n-\t  for (i = 0; i < num; i++)\n-\t    {\n-\t      op = op_array[i];\n-\t      if (op->ready <= 1)\n-\t\tbreak;\n-\t      else if (op->ready == value)\n-\t\torexp = insert_right_side (IOR, orexp, op->condexp, -2, -2);\n-\t      else\n-\t\t{\n-\t\t  XVECEXP (readycost, 0, nvalues * 2) = orexp;\n-\t\t  XVECEXP (readycost, 0, nvalues * 2 + 1)\n-\t\t    = make_numeric_value (value);\n-\t\t  nvalues++;\n-\t\t  value = op->ready;\n-\t\t  orexp = op->condexp;\n-\t\t}\n-\t    }\n-\t  XVECEXP (readycost, 0, nvalues * 2) = orexp;\n-\t  XVECEXP (readycost, 0, nvalues * 2 + 1) = make_numeric_value (value);\n-\t}\n-\n-      if (u < num_units)\n-\t{\n-\t  rtx max_blockage = 0, min_blockage = 0;\n-\n-\t  /* Simplify the readycost expression by only considering insns\n-\t     that use the unit.  */\n-\t  readycost = simplify_knowing (readycost, unit->condexp);\n-\n-\t  /* Determine the blockage cost the executing insn (E) given\n-\t     the candidate insn (C).  This is the maximum of the issue\n-\t     delay, the pipeline delay, and the simultaneity constraint.\n-\t     Each function_unit_op represents the characteristics of the\n-\t     candidate insn, so in the expressions below, C is a known\n-\t     term and E is an unknown term.\n-\n-\t     We compute the blockage cost for each E for every possible C.\n-\t     Thus OP represents E, and READYCOST is a list of values for\n-\t     every possible C.\n-\n-\t     The issue delay function for C is op->issue_exp and is used to\n-\t     write the `<name>_unit_conflict_cost' function.  Symbolically\n-\t     this is \"ISSUE-DELAY (E,C)\".\n-\n-\t     The pipeline delay results form the FIFO constraint on the\n-\t     function unit and is \"READY-COST (E) + 1 - READY-COST (C)\".\n-\n-\t     The simultaneity constraint is based on how long it takes to\n-\t     fill the unit given the minimum issue delay.  FILL-TIME is the\n-\t     constant \"MIN (ISSUE-DELAY (*,*)) * (SIMULTANEITY - 1)\", and\n-\t     the simultaneity constraint is \"READY-COST (E) - FILL-TIME\"\n-\t     if SIMULTANEITY is nonzero and zero otherwise.\n-\n-\t     Thus, BLOCKAGE (E,C) when SIMULTANEITY is zero is\n-\n-\t         MAX (ISSUE-DELAY (E,C),\n-\t\t      READY-COST (E) - (READY-COST (C) - 1))\n-\n-\t     and otherwise\n-\n-\t         MAX (ISSUE-DELAY (E,C),\n-\t\t      READY-COST (E) - (READY-COST (C) - 1),\n-\t\t      READY-COST (E) - FILL-TIME)\n-\n-\t     The `<name>_unit_blockage' function is computed by determining\n-\t     this value for each candidate insn.  As these values are\n-\t     computed, we also compute the upper and lower bounds for\n-\t     BLOCKAGE (E,*).  These are combined to form the function\n-\t     `<name>_unit_blockage_range'.  Finally, the maximum blockage\n-\t     cost, MAX (BLOCKAGE (*,*)), is computed.  */\n-\n-\t  for (op = unit->ops; op; op = op->next)\n-\t    {\n-\t      rtx blockage = op->issue_exp;\n-\t      blockage = simplify_knowing (blockage, unit->condexp);\n-\n-\t      /* Add this op's contribution to MAX (BLOCKAGE (E,*)) and\n-\t\t MIN (BLOCKAGE (E,*)).  */\n-\t      if (max_blockage == 0)\n-\t\tmax_blockage = min_blockage = blockage;\n-\t      else\n-\t\t{\n-\t\t  max_blockage\n-\t\t    = simplify_knowing (operate_exp (MAX_OP, max_blockage,\n-\t\t\t\t\t\t     blockage),\n-\t\t\t\t\tunit->condexp);\n-\t\t  min_blockage\n-\t\t    = simplify_knowing (operate_exp (MIN_OP, min_blockage,\n-\t\t\t\t\t\t     blockage),\n-\t\t\t\t\tunit->condexp);\n-\t\t}\n-\n-\t      /* Make an attribute for use in the blockage function.  */\n-\t      str = attr_printf ((strlen (unit->name) + sizeof \"*_block_\"\n-\t\t\t\t  + MAX_DIGITS),\n-\t\t\t\t \"*%s_block_%d\", unit->name, op->num);\n-\t      make_internal_attr (str, blockage, ATTR_SPECIAL);\n-\t    }\n-\n-\t  /* Record MAX (BLOCKAGE (*,*)).  */\n-\t  {\n-\t    int unknown;\n-\t    unit->max_blockage = max_attr_value (max_blockage, &unknown);\n-\t  }\n-\n-\t  /* See if the upper and lower bounds of BLOCKAGE (E,*) are the\n-\t     same.  If so, the blockage function carries no additional\n-\t     information and is not written.  */\n-\t  newexp = operate_exp (EQ_OP, max_blockage, min_blockage);\n-\t  newexp = simplify_knowing (newexp, unit->condexp);\n-\t  unit->needs_blockage_function\n-\t    = (GET_CODE (newexp) != CONST_STRING\n-\t       || atoi (XSTR (newexp, 0)) != 1);\n-\n-\t  /* If the all values of BLOCKAGE (E,C) have the same value,\n-\t     neither blockage function is written.  */\n-\t  unit->needs_range_function\n-\t    = (unit->needs_blockage_function\n-\t       || GET_CODE (max_blockage) != CONST_STRING);\n-\n-\t  if (unit->needs_range_function)\n-\t    {\n-\t      /* Compute the blockage range function and make an attribute\n-\t\t for writing its value.  */\n-\t      newexp = operate_exp (RANGE_OP, min_blockage, max_blockage);\n-\t      newexp = simplify_knowing (newexp, unit->condexp);\n-\n-\t      str = attr_printf ((strlen (unit->name)\n-\t\t\t\t  + sizeof \"*_unit_blockage_range\"),\n-\t\t\t\t \"*%s_unit_blockage_range\", unit->name);\n-\t      make_internal_attr (str, newexp, (ATTR_STATIC|ATTR_BLOCKAGE|ATTR_UNSIGNED));\n-\t    }\n-\n-\t  str = attr_printf (strlen (unit->name) + sizeof \"*_unit_ready_cost\",\n-\t\t\t     \"*%s_unit_ready_cost\", unit->name);\n-\t  make_internal_attr (str, readycost, ATTR_STATIC);\n-\t}\n-      else\n-        {\n-\t  /* Make an attribute for the ready_cost function.  Simplifying\n-\t     further with simplify_by_exploding doesn't win.  */\n-\t  str = \"*result_ready_cost\";\n-\t  make_internal_attr (str, readycost, ATTR_NONE);\n-\t}\n-    }\n-\n-  /* For each unit that requires a conflict cost function, make an attribute\n-     that maps insns to the operation number.  */\n-  for (unit = units; unit; unit = unit->next)\n-    {\n-      rtx caseexp;\n-\n-      if (! unit->needs_conflict_function\n-\t  && ! unit->needs_blockage_function)\n-\tcontinue;\n-\n-      caseexp = rtx_alloc (COND);\n-      XVEC (caseexp, 0) = rtvec_alloc ((unit->num_opclasses - 1) * 2);\n-\n-      for (op = unit->ops; op; op = op->next)\n-\t{\n-\t  /* Make our adjustment to the COND being computed.  If we are the\n-\t     last operation class, place our values into the default of the\n-\t     COND.  */\n-\t  if (op->num == unit->num_opclasses - 1)\n-\t    {\n-\t      XEXP (caseexp, 1) = make_numeric_value (op->num);\n-\t    }\n-\t  else\n-\t    {\n-\t      XVECEXP (caseexp, 0, op->num * 2) = op->condexp;\n-\t      XVECEXP (caseexp, 0, op->num * 2 + 1)\n-\t\t= make_numeric_value (op->num);\n-\t    }\n-\t}\n-\n-      /* Simplifying caseexp with simplify_by_exploding doesn't win.  */\n-      str = attr_printf (strlen (unit->name) + sizeof \"*_cases\",\n-\t\t\t \"*%s_cases\", unit->name);\n-      make_internal_attr (str, caseexp, ATTR_SPECIAL);\n-    }\n-}\n-\n-/* Simplify EXP given KNOWN_TRUE.  */\n-\n-static rtx\n-simplify_knowing (rtx exp, rtx known_true)\n-{\n-  if (GET_CODE (exp) != CONST_STRING)\n-    {\n-      int unknown = 0, max;\n-      max = max_attr_value (exp, &unknown);\n-      if (! unknown)\n-\t{\n-\t  exp = attr_rtx (IF_THEN_ELSE, known_true, exp,\n-\t\t\t  make_numeric_value (max));\n-\t  exp = simplify_by_exploding (exp);\n-\t}\n-    }\n-  return exp;\n-}\n-\n-/* Translate the CONST_STRING expressions in X to change the encoding of\n-   value.  On input, the value is a bitmask with a one bit for each unit\n-   used; on output, the value is the unit number (zero based) if one\n-   and only one unit is used or the one's complement of the bitmask.  */\n-\n-static rtx\n-encode_units_mask (rtx x)\n-{\n-  int i;\n-  int j;\n-  enum rtx_code code;\n-  const char *fmt;\n-\n-  code = GET_CODE (x);\n-\n-  switch (code)\n-    {\n-    case CONST_STRING:\n-      i = atoi (XSTR (x, 0));\n-      if (i < 0)\n-\t/* The sign bit encodes a one's complement mask.  */\n-\tabort ();\n-      else if (i != 0 && i == (i & -i))\n-\t/* Only one bit is set, so yield that unit number.  */\n-\tfor (j = 0; (i >>= 1) != 0; j++)\n-\t  ;\n-      else\n-\tj = ~i;\n-      return attr_rtx (CONST_STRING, attr_printf (MAX_DIGITS, \"%d\", j));\n-\n-    case REG:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST_VECTOR:\n-    case SYMBOL_REF:\n-    case CODE_LABEL:\n-    case PC:\n-    case CC0:\n-    case EQ_ATTR:\n-    case EQ_ATTR_ALT:\n-      return x;\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Compare the elements.  If any pair of corresponding elements\n-     fail to match, return 0 for the whole things.  */\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      switch (fmt[i])\n-\t{\n-\tcase 'V':\n-\tcase 'E':\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    XVECEXP (x, i, j) = encode_units_mask (XVECEXP (x, i, j));\n-\t  break;\n-\n-\tcase 'e':\n-\t  XEXP (x, i) = encode_units_mask (XEXP (x, i));\n-\t  break;\n-\t}\n-    }\n-  return x;\n-}\n-\n /* Once all attributes and insns have been read and checked, we construct for\n    each attribute value a list of all the insns that have that value for\n    the attribute.  */\n@@ -3638,519 +2873,81 @@ optimize_attrs (void)\n   struct attr_value_list *ivbuf;\n   struct attr_value_list *iv;\n \n-  /* For each insn code, make a list of all the insn_ent's for it,\n-     for all values for all attributes.  */\n-\n-  if (num_insn_ents == 0)\n-    return;\n-\n-  /* Make 2 extra elements, for \"code\" values -2 and -1.  */\n-  insn_code_values = xcalloc ((insn_code_number + 2),\n-\t\t\t      sizeof (struct attr_value_list *));\n-\n-  /* Offset the table address so we can index by -2 or -1.  */\n-  insn_code_values += 2;\n-\n-  iv = ivbuf = xmalloc (num_insn_ents * sizeof (struct attr_value_list));\n-\n-  for (i = 0; i < MAX_ATTRS_INDEX; i++)\n-    for (attr = attrs[i]; attr; attr = attr->next)\n-      for (av = attr->first_value; av; av = av->next)\n-\tfor (ie = av->first_insn; ie; ie = ie->next)\n-\t  {\n-\t    iv->attr = attr;\n-\t    iv->av = av;\n-\t    iv->ie = ie;\n-\t    iv->next = insn_code_values[ie->insn_code];\n-\t    insn_code_values[ie->insn_code] = iv;\n-\t    iv++;\n-\t  }\n-\n-  /* Sanity check on num_insn_ents.  */\n-  if (iv != ivbuf + num_insn_ents)\n-    abort ();\n-\n-  /* Process one insn code at a time.  */\n-  for (i = -2; i < insn_code_number; i++)\n-    {\n-      /* Clear the ATTR_CURR_SIMPLIFIED_P flag everywhere relevant.\n-\t We use it to mean \"already simplified for this insn\".  */\n-      for (iv = insn_code_values[i]; iv; iv = iv->next)\n-\tclear_struct_flag (iv->av->value);\n-\n-      for (iv = insn_code_values[i]; iv; iv = iv->next)\n-\t{\n-\t  struct obstack *old = rtl_obstack;\n-\n-\t  attr = iv->attr;\n-\t  av = iv->av;\n-\t  ie = iv->ie;\n-\t  if (GET_CODE (av->value) != COND)\n-\t    continue;\n-\n-\t  rtl_obstack = temp_obstack;\n-\t  newexp = av->value;\n-\t  while (GET_CODE (newexp) == COND)\n-\t    {\n-\t      rtx newexp2 = simplify_cond (newexp, ie->insn_code,\n-\t\t\t\t\t   ie->insn_index);\n-\t      if (newexp2 == newexp)\n-\t\tbreak;\n-\t      newexp = newexp2;\n-\t    }\n-\n-\t  rtl_obstack = old;\n-\t  if (newexp != av->value)\n-\t    {\n-\t      newexp = attr_copy_rtx (newexp);\n-\t      remove_insn_ent (av, ie);\n-\t      av = get_attr_value (newexp, attr, ie->insn_code);\n-\t      iv->av = av;\n-\t      insert_insn_ent (av, ie);\n-\t    }\n-\t}\n-    }\n-\n-  free (ivbuf);\n-  free (insn_code_values - 2);\n-}\n-\n-/* If EXP is a suitable expression, reorganize it by constructing an\n-   equivalent expression that is a COND with the tests being all combinations\n-   of attribute values and the values being simple constants.  */\n-\n-static rtx\n-simplify_by_exploding (rtx exp)\n-{\n-  rtx list = 0, link, condexp, defval = NULL_RTX;\n-  struct dimension *space;\n-  rtx *condtest, *condval;\n-  int i, j, total, ndim = 0;\n-  int most_tests, num_marks, new_marks;\n-  rtx ret;\n-\n-  /* Locate all the EQ_ATTR expressions.  */\n-  if (! find_and_mark_used_attributes (exp, &list, &ndim) || ndim == 0)\n-    {\n-      unmark_used_attributes (list, 0, 0);\n-      return exp;\n-    }\n-\n-  /* Create an attribute space from the list of used attributes.  For each\n-     dimension in the attribute space, record the attribute, list of values\n-     used, and number of values used.  Add members to the list of values to\n-     cover the domain of the attribute.  This makes the expanded COND form\n-     order independent.  */\n-\n-  space = xmalloc (ndim * sizeof (struct dimension));\n-\n-  total = 1;\n-  for (ndim = 0; list; ndim++)\n-    {\n-      /* Pull the first attribute value from the list and record that\n-\t attribute as another dimension in the attribute space.  */\n-      const char *name = XSTR (XEXP (list, 0), 0);\n-      rtx *prev;\n-\n-      space[ndim].attr = find_attr (&name, 0);\n-      XSTR (XEXP (list, 0), 0) = name;\n-\n-      if (space[ndim].attr == 0\n-\t  || space[ndim].attr->is_numeric)\n-\t{\n-\t  unmark_used_attributes (list, space, ndim);\n-\t  return exp;\n-\t}\n-\n-      /* Add all remaining attribute values that refer to this attribute.  */\n-      space[ndim].num_values = 0;\n-      space[ndim].values = 0;\n-      prev = &list;\n-      for (link = list; link; link = *prev)\n-\tif (! strcmp_check (XSTR (XEXP (link, 0), 0), name))\n-\t  {\n-\t    space[ndim].num_values++;\n-\t    *prev = XEXP (link, 1);\n-\t    XEXP (link, 1) = space[ndim].values;\n-\t    space[ndim].values = link;\n-\t  }\n-\telse\n-\t  prev = &XEXP (link, 1);\n-\n-      /* Add sufficient members to the list of values to make the list\n-\t mutually exclusive and record the total size of the attribute\n-\t space.  */\n-      total *= add_values_to_cover (&space[ndim]);\n-    }\n-\n-  /* Sort the attribute space so that the attributes go from non-constant\n-     to constant and from most values to least values.  */\n-  for (i = 0; i < ndim; i++)\n-    for (j = ndim - 1; j > i; j--)\n-      if ((space[j-1].attr->is_const && !space[j].attr->is_const)\n-\t  || space[j-1].num_values < space[j].num_values)\n-\t{\n-\t  struct dimension tmp;\n-\t  tmp = space[j];\n-\t  space[j] = space[j - 1];\n-\t  space[j - 1] = tmp;\n-\t}\n-\n-  /* Establish the initial current value.  */\n-  for (i = 0; i < ndim; i++)\n-    space[i].current_value = space[i].values;\n-\n-  condtest = xmalloc (total * sizeof (rtx));\n-  condval = xmalloc (total * sizeof (rtx));\n-\n-  /* Expand the tests and values by iterating over all values in the\n-     attribute space.  */\n-  for (i = 0;; i++)\n-    {\n-      condtest[i] = test_for_current_value (space, ndim);\n-      condval[i] = simplify_with_current_value (exp, space, ndim);\n-      if (! increment_current_value (space, ndim))\n-\tbreak;\n-    }\n-  if (i != total - 1)\n-    abort ();\n-\n-  /* We are now finished with the original expression.  */\n-  unmark_used_attributes (0, space, ndim);\n-  free (space);\n-\n-  /* Find the most used constant value and make that the default.  */\n-  most_tests = -1;\n-  for (i = num_marks = 0; i < total; i++)\n-    if (GET_CODE (condval[i]) == CONST_STRING\n-\t&& ! ATTR_EQ_ATTR_P (condval[i]))\n-      {\n-\t/* Mark the unmarked constant value and count how many are marked.  */\n-\tATTR_EQ_ATTR_P (condval[i]) = 1;\n-\tfor (j = new_marks = 0; j < total; j++)\n-\t  if (GET_CODE (condval[j]) == CONST_STRING\n-\t      && ATTR_EQ_ATTR_P (condval[j]))\n-\t    new_marks++;\n-\tif (new_marks - num_marks > most_tests)\n-\t  {\n-\t    most_tests = new_marks - num_marks;\n-\t    defval = condval[i];\n-\t  }\n-\tnum_marks = new_marks;\n-      }\n-  /* Clear all the marks.  */\n-  for (i = 0; i < total; i++)\n-    ATTR_EQ_ATTR_P (condval[i]) = 0;\n-\n-  /* Give up if nothing is constant.  */\n-  if (num_marks == 0)\n-    ret = exp;\n-\n-  /* If all values are the default, use that.  */\n-  else if (total == most_tests)\n-    ret = defval;\n-\n-  /* Make a COND with the most common constant value the default.  (A more\n-     complex method where tests with the same value were combined didn't\n-     seem to improve things.)  */\n-  else\n-    {\n-      condexp = rtx_alloc (COND);\n-      XVEC (condexp, 0) = rtvec_alloc ((total - most_tests) * 2);\n-      XEXP (condexp, 1) = defval;\n-      for (i = j = 0; i < total; i++)\n-\tif (condval[i] != defval)\n-\t  {\n-\t    XVECEXP (condexp, 0, 2 * j) = condtest[i];\n-\t    XVECEXP (condexp, 0, 2 * j + 1) = condval[i];\n-\t    j++;\n-\t  }\n-      ret = condexp;\n-    }\n-  free (condtest);\n-  free (condval);\n-  return ret;\n-}\n-\n-/* Set the ATTR_EQ_ATTR_P flag for all EQ_ATTR expressions in EXP and\n-   verify that EXP can be simplified to a constant term if all the EQ_ATTR\n-   tests have known value.  */\n-\n-static int\n-find_and_mark_used_attributes (rtx exp, rtx *terms, int *nterms)\n-{\n-  int i;\n-\n-  switch (GET_CODE (exp))\n-    {\n-    case EQ_ATTR:\n-      if (! ATTR_EQ_ATTR_P (exp))\n-\t{\n-\t  rtx link = rtx_alloc (EXPR_LIST);\n-\t  XEXP (link, 0) = exp;\n-\t  XEXP (link, 1) = *terms;\n-\t  *terms = link;\n-\t  *nterms += 1;\n-\t  ATTR_EQ_ATTR_P (exp) = 1;\n-\t}\n-      return 1;\n-\n-    case CONST_STRING:\n-    case CONST_INT:\n-      return 1;\n-\n-    case IF_THEN_ELSE:\n-      if (! find_and_mark_used_attributes (XEXP (exp, 2), terms, nterms))\n-\treturn 0;\n-    case IOR:\n-    case AND:\n-      if (! find_and_mark_used_attributes (XEXP (exp, 1), terms, nterms))\n-\treturn 0;\n-    case NOT:\n-      if (! find_and_mark_used_attributes (XEXP (exp, 0), terms, nterms))\n-\treturn 0;\n-      return 1;\n-\n-    case COND:\n-      for (i = 0; i < XVECLEN (exp, 0); i++)\n-\tif (! find_and_mark_used_attributes (XVECEXP (exp, 0, i), terms, nterms))\n-\t  return 0;\n-      if (! find_and_mark_used_attributes (XEXP (exp, 1), terms, nterms))\n-\treturn 0;\n-      return 1;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Clear the ATTR_EQ_ATTR_P flag in all EQ_ATTR expressions on LIST and\n-   in the values of the NDIM-dimensional attribute space SPACE.  */\n-\n-static void\n-unmark_used_attributes (rtx list, struct dimension *space, int ndim)\n-{\n-  rtx link, exp;\n-  int i;\n-\n-  for (i = 0; i < ndim; i++)\n-    unmark_used_attributes (space[i].values, 0, 0);\n-\n-  for (link = list; link; link = XEXP (link, 1))\n-    {\n-      exp = XEXP (link, 0);\n-      if (GET_CODE (exp) == EQ_ATTR)\n-\tATTR_EQ_ATTR_P (exp) = 0;\n-    }\n-}\n-\n-/* Update the attribute dimension DIM so that all values of the attribute\n-   are tested.  Return the updated number of values.  */\n-\n-static int\n-add_values_to_cover (struct dimension *dim)\n-{\n-  struct attr_value *av;\n-  rtx exp, link, *prev;\n-  int nalt = 0;\n-\n-  for (av = dim->attr->first_value; av; av = av->next)\n-    if (GET_CODE (av->value) == CONST_STRING)\n-      nalt++;\n-\n-  if (nalt < dim->num_values)\n-    abort ();\n-  else if (nalt == dim->num_values)\n-    /* OK.  */\n-    ;\n-  else if (nalt * 2 < dim->num_values * 3)\n-    {\n-      /* Most all the values of the attribute are used, so add all the unused\n-\t values.  */\n-      prev = &dim->values;\n-      for (link = dim->values; link; link = *prev)\n-\tprev = &XEXP (link, 1);\n-\n-      for (av = dim->attr->first_value; av; av = av->next)\n-\tif (GET_CODE (av->value) == CONST_STRING)\n-\t  {\n-\t    exp = attr_eq (dim->attr->name, XSTR (av->value, 0));\n-\t    if (ATTR_EQ_ATTR_P (exp))\n-\t      continue;\n-\n-\t    link = rtx_alloc (EXPR_LIST);\n-\t    XEXP (link, 0) = exp;\n-\t    XEXP (link, 1) = 0;\n-\t    *prev = link;\n-\t    prev = &XEXP (link, 1);\n-\t  }\n-      dim->num_values = nalt;\n-    }\n-  else\n-    {\n-      rtx orexp = false_rtx;\n-\n-      /* Very few values are used, so compute a mutually exclusive\n-\t expression.  (We could do this for numeric values if that becomes\n-\t important.)  */\n-      prev = &dim->values;\n-      for (link = dim->values; link; link = *prev)\n-\t{\n-\t  orexp = insert_right_side (IOR, orexp, XEXP (link, 0), -2, -2);\n-\t  prev = &XEXP (link, 1);\n-\t}\n-      link = rtx_alloc (EXPR_LIST);\n-      XEXP (link, 0) = attr_rtx (NOT, orexp);\n-      XEXP (link, 1) = 0;\n-      *prev = link;\n-      dim->num_values++;\n-    }\n-  return dim->num_values;\n-}\n-\n-/* Increment the current value for the NDIM-dimensional attribute space SPACE\n-   and return FALSE if the increment overflowed.  */\n-\n-static int\n-increment_current_value (struct dimension *space, int ndim)\n-{\n-  int i;\n-\n-  for (i = ndim - 1; i >= 0; i--)\n-    {\n-      if ((space[i].current_value = XEXP (space[i].current_value, 1)) == 0)\n-\tspace[i].current_value = space[i].values;\n-      else\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n-/* Construct an expression corresponding to the current value for the\n-   NDIM-dimensional attribute space SPACE.  */\n-\n-static rtx\n-test_for_current_value (struct dimension *space, int ndim)\n-{\n-  int i;\n-  rtx exp = true_rtx;\n-\n-  for (i = 0; i < ndim; i++)\n-    exp = insert_right_side (AND, exp, XEXP (space[i].current_value, 0),\n-\t\t\t     -2, -2);\n-\n-  return exp;\n-}\n-\n-/* Given the current value of the NDIM-dimensional attribute space SPACE,\n-   set the corresponding EQ_ATTR expressions to that value and reduce\n-   the expression EXP as much as possible.  On input [and output], all\n-   known EQ_ATTR expressions are set to FALSE.  */\n-\n-static rtx\n-simplify_with_current_value (rtx exp, struct dimension *space, int ndim)\n-{\n-  int i;\n-  rtx x;\n-\n-  /* Mark each current value as TRUE.  */\n-  for (i = 0; i < ndim; i++)\n-    {\n-      x = XEXP (space[i].current_value, 0);\n-      if (GET_CODE (x) == EQ_ATTR)\n-\tATTR_EQ_ATTR_P (x) = 0;\n-    }\n-\n-  exp = simplify_with_current_value_aux (exp);\n-\n-  /* Change each current value back to FALSE.  */\n-  for (i = 0; i < ndim; i++)\n-    {\n-      x = XEXP (space[i].current_value, 0);\n-      if (GET_CODE (x) == EQ_ATTR)\n-\tATTR_EQ_ATTR_P (x) = 1;\n-    }\n-\n-  return exp;\n-}\n+  /* For each insn code, make a list of all the insn_ent's for it,\n+     for all values for all attributes.  */\n \n-/* Reduce the expression EXP based on the ATTR_EQ_ATTR_P settings of\n-   all EQ_ATTR expressions.  */\n+  if (num_insn_ents == 0)\n+    return;\n \n-static rtx\n-simplify_with_current_value_aux (rtx exp)\n-{\n-  int i;\n-  rtx cond;\n+  /* Make 2 extra elements, for \"code\" values -2 and -1.  */\n+  insn_code_values = xcalloc ((insn_code_number + 2),\n+\t\t\t      sizeof (struct attr_value_list *));\n \n-  switch (GET_CODE (exp))\n-    {\n-    case EQ_ATTR:\n-      if (ATTR_EQ_ATTR_P (exp))\n-\treturn false_rtx;\n-      else\n-\treturn true_rtx;\n-    case CONST_STRING:\n-    case CONST_INT:\n-      return exp;\n+  /* Offset the table address so we can index by -2 or -1.  */\n+  insn_code_values += 2;\n \n-    case IF_THEN_ELSE:\n-      cond = simplify_with_current_value_aux (XEXP (exp, 0));\n-      if (cond == true_rtx)\n-\treturn simplify_with_current_value_aux (XEXP (exp, 1));\n-      else if (cond == false_rtx)\n-\treturn simplify_with_current_value_aux (XEXP (exp, 2));\n-      else\n-\treturn attr_rtx (IF_THEN_ELSE, cond,\n-\t\t\t simplify_with_current_value_aux (XEXP (exp, 1)),\n-\t\t\t simplify_with_current_value_aux (XEXP (exp, 2)));\n+  iv = ivbuf = xmalloc (num_insn_ents * sizeof (struct attr_value_list));\n \n-    case IOR:\n-      cond = simplify_with_current_value_aux (XEXP (exp, 1));\n-      if (cond == true_rtx)\n-\treturn cond;\n-      else if (cond == false_rtx)\n-\treturn simplify_with_current_value_aux (XEXP (exp, 0));\n-      else\n-\treturn attr_rtx (IOR, cond,\n-\t\t\t simplify_with_current_value_aux (XEXP (exp, 0)));\n+  for (i = 0; i < MAX_ATTRS_INDEX; i++)\n+    for (attr = attrs[i]; attr; attr = attr->next)\n+      for (av = attr->first_value; av; av = av->next)\n+\tfor (ie = av->first_insn; ie; ie = ie->next)\n+\t  {\n+\t    iv->attr = attr;\n+\t    iv->av = av;\n+\t    iv->ie = ie;\n+\t    iv->next = insn_code_values[ie->insn_code];\n+\t    insn_code_values[ie->insn_code] = iv;\n+\t    iv++;\n+\t  }\n \n-    case AND:\n-      cond = simplify_with_current_value_aux (XEXP (exp, 1));\n-      if (cond == true_rtx)\n-\treturn simplify_with_current_value_aux (XEXP (exp, 0));\n-      else if (cond == false_rtx)\n-\treturn cond;\n-      else\n-\treturn attr_rtx (AND, cond,\n-\t\t\t simplify_with_current_value_aux (XEXP (exp, 0)));\n+  /* Sanity check on num_insn_ents.  */\n+  if (iv != ivbuf + num_insn_ents)\n+    abort ();\n \n-    case NOT:\n-      cond = simplify_with_current_value_aux (XEXP (exp, 0));\n-      if (cond == true_rtx)\n-\treturn false_rtx;\n-      else if (cond == false_rtx)\n-\treturn true_rtx;\n-      else\n-\treturn attr_rtx (NOT, cond);\n+  /* Process one insn code at a time.  */\n+  for (i = -2; i < insn_code_number; i++)\n+    {\n+      /* Clear the ATTR_CURR_SIMPLIFIED_P flag everywhere relevant.\n+\t We use it to mean \"already simplified for this insn\".  */\n+      for (iv = insn_code_values[i]; iv; iv = iv->next)\n+\tclear_struct_flag (iv->av->value);\n \n-    case COND:\n-      for (i = 0; i < XVECLEN (exp, 0); i += 2)\n+      for (iv = insn_code_values[i]; iv; iv = iv->next)\n \t{\n-\t  cond = simplify_with_current_value_aux (XVECEXP (exp, 0, i));\n-\t  if (cond == true_rtx)\n-\t    return simplify_with_current_value_aux (XVECEXP (exp, 0, i + 1));\n-\t  else if (cond == false_rtx)\n+\t  struct obstack *old = rtl_obstack;\n+\n+\t  attr = iv->attr;\n+\t  av = iv->av;\n+\t  ie = iv->ie;\n+\t  if (GET_CODE (av->value) != COND)\n \t    continue;\n-\t  else\n-\t    abort (); /* With all EQ_ATTR's of known value, a case should\n-\t\t\t have been selected.  */\n-\t}\n-      return simplify_with_current_value_aux (XEXP (exp, 1));\n \n-    default:\n-      abort ();\n+\t  rtl_obstack = temp_obstack;\n+\t  newexp = av->value;\n+\t  while (GET_CODE (newexp) == COND)\n+\t    {\n+\t      rtx newexp2 = simplify_cond (newexp, ie->insn_code,\n+\t\t\t\t\t   ie->insn_index);\n+\t      if (newexp2 == newexp)\n+\t\tbreak;\n+\t      newexp = newexp2;\n+\t    }\n+\n+\t  rtl_obstack = old;\n+\t  if (newexp != av->value)\n+\t    {\n+\t      newexp = attr_copy_rtx (newexp);\n+\t      remove_insn_ent (av, ie);\n+\t      av = get_attr_value (newexp, attr, ie->insn_code);\n+\t      iv->av = av;\n+\t      insert_insn_ent (av, ie);\n+\t    }\n+\t}\n     }\n+\n+  free (ivbuf);\n+  free (insn_code_values - 2);\n }\n \n /* Clear the ATTR_CURR_SIMPLIFIED_P flag in EXP and its subexpressions.  */\n@@ -4454,97 +3251,6 @@ gen_delay (rtx def, int lineno)\n   delays = delay;\n }\n \n-/* Process a DEFINE_FUNCTION_UNIT.\n-\n-   This gives information about a function unit contained in the CPU.\n-   We fill in a `struct function_unit_op' and a `struct function_unit'\n-   with information used later by `expand_unit'.  */\n-\n-static void\n-gen_unit (rtx def, int lineno)\n-{\n-  struct function_unit *unit;\n-  struct function_unit_op *op;\n-  const char *name = XSTR (def, 0);\n-  int multiplicity = XINT (def, 1);\n-  int simultaneity = XINT (def, 2);\n-  rtx condexp = XEXP (def, 3);\n-  int ready_cost = MAX (XINT (def, 4), 1);\n-  int issue_delay = MAX (XINT (def, 5), 1);\n-\n-  /* See if we have already seen this function unit.  If so, check that\n-     the multiplicity and simultaneity values are the same.  If not, make\n-     a structure for this function unit.  */\n-  for (unit = units; unit; unit = unit->next)\n-    if (! strcmp (unit->name, name))\n-      {\n-\tif (unit->multiplicity != multiplicity\n-\t    || unit->simultaneity != simultaneity)\n-\t  {\n-\t    message_with_line (lineno,\n-\t\t\t       \"differing specifications given for function unit %s\",\n-\t\t\t       unit->name);\n-\t    message_with_line (unit->first_lineno, \"previous definition\");\n-\t    have_error = 1;\n-\t    return;\n-\t  }\n-\tbreak;\n-      }\n-\n-  if (unit == 0)\n-    {\n-      unit = oballoc (sizeof (struct function_unit));\n-      unit->name = name;\n-      unit->multiplicity = multiplicity;\n-      unit->simultaneity = simultaneity;\n-      unit->issue_delay.min = unit->issue_delay.max = issue_delay;\n-      unit->num = num_units++;\n-      unit->num_opclasses = 0;\n-      unit->condexp = false_rtx;\n-      unit->ops = 0;\n-      unit->next = units;\n-      unit->first_lineno = lineno;\n-      units = unit;\n-    }\n-  else\n-    XSTR (def, 0) = unit->name;\n-\n-  /* Make a new operation class structure entry and initialize it.  */\n-  op = oballoc (sizeof (struct function_unit_op));\n-  op->condexp = condexp;\n-  op->num = unit->num_opclasses++;\n-  op->ready = ready_cost;\n-  op->issue_delay = issue_delay;\n-  op->next = unit->ops;\n-  op->lineno = lineno;\n-  unit->ops = op;\n-  num_unit_opclasses++;\n-\n-  /* Set our issue expression based on whether or not an optional conflict\n-     vector was specified.  */\n-  if (XVEC (def, 6))\n-    {\n-      /* Compute the IOR of all the specified expressions.  */\n-      rtx orexp = false_rtx;\n-      int i;\n-\n-      for (i = 0; i < XVECLEN (def, 6); i++)\n-\torexp = insert_right_side (IOR, orexp, XVECEXP (def, 6, i), -2, -2);\n-\n-      op->conflict_exp = orexp;\n-      extend_range (&unit->issue_delay, 1, issue_delay);\n-    }\n-  else\n-    {\n-      op->conflict_exp = true_rtx;\n-      extend_range (&unit->issue_delay, issue_delay, issue_delay);\n-    }\n-\n-  /* Merge our conditional into that of the function unit so we can determine\n-     which insns are used by the function unit.  */\n-  unit->condexp = insert_right_side (IOR, unit->condexp, op->condexp, -2, -2);\n-}\n-\n /* Given a piece of RTX, print a C expression to test its truth value.\n    We use AND and IOR both for logical and bit-wise operations, so\n    interpret them as logical unless they are inside a comparison expression.\n@@ -5041,37 +3747,15 @@ write_attr_get (struct attr_desc *attr)\n     }\n \n   printf (\"{\\n\");\n+  printf (\"  switch (recog_memoized (insn))\\n\");\n+  printf (\"    {\\n\");\n \n-  if (GET_CODE (common_av->value) == FFS)\n-    {\n-      rtx p = XEXP (common_av->value, 0);\n-\n-      /* No need to emit code to abort if the insn is unrecognized; the\n-         other get_attr_foo functions will do that when we call them.  */\n-\n-      write_toplevel_expr (p);\n-\n-      printf (\"\\n  if (accum && accum == (accum & -accum))\\n\");\n-      printf (\"    {\\n\");\n-      printf (\"      int i;\\n\");\n-      printf (\"      for (i = 0; accum >>= 1; ++i) continue;\\n\");\n-      printf (\"      accum = i;\\n\");\n-      printf (\"    }\\n  else\\n\");\n-      printf (\"    accum = ~accum;\\n\");\n-      printf (\"  return accum;\\n}\\n\\n\");\n-    }\n-  else\n-    {\n-      printf (\"  switch (recog_memoized (insn))\\n\");\n-      printf (\"    {\\n\");\n-\n-      for (av = attr->first_value; av; av = av->next)\n-\tif (av != common_av)\n-\t  write_attr_case (attr, av, 1, \"return\", \";\", 4, true_rtx);\n+  for (av = attr->first_value; av; av = av->next)\n+    if (av != common_av)\n+      write_attr_case (attr, av, 1, \"return\", \";\", 4, true_rtx);\n \n-      write_attr_case (attr, common_av, 0, \"return\", \";\", 4, true_rtx);\n-      printf (\"    }\\n}\\n\\n\");\n-    }\n+  write_attr_case (attr, common_av, 0, \"return\", \";\", 4, true_rtx);\n+  printf (\"    }\\n}\\n\\n\");\n }\n \n /* Given an AND tree of known true terms (because we are inside an `if' with\n@@ -5307,56 +3991,7 @@ write_expr_attr_cache (rtx p, struct attr_desc *attr)\n   return 0;\n }\n \n-/* Evaluate an expression at top level.  A front end to write_test_expr,\n-   in which we cache attribute values and break up excessively large\n-   expressions to cater to older compilers.  */\n-\n-static void\n-write_toplevel_expr (rtx p)\n-{\n-  struct attr_desc *attr;\n-  int i;\n-\n-  for (i = 0; i < MAX_ATTRS_INDEX; ++i)\n-    for (attr = attrs[i]; attr; attr = attr->next)\n-      if (!attr->is_const)\n-\twrite_expr_attr_cache (p, attr);\n-\n-  printf (\"  unsigned long accum = 0;\\n\\n\");\n-\n-  while (GET_CODE (p) == IOR)\n-    {\n-      rtx e;\n-      if (GET_CODE (XEXP (p, 0)) == IOR)\n-\te = XEXP (p, 1), p = XEXP (p, 0);\n-      else\n-\te = XEXP (p, 0), p = XEXP (p, 1);\n-\n-      printf (\"  accum |= \");\n-      write_test_expr (e, 3);\n-      printf (\";\\n\");\n-    }\n-  printf (\"  accum |= \");\n-  write_test_expr (p, 3);\n-  printf (\";\\n\");\n-}\n-\n-/* Utilities to write names in various forms.  */\n-\n-static void\n-write_unit_name (const char *prefix, int num, const char *suffix)\n-{\n-  struct function_unit *unit;\n-\n-  for (unit = units; unit; unit = unit->next)\n-    if (unit->num == num)\n-      {\n-\tprintf (\"%s%s%s\", prefix, unit->name, suffix);\n-\treturn;\n-      }\n-\n-  printf (\"%s<unknown>%s\", prefix, suffix);\n-}\n+/* Utilities to write in various forms.  */\n \n static void\n write_attr_valueq (struct attr_desc *attr, const char *s)\n@@ -5367,32 +4002,7 @@ write_attr_valueq (struct attr_desc *attr, const char *s)\n \n       printf (\"%d\", num);\n \n-      /* Make the blockage range values and function units used values easier\n-         to read.  */\n-      if (attr->func_units_p)\n-\t{\n-\t  if (num == -1)\n-\t    printf (\" /* units: none */\");\n-\t  else if (num >= 0)\n-\t    write_unit_name (\" /* units: \", num, \" */\");\n-\t  else\n-\t    {\n-\t      int i;\n-\t      const char *sep = \" /* units: \";\n-\t      for (i = 0, num = ~num; num; i++, num >>= 1)\n-\t\tif (num & 1)\n-\t\t  {\n-\t\t    write_unit_name (sep, i, (num == 1) ? \" */\" : \"\");\n-\t\t    sep = \", \";\n-\t\t  }\n-\t    }\n-\t}\n-\n-      else if (attr->blockage_p)\n-\tprintf (\" /* min %d, max %d */\", num >> (HOST_BITS_PER_INT / 2),\n-\t\tnum & ((1 << (HOST_BITS_PER_INT / 2)) - 1));\n-\n-      else if (num > 9 || num < 0)\n+      if (num > 9 || num < 0)\n \tprintf (\" /* 0x%x */\", num);\n     }\n   else\n@@ -5613,175 +4223,6 @@ write_eligible_delay (const char *kind)\n   printf (\"}\\n\\n\");\n }\n \n-/* Write routines to compute conflict cost for function units.  Then write a\n-   table describing the available function units.  */\n-\n-static void\n-write_function_unit_info (void)\n-{\n-  struct function_unit *unit;\n-  int i;\n-\n-  /* Write out conflict routines for function units.  Don't bother writing\n-     one if there is only one issue delay value.  */\n-\n-  for (unit = units; unit; unit = unit->next)\n-    {\n-      if (unit->needs_blockage_function)\n-\twrite_complex_function (unit, \"blockage\", \"block\");\n-\n-      /* If the minimum and maximum conflict costs are the same, there\n-\t is only one value, so we don't need a function.  */\n-      if (! unit->needs_conflict_function)\n-\t{\n-\t  unit->default_cost = make_numeric_value (unit->issue_delay.max);\n-\t  continue;\n-\t}\n-\n-      /* The function first computes the case from the candidate insn.  */\n-      unit->default_cost = make_numeric_value (0);\n-      write_complex_function (unit, \"conflict_cost\", \"cost\");\n-    }\n-\n-  /* Now that all functions have been written, write the table describing\n-     the function units.   The name is included for documentation purposes\n-     only.  */\n-\n-  printf (\"const struct function_unit_desc function_units[] = {\\n\");\n-\n-  /* Write out the descriptions in numeric order, but don't force that order\n-     on the list.  Doing so increases the runtime of genattrtab.c.  */\n-  for (i = 0; i < num_units; i++)\n-    {\n-      for (unit = units; unit; unit = unit->next)\n-\tif (unit->num == i)\n-\t  break;\n-\n-      printf (\"  {\\\"%s\\\", %d, %d, %d, %s, %d, %s_unit_ready_cost, \",\n-\t      unit->name, 1 << unit->num, unit->multiplicity,\n-\t      unit->simultaneity, XSTR (unit->default_cost, 0),\n-\t      unit->issue_delay.max, unit->name);\n-\n-      if (unit->needs_conflict_function)\n-\tprintf (\"%s_unit_conflict_cost, \", unit->name);\n-      else\n-\tprintf (\"0, \");\n-\n-      printf (\"%d, \", unit->max_blockage);\n-\n-      if (unit->needs_range_function)\n-\tprintf (\"%s_unit_blockage_range, \", unit->name);\n-      else\n-\tprintf (\"0, \");\n-\n-      if (unit->needs_blockage_function)\n-\tprintf (\"%s_unit_blockage\", unit->name);\n-      else\n-\tprintf (\"0\");\n-\n-      printf (\"}, \\n\");\n-    }\n-\n-  if (num_units == 0)\n-    printf (\"{\\\"dummy\\\", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} /* a dummy element */\");\n-  printf (\"};\\n\\n\");\n-}\n-\n-static void\n-write_complex_function (struct function_unit *unit,\n-\t\t\tconst char *name,\n-\t\t\tconst char *connection)\n-{\n-  struct attr_desc *case_attr, *attr;\n-  struct attr_value *av, *common_av;\n-  rtx value;\n-  char str[256];\n-  const char *pstr;\n-  int using_case;\n-  int i;\n-\n-  printf (\"static int\\n\");\n-  printf (\"%s_unit_%s (rtx executing_insn, rtx candidate_insn)\\n\",\n-\t  unit->name, name);\n-  printf (\"{\\n\");\n-  printf (\"  rtx insn;\\n\");\n-  printf (\"  int casenum;\\n\\n\");\n-  printf (\"  insn = executing_insn;\\n\");\n-  printf (\"  switch (recog_memoized (insn))\\n\");\n-  printf (\"    {\\n\");\n-\n-  /* Write the `switch' statement to get the case value.  */\n-  if (strlen (unit->name) + sizeof \"*_cases\" > 256)\n-    abort ();\n-  sprintf (str, \"*%s_cases\", unit->name);\n-  pstr = str;\n-  case_attr = find_attr (&pstr, 0);\n-  if (! case_attr)\n-    abort ();\n-  common_av = find_most_used (case_attr);\n-\n-  for (av = case_attr->first_value; av; av = av->next)\n-    if (av != common_av)\n-      write_attr_case (case_attr, av, 1,\n-\t\t       \"casenum =\", \";\", 4, unit->condexp);\n-\n-  write_attr_case (case_attr, common_av, 0,\n-\t\t   \"casenum =\", \";\", 4, unit->condexp);\n-  printf (\"    }\\n\\n\");\n-\n-  /* Now write an outer switch statement on each case.  Then write\n-     the tests on the executing function within each.  */\n-  printf (\"  insn = candidate_insn;\\n\");\n-  printf (\"  switch (casenum)\\n\");\n-  printf (\"    {\\n\");\n-\n-  for (i = 0; i < unit->num_opclasses; i++)\n-    {\n-      /* Ensure using this case.  */\n-      using_case = 0;\n-      for (av = case_attr->first_value; av; av = av->next)\n-\tif (av->num_insns\n-\t    && contained_in_p (make_numeric_value (i), av->value))\n-\t  using_case = 1;\n-\n-      if (! using_case)\n-\tcontinue;\n-\n-      printf (\"    case %d:\\n\", i);\n-      sprintf (str, \"*%s_%s_%d\", unit->name, connection, i);\n-      pstr = str;\n-      attr = find_attr (&pstr, 0);\n-      if (! attr)\n-\tabort ();\n-\n-      /* If single value, just write it.  */\n-      value = find_single_value (attr);\n-      if (value)\n-\twrite_attr_set (attr, 6, value, \"return\", \";\\n\", true_rtx, -2, -2);\n-      else\n-\t{\n-\t  common_av = find_most_used (attr);\n-\t  printf (\"      switch (recog_memoized (insn))\\n\");\n-\t  printf (\"\\t{\\n\");\n-\n-\t  for (av = attr->first_value; av; av = av->next)\n-\t    if (av != common_av)\n-\t      write_attr_case (attr, av, 1,\n-\t\t\t       \"return\", \";\", 8, unit->condexp);\n-\n-\t  write_attr_case (attr, common_av, 0,\n-\t\t\t   \"return\", \";\", 8, unit->condexp);\n-\t  printf (\"      }\\n\\n\");\n-\t}\n-    }\n-\n-  /* This default case should not be needed, but gcc's analysis is not\n-     good enough to realize that the default case is not needed for the\n-     second switch statement.  */\n-  printf (\"    default:\\n      abort ();\\n\");\n-  printf (\"    }\\n}\\n\\n\");\n-}\n-\n /* This page contains miscellaneous utility routines.  */\n \n /* Given a pointer to a (char *), return a malloc'ed string containing the\n@@ -5837,7 +4278,7 @@ find_attr (const char **name_p, int create)\n   attr->name = DEF_ATTR_STRING (name);\n   attr->first_value = attr->default_val = NULL;\n   attr->is_numeric = attr->negative_ok = attr->is_const = attr->is_special = 0;\n-  attr->unsigned_p = attr->func_units_p = attr->blockage_p = attr->static_p = 0;\n+  attr->unsigned_p = attr->static_p = 0;\n   attr->next = attrs[index];\n   attrs[index] = attr;\n \n@@ -5862,8 +4303,6 @@ make_internal_attr (const char *name, rtx value, int special)\n   attr->is_special = (special & ATTR_SPECIAL) != 0;\n   attr->negative_ok = (special & ATTR_NEGATIVE_OK) != 0;\n   attr->unsigned_p = (special & ATTR_UNSIGNED) != 0;\n-  attr->func_units_p = (special & ATTR_FUNC_UNITS) != 0;\n-  attr->blockage_p = (special & ATTR_BLOCKAGE) != 0;\n   attr->static_p = (special & ATTR_STATIC) != 0;\n   attr->default_val = get_attr_value (value, attr, -2);\n }\n@@ -5887,28 +4326,6 @@ find_most_used (struct attr_desc *attr)\n   return most_used;\n }\n \n-/* If an attribute only has a single value used, return it.  Otherwise\n-   return NULL.  */\n-\n-static rtx\n-find_single_value (struct attr_desc *attr)\n-{\n-  struct attr_value *av;\n-  rtx unique_value;\n-\n-  unique_value = NULL;\n-  for (av = attr->first_value; av; av = av->next)\n-    if (av->num_insns)\n-      {\n-\tif (unique_value)\n-\t  return NULL;\n-\telse\n-\t  unique_value = av->value;\n-      }\n-\n-  return unique_value;\n-}\n-\n /* Return (attr_value \"n\") */\n \n rtx\n@@ -5933,15 +4350,6 @@ make_numeric_value (int n)\n   return exp;\n }\n \n-static void\n-extend_range (struct range *range, int min, int max)\n-{\n-  if (range->min > min)\n-    range->min = min;\n-  if (range->max < max)\n-    range->max = max;\n-}\n-\n static rtx\n copy_rtx_unchanging (rtx orig)\n {\n@@ -6052,10 +4460,6 @@ from the machine description file `md'.  */\\n\\n\");\n \t  gen_delay (desc, lineno);\n \t  break;\n \n-\tcase DEFINE_FUNCTION_UNIT:\n-\t  gen_unit (desc, lineno);\n-\t  break;\n-\n \tcase DEFINE_CPU_UNIT:\n \t  gen_cpu_unit (desc);\n \t  break;\n@@ -6128,14 +4532,10 @@ from the machine description file `md'.  */\\n\\n\");\n   if (num_delays)\n     expand_delays ();\n \n-  if (num_units || num_dfa_decls)\n-    {\n-      /* Expand DEFINE_FUNCTION_UNIT information into new attributes.  */\n-      expand_units ();\n-      /* Build DFA, output some functions and expand DFA information\n-\t into new attributes.  */\n-      expand_automata ();\n-    }\n+  /* Build DFA, output some functions and expand DFA information\n+     to new attributes.  */\n+  if (num_dfa_decls)\n+    expand_automata ();\n \n   printf (\"#include \\\"config.h\\\"\\n\");\n   printf (\"#include \\\"system.h\\\"\\n\");\n@@ -6191,8 +4591,7 @@ from the machine description file `md'.  */\\n\\n\");\n   optimize_attrs ();\n \n   /* Now write out all the `gen_attr_...' routines.  Do these before the\n-     special routines (specifically before write_function_unit_info), so\n-     that they get defined before they are used.  */\n+     special routines so that they get defined before they are used.  */\n \n   for (i = 0; i < MAX_ATTRS_INDEX; i++)\n     for (attr = attrs[i]; attr; attr = attr->next)\n@@ -6224,14 +4623,10 @@ from the machine description file `md'.  */\\n\\n\");\n \twrite_eligible_delay (\"annul_false\");\n     }\n \n-  if (num_units || num_dfa_decls)\n-    {\n-      /* Write out information about function units.  */\n-      write_function_unit_info ();\n-      /* Output code for pipeline hazards recognition based on DFA\n-\t (deterministic finite state automata.  */\n-      write_automata ();\n-    }\n+  /* Output code for pipeline hazards recognition based on DFA\n+     (deterministic finite-state automata).  */\n+  if (num_dfa_decls)\n+    write_automata ();\n \n   /* Write out constant delay slot info.  */\n   write_const_num_delay_slots ();"}, {"sha": "ad782cc818eab35d37ab9b0793faa1bc79ee914b", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 110, "deletions": 552, "changes": 662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -54,13 +54,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    as short as possible.  The remaining insns are then scheduled in\n    remaining slots.\n \n-   Function unit conflicts are resolved during forward list scheduling\n-   by tracking the time when each insn is committed to the schedule\n-   and from that, the time the function units it uses must be free.\n-   As insns on the ready list are considered for scheduling, those\n-   that would result in a blockage of the already committed insns are\n-   queued until no blockage will result.\n-\n    The following list shows the order in which we want to break ties\n    among insns in the ready list:\n \n@@ -225,9 +218,7 @@ static rtx note_list;\n    \"Pending\" list have their dependencies satisfied and move to either\n    the \"Ready\" list or the \"Queued\" set depending on whether\n    sufficient time has passed to make them ready.  As time passes,\n-   insns move from the \"Queued\" set to the \"Ready\" list.  Insns may\n-   move from the \"Ready\" list to the \"Queued\" set if they are blocked\n-   due to a function unit conflict.\n+   insns move from the \"Queued\" set to the \"Ready\" list.\n \n    The \"Pending\" list (P) are the insns in the INSN_DEPEND of the unscheduled\n    insns, i.e., those that are ready, queued, and pending.\n@@ -238,43 +229,30 @@ static rtx note_list;\n \n    The transition (R->S) is implemented in the scheduling loop in\n    `schedule_block' when the best insn to schedule is chosen.\n-   The transition (R->Q) is implemented in `queue_insn' when an\n-   insn is found to have a function unit conflict with the already\n-   committed insns.\n    The transitions (P->R and P->Q) are implemented in `schedule_insn' as\n    insns move from the ready list to the scheduled list.\n    The transition (Q->R) is implemented in 'queue_to_insn' as time\n    passes or stalls are introduced.  */\n \n /* Implement a circular buffer to delay instructions until sufficient\n-   time has passed.  For the old pipeline description interface,\n-   INSN_QUEUE_SIZE is a power of two larger than MAX_BLOCKAGE and\n-   MAX_READY_COST computed by genattr.c.  For the new pipeline\n-   description interface, MAX_INSN_QUEUE_INDEX is a power of two minus\n-   one which is larger than maximal time of instruction execution\n-   computed by genattr.c on the base maximal time of functional unit\n-   reservations and getting a result.  This is the longest time an\n-   insn may be queued.  */\n-\n-#define MAX_INSN_QUEUE_INDEX max_insn_queue_index_macro_value\n+   time has passed.  For the new pipeline description interface,\n+   MAX_INSN_QUEUE_INDEX is a power of two minus one which is larger\n+   than maximal time of instruction execution computed by genattr.c on\n+   the base maximal time of functional unit reservations and getting a\n+   result.  This is the longest time an insn may be queued.  */\n \n static rtx *insn_queue;\n static int q_ptr = 0;\n static int q_size = 0;\n-#define NEXT_Q(X) (((X)+1) & MAX_INSN_QUEUE_INDEX)\n-#define NEXT_Q_AFTER(X, C) (((X)+C) & MAX_INSN_QUEUE_INDEX)\n-\n-/* The following variable defines value for macro\n-   MAX_INSN_QUEUE_INDEX.  */\n-static int max_insn_queue_index_macro_value;\n+#define NEXT_Q(X) (((X)+1) & max_insn_queue_index)\n+#define NEXT_Q_AFTER(X, C) (((X)+C) & max_insn_queue_index)\n \n /* The following variable value refers for all current and future\n    reservations of the processor units.  */\n state_t curr_state;\n \n /* The following variable value is size of memory representing all\n-   current and future reservations of the processor units.  It is used\n-   only by DFA based scheduler.  */\n+   current and future reservations of the processor units.  */\n static size_t dfa_state_size;\n \n /* The following array is used to find the best insn from ready when\n@@ -460,14 +438,6 @@ haifa_classify_insn (rtx insn)\n \n /* Forward declarations.  */\n \n-/* The scheduler using only DFA description should never use the\n-   following five functions:  */\n-static unsigned int blockage_range (int, rtx);\n-static void clear_units (void);\n-static void schedule_unit (int, rtx, int);\n-static int actual_hazard (int, rtx, int, int);\n-static int potential_hazard (int, rtx, int);\n-\n static int priority (rtx);\n static int rank_for_schedule (const void *, const void *);\n static void swap_sort (rtx *, int);\n@@ -518,7 +488,7 @@ static rtx move_insn1 (rtx, rtx);\n static rtx move_insn (rtx, rtx);\n \n /* The following functions are used to implement multi-pass scheduling\n-   on the first cycle.  It is used only for DFA based scheduler.  */\n+   on the first cycle.  */\n static rtx ready_element (struct ready_list *, int);\n static rtx ready_remove (struct ready_list *, int);\n static int max_issue (struct ready_list *, int *);\n@@ -543,309 +513,6 @@ schedule_insns (FILE *dump_file ATTRIBUTE_UNUSED)\n \n static rtx last_scheduled_insn;\n \n-/* Compute the function units used by INSN.  This caches the value\n-   returned by function_units_used.  A function unit is encoded as the\n-   unit number if the value is non-negative and the complement of a\n-   mask if the value is negative.  A function unit index is the\n-   non-negative encoding.  The scheduler using only DFA description\n-   should never use the following function.  */\n-\n-HAIFA_INLINE int\n-insn_unit (rtx insn)\n-{\n-  int unit = INSN_UNIT (insn);\n-\n-  if (unit == 0)\n-    {\n-      recog_memoized (insn);\n-\n-      /* A USE insn, or something else we don't need to understand.\n-         We can't pass these directly to function_units_used because it will\n-         trigger a fatal error for unrecognizable insns.  */\n-      if (INSN_CODE (insn) < 0)\n-\tunit = -1;\n-      else\n-\t{\n-\t  unit = function_units_used (insn);\n-\t  /* Increment non-negative values so we can cache zero.  */\n-\t  if (unit >= 0)\n-\t    unit++;\n-\t}\n-      /* We only cache 16 bits of the result, so if the value is out of\n-         range, don't cache it.  */\n-      if (FUNCTION_UNITS_SIZE < HOST_BITS_PER_SHORT\n-\t  || unit >= 0\n-\t  || (unit & ~((1 << (HOST_BITS_PER_SHORT - 1)) - 1)) == 0)\n-\tINSN_UNIT (insn) = unit;\n-    }\n-  return (unit > 0 ? unit - 1 : unit);\n-}\n-\n-/* Compute the blockage range for executing INSN on UNIT.  This caches\n-   the value returned by the blockage_range_function for the unit.\n-   These values are encoded in an int where the upper half gives the\n-   minimum value and the lower half gives the maximum value.  The\n-   scheduler using only DFA description should never use the following\n-   function.  */\n-\n-HAIFA_INLINE static unsigned int\n-blockage_range (int unit, rtx insn)\n-{\n-  unsigned int blockage = INSN_BLOCKAGE (insn);\n-  unsigned int range;\n-\n-  if ((int) UNIT_BLOCKED (blockage) != unit + 1)\n-    {\n-      range = function_units[unit].blockage_range_function (insn);\n-      /* We only cache the blockage range for one unit and then only if\n-         the values fit.  */\n-      if (HOST_BITS_PER_INT >= UNIT_BITS + 2 * BLOCKAGE_BITS)\n-\tINSN_BLOCKAGE (insn) = ENCODE_BLOCKAGE (unit + 1, range);\n-    }\n-  else\n-    range = BLOCKAGE_RANGE (blockage);\n-\n-  return range;\n-}\n-\n-/* A vector indexed by function unit instance giving the last insn to\n-   use the unit.  The value of the function unit instance index for\n-   unit U instance I is (U + I * FUNCTION_UNITS_SIZE).  The scheduler\n-   using only DFA description should never use the following variable.  */\n-#if FUNCTION_UNITS_SIZE\n-static rtx unit_last_insn[FUNCTION_UNITS_SIZE * MAX_MULTIPLICITY];\n-#else\n-static rtx unit_last_insn[1];\n-#endif\n-\n-/* A vector indexed by function unit instance giving the minimum time\n-   when the unit will unblock based on the maximum blockage cost.  The\n-   scheduler using only DFA description should never use the following\n-   variable.  */\n-#if FUNCTION_UNITS_SIZE\n-static int unit_tick[FUNCTION_UNITS_SIZE * MAX_MULTIPLICITY];\n-#else\n-static int unit_tick[1];\n-#endif\n-\n-/* A vector indexed by function unit number giving the number of insns\n-   that remain to use the unit.  The scheduler using only DFA\n-   description should never use the following variable.  */\n-#if FUNCTION_UNITS_SIZE\n-static int unit_n_insns[FUNCTION_UNITS_SIZE];\n-#else\n-static int unit_n_insns[1];\n-#endif\n-\n-/* Access the unit_last_insn array.  Used by the visualization code.\n-   The scheduler using only DFA description should never use the\n-   following function.  */\n-\n-rtx\n-get_unit_last_insn (int instance)\n-{\n-  return unit_last_insn[instance];\n-}\n-\n-/* Reset the function unit state to the null state.  */\n-\n-static void\n-clear_units (void)\n-{\n-  memset (unit_last_insn, 0, sizeof (unit_last_insn));\n-  memset (unit_tick, 0, sizeof (unit_tick));\n-  memset (unit_n_insns, 0, sizeof (unit_n_insns));\n-}\n-\n-/* Return the issue-delay of an insn.  The scheduler using only DFA\n-   description should never use the following function.  */\n-\n-HAIFA_INLINE int\n-insn_issue_delay (rtx insn)\n-{\n-  int i, delay = 0;\n-  int unit = insn_unit (insn);\n-\n-  /* Efficiency note: in fact, we are working 'hard' to compute a\n-     value that was available in md file, and is not available in\n-     function_units[] structure.  It would be nice to have this\n-     value there, too.  */\n-  if (unit >= 0)\n-    {\n-      if (function_units[unit].blockage_range_function &&\n-\t  function_units[unit].blockage_function)\n-\tdelay = function_units[unit].blockage_function (insn, insn);\n-    }\n-  else\n-    for (i = 0, unit = ~unit; unit; i++, unit >>= 1)\n-      if ((unit & 1) != 0 && function_units[i].blockage_range_function\n-\t  && function_units[i].blockage_function)\n-\tdelay = MAX (delay, function_units[i].blockage_function (insn, insn));\n-\n-  return delay;\n-}\n-\n-/* Return the actual hazard cost of executing INSN on the unit UNIT,\n-   instance INSTANCE at time CLOCK if the previous actual hazard cost\n-   was COST.  The scheduler using only DFA description should never\n-   use the following function.  */\n-\n-HAIFA_INLINE int\n-actual_hazard_this_instance (int unit, int instance, rtx insn, int clock, int cost)\n-{\n-  int tick = unit_tick[instance]; /* Issue time of the last issued insn.  */\n-\n-  if (tick - clock > cost)\n-    {\n-      /* The scheduler is operating forward, so unit's last insn is the\n-         executing insn and INSN is the candidate insn.  We want a\n-         more exact measure of the blockage if we execute INSN at CLOCK\n-         given when we committed the execution of the unit's last insn.\n-\n-         The blockage value is given by either the unit's max blockage\n-         constant, blockage range function, or blockage function.  Use\n-         the most exact form for the given unit.  */\n-\n-      if (function_units[unit].blockage_range_function)\n-\t{\n-\t  if (function_units[unit].blockage_function)\n-\t    tick += (function_units[unit].blockage_function\n-\t\t     (unit_last_insn[instance], insn)\n-\t\t     - function_units[unit].max_blockage);\n-\t  else\n-\t    tick += ((int) MAX_BLOCKAGE_COST (blockage_range (unit, insn))\n-\t\t     - function_units[unit].max_blockage);\n-\t}\n-      if (tick - clock > cost)\n-\tcost = tick - clock;\n-    }\n-  return cost;\n-}\n-\n-/* Record INSN as having begun execution on the units encoded by UNIT\n-   at time CLOCK.  The scheduler using only DFA description should\n-   never use the following function.  */\n-\n-static void\n-schedule_unit (int unit, rtx insn, int clock)\n-{\n-  int i;\n-\n-  if (unit >= 0)\n-    {\n-      int instance = unit;\n-#if MAX_MULTIPLICITY > 1\n-      /* Find the first free instance of the function unit and use that\n-         one.  We assume that one is free.  */\n-      for (i = function_units[unit].multiplicity - 1; i > 0; i--)\n-\t{\n-\t  if (!actual_hazard_this_instance (unit, instance, insn, clock, 0))\n-\t    break;\n-\t  instance += FUNCTION_UNITS_SIZE;\n-\t}\n-#endif\n-      unit_last_insn[instance] = insn;\n-      unit_tick[instance] = (clock + function_units[unit].max_blockage);\n-    }\n-  else\n-    for (i = 0, unit = ~unit; unit; i++, unit >>= 1)\n-      if ((unit & 1) != 0)\n-\tschedule_unit (i, insn, clock);\n-}\n-\n-/* Return the actual hazard cost of executing INSN on the units\n-   encoded by UNIT at time CLOCK if the previous actual hazard cost\n-   was COST.  The scheduler using only DFA description should never\n-   use the following function.  */\n-\n-static int\n-actual_hazard (int unit, rtx insn, int clock, int cost)\n-{\n-  int i;\n-\n-  if (unit >= 0)\n-    {\n-      /* Find the instance of the function unit with the minimum hazard.  */\n-      int instance = unit;\n-      int best_cost = actual_hazard_this_instance (unit, instance, insn,\n-\t\t\t\t\t\t   clock, cost);\n-#if MAX_MULTIPLICITY > 1\n-      int this_cost;\n-\n-      if (best_cost > cost)\n-\t{\n-\t  for (i = function_units[unit].multiplicity - 1; i > 0; i--)\n-\t    {\n-\t      instance += FUNCTION_UNITS_SIZE;\n-\t      this_cost = actual_hazard_this_instance (unit, instance, insn,\n-\t\t\t\t\t\t       clock, cost);\n-\t      if (this_cost < best_cost)\n-\t\t{\n-\t\t  best_cost = this_cost;\n-\t\t  if (this_cost <= cost)\n-\t\t    break;\n-\t\t}\n-\t    }\n-\t}\n-#endif\n-      cost = MAX (cost, best_cost);\n-    }\n-  else\n-    for (i = 0, unit = ~unit; unit; i++, unit >>= 1)\n-      if ((unit & 1) != 0)\n-\tcost = actual_hazard (i, insn, clock, cost);\n-\n-  return cost;\n-}\n-\n-/* Return the potential hazard cost of executing an instruction on the\n-   units encoded by UNIT if the previous potential hazard cost was\n-   COST.  An insn with a large blockage time is chosen in preference\n-   to one with a smaller time; an insn that uses a unit that is more\n-   likely to be used is chosen in preference to one with a unit that\n-   is less used.  We are trying to minimize a subsequent actual\n-   hazard.  The scheduler using only DFA description should never use\n-   the following function.  */\n-\n-HAIFA_INLINE static int\n-potential_hazard (int unit, rtx insn, int cost)\n-{\n-  int i, ncost;\n-  unsigned int minb, maxb;\n-\n-  if (unit >= 0)\n-    {\n-      minb = maxb = function_units[unit].max_blockage;\n-      if (maxb > 1)\n-\t{\n-\t  if (function_units[unit].blockage_range_function)\n-\t    {\n-\t      maxb = minb = blockage_range (unit, insn);\n-\t      maxb = MAX_BLOCKAGE_COST (maxb);\n-\t      minb = MIN_BLOCKAGE_COST (minb);\n-\t    }\n-\n-\t  if (maxb > 1)\n-\t    {\n-\t      /* Make the number of instructions left dominate.  Make the\n-\t         minimum delay dominate the maximum delay.  If all these\n-\t         are the same, use the unit number to add an arbitrary\n-\t         ordering.  Other terms can be added.  */\n-\t      ncost = minb * 0x40 + maxb;\n-\t      ncost *= (unit_n_insns[unit] - 1) * 0x1000 + unit;\n-\t      if (ncost > cost)\n-\t\tcost = ncost;\n-\t    }\n-\t}\n-    }\n-  else\n-    for (i = 0, unit = ~unit; unit; i++, unit >>= 1)\n-      if ((unit & 1) != 0)\n-\tcost = potential_hazard (i, insn, cost);\n-\n-  return cost;\n-}\n-\n /* Compute cost of executing INSN given the dependence LINK on the insn USED.\n    This is the number of cycles between instruction issue and\n    instruction results.  */\n@@ -868,12 +535,7 @@ insn_cost (rtx insn, rtx link, rtx used)\n \t}\n       else\n \t{\n-\t  if (targetm.sched.use_dfa_pipeline_interface\n-\t      && targetm.sched.use_dfa_pipeline_interface ())\n-\t    cost = insn_default_latency (insn);\n-\t  else\n-\t    cost = result_ready_cost (insn);\n-\n+\t  cost = insn_default_latency (insn);\n \t  if (cost < 0)\n \t    cost = 0;\n \n@@ -892,23 +554,19 @@ insn_cost (rtx insn, rtx link, rtx used)\n     cost = 0;\n   else\n     {\n-      if (targetm.sched.use_dfa_pipeline_interface\n-\t  && targetm.sched.use_dfa_pipeline_interface ())\n+      if (INSN_CODE (insn) >= 0)\n \t{\n-\t  if (INSN_CODE (insn) >= 0)\n+\t  if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n+\t    cost = 0;\n+\t  else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n \t    {\n-\t      if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n-\t\tcost = 0;\n-\t      else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n-\t\t{\n-\t\t  cost = (insn_default_latency (insn)\n-\t\t\t  - insn_default_latency (used));\n-\t\t  if (cost <= 0)\n-\t\t    cost = 1;\n-\t\t}\n-\t      else if (bypass_p (insn))\n-\t\tcost = insn_latency (insn, used);\n+\t      cost = (insn_default_latency (insn)\n+\t\t      - insn_default_latency (used));\n+\t      if (cost <= 0)\n+\t\tcost = 1;\n \t    }\n+\t  else if (bypass_p (insn))\n+\t    cost = insn_latency (insn, used);\n \t}\n \n       if (targetm.sched.adjust_cost)\n@@ -1208,19 +866,15 @@ adjust_priority (rtx prev)\n HAIFA_INLINE static void\n advance_one_cycle (void)\n {\n-  if (targetm.sched.use_dfa_pipeline_interface\n-      && targetm.sched.use_dfa_pipeline_interface ())\n-    {\n-      if (targetm.sched.dfa_pre_cycle_insn)\n-\tstate_transition (curr_state,\n-\t\t\t  targetm.sched.dfa_pre_cycle_insn ());\n-\n-      state_transition (curr_state, NULL);\n-\n-      if (targetm.sched.dfa_post_cycle_insn)\n-\tstate_transition (curr_state,\n-\t\t\t  targetm.sched.dfa_post_cycle_insn ());\n-    }\n+  if (targetm.sched.dfa_pre_cycle_insn)\n+    state_transition (curr_state,\n+\t\t      targetm.sched.dfa_pre_cycle_insn ());\n+\n+  state_transition (curr_state, NULL);\n+  \n+  if (targetm.sched.dfa_post_cycle_insn)\n+    state_transition (curr_state,\n+\t\t      targetm.sched.dfa_post_cycle_insn ());\n }\n \n /* Clock at which the previous instruction was issued.  */\n@@ -1237,16 +891,9 @@ schedule_insn (rtx insn, struct ready_list *ready, int clock)\n {\n   rtx link;\n   int advance = 0;\n-  int unit = 0;\n   int premature_issue = 0;\n \n-  if (!targetm.sched.use_dfa_pipeline_interface\n-      || !targetm.sched.use_dfa_pipeline_interface ())\n-    unit = insn_unit (insn);\n-\n-  if (targetm.sched.use_dfa_pipeline_interface\n-      && targetm.sched.use_dfa_pipeline_interface ()\n-      && sched_verbose >= 1)\n+  if (sched_verbose >= 1)\n     {\n       char buf[2048];\n \n@@ -1260,27 +907,6 @@ schedule_insn (rtx insn, struct ready_list *ready, int clock)\n \tprint_reservation (sched_dump, insn);\n       fputc ('\\n', sched_dump);\n     }\n-  else if (sched_verbose >= 2)\n-    {\n-      fprintf (sched_dump, \";;\\t\\t--> scheduling insn <<<%d>>> on unit \",\n-\t       INSN_UID (insn));\n-      insn_print_units (insn);\n-      fputc ('\\n', sched_dump);\n-    }\n-\n-  if (!targetm.sched.use_dfa_pipeline_interface\n-      || !targetm.sched.use_dfa_pipeline_interface ())\n-    {\n-      if (sched_verbose && unit == -1)\n-\tvisualize_no_unit (insn);\n-\n-\n-      if (MAX_BLOCKAGE > 1 || issue_rate > 1 || sched_verbose)\n-\tschedule_unit (unit, insn, clock);\n-\n-      if (INSN_DEPEND (insn) == 0)\n-\treturn 0;\n-    }\n \n   if (INSN_TICK (insn) > clock)\n     {\n@@ -1780,7 +1406,7 @@ queue_to_ready (struct ready_list *ready)\n     {\n       int stalls;\n \n-      for (stalls = 1; stalls <= MAX_INSN_QUEUE_INDEX; stalls++)\n+      for (stalls = 1; stalls <= max_insn_queue_index; stalls++)\n \t{\n \t  if ((link = insn_queue[NEXT_Q_AFTER (q_ptr, stalls)]))\n \t    {\n@@ -1807,11 +1433,6 @@ queue_to_ready (struct ready_list *ready)\n \t  advance_one_cycle ();\n \t}\n \n-      if ((!targetm.sched.use_dfa_pipeline_interface\n-\t   || !targetm.sched.use_dfa_pipeline_interface ())\n-\t  && sched_verbose && stalls)\n-\tvisualize_stall_cycles (stalls);\n-\n       q_ptr = NEXT_Q_AFTER (q_ptr, stalls);\n       clock_var += stalls;\n     }\n@@ -1903,7 +1524,7 @@ early_queue_to_ready (state_t state, struct ready_list *ready)\n   if (! flag_sched_stalled_insns)   \n     return 0;\n \n-  for (stalls = 0; stalls <= MAX_INSN_QUEUE_INDEX; stalls++)\n+  for (stalls = 0; stalls <= max_insn_queue_index; stalls++)\n     {\n       if ((link = insn_queue[NEXT_Q_AFTER (q_ptr, stalls)]))\n \t{\n@@ -2266,34 +1887,23 @@ schedule_block (int b, int rgn_n_insns)\n \t       (reload_completed ? \"after\" : \"before\"));\n       fprintf (sched_dump, \";;   ======================================================\\n\");\n       fprintf (sched_dump, \"\\n\");\n-\n-      visualize_alloc ();\n-      init_block_visualization ();\n     }\n \n-  if (targetm.sched.use_dfa_pipeline_interface\n-      && targetm.sched.use_dfa_pipeline_interface ())\n-    state_reset (curr_state);\n-  else\n-    clear_units ();\n+  state_reset (curr_state);\n \n   /* Allocate the ready list.  */\n   ready.veclen = rgn_n_insns + 1 + issue_rate;\n   ready.first = ready.veclen - 1;\n   ready.vec = xmalloc (ready.veclen * sizeof (rtx));\n   ready.n_ready = 0;\n \n-  if (targetm.sched.use_dfa_pipeline_interface\n-      && targetm.sched.use_dfa_pipeline_interface ())\n-    {\n-      /* It is used for first cycle multipass scheduling.  */\n-      temp_state = alloca (dfa_state_size);\n-      ready_try = xcalloc ((rgn_n_insns + 1), sizeof (char));\n-      choice_stack = xmalloc ((rgn_n_insns + 1)\n-\t\t\t      * sizeof (struct choice_entry));\n-      for (i = 0; i <= rgn_n_insns; i++)\n-\tchoice_stack[i].state = xmalloc (dfa_state_size);\n-    }\n+  /* It is used for first cycle multipass scheduling.  */\n+  temp_state = alloca (dfa_state_size);\n+  ready_try = xcalloc ((rgn_n_insns + 1), sizeof (char));\n+  choice_stack = xmalloc ((rgn_n_insns + 1)\n+\t\t\t  * sizeof (struct choice_entry));\n+  for (i = 0; i <= rgn_n_insns; i++)\n+    choice_stack[i].state = xmalloc (dfa_state_size);\n \n   (*current_sched_info->init_ready_list) (&ready);\n \n@@ -2308,14 +1918,8 @@ schedule_block (int b, int rgn_n_insns)\n   q_ptr = 0;\n   q_size = 0;\n \n-  if (!targetm.sched.use_dfa_pipeline_interface\n-      || !targetm.sched.use_dfa_pipeline_interface ())\n-    max_insn_queue_index_macro_value = INSN_QUEUE_SIZE - 1;\n-  else\n-    max_insn_queue_index_macro_value = max_insn_queue_index;\n-\n-  insn_queue = alloca ((MAX_INSN_QUEUE_INDEX + 1) * sizeof (rtx));\n-  memset (insn_queue, 0, (MAX_INSN_QUEUE_INDEX + 1) * sizeof (rtx));\n+  insn_queue = alloca ((max_insn_queue_index + 1) * sizeof (rtx));\n+  memset (insn_queue, 0, (max_insn_queue_index + 1) * sizeof (rtx));\n   last_clock_var = -1;\n \n   /* Start just before the beginning of time.  */\n@@ -2391,78 +1995,65 @@ schedule_block (int b, int rgn_n_insns)\n \t      debug_ready_list (&ready);\n \t    }\n \n-\t  if (!targetm.sched.use_dfa_pipeline_interface\n-\t      || !targetm.sched.use_dfa_pipeline_interface ())\n+\t  if (ready.n_ready == 0 \n+\t      && can_issue_more \n+\t      && reload_completed) \n \t    {\n-\t      if (ready.n_ready == 0 || !can_issue_more\n-\t\t  || !(*current_sched_info->schedule_more_p) ())\n-\t\tbreak;\n-\t      insn = ready_remove_first (&ready);\n-\t      cost = actual_hazard (insn_unit (insn), insn, clock_var, 0);\n+\t      /* Allow scheduling insns directly from the queue in case\n+\t\t there's nothing better to do (ready list is empty) but\n+\t\t there are still vacant dispatch slots in the current cycle.  */\n+\t      if (sched_verbose >= 6)\n+\t\tfprintf(sched_dump,\";;\\t\\tSecond chance\\n\");\n+\t      memcpy (temp_state, curr_state, dfa_state_size);\n+\t      if (early_queue_to_ready (temp_state, &ready))\n+\t\tready_sort (&ready);\n \t    }\n-\t  else\n-\t    {\n-\t      if (ready.n_ready == 0 \n-\t\t  && can_issue_more \n-\t\t  && reload_completed) \n-\t\t{\n-\t\t  /* Allow scheduling insns directly from the queue in case\n-\t\t     there's nothing better to do (ready list is empty) but\n-\t\t     there are still vacant dispatch slots in the current cycle.  */\n-\t\t  if (sched_verbose >= 6)\n-\t\t    fprintf(sched_dump,\";;\\t\\tSecond chance\\n\");\n-\t\t  memcpy (temp_state, curr_state, dfa_state_size);\n-\t\t  if (early_queue_to_ready (temp_state, &ready))\n-\t\t    ready_sort (&ready);\n-\t\t}\n \n-\t      if (ready.n_ready == 0 || !can_issue_more\n-\t\t  || state_dead_lock_p (curr_state)\n-\t\t  || !(*current_sched_info->schedule_more_p) ())\n-\t\tbreak;\n+\t  if (ready.n_ready == 0 || !can_issue_more\n+\t      || state_dead_lock_p (curr_state)\n+\t      || !(*current_sched_info->schedule_more_p) ())\n+\t    break;\n \n-\t      /* Select and remove the insn from the ready list.  */\n-\t      if (sort_p)\n-\t\tinsn = choose_ready (&ready);\n-\t      else\n-\t\tinsn = ready_remove_first (&ready);\n+\t  /* Select and remove the insn from the ready list.  */\n+\t  if (sort_p)\n+\t    insn = choose_ready (&ready);\n+\t  else\n+\t    insn = ready_remove_first (&ready);\n \n-\t      if (targetm.sched.dfa_new_cycle\n-\t\t  && targetm.sched.dfa_new_cycle (sched_dump, sched_verbose,\n-\t\t\t\t\t\t  insn, last_clock_var,\n-\t\t\t\t\t\t  clock_var, &sort_p))\n-\t\t{\n-\t\t  ready_add (&ready, insn);\n-\t\t  break;\n-\t\t}\n+\t  if (targetm.sched.dfa_new_cycle\n+\t      && targetm.sched.dfa_new_cycle (sched_dump, sched_verbose,\n+\t\t\t\t\t      insn, last_clock_var,\n+\t\t\t\t\t      clock_var, &sort_p))\n+\t    {\n+\t      ready_add (&ready, insn);\n+\t      break;\n+\t    }\n \n-\t      sort_p = TRUE;\n-\t      memcpy (temp_state, curr_state, dfa_state_size);\n-\t      if (recog_memoized (insn) < 0)\n-\t\t{\n-\t\t  asm_p = (GET_CODE (PATTERN (insn)) == ASM_INPUT\n-\t\t\t   || asm_noperands (PATTERN (insn)) >= 0);\n-\t\t  if (!first_cycle_insn_p && asm_p)\n-\t\t    /* This is asm insn which is tryed to be issued on the\n-\t\t       cycle not first.  Issue it on the next cycle.  */\n-\t\t    cost = 1;\n-\t\t  else\n-\t\t    /* A USE insn, or something else we don't need to\n-\t\t       understand.  We can't pass these directly to\n-\t\t       state_transition because it will trigger a\n-\t\t       fatal error for unrecognizable insns.  */\n-\t\t    cost = 0;\n-\t\t}\n+\t  sort_p = TRUE;\n+\t  memcpy (temp_state, curr_state, dfa_state_size);\n+\t  if (recog_memoized (insn) < 0)\n+\t    {\n+\t      asm_p = (GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t\t       || asm_noperands (PATTERN (insn)) >= 0);\n+\t      if (!first_cycle_insn_p && asm_p)\n+\t\t/* This is asm insn which is tryed to be issued on the\n+\t\t   cycle not first.  Issue it on the next cycle.  */\n+\t\tcost = 1;\n \t      else\n-\t\t{\n-\t\t  cost = state_transition (temp_state, insn);\n-\t\t  if (cost < 0)\n-\t\t    cost = 0;\n-\t\t  else if (cost == 0)\n-\t\t    cost = 1;\n-\t\t}\n+\t\t/* A USE insn, or something else we don't need to\n+\t\t   understand.  We can't pass these directly to\n+\t\t   state_transition because it will trigger a\n+\t\t   fatal error for unrecognizable insns.  */\n+\t\tcost = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      cost = state_transition (temp_state, insn);\n+\t      if (cost < 0)\n+\t\tcost = 0;\n+\t      else if (cost == 0)\n+\t\tcost = 1;\n \t    }\n-\n \n \t  if (cost >= 1)\n \t    {\n@@ -2475,13 +2066,9 @@ schedule_block (int b, int rgn_n_insns)\n \n \t  last_scheduled_insn = move_insn (insn, last_scheduled_insn);\n \n-\t  if (targetm.sched.use_dfa_pipeline_interface\n-\t      && targetm.sched.use_dfa_pipeline_interface ())\n-\t    {\n-\t      if (memcmp (curr_state, temp_state, dfa_state_size) != 0)\n-\t\tcycle_issued_insns++;\n-\t      memcpy (curr_state, temp_state, dfa_state_size);\n-\t    }\n+\t  if (memcmp (curr_state, temp_state, dfa_state_size) != 0)\n+\t    cycle_issued_insns++;\n+\t  memcpy (curr_state, temp_state, dfa_state_size);\n \n \t  if (targetm.sched.variable_issue)\n \t    can_issue_more =\n@@ -2521,12 +2108,6 @@ schedule_block (int b, int rgn_n_insns)\n \t\t\t\t\t&ready.n_ready, clock_var);\n \t    }\n \t}\n-\n-      if ((!targetm.sched.use_dfa_pipeline_interface\n-\t   || !targetm.sched.use_dfa_pipeline_interface ())\n-\t  && sched_verbose)\n-\t/* Debug info.  */\n-\tvisualize_scheduled_insns (clock_var);\n     }\n \n   if (targetm.sched.md_finish)\n@@ -2537,9 +2118,6 @@ schedule_block (int b, int rgn_n_insns)\n     {\n       fprintf (sched_dump, \";;\\tReady list (final):  \");\n       debug_ready_list (&ready);\n-      if (!targetm.sched.use_dfa_pipeline_interface\n-\t  || !targetm.sched.use_dfa_pipeline_interface ())\n-\tprint_block_visualization (\"\");\n     }\n \n   /* Sanity check -- queue must be empty now.  Meaningless if region has\n@@ -2598,22 +2176,17 @@ schedule_block (int b, int rgn_n_insns)\n \t       clock_var, INSN_UID (head));\n       fprintf (sched_dump, \";;   new tail = %d\\n\\n\",\n \t       INSN_UID (tail));\n-      visualize_free ();\n     }\n \n   current_sched_info->head = head;\n   current_sched_info->tail = tail;\n \n   free (ready.vec);\n \n-  if (targetm.sched.use_dfa_pipeline_interface\n-      && targetm.sched.use_dfa_pipeline_interface ())\n-    {\n-      free (ready_try);\n-      for (i = 0; i <= rgn_n_insns; i++)\n-\tfree (choice_stack [i].state);\n-      free (choice_stack);\n-    }\n+  free (ready_try);\n+  for (i = 0; i <= rgn_n_insns; i++)\n+    free (choice_stack [i].state);\n+  free (choice_stack);\n }\n \f\n /* Set_priorities: compute priority of each insn in the block.  */\n@@ -2700,19 +2273,15 @@ sched_init (FILE *dump_file)\n   for (i = 0; i < old_max_uid; i++)\n     h_i_d [i].cost = -1;\n \n-  if (targetm.sched.use_dfa_pipeline_interface\n-      && targetm.sched.use_dfa_pipeline_interface ())\n-    {\n-      if (targetm.sched.init_dfa_pre_cycle_insn)\n-\ttargetm.sched.init_dfa_pre_cycle_insn ();\n+  if (targetm.sched.init_dfa_pre_cycle_insn)\n+    targetm.sched.init_dfa_pre_cycle_insn ();\n \n-      if (targetm.sched.init_dfa_post_cycle_insn)\n-\ttargetm.sched.init_dfa_post_cycle_insn ();\n+  if (targetm.sched.init_dfa_post_cycle_insn)\n+    targetm.sched.init_dfa_post_cycle_insn ();\n \n-      dfa_start ();\n-      dfa_state_size = state_size ();\n-      curr_state = xmalloc (dfa_state_size);\n-    }\n+  dfa_start ();\n+  dfa_state_size = state_size ();\n+  curr_state = xmalloc (dfa_state_size);\n \n   h_i_d[0].luid = 0;\n   luid = 1;\n@@ -2769,12 +2338,6 @@ sched_init (FILE *dump_file)\n \t}\n     }\n \n-  if ((!targetm.sched.use_dfa_pipeline_interface\n-       || !targetm.sched.use_dfa_pipeline_interface ())\n-      && sched_verbose)\n-    /* Find units used in this function, for visualization.  */\n-    init_target_units ();\n-\n   /* ??? Add a NOTE after the last insn of the last basic block.  It is not\n      known why this is done.  */\n \n@@ -2805,13 +2368,8 @@ void\n sched_finish (void)\n {\n   free (h_i_d);\n-\n-  if (targetm.sched.use_dfa_pipeline_interface\n-      && targetm.sched.use_dfa_pipeline_interface ())\n-    {\n-      free (curr_state);\n-      dfa_finish ();\n-    }\n+  free (curr_state);\n+  dfa_finish ();\n   free_dependency_caches ();\n   end_alias_analysis ();\n   if (write_symbols != NO_DEBUG)"}, {"sha": "d9cb45c83c1f2ed09c3069d8add6b996edbc0144", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -812,14 +812,8 @@ sms_schedule (FILE *dump_file)\n   int max_bb_index = last_basic_block;\n   struct df *df;\n \n-  /* SMS uses the DFA interface.  */\n-  if (! targetm.sched.use_dfa_pipeline_interface\n-      || ! (*targetm.sched.use_dfa_pipeline_interface) ())\n-    return;\n-\n   stats_file = dump_file;\n \n-\n   /* Initialize issue_rate.  */\n   if (targetm.sched.issue_rate)\n     {\n@@ -1990,19 +1984,15 @@ add_node_to_ps (partial_schedule_ptr ps, ddg_node_ptr node, int cycle)\n static void\n advance_one_cycle (void)\n {\n-  if (targetm.sched.use_dfa_pipeline_interface\n-      && (*targetm.sched.use_dfa_pipeline_interface) ())\n-    {\n-      if (targetm.sched.dfa_pre_cycle_insn)\n-\tstate_transition (curr_state,\n-\t\t\t  (*targetm.sched.dfa_pre_cycle_insn) ());\n+  if (targetm.sched.dfa_pre_cycle_insn)\n+    state_transition (curr_state,\n+\t\t      (*targetm.sched.dfa_pre_cycle_insn) ());\n \n-      state_transition (curr_state, NULL);\n+  state_transition (curr_state, NULL);\n \n-      if (targetm.sched.dfa_post_cycle_insn)\n-\tstate_transition (curr_state,\n-\t\t\t  (*targetm.sched.dfa_post_cycle_insn) ());\n-    }\n+  if (targetm.sched.dfa_post_cycle_insn)\n+    state_transition (curr_state,\n+\t\t      (*targetm.sched.dfa_post_cycle_insn) ());\n }\n \n /* Checks if PS has resource conflicts according to DFA, starting from\n@@ -2013,10 +2003,6 @@ ps_has_conflicts (partial_schedule_ptr ps, int from, int to)\n {\n   int cycle;\n \n-  if (! targetm.sched.use_dfa_pipeline_interface\n-      || ! (*targetm.sched.use_dfa_pipeline_interface) ())\n-    return true;\n-\n   state_reset (curr_state);\n \n   for (cycle = from; cycle <= to; cycle++)"}, {"sha": "fd23963597ca5638e1740bfb7b5f89cf9a7b4218", "filename": "gcc/rtl.def", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -281,47 +281,6 @@ DEF_RTL_EXPR(DEFINE_EXPAND, \"define_expand\", \"sEss\", RTX_EXTRA)\n    requirements for delay slots.  */\n DEF_RTL_EXPR(DEFINE_DELAY, \"define_delay\", \"eE\", RTX_EXTRA)\n \n-/* Define a set of insns that requires a function unit.  This means that\n-   these insns produce their result after a delay and that there may be\n-   restrictions on the number of insns of this type that can be scheduled\n-   simultaneously.\n-\n-   More than one DEFINE_FUNCTION_UNIT can be specified for a function unit.\n-   Each gives a set of operations and associated delays.  The first three\n-   operands must be the same for each operation for the same function unit.\n-\n-   All delays are specified in cycles.\n-\n-   1st operand: Name of function unit (mostly for documentation)\n-   2nd operand: Number of identical function units in CPU\n-   3rd operand: Total number of simultaneous insns that can execute on this\n-\t\tfunction unit; 0 if unlimited.\n-   4th operand: Condition involving insn attribute, that, if true, specifies\n-\t\tthose insns that this expression applies to.\n-   5th operand: Constant delay after which insn result will be\n-\t\tavailable.\n-   6th operand: Delay until next insn can be scheduled on the function unit\n-\t\texecuting this operation.  The meaning depends on whether or\n-\t\tnot the next operand is supplied.\n-   7th operand: If this operand is not specified, the 6th operand gives the\n-\t\tnumber of cycles after the instruction matching the 4th\n-\t\toperand begins using the function unit until a subsequent\n-\t\tinsn can begin.  A value of zero should be used for a\n-\t\tunit with no issue constraints.  If only one operation can\n-\t\tbe executed a time and the unit is busy for the entire time,\n-\t\tthe 3rd operand should be specified as 1, the 6th operand\n-\t\tshould be specified as 0, and the 7th operand should not\n-\t\tbe specified.\n-\n-\t\tIf this operand is specified, it is a list of attribute\n-\t\texpressions.  If an insn for which any of these expressions\n-\t\tis true is currently executing on the function unit, the\n-\t\tissue delay will be given by the 6th operand.  Otherwise,\n-\t\tthe insn can be immediately scheduled (subject to the limit\n-\t\ton the number of simultaneous operations executing on the\n-\t\tunit.)  */\n-DEF_RTL_EXPR(DEFINE_FUNCTION_UNIT, \"define_function_unit\", \"siieiiV\", RTX_EXTRA)\n-\n /* Define attribute computation for `asm' instructions.  */\n DEF_RTL_EXPR(DEFINE_ASM_ATTRIBUTES, \"define_asm_attributes\", \"V\", RTX_EXTRA)\n "}, {"sha": "8dddc9e2b834d3d2354e452c628fb413d1365ceb", "filename": "gcc/sched-int.h", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -353,15 +353,7 @@ enum INSN_TRAP_CLASS\n #endif\n \n /* Functions in sched-vis.c.  */\n-extern void init_target_units (void);\n-extern void insn_print_units (rtx);\n-extern void init_block_visualization (void);\n-extern void print_block_visualization (const char *);\n-extern void visualize_scheduled_insns (int);\n-extern void visualize_no_unit (rtx);\n-extern void visualize_stall_cycles (int);\n-extern void visualize_alloc (void);\n-extern void visualize_free (void);\n+extern void print_insn (char *, rtx, int);\n \n /* Functions in sched-deps.c.  */\n extern int add_dependence (rtx, rtx, enum reg_note);\n@@ -388,7 +380,7 @@ extern void restore_line_notes (rtx, rtx);\n extern void rm_redundant_line_notes (void);\n extern void rm_other_notes (rtx, rtx);\n \n-extern int insn_issue_delay (rtx);\n+extern int insn_cost (rtx, rtx, rtx);\n extern int set_priorities (rtx, rtx);\n \n extern void schedule_block (int, int);\n@@ -397,12 +389,4 @@ extern void sched_finish (void);\n \n extern void ready_add (struct ready_list *, rtx);\n \n-/* The following are exported for the benefit of debugging functions.  It\n-   would be nicer to keep them private to haifa-sched.c.  */\n-extern int insn_unit (rtx);\n-extern int insn_cost (rtx, rtx, rtx);\n-extern rtx get_unit_last_insn (int);\n-extern int actual_hazard_this_instance (int, int, rtx, int, int);\n-extern void print_insn (char *, rtx, int);\n-\n #endif /* GCC_SCHED_INT_H */"}, {"sha": "325e1693cd4dfc4ae0325b1976506f623026189a", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 57, "deletions": 108, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -1784,14 +1784,9 @@ init_ready_list (struct ready_list *ready)\n \n \t    if (!CANT_MOVE (insn)\n \t\t&& (!IS_SPECULATIVE_INSN (insn)\n-\t\t    || ((((!targetm.sched.use_dfa_pipeline_interface\n-\t\t\t   || !targetm.sched.use_dfa_pipeline_interface ())\n-\t\t\t  && insn_issue_delay (insn) <= 3)\n-\t\t\t || (targetm.sched.use_dfa_pipeline_interface\n-\t\t\t     && targetm.sched.use_dfa_pipeline_interface ()\n-\t\t\t     && (recog_memoized (insn) < 0\n-\t\t\t         || min_insn_conflict_delay (curr_state,\n-\t\t\t\t\t\t\t     insn, insn) <= 3)))\n+\t\t    || ((recog_memoized (insn) < 0\n+\t\t\t || min_insn_conflict_delay (curr_state,\n+\t\t\t\t\t\t     insn, insn) <= 3)\n \t\t\t&& check_live (insn, bb_src)\n \t\t\t&& is_exception_free (insn, bb_src, target_bb))))\n \t      if (INSN_DEP_COUNT (insn) == 0)\n@@ -1882,15 +1877,8 @@ new_ready (rtx next)\n       && (!IS_VALID (INSN_BB (next))\n \t  || CANT_MOVE (next)\n \t  || (IS_SPECULATIVE_INSN (next)\n-\t      && (0\n-\t\t  || (targetm.sched.use_dfa_pipeline_interface\n-\t\t      && targetm.sched.use_dfa_pipeline_interface ()\n-\t\t      && recog_memoized (next) >= 0\n-\t\t      && min_insn_conflict_delay (curr_state, next,\n-\t\t\t\t\t\t  next) > 3)\n-\t\t  || ((!targetm.sched.use_dfa_pipeline_interface\n-\t\t       || !targetm.sched.use_dfa_pipeline_interface ())\n-\t\t      && insn_issue_delay (next) > 3)\n+\t      && ((recog_memoized (next) >= 0\n+\t\t   && min_insn_conflict_delay (curr_state, next, next) > 3)\n \t\t  || !check_live (next, INSN_BB (next))\n \t\t  || !is_exception_free (next, INSN_BB (next), target_bb)))))\n     return 0;\n@@ -2278,106 +2266,67 @@ debug_dependencies (void)\n   fprintf (sched_dump, \";;   --------------- forward dependences: ------------ \\n\");\n   for (bb = 0; bb < current_nr_blocks; bb++)\n     {\n-      if (1)\n-\t{\n-\t  rtx head, tail;\n-\t  rtx next_tail;\n-\t  rtx insn;\n-\n-\t  get_block_head_tail (BB_TO_BLOCK (bb), &head, &tail);\n-\t  next_tail = NEXT_INSN (tail);\n-\t  fprintf (sched_dump, \"\\n;;   --- Region Dependences --- b %d bb %d \\n\",\n-\t\t   BB_TO_BLOCK (bb), bb);\n+      rtx head, tail;\n+      rtx next_tail;\n+      rtx insn;\n \n-\t  if (targetm.sched.use_dfa_pipeline_interface\n-\t      && targetm.sched.use_dfa_pipeline_interface ())\n-\t    {\n-\t      fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%14s\\n\",\n-\t\t       \"insn\", \"code\", \"bb\", \"dep\", \"prio\", \"cost\",\n-\t\t       \"reservation\");\n-\t      fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%14s\\n\",\n-\t\t       \"----\", \"----\", \"--\", \"---\", \"----\", \"----\",\n-\t\t       \"-----------\");\n-\t    }\n-\t  else\n-\t    {\n-\t      fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%11s%6s\\n\",\n-\t      \"insn\", \"code\", \"bb\", \"dep\", \"prio\", \"cost\", \"blockage\", \"units\");\n-\t      fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%11s%6s\\n\",\n-\t      \"----\", \"----\", \"--\", \"---\", \"----\", \"----\", \"--------\", \"-----\");\n-\t    }\n+      get_block_head_tail (BB_TO_BLOCK (bb), &head, &tail);\n+      next_tail = NEXT_INSN (tail);\n+      fprintf (sched_dump, \"\\n;;   --- Region Dependences --- b %d bb %d \\n\",\n+\t       BB_TO_BLOCK (bb), bb);\n+\n+      fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%14s\\n\",\n+\t       \"insn\", \"code\", \"bb\", \"dep\", \"prio\", \"cost\",\n+\t       \"reservation\");\n+      fprintf (sched_dump, \";;   %7s%6s%6s%6s%6s%6s%14s\\n\",\n+\t       \"----\", \"----\", \"--\", \"---\", \"----\", \"----\",\n+\t       \"-----------\");\n+\n+      for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n+\t{\n+\t  rtx link;\n \n-\t  for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n+\t  if (! INSN_P (insn))\n \t    {\n-\t      rtx link;\n-\n-\t      if (! INSN_P (insn))\n+\t      int n;\n+\t      fprintf (sched_dump, \";;   %6d \", INSN_UID (insn));\n+\t      if (NOTE_P (insn))\n \t\t{\n-\t\t  int n;\n-\t\t  fprintf (sched_dump, \";;   %6d \", INSN_UID (insn));\n-\t\t  if (NOTE_P (insn))\n+\t\t  n = NOTE_LINE_NUMBER (insn);\n+\t\t  if (n < 0)\n+\t\t    fprintf (sched_dump, \"%s\\n\", GET_NOTE_INSN_NAME (n));\n+\t\t  else\n \t\t    {\n-\t\t      n = NOTE_LINE_NUMBER (insn);\n-\t\t      if (n < 0)\n-\t\t\tfprintf (sched_dump, \"%s\\n\", GET_NOTE_INSN_NAME (n));\n-\t\t      else\n-\t\t\t{\n-\t\t\t  expanded_location xloc;\n-\t\t\t  NOTE_EXPANDED_LOCATION (xloc, insn);\n-\t\t\t  fprintf (sched_dump, \"line %d, file %s\\n\",\n-\t\t\t\t   xloc.line, xloc.file);\n-\t\t\t}\n+\t\t      expanded_location xloc;\n+\t\t      NOTE_EXPANDED_LOCATION (xloc, insn);\n+\t\t      fprintf (sched_dump, \"line %d, file %s\\n\",\n+\t\t\t       xloc.line, xloc.file);\n \t\t    }\n-\t\t  else\n-\t\t    fprintf (sched_dump, \" {%s}\\n\", GET_RTX_NAME (GET_CODE (insn)));\n-\t\t  continue;\n-\t\t}\n-\n-\t      if (targetm.sched.use_dfa_pipeline_interface\n-\t\t  && targetm.sched.use_dfa_pipeline_interface ())\n-\t\t{\n-\t\t  fprintf (sched_dump,\n-\t\t\t   \";;   %s%5d%6d%6d%6d%6d%6d   \",\n-\t\t\t   (SCHED_GROUP_P (insn) ? \"+\" : \" \"),\n-\t\t\t   INSN_UID (insn),\n-\t\t\t   INSN_CODE (insn),\n-\t\t\t   INSN_BB (insn),\n-\t\t\t   INSN_DEP_COUNT (insn),\n-\t\t\t   INSN_PRIORITY (insn),\n-\t\t\t   insn_cost (insn, 0, 0));\n-\n-\t\t  if (recog_memoized (insn) < 0)\n-\t\t    fprintf (sched_dump, \"nothing\");\n-\t\t  else\n-\t\t    print_reservation (sched_dump, insn);\n \t\t}\n \t      else\n-\t\t{\n-\t\t  int unit = insn_unit (insn);\n-\t\t  int range\n-\t\t    = (unit < 0\n-\t\t       || function_units[unit].blockage_range_function == 0\n-\t\t       ? 0\n-\t\t       : function_units[unit].blockage_range_function (insn));\n-\t\t  fprintf (sched_dump,\n-\t\t\t   \";;   %s%5d%6d%6d%6d%6d%6d  %3d -%3d   \",\n-\t\t\t   (SCHED_GROUP_P (insn) ? \"+\" : \" \"),\n-\t\t\t   INSN_UID (insn),\n-\t\t\t   INSN_CODE (insn),\n-\t\t\t   INSN_BB (insn),\n-\t\t\t   INSN_DEP_COUNT (insn),\n-\t\t\t   INSN_PRIORITY (insn),\n-\t\t\t   insn_cost (insn, 0, 0),\n-\t\t\t   (int) MIN_BLOCKAGE_COST (range),\n-\t\t\t   (int) MAX_BLOCKAGE_COST (range));\n-\t\t  insn_print_units (insn);\n-\t\t}\n-\n-\t      fprintf (sched_dump, \"\\t: \");\n-\t      for (link = INSN_DEPEND (insn); link; link = XEXP (link, 1))\n-\t\tfprintf (sched_dump, \"%d \", INSN_UID (XEXP (link, 0)));\n-\t      fprintf (sched_dump, \"\\n\");\n+\t\tfprintf (sched_dump, \" {%s}\\n\", GET_RTX_NAME (GET_CODE (insn)));\n+\t      continue;\n \t    }\n+\n+\t  fprintf (sched_dump,\n+\t\t   \";;   %s%5d%6d%6d%6d%6d%6d   \",\n+\t\t   (SCHED_GROUP_P (insn) ? \"+\" : \" \"),\n+\t\t   INSN_UID (insn),\n+\t\t   INSN_CODE (insn),\n+\t\t   INSN_BB (insn),\n+\t\t   INSN_DEP_COUNT (insn),\n+\t\t   INSN_PRIORITY (insn),\n+\t\t   insn_cost (insn, 0, 0));\n+\n+\t  if (recog_memoized (insn) < 0)\n+\t    fprintf (sched_dump, \"nothing\");\n+\t  else\n+\t    print_reservation (sched_dump, insn);\n+\n+\t  fprintf (sched_dump, \"\\t: \");\n+\t  for (link = INSN_DEPEND (insn); link; link = XEXP (link, 1))\n+\t    fprintf (sched_dump, \"%d \", INSN_UID (XEXP (link, 0)));\n+\t  fprintf (sched_dump, \"\\n\");\n \t}\n     }\n   fprintf (sched_dump, \"\\n\");"}, {"sha": "c7c5427b86328b65ec4f9b15c1cece15aab10d25", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 0, "deletions": 259, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -37,133 +37,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"target.h\"\n \n #ifdef INSN_SCHEDULING\n-/* target_units bitmask has 1 for each unit in the cpu.  It should be\n-   possible to compute this variable from the machine description.\n-   But currently it is computed by examining the insn list.  Since\n-   this is only needed for visualization, it seems an acceptable\n-   solution.  (For understanding the mapping of bits to units, see\n-   definition of function_units[] in \"insn-attrtab.c\".)  The scheduler\n-   using only DFA description should never use the following variable.  */\n-\n-static int target_units = 0;\n \n static char *safe_concat (char *, char *, const char *);\n-static int get_visual_tbl_length (void);\n static void print_exp (char *, rtx, int);\n static void print_value (char *, rtx, int);\n static void print_pattern (char *, rtx, int);\n \n-/* Print names of units on which insn can/should execute, for debugging.  */\n-\n-void\n-insn_print_units (rtx insn)\n-{\n-  int i;\n-  int unit = insn_unit (insn);\n-\n-  if (unit == -1)\n-    fprintf (sched_dump, \"none\");\n-  else if (unit >= 0)\n-    fprintf (sched_dump, \"%s\", function_units[unit].name);\n-  else\n-    {\n-      fprintf (sched_dump, \"[\");\n-      for (i = 0, unit = ~unit; unit; i++, unit >>= 1)\n-\tif (unit & 1)\n-\t  {\n-\t    fprintf (sched_dump, \"%s\", function_units[i].name);\n-\t    if (unit != 1)\n-\t      fprintf (sched_dump, \" \");\n-\t  }\n-      fprintf (sched_dump, \"]\");\n-    }\n-}\n-\n-/* MAX_VISUAL_LINES is the maximum number of lines in visualization table\n-   of a basic block.  If more lines are needed, table is split to two.\n-   n_visual_lines is the number of lines printed so far for a block.\n-   visual_tbl contains the block visualization info.\n-   vis_no_unit holds insns in a cycle that are not mapped to any unit.  */\n-#define MAX_VISUAL_LINES 100\n-#define INSN_LEN 30\n-int n_visual_lines;\n-static unsigned visual_tbl_line_length;\n-char *visual_tbl;\n-int n_vis_no_unit;\n-#define MAX_VISUAL_NO_UNIT 20\n-rtx vis_no_unit[MAX_VISUAL_NO_UNIT];\n-\n-/* Finds units that are in use in this function.  Required only\n-   for visualization.  */\n-\n-void\n-init_target_units (void)\n-{\n-  rtx insn;\n-  int unit;\n-\n-  for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n-    {\n-      if (! INSN_P (insn))\n-\tcontinue;\n-\n-      unit = insn_unit (insn);\n-\n-      if (unit < 0)\n-\ttarget_units |= ~unit;\n-      else\n-\ttarget_units |= (1 << unit);\n-    }\n-}\n-\n-/* Return the length of the visualization table.  */\n-\n-static int\n-get_visual_tbl_length (void)\n-{\n-  int unit, i;\n-  int n, n1;\n-  char *s;\n-\n-  if (targetm.sched.use_dfa_pipeline_interface\n-      && targetm.sched.use_dfa_pipeline_interface ())\n-    {\n-      visual_tbl_line_length = 1;\n-      return 1; /* Can't return 0 because that will cause problems\n-                   with alloca.  */\n-    }\n-\n-  /* Compute length of one field in line.  */\n-  s = alloca (INSN_LEN + 6);\n-  sprintf (s, \"  %33s\", \"uname\");\n-  n1 = strlen (s);\n-\n-  /* Compute length of one line.  */\n-  n = strlen (\";; \");\n-  n += n1;\n-  for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n-    if (function_units[unit].bitmask & target_units)\n-      for (i = 0; i < function_units[unit].multiplicity; i++)\n-\tn += n1;\n-  n += n1;\n-  n += strlen (\"\\n\") + 2;\n-\n-  visual_tbl_line_length = n;\n-\n-  /* Compute length of visualization string.  */\n-  return (MAX_VISUAL_LINES * n);\n-}\n-\n-/* Init block visualization debugging info.  */\n-\n-void\n-init_block_visualization (void)\n-{\n-  strcpy (visual_tbl, \"\");\n-  n_visual_lines = 0;\n-  n_vis_no_unit = 0;\n-}\n-\n #define BUF_LEN 2048\n \n static char *\n@@ -808,142 +687,4 @@ print_insn (char *buf, rtx x, int verbose)\n     }\n }\t\t\t\t/* print_insn */\n \n-/* Print visualization debugging info.  The scheduler using only DFA\n-   description should never use the following function.  */\n-\n-void\n-print_block_visualization (const char *s)\n-{\n-  int unit, i;\n-\n-  /* Print header.  */\n-  fprintf (sched_dump, \"\\n;;   ==================== scheduling visualization %s \\n\", s);\n-\n-  /* Print names of units.  */\n-  fprintf (sched_dump, \";;   %-8s\", \"clock\");\n-  for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n-    if (function_units[unit].bitmask & target_units)\n-      for (i = 0; i < function_units[unit].multiplicity; i++)\n-\tfprintf (sched_dump, \"  %-33s\", function_units[unit].name);\n-  fprintf (sched_dump, \"  %-8s\\n\", \"no-unit\");\n-\n-  fprintf (sched_dump, \";;   %-8s\", \"=====\");\n-  for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n-    if (function_units[unit].bitmask & target_units)\n-      for (i = 0; i < function_units[unit].multiplicity; i++)\n-\tfprintf (sched_dump, \"  %-33s\", \"==============================\");\n-  fprintf (sched_dump, \"  %-8s\\n\", \"=======\");\n-\n-  /* Print insns in each cycle.  */\n-  fprintf (sched_dump, \"%s\\n\", visual_tbl);\n-}\n-\n-/* Print insns in the 'no_unit' column of visualization.  */\n-\n-void\n-visualize_no_unit (rtx insn)\n-{\n-  if (n_vis_no_unit < MAX_VISUAL_NO_UNIT)\n-    {\n-      vis_no_unit[n_vis_no_unit] = insn;\n-      n_vis_no_unit++;\n-    }\n-}\n-\n-/* Print insns scheduled in clock, for visualization.  */\n-\n-void\n-visualize_scheduled_insns (int clock)\n-{\n-  int i, unit;\n-\n-  /* If no more room, split table into two.  */\n-  if (n_visual_lines >= MAX_VISUAL_LINES)\n-    {\n-      print_block_visualization (\"(incomplete)\");\n-      init_block_visualization ();\n-    }\n-\n-  n_visual_lines++;\n-\n-  sprintf (visual_tbl + strlen (visual_tbl), \";;   %-8d\", clock);\n-  for (unit = 0; unit < FUNCTION_UNITS_SIZE; unit++)\n-    if (function_units[unit].bitmask & target_units)\n-      for (i = 0; i < function_units[unit].multiplicity; i++)\n-\t{\n-\t  int instance = unit + i * FUNCTION_UNITS_SIZE;\n-\t  rtx insn = get_unit_last_insn (instance);\n-\n-\t  /* Print insns that still keep the unit busy.  */\n-\t  if (insn\n-\t      && actual_hazard_this_instance (unit, instance, insn, clock, 0))\n-\t    {\n-\t      char str[BUF_LEN];\n-\t      print_insn (str, insn, 0);\n-\t      str[INSN_LEN] = '\\0';\n-\t      sprintf (visual_tbl + strlen (visual_tbl), \"  %-33s\", str);\n-\t    }\n-\t  else\n-\t    sprintf (visual_tbl + strlen (visual_tbl), \"  %-33s\", \"------------------------------\");\n-\t}\n-\n-  /* Print insns that are not assigned to any unit.  */\n-  for (i = 0; i < n_vis_no_unit; i++)\n-    sprintf (visual_tbl + strlen (visual_tbl), \"  %-8d\",\n-\t     INSN_UID (vis_no_unit[i]));\n-  n_vis_no_unit = 0;\n-\n-  sprintf (visual_tbl + strlen (visual_tbl), \"\\n\");\n-}\n-\n-/* Print stalled cycles.  */\n-\n-void\n-visualize_stall_cycles (int stalls)\n-{\n-  static const char *const prefix = \";;       \";\n-  const char *suffix = \"\\n\";\n-  char *p;\n-\n-  /* If no more room, split table into two.  */\n-  if (n_visual_lines >= MAX_VISUAL_LINES)\n-    {\n-      print_block_visualization (\"(incomplete)\");\n-      init_block_visualization ();\n-    }\n-\n-  n_visual_lines++;\n-\n-  p = visual_tbl + strlen (visual_tbl);\n-  strcpy (p, prefix);\n-  p += strlen (prefix);\n-\n-  if ((unsigned) stalls >\n-      visual_tbl_line_length - strlen (prefix) - strlen (suffix))\n-    {\n-      suffix = \"[...]\\n\";\n-      stalls = visual_tbl_line_length - strlen (prefix) - strlen (suffix);\n-    }\n-\n-  memset (p, '.', stalls);\n-  p += stalls;\n-\n-  strcpy (p, suffix);\n-}\n-\n-/* Allocate data used for visualization during scheduling.  */\n-\n-void\n-visualize_alloc (void)\n-{\n-  visual_tbl = xmalloc (get_visual_tbl_length ());\n-}\n-\n-/* Free data used for visualization.  */\n-\n-void\n-visualize_free (void)\n-{\n-  free (visual_tbl);\n-}\n #endif"}, {"sha": "a3edb019a14836037414a67b157ca4f336416a6d", "filename": "gcc/target-def.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -233,7 +233,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_SCHED_REORDER 0\n #define TARGET_SCHED_REORDER2 0\n #define TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK 0\n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE 0\n #define TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN 0\n #define TARGET_SCHED_DFA_PRE_CYCLE_INSN 0\n #define TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN 0\n@@ -255,7 +254,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_SCHED_REORDER,\t\t\t\t\t\\\n    TARGET_SCHED_REORDER2,\t\t\t\t\t\\\n    TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK,\t\t\t\\\n-   TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE,\t\t\t\\\n    TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN,\t\t\t\\\n    TARGET_SCHED_DFA_PRE_CYCLE_INSN,\t\t\t\t\\\n    TARGET_SCHED_INIT_DFA_POST_CYCLE_INSN,\t\t\t\\"}, {"sha": "cdcaa18acd9826d4cf02562038e1a68c5276e887", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa0aee8996c4865098816ee9a5007aabe355925f/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=fa0aee8996c4865098816ee9a5007aabe355925f", "patch": "@@ -213,12 +213,6 @@ struct gcc_target\n        by two parameter values (head and tail correspondingly).  */\n     void (* dependencies_evaluation_hook) (rtx, rtx);\n \n-    /* The following member value is a pointer to a function returning\n-       nonzero if we should use DFA based scheduling.  The default is\n-       to use the old pipeline scheduler.  */\n-    int (* use_dfa_pipeline_interface) (void);\n-    /* The values of all the following members are used only for the\n-       DFA based scheduler: */\n     /* The values of the following four members are pointers to\n        functions used to simplify the automaton descriptions.\n        dfa_pre_cycle_insn and dfa_post_cycle_insn give functions\n@@ -234,6 +228,7 @@ struct gcc_target\n     rtx (* dfa_pre_cycle_insn) (void);\n     void (* init_dfa_post_cycle_insn) (void);\n     rtx (* dfa_post_cycle_insn) (void);\n+\n     /* The following member value is a pointer to a function returning value\n        which defines how many insns in queue `ready' will we try for\n        multi-pass scheduling.  If the member value is nonzero and the\n@@ -242,12 +237,14 @@ struct gcc_target\n        try to choose ready insn which permits to start maximum number of\n        insns on the same cycle.  */\n     int (* first_cycle_multipass_dfa_lookahead) (void);\n+\n     /* The following member value is pointer to a function controlling\n        what insns from the ready insn queue will be considered for the\n        multipass insn scheduling.  If the hook returns zero for insn\n        passed as the parameter, the insn will be not chosen to be\n        issued.  */\n     int (* first_cycle_multipass_dfa_lookahead_guard) (rtx);\n+\n     /* The following member value is pointer to a function called by\n        the insn scheduler before issuing insn passed as the third\n        parameter on given cycle.  If the hook returns nonzero, the\n@@ -261,6 +258,7 @@ struct gcc_target\n        the previous insn has been issued and the current processor\n        cycle.  */\n     int (* dfa_new_cycle) (FILE *, int, rtx, int, int, int *);\n+\n     /* The following member value is a pointer to a function called\n        by the insn scheduler.  It should return true if there exists a\n        dependence which is considered costly by the target, between "}]}