{"sha": "544aee0d660d2bd471cc4317939326fe14a0babe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ0YWVlMGQ2NjBkMmJkNDcxY2M0MzE3OTM5MzI2ZmUxNGEwYmFiZQ==", "commit": {"author": {"name": "Andreas Schwab", "email": "schwab@suse.de", "date": "2014-06-18T15:01:32Z"}, "committer": {"name": "Andreas Schwab", "email": "schwab@gcc.gnu.org", "date": "2014-06-18T15:01:32Z"}, "message": "md.texi (Standard Names): Use @itemx for grouped items.\n\n* doc/md.texi (Standard Names): Use @itemx for grouped items.\nRemove blank line after @item.\n\nFrom-SVN: r211788", "tree": {"sha": "dbbce0f62e38da50ae9dd072a82fd3a533fd8b0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbbce0f62e38da50ae9dd072a82fd3a533fd8b0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/544aee0d660d2bd471cc4317939326fe14a0babe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544aee0d660d2bd471cc4317939326fe14a0babe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/544aee0d660d2bd471cc4317939326fe14a0babe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544aee0d660d2bd471cc4317939326fe14a0babe/comments", "author": {"login": "andreas-schwab", "id": 2175493, "node_id": "MDQ6VXNlcjIxNzU0OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/2175493?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andreas-schwab", "html_url": "https://github.com/andreas-schwab", "followers_url": "https://api.github.com/users/andreas-schwab/followers", "following_url": "https://api.github.com/users/andreas-schwab/following{/other_user}", "gists_url": "https://api.github.com/users/andreas-schwab/gists{/gist_id}", "starred_url": "https://api.github.com/users/andreas-schwab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andreas-schwab/subscriptions", "organizations_url": "https://api.github.com/users/andreas-schwab/orgs", "repos_url": "https://api.github.com/users/andreas-schwab/repos", "events_url": "https://api.github.com/users/andreas-schwab/events{/privacy}", "received_events_url": "https://api.github.com/users/andreas-schwab/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0bc117145a4dc08c79f20d41946abb1b24eda92a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bc117145a4dc08c79f20d41946abb1b24eda92a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bc117145a4dc08c79f20d41946abb1b24eda92a"}], "stats": {"total": 25, "additions": 7, "deletions": 18}, "files": [{"sha": "5ac60f2dce9e995ea5f40e0fef01f595082a26db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544aee0d660d2bd471cc4317939326fe14a0babe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544aee0d660d2bd471cc4317939326fe14a0babe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=544aee0d660d2bd471cc4317939326fe14a0babe", "patch": "@@ -1,3 +1,8 @@\n+2014-06-18  Andreas Schwab  <schwab@suse.de>\n+\n+\t* doc/md.texi (Standard Names): Use @itemx for grouped items.\n+\tRemove blank line after @item.\n+\n 2014-06-18  Richard Henderson  <rth@redhat.com>\n \n \tPR target/61545"}, {"sha": "1c3a3265ed1f00307367ddd656ee896c70c03cea", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/544aee0d660d2bd471cc4317939326fe14a0babe/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/544aee0d660d2bd471cc4317939326fe14a0babe/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=544aee0d660d2bd471cc4317939326fe14a0babe", "patch": "@@ -4835,7 +4835,7 @@ and the scalar result is stored in the least significant bits of operand 0\n @cindex @code{sdot_prod@var{m}} instruction pattern\n @item @samp{sdot_prod@var{m}}\n @cindex @code{udot_prod@var{m}} instruction pattern\n-@item @samp{udot_prod@var{m}}\n+@itemx @samp{udot_prod@var{m}}\n Compute the sum of the products of two signed/unsigned elements.\n Operand 1 and operand 2 are of the same mode. Their product, which is of a\n wider mode, is computed and added to operand 3. Operand 3 is of a mode equal or\n@@ -4845,7 +4845,7 @@ is of the same mode as operand 3.\n @cindex @code{ssum_widen@var{m3}} instruction pattern\n @item @samp{ssum_widen@var{m3}}\n @cindex @code{usum_widen@var{m3}} instruction pattern\n-@item @samp{usum_widen@var{m3}}\n+@itemx @samp{usum_widen@var{m3}}\n Operands 0 and 2 are of the same mode, which is wider than the mode of\n operand 1. Add operand 1 to operand 2 and place the widened result in\n operand 0. (This is used express accumulation of elements into an accumulator\n@@ -6218,7 +6218,6 @@ A typical @code{ctrap} pattern looks like\n \n @cindex @code{prefetch} instruction pattern\n @item @samp{prefetch}\n-\n This pattern, if defined, emits code for a non-faulting data prefetch\n instruction.  Operand 0 is the address of the memory to prefetch.  Operand 1\n is a constant 1 if the prefetch is preparing for a write to the memory\n@@ -6234,23 +6233,20 @@ the values of operands 1 and 2.\n \n @cindex @code{blockage} instruction pattern\n @item @samp{blockage}\n-\n This pattern defines a pseudo insn that prevents the instruction\n scheduler and other passes from moving instructions and using register\n equivalences across the boundary defined by the blockage insn.\n This needs to be an UNSPEC_VOLATILE pattern or a volatile ASM.\n \n @cindex @code{memory_barrier} instruction pattern\n @item @samp{memory_barrier}\n-\n If the target memory model is not fully synchronous, then this pattern\n should be defined to an instruction that orders both loads and stores\n before the instruction with respect to loads and stores after the instruction.\n This pattern has no operands.\n \n @cindex @code{sync_compare_and_swap@var{mode}} instruction pattern\n @item @samp{sync_compare_and_swap@var{mode}}\n-\n This pattern, if defined, emits code for an atomic compare-and-swap\n operation.  Operand 1 is the memory on which the atomic operation is\n performed.  Operand 2 is the ``old'' value to be compared against the\n@@ -6299,7 +6295,6 @@ interruptable locking.\n @item @samp{sync_add@var{mode}}, @samp{sync_sub@var{mode}}\n @itemx @samp{sync_ior@var{mode}}, @samp{sync_and@var{mode}}\n @itemx @samp{sync_xor@var{mode}}, @samp{sync_nand@var{mode}}\n-\n These patterns emit code for an atomic operation on memory.\n Operand 0 is the memory on which the atomic operation is performed.\n Operand 1 is the second operand to the binary operator.\n@@ -6321,7 +6316,6 @@ from a compare-and-swap operation, if defined.\n @item @samp{sync_old_add@var{mode}}, @samp{sync_old_sub@var{mode}}\n @itemx @samp{sync_old_ior@var{mode}}, @samp{sync_old_and@var{mode}}\n @itemx @samp{sync_old_xor@var{mode}}, @samp{sync_old_nand@var{mode}}\n-\n These patterns emit code for an atomic operation on memory,\n and return the value that the memory contained before the operation.\n Operand 0 is the result value, operand 1 is the memory on which the\n@@ -6345,14 +6339,12 @@ from a compare-and-swap operation, if defined.\n @item @samp{sync_new_add@var{mode}}, @samp{sync_new_sub@var{mode}}\n @itemx @samp{sync_new_ior@var{mode}}, @samp{sync_new_and@var{mode}}\n @itemx @samp{sync_new_xor@var{mode}}, @samp{sync_new_nand@var{mode}}\n-\n These patterns are like their @code{sync_old_@var{op}} counterparts,\n except that they return the value that exists in the memory location\n after the operation, rather than before the operation.\n \n @cindex @code{sync_lock_test_and_set@var{mode}} instruction pattern\n @item @samp{sync_lock_test_and_set@var{mode}}\n-\n This pattern takes two forms, based on the capabilities of the target.\n In either case, operand 0 is the result of the operand, operand 1 is\n the memory on which the atomic operation is performed, and operand 2\n@@ -6377,7 +6369,6 @@ a compare-and-swap operation, if defined.\n \n @cindex @code{sync_lock_release@var{mode}} instruction pattern\n @item @samp{sync_lock_release@var{mode}}\n-\n This pattern, if defined, releases a lock set by\n @code{sync_lock_test_and_set@var{mode}}.  Operand 0 is the memory\n that contains the lock; operand 1 is the value to store in the lock.\n@@ -6467,7 +6458,6 @@ compare and swap loop.\n @item @samp{atomic_add@var{mode}}, @samp{atomic_sub@var{mode}}\n @itemx @samp{atomic_or@var{mode}}, @samp{atomic_and@var{mode}}\n @itemx @samp{atomic_xor@var{mode}}, @samp{atomic_nand@var{mode}}\n-\n These patterns emit code for an atomic operation on memory with memory\n model semantics. Operand 0 is the memory on which the atomic operation is\n performed.  Operand 1 is the second operand to the binary operator.\n@@ -6486,7 +6476,6 @@ none of these are available a compare-and-swap loop will be used.\n @item @samp{atomic_fetch_add@var{mode}}, @samp{atomic_fetch_sub@var{mode}}\n @itemx @samp{atomic_fetch_or@var{mode}}, @samp{atomic_fetch_and@var{mode}}\n @itemx @samp{atomic_fetch_xor@var{mode}}, @samp{atomic_fetch_nand@var{mode}}\n-\n These patterns emit code for an atomic operation on memory with memory\n model semantics, and return the original value. Operand 0 is an output \n operand which contains the value of the memory location before the \n@@ -6507,7 +6496,6 @@ loop will be used.\n @item @samp{atomic_add_fetch@var{mode}}, @samp{atomic_sub_fetch@var{mode}}\n @itemx @samp{atomic_or_fetch@var{mode}}, @samp{atomic_and_fetch@var{mode}}\n @itemx @samp{atomic_xor_fetch@var{mode}}, @samp{atomic_nand_fetch@var{mode}}\n-\n These patterns emit code for an atomic operation on memory with memory\n model semantics and return the result after the operation is performed.\n Operand 0 is an output operand which contains the value after the\n@@ -6523,7 +6511,6 @@ used.\n \n @cindex @code{atomic_test_and_set} instruction pattern\n @item @samp{atomic_test_and_set}\n-\n This pattern emits code for @code{__builtin_atomic_test_and_set}.\n Operand 0 is an output operand which is set to true if the previous\n previous contents of the byte was \"set\", and false otherwise.  Operand 1\n@@ -6570,7 +6557,6 @@ with @var{mode} intended to be @code{Pmode}.\n \n @cindex @code{stack_protect_set} instruction pattern\n @item @samp{stack_protect_set}\n-\n This pattern, if defined, moves a @code{ptr_mode} value from the memory\n in operand 1 to the memory in operand 0 without leaving the value in\n a register afterward.  This is to avoid leaking the value some place\n@@ -6581,7 +6567,6 @@ If this pattern is not defined, then a plain move pattern is generated.\n \n @cindex @code{stack_protect_test} instruction pattern\n @item @samp{stack_protect_test}\n-\n This pattern, if defined, compares a @code{ptr_mode} value from the\n memory in operand 1 with the memory in operand 0 without leaving the\n value in a register afterward and branches to operand 2 if the values\n@@ -6592,7 +6577,6 @@ conditional branch pattern is used.\n \n @cindex @code{clear_cache} instruction pattern\n @item @samp{clear_cache}\n-\n This pattern, if defined, flushes the instruction cache for a region of\n memory.  The region is bounded to by the Pmode pointers in operand 0\n inclusive and operand 1 exclusive."}]}