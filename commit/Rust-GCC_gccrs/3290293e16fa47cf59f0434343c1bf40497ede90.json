{"sha": "3290293e16fa47cf59f0434343c1bf40497ede90", "node_id": "C_kwDOANBUbNoAKDMyOTAyOTNlMTZmYTQ3Y2Y1OWYwNDM0MzQzYzFiZjQwNDk3ZWRlOTA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2023-01-09T15:48:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-09T15:48:12Z"}, "message": "Merge #1708\n\n1708: Parse declarative macro (decl_macro 2.0) r=CohenArthur a=tamaroning\n\nThis PR is currentry wip.\r\nOpinions and advices are welcome!\n\nCo-authored-by: Raiki Tamura <tamaron1203@gmail.com>", "tree": {"sha": "c98859a1c4cd79baaa13435bb072b4d42836b39e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c98859a1c4cd79baaa13435bb072b4d42836b39e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3290293e16fa47cf59f0434343c1bf40497ede90", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjvDc8CRBK7hj4Ov3rIwAAE38IAFXxVw7FT6EOnx5Guu2Zt+Y4\nvLnuNtMKi5JjR0Rnb+D5ttciHxuWaIvw9X9AAstodBNARkaB1dxVumMhtDahdbJv\nc5FfrztHP7vuVj0KLIhLnAZnmyXIU4X9fTRAIAC6ghlHSmjh3yCy7eDymoPpTq5S\nw9pqPxqPE8pE5DdOG57R+3KMnHLwfTjFRux8REzY+k5WTWHX4M9nfmXVGLP1+U4z\n+/UWvVHVIJKndkUiLeASBfgCE8xQsyqCLZfCQDBkq0Kd41WXFCRofb/kirdHYY+h\nitasIjTd57pmpI80ImHz52MsRMSS3ZgZOiWi335t8lB5fDoSMv4k9cJsVyHK4qo=\n=xwY7\n-----END PGP SIGNATURE-----\n", "payload": "tree c98859a1c4cd79baaa13435bb072b4d42836b39e\nparent 48d32bc9cb05ea02ee0dc9d97d86ff1f559fae4f\nparent 9e5769cf45cfc703e807e51b3ad301e123b05b55\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1673279292 +0000\ncommitter GitHub <noreply@github.com> 1673279292 +0000\n\nMerge #1708\n\n1708: Parse declarative macro (decl_macro 2.0) r=CohenArthur a=tamaroning\n\nThis PR is currentry wip.\r\nOpinions and advices are welcome!\n\nCo-authored-by: Raiki Tamura <tamaron1203@gmail.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3290293e16fa47cf59f0434343c1bf40497ede90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3290293e16fa47cf59f0434343c1bf40497ede90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3290293e16fa47cf59f0434343c1bf40497ede90/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48d32bc9cb05ea02ee0dc9d97d86ff1f559fae4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48d32bc9cb05ea02ee0dc9d97d86ff1f559fae4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48d32bc9cb05ea02ee0dc9d97d86ff1f559fae4f"}, {"sha": "9e5769cf45cfc703e807e51b3ad301e123b05b55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e5769cf45cfc703e807e51b3ad301e123b05b55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e5769cf45cfc703e807e51b3ad301e123b05b55"}], "stats": {"total": 381, "additions": 301, "deletions": 80}, "files": [{"sha": "0927adb3bc2b5716657d6cef0b50bc64ecc40da8", "filename": "gcc/rust/ast/rust-ast-full-decls.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-decls.h?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -51,7 +51,6 @@ class Lifetime;\n class GenericParam;\n class LifetimeParam;\n class ConstGenericParam;\n-class MacroItem;\n class TraitItem;\n class InherentImplItem;\n class TraitImplItem;"}, {"sha": "c98df5106ef88ed81f007c18e72beca1c3999cea", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -1284,6 +1284,7 @@ MacroRulesDefinition::as_string () const\n   // get outer attrs\n   str += append_attributes (outer_attrs, OUTER);\n \n+  // TODO: deal with macro_2_0\n   str += \"macro_rules!\";\n \n   str += rule_name;"}, {"sha": "1539e78f01b14cf7ae908b0d1bf4fb214b1a0565", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -1350,11 +1350,6 @@ class LifetimeParam : public GenericParam\n   }\n };\n \n-// A macro item AST node - abstract base class\n-class MacroItem : public Item\n-{\n-};\n-\n // Item used in trait declarations - abstract base class\n class TraitItem\n {"}, {"sha": "206887c01e6c6a6d8b998e70b07e605ae9473ba1", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -4391,8 +4391,6 @@ class ExternBlock : public VisItem\n   }\n };\n \n-// Replaced with forward decls - defined in \"rust-macro.h\"\n-class MacroItem;\n class MacroRulesDefinition;\n } // namespace AST\n } // namespace Rust"}, {"sha": "52c7efb5d1b760cf880b054a86a8f77bf437ee6e", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -23,13 +23,11 @@\n #include \"rust-ast.h\"\n #include \"rust-ast-fragment.h\"\n #include \"rust-location.h\"\n+#include \"rust-item.h\"\n+#include \"rust-make-unique.h\"\n \n namespace Rust {\n namespace AST {\n-\n-// Decls as definitions moved to rust-ast.h\n-class MacroItem;\n-\n class MacroFragSpec\n {\n public:\n@@ -446,8 +444,18 @@ struct MacroRule\n };\n \n // A macro rules definition item AST node\n-class MacroRulesDefinition : public MacroItem\n+class MacroRulesDefinition : public VisItem\n {\n+public:\n+  enum MacroKind\n+  {\n+    // Macro by Example (legacy macro rules)\n+    MBE,\n+    // Declarative macros 2.0\n+    DeclMacro,\n+  };\n+\n+private:\n   std::vector<Attribute> outer_attrs;\n   Identifier rule_name;\n   // MacroRulesDef rules_def;\n@@ -460,6 +468,7 @@ class MacroRulesDefinition : public MacroItem\n   std::function<Fragment (Location, MacroInvocData &)> associated_transcriber;\n   // Since we can't compare std::functions, we need to use an extra boolean\n   bool is_builtin_rule;\n+  MacroKind kind;\n \n   /**\n    * Default function to use as an associated transcriber. This function should\n@@ -479,27 +488,51 @@ class MacroRulesDefinition : public MacroItem\n    * I am not aware of the implications of this decision. The rustc spec does\n    * mention that using the same parser for macro definitions and invocations\n    * is \"extremely self-referential and non-intuitive\". */\n-\n-public:\n-  std::string as_string () const override;\n-\n   MacroRulesDefinition (Identifier rule_name, DelimType delim_type,\n \t\t\tstd::vector<MacroRule> rules,\n-\t\t\tstd::vector<Attribute> outer_attrs, Location locus)\n-    : outer_attrs (std::move (outer_attrs)), rule_name (std::move (rule_name)),\n+\t\t\tstd::vector<Attribute> outer_attrs, Location locus,\n+\t\t\tMacroKind kind, Visibility vis)\n+    : VisItem (std::move (vis), outer_attrs),\n+      outer_attrs (std::move (outer_attrs)), rule_name (std::move (rule_name)),\n       delim_type (delim_type), rules (std::move (rules)), locus (locus),\n-      associated_transcriber (dummy_builtin), is_builtin_rule (false)\n+      associated_transcriber (dummy_builtin), is_builtin_rule (false),\n+      kind (kind)\n   {}\n \n   MacroRulesDefinition (\n     Identifier builtin_name, DelimType delim_type,\n-    std::function<Fragment (Location, MacroInvocData &)> associated_transcriber)\n-    : outer_attrs (std::vector<Attribute> ()), rule_name (builtin_name),\n+    std::function<Fragment (Location, MacroInvocData &)> associated_transcriber,\n+    MacroKind kind, Visibility vis)\n+    : VisItem (std::move (vis), std::vector<Attribute> ()),\n+      outer_attrs (std::vector<Attribute> ()), rule_name (builtin_name),\n       delim_type (delim_type), rules (std::vector<MacroRule> ()),\n       locus (Location ()), associated_transcriber (associated_transcriber),\n-      is_builtin_rule (true)\n+      is_builtin_rule (true), kind (kind)\n   {}\n \n+public:\n+  std::string as_string () const override;\n+\n+  static std::unique_ptr<MacroRulesDefinition>\n+  mbe (Identifier rule_name, DelimType delim_type, std::vector<MacroRule> rules,\n+       std::vector<Attribute> outer_attrs, Location locus)\n+  {\n+    return Rust::make_unique<MacroRulesDefinition> (\n+      MacroRulesDefinition (rule_name, delim_type, rules, outer_attrs, locus,\n+\t\t\t    AST::MacroRulesDefinition::MacroKind::MBE,\n+\t\t\t    AST::Visibility::create_error ()));\n+  }\n+\n+  static std::unique_ptr<MacroRulesDefinition>\n+  decl_macro (Identifier rule_name, std::vector<MacroRule> rules,\n+\t      std::vector<Attribute> outer_attrs, Location locus,\n+\t      Visibility vis)\n+  {\n+    return Rust::make_unique<MacroRulesDefinition> (MacroRulesDefinition (\n+      rule_name, AST::DelimType::CURLY, rules, outer_attrs, locus,\n+      AST::MacroRulesDefinition::MacroKind::DeclMacro, vis));\n+  }\n+\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Invalid if rule name is empty, so base stripping on that.\n@@ -549,7 +582,7 @@ class MacroRulesDefinition : public MacroItem\n  * compile time */\n class MacroInvocation : public TypeNoBounds,\n \t\t\tpublic Pattern,\n-\t\t\tpublic MacroItem,\n+\t\t\tpublic Item,\n \t\t\tpublic TraitItem,\n \t\t\tpublic TraitImplItem,\n \t\t\tpublic InherentImplItem,"}, {"sha": "a0ff5555da444e44e76e4f66027e852fa8db7ec4", "filename": "gcc/rust/lex/rust-token.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.h?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -171,7 +171,7 @@ enum PrimitiveCoreType\n   RS_TOKEN_KEYWORD (IN, \"in\")                                                  \\\n   RS_TOKEN_KEYWORD (LET, \"let\")                                                \\\n   RS_TOKEN_KEYWORD (LOOP, \"loop\")                                              \\\n-  RS_TOKEN_KEYWORD (MACRO, \"macro\") /* unused */                               \\\n+  RS_TOKEN_KEYWORD (MACRO, \"macro\")                                            \\\n   RS_TOKEN_KEYWORD (MATCH_TOK, \"match\")                                        \\\n   RS_TOKEN_KEYWORD (MOD, \"mod\")                                                \\\n   RS_TOKEN_KEYWORD (MOVE, \"move\")                                              \\"}, {"sha": "c19fe9b6ec4f6ef3788c521a4ccf18b7fcf339b7", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 175, "deletions": 54, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -1032,11 +1032,6 @@ Parser<ManagedTokenSource>::parse_item (bool called_from_statement)\n \n   // parse outer attributes for item\n   AST::AttrVec outer_attrs = parse_outer_attributes ();\n-\n-  // TODO: decide how to deal with VisItem vs MacroItem dichotomy\n-  /* best current solution: catch all keywords that would imply a VisItem in a\n-   * switch and have MacroItem as a last resort */\n-\n   const_TokenPtr t = lexer.peek_token ();\n \n   switch (t->get_id ())\n@@ -1064,6 +1059,7 @@ Parser<ManagedTokenSource>::parse_item (bool called_from_statement)\n     case STATIC_TOK:\n     case TRAIT:\n     case IMPL:\n+    case MACRO:\n     /* TODO: implement union keyword but not really because of\n      * context-dependence crappy hack way to parse a union written below to\n      * separate it from the good code. */\n@@ -1078,7 +1074,7 @@ Parser<ManagedTokenSource>::parse_item (bool called_from_statement)\n     case CRATE:\n     case DOLLAR_SIGN:\n       // almost certainly macro invocation semi\n-      return parse_macro_item (std::move (outer_attrs));\n+      return parse_macro_invocation_semi (std::move (outer_attrs));\n       break;\n     // crappy hack to do union \"keyword\"\n     case IDENTIFIER:\n@@ -1092,19 +1088,18 @@ Parser<ManagedTokenSource>::parse_item (bool called_from_statement)\n       else if (t->get_str () == \"macro_rules\")\n \t{\n \t  // macro_rules! macro item\n-\t  return parse_macro_item (std::move (outer_attrs));\n+\t  return parse_macro_rules_def (std::move (outer_attrs));\n \t}\n       else if (lexer.peek_token (1)->get_id () == SCOPE_RESOLUTION\n \t       || lexer.peek_token (1)->get_id () == EXCLAM)\n \t{\n \t  /* path (probably) or macro invocation, so probably a macro invocation\n \t   * semi */\n-\t  return parse_macro_item (std::move (outer_attrs));\n+\t  return parse_macro_invocation_semi (std::move (outer_attrs));\n \t}\n       gcc_fallthrough ();\n     default:\n       // otherwise unrecognised\n-      // return parse_macro_item(std::move(outer_attrs));\n       add_error (Error (t->get_locus (),\n \t\t\t\"unrecognised token %qs for start of %s\",\n \t\t\tt->get_token_description (),\n@@ -1335,6 +1330,8 @@ Parser<ManagedTokenSource>::parse_vis_item (AST::AttrVec outer_attrs)\n \t  lexer.skip_token (1); // TODO: is this right thing to do?\n \t  return nullptr;\n \t}\n+    case MACRO:\n+      return parse_decl_macro_def (std::move (vis), std::move (outer_attrs));\n     default:\n       // otherwise vis item clearly doesn't exist, which is not an error\n       // has a catch-all post-switch return to allow other breaks to occur\n@@ -1343,42 +1340,6 @@ Parser<ManagedTokenSource>::parse_vis_item (AST::AttrVec outer_attrs)\n   return nullptr;\n }\n \n-// Parses a MacroItem (either a MacroInvocationSemi or MacroRulesDefinition).\n-template <typename ManagedTokenSource>\n-std::unique_ptr<AST::MacroItem>\n-Parser<ManagedTokenSource>::parse_macro_item (AST::AttrVec outer_attrs)\n-{\n-  const_TokenPtr t = lexer.peek_token ();\n-\n-  /* dodgy way of detecting macro due to weird context-dependence thing.\n-   * probably can be improved */\n-  // TODO: ensure that string compare works properly\n-  if (t->get_id () == IDENTIFIER && t->get_str () == \"macro_rules\")\n-    {\n-      return parse_macro_rules_def (std::move (outer_attrs));\n-    }\n-  else\n-    {\n-      // DEBUG: TODO: remove\n-      rust_debug (\n-\t\"DEBUG - parse_macro_item called and token is not macro_rules\");\n-      if (t->get_id () == IDENTIFIER)\n-\t{\n-\t  rust_debug (\"just add to last error: token is not macro_rules and is \"\n-\t\t      \"instead '%s'\",\n-\t\t      t->get_str ().c_str ());\n-\t}\n-      else\n-\t{\n-\t  rust_debug (\"just add to last error: token is not macro_rules and is \"\n-\t\t      \"not an identifier either - it is '%s'\",\n-\t\t      t->get_token_description ());\n-\t}\n-\n-      return parse_macro_invocation_semi (std::move (outer_attrs));\n-    }\n-}\n-\n // Parses a macro rules definition syntax extension whatever thing.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::MacroRulesDefinition>\n@@ -1512,16 +1473,16 @@ Parser<ManagedTokenSource>::parse_macro_rules_def (AST::AttrVec outer_attrs)\n \t    {\n \t      // as this is the end, allow recovery (probably) - may change\n \t      return std::unique_ptr<AST::MacroRulesDefinition> (\n-\t\tnew AST::MacroRulesDefinition (\n+\t\tAST::MacroRulesDefinition::mbe (\n \t\t  std::move (rule_name), delim_type, std::move (macro_rules),\n \t\t  std::move (outer_attrs), macro_locus));\n \t    }\n \t}\n \n       return std::unique_ptr<AST::MacroRulesDefinition> (\n-\tnew AST::MacroRulesDefinition (std::move (rule_name), delim_type,\n-\t\t\t\t       std::move (macro_rules),\n-\t\t\t\t       std::move (outer_attrs), macro_locus));\n+\tAST::MacroRulesDefinition::mbe (std::move (rule_name), delim_type,\n+\t\t\t\t\tstd::move (macro_rules),\n+\t\t\t\t\tstd::move (outer_attrs), macro_locus));\n     }\n   else\n     {\n@@ -1541,6 +1502,165 @@ Parser<ManagedTokenSource>::parse_macro_rules_def (AST::AttrVec outer_attrs)\n     }\n }\n \n+// Parses a declarative macro 2.0 definition.\n+template <typename ManagedTokenSource>\n+std::unique_ptr<AST::MacroRulesDefinition>\n+Parser<ManagedTokenSource>::parse_decl_macro_def (AST::Visibility vis,\n+\t\t\t\t\t\t  AST::AttrVec outer_attrs)\n+{\n+  // ensure that first token is identifier saying \"macro\"\n+  const_TokenPtr t = lexer.peek_token ();\n+  if (t->get_id () != MACRO)\n+    {\n+      Error error (\n+\tt->get_locus (),\n+\t\"declarative macro definition does not start with %<macro%>\");\n+      add_error (std::move (error));\n+\n+      // skip after somewhere?\n+      return nullptr;\n+    }\n+  lexer.skip_token ();\n+  Location macro_locus = t->get_locus ();\n+\n+  // parse macro name\n+  const_TokenPtr ident_tok = expect_token (IDENTIFIER);\n+  if (ident_tok == nullptr)\n+    {\n+      return nullptr;\n+    }\n+  Identifier rule_name = ident_tok->get_str ();\n+\n+  t = lexer.peek_token ();\n+  if (t->get_id () == LEFT_PAREN)\n+    {\n+      // single definiton of macro rule\n+      // e.g. `macro foo($e:expr) {}`\n+\n+      // parse macro matcher\n+      Location locus = lexer.peek_token ()->get_locus ();\n+      AST::MacroMatcher matcher = parse_macro_matcher ();\n+      if (matcher.is_error ())\n+\treturn nullptr;\n+\n+      // check delimiter of macro matcher\n+      if (matcher.get_delim_type () != AST::DelimType::PARENS)\n+\t{\n+\t  Error error (locus, \"only parenthesis can be used for a macro \"\n+\t\t\t      \"matcher in declarative macro definition\");\n+\t  add_error (std::move (error));\n+\t  return nullptr;\n+\t}\n+\n+      Location transcriber_loc = lexer.peek_token ()->get_locus ();\n+      AST::DelimTokenTree delim_tok_tree = parse_delim_token_tree ();\n+      AST::MacroTranscriber transcriber (delim_tok_tree, transcriber_loc);\n+\n+      if (transcriber.get_token_tree ().get_delim_type ()\n+\t  != AST::DelimType::CURLY)\n+\t{\n+\t  Error error (transcriber_loc,\n+\t\t       \"only braces can be used for a macro transcriber \"\n+\t\t       \"in declarative macro definition\");\n+\t  add_error (std::move (error));\n+\t  return nullptr;\n+\t}\n+\n+      AST::MacroRule macro_rule\n+\t= AST::MacroRule (std::move (matcher), std::move (transcriber), locus);\n+      std::vector<AST::MacroRule> macro_rules;\n+      macro_rules.push_back (macro_rule);\n+\n+      return std::unique_ptr<AST::MacroRulesDefinition> (\n+\tAST::MacroRulesDefinition::decl_macro (std::move (rule_name),\n+\t\t\t\t\t       macro_rules,\n+\t\t\t\t\t       std::move (outer_attrs),\n+\t\t\t\t\t       macro_locus, vis));\n+    }\n+  else if (t->get_id () == LEFT_CURLY)\n+    {\n+      // multiple definitions of macro rule separated by comma\n+      // e.g. `macro foo { () => {}, ($e:expr) => {}, }`\n+\n+      // parse left curly\n+      const_TokenPtr left_curly = expect_token (LEFT_CURLY);\n+      if (left_curly == nullptr)\n+\t{\n+\t  return nullptr;\n+\t}\n+\n+      // parse actual macro rules\n+      std::vector<AST::MacroRule> macro_rules;\n+\n+      // must be at least one macro rule, so parse it\n+      AST::MacroRule initial_rule = parse_macro_rule ();\n+      if (initial_rule.is_error ())\n+\t{\n+\t  Error error (\n+\t    lexer.peek_token ()->get_locus (),\n+\t    \"required first macro rule in declarative macro definition \"\n+\t    \"could not be parsed\");\n+\t  add_error (std::move (error));\n+\n+\t  // skip after somewhere?\n+\t  return nullptr;\n+\t}\n+      macro_rules.push_back (std::move (initial_rule));\n+\n+      t = lexer.peek_token ();\n+      // parse macro rules\n+      while (t->get_id () == COMMA)\n+\t{\n+\t  // skip comma\n+\t  lexer.skip_token ();\n+\n+\t  // don't parse if end of macro rules\n+\t  if (token_id_matches_delims (lexer.peek_token ()->get_id (),\n+\t\t\t\t       AST::CURLY))\n+\t    {\n+\t      break;\n+\t    }\n+\n+\t  // try to parse next rule\n+\t  AST::MacroRule rule = parse_macro_rule ();\n+\t  if (rule.is_error ())\n+\t    {\n+\t      Error error (\n+\t\tlexer.peek_token ()->get_locus (),\n+\t\t\"failed to parse macro rule in declarative macro definition\");\n+\t      add_error (std::move (error));\n+\n+\t      return nullptr;\n+\t    }\n+\n+\t  macro_rules.push_back (std::move (rule));\n+\n+\t  t = lexer.peek_token ();\n+\t}\n+\n+      // parse right curly\n+      const_TokenPtr right_curly = expect_token (RIGHT_CURLY);\n+      if (right_curly == nullptr)\n+\t{\n+\t  return nullptr;\n+\t}\n+\n+      return std::unique_ptr<AST::MacroRulesDefinition> (\n+\tAST::MacroRulesDefinition::decl_macro (std::move (rule_name),\n+\t\t\t\t\t       std::move (macro_rules),\n+\t\t\t\t\t       std::move (outer_attrs),\n+\t\t\t\t\t       macro_locus, vis));\n+    }\n+  else\n+    {\n+      add_error (Error (t->get_locus (),\n+\t\t\t\"unexpected token %qs - expecting delimiters \"\n+\t\t\t\"(for a declarative macro definiton)\",\n+\t\t\tt->get_token_description ()));\n+      return nullptr;\n+    }\n+}\n+\n // Parses a semi-coloned (except for full block) macro invocation item.\n template <typename ManagedTokenSource>\n std::unique_ptr<AST::MacroInvocation>\n@@ -6004,6 +6124,7 @@ Parser<ManagedTokenSource>::parse_stmt (ParseRestrictions restrictions)\n     case STATIC_TOK:\n     case TRAIT:\n     case IMPL:\n+    case MACRO:\n     /* TODO: implement union keyword but not really because of\n      * context-dependence crappy hack way to parse a union written below to\n      * separate it from the good code. */\n@@ -6019,7 +6140,7 @@ Parser<ManagedTokenSource>::parse_stmt (ParseRestrictions restrictions)\n     case CRATE:\n     case DOLLAR_SIGN:\n       // almost certainly macro invocation semi\n-      return parse_macro_item (std::move (outer_attrs));\n+      return parse_macro_invocation_semi (std::move (outer_attrs));\n       break;\n     // crappy hack to do union \"keyword\"\n     case IDENTIFIER:\n@@ -6032,15 +6153,15 @@ Parser<ManagedTokenSource>::parse_stmt (ParseRestrictions restrictions)\n       else if (t->get_str () == \"macro_rules\")\n \t{\n \t  // macro_rules! macro item\n-\t  return parse_macro_item (std::move (outer_attrs));\n+\t  return parse_macro_rules_def (std::move (outer_attrs));\n \t}\n       else if (lexer.peek_token (1)->get_id () == SCOPE_RESOLUTION\n \t       || lexer.peek_token (1)->get_id () == EXCLAM)\n \t{\n \t  // FIXME: ensure doesn't take any expressions by mistake\n \t  /* path (probably) or macro invocation, so probably a macro\n \t   * invocation semi */\n-\t  return parse_macro_item (std::move (outer_attrs));\n+\t  return parse_macro_invocation_semi (std::move (outer_attrs));\n \t}\n       gcc_fallthrough ();\n       // TODO: find out how to disable gcc \"implicit fallthrough\" warning\n@@ -11711,8 +11832,8 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n       else if (t->get_str () == \"macro_rules\")\n \t{\n \t  // macro_rules! macro item\n-\t  std::unique_ptr<AST::MacroItem> item (\n-\t    parse_macro_item (std::move (outer_attrs)));\n+\t  std::unique_ptr<AST::Item> item (\n+\t    parse_macro_rules_def (std::move (outer_attrs)));\n \t  return ExprOrStmt (std::move (item));\n \t}\n       else if (lexer.peek_token (1)->get_id () == SCOPE_RESOLUTION"}, {"sha": "5c0fcc3f1740b89a0102abc11189a076a784027a", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -197,6 +197,8 @@ template <typename ManagedTokenSource> class Parser\n   AST::DelimTokenTree parse_delim_token_tree ();\n   std::unique_ptr<AST::MacroRulesDefinition>\n   parse_macro_rules_def (AST::AttrVec outer_attrs);\n+  std::unique_ptr<AST::MacroRulesDefinition>\n+  parse_decl_macro_def (AST::Visibility vis, AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::MacroInvocation>\n   parse_macro_invocation_semi (AST::AttrVec outer_attrs);\n   std::unique_ptr<AST::MacroInvocation>\n@@ -209,7 +211,6 @@ template <typename ManagedTokenSource> class Parser\n \n   // Top-level item-related\n   std::unique_ptr<AST::VisItem> parse_vis_item (AST::AttrVec outer_attrs);\n-  std::unique_ptr<AST::MacroItem> parse_macro_item (AST::AttrVec outer_attrs);\n \n   // VisItem subclass-related\n   std::unique_ptr<AST::Module> parse_module (AST::Visibility vis,"}, {"sha": "4a81a71e5004fd9960cac4c662f099bdfbec66da", "filename": "gcc/testsuite/rust/compile/decl_macro1.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro1.rs?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -0,0 +1,2 @@\n+#![feature(decl_macro)]\n+macro m() {}"}, {"sha": "cbe19b0c14b136c7bdaa3c2adf23e8c427f5397b", "filename": "gcc/testsuite/rust/compile/decl_macro2.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro2.rs?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -0,0 +1,2 @@\n+#![feature(decl_macro)]\n+pub macro m($e: expr) { $e + $e }"}, {"sha": "d48da7835f911ed46f6a052bf2c6b5a3d5a841ba", "filename": "gcc/testsuite/rust/compile/decl_macro3.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro3.rs?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -0,0 +1,4 @@\n+#![feature(decl_macro)]\n+macro foo {\n+    () => {}\n+}"}, {"sha": "b8576cf0dd853305bc41d41315aced32fab25c29", "filename": "gcc/testsuite/rust/compile/decl_macro4.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro4.rs?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -0,0 +1,5 @@\n+#![feature(decl_macro)]\n+macro foo {\n+    () => { 0 },\n+    ($n: expr) => { $n + 1 },\n+}\n\\ No newline at end of file"}, {"sha": "b4ea20ffa74db5258ceb3997ab30801010ada9f1", "filename": "gcc/testsuite/rust/compile/decl_macro5.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro5.rs?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -0,0 +1,5 @@\n+#![feature(decl_macro)]\n+macro foo {\n+    () => [],\n+    ($h: expr, $(t: expr),*) => ($h),\n+}"}, {"sha": "5c5e7002a98041adb551b2fdc99a0c81041fad8c", "filename": "gcc/testsuite/rust/compile/decl_macro6.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro6.rs?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -0,0 +1,5 @@\n+#![feature(decl_macro)]\n+macro m {}\n+// { dg-error \"unexpected token .\\}. - expecting delimiters .for a macro matcher.\" \"\" { target *-*-* } .-1 }\n+// { dg-error \"required first macro rule in declarative macro definition could not be parsed\" \"\" { target *-*-* } .-2 }\n+// { dg-error \"failed to parse item in crate\" \"\" { target *-*-* } .-3 }"}, {"sha": "7327fb5678216316483f5e49b971b49c2f8a0b60", "filename": "gcc/testsuite/rust/compile/decl_macro7.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro7.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro7.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fdecl_macro7.rs?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -0,0 +1,4 @@\n+#![feature(decl_macro)]\n+pub macro hello() [ \"Hello\" ]\n+// { dg-error \"only braces can be used for a macro transcriber in declarative macro definition\" \"\" { target *-*-* } .-1 }\n+// { dg-error \"failed to parse item in crate\" }\n\\ No newline at end of file"}, {"sha": "accc8b1db8e5d121e44cf7eff4f518d6896fd3b7", "filename": "gcc/testsuite/rust/execute/torture/decl_macro1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fdecl_macro1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fdecl_macro1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fdecl_macro1.rs?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -0,0 +1,8 @@\n+#![feature(decl_macro)]\n+macro one() {\n+    1\n+}\n+\n+fn main() -> i32 {\n+    one!() - 1\n+}"}, {"sha": "f42b96262feb7b9cf08e076a9608c84d20e548b2", "filename": "gcc/testsuite/rust/execute/torture/decl_macro2.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fdecl_macro2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fdecl_macro2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fdecl_macro2.rs?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -0,0 +1,8 @@\n+#![feature(decl_macro)]\n+macro one {\n+    () => { 1 }\n+}\n+\n+fn main() -> i32 {\n+    one!() - 1\n+}"}, {"sha": "fa2cf793cf2c9ad8cf18adfd767287a2bca9dd08", "filename": "gcc/testsuite/rust/execute/torture/decl_macro3.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fdecl_macro3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fdecl_macro3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fdecl_macro3.rs?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -0,0 +1,15 @@\n+#![feature(decl_macro)]\n+macro add {\n+    ($e:expr) => {\n+        $e\n+    },\n+    ($h:expr, $($t:expr),*) => {\n+        $h + add!($($t),*)\n+    },\n+}\n+\n+fn main() -> i32 {\n+    let a = add!(1, 2, 3);\n+\n+    a - 6\n+}"}, {"sha": "e700e63161db7c1ae3c5f9fcd32c74ba9f0d6b70", "filename": "gcc/testsuite/rust/execute/torture/decl_macro4.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fdecl_macro4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3290293e16fa47cf59f0434343c1bf40497ede90/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fdecl_macro4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fdecl_macro4.rs?ref=3290293e16fa47cf59f0434343c1bf40497ede90", "patch": "@@ -0,0 +1,15 @@\n+#![feature(decl_macro)]\n+pub macro add {\n+    ($e:expr) => {\n+        $e\n+    },\n+    ($h:expr, $($t:expr),*) => {\n+        $h + add!($($t),*)\n+    },\n+}\n+\n+fn main() -> i32 {\n+    let a = add!(1, 2, 3);\n+\n+    a - 6\n+}"}]}