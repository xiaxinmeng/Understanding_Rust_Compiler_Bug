{"sha": "f927760badd161592135b6ba58b5f418b19dcec5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkyNzc2MGJhZGQxNjE1OTIxMzViNmJhNThiNWY0MThiMTlkY2VjNQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-03-14T18:24:15Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-03-14T18:24:15Z"}, "message": "re PR rtl-optimization/17236 (inefficient code for long long multiply on x86)\n\n\n\tPR rtl-optimization/17236\n\t* optabs.c (expand_doubleword_mult): New helper function split out\n\tfrom expand_binop.  Permute the order in which instructions are\n\temitted to minimize the number of simultaneously live registers.\n\t(expand_binop): Call expand_doubleword_mult to synthesize a double\n\tword multiplication.\n\nFrom-SVN: r96441", "tree": {"sha": "bf30c17ba5e1564a31e749406185e5fe9e1e8ae8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf30c17ba5e1564a31e749406185e5fe9e1e8ae8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f927760badd161592135b6ba58b5f418b19dcec5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f927760badd161592135b6ba58b5f418b19dcec5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f927760badd161592135b6ba58b5f418b19dcec5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f927760badd161592135b6ba58b5f418b19dcec5/comments", "author": null, "committer": null, "parents": [{"sha": "a6ee1a15322bd2acadcd49c9e2aa315f32803de5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ee1a15322bd2acadcd49c9e2aa315f32803de5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6ee1a15322bd2acadcd49c9e2aa315f32803de5"}], "stats": {"total": 371, "additions": 198, "deletions": 173}, "files": [{"sha": "865c247c3f1680ab93058de0338642d64a65c2ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f927760badd161592135b6ba58b5f418b19dcec5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f927760badd161592135b6ba58b5f418b19dcec5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f927760badd161592135b6ba58b5f418b19dcec5", "patch": "@@ -1,3 +1,12 @@\n+2005-03-14  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR rtl-optimization/17236\n+\t* optabs.c (expand_doubleword_mult): New helper function split out\n+\tfrom expand_binop.  Permute the order in which instructions are\n+\temitted to minimize the number of simultaneously live registers.\n+\t(expand_binop): Call expand_doubleword_mult to synthesize a double\n+\tword multiplication.\n+\n 2005-03-14  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* basic-block.h: Update the prototypes of cached_make_edge and"}, {"sha": "f0c336e363e155e0c7e52431e82b79fbc9e5152b", "filename": "gcc/optabs.c", "status": "modified", "additions": 189, "deletions": 173, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f927760badd161592135b6ba58b5f418b19dcec5/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f927760badd161592135b6ba58b5f418b19dcec5/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f927760badd161592135b6ba58b5f418b19dcec5", "patch": "@@ -756,6 +756,168 @@ expand_doubleword_shift (enum machine_mode op1_mode, optab binoptab,\n   return true;\n }\n \f\n+/* Subroutine of expand_binop.  Perform a double word multiplication of\n+   operands OP0 and OP1 both of mode MODE, which is exactly twice as wide\n+   as the target's word_mode.  This function return NULL_RTX if anything\n+   goes wrong, in which case it may have already emitted instructions\n+   which need to be deleted.\n+\n+   If we want to multiply two two-word values and have normal and widening\n+   multiplies of single-word values, we can do this with three smaller\n+   multiplications.  Note that we do not make a REG_NO_CONFLICT block here\n+   because we are not operating on one word at a time.\n+\n+   The multiplication proceeds as follows:\n+\t\t\t         _______________________\n+\t\t\t        [__op0_high_|__op0_low__]\n+\t\t\t         _______________________\n+        *\t\t\t[__op1_high_|__op1_low__]\n+        _______________________________________________\n+\t\t\t         _______________________\n+    (1)\t\t\t\t[__op0_low__*__op1_low__]\n+\t\t     _______________________\n+    (2a)\t    [__op0_low__*__op1_high_]\n+\t\t     _______________________\n+    (2b)\t    [__op0_high_*__op1_low__]\n+         _______________________\n+    (3) [__op0_high_*__op1_high_]\n+\n+\n+  This gives a 4-word result.  Since we are only interested in the\n+  lower 2 words, partial result (3) and the upper words of (2a) and\n+  (2b) don't need to be calculated.  Hence (2a) and (2b) can be\n+  calculated using non-widening multiplication.\n+\n+  (1), however, needs to be calculated with an unsigned widening\n+  multiplication.  If this operation is not directly supported we\n+  try using a signed widening multiplication and adjust the result.\n+  This adjustment works as follows:\n+\n+      If both operands are positive then no adjustment is needed.\n+\n+      If the operands have different signs, for example op0_low < 0 and\n+      op1_low >= 0, the instruction treats the most significant bit of\n+      op0_low as a sign bit instead of a bit with significance\n+      2**(BITS_PER_WORD-1), i.e. the instruction multiplies op1_low\n+      with 2**BITS_PER_WORD - op0_low, and two's complements the\n+      result.  Conclusion: We need to add op1_low * 2**BITS_PER_WORD to\n+      the result.\n+\n+      Similarly, if both operands are negative, we need to add\n+      (op0_low + op1_low) * 2**BITS_PER_WORD.\n+\n+      We use a trick to adjust quickly.  We logically shift op0_low right\n+      (op1_low) BITS_PER_WORD-1 steps to get 0 or 1, and add this to\n+      op0_high (op1_high) before it is used to calculate 2b (2a).  If no\n+      logical shift exists, we do an arithmetic right shift and subtract\n+      the 0 or -1.  */\n+\n+static rtx\n+expand_doubleword_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n+\t\t       bool umulp, enum optab_methods methods)\n+{\n+  int low = (WORDS_BIG_ENDIAN ? 1 : 0);\n+  int high = (WORDS_BIG_ENDIAN ? 0 : 1);\n+  rtx wordm1 = umulp ? NULL_RTX : GEN_INT (BITS_PER_WORD - 1);\n+  rtx product, adjust, product_high, temp;\n+\n+  rtx op0_high = operand_subword_force (op0, high, mode);\n+  rtx op0_low = operand_subword_force (op0, low, mode);\n+  rtx op1_high = operand_subword_force (op1, high, mode);\n+  rtx op1_low = operand_subword_force (op1, low, mode);\n+\n+  /* If we're using an unsigned multiply to directly compute the product\n+     of the low-order words of the operands and perform any required\n+     adjustments of the operands, we begin by trying two more multiplications\n+     and then computing the appropriate sum.\n+\n+     We have checked above that the required addition is provided.\n+     Full-word addition will normally always succeed, especially if\n+     it is provided at all, so we don't worry about its failure.  The\n+     multiplication may well fail, however, so we do handle that.  */\n+\n+  if (!umulp)\n+    {\n+      /* ??? This could be done with emit_store_flag where available.  */\n+      temp = expand_binop (word_mode, lshr_optab, op0_low, wordm1,\n+\t\t\t   NULL_RTX, 1, methods);\n+      if (temp)\n+\top0_high = expand_binop (word_mode, add_optab, op0_high, temp,\n+\t\t\t\t op0_high, 0, OPTAB_DIRECT);\n+      else\n+\t{\n+\t  temp = expand_binop (word_mode, ashr_optab, op0_low, wordm1,\n+\t\t\t       NULL_RTX, 0, methods);\n+\t  if (!temp)\n+\t    return NULL_RTX;\n+\t  op0_high = expand_binop (word_mode, sub_optab, op0_high, temp,\n+\t\t\t\t   op0_high, 0, OPTAB_DIRECT);\n+\t}\n+\n+      if (!op0_high)\n+\treturn NULL_RTX;\n+    }\n+\n+  adjust = expand_binop (word_mode, smul_optab, op0_high, op1_low,\n+\t\t\t NULL_RTX, 0, OPTAB_DIRECT);\n+  if (!adjust)\n+    return NULL_RTX;\n+\n+  /* OP0_HIGH should now be dead.  */\n+\n+  if (!umulp)\n+    {\n+      /* ??? This could be done with emit_store_flag where available.  */\n+      temp = expand_binop (word_mode, lshr_optab, op1_low, wordm1,\n+\t\t\t   NULL_RTX, 1, methods);\n+      if (temp)\n+\top1_high = expand_binop (word_mode, add_optab, op1_high, temp,\n+\t\t\t\t op1_high, 0, OPTAB_DIRECT);\n+      else\n+\t{\n+\t  temp = expand_binop (word_mode, ashr_optab, op1_low, wordm1,\n+\t\t\t       NULL_RTX, 0, methods);\n+\t  if (!temp)\n+\t    return NULL_RTX;\n+\t  op1_high = expand_binop (word_mode, sub_optab, op1_high, temp,\n+\t\t\t\t   op1_high, 0, OPTAB_DIRECT);\n+\t}\n+\n+      if (!op1_high)\n+\treturn NULL_RTX;\n+    }\n+\n+  temp = expand_binop (word_mode, smul_optab, op1_high, op0_low,\n+\t\t       NULL_RTX, 0, OPTAB_DIRECT);\n+  if (!temp)\n+    return NULL_RTX;\n+\n+  /* OP1_HIGH should now be dead.  */\n+\n+  adjust = expand_binop (word_mode, add_optab, adjust, temp,\n+\t\t\t adjust, 0, OPTAB_DIRECT);\n+\n+  if (target && !REG_P (target))\n+    target = NULL_RTX;\n+\n+  if (umulp)\n+    product = expand_binop (mode, umul_widen_optab, op0_low, op1_low,\n+\t\t\t    target, 1, OPTAB_DIRECT);\n+  else\n+    product = expand_binop (mode, smul_widen_optab, op0_low, op1_low,\n+\t\t\t    target, 1, OPTAB_DIRECT);\n+\n+  if (!product)\n+    return NULL_RTX;\n+\n+  product_high = operand_subword (product, high, 1, mode);\n+  adjust = expand_binop (word_mode, add_optab, product_high, adjust,\n+\t\t\t REG_P (product_high) ? product_high : adjust,\n+\t\t\t 0, OPTAB_DIRECT);\n+  emit_move_insn (product_high, adjust);\n+  return product;\n+}\n+\f\n /* Wrapper around expand_binop which takes an rtx code to specify\n    the operation to perform, not an optab pointer.  All other\n    arguments are the same.  */\n@@ -1399,197 +1561,51 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \tdelete_insns_since (last);\n     }\n \n-  /* If we want to multiply two two-word values and have normal and widening\n-     multiplies of single-word values, we can do this with three smaller\n-     multiplications.  Note that we do not make a REG_NO_CONFLICT block here\n-     because we are not operating on one word at a time.\n-\n-     The multiplication proceeds as follows:\n-\t\t\t         _______________________\n-\t\t\t        [__op0_high_|__op0_low__]\n-\t\t\t         _______________________\n-        *\t\t\t[__op1_high_|__op1_low__]\n-        _______________________________________________\n-\t\t\t         _______________________\n-    (1)\t\t\t\t[__op0_low__*__op1_low__]\n-\t\t     _______________________\n-    (2a)\t    [__op0_low__*__op1_high_]\n-\t\t     _______________________\n-    (2b)\t    [__op0_high_*__op1_low__]\n-         _______________________\n-    (3) [__op0_high_*__op1_high_]\n-\n-\n-    This gives a 4-word result.  Since we are only interested in the\n-    lower 2 words, partial result (3) and the upper words of (2a) and\n-    (2b) don't need to be calculated.  Hence (2a) and (2b) can be\n-    calculated using non-widening multiplication.\n-\n-    (1), however, needs to be calculated with an unsigned widening\n-    multiplication.  If this operation is not directly supported we\n-    try using a signed widening multiplication and adjust the result.\n-    This adjustment works as follows:\n-\n-      If both operands are positive then no adjustment is needed.\n-\n-      If the operands have different signs, for example op0_low < 0 and\n-      op1_low >= 0, the instruction treats the most significant bit of\n-      op0_low as a sign bit instead of a bit with significance\n-      2**(BITS_PER_WORD-1), i.e. the instruction multiplies op1_low\n-      with 2**BITS_PER_WORD - op0_low, and two's complements the\n-      result.  Conclusion: We need to add op1_low * 2**BITS_PER_WORD to\n-      the result.\n-\n-      Similarly, if both operands are negative, we need to add\n-      (op0_low + op1_low) * 2**BITS_PER_WORD.\n-\n-      We use a trick to adjust quickly.  We logically shift op0_low right\n-      (op1_low) BITS_PER_WORD-1 steps to get 0 or 1, and add this to\n-      op0_high (op1_high) before it is used to calculate 2b (2a).  If no\n-      logical shift exists, we do an arithmetic right shift and subtract\n-      the 0 or -1.  */\n+  /* Attempt to synthesize double word multiplies using a sequence of word\n+     mode multiplications.  We first attempt to generate a sequence using a\n+     more efficient unsigned widening multiply, and if that fails we then\n+     try using a signed widening multiply.  */\n \n   if (binoptab == smul_optab\n       && class == MODE_INT\n       && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n       && smul_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing\n-      && add_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing\n-      && ((umul_widen_optab->handlers[(int) mode].insn_code\n-\t   != CODE_FOR_nothing)\n-\t  || (smul_widen_optab->handlers[(int) mode].insn_code\n-\t      != CODE_FOR_nothing)))\n+      && add_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing)\n     {\n-      int low = (WORDS_BIG_ENDIAN ? 1 : 0);\n-      int high = (WORDS_BIG_ENDIAN ? 0 : 1);\n-      rtx op0_high = operand_subword_force (op0, high, mode);\n-      rtx op0_low = operand_subword_force (op0, low, mode);\n-      rtx op1_high = operand_subword_force (op1, high, mode);\n-      rtx op1_low = operand_subword_force (op1, low, mode);\n-      rtx product = 0;\n-      rtx op0_xhigh = NULL_RTX;\n-      rtx op1_xhigh = NULL_RTX;\n-\n-      /* If the target is the same as one of the inputs, don't use it.  This\n-\t prevents problems with the REG_EQUAL note.  */\n-      if (target == op0 || target == op1\n-\t  || (target != 0 && !REG_P (target)))\n-\ttarget = 0;\n-\n-      /* Multiply the two lower words to get a double-word product.\n-\t If unsigned widening multiplication is available, use that;\n-\t otherwise use the signed form and compensate.  */\n-\n-      if (umul_widen_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n-\t{\n-\t  product = expand_binop (mode, umul_widen_optab, op0_low, op1_low,\n-\t\t\t\t  target, 1, OPTAB_DIRECT);\n+      rtx product = NULL_RTX;\n \n-\t  /* If we didn't succeed, delete everything we did so far.  */\n-\t  if (product == 0)\n+      if (umul_widen_optab->handlers[(int) mode].insn_code\n+\t  != CODE_FOR_nothing)\n+\t{\n+\t  product = expand_doubleword_mult (mode, op0, op1, target,\n+\t\t\t\t\t    true, methods);\n+\t  if (!product)\n \t    delete_insns_since (last);\n-\t  else\n-\t    op0_xhigh = op0_high, op1_xhigh = op1_high;\n \t}\n \n-      if (product == 0\n+      if (product == NULL_RTX\n \t  && smul_widen_optab->handlers[(int) mode].insn_code\n-\t       != CODE_FOR_nothing)\n+\t     != CODE_FOR_nothing)\n \t{\n-\t  rtx wordm1 = GEN_INT (BITS_PER_WORD - 1);\n-\t  product = expand_binop (mode, smul_widen_optab, op0_low, op1_low,\n-\t\t\t\t  target, 1, OPTAB_DIRECT);\n-\t  op0_xhigh = expand_binop (word_mode, lshr_optab, op0_low, wordm1,\n-\t\t\t\t    NULL_RTX, 1, next_methods);\n-\t  if (op0_xhigh)\n-\t    op0_xhigh = expand_binop (word_mode, add_optab, op0_high,\n-\t\t\t\t      op0_xhigh, op0_xhigh, 0, next_methods);\n-\t  else\n-\t    {\n-\t      op0_xhigh = expand_binop (word_mode, ashr_optab, op0_low, wordm1,\n-\t\t\t\t\tNULL_RTX, 0, next_methods);\n-\t      if (op0_xhigh)\n-\t\top0_xhigh = expand_binop (word_mode, sub_optab, op0_high,\n-\t\t\t\t\t  op0_xhigh, op0_xhigh, 0,\n-\t\t\t\t\t  next_methods);\n-\t    }\n-\n-\t  op1_xhigh = expand_binop (word_mode, lshr_optab, op1_low, wordm1,\n-\t\t\t\t    NULL_RTX, 1, next_methods);\n-\t  if (op1_xhigh)\n-\t    op1_xhigh = expand_binop (word_mode, add_optab, op1_high,\n-\t\t\t\t      op1_xhigh, op1_xhigh, 0, next_methods);\n-\t  else\n-\t    {\n-\t      op1_xhigh = expand_binop (word_mode, ashr_optab, op1_low, wordm1,\n-\t\t\t\t\tNULL_RTX, 0, next_methods);\n-\t      if (op1_xhigh)\n-\t\top1_xhigh = expand_binop (word_mode, sub_optab, op1_high,\n-\t\t\t\t\t  op1_xhigh, op1_xhigh, 0,\n-\t\t\t\t\t  next_methods);\n-\t    }\n+\t  product = expand_doubleword_mult (mode, op0, op1, target,\n+\t\t\t\t\t    false, methods);\n+\t  if (!product)\n+\t    delete_insns_since (last);\n \t}\n \n-      /* If we have been able to directly compute the product of the\n-\t low-order words of the operands and perform any required adjustments\n-\t of the operands, we proceed by trying two more multiplications\n-\t and then computing the appropriate sum.\n-\n-\t We have checked above that the required addition is provided.\n-\t Full-word addition will normally always succeed, especially if\n-\t it is provided at all, so we don't worry about its failure.  The\n-\t multiplication may well fail, however, so we do handle that.  */\n-\n-      if (product && op0_xhigh && op1_xhigh)\n+      if (product != NULL_RTX)\n \t{\n-\t  rtx product_high = operand_subword (product, high, 1, mode);\n-\t  rtx temp = expand_binop (word_mode, binoptab, op0_low, op1_xhigh,\n-\t\t\t\t   NULL_RTX, 0, OPTAB_DIRECT);\n-\n-\t  if (!REG_P (product_high))\n-\t    product_high = force_reg (word_mode, product_high);\n-\n-\t  if (temp != 0)\n-\t    temp = expand_binop (word_mode, add_optab, temp, product_high,\n-\t\t\t\t product_high, 0, next_methods);\n-\n-\t  if (temp != 0 && temp != product_high)\n-\t    emit_move_insn (product_high, temp);\n-\n-\t  if (temp != 0)\n-\t    temp = expand_binop (word_mode, binoptab, op1_low, op0_xhigh,\n-\t\t\t\t NULL_RTX, 0, OPTAB_DIRECT);\n-\n-\t  if (temp != 0)\n-\t    temp = expand_binop (word_mode, add_optab, temp,\n-\t\t\t\t product_high, product_high,\n-\t\t\t\t 0, next_methods);\n-\n-\t  if (temp != 0 && temp != product_high)\n-\t    emit_move_insn (product_high, temp);\n-\n-\t  emit_move_insn (operand_subword (product, high, 1, mode), product_high);\n-\n-\t  if (temp != 0)\n+\t  if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n \t    {\n-\t      if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n-\t\t{\n-\t\t  temp = emit_move_insn (product, product);\n-\t\t  set_unique_reg_note (temp,\n-\t\t\t\t       REG_EQUAL,\n-\t\t\t\t       gen_rtx_fmt_ee (MULT, mode,\n-\t\t\t\t\t\t       copy_rtx (op0),\n-\t\t\t\t\t\t       copy_rtx (op1)));\n-\t\t}\n-\n-\t      return product;\n+\t      temp = emit_move_insn (target ? target : product, product);\n+\t      set_unique_reg_note (temp,\n+\t\t\t\t   REG_EQUAL,\n+\t\t\t\t   gen_rtx_fmt_ee (MULT, mode,\n+\t\t\t\t\t\t   copy_rtx (op0),\n+\t\t\t\t\t\t   copy_rtx (op1)));\n \t    }\n+\t  return product;\n \t}\n-\n-      /* If we get here, we couldn't do it for some reason even though we\n-\t originally thought we could.  Delete anything we've emitted in\n-\t trying to do it.  */\n-\n-      delete_insns_since (last);\n     }\n \n   /* It can't be open-coded in this mode."}]}