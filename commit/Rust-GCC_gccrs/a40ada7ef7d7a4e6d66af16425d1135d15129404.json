{"sha": "a40ada7ef7d7a4e6d66af16425d1135d15129404", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQwYWRhN2VmN2Q3YTRlNmQ2NmFmMTY0MjVkMTEzNWQxNTEyOTQwNA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2012-10-04T09:10:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-04T09:10:08Z"}, "message": "checks.adb (Minimize_Eliminate_Overflow_Checks): Dont reanalyze if/case expression if nothing has changed (just reexpand).\n\n2012-10-04  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Minimize_Eliminate_Overflow_Checks): Dont reanalyze\n\tif/case expression if nothing has changed (just reexpand). Stops\n\tcase expression from generating incorrect temporary.\n\t* exp_ch4.adb (Expand_Compare_Minimize_Eliminate_Overflow):\n\tFix cut and paste typo for range analysis in NE (not equal) case.\n\t* sem_eval.adb (Compile_Time_Compare): Small optimization to\n\tcatch some more cases.\n\t* types.ads (Suppressed_Or_Checked): New subtype of\n\tOverflow_Check_Type.\n\nFrom-SVN: r192070", "tree": {"sha": "1808e4c1ca1a676ee883f928f954cc4663d53ea7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1808e4c1ca1a676ee883f928f954cc4663d53ea7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a40ada7ef7d7a4e6d66af16425d1135d15129404", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a40ada7ef7d7a4e6d66af16425d1135d15129404", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a40ada7ef7d7a4e6d66af16425d1135d15129404", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a40ada7ef7d7a4e6d66af16425d1135d15129404/comments", "author": null, "committer": null, "parents": [{"sha": "f62b296e6aa2f756683db7cf529e1b5b9d573531", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f62b296e6aa2f756683db7cf529e1b5b9d573531", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f62b296e6aa2f756683db7cf529e1b5b9d573531"}], "stats": {"total": 194, "additions": 118, "deletions": 76}, "files": [{"sha": "66a04661373c2090cc17963146873e7e6ecdbe15", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a40ada7ef7d7a4e6d66af16425d1135d15129404/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a40ada7ef7d7a4e6d66af16425d1135d15129404/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a40ada7ef7d7a4e6d66af16425d1135d15129404", "patch": "@@ -1,3 +1,15 @@\n+2012-10-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Minimize_Eliminate_Overflow_Checks): Dont reanalyze\n+\tif/case expression if nothing has changed (just reexpand). Stops\n+\tcase expression from generating incorrect temporary.\n+\t* exp_ch4.adb (Expand_Compare_Minimize_Eliminate_Overflow):\n+\tFix cut and paste typo for range analysis in NE (not equal) case.\n+\t* sem_eval.adb (Compile_Time_Compare): Small optimization to\n+\tcatch some more cases.\n+\t* types.ads (Suppressed_Or_Checked): New subtype of\n+\tOverflow_Check_Type.\n+\n 2012-10-04  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_disp.adb (Set_CPP_Constructors_Old): Removed."}, {"sha": "075eb14caebf24fc6b6105bb361ee56dc3586d86", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 57, "deletions": 35, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a40ada7ef7d7a4e6d66af16425d1135d15129404/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a40ada7ef7d7a4e6d66af16425d1135d15129404/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=a40ada7ef7d7a4e6d66af16425d1135d15129404", "patch": "@@ -34,6 +34,7 @@ with Exp_Pakd; use Exp_Pakd;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Elists;   use Elists;\n+with Expander; use Expander;\n with Eval_Fat; use Eval_Fat;\n with Freeze;   use Freeze;\n with Lib;      use Lib;\n@@ -1272,8 +1273,7 @@ package body Checks is\n             Apply_Range_Check (N, Typ);\n          end if;\n \n-      elsif (Is_Record_Type (Typ)\n-               or else Is_Private_Type (Typ))\n+      elsif (Is_Record_Type (Typ) or else Is_Private_Type (Typ))\n         and then Has_Discriminants (Base_Type (Typ))\n         and then Is_Constrained (Typ)\n       then\n@@ -6709,10 +6709,12 @@ package body Checks is\n    --  to be done in bignum mode), and the determined ranges of the operands.\n \n    --  After possible rewriting of a constituent subexpression node, a call is\n-   --  made to reanalyze the node after setting Analyzed to False. To avoid a\n-   --  recursive call into the whole overflow apparatus, and important rule for\n-   --  this reanalysis call is that either Do_Overflow_Check must be False, or\n-   --  if it is set, then the overflow checking mode must be temporarily set\n+   --  made to either reexpand the node (if nothing has changed) or reanalyze\n+   --  the node (if it has been modified by the overflow check processing).\n+   --  The Analyzed_flag is set False before the reexpand/reanalyze. To avoid\n+   --  a recursive call into the whole overflow apparatus, and important rule\n+   --  for this call is that either Do_Overflow_Check must be False, or if\n+   --  it is set, then the overflow checking mode must be temporarily set\n    --  to Checked/Suppressed. Either step will avoid the unwanted recursion.\n \n    procedure Minimize_Eliminate_Overflow_Checks\n@@ -6761,6 +6763,17 @@ package body Checks is\n       --  range, then we must convert such operands back to the result type.\n       --  This switch is properly set only when Bignum_Operands is False.\n \n+      procedure Reexpand (C : Suppressed_Or_Checked);\n+      --  This is called when we have not modifed the node, so we do not need\n+      --  to reanalyze it. But we do want to reexpand it in either CHECKED\n+      --  or SUPPRESSED mode (as indicated by the argument C) to get proper\n+      --  expansion. It is important that we reset the mode to SUPPRESSED or\n+      --  CHECKED, since if we leave it in MINIMIZED or ELIMINATED mode we\n+      --  would reenter this routine recursively which would not be good!\n+      --  Note that this is not just an optimization, testing has showed up\n+      --  several complex cases in which renalyzing an already analyzed node\n+      --  causes incorrect behavior.\n+\n       function In_Result_Range return Boolean;\n       --  Returns True iff Lo .. Hi are within range of the result type\n \n@@ -6813,6 +6826,24 @@ package body Checks is\n          end if;\n       end Min;\n \n+      --------------\n+      -- Reexpand --\n+      --------------\n+\n+      procedure Reexpand (C : Suppressed_Or_Checked) is\n+         Svg : constant Overflow_Check_Type :=\n+                 Scope_Suppress.Overflow_Checks_General;\n+         Sva : constant Overflow_Check_Type :=\n+                 Scope_Suppress.Overflow_Checks_Assertions;\n+      begin\n+         Scope_Suppress.Overflow_Checks_General    := C;\n+         Scope_Suppress.Overflow_Checks_Assertions := C;\n+         Set_Analyzed (N, False);\n+         Expand (N);\n+         Scope_Suppress.Overflow_Checks_General    := Svg;\n+         Scope_Suppress.Overflow_Checks_Assertions := Sva;\n+      end Reexpand;\n+\n    --  Start of processing for Minimize_Eliminate_Overflow_Checks\n \n    begin\n@@ -6890,13 +6921,13 @@ package body Checks is\n             --  If we have no Long_Long_Integer operands, then we are in result\n             --  range, since it means that none of our operands felt the need\n             --  to worry about overflow (otherwise it would have already been\n-            --  converted to long long integer or bignum). We reanalyze to\n-            --  complete the expansion of the if expression\n+            --  converted to long long integer or bignum). We reexpand to\n+            --  complete the expansion of the if expression (but we do not\n+            --  need to reanalyze).\n \n             elsif not Long_Long_Integer_Operands then\n                Set_Do_Overflow_Check (N, False);\n-               Set_Analyzed (N, False);\n-               Analyze_And_Resolve (N, Suppress => Overflow_Check);\n+               Reexpand (Suppressed);\n \n             --  Otherwise convert us to long long integer mode. Note that we\n             --  don't need any further overflow checking at this level.\n@@ -6953,14 +6984,13 @@ package body Checks is\n             --  that none of our dependent expressions could raise overflow.\n             --  In this case, we simply return with no changes except for\n             --  resetting the overflow flag, since we are done with overflow\n-            --  checks for this node. We will reset the Analyzed flag so that\n-            --  we will properly reexpand and get the needed expansion for\n-            --  the case expression.\n+            --  checks for this node. We will reexpand to get the needed\n+            --  expansion for the case expression, but we do not need to\n+            --  renalyze, since nothing has changed.\n \n             if not (Bignum_Operands or Long_Long_Integer_Operands) then\n                Set_Do_Overflow_Check (N, False);\n-               Set_Analyzed (N, False);\n-               Analyze_And_Resolve (N, Suppress => Overflow_Check);\n+               Reexpand (Suppressed);\n \n             --  Otherwise we are going to rebuild the case expression using\n             --  either bignum or long long integer operands throughout.\n@@ -7381,18 +7411,20 @@ package body Checks is\n          end case;\n       end if;\n \n-      --  If we know we are in the result range, and we do not have Bignum\n-      --  operands or Long_Long_Integer operands, we can just renalyze with\n-      --  overflow checks turned off (since we know we cannot have overflow).\n-      --  As always the reanalysis is required to complete expansion of the\n-      --  operator, and we prevent recursion by suppressing the check.\n+      --  Here for the case where we have not rewritten anything (no bignum\n+      --  operands or long long integer operands), and we know the result If we\n+      --  know we are in the result range, and we do not have Bignum operands\n+      --  or Long_Long_Integer operands, we can just reexpand with overflow\n+      --  checks turned off (since we know we cannot have overflow). As always\n+      --  the reexpansion is required to complete expansion of the operator,\n+      --  but we do not need to reanalyze, and we prevent recursion by\n+      --  suppressing the check,\n \n       if not (Bignum_Operands or Long_Long_Integer_Operands)\n         and then In_Result_Range\n       then\n          Set_Do_Overflow_Check (N, False);\n-         Set_Analyzed (N, False);\n-         Analyze_And_Resolve (N, Suppress => Overflow_Check);\n+         Reexpand (Suppressed);\n          return;\n \n       --  Here we know that we are not in the result range, and in the general\n@@ -7427,20 +7459,10 @@ package body Checks is\n          --  eliminated overflow processing which is not what we want. Here\n          --  we are at the top level, and we need a check against the result\n          --  mode (i.e. we want to use Checked mode). So do exactly that!\n+         --  Also, we have not modified the node, so this is a case where\n+         --  we need to reexpand, but not reanalyze.\n \n-         declare\n-            Svg : constant Overflow_Check_Type :=\n-                    Scope_Suppress.Overflow_Checks_General;\n-            Sva : constant Overflow_Check_Type :=\n-                    Scope_Suppress.Overflow_Checks_Assertions;\n-         begin\n-            Scope_Suppress.Overflow_Checks_General    := Checked;\n-            Scope_Suppress.Overflow_Checks_Assertions := Checked;\n-            Analyze_And_Resolve (N);\n-            Scope_Suppress.Overflow_Checks_General    := Svg;\n-            Scope_Suppress.Overflow_Checks_Assertions := Sva;\n-         end;\n-\n+         Reexpand (Checked);\n          return;\n \n       --  Cases where we do the operation in Bignum mode. This happens either"}, {"sha": "869143733074f02f6bbdd4a42b0c5406b8a5d926", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a40ada7ef7d7a4e6d66af16425d1135d15129404/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a40ada7ef7d7a4e6d66af16425d1135d15129404/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=a40ada7ef7d7a4e6d66af16425d1135d15129404", "patch": "@@ -2331,7 +2331,7 @@ package body Exp_Ch4 is\n          when N_Op_Eq =>\n             if Llo = Lhi and then Rlo = Rhi and then Llo = Rlo then\n                Set_True;\n-            elsif Llo > Rhi or else Rlo > Lhi then\n+            elsif Llo > Rhi or else Lhi < Rlo then\n                Set_False;\n             end if;\n \n@@ -2365,9 +2365,9 @@ package body Exp_Ch4 is\n \n          when N_Op_Ne =>\n             if Llo = Lhi and then Rlo = Rhi and then Llo = Rlo then\n-               Set_True;\n-            elsif Llo > Rhi or else Rlo > Lhi then\n                Set_False;\n+            elsif Llo > Rhi or else Lhi < Rlo then\n+               Set_True;\n             end if;\n       end case;\n "}, {"sha": "f42bfb37fddcb9fc322350455b1c1556b27c287c", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 43, "deletions": 37, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a40ada7ef7d7a4e6d66af16425d1135d15129404/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a40ada7ef7d7a4e6d66af16425d1135d15129404/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=a40ada7ef7d7a4e6d66af16425d1135d15129404", "patch": "@@ -942,7 +942,49 @@ package body Sem_Eval is\n             end if;\n          end if;\n \n-         --  Try range analysis on variables and see if ranges are disjoint\n+         --  First attempt is to decompose the expressions to extract a\n+         --  constant offset resulting from the use of any of the forms:\n+\n+         --     expr + literal\n+         --     expr - literal\n+         --     typ'Succ (expr)\n+         --     typ'Pred (expr)\n+\n+         --  Then we see if the two expressions are the same value, and if so\n+         --  the result is obtained by comparing the offsets.\n+\n+         --  Note: the reason we do this test first is that it returns only\n+         --  decisive results (with diff set), where other tests, like the\n+         --  range test, may not be as so decisive. Consider for example\n+         --  J .. J + 1. This code can conclude LT with a difference of 1,\n+         --  even if the range of J is not known.\n+\n+         declare\n+            Lnode : Node_Id;\n+            Loffs : Uint;\n+            Rnode : Node_Id;\n+            Roffs : Uint;\n+\n+         begin\n+            Compare_Decompose (L, Lnode, Loffs);\n+            Compare_Decompose (R, Rnode, Roffs);\n+\n+            if Is_Same_Value (Lnode, Rnode) then\n+               if Loffs = Roffs then\n+                  return EQ;\n+\n+               elsif Loffs < Roffs then\n+                  Diff.all := Roffs - Loffs;\n+                  return LT;\n+\n+               else\n+                  Diff.all := Loffs - Roffs;\n+                  return GT;\n+               end if;\n+            end if;\n+         end;\n+\n+         --  Next, try range analysis and see if operand ranges are disjoint\n \n          declare\n             LOK, ROK : Boolean;\n@@ -1074,42 +1116,6 @@ package body Sem_Eval is\n             end if;\n          end if;\n \n-         --  Next attempt is to decompose the expressions to extract\n-         --  a constant offset resulting from the use of any of the forms:\n-\n-         --     expr + literal\n-         --     expr - literal\n-         --     typ'Succ (expr)\n-         --     typ'Pred (expr)\n-\n-         --  Then we see if the two expressions are the same value, and if so\n-         --  the result is obtained by comparing the offsets.\n-\n-         declare\n-            Lnode : Node_Id;\n-            Loffs : Uint;\n-            Rnode : Node_Id;\n-            Roffs : Uint;\n-\n-         begin\n-            Compare_Decompose (L, Lnode, Loffs);\n-            Compare_Decompose (R, Rnode, Roffs);\n-\n-            if Is_Same_Value (Lnode, Rnode) then\n-               if Loffs = Roffs then\n-                  return EQ;\n-\n-               elsif Loffs < Roffs then\n-                  Diff.all := Roffs - Loffs;\n-                  return LT;\n-\n-               else\n-                  Diff.all := Loffs - Roffs;\n-                  return GT;\n-               end if;\n-            end if;\n-         end;\n-\n          --  Next attempt is to see if we have an entity compared with a\n          --  compile time known value, where there is a current value\n          --  conditional for the entity which can tell us the result."}, {"sha": "277bfd5514629aae3092c9fc613d59e0030efcfb", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a40ada7ef7d7a4e6d66af16425d1135d15129404/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a40ada7ef7d7a4e6d66af16425d1135d15129404/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=a40ada7ef7d7a4e6d66af16425d1135d15129404", "patch": "@@ -737,7 +737,9 @@ package Types is\n \n    subtype Minimized_Or_Eliminated is\n      Overflow_Check_Type range Minimized .. Eliminated;\n-   --  Definte subtypes so that clients don't need to know ordering. Note that\n+   subtype Suppressed_Or_Checked is\n+     Overflow_Check_Type range Suppressed .. Checked;\n+   --  Define subtypes so that clients don't need to know ordering. Note that\n    --  Overflow_Check_Type is not marked as an ordered enumeration type.\n \n    --  The following structure captures the state of check suppression or"}]}