{"sha": "fe89d79748951c95a113e10b6184ca5284d3936d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU4OWQ3OTc0ODk1MWM5NWExMTNlMTBiNjE4NGNhNTI4NGQzOTM2ZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-06-15T03:26:38Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-06-15T03:26:38Z"}, "message": "re PR c++/26559 (ICE with __builtin_constant_p in template argument)\n\n2006-06-14  Mark Mitchell  <mark@codesourcery.com>\n\n\tPR c++/26559\n\t* c-common.h (c_finish_omp_atomic): Adjust declaration.\n\t* c-omp.c (c_finish_omp_atomic): Return the expression to perform,\n\trather than calling add_stmt on it.\n\t* c-parser.c (c_parser_omp_atomic): Adjust accordingly.\n\n2006-06-14  Mark Mitchell  <mark@codesourcery.com>\n\n\tPR c++/26559\n\t* pt.c (tsubst_expr): Use finish_omp_atomic.\n\t(value_dependent_expression_p): All CALL_EXPRs are dependent.\n\t* semantics.c (finish_omp_atomic): Rework to use standard\n\tparadigms for handling non-dependent expressions.\n\n2006-06-14  Mark Mitchell  <mark@codesourcery.com>\n\n\tPR c++/26559\n\t* g++.dg/template/builtin1.C: New test.\n\t* g++.dg/gomp/tpl-atomic-2.C: Remove XFAIL.\n\nFrom-SVN: r114665", "tree": {"sha": "2419236a5dd577e978264804fe2c75548fb14e25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2419236a5dd577e978264804fe2c75548fb14e25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe89d79748951c95a113e10b6184ca5284d3936d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe89d79748951c95a113e10b6184ca5284d3936d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe89d79748951c95a113e10b6184ca5284d3936d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe89d79748951c95a113e10b6184ca5284d3936d/comments", "author": null, "committer": null, "parents": [{"sha": "801522dead7b6e710f78eb26017195c814db04a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/801522dead7b6e710f78eb26017195c814db04a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/801522dead7b6e710f78eb26017195c814db04a2"}], "stats": {"total": 101, "additions": 59, "deletions": 42}, "files": [{"sha": "4713d2e812174184744e8f2148f44ebc1826ee41", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fe89d79748951c95a113e10b6184ca5284d3936d", "patch": "@@ -1,3 +1,11 @@\n+2006-06-14  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/26559\n+\t* c-common.h (c_finish_omp_atomic): Adjust declaration.\n+\t* c-omp.c (c_finish_omp_atomic): Return the expression to perform,\n+\trather than calling add_stmt on it.\n+\t* c-parser.c (c_parser_omp_atomic): Adjust accordingly.\n+\n 2006-06-14  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \tPR middle-end/27959"}, {"sha": "4f4919e9b0b76f45fcc30a60e402e3c682470a0d", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=fe89d79748951c95a113e10b6184ca5284d3936d", "patch": "@@ -948,7 +948,7 @@ extern tree c_finish_omp_master (tree);\n extern tree c_finish_omp_critical (tree, tree);\n extern tree c_finish_omp_ordered (tree);\n extern void c_finish_omp_barrier (void);\n-extern void c_finish_omp_atomic (enum tree_code, tree, tree);\n+extern tree c_finish_omp_atomic (enum tree_code, tree, tree);\n extern void c_finish_omp_flush (void);\n extern tree c_finish_omp_for (location_t, tree, tree, tree, tree, tree, tree);\n extern void c_split_parallel_clauses (tree, tree *, tree *);"}, {"sha": "fe56824401cce560a2e2ce13097a49745a7d6726", "filename": "gcc/c-omp.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-omp.c?ref=fe89d79748951c95a113e10b6184ca5284d3936d", "patch": "@@ -82,15 +82,18 @@ c_finish_omp_barrier (void)\n \n \n /* Complete a #pragma omp atomic construct.  The expression to be \n-   implemented atomically is LHS code= RHS.  */\n+   implemented atomically is LHS code= RHS.  The value returned is\n+   either error_mark_node (if the construct was erroneous) or an\n+   OMP_ATOMIC node which should be added to the current statement tree\n+   with add_stmt.  */\n \n-void\n+tree\n c_finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n {\n   tree x, type, addr;\n \n   if (lhs == error_mark_node || rhs == error_mark_node)\n-    return;\n+    return error_mark_node;\n \n   /* ??? According to one reading of the OpenMP spec, complex type are\n      supported, but there are no atomic stores for any architecture.\n@@ -102,7 +105,7 @@ c_finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n       && !SCALAR_FLOAT_TYPE_P (type))\n     {\n       error (\"invalid expression type for %<#pragma omp atomic%>\");\n-      return;\n+      return error_mark_node;\n     }\n \n   /* ??? Validate that rhs does not overlap lhs.  */\n@@ -111,7 +114,7 @@ c_finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n      via indirection.  */\n   addr = build_unary_op (ADDR_EXPR, lhs, 0);\n   if (addr == error_mark_node)\n-    return;\n+    return error_mark_node;\n   addr = save_expr (addr);\n   lhs = build_indirect_ref (addr, NULL);\n \n@@ -120,12 +123,12 @@ c_finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n      to do this, and then take it apart again.  */\n   x = build_modify_expr (lhs, code, rhs);\n   if (x == error_mark_node)\n-    return;\n+    return error_mark_node;\n   gcc_assert (TREE_CODE (x) == MODIFY_EXPR);  \n   rhs = TREE_OPERAND (x, 1);\n \n   /* Punt the actual generation of atomic operations to common code.  */\n-  add_stmt (build2 (OMP_ATOMIC, void_type_node, addr, rhs));\n+  return build2 (OMP_ATOMIC, void_type_node, addr, rhs);\n }\n \n "}, {"sha": "bca6a1483881ca306afaa9d61e4d1dbdb441718a", "filename": "gcc/c-parser.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=fe89d79748951c95a113e10b6184ca5284d3936d", "patch": "@@ -7214,6 +7214,7 @@ static void\n c_parser_omp_atomic (c_parser *parser)\n {\n   tree lhs, rhs;\n+  tree stmt;\n   enum tree_code code;\n \n   c_parser_skip_to_pragma_eol (parser);\n@@ -7280,7 +7281,9 @@ c_parser_omp_atomic (c_parser *parser)\n       rhs = c_parser_expression (parser).value;\n       break;\n     }\n-  c_finish_omp_atomic (code, lhs, rhs);\n+  stmt = c_finish_omp_atomic (code, lhs, rhs);\n+  if (stmt != error_mark_node)\n+    add_stmt (stmt);\n   c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n }\n "}, {"sha": "abd63d9be4f8a218d703ad89cd3205247bf768a2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fe89d79748951c95a113e10b6184ca5284d3936d", "patch": "@@ -4,6 +4,19 @@\n \n 2006-06-14  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* parser.c (cp_parser_unqualified_id): Use constructor_name_p to\n+\tcheck destructor names.\n+\t(cp_parser_nested_name_specifier_opt): Remove invalid\n+\toptimization.\n+\n+\t* parser.c (cp_parser_declarator): Robustify.\n+\n+\tPR c++/26559\n+\t* pt.c (tsubst_expr): Use finish_omp_atomic.\n+\t(value_dependent_expression_p): All CALL_EXPRs are dependent.\n+\t* semantics.c (finish_omp_atomic): Rework to use standard\n+\tparadigms for handling non-dependent expressions.\n+\n \tPR c++/28018\n \t* typeck.c (build_modify_expr): Disallow array assignment.\n "}, {"sha": "0cc93fdbb115eb9974f605454fb273ca318368c7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=fe89d79748951c95a113e10b6184ca5284d3936d", "patch": "@@ -8546,10 +8546,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \ttree op0, op1;\n \top0 = tsubst_expr (TREE_OPERAND (t, 0), args, complain, in_decl);\n \top1 = tsubst_expr (TREE_OPERAND (t, 1), args, complain, in_decl);\n-\tif (OMP_ATOMIC_DEPENDENT_P (t))\n-\t  c_finish_omp_atomic (OMP_ATOMIC_CODE (t), op0, op1);\n-\telse\n-\t  add_stmt (build2 (OMP_ATOMIC, void_type_node, op0, op1));\n+\tfinish_omp_atomic (OMP_ATOMIC_CODE (t), op0, op1);\n       }\n       break;\n \n@@ -12473,7 +12470,8 @@ dependent_scope_ref_p (tree expression, bool criterion (tree))\n }\n \n /* Returns TRUE if the EXPRESSION is value-dependent, in the sense of\n-   [temp.dep.constexpr] */\n+   [temp.dep.constexpr].  EXPRESSION is already known to be a constant\n+   expression.  */\n \n bool\n value_dependent_expression_p (tree expression)\n@@ -12564,32 +12562,10 @@ value_dependent_expression_p (tree expression)\n \t      || value_dependent_expression_p (TREE_OPERAND (expression, 1)));\n \n     case CALL_EXPR:\n-      /* A CALL_EXPR is value-dependent if any argument is\n-\t value-dependent.  Why do we have to handle CALL_EXPRs in this\n-\t function at all?  First, some function calls, those for which\n-\t value_dependent_expression_p is true, man appear in constant\n-\t expressions.  Second, there appear to be bugs which result in\n-\t other CALL_EXPRs reaching this point. */\n-      {\n-\ttree function = TREE_OPERAND (expression, 0);\n-\ttree args = TREE_OPERAND (expression, 1);\n-\n-\tif (value_dependent_expression_p (function))\n-\t  return true;\n-\n-\tif (! args)\n-\t  return false;\n-\n-\tif (TREE_CODE (args) == TREE_LIST)\n-\t  {\n-\t    for (; args; args = TREE_CHAIN (args))\n-\t      if (value_dependent_expression_p (TREE_VALUE (args)))\n-\t\treturn true;\n-\t    return false;\n-\t  }\n-\n-\treturn value_dependent_expression_p (args);\n-      }\n+      /* A CALL_EXPR may appear in a constant expression if it is a\n+\t call to a builtin function, e.g., __builtin_constant_p.  All\n+\t such calls are value-dependent.  */\n+      return true;\n \n     default:\n       /* A constant expression is value-dependent if any subexpression is"}, {"sha": "6615324667beded700c5085ceba93424b6ccd201", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fe89d79748951c95a113e10b6184ca5284d3936d", "patch": "@@ -1,5 +1,9 @@\n 2006-06-14  Mark Mitchell  <mark@codesourcery.com>\n \n+\tPR c++/26559\n+\t* g++.dg/template/builtin1.C: New test.\n+\t* g++.dg/gomp/tpl-atomic-2.C: Remove XFAIL.\n+\t\n \tPR c++/28018\n \t* g++.old-deja/g++.benjamin/14664-2.C: Expect error for array\n \tassignment."}, {"sha": "c27f20193971462b8f55ad3c5a2fb5d62a7d44c4", "filename": "gcc/testsuite/g++.dg/gomp/tpl-atomic-2.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-atomic-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-atomic-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-atomic-2.C?ref=fe89d79748951c95a113e10b6184ca5284d3936d", "patch": "@@ -17,11 +17,10 @@ template<typename T> void f2(float *f)\n }\n \n // Here the rhs is dependent, but not type dependent.\n-// ??? Fails.  See the comment in finish_omp_atomic.\n template<typename T> void f3(float *f)\n {\n   #pragma omp atomic\n-  *f |= sizeof (T);\t// { dg-error \"invalid|evaluation\" \"\" { xfail *-*-* } }\n+  *f |= sizeof (T);\t// { dg-error \"invalid|evaluation\" }\n }\n \n // And the converse, no error here because we're never fed a T."}, {"sha": "a5b7271cb73de8a52e83b3877457bef93327a0ad", "filename": "gcc/testsuite/g++.dg/template/builtin1.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fbuiltin1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe89d79748951c95a113e10b6184ca5284d3936d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fbuiltin1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fbuiltin1.C?ref=fe89d79748951c95a113e10b6184ca5284d3936d", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/26559\n+\n+template<bool> struct cond;\n+\n+template<int> struct S {\n+  void f(int i) {\n+    cond<__builtin_constant_p(i)>();\n+  }\n+};\n+\n+S<1> s;"}]}