{"sha": "0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYwZmQ3NDUyNTVhZGY4YjI5MDRiMGFjYWYxYzNiNjZlYzkzZGRiMg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2015-05-20T01:26:28Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2015-05-20T01:26:28Z"}, "message": "rs6000-common.c (TARGET_SUPPORTS_SPLIT_STACK): Define.\n\ngcc/\n\t* common/config/rs6000/rs6000-common.c (TARGET_SUPPORTS_SPLIT_STACK):\n\tDefine.\n\t(rs6000_supports_split_stack): New function.\n\t* gcc/config/rs6000/rs6000.c (machine_function): Add\n\tsplit_stack_arg_pointer.\n\t(TARGET_EXTRA_LIVE_ON_ENTRY, TARGET_INTERNAL_ARG_POINTER): Define.\n\t(setup_incoming_varargs): Use crtl->args.internal_arg_pointer\n\trather than virtual_incoming_args_rtx.\n\t(rs6000_va_start): Likewise.\n\t(split_stack_arg_pointer_used_p): New function.\n\t(rs6000_emit_prologue): Set up arg pointer for -fsplit-stack.\n\t(morestack_ref): New var.\n\t(gen_add3_const, rs6000_expand_split_stack_prologue,\n\trs6000_internal_arg_pointer, rs6000_live_on_entry,\n\trs6000_split_stack_space_check): New functions.\n\t(rs6000_elf_file_end): Call file_end_indicate_split_stack.\n\t* gcc/config/rs6000/rs6000.md (UNSPEC_STACK_CHECK): Define.\n\t(UNSPECV_SPLIT_STACK_RETURN): Define.\n\t(split_stack_prologue, load_split_stack_limit,\n\tload_split_stack_limit_di, load_split_stack_limit_si,\n\tsplit_stack_return, split_stack_space_check): New expands and insns.\n\t* gcc/config/rs6000/rs6000-protos.h\n\t(rs6000_expand_split_stack_prologue): Declare.\n\t(rs6000_split_stack_space_check): Declare.\nlibgcc/\n\t* config/rs6000/morestack.S: New.\n\t* config/rs6000/t-stack-rs6000: New.\n\t* config.host (powerpc*-*-linux*): Add t-stack and t-stack-rs6000\n\tto tmake_file.\n\t* generic-morestack.c: Don't build for powerpc 32-bit.\n\nFrom-SVN: r223426", "tree": {"sha": "25d754bde890f2750c3489f49713ea0123e09339", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25d754bde890f2750c3489f49713ea0123e09339"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a03f86937467dcfe401b4f369307faf2593e97a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a03f86937467dcfe401b4f369307faf2593e97a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a03f86937467dcfe401b4f369307faf2593e97a"}], "stats": {"total": 756, "additions": 754, "deletions": 2}, "files": [{"sha": "471291ceebf414e3a91310425b07135402cfff7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2", "patch": "@@ -1,3 +1,30 @@\n+2015-05-20  Alan Modra  <amodra@gmail.com>\n+\n+\t* common/config/rs6000/rs6000-common.c (TARGET_SUPPORTS_SPLIT_STACK):\n+\tDefine.\n+\t(rs6000_supports_split_stack): New function.\n+\t* gcc/config/rs6000/rs6000.c (machine_function): Add\n+\tsplit_stack_arg_pointer.\n+\t(TARGET_EXTRA_LIVE_ON_ENTRY, TARGET_INTERNAL_ARG_POINTER): Define.\n+\t(setup_incoming_varargs): Use crtl->args.internal_arg_pointer\n+\trather than virtual_incoming_args_rtx.\n+\t(rs6000_va_start): Likewise.\n+\t(split_stack_arg_pointer_used_p): New function.\n+\t(rs6000_emit_prologue): Set up arg pointer for -fsplit-stack.\n+\t(morestack_ref): New var.\n+\t(gen_add3_const, rs6000_expand_split_stack_prologue,\n+\trs6000_internal_arg_pointer, rs6000_live_on_entry,\n+\trs6000_split_stack_space_check): New functions.\n+\t(rs6000_elf_file_end): Call file_end_indicate_split_stack.\n+\t* gcc/config/rs6000/rs6000.md (UNSPEC_STACK_CHECK): Define.\n+\t(UNSPECV_SPLIT_STACK_RETURN): Define.\n+\t(split_stack_prologue, load_split_stack_limit,\n+\tload_split_stack_limit_di, load_split_stack_limit_si,\n+\tsplit_stack_return, split_stack_space_check): New expands and insns.\n+\t* gcc/config/rs6000/rs6000-protos.h\n+\t(rs6000_expand_split_stack_prologue): Declare.\n+\t(rs6000_split_stack_space_check): Declare.\n+\n 2015-05-20  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.c (struct rs6000_stack): Correct comments."}, {"sha": "891bc554dcfe023fb578dc40e7b3479664357c74", "filename": "gcc/common/config/rs6000/rs6000-common.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/gcc%2Fcommon%2Fconfig%2Frs6000%2Frs6000-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/gcc%2Fcommon%2Fconfig%2Frs6000%2Frs6000-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Frs6000%2Frs6000-common.c?ref=0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2", "patch": "@@ -288,6 +288,31 @@ rs6000_handle_option (struct gcc_options *opts, struct gcc_options *opts_set,\n   return true;\n }\n \n+/* -fsplit-stack uses a field in the TCB, available with glibc-2.19.\n+   We also allow 2.18 because alignment padding guarantees that the\n+   space is available there too.  */\n+\n+static bool\n+rs6000_supports_split_stack (bool report,\n+\t\t\t     struct gcc_options *opts ATTRIBUTE_UNUSED)\n+{\n+#ifndef TARGET_GLIBC_MAJOR\n+#define TARGET_GLIBC_MAJOR 0\n+#endif\n+#ifndef TARGET_GLIBC_MINOR\n+#define TARGET_GLIBC_MINOR 0\n+#endif\n+  /* Note: Can't test DEFAULT_ABI here, it isn't set until later.  */\n+  if (TARGET_GLIBC_MAJOR * 1000 + TARGET_GLIBC_MINOR >= 2018\n+      && TARGET_64BIT\n+      && TARGET_ELF)\n+    return true;\n+\n+  if (report)\n+    error (\"%<-fsplit-stack%> currently only supported on PowerPC64 GNU/Linux with glibc-2.18 or later\");\n+  return false;\n+}\n+\n #undef TARGET_HANDLE_OPTION\n #define TARGET_HANDLE_OPTION rs6000_handle_option\n \n@@ -300,4 +325,7 @@ rs6000_handle_option (struct gcc_options *opts, struct gcc_options *opts_set,\n #undef TARGET_OPTION_OPTIMIZATION_TABLE\n #define TARGET_OPTION_OPTIMIZATION_TABLE rs6000_option_optimization_table\n \n+#undef TARGET_SUPPORTS_SPLIT_STACK\n+#define TARGET_SUPPORTS_SPLIT_STACK rs6000_supports_split_stack\n+\n struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "bd1ede18cdb0d8926f6d3ecb1780a80f1451070c", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2", "patch": "@@ -191,6 +191,8 @@ extern void rs6000_emit_prologue (void);\n extern void rs6000_emit_load_toc_table (int);\n extern unsigned int rs6000_dbx_register_number (unsigned int, unsigned int);\n extern void rs6000_emit_epilogue (int);\n+extern void rs6000_expand_split_stack_prologue (void);\n+extern void rs6000_split_stack_space_check (rtx, rtx);\n extern void rs6000_emit_eh_reg_restore (rtx, rtx);\n extern const char * output_isel (rtx *);\n extern void rs6000_call_aix (rtx, rtx, rtx, rtx);"}, {"sha": "8947849a73e4061f195c3919a5c029413f42e0bb", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 262, "deletions": 2, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2", "patch": "@@ -187,6 +187,8 @@ typedef struct GTY(()) machine_function\n      64-bits wide and is allocated early enough so that the offset\n      does not overflow the 16-bit load/store offset field.  */\n   rtx sdmode_stack_slot;\n+  /* Alternative internal arg pointer for -fsplit-stack.  */\n+  rtx split_stack_arg_pointer;\n   /* Flag if r2 setup is needed with ELFv2 ABI.  */\n   bool r2_setup_needed;\n } machine_function;\n@@ -1190,6 +1192,7 @@ static bool rs6000_debug_cannot_change_mode_class (machine_mode,\n \t\t\t\t\t\t   machine_mode,\n \t\t\t\t\t\t   enum reg_class);\n static bool rs6000_save_toc_in_prologue_p (void);\n+static rtx rs6000_internal_arg_pointer (void);\n \n rtx (*rs6000_legitimize_reload_address_ptr) (rtx, machine_mode, int, int,\n \t\t\t\t\t     int, int *)\n@@ -1411,6 +1414,12 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_SET_UP_BY_PROLOGUE\n #define TARGET_SET_UP_BY_PROLOGUE rs6000_set_up_by_prologue\n \n+#undef TARGET_EXTRA_LIVE_ON_ENTRY\n+#define TARGET_EXTRA_LIVE_ON_ENTRY rs6000_live_on_entry\n+\n+#undef TARGET_INTERNAL_ARG_POINTER\n+#define TARGET_INTERNAL_ARG_POINTER rs6000_internal_arg_pointer\n+\n #undef TARGET_HAVE_TLS\n #define TARGET_HAVE_TLS HAVE_AS_TLS\n \n@@ -11150,7 +11159,7 @@ setup_incoming_varargs (cumulative_args_t cum, machine_mode mode,\n   else\n     {\n       first_reg_offset = next_cum.words;\n-      save_area = virtual_incoming_args_rtx;\n+      save_area = crtl->args.internal_arg_pointer;\n \n       if (targetm.calls.must_pass_in_stack (mode, type))\n \tfirst_reg_offset += rs6000_arg_size (TYPE_MODE (type), type);\n@@ -11344,7 +11353,7 @@ rs6000_va_start (tree valist, rtx nextarg)\n     }\n \n   /* Find the overflow area.  */\n-  t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n+  t = make_tree (TREE_TYPE (ovf), crtl->args.internal_arg_pointer);\n   if (words != 0)\n     t = fold_build_pointer_plus_hwi (t, words * MIN_UNITS_PER_WORD);\n   t = build2 (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n@@ -23424,6 +23433,48 @@ rs6000_reg_live_or_pic_offset_p (int reg)\n                   || (DEFAULT_ABI == ABI_DARWIN && flag_pic))));\n }\n \n+/* Return whether the split-stack arg pointer (r12) is used.  */\n+\n+static bool\n+split_stack_arg_pointer_used_p (void)\n+{\n+  /* If the pseudo holding the arg pointer is no longer a pseudo,\n+     then the arg pointer is used.  */\n+  if (cfun->machine->split_stack_arg_pointer != NULL_RTX\n+      && (!REG_P (cfun->machine->split_stack_arg_pointer)\n+\t  || (REGNO (cfun->machine->split_stack_arg_pointer)\n+\t      < FIRST_PSEUDO_REGISTER)))\n+    return true;\n+\n+  /* Unfortunately we also need to do some code scanning, since\n+     r12 may have been substituted for the pseudo.  */\n+  rtx_insn *insn;\n+  basic_block bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+  FOR_BB_INSNS (bb, insn)\n+    if (NONDEBUG_INSN_P (insn))\n+      {\n+\t/* A call destroys r12.  */\n+\tif (CALL_P (insn))\n+\t  return false;\n+\n+\tdf_ref use;\n+\tFOR_EACH_INSN_USE (use, insn)\n+\t  {\n+\t    rtx x = DF_REF_REG (use);\n+\t    if (REG_P (x) && REGNO (x) == 12)\n+\t      return true;\n+\t  }\n+\tdf_ref def;\n+\tFOR_EACH_INSN_DEF (def, insn)\n+\t  {\n+\t    rtx x = DF_REF_REG (def);\n+\t    if (REG_P (x) && REGNO (x) == 12)\n+\t      return false;\n+\t  }\n+      }\n+  return bitmap_bit_p (DF_LR_OUT (bb), 12);\n+}\n+\n /* Emit function prologue as insns.  */\n \n void\n@@ -24375,6 +24426,40 @@ rs6000_emit_prologue (void)\n       rtx reg = gen_rtx_REG (reg_mode, TOC_REGNUM);\n       emit_insn (gen_frame_store (reg, sp_reg_rtx, RS6000_TOC_SAVE_SLOT));\n     }\n+\n+  if (flag_split_stack && split_stack_arg_pointer_used_p ())\n+    {\n+      /* Set up the arg pointer (r12) for -fsplit-stack code.  If\n+\t __morestack was called, it left the arg pointer to the old\n+\t stack in r29.  Otherwise, the arg pointer is the top of the\n+\t current frame.  */\n+      if (frame_off != 0 || REGNO (frame_reg_rtx) != 12)\n+\t{\n+\t  rtx r12 = gen_rtx_REG (Pmode, 12);\n+\t  if (frame_off == 0)\n+\t    emit_move_insn (r12, frame_reg_rtx);\n+\t  else\n+\t    emit_insn (gen_add3_insn (r12, frame_reg_rtx, GEN_INT (frame_off)));\n+\t}\n+      if (info->push_p)\n+\t{\n+\t  rtx r12 = gen_rtx_REG (Pmode, 12);\n+\t  rtx r29 = gen_rtx_REG (Pmode, 29);\n+\t  rtx cr7 = gen_rtx_REG (CCUNSmode, CR7_REGNO);\n+\t  rtx not_more = gen_label_rtx ();\n+\t  rtx jump;\n+\n+\t  jump = gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t\t       gen_rtx_GEU (VOIDmode, cr7, const0_rtx),\n+\t\t\t\t       gen_rtx_LABEL_REF (VOIDmode, not_more),\n+\t\t\t\t       pc_rtx);\n+\t  jump = emit_jump_insn (gen_rtx_SET (pc_rtx, jump));\n+\t  JUMP_LABEL (jump) = not_more;\n+\t  LABEL_NUSES (not_more) += 1;\n+\t  emit_move_insn (r12, r29);\n+\t  emit_label (not_more);\n+\t}\n+    }\n }\n \n /* Output .extern statements for the save/restore routines we use.  */\n@@ -25802,6 +25887,178 @@ rs6000_output_function_epilogue (FILE *file,\n       fputs (\"\\t.align 2\\n\", file);\n     }\n }\n+\n+/* -fsplit-stack support.  */\n+\n+/* A SYMBOL_REF for __morestack.  */\n+static GTY(()) rtx morestack_ref;\n+\n+static rtx\n+gen_add3_const (rtx rt, rtx ra, long c)\n+{\n+  if (TARGET_64BIT)\n+    return gen_adddi3 (rt, ra, GEN_INT (c));\n+ else\n+    return gen_addsi3 (rt, ra, GEN_INT (c));\n+}\n+\n+/* Emit -fsplit-stack prologue, which goes before the regular function\n+   prologue (at local entry point in the case of ELFv2).  */\n+\n+void\n+rs6000_expand_split_stack_prologue (void)\n+{\n+  rs6000_stack_t *info = rs6000_stack_info ();\n+  unsigned HOST_WIDE_INT allocate;\n+  long alloc_hi, alloc_lo;\n+  rtx r0, r1, r12, lr, ok_label, compare, jump, call_fusage;\n+  rtx_insn *insn;\n+\n+  gcc_assert (flag_split_stack && reload_completed);\n+\n+  if (!info->push_p)\n+    return;\n+\n+  allocate = info->total_size;\n+  if (allocate > (unsigned HOST_WIDE_INT) 1 << 31)\n+    {\n+      sorry (\"Stack frame larger than 2G is not supported for -fsplit-stack\");\n+      return;\n+    }\n+  if (morestack_ref == NULL_RTX)\n+    {\n+      morestack_ref = gen_rtx_SYMBOL_REF (Pmode, \"__morestack\");\n+      SYMBOL_REF_FLAGS (morestack_ref) |= (SYMBOL_FLAG_LOCAL\n+\t\t\t\t\t   | SYMBOL_FLAG_FUNCTION);\n+    }\n+\n+  r0 = gen_rtx_REG (Pmode, 0);\n+  r1 = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n+  r12 = gen_rtx_REG (Pmode, 12);\n+  emit_insn (gen_load_split_stack_limit (r0));\n+  /* Always emit two insns here to calculate the requested stack,\n+     so that the linker can edit them when adjusting size for calling\n+     non-split-stack code.  */\n+  alloc_hi = (-allocate + 0x8000) & ~0xffffL;\n+  alloc_lo = -allocate - alloc_hi;\n+  if (alloc_hi != 0)\n+    {\n+      emit_insn (gen_add3_const (r12, r1, alloc_hi));\n+      if (alloc_lo != 0)\n+\temit_insn (gen_add3_const (r12, r12, alloc_lo));\n+      else\n+\temit_insn (gen_nop ());\n+    }\n+  else\n+    {\n+      emit_insn (gen_add3_const (r12, r1, alloc_lo));\n+      emit_insn (gen_nop ());\n+    }\n+\n+  compare = gen_rtx_REG (CCUNSmode, CR7_REGNO);\n+  emit_insn (gen_rtx_SET (compare, gen_rtx_COMPARE (CCUNSmode, r12, r0)));\n+  ok_label = gen_label_rtx ();\n+  jump = gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t       gen_rtx_GEU (VOIDmode, compare, const0_rtx),\n+\t\t\t       gen_rtx_LABEL_REF (VOIDmode, ok_label),\n+\t\t\t       pc_rtx);\n+  jump = emit_jump_insn (gen_rtx_SET (pc_rtx, jump));\n+  JUMP_LABEL (jump) = ok_label;\n+  /* Mark the jump as very likely to be taken.  */\n+  add_int_reg_note (jump, REG_BR_PROB,\n+\t\t    REG_BR_PROB_BASE - REG_BR_PROB_BASE / 100);\n+\n+  lr = gen_rtx_REG (Pmode, LR_REGNO);\n+  insn = emit_move_insn (r0, lr);\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+  insn = emit_insn (gen_frame_store (r0, r1, info->lr_save_offset));\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+\n+  insn = emit_call_insn (gen_call (gen_rtx_MEM (SImode, morestack_ref),\n+\t\t\t\t   const0_rtx, const0_rtx));\n+  call_fusage = NULL_RTX;\n+  use_reg (&call_fusage, r12);\n+  add_function_usage_to (insn, call_fusage);\n+  emit_insn (gen_frame_load (r0, r1, info->lr_save_offset));\n+  insn = emit_move_insn (lr, r0);\n+  add_reg_note (insn, REG_CFA_RESTORE, lr);\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+  emit_insn (gen_split_stack_return ());\n+\n+  emit_label (ok_label);\n+  LABEL_NUSES (ok_label) = 1;\n+}\n+\n+/* Return the internal arg pointer used for function incoming\n+   arguments.  When -fsplit-stack, the arg pointer is r12 so we need\n+   to copy it to a pseudo in order for it to be preserved over calls\n+   and suchlike.  We'd really like to use a pseudo here for the\n+   internal arg pointer but data-flow analysis is not prepared to\n+   accept pseudos as live at the beginning of a function.  */\n+\n+static rtx\n+rs6000_internal_arg_pointer (void)\n+{\n+  if (flag_split_stack)\n+    {\n+      if (cfun->machine->split_stack_arg_pointer == NULL_RTX)\n+\t{\n+\t  rtx pat;\n+\n+\t  cfun->machine->split_stack_arg_pointer = gen_reg_rtx (Pmode);\n+\t  REG_POINTER (cfun->machine->split_stack_arg_pointer) = 1;\n+\n+\t  /* Put the pseudo initialization right after the note at the\n+\t     beginning of the function.  */\n+\t  pat = gen_rtx_SET (cfun->machine->split_stack_arg_pointer,\n+\t\t\t     gen_rtx_REG (Pmode, 12));\n+\t  push_topmost_sequence ();\n+\t  emit_insn_after (pat, get_insns ());\n+\t  pop_topmost_sequence ();\n+\t}\n+      return plus_constant (Pmode, cfun->machine->split_stack_arg_pointer,\n+\t\t\t    FIRST_PARM_OFFSET (current_function_decl));\n+    }\n+  return virtual_incoming_args_rtx;\n+}\n+\n+/* We may have to tell the dataflow pass that the split stack prologue\n+   is initializing a register.  */\n+\n+static void\n+rs6000_live_on_entry (bitmap regs)\n+{\n+  if (flag_split_stack)\n+    bitmap_set_bit (regs, 12);\n+}\n+\n+/* Emit -fsplit-stack dynamic stack allocation space check.  */\n+\n+void\n+rs6000_split_stack_space_check (rtx size, rtx label)\n+{\n+  rtx sp = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n+  rtx limit = gen_reg_rtx (Pmode);\n+  rtx requested = gen_reg_rtx (Pmode);\n+  rtx cmp = gen_reg_rtx (CCUNSmode);\n+  rtx jump;\n+\n+  emit_insn (gen_load_split_stack_limit (limit));\n+  if (CONST_INT_P (size))\n+    emit_insn (gen_add3_insn (requested, sp, GEN_INT (-INTVAL (size))));\n+  else\n+    {\n+      size = force_reg (Pmode, size);\n+      emit_move_insn (requested, gen_rtx_MINUS (Pmode, sp, size));\n+    }\n+  emit_insn (gen_rtx_SET (cmp, gen_rtx_COMPARE (CCUNSmode, requested, limit)));\n+  jump = gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t       gen_rtx_GEU (VOIDmode, cmp, const0_rtx),\n+\t\t\t       gen_rtx_LABEL_REF (VOIDmode, label),\n+\t\t\t       pc_rtx);\n+  jump = emit_jump_insn (gen_rtx_SET (pc_rtx, jump));\n+  JUMP_LABEL (jump) = label;\n+}\n \f\n /* A C compound statement that outputs the assembler code for a thunk\n    function, used to implement C++ virtual function calls with\n@@ -29810,6 +30067,9 @@ rs6000_elf_file_end (void)\n   if (TARGET_32BIT || DEFAULT_ABI == ABI_ELFv2)\n     file_end_indicate_exec_stack ();\n #endif\n+\n+  if (flag_split_stack)\n+    file_end_indicate_split_stack ();\n }\n #endif\n "}, {"sha": "5d3e04be819077506a0d450496e711a6c0bf706f", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2", "patch": "@@ -140,6 +140,7 @@\n    UNSPEC_PACK_128BIT\n    UNSPEC_LSQ\n    UNSPEC_FUSION_GPR\n+   UNSPEC_STACK_CHECK\n   ])\n \n ;;\n@@ -157,6 +158,7 @@\n    UNSPECV_NLGR\t\t\t; non-local goto receiver\n    UNSPECV_MFFS\t\t\t; Move from FPSCR\n    UNSPECV_MTFSF\t\t; Move to FPSCR Fields\n+   UNSPECV_SPLIT_STACK_RETURN   ; A camouflaged return\n   ])\n \n \f\n@@ -12345,6 +12347,72 @@\n }\"\n   [(set_attr \"type\" \"load\")])\n \f\n+;; Handle -fsplit-stack.\n+\n+(define_expand \"split_stack_prologue\"\n+  [(const_int 0)]\n+  \"\"\n+{\n+  rs6000_expand_split_stack_prologue ();\n+  DONE;\n+})\n+\n+(define_expand \"load_split_stack_limit\"\n+  [(set (match_operand 0)\n+\t(unspec [(const_int 0)] UNSPEC_STACK_CHECK))]\n+  \"\"\n+{\n+  emit_insn (gen_rtx_SET (operands[0],\n+\t\t\t  gen_rtx_UNSPEC (Pmode,\n+\t\t\t\t\t  gen_rtvec (1, const0_rtx),\n+\t\t\t\t\t  UNSPEC_STACK_CHECK)));\n+  DONE;\n+})\n+\n+(define_insn \"load_split_stack_limit_di\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(unspec:DI [(const_int 0)] UNSPEC_STACK_CHECK))]\n+  \"TARGET_64BIT\"\n+  \"ld %0,-0x7040(13)\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"update\" \"no\")\n+   (set_attr \"indexed\" \"no\")])\n+\n+(define_insn \"load_split_stack_limit_si\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(unspec:SI [(const_int 0)] UNSPEC_STACK_CHECK))]\n+  \"!TARGET_64BIT\"\n+  \"lwz %0,-0x7020(2)\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"update\" \"no\")\n+   (set_attr \"indexed\" \"no\")])\n+\n+;; A return instruction which the middle-end doesn't see.\n+(define_insn \"split_stack_return\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_SPLIT_STACK_RETURN)]\n+  \"\"\n+  \"blr\"\n+  [(set_attr \"type\" \"jmpreg\")])\n+\n+;; If there are operand 0 bytes available on the stack, jump to\n+;; operand 1.\n+(define_expand \"split_stack_space_check\"\n+  [(set (match_dup 2)\n+\t(unspec [(const_int 0)] UNSPEC_STACK_CHECK))\n+   (set (match_dup 3)\n+\t(minus (reg STACK_POINTER_REGNUM)\n+\t       (match_operand 0)))\n+   (set (match_dup 4) (compare:CCUNS (match_dup 3) (match_dup 2)))\n+   (set (pc) (if_then_else\n+\t      (geu (match_dup 4) (const_int 0))\n+\t      (label_ref (match_operand 1))\n+\t      (pc)))]\n+  \"\"\n+{\n+  rs6000_split_stack_space_check (operands[0], operands[1]);\n+  DONE;\n+})\n+\f\n (define_insn \"bpermd_<mode>\"\n   [(set (match_operand:P 0 \"gpc_reg_operand\" \"=r\")\n \t(unspec:P [(match_operand:P 1 \"gpc_reg_operand\" \"r\")"}, {"sha": "c4e716e996d4ed875d4261dcaefe630cdf66636f", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2", "patch": "@@ -1,3 +1,11 @@\n+2015-05-20  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/morestack.S: New.\n+\t* config/rs6000/t-stack-rs6000: New.\n+\t* config.host (powerpc*-*-linux*): Add t-stack and t-stack-rs6000\n+\tto tmake_file.\n+\t* generic-morestack.c: Don't build for powerpc 32-bit.\n+\n 2015-05-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* Makefile.in (LIBUNWIND): Move dependency for shared libgcc."}, {"sha": "8d826806d2ab3379ea1ac9d01a3091334b45f210", "filename": "libgcc/config.host", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2", "patch": "@@ -1027,6 +1027,7 @@ powerpc-*-rtems*)\n \t;;\n powerpc*-*-linux*)\n \ttmake_file=\"${tmake_file} rs6000/t-ppccomm rs6000/t-savresfgpr rs6000/t-crtstuff rs6000/t-linux t-dfprules rs6000/t-ppc64-fp t-slibgcc-libgcc\"\n+\ttmake_file=\"${tmake_file} t-stack rs6000/t-stack-rs6000\"\n \tcase $ppc_fp_type in\n \t64)\n \t\t;;"}, {"sha": "ecd1bf45c1751c4e579d79211080cc4e740ed19f", "filename": "libgcc/config/rs6000/morestack.S", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/libgcc%2Fconfig%2Frs6000%2Fmorestack.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/libgcc%2Fconfig%2Frs6000%2Fmorestack.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Fmorestack.S?ref=0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2", "patch": "@@ -0,0 +1,351 @@\n+#ifdef __powerpc64__\n+# PowerPC64 support for -fsplit-stack.\n+# Copyright (C) 2009-2015 Free Software Foundation, Inc.\n+# Contributed by Alan Modra <amodra@gmail.com>.\n+\n+# This file is part of GCC.\n+\n+# GCC is free software; you can redistribute it and/or modify it under\n+# the terms of the GNU General Public License as published by the Free\n+# Software Foundation; either version 3, or (at your option) any later\n+# version.\n+\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+#if _CALL_ELF == 2\n+\t.abiversion 2\n+#define PARAMS 32\n+#else\n+\t.abiversion 1\n+#define PARAMS 48\n+#endif\n+#define MORESTACK_FRAMESIZE\t(PARAMS+96)\n+#define PARAMREG_SAVE\t\t-MORESTACK_FRAMESIZE+PARAMS+0\n+#define STATIC_CHAIN_SAVE\t-MORESTACK_FRAMESIZE+PARAMS+64\n+#define R29_SAVE\t\t-MORESTACK_FRAMESIZE+PARAMS+72\n+#define LINKREG_SAVE\t\t-MORESTACK_FRAMESIZE+PARAMS+80\n+#define NEWSTACKSIZE_SAVE\t-MORESTACK_FRAMESIZE+PARAMS+88\n+\n+# Excess space needed to call ld.so resolver for lazy plt\n+# resolution.  Go uses sigaltstack so this doesn't need to\n+# also cover signal frame size.\n+#define BACKOFF 4096\n+# Large excess allocated when calling non-split-stack code.\n+#define NON_SPLIT_STACK 0x100000\n+\n+\n+#if _CALL_ELF == 2\n+\n+#define BODY_LABEL(name) name\n+\n+#define ENTRY0(name)\t\t\t\t\t\\\n+\t.global name;\t\t\t\t\t\\\n+\t.hidden\tname;\t\t\t\t\t\\\n+\t.type name,@function;\t\t\t\t\\\n+name##:\n+\n+#define ENTRY(name)\t\t\t\t\t\\\n+\tENTRY0(name);\t\t\t\t\t\\\n+0:\taddis %r2,%r12,.TOC.-0b@ha;\t\t\t\\\n+        addi %r2,%r2,.TOC.-0b@l;\t\t\t\\\n+\t.localentry name, .-name\n+\n+#else\n+\n+#define BODY_LABEL(name) .L.##name\n+\n+#define ENTRY0(name)\t\t\t\t\t\\\n+\t.global name;\t\t\t\t\t\\\n+\t.hidden\tname;\t\t\t\t\t\\\n+\t.type name,@function;\t\t\t\t\\\n+\t.pushsection \".opd\",\"aw\";\t\t\t\\\n+\t.p2align 3;\t\t\t\t\t\\\n+name##: .quad BODY_LABEL (name), .TOC.@tocbase, 0;\t\\\n+\t.popsection;\t\t\t\t\t\\\n+BODY_LABEL(name)##:\n+\n+#define ENTRY(name) ENTRY0(name)\n+\n+#endif\n+\n+#define SIZE(name) .size name, .-BODY_LABEL(name)\n+\n+\n+\t.text\n+# Just like __morestack, but with larger excess allocation\n+ENTRY0(__morestack_non_split)\n+.LFB1:\n+\t.cfi_startproc\n+# We use a cleanup to restore the tcbhead_t.__private_ss if\n+# an exception is thrown through this code.\n+#ifdef __PIC__\n+\t.cfi_personality 0x9b,DW.ref.__gcc_personality_v0\n+\t.cfi_lsda 0x1b,.LLSDA1\n+#else\n+\t.cfi_personality 0x3,__gcc_personality_v0\n+\t.cfi_lsda 0x3,.LLSDA1\n+#endif\n+# LR is already saved by the split-stack prologue code.\n+# We may as well have the unwinder skip over the call in the\n+# prologue too.\n+\t.cfi_offset %lr,16\n+\n+\taddis %r12,%r12,-NON_SPLIT_STACK@h\n+\tSIZE (__morestack_non_split)\n+# Fall through into __morestack\n+\n+\n+# This function is called with non-standard calling conventions.\n+# On entry, r12 is the requested stack pointer.  One version of the\n+# split-stack prologue that calls __morestack looks like\n+#\tld %r0,-0x7000-64(%r13)\n+#\taddis %r12,%r1,-allocate@ha\n+#\taddi %r12,%r12,-allocate@l\n+#\tcmpld %r12,%r0\n+#\tbge+ enough\n+#\tmflr %r0\n+#\tstd %r0,16(%r1)\n+#\tbl __morestack\n+#\tld %r0,16(%r1)\n+#\tmtlr %r0\n+#\tblr\n+# enough:\n+# The normal function prologue follows here, with a small addition at\n+# the end to set up the arg pointer.  The arg pointer is set up with:\n+#\taddi %r12,%r1,offset\n+#\tbge %cr7,.+8\n+#\tmr %r12,%r29\n+#\n+# Note that the lr save slot 16(%r1) has already been used.\n+# r3 thru r11 possibly contain arguments and a static chain\n+# pointer for the function we're calling, so must be preserved.\n+# cr7 must also be preserved.\n+\n+ENTRY0(__morestack)\n+# Save parameter passing registers, our arguments, lr, r29\n+# and use r29 as a frame pointer.\n+\tstd %r3,PARAMREG_SAVE+0(%r1)\n+\tsub %r3,%r1,%r12\t\t# calculate requested stack size\n+\tmflr %r12\n+\tstd %r4,PARAMREG_SAVE+8(%r1)\n+\tstd %r5,PARAMREG_SAVE+16(%r1)\n+\tstd %r6,PARAMREG_SAVE+24(%r1)\n+\tstd %r7,PARAMREG_SAVE+32(%r1)\n+\taddi %r3,%r3,BACKOFF\n+\tstd %r8,PARAMREG_SAVE+40(%r1)\n+\tstd %r9,PARAMREG_SAVE+48(%r1)\n+\tstd %r10,PARAMREG_SAVE+56(%r1)\n+\tstd %r11,STATIC_CHAIN_SAVE(%r1)\n+\tstd %r29,R29_SAVE(%r1)\n+\tstd %r12,LINKREG_SAVE(%r1)\n+\tstd %r3,NEWSTACKSIZE_SAVE(%r1)\t# new stack size\n+\tmr %r29,%r1\n+\t.cfi_offset %r29,R29_SAVE\n+\t.cfi_def_cfa_register %r29\n+\tstdu %r1,-MORESTACK_FRAMESIZE(%r1)\n+\n+\t# void __morestack_block_signals (void)\n+\tbl __morestack_block_signals\n+\n+\t# void *__generic_morestack (size_t *pframe_size,\n+\t#\t\t\t     void *old_stack,\n+\t#\t\t\t     size_t param_size)\n+\taddi %r3,%r29,NEWSTACKSIZE_SAVE\n+\tmr %r4,%r29\n+\tli %r5,0\t\t\t# no copying from old stack\n+\tbl __generic_morestack\n+\n+# Start using new stack\n+\tstdu %r29,-32(%r3)\t\t# back-chain\n+\tmr %r1,%r3\n+\n+# Set __private_ss stack guard for the new stack.\n+\tld %r12,NEWSTACKSIZE_SAVE(%r29)\t# modified size\n+\taddi %r3,%r3,BACKOFF-32\n+\tsub %r3,%r3,%r12\n+# Note that a signal frame has $pc pointing at the instruction\n+# where the signal occurred.  For something like a timer\n+# interrupt this means the instruction has already executed,\n+# thus the region starts at the instruction modifying\n+# __private_ss, not one instruction after.\n+.LEHB0:\n+\tstd %r3,-0x7000-64(%r13)\t# tcbhead_t.__private_ss\n+\n+\t# void __morestack_unblock_signals (void)\n+\tbl __morestack_unblock_signals\n+\n+# Set up for a call to the target function, located 3\n+# instructions after __morestack's return address.\n+#\n+\tld %r12,LINKREG_SAVE(%r29)\n+\tld %r3,PARAMREG_SAVE+0(%r29)\t# restore arg regs\n+\tld %r4,PARAMREG_SAVE+8(%r29)\n+\tld %r5,PARAMREG_SAVE+16(%r29)\n+\tld %r6,PARAMREG_SAVE+24(%r29)\n+\tld %r7,PARAMREG_SAVE+32(%r29)\n+\tld %r8,PARAMREG_SAVE+40(%r29)\n+\tld %r9,PARAMREG_SAVE+48(%r29)\n+\taddi %r0,%r12,12\t\t# add 3 instructions\n+\tld %r10,PARAMREG_SAVE+56(%r29)\n+\tld %r11,STATIC_CHAIN_SAVE(%r29)\n+\tcmpld %cr7,%r12,%r0\t\t# indicate we were called\n+\tmtctr %r0\n+\tbctrl\t\t\t\t# call caller!\n+\n+# On return, save regs possibly used to return a value, and\n+# possibly trashed by calls to __morestack_block_signals,\n+# __generic_releasestack and __morestack_unblock_signals.\n+# Assume those calls don't use vector or floating point regs.\n+\tstd %r3,PARAMREG_SAVE+0(%r29)\n+\tstd %r4,PARAMREG_SAVE+8(%r29)\n+\tstd %r5,PARAMREG_SAVE+16(%r29)\n+\tstd %r6,PARAMREG_SAVE+24(%r29)\n+#if _CALL_ELF == 2\n+\tstd %r7,PARAMREG_SAVE+32(%r29)\n+\tstd %r8,PARAMREG_SAVE+40(%r29)\n+\tstd %r9,PARAMREG_SAVE+48(%r29)\n+\tstd %r10,PARAMREG_SAVE+56(%r29)\n+#endif\n+\n+\tbl __morestack_block_signals\n+\n+\t# void *__generic_releasestack (size_t *pavailable)\n+\taddi %r3,%r29,NEWSTACKSIZE_SAVE\n+\tbl __generic_releasestack\n+\n+# Reset __private_ss stack guard to value for old stack\n+\tld %r12,NEWSTACKSIZE_SAVE(%r29)\n+\taddi %r3,%r3,BACKOFF\n+\tsub %r3,%r3,%r12\n+.LEHE0:\n+\tstd %r3,-0x7000-64(%r13)\t# tcbhead_t.__private_ss\n+\n+\tbl __morestack_unblock_signals\n+\n+# Use old stack again.\n+\tmr %r1,%r29\n+\n+# Restore return value regs, and return.\n+\tld %r0,LINKREG_SAVE(%r29)\n+\tmtlr %r0\n+\tld %r3,PARAMREG_SAVE+0(%r29)\n+\tld %r4,PARAMREG_SAVE+8(%r29)\n+\tld %r5,PARAMREG_SAVE+16(%r29)\n+\tld %r6,PARAMREG_SAVE+24(%r29)\n+#if _CALL_ELF == 2\n+\tld %r7,PARAMREG_SAVE+32(%r29)\n+\tld %r8,PARAMREG_SAVE+40(%r29)\n+\tld %r9,PARAMREG_SAVE+48(%r29)\n+\tld %r10,PARAMREG_SAVE+56(%r29)\n+#endif\n+\tld %r29,R29_SAVE(%r29)\n+\t.cfi_def_cfa_register %r1\n+\tblr\n+\n+# This is the cleanup code called by the stack unwinder when\n+# unwinding through code between .LEHB0 and .LEHE0 above.\n+cleanup:\n+\t.cfi_def_cfa_register %r29\n+\tstd %r3,PARAMREG_SAVE(%r29)\t# Save exception header\n+\t# size_t __generic_findstack (void *stack)\n+\tmr %r3,%r29\n+\tbl __generic_findstack\n+\tsub %r3,%r29,%r3\n+\taddi %r3,%r3,BACKOFF\n+\tstd %r3,-0x7000-64(%r13)\t# tcbhead_t.__private_ss\n+\tld %r3,PARAMREG_SAVE(%r29)\n+\tbl _Unwind_Resume\n+\tnop\n+\t.cfi_endproc\n+\tSIZE (__morestack)\n+\n+\n+\t.section .gcc_except_table,\"a\",@progbits\n+\t.p2align 2\n+.LLSDA1:\n+\t.byte\t0xff\t# @LPStart format (omit)\n+\t.byte\t0xff\t# @TType format (omit)\n+\t.byte\t0x1\t# call-site format (uleb128)\n+\t.uleb128 .LLSDACSE1-.LLSDACSB1\t# Call-site table length\n+.LLSDACSB1:\n+\t.uleb128 .LEHB0-.LFB1\t# region 0 start\n+\t.uleb128 .LEHE0-.LEHB0\t# length\n+\t.uleb128 cleanup-.LFB1\t# landing pad\n+\t.uleb128 0\t\t# no action, ie. a cleanup\n+.LLSDACSE1:\n+\n+\n+#ifdef __PIC__\n+# Build a position independent reference to the personality function.\n+\t.hidden DW.ref.__gcc_personality_v0\n+\t.weak DW.ref.__gcc_personality_v0\n+\t.section .data.DW.ref.__gcc_personality_v0,\"awG\",@progbits,DW.ref.__gcc_personality_v0,comdat\n+\t.p2align 3\n+DW.ref.__gcc_personality_v0:\n+\t.quad __gcc_personality_v0\n+\t.type DW.ref.__gcc_personality_v0, @object\n+\t.size DW.ref.__gcc_personality_v0, 8\n+#endif\n+\n+\n+\t.text\n+# Initialize the stack guard when the program starts or when a\n+# new thread starts.  This is called from a constructor.\n+# void __stack_split_initialize (void)\n+ENTRY(__stack_split_initialize)\n+\taddi %r3,%r1,-0x4000\t\t# We should have at least 16K.\n+\tstd %r3,-0x7000-64(%r13)\t# tcbhead_t.__private_ss\n+\t# void __generic_morestack_set_initial_sp (void *sp, size_t len)\n+\tmr %r3,%r1\n+\tli %r4, 0x4000\n+\tb __generic_morestack_set_initial_sp\n+\tSIZE (__stack_split_initialize)\n+\n+\n+# Return current __private_ss\n+# void *__morestack_get_guard (void)\n+ENTRY0(__morestack_get_guard)\n+\tld %r3,-0x7000-64(%r13)\t\t# tcbhead_t.__private_ss\n+\tblr\n+\tSIZE (__morestack_get_guard)\n+\n+\n+# Set __private_ss\n+# void __morestack_set_guard (void *ptr)\n+ENTRY0(__morestack_set_guard)\n+\tstd %r3,-0x7000-64(%r13)\t# tcbhead_t.__private_ss\n+\tblr\n+\tSIZE (__morestack_set_guard)\n+\n+\n+# Return the stack guard value for given stack\n+# void *__morestack_make_guard (void *stack, size_t size)\n+ENTRY0(__morestack_make_guard)\n+\tsub %r3,%r3,%r4\n+\taddi %r3,%r3,BACKOFF\n+\tblr\n+\tSIZE (__morestack_make_guard)\n+\n+\n+# Make __stack_split_initialize a high priority constructor.\n+\t.section .ctors.65535,\"aw\",@progbits\n+\t.p2align 3\n+\t.quad __stack_split_initialize\n+\t.quad __morestack_load_mmap\n+\n+\t.section .note.GNU-stack,\"\",@progbits\n+\t.section .note.GNU-split-stack,\"\",@progbits\n+\t.section .note.GNU-no-split-stack,\"\",@progbits\n+#endif /* __powerpc64__ */"}, {"sha": "0690622e8f52787dd77e0cd67c848157310b0c88", "filename": "libgcc/config/rs6000/t-stack-rs6000", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/libgcc%2Fconfig%2Frs6000%2Ft-stack-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/libgcc%2Fconfig%2Frs6000%2Ft-stack-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ft-stack-rs6000?ref=0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2", "patch": "@@ -0,0 +1,2 @@\n+# Makefile fragment to support -fsplit-stack for powerpc.\n+LIB2ADD_ST += $(srcdir)/config/rs6000/morestack.S"}, {"sha": "a10559bd985faf6ccf97bf9f7ebfee1c08146f88", "filename": "libgcc/generic-morestack.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/libgcc%2Fgeneric-morestack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2/libgcc%2Fgeneric-morestack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fgeneric-morestack.c?ref=0f0fd745255adf8b2904b0acaf1c3b66ec93ddb2", "patch": "@@ -23,6 +23,9 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n+/* powerpc 32-bit not supported.  */\n+#if !defined __powerpc__ || defined __powerpc64__\n+\n #include \"tconfig.h\"\n #include \"tsystem.h\"\n #include \"coretypes.h\"\n@@ -935,6 +938,7 @@ __splitstack_find (void *segment_arg, void *sp, size_t *len,\n       nsp -= 12 * sizeof (void *);\n #elif defined (__i386__)\n       nsp -= 6 * sizeof (void *);\n+#elif defined __powerpc64__\n #else\n #error \"unrecognized target\"\n #endif\n@@ -1170,3 +1174,4 @@ __splitstack_find_context (void *context[NUMBER_OFFSETS], size_t *stack_size,\n }\n \n #endif /* !defined (inhibit_libc) */\n+#endif /* not powerpc 32-bit */"}]}