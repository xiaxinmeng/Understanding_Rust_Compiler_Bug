{"sha": "0ee8e25059355c772a3e7c7eb88d502496bc7922", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVlOGUyNTA1OTM1NWM3NzJhM2U3YzdlYjg4ZDUwMjQ5NmJjNzkyMg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-05-26T11:25:36Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-05-26T11:25:36Z"}, "message": "re PR fortran/31219 (ICE on array of character function results)\n\n2007-05-26 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/31219\n\t* trans.h : Add no_function_call bitfield to gfc_se structure.\n\tAdd stmtblock_t argument to prototype of get_array_ctor_strlen.\n\t* trans-array.c (get_array_ctor_all_strlen): New function.\n\t(get_array_ctor_strlen): Add new stmtblock_t argument and call\n\tnew function for character elements that are not constants,\n\tarrays or variables.\n\t(gfc_conv_array_parameter): Call get_array_ctor_strlen to get\n\tgood string length.\n\t* trans-intrinsic (gfc_conv_intrinsic_len): Add new argument\n\tto call of get_array_ctor_strlen.\n\n\n2007-05-26 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/31219\n\t* gfortran.dg/array_constructor_17.f90: New test.\n\nFrom-SVN: r125088", "tree": {"sha": "6b71a217017b2b1fcc8dac597c2745ed8da1cbb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b71a217017b2b1fcc8dac597c2745ed8da1cbb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ee8e25059355c772a3e7c7eb88d502496bc7922", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ee8e25059355c772a3e7c7eb88d502496bc7922", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ee8e25059355c772a3e7c7eb88d502496bc7922", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ee8e25059355c772a3e7c7eb88d502496bc7922/comments", "author": null, "committer": null, "parents": [{"sha": "150594ba69066ade4b78e51d0a20ef9a16029bc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150594ba69066ade4b78e51d0a20ef9a16029bc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/150594ba69066ade4b78e51d0a20ef9a16029bc2"}], "stats": {"total": 136, "additions": 121, "deletions": 15}, "files": [{"sha": "0d4a8773e5cd1ca81357bd60fa06d2cc228e1b56", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee8e25059355c772a3e7c7eb88d502496bc7922/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee8e25059355c772a3e7c7eb88d502496bc7922/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0ee8e25059355c772a3e7c7eb88d502496bc7922", "patch": "@@ -1,3 +1,17 @@\n+2007-05-26  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31219\n+\t* trans.h : Add no_function_call bitfield to gfc_se structure.\n+\tAdd stmtblock_t argument to prototype of get_array_ctor_strlen.\n+\t* trans-array.c (get_array_ctor_all_strlen): New function.\n+\t(get_array_ctor_strlen): Add new stmtblock_t argument and call\n+\tnew function for character elements that are not constants,\n+\tarrays or variables.\n+\t(gfc_conv_array_parameter): Call get_array_ctor_strlen to get\n+\tgood string length.\n+\t* trans-intrinsic (gfc_conv_intrinsic_len): Add new argument\n+\tto call of get_array_ctor_strlen.\n+\n 2007-05-25  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* intrinsic.texi: Fix typos."}, {"sha": "cda9f9317e118bf67f6c0b5a303fc77bceaad6f4", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee8e25059355c772a3e7c7eb88d502496bc7922/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee8e25059355c772a3e7c7eb88d502496bc7922/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=0ee8e25059355c772a3e7c7eb88d502496bc7922", "patch": "@@ -1366,11 +1366,54 @@ get_array_ctor_var_strlen (gfc_expr * expr, tree * len)\n }\n \n \n+/* A catch-all to obtain the string length for anything that is not a\n+   constant, array or variable.  */\n+static void\n+get_array_ctor_all_strlen (stmtblock_t *block, gfc_expr *e, tree *len)\n+{\n+  gfc_se se;\n+  gfc_ss *ss;\n+\n+  /* Don't bother if we already know the length is a constant.  */\n+  if (*len && INTEGER_CST_P (*len))\n+    return;\n+\n+  if (!e->ref && e->ts.cl->length\n+\t&& e->ts.cl->length->expr_type == EXPR_CONSTANT)\n+    {\n+      /* This is easy.  */\n+      gfc_conv_const_charlen (e->ts.cl);\n+      *len = e->ts.cl->backend_decl;\n+    }\n+  else\n+    {\n+      /* Otherwise, be brutal even if inefficient.  */\n+      ss = gfc_walk_expr (e);\n+      gfc_init_se (&se, NULL);\n+\n+      /* No function call, in case of side effects.  */\n+      se.no_function_call = 1;\n+      if (ss == gfc_ss_terminator)\n+\tgfc_conv_expr (&se, e);\n+      else\n+\tgfc_conv_expr_descriptor (&se, e, ss);\n+\n+      /* Fix the value.  */\n+      *len = gfc_evaluate_now (se.string_length, &se.pre);\n+\n+      gfc_add_block_to_block (block, &se.pre);\n+      gfc_add_block_to_block (block, &se.post);\n+\n+      e->ts.cl->backend_decl = *len;\n+    }\n+}\n+\n+\n /* Figure out the string length of a character array constructor.\n    Returns TRUE if all elements are character constants.  */\n \n bool\n-get_array_ctor_strlen (gfc_constructor * c, tree * len)\n+get_array_ctor_strlen (stmtblock_t *block, gfc_constructor * c, tree * len)\n {\n   bool is_const;\n   \n@@ -1386,7 +1429,7 @@ get_array_ctor_strlen (gfc_constructor * c, tree * len)\n \t  break;\n \n \tcase EXPR_ARRAY:\n-\t  if (!get_array_ctor_strlen (c->expr->value.constructor, len))\n+\t  if (!get_array_ctor_strlen (block, c->expr->value.constructor, len))\n \t    is_const = false;\n \t  break;\n \n@@ -1397,16 +1440,7 @@ get_array_ctor_strlen (gfc_constructor * c, tree * len)\n \n \tdefault:\n \t  is_const = false;\n-\n-\t  /* Hope that whatever we have possesses a constant character\n-\t     length!  */\n-\t  if (!(*len && INTEGER_CST_P (*len)) && c->expr->ts.cl)\n-\t    {\n-\t      gfc_conv_const_charlen (c->expr->ts.cl);\n-\t      *len = c->expr->ts.cl->backend_decl;\n-\t    }\n-\t  /* TODO: For now we just ignore anything we don't know how to\n-\t     handle, and hope we can figure it out a different way.  */\n+\t  get_array_ctor_all_strlen (block, c->expr, len);\n \t  break;\n \t}\n     }\n@@ -1597,10 +1631,13 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n   c = ss->expr->value.constructor;\n   if (ss->expr->ts.type == BT_CHARACTER)\n     {\n-      bool const_string = get_array_ctor_strlen (c, &ss->string_length);\n+      bool const_string = get_array_ctor_strlen (&loop->pre, c, &ss->string_length);\n       if (!ss->string_length)\n \tgfc_todo_error (\"complex character array constructors\");\n \n+      ss->expr->ts.cl->backend_decl = ss->string_length;\n+\n+\n       type = gfc_get_character_type_len (ss->expr->ts.kind, ss->string_length);\n       if (const_string)\n \ttype = build_pointer_type (type);\n@@ -4782,6 +4819,13 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77)\n \t\t      && expr->ref->u.ar.type == AR_FULL);\n   sym = full_array_var ? expr->symtree->n.sym : NULL;\n \n+  if (expr->expr_type == EXPR_ARRAY && expr->ts.type == BT_CHARACTER)\n+    {\n+      get_array_ctor_strlen (&se->pre, expr->value.constructor, &tmp);\n+      expr->ts.cl->backend_decl = gfc_evaluate_now (tmp, &se->pre);\n+      se->string_length = expr->ts.cl->backend_decl;\n+    }\n+\n   /* Is this the result of the enclosing procedure?  */\n   this_array_result = (full_array_var && sym->attr.flavor == FL_PROCEDURE);\n   if (this_array_result"}, {"sha": "d814b28a21a38d042e06fad40ab553c4df4ba805", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee8e25059355c772a3e7c7eb88d502496bc7922/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee8e25059355c772a3e7c7eb88d502496bc7922/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=0ee8e25059355c772a3e7c7eb88d502496bc7922", "patch": "@@ -2537,7 +2537,7 @@ gfc_conv_intrinsic_len (gfc_se * se, gfc_expr * expr)\n       /* Obtain the string length from the function used by\n          trans-array.c(gfc_trans_array_constructor).  */\n       len = NULL_TREE;\n-      get_array_ctor_strlen (arg->value.constructor, &len);\n+      get_array_ctor_strlen (&se->pre, arg->value.constructor, &len);\n       break;\n \n     case EXPR_VARIABLE:"}, {"sha": "f2a5d440b1dc22cd2dab6868f0e4f49eb78285fa", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee8e25059355c772a3e7c7eb88d502496bc7922/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee8e25059355c772a3e7c7eb88d502496bc7922/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=0ee8e25059355c772a3e7c7eb88d502496bc7922", "patch": "@@ -72,6 +72,9 @@ typedef struct gfc_se\n      are NULL.  Used by intrinsic size.  */\n   unsigned data_not_needed:1;\n \n+  /* If set, gfc_conv_function_call does not put byref calls into se->pre.  */\n+  unsigned no_function_call:1;\n+\n   /* Scalarization parameters.  */\n   struct gfc_se *parent;\n   struct gfc_ss *ss;\n@@ -434,7 +437,7 @@ extern GTY(()) tree gfc_static_ctors;\n void gfc_generate_constructors (void);\n \n /* Get the string length of an array constructor.  */\n-bool get_array_ctor_strlen (gfc_constructor *, tree *);\n+bool get_array_ctor_strlen (stmtblock_t *, gfc_constructor *, tree *);\n \n /* Generate a runtime error check.  */\n void gfc_trans_runtime_check (tree, const char *, stmtblock_t *, locus *);"}, {"sha": "0c99b3c956ed371ef88c75473ef11159e13a6419", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee8e25059355c772a3e7c7eb88d502496bc7922/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee8e25059355c772a3e7c7eb88d502496bc7922/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ee8e25059355c772a3e7c7eb88d502496bc7922", "patch": "@@ -1,3 +1,8 @@\n+2007-05-26  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/31219\n+\t* gfortran.dg/array_constructor_17.f90: New test.\n+\n 2007-05-25  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR tree-opt/32090"}, {"sha": "3ce7a91835dbe53e6f60aaae133e77448896d155", "filename": "gcc/testsuite/gfortran.dg/array_constructor_17.f90", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee8e25059355c772a3e7c7eb88d502496bc7922/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee8e25059355c772a3e7c7eb88d502496bc7922/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_17.f90?ref=0ee8e25059355c772a3e7c7eb88d502496bc7922", "patch": "@@ -0,0 +1,40 @@\n+! { dg-do run }\n+! Tests the fix for PR31219, in which the character length of\n+! the functions in the array constructor was not being obtained\n+! correctly and this caused an ICE.\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+  INTEGER :: J\n+  CHARACTER(LEN = 8) :: str\n+  J = 3\n+  write (str,'(2A4)') (/( F(I, J), I = 1, 2)/)\n+  IF (str .NE. \" ODD EVE\") call abort ()\n+\n+! Comment #1 from F-X Coudert (noted by T. Burnus) that\n+! actually exercises a different part of the bug.\n+  call gee( (/g (3)/) )\n+\n+CONTAINS\n+  FUNCTION F (K,J) RESULT(I)\n+    INTEGER :: K, J\n+    CHARACTER(LEN = J) :: I\n+    IF (MODULO (K, 2) .EQ. 0) THEN\n+       I = \"EVEN\"\n+    ELSE\n+       I = \"ODD\"\n+    ENDIF\n+  END FUNCTION\n+\n+  function g(k) result(i)\n+    integer :: k\n+    character(len = k) :: i\n+    i = '1234'\n+  end function\n+  subroutine gee(a)\n+    character(*),dimension(1) :: a\n+    if(len (a) /= 3) call abort ()\n+    if(a(1) /= '123') call abort ()\n+  end subroutine gee\n+\n+END"}]}