{"sha": "2b778c9d57e0eb58d99023e2445b02e0c0be4d7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI3NzhjOWQ1N2UwZWI1OGQ5OTAyM2UyNDQ1YjAyZTBjMGJlNGQ3Yw==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-07-05T20:56:13Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-07-05T20:56:13Z"}, "message": "re PR rtl-optimization/55342 ([LRA,x86] Non-optimal code for simple loop with LRA)\n\n2013-07-05  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/55342\n\t* lra-int.h (lra_subreg_reload_pseudos): New.\n\t* lra.c: Add undoing optional reloads to the block diagram.\n\t(lra_subreg_reload_pseudos): New.\n\t(lra_optional_reload_pseudos): Change comments.\n\t(lra): Init and clear lra_subreg_reload_pseudos.  Clear\n\tlra_optional_reload_pseudos after undo transformations.\n\t* lra-assigns.c (pseudo_prefix_title): New.\n\t(lra_setup_reg_renumber): Use it.\n\t(spill_for): Ditto.  Check subreg reload pseudos too.\n\t(assign_by_spills): Consider subreg reload pseudos too.\n\t* lra-constraints.c (simplify_operand_subreg): Use\n\tlra_subreg_reload_pseudos instead of lra_optional_reload_pseudos.\n\t(curr_insn_transform): Recognize and do optional reloads.\n\t(undo_optional_reloads): New.\n\t(lra_undo_inheritance): Call undo_optional_reloads.\n\n2013-07-05  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/55342\n\t* gcc.target/i386/pr55342.c: New.\n\nFrom-SVN: r200723", "tree": {"sha": "8a8e7f4e3df96defc69d2feee8fbac6ac8d3a56b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a8e7f4e3df96defc69d2feee8fbac6ac8d3a56b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0ba6aff37954721a287391ae505ef0aface6b533", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ba6aff37954721a287391ae505ef0aface6b533", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ba6aff37954721a287391ae505ef0aface6b533"}], "stats": {"total": 245, "additions": 218, "deletions": 27}, "files": [{"sha": "176ecf446dec4afc1487f64b2e2119d254018ff2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b778c9d57e0eb58d99023e2445b02e0c0be4d7c", "patch": "@@ -1,3 +1,22 @@\n+2013-07-05  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/55342\n+\t* lra-int.h (lra_subreg_reload_pseudos): New.\n+\t* lra.c: Add undoing optional reloads to the block diagram.\n+\t(lra_subreg_reload_pseudos): New.\n+\t(lra_optional_reload_pseudos): Change comments.\n+\t(lra): Init and clear lra_subreg_reload_pseudos.  Clear\n+\tlra_optional_reload_pseudos after undo transformations.\n+\t* lra-assigns.c (pseudo_prefix_title): New.\n+\t(lra_setup_reg_renumber): Use it.\n+\t(spill_for): Ditto.  Check subreg reload pseudos too.\n+\t(assign_by_spills): Consider subreg reload pseudos too.\n+\t* lra-constraints.c (simplify_operand_subreg): Use\n+\tlra_subreg_reload_pseudos instead of lra_optional_reload_pseudos.\n+\t(curr_insn_transform): Recognize and do optional reloads.\n+\t(undo_optional_reloads): New.\n+\t(lra_undo_inheritance): Call undo_optional_reloads.\n+\n 2013-07-05  Thomas Quinot  <quinot@adacore.com>\n \n \t* tree-complex.c (expand_complex_operations_1): Fix typo."}, {"sha": "b5736268e693464fb83176fd4605b9271e4b1109", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=2b778c9d57e0eb58d99023e2445b02e0c0be4d7c", "patch": "@@ -672,6 +672,19 @@ update_hard_regno_preference (int regno, int hard_regno, int div)\n     }\n }\n \n+/* Return prefix title for pseudo REGNO.  */\n+static const char *\n+pseudo_prefix_title (int regno)\n+{\n+  return\n+    (regno < lra_constraint_new_regno_start ? \"\"\n+     : bitmap_bit_p (&lra_inheritance_pseudos, regno) ? \"inheritance \"\n+     : bitmap_bit_p (&lra_split_regs, regno) ? \"split \"\n+     : bitmap_bit_p (&lra_optional_reload_pseudos, regno) ? \"optional reload \"\n+     : bitmap_bit_p (&lra_subreg_reload_pseudos, regno) ? \"subreg reload \"\n+     : \"reload \");\n+}\n+\n /* Update REG_RENUMBER and other pseudo preferences by assignment of\n    HARD_REGNO to pseudo REGNO and print about it if PRINT_P.  */\n void\n@@ -692,13 +705,7 @@ lra_setup_reg_renumber (int regno, int hard_regno, bool print_p)\n       lra_hard_reg_usage[hr + i] += lra_reg_info[regno].freq;\n   if (print_p && lra_dump_file != NULL)\n     fprintf (lra_dump_file, \"\t   Assign %d to %sr%d (freq=%d)\\n\",\n-\t     reg_renumber[regno],\n-\t     regno < lra_constraint_new_regno_start\n-\t     ? \"\"\n-\t     : bitmap_bit_p (&lra_inheritance_pseudos, regno) ? \"inheritance \"\n-\t     : bitmap_bit_p (&lra_split_regs, regno) ? \"split \"\n-\t     : bitmap_bit_p (&lra_optional_reload_pseudos, regno)\n-\t     ? \"optional reload \": \"reload \",\n+\t     reg_renumber[regno], pseudo_prefix_title (regno),\n \t     regno, lra_reg_info[regno].freq);\n   if (hard_regno >= 0)\n     {\n@@ -844,6 +851,7 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap)\n \tif ((int) spill_regno >= lra_constraint_new_regno_start\n \t    && ! bitmap_bit_p (&lra_inheritance_pseudos, spill_regno)\n \t    && ! bitmap_bit_p (&lra_split_regs, spill_regno)\n+\t    && ! bitmap_bit_p (&lra_subreg_reload_pseudos, spill_regno)\n \t    && ! bitmap_bit_p (&lra_optional_reload_pseudos, spill_regno))\n \t  goto fail;\n       insn_pseudos_num = 0;\n@@ -953,14 +961,7 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap)\n     {\n       if (lra_dump_file != NULL)\n \tfprintf (lra_dump_file, \"      Spill %sr%d(hr=%d, freq=%d) for r%d\\n\",\n-\t\t ((int) spill_regno < lra_constraint_new_regno_start\n-\t\t  ? \"\"\n-\t\t  : bitmap_bit_p (&lra_inheritance_pseudos, spill_regno)\n-\t\t  ? \"inheritance \"\n-\t\t  : bitmap_bit_p (&lra_split_regs, spill_regno)\n-\t\t  ? \"split \"\n-\t\t  : bitmap_bit_p (&lra_optional_reload_pseudos, spill_regno)\n-\t\t  ? \"optional reload \" : \"reload \"),\n+\t\t pseudo_prefix_title (spill_regno),\n \t\t spill_regno, reg_renumber[spill_regno],\n \t\t lra_reg_info[spill_regno].freq, regno);\n       update_lives (spill_regno, true);\n@@ -1176,6 +1177,7 @@ assign_by_spills (void)\n   bitmap_initialize (&changed_insns, &reg_obstack);\n   bitmap_initialize (&non_reload_pseudos, &reg_obstack);\n   bitmap_ior (&non_reload_pseudos, &lra_inheritance_pseudos, &lra_split_regs);\n+  bitmap_ior_into (&non_reload_pseudos, &lra_subreg_reload_pseudos);\n   bitmap_ior_into (&non_reload_pseudos, &lra_optional_reload_pseudos);\n   for (iter = 0; iter <= 1; iter++)\n     {\n@@ -1350,6 +1352,7 @@ assign_by_spills (void)\n \t\t && lra_reg_info[i].restore_regno >= 0)\n \t     || (bitmap_bit_p (&lra_split_regs, i)\n \t\t && lra_reg_info[i].restore_regno >= 0)\n+\t     || bitmap_bit_p (&lra_subreg_reload_pseudos, i)\n \t     || bitmap_bit_p (&lra_optional_reload_pseudos, i))\n \t    && reg_renumber[i] < 0 && lra_reg_info[i].nrefs != 0\n \t    && regno_allocno_class_array[i] != NO_REGS)"}, {"sha": "a9a673469019c009b00509b0bd8af0d1d60217be", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 129, "deletions": 2, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=2b778c9d57e0eb58d99023e2445b02e0c0be4d7c", "patch": "@@ -1228,7 +1228,7 @@ simplify_operand_subreg (int nop, enum machine_mode reg_mode)\n       if (get_reload_reg (curr_static_id->operand[nop].type, reg_mode, reg,\n \t\t\t  rclass, \"subreg reg\", &new_reg))\n \t{\n-\t  bitmap_set_bit (&lra_optional_reload_pseudos, REGNO (new_reg));\n+\t  bitmap_set_bit (&lra_subreg_reload_pseudos, REGNO (new_reg));\n \t  if (type != OP_OUT\n \t      || GET_MODE_SIZE (GET_MODE (reg)) > GET_MODE_SIZE (mode))\n \t    {\n@@ -3183,6 +3183,8 @@ curr_insn_transform (void)\n \n   for (i = 0; i < n_operands; i++)\n     {\n+      int regno;\n+      bool optional_p = false;\n       rtx old, new_reg;\n       rtx op = *curr_id->operand_loc[i];\n \n@@ -3205,7 +3207,22 @@ curr_insn_transform (void)\n \t\t   current one.  */\n \t\treg_renumber[regno] = -1;\n \t    }\n-\t  continue;\n+\t  /* We can do an optional reload.  If the pseudo got a hard\n+\t     reg, we might improve the code through inheritance.  If\n+\t     it does not get a hard register we coalesce memory/memory\n+\t     moves later.  Ignore move insns to avoid cycling.  */\n+\t  if (! lra_simple_p\n+\t      && lra_undo_inheritance_iter < LRA_MAX_INHERITANCE_PASSES\n+\t      && goal_alt[i] != NO_REGS && REG_P (op)\n+\t      && (regno = REGNO (op)) >= FIRST_PSEUDO_REGISTER\n+\t      && reg_renumber[regno] < 0\n+\t      && (curr_insn_set == NULL_RTX\n+\t\t  || !(REG_P (SET_SRC (curr_insn_set))\n+\t\t       || MEM_P (SET_SRC (curr_insn_set))\n+\t\t       || GET_CODE (SET_SRC (curr_insn_set)) == SUBREG)))\n+\t    optional_p = true;\n+\t  else\n+\t    continue;\n \t}\n \n       /* Operands that match previous ones have already been handled.  */\n@@ -3328,6 +3345,21 @@ curr_insn_transform (void)\n \t/* We must generate code in any case when function\n \t   process_alt_operands decides that it is possible.  */\n \tgcc_unreachable ();\n+      if (optional_p)\n+\t{\n+\t  lra_assert (REG_P (op));\n+\t  regno = REGNO (op);\n+\t  op = *curr_id->operand_loc[i]; /* Substitution.  */\n+\t  if (GET_CODE (op) == SUBREG)\n+\t    op = SUBREG_REG (op);\n+\t  gcc_assert (REG_P (op) && (int) REGNO (op) >= new_regno_start);\n+\t  bitmap_set_bit (&lra_optional_reload_pseudos, REGNO (op));\n+\t  lra_reg_info[REGNO (op)].restore_regno = regno;\n+\t  if (lra_dump_file != NULL)\n+\t    fprintf (lra_dump_file,\n+\t\t     \"      Making reload reg %d for reg %d optional\\n\",\n+\t\t     REGNO (op), regno);\n+\t}\n     }\n   if (before != NULL_RTX || after != NULL_RTX\n       || max_regno_before != max_reg_num ())\n@@ -5273,6 +5305,100 @@ remove_inheritance_pseudos (bitmap remove_pseudos)\n   return change_p;\n }\n \n+/* If optional reload pseudos failed to get a hard register or was not\n+   inherited, it is better to remove optional reloads.  We do this\n+   transformation after undoing inheritance to figure out necessity to\n+   remove optional reloads easier.  Return true if we do any\n+   change.  */\n+static bool\n+undo_optional_reloads (void)\n+{\n+  bool change_p;\n+  unsigned int regno, uid;\n+  bitmap_iterator bi, bi2;\n+  rtx insn, set, src, dest;\n+  bitmap_head removed_optional_reload_pseudos, insn_bitmap;\n+\n+  bitmap_initialize (&removed_optional_reload_pseudos, &reg_obstack);\n+  bitmap_copy (&removed_optional_reload_pseudos, &lra_optional_reload_pseudos);\n+  EXECUTE_IF_SET_IN_BITMAP (&lra_optional_reload_pseudos, 0, regno, bi)\n+    if (reg_renumber[regno] >= 0)\n+      EXECUTE_IF_SET_IN_BITMAP (&lra_reg_info[regno].insn_bitmap, 0, uid, bi2)\n+\t{\n+\t  insn = lra_insn_recog_data[uid]->insn;\n+\t  if ((set = single_set (insn)) == NULL_RTX)\n+\t    continue;\n+\t  src = SET_SRC (set);\n+\t  dest = SET_DEST (set);\n+\t  if (! REG_P (src) || ! REG_P (dest))\n+\t    continue;\n+\t  if ((REGNO (src) == regno\n+\t       && lra_reg_info[regno].restore_regno != (int) REGNO (dest))\n+\t      || (REGNO (dest) == regno\n+\t\t  && lra_reg_info[regno].restore_regno != (int) REGNO (src)))\n+\t    {\n+\t      /* Optional reload was inherited.  Keep it.  */\n+\t      bitmap_clear_bit (&removed_optional_reload_pseudos, regno);\n+\t      if (lra_dump_file != NULL)\n+\t\tfprintf (lra_dump_file, \"Keep optional reload reg %d\\n\", regno);\n+\t    }\n+\t}\n+  change_p = ! bitmap_empty_p (&removed_optional_reload_pseudos);\n+  bitmap_initialize (&insn_bitmap, &reg_obstack);\n+  EXECUTE_IF_SET_IN_BITMAP (&removed_optional_reload_pseudos, 0, regno, bi)\n+    {\n+      if (lra_dump_file != NULL)\n+\tfprintf (lra_dump_file, \"Remove optional reload reg %d\\n\", regno);\n+      bitmap_copy (&insn_bitmap, &lra_reg_info[regno].insn_bitmap);\n+      EXECUTE_IF_SET_IN_BITMAP (&insn_bitmap, 0, uid, bi2)\n+\t{\n+\t  insn = lra_insn_recog_data[uid]->insn;\n+\t  if ((set = single_set (insn)) != NULL_RTX)\n+\t    {\n+\t      src = SET_SRC (set);\n+\t      dest = SET_DEST (set);\n+\t      if (REG_P (src) && REG_P (dest)\n+\t\t  && ((REGNO (src) == regno\n+\t\t       && (lra_reg_info[regno].restore_regno\n+\t\t\t   == (int) REGNO (dest)))\n+\t\t      || (REGNO (dest) == regno\n+\t\t\t  && (lra_reg_info[regno].restore_regno\n+\t\t\t      == (int) REGNO (src)))))\n+\t\t{\n+\t\t  if (lra_dump_file != NULL)\n+\t\t    {\n+\t\t      fprintf (lra_dump_file, \"  Deleting move %u\\n\",\n+\t\t\t       INSN_UID (insn));\n+\t\t      dump_insn_slim (lra_dump_file, insn);\n+\t\t    }\n+\t\t  lra_set_insn_deleted (insn);\n+\t\t  continue;\n+\t\t}\n+\t      /* We should not worry about generation memory-memory\n+\t\t moves here as if the corresponding inheritance did\n+\t\t not work (inheritance pseudo did not get a hard reg),\n+\t\t we remove the inheritance pseudo and the optional\n+\t\t reload.  */\n+\t    }\n+\t  substitute_pseudo (&insn, regno,\n+\t\t\t     regno_reg_rtx[lra_reg_info[regno].restore_regno]);\n+\t  lra_update_insn_regno_info (insn);\n+\t  if (lra_dump_file != NULL)\n+\t    {\n+\t      fprintf (lra_dump_file,\n+\t\t       \"  Restoring original insn:\\n\");\n+\t      dump_insn_slim (lra_dump_file, insn);\n+\t    }\n+\t}\n+    }\n+  /* Clear restore_regnos.  */\n+  EXECUTE_IF_SET_IN_BITMAP (&lra_optional_reload_pseudos, 0, regno, bi)\n+    lra_reg_info[regno].restore_regno = -1;\n+  bitmap_clear (&insn_bitmap);\n+  bitmap_clear (&removed_optional_reload_pseudos);\n+  return change_p;\n+}\n+\n /* Entry function for undoing inheritance/split transformation.\t Return true\n    if we did any RTL change in this pass.  */\n bool\n@@ -5335,5 +5461,6 @@ lra_undo_inheritance (void)\n     lra_reg_info[regno].restore_regno = -1;\n   EXECUTE_IF_SET_IN_BITMAP (&lra_split_regs, 0, regno, bi)\n     lra_reg_info[regno].restore_regno = -1;\n+  change_p = undo_optional_reloads () || change_p;\n   return change_p;\n }"}, {"sha": "cb45c65d13af6b6fa141f2a408dd2b374c09e4b6", "filename": "gcc/lra-int.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=2b778c9d57e0eb58d99023e2445b02e0c0be4d7c", "patch": "@@ -321,6 +321,7 @@ extern int lra_new_regno_start;\n extern int lra_constraint_new_regno_start;\n extern bitmap_head lra_inheritance_pseudos;\n extern bitmap_head lra_split_regs;\n+extern bitmap_head lra_subreg_reload_pseudos;\n extern bitmap_head lra_optional_reload_pseudos;\n extern int lra_constraint_new_insn_uid_start;\n "}, {"sha": "30b7c0a3dd57ae77d13d24785a52b670cd3adeb5", "filename": "gcc/lra.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=2b778c9d57e0eb58d99023e2445b02e0c0be4d7c", "patch": "@@ -43,13 +43,13 @@ along with GCC; see the file COPYING3.\tIf not see\n \n    Here is block diagram of LRA passes:\n \n-                                ---------------------\n-           ---------------     | Undo inheritance    |     ---------------\n-          | Memory-memory |    | for spilled pseudos)|    | New (and old) |\n-          | move coalesce |<---| and splits (for     |<-- |   pseudos     |\n-           ---------------     | pseudos got the     |    |  assignment   |\n-  Start           |            |  same  hard regs)   |     ---------------\n-    |             |             ---------------------               ^\n+                                ------------------------\n+           ---------------     | Undo inheritance for   |     ---------------\n+          | Memory-memory |    | spilled pseudos,       |    | New (and old) |\n+          | move coalesce |<---| splits for pseudos got |<-- |   pseudos     |\n+           ---------------     | the same hard regs,    |    |  assignment   |\n+  Start           |            | and optional reloads   |     ---------------\n+    |             |             ------------------------            ^\n     V             |              ----------------                   |\n  -----------      V             | Update virtual |                  |\n |  Remove   |----> ------------>|    register    |                  |\n@@ -2187,10 +2187,16 @@ bitmap_head lra_inheritance_pseudos;\n /* Split regnos before the new spill pass.  */\n bitmap_head lra_split_regs;\n \n-/* Reload pseudo regnos before the new assign pass which still can be\n-   spilled after the assinment pass.  */\n+/* Reload pseudo regnos before the new assignmnet pass which still can\n+   be spilled after the assinment pass as memory is also accepted in\n+   insns for the reload pseudos.  */\n bitmap_head lra_optional_reload_pseudos;\n \n+/* Pseudo regnos used for subreg reloads before the new assignment\n+   pass.  Such pseudos still can be spilled after the assinment\n+   pass.  */\n+bitmap_head lra_subreg_reload_pseudos;\n+\n /* First UID of insns generated before a new spill pass.  */\n int lra_constraint_new_insn_uid_start;\n \n@@ -2296,6 +2302,7 @@ lra (FILE *f)\n   bitmap_initialize (&lra_inheritance_pseudos, &reg_obstack);\n   bitmap_initialize (&lra_split_regs, &reg_obstack);\n   bitmap_initialize (&lra_optional_reload_pseudos, &reg_obstack);\n+  bitmap_initialize (&lra_subreg_reload_pseudos, &reg_obstack);\n   live_p = false;\n   if (get_frame_size () != 0 && crtl->stack_alignment_needed)\n     /* If we have a stack frame, we must align it now.  The stack size\n@@ -2356,8 +2363,9 @@ lra (FILE *f)\n \t      if (! live_p)\n \t\tlra_clear_live_ranges ();\n \t    }\n+\t  bitmap_clear (&lra_optional_reload_pseudos);\n \t}\n-      bitmap_clear (&lra_optional_reload_pseudos);\n+      bitmap_clear (&lra_subreg_reload_pseudos);\n       bitmap_clear (&lra_inheritance_pseudos);\n       bitmap_clear (&lra_split_regs);\n       if (! lra_need_for_spills_p ())"}, {"sha": "b84de4bc7d0f21ae4f5d7ce3c8ed476c4e17c9b4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2b778c9d57e0eb58d99023e2445b02e0c0be4d7c", "patch": "@@ -1,3 +1,8 @@\n+2013-07-05  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/55342\n+\t* gcc.target/i386/pr55342.c: New.\n+\n 2013-07-05  Marcus Shawcroft  <marcus.shawcroft@arm.com>\n \n \t* gcc.dg/pr57518.c: Adjust scan-rtl-dump-not pattern."}, {"sha": "0d9e6c6238c3dc795728cee0fcd8a1a2223c81c3", "filename": "gcc/testsuite/gcc.target/i386/pr55342.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55342.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b778c9d57e0eb58d99023e2445b02e0c0be4d7c/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55342.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr55342.c?ref=2b778c9d57e0eb58d99023e2445b02e0c0be4d7c", "patch": "@@ -0,0 +1,28 @@\n+/* PR rtl-optimization/55342 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-not \"notb\" } } */\n+\n+\n+void convert_image(unsigned char *in, unsigned char *out, int size) {\n+    int i;\n+    unsigned char * read = in,\n+     * write = out;\n+    for(i = 0; i < size; i++) {\n+        unsigned char r = *read++;\n+        unsigned char g = *read++;\n+        unsigned char b = *read++;\n+        unsigned char c, m, y, k, tmp;\n+        c = 255 - r;\n+        m = 255 - g;\n+        y = 255 - b;\n+\tif (c < m)\n+\t  k = ((c) > (y)?(y):(c));\n+\telse\n+          k = ((m) > (y)?(y):(m));\n+        *write++ = c - k;\n+        *write++ = m - k;\n+        *write++ = y - k;\n+        *write++ = k;\n+    }\n+}"}]}