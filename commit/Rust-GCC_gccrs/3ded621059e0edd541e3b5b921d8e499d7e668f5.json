{"sha": "3ded621059e0edd541e3b5b921d8e499d7e668f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RlZDYyMTA1OWUwZWRkNTQxZTNiNWI5MjFkOGU0OTlkN2U2NjhmNQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-02-05T22:12:20Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-02-05T22:12:20Z"}, "message": "dependency.c (gfc_check_dependency): Remove unused vars and nvars arguments.\n\n\n\t* dependency.c (gfc_check_dependency): Remove unused vars and nvars\n\targuments.  Replace with an \"identical\" argument.  A full array\n\treference to the same symbol is a dependency if identical is true.\n\t* dependency.h (gfc_check_dependency): Update prototype.\n\t* trans-array.h (gfc_check_dependency): Delete duplicate prototype.\n\t* trans-stmt.c: #include dependency.h for gfc_check_dependency.\n\t(gfc_trans_forall_1): Update calls to gfc_check_dependency.\n\t(gfc_trans_where_2): Likewise.  Remove unneeded variables.\n\t(gfc_trans_where_3): New function for simple non-dependent WHEREs.\n\t(gfc_trans_where): Call gfc_trans_where_3 to translate simple\n\tF90-style WHERE statements without internal dependencies.\n\t* Make-lang.in (trans-stmt.o): Depend upon dependency.h.\n\nFrom-SVN: r110625", "tree": {"sha": "6fff194e6c0dfb03db079b04df84ee2e9dc134ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fff194e6c0dfb03db079b04df84ee2e9dc134ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ded621059e0edd541e3b5b921d8e499d7e668f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ded621059e0edd541e3b5b921d8e499d7e668f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ded621059e0edd541e3b5b921d8e499d7e668f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ded621059e0edd541e3b5b921d8e499d7e668f5/comments", "author": null, "committer": null, "parents": [{"sha": "71ab8de85aada56287c4954e6d7fe24529c5ef74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71ab8de85aada56287c4954e6d7fe24529c5ef74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71ab8de85aada56287c4954e6d7fe24529c5ef74"}], "stats": {"total": 254, "additions": 223, "deletions": 31}, "files": [{"sha": "d2a51f40e76d7038cb5eebef1c7efaa4b4352c25", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ded621059e0edd541e3b5b921d8e499d7e668f5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ded621059e0edd541e3b5b921d8e499d7e668f5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3ded621059e0edd541e3b5b921d8e499d7e668f5", "patch": "@@ -1,3 +1,18 @@\n+2006-02-04  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* dependency.c (gfc_check_dependency): Remove unused vars and nvars\n+\targuments.  Replace with an \"identical\" argument.  A full array\n+\treference to the same symbol is a dependency if identical is true.\n+\t* dependency.h (gfc_check_dependency): Update prototype.\n+\t* trans-array.h (gfc_check_dependency): Delete duplicate prototype.\n+\t* trans-stmt.c: #include dependency.h for gfc_check_dependency.\n+\t(gfc_trans_forall_1): Update calls to gfc_check_dependency.\n+\t(gfc_trans_where_2): Likewise.  Remove unneeded variables.\n+\t(gfc_trans_where_3): New function for simple non-dependent WHEREs.\n+\t(gfc_trans_where): Call gfc_trans_where_3 to translate simple\n+\tF90-style WHERE statements without internal dependencies.\n+\t* Make-lang.in (trans-stmt.o): Depend upon dependency.h.\n+\n 2006-02-05  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR fortran/26041"}, {"sha": "c7fa78f03037ecfef1609339bd6d7b35595d41e1", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ded621059e0edd541e3b5b921d8e499d7e668f5/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ded621059e0edd541e3b5b921d8e499d7e668f5/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=3ded621059e0edd541e3b5b921d8e499d7e668f5", "patch": "@@ -279,7 +279,7 @@ fortran/trans-types.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-types.h \\\n   real.h toplev.h $(TARGET_H)\n fortran/trans-const.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans-expr.o: $(GFORTRAN_TRANS_DEPS) fortran/dependency.h\n-fortran/trans-stmt.o: $(GFORTRAN_TRANS_DEPS)\n+fortran/trans-stmt.o: $(GFORTRAN_TRANS_DEPS) fortran/dependency.h\n fortran/trans-io.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-io.h \\\n   fortran/ioparm.def\n fortran/trans-array.o: $(GFORTRAN_TRANS_DEPS)"}, {"sha": "62f3aa62e482aeea95fd6f22b8c88183106d22e6", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ded621059e0edd541e3b5b921d8e499d7e668f5/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ded621059e0edd541e3b5b921d8e499d7e668f5/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=3ded621059e0edd541e3b5b921d8e499d7e668f5", "patch": "@@ -259,10 +259,10 @@ gfc_check_argument_var_dependency (gfc_expr * var, sym_intent intent,\n     {\n     case EXPR_VARIABLE:\n       return (gfc_ref_needs_temporary_p (expr->ref)\n-\t      || gfc_check_dependency (var, expr, NULL, 0));\n+\t      || gfc_check_dependency (var, expr, 1));\n \n     case EXPR_ARRAY:\n-      return gfc_check_dependency (var, expr, NULL, 0);\n+      return gfc_check_dependency (var, expr, 1);\n \n     case EXPR_FUNCTION:\n       if (intent != INTENT_IN && expr->inline_noncopying_intrinsic)\n@@ -339,15 +339,14 @@ gfc_check_fncall_dependency (gfc_expr * other, sym_intent intent,\n \n /* Return true if the statement body redefines the condition.  Returns\n    true if expr2 depends on expr1.  expr1 should be a single term\n-   suitable for the lhs of an assignment.  The symbols listed in VARS\n-   must be considered to have all possible values. All other scalar\n-   variables may be considered constant.  Used for forall and where\n+   suitable for the lhs of an assignment.  The IDENTICAL flag indicates\n+   whether array references to the same symbol with identical range\n+   references count as a dependency or not.  Used for forall and where\n    statements.  Also used with functions returning arrays without a\n    temporary.  */\n \n int\n-gfc_check_dependency (gfc_expr * expr1, gfc_expr * expr2, gfc_expr ** vars,\n-\t\t      int nvars)\n+gfc_check_dependency (gfc_expr * expr1, gfc_expr * expr2, bool identical)\n {\n   gfc_ref *ref;\n   int n;\n@@ -367,11 +366,11 @@ gfc_check_dependency (gfc_expr * expr1, gfc_expr * expr2, gfc_expr ** vars,\n   switch (expr2->expr_type)\n     {\n     case EXPR_OP:\n-      n = gfc_check_dependency (expr1, expr2->value.op.op1, vars, nvars);\n+      n = gfc_check_dependency (expr1, expr2->value.op.op1, identical);\n       if (n)\n \treturn n;\n       if (expr2->value.op.op2)\n-\treturn gfc_check_dependency (expr1, expr2->value.op.op2, vars, nvars);\n+\treturn gfc_check_dependency (expr1, expr2->value.op.op2, identical);\n       return 0;\n \n     case EXPR_VARIABLE:\n@@ -387,15 +386,25 @@ gfc_check_dependency (gfc_expr * expr1, gfc_expr * expr2, gfc_expr ** vars,\n       if (expr1->symtree->n.sym != expr2->symtree->n.sym)\n \treturn 0;\n \n-      for (ref = expr2->ref; ref; ref = ref->next)\n-\t{\n-\t  /* Identical ranges return 0, overlapping ranges return 1.  */\n-\t  if (ref->type == REF_ARRAY)\n-\t    return 1;\n-\t}\n+      if (identical)\n+\treturn 1;\n+\n+      /* Identical ranges return 0, overlapping ranges return 1.  */\n+\n+      /* Return zero if we refer to the same full arrays.  */\n+      if (expr1->ref->type == REF_ARRAY\n+\t  && expr2->ref->type == REF_ARRAY\n+\t  && expr1->ref->u.ar.type == AR_FULL\n+\t  && expr2->ref->u.ar.type == AR_FULL\n+\t  && !expr1->ref->next\n+\t  && !expr2->ref->next)\n+\treturn 0;\n+\n       return 1;\n \n     case EXPR_FUNCTION:\n+      if (expr2->inline_noncopying_intrinsic)\n+\tidentical = 1;\n       /* Remember possible differences between elemental and\n          transformational functions.  All functions inside a FORALL\n          will be pure.  */\n@@ -404,7 +413,7 @@ gfc_check_dependency (gfc_expr * expr1, gfc_expr * expr2, gfc_expr ** vars,\n \t{\n \t  if (!actual->expr)\n \t    continue;\n-\t  n = gfc_check_dependency (expr1, actual->expr, vars, nvars);\n+\t  n = gfc_check_dependency (expr1, actual->expr, identical);\n \t  if (n)\n \t    return n;\n \t}"}, {"sha": "98629583fbfec74786ecdacb6b21a17f9b36190c", "filename": "gcc/fortran/dependency.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ded621059e0edd541e3b5b921d8e499d7e668f5/gcc%2Ffortran%2Fdependency.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ded621059e0edd541e3b5b921d8e499d7e668f5/gcc%2Ffortran%2Fdependency.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.h?ref=3ded621059e0edd541e3b5b921d8e499d7e668f5", "patch": "@@ -25,7 +25,7 @@ bool gfc_ref_needs_temporary_p (gfc_ref *);\n gfc_expr *gfc_get_noncopying_intrinsic_argument (gfc_expr *);\n int gfc_check_fncall_dependency (gfc_expr *, sym_intent, gfc_symbol *,\n \t\t\t\t gfc_actual_arglist *);\n-int gfc_check_dependency (gfc_expr *, gfc_expr *, gfc_expr **, int);\n+int gfc_check_dependency (gfc_expr *, gfc_expr *, bool);\n int gfc_is_same_range (gfc_array_ref *, gfc_array_ref *, int, int);\n int gfc_expr_is_one (gfc_expr *, int);\n "}, {"sha": "ef3d0265187b08e0d0f0a72bd25d86fd7766a8df", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ded621059e0edd541e3b5b921d8e499d7e668f5/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ded621059e0edd541e3b5b921d8e499d7e668f5/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=3ded621059e0edd541e3b5b921d8e499d7e668f5", "patch": "@@ -115,9 +115,6 @@ tree gfc_conv_descriptor_stride (tree, tree);\n tree gfc_conv_descriptor_lbound (tree, tree);\n tree gfc_conv_descriptor_ubound (tree, tree);\n \n-/* Dependency checking for WHERE and FORALL.  */\n-int gfc_check_dependency (gfc_expr *, gfc_expr *, gfc_expr **, int);\n-\n /* Add pre-loop scalarization code for intrinsic functions which require\n    special handling.  */\n void gfc_add_intrinsic_ss_code (gfc_loopinfo *, gfc_ss *);"}, {"sha": "b44774eb19fcb9a5cb228440684f2a45257bf751", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 181, "deletions": 10, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ded621059e0edd541e3b5b921d8e499d7e668f5/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ded621059e0edd541e3b5b921d8e499d7e668f5/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=3ded621059e0edd541e3b5b921d8e499d7e668f5", "patch": "@@ -37,6 +37,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"trans-array.h\"\n #include \"trans-const.h\"\n #include \"arith.h\"\n+#include \"dependency.h\"\n \n typedef struct iter_info\n {\n@@ -2503,7 +2504,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n \t{\n \tcase EXEC_ASSIGN:\n           /* A scalar or array assignment.  */\n-\t  need_temp = gfc_check_dependency (c->expr, c->expr2, varexpr, nvar);\n+\t  need_temp = gfc_check_dependency (c->expr, c->expr2, 0);\n           /* Temporaries due to array assignment data dependencies introduce\n              no end of problems.  */\n \t  if (need_temp)\n@@ -2546,7 +2547,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n \n         /* Pointer assignment inside FORALL.  */\n \tcase EXEC_POINTER_ASSIGN:\n-          need_temp = gfc_check_dependency (c->expr, c->expr2, varexpr, nvar);\n+          need_temp = gfc_check_dependency (c->expr, c->expr2, 0);\n           if (need_temp)\n             gfc_trans_pointer_assign_need_temp (c->expr, c->expr2,\n                                                 nested_forall_info, &block);\n@@ -3062,14 +3063,7 @@ gfc_trans_where_2 (gfc_code * code, tree mask, tree pmask,\n               expr2 = cnext->expr2;\n               if (nested_forall_info != NULL)\n                 {\n-                  int nvar;\n-                  gfc_expr **varexpr;\n-\n-                  nvar = nested_forall_info->nvar;\n-                  varexpr = (gfc_expr **)\n-                            gfc_getmem (nvar * sizeof (gfc_expr *));\n-                  need_temp = gfc_check_dependency (expr1, expr2, varexpr,\n-                                                    nvar);\n+                  need_temp = gfc_check_dependency (expr1, expr2, 0);\n                   if (need_temp)\n                     gfc_trans_assign_need_temp (expr1, expr2, mask,\n                                                 nested_forall_info, block);\n@@ -3124,6 +3118,137 @@ gfc_trans_where_2 (gfc_code * code, tree mask, tree pmask,\n   }\n }\n \n+/* Translate a simple WHERE construct or statement without dependencies.\n+   CBLOCK is the \"then\" clause of the WHERE statement, where CBLOCK->EXPR\n+   is the mask condition, and EBLOCK if non-NULL is the \"else\" clause.\n+   Currently both CBLOCK and EBLOCK are restricted to single assignments.  */\n+\n+static tree\n+gfc_trans_where_3 (gfc_code * cblock, gfc_code * eblock)\n+{\n+  stmtblock_t block, body;\n+  gfc_expr *cond, *tdst, *tsrc, *edst, *esrc;\n+  tree tmp, cexpr, tstmt, estmt;\n+  gfc_ss *css, *tdss, *tsss;\n+  gfc_se cse, tdse, tsse, edse, esse;\n+  gfc_loopinfo loop;\n+  gfc_ss *edss = 0;\n+  gfc_ss *esss = 0;\n+\n+  cond = cblock->expr;\n+  tdst = cblock->next->expr;\n+  tsrc = cblock->next->expr2;\n+  edst = eblock ? eblock->next->expr : NULL;\n+  esrc = eblock ? eblock->next->expr2 : NULL;\n+\n+  gfc_start_block (&block);\n+  gfc_init_loopinfo (&loop);\n+\n+  /* Handle the condition.  */\n+  gfc_init_se (&cse, NULL);\n+  css = gfc_walk_expr (cond);\n+  gfc_add_ss_to_loop (&loop, css);\n+\n+  /* Handle the then-clause.  */\n+  gfc_init_se (&tdse, NULL);\n+  gfc_init_se (&tsse, NULL);\n+  tdss = gfc_walk_expr (tdst);\n+  tsss = gfc_walk_expr (tsrc);\n+  if (tsss == gfc_ss_terminator)\n+    {\n+      tsss = gfc_get_ss ();\n+      tsss->next = gfc_ss_terminator;\n+      tsss->type = GFC_SS_SCALAR;\n+      tsss->expr = tsrc;\n+    }\n+  gfc_add_ss_to_loop (&loop, tdss);\n+  gfc_add_ss_to_loop (&loop, tsss);\n+\n+  if (eblock)\n+    {\n+      /* Handle the else clause.  */\n+      gfc_init_se (&edse, NULL);\n+      gfc_init_se (&esse, NULL);\n+      edss = gfc_walk_expr (edst);\n+      esss = gfc_walk_expr (esrc);\n+      if (esss == gfc_ss_terminator)\n+\t{\n+\t  esss = gfc_get_ss ();\n+\t  esss->next = gfc_ss_terminator;\n+\t  esss->type = GFC_SS_SCALAR;\n+\t  esss->expr = esrc;\n+\t}\n+      gfc_add_ss_to_loop (&loop, edss);\n+      gfc_add_ss_to_loop (&loop, esss);\n+    }\n+\n+  gfc_conv_ss_startstride (&loop);\n+  gfc_conv_loop_setup (&loop);\n+\n+  gfc_mark_ss_chain_used (css, 1);\n+  gfc_mark_ss_chain_used (tdss, 1);\n+  gfc_mark_ss_chain_used (tsss, 1);\n+  if (eblock)\n+    {\n+      gfc_mark_ss_chain_used (edss, 1);\n+      gfc_mark_ss_chain_used (esss, 1);\n+    }\n+\n+  gfc_start_scalarized_body (&loop, &body);\n+\n+  gfc_copy_loopinfo_to_se (&cse, &loop);\n+  gfc_copy_loopinfo_to_se (&tdse, &loop);\n+  gfc_copy_loopinfo_to_se (&tsse, &loop);\n+  cse.ss = css;\n+  tdse.ss = tdss;\n+  tsse.ss = tsss;\n+  if (eblock)\n+    {\n+      gfc_copy_loopinfo_to_se (&edse, &loop);\n+      gfc_copy_loopinfo_to_se (&esse, &loop);\n+      edse.ss = edss;\n+      esse.ss = esss;\n+    }\n+\n+  gfc_conv_expr (&cse, cond);\n+  gfc_add_block_to_block (&body, &cse.pre);\n+  cexpr = cse.expr;\n+\n+  gfc_conv_expr (&tsse, tsrc);\n+  if (tdss != gfc_ss_terminator && loop.temp_ss != NULL)\n+    {\n+      gfc_conv_tmp_array_ref (&tdse);\n+      gfc_advance_se_ss_chain (&tdse);\n+    }\n+  else\n+    gfc_conv_expr (&tdse, tdst);\n+\n+  if (eblock)\n+    {\n+      gfc_conv_expr (&esse, esrc);\n+      if (edss != gfc_ss_terminator && loop.temp_ss != NULL)\n+        {\n+          gfc_conv_tmp_array_ref (&edse);\n+          gfc_advance_se_ss_chain (&edse);\n+        }\n+      else\n+        gfc_conv_expr (&edse, edst);\n+    }\n+\n+  tstmt = gfc_trans_scalar_assign (&tdse, &tsse, tdst->ts.type);\n+  estmt = eblock ? gfc_trans_scalar_assign (&edse, &esse, edst->ts.type)\n+\t\t : build_empty_stmt ();\n+  tmp = build3_v (COND_EXPR, cexpr, tstmt, estmt);\n+  gfc_add_expr_to_block (&body, tmp);\n+  gfc_add_block_to_block (&body, &cse.post);\n+\n+  gfc_trans_scalarizing_loops (&loop, &body);\n+  gfc_add_block_to_block (&block, &loop.pre);\n+  gfc_add_block_to_block (&block, &loop.post);\n+  gfc_cleanup_loop (&loop);\n+\n+  return gfc_finish_block (&block);\n+}\n \n /* As the WHERE or WHERE construct statement can be nested, we call\n    gfc_trans_where_2 to do the translation, and pass the initial\n@@ -3134,9 +3259,55 @@ gfc_trans_where (gfc_code * code)\n {\n   stmtblock_t block;\n   temporary_list *temp, *p;\n+  gfc_code *cblock;\n+  gfc_code *eblock;\n   tree args;\n   tree tmp;\n \n+  cblock = code->block;\n+  if (cblock->next\n+      && cblock->next->op == EXEC_ASSIGN\n+      && !cblock->next->next)\n+    {\n+      eblock = cblock->block;\n+      if (!eblock)\n+\t{\n+          /* A simple \"WHERE (cond) x = y\" statement or block is\n+\t     dependence free if cond is not dependent upon writing x,\n+\t     and the source y is unaffected by the destination x.  */\n+\t  if (!gfc_check_dependency (cblock->next->expr,\n+\t\t\t\t     cblock->expr, 0)\n+\t      && !gfc_check_dependency (cblock->next->expr,\n+\t\t\t\t\tcblock->next->expr2, 0))\n+\t    return gfc_trans_where_3 (cblock, NULL);\n+\t}\n+      else if (!eblock->expr\n+\t       && !eblock->block\n+\t       && eblock->next\n+\t       && eblock->next->op == EXEC_ASSIGN\n+\t       && !eblock->next->next)\n+\t{\n+          /* A simple \"WHERE (cond) x1 = y1 ELSEWHERE x2 = y2 ENDWHERE\"\n+\t     block is dependence free if cond is not dependent on writes\n+\t     to x1 and x2, y1 is not dependent on writes to x2, and y2\n+\t     is not dependent on writes to x1, and both y's are not\n+\t     dependent upon their own x's.  */\n+\t  if (!gfc_check_dependency(cblock->next->expr,\n+\t\t\t\t    cblock->expr, 0)\n+\t      && !gfc_check_dependency(eblock->next->expr,\n+\t\t\t\t       cblock->expr, 0)\n+\t      && !gfc_check_dependency(cblock->next->expr,\n+\t\t\t\t       eblock->next->expr2, 0)\n+\t      && !gfc_check_dependency(eblock->next->expr,\n+\t\t\t\t       cblock->next->expr2, 0)\n+\t      && !gfc_check_dependency(cblock->next->expr,\n+\t\t\t\t       cblock->next->expr2, 0)\n+\t      && !gfc_check_dependency(eblock->next->expr,\n+\t\t\t\t       eblock->next->expr2, 0))\n+\t    return gfc_trans_where_3 (cblock, eblock);\n+\t}\n+    }\n+\n   gfc_start_block (&block);\n   temp = NULL;\n "}]}