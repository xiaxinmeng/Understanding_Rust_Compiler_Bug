{"sha": "a7b87f730fb2a5904d0f8c5d36c554cd1918bfec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdiODdmNzMwZmIyYTU5MDRkMGY4YzVkMzZjNTU0Y2QxOTE4YmZlYw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-06-06T14:46:34Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-06-06T14:46:34Z"}, "message": "haifa-sched.c (restore_bb_notes): Clear bb field of the notes emited outside of basic block.\n\n\t* haifa-sched.c (restore_bb_notes): Clear bb field of the notes\n\temited outside of basic block.\n\t* cfgbuild.c (find_bb_boundaries): Clear bb field for insns between\n\tthe created blocks.\n\t* rtl.h (delete_insn_chain): Declaration changed.\n\t* cfgrtl.c (delete_insn_chain): Add option to clear bb field for\n\tnon-removed insns.\n\t(rtl_delete_block, rtl_merge_blocks): Pass true to delete_insn_chain.\n\t(delete_insn_chain_and_edges, try_redirect_by_replacing_jump,\n\trtl_tidy_fallthru_edge, cfg_layout_merge_blocks): Pass false \n\tto delete_insn_chain.\n\t(rtl_verify_flow_info_1): Verify that the insns in header and footer\n\tdo not have bb field set.\n\t(rtl_verify_flow_info): Verify that insns between basic blocks do not\n\thave bb field set.\n\t* recog.c (peephole2_optimize): Add argument to delete_insn_chain call.\n\t* cfgcleanup.c (try_optimize_cfg): Ditto.\n\nFrom-SVN: r125492", "tree": {"sha": "83547529d1afe3a91257ca4399bfb3001703c6a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83547529d1afe3a91257ca4399bfb3001703c6a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec/comments", "author": null, "committer": null, "parents": [{"sha": "45222d4a3d07fc721de24bcb6c264dcd0541150a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45222d4a3d07fc721de24bcb6c264dcd0541150a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45222d4a3d07fc721de24bcb6c264dcd0541150a"}], "stats": {"total": 141, "additions": 118, "deletions": 23}, "files": [{"sha": "24097297e5097d095db806e79fb86ce09ea3bf52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7b87f730fb2a5904d0f8c5d36c554cd1918bfec", "patch": "@@ -1,3 +1,23 @@\n+2007-06-06  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* haifa-sched.c (restore_bb_notes): Clear bb field of the notes\n+\temited outside of basic block.\n+\t* cfgbuild.c (find_bb_boundaries): Clear bb field for insns between\n+\tthe created blocks.\n+\t* rtl.h (delete_insn_chain): Declaration changed.\n+\t* cfgrtl.c (delete_insn_chain): Add option to clear bb field for\n+\tnon-removed insns.\n+\t(rtl_delete_block, rtl_merge_blocks): Pass true to delete_insn_chain.\n+\t(delete_insn_chain_and_edges, try_redirect_by_replacing_jump,\n+\trtl_tidy_fallthru_edge, cfg_layout_merge_blocks): Pass false \n+\tto delete_insn_chain.\n+\t(rtl_verify_flow_info_1): Verify that the insns in header and footer\n+\tdo not have bb field set.\n+\t(rtl_verify_flow_info): Verify that insns between basic blocks do not\n+\thave bb field set.\n+\t* recog.c (peephole2_optimize): Add argument to delete_insn_chain call.\n+\t* cfgcleanup.c (try_optimize_cfg): Ditto.\n+\n 2007-06-06  Thomas Neumann  <tneumann@users.sourceforge.net>\n \n \t* lambda-code.c (struct lambda_lattice_s): Add a name to the struct."}, {"sha": "cb216afa2c73f888c565272b909d83ad23de5cd2", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=a7b87f730fb2a5904d0f8c5d36c554cd1918bfec", "patch": "@@ -630,7 +630,7 @@ find_bb_boundaries (basic_block bb)\n {\n   basic_block orig_bb = bb;\n   rtx insn = BB_HEAD (bb);\n-  rtx end = BB_END (bb);\n+  rtx end = BB_END (bb), x;\n   rtx table;\n   rtx flow_transfer_insn = NULL_RTX;\n   edge fallthru = NULL;\n@@ -651,7 +651,16 @@ find_bb_boundaries (basic_block bb)\n \t{\n \t  fallthru = split_block (bb, PREV_INSN (insn));\n \t  if (flow_transfer_insn)\n-\t    BB_END (bb) = flow_transfer_insn;\n+\t    {\n+\t      BB_END (bb) = flow_transfer_insn;\n+\n+\t      /* Clean up the bb field for the insns between the blocks.  */\n+\t      for (x = NEXT_INSN (flow_transfer_insn);\n+\t\t   x != BB_HEAD (fallthru->dest);\n+\t\t   x = NEXT_INSN (x))\n+\t\tif (!BARRIER_P (x))\n+\t\t  set_block_for_insn (x, NULL);\n+\t    }\n \n \t  bb = fallthru->dest;\n \t  remove_edge (fallthru);\n@@ -666,6 +675,14 @@ find_bb_boundaries (basic_block bb)\n \t{\n \t  fallthru = split_block (bb, PREV_INSN (insn));\n \t  BB_END (bb) = flow_transfer_insn;\n+\n+\t  /* Clean up the bb field for the insns between the blocks.  */\n+\t  for (x = NEXT_INSN (flow_transfer_insn);\n+\t       x != BB_HEAD (fallthru->dest);\n+\t       x = NEXT_INSN (x))\n+\t    if (!BARRIER_P (x))\n+\t      set_block_for_insn (x, NULL);\n+\n \t  bb = fallthru->dest;\n \t  remove_edge (fallthru);\n \t  flow_transfer_insn = NULL_RTX;\n@@ -682,7 +699,18 @@ find_bb_boundaries (basic_block bb)\n      return and barrier, or possibly other sequence not behaving like\n      ordinary jump, we need to take care and move basic block boundary.  */\n   if (flow_transfer_insn)\n-    BB_END (bb) = flow_transfer_insn;\n+    {\n+      BB_END (bb) = flow_transfer_insn;\n+\n+      /* Clean up the bb field for the insns that do not belong to BB.  */\n+      x = flow_transfer_insn;\n+      while (x != end)\n+\t{\n+\t  x = NEXT_INSN (x);\n+\t  if (!BARRIER_P (x))\n+\t    set_block_for_insn (x, NULL);\n+\t}\n+    }\n \n   /* We've possibly replaced the conditional jump by conditional jump\n      followed by cleanup at fallthru edge, so the outgoing edges may"}, {"sha": "dafdcd5df758259ebbb347e7a1acbaa35973860c", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=a7b87f730fb2a5904d0f8c5d36c554cd1918bfec", "patch": "@@ -1999,7 +1999,7 @@ try_optimize_cfg (int mode)\n \t\t{\n \t\t  rtx label = BB_HEAD (b);\n \n-\t\t  delete_insn_chain (label, label);\n+\t\t  delete_insn_chain (label, label, false);\n \t\t  /* In the case label is undeletable, move it after the\n \t\t     BASIC_BLOCK note.  */\n \t\t  if (NOTE_KIND (BB_HEAD (b)) == NOTE_INSN_DELETED_LABEL)"}, {"sha": "5655eef15271d37afd4a6b1b105dfea5b4616dbf", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 61, "deletions": 15, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=a7b87f730fb2a5904d0f8c5d36c554cd1918bfec", "patch": "@@ -195,10 +195,11 @@ delete_insn_and_edges (rtx insn)\n }\n \n /* Unlink a chain of insns between START and FINISH, leaving notes\n-   that must be paired.  */\n+   that must be paired.  If CLEAR_BB is true, we set bb field for\n+   insns that cannot be removed to NULL.  */\n \n void\n-delete_insn_chain (rtx start, rtx finish)\n+delete_insn_chain (rtx start, rtx finish, bool clear_bb)\n {\n   rtx next;\n \n@@ -213,6 +214,9 @@ delete_insn_chain (rtx start, rtx finish)\n       else\n \tnext = delete_insn (start);\n \n+      if (clear_bb && !INSN_DELETED_P (start))\n+\tset_block_for_insn (start, NULL);\n+\n       if (start == finish)\n \tbreak;\n       start = next;\n@@ -229,7 +233,7 @@ delete_insn_chain_and_edges (rtx first, rtx last)\n       && BLOCK_FOR_INSN (last)\n       && BB_END (BLOCK_FOR_INSN (last)) == last)\n     purge = true;\n-  delete_insn_chain (first, last);\n+  delete_insn_chain (first, last, false);\n   if (purge)\n     purge_dead_edges (BLOCK_FOR_INSN (last));\n }\n@@ -370,7 +374,8 @@ rtl_delete_block (basic_block b)\n \n   /* Selectively delete the entire chain.  */\n   BB_HEAD (b) = NULL;\n-  delete_insn_chain (insn, end);\n+  delete_insn_chain (insn, end, true);\n+\n   if (b->il.rtl->global_live_at_start)\n     {\n       FREE_REG_SET (b->il.rtl->global_live_at_start);\n@@ -608,7 +613,7 @@ rtl_merge_blocks (basic_block a, basic_block b)\n   /* Delete everything marked above as well as crap that might be\n      hanging out between the two blocks.  */\n   BB_HEAD (b) = NULL;\n-  delete_insn_chain (del_first, del_last);\n+  delete_insn_chain (del_first, del_last, true);\n \n   /* Reassociate the insns of B with A.  */\n   if (!b_empty)\n@@ -745,7 +750,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t{\n \t  rtx insn = src->il.rtl->footer;\n \n-\t  delete_insn_chain (kill_from, BB_END (src));\n+\t  delete_insn_chain (kill_from, BB_END (src), false);\n \n \t  /* Remove barriers but keep jumptables.  */\n \t  while (insn)\n@@ -765,7 +770,8 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t    }\n \t}\n       else\n-\tdelete_insn_chain (kill_from, PREV_INSN (BB_HEAD (target)));\n+\tdelete_insn_chain (kill_from, PREV_INSN (BB_HEAD (target)),\n+\t\t\t   false);\n     }\n \n   /* If this already is simplejump, redirect it.  */\n@@ -801,13 +807,13 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t\t INSN_UID (insn), INSN_UID (BB_END (src)));\n \n \n-      delete_insn_chain (kill_from, insn);\n+      delete_insn_chain (kill_from, insn, false);\n \n       /* Recognize a tablejump that we are converting to a\n \t simple jump and remove its associated CODE_LABEL\n \t and ADDR_VEC or ADDR_DIFF_VEC.  */\n       if (tablejump_p (insn, &label, &table))\n-\tdelete_insn_chain (label, table);\n+\tdelete_insn_chain (label, table, false);\n \n       barrier = next_nonnote_insn (BB_END (src));\n       if (!barrier || !BARRIER_P (barrier))\n@@ -1217,7 +1223,7 @@ rtl_tidy_fallthru_edge (edge e)\n \n   /* Selectively unlink the sequence.  */\n   if (q != PREV_INSN (BB_HEAD (c)))\n-    delete_insn_chain (NEXT_INSN (q), PREV_INSN (BB_HEAD (c)));\n+    delete_insn_chain (NEXT_INSN (q), PREV_INSN (BB_HEAD (c)), false);\n \n   e->flags |= EDGE_FALLTHRU;\n }\n@@ -1715,6 +1721,23 @@ rtl_verify_flow_info_1 (void)\n \t\t   bb->index);\n \t    err = 1;\n \t  }\n+\n+      for (insn = bb->il.rtl->header; insn; insn = NEXT_INSN (insn))\n+\tif (!BARRIER_P (insn)\n+\t    && BLOCK_FOR_INSN (insn) != NULL)\n+\t  {\n+\t    error (\"insn %d in header of bb %d has non-NULL basic block\",\n+\t\t   INSN_UID (insn), bb->index);\n+\t    err = 1;\n+\t  }\n+      for (insn = bb->il.rtl->footer; insn; insn = NEXT_INSN (insn))\n+\tif (!BARRIER_P (insn)\n+\t    && BLOCK_FOR_INSN (insn) != NULL)\n+\t  {\n+\t    error (\"insn %d in footer of bb %d has non-NULL basic block\",\n+\t\t   INSN_UID (insn), bb->index);\n+\t    err = 1;\n+\t  }\n     }\n \n   /* Now check the basic blocks (boundaries etc.) */\n@@ -1918,10 +1941,21 @@ rtl_verify_flow_info (void)\n       rtx head = BB_HEAD (bb);\n       rtx end = BB_END (bb);\n \n-      /* Verify the end of the basic block is in the INSN chain.  */\n       for (x = last_head; x != NULL_RTX; x = PREV_INSN (x))\n-\tif (x == end)\n-\t  break;\n+\t{\n+\t  /* Verify the end of the basic block is in the INSN chain.  */\n+\t  if (x == end)\n+\t    break;\n+\n+\t  /* And that the code outside of basic blocks has NULL bb field.  */\n+\tif (!BARRIER_P (x)\n+\t    && BLOCK_FOR_INSN (x) != NULL)\n+\t  {\n+\t    error (\"insn %d outside of basic blocks has non-NULL bb field\",\n+\t\t   INSN_UID (x));\n+\t    err = 1;\n+\t  }\n+\t}\n \n       if (!x)\n \t{\n@@ -1955,7 +1989,7 @@ rtl_verify_flow_info (void)\n \t  err = 1;\n \t}\n \n-      last_head = x;\n+      last_head = PREV_INSN (x);\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->flags & EDGE_FALLTHRU)\n@@ -2000,6 +2034,18 @@ rtl_verify_flow_info (void)\n \t}\n     }\n \n+  for (x = last_head; x != NULL_RTX; x = PREV_INSN (x))\n+    {\n+      /* Check that the code before the first basic block has NULL\n+\t bb field.  */\n+      if (!BARRIER_P (x)\n+\t  && BLOCK_FOR_INSN (x) != NULL)\n+\t{\n+\t  error (\"insn %d outside of basic blocks has non-NULL bb field\",\n+\t\t INSN_UID (x));\n+\t  err = 1;\n+\t}\n+    }\n   free (bb_info);\n \n   num_bb_notes = 0;\n@@ -2550,7 +2596,7 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n       rtx first = BB_END (a), last;\n \n       last = emit_insn_after_noloc (b->il.rtl->header, BB_END (a));\n-      delete_insn_chain (NEXT_INSN (first), last);\n+      delete_insn_chain (NEXT_INSN (first), last, false);\n       b->il.rtl->header = NULL;\n     }\n "}, {"sha": "cf026446194dbef78397693e84a32cdaf35c823d", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=a7b87f730fb2a5904d0f8c5d36c554cd1918bfec", "patch": "@@ -4080,8 +4080,9 @@ extend_bb (void)\n \t  /* Don't emit a NOTE if it would end up before a BARRIER.  */\n \t  && !BARRIER_P (NEXT_INSN (insn))))\n     {\n-      emit_note_after (NOTE_INSN_DELETED, insn);\n-      /* Make insn to appear outside BB.  */\n+      rtx note = emit_note_after (NOTE_INSN_DELETED, insn);\n+      /* Make insn appear outside BB.  */\n+      set_block_for_insn (note, NULL);\n       BB_END (EXIT_BLOCK_PTR->prev_bb) = insn;\n     }\n }"}, {"sha": "19b6cb2f89cf6479cd7c24a82a693b8fe65da6ac", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=a7b87f730fb2a5904d0f8c5d36c554cd1918bfec", "patch": "@@ -3214,7 +3214,7 @@ peephole2_optimize (void)\n \t\t  try = emit_insn_after_setloc (try, peep2_insn_data[i].insn,\n \t\t\t\t\t        INSN_LOCATOR (peep2_insn_data[i].insn));\n \t\t  before_try = PREV_INSN (insn);\n-\t\t  delete_insn_chain (insn, peep2_insn_data[i].insn);\n+\t\t  delete_insn_chain (insn, peep2_insn_data[i].insn, false);\n \n \t\t  /* Re-insert the EH_REGION notes.  */\n \t\t  if (note || (was_call && nonlocal_goto_handler_labels))"}, {"sha": "2934eabd19220c605e65bd63f22068b377613ce5", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b87f730fb2a5904d0f8c5d36c554cd1918bfec/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a7b87f730fb2a5904d0f8c5d36c554cd1918bfec", "patch": "@@ -2062,7 +2062,7 @@ extern rtx emit (rtx);\n extern rtx delete_insn (rtx);\n extern rtx entry_of_function (void);\n extern void emit_insn_at_entry (rtx);\n-extern void delete_insn_chain (rtx, rtx);\n+extern void delete_insn_chain (rtx, rtx, bool);\n extern rtx unlink_insn_chain (rtx, rtx);\n extern rtx delete_insn_and_edges (rtx);\n extern void delete_insn_chain_and_edges (rtx, rtx);"}]}