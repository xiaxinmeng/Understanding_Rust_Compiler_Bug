{"sha": "ae429eabd866b9984f29b0305a903e5cb548909f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU0MjllYWJkODY2Yjk5ODRmMjliMDMwNWE5MDNlNWNiNTQ4OTA5Zg==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-03-21T08:48:27Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-03-21T08:48:27Z"}, "message": "2003-03-21  Michael Koch  <konqueror@gmx.de>\n\n\t* java/io/LineNumberReader.java\n\t(LineNumberReader): Merged documentation with classpath.\n\t(getLineNumber): Likewise.\n\t(setLineNumber): Likewise.\n\t(mark): Likewise.\n\t(reset): Likewise.\n\t(read): Likewise.\n\t(readLine): Likewise.\n\t(skip): Likewise.\n\nFrom-SVN: r64654", "tree": {"sha": "bb05d5b5228864c42a954c2d1130bfd811ebdbab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb05d5b5228864c42a954c2d1130bfd811ebdbab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae429eabd866b9984f29b0305a903e5cb548909f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae429eabd866b9984f29b0305a903e5cb548909f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae429eabd866b9984f29b0305a903e5cb548909f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae429eabd866b9984f29b0305a903e5cb548909f/comments", "author": null, "committer": null, "parents": [{"sha": "025f5843ab4401f904dcf7bda555bb50ff849964", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/025f5843ab4401f904dcf7bda555bb50ff849964", "html_url": "https://github.com/Rust-GCC/gccrs/commit/025f5843ab4401f904dcf7bda555bb50ff849964"}], "stats": {"total": 150, "additions": 149, "deletions": 1}, "files": [{"sha": "0cfabb50853c564468abd2a4584e4a68f173905f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae429eabd866b9984f29b0305a903e5cb548909f/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae429eabd866b9984f29b0305a903e5cb548909f/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ae429eabd866b9984f29b0305a903e5cb548909f", "patch": "@@ -1,3 +1,15 @@\n+2003-03-21  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/io/LineNumberReader.java\n+\t(LineNumberReader): Merged documentation with classpath.\n+\t(getLineNumber): Likewise.\n+\t(setLineNumber): Likewise.\n+\t(mark): Likewise.\n+\t(reset): Likewise.\n+\t(read): Likewise.\n+\t(readLine): Likewise.\n+\t(skip): Likewise.\n+\n 2003-03-21  Michael Koch  <konqueror@gmx.de>\n \n \t* java/rmi/RMISecurityManager.java"}, {"sha": "8ef670d372fb485c1442c64c15d87aae977b9442", "filename": "libjava/java/io/LineNumberReader.java", "status": "modified", "additions": 137, "deletions": 1, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae429eabd866b9984f29b0305a903e5cb548909f/libjava%2Fjava%2Fio%2FLineNumberReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae429eabd866b9984f29b0305a903e5cb548909f/libjava%2Fjava%2Fio%2FLineNumberReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FLineNumberReader.java?ref=ae429eabd866b9984f29b0305a903e5cb548909f", "patch": "@@ -38,7 +38,22 @@\n package java.io;\n \n /**\n+ * This class functions like a standard <code>Reader</code> except that it\n+ * counts line numbers, and canonicalizes newline characters.  As data\n+ * is read, whenever the char sequences \"\\r\", \"\\n\", or \"\\r\\n\" are encountered,\n+ * the running line count is incremeted by one.  Additionally, the whatever\n+ * line termination sequence was encountered will be converted to a \"\\n\"\n+ * char.  Note that this class numbers lines from 0.  When the first\n+ * line terminator is encountered, the line number is incremented to 1, and\n+ * so on.  Also note that actual \"\\r\" and \"\\n\" characters are looked for.\n+ * The system dependent line separator sequence is ignored.\n+ * <p>\n+ * This class counts only line termination characters.  If the last line\n+ * read from the stream does not end in a line termination sequence, it\n+ * will not be counted as a line.\n+ *\n  * @author Per Bothner <bothner@cygnus.com>\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @date April 22, 1998.  \n  */\n /* Written using \"Java Class Libraries\", 2nd edition, plus online\n@@ -52,27 +67,51 @@\n  *\n  * This implementation is also minimal in the number of fields it uses.\n  */\n-\n public class LineNumberReader extends BufferedReader\n {\n   /** The current line number. */\n   int lineNumber;\n \n+  /**\n+    * Create a new <code>LineNumberReader</code> that reads from the\n+    * specified subordinate <code>Reader</code>.  A default 8K char sized\n+    * buffer will be used for reads.\n+    *\n+    * @param in The subordinate <code>Reader</code> to read from\n+    */\n   public LineNumberReader(Reader in)\n   {\n     super(in, 8192);\n   }\n \n+  /**\n+    * This method initializes a new <code>LineNumberReader</code> to read\n+    * from the specified subordinate <code>Reader</code> using the specified\n+    * read buffer size.\n+    *\n+    * @param in The subordinate <code>Reader</code> to read from\n+    * @param size The buffer size to use for reading\n+    */\n   public LineNumberReader(Reader in, int size)\n   {\n     super(in, size);\n   }\n \n+  /**\n+    * This method returns the current line number\n+    *\n+    * @returns The current line number\n+    */\n   public int getLineNumber()\n   {\n     return lineNumber;\n   }\n \n+  /**\n+    * This method sets the current line number to the specified value.\n+    *\n+    * @param line_number The new line number\n+    */\n   public void setLineNumber(int lineNumber)\n   {\n     this.lineNumber = lineNumber;\n@@ -92,6 +131,28 @@ private static int countLines (char[] buffer, int off, int len)\n     return count;\n   }\n \n+  /**\n+    * This method marks a position in the input to which the stream can be\n+    * \"reset\" char calling the <code>reset()</code> method.  The parameter\n+    * <code>readlimit</code> is the number of chars that can be read from the\n+    * stream after setting the mark before the mark becomes invalid.   For\n+    * example, if <code>mark()</code> is called with a read limit of 10,\n+    * then when\n+    * 11 chars of data are read from the stream before the <code>reset()</code>\n+    * method is called, then the mark is invalid and the stream object\n+    * instance is not required to remember the mark.\n+    * <p>\n+    * In this class, this method will remember the current line number as well\n+    * as the current position in the stream.  When the <code>reset()</code>\n+    * method\n+    * is called, the line number will be restored to the saved line number in\n+    * addition to the stream position.\n+    *\n+    * @param readlimit The number of chars that can be read before the\n+    * mark becomes invalid\n+    *\n+    * @exception IOException If an error occurs\n+    */\n   public void mark(int readLimit) throws IOException\n   {\n     synchronized (lock)\n@@ -114,6 +175,17 @@ public void mark(int readLimit) throws IOException\n       }\n   }\n \n+  /**\n+    * This method resets a stream to the point where the <code>mark()</code>\n+    * method\n+    * was called.  Any chars that were read after the mark point was set will\n+    * be re-read during subsequent reads.\n+    * <p>\n+    * In this class, this method will also restore the line number that was\n+    * current when the <code>mark()</code> method was called.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n   public void reset() throws IOException\n   {\n     synchronized (lock)\n@@ -128,6 +200,24 @@ public void reset() throws IOException\n       }\n   }\n \n+  /**\n+    * This method reads an unsigned char from the input stream and returns it\n+    * as an int in the range of 0-65535.  This method will return -1 if the\n+    * end of the stream has been reached.\n+    * <p>\n+    * Note that if a line termination sequence is encountered (ie, \"\\r\",\n+    * \"\\n\", or \"\\r\\n\") then that line termination sequence is converted to\n+    * a single \"\\n\" value which is returned from this method.  This means\n+    * that it is possible this method reads two chars from the subordinate\n+    * stream instead of just one.\n+    * <p>\n+    * Note that this method will block until a char of data is available\n+    * to be read.\n+    *\n+    * @return The char read or -1 if end of stream\n+    *\n+    * @exception IOException If an error occurs\n+    */\n   public int read() throws IOException\n   {\n     synchronized (lock)\n@@ -154,6 +244,28 @@ public int read() throws IOException\n       }\n   }\n \n+  /**\n+    * This method reads chars from a stream and stores them into a caller\n+    * supplied buffer.  It starts storing data at index <code>offset</code> into    * the buffer and attemps to read <code>len</code> chars.  This method can\n+    * return before reading the number of chars requested.  The actual number\n+    * of chars read is returned as an int.  A -1 is returned to indicated the\n+    * end of the stream.\n+    * <p>\n+    * This method will block until some data can be read.\n+    * <p>\n+    * Note that if a line termination sequence is encountered (ie, \"\\r\",\n+    * \"\\n\", or \"\\r\\n\") then that line termination sequence is converted to\n+    * a single \"\\n\" value which is stored in the buffer.  Only a single\n+    * char is counted towards the number of chars read in this case.\n+    *\n+    * @param buf The array into which the chars read should be stored\n+    * @param offset The offset into the array to start storing chars\n+    * @param len The requested number of chars to read\n+    *\n+    * @return The actual number of chars read, or -1 if end of stream\n+    *\n+    * @exception IOException If an error occurs.\n+    */\n   public int read(char[] buf, int offset, int count) throws IOException\n   {\n     if (count <= 0)\n@@ -213,6 +325,17 @@ private void skipRedundantLF() throws IOException\n       }\n   }\n \n+  /**\n+    * This method reads a line of text from the input stream and returns\n+    * it as a <code>String</code>.  A line is considered to be terminated\n+    * by a \"\\r\", \"\\n\", or \"\\r\\n\" sequence, not by the system dependent line\n+    * separator.\n+    *\n+    * @return The line read as a <code>String</code> or <code>null</code>\n+    * if end of stream.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n   public String readLine() throws IOException\n   {\n     // BufferedReader.readLine already does this.  Shouldn't need to keep\n@@ -239,6 +362,18 @@ public String readLine() throws IOException\n     return str;\n   }\n \n+  /**\n+    * This method skips over characters in the stream.  This method will\n+    * skip the specified number of characters if possible, but is not required\n+    * to skip them all.  The actual number of characters skipped is returned.\n+    * This method returns 0 if the specified number of chars is less than 1.\n+    *\n+    * @param count The specified number of chars to skip.\n+    *\n+    * @return The actual number of chars skipped.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n   public long skip(long count) throws IOException\n   {\n     if (count <= 0)\n@@ -272,3 +407,4 @@ public long skip(long count) throws IOException\n     return count - to_do;\n   }\n }\n+"}]}