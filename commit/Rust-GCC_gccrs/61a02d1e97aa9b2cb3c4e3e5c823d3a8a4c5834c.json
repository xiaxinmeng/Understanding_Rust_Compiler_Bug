{"sha": "61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFhMDJkMWU5N2FhOWIyY2IzYzRlM2U1YzgyM2QzYThhNGM1ODM0Yw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-07-03T00:56:35Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-07-03T00:56:35Z"}, "message": "compiler: rework type and package tracking in exporter\n    \n    Revamps the way the exporter tracks exported types and imported\n    packages that need to be mentioned in the export data.\n    \n    The previous implementation wasn't properly handling the case where an\n    exported non-inlinable function refers to an imported type whose\n    method set includes an inlinable function whose body makes a call to a\n    function in another package that's not directly used in the original\n    package.\n    \n    This patch integrates together two existing traversal helper classes,\n    \"Collect_references_from_inline\" and \"Find_types_to_prepare\" into a\n    single helper \"Collect_export_references\", so as to have common/shared\n    code that looks for indirectly imported packages.\n    \n    Fixes golang/go#32778\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/183850\n\nFrom-SVN: r272955", "tree": {"sha": "ba9c904f9fe356d87ab7ee4f3f59bebc39a71d83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba9c904f9fe356d87ab7ee4f3f59bebc39a71d83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c/comments", "author": null, "committer": null, "parents": [{"sha": "5935baf5bb52209ed2e8fa0f435e19bd4e0507db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5935baf5bb52209ed2e8fa0f435e19bd4e0507db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5935baf5bb52209ed2e8fa0f435e19bd4e0507db"}], "stats": {"total": 674, "additions": 384, "deletions": 290}, "files": [{"sha": "c39a36d269a21a351d7511235cb355f8d2ee7d2c", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c", "patch": "@@ -1,4 +1,4 @@\n-7f753feb8df400d6ed17cdbdfb364f7f3a42fb31\n+aebd2d6303e4bb970b088e84f6c66279095dfea6\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "8cbddac1446e77de0386c6de930649e9793f53f1", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 369, "deletions": 280, "changes": 649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c", "patch": "@@ -99,29 +99,83 @@ Export::~Export()\n }\n \n // A traversal class to collect functions and global variables\n-// referenced by inlined functions.\n+// referenced by inlined functions, and also to gather up\n+// referenced types that need to be included in the exports.\n \n-class Collect_references_from_inline : public Traverse\n+class Collect_export_references : public Traverse\n {\n  public:\n-  Collect_references_from_inline(Unordered_set(Named_object*)* exports,\n-\t\t\t\t std::vector<Named_object*>* check_inline_refs)\n-    : Traverse(traverse_expressions),\n-      exports_(exports), check_inline_refs_(check_inline_refs)\n+  Collect_export_references(Export* exp,\n+                            Unordered_set(Named_object*)* exports,\n+                            Unordered_set(const Package*)* imports)\n+    : Traverse(traverse_expressions\n+               | traverse_types),\n+      exp_(exp), exports_(exports), imports_(imports),\n+      inline_fcn_worklist_(NULL)\n   { }\n \n+  // Initial entry point; performs a walk to expand the exports set.\n+  void\n+  expand_exports(std::vector<Named_object*>* inlinable_functions);\n+\n+  // Second entry point (called after the method above), to find\n+  // all types referenced by exports.\n+  void\n+  prepare_types();\n+\n+ protected:\n+  // Override of parent class method.\n   int\n   expression(Expression**);\n \n+  // Override of parent class method.\n+  int\n+  type(Type* type);\n+\n+  // Traverse the components of a function type.\n+  void\n+  traverse_function_type(Function_type*);\n+\n+  // Traverse the methods of a named type, and register its package.\n+  void\n+  traverse_named_type(Named_type*);\n+\n  private:\n+  // The exporter.\n+  Export* exp_;\n   // The set of named objects to export.\n   Unordered_set(Named_object*)* exports_;\n-  // Functions we are exporting with inline bodies that need to be checked.\n-  std::vector<Named_object*>* check_inline_refs_;\n+  // Set containing all directly and indirectly imported packages.\n+  Unordered_set(const Package*)* imports_;\n+  // Functions we've already traversed and don't need to visit again.\n+  Unordered_set(Named_object*) checked_functions_;\n+  // Worklist of functions we are exporting with inline bodies that need\n+  // to be checked.\n+  std::vector<Named_object*>* inline_fcn_worklist_;\n };\n \n+void\n+Collect_export_references::expand_exports(std::vector<Named_object*>* fcns)\n+{\n+  this->inline_fcn_worklist_ = fcns;\n+  while (!this->inline_fcn_worklist_->empty())\n+    {\n+      Named_object* no = this->inline_fcn_worklist_->back();\n+      this->inline_fcn_worklist_->pop_back();\n+      std::pair<Unordered_set(Named_object*)::iterator, bool> ins =\n+\tthis->checked_functions_.insert(no);\n+      if (ins.second)\n+\t{\n+\t  // This traversal may add new objects to this->exports_ and new\n+\t  // functions to this->inline_fcn_worklist_.\n+\t  no->func_value()->block()->traverse(this);\n+\t}\n+    }\n+  this->inline_fcn_worklist_ = NULL;\n+}\n+\n int\n-Collect_references_from_inline::expression(Expression** pexpr)\n+Collect_export_references::expression(Expression** pexpr)\n {\n   const Expression* expr = *pexpr;\n \n@@ -131,6 +185,10 @@ Collect_references_from_inline::expression(Expression** pexpr)\n       Named_object* no = ve->named_object();\n       if (no->is_variable() && no->var_value()->is_global())\n \t{\n+          const Package* var_package = no->package();\n+          if (var_package != NULL)\n+            this->imports_->insert(var_package);\n+\n \t  this->exports_->insert(no);\n \t  no->var_value()->set_is_referenced_by_inline();\n \t}\n@@ -142,50 +200,216 @@ Collect_references_from_inline::expression(Expression** pexpr)\n     {\n       Named_object* no = fe->named_object();\n \n+      const Package* func_package = fe->named_object()->package();\n+      if (func_package != NULL)\n+        this->imports_->insert(func_package);\n+\n       if (no->is_function_declaration()\n \t  && no->func_declaration_value()->type()->is_builtin())\n \treturn TRAVERSE_CONTINUE;\n \n-      std::pair<Unordered_set(Named_object*)::iterator, bool> ins =\n-\tthis->exports_->insert(no);\n+      if (this->inline_fcn_worklist_ != NULL)\n+        {\n+          std::pair<Unordered_set(Named_object*)::iterator, bool> ins =\n+              this->exports_->insert(no);\n \n-      if (no->is_function())\n-\tno->func_value()->set_is_referenced_by_inline();\n+          if (no->is_function())\n+            no->func_value()->set_is_referenced_by_inline();\n \n-      // If ins.second is false then this object was already in\n-      // exports_, in which case it was already added to\n-      // check_inline_refs_ the first time we added it to exports_, so\n-      // we don't need to add it again.\n-      if (ins.second\n-\t  && no->is_function()\n-\t  && no->func_value()->export_for_inlining())\n-\tthis->check_inline_refs_->push_back(no);\n+          // If ins.second is false then this object was already in\n+          // exports_, in which case it was already added to\n+          // check_inline_refs_ the first time we added it to exports_, so\n+          // we don't need to add it again.\n+          if (ins.second\n+              && no->is_function()\n+              && no->func_value()->export_for_inlining())\n+            this->inline_fcn_worklist_->push_back(no);\n+        }\n \n       return TRAVERSE_CONTINUE;\n     }\n \n   return TRAVERSE_CONTINUE;\n }\n \n-// A functor to sort Named_object pointers by name.\n+// Collect up the set of types mentioned in things we're exporting, and collect\n+// all the packages encountered during type traversal, to make sure we can\n+// declare things referered to indirectly (for example, in the body of an\n+// exported inline function from another package).\n \n-struct Sort_bindings\n+void\n+Collect_export_references::prepare_types()\n {\n-  bool\n-  operator()(const Named_object* n1, const Named_object* n2) const\n-  {\n-    if (n1->package() != n2->package())\n-      {\n-\tif (n1->package() == NULL)\n-\t  return true;\n-\tif (n2->package() == NULL)\n-\t  return false;\n-\treturn n1->package()->pkgpath() < n2->package()->pkgpath();\n-      }\n+  // Iterate through the exported objects and traverse any types encountered.\n+  for (Unordered_set(Named_object*)::iterator p = this->exports_->begin();\n+       p != this->exports_->end();\n+       ++p)\n+    {\n+      Named_object* no = *p;\n+      switch (no->classification())\n+\t{\n+\tcase Named_object::NAMED_OBJECT_CONST:\n+\t  {\n+\t    Type* t = no->const_value()->type();\n+\t    if (t != NULL && !t->is_abstract())\n+\t      Type::traverse(t, this);\n+\t  }\n+\t  break;\n \n-    return n1->name() < n2->name();\n-  }\n-};\n+\tcase Named_object::NAMED_OBJECT_TYPE:\n+\t  Type::traverse(no->type_value()->real_type(), this);\n+\t  this->traverse_named_type(no->type_value());\n+\t  break;\n+\n+\tcase Named_object::NAMED_OBJECT_VAR:\n+\t  Type::traverse(no->var_value()->type(), this);\n+\t  break;\n+\n+\tcase Named_object::NAMED_OBJECT_FUNC:\n+\t  {\n+\t    Function* fn = no->func_value();\n+\t    this->traverse_function_type(fn->type());\n+\t    if (fn->export_for_inlining())\n+\t      fn->block()->traverse(this);\n+\t  }\n+\t  break;\n+\n+\tcase Named_object::NAMED_OBJECT_FUNC_DECLARATION:\n+\t  this->traverse_function_type(no->func_declaration_value()->type());\n+\t  break;\n+\n+\tdefault:\n+\t  // We shouldn't see anything else.  If we do we'll give an\n+\t  // error later when we try to actually export it.\n+\t  break;\n+\t}\n+    }\n+}\n+\n+// Record referenced type, record package imports, and make sure we traverse\n+// methods of named types.\n+\n+int\n+Collect_export_references::type(Type* type)\n+{\n+  // Skip forwarders; don't try to give them a type index.\n+  if (type->forward_declaration_type() != NULL)\n+    return TRAVERSE_CONTINUE;\n+\n+  // Skip the void type, which we'll see when exporting\n+  // unsafe.Pointer.  The void type is not itself exported, because\n+  // Pointer_type::do_export checks for it.\n+  if (type->is_void_type())\n+    return TRAVERSE_SKIP_COMPONENTS;\n+\n+  // Skip abstract types.  We should never see these in real code,\n+  // only in things like const declarations.\n+  if (type->is_abstract())\n+    return TRAVERSE_SKIP_COMPONENTS;\n+\n+  // For interfaces make sure that embedded methods are sorted, since the\n+  // comparison function we use for indexing types relies on it (this call has\n+  // to happen before the record_type call below).\n+  if (type->classification() == Type::TYPE_INTERFACE)\n+    {\n+      Interface_type* it = type->interface_type();\n+      if (it != NULL)\n+        it->sort_embedded();\n+    }\n+\n+  if (!this->exp_->record_type(type))\n+    {\n+      // We've already seen this type.\n+      return TRAVERSE_SKIP_COMPONENTS;\n+    }\n+\n+  // At this stage of compilation traversing interface types traverses\n+  // the final list of methods, but we export the locally defined\n+  // methods.  If there is an embedded interface type we need to make\n+  // sure to export that.  Check classification, rather than calling\n+  // the interface_type method, because we want to handle named types\n+  // below.\n+  if (type->classification() == Type::TYPE_INTERFACE)\n+    {\n+      Interface_type* it = type->interface_type();\n+      const Typed_identifier_list* methods = it->local_methods();\n+      if (methods != NULL)\n+\t{\n+\t  for (Typed_identifier_list::const_iterator p = methods->begin();\n+\t       p != methods->end();\n+\t       ++p)\n+\t    {\n+\t      if (p->name().empty())\n+\t\tType::traverse(p->type(), this);\n+\t      else\n+\t\tthis->traverse_function_type(p->type()->function_type());\n+\t    }\n+\t}\n+      return TRAVERSE_SKIP_COMPONENTS;\n+    }\n+\n+  Named_type* nt = type->named_type();\n+  if (nt != NULL)\n+    this->traverse_named_type(nt);\n+\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+void\n+Collect_export_references::traverse_named_type(Named_type* nt)\n+{\n+  const Package* package = nt->named_object()->package();\n+  if (package != NULL)\n+    this->imports_->insert(package);\n+\n+  // We have to traverse the methods of named types, because we are\n+  // going to export them.  This is not done by ordinary type\n+  // traversal.\n+  const Bindings* methods = nt->local_methods();\n+  if (methods != NULL)\n+    {\n+      for (Bindings::const_definitions_iterator pm =\n+\t     methods->begin_definitions();\n+\t   pm != methods->end_definitions();\n+\t   ++pm)\n+\t{\n+\t  Function* fn = (*pm)->func_value();\n+\t  this->traverse_function_type(fn->type());\n+\t  if (fn->export_for_inlining())\n+\t    fn->block()->traverse(this);\n+\t}\n+\n+      for (Bindings::const_declarations_iterator pm =\n+\t     methods->begin_declarations();\n+\t   pm != methods->end_declarations();\n+\t   ++pm)\n+\t{\n+\t  Named_object* mno = pm->second;\n+\t  if (mno->is_function_declaration())\n+\t    this->traverse_function_type(mno->func_declaration_value()->type());\n+\t}\n+    }\n+}\n+\n+// Traverse the types in a function type.  We don't need the function\n+// type itself, just the receiver, parameter, and result types.\n+\n+void\n+Collect_export_references::traverse_function_type(Function_type* type)\n+{\n+  go_assert(type != NULL);\n+  if (this->remember_type(type))\n+    return;\n+  const Typed_identifier* receiver = type->receiver();\n+  if (receiver != NULL)\n+    Type::traverse(receiver->type(), this);\n+  const Typed_identifier_list* parameters = type->parameters();\n+  if (parameters != NULL)\n+    parameters->traverse(this);\n+  const Typed_identifier_list* results = type->results();\n+  if (results != NULL)\n+    results->traverse(this);\n+}\n \n // Return true if we should export NO.\n \n@@ -224,6 +448,54 @@ should_export(Named_object* no)\n   return true;\n }\n \n+// A functor to sort Named_object pointers by name.\n+\n+struct Sort_bindings\n+{\n+  bool\n+  operator()(const Named_object* n1, const Named_object* n2) const\n+  {\n+    if (n1->package() != n2->package())\n+      {\n+\tif (n1->package() == NULL)\n+\t  return true;\n+\tif (n2->package() == NULL)\n+\t  return false;\n+\treturn n1->package()->pkgpath() < n2->package()->pkgpath();\n+      }\n+\n+    return n1->name() < n2->name();\n+  }\n+};\n+\n+// A functor to sort types for export.\n+\n+struct Sort_types\n+{\n+  bool\n+  operator()(const Type* t1, const Type* t2) const\n+  {\n+    const Named_type* nt1 = t1->named_type();\n+    const Named_type* nt2 = t2->named_type();\n+    if (nt1 != NULL)\n+      {\n+        if (nt2 != NULL)\n+          {\n+            Sort_bindings sb;\n+            return sb(nt1->named_object(), nt2->named_object());\n+          }\n+        else\n+          return true;\n+      }\n+    else if (nt2 != NULL)\n+      return false;\n+    if (t1->classification() != t2->classification())\n+      return t1->classification() < t2->classification();\n+    Gogo* gogo = go_get_gogo();\n+    return gogo->type_descriptor_name(t1, NULL).compare(gogo->type_descriptor_name(t2, NULL)) < 0;\n+  }\n+};\n+\n // Export those identifiers marked for exporting.\n \n void\n@@ -291,29 +563,15 @@ Export::export_globals(const std::string& package_name,\n \texports.insert(p->second);\n     }\n \n-  // Look through the bodies of the functions in CHECK_INLINE_REFS to\n-  // find other names we may need to export, to satisfy those\n-  // references.  Use CHECKED to skip checking function bodies more\n-  // than once.\n-  Unordered_set(Named_object*) checked;\n-  Collect_references_from_inline refs(&exports, &check_inline_refs);\n-  while (!check_inline_refs.empty())\n-    {\n-      Named_object* no = check_inline_refs.back();\n-      check_inline_refs.pop_back();\n-      std::pair<Unordered_set(Named_object*)::iterator, bool> ins =\n-\tchecked.insert(no);\n-      if (ins.second)\n-\t{\n-\t  // This traversal may add new objects to EXPORTS and new\n-\t  // functions to CHECK_INLINE_REFS.\n-\t  no->func_value()->block()->traverse(&refs);\n-\t}\n-    }\n-\n   // Track all imported packages mentioned in export data.\n   Unordered_set(const Package*) all_imports;\n \n+  Collect_export_references collect(this, &exports, &all_imports);\n+\n+  // Walk the set of inlinable routine bodies collected above. This\n+  // can potentially expand the exports set.\n+  collect.expand_exports(&check_inline_refs);\n+\n   // Export the symbols in sorted order.  That will reduce cases where\n   // irrelevant changes to the source code affect the exported\n   // interface.\n@@ -333,10 +591,14 @@ Export::export_globals(const std::string& package_name,\n \n   std::sort(sorted_exports.begin(), sorted_exports.end(), Sort_bindings());\n \n+  // Collect up the set of types mentioned in things we're exporting,\n+  // and any packages that may be referred to indirectly.\n+  collect.prepare_types();\n+\n   // Assign indexes to all exported types and types referenced by\n-  // exported types, and collect all packages mentioned.\n-  int unexported_type_index = this->prepare_types(&sorted_exports,\n-\t\t\t\t\t\t  &all_imports);\n+  // things we're exporting.  Return value is index of first non-exported\n+  // type.\n+  int unexported_type_index = this->assign_type_indices(sorted_exports);\n \n   // Although the export data is readable, at least this version is,\n   // it is conceptually a binary format.  Start with a four byte\n@@ -401,261 +663,88 @@ Export::export_globals(const std::string& package_name,\n   this->stream_->write_checksum(s);\n }\n \n-// Traversal class to find referenced types.\n-\n-class Find_types_to_prepare : public Traverse\n-{\n- public:\n-  Find_types_to_prepare(Export* exp,\n-\t\t\tUnordered_set(const Package*)* imports)\n-    : Traverse(traverse_types),\n-      exp_(exp), imports_(imports)\n-  { }\n-\n-  int\n-  type(Type* type);\n-\n-  // Traverse the components of a function type.\n-  void\n-  traverse_function(Function_type*);\n-\n-  // Traverse the methods of a named type, and register its package.\n-  void\n-  traverse_named_type(Named_type*);\n-\n- private:\n-  // Exporters.\n-  Export* exp_;\n-  // List of packages we are building.\n-  Unordered_set(const Package*)* imports_;\n-};\n-\n-// Set type index of referenced type, record package imports, and make\n-// sure we traverse methods of named types.\n+// Record a type in the \"to be indexed\" set. Return true if the type\n+// was not already in the set, false otherwise.\n \n-int\n-Find_types_to_prepare::type(Type* type)\n+bool\n+Export::record_type(Type* type)\n {\n-  // Skip forwarders; don't try to give them a type index.\n-  if (type->forward_declaration_type() != NULL)\n-    return TRAVERSE_CONTINUE;\n-\n-  // Skip the void type, which we'll see when exporting\n-  // unsafe.Pointer.  The void type is not itself exported, because\n-  // Pointer_type::do_export checks for it.\n-  if (type->is_void_type())\n-    return TRAVERSE_SKIP_COMPONENTS;\n-\n-  // Skip abstract types.  We should never see these in real code,\n-  // only in things like const declarations.\n-  if (type->is_abstract())\n-    return TRAVERSE_SKIP_COMPONENTS;\n-\n-  // For interfaces make sure that embedded methods are sorted, since the\n-  // comparison function we use for indexing types relies on it (this call has\n-  // to happen before the set_type_index call below).\n-  if (type->classification() == Type::TYPE_INTERFACE)\n-    {\n-      Interface_type* it = type->interface_type();\n-      if (it != NULL)\n-        it->sort_embedded();\n-    }\n+  type = type->forwarded();\n \n-  if (!this->exp_->set_type_index(type))\n+  std::pair<Type_refs::iterator, bool> ins =\n+    this->impl_->type_refs.insert(std::make_pair(type, 0));\n+  if (!ins.second)\n     {\n       // We've already seen this type.\n-      return TRAVERSE_SKIP_COMPONENTS;\n-    }\n-\n-  // At this stage of compilation traversing interface types traverses\n-  // the final list of methods, but we export the locally defined\n-  // methods.  If there is an embedded interface type we need to make\n-  // sure to export that.  Check classification, rather than calling\n-  // the interface_type method, because we want to handle named types\n-  // below.\n-  if (type->classification() == Type::TYPE_INTERFACE)\n-    {\n-      Interface_type* it = type->interface_type();\n-      const Typed_identifier_list* methods = it->local_methods();\n-      if (methods != NULL)\n-\t{\n-\t  for (Typed_identifier_list::const_iterator p = methods->begin();\n-\t       p != methods->end();\n-\t       ++p)\n-\t    {\n-\t      if (p->name().empty())\n-\t\tType::traverse(p->type(), this);\n-\t      else\n-\t\tthis->traverse_function(p->type()->function_type());\n-\t    }\n-\t}\n-      return TRAVERSE_SKIP_COMPONENTS;\n+      return false;\n     }\n+  ins.first->second = 0;\n \n-  Named_type* nt = type->named_type();\n-  if (nt != NULL)\n-    this->traverse_named_type(nt);\n-\n-  return TRAVERSE_CONTINUE;\n-}\n-\n-// Traverse the types in a function type.  We don't need the function\n-// type itself, just the receiver, parameter, and result types.\n-\n-void\n-Find_types_to_prepare::traverse_function(Function_type* type)\n-{\n-  go_assert(type != NULL);\n-  if (this->remember_type(type))\n-    return;\n-  const Typed_identifier* receiver = type->receiver();\n-  if (receiver != NULL)\n-    Type::traverse(receiver->type(), this);\n-  const Typed_identifier_list* parameters = type->parameters();\n-  if (parameters != NULL)\n-    parameters->traverse(this);\n-  const Typed_identifier_list* results = type->results();\n-  if (results != NULL)\n-    results->traverse(this);\n+  return true;\n }\n \n-// Traverse the methods of a named type, and record its package.\n+// Assign the specified type an index.\n \n void\n-Find_types_to_prepare::traverse_named_type(Named_type* nt)\n+Export::set_type_index(const Type* type)\n {\n-  const Package* package = nt->named_object()->package();\n-  if (package != NULL)\n-    this->imports_->insert(package);\n-\n-  // We have to traverse the methods of named types, because we are\n-  // going to export them.  This is not done by ordinary type\n-  // traversal.\n-  const Bindings* methods = nt->local_methods();\n-  if (methods != NULL)\n-    {\n-      for (Bindings::const_definitions_iterator pm =\n-\t     methods->begin_definitions();\n-\t   pm != methods->end_definitions();\n-\t   ++pm)\n-\t{\n-\t  Function* fn = (*pm)->func_value();\n-\t  this->traverse_function(fn->type());\n-\t  if (fn->export_for_inlining())\n-\t    fn->block()->traverse(this);\n-\t}\n-\n-      for (Bindings::const_declarations_iterator pm =\n-\t     methods->begin_declarations();\n-\t   pm != methods->end_declarations();\n-\t   ++pm)\n-\t{\n-\t  Named_object* mno = pm->second;\n-\t  if (mno->is_function_declaration())\n-\t    this->traverse_function(mno->func_declaration_value()->type());\n-\t}\n-    }\n+  type = type->forwarded();\n+  std::pair<Type_refs::iterator, bool> ins =\n+    this->impl_->type_refs.insert(std::make_pair(type, 0));\n+  go_assert(!ins.second);\n+  int index = this->type_index_;\n+  ++this->type_index_;\n+  go_assert(ins.first->second == 0);\n+  ins.first->second = index;\n }\n \n-// Prepare to export types by assigning a type index to every exported\n-// type and every type referenced by an exported type.  Also collect\n-// all the packages we see in types, so that if we refer to any types\n-// from indirectly imported packages we can tell the importer about\n-// the package.  This returns the number of exported types.\n+// This helper assigns type indices to all types mentioned directly or\n+// indirectly in the things we're exporting. Actual exported types are given\n+// indices according to where the appear on the sorted exports list; all other\n+// types appear afterwards. Return value is the total number of exported types\n+// plus 1, e.g. the index of the 1st non-exported type.\n \n int\n-Export::prepare_types(const std::vector<Named_object*>* exports,\n-\t\t      Unordered_set(const Package*)* imports)\n+Export::assign_type_indices(const std::vector<Named_object*>& sorted_exports)\n {\n   // Assign indexes to all the exported types.\n-  for (std::vector<Named_object*>::const_iterator p = exports->begin();\n-       p != exports->end();\n+  for (std::vector<Named_object*>::const_iterator p = sorted_exports.begin();\n+       p != sorted_exports.end();\n        ++p)\n     {\n       if (!(*p)->is_type())\n \tcontinue;\n       Interface_type* it = (*p)->type_value()->interface_type();\n       if (it != NULL)\n         it->sort_embedded();\n+      this->record_type((*p)->type_value());\n       this->set_type_index((*p)->type_value());\n     }\n-\n   int ret = this->type_index_;\n \n-  // Use a single instance of the traversal class because traversal\n-  // classes keep track of which types they've already seen.  That\n-  // lets us avoid type reference loops.\n-  Find_types_to_prepare find(this, imports);\n-\n-  // Traverse all the exported objects and assign indexes to all types.\n-  for (std::vector<Named_object*>::const_iterator p = exports->begin();\n-       p != exports->end();\n+  // Collect export-referenced, non-builtin types.\n+  std::vector<const Type*> types;\n+  types.reserve(this->impl_->type_refs.size());\n+  for (Type_refs::const_iterator p = this->impl_->type_refs.begin();\n+       p != this->impl_->type_refs.end();\n        ++p)\n     {\n-      Named_object* no = *p;\n-      switch (no->classification())\n-\t{\n-\tcase Named_object::NAMED_OBJECT_CONST:\n-\t  {\n-\t    Type* t = no->const_value()->type();\n-\t    if (t != NULL && !t->is_abstract())\n-\t      Type::traverse(t, &find);\n-\t  }\n-\t  break;\n-\n-\tcase Named_object::NAMED_OBJECT_TYPE:\n-\t  Type::traverse(no->type_value()->real_type(), &find);\n-\t  find.traverse_named_type(no->type_value());\n-\t  break;\n-\n-\tcase Named_object::NAMED_OBJECT_VAR:\n-\t  Type::traverse(no->var_value()->type(), &find);\n-\t  break;\n-\n-\tcase Named_object::NAMED_OBJECT_FUNC:\n-\t  {\n-\t    Function* fn = no->func_value();\n-\t    find.traverse_function(fn->type());\n-\t    if (fn->export_for_inlining())\n-\t      fn->block()->traverse(&find);\n-\t  }\n-\t  break;\n-\n-\tcase Named_object::NAMED_OBJECT_FUNC_DECLARATION:\n-\t  find.traverse_function(no->func_declaration_value()->type());\n-\t  break;\n-\n-\tdefault:\n-\t  // We shouldn't see anything else.  If we do we'll give an\n-\t  // error later when we try to actually export it.\n-\t  break;\n-\t}\n+      const Type* t = p->first;\n+      if (p->second != 0)\n+        continue;\n+      types.push_back(t);\n     }\n \n-  return ret;\n-}\n-\n-// Give a type an index if it doesn't already have one.  Return true\n-// if we set the type index, false if it was already known.\n-\n-bool\n-Export::set_type_index(Type* type)\n-{\n-  type = type->forwarded();\n-\n-  std::pair<Type_refs::iterator, bool> ins =\n-    this->impl_->type_refs.insert(std::make_pair(type, 0));\n-  if (!ins.second)\n-    {\n-      // We've already seen this type.\n-      return false;\n-    }\n+  // Sort the types.\n+  std::sort(types.begin(), types.end(), Sort_types());\n \n-  int index = this->type_index_;\n-  ++this->type_index_;\n-  ins.first->second = index;\n+  // Assign numbers to the sorted list.\n+  for (std::vector<const Type *>::const_iterator p = types.begin();\n+       p != types.end();\n+       ++p)\n+    this->set_type_index((*p));\n \n-  return true;\n+  return ret;\n }\n \n // Sort packages."}, {"sha": "1af386c17558eeadbaefeb0582c05bd8aa67b3b3", "filename": "gcc/go/gofrontend/export.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c/gcc%2Fgo%2Fgofrontend%2Fexport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c/gcc%2Fgo%2Fgofrontend%2Fexport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.h?ref=61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c", "patch": "@@ -160,9 +160,15 @@ class Export : public String_dump\n \t\t const Import_init_set& imported_init_fns,\n \t\t const Bindings* bindings);\n \n-  // Set the index of a type.\n+  // Record a type that is mentioned in export data. Return value is\n+  // TRUE for newly visited types, FALSE for types that have been seen\n+  // previously.\n   bool\n-  set_type_index(Type*);\n+  record_type(Type*);\n+\n+  // Assign type indices to types mentioned in export data.\n+  int\n+  assign_type_indices(const std::vector<Named_object*>& sorted_exports);\n \n   // Write a string to the export stream.\n   void\n@@ -213,11 +219,6 @@ class Export : public String_dump\n   Export(const Export&);\n   Export& operator=(const Export&);\n \n-  // Prepare types for exporting.\n-  int\n-  prepare_types(const std::vector<Named_object*>* exports,\n-\t\tUnordered_set(const Package*)* imports);\n-\n   // Write out all known packages.\n   void\n   write_packages(const std::map<std::string, Package*>& packages);\n@@ -258,6 +259,10 @@ class Export : public String_dump\n   int\n   type_index(const Type*);\n \n+  // Set the index of a type.\n+  void\n+  set_type_index(const Type*);\n+\n   // The stream to which we are writing data.\n   Stream* stream_;\n   // Index number of next type."}, {"sha": "84b6e8e37d0ba94a96b5d9983c0dd154da8e36d7", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c", "patch": "@@ -914,7 +914,7 @@ class Gogo\n \n   // Return the name for a type descriptor symbol.\n   std::string\n-  type_descriptor_name(Type*, Named_type*);\n+  type_descriptor_name(const Type*, Named_type*);\n \n   // Return the name of the type descriptor list symbol of a package.\n   std::string"}, {"sha": "c622067c2208d07430a1b118e6d97a6d0cbf7d06", "filename": "gcc/go/gofrontend/names.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fnames.cc?ref=61a02d1e97aa9b2cb3c4e3e5c823d3a8a4c5834c", "patch": "@@ -936,7 +936,7 @@ Named_type::append_mangled_type_name(Gogo* gogo, bool use_alias,\n // it is the name to use.\n \n std::string\n-Gogo::type_descriptor_name(Type* type, Named_type* nt)\n+Gogo::type_descriptor_name(const Type* type, Named_type* nt)\n {\n   // The type descriptor symbol for the unsafe.Pointer type is defined\n   // in libgo/runtime/go-unsafe-pointer.c, so just use a reference to"}]}