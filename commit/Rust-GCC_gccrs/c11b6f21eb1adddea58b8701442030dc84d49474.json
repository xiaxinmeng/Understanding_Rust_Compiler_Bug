{"sha": "c11b6f21eb1adddea58b8701442030dc84d49474", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzExYjZmMjFlYjFhZGRkZWE1OGI4NzAxNDQyMDMwZGM4NGQ0OTQ3NA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-09-12T19:19:15Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-09-12T19:19:15Z"}, "message": "merging\n\nFrom-SVN: r12700", "tree": {"sha": "854ebb3a1fb20cc46461f3e263d67c11b338ecc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/854ebb3a1fb20cc46461f3e263d67c11b338ecc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c11b6f21eb1adddea58b8701442030dc84d49474", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c11b6f21eb1adddea58b8701442030dc84d49474", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c11b6f21eb1adddea58b8701442030dc84d49474", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c11b6f21eb1adddea58b8701442030dc84d49474/comments", "author": null, "committer": null, "parents": [{"sha": "55df28b8f230fa1add6b88c480832717ea6e8199", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55df28b8f230fa1add6b88c480832717ea6e8199", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55df28b8f230fa1add6b88c480832717ea6e8199"}], "stats": {"total": 2055, "additions": 1177, "deletions": 878}, "files": [{"sha": "729132ed21ce4c360e1a4cc6d77e29d2287b9be0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 234, "deletions": 4, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -1,3 +1,52 @@\n+Wed Sep 11 22:38:13 1996  Gerald Baumgartner  <gb@cs.purdue.edu>\n+\n+\t* call.c (build_method_call): When calling a signature\n+\tdefault implementation, as in other cases, let instance_ptr simply\n+\tbe instance.\n+\n+Wed Sep 11 22:14:44 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* parse.y (simple_stmt): Cleanup and use do_poplevel ().\n+\n+Wed Sep 11 22:10:48 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_start_catch_block): Add a pushlevel so that -g\n+ \tworks on hppa and SPARC.\n+\n+Wed Sep 11 10:18:06 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* typeck.c (build_indirect_ref): Catch PTR being an error_mark_node.\n+\n+Mon Sep  9 19:51:14 1996  Gerald Baumgartner  <gb@cs.purdue.edu>\n+\n+\t* call.c (build_over_call): Check first whether DECL_CONTEXT exists\n+\tbefore testing whether it's a signature.\n+\n+Sun Sep  8 16:06:57 1996  Gerald Baumgartner  <gb@cs.purdue.edu>\n+\n+\t* call.c (build_new_method_call): Don't complain about signature\n+\tpointers and references not being an aggr type.\n+\t(build_this): If a signature pointer or reference was passed in,\n+\tjust return it.\n+\t(build_new_method_call): If instance is a signature pointer, set\n+\tbasetype to the signature type of instance.\n+\t* sig.c (build_signature_method_call): Deleted basetype and\n+\tinstance parameters, they can be found as the DECL_CONTEXT of\n+\tfunction and as the first argument passed in.\n+\t* cp-tree.h: Changed declaration of build_signature_method_call.\n+\t* call.c (build_method_call): Deleted first two arguments in call\n+\tof build_signature_method_call.\n+\t(build_over_call): Added call to build_signature_method_call.\n+\n+Thu Sep  5 16:51:28 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (build_c_cast): Don't tack a non_lvalue_expr onto a\n+ \ttarget_expr.\n+\n+Thu Sep  5 10:05:38 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* cvt.c (convert_to_reference): Use %#T, not %#D, for error.\n+\n Wed Sep  4 17:16:09 1996  Bob Manson  <manson@charmed.cygnus.com>\n \n \t* except.c (expand_start_try_stmts): Move to except.c in the backend.\n@@ -7,6 +56,191 @@ Wed Sep  4 17:16:09 1996  Bob Manson  <manson@charmed.cygnus.com>\n \tof directly manipulating lists.\n \t(emit_base_init): Ditto.\n \n+Wed Sep  4 12:14:36 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_exception_blocks): Always make sure USE and\n+ \tCLOBBER insns that came at the end still do, the backend relies\n+ \tupon this.\n+\n+Wed Sep  4 07:44:48 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (build_over_call): We can only use a TARGET_EXPR of the\n+ \tright type.\n+\n+Tue Sep  3 19:26:05 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (convert_to_reference): Revert last change, don't complain\n+ \tabout temp without target decl.\n+\n+Tue Sep  3 10:22:56 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (grokdeclarator): Don't core dump when void() is given.\n+\n+Tue Sep  3 02:38:56 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (copy_args_p): Don't crash.\n+\n+Fri Aug 30 14:26:57 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* pt.c (tsubst): And support template args inside the exception\n+ \tspecification.\n+\n+\t* pt.c (tsubst): Add support for exception specifications in\n+ \ttemplate functions.\n+\n+Fri Aug 30 10:01:55 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cp-tree.def (DECL_STMT): Eliminate the throw spec field, only 3\n+ \tfields now.\n+\t* cp-tree.h (start_decl): Eliminate the throw spec parameter.\n+\t(start_function): Likewise.\n+\t(start_method): Likewise.\n+\t(grokfield): Likewise.\n+\t(make_call_declarator): Add throw spec parameter.\n+\t(set_quals_and_spec): Add routine.\n+\t* lex.c (set_quals_and_spec): Likewise.\n+\t* decl.h (grokdeclarator): Eliminate the throw spec parameter.\n+\t* decl.c (shadow_tag): Eliminate the throw spec parameter to\n+ \tgrokdeclarator.\n+\t(groktypename): Likewise.\n+\t(start_decl): Eliminate the throw spec parameter.  Eliminate the\n+ \tthrow spec parameter to grokdeclarator.  Eliminate the throw spec\n+ \tfield in DECL_STMT.\n+\t(cp_finish_decl): Eliminate the throw spec field in DECL_STMT.\n+\t(grokfndecl): Remove useless set of raises.\n+\t(grokdeclarator): Eliminate the throw spec parameter.  Eliminate\n+ \tthe throw spec parameter to start_decl.  Pull the throw spec out\n+ \tof the call declarator.\n+\t(grokparms): Eliminate the throw spec parameter to grokdeclarator.\n+\t(start_function): Eliminate the throw spec parameter.  Eliminate\n+ \tthe throw spec parameter to grokdeclarator.\n+\t(start_method): Likewise.\n+\t* decl2.c (grokfield): Likewise.\n+\t(grokbitfield): Eliminate the throw spec parameter to grokdeclarator.\n+\t(grokoptypename): Likewise.\n+\t(finish_file): Eliminate the throw spec parameter to\n+ \tstart_function.  Add throw spec to make_call_declarator.\n+\t* except.c (init_exception_processing): Add throw spec to\n+ \tmake_call_declarator.  Eliminate the throw spec parameter to\n+ \tstart_decl.\n+\t(expand_start_catch_block): Eliminate the throw spec parameter to\n+ \tgrokdeclarator.\n+\t(expand_builtin_throw): Add throw spec to make_call_declarator.\n+\tEliminate the throw spec parameter to start_function.\n+\t(start_anon_func): Likewise.\n+\t* lex.c (make_call_declarator): Add throw spec parameter.\n+\t(set_quals_and_spec): New routine.\n+\t(cons_up_default_function): Add throw spec to make_call_declarator.\n+\tEliminate the throw spec parameter to grokfield.\n+\t* method.c (synthesize_method): Eliminate the throw spec parameter\n+ \tto start_function.\n+\t* pt.c (process_template_parm): Eliminate the throw spec parameter\n+ \tto grokdeclarator.\n+\t(tsubst): Add throw spec to make_call_declarator.\n+\t(tsubst_expr): Eliminate the throw spec parameter to start_decl.\n+\t(do_function_instantiation): Eliminate the throw spec parameter to\n+ \tgrokdeclarator.  Eliminate the throw spec parameter to\n+ \tstart_function.\n+\t* rtti.c (synthesize_tinfo_fn): Eliminate the throw spec parameter\n+ \tto start_function.\n+\t* parse.y (datadef): Remove non-winning optimization.\n+\t(decl): Likewise.\n+\t(fndef): Remove ambiguous error productions uncovered by grammer\n+ \tfixing.\n+\t(constructor_declarator): Add exception_specification_opt here.\n+\t(component_constructor_declarator): Likewise.\n+\t(direct_after_type_declarator): Likewise.\n+\t(complex_direct_notype_declarator): Likewise.\n+\t(direct_abstract_declarator): Likewise.\n+\t(fn.def1): Remove exception_specification_opt.\n+\t(fn.def2): Likewise.\n+\t(condition): Likewise.\n+\t(initdcl0): Likewise.\n+\t(initdcl): Likewise.\n+\t(notype_initdcl0): Likewise.\n+\t(nomods_initdcl0): Likewise.\n+\t(component_decl_1): Likewise.\n+\t(component_declarator): Likewise.\n+\t(after_type_component_declarator0): Likewise.\n+\t(after_type_component_declarator): Likewise.\n+\t(notype_component_declarator): Likewise.\n+\n+Wed Aug 28 01:40:30 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (build_over_call): Also use an INIT_EXPR when\n+ \tinitializing anything from an rvalue.\n+\n+\t* call.c (build_over_call): Call stabilize_reference when building\n+ \tan INIT_EXPR instead of calling the copy ctor.\n+\n+\t* call.c (joust): Extend the previous change to all comparisons.\n+\n+\t* decl2.c, method.c, lex.c: Use MAKE_DECL_ONE_ONLY and \n+\tNO_LINKAGE_HEURISTICS.\n+\n+\t* decl2.c (finish_file): Emit any statics that weren't already.\n+\n+\t* typeck.c (build_static_cast): Implement.\n+\t* tree.c (build_cplus_new): Handle getting a TARGET_EXPR.\n+\t* decl.c (grokparms): Use can_convert_arg instead of\n+ \timplicit_conversion directly.\n+\t(copy_args_p): New fn.\n+\t* cvt.c (convert_to_reference): Don't complain about temp with\n+ \tstatic_cast.\n+\t(build_up_reference): Handle TARGET_EXPRs.\n+\t* call.c (build_over_call): Elide unnecessary temps.\n+\t(can_convert*): Use new overloading code.\n+\n+Tue Aug 27 13:12:21 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c: Move TYPE_PTR*_MACROS ...\n+\t* cp-tree.h: To here.\n+\t* typeck.c (build_reinterpret_cast): Implement.\n+\n+\t* call.c (add_builtin_candidate): Use TYPE_PTROB_P instead of\n+ \tptr_complete_ob.\n+\t(joust): If we're comparing a function to a builtin and the worst\n+\tconversion for the builtin is worse than the worst conversion for the\n+\tfunction, take the function.\n+\n+\t* typeck.c (build_const_cast): Implement.\n+\t(comp_ptr_ttypes_const): Like comp_ptr_ttypes, for const_cast.\n+\t(comp_ptr_ttypes_reinterpret): Like cpt, for reinterpret_cast.\n+\n+Tue Aug 27 13:14:58 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* rtti.c (build_dynamic_cast): Don't try to dereference exprtype\n+ \ttoo early. Make sure we explode if exprtype turns out to be a\n+ \tNULL_TREE when it shouldn't be.\n+\n+Tue Aug 27 10:56:21 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cp-tree.h: New routine make_call_declarator.\n+\t* lex.c (make_call_declarator): Define it.\n+\t* except.c (init_exception_processing): Use it.\n+\t(expand_builtin_throw): Likewise.\n+\t(start_anon_func): Likewise.\n+\t* decl2.c (finish_file): Likewise.\n+\t* lex.c (cons_up_default_function): Likewise.\n+\t* parse.y: Likewise.\n+\t* pt.c (tsubst): Likewise.\n+\t\n+Mon Aug 26 17:40:03 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl2.c (groktypefield): Remove unused code.\n+\n+Mon Aug 26 17:00:33 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* gxx.gperf: Change TYPE_QUAL into CV_QUALIFIER.\n+\t* parse.y: Likewise.  Change maybe_type_qual into maybe_cv_qualifier.\n+\tChange type_quals into cv_qualifiers.  Change nonempty_type_quals into\n+\tnonempty_cv_qualifiers.\n+\t* hash.h: Rebuild.\n+\t\n+\t* lex.c (make_pointer_declarator): Change type_quals into\n+ \tcv_qualifiers.\n+\t(make_reference_declarator): Likewise.\n+\t\n Thu Aug 22 01:09:22 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (start_function): Only check interface_* for templates\n@@ -122,10 +356,6 @@ Tue Aug 13 12:16:10 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \t(import_export_decl): Use it.\n \t* method.c (make_thunk): Use it.\n \n-Sat Aug 17 15:23:39 1996  Geoffrey Noer  <noer@cygnus.com>\n-\n-\t* g++.c: Update test for win32 (&& ! cygwin32).\n-\n Mon Aug 12 00:09:18 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (end_template_decl): If we don't actually have parms, return."}, {"sha": "06580beccc10191ed7783ff355bd1f0dbbac1667", "filename": "gcc/cp/call.c", "status": "modified", "additions": 151, "deletions": 54, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -668,24 +668,6 @@ user_harshness (type, parmtype)\n   return -1;\n }\n \n-int\n-can_convert (to, from)\n-     tree to, from;\n-{\n-  struct harshness_code h;\n-  h = convert_harshness (to, from, NULL_TREE);\n-  return (h.code < USER_CODE) && (h.distance >= 0);\n-}\n-\n-int\n-can_convert_arg (to, from, arg)\n-     tree to, from, arg;\n-{\n-  struct harshness_code h;\n-  h = convert_harshness (to, from, arg);\n-  return (h.code < USER_CODE) && (h.distance >= 0);\n-}\n-\n #ifdef DEBUG_MATCHING\n static char *\n print_harshness (h)\n@@ -1865,8 +1847,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  && TYPE_IDENTIFIER (basetype) != name)\n \t{\n \t  basetype = SIGNATURE_TYPE (basetype);\n-\t  instance_ptr = build_optr_ref (instance);\n-\t  instance_ptr = convert (build_pointer_type (basetype), instance_ptr);\n+\t  instance_ptr = instance;\n \t  basetype_path = TYPE_BINFO (basetype);\n \t}\n       else\n@@ -2462,7 +2443,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t    basetype, save_name);\n \t  return error_mark_node;\n \t}\n-      return build_signature_method_call (basetype, instance, function, parms);\n+      return build_signature_method_call (function, parms);\n     }\n \n   function = DECL_MAIN_VARIANT (function);\n@@ -3461,27 +3442,6 @@ add_conv_candidate (candidates, fn, obj, arglist)\n   return cand;\n }\n \n-int\n-ptr_complete_ob (t)\n-     tree t;\n-{\n-  return (TREE_CODE (t) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (t)) != OFFSET_TYPE\n-\t  && TREE_CODE (TREE_TYPE (t)) != FUNCTION_TYPE\n-\t  && TREE_CODE (TREE_TYPE (t)) != VOID_TYPE\n-\t  && TYPE_SIZE (complete_type (TREE_TYPE (t))) != NULL_TREE);\n-}\n-\n-#define TYPE_PTRMEM_P(NODE)\t\t\t\t\t\\\n-  (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\t\\\n-   && TREE_CODE (TREE_TYPE (NODE)) == OFFSET_TYPE)\n-#define TYPE_PTR_P(NODE)\t\t\t\t\\\n-  (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\\\n-   && TREE_CODE (TREE_TYPE (NODE)) != OFFSET_TYPE)\n-#define TYPE_PTROB_P(NODE)\t\t\t\t\t\t\\\n-  (TYPE_PTR_P (NODE) && TREE_CODE (TREE_TYPE (NODE)) != FUNCTION_TYPE\t\\\n-   && TREE_CODE (TREE_TYPE (NODE)) != VOID_TYPE)\n-\n static struct z_candidate *\n build_builtin_candidate (candidates, fnname, type1, type2,\n \t\t\t args, argtypes, flags)\n@@ -3598,7 +3558,7 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n     case POSTINCREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n       if ((ARITHMETIC_TYPE_P (type1) && TREE_CODE (type1) != ENUMERAL_TYPE)\n-\t  || ptr_complete_ob (type1))\n+\t  || TYPE_PTROB_P (type1))\n \t{\n \t  type1 = build_reference_type (type1);\n \t  break;\n@@ -3616,7 +3576,7 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n \n     case INDIRECT_REF:\n       if (TREE_CODE (type1) == POINTER_TYPE\n-\t  && (ptr_complete_ob (type1)\n+\t  && (TYPE_PTROB_P (type1)\n \t      || TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE))\n \tbreak;\n       return candidates;\n@@ -3713,9 +3673,9 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n \t     bool    operator!=(T, T);  */\n \n     case MINUS_EXPR:\n-      if (ptr_complete_ob (type1) && ptr_complete_ob (type2))\n+      if (TYPE_PTROB_P (type1) && TYPE_PTROB_P (type2))\n \tbreak;\n-      if (ptr_complete_ob (type1) && INTEGRAL_TYPE_P (type2))\n+      if (TYPE_PTROB_P (type1) && INTEGRAL_TYPE_P (type2))\n \t{\n \t  type2 = ptrdiff_type_node;\n \t  break;\n@@ -3768,12 +3728,12 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n       if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n \tbreak;\n     case ARRAY_REF:\n-      if (INTEGRAL_TYPE_P (type1) && ptr_complete_ob (type2))\n+      if (INTEGRAL_TYPE_P (type1) && TYPE_PTROB_P (type2))\n \t{\n \t  type1 = ptrdiff_type_node;\n \t  break;\n \t}\n-      if (ptr_complete_ob (type1) && INTEGRAL_TYPE_P (type2))\n+      if (TYPE_PTROB_P (type1) && INTEGRAL_TYPE_P (type2))\n \t{\n \t  type2 = ptrdiff_type_node;\n \t  break;\n@@ -3842,7 +3802,7 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n \t{\n \tcase PLUS_EXPR:\n \tcase MINUS_EXPR:\n-\t  if (ptr_complete_ob (type1) && INTEGRAL_TYPE_P (type2))\n+\t  if (TYPE_PTROB_P (type1) && INTEGRAL_TYPE_P (type2))\n \t    {\n \t      type2 = ptrdiff_type_node;\n \t      break;\n@@ -4164,7 +4124,11 @@ build_this (obj)\n      tree obj;\n {\n   /* Fix this to work on non-lvalues.  */\n-  return build_unary_op (ADDR_EXPR, obj, 0);\n+  if (IS_SIGNATURE_POINTER (TREE_TYPE (obj))\n+      || IS_SIGNATURE_REFERENCE (TREE_TYPE (obj)))\n+    return obj;\n+  else\n+    return build_unary_op (ADDR_EXPR, obj, 0);\n }\n \n static void\n@@ -5096,6 +5060,67 @@ build_over_call (fn, convs, args, flags)\n \n   converted_args = nreverse (converted_args);\n \n+  /* Avoid actually calling copy constructors and copy assignment operators,\n+     if possible.  */\n+  if (DECL_CONSTRUCTOR_P (fn)\n+      && TREE_VEC_LENGTH (convs) == 1\n+      && copy_args_p (fn))\n+    {\n+      tree targ = NULL_TREE;\n+      arg = TREE_VALUE (TREE_CHAIN (converted_args));\n+\n+      /* Pull out the real argument, disregarding const-correctness.  */\n+      if (TREE_CODE (arg) == ADDR_EXPR)\n+\t{\n+\t  targ = TREE_OPERAND (arg, 0);\n+\t  if (! comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (arg))),\n+\t\t\t   TYPE_MAIN_VARIANT (TREE_TYPE (targ)), 1))\n+\t    targ = NULL_TREE;\n+\t}\n+\n+      if (targ)\n+\targ = targ;\n+      else\n+\targ = build_indirect_ref (arg, 0);\n+\n+      /* If we're creating a temp and we already have one, don't create a\n+         new one.  If we're not creating a temp but we get one, use\n+         INIT_EXPR to collapse the temp into our target.  Otherwise, if the\n+         ctor is trivial, do a bitwise copy with a simple TARGET_EXPR for a\n+         temp or an INIT_EXPR otherwise.  */\n+      if (integer_zerop (TREE_VALUE (args)))\n+\t{\n+\t  if (! real_lvalue_p (arg))\n+\t    return arg;\n+\t  else if (TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn)))\n+\t    {\n+\t      val = build (VAR_DECL, DECL_CONTEXT (fn));\n+\t      layout_decl (val, 0);\n+\t      return build (TARGET_EXPR, DECL_CONTEXT (fn), val, arg, 0, 0);\n+\t    }\n+\t}\n+      else if (! real_lvalue_p (arg)\n+\t       || TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn)))\n+\t{\n+\t  tree to = stabilize_reference\n+\t    (build_indirect_ref (TREE_VALUE (args), 0));\n+\t  val = build (INIT_EXPR, DECL_CONTEXT (fn), to, arg);\n+\t  TREE_SIDE_EFFECTS (val) = 1;\n+\t  return build_unary_op (ADDR_EXPR, val, 0);\n+\t}\n+    }\n+  else if (DECL_NAME (fn) == ansi_opname[MODIFY_EXPR]\n+\t   && copy_args_p (fn)\n+\t   && TYPE_HAS_TRIVIAL_ASSIGN_REF (DECL_CONTEXT (fn)))\n+    {\n+      tree to = stabilize_reference\n+\t(build_indirect_ref (TREE_VALUE (converted_args), 0));\n+      arg = build_indirect_ref (TREE_VALUE (TREE_CHAIN (converted_args)), 0);\n+      val = build (MODIFY_EXPR, TREE_TYPE (to), to, arg);\n+      TREE_SIDE_EFFECTS (val) = 1;\n+      return val;\n+    }\n+\n   mark_used (fn);\n \n   if (pedantic && DECL_THIS_INLINE (fn) && ! DECL_ARTIFICIAL (fn)\n@@ -5104,7 +5129,9 @@ build_over_call (fn, convs, args, flags)\n \t    && TREE_LANG_FLAG_0 (DECL_TEMPLATE_INFO (fn))))\n     cp_warning (\"inline function `%#D' called before definition\", fn);\n \n-  if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0)\n+  if (DECL_CONTEXT (fn) && IS_SIGNATURE (DECL_CONTEXT (fn)))\n+    return build_signature_method_call (fn, converted_args);\n+  else if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0)\n     {\n       tree t, *p = &TREE_VALUE (converted_args);\n       tree binfo = get_binfo\n@@ -5153,14 +5180,25 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n       basetype = TREE_TYPE (instance);\n \n       /* XXX this should be handled before we get here.  */\n-      if (! IS_AGGR_TYPE (basetype))\n+      if (! IS_AGGR_TYPE (basetype)\n+\t  && ! (TYPE_LANG_SPECIFIC (basetype)\n+\t\t&& (IS_SIGNATURE_POINTER (basetype)\n+\t\t    || IS_SIGNATURE_REFERENCE (basetype))))\n \t{\n \t  if ((flags & LOOKUP_COMPLAIN) && basetype != error_mark_node)\n \t    cp_error (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n \t\t      name, instance, basetype);\n \n \t  return error_mark_node;\n \t}\n+\n+      /* If `instance' is a signature pointer/reference and `name' is\n+\t not a constructor, we are calling a signature member function.\n+\t In that case set the `basetype' to the signature type.  */\n+      if ((IS_SIGNATURE_POINTER (basetype)\n+\t   || IS_SIGNATURE_REFERENCE (basetype))\n+\t  && TYPE_IDENTIFIER (basetype) != name)\n+\tbasetype = SIGNATURE_TYPE (basetype);\n     }\n \n   if (basetype_path == NULL_TREE)\n@@ -5587,7 +5625,10 @@ joust (cand1, cand2)\n       if (comp != 0)\n \t{\n \t  if (winner && comp != winner)\n-\t    return 0;\n+\t    {\n+\t      winner = 0;\n+\t      goto tweak;\n+\t    }\n \t  winner = comp;\n \t}\n     }\n@@ -5621,7 +5662,7 @@ joust (cand1, cand2)\n   if (! winner && cand1->fn == cand2->fn\n       && TREE_CODE (cand1->fn) == IDENTIFIER_NODE)\n     {\n-      for (i = 0; i < TREE_VEC_LENGTH (cand1->convs); ++i)\n+      for (i = 0; i < len; ++i)\n \tif (! comptypes (TREE_TYPE (TREE_VEC_ELT (cand1->convs, i)),\n \t\t\t TREE_TYPE (TREE_VEC_ELT (cand2->convs, i)), 1))\n \t  break;\n@@ -5646,6 +5687,28 @@ joust (cand1, cand2)\n \t}\n     }\n \n+tweak:\n+\n+  /* Extension: If the worst conversion for one candidate is worse than the\n+     worst conversion for the other, take the first.  */\n+  if (! winner && ! pedantic)\n+    {\n+      int rank1 = IDENTITY_RANK, rank2 = IDENTITY_RANK;\n+\n+      for (i = 0; i < len; ++i)\n+\t{\n+\t  if (ICS_RANK (TREE_VEC_ELT (cand1->convs, i+off1)) > rank1)\n+\t    rank1 = ICS_RANK (TREE_VEC_ELT (cand1->convs, i+off1));\n+\t  if (ICS_RANK (TREE_VEC_ELT (cand2->convs, i+off2)) > rank2)\n+\t    rank2 = ICS_RANK (TREE_VEC_ELT (cand2->convs, i+off2));\n+\t}\n+\n+      if (rank1 < rank2)\n+\treturn 1;\n+      if (rank1 > rank2)\n+\treturn -1;\n+    }\n+\n   return winner;\n }\n \n@@ -5698,3 +5761,37 @@ tourney (candidates)\n \n   return champ;\n }\n+\n+int\n+can_convert (to, from)\n+     tree to, from;\n+{\n+  if (flag_ansi_overloading)\n+    {\n+      tree t = implicit_conversion (to, from, NULL_TREE, LOOKUP_NORMAL);\n+      return (t && ! ICS_BAD_FLAG (t));\n+    }\n+  else\n+    {\n+      struct harshness_code h;\n+      h = convert_harshness (to, from, NULL_TREE);\n+      return (h.code < USER_CODE) && (h.distance >= 0);\n+    }\n+}\n+\n+int\n+can_convert_arg (to, from, arg)\n+     tree to, from, arg;\n+{\n+  if (flag_ansi_overloading)\n+    {\n+      tree t = implicit_conversion (to, from, arg, LOOKUP_NORMAL);\n+      return (t && ! ICS_BAD_FLAG (t));\n+    }\n+  else\n+    {\n+      struct harshness_code h;\n+      h = convert_harshness (to, from, arg);\n+      return (h.code < USER_CODE) && (h.distance >= 0);\n+    }\n+}"}, {"sha": "de30bda436b74a206e6984c9766e7512e5efd02e", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -123,7 +123,7 @@ DEFTREECODE (DOTSTAR_EXPR, \"dotstar_expr\", \"e\", 2)\n \n DEFTREECODE (EXPR_STMT, \"expr_stmt\", \"e\", 1)\n DEFTREECODE (COMPOUND_STMT, \"compound_stmt\", \"e\", 1)\n-DEFTREECODE (DECL_STMT, \"decl_stmt\", \"e\", 4)\n+DEFTREECODE (DECL_STMT, \"decl_stmt\", \"e\", 3)\n DEFTREECODE (IF_STMT, \"if_stmt\", \"e\", 3)\n DEFTREECODE (FOR_STMT, \"for_stmt\", \"e\", 4)\n DEFTREECODE (WHILE_STMT, \"while_stmt\", \"e\", 2)"}, {"sha": "12552ec31800ab820c3c5beb5d5ab7ebfbead539", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -1265,6 +1265,21 @@ extern int flag_new_for_scope;\n #define TYPE_HAS_TRIVIAL_ASSIGN_REF(NODE) \\\n   (TYPE_HAS_ASSIGN_REF (NODE) && ! TYPE_HAS_COMPLEX_ASSIGN_REF (NODE))\n \n+#define TYPE_PTRMEM_P(NODE)\t\t\t\t\t\\\n+  (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) == OFFSET_TYPE)\n+#define TYPE_PTR_P(NODE)\t\t\t\t\\\n+  (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) != OFFSET_TYPE)\n+#define TYPE_PTROB_P(NODE)\t\t\t\t\t\t\\\n+  (TYPE_PTR_P (NODE) && TREE_CODE (TREE_TYPE (NODE)) != FUNCTION_TYPE\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) != VOID_TYPE)\n+#define TYPE_PTROBV_P(NODE)\t\t\t\t\t\t\\\n+  (TYPE_PTR_P (NODE) && TREE_CODE (TREE_TYPE (NODE)) != FUNCTION_TYPE)\n+#define TYPE_PTRFN_P(NODE)\t\t\t\t\\\n+  (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE)\n+\n /* Nonzero for _TYPE node means that this type is a pointer to member\n    function type.  */\n #define TYPE_PTRMEMFUNC_P(NODE) (TREE_CODE(NODE) == RECORD_TYPE && TYPE_LANG_SPECIFIC(NODE)->type_flags.ptrmemfunc_flag)\n@@ -2047,7 +2062,7 @@ extern int init_type_desc\t\t\tPROTO((void));\n extern void shadow_tag\t\t\t\tPROTO((tree));\n extern int grok_ctor_properties\t\t\tPROTO((tree, tree));\n extern tree groktypename\t\t\tPROTO((tree));\n-extern tree start_decl\t\t\t\tPROTO((tree, tree, int, tree));\n+extern tree start_decl\t\t\t\tPROTO((tree, tree, int));\n extern void cp_finish_decl\t\t\tPROTO((tree, tree, tree, int, int));\n extern void expand_static_init\t\t\tPROTO((tree, tree));\n extern int complete_array_type\t\t\tPROTO((tree, tree, int));\n@@ -2061,13 +2076,13 @@ extern tree start_enum\t\t\t\tPROTO((tree));\n extern tree finish_enum\t\t\t\tPROTO((tree, tree));\n extern tree build_enumerator\t\t\tPROTO((tree, tree));\n extern tree grok_enum_decls\t\t\tPROTO((tree, tree));\n-extern int start_function\t\t\tPROTO((tree, tree, tree, tree, int));\n+extern int start_function\t\t\tPROTO((tree, tree, tree, int));\n extern void store_parm_decls\t\t\tPROTO((void));\n extern void expand_start_early_try_stmts\tPROTO((void));\n extern void store_in_parms\t\t\tPROTO((struct rtx_def *));\n extern void store_return_init\t\t\tPROTO((tree, tree));\n extern void finish_function\t\t\tPROTO((int, int, int));\n-extern tree start_method\t\t\tPROTO((tree, tree, tree));\n+extern tree start_method\t\t\tPROTO((tree, tree));\n extern tree finish_method\t\t\tPROTO((tree));\n extern void hack_incomplete_structures\t\tPROTO((tree));\n extern tree maybe_build_cleanup\t\t\tPROTO((tree));\n@@ -2092,7 +2107,7 @@ extern tree grok_alignof\t\t\tPROTO((tree));\n extern tree grok_array_decl\t\t\tPROTO((tree, tree));\n extern tree delete_sanity\t\t\tPROTO((tree, tree, int, int));\n extern tree check_classfn\t\t\tPROTO((tree, tree));\n-extern tree grokfield\t\t\t\tPROTO((tree, tree, tree, tree, tree, tree));\n+extern tree grokfield\t\t\t\tPROTO((tree, tree, tree, tree, tree));\n extern tree grokbitfield\t\t\tPROTO((tree, tree, tree));\n extern tree groktypefield\t\t\tPROTO((tree, tree));\n extern tree grokoptypename\t\t\tPROTO((tree, tree));\n@@ -2192,6 +2207,8 @@ extern tree build_vec_delete\t\t\tPROTO((tree, tree, tree, tree, int));\n /* in lex.c */\n extern tree make_pointer_declarator\t\tPROTO((tree, tree));\n extern tree make_reference_declarator\t\tPROTO((tree, tree));\n+extern tree make_call_declarator\t\tPROTO((tree, tree, tree, tree));\n+extern void set_quals_and_spec\t\t\tPROTO((tree, tree, tree));\n extern char *operator_name_string\t\tPROTO((tree));\n extern void lang_init\t\t\t\tPROTO((void));\n extern void lang_finish\t\t\t\tPROTO((void));\n@@ -2345,7 +2362,7 @@ extern tree get_template_base\t\t\tPROTO((tree, tree));\n extern tree build_signature_pointer_type\tPROTO((tree, int, int));\n extern tree build_signature_reference_type\tPROTO((tree, int, int));\n extern tree build_signature_pointer_constructor\tPROTO((tree, tree));\n-extern tree build_signature_method_call\t\tPROTO((tree, tree, tree, tree));\n+extern tree build_signature_method_call\t\tPROTO((tree, tree));\n extern tree build_optr_ref\t\t\tPROTO((tree));\n extern tree build_sptr_ref\t\t\tPROTO((tree));\n extern void append_signature_fields\t\tPROTO((tree));"}, {"sha": "edb5fc310c3af7931bc6ad71b329ab01b579bbf2", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -594,6 +594,11 @@ build_up_reference (type, arg, flags, checkconst)\n       TREE_REFERENCE_EXPR (rval) = 1;\n       return rval;\n \n+    case TARGET_EXPR:\n+      TREE_ADDRESSABLE (targ) = 1;\n+      put_var_into_stack (TREE_OPERAND (targ, 0));\n+      break;\n+\n     default:\n       break;\n     }\n@@ -742,15 +747,14 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t    ttr = cp_build_type_variant (TREE_TYPE (expr), r, v);\n \t  }\n \n-\t  if (! real_lvalue_p (expr) &&\n-\t      (decl == NULL_TREE || ! TYPE_READONLY (ttl)))\n+\t  if (! real_lvalue_p (expr) && ! TYPE_READONLY (ttl))\n \t    {\n \t      if (decl)\n \t\t/* Ensure semantics of [dcl.init.ref] */\n-\t\tcp_pedwarn (\"initialization of non-const `%T' from rvalue `%T'\",\n+\t\tcp_pedwarn (\"initialization of non-const reference `%#T' from rvalue `%T'\",\n \t\t\t    reftype, intype);\n \t      else\n-\t\tcp_pedwarn (\"conversion to `%T' from rvalue `%T'\",\n+\t\tcp_pedwarn (\"conversion to non-const `%T' from rvalue `%T'\",\n \t\t\t    reftype, intype);\n \t    }\n \t  else if (! (convtype & CONV_CONST))"}, {"sha": "ad34c905d43fe5e2981586665099663e7818f5a1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 38, "deletions": 23, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -5700,7 +5700,7 @@ shadow_tag (declspecs)\n       if (TYPE_FIELDS (t))\n \t{\n \t  tree decl = grokdeclarator (NULL_TREE, declspecs, NORMAL, 0,\n-\t\t\t\t      NULL_TREE, NULL_TREE);\n+\t\t\t\t      NULL_TREE);\n \t  finish_anon_union (decl);\n \t}\n     }\n@@ -5739,7 +5739,7 @@ groktypename (typename)\n     return typename;\n   return grokdeclarator (TREE_VALUE (typename),\n \t\t\t TREE_PURPOSE (typename),\n-\t\t\t TYPENAME, 0, NULL_TREE, NULL_TREE);\n+\t\t\t TYPENAME, 0, NULL_TREE);\n }\n \n /* Decode a declarator in an ordinary declaration or data definition.\n@@ -5764,10 +5764,9 @@ int debug_temp_inits = 1;\n void start_decl_1 ();\n \n tree\n-start_decl (declarator, declspecs, initialized, raises)\n+start_decl (declarator, declspecs, initialized)\n      tree declarator, declspecs;\n      int initialized;\n-     tree raises;\n {\n   register tree decl;\n   register tree type, tem;\n@@ -5788,7 +5787,7 @@ start_decl (declarator, declspecs, initialized, raises)\n       used_extern_spec = 1;\n     }\n \n-  decl = grokdeclarator (declarator, declspecs, NORMAL, initialized, raises,\n+  decl = grokdeclarator (declarator, declspecs, NORMAL, initialized,\n \t\t\t NULL_TREE);\n   if (decl == NULL_TREE || decl == void_type_node)\n     return NULL_TREE;\n@@ -5923,7 +5922,7 @@ start_decl (declarator, declspecs, initialized, raises)\n \tDECL_VINDEX (decl)\n \t    = build_min_nt (DECL_STMT, copy_to_permanent (declarator),\n \t\t\t    copy_to_permanent (declspecs),\n-\t\t\t    copy_to_permanent (raises), NULL_TREE);\n+\t\t\t    NULL_TREE);\n     }\n \n \n@@ -6249,7 +6248,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t{\n \t  tree stmt = DECL_VINDEX (decl);\n \t  DECL_VINDEX (decl) = NULL_TREE;\n-\t  TREE_OPERAND (stmt, 3) = copy_to_permanent (init);\n+\t  TREE_OPERAND (stmt, 2) = copy_to_permanent (init);\n \t  add_tree (stmt);\n \t}\n \n@@ -7111,8 +7110,8 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n   if (raises)\n     {\n       type = build_exception_variant (type, raises);\n-      raises = TYPE_RAISES_EXCEPTIONS (type);\n     }\n+\n   decl = build_lang_decl (FUNCTION_DECL, declarator, type);\n   /* propagate volatile out from type to decl */\n   if (TYPE_VOLATILE (type))\n@@ -7447,12 +7446,12 @@ build_ptrmemfunc_type (type)\n enum return_types { return_normal, return_ctor, return_dtor, return_conversion };\n \n tree\n-grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrlist)\n+grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n      tree declspecs;\n      tree declarator;\n      enum decl_context decl_context;\n      int initialized;\n-     tree raises, attrlist;\n+     tree attrlist;\n {\n   RID_BIT_TYPE specbits;\n   int nclasses = 0;\n@@ -7489,6 +7488,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n   tree ctor_return_type = NULL_TREE;\n   enum overload_flags flags = NO_SPECIAL;\n   tree quals = NULL_TREE;\n+  tree raises = NULL_TREE;\n \n   RIDBIT_RESET_ALL (specbits);\n   if (decl_context == FUNCDEF)\n@@ -7579,14 +7579,15 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t\t*next = TREE_OPERAND (decl, 0);\n \t\tinit = TREE_OPERAND (decl, 1);\n \n-\t\tdecl = start_decl (declarator, declspecs, 1, NULL_TREE);\n+\t\tdecl = start_decl (declarator, declspecs, 1);\n \t\tfinish_decl (decl, init, NULL_TREE);\n \t\treturn 0;\n \t      }\n \t    innermost_code = TREE_CODE (decl);\n \t    if (decl_context == FIELD && ctype == NULL_TREE)\n \t      ctype = current_class_type;\n \t    if (ctype\n+\t\t&& TREE_OPERAND (decl, 0)\n \t\t&& (TREE_CODE (TREE_OPERAND (decl, 0)) == TYPE_DECL\n \t\t    && ((DECL_NAME (TREE_OPERAND (decl, 0))\n \t\t\t == constructor_name_full (ctype))\n@@ -8529,6 +8530,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n \t    /* Pick up type qualifiers which should be applied to `this'.  */\n \t    quals = TREE_OPERAND (declarator, 2);\n \n+\t    /* Pick up the exception specifications.  */\n+\t    raises = TREE_TYPE (declarator);\n+\n \t    /* Say it's a definition only for the CALL_EXPR\n \t       closest to the identifier.  */\n \t    funcdecl_p =\n@@ -9776,11 +9780,10 @@ grokparms (first_parm, funcdef_flag)\n \n \t      if (decl != void_type_node)\n \t\t{\n-\t\t  /* @@ May need to fetch out a `raises' here.  */\n \t\t  decl = grokdeclarator (TREE_VALUE (decl),\n \t\t\t\t\t TREE_PURPOSE (decl),\n \t\t\t\t\t PARM, init != NULL_TREE,\n-\t\t\t\t\t NULL_TREE, NULL_TREE);\n+\t\t\t\t\t NULL_TREE);\n \t\t  if (! decl)\n \t\t    continue;\n \t\t  type = TREE_TYPE (decl);\n@@ -9878,7 +9881,7 @@ grokparms (first_parm, funcdef_flag)\n \t\t      else\n \t\t\tinit = require_instantiated_type (type, init, integer_zero_node);\n \t\t      if (! current_template_parms\n-\t\t\t  && ! implicit_conversion (type, TREE_TYPE (init), init, LOOKUP_NORMAL))\n+\t\t\t  && ! can_convert_arg (type, TREE_TYPE (init), init))\n \t\t\tcp_pedwarn (\"invalid type `%T' for default argument to `%#D'\",\n \t\t\t\t    TREE_TYPE (init), decl);\n \t\t    }\n@@ -9933,6 +9936,21 @@ grokparms (first_parm, funcdef_flag)\n   return result;\n }\n \f\n+int\n+copy_args_p (d)\n+     tree d;\n+{\n+  tree t = FUNCTION_ARG_CHAIN (d);\n+  if (t && TREE_CODE (TREE_VALUE (t)) == REFERENCE_TYPE\n+      && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (t)))\n+\t  == DECL_CLASS_CONTEXT (d))\n+      && (TREE_CHAIN (t) == NULL_TREE\n+\t  || TREE_CHAIN (t) == void_list_node\n+\t  || TREE_PURPOSE (TREE_CHAIN (t))))\n+    return 1;\n+  return 0;\n+}\n+\n /* These memoizing functions keep track of special properties which\n    a class may have.  `grok_ctor_properties' notices whether a class\n    has a constructor of the form X(X&), and also complains\n@@ -10880,8 +10898,8 @@ static int function_depth;\n    @@ something we had previously.  */\n \n int\n-start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n-     tree declspecs, declarator, raises, attrs;\n+start_function (declspecs, declarator, attrs, pre_parsed_p)\n+     tree declspecs, declarator, attrs;\n      int pre_parsed_p;\n {\n   tree decl1;\n@@ -10957,8 +10975,6 @@ start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n \t    doing_friend = 1;\n \t}\n \n-      raises = TYPE_RAISES_EXCEPTIONS (fntype);\n-\n       /* In a fcn definition, arg types must be complete.  */\n       require_complete_types_for_parms (DECL_ARGUMENTS (decl1));\n \n@@ -10975,8 +10991,7 @@ start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n     }\n   else\n     {\n-      decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1, raises,\n-\t\t\t      NULL_TREE);\n+      decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1, NULL_TREE);\n       /* If the declarator is not suitable for a function definition,\n \t cause a syntax error.  */\n       if (decl1 == NULL_TREE || TREE_CODE (decl1) != FUNCTION_DECL) return 0;\n@@ -12109,10 +12124,10 @@ finish_function (lineno, call_poplevel, nested)\n    CHANGES TO CODE IN `grokfield'.  */\n \n tree\n-start_method (declspecs, declarator, raises)\n-     tree declarator, declspecs, raises;\n+start_method (declspecs, declarator)\n+     tree declarator, declspecs;\n {\n-  tree fndecl = grokdeclarator (declarator, declspecs, MEMFUNCDEF, 0, raises,\n+  tree fndecl = grokdeclarator (declarator, declspecs, MEMFUNCDEF, 0,\n \t\t\t\tNULL_TREE);\n \n   /* Something too ugly to handle.  */"}, {"sha": "f55dca55ea753a23bc41b618b01a6591578ca1eb", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -31,7 +31,7 @@ enum decl_context\n };\n \n /* We need this in here to get the decl_context definition.  */\n-extern tree grokdeclarator\t\t\tPROTO((tree, tree, enum decl_context, int, tree, tree));\n+extern tree grokdeclarator\t\t\tPROTO((tree, tree, enum decl_context, int, tree));\n \n /* C++: Keep these around to reduce calls to `get_identifier'.\n    Identifiers for `this' in member functions and the auto-delete"}, {"sha": "9c5d14cf4553e4511170324277026df9fc3ffcfb", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 21, "deletions": 210, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -37,10 +37,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"lex.h\"\n #include \"output.h\"\n \n-#ifndef SUPPORTS_ONE_ONLY\n-#define SUPPORTS_ONE_ONLY 0\n-#endif\n-\n extern tree get_file_function_name ();\n extern tree cleanups_this_call;\n static void grok_function_init PROTO((tree, tree));\n@@ -1339,8 +1335,8 @@ check_classfn (ctype, function)\n    CHANGES TO CODE IN `start_method'.  */\n \n tree\n-grokfield (declarator, declspecs, raises, init, asmspec_tree, attrlist)\n-     tree declarator, declspecs, raises, init, asmspec_tree, attrlist;\n+grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n+     tree declarator, declspecs, init, asmspec_tree, attrlist;\n {\n   register tree value;\n   char *asmspec = 0;\n@@ -1376,8 +1372,7 @@ grokfield (declarator, declspecs, raises, init, asmspec_tree, attrlist)\n       && TREE_CHAIN (init) == NULL_TREE)\n     init = NULL_TREE;\n \n-  value = grokdeclarator (declarator, declspecs, FIELD, init != 0,\n-\t\t\t  raises, NULL_TREE);\n+  value = grokdeclarator (declarator, declspecs, FIELD, init != 0, NULL_TREE);\n   if (! value)\n     return value; /* friend or constructor went bad.  */\n \n@@ -1593,7 +1588,7 @@ grokbitfield (declarator, declspecs, width)\n      tree declarator, declspecs, width;\n {\n   register tree value = grokdeclarator (declarator, declspecs, BITFIELD,\n-\t\t\t\t\t0, NULL_TREE, NULL_TREE);\n+\t\t\t\t\t0, NULL_TREE);\n \n   if (! value) return NULL_TREE; /* friends went bad.  */\n \n@@ -1640,194 +1635,11 @@ grokbitfield (declarator, declspecs, width)\n   return value;\n }\n \n-#if 0\n-/* Like GROKFIELD, except that the declarator has been\n-   buried in DECLSPECS.  Find the declarator, and\n-   return something that looks like it came from\n-   GROKFIELD.  */\n-\n-tree\n-groktypefield (declspecs, parmlist)\n-     tree declspecs;\n-     tree parmlist;\n-{\n-  tree spec = declspecs;\n-  tree prev = NULL_TREE;\n-\n-  tree type_id = NULL_TREE;\n-  tree quals = NULL_TREE;\n-  tree lengths = NULL_TREE;\n-  tree decl = NULL_TREE;\n-\n-  while (spec)\n-    {\n-      register tree id = TREE_VALUE (spec);\n-\n-      if (TREE_CODE (spec) != TREE_LIST)\n-\t/* Certain parse errors slip through.  For example,\n-\t   `int class ();' is not caught by the parser. Try\n-\t   weakly to recover here.  */\n-\treturn NULL_TREE;\n-\n-      if (TREE_CODE (id) == TYPE_DECL\n-\t  || (TREE_CODE (id) == IDENTIFIER_NODE && TREE_TYPE (id)))\n-\t{\n-\t  /* We have a constructor/destructor or\n-\t     conversion operator.  Use it.  */\n-\t  if (prev)\n-\t    TREE_CHAIN (prev) = TREE_CHAIN (spec);\n-\t  else\n-\t    declspecs = TREE_CHAIN (spec);\n-\n-\t  type_id = id;\n-\t  goto found;\n-\t}\n-      prev = spec;\n-      spec = TREE_CHAIN (spec);\n-    }\n-\n-  /* Nope, we have a conversion operator to a scalar type or something\n-     else, that includes things like constructor declarations for\n-     templates.  */\n-  spec = declspecs;\n-  while (spec)\n-    {\n-      tree id = TREE_VALUE (spec);\n-\n-      if (TREE_CODE (id) == IDENTIFIER_NODE)\n-\t{\n-\t  if (id == ridpointers[(int)RID_INT]\n-\t      || id == ridpointers[(int)RID_DOUBLE]\n-\t      || id == ridpointers[(int)RID_FLOAT]\n-\t      || id == ridpointers[(int)RID_WCHAR])\n-\t    {\n-\t      if (type_id)\n-\t\terror (\"extra `%s' ignored\",\n-\t\t       IDENTIFIER_POINTER (id));\n-\t      else\n-\t\ttype_id = id;\n-\t    }\n-\t  else if (id == ridpointers[(int)RID_LONG]\n-\t\t   || id == ridpointers[(int)RID_SHORT]\n-\t\t   || id == ridpointers[(int)RID_CHAR])\n-\t    {\n-\t      lengths = tree_cons (NULL_TREE, id, lengths);\n-\t    }\n-\t  else if (id == ridpointers[(int)RID_VOID])\n-\t    {\n-\t      if (type_id)\n-\t\terror (\"spurious `void' type ignored\");\n-\t      else\n-\t\terror (\"conversion to `void' type invalid\");\n-\t    }\n-\t  else if (id == ridpointers[(int)RID_AUTO]\n-\t\t   || id == ridpointers[(int)RID_REGISTER]\n-\t\t   || id == ridpointers[(int)RID_TYPEDEF]\n-\t\t   || id == ridpointers[(int)RID_CONST]\n-\t\t   || id == ridpointers[(int)RID_VOLATILE])\n-\t    {\n-\t      error (\"type specifier `%s' used invalidly\",\n-\t\t     IDENTIFIER_POINTER (id));\n-\t    }\n-\t  else if (id == ridpointers[(int)RID_FRIEND]\n-\t\t   || id == ridpointers[(int)RID_VIRTUAL]\n-\t\t   || id == ridpointers[(int)RID_INLINE]\n-\t\t   || id == ridpointers[(int)RID_UNSIGNED]\n-\t\t   || id == ridpointers[(int)RID_SIGNED]\n-\t\t   || id == ridpointers[(int)RID_STATIC]\n-\t\t   || id == ridpointers[(int)RID_EXTERN])\n-\t    {\n-\t      quals = tree_cons (NULL_TREE, id, quals);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Happens when we have a global typedef\n-\t\t and a class-local member function with\n-\t\t the same name.  */\n-\t      type_id = id;\n-\t      goto found;\n-\t    }\n-\t}\n-      else if (TREE_CODE (id) == RECORD_TYPE)\n-\t{\n-\t  type_id = TYPE_NAME (id);\n-\t  if (TREE_CODE (type_id) == TYPE_DECL)\n-\t    type_id = DECL_NAME (type_id);\n-\t  if (type_id == NULL_TREE)\n-\t    error (\"identifier for aggregate type conversion omitted\");\n-\t}\n-      else if (TREE_CODE_CLASS (TREE_CODE (id)) == 't')\n-\terror (\"`operator' missing on conversion operator or tag missing from type\");\n-      else\n-\tmy_friendly_abort (194);\n-      spec = TREE_CHAIN (spec);\n-    }\n-\n-  if (type_id)\n-    declspecs = chainon (lengths, quals);\n-  else if (lengths)\n-    {\n-      if (TREE_CHAIN (lengths))\n-\terror (\"multiple length specifiers\");\n-      type_id = ridpointers[(int)RID_INT];\n-      declspecs = chainon (lengths, quals);\n-    }\n-  else if (quals)\n-    {\n-      error (\"no type given, defaulting to `operator int ...'\");\n-      type_id = ridpointers[(int)RID_INT];\n-      declspecs = quals;\n-    }\n-  else\n-    return NULL_TREE;\n-\n- found:\n-  decl = grokdeclarator (build_parse_node (CALL_EXPR, type_id, parmlist, NULL_TREE),\n-\t\t\t declspecs, FIELD, 0, NULL_TREE, NULL_TREE);\n-  if (decl == NULL_TREE)\n-    return NULL_TREE;\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_CHAIN (decl) != NULL_TREE)\n-    {\n-      /* Need a fresh node here so that we don't get circularity\n-\t when we link these together.  */\n-      decl = copy_node (decl);\n-    }\n-\n-  if (decl == void_type_node\n-      || (TREE_CODE (decl) == FUNCTION_DECL\n-\t  && TREE_CODE (TREE_TYPE (decl)) != METHOD_TYPE))\n-    /* bunch of friends.  */\n-    return decl;\n-\n-  if (DECL_IN_AGGR_P (decl))\n-    {\n-      cp_error (\"`%D' already defined in the class \", decl);\n-      return void_type_node;\n-    }\n-\n-  cp_finish_decl (decl, NULL_TREE, NULL_TREE, 0, 0);\n-\n-  /* If this declaration is common to another declaration\n-     complain about such redundancy, and return NULL_TREE\n-     so that we don't build a circular list.  */\n-  if (DECL_CHAIN (decl))\n-    {\n-      cp_error (\"function `%D' declared twice in class %T\", decl,\n-\t\t  DECL_CONTEXT (decl));\n-      return NULL_TREE;\n-    }\n-  DECL_IN_AGGR_P (decl) = 1;\n-  return decl;\n-}\n-#endif\n-\n tree\n grokoptypename (declspecs, declarator)\n      tree declspecs, declarator;\n {\n-  tree t = grokdeclarator (declarator, declspecs, TYPENAME, 0,\n-\t\t\t   NULL_TREE, NULL_TREE);\n+  tree t = grokdeclarator (declarator, declspecs, TYPENAME, 0, NULL_TREE);\n   return build_typename_overload (t);\n }\n \n@@ -2486,20 +2298,16 @@ comdat_linkage (decl)\n {\n   TREE_PUBLIC (decl) = 0;\n \n-#ifdef DECL_ONE_ONLY\n-  if (SUPPORTS_ONE_ONLY)\n-    {\n-      DECL_ONE_ONLY (decl) = 1;\n-      TREE_PUBLIC (decl) = 1;\n-    }\n+#ifdef MAKE_DECL_ONE_ONLY\n+  MAKE_DECL_ONE_ONLY (decl);\n+  TREE_PUBLIC (decl) = 1;\n #endif\n \n   if (flag_weak)\n     {\n       DECL_WEAK (decl) = 1;\n       TREE_PUBLIC (decl) = 1;\n     }\n-\n }\n \n /* Set TREE_PUBLIC and/or DECL_EXTERN on the vtable DECL,\n@@ -2585,8 +2393,8 @@ finish_prevtable_vardecl (prev, vars)\n   tree ctype = DECL_CONTEXT (vars);\n   import_export_template (ctype);\n \n+#ifndef NO_LINKAGE_HEURISTICS\n   if (CLASSTYPE_INTERFACE_UNKNOWN (ctype) && TYPE_VIRTUAL_P (ctype)\n-      && ! (SUPPORTS_ONE_ONLY > 1)\n       && ! CLASSTYPE_TEMPLATE_INSTANTIATION (ctype))\n     {\n       tree method;\n@@ -2604,6 +2412,7 @@ finish_prevtable_vardecl (prev, vars)\n \t    }\n \t}\n     }\n+#endif\n \n   import_export_vtable (vars, ctype, 1);\n   return 1;\n@@ -2785,9 +2594,8 @@ import_export_decl (decl)\n \t    {\n \t      /* Statically initialized vars are weak or comdat, if\n                  supported.  */\n-#ifdef DECL_ONE_ONLY\n-\t      if (SUPPORTS_ONE_ONLY)\n-\t\tDECL_ONE_ONLY (decl) = 1;\n+#ifdef MAKE_DECL_ONE_ONLY\n+\t      MAKE_DECL_ONE_ONLY (decl);\n #endif\n \t      if (flag_weak)\n \t\tDECL_WEAK (decl) = 1;\n@@ -2991,6 +2799,9 @@ finish_file ()\n \t}\n     }\n \n+  for (vars = static_aggregates; vars; vars = TREE_CHAIN (vars))\n+    if (! TREE_ASM_WRITTEN (TREE_VALUE (vars)))\n+      rest_of_decl_compilation (TREE_VALUE (vars), 0, 1, 1);\n   vars = static_aggregates;\n \n   if (static_ctors || vars || exception_table_p ())\n@@ -3017,9 +2828,9 @@ finish_file ()\n \n   fnname = get_file_function_name ('D');\n   start_function (void_list_node,\n-\t\t  build_parse_node (CALL_EXPR, fnname, void_list_node,\n-\t\t\t\t    NULL_TREE),\n-\t\t  NULL_TREE, NULL_TREE, 0);\n+\t\t  make_call_declarator (fnname, void_list_node, NULL_TREE,\n+\t\t\t\t\tNULL_TREE),\n+\t\t  NULL_TREE, 0);\n   fnname = DECL_ASSEMBLER_NAME (current_function_decl);\n   store_parm_decls ();\n \n@@ -3083,9 +2894,9 @@ finish_file ()\n     {\n       fnname = get_file_function_name ('I');\n       start_function (void_list_node,\n-\t\t      build_parse_node (CALL_EXPR, fnname,\n-\t\t\t\t\tvoid_list_node, NULL_TREE),\n-\t\t      NULL_TREE, NULL_TREE, 0);\n+\t\t      make_call_declarator (fnname, void_list_node, NULL_TREE,\n+\t\t\t\t\t    NULL_TREE),\n+\t\t      NULL_TREE, 0);\n       fnname = DECL_ASSEMBLER_NAME (current_function_decl);\n       store_parm_decls ();\n "}, {"sha": "2863e21645ad622d5258c12ac6474adb8ce6a202", "filename": "gcc/cp/except.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -312,36 +312,36 @@ init_exception_processing ()\n \n   declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n   d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_pc\"));\n-  d = start_decl (d, declspecs, 0, NULL_TREE);\n+  d = start_decl (d, declspecs, 0);\n   DECL_COMMON (d) = 1;\n   cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n   saved_pc = lookup_name (get_identifier (\"__eh_pc\"), 0);\n \n   declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n   d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_type\"));\n-  d = start_decl (d, declspecs, 0, NULL_TREE);\n+  d = start_decl (d, declspecs, 0);\n   DECL_COMMON (d) = 1;\n   cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n   saved_throw_type = lookup_name (get_identifier (\"__eh_type\"), 0);\n \n   declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n   d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_value\"));\n-  d = start_decl (d, declspecs, 0, NULL_TREE);\n+  d = start_decl (d, declspecs, 0);\n   DECL_COMMON (d) = 1;\n   cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n   saved_throw_value = lookup_name (get_identifier (\"__eh_value\"), 0);\n \n   declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n   d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_cleanup\"));\n-  d = build_parse_node (CALL_EXPR, d, void_list_node, NULL_TREE);\n-  d = start_decl (d, declspecs, 0, NULL_TREE);\n+  d = make_call_declarator (d, void_list_node, NULL_TREE, NULL_TREE);\n+  d = start_decl (d, declspecs, 0);\n   DECL_COMMON (d) = 1;\n   cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n   saved_cleanup = lookup_name (get_identifier (\"__eh_cleanup\"), 0);\n \n   declspecs = tree_cons (NULL_TREE, get_identifier (\"bool\"), NULL_TREE);\n   d = get_identifier (\"__eh_in_catch\");\n-  d = start_decl (d, declspecs, 0, NULL_TREE);\n+  d = start_decl (d, declspecs, 0);\n   DECL_COMMON (d) = 1;\n   cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n   saved_in_catch = lookup_name (get_identifier (\"__eh_in_catch\"), 0);\n@@ -429,6 +429,7 @@ expand_start_catch_block (declspecs, declarator)\n     return;\n \n   /* Create a binding level for the parm.  */\n+  pushlevel (0);\n   expand_start_bindings (0);\n \n   false_label_rtx = gen_label_rtx ();\n@@ -440,8 +441,7 @@ expand_start_catch_block (declspecs, declarator)\n       rtx call_rtx, return_value_rtx;\n       tree init_type;\n \n-      decl = grokdeclarator (declarator, declspecs, CATCHPARM, 1,\n-\t\t\t     NULL_TREE, NULL_TREE);\n+      decl = grokdeclarator (declarator, declspecs, CATCHPARM, 1, NULL_TREE);\n \n       if (decl == NULL_TREE)\n \t{\n@@ -545,8 +545,8 @@ void expand_end_catch_block ()\n   expand_leftover_cleanups ();\n \n   /* Cleanup the EH parameter.  */\n-  decls = getdecls ();\n-  expand_end_bindings (decls, decls != NULL_TREE, 0);\n+  expand_end_bindings (getdecls (), kept_level_p (), 0);\n+  poplevel (kept_level_p (), 1, 0);\n       \n   /* label we emit to jump to if this catch block didn't match.  */\n   /* This the closing } in the `if (eq) {' of the documentation.  */\n@@ -671,10 +671,11 @@ expand_builtin_throw ()\n     return;\n \n   params = void_list_node;\n-  t = build_parse_node (CALL_EXPR, get_identifier (\"__throw\"), params, NULL_TREE);\n+  t = make_call_declarator (get_identifier (\"__throw\"), params, NULL_TREE,\n+\t\t\t    NULL_TREE);\n   start_function (decl_tree_cons (NULL_TREE, get_identifier (\"static\"),\n \t\t\t\t  void_list_node),\n-\t\t  t, NULL_TREE, NULL_TREE, 0);\n+\t\t  t, NULL_TREE, 0);\n   store_parm_decls ();\n   pushlevel (0);\n   clear_last_expr ();\n@@ -868,7 +869,7 @@ void\n expand_exception_blocks ()\n {\n   rtx funcend;\n-  rtx insns;\n+  rtx insn, insns;\n   rtx eh_spec_insns = NULL_RTX;\n \n   start_sequence ();\n@@ -957,7 +958,14 @@ expand_exception_blocks ()\n     store_after_parms (eh_spec_insns);\n #endif\n \n-  emit_insns (insns);\n+  insn = get_last_insn ();\n+  while (GET_CODE (insn) == NOTE\n+\t || (GET_CODE (insn) == INSN\n+\t     && (GET_CODE (PATTERN (insn)) == USE\n+\t\t || GET_CODE (PATTERN (insn)) == CLOBBER)))\n+    insn = PREV_INSN (insn);\n+    \n+  emit_insns_after (insns, insn);\n }\n \n tree\n@@ -980,10 +988,11 @@ start_anon_func ()\n   params = void_list_node;\n   /* tcf stands for throw clean funciton.  */\n   sprintf (name, \"__tcf_%d\", counter++);\n-  t = build_parse_node (CALL_EXPR, get_identifier (name), params, NULL_TREE);\n+  t = make_call_declarator (get_identifier (name), params, NULL_TREE,\n+\t\t\t    NULL_TREE);\n   start_function (decl_tree_cons (NULL_TREE, get_identifier (\"static\"),\n \t\t\t\t  void_list_node),\n-\t\t  t, NULL_TREE, NULL_TREE, 0);\n+\t\t  t, NULL_TREE, 0);\n   store_parm_decls ();\n   pushlevel (0);\n   clear_last_expr ();"}, {"sha": "598b66a059cf4cc51f68ce66ed0e1afc0d54c4b7", "filename": "gcc/cp/gxx.gperf", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -9,8 +9,8 @@ __asm, GCC_ASM_KEYWORD, NORID\n __asm__, GCC_ASM_KEYWORD, NORID\n __attribute, ATTRIBUTE, NORID\n __attribute__, ATTRIBUTE, NORID\n-__const, TYPE_QUAL, RID_CONST\n-__const__, TYPE_QUAL, RID_CONST\n+__const, CV_QUALIFIER, RID_CONST\n+__const__, CV_QUALIFIER, RID_CONST\n __extension__, EXTENSION, NORID\n __inline, SCSPEC, RID_INLINE\n __inline__, SCSPEC, RID_INLINE\n@@ -22,8 +22,8 @@ __signed__, TYPESPEC, RID_SIGNED\n __sigof__, SIGOF, NORID\t\t/* Extension */,\n __typeof, TYPEOF, NORID\n __typeof__, TYPEOF, NORID\n-__volatile, TYPE_QUAL, RID_VOLATILE\n-__volatile__, TYPE_QUAL, RID_VOLATILE\n+__volatile, CV_QUALIFIER, RID_VOLATILE\n+__volatile__, CV_QUALIFIER, RID_VOLATILE\n __wchar_t, TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,\n asm, ASM_KEYWORD, NORID,\n and, ANDAND, NORID,\n@@ -38,7 +38,7 @@ catch, CATCH, NORID,\n char, TYPESPEC, RID_CHAR,\n class, AGGR, RID_CLASS,\n compl, '~', NORID,\n-const, TYPE_QUAL, RID_CONST,\n+const, CV_QUALIFIER, RID_CONST,\n const_cast, CONST_CAST, NORID,\n continue, CONTINUE, NORID,\n default, DEFAULT, NORID,\n@@ -97,7 +97,7 @@ unsigned, TYPESPEC, RID_UNSIGNED,\n using, USING, NORID,\n virtual, SCSPEC, RID_VIRTUAL,\n void, TYPESPEC, RID_VOID,\n-volatile, TYPE_QUAL, RID_VOLATILE,\n+volatile, CV_QUALIFIER, RID_VOLATILE,\n while, WHILE, NORID,\n xor, '^', NORID,\n xor_eq, ASSIGN, NORID,"}, {"sha": "436424f03ecd034ae2f0ed956a4bed8b5fcbd738", "filename": "gcc/cp/hash.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fhash.h?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -1,5 +1,5 @@\n /* C code produced by gperf version 2.5 (GNU C++ version) */\n-/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ /yorick/splunge/jason/g++/small/devo/gcc/cp/gxx.gperf  */\n+/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ ../../../devo/gcc/cp/gxx.gperf  */\n /* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n struct resword { char *name; short token; enum rid rid;};\n \n@@ -123,7 +123,7 @@ is_reserved_word (str, len)\n       {\"mutable\",  SCSPEC, RID_MUTABLE,},\n       {\"short\",  TYPESPEC, RID_SHORT,},\n       {\"signature\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n-      {\"const\",  TYPE_QUAL, RID_CONST,},\n+      {\"const\",  CV_QUALIFIER, RID_CONST,},\n       {\"static\",  SCSPEC, RID_STATIC,},\n       {\"\",}, {\"\",}, \n       {\"for\",  FOR, NORID,},\n@@ -149,11 +149,11 @@ is_reserved_word (str, len)\n       {\"\",}, {\"\",}, {\"\",}, \n       {\"signed\",  TYPESPEC, RID_SIGNED,},\n       {\"this\",  THIS, NORID,},\n-      {\"__const\",  TYPE_QUAL, RID_CONST},\n-      {\"__const__\",  TYPE_QUAL, RID_CONST},\n-      {\"__volatile\",  TYPE_QUAL, RID_VOLATILE},\n+      {\"__const\",  CV_QUALIFIER, RID_CONST},\n+      {\"__const__\",  CV_QUALIFIER, RID_CONST},\n+      {\"__volatile\",  CV_QUALIFIER, RID_VOLATILE},\n       {\"__null\",  CONSTANT, RID_NULL},\n-      {\"__volatile__\",  TYPE_QUAL, RID_VOLATILE},\n+      {\"__volatile__\",  CV_QUALIFIER, RID_VOLATILE},\n       {\"__typeof__\",  TYPEOF, NORID},\n       {\"or_eq\",  ASSIGN, NORID,},\n       {\"\",}, \n@@ -178,7 +178,7 @@ is_reserved_word (str, len)\n       {\"bitor\",  '|', NORID,},\n       {\"\",}, \n       {\"do\",  DO, NORID,},\n-      {\"volatile\",  TYPE_QUAL, RID_VOLATILE,},\n+      {\"volatile\",  CV_QUALIFIER, RID_VOLATILE,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"if\",  IF, NORID,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, "}, {"sha": "f5701f454503cd4d4361ef74228665888b28083a", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -131,35 +131,35 @@ extern int *token_count;\n \f\n /* Return something to represent absolute declarators containing a *.\n    TARGET is the absolute declarator that the * contains.\n-   TYPE_QUALS is a list of modifiers such as const or volatile\n+   CV_QUALIFIERS is a list of modifiers such as const or volatile\n    to apply to the pointer type, represented as identifiers.\n \n    We return an INDIRECT_REF whose \"contents\" are TARGET\n    and whose type is the modifier list.  */\n \n tree\n-make_pointer_declarator (type_quals, target)\n-     tree type_quals, target;\n+make_pointer_declarator (cv_qualifiers, target)\n+     tree cv_qualifiers, target;\n {\n   if (target && TREE_CODE (target) == IDENTIFIER_NODE\n       && ANON_AGGRNAME_P (target))\n     error (\"type name expected before `*'\");\n   target = build_parse_node (INDIRECT_REF, target);\n-  TREE_TYPE (target) = type_quals;\n+  TREE_TYPE (target) = cv_qualifiers;\n   return target;\n }\n \n /* Return something to represent absolute declarators containing a &.\n    TARGET is the absolute declarator that the & contains.\n-   TYPE_QUALS is a list of modifiers such as const or volatile\n+   CV_QUALIFIERS is a list of modifiers such as const or volatile\n    to apply to the reference type, represented as identifiers.\n \n    We return an ADDR_EXPR whose \"contents\" are TARGET\n    and whose type is the modifier list.  */\n    \n tree\n-make_reference_declarator (type_quals, target)\n-     tree type_quals, target;\n+make_reference_declarator (cv_qualifiers, target)\n+     tree cv_qualifiers, target;\n {\n   if (target)\n     {\n@@ -177,9 +177,26 @@ make_reference_declarator (type_quals, target)\n \t  error (\"type name expected before `&'\");\n     }\n   target = build_parse_node (ADDR_EXPR, target);\n-  TREE_TYPE (target) = type_quals;\n+  TREE_TYPE (target) = cv_qualifiers;\n   return target;\n }\n+\n+tree\n+make_call_declarator (target, parms, cv_qualifiers, exception_specification)\n+     tree target, parms, cv_qualifiers, exception_specification;\n+{\n+  target = build_parse_node (CALL_EXPR, target, parms, cv_qualifiers);\n+  TREE_TYPE (target) = exception_specification;\n+  return target;\n+}\n+\n+void\n+set_quals_and_spec (call_declarator, cv_qualifiers, exception_specification)\n+     tree call_declarator, cv_qualifiers, exception_specification;\n+{\n+  TREE_OPERAND (call_declarator, 2) = cv_qualifiers;\n+  TREE_TYPE (call_declarator) = exception_specification;\n+}\n \f\n /* Build names and nodes for overloaded operators.  */\n \n@@ -1681,12 +1698,11 @@ cons_up_default_function (type, full_name, kind)\n   TREE_PARMLIST (args) = 1;\n \n   {\n-    tree declarator = build_parse_node (CALL_EXPR, name, args, NULL_TREE);\n+    tree declarator = make_call_declarator (name, args, NULL_TREE, NULL_TREE);\n     if (retref)\n       declarator = build_parse_node (ADDR_EXPR, declarator);\n     \n-    fn = grokfield (declarator, declspecs, NULL_TREE, NULL_TREE,\n-\t\t    NULL_TREE, NULL_TREE);\n+    fn = grokfield (declarator, declspecs, NULL_TREE, NULL_TREE, NULL_TREE);\n   }\n   \n   if (fn == void_type_node)\n@@ -2444,20 +2460,6 @@ readescape (ignore_ptr)\n    Value is 0 if we treat this name in a default fashion.  */\n int looking_for_typename = 0;\n \n-#if 0\n-/* NO LONGER USED: Value is -1 if we must not see a type name.  */\n-void\n-dont_see_typename ()\n-{\n-  looking_for_typename = -1;\n-  if (yychar == TYPENAME || yychar == PTYPENAME)\n-    {\n-      yychar = IDENTIFIER;\n-      lastiddecl = 0;\n-    }\n-}\n-#endif\n-\n #ifdef __GNUC__\n extern __inline int identifier_type ();\n __inline\n@@ -4363,11 +4365,6 @@ handle_cp_pragma (pname)\n \t  main_filename = TREE_STRING_POINTER (yylval.ttype);\n \t}\n \n-#ifdef SUPPORTS_ONE_ONLY\n-      if (SUPPORTS_ONE_ONLY > 1)\n-\treturn 1;\n-#endif\n-      \n       while (token != END_OF_LINE)\n \t{\n \t  if (!warned_already && extra_warnings)\n@@ -4378,6 +4375,7 @@ handle_cp_pragma (pname)\n \t  token = real_yylex ();\n \t}\n \n+#ifndef NO_LINKAGE_HEURISTICS\n       write_virtuals = 3;\n \n       if (impl_file_chain == 0)\n@@ -4404,6 +4402,7 @@ handle_cp_pragma (pname)\n       interface_unknown = 0;\n       TREE_INT_CST_LOW (fileinfo) = interface_only;\n       TREE_INT_CST_HIGH (fileinfo) = interface_unknown;\n+#endif /* NO_LINKAGE_HEURISTICS */\n \n       return 1;\n     }\n@@ -4436,11 +4435,7 @@ handle_cp_pragma (pname)\n \t  token = real_yylex ();\n \t}\n \n-#ifdef SUPPORTS_ONE_ONLY\n-      if (SUPPORTS_ONE_ONLY > 1)\n-\treturn 1;\n-#endif\n-\n+#ifndef NO_LINKAGE_HEURISTICS\n       if (write_virtuals == 3)\n \t{\n \t  struct impl_files *ifiles = impl_file_chain;\n@@ -4485,6 +4480,8 @@ handle_cp_pragma (pname)\n #endif\n       TREE_INT_CST_LOW (fileinfo) = interface_only;\n       TREE_INT_CST_HIGH (fileinfo) = interface_unknown;\n+#endif /* NO_LINKAGE_HEURISTICS */\n+\n       return 1;\n     }\n "}, {"sha": "cf88ccbf678a792f86cdde90ef62e2d6bf9cc1c4", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -39,10 +39,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"hard-reg-set.h\"\n #include \"flags.h\"\n \n-#ifndef SUPPORTS_ONE_ONLY\n-#define SUPPORTS_ONE_ONLY 0\n-#endif\n-\n /* TREE_LIST of the current inline functions that need to be\n    processed.  */\n struct pending_inline *pending_inlines;\n@@ -2179,7 +2175,7 @@ synthesize_method (fndecl)\n     push_cp_function_context (context);\n \n   interface_unknown = 1;\n-  start_function (NULL_TREE, fndecl, NULL_TREE, NULL_TREE, 1);\n+  start_function (NULL_TREE, fndecl, NULL_TREE, 1);\n   store_parm_decls ();\n \n   if (DECL_NAME (fndecl) == ansi_opname[MODIFY_EXPR])"}, {"sha": "c0a2c453deb1fa72a350d8afd0bac6fb905bbb10", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 330, "deletions": 389, "changes": 719, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -121,7 +121,7 @@ empty_parms ()\n \n /* Reserved words that qualify type: \"const\" or \"volatile\".\n    yylval contains an IDENTIFIER_NODE which indicates which one.  */\n-%token TYPE_QUAL\n+%token CV_QUALIFIER\n \n /* Character or numeric constants.\n    yylval is the node for the constant.  */\n@@ -162,7 +162,7 @@ empty_parms ()\n %nonassoc IF\n %nonassoc ELSE\n \n-%left IDENTIFIER TYPENAME SELFNAME PTYPENAME SCSPEC TYPESPEC TYPE_QUAL ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR NSNAME TYPENAME_KEYWORD\n+%left IDENTIFIER TYPENAME SELFNAME PTYPENAME SCSPEC TYPESPEC CV_QUALIFIER ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR NSNAME TYPENAME_KEYWORD\n \n %left '{' ',' ';'\n \n@@ -198,7 +198,7 @@ empty_parms ()\n %type <ttype> reserved_declspecs boolean.literal\n %type <ttype> reserved_typespecquals\n %type <ttype> declmods \n-%type <ttype> SCSPEC TYPESPEC TYPE_QUAL maybe_type_qual\n+%type <ttype> SCSPEC TYPESPEC CV_QUALIFIER maybe_cv_qualifier\n %type <itype> initdecls notype_initdecls initdcl\t/* C++ modification */\n %type <ttype> init initlist maybeasm maybe_init\n %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n@@ -216,7 +216,7 @@ empty_parms ()\n %type <ttype> notype_component_declarator notype_component_declarator0\n %type <ttype> after_type_component_declarator after_type_component_declarator0\n %type <ttype> enumlist enumerator\n-%type <ttype> absdcl type_quals\n+%type <ttype> absdcl cv_qualifiers\n %type <ttype> direct_abstract_declarator conversion_declarator\n %type <ttype> new_declarator direct_new_declarator\n %type <ttype> xexpr parmlist parms bad_parm \n@@ -229,7 +229,7 @@ empty_parms ()\n %type <ttype> complex_parmlist parms_comma\n \n %type <ftype> type_id new_type_id typed_typespecs typespec typed_declspecs\n-%type <ftype> typed_declspecs1 type_specifier_seq nonempty_type_quals\n+%type <ftype> typed_declspecs1 type_specifier_seq nonempty_cv_qualifiers\n %type <ftype> structsp typespecqual_reserved parm named_parm full_parm\n \n /* C++ extensions */\n@@ -256,7 +256,6 @@ empty_parms ()\n %type <ttype> template_type_parm\n %type <code>  template_close_bracket\n %type <ttype> template_type template_arg_list template_arg\n-/* %type <itype> try_for_typename */\n %type <ttype> condition xcond paren_cond_or_null\n %type <ttype> type_name nested_name_specifier nested_type ptr_to_mem\n %type <ttype> complete_type_name notype_identifier\n@@ -303,7 +302,8 @@ extern tree combine_strings\t\tPROTO((tree));\n %}\n \f\n %%\n-program: /* empty */\n+program:\n+\t  /* empty */\n \t| extdefs\n \t\t{\n \t\t  /* In case there were missing closebraces,\n@@ -319,7 +319,8 @@ program: /* empty */\n  can find a valid list of type and sc specs in $0.  */\n \n extdefs:\n-\t  { $<ttype>$ = NULL_TREE; } lang_extdef\n+\t\t{ $<ttype>$ = NULL_TREE; }\n+\t  lang_extdef\n \t\t{ $<ttype>$ = NULL_TREE; }\n \t| extdefs lang_extdef\n \t\t{ $<ttype>$ = NULL_TREE; }\n@@ -345,10 +346,10 @@ asm_keyword:\n \t;\n \n lang_extdef:\n-\t  { if (pending_lang_change) do_pending_lang_change(); }\n+\t\t{ if (pending_lang_change) do_pending_lang_change(); }\n \t  extdef\n-\t  { if (! toplevel_bindings_p () && ! pseudo_global_level_p())\n-\t      pop_everything (); }\n+\t\t{ if (! toplevel_bindings_p () && ! pseudo_global_level_p())\n+\t\t  pop_everything (); }\n \t;\n \n extdef:\n@@ -464,7 +465,7 @@ template_parm:\n \t\t{ $$ = build_tree_list (groktypename ($3.t), $1); }\n \t| parm\n \t\t{ $$ = build_tree_list (NULL_TREE, $1.t); }\n-\t| parm '=' expr_no_commas %prec ARITHCOMPARE\n+\t| parm '=' expr_no_commas  %prec ARITHCOMPARE\n \t\t{ $$ = build_tree_list ($3, $1.t); }\n \t;\n \n@@ -473,7 +474,8 @@ overloaddef:\n \t\t{ warning (\"use of `overload' is an anachronism\"); }\n \t;\n \n-ov_identifiers: IDENTIFIER\n+ov_identifiers:\n+\t  IDENTIFIER\n \t\t{ declare_overloaded ($1); }\n \t| ov_identifiers ',' IDENTIFIER\n \t\t{ declare_overloaded ($3); }\n@@ -484,7 +486,7 @@ template_def:\n \t  extdef\n \t\t{ end_template_decl (); }\n \t| template_header\n-\t  error %prec EMPTY\n+\t  error  %prec EMPTY\n \t\t{ end_template_decl (); }\n \t;\n \n@@ -493,37 +495,20 @@ datadef:\n \t\t{}\n \t| declmods notype_initdecls ';'\n \t\t{}\n-\t/* Normal case to make fast: \"const i;\".  */\n-\t| declmods notype_declarator ';'\n-\t\t{ tree d, specs, attrs;\n-\t\t  split_specs_attrs ($1, &specs, &attrs);\n-\t\t  d = start_decl ($<ttype>2, specs, 0, NULL_TREE);\n-\t\t  cplus_decl_attributes (d, NULL_TREE, attrs);\n-\t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n-\t\t}\n \t| typed_declspecs initdecls ';'\n \t\t{\n \t\t  note_list_got_semicolon ($1.t);\n \t\t}\n-\t/* Normal case: make this fast.  */\n-\t| typed_declspecs declarator ';'\n-\t\t{ tree d, specs, attrs;\n-\t\t  split_specs_attrs ($1.t, &specs, &attrs);\n-\t\t  note_list_got_semicolon (specs);\n-\t\t  d = start_decl ($2, specs, 0, NULL_TREE);\n-\t\t  cplus_decl_attributes (d, NULL_TREE, attrs);\n-\t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n-\t\t}\n         | declmods ';'\n-\t  { pedwarn (\"empty declaration\"); }\n+\t\t{ pedwarn (\"empty declaration\"); }\n \t| explicit_instantiation ';'\n \t| typed_declspecs ';'\n-\t  {\n-\t    tree t, attrs;\n-\t    split_specs_attrs ($1.t, &t, &attrs);\n-\t    shadow_tag (t);\n-\t    note_list_got_semicolon ($1.t);\n-\t  }\n+\t\t{\n+\t\t  tree t, attrs;\n+\t\t  split_specs_attrs ($1.t, &t, &attrs);\n+\t\t  shadow_tag (t);\n+\t\t  note_list_got_semicolon ($1.t);\n+\t\t}\n \t| error ';'\n \t| error '}'\n \t| ';'\n@@ -553,12 +538,6 @@ fndef:\n \t| fn.def1 maybe_return_init function_try_block\n \t\t{ if ($<ttype>$) process_next_inline ($<ttype>$); }\n \t  eat_saved_input\n-\t| typed_declspecs declarator error\n-\t\t{}\n-\t| declmods notype_declarator error\n-\t\t{}\n-\t| notype_declarator error\n-\t\t{}\n \t;\n \n constructor_declarator:\n@@ -571,17 +550,17 @@ constructor_declarator:\n \t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n \t\t    }\n \t\t}\n-\t  parmlist ')' type_quals\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $<ttype>4, $5, $7); }\n-\t| nested_name_specifier SELFNAME LEFT_RIGHT type_quals\n+\t  parmlist ')' cv_qualifiers exception_specification_opt\n+\t\t{ $$ = make_call_declarator ($<ttype>4, $5, $7, $8); }\n+\t| nested_name_specifier SELFNAME LEFT_RIGHT cv_qualifiers exception_specification_opt\n \t\t{\n \t\t  $$ = build_parse_node (SCOPE_REF, $1, $2);\n \t\t  if ($1 != current_class_type)\n \t\t    {\n \t\t      push_nested_class ($1, 3);\n \t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n \t\t    }\n-\t\t  $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $4);\n+\t\t  $$ = make_call_declarator ($$, empty_parms (), $4, $5);\n \t\t}\n \t| global_scope nested_name_specifier SELFNAME '(' \n \t\t{\n@@ -592,17 +571,17 @@ constructor_declarator:\n \t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n \t\t    }\n \t\t}\n-\t parmlist ')' type_quals\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $<ttype>5, $6, $8); }\n-\t| global_scope nested_name_specifier SELFNAME LEFT_RIGHT type_quals\n+\t parmlist ')' cv_qualifiers exception_specification_opt\n+\t\t{ $$ = make_call_declarator ($<ttype>5, $6, $8, $9); }\n+\t| global_scope nested_name_specifier SELFNAME LEFT_RIGHT cv_qualifiers exception_specification_opt\n \t\t{\n \t\t  $$ = build_parse_node (SCOPE_REF, $2, $3);\n \t\t  if ($2 != current_class_type)\n \t\t    {\n \t\t      push_nested_class ($2, 3);\n \t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n \t\t    }\n-\t\t  $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $5);\n+\t\t  $$ = make_call_declarator ($$, empty_parms (), $5, $6);\n \t\t}\n \t| nested_name_specifier self_template_type '(' \n \t\t{\n@@ -613,17 +592,17 @@ constructor_declarator:\n \t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n \t\t    }\n \t\t}\n-\t  parmlist ')' type_quals\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $<ttype>4, $5, $7); }\n-\t| nested_name_specifier self_template_type LEFT_RIGHT type_quals\n+\t  parmlist ')' cv_qualifiers exception_specification_opt\n+\t\t{ $$ = make_call_declarator ($<ttype>4, $5, $7, $8); }\n+\t| nested_name_specifier self_template_type LEFT_RIGHT cv_qualifiers exception_specification_opt\n \t\t{\n \t\t  $$ = build_parse_node (SCOPE_REF, $1, $2);\n \t\t  if ($1 != current_class_type)\n \t\t    {\n \t\t      push_nested_class ($1, 3);\n \t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n \t\t    }\n-\t\t  $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $4);\n+\t\t  $$ = make_call_declarator ($$, empty_parms (), $4, $5);\n \t\t}\n \t| global_scope nested_name_specifier self_template_type '(' \n \t\t{\n@@ -634,103 +613,105 @@ constructor_declarator:\n \t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n \t\t    }\n \t\t}\n-\t parmlist ')' type_quals\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $<ttype>5, $6, $8); }\n-\t| global_scope nested_name_specifier self_template_type LEFT_RIGHT type_quals\n+\t parmlist ')' cv_qualifiers exception_specification_opt\n+\t\t{ $$ = make_call_declarator ($<ttype>5, $6, $8, $9); }\n+\t| global_scope nested_name_specifier self_template_type LEFT_RIGHT cv_qualifiers exception_specification_opt\n \t\t{\n \t\t  $$ = build_parse_node (SCOPE_REF, $2, $3);\n \t\t  if ($2 != current_class_type)\n \t\t    {\n \t\t      push_nested_class ($2, 3);\n \t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n \t\t    }\n-\t\t  $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $5);\n+\t\t  $$ = make_call_declarator ($$, empty_parms (), $5, $6);\n \t\t}\n \t;\n \n fn.def1:\n-\t  typed_declspecs declarator exception_specification_opt\n+\t  typed_declspecs declarator\n \t\t{ tree specs, attrs;\n \t\t  split_specs_attrs ($1.t, &specs, &attrs);\n-\t\t  if (! start_function (specs, $2, $3, attrs, 0))\n+\t\t  if (! start_function (specs, $2, attrs, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n \t\t  $$ = NULL_TREE; }\n-\t| declmods notype_declarator exception_specification_opt\n+\t| declmods notype_declarator\n \t\t{ tree specs, attrs;\n \t\t  split_specs_attrs ($1, &specs, &attrs);\n-\t\t  if (! start_function (specs, $2, $3, attrs, 0))\n+\t\t  if (! start_function (specs, $2, attrs, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n \t\t  $$ = NULL_TREE; }\n-\t| notype_declarator exception_specification_opt\n-\t\t{ if (! start_function (NULL_TREE, $$, $2, NULL_TREE, 0))\n+\t| notype_declarator\n+\t\t{ if (! start_function (NULL_TREE, $$, NULL_TREE, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n \t\t  $$ = NULL_TREE; }\n-\t| declmods constructor_declarator exception_specification_opt\n+\t| declmods constructor_declarator\n \t\t{ tree specs, attrs;\n \t\t  split_specs_attrs ($1, &specs, &attrs);\n-\t\t  if (! start_function (specs, $2, $3, attrs, 0))\n+\t\t  if (! start_function (specs, $2, attrs, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n \t\t  $$ = NULL_TREE; }\n-\t| constructor_declarator exception_specification_opt\n-\t\t{ if (! start_function (NULL_TREE, $$, $2, NULL_TREE, 0))\n+\t| constructor_declarator\n+\t\t{ if (! start_function (NULL_TREE, $$, NULL_TREE, 0))\n \t\t    YYERROR1;\n \t\t  reinit_parse_for_function ();\n \t\t  $$ = NULL_TREE; }\n \t;\n \n component_constructor_declarator:\n-\t  SELFNAME '(' parmlist ')' type_quals\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $1, $3, $5); }\n-\t| SELFNAME LEFT_RIGHT type_quals\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $1, empty_parms (), $3); }\n-\t| self_template_type '(' parmlist ')' type_quals\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $1, $3, $5); }\n-\t| self_template_type LEFT_RIGHT type_quals\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $1, empty_parms (), $3); }\n+\t  SELFNAME '(' parmlist ')' cv_qualifiers exception_specification_opt\n+\t\t{ $$ = make_call_declarator ($1, $3, $5, $6); }\n+\t| SELFNAME LEFT_RIGHT cv_qualifiers exception_specification_opt\n+\t\t{ $$ = make_call_declarator ($1, empty_parms (), $3, $4); }\n+\t| self_template_type '(' parmlist ')' cv_qualifiers exception_specification_opt\n+\t\t{ $$ = make_call_declarator ($1, $3, $5, $6); }\n+\t| self_template_type LEFT_RIGHT cv_qualifiers exception_specification_opt\n+\t\t{ $$ = make_call_declarator ($1, empty_parms (), $3, $4); }\n \t;\n \n /* more C++ complexity.  See component_decl for a comment on the\n    reduce/reduce conflict introduced by these rules.  */\n fn.def2:\n-\t  declmods component_constructor_declarator exception_specification_opt\n+\t  declmods component_constructor_declarator\n \t\t{ tree specs = strip_attrs ($1);\n-\t\t  $$ = start_method (specs, $2, $3);\n+\t\t  $$ = start_method (specs, $2);\n \t\t rest_of_mdef:\n \t\t  if (! $$)\n \t\t    YYERROR1;\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX;\n \t\t  reinit_parse_for_method (yychar, $$); }\n-\t| component_constructor_declarator exception_specification_opt\n-\t\t{ $$ = start_method (NULL_TREE, $1, $2); goto rest_of_mdef; }\n-\t| typed_declspecs declarator exception_specification_opt\n+\t| component_constructor_declarator\n+\t\t{ $$ = start_method (NULL_TREE, $1); goto rest_of_mdef; }\n+\t| typed_declspecs declarator\n \t\t{ tree specs = strip_attrs ($1.t);\n-\t\t  $$ = start_method (specs, $2, $3); goto rest_of_mdef; }\n-\t| declmods notype_declarator exception_specification_opt\n+\t\t  $$ = start_method (specs, $2); goto rest_of_mdef; }\n+\t| declmods notype_declarator\n \t\t{ tree specs = strip_attrs ($1);\n-\t\t  $$ = start_method (specs, $2, $3); goto rest_of_mdef; }\n-\t| notype_declarator exception_specification_opt\n-\t\t{ $$ = start_method (NULL_TREE, $$, $2); goto rest_of_mdef; }\n-\t| declmods constructor_declarator exception_specification_opt\n+\t\t  $$ = start_method (specs, $2); goto rest_of_mdef; }\n+\t| notype_declarator\n+\t\t{ $$ = start_method (NULL_TREE, $$); goto rest_of_mdef; }\n+\t| declmods constructor_declarator\n \t\t{ tree specs = strip_attrs ($1);\n-\t\t  $$ = start_method (specs, $2, $3); goto rest_of_mdef; }\n-\t| constructor_declarator exception_specification_opt\n-\t\t{ $$ = start_method (NULL_TREE, $$, $2); goto rest_of_mdef; }\n+\t\t  $$ = start_method (specs, $2); goto rest_of_mdef; }\n+\t| constructor_declarator\n+\t\t{ $$ = start_method (NULL_TREE, $$); goto rest_of_mdef; }\n \t;\n \n-return_id: RETURN IDENTIFIER\n+return_id:\n+\t  RETURN IDENTIFIER\n \t\t{\n \t\t  if (! current_function_parms_stored)\n \t\t    store_parm_decls ();\n \t\t  $$ = $2;\n \t\t}\n \t;\n \n-return_init: return_id maybe_init\n+return_init:\n+\t  return_id maybe_init\n \t\t{ store_return_init ($<ttype>$, $2); }\n \t| return_id '(' nonnull_exprlist ')'\n \t\t{ store_return_init ($<ttype>$, $3); }\n@@ -752,7 +733,7 @@ base_init:\n \t;\n \n .set_base_init:\n-\t/* empty */\n+\t  /* empty */\n \t\t{\n \t\t  if (! current_function_parms_stored)\n \t\t    store_parm_decls ();\n@@ -780,7 +761,8 @@ member_init_list:\n \t| member_init_list error\n \t;\n \n-member_init: '(' nonnull_exprlist ')'\n+member_init:\n+\t  '(' nonnull_exprlist ')'\n \t\t{\n \t\t  if (current_class_name && !flag_traditional)\n \t\t    pedwarn (\"anachronistic old style base class initializer\");\n@@ -822,7 +804,7 @@ identifier:\n notype_identifier:\n \t  IDENTIFIER\n \t| PTYPENAME \n-\t| NSNAME %prec EMPTY\n+\t| NSNAME  %prec EMPTY\n \t;\n \n identifier_defn:\n@@ -922,7 +904,8 @@ template_arg:\n \t| expr_no_commas  %prec ARITHCOMPARE\n \t;\n \n-unop:     '-'\n+unop:\n+\t  '-'\n \t\t{ $$ = NEGATE_EXPR; }\n \t| '+'\n \t\t{ $$ = CONVERT_EXPR; }\n@@ -934,7 +917,8 @@ unop:     '-'\n \t\t{ $$ = TRUTH_NOT_EXPR; }\n \t;\n \n-expr:\t  nontrivial_exprlist\n+expr:\n+\t  nontrivial_exprlist\n \t\t{ $$ = build_x_compound_expr ($$); }\n \t| expr_no_commas\n \t;\n@@ -958,7 +942,7 @@ paren_cond_or_null:\n \t;\n \n xcond:\n-\t/* empty */\n+\t  /* empty */\n \t\t{ $$ = NULL_TREE; }\n \t| condition\n \t\t{ $$ = condition_conversion ($$); }\n@@ -967,7 +951,7 @@ xcond:\n \t;\n \n condition:\n-\ttype_specifier_seq declarator exception_specification_opt maybeasm maybe_attribute '='\n+\t  type_specifier_seq declarator maybeasm maybe_attribute '='\n \t\t{ {\n \t\t  tree d;\n \t\t  for (d = getdecls (); d; d = TREE_CHAIN (d))\n@@ -980,16 +964,16 @@ condition:\n \t\t    }\n \t\t  }\n \t\t  current_declspecs = $1.t;\n-\t\t  $<itype>6 = suspend_momentary ();\n-\t\t  $<ttype>$ = start_decl ($<ttype>2, current_declspecs, 1, $3);\n-\t\t  cplus_decl_attributes ($<ttype>$, $5,\n+\t\t  $<itype>5 = suspend_momentary ();\n+\t\t  $<ttype>$ = start_decl ($<ttype>2, current_declspecs, 1);\n+\t\t  cplus_decl_attributes ($<ttype>$, $4,\n \t\t\t\t\t /*prefix_attributes*/ NULL_TREE);\n \t\t}\n-\tinit\n+\t  init\n \t\t{ \n-\t\t  cp_finish_decl ($<ttype>7, $8, $5, 1, LOOKUP_ONLYCONVERTING);\n-\t\t  resume_momentary ($<itype>6);\n-\t\t  $$ = $<ttype>7; \n+\t\t  cp_finish_decl ($<ttype>6, $7, $4, 1, LOOKUP_ONLYCONVERTING);\n+\t\t  resume_momentary ($<itype>5);\n+\t\t  $$ = $<ttype>6; \n \t\t  if (TREE_CODE (TREE_TYPE ($$)) == ARRAY_TYPE)\n \t\t    cp_error (\"definition of array `%#D' in condition\", $$); \n \t\t}\n@@ -1047,13 +1031,13 @@ nonnull_exprlist:\n \t;\n \n unary_expr:\n-\t  primary %prec UNARY\n+\t  primary  %prec UNARY\n \t\t{ $$ = $1; }\n \t/* __extension__ turns off -pedantic for following primary.  */\n \t| EXTENSION\n \t\t{ $<itype>1 = pedantic;\n \t\t  pedantic = 0; }\n-\t  cast_expr\t  %prec UNARY\n+\t  cast_expr  \t  %prec UNARY\n \t\t{ $$ = $3;\n \t\t  pedantic = $<itype>1; }\n \t| '*' cast_expr   %prec UNARY\n@@ -1092,26 +1076,26 @@ unary_expr:\n \n \t/* The %prec EMPTY's here are required by the = init initializer\n \t   syntax extension; see below.  */\n-\t| new new_type_id %prec EMPTY\n+\t| new new_type_id  %prec EMPTY\n \t\t{ $$ = build_new (NULL_TREE, $2.t, NULL_TREE, $1); \n \t\t  check_for_new_type (\"new\", $2); }\n \t| new new_type_id new_initializer\n \t\t{ $$ = build_new (NULL_TREE, $2.t, $3, $1); \n \t\t  check_for_new_type (\"new\", $2); }\n-\t| new new_placement new_type_id %prec EMPTY\n+\t| new new_placement new_type_id  %prec EMPTY\n \t\t{ $$ = build_new ($2, $3.t, NULL_TREE, $1); \n \t\t  check_for_new_type (\"new\", $3); }\n \t| new new_placement new_type_id new_initializer\n \t\t{ $$ = build_new ($2, $3.t, $4, $1); \n \t\t  check_for_new_type (\"new\", $3); }\n-\t| new '(' type_id ')' %prec EMPTY\n+\t| new '(' type_id ')'  %prec EMPTY\n \t\t{ $$ = build_new (NULL_TREE, groktypename($3.t),\n \t\t\t\t  NULL_TREE, $1); \n \t\t  check_for_new_type (\"new\", $3); }\n \t| new '(' type_id ')' new_initializer\n \t\t{ $$ = build_new (NULL_TREE, groktypename($3.t), $5, $1); \n \t\t  check_for_new_type (\"new\", $3); }\n-\t| new new_placement '(' type_id ')' %prec EMPTY\n+\t| new new_placement '(' type_id ')'  %prec EMPTY\n \t\t{ $$ = build_new ($2, groktypename($4.t), NULL_TREE, $1); \n \t\t  check_for_new_type (\"new\", $4); }\n \t| new new_placement '(' type_id ')' new_initializer\n@@ -1124,7 +1108,7 @@ unary_expr:\n \t\t{ $$ = delete_sanity ($4, NULL_TREE, 1, $1);\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX; }\n-\t| delete '[' expr ']' cast_expr %prec UNARY\n+\t| delete '[' expr ']' cast_expr  %prec UNARY\n \t\t{ $$ = delete_sanity ($5, $3, 2, $1);\n \t\t  if (yychar == YYEMPTY)\n \t\t    yychar = YYLEX; }\n@@ -1163,16 +1147,15 @@ new_initializer:\n \n /* This is necessary to postpone reduction of `int ((int)(int)(int))'.  */\n regcast_or_absdcl:\n-\t  '(' type_id ')' %prec EMPTY\n+\t  '(' type_id ')'  %prec EMPTY\n \t\t{ $2.t = tree_cons (NULL_TREE, $2.t, void_list_node);\n \t\t  TREE_PARMLIST ($2.t) = 1;\n-\t\t  $$ = build_parse_node (CALL_EXPR, NULL_TREE, $2.t, \n-\t\t\t\t\t NULL_TREE);\n+\t\t  $$ = make_call_declarator (NULL_TREE, $2.t, NULL_TREE, NULL_TREE);\n \t\t  check_for_new_type (\"cast\", $2); }\n-\t| regcast_or_absdcl '(' type_id ')' %prec EMPTY\n+\t| regcast_or_absdcl '(' type_id ')'  %prec EMPTY\n \t\t{ $3.t = tree_cons (NULL_TREE, $3.t, void_list_node);\n \t\t  TREE_PARMLIST ($3.t) = 1;\n-\t\t  $$ = build_parse_node (CALL_EXPR, $$, $3.t, NULL_TREE);\n+\t\t  $$ = make_call_declarator ($$, $3.t, NULL_TREE, NULL_TREE);\n \t\t  check_for_new_type (\"cast\", $3); }\n \t;\n \n@@ -1248,7 +1231,7 @@ expr_no_commas:\n /* These extensions are not defined.  The second arg to build_m_component_ref\n    is old, build_m_component_ref now does an implicit\n    build_indirect_ref (x, NULL_PTR) on the second argument.\n-\t| object '&' expr_no_commas   %prec UNARY\n+\t| object '&' expr_no_commas  %prec UNARY\n \t\t{ $$ = build_m_component_ref ($$, build_x_unary_op (ADDR_EXPR, $3)); }\n \t| object unop expr_no_commas  %prec UNARY\n \t\t{ $$ = build_m_component_ref ($$, build_x_unary_op ($2, $3)); }\n@@ -1266,7 +1249,7 @@ notype_unqualified_id:\n \t| operator_name\n \t| IDENTIFIER\n \t| PTYPENAME\n-\t| NSNAME %prec EMPTY\n+\t| NSNAME  %prec EMPTY\n \t;\n \n unqualified_id:\n@@ -1277,9 +1260,9 @@ unqualified_id:\n \n expr_or_declarator:\n \t  notype_unqualified_id\n-\t| '*' expr_or_declarator %prec UNARY\n+\t| '*' expr_or_declarator  %prec UNARY\n \t\t{ $$ = build_parse_node (INDIRECT_REF, $2); }\n-\t| '&' expr_or_declarator %prec UNARY\n+\t| '&' expr_or_declarator  %prec UNARY\n \t\t{ $$ = build_parse_node (ADDR_EXPR, $2); }\n \t| '(' expr_or_declarator ')'\n \t\t{ $$ = $2; }\n@@ -1410,7 +1393,7 @@ primary:\n \t\t      $$ = error_mark_node;\n \t\t    }\n \t\t}\n-\t| TYPE_QUAL '(' nonnull_exprlist ')'\n+\t| CV_QUALIFIER '(' nonnull_exprlist ')'\n \t\t{\n \t\t  tree type;\n \t\t  tree id = $$;\n@@ -1487,7 +1470,7 @@ primary:\n \t\t  else\n \t\t    $$ = $2;\n \t\t}\n-\t| overqualified_id %prec HYPERUNARY\n+\t| overqualified_id  %prec HYPERUNARY\n \t\t{ $$ = build_offset_ref (OP0 ($$), OP1 ($$)); }\n \t| overqualified_id '(' nonnull_exprlist ')'\n \t\t{ if (current_template_parms)\n@@ -1502,7 +1485,7 @@ primary:\n \t\t    $$ = build_member_call (OP0 ($$), OP1 ($$), NULL_TREE); }\n \t| object unqualified_id  %prec UNARY\n \t\t{ $$ = build_component_ref ($$, $2, NULL_TREE, 1); }\n-\t| object overqualified_id %prec UNARY\n+\t| object overqualified_id  %prec UNARY\n \t\t{ if (current_template_parms)\n \t\t    $$ = build_min_nt (COMPONENT_REF, $1, copy_to_permanent ($2));\n \t\t  else\n@@ -1621,13 +1604,15 @@ primary_no_id:\n \t;\n */\n \n-new:\t  NEW\n+new:\n+\t  NEW\n \t\t{ $$ = 0; }\n \t| global_scope NEW\n \t\t{ got_scope = NULL_TREE; $$ = 1; }\n \t;\n \n-delete:\t  DELETE\n+delete:\n+\t  DELETE\n \t\t{ $$ = 0; }\n \t| global_scope delete\n \t\t{ got_scope = NULL_TREE; $$ = 1; }\n@@ -1660,7 +1645,8 @@ nodecls:\n \t\t}\n \t;\n \n-object:\t  primary '.'\n+object:\n+\t  primary '.'\n \t\t{ got_object = TREE_TYPE ($$); }\n \t| primary POINTSAT\n \t\t{\n@@ -1670,28 +1656,7 @@ object:\t  primary '.'\n \t;\n \n decl:\n-\t/* Normal case: make this fast.  */\n-\t  typespec declarator ';'\n-\t\t{ tree d = get_decl_list ($1.t);\n-\t\t  int yes = suspend_momentary ();\n-\t\t  d = start_decl ($2, d, 0, NULL_TREE);\n-\t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n-\t\t  resume_momentary (yes);\n-\t\t  if (IS_AGGR_TYPE_CODE (TREE_CODE ($1.t)))\n-\t\t    note_got_semicolon ($1.t);\n-\t\t}\n-\t| typed_declspecs declarator ';'\n-\t\t{ tree d, specs, attrs;\n-\t\t  int yes;\n-\t\t  split_specs_attrs ($1.t, &specs, &attrs);\n-\t\t  yes = suspend_momentary ();\n-\t\t  d = start_decl ($2, specs, 0, NULL_TREE);\n-\t\t  cplus_decl_attributes (d, NULL_TREE, attrs);\n-\t\t  cp_finish_decl (d, NULL_TREE, NULL_TREE, 1, 0);\n-\t\t  resume_momentary (yes);\n-\t\t  note_list_got_semicolon ($1.t);\n-\t\t}\n-\t| typespec initdecls ';'\n+\t  typespec initdecls ';'\n \t\t{\n \t\t  resume_momentary ($2);\n \t\t  if (IS_AGGR_TYPE_CODE (TREE_CODE ($1.t)))\n@@ -1717,35 +1682,35 @@ decl:\n    after an explicit typespec).  */\n \n declarator:\n-\t  after_type_declarator %prec EMPTY\n-\t| notype_declarator %prec EMPTY\n+\t  after_type_declarator  %prec EMPTY\n+\t| notype_declarator  %prec EMPTY\n \t;\n \n /* This is necessary to postpone reduction of `int()()()()'.  */\n fcast_or_absdcl:\n-\t  LEFT_RIGHT %prec EMPTY\n-\t\t{ $$ = build_parse_node (CALL_EXPR, NULL_TREE, empty_parms (),\n-\t\t\t\t\t NULL_TREE); }\n-\t| fcast_or_absdcl LEFT_RIGHT %prec EMPTY\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), \n-\t\t\t\t\t NULL_TREE); }\n+\t  LEFT_RIGHT  %prec EMPTY\n+\t\t{ $$ = make_call_declarator (NULL_TREE, empty_parms (),\n+\t\t\t\t\t     NULL_TREE, NULL_TREE); }\n+\t| fcast_or_absdcl LEFT_RIGHT  %prec EMPTY\n+\t\t{ $$ = make_call_declarator ($$, empty_parms (), NULL_TREE,\n+\t\t\t\t\t     NULL_TREE); }\n \t;\n \n /* ANSI type-id (8.1) */\n type_id:\n \t  typed_typespecs absdcl\n \t\t{ $$.t = build_decl_list ($1.t, $2); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n-\t| nonempty_type_quals absdcl\n+\t| nonempty_cv_qualifiers absdcl\n \t\t{ $$.t = build_decl_list ($1.t, $2); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typespec absdcl\n \t\t{ $$.t = build_decl_list (get_decl_list ($1.t), $2); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n-\t| typed_typespecs %prec EMPTY\n+\t| typed_typespecs  %prec EMPTY\n \t\t{ $$.t = build_decl_list ($1.t, NULL_TREE);\n \t\t  $$.new_type_flag = $1.new_type_flag;  }\n-\t| nonempty_type_quals %prec EMPTY\n+\t| nonempty_cv_qualifiers  %prec EMPTY\n \t\t{ $$.t = build_decl_list ($1.t, NULL_TREE); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t;\n@@ -1756,15 +1721,15 @@ type_id:\n    In the result, declspecs have a non-NULL TREE_VALUE, attributes do not.  */\n \n typed_declspecs:\n-\t  typed_typespecs %prec EMPTY\n+\t  typed_typespecs  %prec EMPTY\n \t| typed_declspecs1\n \t;\n \n typed_declspecs1:\n \t  declmods typespec\n \t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, $1); \n \t\t  $$.new_type_flag = $2.new_type_flag; }\n-\t| typespec reserved_declspecs\t%prec HYPERUNARY\n+\t| typespec reserved_declspecs  %prec HYPERUNARY\n \t\t{ $$.t = decl_tree_cons (NULL_TREE, $1.t, $2); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t| typespec reserved_typespecquals reserved_declspecs\n@@ -1807,11 +1772,11 @@ reserved_declspecs:\n    In the result, declspecs have a non-NULL TREE_VALUE, attributes do not.  */\n \n declmods:\n-\t  nonempty_type_quals %prec EMPTY\n+\t  nonempty_cv_qualifiers  %prec EMPTY\n \t\t{ $$ = $1.t; TREE_STATIC ($$) = 1; }\n \t| SCSPEC\n \t\t{ $$ = IDENTIFIER_AS_LIST ($$); }\n-\t| declmods TYPE_QUAL\n+\t| declmods CV_QUALIFIER\n \t\t{ $$ = decl_tree_cons (NULL_TREE, $2, $$);\n \t\t  TREE_STATIC ($$) = 1; }\n \t| declmods SCSPEC\n@@ -1836,13 +1801,13 @@ typed_typespecs:\n \t  typespec  %prec EMPTY\n \t\t{ $$.t = get_decl_list ($1.t); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n-\t| nonempty_type_quals typespec\n+\t| nonempty_cv_qualifiers typespec\n \t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, $1.t); \n \t\t  $$.new_type_flag = $2.new_type_flag; }\n \t| typespec reserved_typespecquals\n \t\t{ $$.t = decl_tree_cons (NULL_TREE, $1.t, $2); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n-\t| nonempty_type_quals typespec reserved_typespecquals\n+\t| nonempty_cv_qualifiers typespec reserved_typespecquals\n \t\t{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t;\n@@ -1858,7 +1823,8 @@ reserved_typespecquals:\n    Once we have seen one of these in a declaration,\n    if a typedef name appears then it is being redeclared.  */\n \n-typespec: structsp\n+typespec:\n+\t  structsp\n \t| TYPESPEC  %prec EMPTY\n \t\t{ $$.t = $1; $$.new_type_flag = 0; }\n \t| complete_type_name\n@@ -1907,9 +1873,10 @@ typespec: structsp\n \n /* A typespec that is a reserved word, or a type qualifier.  */\n \n-typespecqual_reserved: TYPESPEC\n+typespecqual_reserved:\n+\t  TYPESPEC\n \t\t{ $$.t = $1; $$.new_type_flag = 0; }\n-\t| TYPE_QUAL\n+\t| CV_QUALIFIER\n \t\t{ $$.t = $1; $$.new_type_flag = 0; }\n \t| structsp\n \t;\n@@ -1937,7 +1904,7 @@ maybeasm:\n \t;\n \n initdcl0:\n-\t  declarator exception_specification_opt maybeasm maybe_attribute '='\n+\t  declarator maybeasm maybe_attribute '='\n \t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  if (TREE_CODE (current_declspecs) != TREE_LIST)\n@@ -1949,14 +1916,14 @@ initdcl0:\n \t\t\t current_declspecs);\n \t\t      used_extern_spec = 1;\n \t\t    }\n-\t\t  $<itype>5 = suspend_momentary ();\n-\t\t  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1, $2);\n-\t\t  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes); }\n+\t\t  $<itype>4 = suspend_momentary ();\n+\t\t  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1);\n+\t\t  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ cp_finish_decl ($<ttype>6, $7, $3, 1, LOOKUP_ONLYCONVERTING);\n-\t\t  $$ = $<itype>5; }\n-\t| declarator exception_specification_opt maybeasm maybe_attribute\n+\t\t{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING);\n+\t\t  $$ = $<itype>4; }\n+\t| declarator maybeasm maybe_attribute\n \t\t{ tree d;\n \t\t  split_specs_attrs ($<ttype>0, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n@@ -1970,70 +1937,70 @@ initdcl0:\n \t\t      used_extern_spec = 1;\n \t\t    }\n \t\t  $$ = suspend_momentary ();\n-\t\t  d = start_decl ($<ttype>1, current_declspecs, 0, $2);\n-\t\t  cplus_decl_attributes (d, $4, prefix_attributes);\n-\t\t  cp_finish_decl (d, NULL_TREE, $3, 1, 0); }\n+\t\t  d = start_decl ($<ttype>1, current_declspecs, 0);\n+\t\t  cplus_decl_attributes (d, $3, prefix_attributes);\n+\t\t  cp_finish_decl (d, NULL_TREE, $2, 1, 0); }\n \t;\n \n initdcl:\n-\t  declarator exception_specification_opt maybeasm maybe_attribute '='\n-\t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1, $2);\n-\t\t  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes); }\n+\t  declarator maybeasm maybe_attribute '='\n+\t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1);\n+\t\t  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ cp_finish_decl ($<ttype>6, $7, $3, 1, LOOKUP_ONLYCONVERTING); }\n-\t| declarator exception_specification_opt maybeasm maybe_attribute\n-\t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 0, $2);\n-\t\t  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes);\n-\t\t  cp_finish_decl ($<ttype>$, NULL_TREE, $3, 1, 0); }\n+\t\t{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING); }\n+\t| declarator maybeasm maybe_attribute\n+\t\t{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 0);\n+\t\t  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes);\n+\t\t  cp_finish_decl ($<ttype>$, NULL_TREE, $2, 1, 0); }\n \t;\n \n notype_initdcl0:\n-\t  notype_declarator exception_specification_opt maybeasm maybe_attribute '='\n+\t  notype_declarator maybeasm maybe_attribute '='\n \t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n-\t\t  $<itype>5 = suspend_momentary ();\n-\t\t  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1, $2);\n-\t\t  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes); }\n+\t\t  $<itype>4 = suspend_momentary ();\n+\t\t  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1);\n+\t\t  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ cp_finish_decl ($<ttype>6, $7, $3, 1, LOOKUP_ONLYCONVERTING);\n-\t\t  $$ = $<itype>5; }\n-\t| notype_declarator exception_specification_opt maybeasm maybe_attribute\n+\t\t{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING);\n+\t\t  $$ = $<itype>4; }\n+\t| notype_declarator maybeasm maybe_attribute\n \t\t{ tree d;\n \t\t  split_specs_attrs ($<ttype>0, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  $$ = suspend_momentary ();\n-\t\t  d = start_decl ($<ttype>1, current_declspecs, 0, $2);\n-\t\t  cplus_decl_attributes (d, $4, prefix_attributes);\n-\t\t  cp_finish_decl (d, NULL_TREE, $3, 1, 0); }\n+\t\t  d = start_decl ($<ttype>1, current_declspecs, 0);\n+\t\t  cplus_decl_attributes (d, $3, prefix_attributes);\n+\t\t  cp_finish_decl (d, NULL_TREE, $2, 1, 0); }\n \t;\n \n nomods_initdcl0:\n-\t  notype_declarator exception_specification_opt maybeasm maybe_attribute '='\n+\t  notype_declarator maybeasm maybe_attribute '='\n \t\t{ current_declspecs = NULL_TREE;\n \t\t  prefix_attributes = NULL_TREE;\n-\t\t  $<itype>5 = suspend_momentary ();\n-\t\t  $<ttype>$ = start_decl ($1, current_declspecs, 1, $2);\n-\t\t  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes); }\n+\t\t  $<itype>4 = suspend_momentary ();\n+\t\t  $<ttype>$ = start_decl ($1, current_declspecs, 1);\n+\t\t  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n-\t\t{ cp_finish_decl ($<ttype>6, $7, $3, 1, LOOKUP_ONLYCONVERTING);\n-\t\t  $$ = $<itype>5; }\n-\t| notype_declarator exception_specification_opt maybeasm maybe_attribute\n+\t\t{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING);\n+\t\t  $$ = $<itype>4; }\n+\t| notype_declarator maybeasm maybe_attribute\n \t\t{ tree d;\n \t\t  current_declspecs = NULL_TREE;\n \t\t  prefix_attributes = NULL_TREE;\n \t\t  $$ = suspend_momentary ();\n-\t\t  d = start_decl ($1, current_declspecs, 0, $2);\n-\t\t  cplus_decl_attributes (d, $4, prefix_attributes);\n-\t\t  cp_finish_decl (d, NULL_TREE, $3, 1, 0); }\n+\t\t  d = start_decl ($1, current_declspecs, 0);\n+\t\t  cplus_decl_attributes (d, $3, prefix_attributes);\n+\t\t  cp_finish_decl (d, NULL_TREE, $2, 1, 0); }\n \t;\n \n /* the * rules are dummies to accept the Apollo extended syntax\n    so that the header files compile.  */\n maybe_attribute:\n-      /* empty */\n+\t  /* empty */\n   \t\t{ $$ = NULL_TREE; }\n \t| attributes\n \t\t{ $$ = $1; }\n@@ -2059,7 +2026,7 @@ attribute_list:\n \t;\n  \n attrib:\n-    /* empty */\n+\t  /* empty */\n \t\t{ $$ = NULL_TREE; }\n \t| any_word\n \t\t{ $$ = build_tree_list ($1, NULL_TREE); }\n@@ -2078,19 +2045,19 @@ any_word:\n \t  identifier\n \t| SCSPEC\n \t| TYPESPEC\n-\t| TYPE_QUAL\n+\t| CV_QUALIFIER\n \t;\n \n /* A nonempty list of identifiers, including typenames.  */\n identifiers_or_typenames:\n-\tidentifier\n+\t  identifier\n \t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n \t| identifiers_or_typenames ',' identifier\n \t\t{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }\n \t;\n \n maybe_init:\n-\t%prec EMPTY /* empty */\n+\t  /* empty */  %prec EMPTY\n \t\t{ $$ = NULL_TREE; }\n \t| '=' init\n \t\t{ $$ = $2; }\n@@ -2099,7 +2066,7 @@ maybe_init:\n    initializer yet.  */\n \n init:\n-\t  expr_no_commas %prec '='\n+\t  expr_no_commas  %prec '='\n \t| '{' '}'\n \t\t{ $$ = build_nt (CONSTRUCTOR, NULL_TREE, NULL_TREE);\n \t\t  TREE_HAS_CONSTRUCTOR ($$) = 1; }\n@@ -2134,11 +2101,11 @@ initlist:\n fn.defpen:\n \tPRE_PARSED_FUNCTION_DECL\n \t\t{ start_function (NULL_TREE, TREE_VALUE ($1),\n-\t\t\t\t  NULL_TREE, NULL_TREE, 1);\n+\t\t\t\t  NULL_TREE, 1);\n \t\t  reinit_parse_for_function (); }\n \n pending_inlines:\n-\t/* empty */\n+\t  /* empty */\n \t| pending_inlines fn.defpen maybe_return_init ctor_initializer_opt\n \t  compstmt_or_error\n \t\t{\n@@ -2252,12 +2219,13 @@ maybecomma_warn:\n \t\t    pedwarn (\"comma at end of enumerator list\"); }\n \t;\n \n-aggr:\t  AGGR\n+aggr:\n+\t  AGGR\n \t| aggr SCSPEC\n \t\t{ error (\"storage class specifier `%s' not allowed after struct or class\", IDENTIFIER_POINTER ($2)); }\n \t| aggr TYPESPEC\n \t\t{ error (\"type specifier `%s' not allowed after struct or class\", IDENTIFIER_POINTER ($2)); }\n-\t| aggr TYPE_QUAL\n+\t| aggr CV_QUALIFIER\n \t\t{ error (\"type qualifier `%s' not allowed after struct or class\", IDENTIFIER_POINTER ($2)); }\n \t| aggr AGGR\n \t\t{ error (\"no body nor ';' separates two class, struct or union declarations\"); }\n@@ -2269,7 +2237,7 @@ named_class_head_sans_basetype:\n \t;\n \n named_class_head_sans_basetype_defn:\n-\t  aggr identifier_defn %prec EMPTY\n+\t  aggr identifier_defn  %prec EMPTY\n \t\t{ current_aggr = $$; $$ = $2; }\n \t;\n \n@@ -2294,15 +2262,16 @@ named_complex_class_head_sans_basetype:\n \t\t{ current_aggr = $$; $$ = $3; }\n \t;\n \n-do_xref_defn: /* empty */ %prec EMPTY\n-        { $<ttype>$ = xref_tag (current_aggr, $<ttype>0, NULL_TREE, 0); }\n+do_xref_defn:\n+\t  /* empty */  %prec EMPTY\n+\t\t{ $<ttype>$ = xref_tag (current_aggr, $<ttype>0, NULL_TREE, 0); }\n \t;\n \n named_class_head:\n-\t  named_class_head_sans_basetype %prec EMPTY\n+\t  named_class_head_sans_basetype  %prec EMPTY\n \t\t{ $$ = xref_tag (current_aggr, $1, NULL_TREE, 1); }\n \t| named_class_head_sans_basetype_defn do_xref_defn\n-          maybe_base_class_list %prec EMPTY\n+          maybe_base_class_list  %prec EMPTY\n \t\t{ \n \t\t  $$ = $<ttype>2;\n \t\t  if ($3)\n@@ -2336,17 +2305,21 @@ named_class_head:\n \t\t}\n \t;\n \n-unnamed_class_head: aggr '{'\n+unnamed_class_head:\n+\t  aggr '{'\n \t\t{ $$ = xref_tag ($$, make_anon_name (), NULL_TREE, 0);\n \t\t  yyungetc ('{', 1); }\n \t;\n \n-class_head: unnamed_class_head | named_class_head ;\n+class_head:\n+\t  unnamed_class_head\n+\t| named_class_head\n+\t;\n \n maybe_base_class_list:\n-\t  %prec EMPTY /* empty */\n+\t  /* empty */  %prec EMPTY\n \t\t{ $$ = NULL_TREE; }\n-\t| ':' see_typename %prec EMPTY\n+\t| ':' see_typename  %prec EMPTY\n \t\t{ yyungetc(':', 1); $$ = NULL_TREE; }\n \t| ':' see_typename base_class_list  %prec EMPTY\n \t\t{ $$ = $3; }\n@@ -2504,7 +2477,8 @@ base_class_access_list:\n \t\t    $$ = access_private_virtual_node; }\n \t;\n \n-left_curly: '{'\n+left_curly:\n+\t  '{'\n \t\t{ tree t = $<ttype>0;\n \t\t  push_obstacks_nochange ();\n \t\t  end_temporary_allocation ();\n@@ -2673,12 +2647,12 @@ component_decl_1:\n \t\t{ $$ = grok_x_components ($1.t, $2); }\n \t| declmods notype_components\n \t\t{ $$ = grok_x_components ($1, $2); }\n-\t| notype_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = grokfield ($$, NULL_TREE, $2, $5, $3,\n-\t\t\t\t  build_tree_list ($4, NULL_TREE)); }\n-\t| constructor_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = grokfield ($$, NULL_TREE, $2, $5, $3,\n-\t\t\t\t  build_tree_list ($4, NULL_TREE)); }\n+\t| notype_declarator maybeasm maybe_attribute maybe_init\n+\t\t{ $$ = grokfield ($$, NULL_TREE, $4, $2,\n+\t\t\t\t  build_tree_list ($3, NULL_TREE)); }\n+\t| constructor_declarator maybeasm maybe_attribute maybe_init\n+\t\t{ $$ = grokfield ($$, NULL_TREE, $4, $2,\n+\t\t\t\t  build_tree_list ($3, NULL_TREE)); }\n \t| ':' expr_no_commas\n \t\t{ $$ = grokbitfield (NULL_TREE, NULL_TREE, $2); }\n \t| error\n@@ -2692,13 +2666,13 @@ component_decl_1:\n \t   should \"A::foo\" be declared as a function or \"A::bar\" as a data\n \t   member? In other words, is \"bar\" an after_type_declarator or a\n \t   parmlist? */\n-\t| declmods component_constructor_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n+\t| declmods component_constructor_declarator maybeasm maybe_attribute maybe_init\n \t\t{ tree specs, attrs;\n \t\t  split_specs_attrs ($1, &specs, &attrs);\n-\t\t  $$ = grokfield ($2, specs, $3, $6, $4,\n-\t\t\t\t  build_tree_list ($5, attrs)); }\n-\t| component_constructor_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = grokfield ($$, NULL_TREE, $2, $5, $3, $4); }\n+\t\t  $$ = grokfield ($2, specs, $5, $3,\n+\t\t\t\t  build_tree_list ($4, attrs)); }\n+\t| component_constructor_declarator maybeasm maybe_attribute maybe_init\n+\t\t{ $$ = grokfield ($$, NULL_TREE, $4, $2, $3); }\n \t| using_decl\n \t\t{ $$ = do_class_using_decl ($1); }\n \t;\n@@ -2746,12 +2720,12 @@ component_declarator:\n \t;\n \n after_type_component_declarator0:\n-\t  after_type_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n+\t  after_type_declarator maybeasm maybe_attribute maybe_init\n \t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  $<ttype>0 = current_declspecs;\n-\t\t  $$ = grokfield ($$, current_declspecs, $2, $5, $3,\n-\t\t\t\t  build_tree_list ($4, prefix_attributes)); }\n+\t\t  $$ = grokfield ($$, current_declspecs, $4, $2,\n+\t\t\t\t  build_tree_list ($3, prefix_attributes)); }\n \t| TYPENAME ':' expr_no_commas maybe_attribute\n \t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n@@ -2761,18 +2735,18 @@ after_type_component_declarator0:\n \t;\n \n notype_component_declarator0:\n-\t  notype_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n+\t  notype_declarator maybeasm maybe_attribute maybe_init\n \t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  $<ttype>0 = current_declspecs;\n-\t\t  $$ = grokfield ($$, current_declspecs, $2, $5, $3,\n-\t\t\t\t  build_tree_list ($4, prefix_attributes)); }\n-\t| constructor_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n+\t\t  $$ = grokfield ($$, current_declspecs, $4, $2,\n+\t\t\t\t  build_tree_list ($3, prefix_attributes)); }\n+\t| constructor_declarator maybeasm maybe_attribute maybe_init\n \t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n \t\t  $<ttype>0 = current_declspecs;\n-\t\t  $$ = grokfield ($$, current_declspecs, $2, $5, $3,\n-\t\t\t\t  build_tree_list ($4, prefix_attributes)); }\n+\t\t  $$ = grokfield ($$, current_declspecs, $4, $2,\n+\t\t\t\t  build_tree_list ($3, prefix_attributes)); }\n \t| IDENTIFIER ':' expr_no_commas maybe_attribute\n \t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n@@ -2788,18 +2762,18 @@ notype_component_declarator0:\n \t;\n \n after_type_component_declarator:\n-\t  after_type_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = grokfield ($$, current_declspecs, $2, $5, $3,\n-\t\t\t\t  build_tree_list ($4, prefix_attributes)); }\n+\t  after_type_declarator maybeasm maybe_attribute maybe_init\n+\t\t{ $$ = grokfield ($$, current_declspecs, $4, $2,\n+\t\t\t\t  build_tree_list ($3, prefix_attributes)); }\n \t| TYPENAME ':' expr_no_commas maybe_attribute\n \t\t{ $$ = grokbitfield ($$, current_declspecs, $3);\n \t\t  cplus_decl_attributes ($$, $4, prefix_attributes); }\n \t;\n \n notype_component_declarator:\n-\t  notype_declarator exception_specification_opt maybeasm maybe_attribute maybe_init\n-\t\t{ $$ = grokfield ($$, current_declspecs, $2, $5, $3,\n-\t\t\t\t  build_tree_list ($4, prefix_attributes)); }\n+\t  notype_declarator maybeasm maybe_attribute maybe_init\n+\t\t{ $$ = grokfield ($$, current_declspecs, $4, $2,\n+\t\t\t\t  build_tree_list ($3, prefix_attributes)); }\n \t| IDENTIFIER ':' expr_no_commas maybe_attribute\n \t\t{ $$ = grokbitfield ($$, current_declspecs, $3);\n \t\t  cplus_decl_attributes ($$, $4, prefix_attributes); }\n@@ -2830,7 +2804,7 @@ new_type_id:\n \t  type_specifier_seq new_declarator\n \t\t{ $$.t = build_decl_list ($1.t, $2); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n-\t| type_specifier_seq %prec EMPTY\n+\t| type_specifier_seq  %prec EMPTY\n \t\t{ $$.t = build_decl_list ($1.t, NULL_TREE); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t/* GNU extension to allow arrays of arbitrary types with\n@@ -2845,18 +2819,18 @@ new_type_id:\n \t\t}\n \t;\n \n-type_quals:\n-\t  /* empty */ %prec EMPTY\n+cv_qualifiers:\n+\t  /* empty */  %prec EMPTY\n \t\t{ $$ = NULL_TREE; }\n-\t| type_quals TYPE_QUAL\n+\t| cv_qualifiers CV_QUALIFIER\n \t\t{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n \t;\n \n-nonempty_type_quals:\n-\t  TYPE_QUAL\n+nonempty_cv_qualifiers:\n+\t  CV_QUALIFIER\n \t\t{ $$.t = IDENTIFIER_AS_LIST ($1); \n \t\t  $$.new_type_flag = 0; }\n-\t| nonempty_type_quals TYPE_QUAL\n+\t| nonempty_cv_qualifiers CV_QUALIFIER\n \t\t{ $$.t = decl_tree_cons (NULL_TREE, $2, $1.t); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t;\n@@ -2865,12 +2839,13 @@ nonempty_type_quals:\n    and component declarations.  That way, longer rules are preferred.  */\n \n suspend_mom:\n-\t{ $<itype>$ = suspend_momentary (); } \n+\t  /* empty */\n+\t\t{ $<itype>$ = suspend_momentary (); } \n \n /* An expression which will not live on the momentary obstack.  */\n nonmomentary_expr:\n-\tsuspend_mom expr\n-\t{ resume_momentary ((int) $<itype>1); $$ = $2; }\n+\t  suspend_mom expr\n+\t\t{ resume_momentary ((int) $<itype>1); $$ = $2; }\n \t;\n \n /* An expression which will not live on the momentary obstack.  */\n@@ -2888,23 +2863,23 @@ maybe_parmlist:\n /* A declarator that is allowed only after an explicit typespec.  */\n /* may all be followed by prec '.' */\n after_type_declarator:\n-\t  '*' nonempty_type_quals after_type_declarator  %prec UNARY\n+\t  '*' nonempty_cv_qualifiers after_type_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2.t, $3); }\n-\t| '&' nonempty_type_quals after_type_declarator  %prec UNARY\n+\t| '&' nonempty_cv_qualifiers after_type_declarator  %prec UNARY\n \t\t{ $$ = make_reference_declarator ($2.t, $3); }\n \t| '*' after_type_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n \t| '&' after_type_declarator  %prec UNARY\n \t\t{ $$ = make_reference_declarator (NULL_TREE, $2); }\n-\t| ptr_to_mem type_quals after_type_declarator\n+\t| ptr_to_mem cv_qualifiers after_type_declarator\n \t\t{ tree arg = make_pointer_declarator ($2, $3);\n \t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n \t| direct_after_type_declarator\n \t;\n \n complete_type_name:\n-\t  type_name %prec EMPTY\n+\t  type_name  %prec EMPTY\n \t\t{\n \t\t  if (TREE_CODE ($1) == IDENTIFIER_NODE)\n \t\t    {\n@@ -2938,64 +2913,64 @@ complete_type_name:\n \t;\n \n nested_type:\n-\tnested_name_specifier type_name %prec EMPTY\n+\t  nested_name_specifier type_name  %prec EMPTY\n \t\t{ $$ = get_type_decl ($2); }\n \t;\n \n direct_after_type_declarator:\n-\t  direct_after_type_declarator maybe_parmlist type_quals %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, $2, $3); }\n+\t  direct_after_type_declarator maybe_parmlist cv_qualifiers exception_specification_opt  %prec '.'\n+\t\t{ $$ = make_call_declarator ($$, $2, $3, $4); }\n \t| direct_after_type_declarator '[' nonmomentary_expr ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, $3); }\n \t| direct_after_type_declarator '[' ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }\n \t| '(' after_type_declarator ')'\n \t\t{ $$ = $2; }\n-\t| nested_name_specifier type_name %prec EMPTY\n+\t| nested_name_specifier type_name  %prec EMPTY\n \t\t{ push_nested_class ($1, 3);\n \t\t  $$ = build_parse_node (SCOPE_REF, $$, $2);\n \t\t  TREE_COMPLEXITY ($$) = current_class_depth; }\n-\t| type_name %prec EMPTY\n+\t| type_name  %prec EMPTY\n \t;\n \n /* A declarator allowed whether or not there has been\n    an explicit typespec.  These cannot redeclare a typedef-name.  */\n \n notype_declarator:\n-\t  '*' nonempty_type_quals notype_declarator  %prec UNARY\n+\t  '*' nonempty_cv_qualifiers notype_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2.t, $3); }\n-\t| '&' nonempty_type_quals notype_declarator  %prec UNARY\n+\t| '&' nonempty_cv_qualifiers notype_declarator  %prec UNARY\n \t\t{ $$ = make_reference_declarator ($2.t, $3); }\n \t| '*' notype_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n \t| '&' notype_declarator  %prec UNARY\n \t\t{ $$ = make_reference_declarator (NULL_TREE, $2); }\n-\t| ptr_to_mem type_quals notype_declarator\n+\t| ptr_to_mem cv_qualifiers notype_declarator\n \t\t{ tree arg = make_pointer_declarator ($2, $3);\n \t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n \t| direct_notype_declarator\n \t;\n \n complex_notype_declarator:\n-\t  '*' nonempty_type_quals notype_declarator  %prec UNARY\n+\t  '*' nonempty_cv_qualifiers notype_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2.t, $3); }\n-\t| '&' nonempty_type_quals notype_declarator  %prec UNARY\n+\t| '&' nonempty_cv_qualifiers notype_declarator  %prec UNARY\n \t\t{ $$ = make_reference_declarator ($2.t, $3); }\n \t| '*' complex_notype_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n \t| '&' complex_notype_declarator  %prec UNARY\n \t\t{ $$ = make_reference_declarator (NULL_TREE, $2); }\n-\t| ptr_to_mem type_quals notype_declarator\n+\t| ptr_to_mem cv_qualifiers notype_declarator\n \t\t{ tree arg = make_pointer_declarator ($2, $3);\n \t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n \t| complex_direct_notype_declarator\n \t;\n \n complex_direct_notype_declarator:\n-\t  direct_notype_declarator maybe_parmlist type_quals  %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, $2, $3); }\n+\t  direct_notype_declarator maybe_parmlist cv_qualifiers exception_specification_opt  %prec '.'\n+\t\t{ $$ = make_call_declarator ($$, $2, $3, $4); }\n \t| '(' complex_notype_declarator ')'\n \t\t{ $$ = $2; }\n \t| direct_notype_declarator '[' nonmomentary_expr ']'\n@@ -3012,13 +2987,13 @@ complex_direct_notype_declarator:\n \t;\n \n qualified_id:\n-\tnested_name_specifier unqualified_id\n+\t  nested_name_specifier unqualified_id\n \t\t{ got_scope = NULL_TREE;\n \t\t  $$ = build_parse_node (SCOPE_REF, $$, $2); }\n \t;\n \n notype_qualified_id:\n-\tnested_name_specifier notype_unqualified_id\n+\t  nested_name_specifier notype_unqualified_id\n \t\t{ got_scope = NULL_TREE;\n \t\t  $$ = build_parse_node (SCOPE_REF, $$, $2); }\n \t;\n@@ -3034,14 +3009,14 @@ functional_cast:\n \t\t{ $$ = build_functional_cast ($1.t, $3); }\n \t| typespec '(' expr_or_declarator ')'\n \t\t{ $$ = reparse_decl_as_expr ($1.t, $3); }\n-\t| typespec fcast_or_absdcl %prec EMPTY\n+\t| typespec fcast_or_absdcl  %prec EMPTY\n \t\t{ $$ = reparse_absdcl_as_expr ($1.t, $2); }\n \t;\n \n type_name:\n \t  TYPENAME\n \t| SELFNAME\n-\t| template_type %prec EMPTY\n+\t| template_type  %prec EMPTY\n \t;\n \n nested_name_specifier:\n@@ -3119,23 +3094,23 @@ global_scope:\n \n /* ANSI new-declarator (5.3.4) */\n new_declarator:\n-\t  '*' type_quals new_declarator\n+\t  '*' cv_qualifiers new_declarator\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| '*' type_quals  %prec EMPTY\n+\t| '*' cv_qualifiers  %prec EMPTY\n \t\t{ $$ = make_pointer_declarator ($2, NULL_TREE); }\n-\t| '&' type_quals new_declarator %prec EMPTY\n+\t| '&' cv_qualifiers new_declarator  %prec EMPTY\n \t\t{ $$ = make_reference_declarator ($2, $3); }\n-\t| '&' type_quals %prec EMPTY\n+\t| '&' cv_qualifiers  %prec EMPTY\n \t\t{ $$ = make_reference_declarator ($2, NULL_TREE); }\n-\t| ptr_to_mem type_quals %prec EMPTY\n+\t| ptr_to_mem cv_qualifiers  %prec EMPTY\n \t\t{ tree arg = make_pointer_declarator ($2, NULL_TREE);\n \t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n-\t| ptr_to_mem type_quals new_declarator\n+\t| ptr_to_mem cv_qualifiers new_declarator\n \t\t{ tree arg = make_pointer_declarator ($2, $3);\n \t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n-\t| direct_new_declarator %prec EMPTY\n+\t| direct_new_declarator  %prec EMPTY\n \t;\n \n /* ANSI direct-new-declarator (5.3.4) */\n@@ -3148,31 +3123,31 @@ direct_new_declarator:\n \n /* ANSI abstract-declarator (8.1) */\n absdcl:\n-\t  '*' nonempty_type_quals absdcl\n+\t  '*' nonempty_cv_qualifiers absdcl\n \t\t{ $$ = make_pointer_declarator ($2.t, $3); }\n \t| '*' absdcl\n \t\t{ $$ = make_pointer_declarator (NULL_TREE, $2); }\n-\t| '*' nonempty_type_quals  %prec EMPTY\n+\t| '*' nonempty_cv_qualifiers  %prec EMPTY\n \t\t{ $$ = make_pointer_declarator ($2.t, NULL_TREE); }\n-\t| '*' %prec EMPTY\n+\t| '*'  %prec EMPTY\n \t\t{ $$ = make_pointer_declarator (NULL_TREE, NULL_TREE); }\n-\t| '&' nonempty_type_quals absdcl\n+\t| '&' nonempty_cv_qualifiers absdcl\n \t\t{ $$ = make_reference_declarator ($2.t, $3); }\n \t| '&' absdcl\n \t\t{ $$ = make_reference_declarator (NULL_TREE, $2); }\n-\t| '&' nonempty_type_quals %prec EMPTY\n+\t| '&' nonempty_cv_qualifiers  %prec EMPTY\n \t\t{ $$ = make_reference_declarator ($2.t, NULL_TREE); }\n-\t| '&' %prec EMPTY\n+\t| '&'  %prec EMPTY\n \t\t{ $$ = make_reference_declarator (NULL_TREE, NULL_TREE); }\n-\t| ptr_to_mem type_quals %prec EMPTY\n+\t| ptr_to_mem cv_qualifiers  %prec EMPTY\n \t\t{ tree arg = make_pointer_declarator ($2, NULL_TREE);\n \t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n-\t| ptr_to_mem type_quals absdcl\n+\t| ptr_to_mem cv_qualifiers absdcl\n \t\t{ tree arg = make_pointer_declarator ($2, $3);\n \t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n-\t| direct_abstract_declarator %prec EMPTY\n+\t| direct_abstract_declarator  %prec EMPTY\n \t;\n \n /* ANSI direct-abstract-declarator (8.1) */\n@@ -3181,20 +3156,20 @@ direct_abstract_declarator:\n \t\t{ $$ = $2; }\n \t  /* `(typedef)1' is `int'.  */\n \t| PAREN_STAR_PAREN\n-\t| direct_abstract_declarator '(' parmlist ')' type_quals  %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, $3, $5); }\n-\t| direct_abstract_declarator LEFT_RIGHT type_quals  %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $3); }\n+\t| direct_abstract_declarator '(' parmlist ')' cv_qualifiers exception_specification_opt  %prec '.'\n+\t\t{ $$ = make_call_declarator ($$, $3, $5, $6); }\n+\t| direct_abstract_declarator LEFT_RIGHT cv_qualifiers exception_specification_opt  %prec '.'\n+\t\t{ $$ = make_call_declarator ($$, empty_parms (), $3, $4); }\n \t| direct_abstract_declarator '[' nonmomentary_expr ']'  %prec '.'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, $3); }\n \t| direct_abstract_declarator '[' ']'  %prec '.'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }\n-\t| '(' complex_parmlist ')' type_quals  %prec '.'\n-\t\t{ $$ = build_parse_node (CALL_EXPR, NULL_TREE, $2, $4); }\n-\t| regcast_or_absdcl type_quals %prec '.'\n-\t\t{ TREE_OPERAND ($$, 2) = $2; }\n-\t| fcast_or_absdcl type_quals %prec '.'\n-\t\t{ TREE_OPERAND ($$, 2) = $2; }\n+\t| '(' complex_parmlist ')' cv_qualifiers exception_specification_opt  %prec '.'\n+\t\t{ $$ = make_call_declarator (NULL_TREE, $2, $4, $5); }\n+\t| regcast_or_absdcl cv_qualifiers exception_specification_opt  %prec '.'\n+\t\t{ set_quals_and_spec ($$, $2, $3); }\n+\t| fcast_or_absdcl cv_qualifiers exception_specification_opt  %prec '.'\n+\t\t{ set_quals_and_spec ($$, $2, $3); }\n \t| '[' nonmomentary_expr ']'  %prec '.'\n \t\t{ $$ = build_parse_node (ARRAY_REF, NULL_TREE, $2); }\n \t| '[' ']'  %prec '.'\n@@ -3212,18 +3187,21 @@ stmts:\n \t| stmts errstmt\n \t;\n \n-errstmt:  error ';'\n+errstmt:\n+\t  error ';'\n \t;\n \n /* build the LET_STMT node before parsing its contents,\n   so that any LET_STMTs within the context can have their display pointers\n   set up to point at this one.  */\n \n-.pushlevel:  /* empty */\n+.pushlevel:\n+\t  /* empty */\n \t\t{ do_pushlevel (); }\n \t;\n \n-.poplevel:   /* empty */\n+.poplevel:\n+\t  /* empty */\n \t\t{ $$ = do_poplevel (); }\n \t;\n \n@@ -3261,7 +3239,8 @@ compstmt_or_error:\n \t| error compstmt\n \t;\n \n-compstmt: '{'\n+compstmt:\n+\t  '{'\n \t\t{\n \t\t  if (current_template_parms)\n \t\t    {\n@@ -3385,11 +3364,9 @@ simple_stmt:\n \t\t}\n \t  .poplevel\n \t\t{ finish_stmt (); }\n-\t| simple_if %prec IF\n+\t| simple_if  %prec IF\n \t\t{ if (! current_template_parms) expand_end_cond ();\n-\t\t  expand_end_bindings (getdecls (), kept_level_p (), 1);\n-\t\t  poplevel (kept_level_p (), 1, 0);\n-\t\t  pop_momentary ();\n+\t\t  do_poplevel ();\n \t\t  finish_stmt (); }\n \t| WHILE\n \t\t{\n@@ -3560,9 +3537,7 @@ simple_stmt:\n \t\t  pop_momentary ();\n \t\t  if (flag_new_for_scope > 0)\n \t\t    {\n-\t\t      expand_end_bindings (getdecls (), kept_level_p (), 1);\n-\t\t      poplevel (kept_level_p (), 1, 0);\n-\t\t      pop_momentary ();\n+\t\t      do_poplevel ();\n \t\t    }\n \t\t  finish_stmt (); }\n \t| SWITCH .pushlevel '(' condition ')'\n@@ -3626,14 +3601,14 @@ simple_stmt:\n \t\t  c_expand_return ($2);\n \t\t  finish_stmt ();\n \t\t}\n-\t| asm_keyword maybe_type_qual '(' string ')' ';'\n+\t| asm_keyword maybe_cv_qualifier '(' string ')' ';'\n \t\t{ if (TREE_CHAIN ($4)) $4 = combine_strings ($4);\n \t\t  emit_line_note (input_filename, lineno);\n \t\t  expand_asm ($4);\n \t\t  finish_stmt ();\n \t\t}\n \t/* This is the case with just output operands.  */\n-\t| asm_keyword maybe_type_qual '(' string ':' asm_operands ')' ';'\n+\t| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ')' ';'\n \t\t{ if (TREE_CHAIN ($4)) $4 = combine_strings ($4);\n \t\t  emit_line_note (input_filename, lineno);\n \t\t  c_expand_asm_operands ($4, $6, NULL_TREE, NULL_TREE,\n@@ -3642,7 +3617,7 @@ simple_stmt:\n \t\t  finish_stmt ();\n \t\t}\n \t/* This is the case with input operands as well.  */\n-\t| asm_keyword maybe_type_qual '(' string ':' asm_operands ':' asm_operands ')' ';'\n+\t| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ':' asm_operands ')' ';'\n \t\t{ if (TREE_CHAIN ($4)) $4 = combine_strings ($4);\n \t\t  emit_line_note (input_filename, lineno);\n \t\t  c_expand_asm_operands ($4, $6, $8, NULL_TREE,\n@@ -3651,7 +3626,7 @@ simple_stmt:\n \t\t  finish_stmt ();\n \t\t}\n \t/* This is the case with clobbered registers as well.  */\n-\t| asm_keyword maybe_type_qual '(' string ':' asm_operands ':'\n+\t| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ':'\n \t  asm_operands ':' asm_clobbers ')' ';'\n \t\t{ if (TREE_CHAIN ($4)) $4 = combine_strings ($4);\n \t\t  emit_line_note (input_filename, lineno);\n@@ -3727,8 +3702,8 @@ handler_seq:\n \t;\n \n type_specifier_seq:\n-\t  typed_typespecs %prec EMPTY\n-\t| nonempty_type_quals %prec EMPTY\n+\t  typed_typespecs  %prec EMPTY\n+\t| nonempty_cv_qualifiers  %prec EMPTY\n \t;\n \n handler_args:\n@@ -3782,16 +3757,16 @@ for.init.statement:\n \n /* Either a type-qualifier or nothing.  First thing in an `asm' statement.  */\n \n-maybe_type_qual:\n-\t/* empty */\n+maybe_cv_qualifier:\n+\t  /* empty */\n \t\t{ emit_line_note (input_filename, lineno);\n \t\t  $$ = NULL_TREE; }\n-\t| TYPE_QUAL\n+\t| CV_QUALIFIER\n \t\t{ emit_line_note (input_filename, lineno); }\n \t;\n \n xexpr:\n-\t/* empty */\n+\t  /* empty */\n \t\t{ $$ = NULL_TREE; }\n \t| expr\n \t| error\n@@ -3800,7 +3775,8 @@ xexpr:\n \n /* These are the operands other than the first string and colon\n    in  asm (\"addextend %2,%1\": \"=dm\" (x), \"0\" (y), \"g\" (*x))  */\n-asm_operands: /* empty */\n+asm_operands:\n+\t  /* empty */\n \t\t{ $$ = NULL_TREE; }\n \t| nonnull_asm_operands\n \t;\n@@ -3829,7 +3805,8 @@ asm_clobbers:\n    In C++, declaring a function with no parameters\n    means that that function takes *no* parameters.  */\n \n-parmlist:  /* empty */\n+parmlist:\n+\t  /* empty */\n \t\t{\n \t\t  $$ = empty_parms();\n \t\t}\n@@ -3928,28 +3905,8 @@ parms_comma:\n \t;\n \n /* A single parameter declaration or parameter type name,\n-   as found in a parmlist.  The first four cases make up for 10%\n-   of the time spent parsing C++.  We cannot use them because\n-   of `int id[]' which won't get parsed properly.  */\n+   as found in a parmlist.  */\n named_parm:\n-/*\n-\t  typed_declspecs dont_see_typename '*' IDENTIFIER\n-\t\t{ tree specs = strip_attrs ($1.t);\n-\t\t  $$.t = build_tree_list (specs, build_parse_node (INDIRECT_REF, $4));\n-\t\t  $$.new_type_flag = $1.new_type_flag;\n-\t\t  see_typename (); }\n-\t| typed_declspecs dont_see_typename '&' IDENTIFIER\n-\t\t{ tree specs = strip_attrs ($1.t);\n-\t\t  $$.t = build_tree_list (specs, build_parse_node (ADDR_EXPR, $4));\n-\t\t  $$.new_type_flag = $1.new_type_flag;\n-\t\t  see_typename (); }\n-\t| TYPENAME IDENTIFIER\n-\t\t{ $$.t = build_tree_list (get_decl_list ($$), $2);  \n-\t\t  $$.new_type_flag = 0; }\n-\t| TYPESPEC IDENTIFIER\n-\t\t{ $$.t = build_tree_list (get_decl_list ($$), $2); \n-\t\t  $$.new_type_flag = 0; }\n-\t| */\n \t/* Here we expand typed_declspecs inline to avoid mis-parsing of\n \t   TYPESPEC IDENTIFIER.  */\n \t  typed_declspecs1 declarator\n@@ -3966,7 +3923,7 @@ named_parm:\n \t\t{ tree specs = strip_attrs ($1.t);\n \t\t  $$.t = build_tree_list (specs, $2);\n \t\t  $$.new_type_flag = $1.new_type_flag; }\n-\t| typed_declspecs1 %prec EMPTY\n+\t| typed_declspecs1  %prec EMPTY\n \t\t{ tree specs = strip_attrs ($1.t);\n \t\t  $$.t = build_tree_list (specs, NULL_TREE); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n@@ -3983,32 +3940,15 @@ full_parm:\n \t;\n \n parm:\n-\tnamed_parm\n+\t  named_parm\n \t| type_id\n \t;\n \n-see_typename: %prec EMPTY\n-\t{ see_typename (); }\n+see_typename:\n+\t  /* empty */  %prec EMPTY\n+\t\t{ see_typename (); }\n \t;\n \n-/* \n-dont_see_typename: %prec EMPTY\n-\t{ dont_see_typename (); }\n-\t; \n-\n-try_for_typename:\n-        {\n-\t  if ($<ttype>-1 == error_mark_node)\n-            $$ = 0;\n-          else\n-            {\n-              $$ = 1;\n-              pushclass ($<ttype>-1, 1);\n-            }\n-        }\n-\t;\n-*/\n-\n bad_parm:\n \t  /* empty */ %prec EMPTY\n \t\t{\n@@ -4026,11 +3966,11 @@ bad_parm:\n \t;\n \n exception_specification_opt:\n-\t  %prec EMPTY /* empty */\n+\t  /* empty */  %prec EMPTY\n \t\t{ $$ = NULL_TREE; }\n-\t| THROW '(' ansi_raise_identifiers  ')' %prec EMPTY\n+\t| THROW '(' ansi_raise_identifiers  ')'  %prec EMPTY\n \t\t{ $$ = $3; }\n-\t| THROW LEFT_RIGHT %prec EMPTY\n+\t| THROW LEFT_RIGHT  %prec EMPTY\n \t\t{ $$ = build_decl_list (NULL_TREE, NULL_TREE); }\n \t;\n \n@@ -4049,19 +3989,20 @@ ansi_raise_identifiers:\n \t;\n \n conversion_declarator:\n-\t  /* empty */ %prec EMPTY\n+\t  /* empty */  %prec EMPTY\n \t\t{ $$ = NULL_TREE; }\n-\t| '*' type_quals conversion_declarator\n+\t| '*' cv_qualifiers conversion_declarator\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n-\t| '&' type_quals conversion_declarator\n+\t| '&' cv_qualifiers conversion_declarator\n \t\t{ $$ = make_reference_declarator ($2, $3); }\n-\t| ptr_to_mem type_quals conversion_declarator\n+\t| ptr_to_mem cv_qualifiers conversion_declarator\n \t\t{ tree arg = make_pointer_declarator ($2, $3);\n \t\t  $$ = build_parse_node (SCOPE_REF, $1, arg);\n \t\t}\n \t;\n \n-operator: OPERATOR\n+operator:\n+\t  OPERATOR\n \t\t{ got_scope = NULL_TREE; }\n \t;\n \n@@ -4124,9 +4065,9 @@ operator_name:\n \t\t{ $$ = ansi_opname[CALL_EXPR]; }\n \t| operator '[' ']'\n \t\t{ $$ = ansi_opname[ARRAY_REF]; }\n-\t| operator NEW %prec EMPTY\n+\t| operator NEW  %prec EMPTY\n \t\t{ $$ = ansi_opname[NEW_EXPR]; }\n-\t| operator DELETE %prec EMPTY\n+\t| operator DELETE  %prec EMPTY\n \t\t{ $$ = ansi_opname[DELETE_EXPR]; }\n \t| operator NEW '[' ']'\n \t\t{ $$ = ansi_opname[VEC_NEW_EXPR]; }"}, {"sha": "f8161fae649cc4c6fa1283dc005636fd44ba78c6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -118,7 +118,7 @@ process_template_parm (list, next)\n       my_friendly_assert (TREE_CODE (TREE_PURPOSE (parm)) == TREE_LIST, 260);\n       /* is a const-param */\n       parm = grokdeclarator (TREE_VALUE (parm), TREE_PURPOSE (parm),\n-\t\t\t     PARM, 0, NULL_TREE, NULL_TREE);\n+\t\t\t     PARM, 0, NULL_TREE);\n       /* A template parameter is not modifiable.  */\n       TREE_READONLY (parm) = 1;\n       if (IS_AGGR_TYPE (TREE_TYPE (parm))\n@@ -1761,7 +1761,8 @@ tsubst (t, args, nargs, in_decl)\n       {\n \ttree values = TYPE_ARG_TYPES (t);\n \ttree context = TYPE_CONTEXT (t);\n-\ttree new_value;\n+\ttree raises = TYPE_RAISES_EXCEPTIONS (t);\n+\ttree fntype;\n \n \t/* Don't bother recursing if we know it won't change anything.\t*/\n \tif (values != void_list_node)\n@@ -1777,7 +1778,7 @@ tsubst (t, args, nargs, in_decl)\n \t\ttree value\n \t\t  = tsubst (TREE_VALUE (values), args, nargs, in_decl);\n \t\ttree purpose = tsubst_expr (TREE_PURPOSE (values),\n-\t\t\t\t       args, nargs, in_decl);\n+\t\t\t\t\t    args, nargs, in_decl);\n \t\ttree x = build_tree_list (purpose, value);\n \n \t\tif (first)\n@@ -1807,34 +1808,39 @@ tsubst (t, args, nargs, in_decl)\n \tif (TREE_CODE (t) == FUNCTION_TYPE\n \t    && context == NULL_TREE)\n \t  {\n-\t    new_value = build_function_type (type, values);\n+\t    fntype = build_function_type (type, values);\n \t  }\n \telse if (context == NULL_TREE)\n \t  {\n \t    tree base = tsubst (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))),\n \t\t\t\targs, nargs, in_decl);\n-\t    new_value = build_cplus_method_type (base, type,\n-\t\t\t\t\t\t TREE_CHAIN (values));\n+\t    fntype = build_cplus_method_type (base, type,\n+\t\t\t\t\t      TREE_CHAIN (values));\n \t  }\n \telse\n \t  {\n-\t    new_value = make_node (TREE_CODE (t));\n-\t    TREE_TYPE (new_value) = type;\n-\t    TYPE_CONTEXT (new_value) = context;\n-\t    TYPE_VALUES (new_value) = values;\n-\t    TYPE_SIZE (new_value) = TYPE_SIZE (t);\n-\t    TYPE_ALIGN (new_value) = TYPE_ALIGN (t);\n-\t    TYPE_MODE (new_value) = TYPE_MODE (t);\n+\t    fntype = make_node (TREE_CODE (t));\n+\t    TREE_TYPE (fntype) = type;\n+\t    TYPE_CONTEXT (fntype) = context;\n+\t    TYPE_VALUES (fntype) = values;\n+\t    TYPE_SIZE (fntype) = TYPE_SIZE (t);\n+\t    TYPE_ALIGN (fntype) = TYPE_ALIGN (t);\n+\t    TYPE_MODE (fntype) = TYPE_MODE (t);\n \t    if (TYPE_METHOD_BASETYPE (t))\n-\t      TYPE_METHOD_BASETYPE (new_value) = tsubst (TYPE_METHOD_BASETYPE (t),\n-\t\t\t\t\t\t\t args, nargs, in_decl);\n+\t      TYPE_METHOD_BASETYPE (fntype) = tsubst (TYPE_METHOD_BASETYPE (t),\n+\t\t\t\t\t\t      args, nargs, in_decl);\n \t    /* Need to generate hash value.  */\n \t    my_friendly_abort (84);\n \t  }\n-\tnew_value = build_type_variant (new_value,\n-\t\t\t\t\tTYPE_READONLY (t),\n-\t\t\t\t\tTYPE_VOLATILE (t));\n-\treturn new_value;\n+\tfntype = build_type_variant (fntype,\n+\t\t\t\t     TYPE_READONLY (t),\n+\t\t\t\t     TYPE_VOLATILE (t));\n+\tif (raises)\n+\t  {\n+\t    raises = tsubst (raises, args, nargs, in_decl);\n+\t    fntype = build_exception_variant (fntype, raises);\n+\t  }\n+\treturn fntype;\n       }\n     case ARRAY_TYPE:\n       {\n@@ -1880,9 +1886,11 @@ tsubst (t, args, nargs, in_decl)\n \t tsubst_expr (TREE_OPERAND (t, 1), args, nargs, in_decl));\n \n     case CALL_EXPR:\n-      return build_parse_node\n-\t(CALL_EXPR, tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl),\n-\t tsubst (TREE_OPERAND (t, 1), args, nargs, in_decl), NULL_TREE);\n+      return make_call_declarator\n+\t(tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl),\n+\t tsubst (TREE_OPERAND (t, 1), args, nargs, in_decl),\n+\t TREE_OPERAND (t, 2),\n+\t tsubst (TREE_TYPE (t), args, nargs, in_decl));\n \n     case SCOPE_REF:\n       return build_parse_node\n@@ -2182,9 +2190,8 @@ tsubst_expr (t, args, nargs, in_decl)\n \tdcl = start_decl\n \t  (tsubst (TREE_OPERAND (t, 0), args, nargs, in_decl),\n \t   tsubst (TREE_OPERAND (t, 1), args, nargs, in_decl),\n-\t   TREE_OPERAND (t, 3) != 0,\n-\t   tsubst (TREE_OPERAND (t, 2), args, nargs, in_decl));\n-\tinit = tsubst_expr (TREE_OPERAND (t, 3), args, nargs, in_decl);\n+\t   TREE_OPERAND (t, 2) != 0);\n+\tinit = tsubst_expr (TREE_OPERAND (t, 2), args, nargs, in_decl);\n \tcp_finish_decl\n \t  (dcl, init, NULL_TREE, 1, /*init ? LOOKUP_ONLYCONVERTING :*/ 0);\n \tresume_momentary (i);\n@@ -3057,8 +3064,7 @@ void\n do_function_instantiation (declspecs, declarator, storage)\n      tree declspecs, declarator, storage;\n {\n-  tree decl = grokdeclarator (declarator, declspecs, NORMAL, 0,\n-\t\t\t      NULL_TREE, NULL_TREE);\n+  tree decl = grokdeclarator (declarator, declspecs, NORMAL, 0, NULL_TREE);\n   tree name;\n   tree fn;\n   tree result = NULL_TREE;\n@@ -3354,7 +3360,7 @@ instantiate_decl (d)\n       lineno = DECL_SOURCE_LINE (d);\n       input_filename = DECL_SOURCE_FILE (d);\n \n-      start_function (NULL_TREE, d, NULL_TREE, NULL_TREE, 1);\n+      start_function (NULL_TREE, d, NULL_TREE, 1);\n       store_parm_decls ();\n \n       if (t && TREE_CODE (t) == RETURN_INIT)"}, {"sha": "69513ac9d7a25821f7fe8f396de189c4753fc29e", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -25,6 +25,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"cp-tree.h\"\n #include \"flags.h\"\n #include \"output.h\"\n+#include \"assert.h\"\n \n #undef NULL\n #define NULL 0\n@@ -348,7 +349,7 @@ build_dynamic_cast (type, expr)\n {\n   enum tree_code tc = TREE_CODE (type);\n   tree exprtype = TREE_TYPE (expr);\n-  enum tree_code ec = TREE_CODE (exprtype);\n+  enum tree_code ec;\n   tree dcast_fn;\n \n   if (type == error_mark_node || expr == error_mark_node)\n@@ -360,6 +361,9 @@ build_dynamic_cast (type, expr)\n       return t;\n     }\n \n+  assert (exprtype != NULL_TREE);\n+  ec = TREE_CODE (exprtype);\n+\n   switch (tc)\n     {\n     case POINTER_TYPE:\n@@ -977,7 +981,7 @@ synthesize_tinfo_fn (fndecl)\n   DECL_ALIGN (tdecl) = TYPE_ALIGN (ptr_type_node);\n   cp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0, 0);\n \n-  start_function (NULL_TREE, fndecl, NULL_TREE, NULL_TREE, 1);\n+  start_function (NULL_TREE, fndecl, NULL_TREE, 1);\n   store_parm_decls ();\n   clear_last_expr ();\n   push_momentary ();"}, {"sha": "7e53de6d220970d66a4455a02bb4bed6248e4268", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -919,17 +919,19 @@ save_this (instance)\n /* Build a signature member function call.  Looks up the signature table\n    entry corresponding to FUNCTION.  Depending on the value of the CODE\n    field, either call the function in PFN directly, or use OFFSET to\n-   index INSTANCE's virtual function table.  */\n+   index the object's virtual function table.  */\n \n tree\n-build_signature_method_call (basetype, instance, function, parms)\n-     tree basetype, instance, function, parms;\n+build_signature_method_call (function, parms)\n+     tree function, parms;\n {\n+  tree instance = TREE_VALUE (parms);\n   tree saved_instance = save_this (instance);\t/* Create temp for `this'.  */\n   tree object_ptr = build_optr_ref (saved_instance);\n   tree new_object_ptr, new_parms;\n   tree signature_tbl_ptr = build_sptr_ref (saved_instance);\n   tree sig_field_name = DECL_NAME (DECL_MEMFUNC_POINTER_TO (function));\n+  tree basetype = DECL_CONTEXT (function);\n   tree basetype_path = TYPE_BINFO (basetype);\n   tree tbl_entry = build_component_ref (build1 (INDIRECT_REF, basetype,\n \t\t\t\t\t\tsignature_tbl_ptr),"}, {"sha": "ceb9acc3aece97009bc1852e5dfa5753dee155cf", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -215,6 +215,9 @@ build_cplus_new (type, init)\n   tree slot;\n   tree rval;\n \n+  if (TREE_CODE (init) == TARGET_EXPR || init == error_mark_node)\n+    return init;\n+\n   slot = build (VAR_DECL, type);\n   layout_decl (slot, 0);\n   rval = build (NEW_EXPR, type,"}, {"sha": "944acc62e4659069dc15303ef66be56445f7d6c7", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 252, "deletions": 85, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c11b6f21eb1adddea58b8701442030dc84d49474/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c11b6f21eb1adddea58b8701442030dc84d49474", "patch": "@@ -1966,9 +1966,14 @@ build_indirect_ref (ptr, errorstring)\n      tree ptr;\n      char *errorstring;\n {\n-  register tree pointer = (TREE_CODE (TREE_TYPE (ptr)) == REFERENCE_TYPE ?\n-\t\t\t   ptr : default_conversion (ptr));\n-  register tree type = TREE_TYPE (pointer);\n+  register tree pointer, type;\n+\n+  if (ptr == error_mark_node)\n+    return error_mark_node;\n+\n+  pointer = (TREE_CODE (TREE_TYPE (ptr)) == REFERENCE_TYPE\n+\t     ? ptr : default_conversion (ptr));\n+  type = TREE_TYPE (pointer);\n \n   if (ptr == current_class_ptr)\n     return current_class_ref;\n@@ -5054,139 +5059,247 @@ tree\n build_static_cast (type, expr)\n    tree type, expr;\n {\n+  tree intype, binfo;\n+  int ok;\n+\n+  if (type == error_mark_node || expr == error_mark_node)\n+    return error_mark_node;\n+\n+  if (TREE_CODE (expr) == OFFSET_REF)\n+    expr = resolve_offset_ref (expr);\n+\n   if (current_template_parms)\n     {\n       tree t = build_min (STATIC_CAST_EXPR, type, expr);\n       return t;\n     }\n \n-  return build_c_cast (type, expr, 0);\n+  /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n+     Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */\n+  if (TREE_CODE (type) != REFERENCE_TYPE\n+      && TREE_CODE (expr) == NOP_EXPR\n+      && TREE_TYPE (expr) == TREE_TYPE (TREE_OPERAND (expr, 0)))\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  if (TREE_CODE (type) == VOID_TYPE)\n+    return build1 (CONVERT_EXPR, type, expr);\n+\n+  if (type_unknown_p (expr))\n+    {\n+      expr = instantiate_type (type, expr, 1);\n+      if (expr == error_mark_node)\n+\treturn error_mark_node;\n+    }\n+\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    return (convert_from_reference\n+\t    (convert_to_reference (type, expr, CONV_STATIC|CONV_IMPLICIT,\n+\t\t\t\t   LOOKUP_COMPLAIN, NULL_TREE)));\n+\n+  if (IS_AGGR_TYPE (type))\n+    return build_cplus_new\n+      (type, (build_method_call\n+\t      (NULL_TREE, ctor_identifier, build_tree_list (NULL_TREE, expr),\n+\t       TYPE_BINFO (type), LOOKUP_NORMAL)));\n+\n+  expr = decay_conversion (expr);\n+  intype = TREE_TYPE (expr);\n+\n+  /* FIXME handle casting to array type.  */\n+\n+  ok = 0;\n+  if (can_convert_arg (type, intype, expr))\n+    ok = 1;\n+  else if (TYPE_PTROB_P (type) && TYPE_PTROB_P (intype))\n+    {\n+      tree binfo;\n+      if (IS_AGGR_TYPE (TREE_TYPE (type)) && IS_AGGR_TYPE (TREE_TYPE (intype))\n+\t  && (TYPE_READONLY (TREE_TYPE (type))\n+\t      >= TYPE_READONLY (TREE_TYPE (intype)))\n+\t  && (TYPE_VOLATILE (TREE_TYPE (type))\n+\t      >= TYPE_VOLATILE (TREE_TYPE (intype)))\n+\t  && (binfo = get_binfo (TREE_TYPE (intype), TREE_TYPE (type), 0))\n+\t  && ! TREE_VIA_VIRTUAL (binfo))\n+\tok = 1;\n+    }\n+  else if (TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n+    {\n+      if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type))),\n+\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (intype))), 1)\n+\t  && (TYPE_READONLY (TREE_TYPE (TREE_TYPE (type)))\n+\t      >= TYPE_READONLY (TREE_TYPE (TREE_TYPE (intype))))\n+\t  && (TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (type)))\n+\t      >= TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (intype))))\n+\t  && (binfo = get_binfo (TYPE_OFFSET_BASETYPE (intype),\n+\t\t\t\t TYPE_OFFSET_BASETYPE (type), 0))\n+\t  && ! TREE_VIA_VIRTUAL (binfo))\n+\tok = 1;\n+    }\n+  else if (TREE_CODE (intype) != BOOLEAN_TYPE\n+\t   && TREE_CODE (type) != ARRAY_TYPE\n+\t   && TREE_CODE (type) != FUNCTION_TYPE\n+\t   && can_convert (intype, type))\n+    ok = 1;\n+\n+  if (ok)\n+    return build_c_cast (type, expr, 0);\n+\n+  cp_error (\"static_cast from `%T' to `%T'\", intype, type);\n+  return error_mark_node;\n }\n \n tree\n build_reinterpret_cast (type, expr)\n    tree type, expr;\n {\n-  tree intype = TREE_TYPE (expr);\n+  tree intype;\n+\n+  if (type == error_mark_node || expr == error_mark_node)\n+    return error_mark_node;\n+\n+  if (TREE_CODE (expr) == OFFSET_REF)\n+    expr = resolve_offset_ref (expr);\n \n   if (current_template_parms)\n     {\n       tree t = build_min (REINTERPRET_CAST_EXPR, type, expr);\n       return t;\n     }\n \n-  if (TYPE_PTRMEMFUNC_P (type))\n-    if (TYPE_PTRMEMFUNC_P (intype))\n-      return build1 (NOP_EXPR, type, expr);\n+  if (TREE_CODE (type) != REFERENCE_TYPE)\n+    {\n+      expr = decay_conversion (expr);\n+\n+      /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n+\t Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */\n+      if (TREE_CODE (expr) == NOP_EXPR\n+\t  && TREE_TYPE (expr) == TREE_TYPE (TREE_OPERAND (expr, 0)))\n+\texpr = TREE_OPERAND (expr, 0);\n+    }\n+\n+  if (type_unknown_p (expr))\n+    {\n+      expr = instantiate_type (type, expr, 1);\n+      if (expr == error_mark_node)\n+\treturn error_mark_node;\n+    }\n \n-  if (TYPE_PTRMEMFUNC_P (type))\n-    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n+  intype = TREE_TYPE (expr);\n \n-  if (TYPE_PTRMEMFUNC_P (intype))\n-    intype = TYPE_PTRMEMFUNC_FN_TYPE (intype);\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    {\n+      if (! real_lvalue_p (expr))\n+\t{\n+\t  cp_error (\"reinterpret_cast from `%T' rvalue to `%T'\", intype, type);\n+\t  return error_mark_node;\n+\t}\n+      expr = build_unary_op (ADDR_EXPR, expr, 0);\n+      if (expr != error_mark_node)\n+\texpr = build_reinterpret_cast\n+\t  (build_pointer_type (TREE_TYPE (type)), expr);\n+      if (expr != error_mark_node)\n+\texpr = build_indirect_ref (expr, 0);\n+      return expr;\n+    }\n+  else if (comptypes (TYPE_MAIN_VARIANT (intype), TYPE_MAIN_VARIANT (type), 1))\n+    return build_static_cast (type, expr);\n \n-  if (! POINTER_TYPE_P (type) && ! TREE_CODE (type) == INTEGER_TYPE)\n+  if (TYPE_PTR_P (type) && (TREE_CODE (intype) == INTEGER_TYPE\n+\t\t\t    || TREE_CODE (intype) == ENUMERAL_TYPE))\n+    /* OK */;\n+  else if (TREE_CODE (type) == INTEGER_TYPE && TYPE_PTR_P (intype))\n     {\n-      cp_error (\"reinterpret_cast cannot convert to type `%T'\", type);\n-      return error_mark_node;\n+      if (TYPE_PRECISION (type) < TYPE_PRECISION (intype))\n+\tcp_pedwarn (\"reinterpret_cast from `%T' to `%T' loses precision\",\n+\t\t    intype, type);\n     }\n-  if (! POINTER_TYPE_P (intype) && ! TREE_CODE (intype) == INTEGER_TYPE)\n+  else if ((TYPE_PTRFN_P (type) && TYPE_PTRFN_P (intype))\n+\t   || (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype)))\n     {\n-      cp_error (\"reinterpret_cast cannot convert from type `%T'\", type);\n-      return error_mark_node;\n+      if (TREE_READONLY_DECL_P (expr))\n+\texpr = decl_constant_value (expr);\n+      return fold (build1 (NOP_EXPR, type, expr));\n     }\n-  if (TREE_CODE (type) == INTEGER_TYPE && TREE_CODE (intype) != POINTER_TYPE)\n+  else if ((TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n+\t   || (TYPE_PTROBV_P (type) && TYPE_PTROBV_P (intype)))\n     {\n-      cp_error (\"reinterpret_cast cannot convert non-pointer type `%T' to `%T'\",\n-\t\tintype, type);\n-      return error_mark_node;\n+      if (! comp_ptr_ttypes_reinterpret (TREE_TYPE (type), TREE_TYPE (intype)))\n+\tcp_pedwarn (\"reinterpret_cast from `%T' to `%T' casts away const (or volatile)\",\n+\t\t    intype, type);\n+\n+      if (TREE_READONLY_DECL_P (expr))\n+\texpr = decl_constant_value (expr);\n+      return fold (build1 (NOP_EXPR, type, expr));\n     }\n-  if (TREE_CODE (intype) == INTEGER_TYPE && TREE_CODE (type) != POINTER_TYPE)\n+  else\n     {\n-      cp_error (\"reinterpret_cast cannot convert `%T' to non-pointer type `%T'\",\n-\t\tintype, type);\n+      cp_error (\"reinterpret_cast from `%T' to `%T'\", intype, type);\n       return error_mark_node;\n     }\n-\n-  if (TREE_CODE (type) == POINTER_TYPE && TREE_CODE (intype) == POINTER_TYPE)\n-    expr = convert (ptr_type_node, expr);\n-\n-  return build_c_cast (type, expr, 0);\n+      \n+  return convert (type, expr);\n }\n \n tree\n build_const_cast (type, expr)\n    tree type, expr;\n {\n-  tree intype = TREE_TYPE (expr);\n-  tree t1, t2;\n+  tree intype;\n \n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n \n+  if (TREE_CODE (expr) == OFFSET_REF)\n+    expr = resolve_offset_ref (expr);\n+\n   if (current_template_parms)\n     {\n       tree t = build_min (CONST_CAST_EXPR, type, expr);\n       return t;\n     }\n \n-  if (TYPE_PTRMEMFUNC_P (type))\n-    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n-  if (TYPE_PTRMEMFUNC_P (intype))\n-    intype = TYPE_PTRMEMFUNC_FN_TYPE (intype);\n-\n-  if (! POINTER_TYPE_P (type))\n-    {\n-      cp_error (\"const_cast cannot convert to non-pointer type `%T'\", type);\n-      return error_mark_node;\n-    }\n-  if (TREE_CODE (type) == REFERENCE_TYPE && ! real_lvalue_p (expr))\n+  if (TREE_CODE (type) != REFERENCE_TYPE)\n     {\n-      cp_error (\"const_cast cannot convert rvalue to type `%T'\", type);\n-      return error_mark_node;\n-    }\n-  if (TREE_CODE (type) == POINTER_TYPE && TREE_CODE (intype) != POINTER_TYPE)\n-    {\n-      cp_error (\"const_cast cannot convert non-pointer type `%T' to type `%T'\",\n-\t\tintype, type);\n-      return error_mark_node;\n+      expr = decay_conversion (expr);\n+\n+      /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n+\t Strip such NOP_EXPRs if VALUE is being used in non-lvalue context.  */\n+      if (TREE_CODE (expr) == NOP_EXPR\n+\t  && TREE_TYPE (expr) == TREE_TYPE (TREE_OPERAND (expr, 0)))\n+\texpr = TREE_OPERAND (expr, 0);\n     }\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n+  if (type_unknown_p (expr))\n     {\n-      t1 = TREE_TYPE (type);\n-      t2 = intype;\n+      expr = instantiate_type (type, expr, 1);\n+      if (expr == error_mark_node)\n+\treturn error_mark_node;\n     }\n-  else\n-    {\n-      t1 = TREE_TYPE (type);\n-      t2 = TREE_TYPE (intype);\n \n-      for (; TREE_CODE (t1) == POINTER_TYPE && TREE_CODE (t2) == POINTER_TYPE;\n-\t   t1 = TREE_TYPE (t1), t2 = TREE_TYPE (t2))\n-\t;\n-    }\n+  intype = TREE_TYPE (expr);\n \n-  if (TREE_CODE (t1) == OFFSET_TYPE && TREE_CODE (t2) == OFFSET_TYPE)\n+  if (comptypes (TYPE_MAIN_VARIANT (intype), TYPE_MAIN_VARIANT (type), 1))\n+    return build_static_cast (type, expr);\n+  else if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n-      if (TYPE_OFFSET_BASETYPE (t1) != TYPE_OFFSET_BASETYPE (t2))\n+      if (! real_lvalue_p (expr))\n \t{\n-\t  cp_error (\"const_cast cannot convert between pointers to members of different types `%T' and `%T'\",\n-\t\t    TYPE_OFFSET_BASETYPE (t2), TYPE_OFFSET_BASETYPE (t1));\n+\t  cp_error (\"const_cast from `%T' rvalue to `%T'\", intype, type);\n \t  return error_mark_node;\n \t}\n-      t1 = TREE_TYPE (t1);\n-      t2 = TREE_TYPE (t2);\n-    }\n \n-  if (TYPE_MAIN_VARIANT (t1) != TYPE_MAIN_VARIANT (t2))\n-    {\n-      cp_error (\"const_cast cannot convert unrelated type `%T' to `%T'\",\n-\t\tt2, t1);\n-      return error_mark_node;\n+      if (comp_ptr_ttypes_const (TREE_TYPE (type), intype))\n+\treturn (convert_from_reference\n+\t\t(convert_to_reference (type, expr, CONV_CONST|CONV_IMPLICIT,\n+\t\t\t\t       LOOKUP_COMPLAIN, NULL_TREE)));\n     }\n+  else if (TREE_CODE (type) == POINTER_TYPE\n+\t   && TREE_CODE (intype) == POINTER_TYPE\n+\t   && comp_ptr_ttypes_const (TREE_TYPE (type), TREE_TYPE (intype)))\n+    return convert (type, expr);\n \n-  return build_c_cast (type, expr, 0);\n+  cp_error (\"const_cast from `%T' to `%T'\", intype, type);\n+  return error_mark_node;\n }\n \n /* Build an expression representing a cast to type TYPE of expression EXPR.\n@@ -5348,15 +5461,9 @@ build_c_cast (type, expr, allow_nonconverting)\n     }\n \n     /* Always produce some operator for an explicit cast,\n-       so we can tell (for -pedantic) that the cast is no lvalue.\n-       Also, pedantically, don't let (void *) (FOO *) 0 be a null\n-       pointer constant.  */\n-  if (TREE_CODE (type) != REFERENCE_TYPE\n-      && (value == expr\n-\t  || (pedantic\n-\t      && TREE_CODE (value) == INTEGER_CST\n-\t      && TREE_CODE (expr) == INTEGER_CST\n-\t      && TREE_CODE (TREE_TYPE (expr)) != INTEGER_TYPE)))\n+       so we can tell (for -pedantic) that the cast is no lvalue.  */\n+  if (TREE_CODE (type) != REFERENCE_TYPE && value == expr\n+      && real_lvalue_p (value))\n     value = non_lvalue (value);\n \n   return value;\n@@ -7261,7 +7368,8 @@ comp_ptr_ttypes_real (to, from, constp)\n \treturn 0;\n \n       if (TREE_CODE (from) == OFFSET_TYPE\n-\t  && TYPE_OFFSET_BASETYPE (from) == TYPE_OFFSET_BASETYPE (to))\n+\t  && comptypes (TYPE_OFFSET_BASETYPE (from),\n+\t\t\tTYPE_OFFSET_BASETYPE (to), 1))\n \t  continue;\n \n       /* Const and volatile mean something different for function types,\n@@ -7317,3 +7425,62 @@ ptr_reasonably_similar (to, from)\n \t  (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), -1);\n     }\n }\n+\n+/* Like comp_ptr_ttypes, for const_cast.  */\n+\n+int\n+comp_ptr_ttypes_const (to, from)\n+     tree to, from;\n+{\n+  for (; ; to = TREE_TYPE (to), from = TREE_TYPE (from))\n+    {\n+      if (TREE_CODE (to) != TREE_CODE (from))\n+\treturn 0;\n+\n+      if (TREE_CODE (from) == OFFSET_TYPE\n+\t  && comptypes (TYPE_OFFSET_BASETYPE (from),\n+\t\t\tTYPE_OFFSET_BASETYPE (to), 1))\n+\t  continue;\n+\n+      if (TREE_CODE (to) != POINTER_TYPE)\n+\treturn comptypes (TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), 1);\n+    }\n+}\n+\n+/* Like comp_ptr_ttypes, for reinterpret_cast.  */\n+\n+int\n+comp_ptr_ttypes_reinterpret (to, from)\n+     tree to, from;\n+{\n+  int constp = 1;\n+\n+  for (; ; to = TREE_TYPE (to), from = TREE_TYPE (from))\n+    {\n+      if (TREE_CODE (from) == OFFSET_TYPE)\n+\tfrom = TREE_TYPE (from);\n+      if (TREE_CODE (to) == OFFSET_TYPE)\n+\tto = TREE_TYPE (to);\n+\n+      if (TREE_CODE (to) != TREE_CODE (from))\n+\treturn 1;\n+\n+      /* Const and volatile mean something different for function types,\n+\t so the usual checks are not appropriate.  */\n+      if (TREE_CODE (to) != FUNCTION_TYPE && TREE_CODE (to) != METHOD_TYPE)\n+\t{\n+\t  if (TYPE_READONLY (from) > TYPE_READONLY (to)\n+\t      || TYPE_VOLATILE (from) > TYPE_VOLATILE (to))\n+\t    return 0;\n+\n+\t  if (! constp\n+\t      && (TYPE_READONLY (to) > TYPE_READONLY (from)\n+\t\t  || TYPE_VOLATILE (to) > TYPE_READONLY (from)))\n+\t    return 0;\n+\t  constp &= TYPE_READONLY (to);\n+\t}\n+\n+      if (TREE_CODE (to) != POINTER_TYPE)\n+\treturn 1;\n+    }\n+}"}]}