{"sha": "fda935a2da8e5c3c371fc44977bd9083c18d8423", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRhOTM1YTJkYThlNWMzYzM3MWZjNDQ5NzdiZDkwODNjMThkODQyMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2004-04-05T16:41:19Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2004-04-05T16:41:19Z"}, "message": "PR optimization/13424 (hppa), bootstrap/14462, c/14828\n\n\tPR optimization/13424 (hppa), bootstrap/14462, c/14828\n\t* pa.md: Use replace_equiv_address to retain the attributes of the\n\tmemory operands used in the split and peephole2 patterns for optimizing\n\tthe pre-reload movstrsi, movstrdi, clrstrsi and clrstrdi patterns.\n\nCo-Authored-By: John David Anglin <dave.anglin@nrc-cnrc.gc.ca>\n\nFrom-SVN: r80433", "tree": {"sha": "0736135d057e9b7c8ea9938156e05cdd8c0b65e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0736135d057e9b7c8ea9938156e05cdd8c0b65e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fda935a2da8e5c3c371fc44977bd9083c18d8423", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fda935a2da8e5c3c371fc44977bd9083c18d8423", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fda935a2da8e5c3c371fc44977bd9083c18d8423", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fda935a2da8e5c3c371fc44977bd9083c18d8423/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "355f774decfb49bcf46ce97a6a62a5b89db5e57f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355f774decfb49bcf46ce97a6a62a5b89db5e57f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/355f774decfb49bcf46ce97a6a62a5b89db5e57f"}], "stats": {"total": 188, "additions": 132, "deletions": 56}, "files": [{"sha": "db54eaa39327df17a7606f33073df4a953340283", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fda935a2da8e5c3c371fc44977bd9083c18d8423/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fda935a2da8e5c3c371fc44977bd9083c18d8423/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fda935a2da8e5c3c371fc44977bd9083c18d8423", "patch": "@@ -1,3 +1,11 @@\n+2004-04-05  Jakub Jelinek  <jakub@redhat.com>\n+\t  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR optimization/13424 (hppa), bootstrap/14462, c/14828\n+\t* pa.md: Use replace_equiv_address to retain the attributes of the\n+\tmemory operands used in the split and peephole2 patterns for optimizing\n+\tthe pre-reload movstrsi, movstrdi, clrstrsi and clrstrdi patterns.\n+\n 2004-04-05  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* c-decl.c (build_compound_literal): Use TYPE_READONLY."}, {"sha": "96355248d2266aecbf16fb466631730a3215be7e", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 124, "deletions": 56, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fda935a2da8e5c3c371fc44977bd9083c18d8423/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fda935a2da8e5c3c371fc44977bd9083c18d8423/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=fda935a2da8e5c3c371fc44977bd9083c18d8423", "patch": "@@ -3206,19 +3206,23 @@\n   [(set_attr \"type\" \"multi,multi\")])\n \n (define_split\n-  [(parallel [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"\"))\n-\t\t   (mem:BLK (match_operand:SI 1 \"register_operand\" \"\")))\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t\t   (match_operand:BLK 1 \"memory_operand\" \"\"))\n \t      (clobber (match_operand:SI 2 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 3 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 6 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 7 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 8 \"register_operand\" \"\"))\n \t      (use (match_operand:SI 4 \"arith_operand\" \"\"))\n \t      (use (match_operand:SI 5 \"const_int_operand\" \"\"))])]\n-  \"!TARGET_64BIT && reload_completed && !flag_peephole2\"\n-  [(set (match_dup 7) (match_dup 0))\n-   (set (match_dup 8) (match_dup 1))\n-   (parallel [(set (mem:BLK (match_dup 7)) (mem:BLK (match_dup 8)))\n+  \"!TARGET_64BIT && reload_completed && !flag_peephole2\n+   && GET_CODE (operands[0]) == MEM\n+   && register_operand (XEXP (operands[0], 0), SImode)\n+   && GET_CODE (operands[1]) == MEM\n+   && register_operand (XEXP (operands[1], 0), SImode)\"\n+  [(set (match_dup 7) (match_dup 9))\n+   (set (match_dup 8) (match_dup 10))\n+   (parallel [(set (match_dup 0) (match_dup 1))\n    \t      (clobber (match_dup 2))\n    \t      (clobber (match_dup 3))\n    \t      (clobber (match_dup 6))\n@@ -3227,20 +3231,30 @@\n    \t      (use (match_dup 4))\n    \t      (use (match_dup 5))\n \t      (const_int 0)])]\n-  \"\")\n+  \"\n+{\n+  operands[9] = XEXP (operands[0], 0);\n+  operands[10] = XEXP (operands[1], 0);\n+  operands[0] = replace_equiv_address (operands[0], operands[7]);\n+  operands[1] = replace_equiv_address (operands[1], operands[8]);\n+}\")\n \n (define_peephole2\n-  [(parallel [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"\"))\n-\t\t   (mem:BLK (match_operand:SI 1 \"register_operand\" \"\")))\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t\t   (match_operand:BLK 1 \"memory_operand\" \"\"))\n \t      (clobber (match_operand:SI 2 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 3 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 6 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 7 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 8 \"register_operand\" \"\"))\n \t      (use (match_operand:SI 4 \"arith_operand\" \"\"))\n \t      (use (match_operand:SI 5 \"const_int_operand\" \"\"))])]\n-  \"!TARGET_64BIT\"\n-  [(parallel [(set (mem:BLK (match_dup 7)) (mem:BLK (match_dup 8)))\n+  \"!TARGET_64BIT\n+   && GET_CODE (operands[0]) == MEM\n+   && register_operand (XEXP (operands[0], 0), SImode)\n+   && GET_CODE (operands[1]) == MEM\n+   && register_operand (XEXP (operands[1], 0), SImode)\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n    \t      (clobber (match_dup 2))\n    \t      (clobber (match_dup 3))\n    \t      (clobber (match_dup 6))\n@@ -3251,15 +3265,23 @@\n \t      (const_int 0)])]\n   \"\n {\n-  if (dead_or_set_p (curr_insn, operands[0]))\n-    operands[7] = operands[0];\n+  rtx addr = XEXP (operands[0], 0);\n+  if (dead_or_set_p (curr_insn, addr))\n+    operands[7] = addr;\n   else\n-    emit_insn (gen_rtx_SET (VOIDmode, operands[7], operands[0]));\n+    {\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[7], addr));\n+      operands[0] = replace_equiv_address (operands[0], operands[7]);\n+    }\n \n-  if (dead_or_set_p (curr_insn, operands[1]))\n-    operands[8] = operands[1];\n+  addr = XEXP (operands[1], 0);\n+  if (dead_or_set_p (curr_insn, addr))\n+    operands[8] = addr;\n   else\n-    emit_insn (gen_rtx_SET (VOIDmode, operands[8], operands[1]));\n+    {\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[8], addr));\n+      operands[1] = replace_equiv_address (operands[1], operands[8]);\n+    }\n }\")\n \n (define_insn \"movstrsi_postreload\"\n@@ -3372,19 +3394,23 @@\n   [(set_attr \"type\" \"multi,multi\")])\n \n (define_split\n-  [(parallel [(set (mem:BLK (match_operand:DI 0 \"register_operand\" \"\"))\n-\t\t   (mem:BLK (match_operand:DI 1 \"register_operand\" \"\")))\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t\t   (match_operand:BLK 1 \"memory_operand\" \"\"))\n \t      (clobber (match_operand:DI 2 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 3 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 6 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 7 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 8 \"register_operand\" \"\"))\n \t      (use (match_operand:DI 4 \"arith_operand\" \"\"))\n \t      (use (match_operand:DI 5 \"const_int_operand\" \"\"))])]\n-  \"TARGET_64BIT && reload_completed && !flag_peephole2\"\n-  [(set (match_dup 7) (match_dup 0))\n-   (set (match_dup 8) (match_dup 1))\n-   (parallel [(set (mem:BLK (match_dup 7)) (mem:BLK (match_dup 8)))\n+  \"TARGET_64BIT && reload_completed && !flag_peephole2\n+   && GET_CODE (operands[0]) == MEM\n+   && register_operand (XEXP (operands[0], 0), DImode)\n+   && GET_CODE (operands[1]) == MEM\n+   && register_operand (XEXP (operands[1], 0), DImode)\"\n+  [(set (match_dup 7) (match_dup 9))\n+   (set (match_dup 8) (match_dup 10))\n+   (parallel [(set (match_dup 0) (match_dup 1))\n    \t      (clobber (match_dup 2))\n    \t      (clobber (match_dup 3))\n    \t      (clobber (match_dup 6))\n@@ -3393,20 +3419,30 @@\n    \t      (use (match_dup 4))\n    \t      (use (match_dup 5))\n \t      (const_int 0)])]\n-  \"\")\n+  \"\n+{\n+  operands[9] = XEXP (operands[0], 0);\n+  operands[10] = XEXP (operands[1], 0);\n+  operands[0] = replace_equiv_address (operands[0], operands[7]);\n+  operands[1] = replace_equiv_address (operands[1], operands[8]);\n+}\")\n \n (define_peephole2\n-  [(parallel [(set (mem:BLK (match_operand:DI 0 \"register_operand\" \"\"))\n-\t\t   (mem:BLK (match_operand:DI 1 \"register_operand\" \"\")))\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+\t\t   (match_operand:BLK 1 \"memory_operand\" \"\"))\n \t      (clobber (match_operand:DI 2 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 3 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 6 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 7 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 8 \"register_operand\" \"\"))\n \t      (use (match_operand:DI 4 \"arith_operand\" \"\"))\n \t      (use (match_operand:DI 5 \"const_int_operand\" \"\"))])]\n-  \"TARGET_64BIT\"\n-  [(parallel [(set (mem:BLK (match_dup 7)) (mem:BLK (match_dup 8)))\n+  \"TARGET_64BIT\n+   && GET_CODE (operands[0]) == MEM\n+   && register_operand (XEXP (operands[0], 0), DImode)\n+   && GET_CODE (operands[1]) == MEM\n+   && register_operand (XEXP (operands[1], 0), DImode)\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n    \t      (clobber (match_dup 2))\n    \t      (clobber (match_dup 3))\n    \t      (clobber (match_dup 6))\n@@ -3417,15 +3453,23 @@\n \t      (const_int 0)])]\n   \"\n {\n-  if (dead_or_set_p (curr_insn, operands[0]))\n-    operands[7] = operands[0];\n+  rtx addr = XEXP (operands[0], 0);\n+  if (dead_or_set_p (curr_insn, addr))\n+    operands[7] = addr;\n   else\n-    emit_insn (gen_rtx_SET (VOIDmode, operands[7], operands[0]));\n+    {\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[7], addr));\n+      operands[0] = replace_equiv_address (operands[0], operands[7]);\n+    }\n \n-  if (dead_or_set_p (curr_insn, operands[1]))\n-    operands[8] = operands[1];\n+  addr = XEXP (operands[1], 0);\n+  if (dead_or_set_p (curr_insn, addr))\n+    operands[8] = addr;\n   else\n-    emit_insn (gen_rtx_SET (VOIDmode, operands[8], operands[1]));\n+    {\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[8], addr));\n+      operands[1] = replace_equiv_address (operands[1], operands[8]);\n+    }\n }\")\n \n (define_insn \"movstrdi_postreload\"\n@@ -3491,42 +3535,54 @@\n   [(set_attr \"type\" \"multi,multi\")])\n \n (define_split\n-  [(parallel [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"\"))\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n \t\t   (const_int 0))\n \t      (clobber (match_operand:SI 1 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 4 \"register_operand\" \"\"))\n \t      (use (match_operand:SI 2 \"arith_operand\" \"\"))\n \t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))])]\n-  \"!TARGET_64BIT && reload_completed && !flag_peephole2\"\n-  [(set (match_dup 4) (match_dup 0))\n-   (parallel [(set (mem:BLK (match_dup 4)) (const_int 0))\n+  \"!TARGET_64BIT && reload_completed && !flag_peephole2\n+   && GET_CODE (operands[0]) == MEM\n+   && register_operand (XEXP (operands[0], 0), SImode)\"\n+  [(set (match_dup 4) (match_dup 5))\n+   (parallel [(set (match_dup 0) (const_int 0))\n    \t      (clobber (match_dup 1))\n    \t      (clobber (match_dup 4))\n    \t      (use (match_dup 2))\n    \t      (use (match_dup 3))\n \t      (const_int 0)])]\n-  \"\")\n+  \"\n+{\n+  operands[5] = XEXP (operands[0], 0);\n+  operands[0] = replace_equiv_address (operands[0], operands[4]);\n+}\")\n \n (define_peephole2\n-  [(parallel [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"\"))\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n \t\t   (const_int 0))\n \t      (clobber (match_operand:SI 1 \"register_operand\" \"\"))\n \t      (clobber (match_operand:SI 4 \"register_operand\" \"\"))\n \t      (use (match_operand:SI 2 \"arith_operand\" \"\"))\n \t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))])]\n-  \"!TARGET_64BIT\"\n-  [(parallel [(set (mem:BLK (match_dup 4)) (const_int 0))\n+  \"!TARGET_64BIT\n+   && GET_CODE (operands[0]) == MEM\n+   && register_operand (XEXP (operands[0], 0), SImode)\"\n+  [(parallel [(set (match_dup 0) (const_int 0))\n    \t      (clobber (match_dup 1))\n    \t      (clobber (match_dup 4))\n    \t      (use (match_dup 2))\n    \t      (use (match_dup 3))\n \t      (const_int 0)])]\n   \"\n {\n-  if (dead_or_set_p (curr_insn, operands[0]))\n-    operands[4] = operands[0];\n+  rtx addr = XEXP (operands[0], 0);\n+  if (dead_or_set_p (curr_insn, addr))\n+    operands[4] = addr;\n   else\n-    emit_insn (gen_rtx_SET (VOIDmode, operands[4], operands[0]));\n+    {\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[4], addr));\n+      operands[0] = replace_equiv_address (operands[0], operands[4]);\n+    }\n }\")\n \n (define_insn \"clrstrsi_postreload\"\n@@ -3589,42 +3645,54 @@\n   [(set_attr \"type\" \"multi,multi\")])\n \n (define_split\n-  [(parallel [(set (mem:BLK (match_operand:DI 0 \"register_operand\" \"\"))\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n \t\t   (const_int 0))\n \t      (clobber (match_operand:DI 1 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 4 \"register_operand\" \"\"))\n \t      (use (match_operand:DI 2 \"arith_operand\" \"\"))\n \t      (use (match_operand:DI 3 \"const_int_operand\" \"\"))])]\n-  \"TARGET_64BIT && reload_completed && !flag_peephole2\"\n-  [(set (match_dup 4) (match_dup 0))\n-   (parallel [(set (mem:BLK (match_dup 4)) (const_int 0))\n+  \"TARGET_64BIT && reload_completed && !flag_peephole2\n+   && GET_CODE (operands[0]) == MEM\n+   && register_operand (XEXP (operands[0], 0), DImode)\"\n+  [(set (match_dup 4) (match_dup 5))\n+   (parallel [(set (match_dup 0) (const_int 0))\n    \t      (clobber (match_dup 1))\n    \t      (clobber (match_dup 4))\n    \t      (use (match_dup 2))\n    \t      (use (match_dup 3))\n \t      (const_int 0)])]\n-  \"\")\n+  \"\n+{\n+  operands[5] = XEXP (operands[0], 0);\n+  operands[0] = replace_equiv_address (operands[0], operands[4]);\n+}\")\n \n (define_peephole2\n-  [(parallel [(set (mem:BLK (match_operand:DI 0 \"register_operand\" \"\"))\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n \t\t   (const_int 0))\n \t      (clobber (match_operand:DI 1 \"register_operand\" \"\"))\n \t      (clobber (match_operand:DI 4 \"register_operand\" \"\"))\n \t      (use (match_operand:DI 2 \"arith_operand\" \"\"))\n \t      (use (match_operand:DI 3 \"const_int_operand\" \"\"))])]\n-  \"TARGET_64BIT\"\n-  [(parallel [(set (mem:BLK (match_dup 4)) (const_int 0))\n+  \"TARGET_64BIT\n+   && GET_CODE (operands[0]) == MEM\n+   && register_operand (XEXP (operands[0], 0), DImode)\"\n+  [(parallel [(set (match_dup 0) (const_int 0))\n    \t      (clobber (match_dup 1))\n    \t      (clobber (match_dup 4))\n    \t      (use (match_dup 2))\n    \t      (use (match_dup 3))\n \t      (const_int 0)])]\n   \"\n {  \n-  if (dead_or_set_p (curr_insn, operands[0]))\n-    operands[4] = operands[0];\n+  rtx addr = XEXP (operands[0], 0);\n+  if (dead_or_set_p (curr_insn, addr))\n+    operands[4] = addr;\n   else\n-    emit_insn (gen_rtx_SET (VOIDmode, operands[4], operands[0]));\n+    {\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[4], addr));\n+      operands[0] = replace_equiv_address (operands[0], operands[4]);\n+    }\n }\")\n \n (define_insn \"clrstrdi_postreload\""}]}