{"sha": "5817ff8e5f722e2a36ed6982f94d003164c01992", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTgxN2ZmOGU1ZjcyMmUyYTM2ZWQ2OTgyZjk0ZDAwMzE2NGMwMTk5Mg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2008-01-10T02:07:41Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-01-10T02:07:41Z"}, "message": "multiway_merge.h: Reformat to 80 columns; adjust some inline specifiers; other minor style fixes.\n\n2008-01-09  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/parallel/multiway_merge.h: Reformat to 80 columns;\n\tadjust some inline specifiers; other minor style fixes.\n\t* include/parallel/losertree.h: Likewise.\n\t* include/parallel/list_partition.h: Likewise.\n\t* include/parallel/multiseq_selection.h: Likewise.\n\t* include/parallel/workstealing.h: Likewise.\n\t* include/parallel/base.h: Likewise.\n\t* include/parallel/par_loop.h: Likewise.\n\t* include/parallel/numeric: Likewise.\n\t* include/parallel/quicksort.h: Likewise.\n\t* include/parallel/algorithmfwd.h: Likewise.\n\t* include/parallel/for_each_selectors.h: Likewise.\n\t* include/parallel/omp_loop_static.h: Likewise.\n\t* include/parallel/random_shuffle.h: Likewise.\n\t* include/parallel/balanced_quicksort.h: Likewise.\n\t* include/parallel/set_operations.h: Likewise.\n\t* include/parallel/tree.h: Likewise.\n\t* include/parallel/merge.h: Likewise.\n\t* include/parallel/unique_copy.h: Likewise.\n\t* include/parallel/settings.h: Likewise.\n\t* include/parallel/multiway_mergesort.h: Likewise.\n\t* include/parallel/numericfwd.h: Likewise.\n\t* include/parallel/search.h: Likewise.\n\t* include/parallel/partition.h: Likewise.\n\t* include/parallel/compatibility.h: Likewise.\n\t* include/parallel/partial_sum.h: Likewise.\n\t* include/parallel/find.h: Likewise.\n\t* include/parallel/algo.h: Likewise.\n\t* include/parallel/queue.h: Likewise.\n\t* include/parallel/omp_loop.h: Likewise.\n\t* include/parallel/sort.h: Likewise.\n\t* include/parallel/random_number.h: Likewise.\n\nFrom-SVN: r131440", "tree": {"sha": "5060e35f2e0473b6627ef590ec71e1576524772b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5060e35f2e0473b6627ef590ec71e1576524772b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5817ff8e5f722e2a36ed6982f94d003164c01992", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5817ff8e5f722e2a36ed6982f94d003164c01992", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5817ff8e5f722e2a36ed6982f94d003164c01992", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5817ff8e5f722e2a36ed6982f94d003164c01992/comments", "author": null, "committer": null, "parents": [{"sha": "299f57348c2199656476e39b43643d04bdad1985", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/299f57348c2199656476e39b43643d04bdad1985", "html_url": "https://github.com/Rust-GCC/gccrs/commit/299f57348c2199656476e39b43643d04bdad1985"}], "stats": {"total": 7305, "additions": 3910, "deletions": 3395}, "files": [{"sha": "30d58857f832bcddbda0a46e6904fd16cabb03c7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,3 +1,38 @@\n+2008-01-09  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/parallel/multiway_merge.h: Reformat to 80 columns;\n+\tadjust some inline specifiers; other minor style fixes.\n+\t* include/parallel/losertree.h: Likewise.\n+\t* include/parallel/list_partition.h: Likewise.\n+\t* include/parallel/multiseq_selection.h: Likewise.\n+\t* include/parallel/workstealing.h: Likewise.\n+\t* include/parallel/base.h: Likewise.\n+\t* include/parallel/par_loop.h: Likewise.\n+\t* include/parallel/numeric: Likewise.\n+\t* include/parallel/quicksort.h: Likewise.\n+\t* include/parallel/algorithmfwd.h: Likewise.\n+\t* include/parallel/for_each_selectors.h: Likewise.\n+\t* include/parallel/omp_loop_static.h: Likewise.\n+\t* include/parallel/random_shuffle.h: Likewise.\n+\t* include/parallel/balanced_quicksort.h: Likewise.\n+\t* include/parallel/set_operations.h: Likewise.\n+\t* include/parallel/tree.h: Likewise.\n+\t* include/parallel/merge.h: Likewise.\n+\t* include/parallel/unique_copy.h: Likewise.\n+\t* include/parallel/settings.h: Likewise.\n+\t* include/parallel/multiway_mergesort.h: Likewise.\n+\t* include/parallel/numericfwd.h: Likewise.\n+\t* include/parallel/search.h: Likewise.\n+\t* include/parallel/partition.h: Likewise.\n+\t* include/parallel/compatibility.h: Likewise.\n+\t* include/parallel/partial_sum.h: Likewise.\n+\t* include/parallel/find.h: Likewise.\n+\t* include/parallel/algo.h: Likewise.\n+\t* include/parallel/queue.h: Likewise.\n+\t* include/parallel/omp_loop.h: Likewise.\n+\t* include/parallel/sort.h: Likewise.\n+\t* include/parallel/random_number.h: Likewise.\n+\n 2008-01-09  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* docs/html/17_intro/api.html: Fix markup for rope.h."}, {"sha": "47f305dca32fe67e68a8657f36da9ff6b315a120", "filename": "libstdc++-v3/include/parallel/algo.h", "status": "modified", "additions": 81, "deletions": 121, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -90,12 +90,10 @@ namespace __parallel\n \t\t    __gnu_parallel::parallelism parallelism_tag\n \t\t    = __gnu_parallel::parallel_balanced)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end - begin)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      for_each_minimal_n\n-\t\t\t\t      && __gnu_parallel::\n-\t\t\t\t      is_parallel(parallelism_tag)))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t    >= __gnu_parallel::Settings::for_each_minimal_n\n+\t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  bool dummy;\n \t  __gnu_parallel::for_each_selector<RandomAccessIterator>\n@@ -333,10 +331,9 @@ namespace __parallel\n \t\t       RandomAccessOutputIterator out, Predicate pred, \n \t\t       random_access_iterator_tag, random_access_iterator_tag)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(last - begin)\n-\t\t\t\t      > __gnu_parallel::Settings::\n-\t\t\t\t      unique_copy_minimal_n))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(last - begin)\n+\t    > __gnu_parallel::Settings::unique_copy_minimal_n))\n \treturn __gnu_parallel::parallel_unique_copy(begin, last, out, pred);\n       else\n \treturn _GLIBCXX_STD_P::unique_copy(begin, last, out, pred);\n@@ -414,14 +411,11 @@ namespace __parallel\n \t\t     random_access_iterator_tag, random_access_iterator_tag, \n \t\t     random_access_iterator_tag)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end1 - begin1)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      set_union_minimal_n\n-\t\t\t\t      || static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end2 - begin2)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      set_union_minimal_n))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1)\n+\t    >= __gnu_parallel::Settings::set_union_minimal_n\n+\t    || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2)\n+\t    >= __gnu_parallel::Settings::set_union_minimal_n))\n \treturn __gnu_parallel::parallel_set_union(begin1, end1,\n \t\t\t\t\t\t  begin2, end2, result, pred);\n       else\n@@ -523,14 +517,11 @@ namespace __parallel\n \t\t\t    random_access_iterator_tag,\n \t\t\t    random_access_iterator_tag)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end1 - begin1)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      set_union_minimal_n\n-\t\t\t\t      || static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end2 - begin2)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      set_union_minimal_n))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1)\n+\t    >= __gnu_parallel::Settings::set_union_minimal_n\n+\t    || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2)\n+\t    >= __gnu_parallel::Settings::set_union_minimal_n))\n \treturn __gnu_parallel::parallel_set_intersection(begin1, end1, begin2, \n \t\t\t\t\t\t\t end2, result, pred);\n       else\n@@ -639,14 +630,11 @@ namespace __parallel\n \t\t\t\t    random_access_iterator_tag,\n \t\t\t\t    random_access_iterator_tag)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end1 - begin1)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      set_symmetric_difference_minimal_n\n-\t\t\t\t      || static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end2 - begin2)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      set_symmetric_difference_minimal_n))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1)\n+\t    >= __gnu_parallel::Settings::set_symmetric_difference_minimal_n\n+\t    || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2)\n+\t    >= __gnu_parallel::Settings::set_symmetric_difference_minimal_n))\n \treturn __gnu_parallel::parallel_set_symmetric_difference(begin1, end1,\n \t\t\t\t\t\t\t\t begin2, end2,\n \t\t\t\t\t\t\t\t result, pred);\n@@ -751,14 +739,11 @@ namespace __parallel\n \t\t\t  random_access_iterator_tag,\n \t\t\t  random_access_iterator_tag)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end1 - begin1)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      set_difference_minimal_n\n-\t\t\t\t      || static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end2 - begin2)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      set_difference_minimal_n))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1)\n+\t    >= __gnu_parallel::Settings::set_difference_minimal_n\n+\t    || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2)\n+\t    >= __gnu_parallel::Settings::set_difference_minimal_n))\n \treturn __gnu_parallel::parallel_set_difference(begin1, end1,\n \t\t\t\t\t\t       begin2, end2,\n \t\t\t\t\t\t       result, pred);\n@@ -926,12 +911,10 @@ namespace __parallel\n       typedef typename traits_type::difference_type difference_type;\n       typedef __gnu_parallel::sequence_index_t sequence_index_t;\n \n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<sequence_index_t>\n-\t\t\t\t      (end - begin)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      count_minimal_n\n-\t\t\t\t      && __gnu_parallel::\n-\t\t\t\t      is_parallel(parallelism_tag)))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<sequence_index_t>(end - begin)\n+\t    >= __gnu_parallel::Settings::count_minimal_n\n+\t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  __gnu_parallel::count_selector<RandomAccessIterator, difference_type>\n \t    functionality;\n@@ -996,12 +979,10 @@ namespace __parallel\n       typedef typename traits_type::difference_type difference_type;\n       typedef __gnu_parallel::sequence_index_t sequence_index_t;\n \n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<sequence_index_t>\n-\t\t\t\t      (end - begin)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      count_minimal_n\n-\t\t\t\t      && __gnu_parallel::\n-\t\t\t\t      is_parallel(parallelism_tag)))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<sequence_index_t>(end - begin)\n+\t    >= __gnu_parallel::Settings::count_minimal_n\n+\t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  difference_type res = 0;\n \t  __gnu_parallel::\n@@ -1239,12 +1220,10 @@ namespace __parallel\n \t\t      __gnu_parallel::parallelism parallelism_tag\n \t\t      = __gnu_parallel::parallel_balanced)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end - begin)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      transform_minimal_n\n-\t\t\t\t      && __gnu_parallel::\n-\t\t\t\t      is_parallel(parallelism_tag)))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t    >= __gnu_parallel::Settings::transform_minimal_n\n+\t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  bool dummy = true;\n \t  typedef __gnu_parallel::iterator_pair<RandomAccessIterator1,\n@@ -1330,11 +1309,9 @@ namespace __parallel\n \t\t      __gnu_parallel::parallelism parallelism_tag \n \t\t      = __gnu_parallel::parallel_balanced)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION((end1 - begin1)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      transform_minimal_n\n-\t\t\t\t      && __gnu_parallel::\n-\t\t\t\t      is_parallel(parallelism_tag)))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    (end1 - begin1) >= __gnu_parallel::Settings::transform_minimal_n\n+\t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  bool dummy = true;\n \t  typedef __gnu_parallel::iterator_triple<RandomAccessIterator1,\n@@ -1489,12 +1466,10 @@ namespace __parallel\n \t\t      __gnu_parallel::parallelism parallelism_tag\n \t\t      = __gnu_parallel::parallel_balanced)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end - begin)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      replace_minimal_n\n-\t\t\t\t      && __gnu_parallel::\n-\t\t\t\t      is_parallel(parallelism_tag)))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t    >= __gnu_parallel::Settings::replace_minimal_n\n+\t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  bool dummy;\n \t  __gnu_parallel::\n@@ -1556,12 +1531,10 @@ namespace __parallel\n \t\t    __gnu_parallel::parallelism parallelism_tag\n \t\t    = __gnu_parallel::parallel_balanced)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end - begin)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      generate_minimal_n\n-\t\t\t\t      && __gnu_parallel::\n-\t\t\t\t      is_parallel(parallelism_tag)))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t    >= __gnu_parallel::Settings::generate_minimal_n\n+\t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  bool dummy;\n \t  __gnu_parallel::generate_selector<RandomAccessIterator>\n@@ -1686,10 +1659,9 @@ namespace __parallel\n     {\n       if (begin == end)\n \treturn;\n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end - begin)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      random_shuffle_minimal_n))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t    >= __gnu_parallel::Settings::random_shuffle_minimal_n))\n \t__gnu_parallel::parallel_random_shuffle(begin, end, rand);\n       else\n \t__gnu_parallel::sequential_random_shuffle(begin, end, rand);\n@@ -1715,10 +1687,9 @@ namespace __parallel\n     partition_switch(RandomAccessIterator begin, RandomAccessIterator end,\n \t\t     Predicate pred, random_access_iterator_tag)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end - begin)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      partition_minimal_n))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t    >= __gnu_parallel::Settings::partition_minimal_n))\n \t{\n \t  typedef typename std::iterator_traits<RandomAccessIterator>::\n \t    difference_type difference_type;\n@@ -1775,10 +1746,9 @@ namespace __parallel\n \n       if (begin != end)\n \t{\n-\t  if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t\t  sequence_index_t>(end - begin)\n-\t\t\t\t\t  >= __gnu_parallel::Settings::\n-\t\t\t\t\t  sort_minimal_n))\n+\t  if (_GLIBCXX_PARALLEL_CONDITION(\n+\t\tstatic_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t\t>= __gnu_parallel::Settings::sort_minimal_n))\n \t    __gnu_parallel::parallel_sort(begin, end, comp, false);\n \t  else\n \t    sort(begin, end, comp, __gnu_parallel::sequential_tag());\n@@ -1816,10 +1786,9 @@ namespace __parallel\n     {\n       if (begin != end)\n \t{\n-\t  if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t\t  sequence_index_t>(end - begin)\n-\t\t\t\t\t  >= __gnu_parallel::Settings::\n-\t\t\t\t\t  sort_minimal_n))\n+\t  if (_GLIBCXX_PARALLEL_CONDITION(\n+\t\tstatic_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t\t>= __gnu_parallel::Settings::sort_minimal_n))\n \t    __gnu_parallel::parallel_sort(begin, end, comp, true);\n \t  else\n \t    stable_sort(begin, end, comp, __gnu_parallel::sequential_tag());\n@@ -1866,14 +1835,11 @@ namespace __parallel\n \t\t random_access_iterator_tag, random_access_iterator_tag, \n \t\t random_access_iterator_tag)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION((static_cast<__gnu_parallel::\n-\t\t\t\t       sequence_index_t>(end1 - begin1)\n-\t\t\t\t       >= __gnu_parallel::Settings::\n-\t\t\t\t       merge_minimal_n\n-\t\t\t\t       || static_cast<__gnu_parallel::\n-\t\t\t\t       sequence_index_t>(end2 - begin2)\n-\t\t\t\t       >= __gnu_parallel::Settings::\n-\t\t\t\t       merge_minimal_n)))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    (static_cast<__gnu_parallel::sequence_index_t>(end1 - begin1)\n+\t     >= __gnu_parallel::Settings::merge_minimal_n\n+\t     || static_cast<__gnu_parallel::sequence_index_t>(end2 - begin2)\n+\t     >= __gnu_parallel::Settings::merge_minimal_n)))\n \treturn __gnu_parallel::parallel_merge_advance(begin1, end1,\n \t\t\t\t\t\t      begin2, end2,\n \t\t\t\t\t\t      result, (end1 - begin1)\n@@ -1945,10 +1911,9 @@ namespace __parallel\n     nth_element(RandomAccessIterator begin, RandomAccessIterator nth, \n \t\tRandomAccessIterator end, Comparator comp)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end - begin)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      nth_element_minimal_n))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t    >= __gnu_parallel::Settings::nth_element_minimal_n))\n \t__gnu_parallel::parallel_nth_element(begin, nth, end, comp);\n       else\n \tnth_element(begin, nth, end, comp, __gnu_parallel::sequential_tag());\n@@ -1986,10 +1951,9 @@ namespace __parallel\n     partial_sort(RandomAccessIterator begin, RandomAccessIterator middle, \n \t\t RandomAccessIterator end, _Compare comp)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end - begin)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      partial_sort_minimal_n))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t    >= __gnu_parallel::Settings::partial_sort_minimal_n))\n \t__gnu_parallel::parallel_partial_sort(begin, middle, end, comp);\n       else\n \tpartial_sort(begin, middle, end, comp,\n@@ -2036,12 +2000,10 @@ namespace __parallel\n \t\t       __gnu_parallel::parallelism parallelism_tag\n \t\t       = __gnu_parallel::parallel_balanced)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end - begin)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      max_element_minimal_n\n-\t\t\t\t      && __gnu_parallel::\n-\t\t\t\t      is_parallel(parallelism_tag)))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t    >= __gnu_parallel::Settings::max_element_minimal_n\n+\t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  RandomAccessIterator res(begin);\n \t  __gnu_parallel::identity_selector<RandomAccessIterator>\n@@ -2129,12 +2091,10 @@ namespace __parallel\n \t\t       __gnu_parallel::parallelism parallelism_tag\n \t\t       = __gnu_parallel::parallel_balanced)\n     {\n-      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n-\t\t\t\t      sequence_index_t>(end - begin)\n-\t\t\t\t      >= __gnu_parallel::Settings::\n-\t\t\t\t      min_element_minimal_n\n-\t\t\t\t      && __gnu_parallel::\n-\t\t\t\t      is_parallel(parallelism_tag)))\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t    >= __gnu_parallel::Settings::min_element_minimal_n\n+\t    && __gnu_parallel::is_parallel(parallelism_tag)))\n \t{\n \t  RandomAccessIterator res(begin);\n \t  __gnu_parallel::identity_selector<RandomAccessIterator>"}, {"sha": "f1aa5d7190885a37e2a0a23e61e370b3718d69bc", "filename": "libstdc++-v3/include/parallel/algorithmfwd.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgorithmfwd.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -454,8 +454,8 @@ namespace __parallel\n     _RAIter3\n     transform2_switch(_RAIter1, _RAIter1, _RAIter2, _RAIter3, _BiOperation, \n \t\t      random_access_iterator_tag, random_access_iterator_tag, \n-\t\t      random_access_iterator_tag, \n-\t\t      __gnu_parallel::parallelism parallelism_tag);\n+\t\t      random_access_iterator_tag,\n+\t\t      __gnu_parallel::parallelism);\n \n   template<typename _IIter1, typename _IIter2, typename _OIter,\n \t   typename _BiOperation, typename _Tag1,\n@@ -525,7 +525,7 @@ namespace __parallel\n \n   template<typename _FIter>\n     _FIter\n-    max_element(_FIter, _FIter, __gnu_parallel::parallelism parallelism_tag);\n+    max_element(_FIter, _FIter, __gnu_parallel::parallelism);\n \n   template<typename _FIter, typename _Compare>\n     _FIter"}, {"sha": "70d811526fdff6778f52fd7e93a095fca5ec8228", "filename": "libstdc++-v3/include/parallel/balanced_quicksort.h", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -112,8 +112,9 @@ template<typename RandomAccessIterator, typename Comparator>\n     typedef typename traits_type::value_type value_type;\n     typedef typename traits_type::difference_type difference_type;\n \n-    RandomAccessIterator pivot_pos = median_of_three_iterators(\n-        begin, begin + (end - begin) / 2, end  - 1, comp);\n+    RandomAccessIterator pivot_pos =\n+      median_of_three_iterators(begin, begin + (end - begin) / 2,\n+\t\t\t\tend  - 1, comp);\n \n #if defined(_GLIBCXX_ASSERTIONS)\n     // Must be in between somewhere.\n@@ -146,9 +147,9 @@ template<typename RandomAccessIterator, typename Comparator>\n \n #if _GLIBCXX_ASSERTIONS\n     RandomAccessIterator r;\n-    for (r = begin; r != pivot_pos; r++)\n+    for (r = begin; r != pivot_pos; ++r)\n       _GLIBCXX_PARALLEL_ASSERT(comp(*r, *pivot_pos));\n-    for (; r != end; r++)\n+    for (; r != end; ++r)\n       _GLIBCXX_PARALLEL_ASSERT(!comp(*r, *pivot_pos));\n #endif\n \n@@ -308,12 +309,12 @@ template<typename RandomAccessIterator, typename Comparator>\n                 __gnu_parallel::unary_negate<__gnu_parallel::binder1st\n                     <Comparator, value_type, value_type, bool>, value_type>\n                     pred(__gnu_parallel::binder1st\n-                        <Comparator, value_type, value_type, bool>(\n-                        comp, *pivot_pos));\n+                        <Comparator, value_type, value_type, bool>(comp,\n+\t\t\t\t\t\t\t\t   *pivot_pos));\n \n                 // Find other end of pivot-equal range.\n-                split_pos2 = __gnu_sequential::partition(\n-                    split_pos1 + 1, end, pred);\n+                split_pos2 = __gnu_sequential::partition(split_pos1 + 1,\n+\t\t\t\t\t\t\t end, pred);\n               }\n             else\n               // Only skip the pivot.\n@@ -339,8 +340,8 @@ template<typename RandomAccessIterator, typename Comparator>\n               {\n                 // Left side larger.\n                 if (begin != split_pos1)\n-                  tl.leftover_parts.push_front(\n-                      std::make_pair(begin, split_pos1));\n+                  tl.leftover_parts.push_front(std::make_pair(begin,\n+\t\t\t\t\t\t\t      split_pos1));\n \n                 current.first = split_pos2;\n                 //current.second = end;\t//already set anyway\n@@ -394,8 +395,8 @@ template<typename RandomAccessIterator, typename Comparator>\n             if (omp_get_wtime() >= (search_start + 1.0))\n               {\n                 sleep(1);\n-                _GLIBCXX_PARALLEL_ASSERT(\n-                    omp_get_wtime() < (search_start + 1.0));\n+                _GLIBCXX_PARALLEL_ASSERT(omp_get_wtime()\n+\t\t\t\t\t < (search_start + 1.0));\n               }\n #endif\n             if (!successfully_stolen)\n@@ -452,7 +453,7 @@ template<typename RandomAccessIterator, typename Comparator>\n     // 2. The largest range has at most length n\n     // 3. Each range is larger than half of the range remaining\n     volatile difference_type elements_leftover = n;\n-    for (int i = 0; i < num_threads; i++)\n+    for (int i = 0; i < num_threads; ++i)\n       {\n         tls[i]->elements_leftover = &elements_leftover;\n         tls[i]->num_threads = num_threads;\n@@ -468,11 +469,11 @@ template<typename RandomAccessIterator, typename Comparator>\n #if _GLIBCXX_ASSERTIONS\n     // All stack must be empty.\n     Piece dummy;\n-    for (int i = 1; i < num_threads; i++)\n+    for (int i = 1; i < num_threads; ++i)\n       _GLIBCXX_PARALLEL_ASSERT(!tls[i]->leftover_parts.pop_back(dummy));\n #endif\n \n-    for (int i = 0; i < num_threads; i++)\n+    for (int i = 0; i < num_threads; ++i)\n       delete tls[i];\n     delete[] tls;\n   }"}, {"sha": "8d1c073d4d090ee3906fea058e598046c08ccc96", "filename": "libstdc++-v3/include/parallel/base.h", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -96,17 +96,13 @@ decode2(lcas_t x, int& a, int& b)\n template<typename T>\n   const T&\n   min(const T& a, const T& b)\n-  {\n-    return (a < b) ? a : b;\n-  };\n+  { return (a < b) ? a : b; }\n \n /** @brief Equivalent to std::max. */\n template<typename T>\n   const T&\n   max(const T& a, const T& b)\n-  {\n-    return (a > b) ? a : b;\n-  };\n+  { return (a > b) ? a : b; }\n \n /** @brief Constructs predicate for equality from strict weak\n   *  ordering predicate\n@@ -402,7 +398,7 @@ template<typename _ValueTp>\n   *  @param comp Comparator.\n   */\n template<typename RandomAccessIterator, typename Comparator>\n-RandomAccessIterator\n+  RandomAccessIterator\n   median_of_three_iterators(RandomAccessIterator a, RandomAccessIterator b,\n                             RandomAccessIterator c, Comparator& comp)\n   {"}, {"sha": "c4e906141091de3f64d2467daec370bf8931f0d0", "filename": "libstdc++-v3/include/parallel/compatibility.h", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompatibility.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -105,7 +105,8 @@ namespace __gnu_parallel\n #elif defined(__ECC)\t//IA-64 version\n     return _InterlockedExchangeAdd((void*)ptr, addend);\n #elif defined(__ICL) || defined(_MSC_VER)\n-    return _InterlockedExchangeAdd(reinterpret_cast<volatile long*>(ptr), addend);\n+    return _InterlockedExchangeAdd(reinterpret_cast<volatile long*>(ptr),\n+\t\t\t\t   addend);\n #elif defined(__GNUC__)\n     return __sync_fetch_and_add(ptr, addend);\n #elif defined(__SUNPRO_CC) && defined(__sparc)\n@@ -114,7 +115,8 @@ namespace __gnu_parallel\n       {\n \tbefore = *ptr;\n \tafter = before + addend;\n-      } while (atomic_cas_32((volatile unsigned int*)ptr, before, after) != before);\n+      } while (atomic_cas_32((volatile unsigned int*)ptr, before,\n+\t\t\t     after) != before);\n     return before;\n #else\t//fallback, slow\n #pragma message(\"slow fetch_and_add_32\")\n@@ -159,7 +161,8 @@ namespace __gnu_parallel\n       {\n \tbefore = *ptr;\n \tafter = before + addend;\n-      } while (atomic_cas_64((volatile unsigned long long*)ptr, before, after) != before);\n+      } while (atomic_cas_64((volatile unsigned long long*)ptr, before,\n+\t\t\t     after) != before);\n     return before;\n #else\t//fallback, slow\n #if defined(__GNUC__) && defined(__i386)\n@@ -238,15 +241,19 @@ namespace __gnu_parallel\n   compare_and_swap_32(volatile int32* ptr, int32 comparand, int32 replacement)\n   {\n #if defined(__ICC)\t//x86 version\n-    return _InterlockedCompareExchange((void*)ptr, replacement, comparand) == comparand;\n+    return _InterlockedCompareExchange((void*)ptr, replacement,\n+\t\t\t\t       comparand) == comparand;\n #elif defined(__ECC)\t//IA-64 version\n-    return _InterlockedCompareExchange((void*)ptr, replacement, comparand) == comparand;\n+    return _InterlockedCompareExchange((void*)ptr, replacement,\n+\t\t\t\t       comparand) == comparand;\n #elif defined(__ICL) || defined(_MSC_VER)\n-    return _InterlockedCompareExchange(reinterpret_cast<volatile long*>(ptr), replacement, comparand) == comparand;\n+    return _InterlockedCompareExchange(reinterpret_cast<volatile long*>(ptr),\n+\t\t\t\t       replacement, comparand) == comparand;\n #elif defined(__GNUC__)\n     return __sync_bool_compare_and_swap(ptr, comparand, replacement);\n #elif defined(__SUNPRO_CC) && defined(__sparc)\n-    return atomic_cas_32((volatile unsigned int*)ptr, comparand, replacement) == comparand;\n+    return atomic_cas_32((volatile unsigned int*)ptr, comparand,\n+\t\t\t replacement) == comparand;\n #else\n #pragma message(\"slow compare_and_swap_32\")\n     bool res = false;\n@@ -276,13 +283,15 @@ namespace __gnu_parallel\n #if defined(__ICC) && defined(__x86_64)\t//x86 version\n     return cas64<int>(ptr, comparand, replacement) == comparand;\n #elif defined(__ECC)\t//IA-64 version\n-    return _InterlockedCompareExchange64((void*)ptr, replacement, comparand) == comparand;\n+    return _InterlockedCompareExchange64((void*)ptr, replacement,\n+\t\t\t\t\t comparand) == comparand;\n #elif defined(__ICL) || defined(_MSC_VER)\n #ifndef _WIN64\n     _GLIBCXX_PARALLEL_ASSERT(false);\t//not available in this case\n     return 0;\n #else\n-    return _InterlockedCompareExchange64(ptr, replacement, comparand) == comparand;\n+    return _InterlockedCompareExchange64(ptr, replacement,\n+\t\t\t\t\t comparand) == comparand;\n #endif\n \n #elif defined(__GNUC__) && defined(__x86_64)\n@@ -291,7 +300,8 @@ namespace __gnu_parallel\n   (defined(__i686) || defined(__pentium4) || defined(__athlon))\n     return __sync_bool_compare_and_swap(ptr, comparand, replacement);\n #elif defined(__SUNPRO_CC) && defined(__sparc)\n-    return atomic_cas_64((volatile unsigned long long*)ptr, comparand, replacement) == comparand;\n+    return atomic_cas_64((volatile unsigned long long*)ptr,\n+\t\t\t comparand, replacement) == comparand;\n #else\n #if defined(__GNUC__) && defined(__i386)\n     // XXX -march=native\n@@ -323,9 +333,11 @@ namespace __gnu_parallel\n   compare_and_swap(volatile T* ptr, T comparand, T replacement)\n   {\n     if (sizeof(T) == sizeof(int32))\n-      return compare_and_swap_32((volatile int32*) ptr, (int32)comparand, (int32)replacement);\n+      return compare_and_swap_32((volatile int32*) ptr,\n+\t\t\t\t (int32)comparand, (int32)replacement);\n     else if (sizeof(T) == sizeof(int64))\n-      return compare_and_swap_64((volatile int64*) ptr, (int64)comparand, (int64)replacement);\n+      return compare_and_swap_64((volatile int64*) ptr,\n+\t\t\t\t (int64)comparand, (int64)replacement);\n     else\n       _GLIBCXX_PARALLEL_ASSERT(false);\n   }"}, {"sha": "051c69ef35b30e54001e7a9267b85b8076a3a23a", "filename": "libstdc++-v3/include/parallel/find.h", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -62,21 +62,21 @@ template<typename RandomAccessIterator1,\n \t typename RandomAccessIterator2,\n \t typename Pred,\n \t typename Selector>\n-  std::pair<RandomAccessIterator1, RandomAccessIterator2>\n+  inline std::pair<RandomAccessIterator1, RandomAccessIterator2>\n   find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n                 RandomAccessIterator2 begin2, Pred pred, Selector selector)\n   {\n     switch (Settings::find_distribution)\n       {\n       case Settings::GROWING_BLOCKS:\n         return find_template(begin1, end1, begin2, pred, selector,\n-                            growing_blocks_tag());\n+\t\t\t     growing_blocks_tag());\n       case Settings::CONSTANT_SIZE_BLOCKS:\n         return find_template(begin1, end1, begin2, pred, selector,\n-                            constant_size_blocks_tag());\n+\t\t\t     constant_size_blocks_tag());\n       case Settings::EQUAL_SPLIT:\n         return find_template(begin1, end1, begin2, pred, selector,\n-                            equal_split_tag());\n+\t\t\t     equal_split_tag());\n       default:\n         _GLIBCXX_PARALLEL_ASSERT(false);\n         return std::make_pair(begin1, begin2);\n@@ -158,8 +158,9 @@ template<typename RandomAccessIterator1,\n     omp_destroy_lock(&result_lock);\n     delete[] borders;\n \n-    return std::pair<RandomAccessIterator1, RandomAccessIterator2>(\n-        begin1 + result, begin2 + result);\n+    return\n+      std::pair<RandomAccessIterator1, RandomAccessIterator2>(begin1 + result,\n+\t\t\t\t\t\t\t      begin2 + result);\n   }\n \n #endif\n@@ -205,8 +206,8 @@ template<typename RandomAccessIterator1,\n \n     difference_type length = end1 - begin1;\n \n-    difference_type sequential_search_size = std::min<difference_type>(\n-        length, Settings::find_sequential_search_size);\n+    difference_type sequential_search_size =\n+      std::min<difference_type>(length, Settings::find_sequential_search_size);\n \n     // Try it sequentially first.\n     std::pair<RandomAccessIterator1, RandomAccessIterator2> find_seq_result =\n@@ -267,23 +268,25 @@ template<typename RandomAccessIterator1,\n                   omp_unset_lock(&result_lock);\n               }\n \n-            block_size = std::min<difference_type>(\n-                block_size * Settings::find_increasing_factor,\n-                Settings::find_maximum_block_size);\n+            block_size =\n+\t      std::min<difference_type>(block_size\n+\t\t\t\t\t* Settings::find_increasing_factor,\n+\t\t\t\t\tSettings::find_maximum_block_size);\n \n             // Get new block, update pointer to next block.\n             start =\n-                fetch_and_add<difference_type>(&next_block_start, block_size);\n-            stop = (length < (start + block_size)) ?\n-                        length : (start + block_size);\n+\t      fetch_and_add<difference_type>(&next_block_start, block_size);\n+            stop = ((length < (start + block_size))\n+\t\t    ? length : (start + block_size));\n           }\n       } //parallel\n \n     omp_destroy_lock(&result_lock);\n \n     // Return iterator on found element.\n-    return std::pair<RandomAccessIterator1, RandomAccessIterator2>(\n-        begin1 + result, begin2 + result);\n+    return\n+      std::pair<RandomAccessIterator1, RandomAccessIterator2>(begin1 + result,\n+\t\t\t\t\t\t\t      begin2 + result);\n   }\n \n #endif\n@@ -391,8 +394,9 @@ template<typename RandomAccessIterator1,\n     omp_destroy_lock(&result_lock);\n \n     // Return iterator on found element.\n-    return std::pair<RandomAccessIterator1, RandomAccessIterator2>(\n-        begin1 + result, begin2 + result);\n+    return\n+      std::pair<RandomAccessIterator1, RandomAccessIterator2>(begin1 + result,\n+\t\t\t\t\t\t\t      begin2 + result);\n   }\n #endif\n } // end namespace"}, {"sha": "eaa55fc05c60e3f36a777ae4d1521138b5e83865", "filename": "libstdc++-v3/include/parallel/for_each_selectors.h", "status": "modified", "additions": 224, "deletions": 220, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffor_each_selectors.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -57,231 +57,234 @@ namespace __gnu_parallel\n \n   /** @brief std::for_each() selector. */\n   template<typename It>\n-  struct for_each_selector : public generic_for_each_selector<It>\n-  {\n-    /** @brief Functor execution.\n-     *  @param o Operator.\n-     *  @param i Iterator referencing object. */\n-    template<typename Op>\n-      bool\n-      operator()(Op& o, It i)\n-      {\n-\to(*i);\n-\treturn true;\n-      }\n-  };\n+    struct for_each_selector : public generic_for_each_selector<It>\n+    {\n+      /** @brief Functor execution.\n+       *  @param o Operator.\n+       *  @param i Iterator referencing object. */\n+      template<typename Op>\n+        bool\n+        operator()(Op& o, It i)\n+\t{\n+\t  o(*i);\n+\t  return true;\n+\t}\n+    };\n \n   /** @brief std::generate() selector. */\n   template<typename It>\n-  struct generate_selector : public generic_for_each_selector<It>\n-  {\n-    /** @brief Functor execution.\n-     *  @param o Operator.\n-     *  @param i Iterator referencing object. */\n-    template<typename Op>\n-      bool\n-      operator()(Op& o, It i)\n-      {\n-\t*i = o();\n-\treturn true;\n-      }\n-  };\n+    struct generate_selector : public generic_for_each_selector<It>\n+    {\n+      /** @brief Functor execution.\n+       *  @param o Operator.\n+       *  @param i Iterator referencing object. */\n+      template<typename Op>\n+        bool\n+        operator()(Op& o, It i)\n+        {\n+\t  *i = o();\n+\t  return true;\n+\t}\n+    };\n \n   /** @brief std::fill() selector. */\n   template<typename It>\n-  struct fill_selector : public generic_for_each_selector<It>\n-  {\n-    /** @brief Functor execution.\n-     *  @param v Current value.\n-     *  @param i Iterator referencing object. */\n-    template<typename Val>\n-      bool\n-      operator()(Val& v, It i)\n-      {\n-\t*i = v;\n-\treturn true;\n-      }\n-  };\n+    struct fill_selector : public generic_for_each_selector<It>\n+    {\n+      /** @brief Functor execution.\n+       *  @param v Current value.\n+       *  @param i Iterator referencing object. */\n+      template<typename Val>\n+        bool\n+        operator()(Val& v, It i)\n+\t{\n+\t  *i = v;\n+\t  return true;\n+\t}\n+    };\n \n   /** @brief std::transform() selector, one input sequence variant. */\n   template<typename It>\n-  struct transform1_selector : public generic_for_each_selector<It>\n-  {\n-    /** @brief Functor execution.\n-     *  @param o Operator.\n-     *  @param i Iterator referencing object. */\n-    template<typename Op>\n-      bool\n-      operator()(Op& o, It i)\n-      {\n-\t*i.second = o(*i.first);\n-\treturn true;\n-      }\n-  };\n+    struct transform1_selector : public generic_for_each_selector<It>\n+    {\n+      /** @brief Functor execution.\n+       *  @param o Operator.\n+       *  @param i Iterator referencing object. */\n+      template<typename Op>\n+        bool\n+        operator()(Op& o, It i)\n+\t{\n+\t  *i.second = o(*i.first);\n+\t  return true;\n+\t}\n+    };\n \n   /** @brief std::transform() selector, two input sequences variant. */\n   template<typename It>\n-  struct transform2_selector : public generic_for_each_selector<It>\n-  {\n-    /** @brief Functor execution.\n-     *  @param o Operator.\n-     *  @param i Iterator referencing object. */\n-    template<typename Op>\n-      bool\n-      operator()(Op& o, It i)\n-      {\n-\t*i.third = o(*i.first, *i.second);\n-\treturn true;\n-      }\n-  };\n+    struct transform2_selector : public generic_for_each_selector<It>\n+    {\n+      /** @brief Functor execution.\n+       *  @param o Operator.\n+       *  @param i Iterator referencing object. */\n+      template<typename Op>\n+        bool\n+        operator()(Op& o, It i)\n+\t{\n+\t  *i.third = o(*i.first, *i.second);\n+\t  return true;\n+\t}\n+    };\n \n   /** @brief std::replace() selector. */\n   template<typename It, typename T>\n-  struct replace_selector : public generic_for_each_selector<It>\n-  {\n-    /** @brief Value to replace with. */\n-    const T& new_val;\n+    struct replace_selector : public generic_for_each_selector<It>\n+    {\n+      /** @brief Value to replace with. */\n+      const T& new_val;\n \n-    /** @brief Constructor\n-     *  @param new_val Value to replace with. */\n-    explicit replace_selector(const T &new_val) : new_val(new_val) {}\n+      /** @brief Constructor\n+       *  @param new_val Value to replace with. */\n+      explicit\n+      replace_selector(const T &new_val) : new_val(new_val) {}\n \n-    /** @brief Functor execution.\n-     *  @param v Current value.\n-     *  @param i Iterator referencing object. */\n-    bool\n-    operator()(T& v, It i)\n-    {\n-      if (*i == v)\n-\t*i = new_val;\n-      return true;\n-    }\n-  };\n+      /** @brief Functor execution.\n+       *  @param v Current value.\n+       *  @param i Iterator referencing object. */\n+      bool\n+      operator()(T& v, It i)\n+      {\n+\tif (*i == v)\n+\t  *i = new_val;\n+\treturn true;\n+      }\n+    };\n \n   /** @brief std::replace() selector. */\n   template<typename It, typename Op, typename T>\n-  struct replace_if_selector : public generic_for_each_selector<It>\n-  {\n-    /** @brief Value to replace with. */\n-    const T& new_val;\n+    struct replace_if_selector : public generic_for_each_selector<It>\n+    {\n+      /** @brief Value to replace with. */\n+      const T& new_val;\n \n-    /** @brief Constructor.\n-     *  @param new_val Value to replace with. */\n-    explicit replace_if_selector(const T &new_val) : new_val(new_val) { }\n+      /** @brief Constructor.\n+       *  @param new_val Value to replace with. */\n+      explicit\n+      replace_if_selector(const T &new_val) : new_val(new_val) { }\n \n-    /** @brief Functor execution.\n-     *  @param o Operator.\n-     *  @param i Iterator referencing object. */\n-    bool\n-    operator()(Op& o, It i)\n-    {\n-      if (o(*i))\n-\t*i = new_val;\n-      return true;\n-    }\n-  };\n+      /** @brief Functor execution.\n+       *  @param o Operator.\n+       *  @param i Iterator referencing object. */\n+      bool\n+      operator()(Op& o, It i)\n+      {\n+\tif (o(*i))\n+\t  *i = new_val;\n+\treturn true;\n+      }\n+    };\n \n   /** @brief std::count() selector. */\n   template<typename It, typename Diff>\n-  struct count_selector : public generic_for_each_selector<It>\n-  {\n-    /** @brief Functor execution.\n-     *  @param v Current value.\n-     *  @param i Iterator referencing object.\n-     *  @return 1 if count, 0 if does not count. */\n-    template<typename Val>\n-      Diff\n-      operator()(Val& v, It i)\n-      { return (v == *i) ? 1 : 0; }\n-  };\n+    struct count_selector : public generic_for_each_selector<It>\n+    {\n+      /** @brief Functor execution.\n+       *  @param v Current value.\n+       *  @param i Iterator referencing object.\n+       *  @return 1 if count, 0 if does not count. */\n+      template<typename Val>\n+        Diff\n+        operator()(Val& v, It i)\n+\t{ return (v == *i) ? 1 : 0; }\n+    };\n \n   /** @brief std::count_if () selector. */\n   template<typename It, typename Diff>\n-  struct count_if_selector : public generic_for_each_selector<It>\n-  {\n-    /** @brief Functor execution.\n-     *  @param o Operator.\n-     *  @param i Iterator referencing object.\n-     *  @return 1 if count, 0 if does not count. */\n-    template<typename Op>\n-      Diff\n-      operator()(Op& o, It i)\n-      { return (o(*i)) ? 1 : 0; }\n-  };\n+    struct count_if_selector : public generic_for_each_selector<It>\n+    {\n+      /** @brief Functor execution.\n+       *  @param o Operator.\n+       *  @param i Iterator referencing object.\n+       *  @return 1 if count, 0 if does not count. */\n+      template<typename Op>\n+        Diff\n+        operator()(Op& o, It i)\n+\t{ return (o(*i)) ? 1 : 0; }\n+    };\n \n   /** @brief std::accumulate() selector. */\n   template<typename It>\n-  struct accumulate_selector : public generic_for_each_selector<It>\n-  {\n-    /** @brief Functor execution.\n-     *  @param o Operator (unused).\n-     *  @param i Iterator referencing object.\n-     *  @return The current value. */\n-    template<typename Op>\n-      typename std::iterator_traits<It>::value_type operator()(Op o, It i)\n-      { return *i; }\n-  };\n+    struct accumulate_selector : public generic_for_each_selector<It>\n+    {\n+      /** @brief Functor execution.\n+       *  @param o Operator (unused).\n+       *  @param i Iterator referencing object.\n+       *  @return The current value. */\n+      template<typename Op>\n+        typename std::iterator_traits<It>::value_type operator()(Op o, It i)\n+\t{ return *i; }\n+    };\n \n   /** @brief std::inner_product() selector. */\n   template<typename It, typename It2, typename T>\n-  struct inner_product_selector : public generic_for_each_selector<It>\n-  {\n-    /** @brief Begin iterator of first sequence. */\n-    It begin1_iterator;\n-\n-    /** @brief Begin iterator of second sequence. */\n-    It2 begin2_iterator;\n-\n-    /** @brief Constructor.\n-     *  @param b1 Begin iterator of first sequence.\n-     *  @param b2 Begin iterator of second sequence. */\n-    explicit inner_product_selector(It b1, It2 b2)\n-    : begin1_iterator(b1), begin2_iterator(b2) { }\n-\n-    /** @brief Functor execution.\n-     *  @param mult Multiplication functor.\n-     *  @param current Iterator referencing object.\n-     *  @return Inner product elemental result. */\n-    template<typename Op>\n-      T\n-      operator()(Op mult, It current)\n-      {\n-\ttypename std::iterator_traits<It>::difference_type position\n-\t  = current - begin1_iterator;\n-\treturn mult(*current, *(begin2_iterator + position));\n-      }\n-  };\n+    struct inner_product_selector : public generic_for_each_selector<It>\n+    {\n+      /** @brief Begin iterator of first sequence. */\n+      It begin1_iterator;\n+\n+      /** @brief Begin iterator of second sequence. */\n+      It2 begin2_iterator;\n+\n+      /** @brief Constructor.\n+       *  @param b1 Begin iterator of first sequence.\n+       *  @param b2 Begin iterator of second sequence. */\n+      explicit\n+      inner_product_selector(It b1, It2 b2)\n+      : begin1_iterator(b1), begin2_iterator(b2) { }\n+\n+      /** @brief Functor execution.\n+       *  @param mult Multiplication functor.\n+       *  @param current Iterator referencing object.\n+       *  @return Inner product elemental result. */\n+      template<typename Op>\n+        T\n+        operator()(Op mult, It current)\n+\t{\n+\t  typename std::iterator_traits<It>::difference_type position\n+\t    = current - begin1_iterator;\n+\t  return mult(*current, *(begin2_iterator + position));\n+\t}\n+    };\n \n   /** @brief Selector that just returns the passed iterator. */\n   template<typename It>\n-  struct identity_selector : public generic_for_each_selector<It>\n-  {\n-    /** @brief Functor execution.\n-     *  @param o Operator (unused).\n-     *  @param i Iterator referencing object.\n-     *  @return Passed iterator. */\n-    template<typename Op>\n-      It\n-      operator()(Op o, It i)\n-      { return i; }\n-  };\n+    struct identity_selector : public generic_for_each_selector<It>\n+    {\n+      /** @brief Functor execution.\n+       *  @param o Operator (unused).\n+       *  @param i Iterator referencing object.\n+       *  @return Passed iterator. */\n+      template<typename Op>\n+        It\n+        operator()(Op o, It i)\n+\t{ return i; }\n+    };\n \n   /** @brief Selector that returns the difference between two adjacent\n    *  elements.\n    */\n   template<typename It>\n-  struct adjacent_difference_selector : public generic_for_each_selector<It>\n-  {\n-    template<typename Op>\n-      bool\n-      operator()(Op& o, It i)\n-      {\n-\ttypename It::first_type go_back_one = i.first;\n-\t--go_back_one;\n-\t*i.second = o(*i.first, *go_back_one);\n-\treturn true;\n-      }\n-  };\n+    struct adjacent_difference_selector : public generic_for_each_selector<It>\n+    {\n+      template<typename Op>\n+        bool\n+        operator()(Op& o, It i)\n+\t{\n+\t  typename It::first_type go_back_one = i.first;\n+\t  --go_back_one;\n+\t  *i.second = o(*i.first, *go_back_one);\n+\t  return true;\n+\t}\n+    };\n \n   // XXX move into type_traits?\n   /** @brief Functor doing nothing\n@@ -308,55 +311,56 @@ namespace __gnu_parallel\n \n   /** @brief Reduction for finding the maximum element, using a comparator. */\n   template<typename Comp, typename It>\n-  struct min_element_reduct\n-  {\n-    Comp& comp;\n+    struct min_element_reduct\n+    {\n+      Comp& comp;\n \n-    explicit min_element_reduct(Comp &c) : comp(c)\n-    { }\n+      explicit\n+      min_element_reduct(Comp &c) : comp(c) { }\n \n-    It\n-    operator()(It x, It y)\n-    {\n-      if (comp(*x, *y))\n-\treturn x;\n-      else\n-\treturn y;\n-    }\n-  };\n+      It\n+      operator()(It x, It y)\n+      {\n+\tif (comp(*x, *y))\n+\t  return x;\n+\telse\n+\t  return y;\n+      }\n+    };\n \n   /** @brief Reduction for finding the maximum element, using a comparator. */\n   template<typename Comp, typename It>\n-  struct max_element_reduct\n-  {\n-    Comp& comp;\n+    struct max_element_reduct\n+    {\n+      Comp& comp;\n \n-    explicit max_element_reduct(Comp& c) : comp(c)\n-    { }\n+      explicit\n+      max_element_reduct(Comp& c) : comp(c) { }\n \n-    It\n-    operator()(It x, It y)\n-    {\n-      if (comp(*x, *y))\n-\treturn y;\n-      else\n-\treturn x;\n-    }\n-  };\n+      It\n+      operator()(It x, It y)\n+      {\n+\tif (comp(*x, *y))\n+\t  return y;\n+\telse\n+\t  return x;\n+      }\n+    };\n \n   /** @brief General reduction, using a binary operator. */\n   template<typename BinOp>\n-  struct accumulate_binop_reduct\n-  {\n-    BinOp& binop;\n+    struct accumulate_binop_reduct\n+    {\n+      BinOp& binop;\n \n-    explicit accumulate_binop_reduct(BinOp& b) : binop(b) {}\n+      explicit\n+      accumulate_binop_reduct(BinOp& b) : binop(b) { }\n \n-    template<typename Result, typename Addend>\n-      Result\n-      operator()(const Result& x, const Addend& y)\n-      { return binop(x, y); }\n-  };\n+      template<typename Result, typename Addend>\n+        Result\n+        operator()(const Result& x, const Addend& y)\n+\t{ return binop(x, y); }\n+    };\n }\n \n #endif"}, {"sha": "0fcc6285c7157e8fc371cf20210837b72d7063e5", "filename": "libstdc++-v3/include/parallel/list_partition.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flist_partition.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -159,15 +159,15 @@ namespace __gnu_parallel\n       // Smallest partitions.\n       for (int i = 1; i < (num_parts + 1 - size_greater); ++i)\n \t{\n-\t  lengths[i-1] =  size_part * range_length;\n+\t  lengths[i - 1] =  size_part * range_length;\n \t  index += size_part;\n \t  starts[i] = os_starts[index];\n \t}\n \n       // Biggest partitions.\n       for (int i = num_parts + 1 - size_greater; i <= num_parts; ++i)\n \t{\n-\t  lengths[i-1] =  (size_part+1) * range_length;\n+\t  lengths[i - 1] =  (size_part+1) * range_length;\n \t  index += (size_part+1);\n \t  starts[i] = os_starts[index];\n \t}"}, {"sha": "ddeb0d36d6ccfcb3ee4c87895ab3263608baa22f", "filename": "libstdc++-v3/include/parallel/losertree.h", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -82,7 +82,7 @@ template<typename T, typename Comparator = std::less<T> >\n       size = _size;\n       offset = size;\n       losers = new Loser[size];\n-      for (unsigned int l = 0; l < size; l++)\n+      for (unsigned int l = 0; l < size; ++l)\n         {\n           //losers[l].key = ... \tstays unset\n           losers[l].inf = true;\n@@ -156,9 +156,10 @@ template<typename T, typename Comparator = std::less<T> >\n       bool inf = false;\n       for (unsigned int pos = (offset + source) / 2; pos > 0; pos /= 2)\n         {\n-          if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup &&\n-              ((comp(losers[pos].key, key)) ||\n-                (!comp(key, losers[pos].key) && losers[pos].source < source)))\n+          if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup\n+\t       && ((comp(losers[pos].key, key))\n+\t\t   || (!comp(key, losers[pos].key)\n+\t\t       && losers[pos].source < source)))\n               || losers[pos].inf || sup)\n             {\n               // Take next key.\n@@ -186,8 +187,9 @@ template<typename T, typename Comparator = std::less<T> >\n       for (unsigned int pos = (offset + source) / 2; pos > 0; pos /= 2)\n         {\n           if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup\n-              && ((comp(losers[pos].key, key)) ||\n-                (!comp(key, losers[pos].key) && losers[pos].source < source)))\n+              && ((comp(losers[pos].key, key))\n+\t\t  || (!comp(key, losers[pos].key)\n+\t\t      && losers[pos].source < source)))\n               || losers[pos].inf || sup)\n             {\n               std::swap(losers[pos].key, key);\n@@ -285,9 +287,9 @@ template<typename T, typename Comparator = std::less<T> >\n         {\n           unsigned int left = init_winner (2 * root);\n           unsigned int right = init_winner (2 * root + 1);\n-          if (losers[right].sup ||\n-              (!losers[left].sup\n-                && !comp(losers[right].key, losers[left].key)))\n+          if (losers[right].sup\n+\t      || (!losers[left].sup\n+\t\t  && !comp(losers[right].key, losers[left].key)))\n             {\n               // Left one is less or equal.\n               losers[root] = losers[right];\n@@ -345,7 +347,7 @@ template<typename T, typename Comparator = std::less<T> >\n           unsigned int right = init_winner (2 * root + 1);\n           if (losers[right].sup\n               || (!losers[left].sup\n-                && !comp(losers[right].key, losers[left].key)))\n+\t\t  && !comp(losers[right].key, losers[left].key)))\n             {\n               // Left one is less or equal.\n               losers[root] = losers[right];\n@@ -443,7 +445,7 @@ template<typename T, typename Comparator = std::less<T> >\n #ifndef COPY\n       keys = new T[ik];\n #endif\n-      for (unsigned int i = ik - 1; i < k; i++)\n+      for (unsigned int i = ik - 1; i < k; ++i)\n         losers[i + k].sup = true;\n     }\n \n@@ -569,11 +571,11 @@ template<typename T, typename Comparator = std::less<T> >\n       for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n         {\n           // The smaller one gets promoted, ties are broken by source.\n-          if (\t(sup && (!losers[pos].sup || losers[pos].source < source)) ||\n-                (!sup && !losers[pos].sup &&\n-                ((comp(KEY(pos), KEY_SOURCE(source))) ||\n-                  (!comp(KEY_SOURCE(source), KEY(pos))\n-                    && losers[pos].source < source))))\n+          if ((sup && (!losers[pos].sup || losers[pos].source < source))\n+\t      || (!sup && !losers[pos].sup\n+\t\t  && ((comp(KEY(pos), KEY_SOURCE(source)))\n+\t\t      || (!comp(KEY_SOURCE(source), KEY(pos))\n+\t\t\t  && losers[pos].source < source))))\n             {\n               // The other one is smaller.\n               std::swap(losers[pos].sup, sup);\n@@ -629,7 +631,7 @@ template<typename T, typename Comparator = std::less<T> >\n       k = 1 << (log2(ik - 1) + 1);\n       offset = k;\n       losers = new Loser[k * 2];\n-      for (unsigned int i = ik - 1; i < k; i++)\n+      for (unsigned int i = ik - 1; i < k; ++i)\n         losers[i + k].sup = true;\n     }\n \n@@ -746,11 +748,11 @@ template<typename T, typename Comparator = std::less<T> >\n       for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n         {\n           // The smaller one gets promoted, ties are broken by source.\n-          if (\t(sup && (!losers[pos].sup || losers[pos].source < source)) ||\n-                (!sup && !losers[pos].sup &&\n-                ((comp(*losers[pos].keyp, *keyp)) ||\n-                  (!comp(*keyp, *losers[pos].keyp)\n-                  && losers[pos].source < source))))\n+          if (\t(sup && (!losers[pos].sup || losers[pos].source < source))\n+\t\t|| (!sup && !losers[pos].sup &&\n+\t\t    ((comp(*losers[pos].keyp, *keyp))\n+\t\t     || (!comp(*keyp, *losers[pos].keyp)\n+\t\t\t && losers[pos].source < source))))\n             {\n               // The other one is smaller.\n               std::swap(losers[pos].sup, sup);\n@@ -995,8 +997,8 @@ template<typename T, typename Comparator = std::less<T> >\n           // Next greater or equal power of 2.\n           unsigned int division = 1 << (log2(end - begin - 1));\n           unsigned int left = init_winner(2 * root, begin, begin + division);\n-          unsigned int right\n-                          = init_winner(2 * root + 1, begin + division, end);\n+          unsigned int right = init_winner(2 * root + 1,\n+\t\t\t\t\t   begin + division, end);\n           if (!comp(*losers[right].keyp, *losers[left].keyp))\n             {\n               // Left one is less or equal."}, {"sha": "f12f31108714e97a1cc9348c6761198f03f1337f", "filename": "libstdc++-v3/include/parallel/merge.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -74,7 +74,7 @@ namespace __gnu_parallel\n \t    *target++ = *begin2++;\n \t  else\n \t    *target++ = *begin1++;\n-\t  max_length--;\n+\t  --max_length;\n \t}\n \n       if (begin1 != end1)\n@@ -143,8 +143,8 @@ namespace __gnu_parallel\n \n \t  *target = element1;\n \n-\t  target++;\n-\t  max_length--;\n+\t  ++target;\n+\t  --max_length;\n \t}\n       if (begin1 != end1)\n \t{"}, {"sha": "855d90acdaeb56ed934aba93382fbe2f0edb07bb", "filename": "libstdc++-v3/include/parallel/multiseq_selection.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiseq_selection.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -212,7 +212,7 @@ namespace __gnu_parallel\n       difference_type localrank = rank * m / N ;\n \n       int j;\n-      for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); j++)\n+      for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); ++j)\n \ta[sample[j].second] += n + 1;\n       for (; j < m; j++)\n \tb[sample[j].second] -= n + 1;\n@@ -279,7 +279,7 @@ namespace __gnu_parallel\n \t\tif (b[i] < ns[i])\n \t\t  pq.push(std::make_pair(S(i)[b[i]], i));\n \n-\t      for (; skew != 0 && !pq.empty(); skew--)\n+\t      for (; skew != 0 && !pq.empty(); --skew)\n \t\t{\n \t\t  int source = pq.top().second;\n \t\t  pq.pop();\n@@ -302,7 +302,7 @@ namespace __gnu_parallel\n \t\tif (a[i] > 0)\n \t\t  pq.push(std::make_pair(S(i)[a[i] - 1], i));\n \n-\t      for (; skew != 0; skew++)\n+\t      for (; skew != 0; ++skew)\n \t\t{\n \t\t  int source = pq.top().second;\n \t\t  pq.pop();\n@@ -416,7 +416,7 @@ namespace __gnu_parallel\n \n       ns[0] = std::distance(begin_seqs[0].first, begin_seqs[0].second);\n       nmax = ns[0];\n-      for (int i = 0; i < m; i++)\n+      for (int i = 0; i < m; ++i)\n \t{\n \t  ns[i] = std::distance(begin_seqs[i].first, begin_seqs[i].second);\n \t  nmax = std::max(nmax, ns[i]);\n@@ -431,7 +431,7 @@ namespace __gnu_parallel\n       // From now on, including padding.\n       N = l * m;\n \n-      for (int i = 0; i < m; i++)\n+      for (int i = 0; i < m; ++i)\n \t{\n \t  a[i] = 0;\n \t  b[i] = l;\n@@ -460,9 +460,9 @@ namespace __gnu_parallel\n       difference_type localrank = rank * m / N ;\n \n       int j;\n-      for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); j++)\n+      for (j = 0; j < localrank && ((n + 1) <= ns[sample[j].second]); ++j)\n \ta[sample[j].second] += n + 1;\n-      for (; j < m; j++)\n+      for (; j < m; ++j)\n \tb[sample[j].second] -= n + 1;\n \n       // Further refinement.\n@@ -471,7 +471,7 @@ namespace __gnu_parallel\n \t  n /= 2;\n \n \t  const T* lmax = NULL;\n-\t  for (int i = 0; i < m; i++)\n+\t  for (int i = 0; i < m; ++i)\n \t    {\n \t      if (a[i] > 0)\n \t\t{\n@@ -496,7 +496,7 @@ namespace __gnu_parallel\n \t    }\n \n \t  difference_type leftsize = 0, total = 0;\n-\t  for (int i = 0; i < m; i++)\n+\t  for (int i = 0; i < m; ++i)\n \t    {\n \t      leftsize += a[i] / (n + 1);\n \t      total += l / (n + 1);\n@@ -512,7 +512,7 @@ namespace __gnu_parallel\n \t\tstd::vector<std::pair<T, int> >,\n \t\tlexicographic_reverse<T, int, Comparator> > pq(lrcomp);\n \n-\t      for (int i = 0; i < m; i++)\n+\t      for (int i = 0; i < m; ++i)\n \t\tif (b[i] < ns[i])\n \t\t  pq.push(std::make_pair(S(i)[b[i]], i));\n \n@@ -535,7 +535,7 @@ namespace __gnu_parallel\n \t\tstd::vector<std::pair<T, int> >,\n \t\tlexicographic<T, int, Comparator> > pq(lcomp);\n \n-\t      for (int i = 0; i < m; i++)\n+\t      for (int i = 0; i < m; ++i)\n \t\tif (a[i] > 0)\n \t\t  pq.push(std::make_pair(S(i)[a[i] - 1], i));\n \n@@ -566,7 +566,7 @@ namespace __gnu_parallel\n \n       // Impossible to avoid the warning?\n       T maxleft, minright;\n-      for (int i = 0; i < m; i++)\n+      for (int i = 0; i < m; ++i)\n \t{\n \t  if (a[i] > 0)\n \t    {\n@@ -610,7 +610,7 @@ namespace __gnu_parallel\n \t  // We have to calculate an offset.\n \t  offset = 0;\n \n-\t  for (int i = 0; i < m; i++)\n+\t  for (int i = 0; i < m; ++i)\n \t    {\n \t      difference_type lb = std::lower_bound(S(i), S(i) + ns[i],\n \t\t\t\t\t\t    minright,"}, {"sha": "419e96a3b5eafacf6061c7d9069b6f5cf6a9f4aa", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "modified", "additions": 199, "deletions": 203, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -73,7 +73,7 @@ template<typename RandomAccessIterator, typename Comparator>\n template<typename RandomAccessIterator, typename Comparator>\n   inline bool\n   operator<=(guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-            guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+\t     guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n \n   /** @brief Iterator wrapper supporting an implicit supremum at the end\n       of the sequence, dominating all comparisons.\n@@ -99,14 +99,14 @@ template<typename RandomAccessIterator, typename Comparator>\n     *  @param end End iterator of sequence.\n     *  @param comp Comparator provided for associated overloaded\n     *  compare operators. */\n-    inline guarded_iterator(RandomAccessIterator begin,\n-                            RandomAccessIterator end, Comparator& comp)\n+    guarded_iterator(RandomAccessIterator begin,\n+\t\t     RandomAccessIterator end, Comparator& comp)\n     : current(begin), end(end), comp(comp)\n     { }\n \n     /** @brief Pre-increment operator.\n     *  @return This. */\n-    inline guarded_iterator<RandomAccessIterator, Comparator>&\n+    guarded_iterator<RandomAccessIterator, Comparator>&\n     operator++()\n     {\n       ++current;\n@@ -115,24 +115,24 @@ template<typename RandomAccessIterator, typename Comparator>\n \n     /** @brief Dereference operator.\n     *  @return Referenced element. */\n-    inline typename std::iterator_traits<RandomAccessIterator>::value_type\n+    typename std::iterator_traits<RandomAccessIterator>::value_type\n     operator*()\n     { return *current; }\n \n     /** @brief Convert to wrapped iterator.\n     *  @return Wrapped iterator. */\n-    inline operator RandomAccessIterator()\n+    operator RandomAccessIterator()\n     { return current; }\n \n     friend bool\n     operator< <RandomAccessIterator, Comparator>(\n-        guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-        guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+      guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+      guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n \n     friend bool\n     operator<= <RandomAccessIterator, Comparator>(\n-        guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-        guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+      guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+      guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n   };\n \n /** @brief Compare two elements referenced by guarded iterators.\n@@ -158,7 +158,7 @@ template<typename RandomAccessIterator, typename Comparator>\n template<typename RandomAccessIterator, typename Comparator>\n   inline bool\n   operator<=(guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-            guarded_iterator<RandomAccessIterator, Comparator>& bi2)\n+\t     guarded_iterator<RandomAccessIterator, Comparator>& bi2)\n   {\n     if (bi2.current == bi2.end)\t//bi1 is sup\n       return bi1.current != bi1.end;\t//bi2 is not sup\n@@ -194,14 +194,14 @@ template<typename RandomAccessIterator, typename Comparator>\n     *  @param begin Begin iterator of sequence.\n     *  @param end Unused, only for compatibility.\n     *  @param comp Unused, only for compatibility. */\n-    inline unguarded_iterator(RandomAccessIterator begin,\n-                              RandomAccessIterator end, Comparator& comp)\n+    unguarded_iterator(RandomAccessIterator begin,\n+\t\t       RandomAccessIterator end, Comparator& comp)\n     : current(begin), comp(comp)\n     { }\n \n     /** @brief Pre-increment operator.\n     *  @return This. */\n-    inline  unguarded_iterator<RandomAccessIterator, Comparator>&\n+    unguarded_iterator<RandomAccessIterator, Comparator>&\n     operator++()\n     {\n       ++current;\n@@ -210,25 +210,24 @@ template<typename RandomAccessIterator, typename Comparator>\n \n     /** @brief Dereference operator.\n     *  @return Referenced element. */\n-    inline typename std::iterator_traits<RandomAccessIterator>::value_type\n+    typename std::iterator_traits<RandomAccessIterator>::value_type\n     operator*()\n     { return *current; }\n \n     /** @brief Convert to wrapped iterator.\n     *  @return Wrapped iterator. */\n-    inline\n     operator RandomAccessIterator()\n     { return current; }\n \n     friend bool\n     operator< <RandomAccessIterator, Comparator>(\n-        unguarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-        unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+      unguarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+      unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n \n     friend bool\n     operator<= <RandomAccessIterator, Comparator>(\n-        unguarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-        unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+      unguarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+      unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n   };\n \n /** @brief Compare two elements referenced by unguarded iterators.\n@@ -399,18 +398,17 @@ template<typename RandomAccessIteratorIterator, typename Comparator>\n  *  @param length Maximum length to merge.\n  *  @param stable Unused, stable anyway.\n  *  @return End iterator of output sequence. */\n-template<\n-    template<typename RAI, typename C> class iterator,\n-    typename RandomAccessIteratorIterator,\n-    typename RandomAccessIterator3,\n-    typename _DifferenceTp,\n-    typename Comparator>\n+template<template<typename RAI, typename C> class iterator,\n+\t typename RandomAccessIteratorIterator,\n+\t typename RandomAccessIterator3,\n+\t typename _DifferenceTp,\n+\t typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge_3_variant(\n-      RandomAccessIteratorIterator seqs_begin,\n-      RandomAccessIteratorIterator seqs_end,\n-      RandomAccessIterator3 target,\n-      Comparator comp, _DifferenceTp length, bool stable)\n+  multiway_merge_3_variant(RandomAccessIteratorIterator seqs_begin,\n+\t\t\t   RandomAccessIteratorIterator seqs_end,\n+\t\t\t   RandomAccessIterator3 target,\n+\t\t\t   Comparator comp, _DifferenceTp length,\n+\t\t\t   bool stable)\n   {\n     _GLIBCXX_CALL(length);\n \n@@ -483,11 +481,10 @@ template<\n     return target;\n   }\n \n-template<\n-    typename RandomAccessIteratorIterator,\n-    typename RandomAccessIterator3,\n-    typename _DifferenceTp,\n-    typename Comparator>\n+template<typename RandomAccessIteratorIterator,\n+\t typename RandomAccessIterator3,\n+\t typename _DifferenceTp,\n+\t typename Comparator>\n   RandomAccessIterator3\n   multiway_merge_3_combined(RandomAccessIteratorIterator seqs_begin,\n                             RandomAccessIteratorIterator seqs_end,\n@@ -573,12 +570,11 @@ template<\n  *  @param length Maximum length to merge.\n  *  @param stable Unused, stable anyway.\n  *  @return End iterator of output sequence. */\n-template<\n-    template<typename RAI, typename C> class iterator,\n-    typename RandomAccessIteratorIterator,\n-    typename RandomAccessIterator3,\n-    typename _DifferenceTp,\n-    typename Comparator>\n+template<template<typename RAI, typename C> class iterator,\n+\t typename RandomAccessIteratorIterator,\n+\t typename RandomAccessIterator3,\n+\t typename _DifferenceTp,\n+\t typename Comparator>\n   RandomAccessIterator3\n   multiway_merge_4_variant(RandomAccessIteratorIterator seqs_begin,\n                            RandomAccessIteratorIterator seqs_end,\n@@ -680,11 +676,10 @@ template<\n     return target;\n   }\n \n-template<\n-    typename RandomAccessIteratorIterator,\n-    typename RandomAccessIterator3,\n-    typename _DifferenceTp,\n-    typename Comparator>\n+template<typename RandomAccessIteratorIterator,\n+\t typename RandomAccessIterator3,\n+\t typename _DifferenceTp,\n+\t typename Comparator>\n   RandomAccessIterator3\n   multiway_merge_4_combined(RandomAccessIteratorIterator seqs_begin,\n                             RandomAccessIteratorIterator seqs_end,\n@@ -765,11 +760,10 @@ template<\n  *  @param stable Stable merging incurs a performance penalty.\n  *  @return End iterator of output sequence.\n  */\n-template<\n-    typename RandomAccessIteratorIterator,\n-    typename RandomAccessIterator3,\n-    typename _DifferenceTp,\n-    typename Comparator>\n+template<typename RandomAccessIteratorIterator,\n+\t typename RandomAccessIterator3,\n+\t typename _DifferenceTp,\n+\t typename Comparator>\n   RandomAccessIterator3\n   multiway_merge_bubble(RandomAccessIteratorIterator seqs_begin,\n                         RandomAccessIteratorIterator seqs_end,\n@@ -845,7 +839,8 @@ template<\n                     ++target;\n                     ++(seqs_begin[source[0]].first);\n                     --length;\n-                    if (seqs_begin[source[0]].first == seqs_begin[source[0]].second)\n+                    if (seqs_begin[source[0]].first\n+\t\t\t== seqs_begin[source[0]].second)\n                       {\n                         // Move everything to the left.\n                         for (int s = 0; s < nrs - 1; ++s)\n@@ -870,7 +865,8 @@ template<\n                     ++target;\n                     ++(seqs_begin[source[0]].first);\n                     --length;\n-                    if (seqs_begin[source[0]].first == seqs_begin[source[0]].second)\n+                    if (seqs_begin[source[0]].first\n+\t\t\t== seqs_begin[source[0]].second)\n                       {\n                         for (int s = 0; s < nrs - 1; ++s)\n                           {\n@@ -888,9 +884,9 @@ template<\n \n             // Sink down.\n             j = 1;\n-            while ((j < nrs) && (comp(fe[j], fe[j - 1]) ||\n-                                (!comp(fe[j - 1], fe[j])\n-                                    && (source[j] < source[j - 1]))))\n+            while ((j < nrs) && (comp(fe[j], fe[j - 1])\n+\t\t\t\t || (!comp(fe[j - 1], fe[j])\n+\t\t\t\t     && (source[j] < source[j - 1]))))\n               {\n                 std::swap(fe[j - 1], fe[j]);\n                 std::swap(source[j - 1], source[j]);\n@@ -910,7 +906,8 @@ template<\n                 ++target;\n                 ++seqs_begin[source[0]].first;\n                 --length;\n-                if (seqs_begin[source[0]].first == seqs_begin[source[0]].second)\n+                if (seqs_begin[source[0]].first\n+\t\t    == seqs_begin[source[0]].second)\n                   {\n                     for (int s = 0; s < (nrs - 1); ++s)\n                       {\n@@ -954,12 +951,11 @@ template<\n  *   @param stable Stable merging incurs a performance penalty.\n  *  @return End iterator of output sequence.\n  */\n-template<\n-    typename LT,\n-    typename RandomAccessIteratorIterator,\n-    typename RandomAccessIterator3,\n-    typename _DifferenceTp,\n-    typename Comparator>\n+template<typename LT,\n+\t typename RandomAccessIteratorIterator,\n+\t typename RandomAccessIterator3,\n+\t typename _DifferenceTp,\n+\t typename Comparator>\n   RandomAccessIterator3\n   multiway_merge_loser_tree(RandomAccessIteratorIterator seqs_begin,\n                             RandomAccessIteratorIterator seqs_end,\n@@ -987,7 +983,8 @@ template<\n \n     for (int t = 0; t < k; ++t)\n       {\n-        if(arbitrary_element == NULL && _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]) > 0)\n+        if(arbitrary_element == NULL\n+\t   && _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]) > 0)\n           arbitrary_element = &(*seqs_begin[t].first);\n         total_length += _GLIBCXX_PARALLEL_LENGTH(seqs_begin[t]);\n       }\n@@ -1074,11 +1071,10 @@ template<\n  *  @return End iterator of output sequence.\n  *  @pre No input will run out of elements during the merge.\n  */\n-template<\n-    typename LT,\n-    typename RandomAccessIteratorIterator,\n-    typename RandomAccessIterator3,\n-    typename _DifferenceTp, typename Comparator>\n+template<typename LT,\n+\t typename RandomAccessIteratorIterator,\n+\t typename RandomAccessIterator3,\n+\t typename _DifferenceTp, typename Comparator>\n   RandomAccessIterator3\n   multiway_merge_loser_tree_unguarded(RandomAccessIteratorIterator seqs_begin,\n                                       RandomAccessIteratorIterator seqs_end,\n@@ -1190,11 +1186,10 @@ template<\n     return target;\n   }\n \n-template<\n-    typename RandomAccessIteratorIterator,\n-    typename RandomAccessIterator3,\n-    typename _DifferenceTp,\n-    typename Comparator>\n+template<typename RandomAccessIteratorIterator,\n+\t typename RandomAccessIterator3,\n+\t typename _DifferenceTp,\n+\t typename Comparator>\n   RandomAccessIterator3\n   multiway_merge_loser_tree_combined(RandomAccessIteratorIterator seqs_begin,\n                                      RandomAccessIteratorIterator seqs_end,\n@@ -1254,17 +1249,16 @@ template<\n     return target_end;\n   }\n \n-template<\n-    typename RandomAccessIteratorIterator,\n-    typename RandomAccessIterator3,\n-    typename _DifferenceTp,\n-    typename Comparator>\n+template<typename RandomAccessIteratorIterator,\n+\t typename RandomAccessIterator3,\n+\t typename _DifferenceTp,\n+\t typename Comparator>\n   RandomAccessIterator3\n   multiway_merge_loser_tree_sentinel(RandomAccessIteratorIterator seqs_begin,\n                                      RandomAccessIteratorIterator seqs_end,\n-                                      RandomAccessIterator3 target,\n-                                      Comparator comp,\n-                                      _DifferenceTp length, bool stable)\n+\t\t\t\t     RandomAccessIterator3 target,\n+\t\t\t\t     Comparator comp,\n+\t\t\t\t     _DifferenceTp length, bool stable)\n   {\n     _GLIBCXX_CALL(length)\n \n@@ -1326,7 +1320,8 @@ template<\n \n /** @brief Sequential multi-way merging switch.\n  *\n- *  The _GLIBCXX_PARALLEL_DECISION if based on the branching factor and runtime settings.\n+ *  The _GLIBCXX_PARALLEL_DECISION if based on the branching factor and\n+ *  runtime settings.\n  *  @param seqs_begin Begin iterator of iterator pair input sequence.\n  *  @param seqs_end End iterator of iterator pair input sequence.\n  *  @param target Begin iterator out output sequence.\n@@ -1335,11 +1330,10 @@ template<\n  *  @param stable Stable merging incurs a performance penalty.\n  *  @param sentinel The sequences have a sentinel element.\n  *  @return End iterator of output sequence. */\n-template<\n-    typename RandomAccessIteratorIterator,\n-    typename RandomAccessIterator3,\n-    typename _DifferenceTp,\n-    typename Comparator>\n+template<typename RandomAccessIteratorIterator,\n+\t typename RandomAccessIterator3,\n+\t typename _DifferenceTp,\n+\t typename Comparator>\n   RandomAccessIterator3\n   multiway_merge(RandomAccessIteratorIterator seqs_begin,\n                  RandomAccessIteratorIterator seqs_end,\n@@ -1393,49 +1387,52 @@ template<\n           {\n           case Settings::LOSER_TREE_COMBINED:\n             return_target = multiway_merge_3_combined(seqs_begin,\n-                seqs_end,\n-                target,\n-                comp, length, stable);\n+\t\t\t\t\t\t      seqs_end,\n+\t\t\t\t\t\t      target,\n+\t\t\t\t\t\t      comp, length,\n+\t\t\t\t\t\t      stable);\n             break;\n           case Settings::LOSER_TREE_SENTINEL:\n-            return_target = multiway_merge_3_variant<unguarded_iterator>(\n-                seqs_begin,\n-                seqs_end,\n-                target,\n-                comp, length, stable);\n+            return_target =\n+\t      multiway_merge_3_variant<unguarded_iterator>(seqs_begin,\n+\t\t\t\t\t\t\t   seqs_end,\n+\t\t\t\t\t\t\t   target,\n+\t\t\t\t\t\t\t   comp, length,\n+\t\t\t\t\t\t\t   stable);\n             break;\n           default:\n-            return_target = multiway_merge_3_variant<guarded_iterator>(\n-                seqs_begin,\n-                seqs_end,\n-                target,\n-                comp, length, stable);\n+            return_target = \n+\t      multiway_merge_3_variant<guarded_iterator>(seqs_begin,\n+\t\t\t\t\t\t\t seqs_end,\n+\t\t\t\t\t\t\t target,\n+\t\t\t\t\t\t\t comp, length,\n+\t\t\t\t\t\t\t stable);\n             break;\n           }\n         break;\n       case 4:\n         switch (mwma)\n           {\n           case Settings::LOSER_TREE_COMBINED:\n-            return_target = multiway_merge_4_combined(\n-                seqs_begin,\n-                seqs_end,\n-                target,\n-                comp, length, stable);\n+            return_target = multiway_merge_4_combined(seqs_begin,\n+\t\t\t\t\t\t      seqs_end,\n+\t\t\t\t\t\t      target,\n+\t\t\t\t\t\t      comp, length, stable);\n             break;\n           case Settings::LOSER_TREE_SENTINEL:\n-            return_target = multiway_merge_4_variant<unguarded_iterator>(\n-                seqs_begin,\n-                seqs_end,\n-                target,\n-                comp, length, stable);\n+            return_target = \n+\t      multiway_merge_4_variant<unguarded_iterator>(seqs_begin,\n+\t\t\t\t\t\t\t   seqs_end,\n+\t\t\t\t\t\t\t   target,\n+\t\t\t\t\t\t\t   comp, length,\n+\t\t\t\t\t\t\t   stable);\n             break;\n           default:\n             return_target = multiway_merge_4_variant<guarded_iterator>(\n-                seqs_begin,\n-                seqs_end,\n-                target,\n-                comp, length, stable);\n+\t      seqs_begin,\n+\t      seqs_end,\n+\t      target,\n+\t      comp, length, stable);\n             break;\n           }\n         break;\n@@ -1444,48 +1441,47 @@ template<\n           switch (mwma)\n             {\n             case Settings::BUBBLE:\n-              return_target = multiway_merge_bubble(\n-                  seqs_begin,\n-                  seqs_end,\n-                  target,\n-                  comp, length, stable);\n+              return_target = multiway_merge_bubble(seqs_begin,\n+\t\t\t\t\t\t    seqs_end,\n+\t\t\t\t\t\t    target,\n+\t\t\t\t\t\t    comp, length, stable);\n               break;\n #if _GLIBCXX_LOSER_TREE_EXPLICIT\n             case Settings::LOSER_TREE_EXPLICIT:\n               return_target = multiway_merge_loser_tree<\n-                    LoserTreeExplicit<value_type, Comparator> >(\n-                  seqs_begin,\n-                  seqs_end,\n-                  target,\n-                  comp, length, stable);\n+\t      LoserTreeExplicit<value_type, Comparator> >(seqs_begin,\n+\t\t\t\t\t\t\t  seqs_end,\n+\t\t\t\t\t\t\t  target,\n+\t\t\t\t\t\t\t  comp, length,\n+\t\t\t\t\t\t\t  stable);\n               break;\n #endif\n #if _GLIBCXX_LOSER_TREE\n             case Settings::LOSER_TREE:\n               return_target = multiway_merge_loser_tree<\n-                    LoserTree<value_type, Comparator> >(\n-                  seqs_begin,\n-                  seqs_end,\n-                  target,\n-                  comp, length, stable);\n+                    LoserTree<value_type, Comparator> >(seqs_begin,\n+\t\t\t\t\t\t\tseqs_end,\n+\t\t\t\t\t\t\ttarget,\n+\t\t\t\t\t\t\tcomp, length,\n+\t\t\t\t\t\t\tstable);\n               break;\n #endif\n #if _GLIBCXX_LOSER_TREE_COMBINED\n             case Settings::LOSER_TREE_COMBINED:\n-              return_target = multiway_merge_loser_tree_combined(\n-                  seqs_begin,\n-                  seqs_end,\n-                  target,\n-                  comp, length, stable);\n+              return_target = multiway_merge_loser_tree_combined(seqs_begin,\n+\t\t\t\t\t\t\t\t seqs_end,\n+\t\t\t\t\t\t\t\t target,\n+\t\t\t\t\t\t\t\t comp, length,\n+\t\t\t\t\t\t\t\t stable);\n               break;\n #endif\n #if _GLIBCXX_LOSER_TREE_SENTINEL\n             case Settings::LOSER_TREE_SENTINEL:\n-              return_target = multiway_merge_loser_tree_sentinel(\n-                  seqs_begin,\n-                  seqs_end,\n-                  target,\n-                  comp, length, stable);\n+              return_target = multiway_merge_loser_tree_sentinel(seqs_begin,\n+\t\t\t\t\t\t\t\t seqs_end,\n+\t\t\t\t\t\t\t\t target,\n+\t\t\t\t\t\t\t\t comp, length,\n+\t\t\t\t\t\t\t\t stable);\n               break;\n #endif\n             default:\n@@ -1504,7 +1500,8 @@ template<\n \n /** @brief Parallel multi-way merge routine.\n  *\n- *  The _GLIBCXX_PARALLEL_DECISION if based on the branching factor and runtime settings.\n+ *  The _GLIBCXX_PARALLEL_DECISION if based on the branching factor\n+ *  and runtime settings.\n  *  @param seqs_begin Begin iterator of iterator pair input sequence.\n  *  @param seqs_end End iterator of iterator pair input sequence.\n  *  @param target Begin iterator out output sequence.\n@@ -1514,11 +1511,10 @@ template<\n  *  @param sentinel Ignored.\n  *  @return End iterator of output sequence.\n  */\n-template<\n-    typename RandomAccessIteratorIterator,\n-    typename RandomAccessIterator3,\n-    typename _DifferenceTp,\n-    typename Comparator>\n+template<typename RandomAccessIteratorIterator,\n+\t typename RandomAccessIterator3,\n+\t typename _DifferenceTp,\n+\t typename Comparator>\n   RandomAccessIterator3\n   parallel_multiway_merge(RandomAccessIteratorIterator seqs_begin,\n                           RandomAccessIteratorIterator seqs_end,\n@@ -1553,7 +1549,7 @@ template<\n       std::vector<std::pair<difference_type, difference_type> >* pieces;\n \n       thread_index_t num_threads = static_cast<thread_index_t>(\n-          std::min<difference_type>(get_max_threads(), total_length));\n+\tstd::min<difference_type>(get_max_threads(), total_length));\n \n #     pragma omp parallel num_threads (num_threads)\n         {\n@@ -1578,20 +1574,20 @@ template<\n                     for (difference_type i = 0; i < num_samples; ++i)\n                       {\n                         difference_type sample_index =\n-                            static_cast<difference_type>(\n-                                _GLIBCXX_PARALLEL_LENGTH(seqs_begin[s]) * (double(i + 1) /\n-                                (num_samples + 1)) * (double(length)\n-                                / total_length));\n-                        ::new(&(samples[s * num_samples + i])) value_type(\n-                            seqs_begin[s].first[sample_index]);\n+\t\t\t  static_cast<difference_type>(\n+\t\t\t    _GLIBCXX_PARALLEL_LENGTH(seqs_begin[s])\n+\t\t\t    * (double(i + 1) / (num_samples + 1))\n+\t\t\t    * (double(length) / total_length));\n+                        ::new(&(samples[s * num_samples + i]))\n+\t\t\t    value_type(seqs_begin[s].first[sample_index]);\n                       }\n \n                   if (stable)\n-                    __gnu_sequential::stable_sort(\n-                      samples, samples + (num_samples * k), comp);\n+                    __gnu_sequential::stable_sort(samples, samples\n+\t\t\t\t\t\t  + (num_samples * k), comp);\n                   else\n-                    __gnu_sequential::sort(\n-                      samples, samples + (num_samples * k), comp);\n+                    __gnu_sequential::sort(samples, samples\n+\t\t\t\t\t   + (num_samples * k), comp);\n \n                   for (int slab = 0; slab < num_threads; ++slab)\n                     // For each slab / processor.\n@@ -1600,27 +1596,28 @@ template<\n                         // For each sequence.\n                         if (slab > 0)\n                           pieces[slab][seq].first =\n-                              std::upper_bound(\n-                                seqs_begin[seq].first,\n-                                seqs_begin[seq].second,\n-                                samples[num_samples * k * slab / num_threads],\n-                                  comp)\n-                              - seqs_begin[seq].first;\n+                              std::upper_bound(seqs_begin[seq].first,\n+\t\t\t\t\t       seqs_begin[seq].second,\n+\t\t\t\t\t       samples[num_samples * k\n+\t\t\t\t\t\t       * slab / num_threads],\n+\t\t\t\t\t       comp)\n+\t\t\t    - seqs_begin[seq].first;\n                         else\n                           {\n                             // Absolute beginning.\n                             pieces[slab][seq].first = 0;\n                           }\n                         if ((slab + 1) < num_threads)\n                           pieces[slab][seq].second =\n-                              std::upper_bound(\n-                                  seqs_begin[seq].first,\n-                                  seqs_begin[seq].second,\n-                                  samples[num_samples * k * (slab + 1) /\n-                                      num_threads], comp)\n-                              - seqs_begin[seq].first;\n+\t\t\t    std::upper_bound(seqs_begin[seq].first,\n+\t\t\t\t\t     seqs_begin[seq].second,\n+\t\t\t\t\t     samples[num_samples * k\n+\t\t\t\t\t\t     * (slab + 1)\n+\t\t\t\t\t\t     / num_threads], comp)\n+\t\t\t    - seqs_begin[seq].first;\n                         else\n-                        pieces[slab][seq].second = _GLIBCXX_PARALLEL_LENGTH(seqs_begin[seq]);\n+\t\t\t  pieces[slab][seq].second \n+\t\t\t    = _GLIBCXX_PARALLEL_LENGTH(seqs_begin[seq]);\n                       }\n \t\t  ::operator delete(samples);\n                 }\n@@ -1651,8 +1648,9 @@ template<\n                         {\n                           offsets[num_threads - 1].resize(k);\n                           multiseq_partition(se.begin(), se.end(),\n-                                difference_type(length),\n-                                offsets[num_threads - 1].begin(),  comp);\n+\t\t\t\t\t     difference_type(length),\n+\t\t\t\t\t     offsets[num_threads - 1].begin(),\n+\t\t\t\t\t     comp);\n                         }\n                     }\n \n@@ -1673,12 +1671,12 @@ template<\n                                 pieces[slab - 1][seq].second;\n                           if (!tight || slab < (num_threads - 1))\n                             pieces[slab][seq].second =\n-                                offsets[slab][seq] - seqs_begin[seq].first;\n+\t\t\t      offsets[slab][seq] - seqs_begin[seq].first;\n                           else\n                             {\n                               // slab == num_threads - 1\n                               pieces[slab][seq].second =\n-                                  _GLIBCXX_PARALLEL_LENGTH(seqs_begin[seq]);\n+\t\t\t\t_GLIBCXX_PARALLEL_LENGTH(seqs_begin[seq]);\n                             }\n                         }\n                     }\n@@ -1703,8 +1701,8 @@ template<\n               for (int s = 0; s < k; ++s)\n                 {\n                   chunks[s] = std::make_pair(\n-                      seqs_begin[s].first + pieces[iam][s].first,\n-                      seqs_begin[s].first + pieces[iam][s].second);\n+\t\t    seqs_begin[s].first + pieces[iam][s].first,\n+\t\t    seqs_begin[s].first + pieces[iam][s].second);\n                   local_length += _GLIBCXX_PARALLEL_LENGTH(chunks[s]);\n                 }\n \n@@ -1721,13 +1719,13 @@ template<\n                   begin0 = seqs_begin[0].first + pieces[iam][0].first,\n                   begin1 = seqs_begin[1].first + pieces[iam][1].first;\n               merge_advance(begin0,\n-                    seqs_begin[0].first + pieces[iam][0].second,\n-                    begin1,\n-                    seqs_begin[1].first + pieces[iam][1].second,\n-                    target + target_position,\n-                    (pieces[iam][0].second - pieces[iam][0].first) +\n-                        (pieces[iam][1].second - pieces[iam][1].first),\n-                    comp);\n+\t\t\t    seqs_begin[0].first + pieces[iam][0].second,\n+\t\t\t    begin1,\n+\t\t\t    seqs_begin[1].first + pieces[iam][1].second,\n+\t\t\t    target + target_position,\n+\t\t\t    (pieces[iam][0].second - pieces[iam][0].first) +\n+\t\t\t    (pieces[iam][1].second - pieces[iam][1].first),\n+\t\t\t    comp);\n             }\n         } //parallel\n \n@@ -1754,11 +1752,10 @@ template<\n  *  @param stable Stable merging incurs a performance penalty.\n  *  @return End iterator of output sequence.\n  */\n-template<\n-    typename RandomAccessIteratorPairIterator,\n-    typename RandomAccessIterator3,\n-    typename _DifferenceTp,\n-    typename Comparator>\n+template<typename RandomAccessIteratorPairIterator,\n+\t typename RandomAccessIterator3,\n+\t typename _DifferenceTp,\n+\t typename Comparator>\n   RandomAccessIterator3\n   multiway_merge(RandomAccessIteratorPairIterator seqs_begin,\n                 RandomAccessIteratorPairIterator seqs_end,\n@@ -1775,13 +1772,13 @@ template<\n     if (_GLIBCXX_PARALLEL_CONDITION(\n         ((seqs_end - seqs_begin) >= Settings::multiway_merge_minimal_k)\n         && ((sequence_index_t)length >= Settings::multiway_merge_minimal_n)))\n-      target_end = parallel_multiway_merge(\n-          seqs_begin, seqs_end,\n-          target, comp, static_cast<difference_type>(length), stable, false);\n+      target_end = parallel_multiway_merge(seqs_begin, seqs_end,\n+\t\t\t\t\t   target, comp,\n+\t\t\t\t\t  static_cast<difference_type>(length),\n+\t\t\t\t\t   stable, false);\n     else\n-      target_end = multiway_merge(\n-          seqs_begin, seqs_end,\n-          target, comp, length, stable, false, sequential_tag());\n+      target_end = multiway_merge(seqs_begin, seqs_end, target, comp, length,\n+\t\t\t\t  stable, false, sequential_tag());\n \n     return target_end;\n   }\n@@ -1797,11 +1794,10 @@ template<\n  *  @pre For each @c i, @c seqs_begin[i].second must be the end\n  *  marker of the sequence, but also reference the one more sentinel\n  *  element. */\n-template<\n-    typename RandomAccessIteratorPairIterator,\n-    typename RandomAccessIterator3,\n-    typename _DifferenceTp,\n-    typename Comparator>\n+template<typename RandomAccessIteratorPairIterator,\n+\t typename RandomAccessIterator3,\n+\t typename _DifferenceTp,\n+\t typename Comparator>\n   RandomAccessIterator3\n   multiway_merge_sentinel(RandomAccessIteratorPairIterator seqs_begin,\n                           RandomAccessIteratorPairIterator seqs_end,\n@@ -1824,9 +1820,9 @@ template<\n           seqs_begin, seqs_end,\n           target, comp, static_cast<difference_type>(length), stable, true);\n     else\n-      return multiway_merge(\n-          seqs_begin, seqs_end,\n-          target, comp, length, stable, true, sequential_tag());\n+      return multiway_merge(seqs_begin, seqs_end,\n+\t\t\t    target, comp, length, stable,\n+\t\t\t    true, sequential_tag());\n   }\n }\n "}, {"sha": "923a2a899447fe9b6d904ade785f4248bfeaa34f", "filename": "libstdc++-v3/include/parallel/multiway_mergesort.h", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -120,7 +120,7 @@ template<typename RandomAccessIterator>\n   *  @param num_samples Number of samples to select.\n   */\n template<typename RandomAccessIterator, typename _DifferenceTp>\n-  inline void \n+  void \n   determine_samples(PMWMSSortingData<RandomAccessIterator>* sd,\n                     _DifferenceTp& num_samples)\n   {\n@@ -138,9 +138,9 @@ template<typename RandomAccessIterator, typename _DifferenceTp>\n     equally_split(sd->starts[iam + 1] - sd->starts[iam], \n                   num_samples + 1, es);\n \n-    for (difference_type i = 0; i < num_samples; i++)\n-      ::new(&(sd->samples[iam * num_samples + i])) value_type(\n-          sd->source[sd->starts[iam] + es[i + 1]]);\n+    for (difference_type i = 0; i < num_samples; ++i)\n+      ::new(&(sd->samples[iam * num_samples + i]))\n+\t  value_type(sd->source[sd->starts[iam] + es[i + 1]]);\n \n     delete[] es;\n   }\n@@ -150,7 +150,7 @@ template<typename RandomAccessIterator, typename _DifferenceTp>\n   *  @param comp Comparator.\n   */\n template<typename RandomAccessIterator, typename Comparator>\n-  inline void \n+  void \n   parallel_sort_mwms_pu(PMWMSSortingData<RandomAccessIterator>* sd,\n                         Comparator& comp)\n   {\n@@ -209,7 +209,7 @@ template<typename RandomAccessIterator, typename Comparator>\n \n #       pragma omp barrier\n \n-        for (int s = 0; s < sd->num_threads; s++)\n+        for (int s = 0; s < sd->num_threads; ++s)\n           {\n             // For each sequence.\n               if (num_samples * iam > 0)\n@@ -243,7 +243,7 @@ template<typename RandomAccessIterator, typename Comparator>\n \n         std::vector<std::pair<SortingPlacesIterator, SortingPlacesIterator> >\n             seqs(sd->num_threads);\n-        for (int s = 0; s < sd->num_threads; s++)\n+        for (int s = 0; s < sd->num_threads; ++s)\n           seqs[s] = std::make_pair(sd->sorting_places[s],\n                                    sd->sorting_places[s]\n                                        + (sd->starts[s + 1] - sd->starts[s]));\n@@ -255,20 +255,20 @@ template<typename RandomAccessIterator, typename Comparator>\n           multiseq_partition(seqs.begin(), seqs.end(),\n                              sd->starts[iam + 1], offsets.begin(), comp);\n \n-        for (int seq = 0; seq < sd->num_threads; seq++)\n+        for (int seq = 0; seq < sd->num_threads; ++seq)\n           {\n             // for each sequence\n             if (iam < (sd->num_threads - 1))\n               sd->pieces[iam][seq].end = offsets[seq] - seqs[seq].first;\n             else\n               // very end of this sequence\n-              sd->pieces[iam][seq].end =\n-                  sd->starts[seq + 1] - sd->starts[seq];\n+              sd->pieces[iam][seq].end = (sd->starts[seq + 1]\n+\t\t\t\t\t  - sd->starts[seq]);\n           }\n \n #       pragma omp barrier\n \n-        for (int seq = 0; seq < sd->num_threads; seq++)\n+        for (int seq = 0; seq < sd->num_threads; ++seq)\n           {\n             // For each sequence.\n             if (iam > 0)\n@@ -281,7 +281,7 @@ template<typename RandomAccessIterator, typename Comparator>\n \n     // Offset from target begin, length after merging.\n     difference_type offset = 0, length_am = 0;\n-    for (int s = 0; s < sd->num_threads; s++)\n+    for (int s = 0; s < sd->num_threads; ++s)\n       {\n         length_am += sd->pieces[iam][s].end - sd->pieces[iam][s].begin;\n         offset += sd->pieces[iam][s].begin;\n@@ -293,20 +293,20 @@ template<typename RandomAccessIterator, typename Comparator>\n     // instead of the assignment operator.\n     // XXX incorrect (de)construction\n     sd->merging_places[iam] = sd->temporaries[iam] =\n-        static_cast<value_type*>(\n-        ::operator new(sizeof(value_type) * length_am));\n+        static_cast<value_type*>(::operator new(sizeof(value_type)\n+\t\t\t\t\t\t* length_am));\n #else\n     // Merge directly to target.\n     sd->merging_places[iam] = sd->source + offset;\n #endif\n     std::vector<std::pair<SortingPlacesIterator, SortingPlacesIterator> >\n         seqs(sd->num_threads);\n \n-    for (int s = 0; s < sd->num_threads; s++)\n+    for (int s = 0; s < sd->num_threads; ++s)\n       {\n         seqs[s] =\n-            std::make_pair(sd->sorting_places[s] + sd->pieces[iam][s].begin,\n-                           sd->sorting_places[s] + sd->pieces[iam][s].end);\n+\t  std::make_pair(sd->sorting_places[s] + sd->pieces[iam][s].begin,\n+\t\t\t sd->sorting_places[s] + sd->pieces[iam][s].end);\n       }\n \n     multiway_merge(seqs.begin(), seqs.end(), sd->merging_places[iam], comp,\n@@ -333,13 +333,11 @@ template<typename RandomAccessIterator, typename Comparator>\n   *  @param stable Stable sorting.\n   */\n template<typename RandomAccessIterator, typename Comparator>\n-  inline void\n+  void\n   parallel_sort_mwms(RandomAccessIterator begin, RandomAccessIterator end,\n-                     Comparator comp, \n-                     typename std::iterator_traits<RandomAccessIterator>\n-                        ::difference_type n,\n-                     int num_threads,\n-                     bool stable)\n+                     Comparator comp, typename\n+\t\t     std::iterator_traits<RandomAccessIterator>::\n+\t\t     difference_type n, int num_threads, bool stable)\n   {\n     _GLIBCXX_CALL(n)\n \n@@ -382,22 +380,22 @@ template<typename RandomAccessIterator, typename Comparator>\n                     (Settings::sort_mwms_oversampling * num_threads - 1)\n                         * num_threads;\n                 sd.samples = static_cast<value_type*>(\n-                    ::operator new(size * sizeof(value_type)));\n+\t\t  ::operator new(size * sizeof(value_type)));\n               }\n             else\n               sd.samples = NULL;\n \n             sd.offsets = new difference_type[num_threads - 1];\n             sd.pieces = new std::vector<Piece<difference_type> >[num_threads];\n-            for (int s = 0; s < num_threads; s++)\n+            for (int s = 0; s < num_threads; ++s)\n               sd.pieces[s].resize(num_threads);\n             starts = sd.starts = new difference_type[num_threads + 1];\n             sd.stable = stable;\n \n             difference_type chunk_length = n / num_threads;\n             difference_type split = n % num_threads;\n             difference_type pos = 0;\n-            for (int i = 0; i < num_threads; i++)\n+            for (int i = 0; i < num_threads; ++i)\n               {\n                 starts[i] = pos;\n                 pos += (i < split) ? (chunk_length + 1) : chunk_length;"}, {"sha": "ccbdeee12c43e30da5a7097f9f12f7723f378f26", "filename": "libstdc++-v3/include/parallel/numeric", "status": "modified", "additions": 382, "deletions": 320, "changes": 702, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumeric?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -58,387 +58,449 @@ namespace __parallel\n {\n   // Sequential fallback.\n   template<typename InputIterator, typename T>\n-  inline T\n-  accumulate(InputIterator begin, InputIterator end, T init, \n-\t     __gnu_parallel::sequential_tag)\n-  { return _GLIBCXX_STD_P::accumulate(begin, end, init); }\n+    inline T\n+    accumulate(InputIterator begin, InputIterator end, T init, \n+\t       __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::accumulate(begin, end, init); }\n \n   template<typename InputIterator, typename T, typename BinaryOperation>\n-  inline T\n-  accumulate(InputIterator begin, InputIterator end, T init,\n-\t     BinaryOperation binary_op, __gnu_parallel::sequential_tag)\n-  { return _GLIBCXX_STD_P::accumulate(begin, end, init, binary_op); }\n+    inline T\n+    accumulate(InputIterator begin, InputIterator end, T init,\n+\t       BinaryOperation binary_op, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::accumulate(begin, end, init, binary_op); }\n \n   // Sequential fallback for input iterator case.\n   template<typename InputIterator, typename T, typename IteratorTag>\n-  inline T\n-  accumulate_switch(InputIterator begin, InputIterator end, T init, IteratorTag)  { return accumulate(begin, end, init, __gnu_parallel::sequential_tag()); }\n-\n-  template<typename InputIterator, typename T, typename BinaryOperation, typename IteratorTag>\n-  T\n-  accumulate_switch(InputIterator begin, InputIterator end, T init, \n-\t\t    BinaryOperation binary_op, IteratorTag)\n-  {\n-    return accumulate(begin, end, init, binary_op, \n-\t\t      __gnu_parallel::sequential_tag());\n-  }\n+    inline T\n+    accumulate_switch(InputIterator begin, InputIterator end,\n+\t\t      T init, IteratorTag) \n+    { return accumulate(begin, end, init, __gnu_parallel::sequential_tag()); }\n+\n+  template<typename InputIterator, typename T, typename BinaryOperation,\n+\t   typename IteratorTag>\n+    T\n+    accumulate_switch(InputIterator begin, InputIterator end, T init, \n+\t\t      BinaryOperation binary_op, IteratorTag)\n+    { return accumulate(begin, end, init, binary_op, \n+\t\t\t__gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators.\n-  template<typename _RandomAccessIterator, typename T, typename BinaryOperation>\n-  T\n-  accumulate_switch(_RandomAccessIterator begin, _RandomAccessIterator end, \n-\t\t    T init, BinaryOperation binary_op, \n-\t\t    random_access_iterator_tag, \n-\t\t    __gnu_parallel::parallelism parallelism_tag  \n-\t\t    = __gnu_parallel::parallel_unbalanced)\n-  {\n-    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::accumulate_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n-      {\n-\tT res = init;\n-\t__gnu_parallel::accumulate_selector<_RandomAccessIterator> my_selector;\n-\t__gnu_parallel::for_each_template_random_access(begin, end, __gnu_parallel::nothing(), my_selector, __gnu_parallel::accumulate_binop_reduct<BinaryOperation>(binary_op), res, res, -1, parallelism_tag);\n-\treturn res;\n-      }\n-    else\n-      return accumulate(begin, end, init, binary_op, \n-\t\t\t__gnu_parallel::sequential_tag());\n-  }\n+  template<typename _RandomAccessIterator, typename T,\n+\t   typename BinaryOperation>\n+    T\n+    accumulate_switch(_RandomAccessIterator begin, _RandomAccessIterator end, \n+\t\t      T init, BinaryOperation binary_op, \n+\t\t      random_access_iterator_tag, \n+\t\t      __gnu_parallel::parallelism parallelism_tag  \n+\t\t      = __gnu_parallel::parallel_unbalanced)\n+    {\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t    >= __gnu_parallel::Settings::accumulate_minimal_n\n+\t    && __gnu_parallel::is_parallel(parallelism_tag)))\n+\t{\n+\t  T res = init;\n+\t  __gnu_parallel::accumulate_selector<_RandomAccessIterator>\n+\t    my_selector;\n+\t  __gnu_parallel::\n+\t    for_each_template_random_access(begin, end,\n+\t\t\t\t\t    __gnu_parallel::nothing(),\n+\t\t\t\t\t    my_selector,\n+\t\t\t\t\t    __gnu_parallel::\n+\t\t\t\t\t    accumulate_binop_reduct\n+\t\t\t\t\t    <BinaryOperation>(binary_op),\n+\t\t\t\t\t    res, res, -1, parallelism_tag);\n+\t  return res;\n+\t}\n+      else\n+\treturn accumulate(begin, end, init, binary_op, \n+\t\t\t  __gnu_parallel::sequential_tag());\n+    }\n \n   // Public interface.\n   template<typename InputIterator, typename T>\n-  inline T\n-  accumulate(InputIterator begin, InputIterator end, T init, \n-\t     __gnu_parallel::parallelism parallelism_tag)\n-  {\n-    typedef std::iterator_traits<InputIterator> iterator_traits;\n-    typedef typename iterator_traits::value_type value_type;\n-    typedef typename iterator_traits::iterator_category iterator_category;\n-\n-    return accumulate_switch(begin, end, init, __gnu_parallel::plus<T, value_type>(),\n-\t\t\t     iterator_category(), parallelism_tag);\n-  }\n+    inline T\n+    accumulate(InputIterator begin, InputIterator end, T init, \n+\t       __gnu_parallel::parallelism parallelism_tag)\n+    {\n+      typedef std::iterator_traits<InputIterator> iterator_traits;\n+      typedef typename iterator_traits::value_type value_type;\n+      typedef typename iterator_traits::iterator_category iterator_category;\n+\n+      return accumulate_switch(begin, end, init,\n+\t\t\t       __gnu_parallel::plus<T, value_type>(),\n+\t\t\t       iterator_category(), parallelism_tag);\n+    }\n \n   template<typename InputIterator, typename T>\n-  inline T\n-  accumulate(InputIterator begin, InputIterator end, T init)\n-  {\n-    typedef std::iterator_traits<InputIterator> iterator_traits;\n-    typedef typename iterator_traits::value_type value_type;\n-    typedef typename iterator_traits::iterator_category iterator_category;\n-\n-    return accumulate_switch(begin, end, init, __gnu_parallel::plus<T, value_type>(),\n-\t\t\t     iterator_category());\n-  }\n+    inline T\n+    accumulate(InputIterator begin, InputIterator end, T init)\n+    {\n+      typedef std::iterator_traits<InputIterator> iterator_traits;\n+      typedef typename iterator_traits::value_type value_type;\n+      typedef typename iterator_traits::iterator_category iterator_category;\n+\n+      return accumulate_switch(begin, end, init,\n+\t\t\t       __gnu_parallel::plus<T, value_type>(),\n+\t\t\t       iterator_category());\n+    }\n \n   template<typename InputIterator, typename T, typename BinaryOperation>\n-  inline T\n-  accumulate(InputIterator begin, InputIterator end, T init, \n-\t     BinaryOperation binary_op, \n-\t     __gnu_parallel::parallelism parallelism_tag)\n-  {\n-    typedef iterator_traits<InputIterator> iterator_traits;\n-    typedef typename iterator_traits::iterator_category iterator_category;\n-    return accumulate_switch(begin, end, init, binary_op, \n-\t\t\t     iterator_category(), parallelism_tag);\n-  }\n+    inline T\n+    accumulate(InputIterator begin, InputIterator end, T init, \n+\t       BinaryOperation binary_op, \n+\t       __gnu_parallel::parallelism parallelism_tag)\n+    {\n+      typedef iterator_traits<InputIterator> iterator_traits;\n+      typedef typename iterator_traits::iterator_category iterator_category;\n+      return accumulate_switch(begin, end, init, binary_op, \n+\t\t\t       iterator_category(), parallelism_tag);\n+    }\n \n   template<typename InputIterator, typename T, typename BinaryOperation>\n-  inline T\n-  accumulate(InputIterator begin, InputIterator end, T init, \n-\t     BinaryOperation binary_op) \n-  {\n-    typedef iterator_traits<InputIterator> iterator_traits;\n-    typedef typename iterator_traits::iterator_category iterator_category;\n-    return accumulate_switch(begin, end, init, binary_op, \n-\t\t\t     iterator_category());\n-  }\n+    inline T\n+    accumulate(InputIterator begin, InputIterator end, T init, \n+\t       BinaryOperation binary_op) \n+    {\n+      typedef iterator_traits<InputIterator> iterator_traits;\n+      typedef typename iterator_traits::iterator_category iterator_category;\n+      return accumulate_switch(begin, end, init, binary_op, \n+\t\t\t       iterator_category());\n+    }\n \n \n   // Sequential fallback.\n   template<typename InputIterator1, typename InputIterator2, typename T>\n-  inline T\n-  inner_product(InputIterator1 first1, InputIterator1 last1, \n-\t\tInputIterator2 first2, T init, __gnu_parallel::sequential_tag)\n-  { return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init); }\n-\n-  template<typename InputIterator1, typename InputIterator2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n-  inline T\n-  inner_product(InputIterator1 first1, InputIterator1 last1, \n-\t\tInputIterator2 first2, T init, BinaryFunction1 binary_op1, \n-\t\tBinaryFunction2 binary_op2, __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init, \n-\t\t\t\t\t binary_op1, binary_op2);\n-  }\n+    inline T\n+    inner_product(InputIterator1 first1, InputIterator1 last1, \n+\t\t  InputIterator2 first2, T init,\n+\t\t  __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init); }\n+\n+  template<typename InputIterator1, typename InputIterator2, typename T,\n+\t   typename BinaryFunction1, typename BinaryFunction2>\n+    inline T\n+    inner_product(InputIterator1 first1, InputIterator1 last1, \n+\t\t  InputIterator2 first2, T init, BinaryFunction1 binary_op1, \n+\t\t  BinaryFunction2 binary_op2, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::inner_product(first1, last1, first2, init, \n+\t\t\t\t\t   binary_op1, binary_op2); }\n \n   // Parallel algorithm for random access iterators.\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n-  T\n-  inner_product_switch(RandomAccessIterator1 first1, RandomAccessIterator1 last1, RandomAccessIterator2 first2, T init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2, random_access_iterator_tag, random_access_iterator_tag, __gnu_parallel::parallelism parallelism_tag = __gnu_parallel::parallel_unbalanced)\n-  {\n-    if (_GLIBCXX_PARALLEL_CONDITION((last1 - first1) >= __gnu_parallel::Settings::accumulate_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n-      {\n-\tT res = init;\n-\t__gnu_parallel::inner_product_selector<RandomAccessIterator1, RandomAccessIterator2, T> my_selector(first1, first2);\n-\t__gnu_parallel::for_each_template_random_access(first1, last1, binary_op2, my_selector, binary_op1, res, res, -1, parallelism_tag);\n-\treturn res;\n-      }\n-    else\n-      return inner_product(first1, last1, first2, init, \n-\t\t\t   __gnu_parallel::sequential_tag());\n-  }\n+  template<typename RandomAccessIterator1, typename RandomAccessIterator2,\n+\t   typename T, typename BinaryFunction1, typename BinaryFunction2>\n+    T\n+    inner_product_switch(RandomAccessIterator1 first1,\n+\t\t\t RandomAccessIterator1 last1,\n+\t\t\t RandomAccessIterator2 first2, T init,\n+\t\t\t BinaryFunction1 binary_op1,\n+\t\t\t BinaryFunction2 binary_op2,\n+\t\t\t random_access_iterator_tag,\n+\t\t\t random_access_iterator_tag,\n+\t\t\t __gnu_parallel::parallelism parallelism_tag\n+\t\t\t = __gnu_parallel::parallel_unbalanced)\n+    {\n+      if (_GLIBCXX_PARALLEL_CONDITION((last1 - first1)\n+\t\t\t\t      >= __gnu_parallel::Settings::\n+\t\t\t\t      accumulate_minimal_n\n+\t\t\t\t      && __gnu_parallel::\n+\t\t\t\t      is_parallel(parallelism_tag)))\n+\t{\n+\t  T res = init;\n+\t  __gnu_parallel::\n+\t    inner_product_selector<RandomAccessIterator1,\n+\t    RandomAccessIterator2, T> my_selector(first1, first2);\n+\t  __gnu_parallel::\n+\t    for_each_template_random_access(first1, last1, binary_op2,\n+\t\t\t\t\t    my_selector, binary_op1,\n+\t\t\t\t\t    res, res, -1, parallelism_tag);\n+\t  return res;\n+\t}\n+      else\n+\treturn inner_product(first1, last1, first2, init, \n+\t\t\t     __gnu_parallel::sequential_tag());\n+    }\n \n   // No parallelism for input iterators.\n-  template<typename InputIterator1, typename InputIterator2, typename T, typename BinaryFunction1, typename BinaryFunction2, typename IteratorTag1, typename IteratorTag2>\n-  inline T\n-  inner_product_switch(InputIterator1 first1, InputIterator1 last1, \n-\t\t       InputIterator2 first2, T init, \n-\t\t       BinaryFunction1 binary_op1, BinaryFunction2 binary_op2, \n-\t\t       IteratorTag1, IteratorTag2)\n-  {\n-    return inner_product(first1, last1, first2, init, binary_op1, binary_op2,\n-\t\t\t __gnu_parallel::sequential_tag());\n-  }\n-\n-  template<typename InputIterator1, typename InputIterator2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n-  inline T\n-  inner_product(InputIterator1 first1, InputIterator1 last1, \n-\t\tInputIterator2 first2, T init, BinaryFunction1 binary_op1, \n-\t\tBinaryFunction2 binary_op2, \n-\t\t__gnu_parallel::parallelism parallelism_tag)\n-  {\n-    typedef iterator_traits<InputIterator1> traits1_type;\n-    typedef typename traits1_type::iterator_category iterator1_category;\n-\n-    typedef iterator_traits<InputIterator2> traits2_type;\n-    typedef typename traits2_type::iterator_category iterator2_category;\n-\n-    return inner_product_switch(first1, last1, first2, init, binary_op1, \n-\t\t\t\tbinary_op2, iterator1_category(), \n-\t\t\t\titerator2_category(), parallelism_tag);\n-  }\n-\n-  template<typename InputIterator1, typename InputIterator2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n-  inline T\n-  inner_product(InputIterator1 first1, InputIterator1 last1, \n-\t\tInputIterator2 first2, T init, BinaryFunction1 binary_op1, \n-\t\tBinaryFunction2 binary_op2)\n-  {\n-    typedef iterator_traits<InputIterator1> traits1_type;\n-    typedef typename traits1_type::iterator_category iterator1_category;\n-\n-    typedef iterator_traits<InputIterator2> traits2_type;\n-    typedef typename traits2_type::iterator_category iterator2_category;\n-\n-    return inner_product_switch(first1, last1, first2, init, binary_op1, \n-\t\t\t\tbinary_op2, iterator1_category(),\n-\t\t\t\titerator2_category());\n-  }\n+  template<typename InputIterator1, typename InputIterator2, typename T,\n+\t   typename BinaryFunction1, typename BinaryFunction2,\n+\t   typename IteratorTag1, typename IteratorTag2>\n+    inline T\n+    inner_product_switch(InputIterator1 first1, InputIterator1 last1, \n+\t\t\t InputIterator2 first2, T init, \n+\t\t\t BinaryFunction1 binary_op1,\n+\t\t\t BinaryFunction2 binary_op2, \n+\t\t\t IteratorTag1, IteratorTag2)\n+    { return inner_product(first1, last1, first2, init,\n+\t\t\t   binary_op1, binary_op2,\n+\t\t\t   __gnu_parallel::sequential_tag()); }\n+\n+  template<typename InputIterator1, typename InputIterator2, typename T,\n+\t   typename BinaryFunction1, typename BinaryFunction2>\n+    inline T\n+    inner_product(InputIterator1 first1, InputIterator1 last1, \n+\t\t  InputIterator2 first2, T init, BinaryFunction1 binary_op1, \n+\t\t  BinaryFunction2 binary_op2, \n+\t\t  __gnu_parallel::parallelism parallelism_tag)\n+    {\n+      typedef iterator_traits<InputIterator1> traits1_type;\n+      typedef typename traits1_type::iterator_category iterator1_category;\n+\n+      typedef iterator_traits<InputIterator2> traits2_type;\n+      typedef typename traits2_type::iterator_category iterator2_category;\n+\n+      return inner_product_switch(first1, last1, first2, init, binary_op1, \n+\t\t\t\t  binary_op2, iterator1_category(), \n+\t\t\t\t  iterator2_category(), parallelism_tag);\n+    }\n+\n+  template<typename InputIterator1, typename InputIterator2, typename T,\n+\t   typename BinaryFunction1, typename BinaryFunction2>\n+    inline T\n+    inner_product(InputIterator1 first1, InputIterator1 last1, \n+\t\t  InputIterator2 first2, T init, BinaryFunction1 binary_op1, \n+\t\t  BinaryFunction2 binary_op2)\n+    {\n+      typedef iterator_traits<InputIterator1> traits1_type;\n+      typedef typename traits1_type::iterator_category iterator1_category;\n+\n+      typedef iterator_traits<InputIterator2> traits2_type;\n+      typedef typename traits2_type::iterator_category iterator2_category;\n+\n+      return inner_product_switch(first1, last1, first2, init, binary_op1, \n+\t\t\t\t  binary_op2, iterator1_category(),\n+\t\t\t\t  iterator2_category());\n+    }\n \n   template<typename InputIterator1, typename InputIterator2, typename T>\n-  inline T\n-  inner_product(InputIterator1 first1, InputIterator1 last1, \n-\t\tInputIterator2 first2, T init, \n-\t\t__gnu_parallel::parallelism parallelism_tag)\n-  {\n-    typedef iterator_traits<InputIterator1> traits_type1;\n-    typedef typename traits_type1::value_type value_type1;\n-    typedef iterator_traits<InputIterator2> traits_type2;\n-    typedef typename traits_type2::value_type value_type2;\n-\n-    typedef typename __gnu_parallel::multiplies<value_type1, value_type2>::result\n+    inline T\n+    inner_product(InputIterator1 first1, InputIterator1 last1, \n+\t\t  InputIterator2 first2, T init, \n+\t\t  __gnu_parallel::parallelism parallelism_tag)\n+    {\n+      typedef iterator_traits<InputIterator1> traits_type1;\n+      typedef typename traits_type1::value_type value_type1;\n+      typedef iterator_traits<InputIterator2> traits_type2;\n+      typedef typename traits_type2::value_type value_type2;\n+\n+      typedef typename\n+\t__gnu_parallel::multiplies<value_type1, value_type2>::result\n         multiplies_result_type;\n-    return inner_product(first1, last1, first2, init,\n+      return inner_product(first1, last1, first2, init,\n                            __gnu_parallel::plus<T, multiplies_result_type>(),\n-                           __gnu_parallel::multiplies<value_type1, value_type2>(),\n+                           __gnu_parallel::\n+\t\t\t   multiplies<value_type1, value_type2>(),\n                            parallelism_tag);\n-  }\n+    }\n \n   template<typename InputIterator1, typename InputIterator2, typename T>\n-  inline T\n-  inner_product(InputIterator1 first1, InputIterator1 last1, \n-\t\tInputIterator2 first2, T init)\n-  {\n-    typedef iterator_traits<InputIterator1> traits_type1;\n-    typedef typename traits_type1::value_type value_type1;\n-    typedef iterator_traits<InputIterator2> traits_type2;\n-    typedef typename traits_type2::value_type value_type2;\n-\n-    typedef typename __gnu_parallel::multiplies<value_type1, value_type2>::result\n+    inline T\n+    inner_product(InputIterator1 first1, InputIterator1 last1, \n+\t\t  InputIterator2 first2, T init)\n+    {\n+      typedef iterator_traits<InputIterator1> traits_type1;\n+      typedef typename traits_type1::value_type value_type1;\n+      typedef iterator_traits<InputIterator2> traits_type2;\n+      typedef typename traits_type2::value_type value_type2;\n+\n+      typedef typename\n+\t__gnu_parallel::multiplies<value_type1, value_type2>::result\n         multiplies_result_type;\n-    return inner_product(first1, last1, first2, init,\n+      return inner_product(first1, last1, first2, init,\n                            __gnu_parallel::plus<T, multiplies_result_type>(),\n-                           __gnu_parallel::multiplies<value_type1, value_type2>());\n-  }\n+                           __gnu_parallel::\n+\t\t\t   multiplies<value_type1, value_type2>());\n+    }\n \n   // Sequential fallback.\n   template<typename InputIterator, typename OutputIterator>\n-  inline OutputIterator\n-  partial_sum(InputIterator begin, InputIterator end, OutputIterator result,\n-\t      __gnu_parallel::sequential_tag)\n-  { return _GLIBCXX_STD_P::partial_sum(begin, end, result); }\n+    inline OutputIterator\n+    partial_sum(InputIterator begin, InputIterator end, OutputIterator result,\n+\t\t__gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::partial_sum(begin, end, result); }\n \n   // Sequential fallback.\n-  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n-  inline OutputIterator\n-  partial_sum(InputIterator begin, InputIterator end, OutputIterator result,\n-\t      BinaryOperation bin_op, __gnu_parallel::sequential_tag)\n-  { return _GLIBCXX_STD_P::partial_sum(begin, end, result, bin_op); }\n+  template<typename InputIterator, typename OutputIterator,\n+\t   typename BinaryOperation>\n+    inline OutputIterator\n+    partial_sum(InputIterator begin, InputIterator end, OutputIterator result,\n+\t\tBinaryOperation bin_op, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::partial_sum(begin, end, result, bin_op); }\n \n   // Sequential fallback for input iterator case.\n-  template<typename InputIterator, typename OutputIterator, typename BinaryOperation, typename IteratorTag1, typename IteratorTag2>\n-  inline OutputIterator\n-  partial_sum_switch(InputIterator begin, InputIterator end, OutputIterator result, BinaryOperation bin_op, IteratorTag1, IteratorTag2)\n-  {\n-    return _GLIBCXX_STD_P::partial_sum(begin, end, result, bin_op);\n-  }\n+  template<typename InputIterator, typename OutputIterator,\n+\t   typename BinaryOperation, typename IteratorTag1,\n+\t   typename IteratorTag2>\n+    inline OutputIterator\n+    partial_sum_switch(InputIterator begin, InputIterator end,\n+\t\t       OutputIterator result, BinaryOperation bin_op,\n+\t\t       IteratorTag1, IteratorTag2)\n+    { return _GLIBCXX_STD_P::partial_sum(begin, end, result, bin_op); }\n \n   // Parallel algorithm for random access iterators.\n-  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n-  OutputIterator\n-  partial_sum_switch(InputIterator begin, InputIterator end,\n-\t\t     OutputIterator result, BinaryOperation bin_op,\n-\t\t     random_access_iterator_tag, random_access_iterator_tag)\n-  {\n-    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::partial_sum_minimal_n))\n-      return __gnu_parallel::parallel_partial_sum(begin, end, result, bin_op);\n-    else\n-      return partial_sum(begin, end, result, bin_op, __gnu_parallel::sequential_tag());\n-  }\n+  template<typename InputIterator, typename OutputIterator,\n+\t   typename BinaryOperation>\n+    OutputIterator\n+    partial_sum_switch(InputIterator begin, InputIterator end,\n+\t\t       OutputIterator result, BinaryOperation bin_op,\n+\t\t       random_access_iterator_tag, random_access_iterator_tag)\n+    {\n+      if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::\n+\t\t\t\t      sequence_index_t>(end - begin)\n+\t\t\t\t      >= __gnu_parallel::Settings::\n+\t\t\t\t      partial_sum_minimal_n))\n+\treturn __gnu_parallel::parallel_partial_sum(begin, end,\n+\t\t\t\t\t\t    result, bin_op);\n+      else\n+\treturn partial_sum(begin, end, result, bin_op,\n+\t\t\t   __gnu_parallel::sequential_tag());\n+    }\n \n   // Public interface.\n   template<typename InputIterator, typename OutputIterator>\n-  inline OutputIterator\n-  partial_sum(InputIterator begin, InputIterator end, OutputIterator result)\n-  {\n-    typedef typename iterator_traits<InputIterator>::value_type value_type;\n-    return partial_sum(begin, end, result, std::plus<value_type>());\n-  }\n+    inline OutputIterator\n+    partial_sum(InputIterator begin, InputIterator end, OutputIterator result)\n+    {\n+      typedef typename iterator_traits<InputIterator>::value_type value_type;\n+      return partial_sum(begin, end, result, std::plus<value_type>());\n+    }\n \n   // Public interface\n-  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n-  inline OutputIterator\n-  partial_sum(InputIterator begin, InputIterator end, OutputIterator result,\n-\t      BinaryOperation binary_op)\n-  {\n-    typedef iterator_traits<InputIterator> traitsi_type;\n-    typedef typename traitsi_type::iterator_category iteratori_category;\n-\n-    typedef iterator_traits<OutputIterator> traitso_type;\n-    typedef typename traitso_type::iterator_category iteratoro_category;\n-\n-    return partial_sum_switch(begin, end, result, binary_op,\n-\t\t\t\t   iteratori_category(), iteratoro_category());\n-  }\n+  template<typename InputIterator, typename OutputIterator,\n+\t   typename BinaryOperation>\n+    inline OutputIterator\n+    partial_sum(InputIterator begin, InputIterator end, OutputIterator result,\n+\t\tBinaryOperation binary_op)\n+    {\n+      typedef iterator_traits<InputIterator> traitsi_type;\n+      typedef typename traitsi_type::iterator_category iteratori_category;\n+\n+      typedef iterator_traits<OutputIterator> traitso_type;\n+      typedef typename traitso_type::iterator_category iteratoro_category;\n+\n+      return partial_sum_switch(begin, end, result, binary_op,\n+\t\t\t\titeratori_category(), iteratoro_category());\n+    }\n \n   // Sequential fallback.\n   template<typename InputIterator, typename OutputIterator>\n-  inline OutputIterator\n-  adjacent_difference(InputIterator begin, InputIterator end,\n-\t\t      OutputIterator result, __gnu_parallel::sequential_tag)\n-  { return _GLIBCXX_STD_P::adjacent_difference(begin, end, result); }\n+    inline OutputIterator\n+    adjacent_difference(InputIterator begin, InputIterator end,\n+\t\t\tOutputIterator result, __gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::adjacent_difference(begin, end, result); }\n \n   // Sequential fallback.\n-  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n-  inline OutputIterator\n-  adjacent_difference(InputIterator begin, InputIterator end,\n-\t\t      OutputIterator result, BinaryOperation bin_op,\n-\t\t      __gnu_parallel::sequential_tag)\n-  {\n-    return _GLIBCXX_STD_P::adjacent_difference(begin, end, result, bin_op);\n-  }\n+  template<typename InputIterator, typename OutputIterator,\n+\t   typename BinaryOperation>\n+    inline OutputIterator\n+    adjacent_difference(InputIterator begin, InputIterator end,\n+\t\t\tOutputIterator result, BinaryOperation bin_op,\n+\t\t\t__gnu_parallel::sequential_tag)\n+    { return _GLIBCXX_STD_P::adjacent_difference(begin, end, result, bin_op); }\n \n   // Sequential fallback for input iterator case.\n-  template<typename InputIterator, typename OutputIterator, typename BinaryOperation, typename IteratorTag1, typename IteratorTag2>\n-  inline OutputIterator\n-  adjacent_difference_switch(InputIterator begin, InputIterator end,\n-\t\t\t     OutputIterator result, BinaryOperation bin_op,\n+  template<typename InputIterator, typename OutputIterator,\n+\t   typename BinaryOperation, typename IteratorTag1,\n+\t   typename IteratorTag2>\n+    inline OutputIterator\n+    adjacent_difference_switch(InputIterator begin, InputIterator end,\n+\t\t\t       OutputIterator result, BinaryOperation bin_op,\n \t\t\t     IteratorTag1, IteratorTag2)\n-  { \n-    return adjacent_difference(begin, end, result, bin_op,  \n-\t\t\t       __gnu_parallel::sequential_tag()); \n-  }\n+    { return adjacent_difference(begin, end, result, bin_op,  \n+\t\t\t\t __gnu_parallel::sequential_tag()); }\n \n   // Parallel algorithm for random access iterators.\n-  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n-  OutputIterator\n-  adjacent_difference_switch(InputIterator begin, InputIterator end,\n-\t\t\t     OutputIterator result, BinaryOperation bin_op,\n-\t\t\t     random_access_iterator_tag, \n-\t\t\t     random_access_iterator_tag,\n-\t\t\t     __gnu_parallel::parallelism parallelism_tag\n-\t\t\t     = __gnu_parallel::parallel_balanced)\n-  {\n-    if (_GLIBCXX_PARALLEL_CONDITION(static_cast<__gnu_parallel::sequence_index_t>(end - begin) >= __gnu_parallel::Settings::adjacent_difference_minimal_n && __gnu_parallel::is_parallel(parallelism_tag)))\n-      {\n-\tbool dummy = true;\n-\ttypedef __gnu_parallel::iterator_pair<InputIterator, OutputIterator, random_access_iterator_tag> ip;\n-\t*result = *begin;\n-\tip begin_pair(begin + 1, result + 1), end_pair(end, result + (end - begin));\n-\t__gnu_parallel::adjacent_difference_selector<ip> functionality;\n-\t__gnu_parallel::for_each_template_random_access(begin_pair, end_pair, bin_op, functionality, __gnu_parallel::dummy_reduct(), dummy, dummy, -1, parallelism_tag);\n-\treturn functionality.finish_iterator;\n-      }\n-    else\n-      return adjacent_difference(begin, end, result, bin_op, \n-\t\t\t\t __gnu_parallel::sequential_tag());\n-  }\n+  template<typename InputIterator, typename OutputIterator,\n+\t   typename BinaryOperation>\n+    OutputIterator\n+    adjacent_difference_switch(InputIterator begin, InputIterator end,\n+\t\t\t       OutputIterator result, BinaryOperation bin_op,\n+\t\t\t       random_access_iterator_tag, \n+\t\t\t       random_access_iterator_tag,\n+\t\t\t       __gnu_parallel::parallelism parallelism_tag\n+\t\t\t       = __gnu_parallel::parallel_balanced)\n+    {\n+      if (_GLIBCXX_PARALLEL_CONDITION(\n+\t    static_cast<__gnu_parallel::sequence_index_t>(end - begin)\n+\t    >= __gnu_parallel::Settings::adjacent_difference_minimal_n\n+\t    && __gnu_parallel::is_parallel(parallelism_tag)))\n+\t{\n+\t  bool dummy = true;\n+\t  typedef __gnu_parallel::iterator_pair<InputIterator, OutputIterator,\n+\t    random_access_iterator_tag> ip;\n+\t  *result = *begin;\n+\t  ip begin_pair(begin + 1, result + 1),\n+\t    end_pair(end, result + (end - begin));\n+\t  __gnu_parallel::adjacent_difference_selector<ip> functionality;\n+\t  __gnu_parallel::\n+\t    for_each_template_random_access(begin_pair, end_pair, bin_op,\n+\t\t\t\t\t    functionality,\n+\t\t\t\t\t    __gnu_parallel::dummy_reduct(),\n+\t\t\t\t\t    dummy, dummy, -1, parallelism_tag);\n+\t  return functionality.finish_iterator;\n+\t}\n+      else\n+\treturn adjacent_difference(begin, end, result, bin_op, \n+\t\t\t\t   __gnu_parallel::sequential_tag());\n+    }\n \n   // Public interface.\n   template<typename InputIterator, typename OutputIterator>\n-  inline OutputIterator\n-  adjacent_difference(InputIterator begin, InputIterator end,\n-\t\t      OutputIterator result,\n-\t\t      __gnu_parallel::parallelism parallelism_tag)\n-  {\n-    typedef iterator_traits<InputIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    return adjacent_difference(begin, end, result, std::minus<value_type>(), \n-\t\t\t       parallelism_tag);\n-  }\n+    inline OutputIterator\n+    adjacent_difference(InputIterator begin, InputIterator end,\n+\t\t\tOutputIterator result,\n+\t\t\t__gnu_parallel::parallelism parallelism_tag)\n+    {\n+      typedef iterator_traits<InputIterator> traits_type;\n+      typedef typename traits_type::value_type value_type;\n+      return adjacent_difference(begin, end, result, std::minus<value_type>(),\n+\t\t\t\t parallelism_tag);\n+    }\n \n   template<typename InputIterator, typename OutputIterator>\n-  inline OutputIterator\n-  adjacent_difference(InputIterator begin, InputIterator end,\n-\t\t      OutputIterator result)\n-  {\n-    typedef iterator_traits<InputIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    return adjacent_difference(begin, end, result, std::minus<value_type>());\n-  }\n-\n-  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n-  inline OutputIterator\n-  adjacent_difference(InputIterator begin, InputIterator end,\n-\t\t      OutputIterator result, BinaryOperation binary_op,\n-\t\t      __gnu_parallel::parallelism parallelism_tag)\n-  {\n-    typedef iterator_traits<InputIterator> traitsi_type;\n-    typedef typename traitsi_type::iterator_category iteratori_category;\n-\n-    typedef iterator_traits<OutputIterator> traitso_type;\n-    typedef typename traitso_type::iterator_category iteratoro_category;\n-\n-    return adjacent_difference_switch(begin, end, result, binary_op,\n-\t\t\t\t      iteratori_category(), \n-\t\t\t\t      iteratoro_category(), parallelism_tag);\n-  }\n-\n-  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n-  inline OutputIterator\n-  adjacent_difference(InputIterator begin, InputIterator end,\n-\t\t      OutputIterator result, BinaryOperation binary_op)\n-  {\n-    typedef iterator_traits<InputIterator> traitsi_type;\n-    typedef typename traitsi_type::iterator_category iteratori_category;\n-\n-    typedef iterator_traits<OutputIterator> traitso_type;\n-    typedef typename traitso_type::iterator_category iteratoro_category;\n-\n-    return adjacent_difference_switch(begin, end, result, binary_op,\n-\t\t\t\t      iteratori_category(), \n-\t\t\t\t      iteratoro_category());\n-  }\n+    inline OutputIterator\n+    adjacent_difference(InputIterator begin, InputIterator end,\n+\t\t\tOutputIterator result)\n+    {\n+      typedef iterator_traits<InputIterator> traits_type;\n+      typedef typename traits_type::value_type value_type;\n+      return adjacent_difference(begin, end, result, std::minus<value_type>());\n+    }\n+\n+  template<typename InputIterator, typename OutputIterator,\n+\t   typename BinaryOperation>\n+    inline OutputIterator\n+    adjacent_difference(InputIterator begin, InputIterator end,\n+\t\t\tOutputIterator result, BinaryOperation binary_op,\n+\t\t\t__gnu_parallel::parallelism parallelism_tag)\n+    {\n+      typedef iterator_traits<InputIterator> traitsi_type;\n+      typedef typename traitsi_type::iterator_category iteratori_category;\n+\n+      typedef iterator_traits<OutputIterator> traitso_type;\n+      typedef typename traitso_type::iterator_category iteratoro_category;\n+\n+      return adjacent_difference_switch(begin, end, result, binary_op,\n+\t\t\t\t\titeratori_category(), \n+\t\t\t\t\titeratoro_category(), parallelism_tag);\n+    }\n+\n+  template<typename InputIterator, typename OutputIterator,\n+\t   typename BinaryOperation>\n+    inline OutputIterator\n+    adjacent_difference(InputIterator begin, InputIterator end,\n+\t\t\tOutputIterator result, BinaryOperation binary_op)\n+    {\n+      typedef iterator_traits<InputIterator> traitsi_type;\n+      typedef typename traitsi_type::iterator_category iteratori_category;\n+\n+      typedef iterator_traits<OutputIterator> traitso_type;\n+      typedef typename traitso_type::iterator_category iteratoro_category;\n+\n+      return adjacent_difference_switch(begin, end, result, binary_op,\n+\t\t\t\t\titeratori_category(), \n+\t\t\t\t\titeratoro_category());\n+    }\n } // end namespace\n } // end namespace\n "}, {"sha": "f693a60a3bdb17379934bdc9680ac6f7ef102ffb", "filename": "libstdc++-v3/include/parallel/numericfwd.h", "status": "modified", "additions": 131, "deletions": 115, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fnumericfwd.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // <numeric> parallel extensions -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -44,146 +44,162 @@ namespace std\n {\n namespace __parallel\n {\n-  template<typename _IIter, typename T>\n-  inline T\n-  accumulate(_IIter, _IIter, T);\n-\n-  template<typename _IIter, typename T>\n-  inline T\n-  accumulate(_IIter, _IIter, T, __gnu_parallel::sequential_tag);\n-\n-  template<typename _IIter, typename T>\n-  inline T\n-  accumulate(_IIter, _IIter, T, __gnu_parallel::parallelism parallelism_tag);\n-\n-  template<typename _IIter, typename T, typename _Tag>\n-  inline T\n-  accumulate_switch(_IIter, _IIter, T, _Tag);\n-\n-  template<typename _IIter, typename T, typename _BinaryOper>\n-  inline T\n-  accumulate(_IIter, _IIter, T, _BinaryOper);\n-\n-  template<typename _IIter, typename T, typename _BinaryOper>\n-  inline T\n-  accumulate(_IIter, _IIter, T, _BinaryOper, __gnu_parallel::sequential_tag);\n-\n-  template<typename _IIter, typename T, typename _BinaryOper>\n-  inline T\n-  accumulate(_IIter, _IIter, T, _BinaryOper, \n-\t     __gnu_parallel::parallelism parallelism_tag);\n-\n-  template<typename _IIter, typename T, typename _BinaryOper, typename _Tag>\n-  T\n-  accumulate_switch(_IIter, _IIter, T, _BinaryOper, _Tag);\n-\n-  template<typename _RAIter, typename T, typename _BinaryOper>\n-  T\n-  accumulate_switch(_RAIter, _RAIter, T, _BinaryOper, \n-\t\t    random_access_iterator_tag, __gnu_parallel::parallelism);\n-\n+  template<typename _IIter, typename _Tp>\n+    _Tp\n+    accumulate(_IIter, _IIter, _Tp);\n+\n+  template<typename _IIter, typename _Tp>\n+    _Tp\n+    accumulate(_IIter, _IIter, _Tp, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename _Tp>\n+    _Tp\n+    accumulate(_IIter, _IIter, _Tp, __gnu_parallel::parallelism);\n+\n+  template<typename _IIter, typename _Tp, typename _Tag>\n+    _Tp\n+    accumulate_switch(_IIter, _IIter, _Tp, _Tag);\n+\n+  template<typename _IIter, typename _Tp, typename _BinaryOper>\n+    _Tp\n+    accumulate(_IIter, _IIter, _Tp, _BinaryOper);\n+\n+  template<typename _IIter, typename _Tp, typename _BinaryOper>\n+    _Tp\n+    accumulate(_IIter, _IIter, _Tp, _BinaryOper,\n+\t       __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter, typename _Tp, typename _BinaryOper>\n+    _Tp\n+    accumulate(_IIter, _IIter, _Tp, _BinaryOper,\n+\t       __gnu_parallel::parallelism);\n+\n+  template<typename _IIter, typename _Tp, typename _BinaryOper,\n+\t   typename _Tag>\n+    _Tp\n+    accumulate_switch(_IIter, _IIter, _Tp, _BinaryOper, _Tag);\n+\n+  template<typename _RAIter, typename _Tp, typename _BinaryOper>\n+    _Tp\n+    accumulate_switch(_RAIter, _RAIter, _Tp, _BinaryOper,\n+\t\t      random_access_iterator_tag,\n+\t\t      __gnu_parallel::parallelism);\n \n- template<typename _IIter, typename _OIter>\n-  inline _OIter\n-  adjacent_difference(_IIter, _IIter, _OIter);\n+  template<typename _IIter, typename _OIter>\n+    _OIter\n+    adjacent_difference(_IIter, _IIter, _OIter);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n-  inline _OIter\n-  adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper);\n+    _OIter\n+    adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper);\n \n   template<typename _IIter, typename _OIter>\n-  inline _OIter\n-  adjacent_difference(_IIter, _IIter, _OIter, __gnu_parallel::sequential_tag);\n+    _OIter\n+    adjacent_difference(_IIter, _IIter, _OIter,\n+\t\t\t__gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n-  inline _OIter\n-  adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper, \n-\t\t      __gnu_parallel::sequential_tag);\n+    _OIter\n+    adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper, \n+\t\t\t__gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _OIter>\n-  inline _OIter\n-  adjacent_difference(_IIter, _IIter, _OIter, __gnu_parallel::parallelism);\n+    _OIter\n+    adjacent_difference(_IIter, _IIter, _OIter,\n+\t\t\t__gnu_parallel::parallelism);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n-  inline _OIter\n-  adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper, \n-\t\t      __gnu_parallel::parallelism);\n+    _OIter\n+    adjacent_difference(_IIter, _IIter, _OIter, _BinaryOper, \n+\t\t\t__gnu_parallel::parallelism);\n \n-  template<typename _IIter, typename _OIter, typename _BinaryOper, typename _Tag1, typename _Tag2>\n-  inline _OIter\n-  adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper, _Tag1, _Tag2);\n+  template<typename _IIter, typename _OIter, typename _BinaryOper,\n+\t   typename _Tag1, typename _Tag2>\n+    _OIter\n+    adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper,\n+\t\t\t       _Tag1, _Tag2);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n-  _OIter\n-  adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper, \n-\t\t\t     random_access_iterator_tag, \n-\t\t\t     random_access_iterator_tag, \n-\t\t\t     __gnu_parallel::parallelism);\n-\n-\n-  template<typename _IIter1, typename _IIter2, typename T>\n-  inline T\n-  inner_product(_IIter1, _IIter1, _IIter2, T);\n-\n-  template<typename _IIter1, typename _IIter2, typename T>\n-  inline T\n-  inner_product(_IIter1, _IIter1, _IIter2, T, __gnu_parallel::sequential_tag);\n-\n-  template<typename _IIter1, typename _IIter2, typename T>\n-  inline T\n-  inner_product(_IIter1, _IIter1, _IIter2, T, __gnu_parallel::parallelism);\n-\n-\n-  template<typename _IIter1, typename _IIter2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n-  inline T\n-  inner_product(_IIter1, _IIter1, _IIter2, T, BinaryFunction1, BinaryFunction2);\n-\n-  template<typename _IIter1, typename _IIter2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n-  inline T\n-  inner_product(_IIter1, _IIter1, _IIter2, T, BinaryFunction1, BinaryFunction2,\n-\t\t__gnu_parallel::sequential_tag);\n-\n-  template<typename _IIter1, typename _IIter2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n-  inline T\n-  inner_product(_IIter1, _IIter1, _IIter2, T, BinaryFunction1, BinaryFunction2,\n-\t\t__gnu_parallel::parallelism);\n-\n-  template<typename _RAIter1, typename _RAIter2, typename T, typename BinaryFunction1, typename BinaryFunction2>\n-  T\n-  inner_product_switch(_RAIter1, _RAIter1, _RAIter2, T, BinaryFunction1, \n-\t\t       BinaryFunction2, random_access_iterator_tag, \n-\t\t       random_access_iterator_tag, \n-\t\t       __gnu_parallel::parallelism);\n-\n-  template<typename _IIter1, typename _IIter2, typename T, typename BinaryFunction1, typename BinaryFunction2, typename _Tag1, typename _Tag2>\n-  inline T\n-  inner_product_switch(_IIter1, _IIter1, _IIter2, T, BinaryFunction1, \n-\t\t       BinaryFunction2, _Tag1, _Tag2);\n+    _OIter\n+    adjacent_difference_switch(_IIter, _IIter, _OIter, _BinaryOper, \n+\t\t\t       random_access_iterator_tag, \n+\t\t\t       random_access_iterator_tag, \n+\t\t\t       __gnu_parallel::parallelism);\n+\n+  template<typename _IIter1, typename _IIter2, typename _Tp>\n+    _Tp\n+    inner_product(_IIter1, _IIter1, _IIter2, _Tp);\n+\n+  template<typename _IIter1, typename _IIter2, typename _Tp>\n+    _Tp\n+    inner_product(_IIter1, _IIter1, _IIter2, _Tp,\n+\t\t  __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _Tp>\n+    _Tp\n+    inner_product(_IIter1, _IIter1, _IIter2, _Tp,\n+\t\t  __gnu_parallel::parallelism);\n+\n+  template<typename _IIter1, typename _IIter2, typename _Tp,\n+\t   typename _BinaryFunction1, typename _BinaryFunction2>\n+    _Tp\n+    inner_product(_IIter1, _IIter1, _IIter2, _Tp,\n+\t\t  _BinaryFunction1, _BinaryFunction2);\n+\n+  template<typename _IIter1, typename _IIter2, typename _Tp,\n+\t   typename _BinaryFunction1, typename _BinaryFunction2>\n+    _Tp\n+    inner_product(_IIter1, _IIter1, _IIter2, _Tp, _BinaryFunction1,\n+\t\t  _BinaryFunction2, __gnu_parallel::sequential_tag);\n+\n+  template<typename _IIter1, typename _IIter2, typename _Tp,\n+\t   typename BinaryFunction1, typename BinaryFunction2>\n+    _Tp\n+    inner_product(_IIter1, _IIter1, _IIter2, _Tp, BinaryFunction1,\n+\t\t  BinaryFunction2, __gnu_parallel::parallelism);\n+\n+  template<typename _RAIter1, typename _RAIter2, typename _Tp,\n+\t   typename BinaryFunction1, typename BinaryFunction2>\n+    _Tp\n+    inner_product_switch(_RAIter1, _RAIter1, _RAIter2, _Tp, BinaryFunction1, \n+\t\t\t BinaryFunction2, random_access_iterator_tag, \n+\t\t\t random_access_iterator_tag, \n+\t\t\t __gnu_parallel::parallelism);\n+\n+  template<typename _IIter1, typename _IIter2, typename _Tp,\n+\t   typename _BinaryFunction1, typename _BinaryFunction2,\n+\t   typename _Tag1, typename _Tag2>\n+    _Tp\n+    inner_product_switch(_IIter1, _IIter1, _IIter2, _Tp, _BinaryFunction1, \n+\t\t\t _BinaryFunction2, _Tag1, _Tag2);\n \n \n   template<typename _IIter, typename _OIter>\n-  inline _OIter\n-  partial_sum(_IIter, _IIter, _OIter, __gnu_parallel::sequential_tag);\n+    _OIter\n+    partial_sum(_IIter, _IIter, _OIter, __gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n-  inline _OIter\n-  partial_sum(_IIter, _IIter, _OIter, _BinaryOper, __gnu_parallel::sequential_tag);\n+    _OIter\n+    partial_sum(_IIter, _IIter, _OIter, _BinaryOper,\n+\t\t__gnu_parallel::sequential_tag);\n \n   template<typename _IIter, typename _OIter>\n-  inline _OIter\n-  partial_sum(_IIter, _IIter, _OIter result);\n+    _OIter\n+    partial_sum(_IIter, _IIter, _OIter result);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n-  inline _OIter\n-  partial_sum(_IIter, _IIter, _OIter, _BinaryOper);\n+    _OIter\n+    partial_sum(_IIter, _IIter, _OIter, _BinaryOper);\n \n-  template<typename _IIter, typename _OIter, typename _BinaryOper, typename _Tag1, typename _Tag2>\n-  inline _OIter\n-  partial_sum_switch(_IIter, _IIter, _OIter, _BinaryOper, _Tag1, _Tag2);\n+  template<typename _IIter, typename _OIter, typename _BinaryOper,\n+\t   typename _Tag1, typename _Tag2>\n+    _OIter\n+    partial_sum_switch(_IIter, _IIter, _OIter, _BinaryOper, _Tag1, _Tag2);\n \n   template<typename _IIter, typename _OIter, typename _BinaryOper>\n-  _OIter\n-  partial_sum_switch(_IIter, _IIter, _OIter, _BinaryOper, random_access_iterator_tag, random_access_iterator_tag);\n+    _OIter\n+    partial_sum_switch(_IIter, _IIter, _OIter, _BinaryOper,\n+\t\t       random_access_iterator_tag, random_access_iterator_tag);\n } // end namespace\n } // end namespace\n "}, {"sha": "97660c16bbcc0b3131e860002829f46d586e0682", "filename": "libstdc++-v3/include/parallel/omp_loop.h", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -65,25 +65,26 @@ namespace __gnu_parallel\n   *  @return User-supplied functor (that may contain a part of the result).\n   */\n template<typename RandomAccessIterator,\n-            typename Op,\n-            typename Fu,\n-            typename Red,\n-            typename Result>\n+\t typename Op,\n+\t typename Fu,\n+\t typename Red,\n+\t typename Result>\n   Op\n-  for_each_template_random_access_omp_loop(\n-             RandomAccessIterator begin,\n-             RandomAccessIterator end,\n-             Op o, Fu& f, Red r, Result base, Result& output,\n-             typename std::iterator_traits<RandomAccessIterator>::\n-                 difference_type bound)\n+  for_each_template_random_access_omp_loop(RandomAccessIterator begin,\n+\t\t\t\t\t   RandomAccessIterator end,\n+\t\t\t\t\t   Op o, Fu& f, Red r, Result base,\n+\t\t\t\t\t   Result& output,\n+\t\t\t\t\t   typename std::iterator_traits\n+\t\t\t\t\t   <RandomAccessIterator>::\n+\t\t\t\t\t   difference_type bound)\n   {\n     typedef typename\n         std::iterator_traits<RandomAccessIterator>::difference_type\n         difference_type;\n \n     difference_type length = end - begin;\n     thread_index_t num_threads =\n-        __gnu_parallel::min<difference_type>(get_max_threads(), length);\n+      __gnu_parallel::min<difference_type>(get_max_threads(), length);\n \n     Result *thread_results;\n \n@@ -94,19 +95,19 @@ template<typename RandomAccessIterator,\n             num_threads = omp_get_num_threads();\n             thread_results = new Result[num_threads];\n \n-            for (thread_index_t i = 0; i < num_threads; i++)\n+            for (thread_index_t i = 0; i < num_threads; ++i)\n               thread_results[i] = Result();\n           }\n \n         thread_index_t iam = omp_get_thread_num();\n \n #       pragma omp for schedule(dynamic, Settings::workstealing_chunk_size)\n-        for (difference_type pos = 0; pos < length; pos++)\n+        for (difference_type pos = 0; pos < length; ++pos)\n           thread_results[iam] =\n               r(thread_results[iam], f(o, begin+pos));\n       } //parallel\n \n-    for (thread_index_t i = 0; i < num_threads; i++)\n+    for (thread_index_t i = 0; i < num_threads; ++i)\n         output = r(output, thread_results[i]);\n \n     delete [] thread_results;"}, {"sha": "2546bb201655f6fa0d28e5f3ee78ff46bdc962b4", "filename": "libstdc++-v3/include/parallel/omp_loop_static.h", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -65,25 +65,26 @@ namespace __gnu_parallel\n    *  @return User-supplied functor (that may contain a part of the result).\n    */\n template<typename RandomAccessIterator,\n-          typename Op,\n-          typename Fu,\n-          typename Red,\n-          typename Result>\n+\t typename Op,\n+\t typename Fu,\n+\t typename Red,\n+\t typename Result>\n   Op\n-  for_each_template_random_access_omp_loop_static(\n-              RandomAccessIterator begin,\n-              RandomAccessIterator end,\n-              Op o, Fu& f, Red r, Result base, Result& output,\n-              typename std::iterator_traits<RandomAccessIterator>::\n-                  difference_type bound)\n+  for_each_template_random_access_omp_loop_static(RandomAccessIterator begin,\n+\t\t\t\t\t\t  RandomAccessIterator end,\n+\t\t\t\t\t\t  Op o, Fu& f, Red r,\n+\t\t\t\t\t\t  Result base, Result& output,\n+\t\t\t\t\t\t  typename std::iterator_traits\n+\t\t\t\t\t\t  <RandomAccessIterator>::\n+\t\t\t\t\t\t  difference_type bound)\n   {\n     typedef typename\n-        std::iterator_traits<RandomAccessIterator>::difference_type\n-        difference_type;\n+      std::iterator_traits<RandomAccessIterator>::difference_type\n+      difference_type;\n \n     difference_type length = end - begin;\n     thread_index_t num_threads =\n-        std::min<difference_type>(get_max_threads(), length);\n+      std::min<difference_type>(get_max_threads(), length);\n \n     Result *thread_results;\n \n@@ -94,20 +95,19 @@ template<typename RandomAccessIterator,\n             num_threads = omp_get_num_threads();\n             thread_results = new Result[num_threads];\n \n-            for (thread_index_t i = 0; i < num_threads; i++)\n+            for (thread_index_t i = 0; i < num_threads; ++i)\n               thread_results[i] = Result();\n           }\n \n         thread_index_t iam = omp_get_thread_num();\n \n #       pragma omp for schedule(static, Settings::workstealing_chunk_size)\n-        for (difference_type pos = 0; pos < length; pos++)\n-          thread_results[iam] =\n-              r(thread_results[iam], f(o, begin+pos));\n+        for (difference_type pos = 0; pos < length; ++pos)\n+          thread_results[iam] = r(thread_results[iam], f(o, begin+pos));\n       } //parallel\n \n-    for (thread_index_t i = 0; i < num_threads; i++)\n-        output = r(output, thread_results[i]);\n+    for (thread_index_t i = 0; i < num_threads; ++i)\n+      output = r(output, thread_results[i]);\n \n     delete [] thread_results;\n "}, {"sha": "9e6c2ea641eaa59d18b2cbc8383908a4a35c107a", "filename": "libstdc++-v3/include/parallel/par_loop.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -64,19 +64,19 @@ namespace __gnu_parallel\n   *  std::count_n()).\n   *  @return User-supplied functor (that may contain a part of the result).\n   */\n-template<\n-    typename RandomAccessIterator,\n-    typename Op,\n-    typename Fu,\n-    typename Red,\n-    typename Result>\n+template<typename RandomAccessIterator,\n+\t typename Op,\n+\t typename Fu,\n+\t typename Red,\n+\t typename Result>\n   Op\n-  for_each_template_random_access_ed(\n-              RandomAccessIterator begin,\n-              RandomAccessIterator end,\n-              Op o, Fu& f, Red r, Result base, Result& output,\n-              typename std::iterator_traits<RandomAccessIterator>::\n-                  difference_type bound)\n+  for_each_template_random_access_ed(RandomAccessIterator begin,\n+\t\t\t\t     RandomAccessIterator end,\n+\t\t\t\t     Op o, Fu& f, Red r, Result base,\n+\t\t\t\t     Result& output,\n+\t\t\t\t     typename std::iterator_traits\n+\t\t\t\t     <RandomAccessIterator>::\n+\t\t\t\t     difference_type bound)\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::difference_type difference_type;\n@@ -85,7 +85,7 @@ template<\n     Result *thread_results;\n \n     thread_index_t num_threads =\n-        __gnu_parallel::min<difference_type>(get_max_threads(), length);\n+      __gnu_parallel::min<difference_type>(get_max_threads(), length);\n \n #   pragma omp parallel num_threads(num_threads)\n       {\n@@ -116,7 +116,7 @@ template<\n         thread_results[iam] = reduct;\n       } //parallel\n \n-    for (thread_index_t i = 0; i < num_threads; i++)\n+    for (thread_index_t i = 0; i < num_threads; ++i)\n       output = r(output, thread_results[i]);\n \n     // Points to last element processed (needed as return value for"}, {"sha": "f7ca754720d1acc9a6aab155e1a77c5bafe139e6", "filename": "libstdc++-v3/include/parallel/partial_sum.h", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -57,15 +57,14 @@ namespace __gnu_parallel\n   *  @param value Start value. Must be passed since the neutral\n   *  element is unknown in general.\n   *  @return End iterator of output sequence. */\n-template<\n-    typename InputIterator,\n-    typename OutputIterator,\n-    typename BinaryOperation>\n-  inline OutputIterator\n-  parallel_partial_sum_basecase(\n-            InputIterator begin, InputIterator end,\n-            OutputIterator result, BinaryOperation bin_op,\n-            typename std::iterator_traits<InputIterator>::value_type value)\n+template<typename InputIterator,\n+\t typename OutputIterator,\n+\t typename BinaryOperation>\n+  OutputIterator\n+  parallel_partial_sum_basecase(InputIterator begin, InputIterator end,\n+\t\t\t\tOutputIterator result, BinaryOperation bin_op,\n+\t\t\t\ttypename std::iterator_traits\n+\t\t\t\t<InputIterator>::value_type value)\n   {\n     if (begin == end)\n       return result;\n@@ -90,15 +89,14 @@ template<\n     *  @param num_threads Number of threads to use.\n     *  @return End iterator of output sequence.\n     */\n-template<\n-    typename InputIterator,\n-    typename OutputIterator,\n-    typename BinaryOperation>\n+template<typename InputIterator,\n+\t typename OutputIterator,\n+\t typename BinaryOperation>\n   OutputIterator\n-  parallel_partial_sum_linear(\n-            InputIterator begin, InputIterator end,\n-            OutputIterator result, BinaryOperation bin_op,\n-            typename std::iterator_traits<InputIterator>::difference_type n)\n+  parallel_partial_sum_linear(InputIterator begin, InputIterator end,\n+\t\t\t      OutputIterator result, BinaryOperation bin_op,\n+\t\t\t      typename std::iterator_traits\n+\t\t\t      <InputIterator>::difference_type n)\n   {\n     typedef std::iterator_traits<InputIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n@@ -133,9 +131,10 @@ template<\n             else\n               {\n                 difference_type chunk_length =\n-                    ((double)n /\n-                    ((double)num_threads + Settings::partial_sum_dilatation)),\n-                    borderstart = n - num_threads * chunk_length;\n+                    ((double)n\n+\t\t     / ((double)num_threads\n+\t\t\t+ Settings::partial_sum_dilatation)),\n+\t\t  borderstart = n - num_threads * chunk_length;\n                 borders[0] = 0;\n                 for (int i = 1; i < (num_threads + 1); ++i)\n                   {\n@@ -145,8 +144,8 @@ template<\n                 borders[num_threads + 1] = n;\n               }\n \n-            sums = static_cast<value_type*>(\n-                ::operator new(sizeof(value_type) * num_threads));\n+            sums = static_cast<value_type*>(::operator new(sizeof(value_type)\n+\t\t\t\t\t\t\t   * num_threads));\n             OutputIterator target_end;\n           } //single\n \n@@ -155,16 +154,17 @@ template<\n           {\n             *result = *begin;\n             parallel_partial_sum_basecase(begin + 1, begin + borders[1],\n-                          result + 1, bin_op, *begin);\n+\t\t\t\t\t  result + 1, bin_op, *begin);\n             ::new(&(sums[iam])) value_type(*(result + borders[1] - 1));\n           }\n         else\n           {\n-            ::new(&(sums[iam])) value_type(\n-                                std::accumulate(begin + borders[iam] + 1,\n-                                begin + borders[iam + 1],\n-                                *(begin + borders[iam]),\n-                                bin_op, __gnu_parallel::sequential_tag()));\n+            ::new(&(sums[iam]))\n+\t      value_type(std::accumulate(begin + borders[iam] + 1,\n+\t\t\t\t\t begin + borders[iam + 1],\n+\t\t\t\t\t *(begin + borders[iam]),\n+\t\t\t\t\t bin_op,\n+\t\t\t\t\t __gnu_parallel::sequential_tag()));\n           }\n \n #       pragma omp barrier\n@@ -177,9 +177,9 @@ template<\n \n         // Still same team.\n         parallel_partial_sum_basecase(begin + borders[iam + 1],\n-                      begin + borders[iam + 2],\n-                      result + borders[iam + 1], bin_op,\n-                      sums[iam]);\n+\t\t\t\t      begin + borders[iam + 2],\n+\t\t\t\t      result + borders[iam + 1], bin_op,\n+\t\t\t\t      sums[iam]);\n       } //parallel\n \n     ::operator delete(sums);\n@@ -194,10 +194,9 @@ template<\n   *  @param result Begin iterator of output sequence.\n   *  @param bin_op Associative binary function.\n   *  @return End iterator of output sequence. */\n-template<\n-    typename InputIterator,\n-    typename OutputIterator,\n-    typename BinaryOperation>\n+template<typename InputIterator,\n+\t typename OutputIterator,\n+\t typename BinaryOperation>\n   OutputIterator\n   parallel_partial_sum(InputIterator begin, InputIterator end,\n                        OutputIterator result, BinaryOperation bin_op)"}, {"sha": "9dfcaadd84dad4cd516a8327d4558f13fe0d3b4d", "filename": "libstdc++-v3/include/parallel/partition.h", "status": "modified", "additions": 50, "deletions": 38, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -92,10 +92,11 @@ template<typename RandomAccessIterator, typename Predicate>\n             reserved_right = new bool[num_threads];\n \n             if (Settings::partition_chunk_share > 0.0)\n-              chunk_size = std::max<difference_type>(\n-                  Settings::partition_chunk_size,\n-                  (double)n * Settings::partition_chunk_share /\n-                        (double)num_threads);\n+              chunk_size = std::max<difference_type>(Settings::\n+\t\t\t\t\t\t     partition_chunk_size,\n+\t\t\t\t\t\t     (double)n * Settings::\n+\t\t\t\t\t\t     partition_chunk_share\n+\t\t\t\t\t\t     / (double)num_threads);\n             else\n               chunk_size = Settings::partition_chunk_size;\n           }\n@@ -106,7 +107,7 @@ template<typename RandomAccessIterator, typename Predicate>\n               {\n                 difference_type num_chunks = (right - left + 1) / chunk_size;\n \n-                for (int r = 0; r < num_threads; r++)\n+                for (int r = 0; r < num_threads; ++r)\n                   {\n                     reserved_left[r] = false;\n                     reserved_right[r] = false;\n@@ -164,29 +165,29 @@ template<typename RandomAccessIterator, typename Predicate>\n                   {\n                     while (pred(begin[thread_left])\n                             && thread_left <= thread_left_border)\n-                      thread_left++;\n+                      ++thread_left;\n                     while (!pred(begin[thread_right])\n                             && thread_right >= thread_right_border)\n-                      thread_right--;\n+                      --thread_right;\n \n                     if (thread_left > thread_left_border\n                         || thread_right < thread_right_border)\n                       // Fetch new chunk(s).\n                       break;\n \n                     std::swap(begin[thread_left], begin[thread_right]);\n-                    thread_left++;\n-                    thread_right--;\n+                    ++thread_left;\n+                    --thread_right;\n                   }\n               }\n \n             // Now swap the leftover chunks to the right places.\n             if (thread_left <= thread_left_border)\n #             pragma omp atomic\n-              leftover_left++;\n+              ++leftover_left;\n             if (thread_right >= thread_right_border)\n #             pragma omp atomic\n-              leftover_right++;\n+              ++leftover_right;\n \n #           pragma omp barrier\n \n@@ -212,9 +213,8 @@ template<typename RandomAccessIterator, typename Predicate>\n                 && thread_right_border <= rightnew)\n               {\n                 // Chunk already in place, reserve spot.\n-                reserved_right\n-                    [((thread_right_border - 1) - right) / chunk_size]\n-                    = true;\n+                reserved_right[((thread_right_border - 1) - right)\n+\t\t\t       / chunk_size] = true;\n               }\n \n #           pragma omp barrier\n@@ -225,7 +225,7 @@ template<typename RandomAccessIterator, typename Predicate>\n                 // Find spot and swap.\n                 difference_type swapstart = -1;\n                 omp_set_lock(&result_lock);\n-                for (int r = 0; r < leftover_left; r++)\n+                for (int r = 0; r < leftover_left; ++r)\n                   if (!reserved_left[r])\n                     {\n                       reserved_left[r] = true;\n@@ -238,10 +238,10 @@ template<typename RandomAccessIterator, typename Predicate>\n                 _GLIBCXX_PARALLEL_ASSERT(swapstart != -1);\n #endif\n \n-                std::swap_ranges(\n-                    begin + thread_left_border - (chunk_size - 1),\n-                    begin + thread_left_border + 1,\n-                    begin + swapstart);\n+                std::swap_ranges(begin + thread_left_border\n+\t\t\t\t - (chunk_size - 1),\n+\t\t\t\t begin + thread_left_border + 1,\n+\t\t\t\t begin + swapstart);\n               }\n \n             if (thread_right >= thread_right_border\n@@ -250,7 +250,7 @@ template<typename RandomAccessIterator, typename Predicate>\n                 // Find spot and swap\n                 difference_type swapstart = -1;\n                 omp_set_lock(&result_lock);\n-                for (int r = 0; r < leftover_right; r++)\n+                for (int r = 0; r < leftover_right; ++r)\n                   if (!reserved_right[r])\n                     {\n                       reserved_right[r] = true;\n@@ -264,17 +264,17 @@ template<typename RandomAccessIterator, typename Predicate>\n #endif\n \n                 std::swap_ranges(begin + thread_right_border,\n-                                begin + thread_right_border + chunk_size,\n-                                begin + swapstart);\n+\t\t\t\t begin + thread_right_border + chunk_size,\n+\t\t\t\t begin + swapstart);\n               }\n #if _GLIBCXX_ASSERTIONS\n #             pragma omp barrier\n \n #             pragma omp single\n                 {\n-                  for (int r = 0; r < leftover_left; r++)\n+                  for (int r = 0; r < leftover_left; ++r)\n                     _GLIBCXX_PARALLEL_ASSERT(reserved_left[r]);\n-                  for (int r = 0; r < leftover_right; r++)\n+                  for (int r = 0; r < leftover_right; ++r)\n                     _GLIBCXX_PARALLEL_ASSERT(reserved_right[r]);\n                 }\n \n@@ -295,17 +295,17 @@ template<typename RandomAccessIterator, typename Predicate>\n       {\n         // Go right until key is geq than pivot.\n         while (pred(begin[final_left]) && final_left < final_right)\n-          final_left++;\n+          ++final_left;\n \n         // Go left until key is less than pivot.\n         while (!pred(begin[final_right]) && final_left < final_right)\n-          final_right--;\n+          --final_right;\n \n         if (final_left == final_right)\n           break;\n         std::swap(begin[final_left], begin[final_right]);\n-        final_left++;\n-        final_right--;\n+        ++final_left;\n+        --final_right;\n       }\n \n     // All elements on the left side are < piv, all elements on the\n@@ -345,7 +345,8 @@ template<typename RandomAccessIterator, typename Comparator>\n     RandomAccessIterator split;\n     random_number rng;\n \n-    difference_type minimum_length = std::max<difference_type>(2, Settings::partition_minimal_n);\n+    difference_type minimum_length =\n+      std::max<difference_type>(2, Settings::partition_minimal_n);\n \n     // Break if input range to small.\n     while (static_cast<sequence_index_t>(end - begin) >= minimum_length)\n@@ -359,15 +360,19 @@ template<typename RandomAccessIterator, typename Comparator>\n           std::swap(*pivot_pos, *(end - 1));\n         pivot_pos = end - 1;\n \n-        // XXX Comparator must have first_value_type, second_value_type, result_type\n-        // Comparator == __gnu_parallel::lexicographic<S, int, __gnu_parallel::less<S, S> >\n+        // XXX Comparator must have first_value_type, second_value_type,\n+\t// result_type\n+        // Comparator == __gnu_parallel::lexicographic<S, int,\n+\t// __gnu_parallel::less<S, S> >\n         // pivot_pos == std::pair<S, int>*\n         // XXX binder2nd only for RandomAccessIterators??\n-        __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool> pred(comp, *pivot_pos);\n+        __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool>\n+\t  pred(comp, *pivot_pos);\n \n         // Divide, leave pivot unchanged in last place.\n         RandomAccessIterator split_pos1, split_pos2;\n-        split_pos1 = begin + parallel_partition(begin, end - 1, pred, get_max_threads());\n+        split_pos1 = begin + parallel_partition(begin, end - 1, pred,\n+\t\t\t\t\t\tget_max_threads());\n \n         // Left side: < pivot_pos; right side: >= pivot_pos\n \n@@ -377,14 +382,19 @@ template<typename RandomAccessIterator, typename Comparator>\n         pivot_pos = split_pos1;\n \n         // In case all elements are equal, split_pos1 == 0\n-        if ((split_pos1 + 1 - begin) < (n >> 7) || (end - split_pos1) < (n >> 7))\n+        if ((split_pos1 + 1 - begin) < (n >> 7)\n+\t    || (end - split_pos1) < (n >> 7))\n           {\n             // Very unequal split, one part smaller than one 128th\n             // elements not stricly larger than the pivot.\n-            __gnu_parallel::unary_negate<__gnu_parallel::binder1st<Comparator, value_type, value_type, bool>, value_type> pred(__gnu_parallel::binder1st<Comparator, value_type, value_type, bool>(comp, *pivot_pos));\n+            __gnu_parallel::unary_negate<__gnu_parallel::\n+\t      binder1st<Comparator, value_type, value_type, bool>, value_type>\n+\t      pred(__gnu_parallel::binder1st<Comparator, value_type,\n+\t\t   value_type, bool>(comp, *pivot_pos));\n \n             // Find other end of pivot-equal range.\n-            split_pos2 = __gnu_sequential::partition(split_pos1 + 1, end, pred);\n+            split_pos2 = __gnu_sequential::partition(split_pos1 + 1,\n+\t\t\t\t\t\t     end, pred);\n           }\n         else\n           // Only skip the pivot.\n@@ -410,7 +420,9 @@ template<typename RandomAccessIterator, typename Comparator>\n *  @param comp Comparator. */\n template<typename RandomAccessIterator, typename Comparator>\n   void\n-  parallel_partial_sort(RandomAccessIterator begin, RandomAccessIterator middle, RandomAccessIterator end, Comparator comp)\n+  parallel_partial_sort(RandomAccessIterator begin,\n+\t\t\tRandomAccessIterator middle,\n+\t\t\tRandomAccessIterator end, Comparator comp)\n   {\n     parallel_nth_element(begin, middle, end, comp);\n     std::sort(begin, middle, comp);"}, {"sha": "27a26f3ecaa5a46a42277148c8dd06e2cb04e41a", "filename": "libstdc++-v3/include/parallel/queue.h", "status": "modified", "additions": 85, "deletions": 83, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fqueue.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -55,96 +55,98 @@ namespace __gnu_parallel\n    *  Calling them would not make sense in a concurrent setting.\n    *  @param T Contained element type. */\n   template<typename T>\n-  class RestrictedBoundedConcurrentQueue\n-  {\n-  private:\n-    /** @brief Array of elements, seen as cyclic buffer. */\n-    T* base;\n-\n-    /** @brief Maximal number of elements contained at the same time. */\n-    sequence_index_t max_size;\n-\n-    /** @brief Cyclic begin and end pointers contained in one\n-\tatomically changeable value. */\n-    _GLIBCXX_VOLATILE lcas_t borders;\n-\n-  public:\n-    /** @brief Constructor. Not to be called concurrent, of course.\n-     *  @param max_size Maximal number of elements to be contained. */\n-    RestrictedBoundedConcurrentQueue(sequence_index_t max_size)\n+    class RestrictedBoundedConcurrentQueue\n     {\n-      this->max_size = max_size;\n-      base = new T[max_size];\n-      borders = encode2(0, 0);\n+    private:\n+      /** @brief Array of elements, seen as cyclic buffer. */\n+      T* base;\n+\n+      /** @brief Maximal number of elements contained at the same time. */\n+      sequence_index_t max_size;\n+\n+      /** @brief Cyclic begin and end pointers contained in one\n+\t  atomically changeable value. */\n+      _GLIBCXX_VOLATILE lcas_t borders;\n+\n+    public:\n+      /** @brief Constructor. Not to be called concurrent, of course.\n+       *  @param max_size Maximal number of elements to be contained. */\n+      RestrictedBoundedConcurrentQueue(sequence_index_t max_size)\n+      {\n+\tthis->max_size = max_size;\n+\tbase = new T[max_size];\n+\tborders = encode2(0, 0);\n #pragma omp flush\n-    }\n-\n-    /** @brief Destructor. Not to be called concurrent, of course. */\n-    ~RestrictedBoundedConcurrentQueue()\n-    {\n-      delete[] base;\n-    }\n-\n-    /** @brief Pushes one element into the queue at the front end.\n-     *  Must not be called concurrently with pop_front(). */\n-    void push_front(const T& t)\n-    {\n-      lcas_t former_borders = borders;\n-      int former_front, former_back;\n-      decode2(former_borders, former_front, former_back);\n-      *(base + former_front % max_size) = t;\n+      }\n+\n+      /** @brief Destructor. Not to be called concurrent, of course. */\n+      ~RestrictedBoundedConcurrentQueue()\n+      { delete[] base; }\n+\n+      /** @brief Pushes one element into the queue at the front end.\n+       *  Must not be called concurrently with pop_front(). */\n+      void\n+      push_front(const T& t)\n+      {\n+\tlcas_t former_borders = borders;\n+\tint former_front, former_back;\n+\tdecode2(former_borders, former_front, former_back);\n+\t*(base + former_front % max_size) = t;\n #if _GLIBCXX_ASSERTIONS\n-      // Otherwise: front - back > max_size eventually.\n-      _GLIBCXX_PARALLEL_ASSERT(((former_front + 1) - former_back) <= max_size);\n+\t// Otherwise: front - back > max_size eventually.\n+\t_GLIBCXX_PARALLEL_ASSERT(((former_front + 1) - former_back)\n+\t\t\t\t <= max_size);\n #endif\n-      fetch_and_add(&borders, encode2(1, 0));\n-    }\n-\n-    /** @brief Pops one element from the queue at the front end.\n-     *  Must not be called concurrently with pop_front(). */\n-    bool pop_front(T& t)\n-    {\n-      int former_front, former_back;\n+\tfetch_and_add(&borders, encode2(1, 0));\n+      }\n+\n+      /** @brief Pops one element from the queue at the front end.\n+       *  Must not be called concurrently with pop_front(). */\n+      bool\n+      pop_front(T& t)\n+      {\n+\tint former_front, former_back;\n #pragma omp flush\n-      decode2(borders, former_front, former_back);\n-      while (former_front > former_back)\n-\t{\n-\t  // Chance.\n-\t  lcas_t former_borders = encode2(former_front, former_back);\n-\t  lcas_t new_borders = encode2(former_front - 1, former_back);\n-\t  if (compare_and_swap(&borders, former_borders, new_borders))\n-\t    {\n-\t      t = *(base + (former_front - 1) % max_size);\n-\t      return true;\n-\t    }\n+\tdecode2(borders, former_front, former_back);\n+\twhile (former_front > former_back)\n+\t  {\n+\t    // Chance.\n+\t    lcas_t former_borders = encode2(former_front, former_back);\n+\t    lcas_t new_borders = encode2(former_front - 1, former_back);\n+\t    if (compare_and_swap(&borders, former_borders, new_borders))\n+\t      {\n+\t\tt = *(base + (former_front - 1) % max_size);\n+\t\treturn true;\n+\t      }\n #pragma omp flush\n-\t  decode2(borders, former_front, former_back);\n-\t}\n-      return false;\n-    }\n-\n-    /** @brief Pops one element from the queue at the front end.\n-     *  Must not be called concurrently with pop_front(). */\n-    bool pop_back(T& t)\t//queue behavior\n-    {\n-      int former_front, former_back;\n+\t    decode2(borders, former_front, former_back);\n+\t  }\n+\treturn false;\n+      }\n+\n+      /** @brief Pops one element from the queue at the front end.\n+       *  Must not be called concurrently with pop_front(). */\n+      bool\n+      pop_back(T& t)\t//queue behavior\n+      {\n+\tint former_front, former_back;\n #pragma omp flush\n-      decode2(borders, former_front, former_back);\n-      while (former_front > former_back)\n-\t{\n-\t  // Chance.\n-\t  lcas_t former_borders = encode2(former_front, former_back);\n-\t  lcas_t new_borders = encode2(former_front, former_back + 1);\n-\t  if (compare_and_swap(&borders, former_borders, new_borders))\n-\t    {\n-\t      t = *(base + former_back % max_size);\n-\t      return true;\n-\t    }\n+\tdecode2(borders, former_front, former_back);\n+\twhile (former_front > former_back)\n+\t  {\n+\t    // Chance.\n+\t    lcas_t former_borders = encode2(former_front, former_back);\n+\t    lcas_t new_borders = encode2(former_front, former_back + 1);\n+\t    if (compare_and_swap(&borders, former_borders, new_borders))\n+\t      {\n+\t\tt = *(base + former_back % max_size);\n+\t\treturn true;\n+\t      }\n #pragma omp flush\n-\t  decode2(borders, former_front, former_back);\n-\t}\n-      return false;\n-    }\n+\t    decode2(borders, former_front, former_back);\n+\t  }\n+\treturn false;\n+      }\n   };\n }\t//namespace __gnu_parallel\n "}, {"sha": "5b5a62f30c5c196638dfdb4f2bf5e1baf830adf8", "filename": "libstdc++-v3/include/parallel/quicksort.h", "status": "modified", "additions": 95, "deletions": 97, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -53,48 +53,46 @@ namespace __gnu_parallel\n    *  this part.\n    */\n   template<typename RandomAccessIterator, typename Comparator>\n-  inline\n-  typename std::iterator_traits<RandomAccessIterator>::difference_type\n-  parallel_sort_qs_divide(\n-      RandomAccessIterator begin,\n-      RandomAccessIterator end,\n-      Comparator comp,\n-      typename std::iterator_traits<RandomAccessIterator>::difference_type\n-          pivot_rank,\n-      typename std::iterator_traits<RandomAccessIterator>::difference_type\n-          num_samples,\n-      thread_index_t num_threads)\n-  {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n-\n-    difference_type n = end - begin;\n-    num_samples = std::min(num_samples, n);\n-\n-    // Allocate uninitialized, to avoid default constructor.\n-    value_type* samples = static_cast<value_type*>(\n-      ::operator new(num_samples * sizeof(value_type)));\n-\n-    for (difference_type s = 0; s < num_samples; ++s)\n-      {\n-        const unsigned long long index = static_cast<unsigned long long>(s)\n-                        * n / num_samples;\n-        ::new(&(samples[s])) value_type(begin[index]);\n-      }\n+    typename std::iterator_traits<RandomAccessIterator>::difference_type\n+    parallel_sort_qs_divide(RandomAccessIterator begin,\n+\t\t\t    RandomAccessIterator end,\n+\t\t\t    Comparator comp, typename std::iterator_traits\n+\t\t\t    <RandomAccessIterator>::difference_type pivot_rank,\n+\t\t\t    typename std::iterator_traits\n+\t\t\t    <RandomAccessIterator>::difference_type\n+\t\t\t    num_samples, thread_index_t num_threads)\n+    {\n+      typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+      typedef typename traits_type::value_type value_type;\n+      typedef typename traits_type::difference_type difference_type;\n+\n+      difference_type n = end - begin;\n+      num_samples = std::min(num_samples, n);\n+\n+      // Allocate uninitialized, to avoid default constructor.\n+      value_type* samples =\n+\tstatic_cast<value_type*>(::operator new(num_samples\n+\t\t\t\t\t\t* sizeof(value_type)));\n+\n+      for (difference_type s = 0; s < num_samples; ++s)\n+\t{\n+\t  const unsigned long long index = static_cast<unsigned long long>(s)\n+\t    * n / num_samples;\n+\t  ::new(&(samples[s])) value_type(begin[index]);\n+\t}\n \n-    __gnu_sequential::sort(samples, samples + num_samples, comp);\n+      __gnu_sequential::sort(samples, samples + num_samples, comp);\n \n-    value_type& pivot = samples[pivot_rank * num_samples / n];\n+      value_type& pivot = samples[pivot_rank * num_samples / n];\n \n-    __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool>\n+      __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool>\n         pred(comp, pivot);\n-    difference_type split = parallel_partition(begin, end, pred, num_threads);\n+      difference_type split = parallel_partition(begin, end, pred, num_threads);\n \n-    ::operator delete(samples);\n+      ::operator delete(samples);\n \n-    return split;\n-  }\n+      return split;\n+    }\n \n   /** @brief Unbalanced quicksort conquer step.\n    *  @param begin Begin iterator of subsequence.\n@@ -104,50 +102,51 @@ namespace __gnu_parallel\n    *  this part.\n    */\n   template<typename RandomAccessIterator, typename Comparator>\n-  inline void\n-  parallel_sort_qs_conquer(RandomAccessIterator begin,\n-                           RandomAccessIterator end,\n-                           Comparator comp,\n-                           thread_index_t num_threads)\n-  {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n-\n-    if (num_threads <= 1)\n-      {\n-        __gnu_sequential::sort(begin, end, comp);\n-        return;\n-      }\n+    void\n+    parallel_sort_qs_conquer(RandomAccessIterator begin,\n+\t\t\t     RandomAccessIterator end,\n+\t\t\t     Comparator comp,\n+\t\t\t     thread_index_t num_threads)\n+    {\n+      typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+      typedef typename traits_type::value_type value_type;\n+      typedef typename traits_type::difference_type difference_type;\n+\n+      if (num_threads <= 1)\n+\t{\n+\t  __gnu_sequential::sort(begin, end, comp);\n+\t  return;\n+\t}\n \n-    difference_type n = end - begin, pivot_rank;\n+      difference_type n = end - begin, pivot_rank;\n \n-    if (n <= 1)\n-      return;\n+      if (n <= 1)\n+\treturn;\n \n-    thread_index_t num_threads_left;\n+      thread_index_t num_threads_left;\n \n-    if ((num_threads % 2) == 1)\n-      num_threads_left = num_threads / 2 + 1;\n-    else\n-      num_threads_left = num_threads / 2;\n+      if ((num_threads % 2) == 1)\n+\tnum_threads_left = num_threads / 2 + 1;\n+      else\n+\tnum_threads_left = num_threads / 2;\n \n-    pivot_rank = n * num_threads_left / num_threads;\n+      pivot_rank = n * num_threads_left / num_threads;\n \n-    difference_type split = parallel_sort_qs_divide(\n-        begin, end, comp, pivot_rank,\n-        Settings::sort_qs_num_samples_preset, num_threads);\n+      difference_type split =\n+\tparallel_sort_qs_divide(begin, end, comp, pivot_rank,\n+\t\t\t\tSettings::sort_qs_num_samples_preset,\n+\t\t\t\tnum_threads);\n \n #pragma omp parallel sections\n-    {\n+      {\n #pragma omp section\n-      parallel_sort_qs_conquer(begin, begin + split,\n-                               comp, num_threads_left);\n+\tparallel_sort_qs_conquer(begin, begin + split,\n+\t\t\t\t comp, num_threads_left);\n #pragma omp section\n-      parallel_sort_qs_conquer(begin + split, end,\n-                               comp, num_threads - num_threads_left);\n+\tparallel_sort_qs_conquer(begin + split, end,\n+\t\t\t\t comp, num_threads - num_threads_left);\n+      }\n     }\n-  }\n \n \n \n@@ -160,34 +159,33 @@ namespace __gnu_parallel\n    *  this part.\n    */\n   template<typename RandomAccessIterator, typename Comparator>\n-  inline void\n-  parallel_sort_qs(\n-      RandomAccessIterator begin,\n-      RandomAccessIterator end,\n-      Comparator comp,\n-      typename std::iterator_traits<RandomAccessIterator>::difference_type n,\n-      int num_threads)\n-  {\n-    _GLIBCXX_CALL(n)\n-\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n-\n-    if (n == 0)\n-      return;\n-\n-    // At least one element per processor.\n-    if (num_threads > n)\n-      num_threads = static_cast<thread_index_t>(n);\n-\n-    Settings::sort_qs_num_samples_preset = 100;\n-\n-    // Hard to avoid.\n-    omp_set_num_threads(num_threads);\n-\n-    parallel_sort_qs_conquer(begin, begin + n, comp, num_threads);\n-  }\n+    void\n+    parallel_sort_qs(RandomAccessIterator begin,\n+\t\t     RandomAccessIterator end,\n+\t\t     Comparator comp, typename std::iterator_traits\n+\t\t     <RandomAccessIterator>::difference_type n,\n+\t\t     int num_threads)\n+    {\n+      _GLIBCXX_CALL(n)\n+\n+      typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+      typedef typename traits_type::value_type value_type;\n+      typedef typename traits_type::difference_type difference_type;\n+\n+      if (n == 0)\n+\treturn;\n+\n+      // At least one element per processor.\n+      if (num_threads > n)\n+\tnum_threads = static_cast<thread_index_t>(n);\n+\n+      Settings::sort_qs_num_samples_preset = 100;\n+\n+      // Hard to avoid.\n+      omp_set_num_threads(num_threads);\n+\n+      parallel_sort_qs_conquer(begin, begin + n, comp, num_threads);\n+    }\n \n } //namespace __gnu_parallel\n "}, {"sha": "ae523723ecb4f9e44eeda42c34e62c3c67c41f3c", "filename": "libstdc++-v3/include/parallel/random_number.h", "status": "modified", "additions": 291, "deletions": 232, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_number.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -46,229 +46,288 @@ namespace __gnu_parallel\n   // http://www.math.keio.ac.jp/matumoto/emt.html\n   template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n \t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n-  class mersenne_twister\n-  {\n-  public:\n-    typedef UIntType result_type;\n-    static const int word_size = w;\n-    static const int state_size = n;\n-    static const int shift_size = m;\n-    static const int mask_bits = r;\n-    static const UIntType parameter_a = a;\n-    static const int output_u = u;\n-    static const int output_s = s;\n-    static const UIntType output_b = b;\n-    static const int output_t = t;\n-    static const UIntType output_c = c;\n-    static const int output_l = l;\n-\n-    static const bool has_fixed_range = false;\n-\n-    mersenne_twister() { seed(); }\n+    class mersenne_twister\n+    {\n+    public:\n+      typedef UIntType result_type;\n+      static const int word_size = w;\n+      static const int state_size = n;\n+      static const int shift_size = m;\n+      static const int mask_bits = r;\n+      static const UIntType parameter_a = a;\n+      static const int output_u = u;\n+      static const int output_s = s;\n+      static const UIntType output_b = b;\n+      static const int output_t = t;\n+      static const UIntType output_c = c;\n+      static const int output_l = l;\n+\n+      static const bool has_fixed_range = false;\n+\n+      mersenne_twister() { seed(); }\n \n #if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x520)\n-    // Work around overload resolution problem (Gennadiy E. Rozental)\n-    explicit mersenne_twister(const UIntType& value)\n+      // Work around overload resolution problem (Gennadiy E. Rozental)\n+      explicit\n+      mersenne_twister(const UIntType& value)\n #else\n-      explicit mersenne_twister(UIntType value)\n+      explicit\n+      mersenne_twister(UIntType value)\n #endif\n-    { seed(value); }\n-    template<typename It> mersenne_twister(It& first, It last) { seed(first,last); }\n+      { seed(value); }\n \n-    template<typename Generator>\n-    explicit mersenne_twister(Generator & gen) { seed(gen); }\n+      template<typename It>\n+        mersenne_twister(It& first, It last)\n+\t{ seed(first,last); }\n \n-    // compiler-generated copy ctor and assignment operator are fine\n+      template<typename Generator>\n+        explicit\n+        mersenne_twister(Generator & gen)\n+\t{ seed(gen); }\n \n-    void seed() { seed(UIntType(5489)); }\n+      // compiler-generated copy ctor and assignment operator are fine\n+\n+      void\n+      seed()\n+      { seed(UIntType(5489)); }\n \n #if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x520)\n-    // Work around overload resolution problem (Gennadiy E. Rozental)\n-    void seed(const UIntType& value)\n+      // Work around overload resolution problem (Gennadiy E. Rozental)\n+      void\n+      seed(const UIntType& value)\n #else\n-      void seed(UIntType value)\n+      void\n+      seed(UIntType value)\n #endif\n-    {\n-      // New seeding algorithm from\n+      {\n+\t// New seeding algorithm from\n       // http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html\n-      // In the previous versions, MSBs of the seed affected only MSBs of the\n-      // state x[].\n-      const UIntType mask = ~0u;\n-      x[0] = value & mask;\n-      for (i = 1; i < n; i++) {\n-\t// See Knuth \"The Art of Computer Programming\" Vol. 2, 3rd ed., page 106\n-\tx[i] = (1812433253UL * (x[i-1] ^ (x[i-1] >> (w-2))) + i) & mask;\n+\t// In the previous versions, MSBs of the seed affected only MSBs of the\n+\t// state x[].\n+\tconst UIntType mask = ~0u;\n+\tx[0] = value & mask;\n+\tfor (i = 1; i < n; ++i)\n+\t  {\n+\t    // See Knuth \"The Art of Computer Programming\" Vol. 2,\n+\t    // 3rd ed., page 106\n+\t    x[i] = (1812433253UL * (x[i-1] ^ (x[i-1] >> (w-2))) + i) & mask;\n+\t  }\n       }\n-    }\n \n-    // For GCC, moving this function out-of-line prevents inlining, which may\n-    // reduce overall object code size.  However, MSVC does not grok\n-    // out-of-line definitions of member function templates.\n-    template<typename Generator>\n-    void seed(Generator & gen)\n-    {\n-      // I could have used std::generate_n, but it takes \"gen\" by value\n-      for (int j = 0; j < n; j++)\n-\tx[j] = gen();\n-      i = n;\n-    }\n+      // For GCC, moving this function out-of-line prevents inlining, which may\n+      // reduce overall object code size.  However, MSVC does not grok\n+      // out-of-line definitions of member function templates.\n+      template<typename Generator>\n+        void\n+        seed(Generator & gen)\n+\t{\n+\t  // I could have used std::generate_n, but it takes \"gen\" by value\n+\t  for (int j = 0; j < n; ++j)\n+\t    x[j] = gen();\n+\t  i = n;\n+\t}\n \n-    template<typename It>\n-    void seed(It& first, It last)\n-    {\n-      int j;\n-      for (j = 0; j < n && first != last; ++j, ++first)\n-\tx[j] = *first;\n-      i = n;\n-      /*    if (first == last && j < n)\n-\t    throw std::invalid_argument(\"mersenne_twister::seed\");*/\n-    }\n+      template<typename It>\n+        void\n+        seed(It& first, It last)\n+\t{\n+\t  int j;\n+\t  for (j = 0; j < n && first != last; ++j, ++first)\n+\t    x[j] = *first;\n+\t  i = n;\n+\t  /*    if (first == last && j < n)\n+\t\tthrow std::invalid_argument(\"mersenne_twister::seed\");*/\n+\t}\n \n-    result_type min() const { return 0; }\n-    result_type max() const\n-    {\n-      // avoid \"left shift count >= with of type\" warning\n-      result_type res = 0;\n-      for (int i = 0; i < w; ++i)\n-\tres |= (1u << i);\n-      return res;\n-    }\n+      result_type\n+      min() const\n+      { return 0; }\n+      \n+      result_type\n+      max() const\n+      {\n+\t// avoid \"left shift count >= with of type\" warning\n+\tresult_type res = 0;\n+\tfor (int i = 0; i < w; ++i)\n+\t  res |= (1u << i);\n+\treturn res;\n+      }\n \n-    result_type operator()();\n-    static bool validation(result_type v) { return val == v; }\n+      result_type\n+      operator()();\n+      \n+      static bool\n+      validation(result_type v)\n+      { return val == v; }\n \n #ifndef BOOST_NO_OPERATORS_IN_NAMESPACE\n \n-    friend bool operator==(const mersenne_twister& x, const mersenne_twister& y)\n-    {\n-      for (int j = 0; j < state_size; ++j)\n-\tif (x.compute(j) != y.compute(j))\n-\t  return false;\n-      return true;\n-    }\n+      friend bool\n+      operator==(const mersenne_twister& x, const mersenne_twister& y)\n+      {\n+\tfor (int j = 0; j < state_size; ++j)\n+\t  if (x.compute(j) != y.compute(j))\n+\t    return false;\n+\treturn true;\n+      }\n \n-    friend bool operator!=(const mersenne_twister& x, const mersenne_twister& y)\n-    { return !(x == y); }\n+      friend bool\n+      operator!=(const mersenne_twister& x, const mersenne_twister& y)\n+      { return !(x == y); }\n #else\n-    // Use a member function; Streamable concept not supported.\n-    bool operator==(const mersenne_twister& rhs) const\n-    {\n-      for (int j = 0; j < state_size; ++j)\n-\tif (compute(j) != rhs.compute(j))\n-\t  return false;\n-      return true;\n-    }\n+      // Use a member function; Streamable concept not supported.\n+      bool\n+      operator==(const mersenne_twister& rhs) const\n+      {\n+\tfor (int j = 0; j < state_size; ++j)\n+\t  if (compute(j) != rhs.compute(j))\n+\t    return false;\n+\treturn true;\n+      }\n \n-    bool operator!=(const mersenne_twister& rhs) const\n-    { return !(*this == rhs); }\n+      bool\n+      operator!=(const mersenne_twister& rhs) const\n+      { return !(*this == rhs); }\n #endif\n \n-  private:\n-    // returns x(i-n+index), where index is in 0..n-1\n-    UIntType compute(unsigned int index) const\n-    {\n-      // equivalent to (i-n+index) % 2n, but doesn't produce negative numbers\n-      return x[ (i + n + index) % (2*n) ];\n-    }\n-    void twist(int block);\n+    private:\n+      // returns x(i-n+index), where index is in 0..n-1\n+      UIntType\n+      compute(unsigned int index) const\n+      {\n+\t// equivalent to (i-n+index) % 2n, but doesn't produce negative numbers\n+\treturn x[ (i + n + index) % (2*n) ];\n+      }\n+\n+      void\n+      twist(int block);\n \n-    // state representation: next output is o(x(i))\n-    //   x[0]  ... x[k] x[k+1] ... x[n-1]     x[n]     ... x[2*n-1]   represents\n-    //  x(i-k) ... x(i) x(i+1) ... x(i-k+n-1) x(i-k-n) ... x[i(i-k-1)]\n-    // The goal is to always have x(i-n) ... x(i-1) available for\n-    // operator== and save/restore.\n+      // state representation: next output is o(x(i))\n+      //  x[0]  ... x[k] x[k+1] ... x[n-1]     x[n]     ... x[2*n-1] represents\n+      //  x(i-k) ... x(i) x(i+1) ... x(i-k+n-1) x(i-k-n) ... x[i(i-k-1)]\n+      // The goal is to always have x(i-n) ... x(i-1) available for\n+      // operator== and save/restore.\n \n-    UIntType x[2*n];\n-    int i;\n+      UIntType x[2*n];\n+      int i;\n   };\n \n #ifndef BOOST_NO_INCLASS_MEMBER_INITIALIZATION\n   //  A definition is required even for integral static constants\n   template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n \t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n-  const bool mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::has_fixed_range;\n+    const bool\n+    mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::has_fixed_range;\n+\n   template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n \t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n-  const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::state_size;\n+    const int\n+    mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::state_size;\n+\n   template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n \t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n-  const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::shift_size;\n+    const int\n+    mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::shift_size;\n+  \n   template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n \t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n-  const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::mask_bits;\n+    const int\n+    mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::mask_bits;\n+  \n   template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n \t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n-  const UIntType mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::parameter_a;\n+    const UIntType\n+    mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::parameter_a;\n+  \n   template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n \t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n-  const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_u;\n+    const int\n+    mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_u;\n+  \n   template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n \t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n-  const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_s;\n+    const int\n+    mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_s;\n+  \n   template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n \t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n-  const UIntType mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_b;\n+    const UIntType\n+    mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_b;\n+  \n   template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n \t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n-  const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_t;\n+    const int\n+    mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_t;\n+  \n   template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n \t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n-  const UIntType mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_c;\n+    const UIntType\n+    mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_c;\n+  \n   template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n \t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n-  const int mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_l;\n+    const int\n+    mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::output_l;\n #endif\n \n   template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n \t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n-  void mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::twist(int block)\n+  void\n+  mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::twist(int block)\n   {\n     const UIntType upper_mask = (~0u) << r;\n     const UIntType lower_mask = ~upper_mask;\n \n-    if (block == 0) {\n-      for (int j = n; j < 2*n; j++) {\n-\tUIntType y = (x[j-n] & upper_mask) | (x[j-(n-1)] & lower_mask);\n-\tx[j] = x[j-(n-m)] ^ (y >> 1) ^ (y&1 ? a : 0);\n+    if (block == 0)\n+      {\n+\tfor (int j = n; j < 2*n; ++j)\n+\t  {\n+\t    UIntType y = (x[j-n] & upper_mask) | (x[j-(n-1)] & lower_mask);\n+\t    x[j] = x[j-(n-m)] ^ (y >> 1) ^ (y&1 ? a : 0);\n+\t  }\n       }\n-    } else if (block == 1) {\n-      // split loop to avoid costly modulo operations\n-      {  // extra scope for MSVC brokenness w.r.t. for scope\n-\tfor (int j = 0; j < n-m; j++) {\n-\t  UIntType y = (x[j+n] & upper_mask) | (x[j+n+1] & lower_mask);\n-\t  x[j] = x[j+n+m] ^ (y >> 1) ^ (y&1 ? a : 0);\n+    else if (block == 1)\n+      {\n+\t// split loop to avoid costly modulo operations\n+\t{  // extra scope for MSVC brokenness w.r.t. for scope\n+\t  for (int j = 0; j < n-m; ++j)\n+\t    {\n+\t      UIntType y = (x[j+n] & upper_mask) | (x[j+n+1] & lower_mask);\n+\t      x[j] = x[j+n+m] ^ (y >> 1) ^ (y&1 ? a : 0);\n+\t    }\n \t}\n+\t\n+\tfor (int j = n-m; j < n-1; ++j)\n+\t  {\n+\t    UIntType y = (x[j+n] & upper_mask) | (x[j+n+1] & lower_mask);\n+\t    x[j] = x[j-(n-m)] ^ (y >> 1) ^ (y&1 ? a : 0);\n+\t  }\n+\t// last iteration\n+\tUIntType y = (x[2*n-1] & upper_mask) | (x[0] & lower_mask);\n+\tx[n-1] = x[m-1] ^ (y >> 1) ^ (y&1 ? a : 0);\n+\ti = 0;\n       }\n-\n-      for (int j = n-m; j < n-1; j++) {\n-\tUIntType y = (x[j+n] & upper_mask) | (x[j+n+1] & lower_mask);\n-\tx[j] = x[j-(n-m)] ^ (y >> 1) ^ (y&1 ? a : 0);\n-      }\n-      // last iteration\n-      UIntType y = (x[2*n-1] & upper_mask) | (x[0] & lower_mask);\n-      x[n-1] = x[m-1] ^ (y >> 1) ^ (y&1 ? a : 0);\n-      i = 0;\n-    }\n   }\n \n   template<typename UIntType, int w, int n, int m, int r, UIntType a, int u,\n \t   int s, UIntType b, int t, UIntType c, int l, UIntType val>\n-  inline typename mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::result_type\n-  mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::operator()()\n-  {\n-    if (i == n)\n-      twist(0);\n-    else if (i >= 2*n)\n-      twist(1);\n-    // Step 4\n-    UIntType z = x[i];\n-    ++i;\n-    z ^= (z >> u);\n-    z ^= ((z << s) & b);\n-    z ^= ((z << t) & c);\n-    z ^= (z >> l);\n-    return z;\n-  }\n+    inline\n+    typename mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::result_type\n+    mersenne_twister<UIntType,w,n,m,r,a,u,s,b,t,c,l,val>::operator()()\n+    {\n+      if (i == n)\n+\ttwist(0);\n+      else if (i >= 2*n)\n+\ttwist(1);\n+      // Step 4\n+      UIntType z = x[i];\n+      ++i;\n+      z ^= (z >> u);\n+      z ^= ((z << s) & b);\n+      z ^= ((z << t) & c);\n+      z ^= (z >> l);\n+      return z;\n+    }\n \n \n   typedef mersenne_twister<uint32,32,351,175,19,0xccab8ee7,11,\n@@ -286,14 +345,15 @@ namespace __gnu_parallel\n     uint64 supremum, RAND_SUP;\n     double supremum_reciprocal, RAND_SUP_REC;\n \n-    uint64 cache;\t/* assumed to be twice as long as the usual random number */\n-    int bits_left;\t/* bit results */\n+    uint64 cache;  /* assumed to be twice as long as the usual random number */\n+    int bits_left; /* bit results */\n \n-    static inline uint32 scale_down(uint64 x,\n+    static uint32\n+    scale_down(uint64 x,\n #if _GLIBCXX_SCALE_DOWN_FPU\n-\t\t\t\t    uint64 /*supremum*/, double supremum_reciprocal)\n+\t       uint64 /*supremum*/, double supremum_reciprocal)\n #else\n-      uint64 supremum, double /*supremum_reciprocal*/)\n+               uint64 supremum, double /*supremum_reciprocal*/)\n #endif\n \t{\n #if _GLIBCXX_SCALE_DOWN_FPU\n@@ -303,82 +363,81 @@ namespace __gnu_parallel\n #endif\n \t}\n \n-public:\n-  /** @brief Default constructor. Seed with 0. */\n-  random_number() :\n-    mt(0),\n-    supremum(0x100000000ULL),\n-    RAND_SUP(1ULL << (sizeof(uint32) * 8)),\n-    supremum_reciprocal((double)supremum / (double)RAND_SUP),\n-    RAND_SUP_REC(1.0 / (double)RAND_SUP),\n-    cache(0), bits_left(0)\n-  {\n-  }\n-\n-  /** @brief Constructor.\n-   *  @param seed Random seed.\n-   *  @param supremum Generate integer random numbers in the interval @c [0,supremum). */\n-  random_number(uint32 seed, uint64 supremum = 0x100000000ULL) :\n-    mt(seed),\n-    supremum(supremum),\n-    RAND_SUP(1ULL << (sizeof(uint32) * 8)),\n-    supremum_reciprocal((double)supremum / (double)RAND_SUP),\n-    RAND_SUP_REC(1.0 / (double)RAND_SUP),\n-    cache(0), bits_left(0)\n-  {\n-  }\n-\n-  /** @brief Generate unsigned random 32-bit integer. */\n-  inline uint32 operator()()\n-  {\n-    return scale_down(mt(), supremum, supremum_reciprocal);\n-  }\n-\n-  /** @brief Generate unsigned random 32-bit integer in the interval @c [0,local_supremum). */\n-  inline uint32 operator()(uint64 local_supremum)\n-  {\n-    return scale_down(mt(), local_supremum, (double)local_supremum * RAND_SUP_REC);\n-  }\n-\n-  /** @brief Set the random seed.\n-   *  @param seed to set. */\n-  inline void set_seed(uint32 seed)\n-  {\n-    mt.seed(seed);\n-    cache = mt();\n-    bits_left = 32;\n-  }\n+  public:\n+    /** @brief Default constructor. Seed with 0. */\n+    random_number()\n+    : mt(0), supremum(0x100000000ULL),\n+      RAND_SUP(1ULL << (sizeof(uint32) * 8)),\n+      supremum_reciprocal((double)supremum / (double)RAND_SUP),\n+      RAND_SUP_REC(1.0 / (double)RAND_SUP),\n+      cache(0), bits_left(0) { }\n+\n+    /** @brief Constructor.\n+     *  @param seed Random seed.\n+     *  @param supremum Generate integer random numbers in the\n+     *                  interval @c [0,supremum). */\n+    random_number(uint32 seed, uint64 supremum = 0x100000000ULL)\n+    : mt(seed), supremum(supremum),\n+      RAND_SUP(1ULL << (sizeof(uint32) * 8)),\n+      supremum_reciprocal((double)supremum / (double)RAND_SUP),\n+      RAND_SUP_REC(1.0 / (double)RAND_SUP),\n+      cache(0), bits_left(0) { }\n+\n+    /** @brief Generate unsigned random 32-bit integer. */\n+    uint32\n+    operator()()\n+    { return scale_down(mt(), supremum, supremum_reciprocal); }\n+\n+    /** @brief Generate unsigned random 32-bit integer in the\n+\tinterval @c [0,local_supremum). */\n+    uint32\n+    operator()(uint64 local_supremum)\n+    {\n+      return scale_down(mt(), local_supremum,\n+\t\t\t(double)local_supremum * RAND_SUP_REC);\n+    }\n \n-  /** @brief Generate a number of random bits, compile-time parameter. */\n-  template<int bits>\n-  inline unsigned long genrand_bits()\n-  {\n-    unsigned long res = cache & ((1 << bits) - 1);\n-    cache = cache >> bits;\n-    bits_left -= bits;\n-    if (bits_left < 32)\n-      {\n-\tcache |= (((uint64)mt()) << bits_left);\n-\tbits_left += 32;\n-      }\n-    return res;\n-  }\n+    /** @brief Set the random seed.\n+     *  @param seed to set. */\n+    void\n+    set_seed(uint32 seed)\n+    {\n+      mt.seed(seed);\n+      cache = mt();\n+      bits_left = 32;\n+    }\n \n-  /** @brief Generate a number of random bits, run-time parameter.\n-   *  @param bits Number of bits to generate. */\n-  inline unsigned long genrand_bits(int bits)\n-  {\n-    unsigned long res = cache & ((1 << bits) - 1);\n-    cache = cache >> bits;\n-    bits_left -= bits;\n-    if (bits_left < 32)\n+    /** @brief Generate a number of random bits, compile-time parameter. */\n+    template<int bits>\n+      unsigned long\n+      genrand_bits()\n       {\n-\tcache |= (((uint64)mt()) << bits_left);\n-\tbits_left += 32;\n+\tunsigned long res = cache & ((1 << bits) - 1);\n+\tcache = cache >> bits;\n+\tbits_left -= bits;\n+\tif (bits_left < 32)\n+\t  {\n+\t    cache |= (((uint64)mt()) << bits_left);\n+\t    bits_left += 32;\n+\t  }\n+\treturn res;\n       }\n-    return res;\n-  }\n \n+    /** @brief Generate a number of random bits, run-time parameter.\n+     *  @param bits Number of bits to generate. */\n+    unsigned long\n+    genrand_bits(int bits)\n+    {\n+      unsigned long res = cache & ((1 << bits) - 1);\n+      cache = cache >> bits;\n+      bits_left -= bits;\n+      if (bits_left < 32)\n+\t{\n+\t  cache |= (((uint64)mt()) << bits_left);\n+\t  bits_left += 32;\n+\t}\n+      return res;\n+    }\n };\n \n } // namespace __gnu_parallel"}, {"sha": "348a3a34b378d9ef2a4c28143b6ea298468d9fc0", "filename": "libstdc++-v3/include/parallel/random_shuffle.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -124,7 +124,7 @@ template<typename RandomNumberGenerator>\n /** @brief Random shuffle code executed by each thread.\n   *  @param pus Array of thread-local data records. */\n template<typename RandomAccessIterator, typename RandomNumberGenerator>\n-  inline void \n+  void \n   parallel_random_shuffle_drs_pu(DRSSorterPU<RandomAccessIterator,\n                                  RandomNumberGenerator>* pus)\n   {\n@@ -213,8 +213,8 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n         thread_index_t target_p = bin_proc[target_bin];\n \n         // Last column [d->num_threads] stays unchanged.\n-        ::new(&(temporaries[target_p][dist[target_bin + 1]++])) value_type(\n-              *(source + i + start));\n+        ::new(&(temporaries[target_p][dist[target_bin + 1]++]))\n+\t    value_type(*(source + i + start));\n       }\n \n     delete[] oracles;\n@@ -260,13 +260,13 @@ template<typename T>\n   *  @param rng Random number generator to use.\n   */\n template<typename RandomAccessIterator, typename RandomNumberGenerator>\n-  inline void\n-  parallel_random_shuffle_drs(\n-      RandomAccessIterator begin,\n-      RandomAccessIterator end,\n-      typename std::iterator_traits<RandomAccessIterator>::difference_type n,\n-      thread_index_t num_threads,\n-      RandomNumberGenerator& rng)\n+  void\n+  parallel_random_shuffle_drs(RandomAccessIterator begin,\n+\t\t\t      RandomAccessIterator end,\n+\t\t\t      typename std::iterator_traits\n+\t\t\t      <RandomAccessIterator>::difference_type n,\n+\t\t\t      thread_index_t num_threads,\n+\t\t\t      RandomNumberGenerator& rng)\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n@@ -393,7 +393,7 @@ template<typename RandomAccessIterator, typename RandomNumberGenerator>\n  *  @param rng Random number generator to use.\n  */\n template<typename RandomAccessIterator, typename RandomNumberGenerator>\n-  inline void\n+  void\n   sequential_random_shuffle(RandomAccessIterator begin, \n                             RandomAccessIterator end,\n                             RandomNumberGenerator& rng)"}, {"sha": "86bd2b827b9bfcceadbaf6471b17dd446312a91b", "filename": "libstdc++-v3/include/parallel/search.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -81,10 +81,9 @@ template<typename RandomAccessIterator, typename _DifferenceTp>\n    *  @param end2 End iterator of second sequence.\n    *  @param pred Find predicate.\n    *  @return Place of finding in first sequences. */\n-template<\n-    typename _RandomAccessIterator1,\n-    typename _RandomAccessIterator2,\n-    typename Pred>\n+template<typename _RandomAccessIterator1,\n+\t typename _RandomAccessIterator2,\n+\t typename Pred>\n   _RandomAccessIterator1\n   search_template(_RandomAccessIterator1 begin1, _RandomAccessIterator1 end1,\n                   _RandomAccessIterator2 begin2, _RandomAccessIterator2 end2,"}, {"sha": "50c28d48d66cadb08bafea6965af513114a84d3f", "filename": "libstdc++-v3/include/parallel/set_operations.h", "status": "modified", "additions": 54, "deletions": 62, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -48,7 +48,7 @@\n namespace __gnu_parallel\n {\n template<typename InputIterator, typename OutputIterator>\n-  inline OutputIterator\n+  OutputIterator\n   copy_tail(std::pair<InputIterator, InputIterator> b,\n             std::pair<InputIterator, InputIterator> e, OutputIterator r)\n   {\n@@ -68,10 +68,9 @@ template<typename InputIterator, typename OutputIterator>\n     return r;\n   }\n \n-template<\n-    typename InputIterator,\n-    typename OutputIterator,\n-    typename Comparator>\n+template<typename InputIterator,\n+\t typename OutputIterator,\n+\t typename Comparator>\n   struct symmetric_difference_func\n   {\n     typedef std::iterator_traits<InputIterator> traits_type;\n@@ -82,9 +81,10 @@ template<\n \n     Comparator comp;\n \n-    inline OutputIterator invoke(InputIterator a, InputIterator b,\n-                                  InputIterator c, InputIterator d,\n-                                  OutputIterator r) const\n+    OutputIterator\n+    invoke(InputIterator a, InputIterator b,\n+\t   InputIterator c, InputIterator d,\n+\t   OutputIterator r) const\n     {\n       while (a != b && c != d)\n         {\n@@ -109,9 +109,9 @@ template<\n       return std::copy(c, d, std::copy(a, b, r));\n     }\n \n-    inline difference_type\n-    count(InputIterator a, InputIterator b, InputIterator c, InputIterator d)\n-        const\n+    difference_type\n+    count(InputIterator a, InputIterator b,\n+\t  InputIterator c, InputIterator d) const\n     {\n       difference_type counter = 0;\n \n@@ -137,21 +137,19 @@ template<\n       return counter + (b - a) + (d - c);\n     }\n \n-    inline OutputIterator\n+    OutputIterator\n     first_empty(InputIterator c, InputIterator d, OutputIterator out) const\n     { return std::copy(c, d, out); }\n \n-    inline OutputIterator\n+    OutputIterator\n     second_empty(InputIterator a, InputIterator b, OutputIterator out) const\n     { return std::copy(a, b, out); }\n-\n   };\n \n \n-template<\n-    typename InputIterator,\n-    typename OutputIterator,\n-    typename Comparator>\n+template<typename InputIterator,\n+\t typename OutputIterator,\n+\t typename Comparator>\n   struct difference_func\n   {\n     typedef std::iterator_traits<InputIterator> traits_type;\n@@ -162,7 +160,7 @@ template<\n \n     Comparator comp;\n \n-    inline OutputIterator\n+    OutputIterator\n     invoke(InputIterator a, InputIterator b, InputIterator c, InputIterator d,\n           OutputIterator r) const\n     {\n@@ -185,9 +183,9 @@ template<\n       return std::copy(a, b, r);\n     }\n \n-    inline difference_type\n-    count(InputIterator a, InputIterator b, InputIterator c, InputIterator d)\n-        const\n+    difference_type\n+    count(InputIterator a, InputIterator b,\n+\t  InputIterator c, InputIterator d) const\n     {\n       difference_type counter = 0;\n \n@@ -217,10 +215,9 @@ template<\n   };\n \n \n-template<\n-    typename InputIterator,\n-    typename OutputIterator,\n-    typename Comparator>\n+template<typename InputIterator,\n+\t typename OutputIterator,\n+\t typename Comparator>\n   struct intersection_func\n   {\n     typedef std::iterator_traits<InputIterator> traits_type;\n@@ -231,7 +228,7 @@ template<\n \n     Comparator comp;\n \n-    inline OutputIterator\n+    OutputIterator\n     invoke(InputIterator a, InputIterator b, InputIterator c, InputIterator d,\n           OutputIterator r) const\n     {\n@@ -253,9 +250,9 @@ template<\n       return r;\n     }\n \n-    inline difference_type\n-    count(InputIterator a, InputIterator b, InputIterator c, InputIterator d)\n-        const\n+    difference_type\n+    count(InputIterator a, InputIterator b,\n+\t  InputIterator c, InputIterator d) const\n     {\n       difference_type counter = 0;\n \n@@ -289,13 +286,13 @@ template<class InputIterator, class OutputIterator, class Comparator>\n   struct union_func\n   {\n     typedef typename std::iterator_traits<InputIterator>::difference_type\n-        difference_type;\n+    difference_type;\n \n     union_func(Comparator c) : comp(c) {}\n \n     Comparator comp;\n \n-    inline OutputIterator\n+    OutputIterator\n     invoke(InputIterator a, const InputIterator b, InputIterator c,\n           const InputIterator d, OutputIterator r) const\n     {\n@@ -322,9 +319,9 @@ template<class InputIterator, class OutputIterator, class Comparator>\n       return std::copy(c, d, std::copy(a, b, r));\n     }\n \n-    inline difference_type\n-    count(InputIterator a, InputIterator b, InputIterator c, InputIterator d)\n-        const\n+    difference_type\n+    count(InputIterator a, InputIterator b,\n+\t  InputIterator c, InputIterator d) const\n     {\n       difference_type counter = 0;\n \n@@ -356,10 +353,9 @@ template<class InputIterator, class OutputIterator, class Comparator>\n     { return std::copy(a, b, out); }\n   };\n \n-template<\n-    typename InputIterator,\n-    typename OutputIterator,\n-    typename Operation>\n+template<typename InputIterator,\n+\t typename OutputIterator,\n+\t typename Operation>\n   OutputIterator\n   parallel_set_operation(InputIterator begin1, InputIterator end1,\n                          InputIterator begin2, InputIterator end2,\n@@ -480,11 +476,10 @@ template<\n   }\n \n \n-template<\n-    typename InputIterator,\n-    typename OutputIterator,\n-    typename Comparator>\n-  OutputIterator\n+template<typename InputIterator,\n+\t typename OutputIterator,\n+\t typename Comparator>\n+  inline OutputIterator\n   parallel_set_union(InputIterator begin1, InputIterator end1,\n                      InputIterator begin2, InputIterator end2,\n                      OutputIterator result, Comparator comp)\n@@ -493,11 +488,10 @@ template<\n         union_func< InputIterator, OutputIterator, Comparator>(comp));\n   }\n \n-template<\n-    typename InputIterator,\n-    typename OutputIterator,\n-    typename Comparator>\n-  OutputIterator\n+template<typename InputIterator,\n+\t typename OutputIterator,\n+\t typename Comparator>\n+  inline OutputIterator\n   parallel_set_intersection(InputIterator begin1, InputIterator end1,\n                             InputIterator begin2, InputIterator end2,\n                             OutputIterator result, Comparator comp)\n@@ -508,7 +502,7 @@ template<\n \n \n template<typename InputIterator, typename OutputIterator>\n-  OutputIterator\n+  inline OutputIterator\n   set_intersection(InputIterator begin1, InputIterator end1,\n                    InputIterator begin2, InputIterator end2,\n                    OutputIterator result)\n@@ -517,14 +511,13 @@ template<typename InputIterator, typename OutputIterator>\n     typedef typename traits_type::value_type value_type;\n \n     return set_intersection(begin1, end1, begin2, end2, result,\n-                  std::less<value_type>());\n+\t\t\t    std::less<value_type>());\n   }\n \n-template<\n-    typename InputIterator,\n-    typename OutputIterator,\n-    typename Comparator>\n-  OutputIterator\n+template<typename InputIterator,\n+\t typename OutputIterator,\n+\t typename Comparator>\n+  inline OutputIterator\n   parallel_set_difference(InputIterator begin1, InputIterator end1,\n                           InputIterator begin2, InputIterator end2,\n                           OutputIterator result, Comparator comp)\n@@ -533,11 +526,10 @@ template<\n         difference_func<InputIterator, OutputIterator, Comparator>(comp));\n   }\n \n-template<\n-    typename InputIterator,\n-    typename OutputIterator,\n-    typename Comparator>\n-  OutputIterator\n+template<typename InputIterator,\n+\t typename OutputIterator,\n+\t typename Comparator>\n+  inline OutputIterator\n   parallel_set_symmetric_difference(InputIterator begin1, InputIterator end1,\n                                     InputIterator begin2, InputIterator end2,\n                                     OutputIterator result, Comparator comp)"}, {"sha": "a06227b50085ea04f16404739fb83f5155a189e4", "filename": "libstdc++-v3/include/parallel/settings.h", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsettings.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -33,7 +33,8 @@\n  *  whether to use parallelized algorithms.\n  *  This file is a GNU parallel extension to the Standard C++ Library.\n  *\n- *  @section parallelization_decision  The decision whether to run an algorithm in parallel.\n+ *  @section parallelization_decision  The decision whether to run\n+ *                                     an algorithm in parallel.\n  *\n  *  There are several ways the user can switch on and off the \n  *  parallel execution of an algorithm, both at compile- and \n@@ -104,7 +105,10 @@\n   * __gnu_parallel::Settings::force_parallel, i. e. usually a decision based on\n   * the input size.\n   */\n-#define _GLIBCXX_PARALLEL_CONDITION(c) (!(__gnu_parallel::Settings::force_sequential) && ((__gnu_parallel::get_max_threads() > 1 && (c)) || __gnu_parallel::Settings::force_parallel))\n+#define _GLIBCXX_PARALLEL_CONDITION(c) \\\n+(!(__gnu_parallel::Settings::force_sequential) \\\n+ && ((__gnu_parallel::get_max_threads() > 1 \\\n+      && (c)) || __gnu_parallel::Settings::force_parallel))\n \n namespace __gnu_parallel\n {\n@@ -131,7 +135,8 @@ namespace\n     /** @brief Different merging algorithms: bubblesort-alike,\n \tloser-tree variants, enum sentinel */\n     enum MultiwayMergeAlgorithm\n-    { BUBBLE, LOSER_TREE_EXPLICIT, LOSER_TREE, LOSER_TREE_COMBINED, LOSER_TREE_SENTINEL, MWM_ALGORITHM_LAST };\n+    { BUBBLE, LOSER_TREE_EXPLICIT, LOSER_TREE, LOSER_TREE_COMBINED,\n+      LOSER_TREE_SENTINEL, MWM_ALGORITHM_LAST };\n \n     /** @brief Different splitting strategies for sorting/merging:\n \tby sampling, exact */\n@@ -340,7 +345,8 @@ namespace\n   volatile sequence_index_t Settings::partition_chunk_size = 1000;\n   volatile double Settings::partition_chunk_share = 0.0;\n   volatile unsigned int Settings::adjacent_difference_minimal_n = 1000;\n-  volatile  Settings::PartialSumAlgorithm Settings::partial_sum_algorithm = Settings::LINEAR;\n+  volatile  Settings::PartialSumAlgorithm Settings::\n+  partial_sum_algorithm = Settings::LINEAR;\n   volatile unsigned int Settings::partial_sum_minimal_n = 1000;\n   volatile float Settings::partial_sum_dilatation = 1.0f;\n   volatile unsigned int Settings::random_shuffle_minimal_n = 1000;\n@@ -352,10 +358,13 @@ namespace\n \n   // unique copy\n   volatile sequence_index_t Settings::unique_copy_minimal_n = 10000;\n-  volatile  Settings::MultiwayMergeAlgorithm Settings::multiway_merge_algorithm = Settings::LOSER_TREE;\n-  volatile  Settings::Splitting Settings::multiway_merge_splitting = Settings::EXACT;\n+  volatile  Settings::MultiwayMergeAlgorithm Settings::\n+  multiway_merge_algorithm = Settings::LOSER_TREE;\n+  volatile  Settings::Splitting Settings::multiway_merge_splitting =\n+    Settings::EXACT;\n   volatile unsigned int Settings::multiway_merge_oversampling = 10;\n-  volatile  Settings::FindDistribution Settings::find_distribution = Settings::CONSTANT_SIZE_BLOCKS;\n+  volatile  Settings::FindDistribution Settings::find_distribution =\n+    Settings::CONSTANT_SIZE_BLOCKS;\n   volatile sequence_index_t Settings::find_sequential_search_size = 256;\n   volatile sequence_index_t Settings::find_initial_block_size = 256;\n   volatile sequence_index_t Settings::find_maximum_block_size = 8192;\n@@ -375,7 +384,8 @@ namespace\n   volatile sequence_index_t Settings::set_union_minimal_n = 1000;\n   volatile sequence_index_t Settings::set_intersection_minimal_n = 1000;\n   volatile sequence_index_t Settings::set_difference_minimal_n = 1000;\n-  volatile sequence_index_t Settings::set_symmetric_difference_minimal_n = 1000;\n+  volatile sequence_index_t Settings::set_symmetric_difference_minimal_n =\n+    1000;\n   volatile unsigned long long Settings::L1_cache_size = 16 << 10;\n   volatile unsigned long long Settings::L2_cache_size = 256 << 10;\n   volatile unsigned int Settings::TLB_size = 128;"}, {"sha": "5dc3470f4104e73f678a9a36286ddbe207d2dc0b", "filename": "libstdc++-v3/include/parallel/sort.h", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -69,36 +69,37 @@ namespace __gnu_parallel\n    *  @callgraph \n    */\n   template<typename RandomAccessIterator, typename Comparator>\n-  inline void\n-  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n-\t\tComparator comp, bool stable)\n-  {\n-    _GLIBCXX_CALL(end - begin)\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::value_type value_type;\n-    typedef typename traits_type::difference_type difference_type;\n-\n-    if (begin != end)\n-      {\n-\tdifference_type n = end - begin;\n-\n-\tif (false) ;\n+    inline void\n+    parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n+\t\t  Comparator comp, bool stable)\n+    {\n+      _GLIBCXX_CALL(end - begin)\n+      typedef std::iterator_traits<RandomAccessIterator> traits_type;\n+      typedef typename traits_type::value_type value_type;\n+      typedef typename traits_type::difference_type difference_type;\n+\n+      if (begin != end)\n+\t{\n+\t  difference_type n = end - begin;\n+\n+\t  if (false) ;\n #if _GLIBCXX_MERGESORT\n-\telse if (Settings::sort_algorithm == Settings::MWMS || stable)\n-\t  parallel_sort_mwms(begin, end, comp, n, get_max_threads(), stable);\n+\t  else if (Settings::sort_algorithm == Settings::MWMS || stable)\n+\t    parallel_sort_mwms(begin, end, comp, n, get_max_threads(), stable);\n #endif\n #if _GLIBCXX_QUICKSORT\n-\telse if (Settings::sort_algorithm == Settings::QS && !stable)\n-\t  parallel_sort_qs(begin, end, comp, n, get_max_threads());\n+\t  else if (Settings::sort_algorithm == Settings::QS && !stable)\n+\t    parallel_sort_qs(begin, end, comp, n, get_max_threads());\n #endif\n #if _GLIBCXX_BAL_QUICKSORT\n-\telse if (Settings::sort_algorithm == Settings::QS_BALANCED && !stable)\n-\t  parallel_sort_qsb(begin, end, comp, n, get_max_threads());\n+\t  else if (Settings::sort_algorithm == Settings::QS_BALANCED\n+\t\t   && !stable)\n+\t    parallel_sort_qsb(begin, end, comp, n, get_max_threads());\n #endif\n-\telse\n-\t  __gnu_sequential::sort(begin, end, comp);\n-      }\n-  }\n+\t  else\n+\t    __gnu_sequential::sort(begin, end, comp);\n+\t}\n+    }\n } // end namespace __gnu_parallel\n \n #endif"}, {"sha": "52589b8db5afc3effb6d88ca4214b461ecaadfa7", "filename": "libstdc++-v3/include/parallel/tree.h", "status": "modified", "additions": 1959, "deletions": 1597, "changes": 3556, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftree.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992"}, {"sha": "01bd1077c1b5ec37d7ec60d48884fba96cebd123", "filename": "libstdc++-v3/include/parallel/unique_copy.h", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -50,11 +50,10 @@ namespace __gnu_parallel\n   *  @param result Begin iterator of result sequence.\n   *  @param binary_pred Equality predicate.\n   *  @return End iterator of result sequence. */\n-template<\n-    typename InputIterator,\n-    class OutputIterator,\n-    class BinaryPredicate>\n-  inline OutputIterator\n+template<typename InputIterator,\n+\t class OutputIterator,\n+\t class BinaryPredicate>\n+  OutputIterator\n   parallel_unique_copy(InputIterator first, InputIterator last,\n                        OutputIterator result, BinaryPredicate binary_pred)\n   {\n@@ -79,10 +78,10 @@ template<\n       {\n #       pragma omp single\n           {\n-                num_threads = omp_get_num_threads();\n-                borders = new difference_type[num_threads + 2];\n-                equally_split(size, num_threads + 1, borders);\n-                counter = new difference_type[num_threads + 1];\n+\t    num_threads = omp_get_num_threads();\n+\t    borders = new difference_type[num_threads + 2];\n+\t    equally_split(size, num_threads + 1, borders);\n+\t    counter = new difference_type[num_threads + 1];\n           }\n \n         thread_index_t iam = omp_get_thread_num();\n@@ -99,14 +98,14 @@ template<\n           begin = borders[0] + 1;\t// == 1\n           end = borders[iam + 1];\n \n-          i++;\n+          ++i;\n           *out++ = *first;\n \n           for (InputIterator iter = first + begin; iter < first + end; ++iter)\n             {\n               if (!binary_pred(*iter, *(iter-1)))\n                 {\n-                  i++;\n+                  ++i;\n                   *out++ = *iter;\n                 }\n             }\n@@ -118,11 +117,9 @@ template<\n \n           for (InputIterator iter = first + begin; iter < first + end; ++iter)\n             {\n-              if (!binary_pred(*iter, *(iter-1)))\n-                {\n-                  i++;\n-                }\n-            }\n+              if (!binary_pred(*iter, *(iter - 1)))\n+\t\t++i;\n+\t    }\n         }\n       counter[iam] = i;\n \n@@ -136,7 +133,7 @@ template<\n \n       if (iam == 0)\n         {\n-          for (int t = 0; t < num_threads; t++)\n+          for (int t = 0; t < num_threads; ++t)\n             begin_output += counter[t];\n \n           i = 0;\n@@ -148,9 +145,9 @@ template<\n \n           for (InputIterator iter = first + begin; iter < first + end; ++iter)\n             {\n-              if (iter == first || !binary_pred(*iter, *(iter-1)))\n+              if (iter == first || !binary_pred(*iter, *(iter - 1)))\n                 {\n-                  i++;\n+                  ++i;\n                   *iter_out++ = *iter;\n                 }\n             }\n@@ -166,10 +163,8 @@ template<\n           for (InputIterator iter = first + begin; iter < first + end; ++iter)\n             {\n               if (!binary_pred(*iter, *(iter-1)))\n-                {\n-                  *iter_out++ = *iter;\n-                }\n-            }\n+\t\t*iter_out++ = *iter;\n+\t    }\n         }\n     }\n \n@@ -193,8 +188,8 @@ template<typename InputIterator, class OutputIterator>\n                        OutputIterator result)\n   {\n     typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n-\n-    return parallel_unique_copy(first, last, result, std::equal_to<value_type>());\n+    return parallel_unique_copy(first, last, result,\n+\t\t\t\tstd::equal_to<value_type>());\n   }\n \n }//namespace __gnu_parallel"}, {"sha": "4f0c7482c2fae1fc64f5e5f12a33273f3c773c76", "filename": "libstdc++-v3/include/parallel/workstealing.h", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5817ff8e5f722e2a36ed6982f94d003164c01992/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h?ref=5817ff8e5f722e2a36ed6982f94d003164c01992", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -96,20 +96,19 @@ template<typename _DifferenceTp>\n   *  std::count_n()).\n   *  @return User-supplied functor (that may contain a part of the result).\n   */\n-template<\n-    typename RandomAccessIterator,\n-    typename Op,\n-    typename Fu,\n-    typename Red,\n-    typename Result>\n+template<typename RandomAccessIterator,\n+\t typename Op,\n+\t typename Fu,\n+\t typename Red,\n+\t typename Result>\n   Op\n-  for_each_template_random_access_workstealing(\n-      RandomAccessIterator begin,\n-      RandomAccessIterator end,\n-      Op op, Fu& f, Red r,\n-      Result base, Result& output,\n-      typename std::iterator_traits<RandomAccessIterator>::difference_type\n-          bound)\n+  for_each_template_random_access_workstealing(RandomAccessIterator begin,\n+\t\t\t\t\t       RandomAccessIterator end,\n+\t\t\t\t\t       Op op, Fu& f, Red r,\n+\t\t\t\t\t       Result base, Result& output,\n+\t\t\t\t\t       typename std::iterator_traits\n+\t\t\t\t\t       <RandomAccessIterator>::\n+\t\t\t\t\t       difference_type bound)\n   {\n     _GLIBCXX_CALL(end - begin)\n \n@@ -180,7 +179,7 @@ template<\n \n         // This thread is currently working.\n #       pragma omp atomic\n-          busy++;\n+          ++busy;\n \n         iam_working = true;\n \n@@ -198,8 +197,8 @@ template<\n             // Cannot use volatile variable directly.\n             difference_type my_first = my_job.first;\n             result = f(op, begin + my_first);\n-            my_job.first++;\n-            my_job.load--;\n+            ++my_job.first;\n+            --my_job.load;\n           }\n \n         RandomAccessIterator current;\n@@ -226,11 +225,11 @@ template<\n                 my_job.load = my_job.last - my_job.first + 1;\n                 for (difference_type job_counter = 0;\n                      job_counter < chunk_size && current_job <= my_job.last;\n-                     job_counter++)\n+                     ++job_counter)\n                   {\n                     // Yes: process it!\n                     current = begin + current_job;\n-                    current_job++;\n+                    ++current_job;\n \n                     // Do actual work.\n                     result = r(result, f(op, current));\n@@ -244,7 +243,7 @@ template<\n               {\n                 // This thread no longer has work.\n #               pragma omp atomic\n-                busy--;\n+                --busy;\n \n                 iam_working = false;\n               }\n@@ -286,7 +285,7 @@ template<\n \n                 // Has potential work again.\n #               pragma omp atomic\n-                  busy++;\n+                  ++busy;\n                 iam_working = true;\n \n #               pragma omp flush(busy)"}]}