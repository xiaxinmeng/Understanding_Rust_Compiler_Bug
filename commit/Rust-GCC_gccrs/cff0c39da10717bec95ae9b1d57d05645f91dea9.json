{"sha": "cff0c39da10717bec95ae9b1d57d05645f91dea9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZmMGMzOWRhMTA3MTdiZWM5NWFlOWIxZDU3ZDA1NjQ1ZjkxZGVhOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-01-13T05:17:52Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-01-13T05:17:52Z"}, "message": "Clean up syscalls, add some Solaris support.\n\nFrom-SVN: r168738", "tree": {"sha": "e9602dee09986866e66e3bee32d69f8c5d57bf78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9602dee09986866e66e3bee32d69f8c5d57bf78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cff0c39da10717bec95ae9b1d57d05645f91dea9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cff0c39da10717bec95ae9b1d57d05645f91dea9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cff0c39da10717bec95ae9b1d57d05645f91dea9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cff0c39da10717bec95ae9b1d57d05645f91dea9/comments", "author": null, "committer": null, "parents": [{"sha": "243ffa47b314724dc9f5c0484e999243c4a25da9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/243ffa47b314724dc9f5c0484e999243c4a25da9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/243ffa47b314724dc9f5c0484e999243c4a25da9"}], "stats": {"total": 723, "additions": 413, "deletions": 310}, "files": [{"sha": "e2d2158a8c8181c845174ed2c3921616d9e72b39", "filename": "libgo/Makefile.am", "status": "modified", "additions": 81, "deletions": 14, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -596,10 +596,17 @@ go_mime_files = \\\n if LIBGO_IS_RTEMS\n go_net_fd_os_file = go/net/fd_rtems.go\n go_net_newpollserver_file = go/net/newpollserver_rtems.go\n-else\n+else # !LIBGO_IS_RTEMS\n+if LIBGO_IS_LINUX\n go_net_fd_os_file = go/net/fd_linux.go\n go_net_newpollserver_file = go/net/newpollserver.go\n-endif\n+else # !LIBGO_IS_LINUX && !LIBGO_IS_RTEMS\n+# By default use select with pipes.  Most systems should have\n+# something better.\n+go_net_fd_os_file = go/net/fd_rtems.go\n+go_net_newpollserver_file = go/net/newpollserver.go\n+endif # !LIBGO_IS_LINUX\n+endif # !LIBGO_IS_RTEMS\n \n go_net_files = \\\n \tgo/net/dial.go \\\n@@ -1019,33 +1026,92 @@ go_testing_quick_files = \\\n go_testing_script_files = \\\n \tgo/testing/script/script.go\n \n+# Define Syscall and Syscall6.\n if LIBGO_IS_RTEMS\n-syscall_exec_os_file = syscalls/exec_stubs.go\n-syscall_socket_os_file = syscalls/socket_bsd.go\n-syscall_socket_epoll_file =\n-syscall_sysfile_os_file = syscalls/sysfile_rtems.go\n syscall_syscall_file = syscalls/syscall_stubs.go\n-syscall_errstr_file = syscalls/errstr_rtems.go\n-syscall_errstr_decl_file = syscalls/errstr_decl_rtems.go\n else\n-syscall_exec_os_file = syscalls/exec.go\n-syscall_socket_os_file = syscalls/socket_linux.go\n-syscall_socket_epoll_file = syscalls/socket_epoll.go\n-syscall_sysfile_os_file = syscalls/sysfile_linux.go\n syscall_syscall_file = syscalls/syscall.go\n+endif\n+\n+# Declare libc functions that vary for largefile systems.\n+if LIBGO_IS_LINUX\n+# Always use lseek64 on GNU/Linux.\n+syscall_filesize_file = syscalls/sysfile_largefile.go\n+else # !LIBGO_IS_LINUX\n+if LIBGO_IS_SOLARIS\n+if LIBGO_IS_386\n+# Use lseek64 on 386 Solaris.\n+syscall_filesize_flie = syscalls/sysfile_largefile.go\n+else # !LIBGO_IS_LINUX && LIBGO_IS_SOLARIS && !LIBGO_IS_386\n+# Use lseek on amd64 Solaris.\n+syscall_filesize_flie = syscalls/sysfile_regfile.go\n+endif # !LIBGO_IS_386\n+else # !LIBGO_IS_LINUX && !LIBGO_IS_SOLARIS\n+# Use lseek by default.\n+syscall_filesize_file = syscalls/sysfile_regfile.go\n+endif # !LIBGO_IS_SOLARIS\n+endif # !LIBGO_IS_LINUX\n+\n+\n+# Define ForkExec, PtraceForkExec, Exec, and Wait4.\n+if LIBGO_IS_RTEMS\n+syscall_exec_os_file = syscalls/exec_stubs.go\n+else\n+syscall_exec_os_file = syscalls/exec.go\n+endif\n+\n+# Define Sleep.\n+if LIBGO_IS_RTEMS\n+syscall_sleep_file = syscalls/sleep_rtems.go\n+else\n+syscall_sleep_file = syscalls/sleep_select.go\n+endif\n+\n+# Define Errstr.\n+if LIBGO_IS_RTEMS\n+syscall_errstr_file = syscalls/errstr_rtems.go\n+else\n syscall_errstr_file = syscalls/errstr.go\n+endif\n+\n+# Declare libc_strerror_r which is the Go name for strerror_r.\n+if LIBGO_IS_RTEMS\n+# RTEMS uses newlib in which strerror_r returns char *.\n+syscall_errstr_decl_file = syscalls/errstr_decl_rtems.go\n+else\n if LIBGO_IS_LINUX\n+# In Linux the POSIX strerror_r is called __xpg_strerror_r.\n syscall_errstr_decl_file = syscalls/errstr_decl_linux.go\n else\n+# On other systems we hope strerror_r is just strerror_r.\n syscall_errstr_decl_file = syscalls/errstr_decl.go\n endif\n endif\n \n+# Define socket sizes and types.\n+if LIBGO_IS_LINUX\n+syscall_socket_os_file = syscalls/socket_linux.go\n+else\n+if LIBGO_IS_SOLARIS\n+syscall_socket_os_file = syscalls/socket_solaris.go\n+else\n+syscall_socket_os_file = syscalls_socket_bsd.go\n+endif\n+endif\n+\n+# Support for epoll.\n+if LIBGO_IS_LINUX\n+syscall_socket_epoll_file = syscalls/socket_epoll.go\n+else\n+syscall_socket_epoll_file =\n+endif\n+\n syscall_arch.go: s-syscall_arch; @true\n s-syscall_arch: Makefile\n \trm -f syscall_arch.go.tmp\n \techo \"package syscall\" > syscall_arch.go.tmp\n \techo 'const ARCH = \"'$(GOARCH)'\"' >> syscall_arch.go.tmp\n+\techo 'const OS = \"'$(GOOS)'\"' >> syscall_arch.go.tmp\n \t$(SHELL) $(srcdir)/../move-if-change syscall_arch.go.tmp syscall_arch.go\n \t$(STAMP) $@\n \n@@ -1054,6 +1120,8 @@ go_syscall_files = \\\n \t$(syscall_errstr_decl_file) \\\n \tsyscalls/exec_helpers.go \\\n \t$(syscall_exec_os_file) \\\n+\t$(syscall_filesize_file) \\\n+\t$(syscall_sleep_file) \\\n \tsyscalls/socket.go \\\n \t$(syscall_socket_os_file) \\\n \t$(syscall_socket_epoll_file) \\\n@@ -1063,7 +1131,6 @@ go_syscall_files = \\\n \tsyscalls/syscall_$(GOOS).go \\\n \tsyscalls/syscall_$(GOOS)_$(GOARCH).go \\\n \tsyscalls/sysfile_posix.go \\\n-\t$(syscall_sysfile_os_file) \\\n \tsysinfo.go \\\n \tsyscall_arch.go\n go_syscall_c_files = \\\n@@ -2232,7 +2299,7 @@ testing/script/check: $(CHECK_DEPS)\n .PHONY: testing/script/check\n \n sysinfo.go: $(srcdir)/mksysinfo.sh config.h\n-\t$(SHELL) $(srcdir)/mksysinfo.sh\n+\tCC=\"$(CC)\" $(SHELL) $(srcdir)/mksysinfo.sh\n syscalls/libsyscall.a: $(go_syscall_files) $(go_syscall_c_files) sync.gox\n \trm -f syscall.gox syscalls/libsyscall.a\n \ttest -d syscalls || $(MKDIR_P) syscalls"}, {"sha": "1b8fd5a2429e0815f1b653505034aaef2dc33d26", "filename": "libgo/Makefile.in", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -938,9 +938,13 @@ go_mime_files = \\\n \tgo/mime/mediatype.go \\\n \tgo/mime/type.go\n \n-@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = go/net/fd_linux.go\n+# By default use select with pipes.  Most systems should have\n+# something better.\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = go/net/fd_rtems.go\n+@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_fd_os_file = go/net/fd_linux.go\n @LIBGO_IS_RTEMS_TRUE@go_net_fd_os_file = go/net/fd_rtems.go\n-@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver.go\n+@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@go_net_newpollserver_file = go/net/newpollserver.go\n @LIBGO_IS_RTEMS_TRUE@go_net_newpollserver_file = go/net/newpollserver_rtems.go\n go_net_files = \\\n \tgo/net/dial.go \\\n@@ -1389,26 +1393,56 @@ go_testing_quick_files = \\\n go_testing_script_files = \\\n \tgo/testing/script/script.go\n \n-@LIBGO_IS_RTEMS_FALSE@syscall_exec_os_file = syscalls/exec.go\n-@LIBGO_IS_RTEMS_TRUE@syscall_exec_os_file = syscalls/exec_stubs.go\n-@LIBGO_IS_RTEMS_FALSE@syscall_socket_os_file = syscalls/socket_linux.go\n-@LIBGO_IS_RTEMS_TRUE@syscall_socket_os_file = syscalls/socket_bsd.go\n-@LIBGO_IS_RTEMS_FALSE@syscall_socket_epoll_file = syscalls/socket_epoll.go\n-@LIBGO_IS_RTEMS_TRUE@syscall_socket_epoll_file = \n-@LIBGO_IS_RTEMS_FALSE@syscall_sysfile_os_file = syscalls/sysfile_linux.go\n-@LIBGO_IS_RTEMS_TRUE@syscall_sysfile_os_file = syscalls/sysfile_rtems.go\n @LIBGO_IS_RTEMS_FALSE@syscall_syscall_file = syscalls/syscall.go\n+\n+# Define Syscall and Syscall6.\n @LIBGO_IS_RTEMS_TRUE@syscall_syscall_file = syscalls/syscall_stubs.go\n+# Use lseek by default.\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@syscall_filesize_file = syscalls/sysfile_regfile.go\n+\n+# Declare libc functions that vary for largefile systems.\n+# Always use lseek64 on GNU/Linux.\n+@LIBGO_IS_LINUX_TRUE@syscall_filesize_file = syscalls/sysfile_largefile.go\n+# Use lseek on amd64 Solaris.\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@syscall_filesize_flie = syscalls/sysfile_regfile.go\n+# Use lseek64 on 386 Solaris.\n+@LIBGO_IS_386_TRUE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@syscall_filesize_flie = syscalls/sysfile_largefile.go\n+@LIBGO_IS_RTEMS_FALSE@syscall_exec_os_file = syscalls/exec.go\n+\n+# Define ForkExec, PtraceForkExec, Exec, and Wait4.\n+@LIBGO_IS_RTEMS_TRUE@syscall_exec_os_file = syscalls/exec_stubs.go\n+@LIBGO_IS_RTEMS_FALSE@syscall_sleep_file = syscalls/sleep_select.go\n+\n+# Define Sleep.\n+@LIBGO_IS_RTEMS_TRUE@syscall_sleep_file = syscalls/sleep_rtems.go\n @LIBGO_IS_RTEMS_FALSE@syscall_errstr_file = syscalls/errstr.go\n+\n+# Define Errstr.\n @LIBGO_IS_RTEMS_TRUE@syscall_errstr_file = syscalls/errstr_rtems.go\n+# On other systems we hope strerror_r is just strerror_r.\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_RTEMS_FALSE@syscall_errstr_decl_file = syscalls/errstr_decl.go\n+# In Linux the POSIX strerror_r is called __xpg_strerror_r.\n @LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@syscall_errstr_decl_file = syscalls/errstr_decl_linux.go\n+\n+# Declare libc_strerror_r which is the Go name for strerror_r.\n+# RTEMS uses newlib in which strerror_r returns char *.\n @LIBGO_IS_RTEMS_TRUE@syscall_errstr_decl_file = syscalls/errstr_decl_rtems.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@syscall_socket_os_file = syscalls_socket_bsd.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@syscall_socket_os_file = syscalls/socket_solaris.go\n+\n+# Define socket sizes and types.\n+@LIBGO_IS_LINUX_TRUE@syscall_socket_os_file = syscalls/socket_linux.go\n+@LIBGO_IS_LINUX_FALSE@syscall_socket_epoll_file = \n+\n+# Support for epoll.\n+@LIBGO_IS_LINUX_TRUE@syscall_socket_epoll_file = syscalls/socket_epoll.go\n go_syscall_files = \\\n \t$(syscall_errstr_file) \\\n \t$(syscall_errstr_decl_file) \\\n \tsyscalls/exec_helpers.go \\\n \t$(syscall_exec_os_file) \\\n+\t$(syscall_filesize_file) \\\n+\t$(syscall_sleep_file) \\\n \tsyscalls/socket.go \\\n \t$(syscall_socket_os_file) \\\n \t$(syscall_socket_epoll_file) \\\n@@ -1418,7 +1452,6 @@ go_syscall_files = \\\n \tsyscalls/syscall_$(GOOS).go \\\n \tsyscalls/syscall_$(GOOS)_$(GOARCH).go \\\n \tsyscalls/sysfile_posix.go \\\n-\t$(syscall_sysfile_os_file) \\\n \tsysinfo.go \\\n \tsyscall_arch.go\n \n@@ -3608,6 +3641,7 @@ s-syscall_arch: Makefile\n \trm -f syscall_arch.go.tmp\n \techo \"package syscall\" > syscall_arch.go.tmp\n \techo 'const ARCH = \"'$(GOARCH)'\"' >> syscall_arch.go.tmp\n+\techo 'const OS = \"'$(GOOS)'\"' >> syscall_arch.go.tmp\n \t$(SHELL) $(srcdir)/../move-if-change syscall_arch.go.tmp syscall_arch.go\n \t$(STAMP) $@\n \n@@ -4578,7 +4612,7 @@ testing/script/check: $(CHECK_DEPS)\n .PHONY: testing/script/check\n \n sysinfo.go: $(srcdir)/mksysinfo.sh config.h\n-\t$(SHELL) $(srcdir)/mksysinfo.sh\n+\tCC=\"$(CC)\" $(SHELL) $(srcdir)/mksysinfo.sh\n syscalls/libsyscall.a: $(go_syscall_files) $(go_syscall_c_files) sync.gox\n \trm -f syscall.gox syscalls/libsyscall.a\n \ttest -d syscalls || $(MKDIR_P) syscalls"}, {"sha": "a95abc686f3177c224d02bff590e323b6efb95b0", "filename": "libgo/syscalls/errstr.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Ferrstr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Ferrstr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Ferrstr.go?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -6,11 +6,6 @@\n \n package syscall\n \n-const ENONE = 0\n-\n-func GetErrno() int\n-func SetErrno(int)\n-\n func Errstr(errno int) string {\n \tfor len := Size_t(128); ; len *= 2 {\n \t\tb := make([]byte, len)"}, {"sha": "f6b453bdc7397658bef9d86340160b959ad056fd", "filename": "libgo/syscalls/errstr_rtems.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Ferrstr_rtems.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Ferrstr_rtems.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Ferrstr_rtems.go?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -6,11 +6,6 @@\n \n package syscall\n \n-const ENONE = 0\n-\n-func GetErrno() int\n-func SetErrno(int)\n-\n func Errstr(errno int) string {\n \tfor len := Size_t(128); ; len *= 2 {\n \t\tb := make([]byte, len+1)"}, {"sha": "443e8508edcef47c5a6412cbf69190b9e4f895c1", "filename": "libgo/syscalls/sleep_rtems.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsleep_rtems.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsleep_rtems.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsleep_rtems.go?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -0,0 +1,17 @@\n+// sleep_rtems.go -- Sleep on RTEMS.\n+\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+func libc_nanosleep(req *Timespec, rem *Timespec) int __asm__ (\"nanosleep\")\n+\n+func Sleep(nsec int64) (errno int) {\n+\terrno = 0\n+\tts := NsecToTimespec(nsec)\n+\tr := libc_nanosleep(&ts, nil)\n+\tif r < 0 {\n+\t\terrno = GetErrno()\n+\t}\n+\treturn\n+}"}, {"sha": "6fc13a0ea5ea6ce634418bbc552d890f51b746f0", "filename": "libgo/syscalls/sleep_select.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsleep_select.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsleep_select.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsleep_select.go?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -0,0 +1,13 @@\n+// sleep_select.go -- Sleep using select.\n+\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package syscall\n+\n+func Sleep(nsec int64) (errno int) {\n+\ttv := NsecToTimeval(nsec);\n+\tn, err := Select(0, nil, nil, nil, &tv);\n+\treturn err;\n+}"}, {"sha": "bc3ce694f2c3d24f63c1fd088549492b84da1909", "filename": "libgo/syscalls/socket.go", "status": "modified", "additions": 85, "deletions": 4, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsocket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsocket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsocket.go?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -12,10 +12,6 @@ package syscall\n \n import \"unsafe\"\n \n-const SizeofSockaddrInet4 = 16\n-const SizeofSockaddrInet6 = 28\n-const SizeofSockaddrUnix = 110\n-\n type RawSockaddrAny struct {\n \tAddr RawSockaddr;\n \tPad [12]int8;\n@@ -53,6 +49,91 @@ type Linger struct {\n \tLinger int32;\n }\n \n+func (sa *SockaddrInet4) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n+\tif sa.Port < 0 || sa.Port > 0xFFFF {\n+\t\treturn nil, 0, EINVAL;\n+\t}\n+\tsa.raw.Family = AF_INET;\n+\tn := sa.raw.setLen()\n+\tp := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));\n+\tp[0] = byte(sa.Port>>8);\n+\tp[1] = byte(sa.Port);\n+\tfor i := 0; i < len(sa.Addr); i++ {\n+\t\tsa.raw.Addr[i] = sa.Addr[i];\n+\t}\n+\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), n, 0;\n+}\n+\n+func (sa *SockaddrInet6) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n+\tif sa.Port < 0 || sa.Port > 0xFFFF {\n+\t\treturn nil, 0, EINVAL;\n+\t}\n+\tsa.raw.Family = AF_INET6;\n+\tn := sa.raw.setLen()\n+\tp := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));\n+\tp[0] = byte(sa.Port>>8);\n+\tp[1] = byte(sa.Port);\n+\tfor i := 0; i < len(sa.Addr); i++ {\n+\t\tsa.raw.Addr[i] = sa.Addr[i];\n+\t}\n+\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), n, 0;\n+}\n+\n+func (sa *SockaddrUnix) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n+\tname := sa.Name;\n+\tn := len(name);\n+\tif n >= len(sa.raw.Path) || n == 0 {\n+\t\treturn nil, 0, EINVAL;\n+\t}\n+\tsa.raw.Family = AF_UNIX;\n+\tsa.raw.setLen(n)\n+\tfor i := 0; i < n; i++ {\n+\t\tsa.raw.Path[i] = int8(name[i]);\n+\t}\n+\tif sa.raw.Path[0] == '@' {\n+\t\tsa.raw.Path[0] = 0;\n+\t}\n+\n+\t// length is family (uint16), name, NUL.\n+\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), 2 + Socklen_t(n) + 1, 0;\n+}\n+\n+func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {\n+\tswitch rsa.Addr.Family {\n+\tcase AF_UNIX:\n+\t\tpp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))\n+\t\tsa := new(SockaddrUnix)\n+\t\tn, err := pp.getLen()\n+\t\tif err != 0 {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tbytes := (*[len(pp.Path)]byte)(unsafe.Pointer(&pp.Path[0]));\n+\t\tsa.Name = string(bytes[0:n]);\n+\t\treturn sa, 0;\n+\n+\tcase AF_INET:\n+\t\tpp := (*RawSockaddrInet4)(unsafe.Pointer(rsa));\n+\t\tsa := new(SockaddrInet4);\n+\t\tp := (*[2]byte)(unsafe.Pointer(&pp.Port));\n+\t\tsa.Port = int(p[0])<<8 + int(p[1]);\n+\t\tfor i := 0; i < len(sa.Addr); i++ {\n+\t\t\tsa.Addr[i] = pp.Addr[i];\n+\t\t}\n+\t\treturn sa, 0;\n+\n+\tcase AF_INET6:\n+\t\tpp := (*RawSockaddrInet6)(unsafe.Pointer(rsa));\n+\t\tsa := new(SockaddrInet6);\n+\t\tp := (*[2]byte)(unsafe.Pointer(&pp.Port));\n+\t\tsa.Port = int(p[0])<<8 + int(p[1]);\n+\t\tfor i := 0; i < len(sa.Addr); i++ {\n+\t\t\tsa.Addr[i] = pp.Addr[i];\n+\t\t}\n+\t\treturn sa, 0;\n+\t}\n+\treturn nil, EAFNOSUPPORT;\n+}\n+\n func libc_accept(fd int, sa *RawSockaddrAny, len *Socklen_t) int __asm__ (\"accept\");\n func libc_bind(fd int, sa *RawSockaddrAny, len Socklen_t) int __asm__ (\"bind\");\n func libc_connect(fd int, sa *RawSockaddrAny, len Socklen_t) int __asm__ (\"connect\");"}, {"sha": "c46e24e8f56842dafce79eb7708e30384b29366e", "filename": "libgo/syscalls/socket_bsd.go", "status": "modified", "additions": 29, "deletions": 94, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsocket_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsocket_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsocket_bsd.go?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -4,13 +4,11 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Low-level socket interface.\n-// Only for implementing net package.\n-// DO NOT USE DIRECTLY.\n-\n package syscall\n \n-import \"unsafe\"\n+const SizeofSockaddrInet4 = 16\n+const SizeofSockaddrInet6 = 28\n+const SizeofSockaddrUnix = 110\n \n type RawSockaddrInet4 struct {\n \tLen uint8;\n@@ -20,6 +18,11 @@ type RawSockaddrInet4 struct {\n \tZero [8]uint8;\n }\n \n+func (sa *RawSockaddrInet4) setLen() Socklen_t {\n+\tsa.Len = SizeofSockaddrInet4\n+\treturn SizeofSockaddrInet4\n+}\n+\n type RawSockaddrInet6 struct {\n \tLen uint8;\n \tFamily uint8;\n@@ -29,108 +32,40 @@ type RawSockaddrInet6 struct {\n \tScope_id uint32;\n }\n \n-type RawSockaddrUnix struct {\n-\tLen uint8;\n-\tFamily uint8;\n-\tPath [108]int8;\n+func (sa *RawSockaddrInet6) setLen() Socklen_t {\n+\tsa.raw.Len = SizeofSockaddrInet6\n+\treturn SizeofSockaddrInet6\n }\n \n-type RawSockaddr struct {\n+type RawSockaddrUnix struct {\n \tLen uint8;\n \tFamily uint8;\n-\tData [14]int8;\n+\tPath [108]int8;\n }\n \n-func (sa *SockaddrInet4) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n-\tif sa.Port < 0 || sa.Port > 0xFFFF {\n-\t\treturn nil, 0, EINVAL;\n-\t}\n-\tsa.raw.Len = SizeofSockaddrInet4;\n-\tsa.raw.Family = AF_INET;\n-\tp := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));\n-\tp[0] = byte(sa.Port>>8);\n-\tp[1] = byte(sa.Port);\n-\tfor i := 0; i < len(sa.Addr); i++ {\n-\t\tsa.raw.Addr[i] = sa.Addr[i];\n-\t}\n-\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), Socklen_t(sa.raw.Len), 0;\n+func (sa *RawsockaddrUnix) setLen(n int) {\n+\tsa.Len = uint8(3 + n) // 2 for Family, Len; 1 for NUL.\n }\n \n-func (sa *SockaddrInet6) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n-\tif sa.Port < 0 || sa.Port > 0xFFFF {\n-\t\treturn nil, 0, EINVAL;\n-\t}\n-\tsa.raw.Len = SizeofSockaddrInet6;\n-\tsa.raw.Family = AF_INET6;\n-\tp := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));\n-\tp[0] = byte(sa.Port>>8);\n-\tp[1] = byte(sa.Port);\n-\tfor i := 0; i < len(sa.Addr); i++ {\n-\t\tsa.raw.Addr[i] = sa.Addr[i];\n+func (sa *RawsockaddrUnix) getLen() (int, int) {\n+\tif sa.Len < 3 || sa.Len > SizeofSockaddrUnix {\n+\t\treturn 0, EINVAL\n \t}\n-\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), Socklen_t(sa.raw.Len), 0;\n-}\n-\n-func (sa *SockaddrUnix) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n-\tname := sa.Name;\n-\tn := len(name);\n-\tif n >= len(sa.raw.Path) || n == 0 {\n-\t\treturn nil, 0, EINVAL;\n-\t}\n-\tsa.raw.Len = byte(3 + n); // 2 for Family, Len; 1 for NUL.\n-\tsa.raw.Family = AF_UNIX;\n+\tn := int(sa.Len) - 3 // subtract leading Family, Len, terminating NUL.\n \tfor i := 0; i < n; i++ {\n-\t\tsa.raw.Path[i] = int8(name[i]);\n-\t}\n-\tif sa.raw.Path[0] == '@' {\n-\t\tsa.raw.Path[0] = 0;\n+\t\tif sa.Path[i] == 0 {\n+\t\t\t// found early NUL; assume Len is overestimating.\n+\t\t\tn = i\n+\t\t\tbreak\n+\t\t}\n \t}\n-\n-\t// length is family, name, NUL.\n-\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), Socklen_t(sa.raw.Len), 0;\n+\treturn n, 0\n }\n \n-func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {\n-\tswitch rsa.Addr.Family {\n-\tcase AF_UNIX:\n-\t\tpp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))\n-\t\tif pp.Len < 3 || pp.Len > SizeofSockaddrUnix {\n-\t\t\treturn nil, EINVAL\n-\t\t}\n-\t\tsa := new(SockaddrUnix)\n-\t\tn := int(pp.Len) - 3 // subtract leading Family, Len, terminating NUL.\n-\t\tfor i := 0; i < n; i++ {\n-\t\t\tif pp.Path[i] == 0 {\n-\t\t\t\t// found early NUL; assume Len is overestimating.\n-\t\t\t\tn = i\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\tbytes := (*[len(pp.Path)]byte)(unsafe.Pointer(&pp.Path[0]))\n-\t\tsa.Name = string(bytes[0:n])\n-\t\treturn sa, 0\n-\n-\tcase AF_INET:\n-\t\tpp := (*RawSockaddrInet4)(unsafe.Pointer(rsa));\n-\t\tsa := new(SockaddrInet4);\n-\t\tp := (*[2]byte)(unsafe.Pointer(&pp.Port));\n-\t\tsa.Port = int(p[0])<<8 + int(p[1]);\n-\t\tfor i := 0; i < len(sa.Addr); i++ {\n-\t\t\tsa.Addr[i] = pp.Addr[i];\n-\t\t}\n-\t\treturn sa, 0;\n-\n-\tcase AF_INET6:\n-\t\tpp := (*RawSockaddrInet6)(unsafe.Pointer(rsa));\n-\t\tsa := new(SockaddrInet6);\n-\t\tp := (*[2]byte)(unsafe.Pointer(&pp.Port));\n-\t\tsa.Port = int(p[0])<<8 + int(p[1]);\n-\t\tfor i := 0; i < len(sa.Addr); i++ {\n-\t\t\tsa.Addr[i] = pp.Addr[i];\n-\t\t}\n-\t\treturn sa, 0;\n-\t}\n-\treturn nil, EAFNOSUPPORT;\n+type RawSockaddr struct {\n+\tLen uint8;\n+\tFamily uint8;\n+\tData [14]int8;\n }\n \n // BindToDevice binds the socket associated with fd to device."}, {"sha": "cdcdf4ff28bed5cb29ddb591ae6c85593705d467", "filename": "libgo/syscalls/socket_linux.go", "status": "modified", "additions": 32, "deletions": 97, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsocket_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsocket_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsocket_linux.go?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -4,14 +4,11 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Low-level socket interface.\n-// Only for implementing net package.\n-\n-// DO NOT USE DIRECTLY.\n-\n package syscall\n \n-import \"unsafe\"\n+const SizeofSockaddrInet4 = 16\n+const SizeofSockaddrInet6 = 28\n+const SizeofSockaddrUnix = 110\n \n type RawSockaddrInet4 struct {\n \tFamily uint16;\n@@ -20,6 +17,10 @@ type RawSockaddrInet4 struct {\n \tZero [8]uint8;\n }\n \n+func (sa *RawSockaddrInet4) setLen() Socklen_t {\n+\treturn SizeofSockaddrInet4\n+}\n+\n type RawSockaddrInet6 struct {\n \tFamily uint16;\n \tPort uint16;\n@@ -28,110 +29,44 @@ type RawSockaddrInet6 struct {\n \tScope_id uint32;\n }\n \n-type RawSockaddrUnix struct {\n-\tFamily uint16;\n-\tPath [108]int8;\n+func (sa *RawSockaddrInet6) setLen() Socklen_t {\n+\treturn SizeofSockaddrInet6\n }\n \n-type RawSockaddr struct {\n+type RawSockaddrUnix struct {\n \tFamily uint16;\n-\tData [14]int8;\n+\tPath [108]int8;\n }\n \n-func (sa *SockaddrInet4) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n-\tif sa.Port < 0 || sa.Port > 0xFFFF {\n-\t\treturn nil, 0, EINVAL;\n-\t}\n-\tsa.raw.Family = AF_INET;\n-\tp := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));\n-\tp[0] = byte(sa.Port>>8);\n-\tp[1] = byte(sa.Port);\n-\tfor i := 0; i < len(sa.Addr); i++ {\n-\t\tsa.raw.Addr[i] = sa.Addr[i];\n-\t}\n-\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), SizeofSockaddrInet4, 0;\n+func (sa *RawSockaddrUnix) setLen(int) {\n }\n \n-func (sa *SockaddrInet6) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n-\tif sa.Port < 0 || sa.Port > 0xFFFF {\n-\t\treturn nil, 0, EINVAL;\n-\t}\n-\tsa.raw.Family = AF_INET6;\n-\tp := (*[2]byte)(unsafe.Pointer(&sa.raw.Port));\n-\tp[0] = byte(sa.Port>>8);\n-\tp[1] = byte(sa.Port);\n-\tfor i := 0; i < len(sa.Addr); i++ {\n-\t\tsa.raw.Addr[i] = sa.Addr[i];\n+func (sa *RawSockaddrUnix) getLen() (int, int) {\n+\tif sa.Path[0] == 0 {\n+\t\t// \"Abstract\" Unix domain socket.\n+\t\t// Rewrite leading NUL as @ for textual display.\n+\t\t// (This is the standard convention.)\n+\t\t// Not friendly to overwrite in place,\n+\t\t// but the callers below don't care.\n+\t\tsa.Path[0] = '@';\n \t}\n-\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), SizeofSockaddrInet6, 0;\n-}\n \n-func (sa *SockaddrUnix) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n-\tname := sa.Name;\n-\tn := len(name);\n-\tif n >= len(sa.raw.Path) || n == 0 {\n-\t\treturn nil, 0, EINVAL;\n-\t}\n-\tsa.raw.Family = AF_UNIX;\n-\tfor i := 0; i < n; i++ {\n-\t\tsa.raw.Path[i] = int8(name[i]);\n-\t}\n-\tif sa.raw.Path[0] == '@' {\n-\t\tsa.raw.Path[0] = 0;\n+\t// Assume path ends at NUL.\n+\t// This is not technically the Linux semantics for\n+\t// abstract Unix domain sockets--they are supposed\n+\t// to be uninterpreted fixed-size binary blobs--but\n+\t// everyone uses this convention.\n+\tn := 0;\n+\tfor n < len(sa.Path) - 3 && sa.Path[n] != 0 {\n+\t\tn++;\n \t}\n \n-\t// length is family, name, NUL.\n-\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), 1 + Socklen_t(n) + 1, 0;\n+\treturn n, 0\n }\n \n-func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {\n-\tswitch rsa.Addr.Family {\n-\tcase AF_UNIX:\n-\t\tpp := (*RawSockaddrUnix)(unsafe.Pointer(rsa));\n-\t\tsa := new(SockaddrUnix);\n-\t\tif pp.Path[0] == 0 {\n-\t\t\t// \"Abstract\" Unix domain socket.\n-\t\t\t// Rewrite leading NUL as @ for textual display.\n-\t\t\t// (This is the standard convention.)\n-\t\t\t// Not friendly to overwrite in place,\n-\t\t\t// but the callers below don't care.\n-\t\t\tpp.Path[0] = '@';\n-\t\t}\n-\n-\t\t// Assume path ends at NUL.\n-\t\t// This is not technically the Linux semantics for\n-\t\t// abstract Unix domain sockets--they are supposed\n-\t\t// to be uninterpreted fixed-size binary blobs--but\n-\t\t// everyone uses this convention.\n-\t\tn := 0;\n-\t\tfor n < len(pp.Path) - 3 && pp.Path[n] != 0 {\n-\t\t\tn++;\n-\t\t}\n-\t\tbytes := (*[len(pp.Path)]byte)(unsafe.Pointer(&pp.Path[0]));\n-\t\tsa.Name = string(bytes[0:n]);\n-\t\treturn sa, 0;\n-\n-\tcase AF_INET:\n-\t\tpp := (*RawSockaddrInet4)(unsafe.Pointer(rsa));\n-\t\tsa := new(SockaddrInet4);\n-\t\tp := (*[2]byte)(unsafe.Pointer(&pp.Port));\n-\t\tsa.Port = int(p[0])<<8 + int(p[1]);\n-\t\tfor i := 0; i < len(sa.Addr); i++ {\n-\t\t\tsa.Addr[i] = pp.Addr[i];\n-\t\t}\n-\t\treturn sa, 0;\n-\n-\tcase AF_INET6:\n-\t\tpp := (*RawSockaddrInet6)(unsafe.Pointer(rsa));\n-\t\tsa := new(SockaddrInet6);\n-\t\tp := (*[2]byte)(unsafe.Pointer(&pp.Port));\n-\t\tsa.Port = int(p[0])<<8 + int(p[1]);\n-\t\tfor i := 0; i < len(sa.Addr); i++ {\n-\t\t\tsa.Addr[i] = pp.Addr[i];\n-\t\t}\n-\t\treturn sa, 0;\n-\t}\n-\treturn nil, EAFNOSUPPORT;\n+type RawSockaddr struct {\n+\tFamily uint16;\n+\tData [14]int8;\n }\n \n // BindToDevice binds the socket associated with fd to device."}, {"sha": "13fe727c33ea2991ddb13c4d0d15b7dd4de251ac", "filename": "libgo/syscalls/socket_solaris.go", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsocket_solaris.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsocket_solaris.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsocket_solaris.go?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -0,0 +1,76 @@\n+// socket_solaris.go -- Socket handling specific to Solaris.\n+\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package syscall\n+\n+const SizeofSockaddrInet4 = 16\n+const SizeofSockaddrInet6 = 32\n+const SizeofSockaddrUnix = 110\n+\n+type RawSockaddrInet4 struct {\n+\tFamily uint16\n+\tPort uint16\n+\tAddr [4]byte /* in_addr */\n+\tZero [8]uint8\n+}\n+\n+func (sa *RawSockaddrInet4) setLen() Socklen_t {\n+\treturn SizeofSockaddrInet4\n+}\n+\n+type RawSockaddrInet6 struct {\n+\tFamily uint16\n+\tPort uint16\n+\tFlowinfo uint32\n+\tAddr [16]byte /* in6_addr */\n+\tScope_id uint32\n+\tSrc_id uint32\n+}\n+\n+func (sa *RawSockaddrInet6) setLen() Socklen_t {\n+\treturn SizeofSockaddrInet6\n+}\n+\n+type RawSockaddrUnix struct {\n+\tFamily uint16\n+\tPath [108]int8\n+}\n+\n+func (sa *RawSockaddrUnix) setLen(int) {\n+}\n+\n+func (sa *RawSockaddrUnix) getLen() (int, int) {\n+\tif sa.Path[0] == 0 {\n+\t\t// \"Abstract\" Unix domain socket.\n+\t\t// Rewrite leading NUL as @ for textual display.\n+\t\t// (This is the standard convention.)\n+\t\t// Not friendly to overwrite in place,\n+\t\t// but the callers below don't care.\n+\t\tsa.Path[0] = '@'\n+\t}\n+\n+\t// Assume path ends at NUL.\n+\t// This is not technically the Linux semantics for\n+\t// abstract Unix domain sockets--they are supposed\n+\t// to be uninterpreted fixed-size binary blobs--but\n+\t// everyone uses this convention.\n+\tn := 0\n+\tfor n < len(sa.Path) - 3 && sa.Path[n] != 0 {\n+\t\tn++\n+\t}\n+\n+\treturn n, 0\n+}\n+\n+type RawSockaddr struct {\n+\tFamily uint16\n+\tData [14]int8\n+}\n+\n+// BindToDevice binds the socket associated with fd to device.\n+func BindToDevice(fd int, device string) (errno int) {\n+\treturn ENOSYS\n+}"}, {"sha": "687722ddc1dacb7bbaa3201dc935f463078dd9da", "filename": "libgo/syscalls/syscall_solaris_386.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsyscall_solaris_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsyscall_solaris_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsyscall_solaris_386.go?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -8,8 +8,6 @@ package syscall\n \n import \"unsafe\"\n \n-const ARCH = \"386\"\n-\n // FIXME: ptrace(3C) has this, but exec.go expects the next.\n //func libc_ptrace(request int, pid Pid_t, addr int, data int) int __asm__ (\"ptrace\")\n "}, {"sha": "f68b596c38b706bf156d0602c9e92603866969d6", "filename": "libgo/syscalls/syscall_solaris_amd64.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsyscall_solaris_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsyscall_solaris_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsyscall_solaris_amd64.go?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -8,8 +8,6 @@ package syscall\n \n import \"unsafe\"\n \n-const ARCH = \"amd64\"\n-\n // FIXME: ptrace(3C) has this, but exec.go expects the next.\n //func libc_ptrace(request int, pid Pid_t, addr int, data int) int __asm__ (\"ptrace\")\n "}, {"sha": "408d0b8b7aa8aabfca4b1b9cf71b72d44d76999e", "filename": "libgo/syscalls/syscall_unix.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsyscall_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsyscall_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsyscall_unix.go?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -10,6 +10,11 @@ var (\n \tStderr = 2\n )\n \n+const ENONE = 0\n+\n+func GetErrno() int\n+func SetErrno(int)\n+\n func libc_uname(buf *Utsname) (errno int) __asm__(\"uname\")\n \n func Uname(buf *Utsname) (errno int) {"}, {"sha": "963a624bd88087f4dfb41974525d2c7bf99a9df9", "filename": "libgo/syscalls/sysfile_largefile.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsysfile_largefile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsysfile_largefile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsysfile_largefile.go?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -0,0 +1,13 @@\n+// sysfile_largefile.go -- For systems which use the large file interface.\n+\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package syscall\n+\n+func libc_pread(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t __asm__ (\"pread64\")\n+func libc_pwrite(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t __asm__ (\"pwrite64\")\n+func libc_lseek(int, Offset_t, int) Offset_t __asm__ (\"lseek64\")\n+func libc_truncate(path *byte, length Offset_t) int __asm__ (\"truncate64\")\n+func libc_ftruncate(fd int, length Offset_t) int __asm__ (\"ftruncate64\")"}, {"sha": "3e77e900cafd3b9671780502296d4703adf7550e", "filename": "libgo/syscalls/sysfile_linux.go", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243ffa47b314724dc9f5c0484e999243c4a25da9/libgo%2Fsyscalls%2Fsysfile_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243ffa47b314724dc9f5c0484e999243c4a25da9/libgo%2Fsyscalls%2Fsysfile_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsysfile_linux.go?ref=243ffa47b314724dc9f5c0484e999243c4a25da9", "patch": "@@ -1,38 +0,0 @@\n-// sysfile_linux.go -- Linux specific file handling.\n-\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Support for basic Unix file operations.  This file simply\n-// translates from Go data types to Unix data types, and handles\n-// errno.  FIXME: This could probably be done mechanically.\n-\n-package syscall\n-\n-const OS = \"linux\"\n-\n-func libc_pread(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t __asm__ (\"pread64\")\n-func libc_pwrite(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t __asm__ (\"pwrite64\")\n-func libc_lseek64(int, Offset_t, int) Offset_t __asm__ (\"lseek64\")\n-func libc_truncate64(path *byte, length Offset_t) int __asm__ (\"truncate64\")\n-func libc_ftruncate64(fd int, length Offset_t) int __asm__ (\"ftruncate64\")\n-func libc_setgroups(size Size_t, list *Gid_t) int __asm__ (\"setgroups\")\n-\n-func Sleep(nsec int64) (errno int) {\n-\ttv := NsecToTimeval(nsec);\n-\tn, err := Select(0, nil, nil, nil, &tv);\n-\treturn err;\n-}\n-\n-func Setgroups(gids []int) (errno int) {\n-\tif len(gids) == 0 {\n-\t\treturn libc_setgroups(0, nil);\n-\t}\n-\n-\ta := make([]Gid_t, len(gids));\n-\tfor i, v := range gids {\n-\t\ta[i] = Gid_t(v);\n-\t}\n-\treturn libc_setgroups(Size_t(len(a)), &a[0]);\n-}"}, {"sha": "1458bf56097d9f01f05b0833acf912ca1f11af78", "filename": "libgo/syscalls/sysfile_posix.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsysfile_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsysfile_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsysfile_posix.go?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -106,7 +106,7 @@ func Pwrite(fd int, p []byte, offset int64) (n int, errno int) {\n }\n \n func Seek(fd int, offset int64, whence int) (off int64, errno int) {\n-  r := libc_lseek64(fd, Offset_t(offset), whence);\n+  r := libc_lseek(fd, Offset_t(offset), whence);\n   if r == -1 { errno = GetErrno() }\n   off = int64(r);\n   return;\n@@ -300,13 +300,13 @@ func Fchown(fd int, uid int, gid int) (errno int) {\n }\n \n func Truncate(path string, length int64) (errno int) {\n-  r := libc_truncate64(StringBytePtr(path), Offset_t(length));\n+  r := libc_truncate(StringBytePtr(path), Offset_t(length));\n   if r < 0 { errno = GetErrno() }\n   return;\n }\n \n func Ftruncate(fd int, length int64) (errno int) {\n-  r := libc_ftruncate64(fd, Offset_t(length));\n+  r := libc_ftruncate(fd, Offset_t(length));\n   if r < 0 { errno = GetErrno() }\n   return;\n }"}, {"sha": "731c59c97b09609f806425ef95186b434c61bf13", "filename": "libgo/syscalls/sysfile_regfile.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsysfile_regfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cff0c39da10717bec95ae9b1d57d05645f91dea9/libgo%2Fsyscalls%2Fsysfile_regfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsysfile_regfile.go?ref=cff0c39da10717bec95ae9b1d57d05645f91dea9", "patch": "@@ -0,0 +1,13 @@\n+// sysfile_regfile.go -- For systems which do not use the large file interface.\n+\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package syscall\n+\n+func libc_pread(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t __asm__ (\"pread\")\n+func libc_pwrite(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t __asm__ (\"pwrite\")\n+func libc_lseek(int, Offset_t, int) Offset_t __asm__ (\"lseek\")\n+func libc_truncate(path *byte, length Offset_t) int __asm__ (\"truncate\")\n+func libc_ftruncate(fd int, length Offset_t) int __asm__ (\"ftruncate\")"}, {"sha": "3768b6d44a91d9397a86b11c560a4c6752e3ac75", "filename": "libgo/syscalls/sysfile_rtems.go", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243ffa47b314724dc9f5c0484e999243c4a25da9/libgo%2Fsyscalls%2Fsysfile_rtems.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243ffa47b314724dc9f5c0484e999243c4a25da9/libgo%2Fsyscalls%2Fsysfile_rtems.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsysfile_rtems.go?ref=243ffa47b314724dc9f5c0484e999243c4a25da9", "patch": "@@ -1,34 +0,0 @@\n-// sysfile_rtems.go -- RTEMS specific file handling.\n-\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Support for basic Unix file operations.  This file simply\n-// translates from Go data types to Unix data types, and handles\n-// errno.  FIXME: This could probably be done mechanically.\n-\n-package syscall\n-\n-const (\n-\tOS = \"rtems\"\n-\t// No support for async I/O in RTEMS.\n-\tO_ASYNC = 0\n-)\n-\n-func libc_pread(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t __asm__ (\"pread\")\n-func libc_pwrite(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t __asm__ (\"pwrite\")\n-func libc_lseek64(int, Offset_t, int) Offset_t __asm__ (\"lseek\")\n-func libc_truncate64(path *byte, length Offset_t) int __asm__ (\"truncate\")\n-func libc_ftruncate64(fd int, length Offset_t) int __asm__ (\"ftruncate\")\n-func libc_nanosleep(req *Timespec, rem *Timespec) int __asm__ (\"nanosleep\")\n-\n-func Sleep(nsec int64) (errno int) {\n-\terrno = 0\n-\tts := NsecToTimespec(nsec)\n-\tr := libc_nanosleep(&ts, nil)\n-\tif r < 0 {\n-\t\terrno = GetErrno()\n-\t}\n-\treturn\n-}"}]}