{"sha": "09411461d2e1d7dfcc3aed713bddc68e34ba223d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk0MTE0NjFkMmUxZDdkZmNjM2FlZDcxM2JkZGM2OGUzNGJhMjIzZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-07-08T16:46:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-07-08T16:46:49Z"}, "message": "cgraph.c (cgraph_will_be_removed_from_program_if_no_direct_calls): New function.\n\n\n\t* cgraph.c (cgraph_will_be_removed_from_program_if_no_direct_calls):\n\tNew function.\n\t* cgraph.h (cgraph_will_be_removed_from_program_if_no_direct_calls):\n\tDeclare.\n\t* ipa-cp.c (ipcp_estimate_growth): Use it.\n\t* ipa-inline.c (cgraph_estimate_growth, cgraph_decide_inlining):\n\tLikewise.\n\nFrom-SVN: r161966", "tree": {"sha": "bc5d1a43aa025755bcaa3455dd75d5fff8fd479a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc5d1a43aa025755bcaa3455dd75d5fff8fd479a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09411461d2e1d7dfcc3aed713bddc68e34ba223d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09411461d2e1d7dfcc3aed713bddc68e34ba223d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09411461d2e1d7dfcc3aed713bddc68e34ba223d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09411461d2e1d7dfcc3aed713bddc68e34ba223d/comments", "author": null, "committer": null, "parents": [{"sha": "72109b25534c8471768fa2765bebe7c62420e059", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72109b25534c8471768fa2765bebe7c62420e059", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72109b25534c8471768fa2765bebe7c62420e059"}], "stats": {"total": 49, "additions": 43, "deletions": 6}, "files": [{"sha": "8d5962d2500053f13335f2dc19460b9fca61fa68", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09411461d2e1d7dfcc3aed713bddc68e34ba223d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09411461d2e1d7dfcc3aed713bddc68e34ba223d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09411461d2e1d7dfcc3aed713bddc68e34ba223d", "patch": "@@ -1,3 +1,13 @@\n+2010-07-08  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_will_be_removed_from_program_if_no_direct_calls):\n+\tNew function.\n+\t* cgraph.h (cgraph_will_be_removed_from_program_if_no_direct_calls):\n+\tDeclare.\n+\t* ipa-cp.c (ipcp_estimate_growth): Use it.\n+\t* ipa-inline.c (cgraph_estimate_growth, cgraph_decide_inlining):\n+\tLikewise.\n+\n 2010-07-08  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-inline.c (declare_return_variable): Allocate annotation for new"}, {"sha": "fff437a626528bfb1a515ae98f284a1b4d2a9240", "filename": "gcc/cgraph.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09411461d2e1d7dfcc3aed713bddc68e34ba223d/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09411461d2e1d7dfcc3aed713bddc68e34ba223d/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=09411461d2e1d7dfcc3aed713bddc68e34ba223d", "patch": "@@ -2651,4 +2651,29 @@ cgraph_edge_cannot_lead_to_return (struct cgraph_edge *e)\n     return cgraph_node_cannot_return (e->callee);\n }\n \n+/* Return true when function NODE can be excpected to be removed\n+   from program when direct calls in this compilation unit are removed.\n+\n+   As a special case COMDAT functions are\n+   cgraph_can_remove_if_no_direct_calls_p while the are not\n+   cgraph_only_called_directly_p (it is possible they are called from other\n+   unit)\n+\n+   This function behaves as cgraph_only_called_directly_p because eliminating\n+   all uses of COMDAT function does not make it neccesarily disappear from\n+   the program unless we are compiling whole program or we do LTO.  In this\n+   case we know we win since dynamic linking will not really discard the\n+   linkonce section.  */\n+\n+bool\n+cgraph_will_be_removed_from_program_if_no_direct_calls (struct cgraph_node *node)\n+{\n+  if (node->local.used_from_object_file)\n+    return false;\n+  if (!in_lto_p && !flag_whole_program)\n+    return cgraph_only_called_directly_p (node);\n+  else\n+    return cgraph_can_remove_if_no_direct_calls_p (node);\n+}\n+\n #include \"gt-cgraph.h\""}, {"sha": "2dcdf2f22f3d0c3d704efa55b94bbd5e63a93804", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09411461d2e1d7dfcc3aed713bddc68e34ba223d/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09411461d2e1d7dfcc3aed713bddc68e34ba223d/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=09411461d2e1d7dfcc3aed713bddc68e34ba223d", "patch": "@@ -664,6 +664,8 @@ void cgraph_remove_node_duplication_hook (struct cgraph_2node_hook_list *);\n void cgraph_materialize_all_clones (void);\n gimple cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *);\n bool cgraph_propagate_frequency (struct cgraph_node *node);\n+bool cgraph_will_be_removed_from_program_if_no_direct_calls\n+  (struct cgraph_node *node);\n /* In cgraphbuild.c  */\n unsigned int rebuild_cgraph_edges (void);\n void cgraph_rebuild_references (void);"}, {"sha": "be1956962a8cf13c1e3ff5b65bfbee0ba728f332", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09411461d2e1d7dfcc3aed713bddc68e34ba223d/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09411461d2e1d7dfcc3aed713bddc68e34ba223d/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=09411461d2e1d7dfcc3aed713bddc68e34ba223d", "patch": "@@ -951,7 +951,8 @@ ipcp_estimate_growth (struct cgraph_node *node)\n   struct cgraph_edge *cs;\n   int redirectable_node_callers = 0;\n   int removable_args = 0;\n-  bool need_original = !cgraph_only_called_directly_p (node);\n+  bool need_original\n+     = !cgraph_will_be_removed_from_program_if_no_direct_calls (node);\n   struct ipa_node_params *info;\n   int i, count;\n   int growth;\n@@ -1134,7 +1135,7 @@ ipcp_insert_stage (void)\n       for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n \tif (cs->caller == node || ipcp_need_redirect_p (cs))\n \t  break;\n-      if (!cs && cgraph_only_called_directly_p (node))\n+      if (!cs && cgraph_will_be_removed_from_program_if_no_direct_calls (node))\n \tbitmap_set_bit (dead_nodes, node->uid);\n \n       info = IPA_NODE_REF (node);"}, {"sha": "e65c6968ab4de78208167653252565da9d818a9e", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09411461d2e1d7dfcc3aed713bddc68e34ba223d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09411461d2e1d7dfcc3aed713bddc68e34ba223d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=09411461d2e1d7dfcc3aed713bddc68e34ba223d", "patch": "@@ -389,7 +389,7 @@ cgraph_estimate_growth (struct cgraph_node *node)\n      we decide to not inline for different reasons, but it is not big deal\n      as in that case we will keep the body around, but we will also avoid\n      some inlining.  */\n-  if (cgraph_only_called_directly_p (node)\n+  if (cgraph_will_be_removed_from_program_if_no_direct_calls (node)\n       && !DECL_EXTERNAL (node->decl) && !self_recursive)\n     growth -= node->global.size;\n \n@@ -1496,14 +1496,13 @@ cgraph_decide_inlining (void)\n \n \t  if (node->callers\n \t      && !node->callers->next_caller\n-\t      && cgraph_only_called_directly_p (node)\n+\t      && cgraph_will_be_removed_from_program_if_no_direct_calls (node)\n \t      && node->local.inlinable\n \t      && node->callers->inline_failed\n \t      && node->callers->caller != node\n \t      && node->callers->caller->global.inlined_to != node\n \t      && !node->callers->call_stmt_cannot_inline_p\n-\t      && !DECL_EXTERNAL (node->decl)\n-\t      && !DECL_COMDAT (node->decl))\n+\t      && !DECL_EXTERNAL (node->decl))\n \t    {\n \t      cgraph_inline_failed_t reason;\n \t      old_size = overall_size;"}]}