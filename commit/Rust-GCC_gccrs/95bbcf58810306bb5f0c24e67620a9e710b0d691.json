{"sha": "95bbcf58810306bb5f0c24e67620a9e710b0d691", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTViYmNmNTg4MTAzMDZiYjVmMGMyNGU2NzYyMGE5ZTcxMGIwZDY5MQ==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2017-02-12T00:57:21Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2017-02-12T00:57:21Z"}, "message": "cpp.texi: Replace \"stringify\"/\"stringification\" with C standard terminology...\n\n2017-02-11  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tgcc/\n\t* doc/cpp.texi: Replace \"stringify\"/\"stringification\" with C \n\tstandard terminology \"stringize\"/\"stringizing\" throughout.\n\t* doc/cppinternals.texi: Likewise.\n\nFrom-SVN: r245371", "tree": {"sha": "9308f9e898f9a7c07db466fe610bec625578f1a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9308f9e898f9a7c07db466fe610bec625578f1a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95bbcf58810306bb5f0c24e67620a9e710b0d691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95bbcf58810306bb5f0c24e67620a9e710b0d691", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95bbcf58810306bb5f0c24e67620a9e710b0d691", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95bbcf58810306bb5f0c24e67620a9e710b0d691/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7b65f47719b4dd60c63eca8f90e9821024b32fc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b65f47719b4dd60c63eca8f90e9821024b32fc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b65f47719b4dd60c63eca8f90e9821024b32fc6"}], "stats": {"total": 74, "additions": 40, "deletions": 34}, "files": [{"sha": "c58cfa53732ee11266fd9f8a210698b5fc3a189b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bbcf58810306bb5f0c24e67620a9e710b0d691/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bbcf58810306bb5f0c24e67620a9e710b0d691/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95bbcf58810306bb5f0c24e67620a9e710b0d691", "patch": "@@ -1,3 +1,9 @@\n+2017-02-11  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\t* doc/cpp.texi: Replace \"stringify\"/\"stringification\" with C \n+\tstandard terminology \"stringize\"/\"stringizing\" throughout.\n+\t* doc/cppinternals.texi: Likewise.\n+\n 2017-02-11  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* doc/extend.texi: Fix some spelling mistakes and typos."}, {"sha": "6e16ffb0e6536053f1fafd1c12483c2388f4fef7", "filename": "gcc/doc/cpp.texi", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bbcf58810306bb5f0c24e67620a9e710b0d691/gcc%2Fdoc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bbcf58810306bb5f0c24e67620a9e710b0d691/gcc%2Fdoc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcpp.texi?ref=95bbcf58810306bb5f0c24e67620a9e710b0d691", "patch": "@@ -119,7 +119,7 @@ Macros\n * Object-like Macros::\n * Function-like Macros::\n * Macro Arguments::\n-* Stringification::\n+* Stringizing::\n * Concatenation::\n * Variadic Macros::\n * Predefined Macros::\n@@ -1155,7 +1155,7 @@ macros when you are compiling C++.\n * Object-like Macros::\n * Function-like Macros::\n * Macro Arguments::\n-* Stringification::\n+* Stringizing::\n * Concatenation::\n * Variadic Macros::\n * Predefined Macros::\n@@ -1453,9 +1453,9 @@ their corresponding actual arguments.\n foo(bar)        @expansion{} bar, \"x\"\n @end smallexample\n \n-@node Stringification\n-@section Stringification\n-@cindex stringification\n+@node Stringizing\n+@section Stringizing\n+@cindex stringizing\n @cindex @samp{#} operator\n \n Sometimes you may want to convert a macro argument into a string\n@@ -1464,16 +1464,16 @@ can use the @samp{#} preprocessing operator instead.  When a macro\n parameter is used with a leading @samp{#}, the preprocessor replaces it\n with the literal text of the actual argument, converted to a string\n constant.  Unlike normal parameter replacement, the argument is not\n-macro-expanded first.  This is called @dfn{stringification}.\n+macro-expanded first.  This is called @dfn{stringizing}.\n \n There is no way to combine an argument with surrounding text and\n-stringify it all together.  Instead, you can write a series of adjacent\n-string constants and stringified arguments.  The preprocessor will\n-replace the stringified arguments with string constants.  The C\n-compiler will then combine all the adjacent string constants into one\n+stringize it all together.  Instead, you can write a series of adjacent\n+string constants and stringized arguments.  The preprocessor\n+replaces the stringized arguments with string constants.  The C\n+compiler then combines all the adjacent string constants into one\n long string.\n \n-Here is an example of a macro definition that uses stringification:\n+Here is an example of a macro definition that uses stringizing:\n \n @smallexample\n @group\n@@ -1489,7 +1489,7 @@ WARN_IF (x == 0);\n \n @noindent\n The argument for @code{EXP} is substituted once, as-is, into the\n-@code{if} statement, and once, stringified, into the argument to\n+@code{if} statement, and once, stringized, into the argument to\n @code{fprintf}.  If @code{x} were a macro, it would be expanded in the\n @code{if} statement, but not in the string.\n \n@@ -1498,24 +1498,24 @@ write @code{WARN_IF (@var{arg});}, which the resemblance of\n @code{WARN_IF} to a function would make C programmers want to do; see\n @ref{Swallowing the Semicolon}.\n \n-Stringification in C involves more than putting double-quote characters\n+Stringizing in C involves more than putting double-quote characters\n around the fragment.  The preprocessor backslash-escapes the quotes\n surrounding embedded string constants, and all backslashes within string and\n character constants, in order to get a valid C string constant with the\n-proper contents.  Thus, stringifying @code{@w{p = \"foo\\n\";}} results in\n+proper contents.  Thus, stringizing @code{@w{p = \"foo\\n\";}} results in\n @t{@w{\"p = \\\"foo\\\\n\\\";\"}}.  However, backslashes that are not inside string\n or character constants are not duplicated: @samp{\\n} by itself\n-stringifies to @t{\"\\n\"}.\n+stringizes to @t{\"\\n\"}.\n \n-All leading and trailing whitespace in text being stringified is\n+All leading and trailing whitespace in text being stringized is\n ignored.  Any sequence of whitespace in the middle of the text is\n-converted to a single space in the stringified result.  Comments are\n-replaced by whitespace long before stringification happens, so they\n-never appear in stringified text.\n+converted to a single space in the stringized result.  Comments are\n+replaced by whitespace long before stringizing happens, so they\n+never appear in stringized text.\n \n There is no way to convert a macro argument into a character constant.\n \n-If you want to stringify the result of expansion of a macro argument,\n+If you want to stringize the result of expansion of a macro argument,\n you have to use two levels of macros.\n \n @smallexample\n@@ -1530,7 +1530,7 @@ xstr (foo)\n      @expansion{} \"4\"\n @end smallexample\n \n-@code{s} is stringified when it is used in @code{str}, so it is not\n+@code{s} is stringized when it is used in @code{str}, so it is not\n macro-expanded first.  But @code{s} is an ordinary argument to\n @code{xstr}, so it is completely macro-expanded before @code{xstr}\n itself is expanded (@pxref{Argument Prescan}).  Therefore, by the time\n@@ -1569,7 +1569,7 @@ but you could just as well write them as one token in the first place.\n Token pasting is most useful when one or both of the tokens comes from a\n macro argument.  If either of the tokens next to an @samp{##} is a\n parameter name, it is replaced by its actual argument before @samp{##}\n-executes.  As with stringification, the actual argument is not\n+executes.  As with stringizing, the actual argument is not\n macro-expanded first.  If the argument is empty, that @samp{##} has no\n effect.\n \n@@ -1607,7 +1607,7 @@ struct command commands[] =\n It would be cleaner not to have to give each command name twice, once in\n the string constant and once in the function name.  A macro which takes the\n name of a command as an argument can make this unnecessary.  The string\n-constant can be created with stringification, and the function name by\n+constant can be created with stringizing, and the function name by\n concatenating the argument with @samp{_command}.  Here is how it is done:\n \n @smallexample\n@@ -1649,7 +1649,7 @@ eprintf (\"%s:%d: \", input_file, lineno)\n \n The variable argument is completely macro-expanded before it is inserted\n into the macro expansion, just like an ordinary argument.  You may use\n-the @samp{#} and @samp{##} operators to stringify the variable argument\n+the @samp{#} and @samp{##} operators to stringize the variable argument\n or to paste its leading or trailing token with another token.  (But see\n below for an important special case for @samp{##}.)\n \n@@ -2912,7 +2912,7 @@ macro, but not when it indirectly appears in its own definition.\n @cindex prescan of macro arguments\n \n Macro arguments are completely macro-expanded before they are\n-substituted into a macro body, unless they are stringified or pasted\n+substituted into a macro body, unless they are stringized or pasted\n with other tokens.  After substitution, the entire macro body, including\n the substituted arguments, is scanned again for macros to be expanded.\n The result is that the arguments are scanned @emph{twice} to expand\n@@ -2952,12 +2952,12 @@ appear during the main scan as an indirect self-reference and would not\n be expanded.\n \n @item\n-Macros that call other macros that stringify or concatenate.\n+Macros that call other macros that stringize or concatenate.\n \n-If an argument is stringified or concatenated, the prescan does not\n-occur.  If you @emph{want} to expand a macro, then stringify or\n+If an argument is stringized or concatenated, the prescan does not\n+occur.  If you @emph{want} to expand a macro, then stringize or\n concatenate its expansion, you can do that by causing one macro to call\n-another macro that does the stringification or concatenation.  For\n+another macro that does the stringizing or concatenation.  For\n instance, if you have\n \n @smallexample\n@@ -3830,7 +3830,7 @@ implementation removes comments even before saving the macro\n replacement text, but it careful to do it in such a way that the\n observed effect is identical even in the function-like macro case.)\n \n-The ISO stringification operator @samp{#} and token paste operator\n+The ISO stringizing operator @samp{#} and token paste operator\n @samp{##} have no special meaning.  As explained later, an effect\n similar to these operators can be obtained in a different way.  Macro\n names that are embedded in quotes, either from the main file or after"}, {"sha": "94de21b41c91420381659281d4fcc47004672484", "filename": "gcc/doc/cppinternals.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95bbcf58810306bb5f0c24e67620a9e710b0d691/gcc%2Fdoc%2Fcppinternals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95bbcf58810306bb5f0c24e67620a9e710b0d691/gcc%2Fdoc%2Fcppinternals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcppinternals.texi?ref=95bbcf58810306bb5f0c24e67620a9e710b0d691", "patch": "@@ -203,7 +203,7 @@ error about an unterminated macro argument list.\n \n The C standard also specifies that a new line in the middle of the\n arguments to a macro is treated as whitespace.  This white space is\n-important in case the macro argument is stringified.  The state variable\n+important in case the macro argument is stringized.  The state variable\n @code{parsing_args} is nonzero when the preprocessor is collecting the\n arguments to a macro call.  It is set to 1 when looking for the opening\n parenthesis to a function-like macro, and 2 when collecting the actual\n@@ -374,7 +374,7 @@ the pointers to the tokens of its expansion that are returned will always\n remain valid.  However, macros are a little trickier than that, since\n they give rise to three sources of fresh tokens.  They are the built-in\n macros like @code{__LINE__}, and the @samp{#} and @samp{##} operators\n-for stringification and token pasting.  I handled this by allocating\n+for stringizing and token pasting.  I handled this by allocating\n space for these tokens from the lexer's token run chain.  This means\n they automatically receive the same lifetime guarantees as lexed tokens,\n and we don't need to concern ourselves with freeing them.\n@@ -478,7 +478,7 @@ ways.\n I strongly recommend you have a good grasp of how the C and C++\n standards require macros to be expanded before diving into this\n section, let alone the code!.  If you don't have a clear mental\n-picture of how things like nested macro expansion, stringification and\n+picture of how things like nested macro expansion, stringizing and\n token pasting are supposed to work, damage to your sanity can quickly\n result.\n \n@@ -744,7 +744,7 @@ We would then have it take its spacing from the first of these, which\n carries source token @samp{foo} with no leading space.\n \n It is vital that cpplib get spacing correct in these examples since any\n-of these macro expansions could be stringified, where spacing matters.\n+of these macro expansions could be stringized, where spacing matters.\n \n So, this demonstrates that not just entering macro and argument\n expansions, but leaving them requires special handling too.  I made"}]}