{"sha": "b2e25729e5a4b93e4c022815f19a43e4ae01f11e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJlMjU3MjllNWE0YjkzZTRjMDIyODE1ZjE5YTQzZTRhZTAxZjExZQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2012-01-11T16:52:03Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-01-11T16:52:03Z"}, "message": "re PR tree-optimization/49642 (constant part of a macro not optimized away as expected due to splitter)\n\ngcc:\n\n2012-01-11  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/49642\n\t* ipa-split.c (forbidden_dominators): New variable.\n\t(check_forbidden_calls): New function.\n\t(dominated_by_forbidden): Likewise.\n\t(consider_split): Check for forbidden dominators.\n\t(execute_split_functions): Initialize and free forbidden\n\tdominators info; call check_forbidden_calls.\n\ngcc/testsuite:\n\n2012-01-11  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/49642\n\t* gcc.dg/tree-ssa/pr49642-1.c: New test.\n\t* gcc.dg/tree-ssa/pr49642-2.c: New test.\n\nFrom-SVN: r183101", "tree": {"sha": "508cd0669229c48e3d51b8e8e5dcac0f4d4d9a05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/508cd0669229c48e3d51b8e8e5dcac0f4d4d9a05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2e25729e5a4b93e4c022815f19a43e4ae01f11e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2e25729e5a4b93e4c022815f19a43e4ae01f11e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2e25729e5a4b93e4c022815f19a43e4ae01f11e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2e25729e5a4b93e4c022815f19a43e4ae01f11e/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "276fd9acf007cc9e9251ca8808c7e1ff3a96d52e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/276fd9acf007cc9e9251ca8808c7e1ff3a96d52e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/276fd9acf007cc9e9251ca8808c7e1ff3a96d52e"}], "stats": {"total": 215, "additions": 215, "deletions": 0}, "files": [{"sha": "893eb209dbec3a819a353ef34a39434ff1f6d6d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2e25729e5a4b93e4c022815f19a43e4ae01f11e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2e25729e5a4b93e4c022815f19a43e4ae01f11e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b2e25729e5a4b93e4c022815f19a43e4ae01f11e", "patch": "@@ -1,3 +1,13 @@\n+2012-01-11  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/49642\n+\t* ipa-split.c (forbidden_dominators): New variable.\n+\t(check_forbidden_calls): New function.\n+\t(dominated_by_forbidden): Likewise.\n+\t(consider_split): Check for forbidden dominators.\n+\t(execute_split_functions): Initialize and free forbidden\n+\tdominators info; call check_forbidden_calls.\n+\n 2012-01-11  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>\n \n \t* config/arm/arm.md (mov_notscc): Use MVN for false condition."}, {"sha": "6195f819ec5ffed426628f079c038234f7d30879", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2e25729e5a4b93e4c022815f19a43e4ae01f11e/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2e25729e5a4b93e4c022815f19a43e4ae01f11e/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=b2e25729e5a4b93e4c022815f19a43e4ae01f11e", "patch": "@@ -131,6 +131,10 @@ struct split_point\n \n struct split_point best_split_point;\n \n+/* Set of basic blocks that are not allowed to dominate a split point.  */\n+\n+static bitmap forbidden_dominators;\n+\n static tree find_retval (basic_block return_bb);\n \n /* Callback for walk_stmt_load_store_addr_ops.  If T is non-SSA automatic\n@@ -272,6 +276,83 @@ verify_non_ssa_vars (struct split_point *current, bitmap non_ssa_vars,\n   return ok;\n }\n \n+/* If STMT is a call, check the callee against a list of forbidden\n+   predicate functions.  If a match is found, look for uses of the\n+   call result in condition statements that compare against zero.\n+   For each such use, find the block targeted by the condition\n+   statement for the nonzero result, and set the bit for this block\n+   in the forbidden dominators bitmap.  The purpose of this is to avoid\n+   selecting a split point where we are likely to lose the chance\n+   to optimize away an unused function call.  */\n+\n+static void\n+check_forbidden_calls (gimple stmt)\n+{\n+  imm_use_iterator use_iter;\n+  use_operand_p use_p;\n+  tree lhs;\n+\n+  /* At the moment, __builtin_constant_p is the only forbidden\n+     predicate function call (see PR49642).  */\n+  if (!gimple_call_builtin_p (stmt, BUILT_IN_CONSTANT_P))\n+    return;\n+\n+  lhs = gimple_call_lhs (stmt);\n+\n+  if (!lhs || TREE_CODE (lhs) != SSA_NAME)\n+    return;\n+\n+  FOR_EACH_IMM_USE_FAST (use_p, use_iter, lhs)\n+    {\n+      tree op1;\n+      basic_block use_bb, forbidden_bb;\n+      enum tree_code code;\n+      edge true_edge, false_edge;\n+      gimple use_stmt = USE_STMT (use_p);\n+\n+      if (gimple_code (use_stmt) != GIMPLE_COND)\n+\tcontinue;\n+\n+      /* Assuming canonical form for GIMPLE_COND here, with constant\n+\t in second position.  */\n+      op1 = gimple_cond_rhs (use_stmt);\n+      code = gimple_cond_code (use_stmt);\n+      use_bb = gimple_bb (use_stmt);\n+\n+      extract_true_false_edges_from_block (use_bb, &true_edge, &false_edge);\n+\n+      /* We're only interested in comparisons that distinguish\n+\t unambiguously from zero.  */\n+      if (!integer_zerop (op1) || code == LE_EXPR || code == GE_EXPR)\n+\tcontinue;\n+\n+      if (code == EQ_EXPR)\n+\tforbidden_bb = false_edge->dest;\n+      else\n+\tforbidden_bb = true_edge->dest;\n+\n+      bitmap_set_bit (forbidden_dominators, forbidden_bb->index);\n+    }\n+}\n+\n+/* If BB is dominated by any block in the forbidden dominators set,\n+   return TRUE; else FALSE.  */\n+\n+static bool\n+dominated_by_forbidden (basic_block bb)\n+{\n+  unsigned dom_bb;\n+  bitmap_iterator bi;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (forbidden_dominators, 1, dom_bb, bi)\n+    {\n+      if (dominated_by_p (CDI_DOMINATORS, bb, BASIC_BLOCK (dom_bb)))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* We found an split_point CURRENT.  NON_SSA_VARS is bitmap of all non ssa\n    variables used and RETURN_BB is return basic block.\n    See if we can split function here.  */\n@@ -413,6 +494,18 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n \t\t \"  Refused: split part has non-ssa uses\\n\");\n       return;\n     }\n+\n+  /* If the split point is dominated by a forbidden block, reject\n+     the split.  */\n+  if (!bitmap_empty_p (forbidden_dominators)\n+      && dominated_by_forbidden (current->entry_bb))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"  Refused: split point dominated by forbidden block\\n\");\n+      return;\n+    }\n+\n   /* See if retval used by return bb is computed by header or split part.\n      When it is computed by split part, we need to produce return statement\n      in the split part and add code to header to pass it around.\n@@ -1372,6 +1465,10 @@ execute_split_functions (void)\n       return 0;\n     }\n \n+  /* Initialize bitmap to track forbidden calls.  */\n+  forbidden_dominators = BITMAP_ALLOC (NULL);\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n   /* Compute local info about basic blocks and determine function size/time.  */\n   VEC_safe_grow_cleared (bb_info, heap, bb_info_vec, last_basic_block + 1);\n   memset (&best_split_point, 0, sizeof (best_split_point));\n@@ -1393,6 +1490,7 @@ execute_split_functions (void)\n \t  this_time = estimate_num_insns (stmt, &eni_time_weights) * freq;\n \t  size += this_size;\n \t  time += this_time;\n+\t  check_forbidden_calls (stmt);\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n@@ -1414,6 +1512,7 @@ execute_split_functions (void)\n       BITMAP_FREE (best_split_point.split_bbs);\n       todo = TODO_update_ssa | TODO_cleanup_cfg;\n     }\n+  BITMAP_FREE (forbidden_dominators);\n   VEC_free (bb_info, heap, bb_info_vec);\n   bb_info_vec = NULL;\n   return todo;"}, {"sha": "b0f24a3fd90ad4e765f9f5b768f72071bf4eca20", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2e25729e5a4b93e4c022815f19a43e4ae01f11e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2e25729e5a4b93e4c022815f19a43e4ae01f11e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b2e25729e5a4b93e4c022815f19a43e4ae01f11e", "patch": "@@ -1,3 +1,9 @@\n+2012-01-11  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/49642\n+\t* gcc.dg/tree-ssa/pr49642-1.c: New test.\n+\t* gcc.dg/tree-ssa/pr49642-2.c: New test.\n+\n 2012-01-11  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/51613"}, {"sha": "65a0b128a94e7de38483e7d6729d1b0418e52745", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr49642-1.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2e25729e5a4b93e4c022815f19a43e4ae01f11e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr49642-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2e25729e5a4b93e4c022815f19a43e4ae01f11e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr49642-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr49642-1.c?ref=b2e25729e5a4b93e4c022815f19a43e4ae01f11e", "patch": "@@ -0,0 +1,49 @@\n+/* Verify that ipa-split is disabled following __builtin_constant_p.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+typedef unsigned int u32;\n+typedef unsigned long long u64;\n+\n+static inline __attribute__((always_inline)) __attribute__((const))\n+int __ilog2_u32(u32 n)\n+{\n+ int bit;\n+ asm (\"cntlzw %0,%1\" : \"=r\" (bit) : \"r\" (n));\n+ return 31 - bit;\n+}\n+\n+\n+static inline __attribute__((always_inline)) __attribute__((const))\n+int __ilog2_u64(u64 n)\n+{\n+ int bit;\n+ asm (\"cntlzd %0,%1\" : \"=r\" (bit) : \"r\" (n));\n+ return 63 - bit;\n+}\n+\n+\n+\n+static u64 ehca_map_vaddr(void *caddr);\n+\n+struct ehca_shca {\n+        u32 hca_cap_mr_pgsize;\n+};\n+\n+static u64 ehca_get_max_hwpage_size(struct ehca_shca *shca)\n+{\n+ return 1UL << ( __builtin_constant_p(shca->hca_cap_mr_pgsize) ? ( (shca->hca_cap_mr_pgsize) < 1 ? ____ilog2_NaN() : (shca->hca_cap_mr_pgsize) & (1ULL << 63) ? 63 : (shca->hca_cap_mr_pgsize) & (1ULL << 62) ? 62 : (shca->hca_cap_mr_pgsize) & (1ULL << 61) ? 61 : (shca->hca_cap_mr_pgsize) & (1ULL << 60) ? 60 : (shca->hca_cap_mr_pgsize) & (1ULL << 59) ? 59 : (shca->hca_cap_mr_pgsize) & (1ULL << 58) ? 58 : (shca->hca_cap_mr_pgsize) & (1ULL << 57) ? 57 : (shca->hca_cap_mr_pgsize) & (1ULL << 56) ? 56 : (shca->hca_cap_mr_pgsize) & (1ULL << 55) ? 55 : (shca->hca_cap_mr_pgsize) & (1ULL << 54) ? 54 : (shca->hca_cap_mr_pgsize) & (1ULL << 53) ? 53 : (shca->hca_cap_mr_pgsize) & (1ULL << 52) ? 52 : (shca->hca_cap_mr_pgsize) & (1ULL << 51) ? 51 : (shca->hca_cap_mr_pgsize) & (1ULL << 50) ? 50 : (shca->hca_cap_mr_pgsize) & (1ULL << 49) ? 49 : (shca->hca_cap_mr_pgsize) & (1ULL << 48) ? 48 : (shca->hca_cap_mr_pgsize) & (1ULL << 47) ? 47 : (shca->hca_cap_mr_pgsize) & (1ULL << 46) ? 46 : (shca->hca_cap_mr_pgsize) & (1ULL << 45) ? 45 : (shca->hca_cap_mr_pgsize) & (1ULL << 44) ? 44 : (shca->hca_cap_mr_pgsize) & (1ULL << 43) ? 43 : (shca->hca_cap_mr_pgsize) & (1ULL << 42) ? 42 : (shca->hca_cap_mr_pgsize) & (1ULL << 41) ? 41 : (shca->hca_cap_mr_pgsize) & (1ULL << 40) ? 40 : (shca->hca_cap_mr_pgsize) & (1ULL << 39) ? 39 : (shca->hca_cap_mr_pgsize) & (1ULL << 38) ? 38 : (shca->hca_cap_mr_pgsize) & (1ULL << 37) ? 37 : (shca->hca_cap_mr_pgsize) & (1ULL << 36) ? 36 : (shca->hca_cap_mr_pgsize) & (1ULL << 35) ? 35 : (shca->hca_cap_mr_pgsize) & (1ULL << 34) ? 34 : (shca->hca_cap_mr_pgsize) & (1ULL << 33) ? 33 : (shca->hca_cap_mr_pgsize) & (1ULL << 32) ? 32 : (shca->hca_cap_mr_pgsize) & (1ULL << 31) ? 31 : (shca->hca_cap_mr_pgsize) & (1ULL << 30) ? 30 : (shca->hca_cap_mr_pgsize) & (1ULL << 29) ? 29 : (shca->hca_cap_mr_pgsize) & (1ULL << 28) ? 28 : (shca->hca_cap_mr_pgsize) & (1ULL << 27) ? 27 : (shca->hca_cap_mr_pgsize) & (1ULL << 26) ? 26 : (shca->hca_cap_mr_pgsize) & (1ULL << 25) ? 25 : (shca->hca_cap_mr_pgsize) & (1ULL << 24) ? 24 : (shca->hca_cap_mr_pgsize) & (1ULL << 23) ? 23 : (shca->hca_cap_mr_pgsize) & (1ULL << 22) ? 22 : (shca->hca_cap_mr_pgsize) & (1ULL << 21) ? 21 : (shca->hca_cap_mr_pgsize) & (1ULL << 20) ? 20 : (shca->hca_cap_mr_pgsize) & (1ULL << 19) ? 19 : (shca->hca_cap_mr_pgsize) & (1ULL << 18) ? 18 : (shca->hca_cap_mr_pgsize) & (1ULL << 17) ? 17 : (shca->hca_cap_mr_pgsize) & (1ULL << 16) ? 16 : (shca->hca_cap_mr_pgsize) & (1ULL << 15) ? 15 : (shca->hca_cap_mr_pgsize) & (1ULL << 14) ? 14 : (shca->hca_cap_mr_pgsize) & (1ULL << 13) ? 13 : (shca->hca_cap_mr_pgsize) & (1ULL << 12) ? 12 : (shca->hca_cap_mr_pgsize) & (1ULL << 11) ? 11 : (shca->hca_cap_mr_pgsize) & (1ULL << 10) ? 10 : (shca->hca_cap_mr_pgsize) & (1ULL << 9) ? 9 : (shca->hca_cap_mr_pgsize) & (1ULL << 8) ? 8 : (shca->hca_cap_mr_pgsize) & (1ULL << 7) ? 7 : (shca->hca_cap_mr_pgsize) & (1ULL << 6) ? 6 : (shca->hca_cap_mr_pgsize) & (1ULL << 5) ? 5 : (shca->hca_cap_mr_pgsize) & (1ULL << 4) ? 4 : (shca->hca_cap_mr_pgsize) & (1ULL << 3) ? 3 : (shca->hca_cap_mr_pgsize) & (1ULL << 2) ? 2 : (shca->hca_cap_mr_pgsize) & (1ULL << 1) ? 1 : (shca->hca_cap_mr_pgsize) & (1ULL << 0) ? 0 : ____ilog2_NaN() ) : (sizeof(shca->hca_cap_mr_pgsize) <= 4) ? __ilog2_u32(shca->hca_cap_mr_pgsize) : __ilog2_u64(shca->hca_cap_mr_pgsize) );\n+}\n+\n+int x(struct ehca_shca *shca) {\n+        return ehca_get_max_hwpage_size(shca);\n+}\n+\n+int y(struct ehca_shca *shca)\n+{\n+        return ehca_get_max_hwpage_size(shca);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"____ilog2_NaN\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "c96a87a4015ac3e003c0e460ac8b85dcabd60645", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr49642-2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2e25729e5a4b93e4c022815f19a43e4ae01f11e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr49642-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2e25729e5a4b93e4c022815f19a43e4ae01f11e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr49642-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr49642-2.c?ref=b2e25729e5a4b93e4c022815f19a43e4ae01f11e", "patch": "@@ -0,0 +1,51 @@\n+/* Verify that ipa-split is disabled following __builtin_constant_p.\n+   Same as pr49642-1.c, but we turn off FRE which currently masks\n+   the problem.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fno-tree-fre\" } */\n+\n+typedef unsigned int u32;\n+typedef unsigned long long u64;\n+\n+static inline __attribute__((always_inline)) __attribute__((const))\n+int __ilog2_u32(u32 n)\n+{\n+ int bit;\n+ asm (\"cntlzw %0,%1\" : \"=r\" (bit) : \"r\" (n));\n+ return 31 - bit;\n+}\n+\n+\n+static inline __attribute__((always_inline)) __attribute__((const))\n+int __ilog2_u64(u64 n)\n+{\n+ int bit;\n+ asm (\"cntlzd %0,%1\" : \"=r\" (bit) : \"r\" (n));\n+ return 63 - bit;\n+}\n+\n+\n+\n+static u64 ehca_map_vaddr(void *caddr);\n+\n+struct ehca_shca {\n+        u32 hca_cap_mr_pgsize;\n+};\n+\n+static u64 ehca_get_max_hwpage_size(struct ehca_shca *shca)\n+{\n+ return 1UL << ( __builtin_constant_p(shca->hca_cap_mr_pgsize) ? ( (shca->hca_cap_mr_pgsize) < 1 ? ____ilog2_NaN() : (shca->hca_cap_mr_pgsize) & (1ULL << 63) ? 63 : (shca->hca_cap_mr_pgsize) & (1ULL << 62) ? 62 : (shca->hca_cap_mr_pgsize) & (1ULL << 61) ? 61 : (shca->hca_cap_mr_pgsize) & (1ULL << 60) ? 60 : (shca->hca_cap_mr_pgsize) & (1ULL << 59) ? 59 : (shca->hca_cap_mr_pgsize) & (1ULL << 58) ? 58 : (shca->hca_cap_mr_pgsize) & (1ULL << 57) ? 57 : (shca->hca_cap_mr_pgsize) & (1ULL << 56) ? 56 : (shca->hca_cap_mr_pgsize) & (1ULL << 55) ? 55 : (shca->hca_cap_mr_pgsize) & (1ULL << 54) ? 54 : (shca->hca_cap_mr_pgsize) & (1ULL << 53) ? 53 : (shca->hca_cap_mr_pgsize) & (1ULL << 52) ? 52 : (shca->hca_cap_mr_pgsize) & (1ULL << 51) ? 51 : (shca->hca_cap_mr_pgsize) & (1ULL << 50) ? 50 : (shca->hca_cap_mr_pgsize) & (1ULL << 49) ? 49 : (shca->hca_cap_mr_pgsize) & (1ULL << 48) ? 48 : (shca->hca_cap_mr_pgsize) & (1ULL << 47) ? 47 : (shca->hca_cap_mr_pgsize) & (1ULL << 46) ? 46 : (shca->hca_cap_mr_pgsize) & (1ULL << 45) ? 45 : (shca->hca_cap_mr_pgsize) & (1ULL << 44) ? 44 : (shca->hca_cap_mr_pgsize) & (1ULL << 43) ? 43 : (shca->hca_cap_mr_pgsize) & (1ULL << 42) ? 42 : (shca->hca_cap_mr_pgsize) & (1ULL << 41) ? 41 : (shca->hca_cap_mr_pgsize) & (1ULL << 40) ? 40 : (shca->hca_cap_mr_pgsize) & (1ULL << 39) ? 39 : (shca->hca_cap_mr_pgsize) & (1ULL << 38) ? 38 : (shca->hca_cap_mr_pgsize) & (1ULL << 37) ? 37 : (shca->hca_cap_mr_pgsize) & (1ULL << 36) ? 36 : (shca->hca_cap_mr_pgsize) & (1ULL << 35) ? 35 : (shca->hca_cap_mr_pgsize) & (1ULL << 34) ? 34 : (shca->hca_cap_mr_pgsize) & (1ULL << 33) ? 33 : (shca->hca_cap_mr_pgsize) & (1ULL << 32) ? 32 : (shca->hca_cap_mr_pgsize) & (1ULL << 31) ? 31 : (shca->hca_cap_mr_pgsize) & (1ULL << 30) ? 30 : (shca->hca_cap_mr_pgsize) & (1ULL << 29) ? 29 : (shca->hca_cap_mr_pgsize) & (1ULL << 28) ? 28 : (shca->hca_cap_mr_pgsize) & (1ULL << 27) ? 27 : (shca->hca_cap_mr_pgsize) & (1ULL << 26) ? 26 : (shca->hca_cap_mr_pgsize) & (1ULL << 25) ? 25 : (shca->hca_cap_mr_pgsize) & (1ULL << 24) ? 24 : (shca->hca_cap_mr_pgsize) & (1ULL << 23) ? 23 : (shca->hca_cap_mr_pgsize) & (1ULL << 22) ? 22 : (shca->hca_cap_mr_pgsize) & (1ULL << 21) ? 21 : (shca->hca_cap_mr_pgsize) & (1ULL << 20) ? 20 : (shca->hca_cap_mr_pgsize) & (1ULL << 19) ? 19 : (shca->hca_cap_mr_pgsize) & (1ULL << 18) ? 18 : (shca->hca_cap_mr_pgsize) & (1ULL << 17) ? 17 : (shca->hca_cap_mr_pgsize) & (1ULL << 16) ? 16 : (shca->hca_cap_mr_pgsize) & (1ULL << 15) ? 15 : (shca->hca_cap_mr_pgsize) & (1ULL << 14) ? 14 : (shca->hca_cap_mr_pgsize) & (1ULL << 13) ? 13 : (shca->hca_cap_mr_pgsize) & (1ULL << 12) ? 12 : (shca->hca_cap_mr_pgsize) & (1ULL << 11) ? 11 : (shca->hca_cap_mr_pgsize) & (1ULL << 10) ? 10 : (shca->hca_cap_mr_pgsize) & (1ULL << 9) ? 9 : (shca->hca_cap_mr_pgsize) & (1ULL << 8) ? 8 : (shca->hca_cap_mr_pgsize) & (1ULL << 7) ? 7 : (shca->hca_cap_mr_pgsize) & (1ULL << 6) ? 6 : (shca->hca_cap_mr_pgsize) & (1ULL << 5) ? 5 : (shca->hca_cap_mr_pgsize) & (1ULL << 4) ? 4 : (shca->hca_cap_mr_pgsize) & (1ULL << 3) ? 3 : (shca->hca_cap_mr_pgsize) & (1ULL << 2) ? 2 : (shca->hca_cap_mr_pgsize) & (1ULL << 1) ? 1 : (shca->hca_cap_mr_pgsize) & (1ULL << 0) ? 0 : ____ilog2_NaN() ) : (sizeof(shca->hca_cap_mr_pgsize) <= 4) ? __ilog2_u32(shca->hca_cap_mr_pgsize) : __ilog2_u64(shca->hca_cap_mr_pgsize) );\n+}\n+\n+int x(struct ehca_shca *shca) {\n+        return ehca_get_max_hwpage_size(shca);\n+}\n+\n+int y(struct ehca_shca *shca)\n+{\n+        return ehca_get_max_hwpage_size(shca);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"____ilog2_NaN\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}]}