{"sha": "f5b65a56691fdc8f8b914011da7ed8ec4fa1176c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjViNjVhNTY2OTFmZGM4ZjhiOTE0MDExZGE3ZWQ4ZWM0ZmExMTc2Yw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-04-01T18:48:52Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-04-01T18:48:52Z"}, "message": "h8300.c (interrupt_handler): Renamed from pragma_interrupt.\n\n        * h8300.c (interrupt_handler): Renamed from pragma_interrupt.\n        All references changed.\n        (function_prologue): Set interrupt_handler if the current\n        function has the \"interrrupt-handler\" attribute.\n        (small_call_insn_operand): New function.\n        (h8300_interrrupt_function_p): New function.\n        (h8300_funcvec_function_p): New function.\n        (h8300_valid_machine_decl_attribute): New function.\n        * h8300.h (VALID_MACHINE_DECL_ATTRIBUTE): Define.\n        * h8300.md (call insns): Handle calls through the\n        function vector.  Indirect calls and calls through\n        the function vector have a length of two bytes.\n\nFrom-SVN: r11650", "tree": {"sha": "635a5ec83d2bb80079ecdbc3940f71ca2b73b335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/635a5ec83d2bb80079ecdbc3940f71ca2b73b335"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5b65a56691fdc8f8b914011da7ed8ec4fa1176c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5b65a56691fdc8f8b914011da7ed8ec4fa1176c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5b65a56691fdc8f8b914011da7ed8ec4fa1176c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5b65a56691fdc8f8b914011da7ed8ec4fa1176c/comments", "author": null, "committer": null, "parents": [{"sha": "eecb6f50c217cb9c7b1442da11309d77771d7162", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eecb6f50c217cb9c7b1442da11309d77771d7162", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eecb6f50c217cb9c7b1442da11309d77771d7162"}], "stats": {"total": 151, "additions": 141, "deletions": 10}, "files": [{"sha": "6a85ecb9ebcd0c18d2d072f1d2a32a1ca2a0c9c3", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 102, "deletions": 6, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b65a56691fdc8f8b914011da7ed8ec4fa1176c/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b65a56691fdc8f8b914011da7ed8ec4fa1176c/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=f5b65a56691fdc8f8b914011da7ed8ec4fa1176c", "patch": "@@ -40,11 +40,16 @@ Boston, MA 02111-1307, USA.  */\n void print_operand_address ();\n char *index ();\n \n+static int h8300_interrupt_function_p PROTO ((tree));\n+static int h8300_funcvec_function_p PROTO ((tree));\n+\n /* CPU_TYPE, says what cpu we're compiling for.  */\n int cpu_type;\n \n-/* True if a #pragma interrupt has been seen for the current function.  */\n-int pragma_interrupt;\n+/* True if the current function is an interrupt handler\n+   (either via #pragma or an attribute specification).  */\n+int interrupt_handler;\n+\n \n /* True if a #pragma saveall has been seen for the current function.  */\n int pragma_saveall;\n@@ -110,7 +115,7 @@ byte_reg (x, b)\n \n #define WORD_REG_USED(regno)\t\t\t\t\t\\\n   (regno < 7 &&\t\t\t\t\t\t\t\\\n-   (pragma_interrupt\t\t\t\t\t\t\\\n+   (interrupt_handler\t\t\t\t\t\t\\\n     || pragma_saveall\t\t\t\t\t\t\\\n     || (regno == FRAME_POINTER_REGNUM && regs_ever_live[regno])\t\\\n     || (regs_ever_live[regno] & !call_used_regs[regno])))\n@@ -190,6 +195,9 @@ function_prologue (file, size)\n   int idx;\n   extra_pop = 0;\n \n+  if (h8300_interrupt_function_p (current_function_decl))\n+    interrupt_handler = 1;\n+\n   if (current_function_anonymous_args && TARGET_QUICKCALL)\n     {\n       /* Push regs as if done by caller, and move around return address.  */\n@@ -325,13 +333,13 @@ function_epilogue (file, size)\n     }\n   else\n     {\n-      if (pragma_interrupt)\n+      if (interrupt_handler)\n \tfprintf (file, \"\\trte\\n\");\n       else\n \tfprintf (file, \"\\trts\\n\");\n     }\n \n-  pragma_interrupt = 0;\n+  interrupt_handler = 0;\n   pragma_saveall = 0;\n \n   current_function_anonymous_args = 0;\n@@ -470,6 +478,32 @@ call_insn_operand (op, mode)\n   return 0;\n }\n \n+/* Return true if OP is a valid call operand, and OP represents\n+   an operand for a small call (4 bytes instead of 6 bytes).  */\n+\n+int\n+small_call_insn_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == MEM)\n+    {\n+      rtx inside = XEXP (op, 0);\n+\n+      /* Register indirect is a small call.  */\n+      if (register_operand (inside, Pmode))\n+\treturn 1;\n+\n+      /* A call through the function vector is a small\n+\t call too.  */\n+      if (GET_CODE (inside) == SYMBOL_REF\n+\t  && SYMBOL_REF_FLAG (inside))\n+\treturn 1;\n+    }\n+  /* Otherwise it's a large call.  */\n+  return 0;\n+}\n+\n /* Return true if OP is a valid jump operand.  */\n \n int\n@@ -569,7 +603,7 @@ handle_pragma (file, c)\n       pbuf[psize] = 0;\n \n       if (strcmp (pbuf, \"interrupt\") == 0)\n-\tpragma_interrupt = 1;\n+\tinterrupt_handler = 1;\n       else if (strcmp (pbuf, \"saveall\") == 0)\n \tpragma_saveall = 1;\n \n@@ -2065,3 +2099,65 @@ fix_bit_operand (operands, what, type)\n   }\n   return 1;\n }\n+\n+\n+/* Return nonzero if FUNC is an interrupt function as specified\n+   by the \"interrupt\" attribute.  */\n+\n+static int\n+h8300_interrupt_function_p (func)\n+     tree func;\n+{\n+  tree a;\n+\n+  if (TREE_CODE (func) != FUNCTION_DECL)\n+    return 0;\n+\n+  a = lookup_attribute (\"interrupt-handler\", DECL_MACHINE_ATTRIBUTES (func));\n+  return a != NULL_TREE;\n+}\n+\n+/* Return nonzero if FUNC is a function that should be called\n+   through the function vector.  */\n+\n+int\n+h8300_funcvec_function_p (func)\n+     tree func;\n+{\n+  tree a;\n+\n+  if (TREE_CODE (func) != FUNCTION_DECL)\n+    return 0;\n+\n+  a = lookup_attribute (\"function-vector\", DECL_MACHINE_ATTRIBUTES (func));\n+  return a != NULL_TREE;\n+}\n+\n+/* Return nonzero if ATTR is a valid attribute for DECL.\n+   ATTRIBUTES are any existing attributes and ARGS are the arguments\n+   supplied with ATTR.\n+\n+   Supported attributes:\n+\n+   interrupt-handler: output a prologue and epilogue suitable for an\n+   interrupt handler.\n+\n+   function-vector: This function should be called through the\n+   function vector.  */\n+\n+int\n+h8300_valid_machine_decl_attribute (decl, attributes, attr, args)\n+     tree decl;\n+     tree attributes;\n+     tree attr;\n+     tree args;\n+{\n+  if (args != NULL_TREE)\n+    return 0;\n+\n+  if (is_attribute_p (\"interrupt-handler\", attr)\n+      || is_attribute_p (\"function-vector\", attr))\n+    return TREE_CODE (decl) == FUNCTION_DECL;\n+  return 0;\n+}\n+"}, {"sha": "197d814933fefc29f515b3532eebb49a7f06c66a", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b65a56691fdc8f8b914011da7ed8ec4fa1176c/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b65a56691fdc8f8b914011da7ed8ec4fa1176c/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=f5b65a56691fdc8f8b914011da7ed8ec4fa1176c", "patch": "@@ -932,6 +932,13 @@ extern int current_function_anonymous_args;\n    so give the MEM rtx a byte's mode.  */\n #define FUNCTION_MODE QImode\n \n+/* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n+   is a valid machine specific attribute for DECL.\n+   The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n+extern int h8300_valid_machine_decl_attribute ();\n+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n+h8300_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n+\n /* Compute the cost of computing a constant rtl expression RTX\n    whose rtx-code is CODE.  The body of this macro is a portion\n    of a switch statement.  If the code is computed here,\n@@ -1081,6 +1088,14 @@ dtors_section() \t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\\\n }\t\t\t\t\t\t \n \n+/* If we are referencing a function that is supposed to be called\n+   through the function vector, the SYMBOL_REF_FLAG in the rtl\n+   so the call patterns can generate the correct code.  */\n+#define ENCODE_SECTION_INFO(DECL)  \\\n+  if (TREE_CODE (DECL) == FUNCTION_DECL \\\n+      && h8300_funcvec_function_p (DECL)) \\\n+    SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\n+\n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n "}, {"sha": "509c9600d5be7462f6e4b80491deb8a6664fa1b3", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5b65a56691fdc8f8b914011da7ed8ec4fa1176c/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5b65a56691fdc8f8b914011da7ed8ec4fa1176c/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=f5b65a56691fdc8f8b914011da7ed8ec4fa1176c", "patch": "@@ -1312,10 +1312,20 @@\n   [(call (match_operand:QI 0 \"call_insn_operand\" \"or\")\n \t (match_operand:HI 1 \"general_operand\" \"g\"))]\n   \"\"\n-  \"jsr\t%0\"\n+  \"*\n+{\n+  if (GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF\n+      && SYMBOL_REF_FLAG (XEXP (operands[0], 0)))\n+    return \\\"jsr\\\\t\\@%0:8\\\";\n+  else\n+    return \\\"jsr\\\\t%0\\\";\n+}\"\n   [(set_attr \"type\" \"call\")\n    (set_attr \"cc\" \"clobber\")\n-   (set_attr \"length\" \"4\")])\n+   (set (attr \"length\")\n+     (if_then_else (match_operand:QI 0 \"small_call_insn_operand\" \"\")\n+\t\t   (const_int 4)\n+\t\t   (const_int 8)))])\n \n ;; Call subroutine, returning value in operand 0\n ;; (which must be a hard register).\n@@ -1327,10 +1337,20 @@\n \t(call (match_operand:QI 1 \"call_insn_operand\" \"or\")\n \t      (match_operand:HI 2 \"general_operand\" \"g\")))]\n   \"\"\n-  \"jsr\t%1\"\n+  \"*\n+{\n+  if (GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n+      && SYMBOL_REF_FLAG (XEXP (operands[1], 0)))\n+    return \\\"jsr\\\\t\\@%1:8\\\";\n+  else\n+    return \\\"jsr\\\\t%1\\\";\n+}\"\n   [(set_attr \"type\" \"call\")\n    (set_attr \"cc\" \"clobber\")\n-   (set_attr \"length\" \"4\")])\n+   (set (attr \"length\")\n+     (if_then_else (match_operand:QI 0 \"small_call_insn_operand\" \"\")\n+\t\t   (const_int 4)\n+\t\t   (const_int 8)))])\n \n (define_insn \"nop\"\n   [(const_int 0)]"}]}