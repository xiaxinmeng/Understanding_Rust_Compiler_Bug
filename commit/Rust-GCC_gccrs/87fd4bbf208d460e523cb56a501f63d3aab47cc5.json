{"sha": "87fd4bbf208d460e523cb56a501f63d3aab47cc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdmZDRiYmYyMDhkNDYwZTUyM2NiNTZhNTAxZjYzZDNhYWI0N2NjNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-05-15T22:30:37Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-05-15T22:30:37Z"}, "message": "compiler: Sort array constructors by index.\n\nFrom-SVN: r187560", "tree": {"sha": "2790c4b5323e69dc5c2add072f456cf78a937843", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2790c4b5323e69dc5c2add072f456cf78a937843"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87fd4bbf208d460e523cb56a501f63d3aab47cc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87fd4bbf208d460e523cb56a501f63d3aab47cc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87fd4bbf208d460e523cb56a501f63d3aab47cc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87fd4bbf208d460e523cb56a501f63d3aab47cc5/comments", "author": null, "committer": null, "parents": [{"sha": "efc704cb036749efaf05bcd0557e61df075b3b16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efc704cb036749efaf05bcd0557e61df075b3b16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efc704cb036749efaf05bcd0557e61df075b3b16"}], "stats": {"total": 58, "additions": 48, "deletions": 10}, "files": [{"sha": "b3285480ca0df9a48afe3867756ec0693fe1a11f", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 48, "deletions": 10, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87fd4bbf208d460e523cb56a501f63d3aab47cc5/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87fd4bbf208d460e523cb56a501f63d3aab47cc5/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=87fd4bbf208d460e523cb56a501f63d3aab47cc5", "patch": "@@ -11794,8 +11794,7 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n       if (this->indexes() == NULL)\n \tmax_index = this->vals()->size() - 1;\n       else\n-\tmax_index = *std::max_element(this->indexes()->begin(),\n-\t\t\t\t      this->indexes()->end());\n+\tmax_index = this->indexes()->back();\n       tree max_tree = size_int(max_index);\n       tree constructor_type = build_array_type(element_type_tree,\n \t\t\t\t\t       build_index_type(max_tree));\n@@ -12546,6 +12545,17 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n   return ret;\n }\n \n+// Used to sort an index/value array.\n+\n+class Index_value_compare\n+{\n+ public:\n+  bool\n+  operator()(const std::pair<unsigned long, Expression*>& a,\n+\t     const std::pair<unsigned long, Expression*>& b)\n+  { return a.first < b.first; }\n+};\n+\n // Lower an array composite literal.\n \n Expression*\n@@ -12557,6 +12567,7 @@ Composite_literal_expression::lower_array(Type* type)\n \n   std::vector<unsigned long>* indexes = new std::vector<unsigned long>;\n   indexes->reserve(this->vals_->size());\n+  bool indexes_out_of_order = false;\n   Expression_list* vals = new Expression_list();\n   vals->reserve(this->vals_->size());\n   unsigned long index = 0;\n@@ -12627,6 +12638,9 @@ Composite_literal_expression::lower_array(Type* type)\n \t      return Expression::make_error(location);\n \t    }\n \n+\t  if (!indexes->empty() && index < indexes->back())\n+\t    indexes_out_of_order = true;\n+\n \t  indexes->push_back(index);\n \t}\n \n@@ -12641,6 +12655,34 @@ Composite_literal_expression::lower_array(Type* type)\n       indexes = NULL;\n     }\n \n+  if (indexes_out_of_order)\n+    {\n+      typedef std::vector<std::pair<unsigned long, Expression*> > V;\n+\n+      V v;\n+      v.reserve(indexes->size());\n+      std::vector<unsigned long>::const_iterator pi = indexes->begin();\n+      for (Expression_list::const_iterator pe = vals->begin();\n+\t   pe != vals->end();\n+\t   ++pe, ++pi)\n+\tv.push_back(std::make_pair(*pi, *pe));\n+\n+      std::sort(v.begin(), v.end(), Index_value_compare());\n+\n+      delete indexes;\n+      delete vals;\n+      indexes = new std::vector<unsigned long>();\n+      indexes->reserve(v.size());\n+      vals = new Expression_list();\n+      vals->reserve(v.size());\n+\n+      for (V::const_iterator p = v.begin(); p != v.end(); ++p)\n+\t{\n+\t  indexes->push_back(p->first);\n+\t  vals->push_back(p->second);\n+\t}\n+    }\n+\n   return this->make_array(type, indexes, vals);\n }\n \n@@ -12661,7 +12703,9 @@ Composite_literal_expression::make_array(\n       size_t size;\n       if (vals == NULL)\n \tsize = 0;\n-      else if (indexes == NULL)\n+      else if (indexes != NULL)\n+\tsize = indexes->back() + 1;\n+      else\n \t{\n \t  size = vals->size();\n \t  Integer_type* it = Type::lookup_integer_type(\"int\")->integer_type();\n@@ -12672,11 +12716,6 @@ Composite_literal_expression::make_array(\n \t      return Expression::make_error(location);\n \t    }\n \t}\n-      else\n-\t{\n-\t  size = *std::max_element(indexes->begin(), indexes->end());\n-\t  ++size;\n-\t}\n \n       mpz_t vlen;\n       mpz_init_set_ui(vlen, size);\n@@ -12704,8 +12743,7 @@ Composite_literal_expression::make_array(\n \t    }\n \t  else\n \t    {\n-\t      unsigned long max = *std::max_element(indexes->begin(),\n-\t\t\t\t\t\t    indexes->end());\n+\t      unsigned long max = indexes->back();\n \t      if (max >= val)\n \t\t{\n \t\t  error_at(location,"}]}