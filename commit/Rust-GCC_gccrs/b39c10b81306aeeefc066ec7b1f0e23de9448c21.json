{"sha": "b39c10b81306aeeefc066ec7b1f0e23de9448c21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM5YzEwYjgxMzA2YWVlZWZjMDY2ZWM3YjFmMGUyM2RlOTQ0OGMyMQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-04-13T21:00:59Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-04-13T21:00:59Z"}, "message": "Unify handling of runtime support functions.\n\nThis introduces the new approach, and rewrites the lowering\ncode which uses runtime functions.  The code which calls\nruntime functions at GENERIC conversion time is not yet\nrewritten.\n\nFrom-SVN: r172396", "tree": {"sha": "32a57ad9ca89c95394a45e92649f097c96b50924", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32a57ad9ca89c95394a45e92649f097c96b50924"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b39c10b81306aeeefc066ec7b1f0e23de9448c21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b39c10b81306aeeefc066ec7b1f0e23de9448c21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b39c10b81306aeeefc066ec7b1f0e23de9448c21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b39c10b81306aeeefc066ec7b1f0e23de9448c21/comments", "author": null, "committer": null, "parents": [{"sha": "516d9427ed538547a182833b2cf16f557c932710", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/516d9427ed538547a182833b2cf16f557c932710", "html_url": "https://github.com/Rust-GCC/gccrs/commit/516d9427ed538547a182833b2cf16f557c932710"}], "stats": {"total": 1595, "additions": 1084, "deletions": 511}, "files": [{"sha": "79f9a111aabf09f945bc087a7dd0f3e9ef305e8c", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -1,3 +1,11 @@\n+2011-04-13  Ian Lance Taylor  <iant@google.com>\n+\n+\t* Make-lang.in (GO_OBJS): Add go/runtime.o.\n+\t(GO_RUNTIME_H): New variable.\n+\t(go/runtime.o): New target.\n+\t(go/gogo.o): Depend on $(GO_RUNTIME_H).\n+\t(go/statements.o): Likewise.\n+\n 2011-04-12  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* go-lang.c (union lang_tree_node): Check for TS_COMMON before"}, {"sha": "c5289c67884b759f5a58ee5113c52c82adba9a2f", "filename": "gcc/go/Make-lang.in", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FMake-lang.in?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -59,6 +59,7 @@ GO_OBJS = \\\n \tgo/import-archive.o \\\n \tgo/lex.o \\\n \tgo/parse.o \\\n+\tgo/runtime.o \\\n \tgo/statements.o \\\n \tgo/types.o \\\n \tgo/unsafe.o\n@@ -220,6 +221,7 @@ GO_TYPES_H = go/gofrontend/types.h\n GO_STATEMENTS_H = go/gofrontend/statements.h go/gofrontend/operator.h\n GO_EXPRESSIONS_H = go/gofrontend/expressions.h go/gofrontend/operator.h\n GO_IMPORT_H = go/gofrontend/import.h go/gofrontend/export.h\n+GO_RUNTIME_H = go/gofrontend/runtime.h go/gofrontend/runtime.def\n \n go/go-backend.o: go/go-backend.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \t$(TM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(TARGET_H)\n@@ -263,8 +265,9 @@ go/gogo-tree.o: go/gofrontend/gogo-tree.cc $(GO_SYSTEM_H) $(TOPLEV_H) \\\n \t$(GO_EXPRESSIONS_H) $(GO_STATEMENTS_H) $(GO_GOGO_H)\n go/gogo.o: go/gofrontend/gogo.cc $(GO_SYSTEM_H) $(GO_C_H) \\\n \tgo/gofrontend/go-dump.h $(GO_LEX_H) $(GO_TYPES_H) $(GO_STATEMENTS_H) \\\n-\t$(GO_EXPRESSIONS_H) go/gofrontend/dataflow.h $(GO_IMPORT_H) \\\n-\tgo/gofrontend/export.h go/gofrontend/backend.h $(GO_GOGO_H)\n+\t$(GO_EXPRESSIONS_H) go/gofrontend/dataflow.h $(GO_RUNTIME_H) \\\n+\t$(GO_IMPORT_H) go/gofrontend/export.h go/gofrontend/backend.h \\\n+\t$(GO_GOGO_H)\n go/import.o: go/gofrontend/import.cc $(GO_SYSTEM_H) \\\n \t$(srcdir)/../include/filenames.h $(srcdir)/../include/simple-object.h \\\n \t$(GO_C_H) $(GO_GOGO_H) $(GO_TYPES_H) go/gofrontend/export.h \\\n@@ -274,10 +277,13 @@ go/import-archive.o: go/gofrontend/import-archive.cc $(GO_SYSTEM_H) \\\n go/lex.o: go/gofrontend/lex.cc $(GO_LEX_H) $(GO_SYSTEM_H)\n go/parse.o: go/gofrontend/parse.cc $(GO_SYSTEM_H) $(GO_LEX_H) $(GO_GOGO_H) \\\n \t$(GO_TYPES_H) $(GO_STATEMENTS_H) $(GO_EXPRESSIONS_H) $(GO_PARSE_H)\n+go/runtime.o: go/gofrontend/runtime.cc $(GO_SYSTEM_H) $(GO_GOGO_H) \\\n+\t$(GO_TYPES_H) $(GO_EXPRESSIONS_H) $(GO_RUNTIME_H) \\\n+\tgo/gofrontend/runtime.def\n go/statements.o: go/gofrontend/statements.cc $(GO_SYSTEM_H) intl.h $(TREE_H) \\\n \t$(GIMPLE_H) convert.h tree-iterator.h $(TREE_FLOW_H) $(REAL_H) \\\n \t$(GO_C_H) $(GO_TYPES_H) $(GO_EXPRESSIONS_H) $(GO_GOGO_H) \\\n-\tgo/gofrontend/backend.h $(GO_STATEMENTS_H)\n+\t$(GO_RUNTIME_H) go/gofrontend/backend.h $(GO_STATEMENTS_H)\n go/types.o: go/gofrontend/types.cc $(GO_SYSTEM_H) $(TOPLEV_H) intl.h $(TREE_H) \\\n \t$(GIMPLE_H) $(REAL_H) convert.h $(GO_C_H) $(GO_GOGO_H) \\\n \tgo/gofrontend/operator.h $(GO_EXPRESSIONS_H) $(GO_STATEMENTS_H) \\"}, {"sha": "7f291d40a76d91dbf986c0879c598ac481542f60", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 122, "deletions": 6, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -3410,7 +3410,7 @@ Type_conversion_expression::do_get_tree(Translate_context* context)\n       tree valptr = fold_convert(const_ptr_type_node,\n \t\t\t\t a->value_pointer_tree(gogo, expr_tree));\n       tree len = a->length_tree(gogo, expr_tree);\n-      len = fold_convert_loc(this->location(), size_type_node, len);\n+      len = fold_convert_loc(this->location(), integer_type_node, len);\n       if (e->integer_type()->is_unsigned()\n \t  && e->integer_type()->bits() == 8)\n \t{\n@@ -3422,7 +3422,7 @@ Type_conversion_expression::do_get_tree(Translate_context* context)\n \t\t\t\t   type_tree,\n \t\t\t\t   const_ptr_type_node,\n \t\t\t\t   valptr,\n-\t\t\t\t   size_type_node,\n+\t\t\t\t   integer_type_node,\n \t\t\t\t   len);\n \t}\n       else\n@@ -3436,7 +3436,7 @@ Type_conversion_expression::do_get_tree(Translate_context* context)\n \t\t\t\t   type_tree,\n \t\t\t\t   const_ptr_type_node,\n \t\t\t\t   valptr,\n-\t\t\t\t   size_type_node,\n+\t\t\t\t   integer_type_node,\n \t\t\t\t   len);\n \t}\n     }\n@@ -3523,6 +3523,122 @@ Expression::make_cast(Type* type, Expression* val, source_location location)\n   return new Type_conversion_expression(type, val, location);\n }\n \n+// An unsafe type conversion, used to pass values to builtin functions.\n+\n+class Unsafe_type_conversion_expression : public Expression\n+{\n+ public:\n+  Unsafe_type_conversion_expression(Type* type, Expression* expr,\n+\t\t\t\t    source_location location)\n+    : Expression(EXPRESSION_UNSAFE_CONVERSION, location),\n+      type_(type), expr_(expr)\n+  { }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  Type*\n+  do_type()\n+  { return this->type_; }\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Unsafe_type_conversion_expression(this->type_,\n+\t\t\t\t\t\t this->expr_->copy(),\n+\t\t\t\t\t\t this->location());\n+  }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The type to convert to.\n+  Type* type_;\n+  // The expression to convert.\n+  Expression* expr_;\n+};\n+\n+// Traversal.\n+\n+int\n+Unsafe_type_conversion_expression::do_traverse(Traverse* traverse)\n+{\n+  if (Expression::traverse(&this->expr_, traverse) == TRAVERSE_EXIT\n+      || Type::traverse(this->type_, traverse) == TRAVERSE_EXIT)\n+    return TRAVERSE_EXIT;\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Convert to backend representation.\n+\n+tree\n+Unsafe_type_conversion_expression::do_get_tree(Translate_context* context)\n+{\n+  // We are only called for a limited number of cases.\n+\n+  Type* t = this->type_;\n+  Type* et = this->expr_->type();\n+\n+  tree type_tree = this->type_->get_tree(context->gogo());\n+  tree expr_tree = this->expr_->get_tree(context);\n+  if (type_tree == error_mark_node || expr_tree == error_mark_node)\n+    return error_mark_node;\n+\n+  source_location loc = this->location();\n+\n+  bool use_view_convert = false;\n+  if (t->is_open_array_type())\n+    {\n+      gcc_assert(et->is_open_array_type());\n+      use_view_convert = true;\n+    }\n+  else if (t->map_type() != NULL)\n+    gcc_assert(et->map_type() != NULL);\n+  else if (t->channel_type() != NULL)\n+    gcc_assert(et->channel_type() != NULL);\n+  else if (t->points_to() != NULL && t->points_to()->channel_type() != NULL)\n+    gcc_assert(et->points_to() != NULL\n+\t       && et->points_to()->channel_type() != NULL);\n+  else if (t->is_unsafe_pointer_type())\n+    gcc_assert(et->points_to() != NULL);\n+  else if (et->is_unsafe_pointer_type())\n+    gcc_assert(t->points_to() != NULL);\n+  else if (t->interface_type() != NULL && !t->interface_type()->is_empty())\n+    {\n+      gcc_assert(et->interface_type() != NULL\n+\t\t && !et->interface_type()->is_empty());\n+      use_view_convert = true;\n+    }\n+  else if (t->interface_type() != NULL && t->interface_type()->is_empty())\n+    {\n+      gcc_assert(et->interface_type() != NULL\n+\t\t && et->interface_type()->is_empty());\n+      use_view_convert = true;\n+    }\n+  else\n+    gcc_unreachable();\n+\n+  if (use_view_convert)\n+    return fold_build1_loc(loc, VIEW_CONVERT_EXPR, type_tree, expr_tree);\n+  else\n+    return fold_convert_loc(loc, type_tree, expr_tree);\n+}\n+\n+// Make an unsafe type conversion expression.\n+\n+Expression*\n+Expression::make_unsafe_cast(Type* type, Expression* expr,\n+\t\t\t     source_location location)\n+{\n+  return new Unsafe_type_conversion_expression(type, expr, location);\n+}\n+\n // Unary expressions.\n \n class Unary_expression : public Expression\n@@ -7654,7 +7770,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t\t\t\t      location,\n \t\t\t\t\t      \"__go_map_len\",\n \t\t\t\t\t      1,\n-\t\t\t\t\t      sizetype,\n+\t\t\t\t\t      integer_type_node,\n \t\t\t\t\t      arg_type->get_tree(gogo),\n \t\t\t\t\t      arg_tree);\n \t      }\n@@ -7665,7 +7781,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t\t\t\t      location,\n \t\t\t\t\t      \"__go_chan_len\",\n \t\t\t\t\t      1,\n-\t\t\t\t\t      sizetype,\n+\t\t\t\t\t      integer_type_node,\n \t\t\t\t\t      arg_type->get_tree(gogo),\n \t\t\t\t\t      arg_tree);\n \t      }\n@@ -7693,7 +7809,7 @@ Builtin_call_expression::do_get_tree(Translate_context* context)\n \t\t\t\t\t      location,\n \t\t\t\t\t      \"__go_chan_cap\",\n \t\t\t\t\t      1,\n-\t\t\t\t\t      sizetype,\n+\t\t\t\t\t      integer_type_node,\n \t\t\t\t\t      arg_type->get_tree(gogo),\n \t\t\t\t\t      arg_tree);\n \t      }"}, {"sha": "66aabeb748cd47da1d5b487fe666cea74f1b7cb8", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -81,6 +81,7 @@ class Expression\n     EXPRESSION_MAKE,\n     EXPRESSION_TYPE_GUARD,\n     EXPRESSION_CONVERSION,\n+    EXPRESSION_UNSAFE_CONVERSION,\n     EXPRESSION_STRUCT_CONSTRUCTION,\n     EXPRESSION_FIXED_ARRAY_CONSTRUCTION,\n     EXPRESSION_OPEN_ARRAY_CONSTRUCTION,\n@@ -247,6 +248,12 @@ class Expression\n   static Expression*\n   make_cast(Type*, Expression*, source_location);\n \n+  // Make an unsafe type cast expression.  This is only used when\n+  // passing parameter to builtin functions that are part of the Go\n+  // runtime.\n+  static Expression*\n+  make_unsafe_cast(Type*, Expression*, source_location);\n+\n   // Make a composite literal.  The DEPTH parameter is how far down we\n   // are in a list of composite literals with omitted types.\n   static Expression*"}, {"sha": "e22de4be4461dfc81b4b622c4fd95f1318b97236", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -13,6 +13,7 @@\n #include \"statements.h\"\n #include \"expressions.h\"\n #include \"dataflow.h\"\n+#include \"runtime.h\"\n #include \"import.h\"\n #include \"export.h\"\n #include \"backend.h\"\n@@ -2598,6 +2599,8 @@ Gogo::convert_named_types()\n   Interface_type::make_interface_type_descriptor_type();\n   Type::convert_builtin_named_types(this);\n \n+  Runtime::convert_types(this);\n+\n   this->named_types_are_converted_ = true;\n }\n "}, {"sha": "7249dff739b3041ad32c4638cb9ef16aadde9f8c", "filename": "gcc/go/gofrontend/runtime.cc", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.cc?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -0,0 +1,383 @@\n+// runtime.cc -- runtime functions called by generated code\n+\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include <gmp.h>\n+\n+#include \"gogo.h\"\n+#include \"types.h\"\n+#include \"expressions.h\"\n+#include \"runtime.h\"\n+\n+// The frontend generates calls to various runtime functions.  They\n+// are implemented in libgo/runtime.  This is how the runtime\n+// functions are represented in the frontend.  Note that there is\n+// currently nothing which ensures that the compiler's understanding\n+// of the runtime function matches the actual implementation in\n+// libgo/runtime.\n+\n+// Parameter and result types used by runtime functions.\n+\n+enum Runtime_function_type\n+{\n+  // General indicator that value is not used.\n+  RFT_VOID,\n+  // Go type bool, C type _Bool.\n+  RFT_BOOL,\n+  // Go type *bool, C type _Bool*.\n+  RFT_BOOLPTR,\n+  // Go type int, C type int.\n+  RFT_INT,\n+  // Go type int64, C type int64_t.\n+  RFT_INT64,\n+  // Go type uint64, C type uint64_t.\n+  RFT_UINT64,\n+  // Go type uintptr, C type uintptr_t.\n+  RFT_UINTPTR,\n+  // Go type float64, C type double.\n+  RFT_FLOAT64,\n+  // Go type complex128, C type __complex double.\n+  RFT_COMPLEX128,\n+  // Go type string, C type struct __go_string.\n+  RFT_STRING,\n+  // Go type unsafe.Pointer, C type \"void *\".\n+  RFT_POINTER,\n+  // Go type []any, C type struct __go_open_array.\n+  RFT_SLICE,\n+  // Go type map[any]any, C type struct __go_map *.\n+  RFT_MAP,\n+  // Pointer to map iteration type.\n+  RFT_MAPITER,\n+  // Go type chan any, C type struct __go_channel *.\n+  RFT_CHAN,\n+  // Go type *chan any, C type struct __go_channel **.\n+  RFT_CHANPTR,\n+  // Go type non-empty interface, C type struct __go_interface.\n+  RFT_IFACE,\n+  // Go type interface{}, C type struct __go_empty_interface.\n+  RFT_EFACE,\n+  // Go type func(unsafe.Pointer), C type void (*) (void *).\n+  RFT_FUNC_PTR,\n+  // Pointer to Go type descriptor.\n+  RFT_TYPE,\n+\n+  NUMBER_OF_RUNTIME_FUNCTION_TYPES\n+};\n+\n+// The Type structures for the runtime function types.\n+\n+static Type* runtime_function_types[NUMBER_OF_RUNTIME_FUNCTION_TYPES];\n+\n+// Get the Type for a Runtime_function_type code.\n+\n+static Type*\n+runtime_function_type(Runtime_function_type bft)\n+{\n+  gcc_assert(bft < NUMBER_OF_RUNTIME_FUNCTION_TYPES);\n+  if (runtime_function_types[bft] == NULL)\n+    {\n+      const source_location bloc = BUILTINS_LOCATION;\n+      Type* t;\n+      switch (bft)\n+\t{\n+\tdefault:\n+\tcase RFT_VOID:\n+\t  gcc_unreachable();\n+\n+\tcase RFT_BOOL:\n+\t  t = Type::lookup_bool_type();\n+\t  break;\n+\n+\tcase RFT_BOOLPTR:\n+\t  t = Type::make_pointer_type(Type::lookup_bool_type());\n+\t  break;\n+\n+\tcase RFT_INT:\n+\t  t = Type::lookup_integer_type(\"int\");\n+\t  break;\n+\n+\tcase RFT_INT64:\n+\t  t = Type::lookup_integer_type(\"int64\");\n+\t  break;\n+\n+\tcase RFT_UINT64:\n+\t  t = Type::lookup_integer_type(\"uint64\");\n+\t  break;\n+\n+\tcase RFT_UINTPTR:\n+\t  t = Type::lookup_integer_type(\"uintptr\");\n+\t  break;\n+\n+\tcase RFT_FLOAT64:\n+\t  t = Type::lookup_float_type(\"float64\");\n+\t  break;\n+\n+\tcase RFT_COMPLEX128:\n+\t  t = Type::lookup_complex_type(\"complex128\");\n+\t  break;\n+\n+\tcase RFT_STRING:\n+\t  t = Type::lookup_string_type();\n+\t  break;\n+\n+\tcase RFT_POINTER:\n+\t  t = Type::make_pointer_type(Type::make_void_type());\n+\t  break;\n+\n+\tcase RFT_SLICE:\n+\t  t = Type::make_array_type(Type::make_void_type(), NULL);\n+\t  break;\n+\n+\tcase RFT_MAP:\n+\t  t = Type::make_map_type(Type::make_void_type(),\n+\t\t\t\t  Type::make_void_type(),\n+\t\t\t\t  bloc);\n+\t  break;\n+\n+\tcase RFT_MAPITER:\n+\t  t = Type::make_pointer_type(Runtime::map_iteration_type());\n+\t  break;\n+\n+\tcase RFT_CHAN:\n+\t  t = Type::make_channel_type(true, true, Type::make_void_type());\n+\t  break;\n+\n+\tcase RFT_CHANPTR:\n+\t  t = Type::make_pointer_type(runtime_function_type(RFT_CHAN));\n+\t  break;\n+\n+\tcase RFT_IFACE:\n+\t  {\n+\t    Typed_identifier_list* methods = new Typed_identifier_list();\n+\t    Type* mtype = Type::make_function_type(NULL, NULL, NULL, bloc);\n+\t    methods->push_back(Typed_identifier(\"x\", mtype, bloc));\n+\t    t = Type::make_interface_type(methods, bloc);\n+\t  }\n+\t  break;\n+\n+\tcase RFT_EFACE:\n+\t  t = Type::make_interface_type(NULL, bloc);\n+\t  break;\n+\n+\tcase RFT_FUNC_PTR:\n+\t  {\n+\t    Typed_identifier_list* param_types = new Typed_identifier_list();\n+\t    Type* ptrtype = runtime_function_type(RFT_POINTER);\n+\t    param_types->push_back(Typed_identifier(\"\", ptrtype, bloc));\n+\t    t = Type::make_function_type(NULL, param_types, NULL, bloc);\n+\t  }\n+\t  break;\n+\n+\tcase RFT_TYPE:\n+\t  t = Type::make_type_descriptor_ptr_type();\n+\t  break;\n+\t}\n+\n+      runtime_function_types[bft] = t;\n+    }\n+\n+  return runtime_function_types[bft];\n+}\n+\n+// Convert an expression to the type to pass to a runtime function.\n+\n+static Expression*\n+convert_to_runtime_function_type(Runtime_function_type bft, Expression* e,\n+\t\t\t\t source_location loc)\n+{\n+  switch (bft)\n+    {\n+    default:\n+    case RFT_VOID:\n+      gcc_unreachable();\n+\n+    case RFT_BOOL:\n+    case RFT_BOOLPTR:\n+    case RFT_INT:\n+    case RFT_INT64:\n+    case RFT_UINT64:\n+    case RFT_UINTPTR:\n+    case RFT_FLOAT64:\n+    case RFT_COMPLEX128:\n+    case RFT_STRING:\n+    case RFT_POINTER:\n+    case RFT_MAPITER:\n+    case RFT_FUNC_PTR:\n+      {\n+\tType* t = runtime_function_type(bft);\n+\tif (!Type::are_identical(t, e->type(), true, NULL))\n+\t  e = Expression::make_cast(t, e, loc);\n+\treturn e;\n+      }\n+\n+    case RFT_SLICE:\n+    case RFT_MAP:\n+    case RFT_CHAN:\n+    case RFT_CHANPTR:\n+    case RFT_IFACE:\n+    case RFT_EFACE:\n+      return Expression::make_unsafe_cast(runtime_function_type(bft), e, loc);\n+\n+    case RFT_TYPE:\n+      gcc_assert(e->type() == Type::make_type_descriptor_ptr_type());\n+      return e;\n+    }\n+}\n+\n+// Convert all the types used for runtime functions to the backend\n+// representation.\n+\n+void\n+Runtime::convert_types(Gogo* gogo)\n+{\n+  for (int i = 0; i < static_cast<int>(NUMBER_OF_RUNTIME_FUNCTION_TYPES); ++i)\n+    {\n+      Type* t = runtime_function_types[i];\n+      if (t != NULL && t->named_type() != NULL)\n+\t{\n+\t  bool r = t->verify();\n+\t  gcc_assert(r);\n+\t  t->named_type()->convert(gogo);\n+\t}\n+    }\n+}\n+\n+// The type used to define a runtime function.\n+\n+struct Runtime_function\n+{\n+  // Function name.\n+  const char* name;\n+  // Parameter types.  Never more than 6, as it happens.  RFT_VOID if\n+  // not used.\n+  Runtime_function_type parameter_types[6];\n+  // Result types.  Never more than 2, as it happens.  RFT_VOID if not\n+  // used.\n+  Runtime_function_type result_types[2];\n+};\n+\n+static const Runtime_function runtime_functions[] =\n+{\n+\n+#define DEF_GO_RUNTIME(CODE, NAME, PARAMS, RESULTS) { NAME, PARAMS, RESULTS } ,\n+\n+#include \"runtime.def\"\n+\n+#undef DEF_GO_RUNTIME\n+\n+};\n+\n+static Named_object*\n+runtime_function_declarations[Runtime::NUMBER_OF_FUNCTIONS];\n+\n+// Get the declaration of a runtime function.\n+\n+Named_object*\n+Runtime::runtime_declaration(Function code)\n+{\n+  gcc_assert(code < Runtime::NUMBER_OF_FUNCTIONS);\n+  if (runtime_function_declarations[code] == NULL)\n+    {\n+      const Runtime_function* pb = &runtime_functions[code];\n+\n+      source_location bloc = BUILTINS_LOCATION;\n+\n+      Typed_identifier_list* param_types = NULL;\n+      if (pb->parameter_types[0] != RFT_VOID)\n+\t{\n+\t  param_types = new Typed_identifier_list();\n+\t  for (unsigned int i = 0;\n+\t       i < (sizeof(pb->parameter_types)\n+\t\t    / sizeof (pb->parameter_types[0]));\n+\t       i++)\n+\t    {\n+\t      if (pb->parameter_types[i] == RFT_VOID)\n+\t\tbreak;\n+\t      Type* t = runtime_function_type(pb->parameter_types[i]);\n+\t      param_types->push_back(Typed_identifier(\"\", t, bloc));\n+\t    }\n+\t}\n+\n+      Typed_identifier_list* result_types = NULL;\n+      if (pb->result_types[0] != RFT_VOID)\n+\t{\n+\t  result_types = new Typed_identifier_list();\n+\t  for (unsigned int i = 0;\n+\t       i < sizeof(pb->result_types) / sizeof(pb->result_types[0]);\n+\t       i++)\n+\t    {\n+\t      if (pb->result_types[i] == RFT_VOID)\n+\t\tbreak;\n+\t      Type* t = runtime_function_type(pb->result_types[i]);\n+\t      result_types->push_back(Typed_identifier(\"\", t, bloc));\n+\t    }\n+\t}\n+\n+      Function_type* fntype = Type::make_function_type(NULL, param_types,\n+\t\t\t\t\t\t       result_types, bloc);\n+      const char* n = pb->name;\n+      const char* n1 = strchr(n, '.');\n+      if (n1 != NULL)\n+\tn = n1 + 1;\n+      Named_object* no = Named_object::make_function_declaration(n, NULL,\n+\t\t\t\t\t\t\t\t fntype, bloc);\n+      no->func_declaration_value()->set_asm_name(pb->name);\n+\n+      runtime_function_declarations[code] = no;\n+    }\n+\n+  return runtime_function_declarations[code];\n+}\n+\n+// Make a call to a runtime function.\n+\n+Call_expression*\n+Runtime::make_call(Runtime::Function code, source_location loc,\n+\t\t   int param_count, ...)\n+{\n+  gcc_assert(code < Runtime::NUMBER_OF_FUNCTIONS);\n+\n+  const Runtime_function* pb = &runtime_functions[code];\n+\n+  gcc_assert(static_cast<size_t>(param_count)\n+\t     <= sizeof(pb->parameter_types) / sizeof(pb->parameter_types[0]));\n+\n+  Named_object* no = runtime_declaration(code);\n+  Expression* func = Expression::make_func_reference(no, NULL, loc);\n+\n+  Expression_list* args = new Expression_list();\n+  args->reserve(param_count);\n+\n+  va_list ap;\n+  va_start(ap, param_count);\n+  for (int i = 0; i < param_count; ++i)\n+    {\n+      Expression* e = va_arg(ap, Expression*);\n+      Runtime_function_type rft = pb->parameter_types[i];\n+      args->push_back(convert_to_runtime_function_type(rft, e, loc));\n+    }\n+  va_end(ap);\n+\n+  return Expression::make_call(func, args, false, loc);\n+}\n+\n+// The type we use for a map iteration.  This is really a struct which\n+// is four pointers long.  This must match the runtime struct\n+// __go_hash_iter.\n+\n+Type*\n+Runtime::map_iteration_type()\n+{\n+  const unsigned long map_iteration_size = 4;\n+\n+  mpz_t ival;\n+  mpz_init_set_ui(ival, map_iteration_size);\n+  Expression* iexpr = Expression::make_integer(&ival, NULL, BUILTINS_LOCATION);\n+  mpz_clear(ival);\n+\n+  return Type::make_array_type(runtime_function_type(RFT_POINTER), iexpr);\n+}"}, {"sha": "6e7a807a88e3efe6fa7b948664334758cd724fc8", "filename": "gcc/go/gofrontend/runtime.def", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -0,0 +1,341 @@\n+// runtime.def -- runtime functions called by generated code.  -*- C++ -*-\n+\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Definitions for the Go runtime functions.\n+\n+// Parameter type helper macros.\n+#define ABFT6(T1, T2, T3, T4, T5, T6) \\\n+  { RFT_ ## T1, RFT_ ## T2, RFT_ ## T3, RFT_ ## T4, RFT_ ## T5, RFT_ ## T6 }\n+#define P0()\t\t\tABFT6(VOID, VOID, VOID, VOID, VOID, VOID)\n+#define P1(T)\t\t\tABFT6(T, VOID, VOID, VOID, VOID, VOID)\n+#define P2(T1, T2)\t\tABFT6(T1, T2, VOID, VOID, VOID, VOID)\n+#define P3(T1, T2, T3)\t\tABFT6(T1, T2, T3, VOID, VOID, VOID)\n+#define P4(T1, T2, T3, T4)\tABFT6(T1, T2, T3, T4, VOID, VOID)\n+#define P5(T1, T2, T3, T4, T5)\tABFT6(T1, T2, T3, T4, T5, VOID)\n+#define P6(T1,T2,T3,T4,T5,T6)\tABFT6(T1, T2, T3, T4, T5, T6)\n+\n+// Result type helper macros.\n+#define ABFT2(T1, T2) { RFT_ ## T1, RFT_ ## T2 }\n+#define R0()\t\t\tABFT2(VOID, VOID)\n+#define R1(T)\t\t\tABFT2(T, VOID)\n+#define R2(T1, T2)\t\tABFT2(T1, T2)\n+\n+// Define all the Go runtime functions.  The first parameter is the\n+// enum code used to refer to the function.  The second parameter is\n+// the name.  The third is the parameter types and the fourth is the\n+// result types.\n+\n+// Range over a string, returning the next index.\n+DEF_GO_RUNTIME(STRINGITER, \"runtime.stringiter\", P2(STRING, INT), R1(INT))\n+\n+// Range over a string, returning the next index and character.\n+DEF_GO_RUNTIME(STRINGITER2, \"runtime.stringiter2\", P2(STRING, INT),\n+\t       R2(INT, INT))\n+\n+// Concatenate two strings.\n+DEF_GO_RUNTIME(STRING_PLUS, \"__go_string_plus\", P2(STRING, STRING), R1(STRING))\n+\n+// Compare two strings.\n+DEF_GO_RUNTIME(STRCMP, \"__go_strcmp\", P2(STRING, STRING), R1(INT))\n+\n+// Take a slice of a string.\n+DEF_GO_RUNTIME(STRING_SLICE, \"__go_string_slice\", P3(STRING, INT, INT),\n+\t       R1(STRING))\n+\n+// Convert an integer to a string.\n+DEF_GO_RUNTIME(INT_TO_STRING, \"__go_int_to_string\", P1(INT), R1(STRING))\n+\n+// Convert a byte array to a string.\n+DEF_GO_RUNTIME(BYTE_ARRAY_TO_STRING, \"__go_byte_array_to_string\",\n+\t       P2(POINTER, INT), R1(STRING))\n+\n+// Convert an int array to a string.\n+DEF_GO_RUNTIME(INT_ARRAY_TO_STRING, \"__go_int_array_to_string\",\n+\t       P2(POINTER, INT), R1(STRING))\n+\n+// Convert a string to a byte slice.\n+DEF_GO_RUNTIME(STRING_TO_BYTE_ARRAY, \"__go_string_to_byte_array\",\n+\t       P1(STRING), R1(SLICE))\n+\n+// Convert a string to an int slice.\n+DEF_GO_RUNTIME(STRING_TO_INT_ARRAY, \"__go_string_to_int_array\",\n+\t       P1(STRING), R1(SLICE))\n+\n+\n+// Make a map.\n+DEF_GO_RUNTIME(NEW_MAP, \"__go_new_map\", P2(TYPE, UINTPTR), R1(MAP))\n+\n+// Build a map from a composite literal.\n+DEF_GO_RUNTIME(CONSTRUCT_MAP, \"__go_construct_map\",\n+\t       P6(POINTER, UINTPTR, UINTPTR, UINTPTR, UINTPTR, POINTER),\n+\t       R1(MAP))\n+\n+// Get the length of a map (the number of entries).\n+DEF_GO_RUNTIME(MAP_LEN, \"__go_map_len\", P1(MAP), R1(INT))\n+\n+// Look up a key in a map.\n+DEF_GO_RUNTIME(MAP_INDEX, \"__go_map_index\", P3(MAP, POINTER, BOOL),\n+\t       R1(POINTER))\n+\n+// Look up a key in a map returning whether it is present.\n+DEF_GO_RUNTIME(MAPACCESS2, \"runtime.mapaccess2\", P3(MAP, POINTER, POINTER),\n+\t       R1(BOOL))\n+\n+// Tuple assignment to a map element.\n+DEF_GO_RUNTIME(MAPASSIGN2, \"runtime.mapassign2\",\n+\t       P4(MAP, POINTER, POINTER, BOOL), R0())\n+\n+// Begin a range over a map.\n+DEF_GO_RUNTIME(MAPITERINIT, \"runtime.mapiterinit\", P2(MAP, MAPITER), R0())\n+\n+// Range over a map, returning the next key.\n+DEF_GO_RUNTIME(MAPITER1, \"runtime.mapiter1\", P2(MAPITER, POINTER), R0())\n+\n+// Range over a map, returning the next key and value.\n+DEF_GO_RUNTIME(MAPITER2, \"runtime.mapiter2\", P3(MAPITER, POINTER, POINTER),\n+\t       R0())\n+\n+// Range over a map, moving to the next map entry.\n+DEF_GO_RUNTIME(MAPITERNEXT, \"runtime.mapiternext\", P1(MAPITER), R0())\n+\n+\n+// Make a channel.\n+DEF_GO_RUNTIME(NEW_CHANNEL, \"__go_new_channel\", P2(UINTPTR, UINTPTR), R1(CHAN))\n+\n+// Get the length of a channel (the number of unread values).\n+DEF_GO_RUNTIME(CHAN_LEN, \"__go_chan_len\", P1(CHAN), R1(INT))\n+\n+// Get the capacity of a channel (the size of the buffer).\n+DEF_GO_RUNTIME(CHAN_CAP, \"__go_chan_cap\", P1(CHAN), R1(INT))\n+\n+// Send a small value on a channel.\n+DEF_GO_RUNTIME(SEND_SMALL, \"__go_send_small\", P3(CHAN, UINT64, BOOL), R0())\n+\n+// Send a small value on a channel without blocking.\n+DEF_GO_RUNTIME(SEND_NONBLOCKING_SMALL, \"__go_send_nonblocking_small\",\n+\t       P2(CHAN, UINT64), R1(BOOL))\n+\n+// Send a big value on a channel.\n+DEF_GO_RUNTIME(SEND_BIG, \"__go_send_big\", P3(CHAN, POINTER, BOOL), R0())\n+\n+// Send a big value on a channel without blocking.\n+DEF_GO_RUNTIME(SEND_NONBLOCKING_BIG, \"__go_send_nonblocking_big\",\n+\t       P2(CHAN, POINTER), R1(BOOL))\n+\n+// Receive a small value from a channel.\n+DEF_GO_RUNTIME(RECEIVE_SMALL, \"__go_receive_small\", P2(CHAN, BOOL), R1(UINT64))\n+\n+// Receive a big value from a channel.\n+DEF_GO_RUNTIME(RECEIVE_BIG, \"__go_receive_big\", P3(CHAN, POINTER, BOOL),\n+\t       R1(BOOL))\n+\n+// Receive a value from a channel returning whether it is closed.\n+DEF_GO_RUNTIME(CHANRECV2, \"runtime.chanrecv2\", P2(CHAN, POINTER), R1(BOOL))\n+\n+// Receive a value from a channel returning whether it is closed, for select.\n+DEF_GO_RUNTIME(CHANRECV3, \"runtime.chanrecv3\", P2(CHAN, POINTER), R1(BOOL))\n+\n+\n+// Panic.\n+DEF_GO_RUNTIME(PANIC, \"__go_panic\", P1(EFACE), R0())\n+\n+// Recover.\n+DEF_GO_RUNTIME(RECOVER, \"__go_recover\", P0(), R1(EFACE))\n+\n+// Recover when called directly from defer.\n+DEF_GO_RUNTIME(DEFERRED_RECOVER, \"__go_deferred_recover\", P0(), R1(EFACE))\n+\n+// Decide whether this function can call recover.\n+DEF_GO_RUNTIME(CAN_RECOVER, \"__go_can_recover\", P1(POINTER), R1(BOOL))\n+\n+// Get the return address of the function.\n+DEF_GO_RUNTIME(RETURN_ADDRESS, \"__go_return_address\", P1(INT), R1(POINTER))\n+\n+// Set the return address for defer in a defer thunk.\n+DEF_GO_RUNTIME(SET_DEFER_RETADDR, \"__go_set_defer_retaddr\", P1(POINTER),\n+\t       R1(BOOL))\n+\n+// Check for a deferred function in an exception handler.\n+DEF_GO_RUNTIME(CHECK_DEFER, \"__go_check_defer\", P1(POINTER), R0())\n+\n+// Run deferred functions.\n+DEF_GO_RUNTIME(UNDEFER, \"__go_undefer\", P1(POINTER), R0())\n+\n+// Panic with a runtime error.\n+DEF_GO_RUNTIME(RUNTIME_ERROR, \"__go_runtime_error\", P1(INT), R0())\n+\n+\n+// Close.\n+DEF_GO_RUNTIME(CLOSE, \"__go_close\", P1(CHAN), R0())\n+\n+\n+// Copy.\n+DEF_GO_RUNTIME(COPY, \"__go_copy\", P3(POINTER, POINTER, UINTPTR), R0())\n+\n+// Append.\n+DEF_GO_RUNTIME(APPEND, \"__go_append\", P4(SLICE, POINTER, UINTPTR, UINTPTR),\n+\t       R1(SLICE))\n+\n+\n+// Register roots (global variables) for the garbage collector.\n+DEF_GO_RUNTIME(REGISTER_GC_ROOTS, \"__go_register_gc_roots\", P1(POINTER), R0())\n+\n+\n+// Allocate memory.\n+DEF_GO_RUNTIME(NEW, \"__go_new\", P1(UINTPTR), R1(POINTER))\n+\n+// Allocate memory which can not contain pointers.\n+DEF_GO_RUNTIME(NEW_NOPOINTERS, \"__go_new_nopointers\", P1(UINTPTR), R1(POINTER))\n+\n+\n+// Allocate a trampoline for a function literal.\n+DEF_GO_RUNTIME(ALLOCATE_GO_TRAMPOLINE, \"__go_allocate_trampoline\",\n+\t       P2(UINTPTR, POINTER), R1(POINTER))\n+\n+\n+// Start a new goroutine.\n+DEF_GO_RUNTIME(GO, \"__go_go\", P2(FUNC_PTR, POINTER), R0())\n+\n+\n+// Defer a function.\n+DEF_GO_RUNTIME(DEFER, \"__go_defer\", P3(POINTER, FUNC_PTR, POINTER), R0())\n+\n+\n+// Run a select statement.\n+DEF_GO_RUNTIME(SELECT, \"__go_select\", P4(UINTPTR, BOOL, CHANPTR, BOOLPTR),\n+\t       R1(UINTPTR))\n+\n+\n+// Convert an empty interface to an empty interface, returning ok.\n+DEF_GO_RUNTIME(IFACEE2E2, \"runtime.ifaceE2E2\", P1(EFACE), R2(EFACE, BOOL))\n+\n+// Convert a non-empty interface to an empty interface, returning ok.\n+DEF_GO_RUNTIME(IFACEI2E2, \"runtime.ifaceI2E2\", P1(IFACE), R2(EFACE, BOOL))\n+\n+// Convert an empty interface to a non-empty interface, returning ok.\n+DEF_GO_RUNTIME(IFACEE2I2, \"runtime.ifaceE2I2\", P2(TYPE, EFACE),\n+\t       R2(IFACE, BOOL))\n+\n+// Convert a non-empty interface to a non-empty interface, returning ok.\n+DEF_GO_RUNTIME(IFACEI2I2, \"runtime.ifaceI2I2\", P2(TYPE, IFACE),\n+\t       R2(IFACE, BOOL))\n+\n+// Convert an empty interface to a pointer type, returning ok.\n+DEF_GO_RUNTIME(IFACEE2T2P, \"runtime.ifaceE2T2P\", P2(TYPE, EFACE),\n+\t       R2(POINTER, BOOL))\n+\n+// Convert a non-empty interface to a pointer type, return ok.\n+DEF_GO_RUNTIME(IFACEI2T2P, \"runtime.ifaceI2T2P\", P2(TYPE, IFACE),\n+\t       R2(POINTER, BOOL))\n+\n+// Convert an empty interface to a non-pointer type, returning ok.\n+DEF_GO_RUNTIME(IFACEE2T2, \"runtime.ifaceE2T2\", P3(TYPE, EFACE, POINTER),\n+\t       R1(BOOL))\n+\n+// Convert a non-empty interface to a non-pointer type, returning ok.\n+DEF_GO_RUNTIME(IFACEI2T2, \"runtime.ifaceI2T2\", P3(TYPE, IFACE, POINTER),\n+\t       R1(BOOL))\n+\n+// A type assertion from one interface type to another.  This is\n+// used for a type assertion.\n+DEF_GO_RUNTIME(ASSERT_INTERFACE, \"__go_assert_interface\", P2(TYPE, TYPE), R0())\n+\n+// Convert one interface type to another.  This is used for an\n+// assignment.\n+DEF_GO_RUNTIME(CONVERT_INTERFACE, \"__go_convert_interface\", P2(TYPE, TYPE),\n+\t       R1(POINTER))\n+\n+// Check whether an interface type may be converted to a\n+// non-interface type.\n+DEF_GO_RUNTIME(CHECK_INTERFACE_TYPE, \"__go_check_interface_type\",\n+\t       P3(TYPE, TYPE, TYPE), R0())\n+\n+// Return whether we can convert an interface type to a type.\n+DEF_GO_RUNTIME(IFACEI2TP, \"runtime.ifaceI2Tp\", P2(TYPE, TYPE), R1(BOOL))\n+\n+// Get the type descriptor of an empty interface.\n+DEF_GO_RUNTIME(EFACETYPE, \"runtime.efacetype\", P1(EFACE), R1(TYPE))\n+\n+// Get the type descriptor of a non-empty interface.\n+DEF_GO_RUNTIME(IFACETYPE, \"runtime.ifacetype\", P1(IFACE), R1(TYPE))\n+\n+\n+// Compare two type descriptors for equality.\n+DEF_GO_RUNTIME(IFACETYPEEQ, \"runtime.ifacetypeeq\", P2(TYPE, TYPE), R1(BOOL))\n+\n+// Compare two empty interface values.\n+DEF_GO_RUNTIME(EMPTY_INTERFACE_COMPARE, \"__go_empty_interface_compare\",\n+\t       P2(EFACE, EFACE), R1(INT))\n+\n+// Compare an empty interface value to a non-interface value.\n+DEF_GO_RUNTIME(EMPTY_INTERFACE_VALUE_COMPARE,\n+\t       \"__go_empty_interface_value_compare\",\n+\t       P3(EFACE, TYPE, POINTER), R1(INT))\n+\n+// Compare two non-empty interface values.\n+DEF_GO_RUNTIME(INTERFACE_COMPARE, \"__go_interface_compare\",\n+\t       P2(IFACE, IFACE), R1(INT))\n+\n+// Compare a non-empty interface value to a non-interface value.\n+DEF_GO_RUNTIME(INTERFACE_VALUE_COMPARE, \"__go_interface_value_compare\",\n+\t       P3(IFACE, TYPE, POINTER), R1(INT))\n+\n+// Compare a non-empty interface value to an interface value.\n+DEF_GO_RUNTIME(INTERFACE_EMPTY_COMPARE, \"__go_interface_empty_compare\",\n+\t       P2(IFACE, EFACE), R1(INT))\n+\n+\n+// Print a string (for print/println).\n+DEF_GO_RUNTIME(PRINT_STRING, \"__go_print_string\", P1(STRING), R0())\n+\n+// Print a uint64 (for print/println).\n+DEF_GO_RUNTIME(PRINT_UINT64, \"__go_print_uint64\", P1(UINT64), R0())\n+\n+// Print a int64 (for print/println).\n+DEF_GO_RUNTIME(PRINT_INT64, \"__go_print_int64\", P1(INT64), R0())\n+\n+// Print a float64 (for print/println).\n+DEF_GO_RUNTIME(PRINT_DOUBLE, \"__go_print_double\", P1(FLOAT64), R0())\n+\n+// Print a complex128 (for print/println).\n+DEF_GO_RUNTIME(PRINT_COMPLEX, \"__go_print_complex\", P1(COMPLEX128), R0())\n+\n+// Print a bool (for print/println).\n+DEF_GO_RUNTIME(PRINT_BOOL, \"__go_print_bool\", P1(BOOL), R0())\n+\n+// Print a pointer/map/channel/function (for print/println).\n+DEF_GO_RUNTIME(PRINT_POINTER, \"__go_print_pointer\", P1(POINTER), R0())\n+\n+// Print an empty interface (for print/println).\n+DEF_GO_RUNTIME(PRINT_EMPTY_INTERFACE, \"__go_print_empty_interface\",\n+\t       P1(EFACE), R0())\n+\n+// Print a non-empty interface (for print/println).\n+DEF_GO_RUNTIME(PRINT_INTERFACE, \"__go_print_interface\", P1(IFACE), R0())\n+\n+// Print a slice (for print/println).\n+DEF_GO_RUNTIME(PRINT_SLICE, \"__go_print_slice\", P1(SLICE), R0())\n+\n+// Print a space (for println).\n+DEF_GO_RUNTIME(PRINT_SPACE, \"__go_print_space\", P0(), R0())\n+\n+// Print a newline (for println).\n+DEF_GO_RUNTIME(PRINT_NL, \"__go_print_nl\", P0(), R0())\n+\n+\n+// Remove helper macros.\n+#undef ABFT6\n+#undef ABFT2\n+#undef P0\n+#undef P1\n+#undef P2\n+#undef P3\n+#undef P4\n+#undef P5\n+#undef P6\n+#undef R0\n+#undef R1\n+#undef R2"}, {"sha": "d8fb00c2725dac277d508cbf0491bfdd449dbaaf", "filename": "gcc/go/gofrontend/runtime.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2Fgofrontend%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2Fgofrontend%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.h?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -0,0 +1,47 @@\n+// runtime.h -- runtime functions called by generated code  -*- C++ -*-\n+\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_RUNTIME_H\n+#define GO_RUNTIME_H\n+\n+class Gogo;\n+class Type;\n+class Named_object;\n+class Call_expression;\n+\n+class Runtime\n+{\n+ public:\n+\n+  // The runtime functions which may be called by generated code.\n+  enum Function\n+  {\n+\n+#define DEF_GO_RUNTIME(CODE, NAME, PARAMS, RESULTS) CODE ,\n+\n+#include \"runtime.def\"\n+\n+#undef DEF_GO_RUNTIME\n+\n+    // Number of runtime functions.\n+    NUMBER_OF_FUNCTIONS\n+  };\n+\n+  static Call_expression*\n+  make_call(Function, source_location, int, ...);\n+\n+  static void\n+  convert_types(Gogo*);\n+\n+  static Type*\n+  map_iteration_type();\n+\n+ private:\n+  static Named_object*\n+  runtime_declaration(Function);\n+};\n+\n+#endif // !defined(GO_BUILTINS_H)"}, {"sha": "0b22e307306c3966383ca0f59e1523361fd87aff", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 89, "deletions": 434, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -29,6 +29,7 @@ extern \"C\"\n #include \"types.h\"\n #include \"expressions.h\"\n #include \"gogo.h\"\n+#include \"runtime.h\"\n #include \"backend.h\"\n #include \"statements.h\"\n \n@@ -958,33 +959,13 @@ Tuple_map_assignment_statement::do_lower(Gogo*, Named_object*,\n     Statement::make_temporary(Type::lookup_bool_type(), NULL, loc);\n   b->add_statement(present_temp);\n \n-  // func mapaccess2(hmap map[k]v, key *k, val *v) bool\n-  source_location bloc = BUILTINS_LOCATION;\n-  Typed_identifier_list* param_types = new Typed_identifier_list();\n-  param_types->push_back(Typed_identifier(\"hmap\", map_type, bloc));\n-  Type* pkey_type = Type::make_pointer_type(map_type->key_type());\n-  param_types->push_back(Typed_identifier(\"key\", pkey_type, bloc));\n-  Type* pval_type = Type::make_pointer_type(map_type->val_type());\n-  param_types->push_back(Typed_identifier(\"val\", pval_type, bloc));\n-\n-  Typed_identifier_list* ret_types = new Typed_identifier_list();\n-  ret_types->push_back(Typed_identifier(\"\", Type::lookup_bool_type(), bloc));\n-\n-  Function_type* fntype = Type::make_function_type(NULL, param_types,\n-\t\t\t\t\t\t   ret_types, bloc);\n-  Named_object* mapaccess2 =\n-    Named_object::make_function_declaration(\"mapaccess2\", NULL, fntype, bloc);\n-  mapaccess2->func_declaration_value()->set_asm_name(\"runtime.mapaccess2\");\n-\n   // present_temp = mapaccess2(MAP, &key_temp, &val_temp)\n-  Expression* func = Expression::make_func_reference(mapaccess2, NULL, loc);\n-  Expression_list* params = new Expression_list();\n-  params->push_back(map_index->map());\n   Expression* ref = Expression::make_temporary_reference(key_temp, loc);\n-  params->push_back(Expression::make_unary(OPERATOR_AND, ref, loc));\n+  Expression* a1 = Expression::make_unary(OPERATOR_AND, ref, loc);\n   ref = Expression::make_temporary_reference(val_temp, loc);\n-  params->push_back(Expression::make_unary(OPERATOR_AND, ref, loc));\n-  Expression* call = Expression::make_call(func, params, false, loc);\n+  Expression* a2 = Expression::make_unary(OPERATOR_AND, ref, loc);\n+  Expression* call = Runtime::make_call(Runtime::MAPACCESS2, loc, 3,\n+\t\t\t\t\tmap_index->map(), a1, a2);\n \n   ref = Expression::make_temporary_reference(present_temp, loc);\n   Statement* s = Statement::make_assignment(ref, call, loc);\n@@ -1097,31 +1078,21 @@ Map_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n     Statement::make_temporary(map_type->val_type(), this->val_, loc);\n   b->add_statement(val_temp);\n \n-  // func mapassign2(hmap map[k]v, key *k, val *v, p)\n-  source_location bloc = BUILTINS_LOCATION;\n-  Typed_identifier_list* param_types = new Typed_identifier_list();\n-  param_types->push_back(Typed_identifier(\"hmap\", map_type, bloc));\n-  Type* pkey_type = Type::make_pointer_type(map_type->key_type());\n-  param_types->push_back(Typed_identifier(\"key\", pkey_type, bloc));\n-  Type* pval_type = Type::make_pointer_type(map_type->val_type());\n-  param_types->push_back(Typed_identifier(\"val\", pval_type, bloc));\n-  param_types->push_back(Typed_identifier(\"p\", Type::lookup_bool_type(), bloc));\n-  Function_type* fntype = Type::make_function_type(NULL, param_types,\n-\t\t\t\t\t\t   NULL, bloc);\n-  Named_object* mapassign2 =\n-    Named_object::make_function_declaration(\"mapassign2\", NULL, fntype, bloc);\n-  mapassign2->func_declaration_value()->set_asm_name(\"runtime.mapassign2\");\n+  // var insert_temp bool = p\n+  Temporary_statement* insert_temp =\n+    Statement::make_temporary(Type::lookup_bool_type(), this->should_set_,\n+\t\t\t      loc);\n+  b->add_statement(insert_temp);\n \n   // mapassign2(map_temp, &key_temp, &val_temp, p)\n-  Expression* func = Expression::make_func_reference(mapassign2, NULL, loc);\n-  Expression_list* params = new Expression_list();\n-  params->push_back(Expression::make_temporary_reference(map_temp, loc));\n+  Expression* p1 = Expression::make_temporary_reference(map_temp, loc);\n   Expression* ref = Expression::make_temporary_reference(key_temp, loc);\n-  params->push_back(Expression::make_unary(OPERATOR_AND, ref, loc));\n+  Expression* p2 = Expression::make_unary(OPERATOR_AND, ref, loc);\n   ref = Expression::make_temporary_reference(val_temp, loc);\n-  params->push_back(Expression::make_unary(OPERATOR_AND, ref, loc));\n-  params->push_back(this->should_set_);\n-  Expression* call = Expression::make_call(func, params, false, loc);\n+  Expression* p3 = Expression::make_unary(OPERATOR_AND, ref, loc);\n+  Expression* p4 = Expression::make_temporary_reference(insert_temp, loc);\n+  Expression* call = Runtime::make_call(Runtime::MAPASSIGN2, loc, 4,\n+\t\t\t\t\tp1, p2, p3, p4);\n   Statement* s = Statement::make_statement(call);\n   b->add_statement(s);\n \n@@ -1225,40 +1196,13 @@ Tuple_receive_assignment_statement::do_lower(Gogo*, Named_object*,\n     Statement::make_temporary(Type::lookup_bool_type(), NULL, loc);\n   b->add_statement(closed_temp);\n \n-  // func chanrecv2(c chan T, val *T) bool\n-  // func chanrecv3(c chan T, val *T) bool (if for_select)\n-  source_location bloc = BUILTINS_LOCATION;\n-  Typed_identifier_list* param_types = new Typed_identifier_list();\n-  param_types->push_back(Typed_identifier(\"c\", channel_type, bloc));\n-  Type* pelement_type = Type::make_pointer_type(channel_type->element_type());\n-  param_types->push_back(Typed_identifier(\"val\", pelement_type, bloc));\n-\n-  Typed_identifier_list* ret_types = new Typed_identifier_list();\n-  ret_types->push_back(Typed_identifier(\"\", Type::lookup_bool_type(), bloc));\n-\n-  Function_type* fntype = Type::make_function_type(NULL, param_types,\n-\t\t\t\t\t\t   ret_types, bloc);\n-  Named_object* chanrecv;\n-  if (!this->for_select_)\n-    {\n-      chanrecv = Named_object::make_function_declaration(\"chanrecv2\", NULL,\n-\t\t\t\t\t\t\t fntype, bloc);\n-      chanrecv->func_declaration_value()->set_asm_name(\"runtime.chanrecv2\");\n-    }\n-  else\n-    {\n-      chanrecv = Named_object::make_function_declaration(\"chanrecv3\", NULL,\n-\t\t\t\t\t\t\t fntype, bloc);\n-      chanrecv->func_declaration_value()->set_asm_name(\"runtime.chanrecv3\");\n-    }\n-\n   // closed_temp = chanrecv[23](channel, &val_temp)\n-  Expression* func = Expression::make_func_reference(chanrecv, NULL, loc);\n-  Expression_list* params = new Expression_list();\n-  params->push_back(this->channel_);\n   Expression* ref = Expression::make_temporary_reference(val_temp, loc);\n-  params->push_back(Expression::make_unary(OPERATOR_AND, ref, loc));\n-  Expression* call = Expression::make_call(func, params, false, loc);\n+  Expression* p2 = Expression::make_unary(OPERATOR_AND, ref, loc);\n+  Expression* call = Runtime::make_call((this->for_select_\n+\t\t\t\t\t ? Runtime::CHANRECV3\n+\t\t\t\t\t : Runtime::CHANRECV2),\n+\t\t\t\t\tloc, 2, this->channel_, p2);\n   ref = Expression::make_temporary_reference(closed_temp, loc);\n   Statement* s = Statement::make_assignment(ref, call, loc);\n   b->add_statement(s);\n@@ -1318,13 +1262,10 @@ class Tuple_type_guard_assignment_statement : public Statement\n \n  private:\n   Call_expression*\n-  lower_to_empty_interface(const char*);\n-\n-  Call_expression*\n-  lower_to_type(const char*);\n+  lower_to_type(Runtime::Function);\n \n   void\n-  lower_to_object_type(Block*, const char*);\n+  lower_to_object_type(Block*, Runtime::Function);\n \n   // The variable which recieves the converted value.\n   Expression* val_;\n@@ -1377,23 +1318,32 @@ Tuple_type_guard_assignment_statement::do_lower(Gogo*, Named_object*,\n   if (this->type_->interface_type() != NULL)\n     {\n       if (this->type_->interface_type()->is_empty())\n-\tcall = this->lower_to_empty_interface(expr_is_empty\n-\t\t\t\t\t      ? \"ifaceE2E2\"\n-\t\t\t\t\t      : \"ifaceI2E2\");\n+\tcall = Runtime::make_call((expr_is_empty\n+\t\t\t\t   ? Runtime::IFACEE2E2\n+\t\t\t\t   : Runtime::IFACEI2E2),\n+\t\t\t\t  loc, 1, this->expr_);\n       else\n-\tcall = this->lower_to_type(expr_is_empty ? \"ifaceE2I2\" : \"ifaceI2I2\");\n+\tcall = this->lower_to_type(expr_is_empty\n+\t\t\t\t   ? Runtime::IFACEE2I2\n+\t\t\t\t   : Runtime::IFACEI2I2);\n     }\n   else if (this->type_->points_to() != NULL)\n-    call = this->lower_to_type(expr_is_empty ? \"ifaceE2T2P\" : \"ifaceI2T2P\");\n+    call = this->lower_to_type(expr_is_empty\n+\t\t\t       ? Runtime::IFACEE2T2P\n+\t\t\t       : Runtime::IFACEI2T2P);\n   else\n     {\n-      this->lower_to_object_type(b, expr_is_empty ? \"ifaceE2T2\" : \"ifaceI2T2\");\n+      this->lower_to_object_type(b,\n+\t\t\t\t (expr_is_empty\n+\t\t\t\t  ? Runtime::IFACEE2T2\n+\t\t\t\t  : Runtime::IFACEI2T2));\n       call = NULL;\n     }\n \n   if (call != NULL)\n     {\n       Expression* res = Expression::make_call_result(call, 0);\n+      res = Expression::make_unsafe_cast(this->type_, res, loc);\n       Statement* s = Statement::make_assignment(this->val_, res, loc);\n       b->add_statement(s);\n \n@@ -1405,74 +1355,23 @@ Tuple_type_guard_assignment_statement::do_lower(Gogo*, Named_object*,\n   return Statement::make_block_statement(b, loc);\n }\n \n-// Lower a conversion to an empty interface type.\n-\n-Call_expression*\n-Tuple_type_guard_assignment_statement::lower_to_empty_interface(\n-    const char *fnname)\n-{\n-  source_location loc = this->location();\n-\n-  // func FNNAME(interface) (empty, bool)\n-  source_location bloc = BUILTINS_LOCATION;\n-  Typed_identifier_list* param_types = new Typed_identifier_list();\n-  param_types->push_back(Typed_identifier(\"i\", this->expr_->type(), bloc));\n-  Typed_identifier_list* ret_types = new Typed_identifier_list();\n-  ret_types->push_back(Typed_identifier(\"ret\", this->type_, bloc));\n-  ret_types->push_back(Typed_identifier(\"ok\", Type::lookup_bool_type(), bloc));\n-  Function_type* fntype = Type::make_function_type(NULL, param_types,\n-\t\t\t\t\t\t   ret_types, bloc);\n-  Named_object* fn =\n-    Named_object::make_function_declaration(fnname, NULL, fntype, bloc);\n-  std::string asm_name = \"runtime.\";\n-  asm_name += fnname;\n-  fn->func_declaration_value()->set_asm_name(asm_name);\n-\n-  // val, ok = FNNAME(expr)\n-  Expression* func = Expression::make_func_reference(fn, NULL, loc);\n-  Expression_list* params = new Expression_list();\n-  params->push_back(this->expr_);\n-  return Expression::make_call(func, params, false, loc);\n-}\n-\n // Lower a conversion to a non-empty interface type or a pointer type.\n \n Call_expression*\n-Tuple_type_guard_assignment_statement::lower_to_type(const char* fnname)\n+Tuple_type_guard_assignment_statement::lower_to_type(Runtime::Function code)\n {\n   source_location loc = this->location();\n-\n-  // func FNNAME(*descriptor, interface) (interface, bool)\n-  source_location bloc = BUILTINS_LOCATION;\n-  Typed_identifier_list* param_types = new Typed_identifier_list();\n-  param_types->push_back(Typed_identifier(\"inter\",\n-\t\t\t\t\t  Type::make_type_descriptor_ptr_type(),\n-\t\t\t\t\t  bloc));\n-  param_types->push_back(Typed_identifier(\"i\", this->expr_->type(), bloc));\n-  Typed_identifier_list* ret_types = new Typed_identifier_list();\n-  ret_types->push_back(Typed_identifier(\"ret\", this->type_, bloc));\n-  ret_types->push_back(Typed_identifier(\"ok\", Type::lookup_bool_type(), bloc));\n-  Function_type* fntype = Type::make_function_type(NULL, param_types,\n-\t\t\t\t\t\t   ret_types, bloc);\n-  Named_object* fn =\n-    Named_object::make_function_declaration(fnname, NULL, fntype, bloc);\n-  std::string asm_name = \"runtime.\";\n-  asm_name += fnname;\n-  fn->func_declaration_value()->set_asm_name(asm_name);\n-\n-  // val, ok = FNNAME(type_descriptor, expr)\n-  Expression* func = Expression::make_func_reference(fn, NULL, loc);\n-  Expression_list* params = new Expression_list();\n-  params->push_back(Expression::make_type_descriptor(this->type_, loc));\n-  params->push_back(this->expr_);\n-  return Expression::make_call(func, params, false, loc);\n+  return Runtime::make_call(code, loc, 2,\n+\t\t\t    Expression::make_type_descriptor(this->type_, loc),\n+\t\t\t    this->expr_);\n }\n \n // Lower a conversion to a non-interface non-pointer type.\n \n void\n-Tuple_type_guard_assignment_statement::lower_to_object_type(Block* b,\n-\t\t\t\t\t\t\t    const char *fnname)\n+Tuple_type_guard_assignment_statement::lower_to_object_type(\n+    Block* b,\n+    Runtime::Function code)\n {\n   source_location loc = this->location();\n \n@@ -1481,33 +1380,11 @@ Tuple_type_guard_assignment_statement::lower_to_object_type(Block* b,\n \t\t\t\t\t\t\t    NULL, loc);\n   b->add_statement(val_temp);\n \n-  // func FNNAME(*descriptor, interface, *T) bool\n-  source_location bloc = BUILTINS_LOCATION;\n-  Typed_identifier_list* param_types = new Typed_identifier_list();\n-  param_types->push_back(Typed_identifier(\"inter\",\n-\t\t\t\t\t  Type::make_type_descriptor_ptr_type(),\n-\t\t\t\t\t  bloc));\n-  param_types->push_back(Typed_identifier(\"i\", this->expr_->type(), bloc));\n-  Type* ptype = Type::make_pointer_type(this->type_);\n-  param_types->push_back(Typed_identifier(\"v\", ptype, bloc));\n-  Typed_identifier_list* ret_types = new Typed_identifier_list();\n-  ret_types->push_back(Typed_identifier(\"ok\", Type::lookup_bool_type(), bloc));\n-  Function_type* fntype = Type::make_function_type(NULL, param_types,\n-\t\t\t\t\t\t   ret_types, bloc);\n-  Named_object* fn =\n-    Named_object::make_function_declaration(fnname, NULL, fntype, bloc);\n-  std::string asm_name = \"runtime.\";\n-  asm_name += fnname;\n-  fn->func_declaration_value()->set_asm_name(asm_name);\n-\n-  // ok = FNNAME(type_descriptor, expr, &val_temp)\n-  Expression* func = Expression::make_func_reference(fn, NULL, loc);\n-  Expression_list* params = new Expression_list();\n-  params->push_back(Expression::make_type_descriptor(this->type_, loc));\n-  params->push_back(this->expr_);\n+  // ok = CODE(type_descriptor, expr, &val_temp)\n+  Expression* p1 = Expression::make_type_descriptor(this->type_, loc);\n   Expression* ref = Expression::make_temporary_reference(val_temp, loc);\n-  params->push_back(Expression::make_unary(OPERATOR_AND, ref, loc));\n-  Expression* call = Expression::make_call(func, params, false, loc);\n+  Expression* p3 = Expression::make_unary(OPERATOR_AND, ref, loc);\n+  Expression* call = Runtime::make_call(code, loc, 3, p1, this->expr_, p3);\n   Statement* s = Statement::make_assignment(this->ok_, call, loc);\n   b->add_statement(s);\n \n@@ -2146,34 +2023,8 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name,\n     {\n       retaddr_label = gogo->add_label_reference(\"retaddr\");\n       Expression* arg = Expression::make_label_addr(retaddr_label, location);\n-      Expression_list* args = new Expression_list();\n-      args->push_back(arg);\n-\n-      static Named_object* set_defer_retaddr;\n-      if (set_defer_retaddr == NULL)\n-\t{\n-\t  const source_location bloc = BUILTINS_LOCATION;\n-\t  Typed_identifier_list* param_types = new Typed_identifier_list();\n-\t  Type *voidptr_type = Type::make_pointer_type(Type::make_void_type());\n-\t  param_types->push_back(Typed_identifier(\"r\", voidptr_type, bloc));\n-\n-\t  Typed_identifier_list* result_types = new Typed_identifier_list();\n-\t  result_types->push_back(Typed_identifier(\"\",\n-\t\t\t\t\t\t   Type::lookup_bool_type(),\n-\t\t\t\t\t\t   bloc));\n-\n-\t  Function_type* t = Type::make_function_type(NULL, param_types,\n-\t\t\t\t\t\t      result_types, bloc);\n-\t  set_defer_retaddr =\n-\t    Named_object::make_function_declaration(\"__go_set_defer_retaddr\",\n-\t\t\t\t\t\t    NULL, t, bloc);\n-\t  const char* n = \"__go_set_defer_retaddr\";\n-\t  set_defer_retaddr->func_declaration_value()->set_asm_name(n);\n-\t}\n-\n-      Expression* fn = Expression::make_func_reference(set_defer_retaddr,\n-\t\t\t\t\t\t       NULL, location);\n-      Expression* call = Expression::make_call(fn, args, false, location);\n+      Expression* call = Runtime::make_call(Runtime::SET_DEFER_RETADDR,\n+\t\t\t\t\t    location, 1, arg);\n \n       // This is a hack to prevent the middle-end from deleting the\n       // label.\n@@ -3610,92 +3461,24 @@ Type_case_clauses::Type_case_clause::lower(Block* b,\n     {\n       Type* type = this->type_;\n \n+      Expression* ref = Expression::make_temporary_reference(descriptor_temp,\n+\t\t\t\t\t\t\t     loc);\n+\n       Expression* cond;\n       // The language permits case nil, which is of course a constant\n       // rather than a type.  It will appear here as an invalid\n       // forwarding type.\n       if (type->is_nil_constant_as_type())\n-\t{\n-\t  Expression* ref =\n-\t    Expression::make_temporary_reference(descriptor_temp, loc);\n-\t  cond = Expression::make_binary(OPERATOR_EQEQ, ref,\n-\t\t\t\t\t Expression::make_nil(loc),\n-\t\t\t\t\t loc);\n-\t}\n+\tcond = Expression::make_binary(OPERATOR_EQEQ, ref,\n+\t\t\t\t       Expression::make_nil(loc),\n+\t\t\t\t       loc);\n       else\n-\t{\n-\t  Expression* func;\n-\t  if (type->interface_type() == NULL)\n-\t    {\n-\t      // func ifacetypeeq(*descriptor, *descriptor) bool\n-\t      static Named_object* ifacetypeeq;\n-\t      if (ifacetypeeq == NULL)\n-\t\t{\n-\t\t  const source_location bloc = BUILTINS_LOCATION;\n-\t\t  Typed_identifier_list* param_types =\n-\t\t    new Typed_identifier_list();\n-\t\t  Type* descriptor_type = Type::make_type_descriptor_ptr_type();\n-\t\t  param_types->push_back(Typed_identifier(\"a\", descriptor_type,\n-\t\t\t\t\t\t\t  bloc));\n-\t\t  param_types->push_back(Typed_identifier(\"b\", descriptor_type,\n-\t\t\t\t\t\t\t  bloc));\n-\t\t  Typed_identifier_list* ret_types =\n-\t\t    new Typed_identifier_list();\n-\t\t  Type* bool_type = Type::lookup_bool_type();\n-\t\t  ret_types->push_back(Typed_identifier(\"\", bool_type, bloc));\n-\t\t  Function_type* fntype = Type::make_function_type(NULL,\n-\t\t\t\t\t\t\t\t   param_types,\n-\t\t\t\t\t\t\t\t   ret_types,\n-\t\t\t\t\t\t\t\t   bloc);\n-\t\t  ifacetypeeq =\n-\t\t    Named_object::make_function_declaration(\"ifacetypeeq\", NULL,\n-\t\t\t\t\t\t\t    fntype, bloc);\n-\t\t  const char* n = \"runtime.ifacetypeeq\";\n-\t\t  ifacetypeeq->func_declaration_value()->set_asm_name(n);\n-\t\t}\n-\n-\t      // ifacetypeeq(descriptor_temp, DESCRIPTOR)\n-\t      func = Expression::make_func_reference(ifacetypeeq, NULL, loc);\n-\t    }\n-\t  else\n-\t    {\n-\t      // func ifaceI2Tp(*descriptor, *descriptor) bool\n-\t      static Named_object* ifaceI2Tp;\n-\t      if (ifaceI2Tp == NULL)\n-\t\t{\n-\t\t  const source_location bloc = BUILTINS_LOCATION;\n-\t\t  Typed_identifier_list* param_types =\n-\t\t    new Typed_identifier_list();\n-\t\t  Type* descriptor_type = Type::make_type_descriptor_ptr_type();\n-\t\t  param_types->push_back(Typed_identifier(\"a\", descriptor_type,\n-\t\t\t\t\t\t\t  bloc));\n-\t\t  param_types->push_back(Typed_identifier(\"b\", descriptor_type,\n-\t\t\t\t\t\t\t  bloc));\n-\t\t  Typed_identifier_list* ret_types =\n-\t\t    new Typed_identifier_list();\n-\t\t  Type* bool_type = Type::lookup_bool_type();\n-\t\t  ret_types->push_back(Typed_identifier(\"\", bool_type, bloc));\n-\t\t  Function_type* fntype = Type::make_function_type(NULL,\n-\t\t\t\t\t\t\t\t   param_types,\n-\t\t\t\t\t\t\t\t   ret_types,\n-\t\t\t\t\t\t\t\t   bloc);\n-\t\t  ifaceI2Tp =\n-\t\t    Named_object::make_function_declaration(\"ifaceI2Tp\", NULL,\n-\t\t\t\t\t\t\t    fntype, bloc);\n-\t\t  const char* n = \"runtime.ifaceI2Tp\";\n-\t\t  ifaceI2Tp->func_declaration_value()->set_asm_name(n);\n-\t\t}\n-\n-\t      // ifaceI2Tp(descriptor_temp, DESCRIPTOR)\n-\t      func = Expression::make_func_reference(ifaceI2Tp, NULL, loc);\n-\t    }\n-\t  Expression_list* params = new Expression_list();\n-\t  params->push_back(Expression::make_type_descriptor(type, loc));\n-\t  Expression* ref =\n-\t    Expression::make_temporary_reference(descriptor_temp, loc);\n-\t  params->push_back(ref);\n-\t  cond = Expression::make_call(func, params, false, loc);\n-\t}\n+\tcond = Runtime::make_call((type->interface_type() == NULL\n+\t\t\t\t   ? Runtime::IFACETYPEEQ\n+\t\t\t\t   : Runtime::IFACEI2TP),\n+\t\t\t\t  loc, 2,\n+\t\t\t\t  Expression::make_type_descriptor(type, loc),\n+\t\t\t\t  ref);\n \n       Unnamed_label* dest;\n       if (!this->is_fallthrough_)\n@@ -3891,35 +3674,18 @@ Type_switch_statement::do_lower(Gogo*, Named_object*, Block* enclosing)\n     }\n   else\n     {\n-      const source_location bloc = BUILTINS_LOCATION;\n-\n-      // func {efacetype,ifacetype}(*interface) *descriptor\n+      // descriptor_temp = ifacetype(val_temp)\n       // FIXME: This should be inlined.\n-      Typed_identifier_list* param_types = new Typed_identifier_list();\n-      param_types->push_back(Typed_identifier(\"i\", val_type, bloc));\n-      Typed_identifier_list* ret_types = new Typed_identifier_list();\n-      ret_types->push_back(Typed_identifier(\"\", descriptor_type, bloc));\n-      Function_type* fntype = Type::make_function_type(NULL, param_types,\n-\t\t\t\t\t\t       ret_types, bloc);\n       bool is_empty = val_type->interface_type()->is_empty();\n-      const char* fnname = is_empty ? \"efacetype\" : \"ifacetype\";\n-      Named_object* fn =\n-\tNamed_object::make_function_declaration(fnname, NULL, fntype, bloc);\n-      const char* asm_name = (is_empty\n-\t\t\t      ? \"runtime.efacetype\"\n-\t\t\t      : \"runtime.ifacetype\");\n-      fn->func_declaration_value()->set_asm_name(asm_name);\n-\n-      // descriptor_temp = ifacetype(val_temp)\n-      Expression* func = Expression::make_func_reference(fn, NULL, loc);\n-      Expression_list* params = new Expression_list();\n       Expression* ref;\n       if (this->var_ == NULL)\n \tref = this->expr_;\n       else\n \tref = Expression::make_var_reference(this->var_, loc);\n-      params->push_back(ref);\n-      Expression* call = Expression::make_call(func, params, false, loc);\n+      Expression* call = Runtime::make_call((is_empty\n+\t\t\t\t\t     ? Runtime::EFACETYPE\n+\t\t\t\t\t     : Runtime::IFACETYPE),\n+\t\t\t\t\t    loc, 1, ref);\n       Expression* lhs = Expression::make_temporary_reference(descriptor_temp,\n \t\t\t\t\t\t\t     loc);\n       Statement* s = Statement::make_assignment(lhs, call, loc);\n@@ -4935,7 +4701,7 @@ For_range_statement::lower_range_array(Gogo* gogo,\n // Lower a for range over a string.\n \n void\n-For_range_statement::lower_range_string(Gogo* gogo,\n+For_range_statement::lower_range_string(Gogo*,\n \t\t\t\t\tBlock* enclosing,\n \t\t\t\t\tBlock* body_block,\n \t\t\t\t\tNamed_object* range_object,\n@@ -4996,66 +4762,12 @@ For_range_statement::lower_range_string(Gogo* gogo,\n \n   Block* iter_init = new Block(body_block, loc);\n \n-  Named_object* no;\n-  if (value_temp == NULL)\n-    {\n-      static Named_object* stringiter;\n-      if (stringiter == NULL)\n-\t{\n-\t  source_location bloc = BUILTINS_LOCATION;\n-\t  Type* int_type = gogo->lookup_global(\"int\")->type_value();\n-\n-\t  Typed_identifier_list* params = new Typed_identifier_list();\n-\t  params->push_back(Typed_identifier(\"s\", Type::make_string_type(),\n-\t\t\t\t\t     bloc));\n-\t  params->push_back(Typed_identifier(\"k\", int_type, bloc));\n-\n-\t  Typed_identifier_list* results = new Typed_identifier_list();\n-\t  results->push_back(Typed_identifier(\"\", int_type, bloc));\n-\n-\t  Function_type* fntype = Type::make_function_type(NULL, params,\n-\t\t\t\t\t\t\t   results, bloc);\n-\t  stringiter = Named_object::make_function_declaration(\"stringiter\",\n-\t\t\t\t\t\t\t       NULL, fntype,\n-\t\t\t\t\t\t\t       bloc);\n-\t  const char* n = \"runtime.stringiter\";\n-\t  stringiter->func_declaration_value()->set_asm_name(n);\n-\t}\n-      no = stringiter;\n-    }\n-  else\n-    {\n-      static Named_object* stringiter2;\n-      if (stringiter2 == NULL)\n-\t{\n-\t  source_location bloc = BUILTINS_LOCATION;\n-\t  Type* int_type = gogo->lookup_global(\"int\")->type_value();\n-\n-\t  Typed_identifier_list* params = new Typed_identifier_list();\n-\t  params->push_back(Typed_identifier(\"s\", Type::make_string_type(),\n-\t\t\t\t\t     bloc));\n-\t  params->push_back(Typed_identifier(\"k\", int_type, bloc));\n-\n-\t  Typed_identifier_list* results = new Typed_identifier_list();\n-\t  results->push_back(Typed_identifier(\"\", int_type, bloc));\n-\t  results->push_back(Typed_identifier(\"\", int_type, bloc));\n-\n-\t  Function_type* fntype = Type::make_function_type(NULL, params,\n-\t\t\t\t\t\t\t   results, bloc);\n-\t  stringiter2 = Named_object::make_function_declaration(\"stringiter\",\n-\t\t\t\t\t\t\t\tNULL, fntype,\n-\t\t\t\t\t\t\t\tbloc);\n-\t  const char* n = \"runtime.stringiter2\";\n-\t  stringiter2->func_declaration_value()->set_asm_name(n);\n-\t}\n-      no = stringiter2;\n-    }\n-\n-  Expression* func = Expression::make_func_reference(no, NULL, loc);\n-  Expression_list* params = new Expression_list();\n-  params->push_back(this->make_range_ref(range_object, range_temp, loc));\n-  params->push_back(Expression::make_temporary_reference(index_temp, loc));\n-  Call_expression* call = Expression::make_call(func, params, false, loc);\n+  Expression* p1 = this->make_range_ref(range_object, range_temp, loc);\n+  Expression* p2 = Expression::make_temporary_reference(index_temp, loc);\n+  Call_expression* call = Runtime::make_call((value_temp == NULL\n+\t\t\t\t\t      ? Runtime::STRINGITER\n+\t\t\t\t\t      : Runtime::STRINGITER2),\n+\t\t\t\t\t     loc, 2, p1, p2);\n \n   if (value_temp == NULL)\n     {\n@@ -5107,7 +4819,7 @@ For_range_statement::lower_range_string(Gogo* gogo,\n // Lower a for range over a map.\n \n void\n-For_range_statement::lower_range_map(Gogo* gogo,\n+For_range_statement::lower_range_map(Gogo*,\n \t\t\t\t     Block* enclosing,\n \t\t\t\t     Block* body_block,\n \t\t\t\t     Named_object* range_object,\n@@ -5140,41 +4852,15 @@ For_range_statement::lower_range_map(Gogo* gogo,\n \n   Block* init = new Block(enclosing, loc);\n \n-  const unsigned long map_iteration_size = 4;\n-\n-  mpz_t ival;\n-  mpz_init_set_ui(ival, map_iteration_size);\n-  Expression* iexpr = Expression::make_integer(&ival, NULL, loc);\n-  mpz_clear(ival);\n-\n-  Type* byte_type = gogo->lookup_global(\"byte\")->type_value();\n-  Type* ptr_type = Type::make_pointer_type(byte_type);\n-\n-  Type* map_iteration_type = Type::make_array_type(ptr_type, iexpr);\n-  Type* map_iteration_ptr = Type::make_pointer_type(map_iteration_type);\n-\n+  Type* map_iteration_type = Runtime::map_iteration_type();\n   Temporary_statement* hiter = Statement::make_temporary(map_iteration_type,\n \t\t\t\t\t\t\t NULL, loc);\n   init->add_statement(hiter);\n \n-  source_location bloc = BUILTINS_LOCATION;\n-  Typed_identifier_list* param_types = new Typed_identifier_list();\n-  param_types->push_back(Typed_identifier(\"map\", this->range_->type(), bloc));\n-  param_types->push_back(Typed_identifier(\"it\", map_iteration_ptr, bloc));\n-  Function_type* fntype = Type::make_function_type(NULL, param_types, NULL,\n-\t\t\t\t\t\t   bloc);\n-\n-  Named_object* mapiterinit =\n-    Named_object::make_function_declaration(\"mapiterinit\", NULL, fntype, bloc);\n-  const char* n = \"runtime.mapiterinit\";\n-  mapiterinit->func_declaration_value()->set_asm_name(n);\n-\n-  Expression* func = Expression::make_func_reference(mapiterinit, NULL, loc);\n-  Expression_list* params = new Expression_list();\n-  params->push_back(this->make_range_ref(range_object, range_temp, loc));\n+  Expression* p1 = this->make_range_ref(range_object, range_temp, loc);\n   Expression* ref = Expression::make_temporary_reference(hiter, loc);\n-  params->push_back(Expression::make_unary(OPERATOR_AND, ref, loc));\n-  Expression* call = Expression::make_call(func, params, false, loc);\n+  Expression* p2 = Expression::make_unary(OPERATOR_AND, ref, loc);\n+  Expression* call = Runtime::make_call(Runtime::MAPITERINIT, loc, 2, p1, p2);\n   init->add_statement(Statement::make_statement(call));\n \n   *pinit = init;\n@@ -5204,34 +4890,18 @@ For_range_statement::lower_range_map(Gogo* gogo,\n \n   Block* iter_init = new Block(body_block, loc);\n \n-  param_types = new Typed_identifier_list();\n-  param_types->push_back(Typed_identifier(\"hiter\", map_iteration_ptr, bloc));\n-  Type* pkey_type = Type::make_pointer_type(index_temp->type());\n-  param_types->push_back(Typed_identifier(\"key\", pkey_type, bloc));\n-  if (value_temp != NULL)\n-    {\n-      Type* pval_type = Type::make_pointer_type(value_temp->type());\n-      param_types->push_back(Typed_identifier(\"val\", pval_type, bloc));\n-    }\n-  fntype = Type::make_function_type(NULL, param_types, NULL, bloc);\n-  n = value_temp == NULL ? \"mapiter1\" : \"mapiter2\";\n-  Named_object* mapiter = Named_object::make_function_declaration(n, NULL,\n-\t\t\t\t\t\t\t\t  fntype, bloc);\n-  n = value_temp == NULL ? \"runtime.mapiter1\" : \"runtime.mapiter2\";\n-  mapiter->func_declaration_value()->set_asm_name(n);\n-\n-  func = Expression::make_func_reference(mapiter, NULL, loc);\n-  params = new Expression_list();\n   ref = Expression::make_temporary_reference(hiter, loc);\n-  params->push_back(Expression::make_unary(OPERATOR_AND, ref, loc));\n+  p1 = Expression::make_unary(OPERATOR_AND, ref, loc);\n   ref = Expression::make_temporary_reference(index_temp, loc);\n-  params->push_back(Expression::make_unary(OPERATOR_AND, ref, loc));\n-  if (value_temp != NULL)\n+  p2 = Expression::make_unary(OPERATOR_AND, ref, loc);\n+  if (value_temp == NULL)\n+    call = Runtime::make_call(Runtime::MAPITER1, loc, 2, p1, p2);\n+  else\n     {\n       ref = Expression::make_temporary_reference(value_temp, loc);\n-      params->push_back(Expression::make_unary(OPERATOR_AND, ref, loc));\n+      Expression* p3 = Expression::make_unary(OPERATOR_AND, ref, loc);\n+      call = Runtime::make_call(Runtime::MAPITER2, loc, 3, p1, p2, p3);\n     }\n-  call = Expression::make_call(func, params, false, loc);\n   iter_init->add_statement(Statement::make_statement(call));\n \n   *piter_init = iter_init;\n@@ -5241,24 +4911,9 @@ For_range_statement::lower_range_map(Gogo* gogo,\n \n   Block* post = new Block(enclosing, loc);\n \n-  static Named_object* mapiternext;\n-  if (mapiternext == NULL)\n-    {\n-      param_types = new Typed_identifier_list();\n-      param_types->push_back(Typed_identifier(\"it\", map_iteration_ptr, bloc));\n-      fntype = Type::make_function_type(NULL, param_types, NULL, bloc);\n-      mapiternext = Named_object::make_function_declaration(\"mapiternext\",\n-\t\t\t\t\t\t\t    NULL, fntype,\n-\t\t\t\t\t\t\t    bloc);\n-      const char* n = \"runtime.mapiternext\";\n-      mapiternext->func_declaration_value()->set_asm_name(n);\n-    }\n-\n-  func = Expression::make_func_reference(mapiternext, NULL, loc);\n-  params = new Expression_list();\n   ref = Expression::make_temporary_reference(hiter, loc);\n-  params->push_back(Expression::make_unary(OPERATOR_AND, ref, loc));\n-  call = Expression::make_call(func, params, false, loc);\n+  p1 = Expression::make_unary(OPERATOR_AND, ref, loc);\n+  call = Runtime::make_call(Runtime::MAPITERNEXT, loc, 1, p1);\n   post->add_statement(Statement::make_statement(call));\n \n   *ppost = post;"}, {"sha": "ac791746e179649bf3403aefb6a6a8d9f6ccb319", "filename": "libgo/runtime/channel.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fchannel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fchannel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fchannel.h?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -79,7 +79,7 @@ struct __go_channel\n    acquired while this mutex is held.  */\n extern pthread_mutex_t __go_select_data_mutex;\n \n-extern struct __go_channel *__go_new_channel (size_t, size_t);\n+extern struct __go_channel *__go_new_channel (uintptr_t, uintptr_t);\n \n extern _Bool __go_synch_with_select (struct __go_channel *, _Bool);\n \n@@ -138,6 +138,6 @@ extern _Bool __go_builtin_closed (struct __go_channel *);\n \n extern void __go_builtin_close (struct __go_channel *);\n \n-extern size_t __go_chan_len (struct __go_channel *);\n+extern int __go_chan_len (struct __go_channel *);\n \n-extern size_t __go_chan_cap (struct __go_channel *);\n+extern int __go_chan_cap (struct __go_channel *);"}, {"sha": "e501f3066a950db1cab11bc11fe153c880ea6340", "filename": "libgo/runtime/go-append.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-append.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-append.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-append.c?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -19,18 +19,18 @@ __go_append (struct __go_open_array, void *, size_t, size_t)\n   __attribute__ ((no_split_stack));\n \n struct __go_open_array\n-__go_append (struct __go_open_array a, void *bvalues, size_t bcount,\n-\t     size_t element_size)\n+__go_append (struct __go_open_array a, void *bvalues, uintptr_t bcount,\n+\t     uintptr_t element_size)\n {\n-  size_t ucount;\n+  uintptr_t ucount;\n   int count;\n \n   if (bvalues == NULL || bcount == 0)\n     return a;\n \n-  ucount = (size_t) a.__count + bcount;\n+  ucount = (uintptr_t) a.__count + bcount;\n   count = (int) ucount;\n-  if ((size_t) count != ucount || count <= a.__count)\n+  if ((uintptr_t) count != ucount || count <= a.__count)\n     __go_panic_msg (\"append: slice overflow\");\n \n   if (count > a.__capacity)"}, {"sha": "ab9e28388bc3efc29f2b18be2e5eefcabb286e51", "filename": "libgo/runtime/go-byte-array-to-string.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-byte-array-to-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-byte-array-to-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-byte-array-to-string.c?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -9,7 +9,7 @@\n #include \"malloc.h\"\n \n struct __go_string\n-__go_byte_array_to_string (const void* p, size_t len)\n+__go_byte_array_to_string (const void* p, int len)\n {\n   const unsigned char *bytes;\n   unsigned char *retdata;"}, {"sha": "2c7958dd9fc444518ebf841a71457d5969163789", "filename": "libgo/runtime/go-chan-cap.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-chan-cap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-chan-cap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-chan-cap.c?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -13,11 +13,11 @@\n    buffer.  This could be done inline but I'm doing it as a function\n    for now to make it easy to change the channel structure.  */\n \n-size_t\n+int\n __go_chan_cap (struct __go_channel *channel)\n {\n   int i;\n-  size_t ret;\n+  int ret;\n \n   if (channel == NULL)\n     return 0;"}, {"sha": "b3ced98aa050ebafd172b50ae66948cd5ec1e9f4", "filename": "libgo/runtime/go-chan-len.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-chan-len.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-chan-len.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-chan-len.c?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -14,11 +14,11 @@\n    as a function for now to make it easy to change the channel\n    structure.  */\n \n-size_t\n+int\n __go_chan_len (struct __go_channel *channel)\n {\n   int i;\n-  size_t ret;\n+  int ret;\n \n   if (channel == NULL)\n     return 0;\n@@ -35,7 +35,7 @@ __go_chan_len (struct __go_channel *channel)\n \t   % channel->num_entries);\n \n   i = pthread_mutex_unlock (&channel->lock);\n-  __go_assert  (i == 0);\n+  __go_assert (i == 0);\n \n   return ret;\n }"}, {"sha": "5e459d07ac4b63f251f75f8bd79e01ac044703d9", "filename": "libgo/runtime/go-construct-map.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-construct-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-construct-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-construct-map.c?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -5,18 +5,20 @@\n    license that can be found in the LICENSE file.  */\n \n #include <stddef.h>\n+#include <stdint.h>\n #include <stdlib.h>\n \n #include \"map.h\"\n \n struct __go_map *\n __go_construct_map (const struct __go_map_descriptor *descriptor,\n-\t\t    size_t count, size_t entry_size, size_t val_offset,\n-\t\t    size_t val_size, const void *ventries)\n+\t\t    uintptr_t count, uintptr_t entry_size,\n+\t\t    uintptr_t val_offset, uintptr_t val_size,\n+\t\t    const void *ventries)\n {\n   struct __go_map *ret;\n   const unsigned char *entries;\n-  size_t i;\n+  uintptr_t i;\n \n   ret = __go_new_map (descriptor, count);\n "}, {"sha": "05e16acbf1c48686ec76b7338473d537e5731723", "filename": "libgo/runtime/go-copy.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-copy.c?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -5,17 +5,18 @@\n    license that can be found in the LICENSE file.  */\n \n #include <stddef.h>\n+#include <stdint.h>\n \n /* We should be OK if we don't split the stack here, since we are just\n    calling memmove which shouldn't need much stack.  If we don't do\n    this we will always split the stack, because of memmove.  */\n \n extern void\n-__go_copy (void *, void *, size_t)\n+__go_copy (void *, void *, uintptr_t)\n   __attribute__ ((no_split_stack));\n \n void\n-__go_copy (void *a, void *b, size_t len)\n+__go_copy (void *a, void *b, uintptr_t len)\n {\n   __builtin_memmove (a, b, len);\n }"}, {"sha": "ec07b873907d7fbf253038a4c8d895ef3fb7e835", "filename": "libgo/runtime/go-int-array-to-string.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-int-array-to-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-int-array-to-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-int-array-to-string.c?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -10,11 +10,11 @@\n #include \"malloc.h\"\n \n struct __go_string\n-__go_int_array_to_string (const void* p, size_t len)\n+__go_int_array_to_string (const void* p, int len)\n {\n   const int *ints;\n-  size_t slen;\n-  size_t i;\n+  int slen;\n+  int i;\n   unsigned char *retdata;\n   struct __go_string ret;\n   unsigned char *s;\n@@ -79,7 +79,7 @@ __go_int_array_to_string (const void* p, size_t len)\n \t}\n     }\n \n-  __go_assert ((size_t) (s - retdata) == slen);\n+  __go_assert (s - retdata == slen);\n \n   return ret;\n }"}, {"sha": "01df5b41c6c8f9d429d06e1b3241f9276c2be95c", "filename": "libgo/runtime/go-map-len.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-map-len.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-map-len.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-map-len.c?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -6,16 +6,18 @@\n \n #include <stddef.h>\n \n+#include \"go-assert.h\"\n #include \"map.h\"\n \n /* Return the length of a map.  This could be done inline, of course,\n-   but I'm doing it as a function for now to make it easy to chang the\n-   map structure.  */\n+   but I'm doing it as a function for now to make it easy to change\n+   the map structure.  */\n \n-size_t\n+int\n __go_map_len (struct __go_map *map)\n {\n   if (map == NULL)\n     return 0;\n+  __go_assert (map->__element_count == (size_t) (int) map->__element_count);\n   return map->__element_count;\n }"}, {"sha": "028715e3b1de384933a645b838660297420c2fce", "filename": "libgo/runtime/go-new-channel.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-new-channel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-new-channel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-new-channel.c?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -5,20 +5,22 @@\n    license that can be found in the LICENSE file.  */\n \n #include <stddef.h>\n+#include <stdint.h>\n \n #include \"go-alloc.h\"\n #include \"go-assert.h\"\n #include \"go-panic.h\"\n #include \"channel.h\"\n \n struct __go_channel*\n-__go_new_channel (size_t element_size, size_t entries)\n+__go_new_channel (uintptr_t element_size, uintptr_t entries)\n {\n   struct __go_channel* ret;\n   size_t alloc_size;\n   int i;\n \n-  if ((size_t) (int) entries != entries || entries > (size_t) -1 / element_size)\n+  if ((uintptr_t) (int) entries != entries\n+      || entries > (uintptr_t) -1 / element_size)\n     __go_panic_msg (\"chan size out of range\");\n \n   alloc_size = (element_size + sizeof (uint64_t) - 1) / sizeof (uint64_t);"}, {"sha": "73e8d7dfe794d16fb9f7521904cb8a44dcb9d1e8", "filename": "libgo/runtime/go-new-map.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-new-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-new-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-new-map.c?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -104,11 +104,11 @@ __go_map_next_prime (unsigned long n)\n /* Allocate a new map.  */\n \n struct __go_map *\n-__go_new_map (const struct __go_map_descriptor *descriptor, size_t entries)\n+__go_new_map (const struct __go_map_descriptor *descriptor, uintptr_t entries)\n {\n   struct __go_map *ret;\n \n-  if ((size_t) (int) entries != entries)\n+  if ((uintptr_t) (int) entries != entries)\n     __go_panic_msg (\"map size out of range\");\n \n   if (entries == 0)"}, {"sha": "657978c30a82433744fdb73a5bcdf14aabe25c22", "filename": "libgo/runtime/go-new.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-new.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-new.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-new.c?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -9,13 +9,13 @@\n #include \"malloc.h\"\n \n void *\n-__go_new (size_t size)\n+__go_new (uintptr_t size)\n {\n   return runtime_mallocgc (size, 0, 1, 1);\n }\n \n void *\n-__go_new_nopointers (size_t size)\n+__go_new_nopointers (uintptr_t size)\n {\n   return runtime_mallocgc (size, FlagNoPointers, 1, 1);\n }"}, {"sha": "5ea521d423dc2ad04ddcf12e8a1cb6cbde6a51b7", "filename": "libgo/runtime/go-select.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-select.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-select.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-select.c?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -22,11 +22,11 @@ struct select_channel\n   /* The channel being selected.  */\n   struct __go_channel* channel;\n   /* If this channel is selected, the value to return.  */\n-  size_t retval;\n+  uintptr_t retval;\n   /* If this channel is a duplicate of one which appears earlier in\n      the array, this is the array index of the earlier channel.  This\n      is -1UL if this is not a dup.  */\n-  size_t dup_index;\n+  uintptr_t dup_index;\n   /* An entry to put on the send or receive queue.  */\n   struct __go_channel_select queue_entry;\n   /* True if selected for send.  */\n@@ -321,24 +321,24 @@ clear_select_waiting (struct select_channel *sc,\n    Lock each channels, and set the is_ready flag.  Return the number\n    of ready channels.  */\n \n-static size_t\n-lock_channels_find_ready (struct select_channel *channels, size_t count)\n+static uintptr_t\n+lock_channels_find_ready (struct select_channel *channels, uintptr_t count)\n {\n-  size_t ready_count;\n-  size_t i;\n+  uintptr_t ready_count;\n+  uintptr_t i;\n \n   ready_count = 0;\n   for (i = 0; i < count; ++i)\n     {\n       struct __go_channel *channel = channels[i].channel;\n       _Bool is_send = channels[i].is_send;\n-      size_t dup_index = channels[i].dup_index;\n+      uintptr_t dup_index = channels[i].dup_index;\n       int x;\n \n       if (channel == NULL)\n \tcontinue;\n \n-      if (dup_index != (size_t) -1UL)\n+      if (dup_index != (uintptr_t) -1UL)\n \t{\n \t  if (channels[dup_index].is_ready)\n \t    {\n@@ -370,13 +370,13 @@ lock_channels_find_ready (struct select_channel *channels, size_t count)\n    All the channels are locked before this routine is called.  This\n    returns the number of ready channels.  */\n \n-size_t\n-force_selected_channel_ready (struct select_channel *channels, size_t count,\n+uintptr_t\n+force_selected_channel_ready (struct select_channel *channels, uintptr_t count,\n \t\t\t      struct __go_channel *selected_channel,\n \t\t\t      _Bool selected_for_read)\n {\n-  size_t ready_count;\n-  size_t i;\n+  uintptr_t ready_count;\n+  uintptr_t i;\n \n   ready_count = 0;\n   for (i = 0; i < count; ++i)\n@@ -403,9 +403,9 @@ force_selected_channel_ready (struct select_channel *channels, size_t count,\n /* Unlock all the channels.  */\n \n static void\n-unlock_channels (struct select_channel *channels, size_t count)\n+unlock_channels (struct select_channel *channels, uintptr_t count)\n {\n-  size_t i;\n+  uintptr_t i;\n   int x;\n \n   for (i = 0; i < count; ++i)\n@@ -415,7 +415,7 @@ unlock_channels (struct select_channel *channels, size_t count)\n       if (channel == NULL)\n \tcontinue;\n \n-      if (channels[i].dup_index != (size_t) -1UL)\n+      if (channels[i].dup_index != (uintptr_t) -1UL)\n \tcontinue;\n \n       x = pthread_mutex_unlock (&channel->lock);\n@@ -432,23 +432,23 @@ unlock_channels (struct select_channel *channels, size_t count)\n    with some other select, and that select already synchronized with a\n    different channel.  */\n \n-static size_t\n+static uintptr_t\n unlock_channels_and_select (struct select_channel *channels,\n-\t\t\t    size_t count, size_t ready_count,\n+\t\t\t    uintptr_t count, uintptr_t ready_count,\n \t\t\t    _Bool is_selected,\n \t\t\t    struct __go_channel **selected_pointer)\n {\n-  size_t selected;\n-  size_t ret;\n+  uintptr_t selected;\n+  uintptr_t ret;\n   _Bool needs_broadcast;\n-  size_t i;\n+  uintptr_t i;\n   int x;\n \n   /* Pick which channel we are going to return.  */\n #if defined(HAVE_RANDOM)\n-  selected = (size_t) random () % ready_count;\n+  selected = (uintptr_t) random () % ready_count;\n #else\n-  selected = (size_t) rand () % ready_count;\n+  selected = (uintptr_t) rand () % ready_count;\n #endif\n   ret = 0;\n   needs_broadcast = 0;\n@@ -457,7 +457,7 @@ unlock_channels_and_select (struct select_channel *channels,\n      duplicated channel until we have seen all its dups.  */\n   for (i = 0; i < count; ++i)\n     {\n-      size_t j = count - i - 1;\n+      uintptr_t j = count - i - 1;\n       struct __go_channel *channel = channels[j].channel;\n       _Bool is_send = channels[j].is_send;\n \n@@ -476,7 +476,7 @@ unlock_channels_and_select (struct select_channel *channels,\n \t  --selected;\n \t}\n \n-      if (channels[j].dup_index == (size_t) -1UL)\n+      if (channels[j].dup_index == (uintptr_t) -1UL)\n \t{\n \t  if (selected_pointer != NULL)\n \t    clear_select_waiting (&channels[j], selected_pointer);\n@@ -511,13 +511,13 @@ unlock_channels_and_select (struct select_channel *channels,\n    ready.  */\n \n static _Bool\n-mark_all_channels_waiting (struct select_channel* channels, size_t count,\n+mark_all_channels_waiting (struct select_channel* channels, uintptr_t count,\n \t\t\t   struct __go_channel **selected_pointer,\n \t\t\t   _Bool *selected_for_read_pointer)\n {\n   _Bool ret;\n   int x;\n-  size_t i;\n+  uintptr_t i;\n \n   ret = 0;\n   for (i = 0; i < count; ++i)\n@@ -528,9 +528,9 @@ mark_all_channels_waiting (struct select_channel* channels, size_t count,\n       if (channel == NULL)\n \tcontinue;\n \n-      if (channels[i].dup_index != (size_t) -1UL)\n+      if (channels[i].dup_index != (uintptr_t) -1UL)\n \t{\n-\t  size_t j;\n+\t  uintptr_t j;\n \n \t  /* A channel may be selected for both read and write.  */\n \t  if (channels[channels[i].dup_index].is_send != is_send)\n@@ -574,14 +574,14 @@ mark_all_channels_waiting (struct select_channel* channels, size_t count,\n    with pairs of arguments: a pointer to a channel, and an int which\n    is non-zero for send, zero for receive.  */\n \n-size_t\n-__go_select (size_t count, _Bool has_default,\n+uintptr_t\n+__go_select (uintptr_t count, _Bool has_default,\n \t     struct __go_channel **channel_args, _Bool *is_send_args)\n {\n   struct select_channel stack_buffer[16];\n   struct select_channel *allocated_buffer;\n   struct select_channel *channels;\n-  size_t i;\n+  uintptr_t i;\n   int x;\n   struct __go_channel *selected_channel;\n   _Bool selected_for_read;\n@@ -606,7 +606,7 @@ __go_select (size_t count, _Bool has_default,\n \n       channels[i].channel = (struct __go_channel*) channel_arg;\n       channels[i].retval = i + 1;\n-      channels[i].dup_index = (size_t) -1UL;\n+      channels[i].dup_index = (uintptr_t) -1UL;\n       channels[i].queue_entry.next = NULL;\n       channels[i].queue_entry.selected = NULL;\n       channels[i].is_send = is_send;\n@@ -617,7 +617,7 @@ __go_select (size_t count, _Bool has_default,\n \n   for (i = 0; i < count; ++i)\n     {\n-      size_t j;\n+      uintptr_t j;\n \n       for (j = 0; j < i; ++j)\n \t{\n@@ -667,7 +667,7 @@ __go_select (size_t count, _Bool has_default,\n \n       if (ready_count > 0)\n \t{\n-\t  size_t ret;\n+\t  uintptr_t ret;\n \n \t  ret = unlock_channels_and_select (channels, count, ready_count,\n \t\t\t\t\t    is_selected,"}, {"sha": "d6cc29922e85eae6eb026dcf8066fc92b9b198a0", "filename": "libgo/runtime/go-trampoline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-trampoline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fgo-trampoline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-trampoline.c?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -22,7 +22,7 @@\n    needs to be more system dependent.  */\n \n void *\n-__go_allocate_trampoline (size_t size, void *closure)\n+__go_allocate_trampoline (uintptr_t size, void *closure)\n {\n   unsigned int page_size;\n   void *ret;"}, {"sha": "9c3fda263a0455a5f276d1d8e4715d010a701650", "filename": "libgo/runtime/map.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39c10b81306aeeefc066ec7b1f0e23de9448c21/libgo%2Fruntime%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmap.h?ref=b39c10b81306aeeefc066ec7b1f0e23de9448c21", "patch": "@@ -68,7 +68,7 @@ struct __go_hash_iter\n };\n \n extern struct __go_map *__go_new_map (const struct __go_map_descriptor *,\n-\t\t\t\t      size_t);\n+\t\t\t\t      uintptr_t);\n \n extern unsigned long __go_map_next_prime (unsigned long);\n "}]}