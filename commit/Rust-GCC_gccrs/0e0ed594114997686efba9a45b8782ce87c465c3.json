{"sha": "0e0ed594114997686efba9a45b8782ce87c465c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUwZWQ1OTQxMTQ5OTc2ODZlZmJhOWE0NWI4NzgyY2U4N2M0NjVjMw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-12-12T19:59:16Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-12-12T19:59:16Z"}, "message": "tree-ssa-dom.c (simplify_rhs_and_lookup_avail_expr): Remove reassociation code.\n\n\n\t* tree-ssa-dom.c (simplify_rhs_and_lookup_avail_expr): Remove\n\treassociation code.\n\t* passes.c (init_optimization_passes): Run reassociation again\n\tafter loop optimizations.\n\n\t* tree-ssa-dom.c (thread_across_edge): Canonicalize condition\n\tif necessary.\n\t(optimize_stmt): Ditto.\n\t(canonicalize_comparison): New function.\n\t* tree-ssa-operands.c (swap_tree_operands): Make external.\n\t(get_expr_operands): Stop auto-canonicalization.\n\t* tree-ssa-reassoc.c: Rewrite.\n\t(init_optimization_passes): \n\t* tree-flow.h (swap_tree_operands): Prototype.\n\t* Makefile.in (tree-ssa-reassoc.o): Update dependencies.\n\n\t* gcc.dg/tree-ssa/ssa-pre-2.c: Update due to reassociation changes.\n\t* gcc.dg/tree-ssa/reassoc-1.c: Likewise.\n\t* gcc.dg/tree-ssa/reassoc-2.c: Likewise.\n\t* gcc.dg/tree-ssa/reassoc-3.c: Likewise.\n\t* gcc.dg/tree-ssa/reassoc-4.c: Likewise.\n\t* gcc.dg/tree-ssa/reassoc-5.c: New.\n\t* gcc.dg/tree-ssa/reassoc-6.c: New.\n\t* gcc.dg/tree-ssa/reassoc-7.c: New.\n\t* gcc.dg/tree-ssa/reassoc-8.c: New.\n\t* gcc.dg/tree-ssa/reassoc-9.c: New.\n\t* gcc.dg/tree-ssa/reassoc-10.c: New.\n\t* gcc.dg/tree-ssa/reassoc-11.c: New.\n\nFrom-SVN: r108425", "tree": {"sha": "c76d6731feeecd4ca0a01da9f4b777624a718874", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c76d6731feeecd4ca0a01da9f4b777624a718874"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e0ed594114997686efba9a45b8782ce87c465c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e0ed594114997686efba9a45b8782ce87c465c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e0ed594114997686efba9a45b8782ce87c465c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e0ed594114997686efba9a45b8782ce87c465c3/comments", "author": null, "committer": null, "parents": [{"sha": "e525ba8e6ccfe6fd514ee115c97413f19f7700e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e525ba8e6ccfe6fd514ee115c97413f19f7700e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e525ba8e6ccfe6fd514ee115c97413f19f7700e8"}], "stats": {"total": 2095, "additions": 1509, "deletions": 586}, "files": [{"sha": "52c4e1c4967efb263192df3fa50951c72b5fb617", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -1,3 +1,23 @@\n+2005-12-12  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (simplify_rhs_and_lookup_avail_expr): Remove\n+\treassociation code.\n+\t* passes.c (init_optimization_passes): Run reassociation again\n+\tafter loop optimizations.\n+\n+2005-12-12  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-ssa-dom.c (thread_across_edge): Canonicalize condition\n+\tif necessary.\n+\t(optimize_stmt): Ditto.\n+\t(canonicalize_comparison): New function.\n+\t* tree-ssa-operands.c (swap_tree_operands): Make external.\n+\t(get_expr_operands): Stop auto-canonicalization.\n+\t* tree-ssa-reassoc.c: Rewrite.\n+\t(init_optimization_passes): \n+\t* tree-flow.h (swap_tree_operands): Prototype.\n+\t* Makefile.in (tree-ssa-reassoc.o): Update dependencies.\n+\n 2005-12-12  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* pa.c (pa_output_function_epilogue): Set cfun->machine->in_nsubspa to"}, {"sha": "3afa7b2e982cb79ca71679c78aa260739cf44f49", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -1975,7 +1975,8 @@ tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n tree-ssa-reassoc.o : tree-ssa-reassoc.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(GGC_H) $(DIAGNOSTIC_H) errors.h $(TIMEVAR_H) \\\n    $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) tree-iterator.h\\\n-   $(BASIC_BLOCK_H) $(HASHTAB_H) $(TREE_GIMPLE_H) tree-inline.h\n+   $(BASIC_BLOCK_H) $(TREE_GIMPLE_H) tree-inline.h vec.h \\\n+   alloc-pool.h\n tree-optimize.o : tree-optimize.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h $(DIAGNOSTIC_H) \\\n    $(FLAGS_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) toplev.h \\"}, {"sha": "7673c677a495f8a1730fd899a002ea36257a57b9", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -538,6 +538,7 @@ init_optimization_passes (void)\n      propagate away the degenerate PHI nodes.  */\n   NEXT_PASS (pass_phi_only_copy_prop);\n \n+  NEXT_PASS (pass_reassoc);\n   NEXT_PASS (pass_dce);\n   NEXT_PASS (pass_dse);\n   NEXT_PASS (pass_may_alias);\n@@ -553,10 +554,10 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_may_alias);\n   NEXT_PASS (pass_cse_reciprocals);\n   NEXT_PASS (pass_split_crit_edges);\n-  NEXT_PASS (pass_reassoc);\n   NEXT_PASS (pass_pre);\n   NEXT_PASS (pass_sink_code);\n   NEXT_PASS (pass_tree_loop);\n+  NEXT_PASS (pass_reassoc);\n   NEXT_PASS (pass_dominator);\n \n   /* The only copy propagation opportunities left after DOM"}, {"sha": "d2740e7e8147efd886c2ed9b1e4a45c51e99ff39", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -1,3 +1,18 @@\n+2005-12-12  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* gcc.dg/tree-ssa/ssa-pre-2.c: Update due to reassociation changes.\n+\t* gcc.dg/tree-ssa/reassoc-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/reassoc-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/reassoc-3.c: Likewise.\n+\t* gcc.dg/tree-ssa/reassoc-4.c: Likewise.\n+\t* gcc.dg/tree-ssa/reassoc-5.c: New.\n+\t* gcc.dg/tree-ssa/reassoc-6.c: New.\n+\t* gcc.dg/tree-ssa/reassoc-7.c: New.\n+\t* gcc.dg/tree-ssa/reassoc-8.c: New.\n+\t* gcc.dg/tree-ssa/reassoc-9.c: New.\n+\t* gcc.dg/tree-ssa/reassoc-10.c: New.\n+\t* gcc.dg/tree-ssa/reassoc-11.c: New.\n+\n 2005-12-12  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR testsuite/25167"}, {"sha": "166780adf87ffefc10d916b418799680e98fa8c4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-1.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -14,5 +14,5 @@ int main(void)\n   printf (\"%d %d\\n\", e, f);\n }\n \n-/* { dg-final { scan-tree-dump-times \"a \\\\\\+ b\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"b \\\\\\+ a\" 1 \"optimized\"} } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "cdc277431ea585a22ac8bf6bd7f5ed5ff024b696", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-10.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-10.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+int main(int a, int b, int c, int d)\n+{\n+  /* Should become just a & b & c & d */\n+  int e = (a & b) & (c & d);\n+  int f = (c & a) & (b & d);\n+  return e & f;\n+}\n+/* { dg-final { scan-tree-dump-times \"\\\\\\& \" 3 \"optimized\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "f48f04e9980e2ed5dd1759ad23703fdda6059592", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-11.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-11.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-reassoc1\" } */\n+int main(int a, int b, int c, int d)\n+{\n+  /* All the xor's cancel each other out, leaving 0  */\n+  int e = (a ^ b) ^ (c ^ d);\n+  int f = (c ^ a) ^ (b ^ d);\n+  return e ^ f;\n+}\n+/* { dg-final { scan-tree-dump-times \"= 0\" 1 \"reassoc1\"} } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "96be8cfe8579627053c23eda616d44cd53a5593a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-2.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-2.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -1,18 +1,17 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-reassoc-details\" } */\n-extern int a0, a1, a2, a3, a4; \n-int f () \n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+int f (int a0,int a1,int a2,int a3,int a4) \n { \n-int b0, b1, b2, b3, b4; \n+int b0, b1, b2, b3, b4,e; \n   /* this can be optimized to four additions... */ \n   b4 = a4 + a3 + a2 + a1 + a0; \n   b3 = a3 + a2 + a1 + a0; \n   b2 = a2 + a1 + a0; \n   b1 = a1 + a0; \n   /* This is actually 0 */\n-  return b4 - b3 + b2 - b1 - a4 - a2;\n-} \n-/* { dg-final { scan-tree-dump-times \"Reassociating by rank\" 3 \"reassoc\" } } */\n-/* { dg-final { scan-tree-dump-times \"return 0\" 1 \"optimized\" { xfail *-*-* } } } */\n+  e = b4 - b3 + b2 - b1 - a4 - a2;\n+  return e;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"return 0\" 1 \"optimized\" } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */\n-/* { dg-final { cleanup-tree-dump \"reassoc\" } } */"}, {"sha": "6103c400ecb61d7a54808afc8dfa1e9c69d11389", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-3.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-3.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -1,18 +1,6 @@\n-/* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdump-tree-optimized -ffast-math\" } */\n-float a, b, c, d;\n-extern int printf (const char *, ...);\n-int main(void)\n+int main(int a, int b, int c, int d)\n {\n-  float e;\n-  float f;\n-  /* We should be able to transform these into the same expression, and only have two additions.  */\n-  e = a + b;\n-  e = e + c;\n-  f = c + a;\n-  f = f + b;\n-  printf (\"%f %f\\n\", e, f);\n+  int e = (a & ~b) & (~c & d);\n+  int f = (~c & a) & (b & ~d);\n+ return (e & f);\n }\n-\n-/* { dg-final { scan-tree-dump-times \"\\\\\\+\" 2 \"optimized\"} } */\n-/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "8f9de464e8d3dc4742338a12d6f0902fdef4cfd5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-4.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -ffast-math\" } */\n float a, b, c, d;\n extern int printf (const char *, ...);\n int main(void)\n@@ -14,5 +14,5 @@ int main(void)\n   printf (\"%f %f\\n\", e, f);\n }\n \n-/* { dg-final { scan-tree-dump-times \"\\\\\\+\" 4 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"\\\\\\+\" 2 \"optimized\"} } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "8d168f90f93fe5031eefa2346f66436e86118084", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-5.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-5.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+extern int printf (const char *, ...);\n+int main(int argc, int b)\n+{\n+  /* We should be able to get rid of the a - i.  */\n+  int i;\n+  for (i = 0; i < 50; i++)\n+    {\n+      int a = b + i;\n+      int c = a - i;\n+      int d = argc + b;\n+      printf (\"%d %d\\n\", c,d);\n+    }\n+}\n+/* { dg-final { scan-tree-dump-times \"a - i\" 0 \"optimized\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "d7c8b818c9995d52135b26c739791d9820246d66", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-6.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-6.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-reassoc1\" } */\n+int main(int a, int b, int c, int d)\n+{\n+  /* Should be transformed into a + c + 8 */\n+  int e = a + 3;\n+  int f = c + 5;\n+  int g = e + f;\n+  return g;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\\\+ 8\" 1 \"reassoc1\"} } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "6b3b227029d1bc1c4078b5bcdb0c2202e6d68ca6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-7.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-7.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-reassoc1\" } */\n+int main(int a, int b, int c, int d, int e, int f, int g, int h)\n+{\n+  /* Should be transformed into a + c + d + e + g + 15 */\n+  int i = (a + 9) + (c + d);\n+  int j = (e + 4) + (2 + g);\n+  e = i + j;\n+  return e;\n+}\n+/* { dg-final { scan-tree-dump-times \"\\\\\\+ 15\" 1 \"reassoc1\"} } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "b2ca4ae0302bb351d227fd959f2a4223ffd4f71e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-8.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-8.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-reassoc1\" } */\n+\n+int main(int a, int b, int c, int d, int e, int f, int g, int h)\n+{\n+  /* e & ~e -> 0 */\n+  int i = (a & 9) & (c & d);\n+  int j = (~e & d) & (~c & e);\n+  e = i & j;\n+  return e;\n+}\n+/* { dg-final { scan-tree-dump-times \"= 0\" 1 \"reassoc1\"} } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "7fa9ff3f125dbe70b924bbc19579d342c104800f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-9.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-9.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-reassoc1\" } */\n+\n+int main(int a, int b, int c, int d, int e, int f, int g, int h)\n+{\n+  /* Should be transformed into e = 20 */\n+  int i = (a + 9) + (c + 8);\n+  int j = (-c + 1) + (-a + 2);\n+\n+  e = i + j;\n+  return e;\n+}\n+/* { dg-final { scan-tree-dump-times \"= 20\" 1 \"reassoc1\"} } */\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "38380d3d1857ce6de6b53a3da0f1c5a79995e16d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-2.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -16,6 +16,7 @@ int motion_test1(int data, int data_0, int data_3, int v)\n \treturn v * t * u;\n }\n /* We should eliminate one computation of data_0 + data_3 along the \n-   main path, causing one reload. */\n-/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+   main path, and one computation of v * i along the main path, causing \n+   two eliminations. */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 2\" 1 \"pre\"} } */\n /* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "4341d6f27a2845a49249e698b986376ca3532379", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -873,4 +873,6 @@ void delete_alias_heapvars (void);\n \n #include \"tree-flow-inline.h\"\n \n+void swap_tree_operands (tree, tree *, tree *);\n+\n #endif /* _TREE_FLOW_H  */"}, {"sha": "4997a1b3c055ce3a21b89466616d755a7a699e1c", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 54, "deletions": 93, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -588,6 +588,52 @@ struct tree_opt_pass pass_dominator =\n };\n \n \n+/* Given a stmt CONDSTMT containing a COND_EXPR, canonicalize the\n+   COND_EXPR into a canonical form.  */\n+\n+static void\n+canonicalize_comparison (tree condstmt)\n+{\n+  tree cond = COND_EXPR_COND (condstmt);\n+  tree op0;\n+  tree op1;\n+  enum tree_code code = TREE_CODE (cond);\n+\n+  if (!COMPARISON_CLASS_P (cond))\n+    return;\n+\n+  op0 = TREE_OPERAND (cond, 0);\n+  op1 = TREE_OPERAND (cond, 1);\n+\n+  /* If it would be profitable to swap the operands, then do so to\n+     canonicalize the statement, enabling better optimization.\n+\n+     By placing canonicalization of such expressions here we\n+     transparently keep statements in canonical form, even\n+     when the statement is modified.  */\n+  if (tree_swap_operands_p (op0, op1, false))\n+    {\n+      /* For relationals we need to swap the operands\n+\t and change the code.  */\n+      if (code == LT_EXPR\n+\t  || code == GT_EXPR\n+\t  || code == LE_EXPR\n+\t  || code == GE_EXPR)\n+\t{\n+\t  TREE_SET_CODE (cond, swap_tree_comparison (code));\n+\t  swap_tree_operands (condstmt,\n+\t\t\t      &TREE_OPERAND (cond, 0),\n+\t\t\t      &TREE_OPERAND (cond, 1));\n+\t  /* If one operand was in the operand cache, but the other is\n+\t     not, because it is a constant, this is a case that the\n+\t     internal updating code of swap_tree_operands can't handle\n+\t     properly.  */\n+\t  if (TREE_CODE_CLASS (TREE_CODE (op0)) \n+\t      != TREE_CODE_CLASS (TREE_CODE (op1)))\n+\t    update_stmt (condstmt);\n+\t}\n+    }\n+}\n /* We are exiting E->src, see if E->dest ends with a conditional\n    jump which has a known value when reached via E. \n \n@@ -799,7 +845,10 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n       /* Now temporarily cprop the operands and try to find the resulting\n \t expression in the hash tables.  */\n       if (TREE_CODE (stmt) == COND_EXPR)\n-\tcond = COND_EXPR_COND (stmt);\n+\t{\n+\t  canonicalize_comparison (stmt);\n+\t  cond = COND_EXPR_COND (stmt);\n+\t}\n       else if (TREE_CODE (stmt) == GOTO_EXPR)\n \tcond = GOTO_DESTINATION (stmt);\n       else\n@@ -1788,97 +1837,6 @@ simplify_rhs_and_lookup_avail_expr (tree stmt, int insert)\n \t}\n     }\n \n-  /* If we have z = (x OP C1), see if we earlier had x = y OP C2.\n-     If OP is associative, create and fold (y OP C2) OP C1 which\n-     should result in (y OP C3), use that as the RHS for the\n-     assignment.  Add minus to this, as we handle it specially below.  */\n-  if ((associative_tree_code (rhs_code) || rhs_code == MINUS_EXPR)\n-      && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n-      && num_imm_uses (TREE_OPERAND (rhs, 0)) == 1\n-      && is_gimple_min_invariant (TREE_OPERAND (rhs, 1)))\n-    {\n-      tree rhs_def_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 0));\n-\n-      /* If the statement defines an induction variable, do not propagate\n-\t its value, so that we do not create overlapping life ranges.  */\n-      if (simple_iv_increment_p (rhs_def_stmt))\n-\tgoto dont_fold_assoc;\n-\n-      /* See if the RHS_DEF_STMT has the same form as our statement.  */\n-      if (TREE_CODE (rhs_def_stmt) == MODIFY_EXPR)\n-\t{\n-\t  tree rhs_def_rhs = TREE_OPERAND (rhs_def_stmt, 1);\n-\t  enum tree_code rhs_def_code = TREE_CODE (rhs_def_rhs);\n-\n-\t  if ((rhs_code == rhs_def_code && unsafe_associative_fp_binop (rhs))\n-\t      || (rhs_code == PLUS_EXPR && rhs_def_code == MINUS_EXPR)\n-\t      || (rhs_code == MINUS_EXPR && rhs_def_code == PLUS_EXPR))\n-\t    {\n-\t      tree def_stmt_op0 = TREE_OPERAND (rhs_def_rhs, 0);\n-\t      tree def_stmt_op1 = TREE_OPERAND (rhs_def_rhs, 1);\n-\n-\t      if (TREE_CODE (def_stmt_op0) == SSA_NAME\n-\t\t  && ! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (def_stmt_op0)\n-\t\t  && is_gimple_min_invariant (def_stmt_op1))\n-\t\t{\n-\t\t  tree outer_const = TREE_OPERAND (rhs, 1);\n-\t\t  tree type = TREE_TYPE (TREE_OPERAND (stmt, 0));\n-\t\t  tree t;\n-\n-\t\t  /* If we care about correct floating point results, then\n-\t\t     don't fold x + c1 - c2.  Note that we need to take both\n-\t\t     the codes and the signs to figure this out.  */\n-\t\t  if (FLOAT_TYPE_P (type)\n-\t\t      && !flag_unsafe_math_optimizations\n-\t\t      && (rhs_def_code == PLUS_EXPR\n-\t\t\t  || rhs_def_code == MINUS_EXPR))\n-\t\t    {\n-\t\t      bool neg = false;\n-\n-\t\t      neg ^= (rhs_code == MINUS_EXPR);\n-\t\t      neg ^= (rhs_def_code == MINUS_EXPR);\n-\t\t      neg ^= real_isneg (TREE_REAL_CST_PTR (outer_const));\n-\t\t      neg ^= real_isneg (TREE_REAL_CST_PTR (def_stmt_op1));\n-\n-\t\t      if (neg)\n-\t\t\tgoto dont_fold_assoc;\n-\t\t    }\n-\n-\t\t  /* Ho hum.  So fold will only operate on the outermost\n-\t\t     thingy that we give it, so we have to build the new\n-\t\t     expression in two pieces.  This requires that we handle\n-\t\t     combinations of plus and minus.  */\n-\t\t  if (rhs_def_code != rhs_code)\n-\t\t    {\n-\t\t      if (rhs_def_code == MINUS_EXPR)\n-\t\t        t = build2 (MINUS_EXPR, type, outer_const, def_stmt_op1);\n-\t\t      else\n-\t\t        t = build2 (MINUS_EXPR, type, def_stmt_op1, outer_const);\n-\t\t      rhs_code = PLUS_EXPR;\n-\t\t    }\n-\t\t  else if (rhs_def_code == MINUS_EXPR)\n-\t\t    t = build2 (PLUS_EXPR, type, def_stmt_op1, outer_const);\n-\t\t  else\n-\t\t    t = build2 (rhs_def_code, type, def_stmt_op1, outer_const);\n-\t\t  t = local_fold (t);\n-\t\t  t = build2 (rhs_code, type, def_stmt_op0, t);\n-\t\t  t = local_fold (t);\n-\n-\t\t  /* If the result is a suitable looking gimple expression,\n-\t\t     then use it instead of the original for STMT.  */\n-\t\t  if (TREE_CODE (t) == SSA_NAME\n-\t\t      || (UNARY_CLASS_P (t)\n-\t\t\t  && TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME)\n-\t\t      || ((BINARY_CLASS_P (t) || COMPARISON_CLASS_P (t))\n-\t\t\t  && TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME\n-\t\t\t  && is_gimple_val (TREE_OPERAND (t, 1))))\n-\t\t    result = update_rhs_and_lookup_avail_expr (stmt, t, insert);\n-\t\t}\n-\t    }\n-\t}\n- dont_fold_assoc:;\n-    }\n-\n   /* Optimize *\"foo\" into 'f'.  This is done here rather than\n      in fold to avoid problems with stuff like &*\"foo\".  */\n   if (TREE_CODE (rhs) == INDIRECT_REF || TREE_CODE (rhs) == ARRAY_REF)\n@@ -2918,7 +2876,10 @@ optimize_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   bool may_have_exposed_new_symbols = false;\n \n   old_stmt = stmt = bsi_stmt (si);\n-\n+  \n+  if (TREE_CODE (stmt) == COND_EXPR)\n+    canonicalize_comparison (stmt);\n+  \n   update_stmt_if_modified (stmt);\n   ann = stmt_ann (stmt);\n   opt_stats.num_stmts++;"}, {"sha": "72c2d7108beff160c9d0c659e661ae857c16e1b8", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -1047,7 +1047,6 @@ swap_tree_operands (tree stmt, tree *exp0, tree *exp1)\n   *exp1 = op0;\n }\n \n-\n /* Recursively scan the expression pointed to by EXPR_P in statement referred\n    to by INFO.  FLAGS is one of the OPF_* constants modifying how to interpret\n    the operands found.  */\n@@ -1260,39 +1259,6 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n     case ASSERT_EXPR:\n     do_binary:\n       {\n-\ttree op0 = TREE_OPERAND (expr, 0);\n-\ttree op1 = TREE_OPERAND (expr, 1);\n-\n-\t/* If it would be profitable to swap the operands, then do so to\n-\t   canonicalize the statement, enabling better optimization.\n-\n-\t   By placing canonicalization of such expressions here we\n-\t   transparently keep statements in canonical form, even\n-\t   when the statement is modified.  */\n-\tif (tree_swap_operands_p (op0, op1, false))\n-\t  {\n-\t    /* For relationals we need to swap the operands\n-\t       and change the code.  */\n-\t    if (code == LT_EXPR\n-\t\t|| code == GT_EXPR\n-\t\t|| code == LE_EXPR\n-\t\t|| code == GE_EXPR)\n-\t      {\n-\t\tTREE_SET_CODE (expr, swap_tree_comparison (code));\n-\t\tswap_tree_operands (stmt,\n-\t\t\t\t    &TREE_OPERAND (expr, 0),\t\t\t\n-\t\t\t\t    &TREE_OPERAND (expr, 1));\n-\t      }\n-\t  \n-\t    /* For a commutative operator we can just swap the operands.  */\n-\t    else if (commutative_tree_code (code))\n-\t      {\n-\t\tswap_tree_operands (stmt,\n-\t\t\t\t    &TREE_OPERAND (expr, 0),\t\t\t\n-\t\t\t\t    &TREE_OPERAND (expr, 1));\n-\t      }\n-\t  }\n-\n \tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n \tget_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags);\n \treturn;"}, {"sha": "6f19408f0ac1df7ffb39eb4abfacd6625cf90de9", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1305, "deletions": 427, "changes": 1732, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e0ed594114997686efba9a45b8782ce87c465c3/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=0e0ed594114997686efba9a45b8782ce87c465c3", "patch": "@@ -33,249 +33,219 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-gimple.h\"\n #include \"tree-dump.h\"\n #include \"timevar.h\"\n-#include \"hashtab.h\"\n #include \"tree-iterator.h\"\n #include \"tree-pass.h\"\n+#include \"alloc-pool.h\"\n+#include \"vec.h\"\n+#include \"langhooks.h\"\n \n-/*  This is a simple global reassociation pass that uses a combination\n-    of heuristics and a hashtable to try to expose more operations to\n-    CSE.  \n+/*  This is a simple global reassociation pass.  It is, in part, based\n+    on the LLVM pass of the same name (They do some things more/less\n+    than we do, in different orders, etc).\n \n-    The basic idea behind the heuristic is to rank expressions by\n-    depth of the computation tree and loop depth, and try to produce\n-    expressions consisting of small rank operations, as they are more\n-    likely to reoccur.  In addition, we use a hashtable to try to see\n-    if we can transpose an operation into something we have seen\n-    before.\n+    It consists of five steps:\n \n-    Note that the way the hashtable is structured will sometimes find\n-    matches that will not expose additional redundancies, since it is\n-    not unwound as we traverse back up one branch of the dominator\n-    tree and down another.  However, the cost of improving this is\n-    probably not worth the additional benefits it will bring.  */\n+    1. Breaking up subtract operations into addition + negate, where\n+    it would promote the reassociation of adds.\n \n-/* Statistics */\n-static struct\n-{\n-  int reassociated_by_rank;\n-  int reassociated_by_match;\n-} reassociate_stats;\n+    2. Left linearization of the expression trees, so that (A+B)+(C+D)\n+    becomes (((A+B)+C)+D), which is easier for us to rewrite later.\n+    During linearization, we place the operands of the binary\n+    expressions into a vector of operand_entry_t\n \n+    3. Optimization of the operand lists, eliminating things like a +\n+    -a, a & a, etc.\n \n+    4. Rewrite the expression trees we linearized and optimized so\n+    they are in proper rank order.\n \n-/* Seen binary operator hashtable.  */\n-static htab_t seen_binops;\n+    5. Repropagate negates, as nothing else will clean it up ATM.\n \n-/* Binary operator struct. */\n+    A bit of theory on #4, since nobody seems to write anything down\n+    about why it makes sense to do it the way they do it:\n \n-typedef struct seen_binop_d\n-{\n-  tree op1;\n-  tree op2;\n-} *seen_binop_t;\n+    We could do this much nicer theoretically, but don't (for reasons\n+    explained after how to do it theoretically nice :P).\n \n-/* Return a SEEN_BINOP_T if we have seen an associative binary\n-   operator with OP1 and OP2 in it.  */\n+    In order to promote the most redundancy elimination, you want\n+    binary expressions whose operands are the same rank (or\n+    preferrably, the same value) exposed to the redundancy eliminator,\n+    for possible elimination.\n \n-static seen_binop_t\n-find_seen_binop (tree op1, tree op2)\n-{\n-  void **slot;\n-  struct seen_binop_d sbd;\n-  sbd.op1 = op1;\n-  sbd.op2 = op2;\n-  slot = htab_find_slot (seen_binops, &sbd, NO_INSERT);\n-  if (!slot)\n-    return NULL;\n-  return ((seen_binop_t) *slot);\n-}\n+    So the way to do this if we really cared, is to build the new op\n+    tree from the leaves to the roots, merging as you go, and putting the\n+    new op on the end of the worklist, until you are left with one\n+    thing on the worklist.\n \n-/* Insert a binary operator consisting of OP1 and OP2 into the\n-   SEEN_BINOP table.  */\n+    IE if you have to rewrite the following set of operands (listed with\n+    rank in parentheses), with opcode PLUS_EXPR:\n \n-static void\n-insert_seen_binop (tree op1, tree op2)\n-{\n-  void **slot;\n-  seen_binop_t new_pair = xmalloc (sizeof (*new_pair));\n-  new_pair->op1 = op1;\n-  new_pair->op2 = op2;\n-  slot = htab_find_slot (seen_binops, new_pair, INSERT);\n-  if (*slot != NULL)\n-    free (*slot);\n-  *slot = new_pair;\n-}\n+    a (1),  b (1),  c (1),  d (2), e (2)\n \n-/* Return the hash value for a seen binop structure pointed to by P.\n-   Because all the binops we consider are associative, we just add the\n-   hash value for op1 and op2.  */\n \n-static hashval_t\n-seen_binop_hash (const void *p)\n-{\n-  const seen_binop_t sb = (seen_binop_t) p;\n-  return iterative_hash_expr (sb->op1, 0) + iterative_hash_expr (sb->op2, 0);\n-}\n+    We start with our merge worklist empty, and the ops list with all of\n+    those on it.\n \n-/* Return true if two seen binop structures pointed to by P1 and P2 are equal.\n-   We have to check the operators both ways because we don't know what\n-   order they appear in the table.  */\n+    You want to first merge all leaves of the same rank, as much as\n+    possible.\n+\n+    So first build a binary op of\n+\n+    mergetmp = a + b, and put \"mergetmp\" on the merge worklist.\n+\n+    Because there is no three operand form of PLUS_EXPR, c is not going to\n+    be exposed to redundancy elimination as a rank 1 operand.\n+\n+    So you might as well throw it on the merge worklist (you could also\n+    consider it to now be a rank two operand, and merge it with d and e,\n+    but in this case, you then have evicted e from a binary op. So at\n+    least in this situation, you can't win.)\n+\n+    Then build a binary op of d + e\n+    mergetmp2 = d + e\n+\n+    and put mergetmp2 on the merge worklist.\n+    \n+    so merge worklist = {mergetmp, c, mergetmp2}\n+    \n+    Continue building binary ops of these operations until you have only\n+    one operation left on the worklist.\n+    \n+    So we have\n+    \n+    build binary op\n+    mergetmp3 = mergetmp + c\n+    \n+    worklist = {mergetmp2, mergetmp3}\n+    \n+    mergetmp4 = mergetmp2 + mergetmp3\n+    \n+    worklist = {mergetmp4}\n+    \n+    because we have one operation left, we can now just set the original\n+    statement equal to the result of that operation.\n+    \n+    This will at least expose a + b  and d + e to redundancy elimination\n+    as binary operations.\n+    \n+    For extra points, you can reuse the old statements to build the\n+    mergetmps, since you shouldn't run out.\n+\n+    So why don't we do this?\n+    \n+    Because it's expensive, and rarely will help.  Most trees we are\n+    reassociating have 3 or less ops.  If they have 2 ops, they already\n+    will be written into a nice single binary op.  If you have 3 ops, a\n+    single simple check suffices to tell you whether the first two are of the\n+    same rank.  If so, you know to order it\n+\n+    mergetmp = op1 + op2\n+    newstmt = mergetmp + op3\n+    \n+    instead of\n+    mergetmp = op2 + op3\n+    newstmt = mergetmp + op1\n+    \n+    If all three are of the same rank, you can't expose them all in a\n+    single binary operator anyway, so the above is *still* the best you\n+    can do.\n+    \n+    Thus, this is what we do.  When we have three ops left, we check to see\n+    what order to put them in, and call it a day.  As a nod to vector sum\n+    reduction, we check if any of ops are a really a phi node that is a\n+    destructive update for the associating op, and keep the destructive\n+    update together for vector sum reduction recognition.  */\n \n-static int\n-seen_binop_eq (const void *p1, const void *p2)\n-{\n-  const seen_binop_t sb1 = (seen_binop_t) p1;\n-  const seen_binop_t sb2 = (seen_binop_t) p2;\n-  return (sb1->op1 == sb2->op1 && sb1->op2 == sb2->op2)\n-    || (sb1->op2 == sb2->op1 && sb1->op1 == sb2->op2);\n-}\n \n-/* Value rank structure.  */\n+/* Statistics */\n+static struct\n+{\n+  int linearized;\n+  int constants_eliminated;\n+  int ops_eliminated;\n+  int rewritten;\n+} reassociate_stats;\n \n-typedef struct valrank_d\n+/* Operator, rank pair.  */\n+typedef struct operand_entry\n {\n-  tree e;   \n-  unsigned int rank;  \n-} *valrank_t;\n+  unsigned int rank;\n+  tree op;\n+} *operand_entry_t;\n+\n+static alloc_pool operand_entry_pool;\n+\n \n /* Starting rank number for a given basic block, so that we can rank\n    operations using unmovable instructions in that BB based on the bb\n    depth.  */\n static unsigned int *bb_rank;\n \n-/* Value rank hashtable.  */\n-static htab_t value_rank;\n+/* Operand->rank hashtable.  */\n+static htab_t operand_rank;\n \n \n-/* Look up the value rank structure for expression E.  */\n+/* Look up the operand rank structure for expression E.  */\n \n-static valrank_t\n-find_value_rank (tree e)\n+static operand_entry_t\n+find_operand_rank (tree e)\n {\n   void **slot;\n-  struct valrank_d vrd;\n-  vrd.e = e;\n-  slot = htab_find_slot (value_rank, &vrd, NO_INSERT);\n+  struct operand_entry vrd;\n+\n+  vrd.op = e;\n+  slot = htab_find_slot (operand_rank, &vrd, NO_INSERT);\n   if (!slot)\n     return NULL;\n-  return ((valrank_t) *slot);\n+  return ((operand_entry_t) *slot);\n }\n \n-/* Insert {E,RANK} into the value rank hashtable.  */\n+/* Insert {E,RANK} into the operand rank hashtable.  */\n \n static void\n-insert_value_rank (tree e, unsigned int rank)\n+insert_operand_rank (tree e, unsigned int rank)\n {\n   void **slot;\n-  valrank_t new_pair = xmalloc (sizeof (*new_pair));\n-  new_pair->e = e;\n+  operand_entry_t new_pair = pool_alloc (operand_entry_pool);\n+\n+  new_pair->op = e;\n   new_pair->rank = rank;\n-  slot = htab_find_slot (value_rank, new_pair, INSERT);\n+  slot = htab_find_slot (operand_rank, new_pair, INSERT);\n   gcc_assert (*slot == NULL);\n   *slot = new_pair;\n-\n }\n \n-\n-/* Return the hash value for a value rank structure  */\n+/* Return the hash value for a operand rank structure  */\n \n static hashval_t\n-valrank_hash (const void *p)\n+operand_entry_hash (const void *p)\n {\n-  const valrank_t vr = (valrank_t) p;\n-  return iterative_hash_expr (vr->e, 0);\n+  const operand_entry_t vr = (operand_entry_t) p;\n+  return iterative_hash_expr (vr->op, 0);\n }\n \n-/* Return true if two value rank structures are equal.  */\n+/* Return true if two operand rank structures are equal.  */\n \n static int\n-valrank_eq (const void *p1, const void *p2)\n-{\n-  const valrank_t vr1 = (valrank_t) p1;\n-  const valrank_t vr2 = (valrank_t) p2;\n-  return vr1->e == vr2->e;\n-}\n-\n-\n-/* Initialize the reassociation pass.  */\n-\n-static void\n-init_reassoc (void)\n+operand_entry_eq (const void *p1, const void *p2)\n {\n-  int i;\n-  unsigned int rank = 2;\n-  \n-  tree param;\n-  int *bbs = xmalloc ((last_basic_block + 1) * sizeof (int));\n-  \n-  memset (&reassociate_stats, 0, sizeof (reassociate_stats));\n-\n-  /* Reverse RPO (Reverse Post Order) will give us something where\n-     deeper loops come later.  */\n-  flow_reverse_top_sort_order_compute (bbs);\n-  bb_rank = xcalloc (last_basic_block + 1, sizeof (unsigned int));\n-  value_rank = htab_create (511, valrank_hash,\n-\t\t\t    valrank_eq, free);\n-  seen_binops = htab_create (511, seen_binop_hash,\n-\t\t\t     seen_binop_eq, free);\n-\n-  /* Give each argument a distinct rank.   */\n-  for (param = DECL_ARGUMENTS (current_function_decl);\n-       param;\n-       param = TREE_CHAIN (param))\n-    {\n-      if (default_def (param) != NULL)\n-\t{\n-\t  tree def = default_def (param);\n-\t  insert_value_rank (def, ++rank);\n-\t}\n-    }\n-  /* Give the chain decl a distinct rank. */\n-  if (cfun->static_chain_decl != NULL)\n-    {\n-      tree def = default_def (cfun->static_chain_decl);\n-      if (def != NULL)\n-        insert_value_rank (def, ++rank);\n-    }\n-  \n-  /* Set up rank for each BB  */\n-  for (i = 0; i < n_basic_blocks; i++)\n-    bb_rank[bbs[i]] = ++rank  << 16;\n-\n-  free (bbs);\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n+  const operand_entry_t vr1 = (operand_entry_t) p1;\n+  const operand_entry_t vr2 = (operand_entry_t) p2;\n+  return vr1->op == vr2->op;\n }\n \n-/* Cleanup after the reassociation pass, and print stats if\n-   requested.  */\n-\n-static void\n-fini_reassoc (void)\n-{\n-\n-  if (dump_file && (dump_flags & TDF_STATS))\n-    {\n-      fprintf (dump_file, \"Reassociation stats:\\n\");\n-      fprintf (dump_file, \"Reassociated by rank: %d\\n\", reassociate_stats.reassociated_by_rank);\n-      fprintf (dump_file, \"Reassociated by match: %d\\n\", reassociate_stats.reassociated_by_match);\n-    }\n-  htab_delete (value_rank);\n-  htab_delete (seen_binops);\n-  free (bb_rank);\n-}\n \n /* Given an expression E, return the rank of the expression.  */\n \n static unsigned int\n get_rank (tree e)\n {\n-  valrank_t vr;\n+  operand_entry_t vr;\n \n-  /* Constants have rank 0.  */  \n+  /* Constants have rank 0.  */\n   if (is_gimple_min_invariant (e))\n     return 0;\n-  \n+\n   /* SSA_NAME's have the rank of the expression they are the result\n      of.\n      For globals and uninitialized values, the rank is 0.\n@@ -290,24 +260,24 @@ get_rank (tree e)\n   if (TREE_CODE (e) == SSA_NAME)\n     {\n       tree stmt;\n-      tree rhs;      \n+      tree rhs;\n       unsigned int rank, maxrank;\n       int i;\n-      \n+\n       if (TREE_CODE (SSA_NAME_VAR (e)) == PARM_DECL\n \t  && e == default_def (SSA_NAME_VAR (e)))\n-\treturn find_value_rank (e)->rank;\n-      \n+\treturn find_operand_rank (e)->rank;\n+\n       stmt = SSA_NAME_DEF_STMT (e);\n       if (bb_for_stmt (stmt) == NULL)\n \treturn 0;\n-      \n+\n       if (TREE_CODE (stmt) != MODIFY_EXPR\n \t  || !ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n \treturn bb_rank[bb_for_stmt (stmt)->index];\n \n       /* If we already have a rank for this expression, use that.  */\n-      vr = find_value_rank (e);\n+      vr = find_operand_rank (e);\n       if (vr)\n \treturn vr->rank;\n \n@@ -318,307 +288,1216 @@ get_rank (tree e)\n       rhs = TREE_OPERAND (stmt, 1);\n       if (TREE_CODE_LENGTH (TREE_CODE (rhs)) == 0)\n \trank = MAX (rank, get_rank (rhs));\n-      else \n+      else\n \t{\n-\t  for (i = 0; \n-\t       i < TREE_CODE_LENGTH (TREE_CODE (rhs)) \n+\t  for (i = 0;\n+\t       i < TREE_CODE_LENGTH (TREE_CODE (rhs))\n \t\t && TREE_OPERAND (rhs, i)\n-\t\t && rank != maxrank; i++)\n+\t\t && rank != maxrank;\n+\t       i++)\n \t    rank = MAX(rank, get_rank (TREE_OPERAND (rhs, i)));\n \t}\n-      \n+\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Rank for \");\n \t  print_generic_expr (dump_file, e, 0);\n \t  fprintf (dump_file, \" is %d\\n\", (rank + 1));\n \t}\n-      \n+\n       /* Note the rank in the hashtable so we don't recompute it.  */\n-      insert_value_rank (e, (rank + 1));\n+      insert_operand_rank (e, (rank + 1));\n       return (rank + 1);\n     }\n \n   /* Globals, etc,  are rank 0 */\n   return 0;\n }\n \n+DEF_VEC_P(operand_entry_t);\n+DEF_VEC_ALLOC_P(operand_entry_t, heap);\n+\n+/* We want integer ones to end up last no matter what, since they are\n+   the ones we can do the most with.  */\n+#define INTEGER_CONST_TYPE 1 << 3\n+#define FLOAT_CONST_TYPE 1 << 2\n+#define OTHER_CONST_TYPE 1 << 1\n+\n+/* Classify an invariant tree into integer, float, or other, so that\n+   we can sort them to be near other constants of the same type.  */\n+static inline int\n+constant_type (tree t)\n+{\n+  if (INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+    return INTEGER_CONST_TYPE;\n+  else if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (t)))\n+    return FLOAT_CONST_TYPE;\n+  else\n+    return OTHER_CONST_TYPE;\n+}\n+\n+/* qsort comparison function to sort operand entries PA and PB by rank\n+   so that the sorted array is ordered by rank in decreasing order.  */\n+static int\n+sort_by_operand_rank (const void *pa, const void *pb)\n+{\n+  const operand_entry_t oea = *(const operand_entry_t *)pa;\n+  const operand_entry_t oeb = *(const operand_entry_t *)pb;\n+\n+  /* It's nicer for optimize_expression if constants that are likely\n+     to fold when added/multiplied//whatever are put next to each\n+     other.  Since all constants have rank 0, order them by type.  */\n+  if (oeb->rank == 0 &&  oea->rank == 0)\n+    return constant_type (oeb->op) - constant_type (oea->op);\n+\n+  /* Lastly, make sure the versions that are the same go next to each\n+     other.  We use SSA_NAME_VERSION because it's stable.  */\n+  if ((oeb->rank - oea->rank == 0)\n+      && TREE_CODE (oea->op) == SSA_NAME\n+      && TREE_CODE (oeb->op) == SSA_NAME)\n+    return SSA_NAME_VERSION (oeb->op) - SSA_NAME_VERSION (oea->op);\n+\n+  return oeb->rank - oea->rank;\n+}\n+\n+/* Add an operand entry to *OPS for the tree operand OP.  */\n+\n+static void\n+add_to_ops_vec (VEC(operand_entry_t, heap) **ops, tree op)\n+{\n+  operand_entry_t oe = pool_alloc (operand_entry_pool);\n+\n+  oe->op = op;\n+  oe->rank = get_rank (op);\n+  VEC_safe_push (operand_entry_t, heap, *ops, oe);\n+}\n \n-/* Decide whether we should transpose RHS and some operand of\n-   LHSDEFOP.\n-   If yes, then return true and set TAKEOP to the operand number of LHSDEFOP to\n-   switch RHS for.\n-   Otherwise, return false.  */\n+/* Return true if STMT is reassociable operation containing a binary\n+   operation with tree code CODE.  */\n \n static bool\n-should_transpose (tree rhs ATTRIBUTE_UNUSED, \n-\t\t  unsigned int rhsrank,\n-\t\t  tree lhsdefop, unsigned int *takeop)\n-{\n-  /* Attempt to expose the low ranked\n-     arguments to CSE if we have something like:\n-     a = <rank 2> + c (rank 1)\n-     b = a (rank 3) + d (rank 1)\n-     We want to transform this into:\n-     a = c + d\n-     b = <rank 2> + <rank 3>\n-     \n-     The op finding part wouldn't be necessary if\n-\t\t\t we could swap the operands above and not have\n-\t\t\t update_stmt change them back on us.\n-  */\n-  unsigned int lowrankop;\n-  unsigned int lowrank;\n-  unsigned int highrank;\n-  unsigned int highrankop;\n-  unsigned int temp;\n-  \n-  lowrankop = 0;\n-  *takeop = 1;\n-  lowrank = get_rank (TREE_OPERAND (lhsdefop, 0));\n-  temp = get_rank (TREE_OPERAND (lhsdefop, 1));\n-  highrank = temp;\n-  highrankop = 1;\n-  if (temp < lowrank)\n-    {\n-      lowrankop = 1;\n-      highrankop = 0;\n-      *takeop = 0;\n-      highrank = lowrank;\n-      lowrank = temp;\n-    }\n-  \n-  /* If highrank == lowrank, then we had something\n-     like:\n-     a = <rank 1> + <rank 1> \n-     already, so there is no guarantee that\n-     swapping our argument in is going to be\n-     better.\n-     If we run reassoc twice, we could probably\n-     have a flag that switches this behavior on,\n-     so that we try once without it, and once with\n-     it, so that redundancy elimination sees it\n-     both ways.\n-  */\t\t      \n-  \n-  if (lowrank == rhsrank && highrank != lowrank)\n+is_reassociable_op (tree stmt, enum tree_code code)\n+{\n+  if (!IS_EMPTY_STMT (stmt)\n+      && TREE_CODE (stmt) == MODIFY_EXPR\n+      && TREE_CODE (TREE_OPERAND (stmt, 1)) == code\n+      && has_single_use (TREE_OPERAND (stmt, 0)))\n     return true;\n+  return false;\n+}\n+\n+\n+/* Given NAME, if NAME is defined by a unary operation OPCODE, return the\n+   operand of the negate operation.  Otherwise, return NULL.  */\n+\n+static tree\n+get_unary_op (tree name, enum tree_code opcode)\n+{\n+  tree stmt = SSA_NAME_DEF_STMT (name);\n+  tree rhs;\n+\n+  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+    return NULL_TREE;\n+\n+  rhs = TREE_OPERAND (stmt, 1);\n+  if (TREE_CODE (rhs) == opcode)\n+    return TREE_OPERAND (rhs, 0);\n+  return NULL_TREE;\n+}\n+\n+/* If CURR and LAST are a pair of ops that OPCODE allows us to\n+   eliminate through equivalences, do so, remove them from OPS, and\n+   return true.  Otherwise, return false.  */\n+\n+static bool\n+eliminate_duplicate_pair (enum tree_code opcode,\n+\t\t\t  VEC (operand_entry_t, heap) **ops,\n+\t\t\t  bool *all_done,\n+\t\t\t  unsigned int i,\n+\t\t\t  operand_entry_t curr,\n+\t\t\t  operand_entry_t last)\n+{\n+\n+  /* If we have two of the same op, and the opcode is & or |, we can\n+     eliminate one of them.\n+     If we have two of the same op, and the opcode is ^, we can\n+     eliminate both of them.  */\n \n-  /* Also, see if the LHS's high ranked op should be switched with our\n-     RHS simply because it is greater in rank than our current RHS.  */\n-  if (TREE_CODE (TREE_OPERAND (lhsdefop, highrankop)) == SSA_NAME)\n+  if (last && last->op == curr->op)\n     {\n-      tree iop = SSA_NAME_DEF_STMT (TREE_OPERAND (lhsdefop, highrankop));\n-      if (TREE_CODE (iop) == MODIFY_EXPR)\n-\tiop = TREE_OPERAND (iop, 1);\n-      if (TREE_CODE (iop) == TREE_CODE (lhsdefop))\n-\t*takeop = 1;\n-      if (rhsrank < get_rank (TREE_OPERAND (lhsdefop, *takeop)))\n-\treturn true;\n-    }\t\t  \n-  \n+      switch (opcode)\n+\t{\n+\tcase BIT_IOR_EXPR:\n+\tcase BIT_AND_EXPR:\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Equivalence: \");\n+\t      print_generic_expr (dump_file, curr->op, 0);\n+\t      fprintf (dump_file, \" [&|] \");\n+\t      print_generic_expr (dump_file, last->op, 0);\n+\t      fprintf (dump_file, \" -> \");\n+\t      print_generic_stmt (dump_file, last->op, 0);\n+\t    }\n+\n+\t  VEC_ordered_remove (operand_entry_t, *ops, i);\n+\t  reassociate_stats.ops_eliminated ++;\n+\n+\t  return true;\n+\n+\tcase BIT_XOR_EXPR:\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Equivalence: \");\n+\t      print_generic_expr (dump_file, curr->op, 0);\n+\t      fprintf (dump_file, \" ^ \");\n+\t      print_generic_expr (dump_file, last->op, 0);\n+\t      fprintf (dump_file, \" -> nothing\\n\");\n+\t    }\n+\n+\t  reassociate_stats.ops_eliminated += 2;\n+\n+\t  if (VEC_length (operand_entry_t, *ops) == 2)\n+\t    {\n+\t      VEC_free (operand_entry_t, heap, *ops);\n+\t      *ops = NULL;\n+\t      add_to_ops_vec (ops, fold_convert (TREE_TYPE (last->op), \n+\t\t\t\t\t\t integer_zero_node));\n+\t      *all_done = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      VEC_ordered_remove (operand_entry_t, *ops, i-1);\n+\t      VEC_ordered_remove (operand_entry_t, *ops, i-1);\n+\t    }\n+\n+\t  return true;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n   return false;\n }\n \n-/* Attempt to reassociate the associative binary operator BEXPR, which\n-   is in the statement pointed to by CURRBSI.  Return true if we\n-   changed the statement.  */\n+/* If OPCODE is PLUS_EXPR, CURR->OP is really a negate expression,\n+   look in OPS for a corresponding positive operation to cancel it\n+   out.  If we find one, remove the other from OPS, replace\n+   OPS[CURRINDEX] with 0, and return true.  Otherwise, return\n+   false. */\n \n static bool\n-reassociate_expr (tree bexpr, block_stmt_iterator *currbsi)\n-{\n-  tree lhs = TREE_OPERAND (bexpr, 0);\n-  tree rhs = TREE_OPERAND (bexpr, 1);\n-  tree lhsdef;\n-  tree lhsi;\n-  bool changed = false;\n-  unsigned int lhsrank = get_rank (lhs);\n-  unsigned int rhsrank = get_rank (rhs);\n-\n-  /* If unsafe math optimizations we can do reassociation for non-integral\n-     types.  */\n-  if ((!INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n-       || !INTEGRAL_TYPE_P (TREE_TYPE (rhs)))\n-      && (!SCALAR_FLOAT_TYPE_P (TREE_TYPE (rhs))\n-\t  || !SCALAR_FLOAT_TYPE_P (TREE_TYPE(lhs))\n-\t  || !flag_unsafe_math_optimizations))\n+eliminate_plus_minus_pair (enum tree_code opcode,\n+\t\t\t   VEC (operand_entry_t, heap) **ops,\n+\t\t\t   unsigned int currindex,\n+\t\t\t   operand_entry_t curr)\n+{\n+  tree negateop;\n+  unsigned int i;\n+  operand_entry_t oe;\n+\n+  if (opcode != PLUS_EXPR || TREE_CODE (curr->op) != SSA_NAME)\n     return false;\n-    \n-  /* We want the greater ranked operand to be our \"LHS\" for simplicity\n-     sake.  There is no point in actually modifying the expression, as\n-     update_stmt will simply resort the operands anyway. */\n-  if (lhsrank < rhsrank)\n+\n+  negateop = get_unary_op (curr->op, NEGATE_EXPR);\n+  if (negateop == NULL_TREE)\n+    return false;\n+\n+  /* Any non-negated version will have a rank that is one less than\n+     the current rank.  So once we hit those ranks, if we don't find\n+     one, we can stop.  */\n+\n+  for (i = currindex + 1;\n+       VEC_iterate (operand_entry_t, *ops, i, oe)\n+       && oe->rank >= curr->rank - 1 ;\n+       i++)\n     {\n-      tree temp;\n-      unsigned int temp1;\n-      temp = lhs;\n-      lhs = rhs;\n-      rhs = temp;\n-      temp1 = lhsrank;\n-      lhsrank = rhsrank;\n-      rhsrank = temp1;\n+      if (oe->op == negateop)\n+\t{\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Equivalence: \");\n+\t      print_generic_expr (dump_file, negateop, 0);\n+\t      fprintf (dump_file, \" + -\");\n+\t      print_generic_expr (dump_file, oe->op, 0);\n+\t      fprintf (dump_file, \" -> 0\\n\");\n+\t    }\n+\n+\t  VEC_ordered_remove (operand_entry_t, *ops, i);\n+\t  add_to_ops_vec (ops, fold_convert(TREE_TYPE (oe->op), \n+\t\t\t\t\t    integer_zero_node));\n+\t  VEC_ordered_remove (operand_entry_t, *ops, currindex);\n+\t  reassociate_stats.ops_eliminated ++;\n+\n+\t  return true;\n+\t}\n     }\n \n-  /* If the high ranked operand is an SSA_NAME, and the binary\n-     operator is not something we've already seen somewhere else\n-     (i.e., it may be redundant), attempt to reassociate it.\n-     \n-     We can't reassociate expressions unless the expression we are\n-     going to reassociate with is only used in our current expression,\n-     or else we may screw up other computations, like so:\n-\n-     a = b + c\n-     e = a + d\n-     \n-     g = a + f\n-     \n-     We cannot reassociate and rewrite the \"a = ...\" , \n-     because that would change the value of the computation of \n-     \"g = a + f\".  */\n-  if (TREE_CODE (lhs) == SSA_NAME && !find_seen_binop (lhs, rhs))\n+  return false;\n+}\n+\n+/* If OPCODE is BIT_IOR_EXPR, BIT_AND_EXPR, and, CURR->OP is really a\n+   bitwise not expression, look in OPS for a corresponding operand to\n+   cancel it out.  If we find one, remove the other from OPS, replace\n+   OPS[CURRINDEX] with 0, and return true.  Otherwise, return\n+   false. */\n+\n+static bool\n+eliminate_not_pairs (enum tree_code opcode,\n+\t\t     VEC (operand_entry_t, heap) **ops,\n+\t\t     unsigned int currindex,\n+\t\t     operand_entry_t curr)\n+{\n+  tree notop;\n+  unsigned int i;\n+  operand_entry_t oe;\n+\n+  if ((opcode != BIT_IOR_EXPR && opcode != BIT_AND_EXPR)\n+      || TREE_CODE (curr->op) != SSA_NAME)\n+    return false;\n+\n+  notop = get_unary_op (curr->op, BIT_NOT_EXPR);\n+  if (notop == NULL_TREE)\n+    return false;\n+\n+  /* Any non-not version will have a rank that is one less than\n+     the current rank.  So once we hit those ranks, if we don't find\n+     one, we can stop.  */\n+\n+  for (i = currindex + 1;\n+       VEC_iterate (operand_entry_t, *ops, i, oe)\n+       && oe->rank >= curr->rank - 1;\n+       i++)\n     {\n-      lhsdef = SSA_NAME_DEF_STMT (lhs);\n-      if (TREE_CODE (lhsdef) == MODIFY_EXPR)\n+      if (oe->op == notop)\n \t{\n-\t  lhsi = TREE_OPERAND (lhsdef, 1);\n-\t  if (TREE_CODE (lhsi) == TREE_CODE (bexpr))\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n-\t      use_operand_p use;\n-\t      tree usestmt;\n-\t      if (single_imm_use (lhs, &use, &usestmt))\n-\t\t{\n-\t\t  unsigned int takeop = 0;\n-\t\t  unsigned int otherop = 1;\n-\t\t  bool foundmatch = false;\n-\t\t  bool foundrank = false;\n-\n-\t\t  /* If we can easily transpose this into an operation\n-\t\t     we've already seen, let's do that.\n-\t\t     otherwise, let's try to expose low ranked ops to\n-\t\t     CSE.  */\n-\t\t  if (find_seen_binop (TREE_OPERAND (lhsi, 1), rhs))\n-\t\t    {\n-\t\t      takeop = 0;\n-\t\t      otherop = 1;\n-\t\t      foundmatch = true;\n-\t\t    }\n-\t\t  else if (find_seen_binop (TREE_OPERAND (lhsi, 0),\n-\t\t\t\t\t    rhs))\n-\t\t    {\n-\t\t      takeop = 1;\n-\t\t      otherop = 0;\n-\t\t      foundmatch = true;\n-\t\t    }\n-\t\t  else if (should_transpose (rhs, rhsrank, lhsi,\n-\t\t\t\t\t     &takeop))\n-\t\t    {\n-\t\t      foundrank = true;\n-\t\t    }\t\t  \n-\t\t  if (foundmatch || foundrank)\n-\t\t    {\n-\t\t      block_stmt_iterator lhsbsi = bsi_for_stmt (lhsdef);\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t{\n-\t\t\t  fprintf (dump_file, \"Reassociating by %s\\n\",\n-\t\t\t\t   foundmatch ? \"match\" : \"rank\");\n-\t\t\t  fprintf (dump_file, \"Before LHS:\");\n-\t\t\t  print_generic_stmt (dump_file, lhsi, 0);\n-\t\t\t  fprintf (dump_file, \"Before curr expr:\");\n-\t\t\t  print_generic_stmt (dump_file, bexpr, 0);\n-\t\t\t}\n-\t\t      TREE_OPERAND (bexpr, 0) = TREE_OPERAND (lhsi, takeop);\n-\t\t      TREE_OPERAND (lhsi, takeop) = rhs;\n-\t\t      TREE_OPERAND (bexpr, 1) = TREE_OPERAND (lhsdef, 0);\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t{\n-\t\t\t  fprintf (dump_file, \"After LHS:\");\n-\t\t\t  print_generic_stmt (dump_file, lhsi, 0);\n-\t\t\t  fprintf (dump_file, \"After curr expr:\");\n-\t\t\t  print_generic_stmt (dump_file, bexpr, 0);\n-\t\t\t}\n-\t\t      bsi_move_before (&lhsbsi, currbsi);\n-\t\t      update_stmt (lhsdef);\n-\t\t      update_stmt (bsi_stmt (*currbsi));\n-\t\t      lhsbsi = bsi_for_stmt (lhsdef);\n-\t\t      update_stmt (bsi_stmt (lhsbsi));\n-\n-\t\t      /* If update_stmt didn't reorder our operands,\n-\t\t\t we'd like to recurse on the expression we\n-\t\t\t just reassociated and reassociate it\n-\t\t\t top-down, exposing further opportunities.\n-\t\t\t Unfortunately, update_stmt does reorder them,\n-\t\t\t so we can't do this cheaply.  */\n-\t\t      if (!foundmatch)\n-\t\t\treassociate_stats.reassociated_by_rank++;\n-\t\t      else\n-\t\t\treassociate_stats.reassociated_by_match++;\n-\t\t      return true;\n-\t\t    }\n-\t\t}\n+\t      fprintf (dump_file, \"Equivalence: \");\n+\t      print_generic_expr (dump_file, notop, 0);\n+\t      if (opcode == BIT_AND_EXPR)\n+\t\tfprintf (dump_file, \" & ~\");\n+\t      else if (opcode == BIT_IOR_EXPR)\n+\t\tfprintf (dump_file, \" | ~\");\n+\t      print_generic_expr (dump_file, oe->op, 0);\n+\t      if (opcode == BIT_AND_EXPR)\n+\t\tfprintf (dump_file, \" -> 0\\n\");\n+\t      else if (opcode == BIT_IOR_EXPR)\n+\t\tfprintf (dump_file, \" -> -1\\n\");\n \t    }\n+\n+\t  if (opcode == BIT_AND_EXPR)\n+\t    oe->op = fold_convert (TREE_TYPE (oe->op), integer_zero_node);\n+\t  else if (opcode == BIT_IOR_EXPR)\n+\t    oe->op = build_low_bits_mask (TREE_TYPE (oe->op),\n+\t\t\t\t\t  TYPE_PRECISION (TREE_TYPE (oe->op)));\n+\n+\t  reassociate_stats.ops_eliminated \n+\t    += VEC_length (operand_entry_t, *ops) - 1;\n+\t  VEC_free (operand_entry_t, heap, *ops);\n+\t  *ops = NULL;\n+\t  VEC_safe_push (operand_entry_t, heap, *ops, oe);\n+\t  return true;\n \t}\n     }\n-  return changed;\n+\n+  return false;\n }\n \n-/* Reassociate expressions in basic block BB and its dominator as\n-   children , return true if any\n-   expressions changed.  */\n+/* Use constant value that may be present in OPS to try to eliminate\n+   operands.  Note that this function is only really used when we've\n+   eliminated ops for other reasons, or merged constants.  Across\n+   single statements, fold already does all of this, plus more.  There\n+   is little point in duplicating logic, so I've only included the\n+   identities that I could ever construct testcases to trigger.  */\n \n-static bool\n-reassociate_bb (basic_block bb)\n+static void\n+eliminate_using_constants (enum tree_code opcode,\n+\t\t\t   VEC(operand_entry_t, heap) **ops)\n {\n-  bool changed = false;\n-  block_stmt_iterator bsi;\n-  basic_block son;\n+  operand_entry_t oelast = VEC_last (operand_entry_t, *ops);\n \n-  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+  if (oelast->rank == 0 && INTEGRAL_TYPE_P (TREE_TYPE (oelast->op)))\n     {\n-      tree stmt = bsi_stmt (bsi);\n-      \n-      if (TREE_CODE (stmt) == MODIFY_EXPR)\n+      switch (opcode)\n \t{\n-\t  tree rhs = TREE_OPERAND (stmt, 1);\n-\t  if (associative_tree_code (TREE_CODE (rhs)))\n+\tcase BIT_AND_EXPR:\n+\t  if (integer_zerop (oelast->op))\n+\t    {\n+\t      if (VEC_length (operand_entry_t, *ops) != 1)\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"Found & 0, removing all other ops\\n\");\n+\n+\t\t  reassociate_stats.ops_eliminated \n+\t\t    += VEC_length (operand_entry_t, *ops) - 1;\n+\t\t  \n+\t\t  VEC_free (operand_entry_t, heap, *ops);\n+\t\t  *ops = NULL;\n+\t\t  VEC_safe_push (operand_entry_t, heap, *ops, oelast);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  else if (integer_all_onesp (oelast->op))\n+\t    {\n+\t      if (VEC_length (operand_entry_t, *ops) != 1)\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"Found & -1, removing\\n\");\n+\t\t  VEC_pop (operand_entry_t, *ops);\n+\t\t  reassociate_stats.ops_eliminated++;\n+\t\t}\n+\t    }\n+\t  break;\n+\tcase BIT_IOR_EXPR:\n+\t  if (integer_all_onesp (oelast->op))\n+\t    {\n+\t      if (VEC_length (operand_entry_t, *ops) != 1)\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"Found | -1, removing all other ops\\n\");\n+\n+\t\t  reassociate_stats.ops_eliminated \n+\t\t    += VEC_length (operand_entry_t, *ops) - 1;\n+\t\t  \n+\t\t  VEC_free (operand_entry_t, heap, *ops);\n+\t\t  *ops = NULL;\n+\t\t  VEC_safe_push (operand_entry_t, heap, *ops, oelast);\n+\t\t  return;\n+\t\t}\n+\t    }\t  \n+\t  else if (integer_zerop (oelast->op))\n+\t    {\n+\t      if (VEC_length (operand_entry_t, *ops) != 1)\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"Found | 0, removing\\n\");\n+\t\t  VEC_pop (operand_entry_t, *ops);\n+\t\t  reassociate_stats.ops_eliminated++;\n+\t\t}\n+\t    }\n+\t  break;\n+\tcase MULT_EXPR:\n+\t  if (integer_zerop (oelast->op))\n+\t    {\n+\t      if (VEC_length (operand_entry_t, *ops) != 1)\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"Found * 0, removing all other ops\\n\");\n+\t\t  \n+\t\t  reassociate_stats.ops_eliminated \n+\t\t    += VEC_length (operand_entry_t, *ops) - 1;\n+\t\t  VEC_free (operand_entry_t, heap, *ops);\n+\t\t  *ops = NULL;\n+\t\t  VEC_safe_push (operand_entry_t, heap, *ops, oelast);\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  else if (integer_onep (oelast->op))\n+\t    {\n+\t      if (VEC_length (operand_entry_t, *ops) != 1)\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"Found * 1, removing\\n\");\n+\t\t  VEC_pop (operand_entry_t, *ops);\n+\t\t  reassociate_stats.ops_eliminated++;\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  break;\n+\tcase BIT_XOR_EXPR:\n+\tcase PLUS_EXPR:\n+\tcase MINUS_EXPR:\n+\t  if (integer_zerop (oelast->op))\n \t    {\n-\t      if (reassociate_expr (rhs, &bsi))\n+\t      if (VEC_length (operand_entry_t, *ops) != 1)\n \t\t{\n-\t\t  changed = true;\n-\t\t  update_stmt (stmt);\t\t  \n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"Found [|^+] 0, removing\\n\");\n+\t\t  VEC_pop (operand_entry_t, *ops);\n+\t\t  reassociate_stats.ops_eliminated++;\n+\t\t  return;\n \t\t}\n-\t      insert_seen_binop (TREE_OPERAND (rhs, 0),\n-\t\t\t\t TREE_OPERAND (rhs, 1));\n \t    }\n+\t  break;\n+\tdefault:\n+\t  break;\n \t}\n     }\n-  for (son = first_dom_son (CDI_DOMINATORS, bb);\n-       son;\n-       son = next_dom_son (CDI_DOMINATORS, son))\n-    {\n-      changed |= reassociate_bb (son);\n-    }\n-  return changed;  \n }\n \n-\t\n-static bool\n-do_reassoc (void)\n-{  \n-  bool changed = false;\n-  \n-  changed = reassociate_bb (ENTRY_BLOCK_PTR);\n+/* Perform various identities and other optimizations on the list of\n+   operand entries, stored in OPS.  The tree code for the binary\n+   operation between all the operands is OPCODE.  */\n \n-  return changed;  \n-}\n+static void\n+optimize_ops_list (enum tree_code opcode,\n+\t\t   VEC (operand_entry_t, heap) **ops)\n+{\n+  unsigned int length = VEC_length (operand_entry_t, *ops);\n+  unsigned int i;\n+  operand_entry_t oe;\n+  operand_entry_t oelast = NULL;\n+  bool iterate = false;\n \n+  if (length == 1)\n+    return;\n \n-/* Gate and execute functions for Reassociation.  */\n+  oelast = VEC_last (operand_entry_t, *ops);\n \n-static void\n-execute_reassoc (void)\n-{\n+  /* If the last two are constants, pop the constants off, merge them\n+     and try the next two.  */\n+  if (oelast->rank == 0 && is_gimple_min_invariant (oelast->op))\n+    {\n+      operand_entry_t oelm1 = VEC_index (operand_entry_t, *ops, length - 2);\n+\n+      if (oelm1->rank == 0\n+\t  && is_gimple_min_invariant (oelm1->op)\n+\t  && lang_hooks.types_compatible_p (TREE_TYPE (oelm1->op),\n+\t\t\t\t\t    TREE_TYPE (oelast->op)))\n+\t{\n+\t  tree folded = fold_build2 (opcode, TREE_TYPE (oelm1->op),\n+\t\t\t\t     oelm1->op, oelast->op);\n+\n+\t  if (is_gimple_min_invariant (folded))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"Merging constants\\n\");\n+\n+\t      VEC_pop (operand_entry_t, *ops);\n+\t      VEC_pop (operand_entry_t, *ops);\n+\n+\t      add_to_ops_vec (ops, folded);\n+\t      reassociate_stats.constants_eliminated++;\n+\n+\t      optimize_ops_list (opcode, ops);\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n+  eliminate_using_constants (opcode, ops);\n+  oelast = NULL;\n+\n+  for (i = 0; VEC_iterate (operand_entry_t, *ops, i, oe);)\n+    {\n+      bool done = false;\n+\n+      if (eliminate_not_pairs (opcode, ops, i, oe))\n+\treturn;\n+      if (eliminate_duplicate_pair (opcode, ops, &done, i, oe, oelast)\n+\t  || (!done && eliminate_plus_minus_pair (opcode, ops, i, oe)))\n+\t{\n+\t  if (done)\n+\t    return;\n+\t  iterate = true;\n+\t  oelast = NULL;\n+\t  continue;\n+\t}\n+      oelast = oe;\n+      i++;\n+    }\n+\n+  length  = VEC_length (operand_entry_t, *ops);\n+  oelast = VEC_last (operand_entry_t, *ops);\n+\n+  if (iterate)\n+    optimize_ops_list (opcode, ops);\n+}\n+\n+/* Return true if OPERAND is defined by a PHI node which uses the LHS\n+   of STMT in it's operands.  This is also known as a \"destructive\n+   update\" operation.  */\n+\n+static bool\n+is_phi_for_stmt (tree stmt, tree operand)\n+{\n+  tree def_stmt;\n+  tree lhs = TREE_OPERAND (stmt, 0);\n+  use_operand_p arg_p;\n+  ssa_op_iter i;\n+\n+  if (TREE_CODE (operand) != SSA_NAME)\n+    return false;\n+\n+  def_stmt = SSA_NAME_DEF_STMT (operand);\n+  if (TREE_CODE (def_stmt) != PHI_NODE)\n+    return false;\n+\n+  FOR_EACH_PHI_ARG (arg_p, def_stmt, i, SSA_OP_USE)\n+    if (lhs == USE_FROM_PTR (arg_p))\n+      return true;\n+  return false;\n+}\n+\n+/* Recursively rewrite our linearized statements so that the operators\n+   match those in OPS[OPINDEX], putting the computation in rank\n+   order.  */\n+\n+static void\n+rewrite_expr_tree (tree stmt, unsigned int opindex,\n+\t\t   VEC(operand_entry_t, heap) * ops)\n+{\n+  tree rhs = TREE_OPERAND (stmt, 1);\n+  operand_entry_t oe;\n+\n+  /* If we have three operands left, then we want to make sure the one\n+     that gets the double binary op are the ones with the same rank.\n+\n+     The alternative we try is to see if this is a destructive\n+     update style statement, which is like:\n+     b = phi (a, ...)\n+     a = c + b;\n+     In that case, we want to use the destructive update form to\n+     expose the possible vectorizer sum reduction opportunity.\n+     In that case, the third operand will be the phi node.\n+\n+     We could, of course, try to be better as noted above, and do a\n+     lot of work to try to find these opportunities in >3 operand\n+     cases, but it is unlikely to be worth it.  */\n+  if (opindex + 3 == VEC_length (operand_entry_t, ops))\n+    {\n+      operand_entry_t oe1, oe2, oe3;\n+\n+      oe1 = VEC_index (operand_entry_t, ops, opindex);\n+      oe2 = VEC_index (operand_entry_t, ops, opindex + 1);\n+      oe3 = VEC_index (operand_entry_t, ops, opindex + 2);\n+\n+      if ((oe1->rank == oe2->rank\n+\t   && oe2->rank != oe3->rank)\n+\t  || (is_phi_for_stmt (stmt, oe3->op)\n+\t      && !is_phi_for_stmt (stmt, oe1->op)\n+\t      && !is_phi_for_stmt (stmt, oe2->op)))\n+\t{\n+\t  struct operand_entry temp = *oe3;\n+\t  oe3->op = oe1->op;\n+\t  oe3->rank = oe1->rank;\n+\t  oe1->op = temp.op;\n+\t  oe1->rank= temp.rank;\n+\t}\n+    }\n+\n+  /* The final recursion case for this function is that you have\n+     exactly two operations left.\n+     If we had one exactly one op in the entire list to start with, we\n+     would have never called this function, and the tail recursion\n+     rewrites them one at a time.  */\n+  if (opindex + 2 == VEC_length (operand_entry_t, ops))\n+    {\n+      operand_entry_t oe1, oe2;\n+\n+      oe1 = VEC_index (operand_entry_t, ops, opindex);\n+      oe2 = VEC_index (operand_entry_t, ops, opindex + 1);\n+\n+      if (TREE_OPERAND (rhs, 0) != oe1->op\n+\t  || TREE_OPERAND (rhs, 1) != oe2->op)\n+\t{\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Transforming \");\n+\t      print_generic_expr (dump_file, rhs, 0);\n+\t    }\n+\n+\t  TREE_OPERAND (rhs, 0) = oe1->op;\n+\t  TREE_OPERAND (rhs, 1) = oe2->op;\n+\t  update_stmt (stmt);\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \" into \");\n+\t      print_generic_stmt (dump_file, rhs, 0);\n+\t    }\n+\n+\t}\n+      return;\n+    }\n+\n+  /* If we hit here, we should have 3 or more ops left.  */\n+  gcc_assert (opindex + 2 < VEC_length (operand_entry_t, ops));\n+\n+  /* Rewrite the next operator.  */\n+  oe = VEC_index (operand_entry_t, ops, opindex);\n+\n+  if (oe->op != TREE_OPERAND (rhs, 1))\n+    {\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Transforming \");\n+\t  print_generic_expr (dump_file, rhs, 0);\n+\t}\n+\n+      TREE_OPERAND (rhs, 1) = oe->op;\n+      update_stmt (stmt);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \" into \");\n+\t  print_generic_stmt (dump_file, rhs, 0);\n+\t}\n+    }\n+  /* Recurse on the LHS of the binary operator, which is guaranteed to\n+     be the non-leaf side.  */\n+  rewrite_expr_tree (SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 0)),\n+\t\t     opindex + 1, ops);\n+}\n+\n+/* Transform STMT, which is really (A +B) + (C + D) into the left\n+   linear form, ((A+B)+C)+D.\n+   Recurse on D if necessary.  */\n+\n+static void\n+linearize_expr (tree stmt)\n+{\n+  block_stmt_iterator bsinow, bsirhs;\n+  tree rhs = TREE_OPERAND (stmt, 1);\n+  enum tree_code rhscode = TREE_CODE (rhs);\n+  tree binrhs = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 1));\n+  tree binlhs = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 0));\n+  tree newbinrhs = NULL_TREE;\n+\n+  gcc_assert (is_reassociable_op (binlhs, TREE_CODE (rhs))\n+\t      && is_reassociable_op (binrhs, TREE_CODE (rhs)));\n+\n+  bsinow = bsi_for_stmt (stmt);\n+  bsirhs = bsi_for_stmt (binrhs);\n+  bsi_move_before (&bsirhs, &bsinow);\n+\n+  TREE_OPERAND (rhs, 1) = TREE_OPERAND (TREE_OPERAND (binrhs, 1), 0);\n+  if (TREE_CODE (TREE_OPERAND (rhs, 1)) == SSA_NAME)\n+    newbinrhs = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 1));\n+  TREE_OPERAND (TREE_OPERAND (binrhs, 1), 0) = TREE_OPERAND (binlhs, 0);\n+  TREE_OPERAND (rhs, 0) = TREE_OPERAND (binrhs, 0);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Linearized: \");\n+      print_generic_stmt (dump_file, rhs, 0);\n+    }\n+\n+  reassociate_stats.linearized++;\n+  update_stmt (binrhs);\n+  update_stmt (binlhs);\n+  update_stmt (stmt);\n+  TREE_VISITED (binrhs) = 1;\n+  TREE_VISITED (binlhs) = 1;\n+  TREE_VISITED (stmt) = 1;\n+\n+  /* Tail recurse on the new rhs if it still needs reassociation.  */\n+  if (newbinrhs && is_reassociable_op (newbinrhs, rhscode))\n+    linearize_expr (stmt);\n+\n+}\n+\n+/* If LHS has a single immediate use that is a MODIFY_EXPR, return\n+   it.  Otherwise, return NULL.  */\n+\n+static tree\n+get_single_immediate_use (tree lhs)\n+{\n+  use_operand_p immuse;\n+  tree immusestmt;\n+\n+  if (TREE_CODE (lhs) == SSA_NAME\n+      && single_imm_use (lhs, &immuse, &immusestmt))\n+    {\n+      if (TREE_CODE (immusestmt) == RETURN_EXPR)\n+\timmusestmt = TREE_OPERAND (immusestmt, 0);\n+      if (TREE_CODE (immusestmt) == MODIFY_EXPR)\n+\treturn immusestmt;\n+    }\n+  return NULL_TREE;\n+}\n+static VEC(tree, heap) *broken_up_subtracts;\n+\n+\n+/* Recursively negate the value of TONEGATE, and return the SSA_NAME\n+   representing the negated value.  Insertions of any necessary\n+   instructions go before BSI.\n+   This function is recursive in that, if you hand it \"a_5\" as the\n+   value to negate, and a_5 is defined by \"a_5 = b_3 + b_4\", it will\n+   transform b_3 + b_4 into a_5 = -b_3 + -b_4.  */\n+\n+static tree\n+negate_value (tree tonegate, block_stmt_iterator *bsi)\n+{\n+  tree negatedef = tonegate;\n+  tree resultofnegate;\n+\n+  if (TREE_CODE (tonegate) == SSA_NAME)\n+    negatedef = SSA_NAME_DEF_STMT (tonegate);\n+\n+  /* If we are trying to negate a name, defined by an add, negate the\n+     add operands instead.  */\n+  if (TREE_CODE (tonegate) == SSA_NAME\n+      && TREE_CODE (negatedef) == MODIFY_EXPR\n+      && TREE_CODE (TREE_OPERAND (negatedef, 0)) == SSA_NAME\n+      && num_imm_uses (TREE_OPERAND (negatedef, 0)) == 1\n+      && TREE_CODE (TREE_OPERAND (negatedef, 1)) == PLUS_EXPR)\n+    {\n+      block_stmt_iterator bsi;\n+      tree binop = TREE_OPERAND (negatedef, 1);\n+\n+      bsi = bsi_for_stmt (negatedef);\n+      TREE_OPERAND (binop, 0) = negate_value (TREE_OPERAND (binop, 0),\n+\t\t\t\t\t      &bsi);\n+      bsi = bsi_for_stmt (negatedef);\n+      TREE_OPERAND (binop, 1) = negate_value (TREE_OPERAND (binop, 1),\n+\t\t\t\t\t      &bsi);\n+      update_stmt (negatedef);\n+      return TREE_OPERAND (negatedef, 0);\n+    }\n+\n+  tonegate = fold_build1 (NEGATE_EXPR, TREE_TYPE (tonegate), tonegate);\n+  resultofnegate = force_gimple_operand_bsi (bsi, tonegate, true,\n+\t\t\t\t\t     NULL_TREE);\n+  VEC_safe_push (tree, heap, broken_up_subtracts, resultofnegate);\n+  return resultofnegate;\n+\n+}\n+\n+/* Return true if we should break up the subtract in STMT into an add\n+   with negate.  This is true when we the subtract operands are really\n+   adds, or the subtract itself is used in an add expression.  In\n+   either case, breaking up the subtract into an add with negate\n+   exposes the adds to reassociation.  */\n+\n+static bool\n+should_break_up_subtract (tree stmt)\n+{\n+\n+  tree lhs = TREE_OPERAND (stmt, 0);\n+  tree rhs = TREE_OPERAND (stmt, 1);\n+  tree binlhs = TREE_OPERAND (rhs, 0);\n+  tree binrhs = TREE_OPERAND (rhs, 1);\n+  tree immusestmt;\n+\n+  if (TREE_CODE (binlhs) == SSA_NAME\n+      && is_reassociable_op (SSA_NAME_DEF_STMT (binlhs), PLUS_EXPR))\n+    return true;\n+\n+  if (TREE_CODE (binrhs) == SSA_NAME\n+      && is_reassociable_op (SSA_NAME_DEF_STMT (binrhs), PLUS_EXPR))\n+    return true;\n+\n+  if (TREE_CODE (lhs) == SSA_NAME\n+      && (immusestmt = get_single_immediate_use (lhs))\n+      && TREE_CODE (TREE_OPERAND (immusestmt, 1)) == PLUS_EXPR)\n+    return true;\n+  return false;\n+\n+}\n+\n+/* Transform STMT from A - B into A + -B.  */\n+\n+static void\n+break_up_subtract (tree stmt, block_stmt_iterator *bsi)\n+{\n+  tree rhs = TREE_OPERAND (stmt, 1);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Breaking up subtract \");\n+      print_generic_stmt (dump_file, stmt, 0);\n+    }\n+\n+  TREE_SET_CODE (TREE_OPERAND (stmt, 1), PLUS_EXPR);\n+  TREE_OPERAND (rhs, 1) = negate_value (TREE_OPERAND (rhs, 1), bsi);\n+\n+  update_stmt (stmt);\n+}\n+\n+/* Recursively linearize a binary expression that is the RHS of STMT.\n+   Place the operands of the expression tree in the vector named OPS.  */\n+\n+static void\n+linearize_expr_tree (VEC(operand_entry_t, heap) **ops, tree stmt)\n+{\n+  block_stmt_iterator bsinow, bsilhs;\n+  tree rhs = TREE_OPERAND (stmt, 1);\n+  tree binrhs = TREE_OPERAND (rhs, 1);\n+  tree binlhs = TREE_OPERAND (rhs, 0);\n+  tree binlhsdef, binrhsdef;\n+  bool binlhsisreassoc = false;\n+  bool binrhsisreassoc = false;\n+  enum tree_code rhscode = TREE_CODE (rhs);\n+\n+  TREE_VISITED (stmt) = 1;\n+\n+  if (TREE_CODE (binlhs) == SSA_NAME)\n+    {\n+      binlhsdef = SSA_NAME_DEF_STMT (binlhs);\n+      binlhsisreassoc = is_reassociable_op (binlhsdef, rhscode);\n+    }\n+\n+  if (TREE_CODE (binrhs) == SSA_NAME)\n+    {\n+      binrhsdef = SSA_NAME_DEF_STMT (binrhs);\n+      binrhsisreassoc = is_reassociable_op (binrhsdef, rhscode);\n+    }\n+\n+  /* If the LHS is not reassociable, but the RHS is, we need to swap\n+     them.  If neither is reassociable, there is nothing we can do, so\n+     just put them in the ops vector.  If the LHS is reassociable,\n+     linearize it.  If both are reassociable, then linearize the RHS\n+     and the LHS.  */\n+\n+  if (!binlhsisreassoc)\n+    {\n+      tree temp;\n+\n+      if (!binrhsisreassoc)\n+\t{\n+\t  add_to_ops_vec (ops, binrhs);\n+\t  add_to_ops_vec (ops, binlhs);\n+\t  return;\n+\t}\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"swapping operands of \");\n+\t  print_generic_expr (dump_file, stmt, 0);\n+\t}\n+\n+      swap_tree_operands (stmt, &TREE_OPERAND (rhs, 0),\n+\t\t\t  &TREE_OPERAND (rhs, 1));\n+      update_stmt (stmt);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \" is now \");\n+\t  print_generic_stmt (dump_file, stmt, 0);\n+\t}\n+\n+      /* We want to make it so the lhs is always the reassociative op,\n+\t so swap.  */\n+      temp = binlhs;\n+      binlhs = binrhs;\n+      binrhs = temp;\n+    }\n+  else if (binrhsisreassoc)\n+    {\n+      linearize_expr (stmt);\n+      gcc_assert (rhs == TREE_OPERAND (stmt, 1));\n+      binlhs = TREE_OPERAND (rhs, 0);\n+      binrhs = TREE_OPERAND (rhs, 1);\n+    }\n+\n+  gcc_assert (TREE_CODE (binrhs) != SSA_NAME\n+\t      || !is_reassociable_op (SSA_NAME_DEF_STMT (binrhs), rhscode));\n+  bsinow = bsi_for_stmt (stmt);\n+  bsilhs = bsi_for_stmt (SSA_NAME_DEF_STMT (binlhs));\n+  bsi_move_before (&bsilhs, &bsinow);\n+  linearize_expr_tree (ops, SSA_NAME_DEF_STMT (binlhs));\n+  add_to_ops_vec (ops, binrhs);\n+}\n+\n+/* Repropagate the negates back into subtracts, since no other pass\n+   currently does it.  */\n+\n+static void\n+repropagate_negates (void)\n+{\n+  unsigned int i = 0;\n+  tree negate;\n+\n+  for (i = 0; VEC_iterate (tree, broken_up_subtracts, i, negate); i++)\n+    {\n+      tree user = get_single_immediate_use (negate);\n+\n+      /* The negate operand can be either operand of a PLUS_EXPR\n+\t (it can be the LHS if the RHS is a constant for example).\n+\n+\t Force the negate operand to the RHS of the PLUS_EXPR, then\n+\t transform the PLUS_EXPR into a MINUS_EXPR.  */\n+      if (user\n+\t  && TREE_CODE (user) == MODIFY_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (user, 1)) == PLUS_EXPR)\n+\t{\n+\t  tree rhs = TREE_OPERAND (user, 1);\n+\n+\t  /* If the negated operand appears on the LHS of the\n+\t     PLUS_EXPR, exchange the operands of the PLUS_EXPR\n+\t     to force the negated operand to the RHS of the PLUS_EXPR.  */\n+\t  if (TREE_OPERAND (TREE_OPERAND (user, 1), 0) == negate)\n+\t    {\n+\t      tree temp = TREE_OPERAND (rhs, 0);\n+\t      TREE_OPERAND (rhs, 0) = TREE_OPERAND (rhs, 1);\n+\t      TREE_OPERAND (rhs, 1) = temp;\n+\t    }\n+\n+\t  /* Now transform the PLUS_EXPR into a MINUS_EXPR and replace\n+\t     the RHS of the PLUS_EXPR with the operand of the NEGATE_EXPR.  */\n+\t  if (TREE_OPERAND (TREE_OPERAND (user, 1), 1) == negate)\n+\t    {\n+\t      TREE_SET_CODE (rhs, MINUS_EXPR);\n+\t      TREE_OPERAND (rhs, 1) = get_unary_op (negate, NEGATE_EXPR);\n+\t      update_stmt (user);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Break up subtract operations in block BB.\n+\n+   We do this top down because we don't know whether the subtract is\n+   part of a possible chain of reassociation except at the top.\n+ \n+   IE given\n+   d = f + g\n+   c = a + e\n+   b = c - d\n+   q = b - r\n+   k = t - q\n+   \n+   we want to break up k = t - q, but we won't until we've transformed q\n+   = b - r, which won't be broken up until we transform b = c - d.  */\n+\n+static void\n+break_up_subtract_bb (basic_block bb)\n+{\n+  block_stmt_iterator bsi;\n+  basic_block son;\n+\n+  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      tree stmt = bsi_stmt (bsi);\n+\n+      if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t{\n+\t  tree lhs = TREE_OPERAND (stmt, 0);\n+\t  tree rhs = TREE_OPERAND (stmt, 1);\n+\n+\t  TREE_VISITED (stmt) = 0;\n+\t  /* If unsafe math optimizations we can do reassociation for\n+\t     non-integral types.  */\n+\t  if ((!INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t       || !INTEGRAL_TYPE_P (TREE_TYPE (rhs)))\n+\t      && (!SCALAR_FLOAT_TYPE_P (TREE_TYPE (rhs))\n+\t\t  || !SCALAR_FLOAT_TYPE_P (TREE_TYPE(lhs))\n+\t\t  || !flag_unsafe_math_optimizations))\n+\t    continue;\n+\n+\t  /* Check for a subtract used only in an addition.  If this\n+\t     is the case, transform it into add of a negate for better\n+\t     reassociation.  IE transform C = A-B into C = A + -B if C\n+\t     is only used in an addition.  */\n+\t  if (TREE_CODE (rhs) == MINUS_EXPR)\n+\t    if (should_break_up_subtract (stmt))\n+\t      break_up_subtract (stmt, &bsi);\n+\t}\n+    }\n+  for (son = first_dom_son (CDI_DOMINATORS, bb);\n+       son;\n+       son = next_dom_son (CDI_DOMINATORS, son))\n+    break_up_subtract_bb (son);\n+}\n+\n+/* Reassociate expressions in basic block BB and its post-dominator as\n+   children.  */\n+\n+static void\n+reassociate_bb (basic_block bb)\n+{\n+  block_stmt_iterator bsi;\n+  basic_block son;\n+\n+  for (bsi = bsi_last (bb); !bsi_end_p (bsi); bsi_prev (&bsi))\n+    {\n+      tree stmt = bsi_stmt (bsi);\n+\n+      if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t{\n+\t  tree lhs = TREE_OPERAND (stmt, 0);\n+\t  tree rhs = TREE_OPERAND (stmt, 1);\n+\n+\t  /* If this was part of an already processed tree, we don't\n+\t     need to touch it again. */\n+\t  if (TREE_VISITED (stmt))\n+\t    continue;\n+\n+\t  /* If unsafe math optimizations we can do reassociation for\n+\t     non-integral types.  */\n+\t  if ((!INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n+\t       || !INTEGRAL_TYPE_P (TREE_TYPE (rhs)))\n+\t      && (!SCALAR_FLOAT_TYPE_P (TREE_TYPE (rhs))\n+\t\t  || !SCALAR_FLOAT_TYPE_P (TREE_TYPE(lhs))\n+\t\t  || !flag_unsafe_math_optimizations))\n+\t    continue;\n+\n+\t  if (associative_tree_code (TREE_CODE (rhs)))\n+\t    {\n+\t      VEC(operand_entry_t, heap) *ops = NULL;\n+\n+\t      /* There may be no immediate uses left by the time we\n+\t\t get here because we may have eliminated them all.  */\n+\t      if (TREE_CODE (lhs) == SSA_NAME && num_imm_uses (lhs) == 0)\n+\t\tcontinue;\n+\n+\t      TREE_VISITED (stmt) = 1;\n+\t      linearize_expr_tree (&ops, stmt);\n+\t      qsort (VEC_address (operand_entry_t, ops),\n+\t\t     VEC_length (operand_entry_t, ops),\n+\t\t     sizeof (operand_entry_t),\n+\t\t     sort_by_operand_rank);\n+\t      optimize_ops_list (TREE_CODE (rhs), &ops);\n+\n+\t      if (VEC_length (operand_entry_t, ops) == 1)\n+\t\t{\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file, \"Transforming \");\n+\t\t      print_generic_expr (dump_file, rhs, 0);\n+\t\t    }\n+\t\t  TREE_OPERAND (stmt, 1) = VEC_last (operand_entry_t, ops)->op;\n+\t\t  update_stmt (stmt);\n+\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    {\n+\t\t      fprintf (dump_file, \" into \");\n+\t\t      print_generic_stmt (dump_file,\n+\t\t\t\t\t  TREE_OPERAND (stmt, 1), 0);\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rewrite_expr_tree (stmt, 0, ops);\n+\t\t}\n+\n+\t      VEC_free (operand_entry_t, heap, ops);\n+\t    }\n+\t}\n+    }\n+  for (son = first_dom_son (CDI_POST_DOMINATORS, bb);\n+       son;\n+       son = next_dom_son (CDI_POST_DOMINATORS, son))\n+    reassociate_bb (son);\n+}\n+\n+void dump_ops_vector (FILE *file, VEC (operand_entry_t, heap) *ops);\n+void debug_ops_vector (VEC (operand_entry_t, heap) *ops);\n+\n+/* Dump the operand entry vector OPS to FILE.  */\n+\n+void\n+dump_ops_vector (FILE *file, VEC (operand_entry_t, heap) *ops)\n+{\n+  operand_entry_t oe;\n+  unsigned int i;\n+\n+  for (i = 0; VEC_iterate (operand_entry_t, ops, i, oe); i++)\n+    {\n+      fprintf (file, \"Op %d -> rank: %d, tree: \", i, oe->rank);\n+      print_generic_stmt (file, oe->op, 0);\n+    }\n+}\n+\n+/* Dump the operand entry vector OPS to STDERR.  */\n+\n+void\n+debug_ops_vector (VEC (operand_entry_t, heap) *ops)\n+{\n+  dump_ops_vector (stderr, ops);\n+}\n+\n+static void\n+do_reassoc (void)\n+{\n+  break_up_subtract_bb (ENTRY_BLOCK_PTR);\n+  reassociate_bb (EXIT_BLOCK_PTR);\n+}\n+\n+/* Initialize the reassociation pass.  */\n+\n+static void\n+init_reassoc (void)\n+{\n+  int i;\n+  unsigned int rank = 2;\n+  tree param;\n+  int *bbs = xmalloc ((last_basic_block + 1) * sizeof (int));\n+\n+  memset (&reassociate_stats, 0, sizeof (reassociate_stats));\n+\n+  operand_entry_pool = create_alloc_pool (\"operand entry pool\",\n+\t\t\t\t\t  sizeof (struct operand_entry), 30);\n+\n+  /* Reverse RPO (Reverse Post Order) will give us something where\n+     deeper loops come later.  */\n+  flow_depth_first_order_compute (NULL, bbs);\n+  bb_rank = xcalloc (last_basic_block + 1, sizeof (unsigned int));\n+  \n+  operand_rank = htab_create (511, operand_entry_hash,\n+\t\t\t      operand_entry_eq, 0);\n+\n+  /* Give each argument a distinct rank.   */\n+  for (param = DECL_ARGUMENTS (current_function_decl);\n+       param;\n+       param = TREE_CHAIN (param))\n+    {\n+      if (default_def (param) != NULL)\n+\t{\n+\t  tree def = default_def (param);\n+\t  insert_operand_rank (def, ++rank);\n+\t}\n+    }\n+\n+  /* Give the chain decl a distinct rank. */\n+  if (cfun->static_chain_decl != NULL)\n+    {\n+      tree def = default_def (cfun->static_chain_decl);\n+      if (def != NULL)\n+\tinsert_operand_rank (def, ++rank);\n+    }\n+\n+  /* Set up rank for each BB  */\n+  for (i = 0; i < n_basic_blocks; i++)\n+    bb_rank[bbs[i]] = ++rank  << 16;\n+\n+  free (bbs);\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+  broken_up_subtracts = NULL;\n+}\n+\n+/* Cleanup after the reassociation pass, and print stats if\n+   requested.  */\n+\n+static void\n+fini_reassoc (void)\n+{\n+\n+  if (dump_file && (dump_flags & TDF_STATS))\n+    {\n+      fprintf (dump_file, \"Reassociation stats:\\n\");\n+      fprintf (dump_file, \"Linearized: %d\\n\", \n+\t       reassociate_stats.linearized);\n+      fprintf (dump_file, \"Constants eliminated: %d\\n\",\n+\t       reassociate_stats.constants_eliminated);\n+      fprintf (dump_file, \"Ops eliminated: %d\\n\",\n+\t       reassociate_stats.ops_eliminated);\n+      fprintf (dump_file, \"Statements rewritten: %d\\n\",\n+\t       reassociate_stats.rewritten);\n+    }\n+  htab_delete (operand_rank);\n+\n+  free_alloc_pool (operand_entry_pool);\n+  free (bb_rank);\n+  VEC_free (tree, heap, broken_up_subtracts);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+}\n+\n+/* Gate and execute functions for Reassociation.  */\n+\n+static void\n+execute_reassoc (void)\n+{\n   init_reassoc ();\n+\n   do_reassoc ();\n+  repropagate_negates ();\n+\n   fini_reassoc ();\n }\n \n@@ -635,7 +1514,6 @@ struct tree_opt_pass pass_reassoc =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa | TODO_dump_func \n-  | TODO_ggc_collect | TODO_verify_ssa, /* todo_flags_finish */\n+  TODO_dump_func | TODO_ggc_collect | TODO_verify_ssa, /* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };"}]}