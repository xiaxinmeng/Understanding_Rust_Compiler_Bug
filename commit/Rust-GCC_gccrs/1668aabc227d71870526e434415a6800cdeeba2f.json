{"sha": "1668aabc227d71870526e434415a6800cdeeba2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY2OGFhYmMyMjdkNzE4NzA1MjZlNDM0NDE1YTY4MDBjZGVlYmEyZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-06-23T21:11:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-06-23T21:11:44Z"}, "message": "cgraph.c (cgraph_nodes_queue): Declare.\n\n\n\t* cgraph.c (cgraph_nodes_queue): Declare.\n\t(eq_node): Take identifier as p2.\n\t(cgraph_node): Update htab_find_slot_with_hash call.\n\t(cgraph_node_for_identifier): New.\n\t(cgraph_mark_needed_node): Move here from cgraphunit.c.\n\t* cgraph.h (cgraph_nodes_queue): Declare.\n\t(cgraph_node_for_identifier): Declare.\n\t* cgraphunit.c (cgraph_finalize_function): Collect entry points here\n\tinstead of in cgraph_finalize_compilation_unit; constructors and\n\tdestructors are entry points.\n\t(cgraph_finalize_compilation_unit): Reorganize debug outout;\n\texamine nested functions after lowerng; call collect_functions hook.\n\t(cgraph_mark_local_functions): DECL_COMDAT functions are not local.\n\t(cgraph_finalize_compilation_unit): Do not collect entry points.\n\t* varasm.c: Include cgraph.h\n\t(assemble_name): Mark referenced identifier as needed.\n\n\t* cgraphunit.c (record_call_1): Use get_callee_fndecl.\n\nFrom-SVN: r68390", "tree": {"sha": "a308ac6242dd91f73480ea940c0237afcc47f134", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a308ac6242dd91f73480ea940c0237afcc47f134"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1668aabc227d71870526e434415a6800cdeeba2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1668aabc227d71870526e434415a6800cdeeba2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1668aabc227d71870526e434415a6800cdeeba2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1668aabc227d71870526e434415a6800cdeeba2f/comments", "author": null, "committer": null, "parents": [{"sha": "89ce1c8f763e1c3485d97d3c8c74f75f94bf0e09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89ce1c8f763e1c3485d97d3c8c74f75f94bf0e09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89ce1c8f763e1c3485d97d3c8c74f75f94bf0e09"}], "stats": {"total": 202, "additions": 136, "deletions": 66}, "files": [{"sha": "ee9dab63280a327ea437eb38bec9e8fdea3ecdef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1668aabc227d71870526e434415a6800cdeeba2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1668aabc227d71870526e434415a6800cdeeba2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1668aabc227d71870526e434415a6800cdeeba2f", "patch": "@@ -1,3 +1,24 @@\n+Mon Jun 23 23:07:35 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_nodes_queue): Declare.\n+\t(eq_node): Take identifier as p2.\n+\t(cgraph_node): Update htab_find_slot_with_hash call.\n+\t(cgraph_node_for_identifier): New.\n+\t(cgraph_mark_needed_node): Move here from cgraphunit.c.\n+\t* cgraph.h (cgraph_nodes_queue): Declare.\n+\t(cgraph_node_for_identifier): Declare.\n+\t* cgraphunit.c (cgraph_finalize_function): Collect entry points here\n+\tinstead of in cgraph_finalize_compilation_unit; constructors and\n+\tdestructors are entry points.\n+\t(cgraph_finalize_compilation_unit): Reorganize debug outout; \n+\texamine nested functions after lowerng; call collect_functions hook.\n+\t(cgraph_mark_local_functions): DECL_COMDAT functions are not local.\n+\t(cgraph_finalize_compilation_unit): Do not collect entry points.\n+\t* varasm.c: Include cgraph.h\n+\t(assemble_name): Mark referenced identifier as needed.\n+\n+\t* cgraphunit.c (record_call_1): Use get_callee_fndecl.\n+\n 2003-06-23  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.c (x86_output_mi_thunk): Don't pass MEM to %P0,"}, {"sha": "b5753a12831dbd651d9e4a3fa958aa9f8c175468", "filename": "gcc/cgraph.c", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1668aabc227d71870526e434415a6800cdeeba2f/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1668aabc227d71870526e434415a6800cdeeba2f/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=1668aabc227d71870526e434415a6800cdeeba2f", "patch": "@@ -48,6 +48,9 @@ static htab_t cgraph_hash = 0;\n /* The linked list of cgraph nodes.  */\n struct cgraph_node *cgraph_nodes;\n \n+/* Queue of cgraph nodes scheduled to be lowered.  */\n+struct cgraph_node *cgraph_nodes_queue;\n+\n /* Number of nodes in existence.  */\n int cgraph_n_nodes;\n \n@@ -79,7 +82,7 @@ eq_node (p1, p2)\n      const void *p2;\n {\n   return ((DECL_ASSEMBLER_NAME (((struct cgraph_node *) p1)->decl)) ==\n-\t  DECL_ASSEMBLER_NAME ((tree) p2));\n+\t  (tree) p2);\n }\n \n /* Return cgraph node assigned to DECL.  Create new one when needed.  */\n@@ -100,7 +103,8 @@ cgraph_node (decl)\n     }\n \n   slot =\n-    (struct cgraph_node **) htab_find_slot_with_hash (cgraph_hash, decl,\n+    (struct cgraph_node **) htab_find_slot_with_hash (cgraph_hash,\n+\t\t\t\t\t\t      DECL_ASSEMBLER_NAME (decl),\n \t\t\t\t\t\t      htab_hash_pointer\n \t\t\t\t\t\t      (DECL_ASSEMBLER_NAME\n \t\t\t\t\t\t       (decl)), 1);\n@@ -125,6 +129,30 @@ cgraph_node (decl)\n   return node;\n }\n \n+/* Try to find existing function for identifier ID.  */\n+struct cgraph_node *\n+cgraph_node_for_identifier (id)\n+     tree id;\n+{\n+  struct cgraph_node **slot;\n+\n+  if (TREE_CODE (id) != IDENTIFIER_NODE)\n+    abort ();\n+\n+  if (!cgraph_hash)\n+    {\n+      cgraph_hash = htab_create (10, hash_node, eq_node, NULL);\n+      VARRAY_TREE_INIT (known_fns, 32, \"known_fns\");\n+    }\n+\n+  slot =\n+    (struct cgraph_node **) htab_find_slot_with_hash (cgraph_hash, id,\n+\t\t\t\t\t\t      htab_hash_pointer (id), 0);\n+  if (!slot)\n+    return NULL;\n+  return *slot;\n+}\n+\n /* Create edge from CALLER to CALLEE in the cgraph.  */\n \n static struct cgraph_edge *\n@@ -194,6 +222,28 @@ cgraph_remove_node (node)\n   /* Do not free the structure itself so the walk over chain can continue.  */\n }\n \n+/* Notify finalize_compilation_unit that given node is reachable\n+   or needed.  */\n+void\n+cgraph_mark_needed_node (node, needed)\n+     struct cgraph_node *node;\n+     int needed;\n+{\n+  if (needed)\n+    {\n+      node->needed = 1;\n+    }\n+  if (!node->reachable)\n+    {\n+      node->reachable = 1;\n+      if (DECL_SAVED_TREE (node->decl))\n+\t{\n+\t  node->aux = cgraph_nodes_queue;\n+\t  cgraph_nodes_queue = node;\n+        }\n+    }\n+}\n+\n \n /* Record call from CALLER to CALLEE  */\n "}, {"sha": "d29e190dbfd86c7c203422f99e2096a34768ecd5", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1668aabc227d71870526e434415a6800cdeeba2f/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1668aabc227d71870526e434415a6800cdeeba2f/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=1668aabc227d71870526e434415a6800cdeeba2f", "patch": "@@ -100,13 +100,15 @@ struct cgraph_edge\n extern struct cgraph_node *cgraph_nodes;\n extern int cgraph_n_nodes;\n extern bool cgraph_global_info_ready;\n+extern struct cgraph_node *cgraph_nodes_queue;\n \n /* In cgraph.c  */\n void dump_cgraph\t\t\tPARAMS ((FILE *));\n void cgraph_remove_call\t\t\tPARAMS ((tree, tree));\n void cgraph_remove_node\t\t\tPARAMS ((struct cgraph_node *));\n struct cgraph_edge *cgraph_record_call\tPARAMS ((tree, tree));\n struct cgraph_node *cgraph_node\t\tPARAMS ((tree decl));\n+struct cgraph_node *cgraph_node_for_identifier\tPARAMS ((tree id));\n bool cgraph_calls_p\t\t\tPARAMS ((tree, tree));\n struct cgraph_local_info *cgraph_local_info PARAMS ((tree));\n struct cgraph_global_info *cgraph_global_info PARAMS ((tree));"}, {"sha": "9fc5dd036b039f6e7f907bc2b1273c982a234111", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 50, "deletions": 63, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1668aabc227d71870526e434415a6800cdeeba2f/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1668aabc227d71870526e434415a6800cdeeba2f/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=1668aabc227d71870526e434415a6800cdeeba2f", "patch": "@@ -55,7 +55,29 @@ cgraph_finalize_function (decl, body)\n \n   node->decl = decl;\n \n-  node->local.can_inline_once = tree_inlinable_function_p (decl, 1);\n+  if (/* Externally visible functions must be output.  The exception are\n+\t COMDAT functions that must be output only when they are needed.\n+\t Similarly are handled defered functions and\n+\t external functions (GCC extension \"extern inline\") */\n+      (TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n+      /* ??? Constructors and destructors not called otherwise can be inlined\n+\t into single construction/destruction function per section to save some\n+\t resources.  For now just mark it as reachable.  */\n+      || DECL_STATIC_CONSTRUCTOR (decl)\n+      || DECL_STATIC_DESTRUCTOR (decl)\n+      /* Function whose name is output to the assembler file must be produced.\n+\t It is possible to assemble the name later after finalizing the function\n+\t and the fact is noticed in assemble_name then.  */\n+      || (DECL_ASSEMBLER_NAME_SET_P (decl)\n+\t  && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n+    {\n+      cgraph_mark_needed_node (node, 1);\n+    }\n+\n+  if (!node->needed && !DECL_COMDAT (node->decl))\n+    node->local.can_inline_once = tree_inlinable_function_p (decl, 1);\n+  else\n+    node->local.can_inline_once = 0;\n   if (flag_inline_trees)\n     node->local.inline_many = tree_inlinable_function_p (decl, 0);\n   else\n@@ -64,33 +86,6 @@ cgraph_finalize_function (decl, body)\n   (*debug_hooks->deferred_inline_function) (decl);\n }\n \n-static struct cgraph_node *queue = NULL;\n-\n-/* Notify finalize_compilation_unit that given node is reachable\n-   or needed.  */\n-\n-void\n-cgraph_mark_needed_node (node, needed)\n-     struct cgraph_node *node;\n-     int needed;\n-{\n-  if (needed)\n-    {\n-      if (DECL_SAVED_TREE (node->decl))\n-        announce_function (node->decl);\n-      node->needed = 1;\n-    }\n-  if (!node->reachable)\n-    {\n-      node->reachable = 1;\n-      if (DECL_SAVED_TREE (node->decl))\n-\t{\n-\t  node->aux = queue;\n-\t  queue = node;\n-        }\n-    }\n-}\n-\n /* Walk tree and record all calls.  Called via walk_tree.  */\n static tree\n record_call_1 (tp, walk_subtrees, data)\n@@ -108,15 +103,8 @@ record_call_1 (tp, walk_subtrees, data)\n     }\n   else if (TREE_CODE (*tp) == CALL_EXPR)\n     {\n-      /* We cannot use get_callee_fndecl here because it actually tries\n-\t too hard to get the function declaration, looking for indirect\n-\t references and stripping NOPS.  As a result, get_callee_fndecl\n-\t finds calls that shouldn't be in the call graph.  */\n-\n-      tree decl = TREE_OPERAND (*tp, 0);\n-      if (TREE_CODE (decl) == ADDR_EXPR)\n-\tdecl = TREE_OPERAND (decl, 0);\n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n+      tree decl = get_callee_fndecl (*tp);\n+      if (decl && TREE_CODE (decl) == FUNCTION_DECL)\n \t{\n \t  if (DECL_BUILT_IN (decl))\n \t    return NULL;\n@@ -156,40 +144,31 @@ cgraph_finalize_compilation_unit ()\n   struct cgraph_node *node;\n   struct cgraph_edge *edge;\n \n-  /* Collect entry points to the unit.  */\n-\n   if (!quiet_flag)\n-    fprintf (stderr, \"\\n\\nUnit entry points:\");\n-\n-  for (node = cgraph_nodes; node; node = node->next)\n     {\n-      tree decl = node->decl;\n-\n-      if (!DECL_SAVED_TREE (decl))\n-\tcontinue;\n-      if ((TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n-\t  || (DECL_ASSEMBLER_NAME_SET_P (decl)\n-\t      && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n-\t{\n-\t  /* This function can be called from outside this compliation\n-\t     unit, so it most definitely is needed.  */\n-\t  cgraph_mark_needed_node (node, 1);\n-\t}\n+      fprintf (stderr, \"\\n\\nInitial entry points:\");\n+      for (node = cgraph_nodes; node; node = node->next)\n+\tif (node->needed && DECL_SAVED_TREE (node->decl))\n+\t  announce_function (node->decl);\n     }\n \n   /* Propagate reachability flag and lower representation of all reachable\n      functions.  In the future, lowering will introduce new functions and\n      new entry points on the way (by template instantiation and virtual\n      method table generation for instance).  */\n-  while (queue)\n+  while (cgraph_nodes_queue)\n     {\n-      tree decl = queue->decl;\n+      tree decl = cgraph_nodes_queue->decl;\n+\n+      node = cgraph_nodes_queue;\n+      cgraph_nodes_queue = cgraph_nodes_queue->aux;\n \n-      node = queue;\n-      queue = queue->aux;\n       if (node->lowered || !node->reachable || !DECL_SAVED_TREE (decl))\n \tabort ();\n \n+      if (lang_hooks.callgraph.lower_function)\n+\t(*lang_hooks.callgraph.lower_function) (decl);\n+\n       /* At the moment frontend automatically emits all nested functions.  */\n       if (node->nested)\n \t{\n@@ -200,9 +179,6 @@ cgraph_finalize_compilation_unit ()\n \t      cgraph_mark_needed_node (node2, 0);\n \t}\n \n-      if (lang_hooks.callgraph.lower_function)\n-\t(*lang_hooks.callgraph.lower_function) (decl);\n-\n       /* First kill forward declaration so reverse inling works properly.  */\n       cgraph_create_edges (decl, DECL_SAVED_TREE (decl));\n \n@@ -213,6 +189,15 @@ cgraph_finalize_compilation_unit ()\n \t}\n       node->lowered = true;\n     }\n+  /* Collect entry points to the unit.  */\n+\n+  if (!quiet_flag)\n+    {\n+      fprintf (stderr, \"\\n\\nUnit entry points:\");\n+      for (node = cgraph_nodes; node; node = node->next)\n+\tif (node->needed && DECL_SAVED_TREE (node->decl))\n+\t  announce_function (node->decl);\n+    }\n \n   if (!quiet_flag)\n     fprintf (stderr, \"\\n\\nReclaiming functions:\");\n@@ -248,7 +233,8 @@ cgraph_mark_functions_to_output ()\n \t  && (node->needed\n \t      || (!node->local.inline_many && !node->global.inline_once\n \t\t  && node->reachable)\n-\t      || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n+\t      || (DECL_ASSEMBLER_NAME_SET_P (decl)\n+\t          && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n \t  && !TREE_ASM_WRITTEN (decl) && !node->origin\n \t  && !DECL_EXTERNAL (decl))\n \tnode->output = 1;\n@@ -331,7 +317,7 @@ cgraph_expand_functions ()\n   for (node = cgraph_nodes; node; node = node->next)\n     node->aux = NULL;\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->output && !node->aux)\n+    if (!node->aux)\n       {\n \tnode2 = node;\n \tif (!node->callers)\n@@ -400,6 +386,7 @@ cgraph_mark_local_functions ()\n     {\n       node->local.local = (!node->needed\n \t\t           && DECL_SAVED_TREE (node->decl)\n+\t\t\t   && !DECL_COMDAT (node->decl)\n \t\t           && !TREE_PUBLIC (node->decl));\n       if (node->local.local)\n \tannounce_function (node->decl);"}, {"sha": "a464e328b83a3b4293b5518c9a944837351fb626", "filename": "gcc/varasm.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1668aabc227d71870526e434415a6800cdeeba2f/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1668aabc227d71870526e434415a6800cdeeba2f/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=1668aabc227d71870526e434415a6800cdeeba2f", "patch": "@@ -48,6 +48,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm_p.h\"\n #include \"debug.h\"\n #include \"target.h\"\n+#include \"cgraph.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\t\t/* Needed for external data\n@@ -1742,7 +1743,16 @@ assemble_name (file, name)\n \n   id = maybe_get_identifier (real_name);\n   if (id)\n-    TREE_SYMBOL_REFERENCED (id) = 1;\n+    {\n+      if (!TREE_SYMBOL_REFERENCED (id)\n+\t  && !cgraph_global_info_ready)\n+\t{\n+\t  struct cgraph_node *node = cgraph_node_for_identifier (id);\n+\t  if (node)\n+\t    cgraph_mark_needed_node (node, 1);\n+\t}\n+      TREE_SYMBOL_REFERENCED (id) = 1;\n+    }\n \n   if (name[0] == '*')\n     fputs (&name[1], file);"}]}