{"sha": "f7185d479171342a33ffc2bc76226e86d400a785", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcxODVkNDc5MTcxMzQyYTMzZmZjMmJjNzYyMjZlODZkNDAwYTc4NQ==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-10-15T10:35:00Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-10-15T10:35:00Z"}, "message": "In libobjc/: 2010-10-14 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn libobjc/:\n2010-10-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * init.c (__objc_init_protocol): New function which fixes up a\n        protocol's class pointer, registers it with the runtime, register\n        all protocol selectors and registers associated protocols too.\n        (objc_init_statics): Detect if we are initializing protocols, and\n        if so, use __objc_init_protocol instead of only fixing up the\n        class pointer.\n        (__objc_init_protocls): Use __objc_init_protocol.\n        * objc-private/module-abi-8.h: Updated comments.\n        * objc-private/runtime.h\n        (__objc_register_selectors_from_description_list): New.\n        * selector.c (__objc_register_selectors_from_description_list):\n        New.  (struct objc_method_description_list): Declare.\n        * Protocol.m ([-descriptionForInstanceMethod:]): Use sel_get_name\n        when accessing the name of a method, which is now correctly a SEL.\n        ([-descriptionForClassMethod:]): Same change.\n        * protocols.c (protocol_getMethodDescription): Same change.\n        * objc/runtime.h: Updated comments.\n        (sel_registerTypedName): Fixed typo in function name.\n\nFrom-SVN: r165499", "tree": {"sha": "25c0b3362de3f254c6fe9987ea63d4a668631f87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25c0b3362de3f254c6fe9987ea63d4a668631f87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7185d479171342a33ffc2bc76226e86d400a785", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7185d479171342a33ffc2bc76226e86d400a785", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7185d479171342a33ffc2bc76226e86d400a785", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7185d479171342a33ffc2bc76226e86d400a785/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fbbf834e27301ed73f079d0311a2f6d53d78d908", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbbf834e27301ed73f079d0311a2f6d53d78d908", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbbf834e27301ed73f079d0311a2f6d53d78d908"}], "stats": {"total": 194, "additions": 152, "deletions": 42}, "files": [{"sha": "7bcf3ffca2869f832a1981efea602e05ada9899c", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=f7185d479171342a33ffc2bc76226e86d400a785", "patch": "@@ -1,3 +1,24 @@\n+2010-10-14  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* init.c (__objc_init_protocol): New function which fixes up a\n+\tprotocol's class pointer, registers it with the runtime, register\n+\tall protocol selectors and registers associated protocols too.\n+\t(objc_init_statics): Detect if we are initializing protocols, and\n+\tif so, use __objc_init_protocol instead of only fixing up the\n+\tclass pointer.\n+\t(__objc_init_protocls): Use __objc_init_protocol.\n+\t* objc-private/module-abi-8.h: Updated comments.\n+\t* objc-private/runtime.h\n+\t(__objc_register_selectors_from_description_list): New.\n+\t* selector.c (__objc_register_selectors_from_description_list):\n+\tNew.  (struct objc_method_description_list): Declare.\n+\t* Protocol.m ([-descriptionForInstanceMethod:]): Use sel_get_name\n+\twhen accessing the name of a method, which is now correctly a SEL.\n+\t([-descriptionForClassMethod:]): Same change.\n+\t* protocols.c (protocol_getMethodDescription): Same change.\n+\t* objc/runtime.h: Updated comments.\n+\t(sel_registerTypedName): Fixed typo in function name.\n+\t\n 2010-10-13  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tPR libobjc/23214"}, {"sha": "e8bb9442ac49904f7add654b272d09f5a0588fb2", "filename": "libobjc/Protocol.m", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2FProtocol.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2FProtocol.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FProtocol.m?ref=f7185d479171342a33ffc2bc76226e86d400a785", "patch": "@@ -85,7 +85,7 @@ - (struct objc_method_description *) descriptionForInstanceMethod:(SEL)aSel\n   if (instance_methods)\n     for (i = 0; i < instance_methods->count; i++)\n       {\n-\tif (!strcmp ((char*)instance_methods->list[i].name, name))\n+\tif (!strcmp (sel_get_name (instance_methods->list[i].name), name))\n \t  return &(instance_methods->list[i]);\n       }\n \n@@ -113,7 +113,7 @@ - (struct objc_method_description *) descriptionForClassMethod:(SEL)aSel;\n   if (class_methods)\n     for (i = 0; i < class_methods->count; i++)\n       {\n-\tif (!strcmp ((char*)class_methods->list[i].name, name))\n+\tif (!strcmp (sel_get_name (class_methods->list[i].name), name))\n \t  return &(class_methods->list[i]);\n       }\n "}, {"sha": "33fb7979ef7b32d928fa07f50a118d78717ba448", "filename": "libobjc/init.c", "status": "modified", "additions": 69, "deletions": 23, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Finit.c?ref=f7185d479171342a33ffc2bc76226e86d400a785", "patch": "@@ -32,7 +32,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"objc-private/objc-list.h\" \n #include \"objc-private/runtime.h\"\n #include \"objc-private/objc-sync.h\" /* For __objc_sync_init() */\n-#include \"objc-private/protocols.h\" /* For __objc_protocols_init() and __objc_protocols_add_protocol() */\n+#include \"objc-private/protocols.h\" /* For __objc_protocols_init(),\n+\t\t\t\t       __objc_protocols_add_protocol()\n+\t\t\t\t       __objc_protocols_register_selectors() */\n \n /* The version number of this runtime.  This must match the number \n    defined in gcc (objc-act.c).  */\n@@ -70,6 +72,9 @@ static void init_check_module_version (Module_t);\n /* Assign isa links to protos.  */\n static void __objc_init_protocols (struct objc_protocol_list *protos);\n \n+/* Assign isa link to a protocol, and register it.  */\n+static void __objc_init_protocol (struct objc_protocol *protocol);\n+\n /* Add protocol to class.  */\n static void __objc_class_add_protocols (Class, struct objc_protocol_list *);\n \n@@ -490,11 +495,27 @@ objc_init_statics (void)\n \t\t they were attached to classes or categories, and the\n \t\t class/category loading code automatically fixes them\n \t\t up), and some of them may not.  We really need to go\n-\t\t through the whole list to be sure!  */\n+\t\t through the whole list to be sure!  Protocols are\n+\t\t also special because we want to register them and\n+\t\t register all their selectors.  */\n \t      id *inst;\n \n-\t      for (inst = &statics->instances[0]; *inst; inst++)\n-\t\t(*inst)->class_pointer = class;\n+\t      if (strcmp (statics->class_name, \"Protocol\") == 0)\n+\t\t{\n+\t\t  /* Protocols are special, because not only we want\n+\t\t     to fix up their class pointers, but we also want\n+\t\t     to register them and their selectors with the\n+\t\t     runtime.  */\n+\t\t  for (inst = &statics->instances[0]; *inst; inst++)\n+\t\t    __objc_init_protocol ((struct objc_protocol *)*inst);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Other static instances (typically constant strings) are\n+\t\t     easier as we just fix up their class pointers.  */\n+\t\t  for (inst = &statics->instances[0]; *inst; inst++)\t\t  \n+\t\t    (*inst)->class_pointer = class;\n+\t\t}\n \t    }\n \t}\n       if (module_initialized)\n@@ -843,6 +864,49 @@ init_check_module_version (Module_t module)\n     }\n }\n \n+/* __objc_init_protocol must be called with __objc_runtime_mutex\n+   already locked, and the \"Protocol\" class already registered.  */\n+static void\n+__objc_init_protocol (struct objc_protocol *protocol)\n+{\n+  static Class proto_class = 0;\n+\n+  if (! proto_class)\n+    proto_class = objc_get_class (\"Protocol\");\n+\n+  if (((size_t)protocol->class_pointer) == PROTOCOL_VERSION)\n+    {\n+      /* Assign class pointer */\n+      protocol->class_pointer = proto_class;\n+      \n+      /* Register all the selectors in the protocol with the runtime.\n+\t This both registers the selectors with the right types, and\n+\t it also fixes up the 'struct objc_method' structures inside\n+\t the protocol so that each method_name (a char * as compiled\n+\t by the compiler) is replaced with the appropriate runtime\n+\t SEL.  */\n+      if (protocol->class_methods)\n+\t__objc_register_selectors_from_description_list (protocol->class_methods);\n+\n+      if (protocol->instance_methods)\n+\t__objc_register_selectors_from_description_list (protocol->instance_methods);\n+\n+      /* Register the protocol in the hashtable or protocols by\n+\t name.  */\n+      __objc_protocols_add_protocol (protocol->protocol_name, protocol);\n+      \n+      /* Init super protocols */\n+      __objc_init_protocols (protocol->protocol_list);\n+    }\n+  else if (protocol->class_pointer != proto_class)\n+    {\n+      _objc_abort (\"Version %d doesn't match runtime protocol version %d\\n\",\n+\t\t   (int) ((char *) protocol->class_pointer\n+\t\t\t  - (char *) 0),\n+\t\t   PROTOCOL_VERSION);\n+    }\n+}\n+\n static void\n __objc_init_protocols (struct objc_protocol_list *protos)\n {\n@@ -871,25 +935,7 @@ __objc_init_protocols (struct objc_protocol_list *protos)\n   for (i = 0; i < protos->count; i++)\n     {\n       struct objc_protocol *aProto = protos->list[i];\n-      if (((size_t)aProto->class_pointer) == PROTOCOL_VERSION)\n-\t{\n-\t  /* Assign class pointer */\n-\t  aProto->class_pointer = proto_class;\n-\n-\t  /* Register the protocol in the hashtable or protocols by\n-\t     name.  */\n-\t  __objc_protocols_add_protocol (aProto->protocol_name, aProto);\n-\n-\t  /* Init super protocols */\n-\t  __objc_init_protocols (aProto->protocol_list);\n-\t}\n-      else if (protos->list[i]->class_pointer != proto_class)\n-\t{\n-\t  _objc_abort (\"Version %d doesn't match runtime protocol version %d\\n\",\n-\t\t       (int) ((char *) protos->list[i]->class_pointer\n-\t\t\t      - (char *) 0),\n-\t\t       PROTOCOL_VERSION);\n-\t}\n+      __objc_init_protocol (aProto);\n     }\n \n   objc_mutex_unlock (__objc_runtime_mutex);"}, {"sha": "7505a6b0bf3f89ae93339718f7ea704e9ded71bd", "filename": "libobjc/objc-private/module-abi-8.h", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2Fobjc-private%2Fmodule-abi-8.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2Fobjc-private%2Fmodule-abi-8.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-private%2Fmodule-abi-8.h?ref=f7185d479171342a33ffc2bc76226e86d400a785", "patch": "@@ -115,13 +115,15 @@ struct objc_ivar_list\n    problem is a singly linked list of methods.  */\n struct objc_method\n {\n-  SEL         method_name;  /* This variable is the method's name.  It\n-\t\t\t       is a char*.  The unique integer passed\n-\t\t\t       to objc_msg_send is a char* too.  It is\n-\t\t\t       compared against method_name using\n-\t\t\t       strcmp. */\n+  SEL         method_name;  /* This variable is the method's name.\n+\t\t\t       The compiler puts a char* here, and\n+\t\t\t       it's replaced by a real SEL at runtime\n+\t\t\t       when the method is registered.  */\n   const char* method_types; /* Description of the method's parameter\n-\t\t\t       list.  Useful for debuggers. */\n+\t\t\t       list.  Used when registering the\n+\t\t\t       selector with the runtime.  When that\n+\t\t\t       happens, method_name will contain the\n+\t\t\t       method's parameter list.  */\n   IMP         method_imp;   /* Address of the method in the\n \t\t\t       executable. */\n };\n@@ -139,7 +141,12 @@ struct objc_method_list\n };\n \n /* Currently defined in Protocol.m (that definition should go away\n-   once we include this file).  */\n+   once we include this file).  Note that a 'struct\n+   objc_method_description' as embedded inside a Protocol uses the\n+   same trick as a 'struct objc_method': the method_name is a 'char *'\n+   according to the compiler, who puts the method name as a string in\n+   there.  At runtime, the selectors need to be registered, and the\n+   method_name then becomes a SEL.  */\n struct objc_method_description_list\n {\n   int count;"}, {"sha": "6794d1815130015259b2d1d180107aae200db84e", "filename": "libobjc/objc-private/runtime.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2Fobjc-private%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2Fobjc-private%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-private%2Fruntime.h?ref=f7185d479171342a33ffc2bc76226e86d400a785", "patch": "@@ -60,6 +60,8 @@ extern void __objc_install_premature_dtable(Class); /* (objc-dispatch.c) */\n extern void __objc_resolve_class_links(void);  /* (objc-class.c) */\n extern void __objc_register_selectors_from_class(Class); /* (objc-sel.c) */\n extern void __objc_register_selectors_from_list (struct objc_method_list *); /* (selector.c) */\n+extern void __objc_register_selectors_from_description_list\n+(struct objc_method_description_list *method_list); /* (selector.c) */\n extern void __objc_update_dispatch_table_for_class (Class);/* (objc-msg.c) */\n \n extern int  __objc_init_thread_system(void);    /* thread.c */"}, {"sha": "938033148ae42a945f67e2cd0ee838431e45cf31", "filename": "libobjc/objc/runtime.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fruntime.h?ref=f7185d479171342a33ffc2bc76226e86d400a785", "patch": "@@ -195,7 +195,7 @@ objc_EXPORT SEL sel_registerName (const char *name);\n    Compatibility Note: the Apple/NeXT runtime has untyped selectors,\n    so it does not have this function, which is specific to the GNU\n    Runtime.  */\n-objc_EXPORT SEL set_registerTypedName (const char *name, const char *type);\n+objc_EXPORT SEL sel_registerTypedName (const char *name, const char *type);\n \n /* Return YES if first_selector is the same as second_selector, and NO\n    if not.  */\n@@ -505,15 +505,15 @@ objc_EXPORT Method * class_copyMethodList (Class class_, unsigned int *numberOfR\n objc_EXPORT unsigned int method_getNumberOfArguments (Method method);\n \n /* Return the string encoding for the return type of method 'method'.\n-   The string is a standard NULL-terminated string in an area of\n+   The string is a standard zero-terminated string in an area of\n    memory allocated with malloc(); you should free it with free() when\n    you finish using it.  Return an empty string if method is NULL.  */\n objc_EXPORT char * method_copyReturnType (Method method);\n \n /* Return the string encoding for the argument type of method\n    'method', argument number 'argumentNumber' ('argumentNumber' is 0\n    for self, 1 for _cmd, and 2 or more for the additional arguments if\n-   any).  The string is a standard NULL-terminated string in an area\n+   any).  The string is a standard zero-terminated string in an area\n    of memory allocated with malloc(); you should free it with free()\n    when you finish using it.  Return an empty string if method is NULL\n    or if 'argumentNumber' refers to a non-existing argument.  */\n@@ -524,10 +524,10 @@ objc_EXPORT char * method_copyArgumentType (Method method, unsigned int argument\n    'returnValue' string, which is of size 'returnValueSize'.  No more\n    than 'returnValueSize' characters are copied; if the encoding is\n    smaller than 'returnValueSize', the rest of 'returnValue' is filled\n-   with NULLs.  If it is bigger, it is truncated (and would not be\n-   NULL-terminated).  You should supply a big enough\n+   with zeros.  If it is bigger, it is truncated (and would not be\n+   zero-terminated).  You should supply a big enough\n    'returnValueSize'.  If the method is NULL, returnValue is set to a\n-   string of NULLs.  */\n+   string of zeros.  */\n objc_EXPORT void method_getReturnType (Method method, char *returnValue, \n \t\t\t\t       size_t returnValueSize);\n \n@@ -538,10 +538,10 @@ objc_EXPORT void method_getReturnType (Method method, char *returnValue,\n    'returnValue' string, which is of size 'returnValueSize'.  No more\n    than 'returnValueSize' characters are copied; if the encoding is\n    smaller than 'returnValueSize', the rest of 'returnValue' is filled\n-   with NULLs.  If it is bigger, it is truncated (and would not be\n-   NULL-terminated).  You should supply a big enough\n+   with zeros.  If it is bigger, it is truncated (and would not be\n+   zero-terminated).  You should supply a big enough\n    'returnValueSize'.  If the method is NULL, returnValue is set to a\n-   string of NULLs.  */\n+   string of zeros.  */\n objc_EXPORT void method_getArgumentType (Method method, unsigned int argumentNumber,\n \t\t\t\t\t char *returnValue, size_t returnValueSize);\n "}, {"sha": "d23d42d8f82f0cdd374f7696ea8e2e18a5a7e74a", "filename": "libobjc/protocols.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2Fprotocols.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2Fprotocols.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fprotocols.c?ref=f7185d479171342a33ffc2bc76226e86d400a785", "patch": "@@ -383,7 +383,7 @@ struct objc_method_description protocol_getMethodDescription (Protocol *protocol\n     {\n       for (i = 0; i < methods->count; i++)\n \t{\n-\t  if (strcmp ((char*)(methods->list[i].name), selector_name) == 0)\n+\t  if (strcmp (sel_getName (methods->list[i].name), selector_name) == 0)\n \t    return methods->list[i];\n \t}\n     }"}, {"sha": "ca8aa42e140fcc0d807479942802e4705486445e", "filename": "libobjc/selector.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2Fselector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7185d479171342a33ffc2bc76226e86d400a785/libobjc%2Fselector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fselector.c?ref=f7185d479171342a33ffc2bc76226e86d400a785", "patch": "@@ -95,6 +95,40 @@ __objc_register_selectors_from_list (MethodList_t method_list)\n   objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n+/* Temporary definition while we include objc/objc-api.h instead of\n+   objc-private/module-abi-8.h.  It should go away once we include\n+   module-abi-8.h.  */\n+struct objc_method_description_list\n+{\n+  int count;\n+  struct objc_method_description list[1];\n+};\n+\n+/* The same as __objc_register_selectors_from_list, but works on a\n+   struct objc_method_description_list* instead of a struct\n+   objc_method_list*.  This is only used for protocols, which have\n+   lists of method descriptions, not methods.\n+   */\n+void\n+__objc_register_selectors_from_description_list \n+(struct objc_method_description_list *method_list)\n+{\n+  int i = 0;\n+  \n+  objc_mutex_lock (__objc_runtime_mutex);\n+  while (i < method_list->count)\n+    {\n+      struct objc_method_description *method = &method_list->list[i];\n+      if (method->name)\n+\t{\n+\t  method->name\n+\t    = __sel_register_typed_name ((const char *) method->name,\n+\t\t\t\t\t method->types, 0, YES);\n+\t}\n+      i += 1;\n+    }\n+  objc_mutex_unlock (__objc_runtime_mutex);\n+}\n \n /* Register instance methods as class methods for root classes */\n void __objc_register_instance_methods_to_class (Class class)"}]}