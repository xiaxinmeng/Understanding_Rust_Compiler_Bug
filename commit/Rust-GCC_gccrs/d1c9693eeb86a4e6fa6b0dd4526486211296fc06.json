{"sha": "d1c9693eeb86a4e6fa6b0dd4526486211296fc06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFjOTY5M2VlYjg2YTRlNmZhNmIwZGQ0NTI2NDg2MjExMjk2ZmMwNg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2003-04-09T18:51:54Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2003-04-09T18:51:54Z"}, "message": "sched-deps.c (reg_pending_barrier_mode): New enumeration.\n\n2003-04-09  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* sched-deps.c (reg_pending_barrier_mode): New enumeration.\n\t(reg_pending_barrier): Make it of the enumeration type.\n\t(sched_analyze_2): Define the barrier as MOVE_BARRIER or\n\tTRUE_BARRIER.\n\t(sched_analyze): Ditto.\n\t(sched_analyze_insn): Ditto.  Use anti-dependencies for\n\tMOVE_BARRIER and true-dependencies as TRUE_BARRIER.\n\t(init_deps_global): Initialize the barrier as NO_BARRIER.\n\nFrom-SVN: r65402", "tree": {"sha": "c7de181a74e753afaf3f346f037e870a60caad21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7de181a74e753afaf3f346f037e870a60caad21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1c9693eeb86a4e6fa6b0dd4526486211296fc06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1c9693eeb86a4e6fa6b0dd4526486211296fc06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1c9693eeb86a4e6fa6b0dd4526486211296fc06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1c9693eeb86a4e6fa6b0dd4526486211296fc06/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f32360c7226f7216f67970073a98cca0705a529d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f32360c7226f7216f67970073a98cca0705a529d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f32360c7226f7216f67970073a98cca0705a529d"}], "stats": {"total": 58, "additions": 43, "deletions": 15}, "files": [{"sha": "200d2a77a0a988b043808d6fa35b18e3709efab0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1c9693eeb86a4e6fa6b0dd4526486211296fc06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1c9693eeb86a4e6fa6b0dd4526486211296fc06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1c9693eeb86a4e6fa6b0dd4526486211296fc06", "patch": "@@ -1,3 +1,14 @@\n+2003-04-09  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* sched-deps.c (reg_pending_barrier_mode): New enumeration.\n+\t(reg_pending_barrier): Make it of the enumeration type.\n+\t(sched_analyze_2): Define the barrier as MOVE_BARRIER or\n+\tTRUE_BARRIER.\n+\t(sched_analyze): Ditto.\n+\t(sched_analyze_insn): Ditto.  Use anti-dependencies for\n+\tMOVE_BARRIER and true-dependencies as TRUE_BARRIER.\n+\t(init_deps_global): Initialize the barrier as NO_BARRIER.\n+\t\n 2003-04-09  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* config/ia64/ia64.c (issue_nops_and_insn): Add new parameter."}, {"sha": "5b1062bbc14cac3fd4a84f6f8fe77c880ecf1173", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1c9693eeb86a4e6fa6b0dd4526486211296fc06/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1c9693eeb86a4e6fa6b0dd4526486211296fc06/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=d1c9693eeb86a4e6fa6b0dd4526486211296fc06", "patch": "@@ -54,7 +54,18 @@ static regset_head reg_pending_uses_head;\n static regset reg_pending_sets;\n static regset reg_pending_clobbers;\n static regset reg_pending_uses;\n-static bool reg_pending_barrier;\n+\n+/* The following enumeration values tell us what dependencies we\n+   should use to implement the barrier.  We use true-dependencies for\n+   TRUE_BARRIER and anti-dependencies for MOVE_BARRIER.  */\n+enum reg_pending_barrier_mode\n+{\n+  NOT_A_BARRIER = 0,\n+  MOVE_BARRIER,\n+  TRUE_BARRIER\n+};\n+\n+static enum reg_pending_barrier_mode reg_pending_barrier;\n \n /* To speed up the test for duplicate dependency links we keep a\n    record of dependencies created by add_dependence when the average\n@@ -748,7 +759,7 @@ sched_analyze_2 (deps, x, insn)\n \t   mode.  An insn should not be moved across this even if it only uses\n \t   pseudo-regs because it might give an incorrectly rounded result.  */\n \tif (code != ASM_OPERANDS || MEM_VOLATILE_P (x))\n-\t  reg_pending_barrier = true;\n+\t  reg_pending_barrier = TRUE_BARRIER;\n \n \t/* For all ASM_OPERANDS, we must traverse the vector of input operands.\n \t   We can not just fall through here since then we would be confused\n@@ -867,15 +878,15 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \t    sched_analyze_2 (deps, XEXP (link, 0), insn);\n \t}\n       if (find_reg_note (insn, REG_SETJMP, NULL))\n-\treg_pending_barrier = true;\n+\treg_pending_barrier = MOVE_BARRIER;\n     }\n \n   if (GET_CODE (insn) == JUMP_INSN)\n     {\n       rtx next;\n       next = next_nonnote_insn (insn);\n       if (next && GET_CODE (next) == BARRIER)\n-\treg_pending_barrier = true;\n+\treg_pending_barrier = TRUE_BARRIER;\n       else\n \t{\n \t  rtx pending, pending_mem;\n@@ -940,7 +951,7 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \t      || INTVAL (XEXP (link, 0)) == NOTE_INSN_LOOP_END\n \t      || INTVAL (XEXP (link, 0)) == NOTE_INSN_EH_REGION_BEG\n \t      || INTVAL (XEXP (link, 0)) == NOTE_INSN_EH_REGION_END)\n-\t    reg_pending_barrier = true;\n+\t    reg_pending_barrier = MOVE_BARRIER;\n \n \t  link = XEXP (link, 1);\n \t}\n@@ -952,7 +963,7 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n      where block boundaries fall.  This is mighty confusing elsewhere.\n      Therefore, prevent such an instruction from being moved.  */\n   if (can_throw_internal (insn))\n-    reg_pending_barrier = true;\n+    reg_pending_barrier = MOVE_BARRIER;\n \n   /* Add dependencies if a scheduling barrier was found.  */\n   if (reg_pending_barrier)\n@@ -965,8 +976,12 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      add_dependence_list (insn, reg_last->uses, REG_DEP_ANTI);\n-\t      add_dependence_list (insn, reg_last->sets, REG_DEP_ANTI);\n-\t      add_dependence_list (insn, reg_last->clobbers, REG_DEP_ANTI);\n+\t      add_dependence_list\n+\t\t(insn, reg_last->sets,\n+\t\t reg_pending_barrier == TRUE_BARRIER ? 0 : REG_DEP_ANTI);\n+\t      add_dependence_list\n+\t\t(insn, reg_last->clobbers,\n+\t\t reg_pending_barrier == TRUE_BARRIER ? 0 : REG_DEP_ANTI);\n \t    });\n \t}\n       else\n@@ -976,10 +991,12 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      add_dependence_list_and_free (insn, &reg_last->uses,\n \t\t\t\t\t    REG_DEP_ANTI);\n-\t      add_dependence_list_and_free (insn, &reg_last->sets,\n-\t\t\t\t\t    REG_DEP_ANTI);\n-\t      add_dependence_list_and_free (insn, &reg_last->clobbers,\n-\t\t\t\t\t    REG_DEP_ANTI);\n+\t      add_dependence_list_and_free\n+\t\t(insn, &reg_last->sets,\n+\t\t reg_pending_barrier == TRUE_BARRIER ? 0 : REG_DEP_ANTI);\n+\t      add_dependence_list_and_free\n+\t\t(insn, &reg_last->clobbers,\n+\t\t reg_pending_barrier == TRUE_BARRIER ? 0 : REG_DEP_ANTI);\n \t      reg_last->uses_length = 0;\n \t      reg_last->clobbers_length = 0;\n \t    });\n@@ -993,7 +1010,7 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \t}\n \n       flush_pending_lists (deps, insn, true, true);\n-      reg_pending_barrier = false;\n+      reg_pending_barrier = NOT_A_BARRIER;\n     }\n   else\n     {\n@@ -1190,7 +1207,7 @@ sched_analyze (deps, head, tail)\n \t    {\n \t      /* This is setjmp.  Assume that all registers, not just\n \t\t hard registers, may be clobbered by this call.  */\n-\t      reg_pending_barrier = true;\n+\t      reg_pending_barrier = MOVE_BARRIER;\n \t    }\n \t  else\n \t    {\n@@ -1505,7 +1522,7 @@ init_deps_global ()\n   reg_pending_sets = INITIALIZE_REG_SET (reg_pending_sets_head);\n   reg_pending_clobbers = INITIALIZE_REG_SET (reg_pending_clobbers_head);\n   reg_pending_uses = INITIALIZE_REG_SET (reg_pending_uses_head);\n-  reg_pending_barrier = false;\n+  reg_pending_barrier = NOT_A_BARRIER;\n }\n \n /* Free everything used by the dependency analysis code.  */"}]}