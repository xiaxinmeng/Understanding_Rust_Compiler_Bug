{"sha": "6cf276ddf22066af780335cd0072d2c27aabe468", "node_id": "C_kwDOANBUbNoAKDZjZjI3NmRkZjIyMDY2YWY3ODAzMzVjZDAwNzJkMmMyN2FhYmU0Njg", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-06-02T19:40:22Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-06-02T19:40:22Z"}, "message": "diagnostics: add SARIF output format\n\nThis patch adds support to gcc's diagnostic subsystem for emitting\ndiagnostics in SARIF, aka the Static Analysis Results Interchange Format:\n  https://sarifweb.azurewebsites.net/\nby extending -fdiagnostics-format= to add two new options:\n  -fdiagnostics-format=sarif-stderr\nand:\n  -fdiagnostics-format=sarif-file\n\nThe patch targets SARIF v2.1.0\n\nThis is a JSON-based format suited for capturing the results of static\nanalysis tools (like GCC's -fanalyzer), but it can also be used for plain\nGCC warnings and errors.\n\nSARIF supports per-event metadata in diagnostic paths such as\n[\"acquire\", \"resource\"] and [\"release\", \"lock\"] (specifically, the\nthreadFlowLocation \"kinds\" property: SARIF v2.1.0 section 3.38.8), so\nthe patch extends GCC\"s diagnostic_event subclass with a \"struct meaning\"\nwith similar purpose.  The patch implements this for -fanalyzer so that\nthe various state-machine-based warnings set these in the SARIF output.\n\nThe heart of the implementation is in the new file\ndiagnostic-format-sarif.cc.  Much of the rest of the patch is interface\nclasses, isolating the diagnostic subsystem (which has no knowledge of\ne.g. tree or langhook) from the \"client\" code in the compiler proper\ncc1 etc).\n\nThe patch adds a langhook for specifying the SARIF v2.1.0\n\"artifact.sourceLanguage\" property, based on the list in\nSARIF v2.1.0 Appendix J.\n\nThe patch adds automated DejaGnu tests to our testsuite via new\nscan-sarif-file and scan-sarif-file-not directives (although these\nmerely use regexps, rather than attempting to use a proper JSON parser).\n\nI've tested the patch by hand using the validator at:\n  https://sarifweb.azurewebsites.net/Validation\nand the react-based viewer at:\n  https://microsoft.github.io/sarif-web-component/\nwhich successfully shows most of the information (although not paths,\nand not CWE IDs), and I've fixed all validation errors I've seen (though\nbugs no doubt remain).\n\nI've also tested the generated SARIF using the VS Code extension linked\nto from the SARIF website; I'm a novice with VS Code, but it seems to be\nable to handle my generated SARIF files (e.g. showing the data in the\nSARIF tab, and showing squiggly underlines under issues, and when I\nclick on them, it visualizes the events in the path inline within the\nsource window).\n\nHas anyone written an Emacs mode for SARIF files? (pretty please)\n\ngcc/ChangeLog:\n\t* Makefile.in (OBJS): Add tree-diagnostic-client-data-hooks.o and\n\ttree-logical-location.o.\n\t(OBJS-libcommon): Add diagnostic-format-sarif.o; reorder.\n\t(CFLAGS-tree-diagnostic-client-data-hooks.o): Add TARGET_NAME.\n\t* common.opt (fdiagnostics-format=): Add sarif-stderr and sarif-file.\n\t(sarif-stderr, sarif-file): New enum values.\n\t* diagnostic-client-data-hooks.h: New file.\n\t* diagnostic-format-sarif.cc: New file.\n\t* diagnostic-path.h (enum diagnostic_event::verb): New enum.\n\t(enum diagnostic_event::noun): New enum.\n\t(enum diagnostic_event::property): New enum.\n\t(struct diagnostic_event::meaning): New struct.\n\t(diagnostic_event::get_logical_location): New vfunc.\n\t(diagnostic_event::get_meaning): New vfunc.\n\t(simple_diagnostic_event::get_logical_location): New vfunc impl.\n\t(simple_diagnostic_event::get_meaning): New vfunc impl.\n\t* diagnostic.cc: Include \"diagnostic-client-data-hooks.h\".\n\t(diagnostic_initialize): Initialize m_client_data_hooks.\n\t(diagnostic_finish): Clean up m_client_data_hooks.\n\t(diagnostic_event::meaning::dump_to_pp): New.\n\t(diagnostic_event::meaning::maybe_get_verb_str): New.\n\t(diagnostic_event::meaning::maybe_get_noun_str): New.\n\t(diagnostic_event::meaning::maybe_get_property_str): New.\n\t(get_cwe_url): Make non-static.\n\t(diagnostic_output_format_init): Handle\n\tDIAGNOSTICS_OUTPUT_FORMAT_SARIF_STDERR and\n\tDIAGNOSTICS_OUTPUT_FORMAT_SARIF_FILE.\n\t* diagnostic.h (enum diagnostics_output_format): Add\n\tDIAGNOSTICS_OUTPUT_FORMAT_SARIF_STDERR and\n\tDIAGNOSTICS_OUTPUT_FORMAT_SARIF_FILE.\n\t(class diagnostic_client_data_hooks): New forward decl.\n\t(class logical_location): New forward decl.\n\t(diagnostic_context::m_client_data_hooks): New field.\n\t(diagnostic_output_format_init_sarif_stderr): New decl.\n\t(diagnostic_output_format_init_sarif_file): New decl.\n\t(get_cwe_url): New decl.\n\t* doc/invoke.texi (-fdiagnostics-format=): Add sarif-stderr and\n\tsarif-file.\n\t* doc/sourcebuild.texi (Scan a particular file): Add\n\tscan-sarif-file and scan-sarif-file-not.\n\t* langhooks-def.h (lhd_get_sarif_source_language): New decl.\n\t(LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE): New macro.\n\t(LANG_HOOKS_INITIALIZER): Add\n\tLANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE.\n\t* langhooks.cc (lhd_get_sarif_source_language): New.\n\t* langhooks.h (lang_hooks::get_sarif_source_language): New field.\n\t* logical-location.h: New file.\n\t* plugin.cc (struct for_each_plugin_closure): New.\n\t(for_each_plugin_cb): New.\n\t(for_each_plugin): New.\n\t* plugin.h (for_each_plugin): New decl.\n\t* tree-diagnostic-client-data-hooks.cc: New file.\n\t* tree-diagnostic.cc: Include \"diagnostic-client-data-hooks.h\".\n\t(tree_diagnostics_defaults): Populate m_client_data_hooks.\n\t* tree-logical-location.cc: New file.\n\t* tree-logical-location.h: New file.\n\ngcc/ada/ChangeLog:\n\t* gcc-interface/misc.cc (gnat_get_sarif_source_language): New.\n\t(LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE): Redefine.\n\ngcc/analyzer/ChangeLog:\n\t* checker-path.cc (checker_event::get_meaning): New.\n\t(function_entry_event::get_meaning): New.\n\t(state_change_event::get_desc): Add dump of meaning of the event\n\tto the -fanalyzer-verbose-state-changes output.\n\t(state_change_event::get_meaning): New.\n\t(cfg_edge_event::get_meaning): New.\n\t(call_event::get_meaning): New.\n\t(return_event::get_meaning): New.\n\t(start_consolidated_cfg_edges_event::get_meaning): New.\n\t(warning_event::get_meaning): New.\n\t* checker-path.h: Include \"tree-logical-location.h\".\n\t(checker_event::checker_event): Construct m_logical_loc.\n\t(checker_event::get_logical_location): New.\n\t(checker_event::get_meaning): New decl.\n\t(checker_event::m_logical_loc): New.\n\t(function_entry_event::get_meaning): New decl.\n\t(state_change_event::get_meaning): New decl.\n\t(cfg_edge_event::get_meaning): New decl.\n\t(call_event::get_meaning): New decl.\n\t(return_event::get_meaning): New decl.\n\t(start_consolidated_cfg_edges_event::get_meaning): New.\n\t(warning_event::get_meaning): New decl.\n\t* pending-diagnostic.h: Include \"diagnostic-path.h\".\n\t(pending_diagnostic::get_meaning_for_state_change): New vfunc.\n\t* sm-file.cc (file_diagnostic::get_meaning_for_state_change): New\n\tvfunc impl.\n\t* sm-malloc.cc (malloc_diagnostic::get_meaning_for_state_change):\n\tLikewise.\n\t* sm-sensitive.cc\n\t(exposure_through_output_file::get_meaning_for_state_change):\n\tLikewise.\n\t* sm-taint.cc (taint_diagnostic::get_meaning_for_state_change):\n\tLikewise.\n\t* varargs.cc\n\t(va_list_sm_diagnostic::get_meaning_for_state_change): Likewise.\n\ngcc/c/ChangeLog:\n\t* c-lang.cc (LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE): Redefine.\n\t(c_get_sarif_source_language): New.\n\t* c-tree.h (c_get_sarif_source_language): New decl.\n\ngcc/cp/ChangeLog:\n\t* cp-lang.cc (LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE): Redefine.\n\t(cp_get_sarif_source_language): New.\n\ngcc/d/ChangeLog:\n\t* d-lang.cc (d_get_sarif_source_language): New.\n\t(LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE): Redefine.\n\ngcc/fortran/ChangeLog:\n\t* f95-lang.cc (gfc_get_sarif_source_language): New.\n\t(LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE): Redefine.\n\ngcc/go/ChangeLog:\n\t* go-lang.cc (go_get_sarif_source_language): New.\n\t(LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE): Redefine.\n\ngcc/objc/ChangeLog:\n\t* objc-act.h (objc_get_sarif_source_language): New decl.\n\t* objc-lang.cc (LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE): Redefine.\n\t(objc_get_sarif_source_language): New.\n\ngcc/testsuite/ChangeLog:\n\t* c-c++-common/diagnostic-format-sarif-file-1.c: New test.\n\t* c-c++-common/diagnostic-format-sarif-file-2.c: New test.\n\t* c-c++-common/diagnostic-format-sarif-file-3.c: New test.\n\t* c-c++-common/diagnostic-format-sarif-file-4.c: New test.\n\t* gcc.dg/analyzer/file-meaning-1.c: New test.\n\t* gcc.dg/analyzer/malloc-meaning-1.c: New test.\n\t* gcc.dg/analyzer/malloc-sarif-1.c: New test.\n\t* gcc.dg/plugin/analyzer_gil_plugin.c\n\t(gil_diagnostic::get_meaning_for_state_change): New vfunc impl.\n\t* gcc.dg/plugin/diagnostic-test-paths-5.c: New test.\n\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add\n\tdiagnostic-test-paths-5.c to tests for\n\tdiagnostic_plugin_test_paths.c.\n\t* lib/gcc-dg.exp: Load scansarif.exp.\n\t* lib/scansarif.exp: New test.\n\nlibatomic/ChangeLog:\n\t* testsuite/lib/libatomic.exp: Add load_gcc_lib of scansarif.exp.\n\nlibgomp/ChangeLog:\n\t* testsuite/lib/libgomp.exp: Add load_gcc_lib of scansarif.exp.\n\nlibitm/ChangeLog:\n\t* testsuite/lib/libitm.exp: Add load_gcc_lib of scansarif.exp.\n\nlibphobos/ChangeLog:\n\t* testsuite/lib/libphobos-dg.exp: Add load_gcc_lib of scansarif.exp.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "a765d4f8d248aa7a4cebe46e77c3eace8c99ad6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a765d4f8d248aa7a4cebe46e77c3eace8c99ad6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cf276ddf22066af780335cd0072d2c27aabe468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf276ddf22066af780335cd0072d2c27aabe468", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cf276ddf22066af780335cd0072d2c27aabe468", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cf276ddf22066af780335cd0072d2c27aabe468/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ab73173cca4610e59df8a3fe9cb5b30ded75aec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ab73173cca4610e59df8a3fe9cb5b30ded75aec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ab73173cca4610e59df8a3fe9cb5b30ded75aec"}], "stats": {"total": 3018, "additions": 3005, "deletions": 13}, "files": [{"sha": "b6dcc45a58aeba9c812520242ffce5a874721f17", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -1617,6 +1617,7 @@ OBJS = \\\n \ttree-data-ref.o \\\n \ttree-dfa.o \\\n \ttree-diagnostic.o \\\n+\ttree-diagnostic-client-data-hooks.o \\\n \ttree-diagnostic-path.o \\\n \ttree-dump.o \\\n \ttree-eh.o \\\n@@ -1625,6 +1626,7 @@ OBJS = \\\n \ttree-inline.o \\\n \ttree-into-ssa.o \\\n \ttree-iterator.o \\\n+\ttree-logical-location.o \\\n \ttree-loop-distribution.o \\\n \ttree-nested.o \\\n \ttree-nrv.o \\\n@@ -1728,9 +1730,12 @@ OBJS = \\\n # Objects in libcommon.a, potentially used by all host binaries and with\n # no target dependencies.\n OBJS-libcommon = diagnostic-spec.o diagnostic.o diagnostic-color.o \\\n-\tdiagnostic-show-locus.o diagnostic-format-json.o json.o \\\n+\tdiagnostic-format-json.o \\\n+\tdiagnostic-format-sarif.o \\\n+\tdiagnostic-show-locus.o \\\n \tedit-context.o \\\n \tpretty-print.o intl.o \\\n+\tjson.o \\\n \tsbitmap.o \\\n \tvec.o input.o hash-table.o ggc-none.o memory-block.o \\\n \tselftest.o selftest-diagnostic.o sort.o\n@@ -2368,6 +2373,7 @@ s-bversion: BASE-VER\n \t$(STAMP) s-bversion\n \n CFLAGS-toplev.o += -DTARGET_NAME=\\\"$(target_noncanonical)\\\"\n+CFLAGS-tree-diagnostic-client-data-hooks.o += -DTARGET_NAME=\\\"$(target_noncanonical)\\\"\n CFLAGS-optinfo-emit-json.o += -DTARGET_NAME=\\\"$(target_noncanonical)\\\" $(ZLIBINC)\n CFLAGS-analyzer/engine.o += $(ZLIBINC)\n "}, {"sha": "f0ca197270079c97f088c5f4b29324b78c0cc4fb", "filename": "gcc/ada/gcc-interface/misc.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fada%2Fgcc-interface%2Fmisc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fada%2Fgcc-interface%2Fmisc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -1292,6 +1292,15 @@ gnat_eh_personality (void)\n   return gnat_eh_personality_decl;\n }\n \n+/* Get a value for the SARIF v2.1.0 \"artifact.sourceLanguage\" property,\n+   based on the list in SARIF v2.1.0 Appendix J.  */\n+\n+static const char *\n+gnat_get_sarif_source_language (const char *)\n+{\n+  return \"ada\";\n+}\n+\n /* Initialize language-specific bits of tree_contains_struct.  */\n \n static void\n@@ -1414,6 +1423,8 @@ get_lang_specific (tree node)\n #define LANG_HOOKS_DEEP_UNSHARING\ttrue\n #undef  LANG_HOOKS_CUSTOM_FUNCTION_DESCRIPTORS\n #define LANG_HOOKS_CUSTOM_FUNCTION_DESCRIPTORS true\n+#undef LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE\n+#define LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE gnat_get_sarif_source_language\n \n struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n "}, {"sha": "8aa5bf716d9cabc310b3d6cd062667ef457dad90", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 102, "deletions": 4, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -112,6 +112,15 @@ event_kind_to_string (enum event_kind ek)\n \n /* class checker_event : public diagnostic_event.  */\n \n+/* No-op implementation of diagnostic_event::get_meaning vfunc for\n+   checker_event: checker events have no meaning by default.  */\n+\n+diagnostic_event::meaning\n+checker_event::get_meaning () const\n+{\n+  return meaning ();\n+}\n+\n /* Dump this event to PP (for debugging/logging purposes).  */\n \n void\n@@ -242,6 +251,15 @@ function_entry_event::get_desc (bool can_colorize) const\n   return make_label_text (can_colorize, \"entry to %qE\", m_fndecl);\n }\n \n+/* Implementation of diagnostic_event::get_meaning vfunc for\n+   function entry.  */\n+\n+diagnostic_event::meaning\n+function_entry_event::get_meaning () const\n+{\n+  return meaning (VERB_enter, NOUN_function);\n+}\n+\n /* class state_change_event : public checker_event.  */\n \n /* state_change_event's ctor.  */\n@@ -292,25 +310,33 @@ state_change_event::get_desc (bool can_colorize) const\n \t{\n \t  if (flag_analyzer_verbose_state_changes)\n \t    {\n+\t      /* Get any \"meaning\" of event.  */\n+\t      diagnostic_event::meaning meaning = get_meaning ();\n+\t      pretty_printer meaning_pp;\n+\t      meaning.dump_to_pp (&meaning_pp);\n+\n \t      /* Append debug version.  */\n \t      label_text result;\n \t      if (m_origin)\n \t\tresult = make_label_text\n \t\t  (can_colorize,\n-\t\t   \"%s (state of %qE: %qs -> %qs, origin: %qE)\",\n+\t\t   \"%s (state of %qE: %qs -> %qs, origin: %qE, meaning: %s)\",\n \t\t   custom_desc.m_buffer,\n \t\t   var,\n \t\t   m_from->get_name (),\n \t\t   m_to->get_name (),\n-\t\t   origin);\n+\t\t   origin,\n+\t\t   pp_formatted_text (&meaning_pp));\n \t      else\n \t\tresult = make_label_text\n \t\t  (can_colorize,\n-\t\t   \"%s (state of %qE: %qs -> %qs, NULL origin)\",\n+\t\t   \"%s (state of %qE: %qs -> %qs, NULL origin, meaning: %s)\",\n \t\t   custom_desc.m_buffer,\n \t\t   var,\n \t\t   m_from->get_name (),\n-\t\t   m_to->get_name ());\n+\t\t   m_to->get_name (),\n+\t\t   pp_formatted_text (&meaning_pp));\n+\n \t      custom_desc.maybe_free ();\n \t      return result;\n \t    }\n@@ -357,6 +383,26 @@ state_change_event::get_desc (bool can_colorize) const\n     }\n }\n \n+/* Implementation of diagnostic_event::get_meaning vfunc for\n+   state change events: delegate to the pending_diagnostic to\n+   get any meaning.  */\n+\n+diagnostic_event::meaning\n+state_change_event::get_meaning () const\n+{\n+  if (m_pending_diagnostic)\n+    {\n+      region_model *model = m_dst_state.m_region_model;\n+      tree var = model->get_representative_tree (m_sval);\n+      tree origin = model->get_representative_tree (m_origin);\n+      return m_pending_diagnostic->get_meaning_for_state_change\n+\t(evdesc::state_change (false, var, origin,\n+\t\t\t       m_from, m_to, m_emission_id, *this));\n+    }\n+  else\n+    return meaning ();\n+}\n+\n /* class superedge_event : public checker_event.  */\n \n /* Get the callgraph_superedge for this superedge_event, which must be\n@@ -432,6 +478,21 @@ cfg_edge_event::cfg_edge_event (enum event_kind kind,\n   gcc_assert (eedge.m_sedge->m_kind == SUPEREDGE_CFG_EDGE);\n }\n \n+/* Implementation of diagnostic_event::get_meaning vfunc for\n+   CFG edge events.  */\n+\n+diagnostic_event::meaning\n+cfg_edge_event::get_meaning () const\n+{\n+  const cfg_superedge& cfg_sedge = get_cfg_superedge ();\n+  if (cfg_sedge.true_value_p ())\n+    return meaning (VERB_branch, PROPERTY_true);\n+  else if (cfg_sedge.false_value_p ())\n+    return meaning (VERB_branch, PROPERTY_false);\n+  else\n+    return meaning ();\n+}\n+\n /* class start_cfg_edge_event : public cfg_edge_event.  */\n \n /* Implementation of diagnostic_event::get_desc vfunc for\n@@ -690,6 +751,15 @@ call_event::get_desc (bool can_colorize) const\n \t\t\t  get_caller_fndecl ());\n }\n \n+/* Implementation of diagnostic_event::get_meaning vfunc for\n+   function call events.  */\n+\n+diagnostic_event::meaning\n+call_event::get_meaning () const\n+{\n+  return meaning (VERB_call, NOUN_function);\n+}\n+\n /* Override of checker_event::is_call_p for calls.  */\n \n bool\n@@ -760,6 +830,15 @@ return_event::get_desc (bool can_colorize) const\n \t\t\t  m_src_snode->m_fun->decl);\n }\n \n+/* Implementation of diagnostic_event::get_meaning vfunc for\n+   function return events.  */\n+\n+diagnostic_event::meaning\n+return_event::get_meaning () const\n+{\n+  return meaning (VERB_return, NOUN_function);\n+}\n+\n /* Override of checker_event::is_return_p for returns.  */\n \n bool\n@@ -778,6 +857,16 @@ start_consolidated_cfg_edges_event::get_desc (bool can_colorize) const\n \t\t\t  m_edge_sense ? \"true\" : \"false\");\n }\n \n+/* Implementation of diagnostic_event::get_meaning vfunc for\n+   start_consolidated_cfg_edges_event.  */\n+\n+diagnostic_event::meaning\n+start_consolidated_cfg_edges_event::get_meaning () const\n+{\n+  return meaning (VERB_branch,\n+\t\t  (m_edge_sense ? PROPERTY_true : PROPERTY_false));\n+}\n+\n /* class setjmp_event : public checker_event.  */\n \n /* Implementation of diagnostic_event::get_desc vfunc for\n@@ -977,6 +1066,15 @@ warning_event::get_desc (bool can_colorize) const\n     return label_text::borrow (\"here\");\n }\n \n+/* Implementation of diagnostic_event::get_meaning vfunc for\n+   warning_event.  */\n+\n+diagnostic_event::meaning\n+warning_event::get_meaning () const\n+{\n+  return meaning (VERB_danger, NOUN_unknown);\n+}\n+\n /* Print a single-line representation of this path to PP.  */\n \n void"}, {"sha": "8960d56c8fa4c280dd38ab2f323c599c773babcf", "filename": "gcc/analyzer/checker-path.h", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fchecker-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fchecker-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.h?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -21,6 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_CHECKER_PATH_H\n #define GCC_ANALYZER_CHECKER_PATH_H\n \n+#include \"tree-logical-location.h\"\n+\n namespace ana {\n \n /* An enum for discriminating between the concrete subclasses of\n@@ -85,7 +87,8 @@ class checker_event : public diagnostic_event\n   checker_event (enum event_kind kind,\n \t\t location_t loc, tree fndecl, int depth)\n     : m_kind (kind), m_loc (loc), m_fndecl (fndecl), m_depth (depth),\n-      m_pending_diagnostic (NULL), m_emission_id ()\n+      m_pending_diagnostic (NULL), m_emission_id (),\n+      m_logical_loc (fndecl)\n   {\n   }\n \n@@ -94,6 +97,14 @@ class checker_event : public diagnostic_event\n   location_t get_location () const final override { return m_loc; }\n   tree get_fndecl () const final override { return m_fndecl; }\n   int get_stack_depth () const final override { return m_depth; }\n+  const logical_location *get_logical_location () const final override\n+  {\n+    if (m_fndecl)\n+      return &m_logical_loc;\n+    else\n+      return NULL;\n+  }\n+  meaning get_meaning () const override;\n \n   /* Additional functionality.  */\n \n@@ -122,6 +133,7 @@ class checker_event : public diagnostic_event\n   int m_depth;\n   pending_diagnostic *m_pending_diagnostic;\n   diagnostic_event_id_t m_emission_id; // only set once all pruning has occurred\n+  tree_logical_location m_logical_loc;\n };\n \n /* A concrete event subclass for a purely textual event, for use in\n@@ -222,6 +234,7 @@ class function_entry_event : public checker_event\n   }\n \n   label_text get_desc (bool can_colorize) const final override;\n+  meaning get_meaning () const override;\n \n   bool is_function_entry_p () const final override { return true; }\n };\n@@ -241,6 +254,7 @@ class state_change_event : public checker_event\n \t\t      const program_state &dst_state);\n \n   label_text get_desc (bool can_colorize) const final override;\n+  meaning get_meaning () const override;\n \n   function *get_dest_function () const\n   {\n@@ -295,6 +309,8 @@ class superedge_event : public checker_event\n class cfg_edge_event : public superedge_event\n {\n public:\n+  meaning get_meaning () const override;\n+\n   const cfg_superedge& get_cfg_superedge () const;\n \n  protected:\n@@ -353,6 +369,7 @@ class call_event : public superedge_event\n \t      location_t loc, tree fndecl, int depth);\n \n   label_text get_desc (bool can_colorize) const override;\n+  meaning get_meaning () const override;\n \n   bool is_call_p () const final override;\n \n@@ -373,6 +390,7 @@ class return_event : public superedge_event\n \t\tlocation_t loc, tree fndecl, int depth);\n \n   label_text get_desc (bool can_colorize) const final override;\n+  meaning get_meaning () const override;\n \n   bool is_return_p () const final override;\n \n@@ -394,6 +412,7 @@ class start_consolidated_cfg_edges_event : public checker_event\n   }\n \n   label_text get_desc (bool can_colorize) const final override;\n+  meaning get_meaning () const override;\n \n  private:\n   bool m_edge_sense;\n@@ -521,6 +540,7 @@ class warning_event : public checker_event\n   }\n \n   label_text get_desc (bool can_colorize) const final override;\n+  meaning get_meaning () const override;\n \n private:\n   const state_machine *m_sm;"}, {"sha": "9e1c656bf0a12af8ec12a28bf3eeb3d773f6414f", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -21,6 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_PENDING_DIAGNOSTIC_H\n #define GCC_ANALYZER_PENDING_DIAGNOSTIC_H\n \n+#include \"diagnostic-path.h\"\n+\n namespace ana {\n \n /* A bundle of information about things that are of interest to a\n@@ -232,6 +234,15 @@ class pending_diagnostic\n     return label_text ();\n   }\n \n+  /* Vfunc for implementing diagnostic_event::get_meaning for\n+     state_change_event.  */\n+  virtual diagnostic_event::meaning\n+  get_meaning_for_state_change (const evdesc::state_change &) const\n+  {\n+    /* Default no-op implementation.  */\n+    return diagnostic_event::meaning ();\n+  }\n+\n   /* Precision-of-wording vfunc for describing an interprocedural call\n      carrying critial state for the diagnostic, from caller to callee.\n "}, {"sha": "8514af197667a26ec36ec9af3a2e43031b677580", "filename": "gcc/analyzer/sm-file.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fsm-file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fsm-file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-file.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -143,6 +143,20 @@ class file_diagnostic : public pending_diagnostic\n     return label_text ();\n   }\n \n+  diagnostic_event::meaning\n+  get_meaning_for_state_change (const evdesc::state_change &change)\n+    const final override\n+  {\n+    if (change.m_old_state == m_sm.get_start_state ()\n+\t&& change.m_new_state == m_sm.m_unchecked)\n+      return diagnostic_event::meaning (diagnostic_event::VERB_acquire,\n+\t\t\t\t\tdiagnostic_event::NOUN_resource);\n+    if (change.m_new_state == m_sm.m_closed)\n+      return diagnostic_event::meaning (diagnostic_event::VERB_release,\n+\t\t\t\t\tdiagnostic_event::NOUN_resource);\n+    return diagnostic_event::meaning ();\n+  }\n+\n protected:\n   const fileptr_state_machine &m_sm;\n   tree m_arg;"}, {"sha": "3bd40425919a3bc51bec5947c324f23db1b2f3a0", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -736,6 +736,20 @@ class malloc_diagnostic : public pending_diagnostic\n     return label_text ();\n   }\n \n+  diagnostic_event::meaning\n+  get_meaning_for_state_change (const evdesc::state_change &change)\n+    const final override\n+  {\n+    if (change.m_old_state == m_sm.get_start_state ()\n+\t&& unchecked_p (change.m_new_state))\n+      return diagnostic_event::meaning (diagnostic_event::VERB_acquire,\n+\t\t\t\t\tdiagnostic_event::NOUN_memory);\n+    if (freed_p (change.m_new_state))\n+      return diagnostic_event::meaning (diagnostic_event::VERB_release,\n+\t\t\t\t\tdiagnostic_event::NOUN_memory);\n+    return diagnostic_event::meaning ();\n+  }\n+\n protected:\n   const malloc_state_machine &m_sm;\n   tree m_arg;"}, {"sha": "83c19068be6dc1c2257b02c9b68696c35aaa5641", "filename": "gcc/analyzer/sm-sensitive.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fsm-sensitive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fsm-sensitive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-sensitive.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -117,6 +117,15 @@ class exposure_through_output_file\n     return label_text ();\n   }\n \n+  diagnostic_event::meaning\n+  get_meaning_for_state_change (const evdesc::state_change &change)\n+    const final override\n+  {\n+    if (change.m_new_state == m_sm.m_sensitive)\n+      return diagnostic_event::meaning (diagnostic_event::VERB_acquire,\n+\t\t\t\t\tdiagnostic_event::NOUN_sensitive);\n+    return diagnostic_event::meaning ();\n+  }\n   label_text describe_call_with_state (const evdesc::call_with_state &info)\n     final override\n   {"}, {"sha": "d2d03c3d602e9637aabaf585d757ef0adf9e3809", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -163,6 +163,17 @@ class taint_diagnostic : public pending_diagnostic\n \t\t\t\t     change.m_expr);\n     return label_text ();\n   }\n+\n+  diagnostic_event::meaning\n+  get_meaning_for_state_change (const evdesc::state_change &change)\n+    const final override\n+  {\n+    if (change.m_new_state == m_sm.m_tainted)\n+      return diagnostic_event::meaning (diagnostic_event::VERB_acquire,\n+\t\t\t\t\tdiagnostic_event::NOUN_taint);\n+    return diagnostic_event::meaning ();\n+  }\n+\n protected:\n   const taint_state_machine &m_sm;\n   tree m_arg;"}, {"sha": "846a0b1e3ff353f6f127f632316af5675e187770", "filename": "gcc/analyzer/varargs.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fvarargs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fanalyzer%2Fvarargs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fvarargs.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -335,6 +335,19 @@ class va_list_sm_diagnostic : public pending_diagnostic\n     return label_text ();\n   }\n \n+  diagnostic_event::meaning\n+  get_meaning_for_state_change (const evdesc::state_change &change)\n+    const final override\n+  {\n+    if (change.m_new_state == m_sm.m_started)\n+      return diagnostic_event::meaning (diagnostic_event::VERB_acquire,\n+\t\t\t\t\tdiagnostic_event::NOUN_resource);\n+    if (change.m_new_state == m_sm.m_ended)\n+      return diagnostic_event::meaning (diagnostic_event::VERB_release,\n+\t\t\t\t\tdiagnostic_event::NOUN_resource);\n+    return diagnostic_event::meaning ();\n+  }\n+\n protected:\n   va_list_sm_diagnostic (const va_list_state_machine &sm,\n \t\t\t const svalue *ap_sval, tree ap_tree)"}, {"sha": "0e67045a8717797460f5a38701171847abcee858", "filename": "gcc/c/c-lang.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fc%2Fc-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fc%2Fc-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-lang.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -46,9 +46,21 @@ enum c_language_kind c_language = clk_c;\n #undef LANG_HOOKS_GET_SUBSTRING_LOCATION\n #define LANG_HOOKS_GET_SUBSTRING_LOCATION c_get_substring_location\n \n+#undef LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE\n+#define LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE c_get_sarif_source_language\n+\n /* Each front end provides its own lang hook initializer.  */\n struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n+/* Get a value for the SARIF v2.1.0 \"artifact.sourceLanguage\" property,\n+   based on the list in SARIF v2.1.0 Appendix J.  */\n+\n+const char *\n+c_get_sarif_source_language (const char *)\n+{\n+  return \"c\";\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "e655afd1cd44825b2a82f6d67a3c6575d9ac14e8", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -837,6 +837,8 @@ set_c_expr_source_range (c_expr *expr,\n /* In c-fold.cc */\n extern vec<tree> incomplete_record_decls;\n \n+extern const char *c_get_sarif_source_language (const char *filename);\n+\n #if CHECKING_P\n namespace selftest {\n   extern void run_c_tests (void);"}, {"sha": "7ca0cceed82793a6fced01a3a137066298fe8e59", "filename": "gcc/common.opt", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -1390,7 +1390,7 @@ Common Joined RejectNegative UInteger\n \n fdiagnostics-format=\n Common Joined RejectNegative Enum(diagnostics_output_format)\n--fdiagnostics-format=[text|json|json-stderr|json-file]\tSelect output format.\n+-fdiagnostics-format=[text|sarif-stderr|sarif-file|json|json-stderr|json-file]\tSelect output format.\n \n fdiagnostics-escape-format=\n Common Joined RejectNegative Enum(diagnostics_escape_format)\n@@ -1433,6 +1433,12 @@ Enum(diagnostics_output_format) String(json-stderr) Value(DIAGNOSTICS_OUTPUT_FOR\n EnumValue\n Enum(diagnostics_output_format) String(json-file) Value(DIAGNOSTICS_OUTPUT_FORMAT_JSON_FILE)\n \n+EnumValue\n+Enum(diagnostics_output_format) String(sarif-stderr) Value(DIAGNOSTICS_OUTPUT_FORMAT_SARIF_STDERR)\n+\n+EnumValue\n+Enum(diagnostics_output_format) String(sarif-file) Value(DIAGNOSTICS_OUTPUT_FORMAT_SARIF_FILE)\n+\n fdiagnostics-parseable-fixits\n Common Var(flag_diagnostics_parseable_fixits)\n Print fix-it hints in machine-readable form."}, {"sha": "c3cfde56cc66e1dc24e2af0e0755b1b3d7443208", "filename": "gcc/cp/cp-lang.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fcp%2Fcp-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fcp%2Fcp-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -36,6 +36,7 @@ static tree get_template_argument_pack_elems_folded (const_tree);\n static tree cxx_enum_underlying_base_type (const_tree);\n static tree *cxx_omp_get_decl_init (tree);\n static void cxx_omp_finish_decl_inits (void);\n+static const char *cp_get_sarif_source_language (const char *);\n \n /* Lang hooks common to C++ and ObjC++ are declared in cp/cp-objcp-common.h;\n    consequently, there should be very few hooks below.  */\n@@ -100,6 +101,9 @@ static void cxx_omp_finish_decl_inits (void);\n #undef LANG_HOOKS_OMP_FINISH_DECL_INITS\n #define LANG_HOOKS_OMP_FINISH_DECL_INITS cxx_omp_finish_decl_inits\n \n+#undef LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE\n+#define LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE cp_get_sarif_source_language\n+\n /* Each front end provides its own lang hook initializer.  */\n struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n@@ -265,6 +269,15 @@ cxx_omp_finish_decl_inits (void)\n   dynamic_initializers = NULL;\n }\n \n+/* Get a value for the SARIF v2.1.0 \"artifact.sourceLanguage\" property,\n+   based on the list in SARIF v2.1.0 Appendix J.  */\n+\n+static const char *\n+cp_get_sarif_source_language (const char *)\n+{\n+  return \"cplusplus\";\n+}\n+\n #if CHECKING_P\n \n namespace selftest {"}, {"sha": "6e4350f54ccec1b5238e321fa8189f6d26c1f35f", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -1933,6 +1933,15 @@ d_enum_underlying_base_type (const_tree type)\n   return TREE_TYPE (type);\n }\n \n+/* Get a value for the SARIF v2.1.0 \"artifact.sourceLanguage\" property,\n+   based on the list in SARIF v2.1.0 Appendix J.  */\n+\n+static const char *\n+d_get_sarif_source_language (const char *)\n+{\n+  return \"d\";\n+}\n+\n /* Definitions for our language-specific hooks.  */\n \n #undef LANG_HOOKS_NAME\n@@ -1966,6 +1975,7 @@ d_enum_underlying_base_type (const_tree type)\n #undef LANG_HOOKS_TYPE_FOR_MODE\n #undef LANG_HOOKS_TYPE_FOR_SIZE\n #undef LANG_HOOKS_TYPE_PROMOTES_TO\n+#undef LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE\n \n #define LANG_HOOKS_NAME\t\t\t    \"GNU D\"\n #define LANG_HOOKS_INIT\t\t\t    d_init\n@@ -1998,6 +2008,7 @@ d_enum_underlying_base_type (const_tree type)\n #define LANG_HOOKS_TYPE_FOR_MODE\t    d_type_for_mode\n #define LANG_HOOKS_TYPE_FOR_SIZE\t    d_type_for_size\n #define LANG_HOOKS_TYPE_PROMOTES_TO\t    d_type_promotes_to\n+#define LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE d_get_sarif_source_language\n \n struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n "}, {"sha": "ba78546abebf69caea72be7519acaacf7d6fbf32", "filename": "gcc/diagnostic-client-data-hooks.h", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fdiagnostic-client-data-hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fdiagnostic-client-data-hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-client-data-hooks.h?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -0,0 +1,105 @@\n+/* Additional metadata about a client for a diagnostic context.\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_DIAGNOSTIC_CLIENT_DATA_HOOKS_H\n+#define GCC_DIAGNOSTIC_CLIENT_DATA_HOOKS_H\n+\n+class client_version_info;\n+\n+/* A bundle of additional metadata, owned by the diagnostic_context,\n+   for querying things about the client, like version data.  */\n+\n+class diagnostic_client_data_hooks\n+{\n+ public:\n+  virtual ~diagnostic_client_data_hooks () {}\n+\n+  /* Get version info for this client, or NULL.  */\n+  virtual const client_version_info *get_any_version_info () const = 0;\n+\n+  /* Get the current logical_location for this client, or NULL.  */\n+  virtual const logical_location *get_current_logical_location () const = 0;\n+\n+  /* Get a sourceLanguage value for FILENAME, or return NULL.\n+     See SARIF v2.1.0 Appendix J for suggested values.  */\n+  virtual const char *\n+  maybe_get_sarif_source_language (const char *filename) const = 0;\n+};\n+\n+/* Factory function for making an instance of diagnostic_client_data_hooks\n+   for use in the compiler (i.e. with knowledge of \"tree\", access to\n+   langhooks, etc).  */\n+\n+extern diagnostic_client_data_hooks *make_compiler_data_hooks ();\n+\n+class diagnostic_client_plugin_info;\n+\n+/* Abstract base class for a diagnostic_context to get at\n+   version information about the client.  */\n+\n+class client_version_info\n+{\n+public:\n+  class plugin_visitor\n+  {\n+  public:\n+    virtual void on_plugin (const diagnostic_client_plugin_info &) = 0;\n+  };\n+\n+  virtual ~client_version_info () {}\n+\n+  /* Get a string suitable for use as the value of the \"name\" property\n+     (SARIF v2.1.0 section 3.19.8).  */\n+  virtual const char *get_tool_name () const = 0;\n+\n+  /* Create a string suitable for use as the value of the \"fullName\" property\n+     (SARIF v2.1.0 section 3.19.9).  */\n+  virtual char *maybe_make_full_name () const = 0;\n+\n+  /* Get a string suitable for use as the value of the \"version\" property\n+     (SARIF v2.1.0 section 3.19.13).  */\n+  virtual const char *get_version_string () const = 0;\n+\n+  /* Create a string suitable for use as the value of the \"informationUri\"\n+     property (SARIF v2.1.0 section 3.19.17).  */\n+  virtual char *maybe_make_version_url () const = 0;\n+\n+  virtual void for_each_plugin (plugin_visitor &v) const = 0;\n+};\n+\n+/* Abstract base class for a diagnostic_context to get at\n+   information about a specific plugin within a client.  */\n+\n+class diagnostic_client_plugin_info\n+{\n+public:\n+  /* For use e.g. by SARIF \"name\" property (SARIF v2.1.0 section 3.19.8).  */\n+  virtual const char *get_short_name () const = 0;\n+\n+  /* For use e.g. by SARIF \"fullName\" property\n+     (SARIF v2.1.0 section 3.19.9).  */\n+  virtual const char *get_full_name () const = 0;\n+\n+  /* For use e.g. by SARIF \"version\" property\n+     (SARIF v2.1.0 section 3.19.13).  */\n+  virtual const char *get_version () const = 0;\n+};\n+\n+#endif /* ! GCC_DIAGNOSTIC_CLIENT_DATA_HOOKS_H */"}, {"sha": "0c33179e8cfbc4349639acb60821ef18c23434e0", "filename": "gcc/diagnostic-format-sarif.cc", "status": "added", "additions": 1586, "deletions": 0, "changes": 1586, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fdiagnostic-format-sarif.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fdiagnostic-format-sarif.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-format-sarif.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -0,0 +1,1586 @@\n+/* SARIF output for diagnostics\n+   Copyright (C) 2018-2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"diagnostic.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"diagnostic-path.h\"\n+#include \"json.h\"\n+#include \"cpplib.h\"\n+#include \"logical-location.h\"\n+#include \"diagnostic-client-data-hooks.h\"\n+\n+class sarif_builder;\n+\n+/* Subclass of json::object for SARIF result objects\n+   (SARIF v2.1.0 section 3.27.  */\n+\n+class sarif_result : public json::object\n+{\n+public:\n+  sarif_result () : m_related_locations_arr (NULL) {}\n+\n+  void\n+  on_nested_diagnostic (diagnostic_context *context,\n+\t\t\tdiagnostic_info *diagnostic,\n+\t\t\tdiagnostic_t orig_diag_kind,\n+\t\t\tsarif_builder *builder);\n+\n+private:\n+  json::array *m_related_locations_arr;\n+};\n+\n+/* A class for managing SARIF output (for -fdiagnostics-format=sarif-stderr\n+   and -fdiagnostics-format=sarif-file).\n+\n+   As diagnostics occur, we build \"result\" JSON objects, and\n+   accumulate state:\n+   - which source files are referenced\n+   - which warnings are emitted\n+   - which CWEs are used\n+\n+   At the end of the compile, we use the above to build the full SARIF\n+   object tree, adding the result objects to the correct place, and\n+   creating objects for the various source files, warnings and CWEs\n+   referenced.\n+\n+   Implemented:\n+   - fix-it hints\n+   - CWE metadata\n+   - diagnostic groups (see limitations below)\n+   - logical locations (e.g. cfun)\n+\n+   Known limitations:\n+   - GCC supports one-deep nesting of diagnostics (via auto_diagnostic_group),\n+     but we only capture location and message information from such nested\n+     diagnostics (e.g. we ignore fix-it hints on them)\n+   - doesn't yet capture command-line arguments: would be run.invocations\n+     property (SARIF v2.1.0 section 3.14.11), as invocation objects\n+     (SARIF v2.1.0 section 3.20), but we'd want to capture the arguments to\n+     toplev::main, and the response files.\n+   - doesn't capture escape_on_output_p\n+   - doesn't capture secondary locations within a rich_location\n+     (perhaps we should use the \"relatedLocations\" property: SARIF v2.1.0\n+     section 3.27.22)\n+   - doesn't capture \"artifact.encoding\" property\n+     (SARIF v2.1.0 section 3.24.9).\n+   - doesn't capture hashes of the source files\n+     (\"artifact.hashes\" property (SARIF v2.1.0 section 3.24.11).\n+   - doesn't capture the \"analysisTarget\" property\n+     (SARIF v2.1.0 section 3.27.13).\n+   - doesn't capture labelled ranges\n+   - doesn't capture -Werror cleanly\n+   - doesn't capture inlining information (can SARIF handle this?)\n+   - doesn't capture macro expansion information (can SARIF handle this?).  */\n+\n+class sarif_builder\n+{\n+public:\n+  sarif_builder (diagnostic_context *context);\n+\n+  void end_diagnostic (diagnostic_context *context, diagnostic_info *diagnostic,\n+\t\t       diagnostic_t orig_diag_kind);\n+\n+  void end_group ();\n+\n+  void flush_to_file (FILE *outf);\n+\n+  json::object *make_location_object (const rich_location &rich_loc,\n+\t\t\t\t      const logical_location *logical_loc);\n+  json::object *make_message_object (const char *msg) const;\n+\n+private:\n+  sarif_result *make_result_object (diagnostic_context *context,\n+\t\t\t\t    diagnostic_info *diagnostic,\n+\t\t\t\t    diagnostic_t orig_diag_kind);\n+  void set_any_logical_locs_arr (json::object *location_obj,\n+\t\t\t\t const logical_location *logical_loc);\n+  json::object *make_location_object (const diagnostic_event &event);\n+  json::object *\n+  make_logical_location_object (const logical_location &logical_loc) const;\n+  json::object *make_code_flow_object (const diagnostic_path &path);\n+  json::object *make_thread_flow_object (const diagnostic_path &path);\n+  json::object *\n+  make_thread_flow_location_object (const diagnostic_event &event);\n+  json::array *maybe_make_kinds_array (diagnostic_event::meaning m) const;\n+  json::object *maybe_make_physical_location_object (location_t loc);\n+  json::object *make_artifact_location_object (location_t loc);\n+  json::object *make_artifact_location_object (const char *filename);\n+  json::object *make_artifact_location_object_for_pwd () const;\n+  json::object *maybe_make_region_object (location_t loc) const;\n+  json::object *maybe_make_region_object_for_context (location_t loc) const;\n+  json::object *make_region_object_for_hint (const fixit_hint &hint) const;\n+  json::object *make_multiformat_message_string (const char *msg) const;\n+  json::object *make_top_level_object (json::array *results);\n+  json::object *make_run_object (json::array *results);\n+  json::object *make_tool_object () const;\n+  json::object *make_driver_tool_component_object () const;\n+  json::array *maybe_make_taxonomies_array () const;\n+  json::object *maybe_make_cwe_taxonomy_object () const;\n+  json::object *make_tool_component_reference_object_for_cwe () const;\n+  json::object *\n+  make_reporting_descriptor_object_for_warning (diagnostic_context *context,\n+\t\t\t\t\t\tdiagnostic_info *diagnostic,\n+\t\t\t\t\t\tdiagnostic_t orig_diag_kind,\n+\t\t\t\t\t\tconst char *option_text);\n+  json::object *make_reporting_descriptor_object_for_cwe_id (int cwe_id) const;\n+  json::object *\n+  make_reporting_descriptor_reference_object_for_cwe_id (int cwe_id);\n+  json::object *make_artifact_object (const char *filename);\n+  json::object *maybe_make_artifact_content_object (const char *filename) const;\n+  json::object *maybe_make_artifact_content_object (const char *filename,\n+\t\t\t\t\t\t    int start_line,\n+\t\t\t\t\t\t    int end_line) const;\n+  json::object *make_fix_object (const rich_location &rich_loc);\n+  json::object *make_artifact_change_object (const rich_location &richloc);\n+  json::object *make_replacement_object (const fixit_hint &hint) const;\n+  json::object *make_artifact_content_object (const char *text) const;\n+  int get_sarif_column (expanded_location exploc) const;\n+\n+  diagnostic_context *m_context;\n+\n+  /* The JSON array of pending diagnostics.  */\n+  json::array *m_results_array;\n+\n+  /* The JSON object for the result object (if any) in the current\n+     diagnostic group.  */\n+  sarif_result *m_cur_group_result;\n+\n+  hash_set <const char *> m_filenames;\n+  bool m_seen_any_relative_paths;\n+  hash_set <free_string_hash> m_rule_id_set;\n+  json::array *m_rules_arr;\n+\n+  /* The set of all CWE IDs we've seen, if any.  */\n+  hash_set <int_hash <int, 0, 1> > m_cwe_id_set;\n+\n+  int m_tabstop;\n+};\n+\n+static sarif_builder *the_builder;\n+\n+/* class sarif_result : public json::object.  */\n+\n+/* Handle secondary diagnostics that occur within a diagnostic group.\n+   The closest SARIF seems to have to nested diagnostics is the\n+   \"relatedLocations\" property of result objects (SARIF v2.1.0 section 3.27.22),\n+   so we lazily set this property and populate the array if and when\n+   secondary diagnostics occur (such as notes to a warning).  */\n+\n+void\n+sarif_result::on_nested_diagnostic (diagnostic_context *context,\n+\t\t\t\t    diagnostic_info *diagnostic,\n+\t\t\t\t    diagnostic_t /*orig_diag_kind*/,\n+\t\t\t\t    sarif_builder *builder)\n+{\n+  if (!m_related_locations_arr)\n+    {\n+      m_related_locations_arr = new json::array ();\n+      set (\"relatedLocations\", m_related_locations_arr);\n+    }\n+\n+  /* We don't yet generate meaningful logical locations for notes;\n+     sometimes these will related to current_function_decl, but\n+     often they won't.  */\n+  json::object *location_obj\n+    = builder->make_location_object (*diagnostic->richloc, NULL);\n+  json::object *message_obj\n+    = builder->make_message_object (pp_formatted_text (context->printer));\n+  pp_clear_output_area (context->printer);\n+  location_obj->set (\"message\", message_obj);\n+\n+  m_related_locations_arr->append (location_obj);\n+}\n+\n+/* class sarif_builder.  */\n+\n+/* sarif_builder's ctor.  */\n+\n+sarif_builder::sarif_builder (diagnostic_context *context)\n+: m_context (context),\n+  m_results_array (new json::array ()),\n+  m_cur_group_result (NULL),\n+  m_seen_any_relative_paths (false),\n+  m_rule_id_set (),\n+  m_rules_arr (new json::array ()),\n+  m_tabstop (context->tabstop)\n+{\n+}\n+\n+/* Implementation of \"end_diagnostic\" for SARIF output.  */\n+\n+void\n+sarif_builder::end_diagnostic (diagnostic_context *context,\n+\t\t\t       diagnostic_info *diagnostic,\n+\t\t\t       diagnostic_t orig_diag_kind)\n+{\n+\n+  if (m_cur_group_result)\n+    /* Nested diagnostic.  */\n+    m_cur_group_result->on_nested_diagnostic (context,\n+\t\t\t\t\t      diagnostic,\n+\t\t\t\t\t      orig_diag_kind,\n+\t\t\t\t\t      this);\n+  else\n+    {\n+      /* Top-level diagnostic.  */\n+      sarif_result *result_obj\n+\t= make_result_object (context, diagnostic, orig_diag_kind);\n+      m_results_array->append (result_obj);\n+      m_cur_group_result = result_obj;\n+    }\n+}\n+\n+/* Implementation of \"end_group_cb\" for SARIF output.  */\n+\n+void\n+sarif_builder::end_group ()\n+{\n+  m_cur_group_result = NULL;\n+}\n+\n+/* Create a top-level object, and add it to all the results\n+   (and other entities) we've seen so far.\n+\n+   Flush it all to OUTF.  */\n+\n+void\n+sarif_builder::flush_to_file (FILE *outf)\n+{\n+  json::object *top = make_top_level_object (m_results_array);\n+  top->dump (outf);\n+  m_results_array = NULL;\n+  fprintf (outf, \"\\n\");\n+  delete top;\n+}\n+\n+/* Attempt to convert DIAG_KIND to a suitable value for the \"level\"\n+   property (SARIF v2.1.0 section 3.27.10).\n+\n+   Return NULL if there isn't one.  */\n+\n+static const char *\n+maybe_get_sarif_level (diagnostic_t diag_kind)\n+{\n+  switch (diag_kind)\n+    {\n+    case DK_WARNING:\n+      return \"warning\";\n+    case DK_ERROR:\n+      return \"error\";\n+    case DK_NOTE:\n+    case DK_ANACHRONISM:\n+      return \"note\";\n+    default:\n+      return NULL;\n+    }\n+}\n+\n+/* Make a string for DIAG_KIND suitable for use a ruleId\n+   (SARIF v2.1.0 section 3.27.5) as a fallback for when we don't\n+   have anything better to use.  */\n+\n+static char *\n+make_rule_id_for_diagnostic_kind (diagnostic_t diag_kind)\n+{\n+  static const char *const diagnostic_kind_text[] = {\n+#define DEFINE_DIAGNOSTIC_KIND(K, T, C) (T),\n+#include \"diagnostic.def\"\n+#undef DEFINE_DIAGNOSTIC_KIND\n+    \"must-not-happen\"\n+  };\n+  /* Lose the trailing \": \".  */\n+  const char *kind_text = diagnostic_kind_text[diag_kind];\n+  size_t len = strlen (kind_text);\n+  gcc_assert (len > 2);\n+  gcc_assert (kind_text[len - 2] == ':');\n+  gcc_assert (kind_text[len - 1] == ' ');\n+  char *rstrip = xstrdup (kind_text);\n+  rstrip[len - 2] = '\\0';\n+  return rstrip;\n+}\n+\n+/* Make a result object (SARIF v2.1.0 section 3.27) for DIAGNOSTIC.  */\n+\n+sarif_result *\n+sarif_builder::make_result_object (diagnostic_context *context,\n+\t\t\t\t   diagnostic_info *diagnostic,\n+\t\t\t\t   diagnostic_t orig_diag_kind)\n+{\n+  sarif_result *result_obj = new sarif_result ();\n+\n+  /* \"ruleId\" property (SARIF v2.1.0 section 3.27.5).  */\n+  /* Ideally we'd have an option_name for these.  */\n+  if (char *option_text\n+\t= context->option_name (context, diagnostic->option_index,\n+\t\t\t\torig_diag_kind, diagnostic->kind))\n+    {\n+      /* Lazily create reportingDescriptor objects for and add to m_rules_arr.\n+\t Set ruleId referencing them.  */\n+      result_obj->set (\"ruleId\", new json::string (option_text));\n+      if (m_rule_id_set.contains (option_text))\n+\tfree (option_text);\n+      else\n+\t{\n+\t  /* This is the first time we've seen this ruleId.  */\n+\t  /* Add to set, taking ownership.  */\n+\t  m_rule_id_set.add (option_text);\n+\n+\t  json::object *reporting_desc_obj\n+\t    = make_reporting_descriptor_object_for_warning (context,\n+\t\t\t\t\t\t\t    diagnostic,\n+\t\t\t\t\t\t\t    orig_diag_kind,\n+\t\t\t\t\t\t\t    option_text);\n+\t  m_rules_arr->append (reporting_desc_obj);\n+\t}\n+    }\n+  else\n+    {\n+      /* Otherwise, we have an \"error\" or a stray \"note\"; use the\n+\t diagnostic kind as the ruleId, so that the result object at least\n+\t has a ruleId.\n+\t We don't bother creating reportingDescriptor objects for these.  */\n+      char *rule_id = make_rule_id_for_diagnostic_kind (orig_diag_kind);\n+      result_obj->set (\"ruleId\", new json::string (rule_id));\n+      free (rule_id);\n+    }\n+\n+  /* \"taxa\" property (SARIF v2.1.0 section 3.27.8).  */\n+  if (diagnostic->metadata)\n+    if (int cwe_id = diagnostic->metadata->get_cwe ())\n+      {\n+\tjson::array *taxa_arr = new json::array ();\n+\tjson::object *cwe_id_obj\n+\t  = make_reporting_descriptor_reference_object_for_cwe_id (cwe_id);\n+\ttaxa_arr->append (cwe_id_obj);\n+\tresult_obj->set (\"taxa\", taxa_arr);\n+      }\n+\n+  /* \"level\" property (SARIF v2.1.0 section 3.27.10).  */\n+  if (const char *sarif_level = maybe_get_sarif_level (diagnostic->kind))\n+    result_obj->set (\"level\", new json::string (sarif_level));\n+\n+  /* \"message\" property (SARIF v2.1.0 section 3.27.11).  */\n+  json::object *message_obj\n+    = make_message_object (pp_formatted_text (context->printer));\n+  pp_clear_output_area (context->printer);\n+  result_obj->set (\"message\", message_obj);\n+\n+  /* \"locations\" property (SARIF v2.1.0 section 3.27.12).  */\n+  json::array *locations_arr = new json::array ();\n+  const logical_location *logical_loc = NULL;\n+  if (m_context->m_client_data_hooks)\n+    logical_loc\n+      = m_context->m_client_data_hooks->get_current_logical_location ();\n+\n+  json::object *location_obj\n+    = make_location_object (*diagnostic->richloc, logical_loc);\n+  locations_arr->append (location_obj);\n+  result_obj->set (\"locations\", locations_arr);\n+\n+  /* \"codeFlows\" property (SARIF v2.1.0 section 3.27.18).  */\n+  if (const diagnostic_path *path = diagnostic->richloc->get_path ())\n+    {\n+      json::array *code_flows_arr = new json::array ();\n+      json::object *code_flow_obj = make_code_flow_object (*path);\n+      code_flows_arr->append (code_flow_obj);\n+      result_obj->set (\"codeFlows\", code_flows_arr);\n+    }\n+\n+  /* The \"relatedLocations\" property (SARIF v2.1.0 section 3.27.22) is\n+     set up later, if any nested diagnostics occur within this diagnostic\n+     group.  */\n+\n+  /* \"fixes\" property (SARIF v2.1.0 section 3.27.30).  */\n+  const rich_location *richloc = diagnostic->richloc;\n+  if (richloc->get_num_fixit_hints ())\n+    {\n+      json::array *fix_arr = new json::array ();\n+      json::object *fix_obj = make_fix_object (*richloc);\n+      fix_arr->append (fix_obj);\n+      result_obj->set (\"fixes\", fix_arr);\n+    }\n+\n+  return result_obj;\n+}\n+\n+/* Make a reportingDescriptor object (SARIF v2.1.0 section 3.49)\n+   for a GCC warning.  */\n+\n+json::object *\n+sarif_builder::\n+make_reporting_descriptor_object_for_warning (diagnostic_context *context,\n+\t\t\t\t\t      diagnostic_info *diagnostic,\n+\t\t\t\t\t      diagnostic_t /*orig_diag_kind*/,\n+\t\t\t\t\t      const char *option_text)\n+{\n+  json::object *reporting_desc = new json::object ();\n+\n+  /* \"id\" property (SARIF v2.1.0 section 3.49.3).  */\n+  reporting_desc->set (\"id\", new json::string (option_text));\n+\n+  /* We don't implement \"name\" property (SARIF v2.1.0 section 3.49.7), since\n+     it seems redundant compared to \"id\".  */\n+\n+  /* \"helpUri\" property (SARIF v2.1.0 section 3.49.12).  */\n+  if (context->get_option_url)\n+    {\n+      char *option_url\n+\t= context->get_option_url (context, diagnostic->option_index);\n+      if (option_url)\n+\t{\n+\t  reporting_desc->set (\"helpUri\", new json::string (option_url));\n+\t  free (option_url);\n+\t}\n+    }\n+\n+  return reporting_desc;\n+}\n+\n+/* Make a reportingDescriptor object (SARIF v2.1.0 section 3.49)\n+   for CWE_ID, for use within the CWE taxa array.  */\n+\n+json::object *\n+sarif_builder::make_reporting_descriptor_object_for_cwe_id (int cwe_id) const\n+{\n+  json::object *reporting_desc = new json::object ();\n+\n+  /* \"id\" property (SARIF v2.1.0 section 3.49.3).  */\n+  {\n+    pretty_printer pp;\n+    pp_printf (&pp, \"%i\", cwe_id);\n+    reporting_desc->set (\"id\", new json::string (pp_formatted_text (&pp)));\n+  }\n+\n+  /* \"helpUri\" property (SARIF v2.1.0 section 3.49.12).  */\n+  {\n+    char *url = get_cwe_url (cwe_id);\n+    reporting_desc->set (\"helpUri\", new json::string (url));\n+    free (url);\n+  }\n+\n+  return reporting_desc;\n+}\n+\n+/* Make a reportingDescriptorReference object (SARIF v2.1.0 section 3.52)\n+   referencing CWE_ID, for use within a result object.\n+   Also, add CWE_ID to m_cwe_id_set.  */\n+\n+json::object *\n+sarif_builder::\n+make_reporting_descriptor_reference_object_for_cwe_id (int cwe_id)\n+{\n+  json::object *desc_ref_obj = new json::object ();\n+\n+  /* \"id\" property (SARIF v2.1.0 section 3.52.4).  */\n+  {\n+    pretty_printer pp;\n+    pp_printf (&pp, \"%i\", cwe_id);\n+    desc_ref_obj->set (\"id\", new json::string (pp_formatted_text (&pp)));\n+  }\n+\n+  /* \"toolComponent\" property (SARIF v2.1.0 section 3.52.7).  */\n+  json::object *comp_ref_obj = make_tool_component_reference_object_for_cwe ();\n+  desc_ref_obj->set (\"toolComponent\", comp_ref_obj);\n+\n+  /* Add CWE_ID to our set.  */\n+  gcc_assert (cwe_id > 0);\n+  m_cwe_id_set.add (cwe_id);\n+\n+  return desc_ref_obj;\n+}\n+\n+/* Make a toolComponentReference object (SARIF v2.1.0 section 3.54) that\n+   references the CWE taxonomy.  */\n+\n+json::object *\n+sarif_builder::\n+make_tool_component_reference_object_for_cwe () const\n+{\n+  json::object *comp_ref_obj = new json::object ();\n+\n+  /* \"name\" property  (SARIF v2.1.0 section 3.54.3).  */\n+  comp_ref_obj->set (\"name\", new json::string (\"cwe\"));\n+\n+  return comp_ref_obj;\n+}\n+\n+/* If LOGICAL_LOC is non-NULL, use it to create a \"logicalLocations\" property\n+   within LOCATION_OBJ (SARIF v2.1.0 section 3.28.4).  */\n+\n+void\n+sarif_builder::\n+set_any_logical_locs_arr (json::object *location_obj,\n+\t\t\t  const logical_location *logical_loc)\n+{\n+  if (!logical_loc)\n+    return;\n+  json::object *logical_loc_obj = make_logical_location_object (*logical_loc);\n+  json::array *location_locs_arr = new json::array ();\n+  location_locs_arr->append (logical_loc_obj);\n+  location_obj->set (\"logicalLocations\", location_locs_arr);\n+}\n+\n+/* Make a location object (SARIF v2.1.0 section 3.28) for RICH_LOC\n+   and LOGICAL_LOC.  */\n+\n+json::object *\n+sarif_builder::make_location_object (const rich_location &rich_loc,\n+\t\t\t\t     const logical_location *logical_loc)\n+{\n+  json::object *location_obj = new json::object ();\n+\n+  /* Get primary loc from RICH_LOC.  */\n+  location_t loc = rich_loc.get_loc ();\n+\n+  /* \"physicalLocation\" property (SARIF v2.1.0 section 3.28.3).  */\n+  if (json::object *phs_loc_obj = maybe_make_physical_location_object (loc))\n+    location_obj->set (\"physicalLocation\", phs_loc_obj);\n+\n+  /* \"logicalLocations\" property (SARIF v2.1.0 section 3.28.4).  */\n+  set_any_logical_locs_arr (location_obj, logical_loc);\n+\n+  return location_obj;\n+}\n+\n+/* Make a location object (SARIF v2.1.0 section 3.28) for EVENT\n+   within a diagnostic_path.  */\n+\n+json::object *\n+sarif_builder::make_location_object (const diagnostic_event &event)\n+{\n+  json::object *location_obj = new json::object ();\n+\n+  /* \"physicalLocation\" property (SARIF v2.1.0 section 3.28.3).  */\n+  location_t loc = event.get_location ();\n+  if (json::object *phs_loc_obj = maybe_make_physical_location_object (loc))\n+    location_obj->set (\"physicalLocation\", phs_loc_obj);\n+\n+  /* \"logicalLocations\" property (SARIF v2.1.0 section 3.28.4).  */\n+  const logical_location *logical_loc = event.get_logical_location ();\n+  set_any_logical_locs_arr (location_obj, logical_loc);\n+\n+  /* \"message\" property (SARIF v2.1.0 section 3.28.5).  */\n+  label_text ev_desc = event.get_desc (false);\n+  json::object *message_obj = make_message_object (ev_desc.m_buffer);\n+  location_obj->set (\"message\", message_obj);\n+  ev_desc.maybe_free ();\n+\n+  return location_obj;\n+}\n+\n+/* Make a physicalLocation object (SARIF v2.1.0 section 3.29) for LOC,\n+   or return NULL;\n+   Add any filename to the m_artifacts.  */\n+\n+json::object *\n+sarif_builder::maybe_make_physical_location_object (location_t loc)\n+{\n+  if (loc <= BUILTINS_LOCATION)\n+    return NULL;\n+\n+  json::object *phys_loc_obj = new json::object ();\n+\n+  /* \"artifactLocation\" property (SARIF v2.1.0 section 3.29.3).  */\n+  json::object *artifact_loc_obj = make_artifact_location_object (loc);\n+  phys_loc_obj->set (\"artifactLocation\", artifact_loc_obj);\n+  m_filenames.add (LOCATION_FILE (loc));\n+\n+  /* \"region\" property (SARIF v2.1.0 section 3.29.4).  */\n+  if (json::object *region_obj = maybe_make_region_object (loc))\n+    phys_loc_obj->set (\"region\", region_obj);\n+\n+  /* \"contextRegion\" property (SARIF v2.1.0 section 3.29.5).  */\n+  if (json::object *context_region_obj\n+\t= maybe_make_region_object_for_context (loc))\n+    phys_loc_obj->set (\"contextRegion\", context_region_obj);\n+\n+  /* Instead, we add artifacts to the run as a whole,\n+     with artifact.contents.\n+     Could do both, though.  */\n+\n+  return phys_loc_obj;\n+}\n+\n+/* Make an artifactLocation object (SARIF v2.1.0 section 3.4) for LOC,\n+   or return NULL.  */\n+\n+json::object *\n+sarif_builder::make_artifact_location_object (location_t loc)\n+{\n+  return make_artifact_location_object (LOCATION_FILE (loc));\n+}\n+\n+/* The ID value for use in \"uriBaseId\" properties (SARIF v2.1.0 section 3.4.4)\n+   for when we need to express paths relative to PWD.  */\n+\n+#define PWD_PROPERTY_NAME (\"PWD\")\n+\n+/* Make an artifactLocation object (SARIF v2.1.0 section 3.4) for FILENAME,\n+   or return NULL.  */\n+\n+json::object *\n+sarif_builder::make_artifact_location_object (const char *filename)\n+{\n+  json::object *artifact_loc_obj = new json::object ();\n+\n+  /* \"uri\" property (SARIF v2.1.0 section 3.4.3).  */\n+  artifact_loc_obj->set (\"uri\", new json::string (filename));\n+\n+  if (filename[0] != '/')\n+    {\n+      /* If we have a relative path, set the \"uriBaseId\" property\n+\t (SARIF v2.1.0 section 3.4.4).  */\n+      artifact_loc_obj->set (\"uriBaseId\", new json::string (PWD_PROPERTY_NAME));\n+      m_seen_any_relative_paths = true;\n+    }\n+\n+  return artifact_loc_obj;\n+}\n+\n+/* Get the PWD, or NULL, as an absolute file-based URI,\n+   adding a trailing forward slash (as required by SARIF v2.1.0\n+   section 3.14.14).  */\n+\n+static char *\n+make_pwd_uri_str ()\n+{\n+  /* The prefix of a file-based URI, up to, but not including the path. */\n+#define FILE_PREFIX (\"file://\")\n+\n+  const char *pwd = getpwd ();\n+  if (!pwd)\n+    return NULL;\n+  size_t len = strlen (pwd);\n+  if (len == 0 || pwd[len - 1] != '/')\n+    return concat (FILE_PREFIX, pwd, \"/\", NULL);\n+  else\n+    {\n+      gcc_assert (pwd[len - 1] == '/');\n+      return concat (FILE_PREFIX, pwd, NULL);\n+    }\n+}\n+\n+/* Make an artifactLocation object (SARIF v2.1.0 section 3.4) for the pwd,\n+   for use in the \"run.originalUriBaseIds\" property (SARIF v2.1.0\n+   section 3.14.14) when we have any relative paths.  */\n+\n+json::object *\n+sarif_builder::make_artifact_location_object_for_pwd () const\n+{\n+  json::object *artifact_loc_obj = new json::object ();\n+\n+  /* \"uri\" property (SARIF v2.1.0 section 3.4.3).  */\n+  if (char *pwd = make_pwd_uri_str ())\n+    {\n+      gcc_assert (strlen (pwd) > 0);\n+      gcc_assert (pwd[strlen (pwd) - 1] == '/');\n+      artifact_loc_obj->set (\"uri\", new json::string (pwd));\n+      free (pwd);\n+    }\n+\n+  return artifact_loc_obj;\n+}\n+\n+/* Get the column number within EXPLOC.  */\n+\n+int\n+sarif_builder::get_sarif_column (expanded_location exploc) const\n+{\n+  cpp_char_column_policy policy (m_tabstop, cpp_wcwidth);\n+  return location_compute_display_column (exploc, policy);\n+}\n+\n+/* Make a region object (SARIF v2.1.0 section 3.30) for LOC,\n+   or return NULL.  */\n+\n+json::object *\n+sarif_builder::maybe_make_region_object (location_t loc) const\n+{\n+  location_t caret_loc = get_pure_location (loc);\n+\n+  if (caret_loc <= BUILTINS_LOCATION)\n+    return NULL;\n+\n+  location_t start_loc = get_start (loc);\n+  location_t finish_loc = get_finish (loc);\n+\n+  expanded_location exploc_caret = expand_location (caret_loc);\n+  expanded_location exploc_start = expand_location (start_loc);\n+  expanded_location exploc_finish = expand_location (finish_loc);\n+\n+  if (exploc_start.file !=exploc_caret.file)\n+    return NULL;\n+  if (exploc_finish.file !=exploc_caret.file)\n+    return NULL;\n+\n+  json::object *region_obj = new json::object ();\n+\n+  /* \"startLine\" property (SARIF v2.1.0 section 3.30.5) */\n+  region_obj->set (\"startLine\", new json::integer_number (exploc_start.line));\n+\n+  /* \"startColumn\" property (SARIF v2.1.0 section 3.30.6) */\n+  region_obj->set (\"startColumn\",\n+\t\t   new json::integer_number (get_sarif_column (exploc_start)));\n+\n+  /* \"endLine\" property (SARIF v2.1.0 section 3.30.7) */\n+  if (exploc_finish.line != exploc_start.line)\n+    region_obj->set (\"endLine\", new json::integer_number (exploc_finish.line));\n+\n+  /* \"endColumn\" property (SARIF v2.1.0 section 3.30.8).\n+     This expresses the column immediately beyond the range.  */\n+  {\n+    int next_column = sarif_builder::get_sarif_column (exploc_finish) + 1;\n+    region_obj->set (\"endColumn\", new json::integer_number (next_column));\n+  }\n+\n+  return region_obj;\n+}\n+\n+/* Make a region object (SARIF v2.1.0 section 3.30) for the \"contextRegion\"\n+   property (SARIF v2.1.0 section 3.29.5) of a physicalLocation.\n+\n+   This is similar to maybe_make_region_object, but ignores column numbers,\n+   covering the line(s) as a whole, and including a \"snippet\" property\n+   embedding those source lines, making it easier for consumers to show\n+   the pertinent source.  */\n+\n+json::object *\n+sarif_builder::maybe_make_region_object_for_context (location_t loc) const\n+{\n+  location_t caret_loc = get_pure_location (loc);\n+\n+  if (caret_loc <= BUILTINS_LOCATION)\n+    return NULL;\n+\n+  location_t start_loc = get_start (loc);\n+  location_t finish_loc = get_finish (loc);\n+\n+  expanded_location exploc_caret = expand_location (caret_loc);\n+  expanded_location exploc_start = expand_location (start_loc);\n+  expanded_location exploc_finish = expand_location (finish_loc);\n+\n+  if (exploc_start.file !=exploc_caret.file)\n+    return NULL;\n+  if (exploc_finish.file !=exploc_caret.file)\n+    return NULL;\n+\n+  json::object *region_obj = new json::object ();\n+\n+  /* \"startLine\" property (SARIF v2.1.0 section 3.30.5) */\n+  region_obj->set (\"startLine\", new json::integer_number (exploc_start.line));\n+\n+  /* \"endLine\" property (SARIF v2.1.0 section 3.30.7) */\n+  if (exploc_finish.line != exploc_start.line)\n+    region_obj->set (\"endLine\", new json::integer_number (exploc_finish.line));\n+\n+  /* \"snippet\" property (SARIF v2.1.0 section 3.30.13).  */\n+  if (json::object *artifact_content_obj\n+\t = maybe_make_artifact_content_object (exploc_start.file,\n+\t\t\t\t\t       exploc_start.line,\n+\t\t\t\t\t       exploc_finish.line))\n+    region_obj->set (\"snippet\", artifact_content_obj);\n+\n+  return region_obj;\n+}\n+\n+/* Make a region object (SARIF v2.1.0 section 3.30) for the deletion region\n+   of HINT (as per SARIF v2.1.0 section 3.57.3).  */\n+\n+json::object *\n+sarif_builder::make_region_object_for_hint (const fixit_hint &hint) const\n+{\n+  location_t start_loc = hint.get_start_loc ();\n+  location_t next_loc = hint.get_next_loc ();\n+\n+  expanded_location exploc_start = expand_location (start_loc);\n+  expanded_location exploc_next = expand_location (next_loc);\n+\n+  json::object *region_obj = new json::object ();\n+\n+  /* \"startLine\" property (SARIF v2.1.0 section 3.30.5) */\n+  region_obj->set (\"startLine\", new json::integer_number (exploc_start.line));\n+\n+  /* \"startColumn\" property (SARIF v2.1.0 section 3.30.6) */\n+  int start_col = get_sarif_column (exploc_start);\n+  region_obj->set (\"startColumn\",\n+\t\t   new json::integer_number (start_col));\n+\n+  /* \"endLine\" property (SARIF v2.1.0 section 3.30.7) */\n+  if (exploc_next.line != exploc_start.line)\n+    region_obj->set (\"endLine\", new json::integer_number (exploc_next.line));\n+\n+  /* \"endColumn\" property (SARIF v2.1.0 section 3.30.8).\n+     This expresses the column immediately beyond the range.  */\n+  int next_col =  get_sarif_column (exploc_next);\n+  region_obj->set (\"endColumn\", new json::integer_number (next_col));\n+\n+  return region_obj;\n+}\n+\n+/* Attempt to get a string for a logicalLocation's \"kind\" property\n+   (SARIF v2.1.0 section 3.33.7).\n+   Return NULL if unknown.  */\n+\n+static const char *\n+maybe_get_sarif_kind (enum logical_location_kind kind)\n+{\n+  switch (kind)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case LOGICAL_LOCATION_KIND_UNKNOWN:\n+      return NULL;\n+\n+    case LOGICAL_LOCATION_KIND_FUNCTION:\n+      return \"function\";\n+    case LOGICAL_LOCATION_KIND_MEMBER:\n+      return \"member\";\n+    case LOGICAL_LOCATION_KIND_MODULE:\n+      return \"module\";\n+    case LOGICAL_LOCATION_KIND_NAMESPACE:\n+      return \"namespace\";\n+    case LOGICAL_LOCATION_KIND_TYPE:\n+      return \"type\";\n+    case LOGICAL_LOCATION_KIND_RETURN_TYPE:\n+      return \"returnType\";\n+    case LOGICAL_LOCATION_KIND_PARAMETER:\n+      return \"parameter\";\n+    case LOGICAL_LOCATION_KIND_VARIABLE:\n+      return \"variable\";\n+    }\n+}\n+\n+/* Make a logicalLocation object (SARIF v2.1.0 section 3.33) for LOGICAL_LOC,\n+   or return NULL.  */\n+\n+json::object *\n+sarif_builder::\n+make_logical_location_object (const logical_location &logical_loc) const\n+{\n+  json::object *logical_loc_obj = new json::object ();\n+\n+  /* \"name\" property (SARIF v2.1.0 section 3.33.4).  */\n+  if (const char *short_name = logical_loc.get_short_name ())\n+    logical_loc_obj->set (\"name\", new json::string (short_name));\n+\n+  /* \"fullyQualifiedName\" property (SARIF v2.1.0 section 3.33.5).  */\n+  if (const char *name_with_scope = logical_loc.get_name_with_scope ())\n+    logical_loc_obj->set (\"fullyQualifiedName\",\n+\t\t\t  new json::string (name_with_scope));\n+\n+  /* \"decoratedName\" property (SARIF v2.1.0 section 3.33.6).  */\n+  if (const char *internal_name = logical_loc.get_internal_name ())\n+    logical_loc_obj->set (\"decoratedName\", new json::string (internal_name));\n+\n+  /* \"kind\" property (SARIF v2.1.0 section 3.33.7).  */\n+  enum logical_location_kind kind = logical_loc.get_kind ();\n+  if (const char *sarif_kind_str = maybe_get_sarif_kind (kind))\n+    logical_loc_obj->set (\"kind\", new json::string (sarif_kind_str));\n+\n+  return logical_loc_obj;\n+}\n+\n+/* Make a codeFlow object (SARIF v2.1.0 section 3.36) for PATH.  */\n+\n+json::object *\n+sarif_builder::make_code_flow_object (const diagnostic_path &path)\n+{\n+  json::object *code_flow_obj = new json::object ();\n+\n+  /* \"threadFlows\" property (SARIF v2.1.0 section 3.36.3).\n+     Currently we only support one thread per result.  */\n+  json::array *thread_flows_arr = new json::array ();\n+  json::object *thread_flow_obj = make_thread_flow_object (path);\n+  thread_flows_arr->append (thread_flow_obj);\n+  code_flow_obj->set (\"threadFlows\", thread_flows_arr);\n+\n+  return code_flow_obj;\n+}\n+\n+/* Make a threadFlow object (SARIF v2.1.0 section 3.37) for PATH.  */\n+\n+json::object *\n+sarif_builder::make_thread_flow_object (const diagnostic_path &path)\n+{\n+  json::object *thread_flow_obj = new json::object ();\n+\n+  /* \"locations\" property (SARIF v2.1.0 section 3.37.6).  */\n+  json::array *locations_arr = new json::array ();\n+  for (unsigned i = 0; i < path.num_events (); i++)\n+    {\n+      const diagnostic_event &event = path.get_event (i);\n+      json::object *thread_flow_loc_obj\n+\t= make_thread_flow_location_object (event);\n+      locations_arr->append (thread_flow_loc_obj);\n+    }\n+  thread_flow_obj->set (\"locations\", locations_arr);\n+\n+  return thread_flow_obj;\n+}\n+\n+/* Make a threadFlowLocation object (SARIF v2.1.0 section 3.38) for EVENT.  */\n+\n+json::object *\n+sarif_builder::make_thread_flow_location_object (const diagnostic_event &ev)\n+{\n+  json::object *thread_flow_loc_obj = new json::object ();\n+\n+  /* \"location\" property (SARIF v2.1.0 section 3.38.3).  */\n+  json::object *location_obj = make_location_object (ev);\n+  thread_flow_loc_obj->set (\"location\", location_obj);\n+\n+  /* \"kinds\" property (SARIF v2.1.0 section 3.38.8).  */\n+  diagnostic_event::meaning m = ev.get_meaning ();\n+  if (json::array *kinds_arr = maybe_make_kinds_array (m))\n+    thread_flow_loc_obj->set (\"kinds\", kinds_arr);\n+\n+  /* \"nestingLevel\" property (SARIF v2.1.0 section 3.38.10).  */\n+  thread_flow_loc_obj->set (\"nestingLevel\",\n+\t\t\t    new json::integer_number (ev.get_stack_depth ()));\n+\n+  /* It might be nice to eventually implement the following for -fanalyzer:\n+     - the \"stack\" property (SARIF v2.1.0 section 3.38.5)\n+     - the \"state\" property (SARIF v2.1.0 section 3.38.9)\n+     - the \"importance\" property (SARIF v2.1.0 section 3.38.13).  */\n+\n+  return thread_flow_loc_obj;\n+}\n+\n+/* If M has any known meaning, make a json array suitable for the \"kinds\"\n+   property of a threadFlowLocation object (SARIF v2.1.0 section 3.38.8).\n+\n+   Otherwise, return NULL.  */\n+\n+json::array *\n+sarif_builder::maybe_make_kinds_array (diagnostic_event::meaning m) const\n+{\n+  if (m.m_verb == diagnostic_event::VERB_unknown\n+      && m.m_noun == diagnostic_event::NOUN_unknown\n+      && m.m_property == diagnostic_event::PROPERTY_unknown)\n+    return NULL;\n+\n+  json::array *kinds_arr = new json::array ();\n+  if (const char *verb_str\n+\t= diagnostic_event::meaning::maybe_get_verb_str (m.m_verb))\n+    kinds_arr->append (new json::string (verb_str));\n+  if (const char *noun_str\n+\t= diagnostic_event::meaning::maybe_get_noun_str (m.m_noun))\n+    kinds_arr->append (new json::string (noun_str));\n+  if (const char *property_str\n+\t= diagnostic_event::meaning::maybe_get_property_str (m.m_property))\n+    kinds_arr->append (new json::string (property_str));\n+  return kinds_arr;\n+}\n+\n+/* Make a message object (SARIF v2.1.0 section 3.11) for MSG.  */\n+\n+json::object *\n+sarif_builder::make_message_object (const char *msg) const\n+{\n+  json::object *message_obj = new json::object ();\n+\n+  /* \"text\" property (SARIF v2.1.0 section 3.11.8).  */\n+  message_obj->set (\"text\", new json::string (msg));\n+\n+  return message_obj;\n+}\n+\n+/* Make a multiformatMessageString object (SARIF v2.1.0 section 3.12)\n+   for MSG.  */\n+\n+json::object *\n+sarif_builder::make_multiformat_message_string (const char *msg) const\n+{\n+  json::object *message_obj = new json::object ();\n+\n+  /* \"text\" property (SARIF v2.1.0 section 3.12.3).  */\n+  message_obj->set (\"text\", new json::string (msg));\n+\n+  return message_obj;\n+}\n+\n+#define SARIF_SCHEMA \"https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json\"\n+#define SARIF_VERSION \"2.1.0\"\n+\n+/* Make a top-level sarifLog object (SARIF v2.1.0 section 3.13).\n+   Take ownership of RESULTS.  */\n+\n+json::object *\n+sarif_builder::make_top_level_object (json::array *results)\n+{\n+  json::object *log_obj = new json::object ();\n+\n+  /* \"$schema\" property (SARIF v2.1.0 section 3.13.3) .  */\n+  log_obj->set (\"$schema\", new json::string (SARIF_SCHEMA));\n+\n+  /* \"version\" property (SARIF v2.1.0 section 3.13.2).  */\n+  log_obj->set (\"version\", new json::string (SARIF_VERSION));\n+\n+  /* \"runs\" property (SARIF v2.1.0 section 3.13.4).  */\n+  json::array *run_arr = new json::array ();\n+  json::object *run_obj = make_run_object (results);\n+  run_arr->append (run_obj);\n+  log_obj->set (\"runs\", run_arr);\n+\n+  return log_obj;\n+}\n+\n+/* Make a run object (SARIF v2.1.0 section 3.14).\n+   Take ownership of RESULTS.  */\n+\n+json::object *\n+sarif_builder::make_run_object (json::array *results)\n+{\n+  json::object *run_obj = new json::object ();\n+\n+  /* \"tool\" property (SARIF v2.1.0 section 3.14.6).  */\n+  json::object *tool_obj = make_tool_object ();\n+  run_obj->set (\"tool\", tool_obj);\n+\n+  /* \"taxonomies\" property (SARIF v2.1.0 section 3.14.8).  */\n+  if (json::array *taxonomies_arr = maybe_make_taxonomies_array ())\n+    run_obj->set (\"taxonomies\", taxonomies_arr);\n+\n+  /* \"originalUriBaseIds (SARIF v2.1.0 section 3.14.14).  */\n+  if (m_seen_any_relative_paths)\n+    {\n+      json::object *orig_uri_base_ids = new json::object ();\n+      run_obj->set (\"originalUriBaseIds\", orig_uri_base_ids);\n+      json::object *pwd_art_loc_obj = make_artifact_location_object_for_pwd ();\n+      orig_uri_base_ids->set (PWD_PROPERTY_NAME, pwd_art_loc_obj);\n+    }\n+\n+  /* \"artifacts\" property (SARIF v2.1.0 section 3.14.15).  */\n+  json::array *artifacts_arr = new json::array ();\n+  for (auto iter : m_filenames)\n+    {\n+      json::object *artifact_obj = make_artifact_object (iter);\n+      artifacts_arr->append (artifact_obj);\n+    }\n+  run_obj->set (\"artifacts\", artifacts_arr);\n+\n+  /* \"results\" property (SARIF v2.1.0 section 3.14.23).  */\n+  run_obj->set (\"results\", results);\n+\n+  return run_obj;\n+}\n+\n+/* Make a tool object (SARIF v2.1.0 section 3.18).  */\n+\n+json::object *\n+sarif_builder::make_tool_object () const\n+{\n+  json::object *tool_obj = new json::object ();\n+\n+  /* \"driver\" property (SARIF v2.1.0 section 3.18.2).  */\n+  json::object *driver_obj = make_driver_tool_component_object ();\n+  tool_obj->set (\"driver\", driver_obj);\n+\n+  /* Report plugins via the \"extensions\" property\n+     (SARIF v2.1.0 section 3.18.3).  */\n+  if (m_context->m_client_data_hooks)\n+    if (const client_version_info *vinfo\n+\t  = m_context->m_client_data_hooks->get_any_version_info ())\n+      {\n+\tclass my_plugin_visitor : public client_version_info :: plugin_visitor\n+\t{\n+\tpublic:\n+\t  void on_plugin (const diagnostic_client_plugin_info &p) final override\n+\t  {\n+\t    /* Create a toolComponent object (SARIF v2.1.0 section 3.19)\n+\t       for the plugin.  */\n+\t    json::object *plugin_obj = new json::object ();\n+\t    m_plugin_objs.safe_push (plugin_obj);\n+\n+\t    /* \"name\" property (SARIF v2.1.0 section 3.19.8).  */\n+\t    if (const char *short_name = p.get_short_name ())\n+\t      plugin_obj->set (\"name\", new json::string (short_name));\n+\n+\t    /* \"fullName\" property (SARIF v2.1.0 section 3.19.9).  */\n+\t    if (const char *full_name = p.get_full_name ())\n+\t      plugin_obj->set (\"fullName\", new json::string (full_name));\n+\n+\t    /* \"version\" property (SARIF v2.1.0 section 3.19.13).  */\n+\t    if (const char *version = p.get_version ())\n+\t      plugin_obj->set (\"version\", new json::string (version));\n+\t  }\n+\t  auto_vec <json::object *> m_plugin_objs;\n+\t};\n+\tmy_plugin_visitor v;\n+\tvinfo->for_each_plugin (v);\n+\tif (v.m_plugin_objs.length () > 0)\n+\t  {\n+\t    json::array *extensions_arr = new json::array ();\n+\t    tool_obj->set (\"extensions\", extensions_arr);\n+\t    for (auto iter : v.m_plugin_objs)\n+\t      extensions_arr->append (iter);\n+\t  }\n+      }\n+\n+  /* Perhaps we could also show GMP, MPFR, MPC, isl versions as other\n+     \"extensions\" (see toplev.cc: print_version).  */\n+\n+  return tool_obj;\n+}\n+\n+/* Make a toolComponent object (SARIF v2.1.0 section 3.19) for what SARIF\n+   calls the \"driver\" (see SARIF v2.1.0 section 3.18.1).  */\n+\n+json::object *\n+sarif_builder::make_driver_tool_component_object () const\n+{\n+  json::object *driver_obj = new json::object ();\n+\n+  if (m_context->m_client_data_hooks)\n+    if (const client_version_info *vinfo\n+\t  = m_context->m_client_data_hooks->get_any_version_info ())\n+      {\n+\t/* \"name\" property (SARIF v2.1.0 section 3.19.8).  */\n+\tif (const char *name = vinfo->get_tool_name ())\n+\t  driver_obj->set (\"name\", new json::string (name));\n+\n+\t/* \"fullName\" property (SARIF v2.1.0 section 3.19.9).  */\n+\tif (char *full_name = vinfo->maybe_make_full_name ())\n+\t  {\n+\t    driver_obj->set (\"fullName\", new json::string (full_name));\n+\t    free (full_name);\n+\t  }\n+\n+\t/* \"version\" property (SARIF v2.1.0 section 3.19.13).  */\n+\tif (const char *version = vinfo->get_version_string ())\n+\t  driver_obj->set (\"version\", new json::string (version));\n+\n+\t/* \"informationUri\" property (SARIF v2.1.0 section 3.19.17).  */\n+\tif (char *version_url =  vinfo->maybe_make_version_url ())\n+\t  {\n+\t    driver_obj->set (\"informationUri\", new json::string (version_url));\n+\t    free (version_url);\n+\t  }\n+      }\n+\n+  /* \"rules\" property (SARIF v2.1.0 section 3.19.23).  */\n+  driver_obj->set (\"rules\", m_rules_arr);\n+\n+  return driver_obj;\n+}\n+\n+/* If we've seen any CWE IDs, make an array for the \"taxonomies\" property\n+   (SARIF v2.1.0 section 3.14.8) of a run object, containting a singl\n+   toolComponent (3.19) as per 3.19.3, representing the CWE.\n+\n+   Otherwise return NULL.  */\n+\n+json::array *\n+sarif_builder::maybe_make_taxonomies_array () const\n+{\n+  json::object *cwe_obj = maybe_make_cwe_taxonomy_object ();\n+  if (!cwe_obj)\n+    return NULL;\n+\n+  /* \"taxonomies\" property (SARIF v2.1.0 section 3.14.8).  */\n+  json::array *taxonomies_arr = new json::array ();\n+  taxonomies_arr->append (cwe_obj);\n+  return taxonomies_arr;\n+}\n+\n+/* If we've seen any CWE IDs, make a toolComponent object\n+   (SARIF v2.1.0 section 3.19) representing the CWE taxonomy, as per 3.19.3.\n+   Populate the \"taxa\" property with all of the CWE IDs in m_cwe_id_set.\n+\n+   Otherwise return NULL.  */\n+\n+json::object *\n+sarif_builder::maybe_make_cwe_taxonomy_object () const\n+{\n+  if (m_cwe_id_set.is_empty ())\n+    return NULL;\n+\n+  json::object *taxonomy_obj = new json::object ();\n+\n+  /* \"name\" property (SARIF v2.1.0 section 3.19.8).  */\n+  taxonomy_obj->set (\"name\", new json::string (\"CWE\"));\n+\n+  /* \"version\" property (SARIF v2.1.0 section 3.19.13).  */\n+  taxonomy_obj->set (\"version\", new json::string (\"4.7\"));\n+\n+  /* \"organization\" property (SARIF v2.1.0 section 3.19.18).  */\n+  taxonomy_obj->set (\"organization\", new json::string (\"MITRE\"));\n+\n+  /* \"shortDescription\" property (SARIF v2.1.0 section 3.19.19).  */\n+  json::object *short_desc\n+    = make_multiformat_message_string (\"The MITRE\"\n+\t\t\t\t       \" Common Weakness Enumeration\");\n+  taxonomy_obj->set (\"shortDescription\", short_desc);\n+\n+  /* \"taxa\" property (SARIF v2.1.0 3.section 3.19.25).  */\n+  json::array *taxa_arr = new json::array ();\n+  for (auto cwe_id : m_cwe_id_set)\n+    {\n+      json::object *cwe_taxon\n+\t= make_reporting_descriptor_object_for_cwe_id (cwe_id);\n+      taxa_arr->append (cwe_taxon);\n+    }\n+  taxonomy_obj->set (\"taxa\", taxa_arr);\n+\n+  return taxonomy_obj;\n+}\n+\n+/* Make an artifact object (SARIF v2.1.0 section 3.24).  */\n+\n+json::object *\n+sarif_builder::make_artifact_object (const char *filename)\n+{\n+  json::object *artifact_obj = new json::object ();\n+\n+  /* \"location\" property (SARIF v2.1.0 section 3.24.2).  */\n+  json::object *artifact_loc_obj = make_artifact_location_object (filename);\n+  artifact_obj->set (\"location\", artifact_loc_obj);\n+\n+  /* \"contents\" property (SARIF v2.1.0 section 3.24.8).  */\n+  if (json::object *artifact_content_obj\n+\t= maybe_make_artifact_content_object (filename))\n+    artifact_obj->set (\"contents\", artifact_content_obj);\n+\n+  /* \"sourceLanguage\" property (SARIF v2.1.0 section 3.24.10).  */\n+  if (m_context->m_client_data_hooks)\n+    if (const char *source_lang\n+\t= m_context->m_client_data_hooks->maybe_get_sarif_source_language\n+\t    (filename))\n+      artifact_obj->set (\"sourceLanguage\", new json::string (source_lang));\n+\n+  return artifact_obj;\n+}\n+\n+/* Read all data from F_IN until EOF.\n+   Return a NULL-terminated buffer containing the data, which must be\n+   freed by the caller.\n+   Return NULL on errors.  */\n+\n+static char *\n+read_until_eof (FILE *f_in)\n+{\n+  /* Read content, allocating a buffer for it.  */\n+  char *result = NULL;\n+  size_t total_sz = 0;\n+  size_t alloc_sz = 0;\n+  char buf[4096];\n+  size_t iter_sz_in;\n+\n+  while ( (iter_sz_in = fread (buf, 1, sizeof (buf), f_in)) )\n+    {\n+      gcc_assert (alloc_sz >= total_sz);\n+      size_t old_total_sz = total_sz;\n+      total_sz += iter_sz_in;\n+      /* Allow 1 extra byte for 0-termination.  */\n+      if (alloc_sz < (total_sz + 1))\n+\t{\n+\t  size_t new_alloc_sz = alloc_sz ? alloc_sz * 2: total_sz + 1;\n+\t  result = (char *)xrealloc (result, new_alloc_sz);\n+\t  alloc_sz = new_alloc_sz;\n+\t}\n+      memcpy (result + old_total_sz, buf, iter_sz_in);\n+    }\n+\n+  if (!feof (f_in))\n+    return NULL;\n+\n+  /* 0-terminate the buffer.  */\n+  gcc_assert (total_sz < alloc_sz);\n+  result[total_sz] = '\\0';\n+\n+  return result;\n+}\n+\n+/* Read all data from FILENAME until EOF.\n+   Return a NULL-terminated buffer containing the data, which must be\n+   freed by the caller.\n+   Return NULL on errors.  */\n+\n+static char *\n+maybe_read_file (const char *filename)\n+{\n+  FILE *f_in = fopen (filename, \"r\");\n+  if (!f_in)\n+    return NULL;\n+  char *result = read_until_eof (f_in);\n+  fclose (f_in);\n+  return result;\n+}\n+\n+/* Make an artifactContent object (SARIF v2.1.0 section 3.3) for the\n+   full contents of FILENAME.  */\n+\n+json::object *\n+sarif_builder::maybe_make_artifact_content_object (const char *filename) const\n+{\n+  char *text_utf8 = maybe_read_file (filename);\n+  if (!text_utf8)\n+    return NULL;\n+\n+  json::object *artifact_content_obj = new json::object ();\n+  artifact_content_obj->set (\"text\", new json::string (text_utf8));\n+  free (text_utf8);\n+\n+  return artifact_content_obj;\n+}\n+\n+/* Attempt to read the given range of lines from FILENAME; return\n+   a freshly-allocated 0-terminated buffer containing them, or NULL.  */\n+\n+static char *\n+get_source_lines (const char *filename,\n+\t\t  int start_line,\n+\t\t  int end_line)\n+{\n+  auto_vec<char> result;\n+\n+  for (int line = start_line; line <= end_line; line++)\n+    {\n+      char_span line_content = location_get_source_line (filename, line);\n+      if (!line_content.get_buffer ())\n+\treturn NULL;\n+      result.reserve (line_content.length () + 1);\n+      for (size_t i = 0; i < line_content.length (); i++)\n+\tresult.quick_push (line_content[i]);\n+      result.quick_push ('\\n');\n+    }\n+  result.safe_push ('\\0');\n+\n+  return xstrdup (result.address ());\n+}\n+\n+/* Make an artifactContent object (SARIF v2.1.0 section 3.3) for the given\n+   run of lines within FILENAME (including the endpoints).  */\n+\n+json::object *\n+sarif_builder::maybe_make_artifact_content_object (const char *filename,\n+\t\t\t\t\t\t   int start_line,\n+\t\t\t\t\t\t   int end_line) const\n+{\n+  char *text_utf8 = get_source_lines (filename, start_line, end_line);\n+\n+  if (!text_utf8)\n+    return NULL;\n+\n+  json::object *artifact_content_obj = new json::object ();\n+  artifact_content_obj->set (\"text\", new json::string (text_utf8));\n+  free (text_utf8);\n+\n+  return artifact_content_obj;\n+}\n+\n+/* Make a fix object (SARIF v2.1.0 section 3.55) for RICHLOC.  */\n+\n+json::object *\n+sarif_builder::make_fix_object (const rich_location &richloc)\n+{\n+  json::object *fix_obj = new json::object ();\n+\n+  /* \"artifactChanges\" property (SARIF v2.1.0 section 3.55.3).  */\n+  /* We assume that all fix-it hints in RICHLOC affect the same file.  */\n+  json::array *artifact_change_arr = new json::array ();\n+  json::object *artifact_change_obj = make_artifact_change_object (richloc);\n+  artifact_change_arr->append (artifact_change_obj);\n+  fix_obj->set (\"artifactChanges\", artifact_change_arr);\n+\n+  return fix_obj;\n+}\n+\n+/* Make an artifactChange object (SARIF v2.1.0 section 3.56) for RICHLOC.  */\n+\n+json::object *\n+sarif_builder::make_artifact_change_object (const rich_location &richloc)\n+{\n+  json::object *artifact_change_obj = new json::object ();\n+\n+  /* \"artifactLocation\" property (SARIF v2.1.0 section 3.56.2).  */\n+  json::object *artifact_location_obj\n+    = make_artifact_location_object (richloc.get_loc ());\n+  artifact_change_obj->set (\"artifactLocation\", artifact_location_obj);\n+\n+  /* \"replacements\" property (SARIF v2.1.0 section 3.56.3).  */\n+  json::array *replacement_arr = new json::array ();\n+  for (unsigned int i = 0; i < richloc.get_num_fixit_hints (); i++)\n+    {\n+      const fixit_hint *hint = richloc.get_fixit_hint (i);\n+      json::object *replacement_obj = make_replacement_object (*hint);\n+      replacement_arr->append (replacement_obj);\n+    }\n+  artifact_change_obj->set (\"replacements\", replacement_arr);\n+\n+  return artifact_change_obj;\n+}\n+\n+/* Make a replacement object (SARIF v2.1.0 section 3.57) for HINT.  */\n+\n+json::object *\n+sarif_builder::make_replacement_object (const fixit_hint &hint) const\n+{\n+  json::object *replacement_obj = new json::object ();\n+\n+  /* \"deletedRegion\" property (SARIF v2.1.0 section 3.57.3).  */\n+  json::object *region_obj = make_region_object_for_hint (hint);\n+  replacement_obj->set (\"deletedRegion\", region_obj);\n+\n+  /* \"insertedContent\" property (SARIF v2.1.0 section 3.57.4).  */\n+  json::object *content_obj = make_artifact_content_object (hint.get_string ());\n+  replacement_obj->set (\"insertedContent\", content_obj);\n+\n+  return replacement_obj;\n+}\n+\n+/* Make an artifactContent object (SARIF v2.1.0 section 3.3) for TEXT.  */\n+\n+json::object *\n+sarif_builder::make_artifact_content_object (const char *text) const\n+{\n+  json::object *content_obj = new json::object ();\n+\n+  /* \"text\" property (SARIF v2.1.0 section 3.3.2).  */\n+  content_obj->set (\"text\", new json::string (text));\n+\n+  return content_obj;\n+}\n+\n+/* No-op implementation of \"begin_diagnostic\" for SARIF output.  */\n+\n+static void\n+sarif_begin_diagnostic (diagnostic_context *, diagnostic_info *)\n+{\n+}\n+\n+/* Implementation of \"end_diagnostic\" for SARIF output.  */\n+\n+static void\n+sarif_end_diagnostic (diagnostic_context *context, diagnostic_info *diagnostic,\n+\t\t      diagnostic_t orig_diag_kind)\n+{\n+  gcc_assert (the_builder);\n+  the_builder->end_diagnostic (context, diagnostic, orig_diag_kind);\n+}\n+\n+/* No-op implementation of \"begin_group_cb\" for SARIF output.  */\n+\n+static void\n+sarif_begin_group (diagnostic_context *)\n+{\n+}\n+\n+/* Implementation of \"end_group_cb\" for SARIF output.  */\n+\n+static void\n+sarif_end_group (diagnostic_context *)\n+{\n+  gcc_assert (the_builder);\n+  the_builder->end_group ();\n+}\n+\n+/* Flush the top-level array to OUTF.  */\n+\n+static void\n+sarif_flush_to_file (FILE *outf)\n+{\n+  gcc_assert (the_builder);\n+  the_builder->flush_to_file (outf);\n+  delete the_builder;\n+  the_builder = NULL;\n+}\n+\n+/* Callback for final cleanup for SARIF output to stderr.  */\n+\n+static void\n+sarif_stderr_final_cb (diagnostic_context *)\n+{\n+  gcc_assert (the_builder);\n+  sarif_flush_to_file (stderr);\n+}\n+\n+static char *sarif_output_base_file_name;\n+\n+/* Callback for final cleanup for SARIF output to a file.  */\n+\n+static void\n+sarif_file_final_cb (diagnostic_context *)\n+{\n+  char *filename = concat (sarif_output_base_file_name, \".sarif\", NULL);\n+  FILE *outf = fopen (filename, \"w\");\n+  if (!outf)\n+    {\n+      const char *errstr = xstrerror (errno);\n+      fnotice (stderr, \"error: unable to open '%s' for writing: %s\\n\",\n+\t       filename, errstr);\n+      free (filename);\n+      return;\n+    }\n+  gcc_assert (the_builder);\n+  sarif_flush_to_file (outf);\n+  fclose (outf);\n+  free (filename);\n+}\n+\n+/* Populate CONTEXT in preparation for SARIF output (either to stderr, or\n+   to a file).  */\n+\n+static void\n+diagnostic_output_format_init_sarif (diagnostic_context *context)\n+{\n+  the_builder = new sarif_builder (context);\n+\n+  /* Override callbacks.  */\n+  context->begin_diagnostic = sarif_begin_diagnostic;\n+  context->end_diagnostic = sarif_end_diagnostic;\n+  context->begin_group_cb = sarif_begin_group;\n+  context->end_group_cb =  sarif_end_group;\n+  context->print_path = NULL; /* handled in sarif_end_diagnostic.  */\n+\n+  /* The metadata is handled in SARIF format, rather than as text.  */\n+  context->show_cwe = false;\n+\n+  /* The option is handled in SARIF format, rather than as text.  */\n+  context->show_option_requested = false;\n+\n+  /* Don't colorize the text.  */\n+  pp_show_color (context->printer) = false;\n+}\n+\n+/* Populate CONTEXT in preparation for SARIF output to stderr.  */\n+\n+void\n+diagnostic_output_format_init_sarif_stderr (diagnostic_context *context)\n+{\n+  diagnostic_output_format_init_sarif (context);\n+  context->final_cb = sarif_stderr_final_cb;\n+}\n+\n+/* Populate CONTEXT in preparation for SARIF output to a file named\n+   BASE_FILE_NAME.sarif.  */\n+\n+void\n+diagnostic_output_format_init_sarif_file (diagnostic_context *context,\n+\t\t\t\t\t const char *base_file_name)\n+{\n+  diagnostic_output_format_init_sarif (context);\n+  context->final_cb = sarif_file_final_cb;\n+  sarif_output_base_file_name = xstrdup (base_file_name);\n+}"}, {"sha": "8ce4ff763d42c15cb15737960e1975a845ba29cd", "filename": "gcc/diagnostic-path.h", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fdiagnostic-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fdiagnostic-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-path.h?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -69,6 +69,75 @@ along with GCC; see the file COPYING3.  If not see\n class diagnostic_event\n {\n  public:\n+  /* Enums for giving a sense of what this event means.\n+     Roughly corresponds to SARIF v2.1.0 section 3.38.8.  */\n+  enum verb\n+  {\n+    VERB_unknown,\n+\n+    VERB_acquire,\n+    VERB_release,\n+    VERB_enter,\n+    VERB_exit,\n+    VERB_call,\n+    VERB_return,\n+    VERB_branch,\n+\n+    VERB_danger\n+  };\n+  enum noun\n+  {\n+    NOUN_unknown,\n+\n+    NOUN_taint,\n+    NOUN_sensitive, // this one isn't in SARIF v2.1.0; filed as https://github.com/oasis-tcs/sarif-spec/issues/530\n+    NOUN_function,\n+    NOUN_lock,\n+    NOUN_memory,\n+    NOUN_resource\n+  };\n+  enum property\n+  {\n+    PROPERTY_unknown,\n+\n+    PROPERTY_true,\n+    PROPERTY_false\n+  };\n+  /* A bundle of such enums, allowing for descriptions of the meaning of\n+     an event, such as\n+     - \"acquire memory\": meaning (VERB_acquire, NOUN_memory)\n+     - \"take true branch\"\": meaning (VERB_branch, PROPERTY_true)\n+     - \"return from function\": meaning (VERB_return, NOUN_function)\n+     etc, as per SARIF's threadFlowLocation \"kinds\" property\n+     (SARIF v2.1.0 section 3.38.8).  */\n+  struct meaning\n+  {\n+    meaning ()\n+    : m_verb (VERB_unknown),\n+      m_noun (NOUN_unknown),\n+      m_property (PROPERTY_unknown)\n+    {\n+    }\n+    meaning (enum verb verb, enum noun noun)\n+    : m_verb (verb), m_noun (noun), m_property (PROPERTY_unknown)\n+    {\n+    }\n+    meaning (enum verb verb, enum property property)\n+    : m_verb (verb), m_noun (NOUN_unknown), m_property (property)\n+    {\n+    }\n+\n+    void dump_to_pp (pretty_printer *pp) const;\n+\n+    static const char *maybe_get_verb_str (enum verb);\n+    static const char *maybe_get_noun_str (enum noun);\n+    static const char *maybe_get_property_str (enum property);\n+\n+    enum verb m_verb;\n+    enum noun m_noun;\n+    enum property m_property;\n+  };\n+\n   virtual ~diagnostic_event () {}\n \n   virtual location_t get_location () const = 0;\n@@ -81,6 +150,11 @@ class diagnostic_event\n \n   /* Get a localized (and possibly colorized) description of this event.  */\n   virtual label_text get_desc (bool can_colorize) const = 0;\n+\n+  /* Get a logical_location for this event, or NULL.  */\n+  virtual const logical_location *get_logical_location () const = 0;\n+\n+  virtual meaning get_meaning () const = 0;\n };\n \n /* Abstract base class for getting at a sequence of events.  */\n@@ -113,6 +187,14 @@ class simple_diagnostic_event : public diagnostic_event\n   {\n     return label_text::borrow (m_desc);\n   }\n+  const logical_location *get_logical_location () const final override\n+  {\n+    return NULL;\n+  }\n+  meaning get_meaning () const final override\n+  {\n+    return meaning ();\n+  }\n \n  private:\n   location_t m_loc;"}, {"sha": "f2a82fff46290d2cc56ec8679116de3757e00c0b", "filename": "gcc/diagnostic.cc", "status": "modified", "additions": 127, "deletions": 1, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fdiagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fdiagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-url.h\"\n #include \"diagnostic-metadata.h\"\n #include \"diagnostic-path.h\"\n+#include \"diagnostic-client-data-hooks.h\"\n #include \"edit-context.h\"\n #include \"selftest.h\"\n #include \"selftest-diagnostic.h\"\n@@ -240,6 +241,7 @@ diagnostic_initialize (diagnostic_context *context, int n_opts)\n   context->end_group_cb = NULL;\n   context->final_cb = default_diagnostic_final_cb;\n   context->includes_seen = NULL;\n+  context->m_client_data_hooks = NULL;\n }\n \n /* Maybe initialize the color support. We require clients to do this\n@@ -338,6 +340,12 @@ diagnostic_finish (diagnostic_context *context)\n       delete context->includes_seen;\n       context->includes_seen = nullptr;\n     }\n+\n+  if (context->m_client_data_hooks)\n+    {\n+      delete context->m_client_data_hooks;\n+      context->m_client_data_hooks = NULL;\n+    }\n }\n \n /* Initialize DIAGNOSTIC, where the message MSG has already been\n@@ -820,6 +828,116 @@ diagnostic_show_any_path (diagnostic_context *context,\n     context->print_path (context, path);\n }\n \n+/* class diagnostic_event.  */\n+\n+/* struct diagnostic_event::meaning.  */\n+\n+void\n+diagnostic_event::meaning::dump_to_pp (pretty_printer *pp) const\n+{\n+  bool need_comma = false;\n+  pp_character (pp, '{');\n+  if (const char *verb_str = maybe_get_verb_str (m_verb))\n+    {\n+      pp_printf (pp, \"verb: %qs\", verb_str);\n+      need_comma = true;\n+    }\n+  if (const char *noun_str = maybe_get_noun_str (m_noun))\n+    {\n+      if (need_comma)\n+\tpp_string (pp, \", \");\n+      pp_printf (pp, \"noun: %qs\", noun_str);\n+      need_comma = true;\n+    }\n+  if (const char *property_str = maybe_get_property_str (m_property))\n+    {\n+      if (need_comma)\n+\tpp_string (pp, \", \");\n+      pp_printf (pp, \"property: %qs\", property_str);\n+      need_comma = true;\n+    }\n+  pp_character (pp, '}');\n+}\n+\n+/* Get a string (or NULL) for V suitable for use within a SARIF\n+   threadFlowLocation \"kinds\" property (SARIF v2.1.0 section 3.38.8).  */\n+\n+const char *\n+diagnostic_event::meaning::maybe_get_verb_str (enum verb v)\n+{\n+  switch (v)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case VERB_unknown:\n+      return NULL;\n+    case VERB_acquire:\n+      return \"acquire\";\n+    case VERB_release:\n+      return \"release\";\n+    case VERB_enter:\n+      return \"enter\";\n+    case VERB_exit:\n+      return \"exit\";\n+    case VERB_call:\n+      return \"call\";\n+    case VERB_return:\n+      return \"return\";\n+    case VERB_branch:\n+      return \"branch\";\n+    case VERB_danger:\n+      return \"danger\";\n+    }\n+}\n+\n+/* Get a string (or NULL) for N suitable for use within a SARIF\n+   threadFlowLocation \"kinds\" property (SARIF v2.1.0 section 3.38.8).  */\n+\n+const char *\n+diagnostic_event::meaning::maybe_get_noun_str (enum noun n)\n+{\n+  switch (n)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case NOUN_unknown:\n+      return NULL;\n+    case NOUN_taint:\n+      return \"taint\";\n+    case NOUN_sensitive:\n+      return \"sensitive\";\n+    case NOUN_function:\n+      return \"function\";\n+    case NOUN_lock:\n+      return \"lock\";\n+    case NOUN_memory:\n+      return \"memory\";\n+    case NOUN_resource:\n+      return \"resource\";\n+    }\n+}\n+\n+/* Get a string (or NULL) for P suitable for use within a SARIF\n+   threadFlowLocation \"kinds\" property (SARIF v2.1.0 section 3.38.8).  */\n+\n+const char *\n+diagnostic_event::meaning::maybe_get_property_str (enum property p)\n+{\n+  switch (p)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case PROPERTY_unknown:\n+      return NULL;\n+    case PROPERTY_true:\n+      return \"true\";\n+    case PROPERTY_false:\n+      return \"false\";\n+    }\n+}\n+\n+/* class diagnostic_path.  */\n+\n /* Return true if the events in this path involve more than one\n    function, or false if it is purely intraprocedural.  */\n \n@@ -1131,7 +1249,7 @@ update_effective_level_from_pragmas (diagnostic_context *context,\n /* Generate a URL string describing CWE.  The caller is responsible for\n    freeing the string.  */\n \n-static char *\n+char *\n get_cwe_url (int cwe)\n {\n   return xasprintf (\"https://cwe.mitre.org/data/definitions/%i.html\", cwe);\n@@ -2095,6 +2213,14 @@ diagnostic_output_format_init (diagnostic_context *context,\n     case DIAGNOSTICS_OUTPUT_FORMAT_JSON_FILE:\n       diagnostic_output_format_init_json_file (context, base_file_name);\n       break;\n+\n+    case DIAGNOSTICS_OUTPUT_FORMAT_SARIF_STDERR:\n+      diagnostic_output_format_init_sarif_stderr (context);\n+      break;\n+\n+    case DIAGNOSTICS_OUTPUT_FORMAT_SARIF_FILE:\n+      diagnostic_output_format_init_sarif_file (context, base_file_name);\n+      break;\n     }\n }\n "}, {"sha": "96c9a7202f9750eaa511e4ac624ec2c4f551ed5b", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -63,7 +63,13 @@ enum diagnostics_output_format\n   DIAGNOSTICS_OUTPUT_FORMAT_JSON_STDERR,\n \n   /* JSON-based output, to a file.  */\n-  DIAGNOSTICS_OUTPUT_FORMAT_JSON_FILE\n+  DIAGNOSTICS_OUTPUT_FORMAT_JSON_FILE,\n+\n+  /* SARIF-based output, to stderr.  */\n+  DIAGNOSTICS_OUTPUT_FORMAT_SARIF_STDERR,\n+\n+  /* SARIF-based output, to a file.  */\n+  DIAGNOSTICS_OUTPUT_FORMAT_SARIF_FILE\n };\n \n /* An enum for controlling how diagnostic_paths should be printed.  */\n@@ -162,6 +168,8 @@ typedef void (*diagnostic_finalizer_fn) (diagnostic_context *,\n \n class edit_context;\n namespace json { class value; }\n+class diagnostic_client_data_hooks;\n+class logical_location;\n \n /* This data structure bundles altogether any information relevant to\n    the context of a diagnostic message.  */\n@@ -397,6 +405,12 @@ struct diagnostic_context\n   /* Include files that diagnostic_report_current_module has already listed the\n      include path for.  */\n   hash_set<location_t, false, location_hash> *includes_seen;\n+\n+  /* A bundle of hooks for providing data to the context about its client\n+     e.g. version information, plugins, etc.\n+     Used by SARIF output to give metadata about the client that's\n+     producing diagnostics.  */\n+  diagnostic_client_data_hooks *m_client_data_hooks;\n };\n \n static inline void\n@@ -585,6 +599,9 @@ extern void diagnostic_output_format_init (diagnostic_context *,\n extern void diagnostic_output_format_init_json_stderr (diagnostic_context *context);\n extern void diagnostic_output_format_init_json_file (diagnostic_context *context,\n \t\t\t\t\t\t     const char *base_file_name);\n+extern void diagnostic_output_format_init_sarif_stderr (diagnostic_context *context);\n+extern void diagnostic_output_format_init_sarif_file (diagnostic_context *context,\n+\t\t\t\t\t\t      const char *base_file_name);\n \n /* Compute the number of digits in the decimal representation of an integer.  */\n extern int num_digits (int);\n@@ -594,4 +611,6 @@ extern json::value *json_from_expanded_location (diagnostic_context *context,\n \n extern bool warning_enabled_at (location_t, int);\n \n+extern char *get_cwe_url (int cwe);\n+\n #endif /* ! GCC_DIAGNOSTIC_H */"}, {"sha": "8cd5bdddc5d36360e255dd84ca5f84d8ab163751", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -301,7 +301,7 @@ Objective-C and Objective-C++ Dialects}.\n -fdiagnostics-show-location=@r{[}once@r{|}every-line@r{]}  @gol\n -fdiagnostics-color=@r{[}auto@r{|}never@r{|}always@r{]}  @gol\n -fdiagnostics-urls=@r{[}auto@r{|}never@r{|}always@r{]}  @gol\n--fdiagnostics-format=@r{[}text@r{|}json@r{|}json-stderr@r{|}json-file@r{]}  @gol\n+-fdiagnostics-format=@r{[}text@r{|}sarif-stderr@r{|}sarif-file@r{|}json@r{|}json-stderr@r{|}json-file@r{]}  @gol\n -fno-diagnostics-show-option  -fno-diagnostics-show-caret @gol\n -fno-diagnostics-show-labels  -fno-diagnostics-show-line-numbers @gol\n -fno-diagnostics-show-cwe  @gol\n@@ -5305,11 +5305,15 @@ Unicode characters.  For the example above, the following will be printed:\n @item -fdiagnostics-format=@var{FORMAT}\n @opindex fdiagnostics-format\n Select a different format for printing diagnostics.\n-@var{FORMAT} is @samp{text}, @samp{json}, @samp{json-stderr},\n-or @samp{json-file}.\n+@var{FORMAT} is @samp{text}, @samp{sarif-stderr}, @samp{sarif-file},\n+@samp{json}, @samp{json-stderr}, or @samp{json-file}.\n \n The default is @samp{text}.\n \n+The @samp{sarif-stderr} and @samp{sarif-file} formats both emit\n+diagnostics in SARIF Version 2.1.0 format, either to stderr, or to a file\n+named @file{@var{source}.sarif}, respectively.\n+\n The @samp{json} format is a synonym for @samp{json-stderr}.\n The @samp{json-stderr} and @samp{json-file} formats are identical, apart from\n where the JSON is emitted to - with the former, the JSON is emitted to stderr,"}, {"sha": "606ab85a116685950966fa947957b834429fbefc", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -3152,6 +3152,12 @@ Passes if @var{regexp} matches in Fortran module @var{module}.\n @item dg-check-dot @var{filename}\n Passes if @var{filename} is a valid @file{.dot} file (by running\n @code{dot -Tpng} on it, and verifying the exit code is 0).\n+@item scan-sarif-file @var{regexp} [@{ target/xfail @var{selector} @}]\n+Passes if @var{regexp} matches text in the file generated by\n+@option{-fdiagnostics-format=sarif-file}.\n+@item scan-sarif-file-not @var{regexp} [@{ target/xfail @var{selector} @}]\n+Passes if @var{regexp} does not match text in the file generated by\n+@option{-fdiagnostics-format=sarif-file}.\n @end table\n \n @subsubsection Scan the assembly output"}, {"sha": "319cf8ff573c4821954194a3a79a2e556d8a3dc0", "filename": "gcc/fortran/f95-lang.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ffortran%2Ff95-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ffortran%2Ff95-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -100,6 +100,15 @@ static const struct attribute_spec gfc_attribute_table[] =\n   { NULL,\t\t  0, 0, false, false, false, false, NULL, NULL }\n };\n \n+/* Get a value for the SARIF v2.1.0 \"artifact.sourceLanguage\" property,\n+   based on the list in SARIF v2.1.0 Appendix J.  */\n+\n+static const char *\n+gfc_get_sarif_source_language (const char *)\n+{\n+  return \"fortran\";\n+}\n+\n #undef LANG_HOOKS_NAME\n #undef LANG_HOOKS_INIT\n #undef LANG_HOOKS_FINISH\n@@ -138,6 +147,7 @@ static const struct attribute_spec gfc_attribute_table[] =\n #undef LANG_HOOKS_BUILTIN_FUNCTION\n #undef LANG_HOOKS_GET_ARRAY_DESCR_INFO\n #undef LANG_HOOKS_ATTRIBUTE_TABLE\n+#undef LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE\n \n /* Define lang hooks.  */\n #define LANG_HOOKS_NAME                 \"GNU Fortran\"\n@@ -177,6 +187,7 @@ static const struct attribute_spec gfc_attribute_table[] =\n #define LANG_HOOKS_BUILTIN_FUNCTION\tgfc_builtin_function\n #define LANG_HOOKS_GET_ARRAY_DESCR_INFO\tgfc_get_array_descr_info\n #define LANG_HOOKS_ATTRIBUTE_TABLE\tgfc_attribute_table\n+#define LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE gfc_get_sarif_source_language\n \n struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n "}, {"sha": "84cd623bbf88811f10e959007854bf94852ece2a", "filename": "gcc/go/go-lang.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fgo%2Fgo-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fgo%2Fgo-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -545,6 +545,15 @@ go_langhook_eh_personality (void)\n   return personality_decl;\n }\n \n+/* Get a value for the SARIF v2.1.0 \"artifact.sourceLanguage\" property,\n+   based on the list in SARIF v2.1.0 Appendix J.  */\n+\n+static const char *\n+go_get_sarif_source_language (const char *)\n+{\n+  return \"go\";\n+}\n+\n /* Functions called directly by the generic backend.  */\n \n tree\n@@ -615,6 +624,7 @@ go_localize_identifier (const char *ident)\n #undef LANG_HOOKS_GETDECLS\n #undef LANG_HOOKS_GIMPLIFY_EXPR\n #undef LANG_HOOKS_EH_PERSONALITY\n+#undef LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE\n \n #define LANG_HOOKS_NAME\t\t\t\"GNU Go\"\n #define LANG_HOOKS_INIT\t\t\tgo_langhook_init\n@@ -631,6 +641,7 @@ go_localize_identifier (const char *ident)\n #define LANG_HOOKS_GETDECLS\t\tgo_langhook_getdecls\n #define LANG_HOOKS_GIMPLIFY_EXPR\tgo_langhook_gimplify_expr\n #define LANG_HOOKS_EH_PERSONALITY\tgo_langhook_eh_personality\n+#define LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE go_get_sarif_source_language\n \n struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n "}, {"sha": "4e17915e8b332c2fb9b73ec9ab793346bc0c4baa", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -98,6 +98,7 @@ extern const char *lhd_get_substring_location (const substring_loc &,\n extern int lhd_decl_dwarf_attribute (const_tree, int);\n extern int lhd_type_dwarf_attribute (const_tree, int);\n extern void lhd_finalize_early_debug (void);\n+extern const char *lhd_get_sarif_source_language (const char *);\n \n #define LANG_HOOKS_NAME\t\t\t\"GNU unknown\"\n #define LANG_HOOKS_IDENTIFIER_SIZE\tsizeof (struct lang_identifier)\n@@ -150,6 +151,7 @@ extern void lhd_finalize_early_debug (void);\n #define LANG_HOOKS_RUN_LANG_SELFTESTS   lhd_do_nothing\n #define LANG_HOOKS_GET_SUBSTRING_LOCATION lhd_get_substring_location\n #define LANG_HOOKS_FINALIZE_EARLY_DEBUG lhd_finalize_early_debug\n+#define LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE lhd_get_sarif_source_language\n \n /* Attribute hooks.  */\n #define LANG_HOOKS_ATTRIBUTE_TABLE\t\tNULL\n@@ -394,7 +396,8 @@ extern void lhd_end_section (void);\n   LANG_HOOKS_EMITS_BEGIN_STMT, \\\n   LANG_HOOKS_RUN_LANG_SELFTESTS, \\\n   LANG_HOOKS_GET_SUBSTRING_LOCATION, \\\n-  LANG_HOOKS_FINALIZE_EARLY_DEBUG \\\n+  LANG_HOOKS_FINALIZE_EARLY_DEBUG,   \\\n+  LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE \\\n }\n \n #endif /* GCC_LANG_HOOKS_DEF_H */"}, {"sha": "a93340799f331a323f8ca1f011b3138c27aac182", "filename": "gcc/langhooks.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Flanghooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Flanghooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -925,6 +925,14 @@ lhd_finalize_early_debug (void)\n     (*debug_hooks->early_global_decl) (cnode->decl);\n }\n \n+/* Default implementation of LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE.  */\n+\n+const char *\n+lhd_get_sarif_source_language (const char *)\n+{\n+  return NULL;\n+}\n+\n /* Returns true if the current lang_hooks represents the GNU C frontend.  */\n \n bool"}, {"sha": "97aa9e0d070db36d83b777f378863eabf297cb5f", "filename": "gcc/langhooks.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -640,6 +640,12 @@ struct lang_hooks\n   /* Invoked before the early_finish debug hook is invoked.  */\n   void (*finalize_early_debug) (void);\n \n+  /* Get a value for the SARIF v2.1.0 \"artifact.sourceLanguage\" property\n+     for FILENAME, or return NULL.\n+     See SARIF v2.1.0 Appendix J for suggested values for common programming\n+     languages.  */\n+  const char *(*get_sarif_source_language) (const char *filename);\n+\n   /* Whenever you add entries here, make sure you adjust langhooks-def.h\n      and langhooks.cc accordingly.  */\n };"}, {"sha": "2e7b8e3ad1f480b8e5999144334966a8251a47fa", "filename": "gcc/logical-location.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Flogical-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Flogical-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flogical-location.h?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -0,0 +1,72 @@\n+/* Logical location support, without knowledge of \"tree\".\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_LOGICAL_LOCATION_H\n+#define GCC_LOGICAL_LOCATION_H\n+\n+/* An enum for discriminating between different kinds of logical location\n+   for a diagnostic.\n+\n+   Roughly corresponds to logicalLocation's \"kind\" property in SARIF v2.1.0\n+   (section 3.33.7).  */\n+\n+enum logical_location_kind\n+{\n+  LOGICAL_LOCATION_KIND_UNKNOWN,\n+\n+  LOGICAL_LOCATION_KIND_FUNCTION,\n+  LOGICAL_LOCATION_KIND_MEMBER,\n+  LOGICAL_LOCATION_KIND_MODULE,\n+  LOGICAL_LOCATION_KIND_NAMESPACE,\n+  LOGICAL_LOCATION_KIND_TYPE,\n+  LOGICAL_LOCATION_KIND_RETURN_TYPE,\n+  LOGICAL_LOCATION_KIND_PARAMETER,\n+  LOGICAL_LOCATION_KIND_VARIABLE\n+};\n+\n+/* Abstract base class for passing around logical locations in the\n+   diagnostics subsystem, such as:\n+   - \"within function 'foo'\", or\n+   - \"within method 'bar'\",\n+   but *without* requiring knowledge of trees\n+   (see tree-logical-location.h for subclasses relating to trees).  */\n+\n+class logical_location\n+{\n+public:\n+  virtual ~logical_location () {}\n+\n+  /* Get a string (or NULL) suitable for use by the SARIF logicalLocation\n+     \"name\" property (SARIF v2.1.0 section 3.33.4).  */\n+  virtual const char *get_short_name () const = 0;\n+\n+  /* Get a string (or NULL) suitable for use by the SARIF logicalLocation\n+     \"fullyQualifiedName\" property (SARIF v2.1.0 section 3.33.5).  */\n+  virtual const char *get_name_with_scope () const = 0;\n+\n+  /* Get a string (or NULL) suitable for use by the SARIF logicalLocation\n+     \"decoratedName\" property (SARIF v2.1.0 section 3.33.6).  */\n+  virtual const char *get_internal_name () const = 0;\n+\n+  /* Get what kind of SARIF logicalLocation this is (if any).  */\n+  virtual enum logical_location_kind get_kind () const = 0;\n+};\n+\n+#endif /* GCC_LOGICAL_LOCATION_H.  */"}, {"sha": "4f9c3a2b69baba2d8a88b26f99a94a62b7d378eb", "filename": "gcc/objc/objc-act.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fobjc%2Fobjc-act.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fobjc%2Fobjc-act.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.h?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -27,6 +27,7 @@ bool objc_init (void);\n const char *objc_printable_name (tree, int);\n int objc_gimplify_expr (tree *, gimple_seq *, gimple_seq *);\n void objc_common_init_ts (void);\n+const char *objc_get_sarif_source_language (const char *);\n \n /* NB: The remaining public functions are prototyped in c-common.h, for the\n    benefit of stub-objc.cc and objc-act.cc.  */"}, {"sha": "559de4bd56a9a22f713ec014eea541ae37db969e", "filename": "gcc/objc/objc-lang.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fobjc%2Fobjc-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fobjc%2Fobjc-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -46,10 +46,18 @@ enum c_language_kind c_language = clk_objc;\n #define LANG_HOOKS_INIT_TS objc_common_init_ts\n #undef LANG_HOOKS_TREE_SIZE\n #define LANG_HOOKS_TREE_SIZE objc_common_tree_size\n+#undef LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE\n+#define LANG_HOOKS_GET_SARIF_SOURCE_LANGUAGE objc_get_sarif_source_language\n \n /* Each front end provides its own lang hook initializer.  */\n struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n+const char *\n+objc_get_sarif_source_language (const char *)\n+{\n+  return \"objectivec\";\n+}\n+\n /* Lang hook routines common to C and ObjC appear in c-objc-common.cc;\n    there should be very few (if any) routines below.  */\n "}, {"sha": "6c42e057cbc3643ac1e0e4b31f62c34475180c14", "filename": "gcc/plugin.cc", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fplugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fplugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -815,6 +815,44 @@ finalize_plugins (void)\n   plugin_name_args_tab = NULL;\n }\n \n+/* Implementation detail of for_each_plugin.  */\n+\n+struct for_each_plugin_closure\n+{\n+  void (*cb) (const plugin_name_args *,\n+\t      void *user_data);\n+  void *user_data;\n+};\n+\n+/* Implementation detail of for_each_plugin: callback for htab_traverse_noresize\n+   that calls the user-provided callback.  */\n+\n+static int\n+for_each_plugin_cb (void **slot, void *info)\n+{\n+  struct plugin_name_args *plugin = (struct plugin_name_args *) *slot;\n+  for_each_plugin_closure *c = (for_each_plugin_closure *)info;\n+  c->cb (plugin, c->user_data);\n+  return 1;\n+}\n+\n+/* Call CB with USER_DATA on each plugin.  */\n+\n+void\n+for_each_plugin (void (*cb) (const plugin_name_args *,\n+\t\t\t     void *user_data),\n+\t\t void *user_data)\n+{\n+  if (!plugin_name_args_tab)\n+    return;\n+\n+  for_each_plugin_closure c;\n+  c.cb = cb;\n+  c.user_data = user_data;\n+\n+  htab_traverse_noresize (plugin_name_args_tab, for_each_plugin_cb, &c);\n+}\n+\n /* Used to pass options to htab_traverse callbacks. */\n \n struct print_options"}, {"sha": "e7e8b51d15a175ec37c98c6e5059d89166510e45", "filename": "gcc/plugin.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fplugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Fplugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.h?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -170,6 +170,9 @@ extern void warn_if_plugins (void);\n extern void print_plugins_versions (FILE *file, const char *indent);\n extern void print_plugins_help (FILE *file, const char *indent);\n extern void finalize_plugins (void);\n+extern void for_each_plugin (void (*cb) (const plugin_name_args *,\n+\t\t\t\t\t void *user_data),\n+\t\t\t     void *user_data);\n \n extern bool flag_plugin_added;\n "}, {"sha": "4d19ae14bb48704091dd8fa99a9086878b04aaed", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-sarif-file-1.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-1.c?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-format=sarif-file\" } */\n+\n+#warning message\n+\n+/* Verify that some JSON was written to a file with the expected name.  */\n+\n+/* We expect various properties.\n+   The indentation here reflects the expected hierarchy, though these tests\n+   don't check for that, merely the string fragments we expect.\n+   { dg-final { scan-sarif-file \"\\\"version\\\": \\\"2.1.0\\\"\" } }\n+   { dg-final { scan-sarif-file \"\\\"runs\\\": \\\\\\[\" } }\n+     { dg-final { scan-sarif-file \"\\\"artifacts\\\": \\\\\\[\" } } \n+       { dg-final { scan-sarif-file \"\\\"location\\\": \" } }\n+         { dg-final { scan-sarif-file \"\\\"uri\\\": \" } }\n+\n+       { dg-final { scan-sarif-file \"\\\"sourceLanguage\\\": \\\"c\\\"\" { target c } } }\n+       { dg-final { scan-sarif-file \"\\\"sourceLanguage\\\": \\\"cplusplus\\\"\" { target c++ } } }\n+\n+       { dg-final { scan-sarif-file \"\\\"contents\\\": \" } }\n+         { dg-final { scan-sarif-file \"\\\"text\\\": \" } }\n+     { dg-final { scan-sarif-file \"\\\"tool\\\": \" } }\n+       { dg-final { scan-sarif-file \"\\\"driver\\\": \" } }\n+         { dg-final { scan-sarif-file \"\\\"name\\\": \\\"GNU C\" } }\n+         { dg-final { scan-sarif-file \"\\\"fullName\\\": \\\"GNU C\" } }\n+         { dg-final { scan-sarif-file \"\\\"informationUri\\\": \\\"\" } }\n+     { dg-final { scan-sarif-file \"\\\"results\\\": \\\\\\[\" } }\n+       { dg-final { scan-sarif-file \"\\\"level\\\": \\\"warning\\\"\" } }\n+       { dg-final { scan-sarif-file \"\\\"ruleId\\\": \\\"-Wcpp\\\"\" } }\n+       { dg-final { scan-sarif-file \"\\\"locations\\\": \\\\\\[\" } }\n+         { dg-final { scan-sarif-file \"\\\"physicalLocation\\\": \" } }\n+           { dg-final { scan-sarif-file \"\\\"contextRegion\\\": \" } }\n+           { dg-final { scan-sarif-file \"\\\"artifactLocation\\\": \" } }\n+           { dg-final { scan-sarif-file \"\\\"region\\\": \" } }\n+             { dg-final { scan-sarif-file \"\\\"startLine\\\": 4\" } }\n+             { dg-final { scan-sarif-file \"\\\"startColumn\\\": 2\" } }\n+             { dg-final { scan-sarif-file \"\\\"endColumn\\\": 9\" } }\n+\n+         We don't expect logical locations for a top-level warning:\n+         { dg-final { scan-sarif-file-not \"\\\"logicalLocations\\\": \" } }\n+\n+       { dg-final { scan-sarif-file \"\\\"message\\\": \" } }\n+         { dg-final { scan-sarif-file \"\\\"text\\\": \\\"#warning message\" } } */"}, {"sha": "8f5814d894eb01b067edcb533babeb1a40425152", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-sarif-file-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-2.c?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-format=sarif-file -Wmisleading-indentation\" } */\n+\n+int test (void)\n+{\n+  if (1)\n+    return 3;\n+    return 4;\n+  return 5;\n+}\n+\n+/* \n+       { dg-final { scan-sarif-file \"\\\"level\\\": \\\"warning\\\"\" } }\n+       { dg-final { scan-sarif-file \"\\\"ruleId\\\": \\\"-Wmisleading-indentation\\\"\" } }\n+         { dg-final { scan-sarif-file \"\\\"text\\\": \\\"  if \" } }\n+\n+       { dg-final { scan-sarif-file \"\\\"locations\\\": \\\\\\[\" } }\n+\n+       We expect a logical location for the error (within fn \"test\"):\n+         { dg-final { scan-sarif-file \"\\\"logicalLocations\\\": \\\\\\[\" } }\n+           { dg-final { scan-sarif-file \"\\\"kind\\\": \\\"function\\\"\" } }\n+           { dg-final { scan-sarif-file \"\\\"name\\\": \\\"test\\\"\" } }\n+           { dg-final { scan-sarif-file \"\\\"fullyQualifiedName\\\": \\\"test\\\"\" } }\n+           { dg-final { scan-sarif-file \"\\\"decoratedName\\\": \\\"\" } }\n+\n+       We expect the \"note\" to become a \"relatedLocations\" entry:\n+       { dg-final { scan-sarif-file \"\\\"relatedLocations\\\": \\\\\\[\" } }\n+         { dg-final { scan-sarif-file \"\\\"text\\\": \\\"    return 4;\" } }\n+*/"}, {"sha": "3856782b5ea9a7218028d2bcb4eb2191b487ea94", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-sarif-file-3.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-3.c?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-format=sarif-file\" } */\n+/* { dg-excess-errors \"The error is sent to the SARIF file, rather than stderr\" } */\n+\n+struct s { int color; };\n+\n+int test (struct s *ptr)\n+{\n+  return ptr->colour;\n+}\n+\n+/* \n+       { dg-final { scan-sarif-file \"\\\"level\\\": \\\"error\\\"\" } }\n+\n+       We expect a logical location for the error (within fn \"test\"):\n+       { dg-final { scan-sarif-file \"\\\"locations\\\": \\\\\\[\" } }\n+         { dg-final { scan-sarif-file \"\\\"logicalLocations\\\": \\\\\\[\" } }\n+           { dg-final { scan-sarif-file \"\\\"kind\\\": \\\"function\\\"\" } }\n+           { dg-final { scan-sarif-file \"\\\"name\\\": \\\"test\\\"\" } }\n+           { dg-final { scan-sarif-file \"\\\"fullyQualifiedName\\\": \\\"test\\\"\" } }\n+           { dg-final { scan-sarif-file \"\\\"decoratedName\\\": \\\"\" } }\n+\n+       We expect a \"fixes\" array for the fix-it hint (SARIF v2.1.0 section 3.27.30):\n+       { dg-final { scan-sarif-file \"\\\"fixes\\\": \\\\\\[\" } }\n+         { dg-final { scan-sarif-file \"\\\"artifactChanges\\\": \\\\\\[\" } }\n+           { dg-final { scan-sarif-file \"\\\"replacements\\\": \\\\\\[\" } }\n+             { dg-final { scan-sarif-file \"\\\"insertedContent\\\": \" } }\n+               { dg-final { scan-sarif-file \"\\\"text\\\": \\\"color\\\"\" } }\n+             { dg-final { scan-sarif-file \"\\\"deletedRegion\\\": \" } }\n+*/"}, {"sha": "2d22f54037ca7ff76072728fd31641f33fd45b42", "filename": "gcc/testsuite/c-c++-common/diagnostic-format-sarif-file-4.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fdiagnostic-format-sarif-file-4.c?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-format=sarif-file\" } */\n+/* { dg-excess-errors \"The error is sent to the SARIF file, rather than stderr\" } */\n+\n+int test (void)\n+{\n+  int \u6587\u5b57\u5316\u3051 = *42;\n+}\n+\n+/* \n+       { dg-final { scan-sarif-file \"\\\"level\\\": \\\"error\\\"\" } }\n+\n+       We expect the region expressed in display columns:\n+       { dg-final { scan-sarif-file \"\\\"startLine\\\": 7\" } }\n+       { dg-final { scan-sarif-file \"\\\"startColumn\\\": 18\" } }\n+       { dg-final { scan-sarif-file \"\\\"endColumn\\\": 21\" } }\n+\n+       { dg-final { scan-sarif-file \"\\\"text\\\": \\\"  int \\\\u6587\\\\u5b57\\\\u5316\\\\u3051 = \" } }\n+*/"}, {"sha": "66b72a72daff0a33961c7c517cc9824ae8b4fd3f", "filename": "gcc/testsuite/gcc.dg/analyzer/file-meaning-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-meaning-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-meaning-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffile-meaning-1.c?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-additional-options \"-fanalyzer-verbose-state-changes\" } */\n+\n+typedef struct FILE   FILE;\n+FILE* fopen (const char*, const char*);\n+int   fclose (FILE*);\n+\n+void test_1 (const char *path)\n+{\n+  FILE *f = fopen (path, \"r\"); /* { dg-message \"meaning: \\\\{verb: 'acquire', noun: 'resource'\\\\}\" } */\n+  if (!f)\n+    return;\n+\n+  fclose (f); /* { dg-message \"meaning: \\\\{verb: 'release', noun: 'resource'\\\\}\" } */\n+  fclose (f); /* { dg-warning \"double 'fclose' of FILE 'f'\" \"warning\" } */ \n+}"}, {"sha": "4964e25fe1086f6ab4cc486a957d3ceab99081ba", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-meaning-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-meaning-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-meaning-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-meaning-1.c?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-additional-options \"-fanalyzer-verbose-state-changes\" } */\n+\n+#include <stdlib.h>\n+\n+void test_1 (void)\n+{\n+  void *ptr = malloc (1024); /* { dg-message \"meaning: \\\\{verb: 'acquire', noun: 'memory'\\\\}\" } */\n+  free (ptr); /* { dg-message \"meaning: \\\\{verb: 'release', noun: 'memory'\\\\}\" } */\n+  free (ptr); /* { dg-warning \"double-'free' of 'ptr'\" } */\n+}"}, {"sha": "3d141b53f4757c6d6456f638453db719b02b574c", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-sarif-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-sarif-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-sarif-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-sarif-1.c?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdiagnostics-format=sarif-file\" } */\n+\n+#include <stdlib.h>\n+\n+void test_1 (void)\n+{\n+  void *ptr = malloc (1024);\n+  free (ptr);\n+  free (ptr);\n+}\n+\n+/* Verify SARIF output.\n+\n+   The threadFlowLocation objects should have \"kinds\" properties\n+   reflecting the meanings of the events:\n+     { dg-final { scan-sarif-file \"\\\"kinds\\\": \\\\\\[\\\"acquire\\\", \\\"memory\\\"\\\\\\]\" } }\n+     { dg-final { scan-sarif-file \"\\\"kinds\\\": \\\\\\[\\\"release\\\", \\\"memory\\\"\\\\\\]\" } }\n+     { dg-final { scan-sarif-file \"\\\"kinds\\\": \\\\\\[\\\"danger\\\"\\\\\\]\" } }\n+*/"}, {"sha": "2a8bf11b3e9291223845f165a14e5bb927c14468", "filename": "gcc/testsuite/gcc.dg/plugin/analyzer_gil_plugin.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -109,6 +109,21 @@ class gil_diagnostic : public pending_diagnostic\n     return label_text ();\n   }\n \n+  diagnostic_event::meaning\n+  get_meaning_for_state_change (const evdesc::state_change &change)\n+    const final override\n+  {\n+    if (change.is_global_p ())\n+      {\n+\tif (change.m_new_state == m_sm.m_released_gil)\n+\t  return diagnostic_event::meaning (diagnostic_event::VERB_release,\n+\t\t\t\t\t    diagnostic_event::NOUN_lock);\n+\telse if (change.m_new_state == m_sm.get_start_state ())\n+\t  return diagnostic_event::meaning (diagnostic_event::VERB_acquire,\n+\t\t\t\t\t    diagnostic_event::NOUN_lock);\n+      }\n+    return diagnostic_event::meaning ();\n+  }\n  protected:\n   gil_diagnostic (const gil_state_machine &sm) : m_sm (sm)\n   {"}, {"sha": "bd09391a8b28159a3b65f7c76e0ebe3c466647e6", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-paths-5.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-5.c?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-format=sarif-file\" } */\n+/* { dg-excess-errors \"The error is sent to the SARIF file, rather than stderr\" } */\n+\n+#include <stddef.h>\n+#include <stdlib.h>\n+\n+/* Minimal reimplementation of cpython API.  */\n+typedef struct PyObject {} PyObject;\n+extern int PyArg_ParseTuple (PyObject *args, const char *fmt, ...);\n+extern PyObject *PyList_New (int);\n+extern PyObject *PyLong_FromLong(long);\n+extern void PyList_Append(PyObject *list, PyObject *item);\n+\n+PyObject *\n+make_a_list_of_random_ints_badly(PyObject *self,\n+\t\t\t\t PyObject *args)\n+{\n+  PyObject *list, *item;\n+  long count, i;\n+\n+  if (!PyArg_ParseTuple(args, \"i\", &count)) {\n+    return NULL;\n+  }\n+\n+  list = PyList_New(0);\n+\t\n+  for (i = 0; i < count; i++) {\n+    item = PyLong_FromLong(random());\n+    PyList_Append(list, item);\n+  }\n+  \n+  return list;\n+}\n+\n+/* \n+   { dg-final { scan-sarif-file \"\\\"tool\\\": \" } }\n+\n+     We expect info about the plugin:\n+     { dg-final { scan-sarif-file \"\\\"extensions\\\": \\\\\\[\" } }\n+       { dg-final { scan-sarif-file \"\\\"name\\\": \\\"diagnostic_plugin_test_paths\\\"\" } }\n+       { dg-final { scan-sarif-file \"\\\"fullName\\\": \\\"\" } }\n+\n+     { dg-final { scan-sarif-file \"\\\"results\\\": \\\\\\[\" } }\n+       { dg-final { scan-sarif-file \"\\\"level\\\": \\\"error\\\"\" } }\n+         { dg-final { scan-sarif-file \"\\\"text\\\": \\\"passing NULL as argument 1 to 'PyList_Append' which requires a non-NULL parameter\\\"\" } }\n+\n+       We expect a path for the diagnostic:\n+       { dg-final { scan-sarif-file \"\\\"codeFlows\\\": \\\\\\[\" } }\n+         { dg-final { scan-sarif-file \"\\\"threadFlows\\\": \\\\\\[\" } }\n+           { dg-final { scan-sarif-file \"\\\"locations\\\": \\\\\\[\" } }\n+             { dg-final { scan-sarif-file \"\\\"text\\\": \\\"when 'PyList_New' fails, returning NULL\\\"\" } }\n+             { dg-final { scan-sarif-file \"\\\"text\\\": \\\"when 'i < count'\\\"\" } }\n+             { dg-final { scan-sarif-file \"\\\"text\\\": \\\"when calling 'PyList_Append', passing NULL from \\\\(1\\\\) as argument 1\\\"\" } }\n+\n+*/"}, {"sha": "63b117d3cde0e3b6c1e6552390079ced1d91c707", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -102,6 +102,7 @@ set plugin_test_list [list \\\n \t  diagnostic-test-paths-2.c \\\n \t  diagnostic-test-paths-3.c \\\n \t  diagnostic-test-paths-4.c \\\n+\t  diagnostic-test-paths-5.c \\\n \t  diagnostic-path-format-plain.c \\\n \t  diagnostic-path-format-none.c \\\n \t  diagnostic-path-format-separate-events.c \\"}, {"sha": "f58b9e6e873d29dc948d7b168f86653e738cbd0d", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -25,6 +25,7 @@ load_lib scanltranstree.exp\n load_lib scanipa.exp\n load_lib scanwpaipa.exp\n load_lib scanlang.exp\n+load_lib scansarif.exp\n load_lib timeout.exp\n load_lib timeout-dg.exp\n load_lib prune.exp"}, {"sha": "8b7e89cc817fce7137cd41d0d8c731ba883bca2e", "filename": "gcc/testsuite/lib/scansarif.exp", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Flib%2Fscansarif.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftestsuite%2Flib%2Fscansarif.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fscansarif.exp?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -0,0 +1,42 @@\n+# Copyright (C) 2000-2022 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Various utilities for scanning SARIF output, used by gcc-dg.exp and\n+# g++-dg.exp.\n+#\n+# This is largely borrowed from scanasm.exp.\n+\n+# Look for a pattern in the .sarif file produced by the compiler.  See\n+# dg-scan for details.\n+\n+proc scan-sarif-file { args } {\n+    set testcase [testname-for-summary]\n+    # The name might include a list of options; extract the file name.\n+    set filename [lindex $testcase 0]\n+    set output_file \"[file tail $filename].sarif\"\n+    dg-scan \"scan-sarif-file\" 1 $testcase $output_file $args\n+}\n+\n+# Check that a pattern is not present in the .sarif file.  See dg-scan\n+# for details.\n+\n+proc scan-sarif-file-not { args } {\n+    set testcase [testname-for-summary]\n+    # The name might include a list of options; extract the file name.\n+    set filename [lindex $testcase 0]\n+    set output_file \"[file tail $filename].sarif\"\n+    dg-scan \"scan-sarif-file-not\" 0 $testcase $output_file $args\n+}"}, {"sha": "f8ff271d2f59b37eba4a0e4bcbb59f9e8923512a", "filename": "gcc/tree-diagnostic-client-data-hooks.cc", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftree-diagnostic-client-data-hooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftree-diagnostic-client-data-hooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic-client-data-hooks.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -0,0 +1,150 @@\n+/* Implementation of diagnostic_client_data_hooks for the compilers\n+   (e.g. with knowledge of \"tree\" and lang_hooks).\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"version.h\"\n+#include \"tree.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-logical-location.h\"\n+#include \"diagnostic-client-data-hooks.h\"\n+#include \"langhooks.h\"\n+#include \"plugin.h\"\n+\n+/* Concrete class for supplying a diagnostic_context with information\n+   about a specific plugin within the client, when the client is the\n+   compiler (i.e. a GCC plugin).  */\n+\n+class compiler_diagnostic_client_plugin_info\n+  : public diagnostic_client_plugin_info\n+{\n+public:\n+  compiler_diagnostic_client_plugin_info (const plugin_name_args *args)\n+  : m_args (args)\n+  {\n+  }\n+\n+  const char *get_short_name () const final override\n+  {\n+    return m_args->base_name;\n+  }\n+\n+  const char *get_full_name () const final override\n+  {\n+    return m_args->full_name;\n+  }\n+\n+  const char *get_version () const final override\n+  {\n+    return m_args->version;\n+  }\n+\n+private:\n+  const plugin_name_args *m_args;\n+};\n+\n+/* Concrete subclass of client_version_info for use by compilers proper,\n+   (i.e. using lang_hooks, and with knowledge of GCC plugins).  */\n+\n+class compiler_version_info : public client_version_info\n+{\n+public:\n+  const char *get_tool_name () const final override\n+  {\n+    return lang_hooks.name;\n+  }\n+\n+  /* Compare with toplev.cc: print_version.\n+     TARGET_NAME is passed in by the Makefile.  */\n+  char *\n+  maybe_make_full_name () const final override\n+  {\n+    return xasprintf (\"%s %sversion %s (%s)\",\n+\t\t      get_tool_name (), pkgversion_string, version_string,\n+\t\t      TARGET_NAME);\n+  }\n+\n+  const char *get_version_string () const final override\n+  {\n+    return version_string;\n+  }\n+\n+  char *maybe_make_version_url () const final override\n+  {\n+    return xasprintf (\"https://gcc.gnu.org/gcc-%i/\", GCC_major_version);\n+  }\n+\n+  void for_each_plugin (plugin_visitor &visitor) const final override\n+  {\n+    ::for_each_plugin (on_plugin_cb, &visitor);\n+  }\n+\n+private:\n+  static void\n+  on_plugin_cb (const plugin_name_args *args,\n+\t\tvoid *user_data)\n+  {\n+    compiler_diagnostic_client_plugin_info cpi (args);\n+    client_version_info::plugin_visitor *visitor\n+      = (client_version_info::plugin_visitor *)user_data;\n+    visitor->on_plugin (cpi);\n+  }\n+};\n+\n+/* Subclass of diagnostic_client_data_hooks for use by compilers proper\n+   i.e. with knowledge of \"tree\", access to langhooks, etc.  */\n+\n+class compiler_data_hooks : public diagnostic_client_data_hooks\n+{\n+public:\n+  const client_version_info *get_any_version_info () const final override\n+  {\n+    return &m_version_info;\n+  }\n+\n+  const logical_location *get_current_logical_location () const final override\n+  {\n+    if (current_function_decl)\n+      return &m_current_fndecl_logical_loc;\n+    else\n+      return NULL;\n+  }\n+\n+  const char *\n+  maybe_get_sarif_source_language (const char *filename) const final override\n+  {\n+    return lang_hooks.get_sarif_source_language (filename);\n+  }\n+\n+private:\n+  compiler_version_info m_version_info;\n+  current_fndecl_logical_location m_current_fndecl_logical_loc;\n+};\n+\n+/* Create a compiler_data_hooks (so that the class can be local\n+   to this file).  */\n+\n+diagnostic_client_data_hooks *\n+make_compiler_data_hooks ()\n+{\n+  return new compiler_data_hooks ();\n+}"}, {"sha": "0d79fe3c3c15dc536a4bc9221d98ff6637d08b96", "filename": "gcc/tree-diagnostic.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftree-diagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftree-diagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n #include \"gimple-pretty-print.h\"\n #include \"tree-diagnostic.h\"\n+#include \"diagnostic-client-data-hooks.h\"\n #include \"langhooks.h\"\n #include \"intl.h\"\n \n@@ -373,4 +374,5 @@ tree_diagnostics_defaults (diagnostic_context *context)\n   context->print_path = default_tree_diagnostic_path_printer;\n   context->make_json_for_path = default_tree_make_json_for_path;\n   context->set_locations_cb = set_inlining_locations;\n+  context->m_client_data_hooks = make_compiler_data_hooks ();\n }"}, {"sha": "79d8add7d837e83f773ea7155286d5016f8b8de2", "filename": "gcc/tree-logical-location.cc", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftree-logical-location.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftree-logical-location.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-logical-location.cc?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -0,0 +1,148 @@\n+/* Subclasses of logical_location with knowledge of \"tree\".\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"pretty-print.h\"\n+#include \"tree-logical-location.h\"\n+#include \"langhooks.h\"\n+\n+/* class compiler_logical_location : public logical_location.  */\n+\n+/* Get a string for DECL suitable for use by the SARIF logicalLocation\n+   \"name\" property (SARIF v2.1.0 section 3.33.4).  */\n+\n+const char *\n+compiler_logical_location::get_short_name_for_tree (tree decl)\n+{\n+  gcc_assert (decl);\n+  return identifier_to_locale (lang_hooks.decl_printable_name (decl, 0));\n+}\n+\n+/* Get a string for DECL suitable for use by the SARIF logicalLocation\n+   \"fullyQualifiedName\" property (SARIF v2.1.0 section 3.33.5).  */\n+\n+const char *\n+compiler_logical_location::get_name_with_scope_for_tree (tree decl)\n+{\n+  gcc_assert (decl);\n+  return identifier_to_locale (lang_hooks.decl_printable_name (decl, 1));\n+}\n+\n+/* Get a string for DECL suitable for use by the SARIF logicalLocation\n+   \"decoratedName\" property (SARIF v2.1.0 section 3.33.6).  */\n+\n+const char *\n+compiler_logical_location::get_internal_name_for_tree (tree decl)\n+{\n+  gcc_assert (decl);\n+  if (HAS_DECL_ASSEMBLER_NAME_P (decl))\n+    if (tree id = DECL_ASSEMBLER_NAME (decl))\n+      return IDENTIFIER_POINTER (id);\n+  return NULL;\n+}\n+\n+/* Get what kind of SARIF logicalLocation DECL is (if any).  */\n+\n+enum logical_location_kind\n+compiler_logical_location::get_kind_for_tree (tree decl)\n+{\n+  if (!decl)\n+    return LOGICAL_LOCATION_KIND_UNKNOWN;\n+\n+  switch (TREE_CODE (decl))\n+    {\n+    default:\n+      return LOGICAL_LOCATION_KIND_UNKNOWN;\n+    case FUNCTION_DECL:\n+      return LOGICAL_LOCATION_KIND_FUNCTION;\n+    case PARM_DECL:\n+      return LOGICAL_LOCATION_KIND_PARAMETER;\n+    case VAR_DECL:\n+      return LOGICAL_LOCATION_KIND_VARIABLE;\n+    }\n+}\n+\n+/* class tree_logical_location : public compiler_logical_location.  */\n+\n+/* Implementation of the logical_location vfuncs, using m_decl.  */\n+\n+const char *\n+tree_logical_location::get_short_name () const\n+{\n+  gcc_assert (m_decl);\n+  return get_short_name_for_tree (m_decl);\n+}\n+\n+const char *\n+tree_logical_location::get_name_with_scope () const\n+{\n+  gcc_assert (m_decl);\n+  return get_name_with_scope_for_tree (m_decl);\n+}\n+\n+const char *\n+tree_logical_location::get_internal_name () const\n+{\n+  gcc_assert (m_decl);\n+  return get_internal_name_for_tree (m_decl);\n+}\n+\n+enum logical_location_kind\n+tree_logical_location::get_kind () const\n+{\n+  gcc_assert (m_decl);\n+  return get_kind_for_tree (m_decl);\n+}\n+\n+/* class current_fndecl_logical_location : public compiler_logical_location.  */\n+\n+/* Implementation of the logical_location vfuncs, using\n+   current_function_decl.  */\n+\n+const char *\n+current_fndecl_logical_location::get_short_name () const\n+{\n+  gcc_assert (current_function_decl);\n+  return get_short_name_for_tree (current_function_decl);\n+}\n+\n+const char *\n+current_fndecl_logical_location::get_name_with_scope () const\n+{\n+  gcc_assert (current_function_decl);\n+  return get_name_with_scope_for_tree (current_function_decl);\n+}\n+\n+const char *\n+current_fndecl_logical_location::get_internal_name () const\n+{\n+  gcc_assert (current_function_decl);\n+  return get_internal_name_for_tree (current_function_decl);\n+}\n+\n+enum logical_location_kind\n+current_fndecl_logical_location::get_kind () const\n+{\n+  gcc_assert (current_function_decl);\n+  return get_kind_for_tree (current_function_decl);\n+}"}, {"sha": "3086cac98726e49fc4284ae17d48aa553aeff053", "filename": "gcc/tree-logical-location.h", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftree-logical-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/gcc%2Ftree-logical-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-logical-location.h?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -0,0 +1,67 @@\n+/* Subclasses of logical_location with knowledge of \"tree\".\n+   Copyright (C) 2022 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TREE_LOGICAL_LOCATION_H\n+#define GCC_TREE_LOGICAL_LOCATION_H\n+\n+#include \"logical-location.h\"\n+\n+/* Abstract subclass of logical_location, with knowledge of \"tree\", but\n+   for no specific tree.  */\n+\n+class compiler_logical_location : public logical_location\n+{\n+ protected:\n+  static const char *get_short_name_for_tree (tree);\n+  static const char *get_name_with_scope_for_tree (tree);\n+  static const char *get_internal_name_for_tree (tree);\n+  static enum logical_location_kind get_kind_for_tree (tree);\n+};\n+\n+/* Concrete subclass of logical_location, with reference to a specific\n+   tree.  */\n+\n+class tree_logical_location : public compiler_logical_location\n+{\n+public:\n+  tree_logical_location (tree decl) : m_decl (decl) {}\n+\n+  const char *get_short_name () const final override;\n+  const char *get_name_with_scope () const final override;\n+  const char *get_internal_name () const final override;\n+  enum logical_location_kind get_kind () const final override;\n+\n+private:\n+  tree m_decl;\n+};\n+\n+/* Concrete subclass of logical_location, with reference to\n+   current_function_decl.  */\n+\n+class current_fndecl_logical_location : public compiler_logical_location\n+{\n+public:\n+  const char *get_short_name () const final override;\n+  const char *get_name_with_scope () const final override;\n+  const char *get_internal_name () const final override;\n+  enum logical_location_kind get_kind () const final override;\n+};\n+\n+#endif /* GCC_TREE_LOGICAL_LOCATION_H.  */"}, {"sha": "10f38475bc89ca01009280c8a9ada100f7746138", "filename": "libatomic/testsuite/lib/libatomic.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/libatomic%2Ftestsuite%2Flib%2Flibatomic.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/libatomic%2Ftestsuite%2Flib%2Flibatomic.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flib%2Flibatomic.exp?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -36,6 +36,7 @@ load_gcc_lib scanasm.exp\n load_gcc_lib scandump.exp\n load_gcc_lib scanlang.exp\n load_gcc_lib scanrtl.exp\n+load_gcc_lib scansarif.exp\n load_gcc_lib scantree.exp\n load_gcc_lib scanltranstree.exp\n load_gcc_lib scanipa.exp"}, {"sha": "4602d031041bd83531a5d262804c0fe89d26034f", "filename": "libgomp/testsuite/lib/libgomp.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flib%2Flibgomp.exp?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -28,6 +28,7 @@ load_gcc_lib scanasm.exp\n load_gcc_lib scandump.exp\n load_gcc_lib scanlang.exp\n load_gcc_lib scanrtl.exp\n+load_gcc_lib scansarif.exp\n load_gcc_lib scantree.exp\n load_gcc_lib scanltranstree.exp\n load_gcc_lib scanoffload.exp"}, {"sha": "da918d1ee8d1a4e12f34887c111131934e548a6d", "filename": "libitm/testsuite/lib/libitm.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/libitm%2Ftestsuite%2Flib%2Flibitm.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/libitm%2Ftestsuite%2Flib%2Flibitm.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flib%2Flibitm.exp?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -42,6 +42,7 @@ load_gcc_lib scanasm.exp\n load_gcc_lib scandump.exp\n load_gcc_lib scanlang.exp\n load_gcc_lib scanrtl.exp\n+load_gcc_lib scansarif.exp\n load_gcc_lib scantree.exp\n load_gcc_lib scanltranstree.exp\n load_gcc_lib scanipa.exp"}, {"sha": "37b545623f3e4fe5d5b2c25740da7242eaf9e663", "filename": "libphobos/testsuite/lib/libphobos-dg.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cf276ddf22066af780335cd0072d2c27aabe468/libphobos%2Ftestsuite%2Flib%2Flibphobos-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cf276ddf22066af780335cd0072d2c27aabe468/libphobos%2Ftestsuite%2Flib%2Flibphobos-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flib%2Flibphobos-dg.exp?ref=6cf276ddf22066af780335cd0072d2c27aabe468", "patch": "@@ -23,6 +23,7 @@ load_gcc_lib file-format.exp\n load_gcc_lib scanasm.exp\n load_gcc_lib scanlang.exp\n load_gcc_lib scanrtl.exp\n+load_gcc_lib scansarif.exp\n load_gcc_lib scantree.exp\n load_gcc_lib scanipa.exp\n load_gcc_lib torture-options.exp"}]}