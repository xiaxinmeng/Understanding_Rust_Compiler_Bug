{"sha": "aa8cfe785953a0e87d2472311e1260cd98c605c0", "node_id": "C_kwDOANBUbNoAKGFhOGNmZTc4NTk1M2EwZTg3ZDI0NzIzMTFlMTI2MGNkOThjNjA1YzA", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-01-19T16:36:36Z"}, "committer": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-01-19T17:37:46Z"}, "message": "ifcvt: Try re-using CC for conditional moves.\n\nFollowing up on the previous patch, this patch makes\nnoce_convert_multiple emit two cmov sequences:  The same one as before\nand a second one that tries to re-use the existing CC.  Then their costs\nare compared and the cheaper one is selected.\n\ngcc/ChangeLog:\n\n\t* ifcvt.cc (cond_exec_get_condition): New parameter to allow getting the\n\treversed comparison.\n\t(try_emit_cmove_seq): New function to facilitate creating a cmov\n\tsequence.\n\t(noce_convert_multiple_sets): Create two sequences and use the less\n\texpensive one.", "tree": {"sha": "ba5b2184bed0346bce310990806697d55d8eb380", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba5b2184bed0346bce310990806697d55d8eb380"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa8cfe785953a0e87d2472311e1260cd98c605c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa8cfe785953a0e87d2472311e1260cd98c605c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa8cfe785953a0e87d2472311e1260cd98c605c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa8cfe785953a0e87d2472311e1260cd98c605c0/comments", "author": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9ebb86799fd77cdd5351078230c114a90e66066", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9ebb86799fd77cdd5351078230c114a90e66066", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9ebb86799fd77cdd5351078230c114a90e66066"}], "stats": {"total": 117, "additions": 93, "deletions": 24}, "files": [{"sha": "3469806c6f3faa9ef340b045137d99f4a175e3d9", "filename": "gcc/ifcvt.cc", "status": "modified", "additions": 93, "deletions": 24, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8cfe785953a0e87d2472311e1260cd98c605c0/gcc%2Fifcvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8cfe785953a0e87d2472311e1260cd98c605c0/gcc%2Fifcvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.cc?ref=aa8cfe785953a0e87d2472311e1260cd98c605c0", "patch": "@@ -83,7 +83,7 @@ static rtx_insn *last_active_insn (basic_block, int);\n static rtx_insn *find_active_insn_before (basic_block, rtx_insn *);\n static rtx_insn *find_active_insn_after (basic_block, rtx_insn *);\n static basic_block block_fallthru (basic_block);\n-static rtx cond_exec_get_condition (rtx_insn *);\n+static rtx cond_exec_get_condition (rtx_insn *, bool);\n static rtx noce_get_condition (rtx_insn *, rtx_insn **, bool);\n static int noce_operand_ok (const_rtx);\n static void merge_if_block (ce_if_block *);\n@@ -427,7 +427,7 @@ cond_exec_process_insns (ce_if_block *ce_info ATTRIBUTE_UNUSED,\n /* Return the condition for a jump.  Do not do any special processing.  */\n \n static rtx\n-cond_exec_get_condition (rtx_insn *jump)\n+cond_exec_get_condition (rtx_insn *jump, bool get_reversed = false)\n {\n   rtx test_if, cond;\n \n@@ -439,8 +439,10 @@ cond_exec_get_condition (rtx_insn *jump)\n \n   /* If this branches to JUMP_LABEL when the condition is false,\n      reverse the condition.  */\n-  if (GET_CODE (XEXP (test_if, 2)) == LABEL_REF\n-      && label_ref_label (XEXP (test_if, 2)) == JUMP_LABEL (jump))\n+  if (get_reversed\n+      || (GET_CODE (XEXP (test_if, 2)) == LABEL_REF\n+\t  && label_ref_label (XEXP (test_if, 2))\n+\t  == JUMP_LABEL (jump)))\n     {\n       enum rtx_code rev = reversed_comparison_code (cond, jump);\n       if (rev == UNKNOWN)\n@@ -3152,6 +3154,50 @@ bb_valid_for_noce_process_p (basic_block test_bb, rtx cond,\n   return false;\n }\n \n+/* Helper function to emit a cmov sequence encapsulated in\n+   start_sequence () and end_sequence ().  If NEED_CMOV is true\n+   we call noce_emit_cmove to create a cmove sequence.  Otherwise emit\n+   a simple move.  If successful, store the first instruction of the\n+   sequence in TEMP_DEST and the sequence costs in SEQ_COST.  */\n+\n+static rtx_insn*\n+try_emit_cmove_seq (struct noce_if_info *if_info, rtx temp,\n+\t\t    rtx cond, rtx new_val, rtx old_val, bool need_cmov,\n+\t\t    unsigned *cost, rtx *temp_dest,\n+\t\t    rtx cc_cmp = NULL, rtx rev_cc_cmp = NULL)\n+{\n+  rtx_insn *seq = NULL;\n+  *cost = 0;\n+\n+  rtx x = XEXP (cond, 0);\n+  rtx y = XEXP (cond, 1);\n+  rtx_code cond_code = GET_CODE (cond);\n+\n+  start_sequence ();\n+\n+  if (need_cmov)\n+    *temp_dest = noce_emit_cmove (if_info, temp, cond_code,\n+\t\t\t\t  x, y, new_val, old_val, cc_cmp, rev_cc_cmp);\n+  else\n+    {\n+      *temp_dest = temp;\n+      if (if_info->then_else_reversed)\n+\tnoce_emit_move_insn (temp, old_val);\n+      else\n+\tnoce_emit_move_insn (temp, new_val);\n+    }\n+\n+  if (*temp_dest != NULL_RTX)\n+    {\n+      seq = get_insns ();\n+      *cost = seq_cost (seq, if_info->speed_p);\n+    }\n+\n+  end_sequence ();\n+\n+  return seq;\n+}\n+\n /* We have something like:\n \n      if (x > y)\n@@ -3209,7 +3255,9 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n   rtx cond = noce_get_condition (jump, &cond_earliest, false);\n   rtx x = XEXP (cond, 0);\n   rtx y = XEXP (cond, 1);\n-  rtx_code cond_code = GET_CODE (cond);\n+\n+  rtx cc_cmp = cond_exec_get_condition (jump);\n+  rtx rev_cc_cmp = cond_exec_get_condition (jump, /* get_reversed */ true);\n \n   /* The true targets for a conditional move.  */\n   auto_vec<rtx> targets;\n@@ -3323,31 +3371,51 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n \t  old_val = lowpart_subreg (dst_mode, old_val, src_mode);\n \t}\n \n-      rtx temp_dest = NULL_RTX;\n+      /* Try emitting a conditional move passing the backend the\n+\t canonicalized comparison.  The backend is then able to\n+\t recognize expressions like\n \n-      if (need_cmov)\n+\t   if (x > y)\n+\t     y = x;\n+\n+\t as min/max and emit an insn, accordingly.  */\n+      unsigned cost1 = 0, cost2 = 0;\n+      rtx_insn *seq, *seq1, *seq2;\n+      rtx temp_dest = NULL_RTX, temp_dest1 = NULL_RTX, temp_dest2 = NULL_RTX;\n+\n+      seq1 = try_emit_cmove_seq (if_info, temp, cond,\n+\t\t\t\t new_val, old_val, need_cmov,\n+\t\t\t\t &cost1, &temp_dest1);\n+\n+      /* Here, we try to pass the backend a non-canonicalized cc comparison\n+\t as well.  This allows the backend to emit a cmov directly without\n+\t creating an additional compare for each.  If successful, costing\n+\t is easier and this sequence is usually preferred.  */\n+      seq2 = try_emit_cmove_seq (if_info, target, cond,\n+\t\t\t\t new_val, old_val, need_cmov,\n+\t\t\t\t &cost2, &temp_dest2, cc_cmp, rev_cc_cmp);\n+\n+      /* Check which version is less expensive.  */\n+      if (seq1 != NULL_RTX && (cost1 <= cost2 || seq2 == NULL_RTX))\n \t{\n-\t  /* Actually emit the conditional move.  */\n-\t  temp_dest = noce_emit_cmove (if_info, temp, cond_code,\n-\t\t\t\t       x, y, new_val, old_val);\n-\n-\t  /* If we failed to expand the conditional move, drop out and don't\n-\t     try to continue.  */\n-\t  if (temp_dest == NULL_RTX)\n-\t    {\n-\t      end_sequence ();\n-\t      return FALSE;\n-\t    }\n+\t  seq = seq1;\n+\t  temp_dest = temp_dest1;\n+\t}\n+      else if (seq2 != NULL_RTX)\n+\t{\n+\t  seq = seq2;\n+\t  temp_dest = temp_dest2;\n \t}\n       else\n \t{\n-\t  if (if_info->then_else_reversed)\n-\t    noce_emit_move_insn (temp, old_val);\n-\t  else\n-\t    noce_emit_move_insn (temp, new_val);\n-\t  temp_dest = temp;\n+\t  /* Nothing worked, bail out.  */\n+\t  end_sequence ();\n+\t  return FALSE;\n \t}\n \n+      /* End the sub sequence and emit to the main sequence.  */\n+      emit_insn (seq);\n+\n       /* Bookkeeping.  */\n       count++;\n       targets.safe_push (target);\n@@ -3361,7 +3429,8 @@ noce_convert_multiple_sets (struct noce_if_info *if_info)\n \n   /* Now fixup the assignments.  */\n   for (int i = 0; i < count; i++)\n-    noce_emit_move_insn (targets[i], temporaries[i]);\n+    if (targets[i] != temporaries[i])\n+      noce_emit_move_insn (targets[i], temporaries[i]);\n \n   /* Actually emit the sequence if it isn't too expensive.  */\n   rtx_insn *seq = get_insns ();"}]}