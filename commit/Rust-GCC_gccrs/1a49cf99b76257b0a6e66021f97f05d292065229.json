{"sha": "1a49cf99b76257b0a6e66021f97f05d292065229", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE0OWNmOTliNzYyNTdiMGE2ZTY2MDIxZjk3ZjA1ZDI5MjA2NTIyOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-15T16:19:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-15T16:19:40Z"}, "message": "[multiple changes]\n\n2005-03-08  Robert Dewar  <dewar@adacore.com>\n\n\t* s-bitops.adb, s-bitops.ads,\n\ts-taprop-os2.adb, s-intman-vms.ads, s-intman-vxworks.ads,\n\ts-taprop-vxworks.adb, a-caldel.ads, a-calend.adb, a-tasatt.adb,\n\ttbuild.ads, s-finimp.adb, s-imgwch.adb, s-intman.ads, s-intman.ads,\n\ts-memory.adb, s-soflin.ads, s-taasde.ads, s-taprob.adb, s-taprop.ads,\n\ts-taprop.ads, s-tasini.adb, s-tasini.ads, s-tasini.ads, s-tasini.ads,\n\ts-taskin.ads, s-tasren.adb, s-tassta.adb, s-tassta.ads, s-tassta.ads,\n\ts-tasuti.ads, s-tataat.ads, s-tataat.ads, s-tataat.ads, s-tataat.ads,\n\ts-tpoben.adb, s-tpoben.adb, s-tpobop.ads: Update comments. Minor\n\treformatting.\n\n2005-03-08  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* utils2.c (build_binary_op): Fix typo.\n\n2005-03-08  Doug Rupp  <rupp@adacore.com>\n\n\t* s-crtl.ads (popen,pclose): New imports.\n\n2005-03-08  Cyrille Comar  <comar@adacore.com>\n\n\t* comperr.adb (Compiler_Abort): remove references to obsolete\n\tprocedures in the bug boxes for various GNAT builds.\n\n2005-03-08  Vincent Celier  <celier@adacore.com>\n\n\t* snames.ads, snames.adb: Save as Unix text file, not as DOS text file\n\nFrom-SVN: r96512", "tree": {"sha": "f3daea4db10883323aa8c12fd8894fd4fa00c5f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3daea4db10883323aa8c12fd8894fd4fa00c5f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a49cf99b76257b0a6e66021f97f05d292065229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a49cf99b76257b0a6e66021f97f05d292065229", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a49cf99b76257b0a6e66021f97f05d292065229", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a49cf99b76257b0a6e66021f97f05d292065229/comments", "author": null, "committer": null, "parents": [{"sha": "728c3084ee3b33f86c66ed6b401f56107d307dd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/728c3084ee3b33f86c66ed6b401f56107d307dd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/728c3084ee3b33f86c66ed6b401f56107d307dd7"}], "stats": {"total": 7318, "additions": 3654, "deletions": 3664}, "files": [{"sha": "f69634b341dff1234307b4d714cf3d1285c61e75", "filename": "gcc/ada/a-caldel.ads", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fa-caldel.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fa-caldel.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-caldel.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-1998, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,18 +39,17 @@\n package Ada.Calendar.Delays is\n \n    procedure Delay_For (D : Duration);\n-   --  Delay until an interval of length (at least) D seconds has passed,\n-   --  or the task is aborted to at least the current ATC nesting level.\n-   --  This is an abort completion point.\n-   --  The body of this procedure must perform all the processing\n-   --  required for an abortion point.\n+   --  Delay until an interval of length (at least) D seconds has passed, or\n+   --  the task is aborted to at least the current ATC nesting level. This is\n+   --  an abort completion point. The body of this procedure must perform all\n+   --  the processing required for an abort point.\n \n    procedure Delay_Until (T : Time);\n-   --  Delay until Clock has reached (at least) time T,\n-   --  or the task is aborted to at least the current ATC nesting level.\n-   --  The body of this procedure must perform all the processing\n-   --  required for an abortion point.\n+   --  Delay until Clock has reached (at least) time T, or the task is aborted\n+   --  to at least the current ATC nesting level. The body of this procedure\n+   --  must perform all the processing required for an abort point.\n \n    function To_Duration (T : Time) return Duration;\n+   --  Convert Time to Duration\n \n end Ada.Calendar.Delays;"}, {"sha": "f5dd5013399e43641a370418126216d936808ede", "filename": "gcc/ada/a-calend.adb", "status": "modified", "additions": 39, "deletions": 47, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fa-calend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fa-calend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.adb?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -91,15 +91,16 @@ package body Ada.Calendar is\n    --  The following constants are used in adjusting Ada dates so that they\n    --  fit into a 56 year range that can be handled by Unix (1970 included -\n    --  2026 excluded). Dates that are not in this 56 year range are shifted\n-   --  by multiples of 56 years to fit in this range\n+   --  by multiples of 56 years to fit in this range.\n+\n    --  The trick is that the number of days in any four year period in the Ada\n    --  range of years (1901 - 2099) has a constant number of days. This is\n    --  because we have the special case of 2000 which, contrary to the normal\n-   --  exception for centuries, is a leap year after all.\n-   --  56 has been chosen, because it is not only a multiple of 4, but also\n-   --  a multiple of 7. Thus two dates 56 years apart fall on the same day of\n-   --  the week, and the Daylight Saving Time change dates are usually the same\n-   --  for these two years.\n+   --  exception for centuries, is a leap year after all. 56 has been chosen,\n+   --  because it is not only a multiple of 4, but also a multiple of 7. Thus\n+   --  two dates 56 years apart fall on the same day of the week, and the\n+   --  Daylight Saving Time change dates are usually the same for these two\n+   --  years.\n \n    Unix_Year_Min : constant := 1970;\n    Unix_Year_Max : constant := 2026;\n@@ -125,7 +126,6 @@ package body Ada.Calendar is\n       pragma Unsuppress (Overflow_Check);\n    begin\n       return (Left + Time (Right));\n-\n    exception\n       when Constraint_Error =>\n          raise Time_Error;\n@@ -135,7 +135,6 @@ package body Ada.Calendar is\n       pragma Unsuppress (Overflow_Check);\n    begin\n       return (Time (Left) + Right);\n-\n    exception\n       when Constraint_Error =>\n          raise Time_Error;\n@@ -149,7 +148,6 @@ package body Ada.Calendar is\n       pragma Unsuppress (Overflow_Check);\n    begin\n       return Left - Time (Right);\n-\n    exception\n       when Constraint_Error =>\n          raise Time_Error;\n@@ -159,7 +157,6 @@ package body Ada.Calendar is\n       pragma Unsuppress (Overflow_Check);\n    begin\n       return Duration (Left) - Duration (Right);\n-\n    exception\n       when Constraint_Error =>\n          raise Time_Error;\n@@ -219,7 +216,6 @@ package body Ada.Calendar is\n       DM : Month_Number;\n       DD : Day_Number;\n       DS : Day_Duration;\n-\n    begin\n       Split (Date, DY, DM, DD, DS);\n       return DD;\n@@ -234,7 +230,6 @@ package body Ada.Calendar is\n       DM : Month_Number;\n       DD : Day_Number;\n       DS : Day_Duration;\n-\n    begin\n       Split (Date, DY, DM, DD, DS);\n       return DM;\n@@ -249,7 +244,6 @@ package body Ada.Calendar is\n       DM : Month_Number;\n       DD : Day_Number;\n       DS : Day_Duration;\n-\n    begin\n       Split (Date, DY, DM, DD, DS);\n       return DS;\n@@ -291,11 +285,11 @@ package body Ada.Calendar is\n \n       D := Duration (Date);\n \n-      --  First of all, filter out completely ludicrous values. Remember\n-      --  that we use the full stored range of duration values, which may\n-      --  be significantly larger than the allowed range of Ada times. Note\n-      --  that these checks are wider than required to make absolutely sure\n-      --  that there are no end effects from time zone differences.\n+      --  First of all, filter out completely ludicrous values. Remember that\n+      --  we use the full stored range of duration values, which may be\n+      --  significantly larger than the allowed range of Ada times. Note that\n+      --  these checks are wider than required to make absolutely sure that\n+      --  there are no end effects from time zone differences.\n \n       if D < LowD or else D > HighD then\n          raise Time_Error;\n@@ -306,11 +300,11 @@ package body Ada.Calendar is\n       --  required range of years (the guaranteed range available is only\n       --  EPOCH through EPOCH + N seconds). N is in practice 2 ** 31 - 1.\n \n-      --  If we have a value outside this range, then we first adjust it\n-      --  to be in the required range by adding multiples of 56 years.\n-      --  For the range we are interested in, the number of days in any\n-      --  consecutive 56 year period is constant. Then we do the split\n-      --  on the adjusted value, and readjust the years value accordingly.\n+      --  If we have a value outside this range, then we first adjust it to be\n+      --  in the required range by adding multiples of 56 years. For the range\n+      --  we are interested in, the number of days in any consecutive 56 year\n+      --  period is constant. Then we do the split on the adjusted value, and\n+      --  readjust the years value accordingly.\n \n       Year_Val := 0;\n \n@@ -325,13 +319,13 @@ package body Ada.Calendar is\n       end loop;\n \n       --  Now we need to take the value D, which is now non-negative, and\n-      --  break it down into seconds (to pass to the localtime_r function)\n-      --  and fractions of seconds (for the adjustment below).\n+      --  break it down into seconds (to pass to the localtime_r function) and\n+      --  fractions of seconds (for the adjustment below).\n \n       --  Surprisingly there is no easy way to do this in Ada, and certainly\n-      --  no easy way to do it and generate efficient code. Therefore we\n-      --  do it at a low level, knowing that it is really represented as\n-      --  an integer with units of Small\n+      --  no easy way to do it and generate efficient code. Therefore we do it\n+      --  at a low level, knowing that it is really represented as an integer\n+      --  with units of Small\n \n       declare\n          type D_Int is range 0 .. 2 ** (Duration'Size - 1) - 1;\n@@ -356,18 +350,18 @@ package body Ada.Calendar is\n       Day      := Tm_Val.tm_mday;\n \n       --  The Seconds value is a little complex. The localtime function\n-      --  returns the integral number of seconds, which is what we want,\n-      --  but we want to retain the fractional part from the original\n-      --  Time value, since this is typically stored more accurately.\n+      --  returns the integral number of seconds, which is what we want, but\n+      --  we want to retain the fractional part from the original Time value,\n+      --  since this is typically stored more accurately.\n \n       Seconds := Duration (Tm_Val.tm_hour * 3600 +\n                            Tm_Val.tm_min  * 60 +\n                            Tm_Val.tm_sec)\n                    + Frac_Sec;\n \n-      --  Note: the above expression is pretty horrible, one of these days\n-      --  we should stop using time_of and do everything ourselves to avoid\n-      --  these unnecessary divides and multiplies???.\n+      --  Note: the above expression is pretty horrible, one of these days we\n+      --  should stop using time_of and do everything ourselves to avoid these\n+      --  unnecessary divides and multiplies???.\n \n       --  The Year may still be out of range, since our entry test was\n       --  deliberately crude. Trying to make this entry test accurate is\n@@ -404,8 +398,8 @@ package body Ada.Calendar is\n    begin\n       --  The following checks are redundant with respect to the constraint\n       --  error checks that should normally be made on parameters, but we\n-      --  decide to raise Constraint_Error in any case if bad values come\n-      --  in (as a result of checks being off in the caller, or for other\n+      --  decide to raise Constraint_Error in any case if bad values come in\n+      --  (as a result of checks being off in the caller, or for other\n       --  erroneous or bounded error cases).\n \n       if        not Year   'Valid\n@@ -433,10 +427,10 @@ package body Ada.Calendar is\n       TM_Val.tm_mon  := Month - 1;\n \n       --  For the year, we have to adjust it to a year that Unix can handle.\n-      --  We do this in 56 year steps, since the number of days in 56 years\n-      --  is constant, so the timezone effect on the conversion from local\n-      --  time to GMT is unaffected; also the DST change dates are usually\n-      --  not modified.\n+      --  We do this in 56 year steps, since the number of days in 56 years is\n+      --  constant, so the timezone effect on the conversion from local time\n+      --  to GMT is unaffected; also the DST change dates are usually not\n+      --  modified.\n \n       while Year_Val < Unix_Year_Min loop\n          Year_Val := Year_Val + 56;\n@@ -450,23 +444,22 @@ package body Ada.Calendar is\n \n       TM_Val.tm_year := Year_Val - 1900;\n \n-      --  Since we do not have information on daylight savings,\n-      --  rely on the default information.\n+      --  Since we do not have information on daylight savings, rely on the\n+      --  default information.\n \n       TM_Val.tm_isdst := -1;\n       Result_Secs := mktime (TM_Val'Unchecked_Access);\n \n       --  That gives us the basic value in seconds. Two adjustments are\n       --  needed. First we must undo the year adjustment carried out above.\n       --  Second we put back the fraction seconds value since in general the\n-      --  Day_Duration value we received has additional precision which we\n-      --  do not want to lose in the constructed result.\n+      --  Day_Duration value we received has additional precision which we do\n+      --  not want to lose in the constructed result.\n \n       return\n         Time (Duration (Result_Secs) +\n               Duration_Adjust +\n               (Seconds - Duration (Int_Secs)));\n-\n    end Time_Of;\n \n    ----------\n@@ -478,7 +471,6 @@ package body Ada.Calendar is\n       DM : Month_Number;\n       DD : Day_Number;\n       DS : Day_Duration;\n-\n    begin\n       Split (Date, DY, DM, DD, DS);\n       return DY;"}, {"sha": "0fc74d5231f2b2d82427214ba5cb256aeb96e1d1", "filename": "gcc/ada/a-tasatt.adb", "status": "modified", "additions": 179, "deletions": 184, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fa-tasatt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fa-tasatt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tasatt.adb?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2004, Ada Core Technologies               --\n+--             Copyright (C) 1995-2005, Ada Core Technologies               --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,174 +32,171 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  The following notes are provided in case someone decides the\n---  implementation of this package is too complicated, or too slow.\n---  Please read this before making any \"simplifications\".\n+--  The following notes are provided in case someone decides the implementation\n+--  of this package is too complicated, or too slow. Please read this before\n+--  making any \"simplifications\".\n \n---  Correct implementation of this package is more difficult than one\n---  might expect. After considering (and coding) several alternatives,\n---  we settled on the present compromise. Things we do not like about\n---  this implementation include:\n+--  Correct implementation of this package is more difficult than one might\n+--  expect. After considering (and coding) several alternatives, we settled on\n+--  the present compromise. Things we do not like about this implementation\n+--  include:\n \n---  -  It is vulnerable to bad Task_Id values, to the extent of\n---     possibly trashing memory and crashing the runtime system.\n+--  - It is vulnerable to bad Task_Id values, to the extent of possibly\n+--     trashing memory and crashing the runtime system.\n \n---  -  It requires dynamic storage allocation for each new attribute value,\n---     except for types that happen to be the same size as System.Address,\n---     or shorter.\n+--  - It requires dynamic storage allocation for each new attribute value,\n+--     except for types that happen to be the same size as System.Address, or\n+--     shorter.\n \n --  -  Instantiations at other than the library level rely on being able to\n --     do down-level calls to a procedure declared in the generic package body.\n --     This makes it potentially vulnerable to compiler changes.\n \n---  The main implementation issue here is that the connection from\n---  task to attribute is a potential source of dangling references.\n+--  The main implementation issue here is that the connection from task to\n+--  attribute is a potential source of dangling references.\n \n --  When a task goes away, we want to be able to recover all the storage\n --  associated with its attributes. The Ada mechanism for this is\n---  finalization, via controlled attribute types. For this reason,\n---  the ARM requires finalization of attribute values when the\n---  associated task terminates.\n+--  finalization, via controlled attribute types. For this reason, the ARM\n+--  requires finalization of attribute values when the associated task\n+--  terminates.\n \n---  This finalization must be triggered by the tasking runtime system,\n---  during termination of the task. Given the active set of instantiations\n---  of Ada.Task_Attributes is dynamic, the number and types of attributes\n+--  This finalization must be triggered by the tasking runtime system, during\n+--  termination of the task. Given the active set of instantiations of\n+--  Ada.Task_Attributes is dynamic, the number and types of attributes\n --  belonging to a task will not be known until the task actually terminates.\n --  Some of these types may be controlled and some may not. The RTS must find\n --  some way to determine which of these attributes need finalization, and\n --  invoke the appropriate finalization on them.\n \n---  One way this might be done is to create a special finalization chain\n---  for each task, similar to the finalization chain that is used for\n---  controlled objects within the task. This would differ from the usual\n---  finalization chain in that it would not have a LIFO structure, since\n---  attributes may be added to a task at any time during its lifetime.\n---  This might be the right way to go for the longer term, but at present\n---  this approach is not open, since GNAT does not provide such special\n---  finalization support.\n+--  One way this might be done is to create a special finalization chain for\n+--  each task, similar to the finalization chain that is used for controlled\n+--  objects within the task. This would differ from the usual finalization\n+--  chain in that it would not have a LIFO structure, since attributes may be\n+--  added to a task at any time during its lifetime. This might be the right\n+--  way to go for the longer term, but at present this approach is not open,\n+--  since GNAT does not provide such special finalization support.\n \n---  Lacking special compiler support, the RTS is limited to the\n---  normal ways an application invokes finalization, i.e.\n+--  Lacking special compiler support, the RTS is limited to the normal ways an\n+--  application invokes finalization, i.e.\n \n---  a) Explicit call to the procedure Finalize, if we know the type\n---     has this operation defined on it. This is not sufficient, since\n---     we have no way of determining whether a given generic formal\n---     Attribute type is controlled, and no visibility of the associated\n---     Finalize procedure, in the generic body.\n+--  a) Explicit call to the procedure Finalize, if we know the type has this\n+--     operation defined on it. This is not sufficient, since we have no way\n+--     of determining whether a given generic formal Attribute type is\n+--     controlled, and no visibility of the associated Finalize procedure, in\n+--     the generic body.\n \n---  b) Leaving the scope of a local object of a controlled type.\n---     This does not help, since the lifetime of an instantiation of\n---     Ada.Task_Attributes does not correspond to the lifetimes of the\n---     various tasks which may have that attribute.\n+--  b) Leaving the scope of a local object of a controlled type. This does not\n+--     help, since the lifetime of an instantiation of Ada.Task_Attributes\n+--     does not correspond to the lifetimes of the various tasks which may\n+--     have that attribute.\n \n---  c) Assignment of another value to the object. This would not help,\n---     since we then have to finalize the new value of the object.\n+--  c) Assignment of another value to the object. This would not help, since\n+--     we then have to finalize the new value of the object.\n \n---  d) Unchecked deallocation of an object of a controlled type.\n---     This seems to be the only mechanism available to the runtime\n---     system for finalization of task attributes.\n+--  d) Unchecked deallocation of an object of a controlled type. This seems to\n+--     be the only mechanism available to the runtime system for finalization\n+--     of task attributes.\n \n---  We considered two ways of using unchecked deallocation, both based\n---  on a linked list of that would hang from the task control block.\n+--  We considered two ways of using unchecked deallocation, both based on a\n+--  linked list of that would hang from the task control block.\n \n --  In the first approach the objects on the attribute list are all derived\n --  from one controlled type, say T, and are linked using an access type to\n---  T'Class. The runtime system has an Unchecked_Deallocation for T'Class\n---  with access type T'Class, and uses this to deallocate and finalize all\n---  the items in the list. The limitation of this approach is that each\n+--  T'Class. The runtime system has an Unchecked_Deallocation for T'Class with\n+--  access type T'Class, and uses this to deallocate and finalize all the\n+--  items in the list. The limitation of this approach is that each\n --  instantiation of the package Ada.Task_Attributes derives a new record\n---  extension of T, and since T is controlled (RM 3.9.1 (3)), instantiation\n---  is only allowed at the library level.\n-\n---  In the second approach the objects on the attribute list are of\n---  unrelated but structurally similar types. Unchecked conversion is\n---  used to circument Ada type checking. Each attribute-storage node\n---  contains not only the attribute value and a link for chaining, but\n---  also a pointer to a descriptor for the corresponding instantiation\n---  of Task_Attributes. The instantiation-descriptor contains a\n---  pointer to a procedure that can do the correct deallocation and\n---  finalization for that type of attribute. On task termination, the\n---  runtime system uses the pointer to call the appropriate deallocator.\n-\n---  While this gets around the limitation that instantations be at\n---  the library level, it relies on an implementation feature that\n---  may not always be safe, i.e. that it is safe to call the\n---  Deallocate procedure for an instantiation of Ada.Task_Attributes\n---  that no longer exists. In general, it seems this might result in\n---  dangling references.\n-\n---  Another problem with instantiations deeper than the library level\n---  is that there is risk of storage leakage, or dangling references\n---  to reused storage. That is, if an instantiation of Ada.Task_Attributes\n---  is made within a procedure, what happens to the storage allocated for\n---  attributes, when the procedure call returns?  Apparently (RM 7.6.1 (4))\n---  any such objects must be finalized, since they will no longer be\n---  accessible, and in general one would expect that the storage they occupy\n---  would be recovered for later reuse. (If not, we would have a case of\n---  storage leakage.)  Assuming the storage is recovered and later reused,\n---  we have potentially dangerous dangling references. When the procedure\n---  containing the instantiation of Ada.Task_Attributes returns, there\n---  may still be unterminated tasks with associated attribute values for\n---  that instantiation. When such tasks eventually terminate, the RTS\n---  will attempt to call the Deallocate procedure on them. If the\n---  corresponding storage has already been deallocated, when the master\n---  of the access type was left, we have a potential disaster. This\n---  disaster is compounded since the pointer to Deallocate is probably\n---  through a \"trampoline\" which will also have been destroyed.\n-\n---  For this reason, we arrange to remove all dangling references\n---  before leaving the scope of an instantiation. This is ugly, since\n---  it requires traversing the list of all tasks, but it is no more ugly\n---  than a similar traversal that we must do at the point of instantiation\n---  in order to initialize the attributes of all tasks. At least we only\n---  need to do these traversals if the type is controlled.\n-\n---  We chose to defer allocation of storage for attributes until the\n---  Reference function is called or the attribute is first set to a value\n---  different from the default initial one. This allows a potential\n---  savings in allocation, for attributes that are not used by all tasks.\n+--  extension of T, and since T is controlled (RM 3.9.1 (3)), instantiation is\n+--  only allowed at the library level.\n+\n+--  In the second approach the objects on the attribute list are of unrelated\n+--  but structurally similar types. Unchecked conversion is used to circument\n+--  Ada type checking. Each attribute-storage node contains not only the\n+--  attribute value and a link for chaining, but also a pointer to descriptor\n+--  for the corresponding instantiation of Task_Attributes. The instantiation\n+--  descriptor contains pointer to a procedure that can do the correct\n+--  deallocation and finalization for that type of attribute. On task\n+--  termination, the runtime system uses the pointer to call the appropriate\n+--  deallocator.\n+\n+--  While this gets around the limitation that instantations be at the library\n+--  level, it relies on an implementation feature that may not always be safe,\n+--  i.e. that it is safe to call the Deallocate procedure for an instantiation\n+--  of Ada.Task_Attributes that no longer exists. In general, it seems this\n+--  might result in dangling references.\n+\n+--  Another problem with instantiations deeper than the library level is that\n+--  there is risk of storage leakage, or dangling references to reused\n+--  storage. That is, if an instantiation of Ada.Task_Attributes is made\n+--  within a procedure, what happens to the storage allocated for attributes,\n+--  when the procedure call returns? Apparently (RM 7.6.1 (4)) any such\n+--  objects must be finalized, since they will no longer be accessible, and in\n+--  general one would expect that the storage they occupy would be recovered\n+--  for later reuse. (If not, we would have a case of storage leakage.)\n+--  Assuming the storage is recovered and later reused, we have potentially\n+--  dangerous dangling references. When the procedure containing the\n+--  instantiation of Ada.Task_Attributes returns, there may still be\n+--  unterminated tasks with associated attribute values for that instantiation.\n+--  When such tasks eventually terminate, the RTS will attempt to call the\n+--  Deallocate procedure on them. If the corresponding storage has already\n+--  been deallocated, when the master of the access type was left, we have a\n+--  potential disaster. This disaster is compounded since the pointer to\n+--  Deallocate is probably through a \"trampoline\" which will also have been\n+--  destroyed.\n+\n+--  For this reason, we arrange to remove all dangling references before\n+--  leaving the scope of an instantiation. This is ugly, since it requires\n+--  traversing the list of all tasks, but it is no more ugly than a similar\n+--  traversal that we must do at the point of instantiation in order to\n+--  initialize the attributes of all tasks. At least we only need to do these\n+--  traversals if the type is controlled.\n+\n+--  We chose to defer allocation of storage for attributes until the Reference\n+--  function is called or the attribute is first set to a value different from\n+--  the default initial one. This allows a potential savings in allocation,\n+--  for attributes that are not used by all tasks.\n \n --  For efficiency, we reserve space in the TCB for a fixed number of\n---  direct-access attributes. These are required to be of a size that\n---  fits in the space of an object of type System.Address. Because\n---  we must use unchecked bitwise copy operations on these values, they\n---  cannot be of a controlled type, but that is covered automatically\n---  since controlled objects are too large to fit in the spaces.\n+--  direct-access attributes. These are required to be of a size that fits in\n+--  the space of an object of type System.Address. Because we must use\n+--  unchecked bitwise copy operations on these values, they cannot be of a\n+--  controlled type, but that is covered automatically since controlled\n+--  objects are too large to fit in the spaces.\n \n --  We originally deferred the initialization of these direct-access\n---  attributes, just as we do for the indirect-access attributes, and\n---  used a per-task bit vector to keep track of which attributes were\n---  currently defined for that task. We found that the overhead of\n---  maintaining this bit-vector seriously slowed down access to the\n---  attributes, and made the fetch operation non-atomic, so that even\n---  to read an attribute value required locking the TCB. Therefore,\n---  we now initialize such attributes for all existing tasks at the time\n---  of the attribute instantiation, and initialize existing attributes\n---  for each new task at the time it is created.\n+--  attributes, just as we do for the indirect-access attributes, and used a\n+--  per-task bit vector to keep track of which attributes were currently\n+--  defined for that task. We found that the overhead of maintaining this\n+--  bit-vector seriously slowed down access to the attributes, and made the\n+--  fetch operation non-atomic, so that even to read an attribute value\n+--  required locking the TCB. Therefore, we now initialize such attributes for\n+--  all existing tasks at the time of the attribute instantiation, and\n+--  initialize existing attributes for each new task at the time it is\n+--  created.\n \n --  The latter initialization requires a list of all the instantiation\n---  descriptors. Updates to this list, as well as the bit-vector that\n---  is used to reserve slots for attributes in the TCB, require mutual\n---  exclusion. That is provided by the Lock/Unlock_RTS.\n-\n---  One special problem that added complexity to the design is that\n---  the per-task list of indirect attributes contains objects of\n---  different types. We use unchecked pointer conversion to link\n---  these nodes together and access them, but the records may not have\n---  identical internal structure. Initially, we thought it would be\n---  enough to allocate all the common components of the records at the\n---  front of each record, so that their positions would correspond.\n---  Unfortunately, GNAT adds \"dope\" information at the front of a record,\n---  if the record contains any controlled-type components.\n+--  descriptors. Updates to this list, as well as the bit-vector that is used\n+--  to reserve slots for attributes in the TCB, require mutual exclusion. That\n+--  is provided by the Lock/Unlock_RTS.\n+\n+--  One special problem that added complexity to the design is that the\n+--  per-task list of indirect attributes contains objects of different types.\n+--  We use unchecked pointer conversion to link these nodes together and\n+--  access them, but the records may not have identical internal structure.\n+--  Initially, we thought it would be enough to allocate all the common\n+--  components of the records at the front of each record, so that their\n+--  positions would correspond. Unfortunately, GNAT adds \"dope\" information at\n+--  the front of a record, if the record contains any controlled-type\n+--  components.\n --\n---  This means that the offset of the fields we use to link the nodes is\n---  at different positions on nodes of different types. To get around this,\n---  each attribute storage record consists of a core node and wrapper.\n---  The core nodes are all of the same type, and it is these that are\n---  linked together and generally \"seen\" by the RTS. Each core node\n---  contains a pointer to its own wrapper, which is a record that contains\n---  the core node along with an attribute value, approximately\n---  as follows:\n+--  This means that the offset of the fields we use to link the nodes is at\n+--  different positions on nodes of different types. To get around this, each\n+--  attribute storage record consists of a core node and wrapper. The core\n+--  nodes are all of the same type, and it is these that are linked together\n+--  and generally \"seen\" by the RTS. Each core node contains a pointer to its\n+--  own wrapper, which is a record that contains the core node along with an\n+--  attribute value, approximately as follows:\n \n --    type Node;\n --    type Node_Access is access all Node;\n@@ -211,65 +208,64 @@\n --       Wrapper : Access_Wrapper;\n --    end record;\n --    type Wrapper is record\n---       Noed    : aliased Node;\n---       Value   : aliased Attribute;  --  the generic formal type\n+--       Dummy_Node : aliased Node;\n+--       Value      : aliased Attribute;  --  the generic formal type\n --    end record;\n \n---  Another interesting problem is with the initialization of\n---  the instantiation descriptors. Originally, we did this all via\n---  the Initialize procedure of the descriptor type and code in the\n---  package body. It turned out that the Initialize procedure needed\n---  quite a bit of information, including the size of the attribute\n---  type, the initial value of the attribute (if it fits in the TCB),\n---  and a pointer to the deallocator procedure. These needed to be\n---  \"passed\" in via access discriminants. GNAT was having trouble\n---  with access discriminants, so all this work was moved to the\n---  package body.\n+--  Another interesting problem is with the initialization of the\n+--  instantiation descriptors. Originally, we did this all via the Initialize\n+--  procedure of the descriptor type and code in the package body. It turned\n+--  out that the Initialize procedure needed quite a bit of information,\n+--  including the size of the attribute type, the initial value of the\n+--  attribute (if it fits in the TCB), and a pointer to the deallocator\n+--  procedure. These needed to be \"passed\" in via access discriminants. GNAT\n+--  was having trouble with access discriminants, so all this work was moved\n+--  to the package body.\n \n with Ada.Task_Identification;\n---  used for Task_Id\n+--  Used for Task_Id\n --           Null_Task_Id\n --           Current_Task\n \n with System.Error_Reporting;\n---  used for Shutdown;\n+--  Used for Shutdown;\n \n with System.Storage_Elements;\n---  used for Integer_Address\n+--  Used for Integer_Address\n \n with System.Task_Primitives.Operations;\n---  used for Write_Lock\n+--  Used for Write_Lock\n --           Unlock\n --           Lock/Unlock_RTS\n \n with System.Tasking;\n---  used for Access_Address\n+--  Used for Access_Address\n --           Task_Id\n --           Direct_Index_Vector\n --           Direct_Index\n \n with System.Tasking.Initialization;\n---  used for Defer_Abortion\n+--  Used for Defer_Abortion\n --           Undefer_Abortion\n --           Initialize_Attributes_Link\n --           Finalize_Attributes_Link\n \n with System.Tasking.Task_Attributes;\n---  used for Access_Node\n+--  Used for Access_Node\n --           Access_Dummy_Wrapper\n --           Deallocator\n --           Instance\n --           Node\n --           Access_Instance\n \n with Ada.Exceptions;\n---  used for Raise_Exception\n+--  Used for Raise_Exception\n \n with Unchecked_Conversion;\n with Unchecked_Deallocation;\n \n pragma Elaborate_All (System.Tasking.Task_Attributes);\n---  to ensure the initialization of object Local (below) will work\n+--  To ensure the initialization of object Local (below) will work\n \n package body Ada.Task_Attributes is\n \n@@ -295,11 +291,10 @@ package body Ada.Task_Attributes is\n \n    pragma Warnings (Off);\n    --  We turn warnings off for the following declarations of the\n-   --  To_Attribute_Handle conversions, since these are used only\n-   --  for small attributes where we know that there are no problems\n-   --  with alignment, but the compiler will generate warnings for\n-   --  the occurrences in the large attribute case, even though\n-   --  they will not actually be used.\n+   --  To_Attribute_Handle conversions, since these are used only for small\n+   --  attributes where we know that there are no problems with alignment, but\n+   --  the compiler will generate warnings for the occurrences in the large\n+   --  attribute case, even though they will not actually be used.\n \n    function To_Attribute_Handle is new Unchecked_Conversion\n      (System.Address, Attribute_Handle);\n@@ -327,10 +322,10 @@ package body Ada.Task_Attributes is\n      (Access_Dummy_Wrapper, Access_Wrapper);\n    pragma Warnings (On);\n    --  To fetch pointer to actual wrapper of attribute node. We turn off\n-   --  warnings since this may generate an alignment warning. The warning\n-   --  can be ignored since Dummy_Wrapper is only a non-generic standin\n-   --  for the real wrapper type (we never actually allocate objects of\n-   --  type Dummy_Wrapper).\n+   --  warnings since this may generate an alignment warning. The warning can\n+   --  be ignored since Dummy_Wrapper is only a non-generic standin for the\n+   --  real wrapper type (we never actually allocate objects of type\n+   --  Dummy_Wrapper).\n \n    function To_Access_Dummy_Wrapper is new Unchecked_Conversion\n      (Access_Wrapper, Access_Dummy_Wrapper);\n@@ -364,7 +359,7 @@ package body Ada.Task_Attributes is\n    --  Initialized in package body\n \n    type Wrapper is record\n-      Noed : aliased Node;\n+      Dummy_Node : aliased Node;\n \n       Value : aliased Attribute := Initial_Value;\n       --  The generic formal type, may be controlled\n@@ -450,7 +445,7 @@ package body Ada.Task_Attributes is\n                   ((null, Local'Unchecked_Access, null), Initial_Value);\n             POP.Lock_RTS;\n \n-            P := W.Noed'Unchecked_Access;\n+            P := W.Dummy_Node'Unchecked_Access;\n             P.Wrapper := To_Access_Dummy_Wrapper (W);\n             P.Next := To_Access_Node (TT.Indirect_Attributes);\n             TT.Indirect_Attributes := To_Access_Address (P);\n@@ -605,14 +600,14 @@ package body Ada.Task_Attributes is\n             P := P.Next;\n          end loop;\n \n-         --  Unlock RTS here to follow the lock ordering rule that\n-         --  prevent us from using new (i.e the Global_Lock) while\n-         --  holding any other lock.\n+         --  Unlock RTS here to follow the lock ordering rule that prevent us\n+         --  from using new (i.e the Global_Lock) while holding any other\n+         --  lock.\n \n          POP.Unlock_RTS;\n          W := new Wrapper'((null, Local'Unchecked_Access, null), Val);\n          POP.Lock_RTS;\n-         P := W.Noed'Unchecked_Access;\n+         P := W.Dummy_Node'Unchecked_Access;\n          P.Wrapper := To_Access_Dummy_Wrapper (W);\n          P.Next := To_Access_Node (TT.Indirect_Attributes);\n          TT.Indirect_Attributes := To_Access_Address (P);\n@@ -661,9 +656,9 @@ package body Ada.Task_Attributes is\n       if Local.Index /= 0 then\n \n          --  Get value of attribute. Warnings off, because for large\n-         --  attributes, this code can generate alignment warnings.\n-         --  But of course large attributes are never directly addressed\n-         --  so in fact we will never execute the code in this case.\n+         --  attributes, this code can generate alignment warnings. But of\n+         --  course large attributes are never directly addressed so in fact\n+         --  we will never execute the code in this case.\n \n          pragma Warnings (Off);\n          return To_Attribute_Handle\n@@ -734,13 +729,13 @@ begin\n \n       POP.Lock_RTS;\n \n-      --  Add this instantiation to the list of all instantiations.\n+      --  Add this instantiation to the list of all instantiations\n \n       Local.Next := System.Tasking.Task_Attributes.All_Attributes;\n       System.Tasking.Task_Attributes.All_Attributes :=\n         Local'Unchecked_Access;\n \n-      --  Try to find space for the attribute in the TCB.\n+      --  Try to find space for the attribute in the TCB\n \n       Local.Index := 0;\n       Two_To_J := 1;\n@@ -754,9 +749,9 @@ begin\n                In_Use := In_Use or Two_To_J;\n                Local.Index := J;\n \n-               --  This unchecked conversions can give a warning when the\n-               --  the alignment is incorrect, but it will not be used in\n-               --  such a case anyway, so the warning can be safely ignored.\n+               --  This unchecked conversions can give a warning when the the\n+               --  alignment is incorrect, but it will not be used in such a\n+               --  case anyway, so the warning can be safely ignored.\n \n                pragma Warnings (Off);\n                To_Attribute_Handle (Local.Initial_Value'Access).all :=\n@@ -773,13 +768,13 @@ begin\n       --  Attribute goes directly in the TCB\n \n       if Local.Index /= 0 then\n-         --  Replace stub for initialization routine\n-         --  that is called at task creation.\n+         --  Replace stub for initialization routine that is called at task\n+         --  creation.\n \n          Initialization.Initialize_Attributes_Link :=\n            System.Tasking.Task_Attributes.Initialize_Attributes'Access;\n \n-         --  Initialize the attribute, for all tasks.\n+         --  Initialize the attribute, for all tasks\n \n          declare\n             C : System.Tasking.Task_Id := System.Tasking.All_Tasks_List;\n@@ -795,8 +790,8 @@ begin\n       --  Attribute goes into a node onto a linked list\n \n       else\n-         --  Replace stub for finalization routine\n-         --  that is called at task termination.\n+         --  Replace stub for finalization routine that is called at task\n+         --  termination.\n \n          Initialization.Finalize_Attributes_Link :=\n            System.Tasking.Task_Attributes.Finalize_Attributes'Access;"}, {"sha": "3988800a4f2723dcf89dc9235668763a819618a9", "filename": "gcc/ada/comperr.adb", "status": "modified", "additions": 32, "deletions": 38, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fcomperr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fcomperr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcomperr.adb?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -20,7 +20,7 @@\n -- MA 02111-1307, USA.                                                      --\n --                                                                          --\n -- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+-- Extensive contributions were provided by AdaCore.                         --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n@@ -78,7 +78,7 @@ package body Comperr is\n       --  the cause of the compiler abort and about the preferred method\n       --  of reporting bugs. The default is a bug box appropriate for\n       --  the FSF version of GNAT, but there are specializations for\n-      --  the GNATPRO and Public releases by Ada Core Technologies.\n+      --  the GNATPRO and Public releases by AdaCore.\n \n       procedure End_Line;\n       --  Add blanks up to column 76, and then a final vertical bar\n@@ -95,7 +95,6 @@ package body Comperr is\n \n       Is_Public_Version : constant Boolean := Get_Gnat_Build_Type = Public;\n       Is_FSF_Version    : constant Boolean := Get_Gnat_Build_Type = FSF;\n-      Is_GAP_Version    : constant Boolean := Get_Gnat_Build_Type = GAP;\n \n    --  Start of processing for Compiler_Abort\n \n@@ -268,22 +267,43 @@ package body Comperr is\n                      \" http://gcc.gnu.org/bugs.html.\");\n                   End_Line;\n \n+               elsif Is_Public_Version then\n+                  Write_Str\n+                    (\"| submit bug report by email \" &\n+                     \"to report@adacore.com.\");\n+                  End_Line;\n+\n+                  Write_Str\n+                    (\"| See gnatinfo.txt for full info on procedure \" &\n+                     \"for submitting bugs.\");\n+                  End_Line;\n+\n                else\n                   Write_Str\n-                    (\"| Please submit bug report by email \" &\n-                     \"to report@gnat.com.\");\n+                    (\"| Please submit a bug report using GNAT Tracker:\");\n                   End_Line;\n \n                   Write_Str\n-                    (\"| Use a subject line meaningful to you\" &\n-                     \" and us to track the bug.\");\n+                    (\"| http://www.adacore.com/gnattracker/ \" &\n+                     \"section 'send a report'.\");\n+                  End_Line;\n+\n+                  Write_Str\n+                    (\"| alternatively submit a bug report by email \" &\n+                     \"to report@adacore.com.\");\n                   End_Line;\n                end if;\n \n+\n+               Write_Str\n+                 (\"| Use a subject line meaningful to you\" &\n+                  \" and us to track the bug.\");\n+               End_Line;\n+\n                if not (Is_Public_Version or Is_FSF_Version) then\n                   Write_Str\n-                    (\"| (include your customer number #nnn \" &\n-                     \"in the subject line).\");\n+                    (\"| Include your customer number #nnn \" &\n+                     \"in the subject line.\");\n                   End_Line;\n                end if;\n \n@@ -305,35 +325,9 @@ package body Comperr is\n                  (\"| (concatenated together with no headers between files).\");\n                End_Line;\n \n-               if Is_Public_Version then\n+               if not Is_FSF_Version then\n                   Write_Str\n-                    (\"| (use plain ASCII or MIME attachment).\");\n-                  End_Line;\n-\n-                  Write_Str\n-                    (\"| See gnatinfo.txt for full info on procedure \" &\n-                     \"for submitting bugs.\");\n-                  End_Line;\n-\n-               elsif Is_GAP_Version then\n-                  Write_Str\n-                    (\"| (use plain ASCII or MIME attachment, or FTP \"\n-                     & \"to your GAP account.).\");\n-                  End_Line;\n-\n-                  Write_Str\n-                    (\"| Please use your GAP account to report this.\");\n-                  End_Line;\n-\n-               elsif not Is_FSF_Version then\n-                  Write_Str\n-                    (\"| (use plain ASCII or MIME attachment, or FTP \"\n-                     & \"to your customer directory).\");\n-                  End_Line;\n-\n-                  Write_Str\n-                    (\"| See README.GNATPRO for full info on procedure \" &\n-                     \"for submitting bugs.\");\n+                    (\"| Use plain ASCII or MIME attachment.\");\n                   End_Line;\n                end if;\n             end if;"}, {"sha": "cea4ec8998c798cc0100f45b081d59a7f0cfa955", "filename": "gcc/ada/s-bitops.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-bitops.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-bitops.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bitops.adb?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 1996-2004 Free Software Foundation, Inc.           --\n+--         Copyright (C) 1996-2005 Free Software Foundation, Inc.           --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -107,8 +107,7 @@ package body System.Bit_Ops is\n      (Left  : Address;\n       Llen  : Natural;\n       Right : Address;\n-      Rlen  : Natural)\n-      return  Boolean\n+      Rlen  : Natural) return Boolean\n    is\n       LeftB  : constant Bits := To_Bits (Left);\n       RightB : constant Bits := To_Bits (Right);"}, {"sha": "dbecac3d0da8f363d3a72daaacfeab634dd292c1", "filename": "gcc/ada/s-bitops.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-bitops.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-bitops.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bitops.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,7 +40,8 @@ package System.Bit_Ops is\n    --  Note: in all the following routines, the System.Address parameters\n    --  represent the address of the first byte of an array used to represent\n    --  a packed array (of type System.Unsigned_Types.Packed_Bytes{1,2,4})\n-   --  The length in bits is passed as a separate parameter.\n+   --  The length in bits is passed as a separate parameter. Note that all\n+   --  addresses must be of byte aligned arrays.\n \n    procedure Bit_And\n      (Left   : System.Address;\n@@ -57,8 +58,7 @@ package System.Bit_Ops is\n      (Left  : System.Address;\n       Llen  : Natural;\n       Right : System.Address;\n-      Rlen  : Natural)\n-      return  Boolean;\n+      Rlen  : Natural) return Boolean;\n    --  Left and Right are the addresses of two bit packed arrays with Llen\n    --  and Rlen being the respective length in bits. The routine compares the\n    --  two bit strings for equality, being careful not to include the unused"}, {"sha": "b09a471aafb0d7ac465f48d895436418158ce5f1", "filename": "gcc/ada/s-crtl.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-crtl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-crtl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-crtl.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -139,6 +139,12 @@ pragma Preelaborate (CRTL);\n    function opendir (file_name : String) return DIRs;\n    pragma Import (C, opendir, \"opendir\");\n \n+   function pclose (stream : System.Address) return int;\n+   pragma Import (C, pclose, \"pclose\");\n+\n+   function popen (command, mode : System.Address) return System.Address;\n+   pragma Import (C, popen, \"popen\");\n+\n    function read (fd : int; buffer : chars; nbytes : int) return int;\n    pragma Import (C, read, \"read\");\n "}, {"sha": "0ef7443a3a80f2944994ced67990704f7f4d7d3f", "filename": "gcc/ada/s-finimp.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-finimp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-finimp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finimp.adb?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -383,19 +383,22 @@ package body System.Finalization_Implementation is\n    procedure Finalize_Global_List is\n    begin\n       --  There are three case here:\n+\n       --  a. the application uses tasks, in which case Finalize_Global_Tasks\n-      --     will defer abortion\n+      --     will defer abort.\n+\n       --  b. the application doesn't use tasks but uses other tasking\n       --     constructs, such as ATCs and protected objects. In this case,\n       --     the binder will call Finalize_Global_List instead of\n       --     Finalize_Global_Tasks, letting abort undeferred, and leading\n       --     to assertion failures in the GNULL\n+\n       --  c. the application doesn't use any tasking construct in which case\n       --     deferring abort isn't necessary.\n-      --\n+\n       --  Until another solution is found to deal with case b, we need to\n       --  call abort_defer here to pass the checks, but we do not need to\n-      --  undefer abortion, since Finalize_Global_List is the last procedure\n+      --  undefer abort, since Finalize_Global_List is the last procedure\n       --  called before exiting the partition.\n \n       SSL.Abort_Defer.all;"}, {"sha": "a74659ada4c6c62d1e2b98fa17fbf5c752390ab5", "filename": "gcc/ada/s-intman-vms.ads", "status": "modified", "additions": 52, "deletions": 57, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-intman-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-intman-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-vms.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1991-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1991-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,30 +31,31 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is the Alpha/VMS version of this package.\n---\n---  This package encapsulates and centralizes information about\n---  all uses of interrupts (or signals), including the\n---  target-dependent mapping of interrupts (or signals) to exceptions.\n+--  This is the Alpha/VMS version of this package\n \n---  PLEASE DO NOT add any with-clauses to this package.\n---  This is designed to work for both tasking and non-tasking systems,\n---  without pulling in any of the tasking support.\n+--  This package encapsulates and centralizes information about all uses of\n+--  interrupts (or signals), including the target-dependent mapping of\n+--  interrupts (or signals) to exceptions.\n+\n+--  PLEASE DO NOT add any with-clauses to this package\n+\n+--  This is designed to work for both tasking and non-tasking systems, without\n+--  pulling in any of the tasking support.\n \n --  PLEASE DO NOT remove the Elaborate_Body pragma from this package.\n --  Elaboration of this package should happen early, as most other\n---  initializations depend on it.\n---  Forcing immediate elaboration of the body also helps to enforce\n---  the design assumption that this is a second-level\n---  package, just one level above System.OS_Interface, with no\n---  cross-dependences.\n-\n---  PLEASE DO NOT put any subprogram declarations with arguments of\n---  type Interrupt_ID into the visible part of this package.\n---  The type Interrupt_ID is used to derive the type in Ada.Interrupts,\n---  and adding more operations to that type would be illegal according\n---  to the Ada Reference Manual.  (This is the reason why the signals sets\n---  below are implemented as visible arrays rather than functions.)\n+\n+--  Forcing immediate elaboration of the body also helps to enforce the design\n+--  assumption that this is a second-level package, just one level above\n+--  System.OS_Interface, with no cross-dependences.\n+\n+--  PLEASE DO NOT put any subprogram declarations with arguments of type\n+--  Interrupt_ID into the visible part of this package.\n+\n+--  The type Interrupt_ID is used to derive the type in Ada.Interrupts, and\n+--  adding more operations to that type would be illegal according to the Ada\n+--  Reference Manual. (This is the reason why the signals sets below are\n+--  implemented as visible arrays rather than functions.)\n \n with System.OS_Interface;\n --  used for Signal\n@@ -70,49 +71,44 @@ package System.Interrupt_Management is\n \n    type Interrupt_Set is array (Interrupt_ID) of Boolean;\n \n-   --  The following objects serve as constants, but are initialized\n-   --  in the body to aid portability.  This permits us\n-   --  to use more portable names for interrupts,\n-   --  where distinct names may map to the same interrupt ID value.\n-   --  For example, suppose SIGRARE is a signal that is not defined on\n-   --  all systems, but is always reserved when it is defined.\n-   --  If we have the convention that ID zero is not used for any \"real\"\n-   --  signals, and SIGRARE = 0 when SIGRARE is not one of the locally\n-   --  supported signals, we can write\n+   --  The following objects serve as constants, but are initialized in the\n+   --  body to aid portability. This permits us to use more portable names for\n+   --  interrupts, where distinct names may map to the same interrupt ID\n+   --  value. For example, suppose SIGRARE is a signal that is not defined on\n+   --  all systems, but is always reserved when it is defined. If we have the\n+   --  convention that ID zero is not used for any \"real\" signals, and SIGRARE\n+   --  = 0 when SIGRARE is not one of the locally supported signals, we can\n+   --  write\n+\n    --     Reserved (SIGRARE) := true;\n-   --  and the initialization code will be portable.\n+\n+   --  Then the initialization code will be portable\n \n    Abort_Task_Interrupt : Interrupt_ID;\n-   --  The interrupt that is used to implement task abortion,\n-   --  if an interrupt is used for that purpose.\n-   --  This is one of the reserved interrupts.\n+   --  The interrupt that is used to implement task abort, if an interrupt is\n+   --  used for that purpose. This is one of the reserved interrupts.\n \n    Keep_Unmasked : Interrupt_Set := (others => False);\n-   --  Keep_Unmasked (I) is true iff the interrupt I is\n-   --  one that must be kept unmasked at all times,\n-   --  except (perhaps) for short critical sections.\n-   --  This includes interrupts that are mapped to exceptions\n-   --  (see System.Interrupt_Exceptions.Is_Exception), but may also\n-   --  include interrupts (e.g. timer) that need to be kept unmasked\n-   --  for other reasons.\n-   --  Where interrupts are implemented as OS signals, and signal masking\n-   --  is per-task, the interrupt should be unmasked in ALL TASKS.\n+   --  Keep_Unmasked (I) is true iff the interrupt I is one that must be kept\n+   --  unmasked at all times, except (perhaps) for short critical sections.\n+   --  This includes interrupts that are mapped to exceptions (see\n+   --  System.Interrupt_Exceptions.Is_Exception), but may also include\n+   --  interrupts (e.g. timer) that need to be kept unmasked for other\n+   --  reasons. Where interrupts are implemented as OS signals, and signal\n+   --  masking is per-task, the interrupt should be unmasked in ALL TASKS.\n \n    Reserve : Interrupt_Set := (others => False);\n-   --  Reserve (I) is true iff the interrupt I is one that\n-   --  cannot be permitted to be attached to a user handler.\n-   --  The possible reasons are many.  For example,\n-   --  it may be mapped to an exception, used to implement task abortion,\n-   --  or used to implement time delays.\n+   --  Reserve (I) is true iff the interrupt I is one that cannot be permitted\n+   --  to be attached to a user handler. The possible reasons are many. For\n+   --  example it may be mapped to an exception used to implement task abort.\n \n    Keep_Masked : Interrupt_Set := (others => False);\n    --  Keep_Masked (I) is true iff the interrupt I must always be masked.\n-   --  Where interrupts are implemented as OS signals, and signal masking\n-   --  is per-task, the interrupt should be masked in ALL TASKS.\n-   --  There might not be any interrupts in this class, depending on\n-   --  the environment.  For example, if interrupts are OS signals\n-   --  and signal masking is per-task, use of the sigwait operation\n-   --  requires the signal be masked in all tasks.\n+   --  Where interrupts are implemented as OS signals, and signal masking is\n+   --  per-task, the interrupt should be masked in ALL TASKS. There might not\n+   --  be any interrupts in this class, depending on the environment. For\n+   --  example, if interrupts are OS signals and signal masking is per-task,\n+   --  use of the sigwait operation requires the signal be masked in all tasks.\n \n    procedure Initialize_Interrupts;\n    --  On systems where there is no signal inheritance between tasks (e.g\n@@ -121,7 +117,6 @@ package System.Interrupt_Management is\n    --  only be called by initialize in this package body.\n \n private\n-\n    use type System.OS_Interface.unsigned_long;\n \n    type Interrupt_Mask is new System.OS_Interface.sigset_t;\n@@ -136,7 +131,7 @@ private\n    Rcv_Interrupt_Chan : System.OS_Interface.unsigned_short := 0;\n    Snd_Interrupt_Chan : System.OS_Interface.unsigned_short := 0;\n    Interrupt_Mailbox  : Interrupt_ID := 0;\n-   Interrupt_Bufquo   : System.OS_Interface.unsigned_long\n-                        := 1000 * (Interrupt_ID'Size / 8);\n+   Interrupt_Bufquo   : System.OS_Interface.unsigned_long :=\n+                          1000 * (Interrupt_ID'Size / 8);\n \n end System.Interrupt_Management;"}, {"sha": "7e386f300f41495d236374bb8e98125118c68856", "filename": "gcc/ada/s-intman-vxworks.ads", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-intman-vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-intman-vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-vxworks.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is the VxWorks version of this package.\n+--  This is the VxWorks version of this package\n \n --  This package encapsulates and centralizes information about all\n --  uses of interrupts (or signals), including the target-dependent\n@@ -76,48 +76,48 @@ package System.Interrupt_Management is\n \n    type Signal_Set is array (Signal_ID) of Boolean;\n \n-   --  The following objects serve as constants, but are initialized\n-   --  in the body to aid portability.  This permits us to use more\n-   --  portable names for interrupts, where distinct names may map to\n-   --  the same interrupt ID value.\n-   --\n-   --  For example, suppose SIGRARE is a signal that is not defined on\n-   --  all systems, but is always reserved when it is defined. If we\n-   --  have the convention that ID zero is not used for any \"real\"\n-   --  signals, and SIGRARE = 0 when SIGRARE is not one of the locally\n-   --  supported signals, we can write\n+   --  The following objects serve as constants, but are initialized in the\n+   --  body to aid portability. This permits us to use more portable names for\n+   --  interrupts, where distinct names may map to the same interrupt ID\n+   --  value.\n+\n+   --  For example, suppose SIGRARE is a signal that is not defined on all\n+   --  systems, but is always reserved when it is defined. If we have the\n+   --  convention that ID zero is not used for any \"real\" signals, and SIGRARE\n+   --  = 0 when SIGRARE is not one of the locally supported signals, we can\n+   --  write:\n+\n    --     Reserved (SIGRARE) := true;\n+\n    --  and the initialization code will be portable.\n \n    Abort_Task_Signal : Signal_ID;\n-   --  The signal that is used to implement task abortion if\n-   --  an interrupt is used for that purpose. This is one of the\n-   --  reserved signals.\n+   --  The signal that is used to implement task abort if an interrupt is used\n+   --  for that purpose. This is one of the reserved signals.\n \n    Keep_Unmasked : Signal_Set := (others => False);\n-   --  Keep_Unmasked (I) is true iff the signal I is one that must\n-   --  that must be kept unmasked at all times, except (perhaps) for\n-   --  short critical sections. This includes signals that are\n-   --  mapped to exceptions, but may also include interrupts\n-   --  (e.g. timer) that need to be kept unmasked for other\n-   --  reasons. Where signal masking is per-task, the signal should be\n+   --  Keep_Unmasked (I) is true iff the signal I is one that must that must\n+   --  be kept unmasked at all times, except (perhaps) for short critical\n+   --  sections. This includes signals that are mapped to exceptions, but may\n+   --  also include interrupts (e.g. timer) that need to be kept unmasked for\n+   --  other reasons. Where signal masking is per-task, the signal should be\n    --  unmasked in ALL TASKS.\n \n    Reserve : Interrupt_Set := (others => False);\n-   --  Reserve (I) is true iff the interrupt I is one that cannot be\n-   --  permitted to be attached to a user handler. The possible reasons\n-   --  are many. For example, it may be mapped to an exception used to\n-   --  implement task abortion, or used to implement time delays.\n+   --  Reserve (I) is true iff the interrupt I is one that cannot be permitted\n+   --  to be attached to a user handler. The possible reasons are many. For\n+   --  example, it may be mapped to an exception used to implement task abort,\n+   --  or used to implement time delays.\n \n    procedure Initialize_Interrupts;\n    --  On systems where there is no signal inheritance between tasks (e.g\n    --  VxWorks, GNU/LinuxThreads), this procedure is used to initialize\n-   --  interrupts handling in each task. Otherwise this function should\n-   --  only be called by initialize in this package body.\n+   --  interrupts handling in each task. Otherwise this function should only\n+   --  be called by initialize in this package body.\n \n private\n    type Interrupt_Mask is new System.OS_Interface.sigset_t;\n-   --  In some implementation Interrupt_Mask can be represented\n-   --  as a linked list.\n+   --  In some implementation Interrupt_Mask can be represented as a linked\n+   --  list.\n \n end System.Interrupt_Management;"}, {"sha": "c8d2a0e2d3c8fcfa57f8ceb2f35476d86edf3b6b", "filename": "gcc/ada/s-intman.ads", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-intman.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-intman.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,26 +31,26 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package encapsulates and centralizes information about all\n---  uses of interrupts (or signals), including the target-dependent\n---  mapping of interrupts (or signals) to exceptions.\n+--  This package encapsulates and centralizes information about all uses of\n+--  interrupts (or signals), including the target-dependent mapping of\n+--  interrupts (or signals) to exceptions.\n \n---  Unlike the original design, System.Interrupt_Management can only\n---  be used for tasking systems.\n+--  Unlike the original design, System.Interrupt_Management can only be used\n+--  for tasking systems.\n \n --  PLEASE DO NOT remove the Elaborate_Body pragma from this package.\n --  Elaboration of this package should happen early, as most other\n---  initializations depend on it. Forcing immediate elaboration of\n---  the body also helps to enforce the design assumption that this\n---  is a second-level package, just one level above System.OS_Interface\n---  with no cross-dependencies.\n-\n---  PLEASE DO NOT put any subprogram declarations with arguments of\n---  type Interrupt_ID into the visible part of this package. The type\n---  Interrupt_ID is used to derive the type in Ada.Interrupts, and\n---  adding more operations to that type would be illegal according\n---  to the Ada Reference Manual. This is the reason why the signals\n---  sets are implemeneted using visible arrays rather than functions.\n+--  initializations depend on it. Forcing immediate elaboration of the body\n+--  also helps to enforce the design assumption that this is a second-level\n+--  package, just one level above System.OS_Interface with no\n+--  cross-dependencies.\n+\n+--  PLEASE DO NOT put any subprogram declarations with arguments of type\n+--  Interrupt_ID into the visible part of this package. The type Interrupt_ID\n+--  is used to derive the type in Ada.Interrupts, and adding more operations\n+--  to that type would be illegal according to the Ada Reference Manual. This\n+--  is the reason why the signals sets are implemeneted using visible arrays\n+--  rather than functions.\n \n with System.OS_Interface;\n --  used for sigset_t\n@@ -69,49 +69,49 @@ package System.Interrupt_Management is\n \n    type Interrupt_Set is array (Interrupt_ID) of Boolean;\n \n-   --  The following objects serve as constants, but are initialized\n-   --  in the body to aid portability.  This permits us to use more\n-   --  portable names for interrupts, where distinct names may map to\n-   --  the same interrupt ID value.\n-   --\n-   --  For example, suppose SIGRARE is a signal that is not defined on\n-   --  all systems, but is always reserved when it is defined. If we\n-   --  have the convention that ID zero is not used for any \"real\"\n-   --  signals, and SIGRARE = 0 when SIGRARE is not one of the locally\n-   --  supported signals, we can write\n-   --     Reserved (SIGRARE) := true;\n+   --  The following objects serve as constants, but are initialized in the\n+   --  body to aid portability. This permits us to use more portable names for\n+   --  interrupts, where distinct names may map to the same interrupt ID\n+   --  value.\n+\n+   --  For example, suppose SIGRARE is a signal that is not defined on all\n+   --  systems, but is always reserved when it is defined. If we have the\n+   --  convention that ID zero is not used for any \"real\" signals, and SIGRARE\n+   --  = 0 when SIGRARE is not one of the locally supported signals, we can\n+   --  write\n+\n+   --     Reserved (SIGRARE) := True;\n+\n    --  and the initialization code will be portable.\n \n    Abort_Task_Interrupt : Interrupt_ID;\n-   --  The interrupt that is used to implement task abortion if\n-   --  an interrupt is used for that purpose. This is one of the\n-   --  reserved interrupts.\n+   --  The interrupt that is used to implement task abort if an interrupt is\n+   --  used for that purpose. This is one of the reserved interrupts.\n \n    Keep_Unmasked : Interrupt_Set := (others => False);\n-   --  Keep_Unmasked (I) is true iff the interrupt I is one that must\n-   --  that must be kept unmasked at all times, except (perhaps) for\n-   --  short critical sections. This includes interrupts that are\n-   --  mapped to exceptions (see System.Interrupt_Exceptions.Is_Exception),\n-   --  but may also include interrupts (e.g. timer) that need to be kept\n-   --  unmasked for other reasons. Where interrupts are implemented as\n-   --  OS signals, and signal masking is per-task, the interrupt should\n-   --  be unmasked in ALL TASKS.\n+   --  Keep_Unmasked (I) is true iff the interrupt I is one that must that\n+   --  must be kept unmasked at all times, except (perhaps) for short critical\n+   --  sections. This includes interrupts that are mapped to exceptions (see\n+   --  System.Interrupt_Exceptions.Is_Exception), but may also include\n+   --  interrupts (e.g. timer) that need to be kept unmasked for other\n+   --  reasons. Where interrupts are implemented as OS signals, and signal\n+   --  masking is per-task, the interrupt should be unmasked in ALL TASKS.\n \n    Reserve : Interrupt_Set := (others => False);\n-   --  Reserve (I) is true iff the interrupt I is one that cannot be\n-   --  permitted to be attached to a user handler. The possible reasons\n-   --  are many. For example, it may be mapped to an exception used to\n-   --  implement task abortion, or used to implement time delays.\n+   --  Reserve (I) is true iff the interrupt I is one that cannot be permitted\n+   --  to be attached to a user handler. The possible reasons are many. For\n+   --  example, it may be mapped to an exception used to implement task abort,\n+   --  or used to implement time delays.\n \n    procedure Initialize_Interrupts;\n    --  On systems where there is no signal inheritance between tasks (e.g\n    --  VxWorks, GNU/LinuxThreads), this procedure is used to initialize\n-   --  interrupts handling in each task. Otherwise this function should\n-   --  only be called by initialize in this package body.\n+   --  interrupts handling in each task. Otherwise this function should only\n+   --  be called by initialize in this package body.\n \n private\n    type Interrupt_Mask is new System.OS_Interface.sigset_t;\n-   --  In some implementation Interrupt_Mask can be represented\n-   --  as a linked list.\n+   --  In some implementations Interrupt_Mask can be represented as a linked\n+   --  list.\n \n end System.Interrupt_Management;"}, {"sha": "6e995f452bec96523e4de716a649e6dcf41c81f9", "filename": "gcc/ada/s-memory.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-memory.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-memory.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-memory.adb?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -35,13 +35,13 @@\n \n --  This implementation assumes that the underlying malloc/free/realloc\n --  implementation is thread safe, and thus, no additional lock is required.\n---  Note that we still need to defer abortion because on most systems,\n---  an asynchronous signal (as used for implementing asynchronous abortion\n---  of task) cannot safely be handled while malloc is executing.\n+--  Note that we still need to defer abort because on most systems, an\n+--  asynchronous signal (as used for implementing asynchronous abort of\n+--  task) cannot safely be handled while malloc is executing.\n \n---  If you are not using Ada constructs containing the \"abort\" keyword,\n---  then you can remove the calls to Abort_Defer.all and Abort_Undefer.all\n---  from this unit.\n+--  If you are not using Ada constructs containing the \"abort\" keyword, then\n+--  you can remove the calls to Abort_Defer.all and Abort_Undefer.all from\n+--  this unit.\n \n with Ada.Exceptions;\n with System.Soft_Links;"}, {"sha": "1e4007479d8ad72710ecc788b869661e03a90bae", "filename": "gcc/ada/s-soflin.ads", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-soflin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-soflin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-soflin.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -52,7 +52,7 @@ package System.Soft_Links is\n    pragma Import\n      (Ada, Current_Target_Exception,\n       \"__gnat_current_target_exception\");\n-   --  Import this subprogram from the private part of Ada.Exceptions.\n+   --  Import this subprogram from the private part of Ada.Exceptions\n \n    --  First we have the access subprogram types used to establish the links.\n    --  The approach is to establish variables containing access subprogram\n@@ -112,20 +112,20 @@ package System.Soft_Links is\n    --  Declarations for the no tasking versions of the required routines\n \n    procedure Abort_Defer_NT;\n-   --  Defer task abortion (non-tasking case, does nothing)\n+   --  Defer task abort (non-tasking case, does nothing)\n \n    procedure Abort_Undefer_NT;\n-   --  Undefer task abortion (non-tasking case, does nothing)\n+   --  Undefer task abort (non-tasking case, does nothing)\n \n    procedure Abort_Handler_NT;\n-   --  Handle task abortion (non-tasking case, does nothing). Currently,\n-   --  only VMS uses this.\n+   --  Handle task abort (non-tasking case, does nothing). Currently, only VMS\n+   --  uses this.\n \n    procedure Update_Exception_NT (X : EO := Current_Target_Exception);\n-   --  Handle exception setting. This routine is provided for targets\n-   --  which have built-in exception handling such as the Java Virtual\n-   --  Machine. Currently, only JGNAT uses this. See 4jexcept.ads for\n-   --  an explanation on how this routine is used.\n+   --  Handle exception setting. This routine is provided for targets which\n+   --  have built-in exception handling such as the Java Virtual Machine.\n+   --  Currently, only JGNAT uses this. See 4jexcept.ads for an explanation on\n+   --  how this routine is used.\n \n    function Check_Abort_Status_NT return Integer;\n    --  Returns Boolean'Pos (True) iff abort signal should raise\n@@ -143,14 +143,14 @@ package System.Soft_Links is\n \n    Abort_Defer : No_Param_Proc := Abort_Defer_NT'Access;\n    pragma Suppress (Access_Check, Abort_Defer);\n-   --  Defer task abortion (task/non-task case as appropriate)\n+   --  Defer task abort (task/non-task case as appropriate)\n \n    Abort_Undefer : No_Param_Proc := Abort_Undefer_NT'Access;\n    pragma Suppress (Access_Check, Abort_Undefer);\n-   --  Undefer task abortion (task/non-task case as appropriate)\n+   --  Undefer task abort (task/non-task case as appropriate)\n \n    Abort_Handler : No_Param_Proc := Abort_Handler_NT'Access;\n-   --  Handle task abortion (task/non-task case as appropriate)\n+   --  Handle task abort (task/non-task case as appropriate)\n \n    Update_Exception : Special_EO_Call := Update_Exception_NT'Access;\n    --  Handle exception setting and tasking polling when appropriate\n@@ -196,7 +196,7 @@ package System.Soft_Links is\n    --  explicitly or implicitly during the critical locked region.\n \n    Adafinal : No_Param_Proc := Null_Adafinal'Access;\n-   --  Performs the finalization of the Ada Runtime.\n+   --  Performs the finalization of the Ada Runtime\n \n    function  Get_Jmpbuf_Address_NT return  Address;\n    procedure Set_Jmpbuf_Address_NT (Addr : Address);"}, {"sha": "ce21a5dfab8e1649aafe36b493f026fb9ed40679", "filename": "gcc/ada/s-taasde.ads", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-taasde.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-taasde.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taasde.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1998-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1998-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,8 +31,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the procedures to implements timeouts (delays)\n---  for asynchronous select statements.\n+--  This package contains the procedures to implements timeouts (delays) for\n+--  asynchronous select statements.\n \n --  Note: the compiler generates direct calls to this interface, via Rtsfind.\n --  Any changes to this interface may require corresponding compiler changes.\n@@ -100,8 +100,8 @@ package System.Tasking.Async_Delays is\n      (T : in Duration;\n       D : Delay_Block_Access) return Boolean;\n    --  Enqueue the specified relative delay. Returns True if the delay has\n-   --  been enqueued, False if it has already expired.\n-   --  If the delay has been enqueued, abortion is deferred.\n+   --  been enqueued, False if it has already expired. If the delay has been\n+   --  enqueued, abort is deferred.\n \n    procedure Cancel_Async_Delay (D : Delay_Block_Access);\n    --  Cancel the specified asynchronous delay\n@@ -117,10 +117,10 @@ package System.Tasking.Async_Delays is\n private\n \n    type Delay_Block is record\n-      Self_Id     : Task_Id;\n+      Self_Id : Task_Id;\n       --  ID of the calling task\n \n-      Level       : ATC_Level_Base;\n+      Level : ATC_Level_Base;\n       --  Normally Level is the ATC nesting level of the\n       --  async. select statement to which this delay belongs, but\n       --  after a call has been dequeued we set it to\n@@ -130,10 +130,10 @@ private\n       Resume_Time : Duration;\n       --  The absolute wake up time, represented as Duration\n \n-      Timed_Out   : Boolean := False;\n+      Timed_Out : Boolean := False;\n       --  Set to true if the delay has timed out\n \n-      Succ, Pred  : Delay_Block_Access;\n+      Succ, Pred : Delay_Block_Access;\n       --  A double linked list\n    end record;\n "}, {"sha": "ab6852dbcb6af35eabe52e8f5eba8791d86898a5", "filename": "gcc/ada/s-taprob.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-taprob.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-taprob.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprob.adb?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -7,7 +7,7 @@\n --                                  B o d y                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2004, Ada Core Technologies               --\n+--             Copyright (C) 1995-2005, Ada Core Technologies               --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -90,15 +90,15 @@ package body System.Tasking.Protected_Objects is\n       Ceiling_Violation : Boolean;\n \n    begin\n-      --  The lock is made without defering abortion.\n+      --  The lock is made without defering abort\n \n-      --  Therefore the abortion has to be deferred before calling this\n-      --  routine. This means that the compiler has to generate a Defer_Abort\n-      --  call before the call to Lock.\n+      --  Therefore the abort has to be deferred before calling this routine.\n+      --  This means that the compiler has to generate a Defer_Abort call\n+      --  before the call to Lock.\n \n-      --  The caller is responsible for undeferring abortion, and compiler\n+      --  The caller is responsible for undeferring abort, and compiler\n       --  generated calls must be protected with cleanup handlers to ensure\n-      --  that abortion is undeferred in all cases.\n+      --  that abort is undeferred in all cases.\n \n       Write_Lock (Object.L'Access, Ceiling_Violation);\n "}, {"sha": "d922adedcf8dd23af19ad98293ddd388edb38a8c", "filename": "gcc/ada/s-taprop-os2.adb", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-taprop-os2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-taprop-os2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-os2.adb?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -112,7 +112,7 @@ package body System.Task_Primitives.Operations is\n    -- Local Data  --\n    -----------------\n \n-   --  The OS/2 DosAllocThreadLocalMemory API is used to allocate our TCB_Ptr.\n+   --  The OS/2 DosAllocThreadLocalMemory API is used to allocate our TCB_Ptr\n \n    --  This API reserves a small range of virtual addresses that is backed\n    --  by different physical memory for each running thread. In this case we\n@@ -141,7 +141,7 @@ package body System.Task_Primitives.Operations is\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    Environment_Task_Id : Task_Id;\n-   --  A variable to hold Task_Id for the environment task.\n+   --  A variable to hold Task_Id for the environment task\n \n    -----------------------\n    -- Local Subprograms --\n@@ -223,7 +223,7 @@ package body System.Task_Primitives.Operations is\n       Self_ID : Task_Id renames Thread_Local_Data_Ptr.Self_ID;\n \n    begin\n-      --  Check that the thread local data has been initialized.\n+      --  Check that the thread local data has been initialized\n \n       pragma Assert\n         ((Thread_Local_Data_Ptr /= null\n@@ -458,7 +458,7 @@ package body System.Task_Primitives.Operations is\n       Count : aliased ULONG; -- Used to store dummy result\n \n    begin\n-      --  Must reset Cond BEFORE L is unlocked.\n+      --  Must reset Cond BEFORE L is unlocked\n \n       Sem_Must_Not_Fail\n         (DosResetEventSem (Self_ID.Common.LL.CV, Count'Unchecked_Access));\n@@ -475,7 +475,7 @@ package body System.Task_Primitives.Operations is\n       Sem_Must_Not_Fail\n         (DosWaitEventSem (Self_ID.Common.LL.CV, SEM_INDEFINITE_WAIT));\n \n-      --  Since L was previously accquired, lock operation should not fail.\n+      --  Since L was previously accquired, lock operation should not fail\n \n       if Single_Lock then\n          Lock_RTS;\n@@ -516,7 +516,7 @@ package body System.Task_Primitives.Operations is\n       Count      : aliased ULONG;  --  Used to store dummy result\n \n    begin\n-      --  Must reset Cond BEFORE Self_ID is unlocked.\n+      --  Must reset Cond BEFORE Self_ID is unlocked\n \n       Sem_Must_Not_Fail\n         (DosResetEventSem (Self_ID.Common.LL.CV,\n@@ -611,7 +611,7 @@ package body System.Task_Primitives.Operations is\n          Write_Lock (Self_ID);\n       end if;\n \n-      --  Must reset Cond BEFORE Self_ID is unlocked.\n+      --  Must reset Cond BEFORE Self_ID is unlocked\n \n       Sem_Must_Not_Fail\n         (DosResetEventSem (Self_ID.Common.LL.CV,\n@@ -767,7 +767,7 @@ package body System.Task_Primitives.Operations is\n \n    procedure Enter_Task (Self_ID : Task_Id) is\n    begin\n-      --  Initialize thread local data. Must be done first.\n+      --  Initialize thread local data. Must be done first\n \n       Thread_Local_Data_Ptr.Self_ID := Self_ID;\n       Thread_Local_Data_Ptr.Lock_Prio_Level := 0;\n@@ -927,7 +927,7 @@ package body System.Task_Primitives.Operations is\n \n       T.Common.LL.Wrapper := To_PFNTHREAD (Wrapper);\n \n-      --  The OS implicitly gives the new task the priority of this task.\n+      --  The OS implicitly gives the new task the priority of this task\n \n       T.Common.LL.Current_Priority := Self.Common.LL.Current_Priority;\n \n@@ -1007,7 +1007,7 @@ package body System.Task_Primitives.Operations is\n    begin\n       null;\n \n-      --  Task abortion not implemented yet.\n+      --  Task abort not implemented yet.\n       --  Should perform other action ???\n \n    end Abort_Task;\n@@ -1103,9 +1103,9 @@ package body System.Task_Primitives.Operations is\n       Environment_Task_Id := Environment_Task;\n \n       Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n-      --  Initialize the lock used to synchronize chain of all ATCBs.\n+      --  Initialize the lock used to synchronize chain of all ATCBs\n \n-      --  Set ID of environment task.\n+      --  Set ID of environment task\n \n       Thread_Local_Data_Ptr.Self_ID := Environment_Task;\n       Environment_Task.Common.LL.Thread := 1; --  By definition"}, {"sha": "4298e09e84591baa163ab5476c19a4ac0f04b69d", "filename": "gcc/ada/s-taprop-vxworks.adb", "status": "modified", "additions": 71, "deletions": 62, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-taprop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-taprop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vxworks.adb?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -91,12 +91,12 @@ package body System.Task_Primitives.Operations is\n    -- Local Data --\n    ----------------\n \n-   --  The followings are logically constants, but need to be initialized\n-   --  at run time.\n+   --  The followings are logically constants, but need to be initialized at\n+   --  run time.\n \n    Single_RTS_Lock : aliased RTS_Lock;\n-   --  This is a lock to allow only one thread of control in the RTS at\n-   --  a time; it is used to execute in mutual exclusion from all other tasks.\n+   --  This is a lock to allow only one thread of control in the RTS at a\n+   --  time; it is used to execute in mutual exclusion from all other tasks.\n    --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n \n    ATCB_Key : aliased System.Address := System.Null_Address;\n@@ -109,12 +109,12 @@ package body System.Task_Primitives.Operations is\n    --  targets.\n \n    Environment_Task_Id : Task_Id;\n-   --  A variable to hold Task_Id for the environment task.\n+   --  A variable to hold Task_Id for the environment task\n \n    Unblocked_Signal_Mask : aliased sigset_t;\n    --  The set of signals that should unblocked in all tasks\n \n-   --  The followings are internal configuration constants needed.\n+   --  The followings are internal configuration constants needed\n \n    Time_Slice_Val : Integer;\n    pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n@@ -126,12 +126,12 @@ package body System.Task_Primitives.Operations is\n    pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n \n    FIFO_Within_Priorities : constant Boolean := Dispatching_Policy = 'F';\n-   --  Indicates whether FIFO_Within_Priorities is set.\n+   --  Indicates whether FIFO_Within_Priorities is set\n \n    Mutex_Protocol : Priority_Type;\n \n    Foreign_Task_Elaborated : aliased Boolean := True;\n-   --  Used to identified fake tasks (i.e., non-Ada Threads).\n+   --  Used to identified fake tasks (i.e., non-Ada Threads)\n \n    --------------------\n    -- Local Packages --\n@@ -145,23 +145,23 @@ package body System.Task_Primitives.Operations is\n \n       procedure Set (Self_Id : Task_Id);\n       pragma Inline (Set);\n-      --  Set the self id for the current task.\n+      --  Set the self id for the current task\n \n       function Self return Task_Id;\n       pragma Inline (Self);\n-      --  Return a pointer to the Ada Task Control Block of the calling task.\n+      --  Return a pointer to the Ada Task Control Block of the calling task\n \n    end Specific;\n \n    package body Specific is separate;\n-   --  The body of this package is target specific.\n+   --  The body of this package is target specific\n \n    ---------------------------------\n    -- Support for foreign threads --\n    ---------------------------------\n \n    function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;\n-   --  Allocate and Initialize a new ATCB for the current Thread.\n+   --  Allocate and Initialize a new ATCB for the current Thread\n \n    function Register_Foreign_Thread\n      (Thread : Thread_Id) return Task_Id is separate;\n@@ -171,7 +171,7 @@ package body System.Task_Primitives.Operations is\n    -----------------------\n \n    procedure Abort_Handler (signo : Signal);\n-   --  Handler for the abort (SIGABRT) signal to handle asynchronous abortion.\n+   --  Handler for the abort (SIGABRT) signal to handle asynchronous abort\n \n    procedure Install_Signal_Handlers;\n    --  Install the default signal handlers for the current task\n@@ -409,7 +409,8 @@ package body System.Task_Primitives.Operations is\n    begin\n       pragma Assert (Self_ID = Self);\n \n-      --  Release the mutex before sleeping.\n+      --  Release the mutex before sleeping\n+\n       if Single_Lock then\n          Result := semGive (Single_RTS_Lock.Mutex);\n       else\n@@ -418,15 +419,16 @@ package body System.Task_Primitives.Operations is\n \n       pragma Assert (Result = 0);\n \n-      --  Perform a blocking operation to take the CV semaphore.\n-      --  Note that a blocking operation in VxWorks will reenable\n-      --  task scheduling. When we are no longer blocked and control\n-      --  is returned, task scheduling will again be disabled.\n+      --  Perform a blocking operation to take the CV semaphore. Note that a\n+      --  blocking operation in VxWorks will reenable task scheduling. When we\n+      --  are no longer blocked and control is returned, task scheduling will\n+      --  again be disabled.\n \n       Result := semTake (Self_ID.Common.LL.CV, WAIT_FOREVER);\n       pragma Assert (Result = 0);\n \n-      --  Take the mutex back.\n+      --  Take the mutex back\n+\n       if Single_Lock then\n          Result := semTake (Single_RTS_Lock.Mutex, WAIT_FOREVER);\n       else\n@@ -440,9 +442,8 @@ package body System.Task_Primitives.Operations is\n    -- Timed_Sleep --\n    -----------------\n \n-   --  This is for use within the run-time system, so abort is\n-   --  assumed to be already deferred, and the caller should be\n-   --  holding its own ATCB lock.\n+   --  This is for use within the run-time system, so abort is assumed to be\n+   --  already deferred, and the caller should be holding its own ATCB lock.\n \n    procedure Timed_Sleep\n      (Self_ID  : Task_Id;\n@@ -467,9 +468,9 @@ package body System.Task_Primitives.Operations is\n       if Mode = Relative then\n          Absolute := Orig + Time;\n \n-         --  Systematically add one since the first tick will delay\n-         --  *at most* 1 / Rate_Duration seconds, so we need to add one to\n-         --  be on the safe side.\n+         --  Systematically add one since the first tick will delay *at most*\n+         --  1 / Rate_Duration seconds, so we need to add one to be on the\n+         --  safe side.\n \n          Ticks := To_Clock_Ticks (Time);\n \n@@ -484,7 +485,8 @@ package body System.Task_Primitives.Operations is\n \n       if Ticks > 0 then\n          loop\n-            --  Release the mutex before sleeping.\n+            --  Release the mutex before sleeping\n+\n             if Single_Lock then\n                Result := semGive (Single_RTS_Lock.Mutex);\n             else\n@@ -493,25 +495,27 @@ package body System.Task_Primitives.Operations is\n \n             pragma Assert (Result = 0);\n \n-            --  Perform a blocking operation to take the CV semaphore.\n-            --  Note that a blocking operation in VxWorks will reenable\n-            --  task scheduling. When we are no longer blocked and control\n-            --  is returned, task scheduling will again be disabled.\n+            --  Perform a blocking operation to take the CV semaphore. Note\n+            --  that a blocking operation in VxWorks will reenable task\n+            --  scheduling. When we are no longer blocked and control is\n+            --  returned, task scheduling will again be disabled.\n \n             Result := semTake (Self_ID.Common.LL.CV, Ticks);\n \n             if Result = 0 then\n+\n                --  Somebody may have called Wakeup for us\n \n                Wakeup := True;\n \n             else\n                if errno /= S_objLib_OBJ_TIMEOUT then\n                   Wakeup := True;\n+\n                else\n-                  --  If Ticks = int'last, it was most probably truncated\n-                  --  so let's make another round after recomputing Ticks\n-                  --  from the the absolute time.\n+                  --  If Ticks = int'last, it was most probably truncated so\n+                  --  let's make another round after recomputing Ticks from\n+                  --  the the absolute time.\n \n                   if Ticks /= int'Last then\n                      Timedout := True;\n@@ -525,7 +529,8 @@ package body System.Task_Primitives.Operations is\n                end if;\n             end if;\n \n-            --  Take the mutex back.\n+            --  Take the mutex back\n+\n             if Single_Lock then\n                Result := semTake (Single_RTS_Lock.Mutex, WAIT_FOREVER);\n             else\n@@ -540,7 +545,8 @@ package body System.Task_Primitives.Operations is\n       else\n          Timedout := True;\n \n-         --  Should never hold a lock while yielding.\n+         --  Should never hold a lock while yielding\n+\n          if Single_Lock then\n             Result := semGive (Single_RTS_Lock.Mutex);\n             taskDelay (0);\n@@ -558,8 +564,8 @@ package body System.Task_Primitives.Operations is\n    -- Timed_Delay --\n    -----------------\n \n-   --  This is for use in implementing delay statements, so\n-   --  we assume the caller is holding no locks.\n+   --  This is for use in implementing delay statements, so we assume the\n+   --  caller is holding no locks.\n \n    procedure Timed_Delay\n      (Self_ID  : Task_Id;\n@@ -582,9 +588,8 @@ package body System.Task_Primitives.Operations is\n \n          if Ticks > 0 and then Ticks < int'Last then\n \n-            --  The first tick will delay anytime between 0 and\n-            --  1 / sysClkRateGet seconds, so we need to add one to\n-            --  be on the safe side.\n+            --  First tick will delay anytime between 0 and 1 / sysClkRateGet\n+            --  seconds, so we need to add one to be on the safe side.\n \n             Ticks := Ticks + 1;\n          end if;\n@@ -595,7 +600,9 @@ package body System.Task_Primitives.Operations is\n       end if;\n \n       if Ticks > 0 then\n-         --  Modifying State and Pending_Priority_Change, locking the TCB.\n+\n+         --  Modifying State and Pending_Priority_Change, locking the TCB\n+\n          if Single_Lock then\n             Result := semTake (Single_RTS_Lock.Mutex, WAIT_FOREVER);\n          else\n@@ -630,6 +637,7 @@ package body System.Task_Primitives.Operations is\n             Result := semTake (Self_ID.Common.LL.CV, Ticks);\n \n             if Result /= 0 then\n+\n                --  If Ticks = int'last, it was most probably truncated\n                --  so let's make another round after recomputing Ticks\n                --  from the the absolute time.\n@@ -749,6 +757,7 @@ package body System.Task_Primitives.Operations is\n       if FIFO_Within_Priorities then\n \n          --  Annex D requirement [RM D.2.2 par. 9]:\n+\n          --    If the task drops its priority due to the loss of inherited\n          --    priority, it is added at the head of the ready queue for its\n          --    new active priority.\n@@ -794,15 +803,16 @@ package body System.Task_Primitives.Operations is\n    procedure Enter_Task (Self_ID : Task_Id) is\n       procedure Init_Float;\n       pragma Import (C, Init_Float, \"__gnat_init_float\");\n-      --  Properly initializes the FPU for PPC/MIPS systems.\n+      --  Properly initializes the FPU for PPC/MIPS systems\n \n    begin\n       Self_ID.Common.LL.Thread := taskIdSelf;\n       Specific.Set (Self_ID);\n \n       Init_Float;\n \n-      --  Install the signal handlers.\n+      --  Install the signal handlers\n+\n       --  This is called for each task since there is no signal inheritance\n       --  between VxWorks tasks.\n \n@@ -892,28 +902,26 @@ package body System.Task_Primitives.Operations is\n          Adjusted_Stack_Size := size_t (Stack_Size);\n       end if;\n \n-      --  Ask for 4 extra bytes of stack space so that the ATCB\n-      --  pointer can be stored below the stack limit, plus extra\n-      --  space for the frame of Task_Wrapper.  This is so the user\n-      --  gets the amount of stack requested exclusive of the needs\n-      --  of the runtime.\n+      --  Ask for four extra bytes of stack space so that the ATCB pointer can\n+      --  be stored below the stack limit, plus extra space for the frame of\n+      --  Task_Wrapper. This is so the user gets the amount of stack requested\n+      --  exclusive of the needs\n       --\n-      --  We also have to allocate n more bytes for the task name\n-      --  storage and enough space for the Wind Task Control Block\n-      --  which is around 0x778 bytes.  VxWorks also seems to carve out\n-      --  additional space, so use 2048 as a nice round number.\n-      --  We might want to increment to the nearest page size in\n-      --  case we ever support VxVMI.\n+      --  We also have to allocate n more bytes for the task name storage and\n+      --  enough space for the Wind Task Control Block which is around 0x778\n+      --  bytes. VxWorks also seems to carve out additional space, so use 2048\n+      --  as a nice round number. We might want to increment to the nearest\n+      --  page size in case we ever support VxVMI.\n       --\n-      --  XXX - we should come back and visit this so we can\n-      --        set the task name to something appropriate.\n+      --  XXX - we should come back and visit this so we can set the task name\n+      --        to something appropriate.\n \n       Adjusted_Stack_Size := Adjusted_Stack_Size + 2048;\n \n       --  Since the initial signal mask of a thread is inherited from the\n-      --  creator, and the Environment task has all its signals masked, we\n-      --  do not need to manipulate caller's signal mask at this point.\n-      --  All tasks in RTS will have All_Tasks_Mask initially.\n+      --  creator, and the Environment task has all its signals masked, we do\n+      --  not need to manipulate caller's signal mask at this point. All tasks\n+      --  in RTS will have All_Tasks_Mask initially.\n \n       if T.Common.Task_Image_Len = 0 then\n          T.Common.LL.Thread := taskSpawn\n@@ -926,6 +934,7 @@ package body System.Task_Primitives.Operations is\n       else\n          declare\n             Name : aliased String (1 .. T.Common.Task_Image_Len + 1);\n+\n          begin\n             Name (1 .. Name'Last - 1) :=\n               T.Common.Task_Image (1 .. T.Common.Task_Image_Len);\n@@ -1004,7 +1013,7 @@ package body System.Task_Primitives.Operations is\n \n    begin\n       Result := kill (T.Common.LL.Thread,\n-        Signal (Interrupt_Management.Abort_Task_Signal));\n+                      Signal (Interrupt_Management.Abort_Task_Signal));\n       pragma Assert (Result = 0);\n    end Abort_Task;\n \n@@ -1127,7 +1136,7 @@ package body System.Task_Primitives.Operations is\n \n       Environment_Task_Id := Environment_Task;\n \n-      --  Initialize the lock used to synchronize chain of all ATCBs.\n+      --  Initialize the lock used to synchronize chain of all ATCBs\n \n       Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n "}, {"sha": "e3c80baf71b2821df4f603a9e9b1228773ca0d1c", "filename": "gcc/ada/s-taprop.ads", "status": "modified", "additions": 119, "deletions": 133, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-taprop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-taprop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -82,43 +82,39 @@ package System.Task_Primitives.Operations is\n \n    procedure Enter_Task (Self_ID : ST.Task_Id);\n    pragma Inline (Enter_Task);\n-   --  Initialize data structures specific to the calling task.\n-   --  Self must be the ID of the calling task.\n-   --  It must be called (once) by the task immediately after creation,\n-   --  while abortion is still deferred.\n-   --  The effects of other operations defined below are not defined\n-   --  unless the caller has previously called Initialize_Task.\n+   --  Initialize data structures specific to the calling task. Self must be\n+   --  the ID of the calling task. It must be called (once) by the task\n+   --  immediately after creation, while abort is still deferred. The effects\n+   --  of other operations defined below are not defined unless the caller has\n+   --  previously called Initialize_Task.\n \n    procedure Exit_Task;\n    pragma Inline (Exit_Task);\n-   --  Destroy the thread of control.\n-   --  Self must be the ID of the calling task.\n-   --  The effects of further calls to operations defined below\n-   --  on the task are undefined thereafter.\n+   --  Destroy the thread of control. Self must be the ID of the calling task.\n+   --  The effects of further calls to operations defined below on the task\n+   --  are undefined thereafter.\n \n    function New_ATCB (Entry_Num : ST.Task_Entry_Index) return ST.Task_Id;\n    pragma Inline (New_ATCB);\n-   --  Allocate a new ATCB with the specified number of entries.\n+   --  Allocate a new ATCB with the specified number of entries\n \n    procedure Initialize_TCB (Self_ID : ST.Task_Id; Succeeded : out Boolean);\n    pragma Inline (Initialize_TCB);\n    --  Initialize all fields of the TCB\n \n    procedure Finalize_TCB (T : ST.Task_Id);\n    pragma Inline (Finalize_TCB);\n-   --  Finalizes Private_Data of ATCB, and then deallocates it.\n-   --  This is also responsible for recovering any storage or other resources\n-   --  that were allocated by Create_Task (the one in this package).\n-   --  This should only be called from Free_Task.\n-   --  After it is called there should be no further\n+   --  Finalizes Private_Data of ATCB, and then deallocates it. This is also\n+   --  responsible for recovering any storage or other resources that were\n+   --  allocated by Create_Task (the one in this package). This should only be\n+   --  called from Free_Task. After it is called there should be no further\n    --  reference to the ATCB that corresponds to T.\n \n    procedure Abort_Task (T : ST.Task_Id);\n    pragma Inline (Abort_Task);\n-   --  Abort the task specified by T (the target task). This causes\n-   --  the target task to asynchronously raise Abort_Signal if\n-   --  abort is not deferred, or if it is blocked on an interruptible\n-   --  system call.\n+   --  Abort the task specified by T (the target task). This causes the target\n+   --  task to asynchronously raise Abort_Signal if abort is not deferred, or\n+   --  if it is blocked on an interruptible system call.\n    --\n    --  precondition:\n    --    the calling task is holding T's lock and has abort deferred\n@@ -130,35 +126,35 @@ package System.Task_Primitives.Operations is\n \n    function Self return ST.Task_Id;\n    pragma Inline (Self);\n-   --  Return a pointer to the Ada Task Control Block of the calling task.\n+   --  Return a pointer to the Ada Task Control Block of the calling task\n \n    type Lock_Level is\n      (PO_Level,\n       Global_Task_Level,\n       RTS_Lock_Level,\n       ATCB_Level);\n    --  Type used to describe kind of lock for second form of Initialize_Lock\n-   --  call specified below.\n-   --  See locking rules in System.Tasking (spec) for more details.\n+   --  call specified below. See locking rules in System.Tasking (spec) for\n+   --  more details.\n \n    procedure Initialize_Lock (Prio : System.Any_Priority; L : access Lock);\n    procedure Initialize_Lock (L : access RTS_Lock; Level : Lock_Level);\n    pragma Inline (Initialize_Lock);\n    --  Initialize a lock object.\n    --\n-   --  For Lock, Prio is the ceiling priority associated with the lock.\n-   --  For RTS_Lock, the ceiling is implicitly Priority'Last.\n+   --  For Lock, Prio is the ceiling priority associated with the lock. For\n+   --  RTS_Lock, the ceiling is implicitly Priority'Last.\n    --\n    --  If the underlying system does not support priority ceiling\n    --  locking, the Prio parameter is ignored.\n    --\n-   --  The effect of either initialize operation is undefined unless L\n-   --  is a lock object that has not been initialized, or which has been\n-   --  finalized since it was last initialized.\n+   --  The effect of either initialize operation is undefined unless is a lock\n+   --  object that has not been initialized, or which has been finalized since\n+   --  it was last initialized.\n    --\n-   --  The effects of the other operations on lock objects\n-   --  are undefined unless the lock object has been initialized\n-   --  and has not since been finalized.\n+   --  The effects of the other operations on lock objects are undefined\n+   --  unless the lock object has been initialized and has not since been\n+   --  finalized.\n    --\n    --  Initialization of the per-task lock is implicit in Create_Task.\n    --\n@@ -230,89 +226,82 @@ package System.Task_Primitives.Operations is\n    --  read or write permission. (That is, matching pairs of Lock and Unlock\n    --  operations on each lock object must be properly nested.)\n \n-   --  For the operation on RTS_Lock, Global_Lock should be set to True\n-   --  if L is a global lock (Single_RTS_Lock, Global_Task_Lock).\n+   --  For the operation on RTS_Lock, Global_Lock should be set to True if L\n+   --  is a global lock (Single_RTS_Lock, Global_Task_Lock).\n    --\n    --  Note that Write_Lock for RTS_Lock does not have an out-parameter.\n-   --  RTS_Locks are used in situations where we have not made provision\n-   --  for recovery from ceiling violations. We do not expect them to\n-   --  occur inside the runtime system, because all RTS locks have ceiling\n-   --  Priority'Last.\n-\n-   --  There is one way there can be a ceiling violation.\n-   --  That is if the runtime system is called from a task that is\n-   --  executing in the Interrupt_Priority range.\n-\n-   --  It is not clear what to do about ceiling violations due\n-   --  to RTS calls done at interrupt priority. In general, it\n-   --  is not acceptable to give all RTS locks interrupt priority,\n-   --  since that whould give terrible performance on systems where\n-   --  this has the effect of masking hardware interrupts, though we\n-   --  could get away with allowing Interrupt_Priority'last where we\n-   --  are layered on an OS that does not allow us to mask interrupts.\n-   --  Ideally, we would like to raise Program_Error back at the\n-   --  original point of the RTS call, but this would require a lot of\n-   --  detailed analysis and recoding, with almost certain performance\n-   --  penalties.\n-\n-   --  For POSIX systems, we considered just skipping setting a\n-   --  priority ceiling on RTS locks. This would mean there is no\n-   --  ceiling violation, but we would end up with priority inversions\n-   --  inside the runtime system, resulting in failure to satisfy the\n-   --  Ada priority rules, and possible missed validation tests.\n-   --  This could be compensated-for by explicit priority-change calls\n-   --  to raise the caller to Priority'Last whenever it first enters\n-   --  the runtime system, but the expected overhead seems high, though\n-   --  it might be lower than using locks with ceilings if the underlying\n-   --  implementation of ceiling locks is an inefficient one.\n-\n-   --  This issue should be reconsidered whenever we get around to\n-   --  checking for calls to potentially blocking operations from\n-   --  within protected operations. If we check for such calls and\n-   --  catch them on entry to the OS, it may be that we can eliminate\n-   --  the possibility of ceiling violations inside the RTS. For this\n-   --  to work, we would have to forbid explicitly setting the priority\n-   --  of a task to anything in the Interrupt_Priority range, at least.\n-   --  We would also have to check that there are no RTS-lock operations\n-   --  done inside any operations that are not treated as potentially\n-   --  blocking.\n-\n-   --  The latter approach seems to be the best, i.e. to check on entry\n-   --  to RTS calls that may need to use locks that the priority is not\n-   --  in the interrupt range. If there are RTS operations that NEED to\n-   --  be called from interrupt handlers, those few RTS locks should then\n-   --  be converted to PO-type locks, with ceiling Interrupt_Priority'Last.\n-\n-   --  For now, we will just shut down the system if there is a\n-   --  ceiling violation.\n+   --  RTS_Locks are used in situations where we have not made provision for\n+   --  recovery from ceiling violations. We do not expect them to occur inside\n+   --  the runtime system, because all RTS locks have ceiling Priority'Last.\n+\n+   --  There is one way there can be a ceiling violation. That is if the\n+   --  runtime system is called from a task that is executing in the\n+   --  Interrupt_Priority range.\n+\n+   --  It is not clear what to do about ceiling violations due to RTS calls\n+   --  done at interrupt priority. In general, it is not acceptable to give\n+   --  all RTS locks interrupt priority, since that whould give terrible\n+   --  performance on systems where this has the effect of masking hardware\n+   --  interrupts, though we could get away with allowing\n+   --  Interrupt_Priority'last where we are layered on an OS that does not\n+   --  allow us to mask interrupts. Ideally, we would like to raise\n+   --  Program_Error back at the original point of the RTS call, but this\n+   --  would require a lot of detailed analysis and recoding, with almost\n+   --  certain performance penalties.\n+\n+   --  For POSIX systems, we considered just skipping setting priority ceiling\n+   --  on RTS locks. This would mean there is no ceiling violation, but we\n+   --  would end up with priority inversions inside the runtime system,\n+   --  resulting in failure to satisfy the Ada priority rules, and possible\n+   --  missed validation tests. This could be compensated-for by explicit\n+   --  priority-change calls to raise the caller to Priority'Last whenever it\n+   --  first enters the runtime system, but the expected overhead seems high,\n+   --  though it might be lower than using locks with ceilings if the\n+   --  underlying implementation of ceiling locks is an inefficient one.\n+\n+   --  This issue should be reconsidered whenever we get around to checking\n+   --  for calls to potentially blocking operations from within protected\n+   --  operations. If we check for such calls and catch them on entry to the\n+   --  OS, it may be that we can eliminate the possibility of ceiling\n+   --  violations inside the RTS. For this to work, we would have to forbid\n+   --  explicitly setting the priority of a task to anything in the\n+   --  Interrupt_Priority range, at least. We would also have to check that\n+   --  there are no RTS-lock operations done inside any operations that are\n+   --  not treated as potentially blocking.\n+\n+   --  The latter approach seems to be the best, i.e. to check on entry to RTS\n+   --  calls that may need to use locks that the priority is not in the\n+   --  interrupt range. If there are RTS operations that NEED to be called\n+   --  from interrupt handlers, those few RTS locks should then be converted\n+   --  to PO-type locks, with ceiling Interrupt_Priority'Last.\n+\n+   --  For now, we will just shut down the system if there is ceiling violation\n \n    procedure Yield (Do_Yield : Boolean := True);\n    pragma Inline (Yield);\n-   --  Yield the processor. Add the calling task to the tail of the\n-   --  ready queue for its active_priority.\n-   --  The Do_Yield argument is only used in some very rare cases very\n-   --  a yield should have an effect on a specific target and not on regular\n-   --  ones.\n+   --  Yield the processor. Add the calling task to the tail of the ready\n+   --  queue for its active_priority. The Do_Yield argument is only used in\n+   --  some very rare cases very a yield should have an effect on a specific\n+   --  target and not on regular ones.\n \n    procedure Set_Priority\n      (T : ST.Task_Id;\n       Prio : System.Any_Priority;\n       Loss_Of_Inheritance : Boolean := False);\n    pragma Inline (Set_Priority);\n-   --  Set the priority of the task specified by T to T.Current_Priority.\n-   --  The priority set is what would correspond to the Ada concept of\n-   --  \"base priority\" in the terms of the lower layer system, but\n-   --  the operation may be used by the upper layer to implement\n-   --  changes in \"active priority\" that are not due to lock effects.\n-   --  The effect should be consistent with the Ada Reference Manual.\n-   --  In particular, when a task lowers its priority due to the loss of\n-   --  inherited priority, it goes at the head of the queue for its new\n-   --  priority (RM D.2.2 par 9). Loss_Of_Inheritance helps the underlying\n-   --  implementation to do it right when the OS doesn't.\n+   --  Set the priority of the task specified by T to T.Current_Priority. The\n+   --  priority set is what would correspond to the Ada concept of \"base\n+   --  priority\" in the terms of the lower layer system, but the operation may\n+   --  be used by the upper layer to implement changes in \"active priority\"\n+   --  that are not due to lock effects. The effect should be consistent with\n+   --  the Ada Reference Manual. In particular, when a task lowers its\n+   --  priority due to the loss of inherited priority, it goes at the head of\n+   --  the queue for its new priority (RM D.2.2 par 9). Loss_Of_Inheritance\n+   --  helps the underlying implementation to do it right when the OS doesn't.\n \n    function Get_Priority (T : ST.Task_Id) return System.Any_Priority;\n    pragma Inline (Get_Priority);\n-   --  Returns the priority last set by Set_Priority for this task.\n+   --  Returns the priority last set by Set_Priority for this task\n \n    function Monotonic_Clock return Duration;\n    pragma Inline (Monotonic_Clock);\n@@ -343,17 +332,16 @@ package System.Task_Primitives.Operations is\n    --    and has abort deferred\n    --\n    --  postcondition:\n-   --    The calling task is holding its own ATCB lock\n-   --    and has abort deferred.\n+   --    The calling task is holding its own ATCB lock and has abort deferred.\n \n    --  The effect is to atomically unlock T's lock and wait, so that another\n    --  task that is able to lock T's lock can be assured that the wait has\n    --  actually commenced, and that a Wakeup operation will cause the waiting\n-   --  task to become ready for execution once again. When Sleep returns,\n-   --  the waiting task will again hold its own ATCB lock. The waiting task\n-   --  may become ready for execution at any time (that is, spurious wakeups\n-   --  are permitted), but it will definitely become ready for execution when\n-   --  a Wakeup operation is performed for the same task.\n+   --  task to become ready for execution once again. When Sleep returns, the\n+   --  waiting task will again hold its own ATCB lock. The waiting task may\n+   --  become ready for execution at any time (that is, spurious wakeups are\n+   --  permitted), but it will definitely become ready for execution when a\n+   --  Wakeup operation is performed for the same task.\n \n    procedure Timed_Sleep\n      (Self_ID  : ST.Task_Id;\n@@ -399,21 +387,20 @@ package System.Task_Primitives.Operations is\n    -- RTS Entrance/Exit --\n    -----------------------\n \n-   --  Following two routines are used for possible operations needed\n-   --  to be setup/cleared upon entrance/exit of RTS while maintaining\n-   --  a single thread of control in the RTS. Since we intend these\n-   --  routines to be used for implementing the Single_Lock RTS,\n-   --  Lock_RTS should follow the first Defer_Abortion operation\n-   --  entering RTS. In the same fashion Unlock_RTS should preceed\n-   --  the last Undefer_Abortion exiting RTS.\n+   --  Following two routines are used for possible operations needed to be\n+   --  setup/cleared upon entrance/exit of RTS while maintaining a single\n+   --  thread of control in the RTS. Since we intend these routines to be used\n+   --  for implementing the Single_Lock RTS, Lock_RTS should follow the first\n+   --  Defer_Abortion operation entering RTS. In the same fashion Unlock_RTS\n+   --  should preceed the last Undefer_Abortion exiting RTS.\n    --\n    --  These routines also replace the functions Lock/Unlock_All_Tasks_List\n \n    procedure Lock_RTS;\n-   --  Take the global RTS lock.\n+   --  Take the global RTS lock\n \n    procedure Unlock_RTS;\n-   --  Release the global RTS lock.\n+   --  Release the global RTS lock\n \n    --------------------\n    -- Stack Checking --\n@@ -424,30 +411,29 @@ package System.Task_Primitives.Operations is\n    --  an insufficient amount of stack space remains in the current task.\n \n    --  The exact mechanism for a stack probe is target dependent. Typical\n-   --  possibilities are to use a load from a non-existent page, a store\n-   --  to a read-only page, or a comparison with some stack limit constant.\n-   --  Where possible we prefer to use a trap on a bad page access, since\n-   --  this has less overhead. The generation of stack probes is either\n-   --  automatic if the ABI requires it (as on for example DEC Unix), or\n-   --  is controlled by the gcc parameter -fstack-check.\n-\n-   --  When we are using bad-page accesses, we need a bad page, called a\n-   --  guard page, at the end of each task stack. On some systems, this\n-   --  is provided automatically, but on other systems, we need to create\n-   --  the guard page ourselves, and the procedure Stack_Guard is provided\n-   --  for this purpose.\n+   --  possibilities are to use a load from a non-existent page, a store to a\n+   --  read-only page, or a comparison with some stack limit constant. Where\n+   --  possible we prefer to use a trap on a bad page access, since this has\n+   --  less overhead. The generation of stack probes is either automatic if\n+   --  the ABI requires it (as on for example DEC Unix), or is controlled by\n+   --  the gcc parameter -fstack-check.\n+\n+   --  When we are using bad-page accesses, we need a bad page, called guard\n+   --  page, at the end of each task stack. On some systems, this is provided\n+   --  automatically, but on other systems, we need to create the guard page\n+   --  ourselves, and the procedure Stack_Guard is provided for this purpose.\n \n    procedure Stack_Guard (T : ST.Task_Id; On : Boolean);\n    --  Ensure guard page is set if one is needed and the underlying thread\n    --  system does not provide it. The procedure is as follows:\n    --\n    --    1. When we create a task adjust its size so a guard page can\n-   --       safely be set at the bottom of the stack\n+   --       safely be set at the bottom of the stack.\n    --\n    --    2. When the thread is created (and its stack allocated by the\n    --       underlying thread system), get the stack base (and size, depending\n-   --       how the stack is growing), and create the guard page taking care of\n-   --       page boundaries issues.\n+   --       how the stack is growing), and create the guard page taking care\n+   --       of page boundaries issues.\n    --\n    --    3. When the task is destroyed, remove the guard page.\n    --\n@@ -467,11 +453,11 @@ package System.Task_Primitives.Operations is\n \n    function Check_Exit (Self_ID : ST.Task_Id) return Boolean;\n    pragma Inline (Check_Exit);\n-   --  Check that the current task is holding only Global_Task_Lock.\n+   --  Check that the current task is holding only Global_Task_Lock\n \n    function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean;\n    pragma Inline (Check_No_Locks);\n-   --  Check that current task is holding no locks.\n+   --  Check that current task is holding no locks\n \n    function Suspend_Task\n      (T           : ST.Task_Id;"}, {"sha": "6a1da15615eb0672b13044c5a51c27adcf5e2f4f", "filename": "gcc/ada/s-tasini.adb", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tasini.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tasini.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasini.adb?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,30 +41,30 @@ pragma Polling (Off);\n --  to poll it can cause infinite loops.\n \n with Ada.Exceptions;\n---  used for Exception_Occurrence_Access.\n+--  Used for Exception_Occurrence_Access\n \n with System.Tasking;\n pragma Elaborate_All (System.Tasking);\n---  ensure that the first step initializations have been performed\n+--  Ensure that the first step initializations have been performed\n \n with System.Task_Primitives;\n---  used for Lock\n+--  Used for Lock\n \n with System.Task_Primitives.Operations;\n---  used for Set_Priority\n+--  Used for Set_Priority\n --           Write_Lock\n --           Unlock\n --           Initialize_Lock\n \n with System.Soft_Links;\n---  used for the non-tasking routines (*_NT) that refer to global data.\n+--  Used for the non-tasking routines (*_NT) that refer to global data.\n --  They are needed here before the tasking run time has been elaborated.\n \n with System.Soft_Links.Tasking;\n --  Used for Init_Tasking_Soft_Links\n \n with System.Tasking.Debug;\n---  used for Trace\n+--  Used for Trace\n \n with System.Stack_Checking;\n \n@@ -88,7 +88,7 @@ package body System.Tasking.Initialization is\n    function Current_Target_Exception return AE.Exception_Occurrence;\n    pragma Import\n      (Ada, Current_Target_Exception, \"__gnat_current_target_exception\");\n-   --  Import this subprogram from the private part of Ada.Exceptions.\n+   --  Import this subprogram from the private part of Ada.Exceptions\n \n    ----------------------------------------------------------------------\n    -- Tasking versions of some services needed by non-tasking programs --\n@@ -150,7 +150,7 @@ package body System.Tasking.Initialization is\n    -- Change_Base_Priority --\n    --------------------------\n \n-   --  Call only with abort deferred and holding Self_ID locked.\n+   --  Call only with abort deferred and holding Self_ID locked\n \n    procedure Change_Base_Priority (T : Task_Id) is\n    begin\n@@ -269,7 +269,7 @@ package body System.Tasking.Initialization is\n       --  while we had abort deferred below.\n \n       loop\n-         --  Temporarily defer abortion so that we can lock Self_ID.\n+         --  Temporarily defer abort so that we can lock Self_ID\n \n          Self_ID.Deferral_Level := Self_ID.Deferral_Level + 1;\n \n@@ -286,7 +286,7 @@ package body System.Tasking.Initialization is\n             Unlock_RTS;\n          end if;\n \n-         --  Restore the original Deferral value.\n+         --  Restore the original Deferral value\n \n          Self_ID.Deferral_Level := Self_ID.Deferral_Level - 1;\n \n@@ -401,11 +401,11 @@ package body System.Tasking.Initialization is\n \n       SSL.Tasking.Init_Tasking_Soft_Links;\n \n-      --  Install tasking locks in the GCC runtime.\n+      --  Install tasking locks in the GCC runtime\n \n       Gnat_Install_Locks (Task_Lock'Access, Task_Unlock'Access);\n \n-      --  Abortion is deferred in a new ATCB, so we need to undefer abortion\n+      --  Abort is deferred in a new ATCB, so we need to undefer abort\n       --  at this stage to make the environment task abortable.\n \n       Undefer_Abort (Environment_Task);\n@@ -426,15 +426,16 @@ package body System.Tasking.Initialization is\n    --  hurt to uncomment the above call, until the error is corrected for\n    --  all targets.\n \n-   --  See extended comments in package body System.Tasking.Abortion\n-   --  for the overall design of the implementation of task abort.\n+   --  See extended comments in package body System.Tasking.Abort for the\n+   --  overall design of the implementation of task abort.\n+   --  ??? there is no such package ???\n \n-   --  If the task is sleeping it will be in an abort-deferred region,\n-   --  and will not have Abort_Signal raised by Abort_Task.\n-   --  Such an \"abort deferral\" is just to protect the RTS internals,\n-   --  and not necessarily required to enforce Ada semantics.\n-   --  Abort_Task should wake the task up and let it decide if it wants\n-   --  to complete the aborted construct immediately.\n+   --  If the task is sleeping it will be in an abort-deferred region, and\n+   --  will not have Abort_Signal raised by Abort_Task. Such an \"abort\n+   --  deferral\" is just to protect the RTS internals, and not necessarily\n+   --  required to enforce Ada semantics. Abort_Task should wake the task up\n+   --  and let it decide if it wants to complete the aborted construct\n+   --  immediately.\n \n    --  Note that the effect of the lowl-level Abort_Task is not persistent.\n    --  If the target task is not blocked, this wakeup will be missed.\n@@ -452,14 +453,13 @@ package body System.Tasking.Initialization is\n    --  implement delays). That still left the possibility of missed\n    --  wakeups.\n \n-   --  We cannot safely call Vulnerable_Complete_Activation here,\n-   --  since that requires locking Self_ID.Parent. The anti-deadlock\n-   --  lock ordering rules would then require us to release the lock\n-   --  on Self_ID first, which would create a timing window for other\n-   --  tasks to lock Self_ID. This is significant for tasks that may be\n-   --  aborted before their execution can enter the task body, and so\n-   --  they do not get a chance to call Complete_Task. The actual work\n-   --  for this case is done in Terminate_Task.\n+   --  We cannot safely call Vulnerable_Complete_Activation here, since that\n+   --  requires locking Self_ID.Parent. The anti-deadlock lock ordering rules\n+   --  would then require us to release the lock on Self_ID first, which would\n+   --  create a timing window for other tasks to lock Self_ID. This is\n+   --  significant for tasks that may be aborted before their execution can\n+   --  enter the task body, and so they do not get a chance to call\n+   --  Complete_Task. The actual work for this case is done in Terminate_Task.\n \n    procedure Locked_Abort_To_Level\n      (Self_ID : Task_Id;\n@@ -694,12 +694,12 @@ package body System.Tasking.Initialization is\n \n    --  Precondition : Self does not hold any locks!\n \n-   --  Undefer_Abort is called on any abortion completion point (aka.\n+   --  Undefer_Abort is called on any abort completion point (aka.\n    --  synchronization point). It performs the following actions if they\n    --  are pending: (1) change the base priority, (2) abort the task.\n \n-   --  The priority change has to occur before abortion. Otherwise, it would\n-   --  take effect no earlier than the next abortion completion point.\n+   --  The priority change has to occur before abort. Otherwise, it would\n+   --  take effect no earlier than the next abort completion point.\n \n    procedure Undefer_Abort (Self_ID : Task_Id) is\n    begin\n@@ -761,8 +761,8 @@ package body System.Tasking.Initialization is\n    -- Undefer_Abortion --\n    ----------------------\n \n-   --  Phase out RTS-internal use of Undefer_Abortion\n-   --  to reduce overhead due to multiple calls to Self.\n+   --  Phase out RTS-internal use of Undefer_Abortion to reduce overhead due\n+   --  to multiple calls to Self.\n \n    procedure Undefer_Abortion is\n       Self_ID : Task_Id;\n@@ -806,7 +806,7 @@ package body System.Tasking.Initialization is\n    -- Update_Exception --\n    ----------------------\n \n-   --  Call only when holding no locks.\n+   --  Call only when holding no locks\n \n    procedure Update_Exception\n      (X : AE.Exception_Occurrence := Current_Target_Exception)"}, {"sha": "8917dcc8aa54353b365144d5a249e076e435c128", "filename": "gcc/ada/s-tasini.ads", "status": "modified", "additions": 52, "deletions": 60, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tasini.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tasini.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasini.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,8 +37,7 @@\n package System.Tasking.Initialization is\n \n    procedure Remove_From_All_Tasks_List (T : Task_Id);\n-   --  Remove T from All_Tasks_List.\n-   --  Call this function with RTS_Lock taken.\n+   --  Remove T from All_Tasks_List. Call this function with RTS_Lock taken\n \n    ---------------------------------\n    -- Tasking-Specific Soft Links --\n@@ -47,18 +46,19 @@ package System.Tasking.Initialization is\n    --  These permit us to leave out certain portions of the tasking\n    --  run-time system if they are not used.  They are only used internally\n    --  by the tasking run-time system.\n-   --  So far, the only example is support for Ada.Task_Attributes.\n+\n+   --  So far, the only example is support for Ada.Task_Attributes\n \n    type Proc_T is access procedure (T : Task_Id);\n \n    procedure Finalize_Attributes (T : Task_Id);\n    procedure Initialize_Attributes (T : Task_Id);\n \n    Finalize_Attributes_Link : Proc_T := Finalize_Attributes'Access;\n-   --  should be called with abortion deferred and T.L write-locked\n+   --  should be called with abort deferred and T.L write-locked\n \n    Initialize_Attributes_Link : Proc_T := Initialize_Attributes'Access;\n-   --  should be called with abortion deferred, but holding no locks\n+   --  should be called with abort deferred, but holding no locks\n \n    -------------------------\n    -- Abort Defer/Undefer --\n@@ -68,43 +68,41 @@ package System.Tasking.Initialization is\n    --  in the calling task until a matching Undefer_Abort call is executed.\n \n    --  Undefer_Abort DOES MORE than just undo the effects of one call to\n-   --  Defer_Abort.  It is the universal \"polling point\" for deferred\n+   --  Defer_Abort. It is the universal \"polling point\" for deferred\n    --  processing, including the following:\n \n    --  1) base priority changes\n \n    --  2) abort/ATC\n \n-   --  Abort deferral MAY be nested (Self_ID.Deferral_Level is a count),\n-   --  but to avoid waste and undetected errors, it generally SHOULD NOT\n-   --  be nested.  The symptom of over-deferring abort is that an exception\n-   --  may fail to be raised, or an abort may fail to take place.\n+   --  Abort deferral MAY be nested (Self_ID.Deferral_Level is a count), but\n+   --  to avoid waste and undetected errors, it generally SHOULD NOT be\n+   --  nested. The symptom of over-deferring abort is that an exception may\n+   --  fail to be raised, or an abort may fail to take place.\n \n-   --  Therefore, there are two sets of the inlinable defer/undefer\n-   --  routines, which are the ones to be used inside GNARL.\n-   --  One set allows nesting.  The other does not.  People who\n-   --  maintain the GNARL should try to avoid using the nested versions,\n-   --  or at least look very critically at the places where they are\n-   --  used.\n+   --  Therefore, there are two sets of the inlinable defer/undefer routines,\n+   --  which are the ones to be used inside GNARL. One set allows nesting. The\n+   --  other does not. People who maintain the GNARL should try to avoid using\n+   --  the nested versions, or at least look very critically at the places\n+   --  where they are used.\n \n-   --  In general, any GNARL call that is potentially blocking, or\n-   --  whose semantics require that it sometimes raise an exception,\n-   --  or that is required to be an abort completion point, must be\n-   --  made with abort Deferral_Level = 1.\n+   --  In general, any GNARL call that is potentially blocking, or whose\n+   --  semantics require that it sometimes raise an exception, or that is\n+   --  required to be an abort completion point, must be made with abort\n+   --  Deferral_Level = 1.\n \n-   --  In general, non-blocking GNARL calls, which may be made from inside\n-   --  a protected action, are likely to need to allow nested abort\n-   --  deferral.\n+   --  In general, non-blocking GNARL calls, which may be made from inside a\n+   --  protected action, are likely to need to allow nested abort deferral.\n \n    --  With some critical exceptions (which are supposed to be documented),\n    --  internal calls to the tasking runtime system assume abort is already\n    --  deferred, and do not modify the deferral level.\n \n-   --  There is also a set of non-linable defer/undefer routines,\n-   --  for direct call from the compiler. These are not in-lineable\n-   --  because they may need to be called via pointers (\"soft links\").\n-   --  For the sake of efficiency, the version with Self_ID as parameter\n-   --  should used wherever possible. These are all nestable.\n+   --  There is also a set of non-linable defer/undefer routines, for direct\n+   --  call from the compiler. These are not in-lineable because they may need\n+   --  to be called via pointers (\"soft links\"). For the sake of efficiency,\n+   --  the version with Self_ID as parameter should used wherever possible.\n+   --  These are all nestable.\n \n    --  Non-nestable inline versions\n \n@@ -128,16 +126,14 @@ package System.Tasking.Initialization is\n    procedure Defer_Abortion;\n    procedure Undefer_Abortion;\n \n-   --  ?????\n-   --  Try to phase out all uses of the above versions.\n+   --  Try to phase out all uses of the above versions ???\n \n    procedure Do_Pending_Action (Self_ID : Task_Id);\n-   --  Only call with no locks, and when Self_ID.Pending_Action = True\n-   --  Perform necessary pending actions (e.g. abortion, priority change).\n-   --  This procedure is usually called when needed as a result of\n-   --  calling Undefer_Abort, although in the case of e.g. No_Abort\n-   --  restriction, it can be necessary to force execution of pending\n-   --  actions.\n+   --  Only call with no locks, and when Self_ID.Pending_Action = True Perform\n+   --  necessary pending actions (e.g. abort, priority change). This procedure\n+   --  is usually called when needed as a result of calling Undefer_Abort,\n+   --  although in the case of e.g. No_Abort restriction, it can be necessary\n+   --  to force execution of pending actions.\n \n    function Check_Abort_Status return Integer;\n    --  Returns Boolean'Pos (True) iff abort signal should raise\n@@ -148,9 +144,8 @@ package System.Tasking.Initialization is\n    --------------------------\n \n    procedure Change_Base_Priority (T : Task_Id);\n-   --  Change the base priority of T.\n-   --  Has to be called with the affected task's ATCB write-locked.\n-   --  May temporariliy release the lock.\n+   --  Change the base priority of T. Has to be called with the affected\n+   --  task's ATCB write-locked. May temporariliy release the lock.\n \n    procedure Poll_Base_Priority_Change (Self_ID : Task_Id);\n    --  Has to be called with Self_ID's ATCB write-locked.\n@@ -170,44 +165,41 @@ package System.Tasking.Initialization is\n    --  within the GNARL.\n \n    procedure Final_Task_Unlock (Self_ID : Task_Id);\n-   --  This version is only for use in Terminate_Task, when the task\n-   --  is relinquishing further rights to its own ATCB.\n-   --  There is a very interesting potential race condition there, where\n-   --  the old task may run concurrently with a new task that is allocated\n-   --  the old tasks (now reused) ATCB.  The critical thing here is to\n-   --  not make any reference to the ATCB after the lock is released.\n-   --  See also comments on Terminate_Task and Unlock.\n+   --  This version is only for use in Terminate_Task, when the task is\n+   --  relinquishing further rights to its own ATCB. There is a very\n+   --  interesting potential race condition there, where the old task may run\n+   --  concurrently with a new task that is allocated the old tasks (now\n+   --  reused) ATCB. The critical thing here is to not make any reference to\n+   --  the ATCB after the lock is released. See also comments on\n+   --  Terminate_Task and Unlock.\n \n    procedure Wakeup_Entry_Caller\n      (Self_ID    : Task_Id;\n       Entry_Call : Entry_Call_Link;\n       New_State  : Entry_Call_State);\n    pragma Inline (Wakeup_Entry_Caller);\n-   --  This is called at the end of service of an entry call,\n-   --  to abort the caller if he is in an abortable part, and\n-   --  to wake up the caller if he is on Entry_Caller_Sleep.\n-   --  Call it holding the lock of Entry_Call.Self.\n+   --  This is called at the end of service of an entry call, to abort the\n+   --  caller if he is in an abortable part, and to wake up the caller if he\n+   --  is on Entry_Caller_Sleep. Call it holding the lock of Entry_Call.Self.\n    --\n    --  Timed_Call or Simple_Call:\n-   --    The caller is waiting on Entry_Caller_Sleep, in\n-   --    Wait_For_Completion, or Wait_For_Completion_With_Timeout.\n+   --    The caller is waiting on Entry_Caller_Sleep, in Wait_For_Completion,\n+   --    or Wait_For_Completion_With_Timeout.\n    --\n    --  Conditional_Call:\n    --    The caller might be in Wait_For_Completion,\n-   --    waiting for a rendezvous (possibly requeued without abort)\n-   --    to complete.\n+   --    waiting for a rendezvous (possibly requeued without abort) to\n+   --    complete.\n    --\n    --  Asynchronous_Call:\n-   --    The caller may be executing in the abortable part o\n-   --    an async. select, or on a time delay,\n-   --    if Entry_Call.State >= Was_Abortable.\n+   --    The caller may be executing in the abortable part an async. select,\n+   --    or on a time delay, if Entry_Call.State >= Was_Abortable.\n \n    procedure Locked_Abort_To_Level\n      (Self_ID : Task_Id;\n       T       : Task_Id;\n       L       : ATC_Level);\n    pragma Inline (Locked_Abort_To_Level);\n-   --  Abort a task to a specified ATC level.\n-   --  Call this only with T locked.\n+   --  Abort a task to a specified ATC level. Call this only with T locked\n \n end System.Tasking.Initialization;"}, {"sha": "3bafc1300651ff3b6e3f8d97bc79553db42057fe", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 218, "deletions": 201, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package provides necessary type definitions for compiler interface.\n+--  This package provides necessary type definitions for compiler interface\n \n --  Note: the compiler generates direct calls to this interface, via Rtsfind.\n --  Any changes to this interface may require corresponding compiler changes.\n@@ -62,13 +62,12 @@ package System.Tasking is\n    --  The following rules must be followed at all times, to prevent\n    --  deadlock and generally ensure correct operation of locking.\n \n-   --  . Never lock a lock unless abort is deferred.\n+   --  Never lock a lock unless abort is deferred\n \n-   --  . Never undefer abort while holding a lock.\n+   --  Never undefer abort while holding a lock\n \n-   --  . Overlapping critical sections must be properly nested,\n-   --    and locks must be released in LIFO order.\n-   --    e.g., the following is not allowed:\n+   --  Overlapping critical sections must be properly nested, and locks must\n+   --  be released in LIFO order. e.g., the following is not allowed:\n \n    --         Lock (X);\n    --         ...\n@@ -80,7 +79,6 @@ package System.Tasking is\n \n    --  Locks with lower (smaller) level number cannot be locked\n    --  while holding a lock with a higher level number. (The level\n-   --  number is the number at the left.)\n \n    --  1. System.Tasking.PO_Simple.Protection.L (any PO lock)\n    --  2. System.Tasking.Initialization.Global_Task_Lock (in body)\n@@ -94,13 +92,13 @@ package System.Tasking is\n    --  clearly wrong since there can be calls to \"new\" inside protected\n    --  operations. The new ordering prevents these failures.\n \n-   --  Sometimes we need to hold two ATCB locks at the same time. To allow\n-   --  us to order the locking, each ATCB is given a unique serial\n-   --  number. If one needs to hold locks on several ATCBs at once,\n-   --  the locks with lower serial numbers must be locked first.\n+   --  Sometimes we need to hold two ATCB locks at the same time. To allow us\n+   --  to order the locking, each ATCB is given a unique serial number. If one\n+   --  needs to hold locks on several ATCBs at once, the locks with lower\n+   --  serial numbers must be locked first.\n \n-   --  We don't always need to check the serial numbers, since\n-   --  the serial numbers are assigned sequentially, and so:\n+   --  We don't always need to check the serial numbers, since the serial\n+   --  numbers are assigned sequentially, and so:\n \n    --  . The parent of a task always has a lower serial number.\n    --  . The activator of a task always has a lower serial number.\n@@ -157,13 +155,13 @@ package System.Tasking is\n       --  alternatives have been awakened and have terminated themselves.\n \n       Activator_Sleep,\n-      --  Task is waiting for created tasks to complete activation.\n+      --  Task is waiting for created tasks to complete activation\n \n       Acceptor_Sleep,\n-      --  Task is waiting on an accept or selective wait statement.\n+      --  Task is waiting on an accept or selective wait statement\n \n       Entry_Caller_Sleep,\n-      --  Task is waiting on an entry call.\n+      --  Task is waiting on an entry call\n \n       Async_Select_Sleep,\n       --  Task is waiting to start the abortable part of an\n@@ -309,20 +307,20 @@ package System.Tasking is\n       State : Entry_Call_State;\n       pragma Atomic (State);\n       --  Indicates part of the state of the call.\n-      --  Protection:\n-      --  If the call is not on a queue, it should\n-      --  only be accessed by Self, and Self does not need any\n-      --  lock to modify this field.\n-      --  Once the call is on a queue, the value should be\n-      --  something other than Done unless it is cancelled, and access is\n-      --  controller by the \"server\" of the queue -- i.e., the lock\n-      --  of Checked_To_Protection (Call_Target)\n-      --  if the call record is on the queue of a PO, or the lock\n-      --  of Called_Target if the call is on the queue of a task.\n-      --  See comments on type declaration for more details.\n+      --\n+      --  Protection: If the call is not on a queue, it should only be\n+      --  accessed by Self, and Self does not need any lock to modify this\n+      --  field.\n+      --\n+      --  Once the call is on a queue, the value should be something other\n+      --  than Done unless it is cancelled, and access is controller by the\n+      --  \"server\" of the queue -- i.e., the lock of Checked_To_Protection\n+      --  (Call_Target) if the call record is on the queue of a PO, or the\n+      --  lock of Called_Target if the call is on the queue of a task. See\n+      --  comments on type declaration for more details.\n \n       Uninterpreted_Data : System.Address;\n-      --  Data passed by the compiler.\n+      --  Data passed by the compiler\n \n       Exception_To_Raise : Ada.Exceptions.Exception_Id;\n       --  The exception to raise once this call has been completed without\n@@ -351,7 +349,7 @@ package System.Tasking is\n    -- Ada_Task_Control_Block (ATCB) definition --\n    ----------------------------------------------\n \n-   --  Notes on protection (synchronization) of TRTS data structures.\n+   --  Notes on protection (synchronization) of TRTS data structures\n \n    --  Any field of the TCB can be written by the activator of a task when the\n    --  task is created, since no other task can access the new task's\n@@ -360,7 +358,7 @@ package System.Tasking is\n    --  The protection for each field is described in a comment starting with\n    --  \"Protection:\".\n \n-   --  When a lock is used to protect an ATCB field, this lock is simply named.\n+   --  When a lock is used to protect an ATCB field, this lock is simply named\n \n    --  Some protection is described in terms of tasks related to the\n    --  ATCB being protected. These are:\n@@ -390,7 +388,8 @@ package System.Tasking is\n       --  Encodes some basic information about the state of a task,\n       --  including whether it has been activated, whether it is sleeping,\n       --  and whether it is terminated.\n-      --  Protection: Self.L.\n+      --\n+      --  Protection: Self.L\n \n       Parent : Task_Id;\n       --  The task on which this task depends.\n@@ -399,7 +398,8 @@ package System.Tasking is\n       Base_Priority : System.Any_Priority;\n       --  Base priority, not changed during entry calls, only changed\n       --  via dynamic priorities package.\n-      --  Protection: Only written by Self, accessed by anyone.\n+      --\n+      --  Protection: Only written by Self, accessed by anyone\n \n       Current_Priority : System.Any_Priority;\n       --  Active priority, except that the effects of protected object\n@@ -428,96 +428,104 @@ package System.Tasking is\n \n       Protected_Action_Nesting : Natural;\n       pragma Atomic (Protected_Action_Nesting);\n-      --  The dynamic level of protected action nesting for this task.\n-      --  This field is needed for checking whether potentially\n-      --  blocking operations are invoked from protected actions.\n-      --  pragma Atomic is used because it can be read/written from\n-      --  protected interrupt handlers.\n+      --  The dynamic level of protected action nesting for this task. This\n+      --  field is needed for checking whether potentially blocking operations\n+      --  are invoked from protected actions. pragma Atomic is used because it\n+      --  can be read/written from protected interrupt handlers.\n \n       Task_Image : String (1 .. 32);\n       --  Hold a string that provides a readable id for task,\n       --  built from the variable of which it is a value or component.\n \n       Task_Image_Len : Natural;\n-      --  Actual length of Task_Image.\n+      --  Actual length of Task_Image\n \n       Call : Entry_Call_Link;\n       --  The entry call that has been accepted by this task.\n-      --  Protection: Self.L. Self will modify this field\n-      --  when Self.Accepting is False, and will not need the mutex to do so.\n-      --  Once a task sets Pending_ATC_Level = 0, no other task can access\n-      --  this field.\n+      --\n+      --  Protection: Self.L. Self will modify this field when Self.Accepting\n+      --  is False, and will not need the mutex to do so. Once a task sets\n+      --  Pending_ATC_Level = 0, no other task can access this field.\n \n       LL : aliased Task_Primitives.Private_Data;\n-      --  Control block used by the underlying low-level tasking\n-      --  service (GNULLI).\n+      --  Control block used by the underlying low-level tasking service\n+      --  (GNULLI).\n+      --\n       --  Protection: This is used only by the GNULLI implementation, which\n       --  takes care of all of its synchronization.\n \n       Task_Arg : System.Address;\n       --  The argument to task procedure. Provide a handle for discriminant\n-      --  information.\n-      --  Protection: Part of the synchronization between Self and\n-      --  Activator. Activator writes it, once, before Self starts\n-      --  executing. Thereafter, Self only reads it.\n+      --  information\n+      --\n+      --  Protection: Part of the synchronization between Self and Activator.\n+      --  Activator writes it, once, before Self starts executing. Thereafter,\n+      --  Self only reads it.\n \n       Task_Entry_Point : Task_Procedure_Access;\n       --  Information needed to call the procedure containing the code for\n       --  the body of this task.\n-      --  Protection: Part of the synchronization between Self and\n-      --  Activator. Activator writes it, once, before Self starts\n-      --  executing. Self reads it, once, as part of its execution.\n+      --\n+      --  Protection: Part of the synchronization between Self and Activator.\n+      --  Activator writes it, once, before Self starts executing. Self reads\n+      --  it, once, as part of its execution.\n \n       Compiler_Data : System.Soft_Links.TSD;\n-      --  Task-specific data needed by the compiler to store\n-      --  per-task structures.\n-      --  Protection: Only accessed by Self.\n+      --  Task-specific data needed by the compiler to store per-task\n+      --  structures.\n+      --\n+      --  Protection: Only accessed by Self\n \n       All_Tasks_Link : Task_Id;\n-      --  Used to link this task to the list of all tasks in the system.\n-      --  Protection: RTS_Lock.\n+      --  Used to link this task to the list of all tasks in the system\n+      --\n+      --  Protection: RTS_Lock\n \n       Activation_Link : Task_Id;\n-      --  Used to link this task to a list of tasks to be activated.\n-      --  Protection: Only used by Activator.\n+      --  Used to link this task to a list of tasks to be activated\n+      --\n+      --  Protection: Only used by Activator\n \n       Activator : Task_Id;\n       --  The task that created this task, either by declaring it as a task\n-      --  object or by executing a task allocator.\n-      --  The value is null iff Self has completed activation.\n-      --  Protection: Set by Activator before Self is activated, and\n-      --  only read and modified by Self after that.\n+      --  object or by executing a task allocator. The value is null iff Self\n+      --  has completed activation.\n+      --\n+      --  Protection: Set by Activator before Self is activated, and only read\n+      --  and modified by Self after that.\n \n       Wait_Count : Integer;\n-      --  This count is used by a task that is waiting for other tasks.\n-      --  At all other times, the value should be zero.\n-      --  It is used differently in several different states.\n-      --  Since a task cannot be in more than one of these states at the\n-      --  same time, a single counter suffices.\n-      --  Protection: Self.L.\n+      --  This count is used by a task that is waiting for other tasks. At all\n+      --  other times, the value should be zero. It is used differently in\n+      --  several different states. Since a task cannot be in more than one of\n+      --  these states at the same time, a single counter suffices.\n+      --\n+      --  Protection: Self.L\n \n       --  Activator_Sleep\n \n       --  This is the number of tasks that this task is activating, i.e. the\n       --  children that have started activation but have not completed it.\n-      --  Protection: Self.L and Created.L. Both mutexes must be locked,\n-      --  since Self.Activation_Count and Created.State must be synchronized.\n+      --\n+      --  Protection: Self.L and Created.L. Both mutexes must be locked, since\n+      --  Self.Activation_Count and Created.State must be synchronized.\n \n       --  Master_Completion_Sleep (phase 1)\n \n-      --  This is the number dependent tasks of a master being\n-      --  completed by Self that are not activated, not terminated, and\n-      --  not waiting on a terminate alternative.\n+      --  This is the number dependent tasks of a master being completed by\n+      --  Self that are not activated, not terminated, and not waiting on a\n+      --  terminate alternative.\n \n       --  Master_Completion_2_Sleep (phase 2)\n \n-      --  This is the count of tasks dependent on a master being\n-      --  completed by Self which are waiting on a terminate alternative.\n+      --  This is the count of tasks dependent on a master being completed by\n+      --  Self which are waiting on a terminate alternative.\n \n       Elaborated : Access_Boolean;\n       --  Pointer to a flag indicating that this task's body has been\n       --  elaborated. The flag is created and managed by the\n       --  compiler-generated code.\n+      --\n       --  Protection: The field itself is only accessed by Activator. The flag\n       --  that it points to is updated by Master and read by Activator; access\n       --  is assumed to be atomic.\n@@ -539,6 +547,7 @@ package System.Tasking is\n    --  restricted GNULL implementations to allocate an ATCB (see\n    --  System.Task_Primitives.Operations.New_ATCB) that will take\n    --  significantly less memory.\n+\n    --  Note that the restricted GNARLI should only access fields that are\n    --  present in the Restricted_Ada_Task_Control_Block structure.\n \n@@ -564,7 +573,7 @@ package System.Tasking is\n    -----------------------\n \n    All_Tasks_List : Task_Id;\n-   --  Global linked list of all tasks.\n+   --  Global linked list of all tasks\n \n    ------------------------------------------\n    -- Regular (non restricted) definitions --\n@@ -577,13 +586,13 @@ package System.Tasking is\n    subtype Master_Level is Integer;\n    subtype Master_ID is Master_Level;\n \n-   --  Normally, a task starts out with internal master nesting level\n-   --  one larger than external master nesting level. It is incremented\n-   --  to one by Enter_Master, which is called in the task body only if\n-   --  the compiler thinks the task may have dependent tasks. It is set to 1\n-   --  for the environment task, the level 2 is reserved for server tasks of\n-   --  the run-time system (the so called \"independent tasks\"), and the level\n-   --  3 is for the library level tasks.\n+   --  Normally, a task starts out with internal master nesting level one\n+   --  larger than external master nesting level. It is incremented to one by\n+   --  Enter_Master, which is called in the task body only if the compiler\n+   --  thinks the task may have dependent tasks. It is set to for the\n+   --  environment task, the level 2 is reserved for server tasks of the\n+   --  run-time system (the so called \"independent tasks\"), and the level 3 is\n+   --  for the library level tasks.\n \n    Environment_Task_Level : constant Master_Level := 1;\n    Independent_Task_Level : constant Master_Level := 2;\n@@ -596,7 +605,7 @@ package System.Tasking is\n    Unspecified_Priority : constant Integer := System.Priority'First - 1;\n \n    Priority_Not_Boosted : constant Integer := System.Priority'First - 1;\n-   --  Definition of Priority actually has to come from the RTS configuration.\n+   --  Definition of Priority actually has to come from the RTS configuration\n \n    subtype Rendezvous_Priority is Integer\n      range Priority_Not_Boosted .. System.Any_Priority'Last;\n@@ -652,21 +661,19 @@ package System.Tasking is\n \n       State : Entry_Call_State;\n       pragma Atomic (State);\n-      --  Indicates part of the state of the call.\n-      --  Protection:\n-      --  If the call is not on a queue, it should\n-      --  only be accessed by Self, and Self does not need any\n-      --  lock to modify this field.\n-      --  Once the call is on a queue, the value should be\n-      --  something other than Done unless it is cancelled, and access is\n-      --  controller by the \"server\" of the queue -- i.e., the lock\n-      --  of Checked_To_Protection (Call_Target)\n-      --  if the call record is on the queue of a PO, or the lock\n-      --  of Called_Target if the call is on the queue of a task.\n-      --  See comments on type declaration for more details.\n+      --  Indicates part of the state of the call\n+      --\n+      --  Protection: If the call is not on a queue, it should only be\n+      --  accessed by Self, and Self does not need any lock to modify this\n+      --  field. Once the call is on a queue, the value should be something\n+      --  other than Done unless it is cancelled, and access is controller by\n+      --  the \"server\" of the queue -- i.e., the lock of Checked_To_Protection\n+      --  (Call_Target) if the call record is on the queue of a PO, or the\n+      --  lock of Called_Target if the call is on the queue of a task. See\n+      --  comments on type declaration for more details.\n \n       Uninterpreted_Data : System.Address;\n-      --  Data passed by the compiler.\n+      --  Data passed by the compiler\n \n       Exception_To_Raise : Ada.Exceptions.Exception_Id;\n       --  The exception to raise once this call has been completed without\n@@ -693,42 +700,39 @@ package System.Tasking is\n \n       Called_Task : Task_Id;\n       pragma Atomic (Called_Task);\n-      --  Use for task entry calls.\n-      --  The value is null if the call record is not in use.\n-      --  Conversely, unless State is Done and Onqueue is false,\n+      --  Use for task entry calls. The value is null if the call record is\n+      --  not in use. Conversely, unless State is Done and Onqueue is false,\n       --  Called_Task points to an ATCB.\n-      --  Protection:  Called_Task.L.\n+      --\n+      --  Protection:  Called_Task.L\n \n       Called_PO : System.Address;\n       pragma Atomic (Called_PO);\n-      --  Similar to Called_Task but for protected objects.\n+      --  Similar to Called_Task but for protected objects\n+      --\n       --  Note that the previous implementation tried to merge both\n       --  Called_Task and Called_PO but this ended up in many unexpected\n       --  complications (e.g having to add a magic number in the ATCB, which\n-      --  caused gdb lots of confusion) with no real gain since the Lock_Server\n-      --  implementation still need to loop around chasing for pointer changes\n-      --  even with a single pointer.\n+      --  caused gdb lots of confusion) with no real gain since the\n+      --  Lock_Server implementation still need to loop around chasing for\n+      --  pointer changes even with a single pointer.\n \n       Acceptor_Prev_Call : Entry_Call_Link;\n-      --  For task entry calls only.\n+      --  For task entry calls only\n \n       Acceptor_Prev_Priority : Rendezvous_Priority := Priority_Not_Boosted;\n-      --  For task entry calls only.\n-      --  The priority of the most recent prior call being serviced.\n-      --  For protected entry calls, this function should be performed by\n-      --  GNULLI ceiling locking.\n+      --  For task entry calls only. The priority of the most recent prior\n+      --  call being serviced. For protected entry calls, this function should\n+      --  be performed by GNULLI ceiling locking.\n \n       Cancellation_Attempted : Boolean := False;\n       pragma Atomic (Cancellation_Attempted);\n       --  Cancellation of the call has been attempted.\n-      --  If it has succeeded, State = Cancelled.\n-      --  ?????\n-      --  Consider merging this into State?\n+      --  Consider merging this into State???\n \n       Requeue_With_Abort : Boolean := False;\n       --  Temporary to tell caller whether requeue is with abort.\n-      --  ?????\n-      --  Find a better way of doing this.\n+      --  Find a better way of doing this ???\n \n       Needs_Requeue : Boolean := False;\n       --  Temporary to tell acceptor of task entry call that\n@@ -756,10 +760,10 @@ package System.Tasking is\n \n    type Direct_Index is range 0 .. Parameters.Default_Attribute_Count;\n    subtype Direct_Index_Range is Direct_Index range 1 .. Direct_Index'Last;\n-   --  Attributes with indices in this range are stored directly in\n-   --  the task control block. Such attributes must be Address-sized.\n-   --  Other attributes will be held in dynamically allocated records\n-   --  chained off of the task control block.\n+   --  Attributes with indices in this range are stored directly in the task\n+   --  control block. Such attributes must be Address-sized. Other attributes\n+   --  will be held in dynamically allocated records chained off of the task\n+   --  control block.\n \n    type Direct_Attribute_Element is mod Memory_Size;\n    pragma Atomic (Direct_Attribute_Element);\n@@ -772,86 +776,95 @@ package System.Tasking is\n    --  the usage of the direct attribute fields.\n \n    type Task_Serial_Number is mod 2 ** 64;\n-   --  Used to give each task a unique serial number.\n+   --  Used to give each task a unique serial number\n \n    type Ada_Task_Control_Block (Entry_Num : Task_Entry_Index) is record\n       Common : Common_ATCB;\n       --  The common part between various tasking implementations\n \n       Entry_Calls : Entry_Call_Array;\n-      --  An array of entry calls.\n+      --  An array of entry calls\n+      --\n       --  Protection: The elements of this array are on entry call queues\n       --  associated with protected objects or task entries, and are protected\n       --  by the protected object lock or Acceptor.L, respectively.\n \n       New_Base_Priority : System.Any_Priority;\n-      --  New value for Base_Priority (for dynamic priorities package).\n-      --  Protection: Self.L.\n+      --  New value for Base_Priority (for dynamic priorities package)\n+      --\n+      --  Protection: Self.L\n \n       Global_Task_Lock_Nesting : Natural := 0;\n       --  This is the current nesting level of calls to\n-      --  System.Tasking.Stages.Lock_Task_T.\n-      --  This allows a task to call Lock_Task_T multiple times without\n-      --  deadlocking. A task only locks All_Task_Lock when its\n-      --  All_Tasks_Nesting goes from 0 to 1, and only unlocked when it\n-      --  goes from 1 to 0.\n-      --  Protection: Only accessed by Self.\n+      --  System.Tasking.Stages.Lock_Task_T. This allows a task to call\n+      --  Lock_Task_T multiple times without deadlocking. A task only locks\n+      --  All_Task_Lock when its All_Tasks_Nesting goes from 0 to 1, and only\n+      --  unlocked when it goes from 1 to 0.\n+      --\n+      --  Protection: Only accessed by Self\n \n       Open_Accepts : Accept_List_Access;\n       --  This points to the Open_Accepts array of accept alternatives passed\n-      --  to the RTS by the compiler-generated code to Selective_Wait.\n-      --  It is non-null iff this task is ready to accept an entry call.\n-      --  Protection: Self.L.\n+      --  to the RTS by the compiler-generated code to Selective_Wait. It is\n+      --  non-null iff this task is ready to accept an entry call.\n+      --\n+      --  Protection: Self.L\n \n       Chosen_Index : Select_Index;\n       --  The index in Open_Accepts of the entry call accepted by a selective\n       --  wait executed by this task.\n-      --  Protection: Written by both Self and Caller. Usually protected\n-      --  by Self.L. However, once the selection is known to have been\n-      --  written it can be accessed without protection. This happens\n-      --  after Self has updated it itself using information from a suspended\n-      --  Caller, or after Caller has updated it and awakened Self.\n+      --\n+      --  Protection: Written by both Self and Caller. Usually protected by\n+      --  Self.L. However, once the selection is known to have been written it\n+      --  can be accessed without protection. This happens after Self has\n+      --  updated it itself using information from a suspended Caller, or\n+      --  after Caller has updated it and awakened Self.\n \n       Master_of_Task : Master_Level;\n       --  The task executing the master of this task, and the ID of this task's\n       --  master (unique only among masters currently active within Parent).\n-      --  Protection: Set by Activator before Self is activated, and\n-      --  read after Self is activated.\n+      --\n+      --  Protection: Set by Activator before Self is activated, and read\n+      --  after Self is activated.\n \n       Master_Within : Master_Level;\n       --  The ID of the master currently executing within this task; that is,\n       --  the most deeply nested currently active master.\n+      --\n       --  Protection: Only written by Self, and only read by Self or by\n-      --  dependents when Self is attempting to exit a master. Since Self\n-      --  will not write this field until the master is complete, the\n+      --  dependents when Self is attempting to exit a master. Since Self will\n+      --  not write this field until the master is complete, the\n       --  synchronization should be adequate to prevent races.\n \n       Alive_Count : Integer := 0;\n       --  Number of tasks directly dependent on this task (including itself)\n       --  that are still \"alive\", i.e. not terminated.\n-      --  Protection: Self.L.\n+      --\n+      --  Protection: Self.L\n \n       Awake_Count : Integer := 0;\n       --  Number of tasks directly dependent on this task (including itself)\n       --  still \"awake\", i.e., are not terminated and not waiting on a\n       --  terminate alternative.\n+      --\n       --  Invariant: Awake_Count <= Alive_Count\n-      --  Protection: Self.L.\n \n-      --  beginning of flags\n+      --  Protection: Self.L\n+\n+      --  Beginning of flags\n \n       Aborting : Boolean := False;\n       pragma Atomic (Aborting);\n       --  Self is in the process of aborting. While set, prevents multiple\n-      --  abortion signals from being sent by different aborter while abortion\n+      --  abort signals from being sent by different aborter while abort\n       --  is acted upon. This is essential since an aborter which calls\n       --  Abort_To_Level could set the Pending_ATC_Level to yet a lower level\n       --  (than the current level), may be preempted and would send the\n-      --  abortion signal when resuming execution. At this point, the abortee\n-      --  may have completed abortion to the proper level such that the\n-      --  signal (and resulting abortion exception) are not handled any more.\n+      --  abort signal when resuming execution. At this point, the abortee\n+      --  may have completed abort to the proper level such that the\n+      --  signal (and resulting abort exception) are not handled any more.\n       --  In other words, the flag prevents a race between multiple aborters\n-      --  and the abortee.\n+      --\n       --  Protection: protected by atomic access.\n \n       ATC_Hack : Boolean := False;\n@@ -863,17 +876,17 @@ package System.Tasking is\n       --  handler itself.\n \n       Callable : Boolean := True;\n-      --  It is OK to call entries of this task.\n+      --  It is OK to call entries of this task\n \n       Dependents_Aborted : Boolean := False;\n-      --  This is set to True by whichever task takes responsibility\n-      --  for aborting the dependents of this task.\n-      --  Protection: Self.L.\n+      --  This is set to True by whichever task takes responsibility for\n+      --  aborting the dependents of this task.\n+      --\n+      --  Protection: Self.L\n \n       Interrupt_Entry : Boolean := False;\n-      --  Indicates if one or more Interrupt Entries are attached to\n-      --  the task. This flag is needed for cleaning up the Interrupt\n-      --  Entry bindings.\n+      --  Indicates if one or more Interrupt Entries are attached to the task.\n+      --  This flag is needed for cleaning up the Interrupt Entry bindings.\n \n       Pending_Action : Boolean := False;\n       --  Unified flag indicating some action needs to be take when abort\n@@ -884,65 +897,68 @@ package System.Tasking is\n       --    (Abortable field may have changed and the Wait_Until_Abortable\n       --     has to recheck the abortable status of the call.)\n       --  . Exception_To_Raise is non-null\n-      --  Protection: Self.L.\n-      --  This should never be reset back to False outside of the\n-      --  procedure Do_Pending_Action, which is called by Undefer_Abort.\n-      --  It should only be set to True by Set_Priority and Abort_To_Level.\n+      --\n+      --  Protection: Self.L\n+      --\n+      --  This should never be reset back to False outside of the procedure\n+      --  Do_Pending_Action, which is called by Undefer_Abort. It should only\n+      --  be set to True by Set_Priority and Abort_To_Level.\n \n       Pending_Priority_Change : Boolean := False;\n       --  Flag to indicate pending priority change (for dynamic priorities\n-      --  package). The base priority is updated on the next abortion\n+      --  package). The base priority is updated on the next abort\n       --  completion point (aka. synchronization point).\n-      --  Protection: Self.L.\n+      --\n+      --  Protection: Self.L\n \n       Terminate_Alternative : Boolean := False;\n-      --  Task is accepting Select with Terminate Alternative.\n-      --  Protection: Self.L.\n+      --  Task is accepting Select with Terminate Alternative\n+      --\n+      --  Protection: Self.L\n \n-      --  end of flags\n+      --  End of flags\n \n-      --  beginning of counts\n+      --  Beginning of counts\n \n       ATC_Nesting_Level : ATC_Level := 1;\n       --  The dynamic level of ATC nesting (currently executing nested\n       --  asynchronous select statements) in this task.\n-      --  Protection:  Self_ID.L.\n-      --  Only Self reads or updates this field.\n+\n+      --  Protection: Self_ID.L. Only Self reads or updates this field.\n       --  Decrementing it deallocates an Entry_Calls component, and care must\n-      --  be taken that all references to that component are eliminated\n-      --  before doing the decrement. This in turn will require locking\n-      --  a protected object (for a protected entry call) or the Acceptor's\n-      --  lock (for a task entry call).\n-      --  No other task should attempt to read or modify this value.\n+      --  be taken that all references to that component are eliminated before\n+      --  doing the decrement. This in turn will require locking a protected\n+      --  object (for a protected entry call) or the Acceptor's lock (for a\n+      --  task entry call). No other task should attempt to read or modify\n+      --  this value.\n \n       Deferral_Level : Natural := 1;\n       --  This is the number of times that Defer_Abortion has been called by\n-      --  this task without a matching Undefer_Abortion call. Abortion is\n-      --  only allowed when this zero.\n-      --  It is initially 1, to protect the task at startup.\n-      --  Protection: Only updated by Self; access assumed to be atomic.\n+      --  this task without a matching Undefer_Abortion call. Abortion is only\n+      --  allowed when this zero. It is initially 1, to protect the task at\n+      --  startup.\n+\n+      --  Protection: Only updated by Self; access assumed to be atomic\n \n       Pending_ATC_Level : ATC_Level_Base := ATC_Level_Infinity;\n-      --  The ATC level to which this task is currently being aborted.\n-      --  If the value is zero, the entire task has \"completed\".\n-      --  That may be via abort, exception propagation, or normal exit.\n-      --  If the value is ATC_Level_Infinity, the task is not being\n-      --  aborted to any level.\n-      --  If the value is positive, the task has not completed.\n-      --  This should ONLY be modified by\n-      --  Abort_To_Level and Exit_One_ATC_Level.\n-      --  Protection: Self.L.\n+      --  The ATC level to which this task is currently being aborted. If the\n+      --  value is zero, the entire task has \"completed\". That may be via\n+      --  abort, exception propagation, or normal exit. If the value is\n+      --  ATC_Level_Infinity, the task is not being aborted to any level. If\n+      --  the value is positive, the task has not completed. This should ONLY\n+      --  be modified by Abort_To_Level and Exit_One_ATC_Level.\n+      --\n+      --  Protection: Self.L\n \n       Serial_Number : Task_Serial_Number;\n-      --  A growing number to provide some way to check locking\n-      --  rules/ordering.\n+      --  A growing number to provide some way to check locking  rules/ordering\n \n       Known_Tasks_Index : Integer := -1;\n-      --  Index in the System.Tasking.Debug.Known_Tasks array.\n+      --  Index in the System.Tasking.Debug.Known_Tasks array\n \n       User_State : Long_Integer := 0;\n-      --  User-writeable location, for use in debugging tasks;\n-      --  also provides a simple task specific data.\n+      --  User-writeable location, for use in debugging tasks; also provides a\n+      --  simple task specific data.\n \n       Direct_Attributes : Direct_Attribute_Array;\n       --  For task attributes that have same size as Address\n@@ -951,11 +967,12 @@ package System.Tasking is\n       --  Bit I is 1 iff Direct_Attributes (I) is defined\n \n       Indirect_Attributes : Access_Address;\n-      --  A pointer to chain of records for other attributes that\n-      --  are not address-sized, including all tagged types.\n+      --  A pointer to chain of records for other attributes that are not\n+      --  address-sized, including all tagged types.\n \n       Entry_Queues : Task_Entry_Queue_Array (1 .. Entry_Num);\n-      --  An array of task entry queues.\n+      --  An array of task entry queues\n+      --\n       --  Protection: Self.L. Once a task has set Self.Stage to Completing, it\n       --  has exclusive access to this field.\n    end record;\n@@ -975,18 +992,18 @@ package System.Tasking is\n       Stack_Size       : System.Parameters.Size_Type;\n       T                : Task_Id;\n       Success          : out Boolean);\n-   --  Initialize fields of a TCB and link into global TCB structures\n-   --  Call this only with abort deferred and holding RTS_Lock.\n-   --  Need more documentation, mention T, and describe Success ???\n+   --  Initialize fields of a TCB and link into global TCB structures Call\n+   --  this only with abort deferred and holding RTS_Lock. Need more\n+   --  documentation, mention T, and describe Success ???\n \n private\n    Null_Task : constant Task_Id := null;\n \n    GL_Detect_Blocking : Integer;\n    pragma Import (C, GL_Detect_Blocking, \"__gl_detect_blocking\");\n-   --  Global variable exported by the binder generated file. A value\n-   --  equal to 1 indicates that pragma Detect_Blocking is active,\n-   --  while 0 is used for the pragma not being present.\n+   --  Global variable exported by the binder generated file. A value equal to\n+   --  1 indicates that pragma Detect_Blocking is active, while 0 is used for\n+   --  the pragma not being present.\n \n    Detect_Blocking : constant Boolean := GL_Detect_Blocking = 1;\n "}, {"sha": "6bdd8d27738173ebebf08f2a201a923f1f8c92c9", "filename": "gcc/ada/s-tasren.adb", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tasren.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tasren.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasren.adb?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -154,7 +154,7 @@ package body System.Tasking.Rendezvous is\n \n    procedure Boost_Priority (Call : Entry_Call_Link; Acceptor : Task_Id);\n    pragma Inline (Boost_Priority);\n-   --  Call this only with abort deferred and holding lock of Acceptor.\n+   --  Call this only with abort deferred and holding lock of Acceptor\n \n    procedure Call_Synchronous\n      (Acceptor              : Task_Id;\n@@ -255,7 +255,7 @@ package body System.Tasking.Rendezvous is\n             Uninterpreted_Data :=\n               Caller.Entry_Calls (Caller.ATC_Nesting_Level).Uninterpreted_Data;\n          else\n-            --  Case of an aborted task.\n+            --  Case of an aborted task\n \n             Uninterpreted_Data := System.Null_Address;\n          end if;\n@@ -701,7 +701,7 @@ package body System.Tasking.Rendezvous is\n               (Self_Id, Entry_Call.Acceptor_Prev_Priority);\n \n          else\n-            --  The call does not need to be requeued.\n+            --  The call does not need to be requeued\n \n             Self_Id.Common.Call := Entry_Call.Acceptor_Prev_Call;\n             Entry_Call.Exception_To_Raise := Ex;\n@@ -712,7 +712,7 @@ package body System.Tasking.Rendezvous is\n \n             STPO.Write_Lock (Caller);\n \n-            --  Done with Caller locked to make sure that Wakeup is not lost.\n+            --  Done with Caller locked to make sure that Wakeup is not lost\n \n             if Ex /= Ada.Exceptions.Null_Id then\n                Transfer_Occurrence\n@@ -844,7 +844,7 @@ package body System.Tasking.Rendezvous is\n       Queuing.Select_Task_Entry_Call\n         (Self_Id, Open_Accepts, Entry_Call, Selection, Open_Alternative);\n \n-      --  Determine the kind and disposition of the select.\n+      --  Determine the kind and disposition of the select\n \n       Treatment := Default_Treatment (Select_Mode);\n       Self_Id.Chosen_Index := No_Rendezvous;\n@@ -865,7 +865,7 @@ package body System.Tasking.Rendezvous is\n          end if;\n       end if;\n \n-      --  Handle the select according to the disposition selected above.\n+      --  Handle the select according to the disposition selected above\n \n       case Treatment is\n          when Accept_Alternative_Selected =>\n@@ -882,7 +882,8 @@ package body System.Tasking.Rendezvous is\n             STPO.Unlock (Self_Id);\n \n          when Accept_Alternative_Completed =>\n-            --  Accept body is null, so rendezvous is over immediately.\n+\n+            --  Accept body is null, so rendezvous is over immediately\n \n             if Parameters.Runtime_Traces then\n                Send_Trace_Info (M_RDV_Complete, Entry_Call.Self);\n@@ -896,7 +897,8 @@ package body System.Tasking.Rendezvous is\n             STPO.Unlock (Caller);\n \n          when Accept_Alternative_Open =>\n-            --  Wait for caller.\n+\n+            --  Wait for caller\n \n             Self_Id.Open_Accepts := Open_Accepts;\n             pragma Debug\n@@ -913,9 +915,9 @@ package body System.Tasking.Rendezvous is\n \n             --  Self_Id.Common.Call should already be updated by the Caller if\n             --  not aborted. It might also be ready to do rendezvous even if\n-            --  this wakes up due to an abortion.\n-            --  Therefore, if the call is not empty we need to do the\n-            --  rendezvous if the accept body is not Null_Body.\n+            --  this wakes up due to an abort. Therefore, if the call is not\n+            --  empty we need to do the rendezvous if the accept body is not\n+            --  Null_Body.\n \n             --  Aren't the first two conditions below redundant???\n \n@@ -949,7 +951,7 @@ package body System.Tasking.Rendezvous is\n             Self_Id.Open_Accepts := Open_Accepts;\n             Self_Id.Common.State := Acceptor_Sleep;\n \n-            --  Notify ancestors that this task is on a terminate alternative.\n+            --  Notify ancestors that this task is on a terminate alternative\n \n             STPO.Unlock (Self_Id);\n             Utilities.Make_Passive (Self_Id, Task_Completed => False);\n@@ -1154,7 +1156,7 @@ package body System.Tasking.Rendezvous is\n \n       STPO.Write_Lock (Acceptor);\n \n-      --  If the acceptor is not callable, abort the call and return False.\n+      --  If the acceptor is not callable, abort the call and return False\n \n       if not Acceptor.Callable then\n          STPO.Unlock (Acceptor);\n@@ -1176,35 +1178,35 @@ package body System.Tasking.Rendezvous is\n          return False;\n       end if;\n \n-      --  Try to serve the call immediately.\n+      --  Try to serve the call immediately\n \n       if Acceptor.Open_Accepts /= null then\n          for J in Acceptor.Open_Accepts'Range loop\n             if Entry_Call.E = Entry_Index (Acceptor.Open_Accepts (J).S) then\n \n-               --  Commit acceptor to rendezvous with us.\n+               --  Commit acceptor to rendezvous with us\n \n                Acceptor.Chosen_Index := J;\n                Null_Body := Acceptor.Open_Accepts (J).Null_Body;\n                Acceptor.Open_Accepts := null;\n \n-               --  Prevent abort while call is being served.\n+               --  Prevent abort while call is being served\n \n                if Entry_Call.State = Now_Abortable then\n                   Entry_Call.State := Was_Abortable;\n                end if;\n \n                if Acceptor.Terminate_Alternative then\n-                  --  Cancel terminate alternative.\n-                  --  See matching code in Selective_Wait and\n-                  --  Vulnerable_Complete_Master.\n+\n+                  --  Cancel terminate alternative. See matching code in\n+                  --  Selective_Wait and Vulnerable_Complete_Master.\n \n                   Acceptor.Terminate_Alternative := False;\n                   Acceptor.Awake_Count := Acceptor.Awake_Count + 1;\n \n                   if Acceptor.Awake_Count = 1 then\n \n-                     --  Notify parent that acceptor is awake.\n+                     --  Notify parent that acceptor is awake\n \n                      pragma Assert (Parent.Awake_Count > 0);\n \n@@ -1220,7 +1222,8 @@ package body System.Tasking.Rendezvous is\n                end if;\n \n                if Null_Body then\n-                  --  Rendezvous is over immediately.\n+\n+                  --  Rendezvous is over immediately\n \n                   STPO.Wakeup (Acceptor, Acceptor_Sleep);\n                   STPO.Unlock (Acceptor);\n@@ -1237,8 +1240,8 @@ package body System.Tasking.Rendezvous is\n                else\n                   Setup_For_Rendezvous_With_Body (Entry_Call, Acceptor);\n \n-                  --  For terminate_alternative, acceptor may not be\n-                  --  asleep yet, so we skip the wakeup\n+                  --  For terminate_alternative, acceptor may not be asleep\n+                  --  yet, so we skip the wakeup\n \n                   if Acceptor.Common.State /= Runnable then\n                      STPO.Wakeup (Acceptor, Acceptor_Sleep);\n@@ -1255,7 +1258,7 @@ package body System.Tasking.Rendezvous is\n             end if;\n          end loop;\n \n-         --  The acceptor is accepting, but not this entry.\n+         --  The acceptor is accepting, but not this entry\n       end if;\n \n       --  If the acceptor was ready to accept this call,\n@@ -1360,11 +1363,11 @@ package body System.Tasking.Rendezvous is\n       else\n          --  This is an asynchronous call\n \n-         --  Abortion must already be deferred by the compiler-generated\n-         --  code.  Without this, an abortion that occurs between the time\n-         --  that this call is made and the time that the abortable part's\n-         --  cleanup handler is set up might miss the cleanup handler and\n-         --  leave the call pending.\n+         --  Abort must already be deferred by the compiler-generated code.\n+         --  Without this, an abort that occurs between the time that this\n+         --  call is made and the time that the abortable part's cleanup\n+         --  handler is set up might miss the cleanup handler and leave the\n+         --  call pending.\n \n          Self_Id.ATC_Nesting_Level := Self_Id.ATC_Nesting_Level + 1;\n          pragma Debug\n@@ -1421,7 +1424,7 @@ package body System.Tasking.Rendezvous is\n             Unlock_RTS;\n          end if;\n \n-         --  Note: following assignment needs to be atomic.\n+         --  Note: following assignment needs to be atomic\n \n          Rendezvous_Successful := Entry_Call.State = Done;\n       end if;\n@@ -1506,7 +1509,7 @@ package body System.Tasking.Rendezvous is\n       Queuing.Select_Task_Entry_Call\n         (Self_Id, Open_Accepts, Entry_Call, Selection, Open_Alternative);\n \n-      --  Determine the kind and disposition of the select.\n+      --  Determine the kind and disposition of the select\n \n       Treatment := Default_Treatment (Select_Mode);\n       Self_Id.Chosen_Index := No_Rendezvous;\n@@ -1528,7 +1531,7 @@ package body System.Tasking.Rendezvous is\n          end if;\n       end if;\n \n-      --  Handle the select according to the disposition selected above.\n+      --  Handle the select according to the disposition selected above\n \n       case Treatment is\n          when Accept_Alternative_Selected =>\n@@ -1555,17 +1558,17 @@ package body System.Tasking.Rendezvous is\n             STPO.Unlock (Caller);\n \n          when Accept_Alternative_Open =>\n-            --  Wait for caller.\n+\n+            --  Wait for caller\n \n             Self_Id.Open_Accepts := Open_Accepts;\n \n             --  Wait for a normal call and a pending action until the\n             --  Wakeup_Time is reached.\n \n             --  Try to remove calls to Sleep in the loop below by letting the\n-            --  caller a chance of getting ready immediately, using Unlock &\n-            --  Yield.\n-            --  See similar action in Wait_For_Completion & Wait_For_Call.\n+            --  caller a chance of getting ready immediately, using Unlock\n+            --  Yield. See similar action in Wait_For_Completion/Wait_For_Call.\n \n             if Single_Lock then\n                Unlock_RTS;\n@@ -1622,9 +1625,9 @@ package body System.Tasking.Rendezvous is\n \n             --  Self_Id.Common.Call should already be updated by the Caller if\n             --  not aborted. It might also be ready to do rendezvous even if\n-            --  this wakes up due to an abortion.\n-            --  Therefore, if the call is not empty we need to do the\n-            --  rendezvous if the accept body is not Null_Body.\n+            --  this wakes up due to an abort. Therefore, if the call is not\n+            --  empty we need to do the rendezvous if the accept body is not\n+            --  Null_Body.\n \n             if Self_Id.Chosen_Index /= No_Rendezvous\n               and then Self_Id.Common.Call /= null\n@@ -1648,7 +1651,7 @@ package body System.Tasking.Rendezvous is\n             --  for several reasons:\n             --  1) Delay is expired\n             --  2) Pending_Action needs to be checked\n-            --     (Abortion, Priority change)\n+            --     (Abort, Priority change)\n             --  3) Spurious wakeup\n \n             Self_Id.Open_Accepts := null;\n@@ -1753,7 +1756,7 @@ package body System.Tasking.Rendezvous is\n       Entry_Call.Called_PO := Null_Address;\n       Entry_Call.Exception_To_Raise := Ada.Exceptions.Null_Id;\n \n-      --  Note: the caller will undefer abortion on return (see WARNING above)\n+      --  Note: the caller will undefer abort on return (see WARNING above)\n \n       if Single_Lock then\n          Lock_RTS;\n@@ -1820,7 +1823,7 @@ package body System.Tasking.Rendezvous is\n          Write_Lock (Self_Id);\n       end if;\n \n-      --  Check if this task has been aborted while the lock was released.\n+      --  Check if this task has been aborted while the lock was released\n \n       if Self_Id.Pending_ATC_Level < Self_Id.ATC_Nesting_Level then\n          Self_Id.Open_Accepts := null;"}, {"sha": "2a47c70cdf91e9d2bcd7e75d00c763c751a225c6", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -36,24 +36,24 @@ pragma Polling (Off);\n --  tasking operations. It causes infinite loops and other problems.\n \n with Ada.Exceptions;\n---  used for Raise_Exception\n+--  Used for Raise_Exception\n \n with System.Tasking.Debug;\n---  used for enabling tasking facilities with gdb\n+--  Used for enabling tasking facilities with gdb\n \n with System.Address_Image;\n---  used for the function itself.\n+--  Used for the function itself\n \n with System.Parameters;\n---  used for Size_Type\n+--  Used for Size_Type\n --           Single_Lock\n --           Runtime_Traces\n \n with System.Task_Info;\n---  used for Task_Info_Type\n+--  Used for Task_Info_Type\n \n with System.Task_Primitives.Operations;\n---  used for Finalize_Lock\n+--  Used for Finalize_Lock\n --           Enter_Task\n --           Write_Lock\n --           Unlock\n@@ -64,11 +64,11 @@ with System.Task_Primitives.Operations;\n --           New_ATCB\n \n with System.Soft_Links;\n---  These are procedure pointers to non-tasking routines that use\n---  task specific data. In the absence of tasking, these routines\n---  refer to global data. In the presense of tasking, they must be\n---  replaced with pointers to task-specific versions.\n---  Also used for Create_TSD, Destroy_TSD, Get_Current_Excep\n+--  These are procedure pointers to non-tasking routines that use task\n+--  specific data. In the absence of tasking, these routines refer to global\n+--  data. In the presense of tasking, they must be replaced with pointers to\n+--  task-specific versions. Also used for Create_TSD, Destroy_TSD,\n+--  Get_Current_Excep\n \n with System.Tasking.Initialization;\n --  Used for Remove_From_All_Tasks_List\n@@ -79,7 +79,7 @@ with System.Tasking.Initialization;\n --           Initialize_Attributes_Link\n \n pragma Elaborate_All (System.Tasking.Initialization);\n---  This insures that tasking is initialized if any tasks are created.\n+--  This insures that tasking is initialized if any tasks are created\n \n with System.Tasking.Utilities;\n --  Used for Make_Passive\n@@ -98,22 +98,22 @@ with System.Finalization_Implementation;\n --  Used for System.Finalization_Implementation.Finalize_Global_List\n \n with System.Secondary_Stack;\n---  used for SS_Init\n+--  Used for SS_Init\n \n with System.Storage_Elements;\n---  used for Storage_Array\n+--  Used for Storage_Array\n \n with System.Restrictions;\n---  used for Abort_Allowed\n+--  Used for Abort_Allowed\n \n with System.Standard_Library;\n---  used for Exception_Trace\n+--  Used for Exception_Trace\n \n with System.Traces.Tasking;\n---  used for Send_Trace_Info\n+--  Used for Send_Trace_Info\n \n with Unchecked_Deallocation;\n---  To recover from failure of ATCB initialization.\n+--  To recover from failure of ATCB initialization\n \n package body System.Tasking.Stages is\n \n@@ -787,11 +787,11 @@ package body System.Tasking.Stages is\n \n       Self_ID.Callable := False;\n \n-      --  Exit level 2 master, for normal tasks in library-level packages.\n+      --  Exit level 2 master, for normal tasks in library-level packages\n \n       Complete_Master;\n \n-      --  Force termination of \"independent\" library-level server tasks.\n+      --  Force termination of \"independent\" library-level server tasks\n \n       Lock_RTS;\n \n@@ -977,7 +977,7 @@ package body System.Tasking.Stages is\n          --  clean ups associated with the exception handler that need to\n          --  access task specific data.\n \n-         --  Defer abortion so that this task can't be aborted while exiting\n+         --  Defer abort so that this task can't be aborted while exiting\n \n          when Standard'Abort_Signal =>\n             Initialization.Defer_Abort_Nestable (Self_ID);\n@@ -1209,7 +1209,7 @@ package body System.Tasking.Stages is\n \n       --  The activator raises a Tasking_Error if any task it is activating\n       --  is completed before the activation is done. However, if the reason\n-      --  for the task completion is an abortion, we do not raise an exception.\n+      --  for the task completion is an abort, we do not raise an exception.\n       --  See RM 9.2(5).\n \n       if not Self_ID.Callable and then Self_ID.Pending_ATC_Level /= 0 then\n@@ -1392,7 +1392,7 @@ package body System.Tasking.Stages is\n \n          pragma Assert (Self_ID.Common.Wait_Count = 0);\n \n-         --  Force any remaining dependents to terminate, by aborting them.\n+         --  Force any remaining dependents to terminate by aborting them\n \n          if not Single_Lock then\n             Lock_RTS;\n@@ -1461,8 +1461,8 @@ package body System.Tasking.Stages is\n          Unlock (Self_ID);\n       end if;\n \n-      --  We don't wake up for abortion here. We are already terminating\n-      --  just as fast as we can, so there is no point.\n+      --  We don't wake up for abort here. We are already terminating just as\n+      --  fast as we can, so there is no point.\n \n       --  Remove terminated tasks from the list of Self_ID's dependents, but\n       --  don't free their ATCBs yet, because of lock order restrictions,\n@@ -1687,7 +1687,7 @@ package body System.Tasking.Stages is\n --  Package elaboration code\n \n begin\n-   --  Establish the Adafinal softlink.\n+   --  Establish the Adafinal softlink\n \n    --  This is not done inside the central RTS initialization routine\n    --  to avoid with-ing this package from System.Tasking.Initialization."}, {"sha": "c8e02329a0b8c3cc9b08c7a6a81d1f69d47bf502", "filename": "gcc/ada/s-tassta.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tassta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tassta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -121,9 +121,9 @@ package System.Tasking.Stages is\n    --   activate_tasks (_chain'unchecked_access);\n \n    procedure Abort_Tasks (Tasks : Task_List);\n-   --  Compiler interface only. Do not call from within the RTS.\n-   --  Initiate abortion, however, the actual abortion is done by abortee by\n-   --  means of Abort_Handler and Abort_Undefer\n+   --  Compiler interface only. Do not call from within the RTS. Initiate\n+   --  abort, however, the actual abort is done by abortee by means of\n+   --  Abort_Handler and Abort_Undefer\n    --\n    --  source code:\n    --     Abort T1, T2;"}, {"sha": "685bc08cd81dafbc5e935af85cb543d082b00ee4", "filename": "gcc/ada/s-tasuti.ads", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tasuti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tasuti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasuti.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -72,9 +72,9 @@ package System.Tasking.Utilities is\n    --  the environment task (because every independent task depends on it),\n    --  this counter is protected by the environment task's lock.\n \n-   ------------------------------------\n-   -- Task Abortion related routines --\n-   ------------------------------------\n+   ---------------------------------\n+   -- Task Abort Related Routines --\n+   ---------------------------------\n \n    procedure Cancel_Queued_Entry_Calls (T : Task_Id);\n    --  Cancel any entry calls queued on target task.\n@@ -93,13 +93,13 @@ package System.Tasking.Utilities is\n    --    (3) always aborts whole task\n \n    procedure Abort_Tasks (Tasks : Task_List);\n-   --  Abort_Tasks is called to initiate abortion, however, the actual\n-   --  abortion is done by abortee by means of Abort_Handler\n+   --  Abort_Tasks is called to initiate abort, however, the actual\n+   --  aborti is done by aborted task by means of Abort_Handler\n \n    procedure Make_Passive (Self_ID : Task_Id; Task_Completed : Boolean);\n-   --  Update counts to indicate current task is either terminated\n-   --  or accepting on a terminate alternative.\n-   --  Call holding no locks except Global_Task_Lock when calling from\n-   --  Terminate_Task, and RTS_Lock when Single_Lock is True.\n+   --  Update counts to indicate current task is either terminated or\n+   --  accepting on a terminate alternative. Call holding no locks except\n+   --  Global_Task_Lock when calling from Terminate_Task, and RTS_Lock when\n+   --  Single_Lock is True.\n \n end System.Tasking.Utilities;"}, {"sha": "7031a625ce0e95f1d922817a13a6acdd58578db7", "filename": "gcc/ada/s-tataat.ads", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tataat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tataat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tataat.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -7,7 +7,7 @@\n --                                  S p e c                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---             Copyright (C) 1995-2004, Ada Core Technologies               --\n+--             Copyright (C) 1995-2005, Ada Core Technologies               --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,13 +32,13 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package provides support for the body of Ada.Task_Attributes.\n+--  This package provides support for the body of Ada.Task_Attributes\n \n with Ada.Finalization;\n---  used for Limited_Controlled\n+--  Used for Limited_Controlled\n \n with System.Storage_Elements;\n---  used for Integer_Address\n+--  Used for Integer_Address\n \n package System.Tasking.Task_Attributes is\n \n@@ -52,8 +52,8 @@ package System.Tasking.Task_Attributes is\n \n    function To_Access_Node is new Unchecked_Conversion\n      (Access_Address, Access_Node);\n-   --  Used to fetch pointer to indirect attribute list. Declaration is\n-   --  in spec to avoid any problems with aliasing assumptions.\n+   --  Used to fetch pointer to indirect attribute list. Declaration is in\n+   --  spec to avoid any problems with aliasing assumptions.\n \n    type Dummy_Wrapper;\n    type Access_Dummy_Wrapper is access all Dummy_Wrapper;\n@@ -67,7 +67,7 @@ package System.Tasking.Task_Attributes is\n    --  of type Wrapper, no Dummy_Wrapper objects are ever created.\n \n    type Deallocator is access procedure (P : in out Access_Node);\n-   --  Called to deallocate an Wrapper. P is a pointer to a Node within.\n+   --  Called to deallocate an Wrapper. P is a pointer to a Node within\n \n    type Instance;\n \n@@ -78,11 +78,11 @@ package System.Tasking.Task_Attributes is\n       Initial_Value : aliased System.Storage_Elements.Integer_Address;\n \n       Index : Direct_Index;\n-      --  The index of the TCB location used by this instantiation,\n-      --  if it is stored in the TCB, otherwise zero.\n+      --  The index of the TCB location used by this instantiation, if it is\n+      --  stored in the TCB, otherwise zero.\n \n       Next : Access_Instance;\n-      --  Next instance in All_Attributes list.\n+      --  Next instance in All_Attributes list\n    end record;\n \n    procedure Finalize (X : in out Instance);\n@@ -93,12 +93,11 @@ package System.Tasking.Task_Attributes is\n       Next     : Access_Node;\n    end record;\n \n-   --  The following type is a stand-in for the actual\n-   --  wrapper type, which is different for each instantiation\n-   --  of Ada.Task_Attributes.\n+   --  The following type is a stand-in for the actual wrapper type, which is\n+   --  different for each instantiation of Ada.Task_Attributes.\n \n    type Dummy_Wrapper is record\n-      Noed : aliased Node;\n+      Dummy_Node : aliased Node;\n \n       Value : aliased Attribute;\n       --  The generic formal type, may be controlled\n@@ -110,23 +109,23 @@ package System.Tasking.Task_Attributes is\n    --  Ensure that the designated object is always strictly enough aligned.\n \n    In_Use : Direct_Index_Vector := 0;\n-   --  is True for direct indices that are already used.\n+   --  Set True for direct indices that are already used (True??? type???)\n \n    All_Attributes : Access_Instance;\n-   --  A linked list of all indirectly access attributes,\n-   --  which includes all those that require finalization.\n+   --  A linked list of all indirectly access attributes, which includes all\n+   --  those that require finalization.\n \n    procedure Initialize_Attributes (T : Task_Id);\n-   --  Initialize all attributes created via Ada.Task_Attributes for T.\n-   --  This must be called by the creator of the task, inside Create_Task,\n-   --  via soft-link Initialize_Attributes_Link. On entry, abortion must\n-   --  be deferred and the caller must hold no locks\n+   --  Initialize all attributes created via Ada.Task_Attributes for T. This\n+   --  must be called by the creator of the task, inside Create_Task, via\n+   --  soft-link Initialize_Attributes_Link. On entry, abort must be deferred\n+   --  and the caller must hold no locks\n \n    procedure Finalize_Attributes (T : Task_Id);\n    --  Finalize all attributes created via Ada.Task_Attributes for T.\n    --  This is to be called by the task after it is marked as terminated\n    --  (and before it actually dies), inside Vulnerable_Free_Task, via the\n-   --  soft-link Finalize_Attributes_Link. On entry, abortion must be deferred\n+   --  soft-link Finalize_Attributes_Link. On entry, abort must be deferred\n    --  and T.L must be write-locked.\n \n end System.Tasking.Task_Attributes;"}, {"sha": "650f756ff7848011e289fa91c9851b084eee5ca4", "filename": "gcc/ada/s-tpoben.adb", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tpoben.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tpoben.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpoben.adb?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1998-2004, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1998-2005, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,39 +31,40 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains all the simple primitives related to\n---  Protected_Objects with entries (i.e init, lock, unlock).\n+--  This package contains all the simple primitives related to protected\n+--  objects with entries (i.e init, lock, unlock).\n \n --  The handling of protected objects with no entries is done in\n --  System.Tasking.Protected_Objects, the complex routines for protected\n --  objects with entries in System.Tasking.Protected_Objects.Operations.\n+\n --  The split between Entries and Operations is needed to break circular\n --  dependencies inside the run time.\n \n---  Note: the compiler generates direct calls to this interface, via Rtsfind.\n+--  Note: the compiler generates direct calls to this interface, via Rtsfind\n \n with Ada.Exceptions;\n---  used for Exception_Occurrence_Access\n+--  Used for Exception_Occurrence_Access\n --           Raise_Exception\n \n with System.Task_Primitives.Operations;\n---  used for Initialize_Lock\n+--  Used for Initialize_Lock\n --           Write_Lock\n --           Unlock\n --           Get_Priority\n --           Wakeup\n \n with System.Tasking.Initialization;\n---  used for Defer_Abort,\n+--  Used for Defer_Abort,\n --           Undefer_Abort,\n --           Change_Base_Priority\n \n pragma Elaborate_All (System.Tasking.Initialization);\n---  this insures that tasking is initialized if any protected objects are\n+--  This insures that tasking is initialized if any protected objects are\n --  created.\n \n with System.Parameters;\n---  used for Single_Lock\n+--  Used for Single_Lock\n \n package body System.Tasking.Protected_Objects.Entries is\n \n@@ -103,8 +104,9 @@ package body System.Tasking.Protected_Objects.Entries is\n       end if;\n \n       if Ceiling_Violation then\n-         --  Dip our own priority down to ceiling of lock.\n-         --  See similar code in Tasking.Entry_Calls.Lock_Server.\n+\n+         --  Dip our own priority down to ceiling of lock. See similar code in\n+         --  Tasking.Entry_Calls.Lock_Server.\n \n          STPO.Write_Lock (Self_ID);\n          Old_Base_Priority := Self_ID.Common.Base_Priority;\n@@ -130,7 +132,7 @@ package body System.Tasking.Protected_Objects.Entries is\n          Object.Pending_Action := True;\n       end if;\n \n-      --  Send program_error to all tasks still queued on this object.\n+      --  Send program_error to all tasks still queued on this object\n \n       for E in Object.Entry_Queues'Range loop\n          Entry_Call := Object.Entry_Queues (E).Head;\n@@ -229,10 +231,10 @@ package body System.Tasking.Protected_Objects.Entries is\n            (Program_Error'Identity, \"Protected Object is finalized\");\n       end if;\n \n-      --  If pragma Detect_Blocking is active then Program_Error must\n-      --  be raised if this potentially blocking operation is called from\n-      --  a protected action, and the protected object nesting level\n-      --  must be increased.\n+      --  If pragma Detect_Blocking is active then Program_Error must be\n+      --  raised if this potentially blocking operation is called from a\n+      --  protected action, and the protected object nesting level must be\n+      --  increased.\n \n       if Detect_Blocking then\n          declare\n@@ -242,24 +244,24 @@ package body System.Tasking.Protected_Objects.Entries is\n                Ada.Exceptions.Raise_Exception\n                  (Program_Error'Identity, \"potentially blocking operation\");\n             else\n-               --  We are entering in a protected action, so that we\n-               --  increase the protected object nesting level.\n+               --  We are entering in a protected action, so that we increase\n+               --  the protected object nesting level.\n \n                Self_Id.Common.Protected_Action_Nesting :=\n                  Self_Id.Common.Protected_Action_Nesting + 1;\n             end if;\n          end;\n       end if;\n \n-      --  The lock is made without defering abortion.\n+      --  The lock is made without defering abort\n \n-      --  Therefore the abortion has to be deferred before calling this\n-      --  routine. This means that the compiler has to generate a Defer_Abort\n-      --  call before the call to Lock.\n+      --  Therefore the abort has to be deferred before calling this routine.\n+      --  This means that the compiler has to generate a Defer_Abort call\n+      --  before the call to Lock.\n \n-      --  The caller is responsible for undeferring abortion, and compiler\n+      --  The caller is responsible for undeferring abort, and compiler\n       --  generated calls must be protected with cleanup handlers to ensure\n-      --  that abortion is undeferred in all cases.\n+      --  that abort is undeferred in all cases.\n \n       pragma Assert (STPO.Self.Deferral_Level > 0);\n       Write_Lock (Object.L'Access, Ceiling_Violation);\n@@ -302,8 +304,8 @@ package body System.Tasking.Protected_Objects.Entries is\n                Ada.Exceptions.Raise_Exception\n                  (Program_Error'Identity, \"potentially blocking operation\");\n             else\n-               --  We are entering in a protected action, so that we\n-               --  increase the protected object nesting level.\n+               --  We are entering in a protected action, so that we increase\n+               --  the protected object nesting level.\n \n                Self_Id.Common.Protected_Action_Nesting :=\n                  Self_Id.Common.Protected_Action_Nesting + 1;"}, {"sha": "09904f1d34dc47fb0b7f85c0b328bd77124ca7c2", "filename": "gcc/ada/s-tpobop.ads", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tpobop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fs-tpobop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpobop.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -2,12 +2,11 @@\n --                                                                          --\n --                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n --                                                                          --\n---    S Y S T E M . T A S K I N G . P R O T E C T E D _ O B J E C T S .     --\n---                            O P E R A T I O N S                           --\n+--                SYSTEM.TASKING.PROTECTED_OBJECTS.OPERATIONS               --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,19 +31,20 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains all the extended primitives related to\n---  Protected_Objects with entries.\n+--  This package contains all the extended primitives related to protected\n+--  objects with entries.\n+\n --  The handling of protected objects with no entries is done in\n --  System.Tasking.Protected_Objects, the simple routines for protected\n---  objects with entries in System.Tasking.Protected_Objects.Entries.\n---  The split between Entries and Operations is needed to break circular\n+--  objects with entries in System.Tasking.Protected_Objects.Entries. The\n+--  split between Entries and Operations is needed to break circular\n --  dependencies inside the run time.\n \n --  Note: the compiler generates direct calls to this interface, via Rtsfind.\n --  Any changes to this interface may require corresponding compiler changes.\n \n with Ada.Exceptions;\n---  used for Exception_Id\n+--  Used for Exception_Id\n \n with System.Tasking.Protected_Objects.Entries;\n \n@@ -108,7 +108,7 @@ package System.Tasking.Protected_Objects.Operations is\n    --  barriers, so this routine keeps checking barriers until all of\n    --  them are closed.\n    --\n-   --  This must be called with abortion deferred and with the corresponding\n+   --  This must be called with abort deferred and with the corresponding\n    --  object locked.\n    --\n    --  If Unlock_Object is set True, then Object is unlocked on return,\n@@ -173,23 +173,23 @@ package System.Tasking.Protected_Objects.Operations is\n      (Object : Entries.Protection_Entries'Class;\n       E      : Protected_Entry_Index)\n       return   Natural;\n-   --  Return the number of entry calls to E on Object.\n+   --  Return the number of entry calls to E on Object\n \n    function Protected_Entry_Caller\n      (Object : Entries.Protection_Entries'Class) return Task_Id;\n    --  Return value of E'Caller, where E is the protected entry currently\n    --  being handled. This will only work if called from within an entry\n    --  body, as required by the LRM (C.7.1(14)).\n \n-   --  For internal use only:\n+   --  For internal use only\n \n    procedure PO_Do_Or_Queue\n      (Self_ID    : Task_Id;\n       Object     : Entries.Protection_Entries_Access;\n       Entry_Call : Entry_Call_Link;\n       With_Abort : Boolean);\n    --  This procedure either executes or queues an entry call, depending\n-   --  on the status of the corresponding barrier. It assumes that abortion\n+   --  on the status of the corresponding barrier. It assumes that abort\n    --  is deferred and that the specified object is locked.\n \n private\n@@ -201,10 +201,9 @@ private\n    pragma Volatile (Communication_Block);\n \n    --  ?????\n-   --  The Communication_Block seems to be a relic.\n-   --  At the moment, the compiler seems to be generating\n-   --  unnecessary conditional code based on this block.\n-   --  See the code generated for async. select with task entry\n+   --  The Communication_Block seems to be a relic. At the moment, the\n+   --  compiler seems to be generating unnecessary conditional code based on\n+   --  this block. See the code generated for async. select with task entry\n    --  call for another way of solving this.\n \n end System.Tasking.Protected_Objects.Operations;"}, {"sha": "ee6e8bb5151c23a0e894694bdbc98d4577edd268", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 1049, "deletions": 1049, "changes": 2098, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -1,1049 +1,1049 @@\n-------------------------------------------------------------------------------\r\n---                                                                          --\r\n---                         GNAT COMPILER COMPONENTS                         --\r\n---                                                                          --\r\n---                               S N A M E S                                --\r\n---                                                                          --\r\n---                                 B o d y                                  --\r\n---                                                                          --\r\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\r\n---                                                                          --\r\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\r\n--- terms of the  GNU General Public License as published  by the Free Soft- --\r\n--- ware  Foundation;  either version 2,  or (at your option) any later ver- --\r\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\r\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\r\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\r\n--- for  more details.  You should have  received  a copy of the GNU General --\r\n--- Public License  distributed with GNAT;  see file COPYING.  If not, write --\r\n--- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\r\n--- MA 02111-1307, USA.                                                      --\r\n---                                                                          --\r\n--- As a special exception,  if other files  instantiate  generics from this --\r\n--- unit, or you link  this unit with other files  to produce an executable, --\r\n--- this  unit  does not  by itself cause  the resulting  executable  to  be --\r\n--- covered  by the  GNU  General  Public  License.  This exception does not --\r\n--- however invalidate  any other reasons why  the executable file  might be --\r\n--- covered by the  GNU Public License.                                      --\r\n---                                                                          --\r\n--- GNAT was originally developed  by the GNAT team at  New York University. --\r\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\r\n---                                                                          --\r\n-------------------------------------------------------------------------------\r\n-\r\n-with Namet; use Namet;\r\n-with Table;\r\n-\r\n-package body Snames is\r\n-\r\n-   --  Table used to record convention identifiers\r\n-\r\n-   type Convention_Id_Entry is record\r\n-      Name       : Name_Id;\r\n-      Convention : Convention_Id;\r\n-   end record;\r\n-\r\n-   package Convention_Identifiers is new Table.Table (\r\n-     Table_Component_Type => Convention_Id_Entry,\r\n-     Table_Index_Type     => Int,\r\n-     Table_Low_Bound      => 1,\r\n-     Table_Initial        => 50,\r\n-     Table_Increment      => 200,\r\n-     Table_Name           => \"Name_Convention_Identifiers\");\r\n-\r\n-   --  Table of names to be set by Initialize. Each name is terminated by a\r\n-   --  single #, and the end of the list is marked by a null entry, i.e. by\r\n-   --  two # marks in succession. Note that the table does not include the\r\n-   --  entries for a-z, since these are initialized by Namet itself.\r\n-\r\n-   Preset_Names : constant String :=\r\n-     \"_parent#\" &\r\n-     \"_tag#\" &\r\n-     \"off#\" &\r\n-     \"space#\" &\r\n-     \"time#\" &\r\n-     \"_abort_signal#\" &\r\n-     \"_alignment#\" &\r\n-     \"_assign#\" &\r\n-     \"_atcb#\" &\r\n-     \"_chain#\" &\r\n-     \"_clean#\" &\r\n-     \"_controller#\" &\r\n-     \"_entry_bodies#\" &\r\n-     \"_expunge#\" &\r\n-     \"_final_list#\" &\r\n-     \"_idepth#\" &\r\n-     \"_init#\" &\r\n-     \"_local_final_list#\" &\r\n-     \"_master#\" &\r\n-     \"_object#\" &\r\n-     \"_priority#\" &\r\n-     \"_process_atsd#\" &\r\n-     \"_secondary_stack#\" &\r\n-     \"_service#\" &\r\n-     \"_size#\" &\r\n-     \"_stack#\" &\r\n-     \"_tags#\" &\r\n-     \"_task#\" &\r\n-     \"_task_id#\" &\r\n-     \"_task_info#\" &\r\n-     \"_task_name#\" &\r\n-     \"_trace_sp#\" &\r\n-     \"initialize#\" &\r\n-     \"adjust#\" &\r\n-     \"finalize#\" &\r\n-     \"next#\" &\r\n-     \"prev#\" &\r\n-     \"_typecode#\" &\r\n-     \"_from_any#\" &\r\n-     \"_to_any#\" &\r\n-     \"allocate#\" &\r\n-     \"deallocate#\" &\r\n-     \"dereference#\" &\r\n-     \"decimal_io#\" &\r\n-     \"enumeration_io#\" &\r\n-     \"fixed_io#\" &\r\n-     \"float_io#\" &\r\n-     \"integer_io#\" &\r\n-     \"modular_io#\" &\r\n-     \"const#\" &\r\n-     \"<error>#\" &\r\n-     \"go#\" &\r\n-     \"put#\" &\r\n-     \"put_line#\" &\r\n-     \"to#\" &\r\n-     \"finalization#\" &\r\n-     \"finalization_root#\" &\r\n-     \"interfaces#\" &\r\n-     \"standard#\" &\r\n-     \"system#\" &\r\n-     \"text_io#\" &\r\n-     \"wide_text_io#\" &\r\n-     \"wide_wide_text_io#\" &\r\n-     \"no_dsa#\" &\r\n-     \"garlic_dsa#\" &\r\n-     \"polyorb_dsa#\" &\r\n-     \"addr#\" &\r\n-     \"async#\" &\r\n-     \"get_active_partition_id#\" &\r\n-     \"get_rci_package_receiver#\" &\r\n-     \"get_rci_package_ref#\" &\r\n-     \"origin#\" &\r\n-     \"params#\" &\r\n-     \"partition#\" &\r\n-     \"partition_interface#\" &\r\n-     \"ras#\" &\r\n-     \"call#\" &\r\n-     \"rci_name#\" &\r\n-     \"receiver#\" &\r\n-     \"result#\" &\r\n-     \"rpc#\" &\r\n-     \"subp_id#\" &\r\n-     \"operation#\" &\r\n-     \"argument#\" &\r\n-     \"arg_modes#\" &\r\n-     \"handler#\" &\r\n-     \"target#\" &\r\n-     \"req#\" &\r\n-     \"obj_typecode#\" &\r\n-     \"stub#\" &\r\n-     \"Oabs#\" &\r\n-     \"Oand#\" &\r\n-     \"Omod#\" &\r\n-     \"Onot#\" &\r\n-     \"Oor#\" &\r\n-     \"Orem#\" &\r\n-     \"Oxor#\" &\r\n-     \"Oeq#\" &\r\n-     \"One#\" &\r\n-     \"Olt#\" &\r\n-     \"Ole#\" &\r\n-     \"Ogt#\" &\r\n-     \"Oge#\" &\r\n-     \"Oadd#\" &\r\n-     \"Osubtract#\" &\r\n-     \"Oconcat#\" &\r\n-     \"Omultiply#\" &\r\n-     \"Odivide#\" &\r\n-     \"Oexpon#\" &\r\n-     \"ada_83#\" &\r\n-     \"ada_95#\" &\r\n-     \"ada_05#\" &\r\n-     \"c_pass_by_copy#\" &\r\n-     \"compile_time_warning#\" &\r\n-     \"component_alignment#\" &\r\n-     \"convention_identifier#\" &\r\n-     \"detect_blocking#\" &\r\n-     \"discard_names#\" &\r\n-     \"elaboration_checks#\" &\r\n-     \"eliminate#\" &\r\n-     \"explicit_overriding#\" &\r\n-     \"extend_system#\" &\r\n-     \"extensions_allowed#\" &\r\n-     \"external_name_casing#\" &\r\n-     \"float_representation#\" &\r\n-     \"initialize_scalars#\" &\r\n-     \"interrupt_state#\" &\r\n-     \"license#\" &\r\n-     \"locking_policy#\" &\r\n-     \"long_float#\" &\r\n-     \"no_run_time#\" &\r\n-     \"no_strict_aliasing#\" &\r\n-     \"normalize_scalars#\" &\r\n-     \"polling#\" &\r\n-     \"persistent_data#\" &\r\n-     \"persistent_object#\" &\r\n-     \"profile#\" &\r\n-     \"profile_warnings#\" &\r\n-     \"propagate_exceptions#\" &\r\n-     \"queuing_policy#\" &\r\n-     \"ravenscar#\" &\r\n-     \"restricted_run_time#\" &\r\n-     \"restrictions#\" &\r\n-     \"restriction_warnings#\" &\r\n-     \"reviewable#\" &\r\n-     \"source_file_name#\" &\r\n-     \"source_file_name_project#\" &\r\n-     \"style_checks#\" &\r\n-     \"suppress#\" &\r\n-     \"suppress_exception_locations#\" &\r\n-     \"task_dispatching_policy#\" &\r\n-     \"universal_data#\" &\r\n-     \"unsuppress#\" &\r\n-     \"use_vads_size#\" &\r\n-     \"validity_checks#\" &\r\n-     \"warnings#\" &\r\n-     \"abort_defer#\" &\r\n-     \"all_calls_remote#\" &\r\n-     \"annotate#\" &\r\n-     \"assert#\" &\r\n-     \"asynchronous#\" &\r\n-     \"atomic#\" &\r\n-     \"atomic_components#\" &\r\n-     \"attach_handler#\" &\r\n-     \"comment#\" &\r\n-     \"common_object#\" &\r\n-     \"complex_representation#\" &\r\n-     \"controlled#\" &\r\n-     \"convention#\" &\r\n-     \"cpp_class#\" &\r\n-     \"cpp_constructor#\" &\r\n-     \"cpp_virtual#\" &\r\n-     \"cpp_vtable#\" &\r\n-     \"debug#\" &\r\n-     \"elaborate#\" &\r\n-     \"elaborate_all#\" &\r\n-     \"elaborate_body#\" &\r\n-     \"export#\" &\r\n-     \"export_exception#\" &\r\n-     \"export_function#\" &\r\n-     \"export_object#\" &\r\n-     \"export_procedure#\" &\r\n-     \"export_value#\" &\r\n-     \"export_valued_procedure#\" &\r\n-     \"external#\" &\r\n-     \"finalize_storage_only#\" &\r\n-     \"ident#\" &\r\n-     \"import#\" &\r\n-     \"import_exception#\" &\r\n-     \"import_function#\" &\r\n-     \"import_object#\" &\r\n-     \"import_procedure#\" &\r\n-     \"import_valued_procedure#\" &\r\n-     \"inline#\" &\r\n-     \"inline_always#\" &\r\n-     \"inline_generic#\" &\r\n-     \"inspection_point#\" &\r\n-     \"interface_name#\" &\r\n-     \"interrupt_handler#\" &\r\n-     \"interrupt_priority#\" &\r\n-     \"java_constructor#\" &\r\n-     \"java_interface#\" &\r\n-     \"keep_names#\" &\r\n-     \"link_with#\" &\r\n-     \"linker_alias#\" &\r\n-     \"linker_options#\" &\r\n-     \"linker_section#\" &\r\n-     \"list#\" &\r\n-     \"machine_attribute#\" &\r\n-     \"main#\" &\r\n-     \"main_storage#\" &\r\n-     \"memory_size#\" &\r\n-     \"no_return#\" &\r\n-     \"obsolescent#\" &\r\n-     \"optimize#\" &\r\n-     \"optional_overriding#\" &\r\n-     \"pack#\" &\r\n-     \"page#\" &\r\n-     \"passive#\" &\r\n-     \"preelaborate#\" &\r\n-     \"priority#\" &\r\n-     \"psect_object#\" &\r\n-     \"pure#\" &\r\n-     \"pure_function#\" &\r\n-     \"remote_call_interface#\" &\r\n-     \"remote_types#\" &\r\n-     \"share_generic#\" &\r\n-     \"shared#\" &\r\n-     \"shared_passive#\" &\r\n-     \"source_reference#\" &\r\n-     \"stream_convert#\" &\r\n-     \"subtitle#\" &\r\n-     \"suppress_all#\" &\r\n-     \"suppress_debug_info#\" &\r\n-     \"suppress_initialization#\" &\r\n-     \"system_name#\" &\r\n-     \"task_info#\" &\r\n-     \"task_name#\" &\r\n-     \"task_storage#\" &\r\n-     \"thread_body#\" &\r\n-     \"time_slice#\" &\r\n-     \"title#\" &\r\n-     \"unchecked_union#\" &\r\n-     \"unimplemented_unit#\" &\r\n-     \"unreferenced#\" &\r\n-     \"unreserve_all_interrupts#\" &\r\n-     \"volatile#\" &\r\n-     \"volatile_components#\" &\r\n-     \"weak_external#\" &\r\n-     \"ada#\" &\r\n-     \"assembler#\" &\r\n-     \"cobol#\" &\r\n-     \"cpp#\" &\r\n-     \"fortran#\" &\r\n-     \"intrinsic#\" &\r\n-     \"java#\" &\r\n-     \"stdcall#\" &\r\n-     \"stubbed#\" &\r\n-     \"asm#\" &\r\n-     \"assembly#\" &\r\n-     \"default#\" &\r\n-     \"dll#\" &\r\n-     \"win32#\" &\r\n-     \"as_is#\" &\r\n-     \"body_file_name#\" &\r\n-     \"boolean_entry_barriers#\" &\r\n-     \"casing#\" &\r\n-     \"code#\" &\r\n-     \"component#\" &\r\n-     \"component_size_4#\" &\r\n-     \"copy#\" &\r\n-     \"d_float#\" &\r\n-     \"descriptor#\" &\r\n-     \"dot_replacement#\" &\r\n-     \"dynamic#\" &\r\n-     \"entity#\" &\r\n-     \"external_name#\" &\r\n-     \"first_optional_parameter#\" &\r\n-     \"form#\" &\r\n-     \"g_float#\" &\r\n-     \"gcc#\" &\r\n-     \"gnat#\" &\r\n-     \"gpl#\" &\r\n-     \"ieee_float#\" &\r\n-     \"internal#\" &\r\n-     \"link_name#\" &\r\n-     \"lowercase#\" &\r\n-     \"max_entry_queue_depth#\" &\r\n-     \"max_entry_queue_length#\" &\r\n-     \"max_size#\" &\r\n-     \"mechanism#\" &\r\n-     \"mixedcase#\" &\r\n-     \"modified_gpl#\" &\r\n-     \"name#\" &\r\n-     \"nca#\" &\r\n-     \"no#\" &\r\n-     \"no_dependence#\" &\r\n-     \"no_dynamic_attachment#\" &\r\n-     \"no_dynamic_interrupts#\" &\r\n-     \"no_requeue#\" &\r\n-     \"no_requeue_statements#\" &\r\n-     \"no_task_attributes#\" &\r\n-     \"no_task_attributes_package#\" &\r\n-     \"on#\" &\r\n-     \"parameter_types#\" &\r\n-     \"reference#\" &\r\n-     \"restricted#\" &\r\n-     \"result_mechanism#\" &\r\n-     \"result_type#\" &\r\n-     \"runtime#\" &\r\n-     \"sb#\" &\r\n-     \"secondary_stack_size#\" &\r\n-     \"section#\" &\r\n-     \"semaphore#\" &\r\n-     \"simple_barriers#\" &\r\n-     \"spec_file_name#\" &\r\n-     \"static#\" &\r\n-     \"stack_size#\" &\r\n-     \"subunit_file_name#\" &\r\n-     \"task_stack_size_default#\" &\r\n-     \"task_type#\" &\r\n-     \"time_slicing_enabled#\" &\r\n-     \"top_guard#\" &\r\n-     \"uba#\" &\r\n-     \"ubs#\" &\r\n-     \"ubsb#\" &\r\n-     \"unit_name#\" &\r\n-     \"unknown#\" &\r\n-     \"unrestricted#\" &\r\n-     \"uppercase#\" &\r\n-     \"user#\" &\r\n-     \"vax_float#\" &\r\n-     \"vms#\" &\r\n-     \"working_storage#\" &\r\n-     \"abort_signal#\" &\r\n-     \"access#\" &\r\n-     \"address#\" &\r\n-     \"address_size#\" &\r\n-     \"aft#\" &\r\n-     \"alignment#\" &\r\n-     \"asm_input#\" &\r\n-     \"asm_output#\" &\r\n-     \"ast_entry#\" &\r\n-     \"bit#\" &\r\n-     \"bit_order#\" &\r\n-     \"bit_position#\" &\r\n-     \"body_version#\" &\r\n-     \"callable#\" &\r\n-     \"caller#\" &\r\n-     \"code_address#\" &\r\n-     \"component_size#\" &\r\n-     \"compose#\" &\r\n-     \"constrained#\" &\r\n-     \"count#\" &\r\n-     \"default_bit_order#\" &\r\n-     \"definite#\" &\r\n-     \"delta#\" &\r\n-     \"denorm#\" &\r\n-     \"digits#\" &\r\n-     \"elaborated#\" &\r\n-     \"emax#\" &\r\n-     \"enum_rep#\" &\r\n-     \"epsilon#\" &\r\n-     \"exponent#\" &\r\n-     \"external_tag#\" &\r\n-     \"first#\" &\r\n-     \"first_bit#\" &\r\n-     \"fixed_value#\" &\r\n-     \"fore#\" &\r\n-     \"has_access_values#\" &\r\n-     \"has_discriminants#\" &\r\n-     \"identity#\" &\r\n-     \"img#\" &\r\n-     \"integer_value#\" &\r\n-     \"large#\" &\r\n-     \"last#\" &\r\n-     \"last_bit#\" &\r\n-     \"leading_part#\" &\r\n-     \"length#\" &\r\n-     \"machine_emax#\" &\r\n-     \"machine_emin#\" &\r\n-     \"machine_mantissa#\" &\r\n-     \"machine_overflows#\" &\r\n-     \"machine_radix#\" &\r\n-     \"machine_rounds#\" &\r\n-     \"machine_size#\" &\r\n-     \"mantissa#\" &\r\n-     \"max_size_in_storage_elements#\" &\r\n-     \"maximum_alignment#\" &\r\n-     \"mechanism_code#\" &\r\n-     \"mod#\" &\r\n-     \"model_emin#\" &\r\n-     \"model_epsilon#\" &\r\n-     \"model_mantissa#\" &\r\n-     \"model_small#\" &\r\n-     \"modulus#\" &\r\n-     \"null_parameter#\" &\r\n-     \"object_size#\" &\r\n-     \"partition_id#\" &\r\n-     \"passed_by_reference#\" &\r\n-     \"pool_address#\" &\r\n-     \"pos#\" &\r\n-     \"position#\" &\r\n-     \"range#\" &\r\n-     \"range_length#\" &\r\n-     \"round#\" &\r\n-     \"safe_emax#\" &\r\n-     \"safe_first#\" &\r\n-     \"safe_large#\" &\r\n-     \"safe_last#\" &\r\n-     \"safe_small#\" &\r\n-     \"scale#\" &\r\n-     \"scaling#\" &\r\n-     \"signed_zeros#\" &\r\n-     \"size#\" &\r\n-     \"small#\" &\r\n-     \"storage_size#\" &\r\n-     \"storage_unit#\" &\r\n-     \"stream_size#\" &\r\n-     \"tag#\" &\r\n-     \"target_name#\" &\r\n-     \"terminated#\" &\r\n-     \"to_address#\" &\r\n-     \"type_class#\" &\r\n-     \"uet_address#\" &\r\n-     \"unbiased_rounding#\" &\r\n-     \"unchecked_access#\" &\r\n-     \"unconstrained_array#\" &\r\n-     \"universal_literal_string#\" &\r\n-     \"unrestricted_access#\" &\r\n-     \"vads_size#\" &\r\n-     \"val#\" &\r\n-     \"valid#\" &\r\n-     \"value_size#\" &\r\n-     \"version#\" &\r\n-     \"wchar_t_size#\" &\r\n-     \"wide_wide_width#\" &\r\n-     \"wide_width#\" &\r\n-     \"width#\" &\r\n-     \"word_size#\" &\r\n-     \"adjacent#\" &\r\n-     \"ceiling#\" &\r\n-     \"copy_sign#\" &\r\n-     \"floor#\" &\r\n-     \"fraction#\" &\r\n-     \"image#\" &\r\n-     \"input#\" &\r\n-     \"machine#\" &\r\n-     \"max#\" &\r\n-     \"min#\" &\r\n-     \"model#\" &\r\n-     \"pred#\" &\r\n-     \"remainder#\" &\r\n-     \"rounding#\" &\r\n-     \"succ#\" &\r\n-     \"truncation#\" &\r\n-     \"value#\" &\r\n-     \"wide_image#\" &\r\n-     \"wide_wide_image#\" &\r\n-     \"wide_value#\" &\r\n-     \"wide_wide_value#\" &\r\n-     \"output#\" &\r\n-     \"read#\" &\r\n-     \"write#\" &\r\n-     \"elab_body#\" &\r\n-     \"elab_spec#\" &\r\n-     \"storage_pool#\" &\r\n-     \"base#\" &\r\n-     \"class#\" &\r\n-     \"ceiling_locking#\" &\r\n-     \"inheritance_locking#\" &\r\n-     \"fifo_queuing#\" &\r\n-     \"priority_queuing#\" &\r\n-     \"fifo_within_priorities#\" &\r\n-     \"access_check#\" &\r\n-     \"accessibility_check#\" &\r\n-     \"discriminant_check#\" &\r\n-     \"division_check#\" &\r\n-     \"elaboration_check#\" &\r\n-     \"index_check#\" &\r\n-     \"length_check#\" &\r\n-     \"overflow_check#\" &\r\n-     \"range_check#\" &\r\n-     \"storage_check#\" &\r\n-     \"tag_check#\" &\r\n-     \"all_checks#\" &\r\n-     \"abort#\" &\r\n-     \"abs#\" &\r\n-     \"accept#\" &\r\n-     \"and#\" &\r\n-     \"all#\" &\r\n-     \"array#\" &\r\n-     \"at#\" &\r\n-     \"begin#\" &\r\n-     \"body#\" &\r\n-     \"case#\" &\r\n-     \"constant#\" &\r\n-     \"declare#\" &\r\n-     \"delay#\" &\r\n-     \"do#\" &\r\n-     \"else#\" &\r\n-     \"elsif#\" &\r\n-     \"end#\" &\r\n-     \"entry#\" &\r\n-     \"exception#\" &\r\n-     \"exit#\" &\r\n-     \"for#\" &\r\n-     \"function#\" &\r\n-     \"generic#\" &\r\n-     \"goto#\" &\r\n-     \"if#\" &\r\n-     \"in#\" &\r\n-     \"is#\" &\r\n-     \"limited#\" &\r\n-     \"loop#\" &\r\n-     \"new#\" &\r\n-     \"not#\" &\r\n-     \"null#\" &\r\n-     \"of#\" &\r\n-     \"or#\" &\r\n-     \"others#\" &\r\n-     \"out#\" &\r\n-     \"package#\" &\r\n-     \"pragma#\" &\r\n-     \"private#\" &\r\n-     \"procedure#\" &\r\n-     \"raise#\" &\r\n-     \"record#\" &\r\n-     \"rem#\" &\r\n-     \"renames#\" &\r\n-     \"return#\" &\r\n-     \"reverse#\" &\r\n-     \"select#\" &\r\n-     \"separate#\" &\r\n-     \"subtype#\" &\r\n-     \"task#\" &\r\n-     \"terminate#\" &\r\n-     \"then#\" &\r\n-     \"type#\" &\r\n-     \"use#\" &\r\n-     \"when#\" &\r\n-     \"while#\" &\r\n-     \"with#\" &\r\n-     \"xor#\" &\r\n-     \"divide#\" &\r\n-     \"enclosing_entity#\" &\r\n-     \"exception_information#\" &\r\n-     \"exception_message#\" &\r\n-     \"exception_name#\" &\r\n-     \"file#\" &\r\n-     \"import_address#\" &\r\n-     \"import_largest_value#\" &\r\n-     \"import_value#\" &\r\n-     \"is_negative#\" &\r\n-     \"line#\" &\r\n-     \"rotate_left#\" &\r\n-     \"rotate_right#\" &\r\n-     \"shift_left#\" &\r\n-     \"shift_right#\" &\r\n-     \"shift_right_arithmetic#\" &\r\n-     \"source_location#\" &\r\n-     \"unchecked_conversion#\" &\r\n-     \"unchecked_deallocation#\" &\r\n-     \"to_pointer#\" &\r\n-     \"abstract#\" &\r\n-     \"aliased#\" &\r\n-     \"protected#\" &\r\n-     \"until#\" &\r\n-     \"requeue#\" &\r\n-     \"tagged#\" &\r\n-     \"raise_exception#\" &\r\n-     \"ada_roots#\" &\r\n-     \"binder#\" &\r\n-     \"binder_driver#\" &\r\n-     \"body_suffix#\" &\r\n-     \"builder#\" &\r\n-     \"compiler#\" &\r\n-     \"compiler_driver#\" &\r\n-     \"compiler_kind#\" &\r\n-     \"compute_dependency#\" &\r\n-     \"cross_reference#\" &\r\n-     \"default_linker#\" &\r\n-     \"default_switches#\" &\r\n-     \"dependency_option#\" &\r\n-     \"exec_dir#\" &\r\n-     \"executable#\" &\r\n-     \"executable_suffix#\" &\r\n-     \"extends#\" &\r\n-     \"externally_built#\" &\r\n-     \"finder#\" &\r\n-     \"global_configuration_pragmas#\" &\r\n-     \"gnatls#\" &\r\n-     \"gnatstub#\" &\r\n-     \"implementation#\" &\r\n-     \"implementation_exceptions#\" &\r\n-     \"implementation_suffix#\" &\r\n-     \"include_option#\" &\r\n-     \"language_processing#\" &\r\n-     \"languages#\" &\r\n-     \"library_dir#\" &\r\n-     \"library_auto_init#\" &\r\n-     \"library_gcc#\" &\r\n-     \"library_interface#\" &\r\n-     \"library_kind#\" &\r\n-     \"library_name#\" &\r\n-     \"library_options#\" &\r\n-     \"library_reference_symbol_file#\" &\r\n-     \"library_src_dir#\" &\r\n-     \"library_symbol_file#\" &\r\n-     \"library_symbol_policy#\" &\r\n-     \"library_version#\" &\r\n-     \"linker#\" &\r\n-     \"local_configuration_pragmas#\" &\r\n-     \"locally_removed_files#\" &\r\n-     \"metrics#\" &\r\n-     \"naming#\" &\r\n-     \"object_dir#\" &\r\n-     \"pretty_printer#\" &\r\n-     \"project#\" &\r\n-     \"separate_suffix#\" &\r\n-     \"source_dirs#\" &\r\n-     \"source_files#\" &\r\n-     \"source_list_file#\" &\r\n-     \"spec#\" &\r\n-     \"spec_suffix#\" &\r\n-     \"specification#\" &\r\n-     \"specification_exceptions#\" &\r\n-     \"specification_suffix#\" &\r\n-     \"switches#\" &\r\n-     \"unaligned_valid#\" &\r\n-     \"interface#\" &\r\n-     \"overriding#\" &\r\n-     \"synchronized#\" &\r\n-     \"#\";\r\n-\r\n-   ---------------------\r\n-   -- Generated Names --\r\n-   ---------------------\r\n-\r\n-   --  This section lists the various cases of generated names which are\r\n-   --  built from existing names by adding unique leading and/or trailing\r\n-   --  upper case letters. In some cases these names are built recursively,\r\n-   --  in particular names built from types may be built from types which\r\n-   --  themselves have generated names. In this list, xxx represents an\r\n-   --  existing name to which identifying letters are prepended or appended,\r\n-   --  and a trailing n represents a serial number in an external name that\r\n-   --  has some semantic significance (e.g. the n'th index type of an array).\r\n-\r\n-   --    xxxA    access type for formal xxx in entry param record   (Exp_Ch9)\r\n-   --    xxxB    tag table for tagged type xxx                      (Exp_Ch3)\r\n-   --    xxxB    task body procedure for task xxx                   (Exp_Ch9)\r\n-   --    xxxD    dispatch table for tagged type xxx                 (Exp_Ch3)\r\n-   --    xxxD    discriminal for discriminant xxx                   (Sem_Ch3)\r\n-   --    xxxDn   n'th discr check function for rec type xxx         (Exp_Ch3)\r\n-   --    xxxE    elaboration boolean flag for task xxx              (Exp_Ch9)\r\n-   --    xxxE    dispatch table pointer type for tagged type xxx    (Exp_Ch3)\r\n-   --    xxxE    parameters for accept body for entry xxx           (Exp_Ch9)\r\n-   --    xxxFn   n'th primitive of a tagged type (named xxx)        (Exp_Ch3)\r\n-   --    xxxJ    tag table type index for tagged type xxx           (Exp_Ch3)\r\n-   --    xxxM    master Id value for access type xxx                (Exp_Ch3)\r\n-   --    xxxP    tag table pointer type for tagged type xxx         (Exp_Ch3)\r\n-   --    xxxP    parameter record type for entry xxx                (Exp_Ch9)\r\n-   --    xxxPA   access to parameter record type for entry xxx      (Exp_Ch9)\r\n-   --    xxxPn   pointer type for n'th primitive of tagged type xxx (Exp_Ch3)\r\n-   --    xxxR    dispatch table pointer for tagged type xxx         (Exp_Ch3)\r\n-   --    xxxT    tag table type for tagged type xxx                 (Exp_Ch3)\r\n-   --    xxxT    literal table for enumeration type xxx             (Sem_Ch3)\r\n-   --    xxxV    type for task value record for task xxx            (Exp_Ch9)\r\n-   --    xxxX    entry index constant                               (Exp_Ch9)\r\n-   --    xxxY    dispatch table type for tagged type xxx            (Exp_Ch3)\r\n-   --    xxxZ    size variable for task xxx                         (Exp_Ch9)\r\n-\r\n-   --  TSS names\r\n-\r\n-   --    xxxDA   deep adjust routine for type xxx                   (Exp_TSS)\r\n-   --    xxxDF   deep finalize routine for type xxx                 (Exp_TSS)\r\n-   --    xxxDI   deep initialize routine for type xxx               (Exp_TSS)\r\n-   --    xxxEQ   composite equality routine for record type xxx     (Exp_TSS)\r\n-   --    xxxIP   initialization procedure for type xxx              (Exp_TSS)\r\n-   --    xxxRA   RAs type access routine for type xxx               (Exp_TSS)\r\n-   --    xxxRD   RAs type dereference routine for type xxx          (Exp_TSS)\r\n-   --    xxxRP   Rep to Pos conversion for enumeration type xxx     (Exp_TSS)\r\n-   --    xxxSA   array/slice assignment for controlled comp. arrays (Exp_TSS)\r\n-   --    xxxSI   stream input attribute subprogram for type xxx     (Exp_TSS)\r\n-   --    xxxSO   stream output attribute subprogram for type xxx    (Exp_TSS)\r\n-   --    xxxSR   stream read attribute subprogram for type xxx      (Exp_TSS)\r\n-   --    xxxSW   stream write attribute subprogram for type xxx     (Exp_TSS)\r\n-\r\n-   --  Implicit type names\r\n-\r\n-   --    TxxxT   type of literal table for enumeration type xxx     (Sem_Ch3)\r\n-\r\n-   --  (Note: this list is not complete or accurate ???)\r\n-\r\n-   ----------------------\r\n-   -- Get_Attribute_Id --\r\n-   ----------------------\r\n-\r\n-   function Get_Attribute_Id (N : Name_Id) return Attribute_Id is\r\n-   begin\r\n-      return Attribute_Id'Val (N - First_Attribute_Name);\r\n-   end Get_Attribute_Id;\r\n-\r\n-   ------------------\r\n-   -- Get_Check_Id --\r\n-   ------------------\r\n-\r\n-   function Get_Check_Id (N : Name_Id) return Check_Id is\r\n-   begin\r\n-      return Check_Id'Val (N - First_Check_Name);\r\n-   end Get_Check_Id;\r\n-\r\n-   -----------------------\r\n-   -- Get_Convention_Id --\r\n-   -----------------------\r\n-\r\n-   function Get_Convention_Id (N : Name_Id) return Convention_Id is\r\n-   begin\r\n-      case N is\r\n-         when Name_Ada        => return Convention_Ada;\r\n-         when Name_Assembler  => return Convention_Assembler;\r\n-         when Name_C          => return Convention_C;\r\n-         when Name_COBOL      => return Convention_COBOL;\r\n-         when Name_CPP        => return Convention_CPP;\r\n-         when Name_Fortran    => return Convention_Fortran;\r\n-         when Name_Intrinsic  => return Convention_Intrinsic;\r\n-         when Name_Java       => return Convention_Java;\r\n-         when Name_Stdcall    => return Convention_Stdcall;\r\n-         when Name_Stubbed    => return Convention_Stubbed;\r\n-\r\n-         --  If no direct match, then we must have a convention\r\n-         --  identifier pragma that has specified this name.\r\n-\r\n-         when others          =>\r\n-            for J in 1 .. Convention_Identifiers.Last loop\r\n-               if N = Convention_Identifiers.Table (J).Name then\r\n-                  return Convention_Identifiers.Table (J).Convention;\r\n-               end if;\r\n-            end loop;\r\n-\r\n-            raise Program_Error;\r\n-      end case;\r\n-   end Get_Convention_Id;\r\n-\r\n-   ---------------------------\r\n-   -- Get_Locking_Policy_Id --\r\n-   ---------------------------\r\n-\r\n-   function Get_Locking_Policy_Id (N : Name_Id) return Locking_Policy_Id is\r\n-   begin\r\n-      return Locking_Policy_Id'Val (N - First_Locking_Policy_Name);\r\n-   end Get_Locking_Policy_Id;\r\n-\r\n-   -------------------\r\n-   -- Get_Pragma_Id --\r\n-   -------------------\r\n-\r\n-   function Get_Pragma_Id (N : Name_Id) return Pragma_Id is\r\n-   begin\r\n-      if N = Name_AST_Entry then\r\n-         return Pragma_AST_Entry;\r\n-      elsif N = Name_Interface then\r\n-         return Pragma_Interface;\r\n-      elsif N = Name_Storage_Size then\r\n-         return Pragma_Storage_Size;\r\n-      elsif N = Name_Storage_Unit then\r\n-         return Pragma_Storage_Unit;\r\n-      elsif N not in First_Pragma_Name .. Last_Pragma_Name then\r\n-         return Unknown_Pragma;\r\n-      else\r\n-         return Pragma_Id'Val (N - First_Pragma_Name);\r\n-      end if;\r\n-   end Get_Pragma_Id;\r\n-\r\n-   ---------------------------\r\n-   -- Get_Queuing_Policy_Id --\r\n-   ---------------------------\r\n-\r\n-   function Get_Queuing_Policy_Id (N : Name_Id) return Queuing_Policy_Id is\r\n-   begin\r\n-      return Queuing_Policy_Id'Val (N - First_Queuing_Policy_Name);\r\n-   end Get_Queuing_Policy_Id;\r\n-\r\n-   ------------------------------------\r\n-   -- Get_Task_Dispatching_Policy_Id --\r\n-   ------------------------------------\r\n-\r\n-   function Get_Task_Dispatching_Policy_Id (N : Name_Id)\r\n-     return Task_Dispatching_Policy_Id is\r\n-   begin\r\n-      return Task_Dispatching_Policy_Id'Val\r\n-        (N - First_Task_Dispatching_Policy_Name);\r\n-   end Get_Task_Dispatching_Policy_Id;\r\n-\r\n-   ----------------\r\n-   -- Initialize --\r\n-   ----------------\r\n-\r\n-   procedure Initialize is\r\n-      P_Index      : Natural;\r\n-      Discard_Name : Name_Id;\r\n-\r\n-   begin\r\n-      P_Index := Preset_Names'First;\r\n-\r\n-      loop\r\n-         Name_Len := 0;\r\n-\r\n-         while Preset_Names (P_Index) /= '#' loop\r\n-            Name_Len := Name_Len + 1;\r\n-            Name_Buffer (Name_Len) := Preset_Names (P_Index);\r\n-            P_Index := P_Index + 1;\r\n-         end loop;\r\n-\r\n-         --  We do the Name_Find call to enter the name into the table, but\r\n-         --  we don't need to do anything with the result, since we already\r\n-         --  initialized all the preset names to have the right value (we\r\n-         --  are depending on the order of the names and Preset_Names).\r\n-\r\n-         Discard_Name := Name_Find;\r\n-         P_Index := P_Index + 1;\r\n-         exit when Preset_Names (P_Index) = '#';\r\n-      end loop;\r\n-\r\n-      --  Make sure that number of names in standard table is correct. If\r\n-      --  this check fails, run utility program XSNAMES to construct a new\r\n-      --  properly matching version of the body.\r\n-\r\n-      pragma Assert (Discard_Name = Last_Predefined_Name);\r\n-\r\n-      --  Initialize the convention identifiers table with the standard\r\n-      --  set of synonyms that we recognize for conventions.\r\n-\r\n-      Convention_Identifiers.Init;\r\n-\r\n-      Convention_Identifiers.Append ((Name_Asm,      Convention_Assembler));\r\n-      Convention_Identifiers.Append ((Name_Assembly, Convention_Assembler));\r\n-\r\n-      Convention_Identifiers.Append ((Name_Default,  Convention_C));\r\n-      Convention_Identifiers.Append ((Name_External, Convention_C));\r\n-\r\n-      Convention_Identifiers.Append ((Name_DLL,      Convention_Stdcall));\r\n-      Convention_Identifiers.Append ((Name_Win32,    Convention_Stdcall));\r\n-   end Initialize;\r\n-\r\n-   -----------------------\r\n-   -- Is_Attribute_Name --\r\n-   -----------------------\r\n-\r\n-   function Is_Attribute_Name (N : Name_Id) return Boolean is\r\n-   begin\r\n-      return N in First_Attribute_Name .. Last_Attribute_Name;\r\n-   end Is_Attribute_Name;\r\n-\r\n-   -------------------\r\n-   -- Is_Check_Name --\r\n-   -------------------\r\n-\r\n-   function Is_Check_Name (N : Name_Id) return Boolean is\r\n-   begin\r\n-      return N in First_Check_Name .. Last_Check_Name;\r\n-   end Is_Check_Name;\r\n-\r\n-   ------------------------\r\n-   -- Is_Convention_Name --\r\n-   ------------------------\r\n-\r\n-   function Is_Convention_Name (N : Name_Id) return Boolean is\r\n-   begin\r\n-      --  Check if this is one of the standard conventions\r\n-\r\n-      if N in First_Convention_Name .. Last_Convention_Name\r\n-        or else N = Name_C\r\n-      then\r\n-         return True;\r\n-\r\n-      --  Otherwise check if it is in convention identifier table\r\n-\r\n-      else\r\n-         for J in 1 .. Convention_Identifiers.Last loop\r\n-            if N = Convention_Identifiers.Table (J).Name then\r\n-               return True;\r\n-            end if;\r\n-         end loop;\r\n-\r\n-         return False;\r\n-      end if;\r\n-   end Is_Convention_Name;\r\n-\r\n-   ------------------------------\r\n-   -- Is_Entity_Attribute_Name --\r\n-   ------------------------------\r\n-\r\n-   function Is_Entity_Attribute_Name (N : Name_Id) return Boolean is\r\n-   begin\r\n-      return N in First_Entity_Attribute_Name .. Last_Entity_Attribute_Name;\r\n-   end Is_Entity_Attribute_Name;\r\n-\r\n-   --------------------------------\r\n-   -- Is_Function_Attribute_Name --\r\n-   --------------------------------\r\n-\r\n-   function Is_Function_Attribute_Name (N : Name_Id) return Boolean is\r\n-   begin\r\n-      return N in\r\n-        First_Renamable_Function_Attribute ..\r\n-          Last_Renamable_Function_Attribute;\r\n-   end Is_Function_Attribute_Name;\r\n-\r\n-   ----------------------------\r\n-   -- Is_Locking_Policy_Name --\r\n-   ----------------------------\r\n-\r\n-   function Is_Locking_Policy_Name (N : Name_Id) return Boolean is\r\n-   begin\r\n-      return N in First_Locking_Policy_Name .. Last_Locking_Policy_Name;\r\n-   end Is_Locking_Policy_Name;\r\n-\r\n-   -----------------------------\r\n-   -- Is_Operator_Symbol_Name --\r\n-   -----------------------------\r\n-\r\n-   function Is_Operator_Symbol_Name (N : Name_Id) return Boolean is\r\n-   begin\r\n-      return N in First_Operator_Name .. Last_Operator_Name;\r\n-   end Is_Operator_Symbol_Name;\r\n-\r\n-   --------------------\r\n-   -- Is_Pragma_Name --\r\n-   --------------------\r\n-\r\n-   function Is_Pragma_Name (N : Name_Id) return Boolean is\r\n-   begin\r\n-      return N in First_Pragma_Name .. Last_Pragma_Name\r\n-        or else N = Name_AST_Entry\r\n-        or else N = Name_Interface\r\n-        or else N = Name_Storage_Size\r\n-        or else N = Name_Storage_Unit;\r\n-   end Is_Pragma_Name;\r\n-\r\n-   ---------------------------------\r\n-   -- Is_Procedure_Attribute_Name --\r\n-   ---------------------------------\r\n-\r\n-   function Is_Procedure_Attribute_Name (N : Name_Id) return Boolean is\r\n-   begin\r\n-      return N in First_Procedure_Attribute .. Last_Procedure_Attribute;\r\n-   end Is_Procedure_Attribute_Name;\r\n-\r\n-   ----------------------------\r\n-   -- Is_Queuing_Policy_Name --\r\n-   ----------------------------\r\n-\r\n-   function Is_Queuing_Policy_Name (N : Name_Id) return Boolean is\r\n-   begin\r\n-      return N in First_Queuing_Policy_Name .. Last_Queuing_Policy_Name;\r\n-   end Is_Queuing_Policy_Name;\r\n-\r\n-   -------------------------------------\r\n-   -- Is_Task_Dispatching_Policy_Name --\r\n-   -------------------------------------\r\n-\r\n-   function Is_Task_Dispatching_Policy_Name (N : Name_Id) return Boolean is\r\n-   begin\r\n-      return N in First_Task_Dispatching_Policy_Name ..\r\n-                  Last_Task_Dispatching_Policy_Name;\r\n-   end Is_Task_Dispatching_Policy_Name;\r\n-\r\n-   ----------------------------\r\n-   -- Is_Type_Attribute_Name --\r\n-   ----------------------------\r\n-\r\n-   function Is_Type_Attribute_Name (N : Name_Id) return Boolean is\r\n-   begin\r\n-      return N in First_Type_Attribute_Name .. Last_Type_Attribute_Name;\r\n-   end Is_Type_Attribute_Name;\r\n-\r\n-   ----------------------------------\r\n-   -- Record_Convention_Identifier --\r\n-   ----------------------------------\r\n-\r\n-   procedure Record_Convention_Identifier\r\n-     (Id         : Name_Id;\r\n-      Convention : Convention_Id)\r\n-   is\r\n-   begin\r\n-      Convention_Identifiers.Append ((Id, Convention));\r\n-   end Record_Convention_Identifier;\r\n-\r\n-end Snames;\r\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                               S N A M E S                                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Namet; use Namet;\n+with Table;\n+\n+package body Snames is\n+\n+   --  Table used to record convention identifiers\n+\n+   type Convention_Id_Entry is record\n+      Name       : Name_Id;\n+      Convention : Convention_Id;\n+   end record;\n+\n+   package Convention_Identifiers is new Table.Table (\n+     Table_Component_Type => Convention_Id_Entry,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 50,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Name_Convention_Identifiers\");\n+\n+   --  Table of names to be set by Initialize. Each name is terminated by a\n+   --  single #, and the end of the list is marked by a null entry, i.e. by\n+   --  two # marks in succession. Note that the table does not include the\n+   --  entries for a-z, since these are initialized by Namet itself.\n+\n+   Preset_Names : constant String :=\n+     \"_parent#\" &\n+     \"_tag#\" &\n+     \"off#\" &\n+     \"space#\" &\n+     \"time#\" &\n+     \"_abort_signal#\" &\n+     \"_alignment#\" &\n+     \"_assign#\" &\n+     \"_atcb#\" &\n+     \"_chain#\" &\n+     \"_clean#\" &\n+     \"_controller#\" &\n+     \"_entry_bodies#\" &\n+     \"_expunge#\" &\n+     \"_final_list#\" &\n+     \"_idepth#\" &\n+     \"_init#\" &\n+     \"_local_final_list#\" &\n+     \"_master#\" &\n+     \"_object#\" &\n+     \"_priority#\" &\n+     \"_process_atsd#\" &\n+     \"_secondary_stack#\" &\n+     \"_service#\" &\n+     \"_size#\" &\n+     \"_stack#\" &\n+     \"_tags#\" &\n+     \"_task#\" &\n+     \"_task_id#\" &\n+     \"_task_info#\" &\n+     \"_task_name#\" &\n+     \"_trace_sp#\" &\n+     \"initialize#\" &\n+     \"adjust#\" &\n+     \"finalize#\" &\n+     \"next#\" &\n+     \"prev#\" &\n+     \"_typecode#\" &\n+     \"_from_any#\" &\n+     \"_to_any#\" &\n+     \"allocate#\" &\n+     \"deallocate#\" &\n+     \"dereference#\" &\n+     \"decimal_io#\" &\n+     \"enumeration_io#\" &\n+     \"fixed_io#\" &\n+     \"float_io#\" &\n+     \"integer_io#\" &\n+     \"modular_io#\" &\n+     \"const#\" &\n+     \"<error>#\" &\n+     \"go#\" &\n+     \"put#\" &\n+     \"put_line#\" &\n+     \"to#\" &\n+     \"finalization#\" &\n+     \"finalization_root#\" &\n+     \"interfaces#\" &\n+     \"standard#\" &\n+     \"system#\" &\n+     \"text_io#\" &\n+     \"wide_text_io#\" &\n+     \"wide_wide_text_io#\" &\n+     \"no_dsa#\" &\n+     \"garlic_dsa#\" &\n+     \"polyorb_dsa#\" &\n+     \"addr#\" &\n+     \"async#\" &\n+     \"get_active_partition_id#\" &\n+     \"get_rci_package_receiver#\" &\n+     \"get_rci_package_ref#\" &\n+     \"origin#\" &\n+     \"params#\" &\n+     \"partition#\" &\n+     \"partition_interface#\" &\n+     \"ras#\" &\n+     \"call#\" &\n+     \"rci_name#\" &\n+     \"receiver#\" &\n+     \"result#\" &\n+     \"rpc#\" &\n+     \"subp_id#\" &\n+     \"operation#\" &\n+     \"argument#\" &\n+     \"arg_modes#\" &\n+     \"handler#\" &\n+     \"target#\" &\n+     \"req#\" &\n+     \"obj_typecode#\" &\n+     \"stub#\" &\n+     \"Oabs#\" &\n+     \"Oand#\" &\n+     \"Omod#\" &\n+     \"Onot#\" &\n+     \"Oor#\" &\n+     \"Orem#\" &\n+     \"Oxor#\" &\n+     \"Oeq#\" &\n+     \"One#\" &\n+     \"Olt#\" &\n+     \"Ole#\" &\n+     \"Ogt#\" &\n+     \"Oge#\" &\n+     \"Oadd#\" &\n+     \"Osubtract#\" &\n+     \"Oconcat#\" &\n+     \"Omultiply#\" &\n+     \"Odivide#\" &\n+     \"Oexpon#\" &\n+     \"ada_83#\" &\n+     \"ada_95#\" &\n+     \"ada_05#\" &\n+     \"c_pass_by_copy#\" &\n+     \"compile_time_warning#\" &\n+     \"component_alignment#\" &\n+     \"convention_identifier#\" &\n+     \"detect_blocking#\" &\n+     \"discard_names#\" &\n+     \"elaboration_checks#\" &\n+     \"eliminate#\" &\n+     \"explicit_overriding#\" &\n+     \"extend_system#\" &\n+     \"extensions_allowed#\" &\n+     \"external_name_casing#\" &\n+     \"float_representation#\" &\n+     \"initialize_scalars#\" &\n+     \"interrupt_state#\" &\n+     \"license#\" &\n+     \"locking_policy#\" &\n+     \"long_float#\" &\n+     \"no_run_time#\" &\n+     \"no_strict_aliasing#\" &\n+     \"normalize_scalars#\" &\n+     \"polling#\" &\n+     \"persistent_data#\" &\n+     \"persistent_object#\" &\n+     \"profile#\" &\n+     \"profile_warnings#\" &\n+     \"propagate_exceptions#\" &\n+     \"queuing_policy#\" &\n+     \"ravenscar#\" &\n+     \"restricted_run_time#\" &\n+     \"restrictions#\" &\n+     \"restriction_warnings#\" &\n+     \"reviewable#\" &\n+     \"source_file_name#\" &\n+     \"source_file_name_project#\" &\n+     \"style_checks#\" &\n+     \"suppress#\" &\n+     \"suppress_exception_locations#\" &\n+     \"task_dispatching_policy#\" &\n+     \"universal_data#\" &\n+     \"unsuppress#\" &\n+     \"use_vads_size#\" &\n+     \"validity_checks#\" &\n+     \"warnings#\" &\n+     \"abort_defer#\" &\n+     \"all_calls_remote#\" &\n+     \"annotate#\" &\n+     \"assert#\" &\n+     \"asynchronous#\" &\n+     \"atomic#\" &\n+     \"atomic_components#\" &\n+     \"attach_handler#\" &\n+     \"comment#\" &\n+     \"common_object#\" &\n+     \"complex_representation#\" &\n+     \"controlled#\" &\n+     \"convention#\" &\n+     \"cpp_class#\" &\n+     \"cpp_constructor#\" &\n+     \"cpp_virtual#\" &\n+     \"cpp_vtable#\" &\n+     \"debug#\" &\n+     \"elaborate#\" &\n+     \"elaborate_all#\" &\n+     \"elaborate_body#\" &\n+     \"export#\" &\n+     \"export_exception#\" &\n+     \"export_function#\" &\n+     \"export_object#\" &\n+     \"export_procedure#\" &\n+     \"export_value#\" &\n+     \"export_valued_procedure#\" &\n+     \"external#\" &\n+     \"finalize_storage_only#\" &\n+     \"ident#\" &\n+     \"import#\" &\n+     \"import_exception#\" &\n+     \"import_function#\" &\n+     \"import_object#\" &\n+     \"import_procedure#\" &\n+     \"import_valued_procedure#\" &\n+     \"inline#\" &\n+     \"inline_always#\" &\n+     \"inline_generic#\" &\n+     \"inspection_point#\" &\n+     \"interface_name#\" &\n+     \"interrupt_handler#\" &\n+     \"interrupt_priority#\" &\n+     \"java_constructor#\" &\n+     \"java_interface#\" &\n+     \"keep_names#\" &\n+     \"link_with#\" &\n+     \"linker_alias#\" &\n+     \"linker_options#\" &\n+     \"linker_section#\" &\n+     \"list#\" &\n+     \"machine_attribute#\" &\n+     \"main#\" &\n+     \"main_storage#\" &\n+     \"memory_size#\" &\n+     \"no_return#\" &\n+     \"obsolescent#\" &\n+     \"optimize#\" &\n+     \"optional_overriding#\" &\n+     \"pack#\" &\n+     \"page#\" &\n+     \"passive#\" &\n+     \"preelaborate#\" &\n+     \"priority#\" &\n+     \"psect_object#\" &\n+     \"pure#\" &\n+     \"pure_function#\" &\n+     \"remote_call_interface#\" &\n+     \"remote_types#\" &\n+     \"share_generic#\" &\n+     \"shared#\" &\n+     \"shared_passive#\" &\n+     \"source_reference#\" &\n+     \"stream_convert#\" &\n+     \"subtitle#\" &\n+     \"suppress_all#\" &\n+     \"suppress_debug_info#\" &\n+     \"suppress_initialization#\" &\n+     \"system_name#\" &\n+     \"task_info#\" &\n+     \"task_name#\" &\n+     \"task_storage#\" &\n+     \"thread_body#\" &\n+     \"time_slice#\" &\n+     \"title#\" &\n+     \"unchecked_union#\" &\n+     \"unimplemented_unit#\" &\n+     \"unreferenced#\" &\n+     \"unreserve_all_interrupts#\" &\n+     \"volatile#\" &\n+     \"volatile_components#\" &\n+     \"weak_external#\" &\n+     \"ada#\" &\n+     \"assembler#\" &\n+     \"cobol#\" &\n+     \"cpp#\" &\n+     \"fortran#\" &\n+     \"intrinsic#\" &\n+     \"java#\" &\n+     \"stdcall#\" &\n+     \"stubbed#\" &\n+     \"asm#\" &\n+     \"assembly#\" &\n+     \"default#\" &\n+     \"dll#\" &\n+     \"win32#\" &\n+     \"as_is#\" &\n+     \"body_file_name#\" &\n+     \"boolean_entry_barriers#\" &\n+     \"casing#\" &\n+     \"code#\" &\n+     \"component#\" &\n+     \"component_size_4#\" &\n+     \"copy#\" &\n+     \"d_float#\" &\n+     \"descriptor#\" &\n+     \"dot_replacement#\" &\n+     \"dynamic#\" &\n+     \"entity#\" &\n+     \"external_name#\" &\n+     \"first_optional_parameter#\" &\n+     \"form#\" &\n+     \"g_float#\" &\n+     \"gcc#\" &\n+     \"gnat#\" &\n+     \"gpl#\" &\n+     \"ieee_float#\" &\n+     \"internal#\" &\n+     \"link_name#\" &\n+     \"lowercase#\" &\n+     \"max_entry_queue_depth#\" &\n+     \"max_entry_queue_length#\" &\n+     \"max_size#\" &\n+     \"mechanism#\" &\n+     \"mixedcase#\" &\n+     \"modified_gpl#\" &\n+     \"name#\" &\n+     \"nca#\" &\n+     \"no#\" &\n+     \"no_dependence#\" &\n+     \"no_dynamic_attachment#\" &\n+     \"no_dynamic_interrupts#\" &\n+     \"no_requeue#\" &\n+     \"no_requeue_statements#\" &\n+     \"no_task_attributes#\" &\n+     \"no_task_attributes_package#\" &\n+     \"on#\" &\n+     \"parameter_types#\" &\n+     \"reference#\" &\n+     \"restricted#\" &\n+     \"result_mechanism#\" &\n+     \"result_type#\" &\n+     \"runtime#\" &\n+     \"sb#\" &\n+     \"secondary_stack_size#\" &\n+     \"section#\" &\n+     \"semaphore#\" &\n+     \"simple_barriers#\" &\n+     \"spec_file_name#\" &\n+     \"static#\" &\n+     \"stack_size#\" &\n+     \"subunit_file_name#\" &\n+     \"task_stack_size_default#\" &\n+     \"task_type#\" &\n+     \"time_slicing_enabled#\" &\n+     \"top_guard#\" &\n+     \"uba#\" &\n+     \"ubs#\" &\n+     \"ubsb#\" &\n+     \"unit_name#\" &\n+     \"unknown#\" &\n+     \"unrestricted#\" &\n+     \"uppercase#\" &\n+     \"user#\" &\n+     \"vax_float#\" &\n+     \"vms#\" &\n+     \"working_storage#\" &\n+     \"abort_signal#\" &\n+     \"access#\" &\n+     \"address#\" &\n+     \"address_size#\" &\n+     \"aft#\" &\n+     \"alignment#\" &\n+     \"asm_input#\" &\n+     \"asm_output#\" &\n+     \"ast_entry#\" &\n+     \"bit#\" &\n+     \"bit_order#\" &\n+     \"bit_position#\" &\n+     \"body_version#\" &\n+     \"callable#\" &\n+     \"caller#\" &\n+     \"code_address#\" &\n+     \"component_size#\" &\n+     \"compose#\" &\n+     \"constrained#\" &\n+     \"count#\" &\n+     \"default_bit_order#\" &\n+     \"definite#\" &\n+     \"delta#\" &\n+     \"denorm#\" &\n+     \"digits#\" &\n+     \"elaborated#\" &\n+     \"emax#\" &\n+     \"enum_rep#\" &\n+     \"epsilon#\" &\n+     \"exponent#\" &\n+     \"external_tag#\" &\n+     \"first#\" &\n+     \"first_bit#\" &\n+     \"fixed_value#\" &\n+     \"fore#\" &\n+     \"has_access_values#\" &\n+     \"has_discriminants#\" &\n+     \"identity#\" &\n+     \"img#\" &\n+     \"integer_value#\" &\n+     \"large#\" &\n+     \"last#\" &\n+     \"last_bit#\" &\n+     \"leading_part#\" &\n+     \"length#\" &\n+     \"machine_emax#\" &\n+     \"machine_emin#\" &\n+     \"machine_mantissa#\" &\n+     \"machine_overflows#\" &\n+     \"machine_radix#\" &\n+     \"machine_rounds#\" &\n+     \"machine_size#\" &\n+     \"mantissa#\" &\n+     \"max_size_in_storage_elements#\" &\n+     \"maximum_alignment#\" &\n+     \"mechanism_code#\" &\n+     \"mod#\" &\n+     \"model_emin#\" &\n+     \"model_epsilon#\" &\n+     \"model_mantissa#\" &\n+     \"model_small#\" &\n+     \"modulus#\" &\n+     \"null_parameter#\" &\n+     \"object_size#\" &\n+     \"partition_id#\" &\n+     \"passed_by_reference#\" &\n+     \"pool_address#\" &\n+     \"pos#\" &\n+     \"position#\" &\n+     \"range#\" &\n+     \"range_length#\" &\n+     \"round#\" &\n+     \"safe_emax#\" &\n+     \"safe_first#\" &\n+     \"safe_large#\" &\n+     \"safe_last#\" &\n+     \"safe_small#\" &\n+     \"scale#\" &\n+     \"scaling#\" &\n+     \"signed_zeros#\" &\n+     \"size#\" &\n+     \"small#\" &\n+     \"storage_size#\" &\n+     \"storage_unit#\" &\n+     \"stream_size#\" &\n+     \"tag#\" &\n+     \"target_name#\" &\n+     \"terminated#\" &\n+     \"to_address#\" &\n+     \"type_class#\" &\n+     \"uet_address#\" &\n+     \"unbiased_rounding#\" &\n+     \"unchecked_access#\" &\n+     \"unconstrained_array#\" &\n+     \"universal_literal_string#\" &\n+     \"unrestricted_access#\" &\n+     \"vads_size#\" &\n+     \"val#\" &\n+     \"valid#\" &\n+     \"value_size#\" &\n+     \"version#\" &\n+     \"wchar_t_size#\" &\n+     \"wide_wide_width#\" &\n+     \"wide_width#\" &\n+     \"width#\" &\n+     \"word_size#\" &\n+     \"adjacent#\" &\n+     \"ceiling#\" &\n+     \"copy_sign#\" &\n+     \"floor#\" &\n+     \"fraction#\" &\n+     \"image#\" &\n+     \"input#\" &\n+     \"machine#\" &\n+     \"max#\" &\n+     \"min#\" &\n+     \"model#\" &\n+     \"pred#\" &\n+     \"remainder#\" &\n+     \"rounding#\" &\n+     \"succ#\" &\n+     \"truncation#\" &\n+     \"value#\" &\n+     \"wide_image#\" &\n+     \"wide_wide_image#\" &\n+     \"wide_value#\" &\n+     \"wide_wide_value#\" &\n+     \"output#\" &\n+     \"read#\" &\n+     \"write#\" &\n+     \"elab_body#\" &\n+     \"elab_spec#\" &\n+     \"storage_pool#\" &\n+     \"base#\" &\n+     \"class#\" &\n+     \"ceiling_locking#\" &\n+     \"inheritance_locking#\" &\n+     \"fifo_queuing#\" &\n+     \"priority_queuing#\" &\n+     \"fifo_within_priorities#\" &\n+     \"access_check#\" &\n+     \"accessibility_check#\" &\n+     \"discriminant_check#\" &\n+     \"division_check#\" &\n+     \"elaboration_check#\" &\n+     \"index_check#\" &\n+     \"length_check#\" &\n+     \"overflow_check#\" &\n+     \"range_check#\" &\n+     \"storage_check#\" &\n+     \"tag_check#\" &\n+     \"all_checks#\" &\n+     \"abort#\" &\n+     \"abs#\" &\n+     \"accept#\" &\n+     \"and#\" &\n+     \"all#\" &\n+     \"array#\" &\n+     \"at#\" &\n+     \"begin#\" &\n+     \"body#\" &\n+     \"case#\" &\n+     \"constant#\" &\n+     \"declare#\" &\n+     \"delay#\" &\n+     \"do#\" &\n+     \"else#\" &\n+     \"elsif#\" &\n+     \"end#\" &\n+     \"entry#\" &\n+     \"exception#\" &\n+     \"exit#\" &\n+     \"for#\" &\n+     \"function#\" &\n+     \"generic#\" &\n+     \"goto#\" &\n+     \"if#\" &\n+     \"in#\" &\n+     \"is#\" &\n+     \"limited#\" &\n+     \"loop#\" &\n+     \"new#\" &\n+     \"not#\" &\n+     \"null#\" &\n+     \"of#\" &\n+     \"or#\" &\n+     \"others#\" &\n+     \"out#\" &\n+     \"package#\" &\n+     \"pragma#\" &\n+     \"private#\" &\n+     \"procedure#\" &\n+     \"raise#\" &\n+     \"record#\" &\n+     \"rem#\" &\n+     \"renames#\" &\n+     \"return#\" &\n+     \"reverse#\" &\n+     \"select#\" &\n+     \"separate#\" &\n+     \"subtype#\" &\n+     \"task#\" &\n+     \"terminate#\" &\n+     \"then#\" &\n+     \"type#\" &\n+     \"use#\" &\n+     \"when#\" &\n+     \"while#\" &\n+     \"with#\" &\n+     \"xor#\" &\n+     \"divide#\" &\n+     \"enclosing_entity#\" &\n+     \"exception_information#\" &\n+     \"exception_message#\" &\n+     \"exception_name#\" &\n+     \"file#\" &\n+     \"import_address#\" &\n+     \"import_largest_value#\" &\n+     \"import_value#\" &\n+     \"is_negative#\" &\n+     \"line#\" &\n+     \"rotate_left#\" &\n+     \"rotate_right#\" &\n+     \"shift_left#\" &\n+     \"shift_right#\" &\n+     \"shift_right_arithmetic#\" &\n+     \"source_location#\" &\n+     \"unchecked_conversion#\" &\n+     \"unchecked_deallocation#\" &\n+     \"to_pointer#\" &\n+     \"abstract#\" &\n+     \"aliased#\" &\n+     \"protected#\" &\n+     \"until#\" &\n+     \"requeue#\" &\n+     \"tagged#\" &\n+     \"raise_exception#\" &\n+     \"ada_roots#\" &\n+     \"binder#\" &\n+     \"binder_driver#\" &\n+     \"body_suffix#\" &\n+     \"builder#\" &\n+     \"compiler#\" &\n+     \"compiler_driver#\" &\n+     \"compiler_kind#\" &\n+     \"compute_dependency#\" &\n+     \"cross_reference#\" &\n+     \"default_linker#\" &\n+     \"default_switches#\" &\n+     \"dependency_option#\" &\n+     \"exec_dir#\" &\n+     \"executable#\" &\n+     \"executable_suffix#\" &\n+     \"extends#\" &\n+     \"externally_built#\" &\n+     \"finder#\" &\n+     \"global_configuration_pragmas#\" &\n+     \"gnatls#\" &\n+     \"gnatstub#\" &\n+     \"implementation#\" &\n+     \"implementation_exceptions#\" &\n+     \"implementation_suffix#\" &\n+     \"include_option#\" &\n+     \"language_processing#\" &\n+     \"languages#\" &\n+     \"library_dir#\" &\n+     \"library_auto_init#\" &\n+     \"library_gcc#\" &\n+     \"library_interface#\" &\n+     \"library_kind#\" &\n+     \"library_name#\" &\n+     \"library_options#\" &\n+     \"library_reference_symbol_file#\" &\n+     \"library_src_dir#\" &\n+     \"library_symbol_file#\" &\n+     \"library_symbol_policy#\" &\n+     \"library_version#\" &\n+     \"linker#\" &\n+     \"local_configuration_pragmas#\" &\n+     \"locally_removed_files#\" &\n+     \"metrics#\" &\n+     \"naming#\" &\n+     \"object_dir#\" &\n+     \"pretty_printer#\" &\n+     \"project#\" &\n+     \"separate_suffix#\" &\n+     \"source_dirs#\" &\n+     \"source_files#\" &\n+     \"source_list_file#\" &\n+     \"spec#\" &\n+     \"spec_suffix#\" &\n+     \"specification#\" &\n+     \"specification_exceptions#\" &\n+     \"specification_suffix#\" &\n+     \"switches#\" &\n+     \"unaligned_valid#\" &\n+     \"interface#\" &\n+     \"overriding#\" &\n+     \"synchronized#\" &\n+     \"#\";\n+\n+   ---------------------\n+   -- Generated Names --\n+   ---------------------\n+\n+   --  This section lists the various cases of generated names which are\n+   --  built from existing names by adding unique leading and/or trailing\n+   --  upper case letters. In some cases these names are built recursively,\n+   --  in particular names built from types may be built from types which\n+   --  themselves have generated names. In this list, xxx represents an\n+   --  existing name to which identifying letters are prepended or appended,\n+   --  and a trailing n represents a serial number in an external name that\n+   --  has some semantic significance (e.g. the n'th index type of an array).\n+\n+   --    xxxA    access type for formal xxx in entry param record   (Exp_Ch9)\n+   --    xxxB    tag table for tagged type xxx                      (Exp_Ch3)\n+   --    xxxB    task body procedure for task xxx                   (Exp_Ch9)\n+   --    xxxD    dispatch table for tagged type xxx                 (Exp_Ch3)\n+   --    xxxD    discriminal for discriminant xxx                   (Sem_Ch3)\n+   --    xxxDn   n'th discr check function for rec type xxx         (Exp_Ch3)\n+   --    xxxE    elaboration boolean flag for task xxx              (Exp_Ch9)\n+   --    xxxE    dispatch table pointer type for tagged type xxx    (Exp_Ch3)\n+   --    xxxE    parameters for accept body for entry xxx           (Exp_Ch9)\n+   --    xxxFn   n'th primitive of a tagged type (named xxx)        (Exp_Ch3)\n+   --    xxxJ    tag table type index for tagged type xxx           (Exp_Ch3)\n+   --    xxxM    master Id value for access type xxx                (Exp_Ch3)\n+   --    xxxP    tag table pointer type for tagged type xxx         (Exp_Ch3)\n+   --    xxxP    parameter record type for entry xxx                (Exp_Ch9)\n+   --    xxxPA   access to parameter record type for entry xxx      (Exp_Ch9)\n+   --    xxxPn   pointer type for n'th primitive of tagged type xxx (Exp_Ch3)\n+   --    xxxR    dispatch table pointer for tagged type xxx         (Exp_Ch3)\n+   --    xxxT    tag table type for tagged type xxx                 (Exp_Ch3)\n+   --    xxxT    literal table for enumeration type xxx             (Sem_Ch3)\n+   --    xxxV    type for task value record for task xxx            (Exp_Ch9)\n+   --    xxxX    entry index constant                               (Exp_Ch9)\n+   --    xxxY    dispatch table type for tagged type xxx            (Exp_Ch3)\n+   --    xxxZ    size variable for task xxx                         (Exp_Ch9)\n+\n+   --  TSS names\n+\n+   --    xxxDA   deep adjust routine for type xxx                   (Exp_TSS)\n+   --    xxxDF   deep finalize routine for type xxx                 (Exp_TSS)\n+   --    xxxDI   deep initialize routine for type xxx               (Exp_TSS)\n+   --    xxxEQ   composite equality routine for record type xxx     (Exp_TSS)\n+   --    xxxIP   initialization procedure for type xxx              (Exp_TSS)\n+   --    xxxRA   RAs type access routine for type xxx               (Exp_TSS)\n+   --    xxxRD   RAs type dereference routine for type xxx          (Exp_TSS)\n+   --    xxxRP   Rep to Pos conversion for enumeration type xxx     (Exp_TSS)\n+   --    xxxSA   array/slice assignment for controlled comp. arrays (Exp_TSS)\n+   --    xxxSI   stream input attribute subprogram for type xxx     (Exp_TSS)\n+   --    xxxSO   stream output attribute subprogram for type xxx    (Exp_TSS)\n+   --    xxxSR   stream read attribute subprogram for type xxx      (Exp_TSS)\n+   --    xxxSW   stream write attribute subprogram for type xxx     (Exp_TSS)\n+\n+   --  Implicit type names\n+\n+   --    TxxxT   type of literal table for enumeration type xxx     (Sem_Ch3)\n+\n+   --  (Note: this list is not complete or accurate ???)\n+\n+   ----------------------\n+   -- Get_Attribute_Id --\n+   ----------------------\n+\n+   function Get_Attribute_Id (N : Name_Id) return Attribute_Id is\n+   begin\n+      return Attribute_Id'Val (N - First_Attribute_Name);\n+   end Get_Attribute_Id;\n+\n+   ------------------\n+   -- Get_Check_Id --\n+   ------------------\n+\n+   function Get_Check_Id (N : Name_Id) return Check_Id is\n+   begin\n+      return Check_Id'Val (N - First_Check_Name);\n+   end Get_Check_Id;\n+\n+   -----------------------\n+   -- Get_Convention_Id --\n+   -----------------------\n+\n+   function Get_Convention_Id (N : Name_Id) return Convention_Id is\n+   begin\n+      case N is\n+         when Name_Ada        => return Convention_Ada;\n+         when Name_Assembler  => return Convention_Assembler;\n+         when Name_C          => return Convention_C;\n+         when Name_COBOL      => return Convention_COBOL;\n+         when Name_CPP        => return Convention_CPP;\n+         when Name_Fortran    => return Convention_Fortran;\n+         when Name_Intrinsic  => return Convention_Intrinsic;\n+         when Name_Java       => return Convention_Java;\n+         when Name_Stdcall    => return Convention_Stdcall;\n+         when Name_Stubbed    => return Convention_Stubbed;\n+\n+         --  If no direct match, then we must have a convention\n+         --  identifier pragma that has specified this name.\n+\n+         when others          =>\n+            for J in 1 .. Convention_Identifiers.Last loop\n+               if N = Convention_Identifiers.Table (J).Name then\n+                  return Convention_Identifiers.Table (J).Convention;\n+               end if;\n+            end loop;\n+\n+            raise Program_Error;\n+      end case;\n+   end Get_Convention_Id;\n+\n+   ---------------------------\n+   -- Get_Locking_Policy_Id --\n+   ---------------------------\n+\n+   function Get_Locking_Policy_Id (N : Name_Id) return Locking_Policy_Id is\n+   begin\n+      return Locking_Policy_Id'Val (N - First_Locking_Policy_Name);\n+   end Get_Locking_Policy_Id;\n+\n+   -------------------\n+   -- Get_Pragma_Id --\n+   -------------------\n+\n+   function Get_Pragma_Id (N : Name_Id) return Pragma_Id is\n+   begin\n+      if N = Name_AST_Entry then\n+         return Pragma_AST_Entry;\n+      elsif N = Name_Interface then\n+         return Pragma_Interface;\n+      elsif N = Name_Storage_Size then\n+         return Pragma_Storage_Size;\n+      elsif N = Name_Storage_Unit then\n+         return Pragma_Storage_Unit;\n+      elsif N not in First_Pragma_Name .. Last_Pragma_Name then\n+         return Unknown_Pragma;\n+      else\n+         return Pragma_Id'Val (N - First_Pragma_Name);\n+      end if;\n+   end Get_Pragma_Id;\n+\n+   ---------------------------\n+   -- Get_Queuing_Policy_Id --\n+   ---------------------------\n+\n+   function Get_Queuing_Policy_Id (N : Name_Id) return Queuing_Policy_Id is\n+   begin\n+      return Queuing_Policy_Id'Val (N - First_Queuing_Policy_Name);\n+   end Get_Queuing_Policy_Id;\n+\n+   ------------------------------------\n+   -- Get_Task_Dispatching_Policy_Id --\n+   ------------------------------------\n+\n+   function Get_Task_Dispatching_Policy_Id (N : Name_Id)\n+     return Task_Dispatching_Policy_Id is\n+   begin\n+      return Task_Dispatching_Policy_Id'Val\n+        (N - First_Task_Dispatching_Policy_Name);\n+   end Get_Task_Dispatching_Policy_Id;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+      P_Index      : Natural;\n+      Discard_Name : Name_Id;\n+\n+   begin\n+      P_Index := Preset_Names'First;\n+\n+      loop\n+         Name_Len := 0;\n+\n+         while Preset_Names (P_Index) /= '#' loop\n+            Name_Len := Name_Len + 1;\n+            Name_Buffer (Name_Len) := Preset_Names (P_Index);\n+            P_Index := P_Index + 1;\n+         end loop;\n+\n+         --  We do the Name_Find call to enter the name into the table, but\n+         --  we don't need to do anything with the result, since we already\n+         --  initialized all the preset names to have the right value (we\n+         --  are depending on the order of the names and Preset_Names).\n+\n+         Discard_Name := Name_Find;\n+         P_Index := P_Index + 1;\n+         exit when Preset_Names (P_Index) = '#';\n+      end loop;\n+\n+      --  Make sure that number of names in standard table is correct. If\n+      --  this check fails, run utility program XSNAMES to construct a new\n+      --  properly matching version of the body.\n+\n+      pragma Assert (Discard_Name = Last_Predefined_Name);\n+\n+      --  Initialize the convention identifiers table with the standard\n+      --  set of synonyms that we recognize for conventions.\n+\n+      Convention_Identifiers.Init;\n+\n+      Convention_Identifiers.Append ((Name_Asm,      Convention_Assembler));\n+      Convention_Identifiers.Append ((Name_Assembly, Convention_Assembler));\n+\n+      Convention_Identifiers.Append ((Name_Default,  Convention_C));\n+      Convention_Identifiers.Append ((Name_External, Convention_C));\n+\n+      Convention_Identifiers.Append ((Name_DLL,      Convention_Stdcall));\n+      Convention_Identifiers.Append ((Name_Win32,    Convention_Stdcall));\n+   end Initialize;\n+\n+   -----------------------\n+   -- Is_Attribute_Name --\n+   -----------------------\n+\n+   function Is_Attribute_Name (N : Name_Id) return Boolean is\n+   begin\n+      return N in First_Attribute_Name .. Last_Attribute_Name;\n+   end Is_Attribute_Name;\n+\n+   -------------------\n+   -- Is_Check_Name --\n+   -------------------\n+\n+   function Is_Check_Name (N : Name_Id) return Boolean is\n+   begin\n+      return N in First_Check_Name .. Last_Check_Name;\n+   end Is_Check_Name;\n+\n+   ------------------------\n+   -- Is_Convention_Name --\n+   ------------------------\n+\n+   function Is_Convention_Name (N : Name_Id) return Boolean is\n+   begin\n+      --  Check if this is one of the standard conventions\n+\n+      if N in First_Convention_Name .. Last_Convention_Name\n+        or else N = Name_C\n+      then\n+         return True;\n+\n+      --  Otherwise check if it is in convention identifier table\n+\n+      else\n+         for J in 1 .. Convention_Identifiers.Last loop\n+            if N = Convention_Identifiers.Table (J).Name then\n+               return True;\n+            end if;\n+         end loop;\n+\n+         return False;\n+      end if;\n+   end Is_Convention_Name;\n+\n+   ------------------------------\n+   -- Is_Entity_Attribute_Name --\n+   ------------------------------\n+\n+   function Is_Entity_Attribute_Name (N : Name_Id) return Boolean is\n+   begin\n+      return N in First_Entity_Attribute_Name .. Last_Entity_Attribute_Name;\n+   end Is_Entity_Attribute_Name;\n+\n+   --------------------------------\n+   -- Is_Function_Attribute_Name --\n+   --------------------------------\n+\n+   function Is_Function_Attribute_Name (N : Name_Id) return Boolean is\n+   begin\n+      return N in\n+        First_Renamable_Function_Attribute ..\n+          Last_Renamable_Function_Attribute;\n+   end Is_Function_Attribute_Name;\n+\n+   ----------------------------\n+   -- Is_Locking_Policy_Name --\n+   ----------------------------\n+\n+   function Is_Locking_Policy_Name (N : Name_Id) return Boolean is\n+   begin\n+      return N in First_Locking_Policy_Name .. Last_Locking_Policy_Name;\n+   end Is_Locking_Policy_Name;\n+\n+   -----------------------------\n+   -- Is_Operator_Symbol_Name --\n+   -----------------------------\n+\n+   function Is_Operator_Symbol_Name (N : Name_Id) return Boolean is\n+   begin\n+      return N in First_Operator_Name .. Last_Operator_Name;\n+   end Is_Operator_Symbol_Name;\n+\n+   --------------------\n+   -- Is_Pragma_Name --\n+   --------------------\n+\n+   function Is_Pragma_Name (N : Name_Id) return Boolean is\n+   begin\n+      return N in First_Pragma_Name .. Last_Pragma_Name\n+        or else N = Name_AST_Entry\n+        or else N = Name_Interface\n+        or else N = Name_Storage_Size\n+        or else N = Name_Storage_Unit;\n+   end Is_Pragma_Name;\n+\n+   ---------------------------------\n+   -- Is_Procedure_Attribute_Name --\n+   ---------------------------------\n+\n+   function Is_Procedure_Attribute_Name (N : Name_Id) return Boolean is\n+   begin\n+      return N in First_Procedure_Attribute .. Last_Procedure_Attribute;\n+   end Is_Procedure_Attribute_Name;\n+\n+   ----------------------------\n+   -- Is_Queuing_Policy_Name --\n+   ----------------------------\n+\n+   function Is_Queuing_Policy_Name (N : Name_Id) return Boolean is\n+   begin\n+      return N in First_Queuing_Policy_Name .. Last_Queuing_Policy_Name;\n+   end Is_Queuing_Policy_Name;\n+\n+   -------------------------------------\n+   -- Is_Task_Dispatching_Policy_Name --\n+   -------------------------------------\n+\n+   function Is_Task_Dispatching_Policy_Name (N : Name_Id) return Boolean is\n+   begin\n+      return N in First_Task_Dispatching_Policy_Name ..\n+                  Last_Task_Dispatching_Policy_Name;\n+   end Is_Task_Dispatching_Policy_Name;\n+\n+   ----------------------------\n+   -- Is_Type_Attribute_Name --\n+   ----------------------------\n+\n+   function Is_Type_Attribute_Name (N : Name_Id) return Boolean is\n+   begin\n+      return N in First_Type_Attribute_Name .. Last_Type_Attribute_Name;\n+   end Is_Type_Attribute_Name;\n+\n+   ----------------------------------\n+   -- Record_Convention_Identifier --\n+   ----------------------------------\n+\n+   procedure Record_Convention_Identifier\n+     (Id         : Name_Id;\n+      Convention : Convention_Id)\n+   is\n+   begin\n+      Convention_Identifiers.Append ((Id, Convention));\n+   end Record_Convention_Identifier;\n+\n+end Snames;"}, {"sha": "9b79ae448dc2680ee1e888556ffc9031a1e7c80c", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 1496, "deletions": 1496, "changes": 2992, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229"}, {"sha": "740ad785aa238b09ce2313c7411be56103eb6523", "filename": "gcc/ada/tbuild.ads", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Ftbuild.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Ftbuild.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.ads?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -72,16 +72,16 @@ package Tbuild is\n    function Make_DT_Component\n      (Loc  : Source_Ptr;\n       Typ  : Entity_Id;\n-      I    : Positive) return Node_Id;\n-   --  Gives a reference to the Ith component of the Dispatch Table of\n+      N    : Positive) return Node_Id;\n+   --  Gives a reference to the Nth component of the Dispatch Table of\n    --  a given Tagged Type.\n    --\n-   --  I = 1    --> Inheritance_Depth\n-   --  I = 2    --> Tags (array of ancestors)\n-   --  I = 3, 4 --> predefined primitive\n+   --  N = 1    --> Inheritance_Depth\n+   --  N = 2    --> Tags (array of ancestors)\n+   --  N = 3, 4 --> predefined primitive\n    --            function _Size (X : Typ) return Long_Long_Integer;\n    --            function _Equality (X : Typ; Y : Typ'Class) return Boolean;\n-   --  I >= 5   --> User-Defined Primitive Operations\n+   --  N >= 5   --> User-Defined Primitive Operations\n \n    function Make_DT_Access\n      (Loc : Source_Ptr; Rec : Node_Id; Typ : Entity_Id) return Node_Id;"}, {"sha": "787d01e284a19353f06ae19a549b90c20c12e581", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a49cf99b76257b0a6e66021f97f05d292065229/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=1a49cf99b76257b0a6e66021f97f05d292065229", "patch": "@@ -679,9 +679,9 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t\t || (TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n \t\t     == ARRAY_TYPE))\n \t     && (0 == (best_type\n-\t\t       == find_common_type (right_type,\n-\t\t\t\t\t    TREE_TYPE (TREE_OPERAND\n-\t\t\t\t\t\t       (right_operand, 0))))\n+\t\t       = find_common_type (right_type,\n+\t\t\t\t\t   TREE_TYPE (TREE_OPERAND\n+\t\t\t\t\t   (right_operand, 0))))\n \t\t || right_type != best_type))\n \t{\n \t  right_operand = TREE_OPERAND (right_operand, 0);"}]}