{"sha": "a79420f995764129dc40d1abcbf8ce75a0b0f906", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc5NDIwZjk5NTc2NDEyOWRjNDBkMWFiY2JmOGNlNzVhMGIwZjkwNg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-05-06T07:23:03Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-05-06T07:23:03Z"}, "message": "Split part of functionality from lto.c to lto-common.c.\n\n2019-05-06  Martin Liska  <mliska@suse.cz>\n\t    Hrishikesh Kulkarni  <hrishikeshparag@gmail.com>\n\n\t* Make-lang.in: Add lto-common.o.\n\t* config-lang.in: Likewise for gtfiles.\n\t* lto-common.c: New file.\n\t* lto-common.h: New file.\n\t* lto-lang.c: Include lto-common.h.\n\t* lto.c: Move most of the functionality\n\tinto lto-common.c file.\n\nCo-Authored-By: Hrishikesh Kulkarni <hrishikeshparag@gmail.com>\n\nFrom-SVN: r270896", "tree": {"sha": "0526b8bb26dbc7954ff2600528da1c83fb3d1c55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0526b8bb26dbc7954ff2600528da1c83fb3d1c55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a79420f995764129dc40d1abcbf8ce75a0b0f906", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a79420f995764129dc40d1abcbf8ce75a0b0f906", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a79420f995764129dc40d1abcbf8ce75a0b0f906", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a79420f995764129dc40d1abcbf8ce75a0b0f906/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2bf6d93547e516b6b2b2051c0fb1b47ea4acc8a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf6d93547e516b6b2b2051c0fb1b47ea4acc8a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bf6d93547e516b6b2b2051c0fb1b47ea4acc8a4"}], "stats": {"total": 5723, "additions": 2910, "deletions": 2813}, "files": [{"sha": "527d856ef3df4f443437ed9216e79ea81bcc26ad", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79420f995764129dc40d1abcbf8ce75a0b0f906/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79420f995764129dc40d1abcbf8ce75a0b0f906/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=a79420f995764129dc40d1abcbf8ce75a0b0f906", "patch": "@@ -1,3 +1,14 @@\n+2019-05-06  Martin Liska  <mliska@suse.cz>\n+\t    Hrishikesh Kulkarni  <hrishikeshparag@gmail.com>\n+\n+\t* Make-lang.in: Add lto-common.o.\n+\t* config-lang.in: Likewise for gtfiles.\n+\t* lto-common.c: New file.\n+\t* lto-common.h: New file.\n+\t* lto-lang.c: Include lto-common.h.\n+\t* lto.c: Move most of the functionality\n+\tinto lto-common.c file.\n+\n 2019-04-12  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (do_stream_out): rename to ..."}, {"sha": "b7ed96eac29071da6c1844e8355e64fd32aeaa77", "filename": "gcc/lto/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79420f995764129dc40d1abcbf8ce75a0b0f906/gcc%2Flto%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79420f995764129dc40d1abcbf8ce75a0b0f906/gcc%2Flto%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FMake-lang.in?ref=a79420f995764129dc40d1abcbf8ce75a0b0f906", "patch": "@@ -22,7 +22,7 @@\n # The name of the LTO compiler.\n LTO_EXE = lto1$(exeext)\n # The LTO-specific object files inclued in $(LTO_EXE).\n-LTO_OBJS = lto/lto-lang.o lto/lto.o lto/lto-object.o attribs.o lto/lto-partition.o lto/lto-symtab.o\n+LTO_OBJS = lto/lto-lang.o lto/lto.o lto/lto-object.o attribs.o lto/lto-partition.o lto/lto-symtab.o lto/lto-common.o\n lto_OBJS = $(LTO_OBJS)\n \n # this is only useful in a LTO bootstrap, but this does not work right"}, {"sha": "07214365fd8224b1539a37546263e407545018b1", "filename": "gcc/lto/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79420f995764129dc40d1abcbf8ce75a0b0f906/gcc%2Flto%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79420f995764129dc40d1abcbf8ce75a0b0f906/gcc%2Flto%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Fconfig-lang.in?ref=a79420f995764129dc40d1abcbf8ce75a0b0f906", "patch": "@@ -20,7 +20,7 @@\n language=\"lto\"\n compilers=\"lto1\\$(exeext)\"\n \n-gtfiles=\"\\$(srcdir)/lto/lto-tree.h \\$(srcdir)/lto/lto-lang.c \\$(srcdir)/lto/lto.c \\$(srcdir)/lto/lto.h\"\n+gtfiles=\"\\$(srcdir)/lto/lto-tree.h \\$(srcdir)/lto/lto-lang.c \\$(srcdir)/lto/lto.c \\$(srcdir)/lto/lto.h \\$(srcdir)/lto/lto-common.h \\$(srcdir)/lto/lto-common.c\"\n \n # LTO is a special front end.  From a user's perspective it is not\n # really a language, but a middle end feature.  However, the GIMPLE"}, {"sha": "9d5b034729ee0429291a332d14ac5f62b6abded4", "filename": "gcc/lto/lto-common.c", "status": "added", "additions": 2837, "deletions": 0, "changes": 2837, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79420f995764129dc40d1abcbf8ce75a0b0f906/gcc%2Flto%2Flto-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79420f995764129dc40d1abcbf8ce75a0b0f906/gcc%2Flto%2Flto-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-common.c?ref=a79420f995764129dc40d1abcbf8ce75a0b0f906", "patch": "@@ -0,0 +1,2837 @@\n+/* Top-level LTO routines.\n+   Copyright (C) 2009-2018 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"function.h\"\n+#include \"bitmap.h\"\n+#include \"basic-block.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"cfghooks.h\"\n+#include \"alloc-pool.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-streamer.h\"\n+#include \"cgraph.h\"\n+#include \"opts.h\"\n+#include \"toplev.h\"\n+#include \"stor-layout.h\"\n+#include \"symbol-summary.h\"\n+#include \"tree-vrp.h\"\n+#include \"ipa-prop.h\"\n+#include \"common.h\"\n+#include \"debug.h\"\n+#include \"lto.h\"\n+#include \"lto-section-names.h\"\n+#include \"splay-tree.h\"\n+#include \"lto-partition.h\"\n+#include \"context.h\"\n+#include \"pass_manager.h\"\n+#include \"ipa-fnsummary.h\"\n+#include \"params.h\"\n+#include \"ipa-utils.h\"\n+#include \"gomp-constants.h\"\n+#include \"lto-symtab.h\"\n+#include \"stringpool.h\"\n+#include \"fold-const.h\"\n+#include \"attribs.h\"\n+#include \"builtins.h\"\n+#include \"lto-common.h\"\n+\n+GTY(()) tree first_personality_decl;\n+\n+GTY(()) const unsigned char *lto_mode_identity_table;\n+\n+/* Returns a hash code for P.  */\n+\n+static hashval_t\n+hash_name (const void *p)\n+{\n+  const struct lto_section_slot *ds = (const struct lto_section_slot *) p;\n+  return (hashval_t) htab_hash_string (ds->name);\n+}\n+\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+static int\n+eq_name (const void *p1, const void *p2)\n+{\n+  const struct lto_section_slot *s1 =\n+    (const struct lto_section_slot *) p1;\n+  const struct lto_section_slot *s2 =\n+    (const struct lto_section_slot *) p2;\n+\n+  return strcmp (s1->name, s2->name) == 0;\n+}\n+\n+/* Free lto_section_slot */\n+\n+static void\n+free_with_string (void *arg)\n+{\n+  struct lto_section_slot *s = (struct lto_section_slot *)arg;\n+\n+  free (CONST_CAST (char *, s->name));\n+  free (arg);\n+}\n+\n+/* Create section hash table */\n+\n+htab_t \n+lto_obj_create_section_hash_table (void)\n+{\n+  return htab_create (37, hash_name, eq_name, free_with_string);\n+}\n+\n+/* Delete an allocated integer KEY in the splay tree.  */\n+\n+static void\n+lto_splay_tree_delete_id (splay_tree_key key)\n+{\n+  free ((void *) key);\n+}\n+\n+/* Compare splay tree node ids A and B.  */\n+\n+static int\n+lto_splay_tree_compare_ids (splay_tree_key a, splay_tree_key b)\n+{\n+  unsigned HOST_WIDE_INT ai;\n+  unsigned HOST_WIDE_INT bi;\n+\n+  ai = *(unsigned HOST_WIDE_INT *) a;\n+  bi = *(unsigned HOST_WIDE_INT *) b;\n+\n+  if (ai < bi)\n+    return -1;\n+  else if (ai > bi)\n+    return 1;\n+  return 0;\n+}\n+\n+/* Look up splay tree node by ID in splay tree T.  */\n+\n+static splay_tree_node\n+lto_splay_tree_lookup (splay_tree t, unsigned HOST_WIDE_INT id)\n+{\n+  return splay_tree_lookup (t, (splay_tree_key) &id);\n+}\n+\n+/* Check if KEY has ID.  */\n+\n+static bool\n+lto_splay_tree_id_equal_p (splay_tree_key key, unsigned HOST_WIDE_INT id)\n+{\n+  return *(unsigned HOST_WIDE_INT *) key == id;\n+}\n+\n+/* Insert a splay tree node into tree T with ID as key and FILE_DATA as value. \n+   The ID is allocated separately because we need HOST_WIDE_INTs which may\n+   be wider than a splay_tree_key. */\n+\n+static void\n+lto_splay_tree_insert (splay_tree t, unsigned HOST_WIDE_INT id,\n+\t\t       struct lto_file_decl_data *file_data)\n+{\n+  unsigned HOST_WIDE_INT *idp = XCNEW (unsigned HOST_WIDE_INT);\n+  *idp = id;\n+  splay_tree_insert (t, (splay_tree_key) idp, (splay_tree_value) file_data);\n+}\n+\n+/* Create a splay tree.  */\n+\n+static splay_tree\n+lto_splay_tree_new (void)\n+{\n+  return splay_tree_new (lto_splay_tree_compare_ids,\n+\t \t         lto_splay_tree_delete_id,\n+\t\t\t NULL);\n+}\n+\n+/* Decode the content of memory pointed to by DATA in the in decl\n+   state object STATE. DATA_IN points to a data_in structure for\n+   decoding. Return the address after the decoded object in the\n+   input.  */\n+\n+static const uint32_t *\n+lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n+\t\t\tstruct lto_in_decl_state *state)\n+{\n+  uint32_t ix;\n+  tree decl;\n+  uint32_t i, j;\n+\n+  ix = *data++;\n+  state->compressed = ix & 1;\n+  ix /= 2;\n+  decl = streamer_tree_cache_get_tree (data_in->reader_cache, ix);\n+  if (!VAR_OR_FUNCTION_DECL_P (decl))\n+    {\n+      gcc_assert (decl == void_type_node);\n+      decl = NULL_TREE;\n+    }\n+  state->fn_decl = decl;\n+\n+  for (i = 0; i < LTO_N_DECL_STREAMS; i++)\n+    {\n+      uint32_t size = *data++;\n+      vec<tree, va_gc> *decls = NULL;\n+      vec_alloc (decls, size);\n+\n+      for (j = 0; j < size; j++)\n+\tvec_safe_push (decls,\n+\t\t       streamer_tree_cache_get_tree (data_in->reader_cache,\n+\t\t\t\t\t\t     data[j]));\n+\n+      state->streams[i] = decls;\n+      data += size;\n+    }\n+\n+  return data;\n+}\n+\n+\n+/* Global canonical type table.  */\n+static htab_t gimple_canonical_types;\n+static hash_map<const_tree, hashval_t> *canonical_type_hash_cache;\n+static unsigned long num_canonical_type_hash_entries;\n+static unsigned long num_canonical_type_hash_queries;\n+\n+static void iterative_hash_canonical_type (tree type, inchash::hash &hstate);\n+static hashval_t gimple_canonical_type_hash (const void *p);\n+static void gimple_register_canonical_type_1 (tree t, hashval_t hash);\n+\n+/* Returning a hash value for gimple type TYPE.\n+\n+   The hash value returned is equal for types considered compatible\n+   by gimple_canonical_types_compatible_p.  */\n+\n+static hashval_t\n+hash_canonical_type (tree type)\n+{\n+  inchash::hash hstate;\n+  enum tree_code code;\n+\n+  /* We compute alias sets only for types that needs them.\n+     Be sure we do not recurse to something else as we cannot hash incomplete\n+     types in a way they would have same hash value as compatible complete\n+     types.  */\n+  gcc_checking_assert (type_with_alias_set_p (type));\n+\n+  /* Combine a few common features of types so that types are grouped into\n+     smaller sets; when searching for existing matching types to merge,\n+     only existing types having the same features as the new type will be\n+     checked.  */\n+  code = tree_code_for_canonical_type_merging (TREE_CODE (type));\n+  hstate.add_int (code);\n+  hstate.add_int (TYPE_MODE (type));\n+\n+  /* Incorporate common features of numerical types.  */\n+  if (INTEGRAL_TYPE_P (type)\n+      || SCALAR_FLOAT_TYPE_P (type)\n+      || FIXED_POINT_TYPE_P (type)\n+      || TREE_CODE (type) == OFFSET_TYPE\n+      || POINTER_TYPE_P (type))\n+    {\n+      hstate.add_int (TYPE_PRECISION (type));\n+      if (!type_with_interoperable_signedness (type))\n+        hstate.add_int (TYPE_UNSIGNED (type));\n+    }\n+\n+  if (VECTOR_TYPE_P (type))\n+    {\n+      hstate.add_poly_int (TYPE_VECTOR_SUBPARTS (type));\n+      hstate.add_int (TYPE_UNSIGNED (type));\n+    }\n+\n+  if (TREE_CODE (type) == COMPLEX_TYPE)\n+    hstate.add_int (TYPE_UNSIGNED (type));\n+\n+  /* Fortran's C_SIGNED_CHAR is !TYPE_STRING_FLAG but needs to be\n+     interoperable with \"signed char\".  Unless all frontends are revisited to\n+     agree on these types, we must ignore the flag completely.  */\n+\n+  /* Fortran standard define C_PTR type that is compatible with every\n+     C pointer.  For this reason we need to glob all pointers into one.\n+     Still pointers in different address spaces are not compatible.  */\n+  if (POINTER_TYPE_P (type))\n+    hstate.add_int (TYPE_ADDR_SPACE (TREE_TYPE (type)));\n+\n+  /* For array types hash the domain bounds and the string flag.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n+    {\n+      hstate.add_int (TYPE_STRING_FLAG (type));\n+      /* OMP lowering can introduce error_mark_node in place of\n+\t random local decls in types.  */\n+      if (TYPE_MIN_VALUE (TYPE_DOMAIN (type)) != error_mark_node)\n+\tinchash::add_expr (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), hstate);\n+      if (TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != error_mark_node)\n+\tinchash::add_expr (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), hstate);\n+    }\n+\n+  /* Recurse for aggregates with a single element type.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      || TREE_CODE (type) == COMPLEX_TYPE\n+      || TREE_CODE (type) == VECTOR_TYPE)\n+    iterative_hash_canonical_type (TREE_TYPE (type), hstate);\n+\n+  /* Incorporate function return and argument types.  */\n+  if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n+    {\n+      unsigned na;\n+      tree p;\n+\n+      iterative_hash_canonical_type (TREE_TYPE (type), hstate);\n+\n+      for (p = TYPE_ARG_TYPES (type), na = 0; p; p = TREE_CHAIN (p))\n+\t{\n+\t  iterative_hash_canonical_type (TREE_VALUE (p), hstate);\n+\t  na++;\n+\t}\n+\n+      hstate.add_int (na);\n+    }\n+\n+  if (RECORD_OR_UNION_TYPE_P (type))\n+    {\n+      unsigned nf;\n+      tree f;\n+\n+      for (f = TYPE_FIELDS (type), nf = 0; f; f = TREE_CHAIN (f))\n+\tif (TREE_CODE (f) == FIELD_DECL\n+\t    && (! DECL_SIZE (f)\n+\t\t|| ! integer_zerop (DECL_SIZE (f))))\n+\t  {\n+\t    iterative_hash_canonical_type (TREE_TYPE (f), hstate);\n+\t    nf++;\n+\t  }\n+\n+      hstate.add_int (nf);\n+    }\n+\n+  return hstate.end();\n+}\n+\n+/* Returning a hash value for gimple type TYPE combined with VAL.  */\n+\n+static void\n+iterative_hash_canonical_type (tree type, inchash::hash &hstate)\n+{\n+  hashval_t v;\n+\n+  /* All type variants have same TYPE_CANONICAL.  */\n+  type = TYPE_MAIN_VARIANT (type);\n+\n+  if (!canonical_type_used_p (type))\n+    v = hash_canonical_type (type);\n+  /* An already processed type.  */\n+  else if (TYPE_CANONICAL (type))\n+    {\n+      type = TYPE_CANONICAL (type);\n+      v = gimple_canonical_type_hash (type);\n+    }\n+  else\n+    {\n+      /* Canonical types should not be able to form SCCs by design, this\n+\t recursion is just because we do not register canonical types in\n+\t optimal order.  To avoid quadratic behavior also register the\n+\t type here.  */\n+      v = hash_canonical_type (type);\n+      gimple_register_canonical_type_1 (type, v);\n+    }\n+  hstate.add_int (v);\n+}\n+\n+/* Returns the hash for a canonical type P.  */\n+\n+static hashval_t\n+gimple_canonical_type_hash (const void *p)\n+{\n+  num_canonical_type_hash_queries++;\n+  hashval_t *slot = canonical_type_hash_cache->get ((const_tree) p);\n+  gcc_assert (slot != NULL);\n+  return *slot;\n+}\n+\n+\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+static int\n+gimple_canonical_type_eq (const void *p1, const void *p2)\n+{\n+  const_tree t1 = (const_tree) p1;\n+  const_tree t2 = (const_tree) p2;\n+  return gimple_canonical_types_compatible_p (CONST_CAST_TREE (t1),\n+\t\t\t\t\t      CONST_CAST_TREE (t2));\n+}\n+\n+/* Main worker for gimple_register_canonical_type.  */\n+\n+static void\n+gimple_register_canonical_type_1 (tree t, hashval_t hash)\n+{\n+  void **slot;\n+\n+  gcc_checking_assert (TYPE_P (t) && !TYPE_CANONICAL (t)\n+\t\t       && type_with_alias_set_p (t)\n+\t\t       && canonical_type_used_p (t));\n+\n+  slot = htab_find_slot_with_hash (gimple_canonical_types, t, hash, INSERT);\n+  if (*slot)\n+    {\n+      tree new_type = (tree)(*slot);\n+      gcc_checking_assert (new_type != t);\n+      TYPE_CANONICAL (t) = new_type;\n+    }\n+  else\n+    {\n+      TYPE_CANONICAL (t) = t;\n+      *slot = (void *) t;\n+      /* Cache the just computed hash value.  */\n+      num_canonical_type_hash_entries++;\n+      bool existed_p = canonical_type_hash_cache->put (t, hash);\n+      gcc_assert (!existed_p);\n+    }\n+}\n+\n+/* Register type T in the global type table gimple_types and set\n+   TYPE_CANONICAL of T accordingly.\n+   This is used by LTO to merge structurally equivalent types for\n+   type-based aliasing purposes across different TUs and languages.\n+\n+   ???  This merging does not exactly match how the tree.c middle-end\n+   functions will assign TYPE_CANONICAL when new types are created\n+   during optimization (which at least happens for pointer and array\n+   types).  */\n+\n+static void\n+gimple_register_canonical_type (tree t)\n+{\n+  if (TYPE_CANONICAL (t) || !type_with_alias_set_p (t)\n+      || !canonical_type_used_p (t))\n+    return;\n+\n+  /* Canonical types are same among all complete variants.  */\n+  if (TYPE_CANONICAL (TYPE_MAIN_VARIANT (t)))\n+    TYPE_CANONICAL (t) = TYPE_CANONICAL (TYPE_MAIN_VARIANT (t));\n+  else\n+    {\n+      gimple_register_canonical_type_1 (TYPE_MAIN_VARIANT (t),\n+\t\t\t\t\thash_canonical_type (TYPE_MAIN_VARIANT (t)));\n+      TYPE_CANONICAL (t) = TYPE_CANONICAL (TYPE_MAIN_VARIANT (t));\n+    }\n+}\n+\n+/* Re-compute TYPE_CANONICAL for NODE and related types.  */\n+\n+static void\n+lto_register_canonical_types (tree node, bool first_p)\n+{\n+  if (!node\n+      || !TYPE_P (node))\n+    return;\n+\n+  if (first_p)\n+    TYPE_CANONICAL (node) = NULL_TREE;\n+\n+  if (POINTER_TYPE_P (node)\n+      || TREE_CODE (node) == COMPLEX_TYPE\n+      || TREE_CODE (node) == ARRAY_TYPE)\n+    lto_register_canonical_types (TREE_TYPE (node), first_p);\n+\n+ if (!first_p) \n+    gimple_register_canonical_type (node);\n+}\n+\n+\n+/* Remember trees that contains references to declarations.  */\n+vec <tree, va_gc> *tree_with_vars;\n+\n+#define CHECK_VAR(tt) \\\n+  do \\\n+    { \\\n+      if ((tt) && VAR_OR_FUNCTION_DECL_P (tt) \\\n+\t  && (TREE_PUBLIC (tt) || DECL_EXTERNAL (tt))) \\\n+\treturn true; \\\n+    } while (0)\n+\n+#define CHECK_NO_VAR(tt) \\\n+  gcc_checking_assert (!(tt) || !VAR_OR_FUNCTION_DECL_P (tt))\n+\n+/* Check presence of pointers to decls in fields of a tree_typed T.  */\n+\n+static inline bool\n+mentions_vars_p_typed (tree t)\n+{\n+  CHECK_NO_VAR (TREE_TYPE (t));\n+  return false;\n+}\n+\n+/* Check presence of pointers to decls in fields of a tree_common T.  */\n+\n+static inline bool\n+mentions_vars_p_common (tree t)\n+{\n+  if (mentions_vars_p_typed (t))\n+    return true;\n+  CHECK_NO_VAR (TREE_CHAIN (t));\n+  return false;\n+}\n+\n+/* Check presence of pointers to decls in fields of a decl_minimal T.  */\n+\n+static inline bool\n+mentions_vars_p_decl_minimal (tree t)\n+{\n+  if (mentions_vars_p_common (t))\n+    return true;\n+  CHECK_NO_VAR (DECL_NAME (t));\n+  CHECK_VAR (DECL_CONTEXT (t));\n+  return false;\n+}\n+\n+/* Check presence of pointers to decls in fields of a decl_common T.  */\n+\n+static inline bool\n+mentions_vars_p_decl_common (tree t)\n+{\n+  if (mentions_vars_p_decl_minimal (t))\n+    return true;\n+  CHECK_VAR (DECL_SIZE (t));\n+  CHECK_VAR (DECL_SIZE_UNIT (t));\n+  CHECK_VAR (DECL_INITIAL (t));\n+  CHECK_NO_VAR (DECL_ATTRIBUTES (t));\n+  CHECK_VAR (DECL_ABSTRACT_ORIGIN (t));\n+  return false;\n+}\n+\n+/* Check presence of pointers to decls in fields of a decl_with_vis T.  */\n+\n+static inline bool\n+mentions_vars_p_decl_with_vis (tree t)\n+{\n+  if (mentions_vars_p_decl_common (t))\n+    return true;\n+\n+  /* Accessor macro has side-effects, use field-name here. */\n+  CHECK_NO_VAR (DECL_ASSEMBLER_NAME_RAW (t));\n+  return false;\n+}\n+\n+/* Check presence of pointers to decls in fields of a decl_non_common T.  */\n+\n+static inline bool\n+mentions_vars_p_decl_non_common (tree t)\n+{\n+  if (mentions_vars_p_decl_with_vis (t))\n+    return true;\n+  CHECK_NO_VAR (DECL_RESULT_FLD (t));\n+  return false;\n+}\n+\n+/* Check presence of pointers to decls in fields of a decl_non_common T.  */\n+\n+static bool\n+mentions_vars_p_function (tree t)\n+{\n+  if (mentions_vars_p_decl_non_common (t))\n+    return true;\n+  CHECK_NO_VAR (DECL_ARGUMENTS (t));\n+  CHECK_NO_VAR (DECL_VINDEX (t));\n+  CHECK_VAR (DECL_FUNCTION_PERSONALITY (t));\n+  return false;\n+}\n+\n+/* Check presence of pointers to decls in fields of a field_decl T.  */\n+\n+static bool\n+mentions_vars_p_field_decl (tree t)\n+{\n+  if (mentions_vars_p_decl_common (t))\n+    return true;\n+  CHECK_VAR (DECL_FIELD_OFFSET (t));\n+  CHECK_NO_VAR (DECL_BIT_FIELD_TYPE (t));\n+  CHECK_NO_VAR (DECL_QUALIFIER (t));\n+  CHECK_NO_VAR (DECL_FIELD_BIT_OFFSET (t));\n+  CHECK_NO_VAR (DECL_FCONTEXT (t));\n+  return false;\n+}\n+\n+/* Check presence of pointers to decls in fields of a type T.  */\n+\n+static bool\n+mentions_vars_p_type (tree t)\n+{\n+  if (mentions_vars_p_common (t))\n+    return true;\n+  CHECK_NO_VAR (TYPE_CACHED_VALUES (t));\n+  CHECK_VAR (TYPE_SIZE (t));\n+  CHECK_VAR (TYPE_SIZE_UNIT (t));\n+  CHECK_NO_VAR (TYPE_ATTRIBUTES (t));\n+  CHECK_NO_VAR (TYPE_NAME (t));\n+\n+  CHECK_VAR (TYPE_MIN_VALUE_RAW (t));\n+  CHECK_VAR (TYPE_MAX_VALUE_RAW (t));\n+\n+  /* Accessor is for derived node types only. */\n+  CHECK_NO_VAR (TYPE_LANG_SLOT_1 (t));\n+\n+  CHECK_VAR (TYPE_CONTEXT (t));\n+  CHECK_NO_VAR (TYPE_CANONICAL (t));\n+  CHECK_NO_VAR (TYPE_MAIN_VARIANT (t));\n+  CHECK_NO_VAR (TYPE_NEXT_VARIANT (t));\n+  return false;\n+}\n+\n+/* Check presence of pointers to decls in fields of a BINFO T.  */\n+\n+static bool\n+mentions_vars_p_binfo (tree t)\n+{\n+  unsigned HOST_WIDE_INT i, n;\n+\n+  if (mentions_vars_p_common (t))\n+    return true;\n+  CHECK_VAR (BINFO_VTABLE (t));\n+  CHECK_NO_VAR (BINFO_OFFSET (t));\n+  CHECK_NO_VAR (BINFO_VIRTUALS (t));\n+  CHECK_NO_VAR (BINFO_VPTR_FIELD (t));\n+  n = vec_safe_length (BINFO_BASE_ACCESSES (t));\n+  for (i = 0; i < n; i++)\n+    CHECK_NO_VAR (BINFO_BASE_ACCESS (t, i));\n+  /* Do not walk BINFO_INHERITANCE_CHAIN, BINFO_SUBVTT_INDEX\n+     and BINFO_VPTR_INDEX; these are used by C++ FE only.  */\n+  n = BINFO_N_BASE_BINFOS (t);\n+  for (i = 0; i < n; i++)\n+    CHECK_NO_VAR (BINFO_BASE_BINFO (t, i));\n+  return false;\n+}\n+\n+/* Check presence of pointers to decls in fields of a CONSTRUCTOR T.  */\n+\n+static bool\n+mentions_vars_p_constructor (tree t)\n+{\n+  unsigned HOST_WIDE_INT idx;\n+  constructor_elt *ce;\n+\n+  if (mentions_vars_p_typed (t))\n+    return true;\n+\n+  for (idx = 0; vec_safe_iterate (CONSTRUCTOR_ELTS (t), idx, &ce); idx++)\n+    {\n+      CHECK_NO_VAR (ce->index);\n+      CHECK_VAR (ce->value);\n+    }\n+  return false;\n+}\n+\n+/* Check presence of pointers to decls in fields of an expression tree T.  */\n+\n+static bool\n+mentions_vars_p_expr (tree t)\n+{\n+  int i;\n+  if (mentions_vars_p_typed (t))\n+    return true;\n+  for (i = TREE_OPERAND_LENGTH (t) - 1; i >= 0; --i)\n+    CHECK_VAR (TREE_OPERAND (t, i));\n+  return false;\n+}\n+\n+/* Check presence of pointers to decls in fields of an OMP_CLAUSE T.  */\n+\n+static bool\n+mentions_vars_p_omp_clause (tree t)\n+{\n+  int i;\n+  if (mentions_vars_p_common (t))\n+    return true;\n+  for (i = omp_clause_num_ops[OMP_CLAUSE_CODE (t)] - 1; i >= 0; --i)\n+    CHECK_VAR (OMP_CLAUSE_OPERAND (t, i));\n+  return false;\n+}\n+\n+/* Check presence of pointers to decls that needs later fixup in T.  */\n+\n+static bool\n+mentions_vars_p (tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case IDENTIFIER_NODE:\n+      break;\n+\n+    case TREE_LIST:\n+      CHECK_VAR (TREE_VALUE (t));\n+      CHECK_VAR (TREE_PURPOSE (t));\n+      CHECK_NO_VAR (TREE_CHAIN (t));\n+      break;\n+\n+    case FIELD_DECL:\n+      return mentions_vars_p_field_decl (t);\n+\n+    case LABEL_DECL:\n+    case CONST_DECL:\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+    case IMPORTED_DECL:\n+    case NAMESPACE_DECL:\n+    case NAMELIST_DECL:\n+      return mentions_vars_p_decl_common (t);\n+\n+    case VAR_DECL:\n+      return mentions_vars_p_decl_with_vis (t);\n+\n+    case TYPE_DECL:\n+      return mentions_vars_p_decl_non_common (t);\n+\n+    case FUNCTION_DECL:\n+      return mentions_vars_p_function (t);\n+\n+    case TREE_BINFO:\n+      return mentions_vars_p_binfo (t);\n+\n+    case PLACEHOLDER_EXPR:\n+      return mentions_vars_p_common (t);\n+\n+    case BLOCK:\n+    case TRANSLATION_UNIT_DECL:\n+    case OPTIMIZATION_NODE:\n+    case TARGET_OPTION_NODE:\n+      break;\n+\n+    case CONSTRUCTOR:\n+      return mentions_vars_p_constructor (t);\n+\n+    case OMP_CLAUSE:\n+      return mentions_vars_p_omp_clause (t);\n+\n+    default:\n+      if (TYPE_P (t))\n+\t{\n+\t  if (mentions_vars_p_type (t))\n+\t    return true;\n+\t}\n+      else if (EXPR_P (t))\n+\t{\n+\t  if (mentions_vars_p_expr (t))\n+\t    return true;\n+\t}\n+      else if (CONSTANT_CLASS_P (t))\n+\tCHECK_NO_VAR (TREE_TYPE (t));\n+      else\n+\tgcc_unreachable ();\n+    }\n+  return false;\n+}\n+\n+\n+/* Return the resolution for the decl with index INDEX from DATA_IN. */\n+\n+static enum ld_plugin_symbol_resolution\n+get_resolution (struct data_in *data_in, unsigned index)\n+{\n+  if (data_in->globals_resolution.exists ())\n+    {\n+      ld_plugin_symbol_resolution_t ret;\n+      /* We can have references to not emitted functions in\n+\t DECL_FUNCTION_PERSONALITY at least.  So we can and have\n+\t to indeed return LDPR_UNKNOWN in some cases.   */\n+      if (data_in->globals_resolution.length () <= index)\n+\treturn LDPR_UNKNOWN;\n+      ret = data_in->globals_resolution[index];\n+      return ret;\n+    }\n+  else\n+    /* Delay resolution finding until decl merging.  */\n+    return LDPR_UNKNOWN;\n+}\n+\n+/* We need to record resolutions until symbol table is read.  */\n+static void\n+register_resolution (struct lto_file_decl_data *file_data, tree decl,\n+\t\t     enum ld_plugin_symbol_resolution resolution)\n+{\n+  bool existed;\n+  if (resolution == LDPR_UNKNOWN)\n+    return;\n+  if (!file_data->resolution_map)\n+    file_data->resolution_map\n+      = new hash_map<tree, ld_plugin_symbol_resolution>;\n+  ld_plugin_symbol_resolution_t &res\n+     = file_data->resolution_map->get_or_insert (decl, &existed);\n+  if (!existed\n+      || resolution == LDPR_PREVAILING_DEF_IRONLY\n+      || resolution == LDPR_PREVAILING_DEF\n+      || resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+    res = resolution;\n+}\n+\n+/* Register DECL with the global symbol table and change its\n+   name if necessary to avoid name clashes for static globals across\n+   different files.  */\n+\n+static void\n+lto_register_var_decl_in_symtab (struct data_in *data_in, tree decl,\n+\t\t\t\t unsigned ix)\n+{\n+  tree context;\n+\n+  /* Variable has file scope, not local.  */\n+  if (!TREE_PUBLIC (decl)\n+      && !((context = decl_function_context (decl))\n+\t   && auto_var_in_fn_p (decl, context)))\n+    rest_of_decl_compilation (decl, 1, 0);\n+\n+  /* If this variable has already been declared, queue the\n+     declaration for merging.  */\n+  if (TREE_PUBLIC (decl))\n+    register_resolution (data_in->file_data,\n+\t\t\t decl, get_resolution (data_in, ix));\n+}\n+\n+\n+/* Register DECL with the global symbol table and change its\n+   name if necessary to avoid name clashes for static globals across\n+   different files.  DATA_IN contains descriptors and tables for the\n+   file being read.  */\n+\n+static void\n+lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl,\n+\t\t\t\t      unsigned ix)\n+{\n+  /* If this variable has already been declared, queue the\n+     declaration for merging.  */\n+  if (TREE_PUBLIC (decl) && !DECL_ABSTRACT_P (decl))\n+    register_resolution (data_in->file_data,\n+\t\t\t decl, get_resolution (data_in, ix));\n+}\n+\n+/* Check if T is a decl and needs register its resolution info.  */\n+\n+static void\n+lto_maybe_register_decl (struct data_in *data_in, tree t, unsigned ix)\n+{\n+  if (TREE_CODE (t) == VAR_DECL)\n+    lto_register_var_decl_in_symtab (data_in, t, ix);\n+  else if (TREE_CODE (t) == FUNCTION_DECL\n+\t   && !fndecl_built_in_p (t))\n+    lto_register_function_decl_in_symtab (data_in, t, ix);\n+}\n+\n+\n+/* For the type T re-materialize it in the type variant list and\n+   the pointer/reference-to chains.  */\n+\n+static void\n+lto_fixup_prevailing_type (tree t)\n+{\n+  /* The following re-creates proper variant lists while fixing up\n+     the variant leaders.  We do not stream TYPE_NEXT_VARIANT so the\n+     variant list state before fixup is broken.  */\n+\n+  /* If we are not our own variant leader link us into our new leaders\n+     variant list.  */\n+  if (TYPE_MAIN_VARIANT (t) != t)\n+    {\n+      tree mv = TYPE_MAIN_VARIANT (t);\n+      TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (mv);\n+      TYPE_NEXT_VARIANT (mv) = t;\n+    }\n+\n+  /* The following reconstructs the pointer chains\n+     of the new pointed-to type if we are a main variant.  We do\n+     not stream those so they are broken before fixup.  */\n+  if (TREE_CODE (t) == POINTER_TYPE\n+      && TYPE_MAIN_VARIANT (t) == t)\n+    {\n+      TYPE_NEXT_PTR_TO (t) = TYPE_POINTER_TO (TREE_TYPE (t));\n+      TYPE_POINTER_TO (TREE_TYPE (t)) = t;\n+    }\n+  else if (TREE_CODE (t) == REFERENCE_TYPE\n+\t   && TYPE_MAIN_VARIANT (t) == t)\n+    {\n+      TYPE_NEXT_REF_TO (t) = TYPE_REFERENCE_TO (TREE_TYPE (t));\n+      TYPE_REFERENCE_TO (TREE_TYPE (t)) = t;\n+    }\n+}\n+\n+\n+/* We keep prevailing tree SCCs in a hashtable with manual collision\n+   handling (in case all hashes compare the same) and keep the colliding\n+   entries in the tree_scc->next chain.  */\n+\n+struct tree_scc\n+{\n+  tree_scc *next;\n+  /* Hash of the whole SCC.  */\n+  hashval_t hash;\n+  /* Number of trees in the SCC.  */\n+  unsigned len;\n+  /* Number of possible entries into the SCC (tree nodes [0..entry_len-1]\n+     which share the same individual tree hash).  */\n+  unsigned entry_len;\n+  /* The members of the SCC.\n+     We only need to remember the first entry node candidate for prevailing\n+     SCCs (but of course have access to all entries for SCCs we are\n+     processing).\n+     ???  For prevailing SCCs we really only need hash and the first\n+     entry candidate, but that's too awkward to implement.  */\n+  tree entries[1];\n+};\n+\n+struct tree_scc_hasher : nofree_ptr_hash <tree_scc>\n+{\n+  static inline hashval_t hash (const tree_scc *);\n+  static inline bool equal (const tree_scc *, const tree_scc *);\n+};\n+\n+hashval_t\n+tree_scc_hasher::hash (const tree_scc *scc)\n+{\n+  return scc->hash;\n+}\n+\n+bool\n+tree_scc_hasher::equal (const tree_scc *scc1, const tree_scc *scc2)\n+{\n+  if (scc1->hash != scc2->hash\n+      || scc1->len != scc2->len\n+      || scc1->entry_len != scc2->entry_len)\n+    return false;\n+  return true;\n+}\n+\n+static hash_table<tree_scc_hasher> *tree_scc_hash;\n+static struct obstack tree_scc_hash_obstack;\n+\n+static unsigned long num_merged_types;\n+static unsigned long num_prevailing_types;\n+static unsigned long num_type_scc_trees;\n+static unsigned long total_scc_size;\n+static unsigned long num_sccs_read;\n+static unsigned long total_scc_size_merged;\n+static unsigned long num_sccs_merged;\n+static unsigned long num_scc_compares;\n+static unsigned long num_scc_compare_collisions;\n+\n+\n+/* Compare the two entries T1 and T2 of two SCCs that are possibly equal,\n+   recursing through in-SCC tree edges.  Returns true if the SCCs entered\n+   through T1 and T2 are equal and fills in *MAP with the pairs of\n+   SCC entries we visited, starting with (*MAP)[0] = T1 and (*MAP)[1] = T2.  */\n+\n+static bool\n+compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n+{\n+  enum tree_code code;\n+\n+  /* Mark already visited nodes.  */\n+  TREE_ASM_WRITTEN (t2) = 1;\n+\n+  /* Push the pair onto map.  */\n+  (*map)[0] = t1;\n+  (*map)[1] = t2;\n+  *map = *map + 2;\n+\n+  /* Compare value-fields.  */\n+#define compare_values(X) \\\n+  do { \\\n+    if (X(t1) != X(t2)) \\\n+      return false; \\\n+  } while (0)\n+\n+  compare_values (TREE_CODE);\n+  code = TREE_CODE (t1);\n+\n+  if (!TYPE_P (t1))\n+    {\n+      compare_values (TREE_SIDE_EFFECTS);\n+      compare_values (TREE_CONSTANT);\n+      compare_values (TREE_READONLY);\n+      compare_values (TREE_PUBLIC);\n+    }\n+  compare_values (TREE_ADDRESSABLE);\n+  compare_values (TREE_THIS_VOLATILE);\n+  if (DECL_P (t1))\n+    compare_values (DECL_UNSIGNED);\n+  else if (TYPE_P (t1))\n+    compare_values (TYPE_UNSIGNED);\n+  if (TYPE_P (t1))\n+    compare_values (TYPE_ARTIFICIAL);\n+  else\n+    compare_values (TREE_NO_WARNING);\n+  compare_values (TREE_NOTHROW);\n+  compare_values (TREE_STATIC);\n+  if (code != TREE_BINFO)\n+    compare_values (TREE_PRIVATE);\n+  compare_values (TREE_PROTECTED);\n+  compare_values (TREE_DEPRECATED);\n+  if (TYPE_P (t1))\n+    {\n+      if (AGGREGATE_TYPE_P (t1))\n+\tcompare_values (TYPE_REVERSE_STORAGE_ORDER);\n+      else\n+\tcompare_values (TYPE_SATURATING);\n+      compare_values (TYPE_ADDR_SPACE);\n+    }\n+  else if (code == SSA_NAME)\n+    compare_values (SSA_NAME_IS_DEFAULT_DEF);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_INT_CST))\n+    {\n+      if (wi::to_wide (t1) != wi::to_wide (t2))\n+\treturn false;\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_REAL_CST))\n+    {\n+      /* ???  No suitable compare routine available.  */\n+      REAL_VALUE_TYPE r1 = TREE_REAL_CST (t1);\n+      REAL_VALUE_TYPE r2 = TREE_REAL_CST (t2);\n+      if (r1.cl != r2.cl\n+\t  || r1.decimal != r2.decimal\n+\t  || r1.sign != r2.sign\n+\t  || r1.signalling != r2.signalling\n+\t  || r1.canonical != r2.canonical\n+\t  || r1.uexp != r2.uexp)\n+\treturn false;\n+      for (unsigned i = 0; i < SIGSZ; ++i)\n+\tif (r1.sig[i] != r2.sig[i])\n+\t  return false;\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FIXED_CST))\n+    if (!fixed_compare (EQ_EXPR,\n+\t\t\tTREE_FIXED_CST_PTR (t1), TREE_FIXED_CST_PTR (t2)))\n+      return false;\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n+    {\n+      compare_values (VECTOR_CST_LOG2_NPATTERNS);\n+      compare_values (VECTOR_CST_NELTS_PER_PATTERN);\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+    {\n+      compare_values (DECL_MODE);\n+      compare_values (DECL_NONLOCAL);\n+      compare_values (DECL_VIRTUAL_P);\n+      compare_values (DECL_IGNORED_P);\n+      compare_values (DECL_ABSTRACT_P);\n+      compare_values (DECL_ARTIFICIAL);\n+      compare_values (DECL_USER_ALIGN);\n+      compare_values (DECL_PRESERVE_P);\n+      compare_values (DECL_EXTERNAL);\n+      compare_values (DECL_GIMPLE_REG_P);\n+      compare_values (DECL_ALIGN);\n+      if (code == LABEL_DECL)\n+\t{\n+\t  compare_values (EH_LANDING_PAD_NR);\n+\t  compare_values (LABEL_DECL_UID);\n+\t}\n+      else if (code == FIELD_DECL)\n+\t{\n+\t  compare_values (DECL_PACKED);\n+\t  compare_values (DECL_NONADDRESSABLE_P);\n+\t  compare_values (DECL_PADDING_P);\n+\t  compare_values (DECL_OFFSET_ALIGN);\n+\t}\n+      else if (code == VAR_DECL)\n+\t{\n+\t  compare_values (DECL_HAS_DEBUG_EXPR_P);\n+\t  compare_values (DECL_NONLOCAL_FRAME);\n+\t}\n+      if (code == RESULT_DECL\n+\t  || code == PARM_DECL\n+\t  || code == VAR_DECL)\n+\t{\n+\t  compare_values (DECL_BY_REFERENCE);\n+\t  if (code == VAR_DECL\n+\t      || code == PARM_DECL)\n+\t    compare_values (DECL_HAS_VALUE_EXPR_P);\n+\t}\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WRTL))\n+    compare_values (DECL_REGISTER);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    {\n+      compare_values (DECL_COMMON);\n+      compare_values (DECL_DLLIMPORT_P);\n+      compare_values (DECL_WEAK);\n+      compare_values (DECL_SEEN_IN_BIND_EXPR_P);\n+      compare_values (DECL_COMDAT);\n+      compare_values (DECL_VISIBILITY);\n+      compare_values (DECL_VISIBILITY_SPECIFIED);\n+      if (code == VAR_DECL)\n+\t{\n+\t  compare_values (DECL_HARD_REGISTER);\n+          /* DECL_IN_TEXT_SECTION is set during final asm output only.  */\n+\t  compare_values (DECL_IN_CONSTANT_POOL);\n+\t}\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+    {\n+      compare_values (DECL_BUILT_IN_CLASS);\n+      compare_values (DECL_STATIC_CONSTRUCTOR);\n+      compare_values (DECL_STATIC_DESTRUCTOR);\n+      compare_values (DECL_UNINLINABLE);\n+      compare_values (DECL_POSSIBLY_INLINED);\n+      compare_values (DECL_IS_NOVOPS);\n+      compare_values (DECL_IS_RETURNS_TWICE);\n+      compare_values (DECL_IS_MALLOC);\n+      compare_values (DECL_IS_OPERATOR_NEW);\n+      compare_values (DECL_DECLARED_INLINE_P);\n+      compare_values (DECL_STATIC_CHAIN);\n+      compare_values (DECL_NO_INLINE_WARNING_P);\n+      compare_values (DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT);\n+      compare_values (DECL_NO_LIMIT_STACK);\n+      compare_values (DECL_DISREGARD_INLINE_LIMITS);\n+      compare_values (DECL_PURE_P);\n+      compare_values (DECL_LOOPING_CONST_OR_PURE_P);\n+      compare_values (DECL_FINAL_P);\n+      compare_values (DECL_CXX_CONSTRUCTOR_P);\n+      compare_values (DECL_CXX_DESTRUCTOR_P);\n+      if (DECL_BUILT_IN_CLASS (t1) != NOT_BUILT_IN)\n+\tcompare_values (DECL_FUNCTION_CODE);\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n+    {\n+      compare_values (TYPE_MODE);\n+      compare_values (TYPE_STRING_FLAG);\n+      compare_values (TYPE_NEEDS_CONSTRUCTING);\n+      if (RECORD_OR_UNION_TYPE_P (t1))\n+\t{\n+\t  compare_values (TYPE_TRANSPARENT_AGGR);\n+\t  compare_values (TYPE_FINAL_P);\n+\t}\n+      else if (code == ARRAY_TYPE)\n+\tcompare_values (TYPE_NONALIASED_COMPONENT);\n+      if (AGGREGATE_TYPE_P (t1))\n+\tcompare_values (TYPE_TYPELESS_STORAGE);\n+      compare_values (TYPE_EMPTY_P);\n+      compare_values (TYPE_PACKED);\n+      compare_values (TYPE_RESTRICT);\n+      compare_values (TYPE_USER_ALIGN);\n+      compare_values (TYPE_READONLY);\n+      compare_values (TYPE_PRECISION);\n+      compare_values (TYPE_ALIGN);\n+      /* Do not compare TYPE_ALIAS_SET.  Doing so introduce ordering issues\n+         with calls to get_alias_set which may initialize it for streamed\n+ \t in types.  */\n+    }\n+\n+  /* We don't want to compare locations, so there is nothing do compare\n+     for TS_EXP.  */\n+\n+  /* BLOCKs are function local and we don't merge anything there, so\n+     simply refuse to merge.  */\n+  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n+    return false;\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n+    if (strcmp (TRANSLATION_UNIT_LANGUAGE (t1),\n+\t\tTRANSLATION_UNIT_LANGUAGE (t2)) != 0)\n+      return false;\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TARGET_OPTION))\n+    if (!cl_target_option_eq (TREE_TARGET_OPTION (t1), TREE_TARGET_OPTION (t2)))\n+      return false;\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_OPTIMIZATION))\n+    if (!cl_optimization_option_eq (TREE_OPTIMIZATION (t1),\n+\t\t\t\t    TREE_OPTIMIZATION (t2)))\n+      return false;\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n+    if (vec_safe_length (BINFO_BASE_ACCESSES (t1))\n+\t!= vec_safe_length (BINFO_BASE_ACCESSES (t2)))\n+      return false;\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n+    compare_values (CONSTRUCTOR_NELTS);\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_IDENTIFIER))\n+    if (IDENTIFIER_LENGTH (t1) != IDENTIFIER_LENGTH (t2)\n+\t|| memcmp (IDENTIFIER_POINTER (t1), IDENTIFIER_POINTER (t2),\n+\t\t   IDENTIFIER_LENGTH (t1)) != 0)\n+      return false;\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_STRING))\n+    if (TREE_STRING_LENGTH (t1) != TREE_STRING_LENGTH (t2)\n+\t|| memcmp (TREE_STRING_POINTER (t1), TREE_STRING_POINTER (t2),\n+\t\t   TREE_STRING_LENGTH (t1)) != 0)\n+      return false;\n+\n+  if (code == OMP_CLAUSE)\n+    {\n+      compare_values (OMP_CLAUSE_CODE);\n+      switch (OMP_CLAUSE_CODE (t1))\n+\t{\n+\tcase OMP_CLAUSE_DEFAULT:\n+\t  compare_values (OMP_CLAUSE_DEFAULT_KIND);\n+\t  break;\n+\tcase OMP_CLAUSE_SCHEDULE:\n+\t  compare_values (OMP_CLAUSE_SCHEDULE_KIND);\n+\t  break;\n+\tcase OMP_CLAUSE_DEPEND:\n+\t  compare_values (OMP_CLAUSE_DEPEND_KIND);\n+\t  break;\n+\tcase OMP_CLAUSE_MAP:\n+\t  compare_values (OMP_CLAUSE_MAP_KIND);\n+\t  break;\n+\tcase OMP_CLAUSE_PROC_BIND:\n+\t  compare_values (OMP_CLAUSE_PROC_BIND_KIND);\n+\t  break;\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  compare_values (OMP_CLAUSE_REDUCTION_CODE);\n+\t  compare_values (OMP_CLAUSE_REDUCTION_GIMPLE_INIT);\n+\t  compare_values (OMP_CLAUSE_REDUCTION_GIMPLE_MERGE);\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+#undef compare_values\n+\n+\n+  /* Compare pointer fields.  */\n+\n+  /* Recurse.  Search & Replaced from DFS_write_tree_body.\n+     Folding the early checks into the compare_tree_edges recursion\n+     macro makes debugging way quicker as you are able to break on\n+     compare_tree_sccs_1 and simply finish until a call returns false\n+     to spot the SCC members with the difference.  */\n+#define compare_tree_edges(E1, E2) \\\n+  do { \\\n+    tree t1_ = (E1), t2_ = (E2); \\\n+    if (t1_ != t2_ \\\n+\t&& (!t1_ || !t2_ \\\n+\t    || !TREE_VISITED (t2_) \\\n+\t    || (!TREE_ASM_WRITTEN (t2_) \\\n+\t\t&& !compare_tree_sccs_1 (t1_, t2_, map)))) \\\n+      return false; \\\n+    /* Only non-NULL trees outside of the SCC may compare equal.  */ \\\n+    gcc_checking_assert (t1_ != t2_ || (!t2_ || !TREE_VISITED (t2_))); \\\n+  } while (0)\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPED))\n+    {\n+      if (code != IDENTIFIER_NODE)\n+\tcompare_tree_edges (TREE_TYPE (t1), TREE_TYPE (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n+    {\n+      /* Note that the number of elements for EXPR has already been emitted\n+\t in EXPR's header (see streamer_write_tree_header).  */\n+      unsigned int count = vector_cst_encoded_nelts (t1);\n+      for (unsigned int i = 0; i < count; ++i)\n+\tcompare_tree_edges (VECTOR_CST_ENCODED_ELT (t1, i),\n+\t\t\t    VECTOR_CST_ENCODED_ELT (t2, i));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n+    {\n+      compare_tree_edges (TREE_REALPART (t1), TREE_REALPART (t2));\n+      compare_tree_edges (TREE_IMAGPART (t1), TREE_IMAGPART (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_MINIMAL))\n+    {\n+      compare_tree_edges (DECL_NAME (t1), DECL_NAME (t2));\n+      /* ???  Global decls from different TUs have non-matching\n+\t TRANSLATION_UNIT_DECLs.  Only consider a small set of\n+\t decls equivalent, we should not end up merging others.  */\n+      if ((code == TYPE_DECL\n+\t   || code == NAMESPACE_DECL\n+\t   || code == IMPORTED_DECL\n+\t   || code == CONST_DECL\n+\t   || (VAR_OR_FUNCTION_DECL_P (t1)\n+\t       && (TREE_PUBLIC (t1) || DECL_EXTERNAL (t1))))\n+\t  && DECL_FILE_SCOPE_P (t1) && DECL_FILE_SCOPE_P (t2))\n+\t;\n+      else\n+\tcompare_tree_edges (DECL_CONTEXT (t1), DECL_CONTEXT (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+    {\n+      compare_tree_edges (DECL_SIZE (t1), DECL_SIZE (t2));\n+      compare_tree_edges (DECL_SIZE_UNIT (t1), DECL_SIZE_UNIT (t2));\n+      compare_tree_edges (DECL_ATTRIBUTES (t1), DECL_ATTRIBUTES (t2));\n+      compare_tree_edges (DECL_ABSTRACT_ORIGIN (t1), DECL_ABSTRACT_ORIGIN (t2));\n+      if ((code == VAR_DECL\n+\t   || code == PARM_DECL)\n+\t  && DECL_HAS_VALUE_EXPR_P (t1))\n+\tcompare_tree_edges (DECL_VALUE_EXPR (t1), DECL_VALUE_EXPR (t2));\n+      if (code == VAR_DECL\n+\t  && DECL_HAS_DEBUG_EXPR_P (t1))\n+\tcompare_tree_edges (DECL_DEBUG_EXPR (t1), DECL_DEBUG_EXPR (t2));\n+      /* LTO specific edges.  */\n+      if (code != FUNCTION_DECL\n+\t  && code != TRANSLATION_UNIT_DECL)\n+\tcompare_tree_edges (DECL_INITIAL (t1), DECL_INITIAL (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n+    {\n+      if (code == FUNCTION_DECL)\n+\t{\n+\t  tree a1, a2;\n+\t  for (a1 = DECL_ARGUMENTS (t1), a2 = DECL_ARGUMENTS (t2);\n+\t       a1 || a2;\n+\t       a1 = TREE_CHAIN (a1), a2 = TREE_CHAIN (a2))\n+\t    compare_tree_edges (a1, a2);\n+\t  compare_tree_edges (DECL_RESULT (t1), DECL_RESULT (t2));\n+\t}\n+      else if (code == TYPE_DECL)\n+\tcompare_tree_edges (DECL_ORIGINAL_TYPE (t1), DECL_ORIGINAL_TYPE (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+    {\n+      /* Make sure we don't inadvertently set the assembler name.  */\n+      if (DECL_ASSEMBLER_NAME_SET_P (t1))\n+\tcompare_tree_edges (DECL_ASSEMBLER_NAME (t1),\n+\t\t\t    DECL_ASSEMBLER_NAME (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n+    {\n+      compare_tree_edges (DECL_FIELD_OFFSET (t1), DECL_FIELD_OFFSET (t2));\n+      compare_tree_edges (DECL_BIT_FIELD_TYPE (t1), DECL_BIT_FIELD_TYPE (t2));\n+      compare_tree_edges (DECL_BIT_FIELD_REPRESENTATIVE (t1),\n+\t\t\t  DECL_BIT_FIELD_REPRESENTATIVE (t2));\n+      compare_tree_edges (DECL_FIELD_BIT_OFFSET (t1),\n+\t\t\t  DECL_FIELD_BIT_OFFSET (t2));\n+      compare_tree_edges (DECL_FCONTEXT (t1), DECL_FCONTEXT (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+    {\n+      compare_tree_edges (DECL_FUNCTION_PERSONALITY (t1),\n+\t\t\t  DECL_FUNCTION_PERSONALITY (t2));\n+      compare_tree_edges (DECL_VINDEX (t1), DECL_VINDEX (t2));\n+      compare_tree_edges (DECL_FUNCTION_SPECIFIC_TARGET (t1),\n+\t\t\t  DECL_FUNCTION_SPECIFIC_TARGET (t2));\n+      compare_tree_edges (DECL_FUNCTION_SPECIFIC_OPTIMIZATION (t1),\n+\t\t\t  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n+    {\n+      compare_tree_edges (TYPE_SIZE (t1), TYPE_SIZE (t2));\n+      compare_tree_edges (TYPE_SIZE_UNIT (t1), TYPE_SIZE_UNIT (t2));\n+      compare_tree_edges (TYPE_ATTRIBUTES (t1), TYPE_ATTRIBUTES (t2));\n+      compare_tree_edges (TYPE_NAME (t1), TYPE_NAME (t2));\n+      /* Do not compare TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n+\t reconstructed during fixup.  */\n+      /* Do not compare TYPE_NEXT_VARIANT, we reconstruct the variant lists\n+\t during fixup.  */\n+      compare_tree_edges (TYPE_MAIN_VARIANT (t1), TYPE_MAIN_VARIANT (t2));\n+      /* ???  Global types from different TUs have non-matching\n+\t TRANSLATION_UNIT_DECLs.  Still merge them if they are otherwise\n+\t equal.  */\n+      if (TYPE_FILE_SCOPE_P (t1) && TYPE_FILE_SCOPE_P (t2))\n+\t;\n+      else\n+\tcompare_tree_edges (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2));\n+      /* TYPE_CANONICAL is re-computed during type merging, so do not\n+\t compare it here.  */\n+      compare_tree_edges (TYPE_STUB_DECL (t1), TYPE_STUB_DECL (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n+    {\n+      if (code == ENUMERAL_TYPE)\n+\tcompare_tree_edges (TYPE_VALUES (t1), TYPE_VALUES (t2));\n+      else if (code == ARRAY_TYPE)\n+\tcompare_tree_edges (TYPE_DOMAIN (t1), TYPE_DOMAIN (t2));\n+      else if (RECORD_OR_UNION_TYPE_P (t1))\n+\t{\n+\t  tree f1, f2;\n+\t  for (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n+\t       f1 || f2;\n+\t       f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n+\t    compare_tree_edges (f1, f2);\n+\t}\n+      else if (code == FUNCTION_TYPE\n+\t       || code == METHOD_TYPE)\n+\tcompare_tree_edges (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2));\n+\n+      if (!POINTER_TYPE_P (t1))\n+\tcompare_tree_edges (TYPE_MIN_VALUE_RAW (t1), TYPE_MIN_VALUE_RAW (t2));\n+      compare_tree_edges (TYPE_MAX_VALUE_RAW (t1), TYPE_MAX_VALUE_RAW (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n+    {\n+      compare_tree_edges (TREE_PURPOSE (t1), TREE_PURPOSE (t2));\n+      compare_tree_edges (TREE_VALUE (t1), TREE_VALUE (t2));\n+      compare_tree_edges (TREE_CHAIN (t1), TREE_CHAIN (t2));\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n+    for (int i = 0; i < TREE_VEC_LENGTH (t1); i++)\n+      compare_tree_edges (TREE_VEC_ELT (t1, i), TREE_VEC_ELT (t2, i));\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n+    {\n+      for (int i = 0; i < TREE_OPERAND_LENGTH (t1); i++)\n+\tcompare_tree_edges (TREE_OPERAND (t1, i),\n+\t\t\t    TREE_OPERAND (t2, i));\n+\n+      /* BLOCKs are function local and we don't merge anything there.  */\n+      if (TREE_BLOCK (t1) || TREE_BLOCK (t2))\n+\treturn false;\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n+    {\n+      unsigned i;\n+      tree t;\n+      /* Lengths have already been compared above.  */\n+      FOR_EACH_VEC_ELT (*BINFO_BASE_BINFOS (t1), i, t)\n+\tcompare_tree_edges (t, BINFO_BASE_BINFO (t2, i));\n+      FOR_EACH_VEC_SAFE_ELT (BINFO_BASE_ACCESSES (t1), i, t)\n+\tcompare_tree_edges (t, BINFO_BASE_ACCESS (t2, i));\n+      compare_tree_edges (BINFO_OFFSET (t1), BINFO_OFFSET (t2));\n+      compare_tree_edges (BINFO_VTABLE (t1), BINFO_VTABLE (t2));\n+      compare_tree_edges (BINFO_VPTR_FIELD (t1), BINFO_VPTR_FIELD (t2));\n+      /* Do not walk BINFO_INHERITANCE_CHAIN, BINFO_SUBVTT_INDEX\n+\t and BINFO_VPTR_INDEX; these are used by C++ FE only.  */\n+    }\n+\n+  if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n+    {\n+      unsigned i;\n+      tree index, value;\n+      /* Lengths have already been compared above.  */\n+      FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (t1), i, index, value)\n+\t{\n+\t  compare_tree_edges (index, CONSTRUCTOR_ELT (t2, i)->index);\n+\t  compare_tree_edges (value, CONSTRUCTOR_ELT (t2, i)->value);\n+\t}\n+    }\n+\n+  if (code == OMP_CLAUSE)\n+    {\n+      int i;\n+\n+      for (i = 0; i < omp_clause_num_ops[OMP_CLAUSE_CODE (t1)]; i++)\n+\tcompare_tree_edges (OMP_CLAUSE_OPERAND (t1, i),\n+\t\t\t    OMP_CLAUSE_OPERAND (t2, i));\n+      compare_tree_edges (OMP_CLAUSE_CHAIN (t1), OMP_CLAUSE_CHAIN (t2));\n+    }\n+\n+#undef compare_tree_edges\n+\n+  return true;\n+}\n+\n+/* Compare the tree scc SCC to the prevailing candidate PSCC, filling\n+   out MAP if they are equal.  */\n+\n+static bool\n+compare_tree_sccs (tree_scc *pscc, tree_scc *scc,\n+\t\t   tree *map)\n+{\n+  /* Assume SCC entry hashes are sorted after their cardinality.  Which\n+     means we can simply take the first n-tuple of equal hashes\n+     (which is recorded as entry_len) and do n SCC entry candidate\n+     comparisons.  */\n+  for (unsigned i = 0; i < pscc->entry_len; ++i)\n+    {\n+      tree *mapp = map;\n+      num_scc_compare_collisions++;\n+      if (compare_tree_sccs_1 (pscc->entries[0], scc->entries[i], &mapp))\n+\t{\n+\t  /* Equal - no need to reset TREE_VISITED or TREE_ASM_WRITTEN\n+\t     on the scc as all trees will be freed.  */\n+\t  return true;\n+\t}\n+      /* Reset TREE_ASM_WRITTEN on scc for the next compare or in case\n+         the SCC prevails.  */\n+      for (unsigned j = 0; j < scc->len; ++j)\n+\tTREE_ASM_WRITTEN (scc->entries[j]) = 0;\n+    }\n+\n+  return false;\n+}\n+\n+/* QSort sort function to sort a map of two pointers after the 2nd\n+   pointer.  */\n+\n+static int\n+cmp_tree (const void *p1_, const void *p2_)\n+{\n+  tree *p1 = (tree *)(const_cast<void *>(p1_));\n+  tree *p2 = (tree *)(const_cast<void *>(p2_));\n+  if (p1[1] == p2[1])\n+    return 0;\n+  return ((uintptr_t)p1[1] < (uintptr_t)p2[1]) ? -1 : 1;\n+}\n+\n+/* Try to unify the SCC with nodes FROM to FROM + LEN in CACHE and\n+   hash value SCC_HASH with an already recorded SCC.  Return true if\n+   that was successful, otherwise return false.  */\n+\n+static bool\n+unify_scc (struct data_in *data_in, unsigned from,\n+\t   unsigned len, unsigned scc_entry_len, hashval_t scc_hash)\n+{\n+  bool unified_p = false;\n+  struct streamer_tree_cache_d *cache = data_in->reader_cache;\n+  tree_scc *scc\n+    = (tree_scc *) alloca (sizeof (tree_scc) + (len - 1) * sizeof (tree));\n+  scc->next = NULL;\n+  scc->hash = scc_hash;\n+  scc->len = len;\n+  scc->entry_len = scc_entry_len;\n+  for (unsigned i = 0; i < len; ++i)\n+    {\n+      tree t = streamer_tree_cache_get_tree (cache, from + i);\n+      scc->entries[i] = t;\n+      /* Do not merge SCCs with local entities inside them.  Also do\n+\t not merge TRANSLATION_UNIT_DECLs.  */\n+      if (TREE_CODE (t) == TRANSLATION_UNIT_DECL\n+\t  || (VAR_OR_FUNCTION_DECL_P (t)\n+\t      && !(TREE_PUBLIC (t) || DECL_EXTERNAL (t)))\n+\t  || TREE_CODE (t) == LABEL_DECL)\n+\t{\n+\t  /* Avoid doing any work for these cases and do not worry to\n+\t     record the SCCs for further merging.  */\n+\t  return false;\n+\t}\n+    }\n+\n+  /* Look for the list of candidate SCCs to compare against.  */\n+  tree_scc **slot;\n+  slot = tree_scc_hash->find_slot_with_hash (scc, scc_hash, INSERT);\n+  if (*slot)\n+    {\n+      /* Try unifying against each candidate.  */\n+      num_scc_compares++;\n+\n+      /* Set TREE_VISITED on the scc so we can easily identify tree nodes\n+\t outside of the scc when following tree edges.  Make sure\n+\t that TREE_ASM_WRITTEN is unset so we can use it as 2nd bit\n+\t to track whether we visited the SCC member during the compare.\n+\t We cannot use TREE_VISITED on the pscc members as the extended\n+\t scc and pscc can overlap.  */\n+      for (unsigned i = 0; i < scc->len; ++i)\n+\t{\n+\t  TREE_VISITED (scc->entries[i]) = 1;\n+\t  gcc_checking_assert (!TREE_ASM_WRITTEN (scc->entries[i]));\n+\t}\n+\n+      tree *map = XALLOCAVEC (tree, 2 * len);\n+      for (tree_scc *pscc = *slot; pscc; pscc = pscc->next)\n+\t{\n+\t  if (!compare_tree_sccs (pscc, scc, map))\n+\t    continue;\n+\n+\t  /* Found an equal SCC.  */\n+\t  unified_p = true;\n+\t  num_scc_compare_collisions--;\n+\t  num_sccs_merged++;\n+\t  total_scc_size_merged += len;\n+\n+\t  if (flag_checking)\n+\t    for (unsigned i = 0; i < len; ++i)\n+\t      {\n+\t\ttree t = map[2*i+1];\n+\t\tenum tree_code code = TREE_CODE (t);\n+\t\t/* IDENTIFIER_NODEs should be singletons and are merged by the\n+\t\t   streamer.  The others should be singletons, too, and we\n+\t\t   should not merge them in any way.  */\n+\t\tgcc_assert (code != TRANSLATION_UNIT_DECL\n+\t\t\t    && code != IDENTIFIER_NODE);\n+\t      }\n+\n+\t  /* Fixup the streamer cache with the prevailing nodes according\n+\t     to the tree node mapping computed by compare_tree_sccs.  */\n+\t  if (len == 1)\n+\t    {\n+\t      /* If we got a debug reference queued, see if the prevailing\n+\t         tree has a debug reference and if not, register the one\n+\t\t for the tree we are about to throw away.  */\n+\t      if (dref_queue.length () == 1)\n+\t\t{\n+\t\t  dref_entry e = dref_queue.pop ();\n+\t\t  gcc_assert (e.decl\n+\t\t\t      == streamer_tree_cache_get_tree (cache, from));\n+\t\t  const char *sym;\n+\t\t  unsigned HOST_WIDE_INT off;\n+\t\t  if (!debug_hooks->die_ref_for_decl (pscc->entries[0], &sym,\n+\t\t\t\t\t\t      &off))\n+\t\t    debug_hooks->register_external_die (pscc->entries[0],\n+\t\t\t\t\t\t\te.sym, e.off);\n+\t\t}\n+\t      lto_maybe_register_decl (data_in, pscc->entries[0], from);\n+\t      streamer_tree_cache_replace_tree (cache, pscc->entries[0], from);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree *map2 = XALLOCAVEC (tree, 2 * len);\n+\t      for (unsigned i = 0; i < len; ++i)\n+\t\t{\n+\t\t  map2[i*2] = (tree)(uintptr_t)(from + i);\n+\t\t  map2[i*2+1] = scc->entries[i];\n+\t\t}\n+\t      qsort (map2, len, 2 * sizeof (tree), cmp_tree);\n+\t      qsort (map, len, 2 * sizeof (tree), cmp_tree);\n+\t      for (unsigned i = 0; i < len; ++i)\n+\t\t{\n+\t\t  lto_maybe_register_decl (data_in, map[2*i],\n+\t\t\t\t\t   (uintptr_t)map2[2*i]);\n+\t\t  streamer_tree_cache_replace_tree (cache, map[2*i],\n+\t\t\t\t\t\t    (uintptr_t)map2[2*i]);\n+\t\t}\n+\t    }\n+\n+\t  /* Free the tree nodes from the read SCC.  */\n+\t  data_in->location_cache.revert_location_cache ();\n+\t  for (unsigned i = 0; i < len; ++i)\n+\t    {\n+\t      if (TYPE_P (scc->entries[i]))\n+\t\tnum_merged_types++;\n+\t      free_node (scc->entries[i]);\n+\t    }\n+\n+\t  /* Drop DIE references.\n+\t     ???  Do as in the size-one SCC case which involves sorting\n+\t     the queue.  */\n+\t  dref_queue.truncate (0);\n+\n+\t  break;\n+\t}\n+\n+      /* Reset TREE_VISITED if we didn't unify the SCC with another.  */\n+      if (!unified_p)\n+\tfor (unsigned i = 0; i < scc->len; ++i)\n+\t  TREE_VISITED (scc->entries[i]) = 0;\n+    }\n+\n+  /* If we didn't unify it to any candidate duplicate the relevant\n+     pieces to permanent storage and link it into the chain.  */\n+  if (!unified_p)\n+    {\n+      tree_scc *pscc\n+\t= XOBNEWVAR (&tree_scc_hash_obstack, tree_scc, sizeof (tree_scc));\n+      memcpy (pscc, scc, sizeof (tree_scc));\n+      pscc->next = (*slot);\n+      *slot = pscc;\n+    }\n+  return unified_p;\n+}\n+\n+\n+/* Read all the symbols from buffer DATA, using descriptors in DECL_DATA.\n+   RESOLUTIONS is the set of symbols picked by the linker (read from the\n+   resolution file when the linker plugin is being used).  */\n+\n+static void\n+lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n+\t\tvec<ld_plugin_symbol_resolution_t> resolutions)\n+{\n+  const struct lto_decl_header *header = (const struct lto_decl_header *) data;\n+  const int decl_offset = sizeof (struct lto_decl_header);\n+  const int main_offset = decl_offset + header->decl_state_size;\n+  const int string_offset = main_offset + header->main_size;\n+  struct data_in *data_in;\n+  unsigned int i;\n+  const uint32_t *data_ptr, *data_end;\n+  uint32_t num_decl_states;\n+\n+  lto_input_block ib_main ((const char *) data + main_offset,\n+\t\t\t   header->main_size, decl_data->mode_table);\n+\n+  data_in = lto_data_in_create (decl_data, (const char *) data + string_offset,\n+\t\t\t\theader->string_size, resolutions);\n+\n+  /* We do not uniquify the pre-loaded cache entries, those are middle-end\n+     internal types that should not be merged.  */\n+\n+  /* Read the global declarations and types.  */\n+  while (ib_main.p < ib_main.len)\n+    {\n+      tree t;\n+      unsigned from = data_in->reader_cache->nodes.length ();\n+      /* Read and uniquify SCCs as in the input stream.  */\n+      enum LTO_tags tag = streamer_read_record_start (&ib_main);\n+      if (tag == LTO_tree_scc)\n+\t{\n+\t  unsigned len_;\n+\t  unsigned scc_entry_len;\n+\t  hashval_t scc_hash = lto_input_scc (&ib_main, data_in, &len_,\n+\t\t\t\t\t      &scc_entry_len);\n+\t  unsigned len = data_in->reader_cache->nodes.length () - from;\n+\t  gcc_assert (len == len_);\n+\n+\t  total_scc_size += len;\n+\t  num_sccs_read++;\n+\n+\t  /* We have the special case of size-1 SCCs that are pre-merged\n+\t     by means of identifier and string sharing for example.\n+\t     ???  Maybe we should avoid streaming those as SCCs.  */\n+\t  tree first = streamer_tree_cache_get_tree (data_in->reader_cache,\n+\t\t\t\t\t\t     from);\n+\t  if (len == 1\n+\t      && (TREE_CODE (first) == IDENTIFIER_NODE\n+\t\t  || (TREE_CODE (first) == INTEGER_CST\n+\t\t      && !TREE_OVERFLOW (first))))\n+\t    continue;\n+\n+\t  /* Try to unify the SCC with already existing ones.  */\n+\t  if (!flag_ltrans\n+\t      && unify_scc (data_in, from,\n+\t\t\t    len, scc_entry_len, scc_hash))\n+\t    continue;\n+\n+\t  /* Tree merging failed, mark entries in location cache as\n+\t     permanent.  */\n+\t  data_in->location_cache.accept_location_cache ();\n+\n+\t  bool seen_type = false;\n+\t  for (unsigned i = 0; i < len; ++i)\n+\t    {\n+\t      tree t = streamer_tree_cache_get_tree (data_in->reader_cache,\n+\t\t\t\t\t\t     from + i);\n+\t      /* Reconstruct the type variant and pointer-to/reference-to\n+\t\t chains.  */\n+\t      if (TYPE_P (t))\n+\t\t{\n+\t\t  seen_type = true;\n+\t\t  num_prevailing_types++;\n+\t\t  lto_fixup_prevailing_type (t);\n+\n+\t\t  /* Compute the canonical type of all types.\n+\t\t     Because SCC components are streamed in random (hash) order\n+\t\t     we may have encountered the type before while registering\n+\t\t     type canonical of a derived type in the same SCC.  */\n+\t\t  if (!TYPE_CANONICAL (t))\n+\t\t    gimple_register_canonical_type (t);\n+\t\t  if (TYPE_MAIN_VARIANT (t) == t && odr_type_p (t))\n+\t\t    register_odr_type (t);\n+\t\t}\n+\t      /* Link shared INTEGER_CSTs into TYPE_CACHED_VALUEs of its\n+\t\t type which is also member of this SCC.  */\n+\t      if (TREE_CODE (t) == INTEGER_CST\n+\t\t  && !TREE_OVERFLOW (t))\n+\t\tcache_integer_cst (t);\n+\t      if (!flag_ltrans)\n+\t\t{\n+\t\t  lto_maybe_register_decl (data_in, t, from + i);\n+\t\t  /* Scan the tree for references to global functions or\n+\t\t     variables and record those for later fixup.  */\n+\t\t  if (mentions_vars_p (t))\n+\t\t    vec_safe_push (tree_with_vars, t);\n+\t\t}\n+\t    }\n+\n+\t  /* Register DECLs with the debuginfo machinery.  */\n+\t  while (!dref_queue.is_empty ())\n+\t    {\n+\t      dref_entry e = dref_queue.pop ();\n+\t      debug_hooks->register_external_die (e.decl, e.sym, e.off);\n+\t    }\n+\n+\t  if (seen_type)\n+\t    num_type_scc_trees += len;\n+\t}\n+      else\n+\t{\n+\t  /* Pickle stray references.  */\n+\t  t = lto_input_tree_1 (&ib_main, data_in, tag, 0);\n+\t  gcc_assert (t && data_in->reader_cache->nodes.length () == from);\n+\t}\n+    }\n+  data_in->location_cache.apply_location_cache ();\n+\n+  /* Read in lto_in_decl_state objects.  */\n+  data_ptr = (const uint32_t *) ((const char*) data + decl_offset); \n+  data_end =\n+     (const uint32_t *) ((const char*) data_ptr + header->decl_state_size);\n+  num_decl_states = *data_ptr++;\n+  \n+  gcc_assert (num_decl_states > 0);\n+  decl_data->global_decl_state = lto_new_in_decl_state ();\n+  data_ptr = lto_read_in_decl_state (data_in, data_ptr,\n+\t\t\t\t     decl_data->global_decl_state);\n+\n+  /* Read in per-function decl states and enter them in hash table.  */\n+  decl_data->function_decl_states =\n+    hash_table<decl_state_hasher>::create_ggc (37);\n+\n+  for (i = 1; i < num_decl_states; i++)\n+    {\n+      struct lto_in_decl_state *state = lto_new_in_decl_state ();\n+\n+      data_ptr = lto_read_in_decl_state (data_in, data_ptr, state);\n+      lto_in_decl_state **slot\n+\t= decl_data->function_decl_states->find_slot (state, INSERT);\n+      gcc_assert (*slot == NULL);\n+      *slot = state;\n+    }\n+\n+  if (data_ptr != data_end)\n+    internal_error (\"bytecode stream: garbage at the end of symbols section\");\n+\n+  /* Set the current decl state to be the global state. */\n+  decl_data->current_decl_state = decl_data->global_decl_state;\n+\n+  lto_data_in_delete (data_in);\n+}\n+\n+/* Custom version of strtoll, which is not portable.  */\n+\n+static int64_t\n+lto_parse_hex (const char *p)\n+{\n+  int64_t ret = 0;\n+\n+  for (; *p != '\\0'; ++p)\n+    {\n+      char c = *p;\n+      unsigned char part;\n+      ret <<= 4;\n+      if (c >= '0' && c <= '9')\n+        part = c - '0';\n+      else if (c >= 'a' && c <= 'f')\n+        part = c - 'a' + 10;\n+      else if (c >= 'A' && c <= 'F')\n+        part = c - 'A' + 10;\n+      else\n+        internal_error (\"could not parse hex number\");\n+      ret |= part;\n+    }\n+\n+  return ret;\n+}\n+\n+/* Read resolution for file named FILE_NAME. The resolution is read from\n+   RESOLUTION. */\n+\n+static void\n+lto_resolution_read (splay_tree file_ids, FILE *resolution, lto_file *file)\n+{\n+  /* We require that objects in the resolution file are in the same\n+     order as the lto1 command line. */\n+  unsigned int name_len;\n+  char *obj_name;\n+  unsigned int num_symbols;\n+  unsigned int i;\n+  struct lto_file_decl_data *file_data;\n+  splay_tree_node nd = NULL; \n+\n+  if (!resolution)\n+    return;\n+\n+  name_len = strlen (file->filename);\n+  obj_name = XNEWVEC (char, name_len + 1);\n+  fscanf (resolution, \" \");   /* Read white space. */\n+\n+  fread (obj_name, sizeof (char), name_len, resolution);\n+  obj_name[name_len] = '\\0';\n+  if (filename_cmp (obj_name, file->filename) != 0)\n+    internal_error (\"unexpected file name %s in linker resolution file. \"\n+\t\t    \"Expected %s\", obj_name, file->filename);\n+  if (file->offset != 0)\n+    {\n+      int t;\n+      char offset_p[17];\n+      int64_t offset;\n+      t = fscanf (resolution, \"@0x%16s\", offset_p);\n+      if (t != 1)\n+        internal_error (\"could not parse file offset\");\n+      offset = lto_parse_hex (offset_p);\n+      if (offset != file->offset)\n+        internal_error (\"unexpected offset\");\n+    }\n+\n+  free (obj_name);\n+\n+  fscanf (resolution, \"%u\", &num_symbols);\n+\n+  for (i = 0; i < num_symbols; i++)\n+    {\n+      int t;\n+      unsigned index;\n+      unsigned HOST_WIDE_INT id;\n+      char r_str[27];\n+      enum ld_plugin_symbol_resolution r = (enum ld_plugin_symbol_resolution) 0;\n+      unsigned int j;\n+      unsigned int lto_resolution_str_len =\n+\tsizeof (lto_resolution_str) / sizeof (char *);\n+      res_pair rp;\n+\n+      t = fscanf (resolution, \"%u \" HOST_WIDE_INT_PRINT_HEX_PURE \" %26s %*[^\\n]\\n\", \n+\t\t  &index, &id, r_str);\n+      if (t != 3)\n+        internal_error (\"invalid line in the resolution file\");\n+\n+      for (j = 0; j < lto_resolution_str_len; j++)\n+\t{\n+\t  if (strcmp (lto_resolution_str[j], r_str) == 0)\n+\t    {\n+\t      r = (enum ld_plugin_symbol_resolution) j;\n+\t      break;\n+\t    }\n+\t}\n+      if (j == lto_resolution_str_len)\n+\tinternal_error (\"invalid resolution in the resolution file\");\n+\n+      if (!(nd && lto_splay_tree_id_equal_p (nd->key, id)))\n+\t{\n+\t  nd = lto_splay_tree_lookup (file_ids, id);\n+\t  if (nd == NULL)\n+\t    internal_error (\"resolution sub id %wx not in object file\", id);\n+\t}\n+\n+      file_data = (struct lto_file_decl_data *)nd->value;\n+      /* The indexes are very sparse. To save memory save them in a compact\n+         format that is only unpacked later when the subfile is processed. */\n+      rp.res = r;\n+      rp.index = index;\n+      file_data->respairs.safe_push (rp);\n+      if (file_data->max_index < index)\n+        file_data->max_index = index;\n+    }\n+}\n+\n+/* List of file_decl_datas */\n+struct file_data_list\n+  {\n+    struct lto_file_decl_data *first, *last;\n+  };\n+\n+/* Is the name for a id'ed LTO section? */\n+\n+static int \n+lto_section_with_id (const char *name, unsigned HOST_WIDE_INT *id)\n+{\n+  const char *s;\n+\n+  if (strncmp (name, section_name_prefix, strlen (section_name_prefix)))\n+    return 0;\n+  s = strrchr (name, '.');\n+  if (!s)\n+    return 0;\n+  /* If the section is not suffixed with an ID return.  */\n+  if ((size_t)(s - name) == strlen (section_name_prefix))\n+    return 0;\n+  return sscanf (s, \".\" HOST_WIDE_INT_PRINT_HEX_PURE, id) == 1;\n+}\n+\n+/* Create file_data of each sub file id */\n+\n+static int \n+create_subid_section_table (struct lto_section_slot *ls, splay_tree file_ids,\n+                            struct file_data_list *list)\n+{\n+  struct lto_section_slot s_slot, *new_slot;\n+  unsigned HOST_WIDE_INT id;\n+  splay_tree_node nd;\n+  void **hash_slot;\n+  char *new_name;\n+  struct lto_file_decl_data *file_data;\n+\n+  if (!lto_section_with_id (ls->name, &id))\n+    return 1;\n+  \n+  /* Find hash table of sub module id */\n+  nd = lto_splay_tree_lookup (file_ids, id);\n+  if (nd != NULL)\n+    {\n+      file_data = (struct lto_file_decl_data *)nd->value;\n+    }\n+  else\n+    {\n+      file_data = ggc_alloc<lto_file_decl_data> ();\n+      memset(file_data, 0, sizeof (struct lto_file_decl_data));\n+      file_data->id = id;\n+      file_data->section_hash_table = lto_obj_create_section_hash_table ();\n+      lto_splay_tree_insert (file_ids, id, file_data);\n+\n+      /* Maintain list in linker order */\n+      if (!list->first)\n+        list->first = file_data;\n+      if (list->last)\n+        list->last->next = file_data;\n+      list->last = file_data;\n+    }\n+\n+  /* Copy section into sub module hash table */\n+  new_name = XDUPVEC (char, ls->name, strlen (ls->name) + 1);\n+  s_slot.name = new_name;\n+  hash_slot = htab_find_slot (file_data->section_hash_table, &s_slot, INSERT);\n+  gcc_assert (*hash_slot == NULL);\n+\n+  new_slot = XDUP (struct lto_section_slot, ls);\n+  new_slot->name = new_name;\n+  *hash_slot = new_slot;\n+  return 1;\n+}\n+\n+/* Read declarations and other initializations for a FILE_DATA. */\n+\n+static void\n+lto_file_finalize (struct lto_file_decl_data *file_data, lto_file *file)\n+{\n+  const char *data;\n+  size_t len;\n+  vec<ld_plugin_symbol_resolution_t>\n+\tresolutions = vNULL;\n+  int i;\n+  res_pair *rp;\n+\n+  /* Create vector for fast access of resolution. We do this lazily\n+     to save memory. */ \n+  resolutions.safe_grow_cleared (file_data->max_index + 1);\n+  for (i = 0; file_data->respairs.iterate (i, &rp); i++)\n+    resolutions[rp->index] = rp->res;\n+  file_data->respairs.release ();\n+\n+  file_data->renaming_hash_table = lto_create_renaming_table ();\n+  file_data->file_name = file->filename;\n+#ifdef ACCEL_COMPILER\n+  lto_input_mode_table (file_data);\n+#else\n+  file_data->mode_table = lto_mode_identity_table;\n+#endif\n+  data = lto_get_section_data (file_data, LTO_section_decls, NULL, &len);\n+  if (data == NULL)\n+    {\n+      internal_error (\"cannot read LTO decls from %s\", file_data->file_name);\n+      return;\n+    }\n+  /* Frees resolutions */\n+  lto_read_decls (file_data, data, resolutions);\n+  lto_free_section_data (file_data, LTO_section_decls, NULL, data, len);\n+}\n+\n+/* Finalize FILE_DATA in FILE and increase COUNT. */\n+\n+static int \n+lto_create_files_from_ids (lto_file *file, struct lto_file_decl_data *file_data,\n+\t\t\t   int *count)\n+{\n+  lto_file_finalize (file_data, file);\n+  if (symtab->dump_file)\n+    fprintf (symtab->dump_file,\n+\t     \"Creating file %s with sub id \" HOST_WIDE_INT_PRINT_HEX \"\\n\",\n+\t     file_data->file_name, file_data->id);\n+  (*count)++;\n+  return 0;\n+}\n+\n+/* Generate a TREE representation for all types and external decls\n+   entities in FILE.  \n+\n+   Read all of the globals out of the file.  Then read the cgraph\n+   and process the .o index into the cgraph nodes so that it can open\n+   the .o file to load the functions and ipa information.   */\n+\n+static struct lto_file_decl_data *\n+lto_file_read (lto_file *file, FILE *resolution_file, int *count)\n+{\n+  struct lto_file_decl_data *file_data = NULL;\n+  splay_tree file_ids;\n+  htab_t section_hash_table;\n+  struct lto_section_slot *section;\n+  struct file_data_list file_list;\n+  struct lto_section_list section_list;\n+ \n+  memset (&section_list, 0, sizeof (struct lto_section_list)); \n+  section_hash_table = lto_obj_build_section_table (file, &section_list);\n+\n+  /* Find all sub modules in the object and put their sections into new hash\n+     tables in a splay tree. */\n+  file_ids = lto_splay_tree_new ();\n+  memset (&file_list, 0, sizeof (struct file_data_list));\n+  for (section = section_list.first; section != NULL; section = section->next)\n+    create_subid_section_table (section, file_ids, &file_list);\n+\n+  /* Add resolutions to file ids */\n+  lto_resolution_read (file_ids, resolution_file, file);\n+\n+  /* Finalize each lto file for each submodule in the merged object */\n+  for (file_data = file_list.first; file_data != NULL; file_data = file_data->next)\n+    lto_create_files_from_ids (file, file_data, count);\n+ \n+  splay_tree_delete (file_ids);\n+  htab_delete (section_hash_table);\n+\n+  return file_list.first;\n+}\n+\n+#if HAVE_MMAP_FILE && HAVE_SYSCONF && defined _SC_PAGE_SIZE\n+#define LTO_MMAP_IO 1\n+#endif\n+\n+#if LTO_MMAP_IO\n+/* Page size of machine is used for mmap and munmap calls.  */\n+static size_t page_mask;\n+#endif\n+\n+/* Get the section data of length LEN from FILENAME starting at\n+   OFFSET.  The data segment must be freed by the caller when the\n+   caller is finished.  Returns NULL if all was not well.  */\n+\n+static char *\n+lto_read_section_data (struct lto_file_decl_data *file_data,\n+\t\t       intptr_t offset, size_t len)\n+{\n+  char *result;\n+  static int fd = -1;\n+  static char *fd_name;\n+#if LTO_MMAP_IO\n+  intptr_t computed_len;\n+  intptr_t computed_offset;\n+  intptr_t diff;\n+#endif\n+\n+  /* Keep a single-entry file-descriptor cache.  The last file we\n+     touched will get closed at exit.\n+     ???  Eventually we want to add a more sophisticated larger cache\n+     or rather fix function body streaming to not stream them in\n+     practically random order.  */\n+  if (fd != -1\n+      && filename_cmp (fd_name, file_data->file_name) != 0)\n+    {\n+      free (fd_name);\n+      close (fd);\n+      fd = -1;\n+    }\n+  if (fd == -1)\n+    {\n+      fd = open (file_data->file_name, O_RDONLY|O_BINARY);\n+      if (fd == -1)\n+        {\n+\t  fatal_error (input_location, \"Cannot open %s\", file_data->file_name);\n+\t  return NULL;\n+        }\n+      fd_name = xstrdup (file_data->file_name);\n+    }\n+\n+#if LTO_MMAP_IO\n+  if (!page_mask)\n+    {\n+      size_t page_size = sysconf (_SC_PAGE_SIZE);\n+      page_mask = ~(page_size - 1);\n+    }\n+\n+  computed_offset = offset & page_mask;\n+  diff = offset - computed_offset;\n+  computed_len = len + diff;\n+\n+  result = (char *) mmap (NULL, computed_len, PROT_READ, MAP_PRIVATE,\n+\t\t\t  fd, computed_offset);\n+  if (result == MAP_FAILED)\n+    {\n+      fatal_error (input_location, \"Cannot map %s\", file_data->file_name);\n+      return NULL;\n+    }\n+\n+  return result + diff;\n+#else\n+  result = (char *) xmalloc (len);\n+  if (lseek (fd, offset, SEEK_SET) != offset\n+      || read (fd, result, len) != (ssize_t) len)\n+    {\n+      free (result);\n+      fatal_error (input_location, \"Cannot read %s\", file_data->file_name);\n+      result = NULL;\n+    }\n+#ifdef __MINGW32__\n+  /* Native windows doesn't supports delayed unlink on opened file. So\n+     we close file here again. This produces higher I/O load, but at least\n+     it prevents to have dangling file handles preventing unlink.  */\n+  free (fd_name);\n+  fd_name = NULL;\n+  close (fd);\n+  fd = -1;\n+#endif\n+  return result;\n+#endif\n+}    \n+\n+\n+/* Get the section data from FILE_DATA of SECTION_TYPE with NAME.\n+   NAME will be NULL unless the section type is for a function\n+   body.  */\n+\n+static const char *\n+get_section_data (struct lto_file_decl_data *file_data,\n+\t\t      enum lto_section_type section_type,\n+\t\t      const char *name,\n+\t\t      size_t *len)\n+{\n+  htab_t section_hash_table = file_data->section_hash_table;\n+  struct lto_section_slot *f_slot;\n+  struct lto_section_slot s_slot;\n+  const char *section_name = lto_get_section_name (section_type, name, file_data);\n+  char *data = NULL;\n+\n+  *len = 0;\n+  s_slot.name = section_name;\n+  f_slot = (struct lto_section_slot *) htab_find (section_hash_table, &s_slot);\n+  if (f_slot)\n+    {\n+      data = lto_read_section_data (file_data, f_slot->start, f_slot->len);\n+      *len = f_slot->len;\n+    }\n+\n+  free (CONST_CAST (char *, section_name));\n+  return data;\n+}\n+\n+\n+/* Free the section data from FILE_DATA of SECTION_TYPE with NAME that\n+   starts at OFFSET and has LEN bytes.  */\n+\n+static void\n+free_section_data (struct lto_file_decl_data *file_data ATTRIBUTE_UNUSED,\n+\t\t   enum lto_section_type section_type ATTRIBUTE_UNUSED,\n+\t\t   const char *name ATTRIBUTE_UNUSED,\n+\t\t   const char *offset, size_t len ATTRIBUTE_UNUSED)\n+{\n+#if LTO_MMAP_IO\n+  intptr_t computed_len;\n+  intptr_t computed_offset;\n+  intptr_t diff;\n+#endif\n+\n+#if LTO_MMAP_IO\n+  computed_offset = ((intptr_t) offset) & page_mask;\n+  diff = (intptr_t) offset - computed_offset;\n+  computed_len = len + diff;\n+\n+  munmap ((caddr_t) computed_offset, computed_len);\n+#else\n+  free (CONST_CAST(char *, offset));\n+#endif\n+}\n+\n+static lto_file *current_lto_file;\n+\n+/* If TT is a variable or function decl replace it with its\n+   prevailing variant.  */\n+#define LTO_SET_PREVAIL(tt) \\\n+  do {\\\n+    if ((tt) && VAR_OR_FUNCTION_DECL_P (tt) \\\n+\t&& (TREE_PUBLIC (tt) || DECL_EXTERNAL (tt))) \\\n+      { \\\n+        tt = lto_symtab_prevailing_decl (tt); \\\n+\tfixed = true; \\\n+      } \\\n+  } while (0)\n+\n+/* Ensure that TT isn't a replacable var of function decl.  */\n+#define LTO_NO_PREVAIL(tt) \\\n+  gcc_checking_assert (!(tt) || !VAR_OR_FUNCTION_DECL_P (tt))\n+\n+/* Given a tree T replace all fields referring to variables or functions\n+   with their prevailing variant.  */\n+static void\n+lto_fixup_prevailing_decls (tree t)\n+{\n+  enum tree_code code = TREE_CODE (t);\n+  bool fixed = false;\n+\n+  gcc_checking_assert (code != TREE_BINFO);\n+  LTO_NO_PREVAIL (TREE_TYPE (t));\n+  if (CODE_CONTAINS_STRUCT (code, TS_COMMON)\n+      /* lto_symtab_prevail_decl use TREE_CHAIN to link to the prevailing decl.\n+\t in the case T is a prevailed declaration we would ICE here. */\n+      && !VAR_OR_FUNCTION_DECL_P (t))\n+    LTO_NO_PREVAIL (TREE_CHAIN (t));\n+  if (DECL_P (t))\n+    {\n+      LTO_NO_PREVAIL (DECL_NAME (t));\n+      LTO_SET_PREVAIL (DECL_CONTEXT (t));\n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+\t{\n+\t  LTO_SET_PREVAIL (DECL_SIZE (t));\n+\t  LTO_SET_PREVAIL (DECL_SIZE_UNIT (t));\n+\t  LTO_SET_PREVAIL (DECL_INITIAL (t));\n+\t  LTO_NO_PREVAIL (DECL_ATTRIBUTES (t));\n+\t  LTO_SET_PREVAIL (DECL_ABSTRACT_ORIGIN (t));\n+\t}\n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n+\t{\n+\t  LTO_NO_PREVAIL (DECL_ASSEMBLER_NAME_RAW (t));\n+\t}\n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n+\t{\n+\t  LTO_NO_PREVAIL (DECL_RESULT_FLD (t));\n+\t}\n+      if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n+\t{\n+\t  LTO_NO_PREVAIL (DECL_ARGUMENTS (t));\n+\t  LTO_SET_PREVAIL (DECL_FUNCTION_PERSONALITY (t));\n+\t  LTO_NO_PREVAIL (DECL_VINDEX (t));\n+\t}\n+      if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n+\t{\n+\t  LTO_SET_PREVAIL (DECL_FIELD_OFFSET (t));\n+\t  LTO_NO_PREVAIL (DECL_BIT_FIELD_TYPE (t));\n+\t  LTO_NO_PREVAIL (DECL_QUALIFIER (t));\n+\t  LTO_NO_PREVAIL (DECL_FIELD_BIT_OFFSET (t));\n+\t  LTO_NO_PREVAIL (DECL_FCONTEXT (t));\n+\t}\n+    }\n+  else if (TYPE_P (t))\n+    {\n+      LTO_NO_PREVAIL (TYPE_CACHED_VALUES (t));\n+      LTO_SET_PREVAIL (TYPE_SIZE (t));\n+      LTO_SET_PREVAIL (TYPE_SIZE_UNIT (t));\n+      LTO_NO_PREVAIL (TYPE_ATTRIBUTES (t));\n+      LTO_NO_PREVAIL (TYPE_NAME (t));\n+\n+      LTO_SET_PREVAIL (TYPE_MIN_VALUE_RAW (t));\n+      LTO_SET_PREVAIL (TYPE_MAX_VALUE_RAW (t));\n+      LTO_NO_PREVAIL (TYPE_LANG_SLOT_1 (t));\n+\n+      LTO_SET_PREVAIL (TYPE_CONTEXT (t));\n+\n+      LTO_NO_PREVAIL (TYPE_CANONICAL (t));\n+      LTO_NO_PREVAIL (TYPE_MAIN_VARIANT (t));\n+      LTO_NO_PREVAIL (TYPE_NEXT_VARIANT (t));\n+    }\n+  else if (EXPR_P (t))\n+    {\n+      int i;\n+      for (i = TREE_OPERAND_LENGTH (t) - 1; i >= 0; --i)\n+\tLTO_SET_PREVAIL (TREE_OPERAND (t, i));\n+    }\n+  else if (TREE_CODE (t) == CONSTRUCTOR)\n+    {\n+      unsigned i;\n+      tree val;\n+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (t), i, val)\n+\tLTO_SET_PREVAIL (val);\n+    }\n+  else\n+    {\n+      switch (code)\n+\t{\n+\tcase TREE_LIST:\n+\t  LTO_SET_PREVAIL (TREE_VALUE (t));\n+\t  LTO_SET_PREVAIL (TREE_PURPOSE (t));\n+\t  LTO_NO_PREVAIL (TREE_PURPOSE (t));\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  /* If we fixed nothing, then we missed something seen by\n+     mentions_vars_p.  */\n+  gcc_checking_assert (fixed);\n+}\n+#undef LTO_SET_PREVAIL\n+#undef LTO_NO_PREVAIL\n+\n+/* Helper function of lto_fixup_decls. Walks the var and fn streams in STATE,\n+   replaces var and function decls with the corresponding prevailing def.  */\n+\n+static void\n+lto_fixup_state (struct lto_in_decl_state *state)\n+{\n+  unsigned i, si;\n+\n+  /* Although we only want to replace FUNCTION_DECLs and VAR_DECLs,\n+     we still need to walk from all DECLs to find the reachable\n+     FUNCTION_DECLs and VAR_DECLs.  */\n+  for (si = 0; si < LTO_N_DECL_STREAMS; si++)\n+    {\n+      vec<tree, va_gc> *trees = state->streams[si];\n+      for (i = 0; i < vec_safe_length (trees); i++)\n+\t{\n+\t  tree t = (*trees)[i];\n+\t  if (flag_checking && TYPE_P (t))\n+\t    verify_type (t);\n+\t  if (VAR_OR_FUNCTION_DECL_P (t)\n+\t      && (TREE_PUBLIC (t) || DECL_EXTERNAL (t)))\n+\t    (*trees)[i] = lto_symtab_prevailing_decl (t);\n+\t}\n+    }\n+}\n+\n+/* Fix the decls from all FILES. Replaces each decl with the corresponding\n+   prevailing one.  */\n+\n+static void\n+lto_fixup_decls (struct lto_file_decl_data **files)\n+{\n+  unsigned int i;\n+  tree t;\n+\n+  if (tree_with_vars)\n+    FOR_EACH_VEC_ELT ((*tree_with_vars), i, t)\n+      lto_fixup_prevailing_decls (t);\n+\n+  for (i = 0; files[i]; i++)\n+    {\n+      struct lto_file_decl_data *file = files[i];\n+      struct lto_in_decl_state *state = file->global_decl_state;\n+      lto_fixup_state (state);\n+\n+      hash_table<decl_state_hasher>::iterator iter;\n+      lto_in_decl_state *elt;\n+      FOR_EACH_HASH_TABLE_ELEMENT (*file->function_decl_states, elt,\n+\t\t\t\t   lto_in_decl_state *, iter)\n+\tlto_fixup_state (elt);\n+    }\n+}\n+\n+static GTY((length (\"lto_stats.num_input_files + 1\"))) struct lto_file_decl_data **all_file_decl_data;\n+\n+/* Turn file datas for sub files into a single array, so that they look\n+   like separate files for further passes. */\n+\n+static void\n+lto_flatten_files (struct lto_file_decl_data **orig, int count, int last_file_ix)\n+{\n+  struct lto_file_decl_data *n, *next;\n+  int i, k;\n+\n+  lto_stats.num_input_files = count;\n+  all_file_decl_data\n+    = ggc_cleared_vec_alloc<lto_file_decl_data_ptr> (count + 1);\n+  /* Set the hooks so that all of the ipa passes can read in their data.  */\n+  lto_set_in_hooks (all_file_decl_data, get_section_data, free_section_data);\n+  for (i = 0, k = 0; i < last_file_ix; i++) \n+    {\n+      for (n = orig[i]; n != NULL; n = next)\n+\t{\n+\t  all_file_decl_data[k++] = n;\n+\t  next = n->next;\n+\t  n->next = NULL;\n+\t}\n+    }\n+  all_file_decl_data[k] = NULL;\n+  gcc_assert (k == count);\n+}\n+\n+/* Input file data before flattening (i.e. splitting them to subfiles to support\n+   incremental linking.  */\n+static int real_file_count;\n+static GTY((length (\"real_file_count + 1\"))) struct lto_file_decl_data **real_file_decl_data;\n+\n+/* Read all the symbols from the input files FNAMES.  NFILES is the\n+   number of files requested in the command line.  Instantiate a\n+   global call graph by aggregating all the sub-graphs found in each\n+   file.  */\n+\n+void\n+read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n+{\n+  unsigned int i, last_file_ix;\n+  FILE *resolution;\n+  int count = 0;\n+  struct lto_file_decl_data **decl_data;\n+  symtab_node *snode;\n+\n+  symtab->initialize ();\n+\n+  timevar_push (TV_IPA_LTO_DECL_IN);\n+\n+#ifdef ACCEL_COMPILER\n+  section_name_prefix = OFFLOAD_SECTION_NAME_PREFIX;\n+  lto_stream_offload_p = true;\n+#endif\n+\n+  real_file_decl_data\n+    = decl_data = ggc_cleared_vec_alloc<lto_file_decl_data_ptr> (nfiles + 1);\n+  real_file_count = nfiles;\n+\n+  /* Read the resolution file.  */\n+  resolution = NULL;\n+  if (resolution_file_name)\n+    {\n+      int t;\n+      unsigned num_objects;\n+\n+      resolution = fopen (resolution_file_name, \"r\");\n+      if (resolution == NULL)\n+\tfatal_error (input_location,\n+\t\t     \"could not open symbol resolution file: %m\");\n+\n+      t = fscanf (resolution, \"%u\", &num_objects);\n+      gcc_assert (t == 1);\n+\n+      /* True, since the plugin splits the archives.  */\n+      gcc_assert (num_objects == nfiles);\n+    }\n+  symtab->state = LTO_STREAMING;\n+\n+  canonical_type_hash_cache = new hash_map<const_tree, hashval_t> (251);\n+  gimple_canonical_types = htab_create (16381, gimple_canonical_type_hash,\n+\t\t\t\t\tgimple_canonical_type_eq, NULL);\n+  gcc_obstack_init (&tree_scc_hash_obstack);\n+  tree_scc_hash = new hash_table<tree_scc_hasher> (4096);\n+\n+  /* Register the common node types with the canonical type machinery so\n+     we properly share alias-sets across languages and TUs.  Do not\n+     expose the common nodes as type merge target - those that should be\n+     are already exposed so by pre-loading the LTO streamer caches.\n+     Do two passes - first clear TYPE_CANONICAL and then re-compute it.  */\n+  for (i = 0; i < itk_none; ++i)\n+    lto_register_canonical_types (integer_types[i], true);\n+  for (i = 0; i < stk_type_kind_last; ++i)\n+    lto_register_canonical_types (sizetype_tab[i], true);\n+  for (i = 0; i < TI_MAX; ++i)\n+    lto_register_canonical_types (global_trees[i], true);\n+  for (i = 0; i < itk_none; ++i)\n+    lto_register_canonical_types (integer_types[i], false);\n+  for (i = 0; i < stk_type_kind_last; ++i)\n+    lto_register_canonical_types (sizetype_tab[i], false);\n+  for (i = 0; i < TI_MAX; ++i)\n+    lto_register_canonical_types (global_trees[i], false);\n+\n+  if (!quiet_flag)\n+    fprintf (stderr, \"Reading object files:\");\n+\n+  /* Read all of the object files specified on the command line.  */\n+  for (i = 0, last_file_ix = 0; i < nfiles; ++i)\n+    {\n+      struct lto_file_decl_data *file_data = NULL;\n+      if (!quiet_flag)\n+\t{\n+\t  fprintf (stderr, \" %s\", fnames[i]);\n+\t  fflush (stderr);\n+\t}\n+\n+      current_lto_file = lto_obj_file_open (fnames[i], false);\n+      if (!current_lto_file)\n+\tbreak;\n+\n+      file_data = lto_file_read (current_lto_file, resolution, &count);\n+      if (!file_data)\n+\t{\n+\t  lto_obj_file_close (current_lto_file);\n+\t  free (current_lto_file);\n+\t  current_lto_file = NULL;\n+\t  break;\n+\t}\n+\n+      decl_data[last_file_ix++] = file_data;\n+\n+      lto_obj_file_close (current_lto_file);\n+      free (current_lto_file);\n+      current_lto_file = NULL;\n+    }\n+\n+  lto_flatten_files (decl_data, count, last_file_ix);\n+  lto_stats.num_input_files = count;\n+  ggc_free(decl_data);\n+  real_file_decl_data = NULL;\n+\n+  if (resolution_file_name)\n+    fclose (resolution);\n+\n+  /* Show the LTO report before launching LTRANS.  */\n+  if (flag_lto_report || (flag_wpa && flag_lto_report_wpa))\n+    print_lto_report_1 ();\n+\n+  /* Free gimple type merging datastructures.  */\n+  delete tree_scc_hash;\n+  tree_scc_hash = NULL;\n+  obstack_free (&tree_scc_hash_obstack, NULL);\n+  htab_delete (gimple_canonical_types);\n+  gimple_canonical_types = NULL;\n+  delete canonical_type_hash_cache;\n+  canonical_type_hash_cache = NULL;\n+\n+  /* At this stage we know that majority of GGC memory is reachable.  \n+     Growing the limits prevents unnecesary invocation of GGC.  */\n+  ggc_grow ();\n+  ggc_collect ();\n+\n+  /* Set the hooks so that all of the ipa passes can read in their data.  */\n+  lto_set_in_hooks (all_file_decl_data, get_section_data, free_section_data);\n+\n+  timevar_pop (TV_IPA_LTO_DECL_IN);\n+\n+  if (!quiet_flag)\n+    fprintf (stderr, \"\\nReading the callgraph\\n\");\n+\n+  timevar_push (TV_IPA_LTO_CGRAPH_IO);\n+  /* Read the symtab.  */\n+  input_symtab ();\n+\n+  input_offload_tables (!flag_ltrans);\n+\n+  /* Store resolutions into the symbol table.  */\n+\n+  FOR_EACH_SYMBOL (snode)\n+    if (snode->externally_visible && snode->real_symbol_p ()\n+\t&& snode->lto_file_data && snode->lto_file_data->resolution_map\n+\t&& !(TREE_CODE (snode->decl) == FUNCTION_DECL\n+\t     && fndecl_built_in_p (snode->decl))\n+\t&& !(VAR_P (snode->decl) && DECL_HARD_REGISTER (snode->decl)))\n+      {\n+\tld_plugin_symbol_resolution_t *res;\n+\n+\tres = snode->lto_file_data->resolution_map->get (snode->decl);\n+\tif (!res || *res == LDPR_UNKNOWN)\n+\t  {\n+\t    if (snode->output_to_lto_symbol_table_p ())\n+\t      fatal_error (input_location, \"missing resolution data for %s\",\n+\t\t           IDENTIFIER_POINTER\n+\t\t\t     (DECL_ASSEMBLER_NAME (snode->decl)));\n+\t  }\n+\telse\n+          snode->resolution = *res;\n+      }\n+  for (i = 0; all_file_decl_data[i]; i++)\n+    if (all_file_decl_data[i]->resolution_map)\n+      {\n+        delete all_file_decl_data[i]->resolution_map;\n+        all_file_decl_data[i]->resolution_map = NULL;\n+      }\n+  \n+  timevar_pop (TV_IPA_LTO_CGRAPH_IO);\n+\n+  if (!quiet_flag)\n+    fprintf (stderr, \"Merging declarations\\n\");\n+\n+  timevar_push (TV_IPA_LTO_DECL_MERGE);\n+  /* Merge global decls.  In ltrans mode we read merged cgraph, we do not\n+     need to care about resolving symbols again, we only need to replace\n+     duplicated declarations read from the callgraph and from function\n+     sections.  */\n+  if (!flag_ltrans)\n+    {\n+      lto_symtab_merge_decls ();\n+\n+      /* If there were errors during symbol merging bail out, we have no\n+\t good way to recover here.  */\n+      if (seen_error ())\n+\tfatal_error (input_location,\n+\t\t     \"errors during merging of translation units\");\n+\n+      /* Fixup all decls.  */\n+      lto_fixup_decls (all_file_decl_data);\n+    }\n+  if (tree_with_vars)\n+    ggc_free (tree_with_vars);\n+  tree_with_vars = NULL;\n+  ggc_collect ();\n+\n+  timevar_pop (TV_IPA_LTO_DECL_MERGE);\n+  /* Each pass will set the appropriate timer.  */\n+\n+  if (!quiet_flag)\n+    fprintf (stderr, \"Reading summaries\\n\");\n+\n+  /* Read the IPA summary data.  */\n+  if (flag_ltrans)\n+    ipa_read_optimization_summaries ();\n+  else\n+    ipa_read_summaries ();\n+\n+  for (i = 0; all_file_decl_data[i]; i++)\n+    {\n+      gcc_assert (all_file_decl_data[i]->symtab_node_encoder);\n+      lto_symtab_encoder_delete (all_file_decl_data[i]->symtab_node_encoder);\n+      all_file_decl_data[i]->symtab_node_encoder = NULL;\n+      lto_free_function_in_decl_state (all_file_decl_data[i]->global_decl_state);\n+      all_file_decl_data[i]->global_decl_state = NULL;\n+      all_file_decl_data[i]->current_decl_state = NULL; \n+    }\n+\n+  if (!flag_ltrans)\n+    {\n+      /* Finally merge the cgraph according to the decl merging decisions.  */\n+      timevar_push (TV_IPA_LTO_CGRAPH_MERGE);\n+\n+      gcc_assert (!dump_file);\n+      dump_file = dump_begin (lto_link_dump_id, NULL);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Before merging:\\n\");\n+\t  symtab->dump (dump_file);\n+\t}\n+      lto_symtab_merge_symbols ();\n+      /* Removal of unreachable symbols is needed to make verify_symtab to pass;\n+\t we are still having duplicated comdat groups containing local statics.\n+\t We could also just remove them while merging.  */\n+      symtab->remove_unreachable_nodes (dump_file);\n+      ggc_collect ();\n+\n+      if (dump_file)\n+        dump_end (lto_link_dump_id, dump_file);\n+      dump_file = NULL;\n+      timevar_pop (TV_IPA_LTO_CGRAPH_MERGE);\n+    }\n+  symtab->state = IPA_SSA;\n+  /* All node removals happening here are useless, because\n+     WPA should not stream them.  Still always perform remove_unreachable_nodes\n+     because we may reshape clone tree, get rid of dead masters of inline\n+     clones and remove symbol entries for read-only variables we keep around\n+     only to be able to constant fold them.  */\n+  if (flag_ltrans)\n+    {\n+      if (symtab->dump_file)\n+\t symtab->dump (symtab->dump_file);\n+      symtab->remove_unreachable_nodes (symtab->dump_file);\n+    }\n+\n+  /* Indicate that the cgraph is built and ready.  */\n+  symtab->function_flags_ready = true;\n+\n+  ggc_free (all_file_decl_data);\n+  all_file_decl_data = NULL;\n+}\n+\n+\n+\n+/* Show various memory usage statistics related to LTO.  */\n+void\n+print_lto_report_1 (void)\n+{\n+  const char *pfx = (flag_lto) ? \"LTO\" : (flag_wpa) ? \"WPA\" : \"LTRANS\";\n+  fprintf (stderr, \"%s statistics\\n\", pfx);\n+\n+  fprintf (stderr, \"[%s] read %lu SCCs of average size %f\\n\",\n+\t   pfx, num_sccs_read, total_scc_size / (double)num_sccs_read);\n+  fprintf (stderr, \"[%s] %lu tree bodies read in total\\n\", pfx, total_scc_size);\n+  if (flag_wpa && tree_scc_hash)\n+    {\n+      fprintf (stderr, \"[%s] tree SCC table: size %ld, %ld elements, \"\n+\t       \"collision ratio: %f\\n\", pfx,\n+\t       (long) tree_scc_hash->size (),\n+\t       (long) tree_scc_hash->elements (),\n+\t       tree_scc_hash->collisions ());\n+      hash_table<tree_scc_hasher>::iterator hiter;\n+      tree_scc *scc, *max_scc = NULL;\n+      unsigned max_length = 0;\n+      FOR_EACH_HASH_TABLE_ELEMENT (*tree_scc_hash, scc, x, hiter)\n+\t{\n+\t  unsigned length = 0;\n+\t  tree_scc *s = scc;\n+\t  for (; s; s = s->next)\n+\t    length++;\n+\t  if (length > max_length)\n+\t    {\n+\t      max_length = length;\n+\t      max_scc = scc;\n+\t    }\n+\t}\n+      fprintf (stderr, \"[%s] tree SCC max chain length %u (size %u)\\n\",\n+\t       pfx, max_length, max_scc->len);\n+      fprintf (stderr, \"[%s] Compared %lu SCCs, %lu collisions (%f)\\n\", pfx,\n+\t       num_scc_compares, num_scc_compare_collisions,\n+\t       num_scc_compare_collisions / (double) num_scc_compares);\n+      fprintf (stderr, \"[%s] Merged %lu SCCs\\n\", pfx, num_sccs_merged);\n+      fprintf (stderr, \"[%s] Merged %lu tree bodies\\n\", pfx,\n+\t       total_scc_size_merged);\n+      fprintf (stderr, \"[%s] Merged %lu types\\n\", pfx, num_merged_types);\n+      fprintf (stderr, \"[%s] %lu types prevailed (%lu associated trees)\\n\",\n+\t       pfx, num_prevailing_types, num_type_scc_trees);\n+      fprintf (stderr, \"[%s] GIMPLE canonical type table: size %ld, \"\n+\t       \"%ld elements, %ld searches, %ld collisions (ratio: %f)\\n\", pfx,\n+\t       (long) htab_size (gimple_canonical_types),\n+\t       (long) htab_elements (gimple_canonical_types),\n+\t       (long) gimple_canonical_types->searches,\n+\t       (long) gimple_canonical_types->collisions,\n+\t       htab_collisions (gimple_canonical_types));\n+      fprintf (stderr, \"[%s] GIMPLE canonical type pointer-map: \"\n+\t       \"%lu elements, %ld searches\\n\", pfx,\n+\t       num_canonical_type_hash_entries,\n+\t       num_canonical_type_hash_queries);\n+    }\n+\n+  print_lto_report (pfx);\n+}\n+\n+GTY(()) tree lto_eh_personality_decl;\n+\n+/* Return the LTO personality function decl.  */\n+\n+tree\n+lto_eh_personality (void)\n+{\n+  if (!lto_eh_personality_decl)\n+    {\n+      /* Use the first personality DECL for our personality if we don't\n+\t support multiple ones.  This ensures that we don't artificially\n+\t create the need for them in a single-language program.  */\n+      if (first_personality_decl && !dwarf2out_do_cfi_asm ())\n+\tlto_eh_personality_decl = first_personality_decl;\n+      else\n+\tlto_eh_personality_decl = lhd_gcc_personality ();\n+    }\n+\n+  return lto_eh_personality_decl;\n+}\n+\n+/* Set the process name based on the LTO mode. */\n+\n+static void \n+lto_process_name (void)\n+{\n+  if (flag_lto)\n+    setproctitle (flag_incremental_link == INCREMENTAL_LINK_LTO\n+\t\t  ? \"lto1-inclink\" : \"lto1-lto\");\n+  if (flag_wpa)\n+    setproctitle (\"lto1-wpa\");\n+  if (flag_ltrans)\n+    setproctitle (\"lto1-ltrans\");\n+}\n+\n+\n+/* Initialize the LTO front end.  */\n+\n+void\n+lto_fe_init (void)\n+{\n+  lto_process_name ();\n+  lto_streamer_hooks_init ();\n+  lto_reader_init ();\n+  lto_set_in_hooks (NULL, get_section_data, free_section_data);\n+  memset (&lto_stats, 0, sizeof (lto_stats));\n+  bitmap_obstack_initialize (NULL);\n+  gimple_register_cfg_hooks ();\n+#ifndef ACCEL_COMPILER\n+  unsigned char *table\n+    = ggc_vec_alloc<unsigned char> (MAX_MACHINE_MODE);\n+  for (int m = 0; m < MAX_MACHINE_MODE; m++)\n+    table[m] = m;\n+  lto_mode_identity_table = table;\n+#endif\n+}\n+\n+#include \"gt-lto-lto-common.h\""}, {"sha": "b1209a3a3059587caa52226a73082983d38fbe63", "filename": "gcc/lto/lto-common.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79420f995764129dc40d1abcbf8ce75a0b0f906/gcc%2Flto%2Flto-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79420f995764129dc40d1abcbf8ce75a0b0f906/gcc%2Flto%2Flto-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-common.h?ref=a79420f995764129dc40d1abcbf8ce75a0b0f906", "patch": "@@ -0,0 +1,33 @@\n+/* LTO common functions between lto.c and lto-dump.c header file.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef LTO_COMMON_H\n+#define LTO_COMMON_H\n+\n+void lto_fe_init (void);\n+void read_cgraph_and_symbols (unsigned, const char **);\n+void print_lto_report_1 (void);\n+\n+extern tree lto_eh_personality_decl;\n+extern GTY(()) vec<tree, va_gc> *tree_with_vars;\n+extern const unsigned char *lto_mode_identity_table;\n+extern tree first_personality_decl;\n+\n+#endif\n+"}, {"sha": "b88ca09d102c114931b4b2b53d6847ee8358159b", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79420f995764129dc40d1abcbf8ce75a0b0f906/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79420f995764129dc40d1abcbf8ce75a0b0f906/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=a79420f995764129dc40d1abcbf8ce75a0b0f906", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"lto-tree.h\"\n #include \"lto.h\"\n+#include \"lto-common.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n "}, {"sha": "20c2efffedaa36a8e2ebcac12b745da9a1af60f4", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 26, "deletions": 2811, "changes": 2837, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a79420f995764129dc40d1abcbf8ce75a0b0f906/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a79420f995764129dc40d1abcbf8ce75a0b0f906/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=a79420f995764129dc40d1abcbf8ce75a0b0f906", "patch": "@@ -38,7 +38,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"symbol-summary.h\"\n #include \"tree-vrp.h\"\n #include \"ipa-prop.h\"\n-#include \"common.h\"\n #include \"debug.h\"\n #include \"lto.h\"\n #include \"lto-section-names.h\"\n@@ -55,122 +54,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"fold-const.h\"\n #include \"attribs.h\"\n #include \"builtins.h\"\n+#include \"lto-common.h\"\n \n \n /* Number of parallel tasks to run, -1 if we want to use GNU Make jobserver.  */\n static int lto_parallelism;\n \n-static GTY(()) tree first_personality_decl;\n-\n-static GTY(()) const unsigned char *lto_mode_identity_table;\n-\n-/* Returns a hash code for P.  */\n-\n-static hashval_t\n-hash_name (const void *p)\n-{\n-  const struct lto_section_slot *ds = (const struct lto_section_slot *) p;\n-  return (hashval_t) htab_hash_string (ds->name);\n-}\n-\n-\n-/* Returns nonzero if P1 and P2 are equal.  */\n-\n-static int\n-eq_name (const void *p1, const void *p2)\n-{\n-  const struct lto_section_slot *s1 =\n-    (const struct lto_section_slot *) p1;\n-  const struct lto_section_slot *s2 =\n-    (const struct lto_section_slot *) p2;\n-\n-  return strcmp (s1->name, s2->name) == 0;\n-}\n-\n-/* Free lto_section_slot */\n-\n-static void\n-free_with_string (void *arg)\n-{\n-  struct lto_section_slot *s = (struct lto_section_slot *)arg;\n-\n-  free (CONST_CAST (char *, s->name));\n-  free (arg);\n-}\n-\n-/* Create section hash table */\n-\n-htab_t \n-lto_obj_create_section_hash_table (void)\n-{\n-  return htab_create (37, hash_name, eq_name, free_with_string);\n-}\n-\n-/* Delete an allocated integer KEY in the splay tree.  */\n-\n-static void\n-lto_splay_tree_delete_id (splay_tree_key key)\n-{\n-  free ((void *) key);\n-}\n-\n-/* Compare splay tree node ids A and B.  */\n-\n-static int\n-lto_splay_tree_compare_ids (splay_tree_key a, splay_tree_key b)\n-{\n-  unsigned HOST_WIDE_INT ai;\n-  unsigned HOST_WIDE_INT bi;\n-\n-  ai = *(unsigned HOST_WIDE_INT *) a;\n-  bi = *(unsigned HOST_WIDE_INT *) b;\n-\n-  if (ai < bi)\n-    return -1;\n-  else if (ai > bi)\n-    return 1;\n-  return 0;\n-}\n-\n-/* Look up splay tree node by ID in splay tree T.  */\n-\n-static splay_tree_node\n-lto_splay_tree_lookup (splay_tree t, unsigned HOST_WIDE_INT id)\n-{\n-  return splay_tree_lookup (t, (splay_tree_key) &id);\n-}\n-\n-/* Check if KEY has ID.  */\n-\n-static bool\n-lto_splay_tree_id_equal_p (splay_tree_key key, unsigned HOST_WIDE_INT id)\n-{\n-  return *(unsigned HOST_WIDE_INT *) key == id;\n-}\n-\n-/* Insert a splay tree node into tree T with ID as key and FILE_DATA as value. \n-   The ID is allocated separately because we need HOST_WIDE_INTs which may\n-   be wider than a splay_tree_key. */\n-\n-static void\n-lto_splay_tree_insert (splay_tree t, unsigned HOST_WIDE_INT id,\n-\t\t       struct lto_file_decl_data *file_data)\n-{\n-  unsigned HOST_WIDE_INT *idp = XCNEW (unsigned HOST_WIDE_INT);\n-  *idp = id;\n-  splay_tree_insert (t, (splay_tree_key) idp, (splay_tree_value) file_data);\n-}\n-\n-/* Create a splay tree.  */\n-\n-static splay_tree\n-lto_splay_tree_new (void)\n-{\n-  return splay_tree_new (lto_splay_tree_compare_ids,\n-\t \t         lto_splay_tree_delete_id,\n-\t\t\t NULL);\n-}\n-\n /* Return true when NODE has a clone that is analyzed (i.e. we need\n    to load its body even if the node itself is not needed).  */\n \n@@ -224,2083 +113,45 @@ lto_materialize_function (struct cgraph_node *node)\n   rest_of_decl_compilation (decl, 1, 0);\n }\n \n-\n-/* Decode the content of memory pointed to by DATA in the in decl\n-   state object STATE. DATA_IN points to a data_in structure for\n-   decoding. Return the address after the decoded object in the\n-   input.  */\n-\n-static const uint32_t *\n-lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n-\t\t\tstruct lto_in_decl_state *state)\n-{\n-  uint32_t ix;\n-  tree decl;\n-  uint32_t i, j;\n-\n-  ix = *data++;\n-  state->compressed = ix & 1;\n-  ix /= 2;\n-  decl = streamer_tree_cache_get_tree (data_in->reader_cache, ix);\n-  if (!VAR_OR_FUNCTION_DECL_P (decl))\n-    {\n-      gcc_assert (decl == void_type_node);\n-      decl = NULL_TREE;\n-    }\n-  state->fn_decl = decl;\n-\n-  for (i = 0; i < LTO_N_DECL_STREAMS; i++)\n-    {\n-      uint32_t size = *data++;\n-      vec<tree, va_gc> *decls = NULL;\n-      vec_alloc (decls, size);\n-\n-      for (j = 0; j < size; j++)\n-\tvec_safe_push (decls,\n-\t\t       streamer_tree_cache_get_tree (data_in->reader_cache,\n-\t\t\t\t\t\t     data[j]));\n-\n-      state->streams[i] = decls;\n-      data += size;\n-    }\n-\n-  return data;\n-}\n-\n-\n-/* Global canonical type table.  */\n-static htab_t gimple_canonical_types;\n-static hash_map<const_tree, hashval_t> *canonical_type_hash_cache;\n-static unsigned long num_canonical_type_hash_entries;\n-static unsigned long num_canonical_type_hash_queries;\n-\n-static void iterative_hash_canonical_type (tree type, inchash::hash &hstate);\n-static hashval_t gimple_canonical_type_hash (const void *p);\n-static void gimple_register_canonical_type_1 (tree t, hashval_t hash);\n-\n-/* Returning a hash value for gimple type TYPE.\n-\n-   The hash value returned is equal for types considered compatible\n-   by gimple_canonical_types_compatible_p.  */\n-\n-static hashval_t\n-hash_canonical_type (tree type)\n-{\n-  inchash::hash hstate;\n-  enum tree_code code;\n-\n-  /* We compute alias sets only for types that needs them.\n-     Be sure we do not recurse to something else as we cannot hash incomplete\n-     types in a way they would have same hash value as compatible complete\n-     types.  */\n-  gcc_checking_assert (type_with_alias_set_p (type));\n-\n-  /* Combine a few common features of types so that types are grouped into\n-     smaller sets; when searching for existing matching types to merge,\n-     only existing types having the same features as the new type will be\n-     checked.  */\n-  code = tree_code_for_canonical_type_merging (TREE_CODE (type));\n-  hstate.add_int (code);\n-  hstate.add_int (TYPE_MODE (type));\n-\n-  /* Incorporate common features of numerical types.  */\n-  if (INTEGRAL_TYPE_P (type)\n-      || SCALAR_FLOAT_TYPE_P (type)\n-      || FIXED_POINT_TYPE_P (type)\n-      || TREE_CODE (type) == OFFSET_TYPE\n-      || POINTER_TYPE_P (type))\n-    {\n-      hstate.add_int (TYPE_PRECISION (type));\n-      if (!type_with_interoperable_signedness (type))\n-        hstate.add_int (TYPE_UNSIGNED (type));\n-    }\n-\n-  if (VECTOR_TYPE_P (type))\n-    {\n-      hstate.add_poly_int (TYPE_VECTOR_SUBPARTS (type));\n-      hstate.add_int (TYPE_UNSIGNED (type));\n-    }\n-\n-  if (TREE_CODE (type) == COMPLEX_TYPE)\n-    hstate.add_int (TYPE_UNSIGNED (type));\n-\n-  /* Fortran's C_SIGNED_CHAR is !TYPE_STRING_FLAG but needs to be\n-     interoperable with \"signed char\".  Unless all frontends are revisited to\n-     agree on these types, we must ignore the flag completely.  */\n-\n-  /* Fortran standard define C_PTR type that is compatible with every\n-     C pointer.  For this reason we need to glob all pointers into one.\n-     Still pointers in different address spaces are not compatible.  */\n-  if (POINTER_TYPE_P (type))\n-    hstate.add_int (TYPE_ADDR_SPACE (TREE_TYPE (type)));\n-\n-  /* For array types hash the domain bounds and the string flag.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n-    {\n-      hstate.add_int (TYPE_STRING_FLAG (type));\n-      /* OMP lowering can introduce error_mark_node in place of\n-\t random local decls in types.  */\n-      if (TYPE_MIN_VALUE (TYPE_DOMAIN (type)) != error_mark_node)\n-\tinchash::add_expr (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), hstate);\n-      if (TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != error_mark_node)\n-\tinchash::add_expr (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), hstate);\n-    }\n-\n-  /* Recurse for aggregates with a single element type.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE\n-      || TREE_CODE (type) == COMPLEX_TYPE\n-      || TREE_CODE (type) == VECTOR_TYPE)\n-    iterative_hash_canonical_type (TREE_TYPE (type), hstate);\n-\n-  /* Incorporate function return and argument types.  */\n-  if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n-    {\n-      unsigned na;\n-      tree p;\n-\n-      iterative_hash_canonical_type (TREE_TYPE (type), hstate);\n-\n-      for (p = TYPE_ARG_TYPES (type), na = 0; p; p = TREE_CHAIN (p))\n-\t{\n-\t  iterative_hash_canonical_type (TREE_VALUE (p), hstate);\n-\t  na++;\n-\t}\n-\n-      hstate.add_int (na);\n-    }\n-\n-  if (RECORD_OR_UNION_TYPE_P (type))\n-    {\n-      unsigned nf;\n-      tree f;\n-\n-      for (f = TYPE_FIELDS (type), nf = 0; f; f = TREE_CHAIN (f))\n-\tif (TREE_CODE (f) == FIELD_DECL\n-\t    && (! DECL_SIZE (f)\n-\t\t|| ! integer_zerop (DECL_SIZE (f))))\n-\t  {\n-\t    iterative_hash_canonical_type (TREE_TYPE (f), hstate);\n-\t    nf++;\n-\t  }\n-\n-      hstate.add_int (nf);\n-    }\n-\n-  return hstate.end();\n-}\n-\n-/* Returning a hash value for gimple type TYPE combined with VAL.  */\n-\n-static void\n-iterative_hash_canonical_type (tree type, inchash::hash &hstate)\n-{\n-  hashval_t v;\n-\n-  /* All type variants have same TYPE_CANONICAL.  */\n-  type = TYPE_MAIN_VARIANT (type);\n-\n-  if (!canonical_type_used_p (type))\n-    v = hash_canonical_type (type);\n-  /* An already processed type.  */\n-  else if (TYPE_CANONICAL (type))\n-    {\n-      type = TYPE_CANONICAL (type);\n-      v = gimple_canonical_type_hash (type);\n-    }\n-  else\n-    {\n-      /* Canonical types should not be able to form SCCs by design, this\n-\t recursion is just because we do not register canonical types in\n-\t optimal order.  To avoid quadratic behavior also register the\n-\t type here.  */\n-      v = hash_canonical_type (type);\n-      gimple_register_canonical_type_1 (type, v);\n-    }\n-  hstate.add_int (v);\n-}\n-\n-/* Returns the hash for a canonical type P.  */\n-\n-static hashval_t\n-gimple_canonical_type_hash (const void *p)\n-{\n-  num_canonical_type_hash_queries++;\n-  hashval_t *slot = canonical_type_hash_cache->get ((const_tree) p);\n-  gcc_assert (slot != NULL);\n-  return *slot;\n-}\n-\n-\n-\n-/* Returns nonzero if P1 and P2 are equal.  */\n-\n-static int\n-gimple_canonical_type_eq (const void *p1, const void *p2)\n-{\n-  const_tree t1 = (const_tree) p1;\n-  const_tree t2 = (const_tree) p2;\n-  return gimple_canonical_types_compatible_p (CONST_CAST_TREE (t1),\n-\t\t\t\t\t      CONST_CAST_TREE (t2));\n-}\n-\n-/* Main worker for gimple_register_canonical_type.  */\n-\n-static void\n-gimple_register_canonical_type_1 (tree t, hashval_t hash)\n-{\n-  void **slot;\n-\n-  gcc_checking_assert (TYPE_P (t) && !TYPE_CANONICAL (t)\n-\t\t       && type_with_alias_set_p (t)\n-\t\t       && canonical_type_used_p (t));\n-\n-  slot = htab_find_slot_with_hash (gimple_canonical_types, t, hash, INSERT);\n-  if (*slot)\n-    {\n-      tree new_type = (tree)(*slot);\n-      gcc_checking_assert (new_type != t);\n-      TYPE_CANONICAL (t) = new_type;\n-    }\n-  else\n-    {\n-      TYPE_CANONICAL (t) = t;\n-      *slot = (void *) t;\n-      /* Cache the just computed hash value.  */\n-      num_canonical_type_hash_entries++;\n-      bool existed_p = canonical_type_hash_cache->put (t, hash);\n-      gcc_assert (!existed_p);\n-    }\n-}\n-\n-/* Register type T in the global type table gimple_types and set\n-   TYPE_CANONICAL of T accordingly.\n-   This is used by LTO to merge structurally equivalent types for\n-   type-based aliasing purposes across different TUs and languages.\n-\n-   ???  This merging does not exactly match how the tree.c middle-end\n-   functions will assign TYPE_CANONICAL when new types are created\n-   during optimization (which at least happens for pointer and array\n-   types).  */\n-\n-static void\n-gimple_register_canonical_type (tree t)\n-{\n-  if (TYPE_CANONICAL (t) || !type_with_alias_set_p (t)\n-      || !canonical_type_used_p (t))\n-    return;\n-\n-  /* Canonical types are same among all complete variants.  */\n-  if (TYPE_CANONICAL (TYPE_MAIN_VARIANT (t)))\n-    TYPE_CANONICAL (t) = TYPE_CANONICAL (TYPE_MAIN_VARIANT (t));\n-  else\n-    {\n-      gimple_register_canonical_type_1 (TYPE_MAIN_VARIANT (t),\n-\t\t\t\t\thash_canonical_type (TYPE_MAIN_VARIANT (t)));\n-      TYPE_CANONICAL (t) = TYPE_CANONICAL (TYPE_MAIN_VARIANT (t));\n-    }\n-}\n-\n-/* Re-compute TYPE_CANONICAL for NODE and related types.  */\n+/* Materialize all the bodies for all the nodes in the callgraph.  */\n \n static void\n-lto_register_canonical_types (tree node, bool first_p)\n-{\n-  if (!node\n-      || !TYPE_P (node))\n-    return;\n-\n-  if (first_p)\n-    TYPE_CANONICAL (node) = NULL_TREE;\n-\n-  if (POINTER_TYPE_P (node)\n-      || TREE_CODE (node) == COMPLEX_TYPE\n-      || TREE_CODE (node) == ARRAY_TYPE)\n-    lto_register_canonical_types (TREE_TYPE (node), first_p);\n-\n- if (!first_p) \n-    gimple_register_canonical_type (node);\n-}\n-\n-\n-/* Remember trees that contains references to declarations.  */\n-static GTY(()) vec <tree, va_gc> *tree_with_vars;\n-\n-#define CHECK_VAR(tt) \\\n-  do \\\n-    { \\\n-      if ((tt) && VAR_OR_FUNCTION_DECL_P (tt) \\\n-\t  && (TREE_PUBLIC (tt) || DECL_EXTERNAL (tt))) \\\n-\treturn true; \\\n-    } while (0)\n-\n-#define CHECK_NO_VAR(tt) \\\n-  gcc_checking_assert (!(tt) || !VAR_OR_FUNCTION_DECL_P (tt))\n-\n-/* Check presence of pointers to decls in fields of a tree_typed T.  */\n-\n-static inline bool\n-mentions_vars_p_typed (tree t)\n-{\n-  CHECK_NO_VAR (TREE_TYPE (t));\n-  return false;\n-}\n-\n-/* Check presence of pointers to decls in fields of a tree_common T.  */\n-\n-static inline bool\n-mentions_vars_p_common (tree t)\n-{\n-  if (mentions_vars_p_typed (t))\n-    return true;\n-  CHECK_NO_VAR (TREE_CHAIN (t));\n-  return false;\n-}\n-\n-/* Check presence of pointers to decls in fields of a decl_minimal T.  */\n-\n-static inline bool\n-mentions_vars_p_decl_minimal (tree t)\n-{\n-  if (mentions_vars_p_common (t))\n-    return true;\n-  CHECK_NO_VAR (DECL_NAME (t));\n-  CHECK_VAR (DECL_CONTEXT (t));\n-  return false;\n-}\n-\n-/* Check presence of pointers to decls in fields of a decl_common T.  */\n-\n-static inline bool\n-mentions_vars_p_decl_common (tree t)\n-{\n-  if (mentions_vars_p_decl_minimal (t))\n-    return true;\n-  CHECK_VAR (DECL_SIZE (t));\n-  CHECK_VAR (DECL_SIZE_UNIT (t));\n-  CHECK_VAR (DECL_INITIAL (t));\n-  CHECK_NO_VAR (DECL_ATTRIBUTES (t));\n-  CHECK_VAR (DECL_ABSTRACT_ORIGIN (t));\n-  return false;\n-}\n-\n-/* Check presence of pointers to decls in fields of a decl_with_vis T.  */\n-\n-static inline bool\n-mentions_vars_p_decl_with_vis (tree t)\n-{\n-  if (mentions_vars_p_decl_common (t))\n-    return true;\n-\n-  /* Accessor macro has side-effects, use field-name here. */\n-  CHECK_NO_VAR (DECL_ASSEMBLER_NAME_RAW (t));\n-  return false;\n-}\n-\n-/* Check presence of pointers to decls in fields of a decl_non_common T.  */\n-\n-static inline bool\n-mentions_vars_p_decl_non_common (tree t)\n-{\n-  if (mentions_vars_p_decl_with_vis (t))\n-    return true;\n-  CHECK_NO_VAR (DECL_RESULT_FLD (t));\n-  return false;\n-}\n-\n-/* Check presence of pointers to decls in fields of a decl_non_common T.  */\n-\n-static bool\n-mentions_vars_p_function (tree t)\n-{\n-  if (mentions_vars_p_decl_non_common (t))\n-    return true;\n-  CHECK_NO_VAR (DECL_ARGUMENTS (t));\n-  CHECK_NO_VAR (DECL_VINDEX (t));\n-  CHECK_VAR (DECL_FUNCTION_PERSONALITY (t));\n-  return false;\n-}\n-\n-/* Check presence of pointers to decls in fields of a field_decl T.  */\n-\n-static bool\n-mentions_vars_p_field_decl (tree t)\n-{\n-  if (mentions_vars_p_decl_common (t))\n-    return true;\n-  CHECK_VAR (DECL_FIELD_OFFSET (t));\n-  CHECK_NO_VAR (DECL_BIT_FIELD_TYPE (t));\n-  CHECK_NO_VAR (DECL_QUALIFIER (t));\n-  CHECK_NO_VAR (DECL_FIELD_BIT_OFFSET (t));\n-  CHECK_NO_VAR (DECL_FCONTEXT (t));\n-  return false;\n-}\n-\n-/* Check presence of pointers to decls in fields of a type T.  */\n-\n-static bool\n-mentions_vars_p_type (tree t)\n-{\n-  if (mentions_vars_p_common (t))\n-    return true;\n-  CHECK_NO_VAR (TYPE_CACHED_VALUES (t));\n-  CHECK_VAR (TYPE_SIZE (t));\n-  CHECK_VAR (TYPE_SIZE_UNIT (t));\n-  CHECK_NO_VAR (TYPE_ATTRIBUTES (t));\n-  CHECK_NO_VAR (TYPE_NAME (t));\n-\n-  CHECK_VAR (TYPE_MIN_VALUE_RAW (t));\n-  CHECK_VAR (TYPE_MAX_VALUE_RAW (t));\n-\n-  /* Accessor is for derived node types only. */\n-  CHECK_NO_VAR (TYPE_LANG_SLOT_1 (t));\n-\n-  CHECK_VAR (TYPE_CONTEXT (t));\n-  CHECK_NO_VAR (TYPE_CANONICAL (t));\n-  CHECK_NO_VAR (TYPE_MAIN_VARIANT (t));\n-  CHECK_NO_VAR (TYPE_NEXT_VARIANT (t));\n-  return false;\n-}\n-\n-/* Check presence of pointers to decls in fields of a BINFO T.  */\n-\n-static bool\n-mentions_vars_p_binfo (tree t)\n-{\n-  unsigned HOST_WIDE_INT i, n;\n-\n-  if (mentions_vars_p_common (t))\n-    return true;\n-  CHECK_VAR (BINFO_VTABLE (t));\n-  CHECK_NO_VAR (BINFO_OFFSET (t));\n-  CHECK_NO_VAR (BINFO_VIRTUALS (t));\n-  CHECK_NO_VAR (BINFO_VPTR_FIELD (t));\n-  n = vec_safe_length (BINFO_BASE_ACCESSES (t));\n-  for (i = 0; i < n; i++)\n-    CHECK_NO_VAR (BINFO_BASE_ACCESS (t, i));\n-  /* Do not walk BINFO_INHERITANCE_CHAIN, BINFO_SUBVTT_INDEX\n-     and BINFO_VPTR_INDEX; these are used by C++ FE only.  */\n-  n = BINFO_N_BASE_BINFOS (t);\n-  for (i = 0; i < n; i++)\n-    CHECK_NO_VAR (BINFO_BASE_BINFO (t, i));\n-  return false;\n-}\n-\n-/* Check presence of pointers to decls in fields of a CONSTRUCTOR T.  */\n-\n-static bool\n-mentions_vars_p_constructor (tree t)\n-{\n-  unsigned HOST_WIDE_INT idx;\n-  constructor_elt *ce;\n-\n-  if (mentions_vars_p_typed (t))\n-    return true;\n-\n-  for (idx = 0; vec_safe_iterate (CONSTRUCTOR_ELTS (t), idx, &ce); idx++)\n-    {\n-      CHECK_NO_VAR (ce->index);\n-      CHECK_VAR (ce->value);\n-    }\n-  return false;\n-}\n-\n-/* Check presence of pointers to decls in fields of an expression tree T.  */\n-\n-static bool\n-mentions_vars_p_expr (tree t)\n-{\n-  int i;\n-  if (mentions_vars_p_typed (t))\n-    return true;\n-  for (i = TREE_OPERAND_LENGTH (t) - 1; i >= 0; --i)\n-    CHECK_VAR (TREE_OPERAND (t, i));\n-  return false;\n-}\n-\n-/* Check presence of pointers to decls in fields of an OMP_CLAUSE T.  */\n-\n-static bool\n-mentions_vars_p_omp_clause (tree t)\n-{\n-  int i;\n-  if (mentions_vars_p_common (t))\n-    return true;\n-  for (i = omp_clause_num_ops[OMP_CLAUSE_CODE (t)] - 1; i >= 0; --i)\n-    CHECK_VAR (OMP_CLAUSE_OPERAND (t, i));\n-  return false;\n-}\n-\n-/* Check presence of pointers to decls that needs later fixup in T.  */\n-\n-static bool\n-mentions_vars_p (tree t)\n+materialize_cgraph (void)\n {\n-  switch (TREE_CODE (t))\n-    {\n-    case IDENTIFIER_NODE:\n-      break;\n-\n-    case TREE_LIST:\n-      CHECK_VAR (TREE_VALUE (t));\n-      CHECK_VAR (TREE_PURPOSE (t));\n-      CHECK_NO_VAR (TREE_CHAIN (t));\n-      break;\n-\n-    case FIELD_DECL:\n-      return mentions_vars_p_field_decl (t);\n-\n-    case LABEL_DECL:\n-    case CONST_DECL:\n-    case PARM_DECL:\n-    case RESULT_DECL:\n-    case IMPORTED_DECL:\n-    case NAMESPACE_DECL:\n-    case NAMELIST_DECL:\n-      return mentions_vars_p_decl_common (t);\n-\n-    case VAR_DECL:\n-      return mentions_vars_p_decl_with_vis (t);\n-\n-    case TYPE_DECL:\n-      return mentions_vars_p_decl_non_common (t);\n-\n-    case FUNCTION_DECL:\n-      return mentions_vars_p_function (t);\n-\n-    case TREE_BINFO:\n-      return mentions_vars_p_binfo (t);\n-\n-    case PLACEHOLDER_EXPR:\n-      return mentions_vars_p_common (t);\n-\n-    case BLOCK:\n-    case TRANSLATION_UNIT_DECL:\n-    case OPTIMIZATION_NODE:\n-    case TARGET_OPTION_NODE:\n-      break;\n-\n-    case CONSTRUCTOR:\n-      return mentions_vars_p_constructor (t);\n-\n-    case OMP_CLAUSE:\n-      return mentions_vars_p_omp_clause (t);\n-\n-    default:\n-      if (TYPE_P (t))\n-\t{\n-\t  if (mentions_vars_p_type (t))\n-\t    return true;\n-\t}\n-      else if (EXPR_P (t))\n-\t{\n-\t  if (mentions_vars_p_expr (t))\n-\t    return true;\n-\t}\n-      else if (CONSTANT_CLASS_P (t))\n-\tCHECK_NO_VAR (TREE_TYPE (t));\n-      else\n-\tgcc_unreachable ();\n-    }\n-  return false;\n-}\n-\n-\n-/* Return the resolution for the decl with index INDEX from DATA_IN. */\n-\n-static enum ld_plugin_symbol_resolution\n-get_resolution (struct data_in *data_in, unsigned index)\n-{\n-  if (data_in->globals_resolution.exists ())\n-    {\n-      ld_plugin_symbol_resolution_t ret;\n-      /* We can have references to not emitted functions in\n-\t DECL_FUNCTION_PERSONALITY at least.  So we can and have\n-\t to indeed return LDPR_UNKNOWN in some cases.   */\n-      if (data_in->globals_resolution.length () <= index)\n-\treturn LDPR_UNKNOWN;\n-      ret = data_in->globals_resolution[index];\n-      return ret;\n-    }\n-  else\n-    /* Delay resolution finding until decl merging.  */\n-    return LDPR_UNKNOWN;\n-}\n-\n-/* We need to record resolutions until symbol table is read.  */\n-static void\n-register_resolution (struct lto_file_decl_data *file_data, tree decl,\n-\t\t     enum ld_plugin_symbol_resolution resolution)\n-{\n-  bool existed;\n-  if (resolution == LDPR_UNKNOWN)\n-    return;\n-  if (!file_data->resolution_map)\n-    file_data->resolution_map\n-      = new hash_map<tree, ld_plugin_symbol_resolution>;\n-  ld_plugin_symbol_resolution_t &res\n-     = file_data->resolution_map->get_or_insert (decl, &existed);\n-  if (!existed\n-      || resolution == LDPR_PREVAILING_DEF_IRONLY\n-      || resolution == LDPR_PREVAILING_DEF\n-      || resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-    res = resolution;\n-}\n-\n-/* Register DECL with the global symbol table and change its\n-   name if necessary to avoid name clashes for static globals across\n-   different files.  */\n-\n-static void\n-lto_register_var_decl_in_symtab (struct data_in *data_in, tree decl,\n-\t\t\t\t unsigned ix)\n-{\n-  tree context;\n-\n-  /* Variable has file scope, not local.  */\n-  if (!TREE_PUBLIC (decl)\n-      && !((context = decl_function_context (decl))\n-\t   && auto_var_in_fn_p (decl, context)))\n-    rest_of_decl_compilation (decl, 1, 0);\n-\n-  /* If this variable has already been declared, queue the\n-     declaration for merging.  */\n-  if (TREE_PUBLIC (decl))\n-    register_resolution (data_in->file_data,\n-\t\t\t decl, get_resolution (data_in, ix));\n-}\n-\n-\n-/* Register DECL with the global symbol table and change its\n-   name if necessary to avoid name clashes for static globals across\n-   different files.  DATA_IN contains descriptors and tables for the\n-   file being read.  */\n-\n-static void\n-lto_register_function_decl_in_symtab (struct data_in *data_in, tree decl,\n-\t\t\t\t      unsigned ix)\n-{\n-  /* If this variable has already been declared, queue the\n-     declaration for merging.  */\n-  if (TREE_PUBLIC (decl) && !DECL_ABSTRACT_P (decl))\n-    register_resolution (data_in->file_data,\n-\t\t\t decl, get_resolution (data_in, ix));\n-}\n-\n-/* Check if T is a decl and needs register its resolution info.  */\n-\n-static void\n-lto_maybe_register_decl (struct data_in *data_in, tree t, unsigned ix)\n-{\n-  if (TREE_CODE (t) == VAR_DECL)\n-    lto_register_var_decl_in_symtab (data_in, t, ix);\n-  else if (TREE_CODE (t) == FUNCTION_DECL\n-\t   && !fndecl_built_in_p (t))\n-    lto_register_function_decl_in_symtab (data_in, t, ix);\n-}\n-\n-\n-/* For the type T re-materialize it in the type variant list and\n-   the pointer/reference-to chains.  */\n-\n-static void\n-lto_fixup_prevailing_type (tree t)\n-{\n-  /* The following re-creates proper variant lists while fixing up\n-     the variant leaders.  We do not stream TYPE_NEXT_VARIANT so the\n-     variant list state before fixup is broken.  */\n-\n-  /* If we are not our own variant leader link us into our new leaders\n-     variant list.  */\n-  if (TYPE_MAIN_VARIANT (t) != t)\n-    {\n-      tree mv = TYPE_MAIN_VARIANT (t);\n-      TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (mv);\n-      TYPE_NEXT_VARIANT (mv) = t;\n-    }\n-\n-  /* The following reconstructs the pointer chains\n-     of the new pointed-to type if we are a main variant.  We do\n-     not stream those so they are broken before fixup.  */\n-  if (TREE_CODE (t) == POINTER_TYPE\n-      && TYPE_MAIN_VARIANT (t) == t)\n-    {\n-      TYPE_NEXT_PTR_TO (t) = TYPE_POINTER_TO (TREE_TYPE (t));\n-      TYPE_POINTER_TO (TREE_TYPE (t)) = t;\n-    }\n-  else if (TREE_CODE (t) == REFERENCE_TYPE\n-\t   && TYPE_MAIN_VARIANT (t) == t)\n-    {\n-      TYPE_NEXT_REF_TO (t) = TYPE_REFERENCE_TO (TREE_TYPE (t));\n-      TYPE_REFERENCE_TO (TREE_TYPE (t)) = t;\n-    }\n-}\n-\n-\n-/* We keep prevailing tree SCCs in a hashtable with manual collision\n-   handling (in case all hashes compare the same) and keep the colliding\n-   entries in the tree_scc->next chain.  */\n-\n-struct tree_scc\n-{\n-  tree_scc *next;\n-  /* Hash of the whole SCC.  */\n-  hashval_t hash;\n-  /* Number of trees in the SCC.  */\n-  unsigned len;\n-  /* Number of possible entries into the SCC (tree nodes [0..entry_len-1]\n-     which share the same individual tree hash).  */\n-  unsigned entry_len;\n-  /* The members of the SCC.\n-     We only need to remember the first entry node candidate for prevailing\n-     SCCs (but of course have access to all entries for SCCs we are\n-     processing).\n-     ???  For prevailing SCCs we really only need hash and the first\n-     entry candidate, but that's too awkward to implement.  */\n-  tree entries[1];\n-};\n-\n-struct tree_scc_hasher : nofree_ptr_hash <tree_scc>\n-{\n-  static inline hashval_t hash (const tree_scc *);\n-  static inline bool equal (const tree_scc *, const tree_scc *);\n-};\n-\n-hashval_t\n-tree_scc_hasher::hash (const tree_scc *scc)\n-{\n-  return scc->hash;\n-}\n-\n-bool\n-tree_scc_hasher::equal (const tree_scc *scc1, const tree_scc *scc2)\n-{\n-  if (scc1->hash != scc2->hash\n-      || scc1->len != scc2->len\n-      || scc1->entry_len != scc2->entry_len)\n-    return false;\n-  return true;\n-}\n-\n-static hash_table<tree_scc_hasher> *tree_scc_hash;\n-static struct obstack tree_scc_hash_obstack;\n-\n-static unsigned long num_merged_types;\n-static unsigned long num_prevailing_types;\n-static unsigned long num_type_scc_trees;\n-static unsigned long total_scc_size;\n-static unsigned long num_sccs_read;\n-static unsigned long total_scc_size_merged;\n-static unsigned long num_sccs_merged;\n-static unsigned long num_scc_compares;\n-static unsigned long num_scc_compare_collisions;\n-\n-\n-/* Compare the two entries T1 and T2 of two SCCs that are possibly equal,\n-   recursing through in-SCC tree edges.  Returns true if the SCCs entered\n-   through T1 and T2 are equal and fills in *MAP with the pairs of\n-   SCC entries we visited, starting with (*MAP)[0] = T1 and (*MAP)[1] = T2.  */\n-\n-static bool\n-compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n-{\n-  enum tree_code code;\n-\n-  /* Mark already visited nodes.  */\n-  TREE_ASM_WRITTEN (t2) = 1;\n-\n-  /* Push the pair onto map.  */\n-  (*map)[0] = t1;\n-  (*map)[1] = t2;\n-  *map = *map + 2;\n-\n-  /* Compare value-fields.  */\n-#define compare_values(X) \\\n-  do { \\\n-    if (X(t1) != X(t2)) \\\n-      return false; \\\n-  } while (0)\n-\n-  compare_values (TREE_CODE);\n-  code = TREE_CODE (t1);\n-\n-  if (!TYPE_P (t1))\n-    {\n-      compare_values (TREE_SIDE_EFFECTS);\n-      compare_values (TREE_CONSTANT);\n-      compare_values (TREE_READONLY);\n-      compare_values (TREE_PUBLIC);\n-    }\n-  compare_values (TREE_ADDRESSABLE);\n-  compare_values (TREE_THIS_VOLATILE);\n-  if (DECL_P (t1))\n-    compare_values (DECL_UNSIGNED);\n-  else if (TYPE_P (t1))\n-    compare_values (TYPE_UNSIGNED);\n-  if (TYPE_P (t1))\n-    compare_values (TYPE_ARTIFICIAL);\n-  else\n-    compare_values (TREE_NO_WARNING);\n-  compare_values (TREE_NOTHROW);\n-  compare_values (TREE_STATIC);\n-  if (code != TREE_BINFO)\n-    compare_values (TREE_PRIVATE);\n-  compare_values (TREE_PROTECTED);\n-  compare_values (TREE_DEPRECATED);\n-  if (TYPE_P (t1))\n-    {\n-      if (AGGREGATE_TYPE_P (t1))\n-\tcompare_values (TYPE_REVERSE_STORAGE_ORDER);\n-      else\n-\tcompare_values (TYPE_SATURATING);\n-      compare_values (TYPE_ADDR_SPACE);\n-    }\n-  else if (code == SSA_NAME)\n-    compare_values (SSA_NAME_IS_DEFAULT_DEF);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_INT_CST))\n-    {\n-      if (wi::to_wide (t1) != wi::to_wide (t2))\n-\treturn false;\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_REAL_CST))\n-    {\n-      /* ???  No suitable compare routine available.  */\n-      REAL_VALUE_TYPE r1 = TREE_REAL_CST (t1);\n-      REAL_VALUE_TYPE r2 = TREE_REAL_CST (t2);\n-      if (r1.cl != r2.cl\n-\t  || r1.decimal != r2.decimal\n-\t  || r1.sign != r2.sign\n-\t  || r1.signalling != r2.signalling\n-\t  || r1.canonical != r2.canonical\n-\t  || r1.uexp != r2.uexp)\n-\treturn false;\n-      for (unsigned i = 0; i < SIGSZ; ++i)\n-\tif (r1.sig[i] != r2.sig[i])\n-\t  return false;\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_FIXED_CST))\n-    if (!fixed_compare (EQ_EXPR,\n-\t\t\tTREE_FIXED_CST_PTR (t1), TREE_FIXED_CST_PTR (t2)))\n-      return false;\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n-    {\n-      compare_values (VECTOR_CST_LOG2_NPATTERNS);\n-      compare_values (VECTOR_CST_NELTS_PER_PATTERN);\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n-    {\n-      compare_values (DECL_MODE);\n-      compare_values (DECL_NONLOCAL);\n-      compare_values (DECL_VIRTUAL_P);\n-      compare_values (DECL_IGNORED_P);\n-      compare_values (DECL_ABSTRACT_P);\n-      compare_values (DECL_ARTIFICIAL);\n-      compare_values (DECL_USER_ALIGN);\n-      compare_values (DECL_PRESERVE_P);\n-      compare_values (DECL_EXTERNAL);\n-      compare_values (DECL_GIMPLE_REG_P);\n-      compare_values (DECL_ALIGN);\n-      if (code == LABEL_DECL)\n-\t{\n-\t  compare_values (EH_LANDING_PAD_NR);\n-\t  compare_values (LABEL_DECL_UID);\n-\t}\n-      else if (code == FIELD_DECL)\n-\t{\n-\t  compare_values (DECL_PACKED);\n-\t  compare_values (DECL_NONADDRESSABLE_P);\n-\t  compare_values (DECL_PADDING_P);\n-\t  compare_values (DECL_OFFSET_ALIGN);\n-\t}\n-      else if (code == VAR_DECL)\n-\t{\n-\t  compare_values (DECL_HAS_DEBUG_EXPR_P);\n-\t  compare_values (DECL_NONLOCAL_FRAME);\n-\t}\n-      if (code == RESULT_DECL\n-\t  || code == PARM_DECL\n-\t  || code == VAR_DECL)\n-\t{\n-\t  compare_values (DECL_BY_REFERENCE);\n-\t  if (code == VAR_DECL\n-\t      || code == PARM_DECL)\n-\t    compare_values (DECL_HAS_VALUE_EXPR_P);\n-\t}\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WRTL))\n-    compare_values (DECL_REGISTER);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n-    {\n-      compare_values (DECL_COMMON);\n-      compare_values (DECL_DLLIMPORT_P);\n-      compare_values (DECL_WEAK);\n-      compare_values (DECL_SEEN_IN_BIND_EXPR_P);\n-      compare_values (DECL_COMDAT);\n-      compare_values (DECL_VISIBILITY);\n-      compare_values (DECL_VISIBILITY_SPECIFIED);\n-      if (code == VAR_DECL)\n-\t{\n-\t  compare_values (DECL_HARD_REGISTER);\n-          /* DECL_IN_TEXT_SECTION is set during final asm output only.  */\n-\t  compare_values (DECL_IN_CONSTANT_POOL);\n-\t}\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n-    {\n-      compare_values (DECL_BUILT_IN_CLASS);\n-      compare_values (DECL_STATIC_CONSTRUCTOR);\n-      compare_values (DECL_STATIC_DESTRUCTOR);\n-      compare_values (DECL_UNINLINABLE);\n-      compare_values (DECL_POSSIBLY_INLINED);\n-      compare_values (DECL_IS_NOVOPS);\n-      compare_values (DECL_IS_RETURNS_TWICE);\n-      compare_values (DECL_IS_MALLOC);\n-      compare_values (DECL_IS_OPERATOR_NEW);\n-      compare_values (DECL_DECLARED_INLINE_P);\n-      compare_values (DECL_STATIC_CHAIN);\n-      compare_values (DECL_NO_INLINE_WARNING_P);\n-      compare_values (DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT);\n-      compare_values (DECL_NO_LIMIT_STACK);\n-      compare_values (DECL_DISREGARD_INLINE_LIMITS);\n-      compare_values (DECL_PURE_P);\n-      compare_values (DECL_LOOPING_CONST_OR_PURE_P);\n-      compare_values (DECL_FINAL_P);\n-      compare_values (DECL_CXX_CONSTRUCTOR_P);\n-      compare_values (DECL_CXX_DESTRUCTOR_P);\n-      if (DECL_BUILT_IN_CLASS (t1) != NOT_BUILT_IN)\n-\tcompare_values (DECL_FUNCTION_CODE);\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n-    {\n-      compare_values (TYPE_MODE);\n-      compare_values (TYPE_STRING_FLAG);\n-      compare_values (TYPE_NEEDS_CONSTRUCTING);\n-      if (RECORD_OR_UNION_TYPE_P (t1))\n-\t{\n-\t  compare_values (TYPE_TRANSPARENT_AGGR);\n-\t  compare_values (TYPE_FINAL_P);\n-\t}\n-      else if (code == ARRAY_TYPE)\n-\tcompare_values (TYPE_NONALIASED_COMPONENT);\n-      if (AGGREGATE_TYPE_P (t1))\n-\tcompare_values (TYPE_TYPELESS_STORAGE);\n-      compare_values (TYPE_EMPTY_P);\n-      compare_values (TYPE_PACKED);\n-      compare_values (TYPE_RESTRICT);\n-      compare_values (TYPE_USER_ALIGN);\n-      compare_values (TYPE_READONLY);\n-      compare_values (TYPE_PRECISION);\n-      compare_values (TYPE_ALIGN);\n-      /* Do not compare TYPE_ALIAS_SET.  Doing so introduce ordering issues\n-         with calls to get_alias_set which may initialize it for streamed\n- \t in types.  */\n-    }\n-\n-  /* We don't want to compare locations, so there is nothing do compare\n-     for TS_EXP.  */\n-\n-  /* BLOCKs are function local and we don't merge anything there, so\n-     simply refuse to merge.  */\n-  if (CODE_CONTAINS_STRUCT (code, TS_BLOCK))\n-    return false;\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n-    if (strcmp (TRANSLATION_UNIT_LANGUAGE (t1),\n-\t\tTRANSLATION_UNIT_LANGUAGE (t2)) != 0)\n-      return false;\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TARGET_OPTION))\n-    if (!cl_target_option_eq (TREE_TARGET_OPTION (t1), TREE_TARGET_OPTION (t2)))\n-      return false;\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_OPTIMIZATION))\n-    if (!cl_optimization_option_eq (TREE_OPTIMIZATION (t1),\n-\t\t\t\t    TREE_OPTIMIZATION (t2)))\n-      return false;\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n-    if (vec_safe_length (BINFO_BASE_ACCESSES (t1))\n-\t!= vec_safe_length (BINFO_BASE_ACCESSES (t2)))\n-      return false;\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n-    compare_values (CONSTRUCTOR_NELTS);\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_IDENTIFIER))\n-    if (IDENTIFIER_LENGTH (t1) != IDENTIFIER_LENGTH (t2)\n-\t|| memcmp (IDENTIFIER_POINTER (t1), IDENTIFIER_POINTER (t2),\n-\t\t   IDENTIFIER_LENGTH (t1)) != 0)\n-      return false;\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_STRING))\n-    if (TREE_STRING_LENGTH (t1) != TREE_STRING_LENGTH (t2)\n-\t|| memcmp (TREE_STRING_POINTER (t1), TREE_STRING_POINTER (t2),\n-\t\t   TREE_STRING_LENGTH (t1)) != 0)\n-      return false;\n-\n-  if (code == OMP_CLAUSE)\n-    {\n-      compare_values (OMP_CLAUSE_CODE);\n-      switch (OMP_CLAUSE_CODE (t1))\n-\t{\n-\tcase OMP_CLAUSE_DEFAULT:\n-\t  compare_values (OMP_CLAUSE_DEFAULT_KIND);\n-\t  break;\n-\tcase OMP_CLAUSE_SCHEDULE:\n-\t  compare_values (OMP_CLAUSE_SCHEDULE_KIND);\n-\t  break;\n-\tcase OMP_CLAUSE_DEPEND:\n-\t  compare_values (OMP_CLAUSE_DEPEND_KIND);\n-\t  break;\n-\tcase OMP_CLAUSE_MAP:\n-\t  compare_values (OMP_CLAUSE_MAP_KIND);\n-\t  break;\n-\tcase OMP_CLAUSE_PROC_BIND:\n-\t  compare_values (OMP_CLAUSE_PROC_BIND_KIND);\n-\t  break;\n-\tcase OMP_CLAUSE_REDUCTION:\n-\t  compare_values (OMP_CLAUSE_REDUCTION_CODE);\n-\t  compare_values (OMP_CLAUSE_REDUCTION_GIMPLE_INIT);\n-\t  compare_values (OMP_CLAUSE_REDUCTION_GIMPLE_MERGE);\n-\t  break;\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-\n-#undef compare_values\n-\n-\n-  /* Compare pointer fields.  */\n-\n-  /* Recurse.  Search & Replaced from DFS_write_tree_body.\n-     Folding the early checks into the compare_tree_edges recursion\n-     macro makes debugging way quicker as you are able to break on\n-     compare_tree_sccs_1 and simply finish until a call returns false\n-     to spot the SCC members with the difference.  */\n-#define compare_tree_edges(E1, E2) \\\n-  do { \\\n-    tree t1_ = (E1), t2_ = (E2); \\\n-    if (t1_ != t2_ \\\n-\t&& (!t1_ || !t2_ \\\n-\t    || !TREE_VISITED (t2_) \\\n-\t    || (!TREE_ASM_WRITTEN (t2_) \\\n-\t\t&& !compare_tree_sccs_1 (t1_, t2_, map)))) \\\n-      return false; \\\n-    /* Only non-NULL trees outside of the SCC may compare equal.  */ \\\n-    gcc_checking_assert (t1_ != t2_ || (!t2_ || !TREE_VISITED (t2_))); \\\n-  } while (0)\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPED))\n-    {\n-      if (code != IDENTIFIER_NODE)\n-\tcompare_tree_edges (TREE_TYPE (t1), TREE_TYPE (t2));\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_VECTOR))\n-    {\n-      /* Note that the number of elements for EXPR has already been emitted\n-\t in EXPR's header (see streamer_write_tree_header).  */\n-      unsigned int count = vector_cst_encoded_nelts (t1);\n-      for (unsigned int i = 0; i < count; ++i)\n-\tcompare_tree_edges (VECTOR_CST_ENCODED_ELT (t1, i),\n-\t\t\t    VECTOR_CST_ENCODED_ELT (t2, i));\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_COMPLEX))\n-    {\n-      compare_tree_edges (TREE_REALPART (t1), TREE_REALPART (t2));\n-      compare_tree_edges (TREE_IMAGPART (t1), TREE_IMAGPART (t2));\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_MINIMAL))\n-    {\n-      compare_tree_edges (DECL_NAME (t1), DECL_NAME (t2));\n-      /* ???  Global decls from different TUs have non-matching\n-\t TRANSLATION_UNIT_DECLs.  Only consider a small set of\n-\t decls equivalent, we should not end up merging others.  */\n-      if ((code == TYPE_DECL\n-\t   || code == NAMESPACE_DECL\n-\t   || code == IMPORTED_DECL\n-\t   || code == CONST_DECL\n-\t   || (VAR_OR_FUNCTION_DECL_P (t1)\n-\t       && (TREE_PUBLIC (t1) || DECL_EXTERNAL (t1))))\n-\t  && DECL_FILE_SCOPE_P (t1) && DECL_FILE_SCOPE_P (t2))\n-\t;\n-      else\n-\tcompare_tree_edges (DECL_CONTEXT (t1), DECL_CONTEXT (t2));\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n-    {\n-      compare_tree_edges (DECL_SIZE (t1), DECL_SIZE (t2));\n-      compare_tree_edges (DECL_SIZE_UNIT (t1), DECL_SIZE_UNIT (t2));\n-      compare_tree_edges (DECL_ATTRIBUTES (t1), DECL_ATTRIBUTES (t2));\n-      compare_tree_edges (DECL_ABSTRACT_ORIGIN (t1), DECL_ABSTRACT_ORIGIN (t2));\n-      if ((code == VAR_DECL\n-\t   || code == PARM_DECL)\n-\t  && DECL_HAS_VALUE_EXPR_P (t1))\n-\tcompare_tree_edges (DECL_VALUE_EXPR (t1), DECL_VALUE_EXPR (t2));\n-      if (code == VAR_DECL\n-\t  && DECL_HAS_DEBUG_EXPR_P (t1))\n-\tcompare_tree_edges (DECL_DEBUG_EXPR (t1), DECL_DEBUG_EXPR (t2));\n-      /* LTO specific edges.  */\n-      if (code != FUNCTION_DECL\n-\t  && code != TRANSLATION_UNIT_DECL)\n-\tcompare_tree_edges (DECL_INITIAL (t1), DECL_INITIAL (t2));\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n-    {\n-      if (code == FUNCTION_DECL)\n-\t{\n-\t  tree a1, a2;\n-\t  for (a1 = DECL_ARGUMENTS (t1), a2 = DECL_ARGUMENTS (t2);\n-\t       a1 || a2;\n-\t       a1 = TREE_CHAIN (a1), a2 = TREE_CHAIN (a2))\n-\t    compare_tree_edges (a1, a2);\n-\t  compare_tree_edges (DECL_RESULT (t1), DECL_RESULT (t2));\n-\t}\n-      else if (code == TYPE_DECL)\n-\tcompare_tree_edges (DECL_ORIGINAL_TYPE (t1), DECL_ORIGINAL_TYPE (t2));\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n-    {\n-      /* Make sure we don't inadvertently set the assembler name.  */\n-      if (DECL_ASSEMBLER_NAME_SET_P (t1))\n-\tcompare_tree_edges (DECL_ASSEMBLER_NAME (t1),\n-\t\t\t    DECL_ASSEMBLER_NAME (t2));\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n-    {\n-      compare_tree_edges (DECL_FIELD_OFFSET (t1), DECL_FIELD_OFFSET (t2));\n-      compare_tree_edges (DECL_BIT_FIELD_TYPE (t1), DECL_BIT_FIELD_TYPE (t2));\n-      compare_tree_edges (DECL_BIT_FIELD_REPRESENTATIVE (t1),\n-\t\t\t  DECL_BIT_FIELD_REPRESENTATIVE (t2));\n-      compare_tree_edges (DECL_FIELD_BIT_OFFSET (t1),\n-\t\t\t  DECL_FIELD_BIT_OFFSET (t2));\n-      compare_tree_edges (DECL_FCONTEXT (t1), DECL_FCONTEXT (t2));\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n-    {\n-      compare_tree_edges (DECL_FUNCTION_PERSONALITY (t1),\n-\t\t\t  DECL_FUNCTION_PERSONALITY (t2));\n-      compare_tree_edges (DECL_VINDEX (t1), DECL_VINDEX (t2));\n-      compare_tree_edges (DECL_FUNCTION_SPECIFIC_TARGET (t1),\n-\t\t\t  DECL_FUNCTION_SPECIFIC_TARGET (t2));\n-      compare_tree_edges (DECL_FUNCTION_SPECIFIC_OPTIMIZATION (t1),\n-\t\t\t  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (t2));\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_COMMON))\n-    {\n-      compare_tree_edges (TYPE_SIZE (t1), TYPE_SIZE (t2));\n-      compare_tree_edges (TYPE_SIZE_UNIT (t1), TYPE_SIZE_UNIT (t2));\n-      compare_tree_edges (TYPE_ATTRIBUTES (t1), TYPE_ATTRIBUTES (t2));\n-      compare_tree_edges (TYPE_NAME (t1), TYPE_NAME (t2));\n-      /* Do not compare TYPE_POINTER_TO or TYPE_REFERENCE_TO.  They will be\n-\t reconstructed during fixup.  */\n-      /* Do not compare TYPE_NEXT_VARIANT, we reconstruct the variant lists\n-\t during fixup.  */\n-      compare_tree_edges (TYPE_MAIN_VARIANT (t1), TYPE_MAIN_VARIANT (t2));\n-      /* ???  Global types from different TUs have non-matching\n-\t TRANSLATION_UNIT_DECLs.  Still merge them if they are otherwise\n-\t equal.  */\n-      if (TYPE_FILE_SCOPE_P (t1) && TYPE_FILE_SCOPE_P (t2))\n-\t;\n-      else\n-\tcompare_tree_edges (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2));\n-      /* TYPE_CANONICAL is re-computed during type merging, so do not\n-\t compare it here.  */\n-      compare_tree_edges (TYPE_STUB_DECL (t1), TYPE_STUB_DECL (t2));\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_TYPE_NON_COMMON))\n-    {\n-      if (code == ENUMERAL_TYPE)\n-\tcompare_tree_edges (TYPE_VALUES (t1), TYPE_VALUES (t2));\n-      else if (code == ARRAY_TYPE)\n-\tcompare_tree_edges (TYPE_DOMAIN (t1), TYPE_DOMAIN (t2));\n-      else if (RECORD_OR_UNION_TYPE_P (t1))\n-\t{\n-\t  tree f1, f2;\n-\t  for (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n-\t       f1 || f2;\n-\t       f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n-\t    compare_tree_edges (f1, f2);\n-\t}\n-      else if (code == FUNCTION_TYPE\n-\t       || code == METHOD_TYPE)\n-\tcompare_tree_edges (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2));\n-\n-      if (!POINTER_TYPE_P (t1))\n-\tcompare_tree_edges (TYPE_MIN_VALUE_RAW (t1), TYPE_MIN_VALUE_RAW (t2));\n-      compare_tree_edges (TYPE_MAX_VALUE_RAW (t1), TYPE_MAX_VALUE_RAW (t2));\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_LIST))\n-    {\n-      compare_tree_edges (TREE_PURPOSE (t1), TREE_PURPOSE (t2));\n-      compare_tree_edges (TREE_VALUE (t1), TREE_VALUE (t2));\n-      compare_tree_edges (TREE_CHAIN (t1), TREE_CHAIN (t2));\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_VEC))\n-    for (int i = 0; i < TREE_VEC_LENGTH (t1); i++)\n-      compare_tree_edges (TREE_VEC_ELT (t1, i), TREE_VEC_ELT (t2, i));\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n-    {\n-      for (int i = 0; i < TREE_OPERAND_LENGTH (t1); i++)\n-\tcompare_tree_edges (TREE_OPERAND (t1, i),\n-\t\t\t    TREE_OPERAND (t2, i));\n-\n-      /* BLOCKs are function local and we don't merge anything there.  */\n-      if (TREE_BLOCK (t1) || TREE_BLOCK (t2))\n-\treturn false;\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n-    {\n-      unsigned i;\n-      tree t;\n-      /* Lengths have already been compared above.  */\n-      FOR_EACH_VEC_ELT (*BINFO_BASE_BINFOS (t1), i, t)\n-\tcompare_tree_edges (t, BINFO_BASE_BINFO (t2, i));\n-      FOR_EACH_VEC_SAFE_ELT (BINFO_BASE_ACCESSES (t1), i, t)\n-\tcompare_tree_edges (t, BINFO_BASE_ACCESS (t2, i));\n-      compare_tree_edges (BINFO_OFFSET (t1), BINFO_OFFSET (t2));\n-      compare_tree_edges (BINFO_VTABLE (t1), BINFO_VTABLE (t2));\n-      compare_tree_edges (BINFO_VPTR_FIELD (t1), BINFO_VPTR_FIELD (t2));\n-      /* Do not walk BINFO_INHERITANCE_CHAIN, BINFO_SUBVTT_INDEX\n-\t and BINFO_VPTR_INDEX; these are used by C++ FE only.  */\n-    }\n-\n-  if (CODE_CONTAINS_STRUCT (code, TS_CONSTRUCTOR))\n-    {\n-      unsigned i;\n-      tree index, value;\n-      /* Lengths have already been compared above.  */\n-      FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (t1), i, index, value)\n-\t{\n-\t  compare_tree_edges (index, CONSTRUCTOR_ELT (t2, i)->index);\n-\t  compare_tree_edges (value, CONSTRUCTOR_ELT (t2, i)->value);\n-\t}\n-    }\n-\n-  if (code == OMP_CLAUSE)\n-    {\n-      int i;\n-\n-      for (i = 0; i < omp_clause_num_ops[OMP_CLAUSE_CODE (t1)]; i++)\n-\tcompare_tree_edges (OMP_CLAUSE_OPERAND (t1, i),\n-\t\t\t    OMP_CLAUSE_OPERAND (t2, i));\n-      compare_tree_edges (OMP_CLAUSE_CHAIN (t1), OMP_CLAUSE_CHAIN (t2));\n-    }\n-\n-#undef compare_tree_edges\n-\n-  return true;\n-}\n-\n-/* Compare the tree scc SCC to the prevailing candidate PSCC, filling\n-   out MAP if they are equal.  */\n-\n-static bool\n-compare_tree_sccs (tree_scc *pscc, tree_scc *scc,\n-\t\t   tree *map)\n-{\n-  /* Assume SCC entry hashes are sorted after their cardinality.  Which\n-     means we can simply take the first n-tuple of equal hashes\n-     (which is recorded as entry_len) and do n SCC entry candidate\n-     comparisons.  */\n-  for (unsigned i = 0; i < pscc->entry_len; ++i)\n-    {\n-      tree *mapp = map;\n-      num_scc_compare_collisions++;\n-      if (compare_tree_sccs_1 (pscc->entries[0], scc->entries[i], &mapp))\n-\t{\n-\t  /* Equal - no need to reset TREE_VISITED or TREE_ASM_WRITTEN\n-\t     on the scc as all trees will be freed.  */\n-\t  return true;\n-\t}\n-      /* Reset TREE_ASM_WRITTEN on scc for the next compare or in case\n-         the SCC prevails.  */\n-      for (unsigned j = 0; j < scc->len; ++j)\n-\tTREE_ASM_WRITTEN (scc->entries[j]) = 0;\n-    }\n-\n-  return false;\n-}\n-\n-/* QSort sort function to sort a map of two pointers after the 2nd\n-   pointer.  */\n-\n-static int\n-cmp_tree (const void *p1_, const void *p2_)\n-{\n-  tree *p1 = (tree *)(const_cast<void *>(p1_));\n-  tree *p2 = (tree *)(const_cast<void *>(p2_));\n-  if (p1[1] == p2[1])\n-    return 0;\n-  return ((uintptr_t)p1[1] < (uintptr_t)p2[1]) ? -1 : 1;\n-}\n-\n-/* Try to unify the SCC with nodes FROM to FROM + LEN in CACHE and\n-   hash value SCC_HASH with an already recorded SCC.  Return true if\n-   that was successful, otherwise return false.  */\n-\n-static bool\n-unify_scc (struct data_in *data_in, unsigned from,\n-\t   unsigned len, unsigned scc_entry_len, hashval_t scc_hash)\n-{\n-  bool unified_p = false;\n-  struct streamer_tree_cache_d *cache = data_in->reader_cache;\n-  tree_scc *scc\n-    = (tree_scc *) alloca (sizeof (tree_scc) + (len - 1) * sizeof (tree));\n-  scc->next = NULL;\n-  scc->hash = scc_hash;\n-  scc->len = len;\n-  scc->entry_len = scc_entry_len;\n-  for (unsigned i = 0; i < len; ++i)\n-    {\n-      tree t = streamer_tree_cache_get_tree (cache, from + i);\n-      scc->entries[i] = t;\n-      /* Do not merge SCCs with local entities inside them.  Also do\n-\t not merge TRANSLATION_UNIT_DECLs.  */\n-      if (TREE_CODE (t) == TRANSLATION_UNIT_DECL\n-\t  || (VAR_OR_FUNCTION_DECL_P (t)\n-\t      && !(TREE_PUBLIC (t) || DECL_EXTERNAL (t)))\n-\t  || TREE_CODE (t) == LABEL_DECL)\n-\t{\n-\t  /* Avoid doing any work for these cases and do not worry to\n-\t     record the SCCs for further merging.  */\n-\t  return false;\n-\t}\n-    }\n-\n-  /* Look for the list of candidate SCCs to compare against.  */\n-  tree_scc **slot;\n-  slot = tree_scc_hash->find_slot_with_hash (scc, scc_hash, INSERT);\n-  if (*slot)\n-    {\n-      /* Try unifying against each candidate.  */\n-      num_scc_compares++;\n-\n-      /* Set TREE_VISITED on the scc so we can easily identify tree nodes\n-\t outside of the scc when following tree edges.  Make sure\n-\t that TREE_ASM_WRITTEN is unset so we can use it as 2nd bit\n-\t to track whether we visited the SCC member during the compare.\n-\t We cannot use TREE_VISITED on the pscc members as the extended\n-\t scc and pscc can overlap.  */\n-      for (unsigned i = 0; i < scc->len; ++i)\n-\t{\n-\t  TREE_VISITED (scc->entries[i]) = 1;\n-\t  gcc_checking_assert (!TREE_ASM_WRITTEN (scc->entries[i]));\n-\t}\n-\n-      tree *map = XALLOCAVEC (tree, 2 * len);\n-      for (tree_scc *pscc = *slot; pscc; pscc = pscc->next)\n-\t{\n-\t  if (!compare_tree_sccs (pscc, scc, map))\n-\t    continue;\n-\n-\t  /* Found an equal SCC.  */\n-\t  unified_p = true;\n-\t  num_scc_compare_collisions--;\n-\t  num_sccs_merged++;\n-\t  total_scc_size_merged += len;\n-\n-\t  if (flag_checking)\n-\t    for (unsigned i = 0; i < len; ++i)\n-\t      {\n-\t\ttree t = map[2*i+1];\n-\t\tenum tree_code code = TREE_CODE (t);\n-\t\t/* IDENTIFIER_NODEs should be singletons and are merged by the\n-\t\t   streamer.  The others should be singletons, too, and we\n-\t\t   should not merge them in any way.  */\n-\t\tgcc_assert (code != TRANSLATION_UNIT_DECL\n-\t\t\t    && code != IDENTIFIER_NODE);\n-\t      }\n-\n-\t  /* Fixup the streamer cache with the prevailing nodes according\n-\t     to the tree node mapping computed by compare_tree_sccs.  */\n-\t  if (len == 1)\n-\t    {\n-\t      /* If we got a debug reference queued, see if the prevailing\n-\t         tree has a debug reference and if not, register the one\n-\t\t for the tree we are about to throw away.  */\n-\t      if (dref_queue.length () == 1)\n-\t\t{\n-\t\t  dref_entry e = dref_queue.pop ();\n-\t\t  gcc_assert (e.decl\n-\t\t\t      == streamer_tree_cache_get_tree (cache, from));\n-\t\t  const char *sym;\n-\t\t  unsigned HOST_WIDE_INT off;\n-\t\t  if (!debug_hooks->die_ref_for_decl (pscc->entries[0], &sym,\n-\t\t\t\t\t\t      &off))\n-\t\t    debug_hooks->register_external_die (pscc->entries[0],\n-\t\t\t\t\t\t\te.sym, e.off);\n-\t\t}\n-\t      lto_maybe_register_decl (data_in, pscc->entries[0], from);\n-\t      streamer_tree_cache_replace_tree (cache, pscc->entries[0], from);\n-\t    }\n-\t  else\n-\t    {\n-\t      tree *map2 = XALLOCAVEC (tree, 2 * len);\n-\t      for (unsigned i = 0; i < len; ++i)\n-\t\t{\n-\t\t  map2[i*2] = (tree)(uintptr_t)(from + i);\n-\t\t  map2[i*2+1] = scc->entries[i];\n-\t\t}\n-\t      qsort (map2, len, 2 * sizeof (tree), cmp_tree);\n-\t      qsort (map, len, 2 * sizeof (tree), cmp_tree);\n-\t      for (unsigned i = 0; i < len; ++i)\n-\t\t{\n-\t\t  lto_maybe_register_decl (data_in, map[2*i],\n-\t\t\t\t\t   (uintptr_t)map2[2*i]);\n-\t\t  streamer_tree_cache_replace_tree (cache, map[2*i],\n-\t\t\t\t\t\t    (uintptr_t)map2[2*i]);\n-\t\t}\n-\t    }\n-\n-\t  /* Free the tree nodes from the read SCC.  */\n-\t  data_in->location_cache.revert_location_cache ();\n-\t  for (unsigned i = 0; i < len; ++i)\n-\t    {\n-\t      if (TYPE_P (scc->entries[i]))\n-\t\tnum_merged_types++;\n-\t      free_node (scc->entries[i]);\n-\t    }\n-\n-\t  /* Drop DIE references.\n-\t     ???  Do as in the size-one SCC case which involves sorting\n-\t     the queue.  */\n-\t  dref_queue.truncate (0);\n-\n-\t  break;\n-\t}\n-\n-      /* Reset TREE_VISITED if we didn't unify the SCC with another.  */\n-      if (!unified_p)\n-\tfor (unsigned i = 0; i < scc->len; ++i)\n-\t  TREE_VISITED (scc->entries[i]) = 0;\n-    }\n-\n-  /* If we didn't unify it to any candidate duplicate the relevant\n-     pieces to permanent storage and link it into the chain.  */\n-  if (!unified_p)\n-    {\n-      tree_scc *pscc\n-\t= XOBNEWVAR (&tree_scc_hash_obstack, tree_scc, sizeof (tree_scc));\n-      memcpy (pscc, scc, sizeof (tree_scc));\n-      pscc->next = (*slot);\n-      *slot = pscc;\n-    }\n-  return unified_p;\n-}\n-\n-\n-/* Read all the symbols from buffer DATA, using descriptors in DECL_DATA.\n-   RESOLUTIONS is the set of symbols picked by the linker (read from the\n-   resolution file when the linker plugin is being used).  */\n-\n-static void\n-lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n-\t\tvec<ld_plugin_symbol_resolution_t> resolutions)\n-{\n-  const struct lto_decl_header *header = (const struct lto_decl_header *) data;\n-  const int decl_offset = sizeof (struct lto_decl_header);\n-  const int main_offset = decl_offset + header->decl_state_size;\n-  const int string_offset = main_offset + header->main_size;\n-  struct data_in *data_in;\n-  unsigned int i;\n-  const uint32_t *data_ptr, *data_end;\n-  uint32_t num_decl_states;\n-\n-  lto_input_block ib_main ((const char *) data + main_offset,\n-\t\t\t   header->main_size, decl_data->mode_table);\n-\n-  data_in = lto_data_in_create (decl_data, (const char *) data + string_offset,\n-\t\t\t\theader->string_size, resolutions);\n-\n-  /* We do not uniquify the pre-loaded cache entries, those are middle-end\n-     internal types that should not be merged.  */\n-\n-  /* Read the global declarations and types.  */\n-  while (ib_main.p < ib_main.len)\n-    {\n-      tree t;\n-      unsigned from = data_in->reader_cache->nodes.length ();\n-      /* Read and uniquify SCCs as in the input stream.  */\n-      enum LTO_tags tag = streamer_read_record_start (&ib_main);\n-      if (tag == LTO_tree_scc)\n-\t{\n-\t  unsigned len_;\n-\t  unsigned scc_entry_len;\n-\t  hashval_t scc_hash = lto_input_scc (&ib_main, data_in, &len_,\n-\t\t\t\t\t      &scc_entry_len);\n-\t  unsigned len = data_in->reader_cache->nodes.length () - from;\n-\t  gcc_assert (len == len_);\n-\n-\t  total_scc_size += len;\n-\t  num_sccs_read++;\n-\n-\t  /* We have the special case of size-1 SCCs that are pre-merged\n-\t     by means of identifier and string sharing for example.\n-\t     ???  Maybe we should avoid streaming those as SCCs.  */\n-\t  tree first = streamer_tree_cache_get_tree (data_in->reader_cache,\n-\t\t\t\t\t\t     from);\n-\t  if (len == 1\n-\t      && (TREE_CODE (first) == IDENTIFIER_NODE\n-\t\t  || (TREE_CODE (first) == INTEGER_CST\n-\t\t      && !TREE_OVERFLOW (first))))\n-\t    continue;\n-\n-\t  /* Try to unify the SCC with already existing ones.  */\n-\t  if (!flag_ltrans\n-\t      && unify_scc (data_in, from,\n-\t\t\t    len, scc_entry_len, scc_hash))\n-\t    continue;\n-\n-\t  /* Tree merging failed, mark entries in location cache as\n-\t     permanent.  */\n-\t  data_in->location_cache.accept_location_cache ();\n-\n-\t  bool seen_type = false;\n-\t  for (unsigned i = 0; i < len; ++i)\n-\t    {\n-\t      tree t = streamer_tree_cache_get_tree (data_in->reader_cache,\n-\t\t\t\t\t\t     from + i);\n-\t      /* Reconstruct the type variant and pointer-to/reference-to\n-\t\t chains.  */\n-\t      if (TYPE_P (t))\n-\t\t{\n-\t\t  seen_type = true;\n-\t\t  num_prevailing_types++;\n-\t\t  lto_fixup_prevailing_type (t);\n-\n-\t\t  /* Compute the canonical type of all types.\n-\t\t     Because SCC components are streamed in random (hash) order\n-\t\t     we may have encountered the type before while registering\n-\t\t     type canonical of a derived type in the same SCC.  */\n-\t\t  if (!TYPE_CANONICAL (t))\n-\t\t    gimple_register_canonical_type (t);\n-\t\t  if (TYPE_MAIN_VARIANT (t) == t && odr_type_p (t))\n-\t\t    register_odr_type (t);\n-\t\t}\n-\t      /* Link shared INTEGER_CSTs into TYPE_CACHED_VALUEs of its\n-\t\t type which is also member of this SCC.  */\n-\t      if (TREE_CODE (t) == INTEGER_CST\n-\t\t  && !TREE_OVERFLOW (t))\n-\t\tcache_integer_cst (t);\n-\t      if (!flag_ltrans)\n-\t\t{\n-\t\t  lto_maybe_register_decl (data_in, t, from + i);\n-\t\t  /* Scan the tree for references to global functions or\n-\t\t     variables and record those for later fixup.  */\n-\t\t  if (mentions_vars_p (t))\n-\t\t    vec_safe_push (tree_with_vars, t);\n-\t\t}\n-\t    }\n-\n-\t  /* Register DECLs with the debuginfo machinery.  */\n-\t  while (!dref_queue.is_empty ())\n-\t    {\n-\t      dref_entry e = dref_queue.pop ();\n-\t      debug_hooks->register_external_die (e.decl, e.sym, e.off);\n-\t    }\n-\n-\t  if (seen_type)\n-\t    num_type_scc_trees += len;\n-\t}\n-      else\n-\t{\n-\t  /* Pickle stray references.  */\n-\t  t = lto_input_tree_1 (&ib_main, data_in, tag, 0);\n-\t  gcc_assert (t && data_in->reader_cache->nodes.length () == from);\n-\t}\n-    }\n-  data_in->location_cache.apply_location_cache ();\n-\n-  /* Read in lto_in_decl_state objects.  */\n-  data_ptr = (const uint32_t *) ((const char*) data + decl_offset); \n-  data_end =\n-     (const uint32_t *) ((const char*) data_ptr + header->decl_state_size);\n-  num_decl_states = *data_ptr++;\n-  \n-  gcc_assert (num_decl_states > 0);\n-  decl_data->global_decl_state = lto_new_in_decl_state ();\n-  data_ptr = lto_read_in_decl_state (data_in, data_ptr,\n-\t\t\t\t     decl_data->global_decl_state);\n-\n-  /* Read in per-function decl states and enter them in hash table.  */\n-  decl_data->function_decl_states =\n-    hash_table<decl_state_hasher>::create_ggc (37);\n-\n-  for (i = 1; i < num_decl_states; i++)\n-    {\n-      struct lto_in_decl_state *state = lto_new_in_decl_state ();\n-\n-      data_ptr = lto_read_in_decl_state (data_in, data_ptr, state);\n-      lto_in_decl_state **slot\n-\t= decl_data->function_decl_states->find_slot (state, INSERT);\n-      gcc_assert (*slot == NULL);\n-      *slot = state;\n-    }\n-\n-  if (data_ptr != data_end)\n-    internal_error (\"bytecode stream: garbage at the end of symbols section\");\n-\n-  /* Set the current decl state to be the global state. */\n-  decl_data->current_decl_state = decl_data->global_decl_state;\n-\n-  lto_data_in_delete (data_in);\n-}\n-\n-/* Custom version of strtoll, which is not portable.  */\n-\n-static int64_t\n-lto_parse_hex (const char *p)\n-{\n-  int64_t ret = 0;\n-\n-  for (; *p != '\\0'; ++p)\n-    {\n-      char c = *p;\n-      unsigned char part;\n-      ret <<= 4;\n-      if (c >= '0' && c <= '9')\n-        part = c - '0';\n-      else if (c >= 'a' && c <= 'f')\n-        part = c - 'a' + 10;\n-      else if (c >= 'A' && c <= 'F')\n-        part = c - 'A' + 10;\n-      else\n-        internal_error (\"could not parse hex number\");\n-      ret |= part;\n-    }\n-\n-  return ret;\n-}\n-\n-/* Read resolution for file named FILE_NAME. The resolution is read from\n-   RESOLUTION. */\n-\n-static void\n-lto_resolution_read (splay_tree file_ids, FILE *resolution, lto_file *file)\n-{\n-  /* We require that objects in the resolution file are in the same\n-     order as the lto1 command line. */\n-  unsigned int name_len;\n-  char *obj_name;\n-  unsigned int num_symbols;\n-  unsigned int i;\n-  struct lto_file_decl_data *file_data;\n-  splay_tree_node nd = NULL; \n-\n-  if (!resolution)\n-    return;\n-\n-  name_len = strlen (file->filename);\n-  obj_name = XNEWVEC (char, name_len + 1);\n-  fscanf (resolution, \" \");   /* Read white space. */\n-\n-  fread (obj_name, sizeof (char), name_len, resolution);\n-  obj_name[name_len] = '\\0';\n-  if (filename_cmp (obj_name, file->filename) != 0)\n-    internal_error (\"unexpected file name %s in linker resolution file. \"\n-\t\t    \"Expected %s\", obj_name, file->filename);\n-  if (file->offset != 0)\n-    {\n-      int t;\n-      char offset_p[17];\n-      int64_t offset;\n-      t = fscanf (resolution, \"@0x%16s\", offset_p);\n-      if (t != 1)\n-        internal_error (\"could not parse file offset\");\n-      offset = lto_parse_hex (offset_p);\n-      if (offset != file->offset)\n-        internal_error (\"unexpected offset\");\n-    }\n-\n-  free (obj_name);\n-\n-  fscanf (resolution, \"%u\", &num_symbols);\n-\n-  for (i = 0; i < num_symbols; i++)\n-    {\n-      int t;\n-      unsigned index;\n-      unsigned HOST_WIDE_INT id;\n-      char r_str[27];\n-      enum ld_plugin_symbol_resolution r = (enum ld_plugin_symbol_resolution) 0;\n-      unsigned int j;\n-      unsigned int lto_resolution_str_len =\n-\tsizeof (lto_resolution_str) / sizeof (char *);\n-      res_pair rp;\n-\n-      t = fscanf (resolution, \"%u \" HOST_WIDE_INT_PRINT_HEX_PURE \" %26s %*[^\\n]\\n\", \n-\t\t  &index, &id, r_str);\n-      if (t != 3)\n-        internal_error (\"invalid line in the resolution file\");\n-\n-      for (j = 0; j < lto_resolution_str_len; j++)\n-\t{\n-\t  if (strcmp (lto_resolution_str[j], r_str) == 0)\n-\t    {\n-\t      r = (enum ld_plugin_symbol_resolution) j;\n-\t      break;\n-\t    }\n-\t}\n-      if (j == lto_resolution_str_len)\n-\tinternal_error (\"invalid resolution in the resolution file\");\n-\n-      if (!(nd && lto_splay_tree_id_equal_p (nd->key, id)))\n-\t{\n-\t  nd = lto_splay_tree_lookup (file_ids, id);\n-\t  if (nd == NULL)\n-\t    internal_error (\"resolution sub id %wx not in object file\", id);\n-\t}\n-\n-      file_data = (struct lto_file_decl_data *)nd->value;\n-      /* The indexes are very sparse. To save memory save them in a compact\n-         format that is only unpacked later when the subfile is processed. */\n-      rp.res = r;\n-      rp.index = index;\n-      file_data->respairs.safe_push (rp);\n-      if (file_data->max_index < index)\n-        file_data->max_index = index;\n-    }\n-}\n-\n-/* List of file_decl_datas */\n-struct file_data_list\n-  {\n-    struct lto_file_decl_data *first, *last;\n-  };\n-\n-/* Is the name for a id'ed LTO section? */\n-\n-static int \n-lto_section_with_id (const char *name, unsigned HOST_WIDE_INT *id)\n-{\n-  const char *s;\n-\n-  if (strncmp (name, section_name_prefix, strlen (section_name_prefix)))\n-    return 0;\n-  s = strrchr (name, '.');\n-  if (!s)\n-    return 0;\n-  /* If the section is not suffixed with an ID return.  */\n-  if ((size_t)(s - name) == strlen (section_name_prefix))\n-    return 0;\n-  return sscanf (s, \".\" HOST_WIDE_INT_PRINT_HEX_PURE, id) == 1;\n-}\n-\n-/* Create file_data of each sub file id */\n-\n-static int \n-create_subid_section_table (struct lto_section_slot *ls, splay_tree file_ids,\n-                            struct file_data_list *list)\n-{\n-  struct lto_section_slot s_slot, *new_slot;\n-  unsigned HOST_WIDE_INT id;\n-  splay_tree_node nd;\n-  void **hash_slot;\n-  char *new_name;\n-  struct lto_file_decl_data *file_data;\n-\n-  if (!lto_section_with_id (ls->name, &id))\n-    return 1;\n-  \n-  /* Find hash table of sub module id */\n-  nd = lto_splay_tree_lookup (file_ids, id);\n-  if (nd != NULL)\n-    {\n-      file_data = (struct lto_file_decl_data *)nd->value;\n-    }\n-  else\n-    {\n-      file_data = ggc_alloc<lto_file_decl_data> ();\n-      memset(file_data, 0, sizeof (struct lto_file_decl_data));\n-      file_data->id = id;\n-      file_data->section_hash_table = lto_obj_create_section_hash_table ();\n-      lto_splay_tree_insert (file_ids, id, file_data);\n-\n-      /* Maintain list in linker order */\n-      if (!list->first)\n-        list->first = file_data;\n-      if (list->last)\n-        list->last->next = file_data;\n-      list->last = file_data;\n-    }\n-\n-  /* Copy section into sub module hash table */\n-  new_name = XDUPVEC (char, ls->name, strlen (ls->name) + 1);\n-  s_slot.name = new_name;\n-  hash_slot = htab_find_slot (file_data->section_hash_table, &s_slot, INSERT);\n-  gcc_assert (*hash_slot == NULL);\n-\n-  new_slot = XDUP (struct lto_section_slot, ls);\n-  new_slot->name = new_name;\n-  *hash_slot = new_slot;\n-  return 1;\n-}\n-\n-/* Read declarations and other initializations for a FILE_DATA. */\n-\n-static void\n-lto_file_finalize (struct lto_file_decl_data *file_data, lto_file *file)\n-{\n-  const char *data;\n-  size_t len;\n-  vec<ld_plugin_symbol_resolution_t>\n-\tresolutions = vNULL;\n-  int i;\n-  res_pair *rp;\n-\n-  /* Create vector for fast access of resolution. We do this lazily\n-     to save memory. */ \n-  resolutions.safe_grow_cleared (file_data->max_index + 1);\n-  for (i = 0; file_data->respairs.iterate (i, &rp); i++)\n-    resolutions[rp->index] = rp->res;\n-  file_data->respairs.release ();\n-\n-  file_data->renaming_hash_table = lto_create_renaming_table ();\n-  file_data->file_name = file->filename;\n-#ifdef ACCEL_COMPILER\n-  lto_input_mode_table (file_data);\n-#else\n-  file_data->mode_table = lto_mode_identity_table;\n-#endif\n-  data = lto_get_section_data (file_data, LTO_section_decls, NULL, &len);\n-  if (data == NULL)\n-    {\n-      internal_error (\"cannot read LTO decls from %s\", file_data->file_name);\n-      return;\n-    }\n-  /* Frees resolutions */\n-  lto_read_decls (file_data, data, resolutions);\n-  lto_free_section_data (file_data, LTO_section_decls, NULL, data, len);\n-}\n-\n-/* Finalize FILE_DATA in FILE and increase COUNT. */\n-\n-static int \n-lto_create_files_from_ids (lto_file *file, struct lto_file_decl_data *file_data,\n-\t\t\t   int *count)\n-{\n-  lto_file_finalize (file_data, file);\n-  if (symtab->dump_file)\n-    fprintf (symtab->dump_file,\n-\t     \"Creating file %s with sub id \" HOST_WIDE_INT_PRINT_HEX \"\\n\",\n-\t     file_data->file_name, file_data->id);\n-  (*count)++;\n-  return 0;\n-}\n-\n-/* Generate a TREE representation for all types and external decls\n-   entities in FILE.  \n-\n-   Read all of the globals out of the file.  Then read the cgraph\n-   and process the .o index into the cgraph nodes so that it can open\n-   the .o file to load the functions and ipa information.   */\n-\n-static struct lto_file_decl_data *\n-lto_file_read (lto_file *file, FILE *resolution_file, int *count)\n-{\n-  struct lto_file_decl_data *file_data = NULL;\n-  splay_tree file_ids;\n-  htab_t section_hash_table;\n-  struct lto_section_slot *section;\n-  struct file_data_list file_list;\n-  struct lto_section_list section_list;\n- \n-  memset (&section_list, 0, sizeof (struct lto_section_list)); \n-  section_hash_table = lto_obj_build_section_table (file, &section_list);\n-\n-  /* Find all sub modules in the object and put their sections into new hash\n-     tables in a splay tree. */\n-  file_ids = lto_splay_tree_new ();\n-  memset (&file_list, 0, sizeof (struct file_data_list));\n-  for (section = section_list.first; section != NULL; section = section->next)\n-    create_subid_section_table (section, file_ids, &file_list);\n-\n-  /* Add resolutions to file ids */\n-  lto_resolution_read (file_ids, resolution_file, file);\n-\n-  /* Finalize each lto file for each submodule in the merged object */\n-  for (file_data = file_list.first; file_data != NULL; file_data = file_data->next)\n-    lto_create_files_from_ids (file, file_data, count);\n- \n-  splay_tree_delete (file_ids);\n-  htab_delete (section_hash_table);\n-\n-  return file_list.first;\n-}\n-\n-#if HAVE_MMAP_FILE && HAVE_SYSCONF && defined _SC_PAGE_SIZE\n-#define LTO_MMAP_IO 1\n-#endif\n-\n-#if LTO_MMAP_IO\n-/* Page size of machine is used for mmap and munmap calls.  */\n-static size_t page_mask;\n-#endif\n-\n-/* Get the section data of length LEN from FILENAME starting at\n-   OFFSET.  The data segment must be freed by the caller when the\n-   caller is finished.  Returns NULL if all was not well.  */\n-\n-static char *\n-lto_read_section_data (struct lto_file_decl_data *file_data,\n-\t\t       intptr_t offset, size_t len)\n-{\n-  char *result;\n-  static int fd = -1;\n-  static char *fd_name;\n-#if LTO_MMAP_IO\n-  intptr_t computed_len;\n-  intptr_t computed_offset;\n-  intptr_t diff;\n-#endif\n-\n-  /* Keep a single-entry file-descriptor cache.  The last file we\n-     touched will get closed at exit.\n-     ???  Eventually we want to add a more sophisticated larger cache\n-     or rather fix function body streaming to not stream them in\n-     practically random order.  */\n-  if (fd != -1\n-      && filename_cmp (fd_name, file_data->file_name) != 0)\n-    {\n-      free (fd_name);\n-      close (fd);\n-      fd = -1;\n-    }\n-  if (fd == -1)\n-    {\n-      fd = open (file_data->file_name, O_RDONLY|O_BINARY);\n-      if (fd == -1)\n-        {\n-\t  fatal_error (input_location, \"Cannot open %s\", file_data->file_name);\n-\t  return NULL;\n-        }\n-      fd_name = xstrdup (file_data->file_name);\n-    }\n-\n-#if LTO_MMAP_IO\n-  if (!page_mask)\n-    {\n-      size_t page_size = sysconf (_SC_PAGE_SIZE);\n-      page_mask = ~(page_size - 1);\n-    }\n-\n-  computed_offset = offset & page_mask;\n-  diff = offset - computed_offset;\n-  computed_len = len + diff;\n-\n-  result = (char *) mmap (NULL, computed_len, PROT_READ, MAP_PRIVATE,\n-\t\t\t  fd, computed_offset);\n-  if (result == MAP_FAILED)\n-    {\n-      fatal_error (input_location, \"Cannot map %s\", file_data->file_name);\n-      return NULL;\n-    }\n-\n-  return result + diff;\n-#else\n-  result = (char *) xmalloc (len);\n-  if (lseek (fd, offset, SEEK_SET) != offset\n-      || read (fd, result, len) != (ssize_t) len)\n-    {\n-      free (result);\n-      fatal_error (input_location, \"Cannot read %s\", file_data->file_name);\n-      result = NULL;\n-    }\n-#ifdef __MINGW32__\n-  /* Native windows doesn't supports delayed unlink on opened file. So\n-     we close file here again. This produces higher I/O load, but at least\n-     it prevents to have dangling file handles preventing unlink.  */\n-  free (fd_name);\n-  fd_name = NULL;\n-  close (fd);\n-  fd = -1;\n-#endif\n-  return result;\n-#endif\n-}    \n+  struct cgraph_node *node; \n+  timevar_id_t lto_timer;\n \n+  if (!quiet_flag)\n+    fprintf (stderr,\n+\t     flag_wpa ? \"Materializing decls:\" : \"Reading function bodies:\");\n \n-/* Get the section data from FILE_DATA of SECTION_TYPE with NAME.\n-   NAME will be NULL unless the section type is for a function\n-   body.  */\n \n-static const char *\n-get_section_data (struct lto_file_decl_data *file_data,\n-\t\t      enum lto_section_type section_type,\n-\t\t      const char *name,\n-\t\t      size_t *len)\n-{\n-  htab_t section_hash_table = file_data->section_hash_table;\n-  struct lto_section_slot *f_slot;\n-  struct lto_section_slot s_slot;\n-  const char *section_name = lto_get_section_name (section_type, name, file_data);\n-  char *data = NULL;\n-\n-  *len = 0;\n-  s_slot.name = section_name;\n-  f_slot = (struct lto_section_slot *) htab_find (section_hash_table, &s_slot);\n-  if (f_slot)\n+  FOR_EACH_FUNCTION (node)\n     {\n-      data = lto_read_section_data (file_data, f_slot->start, f_slot->len);\n-      *len = f_slot->len;\n+      if (node->lto_file_data)\n+\t{\n+\t  lto_materialize_function (node);\n+\t  lto_stats.num_input_cgraph_nodes++;\n+\t}\n     }\n \n-  free (CONST_CAST (char *, section_name));\n-  return data;\n-}\n-\n \n-/* Free the section data from FILE_DATA of SECTION_TYPE with NAME that\n-   starts at OFFSET and has LEN bytes.  */\n+  /* Start the appropriate timer depending on the mode that we are\n+     operating in.  */\n+  lto_timer = (flag_wpa) ? TV_WHOPR_WPA\n+\t      : (flag_ltrans) ? TV_WHOPR_LTRANS\n+\t      : TV_LTO;\n+  timevar_push (lto_timer);\n \n-static void\n-free_section_data (struct lto_file_decl_data *file_data ATTRIBUTE_UNUSED,\n-\t\t   enum lto_section_type section_type ATTRIBUTE_UNUSED,\n-\t\t   const char *name ATTRIBUTE_UNUSED,\n-\t\t   const char *offset, size_t len ATTRIBUTE_UNUSED)\n-{\n-#if LTO_MMAP_IO\n-  intptr_t computed_len;\n-  intptr_t computed_offset;\n-  intptr_t diff;\n-#endif\n+  current_function_decl = NULL;\n+  set_cfun (NULL);\n \n-#if LTO_MMAP_IO\n-  computed_offset = ((intptr_t) offset) & page_mask;\n-  diff = (intptr_t) offset - computed_offset;\n-  computed_len = len + diff;\n+  if (!quiet_flag)\n+    fprintf (stderr, \"\\n\");\n \n-  munmap ((caddr_t) computed_offset, computed_len);\n-#else\n-  free (CONST_CAST(char *, offset));\n-#endif\n+  timevar_pop (lto_timer);\n }\n \n-static lto_file *current_lto_file;\n-\n /* Actually stream out ENCODER into TEMP_FILENAME.  */\n \n static void\n@@ -2551,581 +402,6 @@ lto_wpa_write_files (void)\n   timevar_pop (TV_WHOPR_WPA_IO);\n }\n \n-\n-/* If TT is a variable or function decl replace it with its\n-   prevailing variant.  */\n-#define LTO_SET_PREVAIL(tt) \\\n-  do {\\\n-    if ((tt) && VAR_OR_FUNCTION_DECL_P (tt) \\\n-\t&& (TREE_PUBLIC (tt) || DECL_EXTERNAL (tt))) \\\n-      { \\\n-        tt = lto_symtab_prevailing_decl (tt); \\\n-\tfixed = true; \\\n-      } \\\n-  } while (0)\n-\n-/* Ensure that TT isn't a replacable var of function decl.  */\n-#define LTO_NO_PREVAIL(tt) \\\n-  gcc_checking_assert (!(tt) || !VAR_OR_FUNCTION_DECL_P (tt))\n-\n-/* Given a tree T replace all fields referring to variables or functions\n-   with their prevailing variant.  */\n-static void\n-lto_fixup_prevailing_decls (tree t)\n-{\n-  enum tree_code code = TREE_CODE (t);\n-  bool fixed = false;\n-\n-  gcc_checking_assert (code != TREE_BINFO);\n-  LTO_NO_PREVAIL (TREE_TYPE (t));\n-  if (CODE_CONTAINS_STRUCT (code, TS_COMMON)\n-      /* lto_symtab_prevail_decl use TREE_CHAIN to link to the prevailing decl.\n-\t in the case T is a prevailed declaration we would ICE here. */\n-      && !VAR_OR_FUNCTION_DECL_P (t))\n-    LTO_NO_PREVAIL (TREE_CHAIN (t));\n-  if (DECL_P (t))\n-    {\n-      LTO_NO_PREVAIL (DECL_NAME (t));\n-      LTO_SET_PREVAIL (DECL_CONTEXT (t));\n-      if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n-\t{\n-\t  LTO_SET_PREVAIL (DECL_SIZE (t));\n-\t  LTO_SET_PREVAIL (DECL_SIZE_UNIT (t));\n-\t  LTO_SET_PREVAIL (DECL_INITIAL (t));\n-\t  LTO_NO_PREVAIL (DECL_ATTRIBUTES (t));\n-\t  LTO_SET_PREVAIL (DECL_ABSTRACT_ORIGIN (t));\n-\t}\n-      if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n-\t{\n-\t  LTO_NO_PREVAIL (DECL_ASSEMBLER_NAME_RAW (t));\n-\t}\n-      if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n-\t{\n-\t  LTO_NO_PREVAIL (DECL_RESULT_FLD (t));\n-\t}\n-      if (CODE_CONTAINS_STRUCT (code, TS_FUNCTION_DECL))\n-\t{\n-\t  LTO_NO_PREVAIL (DECL_ARGUMENTS (t));\n-\t  LTO_SET_PREVAIL (DECL_FUNCTION_PERSONALITY (t));\n-\t  LTO_NO_PREVAIL (DECL_VINDEX (t));\n-\t}\n-      if (CODE_CONTAINS_STRUCT (code, TS_FIELD_DECL))\n-\t{\n-\t  LTO_SET_PREVAIL (DECL_FIELD_OFFSET (t));\n-\t  LTO_NO_PREVAIL (DECL_BIT_FIELD_TYPE (t));\n-\t  LTO_NO_PREVAIL (DECL_QUALIFIER (t));\n-\t  LTO_NO_PREVAIL (DECL_FIELD_BIT_OFFSET (t));\n-\t  LTO_NO_PREVAIL (DECL_FCONTEXT (t));\n-\t}\n-    }\n-  else if (TYPE_P (t))\n-    {\n-      LTO_NO_PREVAIL (TYPE_CACHED_VALUES (t));\n-      LTO_SET_PREVAIL (TYPE_SIZE (t));\n-      LTO_SET_PREVAIL (TYPE_SIZE_UNIT (t));\n-      LTO_NO_PREVAIL (TYPE_ATTRIBUTES (t));\n-      LTO_NO_PREVAIL (TYPE_NAME (t));\n-\n-      LTO_SET_PREVAIL (TYPE_MIN_VALUE_RAW (t));\n-      LTO_SET_PREVAIL (TYPE_MAX_VALUE_RAW (t));\n-      LTO_NO_PREVAIL (TYPE_LANG_SLOT_1 (t));\n-\n-      LTO_SET_PREVAIL (TYPE_CONTEXT (t));\n-\n-      LTO_NO_PREVAIL (TYPE_CANONICAL (t));\n-      LTO_NO_PREVAIL (TYPE_MAIN_VARIANT (t));\n-      LTO_NO_PREVAIL (TYPE_NEXT_VARIANT (t));\n-    }\n-  else if (EXPR_P (t))\n-    {\n-      int i;\n-      for (i = TREE_OPERAND_LENGTH (t) - 1; i >= 0; --i)\n-\tLTO_SET_PREVAIL (TREE_OPERAND (t, i));\n-    }\n-  else if (TREE_CODE (t) == CONSTRUCTOR)\n-    {\n-      unsigned i;\n-      tree val;\n-      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (t), i, val)\n-\tLTO_SET_PREVAIL (val);\n-    }\n-  else\n-    {\n-      switch (code)\n-\t{\n-\tcase TREE_LIST:\n-\t  LTO_SET_PREVAIL (TREE_VALUE (t));\n-\t  LTO_SET_PREVAIL (TREE_PURPOSE (t));\n-\t  LTO_NO_PREVAIL (TREE_PURPOSE (t));\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-  /* If we fixed nothing, then we missed something seen by\n-     mentions_vars_p.  */\n-  gcc_checking_assert (fixed);\n-}\n-#undef LTO_SET_PREVAIL\n-#undef LTO_NO_PREVAIL\n-\n-/* Helper function of lto_fixup_decls. Walks the var and fn streams in STATE,\n-   replaces var and function decls with the corresponding prevailing def.  */\n-\n-static void\n-lto_fixup_state (struct lto_in_decl_state *state)\n-{\n-  unsigned i, si;\n-\n-  /* Although we only want to replace FUNCTION_DECLs and VAR_DECLs,\n-     we still need to walk from all DECLs to find the reachable\n-     FUNCTION_DECLs and VAR_DECLs.  */\n-  for (si = 0; si < LTO_N_DECL_STREAMS; si++)\n-    {\n-      vec<tree, va_gc> *trees = state->streams[si];\n-      for (i = 0; i < vec_safe_length (trees); i++)\n-\t{\n-\t  tree t = (*trees)[i];\n-\t  if (flag_checking && TYPE_P (t))\n-\t    verify_type (t);\n-\t  if (VAR_OR_FUNCTION_DECL_P (t)\n-\t      && (TREE_PUBLIC (t) || DECL_EXTERNAL (t)))\n-\t    (*trees)[i] = lto_symtab_prevailing_decl (t);\n-\t}\n-    }\n-}\n-\n-/* Fix the decls from all FILES. Replaces each decl with the corresponding\n-   prevailing one.  */\n-\n-static void\n-lto_fixup_decls (struct lto_file_decl_data **files)\n-{\n-  unsigned int i;\n-  tree t;\n-\n-  if (tree_with_vars)\n-    FOR_EACH_VEC_ELT ((*tree_with_vars), i, t)\n-      lto_fixup_prevailing_decls (t);\n-\n-  for (i = 0; files[i]; i++)\n-    {\n-      struct lto_file_decl_data *file = files[i];\n-      struct lto_in_decl_state *state = file->global_decl_state;\n-      lto_fixup_state (state);\n-\n-      hash_table<decl_state_hasher>::iterator iter;\n-      lto_in_decl_state *elt;\n-      FOR_EACH_HASH_TABLE_ELEMENT (*file->function_decl_states, elt,\n-\t\t\t\t   lto_in_decl_state *, iter)\n-\tlto_fixup_state (elt);\n-    }\n-}\n-\n-static GTY((length (\"lto_stats.num_input_files + 1\"))) struct lto_file_decl_data **all_file_decl_data;\n-\n-/* Turn file datas for sub files into a single array, so that they look\n-   like separate files for further passes. */\n-\n-static void\n-lto_flatten_files (struct lto_file_decl_data **orig, int count, int last_file_ix)\n-{\n-  struct lto_file_decl_data *n, *next;\n-  int i, k;\n-\n-  lto_stats.num_input_files = count;\n-  all_file_decl_data\n-    = ggc_cleared_vec_alloc<lto_file_decl_data_ptr> (count + 1);\n-  /* Set the hooks so that all of the ipa passes can read in their data.  */\n-  lto_set_in_hooks (all_file_decl_data, get_section_data, free_section_data);\n-  for (i = 0, k = 0; i < last_file_ix; i++) \n-    {\n-      for (n = orig[i]; n != NULL; n = next)\n-\t{\n-\t  all_file_decl_data[k++] = n;\n-\t  next = n->next;\n-\t  n->next = NULL;\n-\t}\n-    }\n-  all_file_decl_data[k] = NULL;\n-  gcc_assert (k == count);\n-}\n-\n-/* Input file data before flattening (i.e. splitting them to subfiles to support\n-   incremental linking.  */\n-static int real_file_count;\n-static GTY((length (\"real_file_count + 1\"))) struct lto_file_decl_data **real_file_decl_data;\n-\n-static void print_lto_report_1 (void);\n-\n-/* Read all the symbols from the input files FNAMES.  NFILES is the\n-   number of files requested in the command line.  Instantiate a\n-   global call graph by aggregating all the sub-graphs found in each\n-   file.  */\n-\n-static void\n-read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n-{\n-  unsigned int i, last_file_ix;\n-  FILE *resolution;\n-  int count = 0;\n-  struct lto_file_decl_data **decl_data;\n-  symtab_node *snode;\n-\n-  symtab->initialize ();\n-\n-  timevar_push (TV_IPA_LTO_DECL_IN);\n-\n-#ifdef ACCEL_COMPILER\n-  section_name_prefix = OFFLOAD_SECTION_NAME_PREFIX;\n-  lto_stream_offload_p = true;\n-#endif\n-\n-  real_file_decl_data\n-    = decl_data = ggc_cleared_vec_alloc<lto_file_decl_data_ptr> (nfiles + 1);\n-  real_file_count = nfiles;\n-\n-  /* Read the resolution file.  */\n-  resolution = NULL;\n-  if (resolution_file_name)\n-    {\n-      int t;\n-      unsigned num_objects;\n-\n-      resolution = fopen (resolution_file_name, \"r\");\n-      if (resolution == NULL)\n-\tfatal_error (input_location,\n-\t\t     \"could not open symbol resolution file: %m\");\n-\n-      t = fscanf (resolution, \"%u\", &num_objects);\n-      gcc_assert (t == 1);\n-\n-      /* True, since the plugin splits the archives.  */\n-      gcc_assert (num_objects == nfiles);\n-    }\n-  symtab->state = LTO_STREAMING;\n-\n-  canonical_type_hash_cache = new hash_map<const_tree, hashval_t> (251);\n-  gimple_canonical_types = htab_create (16381, gimple_canonical_type_hash,\n-\t\t\t\t\tgimple_canonical_type_eq, NULL);\n-  gcc_obstack_init (&tree_scc_hash_obstack);\n-  tree_scc_hash = new hash_table<tree_scc_hasher> (4096);\n-\n-  /* Register the common node types with the canonical type machinery so\n-     we properly share alias-sets across languages and TUs.  Do not\n-     expose the common nodes as type merge target - those that should be\n-     are already exposed so by pre-loading the LTO streamer caches.\n-     Do two passes - first clear TYPE_CANONICAL and then re-compute it.  */\n-  for (i = 0; i < itk_none; ++i)\n-    lto_register_canonical_types (integer_types[i], true);\n-  for (i = 0; i < stk_type_kind_last; ++i)\n-    lto_register_canonical_types (sizetype_tab[i], true);\n-  for (i = 0; i < TI_MAX; ++i)\n-    lto_register_canonical_types (global_trees[i], true);\n-  for (i = 0; i < itk_none; ++i)\n-    lto_register_canonical_types (integer_types[i], false);\n-  for (i = 0; i < stk_type_kind_last; ++i)\n-    lto_register_canonical_types (sizetype_tab[i], false);\n-  for (i = 0; i < TI_MAX; ++i)\n-    lto_register_canonical_types (global_trees[i], false);\n-\n-  if (!quiet_flag)\n-    fprintf (stderr, \"Reading object files:\");\n-\n-  /* Read all of the object files specified on the command line.  */\n-  for (i = 0, last_file_ix = 0; i < nfiles; ++i)\n-    {\n-      struct lto_file_decl_data *file_data = NULL;\n-      if (!quiet_flag)\n-\t{\n-\t  fprintf (stderr, \" %s\", fnames[i]);\n-\t  fflush (stderr);\n-\t}\n-\n-      current_lto_file = lto_obj_file_open (fnames[i], false);\n-      if (!current_lto_file)\n-\tbreak;\n-\n-      file_data = lto_file_read (current_lto_file, resolution, &count);\n-      if (!file_data)\n-\t{\n-\t  lto_obj_file_close (current_lto_file);\n-\t  free (current_lto_file);\n-\t  current_lto_file = NULL;\n-\t  break;\n-\t}\n-\n-      decl_data[last_file_ix++] = file_data;\n-\n-      lto_obj_file_close (current_lto_file);\n-      free (current_lto_file);\n-      current_lto_file = NULL;\n-    }\n-\n-  lto_flatten_files (decl_data, count, last_file_ix);\n-  lto_stats.num_input_files = count;\n-  ggc_free(decl_data);\n-  real_file_decl_data = NULL;\n-\n-  if (resolution_file_name)\n-    fclose (resolution);\n-\n-  /* Show the LTO report before launching LTRANS.  */\n-  if (flag_lto_report || (flag_wpa && flag_lto_report_wpa))\n-    print_lto_report_1 ();\n-\n-  /* Free gimple type merging datastructures.  */\n-  delete tree_scc_hash;\n-  tree_scc_hash = NULL;\n-  obstack_free (&tree_scc_hash_obstack, NULL);\n-  htab_delete (gimple_canonical_types);\n-  gimple_canonical_types = NULL;\n-  delete canonical_type_hash_cache;\n-  canonical_type_hash_cache = NULL;\n-\n-  /* At this stage we know that majority of GGC memory is reachable.  \n-     Growing the limits prevents unnecesary invocation of GGC.  */\n-  ggc_grow ();\n-  ggc_collect ();\n-\n-  /* Set the hooks so that all of the ipa passes can read in their data.  */\n-  lto_set_in_hooks (all_file_decl_data, get_section_data, free_section_data);\n-\n-  timevar_pop (TV_IPA_LTO_DECL_IN);\n-\n-  if (!quiet_flag)\n-    fprintf (stderr, \"\\nReading the callgraph\\n\");\n-\n-  timevar_push (TV_IPA_LTO_CGRAPH_IO);\n-  /* Read the symtab.  */\n-  input_symtab ();\n-\n-  input_offload_tables (!flag_ltrans);\n-\n-  /* Store resolutions into the symbol table.  */\n-\n-  FOR_EACH_SYMBOL (snode)\n-    if (snode->externally_visible && snode->real_symbol_p ()\n-\t&& snode->lto_file_data && snode->lto_file_data->resolution_map\n-\t&& !(TREE_CODE (snode->decl) == FUNCTION_DECL\n-\t     && fndecl_built_in_p (snode->decl))\n-\t&& !(VAR_P (snode->decl) && DECL_HARD_REGISTER (snode->decl)))\n-      {\n-\tld_plugin_symbol_resolution_t *res;\n-\n-\tres = snode->lto_file_data->resolution_map->get (snode->decl);\n-\tif (!res || *res == LDPR_UNKNOWN)\n-\t  {\n-\t    if (snode->output_to_lto_symbol_table_p ())\n-\t      fatal_error (input_location, \"missing resolution data for %s\",\n-\t\t           IDENTIFIER_POINTER\n-\t\t\t     (DECL_ASSEMBLER_NAME (snode->decl)));\n-\t  }\n-\telse\n-          snode->resolution = *res;\n-      }\n-  for (i = 0; all_file_decl_data[i]; i++)\n-    if (all_file_decl_data[i]->resolution_map)\n-      {\n-        delete all_file_decl_data[i]->resolution_map;\n-        all_file_decl_data[i]->resolution_map = NULL;\n-      }\n-  \n-  timevar_pop (TV_IPA_LTO_CGRAPH_IO);\n-\n-  if (!quiet_flag)\n-    fprintf (stderr, \"Merging declarations\\n\");\n-\n-  timevar_push (TV_IPA_LTO_DECL_MERGE);\n-  /* Merge global decls.  In ltrans mode we read merged cgraph, we do not\n-     need to care about resolving symbols again, we only need to replace\n-     duplicated declarations read from the callgraph and from function\n-     sections.  */\n-  if (!flag_ltrans)\n-    {\n-      lto_symtab_merge_decls ();\n-\n-      /* If there were errors during symbol merging bail out, we have no\n-\t good way to recover here.  */\n-      if (seen_error ())\n-\tfatal_error (input_location,\n-\t\t     \"errors during merging of translation units\");\n-\n-      /* Fixup all decls.  */\n-      lto_fixup_decls (all_file_decl_data);\n-    }\n-  if (tree_with_vars)\n-    ggc_free (tree_with_vars);\n-  tree_with_vars = NULL;\n-  ggc_collect ();\n-\n-  timevar_pop (TV_IPA_LTO_DECL_MERGE);\n-  /* Each pass will set the appropriate timer.  */\n-\n-  if (!quiet_flag)\n-    fprintf (stderr, \"Reading summaries\\n\");\n-\n-  /* Read the IPA summary data.  */\n-  if (flag_ltrans)\n-    ipa_read_optimization_summaries ();\n-  else\n-    ipa_read_summaries ();\n-\n-  for (i = 0; all_file_decl_data[i]; i++)\n-    {\n-      gcc_assert (all_file_decl_data[i]->symtab_node_encoder);\n-      lto_symtab_encoder_delete (all_file_decl_data[i]->symtab_node_encoder);\n-      all_file_decl_data[i]->symtab_node_encoder = NULL;\n-      lto_free_function_in_decl_state (all_file_decl_data[i]->global_decl_state);\n-      all_file_decl_data[i]->global_decl_state = NULL;\n-      all_file_decl_data[i]->current_decl_state = NULL; \n-    }\n-\n-  if (!flag_ltrans)\n-    {\n-      /* Finally merge the cgraph according to the decl merging decisions.  */\n-      timevar_push (TV_IPA_LTO_CGRAPH_MERGE);\n-\n-      gcc_assert (!dump_file);\n-      dump_file = dump_begin (lto_link_dump_id, NULL);\n-\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"Before merging:\\n\");\n-\t  symtab->dump (dump_file);\n-\t}\n-      lto_symtab_merge_symbols ();\n-      /* Removal of unreachable symbols is needed to make verify_symtab to pass;\n-\t we are still having duplicated comdat groups containing local statics.\n-\t We could also just remove them while merging.  */\n-      symtab->remove_unreachable_nodes (dump_file);\n-      ggc_collect ();\n-\n-      if (dump_file)\n-        dump_end (lto_link_dump_id, dump_file);\n-      dump_file = NULL;\n-      timevar_pop (TV_IPA_LTO_CGRAPH_MERGE);\n-    }\n-  symtab->state = IPA_SSA;\n-  /* All node removals happening here are useless, because\n-     WPA should not stream them.  Still always perform remove_unreachable_nodes\n-     because we may reshape clone tree, get rid of dead masters of inline\n-     clones and remove symbol entries for read-only variables we keep around\n-     only to be able to constant fold them.  */\n-  if (flag_ltrans)\n-    {\n-      if (symtab->dump_file)\n-\t symtab->dump (symtab->dump_file);\n-      symtab->remove_unreachable_nodes (symtab->dump_file);\n-    }\n-\n-  /* Indicate that the cgraph is built and ready.  */\n-  symtab->function_flags_ready = true;\n-\n-  ggc_free (all_file_decl_data);\n-  all_file_decl_data = NULL;\n-}\n-\n-\n-/* Materialize all the bodies for all the nodes in the callgraph.  */\n-\n-static void\n-materialize_cgraph (void)\n-{\n-  struct cgraph_node *node; \n-  timevar_id_t lto_timer;\n-\n-  if (!quiet_flag)\n-    fprintf (stderr,\n-\t     flag_wpa ? \"Materializing decls:\" : \"Reading function bodies:\");\n-\n-\n-  FOR_EACH_FUNCTION (node)\n-    {\n-      if (node->lto_file_data)\n-\t{\n-\t  lto_materialize_function (node);\n-\t  lto_stats.num_input_cgraph_nodes++;\n-\t}\n-    }\n-\n-\n-  /* Start the appropriate timer depending on the mode that we are\n-     operating in.  */\n-  lto_timer = (flag_wpa) ? TV_WHOPR_WPA\n-\t      : (flag_ltrans) ? TV_WHOPR_LTRANS\n-\t      : TV_LTO;\n-  timevar_push (lto_timer);\n-\n-  current_function_decl = NULL;\n-  set_cfun (NULL);\n-\n-  if (!quiet_flag)\n-    fprintf (stderr, \"\\n\");\n-\n-  timevar_pop (lto_timer);\n-}\n-\n-\n-/* Show various memory usage statistics related to LTO.  */\n-static void\n-print_lto_report_1 (void)\n-{\n-  const char *pfx = (flag_lto) ? \"LTO\" : (flag_wpa) ? \"WPA\" : \"LTRANS\";\n-  fprintf (stderr, \"%s statistics\\n\", pfx);\n-\n-  fprintf (stderr, \"[%s] read %lu SCCs of average size %f\\n\",\n-\t   pfx, num_sccs_read, total_scc_size / (double)num_sccs_read);\n-  fprintf (stderr, \"[%s] %lu tree bodies read in total\\n\", pfx, total_scc_size);\n-  if (flag_wpa && tree_scc_hash)\n-    {\n-      fprintf (stderr, \"[%s] tree SCC table: size %ld, %ld elements, \"\n-\t       \"collision ratio: %f\\n\", pfx,\n-\t       (long) tree_scc_hash->size (),\n-\t       (long) tree_scc_hash->elements (),\n-\t       tree_scc_hash->collisions ());\n-      hash_table<tree_scc_hasher>::iterator hiter;\n-      tree_scc *scc, *max_scc = NULL;\n-      unsigned max_length = 0;\n-      FOR_EACH_HASH_TABLE_ELEMENT (*tree_scc_hash, scc, x, hiter)\n-\t{\n-\t  unsigned length = 0;\n-\t  tree_scc *s = scc;\n-\t  for (; s; s = s->next)\n-\t    length++;\n-\t  if (length > max_length)\n-\t    {\n-\t      max_length = length;\n-\t      max_scc = scc;\n-\t    }\n-\t}\n-      fprintf (stderr, \"[%s] tree SCC max chain length %u (size %u)\\n\",\n-\t       pfx, max_length, max_scc->len);\n-      fprintf (stderr, \"[%s] Compared %lu SCCs, %lu collisions (%f)\\n\", pfx,\n-\t       num_scc_compares, num_scc_compare_collisions,\n-\t       num_scc_compare_collisions / (double) num_scc_compares);\n-      fprintf (stderr, \"[%s] Merged %lu SCCs\\n\", pfx, num_sccs_merged);\n-      fprintf (stderr, \"[%s] Merged %lu tree bodies\\n\", pfx,\n-\t       total_scc_size_merged);\n-      fprintf (stderr, \"[%s] Merged %lu types\\n\", pfx, num_merged_types);\n-      fprintf (stderr, \"[%s] %lu types prevailed (%lu associated trees)\\n\",\n-\t       pfx, num_prevailing_types, num_type_scc_trees);\n-      fprintf (stderr, \"[%s] GIMPLE canonical type table: size %ld, \"\n-\t       \"%ld elements, %ld searches, %ld collisions (ratio: %f)\\n\", pfx,\n-\t       (long) htab_size (gimple_canonical_types),\n-\t       (long) htab_elements (gimple_canonical_types),\n-\t       (long) gimple_canonical_types->searches,\n-\t       (long) gimple_canonical_types->collisions,\n-\t       htab_collisions (gimple_canonical_types));\n-      fprintf (stderr, \"[%s] GIMPLE canonical type pointer-map: \"\n-\t       \"%lu elements, %ld searches\\n\", pfx,\n-\t       num_canonical_type_hash_entries,\n-\t       num_canonical_type_hash_queries);\n-    }\n-\n-  print_lto_report (pfx);\n-}\n-\n /* Perform whole program analysis (WPA) on the callgraph and write out the\n    optimization plan.  */\n \n@@ -3253,64 +529,6 @@ do_whole_program_analysis (void)\n     dump_memory_report (true);\n }\n \n-\n-static GTY(()) tree lto_eh_personality_decl;\n-\n-/* Return the LTO personality function decl.  */\n-\n-tree\n-lto_eh_personality (void)\n-{\n-  if (!lto_eh_personality_decl)\n-    {\n-      /* Use the first personality DECL for our personality if we don't\n-\t support multiple ones.  This ensures that we don't artificially\n-\t create the need for them in a single-language program.  */\n-      if (first_personality_decl && !dwarf2out_do_cfi_asm ())\n-\tlto_eh_personality_decl = first_personality_decl;\n-      else\n-\tlto_eh_personality_decl = lhd_gcc_personality ();\n-    }\n-\n-  return lto_eh_personality_decl;\n-}\n-\n-/* Set the process name based on the LTO mode. */\n-\n-static void \n-lto_process_name (void)\n-{\n-  if (flag_lto)\n-    setproctitle (flag_incremental_link == INCREMENTAL_LINK_LTO\n-\t\t  ? \"lto1-inclink\" : \"lto1-lto\");\n-  if (flag_wpa)\n-    setproctitle (\"lto1-wpa\");\n-  if (flag_ltrans)\n-    setproctitle (\"lto1-ltrans\");\n-}\n-\n-\n-/* Initialize the LTO front end.  */\n-\n-static void\n-lto_init (void)\n-{\n-  lto_process_name ();\n-  lto_streamer_hooks_init ();\n-  lto_reader_init ();\n-  lto_set_in_hooks (NULL, get_section_data, free_section_data);\n-  memset (&lto_stats, 0, sizeof (lto_stats));\n-  bitmap_obstack_initialize (NULL);\n-  gimple_register_cfg_hooks ();\n-#ifndef ACCEL_COMPILER\n-  unsigned char *table\n-    = ggc_vec_alloc<unsigned char> (MAX_MACHINE_MODE);\n-  for (int m = 0; m < MAX_MACHINE_MODE; m++)\n-    table[m] = m;\n-  lto_mode_identity_table = table;\n-#endif\n-}\n-\n /* Create artificial pointers for \"omp declare target link\" vars.  */\n \n static void\n@@ -3342,7 +560,6 @@ offload_handle_link_vars (void)\n #endif\n }\n \n-\n /* Main entry point for the GIMPLE front end.  This front end has\n    three main personalities:\n \n@@ -3377,7 +594,7 @@ lto_main (void)\n   timevar_start (TV_PHASE_SETUP);\n \n   /* Initialize the LTO front end.  */\n-  lto_init ();\n+  lto_fe_init ();\n \n   timevar_stop (TV_PHASE_SETUP);\n   timevar_start (TV_PHASE_STREAM_IN);\n@@ -3430,5 +647,3 @@ lto_main (void)\n   timevar_start (TV_PHASE_PARSING);\n   timevar_push (TV_PARSE_GLOBAL);\n }\n-\n-#include \"gt-lto-lto.h\""}]}