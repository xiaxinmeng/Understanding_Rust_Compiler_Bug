{"sha": "d1b5f5cc3cfd148e8c479a7c05928e0289ccfadc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFiNWY1Y2MzY2ZkMTQ4ZThjNDc5YTdjMDU5MjhlMDI4OWNjZmFkYw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2017-05-03T13:11:21Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-05-03T13:11:21Z"}, "message": "New fix-it printer\n\nThe existing fix-it printer can lead to difficult-to-read output\nwhen fix-it hints are near each other.  For example, in a recent\npatch to add fix-it hints to the C++ frontend's -Wold-style-cast,\ne.g. for:\n\n  foo *f = (foo *)ptr->field;\n                       ^~~~~\n\nthe fix-it hints:\n replace the open paren with \"const_cast<\"\n replace the close paren with \"> (\"\n insert \")\" after the \"ptr->field\"\n\nwould be printed in this odd-looking way:\n\n  foo *f = (foo *)ptr->field;\n                       ^~~~~\n           -\n           const_cast<\n                 -\n                 > (        )\n\nclass rich_location consolidates adjacent fix-it hints, which helps\nsomewhat, but the underlying problem is that the existing printer\nsimply walks through the list of hints printing them, starting newlines\nas necessary.\n\nThis patch reimplements fix-it printing by introducing a planning\nstage: a new class line_corrections \"plans\" how to print the\nfix-it hints affecting a line, generating a vec of \"correction\"\ninstances.  Hints that are sufficiently close to each other are\nconsolidated at this stage.\n\nThis leads to the much more reasonable output for the above case:\n\n  foo *f = (foo *)ptr->field;\n                       ^~~~~\n           -----------------\n           const_cast<foo *> (ptr->field);\n\nwhere the 3 hints are consolidated into one \"correction\" at printing.\n\ngcc/ChangeLog:\n\t* diagnostic-show-locus.c (struct column_range): New struct.\n\t(get_affected_columns): New function.\n\t(get_printed_columns): New function.\n\t(struct correction): New struct.\n\t(correction::ensure_capacity): New function.\n\t(correction::ensure_terminated): New function.\n\t(struct line_corrections): New struct.\n\t(line_corrections::~line_corrections): New dtor.\n\t(line_corrections::add_hint): New function.\n\t(layout::print_trailing_fixits): Reimplement in terms of the new\n\tclasses.\n\t(selftest::test_overlapped_fixit_printing): New function.\n\t(selftest::diagnostic_show_locus_c_tests): Call it.\n\nFrom-SVN: r247548", "tree": {"sha": "4d9a58d881b7cd4c1d8f046cd647dd9de26df3ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d9a58d881b7cd4c1d8f046cd647dd9de26df3ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1b5f5cc3cfd148e8c479a7c05928e0289ccfadc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1b5f5cc3cfd148e8c479a7c05928e0289ccfadc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1b5f5cc3cfd148e8c479a7c05928e0289ccfadc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1b5f5cc3cfd148e8c479a7c05928e0289ccfadc/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5bb64c4183643680e4a1b4ccfe920d48c248cb8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb64c4183643680e4a1b4ccfe920d48c248cb8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bb64c4183643680e4a1b4ccfe920d48c248cb8a"}], "stats": {"total": 588, "additions": 550, "deletions": 38}, "files": [{"sha": "dbd170cc47eab63041761bf4c6d41908abc04468", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1b5f5cc3cfd148e8c479a7c05928e0289ccfadc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1b5f5cc3cfd148e8c479a7c05928e0289ccfadc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1b5f5cc3cfd148e8c479a7c05928e0289ccfadc", "patch": "@@ -1,3 +1,19 @@\n+2017-05-03  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* diagnostic-show-locus.c (struct column_range): New struct.\n+\t(get_affected_columns): New function.\n+\t(get_printed_columns): New function.\n+\t(struct correction): New struct.\n+\t(correction::ensure_capacity): New function.\n+\t(correction::ensure_terminated): New function.\n+\t(struct line_corrections): New struct.\n+\t(line_corrections::~line_corrections): New dtor.\n+\t(line_corrections::add_hint): New function.\n+\t(layout::print_trailing_fixits): Reimplement in terms of the new\n+\tclasses.\n+\t(selftest::test_overlapped_fixit_printing): New function.\n+\t(selftest::diagnostic_show_locus_c_tests): Call it.\n+\n 2017-05-03  Nathan Sidwell  <nathan@acm.org>\n \n \tCanonicalize canonical type hashing"}, {"sha": "f410a324b4b7e631e8ee93dac603736d55a10c42", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 534, "deletions": 38, "changes": 572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1b5f5cc3cfd148e8c479a7c05928e0289ccfadc/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1b5f5cc3cfd148e8c479a7c05928e0289ccfadc/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=d1b5f5cc3cfd148e8c479a7c05928e0289ccfadc", "patch": "@@ -1242,6 +1242,295 @@ layout::annotation_line_showed_range_p (int line, int start_column,\n   return false;\n }\n \n+/* Classes for printing trailing fix-it hints i.e. those that\n+   don't add new lines.\n+\n+   For insertion, these can look like:\n+\n+     new_text\n+\n+   For replacement, these can look like:\n+\n+     ------------- : underline showing affected range\n+     new_text\n+\n+   For deletion, these can look like:\n+\n+     ------------- : underline showing affected range\n+\n+   This can become confusing if they overlap, and so we need\n+   to do some preprocessing to decide what to print.\n+   We use the list of fixit_hint instances affecting the line\n+   to build a list of \"correction\" instances, and print the\n+   latter.\n+\n+   For example, consider a set of fix-its for converting\n+   a C-style cast to a C++ const_cast.\n+\n+   Given:\n+\n+   ..000000000111111111122222222223333333333.\n+   ..123456789012345678901234567890123456789.\n+     foo *f = (foo *)ptr->field;\n+                          ^~~~~\n+\n+   and the fix-it hints:\n+     - replace col 10 (the open paren) with \"const_cast<\"\n+     - replace col 16 (the close paren) with \"> (\"\n+     - insert \")\" before col 27\n+\n+   then we would get odd-looking output:\n+\n+     foo *f = (foo *)ptr->field;\n+                          ^~~~~\n+              -\n+              const_cast<\n+                    -\n+                    > (        )\n+\n+   It would be better to detect when fixit hints are going to\n+   overlap (those that require new lines), and to consolidate\n+   the printing of such fixits, giving something like:\n+\n+     foo *f = (foo *)ptr->field;\n+                          ^~~~~\n+              -----------------\n+              const_cast<foo *> (ptr->field)\n+\n+   This works by detecting when the printing would overlap, and\n+   effectively injecting no-op replace hints into the gaps between\n+   such fix-its, so that the printing joins up.\n+\n+   In the above example, the overlap of:\n+     - replace col 10 (the open paren) with \"const_cast<\"\n+   and:\n+     - replace col 16 (the close paren) with \"> (\"\n+   is fixed by injecting a no-op:\n+     - replace cols 11-15 with themselves (\"foo *\")\n+   and consolidating these, making:\n+     - replace cols 10-16 with \"const_cast<\" + \"foo *\" + \"> (\"\n+   i.e.:\n+     - replace cols 10-16 with \"const_cast<foo *> (\"\n+\n+   This overlaps with the final fix-it hint:\n+     - insert \")\" before col 27\n+   and so we repeat the consolidation process, by injecting\n+   a no-op:\n+     - replace cols 17-26 with themselves (\"ptr->field\")\n+   giving:\n+     - replace cols 10-26 with \"const_cast<foo *> (\" + \"ptr->field\" + \")\"\n+   i.e.:\n+     - replace cols 10-26 with \"const_cast<foo *> (ptr->field)\"\n+\n+   and is thus printed as desired.  */\n+\n+/* A range of columns within a line.  */\n+\n+struct column_range\n+{\n+  column_range (int start_, int finish_) : start (start_), finish (finish_) {}\n+\n+  bool operator== (const column_range &other) const\n+  {\n+    return start == other.start && finish == other.finish;\n+  }\n+\n+  int start;\n+  int finish;\n+};\n+\n+/* Get the range of columns that HINT would affect.  */\n+\n+static column_range\n+get_affected_columns (const fixit_hint *hint)\n+{\n+  int start_column = LOCATION_COLUMN (hint->get_start_loc ());\n+  int finish_column = LOCATION_COLUMN (hint->get_next_loc ()) - 1;\n+\n+  return column_range (start_column, finish_column);\n+}\n+\n+/* Get the range of columns that would be printed for HINT.  */\n+\n+static column_range\n+get_printed_columns (const fixit_hint *hint)\n+{\n+  int start_column = LOCATION_COLUMN (hint->get_start_loc ());\n+  int final_hint_column = start_column + hint->get_length () - 1;\n+  if (hint->insertion_p ())\n+    {\n+      return column_range (start_column, final_hint_column);\n+    }\n+  else\n+    {\n+      int finish_column = LOCATION_COLUMN (hint->get_next_loc ()) - 1;\n+\n+      return column_range (start_column,\n+\t\t\t   MAX (finish_column, final_hint_column));\n+    }\n+}\n+\n+/* A correction on a particular line.\n+   This describes a plan for how to print one or more fixit_hint\n+   instances that affected the line, potentially consolidating hints\n+   into corrections to make the result easier for the user to read.  */\n+\n+struct correction\n+{\n+  correction (column_range affected_columns,\n+\t      column_range printed_columns,\n+\t      const char *new_text, size_t new_text_len)\n+  : m_affected_columns (affected_columns),\n+    m_printed_columns (printed_columns),\n+    m_text (xstrdup (new_text)),\n+    m_len (new_text_len),\n+    m_alloc_sz (new_text_len + 1)\n+  {\n+  }\n+\n+  ~correction () { free (m_text); }\n+\n+  bool insertion_p () const\n+  {\n+    return m_affected_columns.start == m_affected_columns.finish + 1;\n+  }\n+\n+  void ensure_capacity (size_t len);\n+  void ensure_terminated ();\n+\n+  /* If insert, then start: the column before which the text\n+     is to be inserted, and finish is offset by the length of\n+     the replacement.\n+     If replace, then the range of columns affected.  */\n+  column_range m_affected_columns;\n+\n+  /* If insert, then start: the column before which the text\n+     is to be inserted, and finish is offset by the length of\n+     the replacement.\n+     If replace, then the range of columns affected.  */\n+  column_range m_printed_columns;\n+\n+  /* The text to be inserted/used as replacement.  */\n+  char *m_text;\n+  size_t m_len;\n+  size_t m_alloc_sz;\n+};\n+\n+/* Ensure that m_text can hold a string of length LEN\n+   (plus 1 for 0-termination).  */\n+\n+void\n+correction::ensure_capacity (size_t len)\n+{\n+  /* Allow 1 extra byte for 0-termination.  */\n+  if (m_alloc_sz < (len + 1))\n+    {\n+      size_t new_alloc_sz = (len + 1) * 2;\n+      m_text = (char *)xrealloc (m_text, new_alloc_sz);\n+      m_alloc_sz = new_alloc_sz;\n+    }\n+}\n+\n+/* Ensure that m_text is 0-terminated.  */\n+\n+void\n+correction::ensure_terminated ()\n+{\n+  /* 0-terminate the buffer.  */\n+  gcc_assert (m_len < m_alloc_sz);\n+  m_text[m_len] = '\\0';\n+}\n+\n+/* A list of corrections affecting a particular line.\n+   This is used by layout::print_trailing_fixits for planning\n+   how to print the fix-it hints affecting the line.  */\n+\n+struct line_corrections\n+{\n+  line_corrections (const char *filename, int row)\n+  : m_filename (filename), m_row (row)\n+  {}\n+  ~line_corrections ();\n+\n+  void add_hint (const fixit_hint *hint);\n+\n+  const char *m_filename;\n+  int m_row;\n+  auto_vec <correction *> m_corrections;\n+};\n+\n+/* struct line_corrections.  */\n+\n+line_corrections::~line_corrections ()\n+{\n+  unsigned i;\n+  correction *c;\n+  FOR_EACH_VEC_ELT (m_corrections, i, c)\n+    delete c;\n+}\n+\n+/* Add HINT to the corrections for this line.\n+   Attempt to consolidate nearby hints so that they will not\n+   overlap with printed.  */\n+\n+void\n+line_corrections::add_hint (const fixit_hint *hint)\n+{\n+  column_range affected_columns = get_affected_columns (hint);\n+  column_range printed_columns = get_printed_columns (hint);\n+\n+  /* Potentially consolidate.  */\n+  if (!m_corrections.is_empty ())\n+    {\n+      correction *last_correction\n+\t= m_corrections[m_corrections.length () - 1];\n+      if (printed_columns.start <= last_correction->m_printed_columns.finish)\n+\t{\n+\t  /* We have two hints for which the printed forms of the hints\n+\t     would touch or overlap, so we need to consolidate them to avoid\n+\t     confusing the user.\n+\t     Attempt to inject a \"replace\" correction from immediately\n+\t     after the end of the last hint to immediately before the start\n+\t     of the next hint.  */\n+\t  column_range between (last_correction->m_affected_columns.finish + 1,\n+\t\t\t\tprinted_columns.start - 1);\n+\n+\t  /* Try to read the source.  */\n+\t  int line_width;\n+\t  const char *line = location_get_source_line (m_filename, m_row,\n+\t\t\t\t\t\t       &line_width);\n+\t  if (line && between.finish < line_width)\n+\t    {\n+\t      /* Consolidate into the last correction:\n+\t\t add a no-op \"replace\" of the \"between\" text, and\n+\t\t add the text from the new hint.  */\n+\t      size_t old_len = last_correction->m_len;\n+\t      size_t between_len = between.finish + 1 - between.start;\n+\t      size_t new_len = old_len + between_len + hint->get_length ();\n+\t      last_correction->ensure_capacity (new_len);\n+\t      memcpy (last_correction->m_text + old_len,\n+\t\t      line + between.start - 1,\n+\t\t      between.finish + 1 - between.start);\n+\t      memcpy (last_correction->m_text + old_len + between_len,\n+\t\t      hint->get_string (), hint->get_length ());\n+\t      last_correction->m_len = new_len;\n+\t      last_correction->ensure_terminated ();\n+\t      last_correction->m_affected_columns.finish\n+\t\t= affected_columns.finish;\n+\t      last_correction->m_printed_columns.finish\n+\t\t+= between_len + hint->get_length ();\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n+  /* If no consolidation happened, add a new correction instance.  */\n+  m_corrections.safe_push (new correction (affected_columns,\n+\t\t\t\t\t   printed_columns,\n+\t\t\t\t\t   hint->get_string (),\n+\t\t\t\t\t   hint->get_length ()));\n+}\n+\n /* If there are any fixit hints on source line ROW, print them.\n    They are printed in order, attempting to combine them onto lines, but\n    starting new lines if necessary.\n@@ -1251,58 +1540,67 @@ layout::annotation_line_showed_range_p (int line, int start_column,\n void\n layout::print_trailing_fixits (int row)\n {\n-  int column = 0;\n+  /* Build a list of correction instances for the line,\n+     potentially consolidating hints (for the sake of readability).  */\n+  line_corrections corrections (m_exploc.file, row);\n   for (unsigned int i = 0; i < m_fixit_hints.length (); i++)\n     {\n       const fixit_hint *hint = m_fixit_hints[i];\n \n+      /* Newline fixits are handled by layout::print_leading_fixits.  */\n       if (hint->ends_with_newline_p ())\n \tcontinue;\n \n       if (hint->affects_line_p (m_exploc.file, row))\n+\tcorrections.add_hint (hint);\n+    }\n+\n+  /* Now print the corrections.  */\n+  unsigned i;\n+  correction *c;\n+  int column = 0;\n+\n+  FOR_EACH_VEC_ELT (corrections.m_corrections, i, c)\n+    {\n+      /* For now we assume each fixit hint can only touch one line.  */\n+      if (c->insertion_p ())\n+\t{\n+\t  /* This assumes the insertion just affects one line.  */\n+\t  int start_column = c->m_printed_columns.start;\n+\t  move_to_column (&column, start_column);\n+\t  m_colorizer.set_fixit_insert ();\n+\t  pp_string (m_pp, c->m_text);\n+\t  m_colorizer.set_normal_text ();\n+\t  column += c->m_len;\n+\t}\n+      else\n \t{\n-\t  /* For now we assume each fixit hint can only touch one line.  */\n-\t  if (hint->insertion_p ())\n+\t  /* If the range of the replacement wasn't printed in the\n+\t     annotation line, then print an extra underline to\n+\t     indicate exactly what is being replaced.\n+\t     Always show it for removals.  */\n+\t  int start_column = c->m_affected_columns.start;\n+\t  int finish_column = c->m_affected_columns.finish;\n+\t  if (!annotation_line_showed_range_p (row, start_column,\n+\t\t\t\t\t       finish_column)\n+\t      || c->m_len == 0)\n \t    {\n-\t      /* This assumes the insertion just affects one line.  */\n-\t      int start_column = LOCATION_COLUMN (hint->get_start_loc ());\n \t      move_to_column (&column, start_column);\n-\t      m_colorizer.set_fixit_insert ();\n-\t      pp_string (m_pp, hint->get_string ());\n+\t      m_colorizer.set_fixit_delete ();\n+\t      for (; column <= finish_column; column++)\n+\t\tpp_character (m_pp, '-');\n \t      m_colorizer.set_normal_text ();\n-\t      column += hint->get_length ();\n \t    }\n-\t  else\n+\t  /* Print the replacement text.  REPLACE also covers\n+\t     removals, so only do this extra work (potentially starting\n+\t     a new line) if we have actual replacement text.  */\n+\t  if (c->m_len > 0)\n \t    {\n-\t      int line = LOCATION_LINE (hint->get_start_loc ());\n-\t      int start_column = LOCATION_COLUMN (hint->get_start_loc ());\n-\t      int finish_column = LOCATION_COLUMN (hint->get_next_loc ()) - 1;\n-\n-\t      /* If the range of the replacement wasn't printed in the\n-\t\t annotation line, then print an extra underline to\n-\t\t indicate exactly what is being replaced.\n-\t\t Always show it for removals.  */\n-\t      if (!annotation_line_showed_range_p (line, start_column,\n-\t\t\t\t\t\t   finish_column)\n-\t\t  || hint->get_length () == 0)\n-\t\t{\n-\t\t  move_to_column (&column, start_column);\n-\t\t  m_colorizer.set_fixit_delete ();\n-\t\t  for (; column <= finish_column; column++)\n-\t\t    pp_character (m_pp, '-');\n-\t\t  m_colorizer.set_normal_text ();\n-\t\t}\n-\t      /* Print the replacement text.  REPLACE also covers\n-\t\t removals, so only do this extra work (potentially starting\n-\t\t a new line) if we have actual replacement text.  */\n-\t      if (hint->get_length () > 0)\n-\t\t{\n-\t\t  move_to_column (&column, start_column);\n-\t\t  m_colorizer.set_fixit_insert ();\n-\t\t  pp_string (m_pp, hint->get_string ());\n-\t\t  m_colorizer.set_normal_text ();\n-\t\t  column += hint->get_length ();\n-\t\t}\n+\t      move_to_column (&column, start_column);\n+\t      m_colorizer.set_fixit_insert ();\n+\t      pp_string (m_pp, c->m_text);\n+\t      m_colorizer.set_normal_text ();\n+\t      column += c->m_len;\n \t    }\n \t}\n     }\n@@ -2153,6 +2451,203 @@ test_fixit_consolidation (const line_table_case &case_)\n   }\n }\n \n+/* Verify that the line_corrections machinery correctly prints\n+   overlapping fixit-hints.  */\n+\n+static void\n+test_overlapped_fixit_printing (const line_table_case &case_)\n+{\n+  /* Create a tempfile and write some text to it.\n+     ...000000000111111111122222222223333333333.\n+     ...123456789012345678901234567890123456789.  */\n+  const char *content\n+    = (\"  foo *f = (foo *)ptr->field;\\n\");\n+  temp_source_file tmp (SELFTEST_LOCATION, \".C\", content);\n+  line_table_test ltt (case_);\n+\n+  const line_map_ordinary *ord_map\n+    = linemap_check_ordinary (linemap_add (line_table, LC_ENTER, false,\n+\t\t\t\t\t   tmp.get_filename (), 0));\n+\n+  linemap_line_start (line_table, 1, 100);\n+\n+  const location_t final_line_end\n+    = linemap_position_for_line_and_column (line_table, ord_map, 6, 36);\n+\n+  /* Don't attempt to run the tests if column data might be unavailable.  */\n+  if (final_line_end > LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    return;\n+\n+  /* A test for converting a C-style cast to a C++-style cast.  */\n+  const location_t open_paren\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 12);\n+  const location_t close_paren\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 18);\n+  const location_t expr_start\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 19);\n+  const location_t expr_finish\n+    = linemap_position_for_line_and_column (line_table, ord_map, 1, 28);\n+  const location_t expr = make_location (expr_start, expr_start, expr_finish);\n+\n+  /* Various examples of fix-it hints that aren't themselves consolidated,\n+     but for which the *printing* may need consolidation.  */\n+\n+  /* Example where 3 fix-it hints are printed as one.  */\n+  {\n+    test_diagnostic_context dc;\n+    rich_location richloc (line_table, expr);\n+    richloc.add_fixit_replace (open_paren, \"const_cast<\");\n+    richloc.add_fixit_replace (close_paren, \"> (\");\n+    richloc.add_fixit_insert_after (\")\");\n+\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \"   foo *f = (foo *)ptr->field;\\n\"\n+\t\t  \"                   ^~~~~~~~~~\\n\"\n+\t\t  \"            -----------------\\n\"\n+\t\t  \"            const_cast<foo *> (ptr->field)\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+\n+    /* Unit-test the line_corrections machinery.  */\n+    ASSERT_EQ (3, richloc.get_num_fixit_hints ());\n+    const fixit_hint *hint_0 = richloc.get_fixit_hint (0);\n+    ASSERT_EQ (column_range (12, 12), get_affected_columns (hint_0));\n+    ASSERT_EQ (column_range (12, 22), get_printed_columns (hint_0));\n+    const fixit_hint *hint_1 = richloc.get_fixit_hint (1);\n+    ASSERT_EQ (column_range (18, 18), get_affected_columns (hint_1));\n+    ASSERT_EQ (column_range (18, 20), get_printed_columns (hint_1));\n+    const fixit_hint *hint_2 = richloc.get_fixit_hint (2);\n+    ASSERT_EQ (column_range (29, 28), get_affected_columns (hint_2));\n+    ASSERT_EQ (column_range (29, 29), get_printed_columns (hint_2));\n+\n+    /* Add each hint in turn to a line_corrections instance,\n+       and verify that they are consolidated into one correction instance\n+       as expected.  */\n+    line_corrections lc (tmp.get_filename (), 1);\n+\n+    /* The first replace hint by itself.  */\n+    lc.add_hint (hint_0);\n+    ASSERT_EQ (1, lc.m_corrections.length ());\n+    ASSERT_EQ (column_range (12, 12), lc.m_corrections[0]->m_affected_columns);\n+    ASSERT_EQ (column_range (12, 22), lc.m_corrections[0]->m_printed_columns);\n+    ASSERT_STREQ (\"const_cast<\", lc.m_corrections[0]->m_text);\n+\n+    /* After the second replacement hint, they are printed together\n+       as a replacement (along with the text between them).  */\n+    lc.add_hint (hint_1);\n+    ASSERT_EQ (1, lc.m_corrections.length ());\n+    ASSERT_STREQ (\"const_cast<foo *> (\", lc.m_corrections[0]->m_text);\n+    ASSERT_EQ (column_range (12, 18), lc.m_corrections[0]->m_affected_columns);\n+    ASSERT_EQ (column_range (12, 30), lc.m_corrections[0]->m_printed_columns);\n+\n+    /* After the final insertion hint, they are all printed together\n+       as a replacement (along with the text between them).  */\n+    lc.add_hint (hint_2);\n+    ASSERT_STREQ (\"const_cast<foo *> (ptr->field)\",\n+\t\t  lc.m_corrections[0]->m_text);\n+    ASSERT_EQ (1, lc.m_corrections.length ());\n+    ASSERT_EQ (column_range (12, 28), lc.m_corrections[0]->m_affected_columns);\n+    ASSERT_EQ (column_range (12, 41), lc.m_corrections[0]->m_printed_columns);\n+  }\n+\n+  /* Example where two are consolidated during printing.  */\n+  {\n+    test_diagnostic_context dc;\n+    rich_location richloc (line_table, expr);\n+    richloc.add_fixit_replace (open_paren, \"CAST (\");\n+    richloc.add_fixit_replace (close_paren, \") (\");\n+    richloc.add_fixit_insert_after (\")\");\n+\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \"   foo *f = (foo *)ptr->field;\\n\"\n+\t\t  \"                   ^~~~~~~~~~\\n\"\n+\t\t  \"            -\\n\"\n+\t\t  \"            CAST (-\\n\"\n+\t\t  \"                  ) (        )\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+  /* Example where none are consolidated during printing.  */\n+  {\n+    test_diagnostic_context dc;\n+    rich_location richloc (line_table, expr);\n+    richloc.add_fixit_replace (open_paren, \"CST (\");\n+    richloc.add_fixit_replace (close_paren, \") (\");\n+    richloc.add_fixit_insert_after (\")\");\n+\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \"   foo *f = (foo *)ptr->field;\\n\"\n+\t\t  \"                   ^~~~~~~~~~\\n\"\n+\t\t  \"            -\\n\"\n+\t\t  \"            CST ( -\\n\"\n+\t\t  \"                  ) (        )\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+  /* Example of deletion fix-it hints.  */\n+  {\n+    test_diagnostic_context dc;\n+    rich_location richloc (line_table, expr);\n+    richloc.add_fixit_insert_before (open_paren, \"(bar *)\");\n+    source_range victim = {open_paren, close_paren};\n+    richloc.add_fixit_remove (victim);\n+\n+    /* This case is actually handled by fixit-consolidation,\n+       rather than by line_corrections.  */\n+    ASSERT_EQ (1, richloc.get_num_fixit_hints ());\n+\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \"   foo *f = (foo *)ptr->field;\\n\"\n+\t\t  \"                   ^~~~~~~~~~\\n\"\n+\t\t  \"            -------\\n\"\n+\t\t  \"            (bar *)\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+  /* Example of deletion fix-it hints that would overlap.  */\n+  {\n+    test_diagnostic_context dc;\n+    rich_location richloc (line_table, expr);\n+    richloc.add_fixit_insert_before (open_paren, \"(longer *)\");\n+    source_range victim = {expr_start, expr_finish};\n+    richloc.add_fixit_remove (victim);\n+\n+    /* These fixits are not consolidated.  */\n+    ASSERT_EQ (2, richloc.get_num_fixit_hints ());\n+\n+    /* But the corrections are.  */\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \"   foo *f = (foo *)ptr->field;\\n\"\n+\t\t  \"                   ^~~~~~~~~~\\n\"\n+\t\t  \"            -----------------\\n\"\n+\t\t  \"            (longer *)(foo *)\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+\n+  /* Example of insertion fix-it hints that would overlap.  */\n+  {\n+    test_diagnostic_context dc;\n+    rich_location richloc (line_table, expr);\n+    richloc.add_fixit_insert_before (open_paren, \"LONGER THAN THE CAST\");\n+    richloc.add_fixit_insert_after (close_paren, \"TEST\");\n+\n+    /* The first insertion is long enough that if printed naively,\n+       it would overlap with the second.\n+       Verify that they are printed as a single replacement.  */\n+    diagnostic_show_locus (&dc, &richloc, DK_ERROR);\n+    ASSERT_STREQ (\"\\n\"\n+\t\t  \"   foo *f = (foo *)ptr->field;\\n\"\n+\t\t  \"                   ^~~~~~~~~~\\n\"\n+\t\t  \"            -------\\n\"\n+\t\t  \"            LONGER THAN THE CAST(foo *)TEST\\n\",\n+\t\t  pp_formatted_text (dc.printer));\n+  }\n+}\n+\n /* Insertion fix-it hint: adding a \"break;\" on a line by itself.  */\n \n static void\n@@ -2314,6 +2809,7 @@ diagnostic_show_locus_c_tests ()\n   for_each_line_table_case (test_diagnostic_show_locus_one_liner);\n   for_each_line_table_case (test_diagnostic_show_locus_fixit_lines);\n   for_each_line_table_case (test_fixit_consolidation);\n+  for_each_line_table_case (test_overlapped_fixit_printing);\n   for_each_line_table_case (test_fixit_insert_containing_newline);\n   for_each_line_table_case (test_fixit_insert_containing_newline_2);\n   for_each_line_table_case (test_fixit_replace_containing_newline);"}]}