{"sha": "0772402279c0161fe41784911b52c77e12803c42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc3MjQwMjI3OWMwMTYxZmU0MTc4NDkxMWI1MmM3N2UxMjgwM2M0Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-09-02T18:32:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-09-02T18:32:49Z"}, "message": "gimplify.c (gimplify_compound_lval): Move \"stack\" varray out of GGC.\n\n\n\t* gimplify.c (gimplify_compound_lval): Move \"stack\" varray out of\n\tGGC.\n\n\t* ggc-page.c: include tree-flow.h.\n\t(extra_order_size_table): Add stmt_ann_d.\n\t(STAT_LABEL): Rename from ....\n\t(LABEL): ... this one.\n\t* Makefile.in (ggc-page.o): Add dependency.\n\n\t* ggc-common.c (ggc_force_collect): New global variable.\n\t(loc_description): Add fields \"freed\", \"collected\"\n\t(ptr_hash): New static hash\n\t(ptr_hash_entry): New structure.\n\t(hash_ptr,eq_ptr,ggc_prune_ptr): New static functions.\n\t(ggc_record_overhead): Take ptr argument, record it\n\t(ggc_prune_overhead_list, ggc_free_overhead): New functions.\n\t(cmp_statistics): Imrove sorting.\n\t(dump_ggc_loc_statistics): Output newly collected statistics\n\t* ggc-page.c (ggc_alloc): Update call of ggc_record_overhead\n\t(ggc_free): Call ggc_free_overhead.\n\t(ggc_collect): Force collection when asked to be forced.\n\t(ggc_collect): Call ggc_prune_overhead_list.\n\t* ggc.h (ggc_force_collect): Declare\n\t(ggc_record_overhead): Update prototype.\n\t(ggc_free_overhead, ggc_prune_overhead_list): Declare.\n\nFrom-SVN: r86974", "tree": {"sha": "6bf7983f3f95c6b710f8803d101e0114ac581cfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bf7983f3f95c6b710f8803d101e0114ac581cfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0772402279c0161fe41784911b52c77e12803c42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0772402279c0161fe41784911b52c77e12803c42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0772402279c0161fe41784911b52c77e12803c42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0772402279c0161fe41784911b52c77e12803c42/comments", "author": null, "committer": null, "parents": [{"sha": "35dc4c015a0b6e0558a892bbbcca2cc73e435f61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35dc4c015a0b6e0558a892bbbcca2cc73e435f61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35dc4c015a0b6e0558a892bbbcca2cc73e435f61"}], "stats": {"total": 204, "additions": 172, "deletions": 32}, "files": [{"sha": "80d593f4bc6ebdfb89737f7d544a0cd28c266c2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0772402279c0161fe41784911b52c77e12803c42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0772402279c0161fe41784911b52c77e12803c42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0772402279c0161fe41784911b52c77e12803c42", "patch": "@@ -1,3 +1,31 @@\n+2004-09-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gimplify.c (gimplify_compound_lval): Move \"stack\" varray out of\n+\tGGC.\n+\n+\t* ggc-page.c: include tree-flow.h.\n+\t(extra_order_size_table): Add stmt_ann_d.\n+\t(STAT_LABEL): Rename from ....\n+\t(LABEL): ... this one.\n+\t* Makefile.in (ggc-page.o): Add dependency.\n+\n+\t* ggc-common.c (ggc_force_collect): New global variable.\n+\t(loc_description): Add fields \"freed\", \"collected\"\n+\t(ptr_hash): New static hash\n+\t(ptr_hash_entry): New structure.\n+\t(hash_ptr,eq_ptr,ggc_prune_ptr): New static functions.\n+\t(ggc_record_overhead): Take ptr argument, record it\n+\t(ggc_prune_overhead_list, ggc_free_overhead): New functions.\n+\t(cmp_statistics): Imrove sorting.\n+\t(dump_ggc_loc_statistics): Output newly collected statistics\n+\t* ggc-page.c (ggc_alloc): Update call of ggc_record_overhead\n+\t(ggc_free): Call ggc_free_overhead.\n+\t(ggc_collect): Force collection when asked to be forced.\n+\t(ggc_collect): Call ggc_prune_overhead_list.\n+\t* ggc.h (ggc_force_collect): Declare\n+\t(ggc_record_overhead): Update prototype.\n+\t(ggc_free_overhead, ggc_prune_overhead_list): Declare.\n+\n 2004-09-02  James E Wilson  <wilson@specifixinc.com>\n \n \t* common.opt (ftrapping-math): Default to on."}, {"sha": "80af8c5c5361700876e30b02ea157d5a6e753ebf", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0772402279c0161fe41784911b52c77e12803c42/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0772402279c0161fe41784911b52c77e12803c42/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0772402279c0161fe41784911b52c77e12803c42", "patch": "@@ -1548,7 +1548,7 @@ ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H) \\\n \t$(HASHTAB_H) toplev.h $(PARAMS_H) hosthooks.h\n \n ggc-page.o: ggc-page.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n-\tflags.h toplev.h $(GGC_H) $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H)\n+\tflags.h toplev.h $(GGC_H) $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H) $(TREE_FLOW_H)\n \n ggc-zone.o: ggc-zone.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n \tflags.h toplev.h $(GGC_H) $(TIMEVAR_H) $(TM_P_H) $(PARAMS_H)"}, {"sha": "d2528c0eac21fe2f396f44783ffc631f55035978", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 108, "deletions": 15, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0772402279c0161fe41784911b52c77e12803c42/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0772402279c0161fe41784911b52c77e12803c42/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=0772402279c0161fe41784911b52c77e12803c42", "patch": "@@ -61,6 +61,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define VALGRIND_DISCARD(x)\n #endif\n \n+/* When set, ggc_collect will do collection.  */\n+bool ggc_force_collect;\n+\n /* Statistics about the allocation.  */\n static ggc_statistics *ggc_stats;\n \n@@ -780,6 +783,8 @@ struct loc_descriptor\n   int times;\n   size_t allocated;\n   size_t overhead;\n+  size_t freed;\n+  size_t collected;\n };\n \n /* Hashtable used for statistics.  */\n@@ -804,6 +809,32 @@ eq_descriptor (const void *p1, const void *p2)\n \t  && d->function == d2->function);\n }\n \n+/* Hashtable converting address of allocated field to loc descriptor.  */\n+static htab_t ptr_hash;\n+struct ptr_hash_entry\n+{\n+  void *ptr;\n+  struct loc_descriptor *loc;\n+  size_t size;\n+};\n+\n+/* Hash table helpers functions.  */\n+static hashval_t\n+hash_ptr (const void *p)\n+{\n+  const struct ptr_hash_entry *d = p;\n+\n+  return htab_hash_pointer (d->ptr);\n+}\n+\n+static int\n+eq_ptr (const void *p1, const void *p2)\n+{\n+  const struct ptr_hash_entry *p = p1;\n+\n+  return (p->ptr == p2);\n+}\n+\n /* Return descriptor for given call site, create new one if needed.  */\n static struct loc_descriptor *\n loc_descriptor (const char *name, int line, const char *function)\n@@ -829,23 +860,70 @@ loc_descriptor (const char *name, int line, const char *function)\n \n /* Record ALLOCATED and OVERHEAD bytes to descriptor NAME:LINE (FUNCTION).  */\n void\n-ggc_record_overhead (size_t allocated, size_t overhead,\n+ggc_record_overhead (size_t allocated, size_t overhead, void *ptr,\n \t\t     const char *name, int line, const char *function)\n {\n   struct loc_descriptor *loc = loc_descriptor (name, line, function);\n+  struct ptr_hash_entry *p = xmalloc (sizeof (struct ptr_hash_entry));\n+  PTR *slot;\n+\n+  p->ptr = ptr;\n+  p->loc = loc;\n+  p->size = allocated + overhead;\n+  if (!ptr_hash)\n+    ptr_hash = htab_create (10, hash_ptr, eq_ptr, NULL);\n+  slot = htab_find_slot_with_hash (ptr_hash, ptr, htab_hash_pointer (ptr), INSERT);\n+  if (*slot)\n+    abort ();\n+  *slot = p;\n \n   loc->times++;\n   loc->allocated+=allocated;\n   loc->overhead+=overhead;\n }\n \n+/* Helper function for prune_overhead_list.  See if SLOT is still marked and\n+   remove it from hashtable if it is not.  */\n+static int\n+ggc_prune_ptr (void **slot, void *b ATTRIBUTE_UNUSED)\n+{\n+  struct ptr_hash_entry *p = *slot;\n+  if (!ggc_marked_p (p->ptr))\n+    {\n+      p->loc->collected += p->size;\n+      htab_clear_slot (ptr_hash, slot);\n+      free (p);\n+    }\n+  return 1;\n+}\n+\n+/* After live values has been marked, walk all recorded pointers and see if\n+   they are still live.  */\n+void\n+ggc_prune_overhead_list (void)\n+{\n+  htab_traverse (ptr_hash, ggc_prune_ptr, NULL);\n+}\n+\n+/* Notice that the pointer has been freed.  */\n+void ggc_free_overhead (void *ptr)\n+{\n+  PTR *slot = htab_find_slot_with_hash (ptr_hash, ptr, htab_hash_pointer (ptr),\n+\t\t\t\t\tNO_INSERT);\n+  struct ptr_hash_entry *p = *slot;\n+  p->loc->freed += p->size;\n+  htab_clear_slot (ptr_hash, slot);\n+  free (p);\n+}\n+\n /* Helper for qsort; sort descriptors by amount of memory consumed.  */\n static int\n cmp_statistic (const void *loc1, const void *loc2)\n {\n   struct loc_descriptor *l1 = *(struct loc_descriptor **) loc1;\n   struct loc_descriptor *l2 = *(struct loc_descriptor **) loc2;\n-  return (l1->allocated + l1->overhead) - (l2->allocated + l2->overhead);\n+  return ((l1->allocated + l1->overhead - l1->freed) -\n+\t  (l2->allocated + l2->overhead - l1->freed));\n }\n \n /* Collect array of the descriptors from hashtable.  */\n@@ -866,24 +944,26 @@ void dump_ggc_loc_statistics (void)\n #ifdef GATHER_STATISTICS\n   int nentries = 0;\n   char s[4096];\n-  size_t count, size, overhead;\n+  size_t collected = 0, freed = 0, allocated = 0, overhead = 0, times = 0;\n   int i;\n \n+  ggc_force_collect = true;\n+  ggc_collect ();\n+\n   loc_array = xcalloc (sizeof (*loc_array), loc_hash->n_elements);\n   fprintf (stderr, \"-------------------------------------------------------\\n\");\n-  fprintf (stderr, \"\\n%-60s %10s %10s %10s\\n\",\n-\t   \"source location\", \"Times\", \"Allocated\", \"Overhead\");\n+  fprintf (stderr, \"\\n%-48s %10s       %10s       %10s       %10s       %10s\\n\",\n+\t   \"source location\", \"Garbage\", \"Freed\", \"Leak\", \"Overhead\", \"Times\");\n   fprintf (stderr, \"-------------------------------------------------------\\n\");\n-  count = 0;\n-  size = 0;\n-  overhead = 0;\n   htab_traverse (loc_hash, add_statistics, &nentries);\n   qsort (loc_array, nentries, sizeof (*loc_array), cmp_statistic);\n   for (i = 0; i < nentries; i++)\n     {\n       struct loc_descriptor *d = loc_array[i];\n-      size += d->allocated;\n-      count += d->times;\n+      allocated += d->allocated;\n+      times += d->times;\n+      freed += d->freed;\n+      collected += d->collected;\n       overhead += d->overhead;\n     }\n   for (i = 0; i < nentries; i++)\n@@ -896,13 +976,26 @@ void dump_ggc_loc_statistics (void)\n \t  while ((s2 = strstr (s1, \"gcc/\")))\n \t    s1 = s2 + 4;\n \t  sprintf (s, \"%s:%i (%s)\", s1, d->line, d->function);\n-\t  fprintf (stderr, \"%-60s %10i %10li %10li:%.3f%%\\n\", s,\n-\t\t   d->times, (long)d->allocated, (long)d->overhead,\n-\t\t   (d->allocated + d->overhead) *100.0 / (size + overhead));\n+\t  s[48] = 0;\n+\t  fprintf (stderr, \"%-48s %10li:%4.1f%% %10li:%4.1f%% %10li:%4.1f%% %10li:%4.1f%% %10li\\n\", s,\n+\t\t   (long)d->collected,\n+\t\t   (d->collected) * 100.0 / collected,\n+\t\t   (long)d->freed,\n+\t\t   (d->freed) * 100.0 / freed,\n+\t\t   (long)(d->allocated + d->overhead - d->freed - d->collected),\n+\t\t   (d->allocated + d->overhead - d->freed - d->collected) * 100.0\n+\t\t   / (allocated + overhead - freed - collected),\n+\t\t   (long)d->overhead,\n+\t\t   d->overhead * 100.0 / overhead,\n+\t\t   (long)d->times);\n \t}\n     }\n-  fprintf (stderr, \"%-60s %10ld %10ld %10ld\\n\",\n-\t   \"Total\", (long)count, (long)size, (long)overhead);\n+  fprintf (stderr, \"%-48s %10ld       %10ld       %10ld       %10ld       %10ld\\n\",\n+\t   \"Total\", (long)collected, (long)freed,\n+\t   (long)(allocated + overhead - freed - collected), (long)overhead,\n+\t   (long)times);\n+  fprintf (stderr, \"%-48s %10s       %10s       %10s       %10s       %10s\\n\",\n+\t   \"source location\", \"Garbage\", \"Freed\", \"Leak\", \"Overhead\", \"Times\");\n   fprintf (stderr, \"-------------------------------------------------------\\n\");\n #endif\n }"}, {"sha": "578faf67ce3ed02d17f2325a7670052e1c5a5389", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0772402279c0161fe41784911b52c77e12803c42/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0772402279c0161fe41784911b52c77e12803c42/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=0772402279c0161fe41784911b52c77e12803c42", "patch": "@@ -31,6 +31,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"timevar.h\"\n #include \"params.h\"\n+#include \"tree-flow.h\"\n #ifdef ENABLE_VALGRIND_CHECKING\n # ifdef HAVE_VALGRIND_MEMCHECK_H\n #  include <valgrind/memcheck.h>\n@@ -184,6 +185,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    thing you need to do to add a new special allocation size.  */\n \n static const size_t extra_order_size_table[] = {\n+  sizeof (struct stmt_ann_d),\n   sizeof (struct tree_decl),\n   sizeof (struct tree_list),\n   TREE_EXP_SIZE (2),\n@@ -1173,12 +1175,13 @@ ggc_alloc_stat (size_t size MEM_STAT_DECL)\n       G.page_tails[order]->next = entry;\n       G.page_tails[order] = entry;\n     }\n-#ifdef GATHER_STATISTICS\n-  ggc_record_overhead (OBJECT_SIZE (order), OBJECT_SIZE (order) - size PASS_MEM_STAT);\n-#endif\n \n   /* Calculate the object's address.  */\n   result = entry->page + object_offset;\n+#ifdef GATHER_STATISTICS\n+  ggc_record_overhead (OBJECT_SIZE (order), OBJECT_SIZE (order) - size,\n+\t\t       result PASS_MEM_STAT);\n+#endif\n \n #ifdef ENABLE_GC_CHECKING\n   /* Keep poisoning-by-writing-0xaf the object, in an attempt to keep the\n@@ -1327,6 +1330,10 @@ ggc_free (void *p)\n   size_t order = pe->order;\n   size_t size = OBJECT_SIZE (order);\n \n+#ifdef GATHER_STATISTICS\n+  ggc_free_overhead (p);\n+#endif\n+\n   if (GGC_DEBUG_LEVEL >= 3)\n     fprintf (G.debug_file,\n \t     \"Freeing object, actual size=%lu, at %p on %p\\n\",\n@@ -1971,7 +1978,7 @@ ggc_collect (void)\n \n   float min_expand = allocated_last_gc * PARAM_VALUE (GGC_MIN_EXPAND) / 100;\n \n-  if (G.allocated < allocated_last_gc + min_expand)\n+  if (G.allocated < allocated_last_gc + min_expand && !ggc_force_collect)\n     return;\n \n   timevar_push (TV_GC);\n@@ -1993,6 +2000,9 @@ ggc_collect (void)\n \n   clear_marks ();\n   ggc_mark_roots ();\n+#ifdef GATHER_STATISTICS\n+  ggc_prune_overhead_list ();\n+#endif\n   poison_pages ();\n   validate_free_objects ();\n   sweep_pages ();\n@@ -2013,7 +2023,7 @@ ggc_collect (void)\n \t\t  : ((x) < 1024*1024*10 \\\n \t\t     ? (x) / 1024 \\\n \t\t     : (x) / (1024*1024))))\n-#define LABEL(x) ((x) < 1024*10 ? ' ' : ((x) < 1024*1024*10 ? 'k' : 'M'))\n+#define STAT_LABEL(x) ((x) < 1024*10 ? ' ' : ((x) < 1024*1024*10 ? 'k' : 'M'))\n \n void\n ggc_print_statistics (void)\n@@ -2068,15 +2078,15 @@ ggc_print_statistics (void)\n \t}\n       fprintf (stderr, \"%-5lu %10lu%c %10lu%c %10lu%c\\n\",\n \t       (unsigned long) OBJECT_SIZE (i),\n-\t       SCALE (allocated), LABEL (allocated),\n-\t       SCALE (in_use), LABEL (in_use),\n-\t       SCALE (overhead), LABEL (overhead));\n+\t       SCALE (allocated), STAT_LABEL (allocated),\n+\t       SCALE (in_use), STAT_LABEL (in_use),\n+\t       SCALE (overhead), STAT_LABEL (overhead));\n       total_overhead += overhead;\n     }\n   fprintf (stderr, \"%-5s %10lu%c %10lu%c %10lu%c\\n\", \"Total\",\n-\t   SCALE (G.bytes_mapped), LABEL (G.bytes_mapped),\n-\t   SCALE (G.allocated), LABEL(G.allocated),\n-\t   SCALE (total_overhead), LABEL (total_overhead));\n+\t   SCALE (G.bytes_mapped), STAT_LABEL (G.bytes_mapped),\n+\t   SCALE (G.allocated), STAT_LABEL(G.allocated),\n+\t   SCALE (total_overhead), STAT_LABEL (total_overhead));\n \n #ifdef GATHER_STATISTICS  \n   {"}, {"sha": "bdaba2687c8975724e790a36ae91033e550889a4", "filename": "gcc/ggc.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0772402279c0161fe41784911b52c77e12803c42/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0772402279c0161fe41784911b52c77e12803c42/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=0772402279c0161fe41784911b52c77e12803c42", "patch": "@@ -209,6 +209,8 @@ extern struct alloc_zone *garbage_zone;\n extern struct alloc_zone *rtl_zone;\n /* For regular tree allocations.  */\n extern struct alloc_zone *tree_zone;\n+/* When set, ggc_collect will do collection.  */\n+extern bool ggc_force_collect;\n \n /* The internal primitive.  */\n extern void *ggc_alloc_stat (size_t MEM_STAT_DECL);\n@@ -233,7 +235,9 @@ extern void *ggc_calloc (size_t, size_t);\n /* Free a block.  To be used when known for certain it's not reachable.  */\n extern void ggc_free (void *);\n  \n-extern void ggc_record_overhead (size_t, size_t MEM_STAT_DECL);\n+extern void ggc_record_overhead (size_t, size_t, void * MEM_STAT_DECL);\n+extern void ggc_free_overhead (void *);\n+extern void ggc_prune_overhead_list (void);\n \n extern void dump_ggc_loc_statistics (void);\n "}, {"sha": "1ba8cad025f8142c19d812a1d1abd15767a92c82", "filename": "gcc/gimplify.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0772402279c0161fe41784911b52c77e12803c42/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0772402279c0161fe41784911b52c77e12803c42/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=0772402279c0161fe41784911b52c77e12803c42", "patch": "@@ -1466,16 +1466,19 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n   int i;\n \n   /* Create a stack of the subexpressions so later we can walk them in\n-     order from inner to outer.  */\n-  VARRAY_TREE_INIT (stack, 10, \"stack\");\n+     order from inner to outer.  \n+\n+     This array is very memory consuming.  Don't even think of making\n+     it VARRAY_TREE.  */\n+  VARRAY_GENERIC_PTR_NOGC_INIT (stack, 10, \"stack\");\n \n   /* We can either handle REALPART_EXPR, IMAGEPART_EXPR anything that\n      handled_components can deal with.  */\n   for (p = expr_p;\n        (handled_component_p (*p)\n \t|| TREE_CODE (*p) == REALPART_EXPR || TREE_CODE (*p) == IMAGPART_EXPR);\n        p = &TREE_OPERAND (*p, 0))\n-    VARRAY_PUSH_TREE (stack, *p);\n+    VARRAY_PUSH_GENERIC_PTR_NOGC (stack, *p);\n \n #if defined ENABLE_CHECKING\n   if (VARRAY_ACTIVE_SIZE (stack) == 0)\n@@ -1496,7 +1499,7 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n      then we gimplify any indices, from left to right.  */\n   for (i = VARRAY_ACTIVE_SIZE (stack) - 1; i >= 0; i--)\n     {\n-      tree t = VARRAY_TREE (stack, i);\n+      tree t = VARRAY_GENERIC_PTR_NOGC (stack, i);\n \n       if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n \t{\n@@ -1615,6 +1618,8 @@ gimplify_compound_lval (tree *expr_p, tree *pre_p,\n       ret = MIN (ret, GS_OK);\n     }\n \n+  VARRAY_FREE (stack);\n+\n   return ret;\n }\n "}]}