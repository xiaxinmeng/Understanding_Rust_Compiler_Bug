{"sha": "705bae2351a870dc3ff59db47fa0de6baaf829c8", "node_id": "C_kwDOANBUbNoAKDcwNWJhZTIzNTFhODcwZGMzZmY1OWRiNDdmYTBkZTZiYWFmODI5Yzg", "commit": {"author": {"name": "mtsamis", "email": "manolis.tsamis@vrull.eu", "date": "2022-08-24T13:22:58Z"}, "committer": {"name": "Philipp Tomsich", "email": "philipp.tomsich@vrull.eu", "date": "2022-11-17T11:59:06Z"}, "message": "Enable shrink wrapping for the RISC-V target.\n\nThis commit implements the target macros (TARGET_SHRINK_WRAP_*) that\nenable separate shrink wrapping for function prologues/epilogues in\nRISC-V.\n\nTested against SPEC CPU 2017, this change always has a net-positive\neffect on the dynamic instruction count.  See the following table for\nthe breakdown on how this reduces the number of dynamic instructions\nper workload on a like-for-like (i.e., same config file; suppressing\nshrink-wrapping with -fno-shrink-wrap):\n\n                             # dynamic instructions\n                w/o shrink-wrap   w/ shrink-wrap      reduction\n500.perlbench_r   1265716786593    1262156218578     3560568015   0.28%\n500.perlbench_r    779224795689     765337009025    13887786664   1.78%\n500.perlbench_r    724087331471     711307152522    12780178949   1.77%\n502.gcc_r          204259864844     194517006339     9742858505   4.77%\n502.gcc_r          244047794302     231555834722    12491959580   5.12%\n502.gcc_r          230896069400     221877703011     9018366389   3.91%\n502.gcc_r          192130616624     183856450605     8274166019   4.31%\n502.gcc_r          258875074079     247756203226    11118870853   4.30%\n505.mcf_r          662653430325     660678680547     1974749778   0.30%\n520.omnetpp_r      985114167068     934191310154    50922856914   5.17%\n523.xalancbmk_r    927037633578     921688937650     5348695928   0.58%\n525.x264_r         490953958454     490565583447      388375007   0.08%\n525.x264_r        1994662294421    1993171932425     1490361996   0.07%\n525.x264_r        1897617120450    1896062750609     1554369841   0.08%\n531.deepsjeng_r   1695189878907    1669304130411    25885748496   1.53%\n541.leela_r       1925941222222    1897900861198    28040361024   1.46%\n548.exchange2_r   2073816227944    2073816226729           1215   0.00%\n557.xz_r           379572090003     379057409041      514680962   0.14%\n557.xz_r           953117469352     952680431430      437037922   0.05%\n557.xz_r           536859579650     536456690164      402889486   0.08%\n                 18421773405376   18223938521833   197834883543   1.07%  totals\n\nSigned-off-by: Manolis Tsamis <manolis.tsamis@vrull.eu>\n\ngcc/ChangeLog:\n\n\t* config/riscv/riscv.cc (struct machine_function): Add array to store\n\tregister wrapping information.\n\t(riscv_for_each_saved_reg): Skip registers that are wrapped separetely.\n\t(riscv_get_separate_components): New function.\n\t(riscv_components_for_bb): Likewise.\n\t(riscv_disqualify_components): Likewise.\n\t(riscv_process_components): Likewise.\n\t(riscv_emit_prologue_components): Likewise.\n\t(riscv_emit_epilogue_components): Likewise.\n\t(riscv_set_handled_components): Likewise.\n\t(TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS): Define.\n\t(TARGET_SHRINK_WRAP_COMPONENTS_FOR_BB): Likewise.\n\t(TARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS): Likewise.\n\t(TARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS): Likewise.\n\t(TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS): Likewise.\n\t(TARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/riscv/shrink-wrap-1.c: New test.", "tree": {"sha": "a1fa191fefe5fa9e0f0469e122f569f4ecb16189", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1fa191fefe5fa9e0f0469e122f569f4ecb16189"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/705bae2351a870dc3ff59db47fa0de6baaf829c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/705bae2351a870dc3ff59db47fa0de6baaf829c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/705bae2351a870dc3ff59db47fa0de6baaf829c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/705bae2351a870dc3ff59db47fa0de6baaf829c8/comments", "author": null, "committer": {"login": "ptomsich", "id": 14983582, "node_id": "MDQ6VXNlcjE0OTgzNTgy", "avatar_url": "https://avatars.githubusercontent.com/u/14983582?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptomsich", "html_url": "https://github.com/ptomsich", "followers_url": "https://api.github.com/users/ptomsich/followers", "following_url": "https://api.github.com/users/ptomsich/following{/other_user}", "gists_url": "https://api.github.com/users/ptomsich/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptomsich/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptomsich/subscriptions", "organizations_url": "https://api.github.com/users/ptomsich/orgs", "repos_url": "https://api.github.com/users/ptomsich/repos", "events_url": "https://api.github.com/users/ptomsich/events{/privacy}", "received_events_url": "https://api.github.com/users/ptomsich/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06c8f2ebf062f64e8f4228ec47bdd003df9ef5ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c8f2ebf062f64e8f4228ec47bdd003df9ef5ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06c8f2ebf062f64e8f4228ec47bdd003df9ef5ed"}], "stats": {"total": 217, "additions": 215, "deletions": 2}, "files": [{"sha": "d459851450c4ed495b9aa83bffbf153c942ae4cb", "filename": "gcc/config/riscv/riscv.cc", "status": "modified", "additions": 191, "deletions": 2, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/705bae2351a870dc3ff59db47fa0de6baaf829c8/gcc%2Fconfig%2Friscv%2Friscv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/705bae2351a870dc3ff59db47fa0de6baaf829c8/gcc%2Fconfig%2Friscv%2Friscv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.cc?ref=705bae2351a870dc3ff59db47fa0de6baaf829c8", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"target.h\"\n+#include \"backend.h\"\n #include \"tm.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n@@ -51,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"optabs.h\"\n #include \"bitmap.h\"\n #include \"df.h\"\n+#include \"function-abi.h\"\n #include \"diagnostic.h\"\n #include \"builtins.h\"\n #include \"predict.h\"\n@@ -154,6 +156,11 @@ struct GTY(())  machine_function {\n \n   /* The current frame information, calculated by riscv_compute_frame_info.  */\n   struct riscv_frame_info frame;\n+\n+  /* The components already handled by separate shrink-wrapping, which should\n+     not be considered by the prologue and epilogue.  */\n+  bool reg_is_wrapped_separately[FIRST_PSEUDO_REGISTER];\n+\n };\n \n /* Information about a single argument.  */\n@@ -4806,7 +4813,7 @@ riscv_for_each_saved_reg (poly_int64 sp_offset, riscv_save_restore_fn fn,\n   for (unsigned int regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n     if (BITSET_P (cfun->machine->frame.mask, regno - GP_REG_FIRST))\n       {\n-\tbool handle_reg = TRUE;\n+\tbool handle_reg = !cfun->machine->reg_is_wrapped_separately[regno];\n \n \t/* If this is a normal return in a function that calls the eh_return\n \t   builtin, then do not restore the eh return data registers as that\n@@ -4837,9 +4844,11 @@ riscv_for_each_saved_reg (poly_int64 sp_offset, riscv_save_restore_fn fn,\n   for (unsigned int regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno++)\n     if (BITSET_P (cfun->machine->frame.fmask, regno - FP_REG_FIRST))\n       {\n+\tbool handle_reg = !cfun->machine->reg_is_wrapped_separately[regno];\n \tmachine_mode mode = TARGET_DOUBLE_FLOAT ? DFmode : SFmode;\n \n-\triscv_save_restore_reg (mode, regno, offset, fn);\n+\tif (handle_reg)\n+\t  riscv_save_restore_reg (mode, regno, offset, fn);\n \toffset -= GET_MODE_SIZE (mode).to_constant ();\n       }\n }\n@@ -5321,6 +5330,162 @@ riscv_epilogue_uses (unsigned int regno)\n   return false;\n }\n \n+/* Implement TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS.  */\n+\n+static sbitmap\n+riscv_get_separate_components (void)\n+{\n+  HOST_WIDE_INT offset;\n+  sbitmap components = sbitmap_alloc (FIRST_PSEUDO_REGISTER);\n+  bitmap_clear (components);\n+\n+  if (riscv_use_save_libcall (&cfun->machine->frame)\n+      || cfun->machine->interrupt_handler_p)\n+    return components;\n+\n+  offset = cfun->machine->frame.gp_sp_offset.to_constant ();\n+  for (unsigned int regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n+    if (BITSET_P (cfun->machine->frame.mask, regno - GP_REG_FIRST))\n+      {\n+\t/* We can only wrap registers that have small operand offsets.\n+\t   For large offsets a pseudo register might be needed which\n+\t   cannot be created during the shrink wrapping pass.  */\n+\tif (SMALL_OPERAND (offset))\n+\t  bitmap_set_bit (components, regno);\n+\n+\toffset -= UNITS_PER_WORD;\n+      }\n+\n+  offset = cfun->machine->frame.fp_sp_offset.to_constant ();\n+  for (unsigned int regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno++)\n+    if (BITSET_P (cfun->machine->frame.fmask, regno - FP_REG_FIRST))\n+      {\n+\tmachine_mode mode = TARGET_DOUBLE_FLOAT ? DFmode : SFmode;\n+\n+\t/* We can only wrap registers that have small operand offsets.\n+\t   For large offsets a pseudo register might be needed which\n+\t   cannot be created during the shrink wrapping pass.  */\n+\tif (SMALL_OPERAND (offset))\n+\t  bitmap_set_bit (components, regno);\n+\n+\toffset -= GET_MODE_SIZE (mode).to_constant ();\n+      }\n+\n+  /* Don't mess with the hard frame pointer.  */\n+  if (frame_pointer_needed)\n+    bitmap_clear_bit (components, HARD_FRAME_POINTER_REGNUM);\n+\n+  bitmap_clear_bit (components, RETURN_ADDR_REGNUM);\n+\n+  return components;\n+}\n+\n+/* Implement TARGET_SHRINK_WRAP_COMPONENTS_FOR_BB.  */\n+\n+static sbitmap\n+riscv_components_for_bb (basic_block bb)\n+{\n+  bitmap in = DF_LIVE_IN (bb);\n+  bitmap gen = &DF_LIVE_BB_INFO (bb)->gen;\n+  bitmap kill = &DF_LIVE_BB_INFO (bb)->kill;\n+\n+  sbitmap components = sbitmap_alloc (FIRST_PSEUDO_REGISTER);\n+  bitmap_clear (components);\n+\n+  function_abi_aggregator callee_abis;\n+  rtx_insn *insn;\n+  FOR_BB_INSNS (bb, insn)\n+    if (CALL_P (insn))\n+      callee_abis.note_callee_abi (insn_callee_abi (insn));\n+  HARD_REG_SET extra_caller_saves = callee_abis.caller_save_regs (*crtl->abi);\n+\n+  /* GPRs are used in a bb if they are in the IN, GEN, or KILL sets.  */\n+  for (unsigned int regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n+    if (!fixed_regs[regno]\n+       && !crtl->abi->clobbers_full_reg_p (regno)\n+       && (TEST_HARD_REG_BIT (extra_caller_saves, regno)\n+\t   || bitmap_bit_p (in, regno)\n+\t   || bitmap_bit_p (gen, regno)\n+\t   || bitmap_bit_p (kill, regno)))\n+      bitmap_set_bit (components, regno);\n+\n+  for (unsigned int regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno++)\n+    if (!fixed_regs[regno]\n+       && !crtl->abi->clobbers_full_reg_p (regno)\n+       && (TEST_HARD_REG_BIT (extra_caller_saves, regno)\n+\t   || bitmap_bit_p (in, regno)\n+\t   || bitmap_bit_p (gen, regno)\n+\t   || bitmap_bit_p (kill, regno)))\n+      bitmap_set_bit (components, regno);\n+\n+  return components;\n+}\n+\n+/* Implement TARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS.  */\n+\n+static void\n+riscv_disqualify_components (sbitmap, edge, sbitmap, bool)\n+{\n+  /* Nothing to do for riscv.  */\n+}\n+\n+static void\n+riscv_process_components (sbitmap components, bool prologue_p)\n+{\n+  HOST_WIDE_INT offset;\n+  riscv_save_restore_fn fn = prologue_p? riscv_save_reg : riscv_restore_reg;\n+\n+  offset = cfun->machine->frame.gp_sp_offset.to_constant ();\n+  for (unsigned int regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n+    if (BITSET_P (cfun->machine->frame.mask, regno - GP_REG_FIRST))\n+      {\n+\tif (bitmap_bit_p (components, regno))\n+\t  riscv_save_restore_reg (word_mode, regno, offset, fn);\n+\n+\toffset -= UNITS_PER_WORD;\n+      }\n+\n+  offset = cfun->machine->frame.fp_sp_offset.to_constant ();\n+  for (unsigned int regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno++)\n+    if (BITSET_P (cfun->machine->frame.fmask, regno - FP_REG_FIRST))\n+      {\n+\tmachine_mode mode = TARGET_DOUBLE_FLOAT ? DFmode : SFmode;\n+\n+\tif (bitmap_bit_p (components, regno))\n+\t  riscv_save_restore_reg (mode, regno, offset, fn);\n+\n+\toffset -= GET_MODE_SIZE (mode).to_constant ();\n+      }\n+}\n+\n+/* Implement TARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS.  */\n+\n+static void\n+riscv_emit_prologue_components (sbitmap components)\n+{\n+  riscv_process_components (components, true);\n+}\n+\n+/* Implement TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS.  */\n+\n+static void\n+riscv_emit_epilogue_components (sbitmap components)\n+{\n+  riscv_process_components (components, false);\n+}\n+\n+static void\n+riscv_set_handled_components (sbitmap components)\n+{\n+  for (unsigned int regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n+    if (bitmap_bit_p (components, regno))\n+      cfun->machine->reg_is_wrapped_separately[regno] = true;\n+\n+  for (unsigned int regno = FP_REG_FIRST; regno <= FP_REG_LAST; regno++)\n+    if (bitmap_bit_p (components, regno))\n+      cfun->machine->reg_is_wrapped_separately[regno] = true;\n+}\n+\n /* Return nonzero if this function is known to have a null epilogue.\n    This allows the optimizer to omit jumps to jumps if no stack\n    was created.  */\n@@ -6684,6 +6849,30 @@ riscv_dwarf_poly_indeterminate_value (unsigned int i, unsigned int *factor,\n #undef TARGET_FUNCTION_ARG_BOUNDARY\n #define TARGET_FUNCTION_ARG_BOUNDARY riscv_function_arg_boundary\n \n+#undef TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS\n+#define TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS \\\n+  riscv_get_separate_components\n+\n+#undef TARGET_SHRINK_WRAP_COMPONENTS_FOR_BB\n+#define TARGET_SHRINK_WRAP_COMPONENTS_FOR_BB \\\n+  riscv_components_for_bb\n+\n+#undef TARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS\n+#define TARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS \\\n+  riscv_disqualify_components\n+\n+#undef TARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS\n+#define TARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS \\\n+  riscv_emit_prologue_components\n+\n+#undef TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS\n+#define TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS \\\n+  riscv_emit_epilogue_components\n+\n+#undef TARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS\n+#define TARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS \\\n+  riscv_set_handled_components\n+\n /* The generic ELF target does not always have TLS support.  */\n #ifdef HAVE_AS_TLS\n #undef TARGET_HAVE_TLS"}, {"sha": "e1e07c3d4c540cef4b5bc0b32823f85a00491468", "filename": "gcc/testsuite/gcc.target/riscv/shrink-wrap-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/705bae2351a870dc3ff59db47fa0de6baaf829c8/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshrink-wrap-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/705bae2351a870dc3ff59db47fa0de6baaf829c8/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshrink-wrap-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Fshrink-wrap-1.c?ref=705bae2351a870dc3ff59db47fa0de6baaf829c8", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fshrink-wrap\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" \"-Os\" \"-Oz\" } } */\n+\n+void g(void);\n+\n+void f(int x)\n+{\n+  if (x)\n+    {\n+      /* Force saving of some callee-saved registers. With shrink wrapping\n+\t enabled these only need to be saved if x is non-zero.  */\n+      register int s2 asm(\"18\") = x;\n+      register int s3 asm(\"19\") = x;\n+      register int s4 asm(\"20\") = x;\n+      asm(\"\" : : \"r\"(s2));\n+      asm(\"\" : : \"r\"(s3));\n+      asm(\"\" : : \"r\"(s4));\n+      g();\n+    }\n+}\n+\n+/* The resulting code should do nothing if X is 0.  */\n+/* { dg-final { scan-assembler \"bne\\ta0,zero,.*\\n.*ret\" } } */"}]}