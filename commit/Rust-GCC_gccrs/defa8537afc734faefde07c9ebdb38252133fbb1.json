{"sha": "defa8537afc734faefde07c9ebdb38252133fbb1", "node_id": "C_kwDOANBUbNoAKGRlZmE4NTM3YWZjNzM0ZmFlZmRlMDdjOWViZGIzODI1MjEzM2ZiYjE", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-06-25T08:35:45Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-06-25T08:35:45Z"}, "message": "Iterating cprop_hardreg... Third time's a charm.\n\nThis middle-end patch proposes the \"hard register constant propagation\"\npass be performed up to three times on each basic block (up from the\ncurrent two times) if the second pass successfully made changes.\n\nThe motivation for three passes is to handle the \"swap idiom\" (i.e.\nt = x; x = y; y = t;\" sequences) that get generated by register allocation\n(reload).\n\nConsider the x86_64 test case for __int128 addition recently discussed\non gcc-patches.  With that proposed patch, the input to the cprop_hardreg\npass looks like:\n\n\tmovq\t%rdi, %r8\n\tmovq\t%rsi, %rdi\n\tmovq\t%r8, %rsi\n        movq    %rdx, %rax\n        movq    %rcx, %rdx\n        addq    %rsi %rax\n        adcq    %rdi, %rdx\n        ret\n\nwhere the first three instructions effectively swap %rsi and %rdi.\n\nOn the first pass of cprop_hardreg, we notice that the third insn,\n%rsi := %r8, is redundant and can eliminated/propagated to produce:\n\n        movq    %rdi, %r8\n        movq    %rsi, %rdi\n        movq    %rdx, %rax\n        movq    %rcx, %rdx\n        addq    %r8 %rax\n        adcq    %rdi, %rdx\n        ret\n\nBecause a successful propagation was found, cprop_hardreg then runs\na second pass/sweep on affected basic blocks (using worklist), and\non this second pass notices that the second instruction, %rdi := %rsi,\nmay now be propagated (%rsi was killed in the before the first transform),\nand after a second pass, we now end up with:\n\n        movq    %rdi, %r8\n        movq    %rdx, %rax\n        movq    %rcx, %rdx\n        addq    %r8, %rax\n        adcq    %rsi, %rdx\n        ret\n\nwhich is the current behaviour on mainline.  However, a third and final\npass would now notice that the first insn, \"%r8 := %rdi\" is also now\neliminable, and a third iteration would produce optimal code:\n\n        movq    %rdx, %rax\n        movq    %rcx, %rdx\n        addq    %rdi, %rax\n        adcq    %rsi, %rdx\n        ret\n\nThe patch below creates two worklists, and alternates between them on\nsucessive passes, populating NEXT with the basic block id's of blocks\nthat were updated during the current pass over the CURR worklist.\nIt should be noted that this a regression fix; GCC 4.8 generated\noptimal code with two moves (whereas GCC 12 required 5 moves, up\nfrom GCC 11's 4 moves).\n\n2022-06-25  Roger Sayle  <roger@nextmovesoftware.com>\n\t    Richard Biener  <rguenther@suse.de>\n\ngcc/ChangeLog\n\t* regcprop.cc (pass_cprop_hardreg::execute): Perform a third\n\titeration over each basic block that was updated by the second\n\titeration.", "tree": {"sha": "1c4fa22a20fefde10307b3cbea8843578d2f0a6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c4fa22a20fefde10307b3cbea8843578d2f0a6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/defa8537afc734faefde07c9ebdb38252133fbb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/defa8537afc734faefde07c9ebdb38252133fbb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/defa8537afc734faefde07c9ebdb38252133fbb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/defa8537afc734faefde07c9ebdb38252133fbb1/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "476ef855d08db02a027150ea92611c1626ea7350", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/476ef855d08db02a027150ea92611c1626ea7350", "html_url": "https://github.com/Rust-GCC/gccrs/commit/476ef855d08db02a027150ea92611c1626ea7350"}], "stats": {"total": 23, "additions": 16, "deletions": 7}, "files": [{"sha": "eacc59feb3807996c7cedfae2b90f2511db54ceb", "filename": "gcc/regcprop.cc", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/defa8537afc734faefde07c9ebdb38252133fbb1/gcc%2Fregcprop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/defa8537afc734faefde07c9ebdb38252133fbb1/gcc%2Fregcprop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.cc?ref=defa8537afc734faefde07c9ebdb38252133fbb1", "patch": "@@ -1383,7 +1383,9 @@ pass_cprop_hardreg::execute (function *fun)\n   auto_sbitmap visited (last_basic_block_for_fn (fun));\n   bitmap_clear (visited);\n \n-  auto_vec<int> worklist;\n+  auto_vec<int> worklist1, worklist2;\n+  auto_vec<int> *curr = &worklist1;\n+  auto_vec<int> *next = &worklist2;\n   bool any_debug_changes = false;\n \n   /* We need accurate notes.  Earlier passes such as if-conversion may\n@@ -1404,7 +1406,7 @@ pass_cprop_hardreg::execute (function *fun)\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       if (cprop_hardreg_bb (bb, all_vd, visited))\n-\tworklist.safe_push (bb->index);\n+\tcurr->safe_push (bb->index);\n       if (all_vd[bb->index].n_debug_insn_changes)\n \tany_debug_changes = true;\n     }\n@@ -1416,23 +1418,30 @@ pass_cprop_hardreg::execute (function *fun)\n   if (MAY_HAVE_DEBUG_BIND_INSNS && any_debug_changes)\n     cprop_hardreg_debug (fun, all_vd);\n \n-  /* Second pass if we've changed anything, only for the bbs where we have\n-     changed anything though.  */\n-  if (!worklist.is_empty ())\n+  /* Repeat pass up to PASSES times, but only processing basic blocks\n+     that have changed on the previous iteration.  CURR points to the\n+     current worklist, and each iteration populates the NEXT worklist,\n+     swapping pointers after each cycle.  */\n+\n+  unsigned int passes = optimize > 1 ? 3 : 2;\n+  for (unsigned int pass = 2; pass <= passes && !curr->is_empty (); pass++)\n     {\n       any_debug_changes = false;\n       bitmap_clear (visited);\n-      for (int index : worklist)\n+      next->truncate (0);\n+      for (int index : *curr)\n \t{\n \t  bb = BASIC_BLOCK_FOR_FN (fun, index);\n-\t  cprop_hardreg_bb (bb, all_vd, visited);\n+          if (cprop_hardreg_bb (bb, all_vd, visited))\n+\t    next->safe_push (bb->index);\n \t  if (all_vd[bb->index].n_debug_insn_changes)\n \t    any_debug_changes = true;\n \t}\n \n       df_analyze ();\n       if (MAY_HAVE_DEBUG_BIND_INSNS && any_debug_changes)\n \tcprop_hardreg_debug (fun, all_vd);\n+      std::swap (curr, next);\n     }\n \n   free (all_vd);"}]}