{"sha": "91753e21c33ee0f333e529487d67a1ff60b30655", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE3NTNlMjFjMzNlZTBmMzMzZTUyOTQ4N2Q2N2ExZmY2MGIzMDY1NQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-02-11T15:38:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-02-11T15:38:59Z"}, "message": "re PR lto/41664 (FAIL: gfortran.dg/lto/pr40725 f_lto_pr40725_0.o-f_lto_pr40725_1.o execute -O2 -fwhopr and -flto)\n\n2010-02-11  Richard Guenther  <rguenther@suse.de>\n\n\tPR lto/41664\n\t* tree-ssa-alias.c (refs_may_alias_p_1): Canonicalize\n\tpointer-vs-decl case by swapping refs.  Handle some cases\n\tof pointer-vs-decl disambiguations more conservatively.\n\t* cfgexpand.c (gimple_expand_cfg): Set gimple_df->in_ssa_p\n\tto false after expanding.\n\nFrom-SVN: r156699", "tree": {"sha": "677c1523c511c02cf1a26efd442c195756d993b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/677c1523c511c02cf1a26efd442c195756d993b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91753e21c33ee0f333e529487d67a1ff60b30655", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91753e21c33ee0f333e529487d67a1ff60b30655", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91753e21c33ee0f333e529487d67a1ff60b30655", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91753e21c33ee0f333e529487d67a1ff60b30655/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "13b7990c1a90247baa304dfa8c438d214424019f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13b7990c1a90247baa304dfa8c438d214424019f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13b7990c1a90247baa304dfa8c438d214424019f"}], "stats": {"total": 90, "additions": 83, "deletions": 7}, "files": [{"sha": "70deed75ece3785e544cadb1abe48713554da820", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91753e21c33ee0f333e529487d67a1ff60b30655/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91753e21c33ee0f333e529487d67a1ff60b30655/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91753e21c33ee0f333e529487d67a1ff60b30655", "patch": "@@ -1,3 +1,12 @@\n+2010-02-11  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/41664\n+\t* tree-ssa-alias.c (refs_may_alias_p_1): Canonicalize\n+\tpointer-vs-decl case by swapping refs.  Handle some cases\n+\tof pointer-vs-decl disambiguations more conservatively.\n+\t* cfgexpand.c (gimple_expand_cfg): Set gimple_df->in_ssa_p\n+\tto false after expanding.\n+\n 2010-02-11  Richard Guenther  <rguenther@suse.de>\n \n \tPR driver/43021"}, {"sha": "a0d4ba52b12ff24e7409bb916c22b37c741a7e4a", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91753e21c33ee0f333e529487d67a1ff60b30655/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91753e21c33ee0f333e529487d67a1ff60b30655/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=91753e21c33ee0f333e529487d67a1ff60b30655", "patch": "@@ -3639,6 +3639,9 @@ gimple_expand_cfg (void)\n   execute_free_datastructures ();\n   finish_out_of_ssa (&SA);\n \n+  /* We are no longer in SSA form.  */\n+  cfun->gimple_df->in_ssa_p = false;\n+\n   /* Expansion is used by optimization passes too, set maybe_hot_insn_p\n      conservatively to true until they are all profile aware.  */\n   pointer_map_destroy (lab_rtx_for_bb);"}, {"sha": "7b60201279916d0a8c18dfa78595aaba0811d3ff", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 71, "deletions": 7, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91753e21c33ee0f333e529487d67a1ff60b30655/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91753e21c33ee0f333e529487d67a1ff60b30655/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=91753e21c33ee0f333e529487d67a1ff60b30655", "patch": "@@ -818,6 +818,77 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n     return decl_refs_may_alias_p (base1, offset1, max_size1,\n \t\t\t\t  base2, offset2, max_size2);\n \n+  ind1_p = INDIRECT_REF_P (base1);\n+  ind2_p = INDIRECT_REF_P (base2);\n+  /* Canonicalize the pointer-vs-decl case.  */\n+  if (ind1_p && var2_p)\n+    {\n+      HOST_WIDE_INT tmp1;\n+      tree tmp2;\n+      ao_ref *tmp3;\n+      tmp1 = offset1; offset1 = offset2; offset2 = tmp1;\n+      tmp1 = max_size1; max_size1 = max_size2; max_size2 = tmp1;\n+      tmp2 = base1; base1 = base2; base2 = tmp2;\n+      tmp3 = ref1; ref1 = ref2; ref2 = tmp3;\n+      var1_p = true;\n+      ind1_p = false;\n+      var2_p = false;\n+      ind2_p = true;\n+    }\n+\n+  /* If we are about to disambiguate pointer-vs-decl try harder to\n+     see must-aliases and give leeway to some invalid cases.\n+     This covers a pretty minimal set of cases only and does not\n+     when called from the RTL oracle.  It handles cases like\n+\n+       int i = 1;\n+       return *(float *)&i;\n+\n+     and also fixes gfortran.dg/lto/pr40725.  */\n+  if (var1_p && ind2_p\n+      && cfun\n+      && gimple_in_ssa_p (cfun)\n+      && TREE_CODE (TREE_OPERAND (base2, 0)) == SSA_NAME)\n+    {\n+      gimple def_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (base2, 0));\n+      while (is_gimple_assign (def_stmt)\n+\t     && (gimple_assign_rhs_code (def_stmt) == SSA_NAME\n+\t\t || CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt))))\n+\t{\n+\t  tree rhs = gimple_assign_rhs1 (def_stmt);\n+\t  HOST_WIDE_INT offset, size, max_size;\n+\n+\t  /* Look through SSA name copies and pointer conversions.  */\n+\t  if (TREE_CODE (rhs) == SSA_NAME\n+\t      && POINTER_TYPE_P (TREE_TYPE (rhs)))\n+\t    {\n+\t      def_stmt = SSA_NAME_DEF_STMT (rhs);\n+\t      continue;\n+\t    }\n+\t  if (TREE_CODE (rhs) != ADDR_EXPR)\n+\t    break;\n+\n+\t  /* If the pointer is defined as an address based on a decl\n+\t     use plain offset disambiguation and ignore TBAA.  */\n+\t  rhs = TREE_OPERAND (rhs, 0);\n+\t  rhs = get_ref_base_and_extent (rhs, &offset, &size, &max_size);\n+\t  if (SSA_VAR_P (rhs))\n+\t    {\n+\t      base2 = rhs;\n+\t      offset2 += offset;\n+\t      if (size != max_size\n+\t\t  || max_size == -1)\n+\t\tmax_size2 = -1;\n+\t      return decl_refs_may_alias_p (base1, offset1, max_size1,\n+\t\t\t\t\t    base2, offset2, max_size2);\n+\t    }\n+\n+\t  /* Do not continue looking through &p->x to limit time\n+\t     complexity.  */\n+\t  break;\n+\t}\n+    }\n+\n   /* First defer to TBAA if possible.  */\n   if (tbaa_p\n       && flag_strict_aliasing\n@@ -833,19 +904,12 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n     return true;\n \n   /* Dispatch to the pointer-vs-decl or pointer-vs-pointer disambiguators.  */\n-  ind1_p = INDIRECT_REF_P (base1);\n-  ind2_p = INDIRECT_REF_P (base2);\n   set = tbaa_p ? -1 : 0;\n   if (var1_p && ind2_p)\n     return indirect_ref_may_alias_decl_p (ref2->ref, TREE_OPERAND (base2, 0),\n \t\t\t\t\t  offset2, max_size2, set,\n \t\t\t\t\t  ref1->ref, base1,\n \t\t\t\t\t  offset1, max_size1, set);\n-  else if (ind1_p && var2_p)\n-    return indirect_ref_may_alias_decl_p (ref1->ref, TREE_OPERAND (base1, 0),\n-\t\t\t\t\t  offset1, max_size1, set,\n-\t\t\t\t\t  ref2->ref, base2,\n-\t\t\t\t\t  offset2, max_size2, set);\n   else if (ind1_p && ind2_p)\n     return indirect_refs_may_alias_p (ref1->ref, TREE_OPERAND (base1, 0),\n \t\t\t\t      offset1, max_size1, set,"}]}