{"sha": "a029addda261d1f212ee33d0cae9fd1f67a5fa8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAyOWFkZGRhMjYxZDFmMjEyZWUzM2QwY2FlOWZkMWY2N2E1ZmE4ZA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2015-11-06T10:34:13Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2015-11-06T10:34:13Z"}, "message": "[PR67753] fix copy of PARALLEL entry_parm to CONCAT target_reg\n\nIn assign_parms_setup_block, the copy of args in PARALLELs from\nentry_parm to stack_parm is deferred to the parm conversion insn seq,\nbut the copy from stack_parm to target_reg was inserted in the normal\ncopy seq, that is executed before the conversion insn seq.  Oops.\n\nWe could do away with the need for an actual stack_parm in general,\nwhich would have avoided the need for emitting the copy to target_reg\nin the conversion seq, but at least on pa, due to the need for stack\nto copy between SI and SF modes, it seems like using the reserved\nstack slot is beneficial, so I put in logic to use a pre-reserved\nstack slot when there is one, and emit the copy to target_reg in the\nconversion seq if stack_parm was set up there.\n\nfor  gcc/ChangeLog\n\n\tPR rtl-optimization/67753\n\tPR rtl-optimization/64164\n\t* function.c (assign_parm_setup_block): Avoid allocating a\n\tstack slot if we don't have an ABI-reserved one.  Emit the\n\tcopy to target_reg in the conversion seq if the copy from\n\tentry_parm is in it too.  Don't use the conversion seq to copy\n\ta PARALLEL to a REG or a CONCAT.\n\nFrom-SVN: r229840", "tree": {"sha": "2c721a902fe8f0e45fb9a2ad6540cd633ecc1158", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c721a902fe8f0e45fb9a2ad6540cd633ecc1158"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a029addda261d1f212ee33d0cae9fd1f67a5fa8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a029addda261d1f212ee33d0cae9fd1f67a5fa8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a029addda261d1f212ee33d0cae9fd1f67a5fa8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a029addda261d1f212ee33d0cae9fd1f67a5fa8d/comments", "author": null, "committer": null, "parents": [{"sha": "5c661a44685cb5b0185c5a81c26f41dc2876e9df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c661a44685cb5b0185c5a81c26f41dc2876e9df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c661a44685cb5b0185c5a81c26f41dc2876e9df"}], "stats": {"total": 49, "additions": 44, "deletions": 5}, "files": [{"sha": "ae2c5cf48579b147fc5707d1e7172fb120a964a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a029addda261d1f212ee33d0cae9fd1f67a5fa8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a029addda261d1f212ee33d0cae9fd1f67a5fa8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a029addda261d1f212ee33d0cae9fd1f67a5fa8d", "patch": "@@ -1,3 +1,13 @@\n+2015-11-06  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR rtl-optimization/67753\n+\tPR rtl-optimization/64164\n+\t* function.c (assign_parm_setup_block): Avoid allocating a\n+\tstack slot if we don't have an ABI-reserved one.  Emit the\n+\tcopy to target_reg in the conversion seq if the copy from\n+\tentry_parm is in it too.  Don't use the conversion seq to copy\n+\ta PARALLEL to a REG or a CONCAT.\n+\n 2015-11-06  Richard Biener  <rguenther@suse.de>\n \n \t* tree-hash-traits.h (tree_operand_hash): Provide equal, not"}, {"sha": "a637cb39142ea5b6969dc2f4150f9790267db13a", "filename": "gcc/function.c", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a029addda261d1f212ee33d0cae9fd1f67a5fa8d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a029addda261d1f212ee33d0cae9fd1f67a5fa8d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a029addda261d1f212ee33d0cae9fd1f67a5fa8d", "patch": "@@ -2879,6 +2879,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n   rtx entry_parm = data->entry_parm;\n   rtx stack_parm = data->stack_parm;\n   rtx target_reg = NULL_RTX;\n+  bool in_conversion_seq = false;\n   HOST_WIDE_INT size;\n   HOST_WIDE_INT size_stored;\n \n@@ -2895,9 +2896,23 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n       if (GET_CODE (reg) != CONCAT)\n \tstack_parm = reg;\n       else\n-\t/* This will use or allocate a stack slot that we'd rather\n-\t   avoid.  FIXME: Could we avoid it in more cases?  */\n-\ttarget_reg = reg;\n+\t{\n+\t  target_reg = reg;\n+\t  /* Avoid allocating a stack slot, if there isn't one\n+\t     preallocated by the ABI.  It might seem like we should\n+\t     always prefer a pseudo, but converting between\n+\t     floating-point and integer modes goes through the stack\n+\t     on various machines, so it's better to use the reserved\n+\t     stack slot than to risk wasting it and allocating more\n+\t     for the conversion.  */\n+\t  if (stack_parm == NULL_RTX)\n+\t    {\n+\t      int save = generating_concat_p;\n+\t      generating_concat_p = 0;\n+\t      stack_parm = gen_reg_rtx (mode);\n+\t      generating_concat_p = save;\n+\t    }\n+\t}\n       data->stack_parm = NULL;\n     }\n \n@@ -2938,14 +2953,17 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n       mem = validize_mem (copy_rtx (stack_parm));\n \n       /* Handle values in multiple non-contiguous locations.  */\n-      if (GET_CODE (entry_parm) == PARALLEL)\n+      if (GET_CODE (entry_parm) == PARALLEL && !MEM_P (mem))\n+\temit_group_store (mem, entry_parm, data->passed_type, size);\n+      else if (GET_CODE (entry_parm) == PARALLEL)\n \t{\n \t  push_to_sequence2 (all->first_conversion_insn,\n \t\t\t     all->last_conversion_insn);\n \t  emit_group_store (mem, entry_parm, data->passed_type, size);\n \t  all->first_conversion_insn = get_insns ();\n \t  all->last_conversion_insn = get_last_insn ();\n \t  end_sequence ();\n+\t  in_conversion_seq = true;\n \t}\n \n       else if (size == 0)\n@@ -3025,11 +3043,22 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n       all->first_conversion_insn = get_insns ();\n       all->last_conversion_insn = get_last_insn ();\n       end_sequence ();\n+      in_conversion_seq = true;\n     }\n \n   if (target_reg)\n     {\n-      emit_move_insn (target_reg, stack_parm);\n+      if (!in_conversion_seq)\n+\temit_move_insn (target_reg, stack_parm);\n+      else\n+\t{\n+\t  push_to_sequence2 (all->first_conversion_insn,\n+\t\t\t     all->last_conversion_insn);\n+\t  emit_move_insn (target_reg, stack_parm);\n+\t  all->first_conversion_insn = get_insns ();\n+\t  all->last_conversion_insn = get_last_insn ();\n+\t  end_sequence ();\n+\t}\n       stack_parm = target_reg;\n     }\n "}]}