{"sha": "eef99cd9567d40f72654faf6f21fdc65c63c9c3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVmOTljZDk1NjdkNDBmNzI2NTRmYWY2ZjIxZmRjNjVjNjNjOWMzZA==", "commit": {"author": {"name": "Giuliano Belinassi", "email": "giuliano.belinassi@usp.br", "date": "2019-11-18T20:05:16Z"}, "committer": {"name": "Giuliano Belinassi", "email": "giulianob@gcc.gnu.org", "date": "2019-11-18T20:05:16Z"}, "message": "Refactor tree-loop-distribution.c for thread safety\n\nThis patch refactors tree-loop-distribution.c for thread safety without\nuse of C11 __thread feature. All global variables were moved to\n`class loop_distribution` which is initialized at ::execute time.\n\nFrom-SVN: r278421", "tree": {"sha": "92ed33dfe90ac4b9908ab5e37775a2734518b0b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92ed33dfe90ac4b9908ab5e37775a2734518b0b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eef99cd9567d40f72654faf6f21fdc65c63c9c3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eef99cd9567d40f72654faf6f21fdc65c63c9c3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eef99cd9567d40f72654faf6f21fdc65c63c9c3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eef99cd9567d40f72654faf6f21fdc65c63c9c3d/comments", "author": null, "committer": null, "parents": [{"sha": "8d890d37e0183735586c18f1f056deb5848617ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d890d37e0183735586c18f1f056deb5848617ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d890d37e0183735586c18f1f056deb5848617ca"}], "stats": {"total": 711, "additions": 441, "deletions": 270}, "files": [{"sha": "0c71cef37ac335ac4acef3a01436a787c25b88c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef99cd9567d40f72654faf6f21fdc65c63c9c3d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef99cd9567d40f72654faf6f21fdc65c63c9c3d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eef99cd9567d40f72654faf6f21fdc65c63c9c3d", "patch": "@@ -1,3 +1,36 @@\n+2019-11-18  Giuliano Belinassi  <giuliano.belinassi@usp.br>\n+\n+\t* cfgloop.c (get_loop_body_in_custom_order): New.\n+\t* cfgloop.h (get_loop_body_in_custom_order): New prototype.\n+\t* tree-loop-distribution.c (class loop_distribution): New.\n+\t(bb_top_order_cmp): Remove.\n+\t(bb_top_order_cmp_r): New.\n+\t(create_rdg_vertices): Move into class loop_distribution.\n+\t(stmts_from_loop): Same as above.\n+\t(update_for_merge): Same as above.\n+\t(partition_merge_into): Same as above.\n+\t(get_data_dependence): Same as above.\n+\t(data_dep_in_cycle_p): Same as above.\n+\t(update_type_for_merge): Same as above.\n+\t(build_rdg_partition_for-vertex): Same as above.\n+\t(classify_builtin_ldst): Same as above.\n+\t(classify_partition): Same as above.\n+\t(share_memory_accesses): Same as above.\n+\t(rdg_build_partitions): Same as above.\n+\t(pg_add_dependence_edges): Same as above.\n+\t(build_partition_graph): Same as above.\n+\t(merge_dep_scc_partitions): Same as above.\n+\t(break_alias_scc_partitions): Same as above.\n+\t(finalize_partitions): Same as above.\n+\t(distribute_loop): Same as above.\n+\t(bb_top_order_init): New method\n+\t(bb_top_order_destroy): New method.\n+\t(get_bb_top_order_index_size): New method.\n+\t(get_bb_top_order_index_index): New method.\n+\t(get_bb_top_order_index_index): New method.\n+\t(loop_distribution::execute): New method.\n+\t(pass_loop_distribution::execute): Instantiate loop_distribution.\n+\n 2019-11-18  Jan Hubicka  <jh@suse.cz>\n \n \tPR ipa/92508"}, {"sha": "308ed7d18d0ba01f9ee5492475f0ed4ee4216885", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef99cd9567d40f72654faf6f21fdc65c63c9c3d/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef99cd9567d40f72654faf6f21fdc65c63c9c3d/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=eef99cd9567d40f72654faf6f21fdc65c63c9c3d", "patch": "@@ -980,6 +980,19 @@ get_loop_body_in_custom_order (const class loop *loop,\n   return bbs;\n }\n \n+/* Same as above, but use gcc_sort_r instead of qsort.  */\n+\n+basic_block *\n+get_loop_body_in_custom_order (const class loop *loop, void *data,\n+\t\t\t       int (*bb_comparator) (const void *, const void *, void *))\n+{\n+  basic_block *bbs = get_loop_body (loop);\n+\n+  gcc_sort_r (bbs, loop->num_nodes, sizeof (basic_block), bb_comparator, data);\n+\n+  return bbs;\n+}\n+\n /* Get body of a LOOP in breadth first sort order.  */\n \n basic_block *"}, {"sha": "6256cc01ff4312faa98b60afec4168050ce54016", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef99cd9567d40f72654faf6f21fdc65c63c9c3d/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef99cd9567d40f72654faf6f21fdc65c63c9c3d/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=eef99cd9567d40f72654faf6f21fdc65c63c9c3d", "patch": "@@ -376,6 +376,8 @@ extern basic_block *get_loop_body_in_dom_order (const class loop *);\n extern basic_block *get_loop_body_in_bfs_order (const class loop *);\n extern basic_block *get_loop_body_in_custom_order (const class loop *,\n \t\t\t       int (*) (const void *, const void *));\n+extern basic_block *get_loop_body_in_custom_order (const class loop *, void *,\n+\t\t\t       int (*) (const void *, const void *, void *));\n \n extern vec<edge> get_loop_exit_edges (const class loop *);\n extern edge single_exit (const class loop *);"}, {"sha": "839abb733ae80e3a0f5d175d651481915dffae81", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 393, "deletions": 270, "changes": 663, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef99cd9567d40f72654faf6f21fdc65c63c9c3d/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef99cd9567d40f72654faf6f21fdc65c63c9c3d/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=eef99cd9567d40f72654faf6f21fdc65c63c9c3d", "patch": "@@ -154,21 +154,10 @@ ddr_hasher::equal (const data_dependence_relation *ddr1,\n   return (DDR_A (ddr1) == DDR_A (ddr2) && DDR_B (ddr1) == DDR_B (ddr2));\n }\n \n-/* The loop (nest) to be distributed.  */\n-static vec<loop_p> loop_nest;\n \n-/* Vector of data references in the loop to be distributed.  */\n-static vec<data_reference_p> datarefs_vec;\n \n-/* If there is nonaddressable data reference in above vector.  */\n-static bool has_nonaddressable_dataref_p;\n-\n-/* Store index of data reference in aux field.  */\n #define DR_INDEX(dr)      ((uintptr_t) (dr)->aux)\n \n-/* Hash table for data dependence relation in the loop to be distributed.  */\n-static hash_table<ddr_hasher> *ddrs_table;\n-\n /* A Reduced Dependence Graph (RDG) vertex representing a statement.  */\n struct rdg_vertex\n {\n@@ -215,6 +204,83 @@ struct rdg_edge\n \n #define RDGE_TYPE(E)        ((struct rdg_edge *) ((E)->data))->type\n \n+/* Kind of distributed loop.  */\n+enum partition_kind {\n+    PKIND_NORMAL,\n+    /* Partial memset stands for a paritition can be distributed into a loop\n+       of memset calls, rather than a single memset call.  It's handled just\n+       like a normal parition, i.e, distributed as separate loop, no memset\n+       call is generated.\n+\n+       Note: This is a hacking fix trying to distribute ZERO-ing stmt in a\n+       loop nest as deep as possible.  As a result, parloop achieves better\n+       parallelization by parallelizing deeper loop nest.  This hack should\n+       be unnecessary and removed once distributed memset can be understood\n+       and analyzed in data reference analysis.  See PR82604 for more.  */\n+    PKIND_PARTIAL_MEMSET,\n+    PKIND_MEMSET, PKIND_MEMCPY, PKIND_MEMMOVE\n+};\n+\n+/* Type of distributed loop.  */\n+enum partition_type {\n+    /* The distributed loop can be executed parallelly.  */\n+    PTYPE_PARALLEL = 0,\n+    /* The distributed loop has to be executed sequentially.  */\n+    PTYPE_SEQUENTIAL\n+};\n+\n+/* Builtin info for loop distribution.  */\n+struct builtin_info\n+{\n+  /* data-references a kind != PKIND_NORMAL partition is about.  */\n+  data_reference_p dst_dr;\n+  data_reference_p src_dr;\n+  /* Base address and size of memory objects operated by the builtin.  Note\n+     both dest and source memory objects must have the same size.  */\n+  tree dst_base;\n+  tree src_base;\n+  tree size;\n+  /* Base and offset part of dst_base after stripping constant offset.  This\n+     is only used in memset builtin distribution for now.  */\n+  tree dst_base_base;\n+  unsigned HOST_WIDE_INT dst_base_offset;\n+};\n+\n+/* Partition for loop distribution.  */\n+struct partition\n+{\n+  /* Statements of the partition.  */\n+  bitmap stmts;\n+  /* True if the partition defines variable which is used outside of loop.  */\n+  bool reduction_p;\n+  location_t loc;\n+  enum partition_kind kind;\n+  enum partition_type type;\n+  /* Data references in the partition.  */\n+  bitmap datarefs;\n+  /* Information of builtin parition.  */\n+  struct builtin_info *builtin;\n+};\n+\n+/* Partitions are fused because of different reasons.  */\n+enum fuse_type\n+{\n+  FUSE_NON_BUILTIN = 0,\n+  FUSE_REDUCTION = 1,\n+  FUSE_SHARE_REF = 2,\n+  FUSE_SAME_SCC = 3,\n+  FUSE_FINALIZE = 4\n+};\n+\n+/* Description on different fusing reason.  */\n+static const char *fuse_message[] = {\n+  \"they are non-builtins\",\n+  \"they have reductions\",\n+  \"they have shared memory refs\",\n+  \"they are in the same dependence scc\",\n+  \"there is no point to distribute loop\"};\n+\n+\n /* Dump vertex I in RDG to FILE.  */\n \n static void\n@@ -435,11 +501,205 @@ create_rdg_cd_edges (struct graph *rdg, control_dependences *cd, loop_p loop)\n     }\n }\n \n-/* Build the vertices of the reduced dependence graph RDG.  Return false\n-   if that failed.  */\n \n-static bool\n-create_rdg_vertices (struct graph *rdg, vec<gimple *> stmts, loop_p loop)\n+class loop_distribution\n+{\n+  private:\n+  /* The loop (nest) to be distributed.  */\n+  vec<loop_p> loop_nest;\n+\n+  /* Vector of data references in the loop to be distributed.  */\n+  vec<data_reference_p> datarefs_vec;\n+\n+  /* If there is nonaddressable data reference in above vector.  */\n+  bool has_nonaddressable_dataref_p;\n+\n+  /* Store index of data reference in aux field.  */\n+\n+  /* Hash table for data dependence relation in the loop to be distributed.  */\n+  hash_table<ddr_hasher> *ddrs_table;\n+\n+  /* Array mapping basic block's index to its topological order.  */\n+  int *bb_top_order_index;\n+  /* And size of the array.  */\n+  int bb_top_order_index_size;\n+\n+  /* Build the vertices of the reduced dependence graph RDG.  Return false\n+     if that failed.  */\n+  bool create_rdg_vertices (struct graph *rdg, vec<gimple *> stmts, loop_p loop);\n+\n+  /* Initialize STMTS with all the statements of LOOP.  We use topological\n+     order to discover all statements.  The order is important because\n+     generate_loops_for_partition is using the same traversal for identifying\n+     statements in loop copies.  */\n+  void stmts_from_loop (class loop *loop, vec<gimple *> *stmts);\n+\n+\n+  /* Build the Reduced Dependence Graph (RDG) with one vertex per statement of\n+     LOOP, and one edge per flow dependence or control dependence from control\n+     dependence CD.  During visiting each statement, data references are also\n+     collected and recorded in global data DATAREFS_VEC.  */\n+  struct graph * build_rdg (class loop *loop, control_dependences *cd);\n+\n+/* Merge PARTITION into the partition DEST.  RDG is the reduced dependence\n+   graph and we update type for result partition if it is non-NULL.  */\n+  void partition_merge_into (struct graph *rdg,\n+\t\t\t     partition *dest, partition *partition,\n+\t\t\t     enum fuse_type ft);\n+\n+\n+  /* Return data dependence relation for data references A and B.  The two\n+     data references must be in lexicographic order wrto reduced dependence\n+     graph RDG.  We firstly try to find ddr from global ddr hash table.  If\n+     it doesn't exist, compute the ddr and cache it.  */\n+  data_dependence_relation * get_data_dependence (struct graph *rdg,\n+\t\t\t\t\t\t  data_reference_p a,\n+\t\t\t\t\t\t  data_reference_p b);\n+\n+\n+  /* In reduced dependence graph RDG for loop distribution, return true if\n+     dependence between references DR1 and DR2 leads to a dependence cycle\n+     and such dependence cycle can't be resolved by runtime alias check.  */\n+  bool data_dep_in_cycle_p (struct graph *rdg, data_reference_p dr1,\n+\t\t\t    data_reference_p dr2);\n+\n+\n+  /* Given reduced dependence graph RDG, PARTITION1 and PARTITION2, update\n+     PARTITION1's type after merging PARTITION2 into PARTITION1.  */\n+  void update_type_for_merge (struct graph *rdg,\n+\t\t\t      partition *partition1, partition *partition2);\n+\n+\n+  /* Returns a partition with all the statements needed for computing\n+     the vertex V of the RDG, also including the loop exit conditions.  */\n+  partition *build_rdg_partition_for_vertex (struct graph *rdg, int v);\n+\n+  /* Given data references DST_DR and SRC_DR in loop nest LOOP and RDG, classify\n+     if it forms builtin memcpy or memmove call.  */\n+  void classify_builtin_ldst (loop_p loop, struct graph *rdg, partition *partition,\n+\t\t\t      data_reference_p dst_dr, data_reference_p src_dr);\n+\n+  /* Classifies the builtin kind we can generate for PARTITION of RDG and LOOP.\n+     For the moment we detect memset, memcpy and memmove patterns.  Bitmap\n+     STMT_IN_ALL_PARTITIONS contains statements belonging to all partitions.\n+     Returns true if there is a reduction in all partitions and we\n+     possibly did not mark PARTITION as having one for this reason.  */\n+\n+  bool\n+  classify_partition (loop_p loop,\n+\t\t      struct graph *rdg, partition *partition,\n+\t\t      bitmap stmt_in_all_partitions);\n+\n+\n+  /* Returns true when PARTITION1 and PARTITION2 access the same memory\n+     object in RDG.  */\n+  bool share_memory_accesses (struct graph *rdg,\n+\t\t\t      partition *partition1, partition *partition2);\n+\n+  /* For each seed statement in STARTING_STMTS, this function builds\n+     partition for it by adding depended statements according to RDG.\n+     All partitions are recorded in PARTITIONS.  */\n+  void rdg_build_partitions (struct graph *rdg,\n+\t\t\t     vec<gimple *> starting_stmts,\n+\t\t\t     vec<partition *> *partitions);\n+\n+  /* Compute partition dependence created by the data references in DRS1\n+     and DRS2, modify and return DIR according to that.  IF ALIAS_DDR is\n+     not NULL, we record dependence introduced by possible alias between\n+     two data references in ALIAS_DDRS; otherwise, we simply ignore such\n+     dependence as if it doesn't exist at all.  */\n+  int pg_add_dependence_edges (struct graph *rdg, int dir, bitmap drs1,\n+\t\t\t       bitmap drs2, vec<ddr_p> *alias_ddrs);\n+\n+\n+  /* Build and return partition dependence graph for PARTITIONS.  RDG is\n+     reduced dependence graph for the loop to be distributed.  If IGNORE_ALIAS_P\n+     is true, data dependence caused by possible alias between references\n+     is ignored, as if it doesn't exist at all; otherwise all depdendences\n+     are considered.  */\n+  struct graph *build_partition_graph (struct graph *rdg,\n+\t\t\t\t       vec<struct partition *> *partitions,\n+\t\t\t\t       bool ignore_alias_p);\n+\n+  /* Given reduced dependence graph RDG merge strong connected components\n+     of PARTITIONS.  If IGNORE_ALIAS_P is true, data dependence caused by\n+     possible alias between references is ignored, as if it doesn't exist\n+     at all; otherwise all depdendences are considered.  */\n+  void merge_dep_scc_partitions (struct graph *rdg, vec<struct partition *>\n+\t\t\t\t *partitions, bool ignore_alias_p);\n+\n+/* This is the main function breaking strong conected components in\n+   PARTITIONS giving reduced depdendence graph RDG.  Store data dependence\n+   relations for runtime alias check in ALIAS_DDRS.  */\n+  void break_alias_scc_partitions (struct graph *rdg, vec<struct partition *>\n+\t\t\t\t   *partitions, vec<ddr_p> *alias_ddrs);\n+\n+\n+  /* Fuse PARTITIONS of LOOP if necessary before finalizing distribution.\n+     ALIAS_DDRS contains ddrs which need runtime alias check.  */\n+  void finalize_partitions (class loop *loop, vec<struct partition *>\n+\t\t\t    *partitions, vec<ddr_p> *alias_ddrs);\n+\n+  /* Distributes the code from LOOP in such a way that producer statements\n+     are placed before consumer statements.  Tries to separate only the\n+     statements from STMTS into separate loops.  Returns the number of\n+     distributed loops.  Set NB_CALLS to number of generated builtin calls.\n+     Set *DESTROY_P to whether LOOP needs to be destroyed.  */\n+  int distribute_loop (class loop *loop, vec<gimple *> stmts,\n+\t\t       control_dependences *cd, int *nb_calls, bool *destroy_p,\n+\t\t       bool only_patterns_p);\n+\n+  /* Compute topological order for basic blocks.  Topological order is\n+     needed because data dependence is computed for data references in\n+     lexicographical order.  */\n+  void bb_top_order_init (void);\n+\n+  void bb_top_order_destroy (void);\n+\n+  public:\n+\n+  /* Getter for bb_top_order.  */\n+\n+  inline int get_bb_top_order_index_size (void)\n+    {\n+      return bb_top_order_index_size;\n+    }\n+\n+  inline int get_bb_top_order_index (int i)\n+    {\n+      return bb_top_order_index[i];\n+    }\n+\n+  unsigned int execute (function *fun);\n+};\n+\n+\n+/* If X has a smaller topological sort number than Y, returns -1;\n+   if greater, returns 1.  */\n+static int\n+bb_top_order_cmp_r (const void *x, const void *y, void *loop)\n+{\n+  loop_distribution *_loop =\n+    (loop_distribution *) loop;\n+\n+  basic_block bb1 = *(const basic_block *) x;\n+  basic_block bb2 = *(const basic_block *) y;\n+\n+  int bb_top_order_index_size = _loop->get_bb_top_order_index_size ();\n+\n+  gcc_assert (bb1->index < bb_top_order_index_size\n+\t      && bb2->index < bb_top_order_index_size);\n+  gcc_assert (bb1 == bb2\n+\t      || _loop->get_bb_top_order_index(bb1->index)\n+\t\t != _loop->get_bb_top_order_index(bb2->index));\n+\n+  return (_loop->get_bb_top_order_index(bb1->index) - \n+\t  _loop->get_bb_top_order_index(bb2->index));\n+}\n+\n+bool\n+loop_distribution::create_rdg_vertices (struct graph *rdg, vec<gimple *> stmts,\n+\t\t\t\t\tloop_p loop)\n {\n   int i;\n   gimple *stmt;\n@@ -476,39 +736,11 @@ create_rdg_vertices (struct graph *rdg, vec<gimple *> stmts, loop_p loop)\n   return true;\n }\n \n-/* Array mapping basic block's index to its topological order.  */\n-static int *bb_top_order_index;\n-/* And size of the array.  */\n-static int bb_top_order_index_size;\n-\n-/* If X has a smaller topological sort number than Y, returns -1;\n-   if greater, returns 1.  */\n-\n-static int\n-bb_top_order_cmp (const void *x, const void *y)\n-{\n-  basic_block bb1 = *(const basic_block *) x;\n-  basic_block bb2 = *(const basic_block *) y;\n-\n-  gcc_assert (bb1->index < bb_top_order_index_size\n-\t      && bb2->index < bb_top_order_index_size);\n-  gcc_assert (bb1 == bb2\n-\t      || bb_top_order_index[bb1->index]\n-\t\t != bb_top_order_index[bb2->index]);\n-\n-  return (bb_top_order_index[bb1->index] - bb_top_order_index[bb2->index]);\n-}\n-\n-/* Initialize STMTS with all the statements of LOOP.  We use topological\n-   order to discover all statements.  The order is important because\n-   generate_loops_for_partition is using the same traversal for identifying\n-   statements in loop copies.  */\n-\n-static void\n-stmts_from_loop (class loop *loop, vec<gimple *> *stmts)\n+void\n+loop_distribution::stmts_from_loop (class loop *loop, vec<gimple *> *stmts)\n {\n   unsigned int i;\n-  basic_block *bbs = get_loop_body_in_custom_order (loop, bb_top_order_cmp);\n+  basic_block *bbs = get_loop_body_in_custom_order (loop, this, bb_top_order_cmp_r);\n \n   for (i = 0; i < loop->num_nodes; i++)\n     {\n@@ -557,13 +789,8 @@ free_rdg (struct graph *rdg)\n   free_graph (rdg);\n }\n \n-/* Build the Reduced Dependence Graph (RDG) with one vertex per statement of\n-   LOOP, and one edge per flow dependence or control dependence from control\n-   dependence CD.  During visiting each statement, data references are also\n-   collected and recorded in global data DATAREFS_VEC.  */\n-\n-static struct graph *\n-build_rdg (class loop *loop, control_dependences *cd)\n+struct graph *\n+loop_distribution::build_rdg (class loop *loop, control_dependences *cd)\n {\n   struct graph *rdg;\n \n@@ -586,65 +813,6 @@ build_rdg (class loop *loop, control_dependences *cd)\n }\n \n \n-/* Kind of distributed loop.  */\n-enum partition_kind {\n-    PKIND_NORMAL,\n-    /* Partial memset stands for a paritition can be distributed into a loop\n-       of memset calls, rather than a single memset call.  It's handled just\n-       like a normal parition, i.e, distributed as separate loop, no memset\n-       call is generated.\n-\n-       Note: This is a hacking fix trying to distribute ZERO-ing stmt in a\n-       loop nest as deep as possible.  As a result, parloop achieves better\n-       parallelization by parallelizing deeper loop nest.  This hack should\n-       be unnecessary and removed once distributed memset can be understood\n-       and analyzed in data reference analysis.  See PR82604 for more.  */\n-    PKIND_PARTIAL_MEMSET,\n-    PKIND_MEMSET, PKIND_MEMCPY, PKIND_MEMMOVE\n-};\n-\n-/* Type of distributed loop.  */\n-enum partition_type {\n-    /* The distributed loop can be executed parallelly.  */\n-    PTYPE_PARALLEL = 0,\n-    /* The distributed loop has to be executed sequentially.  */\n-    PTYPE_SEQUENTIAL\n-};\n-\n-/* Builtin info for loop distribution.  */\n-struct builtin_info\n-{\n-  /* data-references a kind != PKIND_NORMAL partition is about.  */\n-  data_reference_p dst_dr;\n-  data_reference_p src_dr;\n-  /* Base address and size of memory objects operated by the builtin.  Note\n-     both dest and source memory objects must have the same size.  */\n-  tree dst_base;\n-  tree src_base;\n-  tree size;\n-  /* Base and offset part of dst_base after stripping constant offset.  This\n-     is only used in memset builtin distribution for now.  */\n-  tree dst_base_base;\n-  unsigned HOST_WIDE_INT dst_base_offset;\n-};\n-\n-/* Partition for loop distribution.  */\n-struct partition\n-{\n-  /* Statements of the partition.  */\n-  bitmap stmts;\n-  /* True if the partition defines variable which is used outside of loop.  */\n-  bool reduction_p;\n-  location_t loc;\n-  enum partition_kind kind;\n-  enum partition_type type;\n-  /* Data references in the partition.  */\n-  bitmap datarefs;\n-  /* Information of builtin parition.  */\n-  struct builtin_info *builtin;\n-};\n-\n-\n /* Allocate and initialize a partition from BITMAP.  */\n \n static partition *\n@@ -689,33 +857,9 @@ partition_reduction_p (partition *partition)\n   return partition->reduction_p;\n }\n \n-/* Partitions are fused because of different reasons.  */\n-enum fuse_type\n-{\n-  FUSE_NON_BUILTIN = 0,\n-  FUSE_REDUCTION = 1,\n-  FUSE_SHARE_REF = 2,\n-  FUSE_SAME_SCC = 3,\n-  FUSE_FINALIZE = 4\n-};\n-\n-/* Description on different fusing reason.  */\n-static const char *fuse_message[] = {\n-  \"they are non-builtins\",\n-  \"they have reductions\",\n-  \"they have shared memory refs\",\n-  \"they are in the same dependence scc\",\n-  \"there is no point to distribute loop\"};\n-\n-static void\n-update_type_for_merge (struct graph *, partition *, partition *);\n-\n-/* Merge PARTITION into the partition DEST.  RDG is the reduced dependence\n-   graph and we update type for result partition if it is non-NULL.  */\n-\n-static void\n-partition_merge_into (struct graph *rdg, partition *dest,\n-\t\t      partition *partition, enum fuse_type ft)\n+void\n+loop_distribution::partition_merge_into (struct graph *rdg,\n+\t\t      partition *dest, partition *partition, enum fuse_type ft)\n {\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -1201,13 +1345,9 @@ generate_code_for_partition (class loop *loop,\n   return false;\n }\n \n-/* Return data dependence relation for data references A and B.  The two\n-   data references must be in lexicographic order wrto reduced dependence\n-   graph RDG.  We firstly try to find ddr from global ddr hash table.  If\n-   it doesn't exist, compute the ddr and cache it.  */\n-\n-static data_dependence_relation *\n-get_data_dependence (struct graph *rdg, data_reference_p a, data_reference_p b)\n+data_dependence_relation *\n+loop_distribution::get_data_dependence (struct graph *rdg, data_reference_p a,\n+\t\t\t\t\tdata_reference_p b)\n {\n   struct data_dependence_relation ent, **slot;\n   struct data_dependence_relation *ddr;\n@@ -1228,13 +1368,10 @@ get_data_dependence (struct graph *rdg, data_reference_p a, data_reference_p b)\n   return *slot;\n }\n \n-/* In reduced dependence graph RDG for loop distribution, return true if\n-   dependence between references DR1 and DR2 leads to a dependence cycle\n-   and such dependence cycle can't be resolved by runtime alias check.  */\n-\n-static bool\n-data_dep_in_cycle_p (struct graph *rdg,\n-\t\t     data_reference_p dr1, data_reference_p dr2)\n+bool\n+loop_distribution::data_dep_in_cycle_p (struct graph *rdg,\n+\t\t\t\t\tdata_reference_p dr1,\n+\t\t\t\t\tdata_reference_p dr2)\n {\n   struct data_dependence_relation *ddr;\n \n@@ -1264,12 +1401,10 @@ data_dep_in_cycle_p (struct graph *rdg,\n   return true;\n }\n \n-/* Given reduced dependence graph RDG, PARTITION1 and PARTITION2, update\n-   PARTITION1's type after merging PARTITION2 into PARTITION1.  */\n-\n-static void\n-update_type_for_merge (struct graph *rdg,\n-\t\t       partition *partition1, partition *partition2)\n+void\n+loop_distribution::update_type_for_merge (struct graph *rdg,\n+\t\t\t\t\t   partition *partition1,\n+\t\t\t\t\t   partition *partition2)\n {\n   unsigned i, j;\n   bitmap_iterator bi, bj;\n@@ -1297,11 +1432,8 @@ update_type_for_merge (struct graph *rdg,\n     }\n }\n \n-/* Returns a partition with all the statements needed for computing\n-   the vertex V of the RDG, also including the loop exit conditions.  */\n-\n-static partition *\n-build_rdg_partition_for_vertex (struct graph *rdg, int v)\n+partition *\n+loop_distribution::build_rdg_partition_for_vertex (struct graph *rdg, int v)\n {\n   partition *partition = partition_alloc ();\n   auto_vec<int, 3> nodes;\n@@ -1595,9 +1727,11 @@ classify_builtin_st (loop_p loop, partition *partition, data_reference_p dr)\n /* Given data references DST_DR and SRC_DR in loop nest LOOP and RDG, classify\n    if it forms builtin memcpy or memmove call.  */\n \n-static void\n-classify_builtin_ldst (loop_p loop, struct graph *rdg, partition *partition,\n-\t\t       data_reference_p dst_dr, data_reference_p src_dr)\n+void\n+loop_distribution::classify_builtin_ldst (loop_p loop, struct graph *rdg,\n+\t\t\t\t\t  partition *partition,\n+\t\t\t\t\t  data_reference_p dst_dr,\n+\t\t\t\t\t  data_reference_p src_dr)\n {\n   tree base, size, src_base, src_size;\n   auto_vec<tree> dst_steps, src_steps;\n@@ -1655,15 +1789,10 @@ classify_builtin_ldst (loop_p loop, struct graph *rdg, partition *partition,\n   return;\n }\n \n-/* Classifies the builtin kind we can generate for PARTITION of RDG and LOOP.\n-   For the moment we detect memset, memcpy and memmove patterns.  Bitmap\n-   STMT_IN_ALL_PARTITIONS contains statements belonging to all partitions.\n-   Returns true if there is a reduction in all partitions and we\n-   possibly did not mark PARTITION as having one for this reason.  */\n-\n-static bool\n-classify_partition (loop_p loop, struct graph *rdg, partition *partition,\n-\t\t    bitmap stmt_in_all_partitions)\n+bool\n+loop_distribution::classify_partition (loop_p loop,\n+\t\t\t\t       struct graph *rdg, partition *partition,\n+\t\t\t\t       bitmap stmt_in_all_partitions)\n {\n   bitmap_iterator bi;\n   unsigned i;\n@@ -1721,11 +1850,8 @@ classify_partition (loop_p loop, struct graph *rdg, partition *partition,\n   return has_reduction;\n }\n \n-/* Returns true when PARTITION1 and PARTITION2 access the same memory\n-   object in RDG.  */\n-\n-static bool\n-share_memory_accesses (struct graph *rdg,\n+bool\n+loop_distribution::share_memory_accesses (struct graph *rdg,\n \t\t       partition *partition1, partition *partition2)\n {\n   unsigned i, j;\n@@ -1772,10 +1898,10 @@ share_memory_accesses (struct graph *rdg,\n    partition for it by adding depended statements according to RDG.\n    All partitions are recorded in PARTITIONS.  */\n \n-static void\n-rdg_build_partitions (struct graph *rdg,\n-\t\t      vec<gimple *> starting_stmts,\n-\t\t      vec<partition *> *partitions)\n+void\n+loop_distribution::rdg_build_partitions (struct graph *rdg,\n+\t\t\t\t\t vec<gimple *> starting_stmts,\n+\t\t\t\t\t vec<partition *> *partitions)\n {\n   auto_bitmap processed;\n   int i;\n@@ -1891,14 +2017,8 @@ partition_contains_all_rw (struct graph *rdg,\n   return false;\n }\n \n-/* Compute partition dependence created by the data references in DRS1\n-   and DRS2, modify and return DIR according to that.  IF ALIAS_DDR is\n-   not NULL, we record dependence introduced by possible alias between\n-   two data references in ALIAS_DDRS; otherwise, we simply ignore such\n-   dependence as if it doesn't exist at all.  */\n-\n-static int\n-pg_add_dependence_edges (struct graph *rdg, int dir,\n+int\n+loop_distribution::pg_add_dependence_edges (struct graph *rdg, int dir,\n \t\t\t bitmap drs1, bitmap drs2, vec<ddr_p> *alias_ddrs)\n {\n   unsigned i, j;\n@@ -2114,10 +2234,10 @@ free_partition_graph_vdata (struct graph *pg)\n    is ignored, as if it doesn't exist at all; otherwise all depdendences\n    are considered.  */\n \n-static struct graph *\n-build_partition_graph (struct graph *rdg,\n-\t\t       vec<struct partition *> *partitions,\n-\t\t       bool ignore_alias_p)\n+struct graph *\n+loop_distribution::build_partition_graph (struct graph *rdg,\n+\t\t\t\t\t  vec<struct partition *> *partitions,\n+\t\t\t\t\t  bool ignore_alias_p)\n {\n   int i, j;\n   struct partition *partition1, *partition2;\n@@ -2199,15 +2319,10 @@ sort_partitions_by_post_order (struct graph *pg,\n     }\n }\n \n-/* Given reduced dependence graph RDG merge strong connected components\n-   of PARTITIONS.  If IGNORE_ALIAS_P is true, data dependence caused by\n-   possible alias between references is ignored, as if it doesn't exist\n-   at all; otherwise all depdendences are considered.  */\n-\n-static void\n-merge_dep_scc_partitions (struct graph *rdg,\n-\t\t\t  vec<struct partition *> *partitions,\n-\t\t\t  bool ignore_alias_p)\n+void\n+loop_distribution::merge_dep_scc_partitions (struct graph *rdg,\n+\t\t\t\t\t     vec<struct partition *> *partitions,\n+\t\t\t\t\t     bool ignore_alias_p)\n {\n   struct partition *partition1, *partition2;\n   struct pg_vdata *data;\n@@ -2280,11 +2395,10 @@ pg_collect_alias_ddrs (struct graph *g, struct graph_edge *e, void *data)\n /* This is the main function breaking strong conected components in\n    PARTITIONS giving reduced depdendence graph RDG.  Store data dependence\n    relations for runtime alias check in ALIAS_DDRS.  */\n-\n-static void\n-break_alias_scc_partitions (struct graph *rdg,\n-\t\t\t    vec<struct partition *> *partitions,\n-\t\t\t    vec<ddr_p> *alias_ddrs)\n+void\n+loop_distribution::break_alias_scc_partitions (struct graph *rdg,\n+\t\t\t\t\t       vec<struct partition *> *partitions,\n+\t\t\t\t\t       vec<ddr_p> *alias_ddrs)\n {\n   int i, j, k, num_sccs, num_sccs_no_alias;\n   /* Build partition dependence graph.  */\n@@ -2710,12 +2824,10 @@ fuse_memset_builtins (vec<struct partition *> *partitions)\n     }\n }\n \n-/* Fuse PARTITIONS of LOOP if necessary before finalizing distribution.\n-   ALIAS_DDRS contains ddrs which need runtime alias check.  */\n-\n-static void\n-finalize_partitions (class loop *loop, vec<struct partition *> *partitions,\n-\t\t     vec<ddr_p> *alias_ddrs)\n+void\n+loop_distribution::finalize_partitions (class loop *loop,\n+\t\t\t\t\tvec<struct partition *> *partitions,\n+\t\t\t\t\tvec<ddr_p> *alias_ddrs)\n {\n   unsigned i;\n   struct partition *partition, *a;\n@@ -2770,8 +2882,8 @@ finalize_partitions (class loop *loop, vec<struct partition *> *partitions,\n    distributed loops.  Set NB_CALLS to number of generated builtin calls.\n    Set *DESTROY_P to whether LOOP needs to be destroyed.  */\n \n-static int\n-distribute_loop (class loop *loop, vec<gimple *> stmts,\n+int\n+loop_distribution::distribute_loop (class loop *loop, vec<gimple *> stmts,\n \t\t control_dependences *cd, int *nb_calls, bool *destroy_p,\n \t\t bool only_patterns_p)\n {\n@@ -3011,40 +3123,27 @@ distribute_loop (class loop *loop, vec<gimple *> stmts,\n   return nbp - *nb_calls;\n }\n \n-/* Distribute all loops in the current function.  */\n-\n-namespace {\n \n-const pass_data pass_data_loop_distribution =\n+void loop_distribution::bb_top_order_init (void)\n {\n-  GIMPLE_PASS, /* type */\n-  \"ldist\", /* name */\n-  OPTGROUP_LOOP, /* optinfo_flags */\n-  TV_TREE_LOOP_DISTRIBUTION, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n+  int rpo_num;\n+  int *rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));\n \n-class pass_loop_distribution : public gimple_opt_pass\n-{\n-public:\n-  pass_loop_distribution (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_loop_distribution, ctxt)\n-  {}\n+  bb_top_order_index = XNEWVEC (int, last_basic_block_for_fn (cfun));\n+  bb_top_order_index_size = last_basic_block_for_fn (cfun);\n+  rpo_num = pre_and_rev_post_order_compute_fn (cfun, NULL, rpo, true);\n+  for (int i = 0; i < rpo_num; i++)\n+    bb_top_order_index[rpo[i]] = i;\n \n-  /* opt_pass methods: */\n-  virtual bool gate (function *)\n-    {\n-      return flag_tree_loop_distribution\n-\t|| flag_tree_loop_distribute_patterns;\n-    }\n-\n-  virtual unsigned int execute (function *);\n+  free (rpo);\n+}\n \n-}; // class pass_loop_distribution\n+void loop_distribution::bb_top_order_destroy ()\n+{\n+  free (bb_top_order_index);\n+  bb_top_order_index = NULL;\n+  bb_top_order_index_size = 0;\n+}\n \n \n /* Given LOOP, this function records seed statements for distribution in\n@@ -3131,8 +3230,9 @@ prepare_perfect_loop_nest (class loop *loop)\n   return loop;\n }\n \n+\n unsigned int\n-pass_loop_distribution::execute (function *fun)\n+loop_distribution::execute (function *fun)\n {\n   class loop *loop;\n   bool changed = false;\n@@ -3143,22 +3243,7 @@ pass_loop_distribution::execute (function *fun)\n   if (number_of_loops (fun) <= 1)\n     return 0;\n \n-  /* Compute topological order for basic blocks.  Topological order is\n-     needed because data dependence is computed for data references in\n-     lexicographical order.  */\n-  if (bb_top_order_index == NULL)\n-    {\n-      int rpo_num;\n-      int *rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));\n-\n-      bb_top_order_index = XNEWVEC (int, last_basic_block_for_fn (cfun));\n-      bb_top_order_index_size = last_basic_block_for_fn (cfun);\n-      rpo_num = pre_and_rev_post_order_compute_fn (cfun, NULL, rpo, true);\n-      for (int i = 0; i < rpo_num; i++)\n-\tbb_top_order_index[rpo[i]] = i;\n-\n-      free (rpo);\n-    }\n+  bb_top_order_init ();\n \n   FOR_ALL_BB_FN (bb, fun)\n     {\n@@ -3233,11 +3318,7 @@ pass_loop_distribution::execute (function *fun)\n     delete cd;\n \n   if (bb_top_order_index != NULL)\n-    {\n-      free (bb_top_order_index);\n-      bb_top_order_index = NULL;\n-      bb_top_order_index_size = 0;\n-    }\n+    bb_top_order_destroy ();\n \n   if (changed)\n     {\n@@ -3259,6 +3340,48 @@ pass_loop_distribution::execute (function *fun)\n   return changed ? TODO_cleanup_cfg : 0;\n }\n \n+\n+/* Distribute all loops in the current function.  */\n+\n+namespace {\n+\n+const pass_data pass_data_loop_distribution =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"ldist\", /* name */\n+  OPTGROUP_LOOP, /* optinfo_flags */\n+  TV_TREE_LOOP_DISTRIBUTION, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_loop_distribution : public gimple_opt_pass\n+{\n+public:\n+  pass_loop_distribution (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_loop_distribution, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return flag_tree_loop_distribution\n+\t|| flag_tree_loop_distribute_patterns;\n+    }\n+\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_loop_distribution\n+\n+unsigned int\n+pass_loop_distribution::execute (function *fun)\n+{\n+  return loop_distribution ().execute (fun);\n+}\n+\n } // anon namespace\n \n gimple_opt_pass *"}]}