{"sha": "7f070fc469c71b0d3e435cf23964b6de7cd9943e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YwNzBmYzQ2OWM3MWIwZDNlNDM1Y2YyMzk2NGI2ZGU3Y2Q5OTQzZQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2019-07-01T13:34:55Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-01T13:34:55Z"}, "message": "[Ada] Clean up of GNAT.Dynamic_HTables\n\n------------\n-- Source --\n------------\n\n--  operations.adb\n\nwith Ada.Text_IO;          use Ada.Text_IO;\nwith GNAT;                 use GNAT;\nwith GNAT.Dynamic_HTables; use GNAT.Dynamic_HTables;\n\nprocedure Operations is\n   procedure Destroy (Val : in out Integer) is null;\n   function Hash (Key : Integer) return Bucket_Range_Type;\n\n   package DHT is new Dynamic_Hash_Tables\n     (Key_Type              => Integer,\n      Value_Type            => Integer,\n      No_Value              => 0,\n      Expansion_Threshold   => 1.3,\n      Expansion_Factor      => 2,\n      Compression_Threshold => 0.3,\n      Compression_Factor    => 2,\n      \"=\"                   => \"=\",\n      Destroy_Value         => Destroy,\n      Hash                  => Hash);\n   use DHT;\n\n   function Create_And_Populate\n     (Low_Key   : Integer;\n      High_Key  : Integer;\n      Init_Size : Positive) return Dynamic_Hash_Table;\n   --  Create a hash table with initial size Init_Size and populate it with\n   --  key-value pairs where both keys and values are in the range Low_Key\n   --  .. High_Key.\n\n   procedure Check_Empty\n     (Caller    : String;\n      T         : Dynamic_Hash_Table;\n      Low_Key   : Integer;\n      High_Key  : Integer);\n   --  Ensure that\n   --\n   --    * The key-value pairs count of hash table T is 0.\n   --    * All values for the keys in range Low_Key .. High_Key are 0.\n\n   procedure Check_Keys\n     (Caller   : String;\n      Iter     : in out Iterator;\n      Low_Key  : Integer;\n      High_Key : Integer);\n   --  Ensure that iterator Iter visits every key in the range Low_Key ..\n   --  High_Key exactly once.\n\n   procedure Check_Locked_Mutations\n     (Caller : String;\n      T      : in out Dynamic_Hash_Table);\n   --  Ensure that all mutation operations of hash table T are locked\n\n   procedure Check_Size\n     (Caller    : String;\n      T         : Dynamic_Hash_Table;\n      Exp_Count : Natural);\n   --  Ensure that the count of key-value pairs of hash table T matches\n   --  expected count Exp_Count. Emit an error if this is not the case.\n\n   procedure Test_Create (Init_Size : Positive);\n   --  Verify that all dynamic hash table operations fail on a non-created\n   --  table of size Init_Size.\n\n   procedure Test_Delete_Get_Put_Size\n     (Low_Key   : Integer;\n      High_Key  : Integer;\n      Exp_Count : Natural;\n      Init_Size : Positive);\n   --  Verify that\n   --\n   --    * Put properly inserts values in the hash table.\n   --    * Get properly retrieves all values inserted in the table.\n   --    * Delete properly deletes values.\n   --    * The size of the hash table properly reflects the number of key-value\n   --      pairs.\n   --\n   --  Low_Key and High_Key denote the range of keys to be inserted, retrieved,\n   --  and deleted. Exp_Count is the expected count of key-value pairs n the\n   --  hash table. Init_Size denotes the initial size of the table.\n\n   procedure Test_Iterate\n     (Low_Key   : Integer;\n      High_Key  : Integer;\n      Init_Size : Positive);\n   --  Verify that iterators\n   --\n   --    * Properly visit each key exactly once.\n   --    * Mutation operations are properly locked and unlocked during\n   --      iteration.\n   --\n   --  Low_Key and High_Key denote the range of keys to be inserted, retrieved,\n   --  and deleted. Init_Size denotes the initial size of the table.\n\n   procedure Test_Iterate_Empty (Init_Size : Positive);\n   --  Verify that an iterator over an empty hash table\n   --\n   --    * Does not visit any key\n   --    * Mutation operations are properly locked and unlocked during\n   --      iteration.\n   --\n   --  Init_Size denotes the initial size of the table.\n\n   procedure Test_Iterate_Forced\n     (Low_Key   : Integer;\n      High_Key  : Integer;\n      Init_Size : Positive);\n   --  Verify that an iterator that is forcefully advanced by just Next\n   --\n   --    * Properly visit each key exactly once.\n   --    * Mutation operations are properly locked and unlocked during\n   --      iteration.\n   --\n   --  Low_Key and High_Key denote the range of keys to be inserted, retrieved,\n   --  and deleted. Init_Size denotes the initial size of the table.\n\n   procedure Test_Replace\n     (Low_Val   : Integer;\n      High_Val  : Integer;\n      Init_Size : Positive);\n   --  Verify that Put properly updates the value of a particular key. Low_Val\n   --  and High_Val denote the range of values to be updated. Init_Size denotes\n   --  the initial size of the table.\n\n   procedure Test_Reset\n     (Low_Key   : Integer;\n      High_Key  : Integer;\n      Init_Size : Positive);\n   --  Verify that Reset properly destroy and recreats a hash table. Low_Key\n   --  and High_Key denote the range of keys to be inserted in the hash table.\n   --  Init_Size denotes the initial size of the table.\n\n   -------------------------\n   -- Create_And_Populate --\n   -------------------------\n\n   function Create_And_Populate\n     (Low_Key   : Integer;\n      High_Key  : Integer;\n      Init_Size : Positive) return Dynamic_Hash_Table\n   is\n      T : Dynamic_Hash_Table;\n\n   begin\n      T := Create (Init_Size);\n\n      for Key in Low_Key .. High_Key loop\n         Put (T, Key, Key);\n      end loop;\n\n      return T;\n   end Create_And_Populate;\n\n   -----------------\n   -- Check_Empty --\n   -----------------\n\n   procedure Check_Empty\n     (Caller    : String;\n      T         : Dynamic_Hash_Table;\n      Low_Key   : Integer;\n      High_Key  : Integer)\n   is\n      Val : Integer;\n\n   begin\n      Check_Size\n        (Caller    => Caller,\n         T         => T,\n         Exp_Count => 0);\n\n      for Key in Low_Key .. High_Key loop\n         Val := Get (T, Key);\n\n         if Val /= 0 then\n            Put_Line (\"ERROR: \" & Caller & \": wrong value\");\n            Put_Line (\"expected: 0\");\n            Put_Line (\"got     :\" & Val'Img);\n         end if;\n      end loop;\n   end Check_Empty;\n\n   ----------------\n   -- Check_Keys --\n   ----------------\n\n   procedure Check_Keys\n     (Caller   : String;\n      Iter     : in out Iterator;\n      Low_Key  : Integer;\n      High_Key : Integer)\n   is\n      type Bit_Vector is array (Low_Key .. High_Key) of Boolean;\n      pragma Pack (Bit_Vector);\n\n      Count : Natural;\n      Key   : Integer;\n      Seen  : Bit_Vector := (others => False);\n\n   begin\n      --  Compute the number of outstanding keys that have to be iterated on\n\n      Count := High_Key - Low_Key + 1;\n\n      while Has_Next (Iter) loop\n         Next (Iter, Key);\n\n         if Seen (Key) then\n            Put_Line\n              (\"ERROR: \" & Caller & \": Check_Keys: duplicate key\" & Key'Img);\n         else\n            Seen (Key) := True;\n            Count := Count - 1;\n         end if;\n      end loop;\n\n      --  In the end, all keys must have been iterated on\n\n      if Count /= 0 then\n         for Key in Seen'Range loop\n            if not Seen (Key) then\n               Put_Line\n                 (\"ERROR: \" & Caller & \": Check_Keys: missing key\" & Key'Img);\n            end if;\n         end loop;\n      end if;\n   end Check_Keys;\n\n   ----------------------------\n   -- Check_Locked_Mutations --\n   ----------------------------\n\n   procedure Check_Locked_Mutations\n     (Caller : String;\n      T      : in out Dynamic_Hash_Table)\n   is\n   begin\n      begin\n         Delete (T, 1);\n         Put_Line (\"ERROR: \" & Caller & \": Delete: no exception raised\");\n      exception\n         when Iterated =>\n            null;\n         when others =>\n           Put_Line (\"ERROR: \" & Caller & \": Delete: unexpected exception\");\n      end;\n\n      begin\n         Destroy (T);\n         Put_Line (\"ERROR: \" & Caller & \": Destroy: no exception raised\");\n      exception\n         when Iterated =>\n            null;\n         when others =>\n           Put_Line (\"ERROR: \" & Caller & \": Destroy: unexpected exception\");\n      end;\n\n      begin\n         Put (T, 1, 1);\n         Put_Line (\"ERROR: \" & Caller & \": Put: no exception raised\");\n      exception\n         when Iterated =>\n            null;\n         when others =>\n           Put_Line (\"ERROR: \" & Caller & \": Put: unexpected exception\");\n      end;\n\n      begin\n         Reset (T);\n         Put_Line (\"ERROR: \" & Caller & \": Reset: no exception raised\");\n      exception\n         when Iterated =>\n            null;\n         when others =>\n           Put_Line (\"ERROR: \" & Caller & \": Reset: unexpected exception\");\n      end;\n   end Check_Locked_Mutations;\n\n   ----------------\n   -- Check_Size --\n   ----------------\n\n   procedure Check_Size\n     (Caller    : String;\n      T         : Dynamic_Hash_Table;\n      Exp_Count : Natural)\n   is\n      Count : constant Natural := Size (T);\n\n   begin\n      if Count /= Exp_Count then\n         Put_Line (\"ERROR: \" & Caller & \": Size: wrong value\");\n         Put_Line (\"expected:\" & Exp_Count'Img);\n         Put_Line (\"got     :\" & Count'Img);\n      end if;\n   end Check_Size;\n\n   ----------\n   -- Hash --\n   ----------\n\n   function Hash (Key : Integer) return Bucket_Range_Type is\n   begin\n      return Bucket_Range_Type (Key);\n   end Hash;\n\n   -----------------\n   -- Test_Create --\n   -----------------\n\n   procedure Test_Create (Init_Size : Positive) is\n      Count : Natural;\n      Iter  : Iterator;\n      T     : Dynamic_Hash_Table;\n      Val   : Integer;\n\n   begin\n      --  Ensure that every routine defined in the API fails on a hash table\n      --  which has not been created yet.\n\n      begin\n         Delete (T, 1);\n         Put_Line (\"ERROR: Test_Create: Delete: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n           Put_Line (\"ERROR: Test_Create: Delete: unexpected exception\");\n      end;\n\n      begin\n         Destroy (T);\n         Put_Line (\"ERROR: Test_Create: Destroy: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n           Put_Line (\"ERROR: Test_Create: Destroy: unexpected exception\");\n      end;\n\n      begin\n         Val := Get (T, 1);\n         Put_Line (\"ERROR: Test_Create: Get: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n           Put_Line (\"ERROR: Test_Create: Get: unexpected exception\");\n      end;\n\n      begin\n         Iter := Iterate (T);\n         Put_Line (\"ERROR: Test_Create: Iterate: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n           Put_Line (\"ERROR: Test_Create: Iterate: unexpected exception\");\n      end;\n\n      begin\n         Put (T, 1, 1);\n         Put_Line (\"ERROR: Test_Create: Put: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n           Put_Line (\"ERROR: Test_Create: Put: unexpected exception\");\n      end;\n\n      begin\n         Reset (T);\n         Put_Line (\"ERROR: Test_Create: Reset: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n           Put_Line (\"ERROR: Test_Create: Reset: unexpected exception\");\n      end;\n\n      begin\n         Count := Size (T);\n         Put_Line (\"ERROR: Test_Create: Size: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n           Put_Line (\"ERROR: Test_Create: Size: unexpected exception\");\n      end;\n\n      --  Test create\n\n      T := Create (Init_Size);\n\n      --  Clean up the hash table to prevent memory leaks\n\n      Destroy (T);\n   end Test_Create;\n\n   ------------------------------\n   -- Test_Delete_Get_Put_Size --\n   ------------------------------\n\n   procedure Test_Delete_Get_Put_Size\n     (Low_Key   : Integer;\n      High_Key  : Integer;\n      Exp_Count : Natural;\n      Init_Size : Positive)\n   is\n      Exp_Val : Integer;\n      T       : Dynamic_Hash_Table;\n      Val     : Integer;\n\n   begin\n      T := Create_And_Populate (Low_Key, High_Key, Init_Size);\n\n      --  Ensure that its size matches an expected value\n\n      Check_Size\n        (Caller    => \"Test_Delete_Get_Put_Size\",\n         T         => T,\n         Exp_Count => Exp_Count);\n\n      --  Ensure that every value for the range of keys exists\n\n      for Key in Low_Key .. High_Key loop\n         Val := Get (T, Key);\n\n         if Val /= Key then\n            Put_Line (\"ERROR: Test_Delete_Get_Put_Size: Get: wrong value\");\n            Put_Line (\"expected:\" & Key'Img);\n            Put_Line (\"got     :\" & Val'Img);\n         end if;\n      end loop;\n\n      --  Delete values whose keys are divisible by 10\n\n      for Key in Low_Key .. High_Key loop\n         if Key mod 10 = 0 then\n            Delete (T, Key);\n         end if;\n      end loop;\n\n      --  Ensure that all values whose keys were not deleted still exist\n\n      for Key in Low_Key .. High_Key loop\n         if Key mod 10 = 0 then\n            Exp_Val := 0;\n         else\n            Exp_Val := Key;\n         end if;\n\n         Val := Get (T, Key);\n\n         if Val /= Exp_Val then\n            Put_Line (\"ERROR: Test_Delete_Get_Put_Size: Get: wrong value\");\n            Put_Line (\"expected:\" & Exp_Val'Img);\n            Put_Line (\"got     :\" & Val'Img);\n         end if;\n      end loop;\n\n      --  Delete all values\n\n      for Key in Low_Key .. High_Key loop\n         Delete (T, Key);\n      end loop;\n\n      --  Ensure that the hash table is empty\n\n      Check_Empty\n        (Caller   => \"Test_Delete_Get_Put_Size\",\n         T        => T,\n         Low_Key  => Low_Key,\n         High_Key => High_Key);\n\n      --  Clean up the hash table to prevent memory leaks\n\n      Destroy (T);\n   end Test_Delete_Get_Put_Size;\n\n   ------------------\n   -- Test_Iterate --\n   ------------------\n\n   procedure Test_Iterate\n     (Low_Key   : Integer;\n      High_Key  : Integer;\n      Init_Size : Positive)\n   is\n      Iter_1 : Iterator;\n      Iter_2 : Iterator;\n      T      : Dynamic_Hash_Table;\n\n   begin\n      T := Create_And_Populate (Low_Key, High_Key, Init_Size);\n\n      --  Obtain an iterator. This action must lock all mutation operations of\n      --  the hash table.\n\n      Iter_1 := Iterate (T);\n\n      --  Ensure that every mutation routine defined in the API fails on a hash\n      --  table with at least one outstanding iterator.\n\n      Check_Locked_Mutations\n        (Caller => \"Test_Iterate\",\n         T      => T);\n\n      --  Obtain another iterator\n\n      Iter_2 := Iterate (T);\n\n      --  Ensure that every mutation is still locked\n\n      Check_Locked_Mutations\n        (Caller => \"Test_Iterate\",\n         T      => T);\n\n      --  Ensure that all keys are iterable. Note that this does not unlock the\n      --  mutation operations of the hash table because Iter_2 is not exhausted\n      --  yet.\n\n      Check_Keys\n        (Caller   => \"Test_Iterate\",\n         Iter     => Iter_1,\n         Low_Key  => Low_Key,\n         High_Key => High_Key);\n\n      Check_Locked_Mutations\n        (Caller => \"Test_Iterate\",\n         T      => T);\n\n      --  Ensure that all keys are iterable. This action unlocks all mutation\n      --  operations of the hash table because all outstanding iterators have\n      --  been exhausted.\n\n      Check_Keys\n        (Caller   => \"Test_Iterate\",\n         Iter     => Iter_2,\n         Low_Key  => Low_Key,\n         High_Key => High_Key);\n\n      --  Ensure that all mutation operations are once again callable\n\n      Delete (T, Low_Key);\n      Put (T, Low_Key, Low_Key);\n      Reset (T);\n\n      --  Clean up the hash table to prevent memory leaks\n\n      Destroy (T);\n   end Test_Iterate;\n\n   ------------------------\n   -- Test_Iterate_Empty --\n   ------------------------\n\n   procedure Test_Iterate_Empty (Init_Size : Positive) is\n      Iter : Iterator;\n      Key  : Integer;\n      T    : Dynamic_Hash_Table;\n\n   begin\n      T := Create_And_Populate (0, -1, Init_Size);\n\n      --  Obtain an iterator. This action must lock all mutation operations of\n      --  the hash table.\n\n      Iter := Iterate (T);\n\n      --  Ensure that every mutation routine defined in the API fails on a hash\n      --  table with at least one outstanding iterator.\n\n      Check_Locked_Mutations\n        (Caller => \"Test_Iterate_Empty\",\n         T      => T);\n\n      --  Attempt to iterate over the keys\n\n      while Has_Next (Iter) loop\n         Next (Iter, Key);\n\n         Put_Line (\"ERROR: Test_Iterate_Empty: key\" & Key'Img & \" exists\");\n      end loop;\n\n      --  Ensure that all mutation operations are once again callable\n\n      Delete (T, 1);\n      Put (T, 1, 1);\n      Reset (T);\n\n      --  Clean up the hash table to prevent memory leaks\n\n      Destroy (T);\n   end Test_Iterate_Empty;\n\n   -------------------------\n   -- Test_Iterate_Forced --\n   -------------------------\n\n   procedure Test_Iterate_Forced\n     (Low_Key   : Integer;\n      High_Key  : Integer;\n      Init_Size : Positive)\n   is\n      Iter : Iterator;\n      Key  : Integer;\n      T    : Dynamic_Hash_Table;\n\n   begin\n      T := Create_And_Populate (Low_Key, High_Key, Init_Size);\n\n      --  Obtain an iterator. This action must lock all mutation operations of\n      --  the hash table.\n\n      Iter := Iterate (T);\n\n      --  Ensure that every mutation routine defined in the API fails on a hash\n      --  table with at least one outstanding iterator.\n\n      Check_Locked_Mutations\n        (Caller => \"Test_Iterate_Forced\",\n         T      => T);\n\n      --  Forcibly advance the iterator until it raises an exception\n\n      begin\n         for Guard in Low_Key .. High_Key + 1 loop\n            Next (Iter, Key);\n         end loop;\n\n         Put_Line\n           (\"ERROR: Test_Iterate_Forced: Iterator_Exhausted not raised\");\n      exception\n         when Iterator_Exhausted =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Iterate_Forced: unexpected exception\");\n      end;\n\n      --  Ensure that all mutation operations are once again callable\n\n      Delete (T, Low_Key);\n      Put (T, Low_Key, Low_Key);\n      Reset (T);\n\n      --  Clean up the hash table to prevent memory leaks\n\n      Destroy (T);\n   end Test_Iterate_Forced;\n\n   ------------------\n   -- Test_Replace --\n   ------------------\n\n   procedure Test_Replace\n     (Low_Val   : Integer;\n      High_Val  : Integer;\n      Init_Size : Positive)\n   is\n      Key : constant Integer := 1;\n      T   : Dynamic_Hash_Table;\n      Val : Integer;\n\n   begin\n      T := Create (Init_Size);\n\n      --  Ensure the Put properly updates values with the same key\n\n      for Exp_Val in Low_Val .. High_Val loop\n         Put (T, Key, Exp_Val);\n\n         Val := Get (T, Key);\n\n         if Val /= Exp_Val then\n            Put_Line (\"ERROR: Test_Replace: Get: wrong value\");\n            Put_Line (\"expected:\" & Exp_Val'Img);\n            Put_Line (\"got     :\" & Val'Img);\n         end if;\n      end loop;\n\n      --  Clean up the hash table to prevent memory leaks\n\n      Destroy (T);\n   end Test_Replace;\n\n   ----------------\n   -- Test_Reset --\n   ----------------\n\n   procedure Test_Reset\n     (Low_Key   : Integer;\n      High_Key  : Integer;\n      Init_Size : Positive)\n   is\n      T : Dynamic_Hash_Table;\n\n   begin\n      T := Create_And_Populate (Low_Key, High_Key, Init_Size);\n\n      --  Reset the contents of the hash table\n\n      Reset (T);\n\n      --  Ensure that the hash table is empty\n\n      Check_Empty\n        (Caller   => \"Test_Reset\",\n         T        => T,\n         Low_Key  => Low_Key,\n         High_Key => High_Key);\n\n      --  Clean up the hash table to prevent memory leaks\n\n      Destroy (T);\n   end Test_Reset;\n\n--  Start of processing for Operations\n\nbegin\n   Test_Create (Init_Size => 1);\n   Test_Create (Init_Size => 100);\n\n   Test_Delete_Get_Put_Size\n     (Low_Key   => 1,\n      High_Key  => 1,\n      Exp_Count => 1,\n      Init_Size => 1);\n\n   Test_Delete_Get_Put_Size\n     (Low_Key   => 1,\n      High_Key  => 1000,\n      Exp_Count => 1000,\n      Init_Size => 32);\n\n   Test_Iterate\n     (Low_Key   => 1,\n      High_Key  => 32,\n      Init_Size => 32);\n\n   Test_Iterate_Empty (Init_Size => 32);\n\n   Test_Iterate_Forced\n     (Low_Key   => 1,\n      High_Key  => 32,\n      Init_Size => 32);\n\n   Test_Replace\n     (Low_Val   => 1,\n      High_Val  => 10,\n      Init_Size => 32);\n\n   Test_Reset\n     (Low_Key   => 1,\n      High_Key  => 1000,\n      Init_Size => 100);\nend Operations;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gnatmake -q operations.adb -largs -lgmem\n$ ./operations\n$ gnatmem operations > leaks.txt\n$ grep -c \"non freed allocations\" leaks.txt\n0\n\n2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/g-dynhta.adb: Use type Dynamic_Hash_Table rather than\n\tInstance in various routines.\n\t* libgnat/g-dynhta.ads: Change type Instance to\n\tDynamic_Hash_Table. Update various routines that mention the\n\ttype.\n\ngcc/testsuite/\n\n\t* gnat.dg/dynhash.adb, gnat.dg/dynhash1.adb: Update.\n\nFrom-SVN: r272860", "tree": {"sha": "8bd656f2847fec5157f09040944b427b132db2ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bd656f2847fec5157f09040944b427b132db2ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f070fc469c71b0d3e435cf23964b6de7cd9943e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f070fc469c71b0d3e435cf23964b6de7cd9943e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f070fc469c71b0d3e435cf23964b6de7cd9943e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f070fc469c71b0d3e435cf23964b6de7cd9943e/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "68f27c97bff2d21c107ca90e1b597fed45b52ba5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68f27c97bff2d21c107ca90e1b597fed45b52ba5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68f27c97bff2d21c107ca90e1b597fed45b52ba5"}], "stats": {"total": 205, "additions": 128, "deletions": 77}, "files": [{"sha": "c527b80bc36d473854f936bfd88c031955f41f24", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f070fc469c71b0d3e435cf23964b6de7cd9943e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f070fc469c71b0d3e435cf23964b6de7cd9943e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7f070fc469c71b0d3e435cf23964b6de7cd9943e", "patch": "@@ -1,3 +1,11 @@\n+2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* libgnat/g-dynhta.adb: Use type Dynamic_Hash_Table rather than\n+\tInstance in various routines.\n+\t* libgnat/g-dynhta.ads: Change type Instance to\n+\tDynamic_Hash_Table. Update various routines that mention the\n+\ttype.\n+\n 2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_attr.adb, exp_ch7.adb, exp_unst.adb, sem_ch3.adb,"}, {"sha": "6cb4182d979188fc90a0a7e33cf39021834ecfef", "filename": "gcc/ada/libgnat/g-dynhta.adb", "status": "modified", "additions": 57, "deletions": 36, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f070fc469c71b0d3e435cf23964b6de7cd9943e/gcc%2Fada%2Flibgnat%2Fg-dynhta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f070fc469c71b0d3e435cf23964b6de7cd9943e/gcc%2Fada%2Flibgnat%2Fg-dynhta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-dynhta.adb?ref=7f070fc469c71b0d3e435cf23964b6de7cd9943e", "patch": "@@ -364,11 +364,11 @@ package body GNAT.Dynamic_HTables is\n       end Set_Next;\n    end Simple_HTable;\n \n-   --------------------\n-   -- Dynamic_HTable --\n-   --------------------\n+   -------------------------\n+   -- Dynamic_Hash_Tables --\n+   -------------------------\n \n-   package body Dynamic_HTable is\n+   package body Dynamic_Hash_Tables is\n       Minimum_Size : constant Bucket_Range_Type := 8;\n       --  Minimum size of the buckets\n \n@@ -382,7 +382,9 @@ package body GNAT.Dynamic_HTables is\n       --  Maximum safe size for hash table expansion. Beyond this size, an\n       --  expansion will overflow the buckets.\n \n-      procedure Delete_Node (T : Instance; Nod : Node_Ptr);\n+      procedure Delete_Node\n+        (T   : Dynamic_Hash_Table;\n+         Nod : Node_Ptr);\n       pragma Inline (Delete_Node);\n       --  Detach and delete node Nod from table T\n \n@@ -398,12 +400,12 @@ package body GNAT.Dynamic_HTables is\n       pragma Inline (Ensure_Circular);\n       --  Ensure that dummy head Head is circular with respect to itself\n \n-      procedure Ensure_Created (T : Instance);\n+      procedure Ensure_Created (T : Dynamic_Hash_Table);\n       pragma Inline (Ensure_Created);\n       --  Verify that hash table T is created. Raise Not_Created if this is not\n       --  the case.\n \n-      procedure Ensure_Unlocked (T : Instance);\n+      procedure Ensure_Unlocked (T : Dynamic_Hash_Table);\n       pragma Inline (Ensure_Unlocked);\n       --  Verify that hash table T is unlocked. Raise Iterated if this is not\n       --  the case.\n@@ -422,7 +424,7 @@ package body GNAT.Dynamic_HTables is\n       --  otherwise return null.\n \n       procedure First_Valid_Node\n-        (T        : Instance;\n+        (T        : Dynamic_Hash_Table;\n          Low_Bkt  : Bucket_Range_Type;\n          High_Bkt : Bucket_Range_Type;\n          Idx      : out Bucket_Range_Type;\n@@ -437,7 +439,8 @@ package body GNAT.Dynamic_HTables is\n         new Ada.Unchecked_Deallocation (Bucket_Table, Bucket_Table_Ptr);\n \n       procedure Free is\n-        new Ada.Unchecked_Deallocation (Hash_Table, Instance);\n+        new Ada.Unchecked_Deallocation\n+              (Dynamic_Hash_Table_Attributes, Dynamic_Hash_Table);\n \n       procedure Free is\n         new Ada.Unchecked_Deallocation (Node, Node_Ptr);\n@@ -451,15 +454,17 @@ package body GNAT.Dynamic_HTables is\n       --  Determine whether node Nod is non-null and does not refer to dummy\n       --  head Head, thus making it valid.\n \n-      function Load_Factor (T : Instance) return Threshold_Type;\n+      function Load_Factor (T : Dynamic_Hash_Table) return Threshold_Type;\n       pragma Inline (Load_Factor);\n       --  Calculate the load factor of hash table T\n \n-      procedure Lock (T : Instance);\n+      procedure Lock (T : Dynamic_Hash_Table);\n       pragma Inline (Lock);\n       --  Lock all mutation functionality of hash table T\n \n-      procedure Mutate_And_Rehash (T : Instance; Size : Bucket_Range_Type);\n+      procedure Mutate_And_Rehash\n+        (T    : Dynamic_Hash_Table;\n+         Size : Bucket_Range_Type);\n       pragma Inline (Mutate_And_Rehash);\n       --  Replace the buckets of hash table T with a new set of buckets of size\n       --  Size. Rehash all key-value pairs from the old to the new buckets.\n@@ -476,21 +481,21 @@ package body GNAT.Dynamic_HTables is\n       pragma Inline (Present);\n       --  Determine whether node Nod exists\n \n-      procedure Unlock (T : Instance);\n+      procedure Unlock (T : Dynamic_Hash_Table);\n       pragma Inline (Unlock);\n       --  Unlock all mutation functionality of hash table T\n \n       ------------\n       -- Create --\n       ------------\n \n-      function Create (Initial_Size : Positive) return Instance is\n+      function Create (Initial_Size : Positive) return Dynamic_Hash_Table is\n          Size : constant Bucket_Range_Type :=\n                            Bucket_Range_Type'Max\n                              (Bucket_Range_Type (Initial_Size), Minimum_Size);\n          --  Ensure that the buckets meet a minimum size\n \n-         T : constant Instance := new Hash_Table;\n+         T : constant Dynamic_Hash_Table := new Dynamic_Hash_Table_Attributes;\n \n       begin\n          T.Buckets      := new Bucket_Table (0 .. Size - 1);\n@@ -503,7 +508,10 @@ package body GNAT.Dynamic_HTables is\n       -- Delete --\n       ------------\n \n-      procedure Delete (T : Instance; Key : Key_Type) is\n+      procedure Delete\n+        (T   : Dynamic_Hash_Table;\n+         Key : Key_Type)\n+      is\n          Head : Node_Ptr;\n          Nod  : Node_Ptr;\n \n@@ -531,7 +539,10 @@ package body GNAT.Dynamic_HTables is\n       -- Delete_Node --\n       -----------------\n \n-      procedure Delete_Node (T : Instance; Nod : Node_Ptr) is\n+      procedure Delete_Node\n+        (T   : Dynamic_Hash_Table;\n+         Nod : Node_Ptr)\n+      is\n          procedure Compress;\n          pragma Inline (Compress);\n          --  Determine whether hash table T requires compression, and if so,\n@@ -586,7 +597,7 @@ package body GNAT.Dynamic_HTables is\n       -- Destroy --\n       -------------\n \n-      procedure Destroy (T : in out Instance) is\n+      procedure Destroy (T : in out Dynamic_Hash_Table) is\n       begin\n          Ensure_Created  (T);\n          Ensure_Unlocked (T);\n@@ -678,7 +689,7 @@ package body GNAT.Dynamic_HTables is\n       -- Ensure_Created --\n       --------------------\n \n-      procedure Ensure_Created (T : Instance) is\n+      procedure Ensure_Created (T : Dynamic_Hash_Table) is\n       begin\n          if not Present (T) then\n             raise Not_Created;\n@@ -689,7 +700,7 @@ package body GNAT.Dynamic_HTables is\n       -- Ensure_Unlocked --\n       ---------------------\n \n-      procedure Ensure_Unlocked (T : Instance) is\n+      procedure Ensure_Unlocked (T : Dynamic_Hash_Table) is\n       begin\n          pragma Assert (Present (T));\n \n@@ -746,7 +757,7 @@ package body GNAT.Dynamic_HTables is\n       ----------------------\n \n       procedure First_Valid_Node\n-        (T        : Instance;\n+        (T        : Dynamic_Hash_Table;\n          Low_Bkt  : Bucket_Range_Type;\n          High_Bkt : Bucket_Range_Type;\n          Idx      : out Bucket_Range_Type;\n@@ -784,7 +795,10 @@ package body GNAT.Dynamic_HTables is\n       -- Get --\n       ---------\n \n-      function Get (T : Instance; Key : Key_Type) return Value_Type is\n+      function Get\n+        (T   : Dynamic_Hash_Table;\n+         Key : Key_Type) return Value_Type\n+      is\n          Head : Node_Ptr;\n          Nod  : Node_Ptr;\n \n@@ -814,8 +828,8 @@ package body GNAT.Dynamic_HTables is\n       --------------\n \n       function Has_Next (Iter : Iterator) return Boolean is\n-         Is_OK : constant Boolean  := Is_Valid (Iter);\n-         T     : constant Instance := Iter.Table;\n+         Is_OK : constant Boolean := Is_Valid (Iter);\n+         T     : constant Dynamic_Hash_Table := Iter.Table;\n \n       begin\n          pragma Assert (Present (T));\n@@ -835,7 +849,7 @@ package body GNAT.Dynamic_HTables is\n       -- Is_Empty --\n       --------------\n \n-      function Is_Empty (T : Instance) return Boolean is\n+      function Is_Empty (T : Dynamic_Hash_Table) return Boolean is\n       begin\n          Ensure_Created (T);\n \n@@ -870,7 +884,7 @@ package body GNAT.Dynamic_HTables is\n       -- Iterate --\n       -------------\n \n-      function Iterate (T : Instance) return Iterator is\n+      function Iterate (T : Dynamic_Hash_Table) return Iterator is\n          Iter : Iterator;\n \n       begin\n@@ -906,7 +920,7 @@ package body GNAT.Dynamic_HTables is\n       -- Load_Factor --\n       -----------------\n \n-      function Load_Factor (T : Instance) return Threshold_Type is\n+      function Load_Factor (T : Dynamic_Hash_Table) return Threshold_Type is\n          pragma Assert (Present (T));\n          pragma Assert (Present (T.Buckets));\n \n@@ -920,7 +934,7 @@ package body GNAT.Dynamic_HTables is\n       -- Lock --\n       ----------\n \n-      procedure Lock (T : Instance) is\n+      procedure Lock (T : Dynamic_Hash_Table) is\n       begin\n          --  The hash table may be locked multiple times if multiple iterators\n          --  are operating over it.\n@@ -932,7 +946,10 @@ package body GNAT.Dynamic_HTables is\n       -- Mutate_And_Rehash --\n       -----------------------\n \n-      procedure Mutate_And_Rehash (T : Instance; Size : Bucket_Range_Type) is\n+      procedure Mutate_And_Rehash\n+        (T    : Dynamic_Hash_Table;\n+         Size : Bucket_Range_Type)\n+      is\n          procedure Rehash (From : Bucket_Table_Ptr; To : Bucket_Table_Ptr);\n          pragma Inline (Rehash);\n          --  Remove all nodes from buckets From and rehash them into buckets To\n@@ -1031,7 +1048,7 @@ package body GNAT.Dynamic_HTables is\n       procedure Next (Iter : in out Iterator; Key : out Key_Type) is\n          Is_OK : constant Boolean  := Is_Valid (Iter);\n          Saved : constant Node_Ptr := Iter.Curr_Nod;\n-         T     : constant Instance := Iter.Table;\n+         T     : constant Dynamic_Hash_Table := Iter.Table;\n          Head  : Node_Ptr;\n \n       begin\n@@ -1109,7 +1126,7 @@ package body GNAT.Dynamic_HTables is\n       -- Present --\n       -------------\n \n-      function Present (T : Instance) return Boolean is\n+      function Present (T : Dynamic_Hash_Table) return Boolean is\n       begin\n          return T /= Nil;\n       end Present;\n@@ -1118,7 +1135,11 @@ package body GNAT.Dynamic_HTables is\n       -- Put --\n       ---------\n \n-      procedure Put (T : Instance; Key : Key_Type; Value : Value_Type) is\n+      procedure Put\n+        (T     : Dynamic_Hash_Table;\n+         Key   : Key_Type;\n+         Value : Value_Type)\n+      is\n          procedure Expand;\n          pragma Inline (Expand);\n          --  Determine whether hash table T requires expansion, and if so,\n@@ -1223,7 +1244,7 @@ package body GNAT.Dynamic_HTables is\n       -- Reset --\n       -----------\n \n-      procedure Reset (T : Instance) is\n+      procedure Reset (T : Dynamic_Hash_Table) is\n       begin\n          Ensure_Created  (T);\n          Ensure_Unlocked (T);\n@@ -1243,7 +1264,7 @@ package body GNAT.Dynamic_HTables is\n       -- Size --\n       ----------\n \n-      function Size (T : Instance) return Natural is\n+      function Size (T : Dynamic_Hash_Table) return Natural is\n       begin\n          Ensure_Created (T);\n \n@@ -1254,13 +1275,13 @@ package body GNAT.Dynamic_HTables is\n       -- Unlock --\n       ------------\n \n-      procedure Unlock (T : Instance) is\n+      procedure Unlock (T : Dynamic_Hash_Table) is\n       begin\n          --  The hash table may be locked multiple times if multiple iterators\n          --  are operating over it.\n \n          T.Iterators := T.Iterators - 1;\n       end Unlock;\n-   end Dynamic_HTable;\n+   end Dynamic_Hash_Tables;\n \n end GNAT.Dynamic_HTables;"}, {"sha": "6c19f0f370eb210bfda9aad69b126569789a1e01", "filename": "gcc/ada/libgnat/g-dynhta.ads", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f070fc469c71b0d3e435cf23964b6de7cd9943e/gcc%2Fada%2Flibgnat%2Fg-dynhta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f070fc469c71b0d3e435cf23964b6de7cd9943e/gcc%2Fada%2Flibgnat%2Fg-dynhta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-dynhta.ads?ref=7f070fc469c71b0d3e435cf23964b6de7cd9943e", "patch": "@@ -258,9 +258,9 @@ package GNAT.Dynamic_HTables is\n       Nil : constant Instance := Instance (Tab.Nil);\n    end Simple_HTable;\n \n-   --------------------\n-   -- Dynamic_HTable --\n-   --------------------\n+   -------------------------\n+   -- Dynamic_Hash_Tables --\n+   -------------------------\n \n    --  The following package offers a hash table abstraction with the following\n    --  characteristics:\n@@ -275,7 +275,7 @@ package GNAT.Dynamic_HTables is\n    --\n    --  The following use pattern must be employed when operating this table:\n    --\n-   --    Table : Instance := Create (<some size>);\n+   --    Table : Dynamic_Hash_Table := Create (<some size>);\n    --\n    --    <various operations>\n    --\n@@ -333,7 +333,7 @@ package GNAT.Dynamic_HTables is\n       with function Hash (Key : Key_Type) return Bucket_Range_Type;\n       --  Map an arbitrary key into the range of buckets\n \n-   package Dynamic_HTable is\n+   package Dynamic_Hash_Tables is\n \n       ----------------------\n       -- Table operations --\n@@ -342,50 +342,57 @@ package GNAT.Dynamic_HTables is\n       --  The following type denotes a hash table handle. Each instance must be\n       --  created using routine Create.\n \n-      type Instance is private;\n-      Nil : constant Instance;\n+      type Dynamic_Hash_Table is private;\n+      Nil : constant Dynamic_Hash_Table;\n \n-      function Create (Initial_Size : Positive) return Instance;\n+      function Create (Initial_Size : Positive) return Dynamic_Hash_Table;\n       --  Create a new table with bucket capacity Initial_Size. This routine\n       --  must be called at the start of a hash table's lifetime.\n \n-      procedure Delete (T : Instance; Key : Key_Type);\n+      procedure Delete\n+        (T   : Dynamic_Hash_Table;\n+         Key : Key_Type);\n       --  Delete the value which corresponds to key Key from hash table T. The\n       --  routine has no effect if the value is not present in the hash table.\n       --  This action will raise Iterated if the hash table has outstanding\n       --  iterators. If the load factor drops below Compression_Threshold, the\n       --  size of the buckets is decreased by Copression_Factor.\n \n-      procedure Destroy (T : in out Instance);\n+      procedure Destroy (T : in out Dynamic_Hash_Table);\n       --  Destroy the contents of hash table T, rendering it unusable. This\n       --  routine must be called at the end of a hash table's lifetime. This\n       --  action will raise Iterated if the hash table has outstanding\n       --  iterators.\n \n-      function Get (T : Instance; Key : Key_Type) return Value_Type;\n+      function Get\n+        (T   : Dynamic_Hash_Table;\n+         Key : Key_Type) return Value_Type;\n       --  Obtain the value which corresponds to key Key from hash table T. If\n       --  the value does not exist, return No_Value.\n \n-      function Is_Empty (T : Instance) return Boolean;\n+      function Is_Empty (T : Dynamic_Hash_Table) return Boolean;\n       --  Determine whether hash table T is empty\n \n-      function Present (T : Instance) return Boolean;\n+      function Present (T : Dynamic_Hash_Table) return Boolean;\n       --  Determine whether hash table T exists\n \n-      procedure Put (T : Instance; Key : Key_Type; Value : Value_Type);\n+      procedure Put\n+        (T     : Dynamic_Hash_Table;\n+         Key   : Key_Type;\n+         Value : Value_Type);\n       --  Associate value Value with key Key in hash table T. If the table\n       --  already contains a mapping of the same key to a previous value, the\n       --  previous value is overwritten. This action will raise Iterated if\n       --  the hash table has outstanding iterators. If the load factor goes\n       --  over Expansion_Threshold, the size of the buckets is increased by\n       --  Expansion_Factor.\n \n-      procedure Reset (T : Instance);\n+      procedure Reset (T : Dynamic_Hash_Table);\n       --  Destroy the contents of hash table T, and reset it to its initial\n       --  created state. This action will raise Iterated if the hash table\n       --  has outstanding iterators.\n \n-      function Size (T : Instance) return Natural;\n+      function Size (T : Dynamic_Hash_Table) return Natural;\n       --  Obtain the number of key-value pairs in hash table T\n \n       -------------------------\n@@ -412,7 +419,7 @@ package GNAT.Dynamic_HTables is\n       --  iterator has been exhausted, restore all mutation functionality of\n       --  the associated hash table.\n \n-      function Iterate (T : Instance) return Iterator;\n+      function Iterate (T : Dynamic_Hash_Table) return Iterator;\n       --  Obtain an iterator over the keys of hash table T. This action locks\n       --  all mutation functionality of the associated hash table.\n \n@@ -461,7 +468,7 @@ package GNAT.Dynamic_HTables is\n \n       --  The following type represents a hash table\n \n-      type Hash_Table is record\n+      type Dynamic_Hash_Table_Attributes is record\n          Buckets : Bucket_Table_Ptr := null;\n          --  Reference to the compressing / expanding buckets\n \n@@ -475,8 +482,8 @@ package GNAT.Dynamic_HTables is\n          --  Number of key-value pairs in the buckets\n       end record;\n \n-      type Instance is access Hash_Table;\n-      Nil : constant Instance := null;\n+      type Dynamic_Hash_Table is access Dynamic_Hash_Table_Attributes;\n+      Nil : constant Dynamic_Hash_Table := null;\n \n       --  The following type represents a key iterator\n \n@@ -491,9 +498,9 @@ package GNAT.Dynamic_HTables is\n          --  always point to a valid node. A value of null indicates that the\n          --  iterator is exhausted.\n \n-         Table : Instance := null;\n+         Table : Dynamic_Hash_Table := null;\n          --  Reference to the associated hash table\n       end record;\n-   end Dynamic_HTable;\n+   end Dynamic_Hash_Tables;\n \n end GNAT.Dynamic_HTables;"}, {"sha": "edc2bd6ac6ff002c6a54fadfd044bca628c11817", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f070fc469c71b0d3e435cf23964b6de7cd9943e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f070fc469c71b0d3e435cf23964b6de7cd9943e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7f070fc469c71b0d3e435cf23964b6de7cd9943e", "patch": "@@ -1,3 +1,7 @@\n+2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* gnat.dg/dynhash.adb, gnat.dg/dynhash1.adb: Update.\n+\n 2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* gnat.dg/freezing1.adb, gnat.dg/freezing1.ads,"}, {"sha": "8b229c4c8a87f75d1f310fc54a76c4091137e568", "filename": "gcc/testsuite/gnat.dg/dynhash.adb", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f070fc469c71b0d3e435cf23964b6de7cd9943e/gcc%2Ftestsuite%2Fgnat.dg%2Fdynhash.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f070fc469c71b0d3e435cf23964b6de7cd9943e/gcc%2Ftestsuite%2Fgnat.dg%2Fdynhash.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdynhash.adb?ref=7f070fc469c71b0d3e435cf23964b6de7cd9943e", "patch": "@@ -5,9 +5,10 @@ with GNAT;                 use GNAT;\n with GNAT.Dynamic_HTables; use GNAT.Dynamic_HTables;\n \n procedure Dynhash is\n+   procedure Destroy (Val : in out Integer) is null;\n    function Hash (Key : Integer) return Bucket_Range_Type;\n \n-   package DHT is new Dynamic_HTable\n+   package DHT is new Dynamic_Hash_Tables\n      (Key_Type              => Integer,\n       Value_Type            => Integer,\n       No_Value              => 0,\n@@ -16,20 +17,21 @@ procedure Dynhash is\n       Compression_Threshold => 0.3,\n       Compression_Factor    => 2,\n       \"=\"                   => \"=\",\n+      Destroy_Value         => Destroy,\n       Hash                  => Hash);\n    use DHT;\n \n    function Create_And_Populate\n      (Low_Key   : Integer;\n       High_Key  : Integer;\n-      Init_Size : Positive) return Instance;\n+      Init_Size : Positive) return Dynamic_Hash_Table;\n    --  Create a hash table with initial size Init_Size and populate it with\n    --  key-value pairs where both keys and values are in the range Low_Key\n    --  .. High_Key.\n \n    procedure Check_Empty\n      (Caller    : String;\n-      T         : Instance;\n+      T         : Dynamic_Hash_Table;\n       Low_Key   : Integer;\n       High_Key  : Integer);\n    --  Ensure that\n@@ -45,12 +47,14 @@ procedure Dynhash is\n    --  Ensure that iterator Iter visits every key in the range Low_Key ..\n    --  High_Key exactly once.\n \n-   procedure Check_Locked_Mutations (Caller : String; T : in out Instance);\n+   procedure Check_Locked_Mutations\n+     (Caller : String;\n+      T      : in out Dynamic_Hash_Table);\n    --  Ensure that all mutation operations of hash table T are locked\n \n    procedure Check_Size\n      (Caller    : String;\n-      T         : Instance;\n+      T         : Dynamic_Hash_Table;\n       Exp_Count : Natural);\n    --  Ensure that the count of key-value pairs of hash table T matches\n    --  expected count Exp_Count. Emit an error if this is not the case.\n@@ -134,9 +138,9 @@ procedure Dynhash is\n    function Create_And_Populate\n      (Low_Key   : Integer;\n       High_Key  : Integer;\n-      Init_Size : Positive) return Instance\n+      Init_Size : Positive) return Dynamic_Hash_Table\n    is\n-      T : Instance;\n+      T : Dynamic_Hash_Table;\n \n    begin\n       T := Create (Init_Size);\n@@ -154,7 +158,7 @@ procedure Dynhash is\n \n    procedure Check_Empty\n      (Caller    : String;\n-      T         : Instance;\n+      T         : Dynamic_Hash_Table;\n       Low_Key   : Integer;\n       High_Key  : Integer)\n    is\n@@ -227,7 +231,10 @@ procedure Dynhash is\n    -- Check_Locked_Mutations --\n    ----------------------------\n \n-   procedure Check_Locked_Mutations (Caller : String; T : in out Instance) is\n+   procedure Check_Locked_Mutations\n+     (Caller : String;\n+      T      : in out Dynamic_Hash_Table)\n+   is\n    begin\n       begin\n          Delete (T, 1);\n@@ -276,7 +283,7 @@ procedure Dynhash is\n \n    procedure Check_Size \n      (Caller    : String;\n-      T         : Instance;\n+      T         : Dynamic_Hash_Table;\n       Exp_Count : Natural)\n    is\n       Count : constant Natural := Size (T);\n@@ -305,7 +312,7 @@ procedure Dynhash is\n    procedure Test_Create (Init_Size : Positive) is\n       Count : Natural;\n       Iter  : Iterator;\n-      T     : Instance;\n+      T     : Dynamic_Hash_Table;\n       Val   : Integer;\n \n    begin\n@@ -402,7 +409,7 @@ procedure Dynhash is\n       Init_Size : Positive)\n    is\n       Exp_Val : Integer;\n-      T       : Instance;\n+      T       : Dynamic_Hash_Table;\n       Val     : Integer;\n \n    begin\n@@ -483,7 +490,7 @@ procedure Dynhash is\n    is\n       Iter_1 : Iterator;\n       Iter_2 : Iterator;\n-      T      : Instance;\n+      T      : Dynamic_Hash_Table;\n \n    begin\n       T := Create_And_Populate (Low_Key, High_Key, Init_Size);\n@@ -552,7 +559,7 @@ procedure Dynhash is\n    procedure Test_Iterate_Empty (Init_Size : Positive) is\n       Iter : Iterator;\n       Key  : Integer;\n-      T    : Instance;\n+      T    : Dynamic_Hash_Table;\n \n    begin\n       T := Create_And_Populate (0, -1, Init_Size);\n@@ -599,7 +606,7 @@ procedure Dynhash is\n    is\n       Iter : Iterator;\n       Key  : Integer;\n-      T    : Instance;\n+      T    : Dynamic_Hash_Table;\n \n    begin\n       T := Create_And_Populate (Low_Key, High_Key, Init_Size);\n@@ -653,7 +660,7 @@ procedure Dynhash is\n       Init_Size : Positive)\n    is\n       Key : constant Integer := 1;\n-      T   : Instance;\n+      T   : Dynamic_Hash_Table;\n       Val : Integer;\n \n    begin\n@@ -687,7 +694,7 @@ procedure Dynhash is\n       High_Key  : Integer;\n       Init_Size : Positive)\n    is\n-      T : Instance;\n+      T : Dynamic_Hash_Table;\n \n    begin\n       T := Create_And_Populate (Low_Key, High_Key, Init_Size);"}, {"sha": "e2010de91f70afd471fe29a3e7a7719ded3c7b10", "filename": "gcc/testsuite/gnat.dg/dynhash1.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f070fc469c71b0d3e435cf23964b6de7cd9943e/gcc%2Ftestsuite%2Fgnat.dg%2Fdynhash1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f070fc469c71b0d3e435cf23964b6de7cd9943e/gcc%2Ftestsuite%2Fgnat.dg%2Fdynhash1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdynhash1.adb?ref=7f070fc469c71b0d3e435cf23964b6de7cd9943e", "patch": "@@ -1,14 +1,17 @@\n+--  { dg-do run }\n+\n with Ada.Text_IO;          use Ada.Text_IO;\n with GNAT;                 use GNAT;\n with GNAT.Dynamic_HTables; use GNAT.Dynamic_HTables;\n \n procedure Dynhash1 is\n+   procedure Destroy (Val : in out Integer) is null;\n    function Hash (Key : Integer) return Bucket_Range_Type is\n    begin\n       return Bucket_Range_Type (Key);\n    end Hash;\n \n-   package Integer_Hash_Tables is new Dynamic_HTable\n+   package Integer_Hash_Tables is new Dynamic_Hash_Tables\n      (Key_Type              => Integer,\n       Value_Type            => Integer,\n       No_Value              => 0,\n@@ -17,11 +20,12 @@ procedure Dynhash1 is\n       Compression_Threshold => 0.3,\n       Compression_Factor    => 2,\n       \"=\"                   => \"=\",\n+      Destroy_Value         => Destroy,\n       Hash                  => Hash);\n    use Integer_Hash_Tables;\n \n    Siz : Natural;\n-   T   : Instance;\n+   T   : Dynamic_Hash_Table;\n \n begin\n    T := Create (8);"}]}