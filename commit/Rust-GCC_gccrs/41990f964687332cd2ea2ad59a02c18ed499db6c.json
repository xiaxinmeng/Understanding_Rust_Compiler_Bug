{"sha": "41990f964687332cd2ea2ad59a02c18ed499db6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE5OTBmOTY0Njg3MzMyY2QyZWEyYWQ1OWEwMmMxOGVkNDk5ZGI2Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-05-19T03:01:14Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-05-19T03:01:14Z"}, "message": "re PR c++/27471 (ICE within build_c_cast cp/typeck.c:5434)\n\n\tPR c++/27471\n\tPR c++/27506\n\t* typeck.c (decay_conversion): Convert bitfields to their declared\n\ttypes here.  Improve documentation.  Avoid use of cp_convert.\n\t(default_conversion): Make it static.  Perform integral promotions\n\tbefore lvalue-to-rvalue, function-to-pointer, and array-to-pointer\n\tconversions.\n\t* init.c (build_init): Remove.\n\t(expand_default_init): Do not call rvalue.\n\t* call.c (null_ptr_cst_p): Robustify.\n\t(build_conditional_expr): Tidy.\n\t* except.c (build_throw): Do not perform lvalue-to-rvalue\n\tconversion on operand before initializing temporary.\n\t* tree.c (convert.h): Include it.\n\t(convert_bitfield_to_declared_type): Use convert_to_integer, not\n\tcp_convert.\n\t(rvalue): Don't convert bitfields to their declared type here.\n\t* cp-tree.h (build_init): Remove.\n\t(default_conversion): Likewise.\n\t* typeck2.c (build_m_component_ref): Do not perform\n\tlvalue-to-rvalue, function-to-pointer, or array-to-pointer\n\tconversions here.  Correct error message.\n\tPR c++/27471\n\tPR c++/27506\n\t* g++.dg/conversion/bitfield5.C: New test.\n\t* g++.dg/conversion/bitfield6.C: New test.\n\nFrom-SVN: r113902", "tree": {"sha": "e4b7d562777fd7a64677150037b1ea3eaa0694ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4b7d562777fd7a64677150037b1ea3eaa0694ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41990f964687332cd2ea2ad59a02c18ed499db6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41990f964687332cd2ea2ad59a02c18ed499db6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41990f964687332cd2ea2ad59a02c18ed499db6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41990f964687332cd2ea2ad59a02c18ed499db6c/comments", "author": null, "committer": null, "parents": [{"sha": "84e2e37098ecd0a1085501dade4348e33fe5a695", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84e2e37098ecd0a1085501dade4348e33fe5a695", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84e2e37098ecd0a1085501dade4348e33fe5a695"}], "stats": {"total": 244, "additions": 172, "deletions": 72}, "files": [{"sha": "3c13cc00077a0699ef49ceab1af7cda9ae9ccf35", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=41990f964687332cd2ea2ad59a02c18ed499db6c", "patch": "@@ -1,3 +1,28 @@\n+2006-05-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/27471\n+\tPR c++/27506\n+\t* typeck.c (decay_conversion): Convert bitfields to their declared\n+\ttypes here.  Improve documentation.  Avoid use of cp_convert.\n+\t(default_conversion): Make it static.  Perform integral promotions\n+\tbefore lvalue-to-rvalue, function-to-pointer, and array-to-pointer\n+\tconversions.\n+\t* init.c (build_init): Remove.\n+\t(expand_default_init): Do not call rvalue.\n+\t* call.c (null_ptr_cst_p): Robustify.\n+\t(build_conditional_expr): Tidy.\n+\t* except.c (build_throw): Do not perform lvalue-to-rvalue\n+\tconversion on operand before initializing temporary.\n+\t* tree.c (convert.h): Include it.\n+\t(convert_bitfield_to_declared_type): Use convert_to_integer, not\n+\tcp_convert.\n+\t(rvalue): Don't convert bitfields to their declared type here.\n+\t* cp-tree.h (build_init): Remove.\n+\t(default_conversion): Likewise.\n+\t* typeck2.c (build_m_component_ref): Do not perform\n+\tlvalue-to-rvalue, function-to-pointer, or array-to-pointer\n+\tconversions here.  Correct error message.\n+\n 2006-05-17  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/26122"}, {"sha": "9e69772954c804572d3c28b1163a59f3c8c7b779", "filename": "gcc/cp/call.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=41990f964687332cd2ea2ad59a02c18ed499db6c", "patch": "@@ -426,11 +426,14 @@ null_ptr_cst_p (tree t)\n      A null pointer constant is an integral constant expression\n      (_expr.const_) rvalue of integer type that evaluates to zero.  */\n   t = integral_constant_value (t);\n-  if (t == null_node\n-      || (CP_INTEGRAL_TYPE_P (TREE_TYPE (t))\n-\t  && integer_zerop (t)\n-\t  && !TREE_CONSTANT_OVERFLOW (t)))\n+  if (t == null_node)\n     return true;\n+  if (CP_INTEGRAL_TYPE_P (TREE_TYPE (t)) && integer_zerop (t))\n+    {\n+      STRIP_NOPS (t);\n+      if (!TREE_CONSTANT_OVERFLOW (t))\n+\treturn true;\n+    }\n   return false;\n }\n \n@@ -3518,16 +3521,18 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n   /* We can't use result_type below, as fold might have returned a\n      throw_expr.  */\n \n-  /* Expand both sides into the same slot, hopefully the target of the\n-     ?: expression.  We used to check for TARGET_EXPRs here, but now we\n-     sometimes wrap them in NOP_EXPRs so the test would fail.  */\n-  if (!lvalue_p && CLASS_TYPE_P (TREE_TYPE (result)))\n-    result = get_target_expr (result);\n-\n-  /* If this expression is an rvalue, but might be mistaken for an\n-     lvalue, we must add a NON_LVALUE_EXPR.  */\n-  if (!lvalue_p && real_lvalue_p (result))\n-    result = rvalue (result);\n+  if (!lvalue_p)\n+    {\n+      /* Expand both sides into the same slot, hopefully the target of\n+\t the ?: expression.  We used to check for TARGET_EXPRs here,\n+\t but now we sometimes wrap them in NOP_EXPRs so the test would\n+\t fail.  */\n+      if (CLASS_TYPE_P (TREE_TYPE (result)))\n+\tresult = get_target_expr (result);\n+      /* If this expression is an rvalue, but might be mistaken for an\n+\t lvalue, we must add a NON_LVALUE_EXPR.  */\n+      result = rvalue (result);\n+    }\n \n   return result;\n }"}, {"sha": "cac801d7514c5e40a10942ccb846c166d909ca28", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=41990f964687332cd2ea2ad59a02c18ed499db6c", "patch": "@@ -3973,7 +3973,6 @@ extern tree do_friend\t\t\t\t(tree, tree, tree, tree, enum overload_flags, bool);\n extern tree expand_member_init\t\t\t(tree);\n extern void emit_mem_initializers\t\t(tree);\n extern tree build_aggr_init\t\t\t(tree, tree, int);\n-extern tree build_init\t\t\t\t(tree, tree, int);\n extern int is_aggr_type\t\t\t\t(tree, int);\n extern tree get_type_value\t\t\t(tree);\n extern tree build_zero_init\t\t\t(tree, tree, bool);\n@@ -4357,7 +4356,6 @@ extern tree cxx_sizeof_or_alignof_type\t\t(tree, enum tree_code, bool);\n extern tree inline_conversion\t\t\t(tree);\n extern tree is_bitfield_expr_with_lowered_type  (tree); \n extern tree decay_conversion\t\t\t(tree);\n-extern tree default_conversion\t\t\t(tree);\n extern tree build_class_member_access_expr      (tree, tree, tree, bool);\n extern tree finish_class_member_access_expr     (tree, tree, bool);\n extern tree build_x_indirect_ref\t\t(tree, const char *);"}, {"sha": "efdbd91e85730c0b0e68b4be27c8ffc5aee36692", "filename": "gcc/cp/except.c", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=41990f964687332cd2ea2ad59a02c18ed499db6c", "patch": "@@ -638,6 +638,7 @@ build_throw (tree exp)\n   else if (exp)\n     {\n       tree throw_type;\n+      tree temp_type;\n       tree cleanup;\n       tree object, ptr;\n       tree tmp;\n@@ -666,9 +667,17 @@ build_throw (tree exp)\n \t  fn = push_throw_library_fn (fn, tmp);\n \t}\n \n-      /* throw expression */\n-      /* First, decay it.  */\n-      exp = decay_conversion (exp);\n+      /* [except.throw] \n+\t \n+         A throw-expression initializes a temporary object, the type\n+\t of which is determined by removing any top-level\n+\t cv-qualifiers from the static type of the operand of throw\n+\t and adjusting the type from \"array of T\" or \"function return\n+\t T\" to \"pointer to T\" or \"pointer to function returning T\"\n+\t respectively.  */\n+      temp_type = is_bitfield_expr_with_lowered_type (exp);\n+      if (!temp_type)\n+\ttemp_type = type_decays_to (TYPE_MAIN_VARIANT (TREE_TYPE (exp)));\n \n       /* OK, this is kind of wacky.  The standard says that we call\n \t terminate when the exception handling mechanism, after\n@@ -684,21 +693,32 @@ build_throw (tree exp)\n \t matter, since it can't throw).  */\n \n       /* Allocate the space for the exception.  */\n-      allocate_expr = do_allocate_exception (TREE_TYPE (exp));\n+      allocate_expr = do_allocate_exception (temp_type);\n       allocate_expr = get_target_expr (allocate_expr);\n       ptr = TARGET_EXPR_SLOT (allocate_expr);\n-      object = build1 (NOP_EXPR, build_pointer_type (TREE_TYPE (exp)), ptr);\n+      object = build_nop (build_pointer_type (temp_type), ptr);\n       object = build_indirect_ref (object, NULL);\n \n       elided = (TREE_CODE (exp) == TARGET_EXPR);\n \n       /* And initialize the exception object.  */\n-      exp = build_init (object, exp, LOOKUP_ONLYCONVERTING);\n-      if (exp == error_mark_node)\n+      if (CLASS_TYPE_P (temp_type))\n \t{\n-\t  error (\"  in thrown expression\");\n-\t  return error_mark_node;\n+\t  /* Call the copy constructor.  */\n+\t  exp = (build_special_member_call \n+\t\t (object, complete_ctor_identifier,\n+\t\t  build_tree_list (NULL_TREE, exp),\n+\t\t  TREE_TYPE (object),\n+\t\t  LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING));\n+\t  if (exp == error_mark_node)\n+\t    {\n+\t      error (\"  in thrown expression\");\n+\t      return error_mark_node;\n+\t    }\n \t}\n+      else\n+\texp = build2 (INIT_EXPR, temp_type, object, \n+\t\t      decay_conversion (exp));\n \n       /* Pre-evaluate the thrown expression first, since if we allocated\n \t the space first we would have to deal with cleaning it up if"}, {"sha": "e9528f2aab221f19f0fe1524b78e0843a812e1d1", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=41990f964687332cd2ea2ad59a02c18ed499db6c", "patch": "@@ -1142,26 +1142,6 @@ build_aggr_init (tree exp, tree init, int flags)\n   return stmt_expr;\n }\n \n-/* Like build_aggr_init, but not just for aggregates.  */\n-\n-tree\n-build_init (tree decl, tree init, int flags)\n-{\n-  tree expr;\n-\n-  if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n-    expr = build_aggr_init (decl, init, flags);\n-  else if (CLASS_TYPE_P (TREE_TYPE (decl)))\n-    expr = build_special_member_call (decl, complete_ctor_identifier,\n-\t\t\t\t      build_tree_list (NULL_TREE, init),\n-\t\t\t\t      TREE_TYPE (decl),\n-\t\t\t\t      LOOKUP_NORMAL|flags);\n-  else\n-    expr = build2 (INIT_EXPR, TREE_TYPE (decl), decl, init);\n-\n-  return expr;\n-}\n-\n static void\n expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags)\n {\n@@ -2057,7 +2037,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n   rval = build_nop (pointer_type, rval);\n \n   /* A new-expression is never an lvalue.  */\n-  rval = rvalue (rval);\n+  gcc_assert (!lvalue_p (rval));\n \n   return rval;\n }"}, {"sha": "81b37d615c2ec1107d9e1818a18b6b99a9974110", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=41990f964687332cd2ea2ad59a02c18ed499db6c", "patch": "@@ -35,6 +35,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-inline.h\"\n #include \"debug.h\"\n #include \"target.h\"\n+#include \"convert.h\"\n \n static tree bot_manip (tree *, int *, void *);\n static tree bot_replace (tree *, int *, void *);\n@@ -373,7 +374,8 @@ convert_bitfield_to_declared_type (tree expr)\n \n   bitfield_type = is_bitfield_expr_with_lowered_type (expr);\n   if (bitfield_type)\n-    expr = cp_convert (TYPE_MAIN_VARIANT (bitfield_type), expr);\n+    expr = convert_to_integer (TYPE_MAIN_VARIANT (bitfield_type),\n+\t\t\t       expr);\n   return expr;\n }\n \n@@ -383,18 +385,23 @@ convert_bitfield_to_declared_type (tree expr)\n tree\n rvalue (tree expr)\n {\n-  expr = convert_bitfield_to_declared_type (expr);\n-  if (real_lvalue_p (expr))\n-    {\n-      tree type;\n-      /* [basic.lval]\n-\t \n-         Non-class rvalues always have cv-unqualified types.  */\n-      type = TREE_TYPE (expr);\n-      if (!CLASS_TYPE_P (type))\n-\ttype = TYPE_MAIN_VARIANT (type);\n-      expr = build1 (NON_LVALUE_EXPR, type, expr);\n-    }\n+  tree type;\n+\n+  if (error_operand_p (expr))\n+    return expr;\n+\n+  /* [basic.lval]\n+\n+     Non-class rvalues always have cv-unqualified types.  */\n+  type = TREE_TYPE (expr);\n+  if (!CLASS_TYPE_P (type) && cp_type_quals (type))\n+    type = TYPE_MAIN_VARIANT (type);\n+\n+  if (!processing_template_decl && real_lvalue_p (expr))\n+    expr = build1 (NON_LVALUE_EXPR, type, expr);\n+  else if (type != TREE_TYPE (expr))\n+    expr = build_nop (type, expr);\n+\n   return expr;\n }\n "}, {"sha": "e275f76a20f29ac1624623d4a368b4c8f17e5ece", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 46, "deletions": 10, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=41990f964687332cd2ea2ad59a02c18ed499db6c", "patch": "@@ -1426,10 +1426,14 @@ is_bitfield_expr_with_lowered_type (tree exp)\n \n /* Perform the conversions in [expr] that apply when an lvalue appears\n    in an rvalue context: the lvalue-to-rvalue, array-to-pointer, and\n-   function-to-pointer conversions.\n+   function-to-pointer conversions.  In addition, manifest constants\n+   are replaced by their values, and bitfield references are converted\n+   to their declared types.\n \n-   In addition, manifest constants are replaced by their values, and\n-   bitfield references are converted to their declared types.  */\n+   Although the returned value is being used as an rvalue, this\n+   function does not wrap the returned expression in a\n+   NON_LVALUE_EXPR; the caller is expected to be mindful of the fact\n+   that the return value is no longer an lvalue.  */\n \n tree\n decay_conversion (tree exp)\n@@ -1448,6 +1452,8 @@ decay_conversion (tree exp)\n     }\n \n   exp = decl_constant_value (exp);\n+  if (error_operand_p (exp))\n+    return error_mark_node;\n \n   /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n      Leave such NOP_EXPRs, since RHS is being used in non-lvalue context.  */\n@@ -1498,22 +1504,52 @@ decay_conversion (tree exp)\n       adr = build_unary_op (ADDR_EXPR, exp, 1);\n       return cp_convert (ptrtype, adr);\n     }\n+  \n+  /* If a bitfield is used in a context where integral promotion\n+     applies, then the caller is expected to have used\n+     default_conversion.  That function promotes bitfields correctly\n+     before calling this function.  At this point, if we have a\n+     bitfield referenced, we may assume that is not subject to\n+     promotion, and that, therefore, the type of the resulting rvalue\n+     is the declared type of the bitfield.  */\n+  exp = convert_bitfield_to_declared_type (exp);\n \n-  /* [basic.lval]: Class rvalues can have cv-qualified types; non-class\n-     rvalues always have cv-unqualified types.  */\n-  if (! CLASS_TYPE_P (type))\n-    exp = cp_convert (TYPE_MAIN_VARIANT (type), exp);\n+  /* We do not call rvalue() here because we do not want to wrap EXP\n+     in a NON_LVALUE_EXPR.  */\n+\n+  /* [basic.lval]\n+\n+     Non-class rvalues always have cv-unqualified types.  */\n+  type = TREE_TYPE (exp);\n+  if (!CLASS_TYPE_P (type) && cp_type_quals (type))\n+    exp = build_nop (TYPE_MAIN_VARIANT (type), exp);\n \n   return exp;\n }\n \n-tree\n+/* Perform prepatory conversions, as part of the \"usual arithmetic\n+   conversions\".  In particular, as per [expr]:\n+\n+     Whenever an lvalue expression appears as an operand of an\n+     operator that expects the rvalue for that operand, the\n+     lvalue-to-rvalue, array-to-pointer, or function-to-pointer\n+     standard conversions are applied to convert the expression to an\n+     rvalue.\n+\n+   In addition, we perform integral promotions here, as those are\n+   applied to both operands to a binary operator before determining\n+   what additional conversions should apply.  */\n+\n+static tree\n default_conversion (tree exp)\n {\n-  exp = decay_conversion (exp);\n-\n+  /* Perform the integral promotions first so that bitfield\n+     expressions (which may promote to \"int\", even if the bitfield is\n+     declared \"unsigned\") are promoted correctly.  */  \n   if (INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (exp)))\n     exp = perform_integral_promotions (exp);\n+  /* Perform the other conversions.  */\n+  exp = decay_conversion (exp);\n \n   return exp;\n }"}, {"sha": "5356faa25fa0f1c6b5a61236743288d6c3ebb41f", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=41990f964687332cd2ea2ad59a02c18ed499db6c", "patch": "@@ -1200,8 +1200,6 @@ build_m_component_ref (tree datum, tree component)\n   tree binfo;\n   tree ctype;\n \n-  datum = decay_conversion (datum);\n-\n   if (datum == error_mark_node || component == error_mark_node)\n     return error_mark_node;\n \n@@ -1218,7 +1216,7 @@ build_m_component_ref (tree datum, tree component)\n   if (! IS_AGGR_TYPE (objtype))\n     {\n       error (\"cannot apply member pointer %qE to %qE, which is of \"\n-\t     \"non-aggregate type %qT\",\n+\t     \"non-class type %qT\",\n \t     component, datum, objtype);\n       return error_mark_node;\n     }"}, {"sha": "540995b97c5c569b9591876b638c0a03945c0f44", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=41990f964687332cd2ea2ad59a02c18ed499db6c", "patch": "@@ -1,3 +1,10 @@\n+2006-05-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/27471\n+\tPR c++/27506\n+\t* g++.dg/conversion/bitfield5.C: New test.\n+\t* g++.dg/conversion/bitfield6.C: New test.\n+\n 2006-05-18  Mike Stump  <mrs@apple.com>\n \n \t* gcc.dg/c90-arraydecl-1.c: Update for vla, vm [*] fixups."}, {"sha": "b931ec97c0019a66246cea53a9fb1225d0df0d30", "filename": "gcc/testsuite/g++.dg/conversion/bitfield5.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fbitfield5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fbitfield5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fbitfield5.C?ref=41990f964687332cd2ea2ad59a02c18ed499db6c", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/27506\n+\n+enum EBorderStyle\n+  {\n+    BNATIVE, BHIDDEN\n+  };\n+struct BorderValue\n+{\n+  enum EBorderStyle style:8;\n+};\n+enum EBorderStyle f(const struct BorderValue *border)\n+{\n+  return border ?  border->style : BNATIVE;\n+}"}, {"sha": "79664ab7d5fc3f032fb5033d7a0cbcd44d805c52", "filename": "gcc/testsuite/g++.dg/conversion/bitfield6.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fbitfield6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41990f964687332cd2ea2ad59a02c18ed499db6c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fbitfield6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fbitfield6.C?ref=41990f964687332cd2ea2ad59a02c18ed499db6c", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/27471\n+\n+struct A { unsigned a:8; };\n+\n+extern void b(unsigned char);\n+\n+void breakme (A f)\n+{\n+  b((unsigned char) f.a);\n+}"}]}