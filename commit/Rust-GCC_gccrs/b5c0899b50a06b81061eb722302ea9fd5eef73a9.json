{"sha": "b5c0899b50a06b81061eb722302ea9fd5eef73a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVjMDg5OWI1MGEwNmI4MTA2MWViNzIyMzAyZWE5ZmQ1ZWVmNzNhOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-01-20T11:08:24Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-01-20T11:08:24Z"}, "message": "re PR middle-end/42803 (c++ compilation hang)\n\n\tPR middle-end/42803\n\t* varasm.c (narrowing_initializer_constant_valid_p): Add CACHE\n\targument, call initializer_constant_valid_p_1 instead of\n\tinitializer_constant_valid_p, pass CACHE to it, return NULL\n\timmediately if first call returns NULL.\n\t(initializer_constant_valid_p_1): New function.\n\t(initializer_constant_valid_p): Use it.\n\n\t* g++.dg/parse/limits-initializer1.C: New test.\n\nFrom-SVN: r156069", "tree": {"sha": "13ead27fe4dd12c65ca5e23eeba855cac37bf3d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13ead27fe4dd12c65ca5e23eeba855cac37bf3d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5c0899b50a06b81061eb722302ea9fd5eef73a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c0899b50a06b81061eb722302ea9fd5eef73a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5c0899b50a06b81061eb722302ea9fd5eef73a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c0899b50a06b81061eb722302ea9fd5eef73a9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "21a942d22b1f9e89ccedd0c8711b88dae4b4fa00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21a942d22b1f9e89ccedd0c8711b88dae4b4fa00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21a942d22b1f9e89ccedd0c8711b88dae4b4fa00"}], "stats": {"total": 219, "additions": 165, "deletions": 54}, "files": [{"sha": "b27e46984bddab9ad83c4d7ac70b297a5d827c20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c0899b50a06b81061eb722302ea9fd5eef73a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c0899b50a06b81061eb722302ea9fd5eef73a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5c0899b50a06b81061eb722302ea9fd5eef73a9", "patch": "@@ -1,3 +1,13 @@\n+2010-01-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/42803\n+\t* varasm.c (narrowing_initializer_constant_valid_p): Add CACHE\n+\targument, call initializer_constant_valid_p_1 instead of\n+\tinitializer_constant_valid_p, pass CACHE to it, return NULL\n+\timmediately if first call returns NULL.\n+\t(initializer_constant_valid_p_1): New function.\n+\t(initializer_constant_valid_p): Use it.\n+\n 2010-01-20  Thomas Quinot  <quinot@adacore.com>\n \n \t* tree.def (PLACEHOLDER_EXPR): Fix comment."}, {"sha": "476d0fddc1d1e8cb4e5c6c8b7f4991fb1a2f97cf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c0899b50a06b81061eb722302ea9fd5eef73a9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c0899b50a06b81061eb722302ea9fd5eef73a9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b5c0899b50a06b81061eb722302ea9fd5eef73a9", "patch": "@@ -3,6 +3,9 @@\n \t* gcc.dg/cleanup-13.c: Expect DW_OP_mod to do unsigned modulo instead\n \tof signed, add a few new tests.\n \n+\tPR middle-end/42803\n+\t* g++.dg/parse/limits-initializer1.C: New test.\n+\n 2010-01-19  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/42804"}, {"sha": "4b507912f3680e33808fa675b1335be390a0232d", "filename": "gcc/testsuite/g++.dg/parse/limits-initializer1.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c0899b50a06b81061eb722302ea9fd5eef73a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Flimits-initializer1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c0899b50a06b81061eb722302ea9fd5eef73a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Flimits-initializer1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Flimits-initializer1.C?ref=b5c0899b50a06b81061eb722302ea9fd5eef73a9", "patch": "@@ -0,0 +1,37 @@\n+// PR middle-end/42803\n+// { dg-do compile }\n+// { dg-options \"-O0\" }\n+\n+#define X2 (a + a)\n+#define X4 (X2 + X2)\n+#define X8 (X4 + X4)\n+#define X16 (X8 + X8)\n+#define X32 (X16 + X16)\n+#define X64 (X32 + X32)\n+#define X128 (X64 + X64)\n+#define X256 (X128 + X128)\n+#define X512 (X256 + X256)\n+#define X1024 (X512 + X512)\n+#define X2048 (X1024 + X1024)\n+#define X4096 (X2048 + X2048)\n+#define X8192 (X4096 + X4096)\n+#define X16384 (X8192 + X8192)\n+#define X32768 (X16384 + X16384)\n+#define X65536 (X32768 + X32768)\n+#define X131072 (X65536 + X65536)\n+#define X262144 (X131072 + X131072)\n+\n+int\n+foo (int a)\n+{\n+  int v = X262144;\n+  return v;\n+}\n+\n+// Emit an error to just make sure we don't waste too much time\n+// in the middle-end compiling this.\n+int\n+bar (void)\n+{\n+  return x;\t// { dg-error \"was not declared in this scope\" }\n+}"}, {"sha": "310647e7e2b43e57cf065965a1468d95e058f97b", "filename": "gcc/varasm.c", "status": "modified", "additions": 115, "deletions": 54, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5c0899b50a06b81061eb722302ea9fd5eef73a9/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5c0899b50a06b81061eb722302ea9fd5eef73a9/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=b5c0899b50a06b81061eb722302ea9fd5eef73a9", "patch": "@@ -1,7 +1,7 @@\n /* Output variables, constants and external declarations, for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,\n-   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n-   Free Software Foundation, Inc.\n+   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,\n+   2010  Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -4093,6 +4093,9 @@ constructor_static_from_elts_p (const_tree ctor)\n \t  && !VEC_empty (constructor_elt, CONSTRUCTOR_ELTS (ctor)));\n }\n \n+static tree initializer_constant_valid_p_1 (tree value, tree endtype,\n+\t\t\t\t\t    tree *cache);\n+\n /* A subroutine of initializer_constant_valid_p.  VALUE is a MINUS_EXPR,\n    PLUS_EXPR or POINTER_PLUS_EXPR.  This looks for cases of VALUE\n    which are valid when ENDTYPE is an integer of any size; in\n@@ -4102,7 +4105,7 @@ constructor_static_from_elts_p (const_tree ctor)\n    returns NULL.  */\n \n static tree\n-narrowing_initializer_constant_valid_p (tree value, tree endtype)\n+narrowing_initializer_constant_valid_p (tree value, tree endtype, tree *cache)\n {\n   tree op0, op1;\n \n@@ -4141,11 +4144,14 @@ narrowing_initializer_constant_valid_p (tree value, tree endtype)\n       op1 = inner;\n     }\n \n-  op0 = initializer_constant_valid_p (op0, endtype);\n-  op1 = initializer_constant_valid_p (op1, endtype);\n+  op0 = initializer_constant_valid_p_1 (op0, endtype, cache);\n+  if (!op0)\n+    return NULL_TREE;\n \n+  op1 = initializer_constant_valid_p_1 (op1, endtype,\n+\t\t\t\t\tcache ? cache + 2 : NULL);\n   /* Both initializers must be known.  */\n-  if (op0 && op1)\n+  if (op1)\n     {\n       if (op0 == op1\n \t  && (op0 == null_pointer_node\n@@ -4166,18 +4172,21 @@ narrowing_initializer_constant_valid_p (tree value, tree endtype)\n   return NULL_TREE;\n }\n \n-/* Return nonzero if VALUE is a valid constant-valued expression\n+/* Helper function of initializer_constant_valid_p.\n+   Return nonzero if VALUE is a valid constant-valued expression\n    for use in initializing a static variable; one that can be an\n    element of a \"constant\" initializer.\n \n    Return null_pointer_node if the value is absolute;\n    if it is relocatable, return the variable that determines the relocation.\n    We assume that VALUE has been folded as much as possible;\n    therefore, we do not need to check for such things as\n-   arithmetic-combinations of integers.  */\n+   arithmetic-combinations of integers.\n \n-tree\n-initializer_constant_valid_p (tree value, tree endtype)\n+   Use CACHE (pointer to 2 tree values) for caching if non-NULL.  */\n+\n+static tree\n+initializer_constant_valid_p_1 (tree value, tree endtype, tree *cache)\n {\n   tree ret;\n \n@@ -4190,18 +4199,33 @@ initializer_constant_valid_p (tree value, tree endtype)\n \t  tree elt;\n \t  bool absolute = true;\n \n+\t  if (cache && cache[0] == value)\n+\t    return cache[1];\n \t  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (value), idx, elt)\n \t    {\n \t      tree reloc;\n-\t      reloc = initializer_constant_valid_p (elt, TREE_TYPE (elt));\n+\t      reloc = initializer_constant_valid_p_1 (elt, TREE_TYPE (elt),\n+\t\t\t\t\t\t      NULL);\n \t      if (!reloc)\n-\t\treturn NULL_TREE;\n+\t\t{\n+\t\t  if (cache)\n+\t\t    {\n+\t\t      cache[0] = value;\n+\t\t      cache[1] = NULL_TREE;\n+\t\t    }\n+\t\t  return NULL_TREE;\n+\t\t}\n \t      if (reloc != null_pointer_node)\n \t\tabsolute = false;\n \t    }\n \t  /* For a non-absolute relocation, there is no single\n \t     variable that can be \"the variable that determines the\n \t     relocation.\"  */\n+\t  if (cache)\n+\t    {\n+\t      cache[0] = value;\n+\t      cache[1] = absolute ? null_pointer_node : error_mark_node;\n+\t    }\n \t  return absolute ? null_pointer_node : error_mark_node;\n \t}\n \n@@ -4241,7 +4265,8 @@ initializer_constant_valid_p (tree value, tree endtype)\n       }\n \n     case NON_LVALUE_EXPR:\n-      return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n+      return initializer_constant_valid_p_1 (TREE_OPERAND (value, 0),\n+\t\t\t\t\t     endtype, cache);\n \n     case VIEW_CONVERT_EXPR:\n       {\n@@ -4256,13 +4281,13 @@ initializer_constant_valid_p (tree value, tree endtype)\n \tif (AGGREGATE_TYPE_P (src_type) && !AGGREGATE_TYPE_P (dest_type))\n \t  {\n \t    if (TYPE_MODE (endtype) == TYPE_MODE (dest_type))\n-\t      return initializer_constant_valid_p (src, endtype);\n+\t      return initializer_constant_valid_p_1 (src, endtype, cache);\n \t    else\n \t      return NULL_TREE;\n \t  }\n \n \t/* Allow all other kinds of view-conversion.  */\n-\treturn initializer_constant_valid_p (src, endtype);\n+\treturn initializer_constant_valid_p_1 (src, endtype, cache);\n       }\n \n     CASE_CONVERT:\n@@ -4277,18 +4302,18 @@ initializer_constant_valid_p (tree value, tree endtype)\n \t    || (FLOAT_TYPE_P (dest_type) && FLOAT_TYPE_P (src_type))\n \t    || (TREE_CODE (dest_type) == OFFSET_TYPE\n \t\t&& TREE_CODE (src_type) == OFFSET_TYPE))\n-\t  return initializer_constant_valid_p (src, endtype);\n+\t  return initializer_constant_valid_p_1 (src, endtype, cache);\n \n \t/* Allow length-preserving conversions between integer types.  */\n \tif (INTEGRAL_TYPE_P (dest_type) && INTEGRAL_TYPE_P (src_type)\n \t    && (TYPE_PRECISION (dest_type) == TYPE_PRECISION (src_type)))\n-\t  return initializer_constant_valid_p (src, endtype);\n+\t  return initializer_constant_valid_p_1 (src, endtype, cache);\n \n \t/* Allow conversions between other integer types only if\n \t   explicit value.  */\n \tif (INTEGRAL_TYPE_P (dest_type) && INTEGRAL_TYPE_P (src_type))\n \t  {\n-\t    tree inner = initializer_constant_valid_p (src, endtype);\n+\t    tree inner = initializer_constant_valid_p_1 (src, endtype, cache);\n \t    if (inner == null_pointer_node)\n \t      return null_pointer_node;\n \t    break;\n@@ -4297,7 +4322,7 @@ initializer_constant_valid_p (tree value, tree endtype)\n \t/* Allow (int) &foo provided int is as wide as a pointer.  */\n \tif (INTEGRAL_TYPE_P (dest_type) && POINTER_TYPE_P (src_type)\n \t    && (TYPE_PRECISION (dest_type) >= TYPE_PRECISION (src_type)))\n-\t  return initializer_constant_valid_p (src, endtype);\n+\t  return initializer_constant_valid_p_1 (src, endtype, cache);\n \n \t/* Likewise conversions from int to pointers, but also allow\n \t   conversions from 0.  */\n@@ -4311,14 +4336,14 @@ initializer_constant_valid_p (tree value, tree endtype)\n \t    if (integer_zerop (src))\n \t      return null_pointer_node;\n \t    else if (TYPE_PRECISION (dest_type) <= TYPE_PRECISION (src_type))\n-\t      return initializer_constant_valid_p (src, endtype);\n+\t      return initializer_constant_valid_p_1 (src, endtype, cache);\n \t  }\n \n \t/* Allow conversions to struct or union types if the value\n \t   inside is okay.  */\n \tif (TREE_CODE (dest_type) == RECORD_TYPE\n \t    || TREE_CODE (dest_type) == UNION_TYPE)\n-\t  return initializer_constant_valid_p (src, endtype);\n+\t  return initializer_constant_valid_p_1 (src, endtype, cache);\n       }\n       break;\n \n@@ -4328,66 +4353,102 @@ initializer_constant_valid_p (tree value, tree endtype)\n \t with -frounding-math we hit this with addition of two constants.  */\n       if (TREE_CODE (endtype) == REAL_TYPE)\n \treturn NULL_TREE;\n+      if (cache && cache[0] == value)\n+\treturn cache[1];\n       if (! INTEGRAL_TYPE_P (endtype)\n \t  || TYPE_PRECISION (endtype) >= TYPE_PRECISION (TREE_TYPE (value)))\n \t{\n-\t  tree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t      endtype);\n-\t  tree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n-\t\t\t\t\t\t      endtype);\n+\t  tree ncache[4] = { NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE };\n+\t  tree valid0\n+\t    = initializer_constant_valid_p_1 (TREE_OPERAND (value, 0),\n+\t\t\t\t\t      endtype, ncache);\n+\t  tree valid1\n+\t    = initializer_constant_valid_p_1 (TREE_OPERAND (value, 1),\n+\t\t\t\t\t      endtype, ncache + 2);\n \t  /* If either term is absolute, use the other term's relocation.  */\n \t  if (valid0 == null_pointer_node)\n-\t    return valid1;\n-\t  if (valid1 == null_pointer_node)\n-\t    return valid0;\n+\t    ret = valid1;\n+\t  else if (valid1 == null_pointer_node)\n+\t    ret = valid0;\n+\t  /* Support narrowing pointer differences.  */\n+\t  else\n+\t    ret = narrowing_initializer_constant_valid_p (value, endtype,\n+\t\t\t\t\t\t\t  ncache);\n \t}\n-\n+      else\n       /* Support narrowing pointer differences.  */\n-      ret = narrowing_initializer_constant_valid_p (value, endtype);\n-      if (ret != NULL_TREE)\n-\treturn ret;\n-\n-      break;\n+\tret = narrowing_initializer_constant_valid_p (value, endtype, NULL);\n+      if (cache)\n+\t{\n+\t  cache[0] = value;\n+\t  cache[1] = ret;\n+\t}\n+      return ret;\n \n     case MINUS_EXPR:\n       if (TREE_CODE (endtype) == REAL_TYPE)\n \treturn NULL_TREE;\n+      if (cache && cache[0] == value)\n+\treturn cache[1];\n       if (! INTEGRAL_TYPE_P (endtype)\n \t  || TYPE_PRECISION (endtype) >= TYPE_PRECISION (TREE_TYPE (value)))\n \t{\n-\t  tree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n-\t\t\t\t\t\t      endtype);\n-\t  tree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n-\t\t\t\t\t\t      endtype);\n+\t  tree ncache[4] = { NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE };\n+\t  tree valid0\n+\t    = initializer_constant_valid_p_1 (TREE_OPERAND (value, 0),\n+\t\t\t\t\t      endtype, ncache);\n+\t  tree valid1\n+\t    = initializer_constant_valid_p_1 (TREE_OPERAND (value, 1),\n+\t\t\t\t\t      endtype, ncache + 2);\n \t  /* Win if second argument is absolute.  */\n \t  if (valid1 == null_pointer_node)\n-\t    return valid0;\n+\t    ret = valid0;\n \t  /* Win if both arguments have the same relocation.\n \t     Then the value is absolute.  */\n-\t  if (valid0 == valid1 && valid0 != 0)\n-\t    return null_pointer_node;\n-\n+\t  else if (valid0 == valid1 && valid0 != 0)\n+\t    ret = null_pointer_node;\n \t  /* Since GCC guarantees that string constants are unique in the\n \t     generated code, a subtraction between two copies of the same\n \t     constant string is absolute.  */\n-\t  if (valid0 && TREE_CODE (valid0) == STRING_CST\n-\t      && valid1 && TREE_CODE (valid1) == STRING_CST\n-\t      && operand_equal_p (valid0, valid1, 1))\n-\t    return null_pointer_node;\n+\t  else if (valid0 && TREE_CODE (valid0) == STRING_CST\n+\t\t   && valid1 && TREE_CODE (valid1) == STRING_CST\n+\t\t   && operand_equal_p (valid0, valid1, 1))\n+\t    ret = null_pointer_node;\n+\t  /* Support narrowing differences.  */\n+\t  else\n+\t    ret = narrowing_initializer_constant_valid_p (value, endtype,\n+\t\t\t\t\t\t\t  ncache);\n \t}\n-\n-      /* Support narrowing differences.  */\n-      ret = narrowing_initializer_constant_valid_p (value, endtype);\n-      if (ret != NULL_TREE)\n-\treturn ret;\n-\n-      break;\n+      else\n+\t/* Support narrowing differences.  */\n+\tret = narrowing_initializer_constant_valid_p (value, endtype, NULL);\n+      if (cache)\n+\t{\n+\t  cache[0] = value;\n+\t  cache[1] = ret;\n+\t}\n+      return ret;\n \n     default:\n       break;\n     }\n \n-  return 0;\n+  return NULL_TREE;\n+}\n+\n+/* Return nonzero if VALUE is a valid constant-valued expression\n+   for use in initializing a static variable; one that can be an\n+   element of a \"constant\" initializer.\n+\n+   Return null_pointer_node if the value is absolute;\n+   if it is relocatable, return the variable that determines the relocation.\n+   We assume that VALUE has been folded as much as possible;\n+   therefore, we do not need to check for such things as\n+   arithmetic-combinations of integers.  */\n+tree\n+initializer_constant_valid_p (tree value, tree endtype)\n+{\n+  return initializer_constant_valid_p_1 (value, endtype, NULL);\n }\n \f\n /* Return true if VALUE is a valid constant-valued expression"}]}