{"sha": "4985cde3ef44391a43fd95c0972bf72c86e127cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk4NWNkZTNlZjQ0MzkxYTQzZmQ5NWMwOTcyYmY3MmM4NmUxMjdjYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-08-29T23:21:13Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-08-29T23:21:13Z"}, "message": "tree-optimize.c: New file.\n\ngcc/\n        * tree-optimize.c: New file.\n        * Makefile.in (OBJS-archive): Add tree-optimize.o.\n        (tree-optimize.o): New.\n        * c-decl.c (store_parm_decls): Use allocate_struct_function.\n        (finish_function): Don't free_after_parsing or free_after_compilation.\n        (set_save_expr_context): Move to tree-optimize.c.\n        (c_expand_body_1): Use tree_rest_of_compilation.\n        * c-lang.c (LANG_HOOKS_RTL_EXPAND_STMT): New.\n        * objc/objc-lang.c (LANG_HOOKS_RTL_EXPAND_STMT): New.\n        * c-objc-common.c (expand_deferred_fns): Don't emit unused inlines;\n        iterate until closure.\n        * langhooks-def.h (LANG_HOOKS_RTL_EXPAND_START,\n        LANG_HOOKS_RTL_EXPAND_STMT, LANG_HOOKS_RTL_EXPAND_END): New.\n        (LANG_HOOKS_RTL_EXPAND_INITIALIZER): New.\n        * langhooks.h (struct lang_hooks_for_rtl_expansion): New.\n        * toplev.h (tree_rest_of_compilation): Declare it.\n\ngcc/cp/\n        * cp-lang.c (LANG_HOOKS_RTL_EXPAND_START): New.\n        (LANG_HOOKS_RTL_EXPAND_STMT): New.\n        * cp-tree.h (cxx_expand_function_start): Declare.\n        * decl.c (start_function): Use allocate_struct_function.\n        Move stmts_are_full_exprs_p assertion from expand_body.\n        Do not free_after_parsing or free_after_compilation.\n        (cxx_push_function_context): Move code to set struct function\n        data from genrtl_start_function.\n        * optimize.c (optimize_function): Don't inc/dec function_depth.\n        * semantics.c (expand_body): Use tree_rest_of_compilation.\n        (cxx_expand_function_start): Rename from genrtl_start_function,\n        omit bits done by tree_rest_of_compilation.\n        (genrtl_finish_function): Remove.\n        (clear_decl_rtl): Move to ../tree-optimize.c.\n\nCo-Authored-By: Jason Merrill <jason@redhat.com>\n\nFrom-SVN: r70933", "tree": {"sha": "d3ecf1a361ca516453ed6172c096bc2f280d5875", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3ecf1a361ca516453ed6172c096bc2f280d5875"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4985cde3ef44391a43fd95c0972bf72c86e127cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4985cde3ef44391a43fd95c0972bf72c86e127cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4985cde3ef44391a43fd95c0972bf72c86e127cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4985cde3ef44391a43fd95c0972bf72c86e127cb/comments", "author": null, "committer": null, "parents": [{"sha": "fc2b84778bb51750c841f53b1ba30950935cc901", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc2b84778bb51750c841f53b1ba30950935cc901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc2b84778bb51750c841f53b1ba30950935cc901"}], "stats": {"total": 823, "additions": 422, "deletions": 401}, "files": [{"sha": "fdabb62d39d3fd742165688651c89b4458320d43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -1,3 +1,22 @@\n+2003-08-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-optimize.c: New file.\n+\t* Makefile.in (OBJS-archive): Add tree-optimize.o.\n+\t(tree-optimize.o): New.\n+\t* c-decl.c (store_parm_decls): Use allocate_struct_function.\n+\t(finish_function): Don't free_after_parsing or free_after_compilation.\n+\t(set_save_expr_context): Move to tree-optimize.c.\n+\t(c_expand_body_1): Use tree_rest_of_compilation.\n+\t* c-lang.c (LANG_HOOKS_RTL_EXPAND_STMT): New.\n+\t* objc/objc-lang.c (LANG_HOOKS_RTL_EXPAND_STMT): New.\n+\t* c-objc-common.c (expand_deferred_fns): Don't emit unused inlines;\n+\titerate until closure.\n+\t* langhooks-def.h (LANG_HOOKS_RTL_EXPAND_START,\n+\tLANG_HOOKS_RTL_EXPAND_STMT, LANG_HOOKS_RTL_EXPAND_END): New.\n+\t(LANG_HOOKS_RTL_EXPAND_INITIALIZER): New.\n+\t* langhooks.h (struct lang_hooks_for_rtl_expansion): New.\n+\t* toplev.h (tree_rest_of_compilation): Declare it.\n+\n 2003-08-29  Richard Henderson  <rth@redhat.com>\n \n \t* function.h (struct function): Add rtl_inline_init, saved_for_inline."}, {"sha": "3ea2c569d748c6be2a1c048245bf823406535c55", "filename": "gcc/Makefile.in", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -845,7 +845,7 @@ OBJS-common = \\\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) hashtable.o tree-inline.o\t   \\\n-  cgraph.o cgraphunit.o\n+  tree-optimize.o cgraph.o cgraphunit.o\n \n OBJS = $(OBJS-common) $(out_object_file) $(OBJS-archive)\n \n@@ -1466,10 +1466,13 @@ tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) flags.h fu\n tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(C_TREE_H) flags.h langhooks.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n    $(EXPR_H) $(SPLAY_TREE_H) tree-dump.h\n-tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   $(RTL_H) $(EXPR_H) flags.h $(PARAMS_H) input.h insn-config.h $(INTEGRATE_H) \\\n-   $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h langhooks.h \\\n-   $(C_COMMON_H) tree-inline.h cgraph.h\n+tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) $(RTL_H) $(EXPR_H) flags.h $(PARAMS_H) input.h insn-config.h \\\n+   $(INTEGRATE_H) $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h \\\n+   langhooks.h $(C_COMMON_H) tree-inline.h cgraph.h\n+tree-optimize.o : tree-optimize.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) toplev.h langhooks.h cgraph.h $(TIMEVAR_H) function.h $(GGC_H)\n+\n print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(GGC_H) langhooks.h real.h\n stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\"}, {"sha": "eef6e6df7b5d80dd55812b878d2b6a52219c097a", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 135, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -6032,7 +6032,7 @@ store_parm_decls (void)\n   gen_aux_info_record (fndecl, 1, 0, prototype);\n \n   /* Initialize the RTL code for the function.  */\n-  init_function_start (fndecl);\n+  allocate_struct_function (fndecl);\n \n   /* Begin the statement tree for this function.  */\n   begin_stmt_tree (&DECL_SAVED_TREE (fndecl));\n@@ -6142,11 +6142,8 @@ finish_function (int nested, int can_defer_p)\n       && DECL_INLINE (fndecl))\n     warning (\"no return statement in function returning non-void\");\n \n-  /* Clear out memory we no longer need.  */\n-  free_after_parsing (cfun);\n-  /* Since we never call rest_of_compilation, we never clear\n-     CFUN.  Do so explicitly.  */\n-  free_after_compilation (cfun);\n+  /* We're leaving the context of this function, so zap cfun.  It's still in\n+     DECL_SAVED_INSNS, and we'll restore it in tree_rest_of_compilation.  */\n   cfun = NULL;\n \n   if (flag_unit_at_a_time && can_defer_p)\n@@ -6239,25 +6236,6 @@ c_expand_deferred_function (tree fndecl)\n     }\n }\n \n-/* Called to move the SAVE_EXPRs for parameter declarations in a\n-   nested function into the nested function.  DATA is really the\n-   nested FUNCTION_DECL.  */\n-\n-static tree\n-set_save_expr_context (tree *tp,\n-\t\t       int *walk_subtrees,\n-\t\t       void *data)\n-{\n-  if (TREE_CODE (*tp) == SAVE_EXPR && !SAVE_EXPR_CONTEXT (*tp))\n-    SAVE_EXPR_CONTEXT (*tp) = (tree) data;\n-  /* Do not walk back into the SAVE_EXPR_CONTEXT; that will cause\n-     circularity.  */\n-  else if (DECL_P (*tp))\n-    *walk_subtrees = 0;\n-\n-  return NULL_TREE;\n-}\n-\n /* Generate the RTL for the body of FNDECL.  If NESTED_P is nonzero,\n    then we are already in the process of generating RTL for another\n    function.  If can_defer_p is zero, we won't attempt to defer the\n@@ -6266,78 +6244,14 @@ set_save_expr_context (tree *tp,\n static void\n c_expand_body_1 (tree fndecl, int nested_p)\n {\n-  timevar_push (TV_EXPAND);\n-\n   if (nested_p)\n     {\n       /* Make sure that we will evaluate variable-sized types involved\n \t in our function's type.  */\n       expand_pending_sizes (DECL_LANG_SPECIFIC (fndecl)->pending_sizes);\n-      /* Squirrel away our current state.  */\n-      push_function_context ();\n     }\n \n-  /* Initialize the RTL code for the function.  */\n-  current_function_decl = fndecl;\n-  input_location = DECL_SOURCE_LOCATION (fndecl);\n-  init_function_start (fndecl);\n-\n-  /* This function is being processed in whole-function mode.  */\n-  cfun->x_whole_function_mode_p = 1;\n-\n-  /* Even though we're inside a function body, we still don't want to\n-     call expand_expr to calculate the size of a variable-sized array.\n-     We haven't necessarily assigned RTL to all variables yet, so it's\n-     not safe to try to expand expressions involving them.  */\n-  immediate_size_expand = 0;\n-  cfun->x_dont_save_pending_sizes_p = 1;\n-\n-  /* Set up parameters and prepare for return, for the function.  */\n-  expand_function_start (fndecl, 0);\n-\n-  /* If the function has a variably modified type, there may be\n-     SAVE_EXPRs in the parameter types.  Their context must be set to\n-     refer to this function; they cannot be expanded in the containing\n-     function.  */\n-  if (decl_function_context (fndecl)\n-      && variably_modified_type_p (TREE_TYPE (fndecl)))\n-    walk_tree (&TREE_TYPE (fndecl), set_save_expr_context, fndecl,\n-\t       NULL);\n-\n-  /* If this function is `main', emit a call to `__main'\n-     to run global initializers, etc.  */\n-  if (DECL_NAME (fndecl)\n-      && MAIN_NAME_P (DECL_NAME (fndecl))\n-      && DECL_FILE_SCOPE_P (fndecl))\n-    expand_main_function ();\n-\n-  /* Generate the RTL for this function.  */\n-  expand_stmt (DECL_SAVED_TREE (fndecl));\n-\n-  /* We hard-wired immediate_size_expand to zero above.\n-     expand_function_end will decrement this variable.  So, we set the\n-     variable to one here, so that after the decrement it will remain\n-     zero.  */\n-  immediate_size_expand = 1;\n-\n-  /* Allow language dialects to perform special processing.  */\n-  if (lang_expand_function_end)\n-    (*lang_expand_function_end) ();\n-\n-  /* Generate rtl for function exit.  */\n-  expand_function_end ();\n-\n-  /* If this is a nested function, protect the local variables in the stack\n-     above us from being collected while we're compiling this function.  */\n-  if (nested_p)\n-    ggc_push_context ();\n-\n-  /* Run the optimizers and output the assembler code for this function.  */\n-  rest_of_compilation (fndecl);\n-\n-  /* Undo the GC context switch.  */\n-  if (nested_p)\n-    ggc_pop_context ();\n+  tree_rest_of_compilation (fndecl);\n \n   /* With just -Wextra, complain only if function returns both with\n      and without a value.  */\n@@ -6346,46 +6260,6 @@ c_expand_body_1 (tree fndecl, int nested_p)\n       && current_function_returns_null)\n     warning (\"this function may return with or without a value\");\n \n-  /* If requested, warn about function definitions where the function will\n-     return a value (usually of some struct or union type) which itself will\n-     take up a lot of stack space.  */\n-\n-  if (warn_larger_than && !DECL_EXTERNAL (fndecl) && TREE_TYPE (fndecl))\n-    {\n-      tree ret_type = TREE_TYPE (TREE_TYPE (fndecl));\n-\n-      if (ret_type && TYPE_SIZE_UNIT (ret_type)\n-\t  && TREE_CODE (TYPE_SIZE_UNIT (ret_type)) == INTEGER_CST\n-\t  && 0 < compare_tree_int (TYPE_SIZE_UNIT (ret_type),\n-\t\t\t\t   larger_than_size))\n-\t{\n-          const location_t *locus = &DECL_SOURCE_LOCATION (fndecl);\n-\t  unsigned int size_as_int\n-\t    = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (ret_type));\n-\n-\t  if (compare_tree_int (TYPE_SIZE_UNIT (ret_type), size_as_int) == 0)\n-\t    warning (\"%Hsize of return value of '%D' is %u bytes\",\n-                     locus, fndecl, size_as_int);\n-\t  else\n-\t    warning (\"%Hsize of return value of '%D' is larger than %wd bytes\",\n-                     locus, fndecl, larger_than_size);\n-\t}\n-    }\n-\n-  if (DECL_SAVED_INSNS (fndecl) == 0 && ! nested_p\n-      && ! flag_inline_trees)\n-    {\n-      /* Stop pointing to the local nodes about to be freed.\n-\t But DECL_INITIAL must remain nonzero so we know this\n-\t was an actual function definition.\n-\t For a nested function, this is done in c_pop_function_context.\n-\t If rest_of_compilation set this to 0, leave it 0.  */\n-      if (DECL_INITIAL (fndecl) != 0)\n-\tDECL_INITIAL (fndecl) = error_mark_node;\n-\n-      DECL_ARGUMENTS (fndecl) = 0;\n-    }\n-\n   if (DECL_STATIC_CONSTRUCTOR (fndecl))\n     {\n       if (targetm.have_ctors_dtors)\n@@ -6403,11 +6277,6 @@ c_expand_body_1 (tree fndecl, int nested_p)\n       else\n \tstatic_dtors = tree_cons (NULL_TREE, fndecl, static_dtors);\n     }\n-\n-  if (nested_p)\n-    /* Return to the enclosing function.  */\n-    pop_function_context ();\n-  timevar_pop (TV_EXPAND);\n }\n \n /* Like c_expand_body_1 but only for unnested functions.  */"}, {"sha": "fb1741dea136f0395e5a64db0a35a95a13f776bb", "filename": "gcc/c-lang.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -90,6 +90,9 @@ enum c_language_kind c_language = clk_c;\n #undef LANG_HOOKS_DECL_UNINIT\n #define LANG_HOOKS_DECL_UNINIT c_decl_uninit\n \n+#undef LANG_HOOKS_RTL_EXPAND_STMT\n+#define LANG_HOOKS_RTL_EXPAND_STMT expand_stmt\n+\n /* Attribute hooks.  */\n #undef LANG_HOOKS_COMMON_ATTRIBUTE_TABLE\n #define LANG_HOOKS_COMMON_ATTRIBUTE_TABLE c_common_attribute_table"}, {"sha": "16e0cffec32e8946edc0e6cb65e26270ffa1a82f", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -289,20 +289,43 @@ static void\n expand_deferred_fns (void)\n {\n   unsigned int i;\n+  bool reconsider;\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (deferred_fns); i++)\n+  do\n     {\n-      tree decl = VARRAY_TREE (deferred_fns, i);\n-\n-      if (! TREE_ASM_WRITTEN (decl))\n+      reconsider = false;\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (deferred_fns); i++)\n \t{\n-\t  /* For static inline functions, delay the decision whether to\n-\t     emit them or not until wrapup_global_declarations.  */\n-\t  if (! TREE_PUBLIC (decl))\n-\t    DECL_DEFER_OUTPUT (decl) = 1;\n+\t  tree decl = VARRAY_TREE (deferred_fns, i);\n+\n+\t  if (TREE_ASM_WRITTEN (decl))\n+\t    continue;\n+\n+\t  /* \"extern inline\" says the symbol exists externally,\n+\t      which means we should *never* expand it locally \n+\t      unless we're actually inlining it.  */\n+\t  /* ??? Why did we queue these in the first place?  */\n+\t  if (DECL_DECLARED_INLINE_P (decl) && DECL_EXTERNAL (decl))\n+\t    continue;\n+\t      \n+\t  /* With flag_keep_inline_functions, we're emitting everything,\n+\t     so we never need to reconsider.  */\n+\t  if (flag_keep_inline_functions)\n+\t    ;\n+\t  /* Must emit all public functions.  C doesn't have COMDAT\n+\t     functions, so we don't need to check that, like C++.  */\n+\t  else if (TREE_PUBLIC (decl))\n+\t    reconsider = true;\n+\t  /* Must emit if the symbol is referenced.  */\n+\t  else if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n+\t    reconsider = true;\n+\t  else\n+\t    continue;\n+\n \t  c_expand_deferred_function (decl);\n \t}\n     }\n+  while (reconsider);\n \n   deferred_fns = 0;\n }"}, {"sha": "503a3b86e5be5746aee5afa878a8337ae6903863", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -1,3 +1,21 @@\n+2003-08-29  Richard Henderson  <rth@redhat.com>\n+\t    Jason Merrill <jason@redhat.com>\n+\n+\t* cp-lang.c (LANG_HOOKS_RTL_EXPAND_START): New.\n+\t(LANG_HOOKS_RTL_EXPAND_STMT): New.\n+\t* cp-tree.h (cxx_expand_function_start): Declare.\n+\t* decl.c (start_function): Use allocate_struct_function.\n+\tMove stmts_are_full_exprs_p assertion from expand_body.\n+\tDo not free_after_parsing or free_after_compilation.\n+\t(cxx_push_function_context): Move code to set struct function\n+\tdata from genrtl_start_function.\n+\t* optimize.c (optimize_function): Don't inc/dec function_depth.\n+\t* semantics.c (expand_body): Use tree_rest_of_compilation.\n+\t(cxx_expand_function_start): Rename from genrtl_start_function,\n+\tomit bits done by tree_rest_of_compilation.\n+\t(genrtl_finish_function): Remove.\n+\t(clear_decl_rtl): Move to ../tree-optimize.c.\n+\n 2003-08-29  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \tPR c++/11811"}, {"sha": "4d5ed27b3c7ddd1c4e8824ab529b56d85c06770f", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -115,6 +115,11 @@ static void cxx_initialize_diagnostics (diagnostic_context *);\n #undef LANG_HOOKS_FUNCTION_FINAL\n #define LANG_HOOKS_FUNCTION_FINAL cxx_pop_function_context\n \n+#undef LANG_HOOKS_RTL_EXPAND_START\n+#define LANG_HOOKS_RTL_EXPAND_START cxx_expand_function_start\n+#undef LANG_HOOKS_RTL_EXPAND_STMT\n+#define LANG_HOOKS_RTL_EXPAND_STMT expand_stmt\n+\n /* Attribute hooks.  */\n #undef LANG_HOOKS_COMMON_ATTRIBUTE_TABLE\n #define LANG_HOOKS_COMMON_ATTRIBUTE_TABLE c_common_attribute_table"}, {"sha": "1a2f06e1ad205edc551e5e8cf3b25bf1a2c6abd4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -4137,6 +4137,7 @@ extern tree finish_alignof\t\t\t(tree);\n extern void finish_decl_cleanup                 (tree, tree);\n extern void finish_eh_cleanup                   (tree);\n extern void expand_body                         (tree);\n+extern void cxx_expand_function_start\t\t(void);\n extern tree nullify_returns_r\t\t      (tree *, int *, void *);\n extern void do_pushlevel                        (scope_kind);\n extern tree do_poplevel                         (void);"}, {"sha": "b4eb0192eb8100dc048f937a3901cba187b75fe2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -13539,7 +13539,7 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n      CFUN set up, and our per-function variables initialized.\n      FIXME factor out the non-RTL stuff.  */\n   bl = current_binding_level;\n-  init_function_start (decl1);\n+  allocate_struct_function (decl1);\n   current_binding_level = bl;\n \n   /* Even though we're inside a function body, we still don't want to\n@@ -14084,6 +14084,10 @@ finish_function (int flags)\n     }\n   poplevel (1, 0, 1);\n \n+  /* Statements should always be full-expressions at the outermost set\n+     of curly braces for a function.  */\n+  my_friendly_assert (stmts_are_full_exprs_p (), 19990831);\n+\n   /* Set up the named return value optimization, if we can.  Here, we\n      eliminate the copy from the nrv into the RESULT_DECL and any cleanup\n      for the nrv.  genrtl_start_function and declare_return_variable\n@@ -14154,12 +14158,9 @@ finish_function (int flags)\n \t inline function, as we might never be compiled separately.  */\n       && (DECL_INLINE (fndecl) || processing_template_decl))\n     warning (\"no return statement in function returning non-void\");\n-    \n-  /* Clear out memory we no longer need.  */\n-  free_after_parsing (cfun);\n-  /* Since we never call rest_of_compilation, we never clear\n-     CFUN.  Do so explicitly.  */\n-  free_after_compilation (cfun);\n+\n+  /* We're leaving the context of this function, so zap cfun.  It's still in\n+     DECL_SAVED_INSNS, and we'll restore it in tree_rest_of_compilation.  */\n   cfun = NULL;\n \n   /* If this is an in-class inline definition, we may have to pop the\n@@ -14479,6 +14480,31 @@ cxx_push_function_context (struct function * f)\n   /* Whenever we start a new function, we destroy temporaries in the\n      usual way.  */\n   current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n+\n+  if (f->decl)\n+    {\n+      tree fn = f->decl;\n+\n+      current_function_is_thunk = DECL_THUNK_P (fn);\n+\n+      if (DECL_SAVED_FUNCTION_DATA (fn))\n+\t{\n+\t  /* If we already parsed this function, and we're just expanding it\n+\t     now, restore saved state.  */\n+\t  *cp_function_chain = *DECL_SAVED_FUNCTION_DATA (fn);\n+\n+\t  /* If we decided that we didn't want to inline this function,\n+\t     make sure the back-end knows that.  */\n+\t  if (!current_function_cannot_inline)\n+\t    current_function_cannot_inline = cp_function_chain->cannot_inline;\n+\n+\t  /* We don't need the saved data anymore.  Unless this is an inline\n+\t     function; we need the named return value info for\n+\t     cp_copy_res_decl_for_inlining.  */\n+\t  if (! DECL_INLINE (fn))\n+\t    DECL_SAVED_FUNCTION_DATA (fn) = NULL;\n+\t}\n+    }\n }\n \n /* Free the language-specific parts of F, now that we've finished"}, {"sha": "8c604e3bf8b179d4e3f808cd80257af46d6118e6", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -49,17 +49,6 @@ optimize_function (tree fn)\n {\n   dump_function (TDI_original, fn);\n \n-  /* While in this function, we may choose to go off and compile\n-     another function.  For example, we might instantiate a function\n-     in the hopes of inlining it.  Normally, that wouldn't trigger any\n-     actual RTL code-generation -- but it will if the template is\n-     actually needed.  (For example, if it's address is taken, or if\n-     some other function already refers to the template.)  If\n-     code-generation occurs, then garbage collection will occur, so we\n-     must protect ourselves, just as we do while building up the body\n-     of the function.  */\n-  ++function_depth;\n-\n   if (flag_inline_trees\n       /* We do not inline thunks, as (a) the backend tries to optimize\n          the call to the thunkee, (b) tree based inlining breaks that\n@@ -72,9 +61,6 @@ optimize_function (tree fn)\n       dump_function (TDI_inlined, fn);\n     }\n   \n-  /* Undo the call to ggc_push_context above.  */\n-  --function_depth;\n-  \n   dump_function (TDI_optimized, fn);\n }\n "}, {"sha": "c9f3675d3072d50fb583da740f658615d469fdd5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 19, "deletions": 231, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -59,9 +59,7 @@ static void genrtl_try_block (tree);\n static void genrtl_eh_spec_block (tree);\n static void genrtl_handler (tree);\n static void cp_expand_stmt (tree);\n-static void genrtl_start_function (tree);\n-static void genrtl_finish_function (tree);\n-static tree clear_decl_rtl (tree *, int *, void *);\n+\n \n /* Finish processing the COND, the SUBSTMT condition for STMT.  */\n \n@@ -2863,9 +2861,6 @@ expand_body (tree fn)\n   location_t saved_loc;\n   tree saved_function;\n   \n-  if (flag_unit_at_a_time && !cgraph_global_info_ready)\n-    abort ();\n-\n   /* Compute the appropriate object-file linkage for inline\n      functions.  */\n   if (DECL_DECLARED_INLINE_P (fn))\n@@ -2879,61 +2874,35 @@ expand_body (tree fn)\n   if (DECL_EXTERNAL (fn))\n     return;\n \n-  /* Save the current file name and line number.  When we expand the\n-     body of the function, we'll set INPUT_LOCATION so that\n-     error-messages come out in the right places.  */\n+  /* ??? When is this needed?  */\n   saved_loc = input_location;\n   saved_function = current_function_decl;\n-  input_location = DECL_SOURCE_LOCATION (fn);\n-  current_function_decl = fn;\n \n   timevar_push (TV_INTEGRATION);\n-\n-  /* Optimize the body of the function before expanding it.  */\n   optimize_function (fn);\n-\n   timevar_pop (TV_INTEGRATION);\n-  timevar_push (TV_EXPAND);\n-\n-  genrtl_start_function (fn);\n-  current_function_is_thunk = DECL_THUNK_P (fn);\n-\n-  /* Expand the body.  */\n-  expand_stmt (DECL_SAVED_TREE (fn));\n-\n-  /* Statements should always be full-expressions at the outermost set\n-     of curly braces for a function.  */\n-  my_friendly_assert (stmts_are_full_exprs_p (), 19990831);\n-\n-  /* The outermost statement for a function contains the line number\n-     recorded when we finished processing the function.  */\n-  input_line = STMT_LINENO (DECL_SAVED_TREE (fn));\n-\n-  /* Generate code for the function.  */\n-  genrtl_finish_function (fn);\n \n-  /* If possible, obliterate the body of the function so that it can\n-     be garbage collected.  */\n-  if (dump_enabled_p (TDI_all))\n-    /* Keep the body; we're going to dump it.  */\n-    ;\n-  else if (DECL_INLINE (fn) && flag_inline_trees)\n-    /* We might need the body of this function so that we can expand\n-       it inline somewhere else.  */\n-    ;\n-  else\n-    /* We don't need the body; blow it away.  */\n-    DECL_SAVED_TREE (fn) = NULL_TREE;\n+  tree_rest_of_compilation (fn);\n \n-  /* And restore the current source position.  */\n   current_function_decl = saved_function;\n   input_location = saved_loc;\n-  extract_interface_info ();\n \n-  timevar_pop (TV_EXPAND);\n+  extract_interface_info ();\n \n   /* Emit any thunks that should be emitted at the same time as FN.  */\n   emit_associated_thunks (fn);\n+\n+  /* If this function is marked with the constructor attribute, add it\n+     to the list of functions to be called along with constructors\n+     from static duration objects.  */\n+  if (DECL_STATIC_CONSTRUCTOR (fn))\n+    static_ctors = tree_cons (NULL_TREE, fn, static_ctors);\n+\n+  /* If this function is marked with the destructor attribute, add it\n+     to the list of functions to be called along with destructors from\n+     static duration objects.  */\n+  if (DECL_STATIC_DESTRUCTOR (fn))\n+    static_dtors = tree_cons (NULL_TREE, fn, static_dtors);\n }\n \n /* Generate RTL for FN.  */\n@@ -3062,197 +3031,16 @@ nullify_returns_r (tree* tp, int* walk_subtrees, void* data)\n \n /* Start generating the RTL for FN.  */\n \n-static void\n-genrtl_start_function (tree fn)\n+void\n+cxx_expand_function_start (void)\n {\n-  /* Tell everybody what function we're processing.  */\n-  current_function_decl = fn;\n-  /* Get the RTL machinery going for this function.  */\n-  init_function_start (fn);\n   /* Let everybody know that we're expanding this function, not doing\n      semantic analysis.  */\n   expanding_p = 1;\n \n-  /* Even though we're inside a function body, we still don't want to\n-     call expand_expr to calculate the size of a variable-sized array.\n-     We haven't necessarily assigned RTL to all variables yet, so it's\n-     not safe to try to expand expressions involving them.  */\n-  immediate_size_expand = 0;\n-  cfun->x_dont_save_pending_sizes_p = 1;\n-\n-  /* Let the user know we're compiling this function.  */\n-  announce_function (fn);\n-\n-  /* Initialize the per-function data.  */\n-  my_friendly_assert (!DECL_PENDING_INLINE_P (fn), 20000911);\n-  if (DECL_SAVED_FUNCTION_DATA (fn))\n-    {\n-      /* If we already parsed this function, and we're just expanding it\n-\t now, restore saved state.  */\n-      *cp_function_chain = *DECL_SAVED_FUNCTION_DATA (fn);\n-\n-      /* This function is being processed in whole-function mode; we\n-\t already did semantic analysis.  */\n-      cfun->x_whole_function_mode_p = 1;\n-\n-      /* If we decided that we didn't want to inline this function,\n-\t make sure the back-end knows that.  */\n-      if (!current_function_cannot_inline)\n-\tcurrent_function_cannot_inline = cp_function_chain->cannot_inline;\n-\n-      /* We don't need the saved data anymore.  Unless this is an inline\n-         function; we need the named return value info for\n-         cp_copy_res_decl_for_inlining.  */\n-      if (! DECL_INLINE (fn))\n-\tDECL_SAVED_FUNCTION_DATA (fn) = NULL;\n-    }\n-\n-  /* Keep track of how many functions we're presently expanding.  */\n-  ++function_depth;\n-\n-  /* Create a binding level for the parameters.  */\n-  expand_function_start (fn, /*parms_have_cleanups=*/0);\n-  /* If this function is `main'.  */\n-  if (DECL_MAIN_P (fn))\n-    expand_main_function ();\n-\n   /* Give our named return value the same RTL as our RESULT_DECL.  */\n   if (current_function_return_value)\n-    COPY_DECL_RTL (DECL_RESULT (fn), current_function_return_value);\n-}\n-\n-/* Finish generating the RTL for FN.  */\n-\n-static void\n-genrtl_finish_function (tree fn)\n-{\n-  tree t;\n-\n-#if 0\n-  if (write_symbols != NO_DEBUG)\n-    {\n-      /* Keep this code around in case we later want to control debug info\n-\t based on whether a type is \"used\".  (jason 1999-11-11) */\n-\n-      tree ttype = target_type (fntype);\n-      tree parmdecl;\n-\n-      if (IS_AGGR_TYPE (ttype))\n-\t/* Let debugger know it should output info for this type.  */\n-\tnote_debug_info_needed (ttype);\n-\n-      for (parmdecl = DECL_ARGUMENTS (fndecl); parmdecl; parmdecl = TREE_CHAIN (parmdecl))\n-\t{\n-\t  ttype = target_type (TREE_TYPE (parmdecl));\n-\t  if (IS_AGGR_TYPE (ttype))\n-\t    /* Let debugger know it should output info for this type.  */\n-\t    note_debug_info_needed (ttype);\n-\t}\n-    }\n-#endif\n-\n-  /* Clean house because we will need to reorder insns here.  */\n-  do_pending_stack_adjust ();\n-\n-  /* If we have a named return value, we need to force a return so that\n-     the return register is USEd.  */\n-  if (DECL_NAME (DECL_RESULT (fn)))\n-    emit_jump (return_label);\n-\n-  /* We hard-wired immediate_size_expand to zero in start_function.\n-     Expand_function_end will decrement this variable.  So, we set the\n-     variable to one here, so that after the decrement it will remain\n-     zero.  */\n-  immediate_size_expand = 1;\n-\n-  /* Generate rtl for function exit.  */\n-  expand_function_end ();\n-\n-  /* If this is a nested function (like a template instantiation that\n-     we're compiling in the midst of compiling something else), push a\n-     new GC context.  That will keep local variables on the stack from\n-     being collected while we're doing the compilation of this\n-     function.  */\n-  if (function_depth > 1)\n-    ggc_push_context ();\n-\n-  /* There's no need to defer outputting this function any more; we\n-     know we want to output it.  */\n-  DECL_DEFER_OUTPUT (fn) = 0;\n-\n-  /* Run the optimizers and output the assembler code for this\n-     function.  */\n-  rest_of_compilation (fn);\n-\n-  /* Undo the call to ggc_push_context above.  */\n-  if (function_depth > 1)\n-    ggc_pop_context ();\n-\n-#if 0\n-  /* Keep this code around in case we later want to control debug info\n-     based on whether a type is \"used\".  (jason 1999-11-11) */\n-\n-  if (ctype && TREE_ASM_WRITTEN (fn))\n-    note_debug_info_needed (ctype);\n-#endif\n-\n-  /* If this function is marked with the constructor attribute, add it\n-     to the list of functions to be called along with constructors\n-     from static duration objects.  */\n-  if (DECL_STATIC_CONSTRUCTOR (fn))\n-    static_ctors = tree_cons (NULL_TREE, fn, static_ctors);\n-\n-  /* If this function is marked with the destructor attribute, add it\n-     to the list of functions to be called along with destructors from\n-     static duration objects.  */\n-  if (DECL_STATIC_DESTRUCTOR (fn))\n-    static_dtors = tree_cons (NULL_TREE, fn, static_dtors);\n-\n-  --function_depth;\n-\n-  /* In C++, we should never be saving RTL for the function.  */\n-  my_friendly_assert (!DECL_SAVED_INSNS (fn), 20010903);\n-\n-  /* Since we don't need the RTL for this function anymore, stop\n-     pointing to it.  That's especially important for LABEL_DECLs,\n-     since you can reach all the instructions in the function from the\n-     CODE_LABEL stored in the DECL_RTL for the LABEL_DECL.  Walk the\n-     BLOCK-tree, clearing DECL_RTL for LABEL_DECLs and non-static\n-     local variables.  */\n-  walk_tree_without_duplicates (&DECL_SAVED_TREE (fn),\n-\t\t\t\tclear_decl_rtl,\n-\t\t\t\tNULL);\n-\n-  /* Clear out the RTL for the arguments.  */\n-  for (t = DECL_ARGUMENTS (fn); t; t = TREE_CHAIN (t))\n-    {\n-      SET_DECL_RTL (t, NULL_RTX);\n-      DECL_INCOMING_RTL (t) = NULL_RTX;\n-    }\n-\n-  if (!(flag_inline_trees && DECL_INLINE (fn)))\n-    /* DECL_INITIAL must remain nonzero so we know this was an\n-       actual function definition.  */\n-    DECL_INITIAL (fn) = error_mark_node;\n-  \n-  /* Let the error reporting routines know that we're outside a\n-     function.  For a nested function, this value is used in\n-     pop_cp_function_context and then reset via pop_function_context.  */\n-  current_function_decl = NULL_TREE;\n-}\n-\n-/* Clear out the DECL_RTL for the non-static variables in BLOCK and\n-   its sub-blocks.  */\n-\n-static tree\n-clear_decl_rtl (tree* tp, \n-                int* walk_subtrees ATTRIBUTE_UNUSED , \n-                void* data ATTRIBUTE_UNUSED )\n-{\n-  if (nonstatic_local_decl_p (*tp)) \n-    SET_DECL_RTL (*tp, NULL_RTX);\n-    \n-  return NULL_TREE;\n+    COPY_DECL_RTL (DECL_RESULT (cfun->decl), current_function_return_value);\n }\n \n /* Perform initialization related to this module.  */"}, {"sha": "ee30749f536ca358fccf90231f75dfb4deaa308d", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -123,6 +123,10 @@ extern void lhd_initialize_diagnostics (struct diagnostic_context *);\n #define LANG_HOOKS_FUNCTION_ENTER_NESTED lhd_do_nothing_f\n #define LANG_HOOKS_FUNCTION_LEAVE_NESTED lhd_do_nothing_f\n \n+#define LANG_HOOKS_RTL_EXPAND_START\tlhd_do_nothing\n+#define LANG_HOOKS_RTL_EXPAND_STMT\t(void *) abort\n+#define LANG_HOOKS_RTL_EXPAND_END\tlhd_do_nothing\n+\n /* Attribute hooks.  */\n #define LANG_HOOKS_ATTRIBUTE_TABLE\t\tNULL\n #define LANG_HOOKS_COMMON_ATTRIBUTE_TABLE\tNULL\n@@ -186,6 +190,12 @@ extern void lhd_initialize_diagnostics (struct diagnostic_context *);\n   LANG_HOOKS_FUNCTION_LEAVE_NESTED\t\t\\\n }\n \n+#define LANG_HOOKS_RTL_EXPAND_INITIALIZER {\t\\\n+  LANG_HOOKS_RTL_EXPAND_START,\t\t\t\\\n+  LANG_HOOKS_RTL_EXPAND_STMT,\t\t\t\\\n+  LANG_HOOKS_RTL_EXPAND_END\t\t\t\\\n+}\n+\n /* Tree dump hooks.  */\n extern bool lhd_tree_dump_dump_tree (void *, tree);\n extern int lhd_tree_dump_type_quals (tree);\n@@ -289,7 +299,8 @@ extern int lhd_tree_dump_type_quals (tree);\n   LANG_HOOKS_CALLGRAPH_INITIALIZER, \\\n   LANG_HOOKS_TREE_DUMP_INITIALIZER, \\\n   LANG_HOOKS_DECLS, \\\n-  LANG_HOOKS_FOR_TYPES_INITIALIZER \\\n+  LANG_HOOKS_FOR_TYPES_INITIALIZER, \\\n+  LANG_HOOKS_RTL_EXPAND_INITIALIZER \\\n }\n \n #endif /* GCC_LANG_HOOKS_DEF_H */"}, {"sha": "109dfa1a818641f48b043fb2885e9229acdf448c", "filename": "gcc/langhooks.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -77,6 +77,19 @@ struct lang_hooks_for_functions\n   void (*leave_nested) (struct function *);\n };\n \n+/* Lang hooks for rtl code generation.  */\n+struct lang_hooks_for_rtl_expansion\n+{\n+  /* Called after expand_function_start, but before expanding the body.  */\n+  void (*start) (void);\n+\n+  /* Called to expand each statement.  */\n+  void (*stmt) (tree);\n+\n+  /* Called after expanding the body but before expand_function_end.  */\n+  void (*end) (void);\n+};\n+\n /* The following hooks are used by tree-dump.c.  */\n \n struct lang_hooks_for_tree_dump\n@@ -387,6 +400,8 @@ struct lang_hooks\n \n   struct lang_hooks_for_types types;\n \n+  struct lang_hooks_for_rtl_expansion rtl_expand;\n+\n   /* Whenever you add entries here, make sure you adjust langhooks-def.h\n      and langhooks.c accordingly.  */\n };"}, {"sha": "3f70122302c4f157dad8ec3c8cbaec87e1e56b5b", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -87,6 +87,9 @@ enum c_language_kind c_language = clk_objc;\n #undef LANG_HOOKS_FUNCTION_LEAVE_NESTED\n #define LANG_HOOKS_FUNCTION_LEAVE_NESTED c_pop_function_context\n \n+#undef LANG_HOOKS_RTL_EXPAND_STMT\n+#define LANG_HOOKS_RTL_EXPAND_STMT expand_stmt\n+\n /* Attribute hooks.  */\n #undef LANG_HOOKS_COMMON_ATTRIBUTE_TABLE\n #define LANG_HOOKS_COMMON_ATTRIBUTE_TABLE c_common_attribute_table"}, {"sha": "3ebd8e493f2ed39ce9dcd48d4efb58b43cef209d", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -66,6 +66,7 @@ extern void inform (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n extern void rest_of_decl_compilation (tree, const char *, int, int);\n extern void rest_of_type_compilation (tree, int);\n extern void rest_of_compilation (tree);\n+extern void tree_rest_of_compilation (tree);\n \n extern void announce_function (tree);\n "}, {"sha": "e5bea3ea5bc9da0c80b1ad71e7f8bd2fc7d5e45f", "filename": "gcc/tree-optimize.c", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4985cde3ef44391a43fd95c0972bf72c86e127cb/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=4985cde3ef44391a43fd95c0972bf72c86e127cb", "patch": "@@ -0,0 +1,250 @@\n+/* Control and data flow functions for trees.\n+   Copyright 2001, 2002, 2003 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"toplev.h\"\n+#include \"tree.h\"\n+#include \"tree-inline.h\"\n+#include \"flags.h\"\n+#include \"langhooks.h\"\n+#include \"cgraph.h\"\n+#include \"timevar.h\"\n+#include \"tm.h\"\n+#include \"function.h\"\n+#include \"ggc.h\"\n+\n+\n+/* Called to move the SAVE_EXPRs for parameter declarations in a\n+   nested function into the nested function.  DATA is really the\n+   nested FUNCTION_DECL.  */\n+\n+static tree\n+set_save_expr_context (tree *tp,\n+\t\t       int *walk_subtrees,\n+\t\t       void *data)\n+{\n+  if (TREE_CODE (*tp) == SAVE_EXPR && !SAVE_EXPR_CONTEXT (*tp))\n+    SAVE_EXPR_CONTEXT (*tp) = (tree) data;\n+  /* Do not walk back into the SAVE_EXPR_CONTEXT; that will cause\n+     circularity.  */\n+  else if (DECL_P (*tp))\n+    *walk_subtrees = 0;\n+\n+  return NULL;\n+}\n+\n+/* Clear out the DECL_RTL for the non-static local variables in BLOCK and\n+   its sub-blocks.  DATA is the decl of the function being processed.  */\n+\n+static tree\n+clear_decl_rtl (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED, void *data)\n+{\n+  bool nonstatic_p, local_p;\n+  tree t = *tp;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case VAR_DECL:\n+      nonstatic_p = !TREE_STATIC (t) && !DECL_EXTERNAL (t);\n+      local_p = DECL_CONTEXT (t) == data;\n+      break;\n+\n+    case PARM_DECL:\n+    case LABEL_DECL:\n+      nonstatic_p = true;\n+      local_p = DECL_CONTEXT (t) == data;\n+      break;\n+\n+    case RESULT_DECL:\n+      nonstatic_p = local_p = true;\n+      break;\n+\n+    default:\n+      nonstatic_p = local_p = false;\n+      break;\n+    }\n+\n+  if (nonstatic_p && local_p)\n+    SET_DECL_RTL (t, NULL);\n+\n+  return NULL;\n+}\n+\n+/* For functions-as-trees languages, this performs all optimization and\n+   compilation for FNDECL.  */\n+\n+void\n+tree_rest_of_compilation (tree fndecl)\n+{\n+  static int nesting = -1;\n+\n+  timevar_push (TV_EXPAND);\n+\n+  ++nesting;\n+\n+  if (flag_unit_at_a_time && !cgraph_global_info_ready)\n+    abort ();\n+\n+  if (nesting > 0)\n+    /* Squirrel away our current state.  */\n+    push_function_context ();\n+\n+  /* Initialize the RTL code for the function.  */\n+  current_function_decl = fndecl;\n+  input_location = DECL_SOURCE_LOCATION (fndecl);\n+  init_function_start (fndecl);\n+\n+  /* This function is being processed in whole-function mode.  */\n+  cfun->x_whole_function_mode_p = 1;\n+\n+  /* Even though we're inside a function body, we still don't want to\n+     call expand_expr to calculate the size of a variable-sized array.\n+     We haven't necessarily assigned RTL to all variables yet, so it's\n+     not safe to try to expand expressions involving them.  */\n+  immediate_size_expand = 0;\n+  cfun->x_dont_save_pending_sizes_p = 1;\n+\n+  /* If the function has a variably modified type, there may be\n+     SAVE_EXPRs in the parameter types.  Their context must be set to\n+     refer to this function; they cannot be expanded in the containing\n+     function.  */\n+  if (decl_function_context (fndecl)\n+      && variably_modified_type_p (TREE_TYPE (fndecl)))\n+    walk_tree (&TREE_TYPE (fndecl), set_save_expr_context, fndecl,\n+\t       NULL);\n+\n+  /* Set up parameters and prepare for return, for the function.  */\n+  expand_function_start (fndecl, 0);\n+\n+  /* Allow language dialects to perform special processing.  */\n+  (*lang_hooks.rtl_expand.start) ();\n+\n+  /* If this function is `main', emit a call to `__main'\n+     to run global initializers, etc.  */\n+  if (DECL_NAME (fndecl)\n+      && MAIN_NAME_P (DECL_NAME (fndecl))\n+      && DECL_FILE_SCOPE_P (fndecl))\n+    expand_main_function ();\n+\n+  /* Generate the RTL for this function.  */\n+  (*lang_hooks.rtl_expand.stmt) (DECL_SAVED_TREE (fndecl));\n+\n+  /* We hard-wired immediate_size_expand to zero above.\n+     expand_function_end will decrement this variable.  So, we set the\n+     variable to one here, so that after the decrement it will remain\n+     zero.  */\n+  immediate_size_expand = 1;\n+\n+  /* Allow language dialects to perform special processing.  */\n+  (*lang_hooks.rtl_expand.end) ();\n+\n+  /* Generate rtl for function exit.  */\n+  expand_function_end ();\n+\n+  /* If this is a nested function, protect the local variables in the stack\n+     above us from being collected while we're compiling this function.  */\n+  if (nesting > 0)\n+    ggc_push_context ();\n+\n+  /* There's no need to defer outputting this function any more; we\n+     know we want to output it.  */\n+  DECL_DEFER_OUTPUT (fndecl) = 0;\n+\n+  /* Run the optimizers and output the assembler code for this function.  */\n+  rest_of_compilation (fndecl);\n+\n+  /* Undo the GC context switch.  */\n+  if (nesting > 0)\n+    ggc_pop_context ();\n+\n+  /* If requested, warn about function definitions where the function will\n+     return a value (usually of some struct or union type) which itself will\n+     take up a lot of stack space.  */\n+  if (warn_larger_than && !DECL_EXTERNAL (fndecl) && TREE_TYPE (fndecl))\n+    {\n+      tree ret_type = TREE_TYPE (TREE_TYPE (fndecl));\n+\n+      if (ret_type && TYPE_SIZE_UNIT (ret_type)\n+\t  && TREE_CODE (TYPE_SIZE_UNIT (ret_type)) == INTEGER_CST\n+\t  && 0 < compare_tree_int (TYPE_SIZE_UNIT (ret_type),\n+\t\t\t\t   larger_than_size))\n+\t{\n+          const location_t *locus = &DECL_SOURCE_LOCATION (fndecl);\n+\t  unsigned int size_as_int\n+\t    = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (ret_type));\n+\n+\t  if (compare_tree_int (TYPE_SIZE_UNIT (ret_type), size_as_int) == 0)\n+\t    warning (\"%Hsize of return value of '%D' is %u bytes\",\n+                     locus, fndecl, size_as_int);\n+\t  else\n+\t    warning (\"%Hsize of return value of '%D' is larger than %wd bytes\",\n+                     locus, fndecl, larger_than_size);\n+\t}\n+    }\n+\n+  /* ??? Looks like some of this could be combined.  */\n+\n+  /* If possible, obliterate the body of the function so that it can\n+     be garbage collected.  */\n+  if (dump_enabled_p (TDI_all))\n+    /* Keep the body; we're going to dump it.  */\n+    ;\n+  else if (DECL_INLINE (fndecl) && flag_inline_trees)\n+    /* We might need the body of this function so that we can expand\n+       it inline somewhere else.  */\n+    ;\n+  else\n+    /* We don't need the body; blow it away.  */\n+    DECL_SAVED_TREE (fndecl) = NULL;\n+\n+  /* Since we don't need the RTL for this function anymore, stop pointing to\n+     it.  That's especially important for LABEL_DECLs, since you can reach all\n+     the instructions in the function from the CODE_LABEL stored in the\n+     DECL_RTL for the LABEL_DECL.  Walk the BLOCK-tree, clearing DECL_RTL for\n+     LABEL_DECLs and non-static local variables.  Note that we must check the\n+     context of the variables, otherwise processing a nested function can kill\n+     the rtl of a variable from an outer function.  */\n+  walk_tree_without_duplicates (&DECL_SAVED_TREE (fndecl),\n+\t\t\t\tclear_decl_rtl,\n+\t\t\t\tfndecl);\n+\n+  if (DECL_SAVED_INSNS (fndecl) == 0 && ! nesting && ! flag_inline_trees)\n+    {\n+      /* Stop pointing to the local nodes about to be freed.\n+\t But DECL_INITIAL must remain nonzero so we know this\n+\t was an actual function definition.\n+\t For a nested function, this is done in c_pop_function_context.\n+\t If rest_of_compilation set this to 0, leave it 0.  */\n+      if (DECL_INITIAL (fndecl) != 0)\n+\tDECL_INITIAL (fndecl) = error_mark_node;\n+\n+      DECL_ARGUMENTS (fndecl) = 0;\n+    }\n+\n+  if (nesting > 0)\n+    /* Return to the enclosing function.  */\n+    pop_function_context ();\n+\n+  --nesting;\n+\n+  timevar_pop (TV_EXPAND);\n+}"}]}