{"sha": "051e6fd745109c9de4d707ccd949722904a74987", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUxZTZmZDc0NTEwOWM5ZGU0ZDcwN2NjZDk0OTcyMjkwNGE3NDk4Nw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-01-17T20:18:43Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-17T20:18:43Z"}, "message": "cp-tree.h (scratchalloc): Remove.\n\n\t* cp-tree.h (scratchalloc): Remove.\n\t(build_scratch_list): Likewise.\n\t* call.c (convert_class_to_reference): Replace build_scratch_list\n\tand build_expr_list with build_tree_list.\n\t(add_candidate): Replace scratchalloc with expralloc.  Note memory\n\tleak.\n\t(build_user_type_conversion_1):  Replace build_scratch_list\n\tand build_expr_list with build_tree_list.\n\t(build_new_op): Likewise.\n\t(build_op_delete_call): Likewise.\n\t(convert_like): Likewise.\n\t* cvt.c (ocp_convert): Likewise.\n\t* decl.c (start_decl): Likewise.\n\t(start_function): Likewise.\n\t(finish_destructor_body): Likewise.\n\t(maybe_build_cleanup_1): Likewise.\n\t* decl2.c (reparse_decl_as_expr): Likewise.\n\t* init.c (perform_member_init): Likewise.\n\t(expand_cleanup_for_base): Likewise.\n\t(build_builtin_delete_call): Likewise.\n\t(build_new_1): Likewise.\n\t(build_delete): Likewise.\n\t* method.c (do_build_assign_ref): Likewise.\n\t* parse.y (already_scoped_stmt): Likewise.\n\t(nontrivial_exprlist): Likewise.\n\t(net_initializer): Likewise.\n\t(initlist): Likewise.\n\t* parse.c: Regenerated.\n\t* rtti.c (build_x_typeid): Likewise.\n\t(build_dynamic_cast_1): Likewise.\n\t* typeck.c (build_x_compound_expr): Likewise.\n\t(build_static_cast): Likewise.\n\t(build_modify_expr): Likewise.\n\n\t* cp-tree.h (DECL_VINDEX): Add documentation.\n\t* class.c (build_vtable_entry): Likewise.\n\t(start_vtable): Add comment.\n\t(add_virtual_function): Replace pending_hard_virtuals with\n\toverridden_virtuals and pending_virtuals with new_virtuals.\n\tReplace redundant assignments with assertions.\n\t(check_for_override): Add comment.\n\t(check_bases_and_members): Replace pending_hard_virtuals with\n\toverridden_virtuals and pending_virtuals with new_virtuals.\n\t(create_vtbl_ptr): Likewise.\n\t(layout_class_type): Likewise.\n\t(finish_struct_1): Likewise.  Add comments.\n\nFrom-SVN: r31473", "tree": {"sha": "2fdd9d6f9a01df98507c3bc1b73c1ec015341f25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fdd9d6f9a01df98507c3bc1b73c1ec015341f25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/051e6fd745109c9de4d707ccd949722904a74987", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051e6fd745109c9de4d707ccd949722904a74987", "html_url": "https://github.com/Rust-GCC/gccrs/commit/051e6fd745109c9de4d707ccd949722904a74987", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051e6fd745109c9de4d707ccd949722904a74987/comments", "author": null, "committer": null, "parents": [{"sha": "7af85558553980230b15cc7df9288ed0718af73c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7af85558553980230b15cc7df9288ed0718af73c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7af85558553980230b15cc7df9288ed0718af73c"}], "stats": {"total": 309, "additions": 188, "deletions": 121}, "files": [{"sha": "04ee628f964c8fb49b4b963ce480b1e7ba82c315", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=051e6fd745109c9de4d707ccd949722904a74987", "patch": "@@ -1,3 +1,52 @@\n+2000-01-17  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (scratchalloc): Remove.\n+\t(build_scratch_list): Likewise.\n+\t* call.c (convert_class_to_reference): Replace build_scratch_list\n+\tand build_expr_list with build_tree_list.\n+\t(add_candidate): Replace scratchalloc with expralloc.  Note memory\n+\tleak.\n+\t(build_user_type_conversion_1):  Replace build_scratch_list\n+\tand build_expr_list with build_tree_list.\n+\t(build_new_op): Likewise.\n+\t(build_op_delete_call): Likewise.\n+\t(convert_like): Likewise.\n+\t* cvt.c (ocp_convert): Likewise.\n+\t* decl.c (start_decl): Likewise.\n+\t(start_function): Likewise.\n+\t(finish_destructor_body): Likewise.\n+\t(maybe_build_cleanup_1): Likewise.\n+\t* decl2.c (reparse_decl_as_expr): Likewise.\n+\t* init.c (perform_member_init): Likewise.\n+\t(expand_cleanup_for_base): Likewise.\n+\t(build_builtin_delete_call): Likewise.\n+\t(build_new_1): Likewise.\n+\t(build_delete): Likewise.\n+\t* method.c (do_build_assign_ref): Likewise.\n+\t* parse.y (already_scoped_stmt): Likewise.\n+\t(nontrivial_exprlist): Likewise.\n+\t(net_initializer): Likewise.\n+\t(initlist): Likewise.\n+\t* parse.c: Regenerated.\n+\t* rtti.c (build_x_typeid): Likewise.\n+\t(build_dynamic_cast_1): Likewise.\n+\t* typeck.c (build_x_compound_expr): Likewise.\n+\t(build_static_cast): Likewise.\n+\t(build_modify_expr): Likewise.\n+\t\n+\t* cp-tree.h (DECL_VINDEX): Add documentation.\n+\t* class.c (build_vtable_entry): Likewise.\n+\t(start_vtable): Add comment.\n+\t(add_virtual_function): Replace pending_hard_virtuals with\n+\toverridden_virtuals and pending_virtuals with new_virtuals.\n+\tReplace redundant assignments with assertions.\n+\t(check_for_override): Add comment.\n+\t(check_bases_and_members): Replace pending_hard_virtuals with\n+\toverridden_virtuals and pending_virtuals with new_virtuals.\n+\t(create_vtbl_ptr): Likewise.\n+\t(layout_class_type): Likewise.\n+\t(finish_struct_1): Likewise.  Add comments.\n+\t\n 2000-01-16  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (finish_struct_1): Replace redundant code with"}, {"sha": "7114d022b961e707643a3b7bc9b3f48b51d80c76", "filename": "gcc/cp/call.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=051e6fd745109c9de4d707ccd949722904a74987", "patch": "@@ -869,7 +869,7 @@ convert_class_to_reference (t, s, expr)\n      cast to the appropriate type.  */\n   arglist = build_int_2 (0, 0);\n   TREE_TYPE (arglist) = build_pointer_type (s);\n-  arglist = build_scratch_list (NULL_TREE, arglist);\n+  arglist = build_tree_list (NULL_TREE, arglist);\n   \n   for (conversions = lookup_conversions (s);\n        conversions;\n@@ -1214,8 +1214,10 @@ add_candidate (candidates, fn, convs, viable)\n      tree fn, convs;\n      int viable;\n {\n+  /* FIXME: This is a memory leak.  Presumably, we should use\n+     ggc_alloc instead.  */\n   struct z_candidate *cand\n-    = (struct z_candidate *) scratchalloc (sizeof (struct z_candidate));\n+    = (struct z_candidate *) expralloc (sizeof (struct z_candidate));\n \n   cand->fn = fn;\n   cand->convs = convs;\n@@ -2269,7 +2271,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n     {\n       tree t = build_int_2 (0, 0);\n       TREE_TYPE (t) = build_pointer_type (totype);\n-      args = build_scratch_list (NULL_TREE, expr);\n+      args = build_tree_list (NULL_TREE, expr);\n       if (TYPE_USES_VIRTUAL_BASECLASSES (totype))\n \targs = tree_cons (NULL_TREE, integer_one_node, args);\n       args = tree_cons (NULL_TREE, t, args);\n@@ -2302,7 +2304,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n     }\n \n   if (convs)\n-    args = build_scratch_list (NULL_TREE, build_this (expr));\n+    args = build_tree_list (NULL_TREE, build_this (expr));\n \n   for (; convs; convs = TREE_CHAIN (convs))\n     {\n@@ -3164,11 +3166,11 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \n   if (arg2 && arg3)\n     arglist = tree_cons (NULL_TREE, arg1, tree_cons\n-\t\t      (NULL_TREE, arg2, build_scratch_list (NULL_TREE, arg3)));\n+\t\t      (NULL_TREE, arg2, build_tree_list (NULL_TREE, arg3)));\n   else if (arg2)\n-    arglist = tree_cons (NULL_TREE, arg1, build_scratch_list (NULL_TREE, arg2));\n+    arglist = tree_cons (NULL_TREE, arg1, build_tree_list (NULL_TREE, arg2));\n   else\n-    arglist = build_scratch_list (NULL_TREE, arg1);\n+    arglist = build_tree_list (NULL_TREE, arg1);\n \n   fns = lookup_function_nonclass (fnname, arglist);\n \n@@ -3567,7 +3569,7 @@ build_op_delete_call (code, addr, size, flags, placement)\n \tenforce_access (TREE_PURPOSE (fns), fn);\n       return build_function_call\n \t(fn, tree_cons (NULL_TREE, addr,\n-\t\t\tbuild_expr_list (NULL_TREE, size)));\n+\t\t\tbuild_tree_list (NULL_TREE, size)));\n     }\n \n   /* finish_function passes LOOKUP_SPECULATIVELY if we're in a\n@@ -3650,7 +3652,7 @@ convert_like (convs, expr)\n \t    tree t = build_int_2 (0, 0);\n \t    TREE_TYPE (t) = build_pointer_type (DECL_CONTEXT (fn));\n \n-\t    args = build_scratch_list (NULL_TREE, expr);\n+\t    args = build_tree_list (NULL_TREE, expr);\n \t    if (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n \t      args = tree_cons (NULL_TREE, integer_one_node, args);\n \t    args = tree_cons (NULL_TREE, t, args);\n@@ -3911,7 +3913,7 @@ build_over_call (cand, args, flags)\n     enforce_access (cand->basetype_path, fn);\n \n   if (args && TREE_CODE (args) != TREE_LIST)\n-    args = build_scratch_list (NULL_TREE, args);\n+    args = build_tree_list (NULL_TREE, args);\n   arg = args;\n \n   /* The implicit parameters to a constructor are not considered by overload"}, {"sha": "6d221eb5fca7c5da18236d4fd6438695821407dd", "filename": "gcc/cp/class.c", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=051e6fd745109c9de4d707ccd949722904a74987", "patch": "@@ -573,7 +573,7 @@ build_vtable_entry (delta, pfn)\n       extern int flag_huge_objects;\n       tree elems = tree_cons (NULL_TREE, delta,\n \t\t\t      tree_cons (NULL_TREE, integer_zero_node,\n-\t\t\t\t\t build_expr_list (NULL_TREE, pfn)));\n+\t\t\t\t\t build_tree_list (NULL_TREE, pfn)));\n       tree entry = build (CONSTRUCTOR, vtable_entry_type, NULL_TREE, elems);\n \n       /* DELTA used to be constructed by `size_int' and/or size_binop,\n@@ -1139,6 +1139,9 @@ start_vtable (t, has_virtual_p)\n {\n   if (*has_virtual_p == 0 && ! CLASSTYPE_COM_INTERFACE (t))\n     {\n+      /* If we are using thunks, use two slots at the front, one\n+\t for the offset pointer, one for the tdesc pointer.\n+         For ARM-style vtables, use the same slot for both.  */\n       if (flag_vtable_thunks)\n \t*has_virtual_p = 2;\n       else\n@@ -1151,40 +1154,35 @@ start_vtable (t, has_virtual_p)\n    allocate a new slot in our table.  If it is error_mark_node, we\n    know that no other function from another vtable is overridden by X.\n    HAS_VIRTUAL keeps track of how many virtuals there are in our main\n-   vtable for the type, and we build upon the PENDING_VIRTUALS list\n+   vtable for the type, and we build upon the NEW_VIRTUALS list\n    and return it.  */\n \n static void\n-add_virtual_function (pv, phv, has_virtual, fndecl, t)\n-     tree *pv, *phv;\n+add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n+\t\t      has_virtual, fndecl, t)\n+     tree *new_virtuals_p;\n+     tree *overridden_virtuals_p;\n      int *has_virtual;\n      tree fndecl;\n      tree t; /* Structure type.  */\n {\n-  tree pending_virtuals = *pv;\n-  tree pending_hard_virtuals = *phv;\n-\n-#ifndef DUMB_USER\n-  if (current_class_type == 0)\n-    cp_warning (\"internal problem, current_class_type is zero when adding `%D', please report\",\n-\t\tfndecl);\n-  if (current_class_type && t != current_class_type)\n-    cp_warning (\"internal problem, current_class_type differs when adding `%D', please report\",\n-\t\tfndecl);\n-#endif\n-\n-  /* If the virtual function is a redefinition of a prior one,\n-     figure out in which base class the new definition goes,\n-     and if necessary, make a fresh virtual function table\n-     to hold that entry.  */\n-  if (DECL_VINDEX (fndecl) == error_mark_node)\n+  my_friendly_assert (DECL_CONTEXT (fndecl) == t, 20000116);\n+\n+  /* If this function doesn't override anything from a base class, we\n+     can just assign it a new DECL_VINDEX now.  Otherwise, if it does\n+     override something, we keep it around and assign its DECL_VINDEX\n+     later, in modify_all_vtables.  */\n+  if (TREE_CODE (DECL_VINDEX (fndecl)) == INTEGER_CST)\n+    /* We've already dealt with this function.  */\n+    ;\n+  else if (DECL_VINDEX (fndecl) == error_mark_node)\n     {\n+      /* FNDECL is a new virtual function; it doesn't override any\n+\t virtual function in a base class.  */\n+\n       /* We remember that this was the base sub-object for rtti.  */\n       CLASSTYPE_RTTI (t) = t;\n \n-      /* If we are using thunks, use two slots at the front, one\n-\t for the offset pointer, one for the tdesc pointer.\n-         For ARM-style vtables, use the same slot for both.  */\n       start_vtable (t, has_virtual);\n \n       /* Build a new INT_CST for this DECL_VINDEX.  */\n@@ -1205,25 +1203,17 @@ add_virtual_function (pv, phv, has_virtual, fndecl, t)\n \n \t/* Now assign virtual dispatch information.  */\n \tDECL_VINDEX (fndecl) = idx;\n-\tDECL_CONTEXT (fndecl) = t;\n       }\n-      /* Save the state we've computed on the PENDING_VIRTUALS list.  */\n-      pending_virtuals = tree_cons (integer_zero_node,\n-\t\t\t\t    fndecl,\n-\t\t\t\t    pending_virtuals);\n+      /* Save the state we've computed on the NEW_VIRTUALS list.  */\n+      *new_virtuals_p = tree_cons (integer_zero_node,\n+\t\t\t\t   fndecl,\n+\t\t\t\t   *new_virtuals_p);\n     }\n-  /* Might already be INTEGER_CST if declared twice in class.  We will\n-     give error later or we've already given it.  */\n   else if (TREE_CODE (DECL_VINDEX (fndecl)) != INTEGER_CST)\n-    {\n-      /* Need an entry in some other virtual function table.\n-         Deal with this after we have laid out our virtual base classes.  */\n-      pending_hard_virtuals = tree_cons (NULL_TREE, \n-\t\t\t\t\t fndecl, \n-\t\t\t\t\t pending_hard_virtuals);\n-    }\n-  *pv = pending_virtuals;\n-  *phv = pending_hard_virtuals;\n+    /* FNDECL overrides a function from a base class.  */\n+    *overridden_virtuals_p = tree_cons (NULL_TREE, \n+\t\t\t\t\tfndecl, \n+\t\t\t\t\t*overridden_virtuals_p);\n }\n \f\n extern struct obstack *current_obstack;\n@@ -3126,8 +3116,12 @@ check_for_override (decl, ctype)\n \t\t}\n \t      virtualp = 1;\n \n-\t      DECL_VINDEX (decl)\n-\t\t= tree_cons (NULL_TREE, tmp, DECL_VINDEX (decl));\n+\t      /* Set DECL_VINDEX to a value that is neither an\n+\t\t INTEGER_CST nor the error_mark_node so that\n+\t\t add_virtual_function will realize this is an\n+\t\t overridden function.  */\n+\t      DECL_VINDEX (decl) \n+\t\t= tree_cons (tmp, NULL_TREE, DECL_VINDEX (decl));\n \t      \n \t      /* We now know that DECL overrides something,\n \t\t which is all that is important.  But, we must\n@@ -4202,20 +4196,20 @@ check_bases_and_members (t, empty_p)\n \n static void\n create_vtable_ptr (t, empty_p, has_virtual_p, \n-\t\t   pending_virtuals_p, pending_hard_virtuals_p)\n+\t\t   new_virtuals_p, overridden_virtuals_p)\n      tree t;\n      int *empty_p;\n      int *has_virtual_p;\n-     tree *pending_virtuals_p;\n-     tree *pending_hard_virtuals_p;\n+     tree *new_virtuals_p;\n+     tree *overridden_virtuals_p;\n {\n   tree fn;\n \n   /* Loop over the virtual functions, adding them to our various\n      vtables.  */\n   for (fn = TYPE_METHODS (t); fn; fn = TREE_CHAIN (fn))\n     if (DECL_VINDEX (fn))\n-      add_virtual_function (pending_virtuals_p, pending_hard_virtuals_p,\n+      add_virtual_function (new_virtuals_p, overridden_virtuals_p,\n \t\t\t    has_virtual_p, fn, t);\n \n   /* Even if there weren't any new virtual functions, we might need a\n@@ -4609,12 +4603,12 @@ layout_basetypes (rec)\n \n static void\n layout_class_type (t, empty_p, has_virtual_p, \n-\t\t   pending_virtuals_p, pending_hard_virtuals_p)\n+\t\t   new_virtuals_p, overridden_virtuals_p)\n      tree t;\n      int *empty_p;\n      int *has_virtual_p;\n-     tree *pending_virtuals_p;\n-     tree *pending_hard_virtuals_p;\n+     tree *new_virtuals_p;\n+     tree *overridden_virtuals_p;\n {\n   /* If possible, we reuse the virtual function table pointer from one\n      of our base classes.  */\n@@ -4629,7 +4623,7 @@ layout_class_type (t, empty_p, has_virtual_p,\n \n   /* Create a pointer to our virtual function table.  */\n   create_vtable_ptr (t, empty_p, has_virtual_p,\n-\t\t     pending_virtuals_p, pending_hard_virtuals_p);\n+\t\t     new_virtuals_p, overridden_virtuals_p);\n \n   /* CLASSTYPE_INLINE_FRIENDS is really TYPE_NONCOPIED_PARTS.  Thus,\n      we have to save this before we start modifying\n@@ -4725,8 +4719,15 @@ finish_struct_1 (t)\n {\n   tree x;\n   int has_virtual;\n-  tree pending_virtuals = NULL_TREE;\n-  tree pending_hard_virtuals = NULL_TREE;\n+  /* The NEW_VIRTUALS is a TREE_LIST.  The TREE_VALUE of each node is\n+     a FUNCTION_DECL.  Each of these functions is a virtual function\n+     declared in T that does not override any virtual function from a\n+     base class.  */\n+  tree new_virtuals = NULL_TREE;\n+  /* The OVERRIDDEN_VIRTUALS list is like the NEW_VIRTUALS list,\n+     except that each declaration here overrides the declaration from\n+     a base class.  */\n+  tree overridden_virtuals = NULL_TREE;\n   int n_fields = 0;\n   tree vfield;\n   int empty = 1;\n@@ -4745,7 +4746,6 @@ finish_struct_1 (t)\n \n   /* If this type was previously laid out as a forward reference,\n      make sure we lay it out again.  */\n-\n   TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n   CLASSTYPE_VFIELD_PARENT (t) = -1;\n@@ -4758,7 +4758,7 @@ finish_struct_1 (t)\n \n   /* Layout the class itself.  */\n   layout_class_type (t, &empty, &has_virtual,\n-\t\t     &pending_virtuals, &pending_hard_virtuals);\n+\t\t     &new_virtuals, &overridden_virtuals);\n \n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n     {\n@@ -4818,13 +4818,13 @@ finish_struct_1 (t)\n       TYPE_VFIELD (t) = vfield;\n     }\n \n-  if (flag_rtti && TYPE_CONTAINS_VPTR_P (t) && !pending_hard_virtuals)\n+  if (flag_rtti && TYPE_CONTAINS_VPTR_P (t) && !overridden_virtuals)\n     modify_all_vtables (t, NULL_TREE);\n \n-  for (pending_hard_virtuals = nreverse (pending_hard_virtuals);\n-       pending_hard_virtuals;\n-       pending_hard_virtuals = TREE_CHAIN (pending_hard_virtuals))\n-    modify_all_vtables (t, TREE_VALUE (pending_hard_virtuals));\n+  for (overridden_virtuals = nreverse (overridden_virtuals);\n+       overridden_virtuals;\n+       overridden_virtuals = TREE_CHAIN (overridden_virtuals))\n+    modify_all_vtables (t, TREE_VALUE (overridden_virtuals));\n   \n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n     {\n@@ -4850,23 +4850,23 @@ finish_struct_1 (t)\n     }\n \n   /* If necessary, create the vtable for this class.  */\n-  if (pending_virtuals\n+  if (new_virtuals\n       || (TYPE_CONTAINS_VPTR_P (t) && vptrs_present_everywhere_p ()))\n     {\n-      pending_virtuals = nreverse (pending_virtuals);\n+      new_virtuals = nreverse (new_virtuals);\n       /* We must enter these virtuals into the table.  */\n       if (!CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n \t{\n \t  if (! CLASSTYPE_COM_INTERFACE (t))\n \t    {\n \t      /* The second slot is for the tdesc pointer when thunks are used.  */\n \t      if (flag_vtable_thunks)\n-\t\tpending_virtuals = tree_cons (NULL_TREE, NULL_TREE, pending_virtuals);\n+\t\tnew_virtuals = tree_cons (NULL_TREE, NULL_TREE, new_virtuals);\n \n \t      /* The first slot is for the rtti offset.  */\n-\t      pending_virtuals = tree_cons (NULL_TREE, NULL_TREE, pending_virtuals);\n+\t      new_virtuals = tree_cons (NULL_TREE, NULL_TREE, new_virtuals);\n \n-\t      set_rtti_entry (pending_virtuals,\n+\t      set_rtti_entry (new_virtuals,\n \t\t\t      convert (ssizetype, integer_zero_node), t);\n \t    }\n \t  build_vtable (NULL_TREE, t);\n@@ -4917,7 +4917,7 @@ finish_struct_1 (t)\n       /* Entries for virtual functions defined in the primary base are\n \t followed by entries for new functions unique to this class.  */\n       TYPE_BINFO_VIRTUALS (t) \n-\t= chainon (TYPE_BINFO_VIRTUALS (t), pending_virtuals);\n+\t= chainon (TYPE_BINFO_VIRTUALS (t), new_virtuals);\n     }\n \n   /* Now lay out the virtual function table.  */"}, {"sha": "366181da256ed47945d7c683060123541e60a62a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=051e6fd745109c9de4d707ccd949722904a74987", "patch": "@@ -126,7 +126,18 @@ Boston, MA 02111-1307, USA.  */\n      entry does not have a TREE_VALUE; it is just an offset.\n \n    DECL_ARGUMENTS\n-     For a VAR_DECL this is DECL_ANON_UNION_ELEMS.  */\n+     For a VAR_DECL this is DECL_ANON_UNION_ELEMS.  \n+\n+   DECL_VINDEX\n+     This field is NULL for a non-virtual function.  For a virtual\n+     function, it is eventually set to an INTEGER_CST indicating the\n+     index in the vtable at which this function can be found.  When\n+     a virtual function is declared, but before it is known what\n+     function is overriden, this field is the error_mark_node.\n+\n+     Temporarily, it may be set to a TREE_LIST whose TREE_VALUE is \n+     the virtual function this one overrides, and whose TREE_CHAIN is\n+     the old DECL_VINDEX.  */\n \n /* Language-specific tree checkers. */\n \n@@ -214,6 +225,14 @@ extern int flag_rtti;\n    alternative; otherwise, we choose the former.  */\n #define vptrs_present_everywhere_p() (flag_new_abi)\n \n+/* Nonzero if the vtable for a derived class should contain the\n+   virtual functions from the primary base and all virtual functions\n+   present in the class itself.  Zero if, instead, it should contain\n+   only those virtual functions from the primary base together with\n+   the functions declared in the derived class (but not in any base\n+   class).  */\n+#define all_overridden_vfuns_in_vtables_p() (flag_new_abi)\n+\n \f\n /* Language-dependent contents of an identifier.  */\n \n@@ -4181,9 +4200,6 @@ extern void remap_save_expr                     PROTO((tree *, splay_tree, tree,\n #define cp_build_qualified_type(TYPE, QUALS) \\\n   cp_build_qualified_type_real ((TYPE), (QUALS), /*complain=*/1)\n \n-#define scratchalloc expralloc\n-#define build_scratch_list build_expr_list\n-\n /* in typeck.c */\n extern int string_conv_p\t\t\tPROTO((tree, tree, int));\n extern tree condition_conversion\t\tPROTO((tree));"}, {"sha": "bcc467a0b7d2527a556b3db22e9610ba73326b9a", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=051e6fd745109c9de4d707ccd949722904a74987", "patch": "@@ -807,7 +807,7 @@ ocp_convert (type, expr, convtype, flags)\n \tctor = build_user_type_conversion (type, ctor, flags);\n       if (ctor)\n \tctor = build_method_call (NULL_TREE, ctor_identifier,\n-\t\t\t\t  build_expr_list (NULL_TREE, ctor),\n+\t\t\t\t  build_tree_list (NULL_TREE, ctor),\n \t\t\t\t  TYPE_BINFO (type), flags);\n       if (ctor)\n \treturn build_cplus_new (type, ctor);"}, {"sha": "bd8ba639cdcf358307ed05e7e9e936a00c78dd45", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=051e6fd745109c9de4d707ccd949722904a74987", "patch": "@@ -6668,7 +6668,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n     }\n \n   if (attributes || prefix_attributes)\n-    attrlist = build_scratch_list (attributes, prefix_attributes);\n+    attrlist = build_tree_list (attributes, prefix_attributes);\n   else\n     attrlist = NULL_TREE;\n \n@@ -12968,7 +12968,7 @@ start_function (declspecs, declarator, attrs, flags)\n       if (CLASS_TYPE_P (restype) && !CLASSTYPE_GOT_SEMICOLON (restype))\n \t{\n \t  cp_error (\"semicolon missing after declaration of `%#T'\", restype);\n-\t  shadow_tag (build_expr_list (NULL_TREE, restype));\n+\t  shadow_tag (build_tree_list (NULL_TREE, restype));\n \t  CLASSTYPE_GOT_SEMICOLON (restype) = 1;\n \t  if (TREE_CODE (fntype) == FUNCTION_TYPE)\n \t    fntype = build_function_type (integer_type_node,\n@@ -13600,7 +13600,7 @@ finish_destructor_body ()\n \t\t  finish_expr_stmt\n \t\t    (build_scoped_method_call\n \t\t     (current_class_ref, vb, dtor_identifier,\n-\t\t      build_expr_list (NULL_TREE, integer_zero_node)));\n+\t\t      build_tree_list (NULL_TREE, integer_zero_node)));\n \t\t}\n \t      vbases = TREE_CHAIN (vbases);\n \t    }\n@@ -14276,7 +14276,7 @@ maybe_build_cleanup_1 (decl, auto_delete)\n       if (TYPE_USES_VIRTUAL_BASECLASSES (type)\n \t  && ! TYPE_HAS_DESTRUCTOR (type))\n \trval = build_compound_expr (tree_cons (NULL_TREE, rval,\n-\t\t\t\t\t       build_expr_list (NULL_TREE, build_vbase_delete (type, decl))));\n+\t\t\t\t\t       build_tree_list (NULL_TREE, build_vbase_delete (type, decl))));\n \n       return rval;\n     }"}, {"sha": "aa8b5a76652b437493928339ee93021b105cef32", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=051e6fd745109c9de4d707ccd949722904a74987", "patch": "@@ -4026,7 +4026,7 @@ reparse_decl_as_expr (type, decl)\n {\n   decl = build_expr_from_tree (decl);\n   if (type)\n-    return build_functional_cast (type, build_expr_list (NULL_TREE, decl));\n+    return build_functional_cast (type, build_tree_list (NULL_TREE, decl));\n   else\n     return decl;\n }"}, {"sha": "7d7c084aca9e5ada5cd93de9f023442b5074c441", "filename": "gcc/cp/init.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=051e6fd745109c9de4d707ccd949722904a74987", "patch": "@@ -162,7 +162,7 @@ perform_member_init (member, name, init, explicit)\n       /* Since `init' is already a TREE_LIST on the current_member_init_list,\n \t only build it into one if we aren't already a list.  */\n       if (init != NULL_TREE && TREE_CODE (init) != TREE_LIST)\n-\tinit = build_expr_list (NULL_TREE, init);\n+\tinit = build_tree_list (NULL_TREE, init);\n \n       if (explicit\n \t  && TREE_CODE (type) == ARRAY_TYPE\n@@ -695,7 +695,7 @@ expand_cleanup_for_base (binfo, flag)\n   /* Call the destructor.  */\n   expr = (build_scoped_method_call\n \t  (current_class_ref, binfo, dtor_identifier,\n-\t   build_expr_list (NULL_TREE, integer_zero_node)));\n+\t   build_tree_list (NULL_TREE, integer_zero_node)));\n   if (flag)\n     expr = fold (build (COND_EXPR, void_type_node,\n \t\t\ttruthvalue_conversion (flag),\n@@ -1186,7 +1186,7 @@ expand_default_init (binfo, true_exp, exp, init, flags)\n \tinit = TREE_VALUE (parms);\n     }\n   else\n-    parms = build_expr_list (NULL_TREE, init);\n+    parms = build_tree_list (NULL_TREE, init);\n \n   if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n     {\n@@ -1361,7 +1361,7 @@ get_type_value (name)\n   else\n     return NULL_TREE;\n }\n-  \n+\n \f\n /* This code could just as well go in `class.c', but is placed here for\n    modularity.  */\n@@ -1619,7 +1619,7 @@ build_offset_ref (type, name)\n \t    /* The code in instantiate_type which will process this\n \t       expects to encounter OVERLOADs, not raw functions.  */\n \t    t = ovl_cons (t, NULL_TREE);\n-\t  \n+\n \t  return build (OFFSET_REF, \n \t\t\tunknown_type_node,\n \t\t\tdecl,\n@@ -1772,7 +1772,7 @@ resolve_offset_ref (exp)\n \tbasetype = DECL_CONTEXT (member);\n \n       base = current_class_ptr;\n-      \n+\n       if (get_base_distance (basetype, TREE_TYPE (TREE_TYPE (base)), 0, &basetype_path) < 0)\n \t{\n \t  error_not_base_type (basetype, TREE_TYPE (TREE_TYPE (base)));\n@@ -1812,7 +1812,7 @@ resolve_offset_ref (exp)\n       basetype = TYPE_OFFSET_BASETYPE (TREE_TYPE (TREE_TYPE (member)));\n       addr = convert_pointer_to (basetype, addr);\n       member = cp_convert (ptrdiff_type_node, member);\n-      \n+\n       /* Pointer to data members are offset by one, so that a null\n \t pointer with a real value of 0 is distinguishable from an\n \t offset of the first member of a structure.  */\n@@ -1861,7 +1861,7 @@ build_builtin_delete_call (addr)\n {\n   mark_used (global_delete_fndecl);\n   return build_call (global_delete_fndecl, \n-\t\t     void_type_node, build_expr_list (NULL_TREE, addr));\n+\t\t     void_type_node, build_tree_list (NULL_TREE, addr));\n }\n \f\n /* Generate a C++ \"new\" expression. DECL is either a TREE_LIST\n@@ -2258,7 +2258,7 @@ build_new_1 (exp)\n       rval = cp_convert (build_pointer_type (true_type), rval);\n       rval = build_compound_expr\n \t(tree_cons (NULL_TREE, exp1,\n-\t\t\t build_expr_list (NULL_TREE, rval)));\n+\t\t    build_tree_list (NULL_TREE, rval)));\n     }\n \n   if (rval == error_mark_node)\n@@ -3059,7 +3059,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \tpassed_auto_delete = auto_delete;\n \n       expr = build_method_call\n-\t(ref, dtor_identifier, build_expr_list (NULL_TREE, passed_auto_delete),\n+\t(ref, dtor_identifier, build_tree_list (NULL_TREE, passed_auto_delete),\n \t NULL_TREE, flags);\n \n       if (do_delete)\n@@ -3108,7 +3108,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \tcond = NULL_TREE;\n \n       if (cond)\n-\texprstmt = build_expr_list (NULL_TREE, cond);\n+\texprstmt = build_tree_list (NULL_TREE, cond);\n \n       if (base_binfo\n \t  && ! TREE_VIA_VIRTUAL (base_binfo)\n@@ -3123,7 +3123,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \n \t  expr = build_scoped_method_call\n \t    (ref, base_binfo, dtor_identifier,\n-\t     build_expr_list (NULL_TREE, this_auto_delete));\n+\t     build_tree_list (NULL_TREE, this_auto_delete));\n \t  exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n \t}\n \n@@ -3137,7 +3137,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \n \t  expr = build_scoped_method_call\n \t    (ref, base_binfo, dtor_identifier,\n-\t     build_expr_list (NULL_TREE, integer_zero_node));\n+\t     build_tree_list (NULL_TREE, integer_zero_node));\n \n \t  exprstmt = tree_cons (NULL_TREE, expr, exprstmt);\n \t}"}, {"sha": "4d9988541afb9d310eda38129c9bad9b340f2f4a", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=051e6fd745109c9de4d707ccd949722904a74987", "patch": "@@ -2277,7 +2277,7 @@ do_build_assign_ref (fndecl)\n \t     CONV_IMPLICIT|CONV_CONST, LOOKUP_COMPLAIN, NULL_TREE);\n \t  p = convert_from_reference (p);\n \t  p = build_member_call (basetype, ansi_opname [MODIFY_EXPR],\n-\t\t\t\t build_expr_list (NULL_TREE, p));\n+\t\t\t\t build_tree_list (NULL_TREE, p));\n \t  finish_expr_stmt (p);\n \t}\n       for (; fields; fields = TREE_CHAIN (fields))"}, {"sha": "364d2f462a4c878a5d9dbb699737a4c40d458a12", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=051e6fd745109c9de4d707ccd949722904a74987", "patch": "@@ -5252,24 +5252,24 @@ case 208:\n case 210:\n #line 1061 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyval.ttype, \n-\t\t                  build_expr_list (NULL_TREE, yyvsp[0].ttype)); ;\n+\t\t                  build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;\n     break;}\n case 211:\n #line 1064 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyval.ttype, \n-\t\t                  build_expr_list (NULL_TREE, error_mark_node)); ;\n+\t\t                  build_tree_list (NULL_TREE, error_mark_node)); ;\n     break;}\n case 212:\n #line 1067 \"parse.y\"\n-{ chainon (yyval.ttype, build_expr_list (NULL_TREE, yyvsp[0].ttype)); ;\n+{ chainon (yyval.ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;\n     break;}\n case 213:\n #line 1069 \"parse.y\"\n-{ chainon (yyval.ttype, build_expr_list (NULL_TREE, error_mark_node)); ;\n+{ chainon (yyval.ttype, build_tree_list (NULL_TREE, error_mark_node)); ;\n     break;}\n case 214:\n #line 1074 \"parse.y\"\n-{ yyval.ttype = build_expr_list (NULL_TREE, yyval.ttype); ;\n+{ yyval.ttype = build_tree_list (NULL_TREE, yyval.ttype); ;\n     break;}\n case 216:\n #line 1080 \"parse.y\"\n@@ -5421,7 +5421,7 @@ case 246:\n \t\t    pedwarn (\"ANSI C++ forbids initialization of new expression with `='\");\n \t\t  if (TREE_CODE (yyvsp[0].ttype) != TREE_LIST\n \t\t      && TREE_CODE (yyvsp[0].ttype) != CONSTRUCTOR)\n-\t\t    yyval.ttype = build_expr_list (NULL_TREE, yyvsp[0].ttype);\n+\t\t    yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ttype);\n \t\t  else\n \t\t    yyval.ttype = yyvsp[0].ttype;\n \t\t;\n@@ -6297,11 +6297,11 @@ case 454:\n     break;}\n case 455:\n #line 2007 \"parse.y\"\n-{ yyval.ttype = build_expr_list (yyvsp[-2].ttype, yyvsp[0].ttype); ;\n+{ yyval.ttype = build_tree_list (yyvsp[-2].ttype, yyvsp[0].ttype); ;\n     break;}\n case 456:\n #line 2009 \"parse.y\"\n-{ yyval.ttype = build_expr_list (yyval.ttype, yyvsp[0].ttype); ;\n+{ yyval.ttype = build_tree_list (yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 457:\n #line 2011 \"parse.y\""}, {"sha": "702a9601f13a1aadfaeb7130c3aeb305a3b4b917", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=051e6fd745109c9de4d707ccd949722904a74987", "patch": "@@ -1059,19 +1059,19 @@ already_scoped_stmt:\n nontrivial_exprlist:\n \t  expr_no_commas ',' expr_no_commas\n \t\t{ $$ = tree_cons (NULL_TREE, $$, \n-\t\t                  build_expr_list (NULL_TREE, $3)); }\n+\t\t                  build_tree_list (NULL_TREE, $3)); }\n \t| expr_no_commas ',' error\n \t\t{ $$ = tree_cons (NULL_TREE, $$, \n-\t\t                  build_expr_list (NULL_TREE, error_mark_node)); }\n+\t\t                  build_tree_list (NULL_TREE, error_mark_node)); }\n \t| nontrivial_exprlist ',' expr_no_commas\n-\t\t{ chainon ($$, build_expr_list (NULL_TREE, $3)); }\n+\t\t{ chainon ($$, build_tree_list (NULL_TREE, $3)); }\n \t| nontrivial_exprlist ',' error\n-\t\t{ chainon ($$, build_expr_list (NULL_TREE, error_mark_node)); }\n+\t\t{ chainon ($$, build_tree_list (NULL_TREE, error_mark_node)); }\n \t;\n \n nonnull_exprlist:\n \t  expr_no_commas\n-\t\t{ $$ = build_expr_list (NULL_TREE, $$); }\n+\t\t{ $$ = build_tree_list (NULL_TREE, $$); }\n \t| nontrivial_exprlist\n \t;\n \n@@ -1181,7 +1181,7 @@ new_initializer:\n \t\t    pedwarn (\"ANSI C++ forbids initialization of new expression with `='\");\n \t\t  if (TREE_CODE ($2) != TREE_LIST\n \t\t      && TREE_CODE ($2) != CONSTRUCTOR)\n-\t\t    $$ = build_expr_list (NULL_TREE, $2);\n+\t\t    $$ = build_tree_list (NULL_TREE, $2);\n \t\t  else\n \t\t    $$ = $2;\n \t\t}\n@@ -2004,9 +2004,9 @@ initlist:\n \t\t{ $$ = tree_cons (NULL_TREE, $3, $$); }\n \t/* These are for labeled elements.  */\n \t| '[' expr_no_commas ']' init\n-\t\t{ $$ = build_expr_list ($2, $4); }\n+\t\t{ $$ = build_tree_list ($2, $4); }\n \t| identifier ':' init\n-\t\t{ $$ = build_expr_list ($$, $3); }\n+\t\t{ $$ = build_tree_list ($$, $3); }\n \t| initlist ',' identifier ':' init\n \t\t{ $$ = tree_cons ($3, $5, $$); }\n \t;"}, {"sha": "a90da0de75ce6e9add867b8a448bb21d3c739075", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=051e6fd745109c9de4d707ccd949722904a74987", "patch": "@@ -295,7 +295,7 @@ build_x_typeid (exp)\n       tree bad = throw_bad_typeid ();\n \n       bad = build_compound_expr\n-\t(tree_cons (NULL_TREE, bad, build_expr_list\n+\t(tree_cons (NULL_TREE, bad, build_tree_list\n \t\t    (NULL_TREE, cp_convert (type, integer_zero_node))));\n       exp = build (COND_EXPR, type, cond, exp, bad);\n     }\n@@ -680,7 +680,7 @@ build_dynamic_cast_1 (type, expr)\n \t      expr1 = throw_bad_cast ();\n \t      expr1 = build_compound_expr\n \t\t(tree_cons (NULL_TREE, expr1,\n-\t\t\t    build_expr_list (NULL_TREE, cp_convert (type, integer_zero_node))));\n+\t\t\t    build_tree_list (NULL_TREE, cp_convert (type, integer_zero_node))));\n \t      TREE_TYPE (expr1) = type;\n \t      result = save_expr (result);\n \t      return build (COND_EXPR, type, result, result, expr1);"}, {"sha": "f23277960d4d956dc78638d81abf39e8229a32c0", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051e6fd745109c9de4d707ccd949722904a74987/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=051e6fd745109c9de4d707ccd949722904a74987", "patch": "@@ -5092,7 +5092,7 @@ build_x_compound_expr (list)\n \n   return build_compound_expr\n     (tree_cons (NULL_TREE, TREE_VALUE (list),\n-\t\t     build_expr_list (NULL_TREE,\n+\t\t     build_tree_list (NULL_TREE,\n \t\t\t\t      build_x_compound_expr (rest))));\n }\n \n@@ -5177,7 +5177,7 @@ build_static_cast (type, expr)\n   if (IS_AGGR_TYPE (type))\n     return build_cplus_new\n       (type, (build_method_call\n-\t      (NULL_TREE, ctor_identifier, build_expr_list (NULL_TREE, expr),\n+\t      (NULL_TREE, ctor_identifier, build_tree_list (NULL_TREE, expr),\n \t       TYPE_BINFO (type), LOOKUP_NORMAL)));\n \n   expr = decay_conversion (expr);\n@@ -5702,7 +5702,7 @@ build_modify_expr (lhs, modifycode, rhs)\n       else\n \t{\n \t  result = build_method_call (lhs, ctor_identifier,\n-\t\t\t\t      build_expr_list (NULL_TREE, rhs),\n+\t\t\t\t      build_tree_list (NULL_TREE, rhs),\n \t\t\t\t      TYPE_BINFO (lhstype), LOOKUP_NORMAL);\n \t  if (result == NULL_TREE)\n \t    return error_mark_node;\n@@ -5932,7 +5932,7 @@ build_modify_expr (lhs, modifycode, rhs)\n       if (TREE_SIDE_EFFECTS (lhs))\n \tcond = build_compound_expr (tree_cons\n \t\t\t\t    (NULL_TREE, lhs,\n-\t\t\t\t     build_expr_list (NULL_TREE, cond)));\n+\t\t\t\t     build_tree_list (NULL_TREE, cond)));\n \n       /* Cannot have two identical lhs on this one tree (result) as preexpand\n \t calls will rip them out and fill in RTL for them, but when the"}]}