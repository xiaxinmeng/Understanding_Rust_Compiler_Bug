{"sha": "183bfdafc6f1f98711c5400498a7268cc1441096", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgzYmZkYWZjNmYxZjk4NzExYzU0MDA0OThhNzI2OGNjMTQ0MTA5Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-29T08:45:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-29T08:45:44Z"}, "message": "[AArch64] Add FFR and FFRT registers\n\nThis patch adds the First Fault Register to the AArch64 port, as well\nas a fake register known as the FFR Token or FFRT.  The main ACLE\npatch explains what the FFRT does and how it works.\n\n2019-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64.md (FFR_REGNUM, FFRT_REGNUM): New constants.\n\t* config/aarch64/aarch64.h (FIRST_PSEUDO_REGISTER): Bump to\n\tFFRT_REGNUM + 1.\n\t(FFR_REGS, PR_AND_FFR_REGS): New register classes.\n\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Add entries for them.\n\t* config/aarch64/aarch64.c (pr_or_ffr_regnum_p): New function.\n\t(aarch64_hard_regno_nregs): Handle the new register classes.\n\t(aarch64_hard_regno_mode_ok): Likewise.\n\t(aarch64_regno_regclass): Likewise.\n\t(aarch64_class_max_nregs): Likewise.\n\t(aarch64_register_move_cost): Likewise.\n\t(aarch64_conditional_register_usage): Don't treat FFR and FFRT\n\tas general register_operands.\n\nFrom-SVN: r277561", "tree": {"sha": "122a5518fc5cda98c2c8482bd9d700f89ee8cd6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/122a5518fc5cda98c2c8482bd9d700f89ee8cd6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/183bfdafc6f1f98711c5400498a7268cc1441096", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/183bfdafc6f1f98711c5400498a7268cc1441096", "html_url": "https://github.com/Rust-GCC/gccrs/commit/183bfdafc6f1f98711c5400498a7268cc1441096", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/183bfdafc6f1f98711c5400498a7268cc1441096/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "50a2d3be7bf473c7590f77350fadf3471427ce09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50a2d3be7bf473c7590f77350fadf3471427ce09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50a2d3be7bf473c7590f77350fadf3471427ce09"}], "stats": {"total": 67, "additions": 63, "deletions": 4}, "files": [{"sha": "a80a8e1090c7cefaea685d38b6b26cdedbd9944c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/183bfdafc6f1f98711c5400498a7268cc1441096/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/183bfdafc6f1f98711c5400498a7268cc1441096/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=183bfdafc6f1f98711c5400498a7268cc1441096", "patch": "@@ -1,3 +1,19 @@\n+2019-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64.md (FFR_REGNUM, FFRT_REGNUM): New constants.\n+\t* config/aarch64/aarch64.h (FIRST_PSEUDO_REGISTER): Bump to\n+\tFFRT_REGNUM + 1.\n+\t(FFR_REGS, PR_AND_FFR_REGS): New register classes.\n+\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Add entries for them.\n+\t* config/aarch64/aarch64.c (pr_or_ffr_regnum_p): New function.\n+\t(aarch64_hard_regno_nregs): Handle the new register classes.\n+\t(aarch64_hard_regno_mode_ok): Likewise.\n+\t(aarch64_regno_regclass): Likewise.\n+\t(aarch64_class_max_nregs): Likewise.\n+\t(aarch64_register_move_cost): Likewise.\n+\t(aarch64_conditional_register_usage): Don't treat FFR and FFRT\n+\tas general register_operands.\n+\n 2019-10-29  Martin Liska  <mliska@suse.cz>\n \n \t* ggc-common.c: One can't subtract unsigned types"}, {"sha": "466910dabce7234aa09368e593bba55ae43a148e", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/183bfdafc6f1f98711c5400498a7268cc1441096/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/183bfdafc6f1f98711c5400498a7268cc1441096/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=183bfdafc6f1f98711c5400498a7268cc1441096", "patch": "@@ -1426,6 +1426,14 @@ aarch64_err_no_fpadvsimd (machine_mode mode)\n \t     \" vector types\", \"+nofp\");\n }\n \n+/* Return true if REGNO is P0-P15 or one of the special FFR-related\n+   registers.  */\n+inline bool\n+pr_or_ffr_regnum_p (unsigned int regno)\n+{\n+  return PR_REGNUM_P (regno) || regno == FFR_REGNUM || regno == FFRT_REGNUM;\n+}\n+\n /* Implement TARGET_IRA_CHANGE_PSEUDO_ALLOCNO_CLASS.\n    The register allocator chooses POINTER_AND_FP_REGS if FP_REGS and\n    GENERAL_REGS have the same cost - even if POINTER_AND_FP_REGS has a much\n@@ -1810,6 +1818,8 @@ aarch64_hard_regno_nregs (unsigned regno, machine_mode mode)\n     case PR_REGS:\n     case PR_LO_REGS:\n     case PR_HI_REGS:\n+    case FFR_REGS:\n+    case PR_AND_FFR_REGS:\n       return 1;\n     default:\n       return CEIL (lowest_size, UNITS_PER_WORD);\n@@ -1836,10 +1846,10 @@ aarch64_hard_regno_mode_ok (unsigned regno, machine_mode mode)\n     return false;\n \n   if (vec_flags & VEC_SVE_PRED)\n-    return PR_REGNUM_P (regno);\n+    return pr_or_ffr_regnum_p (regno);\n \n-  if (PR_REGNUM_P (regno))\n-    return 0;\n+  if (pr_or_ffr_regnum_p (regno))\n+    return false;\n \n   if (regno == SP_REGNUM)\n     /* The purpose of comparing with ptr_mode is to support the\n@@ -9163,6 +9173,9 @@ aarch64_regno_regclass (unsigned regno)\n   if (PR_REGNUM_P (regno))\n     return PR_LO_REGNUM_P (regno) ? PR_LO_REGS : PR_HI_REGS;\n \n+  if (regno == FFR_REGNUM || regno == FFRT_REGNUM)\n+    return FFR_REGS;\n+\n   return NO_REGS;\n }\n \n@@ -9461,6 +9474,8 @@ aarch64_class_max_nregs (reg_class_t regclass, machine_mode mode)\n     case PR_REGS:\n     case PR_LO_REGS:\n     case PR_HI_REGS:\n+    case FFR_REGS:\n+    case PR_AND_FFR_REGS:\n       return 1;\n \n     case NO_REGS:\n@@ -11641,6 +11656,14 @@ aarch64_register_move_cost (machine_mode mode,\n   if (from == TAILCALL_ADDR_REGS || from == POINTER_REGS)\n     from = GENERAL_REGS;\n \n+  /* Make RDFFR very expensive.  In particular, if we know that the FFR\n+     contains a PTRUE (e.g. after a SETFFR), we must never use RDFFR\n+     as a way of obtaining a PTRUE.  */\n+  if (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL\n+      && hard_reg_set_subset_p (reg_class_contents[from_i],\n+\t\t\t\treg_class_contents[FFR_REGS]))\n+    return 80;\n+\n   /* Moving between GPR and stack cost is the same as GP2GP.  */\n   if ((from == GENERAL_REGS && to == STACK_REG)\n       || (to == GENERAL_REGS && from == STACK_REG))\n@@ -14802,6 +14825,10 @@ aarch64_conditional_register_usage (void)\n \tcall_used_regs[i] = 1;\n       }\n \n+  /* Only allow the FFR and FFRT to be accessed via special patterns.  */\n+  CLEAR_HARD_REG_BIT (operand_reg_set, FFR_REGNUM);\n+  CLEAR_HARD_REG_BIT (operand_reg_set, FFRT_REGNUM);\n+\n   /* When tracking speculation, we need a couple of call-clobbered registers\n      to track the speculation state.  It would be nice to just use\n      IP0 and IP1, but currently there are numerous places that just"}, {"sha": "070fdc94098dfdce66ad597c73cd5de17e25add4", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/183bfdafc6f1f98711c5400498a7268cc1441096/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/183bfdafc6f1f98711c5400498a7268cc1441096/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=183bfdafc6f1f98711c5400498a7268cc1441096", "patch": "@@ -366,6 +366,9 @@ extern unsigned aarch64_architecture_version;\n    P0-P7        Predicate low registers: valid in all predicate contexts\n    P8-P15       Predicate high registers: used as scratch space\n \n+   FFR\t\tFirst Fault Register, a fixed-use SVE predicate register\n+   FFRT\t\tFFR token: a fake register used for modelling dependencies\n+\n    VG           Pseudo \"vector granules\" register\n \n    VG is the number of 64-bit elements in an SVE vector.  We define\n@@ -386,6 +389,7 @@ extern unsigned aarch64_architecture_version;\n     1, 1, 1, 1,\t\t\t/* SFP, AP, CC, VG */\t\\\n     0, 0, 0, 0,   0, 0, 0, 0,   /* P0 - P7 */           \\\n     0, 0, 0, 0,   0, 0, 0, 0,   /* P8 - P15 */          \\\n+    1, 1\t\t\t/* FFR and FFRT */\t\\\n   }\n \n /* X30 is marked as caller-saved which is in line with regular function call\n@@ -408,6 +412,7 @@ extern unsigned aarch64_architecture_version;\n     1, 1, 1, 1,\t\t\t/* SFP, AP, CC, VG */\t\\\n     1, 1, 1, 1,   1, 1, 1, 1,\t/* P0 - P7 */\t\t\\\n     1, 1, 1, 1,   1, 1, 1, 1,\t/* P8 - P15 */\t\t\\\n+    1, 1\t\t\t/* FFR and FFRT */\t\\\n   }\n \n #define REGISTER_NAMES\t\t\t\t\t\t\\\n@@ -423,6 +428,7 @@ extern unsigned aarch64_architecture_version;\n     \"sfp\", \"ap\",  \"cc\",  \"vg\",\t\t\t\t\t\\\n     \"p0\",  \"p1\",  \"p2\",  \"p3\",  \"p4\",  \"p5\",  \"p6\",  \"p7\",\t\\\n     \"p8\",  \"p9\",  \"p10\", \"p11\", \"p12\", \"p13\", \"p14\", \"p15\",\t\\\n+    \"ffr\", \"ffrt\"\t\t\t\t\t\t\\\n   }\n \n /* Generate the register aliases for core register N */\n@@ -471,7 +477,7 @@ extern unsigned aarch64_architecture_version;\n #define FRAME_POINTER_REGNUM\t\tSFP_REGNUM\n #define STACK_POINTER_REGNUM\t\tSP_REGNUM\n #define ARG_POINTER_REGNUM\t\tAP_REGNUM\n-#define FIRST_PSEUDO_REGISTER\t\t(P15_REGNUM + 1)\n+#define FIRST_PSEUDO_REGISTER\t\t(FFRT_REGNUM + 1)\n \n /* The number of (integer) argument register available.  */\n #define NUM_ARG_REGS\t\t\t8\n@@ -601,6 +607,8 @@ enum reg_class\n   PR_LO_REGS,\n   PR_HI_REGS,\n   PR_REGS,\n+  FFR_REGS,\n+  PR_AND_FFR_REGS,\n   ALL_REGS,\n   LIM_REG_CLASSES\t\t/* Last */\n };\n@@ -621,6 +629,8 @@ enum reg_class\n   \"PR_LO_REGS\",\t\t\t\t\t\\\n   \"PR_HI_REGS\",\t\t\t\t\t\\\n   \"PR_REGS\",\t\t\t\t\t\\\n+  \"FFR_REGS\",\t\t\t\t\t\\\n+  \"PR_AND_FFR_REGS\",\t\t\t\t\\\n   \"ALL_REGS\"\t\t\t\t\t\\\n }\n \n@@ -638,6 +648,8 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000ff0 },\t/* PR_LO_REGS */\t\\\n   { 0x00000000, 0x00000000, 0x000ff000 },\t/* PR_HI_REGS */\t\\\n   { 0x00000000, 0x00000000, 0x000ffff0 },\t/* PR_REGS */\t\t\\\n+  { 0x00000000, 0x00000000, 0x00300000 },\t/* FFR_REGS */\t\t\\\n+  { 0x00000000, 0x00000000, 0x003ffff0 },\t/* PR_AND_FFR_REGS */\t\\\n   { 0xffffffff, 0xffffffff, 0x000fffff }\t/* ALL_REGS */\t\t\\\n }\n "}, {"sha": "3778109cb62d5b116e02397452b122c8226b2965", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/183bfdafc6f1f98711c5400498a7268cc1441096/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/183bfdafc6f1f98711c5400498a7268cc1441096/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=183bfdafc6f1f98711c5400498a7268cc1441096", "patch": "@@ -107,6 +107,10 @@\n     (P13_REGNUM\t\t81)\n     (P14_REGNUM\t\t82)\n     (P15_REGNUM\t\t83)\n+    (FFR_REGNUM\t\t84)\n+    ;; \"FFR token\": a fake register used for representing the scheduling\n+    ;; restrictions on FFR-related operations.\n+    (FFRT_REGNUM\t85)\n     ;; Scratch register used by stack clash protection to calculate\n     ;; SVE CFA offsets during probing.\n     (STACK_CLASH_SVE_CFA_REGNUM 11)"}]}