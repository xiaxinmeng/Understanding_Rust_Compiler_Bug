{"sha": "ed7f23690a8c1cf8295cf151719d7b07f7b68bce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ3ZjIzNjkwYThjMWNmODI5NWNmMTUxNzE5ZDdiMDdmN2I2OGJjZQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2004-06-26T20:40:31Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2004-06-26T20:40:31Z"}, "message": "PR java/1207, java/16178\n\n\tPR java/1207, java/16178\n\t* jcf-parse.c (load_class): Return immediately if passed a type decl\n\twhere CLASS_FROM_SOURCE_P is set. Remove FIXME.\n\t* parse.y (do_resolve_class): Remove checks for CLASS_FROM_SOURCE_P\n\tbefore calling load_class.\n\t(qualify_and_find): Likewise.\n\t(find_in_imports_on_demand): Likewise.\n\t(find_applicable_accessible_methods_list): Likewise.\n\nCo-Authored-By: Ranjit Mathew <rmathew@hotmail.com>\n\nFrom-SVN: r83719", "tree": {"sha": "ec8c7b5d06daedd0915d6edd58a293686a084f4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec8c7b5d06daedd0915d6edd58a293686a084f4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed7f23690a8c1cf8295cf151719d7b07f7b68bce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed7f23690a8c1cf8295cf151719d7b07f7b68bce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed7f23690a8c1cf8295cf151719d7b07f7b68bce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed7f23690a8c1cf8295cf151719d7b07f7b68bce/comments", "author": null, "committer": null, "parents": [{"sha": "c872077c88496940e82e8f52988d98a94c9c5d29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c872077c88496940e82e8f52988d98a94c9c5d29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c872077c88496940e82e8f52988d98a94c9c5d29"}], "stats": {"total": 39, "additions": 27, "deletions": 12}, "files": [{"sha": "9ed01a6fc1504a505546b206070893aa8dd59e19", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7f23690a8c1cf8295cf151719d7b07f7b68bce/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7f23690a8c1cf8295cf151719d7b07f7b68bce/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=ed7f23690a8c1cf8295cf151719d7b07f7b68bce", "patch": "@@ -1,3 +1,20 @@\n+2004-06-26  Bryce McKinlay  <mckinlay@redhat.com>\n+\t    Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\tPR java/1207, java/16178\n+\t* jcf-parse.c (load_class): Return immediately if passed a type decl\n+\twhere CLASS_FROM_SOURCE_P is set. Remove FIXME.\n+\t* parse.y (do_resolve_class): Remove checks for CLASS_FROM_SOURCE_P\n+\tbefore calling load_class.\n+\t(qualify_and_find): Likewise.\n+\t(find_in_imports_on_demand): Likewise.\n+\t(find_applicable_accessible_methods_list): Likewise.\n+\n+2004-06-24  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* parse.y (java_layout_seen_class_methods): Don't call load_class\n+\ton class defined by source parser.\n+\n 2004-06-23  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* parse.y (set_nested_class_simple_name_value): Removed."}, {"sha": "42c3df3fc326317a306a6c8cd0ea25e74853791d", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7f23690a8c1cf8295cf151719d7b07f7b68bce/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7f23690a8c1cf8295cf151719d7b07f7b68bce/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=ed7f23690a8c1cf8295cf151719d7b07f7b68bce", "patch": "@@ -562,10 +562,6 @@ read_class (tree name)\n /* Load CLASS_OR_NAME. CLASS_OR_NAME can be a mere identifier if\n    called from the parser, otherwise it's a RECORD_TYPE node. If\n    VERBOSE is 1, print error message on failure to load a class. */\n-\n-/* Replace calls to load_class by having callers call read_class directly\n-   - and then perhaps rename read_class to load_class.  FIXME */\n-\n void\n load_class (tree class_or_name, int verbose)\n {\n@@ -581,7 +577,12 @@ load_class (tree class_or_name, int verbose)\n     name = TYPE_NAME (TREE_PURPOSE (class_or_name));\n   /* Or it's a type in the making */\n   else\n-    name = DECL_NAME (TYPE_NAME (class_or_name));\n+    {\n+      /* If the class is from source code, then it must already be loaded.  */\n+      if (CLASS_FROM_SOURCE_P (class_or_name))\n+        return;\n+      name = DECL_NAME (TYPE_NAME (class_or_name));\n+    }\n \n   saved = name;\n   while (1)"}, {"sha": "5b8a3039f68d7d52c15f212275f8c62af134a47d", "filename": "gcc/java/parse.y", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7f23690a8c1cf8295cf151719d7b07f7b68bce/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7f23690a8c1cf8295cf151719d7b07f7b68bce/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=ed7f23690a8c1cf8295cf151719d7b07f7b68bce", "patch": "@@ -5796,8 +5796,7 @@ do_resolve_class (tree enclosing, tree class_type, tree decl, tree cl)\n   /* 2- And check for the type in the current compilation unit */\n   if ((new_class_decl = IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type))))\n     {\n-      if (!CLASS_LOADED_P (TREE_TYPE (new_class_decl)) &&\n-\t  !CLASS_FROM_SOURCE_P (TREE_TYPE (new_class_decl)))\n+      if (!CLASS_LOADED_P (TREE_TYPE (new_class_decl)))\n \tload_class (TYPE_NAME (class_type), 0);\n       return IDENTIFIER_CLASS_VALUE (TYPE_NAME (class_type));\n     }\n@@ -5891,8 +5890,7 @@ qualify_and_find (tree class_type, tree package, tree name)\n     load_class (new_qualified, 0);\n   if ((new_class_decl = IDENTIFIER_CLASS_VALUE (new_qualified)))\n     {\n-      if (!CLASS_LOADED_P (TREE_TYPE (new_class_decl)) &&\n-\t  !CLASS_FROM_SOURCE_P (TREE_TYPE (new_class_decl)))\n+      if (!CLASS_LOADED_P (TREE_TYPE (new_class_decl)))\n \tload_class (new_qualified, 0);\n       TYPE_NAME (class_type) = new_qualified;\n       return IDENTIFIER_CLASS_VALUE (new_qualified);\n@@ -7044,8 +7042,7 @@ find_in_imports_on_demand (tree enclosing_type, tree class_type)\n       access_check = -1;\n       /* If there is no DECL set for the class or if the class isn't\n \t loaded and not seen in source yet, then load */\n-      if (!decl || (!CLASS_LOADED_P (TREE_TYPE (decl))\n-\t\t    && !CLASS_FROM_SOURCE_P (TREE_TYPE (decl))))\n+      if (!decl || ! CLASS_LOADED_P (TREE_TYPE (decl)))\n \t{\n \t  load_class (node, 0);\n \t  decl = IDENTIFIER_CLASS_VALUE (node);\n@@ -11014,7 +11011,7 @@ find_applicable_accessible_methods_list (int lc, tree class, tree name,\n   search_not_done++;\n   *htab_find_slot (searched_classes, class, INSERT) = class;\n \n-  if (!CLASS_LOADED_P (class) && !CLASS_FROM_SOURCE_P (class))\n+  if (!CLASS_LOADED_P (class))\n     {\n       load_class (class, 1);\n       safe_layout_class (class);"}]}