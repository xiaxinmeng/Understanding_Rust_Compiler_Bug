{"sha": "606e70fd3d8abf2a74fab56faeecfb8e249178ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA2ZTcwZmQzZDhhYmYyYTc0ZmFiNTZmYWVlY2ZiOGUyNDkxNzhjYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-04-14T07:29:43Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-18T09:08:20Z"}, "message": "[Ada] ACATS 4.1L - B452002 - Wrong universal access \"=\" rules\n\n2020-06-18  Arnaud Charlet  <charlet@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch4.adb (Find_Equality_Types.Check_Access_Object_Types):\n\tNew function, used to implement RM 4.5.2 (9.6/2).\n\t(Find_Equality_Types.Check_Compatible_Profiles): New function,\n\tused to implement RM 4.5.2(9.7/2).\n\t(Find_Equality_Types.Reference_Anonymous_Access_Type): New\n\tfunction.\n\t(Find_Equality_Types.Try_One_Interp): Fix handling of anonymous\n\taccess types which was accepting both too much and too little.\n\tRemove accumulated special and incomplete cases for\n\tinstantiations, replaced by Has_Compatible_Type.\n\t(Analyze_Overloaded_Selected_Component): Use\n\tIs_Anonymous_Access_Type instead of Ekind_In.\n\t* sem_res.adb: Code cleanup and bug fix: use\n\tIs_Anonymous_Access_Type instead of Ekind_In.  Relax checking of\n\tanonymous access parameter when universal_access \"=\" is\n\tinvolved.\n\t* sem_type.adb: Likewise.\n\t(Find_Unique_Type): Move code from here...\n\t(Specific_Type): ...to here. Also add missing handling of access\n\tto class wide types.\n\t* einfo.ads, einfo.adb (Is_Access_Object_Type): New.", "tree": {"sha": "3e8702851e60b29ac26bdd932f355989da8136d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e8702851e60b29ac26bdd932f355989da8136d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/606e70fd3d8abf2a74fab56faeecfb8e249178ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/606e70fd3d8abf2a74fab56faeecfb8e249178ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/606e70fd3d8abf2a74fab56faeecfb8e249178ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/606e70fd3d8abf2a74fab56faeecfb8e249178ca/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41e52aa5859d5ec202f05ec2e36984b7cb708fc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41e52aa5859d5ec202f05ec2e36984b7cb708fc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41e52aa5859d5ec202f05ec2e36984b7cb708fc3"}], "stats": {"total": 390, "additions": 291, "deletions": 99}, "files": [{"sha": "b48270935b9be5232cb2cf0b49f3234a2757b438", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/606e70fd3d8abf2a74fab56faeecfb8e249178ca/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/606e70fd3d8abf2a74fab56faeecfb8e249178ca/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=606e70fd3d8abf2a74fab56faeecfb8e249178ca", "patch": "@@ -3644,6 +3644,11 @@ package body Einfo is\n    -- Classification Functions --\n    ------------------------------\n \n+   function Is_Access_Object_Type               (Id : E) return B is\n+   begin\n+      return Is_Access_Type (Id) and then not Is_Access_Subprogram_Type (Id);\n+   end Is_Access_Object_Type;\n+\n    function Is_Access_Type                      (Id : E) return B is\n    begin\n       return Ekind (Id) in Access_Kind;"}, {"sha": "32f5593373b753554bf64e03a54efed1e28ee535", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/606e70fd3d8abf2a74fab56faeecfb8e249178ca/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/606e70fd3d8abf2a74fab56faeecfb8e249178ca/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=606e70fd3d8abf2a74fab56faeecfb8e249178ca", "patch": "@@ -2331,6 +2331,9 @@ package Einfo is\n --    Is_Access_Type (synthesized)\n --       Applies to all entities, true for access types and subtypes\n \n+--    Is_Access_Object_Type (synthesized)\n+--       Applies to all entities, true for access-to-object types and subtypes\n+\n --    Is_Activation_Record (Flag305)\n --       Applies to E_In_Parameters generated in Exp_Unst for nested\n --       subprograms, to mark the added formal that carries the activation\n@@ -7588,6 +7591,7 @@ package Einfo is\n    --  Is_Generic_Type where the Ekind does not provide the needed\n    --  information).\n \n+   function Is_Access_Object_Type               (Id : E) return B;\n    function Is_Access_Type                      (Id : E) return B;\n    function Is_Access_Protected_Subprogram_Type (Id : E) return B;\n    function Is_Access_Subprogram_Type           (Id : E) return B;"}, {"sha": "556f209fdc62e9eca84cf8317b5436285fdc1754", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 217, "deletions": 41, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/606e70fd3d8abf2a74fab56faeecfb8e249178ca/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/606e70fd3d8abf2a74fab56faeecfb8e249178ca/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=606e70fd3d8abf2a74fab56faeecfb8e249178ca", "patch": "@@ -3929,15 +3929,13 @@ package body Sem_Ch4 is\n                  and then Is_Visible_Component (Comp, Sel)\n                then\n \n-                  --  AI05-105:  if the context is an object renaming with\n+                  --  AI05-105: if the context is an object renaming with\n                   --  an anonymous access type, the expected type of the\n                   --  object must be anonymous. This is a name resolution rule.\n \n                   if Nkind (Parent (N)) /= N_Object_Renaming_Declaration\n                     or else No (Access_Definition (Parent (N)))\n-                    or else Ekind (Etype (Comp)) = E_Anonymous_Access_Type\n-                    or else\n-                      Ekind (Etype (Comp)) = E_Anonymous_Access_Subprogram_Type\n+                    or else Is_Anonymous_Access_Type (Etype (Comp))\n                   then\n                      Set_Entity (Sel, Comp);\n                      Set_Etype (Sel, Etype (Comp));\n@@ -6542,26 +6540,217 @@ package body Sem_Ch4 is\n       Op_Id : Entity_Id;\n       N     : Node_Id)\n    is\n-      Index : Interp_Index;\n+      Index : Interp_Index := 0;\n       It    : Interp;\n       Found : Boolean := False;\n       I_F   : Interp_Index;\n       T_F   : Entity_Id;\n       Scop  : Entity_Id := Empty;\n \n+      function Check_Access_Object_Types\n+        (N : Node_Id; Typ : Entity_Id) return Boolean;\n+      --  Check for RM 4.5.2 (9.6/2): When both are of access-to-object types,\n+      --  the designated types shall be the same or one shall cover the other,\n+      --  and if the designated types are elementary or array types, then the\n+      --  designated subtypes shall statically match.\n+      --  If N is not overloaded, then its unique type must be compatible as\n+      --  per above. Otherwise iterate through the interpretations of N looking\n+      --  for a compatible one.\n+\n+      procedure Check_Compatible_Profiles (N : Node_Id; Typ : Entity_Id);\n+      --  Check for RM 4.5.2(9.7/2): When both are of access-to-subprogram\n+      --  types, the designated profiles shall be subtype conformant.\n+\n+      function References_Anonymous_Access_Type\n+        (N : Node_Id; Typ : Entity_Id) return Boolean;\n+      --  Return True either if N is not overloaded and its Etype is an\n+      --  anonymous access type or if one of the interpretations of N refers\n+      --  to an anonymous access type compatible with Typ.\n+\n       procedure Try_One_Interp (T1 : Entity_Id);\n       --  The context of the equality operator plays no role in resolving the\n       --  arguments, so that if there is more than one interpretation of the\n       --  operands that is compatible with equality, the construct is ambiguous\n       --  and an error can be emitted now, after trying to disambiguate, i.e.\n       --  applying preference rules.\n \n+      -------------------------------\n+      -- Check_Access_Object_Types --\n+      -------------------------------\n+\n+      function Check_Access_Object_Types\n+        (N : Node_Id; Typ : Entity_Id) return Boolean\n+      is\n+         function Check_Designated_Types (DT1, DT2 : Entity_Id) return Boolean;\n+         --  Check RM 4.5.2 (9.6/2) on the given designated types.\n+\n+         ----------------------------\n+         -- Check_Designated_Types --\n+         ----------------------------\n+\n+         function Check_Designated_Types\n+           (DT1, DT2 : Entity_Id) return Boolean is\n+         begin\n+            --  If the designated types are elementary or array types, then\n+            --  the designated subtypes shall statically match.\n+\n+            if Is_Elementary_Type (DT1) or else Is_Array_Type (DT1) then\n+               if Base_Type (DT1) /= Base_Type (DT2) then\n+                  return False;\n+               else\n+                  return Subtypes_Statically_Match (DT1, DT2);\n+               end if;\n+\n+            --  Otherwise, the designated types shall be the same or one\n+            --  shall cover the other.\n+\n+            else\n+               return DT1 = DT2\n+                 or else Covers (DT1, DT2)\n+                 or else Covers (DT2, DT1);\n+            end if;\n+         end Check_Designated_Types;\n+\n+      --  Start of processing for Check_Access_Object_Types\n+\n+      begin\n+         --  Return immediately with no checks if Typ is not an\n+         --  access-to-object type.\n+\n+         if not Is_Access_Object_Type (Typ) then\n+            return True;\n+\n+         --  Any_Type is compatible with all types in this context, and is used\n+         --  in particular for the designated type of a 'null' value.\n+\n+         elsif Directly_Designated_Type (Typ) = Any_Type\n+           or else Nkind (N) = N_Null\n+         then\n+            return True;\n+         end if;\n+\n+         if not Is_Overloaded (N) then\n+            if Is_Access_Object_Type (Etype (N)) then\n+               return Check_Designated_Types\n+                 (Designated_Type (Typ), Designated_Type (Etype (N)));\n+            end if;\n+         else\n+            declare\n+               Typ_Is_Anonymous : constant Boolean :=\n+                 Is_Anonymous_Access_Type (Typ);\n+\n+               I  : Interp_Index;\n+               It : Interp;\n+\n+            begin\n+               Get_First_Interp (N, I, It);\n+               while Present (It.Typ) loop\n+\n+                  --  The check on designated types if only relevant when one\n+                  --  of the types is anonymous, ignore other (non relevant)\n+                  --  types.\n+\n+                  if (Typ_Is_Anonymous\n+                       or else Is_Anonymous_Access_Type (It.Typ))\n+                    and then Is_Access_Object_Type (It.Typ)\n+                  then\n+                     if Check_Designated_Types\n+                          (Designated_Type (Typ), Designated_Type (It.Typ))\n+                     then\n+                        return True;\n+                     end if;\n+                  end if;\n+\n+                  Get_Next_Interp (I, It);\n+               end loop;\n+            end;\n+         end if;\n+\n+         return False;\n+      end Check_Access_Object_Types;\n+\n+      -------------------------------\n+      -- Check_Compatible_Profiles --\n+      -------------------------------\n+\n+      procedure Check_Compatible_Profiles (N : Node_Id; Typ : Entity_Id) is\n+         I     : Interp_Index;\n+         It    : Interp;\n+         I1    : Interp_Index := 0;\n+         Found : Boolean := False;\n+         Tmp   : Entity_Id;\n+\n+      begin\n+         if not Is_Overloaded (N) then\n+            Check_Subtype_Conformant\n+              (Designated_Type (Etype (N)), Designated_Type (Typ), N);\n+         else\n+            Get_First_Interp (N, I, It);\n+            while Present (It.Typ) loop\n+               if Is_Access_Subprogram_Type (It.Typ) then\n+                  if not Found then\n+                     Found := True;\n+                     Tmp   := It.Typ;\n+                     I1    := I;\n+\n+                  else\n+                     It := Disambiguate (N, I1, I, Any_Type);\n+\n+                     if It /= No_Interp then\n+                        Tmp := It.Typ;\n+                        I1  := I;\n+                     else\n+                        Found := False;\n+                        exit;\n+                     end if;\n+                  end if;\n+               end if;\n+\n+               Get_Next_Interp (I, It);\n+            end loop;\n+\n+            if Found then\n+               Check_Subtype_Conformant\n+                 (Designated_Type (Tmp), Designated_Type (Typ), N);\n+            end if;\n+         end if;\n+      end Check_Compatible_Profiles;\n+\n+      --------------------------------------\n+      -- References_Anonymous_Access_Type --\n+      --------------------------------------\n+\n+      function References_Anonymous_Access_Type\n+        (N : Node_Id; Typ : Entity_Id) return Boolean\n+      is\n+         I  : Interp_Index;\n+         It : Interp;\n+      begin\n+         if not Is_Overloaded (N) then\n+            return Is_Anonymous_Access_Type (Etype (N));\n+         else\n+            Get_First_Interp (N, I, It);\n+            while Present (It.Typ) loop\n+               if Is_Anonymous_Access_Type (It.Typ)\n+                 and then (Covers (It.Typ, Typ) or else Covers (Typ, It.Typ))\n+               then\n+                  return True;\n+               end if;\n+\n+               Get_Next_Interp (I, It);\n+            end loop;\n+\n+            return False;\n+         end if;\n+      end References_Anonymous_Access_Type;\n+\n       --------------------\n       -- Try_One_Interp --\n       --------------------\n \n       procedure Try_One_Interp (T1 : Entity_Id) is\n-         Bas : Entity_Id;\n+         Universal_Access : Boolean;\n+         Bas              : Entity_Id;\n \n       begin\n          --  Perform a sanity check in case of previous errors\n@@ -6581,6 +6770,9 @@ package body Sem_Ch4 is\n          --  In Ada 2005, the equality operator for anonymous access types\n          --  is declared in Standard, and preference rules apply to it.\n \n+         Universal_Access := Is_Anonymous_Access_Type (T1)\n+           or else References_Anonymous_Access_Type (R, T1);\n+\n          if Present (Scop) then\n \n             --  Note that we avoid returning if we are currently within a\n@@ -6601,48 +6793,28 @@ package body Sem_Ch4 is\n             then\n                null;\n \n-            elsif Ekind (T1) = E_Anonymous_Access_Type\n-              and then Scop = Standard_Standard\n-            then\n-               null;\n+            elsif Scop /= Standard_Standard or else not Universal_Access then\n \n-            else\n                --  The scope does not contain an operator for the type\n \n                return;\n             end if;\n \n          --  If we have infix notation, the operator must be usable. Within\n-         --  an instance, if the type is already established we know it is\n-         --  correct. If an operand is universal it is compatible with any\n-         --  numeric type.\n+         --  an instance, the type may have been immediately visible if the\n+         --  types are compatible.\n \n          elsif In_Open_Scopes (Scope (Bas))\n            or else Is_Potentially_Use_Visible (Bas)\n            or else In_Use (Bas)\n            or else (In_Use (Scope (Bas)) and then not Is_Hidden (Bas))\n-\n-            --  In an instance, the type may have been immediately visible.\n-            --  Either the types are compatible, or one operand is universal\n-            --  (numeric or null).\n-\n            or else\n              ((In_Instance or else In_Inlined_Body)\n-                and then\n-                  (First_Subtype (T1) = First_Subtype (Etype (R))\n-                    or else Nkind (R) = N_Null\n-                    or else\n-                      (Is_Numeric_Type (T1)\n-                        and then Is_Universal_Numeric_Type (Etype (R)))))\n-\n-           --  In Ada 2005, the equality on anonymous access types is declared\n-           --  in Standard, and is always visible.\n-\n-           or else Ekind (T1) = E_Anonymous_Access_Type\n+                and then Has_Compatible_Type (R, T1))\n          then\n             null;\n \n-         else\n+         elsif not Universal_Access then\n             --  Save candidate type for subsequent error message, if any\n \n             if not Is_Limited_Type (T1) then\n@@ -6655,9 +6827,7 @@ package body Sem_Ch4 is\n          --  Ada 2005 (AI-230): Keep restriction imposed by Ada 83 and 95:\n          --  Do not allow anonymous access types in equality operators.\n \n-         if Ada_Version < Ada_2005\n-           and then Ekind (T1) = E_Anonymous_Access_Type\n-         then\n+         if Ada_Version < Ada_2005 and then Universal_Access then\n             return;\n          end if;\n \n@@ -6675,9 +6845,10 @@ package body Sem_Ch4 is\n          --  because that indicates the potential rewriting case where the\n          --  interpretation to consider is actually \"=\" and the node may be\n          --  about to be rewritten by Analyze_Equality_Op.\n+         --  Finally, also check for RM 4.5.2 (9.6/2).\n \n          if T1 /= Standard_Void_Type\n-           and then Has_Compatible_Type (R, T1)\n+           and then (Universal_Access or else Has_Compatible_Type (R, T1))\n \n            and then\n              ((not Is_Limited_Type (T1)\n@@ -6692,7 +6863,18 @@ package body Sem_Ch4 is\n              (Nkind (N) /= N_Op_Ne\n                or else not Is_Tagged_Type (T1)\n                or else Chars (Op_Id) = Name_Op_Eq)\n+\n+           and then (not Universal_Access\n+                      or else Check_Access_Object_Types (R, T1))\n          then\n+            if Universal_Access\n+              and then Is_Access_Subprogram_Type (T1)\n+              and then Nkind (L) /= N_Null\n+              and then Nkind (R) /= N_Null\n+            then\n+               Check_Compatible_Profiles (R, T1);\n+            end if;\n+\n             if Found\n               and then Base_Type (T1) /= Base_Type (T_F)\n             then\n@@ -6724,11 +6906,6 @@ package body Sem_Ch4 is\n             if Etype (N) = Any_Type then\n                Found := False;\n             end if;\n-\n-         elsif Scop = Standard_Standard\n-           and then Ekind (T1) = E_Anonymous_Access_Type\n-         then\n-            Found := True;\n          end if;\n       end Try_One_Interp;\n \n@@ -6763,7 +6940,6 @@ package body Sem_Ch4 is\n \n       if not Is_Overloaded (L) then\n          Try_One_Interp (Etype (L));\n-\n       else\n          Get_First_Interp (L, Index, It);\n          while Present (It.Typ) loop"}, {"sha": "e6b4e6cd81fbdd704a110f9afd677a65655fa423", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/606e70fd3d8abf2a74fab56faeecfb8e249178ca/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/606e70fd3d8abf2a74fab56faeecfb8e249178ca/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=606e70fd3d8abf2a74fab56faeecfb8e249178ca", "patch": "@@ -1547,8 +1547,8 @@ package body Sem_Res is\n             null;\n \n          elsif Nam_In (Op_Name, Name_Op_Multiply, Name_Op_Divide)\n-           and then Is_Fixed_Point_Type (Etype (Left_Opnd  (Op_Node)))\n-           and then Is_Fixed_Point_Type (Etype (Right_Opnd (Op_Node)))\n+           and then Is_Fixed_Point_Type (Etype (Act1))\n+           and then Is_Fixed_Point_Type (Etype (Act2))\n          then\n             if Pack /= Standard_Standard then\n                Error := True;\n@@ -1559,7 +1559,8 @@ package body Sem_Res is\n \n          elsif Ada_Version >= Ada_2005\n            and then Nam_In (Op_Name, Name_Op_Eq, Name_Op_Ne)\n-           and then Ekind (Etype (Act1)) = E_Anonymous_Access_Type\n+           and then (Is_Anonymous_Access_Type (Etype (Act1))\n+                      or else Is_Anonymous_Access_Type (Etype (Act2)))\n          then\n             null;\n \n@@ -8470,10 +8471,8 @@ package body Sem_Res is\n          --  Why no similar processing for case expressions???\n \n          elsif Ada_Version >= Ada_2012\n-           and then Ekind_In (Etype (L), E_Anonymous_Access_Type,\n-                                         E_Anonymous_Access_Subprogram_Type)\n-           and then Ekind_In (Etype (R), E_Anonymous_Access_Type,\n-                                         E_Anonymous_Access_Subprogram_Type)\n+           and then Is_Anonymous_Access_Type (Etype (L))\n+           and then Is_Anonymous_Access_Type (Etype (R))\n          then\n             Check_If_Expression (L);\n             Check_If_Expression (R);\n@@ -13327,13 +13326,14 @@ package body Sem_Res is\n                      return False;\n \n                   --  Implicit conversions aren't allowed for anonymous access\n-                  --  parameters. The \"not Is_Local_Anonymous_Access_Type\" test\n-                  --  is done to exclude anonymous access results.\n+                  --  parameters. We exclude anonymous access results as well\n+                  --  as universal_access \"=\".\n \n                   elsif not Is_Local_Anonymous_Access (Opnd_Type)\n                     and then Nkind_In (Associated_Node_For_Itype (Opnd_Type),\n                                        N_Function_Specification,\n                                        N_Procedure_Specification)\n+                    and then not Nkind_In (Parent (N), N_Op_Eq, N_Op_Ne)\n                   then\n                      Conversion_Error_N\n                        (\"implicit conversion of anonymous access parameter \"\n@@ -13355,7 +13355,7 @@ package body Sem_Res is\n                   --  implicit conversion is disallowed (by RM12-8.6(27.1/3)).\n \n                   elsif Type_Access_Level (Opnd_Type) >\n-                        Deepest_Type_Access_Level (Target_Type)\n+                    Deepest_Type_Access_Level (Target_Type)\n                   then\n                      Conversion_Error_N\n                        (\"implicit conversion of anonymous access value \""}, {"sha": "d975edc26fe77cfead986e627c45e03c68eddb80", "filename": "gcc/ada/sem_type.adb", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/606e70fd3d8abf2a74fab56faeecfb8e249178ca/gcc%2Fada%2Fsem_type.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/606e70fd3d8abf2a74fab56faeecfb8e249178ca/gcc%2Fada%2Fsem_type.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_type.adb?ref=606e70fd3d8abf2a74fab56faeecfb8e249178ca", "patch": "@@ -376,7 +376,7 @@ package body Sem_Type is\n            or else Nkind (N) = N_Expanded_Name\n            or else (Nkind (N) in N_Op and then E = Entity (N))\n            or else (In_Instance or else In_Inlined_Body)\n-           or else Ekind (Vis_Type) = E_Anonymous_Access_Type\n+           or else Is_Anonymous_Access_Type (Vis_Type)\n          then\n             null;\n \n@@ -1242,8 +1242,8 @@ package body Sem_Type is\n       --                                   Formal_Obj => Actual_Obj);\n \n       elsif Ada_Version >= Ada_2005\n-        and then Ekind (T1) = E_Anonymous_Access_Type\n-        and then Ekind (T2) = E_Anonymous_Access_Type\n+        and then Is_Anonymous_Access_Type (T1)\n+        and then Is_Anonymous_Access_Type (T2)\n         and then Is_Generic_Type (Directly_Designated_Type (T1))\n         and then Get_Instance_Of (Directly_Designated_Type (T1)) =\n                                                Directly_Designated_Type (T2)\n@@ -1888,9 +1888,7 @@ package body Sem_Type is\n       elsif Nkind (Parent (N)) = N_Object_Renaming_Declaration\n         and then Present (Access_Definition (Parent (N)))\n       then\n-         if Ekind_In (It1.Typ, E_Anonymous_Access_Type,\n-                               E_Anonymous_Access_Subprogram_Type)\n-         then\n+         if Is_Anonymous_Access_Type (It1.Typ) then\n             if Ekind (It2.Typ) = Ekind (It1.Typ) then\n \n                --  True ambiguity\n@@ -1901,9 +1899,7 @@ package body Sem_Type is\n                return It1;\n             end if;\n \n-         elsif Ekind_In (It2.Typ, E_Anonymous_Access_Type,\n-                                  E_Anonymous_Access_Subprogram_Type)\n-         then\n+         elsif Is_Anonymous_Access_Type (It2.Typ) then\n             return It2;\n \n          --  No legal interpretation\n@@ -2121,7 +2117,7 @@ package body Sem_Type is\n             elsif Nam_In (Chars (Nam1), Name_Op_Eq, Name_Op_Ne)\n               and then Ada_Version >= Ada_2005\n               and then Etype (User_Subp) = Standard_Boolean\n-              and then Ekind (Operand_Type) = E_Anonymous_Access_Type\n+              and then Is_Anonymous_Access_Type (Operand_Type)\n               and then\n                 In_Same_Declaration_List\n                   (Designated_Type (Operand_Type),\n@@ -2252,35 +2248,6 @@ package body Sem_Type is\n       elsif T = Universal_Fixed then\n          return Etype (R);\n \n-      --  Ada 2005 (AI-230): Support the following operators:\n-\n-      --    function \"=\"  (L, R : universal_access) return Boolean;\n-      --    function \"/=\" (L, R : universal_access) return Boolean;\n-\n-      --  Pool specific access types (E_Access_Type) are not covered by these\n-      --  operators because of the legality rule of 4.5.2(9.2): \"The operands\n-      --  of the equality operators for universal_access shall be convertible\n-      --  to one another (see 4.6)\". For example, considering the type decla-\n-      --  ration \"type P is access Integer\" and an anonymous access to Integer,\n-      --  P is convertible to \"access Integer\" by 4.6 (24.11-24.15), but there\n-      --  is no rule in 4.6 that allows \"access Integer\" to be converted to P.\n-      --  Note that this does not preclude one operand to be a pool-specific\n-      --  access type, as a previous version of this code enforced.\n-\n-      elsif Ada_Version >= Ada_2005\n-        and then Ekind_In (Etype (L), E_Anonymous_Access_Type,\n-                                      E_Anonymous_Access_Subprogram_Type)\n-        and then Is_Access_Type (Etype (R))\n-      then\n-         return Etype (L);\n-\n-      elsif Ada_Version >= Ada_2005\n-        and then Ekind_In (Etype (R), E_Anonymous_Access_Type,\n-                                      E_Anonymous_Access_Subprogram_Type)\n-        and then Is_Access_Type (Etype (L))\n-      then\n-         return Etype (R);\n-\n       --  If one operand is a raise_expression, use type of other operand\n \n       elsif Nkind (L) = N_Raise_Expression then\n@@ -3438,6 +3405,24 @@ package body Sem_Type is\n       then\n          return T2;\n \n+      elsif Is_Access_Type (T1)\n+        and then Is_Access_Type (T2)\n+        and then Is_Class_Wide_Type (Designated_Type (T1))\n+        and then not Is_Class_Wide_Type (Designated_Type (T2))\n+        and then\n+          Is_Ancestor (Root_Type (Designated_Type (T1)), Designated_Type (T2))\n+      then\n+         return T1;\n+\n+      elsif Is_Access_Type (T1)\n+        and then Is_Access_Type (T2)\n+        and then Is_Class_Wide_Type (Designated_Type (T2))\n+        and then not Is_Class_Wide_Type (Designated_Type (T1))\n+        and then\n+          Is_Ancestor (Root_Type (Designated_Type (T2)), Designated_Type (T1))\n+      then\n+         return T2;\n+\n       elsif Ekind_In (B1, E_Access_Subprogram_Type,\n                           E_Access_Protected_Subprogram_Type)\n         and then Ekind (Designated_Type (B1)) /= E_Subprogram_Type\n@@ -3452,25 +3437,47 @@ package body Sem_Type is\n       then\n          return T1;\n \n-      elsif Ekind_In (T1, E_Allocator_Type,\n-                          E_Access_Attribute_Type,\n-                          E_Anonymous_Access_Type)\n+      elsif Ekind_In (T1, E_Allocator_Type, E_Access_Attribute_Type)\n         and then Is_Access_Type (T2)\n       then\n          return T2;\n \n-      elsif Ekind_In (T2, E_Allocator_Type,\n-                          E_Access_Attribute_Type,\n-                          E_Anonymous_Access_Type)\n+      elsif Ekind_In (T2, E_Allocator_Type, E_Access_Attribute_Type)\n         and then Is_Access_Type (T1)\n       then\n          return T1;\n \n-      --  If none of the above cases applies, types are not compatible\n+      --  Ada 2005 (AI-230): Support the following operators:\n \n-      else\n-         return Any_Type;\n+      --    function \"=\"  (L, R : universal_access) return Boolean;\n+      --    function \"/=\" (L, R : universal_access) return Boolean;\n+\n+      --  Pool-specific access types (E_Access_Type) are not covered by these\n+      --  operators because of the legality rule of 4.5.2(9.2): \"The operands\n+      --  of the equality operators for universal_access shall be convertible\n+      --  to one another (see 4.6)\". For example, considering the type decla-\n+      --  ration \"type P is access Integer\" and an anonymous access to Integer,\n+      --  P is convertible to \"access Integer\" by 4.6 (24.11-24.15), but there\n+      --  is no rule in 4.6 that allows \"access Integer\" to be converted to P.\n+      --  Note that this does not preclude one operand to be a pool-specific\n+      --  access type, as a previous version of this code enforced.\n+\n+      elsif Ada_Version >= Ada_2005 then\n+         if Is_Anonymous_Access_Type (T1)\n+           and then Is_Access_Type (T2)\n+         then\n+            return T1;\n+\n+         elsif Is_Anonymous_Access_Type (T2)\n+           and then Is_Access_Type (T1)\n+         then\n+            return T2;\n+         end if;\n       end if;\n+\n+      --  If none of the above cases applies, types are not compatible\n+\n+      return Any_Type;\n    end Specific_Type;\n \n    ---------------------"}]}