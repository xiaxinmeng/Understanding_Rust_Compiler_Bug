{"sha": "6ae6116f1985d4b1645d173776e3d73f2010c939", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFlNjExNmYxOTg1ZDRiMTY0NWQxNzM3NzZlM2Q3M2YyMDEwYzkzOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-07-10T08:25:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-07-10T08:25:39Z"}, "message": "Use VEC_WIDEN_MULT_EVEN/ODD_EXPR in supportable_widening_operation\n\n        * tree-vect-stmts.c (supportable_widening_operation): Expand\n        WIDEN_MULT_EXPR via VEC_WIDEN_MULT_EVEN/ODD_EXPR if possible.\n\nFrom-SVN: r189408", "tree": {"sha": "b399a7b31a3b5cb879e0a2b3ace6605e1d3526c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b399a7b31a3b5cb879e0a2b3ace6605e1d3526c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ae6116f1985d4b1645d173776e3d73f2010c939", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ae6116f1985d4b1645d173776e3d73f2010c939", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ae6116f1985d4b1645d173776e3d73f2010c939", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ae6116f1985d4b1645d173776e3d73f2010c939/comments", "author": null, "committer": null, "parents": [{"sha": "00f07b86e7d7c80695fb655738b89d893b54fc9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f07b86e7d7c80695fb655738b89d893b54fc9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00f07b86e7d7c80695fb655738b89d893b54fc9a"}], "stats": {"total": 99, "additions": 53, "deletions": 46}, "files": [{"sha": "228bd70bc6cce1ccccbe4bff83856171080e35e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae6116f1985d4b1645d173776e3d73f2010c939/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae6116f1985d4b1645d173776e3d73f2010c939/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ae6116f1985d4b1645d173776e3d73f2010c939", "patch": "@@ -1,5 +1,8 @@\n 2012-07-10  Richard Henderson  <rth@redhat.com>\n \n+\t* tree-vect-stmts.c (supportable_widening_operation): Expand\n+\tWIDEN_MULT_EXPR via VEC_WIDEN_MULT_EVEN/ODD_EXPR if possible.\n+\n \t* expmed.c (expmed_mult_highpart): Rename from expand_mult_highpart.\n \t(expmed_mult_highpart_optab): Rename from expand_mult_highpart_optab.\n \t* optabs.c (can_mult_highpart_p): New."}, {"sha": "fe6a997a1aacebbba51b95d7a7bd4425c8dadc2f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 50, "deletions": 46, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae6116f1985d4b1645d173776e3d73f2010c939/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae6116f1985d4b1645d173776e3d73f2010c939/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=6ae6116f1985d4b1645d173776e3d73f2010c939", "patch": "@@ -6199,15 +6199,15 @@ vect_is_simple_use_1 (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n bool\n supportable_widening_operation (enum tree_code code, gimple stmt,\n \t\t\t\ttree vectype_out, tree vectype_in,\n-                                tree *decl1, tree *decl2,\n+                                tree *decl1 ATTRIBUTE_UNUSED,\n+\t\t\t\ttree *decl2 ATTRIBUTE_UNUSED,\n                                 enum tree_code *code1, enum tree_code *code2,\n                                 int *multi_step_cvt,\n                                 VEC (tree, heap) **interm_types)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_info = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *vect_loop = NULL;\n-  bool ordered_p;\n   enum machine_mode vec_mode;\n   enum insn_code icode1, icode2;\n   optab optab1, optab2;\n@@ -6223,56 +6223,60 @@ supportable_widening_operation (enum tree_code code, gimple stmt,\n   if (loop_info)\n     vect_loop = LOOP_VINFO_LOOP (loop_info);\n \n-  /* The result of a vectorized widening operation usually requires two vectors\n-     (because the widened results do not fit into one vector). The generated\n-     vector results would normally be expected to be generated in the same\n-     order as in the original scalar computation, i.e. if 8 results are\n-     generated in each vector iteration, they are to be organized as follows:\n-        vect1: [res1,res2,res3,res4], vect2: [res5,res6,res7,res8].\n-\n-     However, in the special case that the result of the widening operation is\n-     used in a reduction computation only, the order doesn't matter (because\n-     when vectorizing a reduction we change the order of the computation).\n-     Some targets can take advantage of this and generate more efficient code.\n-     For example, targets like Altivec, that support widen_mult using a sequence\n-     of {mult_even,mult_odd} generate the following vectors:\n-        vect1: [res1,res3,res5,res7], vect2: [res2,res4,res6,res8].\n-\n-     When vectorizing outer-loops, we execute the inner-loop sequentially\n-     (each vectorized inner-loop iteration contributes to VF outer-loop\n-     iterations in parallel).  We therefore don't allow to change the order\n-     of the computation in the inner-loop during outer-loop vectorization.  */\n-\n-   if (vect_loop\n-       && STMT_VINFO_RELEVANT (stmt_info) == vect_used_by_reduction\n-       && !nested_in_vect_loop_p (vect_loop, stmt))\n-     ordered_p = false;\n-   else\n-     ordered_p = true;\n-\n-  if (!ordered_p\n-      && code == WIDEN_MULT_EXPR\n-      && targetm.vectorize.builtin_mul_widen_even\n-      && targetm.vectorize.builtin_mul_widen_even (vectype)\n-      && targetm.vectorize.builtin_mul_widen_odd\n-      && targetm.vectorize.builtin_mul_widen_odd (vectype))\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"Unordered widening operation detected.\");\n-\n-      *code1 = *code2 = CALL_EXPR;\n-      *decl1 = targetm.vectorize.builtin_mul_widen_even (vectype);\n-      *decl2 = targetm.vectorize.builtin_mul_widen_odd (vectype);\n-      return true;\n-    }\n-\n   switch (code)\n     {\n     case WIDEN_MULT_EXPR:\n+      /* The result of a vectorized widening operation usually requires\n+\t two vectors (because the widened results do not fit into one vector).\n+\t The generated vector results would normally be expected to be\n+\t generated in the same order as in the original scalar computation,\n+\t i.e. if 8 results are generated in each vector iteration, they are\n+\t to be organized as follows:\n+\t\tvect1: [res1,res2,res3,res4],\n+\t\tvect2: [res5,res6,res7,res8].\n+\n+\t However, in the special case that the result of the widening\n+\t operation is used in a reduction computation only, the order doesn't\n+\t matter (because when vectorizing a reduction we change the order of\n+\t the computation).  Some targets can take advantage of this and\n+\t generate more efficient code.  For example, targets like Altivec,\n+\t that support widen_mult using a sequence of {mult_even,mult_odd}\n+\t generate the following vectors:\n+\t\tvect1: [res1,res3,res5,res7],\n+\t\tvect2: [res2,res4,res6,res8].\n+\n+\t When vectorizing outer-loops, we execute the inner-loop sequentially\n+\t (each vectorized inner-loop iteration contributes to VF outer-loop\n+\t iterations in parallel).  We therefore don't allow to change the\n+\t order of the computation in the inner-loop during outer-loop\n+\t vectorization.  */\n+      /* TODO: Another case in which order doesn't *really* matter is when we\n+\t widen and then contract again, e.g. (short)((int)x * y >> 8).\n+\t Normally, pack_trunc performs an even/odd permute, whereas the \n+\t repack from an even/odd expansion would be an interleave, which\n+\t would be significantly simpler for e.g. AVX2.  */\n+      /* In any case, in order to avoid duplicating the code below, recurse\n+\t on VEC_WIDEN_MULT_EVEN_EXPR.  If it succeeds, all the return values\n+\t are properly set up for the caller.  If we fail, we'll continue with\n+\t a VEC_WIDEN_MULT_LO/HI_EXPR check.  */\n+      if (vect_loop\n+\t  && STMT_VINFO_RELEVANT (stmt_info) == vect_used_by_reduction\n+\t  && !nested_in_vect_loop_p (vect_loop, stmt)\n+\t  && supportable_widening_operation (VEC_WIDEN_MULT_EVEN_EXPR,\n+\t\t\t\t\t     stmt, vectype_out, vectype_in,\n+\t\t\t\t\t     NULL, NULL, code1, code2,\n+\t\t\t\t\t     multi_step_cvt, interm_types))\n+\treturn true;\n       c1 = VEC_WIDEN_MULT_LO_EXPR;\n       c2 = VEC_WIDEN_MULT_HI_EXPR;\n       break;\n \n+    case VEC_WIDEN_MULT_EVEN_EXPR:\n+      /* Support the recursion induced just above.  */\n+      c1 = VEC_WIDEN_MULT_EVEN_EXPR;\n+      c2 = VEC_WIDEN_MULT_ODD_EXPR;\n+      break;\n+\n     case WIDEN_LSHIFT_EXPR:\n       c1 = VEC_WIDEN_LSHIFT_LO_EXPR;\n       c2 = VEC_WIDEN_LSHIFT_HI_EXPR;\n@@ -6298,7 +6302,7 @@ supportable_widening_operation (enum tree_code code, gimple stmt,\n       gcc_unreachable ();\n     }\n \n-  if (BYTES_BIG_ENDIAN)\n+  if (BYTES_BIG_ENDIAN && c1 != VEC_WIDEN_MULT_EVEN_EXPR)\n     {\n       enum tree_code ctmp = c1;\n       c1 = c2;"}]}