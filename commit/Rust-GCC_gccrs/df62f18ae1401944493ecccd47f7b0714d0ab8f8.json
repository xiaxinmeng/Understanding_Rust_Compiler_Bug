{"sha": "df62f18ae1401944493ecccd47f7b0714d0ab8f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY2MmYxOGFlMTQwMTk0NDQ5M2VjY2NkNDdmN2IwNzE0ZDBhYjhmOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2004-06-30T10:09:55Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2004-06-30T10:09:55Z"}, "message": "re PR tree-optimization/15310 ([tree-ssa] Optimize an addition in a bit field)\n\n\t* simplify-rtx.c (simplify_binary_operation): Simplify\n\t((A & N) + B) & M -> (A + B) & M if M is pow2 minus 1 constant and\n\tN has at least all bits in M set as well.\n\n\tPR tree-optimization/15310\n\t* expr.c (expand_assignment): Optimize += or -= on a bit field in\n\tmost significant bits.\n\n\t* gcc.c-torture/execute/20040629-1.c: New test.\n\nFrom-SVN: r83900", "tree": {"sha": "de710deee48e0626b77470a406d37539f06fe50a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de710deee48e0626b77470a406d37539f06fe50a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df62f18ae1401944493ecccd47f7b0714d0ab8f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df62f18ae1401944493ecccd47f7b0714d0ab8f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df62f18ae1401944493ecccd47f7b0714d0ab8f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df62f18ae1401944493ecccd47f7b0714d0ab8f8/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e6a0022b28265f3676f7273a05afb4f6d1d7fd14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6a0022b28265f3676f7273a05afb4f6d1d7fd14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6a0022b28265f3676f7273a05afb4f6d1d7fd14"}], "stats": {"total": 243, "additions": 243, "deletions": 0}, "files": [{"sha": "c1a0c8987364a16fefba9e82eb087e519e04d327", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df62f18ae1401944493ecccd47f7b0714d0ab8f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df62f18ae1401944493ecccd47f7b0714d0ab8f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df62f18ae1401944493ecccd47f7b0714d0ab8f8", "patch": "@@ -1,3 +1,13 @@\n+2004-06-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* simplify-rtx.c (simplify_binary_operation): Simplify\n+\t((A & N) + B) & M -> (A + B) & M if M is pow2 minus 1 constant and\n+\tN has at least all bits in M set as well.\n+\n+\tPR tree-optimization/15310\n+\t* expr.c (expand_assignment): Optimize += or -= on a bit field in\n+\tmost significant bits.\n+\n 2004-06-30  Steven Bosscher  <stevenb@suse.de>\n \n \t* config/c4x/c4x.md: Fix comment."}, {"sha": "d67e6ee3fd6aa325ffa4a05c3775d273af0d654b", "filename": "gcc/expr.c", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df62f18ae1401944493ecccd47f7b0714d0ab8f8/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df62f18ae1401944493ecccd47f7b0714d0ab8f8/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=df62f18ae1401944493ecccd47f7b0714d0ab8f8", "patch": "@@ -3858,6 +3858,57 @@ expand_assignment (tree to, tree from, int want_value)\n \t  MEM_KEEP_ALIAS_SET_P (to_rtx) = 1;\n \t}\n \n+      if (mode1 == VOIDmode && !want_value\n+\t  && bitpos + bitsize <= BITS_PER_WORD\n+\t  && bitsize < BITS_PER_WORD\n+\t  && GET_MODE_BITSIZE (GET_MODE (to_rtx)) <= BITS_PER_WORD\n+\t  && !TREE_SIDE_EFFECTS (to)\n+\t  && TREE_CODE (TREE_TYPE (from)) == INTEGER_TYPE\n+\t  && TREE_CODE_CLASS (TREE_CODE (from)) == '2'\n+\t  && operand_equal_p (to, TREE_OPERAND (from, 0), 0))\n+\t{\n+\t  rtx value;\n+\t  HOST_WIDE_INT count = bitpos;\n+\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    count = GET_MODE_BITSIZE (GET_MODE (to_rtx)) - bitpos - bitsize;\n+\n+\t  /* Special case some bitfield op= exp.  */\n+\t  switch (TREE_CODE (from))\n+\t    {\n+\t    case PLUS_EXPR:\n+\t    case MINUS_EXPR:\n+\t      if (count <= 0)\n+\t        break;\n+\n+\t      /* For now, just optimize the case of the topmost bitfield\n+\t\t where we don't need to do any masking.\n+\t\t We might win by one instruction for the other bitfields\n+\t\t too if insv/extv instructions aren't used, so that\n+\t\t can be added later.  */\n+\t      if (count + bitsize != GET_MODE_BITSIZE (GET_MODE (to_rtx)))\n+\t\tbreak;\n+\t      value = expand_expr (TREE_OPERAND (from, 1), NULL_RTX,\n+\t\t\t\t   VOIDmode, 0);\n+\t      value = protect_from_queue (value, 0);\n+\t      to_rtx = protect_from_queue (to_rtx, 1);\n+\t      value = expand_shift (LSHIFT_EXPR, GET_MODE (to_rtx),\n+\t\t\t\t    value, build_int_2 (count, 0),\n+\t\t\t\t    NULL_RTX, 1);\n+\t      result = expand_binop (GET_MODE (to_rtx),\n+\t\t\t\t     TREE_CODE (from) == PLUS_EXPR\n+\t\t\t\t     ? add_optab : sub_optab, to_rtx,\n+\t\t\t\t     value, to_rtx, 1, OPTAB_WIDEN);\n+\t      if (result != to_rtx)\n+\t\temit_move_insn (to_rtx, result);\n+\t      free_temp_slots ();\n+\t      pop_temp_slots ();\n+\t      return NULL_RTX;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+\n       result = store_field (to_rtx, bitsize, bitpos, mode1, from,\n \t\t\t    (want_value\n \t\t\t     /* Spurious cast for HPUX compiler.  */"}, {"sha": "1ca27b288f4845ea9b2fab53bc416cd1aa1e7e7e", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df62f18ae1401944493ecccd47f7b0714d0ab8f8/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df62f18ae1401944493ecccd47f7b0714d0ab8f8/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=df62f18ae1401944493ecccd47f7b0714d0ab8f8", "patch": "@@ -1894,6 +1894,52 @@ simplify_binary_operation (enum rtx_code code, enum machine_mode mode,\n \t      && ! side_effects_p (op0)\n \t      && GET_MODE_CLASS (mode) != MODE_CC)\n \t    return const0_rtx;\n+\t  /* For constants M and N, if M == (1LL << cst) - 1 && (N & M) == M,\n+\t     ((A & N) + B) & M -> (A + B) & M\n+\t     Similarly if (N & M) == 0,\n+\t     ((A | N) + B) & M -> (A + B) & M\n+\t     and for - instead of + and/or ^ instead of |.  */\n+\t  if (GET_CODE (trueop1) == CONST_INT\n+\t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t      && ~INTVAL (trueop1)\n+\t      && (INTVAL (trueop1) & (INTVAL (trueop1) + 1)) == 0\n+\t      && (GET_CODE (op0) == PLUS || GET_CODE (op0) == MINUS))\n+\t    {\n+\t      rtx pmop[2];\n+\t      int which;\n+\n+\t      pmop[0] = XEXP (op0, 0);\n+\t      pmop[1] = XEXP (op0, 1);\n+\n+\t      for (which = 0; which < 2; which++)\n+\t\t{\n+\t\t  tem = pmop[which];\n+\t\t  switch (GET_CODE (tem))\n+\t\t    {\n+\t\t    case AND:\n+\t\t      if (GET_CODE (XEXP (tem, 1)) == CONST_INT\n+\t\t\t  && (INTVAL (XEXP (tem, 1)) & INTVAL (trueop1))\n+\t\t\t     == INTVAL (trueop1))\n+\t\t\tpmop[which] = XEXP (tem, 0);\n+\t\t      break;\n+\t\t    case IOR:\n+\t\t    case XOR:\n+\t\t      if (GET_CODE (XEXP (tem, 1)) == CONST_INT\n+\t\t\t  && (INTVAL (XEXP (tem, 1)) & INTVAL (trueop1)) == 0)\n+\t\t\tpmop[which] = XEXP (tem, 0);\n+\t\t      break;\n+\t\t    default:\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\n+\t      if (pmop[0] != XEXP (op0, 0) || pmop[1] != XEXP (op0, 1))\n+\t\t{\n+\t\t  tem = simplify_gen_binary (GET_CODE (op0), mode,\n+\t\t\t\t\t     pmop[0], pmop[1]);\n+\t\t  return simplify_gen_binary (code, mode, tem, op1);\n+\t\t}\n+\t    }\n \t  tem = simplify_associative_operation (code, mode, op0, op1);\n \t  if (tem)\n \t    return tem;"}, {"sha": "57520be74e9d707141ce854a6987547b5c0160b1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df62f18ae1401944493ecccd47f7b0714d0ab8f8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df62f18ae1401944493ecccd47f7b0714d0ab8f8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=df62f18ae1401944493ecccd47f7b0714d0ab8f8", "patch": "@@ -1,3 +1,7 @@\n+2004-06-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.c-torture/execute/20040629-1.c: New test.\n+\n 2004-06-29  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/compat/vector-defs.h: Use vector_size attribute"}, {"sha": "9180d6c292047da96b987a7e95f5a7e92079d63b", "filename": "gcc/testsuite/gcc.c-torture/execute/20040629-1.c", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df62f18ae1401944493ecccd47f7b0714d0ab8f8/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040629-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df62f18ae1401944493ecccd47f7b0714d0ab8f8/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040629-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040629-1.c?ref=df62f18ae1401944493ecccd47f7b0714d0ab8f8", "patch": "@@ -0,0 +1,132 @@\n+/* Test arithmetics on bitfields.  */\n+#ifndef T\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+struct { unsigned int i : 6, j : 11, k : 15; } b;\n+struct { unsigned int i : 5, j : 1, k : 26; } c;\n+struct { unsigned int i : 16, j : 8, k : 8; } d;\n+\n+unsigned int ret1 (void) { return b.i; }\n+unsigned int ret2 (void) { return b.j; }\n+unsigned int ret3 (void) { return b.k; }\n+unsigned int ret4 (void) { return c.i; }\n+unsigned int ret5 (void) { return c.j; }\n+unsigned int ret6 (void) { return c.k; }\n+unsigned int ret7 (void) { return d.i; }\n+unsigned int ret8 (void) { return d.j; }\n+unsigned int ret9 (void) { return d.k; }\n+\n+#define T(n, pre, post, op) \t\t\t\t\t\\\n+void fn1_##n (unsigned int x) { pre b.i post; }\t\t\t\\\n+void fn2_##n (unsigned int x) { pre b.j post; }\t\t\t\\\n+void fn3_##n (unsigned int x) { pre b.k post; }\t\t\t\\\n+void fn4_##n (unsigned int x) { pre c.i post; }\t\t\t\\\n+void fn5_##n (unsigned int x) { pre c.j post; }\t\t\t\\\n+void fn6_##n (unsigned int x) { pre c.k post; }\t\t\t\\\n+void fn7_##n (unsigned int x) { pre d.i post; }\t\t\t\\\n+void fn8_##n (unsigned int x) { pre d.j post; }\t\t\t\\\n+void fn9_##n (unsigned int x) { pre d.k post; }\n+\n+#include \"20040629-1.c\"\n+#undef T\n+\n+#define FAIL(n, i) abort ()\n+\n+int\n+main (void)\n+{\n+#define T(n, pre, post, op)\t\t\t\t\t\\\n+  b.i = 51;\t\t\t\t\t\t\t\\\n+  b.j = 636;\t\t\t\t\t\t\t\\\n+  b.k = 31278;\t\t\t\t\t\t\t\\\n+  c.i = 21;\t\t\t\t\t\t\t\\\n+  c.j = 1;\t\t\t\t\t\t\t\\\n+  c.k = 33554432;\t\t\t\t\t\t\\\n+  d.i = 26812;\t\t\t\t\t\t\t\\\n+  d.j = 156;\t\t\t\t\t\t\t\\\n+  d.k = 187;\t\t\t\t\t\t\t\\\n+  fn1_##n (3);\t\t\t\t\t\t\t\\\n+  if (ret1 () != (op (51, 3) & ((1 << 6) - 1)))\t\t\t\\\n+    FAIL (n, 1);\t\t\t\t\t\t\\\n+  b.i = 51;\t\t\t\t\t\t\t\\\n+  fn2_##n (251);\t\t\t\t\t\t\\\n+  if (ret2 () != (op (636, 251) & ((1 << 11) - 1)))\t\t\\\n+    FAIL (n, 2);\t\t\t\t\t\t\\\n+  b.j = 636;\t\t\t\t\t\t\t\\\n+  fn3_##n (13279);\t\t\t\t\t\t\\\n+  if (ret3 () != (op (31278, 13279) & ((1 << 15) - 1)))\t\t\\\n+    FAIL (n, 3);\t\t\t\t\t\t\\\n+  b.j = 31278;\t\t\t\t\t\t\t\\\n+  fn4_##n (24);\t\t\t\t\t\t\t\\\n+  if (ret4 () != (op (21, 24) & ((1 << 5) - 1)))\t\t\\\n+    FAIL (n, 4);\t\t\t\t\t\t\\\n+  c.i = 21;\t\t\t\t\t\t\t\\\n+  fn5_##n (1);\t\t\t\t\t\t\t\\\n+  if (ret5 () != (op (1, 1) & ((1 << 1) - 1)))\t\t\t\\\n+    FAIL (n, 5);\t\t\t\t\t\t\\\n+  c.j = 1;\t\t\t\t\t\t\t\\\n+  fn6_##n (264151);\t\t\t\t\t\t\\\n+  if (ret6 () != (op (33554432, 264151) & ((1 << 26) - 1)))\t\\\n+    FAIL (n, 6);\t\t\t\t\t\t\\\n+  c.k = 33554432;\t\t\t\t\t\t\\\n+  fn7_##n (713);\t\t\t\t\t\t\\\n+  if (ret7 () != (op (26812, 713) & ((1 << 16) - 1)))\t\t\\\n+    FAIL (n, 7);\t\t\t\t\t\t\\\n+  d.i = 26812;\t\t\t\t\t\t\t\\\n+  fn8_##n (17);\t\t\t\t\t\t\t\\\n+  if (ret8 () != (op (156, 17) & ((1 << 8) - 1)))\t\t\\\n+    FAIL (n, 8);\t\t\t\t\t\t\\\n+  d.j = 156;\t\t\t\t\t\t\t\\\n+  fn9_##n (199);\t\t\t\t\t\t\\\n+  if (ret9 () != (op (187, 199) & ((1 << 8) - 1)))\t\t\\\n+    FAIL (n, 9);\t\t\t\t\t\t\\\n+  d.k = 187;\n+\n+#include \"20040629-1.c\"\n+#undef T\n+  return 0;\n+}\n+\n+#else\n+\n+#ifndef opadd\n+#define opadd(x, y) (x + y)\n+#define opsub(x, y) (x - y)\n+#define opinc(x, y) (x + 1)\n+#define opdec(x, y) (x - 1)\n+#define opand(x, y) (x & y)\n+#define opior(x, y) (x | y)\n+#define opxor(x, y) (x ^ y)\n+#define opdiv(x, y) (x / y)\n+#define oprem(x, y) (x % y)\n+#define opadd3(x, y) (x + 3)\n+#define opsub7(x, y) (x - 7)\n+#define opand21(x, y) (x & 21)\n+#define opior19(x, y) (x | 19)\n+#define opxor37(x, y) (x ^ 37)\n+#define opdiv17(x, y) (x / 17)\n+#define oprem19(x, y) (x % 19)\n+#endif\n+\n+T(1, , += x, opadd)\n+T(2, ++, , opinc)\n+T(3, , ++, opinc)\n+T(4, , -= x, opsub)\n+T(5, --, , opdec)\n+T(6, , --, opdec)\n+T(7, , &= x, opand)\n+T(8, , |= x, opior)\n+T(9, , ^= x, opxor)\n+T(a, , /= x, opdiv)\n+T(b, , %= x, oprem)\n+T(c, , += 3, opadd3)\n+T(d, , -= 7, opsub7)\n+T(e, , &= 21, opand21)\n+T(f, , |= 19, opior19)\n+T(g, , ^= 37, opxor37)\n+T(h, , /= 17, opdiv17)\n+T(i, , %= 19, oprem19)\n+\n+#endif"}]}