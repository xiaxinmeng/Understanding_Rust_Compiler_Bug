{"sha": "249b4eeef1fe30237acb4d8e1832243b39d61e7e", "node_id": "C_kwDOANBUbNoAKDI0OWI0ZWVlZjFmZTMwMjM3YWNiNGQ4ZTE4MzIyNDNiMzlkNjFlN2U", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-11-08T07:49:17Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-11-10T08:28:42Z"}, "message": "Extend is_cond_scalar_reduction to handle bit_and/bit_xor/bit_ior.\n\nThis will enable transformation like\n\n-  # sum1_50 = PHI <prephitmp_64(13), 0(4)>\n-  # sum2_52 = PHI <sum2_21(13), 0(4)>\n+  # sum1_50 = PHI <_87(13), 0(4)>\n+  # sum2_52 = PHI <_89(13), 0(4)>\n   # ivtmp_62 = PHI <ivtmp_61(13), 64(4)>\n   i.2_7 = (long unsigned int) i_49;\n   _8 = i.2_7 * 8;\n...\n   vec1_i_38 = vec1_29 >> _10;\n   vec2_i_39 = vec2_31 >> _10;\n   _11 = vec1_i_38 & 1;\n-  _63 = tmp_37 ^ sum1_50;\n-  prephitmp_64 = _11 == 0 ? sum1_50 : _63;\n+  _ifc__86 = _11 != 0 ? tmp_37 : 0;\n+  _87 = sum1_50 ^ _ifc__86;\n   _12 = vec2_i_39 & 1;\n:\n\nso that vectorizer won't failed due to\n\n  /* If this isn't a nested cycle or if the nested cycle reduction value\n     is used ouside of the inner loop we cannot handle uses of the reduction\n     value.  */\n  if (nlatch_def_loop_uses > 1 || nphi_def_loop_uses > 1)\n    {\n      if (dump_enabled_p ())\n\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n\t\t\t \"reduction used in loop.\\n\");\n      return NULL;\n    }\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/103126\n\t* tree-vect-loop.c (neutral_op_for_reduction): Remove static.\n\t* tree-vectorizer.h (neutral_op_for_reduction): Declare.\n\t* tree-if-conv.c : Include tree-vectorizer.h.\n\t(is_cond_scalar_reduction): Handle\n\tBIT_XOR_EXPR/BIT_IOR_EXPR/BIT_AND_EXPR.\n\t(convert_scalar_cond_reduction): Ditto.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/i386/ifcvt-reduction-logic-op.c: New test.", "tree": {"sha": "c4bb6d262e576119cbff86e719102636d21cf992", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4bb6d262e576119cbff86e719102636d21cf992"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/249b4eeef1fe30237acb4d8e1832243b39d61e7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/249b4eeef1fe30237acb4d8e1832243b39d61e7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/249b4eeef1fe30237acb4d8e1832243b39d61e7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/249b4eeef1fe30237acb4d8e1832243b39d61e7e/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2572a398d21fd52435c94065c0651fd79db847c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2572a398d21fd52435c94065c0651fd79db847c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2572a398d21fd52435c94065c0651fd79db847c"}], "stats": {"total": 103, "additions": 95, "deletions": 8}, "files": [{"sha": "eeb822d5d43409d3e49b327e133ca68834aceaab", "filename": "gcc/testsuite/gcc.target/i386/ifcvt-reduction-logic-op.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/249b4eeef1fe30237acb4d8e1832243b39d61e7e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fifcvt-reduction-logic-op.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/249b4eeef1fe30237acb4d8e1832243b39d61e7e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fifcvt-reduction-logic-op.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fifcvt-reduction-logic-op.c?ref=249b4eeef1fe30237acb4d8e1832243b39d61e7e", "patch": "@@ -0,0 +1,80 @@\n+/* PR tree-optimization/103126.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Ofast -mavx2 -ftree-vectorize -fdump-tree-vect-details\" } */\n+/* { dg-final { scan-tree-dump-times \"vectorized \\[1-3] loops\" 3 \"vect\" } } */\n+#include<stdint.h>\n+\n+void xor_bit_arr_nolcd (uint64_t *__restrict mat, uint64_t* a,uint64_t* b, uint64_t *__restrict ans,\n+    int64_t n)\n+{\n+  int64_t i;\n+  uint64_t vec1, sum1;\n+  uint64_t vec2, sum2;\n+\n+  while (n > 0) {\n+    sum1 = 0;\n+    vec1 = a[n];\n+    sum2 = 0;\n+    vec2 = b[n];\n+\n+    for (i = 0; i < 64; i++) {\n+      uint64_t tmp = mat[i];\n+      uint64_t vec1_i = (vec1 >> i);\n+      uint64_t vec2_i = (vec2 >> i);\n+      sum1 ^= (vec1_i & 1) ? tmp : 0;\n+      if (vec2_i&1) sum2 ^= tmp;\n+    }\n+    *ans++ ^= sum1;  n--;\n+    *ans++ ^= sum2;  n--;\n+  }\n+}\n+\n+void ior_bit_arr_nolcd (uint64_t *__restrict mat, uint64_t* a,uint64_t* b, uint64_t *__restrict ans,\n+    int64_t n)\n+{\n+  int64_t i;\n+  uint64_t vec1, sum1;\n+  uint64_t vec2, sum2;\n+\n+  while (n > 0) {\n+    sum1 = 0;\n+    vec1 = a[n];\n+    sum2 = 0;\n+    vec2 = b[n];\n+\n+    for (i = 0; i < 64; i++) {\n+      uint64_t tmp = mat[i];\n+      uint64_t vec1_i = (vec1 >> i);\n+      uint64_t vec2_i = (vec2 >> i);\n+      sum1 |= (vec1_i & 1) ? tmp : 0;\n+      if (vec2_i&1) sum2 |= tmp;\n+    }\n+    *ans++ |= sum1;  n--;\n+    *ans++ |= sum2;  n--;\n+  }\n+}\n+\n+void and_bit_arr_nolcd (uint64_t *__restrict mat, uint64_t* a,uint64_t* b, uint64_t *__restrict ans,\n+    int64_t n)\n+{\n+  int64_t i;\n+  uint64_t vec1, sum1;\n+  uint64_t vec2, sum2;\n+\n+  while (n > 0) {\n+    sum1 = -1;\n+    vec1 = a[n];\n+    sum2 = 0;\n+    vec2 = b[n];\n+\n+    for (i = 0; i < 64; i++) {\n+      uint64_t tmp = mat[i];\n+      uint64_t vec1_i = (vec1 >> i);\n+      uint64_t vec2_i = (vec2 >> i);\n+      sum1 &= (vec1_i & 1) ? tmp : -1;\n+      if (vec2_i&1) sum2 &= tmp;\n+    }\n+    *ans++ &= sum1;  n--;\n+    *ans++ &= sum2;  n--;\n+  }\n+}"}, {"sha": "e88ddc9f7882abbbb60a84761ce597324a0c7c4f", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/249b4eeef1fe30237acb4d8e1832243b39d61e7e/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/249b4eeef1fe30237acb4d8e1832243b39d61e7e/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=249b4eeef1fe30237acb4d8e1832243b39d61e7e", "patch": "@@ -120,6 +120,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-sccvn.h\"\n #include \"tree-cfgcleanup.h\"\n #include \"tree-ssa-dse.h\"\n+#include \"tree-vectorizer.h\"\n \n /* Only handle PHIs with no more arguments unless we are asked to by\n    simd pragma.  */\n@@ -1732,7 +1733,11 @@ is_cond_scalar_reduction (gimple *phi, gimple **reduc, tree arg_0, tree arg_1,\n       reduction_op = gimple_assign_rhs_code (stmt);\n     }\n \n-  if (reduction_op != PLUS_EXPR && reduction_op != MINUS_EXPR)\n+  if (reduction_op != PLUS_EXPR\n+      && reduction_op != MINUS_EXPR\n+      && reduction_op != BIT_IOR_EXPR\n+      && reduction_op != BIT_XOR_EXPR\n+      && reduction_op != BIT_AND_EXPR)\n     return false;\n   r_op1 = gimple_assign_rhs1 (stmt);\n   r_op2 = gimple_assign_rhs2 (stmt);\n@@ -1742,7 +1747,7 @@ is_cond_scalar_reduction (gimple *phi, gimple **reduc, tree arg_0, tree arg_1,\n \n   /* Make R_OP1 to hold reduction variable.  */\n   if (r_nop2 == PHI_RESULT (header_phi)\n-      && reduction_op == PLUS_EXPR)\n+      && commutative_tree_code (reduction_op))\n     {\n       std::swap (r_op1, r_op2);\n       std::swap (r_nop1, r_nop2);\n@@ -1811,7 +1816,8 @@ convert_scalar_cond_reduction (gimple *reduc, gimple_stmt_iterator *gsi,\n   tree rhs1 = gimple_assign_rhs1 (reduc);\n   tree tmp = make_temp_ssa_name (TREE_TYPE (rhs1), NULL, \"_ifc_\");\n   tree c;\n-  tree zero = build_zero_cst (TREE_TYPE (rhs1));\n+  enum tree_code reduction_op  = gimple_assign_rhs_code (reduc);\n+  tree op_nochange = neutral_op_for_reduction (TREE_TYPE (rhs1), reduction_op, NULL);\n   gimple_seq stmts = NULL;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1824,14 +1830,14 @@ convert_scalar_cond_reduction (gimple *reduc, gimple_stmt_iterator *gsi,\n      of reduction rhs.  */\n   c = fold_build_cond_expr (TREE_TYPE (rhs1),\n \t\t\t    unshare_expr (cond),\n-\t\t\t    swap ? zero : op1,\n-\t\t\t    swap ? op1 : zero);\n+\t\t\t    swap ? op_nochange : op1,\n+\t\t\t    swap ? op1 : op_nochange);\n \n   /* Create assignment stmt and insert it at GSI.  */\n   new_assign = gimple_build_assign (tmp, c);\n   gsi_insert_before (gsi, new_assign, GSI_SAME_STMT);\n-  /* Build rhs for unconditional increment/decrement.  */\n-  rhs = gimple_build (&stmts, gimple_assign_rhs_code (reduc),\n+  /* Build rhs for unconditional increment/decrement/logic_operation.  */\n+  rhs = gimple_build (&stmts, reduction_op,\n \t\t      TREE_TYPE (rhs1), op0, tmp);\n \n   if (has_nop)"}, {"sha": "fa4cf88ce51302f6dcf87d92a139c4006d73ebba", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/249b4eeef1fe30237acb4d8e1832243b39d61e7e/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/249b4eeef1fe30237acb4d8e1832243b39d61e7e/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=249b4eeef1fe30237acb4d8e1832243b39d61e7e", "patch": "@@ -3330,7 +3330,7 @@ reduction_fn_for_scalar_code (enum tree_code code, internal_fn *reduc_fn)\n    of the scalar elements.  If the reduction has just a single initial value\n    then INITIAL_VALUE is that value, otherwise it is null.  */\n \n-static tree\n+tree\n neutral_op_for_reduction (tree scalar_type, tree_code code, tree initial_value)\n {\n   switch (code)"}, {"sha": "51ab21896aa8c011e34d65c864c984e81f1de801", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/249b4eeef1fe30237acb4d8e1832243b39d61e7e/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/249b4eeef1fe30237acb4d8e1832243b39d61e7e/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=249b4eeef1fe30237acb4d8e1832243b39d61e7e", "patch": "@@ -2120,6 +2120,7 @@ extern tree vect_create_addr_base_for_vector_ref (vec_info *,\n \t\t\t\t\t\t  tree);\n \n /* In tree-vect-loop.c.  */\n+extern tree neutral_op_for_reduction (tree, tree_code, tree);\n extern widest_int vect_iv_limit_for_partial_vectors (loop_vec_info loop_vinfo);\n bool vect_rgroup_iv_might_wrap_p (loop_vec_info, rgroup_controls *);\n /* Used in tree-vect-loop-manip.c */"}]}