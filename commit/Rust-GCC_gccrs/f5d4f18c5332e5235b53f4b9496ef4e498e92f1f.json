{"sha": "f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVkNGYxOGM1MzMyZTUyMzViNTNmNGI5NDk2ZWY0ZTQ5OGU5MmYxZg==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2013-12-11T16:50:05Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2013-12-11T16:50:05Z"}, "message": "re PR middle-end/23623 (volatile keyword changes bitfield access size from 32bit to 8bit)\n\n2013-12-11  Sandra Loosemore  <sandra@codesourcery.com>\n\n        PR middle-end/23623\n        PR middle-end/48784\n        PR middle-end/56341\n        PR middle-end/56997\n\n        gcc/\n        * expmed.c (strict_volatile_bitfield_p): New function.\n        (store_bit_field_1): Don't special-case strict volatile\n        bitfields here.\n        (store_bit_field): Handle strict volatile bitfields here instead.\n        (store_fixed_bit_field): Don't special-case strict volatile\n        bitfields here.\n        (extract_bit_field_1): Don't special-case strict volatile\n        bitfields here.\n        (extract_bit_field): Handle strict volatile bitfields here instead.\n        (extract_fixed_bit_field): Don't special-case strict volatile\n        bitfields here.  Simplify surrounding code to resemble that in\n        store_fixed_bit_field.\n        * doc/invoke.texi (Code Gen Options): Update\n        -fstrict-volatile-bitfields description.\n\n        gcc/testsuite/\n        * gcc.dg/pr23623.c: New test.\n        * gcc.dg/pr48784-1.c: New test.\n        * gcc.dg/pr48784-2.c: New test.\n        * gcc.dg/pr56341-1.c: New test.\n        * gcc.dg/pr56341-2.c: New test.\n        * gcc.dg/pr56997-1.c: New test.\n        * gcc.dg/pr56997-2.c: New test.\n        * gcc.dg/pr56997-3.c: New test.\n\nFrom-SVN: r205896", "tree": {"sha": "1adfbe0c18fd93a2d8326c0ccef386d4e2b54fed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1adfbe0c18fd93a2d8326c0ccef386d4e2b54fed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2ccd6f727633d25730154efd7094900d24bf6544", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ccd6f727633d25730154efd7094900d24bf6544", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ccd6f727633d25730154efd7094900d24bf6544"}], "stats": {"total": 510, "additions": 432, "deletions": 78}, "files": [{"sha": "3234542f92930aa0695b5db600246af839ac3db8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "patch": "@@ -1,3 +1,24 @@\n+2013-12-11  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR middle-end/23623\n+\tPR middle-end/48784\n+\tPR middle-end/56341\n+\tPR middle-end/56997\n+\t* expmed.c (strict_volatile_bitfield_p): New function.\n+\t(store_bit_field_1): Don't special-case strict volatile\n+\tbitfields here.\n+\t(store_bit_field): Handle strict volatile bitfields here instead.\n+\t(store_fixed_bit_field): Don't special-case strict volatile\n+\tbitfields here.\n+\t(extract_bit_field_1): Don't special-case strict volatile\n+\tbitfields here.\n+\t(extract_bit_field): Handle strict volatile bitfields here instead.\n+\t(extract_fixed_bit_field): Don't special-case strict volatile\n+\tbitfields here.  Simplify surrounding code to resemble that in\n+\tstore_fixed_bit_field.\n+\t* doc/invoke.texi (Code Gen Options): Update\n+\t-fstrict-volatile-bitfields description.\n+\n 2013-12-11  Kugan Vivekanandarajah  <kuganv@linaro.org>\n \n \t* configure.ac: Add check for aarch64 assembler -mabi support."}, {"sha": "b655a6411b1b16568cd7ae5c84813f81dbefdbd4", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "patch": "@@ -22001,6 +22001,12 @@ instruction, even though that accesses bytes that do not contain\n any portion of the bit-field, or memory-mapped registers unrelated to\n the one being updated.\n \n+In some cases, such as when the @code{packed} attribute is applied to a \n+structure field, it may not be possible to access the field with a single\n+read or write that is correctly aligned for the target machine.  In this\n+case GCC falls back to generating multiple accesses rather than code that \n+will fault or truncate the result at run time.\n+\n The default value of this option is determined by the application binary\n interface for the target processor.\n "}, {"sha": "185e66b6b822468ebd68e9f53c3f87b44e05be88", "filename": "gcc/expmed.c", "status": "modified", "additions": 97, "deletions": 78, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "patch": "@@ -416,6 +416,42 @@ lowpart_bit_field_p (unsigned HOST_WIDE_INT bitnum,\n     return bitnum % BITS_PER_WORD == 0;\n }\n \n+/* Return true if -fstrict-volatile-bitfields applies an access of OP0\n+   containing BITSIZE bits starting at BITNUM, with field mode FIELDMODE.  */\n+\n+static bool\n+strict_volatile_bitfield_p (rtx op0, unsigned HOST_WIDE_INT bitsize,\n+\t\t\t    unsigned HOST_WIDE_INT bitnum,\n+\t\t\t    enum machine_mode fieldmode)\n+{\n+  unsigned HOST_WIDE_INT modesize = GET_MODE_BITSIZE (fieldmode);\n+\n+  /* -fstrict-volatile-bitfields must be enabled and we must have a\n+     volatile MEM.  */\n+  if (!MEM_P (op0)\n+      || !MEM_VOLATILE_P (op0)\n+      || flag_strict_volatile_bitfields <= 0)\n+    return false;\n+\n+  /* Non-integral modes likely only happen with packed structures.\n+     Punt.  */\n+  if (!SCALAR_INT_MODE_P (fieldmode))\n+    return false;\n+\n+  /* The bit size must not be larger than the field mode, and\n+     the field mode must not be larger than a word.  */\n+  if (bitsize > modesize || modesize > BITS_PER_WORD)\n+    return false;\n+\n+  /* Check for cases of unaligned fields that must be split.  */\n+  if (bitnum % BITS_PER_UNIT + bitsize > modesize\n+      || (STRICT_ALIGNMENT\n+\t  && bitnum % GET_MODE_ALIGNMENT (fieldmode) + bitsize > modesize))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Return true if OP is a memory and if a bitfield of size BITSIZE at\n    bit number BITNUM can be treated as a simple value of mode MODE.  */\n \n@@ -829,12 +865,8 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      cheap register alternative is available.  */\n   if (MEM_P (op0))\n     {\n-      /* Do not use unaligned memory insvs for volatile bitfields when\n-\t -fstrict-volatile-bitfields is in effect.  */\n-      if (!(MEM_VOLATILE_P (op0)\n-\t    && flag_strict_volatile_bitfields > 0)\n-\t  && get_best_mem_extraction_insn (&insv, EP_insv, bitsize, bitnum,\n-\t\t\t\t\t   fieldmode)\n+      if (get_best_mem_extraction_insn (&insv, EP_insv, bitsize, bitnum,\n+\t\t\t\t\tfieldmode)\n \t  && store_bit_field_using_insv (&insv, op0, bitsize, bitnum, value))\n \treturn true;\n \n@@ -887,6 +919,27 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t enum machine_mode fieldmode,\n \t\t rtx value)\n {\n+  /* Handle -fstrict-volatile-bitfields in the cases where it applies.  */\n+  if (strict_volatile_bitfield_p (str_rtx, bitsize, bitnum, fieldmode))\n+    {\n+\n+      /* Storing any naturally aligned field can be done with a simple\n+\t store.  For targets that support fast unaligned memory, any\n+\t naturally sized, unit aligned field can be done directly.  */\n+      if (simple_mem_bitfield_p (str_rtx, bitsize, bitnum, fieldmode))\n+\t{\n+\t  str_rtx = adjust_bitfield_address (str_rtx, fieldmode,\n+\t\t\t\t\t     bitnum / BITS_PER_UNIT);\n+\t  emit_move_insn (str_rtx, value);\n+\t}\n+      else\n+\t/* Explicitly override the C/C++ memory model; ignore the\n+\t   bit range so that we can do the access in the mode mandated\n+\t   by -fstrict-volatile-bitfields instead.  */\n+\tstore_fixed_bit_field (str_rtx, bitsize, bitnum, 0, 0, value);\n+      return;\n+    }\n+\n   /* Under the C++0x memory model, we must not touch bits outside the\n      bit region.  Adjust the address to start at the beginning of the\n      bit region.  */\n@@ -939,29 +992,12 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \n   if (MEM_P (op0))\n     {\n-      unsigned HOST_WIDE_INT maxbits = MAX_FIXED_MODE_SIZE;\n-\n-      if (bitregion_end)\n-\tmaxbits = bitregion_end - bitregion_start + 1;\n-\n-      /* Get the proper mode to use for this field.  We want a mode that\n-\t includes the entire field.  If such a mode would be larger than\n-\t a word, we won't be doing the extraction the normal way.\n-\t We don't want a mode bigger than the destination.  */\n-\n       mode = GET_MODE (op0);\n       if (GET_MODE_BITSIZE (mode) == 0\n \t  || GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (word_mode))\n \tmode = word_mode;\n-\n-      if (MEM_VOLATILE_P (op0)\n-          && GET_MODE_BITSIZE (GET_MODE (op0)) > 0\n-\t  && GET_MODE_BITSIZE (GET_MODE (op0)) <= maxbits\n-\t  && flag_strict_volatile_bitfields > 0)\n-\tmode = GET_MODE (op0);\n-      else\n-\tmode = get_best_mode (bitsize, bitnum, bitregion_start, bitregion_end,\n-\t\t\t      MEM_ALIGN (op0), mode, MEM_VOLATILE_P (op0));\n+      mode = get_best_mode (bitsize, bitnum, bitregion_start, bitregion_end,\n+\t\t\t    MEM_ALIGN (op0), mode, MEM_VOLATILE_P (op0));\n \n       if (mode == VOIDmode)\n \t{\n@@ -1445,19 +1481,8 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      If that's wrong, the solution is to test for it and set TARGET to 0\n      if needed.  */\n \n-  /* If the bitfield is volatile, we need to make sure the access\n-     remains on a type-aligned boundary.  */\n-  if (GET_CODE (op0) == MEM\n-      && MEM_VOLATILE_P (op0)\n-      && GET_MODE_BITSIZE (GET_MODE (op0)) > 0\n-      && flag_strict_volatile_bitfields > 0)\n-    goto no_subreg_mode_swap;\n-\n-  /* Only scalar integer modes can be converted via subregs.  There is an\n-     additional problem for FP modes here in that they can have a precision\n-     which is different from the size.  mode_for_size uses precision, but\n-     we want a mode based on the size, so we must avoid calling it for FP\n-     modes.  */\n+  /* Get the mode of the field to use for atomic access or subreg\n+     conversion.  */\n   mode1 = mode;\n   if (SCALAR_INT_MODE_P (tmode))\n     {\n@@ -1490,8 +1515,6 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       return convert_extracted_bit_field (op0, mode, tmode, unsignedp);\n     }\n \n- no_subreg_mode_swap:\n-\n   /* Handle fields bigger than a word.  */\n \n   if (bitsize > BITS_PER_WORD)\n@@ -1611,11 +1634,8 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      cheap register alternative is available.  */\n   if (MEM_P (op0))\n     {\n-      /* Do not use extv/extzv for volatile bitfields when\n-         -fstrict-volatile-bitfields is in effect.  */\n-      if (!(MEM_VOLATILE_P (op0) && flag_strict_volatile_bitfields > 0)\n-\t  && get_best_mem_extraction_insn (&extv, pattern, bitsize, bitnum,\n-\t\t\t\t\t   tmode))\n+      if (get_best_mem_extraction_insn (&extv, pattern, bitsize, bitnum,\n+\t\t\t\t\ttmode))\n \t{\n \t  rtx result = extract_bit_field_using_extv (&extv, op0, bitsize,\n \t\t\t\t\t\t     bitnum, unsignedp,\n@@ -1681,6 +1701,31 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t   unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n \t\t   enum machine_mode mode, enum machine_mode tmode)\n {\n+  enum machine_mode mode1;\n+\n+  /* Handle -fstrict-volatile-bitfields in the cases where it applies.  */\n+  if (GET_MODE_BITSIZE (GET_MODE (str_rtx)) > 0)\n+    mode1 = GET_MODE (str_rtx);\n+  else if (target && GET_MODE_BITSIZE (GET_MODE (target)) > 0)\n+    mode1 = GET_MODE (target);\n+  else\n+    mode1 = tmode;\n+\n+  if (strict_volatile_bitfield_p (str_rtx, bitsize, bitnum, mode1))\n+    {\n+      rtx result;\n+\n+      /* Extraction of a full MODE1 value can be done with a load as long as\n+\t the field is on a byte boundary and is sufficiently aligned.  */\n+      if (simple_mem_bitfield_p (str_rtx, bitsize, bitnum, mode1))\n+\tresult = adjust_bitfield_address (str_rtx, mode1,\n+\t\t\t\t\t  bitnum / BITS_PER_UNIT);\n+      else\n+\tresult = extract_fixed_bit_field (mode, str_rtx, bitsize, bitnum,\n+\t\t\t\t\t  target, unsignedp);\n+      return convert_extracted_bit_field (result, mode, tmode, unsignedp);\n+    }\n+  \n   return extract_bit_field_1 (str_rtx, bitsize, bitnum, unsignedp,\n \t\t\t      target, mode, tmode, true);\n }\n@@ -1707,45 +1752,19 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \t includes the entire field.  If such a mode would be larger than\n \t a word, we won't be doing the extraction the normal way.  */\n \n-      if (MEM_VOLATILE_P (op0)\n-\t  && flag_strict_volatile_bitfields > 0)\n-\t{\n-\t  if (GET_MODE_BITSIZE (GET_MODE (op0)) > 0)\n-\t    mode = GET_MODE (op0);\n-\t  else if (target && GET_MODE_BITSIZE (GET_MODE (target)) > 0)\n-\t    mode = GET_MODE (target);\n-\t  else\n-\t    mode = tmode;\n-\t}\n-      else\n-\tmode = get_best_mode (bitsize, bitnum, 0, 0,\n-\t\t\t      MEM_ALIGN (op0), word_mode, MEM_VOLATILE_P (op0));\n+      mode = GET_MODE (op0);\n+      if (GET_MODE_BITSIZE (mode) == 0\n+\t  || GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (word_mode))\n+\tmode = word_mode;\n+      mode = get_best_mode (bitsize, bitnum, 0, 0,\n+\t\t\t    MEM_ALIGN (op0), mode, MEM_VOLATILE_P (op0));\n \n       if (mode == VOIDmode)\n \t/* The only way this should occur is if the field spans word\n \t   boundaries.  */\n \treturn extract_split_bit_field (op0, bitsize, bitnum, unsignedp);\n \n-      unsigned int total_bits = GET_MODE_BITSIZE (mode);\n-      HOST_WIDE_INT bit_offset = bitnum - bitnum % total_bits;\n-\n-      /* If we're accessing a volatile MEM, we can't apply BIT_OFFSET\n-\t if it results in a multi-word access where we otherwise wouldn't\n-\t have one.  So, check for that case here.  */\n-      if (MEM_P (op0)\n-\t  && MEM_VOLATILE_P (op0)\n-\t  && flag_strict_volatile_bitfields > 0\n-\t  && bitnum % BITS_PER_UNIT + bitsize <= total_bits\n-\t  && bitnum % GET_MODE_BITSIZE (mode) + bitsize > total_bits)\n-\t{\n-\t  /* If the target doesn't support unaligned access, give up and\n-\t     split the access into two.  */\n-\t  if (STRICT_ALIGNMENT)\n-\t    return extract_split_bit_field (op0, bitsize, bitnum, unsignedp);\n-\t  bit_offset = bitnum - bitnum % BITS_PER_UNIT;\n-\t}\n-      op0 = adjust_bitfield_address (op0, mode, bit_offset / BITS_PER_UNIT);\n-      bitnum -= bit_offset;\n+      op0 = narrow_bit_field_mem (op0, mode, bitsize, bitnum, &bitnum);\n     }\n \n   mode = GET_MODE (op0);"}, {"sha": "ac0b5fb1add1ff4ebf3b7d47911641f49ce3e25a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "patch": "@@ -1,3 +1,18 @@\n+2013-12-11  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR middle-end/23623\n+\tPR middle-end/48784\n+\tPR middle-end/56341\n+\tPR middle-end/56997\n+\t* gcc.dg/pr23623.c: New test.\n+\t* gcc.dg/pr48784-1.c: New test.\n+\t* gcc.dg/pr48784-2.c: New test.\n+\t* gcc.dg/pr56341-1.c: New test.\n+\t* gcc.dg/pr56341-2.c: New test.\n+\t* gcc.dg/pr56997-1.c: New test.\n+\t* gcc.dg/pr56997-2.c: New test.\n+\t* gcc.dg/pr56997-3.c: New test.\n+\n 2013-12-11  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/58916"}, {"sha": "22da21d489b1b8cc0dcee712dc3028400f3b57a1", "filename": "gcc/testsuite/gcc.dg/pr23623.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr23623.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr23623.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr23623.c?ref=f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-volatile-bitfields -fdump-rtl-final\" } */\n+\n+/* With -fstrict-volatile-bitfields, the volatile accesses to bf2.b\n+   and bf3.b must do unsigned int reads/writes.  The non-volatile\n+   accesses to bf1.b are not so constrained.  */\n+\n+extern struct\n+{\n+  unsigned int b : 1;\n+} bf1;\n+\n+extern volatile struct\n+{\n+  unsigned int b : 1;\n+} bf2;\n+\n+extern struct\n+{\n+  volatile unsigned int b : 1;\n+} bf3;\n+\n+void writeb(void)\n+{\n+  bf1.b = 1;\n+  bf2.b = 1;\t/* volatile read + volatile write */\n+  bf3.b = 1;\t/* volatile read + volatile write */\n+}\n+\n+extern unsigned int x1, x2, x3;\n+\n+void readb(void)\n+{\n+  x1 = bf1.b;\n+  x2 = bf2.b;   /* volatile write */\n+  x3 = bf3.b;   /* volatile write */\n+}\n+\n+/* There should be 6 volatile MEMs total, but scan-rtl-dump-times counts\n+   the number of match variables and not the number of matches.  Since\n+   the parenthesized subexpression in the regexp introduces an extra match\n+   variable, we need to give a count of 12 instead of 6 here.  */\n+/* { dg-final { scan-rtl-dump-times \"mem/v(/.)*:SI\" 12 \"final\" } } */\n+/* { dg-final { cleanup-rtl-dump \"final\" } } */\n+"}, {"sha": "bbcad9b18ed3bb411399fb017d1855d5e8addba0", "filename": "gcc/testsuite/gcc.dg/pr48784-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr48784-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr48784-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr48784-1.c?ref=f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fstrict-volatile-bitfields\" } */\n+\n+extern void abort (void);\n+\n+#pragma pack(1)\n+volatile struct S0 {\n+   signed a : 7;\n+   unsigned b : 28;  /* b can't be fetched with an aligned 32-bit access, */\n+                     /* but it certainly can be fetched with an unaligned access */\n+} g = {0,0xfffffff};\n+\n+int main() {\n+  unsigned b = g.b;\n+  if (b != 0xfffffff)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "6d53263129413b2bf75c5376d9e2bae1fa3af835", "filename": "gcc/testsuite/gcc.dg/pr48784-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr48784-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr48784-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr48784-2.c?ref=f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fno-strict-volatile-bitfields\" } */\n+\n+extern void abort (void);\n+\n+#pragma pack(1)\n+volatile struct S0 {\n+   signed a : 7;\n+   unsigned b : 28;  /* b can't be fetched with an aligned 32-bit access, */\n+                     /* but it certainly can be fetched with an unaligned access */\n+} g = {0,0xfffffff};\n+\n+int main() {\n+  unsigned b = g.b;\n+  if (b != 0xfffffff)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "91cf80ba286d17ddce6dc3b4492de0fe0a76a0da", "filename": "gcc/testsuite/gcc.dg/pr56341-1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56341-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56341-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56341-1.c?ref=f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fstrict-volatile-bitfields\" } */\n+\n+extern void abort (void);\n+\n+struct test0\n+{\n+  unsigned char b1[2];\n+} __attribute__((packed, aligned(2)));\n+\n+struct test1\n+{\n+  volatile unsigned long a1;\n+  unsigned char b1[4];\n+} __attribute__((packed, aligned(2)));\n+\n+struct test2\n+{\n+  struct test0 t0;\n+  struct test1 t1;\n+  struct test0 t2;\n+} __attribute__((packed, aligned(2)));\n+\n+struct test2 xx;\n+struct test2 *x1 = &xx;\n+\n+#define MAGIC 0x12345678\n+\n+void test0 (struct test2* x1)\n+{\n+  x1->t1.a1 = MAGIC;\n+}\n+\n+int main()\n+{\n+  test0 (x1);\n+  if (xx.t1.a1 != MAGIC)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "e6f6569f08965827e9ba219f774ae149a6a65493", "filename": "gcc/testsuite/gcc.dg/pr56341-2.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56341-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56341-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56341-2.c?ref=f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fno-strict-volatile-bitfields\" } */\n+\n+extern void abort (void);\n+\n+struct test0\n+{\n+  unsigned char b1[2];\n+} __attribute__((packed, aligned(2)));\n+\n+struct test1\n+{\n+  volatile unsigned long a1;\n+  unsigned char b1[4];\n+} __attribute__((packed, aligned(2)));\n+\n+struct test2\n+{\n+  struct test0 t0;\n+  struct test1 t1;\n+  struct test0 t2;\n+} __attribute__((packed, aligned(2)));\n+\n+struct test2 xx;\n+struct test2 *x1 = &xx;\n+\n+#define MAGIC 0x12345678\n+\n+void test0 (struct test2* x1)\n+{\n+  x1->t1.a1 = MAGIC;\n+}\n+\n+int main()\n+{\n+  test0 (x1);\n+  if (xx.t1.a1 != MAGIC)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "42458a106c6a13de55d445e5a50f50f3c30ae646", "filename": "gcc/testsuite/gcc.dg/pr56997-1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56997-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56997-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56997-1.c?ref=f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "patch": "@@ -0,0 +1,44 @@\n+/* Test volatile access to unaligned field.  */\n+/* { dg-do run } */\n+/* { dg-options \"-fstrict-volatile-bitfields\" } */\n+\n+extern void abort (void);\n+\n+#define test_type unsigned short\n+#define MAGIC (unsigned short)0x102u\n+\n+typedef struct s{\n+ unsigned char Prefix;\n+ test_type Type;\n+}__attribute((__packed__)) ss;\n+\n+volatile ss v;\n+ss g;\n+\n+void __attribute__((noinline))\n+foo (test_type u)\n+{\n+  v.Type = u;\n+}\n+\n+test_type __attribute__((noinline))\n+bar (void)\n+{\n+  return v.Type;\n+}\n+\n+int main()\n+{\n+  test_type temp;\n+  foo(MAGIC);\n+  __builtin_memcpy(&g, (void *)&v, sizeof(g));\n+  if (g.Type != MAGIC)\n+    abort ();\n+\n+  g.Type = MAGIC;\n+  __builtin_memcpy((void *)&v, &g, sizeof(v));\n+  temp = bar();\n+  if (temp != MAGIC)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "08e631180f15d6124c6ca8f371f4c454507468d2", "filename": "gcc/testsuite/gcc.dg/pr56997-2.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56997-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56997-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56997-2.c?ref=f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "patch": "@@ -0,0 +1,44 @@\n+/* Test volatile access to unaligned field.  */\n+/* { dg-do run } */\n+/* { dg-options \"-fstrict-volatile-bitfields\" } */\n+\n+extern void abort (void);\n+\n+#define test_type unsigned int\n+#define MAGIC 0x1020304u\n+\n+typedef struct s{\n+ unsigned char Prefix;\n+ test_type Type;\n+}__attribute((__packed__)) ss;\n+\n+volatile ss v;\n+ss g;\n+\n+void __attribute__((noinline))\n+foo (test_type u)\n+{\n+  v.Type = u;\n+}\n+\n+test_type __attribute__((noinline))\n+bar (void)\n+{\n+  return v.Type;\n+}\n+\n+int main()\n+{\n+  test_type temp;\n+  foo(MAGIC);\n+  __builtin_memcpy(&g, (void *)&v, sizeof(g));\n+  if (g.Type != MAGIC)\n+    abort ();\n+\n+  g.Type = MAGIC;\n+  __builtin_memcpy((void *)&v, &g, sizeof(v));\n+  temp = bar();\n+  if (temp != MAGIC)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "3754b108ac660cd581c47756aa657fa5a84ec8d5", "filename": "gcc/testsuite/gcc.dg/pr56997-3.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56997-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d4f18c5332e5235b53f4b9496ef4e498e92f1f/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56997-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr56997-3.c?ref=f5d4f18c5332e5235b53f4b9496ef4e498e92f1f", "patch": "@@ -0,0 +1,44 @@\n+/* Test volatile access to unaligned field.  */\n+/* { dg-do run } */\n+/* { dg-options \"-fstrict-volatile-bitfields\" } */\n+\n+extern void abort (void);\n+\n+#define test_type unsigned long long\n+#define MAGIC 0x102030405060708ull\n+\n+typedef struct s{\n+ unsigned char Prefix;\n+ test_type Type;\n+}__attribute((__packed__)) ss;\n+\n+volatile ss v;\n+ss g;\n+\n+void __attribute__((noinline))\n+foo (test_type u)\n+{\n+  v.Type = u;\n+}\n+\n+test_type __attribute__((noinline))\n+bar (void)\n+{\n+  return v.Type;\n+}\n+\n+int main()\n+{\n+  test_type temp;\n+  foo(MAGIC);\n+  __builtin_memcpy(&g, (void *)&v, sizeof(g));\n+  if (g.Type != MAGIC)\n+    abort ();\n+\n+  g.Type = MAGIC;\n+  __builtin_memcpy((void *)&v, &g, sizeof(v));\n+  temp = bar();\n+  if (temp != MAGIC)\n+    abort ();\n+  return 0;\n+}"}]}