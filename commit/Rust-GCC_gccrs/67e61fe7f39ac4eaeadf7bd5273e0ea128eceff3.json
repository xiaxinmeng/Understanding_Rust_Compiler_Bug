{"sha": "67e61fe7f39ac4eaeadf7bd5273e0ea128eceff3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdlNjFmZTdmMzlhYzRlYWVhZGY3YmQ1MjczZTBlYTEyOGVjZWZmMw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-10-26T13:45:31Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-10-26T13:45:31Z"}, "message": "Small reload cleanups\n\nFrom-SVN: r30193", "tree": {"sha": "9a8d29cde52555b6c55f9c36702c2bb7ae5a8ff9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a8d29cde52555b6c55f9c36702c2bb7ae5a8ff9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67e61fe7f39ac4eaeadf7bd5273e0ea128eceff3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67e61fe7f39ac4eaeadf7bd5273e0ea128eceff3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67e61fe7f39ac4eaeadf7bd5273e0ea128eceff3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67e61fe7f39ac4eaeadf7bd5273e0ea128eceff3/comments", "author": null, "committer": null, "parents": [{"sha": "35f86a5003f8b9d53a201fcc7ba29de360d2a772", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35f86a5003f8b9d53a201fcc7ba29de360d2a772", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35f86a5003f8b9d53a201fcc7ba29de360d2a772"}], "stats": {"total": 374, "additions": 153, "deletions": 221}, "files": [{"sha": "8351057a0713bb90dd9d597f2cdd60532db2af78", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67e61fe7f39ac4eaeadf7bd5273e0ea128eceff3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67e61fe7f39ac4eaeadf7bd5273e0ea128eceff3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67e61fe7f39ac4eaeadf7bd5273e0ea128eceff3", "patch": "@@ -1,3 +1,16 @@\n+Tue Oct 26 15:42:56 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* reload.c (find_reloads): Compute mode and nregs fields of all\n+\treloads.\n+\t* reload1.c (calculate_needs_all_insns): Simplify a bit.\n+\t(calculate_needs): Use precomputed mode/nregs values.\n+\t(allocate_reload_reg): Likewise.\n+\tBreak out two...\n+\t(failed_reload, set_reload_reg): ... new functions.\n+\t(choose_reload_regs_init): New function, mostly broken out from...\n+\t(choose_reload_regs): ... here.  Lose all the save_xxx nonsense.\n+\tAlso lose one #if 0 block.\n+\n Tue Oct 26 02:48:32 1999  Marc Espie <espie@cvs.openbsd.org>\n \n \t* Makefile.in (AR_FOR_TARGET, RANLIB_FOR_TARGET):  Fix target name "}, {"sha": "bd32ba303417e9a8098ef207f364510f16e2d773", "filename": "gcc/reload.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67e61fe7f39ac4eaeadf7bd5273e0ea128eceff3/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67e61fe7f39ac4eaeadf7bd5273e0ea128eceff3/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=67e61fe7f39ac4eaeadf7bd5273e0ea128eceff3", "patch": "@@ -4174,6 +4174,18 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t}\n     }\n \n+  /* Compute reload_mode and reload_nregs.  */\n+  for (i = 0; i < n_reloads; i++)\n+    {\n+      rld[i].mode\n+\t= (rld[i].inmode == VOIDmode\n+\t   || (GET_MODE_SIZE (rld[i].outmode)\n+\t       > GET_MODE_SIZE (rld[i].inmode)))\n+\t  ? rld[i].outmode : rld[i].inmode;\n+\n+      rld[i].nregs = CLASS_MAX_NREGS (rld[i].class, rld[i].mode);\n+    }\n+\n   return retval;\n }\n "}, {"sha": "0528860c15d36d8237f01484997f3875b95eff84", "filename": "gcc/reload1.c", "status": "modified", "additions": 128, "deletions": 221, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67e61fe7f39ac4eaeadf7bd5273e0ea128eceff3/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67e61fe7f39ac4eaeadf7bd5273e0ea128eceff3/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=67e61fe7f39ac4eaeadf7bd5273e0ea128eceff3", "patch": "@@ -424,6 +424,7 @@ static int reload_reg_free_for_value_p\tPROTO((int, int, enum reload_type, rtx, r\n static int reload_reg_reaches_end_p\tPROTO((int, int, enum reload_type));\n static int allocate_reload_reg\t\tPROTO((struct insn_chain *, int, int,\n \t\t\t\t\t       int));\n+static void choose_reload_regs_init\tPROTO((struct insn_chain *, rtx *));\n static void choose_reload_regs\t\tPROTO((struct insn_chain *));\n static void merge_assigned_reloads\tPROTO((rtx));\n static void emit_reload_insns\t\tPROTO((struct insn_chain *));\n@@ -1325,17 +1326,18 @@ calculate_needs_all_insns (global)\n      int global;\n {\n   struct insn_chain **pprev_reload = &insns_need_reload;\n-  struct insn_chain **pchain;\n+  struct insn_chain *chain;\n \n   something_needs_elimination = 0;\n \n-  for (pchain = &reload_insn_chain; *pchain != 0; pchain = &(*pchain)->next)\n+  for (chain = reload_insn_chain; chain != 0; chain = chain->next)\n     {\n-      rtx insn;\n-      struct insn_chain *chain;\n+      rtx insn = chain->insn;\n \n-      chain = *pchain;\n-      insn = chain->insn;\n+      /* Clear out the shortcuts, in case they were set last time through.  */\n+      chain->need_elim = 0;\n+      chain->need_reload = 0;\n+      chain->need_operand_change = 0;\n \n       /* If this is a label, a JUMP_INSN, or has REG_NOTES (which might\n \t include REG_LABEL), we need to see what effects this has on the\n@@ -1359,14 +1361,7 @@ calculate_needs_all_insns (global)\n \t  if (set && GET_CODE (SET_DEST (set)) == REG\n \t      && reg_renumber[REGNO (SET_DEST (set))] < 0\n \t      && reg_equiv_constant[REGNO (SET_DEST (set))])\n-\t    {\n-\t      /* Must clear out the shortcuts, in case they were set last\n-\t\t time through.  */\n-\t      chain->need_elim = 0;\n-\t      chain->need_reload = 0;\n-\t      chain->need_operand_change = 0;\n-\t      continue;\n-\t    }\n+\t    continue;\n \n \t  /* If needed, eliminate any eliminable registers.  */\n \t  if (num_eliminable || num_eliminable_invariants)\n@@ -1495,10 +1490,8 @@ calculate_needs (chain)\n \t      && ! rld[i].secondary_p))\n \tcontinue;\n \n-      mode = rld[i].inmode;\n-      if (GET_MODE_SIZE (rld[i].outmode) > GET_MODE_SIZE (mode))\n-\tmode = rld[i].outmode;\n-      size = CLASS_MAX_NREGS (class, mode);\n+      mode = rld[i].mode;\n+      size = rld[i].nregs;\n \n       /* Decide which time-of-use to count this reload for.  */\n       switch (rld[i].when_needed)\n@@ -5488,6 +5481,78 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n   return 1;\n }\n \n+/* Give an error message saying we failed to find a reload for INSN,\n+   and clear out reload R.  */\n+static void\n+failed_reload (insn, r)\n+     rtx insn;\n+     int r;\n+{\n+  if (asm_noperands (PATTERN (insn)) < 0)\n+    /* It's the compiler's fault.  */\n+    fatal_insn (\"Could not find a spill register\", insn);\n+\n+  /* It's the user's fault; the operand's mode and constraint\n+     don't match.  Disable this reload so we don't crash in final.  */\n+  error_for_asm (insn,\n+\t\t \"`asm' operand constraint incompatible with operand size\");\n+  rld[r].in = 0;\n+  rld[r].out = 0;\n+  rld[r].reg_rtx = 0;\n+  rld[r].optional = 1;\n+  rld[r].secondary_p = 1;\n+}\n+\n+/* I is the index in SPILL_REG_RTX of the reload register we are to allocate\n+   for reload R.  If it's valid, get an rtx for it.  Return nonzero if\n+   successful.  */\n+static int\n+set_reload_reg (i, r)\n+     int i, r;\n+{\n+  int regno;\n+  rtx reg = spill_reg_rtx[i];\n+\n+  if (reg == 0 || GET_MODE (reg) != rld[r].mode)\n+    spill_reg_rtx[i] = reg\n+      = gen_rtx_REG (rld[r].mode, spill_regs[i]);\n+\n+  regno = true_regnum (reg);\n+\n+  /* Detect when the reload reg can't hold the reload mode.\n+     This used to be one `if', but Sequent compiler can't handle that.  */\n+  if (HARD_REGNO_MODE_OK (regno, rld[r].mode))\n+    {\n+      enum machine_mode test_mode = VOIDmode;\n+      if (rld[r].in)\n+\ttest_mode = GET_MODE (rld[r].in);\n+      /* If rld[r].in has VOIDmode, it means we will load it\n+\t in whatever mode the reload reg has: to wit, rld[r].mode.\n+\t We have already tested that for validity.  */\n+      /* Aside from that, we need to test that the expressions\n+\t to reload from or into have modes which are valid for this\n+\t reload register.  Otherwise the reload insns would be invalid.  */\n+      if (! (rld[r].in != 0 && test_mode != VOIDmode\n+\t     && ! HARD_REGNO_MODE_OK (regno, test_mode)))\n+\tif (! (rld[r].out != 0\n+\t       && ! HARD_REGNO_MODE_OK (regno, GET_MODE (rld[r].out))))\n+\t  {\n+\t    /* The reg is OK.  */\n+\t    last_spill_reg = i;\n+\n+\t    /* Mark as in use for this insn the reload regs we use\n+\t       for this.  */\n+\t    mark_reload_reg_in_use (spill_regs[i], rld[r].opnum,\n+\t\t\t\t    rld[r].when_needed, rld[r].mode);\n+\n+\t    rld[r].reg_rtx = reg;\n+\t    reload_spill_index[r] = spill_regs[i];\n+\t    return 1;\n+\t  }\n+    }\n+  return 0;\n+}\n+\n /* Find a spill register to use as a reload register for reload R.\n    LAST_RELOAD is non-zero if this is the last reload for the insn being\n    processed.\n@@ -5505,8 +5570,7 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n      int noerror;\n {\n   rtx insn = chain->insn;\n-  int i, pass, count, regno;\n-  rtx new;\n+  int i, pass, count;\n \n   /* If we put this reload ahead, thinking it is a group,\n      then insist on finding a group.  Otherwise we can grab a\n@@ -5589,7 +5653,7 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n \t\t (on 68000) got us two FP regs.  If NR is 1,\n \t\t we would reject both of them.  */\n \t      if (force_group)\n-\t\tnr = CLASS_MAX_NREGS (rld[r].class, rld[r].mode);\n+\t\tnr = rld[r].nregs;\n \t      /* If we need only one reg, we have already won.  */\n \t      if (nr == 1)\n \t\t{\n@@ -5605,7 +5669,7 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n \t      if (! TEST_HARD_REG_BIT (chain->counted_for_nongroups, regnum))\n \t\twhile (nr > 1)\n \t\t  {\n-\t\t    regno = regnum + nr - 1;\n+\t\t    int regno = regnum + nr - 1;\n \t\t    if (!(TEST_HARD_REG_BIT (reg_class_contents[class], regno)\n \t\t\t  && spill_reg_order[regno] >= 0\n \t\t\t  && reload_reg_free_p (regno, rld[r].opnum,\n@@ -5633,106 +5697,31 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n       goto failure;\n     }\n \n-  /* I is the index in SPILL_REG_RTX of the reload register we are to\n-     allocate.  Get an rtx for it and find its register number.  */\n-\n-  new = spill_reg_rtx[i];\n-\n-  if (new == 0 || GET_MODE (new) != rld[r].mode)\n-    spill_reg_rtx[i] = new\n-      = gen_rtx_REG (rld[r].mode, spill_regs[i]);\n-\n-  regno = true_regnum (new);\n-\n-  /* Detect when the reload reg can't hold the reload mode.\n-     This used to be one `if', but Sequent compiler can't handle that.  */\n-  if (HARD_REGNO_MODE_OK (regno, rld[r].mode))\n-    {\n-      enum machine_mode test_mode = VOIDmode;\n-      if (rld[r].in)\n-\ttest_mode = GET_MODE (rld[r].in);\n-      /* If rld[r].in has VOIDmode, it means we will load it\n-\t in whatever mode the reload reg has: to wit, rld[r].mode.\n-\t We have already tested that for validity.  */\n-      /* Aside from that, we need to test that the expressions\n-\t to reload from or into have modes which are valid for this\n-\t reload register.  Otherwise the reload insns would be invalid.  */\n-      if (! (rld[r].in != 0 && test_mode != VOIDmode\n-\t     && ! HARD_REGNO_MODE_OK (regno, test_mode)))\n-\tif (! (rld[r].out != 0\n-\t       && ! HARD_REGNO_MODE_OK (regno, GET_MODE (rld[r].out))))\n-\t  {\n-\t    /* The reg is OK.  */\n-\t    last_spill_reg = i;\n-\n-\t    /* Mark as in use for this insn the reload regs we use\n-\t       for this.  */\n-\t    mark_reload_reg_in_use (spill_regs[i], rld[r].opnum,\n-\t\t\t\t    rld[r].when_needed, rld[r].mode);\n-\n-\t    rld[r].reg_rtx = new;\n-\t    reload_spill_index[r] = spill_regs[i];\n-\t    return 1;\n-\t  }\n-    }\n+  if (set_reload_reg (i, r))\n+    return 1;\n \n   /* The reg is not OK.  */\n   if (noerror)\n     return 0;\n \n  failure:\n-  if (asm_noperands (PATTERN (insn)) < 0)\n-    /* It's the compiler's fault.  */\n-    fatal_insn (\"Could not find a spill register\", insn);\n-\n-  /* It's the user's fault; the operand's mode and constraint\n-     don't match.  Disable this reload so we don't crash in final.  */\n-  error_for_asm (insn,\n-\t\t \"`asm' operand constraint incompatible with operand size\");\n-  rld[r].in = 0;\n-  rld[r].out = 0;\n-  rld[r].reg_rtx = 0;\n-  rld[r].optional = 1;\n-  rld[r].secondary_p = 1;\n+  failed_reload (insn, r);\n \n   return 1;\n }\n \f\n-/* Assign hard reg targets for the pseudo-registers we must reload\n-   into hard regs for this insn.\n-   Also output the instructions to copy them in and out of the hard regs.\n-\n-   For machines with register classes, we are responsible for\n-   finding a reload reg in the proper class.  */\n-\n+/* Initialize all the tables needed to allocate reload registers.\n+   CHAIN is the insn currently being processed; SAVE_RELOAD_REG_RTX\n+   is the array we use to restore the reg_rtx field for every reload.  */\n static void\n-choose_reload_regs (chain)\n+choose_reload_regs_init (chain, save_reload_reg_rtx)\n      struct insn_chain *chain;\n+     rtx *save_reload_reg_rtx;\n {\n-  rtx insn = chain->insn;\n-  register int i, j;\n-  int max_group_size = 1;\n-  enum reg_class group_class = NO_REGS;\n-  int inheritance;\n-  int pass;\n+  int i;\n \n-  rtx save_reload_reg_rtx[MAX_RELOADS];\n-  char save_reload_inherited[MAX_RELOADS];\n-  rtx save_reload_inheritance_insn[MAX_RELOADS];\n-  rtx save_reload_override_in[MAX_RELOADS];\n-  int save_reload_spill_index[MAX_RELOADS];\n-  HARD_REG_SET save_reload_reg_used;\n-  HARD_REG_SET save_reload_reg_used_in_input_addr[MAX_RECOG_OPERANDS];\n-  HARD_REG_SET save_reload_reg_used_in_inpaddr_addr[MAX_RECOG_OPERANDS];\n-  HARD_REG_SET save_reload_reg_used_in_output_addr[MAX_RECOG_OPERANDS];\n-  HARD_REG_SET save_reload_reg_used_in_outaddr_addr[MAX_RECOG_OPERANDS];\n-  HARD_REG_SET save_reload_reg_used_in_input[MAX_RECOG_OPERANDS];\n-  HARD_REG_SET save_reload_reg_used_in_output[MAX_RECOG_OPERANDS];\n-  HARD_REG_SET save_reload_reg_used_in_op_addr;\n-  HARD_REG_SET save_reload_reg_used_in_op_addr_reload;\n-  HARD_REG_SET save_reload_reg_used_in_insn;\n-  HARD_REG_SET save_reload_reg_used_in_other_addr;\n-  HARD_REG_SET save_reload_reg_used_at_all;\n+  for (i = 0; i < n_reloads; i++)\n+    rld[i].reg_rtx = save_reload_reg_rtx[i];\n \n   bzero (reload_inherited, MAX_RELOADS);\n   bzero ((char *) reload_inheritance_insn, MAX_RELOADS * sizeof (rtx));\n@@ -5767,27 +5756,35 @@ choose_reload_regs (chain)\n \n   IOR_COMPL_HARD_REG_SET (reload_reg_used, chain->used_spill_regs);\n \n-#if 0  /* Not needed, now that we can always retry without inheritance.  */\n-  /* See if we have more mandatory reloads than spill regs.\n-     If so, then we cannot risk optimizations that could prevent\n-     reloads from sharing one spill register.\n+  CLEAR_HARD_REG_SET (reload_reg_used_for_inherit);\n \n-     Since we will try finding a better register than reload_reg_rtx\n-     unless it is equal to reload_in or reload_out, count such reloads.  */\n+  for (i = 0; i < n_reloads; i++)\n+    /* If we have already decided to use a certain register,\n+       don't use it in another way.  */\n+    if (rld[i].reg_rtx)\n+      mark_reload_reg_in_use (REGNO (rld[i].reg_rtx), rld[i].opnum,\n+\t\t\t      rld[i].when_needed, rld[i].mode);\n+}\n \n-  {\n-    int tem = 0;\n-    for (j = 0; j < n_reloads; j++)\n-      if (! rld[j].optional\n-\t  && (rld[j].in != 0 || rld[j].out != 0 || rld[j].secondary_p)\n-\t  && (rld[j].reg_rtx == 0\n-\t      || (! rtx_equal_p (rld[j].reg_rtx, rld[j].in)\n-\t\t  && ! rtx_equal_p (rld[j].reg_rtx, rld[j].out))))\n-\ttem++;\n-    if (tem > n_spills)\n-      must_reuse = 1;\n-  }\n-#endif\n+/* Assign hard reg targets for the pseudo-registers we must reload\n+   into hard regs for this insn.\n+   Also output the instructions to copy them in and out of the hard regs.\n+\n+   For machines with register classes, we are responsible for\n+   finding a reload reg in the proper class.  */\n+\n+static void\n+choose_reload_regs (chain)\n+     struct insn_chain *chain;\n+{\n+  rtx insn = chain->insn;\n+  register int i, j;\n+  int max_group_size = 1;\n+  enum reg_class group_class = NO_REGS;\n+  int inheritance;\n+  int pass;\n+\n+  rtx save_reload_reg_rtx[MAX_RELOADS];\n \n   /* In order to be certain of getting the registers we need,\n      we must sort the reloads into order of increasing register class.\n@@ -5803,67 +5800,18 @@ choose_reload_regs (chain)\n       reload_order[j] = j;\n       reload_spill_index[j] = -1;\n \n-      rld[j].mode = ((rld[j].inmode == VOIDmode\n-\t\t      || (GET_MODE_SIZE (rld[j].outmode)\n-\t\t\t  > GET_MODE_SIZE (rld[j].inmode)))\n-\t\t     ? rld[j].outmode : rld[j].inmode);\n-\n-      rld[j].nregs = CLASS_MAX_NREGS (rld[j].class, rld[j].mode);\n-\n       if (rld[j].nregs > 1)\n \t{\n \t  max_group_size = MAX (rld[j].nregs, max_group_size);\n \t  group_class = reg_class_superunion[(int)rld[j].class][(int)group_class];\n \t}\n \n       save_reload_reg_rtx[j] = rld[j].reg_rtx;\n-      /* If we have already decided to use a certain register,\n-\t don't use it in another way.  */\n-      if (rld[j].reg_rtx)\n-\tmark_reload_reg_in_use (REGNO (rld[j].reg_rtx), rld[j].opnum,\n-\t\t\t\trld[j].when_needed, rld[j].mode);\n     }\n \n   if (n_reloads > 1)\n     qsort (reload_order, n_reloads, sizeof (short), reload_reg_class_lower);\n \n-  bcopy (reload_inherited, save_reload_inherited, sizeof reload_inherited);\n-  bcopy ((char *) reload_inheritance_insn,\n-\t (char *) save_reload_inheritance_insn,\n-\t sizeof reload_inheritance_insn);\n-  bcopy ((char *) reload_override_in, (char *) save_reload_override_in,\n-\t sizeof reload_override_in);\n-  bcopy ((char *) reload_spill_index, (char *) save_reload_spill_index,\n-\t sizeof reload_spill_index);\n-  COPY_HARD_REG_SET (save_reload_reg_used, reload_reg_used);\n-  COPY_HARD_REG_SET (save_reload_reg_used_at_all, reload_reg_used_at_all);\n-  COPY_HARD_REG_SET (save_reload_reg_used_in_op_addr,\n-\t\t     reload_reg_used_in_op_addr);\n-\n-  COPY_HARD_REG_SET (save_reload_reg_used_in_op_addr_reload,\n-\t\t     reload_reg_used_in_op_addr_reload);\n-\n-  COPY_HARD_REG_SET (save_reload_reg_used_in_insn,\n-\t\t     reload_reg_used_in_insn);\n-  COPY_HARD_REG_SET (save_reload_reg_used_in_other_addr,\n-\t\t     reload_reg_used_in_other_addr);\n-\n-  for (i = 0; i < reload_n_operands; i++)\n-    {\n-      COPY_HARD_REG_SET (save_reload_reg_used_in_output[i],\n-\t\t\t reload_reg_used_in_output[i]);\n-      COPY_HARD_REG_SET (save_reload_reg_used_in_input[i],\n-\t\t\t reload_reg_used_in_input[i]);\n-      COPY_HARD_REG_SET (save_reload_reg_used_in_input_addr[i],\n-\t\t\t reload_reg_used_in_input_addr[i]);\n-      COPY_HARD_REG_SET (save_reload_reg_used_in_inpaddr_addr[i],\n-\t\t\t reload_reg_used_in_inpaddr_addr[i]);\n-      COPY_HARD_REG_SET (save_reload_reg_used_in_output_addr[i],\n-\t\t\t reload_reg_used_in_output_addr[i]);\n-      COPY_HARD_REG_SET (save_reload_reg_used_in_outaddr_addr[i],\n-\t\t\t reload_reg_used_in_outaddr_addr[i]);\n-    }\n-\n   /* If -O, try first with inheritance, then turning it off.\n      If not -O, don't do inheritance.\n      Using inheritance when not optimizing leads to paradoxes\n@@ -5872,6 +5820,8 @@ choose_reload_regs (chain)\n \n   for (inheritance = optimize > 0; inheritance >= 0; inheritance--)\n     {\n+      choose_reload_regs_init (chain, save_reload_reg_rtx);\n+\n       /* Process the reloads in order of preference just found.\n \t Beyond this point, subregs can be found in reload_reg_rtx.\n \n@@ -5890,8 +5840,6 @@ choose_reload_regs (chain)\n \t Then make a second pass over the reloads to allocate any reloads\n \t that haven't been given registers yet.  */\n \n-      CLEAR_HARD_REG_SET (reload_reg_used_for_inherit);\n-\n       for (j = 0; j < n_reloads; j++)\n \t{\n \t  register int r = reload_order[j];\n@@ -6070,8 +6018,7 @@ choose_reload_regs (chain)\n \t\t\t\t  && rld[r].out\n \t\t\t\t  && ! TEST_HARD_REG_BIT (reg_reloaded_dead, i))\n \t\t\t      /* Don't clobber the frame pointer.  */\n-\t\t\t      || (i == HARD_FRAME_POINTER_REGNUM\n-\t\t\t\t  && rld[r].out)\n+\t\t\t      || (i == HARD_FRAME_POINTER_REGNUM && rld[r].out)\n \t\t\t      /* Don't really use the inherited spill reg\n \t\t\t\t if we need it wider than we've got it.  */\n \t\t\t      || (GET_MODE_SIZE (rld[r].mode)\n@@ -6083,8 +6030,7 @@ choose_reload_regs (chain)\n \t\t\t\t register, stay with it - that leaves the\n \t\t\t\t inherited register for subsequent reloads.  */\n \t\t\t      || (rld[r].out && rld[r].reg_rtx\n-\t\t\t\t  && rtx_equal_p (rld[r].out,\n-\t\t\t\t\t\t  rld[r].reg_rtx)))\n+\t\t\t\t  && rtx_equal_p (rld[r].out, rld[r].reg_rtx)))\n \t\t\t    {\n \t\t\t      reload_override_in[r] = last_reg;\n \t\t\t      reload_inheritance_insn[r]\n@@ -6314,45 +6260,6 @@ choose_reload_regs (chain)\n \tbreak;\n \n       /* Loop around and try without any inheritance.  */\n-      /* First undo everything done by the failed attempt\n-\t to allocate with inheritance.  */\n-      for (i = 0; i < n_reloads; i++)\n-\trld[i].reg_rtx = save_reload_reg_rtx[i];\n-      bcopy ((char *) save_reload_inherited, (char *) reload_inherited,\n-\t     sizeof reload_inherited);\n-      bcopy ((char *) save_reload_inheritance_insn,\n-\t     (char *) reload_inheritance_insn,\n-\t     sizeof reload_inheritance_insn);\n-      bcopy ((char *) save_reload_override_in, (char *) reload_override_in,\n-\t     sizeof reload_override_in);\n-      bcopy ((char *) save_reload_spill_index, (char *) reload_spill_index,\n-\t     sizeof reload_spill_index);\n-      COPY_HARD_REG_SET (reload_reg_used, save_reload_reg_used);\n-      COPY_HARD_REG_SET (reload_reg_used_at_all, save_reload_reg_used_at_all);\n-      COPY_HARD_REG_SET (reload_reg_used_in_op_addr,\n-\t\t\t save_reload_reg_used_in_op_addr);\n-      COPY_HARD_REG_SET (reload_reg_used_in_op_addr_reload,\n-\t\t\t save_reload_reg_used_in_op_addr_reload);\n-      COPY_HARD_REG_SET (reload_reg_used_in_insn,\n-\t\t\t save_reload_reg_used_in_insn);\n-      COPY_HARD_REG_SET (reload_reg_used_in_other_addr,\n-\t\t\t save_reload_reg_used_in_other_addr);\n-\n-      for (i = 0; i < reload_n_operands; i++)\n-\t{\n-\t  COPY_HARD_REG_SET (reload_reg_used_in_input[i],\n-\t\t\t     save_reload_reg_used_in_input[i]);\n-\t  COPY_HARD_REG_SET (reload_reg_used_in_output[i],\n-\t\t\t     save_reload_reg_used_in_output[i]);\n-\t  COPY_HARD_REG_SET (reload_reg_used_in_input_addr[i],\n-\t\t\t     save_reload_reg_used_in_input_addr[i]);\n-\t  COPY_HARD_REG_SET (reload_reg_used_in_inpaddr_addr[i],\n-\t\t\t     save_reload_reg_used_in_inpaddr_addr[i]);\n-\t  COPY_HARD_REG_SET (reload_reg_used_in_output_addr[i],\n-\t\t\t     save_reload_reg_used_in_output_addr[i]);\n-\t  COPY_HARD_REG_SET (reload_reg_used_in_outaddr_addr[i],\n-\t\t\t     save_reload_reg_used_in_outaddr_addr[i]);\n-\t}\n     }\n \n   /* If we thought we could inherit a reload, because it seemed that"}]}