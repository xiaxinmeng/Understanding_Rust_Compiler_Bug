{"sha": "3746a4b2bc625d48a8178b247cace162e62a32f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc0NmE0YjJiYzYyNWQ0OGE4MTc4YjI0N2NhY2UxNjJlNjJhMzJmMQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-01-10T14:37:55Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-01-10T14:37:55Z"}, "message": "Revert m_classes_vec introduction.\n\n2017-01-10  Martin Liska  <mliska@suse.cz>\n\n\t* ipa-icf.c (sem_item_optimizer::sem_item_optimizer): Remove\n\tusage of m_classes_vec.\n\t(sem_item_optimizer::~sem_item_optimizer):  Likewise.\n\t(sem_item_optimizer::get_group_by_hash): Likewise.\n\t(sem_item_optimizer::subdivide_classes_by_equality): Likewise.\n\t(sem_item_optimizer::subdivide_classes_by_sensitive_refs): Likewise.\n\t(sem_item_optimizer::verify_classes): Likewise.\n\t(sem_item_optimizer::process_cong_reduction): Likewise.\n\t(sem_item_optimizer::dump_cong_classes): Likewise.\n\t(sem_item_optimizer::merge_classes): Likewise.\n\t* ipa-icf.h (congruence_class_hash): Rename from\n\tcongruence_class_group_hash.  Remove declaration of\n\tm_classes_vec.\n\nFrom-SVN: r244272", "tree": {"sha": "7e2dccc9c5202161bac5b22e4ef4690467f1bdad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e2dccc9c5202161bac5b22e4ef4690467f1bdad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3746a4b2bc625d48a8178b247cace162e62a32f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3746a4b2bc625d48a8178b247cace162e62a32f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3746a4b2bc625d48a8178b247cace162e62a32f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3746a4b2bc625d48a8178b247cace162e62a32f1/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "26b67e383f4b1df812cd7ba33de43451aff883ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26b67e383f4b1df812cd7ba33de43451aff883ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26b67e383f4b1df812cd7ba33de43451aff883ba"}], "stats": {"total": 129, "additions": 67, "deletions": 62}, "files": [{"sha": "9a2649d49e3c881819c14244357e7aa2a9f0f8a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3746a4b2bc625d48a8178b247cace162e62a32f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3746a4b2bc625d48a8178b247cace162e62a32f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3746a4b2bc625d48a8178b247cace162e62a32f1", "patch": "@@ -1,3 +1,19 @@\n+2017-01-10  Martin Liska  <mliska@suse.cz>\n+\n+\t* ipa-icf.c (sem_item_optimizer::sem_item_optimizer): Remove\n+\tusage of m_classes_vec.\n+\t(sem_item_optimizer::~sem_item_optimizer):  Likewise.\n+\t(sem_item_optimizer::get_group_by_hash): Likewise.\n+\t(sem_item_optimizer::subdivide_classes_by_equality): Likewise.\n+\t(sem_item_optimizer::subdivide_classes_by_sensitive_refs): Likewise.\n+\t(sem_item_optimizer::verify_classes): Likewise.\n+\t(sem_item_optimizer::process_cong_reduction): Likewise.\n+\t(sem_item_optimizer::dump_cong_classes): Likewise.\n+\t(sem_item_optimizer::merge_classes): Likewise.\n+\t* ipa-icf.h (congruence_class_hash): Rename from\n+\tcongruence_class_group_hash.  Remove declaration of\n+\tm_classes_vec.\n+\n 2017-01-10  Andrew Senkevich  <andrew.senkevich@intel.com>\n \n \t* common/config/i386/i386-common.c (OPTION_MASK_ISA_AVX512VPOPCNTDQ_SET,"}, {"sha": "28de251c42129cd3633415acdd7a98b38ab791bb", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 49, "deletions": 57, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3746a4b2bc625d48a8178b247cace162e62a32f1/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3746a4b2bc625d48a8178b247cace162e62a32f1/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=3746a4b2bc625d48a8178b247cace162e62a32f1", "patch": "@@ -2288,7 +2288,6 @@ sem_item_optimizer::sem_item_optimizer ()\n   m_varpool_node_hooks (NULL)\n {\n   m_items.create (0);\n-  m_classes_vec.create (0);\n   bitmap_obstack_initialize (&m_bmstack);\n }\n \n@@ -2297,19 +2296,18 @@ sem_item_optimizer::~sem_item_optimizer ()\n   for (unsigned int i = 0; i < m_items.length (); i++)\n     delete m_items[i];\n \n-  unsigned int l;\n-  congruence_class_group *it;\n-  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n+\n+  for (hash_table<congruence_class_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n     {\n-      for (unsigned int i = 0; i < it->classes.length (); i++)\n-\tdelete it->classes[i];\n+      for (unsigned int i = 0; i < (*it)->classes.length (); i++)\n+\tdelete (*it)->classes[i];\n \n-      it->classes.release ();\n-      free (it);\n+      (*it)->classes.release ();\n+      free (*it);\n     }\n \n   m_items.release ();\n-  m_classes_vec.release ();\n \n   bitmap_obstack_release (&m_bmstack);\n }\n@@ -2502,7 +2500,6 @@ sem_item_optimizer::get_group_by_hash (hashval_t hash, sem_item_type type)\n   else\n     {\n       item->classes.create (1);\n-      m_classes_vec.safe_push (item);\n       *slot = item;\n     }\n \n@@ -2847,15 +2844,14 @@ sem_item_optimizer::parse_nonsingleton_classes (void)\n void\n sem_item_optimizer::subdivide_classes_by_equality (bool in_wpa)\n {\n-  unsigned int l;\n-  congruence_class_group *it;\n-  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n+  for (hash_table <congruence_class_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n     {\n-      unsigned int class_count = it->classes.length ();\n+      unsigned int class_count = (*it)->classes.length ();\n \n       for (unsigned i = 0; i < class_count; i++)\n \t{\n-\t  congruence_class *c = it->classes[i];\n+\t  congruence_class *c = (*it)->classes[i];\n \n \t  if (c->members.length() > 1)\n \t    {\n@@ -2864,7 +2860,7 @@ sem_item_optimizer::subdivide_classes_by_equality (bool in_wpa)\n \t      sem_item *first = c->members[0];\n \t      new_vector.safe_push (first);\n \n-\t      unsigned class_split_first = it->classes.length ();\n+\t      unsigned class_split_first = (*it)->classes.length ();\n \n \t      for (unsigned j = 1; j < c->members.length (); j++)\n \t\t{\n@@ -2881,17 +2877,17 @@ sem_item_optimizer::subdivide_classes_by_equality (bool in_wpa)\n \t\t      bool integrated = false;\n \n \t\t      for (unsigned k = class_split_first;\n-\t\t\t   k < it->classes.length (); k++)\n+\t\t\t   k < (*it)->classes.length (); k++)\n \t\t\t{\n-\t\t\t  sem_item *x = it->classes[k]->members[0];\n+\t\t\t  sem_item *x = (*it)->classes[k]->members[0];\n \t\t\t  bool equals\n \t\t\t    = in_wpa ? x->equals_wpa (item, m_symtab_node_map)\n \t\t\t\t     : x->equals (item, m_symtab_node_map);\n \n \t\t\t  if (equals)\n \t\t\t    {\n \t\t\t      integrated = true;\n-\t\t\t      add_item_to_class (it->classes[k], item);\n+\t\t\t      add_item_to_class ((*it)->classes[k], item);\n \n \t\t\t      break;\n \t\t\t    }\n@@ -2904,7 +2900,7 @@ sem_item_optimizer::subdivide_classes_by_equality (bool in_wpa)\n \t\t\t  m_classes_count++;\n \t\t\t  add_item_to_class (c, item);\n \n-\t\t\t  it->classes.safe_push (c);\n+\t\t\t  (*it)->classes.safe_push (c);\n \t\t\t}\n \t\t    }\n \t\t}\n@@ -2935,16 +2931,15 @@ sem_item_optimizer::subdivide_classes_by_sensitive_refs ()\n \n   unsigned newly_created_classes = 0;\n \n-  unsigned int l;\n-  congruence_class_group *it;\n-  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n+  for (hash_table <congruence_class_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n     {\n-      unsigned int class_count = it->classes.length ();\n+      unsigned int class_count = (*it)->classes.length ();\n       auto_vec<congruence_class *> new_classes;\n \n       for (unsigned i = 0; i < class_count; i++)\n \t{\n-\t  congruence_class *c = it->classes[i];\n+\t  congruence_class *c = (*it)->classes[i];\n \n \t  if (c->members.length() > 1)\n \t    {\n@@ -2988,7 +2983,7 @@ sem_item_optimizer::subdivide_classes_by_sensitive_refs ()\n \n \t\t      if (first_class)\n \t\t        {\n-\t\t\t  it->classes[i] = new_cls;\n+\t\t\t  (*it)->classes[i] = new_cls;\n \t\t\t  first_class = false;\n \t\t\t}\n \t\t      else\n@@ -3010,7 +3005,7 @@ sem_item_optimizer::subdivide_classes_by_sensitive_refs ()\n \t  }\n \n \tfor (unsigned i = 0; i < new_classes.length (); i++)\n-\t  it->classes.safe_push (new_classes[i]);\n+\t  (*it)->classes.safe_push (new_classes[i]);\n     }\n \n   return newly_created_classes;\n@@ -3030,13 +3025,12 @@ sem_item_optimizer::checking_verify_classes (void)\n void\n sem_item_optimizer::verify_classes (void)\n {\n-  unsigned int l;\n-  congruence_class_group *it;\n-  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n+  for (hash_table<congruence_class_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n     {\n-      for (unsigned int i = 0; i < it->classes.length (); i++)\n+      for (unsigned int i = 0; i < (*it)->classes.length (); i++)\n \t{\n-\t  congruence_class *cls = it->classes[i];\n+\t  congruence_class *cls = (*it)->classes[i];\n \n \t  gcc_assert (cls);\n \t  gcc_assert (cls->members.length () > 0);\n@@ -3302,12 +3296,11 @@ sem_item_optimizer::worklist_pop (void)\n void\n sem_item_optimizer::process_cong_reduction (void)\n {\n-  unsigned int l;\n-  congruence_class_group *it;\n-  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n-    for (unsigned i = 0; i < it->classes.length (); i++)\n-      if (it->classes[i]->is_class_used ())\n-\tworklist_push (it->classes[i]);\n+  for (hash_table<congruence_class_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n+    for (unsigned i = 0; i < (*it)->classes.length (); i++)\n+      if ((*it)->classes[i]->is_class_used ())\n+\tworklist_push ((*it)->classes[i]);\n \n   if (dump_file)\n     fprintf (dump_file, \"Worklist has been filled with: %lu\\n\",\n@@ -3347,12 +3340,11 @@ sem_item_optimizer::dump_cong_classes (void)\n   unsigned int max_index = 0;\n   unsigned int* histogram = XCNEWVEC (unsigned int, m_items.length () + 1);\n \n-  unsigned int l;\n-  congruence_class_group *it;\n-  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n-    for (unsigned i = 0; i < it->classes.length (); i++)\n+  for (hash_table<congruence_class_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n+    for (unsigned i = 0; i < (*it)->classes.length (); i++)\n       {\n-\tunsigned int c = it->classes[i]->members.length ();\n+\tunsigned int c = (*it)->classes[i]->members.length ();\n \thistogram[c]++;\n \n \tif (c > max_index)\n@@ -3369,18 +3361,18 @@ sem_item_optimizer::dump_cong_classes (void)\n \n   fprintf (dump_file, \"\\n\\n\");\n \n-\n   if (dump_flags & TDF_DETAILS)\n-    FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n+  for (hash_table<congruence_class_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n       {\n \tfprintf (dump_file, \"  group: with %u classes:\\n\",\n-\t\t it->classes.length ());\n+\t\t (*it)->classes.length ());\n \n-\tfor (unsigned i = 0; i < it->classes.length (); i++)\n+\tfor (unsigned i = 0; i < (*it)->classes.length (); i++)\n \t  {\n-\t    it->classes[i]->dump (dump_file, 4);\n+\t    (*it)->classes[i]->dump (dump_file, 4);\n \n-\t    if (i < it->classes.length () - 1)\n+\t    if (i < (*it)->classes.length () - 1)\n \t      fprintf (dump_file, \" \");\n \t  }\n       }\n@@ -3405,12 +3397,11 @@ sem_item_optimizer::merge_classes (unsigned int prev_class_count)\n \n   bool merged_p = false;\n \n-  unsigned int l;\n-  congruence_class_group *it;\n-  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n-    for (unsigned int i = 0; i < it->classes.length (); i++)\n+  for (hash_table<congruence_class_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n+    for (unsigned int i = 0; i < (*it)->classes.length (); i++)\n       {\n-\tcongruence_class *c = it->classes[i];\n+\tcongruence_class *c = (*it)->classes[i];\n \tif (c->members.length () > 1)\n \t  {\n \t    non_singular_classes_count++;\n@@ -3435,10 +3426,11 @@ sem_item_optimizer::merge_classes (unsigned int prev_class_count)\n \t       item_count ? 100.0f * equal_items / item_count : 0.0f);\n     }\n \n-  FOR_EACH_VEC_ELT (m_classes_vec, l, it)\n-    for (unsigned int i = 0; i < it->classes.length (); i++)\n+  for (hash_table<congruence_class_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n+    for (unsigned int i = 0; i < (*it)->classes.length (); i++)\n       {\n-\tcongruence_class *c = it->classes[i];\n+\tcongruence_class *c = (*it)->classes[i];\n \n \tif (c->members.length () == 1)\n \t  continue;"}, {"sha": "c57224c1517e5f892140c649307b2774a998c424", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3746a4b2bc625d48a8178b247cace162e62a32f1/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3746a4b2bc625d48a8178b247cace162e62a32f1/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=3746a4b2bc625d48a8178b247cace162e62a32f1", "patch": "@@ -442,7 +442,7 @@ struct congruence_class_group\n };\n \n /* Congruence class set structure.  */\n-struct congruence_class_group_hash : nofree_ptr_hash <congruence_class_group>\n+struct congruence_class_hash : nofree_ptr_hash <congruence_class_group>\n {\n   static inline hashval_t hash (const congruence_class_group *item)\n   {\n@@ -610,10 +610,7 @@ class sem_item_optimizer\n   hash_set <symtab_node *> m_removed_items_set;\n \n   /* Hashtable of congruence classes.  */\n-  hash_table <congruence_class_group_hash> m_classes;\n-\n-  /* Vector of congruence classes.  */\n-  vec <congruence_class_group *> m_classes_vec;\n+  hash_table <congruence_class_hash> m_classes;\n \n   /* Count of congruence classes.  */\n   unsigned int m_classes_count;"}]}