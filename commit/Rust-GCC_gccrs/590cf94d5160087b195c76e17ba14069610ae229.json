{"sha": "590cf94d5160087b195c76e17ba14069610ae229", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkwY2Y5NGQ1MTYwMDg3YjE5NWM3NmUxN2JhMTQwNjk2MTBhZTIyOQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1998-11-04T14:30:56Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1998-11-04T14:30:56Z"}, "message": "Warning fixes:\n\n        * reload1.c (ELIMINABLE_REGS, NUM_ELIMINABLE_REGS): Introduce an\n        intermediate structure which has exactly the members provided by\n        ELIMINABLE_REGS.  Define NUM_ELIMINABLE_REGS in terms of the\n        static intermediate structure.\n        (init_elim_table): Xmalloc() `reg_eliminate', and initialize it\n        from the intermediate structure.  Do the same analogous fix in\n        the case where ELIMINABLE_REGS is not defined.\n\nFrom-SVN: r23521", "tree": {"sha": "ba5cc61e5a96278aa99043a227ee708300935b7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba5cc61e5a96278aa99043a227ee708300935b7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/590cf94d5160087b195c76e17ba14069610ae229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/590cf94d5160087b195c76e17ba14069610ae229", "html_url": "https://github.com/Rust-GCC/gccrs/commit/590cf94d5160087b195c76e17ba14069610ae229", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/590cf94d5160087b195c76e17ba14069610ae229/comments", "author": null, "committer": null, "parents": [{"sha": "1eb1d2a36950e7f2d40349b0b7c295c4dd5615ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb1d2a36950e7f2d40349b0b7c295c4dd5615ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eb1d2a36950e7f2d40349b0b7c295c4dd5615ca"}], "stats": {"total": 45, "additions": 41, "deletions": 4}, "files": [{"sha": "0f206e8a9d85624ae65905d8c6caa266847c3c41", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590cf94d5160087b195c76e17ba14069610ae229/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590cf94d5160087b195c76e17ba14069610ae229/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=590cf94d5160087b195c76e17ba14069610ae229", "patch": "@@ -1,3 +1,14 @@\n+Wed Nov  4 17:25:10 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* reload1.c (ELIMINABLE_REGS, NUM_ELIMINABLE_REGS): Introduce an\n+ \tintermediate structure which has exactly the members provided by\n+ \tELIMINABLE_REGS.  Define NUM_ELIMINABLE_REGS in terms of the\n+ \tstatic intermediate structure.\n+\t\n+\t(init_elim_table): Xmalloc() `reg_eliminate', and initialize it\n+ \tfrom the intermediate structure.  Do the same analogous fix in\n+ \tthe case where ELIMINABLE_REGS is not defined.\n+\n Tue Nov  3 20:50:03 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* pa.h (SELECT_SECTION): Fix thinko."}, {"sha": "78c30730739006a45e50a2aba0e324ea5444fe18", "filename": "gcc/reload1.c", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/590cf94d5160087b195c76e17ba14069610ae229/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/590cf94d5160087b195c76e17ba14069610ae229/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=590cf94d5160087b195c76e17ba14069610ae229", "patch": "@@ -290,7 +290,7 @@ static struct insn_chain *insns_need_reload;\n    in favor of another.   If there is more than one way of eliminating a\n    particular register, the most preferred should be specified first.  */\n \n-static struct elim_table\n+struct elim_table\n {\n   int from;\t\t\t/* Register number to be eliminated.  */\n   int to;\t\t\t/* Register number used as replacement.  */\n@@ -307,7 +307,17 @@ static struct elim_table\n \t\t\t\t   register corresponding to a pseudo\n \t\t\t\t   assigned to the reg to be eliminated.  */\n   rtx to_rtx;\t\t\t/* REG rtx for the replacement.  */\n-} reg_eliminate[] =\n+};\n+\n+static struct elim_table * reg_eliminate = 0;\n+\n+/* This is an intermediate structure to initialize the table.  It has\n+   exactly the members provided by ELIMINABLE_REGS. */\n+static struct elim_table_1\n+{\n+  int from;\n+  int to;\n+} reg_eliminate_1[] =\n \n /* If a set of eliminable registers was specified, define the table from it.\n    Otherwise, default to the normal case of the frame pointer being\n@@ -319,7 +329,7 @@ static struct elim_table\n   {{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}};\n #endif\n \n-#define NUM_ELIMINABLE_REGS (sizeof reg_eliminate / sizeof reg_eliminate[0])\n+#define NUM_ELIMINABLE_REGS (sizeof reg_eliminate_1/sizeof reg_eliminate_1[0])\n \n /* Record the number of pending eliminations that have an offset not equal\n    to their initial offset.  If non-zero, we use a new copy of each\n@@ -3611,7 +3621,18 @@ static void\n init_elim_table ()\n {\n   struct elim_table *ep;\n+#ifdef ELIMINABLE_REGS\n+  struct elim_table_1 *ep1;\n+#endif\n \n+  if (!reg_eliminate)\n+    {\n+      reg_eliminate = (struct elim_table *)\n+\txmalloc(sizeof(struct elim_table) * NUM_ELIMINABLE_REGS);\n+      bzero ((PTR) reg_eliminate,\n+\t     sizeof(struct elim_table) * NUM_ELIMINABLE_REGS);\n+    }\n+  \n   /* Does this function require a frame pointer?  */\n \n   frame_pointer_needed = (! flag_omit_frame_pointer\n@@ -3629,13 +3650,18 @@ init_elim_table ()\n   num_eliminable = 0;\n \n #ifdef ELIMINABLE_REGS\n-  for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n+  for (ep = reg_eliminate, ep1 = reg_eliminate_1;\n+       ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++, ep1++)\n     {\n+      ep->from = ep1->from;\n+      ep->to = ep1->to;\n       ep->can_eliminate = ep->can_eliminate_previous\n \t= (CAN_ELIMINATE (ep->from, ep->to)\n \t   && ! (ep->to == STACK_POINTER_REGNUM && frame_pointer_needed));\n     }\n #else\n+  reg_eliminate[0].from = reg_eliminate_1[0].from;\n+  reg_eliminate[0].to = reg_eliminate_1[0].to;\n   reg_eliminate[0].can_eliminate = reg_eliminate[0].can_eliminate_previous\n     = ! frame_pointer_needed;\n #endif"}]}