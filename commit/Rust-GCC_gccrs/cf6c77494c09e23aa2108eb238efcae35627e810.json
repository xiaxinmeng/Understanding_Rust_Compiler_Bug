{"sha": "cf6c77494c09e23aa2108eb238efcae35627e810", "node_id": "C_kwDOANBUbNoAKGNmNmM3NzQ5NGMwOWUyM2FhMjEwOGViMjM4ZWZjYWUzNTYyN2U4MTA", "commit": {"author": {"name": "Pierre-Emmanuel Patry", "email": "pierre-emmanuel.patry@embecosm.com", "date": "2023-03-21T09:39:51Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-03-30T14:48:26Z"}, "message": "ast: Add conversion to token stream\n\nAdd several functions to convert an ast back to a token stream. This may\nbe used later either to unify the ast dumping and modifications on ast\nnodes in procedural macros.\n\ngcc/rust/ChangeLog:\n\n\t* Make-lang.in: Add rust-as-tokenstream to compile list.\n\t* ast/rust-item.h: Add missing getter for location.\n\t* ast/rust-ast-tokenstream.cc: Add ast visitor implementation.\n\t* ast/rust-ast-tokenstream.h: New file.\n\t* ast/rust-pattern.h: Add getter.\n\nSigned-off-by: Pierre-Emmanuel Patry <pierre-emmanuel.patry@embecosm.com>", "tree": {"sha": "707a62eed5be543668173475edec257fdc511ad3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/707a62eed5be543668173475edec257fdc511ad3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf6c77494c09e23aa2108eb238efcae35627e810", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf6c77494c09e23aa2108eb238efcae35627e810", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf6c77494c09e23aa2108eb238efcae35627e810", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf6c77494c09e23aa2108eb238efcae35627e810/comments", "author": {"login": "P-E-P", "id": 32375388, "node_id": "MDQ6VXNlcjMyMzc1Mzg4", "avatar_url": "https://avatars.githubusercontent.com/u/32375388?v=4", "gravatar_id": "", "url": "https://api.github.com/users/P-E-P", "html_url": "https://github.com/P-E-P", "followers_url": "https://api.github.com/users/P-E-P/followers", "following_url": "https://api.github.com/users/P-E-P/following{/other_user}", "gists_url": "https://api.github.com/users/P-E-P/gists{/gist_id}", "starred_url": "https://api.github.com/users/P-E-P/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/P-E-P/subscriptions", "organizations_url": "https://api.github.com/users/P-E-P/orgs", "repos_url": "https://api.github.com/users/P-E-P/repos", "events_url": "https://api.github.com/users/P-E-P/events{/privacy}", "received_events_url": "https://api.github.com/users/P-E-P/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98735d4fe7f435170d0bbc3e5f8bee0702afe464", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98735d4fe7f435170d0bbc3e5f8bee0702afe464", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98735d4fe7f435170d0bbc3e5f8bee0702afe464"}], "stats": {"total": 2710, "additions": 2710, "deletions": 0}, "files": [{"sha": "f7f2813f5056dfff4cf29be912238857c893f9e8", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf6c77494c09e23aa2108eb238efcae35627e810/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf6c77494c09e23aa2108eb238efcae35627e810/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=cf6c77494c09e23aa2108eb238efcae35627e810", "patch": "@@ -75,6 +75,7 @@ GRS_OBJS = \\\n     rust/rust-ast.o \\\n     rust/rust-ast-fragment.o \\\n     rust/rust-ast-dump.o \\\n+    rust/rust-ast-tokenstream.o \\\n     rust/rust-hir-dump.o \\\n     rust/rust-session-manager.o \\\n     rust/rust-compile.o \\"}, {"sha": "46ccf248a576cd14c1a1f1c815ee28133145de9c", "filename": "gcc/rust/ast/rust-ast-tokenstream.cc", "status": "added", "additions": 2400, "deletions": 0, "changes": 2400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf6c77494c09e23aa2108eb238efcae35627e810/gcc%2Frust%2Fast%2Frust-ast-tokenstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf6c77494c09e23aa2108eb238efcae35627e810/gcc%2Frust%2Fast%2Frust-ast-tokenstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-tokenstream.cc?ref=cf6c77494c09e23aa2108eb238efcae35627e810", "patch": "@@ -0,0 +1,2400 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+#include \"rust-ast-tokenstream.h\"\n+\n+namespace Rust {\n+namespace AST {\n+void\n+TokenStream::go (AST::Crate &crate)\n+{\n+  visit_items_as_lines (crate.items);\n+}\n+\n+void\n+TokenStream::go (AST::Item &item)\n+{\n+  item.accept_vis (*this);\n+}\n+\n+template <typename T>\n+void\n+TokenStream::visit (std::unique_ptr<T> &node)\n+{\n+  node->accept_vis (*this);\n+}\n+\n+template <typename T>\n+void\n+TokenStream::visit (T &node)\n+{\n+  node.accept_vis (*this);\n+}\n+\n+template <typename T>\n+void\n+TokenStream::visit_items_joined_by_separator (T &collection, TokenId separator,\n+\t\t\t\t\t      size_t start_offset,\n+\t\t\t\t\t      size_t end_offset)\n+{\n+  if (collection.size () > start_offset)\n+    {\n+      visit (collection.at (start_offset));\n+      auto size = collection.size () - end_offset;\n+      for (size_t i = start_offset + 1; i < size; i++)\n+\t{\n+\t  tokens.push_back (Rust::Token::make (separator, Location ()));\n+\t  visit (collection.at (i));\n+\t}\n+    }\n+}\n+\n+template <typename T>\n+void\n+TokenStream::visit_as_line (T &item, std::vector<TokenPtr> trailing)\n+{\n+  visit (item);\n+  for (auto &token : trailing)\n+    tokens.push_back (token);\n+}\n+\n+template <typename T>\n+void\n+TokenStream::visit_items_as_lines (T &collection,\n+\t\t\t\t   std::vector<TokenPtr> trailing)\n+{\n+  for (auto &item : collection)\n+    visit_as_line (item);\n+}\n+\n+template <typename T>\n+void\n+TokenStream::visit_items_as_block (T &collection,\n+\t\t\t\t   std::vector<TokenPtr> trailing,\n+\t\t\t\t   TokenId left_brace, TokenId right_brace)\n+{\n+  tokens.push_back (Rust::Token::make (left_brace, Location ()));\n+  visit_items_as_lines (collection);\n+  tokens.push_back (Rust::Token::make (right_brace, Location ()));\n+}\n+\n+void\n+TokenStream::visit (FunctionParam &param)\n+{\n+  visit (param.get_pattern ());\n+  tokens.push_back (Rust::Token::make (COLON, Location ()));\n+  visit (param.get_type ());\n+}\n+\n+void\n+TokenStream::visit (Attribute &attrib)\n+{\n+  tokens.push_back (Rust::Token::make (HASH, attrib.get_locus ()));\n+  tokens.push_back (Rust::Token::make (LEFT_SQUARE, Location ()));\n+  visit_items_joined_by_separator (attrib.get_path ().get_segments (),\n+\t\t\t\t   SCOPE_RESOLUTION);\n+\n+  if (attrib.has_attr_input ())\n+    {\n+      tokens.push_back (Rust::Token::make (EQUAL, Location ()));\n+\n+      switch (attrib.get_attr_input ().get_attr_input_type ())\n+\t{\n+\t  case AST::AttrInput::AttrInputType::LITERAL: {\n+\t    auto &literal\n+\t      = static_cast<AST::AttrInputLiteral &> (attrib.get_attr_input ())\n+\t\t  .get_literal ();\n+\t    auto value = literal.as_string ();\n+\t    tokens.push_back (Rust::Token::make (DOUBLE_QUOTE, Location ()));\n+\t    tokens.push_back (Rust::Token::make_string (literal.get_locus (),\n+\t\t\t\t\t\t\tstd::move (value)));\n+\t    tokens.push_back (Rust::Token::make (DOUBLE_QUOTE, Location ()));\n+\t    break;\n+\t  }\n+\t  case AST::AttrInput::AttrInputType::META_ITEM: {\n+\t    // FIXME: Implement this\n+\t    break;\n+\t  }\n+\t  case AST::AttrInput::AttrInputType::TOKEN_TREE: {\n+\t    // FIXME: Implement this\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  tokens.push_back (Rust::Token::make (RIGHT_SQUARE, Location ()));\n+}\n+\n+void\n+TokenStream::visit (SimplePathSegment &segment)\n+{\n+  auto name = segment.get_segment_name ();\n+  if (segment.is_crate_path_seg ())\n+    {\n+      tokens.push_back (Rust::Token::make (CRATE, segment.get_locus ()));\n+    }\n+  else if (segment.is_super_path_seg ())\n+    {\n+      tokens.push_back (Rust::Token::make (SUPER, segment.get_locus ()));\n+    }\n+  else if (segment.is_lower_self ())\n+    {\n+      tokens.push_back (Rust::Token::make (SELF, segment.get_locus ()));\n+    }\n+  else if (segment.is_big_self ())\n+    {\n+      tokens.push_back (Rust::Token::make (SELF_ALIAS, segment.get_locus ()));\n+    }\n+  else\n+    {\n+      tokens.push_back (\n+\tRust::Token::make_identifier (segment.get_locus (), std::move (name)));\n+    }\n+}\n+\n+void\n+TokenStream::visit (Visibility &vis)\n+{\n+  switch (vis.get_vis_type ())\n+    {\n+    case Visibility::PUB:\n+      tokens.push_back (Rust::Token::make (PUB, vis.get_locus ()));\n+      break;\n+    case Visibility::PUB_CRATE:\n+      tokens.push_back (Rust::Token::make (PUB, vis.get_locus ()));\n+      tokens.push_back (Rust::Token::make (LEFT_PAREN, Location ()));\n+      tokens.push_back (Rust::Token::make (CRATE, Location ()));\n+      tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+      break;\n+    case Visibility::PUB_SELF:\n+      tokens.push_back (Rust::Token::make (PUB, vis.get_locus ()));\n+      tokens.push_back (Rust::Token::make (LEFT_PAREN, Location ()));\n+      tokens.push_back (Rust::Token::make (SELF, Location ()));\n+      tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+      break;\n+    case Visibility::PUB_SUPER:\n+      tokens.push_back (Rust::Token::make (PUB, vis.get_locus ()));\n+      tokens.push_back (Rust::Token::make (LEFT_PAREN, Location ()));\n+      tokens.push_back (Rust::Token::make (SUPER, Location ()));\n+      tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+      break;\n+    case Visibility::PUB_IN_PATH:\n+      tokens.push_back (Rust::Token::make (PUB, vis.get_locus ()));\n+      tokens.push_back (Rust::Token::make (LEFT_PAREN, Location ()));\n+      tokens.push_back (Rust::Token::make_identifier (Location (), \"in\"));\n+      visit_items_joined_by_separator (vis.get_path ().get_segments (),\n+\t\t\t\t       SCOPE_RESOLUTION);\n+      tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+      break;\n+    case Visibility::PRIV:\n+      break;\n+    }\n+}\n+\n+void\n+TokenStream::visit (NamedFunctionParam &param)\n+{\n+  auto name = param.get_name ();\n+  tokens.push_back (\n+    Rust::Token::make_identifier (param.get_locus (), std::move (name)));\n+  tokens.push_back (Rust::Token::make (COLON, Location ()));\n+  visit (param.get_type ());\n+}\n+\n+void\n+TokenStream::visit (std::vector<std::unique_ptr<GenericParam>> &params)\n+{\n+  tokens.push_back (Rust::Token::make (LEFT_ANGLE, Location ()));\n+  visit_items_joined_by_separator (params, COMMA);\n+  tokens.push_back (Rust::Token::make (RIGHT_ANGLE, Location ()));\n+}\n+\n+void\n+TokenStream::visit (TupleField &field)\n+{\n+  for (auto attr : field.get_outer_attrs ())\n+    {\n+      visit (attr);\n+    }\n+  visit (field.get_visibility ());\n+  visit (field.get_field_type ());\n+}\n+\n+void\n+TokenStream::visit (StructField &field)\n+{\n+  for (auto attr : field.get_outer_attrs ())\n+    {\n+      visit (attr);\n+    }\n+  visit (field.get_visibility ());\n+  auto name = field.get_field_name ();\n+  tokens.push_back (\n+    Rust::Token::make_identifier (field.get_locus (), std::move (name)));\n+  tokens.push_back (Rust::Token::make (COLON, Location ()));\n+  visit (field.get_field_type ());\n+}\n+\n+void\n+TokenStream::visit (std::vector<LifetimeParam> &for_lifetimes)\n+{\n+  tokens.push_back (Rust::Token::make (FOR, Location ()));\n+  tokens.push_back (Rust::Token::make (LEFT_ANGLE, Location ()));\n+  visit_items_joined_by_separator (for_lifetimes, COMMA);\n+  tokens.push_back (Rust::Token::make (RIGHT_ANGLE, Location ()));\n+}\n+\n+void\n+TokenStream::visit (FunctionQualifiers &qualifiers)\n+{\n+  // Syntax:\n+  //    `const`? `async`? `unsafe`? (`extern` Abi?)?\n+  //    unsafe? (extern Abi?)?\n+\n+  switch (qualifiers.get_const_status ())\n+    {\n+    case NONE:\n+      break;\n+    case CONST_FN:\n+      tokens.push_back (Rust::Token::make (CONST, qualifiers.get_locus ()));\n+      break;\n+    case ASYNC_FN:\n+      tokens.push_back (Rust::Token::make (ASYNC, qualifiers.get_locus ()));\n+      break;\n+    }\n+\n+  if (qualifiers.is_unsafe ())\n+    tokens.push_back (Rust::Token::make (UNSAFE, qualifiers.get_locus ()));\n+  if (qualifiers.is_extern ())\n+    {\n+      tokens.push_back (\n+\tRust::Token::make (EXTERN_TOK, qualifiers.get_locus ()));\n+      if (qualifiers.has_abi ())\n+\t{\n+\t  tokens.push_back (Rust::Token::make (DOUBLE_QUOTE, Location ()));\n+\t  auto abi = qualifiers.get_extern_abi ();\n+\t  tokens.push_back (\n+\t    Rust::Token::make_identifier (Location (), std::move (abi)));\n+\t  tokens.push_back (Rust::Token::make (DOUBLE_QUOTE, Location ()));\n+\t}\n+    }\n+}\n+\n+void\n+TokenStream::visit (MaybeNamedParam &param)\n+{\n+  // Syntax:\n+  //     OuterAttribute* ( ( IDENTIFIER | _ ) : )? Type\n+\n+  for (auto attr : param.get_outer_attrs ())\n+    {\n+      visit (attr);\n+    }\n+  auto param_name = param.get_name ();\n+  switch (param.get_param_kind ())\n+    {\n+    case MaybeNamedParam::UNNAMED:\n+      break;\n+    case MaybeNamedParam::IDENTIFIER:\n+      tokens.push_back (\n+\tRust::Token::make_identifier (Location (), std::move (param_name)));\n+      tokens.push_back (Rust::Token::make (COLON, Location ()));\n+      break;\n+    case MaybeNamedParam::WILDCARD:\n+      tokens.push_back (Rust::Token::make (UNDERSCORE, Location ()));\n+      tokens.push_back (Rust::Token::make (COLON, Location ()));\n+      break;\n+    }\n+  visit (param.get_type ());\n+}\n+\n+void\n+TokenStream::visit (Token &tok)\n+{\n+  tokens.push_back (Rust::Token::make (tok.get_id (), tok.get_locus ()));\n+}\n+\n+void\n+TokenStream::visit (DelimTokenTree &delim_tok_tree)\n+{\n+  for (auto &token : delim_tok_tree.to_token_stream ())\n+    {\n+      visit (token);\n+    }\n+}\n+\n+void\n+TokenStream::visit (AttrInputMetaItemContainer &container)\n+{}\n+\n+void\n+TokenStream::visit (IdentifierExpr &ident_expr)\n+{\n+  auto ident = ident_expr.get_ident ();\n+  tokens.push_back (\n+    Rust::Token::make_identifier (ident_expr.get_locus (), std::move (ident)));\n+}\n+\n+void\n+TokenStream::visit (Lifetime &lifetime)\n+{\n+  // Syntax:\n+  // Lifetime :\n+  // \tLIFETIME_OR_LABEL\n+  // \t| 'static\n+  // \t| '_\n+\n+  auto name = lifetime.get_lifetime_name ();\n+  switch (lifetime.get_lifetime_type ())\n+    {\n+    case Lifetime::LifetimeType::NAMED:\n+      tokens.push_back (\n+\tRust::Token::make_lifetime (lifetime.get_locus (), std::move (name)));\n+      break;\n+    case Lifetime::LifetimeType::STATIC:\n+      tokens.push_back (Rust::Token::make_lifetime (lifetime.get_locus (),\n+\t\t\t\t\t\t    std::move (\"static\")));\n+      break;\n+    case Lifetime::LifetimeType::WILDCARD:\n+      tokens.push_back (\n+\tRust::Token::make_lifetime (lifetime.get_locus (), std::move (\"_\")));\n+      break;\n+    }\n+}\n+\n+void\n+TokenStream::visit (LifetimeParam &lifetime_param)\n+{\n+  // Syntax:\n+  //   LIFETIME_OR_LABEL ( : LifetimeBounds )?\n+  // LifetimeBounds :\n+  //   ( Lifetime + )* Lifetime?\n+\n+  // TODO what to do with outer attr? They are not mentioned in the reference.\n+\n+  auto lifetime = lifetime_param.get_lifetime ();\n+  visit (lifetime);\n+\n+  if (lifetime_param.has_lifetime_bounds ())\n+    {\n+      tokens.push_back (Rust::Token::make (COLON, Location ()));\n+      for (auto &bound : lifetime_param.get_lifetime_bounds ())\n+\t{\n+\t  visit (bound);\n+\t}\n+    }\n+}\n+\n+void\n+TokenStream::visit (ConstGenericParam &)\n+{}\n+\n+void\n+TokenStream::visit (PathInExpression &path)\n+{\n+  if (path.opening_scope_resolution ())\n+    {\n+      tokens.push_back (\n+\tRust::Token::make (SCOPE_RESOLUTION, path.get_locus ()));\n+    }\n+\n+  for (auto &segment : path.get_segments ())\n+    {\n+      auto ident_segment = segment.get_ident_segment ();\n+      // TODO: Add visitor pattern to PathIdentSegment ?\n+      if (ident_segment.is_super_segment ())\n+\t{\n+\t  tokens.push_back (\n+\t    Rust::Token::make (SUPER, ident_segment.get_locus ()));\n+\t}\n+      else if (ident_segment.is_crate_segment ())\n+\t{\n+\t  tokens.push_back (\n+\t    Rust::Token::make (CRATE, ident_segment.get_locus ()));\n+\t}\n+      else if (ident_segment.is_lower_self ())\n+\t{\n+\t  tokens.push_back (\n+\t    Rust::Token::make (SELF, ident_segment.get_locus ()));\n+\t}\n+      else if (ident_segment.is_big_self ())\n+\t{\n+\t  tokens.push_back (\n+\t    Rust::Token::make (SELF_ALIAS, ident_segment.get_locus ()));\n+\t}\n+      else\n+\t{\n+\t  auto id = ident_segment.as_string ();\n+\t  tokens.push_back (\n+\t    Rust::Token::make_identifier (ident_segment.get_locus (),\n+\t\t\t\t\t  std::move (id)));\n+\t}\n+      if (segment.has_generic_args ())\n+\t{\n+\t  auto generics = segment.get_generic_args ();\n+\t  tokens.push_back (\n+\t    Rust::Token::make (SCOPE_RESOLUTION, path.get_locus ()));\n+\t  tokens.push_back (\n+\t    Rust::Token::make (LEFT_ANGLE, generics.get_locus ()));\n+\n+\t  auto &lifetime_args = generics.get_lifetime_args ();\n+\t  auto &generic_args = generics.get_generic_args ();\n+\t  auto &binding_args = generics.get_binding_args ();\n+\n+\t  visit_items_joined_by_separator (generic_args, COMMA);\n+\n+\t  if (!lifetime_args.empty ()\n+\t      && (!generic_args.empty () || !binding_args.empty ()))\n+\t    {\n+\t      tokens.push_back (Rust::Token::make (COMMA, Location ()));\n+\t    }\n+\n+\t  visit_items_joined_by_separator (binding_args, COMMA);\n+\n+\t  if (!generic_args.empty () && !binding_args.empty ())\n+\t    {\n+\t      tokens.push_back (Rust::Token::make (COMMA, Location ()));\n+\t    }\n+\n+\t  visit_items_joined_by_separator (lifetime_args, COMMA);\n+\n+\t  tokens.push_back (Rust::Token::make (RIGHT_ANGLE, Location ()));\n+\t}\n+    }\n+}\n+\n+void\n+TokenStream::visit (TypePathSegment &segment)\n+{\n+  // Syntax:\n+  //    PathIdentSegment\n+  auto ident_segment = segment.get_ident_segment ();\n+  auto id = ident_segment.as_string ();\n+  tokens.push_back (\n+    Rust::Token::make_identifier (ident_segment.get_locus (), std::move (id)));\n+}\n+\n+void\n+TokenStream::visit (TypePathSegmentGeneric &segment)\n+{\n+  // Syntax:\n+  //    PathIdentSegment `::`? (GenericArgs)?\n+  // GenericArgs :\n+  //    `<` `>`\n+  //    | `<` ( GenericArg `,` )* GenericArg `,`? `>`\n+\n+  auto ident_segment = segment.get_ident_segment ();\n+  auto id = ident_segment.as_string ();\n+  tokens.push_back (\n+    Rust::Token::make_identifier (ident_segment.get_locus (), std::move (id)));\n+\n+  if (segment.get_separating_scope_resolution ())\n+    tokens.push_back (Rust::Token::make (SCOPE_RESOLUTION, Location ()));\n+\n+  tokens.push_back (Rust::Token::make (LEFT_ANGLE, Location ()));\n+\n+  {\n+    auto &lifetime_args = segment.get_generic_args ().get_lifetime_args ();\n+    auto &generic_args = segment.get_generic_args ().get_generic_args ();\n+    auto &binding_args = segment.get_generic_args ().get_binding_args ();\n+\n+    visit_items_joined_by_separator (lifetime_args, COMMA);\n+    if (!lifetime_args.empty ()\n+\t&& (!generic_args.empty () || !binding_args.empty ()))\n+      tokens.push_back (Rust::Token::make (COMMA, Location ()));\n+    visit_items_joined_by_separator (generic_args, COMMA);\n+    if (!generic_args.empty () && !binding_args.empty ())\n+      tokens.push_back (Rust::Token::make (COMMA, Location ()));\n+    visit_items_joined_by_separator (generic_args, COMMA);\n+  }\n+\n+  tokens.push_back (Rust::Token::make (RIGHT_ANGLE, Location ()));\n+}\n+\n+void\n+TokenStream::visit (GenericArgsBinding &binding)\n+{\n+  // Syntax:\n+  //    IDENTIFIER `=` Type\n+  auto identifier = binding.get_identifier ();\n+  tokens.push_back (Rust::Token::make_identifier (binding.get_locus (),\n+\t\t\t\t\t\t  std::move (identifier)));\n+\n+  tokens.push_back (Rust::Token::make (EQUAL, Location ()));\n+  visit (binding.get_type ());\n+}\n+\n+void\n+TokenStream::visit (GenericArg &arg)\n+{\n+  // `GenericArg` implements `accept_vis` but it is not useful for this case as\n+  // it ignores unresolved cases (`Kind::Either`).\n+  auto path = arg.get_path ();\n+  switch (arg.get_kind ())\n+    {\n+    case GenericArg::Kind::Const:\n+      visit (arg.get_expression ());\n+      break;\n+    case GenericArg::Kind::Type:\n+      visit (arg.get_type ());\n+      break;\n+    case GenericArg::Kind::Either:\n+      tokens.push_back (\n+\tRust::Token::make_identifier (Location (), std::move (path)));\n+      break;\n+    case GenericArg::Kind::Error:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+void\n+TokenStream::visit (TypePathSegmentFunction &segment)\n+{\n+  // Syntax:\n+  //   PathIdentSegment `::`? (TypePathFn)?\n+\n+  auto ident_segment = segment.get_ident_segment ();\n+  auto id = ident_segment.as_string ();\n+  tokens.push_back (\n+    Rust::Token::make_identifier (ident_segment.get_locus (), std::move (id)));\n+\n+  if (segment.get_separating_scope_resolution ())\n+    tokens.push_back (Rust::Token::make (SCOPE_RESOLUTION, Location ()));\n+\n+  if (!segment.is_ident_only ())\n+    visit (segment.get_type_path_function ());\n+}\n+\n+void\n+TokenStream::visit (TypePathFunction &type_path_fn)\n+{\n+  // Syntax:\n+  //   `(` TypePathFnInputs? `)` (`->` Type)?\n+  // TypePathFnInputs :\n+  //   Type (`,` Type)* `,`?\n+\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, type_path_fn.get_locus ()));\n+  if (type_path_fn.has_inputs ())\n+    visit_items_joined_by_separator (type_path_fn.get_params (), COMMA);\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+\n+  if (type_path_fn.has_return_type ())\n+    {\n+      tokens.push_back (Rust::Token::make (RETURN_TYPE, Location ()));\n+      visit (type_path_fn.get_return_type ());\n+    }\n+}\n+\n+void\n+TokenStream::visit (TypePath &path)\n+{\n+  // Syntax:\n+  //    `::`? TypePathSegment (`::` TypePathSegment)*\n+\n+  if (path.has_opening_scope_resolution_op ())\n+    tokens.push_back (Rust::Token::make (SCOPE_RESOLUTION, path.get_locus ()));\n+\n+  visit_items_joined_by_separator (path.get_segments (), SCOPE_RESOLUTION);\n+}\n+\n+void\n+TokenStream::visit (QualifiedPathInExpression &path)\n+{\n+  for (auto &segment : path.get_segments ())\n+    {\n+      auto ident_segment = segment.get_ident_segment ();\n+      if (ident_segment.is_super_segment ())\n+\t{\n+\t  tokens.push_back (\n+\t    Rust::Token::make (SUPER, ident_segment.get_locus ()));\n+\t}\n+      else if (ident_segment.is_crate_segment ())\n+\t{\n+\t  tokens.push_back (\n+\t    Rust::Token::make (CRATE, ident_segment.get_locus ()));\n+\t}\n+      else if (ident_segment.is_lower_self ())\n+\t{\n+\t  tokens.push_back (\n+\t    Rust::Token::make (SELF, ident_segment.get_locus ()));\n+\t}\n+      else if (ident_segment.is_big_self ())\n+\t{\n+\t  tokens.push_back (\n+\t    Rust::Token::make (SELF_ALIAS, ident_segment.get_locus ()));\n+\t}\n+      else\n+\t{\n+\t  auto id = ident_segment.as_string ();\n+\t  tokens.push_back (\n+\t    Rust::Token::make_identifier (ident_segment.get_locus (),\n+\t\t\t\t\t  std::move (id)));\n+\t}\n+      if (segment.has_generic_args ())\n+\t{\n+\t  auto generics = segment.get_generic_args ();\n+\t  tokens.push_back (\n+\t    Rust::Token::make (SCOPE_RESOLUTION, path.get_locus ()));\n+\t  tokens.push_back (\n+\t    Rust::Token::make (LEFT_ANGLE, generics.get_locus ()));\n+\n+\t  auto &lifetime_args = generics.get_lifetime_args ();\n+\t  auto &generic_args = generics.get_generic_args ();\n+\t  auto &binding_args = generics.get_binding_args ();\n+\n+\t  visit_items_joined_by_separator (generic_args, COMMA);\n+\n+\t  if (!lifetime_args.empty ()\n+\t      && (!generic_args.empty () || !binding_args.empty ()))\n+\t    {\n+\t      tokens.push_back (Rust::Token::make (COMMA, Location ()));\n+\t    }\n+\n+\t  visit_items_joined_by_separator (binding_args, COMMA);\n+\n+\t  if (!generic_args.empty () && !binding_args.empty ())\n+\t    {\n+\t      tokens.push_back (Rust::Token::make (COMMA, Location ()));\n+\t    }\n+\n+\t  visit_items_joined_by_separator (lifetime_args, COMMA);\n+\n+\t  tokens.push_back (Rust::Token::make (RIGHT_ANGLE, Location ()));\n+\t}\n+    }\n+}\n+\n+void\n+TokenStream::visit (QualifiedPathInType &)\n+{}\n+\n+void\n+TokenStream::visit (Literal &lit, Location locus)\n+{\n+  auto value = lit.as_string ();\n+  switch (lit.get_lit_type ())\n+    {\n+    case Literal::LitType::CHAR:\n+      tokens.push_back (Rust::Token::make_char (\n+\tlocus, Codepoint (static_cast<uint32_t> (std::stoul (value)))));\n+      break;\n+    case Literal::LitType::STRING:\n+      tokens.push_back (Rust::Token::make_string (locus, std::move (value)));\n+      break;\n+    case Literal::LitType::BYTE:\n+      tokens.push_back (Rust::Token::make_byte_char (locus, value[0]));\n+      break;\n+    case Literal::LitType::BYTE_STRING:\n+      tokens.push_back (\n+\tRust::Token::make_byte_string (locus, std::move (value)));\n+      break;\n+    case Literal::LitType::INT:\n+      tokens.push_back (Rust::Token::make_int (locus, std::move (value)));\n+      break;\n+    case Literal::LitType::FLOAT:\n+      tokens.push_back (Rust::Token::make_float (locus, std::move (value)));\n+      break;\n+      case Literal::LitType::BOOL: {\n+\tif (value == \"false\")\n+\t  tokens.push_back (Rust::Token::make (FALSE_LITERAL, locus));\n+\telse if (value == \"true\")\n+\t  tokens.push_back (Rust::Token::make (TRUE_LITERAL, locus));\n+\telse\n+\t  gcc_unreachable (); // Not a boolean\n+\tbreak;\n+      }\n+    case Literal::LitType::ERROR:\n+      gcc_unreachable ();\n+      break;\n+    }\n+}\n+\n+void\n+TokenStream::visit (LiteralExpr &expr)\n+{\n+  auto lit = expr.get_literal ();\n+  visit (lit, expr.get_locus ());\n+}\n+\n+void\n+TokenStream::visit (AttrInputLiteral &)\n+{}\n+\n+void\n+TokenStream::visit (MetaItemLitExpr &)\n+{}\n+\n+void\n+TokenStream::visit (MetaItemPathLit &)\n+{}\n+\n+void\n+TokenStream::visit (BorrowExpr &expr)\n+{\n+  tokens.push_back (Rust::Token::make (AMP, expr.get_locus ()));\n+  if (expr.get_is_double_borrow ())\n+    tokens.push_back (Rust::Token::make (AMP, Location ()));\n+  if (expr.get_is_mut ())\n+    tokens.push_back (Rust::Token::make (MUT, Location ()));\n+\n+  visit (expr.get_borrowed_expr ());\n+}\n+\n+void\n+TokenStream::visit (DereferenceExpr &expr)\n+{\n+  tokens.push_back (Rust::Token::make (ASTERISK, expr.get_locus ()));\n+  visit (expr.get_dereferenced_expr ());\n+}\n+\n+void\n+TokenStream::visit (ErrorPropagationExpr &expr)\n+{\n+  visit (expr.get_propagating_expr ());\n+  tokens.push_back (Rust::Token::make (QUESTION_MARK, expr.get_locus ()));\n+}\n+\n+void\n+TokenStream::visit (NegationExpr &expr)\n+{\n+  switch (expr.get_expr_type ())\n+    {\n+    case NegationOperator::NEGATE:\n+      tokens.push_back (Rust::Token::make (MINUS, expr.get_locus ()));\n+      break;\n+    case NegationOperator::NOT:\n+      tokens.push_back (Rust::Token::make (EXCLAM, expr.get_locus ()));\n+      break;\n+    }\n+  visit (expr.get_negated_expr ());\n+}\n+\n+void\n+TokenStream::visit (ArithmeticOrLogicalExpr &expr)\n+{\n+  visit (expr.get_left_expr ());\n+  switch (expr.get_expr_type ())\n+    {\n+    case ArithmeticOrLogicalOperator::ADD:\n+      tokens.push_back (Rust::Token::make (PLUS, expr.get_locus ()));\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::SUBTRACT:\n+      tokens.push_back (Rust::Token::make (MINUS, expr.get_locus ()));\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::MULTIPLY:\n+      tokens.push_back (Rust::Token::make (ASTERISK, expr.get_locus ()));\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::DIVIDE:\n+      tokens.push_back (Rust::Token::make (DIV, expr.get_locus ()));\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::MODULUS:\n+      tokens.push_back (Rust::Token::make (PERCENT, expr.get_locus ()));\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::BITWISE_AND:\n+      tokens.push_back (Rust::Token::make (AMP, expr.get_locus ()));\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::BITWISE_OR:\n+      tokens.push_back (Rust::Token::make (PIPE, expr.get_locus ()));\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::BITWISE_XOR:\n+      tokens.push_back (Rust::Token::make (CARET, expr.get_locus ()));\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+      tokens.push_back (Rust::Token::make (LEFT_SHIFT, expr.get_locus ()));\n+      break;\n+\n+    case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n+      tokens.push_back (Rust::Token::make (RIGHT_SHIFT, expr.get_locus ()));\n+      break;\n+    }\n+\n+  visit (expr.get_right_expr ());\n+}\n+\n+void\n+TokenStream::visit (ComparisonExpr &expr)\n+{\n+  visit (expr.get_left_expr ());\n+\n+  switch (expr.get_expr_type ())\n+    {\n+    case ComparisonOperator::EQUAL:\n+      tokens.push_back (Rust::Token::make (EQUAL_EQUAL, expr.get_locus ()));\n+      break;\n+    case ComparisonOperator::NOT_EQUAL:\n+      tokens.push_back (Rust::Token::make (NOT_EQUAL, expr.get_locus ()));\n+      break;\n+    case ComparisonOperator::GREATER_THAN:\n+      tokens.push_back (Rust::Token::make (RIGHT_ANGLE, expr.get_locus ()));\n+      break;\n+    case ComparisonOperator::LESS_THAN:\n+      tokens.push_back (Rust::Token::make (LEFT_ANGLE, expr.get_locus ()));\n+      break;\n+    case ComparisonOperator::GREATER_OR_EQUAL:\n+      tokens.push_back (\n+\tRust::Token::make (GREATER_OR_EQUAL, expr.get_locus ()));\n+      break;\n+\n+    case ComparisonOperator::LESS_OR_EQUAL:\n+      tokens.push_back (Rust::Token::make (LESS_OR_EQUAL, expr.get_locus ()));\n+      break;\n+    }\n+  visit (expr.get_right_expr ());\n+}\n+\n+void\n+TokenStream::visit (LazyBooleanExpr &expr)\n+{\n+  visit (expr.get_left_expr ());\n+\n+  switch (expr.get_expr_type ())\n+    {\n+    case LazyBooleanOperator::LOGICAL_AND:\n+      tokens.push_back (Rust::Token::make (LOGICAL_AND, expr.get_locus ()));\n+      break;\n+    case LazyBooleanOperator::LOGICAL_OR:\n+      tokens.push_back (Rust::Token::make (OR, expr.get_locus ()));\n+      break;\n+    }\n+\n+  visit (expr.get_right_expr ());\n+}\n+\n+void\n+TokenStream::visit (TypeCastExpr &expr)\n+{\n+  visit (expr.get_casted_expr ());\n+  tokens.push_back (Rust::Token::make (AS, expr.get_locus ()));\n+  visit (expr.get_type_to_cast_to ());\n+}\n+\n+void\n+TokenStream::visit (AssignmentExpr &expr)\n+{\n+  expr.visit_lhs (*this);\n+  tokens.push_back (Rust::Token::make (EQUAL, expr.get_locus ()));\n+  expr.visit_rhs (*this);\n+}\n+\n+void\n+TokenStream::visit (CompoundAssignmentExpr &expr)\n+{\n+  visit (expr.get_left_expr ());\n+\n+  switch (expr.get_expr_type ())\n+    {\n+    case CompoundAssignmentOperator::ADD:\n+      tokens.push_back (Rust::Token::make (PLUS_EQ, expr.get_locus ()));\n+      break;\n+    case CompoundAssignmentOperator::SUBTRACT:\n+      tokens.push_back (Rust::Token::make (MINUS_EQ, expr.get_locus ()));\n+      break;\n+    case CompoundAssignmentOperator::MULTIPLY:\n+      tokens.push_back (Rust::Token::make (ASTERISK_EQ, expr.get_locus ()));\n+      break;\n+    case CompoundAssignmentOperator::DIVIDE:\n+      tokens.push_back (Rust::Token::make (DIV_EQ, expr.get_locus ()));\n+      break;\n+    case CompoundAssignmentOperator::MODULUS:\n+      tokens.push_back (Rust::Token::make (PERCENT_EQ, expr.get_locus ()));\n+      break;\n+    case CompoundAssignmentOperator::BITWISE_AND:\n+      tokens.push_back (Rust::Token::make (AMP_EQ, expr.get_locus ()));\n+      break;\n+    case CompoundAssignmentOperator::BITWISE_OR:\n+      tokens.push_back (Rust::Token::make (PIPE_EQ, expr.get_locus ()));\n+      break;\n+    case CompoundAssignmentOperator::BITWISE_XOR:\n+      tokens.push_back (Rust::Token::make (CARET_EQ, expr.get_locus ()));\n+      break;\n+    case CompoundAssignmentOperator::LEFT_SHIFT:\n+      tokens.push_back (Rust::Token::make (LEFT_SHIFT_EQ, expr.get_locus ()));\n+      break;\n+    case CompoundAssignmentOperator::RIGHT_SHIFT:\n+      tokens.push_back (Rust::Token::make (RIGHT_SHIFT_EQ, expr.get_locus ()));\n+      break;\n+    }\n+  visit (expr.get_right_expr ());\n+}\n+\n+void\n+TokenStream::visit (GroupedExpr &expr)\n+{\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, expr.get_locus ()));\n+  visit (expr.get_expr_in_parens ());\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, expr.get_locus ()));\n+}\n+\n+void\n+TokenStream::visit (ArrayElemsValues &elems)\n+{\n+  visit_items_joined_by_separator (elems.get_values (), COMMA);\n+}\n+\n+void\n+TokenStream::visit (ArrayElemsCopied &elems)\n+{\n+  visit (elems.get_elem_to_copy ());\n+  tokens.push_back (Rust::Token::make (SEMICOLON, Location ()));\n+  visit (elems.get_num_copies ());\n+}\n+\n+void\n+TokenStream::visit (ArrayExpr &expr)\n+{\n+  tokens.push_back (Rust::Token::make (LEFT_SQUARE, expr.get_locus ()));\n+  visit (expr.get_array_elems ());\n+  tokens.push_back (Rust::Token::make (RIGHT_SQUARE, Location ()));\n+}\n+\n+void\n+TokenStream::visit (ArrayIndexExpr &expr)\n+{\n+  visit (expr.get_array_expr ());\n+  tokens.push_back (Rust::Token::make (LEFT_SQUARE, expr.get_locus ()));\n+  visit (expr.get_index_expr ());\n+  tokens.push_back (Rust::Token::make (RIGHT_SQUARE, Location ()));\n+}\n+\n+void\n+TokenStream::visit (TupleExpr &)\n+{}\n+\n+void\n+TokenStream::visit (TupleIndexExpr &)\n+{}\n+\n+void\n+TokenStream::visit (StructExprStruct &)\n+{}\n+\n+void\n+TokenStream::visit (StructExprFieldIdentifier &)\n+{}\n+\n+void\n+TokenStream::visit (StructExprFieldIdentifierValue &)\n+{}\n+\n+void\n+TokenStream::visit (StructExprFieldIndexValue &)\n+{}\n+\n+void\n+TokenStream::visit (StructExprStructFields &)\n+{}\n+\n+void\n+TokenStream::visit (StructExprStructBase &)\n+{}\n+\n+void\n+TokenStream::visit (CallExpr &expr)\n+{\n+  visit (expr.get_function_expr ());\n+\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, Location ()));\n+\n+  visit_items_joined_by_separator (expr.get_params (), COMMA);\n+\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+}\n+\n+void\n+TokenStream::visit (MethodCallExpr &)\n+{}\n+\n+void\n+TokenStream::visit (FieldAccessExpr &)\n+{}\n+\n+void\n+TokenStream::visit (ClosureExprInner &)\n+{}\n+\n+void\n+TokenStream::visit (BlockExpr &expr)\n+{\n+  tokens.push_back (Rust::Token::make (LEFT_CURLY, expr.get_locus ()));\n+\n+  visit_items_joined_by_separator (expr.get_statements (), SEMICOLON);\n+\n+  if (expr.has_tail_expr ())\n+    visit (expr.get_tail_expr ());\n+\n+  tokens.push_back (Rust::Token::make (RIGHT_CURLY, expr.get_locus ()));\n+}\n+\n+void\n+TokenStream::visit (ClosureExprInnerTyped &)\n+{}\n+\n+void\n+TokenStream::visit (ContinueExpr &)\n+{}\n+\n+void\n+TokenStream::visit (BreakExpr &)\n+{}\n+\n+void\n+TokenStream::visit (RangeFromToExpr &expr)\n+{\n+  visit (expr.get_from_expr ());\n+  tokens.push_back (Rust::Token::make (DOT_DOT, expr.get_locus ()));\n+  visit (expr.get_to_expr ());\n+}\n+\n+void\n+TokenStream::visit (RangeFromExpr &expr)\n+{\n+  visit (expr.get_from_expr ());\n+  tokens.push_back (Rust::Token::make (DOT_DOT, expr.get_locus ()));\n+}\n+\n+void\n+TokenStream::visit (RangeToExpr &expr)\n+{\n+  tokens.push_back (Rust::Token::make (DOT_DOT, expr.get_locus ()));\n+  visit (expr.get_to_expr ());\n+}\n+\n+void\n+TokenStream::visit (RangeFullExpr &expr)\n+{\n+  tokens.push_back (Rust::Token::make (DOT_DOT, expr.get_locus ()));\n+}\n+\n+void\n+TokenStream::visit (RangeFromToInclExpr &expr)\n+{\n+  visit (expr.get_from_expr ());\n+  tokens.push_back (Rust::Token::make (DOT_DOT_EQ, expr.get_locus ()));\n+  visit (expr.get_to_expr ());\n+}\n+\n+void\n+TokenStream::visit (RangeToInclExpr &expr)\n+{\n+  tokens.push_back (Rust::Token::make (DOT_DOT_EQ, expr.get_locus ()));\n+  visit (expr.get_to_expr ());\n+}\n+\n+void\n+TokenStream::visit (ReturnExpr &)\n+{}\n+\n+void\n+TokenStream::visit (UnsafeBlockExpr &)\n+{}\n+\n+void\n+TokenStream::visit (LoopExpr &)\n+{}\n+\n+void\n+TokenStream::visit (WhileLoopExpr &)\n+{}\n+\n+void\n+TokenStream::visit (WhileLetLoopExpr &)\n+{}\n+\n+void\n+TokenStream::visit (ForLoopExpr &)\n+{}\n+\n+void\n+TokenStream::visit (IfExpr &expr)\n+{\n+  tokens.push_back (Rust::Token::make (IF, expr.get_locus ()));\n+  visit (expr.get_condition_expr ());\n+  visit (expr.get_if_block ());\n+}\n+\n+void\n+TokenStream::visit (IfExprConseqElse &expr)\n+{\n+  tokens.push_back (Rust::Token::make (IF, expr.get_locus ()));\n+  visit (expr.get_condition_expr ());\n+  visit (expr.get_if_block ());\n+  tokens.push_back (Rust::Token::make (ELSE, expr.get_locus ()));\n+  visit (expr.get_else_block ());\n+}\n+\n+void\n+TokenStream::visit (IfExprConseqIf &expr)\n+{\n+  tokens.push_back (Rust::Token::make (IF, expr.get_locus ()));\n+  visit (expr.get_condition_expr ());\n+  visit (expr.get_if_block ());\n+  tokens.push_back (Rust::Token::make (ELSE, expr.get_locus ()));\n+  // The \"if\" part of the \"else if\" is printed by the next visitor\n+  visit (expr.get_conseq_if_expr ());\n+}\n+\n+void\n+TokenStream::visit (IfExprConseqIfLet &)\n+{}\n+\n+void\n+TokenStream::visit (IfLetExpr &)\n+{}\n+\n+void\n+TokenStream::visit (IfLetExprConseqElse &)\n+{}\n+\n+void\n+TokenStream::visit (IfLetExprConseqIf &)\n+{}\n+\n+void\n+TokenStream::visit (IfLetExprConseqIfLet &)\n+{}\n+\n+void\n+TokenStream::visit (MatchExpr &)\n+{}\n+\n+void\n+TokenStream::visit (AwaitExpr &)\n+{}\n+\n+void\n+TokenStream::visit (AsyncBlockExpr &)\n+{}\n+\n+// rust-item.h\n+\n+void\n+TokenStream::visit (TypeParam &param)\n+{\n+  // Syntax:\n+  //    IDENTIFIER( : TypeParamBounds? )? ( = Type )?\n+  // TypeParamBounds :\n+  //    TypeParamBound ( + TypeParamBound )* +?\n+\n+  auto id = param.get_type_representation ();\n+  tokens.push_back (\n+    Rust::Token::make_identifier (param.get_locus (), std::move (id)));\n+  if (param.has_type_param_bounds ())\n+    {\n+      tokens.push_back (Rust::Token::make (COLON, Location ()));\n+      visit_items_joined_by_separator (param.get_type_param_bounds (), PLUS);\n+    }\n+  if (param.has_type ())\n+    {\n+      tokens.push_back (Rust::Token::make (EQUAL, Location ()));\n+      visit (param.get_type ());\n+    }\n+}\n+\n+void\n+TokenStream::visit (WhereClause &rule)\n+{\n+  // Syntax:\n+  // \twhere ( WhereClauseItem , )* WhereClauseItem ?\n+  // WhereClauseItem :\n+  // \tLifetimeWhereClauseItem\n+  //  \t| TypeBoundWhereClauseItem\n+\n+  tokens.push_back (Rust::Token::make (WHERE, Location ()));\n+  visit_items_joined_by_separator (rule.get_items (), COMMA);\n+}\n+\n+void\n+TokenStream::visit (LifetimeWhereClauseItem &item)\n+{\n+  // Syntax:\n+  // \tLifetime : LifetimeBounds\n+  // LifetimeBounds :\n+  //   ( Lifetime + )* Lifetime?\n+\n+  visit (item.get_lifetime ());\n+  tokens.push_back (Rust::Token::make (COLON, Location ()));\n+  visit_items_joined_by_separator (item.get_lifetime_bounds (), PLUS);\n+}\n+\n+void\n+TokenStream::visit (TypeBoundWhereClauseItem &item)\n+{\n+  // Syntax:\n+  // \tForLifetimes? Type : TypeParamBounds?\n+  // TypeParamBounds :\n+  // \tTypeParamBound ( + TypeParamBound )* +?\n+  // TypeParamBound :\n+  //    Lifetime | TraitBound\n+\n+  if (item.has_for_lifetimes ())\n+    visit (item.get_for_lifetimes ());\n+\n+  visit (item.get_type ());\n+\n+  tokens.push_back (Rust::Token::make (COLON, Location ()));\n+  visit_items_joined_by_separator (item.get_type_param_bounds (), PLUS);\n+}\n+\n+void\n+TokenStream::visit (Method &method)\n+{\n+  visit (method.get_visibility ());\n+  auto method_name = method.get_method_name ();\n+  tokens.push_back (Rust::Token::make (FN_TOK, method.get_locus ()));\n+  tokens.push_back (\n+    Rust::Token::make_identifier (Location (), std::move (method_name)));\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, Location ()));\n+\n+  tokens.push_back (Rust::Token::make (SELF, Location ()));\n+  if (!method.get_function_params ().empty ())\n+    {\n+      tokens.push_back (Rust::Token::make (COMMA, Location ()));\n+      visit_items_joined_by_separator (method.get_function_params (), COMMA);\n+    }\n+\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+\n+  if (method.has_return_type ())\n+    {\n+      tokens.push_back (Rust::Token::make (RETURN_TYPE, Location ()));\n+      visit (method.get_return_type ());\n+    }\n+\n+  auto &block = method.get_definition ();\n+  if (!block)\n+    tokens.push_back (Rust::Token::make (SEMICOLON, Location ()));\n+  else\n+    visit (block);\n+}\n+\n+void\n+TokenStream::visit (Module &module)\n+{\n+  //  Syntax:\n+  //\tmod IDENTIFIER ;\n+  //     | mod IDENTIFIER {\n+  //\t  InnerAttribute*\n+  //\t  Item*\n+  //\t}\n+\n+  visit (module.get_visibility ());\n+  auto name = module.get_name ();\n+  tokens.push_back (Rust::Token::make (MOD, module.get_locus ()));\n+  tokens.push_back (\n+    Rust::Token::make_identifier (Location (), std::move (name)));\n+\n+  if (module.get_kind () == Module::UNLOADED)\n+    {\n+      tokens.push_back (Rust::Token::make (SEMICOLON, Location ()));\n+    }\n+  else /* Module::LOADED */\n+    {\n+      tokens.push_back (Rust::Token::make (LEFT_CURLY, Location ()));\n+\n+      visit_items_as_lines (module.get_inner_attrs ());\n+      visit_items_as_lines (module.get_items ());\n+\n+      tokens.push_back (Rust::Token::make (RIGHT_CURLY, Location ()));\n+    }\n+}\n+\n+void\n+TokenStream::visit (ExternCrate &)\n+{}\n+\n+void\n+TokenStream::visit (UseTreeGlob &)\n+{}\n+\n+void\n+TokenStream::visit (UseTreeList &)\n+{}\n+\n+void\n+TokenStream::visit (UseTreeRebind &)\n+{}\n+\n+void\n+TokenStream::visit (UseDeclaration &)\n+{}\n+\n+void\n+TokenStream::visit (Function &function)\n+{\n+  // Syntax:\n+  //   FunctionQualifiers fn IDENTIFIER GenericParams?\n+  //      ( FunctionParameters? )\n+  //      FunctionReturnType? WhereClause?\n+  //      ( BlockExpression | ; )\n+\n+  visit (function.get_visibility ());\n+\n+  tokens.push_back (Rust::Token::make (FN_TOK, function.get_locus ()));\n+  auto name = function.get_function_name ();\n+  tokens.push_back (\n+    Rust::Token::make_identifier (Location (), std::move (name)));\n+  if (function.has_generics ())\n+    visit (function.get_generic_params ());\n+\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, Location ()));\n+  visit_items_joined_by_separator (function.get_function_params ());\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+\n+  if (function.has_return_type ())\n+    {\n+      tokens.push_back (Rust::Token::make (RETURN_TYPE, Location ()));\n+      visit (function.get_return_type ());\n+    }\n+\n+  if (function.has_where_clause ())\n+    visit (function.get_where_clause ());\n+\n+  auto &block = function.get_definition ();\n+  if (!block)\n+    tokens.push_back (Rust::Token::make (SEMICOLON, Location ()));\n+  else\n+    visit (block);\n+}\n+\n+void\n+TokenStream::visit (TypeAlias &type_alias)\n+{\n+  // Syntax:\n+  // Visibility? type IDENTIFIER GenericParams? WhereClause? = Type;\n+\n+  // Note: Associated types are handled by `AST::TraitItemType`.\n+\n+  if (type_alias.has_visibility ())\n+    visit (type_alias.get_visibility ());\n+  auto alias_name = type_alias.get_new_type_name ();\n+  tokens.push_back (Rust::Token::make (TYPE, type_alias.get_locus ()));\n+  tokens.push_back (\n+    Rust::Token::make_identifier (Location (), std::move (alias_name)));\n+  if (type_alias.has_generics ())\n+    visit (type_alias.get_generic_params ());\n+  if (type_alias.has_where_clause ())\n+    visit (type_alias.get_where_clause ());\n+  tokens.push_back (Rust::Token::make (EQUAL, Location ()));\n+  visit (type_alias.get_type_aliased ());\n+}\n+\n+void\n+TokenStream::visit (StructStruct &struct_item)\n+{\n+  auto struct_name = struct_item.get_identifier ();\n+  tokens.push_back (Rust::Token::make (STRUCT_TOK, struct_item.get_locus ()));\n+  tokens.push_back (\n+    Rust::Token::make_identifier (Location (), std::move (struct_name)));\n+\n+  if (struct_item.has_generics ())\n+    visit (struct_item.get_generic_params ());\n+  if (struct_item.has_where_clause ())\n+    visit (struct_item.get_where_clause ());\n+  if (struct_item.is_unit_struct ())\n+    tokens.push_back (Rust::Token::make (SEMICOLON, Location ()));\n+  else\n+    visit_items_as_block (struct_item.get_fields (),\n+\t\t\t  {Rust::Token::make (COMMA, Location ())});\n+}\n+\n+void\n+TokenStream::visit (TupleStruct &tuple_struct)\n+{\n+  auto struct_name = tuple_struct.get_identifier ();\n+  tokens.push_back (Rust::Token::make (STRUCT_TOK, tuple_struct.get_locus ()));\n+  tokens.push_back (\n+    Rust::Token::make_identifier (Location (), std::move (struct_name)));\n+  if (tuple_struct.has_generics ())\n+    visit (tuple_struct.get_generic_params ());\n+  if (tuple_struct.has_where_clause ())\n+    visit (tuple_struct.get_where_clause ());\n+\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, Location ()));\n+  visit_items_joined_by_separator (tuple_struct.get_fields (), COMMA);\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+  tokens.push_back (Rust::Token::make (SEMICOLON, Location ()));\n+}\n+\n+void\n+TokenStream::visit (EnumItem &item)\n+{\n+  auto id = item.get_identifier ();\n+  tokens.push_back (\n+    Rust::Token::make_identifier (item.get_locus (), std::move (id)));\n+}\n+\n+void\n+TokenStream::visit (EnumItemTuple &item)\n+{\n+  auto id = item.get_identifier ();\n+  tokens.push_back (\n+    Rust::Token::make_identifier (item.get_locus (), std::move (id)));\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, Location ()));\n+  visit_items_joined_by_separator (item.get_tuple_fields (), COMMA);\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+}\n+\n+void\n+TokenStream::visit (EnumItemStruct &item)\n+{\n+  auto id = item.get_identifier ();\n+  tokens.push_back (\n+    Rust::Token::make_identifier (item.get_locus (), std::move (id)));\n+  visit_items_as_block (item.get_struct_fields (),\n+\t\t\t{Rust::Token::make (COMMA, Location ())});\n+}\n+\n+void\n+TokenStream::visit (EnumItemDiscriminant &item)\n+{\n+  auto id = item.get_identifier ();\n+  tokens.push_back (\n+    Rust::Token::make_identifier (item.get_locus (), std::move (id)));\n+  tokens.push_back (Rust::Token::make (EQUAL, Location ()));\n+  visit (item.get_expr ());\n+}\n+\n+void\n+TokenStream::visit (Enum &enum_item)\n+{\n+  tokens.push_back (Rust::Token::make (ENUM_TOK, enum_item.get_locus ()));\n+  auto id = enum_item.get_identifier ();\n+  tokens.push_back (\n+    Rust::Token::make_identifier (enum_item.get_locus (), std::move (id)));\n+  if (enum_item.has_generics ())\n+    visit (enum_item.get_generic_params ());\n+  if (enum_item.has_where_clause ())\n+    visit (enum_item.get_where_clause ());\n+\n+  visit_items_as_block (enum_item.get_variants (),\n+\t\t\t{Rust::Token::make (COMMA, Location ())});\n+}\n+\n+void\n+TokenStream::visit (Union &union_item)\n+{\n+  // FIXME: \"union\" is a context dependent keyword\n+  gcc_unreachable ();\n+  auto id = union_item.get_identifier ();\n+  tokens.push_back (\n+    Rust::Token::make_identifier (union_item.get_locus (), \"union\"));\n+  tokens.push_back (Rust::Token::make_identifier (Location (), std::move (id)));\n+  if (union_item.has_generics ())\n+    visit (union_item.get_generic_params ());\n+  if (union_item.has_where_clause ())\n+    visit (union_item.get_where_clause ());\n+\n+  visit_items_as_block (union_item.get_variants (),\n+\t\t\t{Rust::Token::make (COMMA, Location ())});\n+}\n+\n+void\n+TokenStream::visit (ConstantItem &item)\n+{\n+  tokens.push_back (Rust::Token::make (CONST, item.get_locus ()));\n+  if (item.is_unnamed ())\n+    {\n+      tokens.push_back (Rust::Token::make (UNDERSCORE, Location ()));\n+    }\n+  else\n+    {\n+      auto id = item.get_identifier ();\n+      tokens.push_back (\n+\tRust::Token::make_identifier (Location (), std::move (id)));\n+    }\n+  tokens.push_back (Rust::Token::make (COLON, Location ()));\n+  visit (item.get_type ());\n+  if (item.has_expr ())\n+    {\n+      tokens.push_back (Rust::Token::make (EQUAL, Location ()));\n+      visit (item.get_expr ());\n+    }\n+  tokens.push_back (Rust::Token::make (SEMICOLON, Location ()));\n+}\n+\n+void\n+TokenStream::visit (StaticItem &item)\n+{\n+  tokens.push_back (Rust::Token::make (STATIC_TOK, item.get_locus ()));\n+  if (item.is_mutable ())\n+    tokens.push_back (Rust::Token::make (MUT, Location ()));\n+  auto id = item.get_identifier ();\n+  tokens.push_back (Rust::Token::make_identifier (Location (), std::move (id)));\n+  tokens.push_back (Rust::Token::make (COLON, Location ()));\n+  visit (item.get_type ());\n+  if (item.has_expr ())\n+    {\n+      tokens.push_back (Rust::Token::make (EQUAL, Location ()));\n+      visit (item.get_expr ());\n+    }\n+  tokens.push_back (Rust::Token::make (SEMICOLON, Location ()));\n+}\n+\n+void\n+TokenStream::visit_function_common (std::unique_ptr<Type> &return_type,\n+\t\t\t\t    std::unique_ptr<BlockExpr> &block)\n+{\n+  // FIXME: This should format the `<vis> fn <name> ( [args] )` as well\n+  if (return_type)\n+    {\n+      tokens.push_back (Rust::Token::make (RETURN_TYPE, Location ()));\n+      visit (return_type);\n+    }\n+\n+  if (block)\n+    {\n+      if (return_type)\n+\t{\n+\t  visit (block);\n+\t}\n+    }\n+  else\n+    tokens.push_back (Rust::Token::make (SEMICOLON, Location ()));\n+}\n+\n+void\n+TokenStream::visit (TraitItemFunc &item)\n+{\n+  auto func = item.get_trait_function_decl ();\n+  auto id = func.get_identifier ();\n+  tokens.push_back (Rust::Token::make (FN_TOK, item.get_locus ()));\n+  tokens.push_back (Rust::Token::make_identifier (Location (), std::move (id)));\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, Location ()));\n+\n+  visit_items_joined_by_separator (func.get_function_params ());\n+\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+\n+  visit_function_common (func.get_return_type (), item.get_definition ());\n+}\n+\n+void\n+TokenStream::visit (SelfParam &param)\n+{\n+  if (param.get_has_ref ())\n+    {\n+      tokens.push_back (Rust::Token::make (AMP, param.get_locus ()));\n+      if (param.has_lifetime ())\n+\t{\n+\t  auto lifetime = param.get_lifetime ();\n+\t  visit (lifetime);\n+\t}\n+    }\n+\n+  if (param.get_is_mut ())\n+    {\n+      tokens.push_back (Rust::Token::make (MUT, Location ()));\n+    }\n+\n+  tokens.push_back (Rust::Token::make (SELF, Location ()));\n+}\n+\n+void\n+TokenStream::visit (TraitItemMethod &item)\n+{\n+  auto method = item.get_trait_method_decl ();\n+  auto id = method.get_identifier ();\n+\n+  tokens.push_back (Rust::Token::make (FN_TOK, item.get_locus ()));\n+  tokens.push_back (Rust::Token::make_identifier (Location (), std::move (id)));\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, Location ()));\n+\n+  visit (method.get_self_param ());\n+\n+  if (!method.get_function_params ().empty ())\n+    {\n+      tokens.push_back (Rust::Token::make (COMMA, Location ()));\n+      visit_items_joined_by_separator (method.get_function_params (), COMMA);\n+    }\n+\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+\n+  visit_function_common (method.get_return_type (), item.get_definition ());\n+}\n+\n+void\n+TokenStream::visit (TraitItemConst &item)\n+{\n+  auto id = item.get_identifier ();\n+  tokens.push_back (Rust::Token::make (CONST, item.get_locus ()));\n+  tokens.push_back (Rust::Token::make_identifier (Location (), std::move (id)));\n+  tokens.push_back (Rust::Token::make (COLON, Location ()));\n+  visit (item.get_type ());\n+  tokens.push_back (Rust::Token::make (SEMICOLON, Location ()));\n+}\n+\n+void\n+TokenStream::visit (TraitItemType &item)\n+{\n+  auto id = item.get_identifier ();\n+  tokens.push_back (Rust::Token::make (TYPE, item.get_locus ()));\n+  tokens.push_back (Rust::Token::make_identifier (Location (), std::move (id)));\n+  tokens.push_back (Rust::Token::make (SEMICOLON, Location ()));\n+}\n+\n+void\n+TokenStream::visit (Trait &trait)\n+{\n+  for (auto &attr : trait.get_outer_attrs ())\n+    {\n+      visit (attr);\n+    }\n+\n+  visit (trait.get_visibility ());\n+\n+  auto id = trait.get_identifier ();\n+  tokens.push_back (Rust::Token::make (TRAIT, trait.get_locus ()));\n+  tokens.push_back (Rust::Token::make_identifier (Location (), std::move (id)));\n+\n+  // Traits actually have an implicit Self thrown at the start, so we must\n+  // expect the number of generic params to be > 1\n+  if (trait.get_generic_params ().size () > 1)\n+    {\n+      tokens.push_back (Rust::Token::make (LEFT_ANGLE, Location ()));\n+      visit_items_joined_by_separator (trait.get_generic_params (), COMMA, 1);\n+      tokens.push_back (Rust::Token::make (RIGHT_ANGLE, Location ()));\n+    }\n+\n+  visit_items_as_block (trait.get_trait_items (), {});\n+}\n+\n+void\n+TokenStream::visit (InherentImpl &impl)\n+{\n+  tokens.push_back (Rust::Token::make (IMPL, impl.get_locus ()));\n+  // FIXME: Handle generics\n+\n+  visit (impl.get_type ());\n+\n+  if (impl.has_where_clause ())\n+    visit (impl.get_where_clause ());\n+\n+  // FIXME: Handle inner attributes\n+\n+  visit_items_as_block (impl.get_impl_items (), {});\n+}\n+\n+void\n+TokenStream::visit (TraitImpl &impl)\n+{\n+  tokens.push_back (Rust::Token::make (IMPL, impl.get_locus ()));\n+  visit (impl.get_trait_path ());\n+  tokens.push_back (Rust::Token::make (FOR, Location ()));\n+  visit (impl.get_type ());\n+  tokens.push_back (Rust::Token::make (LEFT_CURLY, Location ()));\n+\n+  for (auto &item : impl.get_impl_items ())\n+    {\n+      visit (item);\n+    }\n+\n+  tokens.push_back (Rust::Token::make (RIGHT_CURLY, Location ()));\n+}\n+\n+void\n+TokenStream::visit (ExternalTypeItem &type)\n+{\n+  visit (type.get_visibility ());\n+\n+  auto id = type.get_identifier ();\n+  tokens.push_back (Rust::Token::make (TYPE, Location ()));\n+  tokens.push_back (Rust::Token::make_identifier (Location (), std::move (id)));\n+  tokens.push_back (Rust::Token::make (SEMICOLON, Location ()));\n+}\n+\n+void\n+TokenStream::visit (ExternalStaticItem &)\n+{}\n+\n+void\n+TokenStream::visit (ExternalFunctionItem &function)\n+{\n+  visit (function.get_visibility ());\n+\n+  auto id = function.get_identifier ();\n+  tokens.push_back (Rust::Token::make (FN_TOK, function.get_locus ()));\n+  tokens.push_back (Rust::Token::make_identifier (Location (), std::move (id)));\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, Location ()));\n+\n+  visit_items_joined_by_separator (function.get_function_params ());\n+\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+  if (function.has_return_type ())\n+    {\n+      tokens.push_back (Rust::Token::make (RETURN_TYPE, Location ()));\n+      visit (function.get_return_type ());\n+    }\n+}\n+\n+void\n+TokenStream::visit (ExternBlock &block)\n+{\n+  tokens.push_back (Rust::Token::make (EXTERN_TOK, block.get_locus ()));\n+\n+  if (block.has_abi ())\n+    {\n+      auto abi = block.get_abi ();\n+      tokens.push_back (Rust::Token::make (DOUBLE_QUOTE, Location ()));\n+      tokens.push_back (\n+\tRust::Token::make_identifier (Location (), std::move (abi)));\n+      tokens.push_back (Rust::Token::make (DOUBLE_QUOTE, Location ()));\n+    }\n+\n+  visit_items_as_block (block.get_extern_items (),\n+\t\t\t{Rust::Token::make (SEMICOLON, Location ())});\n+}\n+\n+static std::pair<TokenId, TokenId>\n+get_delimiters (DelimType delim)\n+{\n+  switch (delim)\n+    {\n+    case PARENS:\n+      return {LEFT_PAREN, RIGHT_PAREN};\n+    case SQUARE:\n+      return {LEFT_SQUARE, RIGHT_SQUARE};\n+    case CURLY:\n+      return {LEFT_CURLY, RIGHT_CURLY};\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+void\n+TokenStream::visit (MacroMatchFragment &match)\n+{\n+  auto id = match.get_ident ();\n+  auto frag_spec = match.get_frag_spec ().as_string ();\n+  tokens.push_back (Rust::Token::make (DOLLAR_SIGN, Location ()));\n+  tokens.push_back (Rust::Token::make_identifier (Location (), std::move (id)));\n+  tokens.push_back (Rust::Token::make (COLON, Location ()));\n+  tokens.push_back (\n+    Rust::Token::make_identifier (Location (), std::move (frag_spec)));\n+}\n+\n+void\n+TokenStream::visit (MacroMatchRepetition &repetition)\n+{\n+  tokens.push_back (Rust::Token::make (DOLLAR_SIGN, Location ()));\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, Location ()));\n+\n+  visit_items_joined_by_separator (repetition.get_matches (), {});\n+\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+\n+  if (repetition.has_sep ())\n+    {\n+      tokens.push_back (\n+\tRust::Token::make (repetition.get_sep ()->get_id (),\n+\t\t\t   repetition.get_sep ()->get_locus ()));\n+    }\n+  switch (repetition.get_op ())\n+    {\n+    case MacroMatchRepetition::ANY:\n+      tokens.push_back (Rust::Token::make (ASTERISK, Location ()));\n+      break;\n+    case MacroMatchRepetition::ONE_OR_MORE:\n+      tokens.push_back (Rust::Token::make (PLUS, Location ()));\n+      break;\n+    case MacroMatchRepetition::ZERO_OR_ONE:\n+      tokens.push_back (Rust::Token::make (QUESTION_MARK, Location ()));\n+      break;\n+    case MacroMatchRepetition::NONE:\n+      break;\n+    }\n+}\n+\n+void\n+TokenStream::visit (MacroMatcher &matcher)\n+{\n+  auto delimiters = get_delimiters (matcher.get_delim_type ());\n+\n+  tokens.push_back (Rust::Token::make (delimiters.first, Location ()));\n+\n+  visit_items_joined_by_separator (matcher.get_matches (), {});\n+\n+  tokens.push_back (Rust::Token::make (delimiters.second, Location ()));\n+}\n+\n+void\n+TokenStream::visit (MacroRule &rule)\n+{\n+  visit (rule.get_matcher ());\n+  tokens.push_back (Rust::Token::make (MATCH_ARROW, rule.get_locus ()));\n+  visit (rule.get_transcriber ().get_token_tree ());\n+  tokens.push_back (Rust::Token::make (SEMICOLON, Location ()));\n+}\n+\n+void\n+TokenStream::visit (MacroRulesDefinition &rules_def)\n+{\n+  for (auto &outer_attr : rules_def.get_outer_attrs ())\n+    visit (outer_attr);\n+\n+  auto rule_name = rules_def.get_rule_name ();\n+  tokens.push_back (\n+    Rust::Token::make_identifier (rules_def.get_locus (), \"macro_rules\"));\n+  tokens.push_back (Rust::Token::make (EXCLAM, Location ()));\n+\n+  tokens.push_back (\n+    Rust::Token::make_identifier (Location (), std::move (rule_name)));\n+\n+  visit_items_as_block (rules_def.get_rules (),\n+\t\t\t{Rust::Token::make (SEMICOLON, Location ())});\n+}\n+\n+void\n+TokenStream::visit (MacroInvocation &)\n+{}\n+\n+void\n+TokenStream::visit (MetaItemPath &)\n+{}\n+\n+void\n+TokenStream::visit (MetaItemSeq &)\n+{}\n+\n+void\n+TokenStream::visit (MetaWord &)\n+{}\n+\n+void\n+TokenStream::visit (MetaNameValueStr &)\n+{}\n+\n+void\n+TokenStream::visit (MetaListPaths &)\n+{}\n+\n+void\n+TokenStream::visit (MetaListNameValueStr &)\n+{}\n+\n+// rust-pattern.h\n+void\n+TokenStream::visit (LiteralPattern &pattern)\n+{\n+  visit (pattern.get_literal (), pattern.get_locus ());\n+}\n+\n+void\n+TokenStream::visit (IdentifierPattern &pattern)\n+{\n+  if (pattern.get_is_ref ())\n+    {\n+      tokens.push_back (Rust::Token::make (REF, pattern.get_locus ()));\n+    }\n+  if (pattern.get_is_mut ())\n+    {\n+      tokens.push_back (Rust::Token::make (MUT, Location ()));\n+    }\n+  auto id = pattern.get_ident ();\n+  tokens.push_back (Rust::Token::make_identifier (Location (), std::move (id)));\n+  if (pattern.has_pattern_to_bind ())\n+    {\n+      tokens.push_back (Rust::Token::make (PATTERN_BIND, Location ()));\n+      visit (pattern.get_pattern_to_bind ());\n+    }\n+}\n+\n+void\n+TokenStream::visit (WildcardPattern &pattern)\n+{\n+  tokens.push_back (Rust::Token::make (UNDERSCORE, pattern.get_locus ()));\n+}\n+\n+void\n+TokenStream::visit (RestPattern &pattern)\n+{\n+  tokens.push_back (Rust::Token::make (DOT_DOT, pattern.get_locus ()));\n+}\n+\n+// void TokenStream::visit(RangePatternBound& ){}\n+\n+void\n+TokenStream::visit (RangePatternBoundLiteral &pattern)\n+{\n+  if (pattern.get_has_minus ())\n+    {\n+      tokens.push_back (Rust::Token::make (MINUS, pattern.get_locus ()));\n+    }\n+  auto literal = pattern.get_literal ();\n+  visit (literal);\n+}\n+\n+void\n+TokenStream::visit (RangePatternBoundPath &pattern)\n+{\n+  visit (pattern.get_path ());\n+}\n+\n+void\n+TokenStream::visit (RangePatternBoundQualPath &pattern)\n+{\n+  visit (pattern.get_qualified_path ());\n+}\n+\n+void\n+TokenStream::visit (RangePattern &pattern)\n+{\n+  if (pattern.get_has_lower_bound () && pattern.get_has_upper_bound ())\n+    {\n+      visit (pattern.get_lower_bound ());\n+      if (pattern.get_has_ellipsis_syntax ())\n+\ttokens.push_back (Rust::Token::make (ELLIPSIS, pattern.get_locus ()));\n+      else\n+\ttokens.push_back (Rust::Token::make (DOT_DOT_EQ, pattern.get_locus ()));\n+      visit (pattern.get_upper_bound ());\n+    }\n+  else if (pattern.get_has_lower_bound ())\n+    {\n+      visit (pattern.get_lower_bound ());\n+      tokens.push_back (Rust::Token::make (DOT_DOT, pattern.get_locus ()));\n+    }\n+  else\n+    {\n+      tokens.push_back (Rust::Token::make (DOT_DOT_EQ, pattern.get_locus ()));\n+      visit (pattern.get_upper_bound ());\n+    }\n+}\n+\n+void\n+TokenStream::visit (ReferencePattern &pattern)\n+{\n+  if (pattern.is_double_reference ())\n+    {\n+      tokens.push_back (Rust::Token::make (LOGICAL_AND, pattern.get_locus ()));\n+    }\n+  else\n+    {\n+      tokens.push_back (Rust::Token::make (AMP, pattern.get_locus ()));\n+    }\n+\n+  if (pattern.get_is_mut ())\n+    {\n+      tokens.push_back (Rust::Token::make (MUT, Location ()));\n+    }\n+\n+  visit (pattern.get_referenced_pattern ());\n+}\n+\n+// void TokenStream::visit(StructPatternField& ){}\n+\n+void\n+TokenStream::visit (StructPatternFieldTuplePat &pattern)\n+{\n+  visit_items_as_lines (pattern.get_outer_attrs ());\n+  tokens.push_back (\n+    Rust::Token::make_int (pattern.get_locus (),\n+\t\t\t   std::to_string (pattern.get_index ())));\n+  tokens.push_back (Rust::Token::make (COLON, pattern.get_locus ()));\n+  visit (pattern.get_index_pattern ());\n+}\n+\n+void\n+TokenStream::visit (StructPatternFieldIdentPat &pattern)\n+{\n+  visit_items_as_lines (pattern.get_outer_attrs ());\n+  auto id = pattern.get_identifier ();\n+  tokens.push_back (Rust::Token::make_identifier (Location (), std::move (id)));\n+  tokens.push_back (Rust::Token::make (COLON, pattern.get_locus ()));\n+  visit (pattern.get_ident_pattern ());\n+}\n+\n+void\n+TokenStream::visit (StructPatternFieldIdent &pattern)\n+{\n+  visit_items_as_lines (pattern.get_outer_attrs ());\n+  if (pattern.is_ref ())\n+    tokens.push_back (Rust::Token::make (REF, Location ()));\n+  if (pattern.is_mut ())\n+    tokens.push_back (Rust::Token::make (MUT, Location ()));\n+\n+  auto id = pattern.get_identifier ();\n+  tokens.push_back (Rust::Token::make_identifier (Location (), std::move (id)));\n+}\n+\n+void\n+TokenStream::visit (StructPattern &pattern)\n+{\n+  visit (pattern.get_path ());\n+  tokens.push_back (Rust::Token::make (LEFT_CURLY, pattern.get_locus ()));\n+  auto elems = pattern.get_struct_pattern_elems ();\n+  if (elems.has_struct_pattern_fields ())\n+    {\n+      visit_items_joined_by_separator (elems.get_struct_pattern_fields ());\n+      if (elems.has_etc ())\n+\t{\n+\t  tokens.push_back (Rust::Token::make (COMMA, Location ()));\n+\t  visit_items_as_lines (elems.get_etc_outer_attrs ());\n+\t}\n+    }\n+  else\n+    {\n+      visit_items_as_lines (elems.get_etc_outer_attrs ());\n+    }\n+\n+  tokens.push_back (Rust::Token::make (RIGHT_CURLY, Location ()));\n+}\n+\n+// void TokenStream::visit(TupleStructItems& ){}\n+\n+void\n+TokenStream::visit (TupleStructItemsNoRange &pattern)\n+{\n+  for (auto &pat : pattern.get_patterns ())\n+    {\n+      visit (pat);\n+    }\n+}\n+\n+void\n+TokenStream::visit (TupleStructItemsRange &pattern)\n+{\n+  for (auto &lower : pattern.get_lower_patterns ())\n+    {\n+      visit (lower);\n+    }\n+  tokens.push_back (Rust::Token::make (DOT_DOT, Location ()));\n+  for (auto &upper : pattern.get_lower_patterns ())\n+    {\n+      visit (upper);\n+    }\n+}\n+\n+void\n+TokenStream::visit (TupleStructPattern &pattern)\n+{\n+  visit (pattern.get_path ());\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, pattern.get_locus ()));\n+  if (pattern.has_items ())\n+    visit (pattern.get_items ());\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+}\n+\n+// void\n+// TokenStream::visit (TuplePatternItems &)\n+// {}\n+\n+void\n+TokenStream::visit (TuplePatternItemsMultiple &pattern)\n+{\n+  visit_items_joined_by_separator (pattern.get_patterns (), COMMA);\n+}\n+\n+void\n+TokenStream::visit (TuplePatternItemsRanged &pattern)\n+{\n+  for (auto &lower : pattern.get_lower_patterns ())\n+    {\n+      visit (lower);\n+    }\n+  tokens.push_back (Rust::Token::make (DOT_DOT, Location ()));\n+  for (auto &upper : pattern.get_lower_patterns ())\n+    {\n+      visit (upper);\n+    }\n+}\n+\n+void\n+TokenStream::visit (TuplePattern &pattern)\n+{\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, pattern.get_locus ()));\n+  visit (pattern.get_items ());\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+}\n+\n+void\n+TokenStream::visit (GroupedPattern &pattern)\n+{\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, pattern.get_locus ()));\n+  visit (pattern.get_pattern_in_parens ());\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+}\n+\n+void\n+TokenStream::visit (SlicePattern &pattern)\n+{\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, pattern.get_locus ()));\n+  visit_items_joined_by_separator (pattern.get_items (), COMMA);\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+}\n+\n+void\n+TokenStream::visit (AltPattern &)\n+{}\n+\n+// rust-stmt.h\n+void\n+TokenStream::visit (EmptyStmt &)\n+{}\n+\n+void\n+TokenStream::visit (LetStmt &stmt)\n+{\n+  tokens.push_back (Rust::Token::make (LET, stmt.get_locus ()));\n+  auto &pattern = stmt.get_pattern ();\n+  if (pattern)\n+    visit (pattern);\n+\n+  if (stmt.has_type ())\n+    {\n+      tokens.push_back (Rust::Token::make (COLON, Location ()));\n+      visit (stmt.get_type ());\n+    }\n+\n+  if (stmt.has_init_expr ())\n+    {\n+      tokens.push_back (Rust::Token::make (EQUAL, Location ()));\n+      visit (stmt.get_init_expr ());\n+    }\n+}\n+\n+void\n+TokenStream::visit (ExprStmtWithoutBlock &stmt)\n+{\n+  visit (stmt.get_expr ());\n+}\n+\n+void\n+TokenStream::visit (ExprStmtWithBlock &stmt)\n+{\n+  visit (stmt.get_expr ());\n+}\n+\n+// rust-type.h\n+void\n+TokenStream::visit (TraitBound &bound)\n+{\n+  // Syntax:\n+  //      ?? ForLifetimes? TypePath\n+  //   | ( ?? ForLifetimes? TypePath )\n+\n+  if (bound.has_opening_question_mark ())\n+    tokens.push_back (Rust::Token::make (QUESTION_MARK, bound.get_locus ()));\n+\n+  if (bound.has_for_lifetimes ())\n+    visit (bound.get_for_lifetimes ());\n+\n+  visit (bound.get_type_path ());\n+}\n+\n+void\n+TokenStream::visit (ImplTraitType &type)\n+{\n+  // Syntax:\n+  //    impl TypeParamBounds\n+  // TypeParamBounds :\n+  //    TypeParamBound ( + TypeParamBound )* +?\n+\n+  tokens.push_back (Rust::Token::make (IMPL, type.get_locus ()));\n+  visit_items_joined_by_separator (type.get_type_param_bounds (), PLUS);\n+}\n+\n+void\n+TokenStream::visit (TraitObjectType &type)\n+{\n+  // Syntax:\n+  //   dyn? TypeParamBounds\n+  // TypeParamBounds :\n+  //   TypeParamBound ( + TypeParamBound )* +?\n+\n+  if (type.is_dyn ())\n+    tokens.push_back (Rust::Token::make (DYN, type.get_locus ()));\n+  visit_items_joined_by_separator (type.get_type_param_bounds (), PLUS);\n+}\n+\n+void\n+TokenStream::visit (ParenthesisedType &type)\n+{\n+  // Syntax:\n+  //    ( Type )\n+\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, type.get_locus ()));\n+  visit (type.get_type_in_parens ());\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+}\n+\n+void\n+TokenStream::visit (ImplTraitTypeOneBound &type)\n+{\n+  // Syntax:\n+  //    impl TraitBound\n+\n+  tokens.push_back (Rust::Token::make (IMPL, type.get_locus ()));\n+  visit (type.get_trait_bound ());\n+}\n+\n+void\n+TokenStream::visit (TraitObjectTypeOneBound &type)\n+{\n+  // Syntax:\n+  //    dyn? TraitBound\n+\n+  if (type.is_dyn ())\n+    tokens.push_back (Rust::Token::make (DYN, type.get_locus ()));\n+  visit (type.get_trait_bound ());\n+}\n+\n+void\n+TokenStream::visit (TupleType &type)\n+{\n+  // Syntax:\n+  //   ( )\n+  //   | ( ( Type , )+ Type? )\n+\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, type.get_locus ()));\n+  visit_items_joined_by_separator (type.get_elems (), COMMA);\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+}\n+\n+void\n+TokenStream::visit (NeverType &type)\n+{\n+  // Syntax:\n+  //  !\n+\n+  tokens.push_back (Rust::Token::make (EXCLAM, type.get_locus ()));\n+}\n+\n+void\n+TokenStream::visit (RawPointerType &type)\n+{\n+  // Syntax:\n+  //    * ( mut | const ) TypeNoBounds\n+\n+  tokens.push_back (Rust::Token::make (ASTERISK, type.get_locus ()));\n+  if (type.get_pointer_type () == RawPointerType::MUT)\n+    tokens.push_back (Rust::Token::make (MUT, Location ()));\n+  else /* RawPointerType::CONST */\n+    tokens.push_back (Rust::Token::make (CONST, Location ()));\n+\n+  visit (type.get_type_pointed_to ());\n+}\n+\n+void\n+TokenStream::visit (ReferenceType &type)\n+{\n+  // Syntax:\n+  //    & Lifetime? mut? TypeNoBounds\n+\n+  tokens.push_back (Rust::Token::make (AMP, type.get_locus ()));\n+\n+  if (type.has_lifetime ())\n+    {\n+      visit (type.get_lifetime ());\n+    }\n+\n+  if (type.get_has_mut ())\n+    tokens.push_back (Rust::Token::make (MUT, Location ()));\n+\n+  visit (type.get_type_referenced ());\n+}\n+\n+void\n+TokenStream::visit (ArrayType &type)\n+{\n+  // Syntax:\n+  //    [ Type ; Expression ]\n+\n+  tokens.push_back (Rust::Token::make (LEFT_SQUARE, type.get_locus ()));\n+  visit (type.get_elem_type ());\n+  tokens.push_back (Rust::Token::make (SEMICOLON, Location ()));\n+  visit (type.get_size_expr ());\n+  tokens.push_back (Rust::Token::make (RIGHT_SQUARE, Location ()));\n+}\n+\n+void\n+TokenStream::visit (SliceType &type)\n+{\n+  // Syntax:\n+  //    [ Type ]\n+\n+  tokens.push_back (Rust::Token::make (LEFT_SQUARE, type.get_locus ()));\n+  visit (type.get_elem_type ());\n+  tokens.push_back (Rust::Token::make (RIGHT_SQUARE, Location ()));\n+}\n+\n+void\n+TokenStream::visit (InferredType &type)\n+{\n+  // Syntax:\n+  //    _\n+\n+  tokens.push_back (Rust::Token::make (UNDERSCORE, type.get_locus ()));\n+}\n+\n+void\n+TokenStream::visit (BareFunctionType &type)\n+{\n+  // Syntax:\n+  //    ForLifetimes? FunctionTypeQualifiers fn\n+  //      ( FunctionParametersMaybeNamedVariadic? ) BareFunctionReturnType?\n+  //\n+  //    BareFunctionReturnType:\n+  //      -> TypeNoBounds\n+  //\n+  //    FunctionParametersMaybeNamedVariadic :\n+  //      MaybeNamedFunctionParameters | MaybeNamedFunctionParametersVariadic\n+  //\n+  //    MaybeNamedFunctionParameters :\n+  //      MaybeNamedParam ( , MaybeNamedParam )* ,?\n+  //\n+  //    MaybeNamedFunctionParametersVariadic :\n+  //      ( MaybeNamedParam , )* MaybeNamedParam , OuterAttribute* ...\n+\n+  if (type.has_for_lifetimes ())\n+    visit (type.get_for_lifetimes ());\n+\n+  visit (type.get_function_qualifiers ());\n+\n+  tokens.push_back (Rust::Token::make (FN_TOK, type.get_locus ()));\n+  tokens.push_back (Rust::Token::make (LEFT_PAREN, Location ()));\n+\n+  visit_items_joined_by_separator (type.get_function_params (), COMMA);\n+\n+  if (type.is_variadic ())\n+    {\n+      tokens.push_back (Rust::Token::make (COMMA, Location ()));\n+      for (auto &item : type.get_variadic_attr ())\n+\t{\n+\t  visit (item);\n+\t}\n+      tokens.push_back (Rust::Token::make (ELLIPSIS, Location ()));\n+    }\n+\n+  tokens.push_back (Rust::Token::make (RIGHT_PAREN, Location ()));\n+\n+  if (type.has_return_type ())\n+    {\n+      tokens.push_back (Rust::Token::make (RETURN_TYPE, Location ()));\n+      visit (type.get_return_type ());\n+    }\n+}\n+\n+} // namespace AST\n+} // namespace Rust"}, {"sha": "6432ac40a1f8cdafcd8e3019ee2f4c7dba1391b8", "filename": "gcc/rust/ast/rust-ast-tokenstream.h", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf6c77494c09e23aa2108eb238efcae35627e810/gcc%2Frust%2Fast%2Frust-ast-tokenstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf6c77494c09e23aa2108eb238efcae35627e810/gcc%2Frust%2Fast%2Frust-ast-tokenstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-tokenstream.h?ref=cf6c77494c09e23aa2108eb238efcae35627e810", "patch": "@@ -0,0 +1,295 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-token.h\"\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-ast.h\"\n+#include \"rust-ast-full.h\"\n+\n+#ifndef RUST_AST_TOKENSTREAM_H\n+#define RUST_AST_TOKENSTREAM_H\n+\n+namespace Rust {\n+namespace AST {\n+\n+class TokenStream : public ASTVisitor\n+{\n+public:\n+  TokenStream (std::vector<TokenPtr> &container);\n+\n+  void go (AST::Crate &crate);\n+  void go (AST::Item &item);\n+\n+private:\n+  std::vector<TokenPtr> &tokens;\n+\n+  /**\n+   * Compatibility layer for using the visitor pattern on polymorphic classes\n+   * with a unified overload syntax. This allows us to call `visit` both on\n+   * types implementing `accept_vis` method and for classes for which the\n+   * `visit` method is directly implemented.\n+   */\n+  template <typename T> void visit (std::unique_ptr<T> &node);\n+\n+  /**\n+   * @see visit<std::unique_ptr<T>>\n+   */\n+  template <typename T> void visit (T &node);\n+\n+  /**\n+   * Visit all items in given @collection, placing the separator in between but\n+   * not at the end.\n+   */\n+  template <typename T>\n+  void visit_items_joined_by_separator (T &collection,\n+\t\t\t\t\tTokenId separator = COMMA,\n+\t\t\t\t\tsize_t start_offset = 0,\n+\t\t\t\t\tsize_t end_offset = 0);\n+\n+  /**\n+   * Visit item placing end of line after.\n+   */\n+  template <typename T>\n+  void visit_as_line (T &item, std::vector<TokenPtr> trailing = {});\n+\n+  /**\n+   * Visit each item in @collection \"as line\".\n+   *\n+   * @see visit_as_line\n+   */\n+  template <typename T>\n+  void visit_items_as_lines (T &collection,\n+\t\t\t     std::vector<TokenPtr> trailing = {});\n+\n+  /**\n+   * Visit each item in @collection as lines inside a block delimited by braces\n+   * with increased indentation. Also includes special handling for empty\n+   * collection to print only the delimiters with no new line inside.\n+   */\n+  template <typename T>\n+  void visit_items_as_block (T &collection, std::vector<TokenPtr> trailing,\n+\t\t\t     TokenId left_brace = LEFT_CURLY,\n+\t\t\t     TokenId right_brace = RIGHT_CURLY);\n+\n+  /**\n+   * Visit common items of functions: Parameters, return type, block\n+   */\n+  void visit_function_common (std::unique_ptr<Type> &return_type,\n+\t\t\t      std::unique_ptr<BlockExpr> &block);\n+\n+  void visit (Literal &lit, Location locus = {});\n+\n+  void visit (FunctionParam &param);\n+  void visit (Attribute &attrib);\n+  void visit (Visibility &vis);\n+  void visit (std::vector<std::unique_ptr<GenericParam>> &params);\n+  void visit (TupleField &field);\n+  void visit (StructField &field);\n+  void visit (SimplePathSegment &segment);\n+  void visit (NamedFunctionParam &param);\n+  void visit (MacroRule &rule);\n+  void visit (WhereClause &rule);\n+  void visit (std::vector<LifetimeParam> &for_lifetimes);\n+  void visit (FunctionQualifiers &qualifiers);\n+  void visit (MaybeNamedParam &param);\n+  void visit (TypePathFunction &type_path_fn);\n+  void visit (GenericArgsBinding &binding);\n+  void visit (GenericArg &arg);\n+\n+  // rust-ast.h\n+  void visit (Token &tok);\n+  void visit (DelimTokenTree &delim_tok_tree);\n+  void visit (AttrInputMetaItemContainer &input);\n+  void visit (IdentifierExpr &ident_expr);\n+  void visit (Lifetime &lifetime);\n+  void visit (LifetimeParam &lifetime_param);\n+  void visit (ConstGenericParam &const_param);\n+\n+  // rust-path.h\n+  void visit (PathInExpression &path);\n+  void visit (TypePathSegment &segment);\n+  void visit (TypePathSegmentGeneric &segment);\n+  void visit (TypePathSegmentFunction &segment);\n+  void visit (TypePath &path);\n+  void visit (QualifiedPathInExpression &path);\n+  void visit (QualifiedPathInType &path);\n+\n+  // rust-expr.h\n+  void visit (LiteralExpr &expr);\n+  void visit (AttrInputLiteral &attr_input);\n+  void visit (MetaItemLitExpr &meta_item);\n+  void visit (MetaItemPathLit &meta_item);\n+  void visit (BorrowExpr &expr);\n+  void visit (DereferenceExpr &expr);\n+  void visit (ErrorPropagationExpr &expr);\n+  void visit (NegationExpr &expr);\n+  void visit (ArithmeticOrLogicalExpr &expr);\n+  void visit (ComparisonExpr &expr);\n+  void visit (LazyBooleanExpr &expr);\n+  void visit (TypeCastExpr &expr);\n+  void visit (AssignmentExpr &expr);\n+  void visit (CompoundAssignmentExpr &expr);\n+  void visit (GroupedExpr &expr);\n+  void visit (ArrayElemsValues &elems);\n+  void visit (ArrayElemsCopied &elems);\n+  void visit (ArrayExpr &expr);\n+  void visit (ArrayIndexExpr &expr);\n+  void visit (TupleExpr &expr);\n+  void visit (TupleIndexExpr &expr);\n+  void visit (StructExprStruct &expr);\n+  void visit (StructExprFieldIdentifier &field);\n+  void visit (StructExprFieldIdentifierValue &field);\n+  void visit (StructExprFieldIndexValue &field);\n+  void visit (StructExprStructFields &expr);\n+  void visit (StructExprStructBase &expr);\n+  void visit (CallExpr &expr);\n+  void visit (MethodCallExpr &expr);\n+  void visit (FieldAccessExpr &expr);\n+  void visit (ClosureExprInner &expr);\n+  void visit (BlockExpr &expr);\n+  void visit (ClosureExprInnerTyped &expr);\n+  void visit (ContinueExpr &expr);\n+  void visit (BreakExpr &expr);\n+  void visit (RangeFromToExpr &expr);\n+  void visit (RangeFromExpr &expr);\n+  void visit (RangeToExpr &expr);\n+  void visit (RangeFullExpr &expr);\n+  void visit (RangeFromToInclExpr &expr);\n+  void visit (RangeToInclExpr &expr);\n+  void visit (ReturnExpr &expr);\n+  void visit (UnsafeBlockExpr &expr);\n+  void visit (LoopExpr &expr);\n+  void visit (WhileLoopExpr &expr);\n+  void visit (WhileLetLoopExpr &expr);\n+  void visit (ForLoopExpr &expr);\n+  void visit (IfExpr &expr);\n+  void visit (IfExprConseqElse &expr);\n+  void visit (IfExprConseqIf &expr);\n+  void visit (IfExprConseqIfLet &expr);\n+  void visit (IfLetExpr &expr);\n+  void visit (IfLetExprConseqElse &expr);\n+  void visit (IfLetExprConseqIf &expr);\n+  void visit (IfLetExprConseqIfLet &expr);\n+  void visit (MatchExpr &expr);\n+  void visit (AwaitExpr &expr);\n+  void visit (AsyncBlockExpr &expr);\n+\n+  // rust-item.h\n+  void visit (TypeParam &param);\n+  void visit (LifetimeWhereClauseItem &item);\n+  void visit (TypeBoundWhereClauseItem &item);\n+  void visit (Method &method);\n+  void visit (Module &module);\n+  void visit (ExternCrate &crate);\n+  void visit (UseTreeGlob &use_tree);\n+  void visit (UseTreeList &use_tree);\n+  void visit (UseTreeRebind &use_tree);\n+  void visit (UseDeclaration &use_decl);\n+  void visit (Function &function);\n+  void visit (TypeAlias &type_alias);\n+  void visit (StructStruct &struct_item);\n+  void visit (TupleStruct &tuple_struct);\n+  void visit (EnumItem &item);\n+  void visit (EnumItemTuple &item);\n+  void visit (EnumItemStruct &item);\n+  void visit (EnumItemDiscriminant &item);\n+  void visit (Enum &enum_item);\n+  void visit (Union &union_item);\n+  void visit (ConstantItem &const_item);\n+  void visit (StaticItem &static_item);\n+  void visit (TraitItemFunc &item);\n+  void visit (SelfParam &param);\n+  void visit (TraitItemMethod &item);\n+  void visit (TraitItemConst &item);\n+  void visit (TraitItemType &item);\n+  void visit (Trait &trait);\n+  void visit (InherentImpl &impl);\n+  void visit (TraitImpl &impl);\n+  void visit (ExternalTypeItem &item);\n+  void visit (ExternalStaticItem &item);\n+  void visit (ExternalFunctionItem &item);\n+  void visit (ExternBlock &block);\n+\n+  // rust-macro.h\n+  void visit (MacroMatchFragment &match);\n+  void visit (MacroMatchRepetition &match);\n+  void visit (MacroMatcher &matcher);\n+  void visit (MacroRulesDefinition &rules_def);\n+  void visit (MacroInvocation &macro_invoc);\n+  void visit (MetaItemPath &meta_item);\n+  void visit (MetaItemSeq &meta_item);\n+  void visit (MetaWord &meta_item);\n+  void visit (MetaNameValueStr &meta_item);\n+  void visit (MetaListPaths &meta_item);\n+  void visit (MetaListNameValueStr &meta_item);\n+\n+  // rust-pattern.h\n+  void visit (LiteralPattern &pattern);\n+  void visit (IdentifierPattern &pattern);\n+  void visit (WildcardPattern &pattern);\n+  void visit (RestPattern &pattern);\n+  // void visit(RangePatternBound& bound);\n+  void visit (RangePatternBoundLiteral &bound);\n+  void visit (RangePatternBoundPath &bound);\n+  void visit (RangePatternBoundQualPath &bound);\n+  void visit (RangePattern &pattern);\n+  void visit (ReferencePattern &pattern);\n+  // void visit(StructPatternField& field);\n+  void visit (StructPatternFieldTuplePat &field);\n+  void visit (StructPatternFieldIdentPat &field);\n+  void visit (StructPatternFieldIdent &field);\n+  void visit (StructPattern &pattern);\n+  // void visit(TupleStructItems& tuple_items);\n+  void visit (TupleStructItemsNoRange &tuple_items);\n+  void visit (TupleStructItemsRange &tuple_items);\n+  void visit (TupleStructPattern &pattern);\n+  // void visit(TuplePatternItems& tuple_items);\n+  void visit (TuplePatternItemsMultiple &tuple_items);\n+  void visit (TuplePatternItemsRanged &tuple_items);\n+  void visit (TuplePattern &pattern);\n+  void visit (GroupedPattern &pattern);\n+  void visit (SlicePattern &pattern);\n+  void visit (AltPattern &pattern);\n+\n+  // rust-stmt.h\n+  void visit (EmptyStmt &stmt);\n+  void visit (LetStmt &stmt);\n+  void visit (ExprStmtWithoutBlock &stmt);\n+  void visit (ExprStmtWithBlock &stmt);\n+\n+  // rust-type.h\n+  void visit (TraitBound &bound);\n+  void visit (ImplTraitType &type);\n+  void visit (TraitObjectType &type);\n+  void visit (ParenthesisedType &type);\n+  void visit (ImplTraitTypeOneBound &type);\n+  void visit (TraitObjectTypeOneBound &type);\n+  void visit (TupleType &type);\n+  void visit (NeverType &type);\n+  void visit (RawPointerType &type);\n+  void visit (ReferenceType &type);\n+  void visit (ArrayType &type);\n+  void visit (SliceType &type);\n+  void visit (InferredType &type);\n+  void visit (BareFunctionType &type);\n+};\n+} // namespace AST\n+\n+} // namespace Rust\n+\n+#endif // !RUST_AST_TOKENSTREAM_H"}, {"sha": "56cc13dce0f6f177d1d6ca8d086e85c0cd563b78", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf6c77494c09e23aa2108eb238efcae35627e810/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf6c77494c09e23aa2108eb238efcae35627e810/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=cf6c77494c09e23aa2108eb238efcae35627e810", "patch": "@@ -2642,6 +2642,8 @@ class ConstantItem : public VisItem,\n     return type == nullptr && const_expr == nullptr;\n   }\n \n+  bool has_expr () { return const_expr != nullptr; }\n+\n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Expr> &get_expr ()\n   {\n@@ -2754,6 +2756,8 @@ class StaticItem : public VisItem\n     return type == nullptr && expr == nullptr;\n   }\n \n+  bool has_expr () { return expr != nullptr; }\n+\n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Expr> &get_expr ()\n   {\n@@ -4115,6 +4119,8 @@ class NamedFunctionParam\n \n   std::string get_name () const { return name; }\n \n+  Location get_locus () { return locus; }\n+\n   // Creates an error state named function parameter.\n   static NamedFunctionParam create_error ()\n   {"}, {"sha": "10af61fafc71d205e36da5f54e790ac2481f8f0a", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf6c77494c09e23aa2108eb238efcae35627e810/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf6c77494c09e23aa2108eb238efcae35627e810/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=cf6c77494c09e23aa2108eb238efcae35627e810", "patch": "@@ -413,6 +413,12 @@ class RangePattern : public Pattern\n \n   Location get_locus () const override final { return locus; }\n \n+  bool get_has_ellipsis_syntax () { return has_ellipsis_syntax; }\n+\n+  bool get_has_lower_bound () { return lower != nullptr; }\n+\n+  bool get_has_upper_bound () { return upper != nullptr; }\n+\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? or is a \"vis_bound\" better?\n@@ -645,6 +651,8 @@ class StructPatternFieldTuplePat : public StructPatternField\n     return tuple_pattern == nullptr;\n   }\n \n+  TupleIndex get_index () { return index; }\n+\n   // TODO: is this better? Or is a \"vis_pattern\" better?\n   std::unique_ptr<Pattern> &get_index_pattern ()\n   {"}]}