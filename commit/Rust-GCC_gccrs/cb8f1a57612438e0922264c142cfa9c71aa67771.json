{"sha": "cb8f1a57612438e0922264c142cfa9c71aa67771", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I4ZjFhNTc2MTI0MzhlMDkyMjI2NGMxNDJjZmE5YzcxYWE2Nzc3MQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2014-05-05T07:36:30Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2014-05-05T07:36:30Z"}, "message": "re PR tree-optimization/60363 (logical_op_short_circuit, gcc.dg/tree-ssa/ssa-dom-thread-4.c scan-tree-dump-times dom1 \"Threaded\" 4)\n\n\n\tPR tree-optimization/60363\n\t* gcc/tree-ssa-threadupdate.c (get_value_locus_in_path): New.\n\t(copy_phi_args): New parameters.  Call get_value_locus_in_path.\n\t(update_destination_phis): New parameter.\n\t(create_edge_and_update_destination_phis): Ditto.\n\t(ssa_fix_duplicate_block_edges): Pass new arguments.\n\t(thread_single_edge): Ditto.\n\n\tPR tree-optimization/60363\n\t* gcc.dg/tree-ssa/ssa-dom-thread-4.c: Revert XFAIL test.\n\nFrom-SVN: r210059", "tree": {"sha": "347e103d5129b8022d8c329578471dace850d580", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/347e103d5129b8022d8c329578471dace850d580"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb8f1a57612438e0922264c142cfa9c71aa67771", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb8f1a57612438e0922264c142cfa9c71aa67771", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb8f1a57612438e0922264c142cfa9c71aa67771", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb8f1a57612438e0922264c142cfa9c71aa67771/comments", "author": null, "committer": null, "parents": [{"sha": "f93bc5b31a74f46a6c190a2bee3bc136ee3e2440", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f93bc5b31a74f46a6c190a2bee3bc136ee3e2440", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f93bc5b31a74f46a6c190a2bee3bc136ee3e2440"}], "stats": {"total": 110, "additions": 95, "deletions": 15}, "files": [{"sha": "cd6aa9d7f016ae0ba28dcf766a0673995e818d00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb8f1a57612438e0922264c142cfa9c71aa67771/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb8f1a57612438e0922264c142cfa9c71aa67771/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb8f1a57612438e0922264c142cfa9c71aa67771", "patch": "@@ -1,3 +1,13 @@\n+2014-05-05  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/60363\n+\t* gcc/tree-ssa-threadupdate.c (get_value_locus_in_path): New.\n+\t(copy_phi_args): New parameters.  Call get_value_locus_in_path.\n+\t(update_destination_phis): New parameter.\n+\t(create_edge_and_update_destination_phis): Ditto.\n+\t(ssa_fix_duplicate_block_edges): Pass new arguments.\n+\t(thread_single_edge): Ditto.\n+\n 2014-05-04  Peter Bergner  <bergner@vnet.ibm.com>\n \n \t* config/rs6000/rs6000.h (RS6000_BTM_HARD_FLOAT): New define."}, {"sha": "8cbc790b276e66887e2424ffd159e46b1800bf49", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb8f1a57612438e0922264c142cfa9c71aa67771/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb8f1a57612438e0922264c142cfa9c71aa67771/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cb8f1a57612438e0922264c142cfa9c71aa67771", "patch": "@@ -1,3 +1,8 @@\n+2014-05-05  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/60363\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-4.c: Revert XFAIL test.\n+\n 2014-05-04  Peter Bergner  <bergner@vnet.ibm.com>\n \n \t* gcc.target/powerpc/pack02.c (dg-options): Add -mhard-float."}, {"sha": "cafdf13909e9eee7b6d88713e1467ed3c4cdfbbb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb8f1a57612438e0922264c142cfa9c71aa67771/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb8f1a57612438e0922264c142cfa9c71aa67771/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-4.c?ref=cb8f1a57612438e0922264c142cfa9c71aa67771", "patch": "@@ -75,6 +75,6 @@ bitmap_ior_and_compl (bitmap dst, const_bitmap a, const_bitmap b,\n       -> \"kill_elt->indx == b_elt->indx\" in the second condition,\n \t skipping the known-true \"b_elt && kill_elt\" in the second\n \t condition.  */\n-/* { dg-final { scan-tree-dump-times \"Threaded\" 4 \"dom1\" { target logical_op_short_circuit xfail logical_op_short_circuit } } } */\n+/* { dg-final { scan-tree-dump-times \"Threaded\" 4 \"dom1\" { target logical_op_short_circuit } } } */\n /* { dg-final { cleanup-tree-dump \"dom1\" } } */\n "}, {"sha": "0a24a5cc0ec690c97f22686358c5c3186be0dd00", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 79, "deletions": 14, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb8f1a57612438e0922264c142cfa9c71aa67771/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb8f1a57612438e0922264c142cfa9c71aa67771/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=cb8f1a57612438e0922264c142cfa9c71aa67771", "patch": "@@ -403,38 +403,96 @@ copy_phi_arg_into_existing_phi (edge src_e, edge tgt_e)\n     }\n }\n \n-/* For each PHI in BB, copy the argument associated with SRC_E to TGT_E.  */\n+/* Given ssa_name DEF, backtrack jump threading PATH from node IDX\n+   to see if it has constant value in a flow sensitive manner.  Set\n+   LOCUS to location of the constant phi arg and return the value.\n+   Return DEF directly if either PATH or idx is ZERO.  */\n+\n+static tree\n+get_value_locus_in_path (tree def, vec<jump_thread_edge *> *path,\n+\t\t\t basic_block bb, int idx, source_location *locus)\n+{\n+  tree arg;\n+  gimple def_phi;\n+  basic_block def_bb;\n+\n+  if (path == NULL || idx == 0)\n+    return def;\n+\n+  def_phi = SSA_NAME_DEF_STMT (def);\n+  if (gimple_code (def_phi) != GIMPLE_PHI)\n+    return def;\n+\n+  def_bb = gimple_bb (def_phi);\n+  /* Don't propagate loop invariants into deeper loops.  */\n+  if (!def_bb || bb_loop_depth (def_bb) < bb_loop_depth (bb))\n+    return def;\n+\n+  /* Backtrack jump threading path from IDX to see if def has constant\n+     value.  */\n+  for (int j = idx - 1; j >= 0; j--)\n+    {\n+      edge e = (*path)[j]->e;\n+      if (e->dest == def_bb)\n+\t{\n+\t  arg = gimple_phi_arg_def (def_phi, e->dest_idx);\n+\t  if (is_gimple_min_invariant (arg))\n+\t    {\n+\t      *locus = gimple_phi_arg_location (def_phi, e->dest_idx);\n+\t      return arg;\n+\t    }\n+\t  break;\n+\t}\n+    }\n+\n+  return def;\n+}\n+\n+/* For each PHI in BB, copy the argument associated with SRC_E to TGT_E.\n+   Try to backtrack jump threading PATH from node IDX to see if the arg\n+   has constant value, copy constant value instead of argument itself\n+   if yes.  */\n \n static void\n-copy_phi_args (basic_block bb, edge src_e, edge tgt_e)\n+copy_phi_args (basic_block bb, edge src_e, edge tgt_e,\n+\t       vec<jump_thread_edge *> *path, int idx)\n {\n   gimple_stmt_iterator gsi;\n   int src_indx = src_e->dest_idx;\n \n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple phi = gsi_stmt (gsi);\n+      tree def = gimple_phi_arg_def (phi, src_indx);\n       source_location locus = gimple_phi_arg_location (phi, src_indx);\n-      add_phi_arg (phi, gimple_phi_arg_def (phi, src_indx), tgt_e, locus);\n+\n+      if (TREE_CODE (def) == SSA_NAME\n+\t  && !virtual_operand_p (gimple_phi_result (phi)))\n+\tdef = get_value_locus_in_path (def, path, bb, idx, &locus);\n+\n+      add_phi_arg (phi, def, tgt_e, locus);\n     }\n }\n \n /* We have recently made a copy of ORIG_BB, including its outgoing\n    edges.  The copy is NEW_BB.  Every PHI node in every direct successor of\n    ORIG_BB has a new argument associated with edge from NEW_BB to the\n    successor.  Initialize the PHI argument so that it is equal to the PHI\n-   argument associated with the edge from ORIG_BB to the successor.  */\n+   argument associated with the edge from ORIG_BB to the successor.\n+   PATH and IDX are used to check if the new PHI argument has constant\n+   value in a flow sensitive manner.  */\n \n static void\n-update_destination_phis (basic_block orig_bb, basic_block new_bb)\n+update_destination_phis (basic_block orig_bb, basic_block new_bb,\n+\t\t\t vec<jump_thread_edge *> *path, int idx)\n {\n   edge_iterator ei;\n   edge e;\n \n   FOR_EACH_EDGE (e, ei, orig_bb->succs)\n     {\n       edge e2 = find_edge (new_bb, e->dest);\n-      copy_phi_args (e->dest, e, e2);\n+      copy_phi_args (e->dest, e, e2, path, idx);\n     }\n }\n \n@@ -443,11 +501,13 @@ update_destination_phis (basic_block orig_bb, basic_block new_bb)\n    destination.\n \n    Add an additional argument to any PHI nodes at the single\n-   destination.  */\n+   destination.  IDX is the start node in jump threading path\n+   we start to check to see if the new PHI argument has constant\n+   value along the jump threading path.  */\n \n static void\n create_edge_and_update_destination_phis (struct redirection_data *rd,\n-\t\t\t\t\t basic_block bb)\n+\t\t\t\t\t basic_block bb, int idx)\n {\n   edge e = make_edge (bb, rd->path->last ()->e->dest, EDGE_FALLTHRU);\n \n@@ -476,7 +536,7 @@ create_edge_and_update_destination_phis (struct redirection_data *rd,\n      from the duplicate block, then we will need to add a new argument\n      to them.  The argument should have the same value as the argument\n      associated with the outgoing edge stored in RD.  */\n-  copy_phi_args (e->dest, rd->path->last ()->e, e);\n+  copy_phi_args (e->dest, rd->path->last ()->e, e, rd->path, idx);\n }\n \n /* Look through PATH beginning at START and return TRUE if there are\n@@ -501,6 +561,7 @@ void\n ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t\t\t       ssa_local_info_t *local_info)\n {\n+  bool multi_incomings = (rd->incoming_edges->next != NULL);\n   edge e = rd->incoming_edges->e;\n   vec<jump_thread_edge *> *path = THREAD_PATH (e);\n \n@@ -516,8 +577,10 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t  edge e2;\n \n \t  /* This updates the PHIs at the destination of the duplicate\n-\t     block.  */\n-\t  update_destination_phis (local_info->bb, rd->dup_blocks[count]);\n+\t     block.  Pass 0 instead of i if we are threading a path which\n+\t     has multiple incoming edges.  */\n+\t  update_destination_phis (local_info->bb, rd->dup_blocks[count],\n+\t\t\t\t   path, multi_incomings ? 0 : i);\n \n \t  /* Find the edge from the duplicate block to the block we're\n \t     threading through.  That's the edge we want to redirect.  */\n@@ -535,7 +598,8 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n \t\t case), then the PHIs in the target already have the correct\n \t\t arguments.  */\n \t      if (e2 == victim)\n-\t\tcopy_phi_args (e2->dest, path->last ()->e, e2);\n+\t\tcopy_phi_args (e2->dest, path->last ()->e, e2,\n+\t\t\t       path, multi_incomings ? 0 : i);\n \t    }\n \t  else\n \t    {\n@@ -567,7 +631,8 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,\n       else if ((*path)[i]->type == EDGE_COPY_SRC_BLOCK)\n \t{\n \t  remove_ctrl_stmt_and_useless_edges (rd->dup_blocks[count], NULL);\n-\t  create_edge_and_update_destination_phis (rd, rd->dup_blocks[count]);\n+\t  create_edge_and_update_destination_phis (rd, rd->dup_blocks[count],\n+\t\t\t\t\t\t   multi_incomings ? 0 : i);\n \t  if (count == 1)\n \t    single_succ_edge (rd->dup_blocks[1])->aux = NULL;\n \t  count++;\n@@ -989,7 +1054,7 @@ thread_single_edge (edge e)\n \n   create_block_for_threading (bb, &rd, 0);\n   remove_ctrl_stmt_and_useless_edges (rd.dup_blocks[0], NULL);\n-  create_edge_and_update_destination_phis (&rd, rd.dup_blocks[0]);\n+  create_edge_and_update_destination_phis (&rd, rd.dup_blocks[0], 0);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\","}]}