{"sha": "4deef538ecda16acd4c0ae3d3ed71c591603ce73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRlZWY1MzhlY2RhMTZhY2Q0YzBhZTNkM2VkNzFjNTkxNjAzY2U3Mw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2011-02-03T06:04:04Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2011-02-03T06:04:04Z"}, "message": "re PR debug/43092 (Wrong debuginfo with VTA and -fomit-frame-pointer/-mno-accumulate-outgoing-args)\n\nPR debug/43092\nPR rtl-optimization/43494\n* rtl.h (for_each_inc_dec_fn): New type.\n(for_each_inc_dec): Declare.\n* rtlanal.c (struct for_each_inc_dec_ops): New type.\n(for_each_inc_dec_find_inc_dec): New fn.\n(for_each_inc_dec_find_mem): New fn.\n(for_each_inc_dec): New fn.\n* dse.c (struct insn_size): Remove.\n(replace_inc_dec, replace_inc_dec_mem): Remove.\n(emit_inc_dec_insn_before): New fn.\n(check_for_inc_dec): Use it, along with for_each_inc_dec.\n(canon_address): Pass mem modes to cselib_lookup.\n* cselib.h (cselib_lookup): Add memmode argument.  Adjust callers.\n(cselib_lookup_from_insn): Likewise.\n(cselib_subst_to_values): Likewise.\n* cselib.c (find_slot_memmode): New var.\n(cselib_find_slot): New fn.  Use it instead of\nhtab_find_slot_with_hash everywhere.\n(entry_and_rtx_equal_p): Use find_slot_memmode.\n(autoinc_split): New fn.\n(rtx_equal_for_cselib_p): Rename and implement in terms of...\n(rtx_equal_for_cselib_1): ... this.  Take memmode, pass it on.\nDeal with autoinc.  Special-case recursion into MEMs.\n(cselib_hash_rtx): Likewise.\n(cselib_lookup_mem): Infer pmode from address mode.  Distinguish\naddress and MEM modes.\n(cselib_subst_to_values): Add memmode, pass it on.\nDeal with autoinc.\n(cselib_lookup): Add memmode argument, pass it on.\n(cselib_lookup_from_insn): Add memmode.\n(cselib_invalidate_rtx): Discard obsolete push_operand handling.\n(struct cselib_record_autoinc_data): New.\n(cselib_record_autoinc_cb): New fn.\n(cselib_record_sets): Use it, along with for_each_inc_dec.  Pass MEM\nmode to cselib_lookup.  Reset autoinced REGs here instead of...\n(cselib_process_insn): ... here.\n* var-tracking.c (replace_expr_with_values, use_type): Pass MEM mode\nto cselib_lookup.\n(add_uses): Likewise, also to cselib_subst_to_values.\n(add_stores): Likewise.\n* sched-deps.c \t(add_insn_mem_dependence): Pass mode to\ncselib_subst_to_values.\n(sched_analyze_1, sched_analyze_2): Likewise.  Adjusted.\n* gcse.c (do_local_cprop): Adjusted.\n* postreload.c (reload_cse_simplify_set): Adjusted.\n(reload_cse_simplify_operands): Adjusted.\n* sel-sched-dump (debug_mem_addr_value): Pass mode.\n\nFrom-SVN: r169782", "tree": {"sha": "1064817b077534a9d4c8d69e161ab2fcd975a017", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1064817b077534a9d4c8d69e161ab2fcd975a017"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4deef538ecda16acd4c0ae3d3ed71c591603ce73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4deef538ecda16acd4c0ae3d3ed71c591603ce73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4deef538ecda16acd4c0ae3d3ed71c591603ce73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4deef538ecda16acd4c0ae3d3ed71c591603ce73/comments", "author": null, "committer": null, "parents": [{"sha": "1551d44aba2deeb55393396502ca091e41bcfee3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1551d44aba2deeb55393396502ca091e41bcfee3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1551d44aba2deeb55393396502ca091e41bcfee3"}], "stats": {"total": 640, "additions": 471, "deletions": 169}, "files": [{"sha": "90e257b51100727812d27256e2f29b6b1612cdde", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4deef538ecda16acd4c0ae3d3ed71c591603ce73", "patch": "@@ -1,3 +1,54 @@\n+2011-02-03  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/43092\n+\tPR rtl-optimization/43494\n+\t* rtl.h (for_each_inc_dec_fn): New type.\n+\t(for_each_inc_dec): Declare.\n+\t* rtlanal.c (struct for_each_inc_dec_ops): New type.\n+\t(for_each_inc_dec_find_inc_dec): New fn.\n+\t(for_each_inc_dec_find_mem): New fn.\n+\t(for_each_inc_dec): New fn.\n+\t* dse.c (struct insn_size): Remove.\n+\t(replace_inc_dec, replace_inc_dec_mem): Remove.\n+\t(emit_inc_dec_insn_before): New fn.\n+\t(check_for_inc_dec): Use it, along with for_each_inc_dec.\n+\t(canon_address): Pass mem modes to cselib_lookup.\n+\t* cselib.h (cselib_lookup): Add memmode argument.  Adjust callers.\n+\t(cselib_lookup_from_insn): Likewise.\n+\t(cselib_subst_to_values): Likewise.\n+\t* cselib.c (find_slot_memmode): New var.\n+\t(cselib_find_slot): New fn.  Use it instead of\n+\thtab_find_slot_with_hash everywhere.\n+\t(entry_and_rtx_equal_p): Use find_slot_memmode.\n+\t(autoinc_split): New fn.\n+\t(rtx_equal_for_cselib_p): Rename and implement in terms of...\n+\t(rtx_equal_for_cselib_1): ... this.  Take memmode, pass it on.\n+\tDeal with autoinc.  Special-case recursion into MEMs.\n+\t(cselib_hash_rtx): Likewise.\n+\t(cselib_lookup_mem): Infer pmode from address mode.  Distinguish\n+\taddress and MEM modes.\n+\t(cselib_subst_to_values): Add memmode, pass it on.\n+\tDeal with autoinc.\n+\t(cselib_lookup): Add memmode argument, pass it on.\n+\t(cselib_lookup_from_insn): Add memmode.\n+\t(cselib_invalidate_rtx): Discard obsolete push_operand handling.\n+\t(struct cselib_record_autoinc_data): New.\n+\t(cselib_record_autoinc_cb): New fn.\n+\t(cselib_record_sets): Use it, along with for_each_inc_dec.  Pass MEM\n+\tmode to cselib_lookup.  Reset autoinced REGs here instead of...\n+\t(cselib_process_insn): ... here.\n+\t* var-tracking.c (replace_expr_with_values, use_type): Pass MEM mode\n+\tto cselib_lookup.\n+\t(add_uses): Likewise, also to cselib_subst_to_values.\n+\t(add_stores): Likewise.\n+\t* sched-deps.c \t(add_insn_mem_dependence): Pass mode to\n+\tcselib_subst_to_values.\n+\t(sched_analyze_1, sched_analyze_2): Likewise.  Adjusted.\n+\t* gcse.c (do_local_cprop): Adjusted.\n+\t* postreload.c (reload_cse_simplify_set): Adjusted.\n+\t(reload_cse_simplify_operands): Adjusted.\n+\t* sel-sched-dump (debug_mem_addr_value): Pass mode.\n+\n 2011-02-03  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR tree-optimization/45122"}, {"sha": "c142d679b7a821974c06d2bb0a8b15241b5ac12d", "filename": "gcc/cselib.c", "status": "modified", "additions": 230, "deletions": 66, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=4deef538ecda16acd4c0ae3d3ed71c591603ce73", "patch": "@@ -62,7 +62,8 @@ static void unchain_one_elt_loc_list (struct elt_loc_list **);\n static int discard_useless_locs (void **, void *);\n static int discard_useless_values (void **, void *);\n static void remove_useless_values (void);\n-static unsigned int cselib_hash_rtx (rtx, int);\n+static int rtx_equal_for_cselib_1 (rtx, rtx, enum machine_mode);\n+static unsigned int cselib_hash_rtx (rtx, int, enum machine_mode);\n static cselib_val *new_cselib_val (unsigned int, enum machine_mode, rtx);\n static void add_mem_for_addr (cselib_val *, cselib_val *, rtx);\n static cselib_val *cselib_lookup_mem (rtx, int);\n@@ -390,6 +391,26 @@ cselib_get_next_uid (void)\n   return next_uid;\n }\n \n+/* See the documentation of cselib_find_slot below.  */\n+static enum machine_mode find_slot_memmode;\n+\n+/* Search for X, whose hashcode is HASH, in CSELIB_HASH_TABLE,\n+   INSERTing if requested.  When X is part of the address of a MEM,\n+   MEMMODE should specify the mode of the MEM.  While searching the\n+   table, MEMMODE is held in FIND_SLOT_MEMMODE, so that autoinc RTXs\n+   in X can be resolved.  */\n+\n+static void **\n+cselib_find_slot (rtx x, hashval_t hash, enum insert_option insert,\n+\t\t  enum machine_mode memmode)\n+{\n+  void **slot;\n+  find_slot_memmode = memmode;\n+  slot = htab_find_slot_with_hash (cselib_hash_table, x, hash, insert);\n+  find_slot_memmode = VOIDmode;\n+  return slot;\n+}\n+\n /* The equality test for our hash table.  The first argument ENTRY is a table\n    element (i.e. a cselib_val), while the second arg X is an rtx.  We know\n    that all callers of htab_find_slot_with_hash will wrap CONST_INTs into a\n@@ -419,7 +440,7 @@ entry_and_rtx_equal_p (const void *entry, const void *x_arg)\n   /* We don't guarantee that distinct rtx's have different hash values,\n      so we need to do a comparison.  */\n   for (l = v->locs; l; l = l->next)\n-    if (rtx_equal_for_cselib_p (l->loc, x))\n+    if (rtx_equal_for_cselib_1 (l->loc, x, find_slot_memmode))\n       {\n \tpromote_debug_loc (l);\n \treturn 1;\n@@ -630,22 +651,74 @@ cselib_reg_set_mode (const_rtx x)\n \n int\n rtx_equal_for_cselib_p (rtx x, rtx y)\n+{\n+  return rtx_equal_for_cselib_1 (x, y, VOIDmode);\n+}\n+\n+/* If x is a PLUS or an autoinc operation, expand the operation,\n+   storing the offset, if any, in *OFF.  */\n+\n+static rtx\n+autoinc_split (rtx x, rtx *off, enum machine_mode memmode)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case PLUS:\n+      *off = XEXP (x, 1);\n+      return XEXP (x, 0);\n+\n+    case PRE_DEC:\n+      if (memmode == VOIDmode)\n+\treturn x;\n+\n+      *off = GEN_INT (-GET_MODE_SIZE (memmode));\n+      return XEXP (x, 0);\n+      break;\n+\n+    case PRE_INC:\n+      if (memmode == VOIDmode)\n+\treturn x;\n+\n+      *off = GEN_INT (GET_MODE_SIZE (memmode));\n+      return XEXP (x, 0);\n+\n+    case PRE_MODIFY:\n+      return XEXP (x, 1);\n+\n+    case POST_DEC:\n+    case POST_INC:\n+    case POST_MODIFY:\n+      return XEXP (x, 0);\n+\n+    default:\n+      return x;\n+    }\n+}\n+\n+/* Return nonzero if we can prove that X and Y contain the same value,\n+   taking our gathered information into account.  MEMMODE holds the\n+   mode of the enclosing MEM, if any, as required to deal with autoinc\n+   addressing modes.  If X and Y are not (known to be) part of\n+   addresses, MEMMODE should be VOIDmode.  */\n+\n+static int\n+rtx_equal_for_cselib_1 (rtx x, rtx y, enum machine_mode memmode)\n {\n   enum rtx_code code;\n   const char *fmt;\n   int i;\n \n   if (REG_P (x) || MEM_P (x))\n     {\n-      cselib_val *e = cselib_lookup (x, GET_MODE (x), 0);\n+      cselib_val *e = cselib_lookup (x, GET_MODE (x), 0, memmode);\n \n       if (e)\n \tx = e->val_rtx;\n     }\n \n   if (REG_P (y) || MEM_P (y))\n     {\n-      cselib_val *e = cselib_lookup (y, GET_MODE (y), 0);\n+      cselib_val *e = cselib_lookup (y, GET_MODE (y), 0, memmode);\n \n       if (e)\n \ty = e->val_rtx;\n@@ -669,7 +742,7 @@ rtx_equal_for_cselib_p (rtx x, rtx y)\n \t  /* Avoid infinite recursion.  */\n \t  if (REG_P (t) || MEM_P (t))\n \t    continue;\n-\t  else if (rtx_equal_for_cselib_p (t, y))\n+\t  else if (rtx_equal_for_cselib_1 (t, y, memmode))\n \t    return 1;\n \t}\n \n@@ -687,16 +760,37 @@ rtx_equal_for_cselib_p (rtx x, rtx y)\n \n \t  if (REG_P (t) || MEM_P (t))\n \t    continue;\n-\t  else if (rtx_equal_for_cselib_p (x, t))\n+\t  else if (rtx_equal_for_cselib_1 (x, t, memmode))\n \t    return 1;\n \t}\n \n       return 0;\n     }\n \n-  if (GET_CODE (x) != GET_CODE (y) || GET_MODE (x) != GET_MODE (y))\n+  if (GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n+  if (GET_CODE (x) != GET_CODE (y))\n+    {\n+      rtx xorig = x, yorig = y;\n+      rtx xoff = NULL, yoff = NULL;\n+\n+      x = autoinc_split (x, &xoff, memmode);\n+      y = autoinc_split (y, &yoff, memmode);\n+\n+      if (!xoff != !yoff)\n+\treturn 0;\n+\n+      if (xoff && !rtx_equal_for_cselib_1 (xoff, yoff, memmode))\n+\treturn 0;\n+\n+      /* Don't recurse if nothing changed.  */\n+      if (x != xorig || y != yorig)\n+\treturn rtx_equal_for_cselib_1 (x, y, memmode);\n+\n+      return 0;\n+    }\n+\n   /* These won't be handled correctly by the code below.  */\n   switch (GET_CODE (x))\n     {\n@@ -712,6 +806,11 @@ rtx_equal_for_cselib_p (rtx x, rtx y)\n     case LABEL_REF:\n       return XEXP (x, 0) == XEXP (y, 0);\n \n+    case MEM:\n+      /* We have to compare any autoinc operations in the addresses\n+\t using this MEM's mode.  */\n+      return rtx_equal_for_cselib_1 (XEXP (x, 0), XEXP (y, 0), GET_MODE (x));\n+\n     default:\n       break;\n     }\n@@ -744,18 +843,18 @@ rtx_equal_for_cselib_p (rtx x, rtx y)\n \n \t  /* And the corresponding elements must match.  */\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    if (! rtx_equal_for_cselib_p (XVECEXP (x, i, j),\n-\t\t\t\t\t  XVECEXP (y, i, j)))\n+\t    if (! rtx_equal_for_cselib_1 (XVECEXP (x, i, j),\n+\t\t\t\t\t  XVECEXP (y, i, j), memmode))\n \t      return 0;\n \t  break;\n \n \tcase 'e':\n \t  if (i == 1\n \t      && targetm.commutative_p (x, UNKNOWN)\n-\t      && rtx_equal_for_cselib_p (XEXP (x, 1), XEXP (y, 0))\n-\t      && rtx_equal_for_cselib_p (XEXP (x, 0), XEXP (y, 1)))\n+\t      && rtx_equal_for_cselib_1 (XEXP (x, 1), XEXP (y, 0), memmode)\n+\t      && rtx_equal_for_cselib_1 (XEXP (x, 0), XEXP (y, 1), memmode))\n \t    return 1;\n-\t  if (! rtx_equal_for_cselib_p (XEXP (x, i), XEXP (y, i)))\n+\t  if (! rtx_equal_for_cselib_1 (XEXP (x, i), XEXP (y, i), memmode))\n \t    return 0;\n \t  break;\n \n@@ -807,6 +906,8 @@ wrap_constant (enum machine_mode mode, rtx x)\n    that take commutativity into account.\n    If we wanted to also support associative rules, we'd have to use a different\n    strategy to avoid returning spurious 0, e.g. return ~(~0U >> 1) .\n+   MEMMODE indicates the mode of an enclosing MEM, and it's only\n+   used to compute autoinc values.\n    We used to have a MODE argument for hashing for CONST_INTs, but that\n    didn't make sense, since it caused spurious hash differences between\n     (set (reg:SI 1) (const_int))\n@@ -817,7 +918,7 @@ wrap_constant (enum machine_mode mode, rtx x)\n    in a comparison anyway, since relying on hash differences is unsafe.  */\n \n static unsigned int\n-cselib_hash_rtx (rtx x, int create)\n+cselib_hash_rtx (rtx x, int create, enum machine_mode memmode)\n {\n   cselib_val *e;\n   int i, j;\n@@ -832,7 +933,7 @@ cselib_hash_rtx (rtx x, int create)\n     {\n     case MEM:\n     case REG:\n-      e = cselib_lookup (x, GET_MODE (x), create);\n+      e = cselib_lookup (x, GET_MODE (x), create, memmode);\n       if (! e)\n \treturn 0;\n \n@@ -878,7 +979,7 @@ cselib_hash_rtx (rtx x, int create)\n \tfor (i = 0; i < units; ++i)\n \t  {\n \t    elt = CONST_VECTOR_ELT (x, i);\n-\t    hash += cselib_hash_rtx (elt, 0);\n+\t    hash += cselib_hash_rtx (elt, 0, memmode);\n \t  }\n \n \treturn hash;\n@@ -911,10 +1012,28 @@ cselib_hash_rtx (rtx x, int create)\n \n     case PRE_DEC:\n     case PRE_INC:\n+      /* We can't compute these without knowing the MEM mode.  */\n+      gcc_assert (memmode != VOIDmode);\n+      i = GET_MODE_SIZE (memmode);\n+      if (code == PRE_DEC)\n+\ti = -i;\n+      /* Adjust the hash so that (mem:MEMMODE (pre_* (reg))) hashes\n+\t like (mem:MEMMODE (plus (reg) (const_int I))).  */\n+      hash += (unsigned) PLUS - (unsigned)code\n+\t+ cselib_hash_rtx (XEXP (x, 0), create, memmode)\n+\t+ cselib_hash_rtx (GEN_INT (i), create, memmode);\n+      return hash ? hash : 1 + (unsigned) PLUS;\n+\n+    case PRE_MODIFY:\n+      gcc_assert (memmode != VOIDmode);\n+      return cselib_hash_rtx (XEXP (x, 1), create, memmode);\n+\n     case POST_DEC:\n     case POST_INC:\n     case POST_MODIFY:\n-    case PRE_MODIFY:\n+      gcc_assert (memmode != VOIDmode);\n+      return cselib_hash_rtx (XEXP (x, 0), create, memmode);\n+\n     case PC:\n     case CC0:\n     case CALL:\n@@ -940,7 +1059,7 @@ cselib_hash_rtx (rtx x, int create)\n \tcase 'e':\n \t  {\n \t    rtx tem = XEXP (x, i);\n-\t    unsigned int tem_hash = cselib_hash_rtx (tem, create);\n+\t    unsigned int tem_hash = cselib_hash_rtx (tem, create, memmode);\n \n \t    if (tem_hash == 0)\n \t      return 0;\n@@ -952,7 +1071,7 @@ cselib_hash_rtx (rtx x, int create)\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    {\n \t      unsigned int tem_hash\n-\t\t= cselib_hash_rtx (XVECEXP (x, i, j), create);\n+\t\t= cselib_hash_rtx (XVECEXP (x, i, j), create, memmode);\n \n \t      if (tem_hash == 0)\n \t\treturn 0;\n@@ -1065,6 +1184,7 @@ static cselib_val *\n cselib_lookup_mem (rtx x, int create)\n {\n   enum machine_mode mode = GET_MODE (x);\n+  enum machine_mode addr_mode;\n   void **slot;\n   cselib_val *addr;\n   cselib_val *mem_elt;\n@@ -1075,8 +1195,12 @@ cselib_lookup_mem (rtx x, int create)\n       || (FLOAT_MODE_P (mode) && flag_float_store))\n     return 0;\n \n+  addr_mode = GET_MODE (XEXP (x, 0));\n+  if (addr_mode == VOIDmode)\n+    addr_mode = Pmode;\n+\n   /* Look up the value for the address.  */\n-  addr = cselib_lookup (XEXP (x, 0), mode, create);\n+  addr = cselib_lookup (XEXP (x, 0), addr_mode, create, mode);\n   if (! addr)\n     return 0;\n \n@@ -1093,8 +1217,8 @@ cselib_lookup_mem (rtx x, int create)\n \n   mem_elt = new_cselib_val (next_uid, mode, x);\n   add_mem_for_addr (addr, mem_elt, x);\n-  slot = htab_find_slot_with_hash (cselib_hash_table, wrap_constant (mode, x),\n-\t\t\t\t   mem_elt->hash, INSERT);\n+  slot = cselib_find_slot (wrap_constant (mode, x), mem_elt->hash,\n+\t\t\t   INSERT, mode);\n   *slot = mem_elt;\n   return mem_elt;\n }\n@@ -1526,10 +1650,11 @@ cselib_expand_value_rtx_1 (rtx orig, struct expand_value_data *evd,\n    with VALUE expressions.  This way, it becomes independent of changes\n    to registers and memory.\n    X isn't actually modified; if modifications are needed, new rtl is\n-   allocated.  However, the return value can share rtl with X.  */\n+   allocated.  However, the return value can share rtl with X.\n+   If X is within a MEM, MEMMODE must be the mode of the MEM.  */\n \n rtx\n-cselib_subst_to_values (rtx x)\n+cselib_subst_to_values (rtx x, enum machine_mode memmode)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char *fmt = GET_RTX_FORMAT (code);\n@@ -1552,10 +1677,11 @@ cselib_subst_to_values (rtx x)\n \n     case MEM:\n       e = cselib_lookup_mem (x, 0);\n+      /* This used to happen for autoincrements, but we deal with them\n+\t properly now.  Remove the if stmt for the next release.  */\n       if (! e)\n \t{\n-\t  /* This happens for autoincrements.  Assign a value that doesn't\n-\t     match any other.  */\n+\t  /* Assign a value that doesn't match any other.  */\n \t  e = new_cselib_val (next_uid, GET_MODE (x), x);\n \t}\n       return e->val_rtx;\n@@ -1566,14 +1692,24 @@ cselib_subst_to_values (rtx x)\n     case CONST_FIXED:\n       return x;\n \n-    case POST_INC:\n+    case PRE_DEC:\n     case PRE_INC:\n+      gcc_assert (memmode != VOIDmode);\n+      i = GET_MODE_SIZE (memmode);\n+      if (code == PRE_DEC)\n+\ti = -i;\n+      return cselib_subst_to_values (plus_constant (XEXP (x, 0), i),\n+\t\t\t\t     memmode);\n+\n+    case PRE_MODIFY:\n+      gcc_assert (memmode != VOIDmode);\n+      return cselib_subst_to_values (XEXP (x, 1), memmode);\n+\n     case POST_DEC:\n-    case PRE_DEC:\n+    case POST_INC:\n     case POST_MODIFY:\n-    case PRE_MODIFY:\n-      e = new_cselib_val (next_uid, GET_MODE (x), x);\n-      return e->val_rtx;\n+      gcc_assert (memmode != VOIDmode);\n+      return cselib_subst_to_values (XEXP (x, 0), memmode);\n \n     default:\n       break;\n@@ -1583,7 +1719,7 @@ cselib_subst_to_values (rtx x)\n     {\n       if (fmt[i] == 'e')\n \t{\n-\t  rtx t = cselib_subst_to_values (XEXP (x, i));\n+\t  rtx t = cselib_subst_to_values (XEXP (x, i), memmode);\n \n \t  if (t != XEXP (x, i))\n \t    {\n@@ -1598,7 +1734,7 @@ cselib_subst_to_values (rtx x)\n \n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    {\n-\t      rtx t = cselib_subst_to_values (XVECEXP (x, i, j));\n+\t      rtx t = cselib_subst_to_values (XVECEXP (x, i, j), memmode);\n \n \t      if (t != XVECEXP (x, i, j))\n \t\t{\n@@ -1617,13 +1753,16 @@ cselib_subst_to_values (rtx x)\n   return copy;\n }\n \n-/* Look up the rtl expression X in our tables and return the value it has.\n-   If CREATE is zero, we return NULL if we don't know the value.  Otherwise,\n-   we create a new one if possible, using mode MODE if X doesn't have a mode\n-   (i.e. because it's a constant).  */\n+/* Look up the rtl expression X in our tables and return the value it\n+   has.  If CREATE is zero, we return NULL if we don't know the value.\n+   Otherwise, we create a new one if possible, using mode MODE if X\n+   doesn't have a mode (i.e. because it's a constant).  When X is part\n+   of an address, MEMMODE should be the mode of the enclosing MEM if\n+   we're tracking autoinc expressions.  */\n \n static cselib_val *\n-cselib_lookup_1 (rtx x, enum machine_mode mode, int create)\n+cselib_lookup_1 (rtx x, enum machine_mode mode,\n+\t\t int create, enum machine_mode memmode)\n {\n   void **slot;\n   cselib_val *e;\n@@ -1672,21 +1811,21 @@ cselib_lookup_1 (rtx x, enum machine_mode mode, int create)\n \t  REG_VALUES (i) = new_elt_list (REG_VALUES (i), NULL);\n \t}\n       REG_VALUES (i)->next = new_elt_list (REG_VALUES (i)->next, e);\n-      slot = htab_find_slot_with_hash (cselib_hash_table, x, e->hash, INSERT);\n+      slot = cselib_find_slot (x, e->hash, INSERT, memmode);\n       *slot = e;\n       return e;\n     }\n \n   if (MEM_P (x))\n     return cselib_lookup_mem (x, create);\n \n-  hashval = cselib_hash_rtx (x, create);\n+  hashval = cselib_hash_rtx (x, create, memmode);\n   /* Can't even create if hashing is not possible.  */\n   if (! hashval)\n     return 0;\n \n-  slot = htab_find_slot_with_hash (cselib_hash_table, wrap_constant (mode, x),\n-\t\t\t\t   hashval, create ? INSERT : NO_INSERT);\n+  slot = cselib_find_slot (wrap_constant (mode, x), hashval,\n+\t\t\t   create ? INSERT : NO_INSERT, memmode);\n   if (slot == 0)\n     return 0;\n \n@@ -1700,22 +1839,23 @@ cselib_lookup_1 (rtx x, enum machine_mode mode, int create)\n      the hash table is inconsistent until we do so, and\n      cselib_subst_to_values will need to do lookups.  */\n   *slot = (void *) e;\n-  e->locs = new_elt_loc_list (e->locs, cselib_subst_to_values (x));\n+  e->locs = new_elt_loc_list (e->locs,\n+\t\t\t      cselib_subst_to_values (x, memmode));\n   return e;\n }\n \n /* Wrapper for cselib_lookup, that indicates X is in INSN.  */\n \n cselib_val *\n cselib_lookup_from_insn (rtx x, enum machine_mode mode,\n-\t\t\t int create, rtx insn)\n+\t\t\t int create, enum machine_mode memmode, rtx insn)\n {\n   cselib_val *ret;\n \n   gcc_assert (!cselib_current_insn);\n   cselib_current_insn = insn;\n \n-  ret = cselib_lookup (x, mode, create);\n+  ret = cselib_lookup (x, mode, create, memmode);\n \n   cselib_current_insn = NULL;\n \n@@ -1726,9 +1866,10 @@ cselib_lookup_from_insn (rtx x, enum machine_mode mode,\n    maintains invariants related with debug insns.  */\n \n cselib_val *\n-cselib_lookup (rtx x, enum machine_mode mode, int create)\n+cselib_lookup (rtx x, enum machine_mode mode,\n+\t       int create, enum machine_mode memmode)\n {\n-  cselib_val *ret = cselib_lookup_1 (x, mode, create);\n+  cselib_val *ret = cselib_lookup_1 (x, mode, create, memmode);\n \n   /* ??? Should we return NULL if we're not to create an entry, the\n      found loc is a debug loc and cselib_current_insn is not DEBUG?\n@@ -1913,7 +2054,7 @@ cselib_invalidate_mem (rtx mem_rtx)\n \t  /* This one overlaps.  */\n \t  /* We must have a mapping from this MEM's address to the\n \t     value (E).  Remove that, too.  */\n-\t  addr = cselib_lookup (XEXP (x, 0), VOIDmode, 0);\n+\t  addr = cselib_lookup (XEXP (x, 0), VOIDmode, 0, GET_MODE (x));\n \t  mem_chain = &addr->addr_list;\n \t  for (;;)\n \t    {\n@@ -1963,13 +2104,6 @@ cselib_invalidate_rtx (rtx dest)\n     cselib_invalidate_regno (REGNO (dest), GET_MODE (dest));\n   else if (MEM_P (dest))\n     cselib_invalidate_mem (dest);\n-\n-  /* Some machines don't define AUTO_INC_DEC, but they still use push\n-     instructions.  We need to catch that case here in order to\n-     invalidate the stack pointer correctly.  Note that invalidating\n-     the stack pointer is different from invalidating DEST.  */\n-  if (push_operand (dest, GET_MODE (dest)))\n-    cselib_invalidate_rtx (stack_pointer_rtx);\n }\n \n /* A wrapper for cselib_invalidate_rtx to be called via note_stores.  */\n@@ -2032,7 +2166,35 @@ cselib_record_set (rtx dest, cselib_val *src_elt, cselib_val *dest_addr_elt)\n    in a PARALLEL.  Since it's fairly cheap, use a really large number.  */\n #define MAX_SETS (FIRST_PSEUDO_REGISTER * 2)\n \n-/* Record the effects of any sets in INSN.  */\n+struct cselib_record_autoinc_data\n+{\n+  struct cselib_set *sets;\n+  int n_sets;\n+};\n+\n+/* Callback for for_each_inc_dec.  Records in ARG the SETs implied by\n+   autoinc RTXs: SRC plus SRCOFF if non-NULL is stored in DEST.  */\n+\n+static int\n+cselib_record_autoinc_cb (rtx mem ATTRIBUTE_UNUSED, rtx op ATTRIBUTE_UNUSED,\n+\t\t\t  rtx dest, rtx src, rtx srcoff, void *arg)\n+{\n+  struct cselib_record_autoinc_data *data;\n+  data = (struct cselib_record_autoinc_data *)arg;\n+\n+  data->sets[data->n_sets].dest = dest;\n+\n+  if (srcoff)\n+    data->sets[data->n_sets].src = gen_rtx_PLUS (GET_MODE (src), src, srcoff);\n+  else\n+    data->sets[data->n_sets].src = src;\n+\n+  data->n_sets++;\n+\n+  return -1;\n+}\n+\n+/* Record the effects of any sets and autoincs in INSN.  */\n static void\n cselib_record_sets (rtx insn)\n {\n@@ -2041,6 +2203,8 @@ cselib_record_sets (rtx insn)\n   struct cselib_set sets[MAX_SETS];\n   rtx body = PATTERN (insn);\n   rtx cond = 0;\n+  int n_sets_before_autoinc;\n+  struct cselib_record_autoinc_data data;\n \n   body = PATTERN (insn);\n   if (GET_CODE (body) == COND_EXEC)\n@@ -2084,6 +2248,11 @@ cselib_record_sets (rtx insn)\n \tsets[0].src = XEXP (note, 0);\n     }\n \n+  data.sets = sets;\n+  data.n_sets = n_sets_before_autoinc = n_sets;\n+  for_each_inc_dec (&insn, cselib_record_autoinc_cb, &data);\n+  n_sets = data.n_sets;\n+\n   /* Look up the values that are read.  Do this before invalidating the\n      locations that are written.  */\n   for (i = 0; i < n_sets; i++)\n@@ -2102,14 +2271,15 @@ cselib_record_sets (rtx insn)\n \t  rtx src = sets[i].src;\n \t  if (cond)\n \t    src = gen_rtx_IF_THEN_ELSE (GET_MODE (dest), cond, src, dest);\n-\t  sets[i].src_elt = cselib_lookup (src, GET_MODE (dest), 1);\n+\t  sets[i].src_elt = cselib_lookup (src, GET_MODE (dest), 1, VOIDmode);\n \t  if (MEM_P (dest))\n \t    {\n \t      enum machine_mode address_mode\n \t\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (dest));\n \n \t      sets[i].dest_addr_elt = cselib_lookup (XEXP (dest, 0),\n-\t\t\t\t\t\t     address_mode, 1);\n+\t\t\t\t\t\t     address_mode, 1,\n+\t\t\t\t\t\t     GET_MODE (dest));\n \t    }\n \t  else\n \t    sets[i].dest_addr_elt = 0;\n@@ -2124,6 +2294,9 @@ cselib_record_sets (rtx insn)\n      locations may go away.  */\n   note_stores (body, cselib_invalidate_rtx_note_stores, NULL);\n \n+  for (i = n_sets_before_autoinc; i < n_sets; i++)\n+    cselib_invalidate_rtx (sets[i].dest);\n+\n   /* If this is an asm, look for duplicate sets.  This can happen when the\n      user uses the same value as an output multiple times.  This is valid\n      if the outputs are not actually used thereafter.  Treat this case as\n@@ -2208,15 +2381,6 @@ cselib_process_insn (rtx insn)\n \n   cselib_record_sets (insn);\n \n-#ifdef AUTO_INC_DEC\n-  /* Clobber any registers which appear in REG_INC notes.  We\n-     could keep track of the changes to their values, but it is\n-     unlikely to help.  */\n-  for (x = REG_NOTES (insn); x; x = XEXP (x, 1))\n-    if (REG_NOTE_KIND (x) == REG_INC)\n-      cselib_invalidate_rtx (XEXP (x, 0));\n-#endif\n-\n   /* Look for any CLOBBERs in CALL_INSN_FUNCTION_USAGE, but only\n      after we have processed the insn.  */\n   if (CALL_P (insn))"}, {"sha": "3590f980e434de5c0b280511db1b5c65519543a9", "filename": "gcc/cselib.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=4deef538ecda16acd4c0ae3d3ed71c591603ce73", "patch": "@@ -70,8 +70,10 @@ extern void (*cselib_discard_hook) (cselib_val *);\n extern void (*cselib_record_sets_hook) (rtx insn, struct cselib_set *sets,\n \t\t\t\t\tint n_sets);\n \n-extern cselib_val *cselib_lookup (rtx, enum machine_mode, int);\n-extern cselib_val *cselib_lookup_from_insn (rtx, enum machine_mode, int, rtx);\n+extern cselib_val *cselib_lookup (rtx, enum machine_mode,\n+\t\t\t\t  int, enum machine_mode);\n+extern cselib_val *cselib_lookup_from_insn (rtx, enum machine_mode,\n+\t\t\t\t\t    int, enum machine_mode, rtx);\n extern void cselib_init (int);\n extern void cselib_clear_table (void);\n extern void cselib_finish (void);\n@@ -85,7 +87,7 @@ extern rtx cselib_expand_value_rtx_cb (rtx, bitmap, int,\n \t\t\t\t       cselib_expand_callback, void *);\n extern bool cselib_dummy_expand_value_rtx_cb (rtx, bitmap, int,\n \t\t\t\t\t      cselib_expand_callback, void *);\n-extern rtx cselib_subst_to_values (rtx);\n+extern rtx cselib_subst_to_values (rtx, enum machine_mode);\n extern void cselib_invalidate_rtx (rtx);\n \n extern void cselib_reset_table (unsigned int);"}, {"sha": "11639816bca7ff195e48f528f8697780fed716ad", "filename": "gcc/dse.c", "status": "modified", "additions": 15, "deletions": 72, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=4deef538ecda16acd4c0ae3d3ed71c591603ce73", "patch": "@@ -806,82 +806,25 @@ free_store_info (insn_info_t insn_info)\n   insn_info->store_rec = NULL;\n }\n \n-\n-struct insn_size {\n-  int size;\n-  rtx insn;\n-};\n-\n-\n-/* Add an insn to do the add inside a x if it is a\n-   PRE/POST-INC/DEC/MODIFY.  D is an structure containing the insn and\n-   the size of the mode of the MEM that this is inside of.  */\n+/* Callback for for_each_inc_dec that emits an INSN that sets DEST to\n+   SRC + SRCOFF before insn ARG.  */\n \n static int\n-replace_inc_dec (rtx *r, void *d)\n+emit_inc_dec_insn_before (rtx mem ATTRIBUTE_UNUSED,\n+\t\t\t  rtx op ATTRIBUTE_UNUSED,\n+\t\t\t  rtx dest, rtx src, rtx srcoff, void *arg)\n {\n-  rtx x = *r;\n-  struct insn_size *data = (struct insn_size *)d;\n-  switch (GET_CODE (x))\n-    {\n-    case PRE_INC:\n-    case POST_INC:\n-      {\n-\trtx r1 = XEXP (x, 0);\n-\trtx c = gen_int_mode (data->size, GET_MODE (r1));\n-\temit_insn_before (gen_rtx_SET (VOIDmode, r1,\n-\t\t\t\t       gen_rtx_PLUS (GET_MODE (r1), r1, c)),\n-\t\t\t  data->insn);\n-\treturn -1;\n-      }\n+  rtx insn = (rtx)arg;\n \n-    case PRE_DEC:\n-    case POST_DEC:\n-      {\n-\trtx r1 = XEXP (x, 0);\n-\trtx c = gen_int_mode (-data->size, GET_MODE (r1));\n-\temit_insn_before (gen_rtx_SET (VOIDmode, r1,\n-\t\t\t\t       gen_rtx_PLUS (GET_MODE (r1), r1, c)),\n-\t\t\t  data->insn);\n-\treturn -1;\n-      }\n+  if (srcoff)\n+    src = gen_rtx_PLUS (GET_MODE (src), src, srcoff);\n \n-    case PRE_MODIFY:\n-    case POST_MODIFY:\n-      {\n-\t/* We can reuse the add because we are about to delete the\n-\t   insn that contained it.  */\n-\trtx add = XEXP (x, 0);\n-\trtx r1 = XEXP (add, 0);\n-\temit_insn_before (gen_rtx_SET (VOIDmode, r1, add), data->insn);\n-\treturn -1;\n-      }\n-\n-    default:\n-      return 0;\n-    }\n-}\n+  /* We can reuse all operands without copying, because we are about\n+     to delete the insn that contained it.  */\n \n+  emit_insn_before (gen_rtx_SET (VOIDmode, dest, src), insn);\n \n-/* If X is a MEM, check the address to see if it is PRE/POST-INC/DEC/MODIFY\n-   and generate an add to replace that.  */\n-\n-static int\n-replace_inc_dec_mem (rtx *r, void *d)\n-{\n-  rtx x = *r;\n-  if (x != NULL_RTX && MEM_P (x))\n-    {\n-      struct insn_size data;\n-\n-      data.size = GET_MODE_SIZE (GET_MODE (x));\n-      data.insn = (rtx) d;\n-\n-      for_each_rtx (&XEXP (x, 0), replace_inc_dec, &data);\n-\n-      return -1;\n-    }\n-  return 0;\n+  return -1;\n }\n \n /* Before we delete INSN, make sure that the auto inc/dec, if it is\n@@ -892,7 +835,7 @@ check_for_inc_dec (rtx insn)\n {\n   rtx note = find_reg_note (insn, REG_INC, NULL_RTX);\n   if (note)\n-    for_each_rtx (&insn, replace_inc_dec_mem, insn);\n+    for_each_inc_dec (&insn, emit_inc_dec_insn_before, insn);\n }\n \n \n@@ -1107,7 +1050,7 @@ canon_address (rtx mem,\n \n   *alias_set_out = 0;\n \n-  cselib_lookup (mem_address, address_mode, 1);\n+  cselib_lookup (mem_address, address_mode, 1, GET_MODE (mem));\n \n   if (dump_file)\n     {\n@@ -1187,7 +1130,7 @@ canon_address (rtx mem,\n \t}\n     }\n \n-  *base = cselib_lookup (address, address_mode, true);\n+  *base = cselib_lookup (address, address_mode, true, GET_MODE (mem));\n   *group_id = -1;\n \n   if (*base == NULL)"}, {"sha": "27f7e8fe0346e9fae9db1b57f03be09b6d3b2450", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=4deef538ecda16acd4c0ae3d3ed71c591603ce73", "patch": "@@ -2738,7 +2738,7 @@ do_local_cprop (rtx x, rtx insn)\n           || (GET_CODE (PATTERN (insn)) != USE\n \t      && asm_noperands (PATTERN (insn)) < 0)))\n     {\n-      cselib_val *val = cselib_lookup (x, GET_MODE (x), 0);\n+      cselib_val *val = cselib_lookup (x, GET_MODE (x), 0, VOIDmode);\n       struct elt_loc_list *l;\n \n       if (!val)"}, {"sha": "5cd26a79ddf1636747e456e229ca9409beff991a", "filename": "gcc/postreload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=4deef538ecda16acd4c0ae3d3ed71c591603ce73", "patch": "@@ -262,7 +262,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n     return 0;\n #endif\n \n-  val = cselib_lookup (src, GET_MODE (SET_DEST (set)), 0);\n+  val = cselib_lookup (src, GET_MODE (SET_DEST (set)), 0, VOIDmode);\n   if (! val)\n     return 0;\n \n@@ -476,7 +476,7 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \t    continue;\n \t}\n #endif /* LOAD_EXTEND_OP */\n-      v = cselib_lookup (op, recog_data.operand_mode[i], 0);\n+      v = cselib_lookup (op, recog_data.operand_mode[i], 0, VOIDmode);\n       if (! v)\n \tcontinue;\n "}, {"sha": "268613b6f1ceadc7ccaeeef1ea6d702ce966968f", "filename": "gcc/rtl.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4deef538ecda16acd4c0ae3d3ed71c591603ce73", "patch": "@@ -1916,6 +1916,17 @@ extern int computed_jump_p (const_rtx);\n typedef int (*rtx_function) (rtx *, void *);\n extern int for_each_rtx (rtx *, rtx_function, void *);\n \n+/* Callback for for_each_inc_dec, to process the autoinc operation OP\n+   within MEM that sets DEST to SRC + SRCOFF, or SRC if SRCOFF is\n+   NULL.  The callback is passed the same opaque ARG passed to\n+   for_each_inc_dec.  Return zero to continue looking for other\n+   autoinc operations, -1 to skip OP's operands, and any other value\n+   to interrupt the traversal and return that value to the caller of\n+   for_each_inc_dec.  */\n+typedef int (*for_each_inc_dec_fn) (rtx mem, rtx op, rtx dest, rtx src,\n+\t\t\t\t    rtx srcoff, void *arg);\n+extern int for_each_inc_dec (rtx *, for_each_inc_dec_fn, void *arg);\n+\n typedef int (*rtx_equal_p_callback_function) (const_rtx *, const_rtx *,\n                                               rtx *, rtx *);\n extern int rtx_equal_p_cb (const_rtx, const_rtx,"}, {"sha": "d9710bdac13a64103c6a8c21f72a2a6f08ac96b3", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=4deef538ecda16acd4c0ae3d3ed71c591603ce73", "patch": "@@ -2886,7 +2886,124 @@ for_each_rtx (rtx *x, rtx_function f, void *data)\n   return for_each_rtx_1 (*x, i, f, data);\n }\n \n+\f\n+\n+/* Data structure that holds the internal state communicated between\n+   for_each_inc_dec, for_each_inc_dec_find_mem and\n+   for_each_inc_dec_find_inc_dec.  */\n+\n+struct for_each_inc_dec_ops {\n+  /* The function to be called for each autoinc operation found.  */\n+  for_each_inc_dec_fn fn;\n+  /* The opaque argument to be passed to it.  */\n+  void *arg;\n+  /* The MEM we're visiting, if any.  */\n+  rtx mem;\n+};\n+\n+static int for_each_inc_dec_find_mem (rtx *r, void *d);\n+\n+/* Find PRE/POST-INC/DEC/MODIFY operations within *R, extract the\n+   operands of the equivalent add insn and pass the result to the\n+   operator specified by *D.  */\n+\n+static int\n+for_each_inc_dec_find_inc_dec (rtx *r, void *d)\n+{\n+  rtx x = *r;\n+  struct for_each_inc_dec_ops *data = (struct for_each_inc_dec_ops *)d;\n \n+  switch (GET_CODE (x))\n+    {\n+    case PRE_INC:\n+    case POST_INC:\n+      {\n+\tint size = GET_MODE_SIZE (GET_MODE (data->mem));\n+\trtx r1 = XEXP (x, 0);\n+\trtx c = gen_int_mode (size, GET_MODE (r1));\n+\treturn data->fn (data->mem, x, r1, r1, c, data->arg);\n+      }\n+\n+    case PRE_DEC:\n+    case POST_DEC:\n+      {\n+\tint size = GET_MODE_SIZE (GET_MODE (data->mem));\n+\trtx r1 = XEXP (x, 0);\n+\trtx c = gen_int_mode (-size, GET_MODE (r1));\n+\treturn data->fn (data->mem, x, r1, r1, c, data->arg);\n+      }\n+\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n+      {\n+\trtx r1 = XEXP (x, 0);\n+\trtx add = XEXP (x, 1);\n+\treturn data->fn (data->mem, x, r1, add, NULL, data->arg);\n+      }\n+\n+    case MEM:\n+      {\n+\trtx save = data->mem;\n+\tint ret = for_each_inc_dec_find_mem (r, d);\n+\tdata->mem = save;\n+\treturn ret;\n+      }\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* If *R is a MEM, find PRE/POST-INC/DEC/MODIFY operations within its\n+   address, extract the operands of the equivalent add insn and pass\n+   the result to the operator specified by *D.  */\n+\n+static int\n+for_each_inc_dec_find_mem (rtx *r, void *d)\n+{\n+  rtx x = *r;\n+  if (x != NULL_RTX && MEM_P (x))\n+    {\n+      struct for_each_inc_dec_ops *data = (struct for_each_inc_dec_ops *) d;\n+      int result;\n+\n+      data->mem = x;\n+\n+      result = for_each_rtx (&XEXP (x, 0), for_each_inc_dec_find_inc_dec,\n+\t\t\t     data);\n+      if (result)\n+\treturn result;\n+\n+      return -1;\n+    }\n+  return 0;\n+}\n+\n+/* Traverse *X looking for MEMs, and for autoinc operations within\n+   them.  For each such autoinc operation found, call FN, passing it\n+   the innermost enclosing MEM, the operation itself, the RTX modified\n+   by the operation, two RTXs (the second may be NULL) that, once\n+   added, represent the value to be held by the modified RTX\n+   afterwards, and ARG.  FN is to return -1 to skip looking for other\n+   autoinc operations within the visited operation, 0 to continue the\n+   traversal, or any other value to have it returned to the caller of\n+   for_each_inc_dec.  */\n+\n+int\n+for_each_inc_dec (rtx *x,\n+\t\t  for_each_inc_dec_fn fn,\n+\t\t  void *arg)\n+{\n+  struct for_each_inc_dec_ops data;\n+\n+  data.fn = fn;\n+  data.arg = arg;\n+  data.mem = NULL;\n+\n+  return for_each_rtx (x, for_each_inc_dec_find_mem, &data);\n+}\n+\n+\f\n /* Searches X for any reference to REGNO, returning the rtx of the\n    reference found if any.  Otherwise, returns NULL_RTX.  */\n "}, {"sha": "7293fc3c972c976365e04b94c8b561af8977ffdf", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=4deef538ecda16acd4c0ae3d3ed71c591603ce73", "patch": "@@ -1566,7 +1566,7 @@ add_insn_mem_dependence (struct deps_desc *deps, bool read_p,\n   if (sched_deps_info->use_cselib)\n     {\n       mem = shallow_copy_rtx (mem);\n-      XEXP (mem, 0) = cselib_subst_to_values (XEXP (mem, 0));\n+      XEXP (mem, 0) = cselib_subst_to_values (XEXP (mem, 0), GET_MODE (mem));\n     }\n   link = alloc_EXPR_LIST (VOIDmode, canon_rtx (mem), *mem_list);\n   *mem_list = link;\n@@ -2283,8 +2283,9 @@ sched_analyze_1 (struct deps_desc *deps, rtx x, rtx insn)\n \t    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (dest));\n \n \t  t = shallow_copy_rtx (dest);\n-\t  cselib_lookup_from_insn (XEXP (t, 0), address_mode, 1, insn);\n-\t  XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0));\n+\t  cselib_lookup_from_insn (XEXP (t, 0), address_mode, 1,\n+\t\t\t\t   GET_MODE (t), insn);\n+\t  XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0), GET_MODE (t));\n \t}\n       t = canon_rtx (t);\n \n@@ -2440,8 +2441,9 @@ sched_analyze_2 (struct deps_desc *deps, rtx x, rtx insn)\n \t      = targetm.addr_space.address_mode (MEM_ADDR_SPACE (t));\n \n \t    t = shallow_copy_rtx (t);\n-\t    cselib_lookup_from_insn (XEXP (t, 0), address_mode, 1, insn);\n-\t    XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0));\n+\t    cselib_lookup_from_insn (XEXP (t, 0), address_mode, 1,\n+\t\t\t\t     GET_MODE (t), insn);\n+\t    XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0), GET_MODE (t));\n \t  }\n \n \tif (!DEBUG_INSN_P (insn))"}, {"sha": "27b06ad169598e19bdf2eacee12aefa45a399e3e", "filename": "gcc/sel-sched-dump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fsel-sched-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fsel-sched-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-dump.c?ref=4deef538ecda16acd4c0ae3d3ed71c591603ce73", "patch": "@@ -960,8 +960,8 @@ debug_mem_addr_value (rtx x)\n   address_mode = targetm.addr_space.address_mode (MEM_ADDR_SPACE (x));\n \n   t = shallow_copy_rtx (x);\n-  if (cselib_lookup (XEXP (t, 0), address_mode, 0))\n-    XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0));\n+  if (cselib_lookup (XEXP (t, 0), address_mode, 0, GET_MODE (t)))\n+    XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0), GET_MODE (t));\n \n   t = canon_rtx (t);\n   addr = get_addr (XEXP (t, 0));"}, {"sha": "7543a5a0b86ab285da514d95f78fc7ffc38279e6", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4deef538ecda16acd4c0ae3d3ed71c591603ce73/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=4deef538ecda16acd4c0ae3d3ed71c591603ce73", "patch": "@@ -737,7 +737,7 @@ use_narrower_mode_test (rtx *loc, void *data)\n   switch (GET_CODE (*loc))\n     {\n     case REG:\n-      if (cselib_lookup (*loc, GET_MODE (SUBREG_REG (subreg)), 0))\n+      if (cselib_lookup (*loc, GET_MODE (SUBREG_REG (subreg)), 0, VOIDmode))\n \treturn 1;\n       return -1;\n     case PLUS:\n@@ -3954,8 +3954,10 @@ variable_post_merge_new_vals (void **slot, void *info)\n \t\t\t subsequent rounds.  */\n \t\t      cselib_val *v;\n \t\t      gcc_assert (!cselib_lookup (node->loc,\n-\t\t\t\t\t\t  GET_MODE (node->loc), 0));\n-\t\t      v = cselib_lookup (node->loc, GET_MODE (node->loc), 1);\n+\t\t\t\t\t\t  GET_MODE (node->loc), 0,\n+\t\t\t\t\t\t  VOIDmode));\n+\t\t      v = cselib_lookup (node->loc, GET_MODE (node->loc), 1,\n+\t\t\t\t\t VOIDmode);\n \t\t      cselib_preserve_value (v);\n \t\t      cselib_invalidate_rtx (node->loc);\n \t\t      cval = v->val_rtx;\n@@ -4793,7 +4795,7 @@ find_use_val (rtx x, enum machine_mode mode, struct count_use_info *cui)\n \t      return cui->sets[i].src_elt;\n \t}\n       else\n-\treturn cselib_lookup (x, mode, 0);\n+\treturn cselib_lookup (x, mode, 0, VOIDmode);\n     }\n \n   return NULL;\n@@ -4822,14 +4824,15 @@ replace_expr_with_values (rtx loc)\n   else if (MEM_P (loc))\n     {\n       cselib_val *addr = cselib_lookup (XEXP (loc, 0),\n-\t\t\t\t\tget_address_mode (loc), 0);\n+\t\t\t\t\tget_address_mode (loc), 0,\n+\t\t\t\t\tGET_MODE (loc));\n       if (addr)\n \treturn replace_equiv_address_nv (loc, addr->val_rtx);\n       else\n \treturn NULL;\n     }\n   else\n-    return cselib_subst_to_values (loc);\n+    return cselib_subst_to_values (loc, VOIDmode);\n }\n \n /* Determine what kind of micro operation to choose for a USE.  Return\n@@ -4849,7 +4852,8 @@ use_type (rtx loc, struct count_use_info *cui, enum machine_mode *modep)\n \t      rtx ploc = PAT_VAR_LOCATION_LOC (loc);\n \t      if (! VAR_LOC_UNKNOWN_P (ploc))\n \t\t{\n-\t\t  cselib_val *val = cselib_lookup (ploc, GET_MODE (loc), 1);\n+\t\t  cselib_val *val = cselib_lookup (ploc, GET_MODE (loc), 1,\n+\t\t\t\t\t\t   VOIDmode);\n \n \t\t  /* ??? flag_float_store and volatile mems are never\n \t\t     given values, but we could in theory use them for\n@@ -4871,7 +4875,8 @@ use_type (rtx loc, struct count_use_info *cui, enum machine_mode *modep)\n \t      if (REG_P (loc)\n \t\t  || (find_use_val (loc, GET_MODE (loc), cui)\n \t\t      && cselib_lookup (XEXP (loc, 0),\n-\t\t\t\t\tget_address_mode (loc), 0)))\n+\t\t\t\t\tget_address_mode (loc), 0,\n+\t\t\t\t\tGET_MODE (loc))))\n \t\treturn MO_VAL_SET;\n \t    }\n \t  else\n@@ -5033,13 +5038,15 @@ add_uses (rtx *ploc, void *data)\n \t      rtx mloc = vloc;\n \t      enum machine_mode address_mode = get_address_mode (mloc);\n \t      cselib_val *val\n-\t\t= cselib_lookup (XEXP (mloc, 0), address_mode, 0);\n+\t\t= cselib_lookup (XEXP (mloc, 0), address_mode, 0,\n+\t\t\t\t GET_MODE (mloc));\n \n \t      if (val && !cselib_preserved_value_p (val))\n \t\t{\n \t\t  micro_operation moa;\n \t\t  preserve_value (val);\n-\t\t  mloc = cselib_subst_to_values (XEXP (mloc, 0));\n+\t\t  mloc = cselib_subst_to_values (XEXP (mloc, 0),\n+\t\t\t\t\t\t GET_MODE (mloc));\n \t\t  moa.type = MO_VAL_USE;\n \t\t  moa.insn = cui->insn;\n \t\t  moa.u.loc = gen_rtx_CONCAT (address_mode,\n@@ -5109,13 +5116,15 @@ add_uses (rtx *ploc, void *data)\n \t      rtx mloc = oloc;\n \t      enum machine_mode address_mode = get_address_mode (mloc);\n \t      cselib_val *val\n-\t\t= cselib_lookup (XEXP (mloc, 0), address_mode, 0);\n+\t\t= cselib_lookup (XEXP (mloc, 0), address_mode, 0,\n+\t\t\t\tGET_MODE (mloc));\n \n \t      if (val && !cselib_preserved_value_p (val))\n \t\t{\n \t\t  micro_operation moa;\n \t\t  preserve_value (val);\n-\t\t  mloc = cselib_subst_to_values (XEXP (mloc, 0));\n+\t\t  mloc = cselib_subst_to_values (XEXP (mloc, 0),\n+\t\t\t\t\t\tGET_MODE (mloc));\n \t\t  moa.type = MO_VAL_USE;\n \t\t  moa.insn = cui->insn;\n \t\t  moa.u.loc = gen_rtx_CONCAT (address_mode,\n@@ -5225,7 +5234,7 @@ reverse_op (rtx val, const_rtx expr)\n   if (!SCALAR_INT_MODE_P (GET_MODE (src)) || XEXP (src, 0) == cfa_base_rtx)\n     return NULL_RTX;\n \n-  v = cselib_lookup (XEXP (src, 0), GET_MODE (XEXP (src, 0)), 0);\n+  v = cselib_lookup (XEXP (src, 0), GET_MODE (XEXP (src, 0)), 0, VOIDmode);\n   if (!v || !cselib_preserved_value_p (v))\n     return NULL_RTX;\n \n@@ -5346,13 +5355,15 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t  rtx mloc = loc;\n \t  enum machine_mode address_mode = get_address_mode (mloc);\n \t  cselib_val *val = cselib_lookup (XEXP (mloc, 0),\n-\t\t\t\t\t   address_mode, 0);\n+\t\t\t\t\t   address_mode, 0,\n+\t\t\t\t\t   GET_MODE (mloc));\n \n \t  if (val && !cselib_preserved_value_p (val))\n \t    {\n \t      preserve_value (val);\n \t      mo.type = MO_VAL_USE;\n-\t      mloc = cselib_subst_to_values (XEXP (mloc, 0));\n+\t      mloc = cselib_subst_to_values (XEXP (mloc, 0),\n+\t\t\t\t\t     GET_MODE (mloc));\n \t      mo.u.loc = gen_rtx_CONCAT (address_mode, val->val_rtx, mloc);\n \t      mo.insn = cui->insn;\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -5411,7 +5422,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \n   if (GET_CODE (PATTERN (cui->insn)) == COND_EXEC)\n     {\n-      cselib_val *oval = cselib_lookup (oloc, GET_MODE (oloc), 0);\n+      cselib_val *oval = cselib_lookup (oloc, GET_MODE (oloc), 0, VOIDmode);\n \n       gcc_assert (oval != v);\n       gcc_assert (REG_P (oloc) || MEM_P (oloc));\n@@ -8077,7 +8088,8 @@ vt_add_function_parameter (tree parm)\n       if (offset)\n \treturn;\n \n-      val = cselib_lookup (var_lowpart (mode, incoming), mode, true);\n+      val = cselib_lookup (var_lowpart (mode, incoming), mode, true,\n+\t\t\t   VOIDmode);\n \n       /* ??? Float-typed values in memory are not handled by\n \t cselib.  */\n@@ -8197,7 +8209,7 @@ vt_init_cfa_base (void)\n \t\t\t    frame_pointer_needed\n \t\t\t    ? hard_frame_pointer_rtx : stack_pointer_rtx);\n   val = cselib_lookup_from_insn (cfa_base_rtx, GET_MODE (cfa_base_rtx), 1,\n-\t\t\t\t get_insns ());\n+\t\t\t\t VOIDmode, get_insns ());\n   preserve_value (val);\n   cselib_preserve_cfa_base_value (val, REGNO (cfa_base_rtx));\n   var_reg_decl_set (&VTI (ENTRY_BLOCK_PTR)->out, cfa_base_rtx,"}]}