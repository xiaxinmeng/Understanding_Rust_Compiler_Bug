{"sha": "22c4c8694927961d5884eeab71a17b92aa4f9702", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJjNGM4Njk0OTI3OTYxZDU4ODRlZWFiNzFhMTdiOTJhYTRmOTcwMg==", "commit": {"author": {"name": "Catherine Moore", "email": "clm@codesourcery.com", "date": "2013-03-20T14:37:52Z"}, "committer": {"name": "Catherine Moore", "email": "clm@gcc.gnu.org", "date": "2013-03-20T14:37:52Z"}, "message": "extend.texi: (micromips, nomicromips, nocompression): Document new function attributes.\n\ngcc/\n2013-03-20  Catherine Moore  <clm@codesourcery.com>\n\t    Maciej W. Rozycki  <macro@codesourcery.com>\n\t    Tom de Vries  <tom@codesourcery.com>\n\t    Nathan Sidwell <nathan@codesourcery.com>\n\t    Iain Sandoe  <iain@codesourcery.com>\n\t    Nathan Froyd  <froydnj@codesourcery.com>\n\t    Chao-ying Fu <fu@mips.com>\n\n\t* doc/extend.texi: (micromips, nomicromips, nocompression):\n\tDocument new function attributes. \n\t* doc/invoke.texi (minterlink-compressed, mmicromips,\n\tm14k, m14ke, m14kec): Document new options.\n\t(minterlink-mips16): Update documentation.\n\t* doc/md.texi (ZC, ZD): Document new constraints.\n\t* configure.ac (gcc_cv_as_micromips): Check if linker\n\tsupports the .set micromips directive.\n\t* configure: Regenerate.\n\t* config.in: Regenerate.\n\t* config/mips/mips-tables.opt: Regenerate.\n\t* config/mips/micromips.md: New file.\n\t* constraints.md (ZC, ZD): New constraints.\n\t* config/mips/predicates.md (movep_src_register): New predicate.\n\t(movep_src_operand): New predicate.\n\t(non_volatile_mem_operand): New predicate.\n\t* config/mips/mips.md (multimem): New type.\n\t(length): Differentiate between 17-bit and 18-bit branch offsets.\n\t(MOVEP1, MOVEP2): New mode iterator.\n \t(mov_<load>l): Use ZC constraint.\n\t(mov_<load>r): Likewise.\n\t(mov_<store>l): Likewise.\n\t(mov_<store>r): Likewise.\n\t(*branch_equality<mode>_inverted): Add microMIPS support.\n\t(*branch_equality<mode>): Likewise.\n\t(*jump_absolute): Likewise.\n\t(indirect_jump_<mode>): Likewise.\n\t(tablejump_<mode>): Likewise.\n\t(<optab>_internal): Likewise.\n\t(sibcall_internal): Likewise.\n\t(sibcall_value_internal): Likewise.\n\t(prefetch): Use constraint ZD.\n\t* config/mips/mips.opt (minterlink-compressed): New option.\n\t(minterlink-mips16): Now an alias for minterlink-compressed.\n\t(mmicromips): New option.\n\t* config/mips/sync.md (sync_compare_and_swap<mode>): Use ZR constraint.\n\t(compare_and_swap_12): Likewise.\n\t(sync_add<mode>): Likewise.\n\t(sync_<optab>_12): Likewise.\n\t(sync_old_<optab>_12): Likewise.\n\t(sync_new_<optab>_12): Likewise.\n\t(sync_nand_12): Likewise.\n\t(sync_old_nand_12): Likewise.\n\t(sync_new_nand_12): Likewise.\n\t(sync_sub<mode>): Likewise.\n\t(sync_old_add<mode>): Likewise.\n\t(sync_old_sub<mode>): Likewise.\n\t(sync_new_add<mode>): Likewise.\n\t(sync_new_sub<mode>): Likewise.\n\t(sync_<optab><mode>): Likewise.\n\t(sync_old_<optab><mode>): Likewise.\n\t(sync_new_<optab><mode>): Likewise.\n\t(sync_nand<mode>): Likewise.\n\t(sync_old_nand<mode>): Likewise.\n\t(sync_new_nand<mode>): Likewise.\n\t(sync_lock_test_and_set<mode>): Likewise.\n\t(test_and_set_12): Likewise.\n\t(atomic_compare_and_swap<mode>): Likewise.\n\t(atomic_exchange<mode>_llsc): Likewise.\n\t(atomic_fetch_add<mode>_llsc): Likewise.\n\t* config/mips/mips-cpus.def (m14kc, m14k): New processors.\n\t* config/mips/mips-protos.h (umips_output_save_restore): New prototype.\n\t(umips_save_restore_pattern_p): Likewise.\n\t(umips_load_store_pair_p): Likewise.\n\t(umips_output_load_store_pair): Likewise.\n\t(umips_movep_target_p): Likewise.\n\t(umips_12bit_offset_address_p): Likewise.\n\t* config/mips/mips.c (MIPS_MAX_FIRST_STEP): Update for microMIPS.\n\t(mips_base_mips16): Rename this...\n\t(mips_base_compression_flags): ...to this. Update all uses.\n\t(mips_attribute_table): Add micromips, nomicromips and nocompression.\n\t(mips_mips16_decl_p): Delete.\n\t(mips_nomips16_decl_p): Delete.\n \t(mips_get_compress_on_flags): New function.\n\t(mips_get_compress_off_flags): New function.\n\t(mips_get_compress_mode): New function.\n\t(mips_get_compress_on_name): New function.\n\t(mips_get_compress_off_name): New function.\n\t(mips_insert_attributes): Support multiple compression types.\n\t(mips_merge_decl_attributes): Likewise.\n\t(umips_12bit_offset_address_p): New function.\n\t(mips_start_function_definition): Emit .set micromips directive.\n\t(mips_call_may_need_jalx_p): New function.\n\t(mips_function_ok_for_sibcall): Add microMIPS support.\n\t(mips_print_operand_punctuation): Support short delay slots and\n\tcompact jumps.\n\t(umips_swm_mask, umips_swm_encoding): New.\n\t(umips_build_save_restore): New function.\n\t(mips_for_each_saved_gpr_and_fpr): Add microMIPS support.\n\t(was_mips16_p): Remove.\n\t(old_compression_mode): New.\n\t(mips_set_compression_mode): New function.\n\t(mips_set_current_function): Add microMIPS support.\n\t(mips_option_override): Likewise.\n\t(umips_save_restore_pattern_p): New function.\n\t(umips_output_save_restore): New function.\n\t(umips_load_store_pair_p_1): New function.\n\t(umips_load_store_pair_p): New function.\n\t(umips_output_load_store_pair_1): New function.\n\t(umips_output_load_store_pair): New function.\n\t(umips_movep_target_p) New function.\n\t(mips_prepare_pch_save): Add microMIPS support.\n\t* config/mips/mips.h (TARGET_COMPRESSION): New.\n\t(TARGET_CPU_CPP_BUILTINS): Update macro\n\tto use new compression flags and to support microMIPS.\n\t(MIPS_ISA_LEVEL_SPEC): Add m14k processors.\n\t(MIPS_ARCH_FLOAT_SPEC): Likewise.\n\t(ISA_HAS_LWXS): Include TARGET_MICROMIPS.\n\t(ISA_HAS_LOAD_DELAY): Exclude TARGET_MICROMIPS.\n\t(ASM_SPEC): Support mmicromips and mno-micromips.\n\t(M16STORE_REG_P): New macro.\n\t(MIPS_CALL): Support TARGET_MICROMIPS.\n\t(MICROMIPS_J): New macro.\n\t(mips_base_mips16): Rename this...\n\t(mips_base_compression_flags): ...to this.\n\t(UMIPS_12BIT_OFFSET_P): New macro.\n\t* config/mips/t-sde: (MULTILIB_OPTIONS): Add microMIPS.\n\t(MULTILIB_DIRNAMES): Likewise.\nlibgcc/\n2013-03-20  Catherine Moore  <clm@codesourcery.com>\n\t    Joseph Myers  <joseph@codesourcery.com>\n\t    Chao-ying Fu  <fu@mips.com>\n\n\t* config/mips/mips16.S:  Don't build for microMIPS.\n\t* config/mips/linux-unwind.h: Handle microMIPS frame.\n\t* config/mips/crtn.S (fini, init): New labels.\ngcc/testsuite/\n2013-03-20  Catherine Moore  <clm@codesourcery.com>\n\t    Richard Sandiford <rdsandiford@googlemail.com>\n\n\t* gcc.target/mips/mips.exp: Add microMIPS support.\n\t* gcc.target/mips/umips-movep-2.c: New test.\n\t* gcc.target/mips/umips-lwp-2.c: New test.\n\t* gcc.target/mips/umips-swp-5.c: New test.\n\t* gcc.target/mips/umips-constraints-1.c: New test.\n\t* gcc.target/mips/umips-lwp-3.c: New test.\n\t* gcc.target/mips/umips-swp-6.c: New test.\n\t* gcc.target/mips/umips-constraints-2.c: New test.\n\t* gcc.target/mips/umips-save-restore-1.c: New test.\n\t* gcc.target/mips/umips-lwp-4.c: New test.\n\t* gcc.target/mips/umips-swp-7.c: New test.\n\t* gcc.target/mips/umips-save-restore-2.c: New test.\n\t* gcc.target/mips/umips-lwp-swp-volatile.c: New test.\n\t* gcc.target/mips/umips-lwp-5.c: New test.\n\t* gcc.target/mips/umips-save-restore-3.c: New test.\n\t* gcc.target/mips/umips-lwp-6.c: New test.\n\t* gcc.target/mips/umips-swp-1.c: New test.\n\t* gcc.target/mips/umips-lwp-7.c: New test.\n\t* gcc.target/mips/umips-swp-2.c: New test.\n\t* gcc.target/mips/umips-lwp-8.c: New test.\n\t* gcc.target/mips/umips-swp-3.c: New test.\n\t* gcc.target/mips/umips-movep-1.c: New test.\n\t* gcc.target/mips/umips-lwp-1.c: New test.\n\t* gcc.target/mips/umips-swp-4.c: New test.\n\n\nCo-Authored-By: Chao-ying Fu <fu@mips.com>\nCo-Authored-By: Iain Sandoe <iain@codesourcery.com>\nCo-Authored-By: Joseph Myers <joseph@codesourcery.com>\nCo-Authored-By: Maciej W. Rozycki <macro@codesourcery.com>\nCo-Authored-By: Nathan Froyd <froydnj@codesourcery.com>\nCo-Authored-By: Nathan Sidwell <nathan@codesourcery.com>\nCo-Authored-By: Richard Sandiford <rdsandiford@googlemail.com>\nCo-Authored-By: Tom de Vries <tom@codesourcery.com>\n\nFrom-SVN: r196828", "tree": {"sha": "7eae26e38b87f9302d0380cc604344eb4e95fd75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7eae26e38b87f9302d0380cc604344eb4e95fd75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22c4c8694927961d5884eeab71a17b92aa4f9702", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22c4c8694927961d5884eeab71a17b92aa4f9702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22c4c8694927961d5884eeab71a17b92aa4f9702", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22c4c8694927961d5884eeab71a17b92aa4f9702/comments", "author": {"login": "CatherineMoore", "id": 15636327, "node_id": "MDQ6VXNlcjE1NjM2MzI3", "avatar_url": "https://avatars.githubusercontent.com/u/15636327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CatherineMoore", "html_url": "https://github.com/CatherineMoore", "followers_url": "https://api.github.com/users/CatherineMoore/followers", "following_url": "https://api.github.com/users/CatherineMoore/following{/other_user}", "gists_url": "https://api.github.com/users/CatherineMoore/gists{/gist_id}", "starred_url": "https://api.github.com/users/CatherineMoore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CatherineMoore/subscriptions", "organizations_url": "https://api.github.com/users/CatherineMoore/orgs", "repos_url": "https://api.github.com/users/CatherineMoore/repos", "events_url": "https://api.github.com/users/CatherineMoore/events{/privacy}", "received_events_url": "https://api.github.com/users/CatherineMoore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "92a8d7a7332ca2d53a70d856052b148331da518a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a8d7a7332ca2d53a70d856052b148331da518a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92a8d7a7332ca2d53a70d856052b148331da518a"}], "stats": {"total": 2047, "additions": 1780, "deletions": 267}, "files": [{"sha": "9873aca318fd07048289d7b7fc095454e59b9c38", "filename": "gcc/ChangeLog", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -1,3 +1,129 @@\n+2013-03-20  Catherine Moore  <clm@codesourcery.com>\n+\t    Maciej W. Rozycki  <macro@codesourcery.com>\n+\t    Tom de Vries  <tom@codesourcery.com>\n+\t    Nathan Sidwell <nathan@codesourcery.com>\n+\t    Iain Sandoe  <iain@codesourcery.com>\n+\t    Nathan Froyd  <froydnj@codesourcery.com>\n+\t    Chao-ying Fu <fu@mips.com>\n+\n+\t* doc/extend.texi: (micromips, nomicromips, nocompression):\n+\tDocument new function attributes. \n+\t* doc/invoke.texi (minterlink-compressed, mmicromips,\n+\tm14k, m14ke, m14kec): Document new options.\n+\t(minterlink-mips16): Update documentation.\n+\t* doc/md.texi (ZC, ZD): Document new constraints.\n+\t* configure.ac (gcc_cv_as_micromips): Check if linker\n+\tsupports the .set micromips directive.\n+\t* configure: Regenerate.\n+\t* config.in: Regenerate.\n+\t* config/mips/mips-tables.opt: Regenerate.\n+\t* config/mips/micromips.md: New file.\n+\t* constraints.md (ZC, ZD): New constraints.\n+\t* config/mips/predicates.md (movep_src_register): New predicate.\n+\t(movep_src_operand): New predicate.\n+\t(non_volatile_mem_operand): New predicate.\n+\t* config/mips/mips.md (multimem): New type.\n+\t(length): Differentiate between 17-bit and 18-bit branch offsets.\n+\t(MOVEP1, MOVEP2): New mode iterator.\n+ \t(mov_<load>l): Use ZC constraint.\n+\t(mov_<load>r): Likewise.\n+\t(mov_<store>l): Likewise.\n+\t(mov_<store>r): Likewise.\n+\t(*branch_equality<mode>_inverted): Add microMIPS support.\n+\t(*branch_equality<mode>): Likewise.\n+\t(*jump_absolute): Likewise.\n+\t(indirect_jump_<mode>): Likewise.\n+\t(tablejump_<mode>): Likewise.\n+\t(<optab>_internal): Likewise.\n+\t(sibcall_internal): Likewise.\n+\t(sibcall_value_internal): Likewise.\n+\t(prefetch): Use constraint ZD.\n+\t* config/mips/mips.opt (minterlink-compressed): New option.\n+\t(minterlink-mips16): Now an alias for minterlink-compressed.\n+\t(mmicromips): New option.\n+\t* config/mips/sync.md (sync_compare_and_swap<mode>): Use ZR constraint.\n+\t(compare_and_swap_12): Likewise.\n+\t(sync_add<mode>): Likewise.\n+\t(sync_<optab>_12): Likewise.\n+\t(sync_old_<optab>_12): Likewise.\n+\t(sync_new_<optab>_12): Likewise.\n+\t(sync_nand_12): Likewise.\n+\t(sync_old_nand_12): Likewise.\n+\t(sync_new_nand_12): Likewise.\n+\t(sync_sub<mode>): Likewise.\n+\t(sync_old_add<mode>): Likewise.\n+\t(sync_old_sub<mode>): Likewise.\n+\t(sync_new_add<mode>): Likewise.\n+\t(sync_new_sub<mode>): Likewise.\n+\t(sync_<optab><mode>): Likewise.\n+\t(sync_old_<optab><mode>): Likewise.\n+\t(sync_new_<optab><mode>): Likewise.\n+\t(sync_nand<mode>): Likewise.\n+\t(sync_old_nand<mode>): Likewise.\n+\t(sync_new_nand<mode>): Likewise.\n+\t(sync_lock_test_and_set<mode>): Likewise.\n+\t(test_and_set_12): Likewise.\n+\t(atomic_compare_and_swap<mode>): Likewise.\n+\t(atomic_exchange<mode>_llsc): Likewise.\n+\t(atomic_fetch_add<mode>_llsc): Likewise.\n+\t* config/mips/mips-cpus.def (m14kc, m14k): New processors.\n+\t* config/mips/mips-protos.h (umips_output_save_restore): New prototype.\n+\t(umips_save_restore_pattern_p): Likewise.\n+\t(umips_load_store_pair_p): Likewise.\n+\t(umips_output_load_store_pair): Likewise.\n+\t(umips_movep_target_p): Likewise.\n+\t(umips_12bit_offset_address_p): Likewise.\n+\t* config/mips/mips.c (MIPS_MAX_FIRST_STEP): Update for microMIPS.\n+\t(mips_base_mips16): Rename this...\n+\t(mips_base_compression_flags): ...to this. Update all uses.\n+\t(mips_attribute_table): Add micromips, nomicromips and nocompression.\n+\t(mips_mips16_decl_p): Delete.\n+\t(mips_nomips16_decl_p): Delete.\n+ \t(mips_get_compress_on_flags): New function.\n+\t(mips_get_compress_off_flags): New function.\n+\t(mips_get_compress_mode): New function.\n+\t(mips_get_compress_on_name): New function.\n+\t(mips_get_compress_off_name): New function.\n+\t(mips_insert_attributes): Support multiple compression types.\n+\t(mips_merge_decl_attributes): Likewise.\n+\t(umips_12bit_offset_address_p): New function.\n+\t(mips_start_function_definition): Emit .set micromips directive.\n+\t(mips_call_may_need_jalx_p): New function.\n+\t(mips_function_ok_for_sibcall): Add microMIPS support.\n+\t(mips_print_operand_punctuation): Support short delay slots and\n+\tcompact jumps.\n+\t(umips_swm_mask, umips_swm_encoding): New.\n+\t(umips_build_save_restore): New function.\n+\t(mips_for_each_saved_gpr_and_fpr): Add microMIPS support.\n+\t(was_mips16_p): Remove.\n+\t(old_compression_mode): New.\n+\t(mips_set_compression_mode): New function.\n+\t(mips_set_current_function): Add microMIPS support.\n+\t(mips_option_override): Likewise.\n+\t(umips_save_restore_pattern_p): New function.\n+\t(umips_output_save_restore): New function.\n+\t(umips_load_store_pair_p_1): New function.\n+\t(umips_load_store_pair_p): New function.\n+\t(umips_output_load_store_pair_1): New function.\n+\t(umips_output_load_store_pair): New function.\n+\t(umips_movep_target_p) New function.\n+\t(mips_prepare_pch_save): Add microMIPS support.\n+\t* config/mips/mips.h (TARGET_COMPRESSION): New.\n+\t(TARGET_CPU_CPP_BUILTINS): Update macro\n+\tto use new compression flags and to support microMIPS.\n+\t(MIPS_ISA_LEVEL_SPEC): Add m14k processors.\n+\t(MIPS_ARCH_FLOAT_SPEC): Likewise.\n+\t(ISA_HAS_LWXS): Include TARGET_MICROMIPS.\n+\t(ISA_HAS_LOAD_DELAY): Exclude TARGET_MICROMIPS.\n+\t(ASM_SPEC): Support mmicromips and mno-micromips.\n+\t(M16STORE_REG_P): New macro.\n+\t(MIPS_CALL): Support TARGET_MICROMIPS.\n+\t(MICROMIPS_J): New macro.\n+\t(mips_base_mips16): Rename this...\n+\t(mips_base_compression_flags): ...to this.\n+\t(UMIPS_12BIT_OFFSET_P): New macro.\n+\t* config/mips/t-sde: (MULTILIB_OPTIONS): Add microMIPS.\n+\t(MULTILIB_DIRNAMES): Likewise.\n 2013-03-20  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/56661"}, {"sha": "f1ab30d0cf98e683eeebd3b991aa6481bb46add4", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -1034,6 +1034,12 @@\n #endif\n \n \n+/* Define if your assembler supports the .set micromips directive */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_GAS_MICROMIPS\n+#endif\n+\n+\n /* Define if your assembler supports .nsubspa comdat option. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_GAS_NSUBSPA_COMDAT"}, {"sha": "773ef3a71e61c31b65913ac55d9cc22d91dff82b", "filename": "gcc/config/mips/constraints.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fconstraints.md?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -232,6 +232,27 @@\n    \"@internal\"\n    (match_operand 0 \"low_bitmask_operand\"))\n \n+(define_memory_constraint \"ZC\"\n+  \"When compiling microMIPS code, this constraint matches a memory operand\n+   whose address is formed from a base register and a 12-bit offset.  These\n+   operands can be used for microMIPS instructions such as @code{ll} and\n+   @code{sc}.  When not compiling for microMIPS code, @code{ZC} is\n+   equivalent to @code{R}.\"\n+  (and (match_code \"mem\")\n+       (if_then_else\n+\t (match_test \"TARGET_MICROMIPS\")\n+\t (match_test \"umips_12bit_offset_address_p (XEXP (op, 0), mode)\")\n+\t (match_test \"mips_address_insns (XEXP (op, 0), mode, false)\"))))\n+\n+(define_address_constraint \"ZD\"\n+  \"When compiling microMIPS code, this constraint matches an address operand\n+   that is formed from a base register and a 12-bit offset.  These operands\n+   can be used for microMIPS instructions such as @code{prefetch}.  When\n+   not compiling for microMIPS code, @code{ZD} is equivalent to @code{p}.\"\n+   (if_then_else (match_test \"TARGET_MICROMIPS\")\n+\t\t (match_test \"umips_12bit_offset_address_p (op, mode)\")\n+\t\t (match_test \"mips_address_insns (op, mode, false)\")))\n+\n (define_memory_constraint \"ZR\"\n  \"@internal\n   An address valid for loading/storing register exclusive\""}, {"sha": "4b7a4a7013f7d6740e338e0fb7dba7a002ebcedd", "filename": "gcc/config/mips/micromips.md", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmicromips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmicromips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmicromips.md?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,125 @@\n+;; Copyright (C) 2013 Free Software Foundation, Inc.\n+;;\n+;; micromips.md   Machine Description for the microMIPS instruction set\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_insn \"*store_word_multiple\"\n+  [(match_parallel 0 \"\"\n+       [(set (match_operand:SI 1 \"memory_operand\")\n+\t     (match_operand:SI 2 \"register_operand\"))])]\n+  \"TARGET_MICROMIPS\n+   && umips_save_restore_pattern_p (true, operands[0])\"\n+  { return umips_output_save_restore (true, operands[0]); }\n+  [(set_attr \"type\" \"multimem\")\n+   (set_attr \"mode\" \"SI\")\n+   (set_attr \"can_delay\" \"no\")])\n+\n+(define_insn \"*load_word_multiple\"\n+  [(match_parallel 0 \"\"\n+       [(set (match_operand:SI 1 \"register_operand\")\n+\t     (match_operand:SI 2 \"memory_operand\"))])]\n+  \"TARGET_MICROMIPS\n+   && umips_save_restore_pattern_p (false, operands[0])\"\n+  { return umips_output_save_restore (false, operands[0]); }\n+  [(set_attr \"type\" \"multimem\")\n+   (set_attr \"mode\" \"SI\")\n+   (set_attr \"can_delay\" \"no\")])\n+\n+;; For LWP.\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"d_operand\" \"\")\n+        (match_operand:SI 1 \"non_volatile_mem_operand\" \"\"))\n+   (set (match_operand:SI 2 \"d_operand\" \"\")\n+        (match_operand:SI 3 \"non_volatile_mem_operand\" \"\"))]\n+  \"TARGET_MICROMIPS\n+   && umips_load_store_pair_p (true, operands)\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+              (set (match_dup 2) (match_dup 3))])])\n+\n+;; The behavior of the LWP insn is undefined if placed in a delay slot.\n+(define_insn \"*lwp\"\n+  [(parallel [(set (match_operand:SI 0 \"d_operand\")\n+\t\t   (match_operand:SI 1 \"non_volatile_mem_operand\"))\n+\t      (set (match_operand:SI 2 \"d_operand\")\n+\t\t   (match_operand:SI 3 \"non_volatile_mem_operand\"))])]\n+\n+  \"TARGET_MICROMIPS\n+   && umips_load_store_pair_p (true, operands)\"\n+{\n+  umips_output_load_store_pair (true, operands);\n+  return \"\";\n+}\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"mode\" \"SI\")\n+   (set_attr \"can_delay\" \"no\")])\n+\n+;; For SWP.\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"non_volatile_mem_operand\" \"\")\n+        (match_operand:SI 1 \"d_operand\" \"\"))\n+   (set (match_operand:SI 2 \"non_volatile_mem_operand\" \"\")\n+        (match_operand:SI 3 \"d_operand\" \"\"))]\n+  \"TARGET_MICROMIPS\n+   && umips_load_store_pair_p (false, operands)\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+              (set (match_dup 2) (match_dup 3))])])\n+\n+;; The behavior of the SWP insn is undefined if placed in a delay slot.\n+(define_insn \"*swp\"\n+  [(parallel [(set (match_operand:SI 0 \"non_volatile_mem_operand\")\n+\t\t   (match_operand:SI 1 \"d_operand\"))\n+\t      (set (match_operand:SI 2 \"non_volatile_mem_operand\")\n+\t\t   (match_operand:SI 3 \"d_operand\"))])]\n+\n+  \"TARGET_MICROMIPS\n+   && umips_load_store_pair_p (false, operands)\"\n+{\n+  umips_output_load_store_pair (false, operands);\n+  return \"\";\n+}\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"mode\" \"SI\")\n+   (set_attr \"can_delay\" \"no\")])\n+\n+;; For MOVEP.\n+(define_peephole2\n+  [(set (match_operand:MOVEP1 0 \"register_operand\" \"\")\n+        (match_operand:MOVEP1 1 \"movep_src_operand\" \"\"))\n+   (set (match_operand:MOVEP2 2 \"register_operand\" \"\")\n+        (match_operand:MOVEP2 3 \"movep_src_operand\" \"\"))]\n+  \"TARGET_MICROMIPS\n+   && umips_movep_target_p (operands[0], operands[2])\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+              (set (match_dup 2) (match_dup 3))])])\n+\n+;; The behavior of the MOVEP insn is undefined if placed in a delay slot.\n+(define_insn \"*movep<MOVEP1:mode><MOVEP2:mode>\"\n+  [(parallel [(set (match_operand:MOVEP1 0 \"register_operand\")\n+\t\t   (match_operand:MOVEP1 1 \"movep_src_operand\"))\n+\t      (set (match_operand:MOVEP2 2 \"register_operand\")\n+\t\t   (match_operand:MOVEP2 3 \"movep_src_operand\"))])]\n+  \"TARGET_MICROMIPS\n+   && umips_movep_target_p (operands[0], operands[2])\"\n+{\n+  if (REGNO (operands[0]) < REGNO (operands[2]))\n+    return \"movep\\t%0,%2,%z1,%z3\";\n+  else\n+    return \"movep\\t%2,%0,%z3,%z1\";\n+}\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"mode\" \"<MODE>\")\n+   (set_attr \"can_delay\" \"no\")])"}, {"sha": "1cc1999937346477ca5b51aa736b769fe951038e", "filename": "gcc/config/mips/mips-cpus.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmips-cpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmips-cpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-cpus.def?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -92,6 +92,8 @@ MIPS_CPU (\"4ksc\", PROCESSOR_4KC, 32, 0)\n \n /* MIPS32 Release 2 processors.  */\n MIPS_CPU (\"m4k\", PROCESSOR_M4K, 33, 0)\n+MIPS_CPU (\"m14kc\", PROCESSOR_M4K, 33, 0)\n+MIPS_CPU (\"m14k\", PROCESSOR_M4K, 33, 0)\n MIPS_CPU (\"4kec\", PROCESSOR_4KC, 33, 0)\n MIPS_CPU (\"4kem\", PROCESSOR_4KC, 33, 0)\n MIPS_CPU (\"4kep\", PROCESSOR_4KP, 33, 0)"}, {"sha": "2d03f5a0656d4af648a2e7e1e9019666d18d80ea", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -350,6 +350,12 @@ extern void mips_expand_vec_reduc (rtx, rtx, rtx (*)(rtx, rtx, rtx));\n extern void mips_expand_vec_minmax (rtx, rtx, rtx,\n \t\t\t\t    rtx (*) (rtx, rtx, rtx), bool);\n \n+extern const char *umips_output_save_restore (bool, rtx);\n+extern bool umips_save_restore_pattern_p (bool, rtx);\n+extern bool umips_load_store_pair_p (bool, rtx *);\n+extern void umips_output_load_store_pair (bool, rtx *);\n+extern bool umips_movep_target_p (rtx, rtx);\n+extern bool umips_12bit_offset_address_p (rtx, enum machine_mode);\n extern rtx mips_expand_thread_pointer (rtx);\n \n extern bool mips_eh_uses (unsigned int);"}, {"sha": "0d7fa26510d0ff30eef9316fb3bf43c006c36736", "filename": "gcc/config/mips/mips-tables.opt", "status": "modified", "additions": 90, "deletions": 84, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmips-tables.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmips-tables.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-tables.opt?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -373,254 +373,260 @@ EnumValue\n Enum(mips_arch_opt_value) String(m4k) Value(39) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(4kec) Value(40) Canonical\n+Enum(mips_arch_opt_value) String(m14kc) Value(40) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r4kec) Value(40)\n+Enum(mips_arch_opt_value) String(m14k) Value(41) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(4kem) Value(41) Canonical\n+Enum(mips_arch_opt_value) String(4kec) Value(42) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r4kem) Value(41)\n+Enum(mips_arch_opt_value) String(r4kec) Value(42)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(4kep) Value(42) Canonical\n+Enum(mips_arch_opt_value) String(4kem) Value(43) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r4kep) Value(42)\n+Enum(mips_arch_opt_value) String(r4kem) Value(43)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(4ksd) Value(43) Canonical\n+Enum(mips_arch_opt_value) String(4kep) Value(44) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r4ksd) Value(43)\n+Enum(mips_arch_opt_value) String(r4kep) Value(44)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(24kc) Value(44) Canonical\n+Enum(mips_arch_opt_value) String(4ksd) Value(45) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r24kc) Value(44)\n+Enum(mips_arch_opt_value) String(r4ksd) Value(45)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(24kf2_1) Value(45) Canonical\n+Enum(mips_arch_opt_value) String(24kc) Value(46) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r24kf2_1) Value(45)\n+Enum(mips_arch_opt_value) String(r24kc) Value(46)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(24kf) Value(46) Canonical\n+Enum(mips_arch_opt_value) String(24kf2_1) Value(47) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r24kf) Value(46)\n+Enum(mips_arch_opt_value) String(r24kf2_1) Value(47)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(24kf1_1) Value(47) Canonical\n+Enum(mips_arch_opt_value) String(24kf) Value(48) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r24kf1_1) Value(47)\n+Enum(mips_arch_opt_value) String(r24kf) Value(48)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(24kfx) Value(48) Canonical\n+Enum(mips_arch_opt_value) String(24kf1_1) Value(49) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r24kfx) Value(48)\n+Enum(mips_arch_opt_value) String(r24kf1_1) Value(49)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(24kx) Value(49) Canonical\n+Enum(mips_arch_opt_value) String(24kfx) Value(50) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r24kx) Value(49)\n+Enum(mips_arch_opt_value) String(r24kfx) Value(50)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(24kec) Value(50) Canonical\n+Enum(mips_arch_opt_value) String(24kx) Value(51) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r24kec) Value(50)\n+Enum(mips_arch_opt_value) String(r24kx) Value(51)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(24kef2_1) Value(51) Canonical\n+Enum(mips_arch_opt_value) String(24kec) Value(52) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r24kef2_1) Value(51)\n+Enum(mips_arch_opt_value) String(r24kec) Value(52)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(24kef) Value(52) Canonical\n+Enum(mips_arch_opt_value) String(24kef2_1) Value(53) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r24kef) Value(52)\n+Enum(mips_arch_opt_value) String(r24kef2_1) Value(53)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(24kef1_1) Value(53) Canonical\n+Enum(mips_arch_opt_value) String(24kef) Value(54) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r24kef1_1) Value(53)\n+Enum(mips_arch_opt_value) String(r24kef) Value(54)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(24kefx) Value(54) Canonical\n+Enum(mips_arch_opt_value) String(24kef1_1) Value(55) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r24kefx) Value(54)\n+Enum(mips_arch_opt_value) String(r24kef1_1) Value(55)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(24kex) Value(55) Canonical\n+Enum(mips_arch_opt_value) String(24kefx) Value(56) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r24kex) Value(55)\n+Enum(mips_arch_opt_value) String(r24kefx) Value(56)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(34kc) Value(56) Canonical\n+Enum(mips_arch_opt_value) String(24kex) Value(57) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r34kc) Value(56)\n+Enum(mips_arch_opt_value) String(r24kex) Value(57)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(34kf2_1) Value(57) Canonical\n+Enum(mips_arch_opt_value) String(34kc) Value(58) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r34kf2_1) Value(57)\n+Enum(mips_arch_opt_value) String(r34kc) Value(58)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(34kf) Value(58) Canonical\n+Enum(mips_arch_opt_value) String(34kf2_1) Value(59) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r34kf) Value(58)\n+Enum(mips_arch_opt_value) String(r34kf2_1) Value(59)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(34kf1_1) Value(59) Canonical\n+Enum(mips_arch_opt_value) String(34kf) Value(60) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r34kf1_1) Value(59)\n+Enum(mips_arch_opt_value) String(r34kf) Value(60)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(34kfx) Value(60) Canonical\n+Enum(mips_arch_opt_value) String(34kf1_1) Value(61) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r34kfx) Value(60)\n+Enum(mips_arch_opt_value) String(r34kf1_1) Value(61)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(34kx) Value(61) Canonical\n+Enum(mips_arch_opt_value) String(34kfx) Value(62) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r34kx) Value(61)\n+Enum(mips_arch_opt_value) String(r34kfx) Value(62)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(34kn) Value(62) Canonical\n+Enum(mips_arch_opt_value) String(34kx) Value(63) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r34kn) Value(62)\n+Enum(mips_arch_opt_value) String(r34kx) Value(63)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(74kc) Value(63) Canonical\n+Enum(mips_arch_opt_value) String(34kn) Value(64) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r74kc) Value(63)\n+Enum(mips_arch_opt_value) String(r34kn) Value(64)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(74kf2_1) Value(64) Canonical\n+Enum(mips_arch_opt_value) String(74kc) Value(65) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r74kf2_1) Value(64)\n+Enum(mips_arch_opt_value) String(r74kc) Value(65)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(74kf) Value(65) Canonical\n+Enum(mips_arch_opt_value) String(74kf2_1) Value(66) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r74kf) Value(65)\n+Enum(mips_arch_opt_value) String(r74kf2_1) Value(66)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(74kf1_1) Value(66) Canonical\n+Enum(mips_arch_opt_value) String(74kf) Value(67) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r74kf1_1) Value(66)\n+Enum(mips_arch_opt_value) String(r74kf) Value(67)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(74kfx) Value(67) Canonical\n+Enum(mips_arch_opt_value) String(74kf1_1) Value(68) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r74kfx) Value(67)\n+Enum(mips_arch_opt_value) String(r74kf1_1) Value(68)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(74kx) Value(68) Canonical\n+Enum(mips_arch_opt_value) String(74kfx) Value(69) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r74kx) Value(68)\n+Enum(mips_arch_opt_value) String(r74kfx) Value(69)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(74kf3_2) Value(69) Canonical\n+Enum(mips_arch_opt_value) String(74kx) Value(70) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r74kf3_2) Value(69)\n+Enum(mips_arch_opt_value) String(r74kx) Value(70)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(1004kc) Value(70) Canonical\n+Enum(mips_arch_opt_value) String(74kf3_2) Value(71) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r1004kc) Value(70)\n+Enum(mips_arch_opt_value) String(r74kf3_2) Value(71)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(1004kf2_1) Value(71) Canonical\n+Enum(mips_arch_opt_value) String(1004kc) Value(72) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r1004kf2_1) Value(71)\n+Enum(mips_arch_opt_value) String(r1004kc) Value(72)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(1004kf) Value(72) Canonical\n+Enum(mips_arch_opt_value) String(1004kf2_1) Value(73) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r1004kf) Value(72)\n+Enum(mips_arch_opt_value) String(r1004kf2_1) Value(73)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(1004kf1_1) Value(73) Canonical\n+Enum(mips_arch_opt_value) String(1004kf) Value(74) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r1004kf1_1) Value(73)\n+Enum(mips_arch_opt_value) String(r1004kf) Value(74)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(5kc) Value(74) Canonical\n+Enum(mips_arch_opt_value) String(1004kf1_1) Value(75) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r5kc) Value(74)\n+Enum(mips_arch_opt_value) String(r1004kf1_1) Value(75)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(5kf) Value(75) Canonical\n+Enum(mips_arch_opt_value) String(5kc) Value(76) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r5kf) Value(75)\n+Enum(mips_arch_opt_value) String(r5kc) Value(76)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(20kc) Value(76) Canonical\n+Enum(mips_arch_opt_value) String(5kf) Value(77) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(r20kc) Value(76)\n+Enum(mips_arch_opt_value) String(r5kf) Value(77)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(sb1) Value(77) Canonical\n+Enum(mips_arch_opt_value) String(20kc) Value(78) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(sb1a) Value(78) Canonical\n+Enum(mips_arch_opt_value) String(r20kc) Value(78)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(sr71000) Value(79) Canonical\n+Enum(mips_arch_opt_value) String(sb1) Value(79) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(sr71k) Value(79)\n+Enum(mips_arch_opt_value) String(sb1a) Value(80) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(xlr) Value(80) Canonical\n+Enum(mips_arch_opt_value) String(sr71000) Value(81) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(loongson3a) Value(81) Canonical\n+Enum(mips_arch_opt_value) String(sr71k) Value(81)\n \n EnumValue\n-Enum(mips_arch_opt_value) String(octeon) Value(82) Canonical\n+Enum(mips_arch_opt_value) String(xlr) Value(82) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(octeon+) Value(83) Canonical\n+Enum(mips_arch_opt_value) String(loongson3a) Value(83) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(octeon2) Value(84) Canonical\n+Enum(mips_arch_opt_value) String(octeon) Value(84) Canonical\n \n EnumValue\n-Enum(mips_arch_opt_value) String(xlp) Value(85) Canonical\n+Enum(mips_arch_opt_value) String(octeon+) Value(85) Canonical\n+\n+EnumValue\n+Enum(mips_arch_opt_value) String(octeon2) Value(86) Canonical\n+\n+EnumValue\n+Enum(mips_arch_opt_value) String(xlp) Value(87) Canonical\n "}, {"sha": "e4ab271fd60974519fa1e80b596cb2add40c7027", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 642, "deletions": 116, "changes": 758, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -77,6 +77,9 @@ along with GCC; see the file COPYING3.  If not see\n    preserve the maximum stack alignment.  We therefore use a value\n    of 0x7ff0 in this case.\n \n+   microMIPS LWM and SWM support 12-bit offsets (from -0x800 to 0x7ff),\n+   so we use a maximum of 0x7f0 for TARGET_MICROMIPS.\n+\n    MIPS16e SAVE and RESTORE instructions can adjust the stack pointer by\n    up to 0x7f8 bytes and can usually save or restore all the registers\n    that we need to save or restore.  (Note that we can only use these\n@@ -87,8 +90,8 @@ along with GCC; see the file COPYING3.  If not see\n    to save and restore registers, and to allocate and deallocate the top\n    part of the frame.  */\n #define MIPS_MAX_FIRST_STACK_STEP\t\t\t\t\t\\\n-  (!TARGET_MIPS16 ? 0x7ff0\t\t\t\t\t\t\\\n-   : GENERATE_MIPS16E_SAVE_RESTORE ? 0x7f8\t\t\t\t\\\n+  (!TARGET_COMPRESSION ? 0x7ff0\t\t\t\t\t\t\\\n+   : TARGET_MICROMIPS || GENERATE_MIPS16E_SAVE_RESTORE ? 0x7f8\t\t\\\n    : TARGET_64BIT ? 0x100 : 0x400)\n \n /* True if INSN is a mips.md pattern or asm statement.  */\n@@ -560,8 +563,8 @@ static const struct mips_rtx_cost_data *mips_cost;\n /* The ambient target flags, excluding MASK_MIPS16.  */\n static int mips_base_target_flags;\n \n-/* True if MIPS16 is the default mode.  */\n-bool mips_base_mips16;\n+/* The default compression mode.  */\n+unsigned int mips_base_compression_flags;\n \n /* The ambient values of other global variables.  */\n static int mips_base_schedule_insns; /* flag_schedule_insns */\n@@ -674,6 +677,9 @@ static const struct attribute_spec mips_attribute_table[] = {\n      code generation but don't carry other semantics.  */\n   { \"mips16\", \t   0, 0, true,  false, false, NULL, false },\n   { \"nomips16\",    0, 0, true,  false, false, NULL, false },\n+  { \"micromips\",   0, 0, true,  false, false, NULL, false },\n+  { \"nomicromips\", 0, 0, true,  false, false, NULL, false },\n+  { \"nocompression\", 0, 0, true,  false, false, NULL, false },\n   /* Allow functions to be specified as interrupt handlers */\n   { \"interrupt\",   0, 0, false, true,  true, NULL, false },\n   { \"use_shadow_register_set\",\t0, 0, false, true,  true, NULL, false },\n@@ -1167,10 +1173,11 @@ mflip_mips16_use_mips16_p (tree decl)\n   const char *name;\n   hashval_t hash;\n   void **slot;\n+  bool base_is_mips16 = (mips_base_compression_flags & MASK_MIPS16) != 0;\n \n   /* Use the opposite of the command-line setting for anonymous decls.  */\n   if (!DECL_NAME (decl))\n-    return !mips_base_mips16;\n+    return !base_is_mips16;\n \n   if (!mflip_mips16_htab)\n     mflip_mips16_htab = htab_create_ggc (37, mflip_mips16_htab_hash,\n@@ -1185,7 +1192,7 @@ mflip_mips16_use_mips16_p (tree decl)\n       mips16_flipper = !mips16_flipper;\n       entry = ggc_alloc_mflip_mips16_entry ();\n       entry->name = name;\n-      entry->mips16_p = mips16_flipper ? !mips_base_mips16 : mips_base_mips16;\n+      entry->mips16_p = mips16_flipper ? !base_is_mips16 : base_is_mips16;\n       *slot = entry;\n     }\n   return entry->mips16_p;\n@@ -1207,19 +1214,6 @@ mips_far_type_p (const_tree type)\n \t  || lookup_attribute (\"far\", TYPE_ATTRIBUTES (type)) != NULL);\n }\n \n-/* Similar predicates for \"mips16\"/\"nomips16\" function attributes.  */\n-\n-static bool\n-mips_mips16_decl_p (const_tree decl)\n-{\n-  return lookup_attribute (\"mips16\", DECL_ATTRIBUTES (decl)) != NULL;\n-}\n-\n-static bool\n-mips_nomips16_decl_p (const_tree decl)\n-{\n-  return lookup_attribute (\"nomips16\", DECL_ATTRIBUTES (decl)) != NULL;\n-}\n \n /* Check if the interrupt attribute is set for a function.  */\n \n@@ -1257,25 +1251,89 @@ mips_use_debug_exception_return_p (tree type)\n \t\t\t   TYPE_ATTRIBUTES (type)) != NULL;\n }\n \n-/* Return true if function DECL is a MIPS16 function.  Return the ambient\n-   setting if DECL is null.  */\n+/* Return the set of compression modes that are explicitly required\n+   by the attributes in ATTRIBUTES.  */\n \n-static bool\n-mips_use_mips16_mode_p (tree decl)\n+static unsigned int\n+mips_get_compress_on_flags (tree attributes)\n+{\n+  unsigned int flags = 0;\n+\n+  if (lookup_attribute (\"mips16\", attributes) != NULL)\n+    flags |= MASK_MIPS16;\n+\n+  if (lookup_attribute (\"micromips\", attributes) != NULL)\n+    flags |= MASK_MICROMIPS;\n+\n+  return flags;\n+}\n+\n+/* Return the set of compression modes that are explicitly forbidden\n+   by the attributes in ATTRIBUTES.  */\n+\n+static unsigned int\n+mips_get_compress_off_flags (tree attributes)\n {\n+  unsigned int flags = 0;\n+\n+  if (lookup_attribute (\"nocompression\", attributes) != NULL)\n+    flags |= MASK_MIPS16 | MASK_MICROMIPS;\n+\n+  if (lookup_attribute (\"nomips16\", attributes) != NULL)\n+    flags |= MASK_MIPS16;\n+\n+  if (lookup_attribute (\"nomicromips\", attributes) != NULL)\n+    flags |= MASK_MICROMIPS;\n+\n+  return flags;\n+}\n+\n+/* Return the compression mode that should be used for function DECL.\n+   Return the ambient setting if DECL is null.  */\n+\n+static unsigned int\n+mips_get_compress_mode (tree decl)\n+{\n+  unsigned int flags, force_on;\n+\n+  flags = mips_base_compression_flags;\n   if (decl)\n     {\n       /* Nested functions must use the same frame pointer as their\n \t parent and must therefore use the same ISA mode.  */\n       tree parent = decl_function_context (decl);\n       if (parent)\n \tdecl = parent;\n-      if (mips_mips16_decl_p (decl))\n-\treturn true;\n-      if (mips_nomips16_decl_p (decl))\n-\treturn false;\n+      force_on = mips_get_compress_on_flags (DECL_ATTRIBUTES (decl));\n+      if (force_on)\n+\treturn force_on;\n+      flags &= ~mips_get_compress_off_flags (DECL_ATTRIBUTES (decl));\n     }\n-  return mips_base_mips16;\n+  return flags;\n+}\n+\n+/* Return the attribute name associated with MASK_MIPS16 and MASK_MICROMIPS\n+   flags FLAGS.  */\n+\n+static const char *\n+mips_get_compress_on_name (unsigned int flags)\n+{\n+  if (flags == MASK_MIPS16)\n+    return \"mips16\";\n+  return \"micromips\";\n+}\n+\n+/* Return the attribute name that forbids MASK_MIPS16 and MASK_MICROMIPS\n+   flags FLAGS.  */\n+\n+static const char *\n+mips_get_compress_off_name (unsigned int flags)\n+{\n+  if (flags == MASK_MIPS16)\n+    return \"nomips16\";\n+  if (flags == MASK_MICROMIPS)\n+    return \"nomicromips\";\n+  return \"nocompression\";\n }\n \n /* Implement TARGET_COMP_TYPE_ATTRIBUTES.  */\n@@ -1297,37 +1355,50 @@ static void\n mips_insert_attributes (tree decl, tree *attributes)\n {\n   const char *name;\n-  bool mips16_p, nomips16_p;\n+  unsigned int compression_flags, nocompression_flags;\n \n   /* Check for \"mips16\" and \"nomips16\" attributes.  */\n-  mips16_p = lookup_attribute (\"mips16\", *attributes) != NULL;\n-  nomips16_p = lookup_attribute (\"nomips16\", *attributes) != NULL;\n+  compression_flags = mips_get_compress_on_flags (*attributes);\n+  nocompression_flags = mips_get_compress_off_flags (*attributes);\n+\n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n-      if (mips16_p)\n-\terror (\"%qs attribute only applies to functions\", \"mips16\");\n-      if (nomips16_p)\n-\terror (\"%qs attribute only applies to functions\", \"nomips16\");\n+      if (nocompression_flags)\n+\terror (\"%qs attribute only applies to functions\",\n+\t       mips_get_compress_off_name (nocompression_flags));\n+\n+      if (compression_flags)\n+\terror (\"%qs attribute only applies to functions\",\n+\t       mips_get_compress_on_name (nocompression_flags));\n     }\n   else\n     {\n-      mips16_p |= mips_mips16_decl_p (decl);\n-      nomips16_p |= mips_nomips16_decl_p (decl);\n-      if (mips16_p || nomips16_p)\n-\t{\n-\t  /* DECL cannot be simultaneously \"mips16\" and \"nomips16\".  */\n-\t  if (mips16_p && nomips16_p)\n-\t    error (\"%qE cannot have both %<mips16%> and \"\n-\t\t   \"%<nomips16%> attributes\",\n-\t\t   DECL_NAME (decl));\n-\t}\n-      else if (TARGET_FLIP_MIPS16 && !DECL_ARTIFICIAL (decl))\n+      compression_flags |= mips_get_compress_on_flags (DECL_ATTRIBUTES (decl));\n+      nocompression_flags |=\n+\tmips_get_compress_off_flags (DECL_ATTRIBUTES (decl));\n+\n+      if (compression_flags && nocompression_flags)\n+\terror (\"%qE cannot have both %qs and %qs attributes\",\n+\t       DECL_NAME (decl), mips_get_compress_on_name (compression_flags),\n+\t       mips_get_compress_off_name (nocompression_flags));\n+\n+      if (compression_flags & MASK_MIPS16\n+          && compression_flags & MASK_MICROMIPS)\n+\terror (\"%qE cannot have both %qs and %qs attributes\",\n+\t       DECL_NAME (decl), \"mips16\", \"micromips\");\n+\n+      if (TARGET_FLIP_MIPS16\n+\t  && !DECL_ARTIFICIAL (decl)\n+\t  && compression_flags == 0\n+\t  && nocompression_flags == 0)\n \t{\n \t  /* Implement -mflip-mips16.  If DECL has neither a \"nomips16\" nor a\n \t     \"mips16\" attribute, arbitrarily pick one.  We must pick the same\n \t     setting for duplicate declarations of a function.  */\n \t  name = mflip_mips16_use_mips16_p (decl) ? \"mips16\" : \"nomips16\";\n \t  *attributes = tree_cons (get_identifier (name), NULL, *attributes);\n+\t  name = \"nomicromips\";\n+\t  *attributes = tree_cons (get_identifier (name), NULL, *attributes);\n \t}\n     }\n }\n@@ -1337,13 +1408,19 @@ mips_insert_attributes (tree decl, tree *attributes)\n static tree\n mips_merge_decl_attributes (tree olddecl, tree newdecl)\n {\n-  /* The decls' \"mips16\" and \"nomips16\" attributes must match exactly.  */\n-  if (mips_mips16_decl_p (olddecl) != mips_mips16_decl_p (newdecl))\n+  unsigned int diff;\n+\n+  diff = (mips_get_compress_on_flags (DECL_ATTRIBUTES (olddecl))\n+\t  ^ mips_get_compress_on_flags (DECL_ATTRIBUTES (newdecl)));\n+  if (diff)\n     error (\"%qE redeclared with conflicting %qs attributes\",\n-\t   DECL_NAME (newdecl), \"mips16\");\n-  if (mips_nomips16_decl_p (olddecl) != mips_nomips16_decl_p (newdecl))\n+\t   DECL_NAME (newdecl), mips_get_compress_on_name (diff));\n+\n+  diff = (mips_get_compress_off_flags (DECL_ATTRIBUTES (olddecl))\n+\t  ^ mips_get_compress_off_flags (DECL_ATTRIBUTES (newdecl)));\n+  if (diff)\n     error (\"%qE redeclared with conflicting %qs attributes\",\n-\t   DECL_NAME (newdecl), \"nomips16\");\n+\t   DECL_NAME (newdecl), mips_get_compress_off_name (diff));\n \n   return merge_attributes (DECL_ATTRIBUTES (olddecl),\n \t\t\t   DECL_ATTRIBUTES (newdecl));\n@@ -1550,7 +1627,7 @@ mips16_local_function_p (const_rtx x)\n   return (GET_CODE (x) == SYMBOL_REF\n \t  && SYMBOL_REF_LOCAL_P (x)\n \t  && !SYMBOL_REF_EXTERNAL_P (x)\n-\t  && mips_use_mips16_mode_p (SYMBOL_REF_DECL (x)));\n+\t  && (mips_get_compress_mode (SYMBOL_REF_DECL (x)) & MASK_MIPS16));\n }\n \n /* Return true if SYMBOL_REF X binds locally.  */\n@@ -2300,6 +2377,20 @@ mips_address_insns (rtx x, enum machine_mode mode, bool might_split_p)\n   return 0;\n }\n \n+/* Return true if X is a legitimate address with a 12-bit offset.\n+   MODE is the mode of the value being accessed.  */\n+\n+bool\n+umips_12bit_offset_address_p (rtx x, enum machine_mode mode)\n+{\n+  struct mips_address_info addr;\n+\n+  return (mips_classify_address (&addr, x, mode, false)\n+\t  && addr.type == ADDRESS_REG\n+\t  && CONST_INT_P (addr.offset)\n+\t  && UMIPS_12BIT_OFFSET_P (INTVAL (addr.offset)));\n+}\n+\n /* Return the number of instructions needed to load constant X.\n    Return 0 if X isn't a valid constant.  */\n \n@@ -6097,6 +6188,13 @@ mips_start_function_definition (const char *name, bool mips16_p)\n   else\n     fprintf (asm_out_file, \"\\t.set\\tnomips16\\n\");\n \n+  if (TARGET_MICROMIPS)\n+    fprintf (asm_out_file, \"\\t.set\\tmicromips\\n\");\n+#ifdef HAVE_GAS_MICROMIPS\n+  else\n+    fprintf (asm_out_file, \"\\t.set\\tnomicromips\\n\");\n+#endif\n+\n   if (!flag_inhibit_size_directive)\n     {\n       fputs (\"\\t.ent\\t\", asm_out_file);\n@@ -6903,6 +7001,37 @@ mips_split_call (rtx insn, rtx call_pattern)\n     mips_restore_gp_from_cprestore_slot (gen_rtx_REG (Pmode, GP_ARG_FIRST + 2));\n }\n \n+/* Return true if a call to DECL may need to use JALX.  */\n+\n+static bool\n+mips_call_may_need_jalx_p (tree decl)\n+{\n+  /* If the current translation unit would use a different mode for DECL,\n+     assume that the call needs JALX.  */\n+  if (mips_get_compress_mode (decl) != TARGET_COMPRESSION)\n+    return true;\n+\n+  /* mips_get_compress_mode is always accurate for locally-binding\n+     functions in the current translation unit.  */\n+  if (!DECL_EXTERNAL (decl) && targetm.binds_local_p (decl))\n+    return false;\n+\n+  /* When -minterlink-compressed is in effect, assume that functions\n+     could use a different encoding mode unless an attribute explicitly\n+     tells us otherwise.  */\n+  if (TARGET_INTERLINK_COMPRESSED)\n+    {\n+      if (!TARGET_COMPRESSION\n+\t  && mips_get_compress_off_flags (DECL_ATTRIBUTES (decl)) ==0)\n+\treturn true;\n+      if (TARGET_COMPRESSION\n+\t  && mips_get_compress_on_flags (DECL_ATTRIBUTES (decl)) == 0)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* Implement TARGET_FUNCTION_OK_FOR_SIBCALL.  */\n \n static bool\n@@ -6916,23 +7045,11 @@ mips_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n   if (mips_interrupt_type_p (TREE_TYPE (current_function_decl)))\n     return false;\n \n-  /* We can't do a sibcall if the called function is a MIPS16 function\n-     because there is no direct \"jx\" instruction equivalent to \"jalx\" to\n-     switch the ISA mode.  We only care about cases where the sibling\n-     and normal calls would both be direct.  */\n+  /* Direct Js are only possible to functions that use the same ISA encoding.\n+     There is no JX counterpoart of JALX.  */\n   if (decl\n-      && mips_use_mips16_mode_p (decl)\n-      && const_call_insn_operand (XEXP (DECL_RTL (decl), 0), VOIDmode))\n-    return false;\n-\n-  /* When -minterlink-mips16 is in effect, assume that non-locally-binding\n-     functions could be MIPS16 ones unless an attribute explicitly tells\n-     us otherwise.  */\n-  if (TARGET_INTERLINK_MIPS16\n-      && decl\n-      && (DECL_EXTERNAL (decl) || !targetm.binds_local_p (decl))\n-      && !mips_nomips16_decl_p (decl)\n-      && const_call_insn_operand (XEXP (DECL_RTL (decl), 0), VOIDmode))\n+      && const_call_insn_operand (XEXP (DECL_RTL (decl), 0), VOIDmode)\n+      && mips_call_may_need_jalx_p (decl))\n     return false;\n \n   /* Otherwise OK.  */\n@@ -7798,6 +7915,9 @@ mips_pop_asm_switch (struct mips_asm_switch *asm_switch)\n    '^'\tPrint the name of the pic call-through register (t9 or $25).\n    '+'\tPrint the name of the gp register (usually gp or $28).\n    '$'\tPrint the name of the stack pointer register (sp or $29).\n+   ':'  Print \"c\" to use the compact version if the delay slot is a nop.\n+   '!'  Print \"s\" to use the short version if the delay slot contains a\n+\t16-bit instruction.\n \n    See also mips_init_print_operand_pucnt.  */\n \n@@ -7881,6 +8001,20 @@ mips_print_operand_punctuation (FILE *file, int ch)\n       fputs (reg_names[STACK_POINTER_REGNUM], file);\n       break;\n \n+    case ':':\n+      /* When final_sequence is 0, the delay slot will be a nop.  We can\n+\t use the compact version for microMIPS.  */\n+      if (final_sequence == 0)\n+\tputc ('c', file);\n+      break;\n+\n+    case '!':\n+      /* When final_sequence is 0, the delay slot will be a nop.  We can\n+\t a 16-bit delay slot for microMIPS.  */\n+      if (final_sequence == 0)\n+\tputc ('s', file);\n+      break;\n+\n     default:\n       gcc_unreachable ();\n       break;\n@@ -7894,7 +8028,7 @@ mips_init_print_operand_punct (void)\n {\n   const char *p;\n \n-  for (p = \"()[]<>*#/?~.@^+$\"; *p; p++)\n+  for (p = \"()[]<>*#/?~.@^+$:!\"; *p; p++)\n     mips_print_operand_punct[(unsigned char) *p] = true;\n }\n \n@@ -10236,6 +10370,126 @@ mips_for_each_saved_acc (HOST_WIDE_INT sp_offset, mips_save_restore_fn fn)\n       }\n }\n \n+/* Save register REG to MEM.  Make the instruction frame-related.  */\n+\n+static void\n+mips_save_reg (rtx reg, rtx mem)\n+{\n+  if (GET_MODE (reg) == DFmode && !TARGET_FLOAT64)\n+    {\n+      rtx x1, x2;\n+\n+      mips_emit_move_or_split (mem, reg, SPLIT_IF_NECESSARY);\n+\n+      x1 = mips_frame_set (mips_subword (mem, false),\n+\t\t\t   mips_subword (reg, false));\n+      x2 = mips_frame_set (mips_subword (mem, true),\n+\t\t\t   mips_subword (reg, true));\n+      mips_set_frame_expr (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, x1, x2)));\n+    }\n+  else\n+    mips_emit_save_slot_move (mem, reg, MIPS_PROLOGUE_TEMP (GET_MODE (reg)));\n+}\n+\n+/* Capture the register combinations that are allowed in a SWM or LWM\n+   instruction.  The entries are ordered by number of registers set in\n+   the mask.  We also ignore the single register encodings because a\n+   normal SW/LW is preferred.  */\n+\n+static const unsigned int umips_swm_mask[17] = {\n+  0xc0ff0000, 0x80ff0000, 0x40ff0000, 0x807f0000,\n+  0x00ff0000, 0x803f0000, 0x007f0000, 0x801f0000,\n+  0x003f0000, 0x800f0000, 0x001f0000, 0x80070000,\n+  0x000f0000, 0x80030000, 0x00070000, 0x80010000,\n+  0x00030000\n+};\n+\n+static const unsigned int umips_swm_encoding[17] = {\n+  25, 24, 9, 23, 8, 22, 7, 21, 6, 20, 5, 19, 4, 18, 3, 17, 2\n+};\n+\n+/* Try to use a microMIPS LWM or SWM instruction to save or restore\n+   as many GPRs in *MASK as possible.  *OFFSET is the offset from the\n+   stack pointer of the topmost save slot.\n+\n+   Remove from *MASK all registers that were handled using LWM and SWM.\n+   Update *OFFSET so that it points to the first unused save slot.  */\n+\n+static bool\n+umips_build_save_restore (mips_save_restore_fn fn,\n+\t\t\t  unsigned *mask, HOST_WIDE_INT *offset)\n+{\n+  int nregs;\n+  unsigned int i, j;\n+  rtx pattern, set, reg, mem;\n+  HOST_WIDE_INT this_offset;\n+  rtx this_base;\n+\n+  /* Try matching $16 to $31 (s0 to ra).  */\n+  for (i = 0; i < ARRAY_SIZE (umips_swm_mask); i++)\n+    if ((*mask & 0xffff0000) == umips_swm_mask[i])\n+      break;\n+\n+  if (i == ARRAY_SIZE (umips_swm_mask))\n+    return false;\n+\n+  /* Get the offset of the lowest save slot.  */\n+  nregs = (umips_swm_encoding[i] & 0xf) + (umips_swm_encoding[i] >> 4);\n+  this_offset = *offset - UNITS_PER_WORD * (nregs - 1);\n+\n+  /* LWM/SWM can only support offsets from -2048 to 2047.  */\n+  if (!UMIPS_12BIT_OFFSET_P (this_offset))\n+    return false;\n+\n+  /* Create the final PARALLEL.  */\n+  pattern = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (nregs));\n+  this_base = stack_pointer_rtx;\n+\n+  /* For registers $16-$23 and $30.  */\n+  for (j = 0; j < (umips_swm_encoding[i] & 0xf); j++)\n+    {\n+      HOST_WIDE_INT offset = this_offset + j * UNITS_PER_WORD;\n+      mem = gen_frame_mem (SImode, plus_constant (Pmode, this_base, offset));\n+      unsigned int regno = (j != 8) ? 16 + j : 30;\n+      *mask &= ~(1 << regno);\n+      reg = gen_rtx_REG (SImode, regno);\n+      if (fn == mips_save_reg)\n+\tset = mips_frame_set (mem, reg);\n+      else\n+\t{\n+\t  set = gen_rtx_SET (VOIDmode, reg, mem);\n+\t  mips_add_cfa_restore (reg);\n+\t}\n+      XVECEXP (pattern, 0, j) = set;\n+    }\n+\n+  /* For register $31.  */\n+  if (umips_swm_encoding[i] >> 4)\n+    {\n+      HOST_WIDE_INT offset = this_offset + j * UNITS_PER_WORD;\n+      *mask &= ~(1 << 31);\n+      mem = gen_frame_mem (SImode, plus_constant (Pmode, this_base, offset));\n+      reg = gen_rtx_REG (SImode, 31);\n+      if (fn == mips_save_reg)\n+\tset = mips_frame_set (mem, reg);\n+      else\n+\t{\n+\t  set = gen_rtx_SET (VOIDmode, reg, mem);\n+\t  mips_add_cfa_restore (reg);\n+\t}\n+      XVECEXP (pattern, 0, j) = set;\n+    }\n+\n+  pattern = emit_insn (pattern);\n+  if (fn == mips_save_reg)\n+    RTX_FRAME_RELATED_P (pattern) = 1;\n+\n+  /* Adjust the last offset.  */\n+  *offset -= UNITS_PER_WORD * nregs;\n+\n+  return true;\n+}\n+\n /* Call FN for each register that is saved by the current function.\n    SP_OFFSET is the offset of the current stack pointer from the start\n    of the frame.  */\n@@ -10245,16 +10499,23 @@ mips_for_each_saved_gpr_and_fpr (HOST_WIDE_INT sp_offset,\n \t\t\t\t mips_save_restore_fn fn)\n {\n   enum machine_mode fpr_mode;\n-  HOST_WIDE_INT offset;\n   int regno;\n+  const struct mips_frame_info *frame = &cfun->machine->frame;\n+  HOST_WIDE_INT offset;\n+  unsigned int mask;\n \n   /* Save registers starting from high to low.  The debuggers prefer at least\n      the return register be stored at func+4, and also it allows us not to\n      need a nop in the epilogue if at least one register is reloaded in\n      addition to return address.  */\n-  offset = cfun->machine->frame.gp_sp_offset - sp_offset;\n+  offset = frame->gp_sp_offset - sp_offset;\n+  mask = frame->mask;\n+\n+  if (TARGET_MICROMIPS)\n+    umips_build_save_restore (fn, &mask, &offset);\n+\n   for (regno = GP_REG_LAST; regno >= GP_REG_FIRST; regno--)\n-    if (BITSET_P (cfun->machine->frame.mask, regno - GP_REG_FIRST))\n+    if (BITSET_P (mask, regno - GP_REG_FIRST))\n       {\n \t/* Record the ra offset for use by mips_function_profiler.  */\n \tif (regno == RETURN_ADDR_REGNUM)\n@@ -10501,26 +10762,6 @@ mips_frame_barrier (void)\n   emit_clobber (gen_frame_mem (BLKmode, stack_pointer_rtx));\n }\n \n-/* Save register REG to MEM.  Make the instruction frame-related.  */\n-\n-static void\n-mips_save_reg (rtx reg, rtx mem)\n-{\n-  if (GET_MODE (reg) == DFmode && !TARGET_FLOAT64)\n-    {\n-      rtx x1, x2;\n-\n-      mips_emit_move_or_split (mem, reg, SPLIT_IF_NECESSARY);\n-\n-      x1 = mips_frame_set (mips_subword (mem, false),\n-\t\t\t   mips_subword (reg, false));\n-      x2 = mips_frame_set (mips_subword (mem, true),\n-\t\t\t   mips_subword (reg, true));\n-      mips_set_frame_expr (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, x1, x2)));\n-    }\n-  else\n-    mips_emit_save_slot_move (mem, reg, MIPS_PROLOGUE_TEMP (GET_MODE (reg)));\n-}\n \n /* The __gnu_local_gp symbol.  */\n \n@@ -11239,7 +11480,7 @@ mips_expand_epilogue (bool sibcall_p)\n \t  mips_emit_move (gen_rtx_REG (word_mode, K0_REG_NUM), mem);\n \t  offset -= UNITS_PER_WORD;\n \n-\t  /* If we don't use shoadow register set, we need to update SP.  */\n+\t  /* If we don't use shadow register set, we need to update SP.  */\n \t  if (!cfun->machine->use_shadow_register_set_p)\n \t    mips_deallocate_stack (stack_pointer_rtx, GEN_INT (step2), 0);\n \t  else\n@@ -11254,6 +11495,7 @@ mips_expand_epilogue (bool sibcall_p)\n \t/* Deallocate the final bit of the frame.  */\n \tmips_deallocate_stack (stack_pointer_rtx, GEN_INT (step2), 0);\n     }\n+\n   gcc_assert (!mips_epilogue.cfa_restores);\n \n   /* Add in the __builtin_eh_return stack adjustment.  We need to\n@@ -16211,17 +16453,19 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   reload_completed = 0;\n }\n \f\n-/* The last argument passed to mips_set_mips16_mode, or negative if the\n-   function hasn't been called yet.  */\n-static int was_mips16_p = -1;\n \n-/* Set up the target-dependent global state so that it matches the\n-   current function's ISA mode.  */\n+/* The last argument passed to mips_set_compression_mode,\n+   or negative if the function hasn't been called yet.  */\n+static unsigned int old_compression_mode = -1;\n+\n+/* Set up the target-dependent global state for ISA mode COMPRESSION_MODE,\n+   which is either MASK_MIPS16 or MASK_MICROMIPS.  */\n \n static void\n-mips_set_mips16_mode (int mips16_p)\n+mips_set_compression_mode (unsigned int compression_mode)\n {\n-  if (mips16_p == was_mips16_p)\n+\n+  if (compression_mode == old_compression_mode)\n     return;\n \n   /* Restore base settings of various flags.  */\n@@ -16232,8 +16476,10 @@ mips_set_mips16_mode (int mips16_p)\n   align_loops = mips_base_align_loops;\n   align_jumps = mips_base_align_jumps;\n   align_functions = mips_base_align_functions;\n+  target_flags &= ~(MASK_MIPS16 | MASK_MICROMIPS);\n+  target_flags |= compression_mode;\n \n-  if (mips16_p)\n+  if (compression_mode & MASK_MIPS16)\n     {\n       /* Switch to MIPS16 mode.  */\n       target_flags |= MASK_MIPS16;\n@@ -16287,8 +16533,11 @@ mips_set_mips16_mode (int mips16_p)\n     }\n   else\n     {\n-      /* Switch to normal (non-MIPS16) mode.  */\n-      target_flags &= ~MASK_MIPS16;\n+      /* Switch to microMIPS or the standard encoding.  */\n+\n+      if (TARGET_MICROMIPS)\n+\t/* Avoid branch likely.  */\n+\ttarget_flags &= ~MASK_BRANCHLIKELY;\n \n       /* Provide default values for align_* for 64-bit targets.  */\n       if (TARGET_64BIT)\n@@ -16310,7 +16559,7 @@ mips_set_mips16_mode (int mips16_p)\n   /* (Re)initialize MIPS target internals for new ISA.  */\n   mips_init_relocs ();\n \n-  if (mips16_p)\n+  if (compression_mode & MASK_MIPS16)\n     {\n       if (!mips16_globals)\n \tmips16_globals = save_target_globals_default_opts ();\n@@ -16320,16 +16569,17 @@ mips_set_mips16_mode (int mips16_p)\n   else\n     restore_target_globals (&default_target_globals);\n \n-  was_mips16_p = mips16_p;\n+  old_compression_mode = compression_mode;\n }\n \n /* Implement TARGET_SET_CURRENT_FUNCTION.  Decide whether the current\n-   function should use the MIPS16 ISA and switch modes accordingly.  */\n+   function should use the MIPS16 or microMIPS ISA and switch modes\n+   accordingly.  */\n \n static void\n mips_set_current_function (tree fndecl)\n {\n-  mips_set_mips16_mode (mips_use_mips16_mode_p (fndecl));\n+  mips_set_compression_mode (mips_get_compress_mode (fndecl));\n }\n \f\n /* Allocate a chunk of memory for per-function machine-dependent data.  */\n@@ -16437,14 +16687,19 @@ mips_option_override (void)\n   if (global_options_set.x_mips_isa_option)\n     mips_isa_option_info = &mips_cpu_info_table[mips_isa_option];\n \n-  /* Process flags as though we were generating non-MIPS16 code.  */\n-  mips_base_mips16 = TARGET_MIPS16;\n-  target_flags &= ~MASK_MIPS16;\n-\n #ifdef SUBTARGET_OVERRIDE_OPTIONS\n   SUBTARGET_OVERRIDE_OPTIONS;\n #endif\n \n+  /* MIPS16 and microMIPS cannot coexist.  */\n+  if (TARGET_MICROMIPS && TARGET_MIPS16)\n+    error (\"unsupported combination: %s\", \"-mips16 -mmicromips\");\n+\n+  /* Save the base compression state and process flags as though we\n+     were generating uncompressed code.  */\n+  mips_base_compression_flags = TARGET_COMPRESSION;\n+  target_flags &= ~TARGET_COMPRESSION;\n+\n   /* -mno-float overrides -mhard-float and -msoft-float.  */\n   if (TARGET_NO_FLOAT)\n     {\n@@ -16453,7 +16708,7 @@ mips_option_override (void)\n     }\n \n   if (TARGET_FLIP_MIPS16)\n-    TARGET_INTERLINK_MIPS16 = 1;\n+    TARGET_INTERLINK_COMPRESSED = 1;\n \n   /* Set the small data limit.  */\n   mips_small_data_threshold = (global_options_set.x_g_switch_value\n@@ -16826,9 +17081,9 @@ mips_option_override (void)\n \n   /* Now select the ISA mode.\n \n-     Do all CPP-sensitive stuff in non-MIPS16 mode; we'll switch to\n-     MIPS16 mode afterwards if need be.  */\n-  mips_set_mips16_mode (false);\n+     Do all CPP-sensitive stuff in uncompressed mode; we'll switch modes\n+     later if required.  */\n+  mips_set_compression_mode (0);\n }\n \n /* Swap the register information for registers I and I + 1, which\n@@ -17088,6 +17343,277 @@ mips_mulsidi3_gen_fn (enum rtx_code ext_code)\n       return signed_p ? gen_mulsidi3_32bit : gen_umulsidi3_32bit;\n     }\n }\n+\n+/* Return true if PATTERN matches the kind of instruction generated by\n+   umips_build_save_restore.  SAVE_P is true for store.  */\n+\n+bool\n+umips_save_restore_pattern_p (bool save_p, rtx pattern)\n+{\n+  int n;\n+  unsigned int i;\n+  HOST_WIDE_INT first_offset = 0;\n+  rtx first_base = 0;\n+  unsigned int regmask = 0;\n+\n+  for (n = 0; n < XVECLEN (pattern, 0); n++)\n+    {\n+      rtx set, reg, mem, this_base;\n+      HOST_WIDE_INT this_offset;\n+\n+      /* Check that we have a SET.  */\n+      set = XVECEXP (pattern, 0, n);\n+      if (GET_CODE (set) != SET)\n+\treturn false;\n+\n+      /* Check that the SET is a load (if restoring) or a store\n+\t (if saving).  */\n+      mem = save_p ? SET_DEST (set) : SET_SRC (set);\n+      if (!MEM_P (mem) || MEM_VOLATILE_P (mem))\n+\treturn false;\n+\n+      /* Check that the address is the sum of base and a possibly-zero\n+\t constant offset.  Determine if the offset is in range.  */\n+      mips_split_plus (XEXP (mem, 0), &this_base, &this_offset);\n+      if (!REG_P (this_base))\n+\treturn false;\n+\n+      if (n == 0)\n+\t{\n+\t  if (!UMIPS_12BIT_OFFSET_P (this_offset))\n+\t    return false;\n+\t  first_base = this_base;\n+\t  first_offset = this_offset;\n+\t}\n+      else\n+\t{\n+\t  /* Check that the save slots are consecutive.  */\n+\t  if (REGNO (this_base) != REGNO (first_base)\n+\t      || this_offset != first_offset + UNITS_PER_WORD * n)\n+\t    return false;\n+\t}\n+\n+      /* Check that SET's other operand is a register.  */\n+      reg = save_p ? SET_SRC (set) : SET_DEST (set);\n+      if (!REG_P (reg))\n+\treturn false;\n+\n+      regmask |= 1 << REGNO (reg);\n+    }\n+\n+  for (i = 0; i < ARRAY_SIZE (umips_swm_mask); i++)\n+    if (regmask == umips_swm_mask[i])\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Return the assembly instruction for microMIPS LWM or SWM.\n+   SAVE_P and PATTERN are as for umips_save_restore_pattern_p.  */\n+\n+const char *\n+umips_output_save_restore (bool save_p, rtx pattern)\n+{\n+  static char buffer[300];\n+  char *s;\n+  int n;\n+  HOST_WIDE_INT offset;\n+  rtx base, mem, set, last_set, last_reg;\n+\n+  /* Parse the pattern.  */\n+  gcc_assert (umips_save_restore_pattern_p (save_p, pattern));\n+\n+  s = strcpy (buffer, save_p ? \"swm\\t\" : \"lwm\\t\");\n+  s += strlen (s);\n+  n = XVECLEN (pattern, 0);\n+\n+  set = XVECEXP (pattern, 0, 0);\n+  mem = save_p ? SET_DEST (set) : SET_SRC (set);\n+  mips_split_plus (XEXP (mem, 0), &base, &offset);\n+\n+  last_set = XVECEXP (pattern, 0, n - 1);\n+  last_reg = save_p ? SET_SRC (last_set) : SET_DEST (last_set);\n+\n+  if (REGNO (last_reg) == 31)\n+    n--;\n+\n+  gcc_assert (n <= 9);\n+  if (n == 0)\n+    ;\n+  else if (n == 1)\n+    s += sprintf (s, \"%s,\", reg_names[16]);\n+  else if (n < 9)\n+    s += sprintf (s, \"%s-%s,\", reg_names[16], reg_names[15 + n]);\n+  else if (n == 9)\n+    s += sprintf (s, \"%s-%s,%s,\", reg_names[16], reg_names[23],\n+\t\t  reg_names[30]);\n+\n+  if (REGNO (last_reg) == 31)\n+    s += sprintf (s, \"%s,\", reg_names[31]);\n+\n+  s += sprintf (s, \"%d(%s)\", (int)offset, reg_names[REGNO (base)]);\n+  return buffer;\n+}\n+\n+/* Return true if MEM1 and MEM2 use the same base register, and the\n+   offset of MEM2 equals the offset of MEM1 plus 4.  FIRST_REG is the\n+   register into (from) which the contents of MEM1 will be loaded\n+   (stored), depending on the value of LOAD_P.\n+   SWAP_P is true when the 1st and 2nd instructions are swapped.  */\n+\n+static bool\n+umips_load_store_pair_p_1 (bool load_p, bool swap_p,\n+\t\t\t   rtx first_reg, rtx mem1, rtx mem2)\n+{\n+  rtx base1, base2;\n+  HOST_WIDE_INT offset1, offset2;\n+\n+  if (!MEM_P (mem1) || !MEM_P (mem2))\n+    return false;\n+\n+  mips_split_plus (XEXP (mem1, 0), &base1, &offset1);\n+  mips_split_plus (XEXP (mem2, 0), &base2, &offset2);\n+\n+  if (!REG_P (base1) || !rtx_equal_p (base1, base2))\n+    return false;\n+\n+  /* Avoid invalid load pair instructions.  */\n+  if (load_p && REGNO (first_reg) == REGNO (base1))\n+    return false;\n+\n+  /* We must avoid this case for anti-dependence.\n+     Ex:  lw $3, 4($3)\n+          lw $2, 0($3)\n+     first_reg is $2, but the base is $3.  */\n+  if (load_p\n+      && swap_p\n+      && REGNO (first_reg) + 1 == REGNO (base1))\n+    return false;\n+\n+  if (offset2 != offset1 + 4)\n+    return false;\n+\n+  if (!UMIPS_12BIT_OFFSET_P (offset1))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* OPERANDS describes the operands to a pair of SETs, in the order\n+   dest1, src1, dest2, src2.  Return true if the operands can be used\n+   in an LWP or SWP instruction; LOAD_P says which.  */\n+\n+bool\n+umips_load_store_pair_p (bool load_p, rtx *operands)\n+{\n+  rtx reg1, reg2, mem1, mem2;\n+\n+  if (load_p)\n+    {\n+      reg1 = operands[0];\n+      reg2 = operands[2];\n+      mem1 = operands[1];\n+      mem2 = operands[3];\n+    }\n+  else\n+    {\n+      reg1 = operands[1];\n+      reg2 = operands[3];\n+      mem1 = operands[0];\n+      mem2 = operands[2];\n+    }\n+\n+  if (REGNO (reg2) == REGNO (reg1) + 1)\n+    return umips_load_store_pair_p_1 (load_p, false, reg1, mem1, mem2);\n+\n+  if (REGNO (reg1) == REGNO (reg2) + 1)\n+    return umips_load_store_pair_p_1 (load_p, true, reg2, mem2, mem1);\n+\n+  return false;\n+}\n+\n+/* Return the assembly instruction for a microMIPS LWP or SWP in which\n+   the first register is REG and the first memory slot is MEM.\n+   LOAD_P is true for LWP.  */\n+\n+static void\n+umips_output_load_store_pair_1 (bool load_p, rtx reg, rtx mem)\n+{\n+  rtx ops[] = {reg, mem};\n+\n+  if (load_p)\n+    output_asm_insn (\"lwp\\t%0,%1\", ops);\n+  else\n+    output_asm_insn (\"swp\\t%0,%1\", ops);\n+}\n+\n+/* Output the assembly instruction for a microMIPS LWP or SWP instruction.\n+   LOAD_P and OPERANDS are as for umips_load_store_pair_p.  */\n+\n+void\n+umips_output_load_store_pair (bool load_p, rtx *operands)\n+{\n+  rtx reg1, reg2, mem1, mem2;\n+  if (load_p)\n+    {\n+      reg1 = operands[0];\n+      reg2 = operands[2];\n+      mem1 = operands[1];\n+      mem2 = operands[3];\n+    }\n+  else\n+    {\n+      reg1 = operands[1];\n+      reg2 = operands[3];\n+      mem1 = operands[0];\n+      mem2 = operands[2];\n+    }\n+\n+  if (REGNO (reg2) == REGNO (reg1) + 1)\n+    {\n+      umips_output_load_store_pair_1 (load_p, reg1, mem1);\n+      return;\n+    }\n+\n+  gcc_assert (REGNO (reg1) == REGNO (reg2) + 1);\n+  umips_output_load_store_pair_1 (load_p, reg2, mem2);\n+}\n+\n+/* Return true if REG1 and REG2 match the criteria for a movep insn.  */\n+\n+bool\n+umips_movep_target_p (rtx reg1, rtx reg2)\n+{\n+  int regno1, regno2, pair;\n+  unsigned int i;\n+  static const int match[8] = {\n+    0x00000060, /* 5, 6 */\n+    0x000000a0, /* 5, 7 */\n+    0x000000c0, /* 6, 7 */\n+    0x00200010, /* 4, 21 */\n+    0x00400010, /* 4, 22 */\n+    0x00000030, /* 4, 5 */\n+    0x00000050, /* 4, 6 */\n+    0x00000090  /* 4, 7 */\n+  };\n+\n+  if (!REG_P (reg1) || !REG_P (reg2))\n+    return false;\n+\n+  regno1 = REGNO (reg1);\n+  regno2 = REGNO (reg2);\n+\n+  if (!GP_REG_P (regno1) || !GP_REG_P (regno2))\n+    return false;\n+\n+  pair = (1 << regno1) | (1 << regno2);\n+\n+  for (i = 0; i < ARRAY_SIZE (match); i++)\n+    if (pair == match[i])\n+      return true;\n+\n+  return false;\n+}\n \f\n /* Return the size in bytes of the trampoline code, padded to\n    TRAMPOLINE_ALIGNMENT bits.  The static chain pointer and target\n@@ -17342,7 +17868,7 @@ mips_prepare_pch_save (void)\n      It therefore seems best to switch back to non-MIPS16 mode at\n      save time, and to ensure that mips16_globals remains null after\n      a PCH load.  */\n-  mips_set_mips16_mode (false);\n+  mips_set_compression_mode (0);\n   mips16_globals = 0;\n }\n \f"}, {"sha": "0db36988dcccf55c7a50416a35ab72ed80094aba", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -174,6 +174,9 @@ struct mips_cpu_info {\n #define ISA_HAS_DSP_MULT ISA_HAS_DSPR2\n #endif\n \n+/* The ISA compression flags that are currently in effect.  */\n+#define TARGET_COMPRESSION (target_flags & (MASK_MIPS16 | MASK_MICROMIPS))\n+\n /* Generate mips16 code */\n #define TARGET_MIPS16\t\t((target_flags & MASK_MIPS16) != 0)\n /* Generate mips16e code. Default 16bit ASE for mips32* and mips64* */\n@@ -374,7 +377,7 @@ struct mips_cpu_info {\n       else\t\t\t\t\t\t\t\t\\\n \tbuiltin_define (\"__mips_fpr=32\");\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      if (mips_base_mips16)\t\t\t\t\t\t\\\n+      if (mips_base_compression_flags & MASK_MIPS16)\t\t\t\\\n \tbuiltin_define (\"__mips16\");\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (TARGET_MIPS3D)\t\t\t\t\t\t\\\n@@ -383,6 +386,9 @@ struct mips_cpu_info {\n       if (TARGET_SMARTMIPS)\t\t\t\t\t\t\\\n \tbuiltin_define (\"__mips_smartmips\");\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+      if (mips_base_compression_flags & MASK_MICROMIPS)\t\t\t\\\n+\tbuiltin_define (\"__mips_micromips\");\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n       if (TARGET_MCU)\t\t\t\t\t\t\t\\\n \tbuiltin_define (\"__mips_mcu\");\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -702,7 +708,7 @@ struct mips_cpu_info {\n        |march=r10000|march=r12000|march=r14000|march=r16000:-mips4} \\\n      %{march=mips32|march=4kc|march=4km|march=4kp|march=4ksc:-mips32} \\\n      %{march=mips32r2|march=m4k|march=4ke*|march=4ksd|march=24k* \\\n-       |march=34k*|march=74k*|march=1004k*: -mips32r2} \\\n+       |march=34k*|march=74k*|march=m14k*|march=1004k*: -mips32r2} \\\n      %{march=mips64|march=5k*|march=20k*|march=sb1*|march=sr71000 \\\n        |march=xlr|march=loongson3a: -mips64} \\\n      %{march=mips64r2|march=octeon|march=xlp: -mips64r2} \\\n@@ -716,7 +722,7 @@ struct mips_cpu_info {\n   \"%{mhard-float|msoft-float|mno-float|march=mips*:; \\\n      march=vr41*|march=m4k|march=4k*|march=24kc|march=24kec \\\n      |march=34kc|march=34kn|march=74kc|march=1004kc|march=5kc \\\n-     |march=octeon|march=xlr: -msoft-float;\t\t  \\\n+     |march=m14k*|march=octeon|march=xlr: -msoft-float;\t\t  \\\n      march=*: -mhard-float}\"\n \n /* A spec condition that matches 32-bit options.  It only works if\n@@ -989,7 +995,8 @@ struct mips_cpu_info {\n \t\t\t\t     || ISA_MIPS64R2))\n \n /* ISA has lwxs instruction (load w/scaled index address.  */\n-#define ISA_HAS_LWXS\t\t(TARGET_SMARTMIPS && !TARGET_MIPS16)\n+#define ISA_HAS_LWXS\t\t((TARGET_SMARTMIPS || TARGET_MICROMIPS) \\\n+\t\t\t\t && !TARGET_MIPS16)\n \n /* ISA has lbx, lbux, lhx, lhx, lhux, lwx, lwux, or ldx instruction. */\n #define ISA_HAS_LBX\t\t(TARGET_OCTEON2)\n@@ -1012,7 +1019,8 @@ struct mips_cpu_info {\n    and \"addiu $4,$4,1\".  */\n #define ISA_HAS_LOAD_DELAY\t(ISA_MIPS1\t\t\t\t\\\n \t\t\t\t && !TARGET_MIPS3900\t\t\t\\\n-\t\t\t\t && !TARGET_MIPS16)\n+\t\t\t\t && !TARGET_MIPS16\t\t\t\\\n+\t\t\t\t && !TARGET_MICROMIPS)\n \n /* Likewise mtc1 and mfc1.  */\n #define ISA_HAS_XFER_DELAY\t(mips_isa <= 3\t\t\t\\\n@@ -1123,6 +1131,7 @@ struct mips_cpu_info {\n %{G*} %(endian_spec) %{mips1} %{mips2} %{mips3} %{mips4} \\\n %{mips32*} %{mips64*} \\\n %{mips16} %{mno-mips16:-no-mips16} \\\n+%{mmicromips} %{mno-micromips} \\\n %{mips3d} %{mno-mips3d:-no-mips3d} \\\n %{mdmx} %{mno-mdmx:-no-mdmx} \\\n %{mdsp} %{mno-dsp} \\\n@@ -1672,6 +1681,8 @@ struct mips_cpu_info {\n   ((unsigned int) ((int) (REGNO) - GP_REG_FIRST) < GP_REG_NUM)\n #define M16_REG_P(REGNO) \\\n   (((REGNO) >= 2 && (REGNO) <= 7) || (REGNO) == 16 || (REGNO) == 17)\n+#define M16STORE_REG_P(REGNO) \\\n+  (((REGNO) >= 2 && (REGNO) <= 7) || (REGNO) == 0 || (REGNO) == 17)\n #define FP_REG_P(REGNO)  \\\n   ((unsigned int) ((int) (REGNO) - FP_REG_FIRST) < FP_REG_NUM)\n #define MD_REG_P(REGNO) \\\n@@ -2034,6 +2045,7 @@ enum reg_class\n #define SMALL_INT(X) SMALL_OPERAND (INTVAL (X))\n #define SMALL_INT_UNSIGNED(X) SMALL_OPERAND_UNSIGNED (INTVAL (X))\n #define LUI_INT(X) LUI_OPERAND (INTVAL (X))\n+#define UMIPS_12BIT_OFFSET_P(OFFSET) (IN_RANGE (OFFSET, -2048, 2047))\n \n /* The HI and LO registers can only be reloaded via the general\n    registers.  Condition code registers can only be loaded to the\n@@ -2452,17 +2464,32 @@ typedef struct mips_args {\n    all calls should use assembly macros.  Otherwise, all indirect\n    calls should use \"jr\" or \"jalr\"; we will arrange to restore $gp\n    afterwards if necessary.  Finally, we can only generate direct\n-   calls for -mabicalls by temporarily switching to non-PIC mode.  */\n+   calls for -mabicalls by temporarily switching to non-PIC mode.\n+\n+   For microMIPS jal(r), we try to generate jal(r)s when a 16-bit\n+   instruction is in the delay slot of jal(r).  */\n #define MIPS_CALL(INSN, OPERANDS, TARGET_OPNO, SIZE_OPNO)\t\\\n   (TARGET_USE_GOT && !TARGET_EXPLICIT_RELOCS\t\t\t\\\n    ? \"%*\" INSN \"\\t%\" #TARGET_OPNO \"%/\"\t\t\t\t\\\n-   : (REG_P (OPERANDS[TARGET_OPNO])\t\t\t\t\\\n-      && mips_get_pic_call_symbol (OPERANDS, SIZE_OPNO))\t\\\n-   ? (\"%*.reloc\\t1f,R_MIPS_JALR,%\" #SIZE_OPNO \"\\n\"\t\t\\\n-      \"1:\\t\" INSN \"r\\t%\" #TARGET_OPNO \"%/\")\t\t\t\\\n    : REG_P (OPERANDS[TARGET_OPNO])\t\t\t\t\\\n-   ? \"%*\" INSN \"r\\t%\" #TARGET_OPNO \"%/\"\t\t\t\t\\\n+   ? (mips_get_pic_call_symbol (OPERANDS, SIZE_OPNO)\t\t\\\n+      ? (\"%*.reloc\\t1f,R_MIPS_JALR,%\" #SIZE_OPNO \"\\n\"\t\t\\\n+\t \"1:\\t\" INSN \"r\\t%\" #TARGET_OPNO \"%/\")\t\t\t\\\n+      : TARGET_MICROMIPS && !TARGET_INTERLINK_COMPRESSED\t\\\n+      ? \"%*\" INSN \"r%!\\t%\" #TARGET_OPNO \"%/\"\t\t\t\\\n+      : \"%*\" INSN \"r\\t%\" #TARGET_OPNO \"%/\")\t\t\t\\\n    : MIPS_ABSOLUTE_JUMP (\"%*\" INSN \"\\t%\" #TARGET_OPNO \"%/\"))\n+\n+/* Similar to MIPS_CALL, but this is for MICROMIPS \"j\" to generate\n+   \"jrc\" when nop is in the delay slot of \"jr\".  */\n+\n+#define MICROMIPS_J(INSN, OPERANDS, OPNO)\t\t\t\\\n+  (TARGET_USE_GOT && !TARGET_EXPLICIT_RELOCS\t\t\t\\\n+   ? \"%*j\\t%\" #OPNO \"%/\"\t\t\t\t\t\\\n+   : REG_P (OPERANDS[OPNO])\t\t\t\t\t\\\n+   ? \"%*jr%:\\t%\" #OPNO\t\t\t\t\t\t\\\n+   : MIPS_ABSOLUTE_JUMP (\"%*\" INSN \"\\t%\" #OPNO \"%/\"))\n+\n \f\n /* Control the assembler format that we output.  */\n \n@@ -2877,7 +2904,7 @@ extern enum processor mips_tune;        /* which cpu to schedule for */\n extern int mips_isa;\t\t\t/* architectural level */\n extern const struct mips_cpu_info *mips_arch_info;\n extern const struct mips_cpu_info *mips_tune_info;\n-extern bool mips_base_mips16;\n+extern unsigned int mips_base_compression_flags;\n extern GTY(()) struct target_globals *mips16_globals;\n #endif\n "}, {"sha": "d8de3405fa16a3dd1c4d9282df4c3eee0f1cb2fe", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 91, "deletions": 18, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -342,13 +342,14 @@\n ;; syncloop\tmemory atomic operation implemented as a sync loop\n ;; nop\t\tno operation\n ;; ghost\tan instruction that produces no real code\n+;; multimem\tmicroMIPS multiword load and store\n (define_attr \"type\"\n   \"unknown,branch,jump,call,load,fpload,fpidxload,store,fpstore,fpidxstore,\n    prefetch,prefetchx,condmove,mtc,mfc,mthi,mtlo,mfhi,mflo,const,arith,logical,\n    shift,slt,signext,clz,pop,trap,imul,imul3,imul3nc,imadd,idiv,idiv3,move,\n    fmove,fadd,fmul,fmadd,fdiv,frdiv,frdiv1,frdiv2,fabs,fneg,fcmp,fcvt,fsqrt,\n    frsqrt,frsqrt1,frsqrt2,dspmac,dspmacsat,accext,accmod,dspalu,dspalusat,\n-   multi,atomic,syncloop,nop,ghost\"\n+   multi,atomic,syncloop,nop,ghost,multimem\"\n   (cond [(eq_attr \"jal\" \"!unset\") (const_string \"call\")\n \t (eq_attr \"got\" \"load\") (const_string \"load\")\n \n@@ -413,9 +414,15 @@\n \n ;; Length of instruction in bytes.\n (define_attr \"length\" \"\"\n-   (cond [;; Direct branch instructions have a range of [-0x20000,0x1fffc],\n-\t  ;; relative to the address of the delay slot.  If a branch is\n-\t  ;; outside this range, we have a choice of two sequences.\n+   (cond [(and (eq_attr \"extended_mips16\" \"yes\")\n+\t       (match_test \"TARGET_MIPS16\"))\n+\t  (const_int 8)\n+\n+\t  ;; Direct microMIPS branch instructions have a range of\n+\t  ;; [-0x10000,0xfffe], otherwise the range is [-0x20000,0x1fffc].\n+\t  ;; If a branch is outside this range, we have a choice of two\n+\t  ;; sequences.\n+\t  ;;\n \t  ;; For PIC, an out-of-range branch like:\n \t  ;;\n \t  ;;\tbne\tr1,r2,target\n@@ -451,8 +458,15 @@\n \t  ;; from the shorten_branches reference address.\n \t  (and (eq_attr \"type\" \"branch\")\n \t       (not (match_test \"TARGET_MIPS16\")))\n-\t  (cond [(and (le (minus (match_dup 0) (pc)) (const_int 131064))\n-\t\t      (le (minus (pc) (match_dup 0)) (const_int 131068)))\n+\t  (cond [;; Any variant can handle the 17-bit range.\n+\t\t (and (le (minus (match_dup 0) (pc)) (const_int 65532))\n+\t\t      (le (minus (pc) (match_dup 0)) (const_int 65534)))\n+\t\t   (const_int 4)\n+\n+\t\t ;; The 18-bit range is OK other than for microMIPS.\n+\t\t (and (not (match_test \"TARGET_MICROMIPS\"))\n+\t\t      (and (le (minus (match_dup 0) (pc)) (const_int 131064))\n+\t\t      \t   (le (minus (pc) (match_dup 0)) (const_int 131068))))\n \t\t   (const_int 4)\n \n \t\t ;; The non-PIC case: branch, first delay slot, and J.\n@@ -712,6 +726,9 @@\n ;; modes.\n (define_mode_iterator GPR2 [SI (DI \"TARGET_64BIT\")])\n \n+(define_mode_iterator MOVEP1 [SI SF])\n+(define_mode_iterator MOVEP2 [SI SF])\n+\n ;; This mode iterator allows :HILO to be used as the mode of the\n ;; concatenated HI and LO registers.\n (define_mode_iterator HILO [(DI \"!TARGET_64BIT\") (TI \"TARGET_64BIT\")])\n@@ -3937,7 +3954,7 @@\n (define_insn \"mov_<load>l\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n \t(unspec:GPR [(match_operand:BLK 1 \"memory_operand\" \"m\")\n-\t\t     (match_operand:QI 2 \"memory_operand\" \"m\")]\n+\t\t     (match_operand:QI 2 \"memory_operand\" \"ZC\")]\n \t\t    UNSPEC_LOAD_LEFT))]\n   \"!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[1])\"\n   \"<load>l\\t%0,%2\"\n@@ -3947,7 +3964,7 @@\n (define_insn \"mov_<load>r\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n \t(unspec:GPR [(match_operand:BLK 1 \"memory_operand\" \"m\")\n-\t\t     (match_operand:QI 2 \"memory_operand\" \"m\")\n+\t\t     (match_operand:QI 2 \"memory_operand\" \"ZC\")\n \t\t     (match_operand:GPR 3 \"register_operand\" \"0\")]\n \t\t    UNSPEC_LOAD_RIGHT))]\n   \"!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[1])\"\n@@ -3958,7 +3975,7 @@\n (define_insn \"mov_<store>l\"\n   [(set (match_operand:BLK 0 \"memory_operand\" \"=m\")\n \t(unspec:BLK [(match_operand:GPR 1 \"reg_or_0_operand\" \"dJ\")\n-\t\t     (match_operand:QI 2 \"memory_operand\" \"m\")]\n+\t\t     (match_operand:QI 2 \"memory_operand\" \"ZC\")]\n \t\t    UNSPEC_STORE_LEFT))]\n   \"!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[0])\"\n   \"<store>l\\t%z1,%2\"\n@@ -3968,7 +3985,7 @@\n (define_insn \"mov_<store>r\"\n   [(set (match_operand:BLK 0 \"memory_operand\" \"+m\")\n \t(unspec:BLK [(match_operand:GPR 1 \"reg_or_0_operand\" \"dJ\")\n-\t\t     (match_operand:QI 2 \"memory_operand\" \"m\")\n+\t\t     (match_operand:QI 2 \"memory_operand\" \"ZC\")\n \t\t     (match_dup 0)]\n \t\t    UNSPEC_STORE_RIGHT))]\n   \"!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[0])\"\n@@ -5447,6 +5464,14 @@\n \t (pc)))]\n   \"!TARGET_MIPS16\"\n {\n+  /* For a simple BNEZ or BEQZ microMIPS branch.  */\n+  if (TARGET_MICROMIPS\n+      && operands[3] == const0_rtx\n+      && get_attr_length (insn) <= 8)\n+    return mips_output_conditional_branch (insn, operands,\n+\t\t\t\t\t   \"%*b%C1z%:\\t%2,%0\",\n+\t\t\t\t\t   \"%*b%N1z%:\\t%2,%0\");\n+\n   return mips_output_conditional_branch (insn, operands,\n \t\t\t\t\t MIPS_BRANCH (\"b%C1\", \"%2,%z3,%0\"),\n \t\t\t\t\t MIPS_BRANCH (\"b%N1\", \"%2,%z3,%0\"));\n@@ -5463,6 +5488,14 @@\n \t (label_ref (match_operand 0 \"\" \"\"))))]\n   \"!TARGET_MIPS16\"\n {\n+  /* For a simple BNEZ or BEQZ microMIPS branch.  */\n+  if (TARGET_MICROMIPS\n+      && operands[3] == const0_rtx\n+      && get_attr_length (insn) <= 8)\n+    return mips_output_conditional_branch (insn, operands,\n+\t\t\t\t\t   \"%*b%N0z%:\\t%2,%1\",\n+\t\t\t\t\t   \"%*b%C0z%:\\t%2,%1\");\n+\n   return mips_output_conditional_branch (insn, operands,\n \t\t\t\t\t MIPS_BRANCH (\"b%N1\", \"%2,%z3,%0\"),\n \t\t\t\t\t MIPS_BRANCH (\"b%C1\", \"%2,%z3,%0\"));\n@@ -5766,7 +5799,14 @@\n   [(set (pc)\n \t(label_ref (match_operand 0)))]\n   \"!TARGET_MIPS16 && TARGET_ABSOLUTE_JUMPS\"\n-  { return MIPS_ABSOLUTE_JUMP (\"%*j\\t%l0%/\"); }\n+{\n+  /* Use a branch for microMIPS.  The assembler will choose\n+     a 16-bit branch, a 32-bit branch, or a 32-bit jump.  */\n+  if (TARGET_MICROMIPS && !TARGET_ABICALLS_PIC2)\n+    return \"%*b\\t%l0%/\";\n+  else\n+    return MIPS_ABSOLUTE_JUMP (\"%*j\\t%l0%/\");\n+}\n   [(set_attr \"type\" \"jump\")])\n \n (define_insn \"*jump_pic\"\n@@ -5829,7 +5869,12 @@\n (define_insn \"indirect_jump_<mode>\"\n   [(set (pc) (match_operand:P 0 \"register_operand\" \"d\"))]\n   \"\"\n-  \"%*j\\t%0%/\"\n+{\n+  if (TARGET_MICROMIPS)\n+    return \"%*jr%:\\t%0\";\n+  else\n+    return \"%*j\\t%0%/\";\n+}\n   [(set_attr \"type\" \"jump\")\n    (set_attr \"mode\" \"none\")])\n \n@@ -5873,7 +5918,12 @@\n \t(match_operand:P 0 \"register_operand\" \"d\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n-  \"%*j\\t%0%/\"\n+{\n+  if (TARGET_MICROMIPS)\n+    return \"%*jr%:\\t%0\";\n+  else\n+    return \"%*j\\t%0%/\";\n+}\n   [(set_attr \"type\" \"jump\")\n    (set_attr \"mode\" \"none\")])\n \n@@ -6094,7 +6144,12 @@\n   [(any_return)\n    (use (match_operand 0 \"pmode_register_operand\" \"\"))]\n   \"\"\n-  \"%*j\\t%0%/\"\n+{\n+  if (TARGET_MICROMIPS)\n+    return \"%*jr%:\\t%0\";\n+  else\n+    return \"%*j\\t%0%/\";\n+}\n   [(set_attr \"type\"\t\"jump\")\n    (set_attr \"mode\"\t\"none\")])\n \n@@ -6350,7 +6405,12 @@\n   [(call (mem:SI (match_operand 0 \"call_insn_operand\" \"j,S\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"TARGET_SIBCALLS && SIBLING_CALL_P (insn)\"\n-  { return MIPS_CALL (\"j\", operands, 0, 1); }\n+{\n+  if (TARGET_MICROMIPS)\n+    return MICROMIPS_J (\"j\", operands, 0);\n+  else\n+    return MIPS_CALL (\"j\", operands, 0, 1);\n+}\n   [(set_attr \"jal\" \"indirect,direct\")\n    (set_attr \"jal_macro\" \"no\")])\n \n@@ -6371,7 +6431,12 @@\n         (call (mem:SI (match_operand 1 \"call_insn_operand\" \"j,S\"))\n               (match_operand 2 \"\" \"\")))]\n   \"TARGET_SIBCALLS && SIBLING_CALL_P (insn)\"\n-  { return MIPS_CALL (\"j\", operands, 1, 2); }\n+{\n+  if (TARGET_MICROMIPS)\n+    return MICROMIPS_J (\"j\", operands, 1);\n+  else\n+    return MIPS_CALL (\"j\", operands, 1, 2);\n+}\n   [(set_attr \"jal\" \"indirect,direct\")\n    (set_attr \"jal_macro\" \"no\")])\n \n@@ -6383,7 +6448,12 @@\n \t(call (mem:SI (match_dup 1))\n \t      (match_dup 2)))]\n   \"TARGET_SIBCALLS && SIBLING_CALL_P (insn)\"\n-  { return MIPS_CALL (\"j\", operands, 1, 2); }\n+{\n+  if (TARGET_MICROMIPS)\n+    return MICROMIPS_J (\"j\", operands, 1);\n+  else\n+    return MIPS_CALL (\"j\", operands, 1, 2);\n+}\n   [(set_attr \"jal\" \"indirect,direct\")\n    (set_attr \"jal_macro\" \"no\")])\n \n@@ -6629,7 +6699,7 @@\n \n \n (define_insn \"prefetch\"\n-  [(prefetch (match_operand:QI 0 \"address_operand\" \"p\")\n+  [(prefetch (match_operand:QI 0 \"address_operand\" \"ZD\")\n \t     (match_operand 1 \"const_int_operand\" \"n\")\n \t     (match_operand 2 \"const_int_operand\" \"n\"))]\n   \"ISA_HAS_PREFETCH && TARGET_EXPLICIT_RELOCS\"\n@@ -6922,6 +6992,9 @@\n ; MIPS fixed-point instructions.\n (include \"mips-fixed.md\")\n \n+; microMIPS patterns.\n+(include \"micromips.md\")\n+\n ; ST-Microelectronics Loongson-2E/2F-specific patterns.\n (include \"loongson.md\")\n "}, {"sha": "f9e88b3cd72451647382e508e3c06daf3b421c5c", "filename": "gcc/config/mips/mips.opt", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmips.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fmips.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.opt?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -217,9 +217,13 @@ mhard-float\n Target Report RejectNegative InverseMask(SOFT_FLOAT_ABI, HARD_FLOAT_ABI)\n Allow the use of hardware floating-point ABI and instructions\n \n+minterlink-compressed\n+Target Report Var(TARGET_INTERLINK_COMPRESSED) Init(0)\n+Generate code that is link-compatible with MIPS16 and microMIPS code.\n+\n minterlink-mips16\n-Target Report Var(TARGET_INTERLINK_MIPS16) Init(0)\n-Generate code that can be safely linked with MIPS16 code.\n+Target Report Var(TARGET_INTERLINK_COMPRESSED) Init(0)\n+An alias for minterlink-compressed provided for backward-compatibility.\n \n mips\n Target RejectNegative Joined ToLower Enum(mips_mips_opt_value) Var(mips_isa_option)\n@@ -261,6 +265,10 @@ mmemcpy\n Target Report Mask(MEMCPY)\n Don't optimize block moves\n \n+mmicromips\n+Target Report Mask(MICROMIPS)\n+Use microMIPS instructions\n+\n mmt\n Target Report Var(TARGET_MT)\n Allow the use of MT instructions"}, {"sha": "c6d7707093ee3e70cb4763cd6d1179113f35ba6a", "filename": "gcc/config/mips/predicates.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fpredicates.md?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -122,6 +122,15 @@\n \t\t    ? M16_REG_P (REGNO (op))\n \t\t    : GP_REG_P (REGNO (op))\")))\n \n+(define_predicate \"movep_src_register\"\n+  (and (match_code \"reg\")\n+       (ior (match_test (\"IN_RANGE (REGNO (op), 2, 3)\"))\n+\t    (match_test (\"IN_RANGE (REGNO (op), 16, 20)\")))))\n+\n+(define_predicate \"movep_src_operand\"\n+  (ior (match_operand 0 \"const_0_operand\")\n+       (match_operand 0 \"movep_src_register\")))\n+\n (define_predicate \"lo_operand\"\n   (and (match_code \"reg\")\n        (match_test \"REGNO (op) == LO_REGNUM\")))\n@@ -371,3 +380,8 @@\n (define_predicate \"mem_noofs_operand\"\n   (and (match_code \"mem\")\n        (match_code \"reg\" \"0\")))\n+\n+;; Return 1 if the operand is in non-volatile memory.\n+(define_predicate \"non_volatile_mem_operand\"\n+  (and (match_operand 0 \"memory_operand\")\n+       (not (match_test \"MEM_VOLATILE_P (op)\"))))"}, {"sha": "d40c2246bb1191babcbb62e82e870e4279177d8b", "filename": "gcc/config/mips/sync.md", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsync.md?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -59,7 +59,7 @@\n ;; Can be removed in favor of atomic_compare_and_swap below.\n (define_insn \"sync_compare_and_swap<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n-\t(match_operand:GPR 1 \"memory_operand\" \"+R,R\"))\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZR,ZR\"))\n    (set (match_dup 1)\n \t(unspec_volatile:GPR [(match_operand:GPR 2 \"reg_or_0_operand\" \"dJ,dJ\")\n \t\t\t      (match_operand:GPR 3 \"arith_operand\" \"I,d\")]\n@@ -89,7 +89,7 @@\n ;; Helper insn for mips_expand_atomic_qihi.\n (define_insn \"compare_and_swap_12\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&d,&d\")\n-\t(match_operand:SI 1 \"memory_operand\" \"+R,R\"))\n+\t(match_operand:SI 1 \"memory_operand\" \"+ZR,ZR\"))\n    (set (match_dup 1)\n \t(unspec_volatile:SI [(match_operand:SI 2 \"register_operand\" \"d,d\")\n \t\t\t     (match_operand:SI 3 \"register_operand\" \"d,d\")\n@@ -106,7 +106,7 @@\n    (set_attr \"sync_insn1_op2\" \"5\")])\n \n (define_insn \"sync_add<mode>\"\n-  [(set (match_operand:GPR 0 \"memory_operand\" \"+R,R\")\n+  [(set (match_operand:GPR 0 \"memory_operand\" \"+ZR,ZR\")\n \t(unspec_volatile:GPR\n           [(plus:GPR (match_dup 0)\n \t\t     (match_operand:GPR 1 \"arith_operand\" \"I,d\"))]\n@@ -134,7 +134,7 @@\n \n ;; Helper insn for sync_<optab><mode>\n (define_insn \"sync_<optab>_12\"\n-  [(set (match_operand:SI 0 \"memory_operand\" \"+R\")\n+  [(set (match_operand:SI 0 \"memory_operand\" \"+ZR\")\n \t(unspec_volatile:SI\n           [(match_operand:SI 1 \"register_operand\" \"d\")\n \t   (match_operand:SI 2 \"register_operand\" \"d\")\n@@ -174,7 +174,7 @@\n ;; Helper insn for sync_old_<optab><mode>\n (define_insn \"sync_old_<optab>_12\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n-\t(match_operand:SI 1 \"memory_operand\" \"+R\"))\n+\t(match_operand:SI 1 \"memory_operand\" \"+ZR\"))\n    (set (match_dup 1)\n \t(unspec_volatile:SI\n           [(match_operand:SI 2 \"register_operand\" \"d\")\n@@ -217,7 +217,7 @@\n (define_insn \"sync_new_<optab>_12\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n \t(unspec_volatile:SI\n-          [(match_operand:SI 1 \"memory_operand\" \"+R\")\n+          [(match_operand:SI 1 \"memory_operand\" \"+ZR\")\n \t   (match_operand:SI 2 \"register_operand\" \"d\")\n \t   (match_operand:SI 3 \"register_operand\" \"d\")\n \t   (atomic_hiqi_op:SI (match_dup 0)\n@@ -257,7 +257,7 @@\n \n ;; Helper insn for sync_nand<mode>\n (define_insn \"sync_nand_12\"\n-  [(set (match_operand:SI 0 \"memory_operand\" \"+R\")\n+  [(set (match_operand:SI 0 \"memory_operand\" \"+ZR\")\n \t(unspec_volatile:SI\n           [(match_operand:SI 1 \"register_operand\" \"d\")\n \t   (match_operand:SI 2 \"register_operand\" \"d\")\n@@ -296,7 +296,7 @@\n ;; Helper insn for sync_old_nand<mode>\n (define_insn \"sync_old_nand_12\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n-\t(match_operand:SI 1 \"memory_operand\" \"+R\"))\n+\t(match_operand:SI 1 \"memory_operand\" \"+ZR\"))\n    (set (match_dup 1)\n \t(unspec_volatile:SI\n           [(match_operand:SI 2 \"register_operand\" \"d\")\n@@ -337,7 +337,7 @@\n (define_insn \"sync_new_nand_12\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n \t(unspec_volatile:SI\n-          [(match_operand:SI 1 \"memory_operand\" \"+R\")\n+          [(match_operand:SI 1 \"memory_operand\" \"+ZR\")\n \t   (match_operand:SI 2 \"register_operand\" \"d\")\n \t   (match_operand:SI 3 \"register_operand\" \"d\")\n \t   (match_operand:SI 4 \"reg_or_0_operand\" \"dJ\")]\n@@ -360,7 +360,7 @@\n    (set_attr \"sync_insn1_op2\" \"4\")])\n \n (define_insn \"sync_sub<mode>\"\n-  [(set (match_operand:GPR 0 \"memory_operand\" \"+R\")\n+  [(set (match_operand:GPR 0 \"memory_operand\" \"+ZR\")\n \t(unspec_volatile:GPR\n           [(minus:GPR (match_dup 0)\n \t\t      (match_operand:GPR 1 \"register_operand\" \"d\"))]\n@@ -374,7 +374,7 @@\n ;; Can be removed in favor of atomic_fetch_add below.\n (define_insn \"sync_old_add<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n-\t(match_operand:GPR 1 \"memory_operand\" \"+R,R\"))\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZR,ZR\"))\n    (set (match_dup 1)\n \t(unspec_volatile:GPR\n           [(plus:GPR (match_dup 1)\n@@ -389,7 +389,7 @@\n \n (define_insn \"sync_old_sub<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d\")\n-\t(match_operand:GPR 1 \"memory_operand\" \"+R\"))\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZR\"))\n    (set (match_dup 1)\n \t(unspec_volatile:GPR\n           [(minus:GPR (match_dup 1)\n@@ -404,7 +404,7 @@\n \n (define_insn \"sync_new_add<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n-        (plus:GPR (match_operand:GPR 1 \"memory_operand\" \"+R,R\")\n+        (plus:GPR (match_operand:GPR 1 \"memory_operand\" \"+ZR,ZR\")\n \t\t  (match_operand:GPR 2 \"arith_operand\" \"I,d\")))\n    (set (match_dup 1)\n \t(unspec_volatile:GPR\n@@ -420,7 +420,7 @@\n \n (define_insn \"sync_new_sub<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d\")\n-        (minus:GPR (match_operand:GPR 1 \"memory_operand\" \"+R\")\n+        (minus:GPR (match_operand:GPR 1 \"memory_operand\" \"+ZR\")\n \t\t   (match_operand:GPR 2 \"register_operand\" \"d\")))\n    (set (match_dup 1)\n \t(unspec_volatile:GPR\n@@ -435,7 +435,7 @@\n    (set_attr \"sync_insn1_op2\" \"2\")])\n \n (define_insn \"sync_<optab><mode>\"\n-  [(set (match_operand:GPR 0 \"memory_operand\" \"+R,R\")\n+  [(set (match_operand:GPR 0 \"memory_operand\" \"+ZR,ZR\")\n \t(unspec_volatile:GPR\n           [(fetchop_bit:GPR (match_operand:GPR 1 \"uns_arith_operand\" \"K,d\")\n \t\t\t      (match_dup 0))]\n@@ -448,7 +448,7 @@\n \n (define_insn \"sync_old_<optab><mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n-\t(match_operand:GPR 1 \"memory_operand\" \"+R,R\"))\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZR,ZR\"))\n    (set (match_dup 1)\n \t(unspec_volatile:GPR\n           [(fetchop_bit:GPR (match_operand:GPR 2 \"uns_arith_operand\" \"K,d\")\n@@ -463,7 +463,7 @@\n \n (define_insn \"sync_new_<optab><mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n-\t(match_operand:GPR 1 \"memory_operand\" \"+R,R\"))\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZR,ZR\"))\n    (set (match_dup 1)\n \t(unspec_volatile:GPR\n           [(fetchop_bit:GPR (match_operand:GPR 2 \"uns_arith_operand\" \"K,d\")\n@@ -478,7 +478,7 @@\n    (set_attr \"sync_insn1_op2\" \"2\")])\n \n (define_insn \"sync_nand<mode>\"\n-  [(set (match_operand:GPR 0 \"memory_operand\" \"+R,R\")\n+  [(set (match_operand:GPR 0 \"memory_operand\" \"+ZR,ZR\")\n \t(unspec_volatile:GPR [(match_operand:GPR 1 \"uns_arith_operand\" \"K,d\")]\n \t UNSPEC_SYNC_OLD_OP))]\n   \"GENERATE_LL_SC\"\n@@ -490,7 +490,7 @@\n \n (define_insn \"sync_old_nand<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n-\t(match_operand:GPR 1 \"memory_operand\" \"+R,R\"))\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZR,ZR\"))\n    (set (match_dup 1)\n         (unspec_volatile:GPR [(match_operand:GPR 2 \"uns_arith_operand\" \"K,d\")]\n \t UNSPEC_SYNC_OLD_OP))]\n@@ -504,7 +504,7 @@\n \n (define_insn \"sync_new_nand<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n-\t(match_operand:GPR 1 \"memory_operand\" \"+R,R\"))\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZR,ZR\"))\n    (set (match_dup 1)\n \t(unspec_volatile:GPR [(match_operand:GPR 2 \"uns_arith_operand\" \"K,d\")]\n \t UNSPEC_SYNC_NEW_OP))]\n@@ -519,7 +519,7 @@\n \n (define_insn \"sync_lock_test_and_set<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n-\t(match_operand:GPR 1 \"memory_operand\" \"+R,R\"))\n+\t(match_operand:GPR 1 \"memory_operand\" \"+ZR,ZR\"))\n    (set (match_dup 1)\n \t(unspec_volatile:GPR [(match_operand:GPR 2 \"arith_operand\" \"I,d\")]\n \t UNSPEC_SYNC_EXCHANGE))]\n@@ -546,7 +546,7 @@\n \n (define_insn \"test_and_set_12\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n-\t(match_operand:SI 1 \"memory_operand\" \"+R\"))\n+\t(match_operand:SI 1 \"memory_operand\" \"+ZR\"))\n    (set (match_dup 1)\n \t(unspec_volatile:SI [(match_operand:SI 2 \"register_operand\" \"d\")\n \t\t\t     (match_operand:SI 3 \"register_operand\" \"d\")\n@@ -576,7 +576,7 @@\n \t;; TODO: the obscuring unspec can be relaxed for permissive memory\n \t;; models.\n \t;; Same applies to other atomic_* patterns.\n-\t(unspec_volatile:GPR [(match_operand:GPR 2 \"memory_operand\" \"+R,R\")\n+\t(unspec_volatile:GPR [(match_operand:GPR 2 \"memory_operand\" \"+ZR,ZR\")\n \t\t\t      (match_operand:GPR 3 \"reg_or_0_operand\" \"dJ,dJ\")]\n \t UNSPEC_ATOMIC_COMPARE_AND_SWAP))\n    (set (match_operand:GPR 1 \"register_operand\" \"=&d,&d\")\n@@ -629,7 +629,7 @@\n \n (define_insn \"atomic_exchange<mode>_llsc\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n-\t(unspec_volatile:GPR [(match_operand:GPR 1 \"memory_operand\" \"+R,R\")]\n+\t(unspec_volatile:GPR [(match_operand:GPR 1 \"memory_operand\" \"+ZR,ZR\")]\n \t UNSPEC_ATOMIC_EXCHANGE))\n    (set (match_dup 1)\n \t(unspec_volatile:GPR [(match_operand:GPR 2 \"arith_operand\" \"I,d\")]\n@@ -684,7 +684,7 @@\n \n (define_insn \"atomic_fetch_add<mode>_llsc\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n-\t(unspec_volatile:GPR [(match_operand:GPR 1 \"memory_operand\" \"+R,R\")]\n+\t(unspec_volatile:GPR [(match_operand:GPR 1 \"memory_operand\" \"+ZR,ZR\")]\n \t UNSPEC_ATOMIC_FETCH_OP))\n    (set (match_dup 1)\n \t(unspec_volatile:GPR"}, {"sha": "15f506f8afe970753baa0c8aa3f919c545a137bd", "filename": "gcc/config/mips/t-sde", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Ft-sde", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfig%2Fmips%2Ft-sde", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-sde?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -16,8 +16,8 @@\n # along with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.\n \n-MULTILIB_OPTIONS = EL/EB mips32/mips32r2/mips64/mips64r2 mips16 msoft-float/mfp64 mcode-readable=no\n-MULTILIB_DIRNAMES = el eb mips32 mips32r2 mips64 mips64r2 mips16 sof f64 spram\n+MULTILIB_OPTIONS = EL/EB mips32/mips32r2/mips64/mips64r2 mips16/mmicromips msoft-float/mfp64 mcode-readable=no\n+MULTILIB_DIRNAMES = el eb mips32 mips32r2 mips64 mips64r2 mips16 micromips sof f64 spram\n MULTILIB_MATCHES = EL=mel EB=meb\n \n # The -mfp64 option is only valid in conjunction with -mips32r2."}, {"sha": "e0f323013c687e16f25cd686408a355137b4a3b3", "filename": "gcc/configure", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -25718,6 +25718,37 @@ if test $gcc_cv_as_mips_gnu_attribute = yes; then\n \n $as_echo \"#define HAVE_AS_GNU_ATTRIBUTE 1\" >>confdefs.h\n \n+fi\n+\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for .micromips support\" >&5\n+$as_echo_n \"checking assembler for .micromips support... \" >&6; }\n+if test \"${gcc_cv_as_micromips_support+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_as_micromips_support=no\n+  if test x$gcc_cv_as != x; then\n+    $as_echo '.set micromips' > conftest.s\n+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    then\n+\tgcc_cv_as_micromips_support=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_micromips_support\" >&5\n+$as_echo \"$gcc_cv_as_micromips_support\" >&6; }\n+if test $gcc_cv_as_micromips_support = yes; then\n+\n+$as_echo \"#define HAVE_GAS_MICROMIPS 1\" >>confdefs.h\n+\n fi\n \n     { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for .dtprelword support\" >&5"}, {"sha": "f783b61510dfaadc2d7ff9ac4d723a40f560f47d", "filename": "gcc/configure.ac", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -4048,6 +4048,12 @@ LCF0:\n       [AC_DEFINE(HAVE_AS_GNU_ATTRIBUTE, 1,\n \t  [Define if your assembler supports .gnu_attribute.])])\n \n+    gcc_GAS_CHECK_FEATURE([.micromips support],\n+      gcc_cv_as_micromips_support,,,\n+      [.set micromips],,\n+      [AC_DEFINE(HAVE_GAS_MICROMIPS, 1,\n+          [Define if your assembler supports the .set micromips directive])])\n+\n     gcc_GAS_CHECK_FEATURE([.dtprelword support],\n       gcc_cv_as_mips_dtprelword, [2,18,0],,\n       [.section .tdata,\"awT\",@progbits"}, {"sha": "80628a3cb909b8a977d1206c066854cd8fb9569d", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -3055,6 +3055,25 @@ not that within individual functions.  Mixed MIPS16 and non-MIPS16 code\n may interact badly with some GCC extensions such as @code{__builtin_apply}\n (@pxref{Constructing Calls}).\n \n+@item micromips/nomicromips\n+@cindex @code{micromips} attribute\n+@cindex @code{nomicromips} attribute\n+\n+On MIPS targets, you can use the @code{micromips} and @code{nomicromips}\n+function attributes to locally select or turn off microMIPS code generation.\n+A function with the @code{micromips} attribute is emitted as microMIPS code,\n+while microMIPS code generation is disabled for functions with the\n+@code{nomicromips} attribute.  These attributes override the\n+@option{-mmicromips} and @option{-mno-micromips} options on the command line\n+(@pxref{MIPS Options}).\n+\n+When compiling files containing mixed microMIPS and non-microMIPS code, the\n+preprocessor symbol @code{__mips_micromips} reflects the setting on the\n+command line,\n+not that within individual functions.  Mixed microMIPS and non-microMIPS code\n+may interact badly with some GCC extensions such as @code{__builtin_apply}\n+(@pxref{Constructing Calls}).\n+\n @item model (@var{model-name})\n @cindex function addressability on the M32R/D\n @cindex variable addressability on the IA-64\n@@ -3157,6 +3176,13 @@ is an NMI handler.  The compiler generates function entry and\n exit sequences suitable for use in an NMI handler when this\n attribute is present.\n \n+@item nocompression\n+@cindex @code{nocompression} attribute\n+On MIPS targets, you can use the @code{nocompression} function attribute\n+to locally turn off MIPS16 and microMIPS code generation.  This attribute\n+overrides the @option{-mips16} and @option{-mmicromips} options on the\n+command line (@pxref{MIPS Options}).\n+\n @item no_instrument_function\n @cindex @code{no_instrument_function} function attribute\n @opindex finstrument-functions"}, {"sha": "6cf142f81b061bd81d61a92a5d49e09133ef0b13", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -741,13 +741,15 @@ Objective-C and Objective-C++ Dialects}.\n -mips1  -mips2  -mips3  -mips4  -mips32  -mips32r2 @gol\n -mips64  -mips64r2 @gol\n -mips16  -mno-mips16  -mflip-mips16 @gol\n+-minterlink-compressed -mno-interlink-compressed @gol\n -minterlink-mips16  -mno-interlink-mips16 @gol\n -mabi=@var{abi}  -mabicalls  -mno-abicalls @gol\n -mshared  -mno-shared  -mplt  -mno-plt  -mxgot  -mno-xgot @gol\n -mgp32  -mgp64  -mfp32  -mfp64  -mhard-float  -msoft-float @gol\n -mno-float -msingle-float  -mdouble-float  @gol\n -mdsp  -mno-dsp  -mdspr2  -mno-dspr2 @gol\n -mmcu -mmno-mcu @gol\n+-mmicromips -mno-micromips @gol\n -mfpu=@var{fpu-type} @gol\n -msmartmips  -mno-smartmips @gol\n -mpaired-single  -mno-paired-single  -mdmx  -mno-mdmx @gol\n@@ -15902,6 +15904,7 @@ The processor names are:\n @samp{1004kc}, @samp{1004kf2_1}, @samp{1004kf1_1},\n @samp{loongson2e}, @samp{loongson2f}, @samp{loongson3a},\n @samp{m4k},\n+@samp{m14k}, @samp{m14ke}, @samp{m14kec},\n @samp{octeon}, @samp{octeon+}, @samp{octeon2},\n @samp{orion},\n @samp{r2000}, @samp{r3000}, @samp{r3900}, @samp{r4000}, @samp{r4400},\n@@ -16015,17 +16018,25 @@ Generate MIPS16 code on alternating functions.  This option is provided\n for regression testing of mixed MIPS16/non-MIPS16 code generation, and is\n not intended for ordinary use in compiling user code.\n \n+@item -minterlink-compressed\n+@item -mno-interlink-compressed\n+@opindex minterlink-compressed\n+@opindex mno-interlink-compressed\n+Require (do not require) that code using the standard (uncompressed) MIPS ISA\n+be link-compatible with MIPS16 and microMIPS code, and vice versa.\n+\n+For example, code using the standard ISA encoding cannot jump directly\n+to MIPS16 or microMIPS code; it must either use a call or an indirect jump.\n+@option{-minterlink-compressed} therefore disables direct jumps unless GCC\n+knows that the target of the jump is not compressed.\n+\n @item -minterlink-mips16\n @itemx -mno-interlink-mips16\n @opindex minterlink-mips16\n @opindex mno-interlink-mips16\n-Require (do not require) that non-MIPS16 code be link-compatible with\n-MIPS16 code.\n-\n-For example, non-MIPS16 code cannot jump directly to MIPS16 code;\n-it must either use a call or an indirect jump.  @option{-minterlink-mips16}\n-therefore disables direct jumps unless GCC knows that the target of the\n-jump is not MIPS16.\n+Aliases of @option{-minterlink-compressed} and\n+@option{-mno-interlink-compressed}.  These options predate the microMIPS ASE\n+and are retained for backwards compatiblity.\n \n @item -mabi=32\n @itemx -mabi=o64\n@@ -16240,6 +16251,16 @@ hardware floating-point support to be enabled.\n Use (do not use) the MIPS-3D ASE@.  @xref{MIPS-3D Built-in Functions}.\n The option @option{-mips3d} implies @option{-mpaired-single}.\n \n+@item -mmicromips\n+@itemx -mno-micromips\n+@opindex mmicromips\n+@opindex mno-mmicromips\n+Generate (do not generate) microMIPS code.\n+\n+MicroMIPS code generation can also be controlled on a per-function basis\n+by means of @code{micromips} and @code{nomicromips} attributes.\n+@xref{Function Attributes}, for more information.\n+\n @item -mmt\n @itemx -mno-mt\n @opindex mmt"}, {"sha": "b84a2028d645ade6fe5857e4e1f8ed18b709f820", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -2916,6 +2916,19 @@ Floating-point zero.\n \n @item R\n An address that can be used in a non-macro load or store.\n+\n+@item ZC\n+When compiling microMIPS code, this constraint matches a memory operand\n+whose address is formed from a base register and a 12-bit offset.  These\n+operands can be used for microMIPS instructions such as @code{ll} and\n+@code{sc}.  When not compiling for microMIPS code, @code{ZC} is\n+equivalent to @code{R}.\n+\n+@item ZD\n+When compiling microMIPS code, this constraint matches an address operand\n+that is formed from a base register and a 12-bit offset.  These operands\n+can be used for microMIPS instructions such as @code{prefetch}.  When\n+not compiling for microMIPS code, @code{ZD} is equivalent to @code{p}.\n @end table\n \n @item Motorola 680x0---@file{config/m68k/constraints.md}"}, {"sha": "a3f78a77d011f82df98c46e7e1c891c31823500a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -1,3 +1,31 @@\n+2013-03-20  Catherine Moore  <clm@codesourcery.com>\n+\t    Richard Sandiford <rdsandiford@googlemail.com>\n+\n+\t* gcc.target/mips/mips.exp: Add microMIPS support.\n+\t* gcc.target/mips/umips-movep-2.c: New test.\n+\t* gcc.target/mips/umips-lwp-2.c: New test.\n+\t* gcc.target/mips/umips-swp-5.c: New test.\n+\t* gcc.target/mips/umips-constraints-1.c: New test.\n+\t* gcc.target/mips/umips-lwp-3.c: New test.\n+\t* gcc.target/mips/umips-swp-6.c: New test.\n+\t* gcc.target/mips/umips-constraints-2.c: New test.\n+\t* gcc.target/mips/umips-save-restore-1.c: New test.\n+\t* gcc.target/mips/umips-lwp-4.c: New test.\n+\t* gcc.target/mips/umips-swp-7.c: New test.\n+\t* gcc.target/mips/umips-save-restore-2.c: New test.\n+\t* gcc.target/mips/umips-lwp-swp-volatile.c: New test.\n+\t* gcc.target/mips/umips-lwp-5.c: New test.\n+\t* gcc.target/mips/umips-save-restore-3.c: New test.\n+\t* gcc.target/mips/umips-lwp-6.c: New test.\n+\t* gcc.target/mips/umips-swp-1.c: New test.\n+\t* gcc.target/mips/umips-lwp-7.c: New test.\n+\t* gcc.target/mips/umips-swp-2.c: New test.\n+\t* gcc.target/mips/umips-lwp-8.c: New test.\n+\t* gcc.target/mips/umips-swp-3.c: New test.\n+\t* gcc.target/mips/umips-movep-1.c: New test.\n+\t* gcc.target/mips/umips-lwp-1.c: New test.\n+\t* gcc.target/mips/umips-swp-4.c: New test.\n+\n 2013-03-20  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/56661"}, {"sha": "15b1386bd9e19a06bb2814a3d8f73c6e9a003862", "filename": "gcc/testsuite/gcc.target/mips/mips.exp", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -238,6 +238,7 @@ set mips_option_groups {\n     fp \"-mfp(32|64)\"\n     gp \"-mgp(32|64)\"\n     long \"-mlong(32|64)\"\n+    micromips \"-mmicromips|-mno-micromips\"\n     mips16 \"-mips16|-mno-mips16|-mflip-mips16\"\n     mips3d \"-mips3d|-mno-mips3d\"\n     pic \"-f(no-|)(pic|PIC)\"\n@@ -816,6 +817,8 @@ proc mips-dg-finish {} {\n #            |                           |\n #         -mips16/-mflip-mips16       -mno-mips16\n #            |                           |\n+#         -micromips                  -mno-micromips\n+#            |                           |\n #         -mips3d                     -mno-mips3d\n #            |                           |\n #         -mpaired-single             -mno-paired-single\n@@ -904,6 +907,8 @@ proc mips-dg-options { args } {\n \n     # Handle dependencies between options on the left of the\n     # dependency diagram.\n+    mips_option_dependency options \"-mips16\" \"-mno-micromips\"\n+    mips_option_dependency options \"-mmicromips\" \"-mno-mips16\"\n     mips_option_dependency options \"-mips3d\" \"-mpaired-single\"\n     mips_option_dependency options \"-mpaired-single\" \"-mfp64\"\n     mips_option_dependency options \"-mfp64\" \"-mhard-float\"\n@@ -1246,6 +1251,10 @@ proc mips-dg-options { args } {\n \tappend extra_tool_flags \" -DMIPS16=__attribute__((mips16))\"\n     }\n \n+    if { [mips_have_test_option_p options \"-mmicromips\"] } {\n+\tappend extra_tool_flags \" -DMICROMIPS=__attribute__((micromips))\"\n+    }\n+\n     # Use our version of gcc-dg-test for this test.\n     if { ![string equal [info procs \"mips-gcc-dg-test\"] \"\"] } {\n \trename gcc-dg-test mips-old-gcc-dg-test\n@@ -1275,6 +1284,6 @@ proc mips-gcc-dg-test { prog do_what extra_tool_flags } {\n dg-init\n mips-dg-init\n gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.c]] \\\n-    \"-DNOMIPS16=__attribute__((nomips16))\"\n+    \"-DNOMIPS16=__attribute__((nomips16)) -DNOMICROMIPS=__attribute__((nomicromips)) -DNOCOMPRESSION=__attribute__((nocompression))\"\n mips-dg-finish\n dg-finish"}, {"sha": "ddec815b0f351cfcf2747c62923270c00e50063c", "filename": "gcc/testsuite/gcc.target/mips/umips-constraints-1.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-constraints-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-constraints-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-constraints-1.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-options \"(-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+MICROMIPS void\n+foo (int *x)\n+{\n+  asm volatile (\"insn1\\t%a0\" :: \"ZD\" (&x[0]));\n+  asm volatile (\"insn2\\t%a0\" :: \"ZD\" (&x[511]));\n+  asm volatile (\"insn3\\t%a0\" :: \"ZD\" (&x[512]));\n+}\n+\n+/* { dg-final { scan-assembler \"\\tinsn1\\t0\\\\(\" } } */\n+/* { dg-final { scan-assembler \"\\tinsn2\\t2044\\\\(\" } } */\n+/* { dg-final { scan-assembler-not \"\\tinsn3\\t2048\\\\(\" } } */"}, {"sha": "0240d46702685bc4ef7a54bc9f93fd8e4a1c2bbe", "filename": "gcc/testsuite/gcc.target/mips/umips-constraints-2.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-constraints-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-constraints-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-constraints-2.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-options \"(-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+MICROMIPS void\n+foo (int *x)\n+{\n+  asm volatile (\"insn1\\t%0\" :: \"ZC\" (x[0]));\n+  asm volatile (\"insn2\\t%0\" :: \"ZC\" (x[511]));\n+  asm volatile (\"insn3\\t%0\" :: \"ZC\" (x[512]));\n+}\n+\n+/* { dg-final { scan-assembler \"\\tinsn1\\t0\\\\(\" } } */\n+/* { dg-final { scan-assembler \"\\tinsn2\\t2044\\\\(\" } } */\n+/* { dg-final { scan-assembler-not \"\\tinsn3\\t2048\\\\(\" } } */"}, {"sha": "0cdb1b7f2bce67b69d5c5ab37799507cde668646", "filename": "gcc/testsuite/gcc.target/mips/umips-lwp-1.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-1.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-mgp32 -fpeephole2 -mtune=m14k (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void MICROMIPS\n+foo (int *r4)\n+{\n+  int r5 = r4[0];\n+  int r6 = r4[1];\n+  r4[2] = r5 * r5;\n+  {\n+    register int r5asm asm (\"$5\") = r5;\n+    register int r6asm asm (\"$6\") = r6;\n+    asm (\"#foo\" : \"=m\" (r4[3]) : \"d\" (r5asm), \"d\" (r6asm));\n+  }\n+}\n+\n+/* { dg-final { scan-assembler \"\\tlwp\\t\\\\\\$5,0\\\\(\\\\\\$4\\\\)\" } }*/"}, {"sha": "ea3f3960742242963ee70258411da9284e35dedc", "filename": "gcc/testsuite/gcc.target/mips/umips-lwp-2.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-2.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-mgp32 -fpeephole2 -mtune=m14k (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void MICROMIPS\n+foo (int *r4)\n+{\n+  int r5 = r4[0];\n+  int r6 = r4[1];\n+  r4[2] = r6 * r6;\n+  {\n+    register int r5asm asm (\"$5\") = r5;\n+    register int r6asm asm (\"$6\") = r6;\n+    asm (\"#foo\" : \"=m\" (r4[3]) : \"d\" (r5asm), \"d\" (r6asm));\n+  }\n+}\n+\n+/* { dg-final { scan-assembler \"\\tlwp\\t\\\\\\$5,0\\\\(\\\\\\$4\\\\)\" } }*/"}, {"sha": "2cb37510feb19bf75c4f1f4db4ce95ad3f51caa2", "filename": "gcc/testsuite/gcc.target/mips/umips-lwp-3.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-3.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-mgp32 -fpeephole2 -mtune=m14k (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void MICROMIPS\n+foo (int *r4)\n+{\n+  int r5 = r4[511];\n+  int r6 = r4[512];\n+  r4[2] = r5 * r5;\n+  {\n+    register int r5asm asm (\"$5\") = r5;\n+    register int r6asm asm (\"$6\") = r6;\n+    asm (\"#foo\" : \"=m\" (r4[3]) : \"d\" (r5asm), \"d\" (r6asm));\n+  }\n+}\n+\n+/* { dg-final { scan-assembler \"\\tlwp\\t\\\\\\$5,2044\\\\(\\\\\\$4\\\\)\" } }*/"}, {"sha": "b8a86b4ed900a0dc60a95b0496fc8bea528abfc9", "filename": "gcc/testsuite/gcc.target/mips/umips-lwp-4.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-4.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-mgp32 -fpeephole2 -mtune=m14k (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void MICROMIPS\n+foo (int *r4)\n+{\n+  int r5 = r4[511];\n+  int r6 = r4[512];\n+  r4[2] = r6 * r6;\n+  {\n+    register int r5asm asm (\"$5\") = r5;\n+    register int r6asm asm (\"$6\") = r6;\n+    asm (\"#foo\" : \"=m\" (r4[3]) : \"d\" (r5asm), \"d\" (r6asm));\n+  }\n+}\n+\n+/* { dg-final { scan-assembler \"\\tlwp\\t\\\\\\$5,2044\\\\(\\\\\\$4\\\\)\" } }*/"}, {"sha": "2315f21e91e168322a4e8930e6bf80a5ff8d771e", "filename": "gcc/testsuite/gcc.target/mips/umips-lwp-5.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-5.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-mgp32 -fpeephole2 -mtune=m14k (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void MICROMIPS\n+foo (int *r4)\n+{\n+  int r5 = r4[512];\n+  int r6 = r4[513];\n+  r4[2] = r5 * r5;\n+  {\n+    register int r5asm asm (\"$5\") = r5;\n+    register int r6asm asm (\"$6\") = r6;\n+    asm (\"#foo\" : \"=m\" (r4[3]) : \"d\" (r5asm), \"d\" (r6asm));\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tlwp\" } }*/"}, {"sha": "9534974de8fcf3f1bc3074d78558a275ac3f07a3", "filename": "gcc/testsuite/gcc.target/mips/umips-lwp-6.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-6.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-mgp32 -fpeephole2 -mtune=m14k (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void MICROMIPS\n+foo (int *r4)\n+{\n+  int r5 = r4[512];\n+  int r6 = r4[513];\n+  r4[2] = r6 * r6;\n+  {\n+    register int r5asm asm (\"$5\") = r5;\n+    register int r6asm asm (\"$6\") = r6;\n+    asm (\"#foo\" : \"=m\" (r4[3]) : \"d\" (r5asm), \"d\" (r6asm));\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tlwp\" } }*/"}, {"sha": "87ff6dc11542c09e4f38aa80e61b2ec68b9019cf", "filename": "gcc/testsuite/gcc.target/mips/umips-lwp-7.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-7.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-options \"-mgp32 -fpeephole2 -mtune=m14k (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void MICROMIPS\n+f1 (int *r4, int dummy, int *other)\n+{\n+  int r5 = r4[1];\n+  int newr4 = r4[0];\n+  other[0] = r5 * r5;\n+  {\n+    register int r5asm asm (\"$5\") = r5;\n+    register int r4asm asm (\"$4\") = newr4;\n+    asm (\"#foo\" : \"=m\" (other[1]) : \"d\" (r4asm), \"d\" (r5asm));\n+  }\n+}\n+\n+void MICROMIPS\n+f2 (int *r4, int dummy, int *other)\n+{\n+  int newr4 = r4[0];\n+  int r5 = *(int *)(newr4 + 4);\n+  {\n+    register int r5asm asm (\"$5\") = r5;\n+    register int r4asm asm (\"$4\") = newr4;\n+    asm (\"#foo\" : \"=m\" (other[0]) : \"d\" (r4asm), \"d\" (r5asm));\n+  }\n+}\n+\n+void MICROMIPS\n+f3 (int dummy, int *r5, int *other)\n+{\n+  int newr5 = r5[1];\n+  int r4 = *(int *)newr5;\n+  {\n+    register int r5asm asm (\"$4\") = r4;\n+    register int r4asm asm (\"$5\") = newr5;\n+    asm (\"#foo\" : \"=m\" (other[0]) : \"d\" (r4asm), \"d\" (r5asm));\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tlwp\" } }*/"}, {"sha": "43b98423dfda55d693bdc12c65cef7bfb8180fa6", "filename": "gcc/testsuite/gcc.target/mips/umips-lwp-8.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-8.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-mgp32 -fpeephole2 -mtune=m14k (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void MICROMIPS\n+f1 (int dummy, int *r5, int *other)\n+{\n+  int r4 = r5[0];\n+  int newr5 = r5[1];\n+  other[0] = r4 * r4;\n+  {\n+    register int r5asm asm (\"$4\") = r4;\n+    register int r4asm asm (\"$5\") = newr5;\n+    asm (\"#foo\" : \"=m\" (other[1]) : \"d\" (r4asm), \"d\" (r5asm));\n+  }\n+}\n+\n+/* { dg-final { scan-assembler \"\\tlwp\\t\\\\\\$4,0\\\\(\\\\\\$5\\\\)\" } }*/"}, {"sha": "da2cbaff38bed641e0893065e2ac13f8c1b79807", "filename": "gcc/testsuite/gcc.target/mips/umips-lwp-swp-volatile.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-swp-volatile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-swp-volatile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-lwp-swp-volatile.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mmicromips\" } */\n+\n+/* This test ensures that we do not generate microMIPS SWP or LWP\n+   instructions when any component of the accessed memory is volatile;\n+   they are unsafe for such since they might cause replay of partial\n+   accesses if interrupted by an exception.  */\n+\n+static void set_csr (volatile void *p, int v)\n+{\n+  *(volatile int *) (p) = v;\n+}\n+\n+static int get_csr (volatile void *p)\n+{\n+  return *(volatile int *) (p);\n+}\n+\n+int main ()\n+{\n+  int i, q = 0, p = 0, r = 0;\n+\n+  for (i = 0; i < 20; i++)\n+    {\n+      set_csr ((volatile void *) 0xbf0100a8, 0xffff0002);\n+      set_csr ((volatile void *) 0xbf0100a4, 0x80000008);\n+    }\n+\n+  for (i = 0; i < 20; i++)\n+    {\n+      register int k, j;\n+      k = get_csr ((volatile void *) 0xbf0100b8);\n+      p += k;\n+      j = get_csr ((volatile void *) 0xbf0100b4);\n+      r += j;\n+      q = j + k;\n+    }\n+  return q + r + p;\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tswp\" } } */\n+/* { dg-final { scan-assembler-not \"\\tlwp\" } } */"}, {"sha": "0865b78bd8c865b23c9149849fa941dea9d96a62", "filename": "gcc/testsuite/gcc.target/mips/umips-movep-1.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-movep-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-movep-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-movep-1.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,16 @@\n+/* Check that we can generate the MOVEP instruction.  */\n+/* { dg-options \"-mgp32 -fpeephole2 (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+long long bar (long long, long long);\n+\n+MICROMIPS long long\n+foo (long long n, long long a)\n+{\n+  long long i, j;\n+\n+  i = bar (n, a);\n+  j = bar (n, a);\n+  return i + j;\n+}\n+/* { dg-final { scan-assembler \"\\tmovep\\t\" } } */"}, {"sha": "5a3a8419eee4d4e8a7a88b89fab60290b8fc67ff", "filename": "gcc/testsuite/gcc.target/mips/umips-movep-2.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-movep-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-movep-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-movep-2.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,13 @@\n+/* Check that we can generate the MOVEP instruction.  */\n+/* { dg-options \"-fpeephole2 -mgp32 (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+int bar (int, int);\n+\n+int MICROMIPS\n+foo (int n, int a)\n+{\n+  return bar (0, 0);\n+}\n+\n+/* { dg-final { scan-assembler \"\\tmovep\\t\\\\\\$4,\\\\\\$5,\\\\\\$0,\\\\\\$0\" } } */"}, {"sha": "ff1ea4b339a240c29d444add346c052a2f2c7ba6", "filename": "gcc/testsuite/gcc.target/mips/umips-save-restore-1.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-save-restore-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-save-restore-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-save-restore-1.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,18 @@\n+/* Check that we can use the swm/lwm instructions.  */\n+/* { dg-options \"-mabi=32 (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+int bar (int, int, int, int, int);\n+\n+MICROMIPS int\n+foo (int n, int a, int b, int c, int d)\n+{\n+  int i, j;\n+\n+  i = bar (n, a, b, c, d);\n+  j = bar (n, a, b, c, d);\n+  return i + j;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tswm\\t\\\\\\$16-\\\\\\$2(0|1),\\\\\\$31\" } } */\n+/* { dg-final { scan-assembler \"\\tlwm\\t\\\\\\$16-\\\\\\$2(0|1),\\\\\\$31\" } } */"}, {"sha": "cb421d5d4bea5ee46893b2b55b538a89465e354d", "filename": "gcc/testsuite/gcc.target/mips/umips-save-restore-2.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-save-restore-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-save-restore-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-save-restore-2.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,16 @@\n+/* Check that we can use the save instruction to save spilled arguments.  */\n+/* { dg-options \"-mabi=32 (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+MICROMIPS void\n+foo (int *a, int b, int c)\n+{\n+  asm volatile (\"\" ::: \"$2\", \"$3\", \"$4\", \"$5\", \"$6\", \"$7\", \"$8\",\n+\t\t\"$9\", \"$10\", \"$11\", \"$12\", \"$13\", \"$14\", \"$15\", \"$16\",\n+\t\t\"$17\", \"$18\", \"$19\", \"$20\", \"$21\", \"$22\", \"$23\", \"$24\",\n+\t\t\"$25\", \"$30\", \"memory\");\n+  a[b] = 1;\n+  a[c] = 1;\n+}\n+/* { dg-final { scan-assembler \"\\tswm\\t\\\\\\$16-\\\\\\$23,\\\\\\$fp\" } } */\n+/* { dg-final { scan-assembler \"\\tlwm\\t\\\\\\$16-\\\\\\$23,\\\\\\$fp\" } } */"}, {"sha": "22c6f45f717cda1da42a97c12fb4072954e3995b", "filename": "gcc/testsuite/gcc.target/mips/umips-save-restore-3.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-save-restore-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-save-restore-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-save-restore-3.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,14 @@\n+/* Check that we can use the swm instruction to save $16, $17 and $31.  */\n+/* { dg-options \"-mgp32 (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void bar (void);\n+\n+MICROMIPS void\n+foo (void)\n+{\n+  bar ();\n+  asm volatile (\"\" ::: \"$16\", \"$17\");\n+}\n+/* { dg-final { scan-assembler \"\\tswm\\t\\\\\\$16-\\\\\\$17,\\\\\\$31\" } } */\n+/* { dg-final { scan-assembler \"\\tlwm\\t\\\\\\$16-\\\\\\$17,\\\\\\$31\" } } */"}, {"sha": "5e337b27b6cbbf728479bb85cc21dd0e9615bc6b", "filename": "gcc/testsuite/gcc.target/mips/umips-swp-1.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-1.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-options \"-fpeephole2 -mgp32 (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void MICROMIPS\n+foo (long long l1, long long *l2)\n+{\n+  *l2 = l1;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tswp\\t\\\\\\$4,0\\\\(\\\\\\$6\\\\)\" } }*/"}, {"sha": "042322c217543a1b4ce81fac4e0607560178401b", "filename": "gcc/testsuite/gcc.target/mips/umips-swp-2.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-2.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-fpeephole2 -mtune=m14k (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void MICROMIPS\n+foo (int *r4, int r5, int r6)\n+{\n+  r6 *= r6;\n+  r4[0] = r5;\n+  r4[1] = r6;\n+  {\n+    register int r5asm asm (\"$5\") = r5;\n+    register int r6asm asm (\"$6\") = r6;\n+    asm (\"#foo\" : \"=m\" (r4[2]) : \"d\" (r5asm), \"d\" (r6asm));\n+  }\n+}\n+\n+/* { dg-final { scan-assembler \"\\tswp\\t\\\\\\$5,0\\\\(\\\\\\$4\\\\)\" } }*/"}, {"sha": "f0e54647d9c22c851daef1c4bf3ec5c799d7fd9a", "filename": "gcc/testsuite/gcc.target/mips/umips-swp-3.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-3.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-fpeephole2 -mtune=m14k (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void MICROMIPS\n+foo (int *r4, int r5, int r6)\n+{\n+  r5 *= r5;\n+  r4[0] = r5;\n+  r4[1] = r6;\n+  {\n+    register int r5asm asm (\"$5\") = r5;\n+    register int r6asm asm (\"$6\") = r6;\n+    asm (\"#foo\" : \"=m\" (r4[2]) : \"d\" (r5asm), \"d\" (r6asm));\n+  }\n+}\n+\n+/* { dg-final { scan-assembler \"\\tswp\\t\\\\\\$5,0\\\\(\\\\\\$4\\\\)\" } }*/"}, {"sha": "5e8f5ea2a76670860720328c5c301d500fc6887a", "filename": "gcc/testsuite/gcc.target/mips/umips-swp-4.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-4.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-fpeephole2 -mtune=m14k (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void MICROMIPS\n+foo (int *r4, int r5, int r6)\n+{\n+  r6 *= r6;\n+  r4[511] = r5;\n+  r4[512] = r6;\n+  {\n+    register int r5asm asm (\"$5\") = r5;\n+    register int r6asm asm (\"$6\") = r6;\n+    asm (\"#foo\" : \"=m\" (r4[2]) : \"d\" (r5asm), \"d\" (r6asm));\n+  }\n+}\n+\n+/* { dg-final { scan-assembler \"\\tswp\\t\\\\\\$5,2044\\\\(\\\\\\$4\\\\)\" } }*/"}, {"sha": "dc1938e47b5086a2275684a8c3e20929c2238e04", "filename": "gcc/testsuite/gcc.target/mips/umips-swp-5.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-5.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-fpeephole2 -mtune=m14k (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void MICROMIPS\n+foo (int *r4, int r5, int r6)\n+{\n+  r5 *= r5;\n+  r4[511] = r5;\n+  r4[512] = r6;\n+  {\n+    register int r5asm asm (\"$5\") = r5;\n+    register int r6asm asm (\"$6\") = r6;\n+    asm (\"#foo\" : \"=m\" (r4[2]) : \"d\" (r5asm), \"d\" (r6asm));\n+  }\n+}\n+\n+/* { dg-final { scan-assembler \"\\tswp\\t\\\\\\$5,2044\\\\(\\\\\\$4\\\\)\" } }*/"}, {"sha": "b489006ce99008fdc7a0d5f13ed1c973f6b38d76", "filename": "gcc/testsuite/gcc.target/mips/umips-swp-6.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-6.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-fpeephole2 -mtune=m14k (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void MICROMIPS\n+foo (int *r4, int r5, int r6)\n+{\n+  r6 *= r6;\n+  r4[512] = r5;\n+  r4[513] = r6;\n+  {\n+    register int r5asm asm (\"$5\") = r5;\n+    register int r6asm asm (\"$6\") = r6;\n+    asm (\"#foo\" : \"=m\" (r4[2]) : \"d\" (r5asm), \"d\" (r6asm));\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tswp\" } }*/"}, {"sha": "6dde49b8a355b93ecbce872298eb01dca5ddcee8", "filename": "gcc/testsuite/gcc.target/mips/umips-swp-7.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fumips-swp-7.c?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-options \"-fpeephole2 -mtune=m14k (-mmicromips)\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+void MICROMIPS\n+foo (int *r4, int r5, int r6)\n+{\n+  r5 *= r5;\n+  r4[512] = r5;\n+  r4[513] = r6;\n+  {\n+    register int r5asm asm (\"$5\") = r5;\n+    register int r6asm asm (\"$6\") = r6;\n+    asm (\"#foo\" : \"=m\" (r4[2]) : \"d\" (r5asm), \"d\" (r6asm));\n+  }\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tswp\" } }*/"}, {"sha": "3ebec3bd1f5bf9c01fe4e220734fb6dd1e562793", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -1,3 +1,11 @@\n+2013-03-20  Catherine Moore  <clm@codesourcery.com>\n+\t    Joseph Myers  <joseph@codesourcery.com>\n+\t    Chao-ying Fu  <fu@mips.com>\n+\n+\t* config/mips/mips16.S:  Don't build for microMIPS.\n+\t* config/mips/linux-unwind.h: Handle microMIPS frame.\n+\t* config/mips/crtn.S (fini, init): New labels.\n+\n 2013-03-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/53265"}, {"sha": "99007176db2c8eb15978cacb7472f1234856a42b", "filename": "libgcc/config/mips/crtn.S", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/libgcc%2Fconfig%2Fmips%2Fcrtn.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/libgcc%2Fconfig%2Fmips%2Fcrtn.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmips%2Fcrtn.S?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -31,6 +31,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #endif\n \n \t.section .init,\"ax\",@progbits\n+init:\t\n #ifdef __mips64\n \tld      RA,40($sp)\n \tdaddu\t$sp,$sp,48\n@@ -41,6 +42,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \tj\tRA\n \n \t.section .fini,\"ax\",@progbits\n+fini:\t\n #ifdef\t__mips64\n \tld\tRA,40($sp)\n \tdaddu\t$sp,$sp,48"}, {"sha": "92c2941ef425eb3dd38caaaadee1f1d5250d9734", "filename": "libgcc/config/mips/linux-unwind.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/libgcc%2Fconfig%2Fmips%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/libgcc%2Fconfig%2Fmips%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmips%2Flinux-unwind.h?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -51,6 +51,11 @@ mips_fallback_frame_state (struct _Unwind_Context *context,\n   _Unwind_Ptr new_cfa, reg_offset;\n   int i;\n \n+  /* A MIPS16 or microMIPS frame.  Signal frames always use the standard\n+     ISA encoding.  */\n+  if ((_Unwind_Ptr) pc & 3)\n+    return _URC_END_OF_STACK;\n+\n   /* 24021061 li v0, 0x1061 (rt_sigreturn)*/\n   /* 0000000c syscall    */\n   /*    or */"}, {"sha": "826750180025a308a9968ea2651e0c1f16dada32", "filename": "libgcc/config/mips/mips16.S", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22c4c8694927961d5884eeab71a17b92aa4f9702/libgcc%2Fconfig%2Fmips%2Fmips16.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22c4c8694927961d5884eeab71a17b92aa4f9702/libgcc%2Fconfig%2Fmips%2Fmips16.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmips%2Fmips16.S?ref=22c4c8694927961d5884eeab71a17b92aa4f9702", "patch": "@@ -21,6 +21,10 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n+#ifdef __mips_micromips\n+  /* DO NOTHING */\n+#else\n+\n /* This file contains mips16 floating point support functions.  These\n    functions are called by mips16 code to handle floating point when\n    -msoft-float is not used.  They accept the arguments and return\n@@ -718,3 +722,4 @@ CALL_STUB_RET (__mips16_call_stub_dc_10, 10, DC)\n #endif /* !__mips_single_float */\n \n #endif\n+#endif /* __mips_micromips */"}]}