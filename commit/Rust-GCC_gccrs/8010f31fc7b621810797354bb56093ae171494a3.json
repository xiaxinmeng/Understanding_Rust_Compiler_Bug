{"sha": "8010f31fc7b621810797354bb56093ae171494a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAxMGYzMWZjN2I2MjE4MTA3OTczNTRiYjU2MDkzYWUxNzE0OTRhMw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-12-04T16:19:30Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-12-04T16:19:30Z"}, "message": "tree-ssa-reassoc.c (maybe_optimize_range_tests): Return boolean indicating if a gimple conditional was optimized to true/false.\n\n\t* tree-ssa-reassoc.c (maybe_optimize_range_tests): Return boolean\n\tindicating if a gimple conditional was optimized to true/false.\n\t(reassociate_bb): Bubble up return value from\n\tmaybe_optimize_range_tests.\n\t(do_reassoc): Similarly, but for reassociate_bb.\n\t(execute_reassoc): Return TODO_cleanup_cfg as needed.\n\n\t* gcc.dg/tree-ssa/reassoc-43.c: New test.\n\nFrom-SVN: r231277", "tree": {"sha": "08b70e435b983c6ab9e401f91cd80adc7fa16a28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08b70e435b983c6ab9e401f91cd80adc7fa16a28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8010f31fc7b621810797354bb56093ae171494a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8010f31fc7b621810797354bb56093ae171494a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8010f31fc7b621810797354bb56093ae171494a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8010f31fc7b621810797354bb56093ae171494a3/comments", "author": null, "committer": null, "parents": [{"sha": "7d9425d46b58e69667300331aa55ebddddcceaeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d9425d46b58e69667300331aa55ebddddcceaeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d9425d46b58e69667300331aa55ebddddcceaeb"}], "stats": {"total": 133, "additions": 113, "deletions": 20}, "files": [{"sha": "a3bde22653e77452a919612482b2b96bff62fe89", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8010f31fc7b621810797354bb56093ae171494a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8010f31fc7b621810797354bb56093ae171494a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8010f31fc7b621810797354bb56093ae171494a3", "patch": "@@ -1,3 +1,12 @@\n+2015-12-04  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-reassoc.c (maybe_optimize_range_tests): Return boolean\n+\tindicating if a gimple conditional was optimized to true/false.\n+\t(reassociate_bb): Bubble up return value from\n+\tmaybe_optimize_range_tests.\n+\t(do_reassoc): Similarly, but for reassociate_bb.\n+\t(execute_reassoc): Return TODO_cleanup_cfg as needed.\n+\n 2015-12-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_override_options_internal):"}, {"sha": "4b1b1a3cee33d2ade6bd342adb18ea806d6b1999", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8010f31fc7b621810797354bb56093ae171494a3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8010f31fc7b621810797354bb56093ae171494a3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8010f31fc7b621810797354bb56093ae171494a3", "patch": "@@ -1,3 +1,7 @@\n+2015-12-02  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/reassoc-43.c: New test.\n+\n 2015-12-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/aarch64/mgeneral-regs_4.c: New test."}, {"sha": "ea44f300f94e7e282f964283805aa444ea92769f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-43.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8010f31fc7b621810797354bb56093ae171494a3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8010f31fc7b621810797354bb56093ae171494a3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-43.c?ref=8010f31fc7b621810797354bb56093ae171494a3", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-reassoc -w\" } */\n+\n+typedef union tree_node *tree;\n+enum cpp_ttype { CPP_COLON, CPP_SEMICOLON, CPP_CLOSE_BRACE, CPP_COMMA };\n+enum rid { RID_STATIC = 0, RID_ATTRIBUTE, };\n+typedef struct c_token\n+{\n+  enum cpp_ttype type:8;\n+}\n+c_token;\n+typedef struct c_parser\n+{\n+  c_token tokens[2];\n+  short tokens_avail;\n+}\n+c_parser;\n+__inline__ c_token *\n+c_parser_peek_token (c_parser * parser)\n+{\n+  if (parser->tokens_avail == 0)\n+    {\n+      parser->tokens_avail = 1;\n+    }\n+  return &parser->tokens[0];\n+}\n+\n+__inline__ unsigned char\n+c_parser_next_token_is (c_parser * parser, enum cpp_ttype type)\n+{\n+  return c_parser_peek_token (parser)->type == type;\n+}\n+\n+void\n+c_parser_translation_unit (c_parser * parser)\n+{\n+  tree prefix_attrs;\n+  tree all_prefix_attrs;\n+  while (1)\n+    {\n+      if (c_parser_next_token_is (parser, CPP_COLON)\n+\t  || c_parser_next_token_is (parser, CPP_COMMA)\n+\t  || c_parser_next_token_is (parser, CPP_SEMICOLON)\n+\t  || c_parser_next_token_is (parser, CPP_CLOSE_BRACE)\n+\t  || c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n+\t{\n+\t  if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n+\t    all_prefix_attrs =\n+\t      chainon (c_parser_attributes (parser), prefix_attrs);\n+\t}\n+    }\n+}\n+/* { dg-final { scan-tree-dump-not \"0 != 0\" \"reassoc2\"} } */"}, {"sha": "315b0bfc7ffd928fd5f74d3f881eeec486dcb587", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 47, "deletions": 20, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8010f31fc7b621810797354bb56093ae171494a3/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8010f31fc7b621810797354bb56093ae171494a3/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=8010f31fc7b621810797354bb56093ae171494a3", "patch": "@@ -2976,9 +2976,15 @@ struct inter_bb_range_test_entry\n   unsigned int first_idx, last_idx;\n };\n \n-/* Inter-bb range test optimization.  */\n+/* Inter-bb range test optimization.\n \n-static void\n+   Returns TRUE if a gimple conditional is optimized to a true/false,\n+   otherwise return FALSE.\n+\n+   This indicates to the caller that it should run a CFG cleanup pass\n+   once reassociation is completed.  */\n+\n+static bool\n maybe_optimize_range_tests (gimple *stmt)\n {\n   basic_block first_bb = gimple_bb (stmt);\n@@ -2990,6 +2996,7 @@ maybe_optimize_range_tests (gimple *stmt)\n   auto_vec<operand_entry *> ops;\n   auto_vec<inter_bb_range_test_entry> bbinfo;\n   bool any_changes = false;\n+  bool cfg_cleanup_needed = false;\n \n   /* Consider only basic blocks that end with GIMPLE_COND or\n      a cast statement satisfying final_range_test_p.  All\n@@ -2998,15 +3005,15 @@ maybe_optimize_range_tests (gimple *stmt)\n   if (gimple_code (stmt) == GIMPLE_COND)\n     {\n       if (EDGE_COUNT (first_bb->succs) != 2)\n-\treturn;\n+\treturn cfg_cleanup_needed;\n     }\n   else if (final_range_test_p (stmt))\n     other_bb = single_succ (first_bb);\n   else\n-    return;\n+    return cfg_cleanup_needed;\n \n   if (stmt_could_throw_p (stmt))\n-    return;\n+    return cfg_cleanup_needed;\n \n   /* As relative ordering of post-dominator sons isn't fixed,\n      maybe_optimize_range_tests can be called first on any\n@@ -3030,14 +3037,14 @@ maybe_optimize_range_tests (gimple *stmt)\n       /* As non-GIMPLE_COND last stmt always terminates the range,\n \t if forward search didn't discover anything, just give up.  */\n       if (gimple_code (stmt) != GIMPLE_COND)\n-\treturn;\n+\treturn cfg_cleanup_needed;\n       /* Look at both successors.  Either it ends with a GIMPLE_COND\n \t and satisfies suitable_cond_bb, or ends with a cast and\n \t other_bb is that cast's successor.  */\n       FOR_EACH_EDGE (e, ei, first_bb->succs)\n \tif (!(e->flags & (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE))\n \t    || e->dest == first_bb)\n-\t  return;\n+\t  return cfg_cleanup_needed;\n \telse if (single_pred_p (e->dest))\n \t  {\n \t    stmt = last_stmt (e->dest);\n@@ -3060,7 +3067,7 @@ maybe_optimize_range_tests (gimple *stmt)\n \t      }\n \t  }\n       if (other_bb == NULL)\n-\treturn;\n+\treturn cfg_cleanup_needed;\n     }\n   /* Now do the forward search, moving last_bb to successor bbs\n      that aren't other_bb.  */\n@@ -3080,7 +3087,7 @@ maybe_optimize_range_tests (gimple *stmt)\n       last_bb = e->dest;\n     }\n   if (first_bb == last_bb)\n-    return;\n+    return cfg_cleanup_needed;\n   /* Here basic blocks first_bb through last_bb's predecessor\n      end with GIMPLE_COND, all of them have one of the edges to\n      other_bb and another to another block in the range,\n@@ -3289,10 +3296,18 @@ maybe_optimize_range_tests (gimple *stmt)\n \t      && ops[bbinfo[idx].first_idx]->op != NULL_TREE)\n \t    {\n \t      gcond *cond_stmt = as_a <gcond *> (last_stmt (bb));\n+\t      /* If we collapse the conditional to a true/false\n+\t\t condition, then bubble that knowledge up to our caller.  */\n \t      if (integer_zerop (ops[bbinfo[idx].first_idx]->op))\n-\t\tgimple_cond_make_false (cond_stmt);\n+\t\t{\n+\t\t  gimple_cond_make_false (cond_stmt);\n+\t\t  cfg_cleanup_needed = true;\n+\t\t}\n \t      else if (integer_onep (ops[bbinfo[idx].first_idx]->op))\n-\t\tgimple_cond_make_true (cond_stmt);\n+\t\t{\n+\t\t  gimple_cond_make_true (cond_stmt);\n+\t\t  cfg_cleanup_needed = true;\n+\t\t}\n \t      else\n \t\t{\n \t\t  gimple_cond_set_code (cond_stmt, NE_EXPR);\n@@ -3306,6 +3321,7 @@ maybe_optimize_range_tests (gimple *stmt)\n \t    break;\n \t}\n     }\n+  return cfg_cleanup_needed;\n }\n \n /* Return true if OPERAND is defined by a PHI node which uses the LHS\n@@ -4753,17 +4769,20 @@ transform_stmt_to_multiply (gimple_stmt_iterator *gsi, gimple *stmt,\n }\n \n /* Reassociate expressions in basic block BB and its post-dominator as\n-   children.  */\n+   children.\n \n-static void\n+   Bubble up return status from maybe_optimize_range_tests.  */\n+\n+static bool\n reassociate_bb (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n   basic_block son;\n   gimple *stmt = last_stmt (bb);\n+  bool cfg_cleanup_needed = false;\n \n   if (stmt && !gimple_visited_p (stmt))\n-    maybe_optimize_range_tests (stmt);\n+    cfg_cleanup_needed |= maybe_optimize_range_tests (stmt);\n \n   for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))\n     {\n@@ -4922,7 +4941,9 @@ reassociate_bb (basic_block bb)\n   for (son = first_dom_son (CDI_POST_DOMINATORS, bb);\n        son;\n        son = next_dom_son (CDI_POST_DOMINATORS, son))\n-    reassociate_bb (son);\n+    cfg_cleanup_needed |= reassociate_bb (son);\n+\n+  return cfg_cleanup_needed;\n }\n \n /* Add jumps around shifts for range tests turned into bit tests.\n@@ -5028,11 +5049,13 @@ debug_ops_vector (vec<operand_entry *> ops)\n   dump_ops_vector (stderr, ops);\n }\n \n-static void\n+/* Bubble up return status from reassociate_bb.  */\n+\n+static bool\n do_reassoc (void)\n {\n   break_up_subtract_bb (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-  reassociate_bb (EXIT_BLOCK_PTR_FOR_FN (cfun));\n+  return reassociate_bb (EXIT_BLOCK_PTR_FOR_FN (cfun));\n }\n \n /* Initialize the reassociation pass.  */\n@@ -5106,7 +5129,10 @@ fini_reassoc (void)\n }\n \n /* Gate and execute functions for Reassociation.  If INSERT_POWI_P, enable\n-   insertion of __builtin_powi calls.  */\n+   insertion of __builtin_powi calls.\n+\n+   Returns TODO_cfg_cleanup if a CFG cleanup pass is desired due to\n+   optimization of a gimple conditional.  Otherwise returns zero.  */\n \n static unsigned int\n execute_reassoc (bool insert_powi_p)\n@@ -5115,12 +5141,13 @@ execute_reassoc (bool insert_powi_p)\n \n   init_reassoc ();\n \n-  do_reassoc ();\n+  bool cfg_cleanup_needed;\n+  cfg_cleanup_needed = do_reassoc ();\n   repropagate_negates ();\n   branch_fixup ();\n \n   fini_reassoc ();\n-  return 0;\n+  return cfg_cleanup_needed ? TODO_cleanup_cfg : 0;\n }\n \n namespace {"}]}