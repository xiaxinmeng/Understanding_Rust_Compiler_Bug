{"sha": "25859971802e6c24a568b4370221e2112ea25953", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU4NTk5NzE4MDJlNmMyNGE1NjhiNDM3MDIyMWUyMTEyZWEyNTk1Mw==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2007-08-31T10:22:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-31T10:22:39Z"}, "message": "exp_ch8.adb (Expand_N_Package_Renaming_Declaration): In the case of a library-level package renaming...\n\n2007-08-31  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch8.adb (Expand_N_Package_Renaming_Declaration): In the case of a\n\tlibrary-level package renaming, pass the declaration associated with\n\tthe renaming's special debug variable to Qualify_Entity_Names to ensure\n\tthat its encoded name is properly qualified.\n\n\t* exp_dbug.adb (Qualify_All_Entity_Names): Check for a variable entity\n\toccurring in the list of entities to qualify, and do not attempt to\n\ttraverse an entity list in that case. Variables associated with\n`\tlibrary-level package renamings can now occur in the table.\n\n\t* exp_dbug.ads: Revise documentation of the encoding for renaming\n\tdeclarations.\n\nFrom-SVN: r127973", "tree": {"sha": "cdb270644b5755e0724d7f331087a6d8533ee6d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cdb270644b5755e0724d7f331087a6d8533ee6d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25859971802e6c24a568b4370221e2112ea25953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25859971802e6c24a568b4370221e2112ea25953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25859971802e6c24a568b4370221e2112ea25953", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25859971802e6c24a568b4370221e2112ea25953/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "55d4e6c0909277e0cd19e05de382ac87895b0db8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d4e6c0909277e0cd19e05de382ac87895b0db8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55d4e6c0909277e0cd19e05de382ac87895b0db8"}], "stats": {"total": 122, "additions": 71, "deletions": 51}, "files": [{"sha": "3185f7d3d1a4667008284efdf6dc6085ca00aee4", "filename": "gcc/ada/exp_ch8.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25859971802e6c24a568b4370221e2112ea25953/gcc%2Fada%2Fexp_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25859971802e6c24a568b4370221e2112ea25953/gcc%2Fada%2Fexp_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.adb?ref=25859971802e6c24a568b4370221e2112ea25953", "patch": "@@ -319,6 +319,14 @@ package body Exp_Ch8 is\n                end if;\n \n                Analyze (Decl);\n+\n+               --  Enter the debug variable in the qualification list, which\n+               --  must be done at this point because auxiliary declarations\n+               --  occur at the library level and aren't associated with a\n+               --  normal scope.\n+\n+               Qualify_Entity_Names (Decl);\n+\n                Pop_Scope;\n             end;\n "}, {"sha": "ac86891538db6bd26253e366d55e030edb1f9390", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25859971802e6c24a568b4370221e2112ea25953/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25859971802e6c24a568b4370221e2112ea25953/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=25859971802e6c24a568b4370221e2112ea25953", "patch": "@@ -1011,17 +1011,25 @@ package body Exp_Dbug is\n          E := Defining_Entity (Name_Qualify_Units.Table (J));\n          Qualify_Entity_Name (E);\n \n-         Ent := First_Entity (E);\n-         while Present (Ent) loop\n-            Qualify_Entity_Name (Ent);\n-            Next_Entity (Ent);\n-\n-            --  There are odd cases where Last_Entity (E) = E. This happens\n-            --  in the case of renaming of packages. This test avoids getting\n-            --  stuck in such cases.\n-\n-            exit when Ent = E;\n-         end loop;\n+         --  Normally entities in the qualification list are scopes, but in the\n+         --  case of a library-level package renaming there is an associated\n+         --  variable that encodes the debugger name and that variable is\n+         --  entered in the list since it occurs in the Aux_Decls list of the\n+         --  compilation and doesn't have a normal scope.\n+\n+         if Ekind (E) /= E_Variable then\n+            Ent := First_Entity (E);\n+            while Present (Ent) loop\n+               Qualify_Entity_Name (Ent);\n+               Next_Entity (Ent);\n+\n+               --  There are odd cases where Last_Entity (E) = E. This happens\n+               --  in the case of renaming of packages. This test avoids\n+               --  getting stuck in such cases.\n+\n+               exit when Ent = E;\n+            end loop;\n+         end if;\n       end loop;\n    end Qualify_All_Entity_Names;\n "}, {"sha": "c4eb15f0dffc1c9edea656e9298a74e076ed93b0", "filename": "gcc/ada/exp_dbug.ads", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25859971802e6c24a568b4370221e2112ea25953/gcc%2Fada%2Fexp_dbug.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25859971802e6c24a568b4370221e2112ea25953/gcc%2Fada%2Fexp_dbug.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.ads?ref=25859971802e6c24a568b4370221e2112ea25953", "patch": "@@ -603,8 +603,7 @@ package Exp_Dbug is\n       --   for most debugging formats. However, we do not ever need XD\n       --   encoding for enumeration base types, since here it is always\n       --   clear what the bounds are from the total number of enumeration\n-      --   literals, and of course we do not need to encode the dummy XR\n-      --   types generated for renamings.\n+      --   literals.\n \n       --     typ___XD\n       --     typ___XDL_lowerbound\n@@ -969,20 +968,23 @@ package Exp_Dbug is\n \n    --  Consider a renaming declaration of the form\n \n-   --    x typ renames y;\n+   --    x : typ renames y;\n \n    --  There is one case in which no special debugging information is required,\n-   --  namely the case of an object renaming where the backend allocates a\n+   --  namely the case of an object renaming where the back end allocates a\n    --  reference for the renamed variable, and the entity x is this reference.\n    --  The debugger can handle this case without any special processing or\n    --  encoding (it won't know it was a renaming, but that does not matter).\n \n-   --  All other cases of renaming generate a dummy type definition for\n-   --  an entity whose name is:\n+   --  All other cases of renaming generate a dummy variable for an entity\n+   --  whose name is of the form:\n \n-   --    x___XR    for an object renaming\n-   --    x___XRE   for an exception renaming\n-   --    x___XRP   for a package renaming\n+   --    x___XR_...    for an object renaming\n+   --    x___XRE_...   for an exception renaming\n+   --    x___XRP_...   for a package renaming\n+\n+   --  and where the \"...\" represents a suffix that describes the structure of\n+   --  the object name given in the renaming (see details below).\n \n    --  The name is fully qualified in the usual manner, i.e. qualified in the\n    --  same manner as the entity x would be. In the case of a package renaming\n@@ -992,24 +994,24 @@ package Exp_Dbug is\n \n    --  Note: subprogram renamings are not encoded at the present time\n \n-   --  The type is an enumeration type with a single enumeration literal\n-   --  that is an identifier which describes the renamed variable.\n+   --  The suffix of the variable name describing the renamed object is\n+   --  defined to use the following encoding:\n \n-   --    For the simple entity case, where y is an entity name,\n-   --    the enumeration is of the form:\n+   --    For the simple entity case, where y is just an entity name, the suffix\n+   --    is of the form:\n \n-   --       (y___XE)\n+   --       y___XE\n \n-   --          i.e. the enumeration type has a single field, whose name matches\n-   --          the name y, with the XE suffix. The entity for this enumeration\n-   --          literal is fully qualified in the usual manner. All subprogram,\n-   --          exception, and package renamings fall into this category, as\n-   --          well as simple object renamings.\n+   --          i.e. the suffix has a single field, the first part matching the\n+   --          name y, followed by a \"___\" separator, ending with sequence XE.\n+   --          The entity name portion is fully qualified in the usual manner.\n+   --          This same naming scheme is followed for all forms of encoded\n+   --          renamings that rename a simple entity.\n \n    --    For the object renaming case where y is a selected component or an\n-   --    indexed component, the literal name is suffixed by additional fields\n+   --    indexed component, the variable name is suffixed by additional fields\n    --    that give details of the components. The name starts as above with a\n-   --    y___XE entity indicating the outer level variable. Then a series of\n+   --    y___XE name indicating the outer level object entity. Then a series of\n    --    selections and indexing operations can be specified as follows:\n \n    --      Indexed component\n@@ -1020,20 +1022,19 @@ package Exp_Dbug is\n \n    --          XSnnn\n \n-   --            Here nnn is a constant value, encoded as a decimal\n-   --            integer (pos value for enumeration type case). Negative\n-   --            values have a trailing 'm' as usual.\n+   --            Here nnn is a constant value, encoded as a decimal integer\n+   --            (pos value for enumeration type case). Negative values have\n+   --            a trailing 'm' as usual.\n \n    --          XSe\n \n-   --            Here e is the (unqualified) name of a constant entity in\n-   --            the same scope as the renaming which contains the subscript\n-   --            value.\n+   --            Here e is the (unqualified) name of a constant entity in the\n+   --            same scope as the renaming which contains the subscript value.\n \n    --      Slice\n \n    --        For the slice case, we have two entries. The first is for the\n-   --        lower bound of the slice, and has the form\n+   --        lower bound of the slice, and has the form:\n \n    --          XLnnn\n    --          XLe\n@@ -1069,21 +1070,24 @@ package Exp_Dbug is\n    --           z : string renames g (1,5).m(2 ..3)\n    --        end p;\n \n-   --     The generated type definition would appear as\n+   --     The generated variable entity would appear as\n+\n+   --       p__z___XR_p__g___XEXS1XS5XRmXL2XS3 : _renaming_type;\n+   --                 p__g___XE--------------------outer entity is g\n+   --                          XS1-----------------first subscript for g\n+   --                             XS5--------------second subscript for g\n+   --                                XRm-----------select field m\n+   --                                   XL2--------lower bound of slice\n+   --                                      XS3-----upper bound of slice\n \n-   --       type p__z___XR is\n-   --         (p__g___XEXS1XS5XRmXL2XS3);\n-   --          p__g___XE--------------------outer entity is g\n-   --                   XS1-----------------first subscript for g\n-   --                      XS5--------------second subscript for g\n-   --                         XRm-----------select field m\n-   --                            XL2--------lower bound of slice\n-   --                               XS3-----upper bound of slice\n+   --     Note that the type of the variable is a special internal type named\n+   --     _renaming_type. This type is an arbitrary type of zero size created\n+   --     in package Standard (see cstand.adb) and is ignored by the debugger.\n \n    function Debug_Renaming_Declaration (N : Node_Id) return Node_Id;\n-   --  The argument N is a renaming declaration. The result is a type\n-   --  declaration as described in the above paragraphs. If not special\n-   --  debug declaration, than Empty is returned.\n+   --  The argument N is a renaming declaration. The result is a variable\n+   --  declaration as described in the above paragraphs. If N is not a special\n+   --  debug declaration, then Empty is returned.\n \n    ---------------------------\n    -- Packed Array Encoding --"}]}