{"sha": "3a42502df4cb1fd3b8090658920bfe2635b39613", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E0MjUwMmRmNGNiMWZkM2I4MDkwNjU4OTIwYmZlMjYzNWIzOTYxMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-10-09T22:05:51Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-10-09T22:05:51Z"}, "message": "re PR rtl-optimization/33721 ([meta-bug] Gcc can't properly align stack variable)\n\n\tPR rtl-opt/33721\n\t* explow.c (allocate_dynamic_stack_space): Add REQUIRED_ALIGN parm,\n\tremove TARGET parm, convert KNOWN_ALIGN parm to SIZE_ALIGN.  Honor\n\trequired_align, tidy the code a bit.  Emit split_stack code in the\n\tright place.  Mark the return value with the alignment properly.\n\t* expr.h (allocate_dynamic_stack_space): Update decl.\n\t* builtins.c (expand_builtin_apply): Update call to\n\tallocate_dynamic_stack_space.\n\t(expand_builtin_alloca): Likewise.  Remove TARGET parameter.\n\t* calls.c (initialize_argument_information): Update call to\n\tallocate_dynamic_stack_space.\n\t(expand_call): Likewise.\n\n\t* cfgexpand.c (get_decl_align_unit): Don't limit alignment.\n\tDon't update_stack_alignment here.\n\t(alloc_stack_frame_space): Make ALIGN unsigned.\n\t(stack_var_cmp): Sort by alignment too.\n\t(partition_stack_vars): Don't merge large and small alignment vars.\n\t(expand_one_stack_var_at): Add BASE and BASE_ALIGN parameters.\n\tTake care when BASE is not virtual_stack_vars_rtx.\n\t(expand_stack_vars): Allocate dynamic stack space for large\n\talignment variables.\n\t(expand_one_stack_var): Update all to expand_one_stack_var_at.\n\t(defer_stack_allocation): True for large alignment vars.\n\t(update_stack_alignment): Merge into ...\n\t(expand_one_var): ... here.\n\t(gimple_expand_cfg): Place code from expand_stack_vars.\n\nFrom-SVN: r165240", "tree": {"sha": "a90073debda145f6a7cc32fb368f7c0370185f15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a90073debda145f6a7cc32fb368f7c0370185f15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a42502df4cb1fd3b8090658920bfe2635b39613", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a42502df4cb1fd3b8090658920bfe2635b39613", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a42502df4cb1fd3b8090658920bfe2635b39613", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a42502df4cb1fd3b8090658920bfe2635b39613/comments", "author": null, "committer": null, "parents": [{"sha": "a5f4f531fe6b58b550d0fda12a90bc94b7986402", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5f4f531fe6b58b550d0fda12a90bc94b7986402", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5f4f531fe6b58b550d0fda12a90bc94b7986402"}], "stats": {"total": 451, "additions": 307, "deletions": 144}, "files": [{"sha": "7dd2ba4f5583f08c81b7a00f9780ecf701626f47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a42502df4cb1fd3b8090658920bfe2635b39613", "patch": "@@ -1,3 +1,33 @@\n+2010-10-09  Richard Henderson  <rth@redhat.com>\n+\n+\tPR rtl-opt/33721\n+\t* explow.c (allocate_dynamic_stack_space): Add REQUIRED_ALIGN parm,\n+\tremove TARGET parm, convert KNOWN_ALIGN parm to SIZE_ALIGN.  Honor\n+\trequired_align, tidy the code a bit.  Emit split_stack code in the\n+\tright place.  Mark the return value with the alignment properly.\n+\t* expr.h (allocate_dynamic_stack_space): Update decl.\n+\t* builtins.c (expand_builtin_apply): Update call to\n+\tallocate_dynamic_stack_space.\n+\t(expand_builtin_alloca): Likewise.  Remove TARGET parameter.\n+\t* calls.c (initialize_argument_information): Update call to\n+\tallocate_dynamic_stack_space.\n+\t(expand_call): Likewise.\n+\n+\t* cfgexpand.c (get_decl_align_unit): Don't limit alignment.\n+\tDon't update_stack_alignment here.\n+\t(alloc_stack_frame_space): Make ALIGN unsigned.\n+\t(stack_var_cmp): Sort by alignment too.\n+\t(partition_stack_vars): Don't merge large and small alignment vars.\n+\t(expand_one_stack_var_at): Add BASE and BASE_ALIGN parameters.\n+\tTake care when BASE is not virtual_stack_vars_rtx.\n+\t(expand_stack_vars): Allocate dynamic stack space for large\n+\talignment variables.\n+\t(expand_one_stack_var): Update all to expand_one_stack_var_at.\n+\t(defer_stack_allocation): True for large alignment vars.\n+\t(update_stack_alignment): Merge into ...\n+\t(expand_one_var): ... here.\n+\t(gimple_expand_cfg): Place code from expand_stack_vars.\n+\n 2010-10-09  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* config/pdp11/pdp11.h (FUNCTION_ARG, FUNCTION_ARG_ADVANCE): Delete."}, {"sha": "6fd2d35b10a0a6322a33d8043346b33d07595e2e", "filename": "gcc/builtins.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=3a42502df4cb1fd3b8090658920bfe2635b39613", "patch": "@@ -132,7 +132,7 @@ static rtx expand_builtin_memset (tree, rtx, enum machine_mode);\n static rtx expand_builtin_memset_args (tree, tree, tree, rtx, enum machine_mode, tree);\n static rtx expand_builtin_bzero (tree);\n static rtx expand_builtin_strlen (tree, rtx, enum machine_mode);\n-static rtx expand_builtin_alloca (tree, rtx, bool);\n+static rtx expand_builtin_alloca (tree, bool);\n static rtx expand_builtin_unop (enum machine_mode, tree, rtx, rtx, optab);\n static rtx expand_builtin_frame_address (tree, tree);\n static tree stabilize_va_list_loc (location_t, tree, int);\n@@ -1572,7 +1572,7 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n      arguments to the outgoing arguments address.  We can pass TRUE\n      as the 4th argument because we just saved the stack pointer\n      and will restore it right after the call.  */\n-  allocate_dynamic_stack_space (argsize, 0, BITS_PER_UNIT, TRUE);\n+  allocate_dynamic_stack_space (argsize, 0, BIGGEST_ALIGNMENT, true);\n \n   /* Set DRAP flag to true, even though allocate_dynamic_stack_space\n      may have already set current_function_calls_alloca to true.\n@@ -4931,12 +4931,11 @@ expand_builtin_frame_address (tree fndecl, tree exp)\n }\n \n /* Expand EXP, a call to the alloca builtin.  Return NULL_RTX if we\n-   failed and the caller should emit a normal call, otherwise try to\n-   get the result in TARGET, if convenient.  CANNOT_ACCUMULATE is the\n-   same as for allocate_dynamic_stack_space.  */\n+   failed and the caller should emit a normal call.  CANNOT_ACCUMULATE\n+   is the same as for allocate_dynamic_stack_space.  */\n \n static rtx\n-expand_builtin_alloca (tree exp, rtx target, bool cannot_accumulate)\n+expand_builtin_alloca (tree exp, bool cannot_accumulate)\n {\n   rtx op0;\n   rtx result;\n@@ -4952,7 +4951,7 @@ expand_builtin_alloca (tree exp, rtx target, bool cannot_accumulate)\n   op0 = expand_normal (CALL_EXPR_ARG (exp, 0));\n \n   /* Allocate the desired space.  */\n-  result = allocate_dynamic_stack_space (op0, target, BITS_PER_UNIT,\n+  result = allocate_dynamic_stack_space (op0, 0, BIGGEST_ALIGNMENT,\n \t\t\t\t\t cannot_accumulate);\n   result = convert_memory_address (ptr_mode, result);\n \n@@ -5997,7 +5996,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     case BUILT_IN_ALLOCA:\n       /* If the allocation stems from the declaration of a variable-sized\n \t object, it cannot accumulate.  */\n-      target = expand_builtin_alloca (exp, target, ALLOCA_FOR_VAR_P (exp));\n+      target = expand_builtin_alloca (exp, ALLOCA_FOR_VAR_P (exp));\n       if (target)\n \treturn target;\n       break;"}, {"sha": "31dcd7bb0777f00b3a4b246309f966557ec72967", "filename": "gcc/calls.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=3a42502df4cb1fd3b8090658920bfe2635b39613", "patch": "@@ -1100,10 +1100,11 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t\t  /* We can pass TRUE as the 4th argument because we just\n \t\t     saved the stack pointer and will restore it right after\n \t\t     the call.  */\n-\t\t  copy = gen_rtx_MEM (BLKmode,\n-\t\t\t\t      allocate_dynamic_stack_space\n-\t\t\t\t      (size_rtx, NULL_RTX,\n-\t\t\t\t       TYPE_ALIGN (type), TRUE));\n+\t\t  copy = allocate_dynamic_stack_space (size_rtx,\n+\t\t\t\t\t\t       TYPE_ALIGN (type),\n+\t\t\t\t\t\t       TYPE_ALIGN (type),\n+\t\t\t\t\t\t       true);\n+\t\t  copy = gen_rtx_MEM (BLKmode, copy);\n \t\t  set_mem_attributes (copy, type, 1);\n \t\t}\n \t      else\n@@ -2664,8 +2665,8 @@ expand_call (tree exp, rtx target, int ignore)\n \t      /* We can pass TRUE as the 4th argument because we just\n \t\t saved the stack pointer and will restore it right after\n \t\t the call.  */\n-\t      allocate_dynamic_stack_space (push_size, NULL_RTX,\n-\t\t\t\t\t    BITS_PER_UNIT, TRUE);\n+\t      allocate_dynamic_stack_space (push_size, 0,\n+\t\t\t\t\t    BIGGEST_ALIGNMENT, true);\n \t    }\n \n \t  /* If argument evaluation might modify the stack pointer,"}, {"sha": "de686b5004dce48564a5e3c875403d9f2723050d", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 187, "deletions": 80, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=3a42502df4cb1fd3b8090658920bfe2635b39613", "patch": "@@ -205,51 +205,21 @@ static bool has_protected_decls;\n    smaller than our cutoff threshold.  Used for -Wstack-protector.  */\n static bool has_short_buffer;\n \n-/* Update stack alignment requirement.  */\n-\n-static void\n-update_stack_alignment (unsigned int align)\n-{\n-  if (SUPPORTS_STACK_ALIGNMENT)\n-    {\n-      if (crtl->stack_alignment_estimated < align)\n-\t{\n-\t  gcc_assert(!crtl->stack_realign_processed);\n-          crtl->stack_alignment_estimated = align;\n-\t}\n-    }\n-\n-  /* stack_alignment_needed > PREFERRED_STACK_BOUNDARY is permitted.\n-     So here we only make sure stack_alignment_needed >= align.  */\n-  if (crtl->stack_alignment_needed < align)\n-    crtl->stack_alignment_needed = align;\n-  if (crtl->max_used_stack_slot_alignment < align)\n-    crtl->max_used_stack_slot_alignment = align;\n-}\n-\n /* Discover the byte alignment to use for DECL.  Ignore alignment\n    we can't do with expected alignment of the stack boundary.  */\n \n static unsigned int\n get_decl_align_unit (tree decl)\n {\n-  unsigned int align;\n-\n-  align = LOCAL_DECL_ALIGNMENT (decl);\n-\n-  if (align > MAX_SUPPORTED_STACK_ALIGNMENT)\n-    align = MAX_SUPPORTED_STACK_ALIGNMENT;\n-\n-  update_stack_alignment (align);\n-\n+  unsigned int align = LOCAL_DECL_ALIGNMENT (decl);\n   return align / BITS_PER_UNIT;\n }\n \n /* Allocate SIZE bytes at byte alignment ALIGN from the stack frame.\n    Return the frame offset.  */\n \n static HOST_WIDE_INT\n-alloc_stack_frame_space (HOST_WIDE_INT size, HOST_WIDE_INT align)\n+alloc_stack_frame_space (HOST_WIDE_INT size, unsigned HOST_WIDE_INT align)\n {\n   HOST_WIDE_INT offset, new_frame_offset;\n \n@@ -402,26 +372,43 @@ add_alias_set_conflicts (void)\n }\n \n /* A subroutine of partition_stack_vars.  A comparison function for qsort,\n-   sorting an array of indices by the size and type of the object.  */\n+   sorting an array of indices by the properties of the object.  */\n \n static int\n-stack_var_size_cmp (const void *a, const void *b)\n+stack_var_cmp (const void *a, const void *b)\n {\n-  HOST_WIDE_INT sa = stack_vars[*(const size_t *)a].size;\n-  HOST_WIDE_INT sb = stack_vars[*(const size_t *)b].size;\n-  tree decla, declb;\n+  size_t ia = *(const size_t *)a;\n+  size_t ib = *(const size_t *)b;\n+  unsigned int aligna = stack_vars[ia].alignb;\n+  unsigned int alignb = stack_vars[ib].alignb;\n+  HOST_WIDE_INT sizea = stack_vars[ia].size;\n+  HOST_WIDE_INT sizeb = stack_vars[ib].size;\n+  tree decla = stack_vars[ia].decl;\n+  tree declb = stack_vars[ib].decl;\n+  bool largea, largeb;\n   unsigned int uida, uidb;\n \n-  if (sa < sb)\n+  /* Primary compare on \"large\" alignment.  Large comes first.  */\n+  largea = (aligna * BITS_PER_UNIT > MAX_SUPPORTED_STACK_ALIGNMENT);\n+  largeb = (alignb * BITS_PER_UNIT > MAX_SUPPORTED_STACK_ALIGNMENT);\n+  if (largea != largeb)\n+    return (int)largeb - (int)largea;\n+\n+  /* Secondary compare on size, decreasing  */\n+  if (sizea < sizeb)\n     return -1;\n-  if (sa > sb)\n+  if (sizea > sizeb)\n     return 1;\n-  decla = stack_vars[*(const size_t *)a].decl;\n-  declb = stack_vars[*(const size_t *)b].decl;\n-  /* For stack variables of the same size use and id of the decls\n-     to make the sort stable.  Two SSA names are compared by their\n-     version, SSA names come before non-SSA names, and two normal\n-     decls are compared by their DECL_UID.  */\n+\n+  /* Tertiary compare on true alignment, decreasing.  */\n+  if (aligna < alignb)\n+    return -1;\n+  if (aligna > alignb)\n+    return 1;\n+\n+  /* Final compare on ID for sort stability, increasing.\n+     Two SSA names are compared by their version, SSA names come before\n+     non-SSA names, and two normal decls are compared by their DECL_UID.  */\n   if (TREE_CODE (decla) == SSA_NAME)\n     {\n       if (TREE_CODE (declb) == SSA_NAME)\n@@ -434,9 +421,9 @@ stack_var_size_cmp (const void *a, const void *b)\n   else\n     uida = DECL_UID (decla), uidb = DECL_UID (declb);\n   if (uida < uidb)\n-    return -1;\n-  if (uida > uidb)\n     return 1;\n+  if (uida > uidb)\n+    return -1;\n   return 0;\n }\n \n@@ -634,12 +621,13 @@ partition_stack_vars (void)\n   if (n == 1)\n     return;\n \n-  qsort (stack_vars_sorted, n, sizeof (size_t), stack_var_size_cmp);\n+  qsort (stack_vars_sorted, n, sizeof (size_t), stack_var_cmp);\n \n   for (si = 0; si < n; ++si)\n     {\n       size_t i = stack_vars_sorted[si];\n       HOST_WIDE_INT isize = stack_vars[i].size;\n+      unsigned int ialign = stack_vars[i].alignb;\n       HOST_WIDE_INT offset = 0;\n \n       for (sj = si; sj-- > 0; )\n@@ -660,6 +648,12 @@ partition_stack_vars (void)\n \t  if (stack_var_conflict_p (i, j))\n \t    continue;\n \n+\t  /* Do not mix objects of \"small\" (supported) alignment\n+\t     and \"large\" (unsupported) alignment.  */\n+\t  if ((ialign * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT)\n+\t      != (jalign * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT))\n+\t    continue;\n+\n \t  /* Refine the remaining space check to include alignment.  */\n \t  if (offset & (jalign - 1))\n \t    {\n@@ -715,32 +709,36 @@ dump_stack_var_partition (void)\n     }\n }\n \n-/* Assign rtl to DECL at frame offset OFFSET.  */\n+/* Assign rtl to DECL at BASE + OFFSET.  */\n \n static void\n-expand_one_stack_var_at (tree decl, HOST_WIDE_INT offset)\n+expand_one_stack_var_at (tree decl, rtx base, unsigned base_align,\n+\t\t\t HOST_WIDE_INT offset)\n {\n-  /* Alignment is unsigned.   */\n-  unsigned HOST_WIDE_INT align, max_align;\n+  unsigned align;\n   rtx x;\n \n   /* If this fails, we've overflowed the stack frame.  Error nicely?  */\n   gcc_assert (offset == trunc_int_for_mode (offset, Pmode));\n \n-  x = plus_constant (virtual_stack_vars_rtx, offset);\n+  x = plus_constant (base, offset);\n   x = gen_rtx_MEM (DECL_MODE (SSAVAR (decl)), x);\n \n   if (TREE_CODE (decl) != SSA_NAME)\n     {\n       /* Set alignment we actually gave this decl if it isn't an SSA name.\n          If it is we generate stack slots only accidentally so it isn't as\n \t important, we'll simply use the alignment that is already set.  */\n-      offset -= frame_phase;\n+      if (base == virtual_stack_vars_rtx)\n+\toffset -= frame_phase;\n       align = offset & -offset;\n       align *= BITS_PER_UNIT;\n-      max_align = crtl->max_used_stack_slot_alignment;\n-      if (align == 0 || align > max_align)\n-\talign = max_align;\n+      if (align == 0 || align > base_align)\n+\talign = base_align;\n+\n+      /* One would think that we could assert that we're not decreasing\n+\t alignment here, but (at least) the i386 port does exactly this\n+\t via the MINIMUM_ALIGNMENT hook.  */\n \n       DECL_ALIGN (decl) = align;\n       DECL_USER_ALIGN (decl) = 0;\n@@ -758,9 +756,56 @@ static void\n expand_stack_vars (bool (*pred) (tree))\n {\n   size_t si, i, j, n = stack_vars_num;\n+  HOST_WIDE_INT large_size = 0, large_alloc = 0;\n+  rtx large_base = NULL;\n+  unsigned large_align = 0;\n+  tree decl;\n+\n+  /* Determine if there are any variables requiring \"large\" alignment.\n+     Since these are dynamically allocated, we only process these if\n+     no predicate involved.  */\n+  large_align = stack_vars[stack_vars_sorted[0]].alignb * BITS_PER_UNIT;\n+  if (pred == NULL && large_align > MAX_SUPPORTED_STACK_ALIGNMENT)\n+    {\n+      /* Find the total size of these variables.  */\n+      for (si = 0; si < n; ++si)\n+\t{\n+\t  unsigned alignb;\n+\n+\t  i = stack_vars_sorted[si];\n+\t  alignb = stack_vars[i].alignb;\n+\n+\t  /* Stop when we get to the first decl with \"small\" alignment.  */\n+\t  if (alignb * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT)\n+\t    break;\n+\n+\t  /* Skip variables that aren't partition representatives.  */\n+\t  if (stack_vars[i].representative != i)\n+\t    continue;\n+\n+\t  /* Skip variables that have already had rtl assigned.  See also\n+\t     add_stack_var where we perpetrate this pc_rtx hack.  */\n+\t  decl = stack_vars[i].decl;\n+\t  if ((TREE_CODE (decl) == SSA_NAME\n+\t      ? SA.partition_to_pseudo[var_to_partition (SA.map, decl)]\n+\t      : DECL_RTL (decl)) != pc_rtx)\n+\t    continue;\n+\n+\t  large_size += alignb - 1;\n+\t  large_size &= -(HOST_WIDE_INT)alignb;\n+\t  large_size += stack_vars[i].size;\n+\t}\n+\n+      /* If there were any, allocate space.  */\n+      if (large_size > 0)\n+\tlarge_base = allocate_dynamic_stack_space (GEN_INT (large_size), 0,\n+\t\t\t\t\t\t   large_align, true);\n+    }\n \n   for (si = 0; si < n; ++si)\n     {\n+      rtx base;\n+      unsigned base_align, alignb;\n       HOST_WIDE_INT offset;\n \n       i = stack_vars_sorted[si];\n@@ -771,28 +816,51 @@ expand_stack_vars (bool (*pred) (tree))\n \n       /* Skip variables that have already had rtl assigned.  See also\n \t add_stack_var where we perpetrate this pc_rtx hack.  */\n-      if ((TREE_CODE (stack_vars[i].decl) == SSA_NAME\n-\t   ? SA.partition_to_pseudo[var_to_partition (SA.map, stack_vars[i].decl)]\n-\t   : DECL_RTL (stack_vars[i].decl)) != pc_rtx)\n+      decl = stack_vars[i].decl;\n+      if ((TREE_CODE (decl) == SSA_NAME\n+\t   ? SA.partition_to_pseudo[var_to_partition (SA.map, decl)]\n+\t   : DECL_RTL (decl)) != pc_rtx)\n \tcontinue;\n \n       /* Check the predicate to see whether this variable should be\n \t allocated in this pass.  */\n-      if (pred && !pred (stack_vars[i].decl))\n+      if (pred && !pred (decl))\n \tcontinue;\n \n-      offset = alloc_stack_frame_space (stack_vars[i].size,\n-\t\t\t\t\tstack_vars[i].alignb);\n+      alignb = stack_vars[i].alignb;\n+      if (alignb * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT)\n+\t{\n+\t  offset = alloc_stack_frame_space (stack_vars[i].size, alignb);\n+\t  base = virtual_stack_vars_rtx;\n+\t  base_align = crtl->max_used_stack_slot_alignment;\n+\t}\n+      else\n+\t{\n+\t  /* Large alignment is only processed in the last pass.  */\n+\t  if (pred)\n+\t    continue;\n+\n+\t  large_alloc += alignb - 1;\n+\t  large_alloc &= -(HOST_WIDE_INT)alignb;\n+\t  offset = large_alloc;\n+\t  large_alloc += stack_vars[i].size;\n+\n+\t  base = large_base;\n+\t  base_align = large_align;\n+\t}\n \n       /* Create rtl for each variable based on their location within the\n \t partition.  */\n       for (j = i; j != EOC; j = stack_vars[j].next)\n \t{\n \t  gcc_assert (stack_vars[j].offset <= stack_vars[i].size);\n \t  expand_one_stack_var_at (stack_vars[j].decl,\n+\t\t\t\t   base, base_align,\n \t\t\t\t   stack_vars[j].offset + offset);\n \t}\n     }\n+\n+  gcc_assert (large_alloc == large_size);\n }\n \n /* Take into account all sizes of partitions and reset DECL_RTLs.  */\n@@ -823,13 +891,19 @@ account_stack_vars (void)\n static void\n expand_one_stack_var (tree var)\n {\n-  HOST_WIDE_INT size, offset, align;\n+  HOST_WIDE_INT size, offset;\n+  unsigned byte_align;\n \n   size = tree_low_cst (DECL_SIZE_UNIT (SSAVAR (var)), 1);\n-  align = get_decl_align_unit (SSAVAR (var));\n-  offset = alloc_stack_frame_space (size, align);\n+  byte_align = get_decl_align_unit (SSAVAR (var));\n+\n+  /* We handle highly aligned variables in expand_stack_vars.  */\n+  gcc_assert (byte_align * BITS_PER_UNIT <= MAX_SUPPORTED_STACK_ALIGNMENT);\n \n-  expand_one_stack_var_at (var, offset);\n+  offset = alloc_stack_frame_space (size, byte_align);\n+\n+  expand_one_stack_var_at (var, virtual_stack_vars_rtx,\n+\t\t\t   crtl->max_used_stack_slot_alignment, offset);\n }\n \n /* A subroutine of expand_one_var.  Called to assign rtl to a VAR_DECL\n@@ -898,6 +972,11 @@ defer_stack_allocation (tree var, bool toplevel)\n   if (flag_stack_protect)\n     return true;\n \n+  /* We handle \"large\" alignment via dynamic allocation.  We want to handle\n+     this extra complication in only one place, so defer them.  */\n+  if (DECL_ALIGN (var) > MAX_SUPPORTED_STACK_ALIGNMENT)\n+    return true;\n+\n   /* Variables in the outermost scope automatically conflict with\n      every other variable.  The only reason to want to defer them\n      at all is that, after sorting, we can more efficiently pack\n@@ -927,15 +1006,13 @@ defer_stack_allocation (tree var, bool toplevel)\n static HOST_WIDE_INT\n expand_one_var (tree var, bool toplevel, bool really_expand)\n {\n+  unsigned int align = BITS_PER_UNIT;\n   tree origvar = var;\n+\n   var = SSAVAR (var);\n \n-  if (SUPPORTS_STACK_ALIGNMENT\n-      && TREE_TYPE (var) != error_mark_node\n-      && TREE_CODE (var) == VAR_DECL)\n+  if (TREE_TYPE (var) != error_mark_node && TREE_CODE (var) == VAR_DECL)\n     {\n-      unsigned int align;\n-\n       /* Because we don't know if VAR will be in register or on stack,\n \t we conservatively assume it will be on stack even if VAR is\n \t eventually put into register after RA pass.  For non-automatic\n@@ -955,15 +1032,28 @@ expand_one_var (tree var, bool toplevel, bool really_expand)\n       else\n \talign = MINIMUM_ALIGNMENT (var, DECL_MODE (var), DECL_ALIGN (var));\n \n-      if (crtl->stack_alignment_estimated < align)\n-        {\n-          /* stack_alignment_estimated shouldn't change after stack\n-             realign decision made */\n-          gcc_assert(!crtl->stack_realign_processed);\n-\t  crtl->stack_alignment_estimated = align;\n-\t}\n+      /* If the variable alignment is very large we'll dynamicaly allocate\n+\t it, which means that in-frame portion is just a pointer.  */\n+      if (align > MAX_SUPPORTED_STACK_ALIGNMENT)\n+\talign = POINTER_SIZE;\n+    }\n+\n+  if (SUPPORTS_STACK_ALIGNMENT\n+      && crtl->stack_alignment_estimated < align)\n+    {\n+      /* stack_alignment_estimated shouldn't change after stack\n+         realign decision made */\n+      gcc_assert(!crtl->stack_realign_processed);\n+      crtl->stack_alignment_estimated = align;\n     }\n \n+  /* stack_alignment_needed > PREFERRED_STACK_BOUNDARY is permitted.\n+     So here we only make sure stack_alignment_needed >= align.  */\n+  if (crtl->stack_alignment_needed < align)\n+    crtl->stack_alignment_needed = align;\n+  if (crtl->max_used_stack_slot_alignment < align)\n+    crtl->max_used_stack_slot_alignment = align;\n+\n   if (TREE_CODE (origvar) == SSA_NAME)\n     {\n       gcc_assert (TREE_CODE (var) != VAR_DECL\n@@ -3787,6 +3877,7 @@ gimple_expand_cfg (void)\n   sbitmap blocks;\n   edge_iterator ei;\n   edge e;\n+  rtx var_seq;\n   unsigned i;\n \n   timevar_push (TV_OUT_OF_SSA);\n@@ -3832,10 +3923,14 @@ gimple_expand_cfg (void)\n   crtl->preferred_stack_boundary = STACK_BOUNDARY;\n   cfun->cfg->max_jumptable_ents = 0;\n \n-\n   /* Expand the variables recorded during gimple lowering.  */\n   timevar_push (TV_VAR_EXPAND);\n+  start_sequence ();\n+\n   expand_used_vars ();\n+\n+  var_seq = get_insns ();\n+  end_sequence ();\n   timevar_pop (TV_VAR_EXPAND);\n \n   /* Honor stack protection warnings.  */\n@@ -3855,6 +3950,18 @@ gimple_expand_cfg (void)\n   /* Set up parameters and prepare for return, for the function.  */\n   expand_function_start (current_function_decl);\n \n+  /* If we emitted any instructions for setting up the variables,\n+     emit them before the FUNCTION_START note.  */\n+  if (var_seq)\n+    {\n+      emit_insn_before (var_seq, parm_birth_insn);\n+\n+      /* In expand_function_end we'll insert the alloca save/restore\n+\t before parm_birth_insn.  We've just insertted an alloca call.\n+\t Adjust the pointer to match.  */\n+      parm_birth_insn = var_seq;\n+    }\n+\n   /* Now that we also have the parameter RTXs, copy them over to our\n      partitions.  */\n   for (i = 0; i < SA.map->num_partitions; i++)"}, {"sha": "a83c6e87388b79b68dc6e0dc910202041b753302", "filename": "gcc/explow.c", "status": "modified", "additions": 68, "deletions": 43, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=3a42502df4cb1fd3b8090658920bfe2635b39613", "patch": "@@ -1123,15 +1123,18 @@ update_nonlocal_goto_save_area (void)\n }\n \f\n /* Return an rtx representing the address of an area of memory dynamically\n-   pushed on the stack.  This region of memory is always aligned to\n-   a multiple of BIGGEST_ALIGNMENT.\n+   pushed on the stack.\n \n    Any required stack pointer alignment is preserved.\n \n    SIZE is an rtx representing the size of the area.\n-   TARGET is a place in which the address can be placed.\n \n-   KNOWN_ALIGN is the alignment (in bits) that we know SIZE has.\n+   SIZE_ALIGN is the alignment (in bits) that we know SIZE has.  This\n+   parameter may be zero.  If so, a proper value will be extracted \n+   from SIZE if it is constant, otherwise BITS_PER_UNIT will be assumed.\n+\n+   REQUIRED_ALIGN is the alignment (in bits) required for the region\n+   of memory.\n \n    If CANNOT_ACCUMULATE is set to TRUE, the caller guarantees that the\n    stack space allocated by the generated code cannot be added with itself\n@@ -1141,12 +1144,12 @@ update_nonlocal_goto_save_area (void)\n    loops to it executes the associated deallocation code.  */\n \n rtx\n-allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n-\t\t\t      bool cannot_accumulate)\n+allocate_dynamic_stack_space (rtx size, unsigned size_align,\n+\t\t\t      unsigned required_align, bool cannot_accumulate)\n {\n   HOST_WIDE_INT stack_usage_size = -1;\n-  bool known_align_valid = true;\n-  rtx final_label, final_target;\n+  rtx final_label, final_target, target;\n+  bool must_align;\n \n   /* If we're asking for zero bytes, it doesn't matter what we point\n      to since we can't dereference it.  But return a reasonable\n@@ -1192,42 +1195,67 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n   if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)\n     size = convert_to_mode (Pmode, size, 1);\n \n+  /* Adjust SIZE_ALIGN, if needed.  */\n+  if (CONST_INT_P (size))\n+    {\n+      unsigned HOST_WIDE_INT lsb;\n+\n+      lsb = INTVAL (size);\n+      lsb &= -lsb;\n+\n+      /* Watch out for overflow truncating to \"unsigned\".  */\n+      if (lsb > UINT_MAX / BITS_PER_UNIT)\n+\tsize_align = 1u << (HOST_BITS_PER_INT - 1);\n+      else\n+\tsize_align = (unsigned)lsb * BITS_PER_UNIT;\n+    }\n+  else if (size_align < BITS_PER_UNIT)\n+    size_align = BITS_PER_UNIT;\n+\n   /* We can't attempt to minimize alignment necessary, because we don't\n      know the final value of preferred_stack_boundary yet while executing\n      this code.  */\n   if (crtl->preferred_stack_boundary < PREFERRED_STACK_BOUNDARY)\n     crtl->preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n \n   /* We will need to ensure that the address we return is aligned to\n-     BIGGEST_ALIGNMENT.  If STACK_DYNAMIC_OFFSET is defined, we don't\n+     REQUIRED_ALIGN.  If STACK_DYNAMIC_OFFSET is defined, we don't\n      always know its final value at this point in the compilation (it\n      might depend on the size of the outgoing parameter lists, for\n      example), so we must align the value to be returned in that case.\n      (Note that STACK_DYNAMIC_OFFSET will have a default nonzero value if\n      STACK_POINTER_OFFSET or ACCUMULATE_OUTGOING_ARGS are defined).\n      We must also do an alignment operation on the returned value if\n-     the stack pointer alignment is less strict that BIGGEST_ALIGNMENT.\n+     the stack pointer alignment is less strict than REQUIRED_ALIGN.\n \n      If we have to align, we must leave space in SIZE for the hole\n      that might result from the alignment operation.  */\n \n+  must_align = (crtl->preferred_stack_boundary < required_align);\n #if defined (STACK_DYNAMIC_OFFSET) || defined (STACK_POINTER_OFFSET)\n-#define MUST_ALIGN 1\n-#else\n-#define MUST_ALIGN (crtl->preferred_stack_boundary < BIGGEST_ALIGNMENT)\n+  must_align = true;\n #endif\n \n-  if (MUST_ALIGN)\n+  if (must_align)\n     {\n-      size\n-        = force_operand (plus_constant (size,\n-\t\t\t\t\tBIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),\n-\t\t\t NULL_RTX);\n+      unsigned extra, extra_align;\n+\n+      if (required_align > PREFERRED_STACK_BOUNDARY)\n+\textra_align = PREFERRED_STACK_BOUNDARY;\n+      else if (required_align > STACK_BOUNDARY)\n+\textra_align = STACK_BOUNDARY;\n+      else\n+\textra_align = BITS_PER_UNIT;\n+      extra = (required_align - extra_align) / BITS_PER_UNIT;\n+\n+      size = plus_constant (size, extra);\n+      size = force_operand (size, NULL_RTX);\n \n       if (flag_stack_usage)\n-\tstack_usage_size += BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1;\n+\tstack_usage_size += extra;\n \n-      known_align_valid = false;\n+      if (extra && size_align > extra_align)\n+\tsize_align = extra_align;\n     }\n \n #ifdef SETJMP_VIA_SAVE_AREA\n@@ -1257,7 +1285,8 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n       if (flag_stack_usage)\n \tcurrent_function_dynamic_alloc_count++;\n \n-      known_align_valid = false;\n+      /* ??? Can we infer a minimum of STACK_BOUNDARY here?  */\n+      size_align = BITS_PER_UNIT;\n     }\n #endif /* SETJMP_VIA_SAVE_AREA */\n \n@@ -1274,7 +1303,7 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n      insns.  Since this is an extremely rare event, we have no reliable\n      way of knowing which systems have this problem.  So we avoid even\n      momentarily mis-aligning the stack.  */\n-  if (!known_align_valid || known_align % MAX_SUPPORTED_STACK_ALIGNMENT != 0)\n+  if (size_align % MAX_SUPPORTED_STACK_ALIGNMENT != 0)\n     {\n       size = round_push (size);\n \n@@ -1285,13 +1314,7 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n \t}\n     }\n \n-  /* Don't use a TARGET that isn't a pseudo or is the wrong mode.  */\n-  if (target == 0 || !REG_P (target)\n-      || REGNO (target) < FIRST_PSEUDO_REGISTER\n-      || GET_MODE (target) != Pmode)\n-    target = gen_reg_rtx (Pmode);\n-\n-  mark_reg_pointer (target, known_align);\n+  target = gen_reg_rtx (Pmode);\n \n   /* The size is supposed to be fully adjusted at this point so record it\n      if stack usage info is requested.  */\n@@ -1341,7 +1364,6 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n \treturn space;\n \n       final_target = gen_reg_rtx (Pmode);\n-      mark_reg_pointer (final_target, known_align);\n \n       emit_move_insn (final_target, space);\n \n@@ -1440,35 +1462,38 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align,\n #endif\n     }\n \n-  if (MUST_ALIGN)\n+  /* Finish up the split stack handling.  */\n+  if (final_label != NULL_RTX)\n+    {\n+      gcc_assert (flag_split_stack);\n+      emit_move_insn (final_target, target);\n+      emit_label (final_label);\n+      target = final_target;\n+    }\n+\n+  if (must_align)\n     {\n       /* CEIL_DIV_EXPR needs to worry about the addition overflowing,\n \t but we know it can't.  So add ourselves and then do\n \t TRUNC_DIV_EXPR.  */\n       target = expand_binop (Pmode, add_optab, target,\n-\t\t\t     GEN_INT (BIGGEST_ALIGNMENT / BITS_PER_UNIT - 1),\n+\t\t\t     GEN_INT (required_align / BITS_PER_UNIT - 1),\n \t\t\t     NULL_RTX, 1, OPTAB_LIB_WIDEN);\n       target = expand_divmod (0, TRUNC_DIV_EXPR, Pmode, target,\n-\t\t\t      GEN_INT (BIGGEST_ALIGNMENT / BITS_PER_UNIT),\n+\t\t\t      GEN_INT (required_align / BITS_PER_UNIT),\n \t\t\t      NULL_RTX, 1);\n       target = expand_mult (Pmode, target,\n-\t\t\t    GEN_INT (BIGGEST_ALIGNMENT / BITS_PER_UNIT),\n+\t\t\t    GEN_INT (required_align / BITS_PER_UNIT),\n \t\t\t    NULL_RTX, 1);\n     }\n \n+  /* Now that we've committed to a return value, mark its alignment.  */\n+  mark_reg_pointer (target, required_align);\n+\n   /* Record the new stack level for nonlocal gotos.  */\n   if (cfun->nonlocal_goto_save_area != 0)\n     update_nonlocal_goto_save_area ();\n \n-  /* Finish up the split stack handling.  */\n-  if (final_label != NULL_RTX)\n-    {\n-      gcc_assert (flag_split_stack);\n-      emit_move_insn (final_target, target);\n-      emit_label (final_label);\n-      target = final_target;\n-    }\n-\n   return target;\n }\n \f"}, {"sha": "3d4ad23698122f67dec6f6b388783fa1a2a76679", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=3a42502df4cb1fd3b8090658920bfe2635b39613", "patch": "@@ -642,7 +642,7 @@ extern void emit_stack_restore (enum save_level, rtx, rtx);\n extern void update_nonlocal_goto_save_area (void);\n \n /* Allocate some space on the stack dynamically and return its address.  */\n-extern rtx allocate_dynamic_stack_space (rtx, rtx, int, bool);\n+extern rtx allocate_dynamic_stack_space (rtx, unsigned, unsigned, bool);\n \n /* Emit one stack probe at ADDRESS, an address within the stack.  */\n extern void emit_stack_probe (rtx);"}, {"sha": "2229bc444e309ba2f0109a5ac7c5e2658bb3c436", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3a42502df4cb1fd3b8090658920bfe2635b39613", "patch": "@@ -1,3 +1,8 @@\n+2010-10-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* lib/target-supports.exp\n+\t(check_effective_target_automatic_stack_alignment): Always true.\n+\t\n 2010-10-09  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/45956"}, {"sha": "0ae003ab44c448200c2d3ba959b63a1372148026", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a42502df4cb1fd3b8090658920bfe2635b39613/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=3a42502df4cb1fd3b8090658920bfe2635b39613", "patch": "@@ -3551,12 +3551,8 @@ proc check_effective_target_4byte_wchar_t { } {\n # Return 1 if the target supports automatic stack alignment.\n \n proc check_effective_target_automatic_stack_alignment  { } {\n-    if { [istarget i?86*-*-*]\n-\t || [istarget x86_64-*-*] } then {\n-\treturn 1\n-    } else {\n-\treturn 0\n-    }\n+    # Not \"stack alignment\" per se, but proper stack alignment of decls.\n+    return 1;\n }\n \n # Return 1 if avx instructions can be compiled."}]}