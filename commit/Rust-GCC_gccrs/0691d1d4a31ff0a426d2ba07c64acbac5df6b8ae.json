{"sha": "0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDY5MWQxZDRhMzFmZjBhNDI2ZDJiYTA3YzY0YWNiYWM1ZGY2YjhhZQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2005-07-15T09:31:39Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2005-07-15T09:31:39Z"}, "message": "c-common.c (handle_flatten_attribute): New function.\n\n2005-07-15  Richard Guenther  <rguenther@suse.de>\n\n\t* c-common.c (handle_flatten_attribute): New function.\n\tAdd flatten function attribute.\n\t* doc/extend.texi: Document flatten function attribute.\n\t* Makefile.in (ipa-inline.o): Depend on hashtab.h.\n\t* ipa-inline.c (cgraph_find_cycles, cgraph_flatten_node):\n\tNew functions.\n\t(cgraph_decide_inlining): Handle functions with flatten\n\tattribute.\n\n\t* gcc.dg/tree-ssa/flatten-1.c: New testcase.\n\t* gcc.dg/tree-ssa/flatten-2.c: Likewise.\n\nFrom-SVN: r102051", "tree": {"sha": "2e0dd485a84563f4c7093a4d5ed09ecd19507784", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e0dd485a84563f4c7093a4d5ed09ecd19507784"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7c22afcba12417a2dcb10ceb358966447f07f5ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c22afcba12417a2dcb10ceb358966447f07f5ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c22afcba12417a2dcb10ceb358966447f07f5ef"}], "stats": {"total": 264, "additions": 262, "deletions": 2}, "files": [{"sha": "317e2d75f11a633a32b2fdfdeaba9d46efa4471f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae", "patch": "@@ -1,3 +1,14 @@\n+2005-07-15  Richard Guenther  <rguenther@suse.de>\n+\n+\t* c-common.c (handle_flatten_attribute): New function.\n+\tAdd flatten function attribute.\n+\t* doc/extend.texi: Document flatten function attribute.\n+\t* Makefile.in (ipa-inline.o): Depend on hashtab.h.\n+\t* ipa-inline.c (cgraph_find_cycles, cgraph_flatten_node):\n+\tNew functions.\n+\t(cgraph_decide_inlining): Handle functions with flatten\n+\tattribute.\n+\n 2005-07-14  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.md (UNSPEC_SYNC, UNSPEC_LWSYNC,"}, {"sha": "3d8b8bc7c253b970854458c104ce5bbc219215a1", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae", "patch": "@@ -2141,7 +2141,7 @@ ipa.o : ipa.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H)\n ipa-inline.o : ipa-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h tree-inline.h $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(DIAGNOSTIC_H) $(FIBHEAP_H) $(PARAMS_H) $(TIMEVAR_H) tree-pass.h \\\n-   $(COVERAGE_H)\n+   $(COVERAGE_H) $(HASHTAB_H)\n coverage.o : coverage.c $(GCOV_IO_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) \\\n    function.h toplev.h $(GGC_H) langhooks.h $(COVERAGE_H) gt-coverage.h \\"}, {"sha": "f7463e1f55319adaa1a6731b9c49b69f5cb97413", "filename": "gcc/c-common.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae", "patch": "@@ -505,6 +505,7 @@ static tree handle_noreturn_attribute (tree *, tree, tree, int, bool *);\n static tree handle_noinline_attribute (tree *, tree, tree, int, bool *);\n static tree handle_always_inline_attribute (tree *, tree, tree, int,\n \t\t\t\t\t    bool *);\n+static tree handle_flatten_attribute (tree *, tree, tree, int, bool *);\n static tree handle_used_attribute (tree *, tree, tree, int, bool *);\n static tree handle_unused_attribute (tree *, tree, tree, int, bool *);\n static tree handle_externally_visible_attribute (tree *, tree, tree, int,\n@@ -571,6 +572,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_noinline_attribute },\n   { \"always_inline\",          0, 0, true,  false, false,\n \t\t\t      handle_always_inline_attribute },\n+  { \"flatten\",                0, 0, true,  false, false,\n+                              handle_flatten_attribute },\n   { \"used\",                   0, 0, true,  false, false,\n \t\t\t      handle_used_attribute },\n   { \"unused\",                 0, 0, false, false, false,\n@@ -4151,6 +4154,28 @@ handle_always_inline_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+/* Handle a \"flatten\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_flatten_attribute (tree *node, tree name,\n+                          tree args ATTRIBUTE_UNUSED,\n+                          int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    /* Do nothing else, just set the attribute.  We'll get at\n+       it later with lookup_attribute.  */\n+    ;\n+  else\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\n /* Handle a \"used\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "f71c5200a0ae102c1ab6dbaaff5e199dba6c7dfb", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae", "patch": "@@ -1523,7 +1523,7 @@ attributes when making a declaration.  This keyword is followed by an\n attribute specification inside double parentheses.  The following\n attributes are currently defined for functions on all targets:\n @code{noreturn}, @code{returns_twice}, @code{noinline}, @code{always_inline},\n-@code{pure}, @code{const}, @code{nothrow}, @code{sentinel},\n+@code{flatten}, @code{pure}, @code{const}, @code{nothrow}, @code{sentinel},\n @code{format}, @code{format_arg}, @code{no_instrument_function},\n @code{section}, @code{constructor}, @code{destructor}, @code{used},\n @code{unused}, @code{deprecated}, @code{weak}, @code{malloc},\n@@ -1566,6 +1566,14 @@ Generally, functions are not inlined unless optimization is specified.\n For functions declared inline, this attribute inlines the function even\n if no optimization level was specified.\n \n+@cindex @code{flatten} function attribute\n+@item flatten\n+Generally, inlining into a function is limited.  For a function marked with\n+this attribute, every call inside this function will be inlined, if possible.\n+Whether the function itself is considered for inlining depends on its size and\n+the current inlining parameters.  The @code{flatten} attribute only works\n+reliably in unit-at-a-time mode.\n+\n @item cdecl\n @cindex functions that do pop the argument stack on the 386\n @opindex mrtd"}, {"sha": "df57ccce0530703af6ed06d32b0e9a7313ccb169", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae", "patch": "@@ -78,6 +78,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"fibheap.h\"\n #include \"intl.h\"\n #include \"tree-pass.h\"\n+#include \"hashtab.h\"\n #include \"coverage.h\"\n #include \"ggc.h\"\n \n@@ -438,6 +439,65 @@ lookup_recursive_calls (struct cgraph_node *node, struct cgraph_node *where,\n       lookup_recursive_calls (node, e->callee, heap);\n }\n \n+/* Find callgraph nodes closing a circle in the graph.  The\n+   resulting hashtab can be used to avoid walking the circles.\n+   Uses the cgraph nodes ->aux field which needs to be zero\n+   before and will be zero after operation.  */\n+\n+static void\n+cgraph_find_cycles (struct cgraph_node *node, htab_t cycles)\n+{\n+  struct cgraph_edge *e;\n+\n+  if (node->aux)\n+    {\n+      void **slot;\n+      slot = htab_find_slot (cycles, node, INSERT);\n+      if (!*slot)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Cycle contains %s\\n\", cgraph_node_name (node));\n+\t  *slot = node;\n+\t}\n+      return;\n+    }\n+\n+  node->aux = node;\n+  for (e = node->callees; e; e = e->next_callee)\n+    cgraph_find_cycles (e->callee, cycles); \n+  node->aux = 0;\n+}\n+\n+/* Leafify the cgraph node.  We have to be careful in recursing\n+   as to not run endlessly in circles of the callgraph.\n+   We do so by using a hashtab of cycle entering nodes as generated\n+   by cgraph_find_cycles.  */\n+\n+static void\n+cgraph_flatten_node (struct cgraph_node *node, htab_t cycles)\n+{\n+  struct cgraph_edge *e;\n+\n+  for (e = node->callees; e; e = e->next_callee)\n+    {\n+      /* Inline call, if possible, and recurse.  Be sure we are not\n+\t entering callgraph circles here.  */\n+      if (e->inline_failed\n+\t  && e->callee->local.inlinable\n+\t  && !cgraph_recursive_inlining_p (node, e->callee,\n+\t\t\t\t  \t   &e->inline_failed)\n+\t  && !htab_find (cycles, e->callee))\n+\t{\n+\t  if (dump_file)\n+    \t    fprintf (dump_file, \" inlining %s\", cgraph_node_name (e->callee));\n+          cgraph_mark_inline_edge (e);\n+\t  cgraph_flatten_node (e->callee, cycles);\n+\t}\n+      else if (dump_file)\n+\tfprintf (dump_file, \" !inlining %s\", cgraph_node_name (e->callee));\n+    }\n+}\n+\n /* Decide on recursive inlining: in the case function has recursive calls,\n    inline until body size reaches given argument.  */\n \n@@ -769,6 +829,24 @@ cgraph_decide_inlining (void)\n \n       node = order[i];\n \n+      /* Handle nodes to be flattened, but don't update overall unit size.  */\n+      if (lookup_attribute (\"flatten\", DECL_ATTRIBUTES (node->decl)) != NULL)\n+        {\n+\t  int old_overall_insns = overall_insns;\n+\t  htab_t cycles;\n+  \t  if (dump_file)\n+    \t    fprintf (dump_file,\n+\t     \t     \"Leafifying %s\\n\", cgraph_node_name (node));\n+\t  cycles = htab_create (7, htab_hash_pointer, htab_eq_pointer, NULL);\n+\t  cgraph_find_cycles (node, cycles);\n+\t  cgraph_flatten_node (node, cycles);\n+\t  htab_delete (cycles);\n+\t  overall_insns = old_overall_insns;\n+\t  /* We don't need to consider always_inline functions inside the flattened\n+\t     function anymore.  */\n+\t  continue;\n+        }\n+\n       if (!node->local.disregard_inline_limits)\n \tcontinue;\n       if (dump_file)"}, {"sha": "6bef685f53d5689963af260b30b0c70ecdc8f75d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae", "patch": "@@ -1,3 +1,8 @@\n+2005-07-15  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/flatten-1.c: New testcase.\n+\t* gcc.dg/tree-ssa/flatten-2.c: Likewise.\n+\n 2005-07-15  Steven Bosscher  <stevenb@suse.de>\n \n \tPR tree-optimization/22230"}, {"sha": "4561f757b8c6866c62902caf2f995c114733a37c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/flatten-1.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fflatten-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fflatten-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fflatten-1.c?ref=0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-do compile } */\n+/* { dg-options -O2 } */\n+\n+/* Basic tests for flatten attribute, check we end up\n+   with only the flattened function bodies.  */\n+\n+static int foobar(int i);\n+static int bar(int i);\n+\n+int __attribute__((flatten)) leaf0a(int i)\n+{\n+  return bar(i);\n+}\n+int __attribute__((flatten)) leaf0b(int i)\n+{\n+  return foobar(i);\n+}\n+int __attribute__((flatten)) leaf1(int i)\n+{\n+  return bar(foobar(i));\n+}\n+int __attribute__((flatten)) leaf2(int i)\n+{\n+  int j;\n+  j = foobar(i);\n+  return bar(j);\n+}\n+\n+static int foobar(int i)\n+{\n+  return i-1;\n+}\n+static int bar(int i)\n+{\n+  return i + foobar(i);\n+}\n+\n+\n+static int g(int i)\n+{\n+  return i*5+1;\n+}\n+static int f(int i)\n+{\n+  return g(i);\n+}\n+int __attribute__((flatten)) leaf3(int i)\n+{\n+  int j;\n+  j = f(i);\n+  j += f(i);\n+  return j;\n+}\n+\n+/* { dg-final { scan-assembler-not \"g:\" } } */\n+/* { dg-final { scan-assembler-not \"f:\" } } */\n+/* { dg-final { scan-assembler-not \"bar:\" } } */"}, {"sha": "56e8083febd4bcafb6a6315a863e7007ea8e63ff", "filename": "gcc/testsuite/gcc.dg/tree-ssa/flatten-2.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fflatten-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fflatten-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fflatten-2.c?ref=0691d1d4a31ff0a426d2ba07c64acbac5df6b8ae", "patch": "@@ -0,0 +1,76 @@\n+/* { dg-do compile } */\n+/* { dg-options -O2 } */\n+\n+/* Check that we finish compiling even if instructed to\n+   flatten a cyclic callgraph.  Verify we correctly\n+   flatten with another function marked flatten in the\n+   callgraph.  */\n+\n+void __attribute__((flatten)) direct(void)\n+{\n+  direct();\n+}\n+\n+\n+void __attribute__((flatten)) indirect(void);\n+static void indirect1(void)\n+{\n+  indirect();\n+}\n+void __attribute__((flatten)) indirect(void)\n+{\n+  indirect1();\n+}\n+\n+\n+void __attribute__((flatten)) doubleindirect(void);\n+static void doubleindirect2(void)\n+{\n+  doubleindirect();\n+}\n+static void doubleindirect1(void)\n+{\n+  doubleindirect2();\n+}\n+void __attribute__((flatten)) doubleindirect(void)\n+{\n+  doubleindirect1();\n+}\n+\n+\n+static void subcycle1(void);\n+static void subcycle2(void)\n+{\n+  subcycle1();\n+}\n+static void subcycle1(void)\n+{\n+  subcycle2();\n+}\n+void __attribute__((flatten)) subcycle(void)\n+{\n+  subcycle1();\n+}\n+\n+\n+static void doublesubcycle1(void);\n+static void doublesubcycle2(void);\n+static void doublesubcycle3(void)\n+{\n+  doublesubcycle1();\n+}\n+static void doublesubcycle2(void)\n+{\n+  doublesubcycle3();\n+}\n+static void doublesubcycle1(void)\n+{\n+  doublesubcycle2();\n+}\n+void __attribute__((flatten)) doublesubcycle(void)\n+{\n+  doublesubcycle1();\n+}\n+\n+/* { dg-final { scan-assembler \"cycle.:\" } } */\n+/* { dg-final { scan-assembler-not \"indirect.:\" } } */"}]}