{"sha": "89b6c83e251d0b65860be2353fcf261169af2cf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODliNmM4M2UyNTFkMGI2NTg2MGJlMjM1M2ZjZjI2MTE2OWFmMmNmMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T10:03:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T10:03:40Z"}, "message": "[multiple changes]\n\n2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* checks.adb (Insert_Valid_Check): Partially reimplement validity\n\tchecks.\n\t* einfo.adb Node36 is now used as Validated_Object.\n\t(Validated_Object): New routine.\n\t(Set_Validated_Object): New routine.\n\t(Write_Field36_Name): Add an entry for Validated_Object.\n\t* einfo.ads Add new attribute Validated_Object along with\n\tusage in entities.\n\t(Validated_Object): New routine along with pragma Inline.\n\t(Set_Validated_Object): New routine along with pragma Inline.\n\t* exp_attr.adb (Make_Range_Test): Add processing for validation\n\tvariables to avoid extra reads and copies of the prefix.\n\t* exp_ch6.adb (Expand_Actuals): Add copy-back for validation\n\tvariables in order to reflect any changes done in the variable\n\tback into the original object.\n\t* sem_util.adb (Is_Validation_Variable_Reference): New routine.\n\t* sem_util.ads (Is_Validation_Variable_Reference): New routine.\n\n2017-04-25  Steve Baird  <baird@adacore.com>\n\n\t* exp_ch7.adb (Build_Array_Deep_Procs,\n\tBuild_Record_Deep_Procs, Make_Finalize_Address_Body): Don't\n\tgenerate Finalize_Address routines for CodePeer.\n\n2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb (Inherits_Class_Wide_Pre): subsidiary of\n\tAnalyze_Pre_Post_Condition, to implement the legality checks\n\tmandated by AI12-0131: Pre'Class shall not be specified for an\n\toverriding primitive subprogram of a tagged type T unless the\n\tPre'Class aspect is specified for the corresponding primitive\n\tsubprogram of some ancestor of T.\n\nFrom-SVN: r247170", "tree": {"sha": "77a84cc123e605028bdec3b1d08c30e0b8dff2d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77a84cc123e605028bdec3b1d08c30e0b8dff2d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89b6c83e251d0b65860be2353fcf261169af2cf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89b6c83e251d0b65860be2353fcf261169af2cf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89b6c83e251d0b65860be2353fcf261169af2cf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89b6c83e251d0b65860be2353fcf261169af2cf3/comments", "author": null, "committer": null, "parents": [{"sha": "c6840e83cc062932453294d553b7bfeafe54e0c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6840e83cc062932453294d553b7bfeafe54e0c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6840e83cc062932453294d553b7bfeafe54e0c1"}], "stats": {"total": 388, "additions": 332, "deletions": 56}, "files": [{"sha": "07615147138e304f29111adcd6d1c29eb5584143", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=89b6c83e251d0b65860be2353fcf261169af2cf3", "patch": "@@ -1,3 +1,38 @@\n+2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* checks.adb (Insert_Valid_Check): Partially reimplement validity\n+\tchecks.\n+\t* einfo.adb Node36 is now used as Validated_Object.\n+\t(Validated_Object): New routine.\n+\t(Set_Validated_Object): New routine.\n+\t(Write_Field36_Name): Add an entry for Validated_Object.\n+\t* einfo.ads Add new attribute Validated_Object along with\n+\tusage in entities.\n+\t(Validated_Object): New routine along with pragma Inline.\n+\t(Set_Validated_Object): New routine along with pragma Inline.\n+\t* exp_attr.adb (Make_Range_Test): Add processing for validation\n+\tvariables to avoid extra reads and copies of the prefix.\n+\t* exp_ch6.adb (Expand_Actuals): Add copy-back for validation\n+\tvariables in order to reflect any changes done in the variable\n+\tback into the original object.\n+\t* sem_util.adb (Is_Validation_Variable_Reference): New routine.\n+\t* sem_util.ads (Is_Validation_Variable_Reference): New routine.\n+\n+2017-04-25  Steve Baird  <baird@adacore.com>\n+\n+\t* exp_ch7.adb (Build_Array_Deep_Procs,\n+\tBuild_Record_Deep_Procs, Make_Finalize_Address_Body): Don't\n+\tgenerate Finalize_Address routines for CodePeer.\n+\n+2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb (Inherits_Class_Wide_Pre): subsidiary of\n+\tAnalyze_Pre_Post_Condition, to implement the legality checks\n+\tmandated by AI12-0131: Pre'Class shall not be specified for an\n+\toverriding primitive subprogram of a tagged type T unless the\n+\tPre'Class aspect is specified for the corresponding primitive\n+\tsubprogram of some ancestor of T.\n+\n 2017-04-25  Bob Duff  <duff@adacore.com>\n \n \t* sem_ch8.adb (Use_One_Type): If a use_type_clause"}, {"sha": "ece2f367c16dd1ac7ad7e67517f14553fdcfdeba", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 71, "deletions": 30, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=89b6c83e251d0b65860be2353fcf261169af2cf3", "patch": "@@ -7180,51 +7180,92 @@ package body Checks is\n          Exp := Expression (Exp);\n       end loop;\n \n+      --  Do not generate a check for a variable which already validates the\n+      --  value of an assignable object.\n+\n+      if Is_Validation_Variable_Reference (Exp) then\n+         return;\n+      end if;\n+\n       --  We are about to insert the validity check for Exp. We save and\n       --  reset the Do_Range_Check flag over this validity check, and then\n       --  put it back for the final original reference (Exp may be rewritten).\n \n       declare\n          DRC : constant Boolean := Do_Range_Check (Exp);\n-         PV  : Node_Id;\n          CE  : Node_Id;\n+         Obj : Node_Id;\n+         PV  : Node_Id;\n+         Var : Entity_Id;\n \n       begin\n          Set_Do_Range_Check (Exp, False);\n \n-         --  Force evaluation to avoid multiple reads for atomic/volatile\n+         --  If the expression denotes an assignable object, capture its value\n+         --  in a variable and replace the original expression by the variable.\n+         --  This approach has several effects:\n \n-         --  Note: we set Name_Req to False. We used to set it to True, with\n-         --  the thinking that a name is required as the prefix of the 'Valid\n-         --  call, but in fact the check that the prefix of an attribute is\n-         --  a name is in the parser, and we just don't require it here.\n-         --  Moreover, when we set Name_Req to True, that interfered with the\n-         --  checking for Volatile, since we couldn't just capture the value.\n+         --    1) The evaluation of the object results in only one read in the\n+         --       case where the object is atomic or volatile.\n \n-         if Is_Entity_Name (Exp)\n-           and then Is_Volatile (Entity (Exp))\n-         then\n-            --  Same reasoning as above for setting Name_Req to False\n+         --         Temp ... := Object;  --  read\n \n-            Force_Evaluation (Exp, Name_Req => False);\n-         end if;\n+         --    2) The captured value is the one verified by attribute 'Valid.\n+         --       As a result the object is not evaluated again, which would\n+         --       result in an unwanted read in the case where the object is\n+         --       atomic or volatile.\n+\n+         --         if not Temp'Valid then    --  OK, no read of Object\n+\n+         --         if not Object'Valid then  --  Wrong, extra read of Object\n+\n+         --    3) The captured value replaces the original object reference.\n+         --       As a result the object is not evaluated again, in the same\n+         --       vein as 2).\n+\n+         --         ... Temp ...    --  OK, no read of Object\n+\n+         --         ... Object ...  --  Wrong, extra read of Object\n \n-         --  Build the prefix for the 'Valid call. If the expression denotes\n-         --  a non-volatile name, use a renaming to alias it, otherwise use a\n-         --  constant to capture the value of the expression.\n-\n-         --    Temp : ... renames Expr;      --  non-volatile name\n-         --    Temp : constant ... := Expr;  --  all other cases\n-\n-         PV :=\n-           Duplicate_Subexpr_No_Checks\n-             (Exp           => Exp,\n-              Name_Req      => False,\n-              Renaming_Req  =>\n-                Is_Name_Reference (Exp) and then not Is_Volatile (Typ),\n-              Related_Id    => Related_Id,\n-              Is_Low_Bound  => Is_Low_Bound,\n-              Is_High_Bound => Is_High_Bound);\n+         --    4) The use of a variable to capture the value of the object\n+         --       allows the propagation of any changes back to the original\n+         --       object.\n+\n+         --         procedure Call (Val : in out ...);\n+\n+         --         Temp : ... := Object;   --  read Object\n+         --         if not Temp'Valid then  --  validity check\n+         --         Call (Temp);            --  modify Temp\n+         --         Object := Temp;         --  update Object\n+\n+         if Is_Variable (Exp) then\n+            Obj := New_Copy_Tree (Exp);\n+            Var := Make_Temporary (Loc, 'T', Exp);\n+\n+            Insert_Action (Exp,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Var,\n+                Object_Definition   => New_Occurrence_Of (Typ, Loc),\n+                Expression          => Relocate_Node (Exp)));\n+            Set_Validated_Object (Var, Obj);\n+\n+            Rewrite (Exp, New_Occurrence_Of (Var, Loc));\n+            PV := New_Occurrence_Of (Var, Loc);\n+\n+         --  Otherwise the expression does not denote a variable. Force its\n+         --  evaluation by capturing its value in a constant. Generate:\n+\n+         --    Temp : constant ... := Exp;\n+\n+         else\n+            Force_Evaluation\n+              (Exp           => Exp,\n+               Related_Id    => Related_Id,\n+               Is_Low_Bound  => Is_Low_Bound,\n+               Is_High_Bound => Is_High_Bound);\n+\n+            PV := New_Copy_Tree (Exp);\n+         end if;\n \n          --  A rather specialized test. If PV is an analyzed expression which\n          --  is an indexed component of a packed array that has not been"}, {"sha": "26e422432156ed33b3f66d0782adf741f0106315", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=89b6c83e251d0b65860be2353fcf261169af2cf3", "patch": "@@ -270,6 +270,8 @@ package body Einfo is\n    --    Entry_Max_Queue_Lengths_Array   Node35\n    --    Import_Pragma                   Node35\n \n+   --    Validated_Object                Node36\n+\n    --    Class_Wide_Preconds             List38\n \n    --    Class_Wide_Postconds            List39\n@@ -3477,6 +3479,12 @@ package body Einfo is\n       return Flag95 (Id);\n    end Uses_Sec_Stack;\n \n+   function Validated_Object (Id : E) return N is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Variable);\n+      return Node36 (Id);\n+   end Validated_Object;\n+\n    function Warnings_Off (Id : E) return B is\n    begin\n       return Flag96 (Id);\n@@ -6618,6 +6626,12 @@ package body Einfo is\n       Set_Flag95 (Id, V);\n    end Set_Uses_Sec_Stack;\n \n+   procedure Set_Validated_Object (Id : E; V : N) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Variable);\n+      Set_Node36 (Id, V);\n+   end Set_Validated_Object;\n+\n    procedure Set_Warnings_Off (Id : E; V : B := True) is\n    begin\n       Set_Flag96 (Id, V);\n@@ -10881,9 +10895,14 @@ package body Einfo is\n    ------------------------\n \n    procedure Write_Field36_Name (Id : Entity_Id) is\n-      pragma Unreferenced (Id);\n    begin\n-      Write_Str (\"Field36??\");\n+      case Ekind (Id) is\n+         when E_Variable =>\n+            Write_Str (\"Validated_Object\");\n+\n+         when others =>\n+            Write_Str (\"Field36??\");\n+      end case;\n    end Write_Field36_Name;\n \n    ------------------------"}, {"sha": "095ec60edeb9635762b29639c1a97632a8b5458f", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=89b6c83e251d0b65860be2353fcf261169af2cf3", "patch": "@@ -4514,6 +4514,10 @@ package Einfo is\n --       task). Set to True when secondary stack is used in this scope and must\n --       be released on exit unless Sec_Stack_Needed_For_Return is set.\n \n+--    Validated_Object (Node36)\n+--       Defined in variables. Contains the object whose value is captured by\n+--       the variable for validity check purposes.\n+\n --    Warnings_Off (Flag96)\n --       Defined in all entities. Set if a pragma Warnings (Off, entity-name)\n --       is used to suppress warnings for a given entity. It is also used by\n@@ -6609,6 +6613,7 @@ package Einfo is\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Anonymous_Designated_Type           (Node35)\n+   --    Validated_Object                    (Node36)\n    --    SPARK_Pragma                        (Node40)\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n@@ -7342,6 +7347,7 @@ package Einfo is\n    function Used_As_Generic_Actual              (Id : E) return B;\n    function Uses_Lock_Free                      (Id : E) return B;\n    function Uses_Sec_Stack                      (Id : E) return B;\n+   function Validated_Object                    (Id : E) return N;\n    function Warnings_Off                        (Id : E) return B;\n    function Warnings_Off_Used                   (Id : E) return B;\n    function Warnings_Off_Used_Unmodified        (Id : E) return B;\n@@ -8029,6 +8035,7 @@ package Einfo is\n    procedure Set_Used_As_Generic_Actual          (Id : E; V : B := True);\n    procedure Set_Uses_Lock_Free                  (Id : E; V : B := True);\n    procedure Set_Uses_Sec_Stack                  (Id : E; V : B := True);\n+   procedure Set_Validated_Object                (Id : E; V : N);\n    procedure Set_Warnings_Off                    (Id : E; V : B := True);\n    procedure Set_Warnings_Off_Used               (Id : E; V : B := True);\n    procedure Set_Warnings_Off_Used_Unmodified    (Id : E; V : B := True);\n@@ -8871,6 +8878,7 @@ package Einfo is\n    pragma Inline (Used_As_Generic_Actual);\n    pragma Inline (Uses_Lock_Free);\n    pragma Inline (Uses_Sec_Stack);\n+   pragma Inline (Validated_Object);\n    pragma Inline (Warnings_Off);\n    pragma Inline (Warnings_Off_Used);\n    pragma Inline (Warnings_Off_Used_Unmodified);\n@@ -9346,6 +9354,7 @@ package Einfo is\n    pragma Inline (Set_Used_As_Generic_Actual);\n    pragma Inline (Set_Uses_Lock_Free);\n    pragma Inline (Set_Uses_Sec_Stack);\n+   pragma Inline (Set_Validated_Object);\n    pragma Inline (Set_Warnings_Off);\n    pragma Inline (Set_Warnings_Off_Used);\n    pragma Inline (Set_Warnings_Off_Used_Unmodified);"}, {"sha": "c1bda8f044210751928e013be1ecdecd77075366", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=89b6c83e251d0b65860be2353fcf261169af2cf3", "patch": "@@ -6488,32 +6488,48 @@ package body Exp_Attr is\n          ---------------------\n \n          function Make_Range_Test return Node_Id is\n-            Temp : constant Node_Id := Duplicate_Subexpr (Pref);\n+            Temp : Node_Id;\n \n          begin\n-            --  The value whose validity is being checked has been captured in\n-            --  an object declaration. We certainly don't want this object to\n-            --  appear valid because the declaration initializes it.\n+            --  The prefix of attribute 'Valid should always denote an object\n+            --  reference. The reference is either coming directly from source\n+            --  or is produced by validity check expansion.\n \n-            if Is_Entity_Name (Temp) then\n-               Set_Is_Known_Valid (Entity (Temp), False);\n+            --  If the prefix denotes a variable which captures the value of\n+            --  an object for validation purposes, use the variable in the\n+            --  range test. This ensures that no extra copies or extra reads\n+            --  are produced as part of the test. Generate:\n+\n+            --    Temp : ... := Object;\n+            --    if not Temp in ... then\n+\n+            if Is_Validation_Variable_Reference (Pref) then\n+               Temp := New_Occurrence_Of (Entity (Pref), Loc);\n+\n+            --  Otherwise the prefix is either a source object or a constant\n+            --  produced by validity check expansion. Generate:\n+\n+            --    Temp : constant ... := Pref;\n+            --    if not Temp in ... then\n+\n+            else\n+               Temp := Duplicate_Subexpr (Pref);\n             end if;\n \n             return\n               Make_In (Loc,\n-                Left_Opnd  =>\n-                  Unchecked_Convert_To (Btyp, Temp),\n+                Left_Opnd  => Unchecked_Convert_To (Btyp, Temp),\n                 Right_Opnd =>\n                   Make_Range (Loc,\n-                    Low_Bound =>\n+                    Low_Bound  =>\n                       Unchecked_Convert_To (Btyp,\n                         Make_Attribute_Reference (Loc,\n-                          Prefix => New_Occurrence_Of (Ptyp, Loc),\n+                          Prefix         => New_Occurrence_Of (Ptyp, Loc),\n                           Attribute_Name => Name_First)),\n                     High_Bound =>\n                       Unchecked_Convert_To (Btyp,\n                         Make_Attribute_Reference (Loc,\n-                          Prefix => New_Occurrence_Of (Ptyp, Loc),\n+                          Prefix         => New_Occurrence_Of (Ptyp, Loc),\n                           Attribute_Name => Name_Last))));\n          end Make_Range_Test;\n "}, {"sha": "e44518f9a7bd18517e70116a0bb156f559bbf3ef", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=89b6c83e251d0b65860be2353fcf261169af2cf3", "patch": "@@ -1901,6 +1901,21 @@ package body Exp_Ch6 is\n             then\n                Add_Call_By_Copy_Code;\n \n+            --  The actual denotes a variable which captures the value of an\n+            --  object for validation purposes. Add a copy-back to reflect any\n+            --  potential changes in value back into the original object.\n+\n+            --    Temp : ... := Object;\n+            --    if not Temp'Valid then ...\n+            --    Call (Temp);\n+            --    Object := Temp;\n+\n+            elsif Is_Validation_Variable_Reference (Actual) then\n+               Append_To (Post_Call,\n+                 Make_Assignment_Statement (Loc,\n+                   Name       => Validated_Object (Entity (Actual)),\n+                   Expression => New_Occurrence_Of (Entity (Actual), Loc)));\n+\n             elsif Nkind (Actual) = N_Indexed_Component\n               and then Is_Entity_Name (Prefix (Actual))\n               and then Has_Volatile_Components (Entity (Prefix (Actual)))"}, {"sha": "4febff09c487d5da77a9fcc009144e18610203c6", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=89b6c83e251d0b65860be2353fcf261169af2cf3", "patch": "@@ -787,13 +787,15 @@ package body Exp_Ch7 is\n               Typ   => Typ,\n               Stmts => Make_Deep_Array_Body (Finalize_Case, Typ)));\n \n-         --  Create TSS primitive Finalize_Address.\n+         --  Create TSS primitive Finalize_Address (unless CodePeer_Mode).\n \n-         Set_TSS (Typ,\n-           Make_Deep_Proc\n-             (Prim  => Address_Case,\n-              Typ   => Typ,\n-              Stmts => Make_Deep_Array_Body (Address_Case, Typ)));\n+         if not CodePeer_Mode then\n+            Set_TSS (Typ,\n+              Make_Deep_Proc\n+                (Prim  => Address_Case,\n+                 Typ   => Typ,\n+                 Stmts => Make_Deep_Array_Body (Address_Case, Typ)));\n+         end if;\n       end if;\n    end Build_Array_Deep_Procs;\n \n@@ -3669,13 +3671,15 @@ package body Exp_Ch7 is\n               Typ   => Typ,\n               Stmts => Make_Deep_Record_Body (Finalize_Case, Typ)));\n \n-         --  Create TSS primitive Finalize_Address\n+         --  Create TSS primitive Finalize_Address (unless CodePeer_Mode).\n \n-         Set_TSS (Typ,\n-           Make_Deep_Proc\n-             (Prim  => Address_Case,\n-              Typ   => Typ,\n-              Stmts => Make_Deep_Record_Body (Address_Case, Typ)));\n+         if not CodePeer_Mode then\n+            Set_TSS (Typ,\n+              Make_Deep_Proc\n+                (Prim  => Address_Case,\n+                 Typ   => Typ,\n+                 Stmts => Make_Deep_Record_Body (Address_Case, Typ)));\n+         end if;\n       end if;\n    end Build_Record_Deep_Procs;\n \n@@ -7797,6 +7801,11 @@ package body Exp_Ch7 is\n          return;\n       end if;\n \n+      --  Don't generate Finalize_Address routine for CodePeer\n+      if CodePeer_Mode then\n+         return;\n+      end if;\n+\n       Proc_Id :=\n         Make_Defining_Identifier (Loc,\n           Make_TSS_Name (Typ, TSS_Finalize_Address));"}, {"sha": "fee1bb321d6b4e3827cf10a29489688b85f0012a", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=89b6c83e251d0b65860be2353fcf261169af2cf3", "patch": "@@ -4208,6 +4208,85 @@ package body Sem_Prag is\n          --  Flag set when the pragma is one of Pre, Pre_Class, Post or\n          --  Post_Class.\n \n+         function Inherits_Class_Wide_Pre (E : Entity_Id) return Boolean;\n+         --  Implement rules in AI12-0131: an overriding operation can have\n+         --  a class-wide precondition only if one of its ancestors has an\n+         --  explicit class-wide precondition.\n+\n+         -----------------------------\n+         -- Inherits_Class_Wide_Pre --\n+         -----------------------------\n+\n+         function Inherits_Class_Wide_Pre (E : Entity_Id) return Boolean is\n+            Prev : Entity_Id := Overridden_Operation (E);\n+            Cont : Node_Id;\n+            Prag : Node_Id;\n+            Typ  : Entity_Id;\n+\n+         begin\n+            --  Check ancestors on the overriding operation to examine the\n+            --  preconditions that may apply to them.\n+\n+            while Present (Prev) loop\n+               Cont := Contract (Prev);\n+               if Present (Cont) then\n+                  Prag := Pre_Post_Conditions (Cont);\n+                  while Present (Prag) loop\n+                     if Class_Present (Prag) then\n+                        return True;\n+                     end if;\n+\n+                     Prag := Next_Pragma (Prag);\n+                  end loop;\n+               end if;\n+\n+               Prev := Overridden_Operation (Prev);\n+            end loop;\n+\n+            --  If the controlling type of the subprogram has progenitors,\n+            --  an interface operation implemented by the current operation\n+            --  may have a class-wide precondition.\n+\n+            Typ := Find_Dispatching_Type (E);\n+            if Has_Interfaces (Typ) then\n+               declare\n+                  Ints      : Elist_Id;\n+                  Elmt      : Elmt_Id;\n+                  Prim_List : Elist_Id;\n+                  Prim_Elmt : Elmt_Id;\n+                  Prim      : Entity_Id;\n+               begin\n+                  Collect_Interfaces (Typ, Ints);\n+                  Elmt := First_Elmt (Ints);\n+\n+                  --  Iterate over the primitive operations of each\n+                  --  interface.\n+\n+                  while Present (Elmt) loop\n+                     Prim_List :=\n+                      (Direct_Primitive_Operations (Node (Elmt)));\n+                     Prim_Elmt := First_Elmt (Prim_List);\n+                     while Present (Prim_Elmt) loop\n+                        Prim := Node (Prim_Elmt);\n+                        if Chars (Prim) = Chars (E)\n+                          and then Present (Contract (Prim))\n+                          and then Class_Present\n+                            (Pre_Post_Conditions (Contract (Prim)))\n+                        then\n+                           return True;\n+                        end if;\n+\n+                        Next_Elmt (Prim_Elmt);\n+                     end loop;\n+\n+                     Next_Elmt (Elmt);\n+                  end loop;\n+               end;\n+            end if;\n+\n+            return False;\n+         end Inherits_Class_Wide_Pre;\n+\n       begin\n          --  Change the name of pragmas Pre, Pre_Class, Post and Post_Class to\n          --  offer uniformity among the various kinds of pre/postconditions by\n@@ -4326,6 +4405,43 @@ package body Sem_Prag is\n                Error_Pragma (\"aspect % requires ''Class for null procedure\");\n             end if;\n \n+            --  Implement the legality checks mandated by AI12-0131:\n+            --    Pre'Class shall not be specified for an overriding primitive\n+            --    subprogram of a tagged type T unless the Pre'Class aspect is\n+            --    specified for the corresponding primitive subprogram of some\n+            --    ancestor of T.\n+\n+            declare\n+               E : constant Entity_Id := Defining_Entity (Subp_Decl);\n+               H : constant Entity_Id := Homonym (E);\n+\n+            begin\n+               if Class_Present (N)\n+                 and then Present (Overridden_Operation (E))\n+                 and then not Inherits_Class_Wide_Pre (E)\n+               then\n+                  Error_Msg_N\n+                    (\"illegal class-wide precondition on overriding \"\n+                      & \"operation\", Corresponding_Aspect (N));\n+\n+               --  If the operation is declared in the private part of an\n+               --  instance it may not override any visible operations,  but\n+               --  still have a parent operation that carries a precondition.\n+\n+               elsif In_Instance\n+                 and then In_Private_Part (Current_Scope)\n+                 and then Present (H)\n+                 and then Scope (E) = Scope (H)\n+                 and then Is_Inherited_Operation (H)\n+                 and then Present (Overridden_Operation (H))\n+                 and then not Inherits_Class_Wide_Pre (H)\n+               then\n+                  Error_Msg_N\n+                    (\"illegal class-wide precondition on overriding \"\n+                      & \"operation in instance\", Corresponding_Aspect (N));\n+               end if;\n+            end;\n+\n          --  Otherwise the placement is illegal\n \n          else"}, {"sha": "4bbaf1bda66b2a1420174fefb200fb762adcac9f", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=89b6c83e251d0b65860be2353fcf261169af2cf3", "patch": "@@ -15277,6 +15277,19 @@ package body Sem_Util is\n       return T = Universal_Integer or else T = Universal_Real;\n    end Is_Universal_Numeric_Type;\n \n+   --------------------------------------\n+   -- Is_Validation_Variable_Reference --\n+   --------------------------------------\n+\n+   function Is_Validation_Variable_Reference (N : Node_Id) return Boolean is\n+   begin\n+      return\n+        Is_Entity_Name (N)\n+          and then Present (Entity (N))\n+          and then Ekind (Entity (N)) = E_Variable\n+          and then Present (Validated_Object (Entity (N)));\n+   end Is_Validation_Variable_Reference;\n+\n    ----------------------------\n    -- Is_Variable_Size_Array --\n    ----------------------------\n@@ -15643,7 +15656,6 @@ package body Sem_Util is\n    ------------------------\n \n    function Is_Volatile_Object (N : Node_Id) return Boolean is\n-\n       function Is_Volatile_Prefix (N : Node_Id) return Boolean;\n       --  If prefix is an implicit dereference, examine designated type\n "}, {"sha": "e3afc1bec0a67e4059af6209de37be6ae491ef6d", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89b6c83e251d0b65860be2353fcf261169af2cf3/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=89b6c83e251d0b65860be2353fcf261169af2cf3", "patch": "@@ -1786,6 +1786,10 @@ package Sem_Util is\n    pragma Inline (Is_Universal_Numeric_Type);\n    --  True if T is Universal_Integer or Universal_Real\n \n+   function Is_Validation_Variable_Reference (N : Node_Id) return Boolean;\n+   --  Determine whether N denotes a reference to a variable which captures the\n+   --  value of an object for validation purposes.\n+\n    function Is_Variable_Size_Array (E : Entity_Id) return Boolean;\n    --  Returns true if E has variable size components\n "}]}