{"sha": "ac2949574da9a668daad421d7edb79f172f73c6f", "node_id": "C_kwDOANBUbNoAKGFjMjk0OTU3NGRhOWE2NjhkYWFkNDIxZDdlZGI3OWYxNzJmNzNjNmY", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2023-02-09T14:51:13Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2023-02-09T14:51:13Z"}, "message": "OpenMP/Fortran: Partially fix non-rect loop nests [PR107424]\n\nThis patch ensures that loop bounds depending on outer loop vars use the\nproper TREE_VEC format. It additionally gives a sorry if such an outer\nvar has a non-one/non-minus-one increment as currently a count variable\nis used in this case (see PR).\n\nFinally, it avoids 'count' and just uses a local loop variable if the\nstep increment is +/-1.\n\n\tPR fortran/107424\n\ngcc/fortran/ChangeLog:\n\n\t* trans-openmp.cc (struct dovar_init_d): Add 'sym' and\n\t'non_unit_incr' members.\n\t(gfc_nonrect_loop_expr): New.\n\t(gfc_trans_omp_do): Call it; use normal loop bounds\n\tfor unit stride - and only create local loop var.\n\nlibgomp/ChangeLog:\n\n\t* testsuite/libgomp.fortran/non-rectangular-loop-1.f90: New test.\n\t* testsuite/libgomp.fortran/non-rectangular-loop-1a.f90: New test.\n\t* testsuite/libgomp.fortran/non-rectangular-loop-2.f90: New test.\n\t* testsuite/libgomp.fortran/non-rectangular-loop-3.f90: New test.\n\t* testsuite/libgomp.fortran/non-rectangular-loop-4.f90: New test.\n\t* testsuite/libgomp.fortran/non-rectangular-loop-5.f90: New test.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/goacc/privatization-1-compute-loop.f90: Update dg-note.\n\t* gfortran.dg/goacc/privatization-1-routine_gang-loop.f90: Likewise.", "tree": {"sha": "7dae635bd8b000f7850ad18f9df63110474bab98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7dae635bd8b000f7850ad18f9df63110474bab98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac2949574da9a668daad421d7edb79f172f73c6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac2949574da9a668daad421d7edb79f172f73c6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac2949574da9a668daad421d7edb79f172f73c6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac2949574da9a668daad421d7edb79f172f73c6f/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1189d1b38e2b9507488ea294cda771c79e972c1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1189d1b38e2b9507488ea294cda771c79e972c1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1189d1b38e2b9507488ea294cda771c79e972c1d"}], "stats": {"total": 1990, "additions": 1941, "deletions": 49}, "files": [{"sha": "2d16f3be8ea6f3ab06ca15a2a829c87a9eecc6c7", "filename": "gcc/fortran/trans-openmp.cc", "status": "modified", "additions": 195, "deletions": 46, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac2949574da9a668daad421d7edb79f172f73c6f/gcc%2Ffortran%2Ftrans-openmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac2949574da9a668daad421d7edb79f172f73c6f/gcc%2Ffortran%2Ftrans-openmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.cc?ref=ac2949574da9a668daad421d7edb79f172f73c6f", "patch": "@@ -5116,18 +5116,146 @@ gfc_trans_omp_critical (gfc_code *code)\n }\n \n typedef struct dovar_init_d {\n+  gfc_symbol *sym;\n   tree var;\n   tree init;\n+  bool non_unit_iter;\n } dovar_init;\n \n+static bool\n+gfc_nonrect_loop_expr (stmtblock_t *pblock, gfc_se *sep, int loop_n,\n+\t\t       gfc_code *code, gfc_expr *expr, vec<dovar_init> *inits,\n+\t\t       int simple, gfc_expr *curr_loop_var)\n+{\n+  int i;\n+  for (i = 0; i < loop_n; i++)\n+    {\n+      gcc_assert (code->ext.iterator->var->expr_type == EXPR_VARIABLE);\n+      if (gfc_find_sym_in_expr (code->ext.iterator->var->symtree->n.sym, expr))\n+\tbreak;\n+      code = code->block->next;\n+    }\n+  if (i >= loop_n)\n+    return false;\n+\n+  /* Canonical format: TREE_VEC with [var, multiplier, offset].  */\n+  gfc_symbol *var = code->ext.iterator->var->symtree->n.sym;\n+\n+  tree tree_var = NULL_TREE;\n+  tree a1 = integer_one_node;\n+  tree a2 = integer_zero_node;\n+\n+  if (!simple)\n+    {\n+      /* FIXME: Handle non-unit iter steps, cf. PR fortran/107424.  */\n+      sorry_at (gfc_get_location (&curr_loop_var->where),\n+\t\t\"non-rectangular loop nest with step other than constant 1 \"\n+\t\t\"or -1 for %qs\", curr_loop_var->symtree->n.sym->name);\n+      return false;\n+    }\n+\n+  dovar_init *di;\n+  unsigned ix;\n+  FOR_EACH_VEC_ELT (*inits, ix, di)\n+    if (di->sym == var)\n+      {\n+\tif (!di->non_unit_iter)\n+\t  {\n+\t    tree_var = di->init;\n+\t    gcc_assert (DECL_P (tree_var));\n+\t    break;\n+\t  }\n+\telse\n+\t  {\n+\t    /* FIXME: Handle non-unit iter steps, cf. PR fortran/107424.  */\n+\t    sorry_at (gfc_get_location (&code->loc),\n+\t\t      \"non-rectangular loop nest with step other than constant \"\n+\t\t      \"1 or -1 for %qs\", var->name);\n+\t    inform (gfc_get_location (&expr->where), \"Used here\");\n+\t    return false;\n+\t  }\n+      }\n+  if (tree_var == NULL_TREE)\n+    tree_var = var->backend_decl;\n+\n+  if (expr->expr_type == EXPR_VARIABLE)\n+    gcc_assert (expr->symtree->n.sym == var);\n+  else if (expr->expr_type != EXPR_OP\n+\t   || (expr->value.op.op != INTRINSIC_TIMES\n+\t       && expr->value.op.op != INTRINSIC_PLUS\n+\t       && expr->value.op.op != INTRINSIC_MINUS))\n+    gcc_unreachable ();\n+  else\n+    {\n+      gfc_se se;\n+      gfc_expr *et = NULL, *eo = NULL, *e = expr;\n+      if (expr->value.op.op != INTRINSIC_TIMES)\n+\t{\n+\t  if (gfc_find_sym_in_expr (var, expr->value.op.op1))\n+\t    {\n+\t      e = expr->value.op.op1;\n+\t      eo = expr->value.op.op2;\n+\t    }\n+\t  else\n+\t    {\n+\t      eo = expr->value.op.op1;\n+\t      e = expr->value.op.op2;\n+\t    }\n+\t}\n+      if (e->value.op.op == INTRINSIC_TIMES)\n+\t{\n+\t  if (e->value.op.op1->expr_type == EXPR_VARIABLE\n+\t      && e->value.op.op1->symtree->n.sym == var)\n+\t    et = e->value.op.op2;\n+\t  else\n+\t    {\n+\t      et = e->value.op.op1;\n+\t      gcc_assert (e->value.op.op2->expr_type == EXPR_VARIABLE\n+\t\t\t  && e->value.op.op2->symtree->n.sym == var);\n+\t    }\n+\t}\n+      else\n+\tgcc_assert (e->expr_type == EXPR_VARIABLE && e->symtree->n.sym == var);\n+      if (et != NULL)\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_val (&se, et);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  a1 = se.expr;\n+\t}\n+      if (eo != NULL)\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_val (&se, eo);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  a2 = se.expr;\n+\t  if (expr->value.op.op == INTRINSIC_MINUS && expr->value.op.op2 == eo)\n+\t    /* outer-var - a2.  */\n+\t    a2 = fold_build1 (NEGATE_EXPR, TREE_TYPE (a2), a2);\n+\t  else if (expr->value.op.op == INTRINSIC_MINUS)\n+\t    /* a2 - outer-var.  */\n+\t    a1 = fold_build1 (NEGATE_EXPR, TREE_TYPE (a1), a1);\n+\t}\n+      a1 = DECL_P (a1) ? a1 : gfc_evaluate_now (a1, pblock);\n+      a2 = DECL_P (a2) ? a2 : gfc_evaluate_now (a2, pblock);\n+    }\n+\n+  gfc_init_se (sep, NULL);\n+  sep->expr = make_tree_vec (3);\n+  TREE_VEC_ELT (sep->expr, 0) = tree_var;\n+  TREE_VEC_ELT (sep->expr, 1) = fold_convert (TREE_TYPE (tree_var), a1);\n+  TREE_VEC_ELT (sep->expr, 2) = fold_convert (TREE_TYPE (tree_var), a2);\n+\n+  return true;\n+}\n \n static tree\n gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t\t  gfc_omp_clauses *do_clauses, tree par_clauses)\n {\n   gfc_se se;\n   tree dovar, stmt, from, to, step, type, init, cond, incr, orig_decls;\n-  tree count = NULL_TREE, cycle_label, tmp, omp_clauses;\n+  tree local_dovar = NULL_TREE, cycle_label, tmp, omp_clauses;\n   stmtblock_t block;\n   stmtblock_t body;\n   gfc_omp_clauses *clauses = code->ext.omp_clauses;\n@@ -5214,52 +5342,72 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n       gfc_init_se (&se, NULL);\n       gfc_conv_expr_lhs (&se, code->ext.iterator->var);\n       gfc_add_block_to_block (pblock, &se.pre);\n-      dovar = se.expr;\n+      local_dovar = dovar_decl = dovar = se.expr;\n       type = TREE_TYPE (dovar);\n       gcc_assert (TREE_CODE (type) == INTEGER_TYPE);\n \n       gfc_init_se (&se, NULL);\n-      gfc_conv_expr_val (&se, code->ext.iterator->start);\n+      gfc_conv_expr_val (&se, code->ext.iterator->step);\n       gfc_add_block_to_block (pblock, &se.pre);\n-      from = gfc_evaluate_now (se.expr, pblock);\n+      step = gfc_evaluate_now (se.expr, pblock);\n \n-      gfc_init_se (&se, NULL);\n-      gfc_conv_expr_val (&se, code->ext.iterator->end);\n-      gfc_add_block_to_block (pblock, &se.pre);\n-      to = gfc_evaluate_now (se.expr, pblock);\n+      if (integer_onep (step))\n+\tsimple = 1;\n+      else if (tree_int_cst_equal (step, integer_minus_one_node))\n+\tsimple = -1;\n \n       gfc_init_se (&se, NULL);\n-      gfc_conv_expr_val (&se, code->ext.iterator->step);\n-      gfc_add_block_to_block (pblock, &se.pre);\n-      step = gfc_evaluate_now (se.expr, pblock);\n-      dovar_decl = dovar;\n+      if (!clauses->non_rectangular\n+\t  || !gfc_nonrect_loop_expr (pblock, &se, i, orig_code->block->next,\n+\t\t\t\t     code->ext.iterator->start, &inits, simple,\n+\t\t\t\t     code->ext.iterator->var))\n+\t{\n+\t  gfc_conv_expr_val (&se, code->ext.iterator->start);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  if (!DECL_P (se.expr))\n+\t    se.expr = gfc_evaluate_now (se.expr, pblock);\n+\t}\n+      from = se.expr;\n \n-      /* Special case simple loops.  */\n-      if (VAR_P (dovar))\n+      gfc_init_se (&se, NULL);\n+      if (!clauses->non_rectangular\n+\t  || !gfc_nonrect_loop_expr (pblock, &se, i, orig_code->block->next,\n+\t\t\t\t     code->ext.iterator->end, &inits, simple,\n+\t\t\t\t     code->ext.iterator->var))\n \t{\n-\t  if (integer_onep (step))\n-\t    simple = 1;\n-\t  else if (tree_int_cst_equal (step, integer_minus_one_node))\n-\t    simple = -1;\n+\t  gfc_conv_expr_val (&se, code->ext.iterator->end);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t  if (!DECL_P (se.expr))\n+\t    se.expr = gfc_evaluate_now (se.expr, pblock);\n \t}\n-      else\n+      to = se.expr;\n+\n+      if (!DECL_P (dovar))\n \tdovar_decl\n \t  = gfc_trans_omp_variable (code->ext.iterator->var->symtree->n.sym,\n \t\t\t\t    false);\n-\n+      if (simple && !DECL_P (dovar))\n+\t{\n+\t  const char *name = code->ext.iterator->var->symtree->n.sym->name;\n+\t  local_dovar = gfc_create_var (type, name);\n+\t  dovar_init e = {code->ext.iterator->var->symtree->n.sym,\n+\t\t\t  dovar, local_dovar, false};\n+\t  inits.safe_push (e);\n+\t}\n       /* Loop body.  */\n       if (simple)\n \t{\n-\t  TREE_VEC_ELT (init, i) = build2_v (MODIFY_EXPR, dovar, from);\n+\t  TREE_VEC_ELT (init, i) = build2_v (MODIFY_EXPR, local_dovar, from);\n \t  /* The condition should not be folded.  */\n \t  TREE_VEC_ELT (cond, i) = build2_loc (input_location, simple > 0\n \t\t\t\t\t       ? LE_EXPR : GE_EXPR,\n-\t\t\t\t\t       logical_type_node, dovar, to);\n+\t\t\t\t\t       logical_type_node, local_dovar,\n+\t\t\t\t\t       to);\n \t  TREE_VEC_ELT (incr, i) = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t\t\t    type, dovar, step);\n+\t\t\t\t\t\t    type, local_dovar, step);\n \t  TREE_VEC_ELT (incr, i) = fold_build2_loc (input_location,\n \t\t\t\t\t\t    MODIFY_EXPR,\n-\t\t\t\t\t\t    type, dovar,\n+\t\t\t\t\t\t    type, local_dovar,\n \t\t\t\t\t\t    TREE_VEC_ELT (incr, i));\n \t  if (orig_decls && !clauses->orderedc)\n \t    orig_decls = NULL;\n@@ -5280,24 +5428,27 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t  tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR, type, tmp,\n \t\t\t\t step);\n \t  tmp = gfc_evaluate_now (tmp, pblock);\n-\t  count = gfc_create_var (type, \"count\");\n-\t  TREE_VEC_ELT (init, i) = build2_v (MODIFY_EXPR, count,\n+\t  local_dovar = gfc_create_var (type, \"count\");\n+\t  TREE_VEC_ELT (init, i) = build2_v (MODIFY_EXPR, local_dovar,\n \t\t\t\t\t     build_int_cst (type, 0));\n \t  /* The condition should not be folded.  */\n \t  TREE_VEC_ELT (cond, i) = build2_loc (input_location, LT_EXPR,\n \t\t\t\t\t       logical_type_node,\n-\t\t\t\t\t       count, tmp);\n+\t\t\t\t\t       local_dovar, tmp);\n \t  TREE_VEC_ELT (incr, i) = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t\t\t    type, count,\n+\t\t\t\t\t\t    type, local_dovar,\n \t\t\t\t\t\t    build_int_cst (type, 1));\n \t  TREE_VEC_ELT (incr, i) = fold_build2_loc (input_location,\n-\t\t\t\t\t\t    MODIFY_EXPR, type, count,\n+\t\t\t\t\t\t    MODIFY_EXPR, type,\n+\t\t\t\t\t\t    local_dovar,\n \t\t\t\t\t\t    TREE_VEC_ELT (incr, i));\n \n \t  /* Initialize DOVAR.  */\n-\t  tmp = fold_build2_loc (input_location, MULT_EXPR, type, count, step);\n+\t  tmp = fold_build2_loc (input_location, MULT_EXPR, type, local_dovar,\n+\t\t\t\t step);\n \t  tmp = fold_build2_loc (input_location, PLUS_EXPR, type, from, tmp);\n-\t  dovar_init e = {dovar, tmp};\n+\t  dovar_init e = {code->ext.iterator->var->symtree->n.sym,\n+\t\t\t  dovar, tmp, true};\n \t  inits.safe_push (e);\n \t  if (clauses->orderedc)\n \t    {\n@@ -5312,7 +5463,7 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n       if (dovar_found == 3\n \t  && op == EXEC_OMP_SIMD\n \t  && collapse == 1\n-\t  && !simple)\n+\t  && local_dovar != dovar)\n \t{\n \t  for (tmp = omp_clauses; tmp; tmp = OMP_CLAUSE_CHAIN (tmp))\n \t    if (OMP_CLAUSE_CODE (tmp) == OMP_CLAUSE_LINEAR\n@@ -5331,11 +5482,11 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t      OMP_CLAUSE_LINEAR_NO_COPYIN (tmp) = 1;\n \t      OMP_CLAUSE_DECL (tmp) = dovar_decl;\n \t      omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);\n+\t      if (local_dovar != dovar)\n+\t\tdovar_found = 3;\n \t    }\n-\t  if (!simple)\n-\t    dovar_found = 3;\n \t}\n-      else if (!dovar_found && !simple)\n+      else if (!dovar_found && local_dovar != dovar)\n \t{\n \t  tmp = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n \t  OMP_CLAUSE_DECL (tmp) = dovar_decl;\n@@ -5346,7 +5497,7 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t  tree c = NULL;\n \n \t  tmp = NULL;\n-\t  if (!simple)\n+\t  if (local_dovar != dovar)\n \t    {\n \t      /* If dovar is lastprivate, but different counter is used,\n \t\t dovar += step needs to be added to\n@@ -5356,21 +5507,19 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t      if (clauses->orderedc)\n \t\t{\n \t\t  if (clauses->collapse <= 1 || i >= clauses->collapse)\n-\t\t    tmp = count;\n+\t\t    tmp = local_dovar;\n \t\t  else\n \t\t    tmp = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t\t   type, count, build_one_cst (type));\n+\t\t\t\t\t   type, local_dovar,\n+\t\t\t\t\t   build_one_cst (type));\n \t\t  tmp = fold_build2_loc (input_location, MULT_EXPR, type,\n \t\t\t\t\t tmp, step);\n \t\t  tmp = fold_build2_loc (input_location, PLUS_EXPR, type,\n \t\t\t\t\t from, tmp);\n \t\t}\n \t      else\n-\t\t{\n-\t\t  tmp = gfc_evaluate_now (step, pblock);\n-\t\t  tmp = fold_build2_loc (input_location, PLUS_EXPR, type,\n-\t\t\t\t\t dovar, tmp);\n-\t\t}\n+\t\ttmp = fold_build2_loc (input_location, PLUS_EXPR, type,\n+\t\t\t\t       dovar, step);\n \t      tmp = fold_build2_loc (input_location, MODIFY_EXPR, type,\n \t\t\t\t     dovar, tmp);\n \t      for (c = omp_clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n@@ -5405,9 +5554,9 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t\t    break;\n \t\t  }\n \t    }\n-\t  gcc_assert (simple || c != NULL);\n+\t  gcc_assert (local_dovar == dovar || c != NULL);\n \t}\n-      if (!simple)\n+      if (local_dovar != dovar)\n \t{\n \t  if (op != EXEC_OMP_SIMD || dovar_found == 1)\n \t    tmp = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n@@ -5420,7 +5569,7 @@ gfc_trans_omp_do (gfc_code *code, gfc_exec_op op, stmtblock_t *pblock,\n \t    }\n \t  else\n \t    tmp = build_omp_clause (input_location, OMP_CLAUSE_LASTPRIVATE);\n-\t  OMP_CLAUSE_DECL (tmp) = count;\n+\t  OMP_CLAUSE_DECL (tmp) = local_dovar;\n \t  omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);\n \t}\n "}, {"sha": "ad5e11abf91384d64aea701a1047c31ece14e3eb", "filename": "gcc/testsuite/gfortran.dg/goacc/privatization-1-compute-loop.f90", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac2949574da9a668daad421d7edb79f172f73c6f/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fprivatization-1-compute-loop.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac2949574da9a668daad421d7edb79f172f73c6f/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fprivatization-1-compute-loop.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fprivatization-1-compute-loop.f90?ref=ac2949574da9a668daad421d7edb79f172f73c6f", "patch": "@@ -47,8 +47,10 @@ subroutine f (i, j, a)\n        end do\n     end do\n     !$acc end parallel\n-    ! { dg-note {variable 'count\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute }\n-    ! { dg-note {variable 'count\\.[0-9]+' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n+    ! { dg-note {variable 'i\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute }\n+    ! { dg-note {variable 'j\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute }\n+    ! { dg-note {variable 'i\\.[0-9]+' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n+    ! { dg-note {variable 'j\\.[0-9]+' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n     ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n     ! { dg-note {variable 'a' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }"}, {"sha": "c5c2f2b9845573c39d606008ce1e19f32d881add", "filename": "gcc/testsuite/gfortran.dg/goacc/privatization-1-routine_gang-loop.f90", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac2949574da9a668daad421d7edb79f172f73c6f/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fprivatization-1-routine_gang-loop.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac2949574da9a668daad421d7edb79f172f73c6f/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fprivatization-1-routine_gang-loop.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fprivatization-1-routine_gang-loop.f90?ref=ac2949574da9a668daad421d7edb79f172f73c6f", "patch": "@@ -46,7 +46,8 @@ subroutine f (i, j, a)\n           y = a\n        end do\n     end do\n-    ! { dg-note {variable 'count\\.[0-9]+' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n+    ! { dg-note {variable 'i\\.[0-9]+' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n+    ! { dg-note {variable 'j\\.[0-9]+' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n     ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n     ! { dg-note {variable 'j' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n     ! { dg-note {variable 'a' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }"}, {"sha": "dbbd18a14441e0ed88215975b78566ea327237ea", "filename": "libgomp/testsuite/libgomp.fortran/non-rectangular-loop-1.f90", "status": "added", "additions": 668, "deletions": 0, "changes": 668, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac2949574da9a668daad421d7edb79f172f73c6f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac2949574da9a668daad421d7edb79f172f73c6f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-1.f90?ref=ac2949574da9a668daad421d7edb79f172f73c6f", "patch": "@@ -0,0 +1,668 @@\n+! { dg-do run }\n+! { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+! { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+! PR fortran/107424\n+\n+! Nonrectangular loop nests checks\n+\n+! See PR or non-rectangular-loop-1a.f90 for the commented tests\n+! Hint: Those use step for loop vars part of nonrectangular loop nests\n+\n+module m\n+  implicit none (type, external)\n+contains\n+\n+! The 'k' loop uses i or j as start value\n+! but a constant end value such that 'lastprivate'\n+! should be well-defined\n+subroutine lastprivate_check_simd_1\n+  integer :: n,m,p, i,j,k\n+\n+  n = 11\n+  m = 23\n+  p = 27\n+\n+  ! Use 'i' or 'j', unit step on 'i' or on 'j' -> 4 loops\n+  ! Then same, except use non-unit step for 'k'\n+\n+!  !$omp simd collapse(3) lastprivate(k)\n+!  do i = 1, n\n+!    do j = 1, m, 2\n+!      do k = j - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+\n+!  !$omp simd collapse(3) lastprivate(k)\n+!  do i = 1, n, 2\n+!    do j = 1, m\n+!      do k = i - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+\n+  !$omp simd collapse(3) lastprivate(k)\n+  do i = 1, n, 2\n+    do j = 1, m\n+      do k = j - 41, p\n+        if (k < 1 - 41 .or. k > p) then\n+          print *, i, j, k,p, \" -> i, j, k, p   (k < 1 - 41 .or. k > p)\"\n+          error stop\n+        end if\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  k = -43\n+  m = 0\n+  !$omp simd collapse(3) lastprivate(k)\n+  do i = 1, n, 2\n+    do j = 1, m\n+      do k = j - 41, p\n+        if (k < 1 - 41 .or. k > p) then\n+          print *, i, j, k,p, \" -> i, j, k, p   (k < 1 - 41 .or. k > p)\"\n+          error stop\n+        end if\n+      end do\n+    end do\n+  end do\n+  if (k /= -43) error stop\n+\n+  m = 23\n+\n+  !$omp simd collapse(3) lastprivate(k)\n+  do i = 1, n\n+    do j = 1, m, 2\n+      do k = i - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  n = -5\n+  k = - 70\n+  !$omp simd collapse(3) lastprivate(k)\n+  do i = 1, n\n+    do j = 1, m, 2\n+      do k = i - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= -70) error stop\n+\n+  n = 11\n+\n+  ! Same but 'private' for all (i,j) vars\n+\n+!  !$omp simd collapse(3) lastprivate(k) private(i,j)\n+!  do i = 1, n\n+!    do j = 1, m, 2\n+!      do k = j - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+!\n+!  !$omp simd collapse(3) lastprivate(k) private(i,j)\n+!  do i = 1, n, 2\n+!    do j = 1, m\n+!      do k = i - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+\n+  !$omp simd collapse(3) lastprivate(k) private(i,j)\n+  do i = 1, n, 2\n+    do j = 1, m\n+      do k = j - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  !$omp simd collapse(3) lastprivate(k) private(i,j)\n+  do i = 1, n\n+    do j = 1, m, 2\n+      do k = i - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  ! Same - but with lastprivate(i,j)\n+\n+!  !$omp simd collapse(3) lastprivate(k) lastprivate(i,j)\n+!  do i = 1, n\n+!    do j = 1, m, 2\n+!      do k = j - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+!  if (i /= n + 1 .or. j /= m + 2) error stop\n+\n+!  !$omp simd collapse(3) lastprivate(k) lastprivate(i,j)\n+!  do i = 1, n, 2\n+!    do j = 1, m\n+!      do k = i - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+!  if (i /= n + 2 .or. j /= m + 1) error stop\n+\n+  !$omp simd collapse(3) lastprivate(k) lastprivate(i,j)\n+  do i = 1, n, 2\n+    do j = 1, m\n+      do k = j - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+  if (i /= n + 2 .or. j /= m + 1) error stop\n+\n+  !$omp simd collapse(3) lastprivate(k) lastprivate(i,j)\n+  do i = 1, n\n+    do j = 1, m, 2\n+      do k = i - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+  if (i /= n + 1 .or. j /= m + 2) error stop\n+end subroutine lastprivate_check_simd_1\n+\n+\n+! Same but with do simd\n+subroutine lastprivate_check_do_simd_1\n+  integer :: n,m,p, i,j,k\n+\n+  n = 11\n+  m = 23\n+  p = 27\n+\n+  ! Use 'i' or 'j', unit step on 'i' or on 'j' -> 4 loops\n+  ! Then same, except use non-unit step for 'k'\n+\n+!  !$omp parallel do simd collapse(3) lastprivate(k)\n+!  do i = 1, n\n+!    do j = 1, m, 2\n+!      do k = j - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+\n+!  !$omp parallel do simd collapse(3) lastprivate(k)\n+!  do i = 1, n, 2\n+!    do j = 1, m\n+!      do k = i - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+\n+  !$omp parallel do simd collapse(3) lastprivate(k)\n+  do i = 1, n, 2\n+    do j = 1, m\n+      do k = j - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  !$omp parallel do simd collapse(3) lastprivate(k)\n+  do i = 1, n\n+    do j = 1, m, 2\n+      do k = i - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  ! Same but 'private' for all (i,j) vars\n+\n+!  !$omp parallel do simd collapse(3) lastprivate(k) private(i,j)\n+!  do i = 1, n\n+!    do j = 1, m, 2\n+!      do k = j - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+\n+!  !$omp parallel do simd collapse(3) lastprivate(k) private(i,j)\n+!  do i = 1, n, 2\n+!    do j = 1, m\n+!      do k = i - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+\n+  !$omp parallel do simd collapse(3) lastprivate(k) private(i,j)\n+  do i = 1, n, 2\n+    do j = 1, m\n+      do k = j - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  !$omp parallel do simd collapse(3) lastprivate(k) private(i,j)\n+  do i = 1, n\n+    do j = 1, m, 2\n+      do k = i - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  ! Same - but with lastprivate(i,j)\n+\n+!  !$omp parallel do simd collapse(3) lastprivate(k) lastprivate(i,j)\n+!  do i = 1, n\n+!    do j = 1, m, 2\n+!      do k = j - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+!  if (i /= n + 1 .or. j /= m + 2) error stop\n+\n+!  !$omp parallel do simd collapse(3) lastprivate(k) lastprivate(i,j)\n+!  do i = 1, n, 2\n+!    do j = 1, m\n+!      do k = i - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+!  if (i /= n + 2 .or. j /= m + 1) error stop\n+\n+  !$omp parallel do simd collapse(3) lastprivate(k) lastprivate(i,j)\n+  do i = 1, n, 2\n+    do j = 1, m\n+      do k = j - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+  if (i /= n + 2 .or. j /= m + 1) error stop\n+\n+  !$omp parallel do simd collapse(3) lastprivate(k) lastprivate(i,j)\n+  do i = 1, n\n+    do j = 1, m, 2\n+      do k = i - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+  if (i /= n + 1 .or. j /= m + 2) error stop\n+end subroutine lastprivate_check_do_simd_1\n+\n+\n+\n+! Same but with do\n+subroutine lastprivate_check_do_1\n+  integer :: n,m,p, i,j,k\n+\n+  n = 11\n+  m = 23\n+  p = 27\n+\n+  ! Use 'i' or 'j', unit step on 'i' or on 'j' -> 4 loops\n+  ! Then same, except use non-unit step for 'k'\n+\n+!  !$omp parallel do collapse(3) lastprivate(k)\n+!  do i = 1, n\n+!    do j = 1, m, 2\n+!      do k = j - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+\n+!  !$omp parallel do collapse(3) lastprivate(k)\n+!  do i = 1, n, 2\n+!    do j = 1, m\n+!      do k = i - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+\n+  !$omp parallel do collapse(3) lastprivate(k)\n+  do i = 1, n, 2\n+    do j = 1, m\n+      do k = j - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  !$omp parallel do collapse(3) lastprivate(k)\n+  do i = 1, n\n+    do j = 1, m, 2\n+      do k = i - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  ! Same but 'private' for all (i,j) vars\n+\n+!  !$omp parallel do collapse(3) lastprivate(k) private(i,j)\n+!  do i = 1, n\n+!    do j = 1, m, 2\n+!      do k = j - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+\n+!  !$omp parallel do collapse(3) lastprivate(k) private(i,j)\n+!  do i = 1, n, 2\n+!    do j = 1, m\n+!      do k = i - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+\n+  !$omp parallel do collapse(3) lastprivate(k) private(i,j)\n+  do i = 1, n, 2\n+    do j = 1, m\n+      do k = j - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  !$omp parallel do collapse(3) lastprivate(k) private(i,j)\n+  do i = 1, n\n+    do j = 1, m, 2\n+      do k = i - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  ! Same - but with lastprivate(i,j)\n+\n+!  !$omp parallel do collapse(3) lastprivate(k) lastprivate(i,j)\n+!  do i = 1, n\n+!    do j = 1, m, 2\n+!      do k = j - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+!  if (i /= n + 1 .or. j /= m + 2) error stop\n+\n+!  !$omp parallel do collapse(3) lastprivate(k) lastprivate(i,j)\n+!  do i = 1, n, 2\n+!    do j = 1, m\n+!      do k = i - 41, p\n+!        if (k < 1 - 41 .or. k > p) error stop\n+!      end do\n+!    end do\n+!  end do\n+!  if (k /= p + 1) error stop\n+!  if (i /= n + 2 .or. j /= m + 1) error stop\n+\n+  !$omp parallel do collapse(3) lastprivate(k) lastprivate(i,j)\n+  do i = 1, n, 2\n+    do j = 1, m\n+      do k = j - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+  if (i /= n + 2 .or. j /= m + 1) error stop\n+\n+  !$omp parallel do collapse(3) lastprivate(k) lastprivate(i,j)\n+  do i = 1, n\n+    do j = 1, m, 2\n+      do k = i - 41, p\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+  if (i /= n + 1 .or. j /= m + 2) error stop\n+end subroutine lastprivate_check_do_1\n+\n+\n+\n+subroutine lastprivate_check_2\n+  integer :: n,m,p, i,j,k,ll\n+\n+  n = 11\n+  m = 23\n+  p = 27\n+\n+!  !$omp parallel do simd collapse(3) lastprivate(p)\n+!  do i = 1, n\n+!    do j = 1, m,2\n+!      do k = 1, j + 41\n+!        do ll = 1, p, 2\n+!          if (k > 23 + 41 .or. k < 1) error stop\n+!        end do\n+!      end do\n+!    end do\n+!  end do\n+!  if (ll /= 29) error stop\n+\n+!  !$omp simd collapse(3) lastprivate(p)\n+!  do i = 1, n\n+!    do j = 1, m,2\n+!      do k = 1, j + 41\n+!        do ll = 1, p, 2\n+!          if (k > 23 + 41 .or. k < 1) error stop\n+!        end do\n+!      end do\n+!    end do\n+!  end do\n+!  if (ll /= 29) error stop\n+\n+!  !$omp simd collapse(3) lastprivate(k)\n+!  do i = 1, n,2\n+!    do j = 1, m\n+!      do k = 1, i + 41\n+!        if (k > 11 + 41 .or. k < 1) error stop\n+!      end do\n+!    end do\n+!  end do\n+!if (k /= 53) then\n+!  print *, k, 53\n+!  error stop\n+!endif\n+\n+!$omp simd collapse(3) lastprivate(k)\n+do i = 1, n,2\n+  do j = 1, m\n+    do k = 1, j + 41\n+      if (k > 23 + 41 .or. k < 1) error stop\n+    end do\n+  end do\n+end do\n+if (k /= 65) then\n+  print *, k, 65\n+  error stop\n+endif\n+\n+\n+!$omp simd collapse(3) lastprivate(k)\n+do i = 1, n\n+  do j = 1, m,2\n+    do k = 1, i + 41\n+      if (k > 11 + 41 .or. k < 1) error stop\n+    end do\n+  end do\n+end do\n+if (k /= 53) then\n+  print *, k, 53\n+  error stop\n+endif\n+\n+! - Same but without 'private':\n+!!$omp simd collapse(3) lastprivate(k)\n+!do i = 1, n\n+!  do j = 1, m,2\n+!    do k = 1, j + 41\n+!      if (k > 23 + 41 .or. k < 1) error stop\n+!    end do\n+!  end do\n+!end do\n+!if (k /= 65) then\n+!  print *, k, 65\n+!  error stop\n+!endif\n+\n+\n+!!$omp simd collapse(3) lastprivate(k)\n+!do i = 1, n,2\n+!  do j = 1, m\n+!    do k = 1, i + 41\n+!      if (k > 11 + 41 .or. k < 1) error stop\n+!    end do\n+!  end do\n+!end do\n+!if (k /= 53) then\n+!  print *, k, 53\n+!  error stop\n+!endif\n+\n+!$omp simd collapse(3) lastprivate(k)\n+do i = 1, n,2\n+  do j = 1, m\n+    do k = 1, j + 41\n+      if (k > 23 + 41 .or. k < 1) error stop\n+    end do\n+  end do\n+end do\n+if (k /= 65) then\n+  print *, k, 65\n+  error stop\n+endif\n+\n+\n+!$omp simd collapse(3) lastprivate(k)\n+do i = 1, n\n+  do j = 1, m,2\n+    do k = 1, i + 41\n+      if (k > 11 + 41 .or. k < 1) error stop\n+    end do\n+  end do\n+end do\n+if (k /= 53) then\n+  print *, k, 53\n+  error stop\n+endif\n+\n+! - all with lastprivate\n+!!$omp simd collapse(3) lastprivate(k) lastprivate(i, j)\n+!do i = 1, n\n+!  do j = 1, m,2\n+!    do k = 1, j + 41\n+!      if (k > 23 + 41 .or. k < 1) error stop\n+!    end do\n+!  end do\n+!end do\n+!if (k /= 65) then\n+!  print *, k, 65\n+!  error stop\n+!endif\n+\n+\n+!!$omp simd collapse(3) lastprivate(k) lastprivate(i, j)\n+!do i = 1, n,2\n+!  do j = 1, m\n+!    do k = 1, i + 41\n+!      if (k > 11 + 41 .or. k < 1) error stop\n+!    end do\n+!  end do\n+!end do\n+!if (k /= 53) then\n+!  print *, k, 53\n+!  error stop\n+!endif\n+\n+!$omp simd collapse(3) lastprivate(k) lastprivate(i, j)\n+do i = 1, n,2\n+  do j = 1, m\n+    do k = 1, j + 41\n+      if (k > 23 + 41 .or. k < 1) error stop\n+    end do\n+  end do\n+end do\n+if (k /= 65) then\n+  print *, k, 65\n+  error stop\n+endif\n+\n+\n+!$omp simd collapse(3) lastprivate(k) lastprivate(i, j)\n+do i = 1, n\n+  do j = 1, m,2\n+    do k = 1, i + 41\n+      if (k > 11 + 41 .or. k < 1) error stop\n+    end do\n+  end do\n+end do\n+if (k /= 53) then\n+  print *, k, 53\n+  error stop\n+endif\n+\n+end\n+end module m\n+\n+program main\n+  use m\n+  implicit none (type, external)\n+  call lastprivate_check_simd_1\n+  call lastprivate_check_do_simd_1\n+  call lastprivate_check_do_1\n+  call lastprivate_check_2\n+end"}, {"sha": "77aa887942e2be9f1ad2ce8b293cd57c5f192fb9", "filename": "libgomp/testsuite/libgomp.fortran/non-rectangular-loop-1a.f90", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac2949574da9a668daad421d7edb79f172f73c6f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-1a.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac2949574da9a668daad421d7edb79f172f73c6f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-1a.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-1a.f90?ref=ac2949574da9a668daad421d7edb79f172f73c6f", "patch": "@@ -0,0 +1,374 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+! { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+! PR fortran/107424\n+\n+! Nonrectangular loop nests checks\n+\n+! ========================================================\n+! NOTE: The testcases are from non-rectangular-loop-1.f90,\n+! but commented there. Feel free to remove this\n+! file + uncomment them in non-rectangular-loop-1.f90\n+! Otherwise, you need to change it to 'dg-do run'!\n+! ========================================================\n+\n+module m\n+  implicit none (type, external)\n+contains\n+\n+! The 'k' loop uses i or j as start value\n+! but a constant end value such that 'lastprivate'\n+! should be well-defined\n+subroutine lastprivate_check_simd_1\n+  integer :: n,m,p, i,j,k\n+\n+  n = 11\n+  m = 23\n+  p = 27\n+\n+  ! Use 'i' or 'j', unit step on 'i' or on 'j' -> 4 loops\n+  ! Then same, except use non-unit step for 'k'\n+\n+  !$omp simd collapse(3) lastprivate(k)\n+  do i = 1, n\n+    do j = 1, m, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+      do k = j - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  !$omp simd collapse(3) lastprivate(k)\n+  do i = 1, n, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'i'\" }\n+    do j = 1, m\n+      do k = i - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  ! Same but 'private' for all (i,j) vars\n+\n+  !$omp simd collapse(3) lastprivate(k) private(i,j)\n+  do i = 1, n\n+    do j = 1, m, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+      do k = j - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  !$omp simd collapse(3) lastprivate(k) private(i,j)\n+  do i = 1, n, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'i'\" }\n+    do j = 1, m\n+      do k = i - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  ! Same - but with lastprivate(i,j)\n+\n+  !$omp simd collapse(3) lastprivate(k) lastprivate(i,j)\n+  do i = 1, n\n+    do j = 1, m, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+      do k = j - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+  if (i /= n + 1 .or. j /= m + 2) error stop\n+\n+  !$omp simd collapse(3) lastprivate(k) lastprivate(i,j)\n+  do i = 1, n, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'i'\" }\n+    do j = 1, m\n+      do k = i - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+  if (i /= n + 2 .or. j /= m + 1) error stop\n+\n+end subroutine lastprivate_check_simd_1\n+\n+\n+! Same but with do simd\n+subroutine lastprivate_check_do_simd_1\n+  integer :: n,m,p, i,j,k\n+\n+  n = 11\n+  m = 23\n+  p = 27\n+\n+  ! Use 'i' or 'j', unit step on 'i' or on 'j' -> 4 loops\n+  ! Then same, except use non-unit step for 'k'\n+\n+  !$omp parallel do simd collapse(3) lastprivate(k)\n+  do i = 1, n\n+    do j = 1, m, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+      do k = j - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  !$omp parallel do simd collapse(3) lastprivate(k)\n+  do i = 1, n, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'i'\" }\n+    do j = 1, m\n+      do k = i - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  ! Same but 'private' for all (i,j) vars\n+\n+  !$omp parallel do simd collapse(3) lastprivate(k) private(i,j)\n+  do i = 1, n\n+    do j = 1, m, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+      do k = j - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  !$omp parallel do simd collapse(3) lastprivate(k) private(i,j)\n+  do i = 1, n, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'i'\" }\n+    do j = 1, m\n+      do k = i - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  ! Same - but with lastprivate(i,j)\n+\n+  !$omp parallel do simd collapse(3) lastprivate(k) lastprivate(i,j)\n+  do i = 1, n\n+    do j = 1, m, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+      do k = j - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+  if (i /= n + 1 .or. j /= m + 2) error stop\n+\n+  !$omp parallel do simd collapse(3) lastprivate(k) lastprivate(i,j)\n+  do i = 1, n, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'i'\" }\n+    do j = 1, m\n+      do k = i - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+  if (i /= n + 2 .or. j /= m + 1) error stop\n+\n+end subroutine lastprivate_check_do_simd_1\n+\n+\n+\n+! Same but with do\n+subroutine lastprivate_check_do_1\n+  integer :: n,m,p, i,j,k\n+\n+  n = 11\n+  m = 23\n+  p = 27\n+\n+  ! Use 'i' or 'j', unit step on 'i' or on 'j' -> 4 loops\n+  ! Then same, except use non-unit step for 'k'\n+\n+  !$omp parallel do collapse(3) lastprivate(k)\n+  do i = 1, n\n+    do j = 1, m, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+      do k = j - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  !$omp parallel do collapse(3) lastprivate(k)\n+  do i = 1, n, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'i'\" }\n+    do j = 1, m\n+      do k = i - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  ! Same but 'private' for all (i,j) vars\n+\n+  !$omp parallel do collapse(3) lastprivate(k) private(i,j)\n+  do i = 1, n\n+    do j = 1, m, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+      do k = j - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  !$omp parallel do collapse(3) lastprivate(k) private(i,j)\n+  do i = 1, n, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'i'\" }\n+    do j = 1, m\n+      do k = i - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+\n+  ! Same - but with lastprivate(i,j)\n+\n+  !$omp parallel do collapse(3) lastprivate(k) lastprivate(i,j)\n+  do i = 1, n\n+    do j = 1, m, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+      do k = j - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+  if (i /= n + 1 .or. j /= m + 2) error stop\n+\n+  !$omp parallel do collapse(3) lastprivate(k) lastprivate(i,j)\n+  do i = 1, n, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'i'\" }\n+    do j = 1, m\n+      do k = i - 41, p  ! { dg-note \"Used here\" }\n+        if (k < 1 - 41 .or. k > p) error stop\n+      end do\n+    end do\n+  end do\n+  if (k /= p + 1) error stop\n+  if (i /= n + 2 .or. j /= m + 1) error stop\n+\n+end subroutine lastprivate_check_do_1\n+\n+\n+\n+subroutine lastprivate_check_2\n+  integer :: n,m,p, i,j,k,ll\n+\n+  n = 11\n+  m = 23\n+  p = 27\n+\n+  !$omp parallel do simd collapse(3) lastprivate(p)\n+  do i = 1, n\n+    do j = 1, m,2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+      do k = 1, j + 41  ! { dg-note \"Used here\" }\n+        do ll = 1, p, 2\n+          if (k > 23 + 41 .or. k < 1) error stop\n+        end do\n+      end do\n+    end do\n+  end do\n+  if (ll /= 29) error stop\n+\n+  !$omp simd collapse(3) lastprivate(p)\n+  do i = 1, n\n+    do j = 1, m,2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+      do k = 1, j + 41  ! { dg-note \"Used here\" }\n+        do ll = 1, p, 2\n+          if (k > 23 + 41 .or. k < 1) error stop\n+        end do\n+      end do\n+    end do\n+  end do\n+  if (ll /= 29) error stop\n+\n+  !$omp simd collapse(3) lastprivate(k)\n+  do i = 1, n,2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'i'\" }\n+    do j = 1, m\n+      do k = 1, i + 41  ! { dg-note \"Used here\" }\n+        if (k > 11 + 41 .or. k < 1) error stop\n+      end do\n+    end do\n+  end do\n+if (k /= 53) then\n+  print *, k, 53\n+  error stop\n+endif\n+\n+! - Same but without 'private':\n+!$omp simd collapse(3) lastprivate(k)\n+do i = 1, n\n+  do j = 1, m,2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+    do k = 1, j + 41  ! { dg-note \"Used here\" }\n+      if (k > 23 + 41 .or. k < 1) error stop\n+    end do\n+  end do\n+end do\n+if (k /= 65) then\n+  print *, k, 65\n+  error stop\n+endif\n+\n+\n+!$omp simd collapse(3) lastprivate(k)\n+do i = 1, n,2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'i'\" }\n+  do j = 1, m\n+    do k = 1, i + 41  ! { dg-note \"Used here\" }\n+      if (k > 11 + 41 .or. k < 1) error stop\n+    end do\n+  end do\n+end do\n+if (k /= 53) then\n+  print *, k, 53\n+  error stop\n+endif\n+\n+! - all with lastprivate\n+!$omp simd collapse(3) lastprivate(k) lastprivate(i, j)\n+do i = 1, n\n+  do j = 1, m,2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+    do k = 1, j + 41  ! { dg-note \"Used here\" }\n+      if (k > 23 + 41 .or. k < 1) error stop\n+    end do\n+  end do\n+end do\n+if (k /= 65) then\n+  print *, k, 65\n+  error stop\n+endif\n+\n+\n+!$omp simd collapse(3) lastprivate(k) lastprivate(i, j)\n+do i = 1, n,2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'i'\" }\n+  do j = 1, m\n+    do k = 1, i + 41  ! { dg-note \"Used here\" }\n+      if (k > 11 + 41 .or. k < 1) error stop\n+    end do\n+  end do\n+end do\n+if (k /= 53) then\n+  print *, k, 53\n+  error stop\n+endif\n+\n+end\n+end module m\n+\n+program main\n+  use m\n+  implicit none (type, external)\n+  call lastprivate_check_simd_1\n+  call lastprivate_check_do_simd_1\n+  call lastprivate_check_do_1\n+  call lastprivate_check_2\n+end"}, {"sha": "0cea61e5f0dc894a4510a66dd6cd4203746b9f31", "filename": "libgomp/testsuite/libgomp.fortran/non-rectangular-loop-2.f90", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac2949574da9a668daad421d7edb79f172f73c6f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac2949574da9a668daad421d7edb79f172f73c6f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-2.f90?ref=ac2949574da9a668daad421d7edb79f172f73c6f", "patch": "@@ -0,0 +1,243 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-original -fcheck=all\" }\n+\n+! PR fortran/107424\n+\n+! Nonrectangular loop nests checks\n+\n+! Valid patterns are:\n+!  (1)  a2 - var-outer\n+!  (2)  a1 * var-outer\n+!  (3)  a1 * var-outer + a2\n+!  (4)  a2 + a1 * var-outer\n+!  (5)  a1 * var-outer - a2\n+!  (6)  a2 - a1 * var-outer\n+!  (7)  var-outer * a1\n+!  (8)  var-outer * a1 + a2\n+!  (9)  a2 + var-outer * a1\n+! (10)  var-outer * a1 - a2\n+! (11)  a2 - var-outer * a1\n+\n+module m\n+contains\n+\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(one_two_inner = one_two_outer \\\\* -1 \\\\+ one_a2; one_two_inner <= one_two_outer \\\\* two_a1 \\\\+ 0; one_two_inner = one_two_inner \\\\+ 1\\\\)\" 1 original } }\n+\n+!  (1)  a2 - var-outer\n+!  (2)  a1 * var-outer\n+subroutine one_two()\n+  implicit none\n+  integer :: one_a2\n+  integer :: two_a1\n+  integer :: one_two_outer, one_two_inner\n+  integer :: i, j\n+  integer, allocatable :: var(:,:)\n+\n+  one_a2 = 13\n+  two_a1 = 5\n+  allocate(var(1:10, one_a2 - 10:two_a1 * 10), &\n+           source=0)\n+  if (size(var) <= 4) error stop\n+\n+  !$omp simd collapse(2)\n+  do one_two_outer = 1, 10\n+    do one_two_inner = one_a2 - one_two_outer, two_a1 * one_two_outer\n+      !$omp atomic update\n+      var(one_two_outer,one_two_inner) = var(one_two_outer,one_two_inner) + 2\n+    end do\n+  end do\n+\n+  do i = 1, 10\n+    do j = one_a2 - i, two_a1 * i\n+      if (var(i,j) /= 2) error stop\n+    end do\n+  end do\n+end\n+\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(three_four_inner = three_four_outer \\\\* three_a1 \\\\+ three_a2; three_four_inner <= three_four_outer \\\\* four_a1 \\\\+ four_a2; three_four_inner = three_four_inner \\\\+ 1\\\\)\" 1 original } }\n+\n+!  (3)  a1 * var-outer + a2\n+!  (4)  a2 + a1 * var-outer\n+subroutine three_four()\n+  implicit none\n+  integer :: three_a1, three_a2\n+  integer :: four_a1, four_a2\n+  integer :: three_four_outer, three_four_inner\n+  integer :: i, j\n+  integer, allocatable :: var(:,:)\n+\n+  three_a1 = 2\n+  three_a2 = 3\n+  four_a1 = 3\n+  four_a2 = 5\n+  allocate(var(1:10, three_a1 * 1 + three_a2:four_a2 + four_a1 * 10), &\n+           source=0)\n+  if (size(var) <= 4) error stop\n+\n+  !$omp simd collapse(2)\n+  do three_four_outer = 1, 10\n+    do three_four_inner = three_a1 * three_four_outer + three_a2, four_a2 + four_a1 * three_four_outer\n+      !$omp atomic update\n+      var(three_four_outer, three_four_inner) = var(three_four_outer, three_four_inner) + 2\n+    end do\n+  end do\n+  do i = 1, 10\n+    do j = three_a1 * i + three_a2, four_a2 + four_a1 * i\n+      if (var(i,j) /= 2) error stop\n+    end do\n+  end do\n+end\n+\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(five_six_inner = five_six_outer \\\\* five_a1 \\\\+ D\\\\.\\[0-9\\]+; five_six_inner <= five_six_outer \\\\* D\\\\.\\[0-9\\]+ \\\\+ six_a2; five_six_inner = five_six_inner \\\\+ 1\\\\)\" 1 original } }\n+\n+!  (5)  a1 * var-outer - a2\n+!  (6)  a2 - a1 * var-outer\n+subroutine five_six()\n+  implicit none\n+  integer :: five_a1, five_a2\n+  integer :: six_a1, six_a2\n+  integer :: five_six_outer, five_six_inner\n+  integer :: i, j\n+  integer, allocatable :: var(:,:)\n+\n+  five_a1 = 2\n+  five_a2 = -3\n+  six_a1 = 3\n+  six_a2 = 20\n+  allocate(var(1:10, five_a1 * 1 - five_a2:six_a2 - six_a1 * 1), &\n+           source=0)\n+  if (size(var) <= 4) error stop\n+\n+  !$omp simd collapse(2)\n+  do five_six_outer = 1, 10\n+    do five_six_inner = five_a1 * five_six_outer - five_a2, six_a2 - six_a1 * five_six_outer\n+      !$omp atomic update\n+      var(five_six_outer, five_six_inner) = var(five_six_outer, five_six_inner) + 2\n+    end do\n+  end do\n+\n+  do i = 1, 10\n+    do j = five_a1 * i - five_a2, six_a2 - six_a1 * i\n+      if (var(i,j) /= 2) error stop\n+    end do\n+  end do\n+end\n+\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(seven_eight_inner = seven_eight_outer \\\\* seven_a1 \\\\+ 0; seven_eight_inner <= seven_eight_outer \\\\* eight_a1 \\\\+ eight_a2; seven_eight_inner = seven_eight_inner \\\\+ 1\\\\)\" 1 original } }\n+\n+!  (7)  var-outer * a1\n+!  (8)  var-outer * a1 + a2\n+subroutine seven_eight()\n+  implicit none\n+  integer :: seven_a1\n+  integer :: eight_a1, eight_a2\n+  integer :: seven_eight_outer, seven_eight_inner\n+  integer :: i, j\n+  integer, allocatable :: var(:,:)\n+\n+  seven_a1 = 3\n+  eight_a1 = 2\n+  eight_a2 = -4\n+  allocate(var(1:10, 1 * seven_a1 : 10 * eight_a1 + eight_a2), &\n+           source=0)\n+  if (size(var) <= 4) error stop\n+\n+  !$omp simd collapse(2)\n+  do seven_eight_outer = 1, 10\n+    do seven_eight_inner = seven_eight_outer * seven_a1, seven_eight_outer * eight_a1 + eight_a2\n+      !$omp atomic update\n+      var(seven_eight_outer, seven_eight_inner) = var(seven_eight_outer, seven_eight_inner) + 2\n+    end do\n+  end do\n+\n+  do i = 1, 10\n+    do j = i * seven_a1, i * eight_a1 + eight_a2\n+      if (var(i,j) /= 2) error stop\n+    end do\n+  end do\n+end\n+\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(nine_ten_inner = nine_ten_outer \\\\* nine_a1 \\\\+ nine_a2; nine_ten_inner <= nine_ten_outer \\\\* ten_a1 \\\\+ D\\\\.\\[0-9\\]+; nine_ten_inner = nine_ten_inner \\\\+ 1\\\\)\" 1 original } }\n+\n+!  (9)  a2 + var-outer * a1\n+! (10)  var-outer * a1 - a2\n+subroutine nine_ten()\n+  implicit none\n+  integer :: nine_a1, nine_a2\n+  integer :: ten_a1, ten_a2\n+  integer :: nine_ten_outer, nine_ten_inner\n+  integer :: i, j\n+  integer, allocatable :: var(:,:)\n+\n+  nine_a1 = 3\n+  nine_a2 = 5\n+  ten_a1 = 2\n+  ten_a2 = 3\n+  allocate(var(1:10, nine_a2 + 1 * nine_a1:10 * ten_a1 - ten_a2), &\n+           source=0)\n+  if (size(var) <= 4) error stop\n+\n+  !$omp simd collapse(2)\n+  do nine_ten_outer = 1, 10\n+    do nine_ten_inner = nine_a2 + nine_ten_outer * nine_a1, nine_ten_outer * ten_a1 - ten_a2\n+      !$omp atomic update\n+      var(nine_ten_outer, nine_ten_inner) = var(nine_ten_outer, nine_ten_inner) + 2\n+    end do\n+  end do\n+\n+  do i = 1, 10\n+    do j = nine_a2 + i * nine_a1, i * ten_a1 - ten_a2\n+      if (var(i,j) /= 2) error stop\n+    end do\n+  end do\n+end\n+\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(eleven_inner = eleven_outer \\\\* D\\\\.\\[0-9\\]+ \\\\+ eleven_a2; eleven_inner <= 10; eleven_inner = eleven_inner \\\\+ 1\\\\)\" 1 original } }\n+\n+! (11)  a2 - var-outer * a1\n+\n+subroutine eleven()\n+  implicit none\n+  integer :: eleven_a1, eleven_a2\n+  integer :: eleven_outer, eleven_inner\n+  integer :: i, j\n+  integer, allocatable :: var(:,:)\n+\n+  eleven_a1 = 2\n+  eleven_a2 = 3\n+  allocate(var(1:10, eleven_a2 - 10 * eleven_a1 : 10), &\n+           source=0)\n+  if (size(var) <= 4) error stop\n+\n+  !$omp simd collapse(2)\n+  do eleven_outer = 1, 10\n+    do eleven_inner = eleven_a2 - eleven_outer * eleven_a1, 10\n+      !$omp atomic update\n+      var(eleven_outer, eleven_inner) = var(eleven_outer, eleven_inner) + 2\n+    end do\n+  end do\n+\n+  do i = 1, 10\n+    do j = eleven_a2 - i * eleven_a1, 10\n+      if (var(i,j) /= 2) error stop\n+    end do\n+  end do\n+end\n+end module m\n+\n+program main\n+use m\n+implicit none\n+call one_two()\n+call three_four()\n+call five_six()\n+call seven_eight()\n+call nine_ten()\n+call eleven()\n+end"}, {"sha": "c97cd99f71caab166a09c0f1a55329c30a04eabc", "filename": "libgomp/testsuite/libgomp.fortran/non-rectangular-loop-3.f90", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac2949574da9a668daad421d7edb79f172f73c6f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac2949574da9a668daad421d7edb79f172f73c6f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-3.f90?ref=ac2949574da9a668daad421d7edb79f172f73c6f", "patch": "@@ -0,0 +1,212 @@\n+! { dg-additional-options \"-fdump-tree-original\" }\n+! PR fortran/107424\n+\n+module m\n+contains\n+subroutine foo (av, avo, a0, a0o, a1, a2, a3, a4)\n+implicit none\n+\n+integer, value :: av\n+integer, value, optional :: avo\n+integer :: a0\n+integer, optional :: a0o\n+integer, pointer :: a1\n+integer, pointer, optional :: a2\n+integer, allocatable :: a3\n+integer, allocatable, optional :: a4\n+integer :: a5\n+integer, pointer :: a6\n+integer, allocatable :: a7\n+integer :: arr(20,10), ref(20,10)\n+\n+integer :: j, i\n+\n+allocate(a6, a7)\n+\n+ref = 44\n+do i = 1, 10\n+  do j = i, 20\n+    ref(j, i) = j + 100 * i\n+  end do\n+end do\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(av = 1; av <= 10; av = av \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = av \\\\* 1 \\\\+ 0; j <= 20; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! -> no temp var\n+arr = 44\n+av = 99; j = 99\n+!$omp simd collapse(2) lastprivate(av,j)\n+do av = 1, 10\n+  do j = av, 20\n+    arr(j, av) = j + 100 * av\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (av /= 11 .or. j /= 21) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(avo = 1; avo <= 10; avo = avo \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = avo \\\\* 1 \\\\+ 0; j <= 20; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! -> no temp var\n+arr = 44\n+avo = 99; j = 99\n+!$omp simd collapse(2) lastprivate(avo, j)\n+do avo = 1, 10\n+  do j = avo, 20\n+    arr(j, avo) = j + 100 * avo\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (avo /= 11 .or. j /= 21) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a0\\\\.\\[0-9\\]+ = 1; a0\\\\.\\[0-9\\]+ <= 10; a0\\\\.\\[0-9\\]+ = a0\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = a0\\\\.\\[0-9\\]+ \\\\* 1 \\\\+ 0; j <= 20; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*a0 = a0\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a0 = 99; j = 99\n+!$omp simd collapse(2) lastprivate(a0,j)\n+do a0 = 1, 10\n+  do j = a0, 20\n+    arr(j, a0) = j + 100 * a0\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (a0 /= 11 .or. j /= 21) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a0o\\\\.\\[0-9\\]+ = 1; a0o\\\\.\\[0-9\\]+ <= 10; a0o\\\\.\\[0-9\\]+ = a0o\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = a0o\\\\.\\[0-9\\]+ \\\\* 1 \\\\+ 0; j <= 20; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*a0o = a0o\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a0o = 99; j = 99\n+!$omp simd collapse(2) lastprivate(a0o,j)\n+do a0o = 1, 10\n+  do j = a0o, 20\n+    arr(j, a0o) = j + 100 * a0o\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (a0o /= 11 .or. j /= 21) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a1\\\\.\\[0-9\\]+ = 1; a1\\\\.\\[0-9\\]+ <= 10; a1\\\\.\\[0-9\\]+ = a1\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = a1\\\\.\\[0-9\\]+ \\\\* 1 \\\\+ 0; j <= 20; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*\\\\*a1 = a1\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a1 = 99; j = 99\n+! no last private for 'a1' as \"The initial status of a private pointer is undefined.\"\n+!$omp simd collapse(2) lastprivate(j)\n+do a1 = 1, 10\n+  do j = a1, 20\n+    arr(j, a1) = j + 100 * a1\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (j /= 21) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a2\\\\.\\[0-9\\]+ = 1; a2\\\\.\\[0-9\\]+ <= 10; a2\\\\.\\[0-9\\]+ = a2\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = a2\\\\.\\[0-9\\]+ \\\\* 1 \\\\+ 0; j <= 20; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*\\\\*a2 = a2\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a2 = 99; j = 99\n+! no last private for 'a2' as \"The initial status of a private pointer is undefined.\"\n+!$omp simd collapse(2) lastprivate(j)\n+do a2 = 1, 10\n+  do j = a2, 20\n+    arr(j, a2) = j + 100 * a2\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (j /= 21) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a3\\\\.\\[0-9\\]+ = 1; a3\\\\.\\[0-9\\]+ <= 10; a3\\\\.\\[0-9\\]+ = a3\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = a3\\\\.\\[0-9\\]+ \\\\* 1 \\\\+ 0; j <= 20; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*\\\\*a3 = a3\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a3 = 99; j = 99\n+!$omp simd collapse(2) lastprivate(a3,j)\n+do a3 = 1, 10\n+  do j = a3, 20\n+    arr(j, a3) = j + 100 * a3\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (a3 /= 11 .or. j /= 21) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a4\\\\.\\[0-9\\]+ = 1; a4\\\\.\\[0-9\\]+ <= 10; a4\\\\.\\[0-9\\]+ = a4\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = a4\\\\.\\[0-9\\]+ \\\\* 1 \\\\+ 0; j <= 20; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*\\\\*a4 = a4\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a4 = 99; j = 99\n+!$omp simd collapse(2) lastprivate(a4,j)\n+do a4 = 1, 10\n+  do j = a4, 20\n+    arr(j, a4) = j + 100 * a4\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (a4 /= 11 .or. j /= 21) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a5 = 1; a5 <= 10; a5 = a5 \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = a5 \\\\* 1 \\\\+ 0; j <= 20; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! -> no temp var\n+arr = 44\n+a5 = 99; j = 99\n+!$omp simd collapse(2) lastprivate(a5,j)\n+do a5 = 1, 10\n+  do j = a5, 20\n+    arr(j, a5) = j + 100 * a5\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (a5 /= 11 .or. j /= 21) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a6\\\\.\\[0-9\\]+ = 1; a6\\\\.\\[0-9\\]+ <= 10; a6\\\\.\\[0-9\\]+ = a6\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = a6\\\\.\\[0-9\\]+ \\\\* 1 \\\\+ 0; j <= 20; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*a6 = a6\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a6 = 99; j = 99\n+! no last private for 'a6' as \"The initial status of a private pointer is undefined.\"\n+!$omp simd collapse(2) lastprivate(j)\n+do a6 = 1, 10\n+  do j = a6, 20\n+    arr(j, a6) = j + 100 * a6\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (j /= 21) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a7\\\\.\\[0-9\\]+ = 1; a7\\\\.\\[0-9\\]+ <= 10; a7\\\\.\\[0-9\\]+ = a7\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = a7\\\\.\\[0-9\\]+ \\\\* 1 \\\\+ 0; j <= 20; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*a7 = a7\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a7 = 99; j = 99\n+!$omp simd collapse(2) lastprivate(a7,j)\n+do a7 = 1, 10\n+  do j = a7, 20\n+    arr(j, a7) = j + 100 * a7\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (a7 /= 11 .or. j /= 21) error stop\n+\n+deallocate(a6, a7)\n+end\n+\n+end module m\n+\n+\n+use m\n+implicit none\n+\n+integer :: av\n+integer :: avo\n+integer :: a0\n+integer :: a0o\n+integer, pointer :: a1\n+integer, pointer :: a2\n+integer, allocatable :: a3\n+integer, allocatable :: a4\n+\n+av = -99; avo = -99\n+allocate(a1,a2,a3,a4)\n+call foo (av, avo, a0, a0o, a1, a2, a3, a4)\n+deallocate(a1,a2,a3,a4)\n+end"}, {"sha": "ef2bd61f1804b8cad45c6adaefe4154c4142bf01", "filename": "libgomp/testsuite/libgomp.fortran/non-rectangular-loop-4.f90", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac2949574da9a668daad421d7edb79f172f73c6f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac2949574da9a668daad421d7edb79f172f73c6f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-4.f90?ref=ac2949574da9a668daad421d7edb79f172f73c6f", "patch": "@@ -0,0 +1,215 @@\n+! { dg-additional-options \"-fdump-tree-original\" }\n+! PR fortran/107424\n+\n+! Same as non-rectangular-loop-4.f90 but expr in upper bound \n+\n+module m\n+contains\n+subroutine foo (av, avo, a0, a0o, a1, a2, a3, a4)\n+implicit none\n+\n+integer, value :: av\n+integer, value, optional :: avo\n+integer :: a0\n+integer, optional :: a0o\n+integer, pointer :: a1\n+integer, pointer, optional :: a2\n+integer, allocatable :: a3\n+integer, allocatable, optional :: a4\n+integer :: a5\n+integer, pointer :: a6\n+integer, allocatable :: a7\n+integer :: arr(20,10), ref(20,10)\n+\n+integer :: j, i, lp_i, lp_j\n+\n+allocate(a6, a7)\n+\n+ref = 44\n+do i = 1, 10\n+  do j = 1, i*2-1\n+    ref(j, i) = j + 100 * i\n+  end do\n+end do\n+lp_i = i; lp_j = j\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(av = 1; av <= 10; av = av \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = 1; j <= av \\\\* 2 \\\\+ -1; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! -> no temp var\n+arr = 44\n+av = 99; j = 99\n+!$omp simd collapse(2) lastprivate(av,j)\n+do av = 1, 10\n+  do j = 1, av*2-1\n+    arr(j, av) = j + 100 * av\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (av /= lp_i .or. j /= lp_j) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(avo = 1; avo <= 10; avo = avo \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = 1; j <= avo \\\\* 2 \\\\+ -1; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! -> no temp var\n+arr = 44\n+avo = 99; j = 99\n+!$omp simd collapse(2) lastprivate(avo, j)\n+do avo = 1, 10\n+  do j = 1, avo*2-1\n+    arr(j, avo) = j + 100 * avo\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (avo /= lp_i .or. j /= lp_j) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a0\\\\.\\[0-9\\]+ = 1; a0\\\\.\\[0-9\\]+ <= 10; a0\\\\.\\[0-9\\]+ = a0\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = 1; j <= a0\\\\.\\[0-9\\]+ \\\\* 2 \\\\+ -1; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*a0 = a0\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a0 = 99; j = 99\n+!$omp simd collapse(2) lastprivate(a0,j)\n+do a0 = 1, 10\n+  do j = 1, a0*2-1\n+    arr(j, a0) = j + 100 * a0\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (a0 /= lp_i .or. j /= lp_j) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a0o\\\\.\\[0-9\\]+ = 1; a0o\\\\.\\[0-9\\]+ <= 10; a0o\\\\.\\[0-9\\]+ = a0o\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = 1; j <= a0o\\\\.\\[0-9\\]+ \\\\* 2 \\\\+ -1; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*a0o = a0o\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a0o = 99; j = 99\n+!$omp simd collapse(2) lastprivate(a0o,j)\n+do a0o = 1, 10\n+  do j = 1, a0o*2-1\n+    arr(j, a0o) = j + 100 * a0o\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (a0o /= lp_i .or. j /= lp_j) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a1\\\\.\\[0-9\\]+ = 1; a1\\\\.\\[0-9\\]+ <= 10; a1\\\\.\\[0-9\\]+ = a1\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = 1; j <= a1\\\\.\\[0-9\\]+ \\\\* 2 \\\\+ -1; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*\\\\*a1 = a1\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a1 = 99; j = 99\n+! no last private for 'a1' as \"The initial status of a private pointer is undefined.\"\n+!$omp simd collapse(2) lastprivate(j)\n+do a1 = 1, 10\n+  do j = 1, a1*2-1\n+    arr(j, a1) = j + 100 * a1\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (j /= lp_j) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a2\\\\.\\[0-9\\]+ = 1; a2\\\\.\\[0-9\\]+ <= 10; a2\\\\.\\[0-9\\]+ = a2\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = 1; j <= a2\\\\.\\[0-9\\]+ \\\\* 2 \\\\+ -1; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*\\\\*a2 = a2\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a2 = 99; j = 99\n+! no last private for 'a2' as \"The initial status of a private pointer is undefined.\"\n+!$omp simd collapse(2) lastprivate(j)\n+do a2 = 1, 10\n+  do j = 1, a2*2-1\n+    arr(j, a2) = j + 100 * a2\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (j /= lp_j) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a3\\\\.\\[0-9\\]+ = 1; a3\\\\.\\[0-9\\]+ <= 10; a3\\\\.\\[0-9\\]+ = a3\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = 1; j <= a3\\\\.\\[0-9\\]+ \\\\* 2 \\\\+ -1; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*\\\\*a3 = a3\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a3 = 99; j = 99\n+!$omp simd collapse(2) lastprivate(a3,j)\n+do a3 = 1, 10\n+  do j = 1, a3*2-1\n+    arr(j, a3) = j + 100 * a3\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (a3 /= lp_i .or. j /= lp_j) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a4\\\\.\\[0-9\\]+ = 1; a4\\\\.\\[0-9\\]+ <= 10; a4\\\\.\\[0-9\\]+ = a4\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = 1; j <= a4\\\\.\\[0-9\\]+ \\\\* 2 \\\\+ -1; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*\\\\*a4 = a4\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a4 = 99; j = 99\n+!$omp simd collapse(2) lastprivate(a4,j)\n+do a4 = 1, 10\n+  do j = 1, a4*2-1\n+    arr(j, a4) = j + 100 * a4\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (a4 /= lp_i .or. j /= lp_j) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a5 = 1; a5 <= 10; a5 = a5 \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = 1; j <= a5 \\\\* 2 \\\\+ -1; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! -> no temp var\n+arr = 44\n+a5 = 99; j = 99\n+!$omp simd collapse(2) lastprivate(a5,j)\n+do a5 = 1, 10\n+  do j = 1, a5*2-1\n+    arr(j, a5) = j + 100 * a5\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (a5 /= lp_i .or. j /= lp_j) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a6\\\\.\\[0-9\\]+ = 1; a6\\\\.\\[0-9\\]+ <= 10; a6\\\\.\\[0-9\\]+ = a6\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = 1; j <= a6\\\\.\\[0-9\\]+ \\\\* 2 \\\\+ -1; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*a6 = a6\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a6 = 99; j = 99\n+! no last private for 'a6' as \"The initial status of a private pointer is undefined.\"\n+!$omp simd collapse(2) lastprivate(j)\n+do a6 = 1, 10\n+  do j = 1, a6*2-1\n+    arr(j, a6) = j + 100 * a6\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (j /= lp_j) error stop\n+\n+! { dg-final { scan-tree-dump-times \"for \\\\(a7\\\\.\\[0-9\\]+ = 1; a7\\\\.\\[0-9\\]+ <= 10; a7\\\\.\\[0-9\\]+ = a7\\\\.\\[0-9\\]+ \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"for \\\\(j = 1; j <= a7\\\\.\\[0-9\\]+ \\\\* 2 \\\\+ -1; j = j \\\\+ 1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\*a7 = a7\\\\.\\[0-9\\]+;\" 1 \"original\" } }\n+arr = 44\n+a7 = 99; j = 99\n+!$omp simd collapse(2) lastprivate(a7,j)\n+do a7 = 1, 10\n+  do j = 1, a7*2-1\n+    arr(j, a7) = j + 100 * a7\n+  end do\n+end do\n+if (any (ref /= arr)) error stop\n+if (a7 /= lp_i .or. j /= lp_j) error stop\n+\n+deallocate(a6, a7)\n+end\n+\n+end module m\n+\n+\n+use m\n+implicit none\n+\n+integer :: av\n+integer :: avo\n+integer :: a0\n+integer :: a0o\n+integer, pointer :: a1\n+integer, pointer :: a2\n+integer, allocatable :: a3\n+integer, allocatable :: a4\n+\n+av = -99; avo = -99\n+allocate(a1,a2,a3,a4)\n+call foo (av, avo, a0, a0o, a1, a2, a3, a4)\n+deallocate(a1,a2,a3,a4)\n+end"}, {"sha": "643ab796a84ce78c523b22793ed7b2bab534960c", "filename": "libgomp/testsuite/libgomp.fortran/non-rectangular-loop-5.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac2949574da9a668daad421d7edb79f172f73c6f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac2949574da9a668daad421d7edb79f172f73c6f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnon-rectangular-loop-5.f90?ref=ac2949574da9a668daad421d7edb79f172f73c6f", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+! { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+! PR fortran/107424\n+\n+! Nonrectangular loop nests checks\n+\n+!$omp simd collapse(2)\n+do i = 1, 10\n+  do j = i, 10, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+  end do\n+end do\n+\n+!$omp do collapse(2) lastprivate(j)  ! { dg-error \"lastprivate variable 'j' is private in outer context\" }\n+do i = 1, 10\n+  do j = i, 10, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+  end do\n+end do\n+if (i /= 11) stop 1\n+\n+!$omp simd collapse(2) lastprivate(j)\n+do i = 1, 10\n+  do j = i, 10, 2  ! { dg-message \"sorry, unimplemented: non-rectangular loop nest with step other than constant 1 or -1 for 'j'\" }\n+  end do\n+end do\n+if (i /= 11) stop 1\n+end"}]}