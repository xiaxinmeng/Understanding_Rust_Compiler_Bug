{"sha": "550fa0931855ee93f340dee752a8bb9b1a70cbc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUwZmEwOTMxODU1ZWU5M2YzNDBkZWU3NTJhOGJiOWIxYTcwY2JjNQ==", "commit": {"author": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2016-05-20T09:35:46Z"}, "committer": {"name": "Prathamesh Kulkarni", "email": "prathamesh3492@gcc.gnu.org", "date": "2016-05-20T09:35:46Z"}, "message": "tree-vectorizer.c (get_vec_alignment_for_decl): New static function.\n\n2016-05-20  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n\n\t* tree-vectorizer.c (get_vec_alignment_for_decl): New static function.\n\t(get_vec_alignment_for_array_decl): Likewise.\n\t(get_vec_alignment_for_record_decl): Likewise.\n\t(increase_alignment::execute): Move code to find alignment to\n\tget_vec_alignment_for_array_decl and call get_vec_alignment_for_decl.\n\t(type_align_map): New hash_map.\n\ntestsuite/\n\t* gcc.dg/vect/section-anchors-vect-70.c: New test-case.\n\t* gcc.dg/vect/section-anchors-vect-71.c: Likewise.\n\t* gcc.dg/vect/section-anchors-vect-72.c: Likewise.\n\nFrom-SVN: r236502", "tree": {"sha": "e25fe64ebb73d39a0d17086f38d34874b3943778", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e25fe64ebb73d39a0d17086f38d34874b3943778"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/550fa0931855ee93f340dee752a8bb9b1a70cbc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550fa0931855ee93f340dee752a8bb9b1a70cbc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/550fa0931855ee93f340dee752a8bb9b1a70cbc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550fa0931855ee93f340dee752a8bb9b1a70cbc5/comments", "author": null, "committer": null, "parents": [{"sha": "483c642948802336899b14fa57b2e76c760c3c36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/483c642948802336899b14fa57b2e76c760c3c36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/483c642948802336899b14fa57b2e76c760c3c36"}], "stats": {"total": 147, "additions": 133, "deletions": 14}, "files": [{"sha": "c6b2a23159d04a0e32298df6df9c079cb341c1d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550fa0931855ee93f340dee752a8bb9b1a70cbc5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550fa0931855ee93f340dee752a8bb9b1a70cbc5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=550fa0931855ee93f340dee752a8bb9b1a70cbc5", "patch": "@@ -1,3 +1,12 @@\n+2016-05-20  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\n+\t* tree-vectorizer.c (get_vec_alignment_for_decl): New static function.\n+\t(get_vec_alignment_for_array_decl): Likewise.\n+\t(get_vec_alignment_for_record_decl): Likewise.\n+\t(increase_alignment::execute): Move code to find alignment to\n+\tget_vec_alignment_for_array_decl and call get_vec_alignment_for_decl.\n+\t(type_align_map): New hash_map.\n+\n 2016-05-20  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/29756"}, {"sha": "fa29e0cb4c0dc49c43f1b2649a46ceb0a17f06ce", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550fa0931855ee93f340dee752a8bb9b1a70cbc5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550fa0931855ee93f340dee752a8bb9b1a70cbc5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=550fa0931855ee93f340dee752a8bb9b1a70cbc5", "patch": "@@ -1,3 +1,9 @@\n+2016-05-20  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\n+\t* gcc.dg/vect/section-anchors-vect-70.c: New test-case.\n+\t* gcc.dg/vect/section-anchors-vect-71.c: Likewise.\n+\t* gcc.dg/vect/section-anchors-vect-72.c: Likewise.\n+\n 2016-05-20  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/29756"}, {"sha": "26698135f541575f0bbf75ba06ae652dfbd9f55c", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 118, "deletions": 14, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/550fa0931855ee93f340dee752a8bb9b1a70cbc5/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/550fa0931855ee93f340dee752a8bb9b1a70cbc5/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=550fa0931855ee93f340dee752a8bb9b1a70cbc5", "patch": "@@ -794,38 +794,142 @@ make_pass_slp_vectorize (gcc::context *ctxt)\n      This should involve global alignment analysis and in the future also\n      array padding.  */\n \n+static unsigned get_vec_alignment_for_type (tree);\n+static hash_map<tree, unsigned> *type_align_map;\n+\n+/* Return alignment of array's vector type corresponding to scalar type.\n+   0 if no vector type exists.  */\n+static unsigned\n+get_vec_alignment_for_array_type (tree type) \n+{\n+  gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n+\n+  tree vectype = get_vectype_for_scalar_type (strip_array_types (type));\n+  if (!vectype\n+      || !TYPE_SIZE (type)\n+      || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n+      || tree_int_cst_lt (TYPE_SIZE (type), TYPE_SIZE (vectype)))\n+    return 0;\n+\n+  return TYPE_ALIGN (vectype);\n+}\n+\n+/* Return alignment of field having maximum alignment of vector type\n+   corresponding to it's scalar type. For now, we only consider fields whose\n+   offset is a multiple of it's vector alignment.\n+   0 if no suitable field is found.  */\n+static unsigned\n+get_vec_alignment_for_record_type (tree type) \n+{\n+  gcc_assert (TREE_CODE (type) == RECORD_TYPE);\n+\n+  unsigned max_align = 0, alignment;\n+  HOST_WIDE_INT offset;\n+  tree offset_tree;\n+\n+  if (TYPE_PACKED (type))\n+    return 0;\n+\n+  unsigned *slot = type_align_map->get (type);\n+  if (slot)\n+    return *slot;\n+\n+  for (tree field = first_field (type);\n+       field != NULL_TREE;\n+       field = DECL_CHAIN (field))\n+    {\n+      /* Skip if not FIELD_DECL or if alignment is set by user.  */ \n+      if (TREE_CODE (field) != FIELD_DECL\n+\t  || DECL_USER_ALIGN (field)\n+\t  || DECL_ARTIFICIAL (field))\n+\tcontinue;\n+\n+      /* We don't need to process the type further if offset is variable,\n+\t since the offsets of remaining members will also be variable.  */\n+      if (TREE_CODE (DECL_FIELD_OFFSET (field)) != INTEGER_CST\n+\t  || TREE_CODE (DECL_FIELD_BIT_OFFSET (field)) != INTEGER_CST)\n+\tbreak;\n+\n+      /* Similarly stop processing the type if offset_tree\n+\t does not fit in unsigned HOST_WIDE_INT.  */\n+      offset_tree = bit_position (field);\n+      if (!tree_fits_uhwi_p (offset_tree))\n+\tbreak;\n+\n+      offset = tree_to_uhwi (offset_tree); \n+      alignment = get_vec_alignment_for_type (TREE_TYPE (field));\n+\n+      /* Get maximum alignment of vectorized field/array among those members\n+\t whose offset is multiple of the vector alignment.  */ \n+      if (alignment\n+\t  && (offset % alignment == 0)\n+\t  && (alignment > max_align))\n+\tmax_align = alignment;\n+    }\n+\n+  type_align_map->put (type, max_align);\n+  return max_align;\n+}\n+\n+/* Return alignment of vector type corresponding to decl's scalar type\n+   or 0 if it doesn't exist or the vector alignment is lesser than\n+   decl's alignment.  */\n+static unsigned\n+get_vec_alignment_for_type (tree type)\n+{\n+  if (type == NULL_TREE)\n+    return 0;\n+\n+  gcc_assert (TYPE_P (type));\n+\n+  static unsigned alignment = 0;\n+  switch (TREE_CODE (type))\n+    {\n+      case ARRAY_TYPE:\n+\talignment = get_vec_alignment_for_array_type (type);\n+\tbreak;\n+      case RECORD_TYPE:\n+\talignment = get_vec_alignment_for_record_type (type);\n+\tbreak;\n+      default:\n+\talignment = 0;\n+\tbreak;\n+    }\n+\n+  return (alignment > TYPE_ALIGN (type)) ? alignment : 0;\n+}\n+\n+/* Entry point to increase_alignment pass.  */\n static unsigned int\n increase_alignment (void)\n {\n   varpool_node *vnode;\n \n   vect_location = UNKNOWN_LOCATION;\n+  type_align_map = new hash_map<tree, unsigned>;\n \n   /* Increase the alignment of all global arrays for vectorization.  */\n   FOR_EACH_DEFINED_VARIABLE (vnode)\n     {\n-      tree vectype, decl = vnode->decl;\n-      tree t;\n+      tree decl = vnode->decl;\n       unsigned int alignment;\n \n-      t = TREE_TYPE (decl);\n-      if (TREE_CODE (t) != ARRAY_TYPE)\n-        continue;\n-      vectype = get_vectype_for_scalar_type (strip_array_types (t));\n-      if (!vectype)\n-        continue;\n-      alignment = TYPE_ALIGN (vectype);\n-      if (DECL_ALIGN (decl) >= alignment)\n-        continue;\n-\n-      if (vect_can_force_dr_alignment_p (decl, alignment))\n+      if ((decl_in_symtab_p (decl)\n+\t  && !symtab_node::get (decl)->can_increase_alignment_p ())\n+\t  || DECL_USER_ALIGN (decl) || DECL_ARTIFICIAL (decl))\n+\tcontinue;\n+\n+      alignment = get_vec_alignment_for_type (TREE_TYPE (decl));\n+      if (alignment && vect_can_force_dr_alignment_p (decl, alignment))\n         {\n-\t  vnode->increase_alignment (TYPE_ALIGN (vectype));\n+\t  vnode->increase_alignment (alignment);\n           dump_printf (MSG_NOTE, \"Increasing alignment of decl: \");\n           dump_generic_expr (MSG_NOTE, TDF_SLIM, decl);\n           dump_printf (MSG_NOTE, \"\\n\");\n         }\n     }\n+\n+  delete type_align_map;\n   return 0;\n }\n "}]}