{"sha": "6d9dbdf51f9afe86a57fb28bc55065fa4500a72b", "node_id": "C_kwDOANBUbNoAKDZkOWRiZGY1MWY5YWZlODZhNTdmYjI4YmM1NTA2NWZhNDUwMGE3MmI", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-02T12:56:59Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-11-02T12:56:59Z"}, "message": "libstdc++: Improve ERANGE behavior for fallback FP std::from_chars\n\nThe fallback implementation of floating-point std::from_chars (used for\nformats other than binary32/64) just calls the C library's strtod family\nof functions.  In case of overflow, the behavior of these functions is\nrigidly specified:\n\n  If the correct value overflows and default rounding is in effect, plus\n  or minus HUGE_VAL, HUGE_VALF, or HUGE_VALL is returned (according to\n  the return type and sign of the value), and the value of the macro\n  ERANGE is stored in errno.\n\nBut in case of underflow, implementations are given more leeway:\n\n  If the result underflows the functions return a value whose magnitude\n  is no greater than the smallest normalized positive number in the\n  return type; whether errno acquires the value ERANGE is\n  implementation-defined.\n\nThus the fallback implementation can (and does) portably detect overflow,\nbut it can't portably detect underflow.  However, glibc (and presumably\nother high-quality C library implementations) will reliably set errno to\nERANGE in case of underflow as well, and it'll also return the nearest\ndenormal number to the correct value (zero in case of true underflow),\nwhich allows callers to succesfully parse denormal numbers.\n\nSo since we can't be perfect here, this patch takes the best effort\napproach of assuming a high quality C library implementation with\nrespect to this underflow behavior, and refines our implementation\nto try to distiguish between a denormal result and true underflow\nby inspecting strtod's return value.\n\nlibstdc++-v3/ChangeLog:\n\n\t* src/c++17/floating_from_chars.cc (from_chars_impl): In the\n\tERANGE case, distinguish between a denormal result and true\n\tunderflow by checking if the return value is 0.", "tree": {"sha": "9b31a4e39adc09f78f1b625daa6ea075cd0226b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b31a4e39adc09f78f1b625daa6ea075cd0226b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d9dbdf51f9afe86a57fb28bc55065fa4500a72b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d9dbdf51f9afe86a57fb28bc55065fa4500a72b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d9dbdf51f9afe86a57fb28bc55065fa4500a72b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d9dbdf51f9afe86a57fb28bc55065fa4500a72b/comments", "author": null, "committer": null, "parents": [{"sha": "f4874691812bc20e3d8e3302db439c27f30c472c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4874691812bc20e3d8e3302db439c27f30c472c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4874691812bc20e3d8e3302db439c27f30c472c"}], "stats": {"total": 7, "additions": 6, "deletions": 1}, "files": [{"sha": "939c751f861e4c5299c860bdbde34d772deab17f", "filename": "libstdc++-v3/src/c++17/floating_from_chars.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9dbdf51f9afe86a57fb28bc55065fa4500a72b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9dbdf51f9afe86a57fb28bc55065fa4500a72b/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc?ref=6d9dbdf51f9afe86a57fb28bc55065fa4500a72b", "patch": "@@ -637,8 +637,13 @@ namespace\n \t  {\n \t    if (__builtin_isinf(tmpval)) // overflow\n \t      ec = errc::result_out_of_range;\n-\t    else // underflow (LWG 3081 wants to set value = tmpval here)\n+\t    else if (tmpval == 0) // underflow (LWG 3081 wants to set value = tmpval here)\n \t      ec = errc::result_out_of_range;\n+\t    else // denormal value\n+\t      {\n+\t\tvalue = tmpval;\n+\t\tec = errc();\n+\t      }\n \t  }\n \telse if (n)\n \t  {"}]}