{"sha": "aaeb3b3a867a793f3e08de6cd6ac76539907fef3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFlYjNiM2E4NjdhNzkzZjNlMDhkZTZjZDZhYzc2NTM5OTA3ZmVmMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-02T11:07:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-02T11:07:34Z"}, "message": "[multiple changes]\n\n2015-03-02  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Ensure_Aggregate_Form):\n\tEnsure that the name denoted by the Chars of a pragma argument\n\tassociation has the proper Sloc when converted into an aggregate.\n\n2015-03-02  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch6.adb (Check_Private_Overriding): Capture\n\tIncomplete_Or_Partial_View in a constant. This is cleaner and\n\tmore efficient.\n\n2015-03-02  Gary Dismukes  <dismukes@adacore.com>\n\n\t* einfo.ads, exp_unst.ads: Minor reformatting.\n\n2015-03-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-strsea.adb (Find_Token): Ensure that the range of iteration\n\tdoes not perform any improper character access. This prevents\n\terroneous access in the unusual case of an empty string target\n\tand a From parameter less than Source'First.\n\n2015-03-02  Robert Dewar  <dewar@adacore.com>\n\n\t* elists.adb (List_Length): Fix incorrect result.\n\nFrom-SVN: r221111", "tree": {"sha": "3d413ee4bbd4502e0880da234c42c2e34eb53a76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d413ee4bbd4502e0880da234c42c2e34eb53a76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aaeb3b3a867a793f3e08de6cd6ac76539907fef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaeb3b3a867a793f3e08de6cd6ac76539907fef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaeb3b3a867a793f3e08de6cd6ac76539907fef3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaeb3b3a867a793f3e08de6cd6ac76539907fef3/comments", "author": null, "committer": null, "parents": [{"sha": "acf624f28032bb0fa8bee97d506c73c281f15ca6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acf624f28032bb0fa8bee97d506c73c281f15ca6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acf624f28032bb0fa8bee97d506c73c281f15ca6"}], "stats": {"total": 177, "additions": 113, "deletions": 64}, "files": [{"sha": "b1bab66e16ef798a12eedaa8ca206281c29a8038", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaeb3b3a867a793f3e08de6cd6ac76539907fef3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaeb3b3a867a793f3e08de6cd6ac76539907fef3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=aaeb3b3a867a793f3e08de6cd6ac76539907fef3", "patch": "@@ -1,3 +1,30 @@\n+2015-03-02  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Ensure_Aggregate_Form):\n+\tEnsure that the name denoted by the Chars of a pragma argument\n+\tassociation has the proper Sloc when converted into an aggregate.\n+\n+2015-03-02  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch6.adb (Check_Private_Overriding): Capture\n+\tIncomplete_Or_Partial_View in a constant. This is cleaner and\n+\tmore efficient.\n+\n+2015-03-02  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* einfo.ads, exp_unst.ads: Minor reformatting.\n+\n+2015-03-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* a-strsea.adb (Find_Token): Ensure that the range of iteration\n+\tdoes not perform any improper character access. This prevents\n+\terroneous access in the unusual case of an empty string target\n+\tand a From parameter less than Source'First.\n+\n+2015-03-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* elists.adb (List_Length): Fix incorrect result.\n+\n 2015-03-02  Bob Duff  <duff@adacore.com>\n \n \t* sem_ch6.adb (Check_Private_Overriding): Refine the legality"}, {"sha": "df267c1d7f9edf1cbf37293f7c278a56568fe25c", "filename": "gcc/ada/a-strsea.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaeb3b3a867a793f3e08de6cd6ac76539907fef3/gcc%2Fada%2Fa-strsea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaeb3b3a867a793f3e08de6cd6ac76539907fef3/gcc%2Fada%2Fa-strsea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-strsea.adb?ref=aaeb3b3a867a793f3e08de6cd6ac76539907fef3", "patch": "@@ -209,7 +209,11 @@ package body Ada.Strings.Search is\n          raise Index_Error;\n       end if;\n \n-      for J in From .. Source'Last loop\n+      --  If Source is the empty string, From may still be out of its\n+      --  range.  The following ensures that in all cases there is no\n+      --  possible erroneous access to a non-existing character.\n+\n+      for J in Integer'Max (From, Source'First) .. Source'Last loop\n          if Belongs (Source (J), Set, Test) then\n             First := J;\n "}, {"sha": "316b6ad0e4eb3227603320b2ea10c609d5b82511", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaeb3b3a867a793f3e08de6cd6ac76539907fef3/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaeb3b3a867a793f3e08de6cd6ac76539907fef3/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=aaeb3b3a867a793f3e08de6cd6ac76539907fef3", "patch": "@@ -1999,7 +1999,7 @@ package Einfo is\n --       the case where we are unnesting nested subprograms (in which case it\n --       is also set for types and subtypes which are not static types, and\n --       that are referenced uplevel, as well as for subprograms that contain\n---       uplevel references or call other subprogram, see Exp_unst for details.\n+--       uplevel references or call other subprograms (Exp_Unst has details).\n \n --    Has_Visible_Refinement (Flag263)\n --       Defined in E_Abstract_State entities. Set when a state has at least\n@@ -2978,7 +2978,7 @@ package Einfo is\n --       type is known to be a static type (defined as a discrete type with\n --       static bounds, a record all of whose component types are static types,\n --       or an array, all of whose bounds are of a static type, and also have\n---       a component type that is a static type. See Set_Uplevel_Type for more\n+--       a component type that is a static type). See Set_Uplevel_Type for more\n --       information on how this flag is used. Note that if Is_Static_Type is\n --       True, then it is never the case that the Has_Uplevel_Reference flag is\n --       set for the same type."}, {"sha": "5b1f88cdd74d544105502f4cd9e43a48b7e80755", "filename": "gcc/ada/elists.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaeb3b3a867a793f3e08de6cd6ac76539907fef3/gcc%2Fada%2Felists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaeb3b3a867a793f3e08de6cd6ac76539907fef3/gcc%2Fada%2Felists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.adb?ref=aaeb3b3a867a793f3e08de6cd6ac76539907fef3", "patch": "@@ -302,6 +302,7 @@ package body Elists is\n          if No (Elmt) then\n             return N;\n          else\n+            N := N + 1;\n             Next_Elmt (Elmt);\n          end if;\n       end loop;"}, {"sha": "8690a3547a8338923121d1720ba53828097d5488", "filename": "gcc/ada/exp_unst.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaeb3b3a867a793f3e08de6cd6ac76539907fef3/gcc%2Fada%2Fexp_unst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaeb3b3a867a793f3e08de6cd6ac76539907fef3/gcc%2Fada%2Fexp_unst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.ads?ref=aaeb3b3a867a793f3e08de6cd6ac76539907fef3", "patch": "@@ -195,7 +195,7 @@ package Exp_Unst is\n    --   xxx is replaced by Tnn!(AREC1.xxx).all (where ! represents a call\n    --   to unchecked conversion to convert the address to the access type\n    --   and Tnn is a locally declared type that is \"access all t\", where t\n-   --   is the type of the reference.\n+   --   is the type of the reference).\n \n    --   Note: the reason that we use Address as the component type in the\n    --   declaration of AREC1T is that we may create this type before we see"}, {"sha": "929b1c94155ef9f9141c7fca990732628eda9f3c", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 52, "deletions": 39, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaeb3b3a867a793f3e08de6cd6ac76539907fef3/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaeb3b3a867a793f3e08de6cd6ac76539907fef3/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=aaeb3b3a867a793f3e08de6cd6ac76539907fef3", "patch": "@@ -8906,24 +8906,27 @@ package body Sem_Ch6 is\n \n          procedure Check_Private_Overriding (T : Entity_Id) is\n \n-            function Overrides_Visible_Function return Boolean;\n+            function Overrides_Visible_Function\n+              (Partial_View : Entity_Id) return Boolean;\n             --  True if S overrides a function in the visible part. The\n             --  overridden function could be explicitly or implicitly declared.\n \n-            function Overrides_Visible_Function return Boolean is\n+            function Overrides_Visible_Function\n+              (Partial_View : Entity_Id) return Boolean\n+            is\n             begin\n                if not Is_Overriding or else not Has_Homonym (S) then\n                   return False;\n                end if;\n \n-               if not Present (Incomplete_Or_Partial_View (T)) then\n+               if not Present (Partial_View) then\n                   return True;\n                end if;\n \n                --  Search through all the homonyms H of S in the current\n                --  package spec, and return True if we find one that matches.\n                --  Note that Parent (H) will be the declaration of the\n-               --  Incomplete_Or_Partial_View of T for a match.\n+               --  partial view of T for a match.\n \n                declare\n                   H : Entity_Id := S;\n@@ -8936,8 +8939,7 @@ package body Sem_Ch6 is\n                        (Parent (H),\n                         N_Private_Extension_Declaration,\n                         N_Private_Type_Declaration)\n-                       and then Defining_Identifier (Parent (H)) =\n-                                  Incomplete_Or_Partial_View (T)\n+                       and then Defining_Identifier (Parent (H)) = Partial_View\n                      then\n                         return True;\n                      end if;\n@@ -8963,41 +8965,52 @@ package body Sem_Ch6 is\n                   Error_Msg_N (\"abstract subprograms must be visible \"\n                                & \"(RM 3.9.3(10))!\", S);\n \n-               elsif Ekind (S) = E_Function\n-                 and then not Overrides_Visible_Function\n-               then\n-                  --  Here, S is \"function ... return T;\" declared in the\n-                  --  private part, not overriding some visible operation.\n-                  --  That's illegal in the tagged case (but not if the\n-                  --  private type is untagged).\n-\n-                  if ((Present (Incomplete_Or_Partial_View (T))\n-                      and then Is_Tagged_Type (Incomplete_Or_Partial_View (T)))\n-                    or else (not Present (Incomplete_Or_Partial_View (T))\n-                      and then Is_Tagged_Type (T)))\n-                    and then T = Base_Type (Etype (S))\n-                  then\n-                     Error_Msg_N (\"private function with tagged result must\"\n-                                  & \" override visible-part function\", S);\n-                     Error_Msg_N (\"\\move subprogram to the visible part\"\n-                                  & \" (RM 3.9.3(10))\", S);\n+               elsif Ekind (S) = E_Function then\n+                  declare\n+                     Partial_View : constant Entity_Id :=\n+                                      Incomplete_Or_Partial_View (T);\n \n-                  --  AI05-0073: extend this test to the case of a function\n-                  --  with a controlling access result.\n+                  begin\n+                     if not Overrides_Visible_Function (Partial_View) then\n+\n+                        --  Here, S is \"function ... return T;\" declared in\n+                        --  the private part, not overriding some visible\n+                        --  operation.  That's illegal in the tagged case\n+                        --  (but not if the private type is untagged).\n+\n+                        if ((Present (Partial_View)\n+                              and then Is_Tagged_Type (Partial_View))\n+                          or else (not Present (Partial_View)\n+                                    and then Is_Tagged_Type (T)))\n+                          and then T = Base_Type (Etype (S))\n+                        then\n+                           Error_Msg_N\n+                             (\"private function with tagged result must\"\n+                              & \" override visible-part function\", S);\n+                           Error_Msg_N\n+                             (\"\\move subprogram to the visible part\"\n+                              & \" (RM 3.9.3(10))\", S);\n \n-                  elsif Ekind (Etype (S)) = E_Anonymous_Access_Type\n-                    and then Is_Tagged_Type (Designated_Type (Etype (S)))\n-                    and then\n-                      not Is_Class_Wide_Type (Designated_Type (Etype (S)))\n-                    and then Ada_Version >= Ada_2012\n-                  then\n-                     Error_Msg_N\n-                       (\"private function with controlling access result \"\n-                        & \"must override visible-part function\", S);\n-                     Error_Msg_N\n-                       (\"\\move subprogram to the visible part\"\n-                        & \" (RM 3.9.3(10))\", S);\n-                  end if;\n+                        --  AI05-0073: extend this test to the case of a\n+                        --  function with a controlling access result.\n+\n+                        elsif Ekind (Etype (S)) = E_Anonymous_Access_Type\n+                          and then Is_Tagged_Type (Designated_Type (Etype (S)))\n+                          and then\n+                            not Is_Class_Wide_Type\n+                                  (Designated_Type (Etype (S)))\n+                          and then Ada_Version >= Ada_2012\n+                        then\n+                           Error_Msg_N\n+                             (\"private function with controlling access \"\n+                              & \"result must override visible-part function\",\n+                              S);\n+                           Error_Msg_N\n+                             (\"\\move subprogram to the visible part\"\n+                              & \" (RM 3.9.3(10))\", S);\n+                        end if;\n+                     end if;\n+                  end;\n                end if;\n             end if;\n          end Check_Private_Overriding;"}, {"sha": "2d84303ac0affbdee51d9b28e70752407ed9999c", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaeb3b3a867a793f3e08de6cd6ac76539907fef3/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaeb3b3a867a793f3e08de6cd6ac76539907fef3/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=aaeb3b3a867a793f3e08de6cd6ac76539907fef3", "patch": "@@ -5222,21 +5222,32 @@ package body Sem_Prag is\n       ---------------------------\n \n       procedure Ensure_Aggregate_Form (Arg : Node_Id) is\n-         Expr  : constant Node_Id    := Expression (Arg);\n-         Loc   : constant Source_Ptr := Sloc (Expr);\n-         Comps : List_Id := No_List;\n-         Exprs : List_Id := No_List;\n-         Nam   : Name_Id;\n-\n-         CFSD : constant Boolean := Get_Comes_From_Source_Default;\n-         --  Used to restore Comes_From_Source_Default\n+         CFSD    : constant Boolean    := Get_Comes_From_Source_Default;\n+         Expr    : constant Node_Id    := Expression (Arg);\n+         Loc     : constant Source_Ptr := Sloc (Expr);\n+         Comps   : List_Id := No_List;\n+         Exprs   : List_Id := No_List;\n+         Nam     : Name_Id := No_Name;\n+         Nam_Loc : Source_Ptr;\n \n       begin\n-         if Nkind (Arg) = N_Aspect_Specification then\n-            Nam := No_Name;\n-         else\n-            pragma Assert (Nkind (Arg) = N_Pragma_Argument_Association);\n-            Nam := Chars (Arg);\n+         --  The pragma argument is in positional form:\n+\n+         --    pragma Depends (Nam => ...)\n+         --                    ^\n+         --                    Chars field\n+\n+         --  Note that the Sloc of the Chars field is the Sloc of the pragma\n+         --  argument association.\n+\n+         if Nkind (Arg) = N_Pragma_Argument_Association then\n+            Nam     := Chars (Arg);\n+            Nam_Loc := Sloc (Arg);\n+\n+            --  Remove the pragma argument name as this will be captured in the\n+            --  aggregate.\n+\n+            Set_Chars (Arg, No_Name);\n          end if;\n \n          --  The argument is already in aggregate form, but the presence of a\n@@ -5279,17 +5290,10 @@ package body Sem_Prag is\n          else\n             Comps := New_List (\n               Make_Component_Association (Loc,\n-                Choices    => New_List (Make_Identifier (Loc, Chars (Arg))),\n+                Choices    => New_List (Make_Identifier (Nam_Loc, Nam)),\n                 Expression => Relocate_Node (Expr)));\n          end if;\n \n-         --  Remove the pragma argument name as this information has been\n-         --  captured in the aggregate.\n-\n-         if Nkind (Arg) = N_Pragma_Argument_Association then\n-            Set_Chars (Arg, No_Name);\n-         end if;\n-\n          Set_Expression (Arg,\n            Make_Aggregate (Loc,\n              Component_Associations => Comps,"}]}