{"sha": "3fcaac1d8c04d2966e667e1e4b18959bb94656c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZjYWFjMWQ4YzA0ZDI5NjZlNjY3ZTFlNGIxODk1OWJiOTQ2NTZjOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2002-03-11T11:13:45Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2002-03-11T11:13:45Z"}, "message": "defaults.h (LARGEST_EXPONENT_IS_NORMAL, [...]): New.\n\n\t* defaults.h (LARGEST_EXPONENT_IS_NORMAL, ROUND_TOWARDS_ZERO): New.\n\t(MODE_HAS_NANS, MODE_HAS_INFINITIES): Evaluate to false if\n\tLARGEST_EXPONENT_IS_NORMAL for the given mode.\n\t(MODE_HAS_SIGN_DEPENDENT_ROUNDING): False when ROUND_TOWARDS_ZERO.\n\t* real.c (eadd1): Make rounding dependent on !ROUND_TOWARDS_ZERO.\n\t(ediv, emul, eldexp, esqrt): Likewise.\n\t(etoe113, etoe64, etoe53, etoe24, etodec, etoibm, etoc4x): Likewise.\n\t(e24toe): Only check NaNs & infinities if !LARGEST_EXPONENT_IS_NORMAL.\n\t(saturate): New function.\n\t(toe53, toe24): Saturate on overflow if LARGEST_EXPONENT_IS_NORMAL.\n\t(make_nan): Use a saturation value instead of a NaN if\n\tLARGEST_EXPONENT_IS_NORMAL.  Warn when this happens.\n\t* fp-bit.c (pack_d): Saturate on NaN, infinite or overflowing\n\tinputs if LARGEST_EXPONENT_IS_NORMAL.  Represent subnormals as\n\tzero if NO_DENORMALS.  Only round to nearest if !ROUND_TOWARDS_ZERO.\n\t(unpack_d): No NaNs or infinities if LARGEST_EXPONENT_IS_NORMAL.\n\t(_fpmul_parts, _fpdiv_parts): Only round to nearest if\n\t!ROUND_TOWARDS_ZERO.\n\t* doc/tm.texi (LARGEST_EXPONENT_IS_NORMAL): Document.\n\t(ROUND_TOWARDS_ZERO): Document.\n\nFrom-SVN: r50569", "tree": {"sha": "b35783a3200c2c8aa44adc916c24401dfe49041e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b35783a3200c2c8aa44adc916c24401dfe49041e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fcaac1d8c04d2966e667e1e4b18959bb94656c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fcaac1d8c04d2966e667e1e4b18959bb94656c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fcaac1d8c04d2966e667e1e4b18959bb94656c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fcaac1d8c04d2966e667e1e4b18959bb94656c9/comments", "author": null, "committer": null, "parents": [{"sha": "d25558bee8343ee30661c00aa2faefd89d60068c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d25558bee8343ee30661c00aa2faefd89d60068c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d25558bee8343ee30661c00aa2faefd89d60068c"}], "stats": {"total": 233, "additions": 192, "deletions": 41}, "files": [{"sha": "d01c087820872b9491704b9059e0acc8284b3757", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcaac1d8c04d2966e667e1e4b18959bb94656c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcaac1d8c04d2966e667e1e4b18959bb94656c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3fcaac1d8c04d2966e667e1e4b18959bb94656c9", "patch": "@@ -1,3 +1,26 @@\n+2002-03-11  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* defaults.h (LARGEST_EXPONENT_IS_NORMAL, ROUND_TOWARDS_ZERO): New.\n+\t(MODE_HAS_NANS, MODE_HAS_INFINITIES): Evaluate to false if\n+\tLARGEST_EXPONENT_IS_NORMAL for the given mode.\n+\t(MODE_HAS_SIGN_DEPENDENT_ROUNDING): False when ROUND_TOWARDS_ZERO.\n+\t* real.c (eadd1): Make rounding dependent on !ROUND_TOWARDS_ZERO.\n+\t(ediv, emul, eldexp, esqrt): Likewise.\n+\t(etoe113, etoe64, etoe53, etoe24, etodec, etoibm, etoc4x): Likewise.\n+\t(e24toe): Only check NaNs & infinities if !LARGEST_EXPONENT_IS_NORMAL.\n+\t(saturate): New function.\n+\t(toe53, toe24): Saturate on overflow if LARGEST_EXPONENT_IS_NORMAL.\n+\t(make_nan): Use a saturation value instead of a NaN if\n+\tLARGEST_EXPONENT_IS_NORMAL.  Warn when this happens.\n+\t* fp-bit.c (pack_d): Saturate on NaN, infinite or overflowing\n+\tinputs if LARGEST_EXPONENT_IS_NORMAL.  Represent subnormals as\n+\tzero if NO_DENORMALS.  Only round to nearest if !ROUND_TOWARDS_ZERO.\n+\t(unpack_d): No NaNs or infinities if LARGEST_EXPONENT_IS_NORMAL.\n+\t(_fpmul_parts, _fpdiv_parts): Only round to nearest if\n+\t!ROUND_TOWARDS_ZERO.\n+\t* doc/tm.texi (LARGEST_EXPONENT_IS_NORMAL): Document.\n+\t(ROUND_TOWARDS_ZERO): Document.\n+\n 2002-03-11  Andreas Jaeger  <aj@suse.de>\n \n \t* cfg.c (dump_flow_info): Remove unused variable."}, {"sha": "5da7a8efe13884839f39fa7cfba028507dda67a6", "filename": "gcc/config/fp-bit.c", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcaac1d8c04d2966e667e1e4b18959bb94656c9/gcc%2Fconfig%2Ffp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcaac1d8c04d2966e667e1e4b18959bb94656c9/gcc%2Fconfig%2Ffp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.c?ref=3fcaac1d8c04d2966e667e1e4b18959bb94656c9", "patch": "@@ -1,6 +1,6 @@\n /* This is a software floating point library which can be used\n    for targets without hardware floating point. \n-   Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000, 2001\n+   Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002\n    Free Software Foundation, Inc.\n \n This file is free software; you can redistribute it and/or modify it\n@@ -181,7 +181,15 @@ pack_d ( fp_number_type *  src)\n   int sign = src->sign;\n   int exp = 0;\n \n-  if (isnan (src))\n+  if (LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS) && (isnan (src) || isinf (src)))\n+    {\n+      /* We can't represent these values accurately.  By using the\n+\t largest possible magnitude, we guarantee that the conversion\n+\t of infinity is at least as big as any finite number.  */\n+      exp = EXPMAX;\n+      fraction = ((fractype) 1 << FRACBITS) - 1;\n+    }\n+  else if (isnan (src))\n     {\n       exp = EXPMAX;\n       if (src->class == CLASS_QNAN || 1)\n@@ -207,6 +215,13 @@ pack_d ( fp_number_type *  src)\n     {\n       if (src->normal_exp < NORMAL_EXPMIN)\n \t{\n+#ifdef NO_DENORMALS\n+\t  /* Go straight to a zero representation if denormals are not\n+ \t     supported.  The denormal handling would be harmless but\n+ \t     isn't unnecessary.  */\n+\t  exp = 0;\n+\t  fraction = 0;\n+#else /* NO_DENORMALS */\n \t  /* This number's exponent is too low to fit into the bits\n \t     available in the number, so we'll store 0 in the exponent and\n \t     shift the fraction to the right to make up for it.  */\n@@ -242,34 +257,46 @@ pack_d ( fp_number_type *  src)\n \t      exp += 1;\n \t    }\n \t  fraction >>= NGARDS;\n+#endif /* NO_DENORMALS */\n \t}\n-      else if (src->normal_exp > EXPBIAS)\n+      else if (!LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS)\n+\t       && src->normal_exp > EXPBIAS)\n \t{\n \t  exp = EXPMAX;\n \t  fraction = 0;\n \t}\n       else\n \t{\n \t  exp = src->normal_exp + EXPBIAS;\n-\t  /* IF the gard bits are the all zero, but the first, then we're\n-\t     half way between two numbers, choose the one which makes the\n-\t     lsb of the answer 0.  */\n-\t  if ((fraction & GARDMASK) == GARDMSB)\n-\t    {\n-\t      if (fraction & (1 << NGARDS))\n-\t\tfraction += GARDROUND + 1;\n-\t    }\n-\t  else\n+\t  if (!ROUND_TOWARDS_ZERO)\n \t    {\n-\t      /* Add a one to the guards to round up */\n-\t      fraction += GARDROUND;\n+\t      /* IF the gard bits are the all zero, but the first, then we're\n+\t\t half way between two numbers, choose the one which makes the\n+\t\t lsb of the answer 0.  */\n+\t      if ((fraction & GARDMASK) == GARDMSB)\n+\t\t{\n+\t\t  if (fraction & (1 << NGARDS))\n+\t\t    fraction += GARDROUND + 1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Add a one to the guards to round up */\n+\t\t  fraction += GARDROUND;\n+\t\t}\n+\t      if (fraction >= IMPLICIT_2)\n+\t\t{\n+\t\t  fraction >>= 1;\n+\t\t  exp += 1;\n+\t\t}\n \t    }\n-\t  if (fraction >= IMPLICIT_2)\n+\t  fraction >>= NGARDS;\n+\n+\t  if (LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS) && exp > EXPMAX)\n \t    {\n-\t      fraction >>= 1;\n-\t      exp += 1;\n+\t      /* Saturate on overflow.  */\n+\t      exp = EXPMAX;\n+\t      fraction = ((fractype) 1 << FRACBITS) - 1;\n \t    }\n-\t  fraction >>= NGARDS;\n \t}\n     }\n \n@@ -359,7 +386,7 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n \t  dst->fraction.ll = fraction;\n \t}\n     }\n-  else if (exp == EXPMAX)\n+  else if (!LARGEST_EXPONENT_IS_NORMAL (FRAC_NBITS) && exp == EXPMAX)\n     {\n       /* Huge exponent*/\n       if (fraction == 0)\n@@ -729,7 +756,7 @@ _fpmul_parts ( fp_number_type *  a,\n \t}\n     }\n #endif\n-  if ((high & GARDMASK) == GARDMSB)\n+  if (!ROUND_TOWARDS_ZERO && (high & GARDMASK) == GARDMSB)\n     {\n       if (high & (1 << NGARDS))\n \t{\n@@ -839,7 +866,7 @@ _fpdiv_parts (fp_number_type * a,\n \tnumerator *= 2;\n       }\n \n-    if ((quotient & GARDMASK) == GARDMSB)\n+    if (!ROUND_TOWARDS_ZERO && (quotient & GARDMASK) == GARDMSB)\n       {\n \tif (quotient & (1 << NGARDS))\n \t  {"}, {"sha": "ffec32c626665be9757e8481948dc086c82cd23d", "filename": "gcc/defaults.h", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcaac1d8c04d2966e667e1e4b18959bb94656c9/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcaac1d8c04d2966e667e1e4b18959bb94656c9/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=3fcaac1d8c04d2966e667e1e4b18959bb94656c9", "patch": "@@ -465,14 +465,26 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #define MODE_BASE_REG_CLASS(MODE) BASE_REG_CLASS\n #endif\n \n+#ifndef LARGEST_EXPONENT_IS_NORMAL\n+#define LARGEST_EXPONENT_IS_NORMAL(SIZE) 0\n+#endif\n+\n+#ifndef ROUND_TOWARDS_ZERO\n+#define ROUND_TOWARDS_ZERO 0\n+#endif\n+\n #ifndef MODE_HAS_NANS\n-#define MODE_HAS_NANS(MODE) \\\n-  (FLOAT_MODE_P (MODE) && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n+#define MODE_HAS_NANS(MODE)\t\t\t\t\t\\\n+  (FLOAT_MODE_P (MODE)\t\t\t\t\t\t\\\n+   && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\t\t\t\\\n+   && !LARGEST_EXPONENT_IS_NORMAL (GET_MODE_BITSIZE (MODE)))\n #endif\n \n #ifndef MODE_HAS_INFINITIES\n-#define MODE_HAS_INFINITIES(MODE) \\\n-  (FLOAT_MODE_P (MODE) && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n+#define MODE_HAS_INFINITIES(MODE)\t\t\t\t\\\n+  (FLOAT_MODE_P (MODE)\t\t\t\t\t\t\\\n+   && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\t\t\t\\\n+   && !LARGEST_EXPONENT_IS_NORMAL (GET_MODE_BITSIZE (MODE)))\n #endif\n \n #ifndef MODE_HAS_SIGNED_ZEROS\n@@ -481,8 +493,10 @@ You Lose!  You must define PREFERRED_DEBUGGING_TYPE!\n #endif\n \n #ifndef MODE_HAS_SIGN_DEPENDENT_ROUNDING\n-#define MODE_HAS_SIGN_DEPENDENT_ROUNDING(MODE) \\\n-  (FLOAT_MODE_P (MODE) && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT)\n+#define MODE_HAS_SIGN_DEPENDENT_ROUNDING(MODE)\t\t\t\\\n+  (FLOAT_MODE_P (MODE)\t\t\t\t\t\t\\\n+   && TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\t\t\t\\\n+   && !ROUND_TOWARDS_ZERO)\n #endif\n \n #endif  /* ! GCC_DEFAULTS_H */"}, {"sha": "ad7917eca4b910da8e1a9248ab26e4c572cbb739", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcaac1d8c04d2966e667e1e4b18959bb94656c9/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcaac1d8c04d2966e667e1e4b18959bb94656c9/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=3fcaac1d8c04d2966e667e1e4b18959bb94656c9", "patch": "@@ -1385,6 +1385,46 @@ towards @minus{}infinity and towards +infinity.\n \n The default definition of this macro is true if @var{mode} is\n a floating-point mode and the target format is IEEE@.\n+\n+@findex ROUND_TOWARDS_ZERO\n+@item ROUND_TOWARDS_ZERO\n+If defined, this macro should be true if the prevailing rounding\n+mode is towards zero.  A true value has the following effects:\n+\n+@itemize @bullet\n+@item\n+@code{MODE_HAS_SIGN_DEPENDENT_ROUNDING} will be false for all modes.\n+\n+@item\n+@file{libgcc.a}'s floating-point emulator will round towards zero\n+rather than towards nearest.\n+\n+@item\n+The compiler's floating-point emulator will round towards zero after\n+doing arithmetic, and when converting from the internal float format to\n+the target format.\n+@end itemize\n+\n+The macro does not affect the parsing of string literals.  When the\n+primary rounding mode is towards zero, library functions like\n+@code{strtod} might still round towards nearest, and the compiler's\n+parser should behave like the target's @code{strtod} where possible.\n+\n+Not defining this macro is equivalent to returning zero.\n+\n+@findex LARGEST_EXPONENT_IS_NORMAL\n+@item LARGEST_EXPONENT_IS_NORMAL (@var{size})\n+This macro should only be defined when the target float format is\n+described as IEEE@.  It should return true if floats with @var{size}\n+bits do not have a NaN or infinity representation, but use the largest\n+exponent for normal numbers instead.\n+\n+Defining this macro to true for @var{size} causes @code{MODE_HAS_NANS}\n+and @code{MODE_HAS_INFINITIES} to be false for @var{size}-bit modes.\n+It also affects the way @file{libgcc.a} and @file{real.c} emulate\n+floating-point arithmetic.\n+\n+The default definition of this macro returns false for all sizes.\n @end table\n \n @deftypefn {Target Hook} bool TARGET_MS_BITFIELD_LAYOUT_P (tree @var{record_type})"}, {"sha": "0d3e657ce9cc6d91b721dfde34666fd0b60dffe1", "filename": "gcc/real.c", "status": "modified", "additions": 61, "deletions": 14, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fcaac1d8c04d2966e667e1e4b18959bb94656c9/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fcaac1d8c04d2966e667e1e4b18959bb94656c9/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=3fcaac1d8c04d2966e667e1e4b18959bb94656c9", "patch": "@@ -336,6 +336,7 @@ static int eiisnan\tPARAMS ((const UEMUSHORT *));\n static int eiisneg\tPARAMS ((const UEMUSHORT *));\n static void make_nan\tPARAMS ((UEMUSHORT *, int, enum machine_mode));\n #endif\n+static void saturate\tPARAMS ((UEMUSHORT *, int, int, int));\n static void emovi\tPARAMS ((const UEMUSHORT *, UEMUSHORT *));\n static void emovo\tPARAMS ((const UEMUSHORT *, UEMUSHORT *));\n static void ecleaz\tPARAMS ((UEMUSHORT *));\n@@ -2871,7 +2872,7 @@ eadd1 (a, b, c)\n       esubm (ai, bi);\n       subflg = 1;\n     }\n-  emdnorm (bi, lost, subflg, ltb, 64);\n+  emdnorm (bi, lost, subflg, ltb, !ROUND_TOWARDS_ZERO);\n \n  done:\n   emovo (bi, c);\n@@ -2967,7 +2968,7 @@ ediv (a, b, c)\n   i = edivm (ai, bi);\n   /* calculate exponent */\n   lt = ltb - lta + EXONE;\n-  emdnorm (bi, i, 0, lt, 64);\n+  emdnorm (bi, i, 0, lt, !ROUND_TOWARDS_ZERO);\n   emovo (bi, c);\n \n  divsign:\n@@ -3064,7 +3065,7 @@ emul (a, b, c)\n   j = emulm (ai, bi);\n   /* calculate exponent */\n   lt = lta + ltb - (EXONE - 1);\n-  emdnorm (bi, j, 0, lt, 64);\n+  emdnorm (bi, j, 0, lt, !ROUND_TOWARDS_ZERO);\n   emovo (bi, c);\n \n  mulsign:\n@@ -3445,7 +3446,7 @@ e24toe (pe, y)\n   yy[M] = (r & 0x7f) | 0200;\n   r &= ~0x807f;\t\t\t/* strip sign and 7 significand bits */\n #ifdef INFINITY\n-  if (r == 0x7f80)\n+  if (!LARGEST_EXPONENT_IS_NORMAL (32) && r == 0x7f80)\n     {\n #ifdef NANS\n       if (REAL_WORDS_BIG_ENDIAN)\n@@ -3536,7 +3537,7 @@ etoe113 (x, e)\n   /* round off to nearest or even */\n   rndsav = rndprc;\n   rndprc = 113;\n-  emdnorm (xi, 0, 0, exp, 64);\n+  emdnorm (xi, 0, 0, exp, !ROUND_TOWARDS_ZERO);\n   rndprc = rndsav;\n #ifdef INFINITY\n  nonorm:\n@@ -3632,7 +3633,7 @@ etoe64 (x, e)\n   /* round off to nearest or even */\n   rndsav = rndprc;\n   rndprc = 64;\n-  emdnorm (xi, 0, 0, exp, 64);\n+  emdnorm (xi, 0, 0, exp, !ROUND_TOWARDS_ZERO);\n   rndprc = rndsav;\n #ifdef INFINITY\n  nonorm:\n@@ -3852,7 +3853,7 @@ etoe53 (x, e)\n   /* round off to nearest or even */\n   rndsav = rndprc;\n   rndprc = 53;\n-  emdnorm (xi, 0, 0, exp, 64);\n+  emdnorm (xi, 0, 0, exp, !ROUND_TOWARDS_ZERO);\n   rndprc = rndsav;\n #ifdef INFINITY\n  nonorm:\n@@ -3877,6 +3878,11 @@ toe53 (x, y)\n       return;\n     }\n #endif\n+  if (LARGEST_EXPONENT_IS_NORMAL (64) && x[1] > 2047)\n+    {\n+      saturate (y, eiisneg (x), 64, 1);\n+      return;\n+    }\n   p = &x[0];\n #ifdef IEEE\n   if (! REAL_WORDS_BIG_ENDIAN)\n@@ -4031,7 +4037,7 @@ etoe24 (x, e)\n   /* round off to nearest or even */\n   rndsav = rndprc;\n   rndprc = 24;\n-  emdnorm (xi, 0, 0, exp, 64);\n+  emdnorm (xi, 0, 0, exp, !ROUND_TOWARDS_ZERO);\n   rndprc = rndsav;\n #ifdef INFINITY\n  nonorm:\n@@ -4056,6 +4062,11 @@ toe24 (x, y)\n       return;\n     }\n #endif\n+  if (LARGEST_EXPONENT_IS_NORMAL (32) && x[1] > 255)\n+    {\n+      saturate (y, eiisneg (x), 32, 1);\n+      return;\n+    }\n   p = &x[0];\n #ifdef IEEE\n   if (! REAL_WORDS_BIG_ENDIAN)\n@@ -4070,7 +4081,7 @@ toe24 (x, y)\n \n   i = *p++;\n /* Handle overflow cases.  */\n-  if (i >= 255)\n+  if (!LARGEST_EXPONENT_IS_NORMAL (32) && i >= 255)\n     {\n #ifdef INFINITY\n       *y |= (UEMUSHORT) 0x7f80;\n@@ -5628,7 +5639,7 @@ eldexp (x, pwr2, y)\n   li = xi[1];\n   li += pwr2;\n   i = 0;\n-  emdnorm (xi, i, i, li, 64);\n+  emdnorm (xi, i, i, li, !ROUND_TOWARDS_ZERO);\n   emovo (xi, y);\n }\n \n@@ -5826,7 +5837,7 @@ etodec (x, d)\n   /* Round off to nearest or even.  */\n   rndsav = rndprc;\n   rndprc = 56;\n-  emdnorm (xi, 0, 0, exp, 64);\n+  emdnorm (xi, 0, 0, exp, !ROUND_TOWARDS_ZERO);\n   rndprc = rndsav;\n   todec (xi, d);\n }\n@@ -5938,7 +5949,7 @@ etoibm (x, d, mode)\n \t\t\t\t\t\t\t/* round off to nearest or even */\n   rndsav = rndprc;\n   rndprc = 56;\n-  emdnorm (xi, 0, 0, exp, 64);\n+  emdnorm (xi, 0, 0, exp, !ROUND_TOWARDS_ZERO);\n   rndprc = rndsav;\n   toibm (xi, d, mode);\n }\n@@ -6136,7 +6147,7 @@ etoc4x (x, d, mode)\n   /* Round off to nearest or even.  */\n   rndsav = rndprc;\n   rndprc = mode == QFmode ? 24 : 32;\n-  emdnorm (xi, 0, 0, exp, 64);\n+  emdnorm (xi, 0, 0, exp, !ROUND_TOWARDS_ZERO);\n   rndprc = rndsav;\n   toc4x (xi, d, mode);\n }\n@@ -6298,7 +6309,15 @@ make_nan (nan, sign, mode)\n {\n   int n;\n   const UEMUSHORT *p;\n+  int size;\n \n+  size = GET_MODE_BITSIZE (mode);\n+  if (LARGEST_EXPONENT_IS_NORMAL (size))\n+    {\n+      warning (\"%d-bit floats cannot hold NaNs\", size);\n+      saturate (nan, sign, size, 0);\n+      return;\n+    }\n   switch (mode)\n     {\n /* Possibly the `reserved operand' patterns on a VAX can be\n@@ -6353,6 +6372,34 @@ make_nan (nan, sign, mode)\n }\n #endif /* NANS */\n \n+\n+/* Create a saturation value for a SIZE-bit float, assuming that\n+   LARGEST_EXPONENT_IS_NORMAL (SIZE).\n+\n+   If SIGN is true, fill X with the most negative value, otherwise fill\n+   it with the most positive value.  WARN is true if the function should\n+   warn about overflow.  */\n+\n+static void\n+saturate (x, sign, size, warn)\n+     UEMUSHORT *x;\n+     int sign, size, warn;\n+{\n+  int i;\n+\n+  if (warn && extra_warnings)\n+    warning (\"value exceeds the range of a %d-bit float\", size);\n+\n+  /* Create the most negative value.  */\n+  for (i = 0; i < size / EMUSHORT_SIZE; i++)\n+    x[i] = 0xffff;\n+\n+  /* Make it positive, if necessary.  */\n+  if (!sign)\n+    x[REAL_WORDS_BIG_ENDIAN? 0 : i - 1] = 0x7fff;\n+}\n+\n+\n /* This is the inverse of the function `etarsingle' invoked by\n    REAL_VALUE_TO_TARGET_SINGLE.  */\n \n@@ -6876,7 +6923,7 @@ esqrt (x, y)\n     k |= (int) num[i];\n \n   /* Renormalize and round off.  */\n-  emdnorm (sq, k, 0, exp, 64);\n+  emdnorm (sq, k, 0, exp, !ROUND_TOWARDS_ZERO);\n   emovo (sq, y);\n }\n #endif"}]}