{"sha": "6945a32ec3fb20b5bba0d98a419da26c1c6b62d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk0NWEzMmVjM2ZiMjBiNWJiYTBkOThhNDE5ZGEyNmMxYzZiNjJkNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-03-20T16:25:54Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-03-20T16:25:54Z"}, "message": "re PR target/52607 (v4df __builtin_shuffle with {0,2,1,3} or {1,3,0,2})\n\n\tPR target/52607\n\t* config/i386/i386.md (\"isa\" attribute): Add avx2 and noavx2.\n\t(\"enabled\" attribute): Handle avx2 and noavx2 isas.\n\t* config/i386/sse.md (avx2_vec_dupv8sf_1, avx2_pbroadcast<mode>_1):\n\tNew insns.\n\t(vec_dup<mode>): Add avx2 =x,x alternative.\n\t(vec_dup<mode> splitter): Don't split if TARGET_AVX2.\n\t(*avx_vperm_broadcast_<mode>): Don't split V4DFmode if TARGET_AVX2.\n\tFor TARGET_AVX2, V8SFmode and elt == 0 split into vbroadcastss.\n\t* config/i386/i386.c (expand_vec_perm_pshufb): Emit also vpermps\n\tfor V8SFmode.\n\t(expand_vec_perm_1): For broadcasts, use avx2_pbroadcast<mode>_1\n\tif possible, handle also V8SFmode.\n\nFrom-SVN: r185577", "tree": {"sha": "125a00826bd91bb2914b8a2b8c72e9e6c03b8776", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/125a00826bd91bb2914b8a2b8c72e9e6c03b8776"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6945a32ec3fb20b5bba0d98a419da26c1c6b62d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6945a32ec3fb20b5bba0d98a419da26c1c6b62d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6945a32ec3fb20b5bba0d98a419da26c1c6b62d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6945a32ec3fb20b5bba0d98a419da26c1c6b62d4/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "681676df511683e888303c510562195c52c67607", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/681676df511683e888303c510562195c52c67607", "html_url": "https://github.com/Rust-GCC/gccrs/commit/681676df511683e888303c510562195c52c67607"}], "stats": {"total": 93, "additions": 78, "deletions": 15}, "files": [{"sha": "bc9a5b86e38928e5fb0de65d7b6705c314000fdd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6945a32ec3fb20b5bba0d98a419da26c1c6b62d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6945a32ec3fb20b5bba0d98a419da26c1c6b62d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6945a32ec3fb20b5bba0d98a419da26c1c6b62d4", "patch": "@@ -1,3 +1,19 @@\n+2012-03-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/52607\n+\t* config/i386/i386.md (\"isa\" attribute): Add avx2 and noavx2.\n+\t(\"enabled\" attribute): Handle avx2 and noavx2 isas.\n+\t* config/i386/sse.md (avx2_vec_dupv8sf_1, avx2_pbroadcast<mode>_1):\n+\tNew insns.\n+\t(vec_dup<mode>): Add avx2 =x,x alternative.\n+\t(vec_dup<mode> splitter): Don't split if TARGET_AVX2.\n+\t(*avx_vperm_broadcast_<mode>): Don't split V4DFmode if TARGET_AVX2.\n+\tFor TARGET_AVX2, V8SFmode and elt == 0 split into vbroadcastss.\n+\t* config/i386/i386.c (expand_vec_perm_pshufb): Emit also vpermps\n+\tfor V8SFmode.\n+\t(expand_vec_perm_1): For broadcasts, use avx2_pbroadcast<mode>_1\n+\tif possible, handle also V8SFmode.\n+\n 2012-03-20  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm/predicates.md (zero_operand, reg_or_zero_operand): New predicates."}, {"sha": "30ed61652be67844e3d071398db4360ec66d8bc0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6945a32ec3fb20b5bba0d98a419da26c1c6b62d4/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6945a32ec3fb20b5bba0d98a419da26c1c6b62d4/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6945a32ec3fb20b5bba0d98a419da26c1c6b62d4", "patch": "@@ -35836,7 +35836,7 @@ valid_perm_using_mode_p (enum machine_mode vmode, struct expand_vec_perm_d *d)\n }\n \n /* A subroutine of ix86_expand_vec_perm_builtin_1.  Try to implement D\n-   in terms of pshufb, vpperm, vpermq, vpermd or vperm2i128.  */\n+   in terms of pshufb, vpperm, vpermq, vpermd, vpermps or vperm2i128.  */\n \n static bool\n expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n@@ -35910,6 +35910,9 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n \t      if (valid_perm_using_mode_p (V8SImode, d))\n \t\tvmode = V8SImode;\n \t    }\n+\t  /* Or if vpermps can be used.  */\n+\t  else if (d->vmode == V8SFmode)\n+\t    vmode = V8SImode;\n \n \t  if (vmode == V32QImode)\n \t    {\n@@ -35952,6 +35955,12 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n \t\t\t\tgen_rtvec_v (GET_MODE_NUNITS (vmode), rperm));\n   vperm = force_reg (vmode, vperm);\n \n+  if (vmode == V8SImode && d->vmode == V8SFmode)\n+    {\n+      vmode = V8SFmode;\n+      vperm = gen_lowpart (vmode, vperm);\n+    }\n+\n   target = gen_lowpart (vmode, d->target);\n   op0 = gen_lowpart (vmode, d->op0);\n   if (d->op0 == d->op1)\n@@ -35960,6 +35969,8 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n \temit_insn (gen_ssse3_pshufbv16qi3 (target, op0, vperm));\n       else if (vmode == V32QImode)\n \temit_insn (gen_avx2_pshufbv32qi3 (target, op0, vperm));\n+      else if (vmode == V8SFmode)\n+\temit_insn (gen_avx2_permvarv8sf (target, vperm, op0));\n       else\n \temit_insn (gen_avx2_permvarv8si (target, vperm, op0));\n     }\n@@ -36008,34 +36019,34 @@ expand_vec_perm_1 (struct expand_vec_perm_d *d)\n       else if (broadcast_perm && TARGET_AVX2)\n \t{\n \t  /* Use vpbroadcast{b,w,d}.  */\n-\t  rtx op = d->op0, (*gen) (rtx, rtx) = NULL;\n+\t  rtx (*gen) (rtx, rtx) = NULL;\n \t  switch (d->vmode)\n \t    {\n \t    case V32QImode:\n-\t      op = gen_lowpart (V16QImode, op);\n-\t      gen = gen_avx2_pbroadcastv32qi;\n+\t      gen = gen_avx2_pbroadcastv32qi_1;\n \t      break;\n \t    case V16HImode:\n-\t      op = gen_lowpart (V8HImode, op);\n-\t      gen = gen_avx2_pbroadcastv16hi;\n+\t      gen = gen_avx2_pbroadcastv16hi_1;\n \t      break;\n \t    case V8SImode:\n-\t      op = gen_lowpart (V4SImode, op);\n-\t      gen = gen_avx2_pbroadcastv8si;\n+\t      gen = gen_avx2_pbroadcastv8si_1;\n \t      break;\n \t    case V16QImode:\n \t      gen = gen_avx2_pbroadcastv16qi;\n \t      break;\n \t    case V8HImode:\n \t      gen = gen_avx2_pbroadcastv8hi;\n \t      break;\n+\t    case V8SFmode:\n+\t      gen = gen_avx2_vec_dupv8sf_1;\n+\t      break;\n \t    /* For other modes prefer other shuffles this function creates.  */\n \t    default: break;\n \t    }\n \t  if (gen != NULL)\n \t    {\n \t      if (!d->testing_p)\n-\t\temit_insn (gen (d->target, op));\n+\t\temit_insn (gen (d->target, d->op0));\n \t      return true;\n \t    }\n \t}\n@@ -36103,7 +36114,7 @@ expand_vec_perm_1 (struct expand_vec_perm_d *d)\n     return true;\n \n   /* Try the SSSE3 pshufb or XOP vpperm or AVX2 vperm2i128,\n-     vpshufb, vpermd or vpermq variable permutation.  */\n+     vpshufb, vpermd, vpermps or vpermq variable permutation.  */\n   if (expand_vec_perm_pshufb (d))\n     return true;\n "}, {"sha": "2d20a52bc062eec3449fe6102a97139a91bc2969", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6945a32ec3fb20b5bba0d98a419da26c1c6b62d4/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6945a32ec3fb20b5bba0d98a419da26c1c6b62d4/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=6945a32ec3fb20b5bba0d98a419da26c1c6b62d4", "patch": "@@ -639,7 +639,7 @@\n (define_attr \"movu\" \"0,1\" (const_string \"0\"))\n \n ;; Used to control the \"enabled\" attribute on a per-instruction basis.\n-(define_attr \"isa\" \"base,sse2,sse2_noavx,sse3,sse4,sse4_noavx,noavx,avx,bmi2\"\n+(define_attr \"isa\" \"base,sse2,sse2_noavx,sse3,sse4,sse4_noavx,noavx,avx,avx2,noavx2,bmi2\"\n   (const_string \"base\"))\n \n (define_attr \"enabled\" \"\"\n@@ -652,6 +652,8 @@\n \t   (symbol_ref \"TARGET_SSE4_1 && !TARGET_AVX\")\n \t (eq_attr \"isa\" \"avx\") (symbol_ref \"TARGET_AVX\")\n \t (eq_attr \"isa\" \"noavx\") (symbol_ref \"!TARGET_AVX\")\n+\t (eq_attr \"isa\" \"avx2\") (symbol_ref \"TARGET_AVX2\")\n+\t (eq_attr \"isa\" \"noavx2\") (symbol_ref \"!TARGET_AVX2\")\n \t (eq_attr \"isa\" \"bmi2\") (symbol_ref \"TARGET_BMI2\")\n \t]\n \t(const_int 1)))"}, {"sha": "9a4728c009289212813ff649b4ce0e2e0787108f", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6945a32ec3fb20b5bba0d98a419da26c1c6b62d4/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6945a32ec3fb20b5bba0d98a419da26c1c6b62d4/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=6945a32ec3fb20b5bba0d98a419da26c1c6b62d4", "patch": "@@ -3808,6 +3808,18 @@\n     (set_attr \"prefix\" \"vex\")\n     (set_attr \"mode\" \"<MODE>\")])\n \n+(define_insn \"avx2_vec_dupv8sf_1\"\n+  [(set (match_operand:V8SF 0 \"register_operand\" \"=x\")\n+\t(vec_duplicate:V8SF\n+\t  (vec_select:SF\n+\t    (match_operand:V8SF 1 \"register_operand\" \"x\")\n+\t    (parallel [(const_int 0)]))))]\n+  \"TARGET_AVX2\"\n+  \"vbroadcastss\\t{%x1, %0|%0, %x1}\"\n+  [(set_attr \"type\" \"sselog1\")\n+    (set_attr \"prefix\" \"vex\")\n+    (set_attr \"mode\" \"V8SF\")])\n+\n (define_insn \"vec_dupv4sf\"\n   [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x,x\")\n \t(vec_duplicate:V4SF\n@@ -11876,6 +11888,19 @@\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n+(define_insn \"avx2_pbroadcast<mode>_1\"\n+  [(set (match_operand:VI_256 0 \"register_operand\" \"=x\")\n+\t(vec_duplicate:VI_256\n+\t  (vec_select:<ssescalarmode>\n+\t    (match_operand:VI_256 1 \"nonimmediate_operand\" \"xm\")\n+\t    (parallel [(const_int 0)]))))]\n+  \"TARGET_AVX2\"\n+  \"vpbroadcast<ssemodesuffix>\\t{%x1, %0|%0, %x1}\"\n+  [(set_attr \"type\" \"ssemov\")\n+   (set_attr \"prefix_extra\" \"1\")\n+   (set_attr \"prefix\" \"vex\")\n+   (set_attr \"mode\" \"<sseinsnmode>\")])\n+\n (define_insn \"avx2_permvarv8si\"\n   [(set (match_operand:V8SI 0 \"register_operand\" \"=x\")\n \t(unspec:V8SI\n@@ -11967,16 +11992,18 @@\n   [V8SI V8SF V4DI V4DF])\n \n (define_insn \"vec_dup<mode>\"\n-  [(set (match_operand:AVX_VEC_DUP_MODE 0 \"register_operand\" \"=x,x\")\n+  [(set (match_operand:AVX_VEC_DUP_MODE 0 \"register_operand\" \"=x,x,x\")\n \t(vec_duplicate:AVX_VEC_DUP_MODE\n-\t  (match_operand:<ssescalarmode> 1 \"nonimmediate_operand\" \"m,?x\")))]\n+\t  (match_operand:<ssescalarmode> 1 \"nonimmediate_operand\" \"m,x,?x\")))]\n   \"TARGET_AVX\"\n   \"@\n    vbroadcast<ssescalarmodesuffix>\\t{%1, %0|%0, %1}\n+   vbroadcast<ssescalarmodesuffix>\\t{%x1, %0|%0, %x1}\n    #\"\n   [(set_attr \"type\" \"ssemov\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"prefix\" \"vex\")\n+   (set_attr \"isa\" \"*,avx2,noavx2\")\n    (set_attr \"mode\" \"V8SF\")])\n \n (define_insn \"avx2_vbroadcasti128_<mode>\"\n@@ -11995,7 +12022,7 @@\n   [(set (match_operand:AVX_VEC_DUP_MODE 0 \"register_operand\")\n \t(vec_duplicate:AVX_VEC_DUP_MODE\n \t  (match_operand:<ssescalarmode> 1 \"register_operand\")))]\n-  \"TARGET_AVX && reload_completed\"\n+  \"TARGET_AVX && !TARGET_AVX2 && reload_completed\"\n   [(set (match_dup 2)\n \t(vec_duplicate:<ssehalfvecmode> (match_dup 1)))\n    (set (match_dup 0)\n@@ -12057,7 +12084,7 @@\n \t    [(match_operand 3 \"const_int_operand\" \"C,n,n\")])))]\n   \"TARGET_AVX\"\n   \"#\"\n-  \"&& reload_completed\"\n+  \"&& reload_completed && (<MODE>mode != V4DFmode || !TARGET_AVX2)\"\n   [(set (match_dup 0) (vec_duplicate:VF_256 (match_dup 1)))]\n {\n   rtx op0 = operands[0], op1 = operands[1];\n@@ -12067,6 +12094,13 @@\n     {\n       int mask;\n \n+      if (TARGET_AVX2 && elt == 0)\n+\t{\n+\t  emit_insn (gen_vec_dup<mode> (op0, gen_lowpart (<ssescalarmode>mode,\n+\t\t\t\t\t\t\t  op1)));\n+\t  DONE;\n+\t}\n+\n       /* Shuffle element we care about into all elements of the 128-bit lane.\n \t The other lane gets shuffled too, but we don't care.  */\n       if (<MODE>mode == V4DFmode)"}]}