{"sha": "73fbfcad22ae37dfd57a544aa0f5339b73bac439", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNmYmZjYWQyMmFlMzdkZmQ1N2E1NDRhYTBmNTMzOWI3M2JhYzQzOQ==", "commit": {"author": {"name": "Sharad Singhai", "email": "singhai@google.com", "date": "2012-10-24T17:58:14Z"}, "committer": {"name": "Sharad Singhai", "email": "singhai@gcc.gnu.org", "date": "2012-10-24T17:58:14Z"}, "message": "dumpfile.c (dump_enabled_p): Make it inline and move the definition to dumpfile.h.\n\n2012-10-24  Sharad Singhai  <singhai@google.com>\n\n\t* dumpfile.c (dump_enabled_p): Make it inline and move the definition\n\tto dumpfile.h.\n\t(dump_kind_p): Deleted. Functionality replaced by dump_enabled_p.\n\tMake alt_dump_file extern.\n\t* dumpfile.h (dump_enabled_p): Move inline definition here.\n\t(dump_kind_p): Delete declaration.\n\tAdd extern declaration of alt_dump_file.\n\t* toplev.c: Move dump_file and dump_file_name to dumpfile.c.\n\t* tree-vect-loop-manip.c: Replace all uses of dump_kind_p with\n\tdump_enabled_p.\n\t* tree-vectorizer.c: Likewise.\n\t* tree-vect-loop.c: Likewise.\n\t* tree-vect-data-refs.c: Likewise.\n\t* tree-vect-patterns.c: Likewise.\n\t* tree-vect-stmts.c: Likewise.\n\t* tree-vect-slp.c: Likewise.\n\nFrom-SVN: r192773", "tree": {"sha": "02a5de43f1e1e7c9de68e336f7b7bb4d2593dbf3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02a5de43f1e1e7c9de68e336f7b7bb4d2593dbf3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73fbfcad22ae37dfd57a544aa0f5339b73bac439", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73fbfcad22ae37dfd57a544aa0f5339b73bac439", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73fbfcad22ae37dfd57a544aa0f5339b73bac439", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73fbfcad22ae37dfd57a544aa0f5339b73bac439/comments", "author": null, "committer": null, "parents": [{"sha": "c1a4d0b580e3c394d1ff9790fa581590aa7e953f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1a4d0b580e3c394d1ff9790fa581590aa7e953f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1a4d0b580e3c394d1ff9790fa581590aa7e953f"}], "stats": {"total": 1021, "additions": 515, "deletions": 506}, "files": [{"sha": "71311d908de476685b20ee8da197af8db10dbeda", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73fbfcad22ae37dfd57a544aa0f5339b73bac439", "patch": "@@ -1,3 +1,22 @@\n+2012-10-24  Sharad Singhai  <singhai@google.com>\n+\n+\t* dumpfile.c (dump_enabled_p): Make it inline and move the definition\n+\tto dumpfile.h.\n+\t(dump_kind_p): Deleted. Functionality replaced by dump_enabled_p.\n+\tMake alt_dump_file extern.\n+\t* dumpfile.h (dump_enabled_p): Move inline definition here.\n+\t(dump_kind_p): Delete declaration.\n+\tAdd extern declaration of alt_dump_file.\n+\t* toplev.c: Move dump_file and dump_file_name to dumpfile.c.\n+\t* tree-vect-loop-manip.c: Replace all uses of dump_kind_p with\n+\tdump_enabled_p.\n+\t* tree-vectorizer.c: Likewise.\n+\t* tree-vect-loop.c: Likewise.\n+\t* tree-vect-data-refs.c: Likewise.\n+\t* tree-vect-patterns.c: Likewise.\n+\t* tree-vect-stmts.c: Likewise.\n+\t* tree-vect-slp.c: Likewise.\n+\n 2012-10-24  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* expmed.c (lowpart_bit_field_p): Add missing == 0 check."}, {"sha": "0f36afae42a3aa69fcc84878a1664ca0330fd114", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=73fbfcad22ae37dfd57a544aa0f5339b73bac439", "patch": "@@ -32,12 +32,18 @@ along with GCC; see the file COPYING3.  If not see\n \n static int pflags;                   /* current dump_flags */\n static int alt_flags;                /* current opt_info flags */\n-static FILE *alt_dump_file = NULL;\n \n static void dump_loc (int, FILE *, source_location);\n static int dump_phase_enabled_p (int);\n static FILE *dump_open_alternate_stream (struct dump_file_info *);\n \n+/* These are currently used for communicating between passes.\n+   However, instead of accessing them directly, the passes can use\n+   dump_printf () for dumps.  */\n+FILE *dump_file = NULL;\n+FILE *alt_dump_file = NULL;\n+const char *dump_file_name;\n+\n /* Table of tree dump switches. This must be consistent with the\n    TREE_DUMP_INDEX enumeration in dumpfile.h.  */\n static struct dump_file_info dump_files[TDI_end] =\n@@ -514,14 +520,6 @@ dump_phase_enabled_p (int phase)\n     }\n }\n \n-/* Return true if any of the dumps are enabled, false otherwise. */\n-\n-inline bool\n-dump_enabled_p (void)\n-{\n-  return (dump_file || alt_dump_file);\n-}\n-\n /* Returns nonzero if tree dump PHASE has been initialized.  */\n \n int\n@@ -836,16 +834,6 @@ opt_info_switch_p (const char *arg)\n   return opt_info_enable_all ((TDF_TREE | TDF_RTL | TDF_IPA), flags, filename);\n }\n \n-/* Return true if any dumps are enabled for the given MSG_TYPE, false\n-   otherwise.  */\n-\n-bool\n-dump_kind_p (int msg_type)\n-{\n-  return (dump_file && (msg_type & pflags))\n-    || (alt_dump_file && (msg_type & alt_flags));\n-}\n-\n /* Print basic block on the dump streams.  */\n \n void"}, {"sha": "b2efc804c096838f6368bac8a0776854f6fbd602", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=73fbfcad22ae37dfd57a544aa0f5339b73bac439", "patch": "@@ -108,7 +108,6 @@ struct dump_file_info\n   int num;                      /* dump file number */\n };\n \n-\n /* In dumpfile.c */\n extern char *get_dump_file_name (int);\n extern int dump_initialized_p (int);\n@@ -120,8 +119,6 @@ extern void dump_node (const_tree, int, FILE *);\n extern int dump_switch_p (const char *);\n extern int opt_info_switch_p (const char *);\n extern const char *dump_flag_name (int);\n-extern bool dump_kind_p (int);\n-extern inline bool dump_enabled_p (void);\n extern void dump_printf (int, const char *, ...) ATTRIBUTE_PRINTF_2;\n extern void dump_printf_loc (int, source_location,\n                              const char *, ...) ATTRIBUTE_PRINTF_3;\n@@ -142,10 +139,19 @@ extern void dump_bb (FILE *, basic_block, int, int);\n \n /* Global variables used to communicate with passes.  */\n extern FILE *dump_file;\n+extern FILE *alt_dump_file;\n extern int dump_flags;\n extern const char *dump_file_name;\n \n /* Return the dump_file_info for the given phase.  */\n extern struct dump_file_info *get_dump_file_info (int);\n \n+/* Return true if any of the dumps are enabled, false otherwise. */\n+\n+static inline bool\n+dump_enabled_p (void)\n+{\n+  return (dump_file || alt_dump_file);\n+}\n+\n #endif /* GCC_DUMPFILE_H */"}, {"sha": "5cbb36411de331663782e093829052e138ad0ed7", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=73fbfcad22ae37dfd57a544aa0f5339b73bac439", "patch": "@@ -169,8 +169,6 @@ const char *user_label_prefix;\n FILE *asm_out_file;\n FILE *aux_info_file;\n FILE *stack_usage_file = NULL;\n-FILE *dump_file = NULL;\n-const char *dump_file_name;\n \n /* The current working directory of a translation.  It's generally the\n    directory from which compilation was initiated, but a preprocessed"}, {"sha": "5866b0652d0cdf6b5fe1a619db60243e16636db8", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 95, "deletions": 96, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=73fbfcad22ae37dfd57a544aa0f5339b73bac439", "patch": "@@ -60,7 +60,7 @@ vect_lanes_optab_supported_p (const char *name, convert_optab optab,\n \n   if (array_mode == BLKmode)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                          \"no array mode for %s[\" HOST_WIDE_INT_PRINT_DEC \"]\",\n                          GET_MODE_NAME (mode), count);\n@@ -69,14 +69,14 @@ vect_lanes_optab_supported_p (const char *name, convert_optab optab,\n \n   if (convert_optab_handler (optab, array_mode, mode) == CODE_FOR_nothing)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"cannot use %s<%s><%s>\", name,\n                          GET_MODE_NAME (array_mode), GET_MODE_NAME (mode));\n       return false;\n     }\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"can use %s<%s><%s>\", name, GET_MODE_NAME (array_mode),\n                      GET_MODE_NAME (mode));\n@@ -439,7 +439,7 @@ vect_check_interleaving (struct data_reference *dra,\n       if (diff_mod_size == 0)\n \t{\n \t  vect_update_interleaving_chain (drb, dra);\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n                                \"Detected interleaving \");\n@@ -462,7 +462,7 @@ vect_check_interleaving (struct data_reference *dra,\n       if (diff_mod_size == 0)\n \t{\n \t  vect_update_interleaving_chain (dra, drb);\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n                                \"Detected interleaving \");\n@@ -524,7 +524,7 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n   if ((unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS) == 0)\n     return false;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"mark for run-time aliasing test between \");\n@@ -535,7 +535,7 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n \n   if (optimize_loop_nest_for_size_p (loop))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                          \"versioning not supported when optimizing for size.\");\n       return false;\n@@ -544,7 +544,7 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n   /* FORNOW: We don't support versioning with outer-loop vectorization.  */\n   if (loop->inner)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                          \"versioning not yet supported for outer-loops.\");\n       return false;\n@@ -555,7 +555,7 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n   if (TREE_CODE (DR_STEP (DDR_A (ddr))) != INTEGER_CST\n       || TREE_CODE (DR_STEP (DDR_B (ddr))) != INTEGER_CST)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                          \"versioning not yet supported for non-constant \"\n                          \"step\");\n@@ -611,7 +611,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \n       if (loop_vinfo)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                \"versioning for alias required: \"\n@@ -637,7 +637,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n       if (DR_IS_READ (dra) && DR_IS_READ (drb))\n         return false;\n \n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                            \"can't determine dependence between \");\n@@ -666,7 +666,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n       if (dra != drb && vect_check_interleaving (dra, drb))\n         return false;\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"determined dependence between \");\n@@ -686,7 +686,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   /* Loop-based vectorization and known data dependence.  */\n   if (DDR_NUM_DIST_VECTS (ddr) == 0)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                            \"versioning for alias required: \"\n@@ -704,13 +704,13 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n     {\n       int dist = dist_v[loop_depth];\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n                          \"dependence distance  = %d.\", dist);\n \n       if (dist == 0)\n \t{\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location, \n                                \"dependence distance == 0 between \");\n@@ -737,7 +737,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  /* If DDR_REVERSED_P the order of the data-refs in DDR was\n \t     reversed (to make distance vector positive), and the actual\n \t     distance is negative.  */\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"dependence distance negative.\");\n \t  continue;\n@@ -749,7 +749,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  /* The dependence distance requires reduction of the maximal\n \t     vectorization factor.  */\n \t  *max_vf = abs (dist);\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n                              \"adjusting maximal vectorization factor to %i\",\n                              *max_vf);\n@@ -759,13 +759,13 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t{\n \t  /* Dependence distance does not create dependence, as far as\n \t     vectorization is concerned, in this case.  */\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n                              \"dependence distance >= VF.\");\n \t  continue;\n \t}\n \n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                        \"not vectorized, possible dependence \"\n@@ -795,7 +795,7 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo,\n   VEC (ddr_p, heap) *ddrs = NULL;\n   struct data_dependence_relation *ddr;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_analyze_dependences ===\");\n   if (loop_vinfo)\n@@ -837,7 +837,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   tree misalign;\n   tree aligned_to, alignment;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_compute_data_ref_alignment:\");\n \n@@ -870,7 +870,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \n       if (dr_step % GET_MODE_SIZE (TYPE_MODE (vectype)) == 0)\n         {\n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location,\n                              \"inner step divides the vector-size.\");\n \t  misalign = STMT_VINFO_DR_INIT (stmt_info);\n@@ -879,7 +879,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n         }\n       else\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"inner step doesn't divide the vector-size.\");\n \t  misalign = NULL_TREE;\n@@ -898,7 +898,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \n       if (dr_step % GET_MODE_SIZE (TYPE_MODE (vectype)) != 0)\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                              \"SLP: step doesn't divide the vector-size.\");\n \t  misalign = NULL_TREE;\n@@ -911,7 +911,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   if ((aligned_to && tree_int_cst_compare (aligned_to, alignment) < 0)\n       || !misalign)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                            \"Unknown alignment for access: \");\n@@ -941,7 +941,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       if (!vect_can_force_dr_alignment_p (base, TYPE_ALIGN (vectype))\n \t  || (TREE_STATIC (base) && flag_section_anchors))\n \t{\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n                                \"can't force alignment of ref: \");\n@@ -953,7 +953,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       /* Force the alignment of the decl.\n \t NOTE: This is the only change to the code we make during\n \t the analysis phase, before deciding to vectorize the loop.  */\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_NOTE, vect_location, \"force alignment of \");\n           dump_generic_expr (MSG_NOTE, TDF_SLIM, ref);\n@@ -987,15 +987,15 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   if (!host_integerp (misalign, 1))\n     {\n       /* Negative or overflowed misalignment value.  */\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"unexpected misalign value\");\n       return false;\n     }\n \n   SET_DR_MISALIGNMENT (dr, TREE_INT_CST_LOW (misalign));\n \n-  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                        \"misalign = %d bytes of ref \", DR_MISALIGNMENT (dr));\n@@ -1095,7 +1095,7 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n       return;\n     }\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"Setting misalignment to -1.\");\n   SET_DR_MISALIGNMENT (dr, -1);\n }\n@@ -1142,7 +1142,7 @@ vect_verify_datarefs_alignment (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n       supportable_dr_alignment = vect_supportable_dr_alignment (dr, false);\n       if (!supportable_dr_alignment)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             {\n               if (DR_IS_READ (dr))\n                 dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1157,8 +1157,7 @@ vect_verify_datarefs_alignment (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n             }\n           return false;\n         }\n-      if (supportable_dr_alignment != dr_aligned\n-          && dump_kind_p (MSG_NOTE))\n+      if (supportable_dr_alignment != dr_aligned && dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"Vectorizing an unaligned access.\");\n     }\n@@ -1215,7 +1214,7 @@ vector_alignment_reachable_p (struct data_reference *dr)\n     {\n       HOST_WIDE_INT elmsize =\n \t\tint_cst_value (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location, \n                            \"data size =\" HOST_WIDE_INT_PRINT_DEC, elmsize);\n@@ -1224,7 +1223,7 @@ vector_alignment_reachable_p (struct data_reference *dr)\n \t}\n       if (DR_MISALIGNMENT (dr) % elmsize)\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                              \"data size does not divide the misalignment.\\n\");\n \t  return false;\n@@ -1235,7 +1234,7 @@ vector_alignment_reachable_p (struct data_reference *dr)\n     {\n       tree type = TREE_TYPE (DR_REF (dr));\n       bool is_packed = not_size_aligned (DR_REF (dr));\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                          \"Unknown misalignment, is_packed = %d\",is_packed);\n       if (targetm.vectorize.vector_alignment_reachable (type, is_packed))\n@@ -1269,7 +1268,7 @@ vect_get_data_access_cost (struct data_reference *dr,\n   else\n     vect_get_store_cost (dr, ncopies, inside_cost, body_cost_vec);\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_get_data_access_cost: inside_cost = %d, \"\n                      \"outside_cost = %d.\", *inside_cost, *outside_cost);\n@@ -1567,7 +1566,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n   unsigned int nelements, mis, same_align_drs_max = 0;\n   stmt_vector_for_cost body_cost_vec = NULL;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_enhance_data_refs_alignment ===\");\n \n@@ -1622,7 +1621,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t and so we can't generate the new base for the pointer.  */\n       if (STMT_VINFO_STRIDE_LOAD_P (stmt_info))\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"strided load prevents peeling\");\n \t  do_peeling = false;\n@@ -1738,7 +1737,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n         {\n           if (!aligned_access_p (dr))\n             {\n-              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+              if (dump_enabled_p ())\n                 dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                                  \"vector alignment may not be reachable\");\n               break;\n@@ -1879,7 +1878,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n \t    npeel /= GROUP_SIZE (stmt_info);\n \n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location,\n                              \"Try peeling by %d\", npeel);\n         }\n@@ -1951,7 +1950,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           else\n             LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) = DR_MISALIGNMENT (dr0);\n \t  SET_DR_MISALIGNMENT (dr0, 0);\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_NOTE, vect_location,\n                                \"Alignment of access forced using peeling.\");\n@@ -2077,12 +2076,12 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n           dr = STMT_VINFO_DATA_REF (stmt_info);\n \t  SET_DR_MISALIGNMENT (dr, 0);\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location, \n                              \"Alignment of access forced using versioning.\");\n         }\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location, \n                          \"Versioning for alignment will be applied.\");\n \n@@ -2148,7 +2147,7 @@ vect_find_same_alignment_drs (struct data_dependence_relation *ddr,\n     {\n       int dist = dist_v[loop_depth];\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n                          \"dependence distance  = %d.\", dist);\n \n@@ -2159,7 +2158,7 @@ vect_find_same_alignment_drs (struct data_dependence_relation *ddr,\n \t  /* Two references with distance zero have the same alignment.  */\n \t  VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_a), drb);\n \t  VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_b), dra);\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n               dump_printf_loc (MSG_NOTE, vect_location,\n                                \"accesses have the same alignment.\");\n@@ -2183,7 +2182,7 @@ bool\n vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo,\n                                   bb_vec_info bb_vinfo)\n {\n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_analyze_data_refs_alignment ===\");\n \n@@ -2201,7 +2200,7 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo,\n \n   if (!vect_compute_data_refs_alignment (loop_vinfo, bb_vinfo))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                          \"not vectorized: can't calculate alignment \"\n                          \"for data ref.\");\n@@ -2254,7 +2253,7 @@ vect_analyze_group_access (struct data_reference *dr)\n \t{\n \t  GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = stmt;\n \t  GROUP_SIZE (vinfo_for_stmt (stmt)) = groupsize;\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location, \n                                \"Detected single element interleaving \");\n@@ -2265,13 +2264,13 @@ vect_analyze_group_access (struct data_reference *dr)\n \n \t  if (loop_vinfo)\n \t    {\n-\t      if (dump_kind_p (MSG_NOTE))\n+\t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_NOTE, vect_location,\n                                  \"Data access with gaps requires scalar \"\n                                  \"epilogue loop\");\n               if (loop->inner)\n                 {\n-                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                  if (dump_enabled_p ())\n                     dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                      \"Peeling for outer loop is not\"\n                                      \" supported\");\n@@ -2284,7 +2283,7 @@ vect_analyze_group_access (struct data_reference *dr)\n \t  return true;\n \t}\n \n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         {\n  \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                            \"not consecutive access \");\n@@ -2324,7 +2323,7 @@ vect_analyze_group_access (struct data_reference *dr)\n             {\n               if (DR_IS_WRITE (data_ref))\n                 {\n-                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                  if (dump_enabled_p ())\n                     dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                                      \"Two store stmts share the same dr.\");\n                   return false;\n@@ -2335,7 +2334,7 @@ vect_analyze_group_access (struct data_reference *dr)\n               if (GROUP_READ_WRITE_DEPENDENCE (vinfo_for_stmt (next))\n                   || GROUP_READ_WRITE_DEPENDENCE (vinfo_for_stmt (prev)))\n                 {\n-                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                  if (dump_enabled_p ())\n                     dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                                      \"READ_WRITE dependence in interleaving.\");\n                   return false;\n@@ -2355,7 +2354,7 @@ vect_analyze_group_access (struct data_reference *dr)\n           next_step = DR_STEP (STMT_VINFO_DATA_REF (vinfo_for_stmt (next)));\n           if (tree_int_cst_compare (step, next_step))\n             {\n-              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+              if (dump_enabled_p ())\n                 dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                                  \"not consecutive access in interleaving\");\n               return false;\n@@ -2372,7 +2371,7 @@ vect_analyze_group_access (struct data_reference *dr)\n \t      slp_impossible = true;\n \t      if (DR_IS_WRITE (data_ref))\n \t\t{\n-                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                  if (dump_enabled_p ())\n                     dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                                      \"interleaved store with gaps\");\n \t\t  return false;\n@@ -2401,7 +2400,7 @@ vect_analyze_group_access (struct data_reference *dr)\n          greater than STEP.  */\n       if (dr_step && dr_step < count_in_bytes + gaps * type_size)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                                \"interleaving size is greater than step for \");\n@@ -2424,7 +2423,7 @@ vect_analyze_group_access (struct data_reference *dr)\n             }\n           else\n             {\n-              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+              if (dump_enabled_p ())\n                 dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                                  \"interleaved store with gaps\");\n               return false;\n@@ -2434,7 +2433,7 @@ vect_analyze_group_access (struct data_reference *dr)\n       /* Check that STEP is a multiple of type size.  */\n       if (dr_step && (dr_step % type_size) != 0)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                \"step is not a multiple of type size: step \");\n@@ -2450,7 +2449,7 @@ vect_analyze_group_access (struct data_reference *dr)\n         groupsize = count;\n \n       GROUP_SIZE (vinfo_for_stmt (stmt)) = groupsize;\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location, \n                          \"Detected interleaving of size %d\", (int)groupsize);\n \n@@ -2469,13 +2468,13 @@ vect_analyze_group_access (struct data_reference *dr)\n       /* There is a gap in the end of the group.  */\n       if (groupsize - last_accessed_element > 0 && loop_vinfo)\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"Data access with gaps requires scalar \"\n                              \"epilogue loop\");\n           if (loop->inner)\n             {\n-              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+              if (dump_enabled_p ())\n                 dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                                  \"Peeling for outer loop is not supported\");\n               return false;\n@@ -2508,7 +2507,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \n   if (loop_vinfo && !step)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                          \"bad data-ref access in loop\");\n       return false;\n@@ -2531,7 +2530,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n       step = STMT_VINFO_DR_STEP (stmt_info);\n       if (integer_zerop (step))\n \t{\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n                              \"zero step in outer loop.\");\n \t  if (DR_IS_READ (dr))\n@@ -2557,7 +2556,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \n   if (loop && nested_in_vect_loop_p (loop, stmt))\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n                          \"grouped access in outer loop.\");\n       return false;\n@@ -2588,7 +2587,7 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n   VEC (data_reference_p, heap) *datarefs;\n   struct data_reference *dr;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_analyze_data_ref_accesses ===\");\n \n@@ -2601,7 +2600,7 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n     if (STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (DR_STMT (dr))) \n         && !vect_analyze_data_ref_access (dr))\n       {\n-\tif (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\tif (dump_enabled_p ())\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                            \"not vectorized: complicated access pattern.\");\n \n@@ -2631,7 +2630,7 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n     LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo);\n   unsigned i, j;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_prune_runtime_alias_test_list ===\");\n \n@@ -2649,7 +2648,7 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \n \t  if (vect_vfa_range_equal (ddr_i, ddr_j))\n \t    {\n-\t      if (dump_kind_p (MSG_NOTE))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_NOTE, vect_location,\n                                    \"found equal ranges \");\n@@ -2677,7 +2676,7 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n   if (VEC_length (ddr_p, ddrs) >\n        (unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION,  vect_location, \n                            \"disable versioning for alias - max number of \"\n@@ -2964,7 +2963,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n   tree scalar_type;\n   bool res, stop_bb_analysis = false;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_analyze_data_refs ===\\n\");\n \n@@ -2979,7 +2978,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n       if (!res)\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                              \"not vectorized: loop contains function calls\"\n                              \" or data references that cannot be analyzed\");\n@@ -3011,7 +3010,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n       if (!compute_all_dependences (BB_VINFO_DATAREFS (bb_vinfo),\n \t\t\t\t    &BB_VINFO_DDRS (bb_vinfo), NULL, true))\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                              \"not vectorized: basic block contains function\"\n                              \" calls or data references that cannot be\"\n@@ -3035,7 +3034,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n       if (!dr || !DR_REF (dr))\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"not vectorized: unhandled data-ref \");\n           return false;\n@@ -3081,7 +3080,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n \t  if (!gather)\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                                    \"not vectorized: data ref analysis \"\n@@ -3102,7 +3101,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n       if (TREE_CODE (DR_BASE_ADDRESS (dr)) == INTEGER_CST)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"not vectorized: base addr of dr is a \"\n                              \"constant\");\n@@ -3121,7 +3120,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n       if (TREE_THIS_VOLATILE (DR_REF (dr)))\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                \"not vectorized: volatile type \");\n@@ -3140,7 +3139,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n       if (stmt_can_throw_internal (stmt))\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                \"not vectorized: statement can throw an \"\n@@ -3163,7 +3162,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n       if (TREE_CODE (DR_REF (dr)) == COMPONENT_REF\n \t  && DECL_BIT_FIELD (TREE_OPERAND (DR_REF (dr), 1)))\n \t{\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                \"not vectorized: statement is bitfield \"\n@@ -3189,7 +3188,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n       if (is_gimple_call (stmt))\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_MISSED_OPTIMIZATION,  vect_location,\n                                \"not vectorized: dr in a call \");\n@@ -3232,7 +3231,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n           tree inner_base = build_fold_indirect_ref\n                                 (fold_build_pointer_plus (base, init));\n \n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n                                \"analyze in outer-loop: \");\n@@ -3245,7 +3244,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n \t  if (pbitpos % BITS_PER_UNIT != 0)\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                  \"failed: bit offset alignment.\\n\");\n \t      return false;\n@@ -3255,7 +3254,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t  if (!simple_iv (loop, loop_containing_stmt (stmt), outer_base,\n                           &base_iv, false))\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                                  \"failed: evolution of base is not affine.\\n\");\n \t      return false;\n@@ -3278,7 +3277,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t  else if (!simple_iv (loop, loop_containing_stmt (stmt), poffset,\n                                &offset_iv, false))\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                                  \"evolution of offset is not affine.\\n\");\n \t      return false;\n@@ -3303,7 +3302,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t  STMT_VINFO_DR_ALIGNED_TO (stmt_info) =\n \t\t\t\tsize_int (highest_pow2_factor (offset_iv.base));\n \n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n                                \"\\touter base_address: \");\n@@ -3327,7 +3326,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n       if (STMT_VINFO_DATA_REF (stmt_info))\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                \"not vectorized: more than one data ref \"\n@@ -3355,7 +3354,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n                 get_vectype_for_scalar_type (scalar_type);\n       if (!STMT_VINFO_VECTYPE (stmt_info))\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                                \"not vectorized: no vectype for stmt: \");\n@@ -3406,7 +3405,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t    {\n \t      STMT_VINFO_DATA_REF (stmt_info) = NULL;\n \t      free_data_ref (dr);\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                                    \"not vectorized: not suitable for gather \"\n@@ -3459,7 +3458,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \n \t  if (bad)\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                                    \"not vectorized: data dependence conflict\"\n@@ -3480,7 +3479,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t      = vect_check_strided_load (stmt, loop_vinfo, NULL, NULL);\n \t  if (!strided_load)\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n                                    \"not vectorized: not suitable for strided \"\n@@ -3668,7 +3667,7 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n \tmark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (vec_stmt));\n     }\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"created \");\n       dump_generic_expr (MSG_NOTE, TDF_SLIM, vec_stmt);\n@@ -3790,7 +3789,7 @@ vect_create_data_ref_ptr (gimple stmt, tree aggr_type, struct loop *at_loop,\n      in LOOP.  */\n   base_name = build_fold_indirect_ref (unshare_expr (DR_BASE_ADDRESS (dr)));\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       tree data_ref_base = base_name;\n       dump_printf_loc (MSG_NOTE, vect_location,\n@@ -4120,7 +4119,7 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n   /* vect_permute_store_chain requires the group size to be a power of two.  */\n   if (exact_log2 (count) == -1)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"the size of the group of accesses\"\n                          \" is not a power of 2\");\n@@ -4146,7 +4145,7 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t}\n     }\n \n-  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+  if (dump_enabled_p ())\n     dump_printf (MSG_MISSED_OPTIMIZATION,\n                  \"interleave op not supported by target.\");\n   return false;\n@@ -4564,7 +4563,7 @@ vect_grouped_load_supported (tree vectype, unsigned HOST_WIDE_INT count)\n   /* vect_permute_load_chain requires the group size to be a power of two.  */\n   if (exact_log2 (count) == -1)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"the size of the group of accesses\"\n                          \" is not a power of 2\");\n@@ -4588,7 +4587,7 @@ vect_grouped_load_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t}\n     }\n \n-  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                      \"extract even/odd not supported by target\");\n   return false;"}, {"sha": "3c356e35b6fd44206ac4647f6d152e87d881cd2c", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=73fbfcad22ae37dfd57a544aa0f5339b73bac439", "patch": "@@ -792,7 +792,7 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n   free_stmt_vec_info (orig_cond);\n \n   loop_loc = find_loop_location (loop);\n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       if (LOCATION_LOCUS (loop_loc) != UNKNOWN_LOC)\n \tdump_printf (MSG_NOTE, \"\\nloop at %s:%d: \", LOC_FILE (loop_loc),\n@@ -1683,15 +1683,15 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n   /* Analyze phi functions of the loop header.  */\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"vect_can_advance_ivs_p:\");\n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       tree access_fn = NULL;\n       tree evolution_part;\n \n       phi = gsi_stmt (gsi);\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \t{\n           dump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: \");\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n@@ -1702,7 +1702,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n       if (virtual_operand_p (PHI_RESULT (phi)))\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"virtual phi. skip.\");\n \t  continue;\n@@ -1712,7 +1712,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n       if (STMT_VINFO_DEF_TYPE (vinfo_for_stmt (phi)) == vect_reduction_def)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"reduc phi. skip.\");\n           continue;\n@@ -1725,13 +1725,13 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n       if (!access_fn)\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"No Access function.\");\n \t  return false;\n \t}\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         {\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n                            \"Access function of PHI: \");\n@@ -1742,7 +1742,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n       if (evolution_part == NULL_TREE)\n         {\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf (MSG_MISSED_OPTIMIZATION, \"No evolution.\");\n \t  return false;\n         }\n@@ -1827,7 +1827,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n \n       phi = gsi_stmt (gsi);\n       phi1 = gsi_stmt (gsi1);\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"vect_update_ivs_after_vectorizer: phi: \");\n@@ -1837,7 +1837,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n       /* Skip virtual phi's.  */\n       if (virtual_operand_p (PHI_RESULT (phi)))\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"virtual phi. skip.\");\n \t  continue;\n@@ -1847,7 +1847,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n       stmt_info = vinfo_for_stmt (phi);\n       if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def)\n         {\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"reduc phi. skip.\");\n           continue;\n@@ -1910,7 +1910,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n   tree cond_expr = NULL_TREE;\n   gimple_seq cond_expr_stmt_list = NULL;\n \n-  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n                      \"=== vect_do_peeling_for_loop_bound ===\");\n \n@@ -2022,7 +2022,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters, int\n     {\n       int npeel = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n \n-      if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n                          \"known peeling = %d.\", npeel);\n \n@@ -2076,7 +2076,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters, int\n   if (TREE_CODE (loop_niters) != INTEGER_CST)\n     iters = fold_build2 (MIN_EXPR, niters_type, iters, loop_niters);\n \n-  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n                        \"niters for prolog loop: \");\n@@ -2134,7 +2134,7 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n   VEC (data_reference_p, heap) *datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   struct data_reference *dr;\n  \n- if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+ if (dump_enabled_p ())\n     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n                      \"=== vect_update_inits_of_dr ===\");\n \n@@ -2163,7 +2163,7 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo,\n   int max_iter;\n   int bound = 0;\n \n-  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n                      \"=== vect_do_peeling_for_alignment ===\");\n \n@@ -2475,7 +2475,7 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n       segment_length_a = vect_vfa_segment_size (dr_a, length_factor);\n       segment_length_b = vect_vfa_segment_size (dr_b, length_factor);\n \n-      if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+      if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n                            \"create runtime check for data references \");\n@@ -2506,7 +2506,7 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,\n \t*cond_expr = part_cond_expr;\n     }\n \n-  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n \t\t     \"created %u versioning for alias checks.\\n\",\n \t\t     VEC_length (ddr_p, may_alias_ddrs));"}, {"sha": "908caed0b57137b36a12447401e73d92e1ee535b", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 158, "deletions": 159, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=73fbfcad22ae37dfd57a544aa0f5339b73bac439", "patch": "@@ -187,7 +187,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n   gimple_stmt_iterator pattern_def_si = gsi_none ();\n   bool analyze_pattern_stmt = false;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_determine_vectorization_factor ===\");\n \n@@ -199,7 +199,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t{\n \t  phi = gsi_stmt (si);\n \t  stmt_info = vinfo_for_stmt (phi);\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location, \"==> examining phi: \");\n \t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n@@ -212,7 +212,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      gcc_assert (!STMT_VINFO_VECTYPE (stmt_info));\n               scalar_type = TREE_TYPE (PHI_RESULT (phi));\n \n-\t      if (dump_kind_p (MSG_NOTE))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_NOTE, vect_location,\n                                    \"get vectype for scalar type:  \");\n@@ -222,7 +222,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      vectype = get_vectype_for_scalar_type (scalar_type);\n \t      if (!vectype)\n \t\t{\n-\t\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\t  if (dump_enabled_p ())\n \t\t    {\n \t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                        \"not vectorized: unsupported \"\n@@ -234,14 +234,14 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t\t}\n \t      STMT_VINFO_VECTYPE (stmt_info) = vectype;\n \n-\t      if (dump_kind_p (MSG_NOTE))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n \t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, vectype);\n \t\t}\n \n \t      nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-\t      if (dump_kind_p (MSG_NOTE))\n+\t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_NOTE, vect_location, \"nunits = %d\", nunits);\n \n \t      if (!vectorization_factor\n@@ -261,7 +261,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n           stmt_info = vinfo_for_stmt (stmt);\n \n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n                                \"==> examining statement: \");\n@@ -281,7 +281,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n                 {\n                   stmt = pattern_stmt;\n                   stmt_info = vinfo_for_stmt (pattern_stmt);\n-                  if (dump_kind_p (MSG_NOTE))\n+                  if (dump_enabled_p ())\n                     {\n                       dump_printf_loc (MSG_NOTE, vect_location,\n                                        \"==> examining pattern statement: \");\n@@ -290,7 +290,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n                 }\n               else\n \t        {\n-\t          if (dump_kind_p (MSG_NOTE))\n+\t          if (dump_enabled_p ())\n \t            dump_printf_loc (MSG_NOTE, vect_location, \"skip.\");\n                   gsi_next (&si);\n \t          continue;\n@@ -330,7 +330,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n \t\t  if (!gsi_end_p (pattern_def_si))\n \t\t    {\n-\t\t      if (dump_kind_p (MSG_NOTE))\n+\t\t      if (dump_enabled_p ())\n \t\t\t{\n \t\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n                                            \"==> examining pattern def stmt: \");\n@@ -353,7 +353,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n \t  if (gimple_get_lhs (stmt) == NULL_TREE)\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                    \"not vectorized: irregular stmt.\");\n@@ -365,7 +365,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n \t  if (VECTOR_MODE_P (TYPE_MODE (gimple_expr_type (stmt))))\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t        {\n \t          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                    \"not vectorized: vector stmt in loop:\");\n@@ -389,7 +389,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t    {\n \t      gcc_assert (!STMT_VINFO_DATA_REF (stmt_info));\n \t      scalar_type = TREE_TYPE (gimple_get_lhs (stmt));\n-\t      if (dump_kind_p (MSG_NOTE))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_NOTE, vect_location,\n                                    \"get vectype for scalar type:  \");\n@@ -398,7 +398,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      vectype = get_vectype_for_scalar_type (scalar_type);\n \t      if (!vectype)\n \t\t{\n-\t\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\t  if (dump_enabled_p ())\n \t\t    {\n \t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                        \"not vectorized: unsupported \"\n@@ -417,7 +417,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t     support one vector size per loop).  */\n \t  scalar_type = vect_get_smallest_scalar_type (stmt, &dummy,\n \t\t\t\t\t\t       &dummy);\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n                                \"get vectype for scalar type:  \");\n@@ -426,7 +426,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t  vf_vectype = get_vectype_for_scalar_type (scalar_type);\n \t  if (!vf_vectype)\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                    \"not vectorized: unsupported data-type \");\n@@ -439,7 +439,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t  if ((GET_MODE_SIZE (TYPE_MODE (vectype))\n \t       != GET_MODE_SIZE (TYPE_MODE (vf_vectype))))\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                    \"not vectorized: different sized vector \"\n@@ -453,14 +453,14 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      return false;\n \t    }\n \n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM, vf_vectype);\n \t    }\n \n \t  nunits = TYPE_VECTOR_SUBPARTS (vf_vectype);\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location, \"nunits = %d\", nunits);\n \t  if (!vectorization_factor\n \t      || (nunits > vectorization_factor))\n@@ -475,12 +475,12 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n     }\n \n   /* TODO: Analyze cost. Decide if worth while to vectorize.  */\n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"vectorization factor = %d\",\n                      vectorization_factor);\n   if (vectorization_factor <= 1)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"not vectorized: unsupported data-type\");\n       return false;\n@@ -517,7 +517,7 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n   step_expr = evolution_part;\n   init_expr = unshare_expr (initial_condition_in_loop_num (access_fn, loop_nb));\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"step: \");\n       dump_generic_expr (MSG_NOTE, TDF_SLIM, step_expr);\n@@ -530,7 +530,7 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n \n   if (TREE_CODE (step_expr) != INTEGER_CST)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"step unknown.\");\n       return false;\n@@ -555,7 +555,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n   gimple_stmt_iterator gsi;\n   bool double_reduc;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_analyze_scalar_cycles ===\");\n \n@@ -569,7 +569,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n       tree def = PHI_RESULT (phi);\n       stmt_vec_info stmt_vinfo = vinfo_for_stmt (phi);\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: \");\n \t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n@@ -587,7 +587,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n       if (access_fn)\n \t{\n \t  STRIP_NOPS (access_fn);\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n                                \"Access function of PHI: \");\n@@ -606,7 +606,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n \n       gcc_assert (STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_vinfo) != NULL_TREE);\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location, \"Detected induction.\");\n       STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_induction_def;\n     }\n@@ -621,7 +621,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n       gimple reduc_stmt;\n       bool nested_cycle;\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: \");\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n@@ -637,7 +637,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n         {\n           if (double_reduc)\n             {\n-              if (dump_kind_p (MSG_NOTE))\n+              if (dump_enabled_p ())\n                 dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t \"Detected double reduction.\");\n \n@@ -649,7 +649,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n             {\n               if (nested_cycle)\n                 {\n-                  if (dump_kind_p (MSG_NOTE))\n+                  if (dump_enabled_p ())\n                     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t     \"Detected vectorizable nested cycle.\");\n \n@@ -659,7 +659,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n                 }\n               else\n                 {\n-                  if (dump_kind_p (MSG_NOTE))\n+                  if (dump_enabled_p ())\n                     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t     \"Detected reduction.\");\n \n@@ -675,7 +675,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n             }\n         }\n       else\n-        if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        if (dump_enabled_p ())\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t   \"Unknown def-use cycle pattern.\");\n     }\n@@ -737,7 +737,7 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n {\n   tree niters;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"=== get_loop_niters ===\");\n   niters = number_of_exit_cond_executions (loop);\n@@ -747,7 +747,7 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n     {\n       *number_of_iterations = niters;\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_NOTE, vect_location, \"==> get_loop_niters:\");\n           dump_generic_expr (MSG_NOTE, TDF_SLIM, *number_of_iterations);\n@@ -995,7 +995,7 @@ vect_analyze_loop_1 (struct loop *loop)\n {\n   loop_vec_info loop_vinfo;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"===== analyze_loop_nest_1 =====\");\n \n@@ -1004,7 +1004,7 @@ vect_analyze_loop_1 (struct loop *loop)\n   loop_vinfo = vect_analyze_loop_form (loop);\n   if (!loop_vinfo)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"bad inner-loop form.\");\n       return NULL;\n@@ -1030,7 +1030,7 @@ vect_analyze_loop_form (struct loop *loop)\n   tree number_of_iterations = NULL;\n   loop_vec_info inner_loop_vinfo = NULL;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"=== vect_analyze_loop_form ===\");\n \n@@ -1054,15 +1054,15 @@ vect_analyze_loop_form (struct loop *loop)\n \n       if (loop->num_nodes != 2)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: control flow in loop.\");\n           return NULL;\n         }\n \n       if (empty_block_p (loop->header))\n     {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: empty loop.\");\n       return NULL;\n@@ -1092,7 +1092,7 @@ vect_analyze_loop_form (struct loop *loop)\n \n       if ((loop->inner)->inner || (loop->inner)->next)\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: multiple nested loops.\");\n \t  return NULL;\n@@ -1102,7 +1102,7 @@ vect_analyze_loop_form (struct loop *loop)\n       inner_loop_vinfo = vect_analyze_loop_1 (loop->inner);\n       if (!inner_loop_vinfo)\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: Bad inner loop.\");\n \t  return NULL;\n@@ -1111,7 +1111,7 @@ vect_analyze_loop_form (struct loop *loop)\n       if (!expr_invariant_in_loop_p (loop,\n \t\t\t\t\tLOOP_VINFO_NITERS (inner_loop_vinfo)))\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t     \"not vectorized: inner-loop count not invariant.\");\n \t  destroy_loop_vec_info (inner_loop_vinfo, true);\n@@ -1120,7 +1120,7 @@ vect_analyze_loop_form (struct loop *loop)\n \n       if (loop->num_nodes != 5)\n         {\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not vectorized: control flow in loop.\");\n \t  destroy_loop_vec_info (inner_loop_vinfo, true);\n@@ -1136,22 +1136,22 @@ vect_analyze_loop_form (struct loop *loop)\n \t  || !single_exit (innerloop)\n \t  || single_exit (innerloop)->dest !=  EDGE_PRED (loop->latch, 0)->src)\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t     \"not vectorized: unsupported outerloop form.\");\n \t  destroy_loop_vec_info (inner_loop_vinfo, true);\n \t  return NULL;\n \t}\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"Considering outer-loop vectorization.\");\n     }\n \n   if (!single_exit (loop)\n       || EDGE_COUNT (loop->header->preds) != 2)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         {\n           if (!single_exit (loop))\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1172,7 +1172,7 @@ vect_analyze_loop_form (struct loop *loop)\n   if (!empty_block_p (loop->latch)\n         || !gimple_seq_empty_p (phi_nodes (loop->latch)))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: unexpected loop form.\");\n       if (inner_loop_vinfo)\n@@ -1187,12 +1187,12 @@ vect_analyze_loop_form (struct loop *loop)\n       if (!(e->flags & EDGE_ABNORMAL))\n \t{\n \t  split_loop_exit_edge (e);\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    dump_printf (MSG_NOTE, \"split exit edge.\");\n \t}\n       else\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t     \"not vectorized: abnormal loop exit edge.\");\n \t  if (inner_loop_vinfo)\n@@ -1204,7 +1204,7 @@ vect_analyze_loop_form (struct loop *loop)\n   loop_cond = vect_get_loop_niters (loop, &number_of_iterations);\n   if (!loop_cond)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t \"not vectorized: complicated exit condition.\");\n       if (inner_loop_vinfo)\n@@ -1214,7 +1214,7 @@ vect_analyze_loop_form (struct loop *loop)\n \n   if (!number_of_iterations)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t \"not vectorized: number of iterations cannot be \"\n \t\t\t \"computed.\");\n@@ -1225,7 +1225,7 @@ vect_analyze_loop_form (struct loop *loop)\n \n   if (chrec_contains_undetermined (number_of_iterations))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"Infinite number of iterations.\");\n       if (inner_loop_vinfo)\n@@ -1235,7 +1235,7 @@ vect_analyze_loop_form (struct loop *loop)\n \n   if (!NITERS_KNOWN_P (number_of_iterations))\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"Symbolic number of iterations is \");\n@@ -1244,7 +1244,7 @@ vect_analyze_loop_form (struct loop *loop)\n     }\n   else if (TREE_INT_CST_LOW (number_of_iterations) == 0)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: number of iterations = 0.\");\n       if (inner_loop_vinfo)\n@@ -1292,7 +1292,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n   HOST_WIDE_INT estimated_niter;\n   int min_profitable_estimate;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"=== vect_analyze_loop_operations ===\");\n \n@@ -1328,7 +1328,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n \t\t\t\tLOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo));\n \n       LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"Updating vectorization factor to %d \",\n \t\t\t vectorization_factor);\n@@ -1344,7 +1344,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n           ok = true;\n \n           stmt_info = vinfo_for_stmt (phi);\n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_NOTE, vect_location, \"examining phi: \");\n               dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n@@ -1363,7 +1363,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n                   && STMT_VINFO_DEF_TYPE (stmt_info)\n                      != vect_double_reduction_def)\n                 {\n-                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t\t     \"Unsupported loop-closed phi in \"\n \t\t\t\t     \"outer-loop.\");\n@@ -1405,7 +1405,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n           if (STMT_VINFO_LIVE_P (stmt_info))\n             {\n               /* FORNOW: not yet supported.  */\n-              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+              if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t \"not vectorized: value used after loop.\");\n               return false;\n@@ -1415,7 +1415,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n               && STMT_VINFO_DEF_TYPE (stmt_info) != vect_induction_def)\n             {\n               /* A scalar-dependence cycle that we don't support.  */\n-              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+              if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t\t \"not vectorized: scalar dependence cycle.\");\n               return false;\n@@ -1430,7 +1430,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n \n           if (!ok)\n             {\n-              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+              if (dump_enabled_p ())\n                 {\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t\t   \"not vectorized: relevant phi not \"\n@@ -1456,18 +1456,17 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n      touching this loop.  */\n   if (!need_to_vectorize)\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"All the computation can be taken out of the loop.\");\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t \"not vectorized: redundant loop. no profit to \"\n \t\t\t \"vectorize.\");\n       return false;\n     }\n \n-  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && dump_kind_p (MSG_NOTE))\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) && dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"vectorization_factor = %d, niters = \"\n \t\t     HOST_WIDE_INT_PRINT_DEC, vectorization_factor,\n@@ -1478,10 +1477,10 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n       || ((max_niter = max_stmt_executions_int (loop)) != -1\n \t  && (unsigned HOST_WIDE_INT) max_niter < vectorization_factor))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: iteration count too small.\");\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: iteration count smaller than \"\n \t\t\t \"vectorization factor.\");\n@@ -1500,10 +1499,10 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n \n   if (min_profitable_iters < 0)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: vectorization not profitable.\");\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t \"not vectorized: vector version will never be \"\n \t\t\t \"profitable.\");\n@@ -1526,10 +1525,10 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       && LOOP_VINFO_INT_NITERS (loop_vinfo) <= th)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: vectorization not profitable.\");\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"not vectorized: iteration count smaller than user \"\n \t\t\t \"specified loop bound parameter or minimum profitable \"\n@@ -1541,11 +1540,11 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n       && ((unsigned HOST_WIDE_INT) estimated_niter\n           <= MAX (th, (unsigned)min_profitable_estimate)))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: estimated iteration count too \"\n                          \"small.\");\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"not vectorized: estimated iteration count smaller \"\n                          \"than specified loop bound parameter or minimum \"\n@@ -1558,18 +1557,18 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n       || LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0\n       || LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location, \"epilog loop required.\");\n       if (!vect_can_advance_ivs_p (loop_vinfo))\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t     \"not vectorized: can't create epilog loop 1.\");\n           return false;\n         }\n       if (!slpeel_can_duplicate_loop_p (loop, single_exit (loop)))\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t     \"not vectorized: can't create epilog loop 2.\");\n           return false;\n@@ -1602,7 +1601,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_analyze_data_refs (loop_vinfo, NULL, &min_vf);\n   if (!ok)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"bad data references.\");\n       return false;\n@@ -1620,7 +1619,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_mark_stmts_to_be_vectorized (loop_vinfo);\n   if (!ok)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"unexpected pattern.\");\n       return false;\n@@ -1635,7 +1634,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   if (!ok\n       || max_vf < min_vf)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"bad data dependence.\");\n       return false;\n@@ -1644,14 +1643,14 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_determine_vectorization_factor (loop_vinfo);\n   if (!ok)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"can't determine vectorization factor.\");\n       return false;\n     }\n   if (max_vf < LOOP_VINFO_VECT_FACTOR (loop_vinfo))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"bad data dependence.\");\n       return false;\n@@ -1663,7 +1662,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_analyze_data_refs_alignment (loop_vinfo, NULL);\n   if (!ok)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"bad data alignment.\");\n       return false;\n@@ -1675,7 +1674,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_analyze_data_ref_accesses (loop_vinfo, NULL);\n   if (!ok)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"bad data access.\");\n       return false;\n@@ -1687,7 +1686,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_prune_runtime_alias_test_list (loop_vinfo);\n   if (!ok)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"too long list of versioning for alias \"\n \t\t\t \"run-time tests.\");\n@@ -1700,7 +1699,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_enhance_data_refs_alignment (loop_vinfo);\n   if (!ok)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"bad data alignment.\");\n       return false;\n@@ -1725,7 +1724,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n   ok = vect_analyze_loop_operations (loop_vinfo, slp);\n   if (!ok)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"bad operation or unsupported loop bound.\");\n       return false;\n@@ -1749,15 +1748,15 @@ vect_analyze_loop (struct loop *loop)\n   current_vector_size = 0;\n   vector_sizes = targetm.vectorize.autovectorize_vector_sizes ();\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"===== analyze_loop_nest =====\");\n \n   if (loop_outer (loop)\n       && loop_vec_info_for_loop (loop_outer (loop))\n       && LOOP_VINFO_VECTORIZABLE_P (loop_vec_info_for_loop (loop_outer (loop))))\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"outer-loop already vectorized.\");\n       return NULL;\n@@ -1769,7 +1768,7 @@ vect_analyze_loop (struct loop *loop)\n       loop_vinfo = vect_analyze_loop_form (loop);\n       if (!loop_vinfo)\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"bad loop form.\");\n \t  return NULL;\n@@ -1791,7 +1790,7 @@ vect_analyze_loop (struct loop *loop)\n \n       /* Try the next biggest vector size.  */\n       current_vector_size = 1 << floor_log2 (vector_sizes);\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"***** Re-trying analysis with \"\n \t\t\t \"vector size %d\\n\", current_vector_size);\n@@ -2023,7 +2022,7 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple phi, gimple first_stmt)\n                                   == vect_internal_def\n                       && !is_loop_header_bb_p (gimple_bb (def_stmt)))))\n   \t    {\n-\t      if (dump_kind_p (MSG_NOTE))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_NOTE, vect_location, \"swapping oprnds: \");\n \t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, next_stmt, 0);\n@@ -2125,7 +2124,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n \n       if (!flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"intermediate value used outside loop.\");\n \n@@ -2137,7 +2136,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n         nloop_uses++;\n       if (nloop_uses > 1)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"reduction used in loop.\");\n           return NULL;\n@@ -2146,7 +2145,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n \n   if (TREE_CODE (loop_arg) != SSA_NAME)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t   \"reduction: not ssa_name: \");\n@@ -2158,15 +2157,15 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n   def_stmt = SSA_NAME_DEF_STMT (loop_arg);\n   if (!def_stmt)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"reduction: no def_stmt.\");\n       return NULL;\n     }\n \n   if (!is_gimple_assign (def_stmt) && gimple_code (def_stmt) != GIMPLE_PHI)\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_gimple_stmt (MSG_NOTE, TDF_SLIM, def_stmt, 0);\n       return NULL;\n     }\n@@ -2194,7 +2193,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n \tnloop_uses++;\n       if (nloop_uses > 1)\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"reduction used in loop.\");\n \t  return NULL;\n@@ -2210,7 +2209,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n       if (gimple_phi_num_args (def_stmt) != 1\n           || TREE_CODE (op1) != SSA_NAME)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"unsupported phi node definition.\");\n \n@@ -2223,7 +2222,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n           && flow_bb_inside_loop_p (loop->inner, gimple_bb (def1))\n           && is_gimple_assign (def1))\n         {\n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n             report_vect_op (MSG_NOTE, def_stmt,\n \t\t\t    \"detected double reduction: \");\n \n@@ -2250,7 +2249,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n   if (check_reduction\n       && (!commutative_tree_code (code) || !associative_tree_code (code)))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n \t\t\t\"reduction: not commutative/associative: \");\n       return NULL;\n@@ -2260,7 +2259,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n     {\n       if (code != COND_EXPR)\n         {\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n \t\t\t    \"reduction: not binary operation: \");\n \n@@ -2279,7 +2278,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n \n       if (TREE_CODE (op1) != SSA_NAME && TREE_CODE (op2) != SSA_NAME)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n \t\t\t    \"reduction: uses not ssa_names: \");\n \n@@ -2293,7 +2292,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n \n       if (TREE_CODE (op1) != SSA_NAME && TREE_CODE (op2) != SSA_NAME)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n \t    report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n \t\t\t    \"reduction: uses not ssa_names: \");\n \n@@ -2311,7 +2310,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n       || (op4 && TREE_CODE (op4) == SSA_NAME\n           && !types_compatible_p (type, TREE_TYPE (op4))))\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"reduction: multiple types: operation type: \");\n@@ -2353,7 +2352,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n       && check_reduction)\n     {\n       /* Changing the order of operations changes the semantics.  */\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n \t\t\t\"reduction: unsafe fp math optimization: \");\n       return NULL;\n@@ -2362,15 +2361,15 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n \t   && check_reduction)\n     {\n       /* Changing the order of operations changes the semantics.  */\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n \t\t\t\"reduction: unsafe int math optimization: \");\n       return NULL;\n     }\n   else if (SAT_FIXED_POINT_TYPE_P (type) && check_reduction)\n     {\n       /* Changing the order of operations changes the semantics.  */\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n \t\t\t\"reduction: unsafe fixed-point math optimization: \");\n       return NULL;\n@@ -2407,7 +2406,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n   if (code != COND_EXPR\n       && ((!def1 || gimple_nop_p (def1)) && (!def2 || gimple_nop_p (def2))))\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \treport_vect_op (MSG_NOTE, def_stmt, \"reduction: no defs for operands: \");\n       return NULL;\n     }\n@@ -2429,7 +2428,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n                           == vect_internal_def\n  \t              && !is_loop_header_bb_p (gimple_bb (def1)))))))\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \treport_vect_op (MSG_NOTE, def_stmt, \"detected reduction: \");\n       return def_stmt;\n     }\n@@ -2452,7 +2451,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n           /* Swap operands (just for simplicity - so that the rest of the code\n \t     can assume that the reduction variable is always the last (second)\n \t     argument).  */\n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n \t    report_vect_op (MSG_NOTE, def_stmt,\n \t  \t            \"detected reduction: need to swap operands: \");\n \n@@ -2464,7 +2463,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n         }\n       else\n         {\n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n             report_vect_op (MSG_NOTE, def_stmt, \"detected reduction: \");\n         }\n \n@@ -2474,14 +2473,14 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n   /* Try to find SLP reduction chain.  */\n   if (check_reduction && vect_is_slp_reduction (loop_info, phi, def_stmt))\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         report_vect_op (MSG_NOTE, def_stmt,\n \t\t\t\"reduction: detected reduction chain: \");\n \n       return def_stmt;\n     }\n \n-  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+  if (dump_enabled_p ())\n     report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n \t\t    \"reduction: unknown pattern: \");\n        \n@@ -2589,7 +2588,7 @@ vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     {\n       *peel_iters_epilogue = vf/2;\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"cost model: epilogue peel iters set to vf/2 \"\n \t\t\t \"because loop iterations are unknown .\");\n@@ -2882,7 +2881,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   /* vector version will never be profitable.  */\n   else\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"cost model: the vector iteration cost = %d \"\n \t\t\t \"divided by the scalar iteration cost = %d \"\n@@ -2893,7 +2892,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n       return;\n     }\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"Cost model analysis: \\n\");\n       dump_printf (MSG_NOTE, \"  Vector inside of loop cost: %d\\n\",\n@@ -2925,7 +2924,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n        then skip the vectorized loop.  */\n   min_profitable_iters--;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"  Runtime profitability threshold = %d\\n\", min_profitable_iters);\n \n@@ -2950,7 +2949,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n     }\n   min_profitable_estimate --;\n   min_profitable_estimate = MAX (min_profitable_estimate, min_profitable_iters);\n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"  Static estimate profitability threshold = %d\\n\",\n                       min_profitable_iters);\n@@ -3010,7 +3009,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n   vectype = get_vectype_for_scalar_type (TREE_TYPE (reduction_op));\n   if (!vectype)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         {\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t   \"unsupported data-type \");\n@@ -3081,7 +3080,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \t}\n     }\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf (MSG_NOTE, \n                  \"vect_model_reduction_cost: inside_cost = %d, \"\n                  \"prologue_cost = %d, epilogue_cost = %d .\", inside_cost,\n@@ -3110,7 +3109,7 @@ vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n   prologue_cost = add_stmt_cost (target_cost_data, 2, scalar_to_vec,\n \t\t\t\t stmt_info, 0, vect_prologue);\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_model_induction_cost: inside_cost = %d, \"\n                      \"prologue_cost = %d .\", inside_cost, prologue_cost);\n@@ -3239,7 +3238,7 @@ get_initial_def_for_induction (gimple iv_phi)\n \t  new_bb = gsi_insert_on_edge_immediate (pe, init_stmt);\n \t  gcc_assert (!new_bb);\n \n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t       \"created new init_stmt: \");\n@@ -3382,7 +3381,7 @@ get_initial_def_for_induction (gimple iv_phi)\n \t\t      && !STMT_VINFO_LIVE_P (stmt_vinfo));\n \n \t  STMT_VINFO_VEC_STMT (stmt_vinfo) = new_stmt;\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t       \"vector of inductions after inner-loop:\");\n@@ -3392,7 +3391,7 @@ get_initial_def_for_induction (gimple iv_phi)\n     }\n \n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location,\n \t\t       \"transform induction: created def-use cycle: \");\n@@ -3800,7 +3799,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n \n           add_phi_arg (phi, def, loop_latch_edge (loop), UNKNOWN_LOCATION);\n \n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t       \"transform reduction: created def-use cycle: \");\n@@ -4001,7 +4000,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n       /*** Case 1:  Create:\n            v_out2 = reduc_expr <v_out1>  */\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"Reduce using direct vector reduction.\");\n \n@@ -4052,7 +4051,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n                   Create:  va = vop <va, va'>\n                 }  */\n \n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"Reduce using vector shifts\");\n \n@@ -4093,7 +4092,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n                  Create:  s = op <s, s'>  // For non SLP cases\n                }  */\n \n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"Reduce using scalar code. \");\n \n@@ -4184,7 +4183,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n     {\n       tree rhs;\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"extract scalar result\");\n \n@@ -4423,7 +4422,7 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n                                UNKNOWN_LOCATION);\n                   add_phi_arg (vect_phi, PHI_RESULT (inner_phi),\n                                loop_latch_edge (outer_loop), UNKNOWN_LOCATION);\n-                  if (dump_kind_p (MSG_NOTE))\n+                  if (dump_enabled_p ())\n                     {\n                       dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t       \"created double reduction phi node: \");\n@@ -4773,7 +4772,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (!vectorizable_condition (stmt, gsi, NULL, ops[reduc_index], 0, NULL))\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"unsupported condition in reduction\");\n \n@@ -4788,7 +4787,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       optab = optab_for_tree_code (code, vectype_in, optab_default);\n       if (!optab)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"no optab.\");\n \n@@ -4797,15 +4796,15 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \n       if (optab_handler (optab, vec_mode) == CODE_FOR_nothing)\n         {\n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n             dump_printf (MSG_NOTE, \"op not supported by target.\");\n \n           if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n               || LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n \t          < vect_min_worthwhile_factor (code))\n             return false;\n \n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n   \t    dump_printf (MSG_NOTE, \"proceeding using word mode.\");\n         }\n \n@@ -4814,7 +4813,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n           && LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n    \t     < vect_min_worthwhile_factor (code))\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"not worthwhile without SIMD support.\");\n \n@@ -4895,7 +4894,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n                                          optab_default);\n       if (!reduc_optab)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"no optab for reduction.\");\n \n@@ -4905,7 +4904,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       if (reduc_optab\n           && optab_handler (reduc_optab, vec_mode) == CODE_FOR_nothing)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"reduc op not supported by target.\");\n \n@@ -4916,7 +4915,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (!nested_cycle || double_reduc)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"no reduc code for scalar code.\");\n \n@@ -4926,7 +4925,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \n   if (double_reduc && ncopies > 1)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"multiple types in double reduction\");\n \n@@ -4945,7 +4944,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n         ops[1] = fold_convert (TREE_TYPE (ops[0]), ops[1]);\n       else\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"invalid types in dot-prod\");\n \n@@ -4963,7 +4962,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \n   /** Transform.  **/\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"transform reduction.\");\n \n   /* FORNOW: Multiple types are not supported for condition.  */\n@@ -5249,7 +5248,7 @@ vectorizable_induction (gimple phi, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n \n       if (ncopies > 1)\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"multiple types in nested loop.\");\n \t  return false;\n@@ -5273,7 +5272,7 @@ vectorizable_induction (gimple phi, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n \t  if (!(STMT_VINFO_RELEVANT_P (exit_phi_vinfo)\n \t\t&& !STMT_VINFO_LIVE_P (exit_phi_vinfo)))\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t\t \"inner-loop induction only used outside \"\n \t\t\t\t \"of the outer vectorized loop.\");\n@@ -5297,7 +5296,7 @@ vectorizable_induction (gimple phi, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = induc_vec_info_type;\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"=== vectorizable_induction ===\");\n       vect_model_induction_cost (stmt_info, ncopies);\n@@ -5306,7 +5305,7 @@ vectorizable_induction (gimple phi, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n \n   /** Transform.  **/\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"transform induction phi.\");\n \n   vec_def = get_initial_def_for_induction (phi);\n@@ -5371,7 +5370,7 @@ vectorizable_live_operation (gimple stmt,\n           && !vect_is_simple_use (op, stmt, loop_vinfo, NULL, &def_stmt, &def,\n \t\t\t\t  &dt))\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"use not simple.\");\n           return false;\n@@ -5410,7 +5409,7 @@ vect_loop_kill_debug_uses (struct loop *loop, gimple stmt)\n \t    {\n \t      if (gimple_debug_bind_p (ustmt))\n \t\t{\n-\t\t  if (dump_kind_p (MSG_NOTE))\n+\t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_NOTE, vect_location,\n                                      \"killing debug use\");\n \n@@ -5450,7 +5449,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   bool check_profitability = false;\n   int th;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"=== vec_transform_loop ===\");\n \n   /* Use the more conservative vectorization threshold.  If the number\n@@ -5464,7 +5463,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   if (th >= LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 1\n       && !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"Profitability threshold is %d loop iterations.\", th);\n       check_profitability = true;\n@@ -5525,7 +5524,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n       for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n         {\n \t  phi = gsi_stmt (si);\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n                                \"------>vectorizing phi: \");\n@@ -5544,12 +5543,12 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n \t  if ((TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info))\n \t        != (unsigned HOST_WIDE_INT) vectorization_factor)\n-\t      && dump_kind_p (MSG_NOTE))\n+\t      && dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location, \"multiple-types.\");\n \n \t  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def)\n \t    {\n-\t      if (dump_kind_p (MSG_NOTE))\n+\t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_NOTE, vect_location, \"transform phi.\");\n \t      vect_transform_stmt (phi, NULL, NULL, NULL, NULL);\n \t    }\n@@ -5565,7 +5564,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n           else\n             stmt = gsi_stmt (si);\n \n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t       \"------>vectorizing statement: \");\n@@ -5637,7 +5636,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n \t\t  if (!gsi_end_p (pattern_def_si))\n \t\t    {\n-\t\t      if (dump_kind_p (MSG_NOTE))\n+\t\t      if (dump_enabled_p ())\n \t\t\t{\n \t\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t\t   \"==> vectorizing pattern def \"\n@@ -5664,7 +5663,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n                                                STMT_VINFO_VECTYPE (stmt_info));\n \t  if (!STMT_SLP_TYPE (stmt_info)\n \t      && nunits != (unsigned int) vectorization_factor\n-              && dump_kind_p (MSG_NOTE))\n+              && dump_enabled_p ())\n \t    /* For SLP VF is set according to unrolling factor, and not to\n \t       vector size, hence for SLP this print is not valid.  */\n             dump_printf_loc (MSG_NOTE, vect_location,\n@@ -5678,7 +5677,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t{\n \t\t  slp_scheduled = true;\n \n-\t\t  if (dump_kind_p (MSG_NOTE))\n+\t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t     \"=== scheduling SLP instances ===\");\n \n@@ -5698,7 +5697,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t    }\n \n \t  /* -------- vectorize statement ------------ */\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location, \"transform statement.\");\n \n \t  grouped_store = false;\n@@ -5741,9 +5740,9 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n      until all the loops have been transformed?  */\n   update_ssa (TODO_update_ssa);\n \n-  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \"LOOP VECTORIZED.\");\n-  if (loop->inner && dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (loop->inner && dump_enabled_p ())\n     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n \t\t     \"OUTER LOOP VECTORIZED.\");\n }"}, {"sha": "dea3595eb342f23d274fb6ecc0a117112f7b8c77", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=73fbfcad22ae37dfd57a544aa0f5339b73bac439", "patch": "@@ -416,7 +416,7 @@ vect_recog_dot_prod_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n   pattern_stmt = gimple_build_assign_with_ops (DOT_PROD_EXPR, var,\n \t\t\t\t\t       oprnd00, oprnd01, oprnd1);\n \n-  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n                        \"vect_recog_dot_prod_pattern: detected: \");\n@@ -676,7 +676,7 @@ vect_recog_widen_mult_pattern (VEC (gimple, heap) **stmts,\n     return NULL;\n \n   /* Pattern detected.  */\n-  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n                      \"vect_recog_widen_mult_pattern: detected: \");\n \n@@ -699,7 +699,7 @@ vect_recog_widen_mult_pattern (VEC (gimple, heap) **stmts,\n   pattern_stmt = gimple_build_assign_with_ops (WIDEN_MULT_EXPR, var, oprnd0,\n \t\t\t\t\t       oprnd1);\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_gimple_stmt_loc (MSG_NOTE, vect_location, TDF_SLIM, pattern_stmt, 0);\n \n   VEC_safe_push (gimple, heap, *stmts, last_stmt);\n@@ -912,7 +912,7 @@ vect_recog_widen_sum_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n   pattern_stmt = gimple_build_assign_with_ops (WIDEN_SUM_EXPR, var,\n \t\t\t\t\t       oprnd0, oprnd1);\n \n-  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n                        \"vect_recog_widen_sum_pattern: detected: \");\n@@ -1217,7 +1217,7 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n       STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt)) = pattern_stmt;\n       new_pattern_def_seq (vinfo_for_stmt (stmt), new_def_stmt);\n \n-      if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n                            \"created pattern stmt: \");\n@@ -1285,7 +1285,7 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n     return NULL;\n \n   /* Pattern detected.  */\n-  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n                        \"vect_recog_over_widening_pattern: detected: \");\n@@ -1421,7 +1421,7 @@ vect_recog_widen_shift_pattern (VEC (gimple, heap) **stmts,\n     return NULL;\n \n   /* Pattern detected.  */\n-  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n                      \"vect_recog_widen_shift_pattern: detected: \");\n \n@@ -1445,7 +1445,7 @@ vect_recog_widen_shift_pattern (VEC (gimple, heap) **stmts,\n   pattern_stmt =\n     gimple_build_assign_with_ops (WIDEN_LSHIFT_EXPR, var, oprnd0, oprnd1);\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_gimple_stmt_loc (MSG_NOTE, vect_location, TDF_SLIM, pattern_stmt, 0);\n \n   VEC_safe_push (gimple, heap, *stmts, last_stmt);\n@@ -1567,15 +1567,15 @@ vect_recog_vector_vector_shift_pattern (VEC (gimple, heap) **stmts,\n     }\n \n   /* Pattern detected.  */\n-  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n                      \"vect_recog_vector_vector_shift_pattern: detected: \");\n \n   /* Pattern supported.  Create a stmt to be used to replace the pattern.  */\n   var = vect_recog_temp_ssa_var (TREE_TYPE (oprnd0), NULL);\n   pattern_stmt = gimple_build_assign_with_ops (rhs_code, var, oprnd0, def);\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_gimple_stmt_loc (MSG_NOTE, vect_location, TDF_SLIM, pattern_stmt, 0);\n \n   VEC_safe_push (gimple, heap, *stmts, last_stmt);\n@@ -1685,7 +1685,7 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n \treturn NULL;\n \n       /* Pattern detected.  */\n-      if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n                          \"vect_recog_divmod_pattern: detected: \");\n \n@@ -1789,7 +1789,7 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n \t\t\t\t\t    signmask);\n \t}\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_gimple_stmt_loc (MSG_NOTE, vect_location, TDF_SLIM, pattern_stmt,\n                               0);\n \n@@ -2031,7 +2031,7 @@ vect_recog_divmod_pattern (VEC (gimple, heap) **stmts,\n     }\n \n   /* Pattern detected.  */\n-  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n                        \"vect_recog_divmod_pattern: detected: \");\n@@ -2199,7 +2199,7 @@ vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n   *type_in = vecitype;\n   *type_out = vectype;\n \n-  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n                      \"vect_recog_mixed_size_cond_pattern: detected: \");\n \n@@ -2592,7 +2592,7 @@ vect_recog_bool_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n       *type_out = vectype;\n       *type_in = vectype;\n       VEC_safe_push (gimple, heap, *stmts, last_stmt);\n-      if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, \n                          \"vect_recog_bool_pattern: detected: \");\n \n@@ -2638,7 +2638,7 @@ vect_recog_bool_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n       *type_out = vectype;\n       *type_in = vectype;\n       VEC_safe_push (gimple, heap, *stmts, last_stmt);\n-      if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n                          \"vect_recog_bool_pattern: detected: \");\n       return pattern_stmt;\n@@ -2788,7 +2788,7 @@ vect_pattern_recog_1 (vect_recog_func_ptr vect_recog_func,\n     }\n \n   /* Found a vectorizable pattern.  */\n-  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n                        \"pattern recognized: \");\n@@ -2814,7 +2814,7 @@ vect_pattern_recog_1 (vect_recog_func_ptr vect_recog_func,\n     {\n       stmt_info = vinfo_for_stmt (stmt);\n       pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n-      if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n                            \"additional pattern stmt: \");\n@@ -2915,7 +2915,7 @@ vect_pattern_recog (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n   VEC (gimple, heap) *stmts_to_replace = VEC_alloc (gimple, heap, 1);\n   gimple stmt;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_pattern_recog ===\");\n "}, {"sha": "58603188747d44f11191b8ab75417a097f987906", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=73fbfcad22ae37dfd57a544aa0f5339b73bac439", "patch": "@@ -238,7 +238,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t       &def, &dt)\n \t  || (!def_stmt && dt != vect_constant_def))\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t       \"Build SLP failed: can't find def for \");\n@@ -263,7 +263,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n           pattern = true;\n           if (!first && !oprnd_info->first_pattern)\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t   \"Build SLP failed: some of the stmts\"\n@@ -279,7 +279,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n           if (dt == vect_unknown_def_type)\n             {\n-              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+              if (dump_enabled_p ())\n                 dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t \"Unsupported pattern.\");\n               return false;\n@@ -296,7 +296,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                 break;\n \n               default:\n-                if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                if (dump_enabled_p ())\n                   dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t   \"unsupported defining stmt: \");\n                 return false;\n@@ -361,7 +361,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t    {\n \t      if (number_of_oprnds != 2)\n \t\t{\n-\t\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t     \"Build SLP failed: different types \");\n \n@@ -388,7 +388,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                            && !types_compatible_p (oprnd_info->first_def_type,\n                                                    TREE_TYPE (def_op0))))\n                     {\n-                      if (dump_kind_p (MSG_NOTE))\n+                      if (dump_enabled_p ())\n \t                {\n \t\t\t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t\t   \"Swapping operands of \");\n@@ -400,7 +400,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t    }\n                   else\n                     {\n-         \t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+         \t      if (dump_enabled_p ())\n \t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t\t \"Build SLP failed: different types \");\n \n@@ -435,7 +435,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n \tdefault:\n \t  /* FORNOW: Not supported.  */\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t       \"Build SLP failed: illegal type of def \");\n@@ -504,7 +504,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   /* For every stmt in NODE find its def stmt/s.  */\n   FOR_EACH_VEC_ELT (gimple, stmts, i, stmt)\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location, \"Build SLP for \");\n \t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n@@ -513,7 +513,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       /* Fail to vectorize statements marked as unvectorizable.  */\n       if (!STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (stmt)))\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t       \"Build SLP failed: unvectorizable statement \");\n@@ -527,7 +527,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       lhs = gimple_get_lhs (stmt);\n       if (lhs == NULL_TREE)\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t       \"Build SLP failed: not GIMPLE_ASSIGN nor \"\n@@ -544,7 +544,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n            && (cond = gimple_assign_rhs1 (stmt))\n            && !COMPARISON_CLASS_P (cond))\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t       \"Build SLP failed: condition is not \"\n@@ -560,7 +560,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       vectype = get_vectype_for_scalar_type (scalar_type);\n       if (!vectype)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t       \"Build SLP failed: unsupported data-type \");\n@@ -591,7 +591,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t      || !gimple_call_nothrow_p (stmt)\n \t      || gimple_call_chain (stmt))\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t\t   \"Build SLP failed: unsupported call type \");\n@@ -631,7 +631,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n \t\t  if (!optab)\n \t\t    {\n-\t\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\t      if (dump_enabled_p ())\n \t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t\t \"Build SLP failed: no optab.\");\n \t  \t      vect_free_oprnd_info (&oprnds_info);\n@@ -640,7 +640,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t  icode = (int) optab_handler (optab, vec_mode);\n \t\t  if (icode == CODE_FOR_nothing)\n \t\t    {\n-\t\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\t      if (dump_enabled_p ())\n \t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t\t \"Build SLP failed: \"\n \t\t\t\t\t \"op not supported by target.\");\n@@ -674,7 +674,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                        || first_stmt_code == COMPONENT_REF\n                        || first_stmt_code == MEM_REF)))\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t\t   \"Build SLP failed: different operation \"\n@@ -689,7 +689,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  if (need_same_oprnds\n \t      && !operand_equal_p (first_op1, gimple_assign_rhs2 (stmt), 0))\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t\t   \"Build SLP failed: different shift \"\n@@ -710,7 +710,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t  || gimple_call_fntype (first_stmt)\n \t\t     != gimple_call_fntype (stmt))\n \t\t{\n-\t\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\t  if (dump_enabled_p ())\n \t\t    {\n \t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t\t       \"Build SLP failed: different calls in \");\n@@ -749,7 +749,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                   || (GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) != stmt\n                       && GROUP_GAP (vinfo_for_stmt (stmt)) != 1))\n                 {\n-                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                  if (dump_enabled_p ())\n                     {\n                       dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t       \"Build SLP failed: grouped \"\n@@ -767,7 +767,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               if (loop_vinfo\n                   && GROUP_SIZE (vinfo_for_stmt (stmt)) > ncopies * group_size)\n                 {\n-                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                  if (dump_enabled_p ())\n                     {\n                       dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t       \"Build SLP failed: the number \"\n@@ -792,7 +792,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                       && rhs_code != REALPART_EXPR\n                       && rhs_code != IMAGPART_EXPR)\n                     {\n-                      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                      if (dump_enabled_p ())\n                         {\n                           dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n \t\t\t\t\t   vect_location, \n@@ -817,7 +817,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n                   if (vect_supportable_dr_alignment (first_dr, false)\n                       == dr_unaligned_unsupported)\n                     {\n-                      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                      if (dump_enabled_p ())\n                         {\n                           dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n \t\t\t\t\t   vect_location, \n@@ -857,7 +857,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  if (TREE_CODE_CLASS (rhs_code) == tcc_reference)\n \t    {\n \t      /* Not grouped load.  */\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t\t   \"Build SLP failed: not grouped load \");\n@@ -875,7 +875,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t      && rhs_code != COND_EXPR\n \t      && rhs_code != CALL_EXPR)\n \t    {\n-\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t   \"Build SLP failed: operation\");\n@@ -895,7 +895,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\tfirst_cond_code = TREE_CODE (cond_expr);\n               else if (first_cond_code != TREE_CODE (cond_expr))\n                 {\n-                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                  if (dump_enabled_p ())\n                     {\n                       dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t       \"Build SLP failed: different\"\n@@ -1080,7 +1080,7 @@ vect_supported_slp_permutation_p (slp_instance instance)\n       /* Check that the loads are all in the same interleaving chain.  */\n       if (GROUP_FIRST_ELEMENT (vinfo_for_stmt (scalar_stmt)) != first_load)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t       \"Build SLP failed: unsupported data \"\n@@ -1169,7 +1169,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n   if (!slp_instn)\n     return false;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"Load permutation \");\n       FOR_EACH_VEC_ELT (int, load_permutation, i, next)\n@@ -1376,7 +1376,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n                   if (vect_supportable_dr_alignment (dr, false)\n  \t               == dr_unaligned_unsupported)\n                     {\n-   \t\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+   \t\t      if (dump_enabled_p ())\n \t\t        {\n   \t                  dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n \t\t\t\t\t   vect_location, \n@@ -1536,7 +1536,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n   if (!vectype)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t   \"Build SLP failed: unsupported data-type \");\n@@ -1556,7 +1556,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   unrolling_factor = least_common_multiple (nunits, group_size) / group_size;\n   if (unrolling_factor != 1 && !loop_vinfo)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t \"Build SLP failed: unrolling required in basic\"\n \t\t\t \" block SLP\");\n@@ -1618,7 +1618,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n       if (unrolling_factor != 1 && !loop_vinfo)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t     \"Build SLP failed: unrolling required in basic\"\n \t\t\t     \" block SLP\");\n@@ -1645,7 +1645,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n           if (!vect_supported_load_permutation_p (new_instance, group_size,\n                                                   load_permutation))\n             {\n-              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+              if (dump_enabled_p ())\n                 {\n                   dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t\t   \"Build SLP failed: unsupported load \"\n@@ -1685,7 +1685,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n         VEC_safe_push (slp_instance, heap, BB_VINFO_SLP_INSTANCES (bb_vinfo),\n                        new_instance);\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tvect_print_slp_tree (MSG_NOTE, node);\n \n       return true;\n@@ -1717,7 +1717,7 @@ vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n   gimple first_element;\n   bool ok = false;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_analyze_slp ===\");\n \n   if (loop_vinfo)\n@@ -1736,7 +1736,7 @@ vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n \n   if (bb_vinfo && !ok)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"Failed to SLP the basic block.\");\n \n@@ -1780,7 +1780,7 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n   slp_instance instance;\n   int decided_to_slp = 0;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_make_slp_decision ===\");\n \n   FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n@@ -1798,7 +1798,7 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n \n   LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo) = unrolling_factor;\n \n-  if (decided_to_slp && dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (decided_to_slp && dump_enabled_p ())\n     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n \t\t     \"Decided to SLP %d instances. Unrolling factor %d\",\n \t\t     decided_to_slp, unrolling_factor);\n@@ -1863,7 +1863,7 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n   VEC (slp_instance, heap) *slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n   slp_instance instance;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_detect_hybrid_slp ===\");\n \n   FOR_EACH_VEC_ELT (slp_instance, slp_instances, i, instance)\n@@ -2060,7 +2060,7 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n \n   vec_outside_cost = vec_prologue_cost + vec_epilogue_cost;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"Cost model analysis: \\n\");\n       dump_printf (MSG_NOTE, \"  Vector inside of basic block cost: %d\\n\",\n@@ -2097,7 +2097,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n \n   if (!vect_analyze_data_refs (NULL, bb_vinfo, &min_vf))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: unhandled data-ref in basic \"\n \t\t\t \"block.\\n\");\n@@ -2109,7 +2109,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n   ddrs = BB_VINFO_DDRS (bb_vinfo);\n   if (!VEC_length (ddr_p, ddrs))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: not enough data-refs in \"\n \t\t\t \"basic block.\\n\");\n@@ -2123,7 +2123,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n   if (!vect_analyze_data_ref_dependences (NULL, bb_vinfo, &max_vf)\n        || min_vf > max_vf)\n      {\n-       if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+       if (dump_enabled_p ())\n \t dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t  \"not vectorized: unhandled data dependence \"\n \t\t\t  \"in basic block.\\n\");\n@@ -2134,7 +2134,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n \n   if (!vect_analyze_data_refs_alignment (NULL, bb_vinfo))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: bad data alignment in basic \"\n \t\t\t \"block.\\n\");\n@@ -2145,7 +2145,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n \n   if (!vect_analyze_data_ref_accesses (NULL, bb_vinfo))\n     {\n-     if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+     if (dump_enabled_p ())\n        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\"not vectorized: unhandled data access in \"\n \t\t\t\"basic block.\\n\");\n@@ -2158,7 +2158,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n      trees.  */\n   if (!vect_analyze_slp (NULL, bb_vinfo))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t \"not vectorized: failed to find SLP opportunities \"\n \t\t\t \"in basic block.\\n\");\n@@ -2179,7 +2179,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n \n   if (!vect_verify_datarefs_alignment (NULL, bb_vinfo))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"not vectorized: unsupported alignment in basic \"\n                          \"block.\\n\");\n@@ -2189,7 +2189,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n \n   if (!vect_slp_analyze_operations (bb_vinfo))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t \"not vectorized: bad operation in basic block.\\n\");\n \n@@ -2201,7 +2201,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n   if (flag_vect_cost_model\n       && !vect_bb_vectorization_profitable_p (bb_vinfo))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: vectorization is not \"\n \t\t\t \"profitable.\\n\");\n@@ -2210,7 +2210,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n       return NULL;\n     }\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"Basic block will be vectorized using SLP\\n\");\n \n@@ -2226,7 +2226,7 @@ vect_slp_analyze_bb (basic_block bb)\n   gimple_stmt_iterator gsi;\n   unsigned int vector_sizes;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"===vect_slp_analyze_bb===\\n\");\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n@@ -2240,7 +2240,7 @@ vect_slp_analyze_bb (basic_block bb)\n \n   if (insns > PARAM_VALUE (PARAM_SLP_MAX_INSNS_IN_BB))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: too many instructions in \"\n \t\t\t \"basic block.\\n\");\n@@ -2267,7 +2267,7 @@ vect_slp_analyze_bb (basic_block bb)\n \n       /* Try the next biggest vector size.  */\n       current_vector_size = 1 << floor_log2 (vector_sizes);\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"***** Re-trying analysis with \"\n \t\t\t \"vector size %d\\n\", current_vector_size);\n@@ -2292,7 +2292,7 @@ vect_update_slp_costs_according_to_vf (loop_vec_info loop_vinfo)\n   stmt_info_for_cost *si;\n   void *data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"=== vect_update_slp_costs_according_to_vf ===\");\n \n@@ -2800,7 +2800,7 @@ vect_get_mask_element (gimple stmt, int first_mask_element, int m,\n      the next vector as well.  */\n   if (only_one_vec && *current_mask_element >= mask_nunits)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t   \"permutation requires at least two vectors \");\n@@ -2818,7 +2818,7 @@ vect_get_mask_element (gimple stmt, int first_mask_element, int m,\n           /* We either need the first vector too or have already moved to the\n              next vector. In both cases, this permutation needs three\n              vectors.  */\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t       \"permutation requires at \"\n@@ -2884,7 +2884,7 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n \n   if (!can_vec_perm_p (mode, false, NULL))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t   \"no vect permute for \");\n@@ -2964,7 +2964,7 @@ vect_transform_slp_perm_load (gimple stmt, VEC (tree, heap) *dr_chain,\n \n \t\t  if (!can_vec_perm_p (mode, false, mask))\n \t\t    {\n-\t\t      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t\t      if (dump_enabled_p ())\n \t\t\t{\n \t\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n \t\t\t\t\t   vect_location, \n@@ -3068,7 +3068,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n       SLP_TREE_NUMBER_OF_VEC_STMTS (node) = vec_stmts_size;\n     }\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE,vect_location,\n \t\t       \"------>vectorizing SLP node starting from: \");\n@@ -3177,7 +3177,7 @@ vect_schedule_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n       /* Schedule the tree of INSTANCE.  */\n       is_store = vect_schedule_slp_instance (SLP_INSTANCE_TREE (instance),\n                                              instance, vf);\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n                          \"vectorizing stmts using SLP.\");\n     }\n@@ -3222,15 +3222,15 @@ vect_slp_transform_bb (basic_block bb)\n \n   gcc_assert (bb_vinfo);\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"SLPing BB\\n\");\n \n   for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n     {\n       gimple stmt = gsi_stmt (si);\n       stmt_vec_info stmt_info;\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"------>SLPing statement: \");\n@@ -3248,7 +3248,7 @@ vect_slp_transform_bb (basic_block bb)\n         }\n     }\n \n-  if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+  if (dump_enabled_p ())\n     dump_printf (MSG_OPTIMIZED_LOCATIONS, \"BASIC BLOCK VECTORIZED\\n\");\n \n   destroy_bb_vec_info (bb_vinfo);"}, {"sha": "2731084624c990f599d790d510734a6308e5eccf", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 122, "deletions": 122, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=73fbfcad22ae37dfd57a544aa0f5339b73bac439", "patch": "@@ -190,7 +190,7 @@ vect_mark_relevant (VEC(gimple,heap) **worklist, gimple stmt,\n   bool save_live_p = STMT_VINFO_LIVE_P (stmt_info);\n   gimple pattern_stmt;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"mark relevant %d, live %d.\", relevant, live_p);\n \n@@ -246,7 +246,7 @@ vect_mark_relevant (VEC(gimple,heap) **worklist, gimple stmt,\n \n           pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n \n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location,\n                              \"last stmt in pattern. don't mark\"\n                              \" relevant/live.\");\n@@ -265,7 +265,7 @@ vect_mark_relevant (VEC(gimple,heap) **worklist, gimple stmt,\n   if (STMT_VINFO_RELEVANT (stmt_info) == save_relevant\n       && STMT_VINFO_LIVE_P (stmt_info) == save_live_p)\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"already marked relevant/live.\");\n       return;\n@@ -310,7 +310,7 @@ vect_stmt_relevant_p (gimple stmt, loop_vec_info loop_vinfo,\n   if (gimple_code (stmt) != GIMPLE_PHI)\n     if (gimple_vdef (stmt))\n       {\n-\tif (dump_kind_p (MSG_NOTE))\n+\tif (dump_enabled_p ())\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n                            \"vec_stmt_relevant_p: stmt has vdefs.\");\n \t*relevant = vect_used_in_scope;\n@@ -324,7 +324,7 @@ vect_stmt_relevant_p (gimple stmt, loop_vec_info loop_vinfo,\n \t  basic_block bb = gimple_bb (USE_STMT (use_p));\n \t  if (!flow_bb_inside_loop_p (loop, bb))\n \t    {\n-\t      if (dump_kind_p (MSG_NOTE))\n+\t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_NOTE, vect_location,\n                                  \"vec_stmt_relevant_p: used out of loop.\");\n \n@@ -437,7 +437,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n \n   if (!vect_is_simple_use (use, stmt, loop_vinfo, NULL, &def_stmt, &def, &dt))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"not vectorized: unsupported use in stmt.\");\n       return false;\n@@ -449,7 +449,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n   def_bb = gimple_bb (def_stmt);\n   if (!flow_bb_inside_loop_p (loop, def_bb))\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location, \"def_stmt is out of loop.\");\n       return true;\n     }\n@@ -467,7 +467,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n       && STMT_VINFO_DEF_TYPE (dstmt_vinfo) == vect_reduction_def\n       && bb->loop_father == def_bb->loop_father)\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n                          \"reduc-stmt defining reduc-phi in the same nest.\");\n       if (STMT_VINFO_IN_PATTERN_P (dstmt_vinfo))\n@@ -487,7 +487,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n \t\t...\t\t  */\n   if (flow_loop_nested_p (def_bb->loop_father, bb->loop_father))\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n                          \"outer-loop def-stmt defining inner-loop stmt.\");\n \n@@ -525,7 +525,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n \t\tstmt # use (d)\t\t*/\n   else if (flow_loop_nested_p (bb->loop_father, def_bb->loop_father))\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n                          \"inner-loop def-stmt defining outer-loop stmt.\");\n \n@@ -589,7 +589,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   enum vect_relevant relevant, tmp_relevant;\n   enum vect_def_type def_type;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"=== vect_mark_stmts_to_be_vectorized ===\");\n \n@@ -602,7 +602,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n       for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n \t{\n \t  phi = gsi_stmt (si);\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location, \"init: phi relevant? \");\n \t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n@@ -614,7 +614,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n \t{\n \t  stmt = gsi_stmt (si);\n-\t  if (dump_kind_p (MSG_NOTE))\n+\t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location, \"init: stmt relevant? \");\n \t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n@@ -632,7 +632,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n       ssa_op_iter iter;\n \n       stmt = VEC_pop (gimple, worklist);\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \t{\n           dump_printf_loc (MSG_NOTE, vect_location, \"worklist: examine stmt: \");\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n@@ -677,7 +677,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   \t          /* fall through */\n \n \t        default:\n-\t          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t          if (dump_enabled_p ())\n \t            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                      \"unsupported use of reduction.\");\n   \t          VEC_free (gimple, heap, worklist);\n@@ -692,7 +692,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n                 && tmp_relevant != vect_used_in_outer_by_reduction\n                 && tmp_relevant != vect_used_in_outer)\n               {\n-                if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                if (dump_enabled_p ())\n                   dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                    \"unsupported use of nested cycle.\");\n \n@@ -707,7 +707,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n             if (tmp_relevant != vect_unused_in_scope\n                 && tmp_relevant != vect_used_by_reduction)\n               {\n-                if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                if (dump_enabled_p ())\n                   dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                    \"unsupported use of double reduction.\");\n \n@@ -830,7 +830,7 @@ vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n   inside_cost = record_stmt_cost (body_cost_vec, ncopies, vector_stmt,\n \t\t\t\t  stmt_info, 0, vect_body);\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_model_simple_cost: inside_cost = %d, \"\n                      \"prologue_cost = %d .\", inside_cost, prologue_cost);\n@@ -876,7 +876,7 @@ vect_model_promotion_demotion_cost (stmt_vec_info stmt_info,\n       prologue_cost += add_stmt_cost (target_cost_data, 1, vector_stmt,\n \t\t\t\t      stmt_info, 0, vect_prologue);\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_model_promotion_demotion_cost: inside_cost = %d, \"\n                      \"prologue_cost = %d .\", inside_cost, prologue_cost);\n@@ -960,7 +960,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n       inside_cost = record_stmt_cost (body_cost_vec, nstmts, vec_perm,\n \t\t\t\t      stmt_info, 0, vect_body);\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"vect_model_store_cost: strided group_size = %d .\",\n                          group_size);\n@@ -969,7 +969,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n   /* Costs of the stores.  */\n   vect_get_store_cost (first_dr, ncopies, &inside_cost, body_cost_vec);\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_model_store_cost: inside_cost = %d, \"\n                      \"prologue_cost = %d .\", inside_cost, prologue_cost);\n@@ -994,7 +994,7 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n \t\t\t\t\t  vector_store, stmt_info, 0,\n \t\t\t\t\t  vect_body);\n \n-        if (dump_kind_p (MSG_NOTE))\n+        if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"vect_model_store_cost: aligned.\");\n         break;\n@@ -1006,7 +1006,7 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n \t*inside_cost += record_stmt_cost (body_cost_vec, ncopies,\n \t\t\t\t\t  unaligned_store, stmt_info,\n \t\t\t\t\t  DR_MISALIGNMENT (dr), vect_body);\n-        if (dump_kind_p (MSG_NOTE))\n+        if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"vect_model_store_cost: unaligned supported by \"\n                            \"hardware.\");\n@@ -1017,7 +1017,7 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n       {\n         *inside_cost = VECT_MAX_COST;\n \n-        if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        if (dump_enabled_p ())\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                            \"vect_model_store_cost: unsupported access.\");\n         break;\n@@ -1076,7 +1076,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n       inside_cost += record_stmt_cost (body_cost_vec, nstmts, vec_perm,\n \t\t\t\t       stmt_info, 0, vect_body);\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location, \n                          \"vect_model_load_cost: strided group_size = %d .\",\n                          group_size);\n@@ -1100,7 +1100,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t\t&inside_cost, &prologue_cost, \n \t\t\tprologue_cost_vec, body_cost_vec, true);\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_model_load_cost: inside_cost = %d, \"\n                      \"prologue_cost = %d .\", inside_cost, prologue_cost);\n@@ -1127,7 +1127,7 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n \t*inside_cost += record_stmt_cost (body_cost_vec, ncopies, vector_load,\n \t\t\t\t\t  stmt_info, 0, vect_body);\n \n-        if (dump_kind_p (MSG_NOTE))\n+        if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"vect_model_load_cost: aligned.\");\n \n@@ -1140,7 +1140,7 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n \t\t\t\t\t  unaligned_load, stmt_info,\n \t\t\t\t\t  DR_MISALIGNMENT (dr), vect_body);\n \n-        if (dump_kind_p (MSG_NOTE))\n+        if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"vect_model_load_cost: unaligned supported by \"\n                            \"hardware.\");\n@@ -1161,15 +1161,15 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n \t  *inside_cost += record_stmt_cost (body_cost_vec, 1, vector_stmt,\n \t\t\t\t\t    stmt_info, 0, vect_body);\n \n-        if (dump_kind_p (MSG_NOTE))\n+        if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location, \n                            \"vect_model_load_cost: explicit realign\");\n \n         break;\n       }\n     case dr_explicit_realign_optimized:\n       {\n-        if (dump_kind_p (MSG_NOTE))\n+        if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location, \n                            \"vect_model_load_cost: unaligned software \"\n                            \"pipelined.\");\n@@ -1197,7 +1197,7 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n \t*inside_cost += record_stmt_cost (body_cost_vec, ncopies, vec_perm,\n \t\t\t\t\t  stmt_info, 0, vect_body);\n \n-        if (dump_kind_p (MSG_NOTE))\n+        if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"vect_model_load_cost: explicit realign optimized\");\n \n@@ -1208,7 +1208,7 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n       {\n         *inside_cost = VECT_MAX_COST;\n \n-        if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+        if (dump_enabled_p ())\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                            \"vect_model_load_cost: unsupported access.\");\n         break;\n@@ -1258,7 +1258,7 @@ vect_init_vector_1 (gimple stmt, gimple new_stmt, gimple_stmt_iterator *gsi)\n        }\n     }\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"created new init_stmt: \");\n@@ -1340,7 +1340,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n   bool is_simple_use;\n   tree vector_type;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"vect_get_vec_def_for_operand: \");\n@@ -1350,7 +1350,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n   is_simple_use = vect_is_simple_use (op, stmt, loop_vinfo, NULL,\n \t\t\t\t      &def_stmt, &def, &dt);\n   gcc_assert (is_simple_use);\n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       int loc_printed = 0;\n       if (def)\n@@ -1382,7 +1382,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n \t  *scalar_def = op;\n \n         /* Create 'vect_cst_ = {cst,cst,...,cst}'  */\n-        if (dump_kind_p (MSG_NOTE))\n+        if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"Create vector_cst. nunits = %d\", nunits);\n \n@@ -1399,7 +1399,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n \t  *scalar_def = def;\n \n         /* Create 'vec_inv = {inv,inv,..,inv}'  */\n-        if (dump_kind_p (MSG_NOTE))\n+        if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location, \"Create vector_inv.\");\n \n         return vect_init_vector (stmt, def, vector_type, NULL);\n@@ -1661,7 +1661,7 @@ vect_finish_stmt_generation (gimple stmt, gimple vec_stmt,\n   set_vinfo_for_stmt (vec_stmt, new_stmt_vec_info (vec_stmt, loop_vinfo,\n                                                    bb_vinfo));\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"add new stmt: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, vec_stmt, 0);\n@@ -1764,7 +1764,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       if (rhs_type\n \t  && !types_compatible_p (rhs_type, TREE_TYPE (op)))\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"argument types differ.\");\n \t  return false;\n@@ -1775,7 +1775,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       if (!vect_is_simple_use_1 (op, stmt, loop_vinfo, bb_vinfo,\n \t\t\t\t &def_stmt, &def, &dt[i], &opvectype))\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"use not simple.\");\n \t  return false;\n@@ -1786,7 +1786,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       else if (opvectype\n \t       && opvectype != vectype_in)\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"argument vector types differ.\");\n \t  return false;\n@@ -1800,7 +1800,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     gcc_assert (vectype_in);\n   if (!vectype_in)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                            \"no vectype for scalar type \");\n@@ -1829,7 +1829,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   fndecl = vectorizable_function (stmt, vectype_out, vectype_in);\n   if (fndecl == NULL_TREE)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"function is not vectorizable.\");\n \n@@ -1852,15 +1852,15 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = call_vec_info_type;\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location, \"=== vectorizable_call ===\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n       return true;\n     }\n \n   /** Transform.  **/\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"transform call.\");\n \n   /* Handle def.  */\n@@ -2375,7 +2375,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t  && (TYPE_PRECISION (rhs_type)\n \t      != GET_MODE_PRECISION (TYPE_MODE (rhs_type)))))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"type conversion to/from bit-precision unsupported.\");\n       return false;\n@@ -2385,7 +2385,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vect_is_simple_use_1 (op0, stmt, loop_vinfo, bb_vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"use not simple.\");\n       return false;\n@@ -2407,7 +2407,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \n       if (!ok)\n \t{\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"use not simple.\");\n \t  return false;\n@@ -2422,7 +2422,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n     gcc_assert (vectype_in);\n   if (!vectype_in)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                            \"no vectype for scalar type \");\n@@ -2466,7 +2466,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \tbreak;\n       /* FALLTHRU */\n     unsupported:\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"conversion not supported by target.\");\n       return false;\n@@ -2565,7 +2565,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \n   if (!vec_stmt)\t\t/* transformation not required.  */\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n                          \"=== vectorizable_conversion ===\");\n       if (code == FIX_TRUNC_EXPR || code == FLOAT_EXPR)\n@@ -2588,7 +2588,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n     }\n \n   /** Transform.  **/\n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"transform conversion. ncopies = %d.\", ncopies);\n \n@@ -2941,7 +2941,7 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vect_is_simple_use_1 (op, stmt, loop_vinfo, bb_vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"use not simple.\");\n       return false;\n@@ -2970,7 +2970,7 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n \t    > TYPE_PRECISION (TREE_TYPE (op)))\n \t   && TYPE_UNSIGNED (TREE_TYPE (op))))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"type conversion to/from bit-precision \"\n                          \"unsupported.\");\n@@ -2980,15 +2980,15 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = assignment_vec_info_type;\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"=== vectorizable_assignment ===\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n       return true;\n     }\n \n   /** Transform.  **/\n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"transform assignment.\");\n \n   /* Handle def.  */\n@@ -3135,7 +3135,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n   if (TYPE_PRECISION (TREE_TYPE (scalar_dest))\n       != GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (scalar_dest))))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"bit-precision shifts not supported.\");\n       return false;\n@@ -3145,7 +3145,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vect_is_simple_use_1 (op0, stmt, loop_vinfo, bb_vinfo,\n                              &def_stmt, &def, &dt[0], &vectype))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"use not simple.\");\n       return false;\n@@ -3158,7 +3158,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n     gcc_assert (vectype);\n   if (!vectype)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"no vectype for scalar type \");\n       return false;\n@@ -3173,7 +3173,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vect_is_simple_use_1 (op1, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n \t\t\t     &def, &dt[1], &op1_vectype))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"use not simple.\");\n       return false;\n@@ -3218,7 +3218,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n     }\n   else\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"operand mode requires invariant argument.\");\n       return false;\n@@ -3228,7 +3228,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!scalar_shift_arg)\n     {\n       optab = optab_for_tree_code (code, vectype, optab_vector);\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"vector/vector shift/rotate found.\");\n \n@@ -3237,7 +3237,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n       if (op1_vectype == NULL_TREE\n \t  || TYPE_MODE (op1_vectype) != TYPE_MODE (vectype))\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"unusable type for last operand in\"\n                              \" vector/vector shift/rotate.\");\n@@ -3252,7 +3252,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n       if (optab\n           && optab_handler (optab, TYPE_MODE (vectype)) != CODE_FOR_nothing)\n         {\n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location,\n                              \"vector/scalar shift/rotate found.\");\n         }\n@@ -3265,7 +3265,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n             {\n \t      scalar_shift_arg = false;\n \n-              if (dump_kind_p (MSG_NOTE))\n+              if (dump_enabled_p ())\n                 dump_printf_loc (MSG_NOTE, vect_location,\n                                  \"vector/vector shift/rotate found.\");\n \n@@ -3282,7 +3282,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t      && TYPE_MODE (TREE_TYPE (vectype))\n \t\t\t != TYPE_MODE (TREE_TYPE (op1)))\n \t\t    {\n-                      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                      if (dump_enabled_p ())\n                         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                          \"unusable type for last operand in\"\n                                          \" vector/vector shift/rotate.\");\n@@ -3302,7 +3302,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Supportable by target?  */\n   if (!optab)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"no optab.\");\n       return false;\n@@ -3311,15 +3311,15 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n   icode = (int) optab_handler (optab, vec_mode);\n   if (icode == CODE_FOR_nothing)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"op not supported by target.\");\n       /* Check only during analysis.  */\n       if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n           || (vf < vect_min_worthwhile_factor (code)\n               && !vec_stmt))\n         return false;\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location, \"proceeding using word mode.\");\n     }\n \n@@ -3328,7 +3328,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n       && vf < vect_min_worthwhile_factor (code)\n       && !vec_stmt)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"not worthwhile without SIMD support.\");\n       return false;\n@@ -3337,15 +3337,15 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = shift_vec_info_type;\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location, \"=== vectorizable_shift ===\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n       return true;\n     }\n \n   /** Transform.  **/\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"transform binary/unary operation.\");\n \n@@ -3382,7 +3382,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n               optab_op2_mode = insn_data[icode].operand[2].mode;\n               if (!VECTOR_MODE_P (optab_op2_mode))\n                 {\n-                  if (dump_kind_p (MSG_NOTE))\n+                  if (dump_enabled_p ())\n                     dump_printf_loc (MSG_NOTE, vect_location,\n                                      \"operand 1 using scalar mode.\");\n                   vec_oprnd1 = op1;\n@@ -3510,7 +3510,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   op_type = TREE_CODE_LENGTH (code);\n   if (op_type != unary_op && op_type != binary_op && op_type != ternary_op)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"num. args = %d (not unary/binary/ternary op).\",\n                          op_type);\n@@ -3529,7 +3529,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       && code != BIT_XOR_EXPR\n       && code != BIT_AND_EXPR)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"bit-precision arithmetic not supported.\");\n       return false;\n@@ -3539,7 +3539,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vect_is_simple_use_1 (op0, stmt, loop_vinfo, bb_vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"use not simple.\");\n       return false;\n@@ -3552,7 +3552,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n     gcc_assert (vectype);\n   if (!vectype)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                            \"no vectype for scalar type \");\n@@ -3574,7 +3574,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       if (!vect_is_simple_use (op1, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n \t\t\t       &def, &dt[1]))\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"use not simple.\");\n \t  return false;\n@@ -3586,7 +3586,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       if (!vect_is_simple_use (op2, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n \t\t\t       &def, &dt[2]))\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"use not simple.\");\n \t  return false;\n@@ -3628,7 +3628,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       optab = optab_for_tree_code (code, vectype, optab_default);\n       if (!optab)\n \t{\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"no optab.\");\n \t  return false;\n@@ -3638,14 +3638,14 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \n   if (icode == CODE_FOR_nothing)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"op not supported by target.\");\n       /* Check only during analysis.  */\n       if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n \t  || (!vec_stmt && vf < vect_min_worthwhile_factor (code)))\n         return false;\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location, \"proceeding using word mode.\");\n     }\n \n@@ -3654,7 +3654,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       && !vec_stmt\n       && vf < vect_min_worthwhile_factor (code))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"not worthwhile without SIMD support.\");\n       return false;\n@@ -3663,7 +3663,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = op_vec_info_type;\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"=== vectorizable_operation ===\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n@@ -3672,7 +3672,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \n   /** Transform.  **/\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"transform binary/unary operation.\");\n \n@@ -3860,7 +3860,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   /* FORNOW. This restriction should be relaxed.  */\n   if (loop && nested_in_vect_loop_p (loop, stmt) && ncopies > 1)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"multiple types in nested loop.\");\n       return false;\n@@ -3894,7 +3894,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!vect_is_simple_use (op, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n \t\t\t   &def, &dt))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"use not simple.\");\n       return false;\n@@ -3915,7 +3915,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t    ? STMT_VINFO_DR_STEP (stmt_info) : DR_STEP (dr),\n \t\t\t    size_zero_node) < 0)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"negative step for store.\");\n       return false;\n@@ -3946,7 +3946,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n               if (!vect_is_simple_use (op, next_stmt, loop_vinfo, bb_vinfo,\n \t\t\t\t       &def_stmt, &def, &dt))\n                 {\n-                  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+                  if (dump_enabled_p ())\n                     dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                      \"use not simple.\");\n                   return false;\n@@ -4008,7 +4008,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       group_size = vec_num = 1;\n     }\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"transform store. ncopies = %d\", ncopies);\n \n@@ -4396,7 +4396,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   /* FORNOW. This restriction should be relaxed.  */\n   if (nested_in_vect_loop && ncopies > 1)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"multiple types in nested loop.\");\n       return false;\n@@ -4436,7 +4436,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     (e.g. - data copies).  */\n   if (optab_handler (mov_optab, mode) == CODE_FOR_nothing)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"Aligned load, but unsupported type.\");\n       return false;\n@@ -4472,7 +4472,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t\t &def_stmt, &def, &gather_dt,\n \t\t\t\t &gather_off_vectype))\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"gather index use not simple.\");\n \t  return false;\n@@ -4492,7 +4492,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t\t\t\t       size_zero_node) < 0;\n       if (negative && ncopies > 1)\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"multiple types with negative step.\");\n \t  return false;\n@@ -4505,14 +4505,14 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  if (alignment_support_scheme != dr_aligned\n \t      && alignment_support_scheme != dr_unaligned_supported)\n \t    {\n-              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+              if (dump_enabled_p ())\n                 dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                  \"negative step but alignment required.\");\n \t      return false;\n \t    }\n \t  if (!perm_mask_for_reverse (vectype))\n \t    {\n-              if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+              if (dump_enabled_p ())\n                 dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                  \"negative step and reversing not supported.\");\n \t      return false;\n@@ -4527,7 +4527,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       return true;\n     }\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"transform load. ncopies = %d\", ncopies);\n \n@@ -5334,7 +5334,7 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   /* FORNOW: not yet supported.  */\n   if (STMT_VINFO_LIVE_P (stmt_info))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"value used after loop.\");\n       return false;\n@@ -5534,15 +5534,15 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n   gimple pattern_stmt;\n   gimple_seq pattern_def_seq;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"==> examining statement: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n     }\n \n   if (gimple_has_volatile_ops (stmt))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"not vectorized: stmt has volatile operands\");\n \n@@ -5575,7 +5575,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n           /* Analyze PATTERN_STMT instead of the original stmt.  */\n           stmt = pattern_stmt;\n           stmt_info = vinfo_for_stmt (pattern_stmt);\n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_NOTE, vect_location,\n                                \"==> examining pattern statement: \");\n@@ -5584,7 +5584,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n         }\n       else\n         {\n-          if (dump_kind_p (MSG_NOTE))\n+          if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location, \"irrelevant.\");\n \n           return true;\n@@ -5597,7 +5597,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n                || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n     {\n       /* Analyze PATTERN_STMT too.  */\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"==> examining pattern statement: \");\n@@ -5621,7 +5621,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n \t      || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_def_stmt)))\n \t    {\n \t      /* Analyze def stmt of STMT if it's a pattern stmt.  */\n-\t      if (dump_kind_p (MSG_NOTE))\n+\t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_NOTE, vect_location,\n                                    \"==> examining pattern def statement: \");\n@@ -5660,7 +5660,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n       gcc_assert (PURE_SLP_STMT (stmt_info));\n \n       scalar_type = TREE_TYPE (gimple_get_lhs (stmt));\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"get vectype for scalar type:  \");\n@@ -5670,7 +5670,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n       vectype = get_vectype_for_scalar_type (scalar_type);\n       if (!vectype)\n         {\n-          if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+          if (dump_enabled_p ())\n             {\n                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                 \"not SLPed: unsupported data-type \");\n@@ -5680,7 +5680,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n           return false;\n         }\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_NOTE, vect_location, \"vectype:  \");\n           dump_generic_expr (MSG_NOTE, TDF_SLIM, vectype);\n@@ -5724,7 +5724,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n \n   if (!ok)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                            \"not vectorized: relevant stmt not \");\n@@ -5746,7 +5746,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n \n   if (!ok)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         {\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                            \"not vectorized: live stmt not \");\n@@ -5846,7 +5846,7 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n     default:\n       if (!STMT_VINFO_LIVE_P (stmt_info))\n \t{\n-\t  if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+\t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"stmt not supported.\");\n \t  gcc_unreachable ();\n@@ -5871,7 +5871,7 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n       tree scalar_dest;\n       gimple exit_phi;\n \n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n                          \"Record the vdef for outer-loop vectorization.\");\n \n@@ -6108,7 +6108,7 @@ get_vectype_for_scalar_type_and_size (tree scalar_type, unsigned size)\n     return NULL_TREE;\n \n   vectype = build_vector_type (scalar_type, nunits);\n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"get vectype with %d units of type \", nunits);\n@@ -6118,7 +6118,7 @@ get_vectype_for_scalar_type_and_size (tree scalar_type, unsigned size)\n   if (!vectype)\n     return NULL_TREE;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n       dump_generic_expr (MSG_NOTE, TDF_SLIM, vectype);\n@@ -6127,7 +6127,7 @@ get_vectype_for_scalar_type_and_size (tree scalar_type, unsigned size)\n   if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n       && !INTEGRAL_MODE_P (TYPE_MODE (vectype)))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"mode not supported by target.\");\n       return NULL_TREE;\n@@ -6198,7 +6198,7 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n   *def_stmt = NULL;\n   *def = NULL_TREE;\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"vect_is_simple_use: operand \");\n@@ -6220,14 +6220,14 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n \n   if (TREE_CODE (operand) == PAREN_EXPR)\n     {\n-      if (dump_kind_p (MSG_NOTE))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location, \"non-associatable copy.\");\n       operand = TREE_OPERAND (operand, 0);\n     }\n \n   if (TREE_CODE (operand) != SSA_NAME)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"not ssa-name.\");\n       return false;\n@@ -6236,13 +6236,13 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n   *def_stmt = SSA_NAME_DEF_STMT (operand);\n   if (*def_stmt == NULL)\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"no def_stmt.\");\n       return false;\n     }\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"def_stmt: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, *def_stmt, 0);\n@@ -6274,13 +6274,13 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n \t  && *dt == vect_double_reduction_def\n \t  && gimple_code (stmt) != GIMPLE_PHI))\n     {\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"Unsupported pattern.\");\n       return false;\n     }\n \n-  if (dump_kind_p (MSG_NOTE))\n+  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"type of def: %d.\", *dt);\n \n   switch (gimple_code (*def_stmt))\n@@ -6299,7 +6299,7 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n \tbreak;\n       /* FALLTHRU */\n     default:\n-      if (dump_kind_p (MSG_MISSED_OPTIMIZATION))\n+      if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"unsupported defining stmt: \");\n       return false;"}, {"sha": "a74ad9d3cd123a6f31eb4d51607e65e607dfa2cd", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73fbfcad22ae37dfd57a544aa0f5339b73bac439/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=73fbfcad22ae37dfd57a544aa0f5339b73bac439", "patch": "@@ -107,7 +107,7 @@ vectorize_loops (void)\n \tloop_vec_info loop_vinfo;\n \tvect_location = find_loop_location (loop);\n         if (LOCATION_LOCUS (vect_location) != UNKNOWN_LOC\n-\t    && dump_kind_p (MSG_ALL))\n+\t    && dump_enabled_p ())\n \t  dump_printf (MSG_ALL, \"\\nAnalyzing loop at %s:%d\\n\",\n                        LOC_FILE (vect_location), LOC_LINE (vect_location));\n \n@@ -118,7 +118,7 @@ vectorize_loops (void)\n \t  continue;\n \n         if (LOCATION_LOCUS (vect_location) != UNKNOWN_LOC\n-\t    && dump_kind_p (MSG_ALL))\n+\t    && dump_enabled_p ())\n           dump_printf (MSG_ALL, \"\\n\\nVectorizing loop at %s:%d\\n\",\n                        LOC_FILE (vect_location), LOC_LINE (vect_location));\n \tvect_transform_loop (loop_vinfo);\n@@ -128,8 +128,8 @@ vectorize_loops (void)\n   vect_location = UNKNOWN_LOC;\n \n   statistics_counter_event (cfun, \"Vectorized loops\", num_vectorized_loops);\n-  if (dump_kind_p (MSG_ALL)\n-      || (num_vectorized_loops > 0 && dump_kind_p (MSG_ALL)))\n+  if (dump_enabled_p ()\n+      || (num_vectorized_loops > 0 && dump_enabled_p ()))\n     dump_printf_loc (MSG_ALL, vect_location,\n                      \"vectorized %u loops in function.\\n\",\n                      num_vectorized_loops);\n@@ -170,7 +170,7 @@ execute_vect_slp (void)\n       if (vect_slp_analyze_bb (bb))\n         {\n           vect_slp_transform_bb (bb);\n-          if (dump_kind_p (MSG_OPTIMIZED_LOCATIONS))\n+          if (dump_enabled_p ())\n             dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n \t\t\t     \"basic block vectorized using SLP\\n\");\n         }"}]}