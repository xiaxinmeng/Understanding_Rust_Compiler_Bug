{"sha": "ca1117ccf724e0b1b543e3e7b607087444340191", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ExMTE3Y2NmNzI0ZTBiMWI1NDNlM2U3YjYwNzA4NzQ0NDM0MDE5MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-05-23T03:40:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-05-23T03:40:53Z"}, "message": "function.c (thread_prologue_and_epilogue_insns): Make sure existing line number notes appear after the prologue.\n\n        * function.c (thread_prologue_and_epilogue_insns): Make sure\n        existing line number notes appear after the prologue.\n\nFrom-SVN: r34098", "tree": {"sha": "7ca7a2beb746e40066364f14177f7d1358975cc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ca7a2beb746e40066364f14177f7d1358975cc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca1117ccf724e0b1b543e3e7b607087444340191", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca1117ccf724e0b1b543e3e7b607087444340191", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca1117ccf724e0b1b543e3e7b607087444340191", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca1117ccf724e0b1b543e3e7b607087444340191/comments", "author": null, "committer": null, "parents": [{"sha": "941cc05afd83b2a1af44a98d7c6598c947ea6a3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/941cc05afd83b2a1af44a98d7c6598c947ea6a3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/941cc05afd83b2a1af44a98d7c6598c947ea6a3d"}], "stats": {"total": 89, "additions": 62, "deletions": 27}, "files": [{"sha": "f3af63bdfa73b42488f11f9c4a1c02072fd924fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca1117ccf724e0b1b543e3e7b607087444340191/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca1117ccf724e0b1b543e3e7b607087444340191/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca1117ccf724e0b1b543e3e7b607087444340191", "patch": "@@ -1,3 +1,8 @@\n+2000-05-22  Richard Henderson  <rth@cygnus.com>\n+\n+\t* function.c (thread_prologue_and_epilogue_insns): Make sure \n+\texisting line number notes appear after the prologue.\n+\n Mon May 22 21:49:00 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* config/alpha/alpha.c (alpha_fnname): New static variable."}, {"sha": "63634bb602c8f8d25a200bf227aa875cf7edad94", "filename": "gcc/function.c", "status": "modified", "additions": 57, "deletions": 27, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca1117ccf724e0b1b543e3e7b607087444340191/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca1117ccf724e0b1b543e3e7b607087444340191/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ca1117ccf724e0b1b543e3e7b607087444340191", "patch": "@@ -6812,15 +6812,16 @@ void\n thread_prologue_and_epilogue_insns (f)\n      rtx f ATTRIBUTE_UNUSED;\n {\n-  int insertted = 0;\n+  int inserted = 0;\n   edge e;\n   rtx seq;\n+#ifdef HAVE_prologue\n+  rtx prologue_end = NULL_RTX;\n+#endif\n \n #ifdef HAVE_prologue\n   if (HAVE_prologue)\n     {\n-      rtx insn;\n-\n       start_sequence ();\n       seq = gen_prologue();\n       emit_insn (seq);\n@@ -6829,26 +6830,7 @@ thread_prologue_and_epilogue_insns (f)\n       if (GET_CODE (seq) != SEQUENCE)\n \tseq = get_insns ();\n       record_insns (seq, &prologue);\n-      emit_note (NULL, NOTE_INSN_PROLOGUE_END);\n-\n-      /* GDB handles `break f' by setting a breakpoint on the first\n-\t line note *after* the prologue.  That means that we should\n-\t insert a line note here; otherwise, if the next line note\n-\t comes part way into the next block, GDB will skip all the way\n-\t to that point.  */\n-      insn = next_nonnote_insn (f);\n-      while (insn)\n-\t{\n-\t  if (GET_CODE (insn) == NOTE \n-\t      && NOTE_LINE_NUMBER (insn) >= 0)\n-\t    {\n-\t      emit_line_note_force (NOTE_SOURCE_FILE (insn),\n-\t\t\t\t    NOTE_LINE_NUMBER (insn));\n-\t      break;\n-\t    }\n-\n-\t  insn = PREV_INSN (insn);\n-\t}\n+      prologue_end = emit_note (NULL, NOTE_INSN_PROLOGUE_END);\n \n       seq = gen_sequence ();\n       end_sequence ();\n@@ -6862,7 +6844,7 @@ thread_prologue_and_epilogue_insns (f)\n \t    abort ();\n \n \t  insert_insn_on_edge (seq, ENTRY_BLOCK_PTR->succ);\n-\t  insertted = 1;\n+\t  inserted = 1;\n \t}\n       else\n \temit_insn_after (seq, f);\n@@ -6977,7 +6959,7 @@ thread_prologue_and_epilogue_insns (f)\n \t  seq = gen_sequence ();\n \t  end_sequence ();\n \t  insert_insn_on_edge (seq, e);\n-\t  insertted = 1;\n+\t  inserted = 1;\n \t}\n       goto epilogue_done;\n     }\n@@ -7011,12 +6993,12 @@ thread_prologue_and_epilogue_insns (f)\n       end_sequence();\n \n       insert_insn_on_edge (seq, e);\n-      insertted = 1;\n+      inserted = 1;\n     }\n #endif\n epilogue_done:\n \n-  if (insertted)\n+  if (inserted)\n     commit_edge_insertions ();\n \n #ifdef HAVE_sibcall_epilogue\n@@ -7049,6 +7031,54 @@ thread_prologue_and_epilogue_insns (f)\n \t\t    ? seq : newinsn, &sibcall_epilogue);\n     }\n #endif\n+\n+#ifdef HAVE_prologue\n+  if (prologue_end)\n+    {\n+      rtx insn, prev;\n+\n+      /* GDB handles `break f' by setting a breakpoint on the first\n+\t line note *after* the prologue.  Which means (1) that if\n+\t there are line number notes before where we inserted the\n+\t prologue we should move them, and (2) if there is no such\n+\t note, then we should generate one at the prologue.  */\n+\n+      for (insn = prologue_end; insn ; insn = prev)\n+\t{\n+\t  prev = PREV_INSN (insn);\n+\t  if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n+\t    {\n+\t      /* Note that we cannot reorder the first insn in the\n+\t\t chain, since rest_of_compilation relies on that\n+\t\t remaining constant.  Do the next best thing.  */\n+\t      if (prev == NULL)\n+\t\t{\n+\t\t  emit_line_note_after (NOTE_SOURCE_FILE (insn),\n+\t\t\t\t\tNOTE_LINE_NUMBER (insn),\n+\t\t\t\t\tprologue_end);\n+\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\t}\n+\t      else\n+\t\treorder_insns (insn, insn, prologue_end);\n+\t    }\n+\t}\n+\n+      insn = NEXT_INSN (prologue_end);\n+      if (! insn || GET_CODE (insn) != NOTE || NOTE_LINE_NUMBER (insn) <= 0)\n+\t{\n+\t  for (insn = next_active_insn (f); insn ; insn = PREV_INSN (insn))\n+\t    {\n+\t      if (GET_CODE (insn) == NOTE && NOTE_LINE_NUMBER (insn) > 0)\n+\t\t{\n+\t\t  emit_line_note_after (NOTE_SOURCE_FILE (insn),\n+\t\t\t\t\tNOTE_LINE_NUMBER (insn),\n+\t\t\t\t\tprologue_end);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+#endif\n }\n \n /* Reposition the prologue-end and epilogue-begin notes after instruction"}]}