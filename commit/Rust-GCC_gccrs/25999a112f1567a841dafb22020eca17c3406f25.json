{"sha": "25999a112f1567a841dafb22020eca17c3406f25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU5OTlhMTEyZjE1NjdhODQxZGFmYjIyMDIwZWNhMTdjMzQwNmYyNQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-05-24T15:28:26Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-05-24T15:28:26Z"}, "message": "Implement P0558R2 changes to std::atomic\n\nThe restrictions forbidding arithmetic on atomic pointer types are only\nenabled for C++17 and later, retaining the GNU extension for older\nstandards. The new nested typedefs and changes to prevent scalar\nparameters participating in template argument deduction are enabled\nunconditionally.\n\n\tPR libstdc++/69769\n\tPR libstdc++/85886\n\t* include/bits/atomic_base.h (__atomic_base::value_type)\n\t(__atomic_base::difference_type): Add new typedefs.\n\t* include/std/atomic (atomic<bool>::value_type, atomic<T>::value_type)\n\t(atomic<T*>::value_type, atomic<T*>::difference_type): Likewise.\n\t(atomic<T*>::operator++, atomic<T*>::operator--)\n\t(atomic<T*>::operator+=, atomic<T*>::operator-=)\n\t(atomic<T*>::fetch_add, atomic<T*>::fetch_sub): Add static assertion\n\tto enforce C++17 requirement on pointer arithmetic.\n\t(__atomic_val_t, __atomic_diff_t): New alias templates.\n\t(atomic_init, atomic_store_explicit, atomic_exchange_explicit)\n\t(atomic_compare_exchange_weak_explicit)\n\t(atomic_compare_exchange_strong_explicit, atomic_store)\n\t(atomic_exchange, atomic_compare_exchange_weak)\n\t(atomic_compare_exchange_strong): Use __atomic_val_t to make\n\tscalar parameters be non-deduced contexts.\n\t(atomic_fetch_add_explicit, atomic_fetch_sub_explicit)\n\t(atomic_fetch_add, atomic_fetch_sub): Change first parameter to be\n\tatomic instead of __atomic_base, and use __atomic_diff_t for scalar\n\tparameters.\n\t(atomic_fetch_and_explicit, atomic_fetch_or_explicit)\n\t(atomic_fetch_xor_explicit, atomic_fetch_and, atomic_fetch_or)\n\t(atomic_fetch_xor): Use __atomic_val_t for scalar parameters.\n\t(atomic_fetch_add_explicit, atomic_fetch_sub_explicit)\n\t(atomic_fetch_add, atomic_fetch_sub): Remove overloads for atomic\n\taddress types.\n\t* testsuite/29_atomics/atomic/60695.cc: Adjust dg-error lineno.\n\t* testsuite/29_atomics/atomic/69769.cc: New test.\n\t* testsuite/29_atomics/atomic/nonmembers.cc: New test.\n\t* testsuite/29_atomics/atomic/operators/pointer_partial_void.cc:\n\tDisable test for C++17 and later.\n\t* testsuite/29_atomics/atomic/requirements/typedefs.cc: New test.\n\t* testsuite/29_atomics/atomic_integral/nonmembers.cc: New test.\n\t* testsuite/29_atomics/atomic_integral/requirements/typedefs.cc: New\n\ttest.\n\nFrom-SVN: r260676", "tree": {"sha": "cc71148cda9d60b7a8224f0fc68a2a68bb1930c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc71148cda9d60b7a8224f0fc68a2a68bb1930c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25999a112f1567a841dafb22020eca17c3406f25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25999a112f1567a841dafb22020eca17c3406f25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25999a112f1567a841dafb22020eca17c3406f25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25999a112f1567a841dafb22020eca17c3406f25/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d39ea2f9d6fe301885a3ca1064ecec8e689ab12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d39ea2f9d6fe301885a3ca1064ecec8e689ab12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d39ea2f9d6fe301885a3ca1064ecec8e689ab12"}], "stats": {"total": 914, "additions": 791, "deletions": 123}, "files": [{"sha": "0f73c6a55310266e46950ce125c711a35b7c227e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=25999a112f1567a841dafb22020eca17c3406f25", "patch": "@@ -1,3 +1,42 @@\n+2018-05-24  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/69769\n+\tPR libstdc++/85886\n+\t* include/bits/atomic_base.h (__atomic_base::value_type)\n+\t(__atomic_base::difference_type): Add new typedefs.\n+\t* include/std/atomic (atomic<bool>::value_type, atomic<T>::value_type)\n+\t(atomic<T*>::value_type, atomic<T*>::difference_type): Likewise.\n+\t(atomic<T*>::operator++, atomic<T*>::operator--)\n+\t(atomic<T*>::operator+=, atomic<T*>::operator-=)\n+\t(atomic<T*>::fetch_add, atomic<T*>::fetch_sub): Add static assertion\n+\tto enforce C++17 requirement on pointer arithmetic.\n+\t(__atomic_val_t, __atomic_diff_t): New alias templates.\n+\t(atomic_init, atomic_store_explicit, atomic_exchange_explicit)\n+\t(atomic_compare_exchange_weak_explicit)\n+\t(atomic_compare_exchange_strong_explicit, atomic_store)\n+\t(atomic_exchange, atomic_compare_exchange_weak)\n+\t(atomic_compare_exchange_strong): Use __atomic_val_t to make\n+\tscalar parameters be non-deduced contexts.\n+\t(atomic_fetch_add_explicit, atomic_fetch_sub_explicit)\n+\t(atomic_fetch_add, atomic_fetch_sub): Change first parameter to be\n+\tatomic instead of __atomic_base, and use __atomic_diff_t for scalar\n+\tparameters.\n+\t(atomic_fetch_and_explicit, atomic_fetch_or_explicit)\n+\t(atomic_fetch_xor_explicit, atomic_fetch_and, atomic_fetch_or)\n+\t(atomic_fetch_xor): Use __atomic_val_t for scalar parameters.\n+\t(atomic_fetch_add_explicit, atomic_fetch_sub_explicit)\n+\t(atomic_fetch_add, atomic_fetch_sub): Remove overloads for atomic\n+\taddress types.\n+\t* testsuite/29_atomics/atomic/60695.cc: Adjust dg-error lineno.\n+\t* testsuite/29_atomics/atomic/69769.cc: New test.\n+\t* testsuite/29_atomics/atomic/nonmembers.cc: New test.\n+\t* testsuite/29_atomics/atomic/operators/pointer_partial_void.cc:\n+\tDisable test for C++17 and later.\n+\t* testsuite/29_atomics/atomic/requirements/typedefs.cc: New test.\n+\t* testsuite/29_atomics/atomic_integral/nonmembers.cc: New test.\n+\t* testsuite/29_atomics/atomic_integral/requirements/typedefs.cc: New\n+\ttest.\n+\n 2018-05-23  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/fs_path.h (path::__is_encoded_char): Change from class"}, {"sha": "7a3354d9e6f9d7c98da996466b0c7e818ea1d6c3", "filename": "libstdc++-v3/include/bits/atomic_base.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h?ref=25999a112f1567a841dafb22020eca17c3406f25", "patch": "@@ -237,6 +237,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _ITp>\n     struct __atomic_base\n     {\n+      using value_type = _ITp;\n+      using difference_type = value_type;\n+\n     private:\n       typedef _ITp \t__int_type;\n "}, {"sha": "002604676cd47f36c35d98c9d86bad450aafd763", "filename": "libstdc++-v3/include/std/atomic", "status": "modified", "additions": 199, "deletions": 121, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fatomic?ref=25999a112f1567a841dafb22020eca17c3406f25", "patch": "@@ -50,7 +50,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @{\n    */\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n # define __cpp_lib_atomic_is_always_lock_free 201603\n #endif\n \n@@ -62,6 +62,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<>\n   struct atomic<bool>\n   {\n+    using value_type = bool;\n+\n   private:\n     __atomic_base<bool>\t_M_base;\n \n@@ -94,7 +96,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     bool\n     is_lock_free() const volatile noexcept { return _M_base.is_lock_free(); }\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_BOOL_LOCK_FREE == 2;\n #endif\n \n@@ -173,6 +175,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     struct atomic\n     {\n+      using value_type = _Tp;\n+\n     private:\n       // Align 1/2/4/8/16-byte types to at least their size.\n       static constexpr int _S_min_alignment\n@@ -229,7 +233,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    reinterpret_cast<void *>(-__alignof(_M_i)));\n       }\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n       static constexpr bool is_always_lock_free\n \t= __atomic_always_lock_free(sizeof(_M_i), 0);\n #endif\n@@ -351,6 +355,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     struct atomic<_Tp*>\n     {\n+      using value_type = _Tp*;\n+      using difference_type = ptrdiff_t;\n+\n       typedef _Tp* \t\t\t__pointer_type;\n       typedef __atomic_base<_Tp*>\t__base_type;\n       __base_type\t\t\t_M_b;\n@@ -379,51 +386,111 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       __pointer_type\n       operator++(int) noexcept\n-      { return _M_b++; }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn _M_b++;\n+      }\n \n       __pointer_type\n       operator++(int) volatile noexcept\n-      { return _M_b++; }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn _M_b++;\n+      }\n \n       __pointer_type\n       operator--(int) noexcept\n-      { return _M_b--; }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn _M_b--;\n+      }\n \n       __pointer_type\n       operator--(int) volatile noexcept\n-      { return _M_b--; }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn _M_b--;\n+      }\n \n       __pointer_type\n       operator++() noexcept\n-      { return ++_M_b; }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn ++_M_b;\n+      }\n \n       __pointer_type\n       operator++() volatile noexcept\n-      { return ++_M_b; }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn ++_M_b;\n+      }\n \n       __pointer_type\n       operator--() noexcept\n-      { return --_M_b; }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn --_M_b;\n+      }\n \n       __pointer_type\n       operator--() volatile noexcept\n-      { return --_M_b; }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn --_M_b;\n+      }\n \n       __pointer_type\n       operator+=(ptrdiff_t __d) noexcept\n-      { return _M_b.operator+=(__d); }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn _M_b.operator+=(__d);\n+      }\n \n       __pointer_type\n       operator+=(ptrdiff_t __d) volatile noexcept\n-      { return _M_b.operator+=(__d); }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn _M_b.operator+=(__d);\n+      }\n \n       __pointer_type\n       operator-=(ptrdiff_t __d) noexcept\n-      { return _M_b.operator-=(__d); }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn _M_b.operator-=(__d);\n+      }\n \n       __pointer_type\n       operator-=(ptrdiff_t __d) volatile noexcept\n-      { return _M_b.operator-=(__d); }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn _M_b.operator-=(__d);\n+      }\n \n       bool\n       is_lock_free() const noexcept\n@@ -433,7 +500,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       is_lock_free() const volatile noexcept\n       { return _M_b.is_lock_free(); }\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_POINTER_LOCK_FREE == 2;\n #endif\n \n@@ -522,22 +589,42 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __pointer_type\n       fetch_add(ptrdiff_t __d,\n \t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return _M_b.fetch_add(__d, __m); }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn _M_b.fetch_add(__d, __m);\n+      }\n \n       __pointer_type\n       fetch_add(ptrdiff_t __d,\n \t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return _M_b.fetch_add(__d, __m); }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn _M_b.fetch_add(__d, __m);\n+      }\n \n       __pointer_type\n       fetch_sub(ptrdiff_t __d,\n \t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return _M_b.fetch_sub(__d, __m); }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn _M_b.fetch_sub(__d, __m);\n+      }\n \n       __pointer_type\n       fetch_sub(ptrdiff_t __d,\n \t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return _M_b.fetch_sub(__d, __m); }\n+      {\n+#if __cplusplus >= 201703L\n+\tstatic_assert( is_object<_Tp>::value, \"pointer to object type\" );\n+#endif\n+\treturn _M_b.fetch_sub(__d, __m);\n+      }\n     };\n \n \n@@ -559,7 +646,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_CHAR_LOCK_FREE == 2;\n #endif\n     };\n@@ -582,7 +669,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_CHAR_LOCK_FREE == 2;\n #endif\n     };\n@@ -605,7 +692,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_CHAR_LOCK_FREE == 2;\n #endif\n     };\n@@ -628,7 +715,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_SHORT_LOCK_FREE == 2;\n #endif\n     };\n@@ -651,7 +738,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_SHORT_LOCK_FREE == 2;\n #endif\n     };\n@@ -674,7 +761,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_INT_LOCK_FREE == 2;\n #endif\n     };\n@@ -697,7 +784,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_INT_LOCK_FREE == 2;\n #endif\n     };\n@@ -720,7 +807,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_LONG_LOCK_FREE == 2;\n #endif\n     };\n@@ -743,7 +830,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_LONG_LOCK_FREE == 2;\n #endif\n     };\n@@ -766,7 +853,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_LLONG_LOCK_FREE == 2;\n #endif\n     };\n@@ -789,7 +876,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_LLONG_LOCK_FREE == 2;\n #endif\n     };\n@@ -812,7 +899,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_WCHAR_T_LOCK_FREE == 2;\n #endif\n     };\n@@ -835,7 +922,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_CHAR16_T_LOCK_FREE == 2;\n #endif\n     };\n@@ -858,7 +945,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __base_type::operator __integral_type;\n       using __base_type::operator=;\n \n-#if __cplusplus > 201402L\n+#if __cplusplus >= 201703L\n     static constexpr bool is_always_lock_free = ATOMIC_CHAR32_T_LOCK_FREE == 2;\n #endif\n     };\n@@ -1046,6 +1133,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   { atomic_flag_clear_explicit(__a, memory_order_seq_cst); }\n \n \n+  template<typename _Tp>\n+    using __atomic_val_t = typename atomic<_Tp>::value_type;\n+  template<typename _Tp>\n+    using __atomic_diff_t = typename atomic<_Tp>::difference_type;\n+\n+  // [atomics.nonmembers] Non-member functions.\n   // Function templates generally applicable to atomic types.\n   template<typename _ITp>\n     inline bool\n@@ -1059,23 +1152,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _ITp>\n     inline void\n-    atomic_init(atomic<_ITp>* __a, _ITp __i) noexcept\n+    atomic_init(atomic<_ITp>* __a, __atomic_val_t<_ITp> __i) noexcept\n     { __a->store(__i, memory_order_relaxed); }\n \n   template<typename _ITp>\n     inline void\n-    atomic_init(volatile atomic<_ITp>* __a, _ITp __i) noexcept\n+    atomic_init(volatile atomic<_ITp>* __a, __atomic_val_t<_ITp> __i) noexcept\n     { __a->store(__i, memory_order_relaxed); }\n \n   template<typename _ITp>\n     inline void\n-    atomic_store_explicit(atomic<_ITp>* __a, _ITp __i,\n+    atomic_store_explicit(atomic<_ITp>* __a, __atomic_val_t<_ITp> __i,\n \t\t\t  memory_order __m) noexcept\n     { __a->store(__i, __m); }\n \n   template<typename _ITp>\n     inline void\n-    atomic_store_explicit(volatile atomic<_ITp>* __a, _ITp __i,\n+    atomic_store_explicit(volatile atomic<_ITp>* __a, __atomic_val_t<_ITp> __i,\n \t\t\t  memory_order __m) noexcept\n     { __a->store(__i, __m); }\n \n@@ -1092,57 +1185,62 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_exchange_explicit(atomic<_ITp>* __a, _ITp __i,\n+    atomic_exchange_explicit(atomic<_ITp>* __a, __atomic_val_t<_ITp> __i,\n \t\t\t     memory_order __m) noexcept\n     { return __a->exchange(__i, __m); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_exchange_explicit(volatile atomic<_ITp>* __a, _ITp __i,\n+    atomic_exchange_explicit(volatile atomic<_ITp>* __a,\n+\t\t\t     __atomic_val_t<_ITp> __i,\n \t\t\t     memory_order __m) noexcept\n     { return __a->exchange(__i, __m); }\n \n   template<typename _ITp>\n     inline bool\n     atomic_compare_exchange_weak_explicit(atomic<_ITp>* __a,\n-\t\t\t\t\t  _ITp* __i1, _ITp __i2,\n+\t\t\t\t\t  __atomic_val_t<_ITp>* __i1,\n+\t\t\t\t\t  __atomic_val_t<_ITp> __i2,\n \t\t\t\t\t  memory_order __m1,\n \t\t\t\t\t  memory_order __m2) noexcept\n     { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }\n \n   template<typename _ITp>\n     inline bool\n     atomic_compare_exchange_weak_explicit(volatile atomic<_ITp>* __a,\n-\t\t\t\t\t  _ITp* __i1, _ITp __i2,\n+\t\t\t\t\t  __atomic_val_t<_ITp>* __i1,\n+\t\t\t\t\t  __atomic_val_t<_ITp> __i2,\n \t\t\t\t\t  memory_order __m1,\n \t\t\t\t\t  memory_order __m2) noexcept\n     { return __a->compare_exchange_weak(*__i1, __i2, __m1, __m2); }\n \n   template<typename _ITp>\n     inline bool\n     atomic_compare_exchange_strong_explicit(atomic<_ITp>* __a,\n-\t\t\t\t\t    _ITp* __i1, _ITp __i2,\n+\t\t\t\t\t    __atomic_val_t<_ITp>* __i1,\n+\t\t\t\t\t    __atomic_val_t<_ITp> __i2,\n \t\t\t\t\t    memory_order __m1,\n \t\t\t\t\t    memory_order __m2) noexcept\n     { return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2); }\n \n   template<typename _ITp>\n     inline bool\n     atomic_compare_exchange_strong_explicit(volatile atomic<_ITp>* __a,\n-\t\t\t\t\t    _ITp* __i1, _ITp __i2,\n+\t\t\t\t\t    __atomic_val_t<_ITp>* __i1,\n+\t\t\t\t\t    __atomic_val_t<_ITp> __i2,\n \t\t\t\t\t    memory_order __m1,\n \t\t\t\t\t    memory_order __m2) noexcept\n     { return __a->compare_exchange_strong(*__i1, __i2, __m1, __m2); }\n \n \n   template<typename _ITp>\n     inline void\n-    atomic_store(atomic<_ITp>* __a, _ITp __i) noexcept\n+    atomic_store(atomic<_ITp>* __a, __atomic_val_t<_ITp> __i) noexcept\n     { atomic_store_explicit(__a, __i, memory_order_seq_cst); }\n \n   template<typename _ITp>\n     inline void\n-    atomic_store(volatile atomic<_ITp>* __a, _ITp __i) noexcept\n+    atomic_store(volatile atomic<_ITp>* __a, __atomic_val_t<_ITp> __i) noexcept\n     { atomic_store_explicit(__a, __i, memory_order_seq_cst); }\n \n   template<typename _ITp>\n@@ -1157,18 +1255,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_exchange(atomic<_ITp>* __a, _ITp __i) noexcept\n+    atomic_exchange(atomic<_ITp>* __a, __atomic_val_t<_ITp> __i) noexcept\n     { return atomic_exchange_explicit(__a, __i, memory_order_seq_cst); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_exchange(volatile atomic<_ITp>* __a, _ITp __i) noexcept\n+    atomic_exchange(volatile atomic<_ITp>* __a,\n+\t\t    __atomic_val_t<_ITp> __i) noexcept\n     { return atomic_exchange_explicit(__a, __i, memory_order_seq_cst); }\n \n   template<typename _ITp>\n     inline bool\n     atomic_compare_exchange_weak(atomic<_ITp>* __a,\n-\t\t\t\t _ITp* __i1, _ITp __i2) noexcept\n+\t\t\t\t __atomic_val_t<_ITp>* __i1,\n+\t\t\t\t __atomic_val_t<_ITp> __i2) noexcept\n     {\n       return atomic_compare_exchange_weak_explicit(__a, __i1, __i2,\n \t\t\t\t\t\t   memory_order_seq_cst,\n@@ -1178,7 +1278,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _ITp>\n     inline bool\n     atomic_compare_exchange_weak(volatile atomic<_ITp>* __a,\n-\t\t\t\t _ITp* __i1, _ITp __i2) noexcept\n+\t\t\t\t __atomic_val_t<_ITp>* __i1,\n+\t\t\t\t __atomic_val_t<_ITp> __i2) noexcept\n     {\n       return atomic_compare_exchange_weak_explicit(__a, __i1, __i2,\n \t\t\t\t\t\t   memory_order_seq_cst,\n@@ -1188,7 +1289,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _ITp>\n     inline bool\n     atomic_compare_exchange_strong(atomic<_ITp>* __a,\n-\t\t\t\t   _ITp* __i1, _ITp __i2) noexcept\n+\t\t\t\t   __atomic_val_t<_ITp>* __i1,\n+\t\t\t\t   __atomic_val_t<_ITp> __i2) noexcept\n     {\n       return atomic_compare_exchange_strong_explicit(__a, __i1, __i2,\n \t\t\t\t\t\t     memory_order_seq_cst,\n@@ -1198,172 +1300,148 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _ITp>\n     inline bool\n     atomic_compare_exchange_strong(volatile atomic<_ITp>* __a,\n-\t\t\t\t   _ITp* __i1, _ITp __i2) noexcept\n+\t\t\t\t   __atomic_val_t<_ITp>* __i1,\n+\t\t\t\t   __atomic_val_t<_ITp> __i2) noexcept\n     {\n       return atomic_compare_exchange_strong_explicit(__a, __i1, __i2,\n \t\t\t\t\t\t     memory_order_seq_cst,\n \t\t\t\t\t\t     memory_order_seq_cst);\n     }\n \n-  // Function templates for atomic_integral operations only, using\n-  // __atomic_base. Template argument should be constricted to\n-  // intergral types as specified in the standard, excluding address\n-  // types.\n+  // Function templates for atomic_integral and atomic_pointer operations only.\n+  // Some operations (and, or, xor) are only available for atomic integrals,\n+  // which is implemented by taking a parameter of type __atomic_base<_ITp>*.\n+\n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_add_explicit(__atomic_base<_ITp>* __a, _ITp __i,\n+    atomic_fetch_add_explicit(atomic<_ITp>* __a,\n+\t\t\t      __atomic_diff_t<_ITp> __i,\n \t\t\t      memory_order __m) noexcept\n     { return __a->fetch_add(__i, __m); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_add_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,\n+    atomic_fetch_add_explicit(volatile atomic<_ITp>* __a,\n+\t\t\t      __atomic_diff_t<_ITp> __i,\n \t\t\t      memory_order __m) noexcept\n     { return __a->fetch_add(__i, __m); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_sub_explicit(__atomic_base<_ITp>* __a, _ITp __i,\n+    atomic_fetch_sub_explicit(atomic<_ITp>* __a,\n+\t\t\t      __atomic_diff_t<_ITp> __i,\n \t\t\t      memory_order __m) noexcept\n     { return __a->fetch_sub(__i, __m); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_sub_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,\n+    atomic_fetch_sub_explicit(volatile atomic<_ITp>* __a,\n+\t\t\t      __atomic_diff_t<_ITp> __i,\n \t\t\t      memory_order __m) noexcept\n     { return __a->fetch_sub(__i, __m); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_and_explicit(__atomic_base<_ITp>* __a, _ITp __i,\n+    atomic_fetch_and_explicit(__atomic_base<_ITp>* __a,\n+\t\t\t      __atomic_val_t<_ITp> __i,\n \t\t\t      memory_order __m) noexcept\n     { return __a->fetch_and(__i, __m); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_and_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,\n+    atomic_fetch_and_explicit(volatile __atomic_base<_ITp>* __a,\n+\t\t\t      __atomic_val_t<_ITp> __i,\n \t\t\t      memory_order __m) noexcept\n     { return __a->fetch_and(__i, __m); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_or_explicit(__atomic_base<_ITp>* __a, _ITp __i,\n+    atomic_fetch_or_explicit(__atomic_base<_ITp>* __a,\n+\t\t\t     __atomic_val_t<_ITp> __i,\n \t\t\t     memory_order __m) noexcept\n     { return __a->fetch_or(__i, __m); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_or_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,\n+    atomic_fetch_or_explicit(volatile __atomic_base<_ITp>* __a,\n+\t\t\t     __atomic_val_t<_ITp> __i,\n \t\t\t     memory_order __m) noexcept\n     { return __a->fetch_or(__i, __m); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_xor_explicit(__atomic_base<_ITp>* __a, _ITp __i,\n+    atomic_fetch_xor_explicit(__atomic_base<_ITp>* __a,\n+\t\t\t      __atomic_val_t<_ITp> __i,\n \t\t\t      memory_order __m) noexcept\n     { return __a->fetch_xor(__i, __m); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_xor_explicit(volatile __atomic_base<_ITp>* __a, _ITp __i,\n+    atomic_fetch_xor_explicit(volatile __atomic_base<_ITp>* __a,\n+\t\t\t      __atomic_val_t<_ITp> __i,\n \t\t\t      memory_order __m) noexcept\n     { return __a->fetch_xor(__i, __m); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_add(__atomic_base<_ITp>* __a, _ITp __i) noexcept\n+    atomic_fetch_add(atomic<_ITp>* __a,\n+\t\t     __atomic_diff_t<_ITp> __i) noexcept\n     { return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_add(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept\n+    atomic_fetch_add(volatile atomic<_ITp>* __a,\n+\t\t     __atomic_diff_t<_ITp> __i) noexcept\n     { return atomic_fetch_add_explicit(__a, __i, memory_order_seq_cst); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_sub(__atomic_base<_ITp>* __a, _ITp __i) noexcept\n+    atomic_fetch_sub(atomic<_ITp>* __a,\n+\t\t     __atomic_diff_t<_ITp> __i) noexcept\n     { return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_sub(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept\n+    atomic_fetch_sub(volatile atomic<_ITp>* __a,\n+\t\t     __atomic_diff_t<_ITp> __i) noexcept\n     { return atomic_fetch_sub_explicit(__a, __i, memory_order_seq_cst); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_and(__atomic_base<_ITp>* __a, _ITp __i) noexcept\n+    atomic_fetch_and(__atomic_base<_ITp>* __a,\n+\t\t     __atomic_val_t<_ITp> __i) noexcept\n     { return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_and(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept\n+    atomic_fetch_and(volatile __atomic_base<_ITp>* __a,\n+\t\t     __atomic_val_t<_ITp> __i) noexcept\n     { return atomic_fetch_and_explicit(__a, __i, memory_order_seq_cst); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_or(__atomic_base<_ITp>* __a, _ITp __i) noexcept\n+    atomic_fetch_or(__atomic_base<_ITp>* __a,\n+\t\t    __atomic_val_t<_ITp> __i) noexcept\n     { return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_or(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept\n+    atomic_fetch_or(volatile __atomic_base<_ITp>* __a,\n+\t\t    __atomic_val_t<_ITp> __i) noexcept\n     { return atomic_fetch_or_explicit(__a, __i, memory_order_seq_cst); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_xor(__atomic_base<_ITp>* __a, _ITp __i) noexcept\n+    atomic_fetch_xor(__atomic_base<_ITp>* __a,\n+\t\t     __atomic_val_t<_ITp> __i) noexcept\n     { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }\n \n   template<typename _ITp>\n     inline _ITp\n-    atomic_fetch_xor(volatile __atomic_base<_ITp>* __a, _ITp __i) noexcept\n+    atomic_fetch_xor(volatile __atomic_base<_ITp>* __a,\n+\t\t     __atomic_val_t<_ITp> __i) noexcept\n     { return atomic_fetch_xor_explicit(__a, __i, memory_order_seq_cst); }\n \n-\n-  // Partial specializations for pointers.\n-  template<typename _ITp>\n-    inline _ITp*\n-    atomic_fetch_add_explicit(atomic<_ITp*>* __a, ptrdiff_t __d,\n-\t\t\t      memory_order __m) noexcept\n-    { return __a->fetch_add(__d, __m); }\n-\n-  template<typename _ITp>\n-    inline _ITp*\n-    atomic_fetch_add_explicit(volatile atomic<_ITp*>* __a, ptrdiff_t __d,\n-\t\t\t      memory_order __m) noexcept\n-    { return __a->fetch_add(__d, __m); }\n-\n-  template<typename _ITp>\n-    inline _ITp*\n-    atomic_fetch_add(volatile atomic<_ITp*>* __a, ptrdiff_t __d) noexcept\n-    { return __a->fetch_add(__d); }\n-\n-  template<typename _ITp>\n-    inline _ITp*\n-    atomic_fetch_add(atomic<_ITp*>* __a, ptrdiff_t __d) noexcept\n-    { return __a->fetch_add(__d); }\n-\n-  template<typename _ITp>\n-    inline _ITp*\n-    atomic_fetch_sub_explicit(volatile atomic<_ITp*>* __a,\n-\t\t\t      ptrdiff_t __d, memory_order __m) noexcept\n-    { return __a->fetch_sub(__d, __m); }\n-\n-  template<typename _ITp>\n-    inline _ITp*\n-    atomic_fetch_sub_explicit(atomic<_ITp*>* __a, ptrdiff_t __d,\n-\t\t\t      memory_order __m) noexcept\n-    { return __a->fetch_sub(__d, __m); }\n-\n-  template<typename _ITp>\n-    inline _ITp*\n-    atomic_fetch_sub(volatile atomic<_ITp*>* __a, ptrdiff_t __d) noexcept\n-    { return __a->fetch_sub(__d); }\n-\n-  template<typename _ITp>\n-    inline _ITp*\n-    atomic_fetch_sub(atomic<_ITp*>* __a, ptrdiff_t __d) noexcept\n-    { return __a->fetch_sub(__d); }\n   // @} group atomics\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "cf2dfb2d28c3c843eba8cddb10ad607e368deed4", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/60695.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2F60695.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2F60695.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2F60695.cc?ref=25999a112f1567a841dafb22020eca17c3406f25", "patch": "@@ -27,4 +27,4 @@ struct X {\n   char stuff[0]; // GNU extension, type has zero size\n };\n \n-std::atomic<X> a;  // { dg-error \"not supported\" \"\" { target *-*-* } 190 }\n+std::atomic<X> a;  // { dg-error \"not supported\" \"\" { target *-*-* } 194 }"}, {"sha": "38fc49d0f25140c6952e06fbadf263f3cf808759", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/69769.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2F69769.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2F69769.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2F69769.cc?ref=25999a112f1567a841dafb22020eca17c3406f25", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++17 } }\n+// { dg-require-atomic-builtins \"\" }\n+\n+#include <atomic>\n+\n+void\n+test01()\n+{\n+  std::atomic<void*> p;\n+  p.fetch_add(1); // { dg-error \"from here\" }\n+  p.fetch_sub(1); // { dg-error \"from here\" }\n+  p += 1;\t  // { dg-error \"from here\" }\n+  p -= 1;\t  // { dg-error \"from here\" }\n+  ++p;\t\t  // { dg-error \"from here\" }\n+  p++;\t\t  // { dg-error \"from here\" }\n+  --p;\t\t  // { dg-error \"from here\" }\n+  p--;\t\t  // { dg-error \"from here\" }\n+}\n+\n+void\n+test02()\n+{\n+  std::atomic<void(*)()> p;\n+  p.fetch_add(1); // { dg-error \"from here\" }\n+  p.fetch_sub(1); // { dg-error \"from here\" }\n+  p += 1;\t  // { dg-error \"from here\" }\n+  p -= 1;\t  // { dg-error \"from here\" }\n+  ++p;\t\t  // { dg-error \"from here\" }\n+  p++;\t\t  // { dg-error \"from here\" }\n+  --p;\t\t  // { dg-error \"from here\" }\n+  p--;\t\t  // { dg-error \"from here\" }\n+}\n+\n+void\n+test03()\n+{\n+  volatile std::atomic<void*> p;\n+  p.fetch_add(1); // { dg-error \"from here\" }\n+  p.fetch_sub(1); // { dg-error \"from here\" }\n+  p += 1;\t  // { dg-error \"from here\" }\n+  p -= 1;\t  // { dg-error \"from here\" }\n+  ++p;\t\t  // { dg-error \"from here\" }\n+  p++;\t\t  // { dg-error \"from here\" }\n+  --p;\t\t  // { dg-error \"from here\" }\n+  p--;\t\t  // { dg-error \"from here\" }\n+}\n+\n+void\n+test04()\n+{\n+  volatile std::atomic<void(*)()> p;\n+  p.fetch_add(1); // { dg-error \"from here\" }\n+  p.fetch_sub(1); // { dg-error \"from here\" }\n+  p += 1;\t  // { dg-error \"from here\" }\n+  p -= 1;\t  // { dg-error \"from here\" }\n+  ++p;\t\t  // { dg-error \"from here\" }\n+  p++;\t\t  // { dg-error \"from here\" }\n+  --p;\t\t  // { dg-error \"from here\" }\n+  p--;\t\t  // { dg-error \"from here\" }\n+}\n+\n+// { dg-prune-output \"static assertion failed\" }"}, {"sha": "886ad7be8638158c0242a717a8f91094cc97f16c", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/nonmembers.cc", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fnonmembers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fnonmembers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Fnonmembers.cc?ref=25999a112f1567a841dafb22020eca17c3406f25", "patch": "@@ -0,0 +1,230 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++11 } }\n+// { dg-require-atomic-builtins \"\" }\n+\n+#include <atomic>\n+\n+void\n+test01()\n+{\n+  struct X { };\n+  struct Y { };\n+  // Primary template\n+  volatile std::atomic<X> v;\n+  std::atomic<Y> a;\n+  const std::memory_order mo = std::memory_order_seq_cst;\n+  X x;\n+  Y y;\n+  auto r1 = atomic_is_lock_free(&v);\n+  static_assert( std::is_same<decltype(r1), bool>::value, \"\" );\n+  auto r2 = atomic_is_lock_free(&a);\n+  static_assert( std::is_same<decltype(r2), bool>::value, \"\" );\n+  atomic_init(&v, x);\n+  atomic_init(&a, y);\n+  atomic_store(&v, x);\n+  atomic_store(&a, y);\n+  atomic_store_explicit(&v, x, mo);\n+  atomic_store_explicit(&a, y, mo);\n+  auto r3 = atomic_load(&v);\n+  static_assert( std::is_same<decltype(r3), X>::value, \"\" );\n+  auto r4 = atomic_load(&a);\n+  static_assert( std::is_same<decltype(r4), Y>::value, \"\" );\n+  auto r5 = atomic_load_explicit(&v, mo);\n+  static_assert( std::is_same<decltype(r5), X>::value, \"\" );\n+  auto r6 = atomic_load_explicit(&a, mo);\n+  static_assert( std::is_same<decltype(r6), Y>::value, \"\" );\n+  auto r7 = atomic_exchange(&v, x);\n+  static_assert( std::is_same<decltype(r7), X>::value, \"\" );\n+  auto r8 = atomic_exchange(&a, y);\n+  static_assert( std::is_same<decltype(r8), Y>::value, \"\" );\n+  auto r9 = atomic_exchange_explicit(&v, x, mo);\n+  static_assert( std::is_same<decltype(r9), X>::value, \"\" );\n+  auto r10 = atomic_exchange_explicit(&a, y, mo);\n+  static_assert( std::is_same<decltype(r10), Y>::value, \"\" );\n+  auto r11 = atomic_compare_exchange_weak(&v, &x, x);\n+  static_assert( std::is_same<decltype(r11), bool>::value, \"\" );\n+  auto r12 = atomic_compare_exchange_weak(&a, &y, y);\n+  static_assert( std::is_same<decltype(r12), bool>::value, \"\" );\n+  auto r13 = atomic_compare_exchange_strong(&v, &x, x);\n+  static_assert( std::is_same<decltype(r13), bool>::value, \"\" );\n+  auto r14 = atomic_compare_exchange_strong(&a, &y, y);\n+  static_assert( std::is_same<decltype(r14), bool>::value, \"\" );\n+  auto r15 = atomic_compare_exchange_weak_explicit(&v, &x, x, mo, mo);\n+  static_assert( std::is_same<decltype(r15), bool>::value, \"\" );\n+  auto r16 = atomic_compare_exchange_weak_explicit(&a, &y, y, mo, mo);\n+  static_assert( std::is_same<decltype(r16), bool>::value, \"\" );\n+  auto r17 = atomic_compare_exchange_strong_explicit(&v, &x, x, mo, mo);\n+  static_assert( std::is_same<decltype(r17), bool>::value, \"\" );\n+  auto r18 = atomic_compare_exchange_strong_explicit(&a, &y, y, mo, mo);\n+  static_assert( std::is_same<decltype(r18), bool>::value, \"\" );\n+}\n+\n+void\n+test02()\n+{\n+  // Specialization for bool\n+  volatile std::atomic<bool> v;\n+  std::atomic<bool> a;\n+  const std::memory_order mo = std::memory_order_seq_cst;\n+  bool b = false;\n+  auto r1 = atomic_is_lock_free(&v);\n+  static_assert( std::is_same<decltype(r1), bool>::value, \"\" );\n+  auto r2 = atomic_is_lock_free(&a);\n+  static_assert( std::is_same<decltype(r2), bool>::value, \"\" );\n+  atomic_init(&v, b);\n+  atomic_init(&a, b);\n+  atomic_store(&v, b);\n+  atomic_store(&a, b);\n+  atomic_store_explicit(&v, b, mo);\n+  atomic_store_explicit(&a, b, mo);\n+  auto r3 = atomic_load(&v);\n+  static_assert( std::is_same<decltype(r3), bool>::value, \"\" );\n+  auto r4 = atomic_load(&a);\n+  static_assert( std::is_same<decltype(r4), bool>::value, \"\" );\n+  auto r5 = atomic_load_explicit(&v, mo);\n+  static_assert( std::is_same<decltype(r5), bool>::value, \"\" );\n+  auto r6 = atomic_load_explicit(&a, mo);\n+  static_assert( std::is_same<decltype(r6), bool>::value, \"\" );\n+  auto r7 = atomic_exchange(&v, b);\n+  static_assert( std::is_same<decltype(r7), bool>::value, \"\" );\n+  auto r8 = atomic_exchange(&a, b);\n+  static_assert( std::is_same<decltype(r8), bool>::value, \"\" );\n+  auto r9 = atomic_exchange_explicit(&v, b, mo);\n+  static_assert( std::is_same<decltype(r9), bool>::value, \"\" );\n+  auto r10 = atomic_exchange_explicit(&a, b, mo);\n+  static_assert( std::is_same<decltype(r10), bool>::value, \"\" );\n+  auto r11 = atomic_compare_exchange_weak(&v, &b, b);\n+  static_assert( std::is_same<decltype(r11), bool>::value, \"\" );\n+  auto r12 = atomic_compare_exchange_weak(&a, &b, b);\n+  static_assert( std::is_same<decltype(r12), bool>::value, \"\" );\n+  auto r13 = atomic_compare_exchange_strong(&v, &b, b);\n+  static_assert( std::is_same<decltype(r13), bool>::value, \"\" );\n+  auto r14 = atomic_compare_exchange_strong(&a, &b, b);\n+  static_assert( std::is_same<decltype(r14), bool>::value, \"\" );\n+  auto r15 = atomic_compare_exchange_weak_explicit(&v, &b, b, mo, mo);\n+  static_assert( std::is_same<decltype(r15), bool>::value, \"\" );\n+  auto r16 = atomic_compare_exchange_weak_explicit(&a, &b, b, mo, mo);\n+  static_assert( std::is_same<decltype(r16), bool>::value, \"\" );\n+  auto r17 = atomic_compare_exchange_strong_explicit(&v, &b, b, mo, mo);\n+  static_assert( std::is_same<decltype(r17), bool>::value, \"\" );\n+  auto r18 = atomic_compare_exchange_strong_explicit(&a, &b, b, mo, mo);\n+  static_assert( std::is_same<decltype(r18), bool>::value, \"\" );\n+}\n+\n+void\n+test03()\n+{\n+  // Partial specialization for pointers\n+  volatile std::atomic<int*> v;\n+  std::atomic<long*> a;\n+  const std::memory_order mo = std::memory_order_seq_cst;\n+  int* i = nullptr;\n+  long* l = nullptr;\n+  auto r1 = atomic_is_lock_free(&v);\n+  static_assert( std::is_same<decltype(r1), bool>::value, \"\" );\n+  auto r2 = atomic_is_lock_free(&a);\n+  static_assert( std::is_same<decltype(r2), bool>::value, \"\" );\n+  atomic_init(&v, i);\n+  atomic_init(&a, l);\n+  atomic_store(&v, i);\n+  atomic_store(&a, l);\n+  atomic_store_explicit(&v, i, mo);\n+  atomic_store_explicit(&a, l, mo);\n+  auto r3 = atomic_load(&v);\n+  static_assert( std::is_same<decltype(r3), int*>::value, \"\" );\n+  auto r4 = atomic_load(&a);\n+  static_assert( std::is_same<decltype(r4), long*>::value, \"\" );\n+  auto r5 = atomic_load_explicit(&v, mo);\n+  static_assert( std::is_same<decltype(r5), int*>::value, \"\" );\n+  auto r6 = atomic_load_explicit(&a, mo);\n+  static_assert( std::is_same<decltype(r6), long*>::value, \"\" );\n+  auto r7 = atomic_exchange(&v, i);\n+  static_assert( std::is_same<decltype(r7), int*>::value, \"\" );\n+  auto r8 = atomic_exchange(&a, l);\n+  static_assert( std::is_same<decltype(r8), long*>::value, \"\" );\n+  auto r9 = atomic_exchange_explicit(&v, i, mo);\n+  static_assert( std::is_same<decltype(r9), int*>::value, \"\" );\n+  auto r10 = atomic_exchange_explicit(&a, l, mo);\n+  static_assert( std::is_same<decltype(r10), long*>::value, \"\" );\n+  auto r11 = atomic_compare_exchange_weak(&v, &i, i);\n+  static_assert( std::is_same<decltype(r11), bool>::value, \"\" );\n+  auto r12 = atomic_compare_exchange_weak(&a, &l, l);\n+  static_assert( std::is_same<decltype(r12), bool>::value, \"\" );\n+  auto r13 = atomic_compare_exchange_strong(&v, &i, i);\n+  static_assert( std::is_same<decltype(r13), bool>::value, \"\" );\n+  auto r14 = atomic_compare_exchange_strong(&a, &l, l);\n+  static_assert( std::is_same<decltype(r14), bool>::value, \"\" );\n+  auto r15 = atomic_compare_exchange_weak_explicit(&v, &i, i, mo, mo);\n+  static_assert( std::is_same<decltype(r15), bool>::value, \"\" );\n+  auto r16 = atomic_compare_exchange_weak_explicit(&a, &l, l, mo, mo);\n+  static_assert( std::is_same<decltype(r16), bool>::value, \"\" );\n+  auto r17 = atomic_compare_exchange_strong_explicit(&v, &i, i, mo, mo);\n+  static_assert( std::is_same<decltype(r17), bool>::value, \"\" );\n+  auto r18 = atomic_compare_exchange_strong_explicit(&a, &l, l, mo, mo);\n+  static_assert( std::is_same<decltype(r18), bool>::value, \"\" );\n+\n+  auto r19 = atomic_fetch_add(&v, 1);\n+  static_assert( std::is_same<decltype(r19), int*>::value, \"\" );\n+  auto r20 = atomic_fetch_add(&a, 1);\n+  static_assert( std::is_same<decltype(r20), long*>::value, \"\" );\n+  auto r21 = atomic_fetch_add_explicit(&v, 1, mo);\n+  static_assert( std::is_same<decltype(r21), int*>::value, \"\" );\n+  auto r22 = atomic_fetch_add_explicit(&a, 1, mo);\n+  static_assert( std::is_same<decltype(r22), long*>::value, \"\" );\n+  auto r23 = atomic_fetch_sub(&v, 1);\n+  static_assert( std::is_same<decltype(r23), int*>::value, \"\" );\n+  auto r24 = atomic_fetch_sub(&a, 1);\n+  static_assert( std::is_same<decltype(r24), long*>::value, \"\" );\n+  auto r25 = atomic_fetch_sub_explicit(&v, 1, mo);\n+  static_assert( std::is_same<decltype(r25), int*>::value, \"\" );\n+  auto r26 = atomic_fetch_sub_explicit(&a, 1, mo);\n+  static_assert( std::is_same<decltype(r26), long*>::value, \"\" );\n+}\n+\n+void\n+test04()\n+{\n+  struct base { };\n+  struct derived : base { };\n+  // Partial specialization for pointers\n+  volatile std::atomic<base*> v;\n+  std::atomic<base*> a;\n+  const std::memory_order mo = std::memory_order_seq_cst;\n+  // Repeat tests with arguments of type different to value_type.\n+  derived* const p = nullptr;\n+  base* b = nullptr;\n+  atomic_init(&v, p);\n+  atomic_init(&a, p);\n+  atomic_store(&v, p);\n+  atomic_store(&a, p);\n+  atomic_store_explicit(&v, p, mo);\n+  atomic_store_explicit(&a, p, mo);\n+  atomic_exchange(&v, p);\n+  atomic_exchange(&a, p);\n+  atomic_exchange_explicit(&v, p, mo);\n+  atomic_exchange_explicit(&a, p, mo);\n+  atomic_compare_exchange_weak(&v, &b, p);\n+  atomic_compare_exchange_weak(&a, &b, p);\n+  atomic_compare_exchange_strong(&v, &b, p);\n+  atomic_compare_exchange_strong(&a, &b, p);\n+  atomic_compare_exchange_weak_explicit(&v, &b, p, mo, mo);\n+  atomic_compare_exchange_weak_explicit(&a, &b, p, mo, mo);\n+  atomic_compare_exchange_strong_explicit(&v, &b, p, mo, mo);\n+  atomic_compare_exchange_strong_explicit(&a, &b, p, mo, mo);\n+}"}, {"sha": "f4668b3e259e03ee972edb1f7fd270d4d97b6a49", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/operators/pointer_partial_void.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Foperators%2Fpointer_partial_void.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Foperators%2Fpointer_partial_void.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Foperators%2Fpointer_partial_void.cc?ref=25999a112f1567a841dafb22020eca17c3406f25", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run { target c++11 } }\n+// { dg-do run { target { c++11_only || c++14_only } } }\n // { dg-require-atomic-builtins \"\" }\n \n // Copyright (C) 2012-2018 Free Software Foundation, Inc."}, {"sha": "96d263e8fbfcfd34534cf5332836544ed36b68aa", "filename": "libstdc++-v3/testsuite/29_atomics/atomic/requirements/typedefs.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic%2Frequirements%2Ftypedefs.cc?ref=25999a112f1567a841dafb22020eca17c3406f25", "patch": "@@ -0,0 +1,36 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++17 } }\n+// { dg-require-atomic-builtins \"\" }\n+\n+#include <atomic>\n+\n+template<typename T>\n+constexpr bool check()\n+{\n+  typename std::atomic<T>::value_type* pv = (T*)nullptr;\n+  typename std::atomic<T>::difference_type* pd = (std::ptrdiff_t*)nullptr;\n+  return true;\n+}\n+\n+static_assert( check<int*>(), \"\" );\n+static_assert( check<void*>(), \"\" );\n+static_assert( check<void(*)()>(), \"\" );\n+struct X { };\n+static_assert( check<X*>(), \"\" );"}, {"sha": "96a234d620a9446e0c1e480c19cb1c94cfd6cef7", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/nonmembers.cc", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fnonmembers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fnonmembers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Fnonmembers.cc?ref=25999a112f1567a841dafb22020eca17c3406f25", "patch": "@@ -0,0 +1,163 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile { target c++11 } }\n+// { dg-require-atomic-builtins \"\" }\n+\n+#include <atomic>\n+\n+void\n+test01()\n+{\n+  volatile std::atomic<int> v;\n+  std::atomic<long> a;\n+  const std::memory_order mo = std::memory_order_seq_cst;\n+  int i = 0;\n+  long l = 0;\n+  auto r1 = atomic_is_lock_free(&v);\n+  static_assert( std::is_same<decltype(r1), bool>::value, \"\" );\n+  auto r2 = atomic_is_lock_free(&a);\n+  static_assert( std::is_same<decltype(r2), bool>::value, \"\" );\n+  atomic_init(&v, i);\n+  atomic_init(&a, l);\n+  atomic_store(&v, i);\n+  atomic_store(&a, l);\n+  atomic_store_explicit(&v, i, mo);\n+  atomic_store_explicit(&a, l, mo);\n+  auto r3 = atomic_load(&v);\n+  static_assert( std::is_same<decltype(r3), int>::value, \"\" );\n+  auto r4 = atomic_load(&a);\n+  static_assert( std::is_same<decltype(r4), long>::value, \"\" );\n+  auto r5 = atomic_load_explicit(&v, mo);\n+  static_assert( std::is_same<decltype(r5), int>::value, \"\" );\n+  auto r6 = atomic_load_explicit(&a, mo);\n+  static_assert( std::is_same<decltype(r6), long>::value, \"\" );\n+  auto r7 = atomic_exchange(&v, i);\n+  static_assert( std::is_same<decltype(r7), int>::value, \"\" );\n+  auto r8 = atomic_exchange(&a, l);\n+  static_assert( std::is_same<decltype(r8), long>::value, \"\" );\n+  auto r9 = atomic_exchange_explicit(&v, i, mo);\n+  static_assert( std::is_same<decltype(r9), int>::value, \"\" );\n+  auto r10 = atomic_exchange_explicit(&a, l, mo);\n+  static_assert( std::is_same<decltype(r10), long>::value, \"\" );\n+  auto r11 = atomic_compare_exchange_weak(&v, &i, i);\n+  static_assert( std::is_same<decltype(r11), bool>::value, \"\" );\n+  auto r12 = atomic_compare_exchange_weak(&a, &l, l);\n+  static_assert( std::is_same<decltype(r12), bool>::value, \"\" );\n+  auto r13 = atomic_compare_exchange_strong(&v, &i, i);\n+  static_assert( std::is_same<decltype(r13), bool>::value, \"\" );\n+  auto r14 = atomic_compare_exchange_strong(&a, &l, l);\n+  static_assert( std::is_same<decltype(r14), bool>::value, \"\" );\n+  auto r15 = atomic_compare_exchange_weak_explicit(&v, &i, i, mo, mo);\n+  static_assert( std::is_same<decltype(r15), bool>::value, \"\" );\n+  auto r16 = atomic_compare_exchange_weak_explicit(&a, &l, l, mo, mo);\n+  static_assert( std::is_same<decltype(r16), bool>::value, \"\" );\n+  auto r17 = atomic_compare_exchange_strong_explicit(&v, &i, i, mo, mo);\n+  static_assert( std::is_same<decltype(r17), bool>::value, \"\" );\n+  auto r18 = atomic_compare_exchange_strong_explicit(&a, &l, l, mo, mo);\n+  static_assert( std::is_same<decltype(r18), bool>::value, \"\" );\n+\n+  auto r19 = atomic_fetch_add(&v, i);\n+  static_assert( std::is_same<decltype(r19), int>::value, \"\" );\n+  auto r20 = atomic_fetch_add(&a, l);\n+  static_assert( std::is_same<decltype(r20), long>::value, \"\" );\n+  auto r21 = atomic_fetch_add_explicit(&v, i, mo);\n+  static_assert( std::is_same<decltype(r21), int>::value, \"\" );\n+  auto r22 = atomic_fetch_add_explicit(&a, l, mo);\n+  static_assert( std::is_same<decltype(r22), long>::value, \"\" );\n+  auto r23 = atomic_fetch_sub(&v, i);\n+  static_assert( std::is_same<decltype(r23), int>::value, \"\" );\n+  auto r24 = atomic_fetch_sub(&a, l);\n+  static_assert( std::is_same<decltype(r24), long>::value, \"\" );\n+  auto r25 = atomic_fetch_sub_explicit(&v, i, mo);\n+  static_assert( std::is_same<decltype(r25), int>::value, \"\" );\n+  auto r26 = atomic_fetch_sub_explicit(&a, l, mo);\n+  static_assert( std::is_same<decltype(r26), long>::value, \"\" );\n+  auto r27 = atomic_fetch_and(&v, i);\n+  static_assert( std::is_same<decltype(r27), int>::value, \"\" );\n+  auto r28 = atomic_fetch_and(&a, l);\n+  static_assert( std::is_same<decltype(r28), long>::value, \"\" );\n+  auto r29 = atomic_fetch_and_explicit(&v, i, mo);\n+  static_assert( std::is_same<decltype(r29), int>::value, \"\" );\n+  auto r30 = atomic_fetch_and_explicit(&a, l, mo);\n+  static_assert( std::is_same<decltype(r30), long>::value, \"\" );\n+  auto r31 = atomic_fetch_or(&v, i);\n+  static_assert( std::is_same<decltype(r31), int>::value, \"\" );\n+  auto r32 = atomic_fetch_or(&a, l);\n+  static_assert( std::is_same<decltype(r32), long>::value, \"\" );\n+  auto r33 = atomic_fetch_or_explicit(&v, i, mo);\n+  static_assert( std::is_same<decltype(r33), int>::value, \"\" );\n+  auto r34 = atomic_fetch_or_explicit(&a, l, mo);\n+  static_assert( std::is_same<decltype(r34), long>::value, \"\" );\n+  auto r35 = atomic_fetch_xor(&v, i);\n+  static_assert( std::is_same<decltype(r35), int>::value, \"\" );\n+  auto r36 = atomic_fetch_xor(&a, l);\n+  static_assert( std::is_same<decltype(r36), long>::value, \"\" );\n+  auto r37 = atomic_fetch_xor_explicit(&v, i, mo);\n+  static_assert( std::is_same<decltype(r37), int>::value, \"\" );\n+  auto r38 = atomic_fetch_xor_explicit(&a, l, mo);\n+  static_assert( std::is_same<decltype(r38), long>::value, \"\" );\n+}\n+\n+void\n+test02()\n+{\n+  volatile std::atomic<long> v;\n+  std::atomic<long> a;\n+  std::memory_order mo = std::memory_order_seq_cst;\n+  // Repeat tests with arguments of type different to value_type.\n+  const int i = 0;\n+  long l = 0;\n+  atomic_init(&v, i);\n+  atomic_init(&a, i);\n+  atomic_store(&v, i);\n+  atomic_store(&a, i);\n+  atomic_store_explicit(&v, i, mo);\n+  atomic_store_explicit(&a, i, mo);\n+  atomic_exchange(&v, i);\n+  atomic_exchange(&a, i);\n+  atomic_exchange_explicit(&v, i, mo);\n+  atomic_exchange_explicit(&a, i, mo);\n+  atomic_compare_exchange_weak(&v, &l, i);\n+  atomic_compare_exchange_weak(&a, &l, i);\n+  atomic_compare_exchange_strong(&v, &l, i);\n+  atomic_compare_exchange_strong(&a, &l, i);\n+  atomic_compare_exchange_weak_explicit(&v, &l, i, mo, mo);\n+  atomic_compare_exchange_weak_explicit(&a, &l, i, mo, mo);\n+  atomic_compare_exchange_strong_explicit(&v, &l, i, mo, mo);\n+  atomic_compare_exchange_strong_explicit(&a, &l, i, mo, mo);\n+  atomic_fetch_add(&v, i);\n+  atomic_fetch_add(&a, i);\n+  atomic_fetch_add_explicit(&v, i, mo);\n+  atomic_fetch_add_explicit(&a, i, mo);\n+  atomic_fetch_sub(&v, i);\n+  atomic_fetch_sub(&a, i);\n+  atomic_fetch_sub_explicit(&v, i, mo);\n+  atomic_fetch_sub_explicit(&a, i, mo);\n+  atomic_fetch_and(&v, i);\n+  atomic_fetch_and(&a, i);\n+  atomic_fetch_and_explicit(&v, i, mo);\n+  atomic_fetch_and_explicit(&a, i, mo);\n+  atomic_fetch_or(&v, i);\n+  atomic_fetch_or(&a, i);\n+  atomic_fetch_or_explicit(&v, i, mo);\n+  atomic_fetch_or_explicit(&a, i, mo);\n+  atomic_fetch_xor(&v, i);\n+  atomic_fetch_xor(&a, i);\n+  atomic_fetch_xor_explicit(&v, i, mo);\n+  atomic_fetch_xor_explicit(&a, i, mo);\n+}"}, {"sha": "2cd2084470175f0e4fffc59619376605f490b9b5", "filename": "libstdc++-v3/testsuite/29_atomics/atomic_integral/requirements/typedefs.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25999a112f1567a841dafb22020eca17c3406f25/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fatomic_integral%2Frequirements%2Ftypedefs.cc?ref=25999a112f1567a841dafb22020eca17c3406f25", "patch": "@@ -0,0 +1,39 @@\n+// Copyright (C) 2017 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++17 } }\n+// { dg-require-atomic-builtins \"\" }\n+\n+#include <atomic>\n+\n+template<typename T>\n+constexpr bool check()\n+{\n+  typename std::atomic<T>::value_type* pv = (T*)nullptr;\n+  typename std::atomic<T>::difference_type* pd = (T*)nullptr;\n+  return true;\n+}\n+\n+static_assert( check<signed short>(), \"\" );\n+static_assert( check<unsigned short>(), \"\" );\n+static_assert( check<signed int>(), \"\" );\n+static_assert( check<unsigned int>(), \"\" );\n+static_assert( check<signed long>(), \"\" );\n+static_assert( check<unsigned long>(), \"\" );\n+static_assert( check<signed long long>(), \"\" );\n+static_assert( check<unsigned long long>(), \"\" );"}]}