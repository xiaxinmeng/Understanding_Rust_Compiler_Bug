{"sha": "03a9562184454fe5395e30b8a3429c4570979d86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNhOTU2MjE4NDQ1NGZlNTM5NWUzMGI4YTM0MjljNDU3MDk3OWQ4Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-22T16:14:48Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-22T16:14:48Z"}, "message": "Make more use of paradoxical_subreg_p\n\nThis patch makes more use of the existing paradoxical_subreg_p\npredicate and also adds a version that operates on outer and\ninner modes.\n\nSome of the affected tests were based on GET_MODE_SIZE rather than\nGET_MODE_PRECISION and so the patch could change the result for modes\nthat have the same size but different precisions.  I think in each\ncase the change should be a no-op or more correct, since a mode with\nprecision N bits can't be expected to hold all of a mode with precision\nM>N bits.\n\nThe patch changes the branch taken in simplify_subreg for modes with\nequal precision, but the new form matches the commentary more closely.\nBoth branches should be equally good in that situation.\n\n2017-08-22  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* rtl.h (paradoxical_subreg_p): Define inline, and add a version\n\tthat takes the outer and inner modes.\n\t* doc/rtl.texi: Use paradoxical_subreg_p instead of a GET_MODE_SIZE\n\tcomparison as the canonical test for a paradoxical subreg.\n\t* combine.c (simplify_set): Use paradoxical_subreg_p.\n\t(make_extraction): Likewise.\n\t(force_to_mode): Likewise.\n\t(rtx_equal_for_field_assignment_p): Likewise.\n\t(gen_lowpart_for_combine): Likewise.\n\t(simplify_comparison): Likewise.\n\t* cse.c (equiv_constant): Likewise.\n\t* expmed.c (store_bit_field_1): Likewise.\n\t* final.c (alter_subreg): Likewise.\n\t* fwprop.c (propagate_rtx): Likewise.\n\t(forward_propagate_subreg): Likewise.\n\t* ira-conflicts.c (ira_build_conflicts): Likewise.\n\t* lower-subreg.c (simplify_gen_subreg_concatn): Likewise.\n\t* lra-constraints.c (curr_insn_transform): Likewise.\n\t(split_reg): Likewise.\n\t* lra-eliminations.c (move_plus_up): Likewise.\n\t(lra_eliminate_regs_1): Likewise.\n\t* recog.c (general_operand): Likewise.\n\t* ree.c (combine_reaching_defs): Likewise.\n\t* reload.c (push_reload): Likewise.\n\t(find_reloads): Likewise.\n\t* reload1.c (elimination_effects): Likewise.\n\t(compute_reload_subreg_offset): Likewise.\n\t(choose_reload_regs): Likewise.\n\t* rtlanal.c (subreg_lsb_1): Likewise.\n\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n\t(simplify_subreg): Likewise.\n\t* var-tracking.c (track_loc_p): Likewise.\n\t* emit-rtl.c (byte_lowpart_offset): Likewise.\n\t(paradoxical_subreg_p): Delete out-of-line definition.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251282", "tree": {"sha": "a417b72b480511bd13f183270b1a546c38ba8235", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a417b72b480511bd13f183270b1a546c38ba8235"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03a9562184454fe5395e30b8a3429c4570979d86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03a9562184454fe5395e30b8a3429c4570979d86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03a9562184454fe5395e30b8a3429c4570979d86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03a9562184454fe5395e30b8a3429c4570979d86/comments", "author": null, "committer": null, "parents": [{"sha": "5b37159fcab6712970305bad6ecea7928b86ab63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b37159fcab6712970305bad6ecea7928b86ab63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b37159fcab6712970305bad6ecea7928b86ab63"}], "stats": {"total": 183, "additions": 105, "deletions": 78}, "files": [{"sha": "6153bd965167df06726c597f433701f66f5e6b33", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -1,3 +1,42 @@\n+2017-08-22  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* rtl.h (paradoxical_subreg_p): Define inline, and add a version\n+\tthat takes the outer and inner modes.\n+\t* doc/rtl.texi: Use paradoxical_subreg_p instead of a GET_MODE_SIZE\n+\tcomparison as the canonical test for a paradoxical subreg.\n+\t* combine.c (simplify_set): Use paradoxical_subreg_p.\n+\t(make_extraction): Likewise.\n+\t(force_to_mode): Likewise.\n+\t(rtx_equal_for_field_assignment_p): Likewise.\n+\t(gen_lowpart_for_combine): Likewise.\n+\t(simplify_comparison): Likewise.\n+\t* cse.c (equiv_constant): Likewise.\n+\t* expmed.c (store_bit_field_1): Likewise.\n+\t* final.c (alter_subreg): Likewise.\n+\t* fwprop.c (propagate_rtx): Likewise.\n+\t(forward_propagate_subreg): Likewise.\n+\t* ira-conflicts.c (ira_build_conflicts): Likewise.\n+\t* lower-subreg.c (simplify_gen_subreg_concatn): Likewise.\n+\t* lra-constraints.c (curr_insn_transform): Likewise.\n+\t(split_reg): Likewise.\n+\t* lra-eliminations.c (move_plus_up): Likewise.\n+\t(lra_eliminate_regs_1): Likewise.\n+\t* recog.c (general_operand): Likewise.\n+\t* ree.c (combine_reaching_defs): Likewise.\n+\t* reload.c (push_reload): Likewise.\n+\t(find_reloads): Likewise.\n+\t* reload1.c (elimination_effects): Likewise.\n+\t(compute_reload_subreg_offset): Likewise.\n+\t(choose_reload_regs): Likewise.\n+\t* rtlanal.c (subreg_lsb_1): Likewise.\n+\t* simplify-rtx.c (simplify_unary_operation_1): Likewise.\n+\t(simplify_subreg): Likewise.\n+\t* var-tracking.c (track_loc_p): Likewise.\n+\t* emit-rtl.c (byte_lowpart_offset): Likewise.\n+\t(paradoxical_subreg_p): Delete out-of-line definition.\n+\n 2017-08-22  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/81741"}, {"sha": "7aa0a359f489bc8d9ccb6227b852cfe90f20e98c", "filename": "gcc/combine.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -6809,9 +6809,7 @@ simplify_set (rtx x)\n \t   / UNITS_PER_WORD)\n \t  == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))\n \t       + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))\n-      && (WORD_REGISTER_OPERATIONS\n-\t  || (GET_MODE_SIZE (GET_MODE (src))\n-\t      <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))))\n+      && (WORD_REGISTER_OPERATIONS || !paradoxical_subreg_p (src))\n #ifdef CANNOT_CHANGE_MODE_CLASS\n       && ! (REG_P (dest) && REGNO (dest) < FIRST_PSEUDO_REGISTER\n \t    && REG_CANNOT_CHANGE_MODE_P (REGNO (dest),\n@@ -7456,7 +7454,7 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t\t     : BITS_PER_UNIT)) == 0\n \t      /* We can't do this if we are widening INNER_MODE (it\n \t\t may not be aligned, for one thing).  */\n-\t      && GET_MODE_PRECISION (inner_mode) >= GET_MODE_PRECISION (tmode)\n+\t      && !paradoxical_subreg_p (tmode, inner_mode)\n \t      && (inner_mode == tmode\n \t\t  || (! mode_dependent_address_p (XEXP (inner, 0),\n \t\t\t\t\t\t  MEM_ADDR_SPACE (inner))\n@@ -7669,7 +7667,7 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n       /* If bytes are big endian and we had a paradoxical SUBREG, we must\n \t adjust OFFSET to compensate.  */\n       if (BYTES_BIG_ENDIAN\n-\t  && GET_MODE_SIZE (inner_mode) < GET_MODE_SIZE (is_mode))\n+\t  && paradoxical_subreg_p (is_mode, inner_mode))\n \toffset -= GET_MODE_SIZE (is_mode) - GET_MODE_SIZE (inner_mode);\n \n       /* We can now move to the desired byte.  */\n@@ -8529,7 +8527,7 @@ force_to_mode (rtx x, machine_mode mode, unsigned HOST_WIDE_INT mask,\n \n   /* If X is narrower than MODE and we want all the bits in X's mode, just\n      get X in the proper mode.  */\n-  if (GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (mode)\n+  if (paradoxical_subreg_p (mode, GET_MODE (x))\n       && (GET_MODE_MASK (GET_MODE (x)) & ~mask) == 0)\n     return gen_lowpart (mode, x);\n \n@@ -9408,7 +9406,7 @@ rtx_equal_for_field_assignment_p (rtx x, rtx y, bool widen_x)\n {\n   if (widen_x && GET_MODE (x) != GET_MODE (y))\n     {\n-      if (GET_MODE_SIZE (GET_MODE (x)) > GET_MODE_SIZE (GET_MODE (y)))\n+      if (paradoxical_subreg_p (GET_MODE (x), GET_MODE (y)))\n \treturn 0;\n       if (BYTES_BIG_ENDIAN != WORDS_BIG_ENDIAN)\n \treturn 0;\n@@ -11488,7 +11486,7 @@ gen_lowpart_for_combine (machine_mode omode, rtx x)\n       /* If we want to refer to something bigger than the original memref,\n \t generate a paradoxical subreg instead.  That will force a reload\n \t of the original memref X.  */\n-      if (isize < osize)\n+      if (paradoxical_subreg_p (omode, imode))\n \treturn gen_rtx_SUBREG (omode, x, 0);\n \n       if (WORDS_BIG_ENDIAN)\n@@ -12145,8 +12143,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \n \t  /* If the inner mode is narrower and we are extracting the low part,\n \t     we can treat the SUBREG as if it were a ZERO_EXTEND.  */\n-\t  if (subreg_lowpart_p (op0)\n-\t      && GET_MODE_PRECISION (GET_MODE (SUBREG_REG (op0))) < mode_width)\n+\t  if (paradoxical_subreg_p (op0))\n \t    ;\n \t  else if (subreg_lowpart_p (op0)\n \t\t   && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT"}, {"sha": "dfcebbfbc02a18390243e60c3098da74a5556608", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -3802,7 +3802,7 @@ equiv_constant (rtx x)\n \t the subreg.  Note that the upper bits of paradoxical subregs\n \t are undefined, so they cannot be said to equal anything.  */\n       if (REG_P (SUBREG_REG (x))\n-\t  && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (imode)\n+\t  && !paradoxical_subreg_p (x)\n \t  && (new_rtx = equiv_constant (SUBREG_REG (x))) != 0)\n         return simplify_subreg (mode, new_rtx, imode, SUBREG_BYTE (x));\n "}, {"sha": "12355c2fbad72c9b3820ad90449372638b618487", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -1872,7 +1872,7 @@ expression is called @dfn{paradoxical}.  The canonical test for this\n class of @code{subreg} is:\n \n @smallexample\n-GET_MODE_SIZE (@var{m1}) > GET_MODE_SIZE (@var{m2})\n+paradoxical_subreg_p (@var{m1}, @var{m2})\n @end smallexample\n \n Paradoxical @code{subreg}s can be used as both lvalues and rvalues."}, {"sha": "c1438d66cb38af3bc829684b987acae74c252350", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -1008,10 +1008,10 @@ int\n byte_lowpart_offset (machine_mode outer_mode,\n \t\t     machine_mode inner_mode)\n {\n-  if (GET_MODE_SIZE (outer_mode) < GET_MODE_SIZE (inner_mode))\n-    return subreg_lowpart_offset (outer_mode, inner_mode);\n-  else\n+  if (paradoxical_subreg_p (outer_mode, inner_mode))\n     return -subreg_lowpart_offset (inner_mode, outer_mode);\n+  else\n+    return subreg_lowpart_offset (outer_mode, inner_mode);\n }\n \f\n /* Generate a REG rtx for a new pseudo register of mode MODE.\n@@ -1552,16 +1552,6 @@ subreg_lowpart_p (const_rtx x)\n   return (subreg_lowpart_offset (GET_MODE (x), GET_MODE (SUBREG_REG (x)))\n \t  == SUBREG_BYTE (x));\n }\n-\n-/* Return true if X is a paradoxical subreg, false otherwise.  */\n-bool\n-paradoxical_subreg_p (const_rtx x)\n-{\n-  if (GET_CODE (x) != SUBREG)\n-    return false;\n-  return (GET_MODE_PRECISION (GET_MODE (x))\n-\t  > GET_MODE_PRECISION (GET_MODE (SUBREG_REG (x))));\n-}\n \f\n /* Return subword OFFSET of operand OP.\n    The word number, OFFSET, is interpreted as the word number starting"}, {"sha": "37f2df819fb7adaa4eb4b211d140c79ac2542741", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -736,7 +736,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       int byte_offset = 0;\n \n       /* Paradoxical subregs need special handling on big-endian machines.  */\n-      if (SUBREG_BYTE (op0) == 0 && inner_mode_size < outer_mode_size)\n+      if (paradoxical_subreg_p (op0))\n \t{\n \t  int difference = inner_mode_size - outer_mode_size;\n "}, {"sha": "be41d6e10f0f29e3be6e585a1844b9e9ec17968b", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -3204,8 +3204,7 @@ alter_subreg (rtx *xp, bool final_p)\n \n       /* For paradoxical subregs on big-endian machines, SUBREG_BYTE\n \t contains 0 instead of the proper offset.  See simplify_subreg.  */\n-      if (offset == 0\n-\t  && GET_MODE_SIZE (GET_MODE (y)) < GET_MODE_SIZE (GET_MODE (x)))\n+      if (paradoxical_subreg_p (x))\n         {\n           int difference = GET_MODE_SIZE (GET_MODE (y))\n \t\t\t   - GET_MODE_SIZE (GET_MODE (x));"}, {"sha": "cab801e5cc75ebeaf99ee1de2bb6306d4fed10e3", "filename": "gcc/fwprop.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -680,8 +680,7 @@ propagate_rtx (rtx x, machine_mode mode, rtx old_rtx, rtx new_rtx,\n       || CONSTANT_P (new_rtx)\n       || (GET_CODE (new_rtx) == SUBREG\n \t  && REG_P (SUBREG_REG (new_rtx))\n-\t  && (GET_MODE_SIZE (mode)\n-\t      <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (new_rtx))))))\n+\t  && !paradoxical_subreg_p (mode, GET_MODE (SUBREG_REG (new_rtx)))))\n     flags |= PR_CAN_APPEAR;\n   if (!varying_mem_p (new_rtx))\n     flags |= PR_HANDLE_MEM;\n@@ -1103,9 +1102,7 @@ forward_propagate_subreg (df_ref use, rtx_insn *def_insn, rtx def_set)\n       || !REG_P (SET_DEST (def_set)))\n     return false;\n \n-  /* If this is a paradoxical SUBREG...  */\n-  if (GET_MODE_SIZE (use_mode)\n-      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (use_reg))))\n+  if (paradoxical_subreg_p (use_reg))\n     {\n       /* If this is a paradoxical SUBREG, we have no idea what value the\n \t extra bits would have.  However, if the operand is equivalent to"}, {"sha": "e3d479383d631aead71e674f3779396735468d45", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -775,7 +775,7 @@ ira_build_conflicts (void)\n \t     cannot be accessed in the widest mode.  */\n \t  machine_mode outer_mode = ALLOCNO_WMODE (a);\n \t  machine_mode inner_mode = ALLOCNO_MODE (a);\n-\t  if (GET_MODE_SIZE (outer_mode) > GET_MODE_SIZE (inner_mode))\n+\t  if (paradoxical_subreg_p (outer_mode, inner_mode))\n \t    {\n \t      enum reg_class aclass = ALLOCNO_CLASS (a);\n \t      for (int j = ira_class_hard_regs_num[aclass] - 1; j >= 0; --j)"}, {"sha": "422b4913b4a39c30bcc0ed15ffcd357c8b565a87", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -661,10 +661,8 @@ simplify_gen_subreg_concatn (machine_mode outermode, rtx op,\n       if (op2 == NULL_RTX)\n \t{\n \t  /* We don't handle paradoxical subregs here.  */\n-\t  gcc_assert (GET_MODE_SIZE (outermode)\n-\t\t      <= GET_MODE_SIZE (GET_MODE (op)));\n-\t  gcc_assert (GET_MODE_SIZE (GET_MODE (op))\n-\t\t      <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))));\n+\t  gcc_assert (!paradoxical_subreg_p (outermode, GET_MODE (op)));\n+\t  gcc_assert (!paradoxical_subreg_p (op));\n \t  op2 = simplify_subreg_concatn (outermode, SUBREG_REG (op),\n \t\t\t\t\t byte + SUBREG_BYTE (op));\n \t  gcc_assert (op2 != NULL_RTX);\n@@ -685,10 +683,7 @@ simplify_gen_subreg_concatn (machine_mode outermode, rtx op,\n      resolve_simple_move will ask for the high part of the paradoxical\n      subreg, which does not have a value.  Just return a zero.  */\n   if (ret == NULL_RTX\n-      && GET_CODE (op) == SUBREG\n-      && SUBREG_BYTE (op) == 0\n-      && (GET_MODE_SIZE (innermode)\n-\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (op)))))\n+      && paradoxical_subreg_p (op))\n     return CONST0_RTX (outermode);\n \n   gcc_assert (ret != NULL_RTX);"}, {"sha": "cefa31968da6fbd228267ebcc39b81f77b8e8bf8", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -4225,8 +4225,7 @@ curr_insn_transform (bool check_only_p)\n \t\t  /* Strict_low_part requires reload the register not\n \t\t     the sub-register.\t*/\n \t\t  && (curr_static_id->operand[i].strict_low\n-\t\t      || (GET_MODE_SIZE (mode)\n-\t\t\t  <= GET_MODE_SIZE (GET_MODE (reg))\n+\t\t      || (!paradoxical_subreg_p (mode, GET_MODE (reg))\n \t\t\t  && (hard_regno\n \t\t\t      = get_try_hard_regno (REGNO (reg))) >= 0\n \t\t\t  && (simplify_subreg_regno\n@@ -5465,7 +5464,7 @@ split_reg (bool before_p, int original_regno, rtx_insn *insn,\n \t mode was larger than a register, just use the reg_rtx.  Otherwise,\n \t limit the size to that of the biggest access in the function.  */\n       if (mode == VOIDmode\n-\t  || GET_MODE_SIZE (mode) > GET_MODE_SIZE (reg_rtx_mode))\n+\t  || paradoxical_subreg_p (mode, reg_rtx_mode))\n \t{\n \t  original_reg = regno_reg_rtx[hard_regno];\n \t  mode = reg_rtx_mode;"}, {"sha": "24a02ef12088f5c38bbb59adfd419f4ab8897547", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -286,8 +286,8 @@ move_plus_up (rtx x)\n   subreg_reg = SUBREG_REG (x);\n   x_mode = GET_MODE (x);\n   subreg_reg_mode = GET_MODE (subreg_reg);\n-  if (GET_CODE (x) == SUBREG && GET_CODE (subreg_reg) == PLUS\n-      && GET_MODE_SIZE (x_mode) <= GET_MODE_SIZE (subreg_reg_mode)\n+  if (!paradoxical_subreg_p (x)\n+      && GET_CODE (subreg_reg) == PLUS\n       && CONSTANT_P (XEXP (subreg_reg, 1))\n       && GET_MODE_CLASS (x_mode) == MODE_INT\n       && GET_MODE_CLASS (subreg_reg_mode) == MODE_INT)\n@@ -605,10 +605,7 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n \n       if (new_rtx != SUBREG_REG (x))\n \t{\n-\t  int x_size = GET_MODE_SIZE (GET_MODE (x));\n-\t  int new_size = GET_MODE_SIZE (GET_MODE (new_rtx));\n-\n-\t  if (MEM_P (new_rtx) && x_size <= new_size)\n+\t  if (MEM_P (new_rtx) && !paradoxical_subreg_p (x))\n \t    {\n \t      SUBREG_REG (x) = new_rtx;\n \t      alter_subreg (&x, false);"}, {"sha": "4467bf73a6fb1daf4969feaae97d119c5171ce2b", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -1002,7 +1002,7 @@ general_operand (rtx op, machine_mode mode)\n \t However, we must allow them after reload so that they can\n \t get cleaned up by cleanup_subreg_operands.  */\n       if (!reload_completed && MEM_P (sub)\n-\t  && GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (sub)))\n+\t  && paradoxical_subreg_p (op))\n \treturn 0;\n #endif\n       /* Avoid memories with nonzero SUBREG_BYTE, as offsetting the memory\n@@ -1037,7 +1037,7 @@ general_operand (rtx op, machine_mode mode)\n \t     size of floating point mode can be less than the integer\n \t     mode.  */\n \t  && ! lra_in_progress \n-\t  && GET_MODE_SIZE (GET_MODE (op)) > GET_MODE_SIZE (GET_MODE (sub)))\n+\t  && paradoxical_subreg_p (op))\n \treturn 0;\n \n       op = sub;"}, {"sha": "bffb18b2b0a9416d9fb72d71c1a861d15dceae24", "filename": "gcc/ree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -869,7 +869,8 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)\n \t    return false;\n \n \t  for (df_link *use = uses; use; use = use->next)\n-\t    if (GET_MODE_PRECISION (GET_MODE (*DF_REF_LOC (use->ref))) > prec)\n+\t    if (paradoxical_subreg_p (GET_MODE (*DF_REF_LOC (use->ref)),\n+\t\t\t\t      GET_MODE (SET_DEST (*dest_sub_rtx))))\n \t      return false;\n \t}\n "}, {"sha": "691c4b9da98840acda10c9463dfbee56035fe10b", "filename": "gcc/reload.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -1062,13 +1062,12 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t  || (((REG_P (SUBREG_REG (in))\n \t\t&& REGNO (SUBREG_REG (in)) >= FIRST_PSEUDO_REGISTER)\n \t       || MEM_P (SUBREG_REG (in)))\n-\t      && ((GET_MODE_PRECISION (inmode)\n-\t\t   > GET_MODE_PRECISION (GET_MODE (SUBREG_REG (in))))\n+\t      && (paradoxical_subreg_p (inmode, GET_MODE (SUBREG_REG (in)))\n \t\t  || (GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n \t\t      && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n \t\t\t  <= UNITS_PER_WORD)\n-\t\t      && (GET_MODE_PRECISION (inmode)\n-\t\t\t  > GET_MODE_PRECISION (GET_MODE (SUBREG_REG (in))))\n+\t\t      && paradoxical_subreg_p (inmode,\n+\t\t\t\t\t       GET_MODE (SUBREG_REG (in)))\n \t\t      && INTEGRAL_MODE_P (GET_MODE (SUBREG_REG (in)))\n \t\t      && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (in))) != UNKNOWN)\n \t\t  || (WORD_REGISTER_OPERATIONS\n@@ -1170,8 +1169,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t  || (((REG_P (SUBREG_REG (out))\n \t\t&& REGNO (SUBREG_REG (out)) >= FIRST_PSEUDO_REGISTER)\n \t       || MEM_P (SUBREG_REG (out)))\n-\t      && ((GET_MODE_PRECISION (outmode)\n-\t\t   > GET_MODE_PRECISION (GET_MODE (SUBREG_REG (out))))\n+\t      && (paradoxical_subreg_p (outmode, GET_MODE (SUBREG_REG (out)))\n \t\t  || (WORD_REGISTER_OPERATIONS\n \t\t      && (GET_MODE_PRECISION (outmode)\n \t\t\t  < GET_MODE_PRECISION (GET_MODE (SUBREG_REG (out))))\n@@ -1299,7 +1297,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n   if (this_insn_is_asm)\n     {\n       machine_mode mode;\n-      if (GET_MODE_SIZE (inmode) > GET_MODE_SIZE (outmode))\n+      if (paradoxical_subreg_p (inmode, outmode))\n \tmode = inmode;\n       else\n \tmode = outmode;\n@@ -3137,15 +3135,15 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t\t\t  && (WORD_REGISTER_OPERATIONS\n \t\t\t      || ((GET_MODE_BITSIZE (GET_MODE (operand))\n \t\t\t\t   < BIGGEST_ALIGNMENT)\n-\t\t\t\t && (GET_MODE_SIZE (operand_mode[i])\n-\t\t\t\t     > GET_MODE_SIZE (GET_MODE (operand))))\n+\t\t\t\t  && paradoxical_subreg_p (operand_mode[i],\n+\t\t\t\t\t\t\t   GET_MODE (operand)))\n \t\t\t      || BYTES_BIG_ENDIAN\n \t\t\t      || ((GET_MODE_SIZE (operand_mode[i])\n \t\t\t\t   <= UNITS_PER_WORD)\n \t\t\t\t  && (GET_MODE_SIZE (GET_MODE (operand))\n \t\t\t\t      <= UNITS_PER_WORD)\n-\t\t\t\t  && (GET_MODE_SIZE (operand_mode[i])\n-\t\t\t\t      > GET_MODE_SIZE (GET_MODE (operand)))\n+\t\t\t\t  && paradoxical_subreg_p (operand_mode[i],\n+\t\t\t\t\t\t\t   GET_MODE (operand))\n \t\t\t\t  && INTEGRAL_MODE_P (GET_MODE (operand))\n \t\t\t\t  && LOAD_EXTEND_OP (GET_MODE (operand))\n \t\t\t\t     != UNKNOWN)))"}, {"sha": "6666344a39b1e777f97fae4f4f0d45d8e29742ee", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -3042,8 +3042,7 @@ elimination_effects (rtx x, machine_mode mem_mode)\n \n     case SUBREG:\n       if (REG_P (SUBREG_REG (x))\n-\t  && (GET_MODE_SIZE (GET_MODE (x))\n-\t      <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+\t  && !paradoxical_subreg_p (x)\n \t  && reg_equivs\n \t  && reg_equiv_memory_loc (REGNO (SUBREG_REG (x))) != 0)\n \treturn;\n@@ -6373,8 +6372,7 @@ compute_reload_subreg_offset (machine_mode outermode,\n   /* If SUBREG is paradoxical then return the normal lowpart offset\n      for OUTERMODE and INNERMODE.  Our caller has already checked\n      that OUTERMODE fits in INNERMODE.  */\n-  if (outer_offset == 0\n-      && GET_MODE_SIZE (outermode) > GET_MODE_SIZE (middlemode))\n+  if (paradoxical_subreg_p (outermode, middlemode))\n     return subreg_lowpart_offset (outermode, innermode);\n \n   /* SUBREG is normal, but may not be lowpart; return OUTER_OFFSET\n@@ -6664,8 +6662,7 @@ choose_reload_regs (struct insn_chain *chain)\n \t\t\t\t  && rld[r].out)\n \t\t\t      /* Don't really use the inherited spill reg\n \t\t\t\t if we need it wider than we've got it.  */\n-\t\t\t      || (GET_MODE_SIZE (rld[r].mode)\n-\t\t\t\t  > GET_MODE_SIZE (mode))\n+\t\t\t      || paradoxical_subreg_p (rld[r].mode, mode)\n \t\t\t      || bad_for_class\n \n \t\t\t      /* If find_reloads chose reload_out as reload"}, {"sha": "a2c339e7e2d5471a10910c77acaceeb3dc966aaf", "filename": "gcc/rtl.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -2784,10 +2784,28 @@ extern rtx operand_subword (rtx, unsigned int, int, machine_mode);\n \n /* In emit-rtl.c */\n extern rtx operand_subword_force (rtx, unsigned int, machine_mode);\n-extern bool paradoxical_subreg_p (const_rtx);\n extern int subreg_lowpart_p (const_rtx);\n extern unsigned int subreg_size_lowpart_offset (unsigned int, unsigned int);\n \n+/* Return true if a subreg with the given outer and inner modes is\n+   paradoxical.  */\n+\n+inline bool\n+paradoxical_subreg_p (machine_mode outermode, machine_mode innermode)\n+{\n+  return GET_MODE_PRECISION (outermode) > GET_MODE_PRECISION (innermode);\n+}\n+\n+/* Return true if X is a paradoxical subreg, false otherwise.  */\n+\n+inline bool\n+paradoxical_subreg_p (const_rtx x)\n+{\n+  if (GET_CODE (x) != SUBREG)\n+    return false;\n+  return paradoxical_subreg_p (GET_MODE (x), GET_MODE (SUBREG_REG (x)));\n+}\n+\n /* Return the SUBREG_BYTE for an OUTERMODE lowpart of an INNERMODE value.  */\n \n inline unsigned int"}, {"sha": "0d93b6f416ffe8fbe1f25e503879c9874c72ba61", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -3530,7 +3530,7 @@ subreg_lsb_1 (machine_mode outer_mode,\n   unsigned int word;\n \n   /* A paradoxical subreg begins at bit position 0.  */\n-  if (GET_MODE_PRECISION (outer_mode) > GET_MODE_PRECISION (inner_mode))\n+  if (paradoxical_subreg_p (outer_mode, inner_mode))\n     return 0;\n \n   if (WORDS_BIG_ENDIAN != BYTES_BIG_ENDIAN)"}, {"sha": "0133d43bbff4322b5da1d60443c9d723170f86be", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -1465,7 +1465,7 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n       if (GET_CODE (op) == SUBREG\n \t  && SUBREG_PROMOTED_VAR_P (op)\n \t  && SUBREG_PROMOTED_SIGNED_P (op)\n-\t  && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (GET_MODE (XEXP (op, 0))))\n+\t  && !paradoxical_subreg_p (mode, GET_MODE (SUBREG_REG (op))))\n \t{\n \t  temp = rtl_hooks.gen_lowpart_no_emit (mode, op);\n \t  if (temp)\n@@ -1547,7 +1547,7 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n       if (GET_CODE (op) == SUBREG\n \t  && SUBREG_PROMOTED_VAR_P (op)\n \t  && SUBREG_PROMOTED_UNSIGNED_P (op)\n-\t  && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (GET_MODE (XEXP (op, 0))))\n+\t  && !paradoxical_subreg_p (mode, GET_MODE (SUBREG_REG (op))))\n \t{\n \t  temp = rtl_hooks.gen_lowpart_no_emit (mode, op);\n \t  if (temp)\n@@ -6080,7 +6080,7 @@ simplify_subreg (machine_mode outermode, rtx op,\n \t}\n \n       /* See whether resulting subreg will be paradoxical.  */\n-      if (GET_MODE_SIZE (innermostmode) > GET_MODE_SIZE (outermode))\n+      if (!paradoxical_subreg_p (outermode, innermostmode))\n \t{\n \t  /* In nonparadoxical subregs we can't handle negative offsets.  */\n \t  if (final_offset < 0)"}, {"sha": "ef2c6aa4c910b5964d3b6075ea8640bb6d17498f", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03a9562184454fe5395e30b8a3429c4570979d86/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=03a9562184454fe5395e30b8a3429c4570979d86", "patch": "@@ -5295,7 +5295,7 @@ track_loc_p (rtx loc, tree expr, HOST_WIDE_INT offset, bool store_reg_p,\n       machine_mode pseudo_mode;\n \n       pseudo_mode = PSEUDO_REGNO_MODE (ORIGINAL_REGNO (loc));\n-      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (pseudo_mode))\n+      if (paradoxical_subreg_p (mode, pseudo_mode))\n \t{\n \t  offset += byte_lowpart_offset (pseudo_mode, mode);\n \t  mode = pseudo_mode;\n@@ -5309,7 +5309,7 @@ track_loc_p (rtx loc, tree expr, HOST_WIDE_INT offset, bool store_reg_p,\n      because the real and imaginary parts are represented as separate\n      pseudo registers, even if the whole complex value fits into one\n      hard register.  */\n-  if ((GET_MODE_SIZE (mode) > GET_MODE_SIZE (DECL_MODE (expr))\n+  if ((paradoxical_subreg_p (mode, DECL_MODE (expr))\n        || (store_reg_p\n \t   && !COMPLEX_MODE_P (DECL_MODE (expr))\n \t   && hard_regno_nregs[REGNO (loc)][DECL_MODE (expr)] == 1))"}]}