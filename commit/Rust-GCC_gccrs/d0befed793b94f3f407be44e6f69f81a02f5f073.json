{"sha": "d0befed793b94f3f407be44e6f69f81a02f5f073", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBiZWZlZDc5M2I5NGYzZjQwN2JlNDRlNmY2OWY4MWEwMmY1ZjA3Mw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-08-12T20:41:17Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-08-12T20:41:17Z"}, "message": "openmp: Add support for OpenMP 5.1 masked construct\n\nThis construct has been introduced as a replacement for master\nconstruct, but unlike that construct is slightly more general,\nhas an optional clause which allows to choose which thread\nwill be the one running the region, it can be some other thread\nthan the master (primary) thread with number 0, or it could be no\nthreads or multiple threads (then of course one needs to be careful\nabout data races).\n\nIt is way too early to deprecate the master construct though, we don't\neven have OpenMP 5.0 fully implemented, it has been deprecated in 5.1,\nwill be also in 5.2 and removed in 6.0.  But even then it will likely\nbe a good idea to just -Wdeprecated warn about it and still accept it.\n\nThe patch also contains something I should have done much earlier,\nfor clauses that accept some integral expression where we only care\nabout the value, forces during gimplification that value into\neither a min invariant (as before), SSA_NAME or a fresh temporary,\nbut never e.g. a user VAR_DECL, so that for those clauses we don't\nneed to worry about adjusting it.\n\n2021-08-12  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* tree.def (OMP_MASKED): New tree code.\n\t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE_FILTER.\n\t* tree.h (OMP_MASKED_BODY, OMP_MASKED_CLAUSES, OMP_MASKED_COMBINED,\n\tOMP_CLAUSE_FILTER_EXPR): Define.\n\t* tree.c (omp_clause_num_ops): Add OMP_CLAUSE_FILTER entry.\n\t(omp_clause_code_name): Likewise.\n\t(walk_tree_1): Handle OMP_CLAUSE_FILTER.\n\t* tree-nested.c (convert_nonlocal_omp_clauses,\n\tconvert_local_omp_clauses): Handle OMP_CLAUSE_FILTER.\n\t(convert_nonlocal_reference_stmt, convert_local_reference_stmt,\n\tconvert_gimple_call): Handle GIMPLE_OMP_MASTER.\n\t* tree-pretty-print.c (dump_omp_clause): Handle OMP_CLAUSE_FILTER.\n\t(dump_generic_node): Handle OMP_MASTER.\n\t* gimple.def (GIMPLE_OMP_MASKED): New gimple code.\n\t* gimple.c (gimple_build_omp_masked): New function.\n\t(gimple_copy): Handle GIMPLE_OMP_MASKED.\n\t* gimple.h (gimple_build_omp_masked): Declare.\n\t(gimple_has_substatements): Handle GIMPLE_OMP_MASKED.\n\t(gimple_omp_masked_clauses, gimple_omp_masked_clauses_ptr,\n\tgimple_omp_masked_set_clauses): New inline functions.\n\t(CASE_GIMPLE_OMP): Add GIMPLE_OMP_MASKED.\n\t* gimple-pretty-print.c (dump_gimple_omp_masked): New function.\n\t(pp_gimple_stmt_1): Handle GIMPLE_OMP_MASKED.\n\t* gimple-walk.c (walk_gimple_stmt): Likewise.\n\t* gimple-low.c (lower_stmt): Likewise.\n\t* gimplify.c (is_gimple_stmt): Handle OMP_MASTER.\n\t(gimplify_scan_omp_clauses): Handle OMP_CLAUSE_FILTER.  For clauses\n\tthat take one expression rather than decl or constant, force\n\tgimplification of that into a SSA_NAME or temporary unless min\n\tinvariant.\n\t(gimplify_adjust_omp_clauses): Handle OMP_CLAUSE_FILTER.\n\t(gimplify_expr): Handle OMP_MASKED.\n\t* tree-inline.c (remap_gimple_stmt): Handle GIMPLE_OMP_MASKED.\n\t(estimate_num_insns): Likewise.\n\t* omp-low.c (scan_sharing_clauses): Handle OMP_CLAUSE_FILTER.\n\t(check_omp_nesting_restrictions): Handle GIMPLE_OMP_MASKED.  Adjust\n\tdiagnostics for existence of masked construct.\n\t(scan_omp_1_stmt, lower_omp_master, lower_omp_1, diagnose_sb_1,\n\tdiagnose_sb_2): Handle GIMPLE_OMP_MASKED.\n\t* omp-expand.c (expand_omp_synch, expand_omp, omp_make_gimple_edges):\n\tLikewise.\ngcc/c-family/\n\t* c-pragma.h (enum pragma_kind): Add PRAGMA_OMP_MASKED.\n\t(enum pragma_omp_clause): Add PRAGMA_OMP_CLAUSE_FILTER.\n\t* c-pragma.c (omp_pragmas_simd): Add masked construct.\n\t* c-common.h (enum c_omp_clause_split): Add C_OMP_CLAUSE_SPLIT_MASKED\n\tenumerator.\n\t(c_finish_omp_masked): Declare.\n\t* c-omp.c (c_finish_omp_masked): New function.\n\t(c_omp_split_clauses): Handle combined masked constructs.\ngcc/c/\n\t* c-parser.c (c_parser_omp_clause_name): Parse filter clause name.\n\t(c_parser_omp_clause_filter): New function.\n\t(c_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_FILTER.\n\t(OMP_MASKED_CLAUSE_MASK): Define.\n\t(c_parser_omp_masked): New function.\n\t(c_parser_omp_parallel): Handle parallel masked.\n\t(c_parser_omp_construct): Handle PRAGMA_OMP_MASKED.\n\t* c-typeck.c (c_finish_omp_clauses): Handle OMP_CLAUSE_FILTER.\ngcc/cp/\n\t* parser.c (cp_parser_omp_clause_name): Parse filter clause name.\n\t(cp_parser_omp_clause_filter): New function.\n\t(cp_parser_omp_all_clauses): Handle PRAGMA_OMP_CLAUSE_FILTER.\n\t(OMP_MASKED_CLAUSE_MASK): Define.\n\t(cp_parser_omp_masked): New function.\n\t(cp_parser_omp_parallel): Handle parallel masked.\n\t(cp_parser_omp_construct, cp_parser_pragma): Handle PRAGMA_OMP_MASKED.\n\t* semantics.c (finish_omp_clauses): Handle OMP_CLAUSE_FILTER.\n\t* pt.c (tsubst_omp_clauses): Likewise.\n\t(tsubst_expr): Handle OMP_MASKED.\ngcc/testsuite/\n\t* c-c++-common/gomp/clauses-1.c (bar): Add tests for combined masked\n\tconstructs with clauses.\n\t* c-c++-common/gomp/clauses-5.c (foo): Add testcase for filter clause.\n\t* c-c++-common/gomp/clause-dups-1.c (f1): Likewise.\n\t* c-c++-common/gomp/masked-1.c: New test.\n\t* c-c++-common/gomp/masked-2.c: New test.\n\t* c-c++-common/gomp/masked-combined-1.c: New test.\n\t* c-c++-common/gomp/masked-combined-2.c: New test.\n\t* c-c++-common/goacc/uninit-if-clause.c: Remove xfails.\n\t* g++.dg/gomp/block-11.C: New test.\n\t* g++.dg/gomp/tpl-masked-1.C: New test.\n\t* g++.dg/gomp/attrs-1.C (bar): Add tests for masked construct and\n\tcombined masked constructs with clauses in attribute syntax.\n\t* g++.dg/gomp/attrs-2.C (bar): Likewise.\n\t* gcc.dg/gomp/nesting-1.c (f1, f2): Add tests for masked construct\n\tnesting.\n\t* gfortran.dg/goacc/host_data-tree.f95: Allow also SSA_NAMEs in if\n\tclause.\n\t* gfortran.dg/goacc/kernels-tree.f95: Likewise.\nlibgomp/\n\t* testsuite/libgomp.c-c++-common/masked-1.c: New test.", "tree": {"sha": "f37b1167915c7996a124b6f70a37f182199c0bbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f37b1167915c7996a124b6f70a37f182199c0bbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0befed793b94f3f407be44e6f69f81a02f5f073", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0befed793b94f3f407be44e6f69f81a02f5f073", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0befed793b94f3f407be44e6f69f81a02f5f073", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0befed793b94f3f407be44e6f69f81a02f5f073/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "408d88af60e3268f7fad59fa393ec7e28922c435", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/408d88af60e3268f7fad59fa393ec7e28922c435", "html_url": "https://github.com/Rust-GCC/gccrs/commit/408d88af60e3268f7fad59fa393ec7e28922c435"}], "stats": {"total": 1009, "additions": 969, "deletions": 40}, "files": [{"sha": "025123a3c916cb1aa30a59ddee0185d5b7f285f4", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -1201,7 +1201,8 @@ enum c_omp_clause_split\n   C_OMP_CLAUSE_SPLIT_COUNT,\n   C_OMP_CLAUSE_SPLIT_SECTIONS = C_OMP_CLAUSE_SPLIT_FOR,\n   C_OMP_CLAUSE_SPLIT_TASKLOOP = C_OMP_CLAUSE_SPLIT_FOR,\n-  C_OMP_CLAUSE_SPLIT_LOOP = C_OMP_CLAUSE_SPLIT_FOR\n+  C_OMP_CLAUSE_SPLIT_LOOP = C_OMP_CLAUSE_SPLIT_FOR,\n+  C_OMP_CLAUSE_SPLIT_MASKED = C_OMP_CLAUSE_SPLIT_DISTRIBUTE\n };\n \n enum c_omp_region_type\n@@ -1215,6 +1216,7 @@ enum c_omp_region_type\n };\n \n extern tree c_finish_omp_master (location_t, tree);\n+extern tree c_finish_omp_masked (location_t, tree, tree);\n extern tree c_finish_omp_taskgroup (location_t, tree, tree);\n extern tree c_finish_omp_critical (location_t, tree, tree, tree);\n extern tree c_finish_omp_ordered (location_t, tree, tree);"}, {"sha": "54eba61762cc044dd9408c86bdfdb9f9de65bf5a", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -86,6 +86,20 @@ c_finish_omp_master (location_t loc, tree stmt)\n   return t;\n }\n \n+/* Complete a #pragma omp masked construct.  BODY is the structured-block\n+   that follows the pragma.  LOC is the location of the #pragma.  */\n+\n+tree\n+c_finish_omp_masked (location_t loc, tree body, tree clauses)\n+{\n+  tree stmt = make_node (OMP_MASKED);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_MASKED_BODY (stmt) = body;\n+  OMP_MASKED_CLAUSES (stmt) = clauses;\n+  SET_EXPR_LOCATION (stmt, loc);\n+  return add_stmt (stmt);\n+}\n+\n /* Complete a #pragma omp taskgroup construct.  BODY is the structured-block\n    that follows the pragma.  LOC is the location of the #pragma.  */\n \n@@ -1542,11 +1556,16 @@ c_oacc_split_loop_clauses (tree clauses, tree *not_loop_clauses,\n    #pragma omp distribute parallel for simd\n    #pragma omp distribute simd\n    #pragma omp for simd\n+   #pragma omp masked taskloop\n+   #pragma omp masked taskloop simd\n    #pragma omp master taskloop\n    #pragma omp master taskloop simd\n    #pragma omp parallel for\n    #pragma omp parallel for simd\n    #pragma omp parallel loop\n+   #pragma omp parallel masked\n+   #pragma omp parallel masked taskloop\n+   #pragma omp parallel masked taskloop simd\n    #pragma omp parallel master\n    #pragma omp parallel master taskloop\n    #pragma omp parallel master taskloop simd\n@@ -1651,6 +1670,9 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \tcase OMP_CLAUSE_BIND:\n \t  s = C_OMP_CLAUSE_SPLIT_LOOP;\n \t  break;\n+\tcase OMP_CLAUSE_FILTER:\n+\t  s = C_OMP_CLAUSE_SPLIT_MASKED;\n+\t  break;\n \t/* Duplicate this to all of taskloop, distribute, for, simd and\n \t   loop.  */\n \tcase OMP_CLAUSE_COLLAPSE:\n@@ -1700,10 +1722,10 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t  else\n \t    s = C_OMP_CLAUSE_SPLIT_DISTRIBUTE;\n \t  break;\n-\t/* Private clause is supported on all constructs but master,\n-\t   it is enough to put it on the innermost one other than master.  For\n-\t   #pragma omp {for,sections} put it on parallel though,\n-\t   as that's what we did for OpenMP 3.1.  */\n+\t/* Private clause is supported on all constructs but master/masked,\n+\t   it is enough to put it on the innermost one other than\n+\t   master/masked.  For #pragma omp {for,sections} put it on parallel\n+\t   though, as that's what we did for OpenMP 3.1.  */\n \tcase OMP_CLAUSE_PRIVATE:\n \t  switch (code)\n \t    {\n@@ -1713,14 +1735,15 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t    case OMP_DISTRIBUTE: s = C_OMP_CLAUSE_SPLIT_DISTRIBUTE; break;\n \t    case OMP_TEAMS: s = C_OMP_CLAUSE_SPLIT_TEAMS; break;\n \t    case OMP_MASTER: s = C_OMP_CLAUSE_SPLIT_PARALLEL; break;\n+\t    case OMP_MASKED: s = C_OMP_CLAUSE_SPLIT_PARALLEL; break;\n \t    case OMP_TASKLOOP: s = C_OMP_CLAUSE_SPLIT_TASKLOOP; break;\n \t    case OMP_LOOP: s = C_OMP_CLAUSE_SPLIT_LOOP; break;\n \t    default: gcc_unreachable ();\n \t    }\n \t  break;\n \t/* Firstprivate clause is supported on all constructs but\n-\t   simd, master and loop.  Put it on the outermost of those and\n-\t   duplicate on teams and parallel.  */\n+\t   simd, master, masked and loop.  Put it on the outermost of those\n+\t   and duplicate on teams and parallel.  */\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n \t  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_MAP))\n \t      != 0)\n@@ -1773,7 +1796,7 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t      else if ((mask & (OMP_CLAUSE_MASK_1\n \t\t\t\t<< PRAGMA_OMP_CLAUSE_NOGROUP)) != 0)\n \t\t/* This must be\n-\t\t   #pragma omp parallel master taskloop{, simd}.  */\n+\t\t   #pragma omp parallel mas{ked,ter} taskloop{, simd}.  */\n \t\ts = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n \t      else\n \t\t/* This must be\n@@ -1805,9 +1828,10 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t  else if ((mask & (OMP_CLAUSE_MASK_1\n \t\t\t    << PRAGMA_OMP_CLAUSE_NOGROUP)) != 0)\n \t    {\n-\t      /* This must be #pragma omp {,{,parallel }master }taskloop simd\n+\t      /* This must be\n+\t\t #pragma omp {,{,parallel }mas{ked,ter} }taskloop simd\n \t\t or\n-\t\t #pragma omp {,parallel }master taskloop.  */\n+\t\t #pragma omp {,parallel }mas{ked,ter} taskloop.  */\n \t      gcc_assert (code == OMP_SIMD || code == OMP_TASKLOOP);\n \t      s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n \t    }\n@@ -2044,7 +2068,8 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n \t    }\n \t  else if (code == OMP_SECTIONS\n \t\t   || code == OMP_PARALLEL\n-\t\t   || code == OMP_MASTER)\n+\t\t   || code == OMP_MASTER\n+\t\t   || code == OMP_MASKED)\n \t    s = C_OMP_CLAUSE_SPLIT_PARALLEL;\n \t  else if (code == OMP_TASKLOOP)\n \t    s = C_OMP_CLAUSE_SPLIT_TASKLOOP;\n@@ -2455,7 +2480,8 @@ c_omp_split_clauses (location_t loc, enum tree_code code,\n     gcc_assert (cclauses[C_OMP_CLAUSE_SPLIT_TARGET] == NULL_TREE);\n   if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_TEAMS)) == 0)\n     gcc_assert (cclauses[C_OMP_CLAUSE_SPLIT_TEAMS] == NULL_TREE);\n-  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) == 0)\n+  if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DIST_SCHEDULE)) == 0\n+      && (mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FILTER)) == 0)\n     gcc_assert (cclauses[C_OMP_CLAUSE_SPLIT_DISTRIBUTE] == NULL_TREE);\n   if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_NUM_THREADS)) == 0)\n     gcc_assert (cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL] == NULL_TREE);\n@@ -2975,8 +3001,8 @@ static const struct c_omp_directive omp_directives[] = {\n     C_OMP_DIR_STANDALONE, false },  */\n   { \"loop\", nullptr, nullptr, PRAGMA_OMP_LOOP,\n     C_OMP_DIR_CONSTRUCT, true },\n-  /* { \"masked\", nullptr, nullptr, PRAGMA_OMP_MASKED,\n-    C_OMP_DIR_CONSTRUCT, true },  */\n+  { \"masked\", nullptr, nullptr, PRAGMA_OMP_MASKED,\n+    C_OMP_DIR_CONSTRUCT, true },\n   { \"master\", nullptr, nullptr, PRAGMA_OMP_MASTER,\n     C_OMP_DIR_CONSTRUCT, true },\n   /* { \"metadirective\", nullptr, nullptr, PRAGMA_OMP_METADIRECTIVE,"}, {"sha": "b466a274615af15d7d47747ed0c3260df60698e2", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -1343,6 +1343,7 @@ static const struct omp_pragma_def omp_pragmas_simd[] = {\n   { \"distribute\", PRAGMA_OMP_DISTRIBUTE },\n   { \"for\", PRAGMA_OMP_FOR },\n   { \"loop\", PRAGMA_OMP_LOOP },\n+  { \"masked\", PRAGMA_OMP_MASKED },\n   { \"master\", PRAGMA_OMP_MASTER },\n   { \"ordered\", PRAGMA_OMP_ORDERED },\n   { \"parallel\", PRAGMA_OMP_PARALLEL },"}, {"sha": "b7ec6e5d5474f11fcd9c34ff6c645babda11ad9d", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -57,6 +57,7 @@ enum pragma_kind {\n   PRAGMA_OMP_FLUSH,\n   PRAGMA_OMP_FOR,\n   PRAGMA_OMP_LOOP,\n+  PRAGMA_OMP_MASKED,\n   PRAGMA_OMP_MASTER,\n   PRAGMA_OMP_ORDERED,\n   PRAGMA_OMP_PARALLEL,\n@@ -104,6 +105,7 @@ enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_DEVICE,\n   PRAGMA_OMP_CLAUSE_DEVICE_TYPE,\n   PRAGMA_OMP_CLAUSE_DIST_SCHEDULE,\n+  PRAGMA_OMP_CLAUSE_FILTER,\n   PRAGMA_OMP_CLAUSE_FINAL,\n   PRAGMA_OMP_CLAUSE_FIRSTPRIVATE,\n   PRAGMA_OMP_CLAUSE_FOR,"}, {"sha": "ca6e56a7517da0449a340ebe7a4272380bd97d1d", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 137, "deletions": 2, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -12696,7 +12696,9 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_DIST_SCHEDULE;\n \t  break;\n \tcase 'f':\n-\t  if (!strcmp (\"final\", p))\n+\t  if (!strcmp (\"filter\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_FILTER;\n+\t  else if (!strcmp (\"final\", p))\n \t    result = PRAGMA_OMP_CLAUSE_FINAL;\n \t  else if (!strcmp (\"finalize\", p))\n \t    result = PRAGMA_OACC_CLAUSE_FINALIZE;\n@@ -13948,6 +13950,38 @@ c_parser_omp_clause_hint (c_parser *parser, tree list)\n   return list;\n }\n \n+/* OpenMP 5.1:\n+   filter ( integer-expression ) */\n+\n+static tree\n+c_parser_omp_clause_filter (c_parser *parser, tree list)\n+{\n+  location_t hint_loc = c_parser_peek_token (parser)->location;\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n+    {\n+      location_t expr_loc = c_parser_peek_token (parser)->location;\n+      c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+      expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n+      tree c, t = expr.value;\n+      t = c_fully_fold (t, false, NULL);\n+      if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t{\n+\t  c_parser_error (parser, \"expected integer expression\");\n+\t  return list;\n+\t}\n+      parens.skip_until_found_close (parser);\n+      check_no_duplicate_clause (list, OMP_CLAUSE_FILTER, \"filter\");\n+\n+      c = build_omp_clause (hint_loc, OMP_CLAUSE_FILTER);\n+      OMP_CLAUSE_FILTER_EXPR (c) = t;\n+      OMP_CLAUSE_CHAIN (c) = list;\n+      list = c;\n+    }\n+\n+  return list;\n+}\n+\n /* OpenMP 4.5:\n    defaultmap ( tofrom : scalar )\n \n@@ -16410,6 +16444,10 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  clauses = c_parser_omp_clause_detach (parser, clauses);\n \t  c_name = \"detach\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_FILTER:\n+\t  clauses = c_parser_omp_clause_filter (parser, clauses);\n+\t  c_name = \"filter\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_FIRSTPRIVATE:\n \t  clauses = c_parser_omp_clause_firstprivate (parser, clauses);\n \t  c_name = \"firstprivate\";\n@@ -18975,6 +19013,70 @@ c_parser_omp_master (location_t loc, c_parser *parser,\n \t\t\t\t\t\t\t\t  if_p));\n }\n \n+/* OpenMP 5.1:\n+   # pragma omp masked masked-clauses new-line\n+     structured-block\n+\n+   LOC is the location of the #pragma token.\n+*/\n+\n+#define OMP_MASKED_CLAUSE_MASK\t\t\t\t\t\\\n+\t(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FILTER)\n+\n+static tree\n+c_parser_omp_masked (location_t loc, c_parser *parser,\n+\t\t     char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t     bool *if_p)\n+{\n+  tree block, clauses, ret;\n+\n+  strcat (p_name, \" masked\");\n+  mask |= OMP_MASKED_CLAUSE_MASK;\n+\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\n+      if (strcmp (p, \"taskloop\") == 0)\n+\t{\n+\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  if (cclauses == NULL)\n+\t    cclauses = cclauses_buf;\n+\n+\t  c_parser_consume_token (parser);\n+\t  if (!flag_openmp)  /* flag_openmp_simd  */\n+\t    return c_parser_omp_taskloop (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t\t  if_p);\n+\t  block = c_begin_compound_stmt (true);\n+\t  ret = c_parser_omp_taskloop (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t       if_p);\n+\t  block = c_end_compound_stmt (loc, block, true);\n+\t  if (ret == NULL_TREE)\n+\t    return ret;\n+\t  ret = c_finish_omp_masked (loc, block,\n+\t\t\t\t     cclauses[C_OMP_CLAUSE_SPLIT_MASKED]);\n+\t  OMP_MASKED_COMBINED (ret) = 1;\n+\t  return ret;\n+\t}\n+    }\n+  if (!flag_openmp)  /* flag_openmp_simd  */\n+    {\n+      c_parser_skip_to_pragma_eol (parser, false);\n+      return NULL_TREE;\n+    }\n+\n+  clauses = c_parser_omp_all_clauses (parser, mask, p_name, cclauses == NULL);\n+  if (cclauses)\n+    {\n+      omp_split_clauses (loc, OMP_MASKED, mask, clauses, cclauses);\n+      clauses = cclauses[C_OMP_CLAUSE_SPLIT_MASKED];\n+    }\n+\n+  return c_finish_omp_masked (loc, c_parser_omp_structured_block (parser,\n+\t\t\t\t\t\t\t\t  if_p),\n+\t\t\t      clauses);\n+}\n+\n /* OpenMP 2.5:\n    # pragma omp ordered new-line\n      structured-block\n@@ -19237,7 +19339,36 @@ c_parser_omp_parallel (location_t loc, c_parser *parser,\n   else if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n-      if (cclauses == NULL && strcmp (p, \"master\") == 0)\n+      if (cclauses == NULL && strcmp (p, \"masked\") == 0)\n+\t{\n+\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  cclauses = cclauses_buf;\n+\n+\t  c_parser_consume_token (parser);\n+\t  if (!flag_openmp)  /* flag_openmp_simd  */\n+\t    return c_parser_omp_masked (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t\tif_p);\n+\t  block = c_begin_omp_parallel ();\n+\t  tree ret = c_parser_omp_masked (loc, parser, p_name, mask, cclauses,\n+\t\t\t\t\t  if_p);\n+\t  stmt = c_finish_omp_parallel (loc,\n+\t\t\t\t\tcclauses[C_OMP_CLAUSE_SPLIT_PARALLEL],\n+\t\t\t\t\tblock);\n+\t  if (ret == NULL)\n+\t    return ret;\n+\t  /* masked does have just filter clause, but during gimplification\n+\t     isn't represented by a gimplification omp context, so for\n+\t     #pragma omp parallel masked don't set OMP_PARALLEL_COMBINED,\n+\t     so that\n+\t     #pragma omp parallel masked\n+\t     #pragma omp taskloop simd lastprivate (x)\n+\t     isn't confused with\n+\t     #pragma omp parallel masked taskloop simd lastprivate (x)  */\n+\t  if (OMP_MASKED_COMBINED (ret))\n+\t    OMP_PARALLEL_COMBINED (stmt) = 1;\n+\t  return stmt;\n+\t}\n+      else if (cclauses == NULL && strcmp (p, \"master\") == 0)\n \t{\n \t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n \t  cclauses = cclauses_buf;\n@@ -21815,6 +21946,10 @@ c_parser_omp_construct (c_parser *parser, bool *if_p)\n       strcpy (p_name, \"#pragma omp\");\n       stmt = c_parser_omp_loop (loc, parser, p_name, mask, NULL, if_p);\n       break;\n+    case PRAGMA_OMP_MASKED:\n+      strcpy (p_name, \"#pragma omp\");\n+      stmt = c_parser_omp_masked (loc, parser, p_name, mask, NULL, if_p);\n+      break;\n     case PRAGMA_OMP_MASTER:\n       strcpy (p_name, \"#pragma omp\");\n       stmt = c_parser_omp_master (loc, parser, p_name, mask, NULL, if_p);"}, {"sha": "0c07af61f24f015f17d055ef398445333c9d8f85", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -15158,6 +15158,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \tcase OMP_CLAUSE_THREADS:\n \tcase OMP_CLAUSE_SIMD:\n \tcase OMP_CLAUSE_HINT:\n+\tcase OMP_CLAUSE_FILTER:\n \tcase OMP_CLAUSE_DEFAULTMAP:\n \tcase OMP_CLAUSE_BIND:\n \tcase OMP_CLAUSE_NUM_GANGS:"}, {"sha": "edb69aeb926932dcf230c06dcd6127723b8d4fb9", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 140, "deletions": 2, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -36004,7 +36004,9 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_DIST_SCHEDULE;\n \t  break;\n \tcase 'f':\n-\t  if (!strcmp (\"final\", p))\n+\t  if (!strcmp (\"filter\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_FILTER;\n+\t  else if (!strcmp (\"final\", p))\n \t    result = PRAGMA_OMP_CLAUSE_FINAL;\n \t  else if (!strcmp (\"finalize\", p))\n \t    result = PRAGMA_OACC_CLAUSE_FINALIZE;\n@@ -37340,6 +37342,34 @@ cp_parser_omp_clause_hint (cp_parser *parser, tree list, location_t location)\n   return c;\n }\n \n+/* OpenMP 5.1:\n+   filter ( integer-expression ) */\n+\n+static tree\n+cp_parser_omp_clause_filter (cp_parser *parser, tree list, location_t location)\n+{\n+  tree t, c;\n+\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    return list;\n+\n+  t = cp_parser_assignment_expression (parser);\n+\n+  if (t == error_mark_node\n+      || !parens.require_close (parser))\n+    cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n+\t\t\t\t\t   /*or_comma=*/false,\n+\t\t\t\t\t   /*consume_paren=*/true);\n+  check_no_duplicate_clause (list, OMP_CLAUSE_FILTER, \"filter\", location);\n+\n+  c = build_omp_clause (location, OMP_CLAUSE_FILTER);\n+  OMP_CLAUSE_FILTER_EXPR (c) = t;\n+  OMP_CLAUSE_CHAIN (c) = list;\n+\n+  return c;\n+}\n+\n /* OpenMP 4.5:\n    defaultmap ( tofrom : scalar )\n \n@@ -39449,6 +39479,11 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t\t\t\t\t\t  token->location, false);\n \t  c_name = \"default\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_FILTER:\n+\t  clauses = cp_parser_omp_clause_filter (parser, clauses,\n+\t\t\t\t\t\t token->location);\n+\t  c_name = \"filter\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_FINAL:\n \t  clauses = cp_parser_omp_clause_final (parser, clauses, token->location);\n \t  c_name = \"final\";\n@@ -41985,6 +42020,73 @@ cp_parser_omp_master (cp_parser *parser, cp_token *pragma_tok,\n \t\t\t      cp_parser_omp_structured_block (parser, if_p));\n }\n \n+/* OpenMP 5.1:\n+   # pragma omp masked masked-clauses new-line\n+     structured-block  */\n+\n+#define OMP_MASKED_CLAUSE_MASK\t\t\t\t\t\\\n+\t(OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_FILTER)\n+\n+static tree\n+cp_parser_omp_masked (cp_parser *parser, cp_token *pragma_tok,\n+\t\t      char *p_name, omp_clause_mask mask, tree *cclauses,\n+\t\t      bool *if_p)\n+{\n+  tree clauses, sb, ret;\n+  unsigned int save;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  strcat (p_name, \" masked\");\n+  mask |= OMP_MASKED_CLAUSE_MASK;\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+\n+      if (strcmp (p, \"taskloop\") == 0)\n+\t{\n+\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  if (cclauses == NULL)\n+\t    cclauses = cclauses_buf;\n+\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (!flag_openmp)  /* flag_openmp_simd  */\n+\t    return cp_parser_omp_taskloop (parser, pragma_tok, p_name, mask,\n+\t\t\t\t\t   cclauses, if_p);\n+\t  sb = begin_omp_structured_block ();\n+\t  save = cp_parser_begin_omp_structured_block (parser);\n+\t  ret = cp_parser_omp_taskloop (parser, pragma_tok, p_name, mask,\n+\t\t\t\t\tcclauses, if_p);\n+\t  cp_parser_end_omp_structured_block (parser, save);\n+\t  tree body = finish_omp_structured_block (sb);\n+\t  if (ret == NULL)\n+\t    return ret;\n+\t  ret = c_finish_omp_masked (loc, body,\n+\t\t\t\t     cclauses[C_OMP_CLAUSE_SPLIT_MASKED]);\n+\t  OMP_MASKED_COMBINED (ret) = 1;\n+\t  return ret;\n+\t}\n+    }\n+  if (!flag_openmp)  /* flag_openmp_simd  */\n+    {\n+      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+      return NULL_TREE;\n+    }\n+\n+  clauses = cp_parser_omp_all_clauses (parser, mask, p_name, pragma_tok,\n+\t\t\t\t       cclauses == NULL);\n+  if (cclauses)\n+    {\n+      cp_omp_split_clauses (loc, OMP_MASTER, mask, clauses, cclauses);\n+      clauses = cclauses[C_OMP_CLAUSE_SPLIT_MASKED];\n+    }\n+\n+  return c_finish_omp_masked (loc,\n+\t\t\t      cp_parser_omp_structured_block (parser, if_p),\n+\t\t\t      clauses);\n+}\n+\n /* OpenMP 2.5:\n    # pragma omp ordered new-line\n      structured-block\n@@ -42238,7 +42340,37 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok,\n     {\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n-      if (cclauses == NULL && strcmp (p, \"master\") == 0)\n+      if (cclauses == NULL && strcmp (p, \"masked\") == 0)\n+\t{\n+\t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n+\t  cclauses = cclauses_buf;\n+\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  if (!flag_openmp)  /* flag_openmp_simd  */\n+\t    return cp_parser_omp_masked (parser, pragma_tok, p_name, mask,\n+\t\t\t\t\t cclauses, if_p);\n+\t  block = begin_omp_parallel ();\n+\t  save = cp_parser_begin_omp_structured_block (parser);\n+\t  tree ret = cp_parser_omp_masked (parser, pragma_tok, p_name, mask,\n+\t\t\t\t\t   cclauses, if_p);\n+\t  cp_parser_end_omp_structured_block (parser, save);\n+\t  stmt = finish_omp_parallel (cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL],\n+\t\t\t\t      block);\n+\t  if (ret == NULL_TREE)\n+\t    return ret;\n+\t  /* masked does have just filter clause, but during gimplification\n+\t     isn't represented by a gimplification omp context, so for\n+\t     #pragma omp parallel masked don't set OMP_PARALLEL_COMBINED,\n+\t     so that\n+\t     #pragma omp parallel masked\n+\t     #pragma omp taskloop simd lastprivate (x)\n+\t     isn't confused with\n+\t     #pragma omp parallel masked taskloop simd lastprivate (x)  */\n+\t  if (OMP_MASKED_COMBINED (ret))\n+\t    OMP_PARALLEL_COMBINED (stmt) = 1;\n+\t  return stmt;\n+\t}\n+      else if (cclauses == NULL && strcmp (p, \"master\") == 0)\n \t{\n \t  tree cclauses_buf[C_OMP_CLAUSE_SPLIT_COUNT];\n \t  cclauses = cclauses_buf;\n@@ -45824,6 +45956,11 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n       stmt = cp_parser_omp_loop (parser, pragma_tok, p_name, mask, NULL,\n \t\t\t\t if_p);\n       break;\n+    case PRAGMA_OMP_MASKED:\n+      strcpy (p_name, \"#pragma omp\");\n+      stmt = cp_parser_omp_masked (parser, pragma_tok, p_name, mask, NULL,\n+\t\t\t\t   if_p);\n+      break;\n     case PRAGMA_OMP_MASTER:\n       strcpy (p_name, \"#pragma omp\");\n       stmt = cp_parser_omp_master (parser, pragma_tok, p_name, mask, NULL,\n@@ -46464,6 +46601,7 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n     case PRAGMA_OMP_DISTRIBUTE:\n     case PRAGMA_OMP_FOR:\n     case PRAGMA_OMP_LOOP:\n+    case PRAGMA_OMP_MASKED:\n     case PRAGMA_OMP_MASTER:\n     case PRAGMA_OMP_PARALLEL:\n     case PRAGMA_OMP_SECTIONS:"}, {"sha": "0870ccdc9f6865c39b62a00e0f0b8c9c1e46a40a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -17394,6 +17394,7 @@ tsubst_omp_clauses (tree clauses, enum c_omp_region_type ort,\n \tcase OMP_CLAUSE_PRIORITY:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_HINT:\n+\tcase OMP_CLAUSE_FILTER:\n \tcase OMP_CLAUSE_NUM_GANGS:\n \tcase OMP_CLAUSE_NUM_WORKERS:\n \tcase OMP_CLAUSE_VECTOR_LENGTH:\n@@ -18786,6 +18787,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       break;\n \n     case OMP_SECTIONS:\n+    case OMP_MASKED:\n       omp_parallel_combined_clauses = NULL;\n       /* FALLTHRU */\n     case OMP_SINGLE:"}, {"sha": "0198d2d8e8bbac71d821e4ae718c7eb24c001a5e", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -8204,6 +8204,29 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  break;\n \n+\tcase OMP_CLAUSE_FILTER:\n+\t  t = OMP_CLAUSE_FILTER_EXPR (c);\n+\t  if (t == error_mark_node)\n+\t    remove = true;\n+\t  else if (!type_dependent_expression_p (t)\n+\t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%<filter%> expression must be integral\");\n+\t      remove = true;\n+\t    }\n+\t  else\n+\t    {\n+\t      t = mark_rvalue_use (t);\n+\t      if (!processing_template_decl)\n+\t\t{\n+\t\t  t = maybe_constant_value (t);\n+\t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t\t}\n+\t      OMP_CLAUSE_FILTER_EXPR (c) = t;\n+\t    }\n+\t  break;\n+\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \t  field_ok = (ort & C_ORT_OMP_DECLARE_SIMD) == C_ORT_OMP;"}, {"sha": "832d5c3721c8cf01cb3c4a101af8473a059c0faf", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -334,6 +334,7 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_SINGLE:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_MASKED:\n     case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_SCAN:"}, {"sha": "1bccad12cc2efbf08fea5f2b47b1ecd69dd974bd", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -1658,6 +1658,35 @@ dump_gimple_omp_taskgroup (pretty_printer *buffer, const gimple *gs,\n     }\n }\n \n+/* Dump a GIMPLE_OMP_MASKED tuple on the pretty_printer BUFFER.  */\n+\n+static void\n+dump_gimple_omp_masked (pretty_printer *buffer, const gimple *gs,\n+\t\t\tint spc, dump_flags_t flags)\n+{\n+  if (flags & TDF_RAW)\n+    {\n+      dump_gimple_fmt (buffer, spc, flags, \"%G <%+BODY <%S>%nCLAUSES <\", gs,\n+\t\t       gimple_omp_body (gs));\n+      dump_omp_clauses (buffer, gimple_omp_masked_clauses (gs), spc, flags);\n+      dump_gimple_fmt (buffer, spc, flags, \" >\");\n+    }\n+  else\n+    {\n+      pp_string (buffer, \"#pragma omp masked\");\n+      dump_omp_clauses (buffer, gimple_omp_masked_clauses (gs), spc, flags);\n+      if (!gimple_seq_empty_p (gimple_omp_body (gs)))\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_left_brace (buffer);\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, gimple_omp_body (gs), spc + 4, flags);\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_right_brace (buffer);\n+\t}\n+    }\n+}\n+\n /* Dump a GIMPLE_OMP_TARGET tuple on the pretty_printer BUFFER.  */\n \n static void\n@@ -2722,6 +2751,10 @@ pp_gimple_stmt_1 (pretty_printer *buffer, const gimple *gs, int spc,\n       dump_gimple_omp_taskgroup (buffer, gs, spc, flags);\n       break;\n \n+    case GIMPLE_OMP_MASKED:\n+      dump_gimple_omp_masked (buffer, gs, spc, flags);\n+      break;\n+\n     case GIMPLE_OMP_MASTER:\n     case GIMPLE_OMP_SECTION:\n       dump_gimple_omp_block (buffer, gs, spc, flags);"}, {"sha": "9dd2e86b35b622c2d12f93354030459be447f5f0", "filename": "gcc/gimple-walk.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fgimple-walk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fgimple-walk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-walk.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -682,6 +682,7 @@ walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n       /* FALL THROUGH.  */\n     case GIMPLE_OMP_CRITICAL:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_MASKED:\n     case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_SCAN:"}, {"sha": "23bfc7fdcb7ce3d65b9597c3bfea61fdd12dadaa", "filename": "gcc/gimple.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -1038,6 +1038,21 @@ gimple_build_omp_master (gimple_seq body)\n   return p;\n }\n \n+/* Build a GIMPLE_OMP_MASKED statement.\n+\n+   BODY is the sequence of statements to be executed by the selected thread(s).  */\n+\n+gimple *\n+gimple_build_omp_masked (gimple_seq body, tree clauses)\n+{\n+  gimple *p = gimple_alloc (GIMPLE_OMP_MASKED, 0);\n+  gimple_omp_masked_set_clauses (p, clauses);\n+  if (body)\n+    gimple_omp_set_body (p, body);\n+\n+  return p;\n+}\n+\n /* Build a GIMPLE_OMP_TASKGROUP statement.\n \n    BODY is the sequence of statements to be executed by the taskgroup\n@@ -2031,6 +2046,11 @@ gimple_copy (gimple *stmt)\n \t  gimple_omp_set_body (copy, new_seq);\n \t  break;\n \n+\tcase GIMPLE_OMP_MASKED:\n+\t  t = unshare_expr (gimple_omp_masked_clauses (stmt));\n+\t  gimple_omp_masked_set_clauses (copy, t);\n+\t  goto copy_omp_body;\n+\n \tcase GIMPLE_TRANSACTION:\n \t  new_seq = gimple_seq_copy (gimple_transaction_body (\n \t\t\t\t       as_a <gtransaction *> (stmt)));"}, {"sha": "e66546c6be3d1e5f2d9c9467bb5ee59bfb35e12e", "filename": "gcc/gimple.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -279,6 +279,10 @@ DEFGSCODE(GIMPLE_OMP_FOR, \"gimple_omp_for\", GSS_OMP_FOR)\n    BODY is the sequence of statements to execute in the master section.  */\n DEFGSCODE(GIMPLE_OMP_MASTER, \"gimple_omp_master\", GSS_OMP)\n \n+/* GIMPLE_OMP_MASKED <BODY, CLAUSES> represents #pragma omp masked.\n+   BODY is the sequence of statements to execute in the masked section.  */\n+DEFGSCODE(GIMPLE_OMP_MASKED, \"gimple_omp_masked\", GSS_OMP_SINGLE_LAYOUT)\n+\n /* GIMPLE_OMP_TASKGROUP <BODY, CLAUSES> represents #pragma omp taskgroup.\n    BODY is the sequence of statements inside the taskgroup section.\n    CLAUSES is an OMP_CLAUSE chain holding the associated clauses.  */"}, {"sha": "7fd483d11ab5d4eedcb5b21c64a5e247ce68db2b", "filename": "gcc/gimple.h", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -1560,6 +1560,7 @@ gomp_task *gimple_build_omp_task (gimple_seq, tree, tree, tree, tree,\n \t\t\t\t       tree, tree);\n gimple *gimple_build_omp_section (gimple_seq);\n gimple *gimple_build_omp_master (gimple_seq);\n+gimple *gimple_build_omp_masked (gimple_seq, tree);\n gimple *gimple_build_omp_taskgroup (gimple_seq, tree);\n gomp_continue *gimple_build_omp_continue (tree, tree);\n gomp_ordered *gimple_build_omp_ordered (gimple_seq, tree);\n@@ -1836,6 +1837,7 @@ gimple_has_substatements (gimple *g)\n     case GIMPLE_TRY:\n     case GIMPLE_OMP_FOR:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_MASKED:\n     case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_SECTION:\n@@ -5205,6 +5207,40 @@ gimple_omp_taskgroup_set_clauses (gimple *gs, tree clauses)\n }\n \n \n+/* Return the clauses associated with OMP_MASTER statement GS.  */\n+\n+static inline tree\n+gimple_omp_masked_clauses (const gimple *gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_MASKED);\n+  return\n+    static_cast <const gimple_statement_omp_single_layout *> (gs)->clauses;\n+}\n+\n+\n+/* Return a pointer to the clauses associated with OMP masked statement\n+   GS.  */\n+\n+static inline tree *\n+gimple_omp_masked_clauses_ptr (gimple *gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_MASKED);\n+  return &static_cast <gimple_statement_omp_single_layout *> (gs)->clauses;\n+}\n+\n+\n+/* Set CLAUSES to be the clauses associated with OMP masked statement\n+   GS.  */\n+\n+static inline void\n+gimple_omp_masked_set_clauses (gimple *gs, tree clauses)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_OMP_MASKED);\n+  static_cast <gimple_statement_omp_single_layout *> (gs)->clauses\n+    = clauses;\n+}\n+\n+\n /* Return the kind of the OMP_FOR statemement G.  */\n \n static inline int\n@@ -6493,6 +6529,7 @@ gimple_return_set_retval (greturn *gs, tree retval)\n     case GIMPLE_OMP_TEAMS:\t\t\t\\\n     case GIMPLE_OMP_SECTION:\t\t\t\\\n     case GIMPLE_OMP_MASTER:\t\t\t\\\n+    case GIMPLE_OMP_MASKED:\t\t\t\\\n     case GIMPLE_OMP_TASKGROUP:\t\t\t\\\n     case GIMPLE_OMP_ORDERED:\t\t\t\\\n     case GIMPLE_OMP_CRITICAL:\t\t\t\\"}, {"sha": "eadbf83efcdcc21d5c700281fc553c1fa841e53f", "filename": "gcc/gimplify.c", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -5632,6 +5632,7 @@ is_gimple_stmt (tree t)\n     case OMP_SECTION:\n     case OMP_SINGLE:\n     case OMP_MASTER:\n+    case OMP_MASKED:\n     case OMP_TASKGROUP:\n     case OMP_ORDERED:\n     case OMP_CRITICAL:\n@@ -10102,6 +10103,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tcase OMP_CLAUSE_PRIORITY:\n \tcase OMP_CLAUSE_GRAINSIZE:\n \tcase OMP_CLAUSE_NUM_TASKS:\n+\tcase OMP_CLAUSE_FILTER:\n \tcase OMP_CLAUSE_HINT:\n \tcase OMP_CLAUSE_ASYNC:\n \tcase OMP_CLAUSE_WAIT:\n@@ -10110,9 +10112,20 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tcase OMP_CLAUSE_VECTOR_LENGTH:\n \tcase OMP_CLAUSE_WORKER:\n \tcase OMP_CLAUSE_VECTOR:\n-\t  if (gimplify_expr (&OMP_CLAUSE_OPERAND (c, 0), pre_p, NULL,\n-\t\t\t     is_gimple_val, fb_rvalue) == GS_ERROR)\n-\t    remove = true;\n+\t  if (OMP_CLAUSE_OPERAND (c, 0)\n+\t      && !is_gimple_min_invariant (OMP_CLAUSE_OPERAND (c, 0)))\n+\t    {\n+\t      if (error_operand_p (OMP_CLAUSE_OPERAND (c, 0)))\n+\t\t{\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n+\t      /* All these clauses care about value, not a particular decl,\n+\t\t so try to force it into a SSA_NAME or fresh temporary.  */\n+\t      OMP_CLAUSE_OPERAND (c, 0)\n+\t\t= get_initialized_tmp_var (OMP_CLAUSE_OPERAND (c, 0),\n+\t\t\t\t\t   pre_p, NULL, true);\n+\t    }\n \t  break;\n \n \tcase OMP_CLAUSE_GANG:\n@@ -11222,6 +11235,7 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \tcase OMP_CLAUSE_NOGROUP:\n \tcase OMP_CLAUSE_THREADS:\n \tcase OMP_CLAUSE_SIMD:\n+\tcase OMP_CLAUSE_FILTER:\n \tcase OMP_CLAUSE_HINT:\n \tcase OMP_CLAUSE_DEFAULTMAP:\n \tcase OMP_CLAUSE_ORDER:\n@@ -14766,6 +14780,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \tcase OMP_SECTION:\n \tcase OMP_MASTER:\n+\tcase OMP_MASKED:\n \tcase OMP_ORDERED:\n \tcase OMP_CRITICAL:\n \tcase OMP_SCAN:\n@@ -14788,6 +14803,15 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t      case OMP_ORDERED:\n \t\tg = gimplify_omp_ordered (*expr_p, body);\n \t\tbreak;\n+\t      case OMP_MASKED:\n+\t\tgimplify_scan_omp_clauses (&OMP_MASKED_CLAUSES (*expr_p),\n+\t\t\t\t\t   pre_p, ORT_WORKSHARE, OMP_MASKED);\n+\t\tgimplify_adjust_omp_clauses (pre_p, body,\n+\t\t\t\t\t     &OMP_MASKED_CLAUSES (*expr_p),\n+\t\t\t\t\t     OMP_MASKED);\n+\t\tg = gimple_build_omp_masked (body,\n+\t\t\t\t\t     OMP_MASKED_CLAUSES (*expr_p));\n+\t\tbreak;\n \t      case OMP_CRITICAL:\n \t\tgimplify_scan_omp_clauses (&OMP_CRITICAL_CLAUSES (*expr_p),\n \t\t\t\t\t   pre_p, ORT_WORKSHARE, OMP_CRITICAL);\n@@ -15161,6 +15185,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\t  && code != OMP_FOR\n \t\t  && code != OACC_LOOP\n \t\t  && code != OMP_MASTER\n+\t\t  && code != OMP_MASKED\n \t\t  && code != OMP_TASKGROUP\n \t\t  && code != OMP_ORDERED\n \t\t  && code != OMP_PARALLEL"}, {"sha": "1d4b39e4f78c6391139bf40d1559d6e87b5e80a5", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -8460,6 +8460,7 @@ expand_omp_synch (struct omp_region *region)\n   si = gsi_last_nondebug_bb (entry_bb);\n   gcc_assert (gimple_code (gsi_stmt (si)) == GIMPLE_OMP_SINGLE\n \t      || gimple_code (gsi_stmt (si)) == GIMPLE_OMP_MASTER\n+\t      || gimple_code (gsi_stmt (si)) == GIMPLE_OMP_MASKED\n \t      || gimple_code (gsi_stmt (si)) == GIMPLE_OMP_TASKGROUP\n \t      || gimple_code (gsi_stmt (si)) == GIMPLE_OMP_ORDERED\n \t      || gimple_code (gsi_stmt (si)) == GIMPLE_OMP_CRITICAL\n@@ -9947,6 +9948,7 @@ expand_omp (struct omp_region *region)\n \t  }\n \t  /* FALLTHRU */\n \tcase GIMPLE_OMP_MASTER:\n+\tcase GIMPLE_OMP_MASKED:\n \tcase GIMPLE_OMP_TASKGROUP:\n \tcase GIMPLE_OMP_CRITICAL:\n \tcase GIMPLE_OMP_TEAMS:\n@@ -10266,6 +10268,7 @@ omp_make_gimple_edges (basic_block bb, struct omp_region **region,\n     case GIMPLE_OMP_SINGLE:\n     case GIMPLE_OMP_TEAMS:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_MASKED:\n     case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_CRITICAL:\n     case GIMPLE_OMP_SECTION:"}, {"sha": "22ba579d11ce9f26d1d643d3cbef7ec1c1c0bfc7", "filename": "gcc/omp-low.c", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -1466,6 +1466,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_NUM_WORKERS:\n \tcase OMP_CLAUSE_VECTOR_LENGTH:\n \tcase OMP_CLAUSE_DETACH:\n+\tcase OMP_CLAUSE_FILTER:\n \t  if (ctx->outer)\n \t    scan_omp_op (&OMP_CLAUSE_OPERAND (c, 0), ctx->outer);\n \t  break;\n@@ -1868,6 +1869,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE__SIMT_:\n \tcase OMP_CLAUSE_IF_PRESENT:\n \tcase OMP_CLAUSE_FINALIZE:\n+\tcase OMP_CLAUSE_FILTER:\n \tcase OMP_CLAUSE__CONDTEMP_:\n \t  break;\n \n@@ -3426,6 +3428,7 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t  case GIMPLE_OMP_SINGLE:\n \t  case GIMPLE_OMP_ORDERED:\n \t  case GIMPLE_OMP_MASTER:\n+\t  case GIMPLE_OMP_MASKED:\n \t  case GIMPLE_OMP_TASK:\n \t  case GIMPLE_OMP_CRITICAL:\n \t    if (is_gimple_call (stmt))\n@@ -3436,14 +3439,15 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t\terror_at (gimple_location (stmt),\n \t\t\t  \"barrier region may not be closely nested inside \"\n \t\t\t  \"of work-sharing, %<loop%>, %<critical%>, \"\n-\t\t\t  \"%<ordered%>, %<master%>, explicit %<task%> or \"\n-\t\t\t  \"%<taskloop%> region\");\n+\t\t\t  \"%<ordered%>, %<master%>, %<masked%>, explicit \"\n+\t\t\t  \"%<task%> or %<taskloop%> region\");\n \t\treturn false;\n \t      }\n \t    error_at (gimple_location (stmt),\n \t\t      \"work-sharing region may not be closely nested inside \"\n \t\t      \"of work-sharing, %<loop%>, %<critical%>, %<ordered%>, \"\n-\t\t      \"%<master%>, explicit %<task%> or %<taskloop%> region\");\n+\t\t      \"%<master%>, %<masked%>, explicit %<task%> or \"\n+\t\t      \"%<taskloop%> region\");\n \t    return false;\n \t  case GIMPLE_OMP_PARALLEL:\n \t  case GIMPLE_OMP_TEAMS:\n@@ -3458,6 +3462,7 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t  }\n       break;\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_MASKED:\n       for (; ctx != NULL; ctx = ctx->outer)\n \tswitch (gimple_code (ctx->stmt))\n \t  {\n@@ -3470,9 +3475,11 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t  case GIMPLE_OMP_SINGLE:\n \t  case GIMPLE_OMP_TASK:\n \t    error_at (gimple_location (stmt),\n-\t\t      \"%<master%> region may not be closely nested inside \"\n+\t\t      \"%qs region may not be closely nested inside \"\n \t\t      \"of work-sharing, %<loop%>, explicit %<task%> or \"\n-\t\t      \"%<taskloop%> region\");\n+\t\t      \"%<taskloop%> region\",\n+\t\t      gimple_code (stmt) == GIMPLE_OMP_MASTER\n+\t\t      ? \"master\" : \"masked\");\n \t    return false;\n \t  case GIMPLE_OMP_PARALLEL:\n \t  case GIMPLE_OMP_TEAMS:\n@@ -4079,6 +4086,12 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       scan_omp (gimple_omp_body_ptr (stmt), ctx);\n       break;\n \n+    case GIMPLE_OMP_MASKED:\n+      ctx = new_omp_context (stmt, ctx);\n+      scan_sharing_clauses (gimple_omp_masked_clauses (stmt), ctx);\n+      scan_omp (gimple_omp_body_ptr (stmt), ctx);\n+      break;\n+\n     case GIMPLE_OMP_TASKGROUP:\n       ctx = new_omp_context (stmt, ctx);\n       scan_sharing_clauses (gimple_omp_taskgroup_clauses (stmt), ctx);\n@@ -8675,7 +8688,7 @@ lower_omp_single (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n }\n \n \n-/* Expand code for an OpenMP master directive.  */\n+/* Expand code for an OpenMP master or masked directive.  */\n \n static void\n lower_omp_master (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n@@ -8685,17 +8698,28 @@ lower_omp_master (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   gbind *bind;\n   location_t loc = gimple_location (stmt);\n   gimple_seq tseq;\n+  tree filter = integer_zero_node;\n \n   push_gimplify_context ();\n \n+  if (gimple_code (stmt) == GIMPLE_OMP_MASKED)\n+    {\n+      filter = omp_find_clause (gimple_omp_masked_clauses (stmt),\n+\t\t\t\tOMP_CLAUSE_FILTER);\n+      if (filter)\n+\tfilter = fold_convert (integer_type_node,\n+\t\t\t       OMP_CLAUSE_FILTER_EXPR (filter));\n+      else\n+\tfilter = integer_zero_node;\n+    }\n   block = make_node (BLOCK);\n   bind = gimple_build_bind (NULL, NULL, block);\n   gsi_replace (gsi_p, bind, true);\n   gimple_bind_add_stmt (bind, stmt);\n \n   bfn_decl = builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM);\n   x = build_call_expr_loc (loc, bfn_decl, 0);\n-  x = build2 (EQ_EXPR, boolean_type_node, x, integer_zero_node);\n+  x = build2 (EQ_EXPR, boolean_type_node, x, filter);\n   x = build3 (COND_EXPR, void_type_node, x, NULL, build_and_jump (&lab));\n   tseq = NULL;\n   gimplify_and_add (x, &tseq);\n@@ -13869,6 +13893,7 @@ lower_omp_1 (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       lower_omp_single (gsi_p, ctx);\n       break;\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_MASKED:\n       ctx = maybe_lookup_ctx (stmt);\n       gcc_assert (ctx);\n       lower_omp_master (gsi_p, ctx);\n@@ -14246,6 +14271,7 @@ diagnose_sb_1 (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n     case GIMPLE_OMP_SINGLE:\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_MASKED:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_SCAN:\n     case GIMPLE_OMP_CRITICAL:\n@@ -14307,6 +14333,7 @@ diagnose_sb_2 (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n     case GIMPLE_OMP_SINGLE:\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_MASKED:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_SCAN:\n     case GIMPLE_OMP_CRITICAL:"}, {"sha": "683ac1b8c45dbce784d2006c8f7f10530ea2de63", "filename": "gcc/testsuite/c-c++-common/goacc/uninit-if-clause.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Funinit-if-clause.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Funinit-if-clause.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Funinit-if-clause.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -1,6 +1,5 @@\n /* { dg-do compile } */\n /* { dg-additional-options \"-Wuninitialized\" } */\n-/* { dg-excess-errors \"PR70392\" { xfail c++ } } */\n \n #include <stdbool.h>\n \n@@ -14,25 +13,25 @@ main (void)\n   #pragma acc parallel if(l) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n-  #pragma acc parallel if(b) /* { dg-warning \"is used uninitialized\" \"\" { xfail c++ } } */\n+  #pragma acc parallel if(b) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n   #pragma acc kernels if(l2) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n-  #pragma acc kernels if(b2) /* { dg-warning \"is used uninitialized\" \"\" { xfail c++ } } */\n+  #pragma acc kernels if(b2) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n   #pragma acc data if(l3) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n-  #pragma acc data if(b3) /* { dg-warning \"is used uninitialized\" \"\" { xfail c++ } } */\n+  #pragma acc data if(b3) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n   #pragma acc update if(l4) self(i) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n-  #pragma acc update if(b4) self(i2) /* { dg-warning \"is used uninitialized\" \"\" { xfail c++ } } */\n+  #pragma acc update if(b4) self(i2) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n }"}, {"sha": "7b71ad37f9c7742c5ec26d62edac80add524771f", "filename": "gcc/testsuite/c-c++-common/gomp/clause-dups-1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclause-dups-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclause-dups-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclause-dups-1.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -203,7 +203,8 @@ f1 (int *p)\n   i = p[0]++;\n   #pragma omp atomic capture hint(0) hint (0)\t\t\t/* { dg-error \"too many 'hint' clauses\" } */\n   i = p[0]++;\n-  \n+  #pragma omp masked filter (0) filter (0)\t\t\t/* { dg-error \"too many 'filter' clauses\" } */\n+  f0 ();\n }\n \n #pragma omp declare simd simdlen (4) simdlen (4)\t\t/* { dg-error \"too many 'simdlen' clauses\" } */"}, {"sha": "378c7bf55a3e112ed313110fef52de5fda86dccf", "filename": "gcc/testsuite/c-c++-common/gomp/clauses-1.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-1.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -273,54 +273,106 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) reduction(+:r) \\\n     num_threads (nth) proc_bind(spread) copyin(t) allocate (f)\n     ;\n+  #pragma omp parallel masked \\\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) reduction(+:r) \\\n+    num_threads (nth) proc_bind(spread) copyin(t) allocate (f) filter (d)\n+    ;\n   #pragma omp taskgroup task_reduction (+:r2) allocate (r2)\n   #pragma omp master taskloop \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable priority (pp) \\\n     reduction(default, +:r) in_reduction(+:r2) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp taskgroup task_reduction (+:r2) allocate (r2)\n+  #pragma omp masked taskloop \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable priority (pp) \\\n+    reduction(default, +:r) in_reduction(+:r2) allocate (f) filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskgroup task_reduction (+:r2) allocate (r2)\n   #pragma omp master taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) \\\n     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) \\\n     order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  #pragma omp taskgroup task_reduction (+:r2) allocate (r2)\n+  #pragma omp masked taskloop simd \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) \\\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) \\\n+    order(concurrent) allocate (f) filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   #pragma omp parallel master taskloop \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable priority (pp) \\\n     reduction(default, +:r) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  #pragma omp parallel masked taskloop \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable priority (pp) \\\n+    reduction(default, +:r) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t) allocate (f) filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   #pragma omp parallel master taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) \\\n     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t) \\\n     order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  #pragma omp parallel masked taskloop simd \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp) \\\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t) \\\n+    order(concurrent) allocate (f) filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   #pragma omp taskgroup task_reduction (+:r2) allocate (r2)\n   #pragma omp master taskloop \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n     reduction(default, +:r) in_reduction(+:r2)\n   for (int i = 0; i < 64; i++)\n     ll++;\n   #pragma omp taskgroup task_reduction (+:r2) allocate (r2)\n+  #pragma omp mastked taskloop \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n+    reduction(default, +:r) in_reduction(+:r2) filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n+  #pragma omp taskgroup task_reduction (+:r2) allocate (r2)\n   #pragma omp master taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) \\\n     order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  #pragma omp taskgroup task_reduction (+:r2) allocate (r2)\n+  #pragma omp masked taskloop simd \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm) \\\n+    order(concurrent) allocate (f) filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   #pragma omp parallel master taskloop \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n     reduction(default, +:r) num_threads (nth) proc_bind(spread) copyin(t) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  #pragma omp parallel masked taskloop \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n+    reduction(default, +:r) num_threads (nth) proc_bind(spread) copyin(t) allocate (f) filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   #pragma omp parallel master taskloop simd \\\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) num_threads (nth) proc_bind(spread) copyin(t) \\\n     order(concurrent) allocate (f)\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  #pragma omp parallel masked taskloop simd \\\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp) \\\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) num_threads (nth) proc_bind(spread) copyin(t) \\\n+    order(concurrent) allocate (f) filter (d)\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   #pragma omp loop bind(thread) order(concurrent) \\\n     private (p) lastprivate (l) collapse(1) reduction(+:r)\n   for (l = 0; l < 64; ++l)"}, {"sha": "87e53a94ac39017ce684c6272635ef9bbaf86dbb", "filename": "gcc/testsuite/c-c++-common/gomp/clauses-5.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fclauses-5.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -49,4 +49,6 @@ foo (int *p)\n   ;\n   #pragma omp critical (baz) hint (2, 3)\t/* { dg-error \"expected\" } */\n   ;\n+  #pragma omp masked filter (3, 4)\t\t/* { dg-error \"expected\" } */\n+  ;\n }"}, {"sha": "36c2e4928923cc75bf2ecbb6cacf878e2e731122", "filename": "gcc/testsuite/c-c++-common/gomp/masked-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmasked-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmasked-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmasked-1.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -0,0 +1,23 @@\n+void bar (void);\n+\n+void\n+foo (int x, int *a)\n+{\n+  #pragma omp masked\n+  bar ();\n+  #pragma omp masked filter (0)\n+  bar ();\n+  #pragma omp masked filter (7)\n+  bar ();\n+  #pragma omp masked filter (x)\n+  bar ();\n+  #pragma omp masked taskloop simd filter (x) grainsize (12) simdlen (4)\n+  for (int i = 0; i < 128; i++)\n+    a[i] = i;\n+  #pragma omp parallel masked filter (x) firstprivate (x)\n+  bar ();\n+  #pragma omp masked\n+  #pragma omp masked filter (0)\n+  #pragma omp masked filter (x)\n+  ;\n+}"}, {"sha": "7230c82b9570af1dd178fb179feb647388187dcf", "filename": "gcc/testsuite/c-c++-common/gomp/masked-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmasked-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmasked-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmasked-2.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -0,0 +1,11 @@\n+void bar (void);\n+struct S { int s; };\n+\n+void\n+foo (float f, struct S s)\n+{\n+  #pragma omp masked filter (0.0)\t/* { dg-error \"integral|integer\" } */\n+  bar ();\n+  #pragma omp masked filter (s)\t\t/* { dg-error \"integral|integer\" } */\n+  bar ();\n+}"}, {"sha": "0b3ff58ff0e890648208cdfe892ad542b716dacf", "filename": "gcc/testsuite/c-c++-common/gomp/masked-combined-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmasked-combined-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmasked-combined-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmasked-combined-1.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -0,0 +1,37 @@\n+void bar (int *);\n+\n+void\n+foo (int *a, int f)\n+{\n+  int i, j, k, u = 0, v = 0, w = 0, x = 0, y = 0, z = 0;\n+  #pragma omp parallel masked default(none) private (k) filter (f) firstprivate (f)\n+  bar (&k);\n+  #pragma omp parallel masked default(none) private (k)\n+  bar (&k);\n+  #pragma omp parallel default(none) firstprivate(a, f) shared(x, y, z)\n+  {\n+    #pragma omp masked taskloop reduction (+:x) default(none) firstprivate(a) filter (f)\n+    for (i = 0; i < 64; i++)\n+      x += a[i];\n+    #pragma omp masked taskloop simd reduction (+:y) default(none) firstprivate(a) private (i) filter (f)\n+    for (i = 0; i < 64; i++)\n+      y += a[i];\n+    #pragma omp masked taskloop simd reduction (+:y) default(none) firstprivate(a) private (i)\n+    for (i = 0; i < 64; i++)\n+      y += a[i];\n+    #pragma omp masked taskloop simd collapse(2) reduction (+:z) default(none) firstprivate(a) private (i, j) filter (f)\n+    for (j = 0; j < 1; j++)\n+      for (i = 0; i < 64; ++i)\n+\tz += a[i];\n+  }\n+  #pragma omp parallel masked taskloop reduction (+:u) default(none) firstprivate(a, f) filter (f)\n+  for (i = 0; i < 64; i++)\n+    u += a[i];\n+  #pragma omp parallel masked taskloop simd reduction (+:v) default(none) firstprivate(a, f) filter (f)\n+  for (i = 0; i < 64; i++)\n+    v += a[i];\n+  #pragma omp parallel masked taskloop simd collapse(2) reduction (+:w) default(none) firstprivate(a, f) filter (f)\n+  for (j = 0; j < 1; j++)\n+    for (i = 0; i < 64; ++i)\n+      w += a[i];\n+}"}, {"sha": "1d639699da994012cd5d61eb19c40ad51f58cf5d", "filename": "gcc/testsuite/c-c++-common/gomp/masked-combined-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmasked-combined-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmasked-combined-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fmasked-combined-2.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -0,0 +1,13 @@\n+void\n+foo (int *a)\n+{\n+  int i, r = 0, s = 0;\n+  #pragma omp taskgroup task_reduction(+:r)\n+  #pragma omp parallel masked taskloop in_reduction(+:r)\t/* { dg-error \"'in_reduction' is not valid for '#pragma omp parallel masked taskloop'\" } */\n+  for (i = 0; i < 64; i++)\n+    r += a[i];\n+  #pragma omp taskgroup task_reduction(+:s)\n+  #pragma omp parallel masked taskloop simd in_reduction(+:s)\t/* { dg-error \"'in_reduction' is not valid for '#pragma omp parallel masked taskloop simd'\" } */\n+  for (i = 0; i < 64; i++)\n+    s += a[i];\n+}"}, {"sha": "c3483756dd6edff68c2d805f7c276f933571f543", "filename": "gcc/testsuite/g++.dg/gomp/attrs-1.C", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-1.C?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -348,6 +348,10 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) reduction(+:r)\n     num_threads (nth) proc_bind(spread) copyin(t) allocate (f))]]\n     ;\n+  [[omp::directive (parallel masked\n+    private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) reduction(+:r)\n+    num_threads (nth) proc_bind(spread) copyin(t) allocate (f) filter (d))]]\n+    ;\n   [[omp::directive (parallel\n     private (p) firstprivate (f) if (parallel: i2) default(shared) shared(s) reduction(+:r)\n     num_threads (nth) proc_bind(spread) copyin(t) allocate (f))]]\n@@ -358,49 +362,99 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     reduction(default, +:r) in_reduction(+:r2) allocate (f)))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[omp::sequence (directive (taskgroup task_reduction (+:r2) allocate (r2)),\n+    omp::directive (masked taskloop\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable priority (pp)\n+    reduction(default, +:r) in_reduction(+:r2) allocate (f) filter (d)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[omp::directive (master)]];\n+  [[omp::directive (masked)]];\n+  [[omp::directive (masked filter (d))]];\n   [[omp::sequence (omp::directive (taskgroup task_reduction (+:r2) allocate (r2)),\n     directive (master taskloop simd\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp)\n     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm)\n     order(concurrent) allocate (f)))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[omp::sequence (omp::directive (taskgroup task_reduction (+:r2) allocate (r2)),\n+    directive (masked taskloop simd\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm)\n+    order(concurrent) allocate (f) filter (d)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[omp::directive (parallel master taskloop\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable priority (pp)\n     reduction(default, +:r) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t) allocate (f))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[omp::directive (parallel masked taskloop\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) final(fi) mergeable priority (pp)\n+    reduction(default, +:r) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t) allocate (f) filter (d))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[omp::directive (parallel master taskloop simd\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp)\n     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t)\n     order(concurrent) allocate (f))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[omp::directive (parallel masked taskloop simd\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) grainsize (g) collapse(1) untied if(taskloop: i1) if(simd: i2) final(fi) mergeable priority (pp)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) if (parallel: i2) num_threads (nth) proc_bind(spread) copyin(t)\n+    order(concurrent) allocate (f) filter (d))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[omp::sequence (directive (taskgroup task_reduction (+:r2) allocate (r2)),\n     directive (master taskloop\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp)\n     reduction(default, +:r) in_reduction(+:r2)))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[omp::sequence (directive (taskgroup task_reduction (+:r2) allocate (r2)),\n+    directive (masked taskloop\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp)\n+    reduction(default, +:r) in_reduction(+:r2) filter (d)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[omp::sequence (omp::directive (taskgroup task_reduction (+:r2) allocate (r2)),\n     omp::directive (master taskloop simd\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp)\n     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm)\n     order(concurrent) allocate (f)))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[omp::sequence (omp::directive (taskgroup task_reduction (+:r2) allocate (r2)),\n+    omp::directive (masked taskloop simd\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) in_reduction(+:r2) nontemporal(ntm)\n+    order(concurrent) allocate (f) filter (d)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[omp::directive (parallel master taskloop\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp)\n     reduction(default, +:r) num_threads (nth) proc_bind(spread) copyin(t) allocate (f))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[omp::directive (parallel masked taskloop\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp)\n+    reduction(default, +:r) num_threads (nth) proc_bind(spread) copyin(t) allocate (f) filter (d))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[omp::directive (parallel master taskloop simd\n     private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp)\n     safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) num_threads (nth) proc_bind(spread) copyin(t)\n     order(concurrent) allocate (f))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[omp::directive (parallel masked taskloop simd\n+    private (p) firstprivate (f) lastprivate (l) shared (s) default(shared) num_tasks (nta) collapse(1) untied if(i1) final(fi) mergeable priority (pp)\n+    safelen(8) simdlen(4) linear(ll: 1) aligned(q: 32) reduction(default, +:r) nontemporal(ntm) num_threads (nth) proc_bind(spread) copyin(t)\n+    order(concurrent) allocate (f) filter (d))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[omp::directive (loop bind(thread) order(concurrent)\n     private (p) lastprivate (l) collapse(1) reduction(+:r))]]\n   for (l = 0; l < 64; ++l)"}, {"sha": "b2fba21d71ab6060582b4b7d4a57069e536fbec8", "filename": "gcc/testsuite/g++.dg/gomp/attrs-2.C", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fattrs-2.C?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -348,6 +348,10 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     private (p),firstprivate (f),if (parallel: i2),default(shared),shared(s),reduction(+:r),\n     num_threads (nth),proc_bind(spread),copyin(t),allocate (f))]]\n     ;\n+  [[omp::directive (parallel masked,\n+    private (p),firstprivate (f),if (parallel: i2),default(shared),shared(s),reduction(+:r),\n+    num_threads (nth),proc_bind(spread),copyin(t),allocate (f),filter(d))]]\n+    ;\n   [[omp::directive (parallel,\n     private (p),firstprivate (f),if (parallel: i2),default(shared),shared(s),reduction(+:r),\n     num_threads (nth),proc_bind(spread),copyin(t),allocate (f))]]\n@@ -358,49 +362,99 @@ bar (int d, int m, int i1, int i2, int i3, int p, int *idp, int s,\n     reduction(default, +:r),in_reduction(+:r2),allocate (f)))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[using omp:sequence (directive (taskgroup, task_reduction (+:r2),allocate (r2)),\n+    omp::directive (masked taskloop,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),grainsize (g),collapse(1),untied, if(taskloop: i1),final(fi),mergeable, priority (pp),\n+    reduction(default, +:r),in_reduction(+:r2),allocate (f),filter(d)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[using omp:directive (master)]];\n+  [[using omp:directive (masked)]];\n+  [[using omp:directive (masked,filter(d))]];\n   [[omp::sequence (omp::directive (taskgroup task_reduction (+:r2),allocate (r2)),\n     directive (master taskloop simd,\n     private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),grainsize (g),collapse(1),untied,if(taskloop: i1),if(simd: i2),final(fi),mergeable,priority (pp),\n     safelen(8),simdlen(4),linear(ll: 1),aligned(q: 32),reduction(default, +:r),in_reduction(+:r2),nontemporal(ntm),\n     order(concurrent),allocate (f)))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[omp::sequence (omp::directive (taskgroup task_reduction (+:r2),allocate (r2)),\n+    directive (masked taskloop simd,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),grainsize (g),collapse(1),untied,if(taskloop: i1),if(simd: i2),final(fi),mergeable,priority (pp),\n+    safelen(8),simdlen(4),linear(ll: 1),aligned(q: 32),reduction(default, +:r),in_reduction(+:r2),nontemporal(ntm),\n+    order(concurrent),allocate (f),filter(d)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[omp::directive (parallel master taskloop,\n     private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),grainsize (g),collapse(1),untied,if(taskloop: i1),final(fi),mergeable,priority (pp),\n     reduction(default, +:r),if (parallel: i2),num_threads (nth),proc_bind(spread),copyin(t),allocate (f))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[omp::directive (parallel masked taskloop,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),grainsize (g),collapse(1),untied,if(taskloop: i1),final(fi),mergeable,priority (pp),\n+    reduction(default, +:r),if (parallel: i2),num_threads (nth),proc_bind(spread),copyin(t),allocate (f),filter(d))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[omp::directive (parallel master taskloop simd,\n     private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),grainsize (g),collapse(1),untied,if(taskloop: i1),if(simd: i2),final(fi),mergeable,priority (pp),\n     safelen(8),simdlen(4),linear(ll: 1),aligned(q: 32),reduction(default, +:r),nontemporal(ntm),if (parallel: i2),num_threads (nth),proc_bind(spread),copyin(t),\n     order(concurrent),allocate (f))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[omp::directive (parallel masked taskloop simd,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),grainsize (g),collapse(1),untied,if(taskloop: i1),if(simd: i2),final(fi),mergeable,priority (pp),\n+    safelen(8),simdlen(4),linear(ll: 1),aligned(q: 32),reduction(default, +:r),nontemporal(ntm),if (parallel: i2),num_threads (nth),proc_bind(spread),copyin(t),\n+    order(concurrent),allocate (f),filter(d))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[omp::sequence (directive (taskgroup,task_reduction (+:r2),allocate (r2)),\n     directive (master taskloop,\n     private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),num_tasks (nta),collapse(1),untied,if(i1),final(fi),mergeable,priority (pp),\n     reduction(default, +:r),in_reduction(+:r2)))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[omp::sequence (directive (taskgroup,task_reduction (+:r2),allocate (r2)),\n+    directive (masked taskloop,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),num_tasks (nta),collapse(1),untied,if(i1),final(fi),mergeable,priority (pp),\n+    reduction(default, +:r),in_reduction(+:r2),filter(d)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[omp::sequence (omp::directive (taskgroup,task_reduction (+:r2),allocate (r2)),\n     omp::directive (master taskloop simd,\n     private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),num_tasks (nta),collapse(1),untied,if(i1),final(fi),mergeable,priority (pp),\n     safelen(8),simdlen(4),linear(ll: 1),aligned(q: 32),reduction(default, +:r),in_reduction(+:r2),nontemporal(ntm),\n     order(concurrent),allocate (f)))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[omp::sequence (omp::directive (taskgroup,task_reduction (+:r2),allocate (r2)),\n+    omp::directive (masked taskloop simd,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),num_tasks (nta),collapse(1),untied,if(i1),final(fi),mergeable,priority (pp),\n+    safelen(8),simdlen(4),linear(ll: 1),aligned(q: 32),reduction(default, +:r),in_reduction(+:r2),nontemporal(ntm),\n+    order(concurrent),allocate (f),filter(d)))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[omp::directive (parallel master taskloop,\n     private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),num_tasks (nta),collapse(1),untied if(i1),final(fi),mergeable priority (pp),\n     reduction(default, +:r),num_threads (nth),proc_bind(spread),copyin(t),allocate (f))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[omp::directive (parallel masked taskloop,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),num_tasks (nta),collapse(1),untied if(i1),final(fi),mergeable priority (pp),\n+    reduction(default, +:r),num_threads (nth),proc_bind(spread),copyin(t),allocate (f),filter(d))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[omp::directive (parallel master taskloop simd,\n     private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),num_tasks (nta),collapse(1),untied if(i1),final(fi),mergeable priority (pp),\n     safelen(8),simdlen(4),linear(ll: 1),aligned(q: 32),reduction(default, +:r),nontemporal(ntm),num_threads (nth),proc_bind(spread),copyin(t),\n     order(concurrent),allocate (f))]]\n   for (int i = 0; i < 64; i++)\n     ll++;\n+  [[omp::directive (parallel masked taskloop simd,\n+    private (p),firstprivate (f),lastprivate (l),shared (s),default(shared),num_tasks (nta),collapse(1),untied if(i1),final(fi),mergeable priority (pp),\n+    safelen(8),simdlen(4),linear(ll: 1),aligned(q: 32),reduction(default, +:r),nontemporal(ntm),num_threads (nth),proc_bind(spread),copyin(t),\n+    order(concurrent),allocate (f),filter(d))]]\n+  for (int i = 0; i < 64; i++)\n+    ll++;\n   [[omp::directive (loop, bind(thread),order(concurrent),\n     private (p),lastprivate (l),collapse(1),reduction(+:r))]]\n   for (l = 0; l < 64; ++l)"}, {"sha": "cf4b0d37c3d41f216770f0a66844839a7d7b8075", "filename": "gcc/testsuite/g++.dg/gomp/block-11.C", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fblock-11.C?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -1,3 +1,21 @@\n+// { dg-do compile }\n+\n+void foo()\n+{\n+  #pragma omp masked\n+    {\n+      goto bad1;\t// { dg-message \"from here\" }\n+    }\n+\n+  #pragma omp masked filter(1)\n+    {\n+    bad1:\t\t// { dg-error \"jump\" }\n+\t\t\t// { dg-message \"exits OpenMP\" \"\" { target *-*-* } .-1 }\n+      return;\t\t// { dg-error \"invalid exit\" }\n+    }\n+}\n+\n+// { dg-message \"error: invalid branch to/from OpenMP structured block\" \"\" { target *-*-* } 7 }\n /* PR c++/24516 */\n /* { dg-do compile } */\n "}, {"sha": "8574861ed238fc24a88c149c32ad7114c89ceac3", "filename": "gcc/testsuite/g++.dg/gomp/tpl-masked-1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-masked-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-masked-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftpl-masked-1.C?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp -fdump-tree-gimple\" }\n+\n+int i;\n+\n+template <typename T> void f1 (bool p, T t)\n+{\n+  if (p)\n+    {\n+      #pragma omp masked filter (t)\n+\ti++;\n+    }\n+}\n+\n+void f2 ()\n+{\n+  f1<int> (true, 0);\n+  f1<long> (true, 0L);\n+}\n+\n+// { dg-final { scan-tree-dump-times \"#pragma omp masked\" 2 \"gimple\" } }"}, {"sha": "4a471c8fbb69702120a7910f1286d4ecf7e67732", "filename": "gcc/testsuite/gcc.dg/gomp/nesting-1.c", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fnesting-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fnesting-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fnesting-1.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -19,8 +19,10 @@ f1 (void)\n       }\n       #pragma omp single\t/* { dg-error \"may not be closely nested\" } */\n \t;\n-    #pragma omp master\t\t/* { dg-error \"may not be closely nested\" } */\n-      ;\n+      #pragma omp master\t/* { dg-error \"may not be closely nested\" } */\n+\t;\n+      #pragma omp masked\t/* { dg-error \"may not be closely nested\" } */\n+\t;\n       #pragma omp barrier\t/* { dg-error \"may not be closely nested\" } */\n     }\n   #pragma omp sections\n@@ -49,6 +51,11 @@ f1 (void)\n       ;\n   }\n   #pragma omp sections\n+  {\n+    #pragma omp masked\t\t/* { dg-error \"may not be closely nested\" } */\n+      ;\n+  }\n+  #pragma omp sections\n   {\n     #pragma omp section\n       ;\n@@ -81,6 +88,9 @@ f1 (void)\n     #pragma omp section\n     #pragma omp master\t\t/* { dg-error \"may not be closely nested\" } */\n       ;\n+    #pragma omp section\n+    #pragma omp masked\t\t/* { dg-error \"may not be closely nested\" } */\n+      ;\n   }\n   #pragma omp single\n   {\n@@ -97,6 +107,8 @@ f1 (void)\n       ;\n     #pragma omp master\t\t/* { dg-error \"may not be closely nested\" } */\n       ;\n+    #pragma omp masked\t\t/* { dg-error \"may not be closely nested\" } */\n+      ;\n     #pragma omp barrier\t\t/* { dg-error \"may not be closely nested\" } */\n   }\n   #pragma omp master\n@@ -116,6 +128,23 @@ f1 (void)\n       ;\n     #pragma omp barrier\t\t/* { dg-error \"may not be closely nested\" } */\n   }\n+  #pragma omp masked filter (1)\n+  {\n+    #pragma omp for\t\t/* { dg-error \"may not be closely nested\" } */\n+    for (j = 0; j < 3; j++)\n+      ;\n+    #pragma omp sections\t/* { dg-error \"may not be closely nested\" } */\n+    {\n+      ;\n+    #pragma omp section\n+      ;\n+    }\n+    #pragma omp single\t\t/* { dg-error \"may not be closely nested\" } */\n+      ;\n+    #pragma omp master\n+      ;\n+    #pragma omp barrier\t\t/* { dg-error \"may not be closely nested\" } */\n+  }\n   #pragma omp task\n   {\n     #pragma omp for\t\t/* { dg-error \"may not be closely nested\" } */\n@@ -131,6 +160,8 @@ f1 (void)\n       ;\n     #pragma omp master\t\t/* { dg-error \"may not be closely nested\" } */\n       ;\n+    #pragma omp masked\t\t/* { dg-error \"may not be closely nested\" } */\n+      ;\n     #pragma omp barrier\t\t/* { dg-error \"may not be closely nested\" } */\n   }\n   #pragma omp parallel\n@@ -148,6 +179,8 @@ f1 (void)\n       ;\n     #pragma omp master\n       ;\n+    #pragma omp masked\n+      ;\n     #pragma omp barrier\n   }\n }\n@@ -171,6 +204,8 @@ f2 (void)\n       ;\n     #pragma omp master\n       ;\n+    #pragma omp masked\n+      ;\n     #pragma omp barrier\t\t/* { dg-error \"may not be closely nested\" } */\n   }\n }"}, {"sha": "e575890c9fcc6ba393ff222a0a7cf9fc291909af", "filename": "gcc/testsuite/gfortran.dg/goacc/host_data-tree.f95", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fhost_data-tree.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fhost_data-tree.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fhost_data-tree.f95?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -12,12 +12,12 @@ program test\n   !$acc host_data use_device(p) if (p == 42)\n   ! { dg-final { scan-tree-dump-times \"(?n)D\\\\.\\[0-9\\]+ = \\\\*p == 42;$\" 1 \"original\" } }\n   ! { dg-final { scan-tree-dump-times \"(?n)#pragma acc host_data use_device_ptr\\\\(p\\\\) if\\\\(D\\\\.\\[0-9\\]+\\\\)$\" 1 \"original\" } }\n-  ! { dg-final { scan-tree-dump-times \"(?n)#pragma omp target oacc_host_data use_device_ptr\\\\(p\\\\) if\\\\(D\\\\.\\[0-9\\]+\\\\)$\" 1 \"gimple\" } }\n+  ! { dg-final { scan-tree-dump-times \"(?n)#pragma omp target oacc_host_data use_device_ptr\\\\(p\\\\) if\\\\((?:D\\\\.|_)\\[0-9\\]+\\\\)$\" 1 \"gimple\" } }\n   !$acc end host_data\n \n   !$acc host_data use_device(p) if_present if (p == 43)\n   ! { dg-final { scan-tree-dump-times \"(?n)D\\\\.\\[0-9\\]+ = \\\\*p == 43;$\" 1 \"original\" } }\n   ! { dg-final { scan-tree-dump-times \"(?n)#pragma acc host_data use_device_ptr\\\\(p\\\\) if\\\\(D\\\\.\\[0-9\\]+\\\\) if_present$\" 1 \"original\" } }\n-  ! { dg-final { scan-tree-dump-times \"(?n)#pragma omp target oacc_host_data use_device_ptr\\\\(if_present:p\\\\) if\\\\(D\\\\.\\[0-9\\]+\\\\) if_present$\" 1 \"gimple\" } }\n+  ! { dg-final { scan-tree-dump-times \"(?n)#pragma omp target oacc_host_data use_device_ptr\\\\(if_present:p\\\\) if\\\\((?:D\\\\.|_)\\[0-9\\]+\\\\) if_present$\" 1 \"gimple\" } }\n   !$acc end host_data\n end program test"}, {"sha": "688ed0a7dc37581f5c945ee63c602e3040bc320f", "filename": "gcc/testsuite/gfortran.dg/goacc/kernels-tree.f95", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-tree.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-tree.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fkernels-tree.f95?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -37,5 +37,5 @@ end program test\n \n ! { dg-final { scan-tree-dump-times \"map\\\\(force_deviceptr:u\\\\)\" 1 \"original\" } } \n \n-! { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_data_kernels if\\(D\\.[0-9]+\\)$} 1 \"omp_oacc_kernels_decompose\" } }\n-! { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_parallel_kernels_gang_single num_gangs\\(1\\) if\\(D\\.[0-9]+\\) async\\(-1\\)$} 1 \"omp_oacc_kernels_decompose\" } }\n+! { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_data_kernels if\\((?:D\\.|_)[0-9]+\\)$} 1 \"omp_oacc_kernels_decompose\" } }\n+! { dg-final { scan-tree-dump-times {(?n)#pragma omp target oacc_parallel_kernels_gang_single num_gangs\\(1\\) if\\((?:D\\.|_)[0-9]+\\) async\\(-1\\)$} 1 \"omp_oacc_kernels_decompose\" } }"}, {"sha": "9e901ce4945bc10c7fec1ab369d51f6654e1736d", "filename": "gcc/tree-core.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -476,6 +476,9 @@ enum omp_clause_code {\n   /* OpenMP clause: bind (binding).  */\n   OMP_CLAUSE_BIND,\n \n+  /* OpenMP clause: filter (integer-expression).  */\n+  OMP_CLAUSE_FILTER,\n+\n   /* Internally used only clause, holding SIMD uid.  */\n   OMP_CLAUSE__SIMDUID_,\n "}, {"sha": "4ba48e03e0e6862f8474837ecd644067db21af4d", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -1658,6 +1658,12 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \t  copy = gimple_build_omp_master (s1);\n \t  break;\n \n+\tcase GIMPLE_OMP_MASKED:\n+\t  s1 = remap_gimple_seq (gimple_omp_body (stmt), id);\n+\t  copy = gimple_build_omp_masked\n+\t\t   (s1, gimple_omp_masked_clauses (stmt));\n+\t  break;\n+\n \tcase GIMPLE_OMP_TASKGROUP:\n \t  s1 = remap_gimple_seq (gimple_omp_body (stmt), id);\n \t  copy = gimple_build_omp_taskgroup\n@@ -4544,6 +4550,7 @@ estimate_num_insns (gimple *stmt, eni_weights *weights)\n     case GIMPLE_OMP_TASK:\n     case GIMPLE_OMP_CRITICAL:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_MASKED:\n     case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_SCAN:"}, {"sha": "d2b39693cdf2d45639e7608dd2b04c96e4c73cd0", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -1376,6 +1376,7 @@ convert_nonlocal_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_GRAINSIZE:\n \tcase OMP_CLAUSE_NUM_TASKS:\n \tcase OMP_CLAUSE_HINT:\n+\tcase OMP_CLAUSE_FILTER:\n \tcase OMP_CLAUSE_NUM_GANGS:\n \tcase OMP_CLAUSE_NUM_WORKERS:\n \tcase OMP_CLAUSE_VECTOR_LENGTH:\n@@ -1785,6 +1786,7 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_MASKED:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_SCAN:\n       walk_body (convert_nonlocal_reference_stmt, convert_nonlocal_reference_op,\n@@ -2154,6 +2156,7 @@ convert_local_omp_clauses (tree *pclauses, struct walk_stmt_info *wi)\n \tcase OMP_CLAUSE_GRAINSIZE:\n \tcase OMP_CLAUSE_NUM_TASKS:\n \tcase OMP_CLAUSE_HINT:\n+\tcase OMP_CLAUSE_FILTER:\n \tcase OMP_CLAUSE_NUM_GANGS:\n \tcase OMP_CLAUSE_NUM_WORKERS:\n \tcase OMP_CLAUSE_VECTOR_LENGTH:\n@@ -2518,6 +2521,7 @@ convert_local_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_MASKED:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_SCAN:\n       walk_body (convert_local_reference_stmt, convert_local_reference_op,\n@@ -3028,6 +3032,7 @@ convert_gimple_call (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n     case GIMPLE_OMP_SECTION:\n     case GIMPLE_OMP_SINGLE:\n     case GIMPLE_OMP_MASTER:\n+    case GIMPLE_OMP_MASKED:\n     case GIMPLE_OMP_TASKGROUP:\n     case GIMPLE_OMP_ORDERED:\n     case GIMPLE_OMP_SCAN:"}, {"sha": "5ac40345bf56f1c5223ce2cfc82280140e48b03d", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -1085,6 +1085,13 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n       pp_right_paren (pp);\n       break;\n \n+    case OMP_CLAUSE_FILTER:\n+      pp_string (pp, \"filter(\");\n+      dump_generic_node (pp, OMP_CLAUSE_FILTER_EXPR (clause),\n+\t\t\t spc, flags, false);\n+      pp_right_paren (pp);\n+      break;\n+\n     case OMP_CLAUSE_DEFAULTMAP:\n       pp_string (pp, \"defaultmap(\");\n       switch (OMP_CLAUSE_DEFAULTMAP_BEHAVIOR (clause))\n@@ -3586,6 +3593,11 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n       pp_string (pp, \"#pragma omp master\");\n       goto dump_omp_body;\n \n+    case OMP_MASKED:\n+      pp_string (pp, \"#pragma omp masked\");\n+      dump_omp_clauses (pp, OMP_MASKED_CLAUSES (node), spc, flags);\n+      goto dump_omp_body;\n+\n     case OMP_TASKGROUP:\n       pp_string (pp, \"#pragma omp taskgroup\");\n       dump_omp_clauses (pp, OMP_TASKGROUP_CLAUSES (node), spc, flags);"}, {"sha": "a0ff79468eb629bcf5043389d6f13f54e46049ce", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -350,6 +350,7 @@ unsigned const char omp_clause_num_ops[] =\n   0, /* OMP_CLAUSE_DEFAULTMAP  */\n   0, /* OMP_CLAUSE_ORDER  */\n   0, /* OMP_CLAUSE_BIND  */\n+  1, /* OMP_CLAUSE_FILTER  */\n   1, /* OMP_CLAUSE__SIMDUID_  */\n   0, /* OMP_CLAUSE__SIMT_  */\n   0, /* OMP_CLAUSE_INDEPENDENT  */\n@@ -438,6 +439,7 @@ const char * const omp_clause_code_name[] =\n   \"defaultmap\",\n   \"order\",\n   \"bind\",\n+  \"filter\",\n   \"_simduid_\",\n   \"_simt_\",\n   \"independent\",\n@@ -11126,6 +11128,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \tcase OMP_CLAUSE_GRAINSIZE:\n \tcase OMP_CLAUSE_NUM_TASKS:\n \tcase OMP_CLAUSE_HINT:\n+\tcase OMP_CLAUSE_FILTER:\n \tcase OMP_CLAUSE_TO_DECLARE:\n \tcase OMP_CLAUSE_LINK:\n \tcase OMP_CLAUSE_DETACH:"}, {"sha": "ff8b5e6503cbf55bb7355603d0c6f3aed462125a", "filename": "gcc/tree.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -1218,6 +1218,11 @@ DEFTREECODE (OMP_SINGLE, \"omp_single\", tcc_statement, 2)\n    Operand 1: OMP_SINGLE_CLAUSES: List of clauses.  */\n DEFTREECODE (OMP_TASKGROUP, \"omp_taskgroup\", tcc_statement, 2)\n \n+/* OpenMP - #pragma omp masked\n+   Operand 0: OMP_MASKED_BODY: Masked section body.\n+   Operand 1: OMP_MASKED_CLAUSES: List of clauses.  */\n+DEFTREECODE (OMP_MASKED, \"omp_masked\", tcc_statement, 2)\n+\n /* OpenMP - #pragma omp scan\n    Operand 0: OMP_SCAN_BODY: Scan body.\n    Operand 1: OMP_SCAN_CLAUSES: List of clauses.  */"}, {"sha": "c3f302a406a98717067ec929b395a4a2a14a13b2", "filename": "gcc/tree.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -1429,6 +1429,9 @@ class auto_suppress_location_wrappers\n \n #define OMP_MASTER_BODY(NODE)\t   TREE_OPERAND (OMP_MASTER_CHECK (NODE), 0)\n \n+#define OMP_MASKED_BODY(NODE)\t   TREE_OPERAND (OMP_MASKED_CHECK (NODE), 0)\n+#define OMP_MASKED_CLAUSES(NODE)   TREE_OPERAND (OMP_MASKED_CHECK (NODE), 1)\n+\n #define OMP_TASKGROUP_BODY(NODE)   TREE_OPERAND (OMP_TASKGROUP_CHECK (NODE), 0)\n #define OMP_TASKGROUP_CLAUSES(NODE) \\\n   TREE_OPERAND (OMP_TASKGROUP_CHECK (NODE), 1)\n@@ -1508,6 +1511,11 @@ class auto_suppress_location_wrappers\n #define OMP_MASTER_COMBINED(NODE) \\\n   (OMP_MASTER_CHECK (NODE)->base.private_flag)\n \n+/* True on an OMP_MASKED statement if it represents an explicit\n+   combined masked constructs.  */\n+#define OMP_MASKED_COMBINED(NODE) \\\n+  (OMP_MASKED_CHECK (NODE)->base.private_flag)\n+\n /* Memory order for OMP_ATOMIC*.  */\n #define OMP_ATOMIC_MEMORY_ORDER(NODE) \\\n   (TREE_RANGE_CHECK (NODE, OMP_ATOMIC, \\\n@@ -1592,6 +1600,8 @@ class auto_suppress_location_wrappers\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_NUM_TASKS), 0)\n #define OMP_CLAUSE_HINT_EXPR(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_HINT), 0)\n+#define OMP_CLAUSE_FILTER_EXPR(NODE) \\\n+  OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_FILTER), 0)\n \n #define OMP_CLAUSE_GRAINSIZE_EXPR(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_GRAINSIZE),0)"}, {"sha": "4ba259ce819afd30a5cd1bdf2fb9b50f348692ee", "filename": "libgomp/testsuite/libgomp.c-c++-common/masked-1.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0befed793b94f3f407be44e6f69f81a02f5f073/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fmasked-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0befed793b94f3f407be44e6f69f81a02f5f073/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fmasked-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fmasked-1.c?ref=d0befed793b94f3f407be44e6f69f81a02f5f073", "patch": "@@ -0,0 +1,83 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+void\n+foo (int x, int *a)\n+{\n+  #pragma omp masked\n+  {\n+    if (omp_get_thread_num () != 0)\n+      abort ();\n+    a[128]++;\n+  }\n+  #pragma omp masked filter (0)\n+  {\n+    if (omp_get_thread_num () != 0)\n+      abort ();\n+    a[129]++;\n+  }\n+  #pragma omp masked filter (7)\n+  {\n+    if (omp_get_thread_num () != 7)\n+      abort ();\n+    a[130]++;\n+  }\n+  #pragma omp masked filter (x)\n+  {\n+    if (omp_get_thread_num () != x)\n+      abort ();\n+    a[131]++;\n+  }\n+  #pragma omp masked taskloop simd filter (x) grainsize (12) simdlen (4)\n+  for (int i = 0; i < 128; i++)\n+    a[i] += i;\n+}\n+\n+int\n+main ()\n+{\n+  int a[136] = {};\n+  #pragma omp parallel num_threads (4)\n+  foo (4, a);\n+  for (int i = 0; i < 128; i++)\n+    if (a[i])\n+      abort ();\n+  if (a[128] != 1 || a[129] != 1 || a[130] || a[131])\n+    abort ();\n+  #pragma omp parallel num_threads (4)\n+  foo (3, a);\n+  for (int i = 0; i < 128; i++)\n+    if (a[i] != i)\n+      abort ();\n+  if (a[128] != 2 || a[129] != 2 || a[130] || a[131] != 1)\n+    abort ();\n+  #pragma omp parallel num_threads (8)\n+  foo (8, a);\n+  for (int i = 0; i < 128; i++)\n+    if (a[i] != i)\n+      abort ();\n+  if (a[128] != 3 || a[129] != 3 || a[130] != 1 || a[131] != 1)\n+    abort ();\n+  #pragma omp parallel num_threads (8)\n+  foo (6, a);\n+  for (int i = 0; i < 128; i++)\n+    if (a[i] != 2 * i)\n+      abort ();\n+  if (a[128] != 4 || a[129] != 4 || a[130] != 2 || a[131] != 2)\n+    abort ();\n+  for (int i = 0; i < 8; i++)\n+    a[i] = 0;\n+  /* The filter expression can evaluate to different values in different threads.  */\n+  #pragma omp parallel masked num_threads (8) filter (omp_get_thread_num () + 1)\n+  a[omp_get_thread_num ()]++;\n+  for (int i = 0; i < 8; i++)\n+    if (a[i])\n+      abort ();\n+  /* And multiple threads can be filtered.  */\n+  #pragma omp parallel masked num_threads (8) filter (omp_get_thread_num () & ~1)\n+  a[omp_get_thread_num ()]++;\n+  for (int i = 0; i < 8; i++)\n+    if (a[i] != !(i & 1))\n+      abort ();\n+  return 0;\n+}"}]}