{"sha": "028d1f20f7547f48b7370209d1e446398f2bb4b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI4ZDFmMjBmNzU0N2Y0OGI3MzcwMjA5ZDFlNDQ2Mzk4ZjJiYjRiMQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-01-18T09:56:46Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-01-18T09:56:46Z"}, "message": "pt.c (UNIFY_ALLOW_OUTER_LEVEL): New unify flag.\n\ncp:\n\t* pt.c (UNIFY_ALLOW_OUTER_LEVEL): New unify flag.\n\t(type_unification_real): Set it.\n\t(unify): Use it.\ntestsuite:\n\t* g++.old-deja/g++.pt/unify8.C: New test.\n\nFrom-SVN: r39115", "tree": {"sha": "4fedead3ac4c81c3a4b67bf00c1fdc7b53de0ca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fedead3ac4c81c3a4b67bf00c1fdc7b53de0ca8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/028d1f20f7547f48b7370209d1e446398f2bb4b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/028d1f20f7547f48b7370209d1e446398f2bb4b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/028d1f20f7547f48b7370209d1e446398f2bb4b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/028d1f20f7547f48b7370209d1e446398f2bb4b1/comments", "author": null, "committer": null, "parents": [{"sha": "9f724b6ae48e21f50e0b00461ba30b8c20b43d5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f724b6ae48e21f50e0b00461ba30b8c20b43d5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f724b6ae48e21f50e0b00461ba30b8c20b43d5a"}], "stats": {"total": 75, "additions": 56, "deletions": 19}, "files": [{"sha": "8409ce3eb6be8009c6a49aad484b586c6280bcc2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d1f20f7547f48b7370209d1e446398f2bb4b1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d1f20f7547f48b7370209d1e446398f2bb4b1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=028d1f20f7547f48b7370209d1e446398f2bb4b1", "patch": "@@ -1,3 +1,9 @@\n+2001-01-18  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* pt.c (UNIFY_ALLOW_OUTER_LEVEL): New unify flag.\n+\t(type_unification_real): Set it.\n+\t(unify): Use it.\n+\n 2001-01-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* decl.c (finish_destructor_body): Convert to vbase pointer here."}, {"sha": "747df21ef674cd25b1328ed18421f5910f70252f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d1f20f7547f48b7370209d1e446398f2bb4b1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d1f20f7547f48b7370209d1e446398f2bb4b1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=028d1f20f7547f48b7370209d1e446398f2bb4b1", "patch": "@@ -86,6 +86,7 @@ static htab_t local_specializations;\n #define UNIFY_ALLOW_LESS_CV_QUAL 2\n #define UNIFY_ALLOW_DERIVED 4\n #define UNIFY_ALLOW_INTEGER 8\n+#define UNIFY_ALLOW_OUTER_LEVEL 16\n \n #define GTB_VIA_VIRTUAL 1 /* The base class we are examining is\n \t\t\t     virtual, or a base class of a virtual\n@@ -7874,7 +7875,8 @@ type_unification_real (tparms, targs, parms, args, subr,\n   switch (strict)\n     {\n     case DEDUCE_CALL:\n-      sub_strict = UNIFY_ALLOW_MORE_CV_QUAL | UNIFY_ALLOW_DERIVED;\n+      sub_strict = (UNIFY_ALLOW_OUTER_LEVEL | UNIFY_ALLOW_MORE_CV_QUAL\n+                    | UNIFY_ALLOW_DERIVED);\n       break;\n       \n     case DEDUCE_CONV:\n@@ -8413,7 +8415,8 @@ check_cv_quals_for_unify (strict, arg, parm)\n      UNIFY_ALLOW_NONE:\n        Require an exact match between PARM and ARG.\n      UNIFY_ALLOW_MORE_CV_QUAL:\n-       Allow the deduced ARG to be more cv-qualified than ARG.\n+       Allow the deduced ARG to be more cv-qualified (by qualification\n+       conversion) than ARG.\n      UNIFY_ALLOW_LESS_CV_QUAL:\n        Allow the deduced ARG to be less cv-qualified than ARG.\n      UNIFY_ALLOW_DERIVED:\n@@ -8422,7 +8425,14 @@ check_cv_quals_for_unify (strict, arg, parm)\n        ARG.\n      UNIFY_ALLOW_INTEGER:\n        Allow any integral type to be deduced.  See the TEMPLATE_PARM_INDEX\n-       case for more information.  */\n+       case for more information. \n+     UNIFY_ALLOW_OUTER_LEVEL:\n+       This is the outermost level of a deduction. Used to determine validity\n+       of qualification conversions. A valid qualification conversion must\n+       have const qualified pointers leading up to the inner type which\n+       requires additional CV quals, except at the outer level, where const\n+       is not required [conv.qual]. It would be normal to set this flag in\n+       addition to setting UNIFY_ALLOW_MORE_CV_QUAL.  */\n \n static int\n unify (tparms, targs, parm, arg, strict)\n@@ -8432,6 +8442,7 @@ unify (tparms, targs, parm, arg, strict)\n   int idx;\n   tree targ;\n   tree tparm;\n+  int strict_in = strict;\n \n   /* I don't think this will do the right thing with respect to types.\n      But the only case I've seen it in so far has been array bounds, where\n@@ -8463,9 +8474,15 @@ unify (tparms, targs, parm, arg, strict)\n \t PARM `T' for example, when computing which of two templates\n \t is more specialized, for example.  */\n       && TREE_CODE (arg) != TEMPLATE_TYPE_PARM\n-      && !check_cv_quals_for_unify (strict, arg, parm))\n+      && !check_cv_quals_for_unify (strict_in, arg, parm))\n     return 1;\n \n+  if (!(strict & UNIFY_ALLOW_OUTER_LEVEL)\n+      && TYPE_P (arg) && !CP_TYPE_CONST_P (arg))\n+    strict &= ~UNIFY_ALLOW_MORE_CV_QUAL;\n+  strict &= ~UNIFY_ALLOW_OUTER_LEVEL;\n+  strict &= ~UNIFY_ALLOW_DERIVED;\n+  \n   switch (TREE_CODE (parm))\n     {\n     case TYPENAME_TYPE:\n@@ -8560,7 +8577,7 @@ unify (tparms, targs, parm, arg, strict)\n \t     a match unless we are allowing additional qualification.\n \t     If ARG is `const int' and PARM is just `T' that's OK;\n \t     that binds `const int' to `T'.  */\n-\t  if (!check_cv_quals_for_unify (strict | UNIFY_ALLOW_LESS_CV_QUAL, \n+\t  if (!check_cv_quals_for_unify (strict_in | UNIFY_ALLOW_LESS_CV_QUAL, \n \t\t\t\t\t arg, parm))\n \t    return 1;\n \n@@ -8645,8 +8662,6 @@ unify (tparms, targs, parm, arg, strict)\n \n     case POINTER_TYPE:\n       {\n-\tint sub_strict;\n-\n \tif (TREE_CODE (arg) != POINTER_TYPE)\n \t  return 1;\n \t\n@@ -8658,28 +8673,22 @@ unify (tparms, targs, parm, arg, strict)\n \n \t   We pass down STRICT here rather than UNIFY_ALLOW_NONE.\n \t   This will allow for additional cv-qualification of the\n-\t   pointed-to types if appropriate.  In general, this is a bit\n-\t   too generous; we are only supposed to allow qualification\n-\t   conversions and this method will allow an ARG of char** and\n-\t   a deduced ARG of const char**.  However, overload\n-\t   resolution will subsequently invalidate the candidate, so\n-\t   this is probably OK.  */\n-\tsub_strict = strict;\n+\t   pointed-to types if appropriate.  */\n \t\n-\tif (TREE_CODE (TREE_TYPE (arg)) != RECORD_TYPE)\n+\tif (TREE_CODE (TREE_TYPE (arg)) == RECORD_TYPE)\n \t  /* The derived-to-base conversion only persists through one\n \t     level of pointers.  */\n-\t  sub_strict &= ~UNIFY_ALLOW_DERIVED;\n+\t  strict |= (strict_in & UNIFY_ALLOW_DERIVED);\n \n \treturn unify (tparms, targs, TREE_TYPE (parm), \n-\t\t      TREE_TYPE (arg), sub_strict);\n+\t\t      TREE_TYPE (arg), strict);\n       }\n \n     case REFERENCE_TYPE:\n       if (TREE_CODE (arg) != REFERENCE_TYPE)\n \treturn 1;\n       return unify (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),\n-\t\t    UNIFY_ALLOW_NONE);\n+\t\t    strict & UNIFY_ALLOW_MORE_CV_QUAL);\n \n     case ARRAY_TYPE:\n       if (TREE_CODE (arg) != ARRAY_TYPE)\n@@ -8769,7 +8778,7 @@ unify (tparms, targs, parm, arg, strict)\n \t{\n \t  tree t = NULL_TREE;\n \n-\t  if (strict & UNIFY_ALLOW_DERIVED)\n+\t  if (strict_in & UNIFY_ALLOW_DERIVED)\n \t    {\n \t      /* First, we try to unify the PARM and ARG directly.  */\n \t      t = try_class_unification (tparms, targs,"}, {"sha": "55790841cb5598b864c7034de2a25bd05273bfae", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d1f20f7547f48b7370209d1e446398f2bb4b1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d1f20f7547f48b7370209d1e446398f2bb4b1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=028d1f20f7547f48b7370209d1e446398f2bb4b1", "patch": "@@ -1,3 +1,7 @@\n+2001-01-18  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.old-deja/g++.pt/unify8.C: New test.\n+\n 2001-01-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.old-deja/g++.abi/vbase1.C: New test."}, {"sha": "4e2f392b64b23df7e2fbda6bf5f72f383b82d419", "filename": "gcc/testsuite/g++.old-deja/g++.pt/unify8.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d1f20f7547f48b7370209d1e446398f2bb4b1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d1f20f7547f48b7370209d1e446398f2bb4b1/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funify8.C?ref=028d1f20f7547f48b7370209d1e446398f2bb4b1", "patch": "@@ -0,0 +1,18 @@\n+// Build don't link:\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 12 Jan 2001 <nathan@codesourcery.com>\n+\n+// Bug 1630. Template deduction at a call allowed conversions more lenient than\n+// qualification conversions. That would lead to misleading diagnostics during\n+// overload resolution.\n+\n+\n+template <typename T> void Foo (T const **);\n+void Foo (int);       // ERROR - candidate\n+void Foo (float);     // ERROR - candidate\n+\n+void baz (int **p1)\n+{\n+  Foo (p1);   // ERROR - no such function\n+}"}]}