{"sha": "0ffef2005fd7536efbc9c3a572701998c8a8080c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZmZWYyMDA1ZmQ3NTM2ZWZiYzljM2E1NzI3MDE5OThjOGE4MDgwYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-20T08:53:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-20T08:53:39Z"}, "message": "Use function_arg_info for TARGET_MUST_PASS_IN_STACK\n\nThe hook is passed the promoted mode instead of the original type mode.\n\nThe expr.h reference in the documentation is no longer correct, but\npointing to calls.h or calls.c doesn't help much either.  I just left\nthis as-is since it's not related to the point of the series.\n\nAfter previous changes, most places already pass arg.mode and arg.type.\nOnly i386 and mcore needed to construct a new one out of nothing.\nrs6000 needs to construct one slightly earlier than before.\n\n2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.def (must_pass_in_stack): Take a function_arg_info instead\n\tof a mode and a type.\n\t* doc/tm.texi: Regenerate.\n\t* calls.h (must_pass_in_stack_var_size): Take a function_arg_info\n\tinstead of a mode and a type.\n\t(must_pass_in_stack_var_size_or_pad): Likewise.\n\t* calls.c (must_pass_in_stack_var_size): Likewise.\n\t(must_pass_in_stack_var_size_or_pad): Likewise.\n\t(initialize_argument_information): Update call to\n\ttargetm.calls.must_pass_in_stack.\n\t(must_pass_va_arg_on_stack): Likewise.\n\t* function.c (assign_parm_find_entry_rtl): Likewise.\n\t* targhooks.c (hook_pass_by_reference_must_pass_in_stack): Likewise.\n\t* config/alpha/alpha.c (alpha_function_arg): Likewise.\n\t(alpha_function_arg_advance): Likewise.\n\t* config/cr16/cr16.c (cr16_function_arg): Likewise.\n\t(cr16_function_arg_advance): Likewise.\n\t* config/cris/cris.c (cris_pass_by_reference): Likewise.\n\t(cris_arg_partial_bytes): Likewise.\n\t* config/iq2000/iq2000.c (iq2000_pass_by_reference): Likewise.\n\t* config/lm32/lm32.c (lm32_function_arg): Likewise.\n\t* config/mcore/mcore.c (mcore_num_arg_regs): Likewise.\n\t(mcore_function_arg, mcore_arg_partial_bytes): Likewise.\n\t* config/mips/mips.c (mips_pass_by_reference): Likewise.\n\t* config/mmix/mmix.c (mmix_function_arg_advance): Likewise.\n\t(mmix_function_arg_1, mmix_pass_by_reference): Likewise.\n\t* config/sh/sh.c (sh_pass_by_reference): Likewise.\n\t* config/stormy16/stormy16.c (xstormy16_function_arg): Likewise.\n\t* config/xtensa/xtensa.c (xtensa_function_arg_advance): Likewise.\n\t* config/arm/arm.c (arm_must_pass_in_stack): Take a function_arg_info\n\tinstead of a mode and a type.\n\t* config/fr30/fr30.c (fr30_must_pass_in_stack): Likewise.\n\t(fr30_num_arg_regs): Likewise.\n\t(fr30_setup_incoming_varargs): Update calls accordingly.\n\t(fr30_arg_partial_bytes, fr30_function_arg): Likewise.\n\t(fr30_function_arg_advance): Likewise.\n\t* config/frv/frv.c (frv_must_pass_in_stack): Take a function_arg_info\n\tinstead of a mode and a type.\n\t* config/gcn/gcn.c (num_arg_regs): Likewise.\n\t(gcn_function_arg, gcn_function_arg_advance): Update calls to\n\tnum_arg_regs and targetm.calls.must_pass_in_stack.\n\t(gcn_arg_partial_bytes): Likewise.\n\t* config/i386/i386.c (ix86_must_pass_in_stack): Take a\n\tfunction_arg_info instead of a mode and a type.\n\t(classify_argument): Update call accordingly.\n\t* config/nds32/nds32.c (nds32_must_pass_in_stack): Take a\n\tfunction_arg_info instead of a mode and a type.\n\t* config/rs6000/rs6000-internal.h (rs6000_must_pass_in_stack):\n\tLikewise.\n\t* config/rs6000/rs6000-call.c (rs6000_must_pass_in_stack): Likewise.\n\t(rs6000_parm_needs_stack): Update call accordingly.\n\t(setup_incoming_varargs): Likewise.\n\nFrom-SVN: r274703", "tree": {"sha": "37282f18d957368ef636c6d4d1086678207d6f8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37282f18d957368ef636c6d4d1086678207d6f8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ffef2005fd7536efbc9c3a572701998c8a8080c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ffef2005fd7536efbc9c3a572701998c8a8080c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ffef2005fd7536efbc9c3a572701998c8a8080c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ffef2005fd7536efbc9c3a572701998c8a8080c/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7256c7194e186fce6ff866a124a77b08196c2a5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7256c7194e186fce6ff866a124a77b08196c2a5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7256c7194e186fce6ff866a124a77b08196c2a5f"}], "stats": {"total": 263, "additions": 151, "deletions": 112}, "files": [{"sha": "b5a198c95dc3d67d1dab5aaad2ab00d6942b841c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -1,3 +1,58 @@\n+2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.def (must_pass_in_stack): Take a function_arg_info instead\n+\tof a mode and a type.\n+\t* doc/tm.texi: Regenerate.\n+\t* calls.h (must_pass_in_stack_var_size): Take a function_arg_info\n+\tinstead of a mode and a type.\n+\t(must_pass_in_stack_var_size_or_pad): Likewise.\n+\t* calls.c (must_pass_in_stack_var_size): Likewise.\n+\t(must_pass_in_stack_var_size_or_pad): Likewise.\n+\t(initialize_argument_information): Update call to\n+\ttargetm.calls.must_pass_in_stack.\n+\t(must_pass_va_arg_on_stack): Likewise.\n+\t* function.c (assign_parm_find_entry_rtl): Likewise.\n+\t* targhooks.c (hook_pass_by_reference_must_pass_in_stack): Likewise.\n+\t* config/alpha/alpha.c (alpha_function_arg): Likewise.\n+\t(alpha_function_arg_advance): Likewise.\n+\t* config/cr16/cr16.c (cr16_function_arg): Likewise.\n+\t(cr16_function_arg_advance): Likewise.\n+\t* config/cris/cris.c (cris_pass_by_reference): Likewise.\n+\t(cris_arg_partial_bytes): Likewise.\n+\t* config/iq2000/iq2000.c (iq2000_pass_by_reference): Likewise.\n+\t* config/lm32/lm32.c (lm32_function_arg): Likewise.\n+\t* config/mcore/mcore.c (mcore_num_arg_regs): Likewise.\n+\t(mcore_function_arg, mcore_arg_partial_bytes): Likewise.\n+\t* config/mips/mips.c (mips_pass_by_reference): Likewise.\n+\t* config/mmix/mmix.c (mmix_function_arg_advance): Likewise.\n+\t(mmix_function_arg_1, mmix_pass_by_reference): Likewise.\n+\t* config/sh/sh.c (sh_pass_by_reference): Likewise.\n+\t* config/stormy16/stormy16.c (xstormy16_function_arg): Likewise.\n+\t* config/xtensa/xtensa.c (xtensa_function_arg_advance): Likewise.\n+\t* config/arm/arm.c (arm_must_pass_in_stack): Take a function_arg_info\n+\tinstead of a mode and a type.\n+\t* config/fr30/fr30.c (fr30_must_pass_in_stack): Likewise.\n+\t(fr30_num_arg_regs): Likewise.\n+\t(fr30_setup_incoming_varargs): Update calls accordingly.\n+\t(fr30_arg_partial_bytes, fr30_function_arg): Likewise.\n+\t(fr30_function_arg_advance): Likewise.\n+\t* config/frv/frv.c (frv_must_pass_in_stack): Take a function_arg_info\n+\tinstead of a mode and a type.\n+\t* config/gcn/gcn.c (num_arg_regs): Likewise.\n+\t(gcn_function_arg, gcn_function_arg_advance): Update calls to\n+\tnum_arg_regs and targetm.calls.must_pass_in_stack.\n+\t(gcn_arg_partial_bytes): Likewise.\n+\t* config/i386/i386.c (ix86_must_pass_in_stack): Take a\n+\tfunction_arg_info instead of a mode and a type.\n+\t(classify_argument): Update call accordingly.\n+\t* config/nds32/nds32.c (nds32_must_pass_in_stack): Take a\n+\tfunction_arg_info instead of a mode and a type.\n+\t* config/rs6000/rs6000-internal.h (rs6000_must_pass_in_stack):\n+\tLikewise.\n+\t* config/rs6000/rs6000-call.c (rs6000_must_pass_in_stack): Likewise.\n+\t(rs6000_parm_needs_stack): Update call accordingly.\n+\t(setup_incoming_varargs): Likewise.\n+\n 2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* target.def (callee_copies): Take a function_arg_info instead"}, {"sha": "1f691e84dfeba89ca54a51363440b53814ea862e", "filename": "gcc/calls.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -2139,7 +2139,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n       if (args[i].reg)\n \targs[i].partial = targetm.calls.arg_partial_bytes (args_so_far, arg);\n \n-      args[i].pass_on_stack = targetm.calls.must_pass_in_stack (mode, type);\n+      args[i].pass_on_stack = targetm.calls.must_pass_in_stack (arg);\n \n       /* If FUNCTION_ARG returned a (parallel [(expr_list (nil) ...) ...]),\n \t it means that we are to pass this arg in the register(s) designated\n@@ -5839,22 +5839,21 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n   return sibcall_failure;\n }\n \n-/* Nonzero if we do not know how to pass TYPE solely in registers.  */\n+/* Nonzero if we do not know how to pass ARG solely in registers.  */\n \n bool\n-must_pass_in_stack_var_size (machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t     const_tree type)\n+must_pass_in_stack_var_size (const function_arg_info &arg)\n {\n-  if (!type)\n+  if (!arg.type)\n     return false;\n \n   /* If the type has variable size...  */\n-  if (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+  if (TREE_CODE (TYPE_SIZE (arg.type)) != INTEGER_CST)\n     return true;\n \n   /* If the type is marked as addressable (it is required\n      to be constructed into the stack)...  */\n-  if (TREE_ADDRESSABLE (type))\n+  if (TREE_ADDRESSABLE (arg.type))\n     return true;\n \n   return false;\n@@ -5865,28 +5864,28 @@ must_pass_in_stack_var_size (machine_mode mode ATTRIBUTE_UNUSED,\n /* ??? Should be able to merge these two by examining BLOCK_REG_PADDING.  */\n \n bool\n-must_pass_in_stack_var_size_or_pad (machine_mode mode, const_tree type)\n+must_pass_in_stack_var_size_or_pad (const function_arg_info &arg)\n {\n-  if (!type)\n+  if (!arg.type)\n     return false;\n \n   /* If the type has variable size...  */\n-  if (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+  if (TREE_CODE (TYPE_SIZE (arg.type)) != INTEGER_CST)\n     return true;\n \n   /* If the type is marked as addressable (it is required\n      to be constructed into the stack)...  */\n-  if (TREE_ADDRESSABLE (type))\n+  if (TREE_ADDRESSABLE (arg.type))\n     return true;\n \n-  if (TYPE_EMPTY_P (type))\n+  if (TYPE_EMPTY_P (arg.type))\n     return false;\n \n   /* If the padding and mode of the type is such that a copy into\n      a register would put it into the wrong part of the register.  */\n-  if (mode == BLKmode\n-      && int_size_in_bytes (type) % (PARM_BOUNDARY / BITS_PER_UNIT)\n-      && (targetm.calls.function_arg_padding (mode, type)\n+  if (arg.mode == BLKmode\n+      && int_size_in_bytes (arg.type) % (PARM_BOUNDARY / BITS_PER_UNIT)\n+      && (targetm.calls.function_arg_padding (arg.mode, arg.type)\n \t  == (BYTES_BIG_ENDIAN ? PAD_UPWARD : PAD_DOWNWARD)))\n     return true;\n \n@@ -5899,7 +5898,8 @@ must_pass_in_stack_var_size_or_pad (machine_mode mode, const_tree type)\n bool\n must_pass_va_arg_in_stack (tree type)\n {\n-  return targetm.calls.must_pass_in_stack (TYPE_MODE (type), type);\n+  function_arg_info arg (type, /*named=*/false);\n+  return targetm.calls.must_pass_in_stack (arg);\n }\n \n /* Tell the garbage collector about GTY markers in this source file.  */"}, {"sha": "5e8c576424abb2797830f248d9eab0805c6b168b", "filename": "gcc/calls.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fcalls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fcalls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.h?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -108,8 +108,8 @@ extern int setjmp_call_p (const_tree);\n extern bool gimple_maybe_alloca_call_p (const gimple *);\n extern bool gimple_alloca_call_p (const gimple *);\n extern bool alloca_call_p (const_tree);\n-extern bool must_pass_in_stack_var_size (machine_mode, const_tree);\n-extern bool must_pass_in_stack_var_size_or_pad (machine_mode, const_tree);\n+extern bool must_pass_in_stack_var_size (const function_arg_info &);\n+extern bool must_pass_in_stack_var_size_or_pad (const function_arg_info &);\n extern bool must_pass_va_arg_in_stack (tree);\n extern rtx prepare_call_address (tree, rtx, rtx, rtx *, int, int);\n extern bool shift_return_value (machine_mode, bool, rtx);"}, {"sha": "fd6b5a82274068945ebcece3c18061056e8a1496", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -5585,7 +5585,7 @@ alpha_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n \n       num_args = cum->num_args;\n       if (num_args >= 6\n-\t  || targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n+\t  || targetm.calls.must_pass_in_stack (arg))\n \treturn NULL_RTX;\n     }\n #elif TARGET_ABI_OSF\n@@ -5596,7 +5596,7 @@ alpha_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n \n       if (arg.end_marker_p ())\n \tbasereg = 16;\n-      else if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n+      else if (targetm.calls.must_pass_in_stack (arg))\n \treturn NULL_RTX;\n     }\n #else\n@@ -5613,7 +5613,7 @@ alpha_function_arg_advance (cumulative_args_t cum_v,\n \t\t\t    const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n-  bool onstack = targetm.calls.must_pass_in_stack (arg.mode, arg.type);\n+  bool onstack = targetm.calls.must_pass_in_stack (arg);\n   int increment = onstack ? 6 : ALPHA_ARG_SIZE (arg.mode, arg.type);\n \n #if TARGET_ABI_OSF"}, {"sha": "3343a7e4639248046fe3b4f8fed2a45d2d3f8388", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -219,7 +219,7 @@ static bool arm_promote_prototypes (const_tree);\n static bool arm_default_short_enums (void);\n static bool arm_align_anon_bitfield (void);\n static bool arm_return_in_msb (const_tree);\n-static bool arm_must_pass_in_stack (machine_mode, const_tree);\n+static bool arm_must_pass_in_stack (const function_arg_info &);\n static bool arm_return_in_memory (const_tree, const_tree);\n #if ARM_UNWIND_INFO\n static void arm_unwind_emit (FILE *, rtx_insn *);\n@@ -15382,12 +15382,12 @@ arm_reload_out_hi (rtx *operands)\n    (padded to the size of a word) should be passed in a register.  */\n \n static bool\n-arm_must_pass_in_stack (machine_mode mode, const_tree type)\n+arm_must_pass_in_stack (const function_arg_info &arg)\n {\n   if (TARGET_AAPCS_BASED)\n-    return must_pass_in_stack_var_size (mode, type);\n+    return must_pass_in_stack_var_size (arg);\n   else\n-    return must_pass_in_stack_var_size_or_pad (mode, type);\n+    return must_pass_in_stack_var_size_or_pad (arg);\n }\n \n "}, {"sha": "c95d5d19a9c63692cc3fe4ecd4524fab76907f8f", "filename": "gcc/config/cr16/cr16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fcr16%2Fcr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fcr16%2Fcr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -606,7 +606,7 @@ cr16_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n   if (arg.end_marker_p ())\n     return NULL_RTX;\n \n-  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type) || (cum->ints < 0))\n+  if (targetm.calls.must_pass_in_stack (arg) || (cum->ints < 0))\n     return NULL_RTX;\n \n   if (arg.mode == BLKmode)\n@@ -672,7 +672,7 @@ cr16_function_arg_advance (cumulative_args_t cum_v,\n   if (!cum->last_parm_in_reg)\n     return;\n \n-  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type) || (cum->ints < 0))\n+  if (targetm.calls.must_pass_in_stack (arg) || (cum->ints < 0))\n     return;\n \n   if ((arg.mode == SImode) || (arg.mode == HImode)"}, {"sha": "fff641e9f84ef1cac3a703ead5b06b3031362f30", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -4046,7 +4046,7 @@ cris_setup_incoming_varargs (cumulative_args_t ca_v,\n static bool\n cris_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n {\n-  return (targetm.calls.must_pass_in_stack (arg.mode, arg.type)\n+  return (targetm.calls.must_pass_in_stack (arg)\n \t  || CRIS_FUNCTION_ARG_SIZE (arg.mode, arg.type) > 8);\n }\n \n@@ -4111,7 +4111,7 @@ static int\n cris_arg_partial_bytes (cumulative_args_t ca, const function_arg_info &arg)\n {\n   if (get_cumulative_args (ca)->regs == CRIS_MAX_ARGS_IN_REGS - 1\n-      && !targetm.calls.must_pass_in_stack (arg.mode, arg.type)\n+      && !targetm.calls.must_pass_in_stack (arg)\n       && CRIS_FUNCTION_ARG_SIZE (arg.mode, arg.type) > 4\n       && CRIS_FUNCTION_ARG_SIZE (arg.mode, arg.type) <= 8)\n     return UNITS_PER_WORD;"}, {"sha": "675198fe5de2b0b376fa3deb2e6b4da12e59230e", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -116,7 +116,7 @@ static struct fr30_frame_info \tzero_frame_info;\n static void fr30_setup_incoming_varargs (cumulative_args_t,\n \t\t\t\t\t const function_arg_info &,\n \t\t\t\t\t int *, int);\n-static bool fr30_must_pass_in_stack (machine_mode, const_tree);\n+static bool fr30_must_pass_in_stack (const function_arg_info &);\n static int fr30_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t   const function_arg_info &);\n static rtx fr30_function_arg (cumulative_args_t, const function_arg_info &);\n@@ -129,7 +129,7 @@ static bool fr30_function_value_regno_p (const unsigned int);\n static bool fr30_can_eliminate (const int, const int);\n static void fr30_asm_trampoline_template (FILE *);\n static void fr30_trampoline_init (rtx, tree, rtx);\n-static int fr30_num_arg_regs (machine_mode, const_tree);\n+static int fr30_num_arg_regs (const function_arg_info &);\n \n #define FRAME_POINTER_MASK \t(1 << (FRAME_POINTER_REGNUM))\n #define RETURN_POINTER_MASK \t(1 << (RETURN_POINTER_REGNUM))\n@@ -480,7 +480,7 @@ fr30_setup_incoming_varargs (cumulative_args_t arg_regs_used_so_far_v,\n     /* If TARGET_STRICT_ARGUMENT_NAMING returns true, then the last named\n        arg must not be treated as an anonymous arg.  */\n     /* ??? This is a pointer increment, which makes no sense.  */\n-    arg_regs_used_so_far += fr30_num_arg_regs (arg.mode, arg.type);\n+    arg_regs_used_so_far += fr30_num_arg_regs (arg);\n \n   size = FR30_NUM_ARG_REGS - (* arg_regs_used_so_far);\n \n@@ -743,30 +743,20 @@ fr30_function_value_regno_p (const unsigned int regno)\n    in registers.  */\n \n static bool\n-fr30_must_pass_in_stack (machine_mode mode, const_tree type)\n+fr30_must_pass_in_stack (const function_arg_info &arg)\n {\n-  if (mode == BLKmode)\n-    return true;\n-  if (type == NULL)\n-    return false;\n-  return AGGREGATE_TYPE_P (type);\n+  return arg.mode == BLKmode || arg.aggregate_type_p ();\n }\n \n-/* Compute the number of word sized registers needed to hold a\n-   function argument of mode INT_MODE and tree type TYPE.  */\n+/* Compute the number of word sized registers needed to hold function\n+   argument ARG.  */\n static int\n-fr30_num_arg_regs (machine_mode mode, const_tree type)\n+fr30_num_arg_regs (const function_arg_info &arg)\n {\n-  int size;\n-\n-  if (targetm.calls.must_pass_in_stack (mode, type))\n+  if (targetm.calls.must_pass_in_stack (arg))\n     return 0;\n \n-  if (type && mode == BLKmode)\n-    size = int_size_in_bytes (type);\n-  else\n-    size = GET_MODE_SIZE (mode);\n-\n+  int size = arg.promoted_size_in_bytes ();\n   return (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n }\n \n@@ -792,7 +782,7 @@ fr30_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n      are needed because the parameter must be passed on the stack)\n      then return zero, as this parameter does not require partial\n      register, partial stack stack space.  */\n-  if (*cum + fr30_num_arg_regs (arg.mode, arg.type) <= FR30_NUM_ARG_REGS)\n+  if (*cum + fr30_num_arg_regs (arg) <= FR30_NUM_ARG_REGS)\n     return 0;\n   \n   return (FR30_NUM_ARG_REGS - *cum) * UNITS_PER_WORD;\n@@ -804,7 +794,7 @@ fr30_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n   if (!arg.named\n-      || fr30_must_pass_in_stack (arg.mode, arg.type)\n+      || fr30_must_pass_in_stack (arg)\n       || *cum >= FR30_NUM_ARG_REGS)\n     return NULL_RTX;\n   else\n@@ -817,7 +807,7 @@ fr30_function_arg_advance (cumulative_args_t cum,\n \t\t\t   const function_arg_info &arg)\n {\n   if (arg.named)\n-    *get_cumulative_args (cum) += fr30_num_arg_regs (arg.mode, arg.type);\n+    *get_cumulative_args (cum) += fr30_num_arg_regs (arg);\n }\n \n /*}}}*/"}, {"sha": "c1b3c9e6d600b8ab1b06c5045cb975177cf5360a", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -379,7 +379,7 @@ static void frv_output_const_unspec\t\t(FILE *,\n \t\t\t\t\t\t const struct frv_unspec *);\n static bool frv_function_ok_for_sibcall\t\t(tree, tree);\n static rtx frv_struct_value_rtx\t\t\t(tree, int);\n-static bool frv_must_pass_in_stack (machine_mode mode, const_tree type);\n+static bool frv_must_pass_in_stack (const function_arg_info &);\n static int frv_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t  const function_arg_info &);\n static rtx frv_function_arg (cumulative_args_t, const function_arg_info &);\n@@ -3077,13 +3077,9 @@ frv_init_cumulative_args (CUMULATIVE_ARGS *cum,\n    in registers.  */\n \n static bool\n-frv_must_pass_in_stack (machine_mode mode, const_tree type)\n+frv_must_pass_in_stack (const function_arg_info &arg)\n {\n-  if (mode == BLKmode)\n-    return true;\n-  if (type == NULL)\n-    return false;\n-  return AGGREGATE_TYPE_P (type);\n+  return arg.mode == BLKmode || arg.aggregate_type_p ();\n }\n \n /* If defined, a C expression that gives the alignment boundary, in bits, of an"}, {"sha": "8645eccf9547a7c3b453922e34fcce91c9bc8fa0", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -2200,22 +2200,16 @@ gcn_function_value_regno_p (const unsigned int n)\n   return n == RETURN_VALUE_REG;\n }\n \n-/* Calculate the number of registers required to hold a function argument\n-   of MODE and TYPE.  */\n+/* Calculate the number of registers required to hold function argument\n+   ARG.  */\n \n static int\n-num_arg_regs (machine_mode mode, const_tree type)\n+num_arg_regs (const function_arg_info &arg)\n {\n-  int size;\n-\n-  if (targetm.calls.must_pass_in_stack (mode, type))\n+  if (targetm.calls.must_pass_in_stack (arg))\n     return 0;\n \n-  if (type && mode == BLKmode)\n-    size = int_size_in_bytes (type);\n-  else\n-    size = GET_MODE_SIZE (mode);\n-\n+  int size = arg.promoted_size_in_bytes ();\n   return (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n }\n \n@@ -2263,11 +2257,11 @@ gcn_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n       if (!arg.named || arg.end_marker_p ())\n \treturn 0;\n \n-      if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n+      if (targetm.calls.must_pass_in_stack (arg))\n \treturn 0;\n \n       int reg_num = FIRST_PARM_REG + cum->num;\n-      int num_regs = num_arg_regs (arg.mode, arg.type);\n+      int num_regs = num_arg_regs (arg);\n       if (num_regs > 0)\n \twhile (reg_num % num_regs != 0)\n \t  reg_num++;\n@@ -2323,7 +2317,7 @@ gcn_function_arg_advance (cumulative_args_t cum_v,\n       if (!arg.named)\n \treturn;\n \n-      int num_regs = num_arg_regs (arg.mode, arg.type);\n+      int num_regs = num_arg_regs (arg);\n       if (num_regs > 0)\n \twhile ((FIRST_PARM_REG + cum->num) % num_regs != 0)\n \t  cum->num++;\n@@ -2355,14 +2349,14 @@ gcn_arg_partial_bytes (cumulative_args_t cum_v, const function_arg_info &arg)\n   if (!arg.named)\n     return 0;\n \n-  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n+  if (targetm.calls.must_pass_in_stack (arg))\n     return 0;\n \n   if (cum->num >= NUM_PARM_REGS)\n     return 0;\n \n   /* If the argument fits entirely in registers, return 0.  */\n-  if (cum->num + num_arg_regs (arg.mode, arg.type) <= NUM_PARM_REGS)\n+  if (cum->num + num_arg_regs (arg) <= NUM_PARM_REGS)\n     return 0;\n \n   return (NUM_PARM_REGS - cum->num) * UNITS_PER_WORD;"}, {"sha": "49ab50ea41bfc008e7282915c7a248584dc0711d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -1455,19 +1455,19 @@ ix86_function_arg_regno_p (int regno)\n   return false;\n }\n \n-/* Return if we do not know how to pass TYPE solely in registers.  */\n+/* Return if we do not know how to pass ARG solely in registers.  */\n \n static bool\n-ix86_must_pass_in_stack (machine_mode mode, const_tree type)\n+ix86_must_pass_in_stack (const function_arg_info &arg)\n {\n-  if (must_pass_in_stack_var_size_or_pad (mode, type))\n+  if (must_pass_in_stack_var_size_or_pad (arg))\n     return true;\n \n   /* For 32-bit, we want TImode aggregates to go on the stack.  But watch out!\n      The layout_type routine is crafty and tries to trick us into passing\n      currently unsupported vector types on the stack by using TImode.  */\n-  return (!TARGET_64BIT && mode == TImode\n-\t  && type && TREE_CODE (type) != VECTOR_TYPE);\n+  return (!TARGET_64BIT && arg.mode == TImode\n+\t  && arg.type && TREE_CODE (arg.type) != VECTOR_TYPE);\n }\n \n /* It returns the size, in bytes, of the area reserved for arguments passed\n@@ -2062,9 +2062,13 @@ classify_argument (machine_mode mode, const_tree type,\n   if (bytes < 0)\n     return 0;\n \n-  if (mode != VOIDmode\n-      && targetm.calls.must_pass_in_stack (mode, type))\n-    return 0;\n+  if (mode != VOIDmode)\n+    {\n+      /* The value of \"named\" doesn't matter.  */\n+      function_arg_info arg (const_cast<tree> (type), mode, /*named=*/true);\n+      if (targetm.calls.must_pass_in_stack (arg))\n+\treturn 0;\n+    }\n \n   if (type && AGGREGATE_TYPE_P (type))\n     {"}, {"sha": "59c5132bc061d74774582c0bfd63fe0027520aa3", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -2300,7 +2300,7 @@ iq2000_pass_by_reference (cumulative_args_t cum_v,\n   /* We must pass by reference if we would be both passing in registers\n      and the stack.  This is because any subsequent partial arg would be\n      handled incorrectly in this case.  */\n-  if (cum && targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n+  if (cum && targetm.calls.must_pass_in_stack (arg))\n      {\n        /* Don't pass the actual CUM to FUNCTION_ARG, because we would\n \t  get double copies of any offsets generated for small structs"}, {"sha": "267ff274815cb0eadfa13222342496ca12ec40f9", "filename": "gcc/config/lm32/lm32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Flm32%2Flm32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Flm32%2Flm32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -629,7 +629,7 @@ lm32_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n     /* Compute operand 2 of the call insn.  */\n     return GEN_INT (0);\n \n-  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n+  if (targetm.calls.must_pass_in_stack (arg))\n     return NULL_RTX;\n \n   if (!arg.named"}, {"sha": "b259da506db2e91ad478ea8c1e4ca88a8a3716fe", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -2713,7 +2713,8 @@ mcore_num_arg_regs (machine_mode mode, const_tree type)\n {\n   int size;\n \n-  if (targetm.calls.must_pass_in_stack (mode, type))\n+  function_arg_info arg (const_cast<tree> (type), mode, /*named=*/true);\n+  if (targetm.calls.must_pass_in_stack (arg))\n     return 0;\n \n   if (type && mode == BLKmode)\n@@ -2803,7 +2804,7 @@ mcore_function_arg (cumulative_args_t cum, const function_arg_info &arg)\n   if (!arg.named || arg.end_marker_p ())\n     return 0;\n \n-  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n+  if (targetm.calls.must_pass_in_stack (arg))\n     return 0;\n \n   arg_reg = ROUND_REG (*get_cumulative_args (cum), arg.mode);\n@@ -2848,7 +2849,7 @@ mcore_arg_partial_bytes (cumulative_args_t cum, const function_arg_info &arg)\n   if (!arg.named)\n     return 0;\n \n-  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n+  if (targetm.calls.must_pass_in_stack (arg))\n     return 0;\n       \n   /* REG is not the *hardware* register number of the register that holds"}, {"sha": "c24dc710b132914a37348cc666836f12a524596d", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -6252,7 +6252,7 @@ mips_pass_by_reference (cumulative_args_t, const function_arg_info &arg)\n   else\n     {\n       /* If we have a variable-sized parameter, we have no choice.  */\n-      return targetm.calls.must_pass_in_stack (arg.mode, arg.type);\n+      return targetm.calls.must_pass_in_stack (arg);\n     }\n }\n "}, {"sha": "8ebb829506cfa78cb0f6e4f25725a02ff4a85973", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -621,7 +621,7 @@ mmix_function_arg_advance (cumulative_args_t argsp_v,\n   CUMULATIVE_ARGS *argsp = get_cumulative_args (argsp_v);\n   int arg_size = MMIX_FUNCTION_ARG_SIZE (arg.mode, arg.type);\n \n-  argsp->regs = ((targetm.calls.must_pass_in_stack (arg.mode, arg.type)\n+  argsp->regs = ((targetm.calls.must_pass_in_stack (arg)\n \t\t  || (arg_size > 8\n \t\t      && !TARGET_LIBFUNC\n \t\t      && !argsp->lib))\n@@ -647,7 +647,7 @@ mmix_function_arg_1 (const cumulative_args_t argsp_v,\n       : NULL_RTX;\n \n   return (argsp->regs < MMIX_MAX_ARGS_IN_REGS\n-\t  && !targetm.calls.must_pass_in_stack (arg.mode, arg.type)\n+\t  && !targetm.calls.must_pass_in_stack (arg)\n \t  && (GET_MODE_BITSIZE (arg.mode) <= 64\n \t      || argsp->lib\n \t      || TARGET_LIBFUNC))\n@@ -686,7 +686,7 @@ mmix_pass_by_reference (cumulative_args_t argsp_v,\n \n   /* FIXME: Check: I'm not sure the must_pass_in_stack check is\n      necessary.  */\n-  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n+  if (targetm.calls.must_pass_in_stack (arg))\n     return true;\n \n   if (MMIX_FUNCTION_ARG_SIZE (arg.mode, arg.type) > 8"}, {"sha": "3caae14e0e123fef37a4f71218cf881a85af07d7", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -1951,16 +1951,16 @@ nds32_function_arg (cumulative_args_t ca, const function_arg_info &arg)\n }\n \n static bool\n-nds32_must_pass_in_stack (machine_mode mode, const_tree type)\n+nds32_must_pass_in_stack (const function_arg_info &arg)\n {\n   /* Return true if a type must be passed in memory.\n      If it is NOT using hard float abi, small aggregates can be\n      passed in a register even we are calling a variadic function.\n      So there is no need to take padding into consideration.  */\n   if (TARGET_HARD_FLOAT)\n-    return must_pass_in_stack_var_size_or_pad (mode, type);\n+    return must_pass_in_stack_var_size_or_pad (arg);\n   else\n-    return must_pass_in_stack_var_size (mode, type);\n+    return must_pass_in_stack_var_size (arg);\n }\n \n static int"}, {"sha": "fb87bb2f2cbe18b93678547eee9274c2f03011ad", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -816,12 +816,12 @@ rs6000_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n /* Return true if TYPE must be passed on the stack and not in registers.  */\n \n bool\n-rs6000_must_pass_in_stack (machine_mode mode, const_tree type)\n+rs6000_must_pass_in_stack (const function_arg_info &arg)\n {\n   if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2 || TARGET_64BIT)\n-    return must_pass_in_stack_var_size (mode, type);\n+    return must_pass_in_stack_var_size (arg);\n   else\n-    return must_pass_in_stack_var_size_or_pad (mode, type);\n+    return must_pass_in_stack_var_size_or_pad (arg);\n }\n \n static inline bool\n@@ -2202,11 +2202,11 @@ rs6000_parm_needs_stack (cumulative_args_t args_so_far, tree type)\n   mode = promote_mode (type, TYPE_MODE (type), &unsignedp);\n \n   /* If we must pass in stack, we need a stack.  */\n-  if (rs6000_must_pass_in_stack (mode, type))\n+  function_arg_info arg (type, mode, /*named=*/true);\n+  if (rs6000_must_pass_in_stack (arg))\n     return true;\n \n   /* If there is no incoming register, we need a stack.  */\n-  function_arg_info arg (type, mode, /*named=*/true);\n   entry_parm = rs6000_function_arg (args_so_far, arg);\n   if (entry_parm == NULL)\n     return true;\n@@ -2457,7 +2457,7 @@ setup_incoming_varargs (cumulative_args_t cum,\n       first_reg_offset = next_cum.words;\n       save_area = crtl->args.internal_arg_pointer;\n \n-      if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n+      if (targetm.calls.must_pass_in_stack (arg))\n \tfirst_reg_offset += rs6000_arg_size (TYPE_MODE (arg.type), arg.type);\n     }\n "}, {"sha": "baccfb3f8872a141abc8764841b08375fb721906", "filename": "gcc/config/rs6000/rs6000-internal.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -156,7 +156,7 @@ extern void setup_incoming_varargs (cumulative_args_t,\n \t\t\t\t    const function_arg_info &, int *, int);\n extern unsigned int rs6000_function_arg_boundary (machine_mode mode,\n \t\t\t\t\t\t  const_tree type);\n-extern bool rs6000_must_pass_in_stack (machine_mode mode, const_tree type);\n+extern bool rs6000_must_pass_in_stack (const function_arg_info &);\n extern int rs6000_arg_partial_bytes (cumulative_args_t,\n \t\t\t\t     const function_arg_info &);\n extern void rs6000_function_arg_advance (cumulative_args_t,"}, {"sha": "3b22d960b619a5d1a4da59eac95d13e859d2b861", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -7901,7 +7901,7 @@ sh_pass_by_reference (cumulative_args_t cum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);\n \n-  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type))\n+  if (targetm.calls.must_pass_in_stack (arg))\n     return true;\n \n   /* ??? std_gimplify_va_arg_expr passes NULL for cum.  That function"}, {"sha": "23f546a0203007acab5910ca3c1416853c951573", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -1239,7 +1239,7 @@ xstormy16_function_arg (cumulative_args_t cum_v, const function_arg_info &arg)\n \n   if (arg.end_marker_p ())\n     return const0_rtx;\n-  if (targetm.calls.must_pass_in_stack (arg.mode, arg.type)\n+  if (targetm.calls.must_pass_in_stack (arg)\n       || (*cum + XSTORMY16_WORD_SIZE (arg.type, arg.mode)\n \t  > NUM_ARGUMENT_REGISTERS))\n     return NULL_RTX;"}, {"sha": "98f30c5cc21c91add2b246cfae1f850a7b3bda7c", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -2118,7 +2118,7 @@ xtensa_function_arg_advance (cumulative_args_t cum,\n \t   / UNITS_PER_WORD);\n \n   if (*arg_words < max\n-      && (targetm.calls.must_pass_in_stack (arg.mode, arg.type)\n+      && (targetm.calls.must_pass_in_stack (arg)\n \t  || *arg_words + words > max))\n     *arg_words = max;\n "}, {"sha": "55069088b52e8d6a5e123e9bdcee5c82334ae0a0", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -4012,8 +4012,8 @@ defined, the argument will be computed in the stack and then loaded into\n a register.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_MUST_PASS_IN_STACK (machine_mode @var{mode}, const_tree @var{type})\n-This target hook should return @code{true} if we should not pass @var{type}\n+@deftypefn {Target Hook} bool TARGET_MUST_PASS_IN_STACK (const function_arg_info @var{&arg})\n+This target hook should return @code{true} if we should not pass @var{arg}\n solely in registers.  The file @file{expr.h} defines a\n definition that is usually appropriate, refer to @file{expr.h} for additional\n documentation."}, {"sha": "46ed75c77be92af937e672dd29a85f8d1b704106", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -2552,8 +2552,7 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n \n   /* If this parameter was passed both in registers and in the stack, use\n      the copy on the stack.  */\n-  if (targetm.calls.must_pass_in_stack (data->promoted_mode,\n-\t\t\t\t\tdata->passed_type))\n+  if (targetm.calls.must_pass_in_stack (arg))\n     entry_parm = 0;\n \n   if (entry_parm)"}, {"sha": "b2332d8215c25fc0c159b0a9cc1f08966105a363", "filename": "gcc/target.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -4630,11 +4630,11 @@ false.\",\n    Need audit to verify that this is the case.  */\n DEFHOOK\n (must_pass_in_stack,\n- \"This target hook should return @code{true} if we should not pass @var{type}\\n\\\n+ \"This target hook should return @code{true} if we should not pass @var{arg}\\n\\\n solely in registers.  The file @file{expr.h} defines a\\n\\\n definition that is usually appropriate, refer to @file{expr.h} for additional\\n\\\n documentation.\",\n- bool, (machine_mode mode, const_tree type),\n+ bool, (const function_arg_info &arg),\n  must_pass_in_stack_var_size_or_pad)\n \n /* Return true if type TYPE, mode MODE, which is passed by reference,"}, {"sha": "1d12ec547047df1d71b57dcb27dcd467d7989cc6", "filename": "gcc/targhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ffef2005fd7536efbc9c3a572701998c8a8080c/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=0ffef2005fd7536efbc9c3a572701998c8a8080c", "patch": "@@ -323,7 +323,7 @@ bool\n hook_pass_by_reference_must_pass_in_stack (cumulative_args_t,\n \t\t\t\t\t   const function_arg_info &arg)\n {\n-  return targetm.calls.must_pass_in_stack (arg.mode, arg.type);\n+  return targetm.calls.must_pass_in_stack (arg);\n }\n \n /* Return true if a parameter follows callee copies conventions.  This"}]}