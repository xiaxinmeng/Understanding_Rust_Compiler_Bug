{"sha": "dfbcd65a0152513db985a552f7e75e24cb2be4d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZiY2Q2NWEwMTUyNTEzZGI5ODVhNTUyZjdlNzVlMjRjYjJiZTRkNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-08-27T15:30:49Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-08-27T15:30:49Z"}, "message": "Never change BINFO_INHERITANCE_CHAIN.\n\n\t* init.c (emit_base_init): Change modification of\n\tBINFO_INHERITANCE_CHAIN to an assert.\n\t* search.c (get_base_distance_recursive): Likewise.\n\t(get_base_distance): Likewise.\n\t(lookup_member): Likewise.\n\t(convert_pointer_to_single_level): Likewise.\n\t(lookup_field): Likewise.  Lose setting TREE_VIA_* on TREE_LISTs.\n\t(lookup_fnfields): Likewise.\n\t* tree.c (propagate_binfo_offsets): Don't call unshare_base_binfos.\n\t(unshare_base_binfos): Don't call propagate_binfo_offsets.\n\t(layout_basetypes): Call propagate_binfo_offsets instead of\n\tunshare_base_binfos.\n\t* decl.c (xref_basetypes): Call unshare_base_binfos.\n\t* pt.c (instantiate_class_template): Likewise.\n\t* tree.c (reverse_path): Remove 'copy' parm; always make a\n\ttemporary copy.\n\t* class.c (build_vbase_path): Just call it.\n\t* search.c (compute_access): Likewise.  Don't re-reverse.\n\nFrom-SVN: r22024", "tree": {"sha": "1e804ccfe218681304e0553b38219628709207f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e804ccfe218681304e0553b38219628709207f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfbcd65a0152513db985a552f7e75e24cb2be4d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfbcd65a0152513db985a552f7e75e24cb2be4d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfbcd65a0152513db985a552f7e75e24cb2be4d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfbcd65a0152513db985a552f7e75e24cb2be4d5/comments", "author": null, "committer": null, "parents": [{"sha": "3e2a2957a078fb0c887fbc5298b9cfdda236a98d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e2a2957a078fb0c887fbc5298b9cfdda236a98d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e2a2957a078fb0c887fbc5298b9cfdda236a98d"}], "stats": {"total": 211, "additions": 110, "deletions": 101}, "files": [{"sha": "a5b99482fd33e6e95bf9dfdb8d1b203c798be85f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dfbcd65a0152513db985a552f7e75e24cb2be4d5", "patch": "@@ -1,3 +1,25 @@\n+1998-08-27  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\tNever change BINFO_INHERITANCE_CHAIN.\n+\t* init.c (emit_base_init): Change modification of\n+\tBINFO_INHERITANCE_CHAIN to an assert.\n+\t* search.c (get_base_distance_recursive): Likewise.\n+\t(get_base_distance): Likewise.\n+\t(lookup_member): Likewise.\n+\t(convert_pointer_to_single_level): Likewise.\n+\t(lookup_field): Likewise.  Lose setting TREE_VIA_* on TREE_LISTs.\n+\t(lookup_fnfields): Likewise.\n+\t* tree.c (propagate_binfo_offsets): Don't call unshare_base_binfos.\n+\t(unshare_base_binfos): Don't call propagate_binfo_offsets.\n+\t(layout_basetypes): Call propagate_binfo_offsets instead of \n+\tunshare_base_binfos.\n+\t* decl.c (xref_basetypes): Call unshare_base_binfos.\n+\t* pt.c (instantiate_class_template): Likewise.\n+\t* tree.c (reverse_path): Remove 'copy' parm; always make a\n+\ttemporary copy.\n+\t* class.c (build_vbase_path): Just call it.\n+\t* search.c (compute_access): Likewise.  Don't re-reverse.\n+\n 1998-08-27  Mark Mitchell  <mark@markmitchell.com>\n \n \t* class.c (build_vbase_path): Use reverse_path."}, {"sha": "a836a095ee1297a606c14ad05efd7dcedde8fd70", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=dfbcd65a0152513db985a552f7e75e24cb2be4d5", "patch": "@@ -265,11 +265,7 @@ build_vbase_path (code, type, expr, path, nonnull)\n   nonnull_expr = expr;\n \n   if (BINFO_INHERITANCE_CHAIN (path))\n-    {\n-      push_expression_obstack ();\n-      path = reverse_path (path, /*copy=*/1);\n-      pop_obstacks ();\n-    }\n+    path = reverse_path (path);\n \n   basetype = BINFO_TYPE (path);\n "}, {"sha": "1ac399a977ed598b68e714820adee28d6b9fef4c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=dfbcd65a0152513db985a552f7e75e24cb2be4d5", "patch": "@@ -3017,7 +3017,7 @@ extern tree hash_chainon\t\t\tPROTO((tree, tree));\n extern tree get_decl_list\t\t\tPROTO((tree));\n extern tree make_binfo\t\t\t\tPROTO((tree, tree, tree, tree));\n extern tree binfo_value\t\t\t\tPROTO((tree, tree));\n-extern tree reverse_path\t\t\tPROTO((tree, int));\n+extern tree reverse_path\t\t\tPROTO((tree));\n extern int count_functions\t\t\tPROTO((tree));\n extern int is_overloaded_fn\t\t\tPROTO((tree));\n extern tree get_first_fn\t\t\tPROTO((tree));"}, {"sha": "e3b67acc383be864a039b057660c02435f827334", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=dfbcd65a0152513db985a552f7e75e24cb2be4d5", "patch": "@@ -11764,6 +11764,10 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t  TREE_VIA_VIRTUAL (base_binfo) = via_virtual;\n \t  BINFO_INHERITANCE_CHAIN (base_binfo) = TYPE_BINFO (ref);\n \n+\t  /* We need to unshare the binfos now so that lookups during class\n+\t     definition work.  */\n+\t  unshare_base_binfos (base_binfo);\n+\n \t  SET_CLASSTYPE_MARKED (basetype);\n \n \t  /* We are free to modify these bits because they are meaningless"}, {"sha": "29408630e1cd6e7d8288ca1de874d4b2a1797009", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=dfbcd65a0152513db985a552f7e75e24cb2be4d5", "patch": "@@ -569,11 +569,8 @@ emit_base_init (t, immediately)\n       if (TREE_VIA_VIRTUAL (base_binfo))\n \tcontinue;\n \n-#if 0 /* Once unsharing happens soon enough.  */\n-      my_friendly_assert (BINFO_INHERITANCE_CHAIN (base_binfo) == t_binfo, 999);\n-#else\n-      BINFO_INHERITANCE_CHAIN (base_binfo) = t_binfo;\n-#endif\n+      my_friendly_assert (BINFO_INHERITANCE_CHAIN (base_binfo) == t_binfo,\n+\t\t\t  999);\n \n       if (TREE_PURPOSE (rbase_init_list))\n \tinit = TREE_VALUE (rbase_init_list);"}, {"sha": "b0b89c4c3d337d11f5ae63b78e36326723a14bc8", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=dfbcd65a0152513db985a552f7e75e24cb2be4d5", "patch": "@@ -4297,6 +4297,9 @@ instantiate_class_template (type)\n \n \t    /* These are set up in xref_basetypes for normal classes, so\n \t       we have to handle them here for template bases.  */\n+\n+\t    unshare_base_binfos (elt);\n+\n \t    if (TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n \t      {\n \t\tTYPE_USES_VIRTUAL_BASECLASSES (type) = 1;"}, {"sha": "33fd19bf6126fcfe7e903430ab6fca92e70e3c74", "filename": "gcc/cp/search.c", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=dfbcd65a0152513db985a552f7e75e24cb2be4d5", "patch": "@@ -683,7 +683,8 @@ get_base_distance_recursive (binfo, depth, is_private, rval,\n \t\t\t\t\t      current_scope_in_chain);\n \t  /* watch for updates; only update if path is good.  */\n \t  if (path_ptr && WATCH_VALUES (rval, *via_virtual_ptr) != was)\n-\t    BINFO_INHERITANCE_CHAIN (base_binfo) = binfo;\n+\t    my_friendly_assert (BINFO_INHERITANCE_CHAIN (base_binfo) == binfo,\n+\t\t\t\t980827);\n \t  if (rval == -2 && *via_virtual_ptr == 0)\n \t    return rval;\n \n@@ -741,7 +742,8 @@ get_base_distance (parent, binfo, protect, path_ptr)\n       binfo = TYPE_BINFO (type);\n \n       if (path_ptr)\n-\tBINFO_INHERITANCE_CHAIN (binfo) = NULL_TREE;\n+\tmy_friendly_assert (BINFO_INHERITANCE_CHAIN (binfo) == NULL_TREE,\n+\t\t\t    980827);\n     }\n   else\n     my_friendly_abort (92);\n@@ -777,7 +779,7 @@ get_base_distance (parent, binfo, protect, path_ptr)\n       && parent == binfo_member (BINFO_TYPE (parent),\n \t\t\t\t CLASSTYPE_VBASECLASSES (type)))\n     {\n-      BINFO_INHERITANCE_CHAIN (parent) = binfo;\n+      my_friendly_assert (BINFO_INHERITANCE_CHAIN (parent) == binfo, 980827);\n       new_binfo = parent;\n       rval = 1;\n     }\n@@ -1003,7 +1005,7 @@ compute_access (basetype_path, field)\n     }\n \n   /* must reverse more than one element */\n-  basetype_path = reverse_path (basetype_path, /*copy=*/0);\n+  basetype_path = reverse_path (basetype_path);\n   types = basetype_path;\n   via_protected = 0;\n   access = access_default_node;\n@@ -1049,7 +1051,6 @@ compute_access (basetype_path, field)\n       else\n \tbreak;\n     }\n-  reverse_path (basetype_path, /*copy=*/0);\n \n   /* No special visibilities apply.  Use normal rules.  */\n \n@@ -1223,7 +1224,8 @@ lookup_field (xbasetype, name, protect, want_type)\n     {\n       type = xbasetype;\n       basetype_path = TYPE_BINFO (type);\n-      BINFO_INHERITANCE_CHAIN (basetype_path) = NULL_TREE;\n+      my_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path) == NULL_TREE,\n+\t\t\t  980827);\n     }\n   else\n     my_friendly_abort (97);\n@@ -1315,9 +1317,6 @@ lookup_field (xbasetype, name, protect, want_type)\n     }\n \n   basetype_chain = build_expr_list (NULL_TREE, basetype_path);\n-  TREE_VIA_PUBLIC (basetype_chain) = TREE_VIA_PUBLIC (basetype_path);\n-  TREE_VIA_PROTECTED (basetype_chain) = TREE_VIA_PROTECTED (basetype_path);\n-  TREE_VIA_VIRTUAL (basetype_chain) = TREE_VIA_VIRTUAL (basetype_path);\n \n   /* The ambiguity check relies upon breadth first searching.  */\n \n@@ -1341,9 +1340,6 @@ lookup_field (xbasetype, name, protect, want_type)\n \n \t      SET_BINFO_FIELDS_MARKED (base_binfo);\n \t      btypes = my_tree_cons (NULL_TREE, base_binfo, basetype_chain);\n-\t      TREE_VIA_PUBLIC (btypes) = TREE_VIA_PUBLIC (base_binfo);\n-\t      TREE_VIA_PROTECTED (btypes) = TREE_VIA_PROTECTED (base_binfo);\n-\t      TREE_VIA_VIRTUAL (btypes) = TREE_VIA_VIRTUAL (base_binfo);\n \t      if (TREE_VIA_VIRTUAL (base_binfo))\n \t\tbtypes = my_tree_cons (NULL_TREE,\n \t\t\t\t    TYPE_BINFO (BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (binfo_h), i))),\n@@ -1368,9 +1364,12 @@ lookup_field (xbasetype, name, protect, want_type)\n       basetype_chain = TREE_CHAIN (basetype_chain);\n       basetype_path = TREE_VALUE (basetype_chain);\n       if (TREE_CHAIN (basetype_chain))\n-\tBINFO_INHERITANCE_CHAIN (basetype_path) = TREE_VALUE (TREE_CHAIN (basetype_chain));\n+\tmy_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path)\n+\t\t\t    == TREE_VALUE (TREE_CHAIN (basetype_chain)),\n+\t\t\t    980827);\n       else\n-\tBINFO_INHERITANCE_CHAIN (basetype_path) = NULL_TREE;\n+\tmy_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path)\n+\t\t\t    == NULL_TREE, 980827);\n \n       binfo = basetype_path;\n       type = BINFO_TYPE (binfo);\n@@ -1850,16 +1849,11 @@ lookup_fnfields (basetype_path, name, complain)\n   if (basetype_path == TYPE_BINFO (type))\n     {\n       basetype_chain = CLASSTYPE_BINFO_AS_LIST (type);\n-      TREE_VIA_PUBLIC (basetype_chain) = 1;\n-      BINFO_INHERITANCE_CHAIN (basetype_path) = NULL_TREE;\n+      my_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path) == NULL_TREE,\n+\t\t\t  980827);\n     }\n   else\n-    {\n-      basetype_chain = build_expr_list (NULL_TREE, basetype_path);\n-      TREE_VIA_PUBLIC (basetype_chain) = TREE_VIA_PUBLIC (basetype_path);\n-      TREE_VIA_PROTECTED (basetype_chain) = TREE_VIA_PROTECTED (basetype_path);\n-      TREE_VIA_VIRTUAL (basetype_chain) = TREE_VIA_VIRTUAL (basetype_path);\n-    }\n+    basetype_chain = build_expr_list (NULL_TREE, basetype_path);\n \n   /* The ambiguity check relies upon breadth first searching.  */\n \n@@ -1883,9 +1877,6 @@ lookup_fnfields (basetype_path, name, complain)\n \n \t      SET_BINFO_FIELDS_MARKED (base_binfo);\n \t      btypes = my_tree_cons (NULL_TREE, base_binfo, basetype_chain);\n-\t      TREE_VIA_PUBLIC (btypes) = TREE_VIA_PUBLIC (base_binfo);\n-\t      TREE_VIA_PROTECTED (btypes) = TREE_VIA_PROTECTED (base_binfo);\n-\t      TREE_VIA_VIRTUAL (btypes) = TREE_VIA_VIRTUAL (base_binfo);\n \t      if (TREE_VIA_VIRTUAL (base_binfo))\n \t\tbtypes = my_tree_cons (NULL_TREE,\n \t\t\t\t    TYPE_BINFO (BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (binfo_h), i))),\n@@ -1910,9 +1901,12 @@ lookup_fnfields (basetype_path, name, complain)\n       basetype_chain = TREE_CHAIN (basetype_chain);\n       basetype_path = TREE_VALUE (basetype_chain);\n       if (TREE_CHAIN (basetype_chain))\n-\tBINFO_INHERITANCE_CHAIN (basetype_path) = TREE_VALUE (TREE_CHAIN (basetype_chain));\n+\tmy_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path)\n+\t\t\t    == TREE_VALUE (TREE_CHAIN (basetype_chain)),\n+\t\t\t    980827);\n       else\n-\tBINFO_INHERITANCE_CHAIN (basetype_path) = NULL_TREE;\n+\tmy_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path)\n+\t\t\t    == NULL_TREE, 980827);\n \n       binfo = basetype_path;\n       type = BINFO_TYPE (binfo);\n@@ -2016,7 +2010,8 @@ lookup_member (xbasetype, name, protect, want_type)\n   else if (IS_AGGR_TYPE_CODE (TREE_CODE (xbasetype)))\n     {\n       basetype_path = TYPE_BINFO (xbasetype);\n-      BINFO_INHERITANCE_CHAIN (basetype_path) = NULL_TREE;\n+      my_friendly_assert (BINFO_INHERITANCE_CHAIN (basetype_path)\n+\t\t\t  == NULL_TREE, 980827);\n     }\n   else\n     my_friendly_abort (97);\n@@ -2538,9 +2533,12 @@ convert_pointer_to_single_level (to_type, expr)\n \n   binfo_of_derived = TYPE_BINFO (TREE_TYPE (TREE_TYPE (expr)));\n   last = get_binfo (to_type, TREE_TYPE (TREE_TYPE (expr)), 0);\n-  BINFO_INHERITANCE_CHAIN (last) = binfo_of_derived;\n-  BINFO_INHERITANCE_CHAIN (binfo_of_derived) = NULL_TREE;\n-  return build_vbase_path (PLUS_EXPR, build_pointer_type (to_type), expr, last, 1);\n+  my_friendly_assert (BINFO_INHERITANCE_CHAIN (last) == binfo_of_derived,\n+\t\t      980827);\n+  my_friendly_assert (BINFO_INHERITANCE_CHAIN (binfo_of_derived) == NULL_TREE,\n+\t\t      980827);\n+  return build_vbase_path (PLUS_EXPR, build_pointer_type (to_type), expr,\n+\t\t\t   last, 1);\n }\n \n /* The main function which implements depth first search."}, {"sha": "41475b5f46782f29b6c1c8f56fb5c434a64128c8", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 48, "deletions": 59, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbcd65a0152513db985a552f7e75e24cb2be4d5/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=dfbcd65a0152513db985a552f7e75e24cb2be4d5", "patch": "@@ -39,7 +39,6 @@ static int list_hash PROTO((tree, tree, tree));\n static tree list_hash_lookup PROTO((int, int, int, int, tree, tree,\n \t\t\t\t    tree));\n static void propagate_binfo_offsets PROTO((tree, tree));\n-static void unshare_base_binfos PROTO((tree));\n static int avoid_overlap PROTO((tree, tree));\n \n #define CEIL(x,y) (((x) + (y) - 1) / (y))\n@@ -584,10 +583,7 @@ propagate_binfo_offsets (binfo, offset)\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n \n       if (TREE_VIA_VIRTUAL (base_binfo))\n-\t{\n-\t  i += 1;\n-\t  unshare_base_binfos (base_binfo);\n-\t}\t  \n+\ti += 1;\n       else\n \t{\n \t  int j;\n@@ -614,7 +610,7 @@ propagate_binfo_offsets (binfo, offset)\n \t  BINFO_OFFSET (base_binfo) = offset;\n #endif\n \n-\t  unshare_base_binfos (base_binfo);\n+\t  propagate_binfo_offsets (base_binfo, offset);\n \n \t  /* Go to our next class that counts for offset propagation.  */\n \t  i = j;\n@@ -624,39 +620,35 @@ propagate_binfo_offsets (binfo, offset)\n     }\n }\n \n-/* Makes new binfos for the indirect bases under BASE_BINFO, and updates\n+/* Makes new binfos for the indirect bases under BINFO, and updates\n    BINFO_OFFSET for them and their bases.  */\n \n-static void\n-unshare_base_binfos (base_binfo)\n-     tree base_binfo;\n+void\n+unshare_base_binfos (binfo)\n+     tree binfo;\n {\n-  if (BINFO_BASETYPES (base_binfo))\n-    {\n-      tree base_binfos = BINFO_BASETYPES (base_binfo);\n-      tree chain = NULL_TREE;\n-      int j;\n+  tree binfos = BINFO_BASETYPES (binfo);\n+  tree new_binfo;\n+  int j;\n \n-      /* Now unshare the structure beneath BASE_BINFO.  */\n-      for (j = TREE_VEC_LENGTH (base_binfos)-1;\n-\t   j >= 0; j--)\n-\t{\n-\t  tree base_base_binfo = TREE_VEC_ELT (base_binfos, j);\n-\t  TREE_VEC_ELT (base_binfos, j)\n-\t    = make_binfo (BINFO_OFFSET (base_base_binfo),\n-\t\t\t  base_base_binfo,\n-\t\t\t  BINFO_VTABLE (base_base_binfo),\n-\t\t\t  BINFO_VIRTUALS (base_base_binfo));\n-\t  chain = TREE_VEC_ELT (base_binfos, j);\n-\t  TREE_VIA_PUBLIC (chain) = TREE_VIA_PUBLIC (base_base_binfo);\n-\t  TREE_VIA_PROTECTED (chain) = TREE_VIA_PROTECTED (base_base_binfo);\n-\t  TREE_VIA_VIRTUAL (chain) = TREE_VIA_VIRTUAL (base_base_binfo);\n-\t  BINFO_INHERITANCE_CHAIN (chain) = base_binfo;\n-\t}\n+  if (binfos == NULL_TREE)\n+    return;\n \n-      /* Completely unshare potentially shared data, and\n-\t update what is ours.  */\n-      propagate_binfo_offsets (base_binfo, BINFO_OFFSET (base_binfo));\n+  /* Now unshare the structure beneath BINFO.  */\n+  for (j = TREE_VEC_LENGTH (binfos)-1;\n+       j >= 0; j--)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (binfos, j);\n+      new_binfo = TREE_VEC_ELT (binfos, j)\n+\t= make_binfo (BINFO_OFFSET (base_binfo),\n+\t\t      base_binfo,\n+\t\t      BINFO_VTABLE (base_binfo),\n+\t\t      BINFO_VIRTUALS (base_binfo));\n+      TREE_VIA_PUBLIC (new_binfo) = TREE_VIA_PUBLIC (base_binfo);\n+      TREE_VIA_PROTECTED (new_binfo) = TREE_VIA_PROTECTED (base_binfo);\n+      TREE_VIA_VIRTUAL (new_binfo) = TREE_VIA_VIRTUAL (base_binfo);\n+      BINFO_INHERITANCE_CHAIN (new_binfo) = binfo;\n+      unshare_base_binfos (new_binfo);\n     }\n }\n \n@@ -758,28 +750,27 @@ layout_basetypes (rec, max)\n       tree field = TYPE_FIELDS (rec);\n \n       if (TREE_VIA_VIRTUAL (base_binfo))\n-\tunshare_base_binfos (base_binfo);\n-      else\n-\t{\n-\t  my_friendly_assert (TREE_TYPE (field) == basetype, 23897);\n+\tcontinue;\n \n-\t  if (get_base_distance (basetype, rec, 0, (tree*)0) == -2)\n-\t    cp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n-\t\t\tbasetype, rec);\n+      my_friendly_assert (TREE_TYPE (field) == basetype, 23897);\n \n-\t  BINFO_OFFSET (base_binfo)\n-\t    = size_int (CEIL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field)),\n-\t\t\t      BITS_PER_UNIT));\n-\t  unshare_base_binfos (base_binfo);\n-\t  TYPE_FIELDS (rec) = TREE_CHAIN (field);\n-\t}\n+      if (get_base_distance (basetype, rec, 0, (tree*)0) == -2)\n+\tcp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n+\t\t    basetype, rec);\n+\n+      BINFO_OFFSET (base_binfo)\n+\t= size_int (CEIL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field)),\n+\t\t\t  BITS_PER_UNIT));\n+      propagate_binfo_offsets (base_binfo, BINFO_OFFSET (base_binfo));\n+      TYPE_FIELDS (rec) = TREE_CHAIN (field);\n     }\n \n   for (vbase_types = CLASSTYPE_VBASECLASSES (rec); vbase_types;\n        vbase_types = TREE_CHAIN (vbase_types))\n     {\n       BINFO_INHERITANCE_CHAIN (vbase_types) = TYPE_BINFO (rec);\n       unshare_base_binfos (vbase_types);\n+      propagate_binfo_offsets (vbase_types, BINFO_OFFSET (vbase_types));\n \n       if (extra_warnings)\n \t{\n@@ -1258,26 +1249,24 @@ binfo_value (elem, type)\n   return get_binfo (elem, type, 0);\n }\n \n-/* Reverse the BINFO-chain given by PATH.  (If the \n+/* Return a reversed copy of the BINFO-chain given by PATH.  (If the \n    BINFO_INHERITANCE_CHAIN points from base classes to derived\n    classes, it will instead point from derived classes to base\n-   classes.)  Returns the first node in the reversed chain.  If COPY\n-   is non-zero, the nodes are copied as the chain is traversed.  */\n+   classes.)  Returns the first node in the reversed chain.  */\n \n tree\n-reverse_path (path, copy)\n+reverse_path (path)\n      tree path;\n-     int copy;\n {\n-  register tree prev = 0, tmp, next;\n-  for (tmp = path; tmp; tmp = next)\n+  register tree prev = NULL_TREE, cur;\n+  push_expression_obstack ();\n+  for (cur = path; cur; cur = BINFO_INHERITANCE_CHAIN (cur))\n     {\n-      if (copy) \n-\ttmp = copy_node (tmp);\n-      next = BINFO_INHERITANCE_CHAIN (tmp);\n-      BINFO_INHERITANCE_CHAIN (tmp) = prev;\n-      prev = tmp;\n+      tree r = copy_node (cur);\n+      BINFO_INHERITANCE_CHAIN (r) = prev;\n+      prev = r;\n     }\n+  pop_obstacks ();\n   return prev;\n }\n "}]}