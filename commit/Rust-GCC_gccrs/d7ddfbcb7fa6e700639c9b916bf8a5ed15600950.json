{"sha": "d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdkZGZiY2I3ZmE2ZTcwMDYzOWM5YjkxNmJmOGE1ZWQxNTYwMDk1MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-11-30T21:03:25Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-30T21:03:25Z"}, "message": "cgraph.h (symtab_node): Add symver flag.\n\n\n2019-11-30  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* cgraph.h (symtab_node): Add symver flag.\n\t* cgraphunit.c (process_symver_attribute): New.\n\t(process_common_attributes): Use process_symver_attribute.\n\t* lto-cgraph.c (lto_output_node): Stream symver.\n\t(lto_output_varpool_node): Stream symver.\n\t(input_overwrite_node): Stream symver.\n\t(input_varpool_node): Stream symver.\n\t* output.h (do_assemble_symver): Decalre.\n\t* symtab.c (symtab_node::dump_base): Dump symver.\n\t(symtab_node::verify_base): Verify symver.\n\t(symtab_node::resolve_alias): Handle symver.\n\t* varasm.c (do_assemble_symver): New function.\n\t* varpool.c (varpool_node::assemble_aliases): Use it.\n\t* doc/extend.texi: (symver attribute): Document.\n\t* config/elfos.h (ASM_OUTPUT_SYMVER_DIRECTIVE): New.\n\nc-family/ChangeLog:\n\n2019-11-30  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* c-attribs.c (handle_symver_attribute): New function\n\t(c_common_attributes): Add symver.\n\nFrom-SVN: r278878", "tree": {"sha": "3e8ad36922e2df05cdc896aec48daa30135163d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e8ad36922e2df05cdc896aec48daa30135163d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/comments", "author": null, "committer": null, "parents": [{"sha": "65ef05d0b7fb429c5760189e638c441dc3da33f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65ef05d0b7fb429c5760189e638c441dc3da33f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65ef05d0b7fb429c5760189e638c441dc3da33f4"}], "stats": {"total": 260, "additions": 256, "deletions": 4}, "files": [{"sha": "c03556b8d3b768f2405a204f37060ab9912f8647", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "patch": "@@ -1,3 +1,21 @@\n+2019-11-30  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraph.h (symtab_node): Add symver flag.\n+\t* cgraphunit.c (process_symver_attribute): New.\n+\t(process_common_attributes): Use process_symver_attribute.\n+\t* lto-cgraph.c (lto_output_node): Stream symver.\n+\t(lto_output_varpool_node): Stream symver.\n+\t(input_overwrite_node): Stream symver.\n+\t(input_varpool_node): Stream symver.\n+\t* output.h (do_assemble_symver): Decalre.\n+\t* symtab.c (symtab_node::dump_base): Dump symver.\n+\t(symtab_node::verify_base): Verify symver.\n+\t(symtab_node::resolve_alias): Handle symver.\n+\t* varasm.c (do_assemble_symver): New function.\n+\t* varpool.c (varpool_node::assemble_aliases): Use it.\n+\t* doc/extend.texi: (symver attribute): Document.\n+\t* config/elfos.h (ASM_OUTPUT_SYMVER_DIRECTIVE): New.\n+\n 2019-11-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* target.h (type_context_kind): New enum."}, {"sha": "fa3b94232fb3acdbeadf92f734569bf95d4f1476", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "patch": "@@ -1,3 +1,8 @@\n+2019-11-30  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* c-attribs.c (handle_symver_attribute): New function\n+\t(c_common_attributes): Add symver.\n+\n 2019-11-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* c-common.c (pointer_int_sum): Use verify_type_context to check"}, {"sha": "dc56e2ec62ffc7f494cc59ddf02452ac0cb406de", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "patch": "@@ -66,6 +66,7 @@ static tree handle_stack_protect_attribute (tree *, tree, tree, int, bool *);\n static tree handle_noinline_attribute (tree *, tree, tree, int, bool *);\n static tree handle_noclone_attribute (tree *, tree, tree, int, bool *);\n static tree handle_nocf_check_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_symver_attribute (tree *, tree, tree, int, bool *);\n static tree handle_noicf_attribute (tree *, tree, tree, int, bool *);\n static tree handle_noipa_attribute (tree *, tree, tree, int, bool *);\n static tree handle_leaf_attribute (tree *, tree, tree, int, bool *);\n@@ -475,6 +476,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      NULL },\n   { \"nocf_check\",\t      0, 0, false, true, true, true,\n \t\t\t      handle_nocf_check_attribute, NULL },\n+  { \"symver\",\t\t      1, -1, true, false, false, false,\n+\t\t\t      handle_symver_attribute, NULL},\n   { \"copy\",                   1, 1, false, false, false, false,\n \t\t\t      handle_copy_attribute, NULL },\n   { \"noinit\",\t\t      0, 0, true,  false, false, false,\n@@ -2335,6 +2338,62 @@ handle_noplt_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+/* Handle a \"symver\" attribute.  */\n+\n+static tree\n+handle_symver_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n+\t\t\t int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  tree symver;\n+  const char *symver_str;\n+\n+  if (TREE_CODE (*node) != FUNCTION_DECL && TREE_CODE (*node) != VAR_DECL)\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%<symver%> attribute only applies to functions and variables\");\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  if (!decl_in_symtab_p (*node))\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%<symver%> attribute is only applicable to symbols\");\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  for (; args; args = TREE_CHAIN (args))\n+    {\n+      symver = TREE_VALUE (args);\n+      if (TREE_CODE (symver) != STRING_CST)\n+\t{\n+\t  error (\"%<symver%> attribute argument not a string constant\");\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n+\n+      symver_str = TREE_STRING_POINTER (symver);\n+\n+      int ats = 0;\n+      for (int n = 0; (int)n < TREE_STRING_LENGTH (symver); n++)\n+\tif (symver_str[n] == '@')\n+\t  ats++;\n+\n+      if (ats != 1 && ats != 2)\n+\t{\n+\t  error (\"symver attribute argument must have format %<name@nodename%>\");\n+\t  error (\"%<symver%> attribute argument %qs must contain one or two \"\n+\t\t \"%<@%>\", symver_str);\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\n /* Handle an \"alias\" or \"ifunc\" attribute; arguments as in\n    struct attribute_spec.handler, except that IS_ALIAS tells us\n    whether this is an alias as opposed to ifunc attribute.  */"}, {"sha": "9c086fedaef4f436eae002e50c073d2c3c6626dc", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "patch": "@@ -497,6 +497,8 @@ struct GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n      and their visibility needs to be copied from their \"masters\" at\n      the end of parsing.  */\n   unsigned cpp_implicit_alias : 1;\n+  /* The alias is a symbol version.  */\n+  unsigned symver : 1;\n   /* Set once the definition was analyzed.  The list of references and\n      other properties are built during analysis.  */\n   unsigned analyzed : 1;"}, {"sha": "75ff10bc0cdbf32b4d734d48d2fa97f9d6c06b13", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 90, "deletions": 2, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "patch": "@@ -711,6 +711,89 @@ symbol_table::process_same_body_aliases (void)\n   cpp_implicit_aliases_done = true;\n }\n \n+/* Process a symver attribute.  */\n+\n+static void\n+process_symver_attribute (symtab_node *n)\n+{\n+  tree value = lookup_attribute (\"symver\", DECL_ATTRIBUTES (n->decl));\n+\n+  if (!value)\n+    return;\n+  if (lookup_attribute (\"symver\", TREE_CHAIN (value)))\n+    {\n+      error_at (DECL_SOURCE_LOCATION (n->decl),\n+\t\t\"multiple versions for one symbol\");\n+      return;\n+    }\n+  tree symver = get_identifier_with_length\n+\t\t  (TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (value))),\n+\t\t   TREE_STRING_LENGTH (TREE_VALUE (TREE_VALUE (value))));\n+  symtab_node *def = symtab_node::get_for_asmname (symver);\n+\n+  if (def)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (n->decl),\n+\t\t\"duplicate definition of a symbol version\");\n+      inform (DECL_SOURCE_LOCATION (def->decl),\n+\t      \"same version was previously defined here\");\n+      return;\n+    }\n+  if (!n->definition)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (n->decl),\n+\t\t\"symbol needs to be defined to have a version\");\n+      return;\n+    }\n+  if (DECL_COMMON (n->decl))\n+    {\n+      error_at (DECL_SOURCE_LOCATION (n->decl),\n+\t\t\"common symbol cannot be versioned\");\n+      return;\n+    }\n+  if (DECL_COMDAT (n->decl))\n+    {\n+      error_at (DECL_SOURCE_LOCATION (n->decl),\n+\t\t\"comdat symbol cannot be versioned\");\n+      return;\n+    }\n+  if (n->weakref)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (n->decl),\n+\t\t\"weakref cannot be versioned\");\n+      return;\n+    }\n+  if (!TREE_PUBLIC (n->decl))\n+    {\n+      error_at (DECL_SOURCE_LOCATION (n->decl),\n+\t\t\"versioned symbol must be public\");\n+      return;\n+    }\n+  if (DECL_VISIBILITY (n->decl) != VISIBILITY_DEFAULT)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (n->decl),\n+\t\t\"versioned symbol must have default visibility\");\n+      return;\n+    }\n+\n+  /* Create new symbol table entry representing the version.  */\n+  tree new_decl = copy_node (n->decl);\n+\n+  DECL_INITIAL (new_decl) = NULL_TREE;\n+  if (TREE_CODE (new_decl) == FUNCTION_DECL)\n+    DECL_STRUCT_FUNCTION (new_decl) = NULL;\n+  SET_DECL_ASSEMBLER_NAME (new_decl, symver);\n+  TREE_PUBLIC (new_decl) = 1;\n+  DECL_ATTRIBUTES (new_decl) = NULL;\n+\n+  symtab_node *symver_node = symtab_node::get_create (new_decl);\n+  symver_node->alias = true;\n+  symver_node->definition = true;\n+  symver_node->symver = true;\n+  symver_node->create_reference (n, IPA_REF_ALIAS, NULL);\n+  symver_node->analyzed = true;\n+}\n+\n /* Process attributes common for vars and functions.  */\n \n static void\n@@ -730,6 +813,7 @@ process_common_attributes (symtab_node *node, tree decl)\n \n   if (lookup_attribute (\"no_reorder\", DECL_ATTRIBUTES (decl)))\n     node->no_reorder = 1;\n+  process_symver_attribute (node);\n }\n \n /* Look for externally_visible and used attributes and mark cgraph nodes\n@@ -2137,8 +2221,12 @@ cgraph_node::assemble_thunks_and_aliases (void)\n \t  /* Force assemble_alias to really output the alias this time instead\n \t     of buffering it in same alias pairs.  */\n \t  TREE_ASM_WRITTEN (decl) = 1;\n-\t  do_assemble_alias (alias->decl,\n-\t\t\t     DECL_ASSEMBLER_NAME (decl));\n+\t  if (alias->symver)\n+\t    do_assemble_symver (alias->decl,\n+\t\t\t\tDECL_ASSEMBLER_NAME (decl));\n+\t  else\n+\t    do_assemble_alias (alias->decl,\n+\t\t\t       DECL_ASSEMBLER_NAME (decl));\n \t  alias->assemble_thunks_and_aliases ();\n \t  TREE_ASM_WRITTEN (decl) = saved_written;\n \t}"}, {"sha": "e91c0f34c72e490dc09b4f16d2f9c8f58933e62c", "filename": "gcc/config/elfos.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fconfig%2Felfos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fconfig%2Felfos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felfos.h?ref=d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "patch": "@@ -248,6 +248,17 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n     }\t\t\t\t\t\\\n   while (0)\n \n+#define ASM_OUTPUT_SYMVER_DIRECTIVE(FILE, NAME, NAME2)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fputs (\"\\t.symver\\t\", (FILE));\t\t\t\t\\\n+      assemble_name ((FILE), (NAME));\t\t\t\t\\\n+      fputs (\", \", (FILE));\t\t\t\t\t\\\n+      assemble_name ((FILE), (NAME2));\t\t\t\t\\\n+      fputc ('\\n', (FILE));\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n /* The following macro defines the format used to output the second\n    operand of the .type assembler directive.  Different svr4 assemblers\n    expect various different forms for this operand.  The one given here"}, {"sha": "b487e03fa963974747fbf2d3a96437e213f97275", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "patch": "@@ -3711,6 +3711,41 @@ Function Attributes}, @ref{PowerPC Function Attributes},\n @ref{Nios II Function Attributes}, and @ref{S/390 Function Attributes}\n for details.\n \n+@item symver (\"@var{name2}@@@var{nodename}\")\n+On ELF targets this attribute creates a symbol version.  The @var{name2} part\n+of the parameter is the actual name of the symbol by which it will be\n+externally referenced.  The @code{nodename} portion should be the name of a\n+node specified in the version script supplied to the linker when building a\n+shared library.  Versioned symbol must be defined and must be exported with\n+default visibility.\n+\n+@smallexample\n+__attribute__ ((__symver__ (\"foo@@VERS_1\"))) int\n+foo_v1 (void)\n+@{\n+@}\n+@end smallexample\n+\n+Will produce a @code{.symver foo_v1, foo@@VERS_1} directive in the assembler\n+output. \n+\n+It's an error to define multiple version of a given symbol.  In such case\n+an alias can be used.\n+\n+@smallexample\n+__attribute__ ((__symver__ (\"foo@@VERS_2\")))\n+__attribute__ ((alias (\"foo_v1\")))\n+int symver_foo_v1 (void);\n+@end smallexample\n+\n+This example creates an alias of @code{foo_v1} with symbol name\n+@code{symver_foo_v1} which will be version @code{VERS_2} of @code{foo}.\n+\n+Finally if the parameter is @code{\"@var{name2}@@@@@var{nodename}\"} then in\n+addition to creating a symbol version (as if\n+@code{\"@var{name2}@@@var{nodename}\"} was used) the version will be also used\n+to resolve @var{name2} by the linker.\n+\n @item target_clones (@var{options})\n @cindex @code{target_clones} function attribute\n The @code{target_clones} attribute is used to specify that a function"}, {"sha": "b5221cd41f93daf066933ae8988ae19d34a67fb3", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "patch": "@@ -526,6 +526,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->alias, 1);\n   bp_pack_value (&bp, node->transparent_alias, 1);\n   bp_pack_value (&bp, node->weakref, 1);\n+  bp_pack_value (&bp, node->symver, 1);\n   bp_pack_value (&bp, node->frequency, 2);\n   bp_pack_value (&bp, node->only_called_at_startup, 1);\n   bp_pack_value (&bp, node->only_called_at_exit, 1);\n@@ -609,6 +610,7 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n   bp_pack_value (&bp, node->alias, 1);\n   bp_pack_value (&bp, node->transparent_alias, 1);\n   bp_pack_value (&bp, node->weakref, 1);\n+  bp_pack_value (&bp, node->symver, 1);\n   bp_pack_value (&bp, node->analyzed && (!boundary_p || node->alias), 1);\n   gcc_assert (node->definition || !node->analyzed);\n   /* Constant pool initializers can be de-unified into individual ltrans units.\n@@ -1173,6 +1175,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->alias = bp_unpack_value (bp, 1);\n   node->transparent_alias = bp_unpack_value (bp, 1);\n   node->weakref = bp_unpack_value (bp, 1);\n+  node->symver = bp_unpack_value (bp, 1);\n   node->frequency = (enum node_frequency)bp_unpack_value (bp, 2);\n   node->only_called_at_startup = bp_unpack_value (bp, 1);\n   node->only_called_at_exit = bp_unpack_value (bp, 1);\n@@ -1371,6 +1374,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   node->alias = bp_unpack_value (&bp, 1);\n   node->transparent_alias = bp_unpack_value (&bp, 1);\n   node->weakref = bp_unpack_value (&bp, 1);\n+  node->symver = bp_unpack_value (&bp, 1);\n   node->analyzed = bp_unpack_value (&bp, 1);\n   node->used_from_other_partition = bp_unpack_value (&bp, 1);\n   node->in_other_partition = bp_unpack_value (&bp, 1);"}, {"sha": "4ac7d5077337bbd88bd1c157d70d9f9c20d028e3", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "patch": "@@ -167,6 +167,7 @@ extern int decode_reg_name (const char *);\n extern int decode_reg_name_and_count (const char *, int *);\n \n extern void do_assemble_alias (tree, tree);\n+extern void do_assemble_symver (tree, tree);\n \n extern void default_assemble_visibility (tree, int);\n "}, {"sha": "f4317d02b719bc817ef2b4bbb8ddd66c42d22ed7", "filename": "gcc/symtab.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "patch": "@@ -848,6 +848,8 @@ symtab_node::dump_base (FILE *f)\n     fprintf (f, \" transparent_alias\");\n   if (weakref)\n     fprintf (f, \" weakref\");\n+  if (symver)\n+    fprintf (f, \" symver\");\n   if (cpp_implicit_alias)\n     fprintf (f, \" cpp_implicit_alias\");\n   if (alias_target)\n@@ -1147,6 +1149,11 @@ symtab_node::verify_base (void)\n       error (\"node is transparent_alias but not an alias\");\n       error_found = true;\n     }\n+  if (symver && !alias)\n+    {\n+      error (\"node is symver but not alias\");\n+      error_found = true;\n+    }\n   if (same_comdat_group)\n     {\n       symtab_node *n = same_comdat_group;\n@@ -1782,7 +1789,9 @@ symtab_node::resolve_alias (symtab_node *target, bool transparent)\n \t  if (target->get_comdat_group ())\n \t    alias_alias->add_to_same_comdat_group (target);\n \t}\n-      if (!alias_alias->transparent_alias || transparent)\n+      if ((!alias_alias->transparent_alias\n+\t   && !alias_alias->symver)\n+\t  || transparent)\n \t{\n \t  alias_alias->remove_all_references ();\n \t  alias_alias->create_reference (target, IPA_REF_ALIAS, NULL);"}, {"sha": "d9d02b3b2633d1178915b92d723f5a240457c392", "filename": "gcc/varasm.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "patch": "@@ -5960,6 +5960,23 @@ do_assemble_alias (tree decl, tree target)\n #endif\n }\n \n+/* Output .symver directive.  */\n+\n+void\n+do_assemble_symver (tree decl, tree target)\n+{\n+  tree id = DECL_ASSEMBLER_NAME (decl);\n+  ultimate_transparent_alias_target (&id);\n+  ultimate_transparent_alias_target (&target);\n+#ifdef ASM_OUTPUT_SYMVER_DIRECTIVE\n+  ASM_OUTPUT_SYMVER_DIRECTIVE (asm_out_file,\n+\t\t\t       IDENTIFIER_POINTER (target),\n+\t\t\t       IDENTIFIER_POINTER (id));\n+#else\n+  error (\"symver is only supported on ELF platforms\");\n+#endif\n+}\n+\n /* Emit an assembler directive to make the symbol for DECL an alias to\n    the symbol for TARGET.  */\n "}, {"sha": "1a30ae49d548ea4175cb2c14709d18aea99a79aa", "filename": "gcc/varpool.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7ddfbcb7fa6e700639c9b916bf8a5ed15600950/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=d7ddfbcb7fa6e700639c9b916bf8a5ed15600950", "patch": "@@ -540,7 +540,10 @@ varpool_node::assemble_aliases (void)\n   FOR_EACH_ALIAS (this, ref)\n     {\n       varpool_node *alias = dyn_cast <varpool_node *> (ref->referring);\n-      if (!alias->transparent_alias)\n+      if (alias->symver)\n+\tdo_assemble_symver (alias->decl,\n+\t\t\t    DECL_ASSEMBLER_NAME (decl));\n+      else if (!alias->transparent_alias)\n \tdo_assemble_alias (alias->decl,\n \t\t\t   DECL_ASSEMBLER_NAME (decl));\n       alias->assemble_aliases ();"}]}