{"sha": "b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI1YjllOGZkMjM4MTZmNTA3NTRkNWJmYTgzNjRkMmYzZjRjYTRhNQ==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2011-03-24T13:03:06Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2011-03-24T13:03:06Z"}, "message": "system.h (FUNCTION_ARG, [...]): Poison.\n\n\t* system.h (FUNCTION_ARG, FUNCTION_INCOMING_ARG): Poison.\n\t(FUNCTION_ARG_ADVANCE): Likewise.\n\t* tm.texi.in: Change references to them to hook references.\n\t* tm.texi: Regenerate.\n\t* targhooks.c (default_function_arg): Eliminate check for target\n\tmacro.\n\t(default_function_incoming_arg): Likewise.\n\t(default_function_arg_advance): Likewise.\n\t* target.def (function_arg, function_incoming_arg): Change to\n\tDEFHOOK.\n\t(function_arg_advance): Likewise.\n\t* target-def.h: Eliminate FUNCTION_INCOMING_ARG check.\n\nFrom-SVN: r171389", "tree": {"sha": "942037d3317717fc15b2e64c5ef5978fabb9e1f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/942037d3317717fc15b2e64c5ef5978fabb9e1f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5/comments", "author": null, "committer": null, "parents": [{"sha": "190b2187b62863306378ea0940a6ddd2eb3629d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/190b2187b62863306378ea0940a6ddd2eb3629d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/190b2187b62863306378ea0940a6ddd2eb3629d5"}], "stats": {"total": 237, "additions": 117, "deletions": 120}, "files": [{"sha": "e67aacafd80cc0225ff5ee6c15cc260cbe916a84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5", "patch": "@@ -1,3 +1,18 @@\n+2011-03-24  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* system.h (FUNCTION_ARG, FUNCTION_INCOMING_ARG): Poison.\n+\t(FUNCTION_ARG_ADVANCE): Likewise.\n+\t* tm.texi.in: Change references to them to hook references.\n+\t* tm.texi: Regenerate.\n+\t* targhooks.c (default_function_arg): Eliminate check for target\n+\tmacro.\n+\t(default_function_incoming_arg): Likewise.\n+\t(default_function_arg_advance): Likewise.\n+\t* target.def (function_arg, function_incoming_arg): Change to\n+\tDEFHOOK.\n+\t(function_arg_advance): Likewise.\n+\t* target-def.h: Eliminate FUNCTION_INCOMING_ARG check.\n+\n 2011-03-24  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/48269"}, {"sha": "bdd1dd3848ff79c5ca2d9bb0b740d2ddcfdf9308", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5", "patch": "@@ -3980,25 +3980,22 @@ This section describes the macros which let you control how various\n types of arguments are passed in registers or how they are arranged in\n the stack.\n \n-@defmac FUNCTION_ARG (@var{cum}, @var{mode}, @var{type}, @var{named})\n-A C expression that controls whether a function argument is passed\n-in a register, and which register.\n+@deftypefn {Target Hook} rtx TARGET_FUNCTION_ARG (CUMULATIVE_ARGS *@var{ca}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n+Return an RTX indicating whether a function argument is passed in a\n+register and if so, which register.\n \n-The arguments are @var{cum}, which summarizes all the previous\n+The arguments are @var{ca}, which summarizes all the previous\n arguments; @var{mode}, the machine mode of the argument; @var{type},\n the data type of the argument as a tree node or 0 if that is not known\n (which happens for C support library functions); and @var{named},\n-which is 1 for an ordinary argument and 0 for nameless arguments that\n-correspond to @samp{@dots{}} in the called function's prototype.\n-@var{type} can be an incomplete type if a syntax error has previously\n-occurred.\n+which is @code{true} for an ordinary argument and @code{false} for\n+nameless arguments that correspond to @samp{@dots{}} in the called\n+function's prototype.  @var{type} can be an incomplete type if a\n+syntax error has previously occurred.\n \n-The value of the expression is usually either a @code{reg} RTX for the\n-hard register in which to pass the argument, or zero to pass the\n-argument on the stack.\n-\n-For machines like the VAX and 68000, where normally all arguments are\n-pushed, zero suffices as a definition.\n+The return value is usually either a @code{reg} RTX for the hard\n+register in which to pass the argument, or zero to pass the argument\n+on the stack.\n \n The value of the expression can also be a @code{parallel} RTX@.  This is\n used when an argument is passed in multiple locations.  The mode of the\n@@ -4014,26 +4011,27 @@ As a special exception the first @code{expr_list} in the @code{parallel}\n RTX may have a first operand of zero.  This indicates that the entire\n argument is also stored on the stack.\n \n-The last time this macro is called, it is called with @code{MODE ==\n+The last time this hook is called, it is called with @code{MODE ==\n VOIDmode}, and its result is passed to the @code{call} or @code{call_value}\n pattern as operands 2 and 3 respectively.\n \n @cindex @file{stdarg.h} and register arguments\n-The usual way to make the ISO library @file{stdarg.h} work on a machine\n-where some arguments are usually passed in registers, is to cause\n-nameless arguments to be passed on the stack instead.  This is done\n-by making @code{FUNCTION_ARG} return 0 whenever @var{named} is 0.\n-\n-@cindex @code{TARGET_MUST_PASS_IN_STACK}, and @code{FUNCTION_ARG}\n-@cindex @code{REG_PARM_STACK_SPACE}, and @code{FUNCTION_ARG}\n+The usual way to make the ISO library @file{stdarg.h} work on a\n+machine where some arguments are usually passed in registers, is to\n+cause nameless arguments to be passed on the stack instead.  This is\n+done by making @code{TARGET_FUNCTION_ARG} return 0 whenever\n+@var{named} is @code{false}.\n+\n+@cindex @code{TARGET_MUST_PASS_IN_STACK}, and @code{TARGET_FUNCTION_ARG}\n+@cindex @code{REG_PARM_STACK_SPACE}, and @code{TARGET_FUNCTION_ARG}\n You may use the hook @code{targetm.calls.must_pass_in_stack}\n in the definition of this macro to determine if this argument is of a\n type that must be passed in the stack.  If @code{REG_PARM_STACK_SPACE}\n-is not defined and @code{FUNCTION_ARG} returns nonzero for such an\n+is not defined and @code{TARGET_FUNCTION_ARG} returns nonzero for such an\n argument, the compiler will abort.  If @code{REG_PARM_STACK_SPACE} is\n defined, the argument will be computed in the stack and then loaded into\n a register.\n-@end defmac\n+@end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_MUST_PASS_IN_STACK (enum machine_mode @var{mode}, const_tree @var{type})\n This target hook should return @code{true} if we should not pass @var{type}\n@@ -4042,20 +4040,21 @@ definition that is usually appropriate, refer to @file{expr.h} for additional\n documentation.\n @end deftypefn\n \n-@defmac FUNCTION_INCOMING_ARG (@var{cum}, @var{mode}, @var{type}, @var{named})\n-Define this macro if the target machine has ``register windows'', so\n+@deftypefn {Target Hook} rtx TARGET_FUNCTION_INCOMING_ARG (CUMULATIVE_ARGS *@var{ca}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n+Define this hook if the target machine has ``register windows'', so\n that the register in which a function sees an arguments is not\n necessarily the same as the one in which the caller passed the\n argument.\n \n-For such machines, @code{FUNCTION_ARG} computes the register in which\n-the caller passes the value, and @code{FUNCTION_INCOMING_ARG} should\n-be defined in a similar fashion to tell the function being called\n-where the arguments will arrive.\n+For such machines, @code{TARGET_FUNCTION_ARG} computes the register in\n+which the caller passes the value, and\n+@code{TARGET_FUNCTION_INCOMING_ARG} should be defined in a similar\n+fashion to tell the function being called where the arguments will\n+arrive.\n \n-If @code{FUNCTION_INCOMING_ARG} is not defined, @code{FUNCTION_ARG}\n-serves both purposes.\n-@end defmac\n+If @code{TARGET_FUNCTION_INCOMING_ARG} is not defined,\n+@code{TARGET_FUNCTION_ARG} serves both purposes.\n+@end deftypefn\n \n @deftypefn {Target Hook} int TARGET_ARG_PARTIAL_BYTES (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, tree @var{type}, bool @var{named})\n This target hook returns the number of bytes at the beginning of an\n@@ -4071,9 +4070,9 @@ structure) crosses that boundary, its first few words must be passed\n in registers and the rest must be pushed.  This macro tells the\n compiler when this occurs, and how many bytes should go in registers.\n \n-@code{FUNCTION_ARG} for these arguments should return the first\n+@code{TARGET_FUNCTION_ARG} for these arguments should return the first\n register to be used by the caller for this argument; likewise\n-@code{FUNCTION_INCOMING_ARG}, for the called function.\n+@code{TARGET_FUNCTION_INCOMING_ARG}, for the called function.\n @end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_PASS_BY_REFERENCE (CUMULATIVE_ARGS *@var{cum}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n@@ -4102,10 +4101,10 @@ The default version of this hook always returns false.\n @end deftypefn\n \n @defmac CUMULATIVE_ARGS\n-A C type for declaring a variable that is used as the first argument of\n-@code{FUNCTION_ARG} and other related values.  For some target machines,\n-the type @code{int} suffices and can hold the number of bytes of\n-argument so far.\n+A C type for declaring a variable that is used as the first argument\n+of @code{TARGET_FUNCTION_ARG} and other related values.  For some\n+target machines, the type @code{int} suffices and can hold the number\n+of bytes of argument so far.\n \n There is no need to record in @code{CUMULATIVE_ARGS} anything about the\n arguments that have been passed on the stack.  The compiler has other\n@@ -4167,17 +4166,17 @@ argument @var{libname} exists for symmetry with\n @c --mew 5feb93   i switched the order of the sentences.  --mew 10feb93\n @end defmac\n \n-@defmac FUNCTION_ARG_ADVANCE (@var{cum}, @var{mode}, @var{type}, @var{named})\n-A C statement (sans semicolon) to update the summarizer variable\n-@var{cum} to advance past an argument in the argument list.  The\n-values @var{mode}, @var{type} and @var{named} describe that argument.\n-Once this is done, the variable @var{cum} is suitable for analyzing\n-the @emph{following} argument with @code{FUNCTION_ARG}, etc.\n+@deftypefn {Target Hook} void TARGET_FUNCTION_ARG_ADVANCE (CUMULATIVE_ARGS *@var{ca}, enum machine_mode @var{mode}, const_tree @var{type}, bool @var{named})\n+This hook updates the summarizer variable pointed to by @var{ca} to\n+advance past an argument in the argument list.  The values @var{mode},\n+@var{type} and @var{named} describe that argument.  Once this is done,\n+the variable @var{cum} is suitable for analyzing the @emph{following}\n+argument with @code{TARGET_FUNCTION_ARG}, etc.\n \n-This macro need not do anything if the argument in question was passed\n+This hook need not do anything if the argument in question was passed\n on the stack.  The compiler knows how to track the amount of stack space\n used for arguments without any special help.\n-@end defmac\n+@end deftypefn\n \n @defmac FUNCTION_ARG_OFFSET (@var{mode}, @var{type})\n If defined, a C expression that is the number of bytes to add to the\n@@ -4377,7 +4376,7 @@ On many machines, only @code{TYPE_MODE (@var{ret_type})} is relevant.\n place regardless of mode.)  The value of the expression is usually a\n @code{reg} RTX for the hard register where the return value is stored.\n The value can also be a @code{parallel} RTX, if the return value is in\n-multiple places.  See @code{FUNCTION_ARG} for an explanation of the\n+multiple places.  See @code{TARGET_FUNCTION_ARG} for an explanation of the\n @code{parallel} form.   Note that the callee will populate every\n location specified in the @code{parallel}, but if the first element of\n the @code{parallel} contains the whole return value, callers will use\n@@ -5068,7 +5067,7 @@ not generate any instructions in this case.\n Define this hook to return @code{true} if the location where a function\n argument is passed depends on whether or not it is a named argument.\n \n-This hook controls how the @var{named} argument to @code{FUNCTION_ARG}\n+This hook controls how the @var{named} argument to @code{TARGET_FUNCTION_ARG}\n is set for varargs and stdarg functions.  If this hook returns\n @code{true}, the @var{named} argument is always true for named\n arguments, and false for unnamed arguments.  If it returns @code{false},"}, {"sha": "654773ef328c38d077e1eb26297de753e855e961", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5", "patch": "@@ -3968,25 +3968,22 @@ This section describes the macros which let you control how various\n types of arguments are passed in registers or how they are arranged in\n the stack.\n \n-@defmac FUNCTION_ARG (@var{cum}, @var{mode}, @var{type}, @var{named})\n-A C expression that controls whether a function argument is passed\n-in a register, and which register.\n+@hook TARGET_FUNCTION_ARG\n+Return an RTX indicating whether a function argument is passed in a\n+register and if so, which register.\n \n-The arguments are @var{cum}, which summarizes all the previous\n+The arguments are @var{ca}, which summarizes all the previous\n arguments; @var{mode}, the machine mode of the argument; @var{type},\n the data type of the argument as a tree node or 0 if that is not known\n (which happens for C support library functions); and @var{named},\n-which is 1 for an ordinary argument and 0 for nameless arguments that\n-correspond to @samp{@dots{}} in the called function's prototype.\n-@var{type} can be an incomplete type if a syntax error has previously\n-occurred.\n+which is @code{true} for an ordinary argument and @code{false} for\n+nameless arguments that correspond to @samp{@dots{}} in the called\n+function's prototype.  @var{type} can be an incomplete type if a\n+syntax error has previously occurred.\n \n-The value of the expression is usually either a @code{reg} RTX for the\n-hard register in which to pass the argument, or zero to pass the\n-argument on the stack.\n-\n-For machines like the VAX and 68000, where normally all arguments are\n-pushed, zero suffices as a definition.\n+The return value is usually either a @code{reg} RTX for the hard\n+register in which to pass the argument, or zero to pass the argument\n+on the stack.\n \n The value of the expression can also be a @code{parallel} RTX@.  This is\n used when an argument is passed in multiple locations.  The mode of the\n@@ -4002,26 +3999,27 @@ As a special exception the first @code{expr_list} in the @code{parallel}\n RTX may have a first operand of zero.  This indicates that the entire\n argument is also stored on the stack.\n \n-The last time this macro is called, it is called with @code{MODE ==\n+The last time this hook is called, it is called with @code{MODE ==\n VOIDmode}, and its result is passed to the @code{call} or @code{call_value}\n pattern as operands 2 and 3 respectively.\n \n @cindex @file{stdarg.h} and register arguments\n-The usual way to make the ISO library @file{stdarg.h} work on a machine\n-where some arguments are usually passed in registers, is to cause\n-nameless arguments to be passed on the stack instead.  This is done\n-by making @code{FUNCTION_ARG} return 0 whenever @var{named} is 0.\n-\n-@cindex @code{TARGET_MUST_PASS_IN_STACK}, and @code{FUNCTION_ARG}\n-@cindex @code{REG_PARM_STACK_SPACE}, and @code{FUNCTION_ARG}\n+The usual way to make the ISO library @file{stdarg.h} work on a\n+machine where some arguments are usually passed in registers, is to\n+cause nameless arguments to be passed on the stack instead.  This is\n+done by making @code{TARGET_FUNCTION_ARG} return 0 whenever\n+@var{named} is @code{false}.\n+\n+@cindex @code{TARGET_MUST_PASS_IN_STACK}, and @code{TARGET_FUNCTION_ARG}\n+@cindex @code{REG_PARM_STACK_SPACE}, and @code{TARGET_FUNCTION_ARG}\n You may use the hook @code{targetm.calls.must_pass_in_stack}\n in the definition of this macro to determine if this argument is of a\n type that must be passed in the stack.  If @code{REG_PARM_STACK_SPACE}\n-is not defined and @code{FUNCTION_ARG} returns nonzero for such an\n+is not defined and @code{TARGET_FUNCTION_ARG} returns nonzero for such an\n argument, the compiler will abort.  If @code{REG_PARM_STACK_SPACE} is\n defined, the argument will be computed in the stack and then loaded into\n a register.\n-@end defmac\n+@end deftypefn\n \n @hook TARGET_MUST_PASS_IN_STACK\n This target hook should return @code{true} if we should not pass @var{type}\n@@ -4030,20 +4028,21 @@ definition that is usually appropriate, refer to @file{expr.h} for additional\n documentation.\n @end deftypefn\n \n-@defmac FUNCTION_INCOMING_ARG (@var{cum}, @var{mode}, @var{type}, @var{named})\n-Define this macro if the target machine has ``register windows'', so\n+@hook TARGET_FUNCTION_INCOMING_ARG\n+Define this hook if the target machine has ``register windows'', so\n that the register in which a function sees an arguments is not\n necessarily the same as the one in which the caller passed the\n argument.\n \n-For such machines, @code{FUNCTION_ARG} computes the register in which\n-the caller passes the value, and @code{FUNCTION_INCOMING_ARG} should\n-be defined in a similar fashion to tell the function being called\n-where the arguments will arrive.\n+For such machines, @code{TARGET_FUNCTION_ARG} computes the register in\n+which the caller passes the value, and\n+@code{TARGET_FUNCTION_INCOMING_ARG} should be defined in a similar\n+fashion to tell the function being called where the arguments will\n+arrive.\n \n-If @code{FUNCTION_INCOMING_ARG} is not defined, @code{FUNCTION_ARG}\n-serves both purposes.\n-@end defmac\n+If @code{TARGET_FUNCTION_INCOMING_ARG} is not defined,\n+@code{TARGET_FUNCTION_ARG} serves both purposes.\n+@end deftypefn\n \n @hook TARGET_ARG_PARTIAL_BYTES\n This target hook returns the number of bytes at the beginning of an\n@@ -4059,9 +4058,9 @@ structure) crosses that boundary, its first few words must be passed\n in registers and the rest must be pushed.  This macro tells the\n compiler when this occurs, and how many bytes should go in registers.\n \n-@code{FUNCTION_ARG} for these arguments should return the first\n+@code{TARGET_FUNCTION_ARG} for these arguments should return the first\n register to be used by the caller for this argument; likewise\n-@code{FUNCTION_INCOMING_ARG}, for the called function.\n+@code{TARGET_FUNCTION_INCOMING_ARG}, for the called function.\n @end deftypefn\n \n @hook TARGET_PASS_BY_REFERENCE\n@@ -4090,10 +4089,10 @@ The default version of this hook always returns false.\n @end deftypefn\n \n @defmac CUMULATIVE_ARGS\n-A C type for declaring a variable that is used as the first argument of\n-@code{FUNCTION_ARG} and other related values.  For some target machines,\n-the type @code{int} suffices and can hold the number of bytes of\n-argument so far.\n+A C type for declaring a variable that is used as the first argument\n+of @code{TARGET_FUNCTION_ARG} and other related values.  For some\n+target machines, the type @code{int} suffices and can hold the number\n+of bytes of argument so far.\n \n There is no need to record in @code{CUMULATIVE_ARGS} anything about the\n arguments that have been passed on the stack.  The compiler has other\n@@ -4155,17 +4154,17 @@ argument @var{libname} exists for symmetry with\n @c --mew 5feb93   i switched the order of the sentences.  --mew 10feb93\n @end defmac\n \n-@defmac FUNCTION_ARG_ADVANCE (@var{cum}, @var{mode}, @var{type}, @var{named})\n-A C statement (sans semicolon) to update the summarizer variable\n-@var{cum} to advance past an argument in the argument list.  The\n-values @var{mode}, @var{type} and @var{named} describe that argument.\n-Once this is done, the variable @var{cum} is suitable for analyzing\n-the @emph{following} argument with @code{FUNCTION_ARG}, etc.\n+@hook TARGET_FUNCTION_ARG_ADVANCE\n+This hook updates the summarizer variable pointed to by @var{ca} to\n+advance past an argument in the argument list.  The values @var{mode},\n+@var{type} and @var{named} describe that argument.  Once this is done,\n+the variable @var{cum} is suitable for analyzing the @emph{following}\n+argument with @code{TARGET_FUNCTION_ARG}, etc.\n \n-This macro need not do anything if the argument in question was passed\n+This hook need not do anything if the argument in question was passed\n on the stack.  The compiler knows how to track the amount of stack space\n used for arguments without any special help.\n-@end defmac\n+@end deftypefn\n \n @defmac FUNCTION_ARG_OFFSET (@var{mode}, @var{type})\n If defined, a C expression that is the number of bytes to add to the\n@@ -4361,7 +4360,7 @@ On many machines, only @code{TYPE_MODE (@var{ret_type})} is relevant.\n place regardless of mode.)  The value of the expression is usually a\n @code{reg} RTX for the hard register where the return value is stored.\n The value can also be a @code{parallel} RTX, if the return value is in\n-multiple places.  See @code{FUNCTION_ARG} for an explanation of the\n+multiple places.  See @code{TARGET_FUNCTION_ARG} for an explanation of the\n @code{parallel} form.   Note that the callee will populate every\n location specified in the @code{parallel}, but if the first element of\n the @code{parallel} contains the whole return value, callers will use\n@@ -5046,7 +5045,7 @@ not generate any instructions in this case.\n Define this hook to return @code{true} if the location where a function\n argument is passed depends on whether or not it is a named argument.\n \n-This hook controls how the @var{named} argument to @code{FUNCTION_ARG}\n+This hook controls how the @var{named} argument to @code{TARGET_FUNCTION_ARG}\n is set for varargs and stdarg functions.  If this hook returns\n @code{true}, the @var{named} argument is always true for named\n arguments, and false for unnamed arguments.  If it returns @code{false},"}, {"sha": "630b4283b31ae48a2bce0d9438e6a291162a3574", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5", "patch": "@@ -828,7 +828,8 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tTARGET_OPTION_TRANSLATE_TABLE HANDLE_PRAGMA_PACK_PUSH_POP\t   \\\n \tHANDLE_SYSV_PRAGMA HANDLE_PRAGMA_WEAK CONDITIONAL_REGISTER_USAGE   \\\n \tFUNCTION_ARG_BOUNDARY MUST_USE_SJLJ_EXCEPTIONS US_SOFTWARE_GOFAST  \\\n-\tUSING_SVR4_H SVR4_ASM_SPEC\n+\tUSING_SVR4_H SVR4_ASM_SPEC FUNCTION_ARG FUNCTION_ARG_ADVANCE\t   \\\n+\tFUNCTION_INCOMING_ARG\n \n /* Hooks that are no longer used.  */\n  #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE\t\\"}, {"sha": "123173505405b2c2c451ae5136424f881db8bee0", "filename": "gcc/target-def.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5", "patch": "@@ -108,7 +108,7 @@\n #define TARGET_IRA_COVER_CLASSES 0\n #endif\n \n-#if !defined (TARGET_FUNCTION_INCOMING_ARG) && !defined (FUNCTION_INCOMING_ARG)\n+#if !defined (TARGET_FUNCTION_INCOMING_ARG)\n #define TARGET_FUNCTION_INCOMING_ARG TARGET_FUNCTION_ARG\n #endif\n "}, {"sha": "584bb7df52eae8f7634e3cdea5edb05dddf6a84a", "filename": "gcc/target.def", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5", "patch": "@@ -2018,8 +2018,7 @@ DEFHOOK\n /* Update the state in CA to advance past an argument in the\n    argument list.  The values MODE, TYPE, and NAMED describe that\n    argument.  */\n-/* ??? tm.texi still only describes the old macro.  */\n-DEFHOOK_UNDOC\n+DEFHOOK\n (function_arg_advance,\n  \"\",\n  void,\n@@ -2030,8 +2029,7 @@ DEFHOOK_UNDOC\n    be placed on a stack, or a hard register in which to store the\n    argument.  The values MODE, TYPE, and NAMED describe that\n    argument.  */\n-/* ??? tm.texi still only describes the old macro.  */\n-DEFHOOK_UNDOC\n+DEFHOOK\n (function_arg,\n  \"\",\n  rtx, (CUMULATIVE_ARGS *ca, enum machine_mode mode, const_tree type,\n@@ -2040,8 +2038,7 @@ DEFHOOK_UNDOC\n \n /* Likewise, but for machines with register windows.  Return the\n    location where the argument will appear to the callee.  */\n-/* ??? tm.texi still only describes the old macro.  */\n-DEFHOOK_UNDOC\n+DEFHOOK\n (function_incoming_arg,\n  \"\",\n  rtx, (CUMULATIVE_ARGS *ca, enum machine_mode mode, const_tree type,"}, {"sha": "f36a15e540ea9b9ab5ad999f557cd80771548824", "filename": "gcc/targhooks.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=b25b9e8fd23816f50754d5bfa8364d2f3f4ca4a5", "patch": "@@ -586,13 +586,7 @@ default_function_arg_advance (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n \t\t\t      const_tree type ATTRIBUTE_UNUSED,\n \t\t\t      bool named ATTRIBUTE_UNUSED)\n {\n-#ifdef FUNCTION_ARG_ADVANCE\n-  CUMULATIVE_ARGS args = *ca;\n-  FUNCTION_ARG_ADVANCE (args, mode, CONST_CAST_TREE (type), named);\n-  *ca = args;\n-#else\n   gcc_unreachable ();\n-#endif\n }\n \n rtx\n@@ -601,11 +595,7 @@ default_function_arg (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n \t\t      const_tree type ATTRIBUTE_UNUSED,\n \t\t      bool named ATTRIBUTE_UNUSED)\n {\n-#ifdef FUNCTION_ARG\n-  return FUNCTION_ARG (*ca, mode, CONST_CAST_TREE (type), named);\n-#else\n   gcc_unreachable ();\n-#endif\n }\n \n rtx\n@@ -614,11 +604,7 @@ default_function_incoming_arg (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n \t\t\t       const_tree type ATTRIBUTE_UNUSED,\n \t\t\t       bool named ATTRIBUTE_UNUSED)\n {\n-#ifdef FUNCTION_INCOMING_ARG\n-  return FUNCTION_INCOMING_ARG (*ca, mode, CONST_CAST_TREE (type), named);\n-#else\n   gcc_unreachable ();\n-#endif\n }\n \n unsigned int"}]}