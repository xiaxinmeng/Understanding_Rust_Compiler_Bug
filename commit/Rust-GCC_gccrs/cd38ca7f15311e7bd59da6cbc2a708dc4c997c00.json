{"sha": "cd38ca7f15311e7bd59da6cbc2a708dc4c997c00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QzOGNhN2YxNTMxMWU3YmQ1OWRhNmNiYzJhNzA4ZGM0Yzk5N2MwMA==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2007-04-17T07:31:45Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-04-17T07:31:45Z"}, "message": "tree-vectorizer.h (stmt_vec_info_type): Add enum value induc_vec_info_type.\n\n        * tree-vectorizer.h (stmt_vec_info_type): Add enum value\n        induc_vec_info_type.\n        (vectorizable_induction): New function declaration.\n        * tree-vect-transform.c (get_initial_def_for_induction): No need to\n        check if already vectorized.  Find first place in BB where new stmts\n        can be inserted.  Takes only one argument.\n        (vectorizable_induction): New function.\n        (vect_transform_stmt): Add case for induc_vec_info_type to call\n        vectorizable_induction.\n        (vect_transform_loop): Consider phis for vectorization.\n        * tree-vect-analyze.c (vect_determine_vectorization_factor): Simplify\n        condition.\n        (analyze_operations): Call vectorizable_induction when analyzing phis.\n        Fix comment.\n        (vect_mark_stmts_to_be_vectorized): Remove redundant checks.\n        (vect_mark_relevant): Include phis in relevance analysis.\n        (vect_mark_stmts_to_be_vectorize): Likewise.\n        * tree-vect-patterns.c (widened_name_p): Remove obsolete asserts.\n\nFrom-SVN: r123910", "tree": {"sha": "beb8051e46aefde6d663dc7d1c41b4fff622187c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/beb8051e46aefde6d663dc7d1c41b4fff622187c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00/comments", "author": null, "committer": null, "parents": [{"sha": "39ef65923c5943c0f04193463dee8eb46d249f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ef65923c5943c0f04193463dee8eb46d249f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ef65923c5943c0f04193463dee8eb46d249f12"}], "stats": {"total": 245, "additions": 184, "deletions": 61}, "files": [{"sha": "d065322a2b71ece891a5510a12d1a0254ec74c84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd38ca7f15311e7bd59da6cbc2a708dc4c997c00", "patch": "@@ -1,3 +1,24 @@\n+2007-04-17  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree-vectorizer.h (stmt_vec_info_type): Add enum value\n+\tinduc_vec_info_type.\n+\t(vectorizable_induction): New function declaration.\n+\t* tree-vect-transform.c (get_initial_def_for_induction): No need to\n+\tcheck if already vectorized.  Find first place in BB where new stmts\n+\tcan be inserted.  Takes only one argument.\n+\t(vectorizable_induction): New function.\n+\t(vect_transform_stmt): Add case for induc_vec_info_type to call\n+\tvectorizable_induction.\n+\t(vect_transform_loop): Consider phis for vectorization.\n+\t* tree-vect-analyze.c (vect_determine_vectorization_factor): Simplify\n+\tcondition.\n+\t(analyze_operations): Call vectorizable_induction when analyzing phis.  \n+\tFix comment.\n+\t(vect_mark_stmts_to_be_vectorized): Remove redundant checks.\n+\t(vect_mark_relevant): Include phis in relevance analysis.\n+\t(vect_mark_stmts_to_be_vectorize): Likewise.\n+\t* tree-vect-patterns.c (widened_name_p): Remove obsolete asserts.\n+\n 2007-04-16  Lawrence Crowl  <crowl@google.com>\n \n \t* doc/invoke.texi (Debugging Options): Add documentation for the"}, {"sha": "c3d96c31fdf3ccd18546cd9b73d6ceb02efceba4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cd38ca7f15311e7bd59da6cbc2a708dc4c997c00", "patch": "@@ -1,3 +1,7 @@\n+2007-04-17  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* gcc.dg/vect/no-tree-scev-cprop-vect-iv-3.c: New test.\n+\n 2007-04-16  Lawrence Crowl  <crowl@google.com>\n \n \t* g++.dg/other/fesd-any.C: Test -femit-struct-debug-detailed=any."}, {"sha": "cdfaa6ff4935aa0827fd2a2eec90d102b9dc46ae", "filename": "gcc/testsuite/gcc.dg/vect/no-tree-scev-cprop-vect-iv-3.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-tree-scev-cprop-vect-iv-3.c?ref=cd38ca7f15311e7bd59da6cbc2a708dc4c997c00", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 26\n+ \n+unsigned int main1 ()\n+{  \n+  unsigned short i;\n+  unsigned int intsum = 0;\n+\n+  /* vectorization of reduction with induction, and widenning sum: \n+     sum shorts into int. \n+     Need -fno-tree-scev-cprop or else the loop is eliminated.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      intsum += i;\n+    } \n+\n+  return intsum;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_widen_sum_hi_to_si } } } */\n+/* { dg-final { scan-tree-dump-times \"vect_recog_widen_sum_pattern: detected\" 1 \"vect\" { target vect_widen_sum_hi_to_si } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "c707a025c011dcb36f3d0eb6b5694025f85c6e6e", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=cd38ca7f15311e7bd59da6cbc2a708dc4c997c00", "patch": "@@ -122,13 +122,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n \t  gcc_assert (stmt_info);\n \n-\t  /* Two cases of \"relevant\" phis: those that define an \n-\t     induction that is used in the loop, and those that\n-\t     define a reduction.  */\n-\t  if ((STMT_VINFO_RELEVANT (stmt_info) == vect_used_in_loop\n-\t       && STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def)\n-\t      || (STMT_VINFO_RELEVANT (stmt_info) == vect_used_by_reduction\n-\t\t  && STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def))\n+\t  if (STMT_VINFO_RELEVANT_P (stmt_info))\n             {\n \t      gcc_assert (!STMT_VINFO_VECTYPE (stmt_info));\n               scalar_type = TREE_TYPE (PHI_RESULT (phi));\n@@ -311,6 +305,8 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n         {\n+\t  ok = true;\n+\n \t  stmt_info = vinfo_for_stmt (phi);\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    {\n@@ -331,15 +327,29 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t  if (STMT_VINFO_RELEVANT (stmt_info) == vect_used_in_loop\n \t      && STMT_VINFO_DEF_TYPE (stmt_info) != vect_induction_def)\n \t    {\n-\t      /* Most likely a reduction-like computation that is used\n-\t\t in the loop.  */\n+\t      /* A scalar-dependence cycle that we don't support.  */\n \t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\t        fprintf (vect_dump, \"not vectorized: unsupported pattern.\");\n- \t     return false;\n+\t\tfprintf (vect_dump, \"not vectorized: scalar dependence cycle.\");\n+\t      return false;\n \t    }\n \n \t  if (STMT_VINFO_RELEVANT_P (stmt_info))\n-\t    need_to_vectorize = true;\n+\t    {\n+\t      need_to_vectorize = true;\n+\t      if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def)\n+\t\tok = vectorizable_induction (phi, NULL, NULL);\n+\t    }\n+\n+\t  if (!ok)\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+\t\t{\n+\t\t  fprintf (vect_dump,\n+\t\t\t   \"not vectorized: relevant phi not supported: \");\n+\t\t  print_generic_expr (vect_dump, phi, TDF_SLIM);\n+\t\t}\n+\t      return false;\n+\t    }\n \t}\n \n       for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n@@ -2106,11 +2116,6 @@ vect_mark_relevant (VEC(tree,heap) **worklist, tree stmt,\n   if (relevant > STMT_VINFO_RELEVANT (stmt_info))\n     STMT_VINFO_RELEVANT (stmt_info) = relevant;\n \n-  if (TREE_CODE (stmt) == PHI_NODE)\n-    /* Don't put phi-nodes in the worklist. Phis that are marked relevant\n-       or live will fail vectorization later on.  */\n-    return;\n-\n   if (STMT_VINFO_RELEVANT (stmt_info) == save_relevant\n       && STMT_VINFO_LIVE_P (stmt_info) == save_live_p)\n     {\n@@ -2228,27 +2233,23 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   worklist = VEC_alloc (tree, heap, 64);\n \n   /* 1. Init worklist.  */\n-\n-  bb = loop->header;\n-  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        {\n-          fprintf (vect_dump, \"init: phi relevant? \");\n-          print_generic_expr (vect_dump, phi, TDF_SLIM);\n-        }\n-\n-      if (vect_stmt_relevant_p (phi, loop_vinfo, &relevant, &live_p))\n-\tvect_mark_relevant (&worklist, phi, relevant, live_p);\n-    }\n-\n   for (i = 0; i < nbbs; i++)\n     {\n       bb = bbs[i];\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t{ \n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    {\n+\t      fprintf (vect_dump, \"init: phi relevant? \");\n+\t      print_generic_expr (vect_dump, phi, TDF_SLIM);\n+\t    }\n+\n+\t  if (vect_stmt_relevant_p (phi, loop_vinfo, &relevant, &live_p))\n+\t    vect_mark_relevant (&worklist, phi, relevant, live_p);\n+\t}\n       for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n \t{\n \t  stmt = bsi_stmt (si);\n-\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    {\n \t      fprintf (vect_dump, \"init: stmt relevant? \");\n@@ -2279,8 +2280,6 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n          relevance properties of STMT.\n        */\n \n-      gcc_assert (TREE_CODE (stmt) != PHI_NODE);\n-\n       ann = stmt_ann (stmt);\n       stmt_vinfo = vinfo_for_stmt (stmt);\n \n@@ -2318,7 +2317,6 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n       /* case 2.2:  */\n       if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def)\n \t{\n-\t  gcc_assert (relevant == vect_unused_in_loop && live_p);\n \t  relevant = vect_used_by_reduction;\n \t  live_p = false;\n \t}"}, {"sha": "5773344abc5eab5aed674fc7167b64e7b567fb61", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=cd38ca7f15311e7bd59da6cbc2a708dc4c997c00", "patch": "@@ -109,10 +109,6 @@ widened_name_p (tree name, tree use_stmt, tree *half_type, tree *def_stmt)\n   if (!vect_is_simple_use (oprnd0, loop_vinfo, &dummy, &dummy, &dt))\n     return false;\n \n-  if (dt != vect_invariant_def && dt != vect_constant_def\n-      && dt != vect_loop_def)\n-    return false;\n-\n   return true;\n }\n "}, {"sha": "a00ecdc3d6bd76c080967c1cc64e089205da746d", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 97, "deletions": 22, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=cd38ca7f15311e7bd59da6cbc2a708dc4c997c00", "patch": "@@ -514,7 +514,6 @@ vect_init_vector (tree stmt, tree vector_var, tree vector_type)\n /* Function get_initial_def_for_induction\n \n    Input:\n-   STMT - a stmt that performs an induction operation in the loop.\n    IV_PHI - the initial value of the induction variable\n \n    Output:\n@@ -524,9 +523,9 @@ vect_init_vector (tree stmt, tree vector_var, tree vector_type)\n    [X, X + S, X + 2*S, X + 3*S].  */\n \n static tree\n-get_initial_def_for_induction (tree stmt, tree iv_phi)\n+get_initial_def_for_induction (tree iv_phi)\n {\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (iv_phi);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree scalar_type = TREE_TYPE (iv_phi);\n@@ -549,27 +548,17 @@ get_initial_def_for_induction (tree stmt, tree iv_phi)\n   tree expr;\n   stmt_vec_info phi_info = vinfo_for_stmt (iv_phi);\n   tree stmts;\n+  tree stmt = NULL_TREE;\n+  block_stmt_iterator si;\n+  basic_block bb = bb_for_stmt (iv_phi);\n \n   gcc_assert (phi_info);\n+  gcc_assert (ncopies >= 1);\n \n-  if (STMT_VINFO_VEC_STMT (phi_info))\n-    {\n-      induction_phi = STMT_VINFO_VEC_STMT (phi_info);\n-      gcc_assert (TREE_CODE (induction_phi) == PHI_NODE);\n-\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\t{\n-\t  fprintf (vect_dump, \"induction already vectorized:\");\n-\t  print_generic_expr (vect_dump, iv_phi, TDF_SLIM);\n-\t  fprintf (vect_dump, \"\\n\");\n-\t  print_generic_expr (vect_dump, induction_phi, TDF_SLIM);\n-\t}\n-\n-      return PHI_RESULT (induction_phi);\n-    }\n+  /* Find the first insertion point in the BB.  */\n+  si = bsi_after_labels (bb);\n+  stmt = bsi_stmt (si);\n \n-  gcc_assert (ncopies >= 1);\n- \n   access_fn = analyze_scalar_evolution (loop, PHI_RESULT (iv_phi));\n   gcc_assert (access_fn);\n   ok = vect_is_simple_iv_evolution (loop->num, access_fn, &init_expr, &step_expr);\n@@ -833,7 +822,7 @@ vect_get_vec_def_for_operand (tree op, tree stmt, tree *scalar_def)\n \tgcc_assert (TREE_CODE (def_stmt) == PHI_NODE);\n \n \t/* Get the def before the loop  */\n-\treturn get_initial_def_for_induction (stmt, def_stmt);\n+\treturn get_initial_def_for_induction (def_stmt);\n       }\n \n     default:\n@@ -2233,6 +2222,59 @@ vect_min_worthwhile_factor (enum tree_code code)\n }\n \n \n+/* Function vectorizable_induction\n+\n+   Check if PHI performs an induction computation that can be vectorized.\n+   If VEC_STMT is also passed, vectorize the induction PHI: create a vectorized\n+   phi to replace it, put it in VEC_STMT, and add it to the same basic block.\n+   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+\n+bool\n+vectorizable_induction (tree phi, block_stmt_iterator *bsi ATTRIBUTE_UNUSED,\n+                        tree *vec_stmt)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (phi);\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+  tree vec_def;\n+\n+  gcc_assert (ncopies >= 1);\n+\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+    return false;\n+\n+  gcc_assert (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def);\n+\n+  if (STMT_VINFO_LIVE_P (stmt_info))\n+    {\n+      /* FORNOW: not yet supported.  */\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"value used after loop.\");\n+      return false;\n+    }\n+\n+  if (TREE_CODE (phi) != PHI_NODE)\n+    return false;\n+\n+  if (!vec_stmt) /* transformation not required.  */\n+    {\n+      STMT_VINFO_TYPE (stmt_info) = induc_vec_info_type;\n+      return true;\n+    }\n+\n+  /** Transform.  **/\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"transform induction phi.\");\n+\n+  vec_def = get_initial_def_for_induction (phi);\n+  *vec_stmt = SSA_NAME_DEF_STMT (vec_def);\n+  return true;\n+}\n+\n+\n /* Function vectorizable_operation.\n \n    Check if STMT performs a binary or unary operation that can be vectorized. \n@@ -4285,6 +4327,11 @@ vect_transform_stmt (tree stmt, block_stmt_iterator *bsi, bool *strided_store)\n       gcc_assert (done);\n       break;\n \n+    case induc_vec_info_type:\n+      done = vectorizable_induction (stmt, bsi, &vec_stmt);\n+      gcc_assert (done);\n+      break;\n+\n     case op_vec_info_type:\n       done = vectorizable_operation (stmt, bsi, &vec_stmt);\n       gcc_assert (done);\n@@ -5192,11 +5239,39 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   for (i = 0; i < nbbs; i++)\n     {\n       basic_block bb = bbs[i];\n+      stmt_vec_info stmt_info;\n+      tree phi;\n+\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+        {\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    {\n+\t      fprintf (vect_dump, \"------>vectorizing phi: \");\n+\t      print_generic_expr (vect_dump, phi, TDF_SLIM);\n+\t    }\n+\t  stmt_info = vinfo_for_stmt (phi);\n+\t  if (!stmt_info)\n+\t    continue;\n+\t  if (!STMT_VINFO_RELEVANT_P (stmt_info)\n+\t      && !STMT_VINFO_LIVE_P (stmt_info))\n+\t    continue;\n+\n+\t  if ((TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info))\n+\t        != (unsigned HOST_WIDE_INT) vectorization_factor)\n+\t      && vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"multiple-types.\");\n+\n+\t  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def)\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\tfprintf (vect_dump, \"transform phi.\");\n+\t      vect_transform_stmt (phi, NULL, NULL);\n+\t    }\n+\t}\n \n       for (si = bsi_start (bb); !bsi_end_p (si);)\n \t{\n \t  tree stmt = bsi_stmt (si);\n-\t  stmt_vec_info stmt_info;\n \t  bool is_store;\n \n \t  if (vect_print_dump_info (REPORT_DETAILS))"}, {"sha": "3d418a92304b806501523ece968399ad30462ee1", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd38ca7f15311e7bd59da6cbc2a708dc4c997c00/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=cd38ca7f15311e7bd59da6cbc2a708dc4c997c00", "patch": "@@ -167,6 +167,7 @@ enum stmt_vec_info_type {\n   assignment_vec_info_type,\n   condition_vec_info_type,\n   reduc_vec_info_type,\n+  induc_vec_info_type,\n   type_promotion_vec_info_type,\n   type_demotion_vec_info_type,\n   type_conversion_vec_info_type\n@@ -428,6 +429,7 @@ extern bool vectorizable_call (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_condition (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_live_operation (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_reduction (tree, block_stmt_iterator *, tree *);\n+extern bool vectorizable_induction (tree, block_stmt_iterator *, tree *);\n /* Driver for transformation stage.  */\n extern void vect_transform_loop (loop_vec_info);\n "}]}