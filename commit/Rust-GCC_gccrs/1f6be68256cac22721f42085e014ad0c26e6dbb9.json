{"sha": "1f6be68256cac22721f42085e014ad0c26e6dbb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY2YmU2ODI1NmNhYzIyNzIxZjQyMDg1ZTAxNGFkMGMyNmU2ZGJiOQ==", "commit": {"author": {"name": "Ilya Verbin", "email": "ilya.verbin@intel.com", "date": "2014-11-13T13:37:38Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-11-13T13:37:38Z"}, "message": "[PATCH 2/7] OpenMP 4.0 offloading infrastructure: LTO streaming.\n\ngcc/\n\t* cgraph.c: Include context.h.\n\t(cgraph_node::create): Set node->offloadable and g->have_offload if\n\tdecl have \"omp declare target\" attribute.\n\t* cgraph.h (symtab_node): Add need_lto_streaming and offloadable flags.\n\t* cgraphunit.c: Include lto-section-names.h.\n\t(ipa_passes): Call ipa_write_summaries if there is something to write to\n\tOFFLOAD_SECTION_NAME_PREFIX sections.\n\t(symbol_table::compile): Set flag_generate_lto if there is something to\n\toffload.\n\tReplace flag_lto with flag_generate_lto before lto_streamer_hooks_init.\n\t* context.c (gcc::context::context): Initialize have_offload with false.\n\t* context.h (class context): Add have_offload flag.\n\t* ipa-inline-analysis.c (inline_generate_summary): Do not exit under\n\tflag_generate_lto.\n\t(inline_free_summary): Always remove hooks.\n\t* lto-cgraph.c (referenced_from_other_partition_p): Ignore references\n\tfrom non-offloadable nodes while streaming a node into offload section.\n\t(reachable_from_other_partition_p): Likewise.\n\t(select_what_to_stream): New function.\n\t(compute_ltrans_boundary): Do not call\n\tlto_set_symtab_encoder_in_partition if the node should not be streamed.\n\t* lto-section-names.h (OFFLOAD_SECTION_NAME_PREFIX): Define.\n\t(section_name_prefix): Declare.\n\t* lto-streamer.c (section_name_prefix): New variable.\n\t(lto_get_section_name): Use section_name_prefix instead of\n\tLTO_SECTION_NAME_PREFIX.\n\t* lto-streamer.h (select_what_to_stream): Declare.\n\t* omp-low.c: Include context.h.\n\t(is_targetreg_ctx): New function.\n\t(scan_sharing_clauses): Use offloadable flag, instead of an attribute.\n\t(create_omp_child_function, check_omp_nesting_restrictions): Use new\n\tis_targetreg_ctx function.  Replace usage of \"omp declare target\"\n\tattribute with a cgraph_node flag offloadable.\n\t(expand_omp_target): Set mark_force_output for offloadable functions.\n\t(lower_omp_critical): Set offloadable flag for omp critical symbol.\n\t* passes.c (ipa_write_summaries): New argument offload_lto_mode.  Call\n\tselect_what_to_stream.  Do not call lto_set_symtab_encoder_in_partition\n\tif the node should not be streamed out.\n\t* tree-pass.h (ipa_write_summaries): New bool argument.\n\t* varpool.c: Include context.h.\n\t(varpool_node::get_create): Set node->offloadable and g->have_offload if\n\tdecl have \"omp declare target\" attribute.\n\ngcc/lto/\n\t* lto-object.c (lto_obj_add_section): Use section_name_prefix instead of\n\tLTO_SECTION_NAME_PREFIX.\n\t* lto-partition.c (lto_promote_cross_file_statics): Call\n\tselect_what_to_stream.\n\t* lto.c (lto_section_with_id): Use section_name_prefix instead of\n\tLTO_SECTION_NAME_PREFIX.\n\t(read_cgraph_and_symbols): Read OFFLOAD_SECTION_NAME_PREFIX sections, if\n\tbeing built as an offload compiler.\n\nCo-Authored-By: Andrey Turetskiy <andrey.turetskiy@intel.com>\nCo-Authored-By: Bernd Schmidt <bernds@codesourcery.com>\nCo-Authored-By: Michael Zolotukhin <michael.v.zolotukhin@intel.com>\n\nFrom-SVN: r217486", "tree": {"sha": "43f38178c7cf5aad2c04113110efd75a815996be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43f38178c7cf5aad2c04113110efd75a815996be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f6be68256cac22721f42085e014ad0c26e6dbb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6be68256cac22721f42085e014ad0c26e6dbb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f6be68256cac22721f42085e014ad0c26e6dbb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6be68256cac22721f42085e014ad0c26e6dbb9/comments", "author": null, "committer": null, "parents": [{"sha": "85c64bbee96e9a877a0138a509c42ad6feb4d189", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85c64bbee96e9a877a0138a509c42ad6feb4d189", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85c64bbee96e9a877a0138a509c42ad6feb4d189"}], "stats": {"total": 243, "additions": 205, "deletions": 38}, "files": [{"sha": "316a00a74b3f63f95517e0282e871bd44899905a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -1,3 +1,51 @@\n+2014-11-13  Ilya Verbin  <ilya.verbin@intel.com>\n+\t    Bernd Schmidt  <bernds@codesourcery.com>\n+\t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\t    Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n+\n+\t* cgraph.c: Include context.h.\n+\t(cgraph_node::create): Set node->offloadable and g->have_offload if\n+\tdecl have \"omp declare target\" attribute.\n+\t* cgraph.h (symtab_node): Add need_lto_streaming and offloadable flags.\n+\t* cgraphunit.c: Include lto-section-names.h.\n+\t(ipa_passes): Call ipa_write_summaries if there is something to write to\n+\tOFFLOAD_SECTION_NAME_PREFIX sections.\n+\t(symbol_table::compile): Set flag_generate_lto if there is something to\n+\toffload.\n+\tReplace flag_lto with flag_generate_lto before lto_streamer_hooks_init.\n+\t* context.c (gcc::context::context): Initialize have_offload with false.\n+\t* context.h (class context): Add have_offload flag.\n+\t* ipa-inline-analysis.c (inline_generate_summary): Do not exit under\n+\tflag_generate_lto.\n+\t(inline_free_summary): Always remove hooks.\n+\t* lto-cgraph.c (referenced_from_other_partition_p): Ignore references\n+\tfrom non-offloadable nodes while streaming a node into offload section.\n+\t(reachable_from_other_partition_p): Likewise.\n+\t(select_what_to_stream): New function.\n+\t(compute_ltrans_boundary): Do not call\n+\tlto_set_symtab_encoder_in_partition if the node should not be streamed.\n+\t* lto-section-names.h (OFFLOAD_SECTION_NAME_PREFIX): Define.\n+\t(section_name_prefix): Declare.\n+\t* lto-streamer.c (section_name_prefix): New variable.\n+\t(lto_get_section_name): Use section_name_prefix instead of\n+\tLTO_SECTION_NAME_PREFIX.\n+\t* lto-streamer.h (select_what_to_stream): Declare.\n+\t* omp-low.c: Include context.h.\n+\t(is_targetreg_ctx): New function.\n+\t(scan_sharing_clauses): Use offloadable flag, instead of an attribute.\n+\t(create_omp_child_function, check_omp_nesting_restrictions): Use new\n+\tis_targetreg_ctx function.  Replace usage of \"omp declare target\"\n+\tattribute with a cgraph_node flag offloadable.\n+\t(expand_omp_target): Set mark_force_output for offloadable functions.\n+\t(lower_omp_critical): Set offloadable flag for omp critical symbol.\n+\t* passes.c (ipa_write_summaries): New argument offload_lto_mode.  Call\n+\tselect_what_to_stream.  Do not call lto_set_symtab_encoder_in_partition\n+\tif the node should not be streamed out.\n+\t* tree-pass.h (ipa_write_summaries): New bool argument.\n+\t* varpool.c: Include context.h.\n+\t(varpool_node::get_create): Set node->offloadable and g->have_offload if\n+\tdecl have \"omp declare target\" attribute.\n+\n 2014-11-13  Bernd Schmidt  <bernds@codesourcery.com>\n \t    Thomas Schwinge  <thomas@codesourcery.com>\n \t    Ilya Verbin  <ilya.verbin@intel.com>"}, {"sha": "8dcccbf19c6e2f13ae28b9375da767a495908a7b", "filename": "gcc/cgraph.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -81,6 +81,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"profile.h\"\n #include \"params.h\"\n #include \"tree-chkp.h\"\n+#include \"context.h\"\n \n /* FIXME: Only for PROP_loops, but cgraph shouldn't have to know about this.  */\n #include \"tree-pass.h\"\n@@ -494,6 +495,14 @@ cgraph_node::create (tree decl)\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n \n   node->decl = decl;\n+\n+  if (flag_openmp\n+      && lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (decl)))\n+    {\n+      node->offloadable = 1;\n+      g->have_offload = true;\n+    }\n+\n   node->register_symbol ();\n \n   if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)"}, {"sha": "1395bc1b4d9d2d373f02b4d117042e1c04d09d3d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -450,6 +450,13 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Set when init priority is set.  */\n   unsigned in_init_priority_hash : 1;\n \n+  /* Set when symbol needs to be streamed into LTO bytecode for LTO, or in case\n+     of offloading, for separate compilation for a different target.  */\n+  unsigned need_lto_streaming : 1;\n+\n+  /* Set when symbol can be streamed into bytecode for offloading.  */\n+  unsigned offloadable : 1;\n+\n \n   /* Ordering of all symtab entries.  */\n   int order;"}, {"sha": "9f49ed05f6ec2a23fe157b781e342b1f82015fbb", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -224,6 +224,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"dbgcnt.h\"\n #include \"tree-chkp.h\"\n+#include \"lto-section-names.h\"\n \n /* Queue of cgraph nodes scheduled to be added into cgraph.  This is a\n    secondary queue used during optimization to accommodate passes that\n@@ -2079,7 +2080,18 @@ ipa_passes (void)\n     targetm.asm_out.lto_start ();\n \n   if (!in_lto_p)\n-    ipa_write_summaries ();\n+    {\n+      if (g->have_offload)\n+\t{\n+\t  section_name_prefix = OFFLOAD_SECTION_NAME_PREFIX;\n+\t  ipa_write_summaries (true);\n+\t}\n+      if (flag_lto)\n+\t{\n+\t  section_name_prefix = LTO_SECTION_NAME_PREFIX;\n+\t  ipa_write_summaries (false);\n+\t}\n+    }\n \n   if (flag_generate_lto)\n     targetm.asm_out.lto_end ();\n@@ -2163,8 +2175,12 @@ symbol_table::compile (void)\n     fprintf (stderr, \"Performing interprocedural optimizations\\n\");\n   state = IPA;\n \n+  /* Offloading requires LTO infrastructure.  */\n+  if (!in_lto_p && g->have_offload)\n+    flag_generate_lto = 1;\n+\n   /* If LTO is enabled, initialize the streamer hooks needed by GIMPLE.  */\n-  if (flag_lto)\n+  if (flag_generate_lto)\n     lto_streamer_hooks_init ();\n \n   /* Don't run the IPA passes if there was any error or sorry messages.  */"}, {"sha": "9279be40dd74a25e4eeb144d83aacda3b13b4519", "filename": "gcc/context.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fcontext.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fcontext.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcontext.c?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -30,6 +30,8 @@ gcc::context *g;\n \n gcc::context::context ()\n {\n+  have_offload = false;\n+\n   /* The pass manager's constructor uses the dump manager (to set up\n      dumps for the various passes), so the dump manager must be set up\n      before the pass manager.  */"}, {"sha": "689ae5ad1874b4e9d13e7b7b5f5451cbac979993", "filename": "gcc/context.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fcontext.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fcontext.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcontext.h?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -33,6 +33,9 @@ class context\n public:\n   context ();\n \n+  /* The flag shows if there are symbols to be streamed for offloading.  */\n+  bool have_offload;\n+\n   /* Pass-management.  */\n \n   pass_manager *get_passes () { gcc_assert (m_passes); return m_passes; }"}, {"sha": "0373b108699a2dd376d055e409b16651b53c94b6", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -4024,7 +4024,7 @@ inline_generate_summary (void)\n \n   /* When not optimizing, do not bother to analyze.  Inlining is still done\n      because edge redirection needs to happen there.  */\n-  if (!optimize && !flag_lto && !flag_wpa)\n+  if (!optimize && !flag_generate_lto && !flag_wpa)\n     return;\n \n   function_insertion_hook_holder =\n@@ -4339,11 +4339,6 @@ void\n inline_free_summary (void)\n {\n   struct cgraph_node *node;\n-  if (!inline_edge_summary_vec.exists ())\n-    return;\n-  FOR_EACH_DEFINED_FUNCTION (node)\n-    if (!node->alias)\n-      reset_inline_summary (node);\n   if (function_insertion_hook_holder)\n     symtab->remove_cgraph_insertion_hook (function_insertion_hook_holder);\n   function_insertion_hook_holder = NULL;\n@@ -4359,6 +4354,11 @@ inline_free_summary (void)\n   if (edge_duplication_hook_holder)\n     symtab->remove_edge_duplication_hook (edge_duplication_hook_holder);\n   edge_duplication_hook_holder = NULL;\n+  if (!inline_edge_summary_vec.exists ())\n+    return;\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    if (!node->alias)\n+      reset_inline_summary (node);\n   vec_free (inline_summary_vec);\n   inline_edge_summary_vec.release ();\n   if (edge_predicate_pool)"}, {"sha": "fc8410c1c3ebfdc56752a809e5308d9e0c0a3898", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -330,6 +330,11 @@ referenced_from_other_partition_p (symtab_node *node, lto_symtab_encoder_t encod\n \n   for (i = 0; node->iterate_referring (i, ref); i++)\n     {\n+      /* Ignore references from non-offloadable nodes while streaming NODE into\n+\t offload LTO section.  */\n+      if (!ref->referring->need_lto_streaming)\n+\tcontinue;\n+\n       if (ref->referring->in_other_partition\n           || !lto_symtab_encoder_in_partition_p (encoder, ref->referring))\n \treturn true;\n@@ -348,9 +353,16 @@ reachable_from_other_partition_p (struct cgraph_node *node, lto_symtab_encoder_t\n   if (node->global.inlined_to)\n     return false;\n   for (e = node->callers; e; e = e->next_caller)\n-    if (e->caller->in_other_partition\n-\t|| !lto_symtab_encoder_in_partition_p (encoder, e->caller))\n-      return true;\n+    {\n+      /* Ignore references from non-offloadable nodes while streaming NODE into\n+\t offload LTO section.  */\n+      if (!e->caller->need_lto_streaming)\n+\tcontinue;\n+\n+      if (e->caller->in_other_partition\n+\t  || !lto_symtab_encoder_in_partition_p (encoder, e->caller))\n+\treturn true;\n+    }\n   return false;\n }\n \n@@ -818,6 +830,16 @@ create_references (lto_symtab_encoder_t encoder, symtab_node *node)\n       lto_symtab_encoder_encode (encoder, ref->referred);\n }\n \n+/* Select what needs to be streamed out.  In regular lto mode stream everything.\n+   In offload lto mode stream only nodes marked as offloadable.  */\n+void\n+select_what_to_stream (bool offload_lto_mode)\n+{\n+  struct symtab_node *snode;\n+  FOR_EACH_SYMBOL (snode)\n+    snode->need_lto_streaming = !offload_lto_mode || snode->offloadable;\n+}\n+\n /* Find all symbols we want to stream into given partition and insert them\n    to encoders.\n \n@@ -844,6 +866,8 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n        !lsei_end_p (lsei); lsei_next_function_in_partition (&lsei))\n     {\n       struct cgraph_node *node = lsei_cgraph_node (lsei);\n+      if (!node->need_lto_streaming)\n+\tcontinue;\n       add_node_to (encoder, node, true);\n       lto_set_symtab_encoder_in_partition (encoder, node);\n       create_references (encoder, node);\n@@ -860,6 +884,8 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n     {\n       varpool_node *vnode = lsei_varpool_node (lsei);\n \n+      if (!vnode->need_lto_streaming)\n+\tcontinue;\n       lto_set_symtab_encoder_in_partition (encoder, vnode);\n       lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n       create_references (encoder, vnode);"}, {"sha": "f5dbed26bad5d52471b4e41ae87204478ffbdcd1", "filename": "gcc/lto-section-names.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto-section-names.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto-section-names.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-names.h?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -25,6 +25,11 @@ along with GCC; see the file COPYING3.  If not see\n    name for the functions and static_initializers.  For other types of\n    sections a '.' and the section type are appended.  */\n #define LTO_SECTION_NAME_PREFIX \".gnu.lto_\"\n+#define OFFLOAD_SECTION_NAME_PREFIX \".gnu.offload_lto_\"\n+\n+/* Can be either OFFLOAD_SECTION_NAME_PREFIX when we stream IR for offload\n+   compiler, or LTO_SECTION_NAME_PREFIX for LTO case.  */\n+extern const char *section_name_prefix;\n \n /* Segment name for LTO sections.  This is only used for Mach-O.  */\n "}, {"sha": "e8347dccd654de020c0a135a3ea5c94997519d92", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -60,6 +60,7 @@ struct lto_stats_d lto_stats;\n static bitmap_obstack lto_obstack;\n static bool lto_obstack_initialized;\n \n+const char *section_name_prefix = LTO_SECTION_NAME_PREFIX;\n \n /* Return a string representing LTO tag TAG.  */\n \n@@ -189,7 +190,7 @@ lto_get_section_name (int section_type, const char *name, struct lto_file_decl_d\n     sprintf (post, \".\" HOST_WIDE_INT_PRINT_HEX_PURE, f->id);\n   else\n     sprintf (post, \".\" HOST_WIDE_INT_PRINT_HEX_PURE, get_random_seed (false)); \n-  return concat (LTO_SECTION_NAME_PREFIX, sep, add, post, NULL);\n+  return concat (section_name_prefix, sep, add, post, NULL);\n }\n \n "}, {"sha": "cdbe507d7189e8a8a2fb4969d86a5134d5bb09a0", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -831,6 +831,7 @@ bool referenced_from_this_partition_p (symtab_node *,\n bool reachable_from_this_partition_p (struct cgraph_node *,\n \t\t\t\t      lto_symtab_encoder_t);\n lto_symtab_encoder_t compute_ltrans_boundary (lto_symtab_encoder_t encoder);\n+void select_what_to_stream (bool);\n \n \n /* In lto-symtab.c.  */"}, {"sha": "1b2f1fe1514ac78c8f8f438a6170ad2f0424225d", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -1,3 +1,17 @@\n+2014-11-13  Ilya Verbin  <ilya.verbin@intel.com>\n+\t    Bernd Schmidt  <bernds@codesourcery.com>\n+\t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\t    Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n+\n+\t* lto-object.c (lto_obj_add_section): Use section_name_prefix instead of\n+\tLTO_SECTION_NAME_PREFIX.\n+\t* lto-partition.c (lto_promote_cross_file_statics): Call\n+\tselect_what_to_stream.\n+\t* lto.c (lto_section_with_id): Use section_name_prefix instead of\n+\tLTO_SECTION_NAME_PREFIX.\n+\t(read_cgraph_and_symbols): Read OFFLOAD_SECTION_NAME_PREFIX sections, if\n+\tbeing built as an offload compiler.\n+\n 2014-10-29  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* lto-lang.c: Remove redundant enum from machine_mode."}, {"sha": "b4124f65b97c49ee3b3d12aef695ae4944c12ed7", "filename": "gcc/lto/lto-object.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto%2Flto-object.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto%2Flto-object.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-object.c?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -242,8 +242,7 @@ lto_obj_add_section (void *data, const char *name, off_t offset,\n   void **slot;\n   struct lto_section_list *list = loasd->list;\n \n-  if (strncmp (name, LTO_SECTION_NAME_PREFIX,\n-\t       strlen (LTO_SECTION_NAME_PREFIX)) != 0)\n+  if (strncmp (name, section_name_prefix, strlen (section_name_prefix)))\n     return 1;\n \n   new_name = xstrdup (name);"}, {"sha": "65f0582cf6b2df04bf0de204ff1b7cdc5700d0ab", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -952,6 +952,8 @@ lto_promote_cross_file_statics (void)\n \n   gcc_assert (flag_wpa);\n \n+  select_what_to_stream (false);\n+\n   /* First compute boundaries.  */\n   n_sets = ltrans_partitions.length ();\n   for (i = 0; i < n_sets; i++)"}, {"sha": "fbf4913875d103f3a81c0d996a933197fb0b7f69", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -2137,7 +2137,7 @@ lto_section_with_id (const char *name, unsigned HOST_WIDE_INT *id)\n {\n   const char *s;\n \n-  if (strncmp (name, LTO_SECTION_NAME_PREFIX, strlen (LTO_SECTION_NAME_PREFIX)))\n+  if (strncmp (name, section_name_prefix, strlen (section_name_prefix)))\n     return 0;\n   s = strrchr (name, '.');\n   return s && sscanf (s, \".\" HOST_WIDE_INT_PRINT_HEX_PURE, id) == 1;\n@@ -2912,6 +2912,10 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n \n   timevar_push (TV_IPA_LTO_DECL_IN);\n \n+#ifdef ACCEL_COMPILER\n+    section_name_prefix = OFFLOAD_SECTION_NAME_PREFIX;\n+#endif\n+\n   real_file_decl_data\n     = decl_data = ggc_cleared_vec_alloc<lto_file_decl_data_ptr> (nfiles + 1);\n   real_file_count = nfiles;"}, {"sha": "8ac5d94bcd1810dce35661b5faa64b8d9b7f1871", "filename": "gcc/omp-low.c", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -86,6 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-nested.h\"\n #include \"tree-eh.h\"\n #include \"cilk.h\"\n+#include \"context.h\"\n \n \n /* Lowering of OpenMP parallel and workshare constructs proceeds in two\n@@ -273,6 +274,16 @@ is_parallel_ctx (omp_context *ctx)\n }\n \n \n+/* Return true if CTX is for an omp target region.  */\n+\n+static inline bool\n+is_targetreg_ctx (omp_context *ctx)\n+{\n+  return gimple_code (ctx->stmt) == GIMPLE_OMP_TARGET\n+\t && gimple_omp_target_kind (ctx->stmt) == GF_OMP_TARGET_KIND_REGION;\n+}\n+\n+\n /* Return true if CTX is for an omp task.  */\n \n static inline bool\n@@ -1642,8 +1653,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t      && DECL_P (decl)\n \t      && is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx))\n-\t      && lookup_attribute (\"omp declare target\",\n-\t\t\t\t   DECL_ATTRIBUTES (decl)))\n+\t      && varpool_node::get_create (decl)->offloadable)\n \t    break;\n \t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t      && OMP_CLAUSE_MAP_KIND (c) == OMP_CLAUSE_MAP_POINTER)\n@@ -1783,8 +1793,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  if (DECL_P (decl)\n \t      && is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx))\n-\t      && lookup_attribute (\"omp declare target\",\n-\t\t\t\t   DECL_ATTRIBUTES (decl)))\n+\t      && varpool_node::get_create (decl)->offloadable)\n \t    break;\n \t  if (DECL_P (decl))\n \t    {\n@@ -1938,26 +1947,19 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n   DECL_EXTERNAL (decl) = 0;\n   DECL_CONTEXT (decl) = NULL_TREE;\n   DECL_INITIAL (decl) = make_node (BLOCK);\n-  bool target_p = false;\n-  if (lookup_attribute (\"omp declare target\",\n-\t\t\tDECL_ATTRIBUTES (current_function_decl)))\n-    target_p = true;\n+  if (cgraph_node::get (current_function_decl)->offloadable)\n+    cgraph_node::get_create (decl)->offloadable = 1;\n   else\n     {\n       omp_context *octx;\n       for (octx = ctx; octx; octx = octx->outer)\n-\tif (gimple_code (octx->stmt) == GIMPLE_OMP_TARGET\n-\t    && gimple_omp_target_kind (octx->stmt)\n-\t       == GF_OMP_TARGET_KIND_REGION)\n+\tif (is_targetreg_ctx (octx))\n \t  {\n-\t    target_p = true;\n+\t    cgraph_node::get_create (decl)->offloadable = 1;\n+\t    g->have_offload = true;\n \t    break;\n \t  }\n     }\n-  if (target_p)\n-    DECL_ATTRIBUTES (decl)\n-      = tree_cons (get_identifier (\"omp declare target\"),\n-\t\t   NULL_TREE, DECL_ATTRIBUTES (decl));\n \n   t = build_decl (DECL_SOURCE_LOCATION (decl),\n \t\t  RESULT_DECL, NULL_TREE, void_type_node);\n@@ -2663,8 +2665,7 @@ check_omp_nesting_restrictions (gimple stmt, omp_context *ctx)\n       break;\n     case GIMPLE_OMP_TARGET:\n       for (; ctx != NULL; ctx = ctx->outer)\n-\tif (gimple_code (ctx->stmt) == GIMPLE_OMP_TARGET\n-\t    && gimple_omp_target_kind (ctx->stmt) == GF_OMP_TARGET_KIND_REGION)\n+\tif (is_targetreg_ctx (ctx))\n \t  {\n \t    const char *name;\n \t    switch (gimple_omp_target_kind (stmt))\n@@ -8281,6 +8282,7 @@ expand_omp_target (struct omp_region *region)\n   if (kind == GF_OMP_TARGET_KIND_REGION)\n     {\n       unsigned srcidx, dstidx, num;\n+      struct cgraph_node *node;\n \n       /* If the target region needs data sent from the parent\n \t function, then the very first statement (except possible\n@@ -8412,6 +8414,11 @@ expand_omp_target (struct omp_region *region)\n       push_cfun (child_cfun);\n       cgraph_edge::rebuild_edges ();\n \n+      /* Prevent IPA from removing child_fn as unreachable, since there are no\n+\t refs from the parent function to child_fn in offload LTO mode.  */\n+      node = cgraph_node::get (child_fn);\n+      node->mark_force_output ();\n+\n       /* Some EH regions might become dead, see PR34608.  If\n \t pass_cleanup_cfg isn't the first pass to happen with the\n \t new child, these dead EH edges might cause problems.\n@@ -9326,6 +9333,17 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  DECL_COMMON (decl) = 1;\n \t  DECL_ARTIFICIAL (decl) = 1;\n \t  DECL_IGNORED_P (decl) = 1;\n+\n+\t  /* If '#pragma omp critical' is inside target region, the symbol must\n+\t     be marked for offloading.  */\n+\t  omp_context *octx;\n+\t  for (octx = ctx->outer; octx; octx = octx->outer)\n+\t    if (is_targetreg_ctx (octx))\n+\t      {\n+\t\tvarpool_node::get_create (decl)->offloadable = 1;\n+\t\tbreak;\n+\t      }\n+\n \t  varpool_node::finalize_decl (decl);\n \n \t  splay_tree_insert (critical_name_mutexes, (splay_tree_key) name,"}, {"sha": "aa40fe5fa30caa18c25ab7d6c199aa8be327b9ee", "filename": "gcc/passes.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -2416,7 +2416,7 @@ ipa_write_summaries_1 (lto_symtab_encoder_t encoder)\n /* Write out summaries for all the nodes in the callgraph.  */\n \n void\n-ipa_write_summaries (void)\n+ipa_write_summaries (bool offload_lto_mode)\n {\n   lto_symtab_encoder_t encoder;\n   int i, order_pos;\n@@ -2427,6 +2427,8 @@ ipa_write_summaries (void)\n   if (!flag_generate_lto || seen_error ())\n     return;\n \n+  select_what_to_stream (offload_lto_mode);\n+\n   encoder = lto_symtab_encoder_new (false);\n \n   /* Create the callgraph set in the same order used in\n@@ -2453,15 +2455,16 @@ ipa_write_summaries (void)\n \t  renumber_gimple_stmt_uids ();\n \t  pop_cfun ();\n \t}\n-      if (node->definition)\n+      if (node->definition && node->need_lto_streaming)\n         lto_set_symtab_encoder_in_partition (encoder, node);\n     }\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (node->alias)\n+    if (node->alias && node->need_lto_streaming)\n       lto_set_symtab_encoder_in_partition (encoder, node);\n   FOR_EACH_DEFINED_VARIABLE (vnode)\n-    lto_set_symtab_encoder_in_partition (encoder, vnode);\n+    if (vnode->need_lto_streaming)\n+      lto_set_symtab_encoder_in_partition (encoder, vnode);\n \n   ipa_write_summaries_1 (compute_ltrans_boundary (encoder));\n "}, {"sha": "b8f2801e198e0c9538f62269e38f89708dc1be79", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -602,7 +602,7 @@ extern void pass_fini_dump_file (opt_pass *);\n extern const char *get_current_pass_name (void);\n extern void print_current_pass (FILE *);\n extern void debug_pass (void);\n-extern void ipa_write_summaries (void);\n+extern void ipa_write_summaries (bool);\n extern void ipa_write_optimization_summaries (struct lto_symtab_encoder_d *);\n extern void ipa_read_summaries (void);\n extern void ipa_read_optimization_summaries (void);"}, {"sha": "ee889f2db53f13e4edc6d57f101b2998a801091a", "filename": "gcc/varpool.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6be68256cac22721f42085e014ad0c26e6dbb9/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=1f6be68256cac22721f42085e014ad0c26e6dbb9", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-alias.h\"\n #include \"gimple.h\"\n #include \"lto-streamer.h\"\n+#include \"context.h\"\n \n const char * const tls_model_names[]={\"none\", \"tls-emulated\", \"tls-real\",\n \t\t\t\t      \"tls-global-dynamic\", \"tls-local-dynamic\",\n@@ -164,6 +165,14 @@ varpool_node::get_create (tree decl)\n \n   node = varpool_node::create_empty ();\n   node->decl = decl;\n+\n+  if (flag_openmp\n+      && lookup_attribute (\"omp declare target\", DECL_ATTRIBUTES (decl)))\n+    {\n+      node->offloadable = 1;\n+      g->have_offload = true;\n+    }\n+\n   node->register_symbol ();\n   return node;\n }"}]}