{"sha": "b11b09048dcd08782578c7c34456e51aa408b1a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjExYjA5MDQ4ZGNkMDg3ODI1NzhjN2MzNDQ1NmU1MWFhNDA4YjFhOQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2011-06-10T10:50:20Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-06-10T10:50:20Z"}, "message": "invoke.texi (SPARC options): Add -mflat.\n\ngcc/\n\t* doc/invoke.texi (SPARC options): Add -mflat.\n\t* config/sparc/sparc.opt: Likewise.\n\t* config/sparc/sparc-protos.h (sparc_expand_epilogue): Add parameter.\n\t(sparc_flat_expand_prologue): Declare.\n\t(sparc_flat_expand_epilogue): Likewise.\n\t* config/sparc/sparc.h (CPP_CPU_SPEC): Do not handle -msoft-float.\n\t(CPP_ENDIAN_SPEC): Replace with...\n\t(CPP_OTHER_SPEC): ...this.  Also handle -mflat and -msoft-float.\n\t(CPP_SPEC): Adjust to above change.\n\t(EXTRA_SPECS): Likewise.\n\t(SPARC_INCOMING_INT_ARG_FIRST): Add TARGET_FLAT handling.\n\t(INCOMING_REGNO): Likewise.\n\t(OUTGOING_REGNO): Likewise.\n\t(LOCAL_REGNO): Likewise.\n\t(SETUP_FRAME_ADDRESSES): Likewise.\n\t(FIXED_REGISTERS): Set 0 for %fp.\n\t(CALL_USED_REGISTERS): Likewise.\n\t(INITIAL_ELIMINATION_OFFSET): Pass current_function_is_leaf.\n\t(EXIT_IGNORE_STACK): Define to 1 unconditionally.\n\t(RETURN_ADDR_REGNUM): Define.\n\t(RETURN_ADDR_RTX): Use it.\n\t(INCOMING_RETURN_ADDR_REGNUM): Define.\n\t(INCOMING_RETURN_ADDR_RTX): Use it.\n\t(DWARF_FRAME_RETURN_COLUMN): Likewise.\n\t(EH_RETURN_REGNUM): Define.\n\t(EH_RETURN_STACKADJ_RTX): Use it.\n\t(EH_RETURN_HANDLER_RTX): Delete.\n\t(EPILOGUE_USES): Use them and add TARGET_FLAT handling.\n\t* config/sparc/sparc.c (apparent_fsize, actual_fsize, num_gfregs):\n\tDelete.\n\t(struct machine_function): Add frame_size, apparent_frame_size,\n\tframe_base_reg, frame_base_offset, n_global_fp_regs and\n\tsave_local_in_regs_p fields.\n\t(sparc_frame_size, sparc_apparent_frame_size, sparc_frame_base_reg,\n\tsparc_frame_base_offset, sparc_n_global_fp_regs,\n\tsparc_save_local_in_regs_p): New macros.\n\t(sparc_option_override): Error out if -fcall-saved-REG is specified\n\tfor Out registers.\n\t(eligible_for_restore_insn): Fix formatting.\n\t(eligible_for_return_delay): Likewise.  Add TARGET_FLAT handling.\n\t(eligible_for_sibcall_delay): Likewise.\n\t(RTX_OK_FOR_OFFSET_P, RTX_OK_FOR_OLO10_P): Add MODE parameter.\n\t(sparc_legitimate_address_p): Adjust to above change.\n\t(save_global_or_fp_reg_p): New predicate.\n\t(return_addr_reg_needed_p): Likewise.\n\t(save_local_or_in_reg_p): Likewise.\n\t(sparc_compute_frame_size): Use them.  Add TARGET_FLAT handling.\n\t(SORR_SAVE, SORR_RESTORE): Delete.\n\t(sorr_pred_t): New typedef.\n\t(sorr_act_t): New enum.\n\t(save_or_restore_regs): Rename to...\n\t(emit_save_or_restore_regs): ...this.  Change type of LOW and HIGH\n\tparameters, remove ACTION parameter, add LEAF_FUNCTION_P, SAVE_P,\n\tACTION_TRUE and ACTION_FALSE parameters.  Implement more general\n\tmechanism.  Add CFI information for double-word saves in 32-bit mode.\n\t(emit_adjust_base_to_offset): New function extracted from...\n\t(emit_save_or_restore_regs): ...this.  Rename the rest to...\n\t(emit_save_or_restore_regs_global_fp_regs): ...this.\n\t(emit_save_or_restore_regs_local_in_regs): New function.\n\t(gen_create_flat_frame_[123]): New functions.\n\t(sparc_expand_prologue): Use SIZE local variable.  Adjust.\n\t(sparc_flat_expand_prologue): New function.\n\t(sparc_asm_function_prologue): Add TARGET_FLAT handling.\n\t(sparc_expand_epilogue): Use SIZE local variable.  Adjust.\n\t(sparc_flat_expand_epilogue): New function.\n\t(sparc_can_use_return_insn_p): Add TARGET_FLAT handling.\n\t(output_return): Likewise.\n\t(output_sibcall): Likewise.\n\t(sparc_output_mi_thunk): Likewise.\n\t(sparc_frame_pointer_required): Likewise.\n\t(sparc_conditional_register_usage): If TARGET_FLAT, disable the leaf\n\tfunction optimization.\n\t* config/sparc/sparc.md (flat): New attribute.\n\t(prologue): Add TARGET_FLAT handling.\n\t(save_register_window): Disable if TARGET_FLAT.\n\t(create_flat_frame_[123]): New patterns.\n\t(epilogue): Add TARGET_FLAT handling.\n\t(sibcall_epilogue): Likewise.\n\t(eh_return): New expander.\n\t(eh_return_internal): New insn and splitter.\n\t(return_internal): Add TARGET_FLAT handling.\n\t(untyped_return): Remove bogus test and use RETURN_ADDR_REGNUM.\n\t(save_stack_nonlocal): Use RETURN_ADDR_REGNUM.\n\t(nonlocal_goto): Add TARGET_FLAT handling.\n\t* config/sparc/t-elf: Add -mflat multilib.\n\t* config/sparc/t-leon: Likewise.\nlibgcc/\n\t* config/sparc/linux-unwind.h (STACK_BIAS): Define.\n\t(sparc64_fallback_frame_state): Use it.\n\t(sparc64_frob_update_context): Further adjust context.\n\t* config/sparc/sol2-unwind.h (sparc64_frob_update_context): Likewise.\n\t* config/sparc/sol2-ci.S: Add TARGET_FLAT handling.\n\t* config/sparc/sol2-cn.S: Likewise.\n\nCo-Authored-By: Laurent Roug\u00e9 <laurent.rouge@menta.fr>\n\nFrom-SVN: r174897", "tree": {"sha": "137aaf52d3f6ac1954c79cc1adf4a87dac699295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/137aaf52d3f6ac1954c79cc1adf4a87dac699295"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b11b09048dcd08782578c7c34456e51aa408b1a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b11b09048dcd08782578c7c34456e51aa408b1a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b11b09048dcd08782578c7c34456e51aa408b1a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b11b09048dcd08782578c7c34456e51aa408b1a9/comments", "author": null, "committer": null, "parents": [{"sha": "f5c01f5bde72d697dc28a9d9e31e9dfa2209f081", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5c01f5bde72d697dc28a9d9e31e9dfa2209f081", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5c01f5bde72d697dc28a9d9e31e9dfa2209f081"}], "stats": {"total": 1252, "additions": 977, "deletions": 275}, "files": [{"sha": "8fb1ad988ac76da77beb9a2c62705ab8881bc066", "filename": "gcc/ChangeLog", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -1,3 +1,93 @@\n+2011-06-10  Eric Botcazou  <ebotcazou@adacore.com>\n+\t    Laurent Roug\ufffd  <laurent.rouge@menta.fr>\n+\n+\t* doc/invoke.texi (SPARC options): Add -mflat.\n+\t* config/sparc/sparc.opt: Likewise.\n+\t* config/sparc/sparc-protos.h (sparc_expand_epilogue): Add parameter.\n+\t(sparc_flat_expand_prologue): Declare.\n+\t(sparc_flat_expand_epilogue): Likewise.\n+\t* config/sparc/sparc.h (CPP_CPU_SPEC): Do not handle -msoft-float.\n+\t(CPP_ENDIAN_SPEC): Replace with...\n+\t(CPP_OTHER_SPEC): ...this.  Also handle -mflat and -msoft-float.\n+\t(CPP_SPEC): Adjust to above change.\n+\t(EXTRA_SPECS): Likewise.\n+\t(SPARC_INCOMING_INT_ARG_FIRST): Add TARGET_FLAT handling.\n+\t(INCOMING_REGNO): Likewise.\n+\t(OUTGOING_REGNO): Likewise.\n+\t(LOCAL_REGNO): Likewise.\n+\t(SETUP_FRAME_ADDRESSES): Likewise.\n+\t(FIXED_REGISTERS): Set 0 for %fp.\n+\t(CALL_USED_REGISTERS): Likewise.\n+\t(INITIAL_ELIMINATION_OFFSET): Pass current_function_is_leaf.\n+\t(EXIT_IGNORE_STACK): Define to 1 unconditionally.\n+\t(RETURN_ADDR_REGNUM): Define.\n+\t(RETURN_ADDR_RTX): Use it.\n+\t(INCOMING_RETURN_ADDR_REGNUM): Define.\n+\t(INCOMING_RETURN_ADDR_RTX): Use it.\n+\t(DWARF_FRAME_RETURN_COLUMN): Likewise.\n+\t(EH_RETURN_REGNUM): Define.\n+\t(EH_RETURN_STACKADJ_RTX): Use it.\n+\t(EH_RETURN_HANDLER_RTX): Delete.\n+\t(EPILOGUE_USES): Use them and add TARGET_FLAT handling.\n+\t* config/sparc/sparc.c (apparent_fsize, actual_fsize, num_gfregs):\n+\tDelete.\n+\t(struct machine_function): Add frame_size, apparent_frame_size,\n+\tframe_base_reg, frame_base_offset, n_global_fp_regs and\n+\tsave_local_in_regs_p fields.\n+\t(sparc_frame_size, sparc_apparent_frame_size, sparc_frame_base_reg,\n+\tsparc_frame_base_offset, sparc_n_global_fp_regs,\n+\tsparc_save_local_in_regs_p): New macros.\n+\t(sparc_option_override): Error out if -fcall-saved-REG is specified\n+\tfor Out registers.\n+\t(eligible_for_restore_insn): Fix formatting.\n+\t(eligible_for_return_delay): Likewise.  Add TARGET_FLAT handling.\n+\t(eligible_for_sibcall_delay): Likewise.\n+\t(RTX_OK_FOR_OFFSET_P, RTX_OK_FOR_OLO10_P): Add MODE parameter.\n+\t(sparc_legitimate_address_p): Adjust to above change.\n+\t(save_global_or_fp_reg_p): New predicate.\n+\t(return_addr_reg_needed_p): Likewise.\n+\t(save_local_or_in_reg_p): Likewise.\n+\t(sparc_compute_frame_size): Use them.  Add TARGET_FLAT handling.\n+\t(SORR_SAVE, SORR_RESTORE): Delete.\n+\t(sorr_pred_t): New typedef.\n+\t(sorr_act_t): New enum.\n+\t(save_or_restore_regs): Rename to...\n+\t(emit_save_or_restore_regs): ...this.  Change type of LOW and HIGH\n+\tparameters, remove ACTION parameter, add LEAF_FUNCTION_P, SAVE_P,\n+\tACTION_TRUE and ACTION_FALSE parameters.  Implement more general\n+\tmechanism.  Add CFI information for double-word saves in 32-bit mode.\n+\t(emit_adjust_base_to_offset): New function extracted from...\n+\t(emit_save_or_restore_regs): ...this.  Rename the rest to...\n+\t(emit_save_or_restore_regs_global_fp_regs): ...this.\n+\t(emit_save_or_restore_regs_local_in_regs): New function.\n+\t(gen_create_flat_frame_[123]): New functions.\n+\t(sparc_expand_prologue): Use SIZE local variable.  Adjust.\n+\t(sparc_flat_expand_prologue): New function.\n+\t(sparc_asm_function_prologue): Add TARGET_FLAT handling.\n+\t(sparc_expand_epilogue): Use SIZE local variable.  Adjust.\n+\t(sparc_flat_expand_epilogue): New function.\n+\t(sparc_can_use_return_insn_p): Add TARGET_FLAT handling.\n+\t(output_return): Likewise.\n+\t(output_sibcall): Likewise.\n+\t(sparc_output_mi_thunk): Likewise.\n+\t(sparc_frame_pointer_required): Likewise.\n+\t(sparc_conditional_register_usage): If TARGET_FLAT, disable the leaf\n+\tfunction optimization.\n+\t* config/sparc/sparc.md (flat): New attribute.\n+\t(prologue): Add TARGET_FLAT handling.\n+\t(save_register_window): Disable if TARGET_FLAT.\n+\t(create_flat_frame_[123]): New patterns.\n+\t(epilogue): Add TARGET_FLAT handling.\n+\t(sibcall_epilogue): Likewise.\n+\t(eh_return): New expander.\n+\t(eh_return_internal): New insn and splitter.\n+\t(return_internal): Add TARGET_FLAT handling.\n+\t(untyped_return): Remove bogus test and use RETURN_ADDR_REGNUM.\n+\t(save_stack_nonlocal): Use RETURN_ADDR_REGNUM.\n+\t(nonlocal_goto): Add TARGET_FLAT handling.\n+\t* config/sparc/t-elf: Add -mflat multilib.\n+\t* config/sparc/t-leon: Likewise.\n+\n 2011-06-10  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-utils.c (searchc): Use cgraph_function_or_thunk_node."}, {"sha": "a5e25879793e7f6b900dfe8a40dabaaa95c7329a", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -38,7 +38,9 @@ extern enum direction function_arg_padding (enum machine_mode, const_tree);\n extern void order_regs_for_local_alloc (void);\n extern HOST_WIDE_INT sparc_compute_frame_size (HOST_WIDE_INT, int);\n extern void sparc_expand_prologue (void);\n-extern void sparc_expand_epilogue (void);\n+extern void sparc_flat_expand_prologue (void);\n+extern void sparc_expand_epilogue (bool);\n+extern void sparc_flat_expand_epilogue (bool);\n extern bool sparc_can_use_return_insn_p (void);\n extern int check_pic (int);\n extern int short_branch (int, int);"}, {"sha": "0de98c67974143ab516f2fe6519c19c5fc0a85d0", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 640, "deletions": 205, "changes": 845, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -287,21 +287,6 @@ const struct processor_costs *sparc_costs = &cypress_costs;\n   ((TARGET_ARCH64 && !TARGET_CM_MEDLOW) || flag_pic)\n #endif\n \n-/* Global variables for machine-dependent things.  */\n-\n-/* Size of frame.  Need to know this to emit return insns from leaf procedures.\n-   ACTUAL_FSIZE is set by sparc_compute_frame_size() which is called during the\n-   reload pass.  This is important as the value is later used for scheduling\n-   (to see what can go in a delay slot).\n-   APPARENT_FSIZE is the size of the stack less the register save area and less\n-   the outgoing argument area.  It is used when saving call preserved regs.  */\n-static HOST_WIDE_INT apparent_fsize;\n-static HOST_WIDE_INT actual_fsize;\n-\n-/* Number of live general or floating point registers needed to be\n-   saved (as 4-byte quantities).  */\n-static int num_gfregs;\n-\n /* Vector to say how input registers are mapped to output registers.\n    HARD_FRAME_POINTER_REGNUM cannot be remapped by this function to\n    eliminate it.  You must use -fomit-frame-pointer to get that.  */\n@@ -341,28 +326,46 @@ char sparc_leaf_regs[] =\n \n struct GTY(()) machine_function\n {\n+  /* Size of the frame of the function.  */\n+  HOST_WIDE_INT frame_size;\n+\n+  /* Size of the frame of the function minus the register window save area\n+     and the outgoing argument area.  */\n+  HOST_WIDE_INT apparent_frame_size;\n+\n+  /* Register we pretend the frame pointer is allocated to.  Normally, this\n+     is %fp, but if we are in a leaf procedure, this is (%sp + offset).  We\n+     record \"offset\" separately as it may be too big for (reg + disp).  */\n+  rtx frame_base_reg;\n+  HOST_WIDE_INT frame_base_offset;\n+\n   /* Some local-dynamic TLS symbol name.  */\n   const char *some_ld_name;\n \n+  /* Number of global or FP registers to be saved (as 4-byte quantities).  */\n+  int n_global_fp_regs;\n+\n   /* True if the current function is leaf and uses only leaf regs,\n      so that the SPARC leaf function optimization can be applied.\n      Private version of current_function_uses_only_leaf_regs, see\n      sparc_expand_prologue for the rationale.  */\n   int leaf_function_p;\n \n+  /* True if the prologue saves local or in registers.  */\n+  bool save_local_in_regs_p;\n+\n   /* True if the data calculated by sparc_expand_prologue are valid.  */\n   bool prologue_data_valid_p;\n };\n \n-#define sparc_leaf_function_p  cfun->machine->leaf_function_p\n-#define sparc_prologue_data_valid_p  cfun->machine->prologue_data_valid_p\n-\n-/* Register we pretend to think the frame pointer is allocated to.\n-   Normally, this is %fp, but if we are in a leaf procedure, this\n-   is %sp+\"something\".  We record \"something\" separately as it may\n-   be too big for reg+constant addressing.  */\n-static rtx frame_base_reg;\n-static HOST_WIDE_INT frame_base_offset;\n+#define sparc_frame_size\t\tcfun->machine->frame_size\n+#define sparc_apparent_frame_size\tcfun->machine->apparent_frame_size\n+#define sparc_frame_base_reg\t\tcfun->machine->frame_base_reg\n+#define sparc_frame_base_offset\t\tcfun->machine->frame_base_offset\n+#define sparc_n_global_fp_regs\t\tcfun->machine->n_global_fp_regs\n+#define sparc_leaf_function_p\t\tcfun->machine->leaf_function_p\n+#define sparc_save_local_in_regs_p\tcfun->machine->save_local_in_regs_p\n+#define sparc_prologue_data_valid_p\tcfun->machine->prologue_data_valid_p\n \n /* 1 if the next opcode is to be specially indented.  */\n int sparc_indent_opcode = 0;\n@@ -387,8 +390,6 @@ static rtx sparc_builtin_saveregs (void);\n static int epilogue_renumber (rtx *, int);\n static bool sparc_assemble_integer (rtx, unsigned int, int);\n static int set_extends (rtx);\n-static int save_or_restore_regs (int, int, rtx, int, int);\n-static void emit_save_or_restore_regs (int);\n static void sparc_asm_function_prologue (FILE *, HOST_WIDE_INT);\n static void sparc_asm_function_epilogue (FILE *, HOST_WIDE_INT);\n #ifdef TARGET_SOLARIS\n@@ -764,6 +765,7 @@ sparc_option_override (void)\n     { MASK_ISA, MASK_V9},\n   };\n   const struct cpu_table *cpu;\n+  unsigned int i;\n   int fpu;\n \n #ifdef SUBTARGET_OVERRIDE_OPTIONS\n@@ -808,6 +810,14 @@ sparc_option_override (void)\n \terror (\"-mcmodel= is not supported on 32 bit systems\");\n     }\n \n+  /* Check that -fcall-saved-REG wasn't specified for out registers.  */\n+  for (i = 8; i < 16; i++)\n+    if (!call_used_regs [i])\n+      {\n+\terror (\"-fcall-saved-REG is not supported for out registers\");\n+        call_used_regs [i] = 1;\n+      }\n+\n   fpu = target_flags & MASK_FPU; /* save current -mfpu status */\n \n   /* Set the default CPU.  */\n@@ -2769,9 +2779,11 @@ eligible_for_restore_insn (rtx trial, bool return_p)\n \n   /* If we have the 'return' instruction, anything that does not use\n      local or output registers and can go into a delay slot wins.  */\n-  else if (return_p && TARGET_V9 && ! epilogue_renumber (&pat, 1)\n-\t   && (get_attr_in_uncond_branch_delay (trial)\n-\t       == IN_UNCOND_BRANCH_DELAY_TRUE))\n+  else if (return_p\n+\t   && TARGET_V9\n+\t   && !epilogue_renumber (&pat, 1)\n+\t   && get_attr_in_uncond_branch_delay (trial)\n+\t       == IN_UNCOND_BRANCH_DELAY_TRUE)\n     return 1;\n \n   /* The 'restore src1,src2,dest' pattern for SImode.  */\n@@ -2806,8 +2818,7 @@ eligible_for_restore_insn (rtx trial, bool return_p)\n   return 0;\n }\n \n-/* Return nonzero if TRIAL can go into the function return's\n-   delay slot.  */\n+/* Return nonzero if TRIAL can go into the function return's delay slot.  */\n \n int\n eligible_for_return_delay (rtx trial)\n@@ -2825,10 +2836,10 @@ eligible_for_return_delay (rtx trial)\n   if (crtl->calls_eh_return)\n     return 0;\n \n-  /* In the case of a true leaf function, anything can go into the slot.  */\n-  if (sparc_leaf_function_p)\n-    return get_attr_in_uncond_branch_delay (trial)\n-\t   == IN_UNCOND_BRANCH_DELAY_TRUE;\n+  /* In the case of a leaf or flat function, anything can go into the slot.  */\n+  if (sparc_leaf_function_p || TARGET_FLAT)\n+    return\n+      get_attr_in_uncond_branch_delay (trial) == IN_UNCOND_BRANCH_DELAY_TRUE;\n \n   pat = PATTERN (trial);\n \n@@ -2843,15 +2854,14 @@ eligible_for_return_delay (rtx trial)\n      with FP_REGS.  */\n   if (REGNO (SET_DEST (pat)) >= 32)\n     return (TARGET_V9\n-\t    && ! epilogue_renumber (&pat, 1)\n-\t    && (get_attr_in_uncond_branch_delay (trial)\n-\t\t== IN_UNCOND_BRANCH_DELAY_TRUE));\n+\t    && !epilogue_renumber (&pat, 1)\n+\t    && get_attr_in_uncond_branch_delay (trial)\n+\t       == IN_UNCOND_BRANCH_DELAY_TRUE);\n \n   return eligible_for_restore_insn (trial, true);\n }\n \n-/* Return nonzero if TRIAL can go into the sibling call's\n-   delay slot.  */\n+/* Return nonzero if TRIAL can go into the sibling call's delay slot.  */\n \n int\n eligible_for_sibcall_delay (rtx trial)\n@@ -2866,7 +2876,7 @@ eligible_for_sibcall_delay (rtx trial)\n \n   pat = PATTERN (trial);\n \n-  if (sparc_leaf_function_p)\n+  if (sparc_leaf_function_p || TARGET_FLAT)\n     {\n       /* If the tail call is done using the call instruction,\n \t we have to restore %o7 in the delay slot.  */\n@@ -3117,11 +3127,15 @@ legitimate_pic_operand_p (rtx x)\n   return true;\n }\n \n-#define RTX_OK_FOR_OFFSET_P(X)                                          \\\n-  (CONST_INT_P (X) && INTVAL (X) >= -0x1000 && INTVAL (X) < 0x1000 - 8)\n+#define RTX_OK_FOR_OFFSET_P(X, MODE)\t\t\t\\\n+  (CONST_INT_P (X)\t\t\t\t\t\\\n+   && INTVAL (X) >= -0x1000\t\t\t\t\\\n+   && INTVAL (X) < (0x1000 - GET_MODE_SIZE (MODE)))\n \n-#define RTX_OK_FOR_OLO10_P(X)                                           \\\n-  (CONST_INT_P (X) && INTVAL (X) >= -0x1000 && INTVAL (X) < 0xc00 - 8)\n+#define RTX_OK_FOR_OLO10_P(X, MODE)\t\t\t\\\n+  (CONST_INT_P (X)\t\t\t\t\t\\\n+   && INTVAL (X) >= -0x1000\t\t\t\t\\\n+   && INTVAL (X) < (0xc00 - GET_MODE_SIZE (MODE)))\n \n /* Handle the TARGET_LEGITIMATE_ADDRESS_P target hook.\n \n@@ -3163,7 +3177,7 @@ sparc_legitimate_address_p (enum machine_mode mode, rtx addr, bool strict)\n \t   && (GET_CODE (rs2) != CONST_INT || SMALL_INT (rs2)))\n \t  || ((REG_P (rs1)\n \t       || GET_CODE (rs1) == SUBREG)\n-\t      && RTX_OK_FOR_OFFSET_P (rs2)))\n+\t      && RTX_OK_FOR_OFFSET_P (rs2, mode)))\n \t{\n \t  imm1 = rs2;\n \t  rs2 = NULL;\n@@ -3193,7 +3207,7 @@ sparc_legitimate_address_p (enum machine_mode mode, rtx addr, bool strict)\n \t       && GET_CODE (rs1) == LO_SUM\n \t       && TARGET_ARCH64\n \t       && ! TARGET_CM_MEDMID\n-\t       && RTX_OK_FOR_OLO10_P (rs2))\n+\t       && RTX_OK_FOR_OLO10_P (rs2, mode))\n \t{\n \t  rs2 = NULL;\n \t  imm1 = XEXP (rs1, 1);\n@@ -4104,59 +4118,138 @@ sparc_init_modes (void)\n     }\n }\n \f\n+/* Return whether REGNO, a global or FP register, must be saved/restored.  */\n+\n+static inline bool\n+save_global_or_fp_reg_p (unsigned int regno,\n+\t\t\t int leaf_function ATTRIBUTE_UNUSED)\n+{\n+  return !call_used_regs[regno] && df_regs_ever_live_p (regno);\n+}\n+\n+/* Return whether the return address register (%i7) is needed.  */\n+\n+static inline bool\n+return_addr_reg_needed_p (int leaf_function)\n+{\n+  /* If it is live, for example because of __builtin_return_address (0).  */\n+  if (df_regs_ever_live_p (RETURN_ADDR_REGNUM))\n+    return true;\n+\n+  /* Otherwise, it is needed as save register if %o7 is clobbered.  */\n+  if (!leaf_function\n+      /* Loading the GOT register clobbers %o7.  */\n+      || crtl->uses_pic_offset_table\n+      || df_regs_ever_live_p (INCOMING_RETURN_ADDR_REGNUM))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Return whether REGNO, a local or in register, must be saved/restored.  */\n+\n+static bool\n+save_local_or_in_reg_p (unsigned int regno, int leaf_function)\n+{\n+  /* General case: call-saved registers live at some point.  */\n+  if (!call_used_regs[regno] && df_regs_ever_live_p (regno))\n+    return true;\n+\n+  /* Frame pointer register (%fp) if needed.  */\n+  if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\n+    return true;\n+\n+  /* Return address register (%i7) if needed.  */\n+  if (regno == RETURN_ADDR_REGNUM && return_addr_reg_needed_p (leaf_function))\n+    return true;\n+\n+  /* PIC register (%l7) if needed.  */\n+  if (regno == PIC_OFFSET_TABLE_REGNUM && crtl->uses_pic_offset_table)\n+    return true;\n+\n+  /* If the function accesses prior frames, the frame pointer and the return\n+     address of the previous frame must be saved on the stack.  */\n+  if (crtl->accesses_prior_frames\n+      && (regno == HARD_FRAME_POINTER_REGNUM || regno == RETURN_ADDR_REGNUM))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Compute the frame size required by the function.  This function is called\n    during the reload pass and also by sparc_expand_prologue.  */\n \n HOST_WIDE_INT\n-sparc_compute_frame_size (HOST_WIDE_INT size, int leaf_function_p)\n+sparc_compute_frame_size (HOST_WIDE_INT size, int leaf_function)\n {\n-  int outgoing_args_size = (crtl->outgoing_args_size\n-\t\t\t    + REG_PARM_STACK_SPACE (current_function_decl));\n-  int n_regs = 0;  /* N_REGS is the number of 4-byte regs saved thus far.  */\n-  int i;\n+  HOST_WIDE_INT frame_size, apparent_frame_size;\n+  int args_size, n_global_fp_regs = 0;\n+  bool save_local_in_regs_p = false;\n+  unsigned int i;\n \n-  if (TARGET_ARCH64)\n-    {\n-      for (i = 0; i < 8; i++)\n-\tif (df_regs_ever_live_p (i) && ! call_used_regs[i])\n-\t  n_regs += 2;\n-    }\n+  /* If the function allocates dynamic stack space, the dynamic offset is\n+     computed early and contains REG_PARM_STACK_SPACE, so we need to cope.  */\n+  if (leaf_function && !cfun->calls_alloca)\n+    args_size = 0;\n   else\n-    {\n-      for (i = 0; i < 8; i += 2)\n-\tif ((df_regs_ever_live_p (i) && ! call_used_regs[i])\n-\t    || (df_regs_ever_live_p (i+1) && ! call_used_regs[i+1]))\n-\t  n_regs += 2;\n-    }\n+    args_size = crtl->outgoing_args_size + REG_PARM_STACK_SPACE (cfun->decl);\n \n-  for (i = 32; i < (TARGET_V9 ? 96 : 64); i += 2)\n-    if ((df_regs_ever_live_p (i) && ! call_used_regs[i])\n-\t|| (df_regs_ever_live_p (i+1) && ! call_used_regs[i+1]))\n-      n_regs += 2;\n+  /* Calculate space needed for global registers.  */\n+  if (TARGET_ARCH64)\n+    for (i = 0; i < 8; i++)\n+      if (save_global_or_fp_reg_p (i, 0))\n+\tn_global_fp_regs += 2;\n+  else\n+    for (i = 0; i < 8; i += 2)\n+      if (save_global_or_fp_reg_p (i, 0) || save_global_or_fp_reg_p (i + 1, 0))\n+\tn_global_fp_regs += 2;\n \n-  /* Set up values for use in prologue and epilogue.  */\n-  num_gfregs = n_regs;\n+  /* In the flat window model, find out which local and in registers need to\n+     be saved.  We don't reserve space in the current frame for them as they\n+     will be spilled into the register window save area of the caller's frame.\n+     However, as soon as we use this register window save area, we must create\n+     that of the current frame to make it the live one.  */\n+  if (TARGET_FLAT)\n+    for (i = 16; i < 32; i++)\n+      if (save_local_or_in_reg_p (i, leaf_function))\n+\t{\n+\t save_local_in_regs_p = true;\n+\t break;\n+\t}\n \n-  if (leaf_function_p\n-      && n_regs == 0\n-      && size == 0\n-      && crtl->outgoing_args_size == 0)\n-    actual_fsize = apparent_fsize = 0;\n+  /* Calculate space needed for FP registers.  */\n+  for (i = 32; i < (TARGET_V9 ? 96 : 64); i += 2)\n+    if (save_global_or_fp_reg_p (i, 0) || save_global_or_fp_reg_p (i + 1, 0))\n+      n_global_fp_regs += 2;\n+\n+  if (size == 0\n+      && n_global_fp_regs == 0\n+      && args_size == 0\n+      && !save_local_in_regs_p)\n+    frame_size = apparent_frame_size = 0;\n   else\n     {\n       /* We subtract STARTING_FRAME_OFFSET, remember it's negative.  */\n-      apparent_fsize = (size - STARTING_FRAME_OFFSET + 7) & -8;\n-      apparent_fsize += n_regs * 4;\n-      actual_fsize = apparent_fsize + ((outgoing_args_size + 7) & -8);\n+      apparent_frame_size = (size - STARTING_FRAME_OFFSET + 7) & -8;\n+      apparent_frame_size += n_global_fp_regs * 4;\n+\n+      /* We need to add the size of the outgoing argument area.  */\n+      frame_size = apparent_frame_size + ((args_size + 7) & -8);\n+\n+      /* And that of the register window save area.  */\n+      frame_size += FIRST_PARM_OFFSET (cfun->decl);\n+\n+      /* Finally, bump to the appropriate alignment.  */\n+      frame_size = SPARC_STACK_ALIGN (frame_size);\n     }\n \n-  /* Make sure nothing can clobber our register windows.\n-     If a SAVE must be done, or there is a stack-local variable,\n-     the register window area must be allocated.  */\n-  if (! leaf_function_p || size > 0)\n-    actual_fsize += FIRST_PARM_OFFSET (current_function_decl);\n+  /* Set up values for use in prologue and epilogue.  */\n+  sparc_frame_size = frame_size;\n+  sparc_apparent_frame_size = apparent_frame_size;\n+  sparc_n_global_fp_regs = n_global_fp_regs;\n+  sparc_save_local_in_regs_p = save_local_in_regs_p;\n \n-  return SPARC_STACK_ALIGN (actual_fsize);\n+  return frame_size;\n }\n \n /* Output any necessary .register pseudo-ops.  */\n@@ -4342,43 +4435,66 @@ output_probe_stack_range (rtx reg1, rtx reg2)\n   return \"\";\n }\n \n-/* Save/restore call-saved registers from LOW to HIGH at BASE+OFFSET\n-   as needed.  LOW should be double-word aligned for 32-bit registers.\n-   Return the new OFFSET.  */\n+/* Emit code to save/restore registers from LOW to HIGH at BASE+OFFSET as\n+   needed.  LOW is supposed to be double-word aligned for 32-bit registers.\n+   SAVE_P decides whether a register must be saved/restored.  ACTION_TRUE\n+   is the action to be performed if SAVE_P returns true and ACTION_FALSE\n+   the action to be performed if it returns false.  Return the new offset.  */\n \n-#define SORR_SAVE    0\n-#define SORR_RESTORE 1\n+typedef bool (*sorr_pred_t) (unsigned int, int);\n+typedef enum { SORR_NONE, SORR_ADVANCE, SORR_SAVE, SORR_RESTORE } sorr_act_t;\n \n static int\n-save_or_restore_regs (int low, int high, rtx base, int offset, int action)\n+emit_save_or_restore_regs (unsigned int low, unsigned int high, rtx base,\n+\t\t\t   int offset, int leaf_function, sorr_pred_t save_p,\n+\t\t\t   sorr_act_t action_true, sorr_act_t action_false)\n {\n+  unsigned int i;\n   rtx mem, insn;\n-  int i;\n \n   if (TARGET_ARCH64 && high <= 32)\n     {\n+      int fp_offset = -1;\n+\n       for (i = low; i < high; i++)\n \t{\n-\t  if (df_regs_ever_live_p (i) && ! call_used_regs[i])\n+\t  if (save_p (i, leaf_function))\n \t    {\n \t      mem = gen_frame_mem (DImode, plus_constant (base, offset));\n-\t      if (action == SORR_SAVE)\n+\t      if (action_true == SORR_SAVE)\n \t\t{\n \t\t  insn = emit_move_insn (mem, gen_rtx_REG (DImode, i));\n \t\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t\t}\n-\t      else  /* action == SORR_RESTORE */\n-\t\temit_move_insn (gen_rtx_REG (DImode, i), mem);\n+\t      else  /* action_true == SORR_RESTORE */\n+\t\t{\n+\t\t  /* The frame pointer must be restored last since its old\n+\t\t     value may be used as base address for the frame.  This\n+\t\t     is problematic in 64-bit mode only because of the lack\n+\t\t     of double-word load instruction.  */\n+\t\t  if (i == HARD_FRAME_POINTER_REGNUM)\n+\t\t    fp_offset = offset;\n+\t\t  else\n+\t\t    emit_move_insn (gen_rtx_REG (DImode, i), mem);\n+\t\t}\n \t      offset += 8;\n \t    }\n+\t  else if (action_false == SORR_ADVANCE)\n+\t    offset += 8;\n+\t}\n+\n+      if (fp_offset >= 0)\n+\t{\n+\t  mem = gen_frame_mem (DImode, plus_constant (base, fp_offset));\n+\t  emit_move_insn (hard_frame_pointer_rtx, mem);\n \t}\n     }\n   else\n     {\n       for (i = low; i < high; i += 2)\n \t{\n-\t  bool reg0 = df_regs_ever_live_p (i) && ! call_used_regs[i];\n-\t  bool reg1 = df_regs_ever_live_p (i+1) && ! call_used_regs[i+1];\n+\t  bool reg0 = save_p (i, leaf_function);\n+\t  bool reg1 = save_p (i + 1, leaf_function);\n \t  enum machine_mode mode;\n \t  int regno;\n \n@@ -4399,15 +4515,35 @@ save_or_restore_regs (int low, int high, rtx base, int offset, int action)\n \t      offset += 4;\n \t    }\n \t  else\n-\t    continue;\n+\t    {\n+\t      if (action_false == SORR_ADVANCE)\n+\t\toffset += 8;\n+\t      continue;\n+\t    }\n \n \t  mem = gen_frame_mem (mode, plus_constant (base, offset));\n-\t  if (action == SORR_SAVE)\n+\t  if (action_true == SORR_SAVE)\n \t    {\n \t      insn = emit_move_insn (mem, gen_rtx_REG (mode, regno));\n \t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      if (mode == DImode)\n+\t\t{\n+\t\t  rtx set1, set2;\n+\t\t  mem = gen_frame_mem (SImode, plus_constant (base, offset));\n+\t\t  set1 = gen_rtx_SET (VOIDmode, mem,\n+\t\t\t\t      gen_rtx_REG (SImode, regno));\n+\t\t  RTX_FRAME_RELATED_P (set1) = 1;\n+\t\t  mem\n+\t\t    = gen_frame_mem (SImode, plus_constant (base, offset + 4));\n+\t\t  set2 = gen_rtx_SET (VOIDmode, mem,\n+\t\t\t\t      gen_rtx_REG (SImode, regno + 1));\n+\t\t  RTX_FRAME_RELATED_P (set2) = 1;\n+\t\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\t\tgen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t\t\t  gen_rtvec (2, set1, set2)));\n+\t\t}\n \t    }\n-\t  else  /* action == SORR_RESTORE */\n+\t  else  /* action_true == SORR_RESTORE */\n \t    emit_move_insn (gen_rtx_REG (mode, regno), mem);\n \n \t  /* Always preserve double-word alignment.  */\n@@ -4418,36 +4554,54 @@ save_or_restore_regs (int low, int high, rtx base, int offset, int action)\n   return offset;\n }\n \n-/* Emit code to save call-saved registers.  */\n+/* Emit code to adjust BASE to OFFSET.  Return the new base.  */\n+\n+static rtx\n+emit_adjust_base_to_offset (rtx base, int offset)\n+{\n+  /* ??? This might be optimized a little as %g1 might already have a\n+     value close enough that a single add insn will do.  */\n+  /* ??? Although, all of this is probably only a temporary fix because\n+     if %g1 can hold a function result, then sparc_expand_epilogue will\n+     lose (the result will be clobbered).  */\n+  rtx new_base = gen_rtx_REG (Pmode, 1);\n+  emit_move_insn (new_base, GEN_INT (offset));\n+  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t  new_base, gen_rtx_PLUS (Pmode, base, new_base)));\n+  return new_base;\n+}\n+\n+/* Emit code to save/restore call-saved global and FP registers.  */\n \n static void\n-emit_save_or_restore_regs (int action)\n+emit_save_or_restore_global_fp_regs (rtx base, int offset, sorr_act_t action)\n {\n-  HOST_WIDE_INT offset;\n-  rtx base;\n+  if (offset < -4096 || offset + sparc_n_global_fp_regs * 4 > 4095)\n+    {\n+      base = emit_adjust_base_to_offset  (base, offset);\n+      offset = 0;\n+    }\n \n-  offset = frame_base_offset - apparent_fsize;\n+  offset\n+    = emit_save_or_restore_regs (0, 8, base, offset, 0,\n+\t\t\t\t save_global_or_fp_reg_p, action, SORR_NONE);\n+  emit_save_or_restore_regs (32, TARGET_V9 ? 96 : 64, base, offset, 0,\n+\t\t\t     save_global_or_fp_reg_p, action, SORR_NONE);\n+}\n \n-  if (offset < -4096 || offset + num_gfregs * 4 > 4095)\n+/* Emit code to save/restore call-saved local and in registers.  */\n+\n+static void\n+emit_save_or_restore_local_in_regs (rtx base, int offset, sorr_act_t action)\n+{\n+  if (offset < -4096 || offset + 16 * UNITS_PER_WORD > 4095)\n     {\n-      /* ??? This might be optimized a little as %g1 might already have a\n-\t value close enough that a single add insn will do.  */\n-      /* ??? Although, all of this is probably only a temporary fix\n-\t because if %g1 can hold a function result, then\n-\t sparc_expand_epilogue will lose (the result will be\n-\t clobbered).  */\n-      base = gen_rtx_REG (Pmode, 1);\n-      emit_move_insn (base, GEN_INT (offset));\n-      emit_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t      base,\n-\t\t\t      gen_rtx_PLUS (Pmode, frame_base_reg, base)));\n+      base = emit_adjust_base_to_offset  (base, offset);\n       offset = 0;\n     }\n-  else\n-    base = frame_base_reg;\n \n-  offset = save_or_restore_regs (0, 8, base, offset, action);\n-  save_or_restore_regs (32, TARGET_V9 ? 96 : 64, base, offset, action);\n+  emit_save_or_restore_regs (16, 32, base, offset, sparc_leaf_function_p,\n+\t\t\t     save_local_or_in_reg_p, action, SORR_ADVANCE);\n }\n \n /* Generate a save_register_window insn.  */\n@@ -4461,6 +4615,39 @@ gen_save_register_window (rtx increment)\n     return gen_save_register_windowsi (increment);\n }\n \n+/* Generate a create_flat_frame_1 insn.  */\n+\n+static rtx\n+gen_create_flat_frame_1 (rtx increment)\n+{\n+  if (TARGET_ARCH64)\n+    return gen_create_flat_frame_1di (increment);\n+  else\n+    return gen_create_flat_frame_1si (increment);\n+}\n+\n+/* Generate a create_flat_frame_2 insn.  */\n+\n+static rtx\n+gen_create_flat_frame_2 (rtx increment)\n+{\n+  if (TARGET_ARCH64)\n+    return gen_create_flat_frame_2di (increment);\n+  else\n+    return gen_create_flat_frame_2si (increment);\n+}\n+\n+/* Generate a create_flat_frame_3 insn.  */\n+\n+static rtx\n+gen_create_flat_frame_3 (rtx increment)\n+{\n+  if (TARGET_ARCH64)\n+    return gen_create_flat_frame_3di (increment);\n+  else\n+    return gen_create_flat_frame_3si (increment);\n+}\n+\n /* Generate an increment for the stack pointer.  */\n \n static rtx\n@@ -4492,6 +4679,7 @@ gen_stack_pointer_dec (rtx decrement)\n void\n sparc_expand_prologue (void)\n {\n+  HOST_WIDE_INT size;\n   rtx insn;\n   int i;\n \n@@ -4520,70 +4708,52 @@ sparc_expand_prologue (void)\n   sparc_leaf_function_p\n     = optimize > 0 && current_function_is_leaf && only_leaf_regs_used ();\n \n-  /* Need to use actual_fsize, since we are also allocating\n-     space for our callee (and our own register save area).  */\n-  actual_fsize\n-    = sparc_compute_frame_size (get_frame_size(), sparc_leaf_function_p);\n-\n-  /* Advertise that the data calculated just above are now valid.  */\n-  sparc_prologue_data_valid_p = true;\n+  size = sparc_compute_frame_size (get_frame_size(), sparc_leaf_function_p);\n \n   if (flag_stack_usage_info)\n-    current_function_static_stack_size = actual_fsize;\n+    current_function_static_stack_size = size;\n \n-  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && actual_fsize)\n-    sparc_emit_probe_stack_range (STACK_CHECK_PROTECT, actual_fsize);\n+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && size)\n+    sparc_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n \n-  if (sparc_leaf_function_p)\n-    {\n-      frame_base_reg = stack_pointer_rtx;\n-      frame_base_offset = actual_fsize + SPARC_STACK_BIAS;\n-    }\n-  else\n-    {\n-      frame_base_reg = hard_frame_pointer_rtx;\n-      frame_base_offset = SPARC_STACK_BIAS;\n-    }\n-\n-  if (actual_fsize == 0)\n-    /* do nothing.  */ ;\n+  if (size == 0)\n+    ; /* do nothing.  */\n   else if (sparc_leaf_function_p)\n     {\n-      if (actual_fsize <= 4096)\n-\tinsn = emit_insn (gen_stack_pointer_inc (GEN_INT (-actual_fsize)));\n-      else if (actual_fsize <= 8192)\n+      if (size <= 4096)\n+\tinsn = emit_insn (gen_stack_pointer_inc (GEN_INT (-size)));\n+      else if (size <= 8192)\n \t{\n \t  insn = emit_insn (gen_stack_pointer_inc (GEN_INT (-4096)));\n \t  /* %sp is still the CFA register.  */\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  insn\n-\t    = emit_insn (gen_stack_pointer_inc (GEN_INT (4096-actual_fsize)));\n+\t  insn = emit_insn (gen_stack_pointer_inc (GEN_INT (4096 - size)));\n \t}\n       else\n \t{\n \t  rtx reg = gen_rtx_REG (Pmode, 1);\n-\t  emit_move_insn (reg, GEN_INT (-actual_fsize));\n+\t  emit_move_insn (reg, GEN_INT (-size));\n \t  insn = emit_insn (gen_stack_pointer_inc (reg));\n \t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n-\t\t\tgen_stack_pointer_inc (GEN_INT (-actual_fsize)));\n+\t\t\tgen_stack_pointer_inc (GEN_INT (-size)));\n \t}\n \n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n   else\n     {\n-      if (actual_fsize <= 4096)\n-\tinsn = emit_insn (gen_save_register_window (GEN_INT (-actual_fsize)));\n-      else if (actual_fsize <= 8192)\n+      if (size <= 4096)\n+\tinsn = emit_insn (gen_save_register_window (GEN_INT (-size)));\n+      else if (size <= 8192)\n \t{\n \t  insn = emit_insn (gen_save_register_window (GEN_INT (-4096)));\n \t  /* %sp is not the CFA register anymore.  */\n-\t  emit_insn (gen_stack_pointer_inc (GEN_INT (4096-actual_fsize)));\n+\t  emit_insn (gen_stack_pointer_inc (GEN_INT (4096 - size)));\n \t}\n       else\n \t{\n \t  rtx reg = gen_rtx_REG (Pmode, 1);\n-\t  emit_move_insn (reg, GEN_INT (-actual_fsize));\n+\t  emit_move_insn (reg, GEN_INT (-size));\n \t  insn = emit_insn (gen_save_register_window (reg));\n \t}\n \n@@ -4592,12 +4762,179 @@ sparc_expand_prologue (void)\n         RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, i)) = 1;\n     }\n \n-  if (num_gfregs)\n-    emit_save_or_restore_regs (SORR_SAVE);\n+  if (sparc_leaf_function_p)\n+    {\n+      sparc_frame_base_reg = stack_pointer_rtx;\n+      sparc_frame_base_offset = size + SPARC_STACK_BIAS;\n+    }\n+  else\n+    {\n+      sparc_frame_base_reg = hard_frame_pointer_rtx;\n+      sparc_frame_base_offset = SPARC_STACK_BIAS;\n+    }\n+\n+  if (sparc_n_global_fp_regs > 0)\n+    emit_save_or_restore_global_fp_regs (sparc_frame_base_reg,\n+\t\t\t\t         sparc_frame_base_offset\n+\t\t\t\t\t   - sparc_apparent_frame_size,\n+\t\t\t\t\t SORR_SAVE);\n \n   /* Load the GOT register if needed.  */\n   if (crtl->uses_pic_offset_table)\n     load_got_register ();\n+\n+  /* Advertise that the data calculated just above are now valid.  */\n+  sparc_prologue_data_valid_p = true;\n+}\n+\n+/* Expand the function prologue.  The prologue is responsible for reserving\n+   storage for the frame, saving the call-saved registers and loading the\n+   GOT register if needed.  */\n+\n+void\n+sparc_flat_expand_prologue (void)\n+{\n+  HOST_WIDE_INT size;\n+  rtx insn;\n+  int i;\n+\n+  sparc_leaf_function_p = optimize > 0 && current_function_is_leaf;\n+\n+  size = sparc_compute_frame_size (get_frame_size(), sparc_leaf_function_p);\n+\n+  if (flag_stack_usage_info)\n+    current_function_static_stack_size = size;\n+\n+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && size)\n+    sparc_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+\n+  if (sparc_save_local_in_regs_p)\n+    emit_save_or_restore_local_in_regs (stack_pointer_rtx, SPARC_STACK_BIAS,\n+\t\t\t\t\tSORR_SAVE);\n+\n+  if (size == 0)\n+    ; /* do nothing.  */\n+  else if (frame_pointer_needed)\n+    {\n+      if (size <= 4096)\n+\t{\n+\t  if (return_addr_reg_needed_p (sparc_leaf_function_p))\n+\t    insn = emit_insn (gen_create_flat_frame_1 (GEN_INT (-size)));\n+\t  else\n+\t    insn = emit_insn (gen_create_flat_frame_2 (GEN_INT (-size)));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  for (i=0; i < XVECLEN (PATTERN (insn), 0); i++)\n+\t    RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, i)) = 1;\n+\t}\n+      else\n+\t{\n+\t  rtx reg = gen_rtx_REG (Pmode, 1), note;\n+\t  emit_move_insn (reg, GEN_INT (-size));\n+\t  if (return_addr_reg_needed_p (sparc_leaf_function_p))\n+\t    {\n+\t      insn = emit_insn (gen_create_flat_frame_1 (reg));\n+\t      note\n+\t\t= gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t    gen_rtvec\n+\t\t\t\t    (3, copy_rtx\n+\t\t\t\t\t(XVECEXP (PATTERN (insn), 0, 0)),\n+\t\t\t\t\tgen_stack_pointer_inc\n+\t\t\t\t\t(GEN_INT (-size)),\n+\t\t\t\t\tcopy_rtx\n+\t\t\t\t\t(XVECEXP (PATTERN (insn), 0, 2))));\n+\t    }\n+\t  else\n+\t    {\n+\t      insn = emit_insn (gen_create_flat_frame_2 (reg));\n+\t      note\n+\t\t= gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t    gen_rtvec\n+\t\t\t\t    (2, copy_rtx\n+\t\t\t\t\t(XVECEXP (PATTERN (insn), 0, 0)),\n+\t\t\t\t\tgen_stack_pointer_inc\n+\t\t\t\t\t(GEN_INT (-size))));\n+\t    }\n+\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, note);\n+\t  for (i=0; i < XVECLEN (note, 0); i++)\n+\t    RTX_FRAME_RELATED_P (XVECEXP (note, 0, i)) = 1;\n+\t}\n+    }\n+  else if (return_addr_reg_needed_p (sparc_leaf_function_p))\n+    {\n+      if (size <= 4096)\n+\t{\n+\t  insn = emit_insn (gen_create_flat_frame_3 (GEN_INT (-size)));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  for (i=0; i < XVECLEN (PATTERN (insn), 0); i++)\n+\t    RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, i)) = 1;\n+\t}\n+      else\n+\t{\n+\t  rtx reg = gen_rtx_REG (Pmode, 1), note;\n+\t  emit_move_insn (reg, GEN_INT (-size));\n+\t  insn = emit_insn (gen_create_flat_frame_3 (reg));\n+\t  note\n+\t    = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\tgen_rtvec\n+\t\t\t\t(2, gen_stack_pointer_inc (GEN_INT (-size)),\n+\t\t\t\t    copy_rtx\n+\t\t\t\t    (XVECEXP (PATTERN (insn), 0, 1))));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, note);\n+\t  for (i=0; i < XVECLEN (note, 0); i++)\n+\t    RTX_FRAME_RELATED_P (XVECEXP (note, 0, i)) = 1;\n+\t}\n+    }\n+  else\n+    {\n+      if (size <= 4096)\n+\tinsn = emit_insn (gen_stack_pointer_inc (GEN_INT (-size)));\n+      else if (size <= 8192)\n+\t{\n+\t  insn = emit_insn (gen_stack_pointer_inc (GEN_INT (-4096)));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  insn = emit_insn (gen_stack_pointer_inc (GEN_INT (4096 - size)));\n+\t}\n+      else\n+\t{\n+\t  rtx reg = gen_rtx_REG (Pmode, 1);\n+\t  emit_move_insn (reg, GEN_INT (-size));\n+\t  insn = emit_insn (gen_stack_pointer_inc (reg));\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR,\n+\t\t\tgen_stack_pointer_inc (GEN_INT (-size)));\n+\t}\n+\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  /* Make sure nothing is scheduled until after the frame is established.  */\n+  emit_insn (gen_blockage ());\n+\n+  if (frame_pointer_needed)\n+    {\n+      sparc_frame_base_reg = hard_frame_pointer_rtx;\n+      sparc_frame_base_offset = SPARC_STACK_BIAS;\n+    }\n+  else\n+    {\n+      sparc_frame_base_reg = stack_pointer_rtx;\n+      sparc_frame_base_offset = size + SPARC_STACK_BIAS;\n+    }\n+\n+  if (sparc_n_global_fp_regs > 0)\n+    emit_save_or_restore_global_fp_regs (sparc_frame_base_reg,\n+\t\t\t\t         sparc_frame_base_offset\n+\t\t\t\t\t   - sparc_apparent_frame_size,\n+\t\t\t\t\t SORR_SAVE);\n+\n+  /* Load the GOT register if needed.  */\n+  if (crtl->uses_pic_offset_table)\n+    load_got_register ();\n+\n+  /* Advertise that the data calculated just above are now valid.  */\n+  sparc_prologue_data_valid_p = true;\n }\n \n /* This function generates the assembly code for function entry, which boils\n@@ -4607,7 +4944,8 @@ static void\n sparc_asm_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   /* Check that the assumption we made in sparc_expand_prologue is valid.  */\n-  gcc_assert (sparc_leaf_function_p == current_function_uses_only_leaf_regs);\n+  if (!TARGET_FLAT)\n+    gcc_assert (sparc_leaf_function_p == current_function_uses_only_leaf_regs);\n \n   sparc_output_scratch_registers (file);\n }\n@@ -4616,26 +4954,91 @@ sparc_asm_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n    We emit all the instructions except the return or the call.  */\n \n void\n-sparc_expand_epilogue (void)\n+sparc_expand_epilogue (bool for_eh)\n {\n-  if (num_gfregs)\n-    emit_save_or_restore_regs (SORR_RESTORE);\n+  HOST_WIDE_INT size = sparc_frame_size;\n+\n+  if (sparc_n_global_fp_regs > 0)\n+    emit_save_or_restore_global_fp_regs (sparc_frame_base_reg,\n+\t\t\t\t         sparc_frame_base_offset\n+\t\t\t\t\t   - sparc_apparent_frame_size,\n+\t\t\t\t\t SORR_RESTORE);\n \n-  if (actual_fsize == 0)\n-    /* do nothing.  */ ;\n+  if (size == 0 || for_eh)\n+    ; /* do nothing.  */\n   else if (sparc_leaf_function_p)\n     {\n-      if (actual_fsize <= 4096)\n-\temit_insn (gen_stack_pointer_dec (GEN_INT (- actual_fsize)));\n-      else if (actual_fsize <= 8192)\n+      if (size <= 4096)\n+\temit_insn (gen_stack_pointer_dec (GEN_INT (-size)));\n+      else if (size <= 8192)\n \t{\n \t  emit_insn (gen_stack_pointer_dec (GEN_INT (-4096)));\n-\t  emit_insn (gen_stack_pointer_dec (GEN_INT (4096 - actual_fsize)));\n+\t  emit_insn (gen_stack_pointer_dec (GEN_INT (4096 - size)));\n \t}\n       else\n \t{\n \t  rtx reg = gen_rtx_REG (Pmode, 1);\n-\t  emit_move_insn (reg, GEN_INT (-actual_fsize));\n+\t  emit_move_insn (reg, GEN_INT (-size));\n+\t  emit_insn (gen_stack_pointer_dec (reg));\n+\t}\n+    }\n+}\n+\n+/* Expand the function epilogue, either normal or part of a sibcall.\n+   We emit all the instructions except the return or the call.  */\n+\n+void\n+sparc_flat_expand_epilogue (bool for_eh)\n+{\n+  HOST_WIDE_INT size = sparc_frame_size;\n+\n+  if (sparc_n_global_fp_regs > 0)\n+    emit_save_or_restore_global_fp_regs (sparc_frame_base_reg,\n+\t\t\t\t         sparc_frame_base_offset\n+\t\t\t\t\t   - sparc_apparent_frame_size,\n+\t\t\t\t\t SORR_RESTORE);\n+\n+  /* If we have a frame pointer, we'll need both to restore it before the\n+     frame is destroyed and use its current value in destroying the frame.\n+     Since we don't have an atomic way to do that in the flat window model,\n+     we save the current value into a temporary register (%g1).  */\n+  if (frame_pointer_needed && !for_eh)\n+    emit_move_insn (gen_rtx_REG (Pmode, 1), hard_frame_pointer_rtx);\n+\n+  if (return_addr_reg_needed_p (sparc_leaf_function_p))\n+    emit_move_insn (gen_rtx_REG (Pmode, INCOMING_RETURN_ADDR_REGNUM),\n+\t\t    gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM));\n+\n+  if (sparc_save_local_in_regs_p)\n+    emit_save_or_restore_local_in_regs (sparc_frame_base_reg,\n+\t\t\t\t\tsparc_frame_base_offset,\n+\t\t\t\t\tSORR_RESTORE);\n+\n+  if (size == 0 || for_eh)\n+    ; /* do nothing.  */\n+  else if (frame_pointer_needed)\n+    {\n+      /* Make sure the frame is destroyed after everything else is done.  */\n+      emit_insn (gen_blockage ());\n+\n+      emit_move_insn (stack_pointer_rtx, gen_rtx_REG (Pmode, 1));\n+    }\n+  else\n+    {\n+      /* Likewise.  */\n+      emit_insn (gen_blockage ());\n+\n+      if (size <= 4096)\n+\temit_insn (gen_stack_pointer_dec (GEN_INT (-size)));\n+      else if (size <= 8192)\n+\t{\n+\t  emit_insn (gen_stack_pointer_dec (GEN_INT (-4096)));\n+\t  emit_insn (gen_stack_pointer_dec (GEN_INT (4096 - size)));\n+\t}\n+      else\n+\t{\n+\t  rtx reg = gen_rtx_REG (Pmode, 1);\n+\t  emit_move_insn (reg, GEN_INT (-size));\n \t  emit_insn (gen_stack_pointer_dec (reg));\n \t}\n     }\n@@ -4648,8 +5051,10 @@ bool\n sparc_can_use_return_insn_p (void)\n {\n   return sparc_prologue_data_valid_p\n-\t && num_gfregs == 0\n-\t && (actual_fsize == 0 || !sparc_leaf_function_p);\n+\t && sparc_n_global_fp_regs == 0\n+\t && TARGET_FLAT\n+\t    ? (sparc_frame_size == 0 && !sparc_save_local_in_regs_p)\n+\t    : (sparc_frame_size == 0 || !sparc_leaf_function_p);\n }\n \n /* This function generates the assembly code for function exit.  */\n@@ -4728,15 +5133,42 @@ output_restore (rtx pat)\n const char *\n output_return (rtx insn)\n {\n-  if (sparc_leaf_function_p)\n+  if (crtl->calls_eh_return)\n+    {\n+      /* If the function uses __builtin_eh_return, the eh_return\n+\t machinery occupies the delay slot.  */\n+      gcc_assert (!final_sequence);\n+\n+      if (flag_delayed_branch)\n+\t{\n+\t  if (!TARGET_FLAT && TARGET_V9)\n+\t    fputs (\"\\treturn\\t%i7+8\\n\", asm_out_file);\n+\t  else\n+\t    {\n+\t      if (!TARGET_FLAT)\n+\t\tfputs (\"\\trestore\\n\", asm_out_file);\n+\n+\t      fputs (\"\\tjmp\\t%o7+8\\n\", asm_out_file);\n+\t    }\n+\n+\t  fputs (\"\\t add\\t%sp, %g1, %sp\\n\", asm_out_file);\n+\t}\n+      else\n+\t{\n+\t  if (!TARGET_FLAT)\n+\t    fputs (\"\\trestore\\n\", asm_out_file);\n+\n+\t  fputs (\"\\tadd\\t%sp, %g1, %sp\\n\", asm_out_file);\n+\t  fputs (\"\\tjmp\\t%o7+8\\n\\t nop\\n\", asm_out_file);\n+\t}\n+    }\n+  else if (sparc_leaf_function_p || TARGET_FLAT)\n     {\n-      /* This is a leaf function so we don't have to bother restoring the\n-\t register window, which frees us from dealing with the convoluted\n+      /* This is a leaf or flat function so we don't have to bother restoring\n+\t the register window, which frees us from dealing with the convoluted\n \t semantics of restore/return.  We simply output the jump to the\n \t return address and the insn in the delay slot (if any).  */\n \n-      gcc_assert (! crtl->calls_eh_return);\n-\n       return \"jmp\\t%%o7+%)%#\";\n     }\n   else\n@@ -4746,28 +5178,7 @@ output_return (rtx insn)\n \t combined with the 'restore' instruction or put in the delay slot of\n \t the 'return' instruction.  */\n \n-      if (crtl->calls_eh_return)\n-\t{\n-\t  /* If the function uses __builtin_eh_return, the eh_return\n-\t     machinery occupies the delay slot.  */\n-\t  gcc_assert (! final_sequence);\n-\n-          if (flag_delayed_branch)\n-\t    {\n-\t      if (TARGET_V9)\n-\t\tfputs (\"\\treturn\\t%i7+8\\n\", asm_out_file);\n-\t      else\n-\t\tfputs (\"\\trestore\\n\\tjmp\\t%o7+8\\n\", asm_out_file);\n-\n-\t      fputs (\"\\t add\\t%sp, %g1, %sp\\n\", asm_out_file);\n-\t    }\n-\t  else\n-\t    {\n-\t      fputs (\"\\trestore\\n\\tadd\\t%sp, %g1, %sp\\n\", asm_out_file);\n-\t      fputs (\"\\tjmp\\t%o7+8\\n\\t nop\\n\", asm_out_file);\n-\t    }\n-\t}\n-      else if (final_sequence)\n+      if (final_sequence)\n \t{\n \t  rtx delay, pat;\n \n@@ -4815,10 +5226,10 @@ output_sibcall (rtx insn, rtx call_operand)\n \n   operands[0] = call_operand;\n \n-  if (sparc_leaf_function_p)\n+  if (sparc_leaf_function_p || TARGET_FLAT)\n     {\n-      /* This is a leaf function so we don't have to bother restoring the\n-\t register window.  We simply output the jump to the function and\n+      /* This is a leaf or flat function so we don't have to bother restoring\n+\t the register window.  We simply output the jump to the function and\n \t the insn in the delay slot (if any).  */\n \n       gcc_assert (!(LEAF_SIBCALL_SLOT_RESERVED_P && final_sequence));\n@@ -9352,7 +9763,13 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   emit_note (NOTE_INSN_PROLOGUE_END);\n \n-  if (flag_delayed_branch)\n+  if (TARGET_FLAT)\n+    {\n+      sparc_leaf_function_p = 1;\n+\n+      int_arg_first = SPARC_OUTGOING_INT_ARG_FIRST;\n+    }\n+  else if (flag_delayed_branch)\n     {\n       /* We will emit a regular sibcall below, so we need to instruct\n \t output_sibcall that we are in a leaf function.  */\n@@ -9473,8 +9890,6 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n         {\n \t  spill_reg = gen_rtx_REG (word_mode, 15);  /* %o7 */\n \t  start_sequence ();\n-\t  /* Delay emitting the GOT helper function because it needs to\n-\t     change the section and we are emitting assembly code.  */\n \t  load_got_register ();  /* clobbers %o7 */\n \t  scratch = sparc_legitimize_pic_address (funexp, scratch);\n \t  seq = get_insns ();\n@@ -9593,8 +10008,10 @@ get_some_local_dynamic_name_1 (rtx *px, void *data ATTRIBUTE_UNUSED)\n }\n \n /* Handle the TARGET_DWARF_HANDLE_FRAME_UNSPEC hook.\n+\n    This is called from dwarf2out.c to emit call frame instructions\n-   for frame-related insns containing UNSPECs and UNSPEC_VOLATILEs. */\n+   for frame-related insns containing UNSPECs and UNSPEC_VOLATILEs.  */\n+\n static void\n sparc_dwarf_handle_frame_unspec (const char *label,\n \t\t\t\t rtx pattern ATTRIBUTE_UNUSED,\n@@ -9810,6 +10227,16 @@ sparc_expand_compare_and_swap_12 (rtx result, rtx mem, rtx oldval, rtx newval)\n static bool\n sparc_frame_pointer_required (void)\n {\n+  /* If the stack pointer is dynamically modified in the function, it cannot\n+     serve as the frame pointer.  */\n+  if (cfun->calls_alloca)\n+    return true;\n+\n+  /* In flat mode, that's it.  */\n+  if (TARGET_FLAT)\n+    return false;\n+\n+  /* Otherwise, the frame pointer is required if the function isn't leaf.  */\n   return !(current_function_is_leaf && only_leaf_regs_used ());\n }\n \n@@ -9880,6 +10307,14 @@ sparc_conditional_register_usage (void)\n     fixed_regs[4] = 1;\n   else if (fixed_regs[4] == 2)\n     fixed_regs[4] = 0;\n+  if (TARGET_FLAT)\n+    {\n+      int regno;\n+      /* Disable leaf functions.  */\n+      memset (sparc_leaf_regs, 0, FIRST_PSEUDO_REGISTER);\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\tleaf_reg_remap [regno] = regno;\n+    }\n }\n \n /* Implement TARGET_PREFERRED_RELOAD_CLASS"}, {"sha": "8f3ace32c1156e3073017515b416497be542e3ee", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 40, "deletions": 36, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -360,7 +360,6 @@ extern enum cmodel sparc_cmodel;\n /* Common CPP definitions used by CPP_SPEC amongst the various targets\n    for handling -mcpu=xxx switches.  */\n #define CPP_CPU_SPEC \"\\\n-%{msoft-float:-D_SOFT_FLOAT} \\\n %{mcpu=sparclet:-D__sparclet__} %{mcpu=tsc701:-D__sparclet__} \\\n %{mcpu=sparclite:-D__sparclite__} \\\n %{mcpu=f930:-D__sparclite__} %{mcpu=f934:-D__sparclite__} \\\n@@ -388,14 +387,18 @@ extern enum cmodel sparc_cmodel;\n %{!m32:%{!m64:%(cpp_arch_default)}} \\\n \"\n \n-/* Macro to distinguish endianness.  */\n-#define CPP_ENDIAN_SPEC \"\\\n-%{mlittle-endian:-D__LITTLE_ENDIAN__}\"\n+/* Macros to distinguish the endianness, window model and FP support.  */\n+#define CPP_OTHER_SPEC \"\\\n+%{mlittle-endian:-D__LITTLE_ENDIAN__} \\\n+%{mflat:-D_FLAT} \\\n+%{msoft-float:-D_SOFT_FLOAT} \\\n+\"\n \n /* Macros to distinguish the particular subtarget.  */\n #define CPP_SUBTARGET_SPEC \"\"\n \n-#define CPP_SPEC \"%(cpp_cpu) %(cpp_arch) %(cpp_endian) %(cpp_subtarget)\"\n+#define CPP_SPEC \\\n+  \"%(cpp_cpu) %(cpp_arch) %(cpp_endian) %(cpp_other) %(cpp_subtarget)\"\n \n /* This used to translate -dalign to -malign, but that is no good\n    because it can't turn off the usual meaning of making debugging dumps.  */\n@@ -464,7 +467,7 @@ extern enum cmodel sparc_cmodel;\n   { \"cpp_arch64\",\tCPP_ARCH64_SPEC },\t\\\n   { \"cpp_arch_default\",\tCPP_ARCH_DEFAULT_SPEC },\\\n   { \"cpp_arch\",\t\tCPP_ARCH_SPEC },\t\\\n-  { \"cpp_endian\",\tCPP_ENDIAN_SPEC },\t\\\n+  { \"cpp_other\",\tCPP_OTHER_SPEC },\t\\\n   { \"cpp_subtarget\",\tCPP_SUBTARGET_SPEC },\t\\\n   { \"asm_cpu\",\t\tASM_CPU_SPEC },\t\t\\\n   { \"asm_cpu_default\",\tASM_CPU_DEFAULT_SPEC },\t\\\n@@ -687,7 +690,7 @@ extern enum cmodel sparc_cmodel;\n \n /* Argument passing regs.  */\n #define SPARC_OUTGOING_INT_ARG_FIRST 8\n-#define SPARC_INCOMING_INT_ARG_FIRST 24\n+#define SPARC_INCOMING_INT_ARG_FIRST (TARGET_FLAT ? 8 : 24)\n #define SPARC_FP_ARG_FIRST           32\n \n /* 1 for registers that have pervasive standard uses\n@@ -721,7 +724,7 @@ extern enum cmodel sparc_cmodel;\n  {1, 0, 2, 2, 2, 2, 1, 1,\t\\\n   0, 0, 0, 0, 0, 0, 1, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 1,\t\\\n \t\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n@@ -746,7 +749,7 @@ extern enum cmodel sparc_cmodel;\n  {1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n+  0, 0, 0, 0, 0, 0, 0, 1,\t\\\n \t\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n   1, 1, 1, 1, 1, 1, 1, 1,\t\\\n@@ -1223,13 +1226,11 @@ extern char leaf_reg_remap[];\n   {{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}, \\\n    { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM} }\n \n-/* We always pretend that this is a leaf function because if it's not,\n-   there's no point in trying to eliminate the frame pointer.  If it\n-   is a leaf function, we guessed right!  */\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     if ((TO) == STACK_POINTER_REGNUM)\t\t\t\t\t\\\n-      (OFFSET) = sparc_compute_frame_size (get_frame_size (), 1);\t\\\n+      (OFFSET) = sparc_compute_frame_size (get_frame_size (),\t\t\\\n+\t\t\t\t\t   current_function_is_leaf);\t\\\n     else\t\t\t\t\t\t\t\t\\\n       (OFFSET) = 0;\t\t\t\t\t\t\t\\\n     (OFFSET) += SPARC_STACK_BIAS;\t\t\t\t\t\\\n@@ -1247,22 +1248,22 @@ extern char leaf_reg_remap[];\n    Return OUT if register number OUT is not an outbound register.  */\n \n #define INCOMING_REGNO(OUT) \\\n- (((OUT) < 8 || (OUT) > 15) ? (OUT) : (OUT) + 16)\n+ ((TARGET_FLAT || (OUT) < 8 || (OUT) > 15) ? (OUT) : (OUT) + 16)\n \n /* Define this macro if the target machine has \"register windows\".  This\n    C expression returns the register number as seen by the calling function\n    corresponding to register number IN as seen by the called function.\n    Return IN if register number IN is not an inbound register.  */\n \n #define OUTGOING_REGNO(IN) \\\n- (((IN) < 24 || (IN) > 31) ? (IN) : (IN) - 16)\n+ ((TARGET_FLAT || (IN) < 24 || (IN) > 31) ? (IN) : (IN) - 16)\n \n /* Define this macro if the target machine has register windows.  This\n    C expression returns true if the register is call-saved but is in the\n    register window.  */\n \n #define LOCAL_REGNO(REGNO) \\\n-  ((REGNO) >= 16 && (REGNO) <= 31)\n+  (!TARGET_FLAT && (REGNO) >= 16 && (REGNO) <= 31)\n \n /* Define the size of space to allocate for the return value of an\n    untyped_call.  */\n@@ -1373,35 +1374,27 @@ do {\t\t\t\t\t\t\t\t\t\\\n \f\n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n+   functions that have frame pointers.  */\n+#define EXIT_IGNORE_STACK 1\n \n-#define EXIT_IGNORE_STACK\t\\\n- (get_frame_size () != 0\t\\\n-  || cfun->calls_alloca || crtl->outgoing_args_size)\n-\n-/* Define registers used by the epilogue and return instruction.  */\n-#define EPILOGUE_USES(REGNO) ((REGNO) == 31 \\\n-  || (crtl->calls_eh_return && (REGNO) == 1))\n-\f\n /* We need 2 words, so we can save the stack pointer and the return register\n    of the function containing a non-local goto target.  */\n-\n #define STACK_SAVEAREA_MODE(LEVEL) \\\n   ((LEVEL) == SAVE_NONLOCAL ? (TARGET_ARCH64 ? TImode : DImode) : Pmode)\n \n /* Length in units of the trampoline for entering a nested function.  */\n-\n #define TRAMPOLINE_SIZE (TARGET_ARCH64 ? 32 : 16)\n \n /* Alignment required for trampolines, in bits.  */\n-\n #define TRAMPOLINE_ALIGNMENT 128\n \f\n /* Generate RTL to flush the register windows so as to make arbitrary frames\n    available.  */\n-#define SETUP_FRAME_ADDRESSES()\t\t\\\n-  emit_insn (gen_flush_register_windows ())\n+#define SETUP_FRAME_ADDRESSES()\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    if (!TARGET_FLAT)\t\t\t\t\\\n+      emit_insn (gen_flush_register_windows ());\\\n+  } while (0)\n \n /* Given an rtx for the address of a frame,\n    return an rtx for the address of the word in the frame\n@@ -1428,9 +1421,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n    farther back is in the register window save area at [%fp+60].  */\n /* ??? This ignores the fact that the actual return address is +8 for normal\n    returns, and +12 for structure returns.  */\n+#define RETURN_ADDR_REGNUM 31\n #define RETURN_ADDR_RTX(count, frame)\t\t\\\n   ((count == -1)\t\t\t\t\\\n-   ? gen_rtx_REG (Pmode, 31)\t\t\t\\\n+   ? gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM)\t\t\t\\\n    : gen_rtx_MEM (Pmode,\t\t\t\\\n \t\t  memory_address (Pmode, plus_constant (frame, \\\n \t\t\t\t\t\t\t15 * UNITS_PER_WORD \\\n@@ -1440,19 +1434,29 @@ do {\t\t\t\t\t\t\t\t\t\\\n    +12, but always using +8 is close enough for frame unwind purposes.\n    Actually, just using %o7 is close enough for unwinding, but %o7+8\n    is something you can return to.  */\n+#define INCOMING_RETURN_ADDR_REGNUM 15\n #define INCOMING_RETURN_ADDR_RTX \\\n-  plus_constant (gen_rtx_REG (word_mode, 15), 8)\n-#define DWARF_FRAME_RETURN_COLUMN\tDWARF_FRAME_REGNUM (15)\n+  plus_constant (gen_rtx_REG (word_mode, INCOMING_RETURN_ADDR_REGNUM), 8)\n+#define DWARF_FRAME_RETURN_COLUMN \\\n+  DWARF_FRAME_REGNUM (INCOMING_RETURN_ADDR_REGNUM)\n \n /* The offset from the incoming value of %sp to the top of the stack frame\n    for the current function.  On sparc64, we have to account for the stack\n    bias if present.  */\n #define INCOMING_FRAME_SP_OFFSET SPARC_STACK_BIAS\n \n /* Describe how we implement __builtin_eh_return.  */\n+#define EH_RETURN_REGNUM 1\n #define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + 24 : INVALID_REGNUM)\n-#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, 1)\t/* %g1 */\n-#define EH_RETURN_HANDLER_RTX\tgen_rtx_REG (Pmode, 31)\t/* %i7 */\n+#define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, EH_RETURN_REGNUM)\n+\n+/* Define registers used by the epilogue and return instruction.  */\n+#define EPILOGUE_USES(REGNO)\t\t\t\t\t\\\n+  ((REGNO) == RETURN_ADDR_REGNUM\t\t\t\t\\\n+   || (TARGET_FLAT\t\t\t\t\t\t\\\n+       && epilogue_completed\t\t\t\t\t\\\n+       && (REGNO) == INCOMING_RETURN_ADDR_REGNUM)\t\t\\\n+   || (crtl->calls_eh_return && (REGNO) == EH_RETURN_REGNUM))\n \n /* Select a format to encode pointers in exception handling data.  CODE\n    is 0 for data, 1 for code labels, 2 for function pointers.  GLOBAL is"}, {"sha": "acf317d46bd512aea86f08decbf49d8af5b45799", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 88, "deletions": 16, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -164,7 +164,7 @@\n (define_attr \"calls_eh_return\" \"false,true\"\n    (symbol_ref \"(crtl->calls_eh_return != 0\n \t\t ? CALLS_EH_RETURN_TRUE : CALLS_EH_RETURN_FALSE)\"))\n-   \n+\n (define_attr \"leaf_function\" \"false,true\"\n   (symbol_ref \"(current_function_uses_only_leaf_regs != 0\n \t\t? LEAF_FUNCTION_TRUE : LEAF_FUNCTION_FALSE)\"))\n@@ -173,6 +173,10 @@\n   (symbol_ref \"(flag_delayed_branch != 0\n \t\t? DELAYED_BRANCH_TRUE : DELAYED_BRANCH_FALSE)\"))\n \n+(define_attr \"flat\" \"false,true\"\n+  (symbol_ref \"(TARGET_FLAT != 0\n+\t\t? FLAT_TRUE : FLAT_FALSE)\"))\n+\n ;; Length (in # of insns).\n ;; Beware that setting a length greater or equal to 3 for conditional branches\n ;; has a side-effect (see output_cbranch and output_v9branch).\n@@ -6265,7 +6269,10 @@\n   [(const_int 0)]\n   \"\"\n {\n-  sparc_expand_prologue ();\n+  if (TARGET_FLAT)\n+    sparc_flat_expand_prologue ();\n+  else\n+    sparc_expand_prologue ();\n   DONE;\n })\n \n@@ -6282,25 +6289,87 @@\n    (set (reg:P 14) (unspec_volatile:P [(reg:P 14)\n \t\t\t\t       (match_operand:P 0 \"arith_operand\" \"rI\")] UNSPECV_SAVEW))\n    (set (reg:P 31) (reg:P 15))]\n-  \"\"\n+  \"!TARGET_FLAT\"\n   \"save\\t%%sp, %0, %%sp\"\n   [(set_attr \"type\" \"savew\")])\n \n+;; Likewise for the \"create flat frame\" insns.  We need to use special insns\n+;; because %fp cannot be clobbered until after the frame is established (so\n+;; that it contains the live register window save area) and %i7 changed with\n+;; a simple move as it is a fixed register and the move would be eliminated.\n+\n+(define_insn \"create_flat_frame_1<P:mode>\"\n+  [(set (reg:P 30) (reg:P 14))\n+   (set (reg:P 14) (plus:P (reg:P 14)\n+\t\t\t   (match_operand:P 0 \"arith_operand\" \"rI\")))\n+   (set (reg:P 31) (reg:P 15))]\n+  \"TARGET_FLAT\"\n+  \"add\\t%%sp, %0, %%sp\\n\\tsub\\t%%sp, %0, %%fp\\n\\tmov\\t%%o7, %%i7\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"3\")])\n+\n+(define_insn \"create_flat_frame_2<P:mode>\"\n+  [(set (reg:P 30) (reg:P 14))\n+   (set (reg:P 14) (plus:P (reg:P 14)\n+\t\t           (match_operand:P 0 \"arith_operand\" \"rI\")))]\n+  \"TARGET_FLAT\"\n+  \"add\\t%%sp, %0, %%sp\\n\\tsub\\t%%sp, %0, %%fp\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"create_flat_frame_3<P:mode>\"\n+  [(set (reg:P 14) (plus:P (reg:P 14)\n+\t\t           (match_operand:P 0 \"arith_operand\" \"rI\")))\n+   (set (reg:P 31) (reg:P 15))]\n+  \"TARGET_FLAT\"\n+  \"add\\t%%sp, %0, %%sp\\n\\tmov\\t%%o7, %%i7\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"2\")])\n+\n (define_expand \"epilogue\"\n   [(return)]\n   \"\"\n {\n-  sparc_expand_epilogue ();\n+  if (TARGET_FLAT)\n+    sparc_flat_expand_epilogue (false);\n+  else\n+    sparc_expand_epilogue (false);\n })\n \n (define_expand \"sibcall_epilogue\"\n   [(return)]\n   \"\"\n {\n-  sparc_expand_epilogue ();\n+  if (TARGET_FLAT)\n+    sparc_flat_expand_epilogue (false);\n+  else\n+    sparc_expand_epilogue (false);\n+  DONE;\n+})\n+\n+(define_expand \"eh_return\"\n+  [(use (match_operand 0 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  emit_move_insn (gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM), operands[0]);\n+  emit_jump_insn (gen_eh_return_internal ());\n+  emit_barrier ();\n   DONE;\n })\n \n+(define_insn_and_split \"eh_return_internal\"\n+  [(eh_return)]\n+  \"\"\n+  \"#\"\n+  \"epilogue_completed\"\n+  [(return)]\n+{\n+  if (TARGET_FLAT)\n+    sparc_flat_expand_epilogue (true);\n+  else\n+    sparc_expand_epilogue (true);\n+})\n+\n (define_expand \"return\"\n   [(return)]\n   \"sparc_can_use_return_insn_p ()\"\n@@ -6312,16 +6381,19 @@\n   \"* return output_return (insn);\"\n   [(set_attr \"type\" \"return\")\n    (set (attr \"length\")\n-\t(cond [(eq_attr \"leaf_function\" \"true\")\n+\t(cond [(eq_attr \"calls_eh_return\" \"true\")\n+\t         (if_then_else (eq_attr \"delayed_branch\" \"true\")\n+\t\t\t\t(if_then_else (ior (eq_attr \"isa\" \"v9\")\n+\t\t\t\t\t\t   (eq_attr \"flat\" \"true\"))\n+\t\t\t\t\t(const_int 2)\n+\t\t\t\t\t(const_int 3))\n+\t\t\t\t(if_then_else (eq_attr \"flat\" \"true\")\n+\t\t\t\t\t(const_int 3)\n+\t\t\t\t\t(const_int 4)))\n+\t       (ior (eq_attr \"leaf_function\" \"true\") (eq_attr \"flat\" \"true\"))\n \t\t (if_then_else (eq_attr \"empty_delay_slot\" \"true\")\n \t\t\t       (const_int 2)\n \t\t\t       (const_int 1))\n-\t       (eq_attr \"calls_eh_return\" \"true\")\n-\t\t (if_then_else (eq_attr \"delayed_branch\" \"true\")\n-\t\t\t       (if_then_else (eq_attr \"isa\" \"v9\")\n-\t\t\t\t\t     (const_int 2)\n-\t\t\t\t\t     (const_int 3))\n-\t\t\t       (const_int 4))\n \t       (eq_attr \"empty_delay_slot\" \"true\")\n \t\t (if_then_else (eq_attr \"delayed_branch\" \"true\")\n \t\t\t       (const_int 2)\n@@ -6367,8 +6439,7 @@\n \n   if (! TARGET_ARCH64)\n     {\n-      rtx rtnreg = gen_rtx_REG (SImode, (current_function_uses_only_leaf_regs\n-\t\t\t\t\t ? 15 : 31));\n+      rtx rtnreg = gen_rtx_REG (SImode, RETURN_ADDR_REGNUM);\n       rtx value = gen_reg_rtx (SImode);\n \n       /* Fetch the instruction where we will return to and see if it's an unimp\n@@ -6449,7 +6520,7 @@\n {\n   operands[0] = adjust_address_nv (operands[0], Pmode, 0);\n   operands[2] = adjust_address_nv (operands[0], Pmode, GET_MODE_SIZE (Pmode));\n-  operands[3] = gen_rtx_REG (Pmode, 31); /* %i7 */\n+  operands[3] = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n })\n \n (define_expand \"restore_stack_nonlocal\"\n@@ -6474,7 +6545,8 @@\n \n   /* We need to flush all the register windows so that their contents will\n      be re-synchronized by the restore insn of the target function.  */\n-  emit_insn (gen_flush_register_windows ());\n+  if (!TARGET_FLAT)\n+    emit_insn (gen_flush_register_windows ());\n \n   emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));\n   emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));"}, {"sha": "d729214d3c49c0bfd9bf2a2974d9bbfd06801ac2", "filename": "gcc/config/sparc/sparc.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.opt?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -33,6 +33,10 @@ msoft-float\n Target RejectNegative InverseMask(FPU)\n Do not use hardware FP\n \n+mflat\n+Target Report Mask(FLAT)\n+Use flat register window model\n+\n munaligned-doubles\n Target Report Mask(UNALIGNED_DOUBLES)\n Assume possible double misalignment"}, {"sha": "962d0009f9bada5c64374acf4ca5747a50a47105", "filename": "gcc/config/sparc/t-elf", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fconfig%2Fsparc%2Ft-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fconfig%2Fsparc%2Ft-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Ft-elf?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -32,8 +32,8 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \techo '#define FLOAT' > fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n \n-MULTILIB_OPTIONS = msoft-float mcpu=v8\n-MULTILIB_DIRNAMES = soft v8\n+MULTILIB_OPTIONS = msoft-float mcpu=v8 mflat\n+MULTILIB_DIRNAMES = soft v8 flat\n MULTILIB_MATCHES = msoft-float=mno-fpu\n \n LIBGCC = stmp-multilib"}, {"sha": "e3ab3bc98933d23ba7669b347a8611f05702c1cb", "filename": "gcc/config/sparc/t-leon", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fconfig%2Fsparc%2Ft-leon", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fconfig%2Fsparc%2Ft-leon", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Ft-leon?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -34,8 +34,8 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n # Multilibs for LEON\n # LEON is a SPARC-V8, but the AT697 implementation has a bug in the\n # V8-specific instructions.\n-MULTILIB_OPTIONS = mcpu=v7 msoft-float\n-MULTILIB_DIRNAMES = v7 soft\n+MULTILIB_OPTIONS = mcpu=v7 msoft-float mflat\n+MULTILIB_DIRNAMES = v7 soft flat\n MULTILIB_MATCHES = mcpu?v7=mv7 msoft-float=mno-fpu\n \n LIBGCC = stmp-multilib"}, {"sha": "fee3a2f6356d9e8185b0792b4fadf0d69db653e0", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -863,7 +863,7 @@ See RS/6000 and PowerPC Options.\n -mtune=@var{cpu-type} @gol\n -mcmodel=@var{code-model} @gol\n -m32  -m64  -mapp-regs  -mno-app-regs @gol\n--mfaster-structs  -mno-faster-structs @gol\n+-mfaster-structs  -mno-faster-structs  -mflat  -mno-flat @gol\n -mfpu  -mno-fpu  -mhard-float  -msoft-float @gol\n -mhard-quad-float  -msoft-quad-float @gol\n -mlittle-endian @gol\n@@ -17043,6 +17043,19 @@ To be fully SVR4 ABI compliant at the cost of some performance loss,\n specify @option{-mno-app-regs}.  You should compile libraries and system\n software with this option.\n \n+@item -mflat\n+@itemx -mno-flat\n+@opindex mflat\n+@opindex mno-flat\n+With @option{-mflat}, the compiler does not generate save/restore instructions\n+and uses a ``flat'' or single register window model.  This model is compatible\n+with the regular register window model.  The local registers and the input\n+registers (0--5) are still treated as ``call-saved'' registers and will be\n+saved on the stack as needed.\n+\n+With @option{-mno-flat} (the default), the compiler generates save/restore\n+instructions (except for leaf functions).  This is the normal operating mode.\n+\n @item -mfpu\n @itemx -mhard-float\n @opindex mfpu"}, {"sha": "31f5d1e65c8975da15c7c868625406d69c22f16a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -1,3 +1,9 @@\n+2011-06-10  Eric Botcazou  <ebotcazou@adacore.com>\n+\t    Laurent Roug\ufffd  <laurent.rouge@menta.fr>\n+\n+\t* gcc.dg/20020503-1.c: Add back -mflat option on the SPARC.\n+\t* gcc.target/sparc/sparc-ret.c: Skip if -mflat is passed.\n+\n 2011-06-10  Daniel Carrera  <dcarrera@gmail.com>\n \n \t* gfortran.dg/coarray/sync_1.f90: New test for"}, {"sha": "e13cf954efb7a6504e9077ee5f93f4dbf3336413", "filename": "gcc/testsuite/gcc.dg/20020503-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Ftestsuite%2Fgcc.dg%2F20020503-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Ftestsuite%2Fgcc.dg%2F20020503-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020503-1.c?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -4,7 +4,7 @@\n    for leaf functions, the function was still leaf, but LEAF_REG_REMAP\n    returned -1 for some registers (like %o0).  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -g\" } */\n+/* { dg-options \"-O2 -g -mflat\" { target sparc*-*-* } } */\n \n void foo (char *a, char *b, char *c, char *d)\n {"}, {"sha": "f58b059e5aa4a529c4f3ab603fbea19c56e3672a", "filename": "gcc/testsuite/gcc.target/sparc/sparc-ret.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsparc-ret.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsparc-ret.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fsparc-ret.c?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -1,4 +1,5 @@\n /* { dg-do compile } */\n+/* { dg-skip-if \"no register windows\" { *-*-* } { \"-mflat\" } { \"\" } } */\n /* { dg-require-effective-target ilp32 } */\n /* { dg-options \"-mcpu=ultrasparc -O\" } */\n \n@@ -11,7 +12,7 @@ int bar (int a, int b, int c, int d, int e, int f, int g, int h)\n   toto (&res);\n   return h;\n }\n-/* { dg-final { global compiler_flags; if ![string match \"*-m64 *\" $compiler_flags] { scan-assembler \"return\\[ \\t\\]*%i7\\\\+8\\n\\[^\\n\\]*ld\\[ \\t\\]*\\\\\\[%sp\\\\+96\\\\\\]\" } } } */\n+/* { dg-final { scan-assembler \"return\\[ \\t\\]*%i7\\\\+8\\n\\[^\\n\\]*ld\\[ \\t\\]*\\\\\\[%sp\\\\+96\\\\\\]\" } } */\n \n int bar2 ()\n {\n@@ -20,4 +21,4 @@ int bar2 ()\n   toto (&res);\n   return res;\n }\n-/* { dg-final { global compiler_flags; if ![string match \"*-m64 *\" $compiler_flags] { scan-assembler \"return\\[ \\t\\]*%i7\\\\+8\\n\\[^\\n\\]*nop\" } } } */\n+/* { dg-final { scan-assembler \"return\\[ \\t\\]*%i7\\\\+8\\n\\[^\\n\\]*nop\" } } */"}, {"sha": "06c7613dd896c87cf846dc7412adc2e0acf85096", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -1,3 +1,12 @@\n+2011-06-10  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/sparc/linux-unwind.h (STACK_BIAS): Define.\n+\t(sparc64_fallback_frame_state): Use it.\n+\t(sparc64_frob_update_context): Further adjust context.\n+\t* config/sparc/sol2-unwind.h (sparc64_frob_update_context): Likewise.\n+\t* config/sparc/sol2-ci.S: Add TARGET_FLAT handling.\n+\t* config/sparc/sol2-cn.S: Likewise.\n+\n 2011-06-09  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* enable-execute-stack-empty.c: New file."}, {"sha": "c5e7f8d9c1584f255b0a294ff80b52e87622a75e", "filename": "libgcc/config/sparc/linux-unwind.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/libgcc%2Fconfig%2Fsparc%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/libgcc%2Fconfig%2Fsparc%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fsparc%2Flinux-unwind.h?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -27,6 +27,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #if defined(__arch64__)\n \n+#undef STACK_BIAS\n+#define STACK_BIAS 2047\n+\n /* 64-bit SPARC version */\n #define MD_FALLBACK_FRAME_STATE_FOR sparc64_fallback_frame_state\n \n@@ -49,7 +52,8 @@ sparc64_fallback_frame_state (struct _Unwind_Context *context,\n   fpu_save_off = regs_off + (16 * 8) + (3 * 8) + (2 * 4);\n \n   new_cfa = *(long *)(this_cfa + regs_off + (14 * 8));\n-  new_cfa += 2047; /* Stack bias */\n+  /* The frame address is %sp + STACK_BIAS in 64-bit mode.  */\n+  new_cfa += STACK_BIAS;\n   fpu_save = *(long *)(this_cfa + fpu_save_off);\n   fs->regs.cfa_how = CFA_REG_OFFSET;\n   fs->regs.cfa_reg = __builtin_dwarf_sp_column ();\n@@ -112,7 +116,16 @@ sparc64_frob_update_context (struct _Unwind_Context *context,\n       && fs->regs.cfa_how == CFA_REG_OFFSET\n       && fs->regs.cfa_offset != 0\n       && !fs->signal_frame)\n-    context->cfa -= 2047;\n+    {\n+      long i;\n+\n+      context->cfa -= STACK_BIAS;\n+\n+      for (i = 0; i < DWARF_FRAME_REGISTERS + 1; ++i)\n+\tif (fs->regs.reg[i].how == REG_SAVED_OFFSET)\n+\t  _Unwind_SetGRPtr (context, i,\n+\t\t\t    _Unwind_GetGRPtr (context, i) - STACK_BIAS);\n+    }\n }\n \n #else"}, {"sha": "a89cc20c86f5e7af34405cf7c79dda013e100313", "filename": "libgcc/config/sparc/sol2-ci.S", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/libgcc%2Fconfig%2Fsparc%2Fsol2-ci.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/libgcc%2Fconfig%2Fsparc%2Fsol2-ci.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fsparc%2Fsol2-ci.S?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -1,6 +1,6 @@\n ! crti.s for solaris 2.0.\n \n-!   Copyright (C) 1992, 2008, 2009 Free Software Foundation, Inc.\n+!   Copyright (C) 1992, 2008, 2009, 2011 Free Software Foundation, Inc.\n !   Written By David Vinayak Henkel-Wallace, June 1992\n ! \n ! This file is free software; you can redistribute it and/or modify it\n@@ -35,11 +35,22 @@\n \t.type\t_init,#function\n \t.align\t4\n _init:\n+#ifdef _FLAT\n+#ifdef __sparcv9\n+\tstx     %i7, [%sp+2167]\n+\tadd\t%sp, -176, %sp\n+#else\n+\tst\t%i7, [%sp+60]\n+\tadd\t%sp, -96, %sp\n+#endif\n+\tmov\t%o7, %i7\n+#else\n #ifdef __sparcv9\n \tsave\t%sp, -176, %sp\n #else\n \tsave\t%sp, -96, %sp\n #endif\n+#endif\n \n \n \t.section\t\".fini\"\n@@ -48,8 +59,19 @@ _init:\n \t.type\t_fini,#function\n \t.align\t4\n _fini:\n+#ifdef _FLAT\n+#ifdef __sparcv9\n+\tstx     %i7, [%sp+2167]\n+\tadd\t%sp, -176, %sp\n+#else\n+\tst      %i7, [%sp+60]\n+\tadd\t%sp, -96, %sp\n+#endif\n+\tmov\t%o7, %i7\n+#else\n #ifdef __sparcv9\n \tsave\t%sp, -176, %sp\n #else\n \tsave\t%sp, -96, %sp\n #endif\n+#endif"}, {"sha": "08862a78e02e07f4f52bfe4d2dd2aee14e94439e", "filename": "libgcc/config/sparc/sol2-cn.S", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/libgcc%2Fconfig%2Fsparc%2Fsol2-cn.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/libgcc%2Fconfig%2Fsparc%2Fsol2-cn.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fsparc%2Fsol2-cn.S?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -1,6 +1,6 @@\n ! crtn.s for solaris 2.0.\n \n-!   Copyright (C) 1992, 2008, 2009 Free Software Foundation, Inc.\n+!   Copyright (C) 1992, 2008, 2009, 2011 Free Software Foundation, Inc.\n !   Written By David Vinayak Henkel-Wallace, June 1992\n ! \n ! This file is free software; you can redistribute it and/or modify it\n@@ -28,14 +28,36 @@\n \n \t.section\t\".init\"\n \t.align\t\t4\n-\n-\tret\n+#ifdef _FLAT\n+\tmov \t%i7, %o7\n+#ifdef __sparcv9\n+\tldx     [%sp+2343], %i7\n+\tsub\t%sp, -176, %sp\n+#else\n+\tld\t[%sp+156], %i7\n+\tsub\t%sp, -96, %sp\n+#endif\n+#else\n \trestore\n+#endif\n+\tjmp\t%o7+8\n+\t nop\n \n \t.section\t\".fini\"\n \t.align\t\t4\n-\n-\tret\n+#ifdef _FLAT\n+\tmov \t%i7, %o7\n+#ifdef __sparcv9\n+\tldx     [%sp+2343], %i7\n+\tsub\t%sp, -176, %sp\n+#else\n+\tld      [%sp+156], %i7\n+\tsub\t%sp, -96, %sp\n+#endif\n+#else\n \trestore\n+#endif\n+\tjmp\t%o7+8\n+\t nop\n \n ! Th-th-th-that is all folks!"}, {"sha": "129405e95ba66be731ac430ff6c24f622d14bd3c", "filename": "libgcc/config/sparc/sol2-unwind.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b11b09048dcd08782578c7c34456e51aa408b1a9/libgcc%2Fconfig%2Fsparc%2Fsol2-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b11b09048dcd08782578c7c34456e51aa408b1a9/libgcc%2Fconfig%2Fsparc%2Fsol2-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fsparc%2Fsol2-unwind.h?ref=b11b09048dcd08782578c7c34456e51aa408b1a9", "patch": "@@ -164,7 +164,16 @@ sparc64_frob_update_context (struct _Unwind_Context *context,\n       && fs->regs.cfa_how == CFA_REG_OFFSET\n       && fs->regs.cfa_offset != 0\n       && !fs->signal_frame)\n-    context->cfa -= STACK_BIAS;\n+    {\n+      long i;\n+\n+      context->cfa -= STACK_BIAS;\n+\n+      for (i = 0; i < DWARF_FRAME_REGISTERS + 1; ++i)\n+\tif (fs->regs.reg[i].how == REG_SAVED_OFFSET)\n+\t  _Unwind_SetGRPtr (context, i,\n+\t\t\t    _Unwind_GetGRPtr (context, i) - STACK_BIAS);\n+    }\n }\n \n #else"}]}