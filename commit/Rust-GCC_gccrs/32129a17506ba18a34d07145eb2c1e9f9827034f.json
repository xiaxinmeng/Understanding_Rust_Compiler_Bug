{"sha": "32129a17506ba18a34d07145eb2c1e9f9827034f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzIxMjlhMTc1MDZiYTE4YTM0ZDA3MTQ1ZWIyYzFlOWY5ODI3MDM0Zg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2017-08-10T13:22:27Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-08-10T13:22:27Z"}, "message": "C/C++: show pertinent open token when missing a close token\n\ngcc/c/ChangeLog:\n\t* c-parser.c (c_parser_error): Rename to...\n\t(c_parser_error_richloc): ...this, making static, and adding\n\t\"richloc\" parameter, passing it to the c_parse_error call,\n\trather than calling c_parser_set_source_position_from_token.\n\t(c_parser_error): Reintroduce, reimplementing in terms of the\n\tabove, converting return type from void to bool.\n\t(class token_pair): New class.\n\t(struct matching_paren_traits): New struct.\n\t(matching_parens): New typedef.\n\t(struct matching_brace_traits): New struct.\n\t(matching_braces): New typedef.\n\t(get_matching_symbol): New function.\n\t(c_parser_require): Add param MATCHING_LOCATION, using it to\n\thighlight matching \"opening\" tokens for missing \"closing\" tokens.\n\t(c_parser_skip_until_found): Likewise.\n\t(c_parser_static_assert_declaration_no_semi): Convert explicit\n\tparsing of CPP_OPEN_PAREN and CPP_CLOSE_PAREN to use of\n\tclass matching_parens, so that the pertinent open parenthesis is\n\thighlighted when there are problems locating the close\n\tparenthesis.\n\t(c_parser_struct_or_union_specifier): Likewise.\n\t(c_parser_typeof_specifier): Likewise.\n\t(c_parser_alignas_specifier): Likewise.\n\t(c_parser_simple_asm_expr): Likewise.\n\t(c_parser_braced_init): Likewise, for matching_braces.\n\t(c_parser_paren_condition): Likewise, for matching_parens.\n\t(c_parser_switch_statement): Likewise.\n\t(c_parser_for_statement): Likewise.\n\t(c_parser_asm_statement): Likewise.\n\t(c_parser_asm_operands): Likewise.\n\t(c_parser_cast_expression): Likewise.\n\t(c_parser_sizeof_expression): Likewise.\n\t(c_parser_alignof_expression): Likewise.\n\t(c_parser_generic_selection): Likewise.\n\t(c_parser_postfix_expression): Likewise for cases RID_VA_ARG,\n\tRID_OFFSETOF, RID_TYPES_COMPATIBLE_P, RID_AT_SELECTOR,\n\tRID_AT_PROTOCOL, RID_AT_ENCODE, reindenting as necessary.\n\tIn case CPP_OPEN_PAREN, pass loc_open_paren to the\n\tc_parser_skip_until_found call.\n\t(c_parser_objc_class_definition): Use class matching_parens as\n\tabove.\n\t(c_parser_objc_method_decl): Likewise.\n\t(c_parser_objc_try_catch_finally_statement): Likewise.\n\t(c_parser_objc_synchronized_statement): Likewise.\n\t(c_parser_objc_at_property_declaration): Likewise.\n\t(c_parser_oacc_wait_list): Likewise.\n\t(c_parser_omp_var_list_parens): Likewise.\n\t(c_parser_omp_clause_collapse): Likewise.\n\t(c_parser_omp_clause_default): Likewise.\n\t(c_parser_omp_clause_if): Likewise.\n\t(c_parser_omp_clause_num_threads): Likewise.\n\t(c_parser_omp_clause_num_tasks): Likewise.\n\t(c_parser_omp_clause_grainsize): Likewise.\n\t(c_parser_omp_clause_priority): Likewise.\n\t(c_parser_omp_clause_hint): Likewise.\n\t(c_parser_omp_clause_defaultmap): Likewise.\n\t(c_parser_oacc_single_int_clause): Likewise.\n\t(c_parser_omp_clause_ordered): Likewise.\n\t(c_parser_omp_clause_reduction): Likewise.\n\t(c_parser_omp_clause_schedule): Likewise.\n\t(c_parser_omp_clause_num_teams): Likewise.\n\t(c_parser_omp_clause_thread_limit): Likewise.\n\t(c_parser_omp_clause_aligned): Likewise.\n\t(c_parser_omp_clause_linear): Likewise.\n\t(c_parser_omp_clause_safelen): Likewise.\n\t(c_parser_omp_clause_simdlen): Likewise.\n\t(c_parser_omp_clause_depend): Likewise.\n\t(c_parser_omp_clause_map): Likewise.\n\t(c_parser_omp_clause_device): Likewise.\n\t(c_parser_omp_clause_dist_schedule): Likewise.\n\t(c_parser_omp_clause_proc_bind): Likewise.\n\t(c_parser_omp_clause_uniform): Likewise.\n\t(c_parser_omp_for_loop): Likewise.\n\t(c_parser_cilk_clause_vectorlength): Likewise.\n\t(c_parser_cilk_clause_linear): Likewise.\n\t(c_parser_transaction_expression): Likewise.\n\t* c-parser.h (c_parser_require): Add param matching_location with\n\tdefault UNKNOWN_LOCATION.\n\t(c_parser_error): Convert return type from void to bool.\n\t(c_parser_skip_until_found): Add param matching_location with\n\tdefault UNKNOWN_LOCATION.\n\ngcc/c-family/ChangeLog:\n\t* c-common.c (c_parse_error): Add rich_location * param, using it\n\trather implicitly using input_location.\n\t* c-common.h (c_parse_error): Add rich_location * param.\n\ngcc/cp/ChangeLog:\n\t* parser.c (cp_parser_error): Update for new param to\n\tc_parse_error.\n\t(class token_pair): New class.\n\t(struct matching_paren_traits): New struct.\n\t(matching_parens): New typedef.\n\t(struct matching_brace_traits): New struct.\n\t(matching_braces): New typedef.\n\t(cp_parser_statement_expr): Convert explicit parsing of\n\tCPP_OPEN_PAREN and CPP_CLOSE_PAREN to use of\n\tclass matching_parens, so that the pertinent open parenthesis is\n\thighlighted when there are problems locating the close\n\tparenthesis.\n\t(cp_parser_primary_expression): Likewise.\n\t(cp_parser_compound_literal_p): Remove consumption of opening\n\tparen.\n\t(cp_parser_postfix_expression): Convert explicit parsing of\n\tCPP_OPEN_PAREN and CPP_CLOSE_PAREN to use matching parens, as\n\tabove.  Use it to consume the opening paren previously consumed by\n\tcp_parser_compound_literal_p.\n\t(cp_parser_parenthesized_expression_list): Likewise.\n\t(cp_parser_unary_expression): Likewise.\n\t(cp_parser_new_expression): Likewise.\n\t(cp_parser_cast_expression): Likewise.\n\t(cp_parser_builtin_offsetof): Likewise.\n\t(cp_parser_trait_expr): Likewise.\n\t(cp_parser_lambda_declarator_opt): Likewise.\n\t(cp_parser_lambda_body): Likewise, for matching_braces.\n\t(cp_parser_compound_statement): Likewise.\n\t(cp_parser_selection_statement): Likewise, for matching_parens.\n\t(cp_parser_iteration_statement): Likewise.\n\t(cp_parser_already_scoped_statement): Likewise, for\n\tmatching_braces.\n\t(cp_parser_linkage_specification): Likewise.\n\t(cp_parser_static_assert): Likewise, for matching_parens.\n\t(cp_parser_decltype): Likewise.\n\t(cp_parser_operator): Likewise.\n\t(cp_parser_enum_specifier): Likewise.\n\t(cp_parser_namespace_definition): Likewise.\n\t(cp_parser_direct_declarator): Likewise.\n\t(cp_parser_braced_list): Likewise.\n\t(cp_parser_class_specifier_1): Likewise, for matching_braces.\n\t(cp_parser_constant_initializer): Likewise.\n\t(cp_parser_noexcept_specification_opt): Likewise, for\n\tmatching_parens.\n\t(cp_parser_exception_specification_opt): Likewise.\n\t(cp_parser_handler): Likewise.\n\t(cp_parser_asm_specification_opt): Likewise.\n\t(cp_parser_asm_operand_list): Likewise.\n\t(cp_parser_gnu_attributes_opt): Likewise.\n\t(cp_parser_std_attribute_spec): Likewise.\n\t(cp_parser_requirement_parameter_list): Likewise.\n\t(cp_parser_requirement_body): Likewise, for matching_braces.\n\t(cp_parser_compound_requirement): Likewise.\n\t(cp_parser_template_introduction): Likewise.\n\t(cp_parser_sizeof_pack): Likewise, for matching_parens.\n\t(cp_parser_sizeof_operand): Likewise; use it to consume the\n\topening paren previously consumed by cp_parser_compound_literal_p.\n\t(get_matching_symbol): New function.\n\t(cp_parser_required_error): Add param \"matching_location\".  Remove\n\tcalls to cp_parser_error, instead setting a non-NULL gmsgid, and\n\thandling it if set by calling c_parse_error, potentially with a\n\tsecondary location if matching_location was set.\n\t(cp_parser_require): Add param \"matching_location\", with a default\n\tvalue of UNKNOWN_LOCATION.\n\t(cp_parser_require_keyword): Update for new param of\n\tcp_parser_required_error.\n\t(cp_parser_objc_encode_expression): Update to class matching_parens\n\tas above.\n\t(cp_parser_objc_defs_expression): Likewise.\n\t(cp_parser_objc_protocol_expression): Likewise.\n\t(cp_parser_objc_selector_expression): Likewise.\n\t(cp_parser_objc_typename): Likewise.\n\t(cp_parser_objc_superclass_or_category): Likewise.\n\t(cp_parser_objc_try_catch_finally_statement): Likewise.\n\t(cp_parser_objc_synchronized_statement): Likewise.\n\t(cp_parser_objc_at_property_declaration): Likewise.\n\t(cp_parser_oacc_single_int_clause): Likewise.\n\t(cp_parser_oacc_shape_clause): Likewise.\n\t(cp_parser_omp_clause_collapse): Likewise.\n\t(cp_parser_omp_clause_default): Likewise.\n\t(cp_parser_omp_clause_final): Likewise.\n\t(cp_parser_omp_clause_if): Likewise.\n\t(cp_parser_omp_clause_num_threads): Likewise.\n\t(cp_parser_omp_clause_num_tasks): Likewise.\n\t(cp_parser_omp_clause_grainsize): Likewise.\n\t(cp_parser_omp_clause_priority): Likewise.\n\t(cp_parser_omp_clause_hint): Likewise.\n\t(cp_parser_omp_clause_defaultmap): Likewise.\n\t(cp_parser_omp_clause_ordered): Likewise.\n\t(cp_parser_omp_clause_schedule): Likewise.\n\t(cp_parser_omp_clause_num_teams): Likewise.\n\t(cp_parser_omp_clause_thread_limit): Likewise.\n\t(cp_parser_omp_clause_aligned): Likewise.\n\t(cp_parser_omp_clause_linear): Likewise.\n\t(cp_parser_omp_clause_safelen): Likewise.\n\t(cp_parser_omp_clause_simdlen): Likewise.\n\t(cp_parser_omp_clause_depend): Likewise.\n\t(cp_parser_omp_clause_device): Likewise.\n\t(cp_parser_omp_clause_dist_schedule): Likewise.\n\t(cp_parser_oacc_clause_async): Likewise.\n\t(cp_parser_omp_critical): Likewise.\n\t(cp_parser_omp_for_loop): Likewise.\n\t(cp_parser_omp_sections_scope): Likewise.\n\t(cp_parser_omp_declare_reduction_exprs): Likewise.\n\tUpdate for new param to cp_parser_required_error.\n\t(cp_parser_oacc_routine): Likewise.\n\t(cp_parser_transaction_expression): Likewise.\n\t(cp_parser_cilk_simd_vectorlength): Likewise.\n\ngcc/testsuite/ChangeLog:\n\t* c-c++-common/missing-close-symbol.c: New test case.\n\t* c-c++-common/missing-symbol.c: New test case.\n\t* gcc.dg/unclosed-init.c: New test case.\n\t* g++.dg/diagnostic/unclosed-extern-c.C: New test case.\n\t* g++.dg/diagnostic/unclosed-function.C: New test case.\n\t* g++.dg/diagnostic/unclosed-namespace.C: New test case.\n\t* g++.dg/diagnostic/unclosed-struct.C: New test case.\n\t* g++.dg/parse/pragma2.C: Update to reflect movement of the\n\t\"expected identifier\" error.\n\nFrom-SVN: r251026", "tree": {"sha": "f8018f92c534466fa12d6791f1df3d201d24df10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8018f92c534466fa12d6791f1df3d201d24df10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32129a17506ba18a34d07145eb2c1e9f9827034f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32129a17506ba18a34d07145eb2c1e9f9827034f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32129a17506ba18a34d07145eb2c1e9f9827034f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32129a17506ba18a34d07145eb2c1e9f9827034f/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7c23ac0d25d2d5f814f53a6357d4c572e48f06d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c23ac0d25d2d5f814f53a6357d4c572e48f06d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c23ac0d25d2d5f814f53a6357d4c572e48f06d3"}], "stats": {"total": 1797, "additions": 1279, "deletions": 518}, "files": [{"sha": "fcb4ea5169b1b19a8ec9c4d44d815ef854962002", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -1,3 +1,9 @@\n+2017-08-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-common.c (c_parse_error): Add rich_location * param, using it\n+\trather implicitly using input_location.\n+\t* c-common.h (c_parse_error): Add rich_location * param.\n+\n 2017-08-09  Marek Polacek  <polacek@redhat.com>\n \n \t* c-common.c (pointer_int_sum): Use true/false instead of 1/0."}, {"sha": "4dc3b338e5e99236daace7c7a69ab2dcb2f5bc77", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -5950,12 +5950,13 @@ catenate_strings (const char *lhs, const char *rhs_start, int rhs_size)\n   return result;\n }\n \n-/* Issue the error given by GMSGID, indicating that it occurred before\n-   TOKEN, which had the associated VALUE.  */\n+/* Issue the error given by GMSGID at RICHLOC, indicating that it occurred\n+   before TOKEN, which had the associated VALUE.  */\n \n void\n c_parse_error (const char *gmsgid, enum cpp_ttype token_type,\n-\t       tree value, unsigned char token_flags)\n+\t       tree value, unsigned char token_flags,\n+\t       rich_location *richloc)\n {\n #define catenate_messages(M1, M2) catenate_strings ((M1), (M2), sizeof (M2))\n \n@@ -5996,7 +5997,7 @@ c_parse_error (const char *gmsgid, enum cpp_ttype token_type,\n       else\n \tmessage = catenate_messages (gmsgid, \" before %s'\\\\x%x'\");\n \n-      error (message, prefix, val);\n+      error_at_rich_loc (richloc, message, prefix, val);\n       free (message);\n       message = NULL;\n     }\n@@ -6024,7 +6025,7 @@ c_parse_error (const char *gmsgid, enum cpp_ttype token_type,\n   else if (token_type == CPP_NAME)\n     {\n       message = catenate_messages (gmsgid, \" before %qE\");\n-      error (message, value);\n+      error_at_rich_loc (richloc, message, value);\n       free (message);\n       message = NULL;\n     }\n@@ -6037,16 +6038,16 @@ c_parse_error (const char *gmsgid, enum cpp_ttype token_type,\n   else if (token_type < N_TTYPES)\n     {\n       message = catenate_messages (gmsgid, \" before %qs token\");\n-      error (message, cpp_type2name (token_type, token_flags));\n+      error_at_rich_loc (richloc, message, cpp_type2name (token_type, token_flags));\n       free (message);\n       message = NULL;\n     }\n   else\n-    error (gmsgid);\n+    error_at_rich_loc (richloc, gmsgid);\n \n   if (message)\n     {\n-      error (message);\n+      error_at_rich_loc (richloc, message);\n       free (message);\n     }\n #undef catenate_messages"}, {"sha": "980d39662fc936030fc4753cbbd29cc19fc775c9", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -1124,7 +1124,8 @@ extern void builtin_define_with_int_value (const char *, HOST_WIDE_INT);\n extern void builtin_define_type_sizeof (const char *, tree);\n extern void c_stddef_cpp_builtins (void);\n extern void fe_file_change (const line_map_ordinary *);\n-extern void c_parse_error (const char *, enum cpp_ttype, tree, unsigned char);\n+extern void c_parse_error (const char *, enum cpp_ttype, tree, unsigned char,\n+\t\t\t   rich_location *richloc);\n \n /* In c-ppoutput.c  */\n extern void init_pp_output (FILE *);"}, {"sha": "6e293345e9961c7166093b3c53a06bffdf65fafe", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -1,3 +1,87 @@\n+2017-08-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-parser.c (c_parser_error): Rename to...\n+\t(c_parser_error_richloc): ...this, making static, and adding\n+\t\"richloc\" parameter, passing it to the c_parse_error call,\n+\trather than calling c_parser_set_source_position_from_token.\n+\t(c_parser_error): Reintroduce, reimplementing in terms of the\n+\tabove, converting return type from void to bool.\n+\t(class token_pair): New class.\n+\t(struct matching_paren_traits): New struct.\n+\t(matching_parens): New typedef.\n+\t(struct matching_brace_traits): New struct.\n+\t(matching_braces): New typedef.\n+\t(get_matching_symbol): New function.\n+\t(c_parser_require): Add param MATCHING_LOCATION, using it to\n+\thighlight matching \"opening\" tokens for missing \"closing\" tokens.\n+\t(c_parser_skip_until_found): Likewise.\n+\t(c_parser_static_assert_declaration_no_semi): Convert explicit\n+\tparsing of CPP_OPEN_PAREN and CPP_CLOSE_PAREN to use of\n+\tclass matching_parens, so that the pertinent open parenthesis is\n+\thighlighted when there are problems locating the close\n+\tparenthesis.\n+\t(c_parser_struct_or_union_specifier): Likewise.\n+\t(c_parser_typeof_specifier): Likewise.\n+\t(c_parser_alignas_specifier): Likewise.\n+\t(c_parser_simple_asm_expr): Likewise.\n+\t(c_parser_braced_init): Likewise, for matching_braces.\n+\t(c_parser_paren_condition): Likewise, for matching_parens.\n+\t(c_parser_switch_statement): Likewise.\n+\t(c_parser_for_statement): Likewise.\n+\t(c_parser_asm_statement): Likewise.\n+\t(c_parser_asm_operands): Likewise.\n+\t(c_parser_cast_expression): Likewise.\n+\t(c_parser_sizeof_expression): Likewise.\n+\t(c_parser_alignof_expression): Likewise.\n+\t(c_parser_generic_selection): Likewise.\n+\t(c_parser_postfix_expression): Likewise for cases RID_VA_ARG,\n+\tRID_OFFSETOF, RID_TYPES_COMPATIBLE_P, RID_AT_SELECTOR,\n+\tRID_AT_PROTOCOL, RID_AT_ENCODE, reindenting as necessary.\n+\tIn case CPP_OPEN_PAREN, pass loc_open_paren to the\n+\tc_parser_skip_until_found call.\n+\t(c_parser_objc_class_definition): Use class matching_parens as\n+\tabove.\n+\t(c_parser_objc_method_decl): Likewise.\n+\t(c_parser_objc_try_catch_finally_statement): Likewise.\n+\t(c_parser_objc_synchronized_statement): Likewise.\n+\t(c_parser_objc_at_property_declaration): Likewise.\n+\t(c_parser_oacc_wait_list): Likewise.\n+\t(c_parser_omp_var_list_parens): Likewise.\n+\t(c_parser_omp_clause_collapse): Likewise.\n+\t(c_parser_omp_clause_default): Likewise.\n+\t(c_parser_omp_clause_if): Likewise.\n+\t(c_parser_omp_clause_num_threads): Likewise.\n+\t(c_parser_omp_clause_num_tasks): Likewise.\n+\t(c_parser_omp_clause_grainsize): Likewise.\n+\t(c_parser_omp_clause_priority): Likewise.\n+\t(c_parser_omp_clause_hint): Likewise.\n+\t(c_parser_omp_clause_defaultmap): Likewise.\n+\t(c_parser_oacc_single_int_clause): Likewise.\n+\t(c_parser_omp_clause_ordered): Likewise.\n+\t(c_parser_omp_clause_reduction): Likewise.\n+\t(c_parser_omp_clause_schedule): Likewise.\n+\t(c_parser_omp_clause_num_teams): Likewise.\n+\t(c_parser_omp_clause_thread_limit): Likewise.\n+\t(c_parser_omp_clause_aligned): Likewise.\n+\t(c_parser_omp_clause_linear): Likewise.\n+\t(c_parser_omp_clause_safelen): Likewise.\n+\t(c_parser_omp_clause_simdlen): Likewise.\n+\t(c_parser_omp_clause_depend): Likewise.\n+\t(c_parser_omp_clause_map): Likewise.\n+\t(c_parser_omp_clause_device): Likewise.\n+\t(c_parser_omp_clause_dist_schedule): Likewise.\n+\t(c_parser_omp_clause_proc_bind): Likewise.\n+\t(c_parser_omp_clause_uniform): Likewise.\n+\t(c_parser_omp_for_loop): Likewise.\n+\t(c_parser_cilk_clause_vectorlength): Likewise.\n+\t(c_parser_cilk_clause_linear): Likewise.\n+\t(c_parser_transaction_expression): Likewise.\n+\t* c-parser.h (c_parser_require): Add param matching_location with\n+\tdefault UNKNOWN_LOCATION.\n+\t(c_parser_error): Convert return type from void to bool.\n+\t(c_parser_skip_until_found): Add param matching_location with\n+\tdefault UNKNOWN_LOCATION.\n+\n 2017-08-09  Marek Polacek  <polacek@redhat.com>\n \n \t* c-decl.c (build_enumerator): Use true/false instead of 1/0."}, {"sha": "1402ba67204601576b630ce149ff71be4cd0fddf", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 430, "deletions": 214, "changes": 644, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -850,21 +850,26 @@ c_parser_peek_conflict_marker (c_parser *parser, enum cpp_ttype tok1_kind,\n    MESSAGE (specified by the caller) is usually of the form \"expected\n    OTHER-TOKEN\".\n \n+   Use RICHLOC as the location of the diagnostic.\n+\n    Do not issue a diagnostic if still recovering from an error.\n \n+   Return true iff an error was actually emitted.\n+\n    ??? This is taken from the C++ parser, but building up messages in\n    this way is not i18n-friendly and some other approach should be\n    used.  */\n \n-void\n-c_parser_error (c_parser *parser, const char *gmsgid)\n+static bool\n+c_parser_error_richloc (c_parser *parser, const char *gmsgid,\n+\t\t\trich_location *richloc)\n {\n   c_token *token = c_parser_peek_token (parser);\n   if (parser->error)\n-    return;\n+    return false;\n   parser->error = true;\n   if (!gmsgid)\n-    return;\n+    return false;\n \n   /* If this is actually a conflict marker, report it as such.  */\n   if (token->type == CPP_LSHIFT\n@@ -875,13 +880,10 @@ c_parser_error (c_parser *parser, const char *gmsgid)\n       if (c_parser_peek_conflict_marker (parser, token->type, &loc))\n \t{\n \t  error_at (loc, \"version control conflict marker in file\");\n-\t  return;\n+\t  return true;\n \t}\n     }\n \n-  /* This diagnostic makes more sense if it is tagged to the line of\n-     the token we just peeked at.  */\n-  c_parser_set_source_position_from_token (token);\n   c_parse_error (gmsgid,\n \t\t /* Because c_parse_error does not understand\n \t\t    CPP_KEYWORD, keywords are treated like\n@@ -891,18 +893,157 @@ c_parser_error (c_parser *parser, const char *gmsgid)\n \t\t    token, we need to pass 0 here and we will not get\n \t\t    the source spelling of some tokens but rather the\n \t\t    canonical spelling.  */\n-\t\t token->value, /*flags=*/0);\n+\t\t token->value, /*flags=*/0, richloc);\n+  return true;\n+}\n+\n+/* As c_parser_error_richloc, but issue the message at the\n+   location of PARSER's next token, or at input_location\n+   if the next token is EOF.  */\n+\n+bool\n+c_parser_error (c_parser *parser, const char *gmsgid)\n+{\n+  c_token *token = c_parser_peek_token (parser);\n+  c_parser_set_source_position_from_token (token);\n+  rich_location richloc (line_table, input_location);\n+  return c_parser_error_richloc (parser, gmsgid, &richloc);\n+}\n+\n+/* Some tokens naturally come in pairs e.g.'(' and ')'.\n+   This class is for tracking such a matching pair of symbols.\n+   In particular, it tracks the location of the first token,\n+   so that if the second token is missing, we can highlight the\n+   location of the first token when notifying the user about the\n+   problem.  */\n+\n+template <typename traits_t>\n+class token_pair\n+{\n+ public:\n+  /* token_pair's ctor.  */\n+  token_pair () : m_open_loc (UNKNOWN_LOCATION) {}\n+\n+  /* If the next token is the opening symbol for this pair, consume it and\n+     return true.\n+     Otherwise, issue an error and return false.\n+     In either case, record the location of the opening token.  */\n+\n+  bool require_open (c_parser *parser)\n+  {\n+    c_token *token = c_parser_peek_token (parser);\n+    if (token)\n+      m_open_loc = token->location;\n+\n+    return c_parser_require (parser, traits_t::open_token_type,\n+\t\t\t     traits_t::open_gmsgid);\n+  }\n+\n+  /* Consume the next token from PARSER, recording its location as\n+     that of the opening token within the pair.  */\n+\n+  void consume_open (c_parser *parser)\n+  {\n+    c_token *token = c_parser_peek_token (parser);\n+    gcc_assert (token->type == traits_t::open_token_type);\n+    m_open_loc = token->location;\n+    c_parser_consume_token (parser);\n+  }\n+\n+  /* If the next token is the closing symbol for this pair, consume it\n+     and return true.\n+     Otherwise, issue an error, highlighting the location of the\n+     corresponding opening token, and return false.  */\n+\n+  bool require_close (c_parser *parser) const\n+  {\n+    return c_parser_require (parser, traits_t::close_token_type,\n+\t\t\t     traits_t::close_gmsgid, m_open_loc);\n+  }\n+\n+  /* Like token_pair::require_close, except that tokens will be skipped\n+     until the desired token is found.  An error message is still produced\n+     if the next token is not as expected.  */\n+\n+  void skip_until_found_close (c_parser *parser) const\n+  {\n+    c_parser_skip_until_found (parser, traits_t::close_token_type,\n+\t\t\t       traits_t::close_gmsgid, m_open_loc);\n+  }\n+\n+ private:\n+  location_t m_open_loc;\n+};\n+\n+/* Traits for token_pair<T> for tracking matching pairs of parentheses.  */\n+\n+struct matching_paren_traits\n+{\n+  static const enum cpp_ttype open_token_type = CPP_OPEN_PAREN;\n+  static const char * const open_gmsgid;\n+  static const enum cpp_ttype close_token_type = CPP_CLOSE_PAREN;\n+  static const char * const close_gmsgid;\n+};\n+\n+const char * const matching_paren_traits::open_gmsgid = \"expected %<(%>\";\n+const char * const matching_paren_traits::close_gmsgid = \"expected %<)%>\";\n+\n+/* \"matching_parens\" is a token_pair<T> class for tracking matching\n+   pairs of parentheses.  */\n+\n+typedef token_pair<matching_paren_traits> matching_parens;\n+\n+/* Traits for token_pair<T> for tracking matching pairs of braces.  */\n+\n+struct matching_brace_traits\n+{\n+  static const enum cpp_ttype open_token_type = CPP_OPEN_BRACE;\n+  static const char * const open_gmsgid;\n+  static const enum cpp_ttype close_token_type = CPP_CLOSE_BRACE;\n+  static const char * const close_gmsgid;\n+};\n+\n+const char * const matching_brace_traits::open_gmsgid = \"expected %<{%>\";\n+const char * const matching_brace_traits::close_gmsgid = \"expected %<}%>\";\n+\n+/* \"matching_braces\" is a token_pair<T> class for tracking matching\n+   pairs of braces.  */\n+\n+typedef token_pair<matching_brace_traits> matching_braces;\n+\n+/* Get a description of the matching symbol to TYPE e.g. \"(\" for\n+   CPP_CLOSE_PAREN.  */\n+\n+static const char *\n+get_matching_symbol (enum cpp_ttype type)\n+{\n+  switch (type)\n+    {\n+    default:\n+      gcc_unreachable ();\n+      return \"\";\n+    case CPP_CLOSE_PAREN:\n+      return \"(\";\n+    case CPP_CLOSE_BRACE:\n+      return \"{\";\n+    }\n }\n \n /* If the next token is of the indicated TYPE, consume it.  Otherwise,\n    issue the error MSGID.  If MSGID is NULL then a message has already\n    been produced and no message will be produced this time.  Returns\n-   true if found, false otherwise.  */\n+   true if found, false otherwise.\n+\n+   If MATCHING_LOCATION is not UNKNOWN_LOCATION, then highlight it\n+   within any error as the location of an \"opening\" token matching\n+   the close token TYPE (e.g. the location of the '(' when TYPE is\n+   CPP_CLOSE_PAREN).  */\n \n bool\n c_parser_require (c_parser *parser,\n \t\t  enum cpp_ttype type,\n-\t\t  const char *msgid)\n+\t\t  const char *msgid,\n+\t\t  location_t matching_location)\n {\n   if (c_parser_next_token_is (parser, type))\n     {\n@@ -911,7 +1052,24 @@ c_parser_require (c_parser *parser,\n     }\n   else\n     {\n-      c_parser_error (parser, msgid);\n+      location_t next_token_loc = c_parser_peek_token (parser)->location;\n+      gcc_rich_location richloc (next_token_loc);\n+\n+      /* If matching_location != UNKNOWN_LOCATION, highlight it.\n+\t Attempt to consolidate diagnostics by printing it as a\n+\t secondary range within the main diagnostic.  */\n+      bool added_matching_location = false;\n+      if (matching_location != UNKNOWN_LOCATION)\n+\tadded_matching_location\n+\t  = richloc.add_location_if_nearby (matching_location);\n+\n+      if (c_parser_error_richloc (parser, msgid, &richloc))\n+\t/* If we weren't able to consolidate matching_location, then\n+\t   print it as a secondary diagnostic.  */\n+\tif (matching_location != UNKNOWN_LOCATION && !added_matching_location)\n+\t  inform (matching_location, \"to match this %qs\",\n+\t\t  get_matching_symbol (type));\n+\n       return false;\n     }\n }\n@@ -940,16 +1098,22 @@ c_parser_require_keyword (c_parser *parser,\n    desired token is found.  An error message is still produced if the\n    next token is not as expected.  If MSGID is NULL then a message has\n    already been produced and no message will be produced this\n-   time.  */\n+   time.\n+\n+   If MATCHING_LOCATION is not UNKNOWN_LOCATION, then highlight it\n+   within any error as the location of an \"opening\" token matching\n+   the close token TYPE (e.g. the location of the '(' when TYPE is\n+   CPP_CLOSE_PAREN).  */\n \n void\n c_parser_skip_until_found (c_parser *parser,\n \t\t\t   enum cpp_ttype type,\n-\t\t\t   const char *msgid)\n+\t\t\t   const char *msgid,\n+\t\t\t   location_t matching_location)\n {\n   unsigned nesting_depth = 0;\n \n-  if (c_parser_require (parser, type, msgid))\n+  if (c_parser_require (parser, type, msgid, matching_location))\n     return;\n \n   /* Skip tokens until the desired token is found.  */\n@@ -2210,7 +2374,8 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n     pedwarn_c99 (assert_loc, OPT_Wpedantic,\n \t\t \"ISO C90 does not support %<_Static_assert%>\");\n   c_parser_consume_token (parser);\n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return;\n   location_t value_tok_loc = c_parser_peek_token (parser)->location;\n   value = c_parser_expr_no_commas (parser, NULL).value;\n@@ -2237,7 +2402,7 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n       parser->lex_untranslated_string = false;\n       return;\n     }\n-  c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.require_close (parser);\n \n   if (!INTEGRAL_TYPE_P (TREE_TYPE (value)))\n     {\n@@ -2922,7 +3087,8 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t  tree name;\n \t  gcc_assert (c_dialect_objc ());\n \t  c_parser_consume_token (parser);\n-\t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+\t  matching_parens parens;\n+\t  if (!parens.require_open (parser))\n \t    goto end_at_defs;\n \t  if (c_parser_next_token_is (parser, CPP_NAME)\n \t      && c_parser_peek_token (parser)->id_kind == C_ID_CLASSNAME)\n@@ -2936,8 +3102,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n \t      goto end_at_defs;\n \t    }\n-\t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n-\t\t\t\t     \"expected %<)%>\");\n+\t  parens.skip_until_found_close (parser);\n \t  contents = nreverse (objc_get_class_ivars (name));\n \t}\n     end_at_defs:\n@@ -3224,7 +3389,8 @@ c_parser_typeof_specifier (c_parser *parser)\n   c_parser_consume_token (parser);\n   c_inhibit_evaluation_warnings++;\n   in_typeof++;\n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     {\n       c_inhibit_evaluation_warnings--;\n       in_typeof--;\n@@ -3265,7 +3431,7 @@ c_parser_typeof_specifier (c_parser *parser)\n       if (ret.spec != error_mark_node && TYPE_ATOMIC (ret.spec))\n \tret.spec = c_build_qualified_type (ret.spec, TYPE_UNQUALIFIED);\n     }\n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n   return ret;\n }\n \n@@ -3291,7 +3457,8 @@ c_parser_alignas_specifier (c_parser * parser)\n   else\n     pedwarn_c99 (loc, OPT_Wpedantic,\n \t\t \"ISO C90 does not support %<_Alignas%>\");\n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return ret;\n   if (c_parser_next_tokens_start_typename (parser, cla_prefer_id))\n     {\n@@ -3302,7 +3469,7 @@ c_parser_alignas_specifier (c_parser * parser)\n     }\n   else\n     ret = c_parser_expr_no_commas (parser, NULL).value;\n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n   return ret;\n }\n \n@@ -3953,14 +4120,15 @@ c_parser_simple_asm_expr (c_parser *parser)\n      lex_untranslated_string kludge.  */\n   parser->lex_untranslated_string = true;\n   c_parser_consume_token (parser);\n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     {\n       parser->lex_untranslated_string = false;\n       return NULL_TREE;\n     }\n   str = c_parser_asm_string_literal (parser);\n   parser->lex_untranslated_string = false;\n-  if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n+  if (!parens.require_close (parser))\n     {\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n       return NULL_TREE;\n@@ -4398,7 +4566,8 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p,\n   location_t brace_loc = c_parser_peek_token (parser)->location;\n   gcc_obstack_init (&braced_init_obstack);\n   gcc_assert (c_parser_next_token_is (parser, CPP_OPEN_BRACE));\n-  c_parser_consume_token (parser);\n+  matching_braces braces;\n+  braces.consume_open (parser);\n   if (nested_p)\n     {\n       finish_implicit_inits (brace_loc, outer_obstack);\n@@ -4436,7 +4605,7 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p,\n       ret.value = error_mark_node;\n       ret.original_code = ERROR_MARK;\n       ret.original_type = NULL;\n-      c_parser_skip_until_found (parser, CPP_CLOSE_BRACE, \"expected %<}%>\");\n+      braces.skip_until_found_close (parser);\n       pop_init_level (brace_loc, 0, &braced_init_obstack, last_init_list_comma);\n       obstack_free (&braced_init_obstack, NULL);\n       return ret;\n@@ -5459,10 +5628,11 @@ static tree\n c_parser_paren_condition (c_parser *parser)\n {\n   tree cond;\n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return error_mark_node;\n   cond = c_parser_condition (parser);\n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n   return cond;\n }\n \n@@ -5731,7 +5901,8 @@ c_parser_switch_statement (c_parser *parser, bool *if_p)\n   c_parser_consume_token (parser);\n   block = c_begin_compound_stmt (flag_isoc99);\n   bool explicit_cast_p = false;\n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       switch_cond_loc = c_parser_peek_token (parser)->location;\n       if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)\n@@ -5746,7 +5917,7 @@ c_parser_switch_statement (c_parser *parser, bool *if_p)\n \t \"%<_Cilk_spawn%> statement cannot be used as a condition for switch statement\",\n \t\t\t switch_cond_loc))\n         expr = error_mark_node;\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n     }\n   else\n     {\n@@ -5956,7 +6127,8 @@ c_parser_for_statement (c_parser *parser, bool ivdep, bool *if_p)\n   block = c_begin_compound_stmt (flag_isoc99 || c_dialect_objc ());\n   cond = error_mark_node;\n   incr = error_mark_node;\n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       /* Parse the initialization declaration or expression.  */\n       object_expression = error_mark_node;\n@@ -6103,7 +6275,7 @@ c_parser_for_statement (c_parser *parser, bool ivdep, bool *if_p)\n \t      incr = c_process_expr_stmt (loc, ce.value);\n \t    }\n \t}\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n     }\n   save_break = c_break_label;\n   c_break_label = NULL_TREE;\n@@ -6197,7 +6369,8 @@ c_parser_asm_statement (c_parser *parser)\n   parser->lex_untranslated_string = true;\n   ret = NULL;\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     goto error;\n \n   str = c_parser_asm_string_literal (parser);\n@@ -6255,7 +6428,7 @@ c_parser_asm_statement (c_parser *parser)\n     }\n \n  done_asm:\n-  if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n+  if (!parens.require_close (parser))\n     {\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n       goto error;\n@@ -6320,15 +6493,16 @@ c_parser_asm_operands (c_parser *parser)\n       if (str == NULL_TREE)\n \treturn NULL_TREE;\n       parser->lex_untranslated_string = false;\n-      if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+      matching_parens parens;\n+      if (!parens.require_open (parser))\n \t{\n \t  parser->lex_untranslated_string = true;\n \t  return NULL_TREE;\n \t}\n       expr = c_parser_expression (parser);\n       mark_exp_read (expr.value);\n       parser->lex_untranslated_string = true;\n-      if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n+      if (!parens.require_close (parser))\n \t{\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n \t  return NULL_TREE;\n@@ -6940,9 +7114,10 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n       struct c_type_name *type_name;\n       struct c_expr ret;\n       struct c_expr expr;\n-      c_parser_consume_token (parser);\n+      matching_parens parens;\n+      parens.consume_open (parser);\n       type_name = c_parser_type_name (parser);\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n       if (type_name == NULL)\n \t{\n \t  ret.value = error_mark_node;\n@@ -7169,10 +7344,11 @@ c_parser_sizeof_expression (c_parser *parser)\n       /* Either sizeof ( type-name ) or sizeof unary-expression\n \t starting with a compound literal.  */\n       struct c_type_name *type_name;\n-      c_parser_consume_token (parser);\n+      matching_parens parens;\n+      parens.consume_open (parser);\n       expr_loc = c_parser_peek_token (parser)->location;\n       type_name = c_parser_type_name (parser);\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n       finish = parser->tokens_buf[0].location;\n       if (type_name == NULL)\n \t{\n@@ -7251,11 +7427,12 @@ c_parser_alignof_expression (c_parser *parser)\n       location_t loc;\n       struct c_type_name *type_name;\n       struct c_expr ret;\n-      c_parser_consume_token (parser);\n+      matching_parens parens;\n+      parens.consume_open (parser);\n       loc = c_parser_peek_token (parser)->location;\n       type_name = c_parser_type_name (parser);\n       end_loc = c_parser_peek_token (parser)->location;\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n       if (type_name == NULL)\n \t{\n \t  struct c_expr ret;\n@@ -7414,7 +7591,8 @@ c_parser_generic_selection (c_parser *parser)\n     pedwarn_c99 (generic_loc, OPT_Wpedantic,\n \t\t \"ISO C90 does not support %<_Generic%>\");\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return error_expr;\n \n   c_inhibit_evaluation_warnings++;\n@@ -7556,7 +7734,7 @@ c_parser_generic_selection (c_parser *parser)\n       c_parser_consume_token (parser);\n     }\n \n-  if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n+  if (!parens.require_close (parser))\n     {\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n       return error_expr;\n@@ -7802,7 +7980,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t  location_t loc_close_paren = c_parser_peek_token (parser)->location;\n \t  set_c_expr_source_range (&expr, loc_open_paren, loc_close_paren);\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n-\t\t\t\t     \"expected %<)%>\");\n+\t\t\t\t     \"expected %<)%>\", loc_open_paren);\n \t}\n       break;\n     case CPP_KEYWORD:\n@@ -7839,7 +8017,8 @@ c_parser_postfix_expression (c_parser *parser)\n \t  {\n \t    location_t start_loc = loc;\n \t    c_parser_consume_token (parser);\n-\t    if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+\t    matching_parens parens;\n+\t    if (!parens.require_open (parser))\n \t      {\n \t\texpr.set_error ();\n \t\tbreak;\n@@ -7879,25 +8058,25 @@ c_parser_postfix_expression (c_parser *parser)\n \t  }\n \t  break;\n \tcase RID_OFFSETOF:\n-\t  c_parser_consume_token (parser);\n-\t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n-\t    {\n-\t      expr.set_error ();\n-\t      break;\n-\t    }\n-\t  t1 = c_parser_type_name (parser);\n-\t  if (t1 == NULL)\n-\t    parser->error = true;\n-\t  if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n-            gcc_assert (parser->error);\n-\t  if (parser->error)\n-\t    {\n-\t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n-\t      expr.set_error ();\n-\t      break;\n-\t    }\n-\n \t  {\n+\t    c_parser_consume_token (parser);\n+\t    matching_parens parens;\n+\t    if (!parens.require_open (parser))\n+\t      {\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\t    t1 = c_parser_type_name (parser);\n+\t    if (t1 == NULL)\n+\t      parser->error = true;\n+\t    if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n+\t      gcc_assert (parser->error);\n+\t    if (parser->error)\n+\t      {\n+\t\tc_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n \t    tree type = groktypename (t1, NULL, NULL);\n \t    tree offsetof_ref;\n \t    if (type == error_mark_node)\n@@ -8014,34 +8193,34 @@ c_parser_postfix_expression (c_parser *parser)\n \t    break;\n \t  }\n \tcase RID_TYPES_COMPATIBLE_P:\n-\t  c_parser_consume_token (parser);\n-\t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n-\t    {\n-\t      expr.set_error ();\n-\t      break;\n-\t    }\n-\t  t1 = c_parser_type_name (parser);\n-\t  if (t1 == NULL)\n-\t    {\n-\t      expr.set_error ();\n-\t      break;\n-\t    }\n-\t  if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n-\t    {\n-\t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n-\t      expr.set_error ();\n-\t      break;\n-\t    }\n-\t  t2 = c_parser_type_name (parser);\n-\t  if (t2 == NULL)\n-\t    {\n-\t      expr.set_error ();\n-\t      break;\n-\t    }\n \t  {\n+\t    c_parser_consume_token (parser);\n+\t    matching_parens parens;\n+\t    if (!parens.require_open (parser))\n+\t      {\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\t    t1 = c_parser_type_name (parser);\n+\t    if (t1 == NULL)\n+\t      {\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\t    if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n+\t      {\n+\t\tc_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\t    t2 = c_parser_type_name (parser);\n+\t    if (t2 == NULL)\n+\t      {\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n \t    location_t close_paren_loc = c_parser_peek_token (parser)->location;\n-\t    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n-\t\t\t\t       \"expected %<)%>\");\n+\t    parens.skip_until_found_close (parser);\n \t    tree e1, e2;\n \t    e1 = groktypename (t1, NULL, NULL);\n \t    e2 = groktypename (t2, NULL, NULL);\n@@ -8207,67 +8386,67 @@ c_parser_postfix_expression (c_parser *parser)\n \t    break;\n \t  }\n \tcase RID_AT_SELECTOR:\n-\t  gcc_assert (c_dialect_objc ());\n-\t  c_parser_consume_token (parser);\n-\t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n-\t    {\n-\t      expr.set_error ();\n-\t      break;\n-\t    }\n \t  {\n+\t    gcc_assert (c_dialect_objc ());\n+\t    c_parser_consume_token (parser);\n+\t    matching_parens parens;\n+\t    if (!parens.require_open (parser))\n+\t      {\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n \t    tree sel = c_parser_objc_selector_arg (parser);\n \t    location_t close_loc = c_parser_peek_token (parser)->location;\n-\t    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n-\t\t\t\t       \"expected %<)%>\");\n+\t    parens.skip_until_found_close (parser);\n \t    expr.value = objc_build_selector_expr (loc, sel);\n \t    set_c_expr_source_range (&expr, loc, close_loc);\n \t  }\n \t  break;\n \tcase RID_AT_PROTOCOL:\n-\t  gcc_assert (c_dialect_objc ());\n-\t  c_parser_consume_token (parser);\n-\t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n-\t    {\n-\t      expr.set_error ();\n-\t      break;\n-\t    }\n-\t  if (c_parser_next_token_is_not (parser, CPP_NAME))\n-\t    {\n-\t      c_parser_error (parser, \"expected identifier\");\n-\t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n-\t      expr.set_error ();\n-\t      break;\n-\t    }\n \t  {\n+\t    gcc_assert (c_dialect_objc ());\n+\t    c_parser_consume_token (parser);\n+\t    matching_parens parens;\n+\t    if (!parens.require_open (parser))\n+\t      {\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\t    if (c_parser_next_token_is_not (parser, CPP_NAME))\n+\t      {\n+\t\tc_parser_error (parser, \"expected identifier\");\n+\t\tc_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n \t    tree id = c_parser_peek_token (parser)->value;\n \t    c_parser_consume_token (parser);\n \t    location_t close_loc = c_parser_peek_token (parser)->location;\n-\t    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n-\t\t\t\t       \"expected %<)%>\");\n+\t    parens.skip_until_found_close (parser);\n \t    expr.value = objc_build_protocol_expr (id);\n \t    set_c_expr_source_range (&expr, loc, close_loc);\n \t  }\n \t  break;\n \tcase RID_AT_ENCODE:\n-\t  /* Extension to support C-structures in the archiver.  */\n-\t  gcc_assert (c_dialect_objc ());\n-\t  c_parser_consume_token (parser);\n-\t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n-\t    {\n-\t      expr.set_error ();\n-\t      break;\n-\t    }\n-\t  t1 = c_parser_type_name (parser);\n-\t  if (t1 == NULL)\n-\t    {\n-\t      expr.set_error ();\n-\t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n-\t      break;\n-\t    }\n \t  {\n+\t    /* Extension to support C-structures in the archiver.  */\n+\t    gcc_assert (c_dialect_objc ());\n+\t    c_parser_consume_token (parser);\n+\t    matching_parens parens;\n+\t    if (!parens.require_open (parser))\n+\t      {\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\t    t1 = c_parser_type_name (parser);\n+\t    if (t1 == NULL)\n+\t      {\n+\t\texpr.set_error ();\n+\t\tc_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n+\t\tbreak;\n+\t      }\n \t    location_t close_loc = c_parser_peek_token (parser)->location;\n-\t    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n-\t\t\t\t     \"expected %<)%>\");\n+\t    parens.skip_until_found_close (parser);\n \t    tree type = groktypename (t1, NULL, NULL);\n \t    expr.value = objc_build_encode_expr (type);\n \t    set_c_expr_source_range (&expr, loc, close_loc);\n@@ -8860,7 +9039,8 @@ c_parser_objc_class_definition (c_parser *parser, tree attributes)\n       /* We have a category or class extension.  */\n       tree id2;\n       tree proto = NULL_TREE;\n-      c_parser_consume_token (parser);\n+      matching_parens parens;\n+      parens.consume_open (parser);\n       if (c_parser_next_token_is_not (parser, CPP_NAME))\n \t{\n \t  if (iface_p && c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n@@ -8880,7 +9060,7 @@ c_parser_objc_class_definition (c_parser *parser, tree attributes)\n \t  id2 = c_parser_peek_token (parser)->value;\n \t  c_parser_consume_token (parser);\n \t}\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n       if (!iface_p)\n \t{\n \t  objc_start_category_implementation (id1, id2);\n@@ -9414,9 +9594,10 @@ c_parser_objc_method_decl (c_parser *parser, bool is_class_method,\n   *attributes = NULL_TREE;\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n     {\n-      c_parser_consume_token (parser);\n+      matching_parens parens;\n+      parens.consume_open (parser);\n       type = c_parser_objc_type_name (parser);\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n     }\n   sel = c_parser_objc_selector (parser);\n   /* If there is no selector, or a colon follows, we have an\n@@ -9622,7 +9803,8 @@ c_parser_objc_try_catch_finally_statement (c_parser *parser)\n       bool seen_open_paren = false;\n \n       c_parser_consume_token (parser);\n-      if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+      matching_parens parens;\n+      if (!parens.require_open (parser))\n \tseen_open_paren = true;\n       if (c_parser_next_token_is (parser, CPP_ELLIPSIS))\n \t{\n@@ -9645,7 +9827,7 @@ c_parser_objc_try_catch_finally_statement (c_parser *parser)\n \t    parameter_declaration = grokparm (parm, NULL);\n \t}\n       if (seen_open_paren)\n-\tc_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\tparens.require_close (parser);\n       else\n \t{\n \t  /* If there was no open parenthesis, we are recovering from\n@@ -9694,13 +9876,14 @@ c_parser_objc_synchronized_statement (c_parser *parser)\n   c_parser_consume_token (parser);\n   loc = c_parser_peek_token (parser)->location;\n   objc_maybe_warn_exceptions (loc);\n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       struct c_expr ce = c_parser_expression (parser);\n       ce = convert_lvalue_to_rvalue (loc, ce, false, false);\n       expr = ce.value;\n       expr = c_fully_fold (expr, false, NULL);\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n     }\n   else\n     expr = error_mark_node;\n@@ -9994,9 +10177,11 @@ c_parser_objc_at_property_declaration (c_parser *parser)\n   /* Parse the optional attribute list...  */\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n     {\n+      matching_parens parens;\n+\n       /* Eat the '(' */\n-      c_parser_consume_token (parser);\n-      \n+      parens.consume_open (parser);\n+\n       /* Property attribute keywords are valid now.  */\n       parser->objc_property_attr_context = true;\n \n@@ -10084,7 +10269,7 @@ c_parser_objc_at_property_declaration (c_parser *parser)\n \t    break;\n \t}\n       parser->objc_property_attr_context = false;\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n     }\n   /* ... and the property declaration(s).  */\n   properties = c_parser_struct_declaration (parser);\n@@ -10744,7 +10929,8 @@ c_parser_oacc_wait_list (c_parser *parser, location_t clause_loc, tree list)\n   vec<tree, va_gc> *args;\n   tree t, args_tree;\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   args = c_parser_expr_list (parser, false, true, NULL, NULL, NULL, NULL);\n@@ -10781,7 +10967,7 @@ c_parser_oacc_wait_list (c_parser *parser, location_t clause_loc, tree list)\n     }\n \n   release_tree_vector (args);\n-  c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.require_close (parser);\n   return list;\n }\n \n@@ -10939,10 +11125,11 @@ c_parser_omp_var_list_parens (c_parser *parser, enum omp_clause_code kind,\n   /* The clauses location.  */\n   location_t loc = c_parser_peek_token (parser)->location;\n \n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       list = c_parser_omp_variable_list (parser, loc, kind, list);\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n     }\n   return list;\n }\n@@ -11079,10 +11266,11 @@ c_parser_omp_clause_collapse (c_parser *parser, tree list)\n   check_no_duplicate_clause (list, OMP_CLAUSE_TILE, \"tile\");\n \n   loc = c_parser_peek_token (parser)->location;\n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       num = c_parser_expr_no_commas (parser, NULL).value;\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n     }\n   if (num == error_mark_node)\n     return list;\n@@ -11134,7 +11322,8 @@ c_parser_omp_clause_default (c_parser *parser, tree list, bool is_oacc)\n   location_t loc = c_parser_peek_token (parser)->location;\n   tree c;\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n@@ -11174,7 +11363,7 @@ c_parser_omp_clause_default (c_parser *parser, tree list, bool is_oacc)\n       else\n \tc_parser_error (parser, \"expected %<none%> or %<shared%>\");\n     }\n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n \n   if (kind == OMP_CLAUSE_DEFAULT_UNSPECIFIED)\n     return list;\n@@ -11237,7 +11426,8 @@ c_parser_omp_clause_if (c_parser *parser, tree list, bool is_omp)\n   location_t location = c_parser_peek_token (parser)->location;\n   enum tree_code if_modifier = ERROR_MARK;\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   if (is_omp && c_parser_next_token_is (parser, CPP_NAME))\n@@ -11318,7 +11508,7 @@ c_parser_omp_clause_if (c_parser *parser, tree list, bool is_omp)\n     }\n \n   tree t = c_parser_condition (parser), c;\n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n \n   for (c = list; c ; c = OMP_CLAUSE_CHAIN (c))\n     if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IF)\n@@ -11417,15 +11607,16 @@ static tree\n c_parser_omp_clause_num_threads (c_parser *parser, tree list)\n {\n   location_t num_threads_loc = c_parser_peek_token (parser)->location;\n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n       c_expr expr = c_parser_expression (parser);\n       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n       tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n \n       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t{\n@@ -11462,15 +11653,16 @@ static tree\n c_parser_omp_clause_num_tasks (c_parser *parser, tree list)\n {\n   location_t num_tasks_loc = c_parser_peek_token (parser)->location;\n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n       c_expr expr = c_parser_expression (parser);\n       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n       tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n \n       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t{\n@@ -11507,15 +11699,16 @@ static tree\n c_parser_omp_clause_grainsize (c_parser *parser, tree list)\n {\n   location_t grainsize_loc = c_parser_peek_token (parser)->location;\n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n       c_expr expr = c_parser_expression (parser);\n       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n       tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n \n       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t{\n@@ -11552,15 +11745,16 @@ static tree\n c_parser_omp_clause_priority (c_parser *parser, tree list)\n {\n   location_t priority_loc = c_parser_peek_token (parser)->location;\n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n       c_expr expr = c_parser_expression (parser);\n       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n       tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n \n       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t{\n@@ -11598,15 +11792,16 @@ static tree\n c_parser_omp_clause_hint (c_parser *parser, tree list)\n {\n   location_t hint_loc = c_parser_peek_token (parser)->location;\n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n       c_expr expr = c_parser_expression (parser);\n       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n       tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n \n       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t{\n@@ -11635,7 +11830,8 @@ c_parser_omp_clause_defaultmap (c_parser *parser, tree list)\n   tree c;\n   const char *p;\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n   if (!c_parser_next_token_is (parser, CPP_NAME))\n     {\n@@ -11663,14 +11859,14 @@ c_parser_omp_clause_defaultmap (c_parser *parser, tree list)\n       goto out_err;\n     }\n   c_parser_consume_token (parser);\n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n   check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULTMAP, \"defaultmap\");\n   c = build_omp_clause (loc, OMP_CLAUSE_DEFAULTMAP);\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n \n  out_err:\n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n   return list;\n }\n \n@@ -11707,7 +11903,8 @@ c_parser_oacc_single_int_clause (c_parser *parser, omp_clause_code code,\n {\n   location_t loc = c_parser_peek_token (parser)->location;\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   location_t expr_loc = c_parser_peek_token (parser)->location;\n@@ -11716,7 +11913,7 @@ c_parser_oacc_single_int_clause (c_parser *parser, omp_clause_code code,\n   tree c, t = expr.value;\n   t = c_fully_fold (t, false, NULL);\n \n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n \n   if (t == error_mark_node)\n     return list;\n@@ -12046,9 +12243,10 @@ c_parser_omp_clause_ordered (c_parser *parser, tree list)\n   location_t loc = c_parser_peek_token (parser)->location;\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n     {\n-      c_parser_consume_token (parser);\n+      matching_parens parens;\n+      parens.consume_open (parser);\n       num = c_parser_expr_no_commas (parser, NULL).value;\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n     }\n   if (num == error_mark_node)\n     return list;\n@@ -12102,7 +12300,8 @@ static tree\n c_parser_omp_clause_reduction (c_parser *parser, tree list)\n {\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       enum tree_code code = ERROR_MARK;\n       tree reduc_id = NULL_TREE;\n@@ -12200,7 +12399,7 @@ c_parser_omp_clause_reduction (c_parser *parser, tree list)\n \n \t  list = nl;\n \t}\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n     }\n   return list;\n }\n@@ -12228,7 +12427,8 @@ c_parser_omp_clause_schedule (c_parser *parser, tree list)\n   location_t loc = c_parser_peek_token (parser)->location;\n   int modifiers = 0, nmodifiers = 0;\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   c = build_omp_clause (loc, OMP_CLAUSE_SCHEDULE);\n@@ -12339,7 +12539,7 @@ c_parser_omp_clause_schedule (c_parser *parser, tree list)\n       else\n \tc_parser_error (parser, \"expected integer expression\");\n \n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n     }\n   else\n     c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n@@ -12452,15 +12652,16 @@ static tree\n c_parser_omp_clause_num_teams (c_parser *parser, tree list)\n {\n   location_t num_teams_loc = c_parser_peek_token (parser)->location;\n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n       c_expr expr = c_parser_expression (parser);\n       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n       tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n \n       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t{\n@@ -12496,15 +12697,16 @@ static tree\n c_parser_omp_clause_thread_limit (c_parser *parser, tree list)\n {\n   location_t num_thread_limit_loc = c_parser_peek_token (parser)->location;\n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n       c_expr expr = c_parser_expression (parser);\n       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n       tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n \n       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t{\n@@ -12544,7 +12746,8 @@ c_parser_omp_clause_aligned (c_parser *parser, tree list)\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n   tree nl, c;\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   nl = c_parser_omp_variable_list (parser, clause_loc,\n@@ -12571,7 +12774,7 @@ c_parser_omp_clause_aligned (c_parser *parser, tree list)\n \tOMP_CLAUSE_ALIGNED_ALIGNMENT (c) = alignment;\n     }\n \n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n   return nl;\n }\n \n@@ -12590,7 +12793,8 @@ c_parser_omp_clause_linear (c_parser *parser, tree list, bool is_cilk_simd_fn)\n   tree nl, c, step;\n   enum omp_clause_linear_kind kind = OMP_CLAUSE_LINEAR_DEFAULT;\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   if (!is_cilk_simd_fn\n@@ -12613,7 +12817,7 @@ c_parser_omp_clause_linear (c_parser *parser, tree list, bool is_cilk_simd_fn)\n \t\t\t\t   OMP_CLAUSE_LINEAR, list);\n \n   if (kind != OMP_CLAUSE_LINEAR_DEFAULT)\n-    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+    parens.skip_until_found_close (parser);\n \n   if (c_parser_next_token_is (parser, CPP_COLON))\n     {\n@@ -12645,7 +12849,7 @@ c_parser_omp_clause_linear (c_parser *parser, tree list, bool is_cilk_simd_fn)\n       OMP_CLAUSE_LINEAR_KIND (c) = kind;\n     }\n \n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n   return nl;\n }\n \n@@ -12658,7 +12862,8 @@ c_parser_omp_clause_safelen (c_parser *parser, tree list)\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n   tree c, t;\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   location_t expr_loc = c_parser_peek_token (parser)->location;\n@@ -12675,7 +12880,7 @@ c_parser_omp_clause_safelen (c_parser *parser, tree list)\n       t = NULL_TREE;\n     }\n \n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n   if (t == NULL_TREE || t == error_mark_node)\n     return list;\n \n@@ -12696,7 +12901,8 @@ c_parser_omp_clause_simdlen (c_parser *parser, tree list)\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n   tree c, t;\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   location_t expr_loc = c_parser_peek_token (parser)->location;\n@@ -12713,7 +12919,7 @@ c_parser_omp_clause_simdlen (c_parser *parser, tree list)\n       t = NULL_TREE;\n     }\n \n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n   if (t == NULL_TREE || t == error_mark_node)\n     return list;\n \n@@ -12825,7 +13031,8 @@ c_parser_omp_clause_depend (c_parser *parser, tree list)\n   enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_INOUT;\n   tree nl, c;\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   if (c_parser_next_token_is (parser, CPP_NAME))\n@@ -12855,7 +13062,7 @@ c_parser_omp_clause_depend (c_parser *parser, tree list)\n       OMP_CLAUSE_DEPEND_KIND (c) = kind;\n       OMP_CLAUSE_DECL (c) = NULL_TREE;\n       OMP_CLAUSE_CHAIN (c) = list;\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n       return c;\n     }\n \n@@ -12873,13 +13080,13 @@ c_parser_omp_clause_depend (c_parser *parser, tree list)\n \tOMP_CLAUSE_DEPEND_KIND (c) = kind;\n     }\n \n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n   return nl;\n \n  invalid_kind:\n   c_parser_error (parser, \"invalid depend kind\");\n  resync_fail:\n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n   return list;\n }\n \n@@ -12907,7 +13114,8 @@ c_parser_omp_clause_map (c_parser *parser, tree list)\n   tree always_id = NULL_TREE;\n   tree nl, c;\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   if (c_parser_next_token_is (parser, CPP_NAME))\n@@ -12974,7 +13182,7 @@ c_parser_omp_clause_map (c_parser *parser, tree list)\n       if (always_id_kind != C_ID_ID)\n \t{\n \t  c_parser_error (parser, \"expected identifier\");\n-\t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\t  parens.skip_until_found_close (parser);\n \t  return list;\n \t}\n \n@@ -12994,7 +13202,7 @@ c_parser_omp_clause_map (c_parser *parser, tree list)\n \t}\n       if (always == 1)\n \t{\n-\t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+\t  parens.skip_until_found_close (parser);\n \t  return list;\n \t}\n     }\n@@ -13004,7 +13212,7 @@ c_parser_omp_clause_map (c_parser *parser, tree list)\n   for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n     OMP_CLAUSE_SET_MAP_KIND (c, kind);\n \n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n   return nl;\n }\n \n@@ -13015,15 +13223,16 @@ static tree\n c_parser_omp_clause_device (c_parser *parser, tree list)\n {\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n       c_expr expr = c_parser_expr_no_commas (parser, NULL);\n       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n       tree c, t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n \n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n \n       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t{\n@@ -13052,7 +13261,8 @@ c_parser_omp_clause_dist_schedule (c_parser *parser, tree list)\n   tree c, t = NULL_TREE;\n   location_t loc = c_parser_peek_token (parser)->location;\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   if (!c_parser_next_token_is_keyword (parser, RID_STATIC))\n@@ -13073,7 +13283,7 @@ c_parser_omp_clause_dist_schedule (c_parser *parser, tree list)\n       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n       t = expr.value;\n       t = c_fully_fold (t, false, NULL);\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n     }\n   else\n     c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n@@ -13102,7 +13312,8 @@ c_parser_omp_clause_proc_bind (c_parser *parser, tree list)\n   enum omp_clause_proc_bind_kind kind;\n   tree c;\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   if (c_parser_next_token_is (parser, CPP_NAME))\n@@ -13121,15 +13332,15 @@ c_parser_omp_clause_proc_bind (c_parser *parser, tree list)\n     goto invalid_kind;\n \n   c_parser_consume_token (parser);\n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n   c = build_omp_clause (clause_loc, OMP_CLAUSE_PROC_BIND);\n   OMP_CLAUSE_PROC_BIND_KIND (c) = kind;\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n \n  invalid_kind:\n   c_parser_error (parser, \"invalid proc_bind kind\");\n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n   return list;\n }\n \n@@ -13160,11 +13371,12 @@ c_parser_omp_clause_uniform (c_parser *parser, tree list)\n   /* The clauses location.  */\n   location_t loc = c_parser_peek_token (parser)->location;\n \n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       list = c_parser_omp_variable_list (parser, loc, OMP_CLAUSE_UNIFORM,\n \t\t\t\t\t list);\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n     }\n   return list;\n }\n@@ -14957,7 +15169,8 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n     {\n       int bracecount = 0;\n \n-      if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+      matching_parens parens;\n+      if (!parens.require_open (parser))\n \tgoto pop_scopes;\n \n       /* Parse the initialization declaration or expression.  */\n@@ -15064,7 +15277,7 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n \t  incr = c_process_expr_stmt (incr_loc,\n \t\t\t\t      c_parser_expression (parser).value);\n \t}\n-      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+      parens.skip_until_found_close (parser);\n \n       if (decl == NULL || decl == error_mark_node || init == error_mark_node)\n \tfail = true;\n@@ -17571,7 +17784,8 @@ c_parser_cilk_clause_vectorlength (c_parser *parser, tree clauses,\n      clause.  Represent it in OpenMP terms.  */\n     check_no_duplicate_clause (clauses, OMP_CLAUSE_SAFELEN, \"vectorlength\");\n \n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return clauses;\n \n   location_t loc = c_parser_peek_token (parser)->location;\n@@ -17607,7 +17821,7 @@ c_parser_cilk_clause_vectorlength (c_parser *parser, tree clauses,\n \t}\n     }\n \n-  c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.require_close (parser);\n \n   return clauses;\n }\n@@ -17629,7 +17843,8 @@ c_parser_cilk_clause_vectorlength (c_parser *parser, tree clauses,\n static tree\n c_parser_cilk_clause_linear (c_parser *parser, tree clauses)\n {\n-  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return clauses;\n \n   location_t loc = c_parser_peek_token (parser)->location;\n@@ -17691,7 +17906,7 @@ c_parser_cilk_clause_linear (c_parser *parser, tree clauses)\n       c_parser_consume_token (parser);\n     }\n \n-  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n+  parens.skip_until_found_close (parser);\n \n   return clauses;\n }\n@@ -18055,7 +18270,8 @@ c_parser_transaction_expression (c_parser *parser, enum rid keyword)\n     }\n \n   parser->in_transaction = this_in;\n-  if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+  matching_parens parens;\n+  if (parens.require_open (parser))\n     {\n       tree expr = c_parser_expression (parser).value;\n       ret.original_type = TREE_TYPE (expr);\n@@ -18064,7 +18280,7 @@ c_parser_transaction_expression (c_parser *parser, enum rid keyword)\n \tTRANSACTION_EXPR_RELAXED (ret.value) = 1;\n       SET_EXPR_LOCATION (ret.value, loc);\n       ret.original_code = TRANSACTION_EXPR;\n-      if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n+      if (!parens.require_close (parser))\n \t{\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n \t  goto error;"}, {"sha": "01a7b724081ab7d3f815eb543fe76f078efc51db", "filename": "gcc/c/c-parser.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fc%2Fc-parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fc%2Fc-parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.h?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -136,11 +136,13 @@ extern c_token * c_parser_peek_token (c_parser *parser);\n extern c_token * c_parser_peek_2nd_token (c_parser *parser);\n extern c_token * c_parser_peek_nth_token (c_parser *parser, unsigned int n);\n extern bool c_parser_require (c_parser *parser, enum cpp_ttype type,\n-\t\t\t      const char *msgid);\n-extern void c_parser_error (c_parser *parser, const char *gmsgid);\n+\t\t\t      const char *msgid,\n+\t\t\t      location_t matching_location = UNKNOWN_LOCATION);\n+extern bool c_parser_error (c_parser *parser, const char *gmsgid);\n extern void c_parser_consume_token (c_parser *parser);\n extern void c_parser_skip_until_found (c_parser *parser, enum cpp_ttype type,\n-\t\t\t\t       const char *msgid);\n+\t\t\t\t       const char *msgid,\n+\t\t\t\t       location_t = UNKNOWN_LOCATION);\n extern bool c_parser_next_token_starts_declspecs (c_parser *parser);\n bool c_parser_next_tokens_start_declaration (c_parser *parser);\n bool c_token_starts_typename (c_token *token);"}, {"sha": "bc0959cfef041f404440f65e54374805e40c3da1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -1,3 +1,114 @@\n+2017-08-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* parser.c (cp_parser_error): Update for new param to\n+\tc_parse_error.\n+\t(class token_pair): New class.\n+\t(struct matching_paren_traits): New struct.\n+\t(matching_parens): New typedef.\n+\t(struct matching_brace_traits): New struct.\n+\t(matching_braces): New typedef.\n+\t(cp_parser_statement_expr): Convert explicit parsing of\n+\tCPP_OPEN_PAREN and CPP_CLOSE_PAREN to use of\n+\tclass matching_parens, so that the pertinent open parenthesis is\n+\thighlighted when there are problems locating the close\n+\tparenthesis.\n+\t(cp_parser_primary_expression): Likewise.\n+\t(cp_parser_compound_literal_p): Remove consumption of opening\n+\tparen.\n+\t(cp_parser_postfix_expression): Convert explicit parsing of\n+\tCPP_OPEN_PAREN and CPP_CLOSE_PAREN to use matching parens, as\n+\tabove.  Use it to consume the opening paren previously consumed by\n+\tcp_parser_compound_literal_p.\n+\t(cp_parser_parenthesized_expression_list): Likewise.\n+\t(cp_parser_unary_expression): Likewise.\n+\t(cp_parser_new_expression): Likewise.\n+\t(cp_parser_cast_expression): Likewise.\n+\t(cp_parser_builtin_offsetof): Likewise.\n+\t(cp_parser_trait_expr): Likewise.\n+\t(cp_parser_lambda_declarator_opt): Likewise.\n+\t(cp_parser_lambda_body): Likewise, for matching_braces.\n+\t(cp_parser_compound_statement): Likewise.\n+\t(cp_parser_selection_statement): Likewise, for matching_parens.\n+\t(cp_parser_iteration_statement): Likewise.\n+\t(cp_parser_already_scoped_statement): Likewise, for\n+\tmatching_braces.\n+\t(cp_parser_linkage_specification): Likewise.\n+\t(cp_parser_static_assert): Likewise, for matching_parens.\n+\t(cp_parser_decltype): Likewise.\n+\t(cp_parser_operator): Likewise.\n+\t(cp_parser_enum_specifier): Likewise.\n+\t(cp_parser_namespace_definition): Likewise.\n+\t(cp_parser_direct_declarator): Likewise.\n+\t(cp_parser_braced_list): Likewise.\n+\t(cp_parser_class_specifier_1): Likewise, for matching_braces.\n+\t(cp_parser_constant_initializer): Likewise.\n+\t(cp_parser_noexcept_specification_opt): Likewise, for\n+\tmatching_parens.\n+\t(cp_parser_exception_specification_opt): Likewise.\n+\t(cp_parser_handler): Likewise.\n+\t(cp_parser_asm_specification_opt): Likewise.\n+\t(cp_parser_asm_operand_list): Likewise.\n+\t(cp_parser_gnu_attributes_opt): Likewise.\n+\t(cp_parser_std_attribute_spec): Likewise.\n+\t(cp_parser_requirement_parameter_list): Likewise.\n+\t(cp_parser_requirement_body): Likewise, for matching_braces.\n+\t(cp_parser_compound_requirement): Likewise.\n+\t(cp_parser_template_introduction): Likewise.\n+\t(cp_parser_sizeof_pack): Likewise, for matching_parens.\n+\t(cp_parser_sizeof_operand): Likewise; use it to consume the\n+\topening paren previously consumed by cp_parser_compound_literal_p.\n+\t(get_matching_symbol): New function.\n+\t(cp_parser_required_error): Add param \"matching_location\".  Remove\n+\tcalls to cp_parser_error, instead setting a non-NULL gmsgid, and\n+\thandling it if set by calling c_parse_error, potentially with a\n+\tsecondary location if matching_location was set.\n+\t(cp_parser_require): Add param \"matching_location\", with a default\n+\tvalue of UNKNOWN_LOCATION.\n+\t(cp_parser_require_keyword): Update for new param of\n+\tcp_parser_required_error.\n+\t(cp_parser_objc_encode_expression): Update to class matching_parens\n+\tas above.\n+\t(cp_parser_objc_defs_expression): Likewise.\n+\t(cp_parser_objc_protocol_expression): Likewise.\n+\t(cp_parser_objc_selector_expression): Likewise.\n+\t(cp_parser_objc_typename): Likewise.\n+\t(cp_parser_objc_superclass_or_category): Likewise.\n+\t(cp_parser_objc_try_catch_finally_statement): Likewise.\n+\t(cp_parser_objc_synchronized_statement): Likewise.\n+\t(cp_parser_objc_at_property_declaration): Likewise.\n+\t(cp_parser_oacc_single_int_clause): Likewise.\n+\t(cp_parser_oacc_shape_clause): Likewise.\n+\t(cp_parser_omp_clause_collapse): Likewise.\n+\t(cp_parser_omp_clause_default): Likewise.\n+\t(cp_parser_omp_clause_final): Likewise.\n+\t(cp_parser_omp_clause_if): Likewise.\n+\t(cp_parser_omp_clause_num_threads): Likewise.\n+\t(cp_parser_omp_clause_num_tasks): Likewise.\n+\t(cp_parser_omp_clause_grainsize): Likewise.\n+\t(cp_parser_omp_clause_priority): Likewise.\n+\t(cp_parser_omp_clause_hint): Likewise.\n+\t(cp_parser_omp_clause_defaultmap): Likewise.\n+\t(cp_parser_omp_clause_ordered): Likewise.\n+\t(cp_parser_omp_clause_schedule): Likewise.\n+\t(cp_parser_omp_clause_num_teams): Likewise.\n+\t(cp_parser_omp_clause_thread_limit): Likewise.\n+\t(cp_parser_omp_clause_aligned): Likewise.\n+\t(cp_parser_omp_clause_linear): Likewise.\n+\t(cp_parser_omp_clause_safelen): Likewise.\n+\t(cp_parser_omp_clause_simdlen): Likewise.\n+\t(cp_parser_omp_clause_depend): Likewise.\n+\t(cp_parser_omp_clause_device): Likewise.\n+\t(cp_parser_omp_clause_dist_schedule): Likewise.\n+\t(cp_parser_oacc_clause_async): Likewise.\n+\t(cp_parser_omp_critical): Likewise.\n+\t(cp_parser_omp_for_loop): Likewise.\n+\t(cp_parser_omp_sections_scope): Likewise.\n+\t(cp_parser_omp_declare_reduction_exprs): Likewise.\n+\tUpdate for new param to cp_parser_required_error.\n+\t(cp_parser_oacc_routine): Likewise.\n+\t(cp_parser_transaction_expression): Likewise.\n+\t(cp_parser_cilk_simd_vectorlength): Likewise.\n+\n 2017-08-09  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/81525 - wrong constant value with generic lambda"}, {"sha": "b849824fcd0fb441f4fe7a26557bb76756230097", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 521, "deletions": 290, "changes": 811, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -2551,9 +2551,9 @@ static void set_and_check_decl_spec_loc\n static bool cp_parser_friend_p\n   (const cp_decl_specifier_seq *);\n static void cp_parser_required_error\n-  (cp_parser *, required_token, bool);\n+  (cp_parser *, required_token, bool, location_t);\n static cp_token *cp_parser_require\n-  (cp_parser *, enum cpp_ttype, required_token);\n+  (cp_parser *, enum cpp_ttype, required_token, location_t = UNKNOWN_LOCATION);\n static cp_token *cp_parser_require_keyword\n   (cp_parser *, enum rid, required_token);\n static bool cp_parser_token_starts_function_definition_p\n@@ -2804,12 +2804,13 @@ cp_parser_error (cp_parser* parser, const char* gmsgid)\n \t    }\n \t}\n \n+      rich_location richloc (line_table, input_location);\n       c_parse_error (gmsgid,\n \t\t     /* Because c_parser_error does not understand\n \t\t\tCPP_KEYWORD, keywords are treated like\n \t\t\tidentifiers.  */\n \t\t     (token->type == CPP_KEYWORD ? CPP_NAME : token->type),\n-\t\t     token->u.value, token->flags);\n+\t\t     token->u.value, token->flags, &richloc);\n     }\n }\n \n@@ -4503,6 +4504,90 @@ struct tentative_firewall\n   }\n };\n \n+/* Some tokens naturally come in pairs e.g.'(' and ')'.\n+   This class is for tracking such a matching pair of symbols.\n+   In particular, it tracks the location of the first token,\n+   so that if the second token is missing, we can highlight the\n+   location of the first token when notifying the user about the\n+   problem.  */\n+\n+template <typename traits_t>\n+class token_pair\n+{\n+ public:\n+  /* token_pair's ctor.  */\n+  token_pair () : m_open_loc (UNKNOWN_LOCATION) {}\n+\n+  /* If the next token is the opening symbol for this pair, consume it and\n+     return true.\n+     Otherwise, issue an error and return false.\n+     In either case, record the location of the opening token.  */\n+\n+  bool require_open (cp_parser *parser)\n+  {\n+    m_open_loc = cp_lexer_peek_token (parser->lexer)->location;\n+    return cp_parser_require (parser, traits_t::open_token_type,\n+\t\t\t      traits_t::required_token_open);\n+  }\n+\n+  /* Consume the next token from PARSER, recording its location as\n+     that of the opening token within the pair.  */\n+\n+  cp_token * consume_open (cp_parser *parser)\n+  {\n+    cp_token *tok = cp_lexer_consume_token (parser->lexer);\n+    gcc_assert (tok->type == traits_t::open_token_type);\n+    m_open_loc = tok->location;\n+    return tok;\n+  }\n+\n+  /* If the next token is the closing symbol for this pair, consume it\n+     and return it.\n+     Otherwise, issue an error, highlighting the location of the\n+     corresponding opening token, and return NULL.  */\n+\n+  cp_token *require_close (cp_parser *parser) const\n+  {\n+    return cp_parser_require (parser, traits_t::close_token_type,\n+\t\t\t      traits_t::required_token_close,\n+\t\t\t      m_open_loc);\n+  }\n+\n+ private:\n+  location_t m_open_loc;\n+};\n+\n+/* Traits for token_pair<T> for tracking matching pairs of parentheses.  */\n+\n+struct matching_paren_traits\n+{\n+  static const enum cpp_ttype open_token_type = CPP_OPEN_PAREN;\n+  static const enum required_token required_token_open  = RT_OPEN_PAREN;\n+  static const enum cpp_ttype close_token_type = CPP_CLOSE_PAREN;\n+  static const enum required_token required_token_close = RT_CLOSE_PAREN;\n+};\n+\n+/* \"matching_parens\" is a token_pair<T> class for tracking matching\n+   pairs of parentheses.  */\n+\n+typedef token_pair<matching_paren_traits> matching_parens;\n+\n+/* Traits for token_pair<T> for tracking matching pairs of braces.  */\n+\n+struct matching_brace_traits\n+{\n+  static const enum cpp_ttype open_token_type = CPP_OPEN_BRACE;\n+  static const enum required_token required_token_open = RT_OPEN_BRACE;\n+  static const enum cpp_ttype close_token_type = CPP_CLOSE_BRACE;\n+  static const enum required_token required_token_close = RT_CLOSE_BRACE;\n+};\n+\n+/* \"matching_braces\" is a token_pair<T> class for tracking matching\n+   pairs of braces.  */\n+\n+typedef token_pair<matching_brace_traits> matching_braces;\n+\n+\n /* Parse a GNU statement-expression, i.e. ({ stmts }), except for the\n    enclosing parentheses.  */\n \n@@ -4513,7 +4598,8 @@ cp_parser_statement_expr (cp_parser *parser)\n \n   /* Consume the '('.  */\n   location_t start_loc = cp_lexer_peek_token (parser->lexer)->location;\n-  cp_lexer_consume_token (parser->lexer);\n+  matching_parens parens;\n+  parens.consume_open (parser);\n   /* Start the statement-expression.  */\n   tree expr = begin_stmt_expr ();\n   /* Parse the compound-statement.  */\n@@ -4522,7 +4608,7 @@ cp_parser_statement_expr (cp_parser *parser)\n   expr = finish_stmt_expr (expr, false);\n   /* Consume the ')'.  */\n   location_t finish_loc = cp_lexer_peek_token (parser->lexer)->location;\n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+  if (!parens.require_close (parser))\n     cp_parser_skip_to_end_of_statement (parser);\n \n   cp_parser_end_tentative_firewall (parser, start, expr);\n@@ -4928,7 +5014,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \tlocation_t open_paren_loc = token->location;\n \n \t/* Consume the `('.  */\n-\tcp_lexer_consume_token (parser->lexer);\n+\tmatching_parens parens;\n+\tparens.consume_open (parser);\n \t/* Within a parenthesized expression, a `>' token is always\n \t   the greater-than operator.  */\n \tsaved_greater_than_is_operator_p\n@@ -4976,7 +5063,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \ttoken = cp_lexer_peek_token (parser->lexer);\n \tlocation_t close_paren_loc = token->location;\n \texpr.set_range (open_paren_loc, close_paren_loc);\n-\tif (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN)\n+\tif (!parens.require_close (parser)\n \t    && !cp_parser_uncommitted_to_tentative_parse_p (parser))\n \t  cp_parser_skip_to_end_of_statement (parser);\n \n@@ -5098,7 +5185,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t       `va_arg'.  Consume the `__builtin_va_arg' token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n \t    /* Look for the opening `('.  */\n-\t    cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+\t    matching_parens parens;\n+\t    parens.require_open (parser);\n \t    /* Now, parse the assignment-expression.  */\n \t    expression = cp_parser_assignment_expression (parser);\n \t    /* Look for the `,'.  */\n@@ -5112,7 +5200,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    /* Look for the closing `)'.  */\n \t    location_t finish_loc\n \t      = cp_lexer_peek_token (parser->lexer)->location;\n-\t    cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\t    parens.require_close (parser);\n \t    /* Using `va_arg' in a constant-expression is not\n \t       allowed.  */\n \t    if (cp_parser_non_integral_constant_expression (parser,\n@@ -6345,9 +6433,6 @@ cp_parser_qualifying_entity (cp_parser *parser,\n static bool\n cp_parser_compound_literal_p (cp_parser *parser)\n {\n-  /* Consume the `('.  */\n-  cp_lexer_consume_token (parser->lexer);\n-\n   cp_lexer_save_tokens (parser->lexer);\n \n   /* Skip tokens until the next token is a closing parenthesis.\n@@ -6465,7 +6550,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \tparser->greater_than_is_operator_p = true;\n \n \t/* And the expression which is being cast.  */\n-\tcp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+\tmatching_parens parens;\n+\tparens.require_open (parser);\n \texpression = cp_parser_expression (parser, & idk, /*cast_p=*/true);\n \tcp_token *close_paren = cp_parser_require (parser, CPP_CLOSE_PAREN,\n \t\t\t\t\t\t   RT_CLOSE_PAREN);\n@@ -6526,7 +6612,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t/* Consume the `typeid' token.  */\n \tcp_lexer_consume_token (parser->lexer);\n \t/* Look for the `(' token.  */\n-\tcp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+\tmatching_parens parens;\n+\tparens.require_open (parser);\n \t/* Types cannot be defined in a `typeid' expression.  */\n \tsaved_message = parser->type_definition_forbidden_message;\n \tparser->type_definition_forbidden_message\n@@ -6542,8 +6629,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t/* Look for the `)' token.  Otherwise, we can't be sure that\n \t   we're not looking at an expression: consider `typeid (int\n \t   (3))', for example.  */\n-\tcp_token *close_paren = cp_parser_require (parser, CPP_CLOSE_PAREN,\n-\t\t\t\t\t\t   RT_CLOSE_PAREN);\n+\tcp_token *close_paren = parens.require_close (parser);\n \t/* If all went well, simply lookup the type-id.  */\n \tif (cp_parser_parse_definitely (parser))\n \t  postfix_expression = get_typeid (type, tf_warning_or_error);\n@@ -6557,8 +6643,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    /* Compute its typeid.  */\n \t    postfix_expression = build_typeid (expression, tf_warning_or_error);\n \t    /* Look for the `)' token.  */\n-\t    close_paren\n-\t      = cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\t    close_paren = parens.require_close (parser);\n \t  }\n \t/* Restore the saved message.  */\n \tparser->type_definition_forbidden_message = saved_message;\n@@ -6759,6 +6844,9 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \n \t    cp_parser_parse_tentatively (parser);\n \n+\t    matching_parens parens;\n+\t    parens.consume_open (parser);\n+\n \t    /* Avoid calling cp_parser_type_id pointlessly, see comment\n \t       in cp_parser_cast_expression about c++/29234.  */\n \t    if (!cp_parser_compound_literal_p (parser))\n@@ -6770,8 +6858,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\tparser->in_type_id_in_expr_p = true;\n \t\ttype = cp_parser_type_id (parser);\n \t\tparser->in_type_id_in_expr_p = saved_in_type_id_in_expr_p;\n-\t\t/* Look for the `)'.  */\n-\t\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\t\tparens.require_close (parser);\n \t      }\n \n \t    /* If things aren't going well, there's no need to\n@@ -7561,7 +7648,8 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n   if (non_constant_p)\n     *non_constant_p = false;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return NULL;\n \n   expression_list = make_tree_vector ();\n@@ -7657,7 +7745,7 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n   if (close_paren_loc)\n     *close_paren_loc = cp_lexer_peek_token (parser->lexer)->location;\n \n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+  if (!parens.require_close (parser))\n     {\n       int ending;\n \n@@ -7957,7 +8045,8 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \t    bool saved_greater_than_is_operator_p;\n \n \t    cp_lexer_consume_token (parser->lexer);\n-\t    cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+\t    matching_parens parens;\n+\t    parens.require_open (parser);\n \n \t    saved_message = parser->type_definition_forbidden_message;\n \t    parser->type_definition_forbidden_message\n@@ -7991,7 +8080,7 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \n \t    parser->type_definition_forbidden_message = saved_message;\n \n-\t    cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\t    parens.require_close (parser);\n \t    return finish_noexcept_expr (expr, tf_warning_or_error);\n \t  }\n \n@@ -8235,7 +8324,8 @@ cp_parser_new_expression (cp_parser* parser)\n       const char *saved_message = parser->type_definition_forbidden_message;\n \n       /* Consume the `('.  */\n-      cp_lexer_consume_token (parser->lexer);\n+      matching_parens parens;\n+      parens.consume_open (parser);\n \n       /* Parse the type-id.  */\n       parser->type_definition_forbidden_message\n@@ -8247,7 +8337,7 @@ cp_parser_new_expression (cp_parser* parser)\n       parser->type_definition_forbidden_message = saved_message;\n \n       /* Look for the closing `)'.  */\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+      parens.require_close (parser);\n       token = cp_lexer_peek_token (parser->lexer);\n       /* There should not be a direct-new-declarator in this production,\n \t but GCC used to allowed this, so we check and emit a sensible error\n@@ -8787,7 +8877,8 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n       parser->type_definition_forbidden_message\n \t= G_(\"types may not be defined in casts\");\n       /* Consume the `('.  */\n-      cp_token *open_paren = cp_lexer_consume_token (parser->lexer);\n+      matching_parens parens;\n+      cp_token *open_paren = parens.consume_open (parser);\n       location_t open_paren_loc = open_paren->location;\n       location_t close_paren_loc = UNKNOWN_LOCATION;\n \n@@ -8852,8 +8943,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  /* Look for the type-id.  */\n \t  type = cp_parser_type_id (parser);\n \t  /* Look for the closing `)'.  */\n-\t  cp_token *close_paren\n-\t    = cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\t  cp_token *close_paren = parens.require_close (parser);\n \t  if (close_paren)\n \t    close_paren_loc = close_paren->location;\n \t  parser->in_type_id_in_expr_p = saved_in_type_id_in_expr_p;\n@@ -9638,7 +9728,8 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n   /* Consume the \"__builtin_offsetof\" token.  */\n   cp_lexer_consume_token (parser->lexer);\n   /* Consume the opening `('.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  matching_parens parens;\n+  parens.require_open (parser);\n   /* Parse the type-id.  */\n   location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n   type = cp_parser_type_id (parser);\n@@ -9688,7 +9779,7 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n \tdefault:\n \t  /* Error.  We know the following require will fail, but\n \t     that gives the proper error message.  */\n-\t  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\t  parens.require_close (parser);\n \t  cp_parser_skip_to_closing_parenthesis (parser, true, false, true);\n \t  expr = error_mark_node;\n \t  goto failure;\n@@ -9834,7 +9925,8 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n   /* Consume the token.  */\n   cp_lexer_consume_token (parser->lexer);\n \n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  matching_parens parens;\n+  parens.require_open (parser);\n \n   {\n     type_id_in_expr_sentinel s (parser);\n@@ -9873,7 +9965,7 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n \t}\n     }\n \n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+  parens.require_close (parser);\n \n   /* Complete the trait expression, which may mean either processing\n      the trait expr now or saving it for template instantiation.  */\n@@ -10354,7 +10446,8 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n      opening parenthesis if present.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n-      cp_lexer_consume_token (parser->lexer);\n+      matching_parens parens;\n+      parens.consume_open (parser);\n \n       begin_scope (sk_function_parms, /*entity=*/NULL_TREE);\n \n@@ -10369,7 +10462,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \t    pedwarn (DECL_SOURCE_LOCATION (TREE_VALUE (t)), OPT_Wpedantic,\n \t\t     \"default argument specified for lambda parameter\");\n \n-      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+      parens.require_close (parser);\n \n       attributes = cp_parser_attributes_opt (parser);\n \n@@ -10526,7 +10619,8 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n     start_lambda_scope (fco);\n     body = begin_function_body ();\n \n-    if (!cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n+    matching_braces braces;\n+    if (!braces.require_open (parser))\n       goto out;\n \n     /* Push the proxies for any explicit captures.  */\n@@ -10567,7 +10661,7 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n \texpr = cp_parser_expression (parser, &idk);\n \n \tcp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n-\tcp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+\tbraces.require_close (parser);\n \n \tif (cp_parser_parse_definitely (parser))\n \t  {\n@@ -10591,7 +10685,7 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n \twhile (cp_lexer_next_token_is_keyword (parser->lexer, RID_LABEL))\n \t  cp_parser_label_declaration (parser);\n \tcp_parser_statement_seq_opt (parser, NULL_TREE);\n-\tcp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+\tbraces.require_close (parser);\n       }\n \n     finish_compound_stmt (compound_stmt);\n@@ -11127,9 +11221,10 @@ cp_parser_compound_statement (cp_parser *parser, tree in_statement_expr,\n \t\t\t      int bcs_flags, bool function_body)\n {\n   tree compound_stmt;\n+  matching_braces braces;\n \n   /* Consume the `{'.  */\n-  if (!cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n+  if (!braces.require_open (parser))\n     return error_mark_node;\n   if (DECL_DECLARED_CONSTEXPR_P (current_function_decl)\n       && !function_body && cxx_dialect < cxx14)\n@@ -11145,7 +11240,7 @@ cp_parser_compound_statement (cp_parser *parser, tree in_statement_expr,\n   /* Finish the compound-statement.  */\n   finish_compound_stmt (compound_stmt);\n   /* Consume the `}'.  */\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+  braces.require_close (parser);\n \n   return compound_stmt;\n }\n@@ -11266,7 +11361,8 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p,\n \t  }\n \n \t/* Look for the `('.  */\n-\tif (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+\tmatching_parens parens;\n+\tif (!parens.require_open (parser))\n \t  {\n \t    cp_parser_skip_to_end_of_statement (parser);\n \t    return error_mark_node;\n@@ -11295,7 +11391,7 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p,\n \t/* Parse the condition.  */\n \tcondition = cp_parser_condition (parser);\n \t/* Look for the `)'.  */\n-\tif (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+\tif (!parens.require_close (parser))\n \t  cp_parser_skip_to_closing_parenthesis (parser, true, false,\n \t\t\t\t\t\t /*consume_paren=*/true);\n \n@@ -12082,12 +12178,13 @@ cp_parser_iteration_statement (cp_parser* parser, bool *if_p, bool ivdep)\n \t/* Begin the while-statement.  */\n \tstatement = begin_while_stmt ();\n \t/* Look for the `('.  */\n-\tcp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+\tmatching_parens parens;\n+\tparens.require_open (parser);\n \t/* Parse the condition.  */\n \tcondition = cp_parser_condition (parser);\n \tfinish_while_stmt_cond (condition, statement, ivdep);\n \t/* Look for the `)'.  */\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\tparens.require_close (parser);\n \t/* Parse the dependent statement.  */\n \tparser->in_statement = IN_ITERATION_STMT;\n \tcp_parser_already_scoped_statement (parser, if_p, guard_tinfo);\n@@ -12111,13 +12208,14 @@ cp_parser_iteration_statement (cp_parser* parser, bool *if_p, bool ivdep)\n \t/* Look for the `while' keyword.  */\n \tcp_parser_require_keyword (parser, RID_WHILE, RT_WHILE);\n \t/* Look for the `('.  */\n-\tcp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+\tmatching_parens parens;\n+\tparens.require_open (parser);\n \t/* Parse the expression.  */\n \texpression = cp_parser_expression (parser);\n \t/* We're done with the do-statement.  */\n \tfinish_do_stmt (expression, statement, ivdep);\n \t/* Look for the `)'.  */\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\tparens.require_close (parser);\n \t/* Look for the `;'.  */\n \tcp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n       }\n@@ -12126,12 +12224,13 @@ cp_parser_iteration_statement (cp_parser* parser, bool *if_p, bool ivdep)\n     case RID_FOR:\n       {\n \t/* Look for the `('.  */\n-\tcp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+\tmatching_parens parens;\n+\tparens.require_open (parser);\n \n \tstatement = cp_parser_for (parser, ivdep);\n \n \t/* Look for the `)'.  */\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\tparens.require_close (parser);\n \n \t/* Parse the body of the for-statement.  */\n \tparser->in_statement = IN_ITERATION_STMT;\n@@ -12481,13 +12580,14 @@ cp_parser_already_scoped_statement (cp_parser* parser, bool *if_p,\n     {\n       /* Avoid calling cp_parser_compound_statement, so that we\n \t don't create a new scope.  Do everything else by hand.  */\n-      cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE);\n+      matching_braces braces;\n+      braces.require_open (parser);\n       /* If the next keyword is `__label__' we have a label declaration.  */\n       while (cp_lexer_next_token_is_keyword (parser->lexer, RID_LABEL))\n \tcp_parser_label_declaration (parser);\n       /* Parse an (optional) statement-seq.  */\n       cp_parser_statement_seq_opt (parser, NULL_TREE);\n-      cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+      braces.require_close (parser);\n     }\n }\n \n@@ -13714,11 +13814,12 @@ cp_parser_linkage_specification (cp_parser* parser)\n       cp_ensure_no_oacc_routine (parser);\n \n       /* Consume the `{' token.  */\n-      cp_lexer_consume_token (parser->lexer);\n+      matching_braces braces;\n+      braces.consume_open (parser)->location;\n       /* Parse the declarations.  */\n       cp_parser_declaration_seq_opt (parser);\n       /* Look for the closing `}'.  */\n-      cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+      braces.require_close (parser);\n     }\n   /* Otherwise, there's just one declaration.  */\n   else\n@@ -13770,7 +13871,8 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n     cp_parser_commit_to_tentative_parse (parser);\n \n   /* Parse the `(' starting the static assertion condition.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  matching_parens parens;\n+  parens.require_open (parser);\n \n   /* Parse the constant-expression.  Allow a non-constant expression\n      here in order to give better diagnostics in finish_static_assert.  */\n@@ -13802,7 +13904,7 @@ cp_parser_static_assert(cp_parser *parser, bool member_p)\n                                 \t  /*wide_ok=*/true);\n \n       /* A `)' completes the static assertion.  */\n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      if (!parens.require_close (parser))\n \tcp_parser_skip_to_closing_parenthesis (parser, \n                                                /*recovering=*/true, \n                                                /*or_comma=*/false,\n@@ -13956,15 +14058,16 @@ cp_parser_decltype (cp_parser *parser)\n     return error_mark_node;\n \n   /* Parse the opening `('.  */\n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return error_mark_node;\n \n   /* decltype (auto) */\n   if (cxx_dialect >= cxx14\n       && cp_lexer_next_token_is_keyword (parser->lexer, RID_AUTO))\n     {\n       cp_lexer_consume_token (parser->lexer);\n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      if (!parens.require_close (parser))\n \treturn error_mark_node;\n       expr = make_decltype_auto ();\n       AUTO_IS_DECLTYPE (expr) = true;\n@@ -14019,7 +14122,7 @@ cp_parser_decltype (cp_parser *parser)\n     = saved_non_integral_constant_expression_p;\n \n   /* Parse to the closing `)'.  */\n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+  if (!parens.require_close (parser))\n     {\n       cp_parser_skip_to_closing_parenthesis (parser, true, false,\n \t\t\t\t\t     /*consume_paren=*/true);\n@@ -14718,11 +14821,14 @@ cp_parser_operator (cp_parser* parser)\n       break;\n \n     case CPP_OPEN_PAREN:\n-      /* Consume the `('.  */\n-      cp_lexer_consume_token (parser->lexer);\n-      /* Look for the matching `)'.  */\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-      return cp_operator_id (CALL_EXPR);\n+      {\n+        /* Consume the `('.  */\n+        matching_parens parens;\n+        parens.consume_open (parser);\n+        /* Look for the matching `)'.  */\n+        parens.require_close (parser);\n+        return cp_operator_id (CALL_EXPR);\n+      }\n \n     case CPP_OPEN_SQUARE:\n       /* Consume the `['.  */\n@@ -18095,7 +18201,8 @@ cp_parser_enum_specifier (cp_parser* parser)\n \tbegin_scope (sk_scoped_enum, type);\n \n       /* Consume the opening brace.  */\n-      cp_lexer_consume_token (parser->lexer);\n+      matching_braces braces;\n+      braces.consume_open (parser);\n \n       if (type == error_mark_node)\n \t; /* Nothing to add */\n@@ -18128,7 +18235,7 @@ cp_parser_enum_specifier (cp_parser* parser)\n \tcp_parser_enumerator_list (parser, type);\n \n       /* Consume the final '}'.  */\n-      cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+      braces.require_close (parser);\n \n       if (scoped_enum_p)\n \tfinish_scope ();\n@@ -18421,13 +18528,14 @@ cp_parser_namespace_definition (cp_parser* parser)\n   warning  (OPT_Wnamespaces, \"namespace %qD entered\", current_namespace);\n \n   /* Look for the `{' to validate starting the namespace.  */\n-  if (cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n+  matching_braces braces;\n+  if (braces.require_open (parser))\n     {\n       /* Parse the body of the namespace.  */\n       cp_parser_namespace_body (parser);\n \n       /* Look for the final `}'.  */\n-      cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+      braces.require_close (parser);\n     }\n \n   if (has_visibility)\n@@ -19808,7 +19916,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\tcp_parser_parse_tentatively (parser);\n \n \t      /* Consume the `('.  */\n-\t      cp_lexer_consume_token (parser->lexer);\n+\t      matching_parens parens;\n+\t      parens.consume_open (parser);\n \t      if (first)\n \t\t{\n \t\t  /* If this is going to be an abstract declarator, we're\n@@ -19823,7 +19932,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      params = cp_parser_parameter_declaration_clause (parser);\n \n \t      /* Consume the `)'.  */\n-\t      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\t      parens.require_close (parser);\n \n \t      /* If all went well, parse the cv-qualifier-seq,\n \t\t ref-qualifier and the exception-specification.  */\n@@ -19919,7 +20028,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      parser->in_declarator_p = saved_in_declarator_p;\n \n \t      /* Consume the `('.  */\n-\t      cp_lexer_consume_token (parser->lexer);\n+\t      matching_parens parens;\n+\t      parens.consume_open (parser);\n \t      /* Parse the nested declarator.  */\n \t      saved_in_type_id_in_expr_p = parser->in_type_id_in_expr_p;\n \t      parser->in_type_id_in_expr_p = true;\n@@ -19930,7 +20040,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      parser->in_type_id_in_expr_p = saved_in_type_id_in_expr_p;\n \t      first = false;\n \t      /* Expect a `)'.  */\n-\t      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+\t      if (!parens.require_close (parser))\n \t\tdeclarator = cp_error_declarator;\n \t      if (declarator == cp_error_declarator)\n \t\tbreak;\n@@ -21778,7 +21888,8 @@ cp_parser_braced_list (cp_parser* parser, bool* non_constant_p)\n   location_t start_loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   /* Consume the `{' token.  */\n-  cp_lexer_consume_token (parser->lexer);\n+  matching_braces braces;\n+  braces.consume_open (parser);\n   /* Create a CONSTRUCTOR to represent the braced-initializer.  */\n   initializer = make_node (CONSTRUCTOR);\n   /* If it's not a `}', then there is a non-trivial initializer.  */\n@@ -21795,7 +21906,7 @@ cp_parser_braced_list (cp_parser* parser, bool* non_constant_p)\n     *non_constant_p = false;\n   /* Now, there should be a trailing `}'.  */\n   location_t finish_loc = cp_lexer_peek_token (parser->lexer)->location;\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+  braces.require_close (parser);\n   TREE_TYPE (initializer) = init_list_type_node;\n \n   cp_expr result (initializer);\n@@ -22222,7 +22333,8 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n     }\n \n   /* Look for the `{'.  */\n-  if (!cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n+  matching_braces braces;\n+  if (!braces.require_open (parser))\n     {\n       pop_deferring_access_checks ();\n       return error_mark_node;\n@@ -22274,7 +22386,7 @@ cp_parser_class_specifier_1 (cp_parser* parser)\n     cp_parser_member_specification_opt (parser);\n \n   /* Look for the trailing `}'.  */\n-  closing_brace = cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+  closing_brace = braces.require_close (parser);\n   /* Look for trailing attributes to apply to this class.  */\n   if (cp_parser_allow_gnu_extensions_p (parser))\n     attributes = cp_parser_gnu_attributes_opt (parser);\n@@ -23753,11 +23865,12 @@ cp_parser_constant_initializer (cp_parser* parser)\n       cp_parser_error (parser,\n \t\t       \"a brace-enclosed initializer is not allowed here\");\n       /* Consume the opening brace.  */\n-      cp_lexer_consume_token (parser->lexer);\n+      matching_braces braces;\n+      braces.consume_open (parser);\n       /* Skip the initializer.  */\n       cp_parser_skip_to_closing_brace (parser);\n       /* Look for the trailing `}'.  */\n-      cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+      braces.require_close (parser);\n \n       return error_mark_node;\n     }\n@@ -24013,7 +24126,8 @@ cp_parser_noexcept_specification_opt (cp_parser* parser,\n \n       if (cp_lexer_peek_token (parser->lexer)->type == CPP_OPEN_PAREN)\n \t{\n-\t  cp_lexer_consume_token (parser->lexer);\n+\t  matching_parens parens;\n+\t  parens.consume_open (parser);\n \n \t  if (require_constexpr)\n \t    {\n@@ -24033,7 +24147,7 @@ cp_parser_noexcept_specification_opt (cp_parser* parser,\n \t      *consumed_expr = true;\n \t    }\n \n-\t  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\t  parens.require_close (parser);\n \t}\n       else\n \t{\n@@ -24087,7 +24201,8 @@ cp_parser_exception_specification_opt (cp_parser* parser)\n   cp_lexer_consume_token (parser->lexer);\n \n   /* Look for the `('.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  matching_parens parens;\n+  parens.require_open (parser);\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -24123,7 +24238,7 @@ cp_parser_exception_specification_opt (cp_parser* parser)\n     type_id_list = empty_except_spec;\n \n   /* Look for the `)'.  */\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+  parens.require_close (parser);\n \n   return type_id_list;\n }\n@@ -24270,10 +24385,11 @@ cp_parser_handler (cp_parser* parser)\n \n   cp_parser_require_keyword (parser, RID_CATCH, RT_CATCH);\n   handler = begin_handler ();\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  matching_parens parens;\n+  parens.require_open (parser);\n   declaration = cp_parser_exception_declaration (parser);\n   finish_handler_parms (declaration, handler);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+  parens.require_close (parser);\n   cp_parser_compound_statement (parser, NULL, BCS_NORMAL, false);\n   finish_handler (handler);\n }\n@@ -24389,13 +24505,14 @@ cp_parser_asm_specification_opt (cp_parser* parser)\n   /* Consume the `asm' token.  */\n   cp_lexer_consume_token (parser->lexer);\n   /* Look for the `('.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  matching_parens parens;\n+  parens.require_open (parser);\n \n   /* Look for the string-literal.  */\n   asm_specification = cp_parser_string_literal (parser, false, false);\n \n   /* Look for the `)'.  */\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+  parens.require_close (parser);\n \n   return asm_specification;\n }\n@@ -24447,11 +24564,12 @@ cp_parser_asm_operand_list (cp_parser* parser)\n       string_literal = cp_parser_string_literal (parser, false, false);\n \n       /* Look for the `('.  */\n-      cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+      matching_parens parens;\n+      parens.require_open (parser);\n       /* Parse the expression.  */\n       expression = cp_parser_expression (parser);\n       /* Look for the `)'.  */\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+      parens.require_close (parser);\n \n       if (name == error_mark_node \n \t  || string_literal == error_mark_node \n@@ -24705,8 +24823,10 @@ cp_parser_gnu_attributes_opt (cp_parser* parser)\n       /* Consume the `__attribute__' keyword.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Look for the two `(' tokens.  */\n-      cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n-      cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+      matching_parens outer_parens;\n+      outer_parens.require_open (parser);\n+      matching_parens inner_parens;\n+      inner_parens.require_open (parser);\n \n       /* Peek at the next token.  */\n       token = cp_lexer_peek_token (parser->lexer);\n@@ -24719,9 +24839,9 @@ cp_parser_gnu_attributes_opt (cp_parser* parser)\n \tattribute_list = NULL;\n \n       /* Look for the two `)' tokens.  */\n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      if (!inner_parens.require_close (parser))\n \tok = false;\n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      if (!outer_parens.require_close (parser))\n \tok = false;\n       if (!ok)\n \tcp_parser_skip_to_end_of_statement (parser);\n@@ -25148,7 +25268,8 @@ cp_parser_std_attribute_spec (cp_parser *parser)\n       cp_lexer_consume_token (parser->lexer);\n       maybe_warn_cpp0x (CPP0X_ATTRIBUTES);\n \n-      if (cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN) == NULL)\n+      matching_parens parens;\n+      if (!parens.require_open (parser))\n \t{\n \t  cp_parser_error (parser, \"expected %<(%>\");\n \t  return error_mark_node;\n@@ -25181,7 +25302,7 @@ cp_parser_std_attribute_spec (cp_parser *parser)\n       if (alignas_expr == error_mark_node)\n \treturn error_mark_node;\n \n-      if (cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN) == NULL)\n+      if (!parens.require_close (parser))\n \t{\n \t  cp_parser_error (parser, \"expected %<)%>\");\n \t  return error_mark_node;\n@@ -25413,12 +25534,13 @@ cp_parser_requires_expression (cp_parser *parser)\n static tree\n cp_parser_requirement_parameter_list (cp_parser *parser)\n {\n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return error_mark_node;\n \n   tree parms = cp_parser_parameter_declaration_clause (parser);\n \n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+  if (!parens.require_close (parser))\n     return error_mark_node;\n \n   return parms;\n@@ -25431,12 +25553,13 @@ cp_parser_requirement_parameter_list (cp_parser *parser)\n static tree\n cp_parser_requirement_body (cp_parser *parser)\n {\n-  if (!cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n+  matching_braces braces;\n+  if (!braces.require_open (parser))\n     return error_mark_node;\n \n   tree reqs = cp_parser_requirement_list (parser);\n \n-  if (!cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE))\n+  if (!braces.require_close (parser))\n     return error_mark_node;\n \n   return reqs;\n@@ -25575,14 +25698,15 @@ static tree\n cp_parser_compound_requirement (cp_parser *parser)\n {\n   /* Parse an expression enclosed in '{ }'s. */\n-  if (!cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n+  matching_braces braces;\n+  if (!braces.require_open (parser))\n     return error_mark_node;\n \n   tree expr = cp_parser_expression (parser, NULL, false, false);\n   if (!expr || expr == error_mark_node)\n     return error_mark_node;\n \n-  if (!cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE))\n+  if (!braces.require_close (parser))\n     return error_mark_node;\n \n   /* Parse the optional noexcept. */\n@@ -26653,7 +26777,8 @@ cp_parser_template_introduction (cp_parser* parser, bool member_p)\n     cp_parser_simulate_error (parser);\n \n   /* Look for opening brace for introduction.  */\n-  cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE);\n+  matching_braces braces;\n+  braces.require_open (parser);\n \n   if (!cp_parser_parse_definitely (parser))\n     return false;\n@@ -26673,7 +26798,7 @@ cp_parser_template_introduction (cp_parser* parser, bool member_p)\n     }\n \n   /* Look for closing brace for introduction.  */\n-  if (!cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE))\n+  if (!braces.require_close (parser))\n     return true;\n \n   if (tmpl_decl == error_mark_node)\n@@ -27558,9 +27683,10 @@ cp_parser_sizeof_pack (cp_parser *parser)\n   cp_lexer_consume_token (parser->lexer);\n   maybe_warn_variadic_templates ();\n \n+  matching_parens parens;\n   bool paren = cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN);\n   if (paren)\n-    cp_lexer_consume_token (parser->lexer);\n+    parens.consume_open (parser);\n   else\n     permerror (cp_lexer_peek_token (parser->lexer)->location,\n \t       \"%<sizeof...%> argument must be surrounded by parentheses\");\n@@ -27585,7 +27711,7 @@ cp_parser_sizeof_pack (cp_parser *parser)\n   PACK_EXPANSION_SIZEOF_P (expr) = true;\n \n   if (paren)\n-    cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+    parens.require_close (parser);\n \n   return expr;\n }\n@@ -27639,6 +27765,10 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n       /* We can't be sure yet whether we're looking at a type-id or an\n \t expression.  */\n       cp_parser_parse_tentatively (parser);\n+\n+      matching_parens parens;\n+      parens.consume_open (parser);\n+\n       /* Note: as a GNU Extension, compound literals are considered\n \t postfix-expressions as they are in C99, so they are valid\n \t arguments to sizeof.  See comment in cp_parser_cast_expression\n@@ -27652,7 +27782,7 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n \t  /* Look for the type-id.  */\n \t  type = cp_parser_type_id (parser);\n \t  /* Look for the closing `)'.  */\n-\t  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\t  parens.require_close (parser);\n \t  parser->in_type_id_in_expr_p = saved_in_type_id_in_expr_p;\n \t}\n \n@@ -27934,195 +28064,254 @@ cp_parser_friend_p (const cp_decl_specifier_seq *decl_specifiers)\n   return decl_spec_seq_has_spec_p (decl_specifiers, ds_friend);\n }\n \n+/* Get a description of the matching symbol to TOKEN_DESC e.g. \"(\" for\n+   RT_CLOSE_PAREN.  */\n+\n+static const char *\n+get_matching_symbol (required_token token_desc)\n+{\n+  switch (token_desc)\n+    {\n+    default:\n+      gcc_unreachable ();\n+      return \"\";\n+    case RT_CLOSE_BRACE:\n+      return \"{\";\n+    case RT_CLOSE_PAREN:\n+      return \"(\";\n+    }\n+}\n+\n /* Issue an error message indicating that TOKEN_DESC was expected.\n    If KEYWORD is true, it indicated this function is called by\n    cp_parser_require_keword and the required token can only be\n-   a indicated keyword. */\n+   a indicated keyword.\n+\n+   If MATCHING_LOCATION is not UNKNOWN_LOCATION, then highlight it\n+   within any error as the location of an \"opening\" token matching\n+   the close token TYPE (e.g. the location of the '(' when TOKEN_DESC is\n+   RT_CLOSE_PAREN).  */\n \n static void\n cp_parser_required_error (cp_parser *parser,\n \t\t\t  required_token token_desc,\n-\t\t\t  bool keyword)\n+\t\t\t  bool keyword,\n+\t\t\t  location_t matching_location)\n {\n+  if (cp_parser_simulate_error (parser))\n+    return;\n+\n+  const char *gmsgid = NULL;\n   switch (token_desc)\n     {\n       case RT_NEW:\n-\tcp_parser_error (parser, \"expected %<new%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<new%>\");\n+\tbreak;\n       case RT_DELETE:\n-\tcp_parser_error (parser, \"expected %<delete%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<delete%>\");\n+\tbreak;\n       case RT_RETURN:\n-\tcp_parser_error (parser, \"expected %<return%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<return%>\");\n+\tbreak;\n       case RT_WHILE:\n-\tcp_parser_error (parser, \"expected %<while%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<while%>\");\n+\tbreak;\n       case RT_EXTERN:\n-\tcp_parser_error (parser, \"expected %<extern%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<extern%>\");\n+\tbreak;\n       case RT_STATIC_ASSERT:\n-\tcp_parser_error (parser, \"expected %<static_assert%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<static_assert%>\");\n+\tbreak;\n       case RT_DECLTYPE:\n-\tcp_parser_error (parser, \"expected %<decltype%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<decltype%>\");\n+\tbreak;\n       case RT_OPERATOR:\n-\tcp_parser_error (parser, \"expected %<operator%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<operator%>\");\n+\tbreak;\n       case RT_CLASS:\n-\tcp_parser_error (parser, \"expected %<class%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<class%>\");\n+\tbreak;\n       case RT_TEMPLATE:\n-\tcp_parser_error (parser, \"expected %<template%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<template%>\");\n+\tbreak;\n       case RT_NAMESPACE:\n-\tcp_parser_error (parser, \"expected %<namespace%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<namespace%>\");\n+\tbreak;\n       case RT_USING:\n-\tcp_parser_error (parser, \"expected %<using%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<using%>\");\n+\tbreak;\n       case RT_ASM:\n-\tcp_parser_error (parser, \"expected %<asm%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<asm%>\");\n+\tbreak;\n       case RT_TRY:\n-\tcp_parser_error (parser, \"expected %<try%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<try%>\");\n+\tbreak;\n       case RT_CATCH:\n-\tcp_parser_error (parser, \"expected %<catch%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<catch%>\");\n+\tbreak;\n       case RT_THROW:\n-\tcp_parser_error (parser, \"expected %<throw%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<throw%>\");\n+\tbreak;\n       case RT_LABEL:\n-\tcp_parser_error (parser, \"expected %<__label__%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<__label__%>\");\n+\tbreak;\n       case RT_AT_TRY:\n-\tcp_parser_error (parser, \"expected %<@try%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<@try%>\");\n+\tbreak;\n       case RT_AT_SYNCHRONIZED:\n-\tcp_parser_error (parser, \"expected %<@synchronized%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<@synchronized%>\");\n+\tbreak;\n       case RT_AT_THROW:\n-\tcp_parser_error (parser, \"expected %<@throw%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<@throw%>\");\n+\tbreak;\n       case RT_TRANSACTION_ATOMIC:\n-\tcp_parser_error (parser, \"expected %<__transaction_atomic%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<__transaction_atomic%>\");\n+\tbreak;\n       case RT_TRANSACTION_RELAXED:\n-\tcp_parser_error (parser, \"expected %<__transaction_relaxed%>\");\n-\treturn;\n+\tgmsgid = G_(\"expected %<__transaction_relaxed%>\");\n+\tbreak;\n       default:\n \tbreak;\n     }\n-  if (!keyword)\n+\n+  if (!gmsgid && !keyword)\n     {\n       switch (token_desc)\n         {\n \t  case RT_SEMICOLON:\n-\t    cp_parser_error (parser, \"expected %<;%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<;%>\");\n+\t    break;\n \t  case RT_OPEN_PAREN:\n-\t    cp_parser_error (parser, \"expected %<(%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<(%>\");\n+\t    break;\n \t  case RT_CLOSE_BRACE:\n-\t    cp_parser_error (parser, \"expected %<}%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<}%>\");\n+\t    break;\n \t  case RT_OPEN_BRACE:\n-\t    cp_parser_error (parser, \"expected %<{%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<{%>\");\n+\t    break;\n \t  case RT_CLOSE_SQUARE:\n-\t    cp_parser_error (parser, \"expected %<]%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<]%>\");\n+\t    break;\n \t  case RT_OPEN_SQUARE:\n-\t    cp_parser_error (parser, \"expected %<[%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<[%>\");\n+\t    break;\n \t  case RT_COMMA:\n-\t    cp_parser_error (parser, \"expected %<,%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<,%>\");\n+\t    break;\n \t  case RT_SCOPE:\n-\t    cp_parser_error (parser, \"expected %<::%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<::%>\");\n+\t    break;\n \t  case RT_LESS:\n-\t    cp_parser_error (parser, \"expected %<<%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<<%>\");\n+\t    break;\n \t  case RT_GREATER:\n-\t    cp_parser_error (parser, \"expected %<>%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<>%>\");\n+\t    break;\n \t  case RT_EQ:\n-\t    cp_parser_error (parser, \"expected %<=%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<=%>\");\n+\t    break;\n \t  case RT_ELLIPSIS:\n-\t    cp_parser_error (parser, \"expected %<...%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<...%>\");\n+\t    break;\n \t  case RT_MULT:\n-\t    cp_parser_error (parser, \"expected %<*%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<*%>\");\n+\t    break;\n \t  case RT_COMPL:\n-\t    cp_parser_error (parser, \"expected %<~%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<~%>\");\n+\t    break;\n \t  case RT_COLON:\n-\t    cp_parser_error (parser, \"expected %<:%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<:%>\");\n+\t    break;\n \t  case RT_COLON_SCOPE:\n-\t    cp_parser_error (parser, \"expected %<:%> or %<::%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<:%> or %<::%>\");\n+\t    break;\n \t  case RT_CLOSE_PAREN:\n-\t    cp_parser_error (parser, \"expected %<)%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<)%>\");\n+\t    break;\n \t  case RT_COMMA_CLOSE_PAREN:\n-\t    cp_parser_error (parser, \"expected %<,%> or %<)%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<,%> or %<)%>\");\n+\t    break;\n \t  case RT_PRAGMA_EOL:\n-\t    cp_parser_error (parser, \"expected end of line\");\n-\t    return;\n+\t    gmsgid = G_(\"expected end of line\");\n+\t    break;\n \t  case RT_NAME:\n-\t    cp_parser_error (parser, \"expected identifier\");\n-\t    return;\n+\t    gmsgid = G_(\"expected identifier\");\n+\t    break;\n \t  case RT_SELECT:\n-\t    cp_parser_error (parser, \"expected selection-statement\");\n-\t    return;\n+\t    gmsgid = G_(\"expected selection-statement\");\n+\t    break;\n \t  case RT_ITERATION:\n-\t    cp_parser_error (parser, \"expected iteration-statement\");\n-\t    return;\n+\t    gmsgid = G_(\"expected iteration-statement\");\n+\t    break;\n \t  case RT_JUMP:\n-\t    cp_parser_error (parser, \"expected jump-statement\");\n-\t    return;\n+\t    gmsgid = G_(\"expected jump-statement\");\n+\t    break;\n \t  case RT_CLASS_KEY:\n-\t    cp_parser_error (parser, \"expected class-key\");\n-\t    return;\n+\t    gmsgid = G_(\"expected class-key\");\n+\t    break;\n \t  case RT_CLASS_TYPENAME_TEMPLATE:\n-\t    cp_parser_error (parser,\n-\t  \t \"expected %<class%>, %<typename%>, or %<template%>\");\n-\t    return;\n+\t    gmsgid = G_(\"expected %<class%>, %<typename%>, or %<template%>\");\n+\t    break;\n \t  default:\n \t    gcc_unreachable ();\n \t}\n     }\n-  else\n-    gcc_unreachable ();\n-}\n \n+  if (gmsgid)\n+    {\n+      /* Emulate rest of cp_parser_error.  */\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n+      cp_lexer_set_source_position_from_token (token);\n+\n+      gcc_rich_location richloc (input_location);\n+\n+      /* If matching_location != UNKNOWN_LOCATION, highlight it.\n+\t Attempt to consolidate diagnostics by printing it as a\n+\tsecondary range within the main diagnostic.  */\n+      bool added_matching_location = false;\n+      if (matching_location != UNKNOWN_LOCATION)\n+\tadded_matching_location\n+\t  = richloc.add_location_if_nearby (matching_location);\n+\n+      c_parse_error (gmsgid,\n+\t\t     (token->type == CPP_KEYWORD ? CPP_NAME : token->type),\n+\t\t     token->u.value, token->flags, &richloc);\n+\n+      /* If we weren't able to consolidate matching_location, then\n+\t print it as a secondary diagnostic.  */\n+      if (matching_location != UNKNOWN_LOCATION && !added_matching_location)\n+\tinform (matching_location, \"to match this %qs\",\n+\t\tget_matching_symbol (token_desc));\n+    }\n+}\n \n \n /* If the next token is of the indicated TYPE, consume it.  Otherwise,\n    issue an error message indicating that TOKEN_DESC was expected.\n \n    Returns the token consumed, if the token had the appropriate type.\n-   Otherwise, returns NULL.  */\n+   Otherwise, returns NULL.\n+\n+   If MATCHING_LOCATION is not UNKNOWN_LOCATION, then highlight it\n+   within any error as the location of an \"opening\" token matching\n+   the close token TYPE (e.g. the location of the '(' when TOKEN_DESC is\n+   RT_CLOSE_PAREN).  */\n \n static cp_token *\n cp_parser_require (cp_parser* parser,\n \t\t   enum cpp_ttype type,\n-\t\t   required_token token_desc)\n+\t\t   required_token token_desc,\n+\t\t   location_t matching_location)\n {\n   if (cp_lexer_next_token_is (parser->lexer, type))\n     return cp_lexer_consume_token (parser->lexer);\n   else\n     {\n       /* Output the MESSAGE -- unless we're parsing tentatively.  */\n       if (!cp_parser_simulate_error (parser))\n-\tcp_parser_required_error (parser, token_desc, /*keyword=*/false);\n+\tcp_parser_required_error (parser, token_desc, /*keyword=*/false,\n+\t\t\t\t  matching_location);\n       return NULL;\n     }\n }\n@@ -28224,7 +28413,8 @@ cp_parser_require_keyword (cp_parser* parser,\n \n   if (token && token->keyword != keyword)\n     {\n-      cp_parser_required_error (parser, token_desc, /*keyword=*/true); \n+      cp_parser_required_error (parser, token_desc, /*keyword=*/true,\n+                                UNKNOWN_LOCATION);\n       return NULL;\n     }\n \n@@ -29046,10 +29236,11 @@ cp_parser_objc_encode_expression (cp_parser* parser)\n   location_t start_loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@encode'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  matching_parens parens;\n+  parens.require_open (parser);\n   token = cp_lexer_peek_token (parser->lexer);\n   type = complete_type (cp_parser_type_id (parser));\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+  parens.require_close (parser);\n \n   if (!type)\n     {\n@@ -29091,9 +29282,10 @@ cp_parser_objc_defs_expression (cp_parser *parser)\n   tree name;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@defs'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  matching_parens parens;\n+  parens.require_open (parser);\n   name = cp_parser_identifier (parser);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+  parens.require_close (parser);\n \n   return objc_get_class_ivars (name);\n }\n@@ -29112,9 +29304,10 @@ cp_parser_objc_protocol_expression (cp_parser* parser)\n   location_t start_loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@protocol'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  matching_parens parens;\n+  parens.require_open (parser);\n   proto = cp_parser_identifier (parser);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+  parens.require_close (parser);\n \n   /* Build a location of the form:\n        @protocol(prot)\n@@ -29152,7 +29345,8 @@ cp_parser_objc_selector_expression (cp_parser* parser)\n   location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@selector'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  matching_parens parens;\n+  parens.require_open (parser);\n   token = cp_lexer_peek_token (parser->lexer);\n \n   while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON\n@@ -29199,7 +29393,7 @@ cp_parser_objc_selector_expression (cp_parser* parser)\n     }\n \n  finish_selector:\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+  parens.require_close (parser);\n \n \n   /* Build a location of the form:\n@@ -29406,7 +29600,8 @@ cp_parser_objc_typename (cp_parser* parser)\n     {\n       tree proto_quals, cp_type = NULL_TREE;\n \n-      cp_lexer_consume_token (parser->lexer);  /* Eat '('.  */\n+      matching_parens parens;\n+      parens.consume_open (parser); /* Eat '('.  */\n       proto_quals = cp_parser_objc_protocol_qualifiers (parser);\n \n       /* An ObjC type name may consist of just protocol qualifiers, in which\n@@ -29432,7 +29627,7 @@ cp_parser_objc_typename (cp_parser* parser)\n \t    }\n \t}\n \n-      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+      parens.require_close (parser);\n       type_name = build_tree_list (proto_quals, cp_type);\n     }\n \n@@ -30046,7 +30241,8 @@ cp_parser_objc_superclass_or_category (cp_parser *parser,\n     }\n   else if (next->type == CPP_OPEN_PAREN)\n     {\n-      cp_lexer_consume_token (parser->lexer);  /* Eat '('.  */\n+      matching_parens parens;\n+      parens.consume_open (parser);  /* Eat '('.  */\n \n       /* If there is no category name, and this is an @interface, we\n \t have a class extension.  */\n@@ -30058,7 +30254,7 @@ cp_parser_objc_superclass_or_category (cp_parser *parser,\n       else\n \t*categ = cp_parser_identifier (parser);\n \n-      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+      parens.require_close (parser);\n     }\n }\n \n@@ -30246,9 +30442,10 @@ cp_parser_objc_try_catch_finally_statement (cp_parser *parser)\n       cp_parameter_declarator *parm;\n       tree parameter_declaration = error_mark_node;\n       bool seen_open_paren = false;\n+      matching_parens parens;\n \n       cp_lexer_consume_token (parser->lexer);\n-      if (cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+      if (parens.require_open (parser))\n \tseen_open_paren = true;\n       if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n \t{\n@@ -30274,7 +30471,7 @@ cp_parser_objc_try_catch_finally_statement (cp_parser *parser)\n \t\t\t\t\t\t    /*attrlist=*/NULL);\n \t}\n       if (seen_open_paren)\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\tparens.require_close (parser);\n       else\n \t{\n \t  /* If there was no open parenthesis, we are recovering from\n@@ -30328,9 +30525,10 @@ cp_parser_objc_synchronized_statement (cp_parser *parser)\n \n   location = cp_lexer_peek_token (parser->lexer)->location;\n   objc_maybe_warn_exceptions (location);\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  matching_parens parens;\n+  parens.require_open (parser);\n   lock = cp_parser_expression (parser);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+  parens.require_close (parser);\n \n   /* NB: The @synchronized block needs to be wrapped in its own STATEMENT_LIST\n      node, lest it get absorbed into the surrounding block.  */\n@@ -30571,7 +30769,8 @@ cp_parser_objc_at_property_declaration (cp_parser *parser)\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n       /* Eat the '('.  */\n-      cp_lexer_consume_token (parser->lexer);\n+      matching_parens parens;\n+      parens.consume_open (parser);\n \n       while (true)\n \t{\n@@ -30659,7 +30858,7 @@ cp_parser_objc_at_property_declaration (cp_parser *parser)\n \t \"error: expected \u2018)\u2019 before \u2018,\u2019 token\".  This is because\n \t cp_parser_require, unlike the C counterpart, will produce an\n \t error even if we are in error recovery.  */\n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      if (!parens.require_close (parser))\n \t{\n \t  cp_parser_skip_to_closing_parenthesis (parser,\n \t\t\t\t\t\t /*recovering=*/true,\n@@ -31350,13 +31549,14 @@ cp_parser_oacc_single_int_clause (cp_parser *parser, omp_clause_code code,\n {\n   location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   tree t = cp_parser_assignment_expression (parser, NULL, false, false);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      || !parens.require_close (parser))\n     {\n       cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t     /*or_comma=*/false,\n@@ -31403,7 +31603,8 @@ cp_parser_oacc_shape_clause (cp_parser *parser, omp_clause_code kind,\n \n   if (cp_lexer_next_token_is (lexer, CPP_OPEN_PAREN))\n     {\n-      cp_lexer_consume_token (lexer);\n+      matching_parens parens;\n+      parens.consume_open (parser);\n \n       do\n \t{\n@@ -31477,7 +31678,7 @@ cp_parser_oacc_shape_clause (cp_parser *parser, omp_clause_code kind,\n \t}\n       while (1);\n \n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      if (!parens.require_close (parser))\n \tgoto cleanup_error;\n     }\n \n@@ -31623,12 +31824,13 @@ cp_parser_omp_clause_collapse (cp_parser *parser, tree list, location_t location\n   HOST_WIDE_INT n;\n \n   loc = cp_lexer_peek_token (parser->lexer)->location;\n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   num = cp_parser_constant_expression (parser);\n \n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+  if (!parens.require_close (parser))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -31667,7 +31869,8 @@ cp_parser_omp_clause_default (cp_parser *parser, tree list,\n   enum omp_clause_default_kind kind = OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n   tree c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n@@ -31710,7 +31913,7 @@ cp_parser_omp_clause_default (cp_parser *parser, tree list,\n     }\n \n   if (kind == OMP_CLAUSE_DEFAULT_UNSPECIFIED\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      || !parens.require_close (parser))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -31734,13 +31937,14 @@ cp_parser_omp_clause_final (cp_parser *parser, tree list, location_t location)\n {\n   tree t, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   t = cp_parser_condition (parser);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      || !parens.require_close (parser))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -31771,7 +31975,8 @@ cp_parser_omp_clause_if (cp_parser *parser, tree list, location_t location,\n   tree t, c;\n   enum tree_code if_modifier = ERROR_MARK;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   if (is_omp && cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n@@ -31854,7 +32059,7 @@ cp_parser_omp_clause_if (cp_parser *parser, tree list, location_t location,\n   t = cp_parser_condition (parser);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      || !parens.require_close (parser))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -31949,13 +32154,14 @@ cp_parser_omp_clause_num_threads (cp_parser *parser, tree list,\n {\n   tree t, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   t = cp_parser_expression (parser);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      || !parens.require_close (parser))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -31979,13 +32185,14 @@ cp_parser_omp_clause_num_tasks (cp_parser *parser, tree list,\n {\n   tree t, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   t = cp_parser_expression (parser);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      || !parens.require_close (parser))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -32009,13 +32216,14 @@ cp_parser_omp_clause_grainsize (cp_parser *parser, tree list,\n {\n   tree t, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   t = cp_parser_expression (parser);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      || !parens.require_close (parser))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -32039,13 +32247,14 @@ cp_parser_omp_clause_priority (cp_parser *parser, tree list,\n {\n   tree t, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   t = cp_parser_expression (parser);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      || !parens.require_close (parser))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -32069,13 +32278,14 @@ cp_parser_omp_clause_hint (cp_parser *parser, tree list,\n {\n   tree t, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   t = cp_parser_expression (parser);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      || !parens.require_close (parser))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -32099,7 +32309,8 @@ cp_parser_omp_clause_defaultmap (cp_parser *parser, tree list,\n   tree c, id;\n   const char *p;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   if (!cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n@@ -32131,7 +32342,7 @@ cp_parser_omp_clause_defaultmap (cp_parser *parser, tree list,\n       goto out_err;\n     }\n   cp_lexer_consume_token (parser->lexer);\n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+  if (!parens.require_close (parser))\n     goto out_err;\n \n   check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULTMAP, \"defaultmap\",\n@@ -32166,11 +32377,12 @@ cp_parser_omp_clause_ordered (cp_parser *parser,\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n-      cp_lexer_consume_token (parser->lexer);\n+      matching_parens parens;\n+      parens.consume_open (parser);\n \n       num = cp_parser_constant_expression (parser);\n \n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      if (!parens.require_close (parser))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t       /*or_comma=*/false,\n \t\t\t\t\t       /*consume_paren=*/true);\n@@ -32327,7 +32539,8 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list, location_t location\n   tree c, t;\n   int modifiers = 0, nmodifiers = 0;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   c = build_omp_clause (location, OMP_CLAUSE_SCHEDULE);\n@@ -32421,7 +32634,7 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list, location_t location\n       else\n \tOMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = t;\n \n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      if (!parens.require_close (parser))\n \tgoto resync_fail;\n     }\n   else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_COMMA_CLOSE_PAREN))\n@@ -32527,13 +32740,14 @@ cp_parser_omp_clause_num_teams (cp_parser *parser, tree list,\n {\n   tree t, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   t = cp_parser_expression (parser);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      || !parens.require_close (parser))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -32557,13 +32771,14 @@ cp_parser_omp_clause_thread_limit (cp_parser *parser, tree list,\n {\n   tree t, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   t = cp_parser_expression (parser);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      || !parens.require_close (parser))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -32588,7 +32803,8 @@ cp_parser_omp_clause_aligned (cp_parser *parser, tree list)\n   tree nlist, c, alignment = NULL_TREE;\n   bool colon;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_ALIGNED, list,\n@@ -32598,7 +32814,7 @@ cp_parser_omp_clause_aligned (cp_parser *parser, tree list)\n     {\n       alignment = cp_parser_constant_expression (parser);\n \n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      if (!parens.require_close (parser))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t       /*or_comma=*/false,\n \t\t\t\t\t       /*consume_paren=*/true);\n@@ -32629,7 +32845,8 @@ cp_parser_omp_clause_linear (cp_parser *parser, tree list,\n   bool colon;\n   enum omp_clause_linear_kind kind = OMP_CLAUSE_LINEAR_DEFAULT;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   if (!is_cilk_simd_fn\n@@ -32659,7 +32876,7 @@ cp_parser_omp_clause_linear (cp_parser *parser, tree list,\n       colon = cp_lexer_next_token_is (parser->lexer, CPP_COLON);\n       if (colon)\n \tcp_parser_require (parser, CPP_COLON, RT_COLON);\n-      else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      else if (!parens.require_close (parser))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t       /*or_comma=*/false,\n \t\t\t\t\t       /*consume_paren=*/true);\n@@ -32697,7 +32914,7 @@ cp_parser_omp_clause_linear (cp_parser *parser, tree list,\n \t  sorry (\"using parameters for %<linear%> step is not supported yet\");\n \t  step = integer_one_node;\n \t}\n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      if (!parens.require_close (parser))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t       /*or_comma=*/false,\n \t\t\t\t\t       /*consume_paren=*/true);\n@@ -32724,13 +32941,14 @@ cp_parser_omp_clause_safelen (cp_parser *parser, tree list,\n {\n   tree t, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   t = cp_parser_constant_expression (parser);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      || !parens.require_close (parser))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -32753,13 +32971,14 @@ cp_parser_omp_clause_simdlen (cp_parser *parser, tree list,\n {\n   tree t, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   t = cp_parser_constant_expression (parser);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      || !parens.require_close (parser))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -32875,7 +33094,8 @@ cp_parser_omp_clause_depend (cp_parser *parser, tree list, location_t loc)\n   tree nlist, c;\n   enum omp_clause_depend_kind kind = OMP_CLAUSE_DEPEND_INOUT;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n@@ -32907,7 +33127,7 @@ cp_parser_omp_clause_depend (cp_parser *parser, tree list, location_t loc)\n       OMP_CLAUSE_DEPEND_KIND (c) = kind;\n       OMP_CLAUSE_DECL (c) = NULL_TREE;\n       OMP_CLAUSE_CHAIN (c) = list;\n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      if (!parens.require_close (parser))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t       /*or_comma=*/false,\n \t\t\t\t\t       /*consume_paren=*/true);\n@@ -33038,13 +33258,14 @@ cp_parser_omp_clause_device (cp_parser *parser, tree list,\n {\n   tree t, c;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   t = cp_parser_expression (parser);\n \n   if (t == error_mark_node\n-      || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      || !parens.require_close (parser))\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n@@ -33069,7 +33290,8 @@ cp_parser_omp_clause_dist_schedule (cp_parser *parser, tree list,\n {\n   tree c, t;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return list;\n \n   c = build_omp_clause (location, OMP_CLAUSE_DIST_SCHEDULE);\n@@ -33088,7 +33310,7 @@ cp_parser_omp_clause_dist_schedule (cp_parser *parser, tree list,\n \tgoto resync_fail;\n       OMP_CLAUSE_DIST_SCHEDULE_CHUNK_EXPR (c) = t;\n \n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      if (!parens.require_close (parser))\n \tgoto resync_fail;\n     }\n   else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_COMMA_CLOSE_PAREN))\n@@ -33174,11 +33396,12 @@ cp_parser_oacc_clause_async (cp_parser *parser, tree list)\n \n   if (cp_lexer_peek_token (parser->lexer)->type == CPP_OPEN_PAREN)\n     {\n-      cp_lexer_consume_token (parser->lexer);\n+      matching_parens parens;\n+      parens.consume_open (parser);\n \n       t = cp_parser_expression (parser);\n       if (t == error_mark_node\n-\t  || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+\t  || !parens.require_close (parser))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t\t/*or_comma=*/false,\n \t\t\t\t\t\t/*consume_paren=*/true);\n@@ -34228,12 +34451,13 @@ cp_parser_omp_critical (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n-      cp_lexer_consume_token (parser->lexer);\n+      matching_parens parens;\n+      parens.consume_open (parser);\n \n       name = cp_parser_identifier (parser);\n \n       if (name == error_mark_node\n-\t  || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+\t  || !parens.require_close (parser))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t       /*or_comma=*/false,\n \t\t\t\t\t       /*consume_paren=*/true);\n@@ -34731,7 +34955,8 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t}\n       loc = cp_lexer_consume_token (parser->lexer)->location;\n \n-      if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+      matching_parens parens;\n+      if (!parens.require_open (parser))\n \treturn NULL;\n \n       init = orig_init = decl = real_decl = NULL;\n@@ -34863,7 +35088,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t    protected_set_expr_location (incr, input_location);\n \t}\n \n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      if (!parens.require_close (parser))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t       /*or_comma=*/false,\n \t\t\t\t\t       /*consume_paren=*/true);\n@@ -35222,7 +35447,8 @@ cp_parser_omp_sections_scope (cp_parser *parser)\n   bool error_suppress = false;\n   cp_token *tok;\n \n-  if (!cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))\n+  matching_braces braces;\n+  if (!braces.require_open (parser))\n     return NULL_TREE;\n \n   stmt = push_stmt_list ();\n@@ -35259,7 +35485,7 @@ cp_parser_omp_sections_scope (cp_parser *parser)\n       substmt = build1 (OMP_SECTION, void_type_node, substmt);\n       add_stmt (substmt);\n     }\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+  braces.require_close (parser);\n \n   substmt = pop_stmt_list (stmt);\n \n@@ -37121,7 +37347,8 @@ cp_parser_omp_declare_reduction_exprs (tree fndecl, cp_parser *parser)\n   if (strcmp (p, \"initializer\") == 0)\n     {\n       cp_lexer_consume_token (parser->lexer);\n-      if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+      matching_parens parens;\n+      if (!parens.require_open (parser))\n \treturn false;\n \n       p = \"\";\n@@ -37212,12 +37439,13 @@ cp_parser_omp_declare_reduction_exprs (tree fndecl, cp_parser *parser)\n       if (ctor)\n \tadd_decl_expr (omp_orig);\n \n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+      if (!parens.require_close (parser))\n \treturn false;\n     }\n \n   if (!cp_lexer_next_token_is (parser->lexer, CPP_PRAGMA_EOL))\n-    cp_parser_required_error (parser, RT_PRAGMA_EOL, /*keyword=*/false);\n+    cp_parser_required_error (parser, RT_PRAGMA_EOL, /*keyword=*/false,\n+                              UNKNOWN_LOCATION);\n \n   return true;\n }\n@@ -37645,7 +37873,8 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n   /* Look for optional '( name )'.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n-      cp_lexer_consume_token (parser->lexer); /* '(' */\n+      matching_parens parens;\n+      parens.consume_open (parser); /* '(' */\n \n       /* We parse the name as an id-expression.  If it resolves to\n \t anything other than a non-overloaded function at namespace\n@@ -37662,7 +37891,7 @@ cp_parser_oacc_routine (cp_parser *parser, cp_token *pragma_tok,\n \tcp_parser_name_lookup_error (parser, name, decl, NLE_NULL, name_loc);\n \n       if (decl == error_mark_node\n-\t  || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+\t  || !parens.require_close (parser))\n \t{\n \t  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n \t  parser->oacc_routine = NULL;\n@@ -38094,12 +38323,13 @@ cp_parser_transaction_expression (cp_parser *parser, enum rid keyword)\n   if (!noex || !noex_expr\n       || cp_lexer_peek_token (parser->lexer)->type == CPP_OPEN_PAREN)\n     {\n-      cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+      matching_parens parens;\n+      parens.require_open (parser);\n \n       expr = cp_parser_expression (parser);\n       expr = finish_parenthesized_expr (expr);\n \n-      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+      parens.require_close (parser);\n     }\n   else\n     {\n@@ -38687,7 +38917,8 @@ cp_parser_cilk_simd_vectorlength (cp_parser *parser, tree clauses,\n     check_no_duplicate_clause (clauses, OMP_CLAUSE_SIMDLEN, \"vectorlength\",\n \t\t\t       loc);\n \n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n     return error_mark_node;\n \n   expr = cp_parser_constant_expression (parser);\n@@ -38724,7 +38955,7 @@ cp_parser_cilk_simd_vectorlength (cp_parser *parser, tree clauses,\n \t}\n     }\n \n-  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+  if (!parens.require_close (parser))\n     return error_mark_node;\n   return clauses;\n }"}, {"sha": "869e7b020984028074857e6d14899e99d0c0be84", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -1,3 +1,15 @@\n+2017-08-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-c++-common/missing-close-symbol.c: New test case.\n+\t* c-c++-common/missing-symbol.c: New test case.\n+\t* gcc.dg/unclosed-init.c: New test case.\n+\t* g++.dg/diagnostic/unclosed-extern-c.C: New test case.\n+\t* g++.dg/diagnostic/unclosed-function.C: New test case.\n+\t* g++.dg/diagnostic/unclosed-namespace.C: New test case.\n+\t* g++.dg/diagnostic/unclosed-struct.C: New test case.\n+\t* g++.dg/parse/pragma2.C: Update to reflect movement of the\n+\t\"expected identifier\" error.\n+\n 2017-08-10  Fritz Reese <fritzoreese@gmail.com>\n \n \t* gfortran.dg/dec_d_lines_1.f: New test."}, {"sha": "85b96f28ef83365845b4face59e5813fbf3cb63b", "filename": "gcc/testsuite/c-c++-common/missing-close-symbol.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fmissing-close-symbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fmissing-close-symbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fmissing-close-symbol.c?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-options \"-fdiagnostics-show-caret\" } */\n+\n+/* Verify that the C/C++ frontends show the pertinent opening symbol when\n+   a closing symbol is missing.  */\n+\n+/* Verify that, when they are on the same line, that the opening symbol is\n+   shown as a secondary range within the main diagnostic.  */\n+\n+void test_static_assert_same_line (void)\n+{\n+  _Static_assert(sizeof(int) >= sizeof(char), \"msg\"; /* { dg-error \"expected '\\\\)' before ';' token\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   _Static_assert(sizeof(int) >= sizeof(char), \"msg\";\n+                 ~                                  ^\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Verify that, when they are on different lines, that the opening symbol is\n+   shown via a secondary diagnostic.  */\n+\n+void test_static_assert_different_line (void)\n+{\n+  _Static_assert(sizeof(int) >= sizeof(char), /* { dg-message \"to match this '\\\\('\" } */\n+\t\t \"msg\"; /* { dg-error \"expected '\\\\)' before ';' token\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+    \"msg\";\n+         ^\n+     { dg-end-multiline-output \"\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   _Static_assert(sizeof(int) >= sizeof(char),\n+                 ^\n+     { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "33a501b998864d9e78954e77da4600fb2ec266eb", "filename": "gcc/testsuite/c-c++-common/missing-symbol.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fmissing-symbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fmissing-symbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fmissing-symbol.c?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-options \"-fdiagnostics-show-caret\" } */\n+\n+extern int foo (void);\n+extern int bar (void);\n+\n+int missing_close_paren_in_switch (int i)\n+{\n+  switch (i /* { dg-message \"10: to match this '\\\\('\" } */\n+    { /* { dg-error \"5: expected '\\\\)' before '.' token\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+     {\n+     ^\n+     { dg-end-multiline-output \"\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   switch (i\n+          ^\n+     { dg-end-multiline-output \"\" } */\n+\n+    case 0:\n+      return 5;\n+    default:\n+      return i;\n+    }\n+} /* { dg-error \"1: expected\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+ }\n+ ^\n+     { dg-end-multiline-output \"\" } */\n+\n+void missing_close_paren_in_if (void)\n+{\n+  if (foo () /* { dg-line start_of_if } */\n+      && bar () \n+    { /* { dg-error \"5: expected '\\\\)' before '.' token\" } */\n+      /* { dg-begin-multiline-output \"\" }\n+     {\n+     ^\n+         { dg-end-multiline-output \"\" } */\n+      /* { dg-message \"6: to match this '\\\\('\" \"\" { target *-*-* } start_of_if } */\n+      /* { dg-begin-multiline-output \"\" }\n+   if (foo ()\n+      ^\n+      { dg-end-multiline-output \"\" } */\n+    }\n+\n+} /* { dg-error \"1: expected\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+ }\n+ ^\n+     { dg-end-multiline-output \"\" } */"}, {"sha": "fda3532266d049b3b5cad9e69ed4c6aea5545a7b", "filename": "gcc/testsuite/g++.dg/diagnostic/unclosed-extern-c.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Funclosed-extern-c.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Funclosed-extern-c.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Funclosed-extern-c.C?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -0,0 +1,3 @@\n+extern \"C\" { /* { dg-message \"12: to match this '.'\" } */\n+\n+void test (void); /* { dg-error \"17: expected '.' at end of input\" } */"}, {"sha": "e1e15504172b9c89cf1e58e45c72c065b592c8d6", "filename": "gcc/testsuite/g++.dg/diagnostic/unclosed-function.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Funclosed-function.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Funclosed-function.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Funclosed-function.C?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -0,0 +1,3 @@\n+void test (void)\n+{ /* { dg-message \"1: to match this '.'\" } */\n+  int filler; /* { dg-error \"13: expected '.' at end of input\" } */"}, {"sha": "ff113226cc7192ae10c0e9c41f381a014bdfc2af", "filename": "gcc/testsuite/g++.dg/diagnostic/unclosed-namespace.C", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Funclosed-namespace.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Funclosed-namespace.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Funclosed-namespace.C?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -0,0 +1,2 @@\n+namespace unclosed { /* { dg-message \"20: to match this '.'\" } */\n+int filler; /* { dg-error \"11: expected '.' at end of input\" } */"}, {"sha": "8c206bbecc46049f2d5269e7cc6d326e468dff61", "filename": "gcc/testsuite/g++.dg/diagnostic/unclosed-struct.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Funclosed-struct.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Funclosed-struct.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Funclosed-struct.C?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -0,0 +1,3 @@\n+struct unclosed { /* { dg-message \"17: to match this '.'\" } */\n+  int dummy; /* { dg-error \"12: expected '.' at end of input\" } */\n+  // { dg-error \"expected unqualified-id at end of input\" \"\" { target *-*-* } .-1 }"}, {"sha": "3dc5fc177886327e18ba0b414034f0d5053dbedf", "filename": "gcc/testsuite/g++.dg/parse/pragma2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpragma2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpragma2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpragma2.C?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -4,5 +4,5 @@\n // does not.\n int f(int x,\n #pragma interface  // { dg-error \"not allowed here\" }\n-      // The parser gets confused and issues an error on the next line.\n-      int y); // { dg-bogus \"\" \"\" { xfail *-*-* } } \n+      // { dg-bogus \"expected identifier\" \"\" { xfail *-*-* } .-1 }\n+      int y);"}, {"sha": "c0e4dd8da9b0fb86ffe759a43b9aedc35551d447", "filename": "gcc/testsuite/gcc.dg/unclosed-init.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fgcc.dg%2Funclosed-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32129a17506ba18a34d07145eb2c1e9f9827034f/gcc%2Ftestsuite%2Fgcc.dg%2Funclosed-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funclosed-init.c?ref=32129a17506ba18a34d07145eb2c1e9f9827034f", "patch": "@@ -0,0 +1,3 @@\n+int unclosed[] = { /* { dg-message \"18: to match this '.'\" } */\n+  42\n+ /* { dg-error \"0: expected '.' at end of input\" } */"}]}