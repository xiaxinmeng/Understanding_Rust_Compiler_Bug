{"sha": "3d7f68c6d99dedb9c00f7fc97156815bf6acaf50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q3ZjY4YzZkOTlkZWRiOWMwMGY3ZmM5NzE1NjgxNWJmNmFjYWY1MA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2016-12-15T15:52:42Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2016-12-15T15:52:42Z"}, "message": "[arm] Eliminate vfp_reg_type\n\nRemove the VFP_REGS field by converting its meanings into flag\nattributes.  The new flag attributes build on each other describing\nincreasing capabilities.  This allows us to do a better job when\ninlining functions with differing requiremetns on the fpu environment:\nwe can now inline A into B if B has at least the same register set\nproperties as B (previously we required identical register set\nproperties).\n\n\t* arm.h (vfp_reg_type): Delete.\n\t(TARGET_FPU_REGS): Delete.\n\t(arm_fpu_desc): Delete regs field.\n\t(FPU_FL_NONE, FPU_FL_NEON, FPU_FL_FP16, FPU_FL_CRYPTO): Use unsigned\n\tvalues.\n\t(FPU_FL_DBL, FPU_FL_D32): Define.\n\t(TARGET_VFPD32): Use feature test.\n\t(TARGET_VFP_SINGLE): Likewise.\n\t(TARGET_VFP_DOUBLE): Likewise.\n\t* arm-fpus.def: Update all entries for new feature bits.\n\t* arm.c (all_fpus): Update initializer macro.\n\t(arm_can_inline_p): Remove test on fpu regs.\n\nFrom-SVN: r243707", "tree": {"sha": "38aa03ba52e49d6c891954ae3700846fbdd41358", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38aa03ba52e49d6c891954ae3700846fbdd41358"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d7f68c6d99dedb9c00f7fc97156815bf6acaf50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d7f68c6d99dedb9c00f7fc97156815bf6acaf50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d7f68c6d99dedb9c00f7fc97156815bf6acaf50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d7f68c6d99dedb9c00f7fc97156815bf6acaf50/comments", "author": null, "committer": null, "parents": [{"sha": "9e9219f327f8b9bc2ebce28296e46698def176f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e9219f327f8b9bc2ebce28296e46698def176f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e9219f327f8b9bc2ebce28296e46698def176f1"}], "stats": {"total": 93, "additions": 48, "deletions": 45}, "files": [{"sha": "4e6be41cc04785a5a81fa0ecd57cafeaa1235c90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7f68c6d99dedb9c00f7fc97156815bf6acaf50/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7f68c6d99dedb9c00f7fc97156815bf6acaf50/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d7f68c6d99dedb9c00f7fc97156815bf6acaf50", "patch": "@@ -1,3 +1,18 @@\n+2016-12-15  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.h (vfp_reg_type): Delete.\n+\t(TARGET_FPU_REGS): Delete.\n+\t(arm_fpu_desc): Delete regs field.\n+\t(FPU_FL_NONE, FPU_FL_NEON, FPU_FL_FP16, FPU_FL_CRYPTO): Use unsigned\n+\tvalues.\n+\t(FPU_FL_DBL, FPU_FL_D32): Define.\n+\t(TARGET_VFPD32): Use feature test.\n+\t(TARGET_VFP_SINGLE): Likewise.\n+\t(TARGET_VFP_DOUBLE): Likewise.\n+\t* arm-fpus.def: Update all entries for new feature bits.\n+\t* arm.c (all_fpus): Update initializer macro.\n+\t(arm_can_inline_p): Remove test on fpu regs.\n+\n 2016-12-15  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.h (arm_fp_model): Delete."}, {"sha": "eca03bb69babfaf015e333d94a0d6285df331813", "filename": "gcc/config/arm/arm-fpus.def", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7f68c6d99dedb9c00f7fc97156815bf6acaf50/gcc%2Fconfig%2Farm%2Farm-fpus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7f68c6d99dedb9c00f7fc97156815bf6acaf50/gcc%2Fconfig%2Farm%2Farm-fpus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-fpus.def?ref=3d7f68c6d99dedb9c00f7fc97156815bf6acaf50", "patch": "@@ -19,31 +19,31 @@\n \n /* Before using #include to read this file, define a macro:\n \n-      ARM_FPU(NAME, REV, VFP_REGS, FEATURES)\n+      ARM_FPU(NAME, REV, FEATURES)\n \n    The arguments are the fields of struct arm_fpu_desc.\n \n    genopt.sh assumes no whitespace up to the first \",\" in each entry.  */\n \n-ARM_FPU(\"vfp\",\t\t2, VFP_REG_D16, FPU_FL_NONE)\n-ARM_FPU(\"vfpv2\",\t2, VFP_REG_D16, FPU_FL_NONE)\n-ARM_FPU(\"vfpv3\",\t3, VFP_REG_D32, FPU_FL_NONE)\n-ARM_FPU(\"vfpv3-fp16\",\t3, VFP_REG_D32, FPU_FL_FP16)\n-ARM_FPU(\"vfpv3-d16\",\t3, VFP_REG_D16, FPU_FL_NONE)\n-ARM_FPU(\"vfpv3-d16-fp16\", 3, VFP_REG_D16, FPU_FL_FP16)\n-ARM_FPU(\"vfpv3xd\",\t3, VFP_REG_SINGLE, FPU_FL_NONE)\n-ARM_FPU(\"vfpv3xd-fp16\",\t3, VFP_REG_SINGLE, FPU_FL_FP16)\n-ARM_FPU(\"neon\",\t\t3, VFP_REG_D32, FPU_FL_NEON)\n-ARM_FPU(\"neon-vfpv3\",\t3, VFP_REG_D32, FPU_FL_NEON)\n-ARM_FPU(\"neon-fp16\",\t3, VFP_REG_D32, FPU_FL_NEON | FPU_FL_FP16)\n-ARM_FPU(\"vfpv4\",\t4, VFP_REG_D32, FPU_FL_FP16)\n-ARM_FPU(\"vfpv4-d16\",\t4, VFP_REG_D16, FPU_FL_FP16)\n-ARM_FPU(\"fpv4-sp-d16\",\t4, VFP_REG_SINGLE, FPU_FL_FP16)\n-ARM_FPU(\"fpv5-sp-d16\",\t5, VFP_REG_SINGLE, FPU_FL_FP16)\n-ARM_FPU(\"fpv5-d16\",\t5, VFP_REG_D16, FPU_FL_FP16)\n-ARM_FPU(\"neon-vfpv4\",\t4, VFP_REG_D32, FPU_FL_NEON | FPU_FL_FP16)\n-ARM_FPU(\"fp-armv8\",\t8, VFP_REG_D32, FPU_FL_FP16)\n-ARM_FPU(\"neon-fp-armv8\", 8, VFP_REG_D32, FPU_FL_NEON | FPU_FL_FP16)\n-ARM_FPU(\"crypto-neon-fp-armv8\", 8, VFP_REG_D32, FPU_FL_NEON | FPU_FL_FP16 | FPU_FL_CRYPTO)\n+ARM_FPU(\"vfp\",\t\t\t2, FPU_FL_DBL)\n+ARM_FPU(\"vfpv2\",\t\t2, FPU_FL_DBL)\n+ARM_FPU(\"vfpv3\",\t\t3, FPU_FL_D32 | FPU_FL_DBL)\n+ARM_FPU(\"vfpv3-fp16\",\t\t3, FPU_FL_D32 | FPU_FL_DBL | FPU_FL_FP16)\n+ARM_FPU(\"vfpv3-d16\",\t\t3, FPU_FL_DBL)\n+ARM_FPU(\"vfpv3-d16-fp16\", \t3, FPU_FL_DBL | FPU_FL_FP16)\n+ARM_FPU(\"vfpv3xd\",\t\t3, FPU_FL_NONE)\n+ARM_FPU(\"vfpv3xd-fp16\",\t\t3, FPU_FL_FP16)\n+ARM_FPU(\"neon\",\t\t\t3, FPU_FL_D32 | FPU_FL_DBL | FPU_FL_NEON)\n+ARM_FPU(\"neon-vfpv3\",\t\t3, FPU_FL_D32 | FPU_FL_DBL | FPU_FL_NEON)\n+ARM_FPU(\"neon-fp16\",\t\t3, FPU_FL_D32 | FPU_FL_DBL | FPU_FL_NEON | FPU_FL_FP16)\n+ARM_FPU(\"vfpv4\",\t\t4, FPU_FL_D32 | FPU_FL_DBL | FPU_FL_FP16)\n+ARM_FPU(\"vfpv4-d16\",\t\t4, FPU_FL_DBL | FPU_FL_FP16)\n+ARM_FPU(\"fpv4-sp-d16\",\t\t4, FPU_FL_FP16)\n+ARM_FPU(\"fpv5-sp-d16\",\t\t5, FPU_FL_FP16)\n+ARM_FPU(\"fpv5-d16\",\t\t5, FPU_FL_DBL | FPU_FL_FP16)\n+ARM_FPU(\"neon-vfpv4\",\t\t4, FPU_FL_D32 | FPU_FL_DBL | FPU_FL_NEON | FPU_FL_FP16)\n+ARM_FPU(\"fp-armv8\",\t\t8, FPU_FL_D32 | FPU_FL_DBL | FPU_FL_FP16)\n+ARM_FPU(\"neon-fp-armv8\", \t8, FPU_FL_D32 | FPU_FL_DBL | FPU_FL_NEON | FPU_FL_FP16)\n+ARM_FPU(\"crypto-neon-fp-armv8\", 8, FPU_FL_D32 | FPU_FL_DBL | FPU_FL_NEON | FPU_FL_FP16 | FPU_FL_CRYPTO)\n /* Compatibility aliases.  */\n-ARM_FPU(\"vfp3\",\t\t3, VFP_REG_D32, FPU_FL_NONE)\n+ARM_FPU(\"vfp3\",\t\t\t3, FPU_FL_D32 | FPU_FL_DBL)"}, {"sha": "820a6abf0bc8b5a566f733e7ee63976eb451d5e1", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7f68c6d99dedb9c00f7fc97156815bf6acaf50/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7f68c6d99dedb9c00f7fc97156815bf6acaf50/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=3d7f68c6d99dedb9c00f7fc97156815bf6acaf50", "patch": "@@ -2323,8 +2323,8 @@ char arm_arch_name[] = \"__ARM_ARCH_PROFILE__\";\n \n const struct arm_fpu_desc all_fpus[] =\n {\n-#define ARM_FPU(NAME, REV, VFP_REGS, FEATURES) \\\n-  { NAME, REV, VFP_REGS, FEATURES },\n+#define ARM_FPU(NAME, REV, FEATURES) \\\n+  { NAME, REV, FEATURES },\n #include \"arm-fpus.def\"\n #undef ARM_FPU\n };\n@@ -30218,10 +30218,6 @@ arm_can_inline_p (tree caller, tree callee)\n   if ((caller_fpu->features & callee_fpu->features) != callee_fpu->features)\n     return false;\n \n-  /* Need same FPU regs.  */\n-  if (callee_fpu->regs != callee_fpu->regs)\n-    return false;\n-\n   /* OK to inline between different modes.\n      Function with mode specific instructions, e.g using asm,\n      must be explicitly protected with noinline.  */"}, {"sha": "a412fb11e01966c2558af954fe026ae5f4cd15c0", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7f68c6d99dedb9c00f7fc97156815bf6acaf50/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7f68c6d99dedb9c00f7fc97156815bf6acaf50/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=3d7f68c6d99dedb9c00f7fc97156815bf6acaf50", "patch": "@@ -161,7 +161,7 @@ extern tree arm_fp16_type_node;\n    to be more careful with TARGET_NEON as noted below.  */\n \n /* FPU is has the full VFPv3/NEON register file of 32 D registers.  */\n-#define TARGET_VFPD32 (TARGET_FPU_REGS == VFP_REG_D32)\n+#define TARGET_VFPD32 (TARGET_FPU_FEATURES & FPU_FL_D32)\n \n /* FPU supports VFPv3 instructions.  */\n #define TARGET_VFP3 (TARGET_FPU_REV >= 3)\n@@ -170,10 +170,10 @@ extern tree arm_fp16_type_node;\n #define TARGET_VFP5 (TARGET_FPU_REV >= 5)\n \n /* FPU only supports VFP single-precision instructions.  */\n-#define TARGET_VFP_SINGLE (TARGET_FPU_REGS == VFP_REG_SINGLE)\n+#define TARGET_VFP_SINGLE ((TARGET_FPU_FEATURES & FPU_FL_DBL) == 0)\n \n /* FPU supports VFP double-precision instructions.  */\n-#define TARGET_VFP_DOUBLE (TARGET_FPU_REGS != VFP_REG_SINGLE)\n+#define TARGET_VFP_DOUBLE (TARGET_FPU_FEATURES & FPU_FL_DBL)\n \n /* FPU supports half-precision floating-point with NEON element load/store.  */\n #define TARGET_NEON_FP16\t\t\t\t\t\\\n@@ -335,32 +335,24 @@ typedef unsigned long arm_fpu_feature_set;\n #define ARM_FPU_FSET_HAS(S,F) (((S) & (F)) == (F))\n \n /* FPU Features.  */\n-#define FPU_FL_NONE\t(0)\n-#define FPU_FL_NEON\t(1 << 0)\t/* NEON instructions.  */\n-#define FPU_FL_FP16\t(1 << 1)\t/* Half-precision.  */\n-#define FPU_FL_CRYPTO\t(1 << 2)\t/* Crypto extensions.  */\n-\n-enum vfp_reg_type\n-{\n-  VFP_NONE = 0,\n-  VFP_REG_D16,\n-  VFP_REG_D32,\n-  VFP_REG_SINGLE\n-};\n+#define FPU_FL_NONE\t(0u)\n+#define FPU_FL_NEON\t(1u << 0)\t/* NEON instructions.  */\n+#define FPU_FL_FP16\t(1u << 1)\t/* Half-precision.  */\n+#define FPU_FL_CRYPTO\t(1u << 2)\t/* Crypto extensions.  */\n+#define FPU_FL_DBL\t(1u << 3)\t/* Has double precision.  */\n+#define FPU_FL_D32\t(1u << 4)\t/* Has 32 double precision regs.  */\n \n extern const struct arm_fpu_desc\n {\n   const char *name;\n   int rev;\n-  enum vfp_reg_type regs;\n   arm_fpu_feature_set features;\n } all_fpus[];\n \n /* Accessors.  */\n \n #define TARGET_FPU_NAME     (all_fpus[arm_fpu_index].name)\n #define TARGET_FPU_REV      (all_fpus[arm_fpu_index].rev)\n-#define TARGET_FPU_REGS     (all_fpus[arm_fpu_index].regs)\n #define TARGET_FPU_FEATURES (all_fpus[arm_fpu_index].features)\n \n /* Which floating point hardware to schedule for.  */"}]}