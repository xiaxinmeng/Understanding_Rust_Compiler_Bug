{"sha": "dcfe3c8f32c207cb4d8cb77425604ae72bee406a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNmZTNjOGYzMmMyMDdjYjRkOGNiNzc0MjU2MDRhZTcyYmVlNDA2YQ==", "commit": {"author": {"name": "Simon Dardis", "email": "simon.dardis@imgtec.com", "date": "2015-11-11T13:40:08Z"}, "committer": {"name": "Simon Dardis", "email": "dardiss@gcc.gnu.org", "date": "2015-11-11T13:40:08Z"}, "message": "Undo delay slot filling and use compact branches in selected cases.\n\ngcc/\n\t* config/mips/mips.c (mips_breakable_sequence_p): New function.\n\t(mips_break_sequence): New function. \n\t(mips_reorg_process_insns) Use them. Use compact branches in selected\n          situations.\n    \ngcc/testsuite/\n        * gcc.target/mips/split-ds-sequence.c: New test.\n\nFrom-SVN: r230160", "tree": {"sha": "e493a662bd56a720d799d846a21967c6d3efd7a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e493a662bd56a720d799d846a21967c6d3efd7a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcfe3c8f32c207cb4d8cb77425604ae72bee406a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcfe3c8f32c207cb4d8cb77425604ae72bee406a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcfe3c8f32c207cb4d8cb77425604ae72bee406a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcfe3c8f32c207cb4d8cb77425604ae72bee406a/comments", "author": null, "committer": null, "parents": [{"sha": "c08de514880f6cc238123da828eca9122dbf74bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c08de514880f6cc238123da828eca9122dbf74bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c08de514880f6cc238123da828eca9122dbf74bd"}], "stats": {"total": 147, "additions": 147, "deletions": 0}, "files": [{"sha": "e955e4175b94f617b494652b90cd550379fb87e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcfe3c8f32c207cb4d8cb77425604ae72bee406a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcfe3c8f32c207cb4d8cb77425604ae72bee406a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dcfe3c8f32c207cb4d8cb77425604ae72bee406a", "patch": "@@ -1,3 +1,10 @@\n+2015-11-11  Simon Dardis  <simon.dardis@imgtec.com>\n+\n+\t* config/mips/mips.c (mips_breakable_sequence_p): New function.\n+\t(mips_break_sequence): New function. \n+\t(mips_reorg_process_insns): Use them. Use compact branches in selected\n+\tsituations.\n+\n 2015-11-11  Alan Lawrence  <alan.lawrence@arm.com>\n \n \t* fold-const.c (get_array_ctor_element_at_index): Fix whitespace, typo."}, {"sha": "d3b7730486db8d9e1a30631785d45efcdaa62cfa", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcfe3c8f32c207cb4d8cb77425604ae72bee406a/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcfe3c8f32c207cb4d8cb77425604ae72bee406a/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=dcfe3c8f32c207cb4d8cb77425604ae72bee406a", "patch": "@@ -16824,6 +16824,34 @@ mips_avoid_hazard (rtx_insn *after, rtx_insn *insn, int *hilo_delay,\n       }\n }\n \n+/* A SEQUENCE is breakable iff the branch inside it has a compact form\n+   and the target has compact branches.  */\n+\n+static bool\n+mips_breakable_sequence_p (rtx_insn *insn)\n+{\n+  return (insn && GET_CODE (PATTERN (insn)) == SEQUENCE\n+\t  && TARGET_CB_MAYBE\n+\t  && get_attr_compact_form (SEQ_BEGIN (insn)) != COMPACT_FORM_NEVER);\n+}\n+\n+/* Remove a SEQUENCE and replace it with the delay slot instruction\n+   followed by the branch and return the instruction in the delay slot.\n+   Return the first of the two new instructions.\n+   Subroutine of mips_reorg_process_insns.  */\n+\n+static rtx_insn *\n+mips_break_sequence (rtx_insn *insn)\n+{\n+  rtx_insn *before = PREV_INSN (insn);\n+  rtx_insn *branch = SEQ_BEGIN (insn);\n+  rtx_insn *ds = SEQ_END (insn);\n+  remove_insn (insn);\n+  add_insn_after (ds, before, NULL);\n+  add_insn_after (branch, ds, NULL);\n+  return ds;\n+}\n+\n /* Go through the instruction stream and insert nops where necessary.\n    Also delete any high-part relocations whose partnering low parts\n    are now all dead.  See if the whole function can then be put into\n@@ -16916,6 +16944,68 @@ mips_reorg_process_insns (void)\n \t{\n \t  if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n \t    {\n+\t      rtx_insn *next_active = next_active_insn (insn);\n+\t      /* Undo delay slots to avoid bubbles if the next instruction can\n+\t\t be placed in a forbidden slot or the cost of adding an\n+\t\t explicit NOP in a forbidden slot is OK and if the SEQUENCE is\n+\t\t safely breakable.  */\n+\t      if (TARGET_CB_MAYBE\n+\t\t  && mips_breakable_sequence_p (insn)\n+\t\t  && INSN_P (SEQ_BEGIN (insn))\n+\t\t  && INSN_P (SEQ_END (insn))\n+\t\t  && ((next_active\n+\t\t       && INSN_P (next_active)\n+\t\t       && GET_CODE (PATTERN (next_active)) != SEQUENCE\n+\t\t       && get_attr_can_delay (next_active) == CAN_DELAY_YES)\n+\t\t      || !optimize_size))\n+\t\t{\n+\t\t  /* To hide a potential pipeline bubble, if we scan backwards\n+\t\t     from the current SEQUENCE and find that there is a load\n+\t\t     of a value that is used in the CTI and there are no\n+\t\t     dependencies between the CTI and instruction in the delay\n+\t\t     slot, break the sequence so the load delay is hidden.  */\n+\t\t  HARD_REG_SET uses;\n+\t\t  CLEAR_HARD_REG_SET (uses);\n+\t\t  note_uses (&PATTERN (SEQ_BEGIN (insn)), record_hard_reg_uses,\n+\t\t\t     &uses);\n+\t\t  HARD_REG_SET delay_sets;\n+\t\t  CLEAR_HARD_REG_SET (delay_sets);\n+\t\t  note_stores (PATTERN (SEQ_END (insn)), record_hard_reg_sets,\n+\t\t\t       &delay_sets);\n+\n+\t\t  rtx_insn *prev = prev_active_insn (insn);\n+\t\t  if (prev\n+\t\t      && GET_CODE (PATTERN (prev)) == SET\n+\t\t      && MEM_P (SET_SRC (PATTERN (prev))))\n+\t\t    {\n+\t\t      HARD_REG_SET sets;\n+\t\t      CLEAR_HARD_REG_SET (sets);\n+\t\t      note_stores (PATTERN (prev), record_hard_reg_sets,\n+\t\t\t\t   &sets);\n+\n+\t\t      /* Re-order if safe.  */\n+\t\t      if (!hard_reg_set_intersect_p (delay_sets, uses)\n+\t\t\t  && hard_reg_set_intersect_p (uses, sets))\n+\t\t\t{\n+\t\t\t  next_insn = mips_break_sequence (insn);\n+\t\t\t  /* Need to process the hazards of the newly\n+\t\t\t     introduced instructions.  */\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  /* If we find an orphaned high-part relocation in a delay\n+\t\t     slot then we can convert to a compact branch and get\n+\t\t     the orphaned high part deleted.  */\n+\t\t  if (mips_orphaned_high_part_p (&htab, SEQ_END (insn)))\n+\t\t    {\n+\t\t      next_insn = mips_break_sequence (insn);\n+\t\t      /* Need to process the hazards of the newly\n+\t\t\t introduced instructions.  */\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\n \t      /* If we find an orphaned high-part relocation in a delay\n \t\t slot, it's easier to turn that instruction into a NOP than\n \t\t to delete it.  The delay slot will be a NOP either way.  */\n@@ -16950,6 +17040,33 @@ mips_reorg_process_insns (void)\n \t\t{\n \t\t  mips_avoid_hazard (last_insn, insn, &hilo_delay,\n \t\t\t\t     &delayed_reg, lo_reg, &fs_delay);\n+\t\t  /* When a compact branch introduces a forbidden slot hazard\n+\t\t     and the next useful instruction is a SEQUENCE of a jump\n+\t\t     and a non-nop instruction in the delay slot, remove the\n+\t\t     sequence and replace it with the delay slot instruction\n+\t\t     then the jump to clear the forbidden slot hazard.  */\n+\n+\t\t  if (fs_delay)\n+\t\t    {\n+\t\t      /* Search onwards from the current position looking for\n+\t\t\t a SEQUENCE.  We are looking for pipeline hazards here\n+\t\t\t and do not need to worry about labels or barriers as\n+\t\t\t the optimization only undoes delay slot filling which\n+\t\t\t only affects the order of the branch and its delay\n+\t\t\t slot.  */\n+\t\t      rtx_insn *next = next_active_insn (insn);\n+\t\t      if (next\n+\t\t\t  && USEFUL_INSN_P (next)\n+\t\t\t  && GET_CODE (PATTERN (next)) == SEQUENCE\n+\t\t\t  && mips_breakable_sequence_p (next))\n+\t\t\t{\n+\t\t\t  last_insn = insn;\n+\t\t\t  next_insn = mips_break_sequence (next);\n+\t\t\t  /* Need to process the hazards of the newly\n+\t\t\t     introduced instructions.  */\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t    }\n \t\t  last_insn = insn;\n \t\t}\n \t    }"}, {"sha": "4637d5fc6a8082600b7558f01719b6092e1c3f3d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcfe3c8f32c207cb4d8cb77425604ae72bee406a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcfe3c8f32c207cb4d8cb77425604ae72bee406a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dcfe3c8f32c207cb4d8cb77425604ae72bee406a", "patch": "@@ -1,3 +1,7 @@\n+2015-11-11  Simon Dardis  <simon.dardis@imgtec.com>\n+\n+\t* gcc.target/mips/split-ds-sequence.c: New test.\n+\n 2015-11-11  Julia Koval  <julia.koval@intel.com>\n \n \t* g++.dg/ext/mv16.C: New functions."}, {"sha": "e60270db30407f8daac39da90c8098e5532a9123", "filename": "gcc/testsuite/gcc.target/mips/split-ds-sequence.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcfe3c8f32c207cb4d8cb77425604ae72bee406a/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsplit-ds-sequence.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcfe3c8f32c207cb4d8cb77425604ae72bee406a/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsplit-ds-sequence.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fsplit-ds-sequence.c?ref=dcfe3c8f32c207cb4d8cb77425604ae72bee406a", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-options \"isa_rev>=6\" } */\n+/* { dg-skip-if \"code quality test\" { *-*-* } { \"-mcompact-branches=never\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"nop\" } } */\n+\n+int\n+testg2 (int a, int c)\n+{\n+\n+  int j = 0;\n+  do\n+    {\n+      j += a;\n+    }\n+  while (j < 56);\n+\n+  j += c;\n+  return j;\n+\n+}"}]}