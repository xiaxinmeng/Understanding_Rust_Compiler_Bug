{"sha": "45fbea4f6603667baa877577a5ccf6326c53babd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVmYmVhNGY2NjAzNjY3YmFhODc3NTc3YTVjY2Y2MzI2YzUzYmFiZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-23T10:52:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-23T10:52:34Z"}, "message": "[multiple changes]\n\n2015-10-23  Olivier Hainque  <hainque@adacore.com>\n\n\t* tracebak.c: Fallback to generic unwinder for gcc-sjlj on x86 &\n\tx86_64 linux\n\t* tracebak.c: Rework x86 & x86_64 sections to resort to the\n\tgeneric unwinder if __USING_SJLJ_EXCEPTIONS__.\n\n2015-10-23  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_util.adb (Check_Function_Writable_Actuals): For function\n\tcalls restrict the check to elementary types, as requested by\n\tRM 6.4.1(6.15/3)\n\n2015-10-23  Arnaud Charlet  <charlet@adacore.com>\n\n\t* exp_unst.adb (Unnest_Subprogram): Suppress initialization on\n\tDecl_ARECnT since we are taking care of all initializations in\n\tthe generated code.\n\nFrom-SVN: r229233", "tree": {"sha": "9932b82dccd6dbaf5f7cacf3eca4eee395fbd433", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9932b82dccd6dbaf5f7cacf3eca4eee395fbd433"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45fbea4f6603667baa877577a5ccf6326c53babd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45fbea4f6603667baa877577a5ccf6326c53babd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45fbea4f6603667baa877577a5ccf6326c53babd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45fbea4f6603667baa877577a5ccf6326c53babd/comments", "author": null, "committer": null, "parents": [{"sha": "faaf6d353899f263bfc6144b2bb7de1f674ad5bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faaf6d353899f263bfc6144b2bb7de1f674ad5bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faaf6d353899f263bfc6144b2bb7de1f674ad5bb"}], "stats": {"total": 88, "additions": 58, "deletions": 30}, "files": [{"sha": "b811165802b773ee7bac9e5f983982ed665807b9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45fbea4f6603667baa877577a5ccf6326c53babd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45fbea4f6603667baa877577a5ccf6326c53babd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=45fbea4f6603667baa877577a5ccf6326c53babd", "patch": "@@ -1,3 +1,22 @@\n+2015-10-23  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* tracebak.c: Fallback to generic unwinder for gcc-sjlj on x86 &\n+\tx86_64 linux\n+\t* tracebak.c: Rework x86 & x86_64 sections to resort to the\n+\tgeneric unwinder if __USING_SJLJ_EXCEPTIONS__.\n+\n+2015-10-23  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_util.adb (Check_Function_Writable_Actuals): For function\n+\tcalls restrict the check to elementary types, as requested by\n+\tRM 6.4.1(6.15/3)\n+\n+2015-10-23  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* exp_unst.adb (Unnest_Subprogram): Suppress initialization on\n+\tDecl_ARECnT since we are taking care of all initializations in\n+\tthe generated code.\n+\n 2015-10-23  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_dim.adb (Analyze_Dimension_Extension_Or_Record_Aggregate):"}, {"sha": "238261e642215c5f8765f2ee12325a160c112210", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45fbea4f6603667baa877577a5ccf6326c53babd/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45fbea4f6603667baa877577a5ccf6326c53babd/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=45fbea4f6603667baa877577a5ccf6326c53babd", "patch": "@@ -1174,6 +1174,9 @@ package body Exp_Unst is\n                      --  Now we can insert the AREC declarations into the body\n \n                      --  type ARECnT is record .. end record;\n+                     --  pragma Suppress_Initialization (ARECnT);\n+                     --  Note that we need to set the Suppress_Initialization\n+                     --  flag after Decl_ARECnT has been analyzed.\n \n                      Decl_ARECnT :=\n                        Make_Full_Type_Declaration (Loc,\n@@ -1262,6 +1265,9 @@ package body Exp_Unst is\n                      Analyze (Decl_ARECn,   Suppress => All_Checks);\n                      Analyze (Decl_ARECnP,  Suppress => All_Checks);\n \n+                     Set_Suppress_Initialization\n+                       (Defining_Identifier (Decl_ARECnT));\n+\n                      if Present (Decl_Assign) then\n                         Analyze (Decl_Assign,  Suppress => All_Checks);\n                      end if;"}, {"sha": "35b32697d257b742a9b1b3a23ae30e5eeff09b2b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45fbea4f6603667baa877577a5ccf6326c53babd/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45fbea4f6603667baa877577a5ccf6326c53babd/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=45fbea4f6603667baa877577a5ccf6326c53babd", "patch": "@@ -2232,11 +2232,26 @@ package body Sem_Util is\n                end if;\n \n                if Is_Writable_Actual then\n-                  if Contains (Writable_Actuals_List, N) then\n+\n+                  --  Skip checking the error in non-elementary types since\n+                  --  RM 6.4.1(6.15/3) is restricted to elementary types, but\n+                  --  store this actual in Writable_Actuals_List since it is\n+                  --  needed to perform checks on other constructs that have\n+                  --  arbitrary order of evaluation (for example, aggregates).\n+\n+                  if not Is_Elementary_Type (Etype (N)) then\n+                     if not Contains (Writable_Actuals_List, N) then\n+                        Append_New_Elmt (N, To => Writable_Actuals_List);\n+                     end if;\n+\n+                  --  Second occurrence of an elementary type writable actual\n+\n+                  elsif Contains (Writable_Actuals_List, N) then\n \n                      --  Report the error on the second occurrence of the\n                      --  identifier. We cannot assume that N is the second\n-                     --  occurrence, since Traverse_Func walks through Field2\n+                     --  occurrence (according to their location in the\n+                     --  sources), since Traverse_Func walks through Field2\n                      --  last (see comment in the body of Traverse_Func).\n \n                      declare\n@@ -2262,9 +2277,12 @@ package body Sem_Util is\n                            Error_Node, Id);\n                         return Abandon;\n                      end;\n-                  end if;\n \n-                  Append_New_Elmt (N, To => Writable_Actuals_List);\n+                  --  First occurrence of a elementary type writable actual\n+\n+                  else\n+                     Append_New_Elmt (N, To => Writable_Actuals_List);\n+                  end if;\n \n                else\n                   if Identifiers_List = No_Elist then"}, {"sha": "c91f1479daaf883d523fc8acbbce1386a4aba9c1", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45fbea4f6603667baa877577a5ccf6326c53babd/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45fbea4f6603667baa877577a5ccf6326c53babd/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=45fbea4f6603667baa877577a5ccf6326c53babd", "patch": "@@ -415,9 +415,9 @@ struct layout\n    window of frame N-1 (positive offset from fp), in which we retrieve the\n    saved return address. We then end up with our caller's return address.  */\n \n-/*------------------------------- x86 ----------------------------------*/\n+/*---------------------------- x86 & x86_64 ---------------------------------*/\n \n-#elif defined (__i386__)\n+#elif defined (__i386__) || defined (__x86_64__)\n \n #if defined (__WIN32)\n #include <windows.h>\n@@ -428,10 +428,12 @@ struct layout\n #define IS_BAD_PTR(ptr) 0\n #endif\n \n-/* Starting with GCC 4.6, -fomit-frame-pointer is turned on by default for\n-   32-bit x86/Linux as well and DWARF 2 unwind tables are emitted instead.\n-   See the x86-64 case below for the drawbacks with this approach.  */\n-#if defined (__linux__) && (__GNUC__ * 10 + __GNUC_MINOR__ > 45)\n+/* Use the dwarf2 unwinder when we expect to have dwarf2 tables at\n+   hand. Backtraces will reliably stop on frames missing such tables,\n+   but our only alternative is the generic unwinder which requires\n+   compilation forcing a frame pointer to be reliable.  */\n+\n+#if defined (__linux__) && !defined (__USING_SJLJ_EXCEPTIONS__)\n #define USE_GCC_UNWINDER\n #else\n #define USE_GENERIC_UNWINDER\n@@ -444,9 +446,9 @@ struct layout\n };\n \n #define FRAME_LEVEL 1\n-/* builtin_frame_address (1) is expected to work on this target, and (0) might\n-   return the soft stack pointer, which does not designate a location where a\n-   backchain and a return address might be found.  */\n+/* builtin_frame_address (1) is expected to work on this family of targets,\n+   and (0) might return the soft stack pointer, which does not designate a\n+   location where a backchain and a return address might be found.  */\n \n #define FRAME_OFFSET(FP) 0\n #define PC_ADJUST -2\n@@ -478,23 +480,6 @@ struct layout\n         || ((*((ptr) - 1) & 0xff) == 0xff) \\\n         || (((*(ptr) & 0xd0ff) == 0xd0ff))))\n \n-/*----------------------------- x86_64 ---------------------------------*/\n-\n-#elif defined (__x86_64__)\n-\n-#define USE_GCC_UNWINDER\n-/* The generic unwinder is not used for this target because it is based\n-   on frame layout assumptions that are not reliable on this target (the\n-   rbp register is very likely used for something else than storing the\n-   frame pointer in optimized code). Hence, we use the GCC unwinder\n-   based on DWARF 2 call frame information, although it has the drawback\n-   of not being able to unwind through frames compiled without DWARF 2\n-   information.\n-*/\n-\n-#define PC_ADJUST -2\n-/* The minimum size of call instructions on this architecture is 2 bytes */\n-\n /*----------------------------- ia64 ---------------------------------*/\n \n #elif defined (__ia64__) && (defined (__linux__) || defined (__hpux__))"}]}