{"sha": "aca52e6f8d29064f4712e5f3f4429a36f918f099", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNhNTJlNmY4ZDI5MDY0ZjQ3MTJlNWYzZjQ0MjlhMzZmOTE4ZjA5OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-21T07:02:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-21T07:02:13Z"}, "message": "poly_int: MEM_REF offsets\n\nThis patch allows MEM_REF offsets to be polynomial, with mem_ref_offset\nnow returning a poly_offset_int instead of an offset_int.  The\nnon-mechanical changes to callers of mem_ref_offset were handled by\nprevious patches.\n\n2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* fold-const.h (mem_ref_offset): Return a poly_offset_int rather\n\tthan an offset_int.\n\t* tree.c (mem_ref_offset): Likewise.\n\t(build_simple_mem_ref_loc): Treat MEM_REF offsets as poly_ints.\n\t* builtins.c (get_object_alignment_2): Likewise.\n\t* expr.c (get_inner_reference, expand_expr_real_1): Likewise.\n\t* gimple-fold.c (get_base_constructor): Likewise.\n\t* gimple-ssa-strength-reduction.c (restructure_reference): Likewise.\n\t* gimple-ssa-warn-restrict.c (builtin_memref::builtin_memref):\n\tLikewise.\n\t* ipa-polymorphic-call.c\n\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context): Likewise.\n\t* ipa-prop.c (compute_complex_assign_jump_func): Likewise.\n\t(get_ancestor_addr_info): Likewise.\n\t* ipa-param-manipulation.c (ipa_get_adjustment_candidate): Likewise.\n\t* match.pd: Likewise.\n\t* tree-data-ref.c (dr_analyze_innermost): Likewise.\n\t* tree-dfa.c (get_addr_base_and_unit_offset_1): Likewise.\n\t* tree-eh.c (tree_could_trap_p): Likewise.\n\t* tree-object-size.c (addr_object_size): Likewise.\n\t* tree-ssa-address.c (copy_ref_info): Likewise.\n\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Likewise.\n\t(indirect_refs_may_alias_p): Likewise.\n\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Likewise.\n\t* tree-ssa.c (maybe_rewrite_mem_ref_base): Likewise.\n\t(non_rewritable_mem_ref_base): Likewise.\n\t* tree-vect-data-refs.c (vect_check_gather_scatter): Likewise.\n\t* tree-vrp.c (vrp_prop::check_array_ref): Likewise.\n\t* varasm.c (decode_addr_const): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255930", "tree": {"sha": "45c2884952716e83f81ee8162585cbf16e06bf73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45c2884952716e83f81ee8162585cbf16e06bf73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aca52e6f8d29064f4712e5f3f4429a36f918f099", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aca52e6f8d29064f4712e5f3f4429a36f918f099", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aca52e6f8d29064f4712e5f3f4429a36f918f099", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aca52e6f8d29064f4712e5f3f4429a36f918f099/comments", "author": null, "committer": null, "parents": [{"sha": "3fed2ce96f7ec8ee8603b33ba0426ac40acecf24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fed2ce96f7ec8ee8603b33ba0426ac40acecf24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fed2ce96f7ec8ee8603b33ba0426ac40acecf24"}], "stats": {"total": 214, "additions": 135, "deletions": 79}, "files": [{"sha": "2bdcde16a21ea4c6b65bad01d0d22fff02151d36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -1,3 +1,37 @@\n+2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* fold-const.h (mem_ref_offset): Return a poly_offset_int rather\n+\tthan an offset_int.\n+\t* tree.c (mem_ref_offset): Likewise.\n+\t(build_simple_mem_ref_loc): Treat MEM_REF offsets as poly_ints.\n+\t* builtins.c (get_object_alignment_2): Likewise.\n+\t* expr.c (get_inner_reference, expand_expr_real_1): Likewise.\n+\t* gimple-fold.c (get_base_constructor): Likewise.\n+\t* gimple-ssa-strength-reduction.c (restructure_reference): Likewise.\n+\t* gimple-ssa-warn-restrict.c (builtin_memref::builtin_memref):\n+\tLikewise.\n+\t* ipa-polymorphic-call.c\n+\t(ipa_polymorphic_call_context::ipa_polymorphic_call_context): Likewise.\n+\t* ipa-prop.c (compute_complex_assign_jump_func): Likewise.\n+\t(get_ancestor_addr_info): Likewise.\n+\t* ipa-param-manipulation.c (ipa_get_adjustment_candidate): Likewise.\n+\t* match.pd: Likewise.\n+\t* tree-data-ref.c (dr_analyze_innermost): Likewise.\n+\t* tree-dfa.c (get_addr_base_and_unit_offset_1): Likewise.\n+\t* tree-eh.c (tree_could_trap_p): Likewise.\n+\t* tree-object-size.c (addr_object_size): Likewise.\n+\t* tree-ssa-address.c (copy_ref_info): Likewise.\n+\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Likewise.\n+\t(indirect_refs_may_alias_p): Likewise.\n+\t* tree-ssa-sccvn.c (copy_reference_ops_from_ref): Likewise.\n+\t* tree-ssa.c (maybe_rewrite_mem_ref_base): Likewise.\n+\t(non_rewritable_mem_ref_base): Likewise.\n+\t* tree-vect-data-refs.c (vect_check_gather_scatter): Likewise.\n+\t* tree-vrp.c (vrp_prop::check_array_ref): Likewise.\n+\t* varasm.c (decode_addr_const): Likewise.\n+\n 2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "753809f2357009a062e5bc7e742d5f2380d9c3d8", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -346,7 +346,7 @@ get_object_alignment_2 (tree exp, unsigned int *alignp,\n \t  bitpos += ptr_bitpos;\n \t  if (TREE_CODE (exp) == MEM_REF\n \t      || TREE_CODE (exp) == TARGET_MEM_REF)\n-\t    bitpos += mem_ref_offset (exp).to_short_addr () * BITS_PER_UNIT;\n+\t    bitpos += mem_ref_offset (exp).force_shwi () * BITS_PER_UNIT;\n \t}\n     }\n   else if (TREE_CODE (exp) == STRING_CST)"}, {"sha": "4e7349e649488dcf3f763e230996663afd0d0b21", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -7197,8 +7197,8 @@ get_inner_reference (tree exp, poly_int64_pod *pbitsize,\n \t      tree off = TREE_OPERAND (exp, 1);\n \t      if (!integer_zerop (off))\n \t\t{\n-\t\t  offset_int boff, coff = mem_ref_offset (exp);\n-\t\t  boff = coff << LOG2_BITS_PER_UNIT;\n+\t\t  poly_offset_int boff = mem_ref_offset (exp);\n+\t\t  boff <<= LOG2_BITS_PER_UNIT;\n \t\t  bit_offset += boff;\n \t\t}\n \t      exp = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n@@ -10222,9 +10222,9 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t   might end up in a register.  */\n \tif (mem_ref_refers_to_non_mem_p (exp))\n \t  {\n-\t    HOST_WIDE_INT offset = mem_ref_offset (exp).to_short_addr ();\n+\t    poly_int64 offset = mem_ref_offset (exp).force_shwi ();\n \t    base = TREE_OPERAND (base, 0);\n-\t    if (offset == 0\n+\t    if (known_eq (offset, 0)\n \t        && !reverse\n \t\t&& tree_fits_uhwi_p (TYPE_SIZE (type))\n \t\t&& (GET_MODE_BITSIZE (DECL_MODE (base))"}, {"sha": "b777606b6e9724806ccf40299e00f1b75226b3bc", "filename": "gcc/fold-const.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -114,7 +114,7 @@ extern tree fold_indirect_ref_loc (location_t, tree);\n extern tree build_simple_mem_ref_loc (location_t, tree);\n #define build_simple_mem_ref(T)\\\n \tbuild_simple_mem_ref_loc (UNKNOWN_LOCATION, T)\n-extern offset_int mem_ref_offset (const_tree);\n+extern poly_offset_int mem_ref_offset (const_tree);\n extern tree build_invariant_address (tree, tree, poly_int64);\n extern tree constant_boolean_node (bool, tree);\n extern tree div_if_zero_remainder (const_tree, const_tree);"}, {"sha": "ae2c9a176c6fd44722b37c4b956b8bd35d7ab5c7", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -6346,7 +6346,7 @@ get_base_constructor (tree base, poly_int64_pod *bit_offset,\n \t{\n \t  if (!tree_fits_shwi_p (TREE_OPERAND (base, 1)))\n \t    return NULL_TREE;\n-\t  *bit_offset += (mem_ref_offset (base).to_short_addr ()\n+\t  *bit_offset += (mem_ref_offset (base).force_shwi ()\n \t\t\t  * BITS_PER_UNIT);\n \t}\n "}, {"sha": "9eab9a72a7ffeda1dcecb57632fd4dc605ed42a8", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -970,17 +970,19 @@ restructure_reference (tree *pbase, tree *poffset, widest_int *pindex,\n   widest_int index = *pindex;\n   tree mult_op0, t1, t2, type;\n   widest_int c1, c2, c3, c4, c5;\n+  offset_int mem_offset;\n \n   if (!base\n       || !offset\n       || TREE_CODE (base) != MEM_REF\n+      || !mem_ref_offset (base).is_constant (&mem_offset)\n       || TREE_CODE (offset) != MULT_EXPR\n       || TREE_CODE (TREE_OPERAND (offset, 1)) != INTEGER_CST\n       || wi::umod_floor (index, BITS_PER_UNIT) != 0)\n     return false;\n \n   t1 = TREE_OPERAND (base, 0);\n-  c1 = widest_int::from (mem_ref_offset (base), SIGNED);\n+  c1 = widest_int::from (mem_offset, SIGNED);\n   type = TREE_TYPE (TREE_OPERAND (base, 1));\n \n   mult_op0 = TREE_OPERAND (offset, 0);"}, {"sha": "ac545e4cf67be026ac597fc9343396f7a94cea74", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -349,10 +349,15 @@ builtin_memref::builtin_memref (tree expr, tree size)\n \n   if (TREE_CODE (base) == MEM_REF)\n     {\n-      offset_int off = mem_ref_offset (base);\n-      refoff += off;\n-      offrange[0] += off;\n-      offrange[1] += off;\n+      offset_int off;\n+      if (mem_ref_offset (base).is_constant (&off))\n+\t{\n+\t  refoff += off;\n+\t  offrange[0] += off;\n+\t  offrange[1] += off;\n+\t}\n+      else\n+\tsize = NULL_TREE;\n       base = TREE_OPERAND (base, 0);\n     }\n "}, {"sha": "efa1ea27c669c3e65c83ef9b72a5eb23c99c086a", "filename": "gcc/ipa-param-manipulation.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fipa-param-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fipa-param-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -636,7 +636,7 @@ ipa_get_adjustment_candidate (tree **expr, bool *convert,\n \n   if (TREE_CODE (base) == MEM_REF)\n     {\n-      offset += mem_ref_offset (base).to_short_addr () * BITS_PER_UNIT;\n+      offset += mem_ref_offset (base).force_shwi () * BITS_PER_UNIT;\n       base = TREE_OPERAND (base, 0);\n     }\n "}, {"sha": "78cde86424479afda52ae680ff1685bcc0a08ea1", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -917,9 +917,11 @@ ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n \t    {\n \t      /* We found dereference of a pointer.  Type of the pointer\n \t\t and MEM_REF is meaningless, but we can look futher.  */\n-\t      if (TREE_CODE (base) == MEM_REF)\n+\t      offset_int mem_offset;\n+\t      if (TREE_CODE (base) == MEM_REF\n+\t\t  && mem_ref_offset (base).is_constant (&mem_offset))\n \t\t{\n-\t\t  offset_int o = mem_ref_offset (base) * BITS_PER_UNIT;\n+\t\t  offset_int o = mem_offset * BITS_PER_UNIT;\n \t\t  o += offset;\n \t\t  o += offset2;\n \t\t  if (!wi::fits_shwi_p (o))"}, {"sha": "7ac250a0a6a8195e7471b83e6c19182fdc1f1f71", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -1267,9 +1267,12 @@ compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n   if (TREE_CODE (TREE_TYPE (op1)) != RECORD_TYPE)\n     return;\n   base = get_ref_base_and_extent_hwi (op1, &offset, &size, &reverse);\n-  if (!base || TREE_CODE (base) != MEM_REF)\n+  offset_int mem_offset;\n+  if (!base\n+      || TREE_CODE (base) != MEM_REF\n+      || !mem_ref_offset (base).is_constant (&mem_offset))\n     return;\n-  offset += mem_ref_offset (base).to_short_addr () * BITS_PER_UNIT;\n+  offset += mem_offset.to_short_addr () * BITS_PER_UNIT;\n   ssa = TREE_OPERAND (base, 0);\n   if (TREE_CODE (ssa) != SSA_NAME\n       || !SSA_NAME_IS_DEFAULT_DEF (ssa)\n@@ -1311,15 +1314,18 @@ get_ancestor_addr_info (gimple *assign, tree *obj_p, HOST_WIDE_INT *offset)\n   obj = expr;\n   expr = get_ref_base_and_extent_hwi (expr, offset, &size, &reverse);\n \n-  if (!expr || TREE_CODE (expr) != MEM_REF)\n+  offset_int mem_offset;\n+  if (!expr\n+      || TREE_CODE (expr) != MEM_REF\n+      || !mem_ref_offset (expr).is_constant (&mem_offset))\n     return NULL_TREE;\n   parm = TREE_OPERAND (expr, 0);\n   if (TREE_CODE (parm) != SSA_NAME\n       || !SSA_NAME_IS_DEFAULT_DEF (parm)\n       || TREE_CODE (SSA_NAME_VAR (parm)) != PARM_DECL)\n     return NULL_TREE;\n \n-  *offset += mem_ref_offset (expr).to_short_addr () * BITS_PER_UNIT;\n+  *offset += mem_offset.to_short_addr () * BITS_PER_UNIT;\n   *obj_p = obj;\n   return expr;\n }"}, {"sha": "bd1673ac5e978aa66575c0d356f1e347b0768857", "filename": "gcc/match.pd", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -3561,12 +3561,12 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n      tree base1 = get_addr_base_and_unit_offset (TREE_OPERAND (@1, 0), &off1);\n      if (base0 && TREE_CODE (base0) == MEM_REF)\n        {\n-\t off0 += mem_ref_offset (base0).to_short_addr ();\n+\t off0 += mem_ref_offset (base0).force_shwi ();\n          base0 = TREE_OPERAND (base0, 0);\n        }\n      if (base1 && TREE_CODE (base1) == MEM_REF)\n        {\n-         off1 += mem_ref_offset (base1).to_short_addr ();\n+\t off1 += mem_ref_offset (base1).force_shwi ();\n          base1 = TREE_OPERAND (base1, 0);\n        }\n    }"}, {"sha": "2707cf82ebafff7f691d007f35ea63fcf195e71d", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -820,25 +820,25 @@ dr_analyze_innermost (innermost_loop_behavior *drb, tree ref,\n     }\n \n   /* Calculate the alignment and misalignment for the inner reference.  */\n-  unsigned int HOST_WIDE_INT base_misalignment;\n-  unsigned int base_alignment;\n-  get_object_alignment_1 (base, &base_alignment, &base_misalignment);\n+  unsigned int HOST_WIDE_INT bit_base_misalignment;\n+  unsigned int bit_base_alignment;\n+  get_object_alignment_1 (base, &bit_base_alignment, &bit_base_misalignment);\n \n   /* There are no bitfield references remaining in BASE, so the values\n      we got back must be whole bytes.  */\n-  gcc_assert (base_alignment % BITS_PER_UNIT == 0\n-\t      && base_misalignment % BITS_PER_UNIT == 0);\n-  base_alignment /= BITS_PER_UNIT;\n-  base_misalignment /= BITS_PER_UNIT;\n+  gcc_assert (bit_base_alignment % BITS_PER_UNIT == 0\n+\t      && bit_base_misalignment % BITS_PER_UNIT == 0);\n+  unsigned int base_alignment = bit_base_alignment / BITS_PER_UNIT;\n+  poly_int64 base_misalignment = bit_base_misalignment / BITS_PER_UNIT;\n \n   if (TREE_CODE (base) == MEM_REF)\n     {\n       if (!integer_zerop (TREE_OPERAND (base, 1)))\n \t{\n \t  /* Subtract MOFF from the base and add it to POFFSET instead.\n \t     Adjust the misalignment to reflect the amount we subtracted.  */\n-\t  offset_int moff = mem_ref_offset (base);\n-\t  base_misalignment -= moff.to_short_addr ();\n+\t  poly_offset_int moff = mem_ref_offset (base);\n+\t  base_misalignment -= moff.force_shwi ();\n \t  tree mofft = wide_int_to_tree (sizetype, moff);\n \t  if (!poffset)\n \t    poffset = mofft;\n@@ -925,8 +925,14 @@ dr_analyze_innermost (innermost_loop_behavior *drb, tree ref,\n   drb->offset = fold_convert (ssizetype, offset_iv.base);\n   drb->init = init;\n   drb->step = step;\n-  drb->base_alignment = base_alignment;\n-  drb->base_misalignment = base_misalignment & (base_alignment - 1);\n+  if (known_misalignment (base_misalignment, base_alignment,\n+\t\t\t  &drb->base_misalignment))\n+    drb->base_alignment = base_alignment;\n+  else\n+    {\n+      drb->base_alignment = known_alignment (base_misalignment);\n+      drb->base_misalignment = 0;\n+    }\n   drb->offset_alignment = highest_pow2_factor (offset_iv.base);\n   drb->step_alignment = highest_pow2_factor (step);\n "}, {"sha": "3358763b466ee8d686fbb1fdf08b1b5f22378e71", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -798,8 +798,8 @@ get_addr_base_and_unit_offset_1 (tree exp, poly_int64_pod *poffset,\n \t      {\n \t\tif (!integer_zerop (TREE_OPERAND (exp, 1)))\n \t\t  {\n-\t\t    offset_int off = mem_ref_offset (exp);\n-\t\t    byte_offset += off.to_short_addr ();\n+\t\t    poly_offset_int off = mem_ref_offset (exp);\n+\t\t    byte_offset += off.force_shwi ();\n \t\t  }\n \t\texp = TREE_OPERAND (base, 0);\n \t      }\n@@ -820,8 +820,8 @@ get_addr_base_and_unit_offset_1 (tree exp, poly_int64_pod *poffset,\n \t\t  return NULL_TREE;\n \t\tif (!integer_zerop (TMR_OFFSET (exp)))\n \t\t  {\n-\t\t    offset_int off = mem_ref_offset (exp);\n-\t\t    byte_offset += off.to_short_addr ();\n+\t\t    poly_offset_int off = mem_ref_offset (exp);\n+\t\t    byte_offset += off.force_shwi ();\n \t\t  }\n \t\texp = TREE_OPERAND (base, 0);\n \t      }"}, {"sha": "fc5fb02ddcd52e8653b47126f8e3a591426af5c9", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -2658,14 +2658,15 @@ tree_could_trap_p (tree expr)\n       if (TREE_CODE (TREE_OPERAND (expr, 0)) == ADDR_EXPR)\n \t{\n \t  tree base = TREE_OPERAND (TREE_OPERAND (expr, 0), 0);\n-\t  offset_int off = mem_ref_offset (expr);\n-\t  if (wi::neg_p (off, SIGNED))\n+\t  poly_offset_int off = mem_ref_offset (expr);\n+\t  if (maybe_lt (off, 0))\n \t    return true;\n \t  if (TREE_CODE (base) == STRING_CST)\n-\t    return wi::leu_p (TREE_STRING_LENGTH (base), off);\n-\t  else if (DECL_SIZE_UNIT (base) == NULL_TREE\n-\t\t   || TREE_CODE (DECL_SIZE_UNIT (base)) != INTEGER_CST\n-\t\t   || wi::leu_p (wi::to_offset (DECL_SIZE_UNIT (base)), off))\n+\t    return maybe_le (TREE_STRING_LENGTH (base), off);\n+\t  tree size = DECL_SIZE_UNIT (base);\n+\t  if (size == NULL_TREE\n+\t      || !poly_int_tree_p (size)\n+\t      || maybe_le (wi::to_poly_offset (size), off))\n \t    return true;\n \t  /* Now we are sure the first byte of the access is inside\n \t     the object.  */"}, {"sha": "488676e4d20dad8381bb5f9b2935d1f947354f8d", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -210,11 +210,17 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t}\n       if (sz != unknown[object_size_type])\n \t{\n-\t  offset_int dsz = wi::sub (sz, mem_ref_offset (pt_var));\n-\t  if (wi::neg_p (dsz))\n-\t    sz = 0;\n-\t  else if (wi::fits_uhwi_p (dsz))\n-\t    sz = dsz.to_uhwi ();\n+\t  offset_int mem_offset;\n+\t  if (mem_ref_offset (pt_var).is_constant (&mem_offset))\n+\t    {\n+\t      offset_int dsz = wi::sub (sz, mem_offset);\n+\t      if (wi::neg_p (dsz))\n+\t\tsz = 0;\n+\t      else if (wi::fits_uhwi_p (dsz))\n+\t\tsz = dsz.to_uhwi ();\n+\t      else\n+\t\tsz = unknown[object_size_type];\n+\t    }\n \t  else\n \t    sz = unknown[object_size_type];\n \t}"}, {"sha": "87df1238bfa57462acc7c2eb4d97803cff81e38d", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -1008,8 +1008,8 @@ copy_ref_info (tree new_ref, tree old_ref)\n \t\t\t   && (TREE_INT_CST_LOW (TMR_STEP (new_ref))\n \t\t\t       < align)))))\n \t    {\n-\t      unsigned int inc = (mem_ref_offset (old_ref).to_short_addr ()\n-\t\t\t\t  - mem_ref_offset (new_ref).to_short_addr ());\n+\t      poly_uint64 inc = (mem_ref_offset (old_ref)\n+\t\t\t\t - mem_ref_offset (new_ref)).force_uhwi ();\n \t      adjust_ptr_info_misalignment (new_pi, inc);\n \t    }\n \t  else"}, {"sha": "7601b19408cdbca9ef6ad2e363bbb08206837707", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -1139,7 +1139,7 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n \t\t       && DECL_P (base2));\n \n   ptr1 = TREE_OPERAND (base1, 0);\n-  offset_int moff = mem_ref_offset (base1) << LOG2_BITS_PER_UNIT;\n+  poly_offset_int moff = mem_ref_offset (base1) << LOG2_BITS_PER_UNIT;\n \n   /* If only one reference is based on a variable, they cannot alias if\n      the pointer access is beyond the extent of the variable access.\n@@ -1295,8 +1295,8 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n \t\t      && operand_equal_p (TMR_INDEX2 (base1),\n \t\t\t\t\t  TMR_INDEX2 (base2), 0))))))\n     {\n-      offset_int moff1 = mem_ref_offset (base1) << LOG2_BITS_PER_UNIT;\n-      offset_int moff2 = mem_ref_offset (base2) << LOG2_BITS_PER_UNIT;\n+      poly_offset_int moff1 = mem_ref_offset (base1) << LOG2_BITS_PER_UNIT;\n+      poly_offset_int moff2 = mem_ref_offset (base2) << LOG2_BITS_PER_UNIT;\n       return ranges_maybe_overlap_p (offset1 + moff1, max_size1,\n \t\t\t\t     offset2 + moff2, max_size2);\n     }"}, {"sha": "7146f8f7e2dc773f06c8923272dd3a72ad52f297", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -766,11 +766,8 @@ copy_reference_ops_from_ref (tree ref, vec<vn_reference_op_s> *result)\n \tcase MEM_REF:\n \t  /* The base address gets its own vn_reference_op_s structure.  */\n \t  temp.op0 = TREE_OPERAND (ref, 1);\n-\t    {\n-\t      offset_int off = mem_ref_offset (ref);\n-\t      if (wi::fits_shwi_p (off))\n-\t\ttemp.off = off.to_shwi ();\n-\t    }\n+\t  if (!mem_ref_offset (ref).to_shwi (&temp.off))\n+\t    temp.off = -1;\n \t  temp.clique = MR_DEPENDENCE_CLIQUE (ref);\n \t  temp.base = MR_DEPENDENCE_BASE (ref);\n \t  temp.reverse = REF_REVERSE_STORAGE_ORDER (ref);"}, {"sha": "c04e0cc6dbf9259219338aba11891000374f439e", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -1379,10 +1379,10 @@ maybe_rewrite_mem_ref_base (tree *tp, bitmap suitable_for_renaming)\n \t}\n       else if (DECL_SIZE (sym)\n \t       && TREE_CODE (DECL_SIZE (sym)) == INTEGER_CST\n-\t       && mem_ref_offset (*tp) >= 0\n-\t       && wi::leu_p (mem_ref_offset (*tp)\n-\t\t\t     + wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (*tp))),\n-\t\t\t     wi::to_offset (DECL_SIZE_UNIT (sym)))\n+\t       && (known_subrange_p\n+\t\t   (mem_ref_offset (*tp),\n+\t\t    wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (*tp))),\n+\t\t    0, wi::to_offset (DECL_SIZE_UNIT (sym))))\n \t       && (! INTEGRAL_TYPE_P (TREE_TYPE (*tp)) \n \t\t   || (wi::to_offset (TYPE_SIZE (TREE_TYPE (*tp)))\n \t\t       == TYPE_PRECISION (TREE_TYPE (*tp))))\n@@ -1433,9 +1433,8 @@ non_rewritable_mem_ref_base (tree ref)\n \t   || TREE_CODE (TREE_TYPE (decl)) == COMPLEX_TYPE)\n \t  && useless_type_conversion_p (TREE_TYPE (base),\n \t\t\t\t\tTREE_TYPE (TREE_TYPE (decl)))\n-\t  && wi::fits_uhwi_p (mem_ref_offset (base))\n-\t  && wi::gtu_p (wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (decl))),\n-\t\t\tmem_ref_offset (base))\n+\t  && known_gt (wi::to_poly_offset (TYPE_SIZE_UNIT (TREE_TYPE (decl))),\n+\t\t       mem_ref_offset (base))\n \t  && multiple_of_p (sizetype, TREE_OPERAND (base, 1),\n \t\t\t    TYPE_SIZE_UNIT (TREE_TYPE (base))))\n \treturn NULL_TREE;\n@@ -1445,11 +1444,10 @@ non_rewritable_mem_ref_base (tree ref)\n \treturn NULL_TREE;\n       /* For integral typed extracts we can use a BIT_FIELD_REF.  */\n       if (DECL_SIZE (decl)\n-\t  && TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST\n-\t  && mem_ref_offset (base) >= 0\n-\t  && wi::leu_p (mem_ref_offset (base)\n-\t\t\t+ wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (base))),\n-\t\t\twi::to_offset (DECL_SIZE_UNIT (decl)))\n+\t  && (known_subrange_p\n+\t      (mem_ref_offset (base),\n+\t       wi::to_poly_offset (TYPE_SIZE_UNIT (TREE_TYPE (base))),\n+\t       0, wi::to_poly_offset (DECL_SIZE_UNIT (decl))))\n \t  /* ???  We can't handle bitfield precision extracts without\n \t     either using an alternate type for the BIT_FIELD_REF and\n \t     then doing a conversion or possibly adjusting the offset"}, {"sha": "7d039185446915557b574fe90437f076db375b26", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -3276,10 +3276,7 @@ vect_check_gather_scatter (gimple *stmt, loop_vec_info loop_vinfo,\n       if (!integer_zerop (TREE_OPERAND (base, 1)))\n \t{\n \t  if (off == NULL_TREE)\n-\t    {\n-\t      offset_int moff = mem_ref_offset (base);\n-\t      off = wide_int_to_tree (sizetype, moff);\n-\t    }\n+\t    off = wide_int_to_tree (sizetype, mem_ref_offset (base));\n \t  else\n \t    off = size_binop (PLUS_EXPR, off,\n \t\t\t      fold_convert (sizetype, TREE_OPERAND (base, 1)));"}, {"sha": "27f7c37cbd7f7b9fd02b1362da1d6ec10a54675f", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -4952,7 +4952,9 @@ vrp_prop::search_for_addr_array (tree t, location_t location)\n \t  || TREE_CODE (el_sz) != INTEGER_CST)\n \treturn;\n \n-      idx = mem_ref_offset (t);\n+      if (!mem_ref_offset (t).is_constant (&idx))\n+\treturn;\n+\n       idx = wi::sdiv_trunc (idx, wi::to_offset (el_sz));\n       if (idx < 0)\n \t{\n@@ -5266,7 +5268,6 @@ remove_range_assertions (void)\n       }\n }\n \n-\n /* Return true if STMT is interesting for VRP.  */\n \n bool"}, {"sha": "97c9f815039b1333e59e32a8b925fd49951b07a0", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -4840,7 +4840,7 @@ build_simple_mem_ref_loc (location_t loc, tree ptr)\n       gcc_assert (ptr);\n       if (TREE_CODE (ptr) == MEM_REF)\n \t{\n-\t  offset += mem_ref_offset (ptr).to_short_addr ();\n+\t  offset += mem_ref_offset (ptr).force_shwi ();\n \t  ptr = TREE_OPERAND (ptr, 0);\n \t}\n       else\n@@ -4855,10 +4855,11 @@ build_simple_mem_ref_loc (location_t loc, tree ptr)\n \n /* Return the constant offset of a MEM_REF or TARGET_MEM_REF tree T.  */\n \n-offset_int\n+poly_offset_int\n mem_ref_offset (const_tree t)\n {\n-  return offset_int::from (wi::to_wide (TREE_OPERAND (t, 1)), SIGNED);\n+  return poly_offset_int::from (wi::to_poly_wide (TREE_OPERAND (t, 1)),\n+\t\t\t\tSIGNED);\n }\n \n /* Return an invariant ADDR_EXPR of type TYPE taking the address of BASE"}, {"sha": "28e35ff6c3e9fa142c7512eb5afac82ef1d9092c", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aca52e6f8d29064f4712e5f3f4429a36f918f099/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=aca52e6f8d29064f4712e5f3f4429a36f918f099", "patch": "@@ -2904,7 +2904,7 @@ decode_addr_const (tree exp, struct addr_const *value)\n       else if (TREE_CODE (target) == MEM_REF\n \t       && TREE_CODE (TREE_OPERAND (target, 0)) == ADDR_EXPR)\n \t{\n-\t  offset += mem_ref_offset (target).to_short_addr ();\n+\t  offset += mem_ref_offset (target).force_shwi ();\n \t  target = TREE_OPERAND (TREE_OPERAND (target, 0), 0);\n \t}\n       else if (TREE_CODE (target) == INDIRECT_REF"}]}