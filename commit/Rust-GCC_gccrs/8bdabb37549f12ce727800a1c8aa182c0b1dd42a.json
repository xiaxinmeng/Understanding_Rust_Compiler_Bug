{"sha": "8bdabb37549f12ce727800a1c8aa182c0b1dd42a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJkYWJiMzc1NDlmMTJjZTcyNzgwMGExYzhhYTE4MmMwYjFkZDQyYQ==", "commit": {"author": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2021-08-03T17:27:44Z"}, "committer": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2021-09-07T20:48:58Z"}, "message": "bpf: BPF CO-RE support\n\nThis commit introduces support for BPF Compile Once - Run\nEverywhere (CO-RE) in GCC.\n\ngcc/ChangeLog:\n\n\t* config/bpf/bpf.c: Adjust includes.\n\t(bpf_handle_preserve_access_index_attribute): New function.\n\t(bpf_attribute_table): Use it here.\n\t(bpf_builtins): Add BPF_BUILTIN_PRESERVE_ACCESS_INDEX.\n\t(bpf_option_override): Handle \"-mco-re\" option.\n\t(bpf_asm_init_sections): New.\n\t(TARGET_ASM_INIT_SECTIONS): Redefine.\n\t(bpf_file_end): New.\n\t(TARGET_ASM_FILE_END): Redefine.\n\t(bpf_init_builtins): Add \"__builtin_preserve_access_index\".\n\t(bpf_core_compute, bpf_core_get_index): New.\n\t(is_attr_preserve_access): New.\n\t(bpf_expand_builtin): Handle new builtins.\n\t(bpf_core_newdecl, bpf_core_is_maybe_aggregate_access): New.\n\t(bpf_core_walk): New.\n\t(bpf_resolve_overloaded_builtin): New.\n\t(TARGET_RESOLVE_OVERLOADED_BUILTIN): Redefine.\n\t(handle_attr): New.\n\t(pass_bpf_core_attr): New RTL pass.\n\t* config/bpf/bpf-passes.def: New file.\n\t* config/bpf/bpf-protos.h (make_pass_bpf_core_attr): New.\n\t* config/bpf/coreout.c: New file.\n\t* config/bpf/coreout.h: Likewise.\n\t* config/bpf/t-bpf (TM_H): Add $(srcdir)/config/bpf/coreout.h.\n\t(coreout.o): New rule.\n\t(PASSES_EXTRA): Add $(srcdir)/config/bpf/bpf-passes.def.\n\t* config.gcc (bpf): Add coreout.h to extra_headers.\n\tAdd coreout.o to extra_objs.\n\tAdd $(srcdir)/config/bpf/coreout.c to target_gtfiles.", "tree": {"sha": "6c04e6ec8a3e394c1d2928b43189d61ae7254ef7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c04e6ec8a3e394c1d2928b43189d61ae7254ef7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8bdabb37549f12ce727800a1c8aa182c0b1dd42a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bdabb37549f12ce727800a1c8aa182c0b1dd42a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bdabb37549f12ce727800a1c8aa182c0b1dd42a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bdabb37549f12ce727800a1c8aa182c0b1dd42a/comments", "author": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a2bd52f1a903060a7b305b429aa71fb68995bb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a2bd52f1a903060a7b305b429aa71fb68995bb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a2bd52f1a903060a7b305b429aa71fb68995bb7"}], "stats": {"total": 1094, "additions": 1094, "deletions": 0}, "files": [{"sha": "e3e9d8f676f02dbf8068710618b2291003e30162", "filename": "gcc/config.gcc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bdabb37549f12ce727800a1c8aa182c0b1dd42a/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bdabb37549f12ce727800a1c8aa182c0b1dd42a/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=8bdabb37549f12ce727800a1c8aa182c0b1dd42a", "patch": "@@ -1525,6 +1525,9 @@ bpf-*-*)\n         use_collect2=no\n         extra_headers=\"bpf-helpers.h\"\n         use_gcc_stdint=provide\n+        extra_headers=\"coreout.h\"\n+        extra_objs=\"coreout.o\"\n+        target_gtfiles=\"$target_gtfiles \\$(srcdir)/config/bpf/coreout.c\"\n         ;;\n cr16-*-elf)\n         tm_file=\"elfos.h ${tm_file} newlib-stdint.h\""}, {"sha": "3e9616594110eaad362332eae450673d8af42c11", "filename": "gcc/config/bpf/bpf-passes.def", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bdabb37549f12ce727800a1c8aa182c0b1dd42a/gcc%2Fconfig%2Fbpf%2Fbpf-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bdabb37549f12ce727800a1c8aa182c0b1dd42a/gcc%2Fconfig%2Fbpf%2Fbpf-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf-passes.def?ref=8bdabb37549f12ce727800a1c8aa182c0b1dd42a", "patch": "@@ -0,0 +1,20 @@\n+/* Declaration of target-specific passes for eBPF.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+INSERT_PASS_AFTER (pass_df_initialize_opt, 1, pass_bpf_core_attr);"}, {"sha": "7ce3386ffdafa79e60adcd29fe554e98439162ab", "filename": "gcc/config/bpf/bpf-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bdabb37549f12ce727800a1c8aa182c0b1dd42a/gcc%2Fconfig%2Fbpf%2Fbpf-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bdabb37549f12ce727800a1c8aa182c0b1dd42a/gcc%2Fconfig%2Fbpf%2Fbpf-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf-protos.h?ref=8bdabb37549f12ce727800a1c8aa182c0b1dd42a", "patch": "@@ -30,4 +30,6 @@ extern void bpf_print_operand_address (FILE *, rtx);\n extern void bpf_expand_prologue (void);\n extern void bpf_expand_epilogue (void);\n \n+rtl_opt_pass * make_pass_bpf_core_attr (gcc::context *);\n+\n #endif /* ! GCC_BPF_PROTOS_H */"}, {"sha": "01d9c03479eb9702c9a4fdc5642e9c8f20c29f8a", "filename": "gcc/config/bpf/bpf.c", "status": "modified", "additions": 591, "deletions": 0, "changes": 591, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bdabb37549f12ce727800a1c8aa182c0b1dd42a/gcc%2Fconfig%2Fbpf%2Fbpf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bdabb37549f12ce727800a1c8aa182c0b1dd42a/gcc%2Fconfig%2Fbpf%2Fbpf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf.c?ref=8bdabb37549f12ce727800a1c8aa182c0b1dd42a", "patch": "@@ -56,6 +56,24 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"flags.h\"\n \n+#include \"cfg.h\" /* needed for struct control_flow_graph used in BB macros */\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-walk.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-iterator.h\"\n+\n+#include \"context.h\"\n+#include \"pass_manager.h\"\n+\n+#include \"gimplify.h\"\n+#include \"gimplify-me.h\"\n+\n+#include \"ctfc.h\"\n+#include \"btf.h\"\n+\n+#include \"coreout.h\"\n+\n /* Per-function machine data.  */\n struct GTY(()) machine_function\n {\n@@ -105,6 +123,27 @@ bpf_handle_fndecl_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+/* Handle preserve_access_index attribute, which can be applied to structs,\n+   unions and classes. Actually adding the attribute to the TYPE_DECL is\n+   taken care of for us, so just warn for types that aren't supported.  */\n+\n+static tree\n+bpf_handle_preserve_access_index_attribute (tree *node, tree name,\n+\t\t\t\t\t    tree args,\n+\t\t\t\t\t    int flags,\n+\t\t\t\t\t    bool *no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != RECORD_TYPE && TREE_CODE (*node) != UNION_TYPE)\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%qE attribute only applies to structure, union and class types\",\n+\t       name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Target-specific attributes.  */\n \n static const struct attribute_spec bpf_attribute_table[] =\n@@ -117,6 +156,11 @@ static const struct attribute_spec bpf_attribute_table[] =\n  { \"kernel_helper\", 1, 1, true, false, false, false,\n    bpf_handle_fndecl_attribute, NULL },\n \n+ /* CO-RE support: attribute to mark that all accesses to the declared\n+    struct/union/array should be recorded.  */\n+ { \"preserve_access_index\", 0, -1, false, true, false, true,\n+   bpf_handle_preserve_access_index_attribute, NULL },\n+\n  /* The last attribute spec is set to be NULL.  */\n  { NULL,\t0,  0, false, false, false, false, NULL, NULL }\n };\n@@ -137,11 +181,18 @@ enum bpf_builtins\n   BPF_BUILTIN_LOAD_BYTE,\n   BPF_BUILTIN_LOAD_HALF,\n   BPF_BUILTIN_LOAD_WORD,\n+\n+  /* Compile Once - Run Everywhere (CO-RE) support.  */\n+  BPF_BUILTIN_PRESERVE_ACCESS_INDEX,\n+\n   BPF_BUILTIN_MAX,\n };\n \n static GTY (()) tree bpf_builtins[(int) BPF_BUILTIN_MAX];\n \n+\n+void bpf_register_coreattr_pass (void);\n+\n /* Initialize the per-function machine status.  */\n \n static struct machine_function *\n@@ -183,11 +234,57 @@ bpf_option_override (void)\n \n   if (flag_lto && TARGET_BPF_CORE)\n     sorry (\"BPF CO-RE does not support LTO\");\n+\n+  /* -gbtf implies -mcore when using the BPF backend, unless -mno-co-re\n+     is specified.  */\n+  if (btf_debuginfo_p () && !(target_flags_explicit & MASK_BPF_CORE))\n+    {\n+      target_flags |= MASK_BPF_CORE;\n+      write_symbols |= BTF_WITH_CORE_DEBUG;\n+    }\n }\n \n #undef TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE bpf_option_override\n \n+/* Return FALSE iff -mcore has been specified.  */\n+\n+static bool\n+ctfc_debuginfo_early_finish_p (void)\n+{\n+  if (TARGET_BPF_CORE)\n+    return false;\n+  else\n+    return true;\n+}\n+\n+#undef TARGET_CTFC_DEBUGINFO_EARLY_FINISH_P\n+#define TARGET_CTFC_DEBUGINFO_EARLY_FINISH_P ctfc_debuginfo_early_finish_p\n+\n+/* Implement TARGET_ASM_INIT_SECTIONS.  */\n+\n+static void\n+bpf_asm_init_sections (void)\n+{\n+  if (TARGET_BPF_CORE)\n+    btf_ext_init ();\n+}\n+\n+#undef TARGET_ASM_INIT_SECTIONS\n+#define TARGET_ASM_INIT_SECTIONS bpf_asm_init_sections\n+\n+/* Implement TARGET_ASM_FILE_END.  */\n+\n+static void\n+bpf_file_end (void)\n+{\n+  if (TARGET_BPF_CORE)\n+    btf_ext_output ();\n+}\n+\n+#undef TARGET_ASM_FILE_END\n+#define TARGET_ASM_FILE_END bpf_file_end\n+\n /* Define target-specific CPP macros.  This function in used in the\n    definition of TARGET_CPU_CPP_BUILTINS in bpf.h */\n \n@@ -837,11 +934,18 @@ bpf_init_builtins (void)\n \t       build_function_type_list (ullt, ullt, 0));\n   def_builtin (\"__builtin_bpf_load_word\", BPF_BUILTIN_LOAD_WORD,\n \t       build_function_type_list (ullt, ullt, 0));\n+  def_builtin (\"__builtin_preserve_access_index\",\n+\t       BPF_BUILTIN_PRESERVE_ACCESS_INDEX,\n+\t       build_function_type_list (ptr_type_node, ptr_type_node, 0));\n }\n \n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS bpf_init_builtins\n \n+static tree bpf_core_compute (tree, vec<unsigned int> *);\n+static int bpf_core_get_index (const tree);\n+static bool is_attr_preserve_access (tree);\n+\n /* Expand a call to a BPF-specific built-in function that was set up\n    with bpf_init_builtins.  */\n \n@@ -892,7 +996,75 @@ bpf_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n       /* The result of the load is in R0.  */\n       return gen_rtx_REG (ops[0].mode, BPF_R0);\n     }\n+  else if (code == -1)\n+    {\n+      /* A resolved overloaded builtin, e.g. __bpf_preserve_access_index_si */\n+      tree arg = CALL_EXPR_ARG (exp, 0);\n+\n+      if (arg == NULL_TREE)\n+\treturn NULL_RTX;\n+\n+      auto_vec<unsigned int, 16> accessors;\n+      tree container;\n \n+      if (TREE_CODE (arg) == SSA_NAME)\n+\t{\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (arg);\n+\n+\t  if (is_gimple_assign (def_stmt))\n+\t    arg = gimple_assign_rhs1 (def_stmt);\n+\t  else\n+\t    return expand_normal (arg);\n+\t}\n+\n+      /* Avoid double-recording information if the argument is an access to\n+\t a struct/union marked __attribute__((preserve_access_index)). This\n+\t Will be handled by the attribute handling pass.  */\n+      if (is_attr_preserve_access (arg))\n+\treturn expand_normal (arg);\n+\n+      container = bpf_core_compute (arg, &accessors);\n+\n+      /* Any valid use of the builtin must have at least one access. Otherwise,\n+\t there is nothing to record and nothing to do. This is primarily a\n+\t guard against optimizations leading to unexpected expressions in the\n+\t argument of the builtin. For example, if the builtin is used to read\n+\t a field of a structure which can be statically determined to hold a\n+\t constant value, the argument to the builtin will be optimized to that\n+\t constant. This is OK, and means the builtin call is superfluous.\n+\t e.g.\n+\t   struct S foo;\n+\t   foo.a = 5;\n+\t   int x = __preserve_access_index (foo.a);\n+\t   ... do stuff with x\n+\t 'foo.a' in the builtin argument will be optimized to '5' with -01+.\n+\t This sequence does not warrant recording a CO-RE relocation.  */\n+\n+      if (accessors.length () < 1)\n+\treturn expand_normal (arg);\n+\n+      accessors.reverse ();\n+\n+      container = TREE_TYPE (container);\n+\n+      rtx_code_label *label = gen_label_rtx ();\n+      LABEL_PRESERVE_P (label) = 1;\n+      emit_label (label);\n+\n+      /* Determine what output section this relocation will apply to.\n+\t If this function is associated with a section, use that. Otherwise,\n+\t fall back on '.text'.  */\n+      const char * section_name;\n+      if (current_function_decl && DECL_SECTION_NAME (current_function_decl))\n+\tsection_name = DECL_SECTION_NAME (current_function_decl);\n+      else\n+\tsection_name = \".text\";\n+\n+      /* Add the CO-RE relocation information to the BTF container.  */\n+      bpf_core_reloc_add (container, section_name, &accessors, label);\n+\n+      return expand_normal (arg);\n+    }\n   gcc_unreachable ();\n }\n \n@@ -946,6 +1118,425 @@ bpf_debug_unwind_info ()\n #undef TARGET_ASM_ALIGNED_DI_OP\n #define TARGET_ASM_ALIGNED_DI_OP \"\\t.dword\\t\"\n \n+\n+/* BPF Compile Once - Run Everywhere (CO-RE) support routines.\n+\n+   BPF CO-RE is supported in two forms:\n+   - A target builtin, __builtin_preserve_access_index\n+\n+     This builtin accepts a single argument. Any access to an aggregate data\n+     structure (struct, union or array) within the argument will be recorded by\n+     the CO-RE machinery, resulting in a relocation record being placed in the\n+     .BTF.ext section of the output.\n+\n+     It is implemented in bpf_resolve_overloaded_builtin () and\n+     bpf_expand_builtin (), using the supporting routines below.\n+\n+   - An attribute, __attribute__((preserve_access_index))\n+\n+     This attribute can be applied to struct and union types. Any access to a\n+     type with this attribute will be recorded by the CO-RE machinery.\n+\n+     The pass pass_bpf_core_attr, below, implements support for\n+     this attribute.  */\n+\n+/* Traverse the subtree under NODE, which is expected to be some form of\n+   aggregate access the CO-RE machinery cares about (like a read of a member of\n+   a struct or union), collecting access indices for the components and storing\n+   them in the vector referenced by ACCESSORS.\n+\n+   Return the ultimate (top-level) container of the aggregate access. In general,\n+   this will be a VAR_DECL or some kind of REF.\n+\n+   Note that the accessors are computed *in reverse order* of how the BPF\n+   CO-RE machinery defines them. The vector needs to be reversed (or simply\n+   output in reverse order) for the .BTF.ext relocation information.  */\n+\n+static tree\n+bpf_core_compute (tree node, vec<unsigned int> *accessors)\n+{\n+\n+  if (TREE_CODE (node) == ADDR_EXPR)\n+    node = TREE_OPERAND (node, 0);\n+\n+  else if (TREE_CODE (node) == INDIRECT_REF\n+\t   || TREE_CODE (node) == POINTER_PLUS_EXPR)\n+    {\n+      accessors->safe_push (0);\n+      return TREE_OPERAND (node, 0);\n+    }\n+\n+  while (1)\n+    {\n+      switch (TREE_CODE (node))\n+\t{\n+\tcase COMPONENT_REF:\n+\t  accessors->safe_push (bpf_core_get_index (TREE_OPERAND (node, 1)));\n+\t  break;\n+\n+\tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n+\t  accessors->safe_push (bpf_core_get_index (node));\n+\t  break;\n+\n+\tcase MEM_REF:\n+\t  accessors->safe_push (bpf_core_get_index (node));\n+\t  if (TREE_CODE (TREE_OPERAND (node, 0)) == ADDR_EXPR)\n+\t    node = TREE_OPERAND (TREE_OPERAND (node, 0), 0);\n+\t  goto done;\n+\n+\tdefault:\n+\t  goto done;\n+\t}\n+      node = TREE_OPERAND (node, 0);\n+    }\n+ done:\n+  return node;\n+\n+}\n+\n+/* Compute the index of the NODE in its immediate container.\n+   NODE should be a FIELD_DECL (i.e. of struct or union), or an ARRAY_REF. */\n+static int\n+bpf_core_get_index (const tree node)\n+{\n+  enum tree_code code = TREE_CODE (node);\n+\n+  if (code == FIELD_DECL)\n+    {\n+      /* Lookup the index from the BTF information.  Some struct/union members\n+\t may not be emitted in BTF; only the BTF container has enough\n+\t information to compute the correct index.  */\n+      int idx = bpf_core_get_sou_member_index (ctf_get_tu_ctfc (), node);\n+      if (idx >= 0)\n+\treturn idx;\n+    }\n+\n+  else if (code == ARRAY_REF || code == ARRAY_RANGE_REF || code == MEM_REF)\n+    {\n+      /* For array accesses, the index is operand 1.  */\n+      tree index = TREE_OPERAND (node, 1);\n+\n+      /* If the indexing operand is a constant, extracting is trivial.  */\n+      if (TREE_CODE (index) == INTEGER_CST && tree_fits_shwi_p (index))\n+\treturn tree_to_shwi (index);\n+    }\n+\n+  return -1;\n+}\n+\n+/* Synthesize a new builtin function declaration at LOC with signature TYPE.\n+   Used by bpf_resolve_overloaded_builtin to resolve calls to\n+   __builtin_preserve_access_index.  */\n+\n+static tree\n+bpf_core_newdecl (location_t loc, tree type)\n+{\n+  tree rettype = build_function_type_list (type, type, NULL);\n+  tree newdecl = NULL_TREE;\n+  char name[80];\n+  int len = snprintf (name, sizeof (name), \"%s\", \"__builtin_pai_\");\n+\n+  static unsigned long cnt = 0;\n+  len = snprintf (name + len, sizeof (name) - len, \"%lu\", cnt++);\n+\n+  return add_builtin_function_ext_scope (name, rettype, -1, BUILT_IN_MD, NULL,\n+\t\t\t\t\t NULL_TREE);\n+}\n+\n+/* Return whether EXPR could access some aggregate data structure that\n+   BPF CO-RE support needs to know about.  */\n+\n+static int\n+bpf_core_is_maybe_aggregate_access (tree expr)\n+{\n+  enum tree_code code = TREE_CODE (expr);\n+  if (code == COMPONENT_REF || code == ARRAY_REF)\n+    return 1;\n+\n+  if (code == ADDR_EXPR)\n+      return bpf_core_is_maybe_aggregate_access (TREE_OPERAND (expr, 0));\n+\n+  return 0;\n+}\n+\n+/* Callback function used with walk_tree from bpf_resolve_overloaded_builtin.  */\n+\n+static tree\n+bpf_core_walk (tree *tp, int *walk_subtrees, void *data)\n+{\n+  location_t loc = *((location_t *) data);\n+\n+  /* If this is a type, don't do anything. */\n+  if (TYPE_P (*tp))\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  if (bpf_core_is_maybe_aggregate_access (*tp))\n+    {\n+      tree newdecl = bpf_core_newdecl (loc, TREE_TYPE (*tp));\n+      tree newcall = build_call_expr_loc (loc, newdecl, 1, *tp);\n+      *tp = newcall;\n+      *walk_subtrees = 0;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\n+/* Implement TARGET_RESOLVE_OVERLOADED_BUILTIN (see gccint manual section\n+   Target Macros::Misc.).\n+   We use this for the __builtin_preserve_access_index builtin for CO-RE\n+   support.\n+\n+   FNDECL is the declaration of the builtin, and ARGLIST is the list of\n+   arguments passed to it, and is really a vec<tree,_> *.\n+\n+   In this case, the 'operation' implemented by the builtin is a no-op;\n+   the builtin is just a marker. So, the result is simply the argument.  */\n+\n+static tree\n+bpf_resolve_overloaded_builtin (location_t loc, tree fndecl, void *arglist)\n+{\n+  if (DECL_MD_FUNCTION_CODE (fndecl) != BPF_BUILTIN_PRESERVE_ACCESS_INDEX)\n+    return NULL_TREE;\n+\n+  /* We only expect one argument, but it may be an arbitrarily-complicated\n+     statement-expression. */\n+  vec<tree, va_gc> *params = static_cast<vec<tree, va_gc> *> (arglist);\n+  unsigned n_params = params ? params->length() : 0;\n+\n+  if (n_params != 1)\n+    {\n+      error_at (loc, \"expected exactly 1 argument\");\n+      return NULL_TREE;\n+    }\n+\n+  tree param = (*params)[0];\n+\n+  /* If not generating BPF_CORE information, the builtin does nothing.  */\n+  if (!TARGET_BPF_CORE)\n+    return param;\n+\n+  /* Do remove_c_maybe_const_expr for the arg.\n+     TODO: WHY do we have to do this here? Why doesn't c-typeck take care\n+     of it before or after this hook? */\n+  if (TREE_CODE (param) == C_MAYBE_CONST_EXPR)\n+    param = C_MAYBE_CONST_EXPR_EXPR (param);\n+\n+  /* Construct a new function declaration with the correct type, and return\n+     a call to it.\n+\n+     Calls with statement-expressions, for example:\n+     _(({ foo->a = 1; foo->u[2].b = 2; }))\n+     require special handling.\n+\n+     We rearrange this into a new block scope in which each statement\n+     becomes a unique builtin call:\n+     {\n+       _ ({ foo->a = 1;});\n+       _ ({ foo->u[2].b = 2;});\n+     }\n+\n+     This ensures that all the relevant information remains within the\n+     expression trees the builtin finally gets.  */\n+\n+  walk_tree (&param, bpf_core_walk, (void *) &loc, NULL);\n+\n+  return param;\n+}\n+\n+#undef TARGET_RESOLVE_OVERLOADED_BUILTIN\n+#define TARGET_RESOLVE_OVERLOADED_BUILTIN bpf_resolve_overloaded_builtin\n+\n+\n+/* Handling for __attribute__((preserve_access_index)) for BPF CO-RE support.\n+\n+   This attribute marks a structure/union/array type as \"preseve\", so that\n+   every access to that type should be recorded and replayed by the BPF loader;\n+   this is just the same functionality as __builtin_preserve_access_index,\n+   but in the form of an attribute for an entire aggregate type.\n+\n+   Note also that nested structs behave as though they all have the attribute.\n+   For example:\n+     struct X { int a; };\n+     struct Y { struct X bar} __attribute__((preserve_access_index));\n+     struct Y foo;\n+     foo.bar.a;\n+   will record access all the way to 'a', even though struct X does not have\n+   the preserve_access_index attribute.\n+\n+   This is to follow LLVM behavior.\n+\n+   This pass finds all accesses to objects of types marked with the attribute,\n+   and wraps them in the same \"low-level\" builtins used by the builtin version.\n+   All logic afterwards is therefore identical to the builtin version of\n+   preserve_access_index.  */\n+\n+/* True iff tree T accesses any member of a struct/union/class which is marked\n+   with the PRESERVE_ACCESS_INDEX attribute.  */\n+\n+static bool\n+is_attr_preserve_access (tree t)\n+{\n+  if (t == NULL_TREE)\n+    return false;\n+\n+  poly_int64 bitsize, bitpos;\n+  tree var_off;\n+  machine_mode mode;\n+  int sign, reverse, vol;\n+\n+  tree base = get_inner_reference (t, &bitsize, &bitpos, &var_off, &mode,\n+\t\t\t\t   &sign, &reverse, &vol);\n+\n+  if (TREE_CODE (base) == MEM_REF)\n+    {\n+      return lookup_attribute (\"preserve_access_index\",\n+\t\t\t       TYPE_ATTRIBUTES (TREE_TYPE (base)));\n+    }\n+\n+  if (TREE_CODE (t) == COMPONENT_REF)\n+    {\n+      /* preserve_access_index propegates into nested structures,\n+\t so check whether this is a component of another component\n+\t which in turn is part of such a struct.  */\n+\n+      const tree op = TREE_OPERAND (t, 0);\n+\n+      if (TREE_CODE (op) == COMPONENT_REF)\n+\treturn is_attr_preserve_access (op);\n+\n+      const tree container = DECL_CONTEXT (TREE_OPERAND (t, 1));\n+\n+      return lookup_attribute (\"preserve_access_index\",\n+\t\t\t       TYPE_ATTRIBUTES (container));\n+    }\n+\n+  else if (TREE_CODE (t) == ADDR_EXPR)\n+    return is_attr_preserve_access (TREE_OPERAND (t, 0));\n+\n+  return false;\n+}\n+\n+/* The body of pass_bpf_core_attr. Scan RTL for accesses to structs/unions\n+   marked with __attribute__((preserve_access_index)) and generate a CO-RE\n+   relocation for any such access.  */\n+\n+static void\n+handle_attr_preserve (function *fn)\n+{\n+  basic_block bb;\n+  rtx_insn *insn;\n+  rtx_code_label *label;\n+  FOR_EACH_BB_FN (bb, fn)\n+    {\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  if (!NONJUMP_INSN_P (insn))\n+\t    continue;\n+\t  rtx pat = PATTERN (insn);\n+\t  if (GET_CODE (pat) != SET)\n+\t    continue;\n+\n+\t  start_sequence();\n+\n+\t  for (int i = 0; i < 2; i++)\n+\t    {\n+\t      rtx mem = XEXP (pat, i);\n+\t      if (MEM_P (mem))\n+\t\t{\n+\t\t  tree expr = MEM_EXPR (mem);\n+\t\t  if (!expr)\n+\t\t    continue;\n+\n+\t\t  if (TREE_CODE (expr) == MEM_REF\n+\t\t      && TREE_CODE (TREE_OPERAND (expr, 0)) == SSA_NAME)\n+\t\t    {\n+\t\t      gimple *def_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (expr, 0));\n+\t\t      if (is_gimple_assign (def_stmt))\n+\t\t\texpr = gimple_assign_rhs1 (def_stmt);\n+\t\t    }\n+\n+\t\t  if (is_attr_preserve_access (expr))\n+\t\t    {\n+\t\t      auto_vec<unsigned int, 16> accessors;\n+\t\t      tree container = bpf_core_compute (expr, &accessors);\n+\t\t      if (accessors.length () < 1)\n+\t\t\tcontinue;\n+\t\t      accessors.reverse ();\n+\n+\t\t      container = TREE_TYPE (container);\n+\t\t      const char * section_name;\n+\t\t      if (DECL_SECTION_NAME (fn->decl))\n+\t\t\tsection_name = DECL_SECTION_NAME (fn->decl);\n+\t\t      else\n+\t\t\tsection_name = \".text\";\n+\n+\t\t      label = gen_label_rtx ();\n+\t\t      LABEL_PRESERVE_P (label) = 1;\n+\t\t      emit_label (label);\n+\n+\t\t      /* Add the CO-RE relocation information to the BTF container.  */\n+\t\t      bpf_core_reloc_add (container, section_name, &accessors, label);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  rtx_insn *seq = get_insns ();\n+\t  end_sequence ();\n+\t  emit_insn_before (seq, insn);\n+\t}\n+    }\n+}\n+\n+\n+/* This pass finds accesses to structures marked with the BPF target attribute\n+   __attribute__((preserve_access_index)). For every such access, a CO-RE\n+   relocation record is generated, to be output in the .BTF.ext section.  */\n+\n+namespace {\n+\n+const pass_data pass_data_bpf_core_attr =\n+{\n+  RTL_PASS, /* type */\n+  \"bpf_core_attr\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_bpf_core_attr : public rtl_opt_pass\n+{\n+public:\n+  pass_bpf_core_attr (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_bpf_core_attr, ctxt)\n+  {}\n+\n+  virtual bool gate (function *) { return TARGET_BPF_CORE; }\n+  virtual unsigned int execute (function *);\n+};\n+\n+unsigned int\n+pass_bpf_core_attr::execute (function *fn)\n+{\n+  handle_attr_preserve (fn);\n+  return 0;\n+}\n+\n+} /* Anonymous namespace.  */\n+\n+rtl_opt_pass *\n+make_pass_bpf_core_attr (gcc::context *ctxt)\n+{\n+  return new pass_bpf_core_attr (ctxt);\n+}\n+\n /* Finally, build the GCC target.  */\n \n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "d5486b463cfa87545e6dc3747e0087cb384e94dd", "filename": "gcc/config/bpf/coreout.c", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bdabb37549f12ce727800a1c8aa182c0b1dd42a/gcc%2Fconfig%2Fbpf%2Fcoreout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bdabb37549f12ce727800a1c8aa182c0b1dd42a/gcc%2Fconfig%2Fbpf%2Fcoreout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fcoreout.c?ref=8bdabb37549f12ce727800a1c8aa182c0b1dd42a", "patch": "@@ -0,0 +1,356 @@\n+/* BPF Compile Once - Run Everywhere (CO-RE) support.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#define IN_TARGET_CODE 1\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"target.h\"\n+#include \"memmodel.h\"\n+#include \"tm_p.h\"\n+#include \"output.h\"\n+#include \"dwarf2asm.h\"\n+#include \"ctfc.h\"\n+#include \"btf.h\"\n+#include \"rtl.h\"\n+\n+#include \"coreout.h\"\n+\n+/* This file contains data structures and routines for construction and output\n+   of BPF Compile Once - Run Everywhere (BPF CO-RE) information.\n+\n+   eBPF programs written in C usually include Linux kernel headers, so that\n+   they may interact with kernel data structures in a useful way. This\n+   intrudces two major portability issues:\n+\n+   1. Kernel data structures regularly change, with fields added, moved or\n+      deleted between versions. An eBPF program cannot in general be expected\n+      to run on any systems which does not share an identical kernel version to\n+      the system on which it was compiled.\n+\n+   2. Included kernel headers (and used data structures) may be internal, not\n+      exposed in an userspace API, and therefore target-specific. An eBPF\n+      program compiled on an x86_64 machine will include x86_64 kernel headers.\n+      The resulting program may not run well (or at all) in machines of\n+      another architecture.\n+\n+   BPF CO-RE is designed to solve the first issue by leveraging the BPF loader\n+   to adjust references to kernel data structures made by the program as-needed\n+   according to versions of structures actually present on the host kernel.\n+\n+   To achieve this, additional information is placed in a \".BTF.ext\" section.\n+   This information tells the loader which references will require adjusting,\n+   and how to perform each necessary adjustment.\n+\n+   For any access to a data structure which may require load-time adjustment,\n+   the following information is recorded (making up a CO-RE relocation record):\n+   - The BTF type ID of the outermost structure which is accessed.\n+   - An access string encoding the accessed member via a series of member and\n+     array indexes. These indexes are used to look up detailed BTF information\n+     about the member.\n+   - The offset of the appropriate instruction to patch in the BPF program.\n+   - An integer specifying what kind of relocation to perform.\n+\n+   A CO-RE-capable BPF loader reads this information together with the BTF\n+   information of the program, compares it against BTF information of the host\n+   kernel, and determines the appropriate way to patch the specified\n+   instruction.\n+\n+   Once all CO-RE relocations are resolved, the program is loaded and verified\n+   as usual. The process can be summarized with the following diagram:\n+\n+              +------------+\n+              | C compiler |\n+              +-----+------+\n+                    | BPF + BTF + CO-RE relocations\n+                    v\n+              +------------+\n+         +--->| BPF loader |\n+         |    +-----+------+\n+         |          | BPF (adapted)\n+     BTF |          v\n+         |    +------------+\n+         +----+   Kernel   |\n+              +------------+\n+\n+   Note that a single ELF object may contain multiple eBPF programs. As a\n+   result, a single .BTF.ext section can contain CO-RE relocations for multiple\n+   programs in distinct sections.  */\n+\n+/* Internal representation of a BPF CO-RE relocation record.  */\n+\n+typedef struct GTY (()) bpf_core_reloc {\n+  unsigned int bpfcr_type;\t\t/* BTF type ID of container.  */\n+  unsigned int  bpfcr_astr_off;\t\t/* Offset of access string in .BTF\n+\t\t\t\t\t   string table.  */\n+  rtx_code_label * bpfcr_insn_label;\t/* RTX label attached to instruction\n+\t\t\t\t\t   to patch.  */\n+  enum btf_core_reloc_kind bpfcr_kind;\t/* Kind of relocation to perform.  */\n+} bpf_core_reloc_t;\n+\n+typedef bpf_core_reloc_t * bpf_core_reloc_ref;\n+\n+/* Internal representation of a CO-RE relocation (sub)section of the\n+   .BTF.ext information. One such section is generated for each ELF section\n+   in the output object having relocations that a BPF loader must resolve.  */\n+\n+typedef struct GTY (()) bpf_core_section {\n+  /* Name of ELF section to which these CO-RE relocations apply.  */\n+  const char * name;\n+\n+  /* Offset of section name in .BTF string table.  */\n+  uint32_t name_offset;\n+\n+  /* Relocations in the section.  */\n+  vec <bpf_core_reloc_ref, va_gc> * GTY (()) relocs;\n+} bpf_core_section_t;\n+\n+typedef bpf_core_section_t * bpf_core_section_ref;\n+\n+/* BTF.ext debug info section.  */\n+\n+static GTY (()) section * btf_ext_info_section;\n+\n+static int btf_ext_label_num;\n+\n+#ifndef BTF_EXT_INFO_SECTION_NAME\n+#define BTF_EXT_INFO_SECTION_NAME \".BTF.ext\"\n+#endif\n+\n+#define BTF_EXT_INFO_SECTION_FLAGS (SECTION_DEBUG)\n+\n+#define MAX_BTF_EXT_LABEL_BYTES 40\n+\n+static char btf_ext_info_section_label[MAX_BTF_EXT_LABEL_BYTES];\n+\n+#ifndef BTF_EXT_INFO_SECTION_LABEL\n+#define BTF_EXT_INFO_SECTION_LABEL \"Lbtfext\"\n+#endif\n+\n+static GTY (()) vec<bpf_core_section_ref, va_gc> *bpf_core_sections;\n+\n+\n+/* Create a new BPF CO-RE relocation record, and add it to the appropriate\n+   CO-RE section.  */\n+\n+void\n+bpf_core_reloc_add (const tree type, const char * section_name,\n+\t\t    vec<unsigned int> *accessors, rtx_code_label *label)\n+{\n+  char buf[40];\n+  unsigned int i, n = 0;\n+\n+  /* A valid CO-RE access must have at least one accessor.  */\n+  if (accessors->length () < 1)\n+    return;\n+\n+  for (i = 0; i < accessors->length () - 1; i++)\n+    n += snprintf (buf + n, sizeof (buf) - n, \"%u:\", (*accessors)[i]);\n+  snprintf (buf + n, sizeof (buf) - n, \"%u\", (*accessors)[i]);\n+\n+  bpf_core_reloc_ref bpfcr = ggc_cleared_alloc<bpf_core_reloc_t> ();\n+  ctf_container_ref ctfc = ctf_get_tu_ctfc ();\n+\n+  /* Buffer the access string in the auxiliary strtab. Since the two string\n+     tables are concatenated, add the length of the first to the offset.  */\n+  size_t strtab_len = ctfc_get_strtab_len (ctfc, CTF_STRTAB);\n+  ctf_add_string (ctfc, buf, &(bpfcr->bpfcr_astr_off), CTF_AUX_STRTAB);\n+  bpfcr->bpfcr_astr_off += strtab_len;\n+\n+  bpfcr->bpfcr_type = get_btf_id (ctf_lookup_tree_type (ctfc, type));\n+  bpfcr->bpfcr_insn_label = label;\n+  bpfcr->bpfcr_kind = BPF_RELO_FIELD_BYTE_OFFSET;\n+\n+  /* Add the CO-RE reloc to the appropriate section.  */\n+  bpf_core_section_ref sec;\n+  FOR_EACH_VEC_ELT (*bpf_core_sections, i, sec)\n+    if (strcmp (sec->name, section_name) == 0)\n+      {\n+\tvec_safe_push (sec->relocs, bpfcr);\n+\treturn;\n+      }\n+\n+  /* If the CO-RE section does not yet exist, create it.  */\n+  sec = ggc_cleared_alloc<bpf_core_section_t> ();\n+\n+  ctf_add_string (ctfc, section_name, &sec->name_offset, CTF_AUX_STRTAB);\n+  sec->name_offset += strtab_len;\n+  if (strcmp (section_name, \"\"))\n+    ctfc->ctfc_aux_strlen += strlen (section_name) + 1;\n+\n+  sec->name = section_name;\n+  vec_alloc (sec->relocs, 1);\n+  vec_safe_push (sec->relocs, bpfcr);\n+\n+  vec_safe_push (bpf_core_sections, sec);\n+}\n+\n+/* Return the 0-based index of the field NODE in its containing struct or union\n+   type.  */\n+\n+int\n+bpf_core_get_sou_member_index (ctf_container_ref ctfc, const tree node)\n+{\n+  if (TREE_CODE (node) == FIELD_DECL)\n+    {\n+      const tree container = DECL_CONTEXT (node);\n+      const char * name = IDENTIFIER_POINTER (DECL_NAME (node));\n+\n+      /* Lookup the CTF type info for the containing type.  */\n+      dw_die_ref die = lookup_type_die (container);\n+      if (die == NULL)\n+        return -1;\n+\n+      ctf_dtdef_ref dtd = ctf_dtd_lookup (ctfc, die);\n+      if (dtd == NULL)\n+        return -1;\n+\n+      unsigned int kind = CTF_V2_INFO_KIND (dtd->dtd_data.ctti_info);\n+      if (kind != CTF_K_STRUCT && kind != CTF_K_UNION)\n+        return -1;\n+\n+      int i = 0;\n+      ctf_dmdef_t * dmd;\n+      for (dmd = dtd->dtd_u.dtu_members;\n+           dmd != NULL; dmd = (ctf_dmdef_t *) ctf_dmd_list_next (dmd))\n+        {\n+          if (get_btf_id (dmd->dmd_type) > BTF_MAX_TYPE)\n+            continue;\n+          if (strcmp (dmd->dmd_name, name) == 0)\n+            return i;\n+          i++;\n+        }\n+    }\n+  return -1;\n+}\n+\n+/* Compute and output the header of a .BTF.ext debug info section.  */\n+\n+static void\n+output_btfext_header (void)\n+{\n+  switch_to_section (btf_ext_info_section);\n+  ASM_OUTPUT_LABEL (asm_out_file, btf_ext_info_section_label);\n+\n+  dw2_asm_output_data (2, BTF_MAGIC, \"btf_magic\");\n+  dw2_asm_output_data (1, BTF_VERSION, \"btfext_version\");\n+  dw2_asm_output_data (1, 0, \"btfext_flags\");\n+  dw2_asm_output_data (4, sizeof (struct btf_ext_header), \"btfext_hdr_len\");\n+\n+  uint32_t func_info_off = 0, func_info_len = 0;\n+  uint32_t line_info_off = 0, line_info_len = 0;\n+  uint32_t core_relo_off = 0, core_relo_len = 0;\n+\n+  /* Header core_relo_len is the sum total length in bytes of all CO-RE\n+     relocation sections.  */\n+  size_t i;\n+  bpf_core_section_ref sec;\n+  core_relo_len += vec_safe_length (bpf_core_sections)\n+    * sizeof (struct btf_ext_section_header);\n+\n+  FOR_EACH_VEC_ELT (*bpf_core_sections, i, sec)\n+    core_relo_len +=\n+      vec_safe_length (sec->relocs) * sizeof (struct btf_ext_reloc);\n+\n+  dw2_asm_output_data (4, func_info_off, \"func_info_offset\");\n+  dw2_asm_output_data (4, func_info_len, \"func_info_len\");\n+\n+  dw2_asm_output_data (4, line_info_off, \"line_info_offset\");\n+  dw2_asm_output_data (4, line_info_len, \"line_info_len\");\n+\n+  dw2_asm_output_data (4, core_relo_off, \"core_relo_offset\");\n+  dw2_asm_output_data (4, core_relo_len, \"core_relo_len\");\n+}\n+\n+/* Output a single CO-RE relocation record.  */\n+\n+static void\n+output_asm_btfext_core_reloc (bpf_core_reloc_ref bpfcr)\n+{\n+  dw2_assemble_integer (4, gen_rtx_LABEL_REF (Pmode, bpfcr->bpfcr_insn_label));\n+  fprintf (asm_out_file, \"\\t%s bpfcr_insn\\n\", ASM_COMMENT_START);\n+\n+  dw2_asm_output_data (4, bpfcr->bpfcr_type, \"bpfcr_type\");\n+  dw2_asm_output_data (4, bpfcr->bpfcr_astr_off, \"bpfcr_astr_off\");\n+  dw2_asm_output_data (4, bpfcr->bpfcr_kind, \"bpfcr_kind\");\n+}\n+\n+/* Output all CO-RE relocation records for a section.  */\n+\n+static void\n+output_btfext_core_relocs (bpf_core_section_ref sec)\n+{\n+  size_t i;\n+  bpf_core_reloc_ref bpfcr;\n+  FOR_EACH_VEC_ELT (*(sec->relocs), i, bpfcr)\n+    output_asm_btfext_core_reloc (bpfcr);\n+}\n+\n+/* Output all CO-RE relocation sections.  */\n+\n+static void\n+output_btfext_core_sections (void)\n+{\n+  size_t i;\n+  bpf_core_section_ref sec;\n+  FOR_EACH_VEC_ELT (*bpf_core_sections, i, sec)\n+    {\n+      /* BTF Ext section info. */\n+      dw2_asm_output_data (4, sizeof (struct btf_ext_reloc),\n+\t\t\t   \"btfext_secinfo_rec_size\");\n+\n+      /* Section name offset, refers to the offset of a string with the name of\n+\t the section to which these CORE relocations refer, e.g. '.text'.\n+\t The string is buffered in the BTF strings table.  */\n+      dw2_asm_output_data (4, sec->name_offset,  \"btfext_secinfo_sec_name_off\");\n+      dw2_asm_output_data (4, vec_safe_length (sec->relocs),\n+\t\t\t   \"btfext_secinfo_num_recs\");\n+\n+      output_btfext_core_relocs (sec);\n+    }\n+}\n+\n+/* Initialize sections, labels, and data structures for BTF.ext output.  */\n+\n+void\n+btf_ext_init (void)\n+{\n+  btf_ext_info_section = get_section (BTF_EXT_INFO_SECTION_NAME,\n+\t\t\t\t      BTF_EXT_INFO_SECTION_FLAGS, NULL);\n+\n+  ASM_GENERATE_INTERNAL_LABEL (btf_ext_info_section_label,\n+\t\t\t       BTF_EXT_INFO_SECTION_LABEL,\n+\t\t\t       btf_ext_label_num++);\n+\n+  vec_alloc (bpf_core_sections, 1);\n+}\n+\n+/* Output the entire .BTF.ext section.  */\n+\n+void\n+btf_ext_output (void)\n+{\n+  output_btfext_header ();\n+  output_btfext_core_sections ();\n+\n+  bpf_core_sections = NULL;\n+}\n+\n+#include \"gt-coreout.h\""}, {"sha": "82c203df341ad83464d43d4482b0cc14bd6c2e94", "filename": "gcc/config/bpf/coreout.h", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bdabb37549f12ce727800a1c8aa182c0b1dd42a/gcc%2Fconfig%2Fbpf%2Fcoreout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bdabb37549f12ce727800a1c8aa182c0b1dd42a/gcc%2Fconfig%2Fbpf%2Fcoreout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fcoreout.h?ref=8bdabb37549f12ce727800a1c8aa182c0b1dd42a", "patch": "@@ -0,0 +1,114 @@\n+/* coreout.h - Declarations and definitions related to\n+   BPF Compile Once - Run Everywhere (CO-RE) support.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+#ifndef __COREOUT_H\n+#define __COREOUT_H\n+\n+#include <stdint.h>\n+\n+#ifdef\t__cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+/* .BTF.ext information.  */\n+\n+struct btf_ext_section_header\n+{\n+  uint32_t kind;\n+  uint32_t sec_name_off;\n+  uint32_t num_records;\n+};\n+\n+/* A funcinfo record, in the .BTF.ext funcinfo section.  */\n+struct btf_ext_funcinfo\n+{\n+  uint32_t insn_off; /* Offset of the first instruction of the function.  */\n+  uint32_t type;     /* Type ID of a BTF_KIND_FUNC type.  */\n+};\n+\n+/* A lineinfo record, in the .BTF.ext lineinfo section.  */\n+struct btf_ext_lineinfo\n+{\n+  uint32_t insn_off;      /* Offset of the instruction.  */\n+  uint32_t file_name_off; /* Offset of file name in BTF string table.  */\n+  uint32_t line_off;      /* Offset of source line in BTF string table.  */\n+  uint32_t line_col;      /* Line number (bits 31-11) and column (11-0).  */\n+};\n+\n+enum btf_core_reloc_kind\n+{\n+  BPF_RELO_FIELD_BYTE_OFFSET = 0,\n+  BPF_RELO_FIELD_BYTE_SIZE = 1,\n+  BPF_RELO_FIELD_EXISTS = 2,\n+  BPF_RELO_FIELD_SIGNED = 3,\n+  BPF_RELO_FIELD_LSHIFT_U64 = 4,\n+  BPF_RELO_FIELD_RSHIFT_U64 = 5,\n+  BPF_RELO_TYPE_ID_LOCAL = 6,\n+  BPF_RELO_TYPE_ID_TARGET = 7,\n+  BPF_RELO_TYPE_EXISTS = 8,\n+  BPF_RELO_TYPE_SIZE = 9,\n+  BPF_RELO_ENUMVAL_EXISTS = 10,\n+  BPF_RELO_ENUMVAL_VALUE = 11\n+};\n+\n+struct btf_ext_reloc\n+{\n+  uint32_t insn_off;       /* Offset of instruction to be patched. A\n+\t\t\t      section-relative label at compile time.  */\n+  uint32_t type_id;        /* Type ID of the outermost containing entity, e.g.\n+\t\t\t      the containing structure.  */\n+  uint32_t access_str_off; /* Offset of CO-RE accessor string in .BTF strings\n+\t\t\t      section.  */\n+  uint32_t kind;           /* An enum btf_core_reloc_kind. Note that it always\n+\t\t\t      takes 32 bits.  */\n+};\n+\n+struct btf_ext_header\n+{\n+  uint16_t magic;\t\t/* Magic number (BTF_MAGIC).  */\n+  uint8_t  version;\t\t/* Data format version (BTF_VERSION).  */\n+  uint8_t  flags;\t\t/* Flags. Currently unused.  */\n+  uint32_t hdr_len;\t\t/* Length of this header in bytes.  */\n+\n+  /* Following offsets are relative to the end of this header, in bytes.\n+     Following lengths are in bytes.  */\n+  uint32_t func_info_off;\t/* Offset of funcinfo section.  */\n+  uint32_t func_info_len;\t/* Length of funcinfo section.  */\n+  uint32_t line_info_off;\t/* Offset of lineinfo section.  */\n+  uint32_t line_info_len;\t/* Length of lineinfo section.  */\n+\n+  uint32_t core_relo_off;\t/* Offset of CO-RE relocation section.  */\n+  uint32_t core_relo_len;\t/* Length of CO-RE relocation section.  */\n+};\n+\n+extern void btf_ext_init (void);\n+extern void btf_ext_output (void);\n+\n+extern void bpf_core_reloc_add (const tree, const char *, vec<unsigned int> *,\n+\t\t\t\trtx_code_label *);\n+extern int bpf_core_get_sou_member_index (ctf_container_ref, const tree);\n+\n+#ifdef\t__cplusplus\n+}\n+#endif\n+\n+#endif /* __COREOUT_H */"}, {"sha": "b37bf858d8fbda2b4c136a7216f30754dc4858a8", "filename": "gcc/config/bpf/t-bpf", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bdabb37549f12ce727800a1c8aa182c0b1dd42a/gcc%2Fconfig%2Fbpf%2Ft-bpf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bdabb37549f12ce727800a1c8aa182c0b1dd42a/gcc%2Fconfig%2Fbpf%2Ft-bpf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Ft-bpf?ref=8bdabb37549f12ce727800a1c8aa182c0b1dd42a", "patch": "@@ -0,0 +1,8 @@\n+\n+TM_H += $(srcdir)/config/bpf/coreout.h\n+\n+coreout.o: $(srcdir)/config/bpf/coreout.c\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)\n+\n+PASSES_EXTRA += $(srcdir)/config/bpf/bpf-passes.def"}]}