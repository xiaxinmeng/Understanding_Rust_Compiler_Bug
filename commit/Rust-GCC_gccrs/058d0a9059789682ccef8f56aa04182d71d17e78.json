{"sha": "058d0a9059789682ccef8f56aa04182d71d17e78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU4ZDBhOTA1OTc4OTY4MmNjZWY4ZjU2YWEwNDE4MmQ3MWQxN2U3OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-07-05T17:22:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-07-05T17:22:44Z"}, "message": "cgraph.c (cgraph_create_indirect_edge): Update call of get_polymorphic_call_info.\n\n\n\t* cgraph.c (cgraph_create_indirect_edge): Update call of\n\tget_polymorphic_call_info.\n\t* ipa-utils.h (get_polymorphic_call_info): Add parameter CALL.\n\t(possible_polymorphic_call_targets): Add parameter call.\n\t(decl_maybe_in_construction_p): New predicate.\n\t(get_polymorphic_call_info): Add parameter call;\n\tuse decl_maybe_in_construction_p.\n\t* gimple-fold.c (fold_gimple_assign): Update use of\n\tpossible_polymorphic_call_targets.\n\t(gimple_fold_call): Likewise.\n\t* ipa-prop.c: Inlcude calls.h\n\t(ipa_binfo_from_known_type_jfunc): Check that known type is record.\n\t(param_type_may_change_p): New predicate.\n\t(detect_type_change_from_memory_writes): Break out from ...\n\t(detect_type_change): ... this one; use \n\tparam_type_may_change_p.\n\t(detect_type_change_ssa): Use param_type_may_change_p.\n\t(compute_known_type_jump_func): Use decl_maybe_in_construction_p.\n\n\t* g++.dg/ipa/devirt-26.C: Update testcase.\n\t* g++.dg/ipa/imm-devirt-1.C: Update testcase.\n\t* g++.dg/ipa/imm-devirt-2.C: Update testcase.\n\nFrom-SVN: r212304", "tree": {"sha": "a316c1d813e71ce225a70f30c867801face3d5aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a316c1d813e71ce225a70f30c867801face3d5aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/058d0a9059789682ccef8f56aa04182d71d17e78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058d0a9059789682ccef8f56aa04182d71d17e78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/058d0a9059789682ccef8f56aa04182d71d17e78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058d0a9059789682ccef8f56aa04182d71d17e78/comments", "author": null, "committer": null, "parents": [{"sha": "aed773a2c8a20550b32cd223ecc44d87b6676974", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aed773a2c8a20550b32cd223ecc44d87b6676974", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aed773a2c8a20550b32cd223ecc44d87b6676974"}], "stats": {"total": 313, "additions": 266, "deletions": 47}, "files": [{"sha": "5cab9dd8ae35c07ac1876300d8adf6e86db28351", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=058d0a9059789682ccef8f56aa04182d71d17e78", "patch": "@@ -1,3 +1,24 @@\n+2014-07-05  Jan Hubicka   <hubicka@ucw.cz>\n+\n+\t* cgraph.c (cgraph_create_indirect_edge): Update call of\n+\tget_polymorphic_call_info.\n+\t* ipa-utils.h (get_polymorphic_call_info): Add parameter CALL.\n+\t(possible_polymorphic_call_targets): Add parameter call.\n+\t(decl_maybe_in_construction_p): New predicate.\n+\t(get_polymorphic_call_info): Add parameter call;\n+\tuse decl_maybe_in_construction_p.\n+\t* gimple-fold.c (fold_gimple_assign): Update use of\n+\tpossible_polymorphic_call_targets.\n+\t(gimple_fold_call): Likewise.\n+\t* ipa-prop.c: Inlcude calls.h\n+\t(ipa_binfo_from_known_type_jfunc): Check that known type is record.\n+\t(param_type_may_change_p): New predicate.\n+\t(detect_type_change_from_memory_writes): Break out from ...\n+\t(detect_type_change): ... this one; use \n+\tparam_type_may_change_p.\n+\t(detect_type_change_ssa): Use param_type_may_change_p.\n+\t(compute_known_type_jump_func): Use decl_maybe_in_construction_p.\n+\n 2014-07-05  Charles Baylis  <charles.baylis@linaro.org>\n \n \tPR target/49423"}, {"sha": "4cc8c9bc308f477cbdb40113639bdb1074b4e59c", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=058d0a9059789682ccef8f56aa04182d71d17e78", "patch": "@@ -967,7 +967,7 @@ cgraph_create_indirect_edge (struct cgraph_node *caller, gimple call_stmt,\n       get_polymorphic_call_info (caller->decl,\n \t\t\t\t target,\n \t\t\t\t &otr_type, &otr_token,\n-\t\t\t\t &context);\n+\t\t\t\t &context, call_stmt);\n \n       /* Only record types can have virtual calls.  */\n       gcc_assert (TREE_CODE (otr_type) == RECORD_TYPE);"}, {"sha": "1a9031932abc209e1f6b3f8dd01392dc37f2f396", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=058d0a9059789682ccef8f56aa04182d71d17e78", "patch": "@@ -376,7 +376,7 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \t      {\n \t\tbool final;\n \t\tvec <cgraph_node *>targets\n-\t\t  = possible_polymorphic_call_targets (val, &final);\n+\t\t  = possible_polymorphic_call_targets (val, stmt, &final);\n \t\tif (final && targets.length () <= 1 && dbg_cnt (devirt))\n \t\t  {\n \t\t    tree fndecl;\n@@ -1125,7 +1125,7 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \t{\n \t  bool final;\n \t  vec <cgraph_node *>targets\n-\t    = possible_polymorphic_call_targets (callee, &final);\n+\t    = possible_polymorphic_call_targets (callee, stmt, &final);\n \t  if (final && targets.length () <= 1 && dbg_cnt (devirt))\n \t    {\n \t      tree lhs = gimple_call_lhs (stmt);"}, {"sha": "da8dfcfee71271ae6ebb5a62263e0f22cf655098", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 103, "deletions": 1, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=058d0a9059789682ccef8f56aa04182d71d17e78", "patch": "@@ -1438,6 +1438,99 @@ vtable_pointer_value_to_binfo (const_tree t)\n \t\t\t\t\t offset, vtable);\n }\n \n+/* We know that the instance is stored in variable or parameter\n+   (not dynamically allocated) and we want to disprove the fact\n+   that it may be in construction at invocation of CALL.\n+\n+   For the variable to be in construction we actually need to\n+   be in constructor of corresponding global variable or\n+   the inline stack of CALL must contain the constructor.\n+   Check this condition.  This check works safely only before\n+   IPA passes, because inline stacks may become out of date\n+   later.  */\n+\n+bool\n+decl_maybe_in_construction_p (tree base, tree outer_type,\n+\t\t\t      gimple call, tree function)\n+{\n+  outer_type = TYPE_MAIN_VARIANT (outer_type);\n+  gcc_assert (DECL_P (base));\n+\n+  /* After inlining the code unification optimizations may invalidate\n+     inline stacks.  Also we need to give up on global variables after\n+     IPA, because addresses of these may have been propagated to their\n+     constructors.  */\n+  if (DECL_STRUCT_FUNCTION (function)->after_inlining)\n+    return true;\n+\n+  /* Pure functions can not do any changes on the dynamic type;\n+     that require writting to memory.  */\n+  if (!auto_var_in_fn_p (base, function)\n+      && flags_from_decl_or_type (function) & (ECF_PURE | ECF_CONST))\n+    return false;\n+\n+  for (tree block = gimple_block (call); block && TREE_CODE (block) == BLOCK;\n+       block = BLOCK_SUPERCONTEXT (block))\n+    if (BLOCK_ABSTRACT_ORIGIN (block)\n+\t&& TREE_CODE (BLOCK_ABSTRACT_ORIGIN (block)) == FUNCTION_DECL)\n+      {\n+\ttree fn = BLOCK_ABSTRACT_ORIGIN (block);\n+\n+\tif (TREE_CODE (TREE_TYPE (fn)) != METHOD_TYPE\n+\t    || (!DECL_CXX_CONSTRUCTOR_P (fn)\n+\t\t|| !DECL_CXX_DESTRUCTOR_P (fn)))\n+\t  {\n+\t    /* Watch for clones where we constant propagated the first\n+\t       argument (pointer to the instance).  */\n+\t    fn = DECL_ABSTRACT_ORIGIN (fn);\n+\t    if (!fn\n+\t\t|| !is_global_var (base)\n+\t        || TREE_CODE (TREE_TYPE (fn)) != METHOD_TYPE\n+\t\t|| (!DECL_CXX_CONSTRUCTOR_P (fn)\n+\t\t    || !DECL_CXX_DESTRUCTOR_P (fn)))\n+\t      continue;\n+\t  }\n+\tif (flags_from_decl_or_type (fn) & (ECF_PURE | ECF_CONST))\n+\t  continue;\n+\n+\t/* FIXME: this can go away once we have ODR types equivalency on\n+\t   LTO level.  */\n+\tif (in_lto_p && !polymorphic_type_binfo_p (TYPE_BINFO (outer_type)))\n+\t  return true;\n+\ttree type = TYPE_MAIN_VARIANT (method_class_type (TREE_TYPE (fn)));\n+\tif (types_same_for_odr (type, outer_type))\n+\t  return true;\n+      }\n+\n+  if (TREE_CODE (base) == VAR_DECL\n+      && is_global_var (base))\n+    {\n+      if (TREE_CODE (TREE_TYPE (function)) != METHOD_TYPE\n+\t  || (!DECL_CXX_CONSTRUCTOR_P (function)\n+\t      || !DECL_CXX_DESTRUCTOR_P (function)))\n+\t{\n+\t  if (!DECL_ABSTRACT_ORIGIN (function))\n+\t    return false;\n+\t  /* Watch for clones where we constant propagated the first\n+\t     argument (pointer to the instance).  */\n+\t  function = DECL_ABSTRACT_ORIGIN (function);\n+\t  if (!function\n+\t      || TREE_CODE (TREE_TYPE (function)) != METHOD_TYPE\n+\t      || (!DECL_CXX_CONSTRUCTOR_P (function)\n+\t\t  || !DECL_CXX_DESTRUCTOR_P (function)))\n+\t    return false;\n+\t}\n+      /* FIXME: this can go away once we have ODR types equivalency on\n+\t LTO level.  */\n+      if (in_lto_p && !polymorphic_type_binfo_p (TYPE_BINFO (outer_type)))\n+\treturn true;\n+      tree type = TYPE_MAIN_VARIANT (method_class_type (TREE_TYPE (function)));\n+      if (types_same_for_odr (type, outer_type))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n /* Proudce polymorphic call context for call method of instance\n    that is located within BASE (that is assumed to be a decl) at OFFSET. */\n \n@@ -1490,14 +1583,17 @@ get_polymorphic_call_info_from_invariant (ipa_polymorphic_call_context *context,\n \n /* Given REF call in FNDECL, determine class of the polymorphic\n    call (OTR_TYPE), its token (OTR_TOKEN) and CONTEXT.\n+   CALL is optional argument giving the actual statement (usually call) where\n+   the context is used.\n    Return pointer to object described by the context  */\n \n tree\n get_polymorphic_call_info (tree fndecl,\n \t\t\t   tree ref,\n \t\t\t   tree *otr_type,\n \t\t\t   HOST_WIDE_INT *otr_token,\n-\t\t\t   ipa_polymorphic_call_context *context)\n+\t\t\t   ipa_polymorphic_call_context *context,\n+\t\t\t   gimple call)\n {\n   tree base_pointer;\n   *otr_type = obj_type_ref_class (ref);\n@@ -1561,6 +1657,12 @@ get_polymorphic_call_info (tree fndecl,\n \t\t    }\n \t\t  get_polymorphic_call_info_for_decl (context, base,\n \t\t\t\t\t\t      context->offset + offset2);\n+\t\t  if (context->maybe_in_construction && call)\n+\t\t    context->maybe_in_construction\n+\t\t     = decl_maybe_in_construction_p (base,\n+\t\t\t\t\t\t     context->outer_type,\n+\t\t\t\t\t\t     call,\n+\t\t\t\t\t\t     current_function_decl);\n \t\t  return NULL;\n \t\t}\n \t      else"}, {"sha": "34e766d18f1b8a41d38fbbfa2f43d0ddf1cd5719", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 108, "deletions": 26, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=058d0a9059789682ccef8f56aa04182d71d17e78", "patch": "@@ -62,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"domwalk.h\"\n #include \"builtins.h\"\n+#include \"calls.h\"\n \n /* Intermediate information that we get from alias analysis about a particular\n    parameter in a particular basic_block.  When a parameter or the memory it\n@@ -552,7 +553,11 @@ ipa_set_ancestor_jf (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n tree\n ipa_binfo_from_known_type_jfunc (struct ipa_jump_func *jfunc)\n {\n+  if (!RECORD_OR_UNION_TYPE_P (jfunc->value.known_type.base_type))\n+    return NULL_TREE;\n+\n   tree base_binfo = TYPE_BINFO (jfunc->value.known_type.base_type);\n+\n   if (!base_binfo)\n     return NULL_TREE;\n   return get_binfo_at_offset (base_binfo,\n@@ -731,18 +736,84 @@ check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n     return false;\n }\n \n+/* See if ARG is PARAM_DECl describing instance passed by pointer\n+   or reference in FUNCTION.  Return false if the dynamic type may change\n+   in between beggining of the function until CALL is invoked.\n \n+   Generally functions are not allowed to change type of such instances,\n+   but they call destructors.  We assume that methods can not destroy the THIS\n+   pointer.  Also as a special cases, constructor and destructors may change\n+   type of the THIS pointer.  */\n+\n+static bool\n+param_type_may_change_p (tree function, tree arg, gimple call)\n+{\n+  /* Pure functions can not do any changes on the dynamic type;\n+     that require writting to memory.  */\n+  if (flags_from_decl_or_type (function) & (ECF_PURE | ECF_CONST))\n+    return false;\n+  /* We need to check if we are within inlined consturctor\n+     or destructor (ideally we would have way to check that the\n+     inline cdtor is actually working on ARG, but we don't have\n+     easy tie on this, so punt on all non-pure cdtors.\n+     We may also record the types of cdtors and once we know type\n+     of the instance match them.\n+\n+     Also code unification optimizations may merge calls from\n+     different blocks making return values unreliable.  So\n+     do nothing during late optimization.  */\n+  if (DECL_STRUCT_FUNCTION (function)->after_inlining)\n+    return true;\n+  if (TREE_CODE (arg) == SSA_NAME\n+      && SSA_NAME_IS_DEFAULT_DEF (arg)\n+      && TREE_CODE (SSA_NAME_VAR (arg)) == PARM_DECL)\n+    {\n+      /* Normal (non-THIS) argument.  */\n+      if ((SSA_NAME_VAR (arg) != DECL_ARGUMENTS (function)\n+\t   || TREE_CODE (TREE_TYPE (function)) != METHOD_TYPE)\n+\t  /* THIS pointer of an method - here we we want to watch constructors\n+\t     and destructors as those definitely may change the dynamic\n+\t     type.  */\n+\t  || (TREE_CODE (TREE_TYPE (function)) == METHOD_TYPE\n+\t      && !DECL_CXX_CONSTRUCTOR_P (function)\n+\t      && !DECL_CXX_DESTRUCTOR_P (function)\n+\t      && (SSA_NAME_VAR (arg) == DECL_ARGUMENTS (function))))\n+\t{\n+\t  /* Walk the inline stack and watch out for ctors/dtors.  */\n+\t  for (tree block = gimple_block (call); block && TREE_CODE (block) == BLOCK;\n+\t       block = BLOCK_SUPERCONTEXT (block))\n+\t    if (BLOCK_ABSTRACT_ORIGIN (block)\n+\t        && TREE_CODE (BLOCK_ABSTRACT_ORIGIN (block)) == FUNCTION_DECL)\n+\t      {\n+\t\ttree fn = BLOCK_ABSTRACT_ORIGIN (block);\n+\n+\t\tif (flags_from_decl_or_type (fn) & (ECF_PURE | ECF_CONST))\n+\t\t  continue;\n+\t\tif (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE\n+\t\t    && (DECL_CXX_CONSTRUCTOR_P (fn)\n+\t\t        || DECL_CXX_DESTRUCTOR_P (fn)))\n+\t\t  return true;\n+\t      }\n+\t  return false;\n+\t}\n+    }\n+  return true;\n+}\n \n /* Detect whether the dynamic type of ARG of COMP_TYPE has changed (before\n    callsite CALL) by looking for assignments to its virtual table pointer.  If\n    it is, return true and fill in the jump function JFUNC with relevant type\n    information or set it to unknown.  ARG is the object itself (not a pointer\n    to it, unless dereferenced).  BASE is the base of the memory access as\n-   returned by get_ref_base_and_extent, as is the offset.  */\n+   returned by get_ref_base_and_extent, as is the offset. \n+\n+   This is helper function for detect_type_change and detect_type_change_ssa\n+   that does the heavy work which is usually unnecesary.  */\n \n static bool\n-detect_type_change (tree arg, tree base, tree comp_type, gimple call,\n-\t\t    struct ipa_jump_func *jfunc, HOST_WIDE_INT offset)\n+detect_type_change_from_memory_writes (tree arg, tree base, tree comp_type,\n+\t\t\t\t       gimple call, struct ipa_jump_func *jfunc,\n+\t\t\t\t       HOST_WIDE_INT offset)\n {\n   struct type_change_info tci;\n   ao_ref ao;\n@@ -753,25 +824,6 @@ detect_type_change (tree arg, tree base, tree comp_type, gimple call,\n \n   comp_type = TYPE_MAIN_VARIANT (comp_type);\n \n-  if (!flag_devirtualize)\n-    return false;\n-\n-  /* C++ methods are not allowed to change THIS pointer unless they\n-     are constructors or destructors.  */\n-  if (TREE_CODE\t(base) == MEM_REF\n-      && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME\n-      && SSA_NAME_IS_DEFAULT_DEF (TREE_OPERAND (base, 0))\n-      && TREE_CODE (SSA_NAME_VAR (TREE_OPERAND (base, 0))) == PARM_DECL\n-      && TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE\n-      && !DECL_CXX_CONSTRUCTOR_P (current_function_decl)\n-      && !DECL_CXX_DESTRUCTOR_P (current_function_decl)\n-      && (SSA_NAME_VAR (TREE_OPERAND (base, 0))\n-\t  == DECL_ARGUMENTS (current_function_decl)))\n-    {\n-      gcc_assert (comp_type);\n-      return false;\n-    }\n-\n   /* Const calls cannot call virtual methods through VMT and so type changes do\n      not matter.  */\n   if (!flag_devirtualize || !gimple_vuse (call)\n@@ -809,6 +861,28 @@ detect_type_change (tree arg, tree base, tree comp_type, gimple call,\n   return true;\n }\n \n+/* Detect whether the dynamic type of ARG of COMP_TYPE may have changed.\n+   If it is, return true and fill in the jump function JFUNC with relevant type\n+   information or set it to unknown.  ARG is the object itself (not a pointer\n+   to it, unless dereferenced).  BASE is the base of the memory access as\n+   returned by get_ref_base_and_extent, as is the offset.  */\n+\n+static bool\n+detect_type_change (tree arg, tree base, tree comp_type, gimple call,\n+\t\t    struct ipa_jump_func *jfunc, HOST_WIDE_INT offset)\n+{\n+  if (!flag_devirtualize)\n+    return false;\n+\n+  if (TREE_CODE\t(base) == MEM_REF\n+      && !param_type_may_change_p (current_function_decl,\n+\t\t\t\t   TREE_OPERAND (base, 0),\n+\t\t\t\t   call))\n+    return false;\n+  return detect_type_change_from_memory_writes (arg, base, comp_type,\n+\t\t\t\t\t\tcall, jfunc, offset);\n+}\n+\n /* Like detect_type_change but ARG is supposed to be a non-dereferenced pointer\n    SSA name (its dereference will become the base and the offset is assumed to\n    be zero).  */\n@@ -822,10 +896,14 @@ detect_type_change_ssa (tree arg, tree comp_type,\n       || !POINTER_TYPE_P (TREE_TYPE (arg)))\n     return false;\n \n+  if (!param_type_may_change_p (current_function_decl, arg, call))\n+    return false;\n+\n   arg = build2 (MEM_REF, ptr_type_node, arg,\n \t\tbuild_int_cst (ptr_type_node, 0));\n \n-  return detect_type_change (arg, arg, comp_type, call, jfunc, 0);\n+  return detect_type_change_from_memory_writes (arg, arg, comp_type,\n+\t\t\t\t\t\tcall, jfunc, 0);\n }\n \n /* Callback of walk_aliased_vdefs.  Flags that it has been invoked to the\n@@ -1433,11 +1511,15 @@ compute_known_type_jump_func (tree op, struct ipa_jump_func *jfunc,\n   if (!DECL_P (base)\n       || max_size == -1\n       || max_size != size\n-      || !contains_polymorphic_type_p (TREE_TYPE (base))\n-      || is_global_var (base))\n+      || !contains_polymorphic_type_p (TREE_TYPE (base)))\n     return;\n \n-  if (detect_type_change (op, base, expected_type, call, jfunc, offset))\n+  if (decl_maybe_in_construction_p (base, TREE_TYPE (base),\n+\t\t\t\t    call, current_function_decl)\n+      /* Even if the var seems to be in construction by inline call stack,\n+\t we may work out the actual type by walking memory writes.  */\n+      && (!is_global_var (base)\n+\t  && detect_type_change (op, base, expected_type, call, jfunc, offset)))\n     return;\n \n   ipa_set_jf_known_type (jfunc, offset, TREE_TYPE (base),"}, {"sha": "470f4959f3c9b7d4d8b33aba71c5db5a5f9491d4", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=058d0a9059789682ccef8f56aa04182d71d17e78", "patch": "@@ -87,9 +87,11 @@ bool possible_polymorphic_call_target_p (tree, HOST_WIDE_INT,\n tree method_class_type (const_tree);\n tree get_polymorphic_call_info (tree, tree, tree *,\n \t\t\t\tHOST_WIDE_INT *,\n-\t\t\t\tipa_polymorphic_call_context *);\n+\t\t\t\tipa_polymorphic_call_context *,\n+\t\t\t\tgimple call = NULL);\n bool get_polymorphic_call_info_from_invariant (ipa_polymorphic_call_context *,\n \t\t\t\t\t       tree, tree, HOST_WIDE_INT);\n+bool decl_maybe_in_construction_p (tree, tree, gimple, tree);\n tree vtable_pointer_value_to_binfo (const_tree);\n bool vtable_pointer_value_to_vtable (const_tree, tree *, unsigned HOST_WIDE_INT *);\n bool contains_polymorphic_type_p (const_tree);\n@@ -125,7 +127,8 @@ possible_polymorphic_call_targets (struct cgraph_edge *e,\n /* Same as above but taking OBJ_TYPE_REF as an parameter.  */\n \n inline vec <cgraph_node *>\n-possible_polymorphic_call_targets (tree call,\n+possible_polymorphic_call_targets (tree ref,\n+\t\t\t\t   gimple call,\n \t\t\t\t   bool *final = NULL,\n \t\t\t\t   void **cache_token = NULL)\n {\n@@ -134,11 +137,11 @@ possible_polymorphic_call_targets (tree call,\n   ipa_polymorphic_call_context context;\n \n   get_polymorphic_call_info (current_function_decl,\n-\t\t\t     call,\n-\t\t\t     &otr_type, &otr_token, &context);\n-  return possible_polymorphic_call_targets (obj_type_ref_class (call),\n+\t\t\t     ref,\n+\t\t\t     &otr_type, &otr_token, &context, call);\n+  return possible_polymorphic_call_targets (obj_type_ref_class (ref),\n \t\t\t\t\t    tree_to_uhwi\n-\t\t\t\t\t      (OBJ_TYPE_REF_TOKEN (call)),\n+\t\t\t\t\t      (OBJ_TYPE_REF_TOKEN (ref)),\n \t\t\t\t\t    context,\n \t\t\t\t\t    final, cache_token);\n }"}, {"sha": "c24f30173ddb29137fe7058f63008a2e0b3afcb8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=058d0a9059789682ccef8f56aa04182d71d17e78", "patch": "@@ -1,3 +1,9 @@\n+2014-07-05  Jan Hubicka   <hubicka@ucw.cz>\n+\n+\t* g++.dg/ipa/devirt-26.C: Update testcase.\n+\t* g++.dg/ipa/imm-devirt-1.C: Update testcase.\n+\t* g++.dg/ipa/imm-devirt-2.C: Update testcase.\n+\n 2014-07-04  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/coarray/coindexed_3.f90: New."}, {"sha": "1787fee86731f2880f0521479d4e7b2428b487b8", "filename": "gcc/testsuite/g++.dg/ipa/devirt-26.C", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-26.C?ref=058d0a9059789682ccef8f56aa04182d71d17e78", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -fdump-ipa-devirt-details\"  } */\n+/* { dg-options \"-O3 -fdump-tree-ccp1\"  } */\n struct A\n  {\n    int a;\n@@ -23,7 +23,6 @@ int test(void)\n   return d->foo()+b->foo();\n }\n /* The call to b->foo() is perfectly devirtualizable because C can not be in construction\n-   when &c was used, but we can not analyze that so far.  Test that we at least speculate\n-   that type is in the construction.  */\n-/* { dg-final { scan-ipa-dump \"speculatively devirtualizing\" \"devirt\"  } } */\n-/* { dg-final { cleanup-ipa-dump \"devirt\" } } */\n+   when &c was used.  */\n+/* { dg-final { scan-tree-dump-not \"OBJ_TYPE_REF\" \"ccp1\"  } } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}, {"sha": "115277ff87093ba6dceb547d6947be2f84839280", "filename": "gcc/testsuite/g++.dg/ipa/imm-devirt-1.C", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fimm-devirt-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fimm-devirt-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fimm-devirt-1.C?ref=058d0a9059789682ccef8f56aa04182d71d17e78", "patch": "@@ -1,7 +1,7 @@\n /* Verify that virtual calls are folded even early inlining puts them into one\n    function with the definition.  */\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fdump-tree-fre1-details\"  } */\n+/* { dg-options \"-O2 -fdump-tree-einline\"  } */\n \n extern \"C\" void abort (void);\n \n@@ -58,5 +58,10 @@ int main (int argc, char *argv[])\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"converting indirect call to function virtual int B::foo\" \"fre1\"  } } */\n-/* { dg-final { cleanup-tree-dump \"fre1\" } } */\n+/* middleman_2 gets early inlined and the virtual call should get turned to\n+   a direct call.  */\n+/* { dg-final { scan-tree-dump \"Inlining int middleman_1\" \"einline\"  } } */\n+/* { dg-final { scan-tree-dump \"Inlining int middleman_2\" \"einline\"  } } */\n+/* { dg-final { scan-tree-dump \"B::foo (\" \"einline\"  } } */\n+/* { dg-final { scan-tree-dump-times \"OBJ_TYPE_REF\" 2 \"einline\"  } } */\n+/* { dg-final { cleanup-tree-dump \"einline\" } } */"}, {"sha": "58af0898077a474b29ea354d0a2c979b422ff4c8", "filename": "gcc/testsuite/g++.dg/ipa/imm-devirt-2.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fimm-devirt-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058d0a9059789682ccef8f56aa04182d71d17e78/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fimm-devirt-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fimm-devirt-2.C?ref=058d0a9059789682ccef8f56aa04182d71d17e78", "patch": "@@ -1,7 +1,7 @@\n /* Verify that virtual calls are folded even early inlining puts them into one\n    function with the definition.  */\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fdump-tree-fre1-details\"  } */\n+/* { dg-options \"-O2 -fdump-tree-einline\"  } */\n \n extern \"C\" void abort (void);\n \n@@ -91,5 +91,6 @@ int main (int argc, char *argv[])\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"converting indirect call to function\" \"fre1\"  } } */\n-/* { dg-final { cleanup-tree-dump \"fre1\" } } */\n+/* We fold into thunk of C. Eventually we should inline the thunk.  */\n+/* { dg-final { scan-tree-dump \"C::_ZThn24_N1C3fooEi (\" \"einline\"  } } */\n+/* { dg-final { cleanup-tree-dump \"einline\" } } */"}]}