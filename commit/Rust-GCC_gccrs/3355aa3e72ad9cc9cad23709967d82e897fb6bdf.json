{"sha": "3355aa3e72ad9cc9cad23709967d82e897fb6bdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM1NWFhM2U3MmFkOWNjOWNhZDIzNzA5OTY3ZDgyZTg5N2ZiNmJkZg==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2007-08-14T08:40:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:40:11Z"}, "message": "re PR ada/19037 (constant renaming creates new constant)\n\n2007-08-14  Olivier Hainque  <hainque@adacore.com>\n\t    Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* targtyps.c (get_target_maximum_default_alignment): New function.\n\tMaximum alignment\n\tthat the compiler might choose by default for a type or object.\n\t(get_target_default_allocator_alignment): New function. Alignment known\n\tto be honored by the target default allocator.\n\t(get_target_maximum_allowed_alignment): New function. Maximum alignment\n\twe might accept for any type or object on the target.\n\t(get_target_maximum_alignment): Now synonym of maximum_default_alignment\n\n\t* gigi.h (get_target_maximum_default_alignment): Declare new function.\n\t(get_target_default_allocator_alignment): Likewise.\n\t(get_target_maximum_allowed_alignment): Likewise.\n\n\tPR ada/19037\n\t* decl.c (gnat_to_gnu_entity) <object>: Except for the renaming of the\n\tresult of a function call, first try to use a stabilized reference for\n\ta constant renaming too.\n\t(validate_alignment): Use target_maximum_allowed_alignment instead of\n\tMAX_OFILE_ALIGNMENT as the upper bound to what we accept.\n\t(gnat_to_gnu_entity): Use common nodes directly.\n\t(gnat_to_gnu_entity) <object>: Pick the values of the type to annotate\n\talignment and size for the object.\n\t(lvalue_required_p): Handle N_Parameter_Association like N_Function_Call\n\tand N_Procedure_Call_Statement.\n\t(takes_address): Rename to lvalue_required_p, add third parameter\n\t'aliased' and adjust recursive calls.\n\t<N_Indexed_Component>: Update 'aliased' from the array type.\n\t<N_Selected_Component>: New case.\n\t<N_Object_Renaming_Declaration>: New Likewise.\n\t(Identifier_to_gnu): Adjust for above changes.\n\t(maybe_stabilize_reference) <CONST_DECL>: New case.\n\n\t* utils2.c (build_binary_op) <ARRAY_RANGE_REF>: Look through conversion\n\tbetween type variants.\n\t(build_simple_component_ref): Likewise.\n\t(build_call_alloc_dealloc): Use target_default_allocator_alignment\n\tinstead of BIGGEST_ALIGNMENT as the threshold to trigger the super\n\taligning type circuitry for allocations from the default storage pool.\n\t(build_allocator): Likewise.\n\t(build_simple_component_ref): Manually fold the reference for a\n\tconstructor if the record type contains a template.\n\n\t* utils.c (value_zerop): Delete.\n\t(gnat_init_decl_processing): Emit debug info for common types.\n\t(rest_of_record_type_compilation): If a union contains a field\n\twith a non-constant qualifier, treat it as variable-sized.\n\t(finish_record_type): Give the stub TYPE_DECL a name.\n\t(rest_of_record_type_compilation): Likewise.\n\t(convert) <CONSTRUCTOR>: New case.  Build a new constructor if\n\ttypes are equivalent array types.\n\t(create_field_decl): Claim fields of any ARRAY_TYPE are addressable,\n\teven if the type is not passed by reference.\n\t(static_ctors, static_dtors): Delete.\n\t(end_subprog_body): Do not record constructors and destructors.\n\t(build_global_cdtor): Delete.\n\t(gnat_write_global_declarations): Do not call build_global_cdtor.\n\n\t* lang-specs.h: If TARGET_VXWORKS_RTP is defined, append -mrtp when\n\t-fRTS=rtp is specified.\n\tIf CONFIG_DUAL_EXCEPTIONS is 1, append -fsjlj when -fRTS=sjlj is\n\tspecified.\n\n\t* misc.c (gnat_init_gcc_eh): Use __gnat_eh_personality_sj for the name\n\tof the personality function with SJLJ exceptions.\n\n        * raise-gcc.c (PERSONALITY_FUNCTION): Use __gnat_eh_personality_sj for\n\tthe name of the personality function with SJLJ exceptions.\n\nFrom-SVN: r127422", "tree": {"sha": "e79464f26ada57355226bd2875fdb9b7d91b2633", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e79464f26ada57355226bd2875fdb9b7d91b2633"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3355aa3e72ad9cc9cad23709967d82e897fb6bdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3355aa3e72ad9cc9cad23709967d82e897fb6bdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3355aa3e72ad9cc9cad23709967d82e897fb6bdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c690a2ec7301f5089252456d4fb764787c1a6fdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c690a2ec7301f5089252456d4fb764787c1a6fdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c690a2ec7301f5089252456d4fb764787c1a6fdb"}], "stats": {"total": 538, "additions": 302, "deletions": 236}, "files": [{"sha": "0621ead41f24ce343e7b2bf05b432b12f9520274", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 109, "deletions": 118, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=3355aa3e72ad9cc9cad23709967d82e897fb6bdf", "patch": "@@ -89,10 +89,6 @@ static VEC (tree,heap) *defer_finalize_list;\n static GTY ((if_marked (\"tree_int_map_marked_p\"),\n \t     param_is (struct tree_int_map))) htab_t annotate_value_cache;\n \n-/* A hash table used as to cache the result of annotate_value.  */\n-static GTY ((if_marked (\"tree_int_map_marked_p\"), param_is (struct tree_int_map)))\n-  htab_t annotate_value_cache;\n-\n static void copy_alias_set (tree, tree);\n static tree substitution_list (Entity_Id, Entity_Id, tree, bool);\n static bool allocatable_size_p (tree, bool);\n@@ -743,65 +739,47 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_type)))))))\n \t  gnu_expr = convert (gnu_type, gnu_expr);\n \n-\t/* See if this is a renaming and handle appropriately depending on\n-\t   what is renamed and in which context.  There are three cases:\n-\n-\t   1/ This is a constant renaming and we can just make an object\n-\t      with what is renamed as its initial value,\n-\n-\t   2/ We can reuse a stabilized version of what is renamed in place\n-\t      of the renaming,\n-\n-\t   3/ If neither 1 nor 2 applies, we make the renaming entity a\n-\t      constant pointer to what is being renamed.  */\n+\t/* If this is a renaming, avoid as much as possible to create a new\n+\t   object.  However, in several cases, creating it is required.  */\n \tif (Present (Renamed_Object (gnat_entity)))\n \t  {\n \t    bool create_normal_object = false;\n \n \t    /* If the renamed object had padding, strip off the reference\n \t       to the inner object and reset our type.  */\n-\t    if (TREE_CODE (gnu_expr) == COMPONENT_REF\n-\t\t&& (TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_expr, 0)))\n-\t\t    == RECORD_TYPE)\n-\t\t&& (TYPE_IS_PADDING_P\n-\t\t    (TREE_TYPE (TREE_OPERAND (gnu_expr, 0)))))\n+\t    if ((TREE_CODE (gnu_expr) == COMPONENT_REF\n+\t\t && TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_expr, 0)))\n+\t\t    == RECORD_TYPE\n+\t\t && TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_expr, 0))))\n+\t\t/* Strip useless conversions around the object.  */\n+\t\t|| TREE_CODE (gnu_expr) == NOP_EXPR)\n \t      {\n \t\tgnu_expr = TREE_OPERAND (gnu_expr, 0);\n \t\tgnu_type = TREE_TYPE (gnu_expr);\n \t      }\n \n-\t    /* Case 1: If this is a constant renaming, treat it as a normal\n-\t       object whose initial value is what is being renamed.  We cannot\n-\t       do this if the type is unconstrained or class-wide.  */\n-\t    if (const_flag\n-\t\t&& TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE\n-\t\t&& Ekind (Etype (gnat_entity)) != E_Class_Wide_Type)\n+\t    /* Case 1: If this is a constant renaming stemming from a function\n+\t       call, treat it as a normal object whose initial value is what\n+\t       is being renamed.  RM 3.3 says that the result of evaluating a\n+\t       function call is a constant object.  As a consequence, it can\n+\t       be the inner object of a constant renaming.  In this case, the\n+\t       renaming must be fully instantiated, i.e. it cannot be a mere\n+\t       reference to (part of) an existing object.  */\n+\t    if (const_flag)\n \t      {\n-\t\t/* However avoid creating large objects...  */\n-\t\tif (TYPE_MODE (gnu_type) != BLKmode)\n+\t        tree inner_object = gnu_expr;\n+\t\twhile (handled_component_p (inner_object))\n+\t\t  inner_object = TREE_OPERAND (inner_object, 0);\n+\t\tif (TREE_CODE (inner_object) == CALL_EXPR)\n \t\t  create_normal_object = true;\n-\t\telse\n-\t\t  {\n-\t\t    /* ...unless we really need to do it.  RM 3.3 says that\n-\t\t       the result of evaluating a function call is a constant\n-\t\t       object.  As a consequence, it can be the inner object\n-\t\t       of a constant renaming.  In this case, the renaming\n-\t\t       must be fully instantiated, i.e. it cannot be a mere\n-\t\t       reference to (part of) an existing object.  */\n-\t\t    tree inner_object = gnu_expr;\n-\t\t    while (handled_component_p (inner_object))\n-\t\t      inner_object = TREE_OPERAND (inner_object, 0);\n-\t\t    if (TREE_CODE (inner_object) == CALL_EXPR)\n-\t\t      create_normal_object = true;\n-\t\t  }\n \t      }\n \n \t    /* Otherwise, see if we can proceed with a stabilized version of\n-\t       the renamed entity or if we need to make a pointer.  */\n+\t       the renamed entity or if we need to make a new object.  */\n \t    if (!create_normal_object)\n \t      {\n-\t\tbool stable = false;\n \t\ttree maybe_stable_expr = NULL_TREE;\n+\t\tbool stable = false;\n \n \t\t/* Case 2: If the renaming entity need not be materialized and\n \t\t   the renamed expression is something we can stabilize, use\n@@ -835,7 +813,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t       about that failure.  */\n \t\t  }\n \n-\t\t/* Case 3: Make this into a constant pointer to the object we\n+\t\t/* Case 3: If this is a constant renaming and creating a\n+\t\t   new object is allowed and cheap, treat it as a normal\n+\t\t   object whose initial value is what is being renamed.  */\n+\t\tif (const_flag\n+\t\t    && Ekind (Etype (gnat_entity)) != E_Class_Wide_Type\n+\t\t    && TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE\n+\t\t    && TYPE_MODE (gnu_type) != BLKmode)\n+\t\t  ;\n+\n+\t\t/* Case 4: Make this into a constant pointer to the object we\n \t\t   are to rename and attach the object to the pointer if it is\n \t\t   something we can stabilize.\n \n@@ -849,53 +836,54 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   In the rare cases where we cannot stabilize the renamed\n \t\t   object, we just make a \"bare\" pointer, and the renamed\n \t\t   entity is always accessed indirectly through it.  */\n-\t\t{\n-\t\t  inner_const_flag = TREE_READONLY (gnu_expr);\n-\t\t  const_flag = true;\n-\t\t  gnu_type = build_reference_type (gnu_type);\n-\n-\t\t  /* If the previous attempt at stabilization failed, there is\n-\t\t     no point in trying again and we reuse the result without\n-\t\t     attaching it to the pointer.  In this case it will only\n-\t\t     be used as the initializing expression of the pointer\n-\t\t     and thus needs no special treatment with regard to\n-\t\t     multiple evaluations.  */\n-\t\t  if (maybe_stable_expr)\n-\t\t    ;\n-\n-\t\t  /* Otherwise, try to stabilize now and attach the expression\n-\t\t     to the pointer if the stabilization succeeds.\n-\n-\t\t     Note that this might introduce SAVE_EXPRs and we don't\n-\t\t     check whether we're at the global level or not.  This is\n-\t\t     fine since we are building a pointer initializer and\n-\t\t     neither the pointer nor the initializing expression can\n-\t\t     be accessed before the pointer elaboration has taken\n-\t\t     place in a correct program.\n-\n-\t\t     SAVE_EXPRs will be evaluated at the right spots by either\n-\t\t     the evaluation of the initializer for the non-global case\n-\t\t     or the elaboration code for the global case, and will be\n-\t\t     attached to the elaboration procedure in the latter case.\n-\t\t     We have no need to force an early evaluation here.  */\n-\t\t  else\n-\t\t    {\n-\t\t      maybe_stable_expr\n-\t\t\t= maybe_stabilize_reference (gnu_expr, true, &stable);\n+\t\telse\n+\t\t  {\n+\t\t    gnu_type = build_reference_type (gnu_type);\n+\t\t    inner_const_flag = TREE_READONLY (gnu_expr);\n+\t\t    const_flag = true;\n+\n+\t\t    /* If the previous attempt at stabilizing failed, there\n+\t\t       is no point in trying again and we reuse the result\n+\t\t       without attaching it to the pointer.  In this case it\n+\t\t       will only be used as the initializing expression of\n+\t\t       the pointer and thus needs no special treatment with\n+\t\t       regard to multiple evaluations.  */\n+\t\t    if (maybe_stable_expr)\n+\t\t      ;\n+\n+\t\t    /* Otherwise, try to stabilize and attach the expression\n+\t\t       to the pointer if the stabilization succeeds.\n+\n+\t\t       Note that this might introduce SAVE_EXPRs and we don't\n+\t\t       check whether we're at the global level or not.  This\n+\t\t       is fine since we are building a pointer initializer and\n+\t\t       neither the pointer nor the initializing expression can\n+\t\t       be accessed before the pointer elaboration has taken\n+\t\t       place in a correct program.\n+\n+\t\t       These SAVE_EXPRs will be evaluated at the right place\n+\t\t       by either the evaluation of the initializer for the\n+\t\t       non-global case or the elaboration code for the global\n+\t\t       case, and will be attached to the elaboration procedure\n+\t\t       in the latter case.  */\n+\t\t    else\n+\t \t     {\n+\t\t\tmaybe_stable_expr\n+\t\t\t  = maybe_stabilize_reference (gnu_expr, true, &stable);\n \n-\t\t      if (stable)\n-\t\t\trenamed_obj = maybe_stable_expr;\n+\t\t\tif (stable)\n+\t\t\t  renamed_obj = maybe_stable_expr;\n \n-\t\t      /* Attaching is actually performed downstream, as soon\n-\t\t\t as we have a VAR_DECL for the pointer we make.  */\n-\t\t    }\n+\t\t\t/* Attaching is actually performed downstream, as soon\n+\t\t\t   as we have a VAR_DECL for the pointer we make.  */\n+\t\t      }\n \n-\t\t  gnu_expr\n-\t\t    = build_unary_op (ADDR_EXPR, gnu_type, maybe_stable_expr);\n+\t\t    gnu_expr\n+\t\t      = build_unary_op (ADDR_EXPR, gnu_type, maybe_stable_expr);\n \n-\t\t  gnu_size = NULL_TREE;\n-\t\t  used_by_ref = true;\n-\t\t}\n+\t\t    gnu_size = NULL_TREE;\n+\t\t    used_by_ref = true;\n+\t\t  }\n \t      }\n \t  }\n \n@@ -1063,7 +1051,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tif (TREE_CODE (TYPE_SIZE_UNIT (gnu_alloc_type)) == INTEGER_CST\n \t\t    && TREE_OVERFLOW (TYPE_SIZE_UNIT (gnu_alloc_type))\n \t\t    && !Is_Imported (gnat_entity))\n-\t\t  post_error (\"Storage_Error will be raised at run-time?\",\n+\t\t  post_error (\"?Storage_Error will be raised at run-time!\",\n \t\t\t      gnat_entity);\n \n \t\tgnu_expr = build_allocator (gnu_alloc_type, gnu_expr, gnu_type,\n@@ -1216,25 +1204,33 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    && Exception_Mechanism != Back_End_Exceptions)\n \t  TREE_ADDRESSABLE (gnu_decl) = 1;\n \n-\t/* Back-annotate the Alignment of the object if not already in the\n-\t   tree.  Likewise for Esize if the object is of a constant size.\n-\t   But if the \"object\" is actually a pointer to an object, the\n-\t   alignment and size are the same as the type, so don't back-annotate\n-\t   the values for the pointer.  */\n+\tgnu_type = TREE_TYPE (gnu_decl);\n+\n+\t/* Back-annotate Alignment and Esize of the object if not already\n+\t   known, except for when the object is actually a pointer to the\n+\t   real object, since alignment and size of a pointer don't have\n+\t   anything to do with those of the designated object.  Note that\n+\t   we pick the values of the type, not those of the object, to\n+\t   shield ourselves from low-level platform-dependent adjustments\n+\t   like alignment promotion.  This is both consistent with all the\n+\t   treatment above, where alignment and size are set on the type of\n+\t   the object and not on the object directly, and makes it possible\n+\t   to support confirming representation clauses in all cases.  */\n+\n \tif (!used_by_ref && Unknown_Alignment (gnat_entity))\n \t  Set_Alignment (gnat_entity,\n-\t\t\t UI_From_Int (DECL_ALIGN (gnu_decl) / BITS_PER_UNIT));\n+\t\t\t UI_From_Int (TYPE_ALIGN (gnu_type) / BITS_PER_UNIT));\n \n-\tif (!used_by_ref && Unknown_Esize (gnat_entity)\n-\t    && DECL_SIZE (gnu_decl))\n+\tif (!used_by_ref && Unknown_Esize (gnat_entity))\n \t  {\n-\t    tree gnu_back_size = DECL_SIZE (gnu_decl);\n+\t    tree gnu_back_size;\n \n-\t    if (TREE_CODE (TREE_TYPE (gnu_decl)) == RECORD_TYPE\n-\t\t&& TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (gnu_decl)))\n+\t    if (TREE_CODE (gnu_type) == RECORD_TYPE\n+\t\t&& TYPE_CONTAINS_TEMPLATE_P (gnu_type))\n \t      gnu_back_size\n-\t\t= TYPE_SIZE (TREE_TYPE (TREE_CHAIN\n-\t\t\t\t\t(TYPE_FIELDS (TREE_TYPE (gnu_decl)))));\n+\t\t= TYPE_SIZE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_type))));\n+            else\n+\t      gnu_back_size = TYPE_SIZE (gnu_type);\n \n \t    Set_Esize (gnat_entity, annotate_value (gnu_back_size));\n \t  }\n@@ -3157,23 +3153,22 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      && Present (Freeze_Node (gnat_desig_rep))))\n \t  {\n \t    gnu_desig_type = make_dummy_type (gnat_desig_equiv);\n-  \t    made_dummy = 1;\n-  \t  }\n+\t    made_dummy = true;\n+\t  }\n \n \t/* Otherwise handle the case of a pointer to itself.  */\n \telse if (gnat_desig_equiv == gnat_entity)\n \t  {\n \t    gnu_type\n-\t      = build_pointer_type_for_mode (make_node (VOID_TYPE),\n-\t\t\t\t\t     p_mode,\n+\t      = build_pointer_type_for_mode (void_type_node, p_mode,\n \t\t\t\t\t     No_Strict_Aliasing (gnat_entity));\n \t    TREE_TYPE (gnu_type) = TYPE_POINTER_TO (gnu_type) = gnu_type;\n \t  }\n \n \t/* If expansion is disabled, the equivalent type of a concurrent\n \t   type is absent, so build a dummy pointer type.  */\n \telse if (type_annotate_only && No (gnat_desig_equiv))\n-\t  gnu_type = build_pointer_type (void_type_node);\n+\t  gnu_type = ptr_void_type_node;\n \n \t/* Finally, handle the straightforward case where we can just\n \t   elaborate our designated type and point to it.  */\n@@ -3302,7 +3297,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_Access_Protected_Subprogram_Type:\n     case E_Anonymous_Access_Protected_Subprogram_Type:\n       if (type_annotate_only && No (gnat_equiv_type))\n-\tgnu_type = build_pointer_type (void_type_node);\n+\tgnu_type = ptr_void_type_node;\n       else\n \t{\n \t  /* The runtime representation is the equivalent type. */\n@@ -6723,9 +6718,7 @@ validate_alignment (Uint alignment, Entity_Id gnat_entity, unsigned int align)\n   Node_Id gnat_error_node = gnat_entity;\n   unsigned int new_align;\n \n-#ifndef MAX_OFILE_ALIGNMENT\n-#define MAX_OFILE_ALIGNMENT BIGGEST_ALIGNMENT\n-#endif\n+  unsigned int max_allowed_alignment = get_target_maximum_allowed_alignment ();\n \n   if (Present (Alignment_Clause (gnat_entity)))\n     gnat_error_node = Expression (Alignment_Clause (gnat_entity));\n@@ -6736,16 +6729,14 @@ validate_alignment (Uint alignment, Entity_Id gnat_entity, unsigned int align)\n   if (Error_Posted (gnat_entity) && !Has_Alignment_Clause (gnat_entity))\n     return align;\n \n-  /* Within GCC, an alignment is an integer, so we must make sure a\n-     value is specified that fits in that range.  Also, alignments of\n-     more than MAX_OFILE_ALIGNMENT can't be supported.  */\n+  /* Within GCC, an alignment is an integer, so we must make sure a value is\n+     specified that fits in that range.  Also, there is an upper bound to\n+     alignments we can support/allow.  */\n \n   if (! UI_Is_In_Int_Range (alignment)\n-      || ((new_align = UI_To_Int (alignment))\n-\t   > MAX_OFILE_ALIGNMENT / BITS_PER_UNIT))\n+      || ((new_align = UI_To_Int (alignment)) > max_allowed_alignment))\n     post_error_ne_num (\"largest supported alignment for& is ^\",\n-\t\t       gnat_error_node, gnat_entity,\n-\t\t       MAX_OFILE_ALIGNMENT / BITS_PER_UNIT);\n+\t\t       gnat_error_node, gnat_entity, max_allowed_alignment);\n   else if (!(Present (Alignment_Clause (gnat_entity))\n \t     && From_At_Mod (Alignment_Clause (gnat_entity)))\n \t   && new_align * BITS_PER_UNIT < align)"}, {"sha": "42e923391b5ec212a64a8fa2615dc857fcb0eec0", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=3355aa3e72ad9cc9cad23709967d82e897fb6bdf", "patch": "@@ -857,6 +857,9 @@ extern Pos get_target_double_size (void);\n extern Pos get_target_long_double_size (void);\n extern Pos get_target_pointer_size (void);\n extern Pos get_target_maximum_alignment (void);\n+extern Pos get_target_default_allocator_alignment (void);\n+extern Pos get_target_maximum_default_alignment (void);\n+extern Pos get_target_maximum_allowed_alignment (void);\n extern Nat get_float_words_be (void);\n extern Nat get_words_be (void);\n extern Nat get_bytes_be (void);"}, {"sha": "c12a897c56212b303ae7605f95e8c831765207f9", "filename": "gcc/ada/lang-specs.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flang-specs.h?ref=3355aa3e72ad9cc9cad23709967d82e897fb6bdf", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *           Copyright (C) 1992-2004 Free Software Foundation, Inc.         *\n+ *           Copyright (C) 1992-2007, Free Software Foundation, Inc.        *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -35,8 +35,14 @@\n  %{!S:%{!c:%e-c or -S required for Ada}}\\\n  gnat1 %{I*} %{k8:-gnatk8} %{w:-gnatws} %{!Q:-quiet} %{nostdinc*}\\\n     %{nostdlib*}\\\n-    -dumpbase %{.adb:%b.adb}%{.ads:%b.ads}%{!.adb:%{!.ads:%b.ada}}\\\n-    %{O*} %{W*} %{w} %{p} %{pg:-p} %{a} %{f*} %{d*} %{g*&m*} %1\\\n+    -dumpbase %{.adb:%b.adb}%{.ads:%b.ads}%{!.adb:%{!.ads:%b.ada}} \"\n+#if defined(TARGET_VXWORKS_RTP)\n+   \"%{fRTS=rtp:-mrtp} \"\n+#endif\n+#if CONFIG_DUAL_EXCEPTIONS\n+   \"%{fRTS=sjlj:-fsjlj} \"\n+#endif\n+   \"%{O*} %{W*} %{w} %{p} %{pg:-p} %{a} %{f*} %{d*} %{g*&m*} %1\\\n     %{!S:%{o*:%w%*-gnatO}} \\\n     %i %{S:%W{o*}%{!o*:-o %b.s}} \\\n     %{gnatc*|gnats*: -o %j} %{-param*} \\"}, {"sha": "a59b1d0efa81a38eb7e116e03df08429b8d9dbb0", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=3355aa3e72ad9cc9cad23709967d82e897fb6bdf", "patch": "@@ -511,7 +511,9 @@ gnat_init_gcc_eh (void)\n      right exception regions.  */\n   using_eh_for_cleanups ();\n \n-  eh_personality_libfunc = init_one_libfunc (\"__gnat_eh_personality\");\n+  eh_personality_libfunc = init_one_libfunc (USING_SJLJ_EXCEPTIONS\n+\t\t\t\t\t     ? \"__gnat_eh_personality_sj\"\n+\t\t\t\t\t     : \"__gnat_eh_personality\");\n   lang_eh_type_covers = gnat_eh_type_covers;\n   lang_eh_runtime_type = gnat_eh_runtime_type;\n   default_init_unwind_resume_libfunc ();"}, {"sha": "55371d57b7eb3952145fd99301ac34a245c2c832", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=3355aa3e72ad9cc9cad23709967d82e897fb6bdf", "patch": "@@ -540,7 +540,7 @@ get_region_description_for (_Unwind_Context *uw_context,\n                             region_descriptor *region)\n {\n   const unsigned char * p;\n-  _uleb128_t tmp;\n+  _Unwind_Word tmp;\n   unsigned char lpbase_encoding;\n \n   /* Get the base address of the lsda information. If the provided context\n@@ -705,7 +705,7 @@ get_call_site_action_for (_Unwind_Context *uw_context,\n     }\n   else\n     {\n-      _uleb128_t cs_lp, cs_action;\n+      _Unwind_Word cs_lp, cs_action;\n \n       /* Let the caller know there may be an action to take, but let it\n \t determine the kind.  */\n@@ -765,7 +765,7 @@ get_call_site_action_for (_Unwind_Context *uw_context,\n   while (p < region->action_table)\n     {\n       _Unwind_Ptr cs_start, cs_len, cs_lp;\n-      _uleb128_t cs_action;\n+      _Unwind_Word cs_action;\n \n       /* Note that all call-site encodings are \"absolute\" displacements.  */\n       p = read_encoded_value (0, region->call_site_encoding, p, &cs_start);\n@@ -913,7 +913,7 @@ get_action_description_for (_Unwind_Context *uw_context,\n     {\n       const unsigned char * p = action->table_entry;\n \n-      _sleb128_t ar_filter, ar_disp;\n+      _Unwind_Sword ar_filter, ar_disp;\n \n       action->kind = nothing;\n \n@@ -1004,6 +1004,12 @@ extern void __gnat_notify_unhandled_exception (void);\n /* Below is the eh personality routine per se. We currently assume that only\n    GNU-Ada exceptions are met.  */\n \n+#ifdef __USING_SJLJ_EXCEPTIONS__\n+#define PERSONALITY_FUNCTION    __gnat_eh_personality_sj\n+#else\n+#define PERSONALITY_FUNCTION    __gnat_eh_personality\n+#endif\n+\n /* Major tweak for ia64-vms : the CHF propagation phase calls this personality\n    routine with sigargs/mechargs arguments and has very specific expectations\n    on possible return values.\n@@ -1036,11 +1042,11 @@ typedef _Unwind_Action phases_arg_t;\n #endif\n \n _Unwind_Reason_Code\n-__gnat_eh_personality (version_arg_t version_arg,\n-                       phases_arg_t phases_arg,\n-                       _Unwind_Exception_Class uw_exception_class,\n-                       _Unwind_Exception *uw_exception,\n-                       _Unwind_Context *uw_context)\n+PERSONALITY_FUNCTION (version_arg_t version_arg,\n+                      phases_arg_t phases_arg,\n+                      _Unwind_Exception_Class uw_exception_class,\n+                      _Unwind_Exception *uw_exception,\n+                      _Unwind_Context *uw_context)\n {\n   /* Fetch the version and phases args with their nominal ABI types for later\n      use. This is a noop everywhere except on ia64-vms when called from the"}, {"sha": "79dafcaf2fe2901f181a9070bc14014c125b1498", "filename": "gcc/ada/targtyps.c", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Ftargtyps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Ftargtyps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftargtyps.c?ref=3355aa3e72ad9cc9cad23709967d82e897fb6bdf", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                                  Body                                    *\n  *                                                                          *\n- *          Copyright (C) 1992-2006, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -142,12 +142,63 @@ get_target_pointer_size (void)\n   return POINTER_SIZE;\n }\n \n+/* Alignment related values, mapped to attributes for functional and\n+   documentation purposes.  */\n+\n+/* Standard'Maximum_Default_Alignment.  Maximum alignment that the compiler\n+   might choose by default for a type or object.\n+\n+   Stricter alignment requests trigger gigi's aligning_type circuitry for\n+   stack objects or objects allocated by the default allocator.  */\n+\n Pos\n-get_target_maximum_alignment (void)\n+get_target_maximum_default_alignment (void)\n {\n   return BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n }\n \n+/* Standard'Default_Allocator_Alignment.  Alignment guaranteed to be honored\n+   by the default allocator (System.Memory.Alloc or malloc if we have no\n+   run-time library at hand).\n+\n+   Stricter alignment requests trigger gigi's aligning_type circuitry for\n+   objects allocated by the default allocator.  */\n+\n+#ifndef MALLOC_ALIGNMENT\n+#define MALLOC_ALIGNMENT BIGGEST_ALIGNMENT\n+#endif\n+\n+Pos\n+get_target_default_allocator_alignment (void)\n+{\n+  /* ??? Need a way to get info about __gnat_malloc from here (whether\n+     it is handy and what alignment it honors).  */\n+\n+  return MALLOC_ALIGNMENT / BITS_PER_UNIT;\n+}\n+\n+/* Standard'Maximum_Allowed_Alignment.  Maximum alignment that we may\n+   accept for any type or object.  */\n+\n+#ifndef MAX_OFILE_ALIGNMENT\n+#define MAX_OFILE_ALIGNMENT BIGGEST_ALIGNMENT\n+#endif\n+\n+Pos\n+get_target_maximum_allowed_alignment (void)\n+{\n+  return MAX_OFILE_ALIGNMENT / BITS_PER_UNIT;\n+}\n+\n+/* Standard'Maximum_Alignment.  The single attribute initially made\n+   available, now a synonym of Standard'Maximum_Default_Alignment.  */\n+\n+Pos\n+get_target_maximum_alignment (void)\n+{\n+  return get_target_maximum_default_alignment ();\n+}\n+\n #ifndef FLOAT_WORDS_BIG_ENDIAN\n #define FLOAT_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n #endif"}, {"sha": "d26395fc0f645086c0e12544211f91e0eb80c1be", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 48, "deletions": 83, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=3355aa3e72ad9cc9cad23709967d82e897fb6bdf", "patch": "@@ -156,19 +156,13 @@ static GTY(()) VEC(tree,gc) *builtin_decls;\n /* An array of global renaming pointers.  */\n static GTY(()) VEC(tree,gc) *global_renaming_pointers;\n \n-/* Arrays of functions called automatically at the beginning and\n-   end of execution, on targets without .ctors/.dtors sections.  */\n-static GTY(()) VEC(tree,gc) *static_ctors;\n-static GTY(()) VEC(tree,gc) *static_dtors;\n-\n /* A chain of unused BLOCK nodes. */\n static GTY((deletable)) tree free_block_chain;\n \n static void gnat_install_builtins (void);\n static tree merge_sizes (tree, tree, tree, bool, bool);\n static tree compute_related_constant (tree, tree);\n static tree split_plus (tree, tree *);\n-static bool value_zerop (tree);\n static void gnat_gimplify_function (tree);\n static tree float_type_for_precision (int, enum machine_mode);\n static tree convert_to_fat_pointer (tree, tree);\n@@ -505,17 +499,14 @@ gnat_init_decl_processing (void)\n   build_common_tree_nodes_2 (0);\n \n   /* Give names and make TYPE_DECLs for common types.  */\n-  gnat_pushdecl (build_decl (TYPE_DECL, get_identifier (SIZE_TYPE), sizetype),\n-\t\t Empty);\n-  gnat_pushdecl (build_decl (TYPE_DECL, get_identifier (\"integer\"),\n-\t\t\t     integer_type_node),\n-\t\t Empty);\n-  gnat_pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned char\"),\n-\t\t\t     char_type_node),\n-\t\t Empty);\n-  gnat_pushdecl (build_decl (TYPE_DECL, get_identifier (\"long integer\"),\n-\t\t\t     long_integer_type_node),\n-\t\t Empty);\n+  create_type_decl (get_identifier (SIZE_TYPE), sizetype,\n+\t\t    NULL, false, true, Empty);\n+  create_type_decl (get_identifier (\"integer\"), integer_type_node,\n+\t\t    NULL, false, true, Empty);\n+  create_type_decl (get_identifier (\"unsigned char\"), char_type_node,\n+\t\t    NULL, false, true, Empty);\n+  create_type_decl (get_identifier (\"long integer\"), long_integer_type_node,\n+\t\t    NULL, false, true, Empty);\n \n   ptr_void_type_node = build_pointer_type (void_type_node);\n \n@@ -778,7 +769,7 @@ finish_record_type (tree record_type, tree fieldlist, int rep_level,\n \n   TYPE_FIELDS (record_type) = fieldlist;\n   TYPE_STUB_DECL (record_type)\n-    = build_decl (TYPE_DECL, NULL_TREE, record_type);\n+    = build_decl (TYPE_DECL, TYPE_NAME (record_type), record_type);\n \n   /* We don't need both the typedef name and the record name output in\n      the debugging information, since they are the same.  */\n@@ -947,6 +938,7 @@ rest_of_record_type_compilation (tree record_type)\n {\n   tree fieldlist = TYPE_FIELDS (record_type);\n   tree field;\n+  enum tree_code code = TREE_CODE (record_type);\n   bool var_size = false;\n \n   for (field = fieldlist; field; field = TREE_CHAIN (field))\n@@ -957,7 +949,11 @@ rest_of_record_type_compilation (tree record_type)\n \t same size, in which case we'll use that size.  But the debug\n \t output routines (except Dwarf2) won't be able to output the fields,\n \t so we need to make the special record.  */\n-      if (TREE_CODE (DECL_SIZE (field)) != INTEGER_CST)\n+      if (TREE_CODE (DECL_SIZE (field)) != INTEGER_CST\n+\t  /* If a field has a non-constant qualifier, the record will have\n+\t     variable size too.  */\n+\t  || (code == QUAL_UNION_TYPE\n+\t      && TREE_CODE (DECL_QUALIFIER (field)) != INTEGER_CST))\n \t{\n \t  var_size = true;\n \t  break;\n@@ -991,7 +987,7 @@ rest_of_record_type_compilation (tree record_type)\n       TYPE_NAME (new_record_type) = new_id;\n       TYPE_ALIGN (new_record_type) = BIGGEST_ALIGNMENT;\n       TYPE_STUB_DECL (new_record_type)\n-\t= build_decl (TYPE_DECL, NULL_TREE, new_record_type);\n+\t= build_decl (TYPE_DECL, new_id, new_record_type);\n       DECL_ARTIFICIAL (TYPE_STUB_DECL (new_record_type)) = 1;\n       DECL_IGNORED_P (TYPE_STUB_DECL (new_record_type))\n \t= DECL_IGNORED_P (TYPE_STUB_DECL (record_type));\n@@ -1483,8 +1479,6 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n   if (TREE_CODE (var_decl) != CONST_DECL)\n     rest_of_decl_compilation (var_decl, global_bindings_p (), 0);\n   else\n-    /* expand CONST_DECLs to set their MODE, ALIGN, SIZE and SIZE_UNIT,\n-       which we need for later back-annotations.  */\n     expand_decl (var_decl);\n \n   return var_decl;\n@@ -1631,35 +1625,28 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n       DECL_HAS_REP_P (field_decl) = 1;\n     }\n \n-  /* If the field type is passed by reference, we will have pointers to the\n-     field, so it is addressable. */\n-  if (must_pass_by_ref (field_type) || default_pass_by_ref (field_type))\n+  /* In addition to what our caller says, claim the field is addressable if we\n+     know we might ever attempt to take its address, then mark the decl as\n+     nonaddressable accordingly.\n+\n+     The field may also be \"technically\" nonaddressable, meaning that even if\n+     we attempt to take the field's address we will actually get the address\n+     of a copy.  This is the case for true bitfields, but the DECL_BIT_FIELD\n+     value we have at this point is not accurate enough, so we don't account\n+     for this here and let finish_record_type decide.  */\n+\n+  /* We will take the address in any argument passing sequence if the field\n+     type is passed by reference, and we might need the address for any array\n+     type, even if normally passed by-copy, to construct a fat pointer if the\n+     field is used as an actual for an unconstrained formal.  */\n+  if (TREE_CODE (field_type) == ARRAY_TYPE\n+      || must_pass_by_ref (field_type) || default_pass_by_ref (field_type))\n     addressable = 1;\n \n-  /* Mark the decl as nonaddressable if it is indicated so semantically,\n-     meaning we won't ever attempt to take the address of the field.\n-\n-     It may also be \"technically\" nonaddressable, meaning that even if we\n-     attempt to take the field's address we will actually get the address of a\n-     copy. This is the case for true bitfields, but the DECL_BIT_FIELD value\n-     we have at this point is not accurate enough, so we don't account for\n-     this here and let finish_record_type decide.  */\n   DECL_NONADDRESSABLE_P (field_decl) = !addressable;\n \n   return field_decl;\n }\n-\n-/* Subroutine of previous function: return nonzero if EXP, ignoring any side\n-   effects, has the value of zero.  */\n-\n-static bool\n-value_zerop (tree exp)\n-{\n-  if (TREE_CODE (exp) == COMPOUND_EXPR)\n-    return value_zerop (TREE_OPERAND (exp, 1));\n-\n-  return integer_zerop (exp);\n-}\n \f\n /* Returns a PARM_DECL node. PARAM_NAME is the name of the parameter,\n    PARAM_TYPE is its type.  READONLY is true if the parameter is\n@@ -2142,14 +2129,6 @@ end_subprog_body (tree body)\n   if (type_annotate_only)\n     return;\n \n-  /* If we don't have .ctors/.dtors sections, and this is a static\n-     constructor or destructor, it must be recorded now.  */\n-  if (DECL_STATIC_CONSTRUCTOR (fndecl) && !targetm.have_ctors_dtors)\n-    VEC_safe_push (tree, gc, static_ctors, fndecl);\n-\n-  if (DECL_STATIC_DESTRUCTOR (fndecl) && !targetm.have_ctors_dtors)\n-    VEC_safe_push (tree, gc, static_dtors, fndecl);\n-\n   /* Perform the required pre-gimplfication transformations on the tree.  */\n   gnat_genericize (fndecl);\n \n@@ -3474,6 +3453,22 @@ convert (tree type, tree expr)\n \t}\n       break;\n \n+    case CONSTRUCTOR:\n+      /* If we are converting a CONSTRUCTOR to another constrained array type\n+\t with the same domain, just make a new one in the proper type.  */\n+      if (code == ecode && code == ARRAY_TYPE\n+\t  && TREE_TYPE (type) == TREE_TYPE (etype)\n+\t  && tree_int_cst_equal (TYPE_MIN_VALUE (TYPE_DOMAIN (type)),\n+\t\t\t\t TYPE_MIN_VALUE (TYPE_DOMAIN (etype)))\n+\t  && tree_int_cst_equal (TYPE_MAX_VALUE (TYPE_DOMAIN (type)),\n+\t\t\t\t TYPE_MAX_VALUE (TYPE_DOMAIN (etype))))\n+\t{\n+\t  expr = copy_node (expr);\n+\t  TREE_TYPE (expr) = type;\n+\t  return expr;\n+\t}\n+      break;\n+\n     case UNCONSTRAINED_ARRAY_REF:\n       /* Convert this to the type of the inner array by getting the address of\n \t the array from the template.  */\n@@ -4010,41 +4005,11 @@ tree_code_for_record_type (Entity_Id gnat_type)\n   return UNION_TYPE;\n }\n \n-/* Build a global constructor or destructor function.  METHOD_TYPE gives\n-   the type of the function and VEC points to the vector of constructor\n-   or destructor functions to be invoked.  FIXME: Migrate into cgraph.  */\n-\n-static void\n-build_global_cdtor (int method_type, tree *vec, int len)\n-{\n-  tree body = NULL_TREE;\n-  int i;\n-\n-  for (i = 0; i < len; i++)\n-    {\n-      tree fntype = TREE_TYPE (vec[i]);\n-      tree fnaddr = build1 (ADDR_EXPR, build_pointer_type (fntype), vec[i]);\n-      tree fncall = build_call_nary (TREE_TYPE (fntype), fnaddr, 0);\n-      append_to_statement_list (fncall, &body);\n-    }\n-\n-  if (body)\n-    cgraph_build_static_cdtor (method_type, body, DEFAULT_INIT_PRIORITY);\n-}\n-\n /* Perform final processing on global variables.  */\n \n void\n gnat_write_global_declarations (void)\n {\n-  /* Generate functions to call static constructors and destructors\n-     for targets that do not support .ctors/.dtors sections.  These\n-     functions have magic names which are detected by collect2.  */\n-  build_global_cdtor ('I', VEC_address (tree, static_ctors),\n-\t\t\t   VEC_length (tree, static_ctors));\n-  build_global_cdtor ('D', VEC_address (tree, static_dtors),\n-\t\t\t   VEC_length (tree, static_dtors));\n-\n   /* Proceed to optimize and emit assembly.\n      FIXME: shouldn't be the front end's responsibility to call this.  */\n   cgraph_optimize ();"}, {"sha": "dd5a29e843cc783a88b43719738497e3e8a1ade0", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 62, "deletions": 20, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3355aa3e72ad9cc9cad23709967d82e897fb6bdf/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=3355aa3e72ad9cc9cad23709967d82e897fb6bdf", "patch": "@@ -758,8 +758,17 @@ build_binary_op (enum tree_code op_code, tree result_type,\n       /* ... fall through ... */\n \n     case ARRAY_RANGE_REF:\n+      /* First look through conversion between type variants.  Note that\n+\t this changes neither the operation type nor the type domain.  */\n+      if (TREE_CODE (left_operand) == VIEW_CONVERT_EXPR\n+\t  && TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (left_operand, 0)))\n+\t     == TYPE_MAIN_VARIANT (left_type))\n+\t{\n+\t  left_operand = TREE_OPERAND (left_operand, 0);\n+\t  left_type = TREE_TYPE (left_operand);\n+\t}\n \n-      /* First convert the right operand to its base type.  This will\n+      /* Then convert the right operand to its base type.  This will\n \t prevent unneeded signedness conversions when sizetype is wider than\n \t integer.  */\n       right_operand = convert (right_base_type, right_operand);\n@@ -1632,7 +1641,7 @@ build_simple_component_ref (tree record_variable, tree component,\n                             tree field, bool no_fold_p)\n {\n   tree record_type = TYPE_MAIN_VARIANT (TREE_TYPE (record_variable));\n-  tree ref;\n+  tree ref, inner_variable;\n \n   gcc_assert ((TREE_CODE (record_type) == RECORD_TYPE\n \t       || TREE_CODE (record_type) == UNION_TYPE\n@@ -1704,9 +1713,16 @@ build_simple_component_ref (tree record_variable, tree component,\n       && TREE_OVERFLOW (DECL_FIELD_OFFSET (field)))\n     return NULL_TREE;\n \n-  /* It would be nice to call \"fold\" here, but that can lose a type\n-     we need to tag a PLACEHOLDER_EXPR with, so we can't do it.  */\n-  ref = build3 (COMPONENT_REF, TREE_TYPE (field), record_variable, field,\n+  /* Look through conversion between type variants.  Note that this\n+     is transparent as far as the field is concerned.  */\n+  if (TREE_CODE (record_variable) == VIEW_CONVERT_EXPR\n+      && TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (record_variable, 0)))\n+\t == record_type)\n+    inner_variable = TREE_OPERAND (record_variable, 0);\n+  else\n+    inner_variable = record_variable;\n+\n+  ref = build3 (COMPONENT_REF, TREE_TYPE (field), inner_variable, field,\n \t\tNULL_TREE);\n \n   if (TREE_READONLY (record_variable) || TREE_READONLY (field))\n@@ -1715,7 +1731,25 @@ build_simple_component_ref (tree record_variable, tree component,\n       || TYPE_VOLATILE (record_type))\n     TREE_THIS_VOLATILE (ref) = 1;\n \n-  return no_fold_p ? ref : fold (ref);\n+  if (no_fold_p)\n+    return ref;\n+\n+  /* The generic folder may punt in this case because the inner array type\n+     can be self-referential, but folding is in fact not problematic.  */\n+  else if (TREE_CODE (record_variable) == CONSTRUCTOR\n+\t   && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (record_variable)))\n+    {\n+      VEC(constructor_elt,gc) *elts = CONSTRUCTOR_ELTS (record_variable);\n+      unsigned HOST_WIDE_INT idx;\n+      tree index, value;\n+      FOR_EACH_CONSTRUCTOR_ELT (elts, idx, index, value)\n+\tif (index == field)\n+\t  return value;\n+      return ref;\n+    }\n+\n+  else\n+    return fold (ref);\n }\n \f\n /* Like build_simple_component_ref, except that we give an error if the\n@@ -1822,12 +1856,17 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n \n   else if (gnu_obj)\n     {\n-      /* If the required alignement was greater than what malloc guarantees,\n-\t what we have in gnu_obj here is an address dynamically adjusted to\n-\t match the requirement (see build_allocator).  What we need to pass\n-\t to free is the initial underlying allocator's return value, which\n-\t has been stored just in front of the block we have.  */\n-      if (align > BIGGEST_ALIGNMENT)\n+      /* If the required alignement was greater than what the default\n+\t allocator guarantees, what we have in gnu_obj here is an address\n+\t dynamically adjusted to match the requirement (see build_allocator).\n+\t What we need to pass to free is the initial underlying allocator's\n+\t return value, which has been stored just in front of the block we\n+\t have.  */\n+\n+      unsigned int default_allocator_alignment\n+\t= get_target_default_allocator_alignment () * BITS_PER_UNIT;\n+\n+      if (align > default_allocator_alignment)\n \t{\n \t  /* We set GNU_OBJ\n \t     as * (void **)((void *)GNU_OBJ - (void *)sizeof(void *))\n@@ -1900,6 +1939,8 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n {\n   tree size = TYPE_SIZE_UNIT (type);\n   tree result;\n+  unsigned int default_allocator_alignment\n+    = get_target_default_allocator_alignment () * BITS_PER_UNIT;\n \n   /* If the initializer, if present, is a NULL_EXPR, just return a new one.  */\n   if (init && TREE_CODE (init) == NULL_EXPR)\n@@ -1999,25 +2040,26 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n   if (TREE_CODE (size) == INTEGER_CST && TREE_OVERFLOW (size))\n     size = ssize_int (-1);\n \n-  /* If this is a type whose alignment is larger than what the underlying\n-     allocator supports and this is in the default storage pool, make an\n-     \"aligning\" record type with room to store a pointer before the field,\n-     allocate an object of that type, store the system's allocator return\n-     value just in front of the field and return the field's address.  */\n+  /* If this is in the default storage pool and the type alignment is larger\n+     than what the default allocator supports, make an \"aligning\" record type\n+     with room to store a pointer before the field, allocate an object of that\n+     type, store the system's allocator return value just in front of the\n+     field and return the field's address.  */\n \n-  if (TYPE_ALIGN (type) > BIGGEST_ALIGNMENT && No (gnat_proc))\n+  if (No (gnat_proc) && TYPE_ALIGN (type) > default_allocator_alignment)\n     {\n       /* Construct the aligning type with enough room for a pointer ahead\n \t of the field, then allocate.  */\n       tree record_type\n \t= make_aligning_type (type, TYPE_ALIGN (type), size,\n-\t\t\t      BIGGEST_ALIGNMENT, POINTER_SIZE / BITS_PER_UNIT);\n+\t\t\t      default_allocator_alignment,\n+\t\t\t      POINTER_SIZE / BITS_PER_UNIT);\n \n       tree record, record_addr;\n \n       record_addr\n \t= build_call_alloc_dealloc (NULL_TREE, TYPE_SIZE_UNIT (record_type),\n-\t\t\t\t    BIGGEST_ALIGNMENT, Empty, Empty,\n+\t\t\t\t    default_allocator_alignment, Empty, Empty,\n \t\t\t\t    gnat_node);\n \n       record_addr"}]}