{"sha": "ee59f29bd96fdf420a4c9888bf65ce20957989d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU1OWYyOWJkOTZmZGY0MjBhNGM5ODg4YmY2NWNlMjA5NTc5ODlkMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-11-21T12:40:47Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-11-21T12:40:47Z"}, "message": "regclass.c (may_move_in_cost): Rename from may_move_cost, all references updated.\n\n\t* regclass.c (may_move_in_cost): Rename from may_move_cost, all\n\treferences updated.\n\t(may_move_out_cost): New variable.\n\t(init_reg_sets_1): Initialize may_move_out_cost.\n\t(record_reg_classes): Use may_move_out_cost.\n\nFrom-SVN: r30601", "tree": {"sha": "03c42138bb4c64b71ebcc4b15c93df7f7e5b26e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03c42138bb4c64b71ebcc4b15c93df7f7e5b26e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee59f29bd96fdf420a4c9888bf65ce20957989d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee59f29bd96fdf420a4c9888bf65ce20957989d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee59f29bd96fdf420a4c9888bf65ce20957989d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee59f29bd96fdf420a4c9888bf65ce20957989d3/comments", "author": null, "committer": null, "parents": [{"sha": "246fd41f2d73a1ded9b7b1fd5d9c6ea7d5d82a11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/246fd41f2d73a1ded9b7b1fd5d9c6ea7d5d82a11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/246fd41f2d73a1ded9b7b1fd5d9c6ea7d5d82a11"}], "stats": {"total": 38, "additions": 27, "deletions": 11}, "files": [{"sha": "b6d3dedb415be4bc2ce5b69512c9efac1ffcea28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee59f29bd96fdf420a4c9888bf65ce20957989d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee59f29bd96fdf420a4c9888bf65ce20957989d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee59f29bd96fdf420a4c9888bf65ce20957989d3", "patch": "@@ -1,8 +1,14 @@\n Fro Nov 19 05:48:45 CET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n \n+\t* regclass.c (may_move_in_cost): Rename from may_move_cost, all\n+\treferences updated.\n+\t(may_move_out_cost): New variable.\n+\t(init_reg_sets_1): Initialize may_move_out_cost.\n+\t(record_reg_classes): Use may_move_out_cost.\n+\n \t* regclass.c (dump_regclass): New function.\n \t(regclass): New parameter DUMP, call DUMP_REGCLASS.\n-\t* toplev.c (rest_of_compilation): Opent lreg dump file before regclass,\n+\t* toplev.c (rest_of_compilation): Open lreg dump file before regclass,\n \tpass rtl_dump_file to regclass.\n \t* rtl.h (regclass): Update prototype.\n "}, {"sha": "d0d8e503be58d3d35c3699e7738fa90d30f82b02", "filename": "gcc/regclass.c", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee59f29bd96fdf420a4c9888bf65ce20957989d3/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee59f29bd96fdf420a4c9888bf65ce20957989d3/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=ee59f29bd96fdf420a4c9888bf65ce20957989d3", "patch": "@@ -175,7 +175,12 @@ static int move_cost[N_REG_CLASSES][N_REG_CLASSES];\n /* Similar, but here we don't have to move if the first index is a subset\n    of the second so in that case the cost is zero.  */\n \n-static int may_move_cost[N_REG_CLASSES][N_REG_CLASSES];\n+static int may_move_in_cost[N_REG_CLASSES][N_REG_CLASSES];\n+\n+/* Similar, but here we don't have to move if the first index is a superset\n+   of the second so in that case the cost is zero.  */\n+\n+static int may_move_out_cost[N_REG_CLASSES][N_REG_CLASSES];\n \n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \n@@ -413,9 +418,14 @@ init_reg_sets_1 ()\n \tmove_cost[i][j] = cost;\n \n \tif (reg_class_subset_p (i, j))\n-\t  cost = 0;\n+\t  may_move_in_cost[i][j] = 0;\n+\telse\n+\t  may_move_in_cost[i][j] = cost;\n \n-\tmay_move_cost[i][j] = cost;\n+\tif (reg_class_subset_p (j, i))\n+\t  may_move_out_cost[i][j] = 0;\n+\telse\n+\t  may_move_out_cost[i][j] = cost;\n       }\n }\n \n@@ -1277,8 +1287,8 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \t\t  for (class = 0; class < N_REG_CLASSES; class++)\n \t\t    pp->cost[class]\n \t\t      = (recog_data.operand_type[i] == OP_IN\n-\t\t\t ? may_move_cost[class][(int) classes[i]]\n-\t\t\t : may_move_cost[(int) classes[i]][class]);\n+\t\t\t ? may_move_in_cost[class][(int) classes[i]]\n+\t\t\t : may_move_out_cost[(int) classes[i]][class]);\n \t\t  \n \t\t  /* If the alternative actually allows memory, make things\n \t\t     a bit cheaper since we won't need an extra insn to\n@@ -1296,7 +1306,7 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \n \t\t  if (prefclass)\n \t\t    alt_cost\n-\t\t      += (may_move_cost[(unsigned char) prefclass[REGNO (op)]]\n+\t\t      += (may_move_in_cost[(unsigned char) prefclass[REGNO (op)]]\n \t\t\t  [(int) classes[i]]);\n \n \t\t  if (REGNO (ops[i]) != REGNO (ops[j])\n@@ -1498,8 +1508,8 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \t\t  for (class = 0; class < N_REG_CLASSES; class++)\n \t\t    pp->cost[class]\n \t\t      = (recog_data.operand_type[i] == OP_IN\n-\t\t\t ? may_move_cost[class][(int) classes[i]]\n-\t\t\t : may_move_cost[(int) classes[i]][class]);\n+\t\t\t ? may_move_in_cost[class][(int) classes[i]]\n+\t\t\t : may_move_out_cost[(int) classes[i]][class]);\n \n \t\t  /* If the alternative actually allows memory, make things\n \t\t     a bit cheaper since we won't need an extra insn to\n@@ -1517,7 +1527,7 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \n \t\t  if (prefclass)\n \t\t    alt_cost\n-\t\t      += (may_move_cost[(unsigned char) prefclass[REGNO (op)]]\n+\t\t      += (may_move_in_cost[(unsigned char) prefclass[REGNO (op)]]\n \t\t\t  [(int) classes[i]]);\n \t\t}\n \t    }\n@@ -1835,7 +1845,7 @@ record_address_regs (x, class, scale)\n \tpp->mem_cost += (MEMORY_MOVE_COST (Pmode, class, 1) * scale) / 2;\n \n \tfor (i = 0; i < N_REG_CLASSES; i++)\n-\t  pp->cost[i] += (may_move_cost[i][(int) class] * scale) / 2;\n+\t  pp->cost[i] += (may_move_in_cost[i][(int) class] * scale) / 2;\n       }\n       break;\n "}]}