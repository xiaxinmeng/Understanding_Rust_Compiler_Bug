{"sha": "0728902f90acc1f79eecea7b6715bc1022c7f7c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDcyODkwMmY5MGFjYzFmNzllZWNlYTdiNjcxNWJjMTAyMmM3ZjdjOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2001-07-18T17:11:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-18T17:11:11Z"}, "message": "flow.c (redirect_edge_and_branch): Bail out on complex edges.\n\n\t* flow.c (redirect_edge_and_branch): Bail out on complex edges.\n\t(try_optimize_cfg): Do not remove tail recursive labels before sibcall.\n\t* jump.c (mark_jump_label): Do not forward branches.\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\n\nFrom-SVN: r44118", "tree": {"sha": "dc545ee97f3d0bb608afc67d322814c81f69c353", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc545ee97f3d0bb608afc67d322814c81f69c353"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0728902f90acc1f79eecea7b6715bc1022c7f7c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0728902f90acc1f79eecea7b6715bc1022c7f7c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0728902f90acc1f79eecea7b6715bc1022c7f7c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0728902f90acc1f79eecea7b6715bc1022c7f7c8/comments", "author": null, "committer": null, "parents": [{"sha": "02d92e3b707a5433814ca22aab53da2d229dc3e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02d92e3b707a5433814ca22aab53da2d229dc3e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02d92e3b707a5433814ca22aab53da2d229dc3e1"}], "stats": {"total": 92, "additions": 33, "deletions": 59}, "files": [{"sha": "e045d18fe6800ec07f564cda5052fefcd96cf858", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0728902f90acc1f79eecea7b6715bc1022c7f7c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0728902f90acc1f79eecea7b6715bc1022c7f7c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0728902f90acc1f79eecea7b6715bc1022c7f7c8", "patch": "@@ -1,3 +1,10 @@\n+Wed Jul 18 18:46:30 CEST 2001  Richard Henderson <rth@cygnus.com>\n+\t\t\t       Jan Hubicka  <jh@suse.cz>\n+\n+\t* flow.c (redirect_edge_and_branch): Bail out on complex edges.\n+\t(try_optimize_cfg): Do not remove tail recursive labels before sibcall.\n+\t* jump.c (mark_jump_label): Do not forward branches.\n+\n Wed Jul 18 18:35:01 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* cse.c (delete_trivially_dead_insns): Delete the libcall block"}, {"sha": "06a10401f79119d532ccfe5a960fae101d9703af", "filename": "gcc/flow.c", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0728902f90acc1f79eecea7b6715bc1022c7f7c8/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0728902f90acc1f79eecea7b6715bc1022c7f7c8/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=0728902f90acc1f79eecea7b6715bc1022c7f7c8", "patch": "@@ -1777,6 +1777,9 @@ redirect_edge_and_branch (e, target)\n   basic_block src = e->src;\n   rtx insn = src->end;\n \n+  if (e->flags & EDGE_COMPLEX)\n+    return false;\n+\n   if (try_redirect_by_replacing_jump (e, target))\n     return true;\n   /* Do this fast path late, as we want above code to simplify for cases\n@@ -3683,30 +3686,15 @@ try_optimize_cfg (mode)\n \t      changed = 1;\n \t      b = c;\n \t    }\n-\t  /* The fallthru forwarder block can be deleted.  */\n-\t  if (b->pred->pred_next == NULL\n-\t      && forwarder_block_p (b)\n-\t      && n_basic_blocks > 1\n-\t      && (b->pred->flags & EDGE_FALLTHRU)\n-\t      && (b->succ->flags & EDGE_FALLTHRU))\n-\t    {\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file, \"Deleting fallthru block %i.\\n\",\n-\t\t\t b->index);\n-\t      c = BASIC_BLOCK (i ? i - 1 : i + 1);\n-\t      redirect_edge_succ (b->pred, b->succ->dest);\n-\t      flow_delete_block (b);\n-\t      changed = 1;\n-\t      b = c;\n-\t    }\n-\n \t  /* Remove code labels no longer used.  \n \t     Don't do the optimization before sibling calls are discovered,\n \t     as some branches may be hidden inside CALL_PLACEHOLDERs.  */\n-\t  if (!(mode & CLEANUP_PRE_SIBCALL)\n-\t      && b->pred->pred_next == NULL\n+\t  if (b->pred->pred_next == NULL\n \t      && (b->pred->flags & EDGE_FALLTHRU)\n+\t      && !(b->pred->flags & EDGE_COMPLEX)\n \t      && GET_CODE (b->head) == CODE_LABEL\n+\t      && (!(mode & CLEANUP_PRE_SIBCALL)\n+ \t\t  || !tail_recursion_label_p (b->head))\n \t      /* If previous block does end with condjump jumping to next BB,\n \t         we can't delete the label.  */\n \t      && (b->pred->src == ENTRY_BLOCK_PTR\n@@ -3719,12 +3707,31 @@ try_optimize_cfg (mode)\n \t\tfprintf (rtl_dump_file, \"Deleted label in block %i.\\n\",\n \t\t\t b->index);\n \t    }\n+\t  /* The fallthru forwarder block can be deleted.  */\n+\t  if (b->pred->pred_next == NULL\n+\t      && forwarder_block_p (b)\n+\t      && n_basic_blocks > 1\n+\t      && (b->pred->flags & EDGE_FALLTHRU)\n+\t      && (b->succ->flags & EDGE_FALLTHRU)\n+\t      && GET_CODE (b->head) != CODE_LABEL)\n+\t    {\n+\t      if (rtl_dump_file)\n+\t\tfprintf (rtl_dump_file, \"Deleting fallthru block %i.\\n\",\n+\t\t\t b->index);\n+\t      c = BASIC_BLOCK (i ? i - 1 : i + 1);\n+\t      redirect_edge_succ (b->pred, b->succ->dest);\n+\t      flow_delete_block (b);\n+\t      changed = 1;\n+\t      b = c;\n+\t    }\n+\n \n \t  /* A loop because chains of blocks might be combineable.  */\n \t  while ((s = b->succ) != NULL\n \t\t && s->succ_next == NULL\n \t\t && (s->flags & EDGE_EH) == 0\n \t\t && (c = s->dest) != EXIT_BLOCK_PTR\n+\t         && !(s->flags & EDGE_COMPLEX)\n \t\t && c->pred->pred_next == NULL\n \t\t /* If the jump insn has side effects,\n \t\t    we can't kill the edge.  */"}, {"sha": "afc37f9b8b4f5c7db03b3708ebc808038e98ac12", "filename": "gcc/jump.c", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0728902f90acc1f79eecea7b6715bc1022c7f7c8/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0728902f90acc1f79eecea7b6715bc1022c7f7c8/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=0728902f90acc1f79eecea7b6715bc1022c7f7c8", "patch": "@@ -1999,8 +1999,6 @@ mark_jump_label (x, insn, in_mem)\n     case LABEL_REF:\n       {\n \trtx label = XEXP (x, 0);\n-\trtx olabel = label;\n-\trtx next;\n \n \t/* Ignore remaining references to unreachable labels that\n \t   have been deleted.  */\n@@ -2015,23 +2013,6 @@ mark_jump_label (x, insn, in_mem)\n \tif (LABEL_REF_NONLOCAL_P (x))\n \t  break;\n \n-\t/* If there are other labels following this one,\n-\t   replace it with the last of the consecutive labels.  */\n-\tfor (next = NEXT_INSN (label); next; next = NEXT_INSN (next))\n-\t  {\n-\t    if (GET_CODE (next) == CODE_LABEL)\n-\t      label = next;\n-\t    else if (GET_CODE (next) != NOTE)\n-\t      break;\n-\t    else if ((NOTE_LINE_NUMBER (next) == NOTE_INSN_LOOP_BEG\n-\t\t      || NOTE_LINE_NUMBER (next) == NOTE_INSN_FUNCTION_END\n-\t\t      /* ??? Optional.  Disables some optimizations, but\n-\t\t\t makes gcov output more accurate with -O.  */\n-\t\t      || (flag_test_coverage\n-\t\t\t  && NOTE_LINE_NUMBER (next) > 0)))\n-\t      break;\n-\t  }\n-\n \tXEXP (x, 0) = label;\n \tif (! insn || ! INSN_DELETED_P (insn))\n \t  ++LABEL_NUSES (label);\n@@ -2042,27 +2023,6 @@ mark_jump_label (x, insn, in_mem)\n \t      JUMP_LABEL (insn) = label;\n \t    else\n \t      {\n-\t\t/* If we've changed the label, update notes accordingly.  */\n-\t\tif (label != olabel)\n-\t\t  {\n-\t\t    rtx note;\n-\n-\t\t    /* We may have a REG_LABEL note to indicate that this\n-\t\t       instruction uses the label.  */\n-\t\t    note = find_reg_note (insn, REG_LABEL, olabel);\n-\t\t    if (note)\n-\t\t      XEXP (note, 0) = label;\n-\n-\t\t    /* We may also have a REG_EQUAL note to indicate that\n-\t\t       a register is being set to the address of the\n-\t\t       label.  */\n-\t\t    note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n-\t\t    if (note \n-\t\t\t&& GET_CODE (XEXP (note, 0)) == LABEL_REF\n-\t\t\t&& XEXP (XEXP (note, 0), 0) == olabel)\n-\t\t      XEXP (XEXP (note, 0), 0) = label;\n-\t\t  }\n-\n \t\t/* Add a REG_LABEL note for LABEL unless there already\n \t\t   is one.  All uses of a label, except for labels\n \t\t   that are the targets of jumps, must have a"}]}