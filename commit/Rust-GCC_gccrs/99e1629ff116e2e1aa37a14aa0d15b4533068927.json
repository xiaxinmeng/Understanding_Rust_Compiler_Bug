{"sha": "99e1629ff116e2e1aa37a14aa0d15b4533068927", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTllMTYyOWZmMTE2ZTJlMWFhMzdhMTRhYTBkMTViNDUzMzA2ODkyNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-04T10:50:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-04T10:50:23Z"}, "message": "Turn MODES_TIEABLE_P into a target hook\n\n2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* target.def (modes_tieable_p): New hook.\n\t* doc/tm.texi (MODES_TIEABLE_P): Replace with...\n\t(TARGET_MODES_TIEABLE_P): ...this.\n\t* doc/tm.texi.in: Regenerate.\n\t* hooks.h (hook_bool_mode_mode_true): Declare.\n\t* hooks.c (hook_bool_mode_mode_true): New function.\n\t* combine.c (subst): Use targetm.modes_tieable_p instead of\n\tMODES_TIEABLE_P.\n\t* dse.c (find_shift_sequence): Likewise.\n\t* expmed.c (extract_low_bits): Likewise.\n\t* lower-subreg.c: Include target.h.\n\t(find_decomposable_subregs): Use targetm.modes_tieable_p instead of\n\tMODES_TIEABLE_P.\n\t* rtlanal.c (rtx_cost): Likewise.\n\t* config/aarch64/aarch64.h (MODES_TIEABLE_P): Delete.\n\t* config/aarch64/aarch64-protos.h (aarch64_modes_tieable_p): Delete.\n\t* config/aarch64/aarch64.c (aarch64_modes_tieable_p): Make static.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/alpha/alpha.h (MODES_TIEABLE_P): Delete.\n\t* config/alpha/alpha.c (alpha_modes_tieable_p): New function.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/arc/arc.h (MODES_TIEABLE_P): Delete.\n\t* config/arc/arc.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(arc_modes_tieable_p): New function.\n\t* config/arm/arm.h (MODES_TIEABLE_P): Delete.\n\t* config/arm/arm-protos.h (arm_modes_tieable_p): Delete.\n\t* config/arm/arm.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(arm_modes_tieable_p): Make static.\n\t* config/avr/avr.h (MODES_TIEABLE_P): Delete.\n\t* config/bfin/bfin.h (MODES_TIEABLE_P): Delete.\n\t* config/bfin/bfin.c (bfin_modes_tieable_p): New function.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/c6x/c6x.h (MODES_TIEABLE_P): Delete.\n\t* config/c6x/c6x.c (c6x_modes_tieable_p): New function.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/cr16/cr16.h (MODES_TIEABLE_P): Delete.\n\t* config/cr16/cr16.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(cr16_modes_tieable_p): New function.\n\t* config/cris/cris.h (MODES_TIEABLE_P): Delete.\n\t* config/epiphany/epiphany.h (MODES_TIEABLE_P): Delete.\n\t* config/fr30/fr30.h (MODES_TIEABLE_P): Delete.\n\t(TRULY_NOOP_TRUNCATION): Update comment.\n\t* config/frv/frv.h (MODES_TIEABLE_P): Delete.\n\t(TRULY_NOOP_TRUNCATION): Update comment.\n\t* config/frv/frv.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(frv_modes_tieable_p): New function.\n\t* config/ft32/ft32.h (MODES_TIEABLE_P): Delete.\n\t* config/h8300/h8300.h (MODES_TIEABLE_P): Delete.\n\t* config/h8300/h8300.c (h8300_modes_tieable_p): New function.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/i386/i386.h (MODES_TIEABLE_P): Delete.\n\t* config/i386/i386-protos.h (ix86_modes_tieable_p): Delete.\n\t* config/i386/i386.c (ix86_modes_tieable_p): Make static.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/ia64/ia64.h (MODES_TIEABLE_P): Delete.\n\t* config/ia64/ia64.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(ia64_modes_tieable_p): New function.\n\t* config/iq2000/iq2000.h (MODES_TIEABLE_P): Delete.\n\t* config/iq2000/iq2000.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(iq2000_modes_tieable_p): New function.\n\t* config/lm32/lm32.h (MODES_TIEABLE_P): Delete.\n\t* config/lm32/lm32.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(lm32_modes_tieable_p): New function.\n\t* config/m32c/m32c.h (MODES_TIEABLE_P): Delete.\n\t* config/m32c/m32c-protos.h (m32c_modes_tieable_p): Delete.\n\t* config/m32c/m32c.c (m32c_modes_tieable_p): Make static.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/m32r/m32r.h (MODES_TIEABLE_P): Delete.\n\t* config/m32r/m32r.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(m32r_modes_tieable_p): New function.\n\t* config/m68k/m68k.h (MODES_TIEABLE_P): Delete.\n\t* config/m68k/m68k.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(m68k_modes_tieable_p): New function.\n\t* config/mcore/mcore.h (MODES_TIEABLE_P): Delete.\n\t* config/mcore/mcore.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(mcore_modes_tieable_p): New function.\n\t* config/microblaze/microblaze.h (MODES_TIEABLE_P): Delete.\n\t* config/microblaze/microblaze.c (microblaze_modes_tieable_p): New\n\tfunction.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/mips/mips.h (MODES_TIEABLE_P): Delete.\n\t* config/mips/mips-protos.h (mips_modes_tieable_p): Delete.\n\t* config/mips/mips.c (mips_modes_tieable_p): Make static.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/mmix/mmix.h (MODES_TIEABLE_P): Delete.\n\t* config/mn10300/mn10300.h (MODES_TIEABLE_P): Delete.\n\t* config/mn10300/mn10300-protos.h (mn10300_modes_tieable): Delete.\n\t* config/mn10300/mn10300.c (mn10300_modes_tieable): Rename to...\n\t(mn10300_modes_tieable_p): ...this and make static.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/moxie/moxie.h (MODES_TIEABLE_P): Delete.\n\t* config/msp430/msp430.h (MODES_TIEABLE_P): Delete.\n\t* config/msp430/msp430-protos.h (msp430_modes_tieable_p): Delete.\n\t* config/msp430/msp430.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(msp430_modes_tieable_p): Make static.\n\t* config/nds32/nds32.h (MODES_TIEABLE_P): Delete.\n\t* config/nds32/nds32.c (nds32_modes_tieable_p): New function.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/nios2/nios2.h (MODES_TIEABLE_P): Delete.\n\t* config/nvptx/nvptx.h (MODES_TIEABLE_P): Delete.\n\t* config/nvptx/nvptx.c (nvptx_modes_tieable_p): New function.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/pa/pa.h (MODES_TIEABLE_P): Delete.\n\t* config/pa/pa-protos.h (pa_modes_tieable_p): Delete.\n\t* config/pa/pa.c (pa_modes_tieable_p): Make static.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/pdp11/pdp11.h (MODES_TIEABLE_P): Delete.\n\t* config/pdp11/pdp11.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(pdp11_modes_tieable_p): New function.\n\t* config/powerpcspe/powerpcspe.h (MODES_TIEABLE_P): Delete.\n\t* config/powerpcspe/powerpcspe.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(rs6000_modes_tieable_p): New function.\n\t(rs6000_debug_reg_global): Use it instead of MODES_TIEABLE_P.\n\t* config/powerpcspe/powerpcspe.md: Update comment.\n\t* config/riscv/riscv.h (MODES_TIEABLE_P): Delete.\n\t* config/riscv/riscv.c (riscv_modes_tieable_p): New function.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/rl78/rl78.h (MODES_TIEABLE_P): Delete.\n\t* config/rl78/rl78.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(rl78_modes_tieable_p): New function.\n\t* config/rs6000/rs6000.h (MODES_TIEABLE_P): Delete.\n\t* config/rs6000/rs6000.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(rs6000_modes_tieable_p): New function.\n\t(rs6000_debug_reg_global): Use it instead of MODES_TIEABLE_P.\n\t* config/rs6000/rs6000.md: Update comment.\n\t* config/rx/rx.h (MODES_TIEABLE_P): Delete.\n\t* config/rx/rx.c (rx_modes_tieable_p): New function.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/s390/s390.h (MODES_TIEABLE_P): Delete.\n\t* config/s390/s390.c (s390_modes_tieable_p): New function.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/sh/sh.h (MODES_TIEABLE_P): Delete.\n\t* config/sh/sh.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(sh_modes_tieable_p): New function.\n\t* config/sparc/sparc.h (MODES_TIEABLE_P): Delete.\n\t* config/sparc/sparc-protos.h (sparc_modes_tieable_p): Delete.\n\t* config/sparc/sparc.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(sparc_modes_tieable_p): Make static.\n\t* config/spu/spu.h (MODES_TIEABLE_P): Delete.\n\t* config/spu/spu.c (spu_modes_tieable_p): New function.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/stormy16/stormy16.h (MODES_TIEABLE_P): Delete.\n\t* config/stormy16/stormy16.c (xstormy16_modes_tieable_p): New function.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/tilegx/tilegx.h (MODES_TIEABLE_P): Delete.\n\t* config/tilepro/tilepro.h (MODES_TIEABLE_P): Delete.\n\t* config/v850/v850.h (MODES_TIEABLE_P): Delete.\n\t* config/v850/v850.c (v850_modes_tieable_p): New function.\n\t(TARGET_MODES_TIEABLE_P): Redefine.\n\t* config/vax/vax.h (MODES_TIEABLE_P): Delete.\n\t* config/visium/visium.h (MODES_TIEABLE_P): Delete.\n\t* config/visium/visium.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(visium_modes_tieable_p): New function.\n\t* config/xtensa/xtensa.h (MODES_TIEABLE_P): Delete.\n\t* config/xtensa/xtensa.c (TARGET_MODES_TIEABLE_P): Redefine.\n\t(xtensa_modes_tieable_p): New function.\n\t* system.h (MODES_TIEABLE_P): Poison.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251647", "tree": {"sha": "6b8be9efc3a2479ffd13803d05fab12ce754df4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b8be9efc3a2479ffd13803d05fab12ce754df4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99e1629ff116e2e1aa37a14aa0d15b4533068927", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99e1629ff116e2e1aa37a14aa0d15b4533068927", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99e1629ff116e2e1aa37a14aa0d15b4533068927", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99e1629ff116e2e1aa37a14aa0d15b4533068927/comments", "author": null, "committer": null, "parents": [{"sha": "f939c3e63c5076205c56fb36e9c7cdc064a189a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f939c3e63c5076205c56fb36e9c7cdc064a189a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f939c3e63c5076205c56fb36e9c7cdc064a189a8"}], "stats": {"total": 1246, "additions": 753, "deletions": 493}, "files": [{"sha": "baac77361e55d19aa88ec90bdfa7f07cdc77229e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -1,3 +1,165 @@\n+2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* target.def (modes_tieable_p): New hook.\n+\t* doc/tm.texi (MODES_TIEABLE_P): Replace with...\n+\t(TARGET_MODES_TIEABLE_P): ...this.\n+\t* doc/tm.texi.in: Regenerate.\n+\t* hooks.h (hook_bool_mode_mode_true): Declare.\n+\t* hooks.c (hook_bool_mode_mode_true): New function.\n+\t* combine.c (subst): Use targetm.modes_tieable_p instead of\n+\tMODES_TIEABLE_P.\n+\t* dse.c (find_shift_sequence): Likewise.\n+\t* expmed.c (extract_low_bits): Likewise.\n+\t* lower-subreg.c: Include target.h.\n+\t(find_decomposable_subregs): Use targetm.modes_tieable_p instead of\n+\tMODES_TIEABLE_P.\n+\t* rtlanal.c (rtx_cost): Likewise.\n+\t* config/aarch64/aarch64.h (MODES_TIEABLE_P): Delete.\n+\t* config/aarch64/aarch64-protos.h (aarch64_modes_tieable_p): Delete.\n+\t* config/aarch64/aarch64.c (aarch64_modes_tieable_p): Make static.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/alpha/alpha.h (MODES_TIEABLE_P): Delete.\n+\t* config/alpha/alpha.c (alpha_modes_tieable_p): New function.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/arc/arc.h (MODES_TIEABLE_P): Delete.\n+\t* config/arc/arc.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(arc_modes_tieable_p): New function.\n+\t* config/arm/arm.h (MODES_TIEABLE_P): Delete.\n+\t* config/arm/arm-protos.h (arm_modes_tieable_p): Delete.\n+\t* config/arm/arm.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(arm_modes_tieable_p): Make static.\n+\t* config/avr/avr.h (MODES_TIEABLE_P): Delete.\n+\t* config/bfin/bfin.h (MODES_TIEABLE_P): Delete.\n+\t* config/bfin/bfin.c (bfin_modes_tieable_p): New function.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/c6x/c6x.h (MODES_TIEABLE_P): Delete.\n+\t* config/c6x/c6x.c (c6x_modes_tieable_p): New function.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/cr16/cr16.h (MODES_TIEABLE_P): Delete.\n+\t* config/cr16/cr16.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(cr16_modes_tieable_p): New function.\n+\t* config/cris/cris.h (MODES_TIEABLE_P): Delete.\n+\t* config/epiphany/epiphany.h (MODES_TIEABLE_P): Delete.\n+\t* config/fr30/fr30.h (MODES_TIEABLE_P): Delete.\n+\t(TRULY_NOOP_TRUNCATION): Update comment.\n+\t* config/frv/frv.h (MODES_TIEABLE_P): Delete.\n+\t(TRULY_NOOP_TRUNCATION): Update comment.\n+\t* config/frv/frv.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(frv_modes_tieable_p): New function.\n+\t* config/ft32/ft32.h (MODES_TIEABLE_P): Delete.\n+\t* config/h8300/h8300.h (MODES_TIEABLE_P): Delete.\n+\t* config/h8300/h8300.c (h8300_modes_tieable_p): New function.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/i386/i386.h (MODES_TIEABLE_P): Delete.\n+\t* config/i386/i386-protos.h (ix86_modes_tieable_p): Delete.\n+\t* config/i386/i386.c (ix86_modes_tieable_p): Make static.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/ia64/ia64.h (MODES_TIEABLE_P): Delete.\n+\t* config/ia64/ia64.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(ia64_modes_tieable_p): New function.\n+\t* config/iq2000/iq2000.h (MODES_TIEABLE_P): Delete.\n+\t* config/iq2000/iq2000.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(iq2000_modes_tieable_p): New function.\n+\t* config/lm32/lm32.h (MODES_TIEABLE_P): Delete.\n+\t* config/lm32/lm32.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(lm32_modes_tieable_p): New function.\n+\t* config/m32c/m32c.h (MODES_TIEABLE_P): Delete.\n+\t* config/m32c/m32c-protos.h (m32c_modes_tieable_p): Delete.\n+\t* config/m32c/m32c.c (m32c_modes_tieable_p): Make static.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/m32r/m32r.h (MODES_TIEABLE_P): Delete.\n+\t* config/m32r/m32r.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(m32r_modes_tieable_p): New function.\n+\t* config/m68k/m68k.h (MODES_TIEABLE_P): Delete.\n+\t* config/m68k/m68k.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(m68k_modes_tieable_p): New function.\n+\t* config/mcore/mcore.h (MODES_TIEABLE_P): Delete.\n+\t* config/mcore/mcore.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(mcore_modes_tieable_p): New function.\n+\t* config/microblaze/microblaze.h (MODES_TIEABLE_P): Delete.\n+\t* config/microblaze/microblaze.c (microblaze_modes_tieable_p): New\n+\tfunction.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/mips/mips.h (MODES_TIEABLE_P): Delete.\n+\t* config/mips/mips-protos.h (mips_modes_tieable_p): Delete.\n+\t* config/mips/mips.c (mips_modes_tieable_p): Make static.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/mmix/mmix.h (MODES_TIEABLE_P): Delete.\n+\t* config/mn10300/mn10300.h (MODES_TIEABLE_P): Delete.\n+\t* config/mn10300/mn10300-protos.h (mn10300_modes_tieable): Delete.\n+\t* config/mn10300/mn10300.c (mn10300_modes_tieable): Rename to...\n+\t(mn10300_modes_tieable_p): ...this and make static.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/moxie/moxie.h (MODES_TIEABLE_P): Delete.\n+\t* config/msp430/msp430.h (MODES_TIEABLE_P): Delete.\n+\t* config/msp430/msp430-protos.h (msp430_modes_tieable_p): Delete.\n+\t* config/msp430/msp430.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(msp430_modes_tieable_p): Make static.\n+\t* config/nds32/nds32.h (MODES_TIEABLE_P): Delete.\n+\t* config/nds32/nds32.c (nds32_modes_tieable_p): New function.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/nios2/nios2.h (MODES_TIEABLE_P): Delete.\n+\t* config/nvptx/nvptx.h (MODES_TIEABLE_P): Delete.\n+\t* config/nvptx/nvptx.c (nvptx_modes_tieable_p): New function.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/pa/pa.h (MODES_TIEABLE_P): Delete.\n+\t* config/pa/pa-protos.h (pa_modes_tieable_p): Delete.\n+\t* config/pa/pa.c (pa_modes_tieable_p): Make static.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/pdp11/pdp11.h (MODES_TIEABLE_P): Delete.\n+\t* config/pdp11/pdp11.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(pdp11_modes_tieable_p): New function.\n+\t* config/powerpcspe/powerpcspe.h (MODES_TIEABLE_P): Delete.\n+\t* config/powerpcspe/powerpcspe.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(rs6000_modes_tieable_p): New function.\n+\t(rs6000_debug_reg_global): Use it instead of MODES_TIEABLE_P.\n+\t* config/powerpcspe/powerpcspe.md: Update comment.\n+\t* config/riscv/riscv.h (MODES_TIEABLE_P): Delete.\n+\t* config/riscv/riscv.c (riscv_modes_tieable_p): New function.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/rl78/rl78.h (MODES_TIEABLE_P): Delete.\n+\t* config/rl78/rl78.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(rl78_modes_tieable_p): New function.\n+\t* config/rs6000/rs6000.h (MODES_TIEABLE_P): Delete.\n+\t* config/rs6000/rs6000.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(rs6000_modes_tieable_p): New function.\n+\t(rs6000_debug_reg_global): Use it instead of MODES_TIEABLE_P.\n+\t* config/rs6000/rs6000.md: Update comment.\n+\t* config/rx/rx.h (MODES_TIEABLE_P): Delete.\n+\t* config/rx/rx.c (rx_modes_tieable_p): New function.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/s390/s390.h (MODES_TIEABLE_P): Delete.\n+\t* config/s390/s390.c (s390_modes_tieable_p): New function.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/sh/sh.h (MODES_TIEABLE_P): Delete.\n+\t* config/sh/sh.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(sh_modes_tieable_p): New function.\n+\t* config/sparc/sparc.h (MODES_TIEABLE_P): Delete.\n+\t* config/sparc/sparc-protos.h (sparc_modes_tieable_p): Delete.\n+\t* config/sparc/sparc.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(sparc_modes_tieable_p): Make static.\n+\t* config/spu/spu.h (MODES_TIEABLE_P): Delete.\n+\t* config/spu/spu.c (spu_modes_tieable_p): New function.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/stormy16/stormy16.h (MODES_TIEABLE_P): Delete.\n+\t* config/stormy16/stormy16.c (xstormy16_modes_tieable_p): New function.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/tilegx/tilegx.h (MODES_TIEABLE_P): Delete.\n+\t* config/tilepro/tilepro.h (MODES_TIEABLE_P): Delete.\n+\t* config/v850/v850.h (MODES_TIEABLE_P): Delete.\n+\t* config/v850/v850.c (v850_modes_tieable_p): New function.\n+\t(TARGET_MODES_TIEABLE_P): Redefine.\n+\t* config/vax/vax.h (MODES_TIEABLE_P): Delete.\n+\t* config/visium/visium.h (MODES_TIEABLE_P): Delete.\n+\t* config/visium/visium.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(visium_modes_tieable_p): New function.\n+\t* config/xtensa/xtensa.h (MODES_TIEABLE_P): Delete.\n+\t* config/xtensa/xtensa.c (TARGET_MODES_TIEABLE_P): Redefine.\n+\t(xtensa_modes_tieable_p): New function.\n+\t* system.h (MODES_TIEABLE_P): Poison.\n+\n 2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "e6a4879dfb229661652e3734c1a4e723dad90ac0", "filename": "gcc/combine.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -5447,11 +5447,11 @@ subst (rtx x, rtx from, rtx to, int in_dest, int in_cond, int unique_copy)\n \t\t     FROM to CC0.  */\n \n \t\t  if (GET_CODE (to) == SUBREG\n-\t\t      && ! MODES_TIEABLE_P (GET_MODE (to),\n-\t\t\t\t\t    GET_MODE (SUBREG_REG (to)))\n+\t\t      && !targetm.modes_tieable_p (GET_MODE (to),\n+\t\t\t\t\t\t   GET_MODE (SUBREG_REG (to)))\n \t\t      && ! (code == SUBREG\n-\t\t\t    && MODES_TIEABLE_P (GET_MODE (x),\n-\t\t\t\t\t\tGET_MODE (SUBREG_REG (to))))\n+\t\t\t    && (targetm.modes_tieable_p\n+\t\t\t\t(GET_MODE (x), GET_MODE (SUBREG_REG (to)))))\n \t\t      && (!HAVE_cc0\n \t\t\t  || (! (code == SET\n \t\t\t\t && i == 1"}, {"sha": "8bd936c5f416fd97c921a680eb9475f1abceb236", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -339,8 +339,6 @@ bool aarch64_label_mentioned_p (rtx);\n void aarch64_declare_function_name (FILE *, const char*, tree);\n bool aarch64_legitimate_pic_operand_p (rtx);\n bool aarch64_mask_and_shift_for_ubfiz_p (machine_mode, rtx, rtx);\n-bool aarch64_modes_tieable_p (machine_mode mode1,\n-\t\t\t      machine_mode mode2);\n bool aarch64_zero_extend_const_eq (machine_mode, rtx, machine_mode, rtx);\n bool aarch64_move_imm (HOST_WIDE_INT, machine_mode);\n bool aarch64_mov_operand_p (rtx, machine_mode);"}, {"sha": "a231bace4d374e750af243cd41fee37242883d75", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -13863,16 +13863,15 @@ aarch64_reverse_mask (machine_mode mode)\n   return force_reg (V16QImode, mask);\n }\n \n-/* Implement MODES_TIEABLE_P.  In principle we should always return true.\n-   However due to issues with register allocation it is preferable to avoid\n-   tieing integer scalar and FP scalar modes.  Executing integer operations\n-   in general registers is better than treating them as scalar vector\n-   operations.  This reduces latency and avoids redundant int<->FP moves.\n-   So tie modes if they are either the same class, or vector modes with\n-   other vector modes, vector structs or any scalar mode.\n-*/\n+/* Implement TARGET_MODES_TIEABLE_P.  In principle we should always return\n+   true.  However due to issues with register allocation it is preferable\n+   to avoid tieing integer scalar and FP scalar modes.  Executing integer\n+   operations in general registers is better than treating them as scalar\n+   vector operations.  This reduces latency and avoids redundant int<->FP\n+   moves.  So tie modes if they are either the same class, or vector modes\n+   with other vector modes, vector structs or any scalar mode.  */\n \n-bool\n+static bool\n aarch64_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n   if (GET_MODE_CLASS (mode1) == GET_MODE_CLASS (mode2))\n@@ -15672,6 +15671,9 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK aarch64_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P aarch64_modes_tieable_p\n+\n #undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n #define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n   aarch64_hard_regno_call_part_clobbered"}, {"sha": "3332b33d99625ba8b02160d2dee32c1a489d98f5", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -403,8 +403,6 @@ extern unsigned aarch64_architecture_version;\n \n #define HARD_REGNO_NREGS(REGNO, MODE)\taarch64_hard_regno_nregs (REGNO, MODE)\n \n-#define MODES_TIEABLE_P(MODE1, MODE2) aarch64_modes_tieable_p (MODE1, MODE2)\n-\n #define DWARF2_UNWIND_INFO 1\n \n /* Use R0 through R3 to pass exception handling information.  */"}, {"sha": "d582d9499406ebbf21854b140a38828845096192", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -9907,6 +9907,17 @@ alpha_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n \t    || mode == DCmode);\n   return true;\n }\n+\n+/* Implement TARGET_MODES_TIEABLE_P.  This asymmetric test is true when\n+   MODE1 could be put in an FP register but MODE2 could not.  */\n+\n+static bool\n+alpha_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return (alpha_hard_regno_mode_ok (32, mode1)\n+\t  ? alpha_hard_regno_mode_ok (32, mode2)\n+\t  : true);\n+}\n \f\n /* Initialize the GCC target structure.  */\n #if TARGET_ABI_OPEN_VMS\n@@ -10104,6 +10115,9 @@ alpha_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK alpha_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P alpha_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f"}, {"sha": "b9fee20ef6528e137bdd20c849e2ff367a769da5", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -385,17 +385,6 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n   CEIL (GET_MODE_SIZE (MODE), UNITS_PER_WORD)\n \n-/* A C expression that is nonzero if a value of mode\n-   MODE1 is accessible in mode MODE2 without copying.\n-\n-   This asymmetric test is true when MODE1 could be put\n-   in an FP register but MODE2 could not.  */\n-\n-#define MODES_TIEABLE_P(MODE1, MODE2) \t\t\t\t\\\n-  (targetm.hard_regno_mode_ok (32, (MODE1))\t\t\t\\\n-   ? targetm.hard_regno_mode_ok (32, (MODE2))\t\t\t\\\n-   : 1)\n-\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n "}, {"sha": "7d84f8176971bae81820bbd4e069add6062409cf", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -593,6 +593,9 @@ static void arc_finalize_pic (void);\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK arc_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P arc_modes_tieable_p\n+\n /* Try to keep the (mov:DF _, reg) as early as possible so\n    that the d<add/sub/mul>h-lr insns appear together and can\n    use the peephole2 pattern.  */\n@@ -1882,6 +1885,17 @@ arc_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return (arc_hard_regno_modes[regno] & arc_mode_class[mode]) != 0;\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.  Tie QI/HI/SI modes together.  */\n+\n+static bool\n+arc_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return (GET_MODE_CLASS (mode1) == MODE_INT\n+\t  && GET_MODE_CLASS (mode2) == MODE_INT\n+\t  && GET_MODE_SIZE (mode1) <= UNITS_PER_WORD\n+\t  && GET_MODE_SIZE (mode2) <= UNITS_PER_WORD);\n+}\n+\n /* Handle an \"interrupt\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "e012aae91bb9eea183a45ef4c12e6847b5bd5a50", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -450,21 +450,6 @@ if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n   && REGNO >= ARC_FIRST_SIMD_VR_REG && REGNO <= ARC_LAST_SIMD_VR_REG) ? 1 \\\n  : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* A C expression that is nonzero if it is desirable to choose\n-   register allocation so as to avoid move instructions between a\n-   value of mode MODE1 and a value of mode MODE2.\n-\n-   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n-   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n-   then `TARGET_MODES_TIEABLE_P (MODE1, MODE2)' must be zero.  */\n-\n-/* Tie QI/HI/SI modes together.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-(GET_MODE_CLASS (MODE1) == MODE_INT\t\t\\\n- && GET_MODE_CLASS (MODE2) == MODE_INT\t\t\\\n- && GET_MODE_SIZE (MODE1) <= UNITS_PER_WORD\t\\\n- && GET_MODE_SIZE (MODE2) <= UNITS_PER_WORD)\n-\n /* Internal macros to classify a register number as to whether it's a\n    general purpose register for compact insns (r0-r3,r12-r15), or\n    stack pointer (r28).  */"}, {"sha": "7fc2b603cedc553a71af740ddc94ced410cc08a2", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -61,7 +61,6 @@ extern void arm_gen_unlikely_cbranch (enum rtx_code, machine_mode cc_mode,\n \t\t\t\t      rtx label_ref);\n extern bool arm_vector_mode_supported_p (machine_mode);\n extern bool arm_small_register_classes_for_mode_p (machine_mode);\n-extern bool arm_modes_tieable_p (machine_mode, machine_mode);\n extern int const_ok_for_arm (HOST_WIDE_INT);\n extern int const_ok_for_op (HOST_WIDE_INT, enum rtx_code);\n extern int const_ok_for_dimode_op (HOST_WIDE_INT, enum rtx_code);"}, {"sha": "c7a45963e50353edee4785df28cac0ec0cffc994", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -314,6 +314,7 @@ static unsigned int arm_elf_section_type_flags (tree decl, const char *name,\n static void arm_expand_divmod_libfunc (rtx, machine_mode, rtx, rtx, rtx *, rtx *);\n static opt_scalar_float_mode arm_floatn_mode (int, bool);\n static bool arm_hard_regno_mode_ok (unsigned int, machine_mode);\n+static bool arm_modes_tieable_p (machine_mode, machine_mode);\n \f\n /* Table of machine attributes.  */\n static const struct attribute_spec arm_attribute_table[] =\n@@ -783,6 +784,9 @@ static const struct attribute_spec arm_attribute_table[] =\n \n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK arm_hard_regno_mode_ok\n+\n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P arm_modes_tieable_p\n \f\n /* Obstack for minipool constant handling.  */\n static struct obstack minipool_obstack;\n@@ -23427,9 +23431,9 @@ arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return false;\n }\n \n-/* Implement MODES_TIEABLE_P.  */\n+/* Implement TARGET_MODES_TIEABLE_P.  */\n \n-bool\n+static bool\n arm_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n   if (GET_MODE_CLASS (mode1) == GET_MODE_CLASS (mode2))"}, {"sha": "67b4cada8b50ce454887d501d78312eb7aec9b87", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -990,8 +990,6 @@ extern int arm_arch_cmse;\n     && !IS_VFP_REGNUM (REGNO)\t\t\\\n    ? 1 : ARM_NUM_REGS (MODE))\n \n-#define MODES_TIEABLE_P(MODE1, MODE2) arm_modes_tieable_p (MODE1, MODE2)\n-\n #define VALID_IWMMXT_REG_MODE(MODE) \\\n  (arm_vector_mode_supported_p (MODE) || (MODE) == DImode)\n "}, {"sha": "e7667de409a6a840e50888505b53d1bd0b6184b6", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -212,8 +212,6 @@ FIXME: DRIVER_SELF_SPECS has changed.\n #define HARD_REGNO_NREGS(REGNO, MODE)                                   \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-#define MODES_TIEABLE_P(MODE1, MODE2) 1\n-\n enum reg_class {\n   NO_REGS,\n   R0_REG,\t\t\t/* r0 */"}, {"sha": "7bf8c4267a2617ac43683b72651d97374337349b", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -2146,6 +2146,21 @@ bfin_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return TEST_HARD_REG_BIT (reg_class_contents[MOST_REGS], regno);\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+bfin_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return (mode1 == mode2\n+\t  || ((GET_MODE_CLASS (mode1) == MODE_INT\n+\t       || GET_MODE_CLASS (mode1) == MODE_FLOAT)\n+\t      && (GET_MODE_CLASS (mode2) == MODE_INT\n+\t\t  || GET_MODE_CLASS (mode2) == MODE_FLOAT)\n+\t      && mode1 != BImode && mode2 != BImode\n+\t      && GET_MODE_SIZE (mode1) <= UNITS_PER_WORD\n+\t      && GET_MODE_SIZE (mode2) <= UNITS_PER_WORD));\n+}\n+\n /* Implements target hook vector_mode_supported_p.  */\n \n static bool\n@@ -5850,4 +5865,7 @@ bfin_conditional_register_usage (void)\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK bfin_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P bfin_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "e5d08343f97732e624eb19398c6d1e8f0514fecf", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -692,23 +692,6 @@ enum reg_class\n    considered for use as a rename register for FROM register */\n #define HARD_REGNO_RENAME_OK(FROM, TO) bfin_hard_regno_rename_ok (FROM, TO)\n \n-/* A C expression that is nonzero if it is desirable to choose\n-   register allocation so as to avoid move instructions between a\n-   value of mode MODE1 and a value of mode MODE2.\n-\n-   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n-   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n-   then `MODES_TIEABLE_P (MODE1, MODE2)' must be zero. */\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n- ((MODE1) == (MODE2)\t\t\t\t\t\\\n-  || ((GET_MODE_CLASS (MODE1) == MODE_INT\t\t\\\n-       || GET_MODE_CLASS (MODE1) == MODE_FLOAT)\t\t\\\n-      && (GET_MODE_CLASS (MODE2) == MODE_INT\t\t\\\n-\t  || GET_MODE_CLASS (MODE2) == MODE_FLOAT)\t\\\n-      && (MODE1) != BImode && (MODE2) != BImode\t\t\\\n-      && GET_MODE_SIZE (MODE1) <= UNITS_PER_WORD\t\\\n-      && GET_MODE_SIZE (MODE2) <= UNITS_PER_WORD))\n-\n /* `PREFERRED_RELOAD_CLASS (X, CLASS)'\n    A C expression that places additional restrictions on the register\n    class to use when it is necessary to copy value X into a register"}, {"sha": "3e26bed316e481b4c684cdf52802e48bd13cf9ae", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -6704,6 +6704,17 @@ c6x_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   return GET_MODE_SIZE (mode) <= UNITS_PER_WORD || (regno & 1) == 0;\n }\n+\n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+c6x_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return (mode1 == mode2\n+\t  || (GET_MODE_SIZE (mode1) <= UNITS_PER_WORD\n+\t      && GET_MODE_SIZE (mode2) <= UNITS_PER_WORD));\n+}\n+\n \f\n /* Target Structure.  */\n \n@@ -6872,6 +6883,8 @@ c6x_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n \n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK c6x_hard_regno_mode_ok\n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P c6x_modes_tieable_p\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "8c0cbc927a080fe71c6c5057bd8b6333d49efc7e", "filename": "gcc/config/c6x/c6x.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fc6x%2Fc6x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fc6x%2Fc6x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -185,11 +185,6 @@ extern c6x_cpu_t c6x_arch;\n   ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1)  \\\n    / UNITS_PER_WORD)\n \n-#define MODES_TIEABLE_P(mode1, mode2)\t       \\\n-  ((mode1) == (mode2) ||\t\t       \\\n-   (GET_MODE_SIZE (mode1) <= UNITS_PER_WORD && \\\n-    GET_MODE_SIZE (mode2) <= UNITS_PER_WORD))\n-\n \n /* Register Classes.  */\n "}, {"sha": "0476065da448f27eb0dd1f8fdc6dea95242a17be", "filename": "gcc/config/cr16/cr16.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fcr16%2Fcr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fcr16%2Fcr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -222,6 +222,8 @@ static const struct attribute_spec cr16_attribute_table[] = {\n \n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK\tcr16_hard_regno_mode_ok\n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P\t\tcr16_modes_tieable_p\n \n /* Target hook implementations.  */\n \n@@ -493,6 +495,13 @@ cr16_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return true;\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+static bool\n+cr16_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return GET_MODE_CLASS (mode1) == GET_MODE_CLASS (mode2);\n+}\n+\n /* Returns register number for function return value.*/\n static inline unsigned int\n cr16_ret_register (void)"}, {"sha": "66886c1e8cb8ae49405c0e847913cf0d3d16f2eb", "filename": "gcc/config/cr16/cr16.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fcr16%2Fcr16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fcr16%2Fcr16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -245,9 +245,6 @@ while (0)\n   (0 == COUNT)\t?  gen_rtx_PLUS (Pmode, gen_rtx_RA, gen_rtx_RA)\t\t\\\n \t\t:  const0_rtx\n \n-#define MODES_TIEABLE_P(MODE1, MODE2)  \\\n-  (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n-\n enum reg_class\n {\n   NO_REGS,"}, {"sha": "cbf21ea243613ff9412852b487ee42311153bab8", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -477,12 +477,6 @@ extern int cris_cpu_version;\n  (MODE == VOIDmode \\\n   ? 1 : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-/* Because CCmode isn't covered by the \"narrower mode\" statement in\n-   tm.texi, we can still say all modes are tieable despite not having an\n-   always 1 TARGET_HARD_REGNO_MODE_OK.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) 1\n-\n-\n /* Node: Leaf Functions */\n /* (no definitions) */\n "}, {"sha": "81b0f61251ea91d2ebe13a0124b16472aaf499aa", "filename": "gcc/config/epiphany/epiphany.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fepiphany%2Fepiphany.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -309,16 +309,6 @@ along with GCC; see the file COPYING3.  If not see\n #define HARD_REGNO_NREGS(REGNO, MODE) \\\n ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* A C expression that is nonzero if it is desirable to choose\n-   register allocation so as to avoid move instructions between a\n-   value of mode MODE1 and a value of mode MODE2.\n-\n-   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n-   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n-   then `MODES_TIEABLE_P (MODE1, MODE2)' must be zero.  */\n-\n-#define MODES_TIEABLE_P(MODE1, MODE2) 1\n-\n /* Register classes and constants.  */\n \n /* Define the classes of registers for register constraints in the"}, {"sha": "5fd1803d15ee083b228753ae22bcfb10df805473", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -246,15 +246,6 @@ along with GCC; see the file COPYING3.  If not see\n #define HARD_REGNO_NREGS(REGNO, MODE) \t\t\t\\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* A C expression that is nonzero if it is desirable to choose register\n-   allocation so as to avoid move instructions between a value of mode MODE1\n-   and a value of mode MODE2.\n-\n-   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n-   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n-   then `MODES_TIEABLE_P (MODE1, MODE2)' must be zero.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) 1\n-\n /*}}}*/ \f\n /*{{{  Register Classes.  */ \n \n@@ -810,9 +801,9 @@ fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n    On many machines, this expression can be 1.\n \n    When `TRULY_NOOP_TRUNCATION' returns 1 for a pair of sizes for modes for\n-   which `MODES_TIEABLE_P' is 0, suboptimal code can result.  If this is the\n-   case, making `TRULY_NOOP_TRUNCATION' return 0 in such cases may improve\n-   things.  */\n+   which `TARGET_MODES_TIEABLE_P' is 0, suboptimal code can result.\n+   If this is the case, making `TRULY_NOOP_TRUNCATION' return 0 in such\n+   cases may improve things.  */\n #define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n \n /* An alias for the machine mode for pointers.  On most machines, define this"}, {"sha": "b6119e9c3952deaf9af48c27937e077bcefbfc14", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -400,6 +400,7 @@ static void frv_conditional_register_usage\t(void);\n static void frv_trampoline_init\t\t\t(rtx, tree, rtx);\n static bool frv_class_likely_spilled_p \t\t(reg_class_t);\n static bool frv_hard_regno_mode_ok\t\t(unsigned int, machine_mode);\n+static bool frv_modes_tieable_p\t\t\t(machine_mode, machine_mode);\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_PRINT_OPERAND\n@@ -519,6 +520,8 @@ static bool frv_hard_regno_mode_ok\t\t(unsigned int, machine_mode);\n \n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK frv_hard_regno_mode_ok\n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P frv_modes_tieable_p\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n@@ -6590,6 +6593,14 @@ frv_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return false;\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+frv_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return mode1 == mode2;\n+}\n+\n \f\n /* A C expression for the number of consecutive hard registers, starting at\n    register number REGNO, required to hold a value of mode MODE."}, {"sha": "9232bea6ff1d846fafe4913da54aeca6e88184f1", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -763,15 +763,6 @@\n    we can build the appropriate instructions to properly reload the values.  */\n #define HARD_REGNO_NREGS(REGNO, MODE) frv_hard_regno_nregs (REGNO, MODE)\n \n-/* A C expression that is nonzero if it is desirable to choose register\n-   allocation so as to avoid move instructions between a value of mode MODE1\n-   and a value of mode MODE2.\n-\n-   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n-   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n-   then `MODES_TIEABLE_P (MODE1, MODE2)' must be zero.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) (MODE1 == MODE2)\n-\n /* Define this macro if the compiler should avoid copies to/from CCmode\n    registers.  You should only define this macro if support fo copying to/from\n    CCmode is incomplete.  */\n@@ -1855,10 +1846,10 @@ fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n \n    On many machines, this expression can be 1.\n \n-   When `TRULY_NOOP_TRUNCATION' returns 1 for a pair of sizes for modes for\n-   which `MODES_TIEABLE_P' is 0, suboptimal code can result.  If this is the\n-   case, making `TRULY_NOOP_TRUNCATION' return 0 in such cases may improve\n-   things.  */\n+   When `TRULY_NOOP_TRUNCATION' returns 1 for a pair of sizes for modes\n+   for which `TARGET_MODES_TIEABLE_P' is 0, suboptimal code can result.\n+   If this is the case, making `TRULY_NOOP_TRUNCATION' return 0 in such\n+   cases may improve things.  */\n #define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n \n /* An alias for the machine mode for pointers.  On most machines, define this"}, {"sha": "68cdda90fe0528b601c121ae51b7bede3f790001", "filename": "gcc/config/ft32/ft32.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fft32%2Fft32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fft32%2Fft32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fft32%2Fft32.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -178,10 +178,6 @@ enum reg_class\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)             \\\n    / UNITS_PER_WORD)\n \n-/* A C expression that is nonzero if a value of mode MODE1 is\n-   accessible in mode MODE2 without copying.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) 1\n-\n /* The Overall Framework of an Assembler File */\n \n #undef  ASM_SPEC"}, {"sha": "eaa7ab24c242bd7869451defad4678c46bca295d", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -5904,6 +5904,20 @@ h8300_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n     return regno == MAC_REG ? mode == SImode : 1;\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+h8300_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return (mode1 == mode2\n+\t  || ((mode1 == QImode\n+\t       || mode1 == HImode\n+\t       || ((TARGET_H8300H || TARGET_H8300S) && mode1 == SImode))\n+\t      && (mode2 == QImode\n+\t\t  || mode2 == HImode\n+\t\t  || ((TARGET_H8300H || TARGET_H8300S) && mode2 == SImode))));\n+}\n+\n /* Helper function for the move patterns.  Make sure a move is legitimate.  */\n \n bool\n@@ -6104,6 +6118,9 @@ h8300_trampoline_init (rtx m_tramp, tree fndecl, rtx cxt)\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK h8300_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P h8300_modes_tieable_p\n+\n #undef TARGET_LRA_P\n #define TARGET_LRA_P hook_bool_void_false\n "}, {"sha": "d6181e72dcfb333aa36f6857c5d458b6cf756fa9", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -239,17 +239,6 @@ extern const char * const *h8_reg_names;\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\\\n   h8300_hard_regno_nregs ((REGNO), (MODE))\n \n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n-   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t  \\\n-  ((MODE1) == (MODE2)\t\t\t\t\t\t\t  \\\n-   || (((MODE1) == QImode || (MODE1) == HImode\t\t\t\t  \\\n-\t|| ((TARGET_H8300H || TARGET_H8300S) && (MODE1) == SImode))\t  \\\n-       &&  ((MODE2) == QImode || (MODE2) == HImode\t\t\t  \\\n-\t    || ((TARGET_H8300H || TARGET_H8300S) && (MODE2) == SImode))))\n-\n /* A C expression that is nonzero if hard register NEW_REG can be\n    considered for use as a rename register for OLD_REG register */\n "}, {"sha": "0ed22e6556d673b8b9575d96d4812783c4f6035f", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -167,7 +167,6 @@ extern int ix86_reg_parm_stack_space (const_tree);\n \n extern void ix86_split_fp_branch (enum rtx_code code, rtx, rtx,\n \t\t\t\t  rtx, rtx, rtx);\n-extern bool ix86_modes_tieable_p (machine_mode, machine_mode);\n extern bool ix86_secondary_memory_needed (enum reg_class, enum reg_class,\n \t\t\t\t\t  machine_mode, int);\n extern bool ix86_cannot_change_mode_class (machine_mode,"}, {"sha": "6afd422d1a599c91d7699acc6a7a10d2f45d02bd", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -41440,11 +41440,13 @@ ix86_tieable_integer_mode_p (machine_mode mode)\n     }\n }\n \n-/* Return true if MODE1 is accessible in a register that can hold MODE2\n+/* Implement TARGET_MODES_TIEABLE_P.\n+\n+   Return true if MODE1 is accessible in a register that can hold MODE2\n    without copying.  That is, all register classes that can hold MODE2\n    can also hold MODE1.  */\n \n-bool\n+static bool\n ix86_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n   if (mode1 == mode2)\n@@ -53263,6 +53265,9 @@ ix86_run_selftests (void)\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK ix86_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P ix86_modes_tieable_p\n+\n #undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n #define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n   ix86_hard_regno_call_part_clobbered"}, {"sha": "8f9a2ad4d7309d1d16f2c04601147590cd5a5366", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -1181,14 +1181,6 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n   (TARGET_FMA4 && ((MODE) == V4SFmode || (MODE) == V2DFmode \\\n \t\t  || (MODE) == V8SFmode || (MODE) == V4DFmode))\n \n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n-   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n-\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  ix86_modes_tieable_p ((MODE1), (MODE2))\n-\n /* It is possible to write patterns to move flags; but until someone\n    does it,  */\n #define AVOID_CCMODE_COPIES"}, {"sha": "febadda1c7456cf3e1205ffceb63f3f0a7c40081", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -336,6 +336,7 @@ static bool ia64_vectorize_vec_perm_const_ok (machine_mode vmode,\n \t\t\t\t\t      const unsigned char *sel);\n \n static bool ia64_hard_regno_mode_ok (unsigned int, machine_mode);\n+static bool ia64_modes_tieable_p (machine_mode, machine_mode);\n \n #define MAX_VECT_LEN\t8\n \n@@ -658,6 +659,9 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK ia64_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P ia64_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Returns TRUE iff the target attribute indicated by ATTR_ID takes a plain\n@@ -4281,6 +4285,21 @@ ia64_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return false;\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.\n+\n+   Don't tie integer and FP modes, as that causes us to get integer registers\n+   allocated for FP instructions.  XFmode only supported in FP registers so\n+   we can't tie it with any other modes.  */\n+\n+static bool\n+ia64_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return (GET_MODE_CLASS (mode1) == GET_MODE_CLASS (mode2)\n+\t  && ((mode1 == XFmode || mode1 == XCmode || mode1 == RFmode)\n+\t      == (mode2 == XFmode || mode2 == XCmode || mode2 == RFmode))\n+\t  && (mode1 == BImode) == (mode2 == BImode));\n+}\n+\n /* Target hook for assembling integer objects.  Handle word-sized\n    aligned objects and detect the cases when @fptr is needed.  */\n "}, {"sha": "6d76f5fd0790fe513dc406022549b3e56d2a5cb4", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -614,22 +614,6 @@ while (0)\n    : FR_REGNO_P (REGNO) && (MODE) == XCmode ? 2\t\t\t\t\\\n    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* A C expression that is nonzero if it is desirable to choose register\n-   allocation so as to avoid move instructions between a value of mode MODE1\n-   and a value of mode MODE2.\n-\n-   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n-   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n-   then `MODES_TIEABLE_P (MODE1, MODE2)' must be zero.  */\n-/* Don't tie integer and FP modes, as that causes us to get integer registers\n-   allocated for FP instructions.  XFmode only supported in FP registers so\n-   we can't tie it with any other modes.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n-  (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2)\t\\\n-   && ((((MODE1) == XFmode) || ((MODE1) == XCmode) || ((MODE1) == RFmode))\t\\\n-       == (((MODE2) == XFmode) || ((MODE2) == XCmode) || ((MODE2) == RFmode)))\t\\\n-   && (((MODE1) == BImode) == ((MODE2) == BImode)))\n-\n /* Specify the modes required to caller save a given hard regno.\n    We need to ensure floating pt regs are not saved as DImode.  */\n "}, {"sha": "a792a98d2271baaa081c1f6926b3b16942faea9b", "filename": "gcc/config/iq2000/iq2000.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fiq2000%2Fiq2000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -178,6 +178,7 @@ static void iq2000_print_operand      (FILE *, rtx, int);\n static void iq2000_print_operand_address (FILE *, machine_mode, rtx);\n static bool iq2000_print_operand_punct_valid_p (unsigned char code);\n static bool iq2000_hard_regno_mode_ok (unsigned int, machine_mode);\n+static bool iq2000_modes_tieable_p (machine_mode, machine_mode);\n \n #undef  TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS \t\tiq2000_init_builtins\n@@ -257,6 +258,8 @@ static bool iq2000_hard_regno_mode_ok (unsigned int, machine_mode);\n \n #undef  TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK\tiq2000_hard_regno_mode_ok\n+#undef  TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P\t\tiq2000_modes_tieable_p\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -3499,4 +3502,15 @@ iq2000_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n \t  : (regno & 1) == 0 || GET_MODE_SIZE (mode) == 4);\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+iq2000_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return ((GET_MODE_CLASS (mode1) == MODE_FLOAT\n+\t   || GET_MODE_CLASS (mode1) == MODE_COMPLEX_FLOAT)\n+\t  == (GET_MODE_CLASS (mode2) == MODE_FLOAT\n+\t      || GET_MODE_CLASS (mode2) == MODE_COMPLEX_FLOAT));\n+}\n+\n #include \"gt-iq2000.h\""}, {"sha": "9855255ad2bcba79ce197beb6cffc0c330dfb1d6", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -165,12 +165,6 @@\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\\\n-  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT ||\t\t\t\\\n-    GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\\\n-   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT ||\t\t\t\\\n-       GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n-\n #define AVOID_CCMODE_COPIES\n \n \f"}, {"sha": "2dcff759f161cf7d5d9b52e71376107d4550fd38", "filename": "gcc/config/lm32/lm32.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Flm32%2Flm32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Flm32%2Flm32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -78,6 +78,7 @@ static void lm32_function_arg_advance (cumulative_args_t cum,\n \t\t\t\t       machine_mode mode,\n \t\t\t\t       const_tree type, bool named);\n static bool lm32_hard_regno_mode_ok (unsigned int, machine_mode);\n+static bool lm32_modes_tieable_p (machine_mode, machine_mode);\n \n #undef TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE lm32_option_override\n@@ -109,6 +110,8 @@ static bool lm32_hard_regno_mode_ok (unsigned int, machine_mode);\n #define TARGET_LEGITIMATE_ADDRESS_P lm32_legitimate_address_p\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK lm32_hard_regno_mode_ok\n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P lm32_modes_tieable_p\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n@@ -1232,3 +1235,14 @@ lm32_hard_regno_mode_ok (unsigned int regno, machine_mode)\n {\n   return G_REG_P (regno);\n }\n+\n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+lm32_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return (GET_MODE_CLASS (mode1) == MODE_INT\n+\t  && GET_MODE_CLASS (mode2) == MODE_INT\n+\t  && GET_MODE_SIZE (mode1) <= UNITS_PER_WORD\n+\t  && GET_MODE_SIZE (mode2) <= UNITS_PER_WORD);\n+}"}, {"sha": "d3d197e31f32ab92cbe291d046b8c34b1cd2d8eb", "filename": "gcc/config/lm32/lm32.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Flm32%2Flm32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Flm32%2Flm32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flm32%2Flm32.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -166,12 +166,6 @@ do {                                                    \\\n #define HARD_REGNO_NREGS(REGNO, MODE)                                   \\\n     ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-#define MODES_TIEABLE_P(MODE1, MODE2)           \\\n-(      GET_MODE_CLASS (MODE1) == MODE_INT\t\t\\\n-    && GET_MODE_CLASS (MODE2) == MODE_INT\t\t\\\n-    && GET_MODE_SIZE (MODE1) <= UNITS_PER_WORD\t\\\n-    && GET_MODE_SIZE (MODE2) <= UNITS_PER_WORD)\n-\n #define AVOID_CCMODE_COPIES\n \n /*----------------------------------*/"}, {"sha": "50e5e0c5e3b28cf9e1807ebd466ee7e334fc4fb9", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -55,7 +55,6 @@ bool m32c_immd_dbl_mov (rtx *, machine_mode);\n rtx  m32c_incoming_return_addr_rtx (void);\n int  m32c_legitimize_reload_address (rtx *, machine_mode, int, int, int);\n int  m32c_limit_reload_class (machine_mode, int);\n-int  m32c_modes_tieable_p (machine_mode, machine_mode);\n bool m32c_mov_ok (rtx *, machine_mode);\n char * m32c_output_compare (rtx_insn *, rtx *);\n int  m32c_prepare_move (rtx *, machine_mode);"}, {"sha": "5332e6a9b7e9b420b8270c0d53ecbc3482c40cfa", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -583,11 +583,11 @@ m32c_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return m32c_hard_regno_nregs_1 (regno, mode) != 0;\n }\n \n-/* Implements MODES_TIEABLE_P.  In general, modes aren't tieable since\n+/* Implement TARGET_MODES_TIEABLE_P.  In general, modes aren't tieable since\n    registers are all different sizes.  However, since most modes are\n    bigger than our registers anyway, it's easier to implement this\n    function that way, leaving QImode as the only unique case.  */\n-int\n+static bool\n m32c_modes_tieable_p (machine_mode m1, machine_mode m2)\n {\n   if (GET_MODE_SIZE (m1) == GET_MODE_SIZE (m2))\n@@ -4491,6 +4491,8 @@ m32c_output_compare (rtx_insn *insn, rtx *operands)\n \n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK m32c_hard_regno_mode_ok\n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P m32c_modes_tieable_p\n \n /* The Global `targetm' Variable. */\n "}, {"sha": "c2a0c249ac84d5fcfd2ccd161e9be0c161f9fa2c", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -256,7 +256,6 @@ machine_function;\n /* How Values Fit in Registers */\n \n #define HARD_REGNO_NREGS(R,M) m32c_hard_regno_nregs (R, M)\n-#define MODES_TIEABLE_P(M1,M2) m32c_modes_tieable_p (M1, M2)\n #define AVOID_CCMODE_COPIES\n \n /* Register Classes */"}, {"sha": "9b7cb5f7d703d64260ccb80faac6e2ecb608ea2f", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -103,6 +103,7 @@ static void m32r_trampoline_init (rtx, tree, rtx);\n static bool m32r_legitimate_constant_p (machine_mode, rtx);\n static bool m32r_attribute_identifier (const_tree);\n static bool m32r_hard_regno_mode_ok (unsigned int, machine_mode);\n+static bool m32r_modes_tieable_p (machine_mode, machine_mode);\n \f\n /* M32R specific attributes.  */\n \n@@ -213,6 +214,9 @@ static const struct attribute_spec m32r_attribute_table[] =\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK m32r_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P m32r_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Called by m32r_option_override to initialize various things.  */\n@@ -2759,6 +2763,17 @@ m32r_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return (m32r_hard_regno_modes[regno] & m32r_mode_class[mode]) != 0;\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.  Tie QI/HI/SI modes together.  */\n+\n+static bool\n+m32r_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return (GET_MODE_CLASS (mode1) == MODE_INT\n+\t  && GET_MODE_CLASS (mode2) == MODE_INT\n+\t  && GET_MODE_SIZE (mode1) <= UNITS_PER_WORD\n+\t  && GET_MODE_SIZE (mode2) <= UNITS_PER_WORD);\n+}\n+\n /* Return true if using NEW_REG in place of OLD_REG is ok.  */\n \n int"}, {"sha": "51f8b394c7d4f2ca497bf468a57dea5c45217da7", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -396,21 +396,6 @@\n #define HARD_REGNO_NREGS(REGNO, MODE) \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* A C expression that is nonzero if it is desirable to choose\n-   register allocation so as to avoid move instructions between a\n-   value of mode MODE1 and a value of mode MODE2.\n-\n-   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n-   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n-   then `MODES_TIEABLE_P (MODE1, MODE2)' must be zero.  */\n-\n-/* Tie QI/HI/SI modes together.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \t\t\\\n-  (   GET_MODE_CLASS (MODE1) == MODE_INT\t\\\n-   && GET_MODE_CLASS (MODE2) == MODE_INT\t\\\n-   && GET_MODE_SIZE (MODE1) <= UNITS_PER_WORD\t\\\n-   && GET_MODE_SIZE (MODE2) <= UNITS_PER_WORD)\n-\n #define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG) \\\n   m32r_hard_regno_rename_ok (OLD_REG, NEW_REG)\n \f"}, {"sha": "73b76375860e6ab515d5d5fe8f2341406ca19666", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -188,6 +188,7 @@ static void m68k_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;\n static enum flt_eval_method\n m68k_excess_precision (enum excess_precision_type);\n static bool m68k_hard_regno_mode_ok (unsigned int, machine_mode);\n+static bool m68k_modes_tieable_p (machine_mode, machine_mode);\n \f\n /* Initialize the GCC target structure.  */\n \n@@ -338,6 +339,9 @@ static bool m68k_hard_regno_mode_ok (unsigned int, machine_mode);\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK m68k_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P m68k_modes_tieable_p\n+\n static const struct attribute_spec m68k_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n@@ -5204,6 +5208,18 @@ m68k_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return false;\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+m68k_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return (!TARGET_HARD_FLOAT\n+\t  || ((GET_MODE_CLASS (mode1) == MODE_FLOAT\n+\t       || GET_MODE_CLASS (mode1) == MODE_COMPLEX_FLOAT)\n+\t      == (GET_MODE_CLASS (mode2) == MODE_FLOAT\n+\t\t  || GET_MODE_CLASS (mode2) == MODE_COMPLEX_FLOAT)));\n+}\n+\n /* Implement SECONDARY_RELOAD_CLASS.  */\n \n enum reg_class"}, {"sha": "363b39078209a7e7add3cf0eb4f0a6dabcc6c75f", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -397,13 +397,6 @@ along with GCC; see the file COPYING3.  If not see\n #define SECONDARY_RELOAD_CLASS(CLASS, MODE, X) \\\n   m68k_secondary_reload_class (CLASS, MODE, X)\n \n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n-  (! TARGET_HARD_FLOAT\t\t\t\t\t\\\n-   || ((GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\\\n-\t|| GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\\\n-       == (GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\t\\\n-\t   || GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT)))\n-\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n "}, {"sha": "81a5820d2e94446315717983116dfc086b91c026", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -145,6 +145,7 @@ static bool       mcore_legitimate_constant_p   (machine_mode, rtx);\n static bool\t  mcore_legitimate_address_p\t(machine_mode, rtx, bool,\n \t\t\t\t\t\t addr_space_t);\n static bool\t  mcore_hard_regno_mode_ok\t(unsigned int, machine_mode);\n+static bool\t  mcore_modes_tieable_p\t\t(machine_mode, machine_mode);\n \f\n /* MCore specific attributes.  */\n \n@@ -244,6 +245,9 @@ static const struct attribute_spec mcore_attribute_table[] =\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK mcore_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P mcore_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Adjust the stack and return the number of bytes taken to do it.  */\n@@ -3275,3 +3279,11 @@ mcore_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n \n   return regno < 18;\n }\n+\n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+mcore_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return mode1 == mode2 || GET_MODE_CLASS (mode1) == GET_MODE_CLASS (mode2);\n+}"}, {"sha": "cf9fbe81f29505ee2fb34a226b039af65a387fd1", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -248,13 +248,6 @@ extern char * mcore_current_function_name;\n #define HARD_REGNO_NREGS(REGNO, MODE)  \\\n    (((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n-   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  ((MODE1) == (MODE2) || GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n-\n /* Definitions for register eliminations.\n \n    We have two registers that can be eliminated on the MCore.  First, the"}, {"sha": "b05eae6b390e7b2e53278e4af154d1628ea91169", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -1860,6 +1860,17 @@ microblaze_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return microblaze_hard_regno_mode_ok_p[mode][regno];\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+microblaze_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return ((GET_MODE_CLASS (mode1) == MODE_FLOAT\n+\t   || GET_MODE_CLASS (mode1) == MODE_COMPLEX_FLOAT)\n+\t  == (GET_MODE_CLASS (mode2) == MODE_FLOAT\n+\t      || GET_MODE_CLASS (mode2) == MODE_COMPLEX_FLOAT));\n+}\n+\n /* Return true if FUNC is an interrupt function as specified\n    by the \"interrupt_handler\" attribute.  */\n \n@@ -3890,6 +3901,9 @@ microblaze_machine_dependent_reorg (void)\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK microblaze_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P microblaze_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n #include \"gt-microblaze.h\""}, {"sha": "fe8b9c7475b9d255ba366ed2cbf4d5f96580efef", "filename": "gcc/config/microblaze/microblaze.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -295,12 +295,6 @@ extern enum pipeline_type microblaze_pipe;\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n \t((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n-  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT ||\t\t\t\t\\\n-    GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\t\\\n-   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT ||\t\t\t\t\\\n-       GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n-\n #define STACK_POINTER_REGNUM   (GP_REG_FIRST + MB_ABI_STACK_POINTER_REGNUM)\n \n #define STACK_POINTER_OFFSET   FIRST_PARM_OFFSET(FNDECL)"}, {"sha": "1ec9669b0cd5de65246c18abfb2637e307c90b6a", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -300,7 +300,6 @@ extern bool mips_secondary_memory_needed (enum reg_class, enum reg_class,\n extern bool mips_cannot_change_mode_class (machine_mode,\n \t\t\t\t\t   machine_mode, enum reg_class);\n extern bool mips_dangerous_for_la25_p (rtx);\n-extern bool mips_modes_tieable_p (machine_mode, machine_mode);\n extern enum reg_class mips_secondary_reload_class (enum reg_class,\n \t\t\t\t\t\t   machine_mode,\n \t\t\t\t\t\t   rtx, bool);"}, {"sha": "7c70c6727b89f4d0b2e17c7d75f3c799d043786b", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -13017,9 +13017,9 @@ mips_mode_ok_for_mov_fmt_p (machine_mode mode)\n     }\n }\n \n-/* Implement MODES_TIEABLE_P.  */\n+/* Implement TARGET_MODES_TIEABLE_P.  */\n \n-bool\n+static bool\n mips_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n   /* FPRs allow no mode punning, so it's not worth tying modes if we'd\n@@ -22589,6 +22589,9 @@ mips_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK mips_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P mips_modes_tieable_p\n+\n #undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n #define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n   mips_hard_regno_call_part_clobbered"}, {"sha": "45dd41df665f7462680e4462f93ccfe6c0ec605a", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -1968,8 +1968,6 @@ FP_ASM_SPEC \"\\\n #define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) \\\n   mips_hard_regno_caller_save_mode (REGNO, NREGS, MODE)\n \n-#define MODES_TIEABLE_P mips_modes_tieable_p\n-\n /* Register to use for pushing function arguments.  */\n #define STACK_POINTER_REGNUM (GP_REG_FIRST + 29)\n "}, {"sha": "5852cf1f32e4c21300ba04b24797ed21ca22cc78", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -386,12 +386,6 @@ struct GTY(()) machine_function\n    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \t\\\n     / UNITS_PER_WORD)\n \n-/* Note that no register can really be accessed in single-float mode, so\n-   we *can* say 1 here.  FIXME:  Will TRT happen for single-float, or do\n-   we have to punt to libgcc1.asm?  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) 1\n-\n-\n /* Node: Leaf Functions */\n /* (empty) */\n "}, {"sha": "a7600eae6625ed7eff9d06822c25a2d6206d7fe3", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -25,7 +25,6 @@ extern rtx   mn10300_legitimize_reload_address (rtx, machine_mode,\n \t\t\t\t\t\tint, int, int);\n extern bool  mn10300_function_value_regno_p (const unsigned int);\n extern unsigned int   mn10300_get_live_callee_saved_regs (unsigned int *);\n-extern bool  mn10300_modes_tieable (machine_mode, machine_mode);\n extern const char *mn10300_output_add (rtx[3], bool);\n extern void  mn10300_print_operand (FILE *, rtx, int);\n extern void  mn10300_print_operand_address (FILE *, rtx);"}, {"sha": "8351a5ef9595d860f611019156f0bae2d98bf851", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -2650,8 +2650,10 @@ mn10300_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return false;\n }\n \n-bool\n-mn10300_modes_tieable (machine_mode mode1, machine_mode mode2)\n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+mn10300_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n   if (GET_MODE_CLASS (mode1) == MODE_FLOAT\n       && GET_MODE_CLASS (mode2) != MODE_FLOAT)\n@@ -3430,4 +3432,7 @@ mn10300_reorg (void)\n #undef  TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK mn10300_hard_regno_mode_ok\n \n+#undef  TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P mn10300_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "6d691bd2d3528f092a1ec45fbdcde0dd11ec0ea3", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -233,13 +233,6 @@ extern enum processor_type mn10300_tune_cpu;\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n-   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  mn10300_modes_tieable ((MODE1), (MODE2))\n-\n /* 4 data, and effectively 3 address registers is small as far as I'm\n    concerned.  */\n #define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true"}, {"sha": "82e20ad8a353eb8b25bf1d34453e58f096a2f380", "filename": "gcc/config/moxie/moxie.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmoxie%2Fmoxie.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmoxie%2Fmoxie.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fmoxie.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -183,10 +183,6 @@ enum reg_class\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)\t\t   \\\n    / UNITS_PER_WORD)\n \n-/* A C expression that is nonzero if a value of mode MODE1 is\n-   accessible in mode MODE2 without copying.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) 1\n-\n /* The Overall Framework of an Assembler File */\n \n #undef  ASM_SPEC"}, {"sha": "15e712294e5034768267463f8fdafaa0d0a00fec", "filename": "gcc/config/msp430/msp430-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -39,7 +39,6 @@ int\tmsp430_initial_elimination_offset (int, int);\n bool    msp430_is_interrupt_func (void);\n const char * msp430x_logical_shift_right (rtx);\n const char * msp430_mcu_name (void);\n-bool\tmsp430_modes_tieable_p (machine_mode, machine_mode);\n void    msp430_output_aligned_decl_common (FILE *, const tree, const char *, unsigned HOST_WIDE_INT, unsigned);\n void\tmsp430_output_labelref (FILE *, const char *);\n void\tmsp430_register_pragmas (void);"}, {"sha": "dd5f3604a1373fc3dd0c36fd423c9609dfd6078f", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -943,8 +943,10 @@ msp430_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n \t\t   - (unsigned int) msp430_hard_regno_nregs (regno, mode));\n }\n \n-/* Implements MODES_TIEABLE_P.  */\n-bool\n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P msp430_modes_tieable_p\n+\n+static bool\n msp430_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n   if ((mode1 == PSImode || mode2 == SImode)"}, {"sha": "16070f03f593468a78668676866e0399d5eb32e8", "filename": "gcc/config/msp430/msp430.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -334,9 +334,6 @@ typedef struct\n \f\n #define HARD_REGNO_NREGS(REGNO, MODE)            \\\n   msp430_hard_regno_nregs (REGNO, MODE)\n-\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\\\n-  msp430_modes_tieable_p (MODE1, MODE2)\n \f\n /* Exception Handling */\n "}, {"sha": "315b70c6d127617379b321489c3d02851e12cfe5", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -2768,6 +2768,21 @@ nds32_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n \n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK nds32_hard_regno_mode_ok\n+\n+/* Implement TARGET_MODES_TIEABLE_P.  We can use general registers to\n+   tie QI/HI/SI modes together.  */\n+\n+static bool\n+nds32_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return (GET_MODE_CLASS (mode1) == MODE_INT\n+\t  && GET_MODE_CLASS (mode2) == MODE_INT\n+\t  && GET_MODE_SIZE (mode1) <= UNITS_PER_WORD\n+\t  && GET_MODE_SIZE (mode2) <= UNITS_PER_WORD);\n+}\n+\n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P nds32_modes_tieable_p\n \f\n /* Register Classes.  */\n "}, {"sha": "5a7595dc83c0e89248a1bc9f78e8a53d93d75691", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -600,17 +600,6 @@ enum nds32_builtins\n    reg \"regno\" for holding a value of mode \"mode\".  */\n #define HARD_REGNO_NREGS(regno, mode) nds32_hard_regno_nregs (regno, mode)\n \n-/* A C expression that is nonzero if a value of mode1\n-   is accessible in mode2 without copying.\n-   Define this macro to return nonzero in as many cases as possible\n-   since doing so will allow GCC to perform better register allocation.\n-   We can use general registers to tie QI/HI/SI modes together.  */\n-#define MODES_TIEABLE_P(mode1, mode2)          \\\n-  (GET_MODE_CLASS (mode1) == MODE_INT          \\\n-   && GET_MODE_CLASS (mode2) == MODE_INT       \\\n-   && GET_MODE_SIZE (mode1) <= UNITS_PER_WORD  \\\n-   && GET_MODE_SIZE (mode2) <= UNITS_PER_WORD)\n-\n \f\n /* Register Classes.  */\n "}, {"sha": "04c78b7ba2efa0b36e269570b81939e5ab8d001e", "filename": "gcc/config/nios2/nios2.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fnios2%2Fnios2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fnios2%2Fnios2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -172,7 +172,6 @@\n /*  30 */  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,     \\\n   }\n \n-#define MODES_TIEABLE_P(MODE1, MODE2) 1\n #define HARD_REGNO_NREGS(REGNO, MODE)            \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n "}, {"sha": "b4e2c052fc62f4552c786fa11b8cae68ab8504c8", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -5513,6 +5513,14 @@ nvptx_data_alignment (const_tree type, unsigned int basic_align)\n   return basic_align;\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+nvptx_modes_tieable_p (machine_mode, machine_mode)\n+{\n+  return false;\n+}\n+\n #undef TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE nvptx_option_override\n \n@@ -5637,6 +5645,9 @@ nvptx_data_alignment (const_tree type, unsigned int basic_align)\n #define TARGET_VECTORIZE_PREFERRED_SIMD_MODE \\\n     nvptx_preferred_simd_mode\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P nvptx_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-nvptx.h\""}, {"sha": "8258bfdecd95f40c97be44bed5de42f81364a86f", "filename": "gcc/config/nvptx/nvptx.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -117,8 +117,6 @@ enum reg_class             {  NO_REGS,    ALL_REGS,\tLIM_REG_CLASSES };\n #define CLASS_MAX_NREGS(class, mode) \\\n   ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-#define MODES_TIEABLE_P(M1, M2) false\n-\n #define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\t\\\n   if ((MODE) == QImode || (MODE) == HImode)\t\t\\\n     {\t\t\t\t\t\t\t\\"}, {"sha": "3d128341d6bf50c06be6bd1feecc309a5e84541d", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -114,7 +114,6 @@ extern void pa_asm_output_aligned_local (FILE *, const char *,\n extern void pa_hpux_asm_output_external (FILE *, tree, const char *);\n extern bool pa_cannot_change_mode_class (machine_mode, machine_mode,\n \t\t\t\t\t enum reg_class);\n-extern bool pa_modes_tieable_p (machine_mode, machine_mode);\n extern HOST_WIDE_INT pa_initial_elimination_offset (int, int);\n \n extern const int pa_magic_milli[];"}, {"sha": "0c49cf0c0c4d48ba8e2a0ba85c79d4ef72cfcdb1", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -199,6 +199,7 @@ static bool pa_legitimate_address_p (machine_mode, rtx, bool);\n static bool pa_callee_copies (cumulative_args_t, machine_mode,\n \t\t\t      const_tree, bool);\n static bool pa_hard_regno_mode_ok (unsigned int, machine_mode);\n+static bool pa_modes_tieable_p (machine_mode, machine_mode);\n \n /* The following extra sections are only used for SOM.  */\n static GTY(()) section *som_readonly_data_section;\n@@ -407,6 +408,8 @@ static size_t n_deferred_plabels = 0;\n \n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK pa_hard_regno_mode_ok\n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P pa_modes_tieable_p\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n@@ -10012,10 +10015,7 @@ pa_cannot_change_mode_class (machine_mode from, machine_mode to,\n   return false;\n }\n \n-/* Returns TRUE if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n-   and MODE2, for any hard reg, then this must be FALSE for correct output.\n+/* Implement TARGET_MODES_TIEABLE_P.\n    \n    We should return FALSE for QImode and HImode because these modes\n    are not ok in the floating-point registers.  However, this prevents\n@@ -10024,7 +10024,7 @@ pa_cannot_change_mode_class (machine_mode from, machine_mode to,\n    CANNOT_CHANGE_MODE_CLASS to prevent these modes from being used\n    in the floating-point registers.  */\n \n-bool\n+static bool\n pa_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n   /* Don't tie modes in different classes.  */"}, {"sha": "513051c0c8409dfdc82b7a8fb27eb6920bc1621f", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -324,13 +324,6 @@ typedef struct GTY(()) machine_function\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 1\n \n-/* Value is 1 if it is a good idea to tie two pseudo registers when one\n-   has mode MODE1 and one has mode MODE2.\n-   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n-   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  pa_modes_tieable_p (MODE1, MODE2)\n-\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n "}, {"sha": "eb21066964f456d5da7ef8d1846cdc756ec1c7c9", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -238,6 +238,9 @@ static bool pdp11_scalar_mode_supported_p (scalar_mode);\n \n #undef  TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK pdp11_hard_regno_mode_ok\n+\n+#undef  TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P pdp11_modes_tieable_p\n \f\n /* A helper function to determine if REGNO should be saved in the\n    current function's stack frame.  */\n@@ -1947,4 +1950,12 @@ pdp11_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return FLOAT_MODE_P (mode);\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+pdp11_modes_tieable_p (machine_mode, machine_mode)\n+{\n+  return false;\n+}\n+\n struct gcc_target targetm = TARGET_INITIALIZER;"}, {"sha": "43a47e60861369ebe68ff944733a672d93ef238e", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -176,12 +176,6 @@ extern const struct real_format pdp11_d_format;\n     :1)\n     \n \n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n-   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) 0\n-\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n "}, {"sha": "0b220361a581489e3c27176c7f11af762cdb224a", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -1976,6 +1976,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK rs6000_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P rs6000_modes_tieable_p\n+\n #undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n #define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n   rs6000_hard_regno_call_part_clobbered\n@@ -2172,6 +2175,46 @@ rs6000_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return rs6000_hard_regno_mode_ok_p[mode][regno];\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.\n+\n+   PTImode cannot tie with other modes because PTImode is restricted to even\n+   GPR registers, and TImode can go in any GPR as well as VSX registers (PR\n+   57744).\n+\n+   Altivec/VSX vector tests were moved ahead of scalar float mode, so that IEEE\n+   128-bit floating point on VSX systems ties with other vectors.  */\n+\n+static bool\n+rs6000_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  if (mode1 == PTImode)\n+    return mode2 == PTImode;\n+  if (mode2 == PTImode)\n+    return false;\n+\n+  if (ALTIVEC_OR_VSX_VECTOR_MODE (mode1))\n+    return ALTIVEC_OR_VSX_VECTOR_MODE (mode2);\n+  if (ALTIVEC_OR_VSX_VECTOR_MODE (mode2))\n+    return false;\n+\n+  if (SCALAR_FLOAT_MODE_P (mode1))\n+    return SCALAR_FLOAT_MODE_P (mode2);\n+  if (SCALAR_FLOAT_MODE_P (mode2))\n+    return false;\n+\n+  if (GET_MODE_CLASS (mode1) == MODE_CC)\n+    return GET_MODE_CLASS (mode2) == MODE_CC;\n+  if (GET_MODE_CLASS (mode2) == MODE_CC)\n+    return false;\n+\n+  if (SPE_VECTOR_MODE (mode1))\n+    return SPE_VECTOR_MODE (mode2);\n+  if (SPE_VECTOR_MODE (mode2))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  */\n \n static bool\n@@ -2648,7 +2691,7 @@ rs6000_debug_reg_global (void)\n       for (m2 = 0; m2 < ARRAY_SIZE (print_tieable_modes); m2++)\n \t{\n \t  machine_mode mode2 = print_tieable_modes[m2];\n-\t  if (mode1 != mode2 && MODES_TIEABLE_P (mode1, mode2))\n+\t  if (mode1 != mode2 && rs6000_modes_tieable_p (mode1, mode2))\n \t    {\n \t      if (first_time)\n \t\t{"}, {"sha": "c008b5f6a7caa43385d109b451533c76246b7595", "filename": "gcc/config/powerpcspe/powerpcspe.h", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -1330,40 +1330,6 @@ enum data_align { align_abi, align_opt, align_both };\n #define PAIRED_VECTOR_MODE(MODE)        \\\n          ((MODE) == V2SFmode)            \n \n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n-   and MODE2, for any hard reg, then this must be 0 for correct output.\n-\n-   PTImode cannot tie with other modes because PTImode is restricted to even\n-   GPR registers, and TImode can go in any GPR as well as VSX registers (PR\n-   57744).\n-\n-   Altivec/VSX vector tests were moved ahead of scalar float mode, so that IEEE\n-   128-bit floating point on VSX systems ties with other vectors.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\\\n-  ((MODE1) == PTImode\t\t\t\t\\\n-   ? (MODE2) == PTImode\t\t\t\t\\\n-   : (MODE2) == PTImode\t\t\t\t\\\n-   ? 0\t\t\t\t\t\t\\\n-   : ALTIVEC_OR_VSX_VECTOR_MODE (MODE1)\t\t\\\n-   ? ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)\t\t\\\n-   : ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)\t\t\\\n-   ? 0\t\t\t\t\t\t\\\n-   : SCALAR_FLOAT_MODE_P (MODE1)\t\t\\\n-   ? SCALAR_FLOAT_MODE_P (MODE2)\t\t\\\n-   : SCALAR_FLOAT_MODE_P (MODE2)\t\t\\\n-   ? 0\t\t\t\t\t\t\\\n-   : GET_MODE_CLASS (MODE1) == MODE_CC\t\t\\\n-   ? GET_MODE_CLASS (MODE2) == MODE_CC\t\t\\\n-   : GET_MODE_CLASS (MODE2) == MODE_CC\t\t\\\n-   ? 0\t\t\t\t\t\t\\\n-   : SPE_VECTOR_MODE (MODE1)\t\t\t\\\n-   ? SPE_VECTOR_MODE (MODE2)\t\t\t\\\n-   : SPE_VECTOR_MODE (MODE2)\t\t\t\\\n-   ? 0\t\t\t\t\t\t\\\n-   : 1)\n-\n /* Post-reload, we can't use any new AltiVec registers, as we already\n    emitted the vrsave mask.  */\n "}, {"sha": "78dd79e58057a7beb34fee3caa81b6ba939efcf9", "filename": "gcc/config/powerpcspe/powerpcspe.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.md?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -4834,9 +4834,9 @@\n  [(set_attr \"length\" \"8,8,4\")\n   (set_attr \"type\" \"mftgpr,load,integer\")])\n \n-;; MODES_TIEABLE_P doesn't allow DImode to be tied with the various floating\n-;; point types, which makes normal SUBREG's problematical. Instead use a\n-;; special pattern to avoid using a normal movdi.\n+;; TARGET_MODES_TIEABLE_P doesn't allow DImode to be tied with the various\n+;; floating point types, which makes normal SUBREG's problematical.  Instead\n+;; use a special pattern to avoid using a normal movdi.\n (define_insn \"signbit<mode>2_dm2\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(unspec:DI [(match_operand:SIGNBIT 1 \"gpc_reg_operand\" \"wa\")"}, {"sha": "62472e934ffe1ff47a9f45935f4586a940dfa574", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -3558,6 +3558,19 @@ riscv_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return true;\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.\n+\n+   Don't allow floating-point modes to be tied, since type punning of\n+   single-precision and double-precision is implementation defined.  */\n+\n+static bool\n+riscv_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return (mode1 == mode2\n+\t  || !(GET_MODE_CLASS (mode1) == MODE_FLOAT\n+\t       && GET_MODE_CLASS (mode2) == MODE_FLOAT));\n+}\n+\n /* Implement HARD_REGNO_NREGS.  */\n \n unsigned int\n@@ -4086,6 +4099,9 @@ riscv_cannot_copy_insn_p (rtx_insn *insn)\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK riscv_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P riscv_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-riscv.h\""}, {"sha": "c0cf8c37b86436d18f5a05f307a38f01b1ed9e33", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -296,13 +296,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #define HARD_REGNO_NREGS(REGNO, MODE) riscv_hard_regno_nregs (REGNO, MODE)\n \n-/* Don't allow floating-point modes to be tied, since type punning of\n-   single-precision and double-precision is implementation defined.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n-  ((MODE1) == (MODE2)\t\t\t\t\t\\\n-   || !(GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\\\n-\t&& GET_MODE_CLASS (MODE2) == MODE_FLOAT))\n-\n /* Use s0 as the frame pointer if it is so requested.  */\n #define HARD_FRAME_POINTER_REGNUM 8\n #define STACK_POINTER_REGNUM 2"}, {"sha": "9573335d7f8484655c1c25ad7dd4a615453c68ae", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -491,6 +491,18 @@ rl78_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return false;\n }\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P rl78_modes_tieable_p\n+\n+static bool\n+rl78_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return ((GET_MODE_CLASS (mode1) == MODE_FLOAT\n+\t   || GET_MODE_CLASS (mode1) == MODE_COMPLEX_FLOAT)\n+\t  == (GET_MODE_CLASS (mode2) == MODE_FLOAT\n+\t      || GET_MODE_CLASS (mode2) == MODE_COMPLEX_FLOAT));\n+}\n+\n /* Simplify_gen_subreg() doesn't handle memory references the way we\n    need it to below, so we use this function for when we must get a\n    valid subreg in a \"natural\" state.  */"}, {"sha": "83f11e648faf55ebd3d30ed4d0e736334d180141", "filename": "gcc/config/rl78/rl78.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Frl78%2Frl78.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Frl78%2Frl78.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -409,12 +409,6 @@ typedef unsigned int CUMULATIVE_ARGS;\n \n #define HARD_REGNO_NREGS(REGNO, MODE)            \\\n   rl78_hard_regno_nregs (REGNO, MODE)\n-\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\\\n-  (   (   GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\t\\\n-       || GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\\\n-   == (   GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\t\t\\\n-       || GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n \f\n \n #define TEXT_SECTION_ASM_OP \".text\""}, {"sha": "09c7f133e42276734aa9748b7009278dcc5c4ab6", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -1966,6 +1966,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK rs6000_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P rs6000_modes_tieable_p\n+\n #undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n #define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\\n   rs6000_hard_regno_call_part_clobbered\n@@ -2139,6 +2142,46 @@ rs6000_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return rs6000_hard_regno_mode_ok_p[mode][regno];\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.\n+\n+   PTImode cannot tie with other modes because PTImode is restricted to even\n+   GPR registers, and TImode can go in any GPR as well as VSX registers (PR\n+   57744).\n+\n+   Altivec/VSX vector tests were moved ahead of scalar float mode, so that IEEE\n+   128-bit floating point on VSX systems ties with other vectors.  */\n+\n+static bool\n+rs6000_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  if (mode1 == PTImode)\n+    return mode2 == PTImode;\n+  if (mode2 == PTImode)\n+    return false;\n+\n+  if (ALTIVEC_OR_VSX_VECTOR_MODE (mode1))\n+    return ALTIVEC_OR_VSX_VECTOR_MODE (mode2);\n+  if (ALTIVEC_OR_VSX_VECTOR_MODE (mode2))\n+    return false;\n+\n+  if (SCALAR_FLOAT_MODE_P (mode1))\n+    return SCALAR_FLOAT_MODE_P (mode2);\n+  if (SCALAR_FLOAT_MODE_P (mode2))\n+    return false;\n+\n+  if (GET_MODE_CLASS (mode1) == MODE_CC)\n+    return GET_MODE_CLASS (mode2) == MODE_CC;\n+  if (GET_MODE_CLASS (mode2) == MODE_CC)\n+    return false;\n+\n+  if (PAIRED_VECTOR_MODE (mode1))\n+    return PAIRED_VECTOR_MODE (mode2);\n+  if (PAIRED_VECTOR_MODE (mode2))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  */\n \n static bool\n@@ -2610,7 +2653,7 @@ rs6000_debug_reg_global (void)\n       for (m2 = 0; m2 < ARRAY_SIZE (print_tieable_modes); m2++)\n \t{\n \t  machine_mode mode2 = print_tieable_modes[m2];\n-\t  if (mode1 != mode2 && MODES_TIEABLE_P (mode1, mode2))\n+\t  if (mode1 != mode2 && rs6000_modes_tieable_p (mode1, mode2))\n \t    {\n \t      if (first_time)\n \t\t{"}, {"sha": "a462da76968a2a01b09b9297824d9cf8d789ab3d", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -1258,40 +1258,6 @@ enum data_align { align_abi, align_opt, align_both };\n #define PAIRED_VECTOR_MODE(MODE)        \\\n          ((MODE) == V2SFmode)            \n \n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n-   and MODE2, for any hard reg, then this must be 0 for correct output.\n-\n-   PTImode cannot tie with other modes because PTImode is restricted to even\n-   GPR registers, and TImode can go in any GPR as well as VSX registers (PR\n-   57744).\n-\n-   Altivec/VSX vector tests were moved ahead of scalar float mode, so that IEEE\n-   128-bit floating point on VSX systems ties with other vectors.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\\\n-  ((MODE1) == PTImode\t\t\t\t\\\n-   ? (MODE2) == PTImode\t\t\t\t\\\n-   : (MODE2) == PTImode\t\t\t\t\\\n-   ? 0\t\t\t\t\t\t\\\n-   : ALTIVEC_OR_VSX_VECTOR_MODE (MODE1)\t\t\\\n-   ? ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)\t\t\\\n-   : ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)\t\t\\\n-   ? 0\t\t\t\t\t\t\\\n-   : SCALAR_FLOAT_MODE_P (MODE1)\t\t\\\n-   ? SCALAR_FLOAT_MODE_P (MODE2)\t\t\\\n-   : SCALAR_FLOAT_MODE_P (MODE2)\t\t\\\n-   ? 0\t\t\t\t\t\t\\\n-   : GET_MODE_CLASS (MODE1) == MODE_CC\t\t\\\n-   ? GET_MODE_CLASS (MODE2) == MODE_CC\t\t\\\n-   : GET_MODE_CLASS (MODE2) == MODE_CC\t\t\\\n-   ? 0\t\t\t\t\t\t\\\n-   : PAIRED_VECTOR_MODE (MODE1)\t\t\t\\\n-   ? PAIRED_VECTOR_MODE (MODE2)\t\t\t\\\n-   : PAIRED_VECTOR_MODE (MODE2)\t\t\t\\\n-   ? 0\t\t\t\t\t\t\\\n-   : 1)\n-\n /* Post-reload, we can't use any new AltiVec registers, as we already\n    emitted the vrsave mask.  */\n "}, {"sha": "20873ac4250bfbd85cf1abc025dceff9297afe48", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -4806,9 +4806,9 @@\n  [(set_attr \"length\" \"8,8,4\")\n   (set_attr \"type\" \"mftgpr,load,integer\")])\n \n-;; MODES_TIEABLE_P doesn't allow DImode to be tied with the various floating\n-;; point types, which makes normal SUBREG's problematical. Instead use a\n-;; special pattern to avoid using a normal movdi.\n+;; TARGET_MODES_TIEABLE_P doesn't allow DImode to be tied with the various\n+;; floating point types, which makes normal SUBREG's problematical.  Instead\n+;; use a special pattern to avoid using a normal movdi.\n (define_insn \"signbit<mode>2_dm2\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(unspec:DI [(match_operand:SIGNBIT 1 \"gpc_reg_operand\" \"wa\")"}, {"sha": "97f2153d2e29ab2ae2ed38dde8026d8c5a77e520", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -3441,6 +3441,17 @@ rx_hard_regno_mode_ok (unsigned int regno, machine_mode)\n {\n   return REGNO_REG_CLASS (regno) == GR_REGS;\n }\n+\n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+rx_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return ((GET_MODE_CLASS (mode1) == MODE_FLOAT\n+\t   || GET_MODE_CLASS (mode1) == MODE_COMPLEX_FLOAT)\n+\t  == (GET_MODE_CLASS (mode2) == MODE_FLOAT\n+\t      || GET_MODE_CLASS (mode2) == MODE_COMPLEX_FLOAT));\n+}\n \f\n #undef  TARGET_NARROW_VOLATILE_BITFIELD\n #define TARGET_NARROW_VOLATILE_BITFIELD\t\trx_narrow_volatile_bitfield\n@@ -3598,6 +3609,9 @@ rx_hard_regno_mode_ok (unsigned int regno, machine_mode)\n #undef  TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK\t\trx_hard_regno_mode_ok\n \n+#undef  TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P\t\t\trx_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-rx.h\""}, {"sha": "29d70c34882806ad85b050cb847806233b547f2d", "filename": "gcc/config/rx/rx.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Frx%2Frx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Frx%2Frx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -333,11 +333,6 @@ typedef unsigned int CUMULATIVE_ARGS;\n \n #define HARD_REGNO_NREGS(REGNO, MODE)   CLASS_MAX_NREGS (0, MODE)\n \n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\\\n-  (   (   GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\t\\\n-       || GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\\\n-   == (   GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\t\t\\\n-       || GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n \f\n \n #define REGISTER_NAMES\t\t\t\t\t\t\\"}, {"sha": "fa45c1927ea9f0ad986049d38cad2b7d51b9c96e", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -10453,6 +10453,15 @@ s390_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return false;\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+s390_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return ((mode1 == SFmode || mode1 == DFmode)\n+\t  == (mode2 == SFmode || mode2 == DFmode));\n+}\n+\n /* Return nonzero if register OLD_REG can be renamed to register NEW_REG.  */\n \n bool\n@@ -15965,6 +15974,8 @@ s390_asan_shadow_offset (void)\n \n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK s390_hard_regno_mode_ok\n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P s390_modes_tieable_p\n \n #undef TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n #define TARGET_HARD_REGNO_CALL_PART_CLOBBERED \\"}, {"sha": "f9df2efbd57f9cfcac3a27bece9a32090049fe2a", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -502,10 +502,6 @@ extern const char *s390_host_detect_local_cpu (int argc, const char **argv);\n #define HARD_REGNO_RENAME_OK(FROM, TO)          \\\n   s390_hard_regno_rename_ok ((FROM), (TO))\n \n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\\\n-   (((MODE1) == SFmode || (MODE1) == DFmode)\t\\\n-   == ((MODE2) == SFmode || (MODE2) == DFmode))\n-\n /* Maximum number of registers to represent a value of mode MODE\n    in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)   \t\t\t\t\t\\"}, {"sha": "22d1bf7680225078a6f8182d4c919024109808e5", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -322,6 +322,7 @@ static bool sh_fixed_condition_code_regs (unsigned int* p1, unsigned int* p2);\n \n static void sh_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;\n static bool sh_hard_regno_mode_ok (unsigned int, machine_mode);\n+static bool sh_modes_tieable_p (machine_mode, machine_mode);\n \f\n static const struct attribute_spec sh_attribute_table[] =\n {\n@@ -645,6 +646,9 @@ static const struct attribute_spec sh_attribute_table[] =\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK sh_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P sh_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n \n@@ -10573,6 +10577,22 @@ sh_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return true;\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.\n+\n+   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n+   and MODE2, for any hard reg, then this must be false for correct output.\n+   That's the case for xd registers: we don't hold SFmode values in\n+   them, so we can't tie an SFmode pseudos with one in another\n+   floating-point mode.  */\n+\n+static bool\n+sh_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return (mode1 == mode2\n+\t  || (GET_MODE_CLASS (mode1) == GET_MODE_CLASS (mode2)\n+\t      && (mode1 != SFmode && mode2 != SFmode)));\n+}\n+\n /* Specify the modes required to caller save a given hard regno.\n    choose_hard_reg_mode chooses mode based on TARGET_HARD_REGNO_MODE_OK\n    and returns ?Imode for float regs when sh_hard_regno_mode_ok"}, {"sha": "b9571968e17fa2448b3dee8f218428f9b7558718", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -823,18 +823,6 @@ extern char sh_additional_register_names[ADDREGNAMES_SIZE] \\\n     ? ((GET_MODE_SIZE (MODE) + (2*UNITS_PER_WORD - 1)) / (2*UNITS_PER_WORD)) \\\n     : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n-   and MODE2, for any hard reg, then this must be 0 for correct output.\n-   That's the case for xd registers: we don't hold SFmode values in\n-   them, so we can't tie an SFmode pseudos with one in another\n-   floating-point mode.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  ((MODE1) == (MODE2) \\\n-   || (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2) \\\n-       && (((MODE1) != SFmode && (MODE2) != SFmode))))\n-\n /* Specify the modes required to caller save a given hard regno.  */\n #define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE)\t\\\n   sh_hard_regno_caller_save_mode ((REGNO), (NREGS), (MODE))"}, {"sha": "311688faf7e6abe42ad3848e997a9990bbdd6f90", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -111,7 +111,6 @@ extern void sparc_expand_vec_perm_bmask(machine_mode, rtx);\n extern bool sparc_expand_conditional_move (machine_mode, rtx *);\n extern void sparc_expand_vcond (machine_mode, rtx *, int, int);\n unsigned int sparc_regmode_natural_size (machine_mode);\n-bool sparc_modes_tieable_p (machine_mode, machine_mode);\n #endif /* RTX_CODE */\n \n extern rtl_opt_pass *make_pass_work_around_errata (gcc::context *);"}, {"sha": "23584124158b1fcb2f7c96b0f440a6f9a6dce44e", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -676,6 +676,7 @@ static void sparc_atomic_assign_expand_fenv (tree *, tree *, tree *);\n static bool sparc_fixed_condition_code_regs (unsigned int *, unsigned int *);\n static unsigned int sparc_min_arithmetic_precision (void);\n static bool sparc_hard_regno_mode_ok (unsigned int, machine_mode);\n+static bool sparc_modes_tieable_p (machine_mode, machine_mode);\n \n \f\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n@@ -904,6 +905,9 @@ char sparc_hard_reg_printed[8];\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK sparc_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P sparc_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Return the memory reference contained in X if any, zero otherwise.  */\n@@ -13139,15 +13143,12 @@ sparc_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return (hard_regno_mode_classes[regno] & sparc_mode_class[mode]) != 0;\n }\n \n-/* Return TRUE if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n-   and MODE2, for any hard reg, then this must be FALSE for correct output.\n+/* Implement TARGET_MODES_TIEABLE_P.\n \n    For V9 we have to deal with the fact that only the lower 32 floating\n    point registers are 32-bit addressable.  */\n \n-bool\n+static bool\n sparc_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n   enum mode_class mclass1, mclass2;"}, {"sha": "1aa46d33b66c64ab3dd05c531707f2a4a1f43369", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -773,8 +773,6 @@ extern enum cmodel sparc_cmodel;\n    register window instruction in the prologue.  */\n #define HARD_REGNO_RENAME_OK(FROM, TO) ((FROM) != 1)\n \n-#define MODES_TIEABLE_P(MODE1, MODE2) sparc_modes_tieable_p (MODE1, MODE2)\n-\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n "}, {"sha": "9d9b103ea0d189da3feca9ce5f4d03e2f163c271", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -7138,6 +7138,14 @@ spu_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n     emit_move_insn (orig_after, after);\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+spu_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return (GET_MODE_BITSIZE (mode1) <= MAX_FIXED_MODE_SIZE\n+\t  && GET_MODE_BITSIZE (mode2) <= MAX_FIXED_MODE_SIZE);\n+}\n \f\n /*  Table of machine attributes.  */\n static const struct attribute_spec spu_attribute_table[] =\n@@ -7360,6 +7368,9 @@ static const struct attribute_spec spu_attribute_table[] =\n #undef TARGET_CAN_USE_DOLOOP_P\n #define TARGET_CAN_USE_DOLOOP_P can_use_doloop_if_innermost\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P spu_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-spu.h\""}, {"sha": "d5d43529dc74b010676da69f7f9c62a8988f84f3", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -176,10 +176,6 @@ extern GTY(()) int spu_tune;\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n     ((GET_MODE_BITSIZE(MODE)+MAX_FIXED_MODE_SIZE-1)/MAX_FIXED_MODE_SIZE)\n \n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  (GET_MODE_BITSIZE (MODE1) <= MAX_FIXED_MODE_SIZE \\\n-   && GET_MODE_BITSIZE (MODE2) <= MAX_FIXED_MODE_SIZE)\n-\n \f\n /* Register Classes */\n "}, {"sha": "89f474eba8476eea961f4f915face7401537e653", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -2625,6 +2625,14 @@ xstormy16_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   return regno != 16 || mode == BImode;\n }\n+\n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+xstormy16_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return mode1 != BImode && mode2 != BImode;\n+}\n \f\n #undef  TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n@@ -2704,6 +2712,8 @@ xstormy16_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n \n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK xstormy16_hard_regno_mode_ok\n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P xstormy16_modes_tieable_p\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "6e43fbe59c46cea37a78475f8189158f3cbdf3a9", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -145,15 +145,6 @@\n #define HARD_REGNO_NREGS(REGNO, MODE) \t\t\t\t\\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* A C expression that is nonzero if it is desirable to choose register\n-   allocation so as to avoid move instructions between a value of mode MODE1\n-   and a value of mode MODE2.\n-\n-   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n-   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are ever different for any R,\n-   then `MODES_TIEABLE_P (MODE1, MODE2)' must be zero.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) ((MODE1) != BImode && (MODE2) != BImode)\n-\n \f\n /* Register Classes.  */\n "}, {"sha": "66cbd0dc9e500bdf6d5ce5c9ff2baa476f920153", "filename": "gcc/config/tilegx/tilegx.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Ftilegx%2Ftilegx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -162,8 +162,6 @@\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-#define MODES_TIEABLE_P(MODE1, MODE2)  1\n-\n /* Register that holds an address into the text segment that can be\n    used by pic code.  */\n #define TILEGX_PIC_TEXT_LABEL_REGNUM (flag_pic ? 50 : INVALID_REGNUM)"}, {"sha": "599a7d8cc89e0f841d902765f1aac71e6f0e72de", "filename": "gcc/config/tilepro/tilepro.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Ftilepro%2Ftilepro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Ftilepro%2Ftilepro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -127,8 +127,6 @@\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-#define MODES_TIEABLE_P(MODE1, MODE2)  1\n-\n /* Register that holds an address into the text segment that can be\n    used by pic code.  */\n #define TILEPRO_PIC_TEXT_LABEL_REGNUM (flag_pic ? 50 : INVALID_REGNUM)"}, {"sha": "0b674d14e786bfc459b19a74c0ee7500111d466f", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -3255,6 +3255,15 @@ v850_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n {\n   return GET_MODE_SIZE (mode) <= 4 || ((regno & 1) == 0 && regno != 0);\n }\n+\n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+v850_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return (mode1 == mode2\n+\t  || (GET_MODE_SIZE (mode1) <= 4 && GET_MODE_SIZE (mode2) <= 4));\n+}\n \f\n /* Initialize the GCC target structure.  */\n \n@@ -3363,6 +3372,9 @@ v850_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n #undef  TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK v850_hard_regno_mode_ok\n \n+#undef  TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P v850_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-v850.h\""}, {"sha": "6ba85ef872d4737a73d19dd48570e1b12de25acd", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -300,13 +300,6 @@ extern GTY(()) rtx v850_compare_op1;\n #define HARD_REGNO_NREGS(REGNO, MODE)   \\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n-   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  (MODE1 == MODE2 || (GET_MODE_SIZE (MODE1) <= 4 && GET_MODE_SIZE (MODE2) <= 4))\n-\n \f\n /* Define the classes of registers for register constraints in the\n    machine description.  Also define ranges of constants."}, {"sha": "ce519475227a48a2b1c6bb1215ef54438ef21662", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -143,12 +143,6 @@ along with GCC; see the file COPYING3.  If not see\n #define HARD_REGNO_NREGS(REGNO, MODE)\t\\\n   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n-   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)  1\n-\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n "}, {"sha": "5478d232ef1b82ec3fa3b4761fa8bc862a0b9195", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -230,6 +230,8 @@ static unsigned int visium_reorg (void);\n \n static bool visium_hard_regno_mode_ok (unsigned int, machine_mode);\n \n+static bool visium_modes_tieable_p (machine_mode, machine_mode);\n+\n /* Setup the global target hooks structure.  */\n \n #undef  TARGET_MAX_ANCHOR_OFFSET\n@@ -344,6 +346,9 @@ static bool visium_hard_regno_mode_ok (unsigned int, machine_mode);\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK visium_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P visium_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n namespace {\n@@ -861,6 +866,15 @@ visium_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n \t  && HARD_REGNO_NREGS (regno, mode) == 1);\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+visium_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return (GET_MODE_CLASS (mode1) == MODE_INT\n+\t  && GET_MODE_CLASS (mode2) == MODE_INT);\n+}\n+\n /* Return true if it is ok to do sibling call optimization for the specified\n    call expression EXP.  DECL will be the called function, or NULL if this\n    is an indirect call.  */"}, {"sha": "1612b95b2e5ed41cbd632dd995bb13e92ccf9805", "filename": "gcc/config/visium/visium.h", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fvisium%2Fvisium.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fvisium%2Fvisium.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -573,25 +573,6 @@\n #define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG) \\\n   visium_hard_regno_rename_ok (OLD_REG, NEW_REG)\n \n-/* `MODES_TIEABLE_P (MODE1, MODE2)'\n-\n-   A C expression that is nonzero if a value of mode MODE1 is\n-   accessible in mode MODE2 without copying.\n-\n-   If `TARGET_HARD_REGNO_MODE_OK (R, MODE1)' and\n-   `TARGET_HARD_REGNO_MODE_OK (R, MODE2)' are always the same for any R,\n-   then `MODES_TIEABLE_P (MODE1, MODE2)' should be nonzero.  If they\n-   differ for any R, you should define this macro to return zero unless\n-   some other mechanism ensures the accessibility of the value in a\n-   narrower mode.\n-\n-   You should define this macro to return nonzero in as many cases as\n-   possible since doing so will allow GNU CC to perform better\n-   register allocation. */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  ((GET_MODE_CLASS (MODE1) == MODE_INT) \\\n-  && (GET_MODE_CLASS (MODE2) == MODE_INT))\n-\n /* Register Classes\n \n    On many machines, the numbered registers are not all equivalent.\n@@ -1271,7 +1252,7 @@ do\t\t\t\t\t\t\t\t\t\\\n    On many machines, this expression can be 1.\n \n    When `TRULY_NOOP_TRUNCATION' returns 1 for a pair of sizes for\n-   modes for which `MODES_TIEABLE_P' is 0, suboptimal code can result.\n+   modes for which `TARGET_MODES_TIEABLE_P' is 0, suboptimal code can result.\n    If this is the case, making `TRULY_NOOP_TRUNCATION' return 0 in\n    such cases may improve things. */\n #define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1"}, {"sha": "f7ce08478aa2e781eb7920d8bee463e20dd4269a", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -179,6 +179,7 @@ static bool xtensa_member_type_forces_blk (const_tree,\n \n static void xtensa_conditional_register_usage (void);\n static bool xtensa_hard_regno_mode_ok (unsigned int, machine_mode);\n+static bool xtensa_modes_tieable_p (machine_mode, machine_mode);\n \n \f\n \n@@ -310,6 +311,9 @@ static bool xtensa_hard_regno_mode_ok (unsigned int, machine_mode);\n #undef TARGET_HARD_REGNO_MODE_OK\n #define TARGET_HARD_REGNO_MODE_OK xtensa_hard_regno_mode_ok\n \n+#undef TARGET_MODES_TIEABLE_P\n+#define TARGET_MODES_TIEABLE_P xtensa_modes_tieable_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f\n@@ -2265,6 +2269,17 @@ xtensa_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n   return xtensa_hard_regno_mode_ok_p[mode][regno];\n }\n \n+/* Implement TARGET_MODES_TIEABLE_P.  */\n+\n+static bool\n+xtensa_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n+{\n+  return ((GET_MODE_CLASS (mode1) == MODE_FLOAT\n+\t   || GET_MODE_CLASS (mode1) == MODE_COMPLEX_FLOAT)\n+\t  == (GET_MODE_CLASS (mode2) == MODE_FLOAT\n+\t      || GET_MODE_CLASS (mode2) == MODE_COMPLEX_FLOAT));\n+}\n+\n /* A C compound statement to output to stdio stream STREAM the\n    assembler syntax for an instruction operand X.  X is an RTL\n    expression."}, {"sha": "63eb32ddaeac7cb3f4107200bfa2aaf0b29608d3", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -328,16 +328,6 @@ extern int leaf_function;\n \t((GET_MODE_SIZE (MODE) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG) : \\\n \t((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If TARGET_HARD_REGNO_MODE_OK could produce different values for MODE1\n-   and MODE2, for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n-  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT ||\t\t\t\t\\\n-    GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\t\\\n-   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT ||\t\t\t\t\\\n-       GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n-\n /* Register to use for pushing function arguments.  */\n #define STACK_POINTER_REGNUM (GP_REG_FIRST + 1)\n "}, {"sha": "6697ddd343c2b106618290ae26bf728b99c8ebed", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -2091,8 +2091,8 @@ all narrower integer modes, it is not necessary on any machine for\n this hook to distinguish between these modes, provided you define\n patterns @samp{movhi}, etc., to take advantage of this.  This is\n useful because of the interaction between @code{TARGET_HARD_REGNO_MODE_OK}\n-and @code{MODES_TIEABLE_P}; it is very desirable for all integer modes\n-to be tieable.\n+and @code{TARGET_MODES_TIEABLE_P}; it is very desirable for all integer\n+modes to be tieable.\n \n Many machines have special registers for floating point arithmetic.\n Often people assume that floating point machine modes are allowed only\n@@ -2135,21 +2135,22 @@ handler.\n The default is always nonzero.\n @end defmac\n \n-@defmac MODES_TIEABLE_P (@var{mode1}, @var{mode2})\n-A C expression that is nonzero if a value of mode\n-@var{mode1} is accessible in mode @var{mode2} without copying.\n+@deftypefn {Target Hook} bool TARGET_MODES_TIEABLE_P (machine_mode @var{mode1}, machine_mode @var{mode2})\n+This hook returns true if a value of mode @var{mode1} is accessible\n+in mode @var{mode2} without copying.\n \n If @code{TARGET_HARD_REGNO_MODE_OK (@var{r}, @var{mode1})} and\n-@code{TARGET_HARD_REGNO_MODE_OK (@var{r}, @var{mode2})} are always the same\n-for any @var{r}, then @code{MODES_TIEABLE_P (@var{mode1}, @var{mode2})}\n-should be nonzero.  If they differ for any @var{r}, you should define\n-this macro to return zero unless some other mechanism ensures the\n+@code{TARGET_HARD_REGNO_MODE_OK (@var{r}, @var{mode2})} are always\n+the same for any @var{r}, then\n+@code{TARGET_MODES_TIEABLE_P (@var{mode1}, @var{mode2})}\n+should be true.  If they differ for any @var{r}, you should define\n+this hook to return false unless some other mechanism ensures the\n accessibility of the value in a narrower mode.\n \n-You should define this macro to return nonzero in as many cases as\n+You should define this hook to return true in as many cases as\n possible since doing so will allow GCC to perform better register\n-allocation.\n-@end defmac\n+allocation.  The default definition returns true unconditionally.\n+@end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_HARD_REGNO_SCRATCH_OK (unsigned int @var{regno})\n This target hook should return @code{true} if it is OK to use a hard register\n@@ -10796,8 +10797,8 @@ On many machines, this expression can be 1.\n \n @c rearranged this, removed the phrase \"it is reported that\".  this was\n @c to fix an overfull hbox.  --mew 10feb93\n-When @code{TRULY_NOOP_TRUNCATION} returns 1 for a pair of sizes for\n-modes for which @code{MODES_TIEABLE_P} is 0, suboptimal code can result.\n+When @code{TRULY_NOOP_TRUNCATION} returns 1 for a pair of sizes for modes\n+for which @code{TARGET_MODES_TIEABLE_P} is false, suboptimal code can result.\n If this is the case, making @code{TRULY_NOOP_TRUNCATION} return 0 in\n such cases may improve things.\n @end defmac"}, {"sha": "274f79ed5a2b808909b03a9b1aa28c0a182ad3cf", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -1871,21 +1871,7 @@ handler.\n The default is always nonzero.\n @end defmac\n \n-@defmac MODES_TIEABLE_P (@var{mode1}, @var{mode2})\n-A C expression that is nonzero if a value of mode\n-@var{mode1} is accessible in mode @var{mode2} without copying.\n-\n-If @code{TARGET_HARD_REGNO_MODE_OK (@var{r}, @var{mode1})} and\n-@code{TARGET_HARD_REGNO_MODE_OK (@var{r}, @var{mode2})} are always the same\n-for any @var{r}, then @code{MODES_TIEABLE_P (@var{mode1}, @var{mode2})}\n-should be nonzero.  If they differ for any @var{r}, you should define\n-this macro to return zero unless some other mechanism ensures the\n-accessibility of the value in a narrower mode.\n-\n-You should define this macro to return nonzero in as many cases as\n-possible since doing so will allow GCC to perform better register\n-allocation.\n-@end defmac\n+@hook TARGET_MODES_TIEABLE_P\n \n @hook TARGET_HARD_REGNO_SCRATCH_OK\n \n@@ -7610,8 +7596,8 @@ On many machines, this expression can be 1.\n \n @c rearranged this, removed the phrase \"it is reported that\".  this was\n @c to fix an overfull hbox.  --mew 10feb93\n-When @code{TRULY_NOOP_TRUNCATION} returns 1 for a pair of sizes for\n-modes for which @code{MODES_TIEABLE_P} is 0, suboptimal code can result.\n+When @code{TRULY_NOOP_TRUNCATION} returns 1 for a pair of sizes for modes\n+for which @code{TARGET_MODES_TIEABLE_P} is false, suboptimal code can result.\n If this is the case, making @code{TRULY_NOOP_TRUNCATION} return 0 in\n such cases may improve things.\n @end defmac"}, {"sha": "cff3ac47356fb3feec39985a7c45f71398e3bb8c", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -1631,7 +1631,7 @@ find_shift_sequence (int access_size,\n       /* Also try a wider mode if the necessary punning is either not\n \t desirable or not possible.  */\n       if (!CONSTANT_P (store_info->rhs)\n-\t  && !MODES_TIEABLE_P (new_mode, store_mode))\n+\t  && !targetm.modes_tieable_p (new_mode, store_mode))\n \tcontinue;\n \n       new_reg = gen_reg_rtx (new_mode);"}, {"sha": "fa223165e906763631cd903fc54bba1cfe58c63f", "filename": "gcc/expmed.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -2272,7 +2272,7 @@ extract_low_bits (machine_mode mode, machine_mode src_mode, rtx src)\n     return NULL_RTX;\n \n   if (GET_MODE_BITSIZE (mode) == GET_MODE_BITSIZE (src_mode)\n-      && MODES_TIEABLE_P (mode, src_mode))\n+      && targetm.modes_tieable_p (mode, src_mode))\n     {\n       rtx x = gen_lowpart_common (mode, src);\n       if (x)\n@@ -2283,9 +2283,9 @@ extract_low_bits (machine_mode mode, machine_mode src_mode, rtx src)\n       || !int_mode_for_mode (mode).exists (&int_mode))\n     return NULL_RTX;\n \n-  if (!MODES_TIEABLE_P (src_int_mode, src_mode))\n+  if (!targetm.modes_tieable_p (src_int_mode, src_mode))\n     return NULL_RTX;\n-  if (!MODES_TIEABLE_P (int_mode, mode))\n+  if (!targetm.modes_tieable_p (int_mode, mode))\n     return NULL_RTX;\n \n   src = gen_lowpart (src_int_mode, src);"}, {"sha": "65b9fe5ce50a91f86da2f9f0bd933b1a7008cb08", "filename": "gcc/hooks.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -82,6 +82,13 @@ hook_bool_mode_true (machine_mode)\n   return true;\n }\n \n+/* Generic hook that takes (machine_mode, machine_mode) and returns true.  */\n+bool\n+hook_bool_mode_mode_true (machine_mode, machine_mode)\n+{\n+  return true;\n+}\n+\n /* Generic hook that takes (machine_mode, const_rtx) and returns false.  */\n bool\n hook_bool_mode_const_rtx_false (machine_mode, const_rtx)"}, {"sha": "06ffd27deb7cbf8b67f3803470e01a6b28d74e67", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -30,6 +30,7 @@ extern bool hook_bool_bool_gcc_optionsp_false (bool, struct gcc_options *);\n extern bool hook_bool_const_int_const_int_true (const int, const int);\n extern bool hook_bool_mode_false (machine_mode);\n extern bool hook_bool_mode_true (machine_mode);\n+extern bool hook_bool_mode_mode_true (machine_mode, machine_mode);\n extern bool hook_bool_mode_const_rtx_false (machine_mode, const_rtx);\n extern bool hook_bool_mode_const_rtx_true (machine_mode, const_rtx);\n extern bool hook_bool_mode_rtx_false (machine_mode, rtx);"}, {"sha": "e93dbd66e1f0b6c4aaf237671b20b679f46cbd9d", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"lower-subreg.h\"\n #include \"rtl-iter.h\"\n+#include \"target.h\"\n \n \n /* Decompose multi-word pseudo-registers into individual\n@@ -496,7 +497,7 @@ find_decomposable_subregs (rtx *loc, enum classify_move_insn *pcmi)\n \t     likely to mess up whatever the backend is trying to do.  */\n \t  if (outer_words > 1\n \t      && outer_size == inner_size\n-\t      && !MODES_TIEABLE_P (GET_MODE (x), GET_MODE (inner)))\n+\t      && !targetm.modes_tieable_p (GET_MODE (x), GET_MODE (inner)))\n \t    {\n \t      bitmap_set_bit (non_decomposable_context, regno);\n \t      bitmap_set_bit (subreg_context, regno);\n@@ -534,7 +535,7 @@ find_decomposable_subregs (rtx *loc, enum classify_move_insn *pcmi)\n \t\t  bitmap_set_bit (non_decomposable_context, regno);\n \t\t  break;\n \t\tcase DECOMPOSABLE_SIMPLE_MOVE:\n-\t\t  if (MODES_TIEABLE_P (GET_MODE (x), word_mode))\n+\t\t  if (targetm.modes_tieable_p (GET_MODE (x), word_mode))\n \t\t    bitmap_set_bit (decomposable_context, regno);\n \t\t  break;\n \t\tcase SIMPLE_MOVE:"}, {"sha": "9f0419c0f3c4ec814899a9d648bd55f68813325d", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -4181,12 +4181,12 @@ rtx_cost (rtx x, machine_mode mode, enum rtx_code outer_code,\n       total = 0;\n       /* If we can't tie these modes, make this expensive.  The larger\n \t the mode, the more expensive it is.  */\n-      if (! MODES_TIEABLE_P (mode, GET_MODE (SUBREG_REG (x))))\n+      if (!targetm.modes_tieable_p (mode, GET_MODE (SUBREG_REG (x))))\n \treturn COSTS_N_INSNS (2 + factor);\n       break;\n \n     case TRUNCATE:\n-      if (MODES_TIEABLE_P (mode, GET_MODE (XEXP (x, 0))))\n+      if (targetm.modes_tieable_p (mode, GET_MODE (XEXP (x, 0))))\n \t{\n \t  total = 0;\n \t  break;"}, {"sha": "1e6c17cfa57827aa003a105b850f24df09863021", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -911,7 +911,8 @@ extern void fancy_abort (const char *, int, const char *)\n \tLIBGCC2_HAS_DF_MODE LIBGCC2_HAS_XF_MODE LIBGCC2_HAS_TF_MODE\t\\\n \tCLEAR_BY_PIECES_P MOVE_BY_PIECES_P SET_BY_PIECES_P\t\t\\\n \tSTORE_BY_PIECES_P TARGET_FLT_EVAL_METHOD\t\t\t\\\n-\tHARD_REGNO_CALL_PART_CLOBBERED HARD_REGNO_MODE_OK\n+\tHARD_REGNO_CALL_PART_CLOBBERED HARD_REGNO_MODE_OK\t\t\\\n+\tMODES_TIEABLE_P\n \n /* Target macros only used for code built for the target, that have\n    moved to libgcc-tm.h or have never been present elsewhere.  */"}, {"sha": "b6bcb86a99553cca119ace3611b7b5877de5f1ff", "filename": "gcc/target.def", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e1629ff116e2e1aa37a14aa0d15b4533068927/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=99e1629ff116e2e1aa37a14aa0d15b4533068927", "patch": "@@ -5406,8 +5406,8 @@ all narrower integer modes, it is not necessary on any machine for\\n\\\n this hook to distinguish between these modes, provided you define\\n\\\n patterns @samp{movhi}, etc., to take advantage of this.  This is\\n\\\n useful because of the interaction between @code{TARGET_HARD_REGNO_MODE_OK}\\n\\\n-and @code{MODES_TIEABLE_P}; it is very desirable for all integer modes\\n\\\n-to be tieable.\\n\\\n+and @code{TARGET_MODES_TIEABLE_P}; it is very desirable for all integer\\n\\\n+modes to be tieable.\\n\\\n \\n\\\n Many machines have special registers for floating point arithmetic.\\n\\\n Often people assume that floating point machine modes are allowed only\\n\\\n@@ -5440,6 +5440,25 @@ be used unless some pattern's constraint asks for one.\",\n  bool, (unsigned int regno, machine_mode mode),\n  hook_bool_uint_mode_true)\n \n+DEFHOOK\n+(modes_tieable_p,\n+ \"This hook returns true if a value of mode @var{mode1} is accessible\\n\\\n+in mode @var{mode2} without copying.\\n\\\n+\\n\\\n+If @code{TARGET_HARD_REGNO_MODE_OK (@var{r}, @var{mode1})} and\\n\\\n+@code{TARGET_HARD_REGNO_MODE_OK (@var{r}, @var{mode2})} are always\\n\\\n+the same for any @var{r}, then\\n\\\n+@code{TARGET_MODES_TIEABLE_P (@var{mode1}, @var{mode2})}\\n\\\n+should be true.  If they differ for any @var{r}, you should define\\n\\\n+this hook to return false unless some other mechanism ensures the\\n\\\n+accessibility of the value in a narrower mode.\\n\\\n+\\n\\\n+You should define this hook to return true in as many cases as\\n\\\n+possible since doing so will allow GCC to perform better register\\n\\\n+allocation.  The default definition returns true unconditionally.\",\n+ bool, (machine_mode mode1, machine_mode mode2),\n+ hook_bool_mode_mode_true)\n+\n /* Return true if is OK to use a hard register REGNO as scratch register\n    in peephole2.  */\n DEFHOOK"}]}