{"sha": "3eae202fc732b048b853afe479bc5af4330ed10b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VhZTIwMmZjNzMyYjA0OGI4NTNhZmU0NzliYzVhZjQzMzBlZDEwYg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-11-12T23:15:13Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-11-12T23:15:13Z"}, "message": "tree-ssa-threadedge.c (thread_around_empty_blocks): New argument backedge_seen_p.\n\n\t* tree-ssa-threadedge.c (thread_around_empty_blocks): New\n\targument backedge_seen_p.  Set, use and pass it to children\n\tappropriately.\n\t(thread_through_normal_block): Similarly.\n\t(thread_across_edge): Similarly.\n\nFrom-SVN: r204724", "tree": {"sha": "d0f17683b7bb08936365d656be288796c7a60438", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0f17683b7bb08936365d656be288796c7a60438"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3eae202fc732b048b853afe479bc5af4330ed10b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eae202fc732b048b853afe479bc5af4330ed10b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eae202fc732b048b853afe479bc5af4330ed10b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eae202fc732b048b853afe479bc5af4330ed10b/comments", "author": null, "committer": null, "parents": [{"sha": "f8ae0b2ac5d94fa0a537909a6f49f00657f3e3fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8ae0b2ac5d94fa0a537909a6f49f00657f3e3fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8ae0b2ac5d94fa0a537909a6f49f00657f3e3fa"}], "stats": {"total": 56, "additions": 38, "deletions": 18}, "files": [{"sha": "2c0554b811192346ee5054e66fe5c312195e9d1c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eae202fc732b048b853afe479bc5af4330ed10b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eae202fc732b048b853afe479bc5af4330ed10b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3eae202fc732b048b853afe479bc5af4330ed10b", "patch": "@@ -1,5 +1,11 @@\n 2013-11-12  Jeff Law  <law@redhat.com>\n \n+\t* tree-ssa-threadedge.c (thread_around_empty_blocks): New\n+\targument backedge_seen_p.  Set, use and pass it to children\n+\tappropriately.\n+\t(thread_through_normal_block): Similarly.\n+\t(thread_across_edge): Similarly.\n+\n \t* gimple-ssa-isolate-paths.c (check_loadstore): Mark discovered\n \tmemory references as volatile.\n \t(insert_trap_and_remove_trailing_statements): Fix comment."}, {"sha": "0c9dcda5ef91def38a20fde1e365470213f98e19", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eae202fc732b048b853afe479bc5af4330ed10b/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eae202fc732b048b853afe479bc5af4330ed10b/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=3eae202fc732b048b853afe479bc5af4330ed10b", "patch": "@@ -760,7 +760,8 @@ thread_around_empty_blocks (edge taken_edge,\n \t\t\t    bool handle_dominating_asserts,\n \t\t\t    tree (*simplify) (gimple, gimple),\n \t\t\t    bitmap visited,\n-\t\t\t    vec<jump_thread_edge *> *path)\n+\t\t\t    vec<jump_thread_edge *> *path,\n+\t\t\t    bool *backedge_seen_p)\n {\n   basic_block bb = taken_edge->dest;\n   gimple_stmt_iterator gsi;\n@@ -795,19 +796,20 @@ thread_around_empty_blocks (edge taken_edge,\n       if (single_succ_p (bb))\n \t{\n \t  taken_edge = single_succ_edge (bb);\n-\t  if ((taken_edge->flags & EDGE_DFS_BACK) == 0\n-\t      && !bitmap_bit_p (visited, taken_edge->dest->index))\n+\t  if (!bitmap_bit_p (visited, taken_edge->dest->index))\n \t    {\n \t      jump_thread_edge *x\n \t\t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n \t      path->safe_push (x);\n \t      bitmap_set_bit (visited, taken_edge->dest->index);\n+\t      *backedge_seen_p |= ((taken_edge->flags & EDGE_DFS_BACK) != 0);\n \t      return thread_around_empty_blocks (taken_edge,\n \t\t\t\t\t\t dummy_cond,\n \t\t\t\t\t\t handle_dominating_asserts,\n \t\t\t\t\t\t simplify,\n \t\t\t\t\t\t visited,\n-\t\t\t\t\t\t path);\n+\t\t\t\t\t\t path,\n+\t\t\t\t\t\t backedge_seen_p);\n \t    }\n \t}\n \n@@ -841,13 +843,15 @@ thread_around_empty_blocks (edge taken_edge,\n       jump_thread_edge *x\n \t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n       path->safe_push (x);\n+      *backedge_seen_p |= ((taken_edge->flags & EDGE_DFS_BACK) != 0);\n \n       thread_around_empty_blocks (taken_edge,\n \t\t\t\t  dummy_cond,\n \t\t\t\t  handle_dominating_asserts,\n \t\t\t\t  simplify,\n \t\t\t\t  visited,\n-\t\t\t\t  path);\n+\t\t\t\t  path,\n+\t\t\t\t  backedge_seen_p);\n       return true;\n     }\n \n@@ -889,17 +893,16 @@ thread_through_normal_block (edge e,\n \t\t\t     vec<tree> *stack,\n \t\t\t     tree (*simplify) (gimple, gimple),\n \t\t\t     vec<jump_thread_edge *> *path,\n-\t\t\t     bitmap visited)\n+\t\t\t     bitmap visited,\n+\t\t\t     bool *backedge_seen_p)\n {\n-  /* If E is a backedge, then we want to verify that the COND_EXPR,\n+  /* If we have crossed a backedge, then we want to verify that the COND_EXPR,\n      SWITCH_EXPR or GOTO_EXPR at the end of e->dest is not affected\n      by any statements in e->dest.  If it is affected, then it is not\n      safe to thread this edge.  */\n-  if (e->flags & EDGE_DFS_BACK)\n-    {\n-      if (cond_arg_set_in_bb (e, e->dest))\n-\treturn false;\n-    }\n+  if (*backedge_seen_p\n+      && cond_arg_set_in_bb (e, e->dest))\n+    return false;\n \n   /* PHIs create temporary equivalences.  */\n   if (!record_temporary_equivalences_from_phis (e, stack))\n@@ -931,20 +934,24 @@ thread_through_normal_block (edge e,\n \n \t  /* DEST could be NULL for a computed jump to an absolute\n \t     address.  */\n-\t  if (dest == NULL || dest == e->dest || bitmap_bit_p (visited, dest->index))\n+\t  if (dest == NULL\n+\t      || dest == e->dest\n+\t      || bitmap_bit_p (visited, dest->index))\n \t    return false;\n \n           jump_thread_edge *x\n \t    = new jump_thread_edge (e, EDGE_START_JUMP_THREAD);\n \t  path->safe_push (x);\n+\t  *backedge_seen_p |= ((e->flags & EDGE_DFS_BACK) != 0);\n \n \t  x = new jump_thread_edge (taken_edge, EDGE_COPY_SRC_BLOCK);\n \t  path->safe_push (x);\n+\t  *backedge_seen_p |= ((taken_edge->flags & EDGE_DFS_BACK) != 0);\n \n \t  /* See if we can thread through DEST as well, this helps capture\n \t     secondary effects of threading without having to re-run DOM or\n \t     VRP.  */\n-\t  if ((e->flags & EDGE_DFS_BACK) == 0\n+\t  if (!*backedge_seen_p\n \t       || ! cond_arg_set_in_bb (taken_edge, e->dest))\n \t    {\n \t      /* We don't want to thread back to a block we have already\n@@ -956,7 +963,8 @@ thread_through_normal_block (edge e,\n \t\t\t\t\t  handle_dominating_asserts,\n \t\t\t\t\t  simplify,\n \t\t\t\t\t  visited,\n-\t\t\t\t\t  path);\n+\t\t\t\t\t  path,\n+\t\t\t\t\t  backedge_seen_p);\n \t    }\n \t  return true;\n \t}\n@@ -999,15 +1007,18 @@ thread_across_edge (gimple dummy_cond,\n \t\t    tree (*simplify) (gimple, gimple))\n {\n   bitmap visited = BITMAP_ALLOC (NULL);\n+  bool backedge_seen;\n \n   stmt_count = 0;\n \n   vec<jump_thread_edge *> *path = new vec<jump_thread_edge *> ();\n   bitmap_clear (visited);\n   bitmap_set_bit (visited, e->src->index);\n   bitmap_set_bit (visited, e->dest->index);\n+  backedge_seen = ((e->flags & EDGE_DFS_BACK) != 0);\n   if (thread_through_normal_block (e, dummy_cond, handle_dominating_asserts,\n-\t\t\t\t   stack, simplify, path, visited))\n+\t\t\t\t   stack, simplify, path, visited,\n+\t\t\t\t   &backedge_seen))\n     {\n       propagate_threaded_block_debug_into (path->last ()->e->dest,\n \t\t\t\t\t   e->dest);\n@@ -1067,14 +1078,17 @@ thread_across_edge (gimple dummy_cond,\n         x = new jump_thread_edge (taken_edge, EDGE_COPY_SRC_JOINER_BLOCK);\n \tpath->safe_push (x);\n \tfound = false;\n-\tif ((e->flags & EDGE_DFS_BACK) == 0\n+\tbackedge_seen = ((e->flags & EDGE_DFS_BACK) != 0);\n+\tbackedge_seen |= ((taken_edge->flags & EDGE_DFS_BACK) != 0);\n+\tif (!backedge_seen\n \t    || ! cond_arg_set_in_bb (path->last ()->e, e->dest))\n \t  found = thread_around_empty_blocks (taken_edge,\n \t\t\t\t\t      dummy_cond,\n \t\t\t\t\t      handle_dominating_asserts,\n \t\t\t\t\t      simplify,\n \t\t\t\t\t      visited,\n-\t\t\t\t\t      path);\n+\t\t\t\t\t      path,\n+\t\t\t\t\t      &backedge_seen);\n \n \t/* If we were able to thread through a successor of E->dest, then\n \t   record the jump threading opportunity.  */"}]}