{"sha": "dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZiZGRiZWIxY2E5MTJjOWY5ZjgwNmQ4Y2ZmNTVhNmFjMjg4N2Q4OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-04T10:39:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-04T10:39:44Z"}, "message": "Handle data dependence relations with different bases\n\nThis patch tries to calculate conservatively-correct distance\nvectors for two references whose base addresses are not the same.\nIt sets a new flag DDR_COULD_BE_INDEPENDENT_P if the dependence\nisn't guaranteed to occur.\n\nThe motivating example is:\n\n  struct s { int x[8]; };\n  void\n  f (struct s *a, struct s *b)\n  {\n    for (int i = 0; i < 8; ++i)\n      a->x[i] += b->x[i];\n  }\n\nin which the \"a\" and \"b\" accesses are either independent or have a\ndependence distance of 0 (assuming -fstrict-aliasing).  Neither case\nprevents vectorisation, so we can vectorise without an alias check.\n\nI'd originally wanted to do the same thing for arrays as well, e.g.:\n\n  void\n  f (int a[][8], struct b[][8])\n  {\n    for (int i = 0; i < 8; ++i)\n      a[0][i] += b[0][i];\n  }\n\nI think this is valid because C11 6.7.6.2/6 says:\n\n  For two array types to be compatible, both shall have compatible\n  element types, and if both size specifiers are present, and are\n  integer constant expressions, then both size specifiers shall have\n  the same constant value.\n\nSo if we access an array through an int (*)[8], it must have type X[8]\nor X[], where X is compatible with int.  It doesn't seem possible in\neither case for \"a[0]\" and \"b[0]\" to overlap when \"a != b\".\n\nHowever, as the comment above \"if (same_base_p)\" explains, GCC is more\nforgiving: it supports arbitrary overlap of arrays and allows arrays to\nbe accessed with different dimensionality.  There are examples of this\nin PR50067.  The patch therefore only handles references that end in a\nstructure field access.\n\nThere are two ways of handling these dependences in the vectoriser:\nuse them to limit VF, or check at runtime as before.  I've gone for\nthe approach of checking at runtime if we can, to avoid limiting VF\nunnecessarily, but falling back to a VF cap when runtime checks aren't\nallowed.\n\nThe patch tests whether we queued an alias check with a dependence\ndistance of X and then picked a VF <= X, in which case it's safe to\ndrop the alias check.  Since vect_prune_runtime_alias_check_list\ncan be called twice with different VF for the same loop, it's no\nlonger safe to clear may_alias_ddrs on exit.  Instead we should use\ncomp_alias_ddrs to check whether versioning is necessary.\n\n2017-08-04  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-data-ref.h (subscript): Add access_fn field.\n\t(data_dependence_relation): Add could_be_independent_p.\n\t(SUB_ACCESS_FN, DDR_COULD_BE_INDEPENDENT_P): New macros.\n\t(same_access_functions): Move to tree-data-ref.c.\n\t* tree-data-ref.c (ref_contains_union_access_p): New function.\n\t(access_fn_component_p): Likewise.\n\t(access_fn_components_comparable_p): Likewise.\n\t(dr_analyze_indices): Add a reference to access_fn_component_p.\n\t(dump_data_dependence_relation): Use SUB_ACCESS_FN instead of\n\tDR_ACCESS_FN.\n\t(constant_access_functions): Likewise.\n\t(add_other_self_distances): Likewise.\n\t(same_access_functions): Likewise.  (Moved from tree-data-ref.h.)\n\t(initialize_data_dependence_relation): Use XCNEW and remove\n\texplicit zeroing of DDR_REVERSED_P.  Look for a subsequence\n\tof access functions that have the same type.  Allow the\n\tsubsequence to end with different bases in some circumstances.\n\tRecord the chosen access functions in SUB_ACCESS_FN.\n\t(build_classic_dist_vector_1): Replace ddr_a and ddr_b with\n\ta_index and b_index.  Use SUB_ACCESS_FN instead of DR_ACCESS_FN.\n\t(subscript_dependence_tester_1): Likewise dra and drb.\n\t(build_classic_dist_vector): Update calls accordingly.\n\t(subscript_dependence_tester): Likewise.\n\t* tree-ssa-loop-prefetch.c (determine_loop_nest_reuse): Check\n\tDDR_COULD_BE_INDEPENDENT_P.\n\t* tree-vectorizer.h (LOOP_REQUIRES_VERSIONING_FOR_ALIAS): Test\n\tcomp_alias_ddrs instead of may_alias_ddrs.\n\t* tree-vect-data-refs.c (vect_analyze_possibly_independent_ddr):\n\tNew function.\n\t(vect_analyze_data_ref_dependence): Use it if\n\tDDR_COULD_BE_INDEPENDENT_P, but fall back to using the recorded\n\tdistance vectors if that fails.\n\t(dependence_distance_ge_vf): New function.\n\t(vect_prune_runtime_alias_test_list): Use it.  Don't clear\n\tLOOP_VINFO_MAY_ALIAS_DDRS.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-alias-check-3.c: New test.\n\t* gcc.dg/vect/vect-alias-check-4.c: Likewise.\n\t* gcc.dg/vect/vect-alias-check-5.c: Likewise.\n\nFrom-SVN: r250867", "tree": {"sha": "aa4d6ca5f5f5cbfadd885d28a60892f3d7aec29f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa4d6ca5f5f5cbfadd885d28a60892f3d7aec29f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/comments", "author": null, "committer": null, "parents": [{"sha": "165b2f5f5d7fe14ab567e83a4cf2e0a492038a8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/165b2f5f5d7fe14ab567e83a4cf2e0a492038a8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/165b2f5f5d7fe14ab567e83a4cf2e0a492038a8c"}], "stats": {"total": 834, "additions": 726, "deletions": 108}, "files": [{"sha": "7a5a1ebd0bcbd0f5f041613af80d987729c6001f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "patch": "@@ -1,3 +1,41 @@\n+2017-08-04  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-data-ref.h (subscript): Add access_fn field.\n+\t(data_dependence_relation): Add could_be_independent_p.\n+\t(SUB_ACCESS_FN, DDR_COULD_BE_INDEPENDENT_P): New macros.\n+\t(same_access_functions): Move to tree-data-ref.c.\n+\t* tree-data-ref.c (ref_contains_union_access_p): New function.\n+\t(access_fn_component_p): Likewise.\n+\t(access_fn_components_comparable_p): Likewise.\n+\t(dr_analyze_indices): Add a reference to access_fn_component_p.\n+\t(dump_data_dependence_relation): Use SUB_ACCESS_FN instead of\n+\tDR_ACCESS_FN.\n+\t(constant_access_functions): Likewise.\n+\t(add_other_self_distances): Likewise.\n+\t(same_access_functions): Likewise.  (Moved from tree-data-ref.h.)\n+\t(initialize_data_dependence_relation): Use XCNEW and remove\n+\texplicit zeroing of DDR_REVERSED_P.  Look for a subsequence\n+\tof access functions that have the same type.  Allow the\n+\tsubsequence to end with different bases in some circumstances.\n+\tRecord the chosen access functions in SUB_ACCESS_FN.\n+\t(build_classic_dist_vector_1): Replace ddr_a and ddr_b with\n+\ta_index and b_index.  Use SUB_ACCESS_FN instead of DR_ACCESS_FN.\n+\t(subscript_dependence_tester_1): Likewise dra and drb.\n+\t(build_classic_dist_vector): Update calls accordingly.\n+\t(subscript_dependence_tester): Likewise.\n+\t* tree-ssa-loop-prefetch.c (determine_loop_nest_reuse): Check\n+\tDDR_COULD_BE_INDEPENDENT_P.\n+\t* tree-vectorizer.h (LOOP_REQUIRES_VERSIONING_FOR_ALIAS): Test\n+\tcomp_alias_ddrs instead of may_alias_ddrs.\n+\t* tree-vect-data-refs.c (vect_analyze_possibly_independent_ddr):\n+\tNew function.\n+\t(vect_analyze_data_ref_dependence): Use it if\n+\tDDR_COULD_BE_INDEPENDENT_P, but fall back to using the recorded\n+\tdistance vectors if that fails.\n+\t(dependence_distance_ge_vf): New function.\n+\t(vect_prune_runtime_alias_test_list): Use it.  Don't clear\n+\tLOOP_VINFO_MAY_ALIAS_DDRS.\n+\n 2017-08-04  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/81705"}, {"sha": "999d5cd6bfa6491fca5b99c246f887c5990b8c55", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "patch": "@@ -1,3 +1,9 @@\n+2017-08-04  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.dg/vect/vect-alias-check-3.c: New test.\n+\t* gcc.dg/vect/vect-alias-check-4.c: Likewise.\n+\t* gcc.dg/vect/vect-alias-check-5.c: Likewise.\n+\n 2017-08-04  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/81705"}, {"sha": "10b4c3d2c2abb8045178e936dd1e4d038ea0c89c", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-3.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-3.c?ref=dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "patch": "@@ -0,0 +1,120 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-additional-options \"--param vect-max-version-for-alias-checks=0 -fopenmp-simd\" } */\n+\n+/* Intended to be larger than any VF.  */\n+#define GAP 128\n+#define N (GAP * 3)\n+\n+struct s { int x[N + 1]; };\n+struct t { struct s x[N + 1]; };\n+struct u { int x[N + 1]; int y; };\n+struct v { struct s s; };\n+\n+void\n+f1 (struct s *a, struct s *b)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a->x[i] += b->x[i];\n+}\n+\n+void\n+f2 (struct s *a, struct s *b)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a[1].x[i] += b[2].x[i];\n+}\n+\n+void\n+f3 (struct s *a, struct s *b)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a[1].x[i] += b[i].x[i];\n+}\n+\n+void\n+f4 (struct s *a, struct s *b)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a[i].x[i] += b[i].x[i];\n+}\n+\n+void\n+f5 (struct s *a, struct s *b)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a->x[i] += b->x[i + 1];\n+}\n+\n+void\n+f6 (struct s *a, struct s *b)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a[1].x[i] += b[2].x[i + 1];\n+}\n+\n+void\n+f7 (struct s *a, struct s *b)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a[1].x[i] += b[i].x[i + 1];\n+}\n+\n+void\n+f8 (struct s *a, struct s *b)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a[i].x[i] += b[i].x[i + 1];\n+}\n+\n+void\n+f9 (struct s *a, struct t *b)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a->x[i] += b->x[1].x[i];\n+}\n+\n+void\n+f10 (struct s *a, struct t *b)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a->x[i] += b->x[i].x[i];\n+}\n+\n+void\n+f11 (struct u *a, struct u *b)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a->x[i] += b->x[i] + b[i].y;\n+}\n+\n+void\n+f12 (struct s *a, struct s *b)\n+{\n+  for (int i = 0; i < GAP; ++i)\n+    a->x[i + GAP] += b->x[i];\n+}\n+\n+void\n+f13 (struct s *a, struct s *b)\n+{\n+  for (int i = 0; i < GAP * 2; ++i)\n+    a->x[i + GAP] += b->x[i];\n+}\n+\n+void\n+f14 (struct v *a, struct s *b)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a->s.x[i] = b->x[i];\n+}\n+\n+void\n+f15 (struct s *a, struct s *b)\n+{\n+  #pragma omp simd safelen(N)\n+  for (int i = 0; i < N; ++i)\n+    a->x[i + 1] += b->x[i];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 15 \"vect\" } } */"}, {"sha": "1e5fc273ec1ab47bfd9a92feed2a4f44dae95501", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-4.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-4.c?ref=dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-additional-options \"--param vect-max-version-for-alias-checks=0\" } */\n+\n+#define N 16\n+\n+struct s1 { int a[N]; };\n+struct s2 { struct s1 b; int c; };\n+struct s3 { int d; struct s1 e; };\n+union u { struct s2 f; struct s3 g; };\n+\n+/* We allow a and b to overlap arbitrarily.  */\n+\n+void\n+f1 (int a[][N], int b[][N])\n+{\n+  for (int i = 0; i < N; ++i)\n+    a[0][i] += b[0][i];\n+}\n+\n+void\n+f2 (union u *a, union u *b)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a->f.b.a[i] += b->g.e.a[i];\n+}\n+\n+void\n+f3 (struct s1 *a, struct s1 *b)\n+{\n+  for (int i = 0; i < N - 1; ++i)\n+    a->a[i + 1] += b->a[i];\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"LOOP VECTORIZED\" \"vect\" } } */"}, {"sha": "bfa946b9ad2bceab4971068d2f43596fe041ed1a", "filename": "gcc/testsuite/gcc.dg/vect/vect-alias-check-5.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-alias-check-5.c?ref=dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+/* Intended to be larger than any VF.  */\n+#define GAP 128\n+#define N (GAP * 3)\n+\n+struct s { int x[N]; };\n+\n+void\n+f1 (struct s *a, struct s *b)\n+{\n+  for (int i = 0; i < GAP * 2; ++i)\n+    a->x[i + GAP] += b->x[i];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"consider run-time aliasing\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"improved number of alias checks from 1 to 0\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 1 \"vect\" } } */"}, {"sha": "619a651486bba7c87464ff76381422b2384f29fe", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 367, "deletions": 87, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "patch": "@@ -124,8 +124,7 @@ static struct datadep_stats\n } dependence_stats;\n \n static bool subscript_dependence_tester_1 (struct data_dependence_relation *,\n-\t\t\t\t\t   struct data_reference *,\n-\t\t\t\t\t   struct data_reference *,\n+\t\t\t\t\t   unsigned int, unsigned int,\n \t\t\t\t\t   struct loop *);\n /* Returns true iff A divides B.  */\n \n@@ -145,6 +144,21 @@ int_divides_p (int a, int b)\n   return ((b % a) == 0);\n }\n \n+/* Return true if reference REF contains a union access.  */\n+\n+static bool\n+ref_contains_union_access_p (tree ref)\n+{\n+  while (handled_component_p (ref))\n+    {\n+      ref = TREE_OPERAND (ref, 0);\n+      if (TREE_CODE (TREE_TYPE (ref)) == UNION_TYPE\n+\t  || TREE_CODE (TREE_TYPE (ref)) == QUAL_UNION_TYPE)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n \f\n \n /* Dump into FILE all the data references from DATAREFS.  */\n@@ -434,13 +448,14 @@ dump_data_dependence_relation (FILE *outf,\n       unsigned int i;\n       struct loop *loopi;\n \n-      for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n+      subscript *sub;\n+      FOR_EACH_VEC_ELT (DDR_SUBSCRIPTS (ddr), i, sub)\n \t{\n \t  fprintf (outf, \"  access_fn_A: \");\n-\t  print_generic_stmt (outf, DR_ACCESS_FN (dra, i));\n+\t  print_generic_stmt (outf, SUB_ACCESS_FN (sub, 0));\n \t  fprintf (outf, \"  access_fn_B: \");\n-\t  print_generic_stmt (outf, DR_ACCESS_FN (drb, i));\n-\t  dump_subscript (outf, DDR_SUBSCRIPT (ddr, i));\n+\t  print_generic_stmt (outf, SUB_ACCESS_FN (sub, 1));\n+\t  dump_subscript (outf, sub);\n \t}\n \n       fprintf (outf, \"  inner loop index: %d\\n\", DDR_INNER_LOOP (ddr));\n@@ -920,6 +935,27 @@ dr_analyze_innermost (innermost_loop_behavior *drb, tree ref,\n   return true;\n }\n \n+/* Return true if OP is a valid component reference for a DR access\n+   function.  This accepts a subset of what handled_component_p accepts.  */\n+\n+static bool\n+access_fn_component_p (tree op)\n+{\n+  switch (TREE_CODE (op))\n+    {\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+    case ARRAY_REF:\n+      return true;\n+\n+    case COMPONENT_REF:\n+      return TREE_CODE (TREE_TYPE (TREE_OPERAND (op, 0))) == RECORD_TYPE;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Determines the base object and the list of indices of memory reference\n    DR, analyzed in LOOP and instantiated in loop nest NEST.  */\n \n@@ -957,7 +993,9 @@ dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n       access_fns.safe_push (integer_one_node);\n     }\n \n-  /* Analyze access functions of dimensions we know to be independent.  */\n+  /* Analyze access functions of dimensions we know to be independent.\n+     The list of component references handled here should be kept in\n+     sync with access_fn_component_p.  */\n   while (handled_component_p (ref))\n     {\n       if (TREE_CODE (ref) == ARRAY_REF)\n@@ -2148,6 +2186,38 @@ dr_may_alias_p (const struct data_reference *a, const struct data_reference *b,\n   return refs_may_alias_p (addr_a, addr_b);\n }\n \n+/* REF_A and REF_B both satisfy access_fn_component_p.  Return true\n+   if it is meaningful to compare their associated access functions\n+   when checking for dependencies.  */\n+\n+static bool\n+access_fn_components_comparable_p (tree ref_a, tree ref_b)\n+{\n+  /* Allow pairs of component refs from the following sets:\n+\n+       { REALPART_EXPR, IMAGPART_EXPR }\n+       { COMPONENT_REF }\n+       { ARRAY_REF }.  */\n+  tree_code code_a = TREE_CODE (ref_a);\n+  tree_code code_b = TREE_CODE (ref_b);\n+  if (code_a == IMAGPART_EXPR)\n+    code_a = REALPART_EXPR;\n+  if (code_b == IMAGPART_EXPR)\n+    code_b = REALPART_EXPR;\n+  if (code_a != code_b)\n+    return false;\n+\n+  if (TREE_CODE (ref_a) == COMPONENT_REF)\n+    /* ??? We cannot simply use the type of operand #0 of the refs here as\n+       the Fortran compiler smuggles type punning into COMPONENT_REFs.\n+       Use the DECL_CONTEXT of the FIELD_DECLs instead.  */\n+    return (DECL_CONTEXT (TREE_OPERAND (ref_a, 1))\n+\t    == DECL_CONTEXT (TREE_OPERAND (ref_b, 1)));\n+\n+  return types_compatible_p (TREE_TYPE (TREE_OPERAND (ref_a, 0)),\n+\t\t\t     TREE_TYPE (TREE_OPERAND (ref_b, 0)));\n+}\n+\n /* Initialize a data dependence relation between data accesses A and\n    B.  NB_LOOPS is the number of loops surrounding the references: the\n    size of the classic distance/direction vectors.  */\n@@ -2160,11 +2230,10 @@ initialize_data_dependence_relation (struct data_reference *a,\n   struct data_dependence_relation *res;\n   unsigned int i;\n \n-  res = XNEW (struct data_dependence_relation);\n+  res = XCNEW (struct data_dependence_relation);\n   DDR_A (res) = a;\n   DDR_B (res) = b;\n   DDR_LOOP_NEST (res).create (0);\n-  DDR_REVERSED_P (res) = false;\n   DDR_SUBSCRIPTS (res).create (0);\n   DDR_DIR_VECTS (res).create (0);\n   DDR_DIST_VECTS (res).create (0);\n@@ -2182,82 +2251,277 @@ initialize_data_dependence_relation (struct data_reference *a,\n       return res;\n     }\n \n-  /* The case where the references are exactly the same.  */\n-  if (operand_equal_p (DR_REF (a), DR_REF (b), 0))\n+  unsigned int num_dimensions_a = DR_NUM_DIMENSIONS (a);\n+  unsigned int num_dimensions_b = DR_NUM_DIMENSIONS (b);\n+  if (num_dimensions_a == 0 || num_dimensions_b == 0)\n     {\n-      if ((loop_nest.exists ()\n-\t   && !object_address_invariant_in_loop_p (loop_nest[0],\n-\t\t\t\t\t\t   DR_BASE_OBJECT (a)))\n-\t  || DR_NUM_DIMENSIONS (a) == 0)\n+      DDR_ARE_DEPENDENT (res) = chrec_dont_know;\n+      return res;\n+    }\n+\n+  /* For unconstrained bases, the root (highest-indexed) subscript\n+     describes a variation in the base of the original DR_REF rather\n+     than a component access.  We have no type that accurately describes\n+     the new DR_BASE_OBJECT (whose TREE_TYPE describes the type *after*\n+     applying this subscript) so limit the search to the last real\n+     component access.\n+\n+     E.g. for:\n+\n+\tvoid\n+\tf (int a[][8], int b[][8])\n \t{\n-\t  DDR_ARE_DEPENDENT (res) = chrec_dont_know;\n-\t  return res;\n+\t  for (int i = 0; i < 8; ++i)\n+\t    a[i * 2][0] = b[i][0];\n+\t}\n+\n+     the a and b accesses have a single ARRAY_REF component reference [0]\n+     but have two subscripts.  */\n+  if (DR_UNCONSTRAINED_BASE (a))\n+    num_dimensions_a -= 1;\n+  if (DR_UNCONSTRAINED_BASE (b))\n+    num_dimensions_b -= 1;\n+\n+  /* These structures describe sequences of component references in\n+     DR_REF (A) and DR_REF (B).  Each component reference is tied to a\n+     specific access function.  */\n+  struct {\n+    /* The sequence starts at DR_ACCESS_FN (A, START_A) of A and\n+       DR_ACCESS_FN (B, START_B) of B (inclusive) and extends to higher\n+       indices.  In C notation, these are the indices of the rightmost\n+       component references; e.g. for a sequence .b.c.d, the start\n+       index is for .d.  */\n+    unsigned int start_a;\n+    unsigned int start_b;\n+\n+    /* The sequence contains LENGTH consecutive access functions from\n+       each DR.  */\n+    unsigned int length;\n+\n+    /* The enclosing objects for the A and B sequences respectively,\n+       i.e. the objects to which DR_ACCESS_FN (A, START_A + LENGTH - 1)\n+       and DR_ACCESS_FN (B, START_B + LENGTH - 1) are applied.  */\n+    tree object_a;\n+    tree object_b;\n+  } full_seq = {}, struct_seq = {};\n+\n+  /* Before each iteration of the loop:\n+\n+     - REF_A is what you get after applying DR_ACCESS_FN (A, INDEX_A) and\n+     - REF_B is what you get after applying DR_ACCESS_FN (B, INDEX_B).  */\n+  unsigned int index_a = 0;\n+  unsigned int index_b = 0;\n+  tree ref_a = DR_REF (a);\n+  tree ref_b = DR_REF (b);\n+\n+  /* Now walk the component references from the final DR_REFs back up to\n+     the enclosing base objects.  Each component reference corresponds\n+     to one access function in the DR, with access function 0 being for\n+     the final DR_REF and the highest-indexed access function being the\n+     one that is applied to the base of the DR.\n+\n+     Look for a sequence of component references whose access functions\n+     are comparable (see access_fn_components_comparable_p).  If more\n+     than one such sequence exists, pick the one nearest the base\n+     (which is the leftmost sequence in C notation).  Store this sequence\n+     in FULL_SEQ.\n+\n+     For example, if we have:\n+\n+\tstruct foo { struct bar s; ... } (*a)[10], (*b)[10];\n+\n+\tA: a[0][i].s.c.d\n+\tB: __real b[0][i].s.e[i].f\n+\n+     (where d is the same type as the real component of f) then the access\n+     functions would be:\n+\n+\t\t\t 0   1   2   3\n+\tA:              .d  .c  .s [i]\n+\n+\t\t 0   1   2   3   4   5\n+\tB:  __real  .f [i]  .e  .s [i]\n+\n+     The A0/B2 column isn't comparable, since .d is a COMPONENT_REF\n+     and [i] is an ARRAY_REF.  However, the A1/B3 column contains two\n+     COMPONENT_REF accesses for struct bar, so is comparable.  Likewise\n+     the A2/B4 column contains two COMPONENT_REF accesses for struct foo,\n+     so is comparable.  The A3/B5 column contains two ARRAY_REFs that\n+     index foo[10] arrays, so is again comparable.  The sequence is\n+     therefore:\n+\n+        A: [1, 3]  (i.e. [i].s.c)\n+        B: [3, 5]  (i.e. [i].s.e)\n+\n+     Also look for sequences of component references whose access\n+     functions are comparable and whose enclosing objects have the same\n+     RECORD_TYPE.  Store this sequence in STRUCT_SEQ.  In the above\n+     example, STRUCT_SEQ would be:\n+\n+        A: [1, 2]  (i.e. s.c)\n+        B: [3, 4]  (i.e. s.e)  */\n+  while (index_a < num_dimensions_a && index_b < num_dimensions_b)\n+    {\n+      /* REF_A and REF_B must be one of the component access types\n+\t allowed by dr_analyze_indices.  */\n+      gcc_checking_assert (access_fn_component_p (ref_a));\n+      gcc_checking_assert (access_fn_component_p (ref_b));\n+\n+      /* Get the immediately-enclosing objects for REF_A and REF_B,\n+\t i.e. the references *before* applying DR_ACCESS_FN (A, INDEX_A)\n+\t and DR_ACCESS_FN (B, INDEX_B).  */\n+      tree object_a = TREE_OPERAND (ref_a, 0);\n+      tree object_b = TREE_OPERAND (ref_b, 0);\n+\n+      tree type_a = TREE_TYPE (object_a);\n+      tree type_b = TREE_TYPE (object_b);\n+      if (access_fn_components_comparable_p (ref_a, ref_b))\n+\t{\n+\t  /* This pair of component accesses is comparable for dependence\n+\t     analysis, so we can include DR_ACCESS_FN (A, INDEX_A) and\n+\t     DR_ACCESS_FN (B, INDEX_B) in the sequence.  */\n+\t  if (full_seq.start_a + full_seq.length != index_a\n+\t      || full_seq.start_b + full_seq.length != index_b)\n+\t    {\n+\t      /* The accesses don't extend the current sequence,\n+\t\t so start a new one here.  */\n+\t      full_seq.start_a = index_a;\n+\t      full_seq.start_b = index_b;\n+\t      full_seq.length = 0;\n+\t    }\n+\n+\t  /* Add this pair of references to the sequence.  */\n+\t  full_seq.length += 1;\n+\t  full_seq.object_a = object_a;\n+\t  full_seq.object_b = object_b;\n+\n+\t  /* If the enclosing objects are structures (and thus have the\n+\t     same RECORD_TYPE), record the new sequence in STRUCT_SEQ.  */\n+\t  if (TREE_CODE (type_a) == RECORD_TYPE)\n+\t    struct_seq = full_seq;\n+\n+\t  /* Move to the next containing reference for both A and B.  */\n+\t  ref_a = object_a;\n+\t  ref_b = object_b;\n+\t  index_a += 1;\n+\t  index_b += 1;\n+\t  continue;\n+\t}\n+\n+      /* Try to approach equal type sizes.  */\n+      if (!COMPLETE_TYPE_P (type_a)\n+\t  || !COMPLETE_TYPE_P (type_b)\n+\t  || !tree_fits_uhwi_p (TYPE_SIZE_UNIT (type_a))\n+\t  || !tree_fits_uhwi_p (TYPE_SIZE_UNIT (type_b)))\n+\tbreak;\n+\n+      unsigned HOST_WIDE_INT size_a = tree_to_uhwi (TYPE_SIZE_UNIT (type_a));\n+      unsigned HOST_WIDE_INT size_b = tree_to_uhwi (TYPE_SIZE_UNIT (type_b));\n+      if (size_a <= size_b)\n+\t{\n+\t  index_a += 1;\n+\t  ref_a = object_a;\n+\t}\n+      if (size_b <= size_a)\n+\t{\n+\t  index_b += 1;\n+\t  ref_b = object_b;\n \t}\n-      DDR_AFFINE_P (res) = true;\n-      DDR_ARE_DEPENDENT (res) = NULL_TREE;\n-      DDR_SUBSCRIPTS (res).create (DR_NUM_DIMENSIONS (a));\n-      DDR_LOOP_NEST (res) = loop_nest;\n-      DDR_INNER_LOOP (res) = 0;\n-      DDR_SELF_REFERENCE (res) = true;\n-      for (i = 0; i < DR_NUM_DIMENSIONS (a); i++)\n-       {\n-         struct subscript *subscript;\n-\n-         subscript = XNEW (struct subscript);\n-         SUB_CONFLICTS_IN_A (subscript) = conflict_fn_not_known ();\n-         SUB_CONFLICTS_IN_B (subscript) = conflict_fn_not_known ();\n-         SUB_LAST_CONFLICT (subscript) = chrec_dont_know;\n-         SUB_DISTANCE (subscript) = chrec_dont_know;\n-         DDR_SUBSCRIPTS (res).safe_push (subscript);\n-       }\n-      return res;\n     }\n \n-  /* If the references do not access the same object, we do not know\n-     whether they alias or not.  We do not care about TBAA or alignment\n-     info so we can use OEP_ADDRESS_OF to avoid false negatives.\n-     But the accesses have to use compatible types as otherwise the\n-     built indices would not match.  */\n-  if (!operand_equal_p (DR_BASE_OBJECT (a), DR_BASE_OBJECT (b), OEP_ADDRESS_OF)\n-      || !types_compatible_p (TREE_TYPE (DR_BASE_OBJECT (a)),\n-\t\t\t      TREE_TYPE (DR_BASE_OBJECT (b))))\n+  /* See whether FULL_SEQ ends at the base and whether the two bases\n+     are equal.  We do not care about TBAA or alignment info so we can\n+     use OEP_ADDRESS_OF to avoid false negatives.  */\n+  tree base_a = DR_BASE_OBJECT (a);\n+  tree base_b = DR_BASE_OBJECT (b);\n+  bool same_base_p = (full_seq.start_a + full_seq.length == num_dimensions_a\n+\t\t      && full_seq.start_b + full_seq.length == num_dimensions_b\n+\t\t      && DR_UNCONSTRAINED_BASE (a) == DR_UNCONSTRAINED_BASE (b)\n+\t\t      && operand_equal_p (base_a, base_b, OEP_ADDRESS_OF)\n+\t\t      && types_compatible_p (TREE_TYPE (base_a),\n+\t\t\t\t\t     TREE_TYPE (base_b))\n+\t\t      && (!loop_nest.exists ()\n+\t\t\t  || (object_address_invariant_in_loop_p\n+\t\t\t      (loop_nest[0], base_a))));\n+\n+  /* If the bases are the same, we can include the base variation too.\n+     E.g. the b accesses in:\n+\n+       for (int i = 0; i < n; ++i)\n+         b[i + 4][0] = b[i][0];\n+\n+     have a definite dependence distance of 4, while for:\n+\n+       for (int i = 0; i < n; ++i)\n+         a[i + 4][0] = b[i][0];\n+\n+     the dependence distance depends on the gap between a and b.\n+\n+     If the bases are different then we can only rely on the sequence\n+     rooted at a structure access, since arrays are allowed to overlap\n+     arbitrarily and change shape arbitrarily.  E.g. we treat this as\n+     valid code:\n+\n+       int a[256];\n+       ...\n+       ((int (*)[4][3]) &a[1])[i][0] += ((int (*)[4][3]) &a[2])[i][0];\n+\n+     where two lvalues with the same int[4][3] type overlap, and where\n+     both lvalues are distinct from the object's declared type.  */\n+  if (same_base_p)\n     {\n-      DDR_ARE_DEPENDENT (res) = chrec_dont_know;\n-      return res;\n+      if (DR_UNCONSTRAINED_BASE (a))\n+\tfull_seq.length += 1;\n     }\n+  else\n+    full_seq = struct_seq;\n \n-  /* If the base of the object is not invariant in the loop nest, we cannot\n-     analyze it.  TODO -- in fact, it would suffice to record that there may\n-     be arbitrary dependences in the loops where the base object varies.  */\n-  if ((loop_nest.exists ()\n-       && !object_address_invariant_in_loop_p (loop_nest[0], DR_BASE_OBJECT (a)))\n-      || DR_NUM_DIMENSIONS (a) == 0)\n+  /* Punt if we didn't find a suitable sequence.  */\n+  if (full_seq.length == 0)\n     {\n       DDR_ARE_DEPENDENT (res) = chrec_dont_know;\n       return res;\n     }\n \n-  /* If the number of dimensions of the access to not agree we can have\n-     a pointer access to a component of the array element type and an\n-     array access while the base-objects are still the same.  Punt.  */\n-  if (DR_NUM_DIMENSIONS (a) != DR_NUM_DIMENSIONS (b))\n+  if (!same_base_p)\n     {\n-      DDR_ARE_DEPENDENT (res) = chrec_dont_know;\n-      return res;\n+      /* Partial overlap is possible for different bases when strict aliasing\n+\t is not in effect.  It's also possible if either base involves a union\n+\t access; e.g. for:\n+\n+\t   struct s1 { int a[2]; };\n+\t   struct s2 { struct s1 b; int c; };\n+\t   struct s3 { int d; struct s1 e; };\n+\t   union u { struct s2 f; struct s3 g; } *p, *q;\n+\n+\t the s1 at \"p->f.b\" (base \"p->f\") partially overlaps the s1 at\n+\t \"p->g.e\" (base \"p->g\") and might partially overlap the s1 at\n+\t \"q->g.e\" (base \"q->g\").  */\n+      if (!flag_strict_aliasing\n+\t  || ref_contains_union_access_p (full_seq.object_a)\n+\t  || ref_contains_union_access_p (full_seq.object_b))\n+\t{\n+\t  DDR_ARE_DEPENDENT (res) = chrec_dont_know;\n+\t  return res;\n+\t}\n+\n+      DDR_COULD_BE_INDEPENDENT_P (res) = true;\n     }\n \n   DDR_AFFINE_P (res) = true;\n   DDR_ARE_DEPENDENT (res) = NULL_TREE;\n-  DDR_SUBSCRIPTS (res).create (DR_NUM_DIMENSIONS (a));\n+  DDR_SUBSCRIPTS (res).create (full_seq.length);\n   DDR_LOOP_NEST (res) = loop_nest;\n   DDR_INNER_LOOP (res) = 0;\n   DDR_SELF_REFERENCE (res) = false;\n \n-  for (i = 0; i < DR_NUM_DIMENSIONS (a); i++)\n+  for (i = 0; i < full_seq.length; ++i)\n     {\n       struct subscript *subscript;\n \n       subscript = XNEW (struct subscript);\n+      SUB_ACCESS_FN (subscript, 0) = DR_ACCESS_FN (a, full_seq.start_a + i);\n+      SUB_ACCESS_FN (subscript, 1) = DR_ACCESS_FN (b, full_seq.start_b + i);\n       SUB_CONFLICTS_IN_A (subscript) = conflict_fn_not_known ();\n       SUB_CONFLICTS_IN_B (subscript) = conflict_fn_not_known ();\n       SUB_LAST_CONFLICT (subscript) = chrec_dont_know;\n@@ -3839,14 +4103,15 @@ add_outer_distances (struct data_dependence_relation *ddr,\n }\n \n /* Return false when fail to represent the data dependence as a\n-   distance vector.  INIT_B is set to true when a component has been\n+   distance vector.  A_INDEX is the index of the first reference\n+   (0 for DDR_A, 1 for DDR_B) and B_INDEX is the index of the\n+   second reference.  INIT_B is set to true when a component has been\n    added to the distance vector DIST_V.  INDEX_CARRY is then set to\n    the index in DIST_V that carries the dependence.  */\n \n static bool\n build_classic_dist_vector_1 (struct data_dependence_relation *ddr,\n-\t\t\t     struct data_reference *ddr_a,\n-\t\t\t     struct data_reference *ddr_b,\n+\t\t\t     unsigned int a_index, unsigned int b_index,\n \t\t\t     lambda_vector dist_v, bool *init_b,\n \t\t\t     int *index_carry)\n {\n@@ -3864,8 +4129,8 @@ build_classic_dist_vector_1 (struct data_dependence_relation *ddr,\n \t  return false;\n \t}\n \n-      access_fn_a = DR_ACCESS_FN (ddr_a, i);\n-      access_fn_b = DR_ACCESS_FN (ddr_b, i);\n+      access_fn_a = SUB_ACCESS_FN (subscript, a_index);\n+      access_fn_b = SUB_ACCESS_FN (subscript, b_index);\n \n       if (TREE_CODE (access_fn_a) == POLYNOMIAL_CHREC\n \t  && TREE_CODE (access_fn_b) == POLYNOMIAL_CHREC)\n@@ -3925,10 +4190,11 @@ static bool\n constant_access_functions (const struct data_dependence_relation *ddr)\n {\n   unsigned i;\n+  subscript *sub;\n \n-  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n-    if (!evolution_function_is_constant_p (DR_ACCESS_FN (DDR_A (ddr), i))\n-\t|| !evolution_function_is_constant_p (DR_ACCESS_FN (DDR_B (ddr), i)))\n+  FOR_EACH_VEC_ELT (DDR_SUBSCRIPTS (ddr), i, sub)\n+    if (!evolution_function_is_constant_p (SUB_ACCESS_FN (sub, 0))\n+\t|| !evolution_function_is_constant_p (SUB_ACCESS_FN (sub, 1)))\n       return false;\n \n   return true;\n@@ -3991,10 +4257,11 @@ add_other_self_distances (struct data_dependence_relation *ddr)\n   lambda_vector dist_v;\n   unsigned i;\n   int index_carry = DDR_NB_LOOPS (ddr);\n+  subscript *sub;\n \n-  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n+  FOR_EACH_VEC_ELT (DDR_SUBSCRIPTS (ddr), i, sub)\n     {\n-      tree access_fun = DR_ACCESS_FN (DDR_A (ddr), i);\n+      tree access_fun = SUB_ACCESS_FN (sub, 0);\n \n       if (TREE_CODE (access_fun) == POLYNOMIAL_CHREC)\n \t{\n@@ -4006,7 +4273,7 @@ add_other_self_distances (struct data_dependence_relation *ddr)\n \t\t  return;\n \t\t}\n \n-\t      access_fun = DR_ACCESS_FN (DDR_A (ddr), 0);\n+\t      access_fun = SUB_ACCESS_FN (DDR_SUBSCRIPT (ddr, 0), 0);\n \n \t      if (TREE_CODE (CHREC_LEFT (access_fun)) == POLYNOMIAL_CHREC)\n \t\tadd_multivariate_self_dist (ddr, access_fun);\n@@ -4077,6 +4344,23 @@ add_distance_for_zero_overlaps (struct data_dependence_relation *ddr)\n     }\n }\n \n+/* Return true when the DDR contains two data references that have the\n+   same access functions.  */\n+\n+static inline bool\n+same_access_functions (const struct data_dependence_relation *ddr)\n+{\n+  unsigned i;\n+  subscript *sub;\n+\n+  FOR_EACH_VEC_ELT (DDR_SUBSCRIPTS (ddr), i, sub)\n+    if (!eq_evolutions_p (SUB_ACCESS_FN (sub, 0),\n+\t\t\t  SUB_ACCESS_FN (sub, 1)))\n+      return false;\n+\n+  return true;\n+}\n+\n /* Compute the classic per loop distance vector.  DDR is the data\n    dependence relation to build a vector from.  Return false when fail\n    to represent the data dependence as a distance vector.  */\n@@ -4108,8 +4392,7 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n     }\n \n   dist_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n-  if (!build_classic_dist_vector_1 (ddr, DDR_A (ddr), DDR_B (ddr),\n-\t\t\t\t    dist_v, &init_b, &index_carry))\n+  if (!build_classic_dist_vector_1 (ddr, 0, 1, dist_v, &init_b, &index_carry))\n     return false;\n \n   /* Save the distance vector if we initialized one.  */\n@@ -4142,12 +4425,11 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n       if (!lambda_vector_lexico_pos (dist_v, DDR_NB_LOOPS (ddr)))\n \t{\n \t  lambda_vector save_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n-\t  if (!subscript_dependence_tester_1 (ddr, DDR_B (ddr), DDR_A (ddr),\n-\t\t\t\t\t      loop_nest))\n+\t  if (!subscript_dependence_tester_1 (ddr, 1, 0, loop_nest))\n \t    return false;\n \t  compute_subscript_distance (ddr);\n-\t  if (!build_classic_dist_vector_1 (ddr, DDR_B (ddr), DDR_A (ddr),\n-\t\t\t\t\t    save_v, &init_b, &index_carry))\n+\t  if (!build_classic_dist_vector_1 (ddr, 1, 0, save_v, &init_b,\n+\t\t\t\t\t    &index_carry))\n \t    return false;\n \t  save_dist_v (ddr, save_v);\n \t  DDR_REVERSED_P (ddr) = true;\n@@ -4183,12 +4465,10 @@ build_classic_dist_vector (struct data_dependence_relation *ddr,\n \t    {\n \t      lambda_vector opposite_v = lambda_vector_new (DDR_NB_LOOPS (ddr));\n \n-\t      if (!subscript_dependence_tester_1 (ddr, DDR_B (ddr),\n-\t\t\t\t\t\t  DDR_A (ddr), loop_nest))\n+\t      if (!subscript_dependence_tester_1 (ddr, 1, 0, loop_nest))\n \t\treturn false;\n \t      compute_subscript_distance (ddr);\n-\t      if (!build_classic_dist_vector_1 (ddr, DDR_B (ddr), DDR_A (ddr),\n-\t\t\t\t\t\topposite_v, &init_b,\n+\t      if (!build_classic_dist_vector_1 (ddr, 1, 0, opposite_v, &init_b,\n \t\t\t\t\t\t&index_carry))\n \t\treturn false;\n \n@@ -4267,13 +4547,13 @@ build_classic_dir_vector (struct data_dependence_relation *ddr)\n     }\n }\n \n-/* Helper function.  Returns true when there is a dependence between\n-   data references DRA and DRB.  */\n+/* Helper function.  Returns true when there is a dependence between the\n+   data references.  A_INDEX is the index of the first reference (0 for\n+   DDR_A, 1 for DDR_B) and B_INDEX is the index of the second reference.  */\n \n static bool\n subscript_dependence_tester_1 (struct data_dependence_relation *ddr,\n-\t\t\t       struct data_reference *dra,\n-\t\t\t       struct data_reference *drb,\n+\t\t\t       unsigned int a_index, unsigned int b_index,\n \t\t\t       struct loop *loop_nest)\n {\n   unsigned int i;\n@@ -4285,8 +4565,8 @@ subscript_dependence_tester_1 (struct data_dependence_relation *ddr,\n     {\n       conflict_function *overlaps_a, *overlaps_b;\n \n-      analyze_overlapping_iterations (DR_ACCESS_FN (dra, i),\n-\t\t\t\t      DR_ACCESS_FN (drb, i),\n+      analyze_overlapping_iterations (SUB_ACCESS_FN (subscript, a_index),\n+\t\t\t\t      SUB_ACCESS_FN (subscript, b_index),\n \t\t\t\t      &overlaps_a, &overlaps_b,\n \t\t\t\t      &last_conflicts, loop_nest);\n \n@@ -4335,7 +4615,7 @@ static void\n subscript_dependence_tester (struct data_dependence_relation *ddr,\n \t\t\t     struct loop *loop_nest)\n {\n-  if (subscript_dependence_tester_1 (ddr, DDR_A (ddr), DDR_B (ddr), loop_nest))\n+  if (subscript_dependence_tester_1 (ddr, 0, 1, loop_nest))\n     dependence_stats.num_dependence_dependent++;\n \n   compute_subscript_distance (ddr);"}, {"sha": "ef02df7b179027acab1766d446195b4dc1cc4c79", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "patch": "@@ -260,6 +260,9 @@ struct conflict_function\n \n struct subscript\n {\n+  /* The access functions of the two references.  */\n+  tree access_fn[2];\n+\n   /* A description of the iterations for which the elements are\n      accessed twice.  */\n   conflict_function *conflicting_iterations_in_a;\n@@ -278,6 +281,7 @@ struct subscript\n \n typedef struct subscript *subscript_p;\n \n+#define SUB_ACCESS_FN(SUB, I) (SUB)->access_fn[I]\n #define SUB_CONFLICTS_IN_A(SUB) (SUB)->conflicting_iterations_in_a\n #define SUB_CONFLICTS_IN_B(SUB) (SUB)->conflicting_iterations_in_b\n #define SUB_LAST_CONFLICT(SUB) (SUB)->last_conflict\n@@ -333,6 +337,33 @@ struct data_dependence_relation\n   /* Set to true when the dependence relation is on the same data\n      access.  */\n   bool self_reference_p;\n+\n+  /* True if the dependence described is conservatively correct rather\n+     than exact, and if it is still possible for the accesses to be\n+     conditionally independent.  For example, the a and b references in:\n+\n+       struct s *a, *b;\n+       for (int i = 0; i < n; ++i)\n+         a->f[i] += b->f[i];\n+\n+     conservatively have a distance vector of (0), for the case in which\n+     a == b, but the accesses are independent if a != b.  Similarly,\n+     the a and b references in:\n+\n+       struct s *a, *b;\n+       for (int i = 0; i < n; ++i)\n+         a[0].f[i] += b[i].f[i];\n+\n+     conservatively have a distance vector of (0), but they are indepenent\n+     when a != b + i.  In contrast, the references in:\n+\n+       struct s *a;\n+       for (int i = 0; i < n; ++i)\n+         a->f[i] += a->f[i];\n+\n+     have the same distance vector of (0), but the accesses can never be\n+     independent.  */\n+  bool could_be_independent_p;\n };\n \n typedef struct data_dependence_relation *ddr_p;\n@@ -363,6 +394,7 @@ typedef struct data_dependence_relation *ddr_p;\n #define DDR_DIST_VECT(DDR, I) \\\n   DDR_DIST_VECTS (DDR)[I]\n #define DDR_REVERSED_P(DDR) (DDR)->reversed_p\n+#define DDR_COULD_BE_INDEPENDENT_P(DDR) (DDR)->could_be_independent_p\n \n \f\n bool dr_analyze_innermost (innermost_loop_behavior *, tree, struct loop *);\n@@ -459,22 +491,6 @@ same_data_refs (data_reference_p a, data_reference_p b)\n   return true;\n }\n \n-/* Return true when the DDR contains two data references that have the\n-   same access functions.  */\n-\n-static inline bool\n-same_access_functions (const struct data_dependence_relation *ddr)\n-{\n-  unsigned i;\n-\n-  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n-    if (!eq_evolutions_p (DR_ACCESS_FN (DDR_A (ddr), i),\n-\t\t\t  DR_ACCESS_FN (DDR_B (ddr), i)))\n-      return false;\n-\n-  return true;\n-}\n-\n /* Returns true when all the dependences are computable.  */\n \n inline bool"}, {"sha": "f8ad6b602f6acf66528dce4f1f3c4f38c20fa5f7", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "patch": "@@ -1668,6 +1668,7 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n       refb = (struct mem_ref *) DDR_B (dep)->aux;\n \n       if (DDR_ARE_DEPENDENT (dep) == chrec_dont_know\n+\t  || DDR_COULD_BE_INDEPENDENT_P (dep)\n \t  || DDR_NUM_DIST_VECTS (dep) == 0)\n \t{\n \t  /* If the dependence cannot be analyzed, assume that there might be"}, {"sha": "377cb90bbb0149246c8f8563be7abe1570d651a5", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 107, "deletions": 4, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "patch": "@@ -160,6 +160,60 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n }\n \n \n+/* A subroutine of vect_analyze_data_ref_dependence.  Handle\n+   DDR_COULD_BE_INDEPENDENT_P ddr DDR that has a known set of dependence\n+   distances.  These distances are conservatively correct but they don't\n+   reflect a guaranteed dependence.\n+\n+   Return true if this function does all the work necessary to avoid\n+   an alias or false if the caller should use the dependence distances\n+   to limit the vectorization factor in the usual way.  LOOP_DEPTH is\n+   the depth of the loop described by LOOP_VINFO and the other arguments\n+   are as for vect_analyze_data_ref_dependence.  */\n+\n+static bool\n+vect_analyze_possibly_independent_ddr (data_dependence_relation *ddr,\n+\t\t\t\t       loop_vec_info loop_vinfo,\n+\t\t\t\t       int loop_depth, int *max_vf)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  lambda_vector dist_v;\n+  unsigned int i;\n+  FOR_EACH_VEC_ELT (DDR_DIST_VECTS (ddr), i, dist_v)\n+    {\n+      int dist = dist_v[loop_depth];\n+      if (dist != 0 && !(dist > 0 && DDR_REVERSED_P (ddr)))\n+\t{\n+\t  /* If the user asserted safelen >= DIST consecutive iterations\n+\t     can be executed concurrently, assume independence.\n+\n+\t     ??? An alternative would be to add the alias check even\n+\t     in this case, and vectorize the fallback loop with the\n+\t     maximum VF set to safelen.  However, if the user has\n+\t     explicitly given a length, it's less likely that that\n+\t     would be a win.  */\n+\t  if (loop->safelen >= 2 && abs_hwi (dist) <= loop->safelen)\n+\t    {\n+\t      if (loop->safelen < *max_vf)\n+\t\t*max_vf = loop->safelen;\n+\t      LOOP_VINFO_NO_DATA_DEPENDENCIES (loop_vinfo) = false;\n+\t      continue;\n+\t    }\n+\n+\t  /* For dependence distances of 2 or more, we have the option\n+\t     of limiting VF or checking for an alias at runtime.\n+\t     Prefer to check at runtime if we can, to avoid limiting\n+\t     the VF unnecessarily when the bases are in fact independent.\n+\n+\t     Note that the alias checks will be removed if the VF ends up\n+\t     being small enough.  */\n+\t  return vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n+\t}\n+    }\n+  return true;\n+}\n+\n+\n /* Function vect_analyze_data_ref_dependence.\n \n    Return TRUE if there (might) exist a dependence between a memory-reference\n@@ -305,6 +359,12 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n     }\n \n   loop_depth = index_in_loop_nest (loop->num, DDR_LOOP_NEST (ddr));\n+\n+  if (DDR_COULD_BE_INDEPENDENT_P (ddr)\n+      && vect_analyze_possibly_independent_ddr (ddr, loop_vinfo,\n+\t\t\t\t\t\tloop_depth, max_vf))\n+    return false;\n+\n   FOR_EACH_VEC_ELT (DDR_DIST_VECTS (ddr), i, dist_v)\n     {\n       int dist = dist_v[loop_depth];\n@@ -2878,6 +2938,44 @@ vect_no_alias_p (struct data_reference *a, struct data_reference *b,\n   return false;\n }\n \n+/* Return true if the minimum nonzero dependence distance for loop LOOP_DEPTH\n+   in DDR is >= VF.  */\n+\n+static bool\n+dependence_distance_ge_vf (data_dependence_relation *ddr,\n+\t\t\t   unsigned int loop_depth, unsigned HOST_WIDE_INT vf)\n+{\n+  if (DDR_ARE_DEPENDENT (ddr) != NULL_TREE\n+      || DDR_NUM_DIST_VECTS (ddr) == 0)\n+    return false;\n+\n+  /* If the dependence is exact, we should have limited the VF instead.  */\n+  gcc_checking_assert (DDR_COULD_BE_INDEPENDENT_P (ddr));\n+\n+  unsigned int i;\n+  lambda_vector dist_v;\n+  FOR_EACH_VEC_ELT (DDR_DIST_VECTS (ddr), i, dist_v)\n+    {\n+      HOST_WIDE_INT dist = dist_v[loop_depth];\n+      if (dist != 0\n+\t  && !(dist > 0 && DDR_REVERSED_P (ddr))\n+\t  && (unsigned HOST_WIDE_INT) abs_hwi (dist) < vf)\n+\treturn false;\n+    }\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"dependence distance between \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_A (ddr)));\n+      dump_printf (MSG_NOTE,  \" and \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_B (ddr)));\n+      dump_printf (MSG_NOTE,  \" is >= VF\\n\");\n+    }\n+\n+  return true;\n+}\n+\n /* Function vect_prune_runtime_alias_test_list.\n \n    Prune a list of ddrs to be tested at run-time by versioning for alias.\n@@ -2908,6 +3006,10 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \n   comp_alias_ddrs.create (may_alias_ddrs.length ());\n \n+  unsigned int loop_depth\n+    = index_in_loop_nest (LOOP_VINFO_LOOP (loop_vinfo)->num,\n+\t\t\t  LOOP_VINFO_LOOP_NEST (loop_vinfo));\n+\n   /* First, we collect all data ref pairs for aliasing checks.  */\n   FOR_EACH_VEC_ELT (may_alias_ddrs, i, ddr)\n     {\n@@ -2917,6 +3019,11 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n       tree segment_length_a, segment_length_b;\n       gimple *stmt_a, *stmt_b;\n \n+      /* Ignore the alias if the VF we chose ended up being no greater\n+\t than the dependence distance.  */\n+      if (dependence_distance_ge_vf (ddr, loop_depth, vect_factor))\n+\tcontinue;\n+\n       dr_a = DDR_A (ddr);\n       stmt_a = DR_STMT (DDR_A (ddr));\n       dr_group_first_a = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_a));\n@@ -2993,10 +3100,6 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n       return false;\n     }\n \n-  /* All alias checks have been resolved at compilation time.  */\n-  if (!comp_alias_ddrs.length ())\n-    LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo).truncate (0);\n-\n   return true;\n }\n "}, {"sha": "cae0668bb4505ba8f4f523fa398d56801acd7df5", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=dfbddbeb1ca912c9f9f806d8cff55a6ac2887d89", "patch": "@@ -358,7 +358,7 @@ typedef struct _loop_vec_info : public vec_info {\n #define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L)\t\\\n   ((L)->may_misalign_stmts.length () > 0)\n #define LOOP_REQUIRES_VERSIONING_FOR_ALIAS(L)\t\t\\\n-  ((L)->may_alias_ddrs.length () > 0)\n+  ((L)->comp_alias_ddrs.length () > 0)\n #define LOOP_REQUIRES_VERSIONING_FOR_NITERS(L)\t\t\\\n   (LOOP_VINFO_NITERS_ASSUMPTIONS (L))\n #define LOOP_REQUIRES_VERSIONING(L)\t\t\t\\"}]}