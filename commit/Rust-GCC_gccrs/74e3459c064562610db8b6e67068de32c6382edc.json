{"sha": "74e3459c064562610db8b6e67068de32c6382edc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRlMzQ1OWMwNjQ1NjI2MTBkYjhiNmU2NzA2OGRlMzJjNjM4MmVkYw==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-01-06T21:53:03Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-01-06T21:53:03Z"}, "message": "arith.c: Update copyright years.\n\n    * arith.c: Update copyright years.  Whitespace.\n\nFrom-SVN: r120530", "tree": {"sha": "27758ccd9794f4c82e869627964a47ef6bcb27e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27758ccd9794f4c82e869627964a47ef6bcb27e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74e3459c064562610db8b6e67068de32c6382edc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74e3459c064562610db8b6e67068de32c6382edc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74e3459c064562610db8b6e67068de32c6382edc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74e3459c064562610db8b6e67068de32c6382edc/comments", "author": null, "committer": null, "parents": [{"sha": "2f82a97b021ee9741d03914752f22e93de441206", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f82a97b021ee9741d03914752f22e93de441206", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f82a97b021ee9741d03914752f22e93de441206"}], "stats": {"total": 319, "additions": 154, "deletions": 165}, "files": [{"sha": "3ed8861e2ad20a1b44a70546c717850352204306", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e3459c064562610db8b6e67068de32c6382edc/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e3459c064562610db8b6e67068de32c6382edc/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=74e3459c064562610db8b6e67068de32c6382edc", "patch": "@@ -1,3 +1,7 @@\n+2007-01-05  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\t* arith.c: Update copyright years.  Whitespace.\n+\n 2007-01-05  Roger Sayle  <roger@eyesopen.com>\n \n \t* trans-expr.c (gfc_trans_assignment_1): New subroutine to scalarize"}, {"sha": "f92de48c20da037c81a615c942fd7a9025f206c9", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 150, "deletions": 165, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74e3459c064562610db8b6e67068de32c6382edc/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74e3459c064562610db8b6e67068de32c6382edc/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=74e3459c064562610db8b6e67068de32c6382edc", "patch": "@@ -1,5 +1,5 @@\n /* Compiler arithmetic\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -143,16 +143,16 @@ gfc_arith_init_1 (void)\n       mpz_sub_ui (int_info->huge, r, 1);\n \n       /* These are the numbers that are actually representable by the\n-         target.  For bases other than two, this needs to be changed.  */\n+\t target.  For bases other than two, this needs to be changed.  */\n       if (int_info->radix != 2)\n-        gfc_internal_error (\"Fix min_int calculation\");\n+\tgfc_internal_error (\"Fix min_int calculation\");\n \n       /* See PRs 13490 and 17912, related to integer ranges.\n-         The pedantic_min_int exists for range checking when a program\n-         is compiled with -pedantic, and reflects the belief that\n-         Standard Fortran requires integers to be symmetrical, i.e.\n-         every negative integer must have a representable positive\n-         absolute value, and vice versa.  */\n+\t The pedantic_min_int exists for range checking when a program\n+\t is compiled with -pedantic, and reflects the belief that\n+\t Standard Fortran requires integers to be symmetrical, i.e.\n+\t every negative integer must have a representable positive\n+\t absolute value, and vice versa.  */\n \n       mpz_init (int_info->pedantic_min_int);\n       mpz_neg (int_info->pedantic_min_int, int_info->huge);\n@@ -297,7 +297,7 @@ gfc_check_integer_range (mpz_t p, int kind)\n   if (pedantic)\n     {\n       if (mpz_cmp (p, gfc_integer_kinds[i].pedantic_min_int) < 0)\n-        result = ARITH_ASYMMETRIC;\n+\tresult = ARITH_ASYMMETRIC;\n     }\n \n \n@@ -332,32 +332,32 @@ gfc_check_real_range (mpfr_t p, int kind)\n   if (mpfr_inf_p (p))\n     {\n       if (gfc_option.flag_range_check == 0)\n-        retval = ARITH_OK;\n+\tretval = ARITH_OK;\n       else\n-        retval = ARITH_OVERFLOW;\n+\tretval = ARITH_OVERFLOW;\n     }\n   else if (mpfr_nan_p (p))\n     {\n       if (gfc_option.flag_range_check == 0)\n-        retval = ARITH_OK;\n+\tretval = ARITH_OK;\n       else\n-        retval = ARITH_NAN;\n+\tretval = ARITH_NAN;\n     }\n   else if (mpfr_sgn (q) == 0)\n     retval = ARITH_OK;\n   else if (mpfr_cmp (q, gfc_real_kinds[i].huge) > 0)\n     {\n       if (gfc_option.flag_range_check == 0)\n-        retval = ARITH_OK;\n+\tretval = ARITH_OK;\n       else\n-        retval = ARITH_OVERFLOW;\n+\tretval = ARITH_OVERFLOW;\n     }\n   else if (mpfr_cmp (q, gfc_real_kinds[i].subnormal) < 0)\n     {\n       if (gfc_option.flag_range_check == 0)\n-        retval = ARITH_OK;\n+\tretval = ARITH_OK;\n       else\n-        retval = ARITH_UNDERFLOW;\n+\tretval = ARITH_UNDERFLOW;\n     }\n   else if (mpfr_cmp (q, gfc_real_kinds[i].tiny) < 0)\n     {\n@@ -398,13 +398,12 @@ gfc_check_real_range (mpfr_t p, int kind)\n /* Function to return a constant expression node of a given type and kind.  */\n \n gfc_expr *\n-gfc_constant_result (bt type, int kind, locus * where)\n+gfc_constant_result (bt type, int kind, locus *where)\n {\n   gfc_expr *result;\n \n   if (!where)\n-    gfc_internal_error\n-      (\"gfc_constant_result(): locus 'where' cannot be NULL\");\n+    gfc_internal_error (\"gfc_constant_result(): locus 'where' cannot be NULL\");\n \n   result = gfc_get_expr ();\n \n@@ -445,7 +444,7 @@ gfc_constant_result (bt type, int kind, locus * where)\n    zero raised to the zero, etc.  */\n \n static arith\n-gfc_arith_not (gfc_expr * op1, gfc_expr ** resultp)\n+gfc_arith_not (gfc_expr *op1, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n@@ -458,7 +457,7 @@ gfc_arith_not (gfc_expr * op1, gfc_expr ** resultp)\n \n \n static arith\n-gfc_arith_and (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_and (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n@@ -472,7 +471,7 @@ gfc_arith_and (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n \n static arith\n-gfc_arith_or (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_or (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n@@ -486,7 +485,7 @@ gfc_arith_or (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n \n static arith\n-gfc_arith_eqv (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_eqv (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n@@ -500,7 +499,7 @@ gfc_arith_eqv (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n \n static arith\n-gfc_arith_neqv (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_neqv (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n@@ -518,7 +517,7 @@ gfc_arith_neqv (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n    but that one deals with the intrinsic RANGE function.  */\n \n arith\n-gfc_range_check (gfc_expr * e)\n+gfc_range_check (gfc_expr *e)\n {\n   arith rc;\n \n@@ -568,7 +567,7 @@ gfc_range_check (gfc_expr * e)\n    check the validity of the result.  Encapsulate the checking here.  */\n \n static arith\n-check_result (arith rc, gfc_expr * x, gfc_expr * r, gfc_expr ** rp)\n+check_result (arith rc, gfc_expr *x, gfc_expr *r, gfc_expr **rp)\n {\n   arith val = rc;\n \n@@ -599,15 +598,15 @@ check_result (arith rc, gfc_expr * x, gfc_expr * r, gfc_expr ** rp)\n    in the code elsewhere.  */\n \n static arith\n-gfc_arith_uplus (gfc_expr * op1, gfc_expr ** resultp)\n+gfc_arith_uplus (gfc_expr *op1, gfc_expr **resultp)\n {\n   *resultp = gfc_copy_expr (op1);\n   return ARITH_OK;\n }\n \n \n static arith\n-gfc_arith_uminus (gfc_expr * op1, gfc_expr ** resultp)\n+gfc_arith_uminus (gfc_expr *op1, gfc_expr **resultp)\n {\n   gfc_expr *result;\n   arith rc;\n@@ -640,7 +639,7 @@ gfc_arith_uminus (gfc_expr * op1, gfc_expr ** resultp)\n \n \n static arith\n-gfc_arith_plus (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_plus (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n   arith rc;\n@@ -655,15 +654,15 @@ gfc_arith_plus (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n     case BT_REAL:\n       mpfr_add (result->value.real, op1->value.real, op2->value.real,\n-               GFC_RND_MODE);\n+\t       GFC_RND_MODE);\n       break;\n \n     case BT_COMPLEX:\n       mpfr_add (result->value.complex.r, op1->value.complex.r,\n-\t       op2->value.complex.r, GFC_RND_MODE);\n+\t\top2->value.complex.r, GFC_RND_MODE);\n \n       mpfr_add (result->value.complex.i, op1->value.complex.i,\n-\t       op2->value.complex.i, GFC_RND_MODE);\n+\t\top2->value.complex.i, GFC_RND_MODE);\n       break;\n \n     default:\n@@ -677,7 +676,7 @@ gfc_arith_plus (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n \n static arith\n-gfc_arith_minus (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_minus (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n   arith rc;\n@@ -692,15 +691,15 @@ gfc_arith_minus (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n     case BT_REAL:\n       mpfr_sub (result->value.real, op1->value.real, op2->value.real,\n-                GFC_RND_MODE);\n+\t\tGFC_RND_MODE);\n       break;\n \n     case BT_COMPLEX:\n       mpfr_sub (result->value.complex.r, op1->value.complex.r,\n-\t       op2->value.complex.r, GFC_RND_MODE);\n+\t\top2->value.complex.r, GFC_RND_MODE);\n \n       mpfr_sub (result->value.complex.i, op1->value.complex.i,\n-\t       op2->value.complex.i, GFC_RND_MODE);\n+\t\top2->value.complex.i, GFC_RND_MODE);\n       break;\n \n     default:\n@@ -714,7 +713,7 @@ gfc_arith_minus (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n \n static arith\n-gfc_arith_times (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_times (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n   mpfr_t x, y;\n@@ -730,7 +729,7 @@ gfc_arith_times (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n     case BT_REAL:\n       mpfr_mul (result->value.real, op1->value.real, op2->value.real,\n-               GFC_RND_MODE);\n+\t       GFC_RND_MODE);\n       break;\n \n     case BT_COMPLEX:\n@@ -761,7 +760,7 @@ gfc_arith_times (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n \n static arith\n-gfc_arith_divide (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_divide (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n   mpfr_t x, y, div;\n@@ -785,15 +784,14 @@ gfc_arith_divide (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       break;\n \n     case BT_REAL:\n-      if (mpfr_sgn (op2->value.real) == 0\n-\t  && gfc_option.flag_range_check == 1)\n+      if (mpfr_sgn (op2->value.real) == 0 && gfc_option.flag_range_check == 1)\n \t{\n \t  rc = ARITH_DIV0;\n \t  break;\n \t}\n \n       mpfr_div (result->value.real, op1->value.real, op2->value.real,\n-               GFC_RND_MODE);\n+\t       GFC_RND_MODE);\n       break;\n \n     case BT_COMPLEX:\n@@ -818,13 +816,13 @@ gfc_arith_divide (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n       mpfr_mul (y, op1->value.complex.i, op2->value.complex.i, GFC_RND_MODE);\n       mpfr_add (result->value.complex.r, x, y, GFC_RND_MODE);\n       mpfr_div (result->value.complex.r, result->value.complex.r, div,\n-                GFC_RND_MODE);\n+\t\tGFC_RND_MODE);\n \n       mpfr_mul (x, op1->value.complex.i, op2->value.complex.r, GFC_RND_MODE);\n       mpfr_mul (y, op1->value.complex.r, op2->value.complex.i, GFC_RND_MODE);\n       mpfr_sub (result->value.complex.i, x, y, GFC_RND_MODE);\n       mpfr_div (result->value.complex.i, result->value.complex.i, div,\n-                GFC_RND_MODE);\n+\t\tGFC_RND_MODE);\n \n       mpfr_clear (x);\n       mpfr_clear (y);\n@@ -845,7 +843,7 @@ gfc_arith_divide (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n /* Compute the reciprocal of a complex number (guaranteed nonzero).  */\n \n static void\n-complex_reciprocal (gfc_expr * op)\n+complex_reciprocal (gfc_expr *op)\n {\n   mpfr_t mod, a, re, im;\n \n@@ -877,7 +875,7 @@ complex_reciprocal (gfc_expr * op)\n /* Raise a complex number to positive power.  */\n \n static void\n-complex_pow_ui (gfc_expr * base, int power, gfc_expr * result)\n+complex_pow_ui (gfc_expr *base, int power, gfc_expr *result)\n {\n   mpfr_t re, im, a;\n \n@@ -892,15 +890,15 @@ complex_pow_ui (gfc_expr * base, int power, gfc_expr * result)\n   for (; power > 0; power--)\n     {\n       mpfr_mul (re, base->value.complex.r, result->value.complex.r,\n-                GFC_RND_MODE);\n+\t\tGFC_RND_MODE);\n       mpfr_mul (a, base->value.complex.i, result->value.complex.i,\n-                GFC_RND_MODE);\n+\t\tGFC_RND_MODE);\n       mpfr_sub (re, re, a, GFC_RND_MODE);\n \n       mpfr_mul (im, base->value.complex.r, result->value.complex.i,\n-                GFC_RND_MODE);\n+\t\tGFC_RND_MODE);\n       mpfr_mul (a, base->value.complex.i, result->value.complex.r,\n-                GFC_RND_MODE);\n+\t\tGFC_RND_MODE);\n       mpfr_add (im, im, a, GFC_RND_MODE);\n \n       mpfr_set (result->value.complex.r, re, GFC_RND_MODE);\n@@ -916,7 +914,7 @@ complex_pow_ui (gfc_expr * base, int power, gfc_expr * result)\n /* Raise a number to an integer power.  */\n \n static arith\n-gfc_arith_power (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   int power, apower;\n   gfc_expr *result;\n@@ -977,15 +975,15 @@ gfc_arith_power (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n \tcase BT_REAL:\n \t  mpfr_pow_ui (result->value.real, op1->value.real, apower,\n-                       GFC_RND_MODE);\n+\t\t       GFC_RND_MODE);\n \n \t  if (power < 0)\n \t    {\n-              gfc_set_model (op1->value.real);\n+\t      gfc_set_model (op1->value.real);\n \t      mpfr_init (unity_f);\n \t      mpfr_set_ui (unity_f, 1, GFC_RND_MODE);\n \t      mpfr_div (result->value.real, unity_f, result->value.real,\n-                        GFC_RND_MODE);\n+\t\t\tGFC_RND_MODE);\n \t      mpfr_clear (unity_f);\n \t    }\n \t  break;\n@@ -1011,7 +1009,7 @@ gfc_arith_power (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n /* Concatenate two string constants.  */\n \n static arith\n-gfc_arith_concat (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_concat (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n   int len;\n@@ -1042,7 +1040,7 @@ gfc_arith_concat (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n    contain two constants of the same type.  */\n \n int\n-gfc_compare_expr (gfc_expr * op1, gfc_expr * op2)\n+gfc_compare_expr (gfc_expr *op1, gfc_expr *op2)\n {\n   int rc;\n \n@@ -1077,7 +1075,7 @@ gfc_compare_expr (gfc_expr * op1, gfc_expr * op2)\n    equality and nonequality.  */\n \n static int\n-compare_complex (gfc_expr * op1, gfc_expr * op2)\n+compare_complex (gfc_expr *op1, gfc_expr *op2)\n {\n   return (mpfr_cmp (op1->value.complex.r, op2->value.complex.r) == 0\n \t  && mpfr_cmp (op1->value.complex.i, op2->value.complex.i) == 0);\n@@ -1089,7 +1087,7 @@ compare_complex (gfc_expr * op1, gfc_expr * op2)\n    xcoll_table is NULL, we use the processor's default collating sequence.  */\n \n int\n-gfc_compare_string (gfc_expr * a, gfc_expr * b, const int * xcoll_table)\n+gfc_compare_string (gfc_expr *a, gfc_expr *b, const int *xcoll_table)\n {\n   int len, alen, blen, i, ac, bc;\n \n@@ -1101,7 +1099,7 @@ gfc_compare_string (gfc_expr * a, gfc_expr * b, const int * xcoll_table)\n   for (i = 0; i < len; i++)\n     {\n       /* We cast to unsigned char because default char, if it is signed,\n-         would lead to ac < 0 for string[i] > 127.  */\n+\t would lead to ac < 0 for string[i] > 127.  */\n       ac = (unsigned char) ((i < alen) ? a->value.character.string[i] : ' ');\n       bc = (unsigned char) ((i < blen) ? b->value.character.string[i] : ' ');\n \n@@ -1126,37 +1124,39 @@ gfc_compare_string (gfc_expr * a, gfc_expr * b, const int * xcoll_table)\n /* Specific comparison subroutines.  */\n \n static arith\n-gfc_arith_eq (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_eq (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n   result = gfc_constant_result (BT_LOGICAL, gfc_default_logical_kind,\n \t\t\t\t&op1->where);\n-  result->value.logical = (op1->ts.type == BT_COMPLEX) ?\n-    compare_complex (op1, op2) : (gfc_compare_expr (op1, op2) == 0);\n+  result->value.logical = (op1->ts.type == BT_COMPLEX)\n+\t\t\t? compare_complex (op1, op2)\n+\t\t\t: (gfc_compare_expr (op1, op2) == 0);\n \n   *resultp = result;\n   return ARITH_OK;\n }\n \n \n static arith\n-gfc_arith_ne (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_ne (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n   result = gfc_constant_result (BT_LOGICAL, gfc_default_logical_kind,\n \t\t\t\t&op1->where);\n-  result->value.logical = (op1->ts.type == BT_COMPLEX) ?\n-    !compare_complex (op1, op2) : (gfc_compare_expr (op1, op2) != 0);\n+  result->value.logical = (op1->ts.type == BT_COMPLEX)\n+\t\t\t? !compare_complex (op1, op2)\n+\t\t\t: (gfc_compare_expr (op1, op2) != 0);\n \n   *resultp = result;\n   return ARITH_OK;\n }\n \n \n static arith\n-gfc_arith_gt (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_gt (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n@@ -1170,7 +1170,7 @@ gfc_arith_gt (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n \n static arith\n-gfc_arith_ge (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_ge (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n@@ -1184,7 +1184,7 @@ gfc_arith_ge (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n \n static arith\n-gfc_arith_lt (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_lt (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n@@ -1198,7 +1198,7 @@ gfc_arith_lt (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n \n static arith\n-gfc_arith_le (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n+gfc_arith_le (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   gfc_expr *result;\n \n@@ -1212,8 +1212,8 @@ gfc_arith_le (gfc_expr * op1, gfc_expr * op2, gfc_expr ** resultp)\n \n \n static arith\n-reduce_unary (arith (*eval) (gfc_expr *, gfc_expr **), gfc_expr * op,\n-\t      gfc_expr ** result)\n+reduce_unary (arith (*eval) (gfc_expr *, gfc_expr **), gfc_expr *op,\n+\t      gfc_expr **result)\n {\n   gfc_constructor *c, *head;\n   gfc_expr *r;\n@@ -1256,8 +1256,7 @@ reduce_unary (arith (*eval) (gfc_expr *, gfc_expr **), gfc_expr * op,\n \n static arith\n reduce_binary_ac (arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n-\t\t  gfc_expr * op1, gfc_expr * op2,\n-\t\t  gfc_expr ** result)\n+\t\t  gfc_expr *op1, gfc_expr *op2, gfc_expr **result)\n {\n   gfc_constructor *c, *head;\n   gfc_expr *r;\n@@ -1297,8 +1296,7 @@ reduce_binary_ac (arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n \n static arith\n reduce_binary_ca (arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n-\t\t  gfc_expr * op1, gfc_expr * op2,\n-\t\t  gfc_expr ** result)\n+\t\t  gfc_expr *op1, gfc_expr *op2, gfc_expr **result)\n {\n   gfc_constructor *c, *head;\n   gfc_expr *r;\n@@ -1338,8 +1336,7 @@ reduce_binary_ca (arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n \n static arith\n reduce_binary_aa (arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n-\t\t  gfc_expr * op1, gfc_expr * op2,\n-\t\t  gfc_expr ** result)\n+\t\t  gfc_expr *op1, gfc_expr *op2, gfc_expr **result)\n {\n   gfc_constructor *c, *d, *head;\n   gfc_expr *r;\n@@ -1355,7 +1352,6 @@ reduce_binary_aa (arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n     rc = ARITH_INCOMMENSURATE;\n   else\n     {\n-\n       for (c = head; c; c = c->next, d = d->next)\n \t{\n \t  if (d == NULL)\n@@ -1397,8 +1393,7 @@ reduce_binary_aa (arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n \n static arith\n reduce_binary (arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n-\t       gfc_expr * op1, gfc_expr * op2,\n-\t       gfc_expr ** result)\n+\t       gfc_expr *op1, gfc_expr *op2, gfc_expr **result)\n {\n   if (op1->expr_type == EXPR_CONSTANT && op2->expr_type == EXPR_CONSTANT)\n     return eval (op1, op2, result);\n@@ -1432,7 +1427,7 @@ eval_f;\n \n static gfc_expr *\n eval_intrinsic (gfc_intrinsic_op operator,\n-\t\teval_f eval, gfc_expr * op1, gfc_expr * op2)\n+\t\teval_f eval, gfc_expr *op1, gfc_expr *op2)\n {\n   gfc_expr temp, *result;\n   int unary;\n@@ -1449,7 +1444,6 @@ eval_intrinsic (gfc_intrinsic_op operator,\n \n       temp.ts.type = BT_LOGICAL;\n       temp.ts.kind = gfc_default_logical_kind;\n-\n       unary = 1;\n       break;\n \n@@ -1463,7 +1457,6 @@ eval_intrinsic (gfc_intrinsic_op operator,\n \n       temp.ts.type = BT_LOGICAL;\n       temp.ts.kind = gfc_default_logical_kind;\n-\n       unary = 0;\n       break;\n \n@@ -1474,13 +1467,11 @@ eval_intrinsic (gfc_intrinsic_op operator,\n \tgoto runtime;\n \n       temp.ts = op1->ts;\n-\n       unary = 1;\n       break;\n \n     case INTRINSIC_PARENTHESES:\n       temp.ts = op1->ts;\n-\n       unary = 1;\n       break;\n \n@@ -1547,7 +1538,6 @@ eval_intrinsic (gfc_intrinsic_op operator,\n \n       temp.ts.type = BT_CHARACTER;\n       temp.ts.kind = gfc_default_character_kind;\n-\n       unary = 0;\n       break;\n \n@@ -1565,16 +1555,14 @@ eval_intrinsic (gfc_intrinsic_op operator,\n   if (op1->from_H\n       || (op1->expr_type != EXPR_CONSTANT\n \t  && (op1->expr_type != EXPR_ARRAY\n-\t      || !gfc_is_constant_expr (op1)\n-\t      || !gfc_expanded_ac (op1))))\n+\t      || !gfc_is_constant_expr (op1) || !gfc_expanded_ac (op1))))\n     goto runtime;\n \n   if (op2 != NULL\n       && (op2->from_H\n \t  || (op2->expr_type != EXPR_CONSTANT\n \t      && (op2->expr_type != EXPR_ARRAY\n-\t      || !gfc_is_constant_expr (op2)\n-\t      || !gfc_expanded_ac (op2)))))\n+\t\t  || !gfc_is_constant_expr (op2) || !gfc_expanded_ac (op2)))))\n     goto runtime;\n \n   if (unary)\n@@ -1612,7 +1600,7 @@ eval_intrinsic (gfc_intrinsic_op operator,\n /* Modify type of expression for zero size array.  */\n \n static gfc_expr *\n-eval_type_intrinsic0 (gfc_intrinsic_op operator, gfc_expr * op)\n+eval_type_intrinsic0 (gfc_intrinsic_op operator, gfc_expr *op)\n {\n   if (op == NULL)\n     gfc_internal_error (\"eval_type_intrinsic0(): op NULL\");\n@@ -1640,7 +1628,7 @@ eval_type_intrinsic0 (gfc_intrinsic_op operator, gfc_expr * op)\n /* Return nonzero if the expression is a zero size array.  */\n \n static int\n-gfc_zero_size_array (gfc_expr * e)\n+gfc_zero_size_array (gfc_expr *e)\n {\n   if (e->expr_type != EXPR_ARRAY)\n     return 0;\n@@ -1654,7 +1642,7 @@ gfc_zero_size_array (gfc_expr * e)\n    operands is a zero-length array.  */\n \n static gfc_expr *\n-reduce_binary0 (gfc_expr * op1, gfc_expr * op2)\n+reduce_binary0 (gfc_expr *op1, gfc_expr *op2)\n {\n   if (gfc_zero_size_array (op1))\n     {\n@@ -1675,7 +1663,7 @@ reduce_binary0 (gfc_expr * op1, gfc_expr * op2)\n static gfc_expr *\n eval_intrinsic_f2 (gfc_intrinsic_op operator,\n \t\t   arith (*eval) (gfc_expr *, gfc_expr **),\n-\t\t   gfc_expr * op1, gfc_expr * op2)\n+\t\t   gfc_expr *op1, gfc_expr *op2)\n {\n   gfc_expr *result;\n   eval_f f;\n@@ -1700,7 +1688,7 @@ eval_intrinsic_f2 (gfc_intrinsic_op operator,\n static gfc_expr *\n eval_intrinsic_f3 (gfc_intrinsic_op operator,\n \t\t   arith (*eval) (gfc_expr *, gfc_expr *, gfc_expr **),\n-\t\t   gfc_expr * op1, gfc_expr * op2)\n+\t\t   gfc_expr *op1, gfc_expr *op2)\n {\n   gfc_expr *result;\n   eval_f f;\n@@ -1715,133 +1703,133 @@ eval_intrinsic_f3 (gfc_intrinsic_op operator,\n \n \n gfc_expr *\n-gfc_uplus (gfc_expr * op)\n+gfc_uplus (gfc_expr *op)\n {\n   return eval_intrinsic_f2 (INTRINSIC_UPLUS, gfc_arith_uplus, op, NULL);\n }\n \n \n gfc_expr *\n-gfc_uminus (gfc_expr * op)\n+gfc_uminus (gfc_expr *op)\n {\n   return eval_intrinsic_f2 (INTRINSIC_UMINUS, gfc_arith_uminus, op, NULL);\n }\n \n \n gfc_expr *\n-gfc_add (gfc_expr * op1, gfc_expr * op2)\n+gfc_add (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_PLUS, gfc_arith_plus, op1, op2);\n }\n \n \n gfc_expr *\n-gfc_subtract (gfc_expr * op1, gfc_expr * op2)\n+gfc_subtract (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_MINUS, gfc_arith_minus, op1, op2);\n }\n \n \n gfc_expr *\n-gfc_multiply (gfc_expr * op1, gfc_expr * op2)\n+gfc_multiply (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_TIMES, gfc_arith_times, op1, op2);\n }\n \n \n gfc_expr *\n-gfc_divide (gfc_expr * op1, gfc_expr * op2)\n+gfc_divide (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_DIVIDE, gfc_arith_divide, op1, op2);\n }\n \n \n gfc_expr *\n-gfc_power (gfc_expr * op1, gfc_expr * op2)\n+gfc_power (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_POWER, gfc_arith_power, op1, op2);\n }\n \n \n gfc_expr *\n-gfc_concat (gfc_expr * op1, gfc_expr * op2)\n+gfc_concat (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_CONCAT, gfc_arith_concat, op1, op2);\n }\n \n \n gfc_expr *\n-gfc_and (gfc_expr * op1, gfc_expr * op2)\n+gfc_and (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_AND, gfc_arith_and, op1, op2);\n }\n \n \n gfc_expr *\n-gfc_or (gfc_expr * op1, gfc_expr * op2)\n+gfc_or (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_OR, gfc_arith_or, op1, op2);\n }\n \n \n gfc_expr *\n-gfc_not (gfc_expr * op1)\n+gfc_not (gfc_expr *op1)\n {\n   return eval_intrinsic_f2 (INTRINSIC_NOT, gfc_arith_not, op1, NULL);\n }\n \n \n gfc_expr *\n-gfc_eqv (gfc_expr * op1, gfc_expr * op2)\n+gfc_eqv (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_EQV, gfc_arith_eqv, op1, op2);\n }\n \n \n gfc_expr *\n-gfc_neqv (gfc_expr * op1, gfc_expr * op2)\n+gfc_neqv (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_NEQV, gfc_arith_neqv, op1, op2);\n }\n \n \n gfc_expr *\n-gfc_eq (gfc_expr * op1, gfc_expr * op2)\n+gfc_eq (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_EQ, gfc_arith_eq, op1, op2);\n }\n \n \n gfc_expr *\n-gfc_ne (gfc_expr * op1, gfc_expr * op2)\n+gfc_ne (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_NE, gfc_arith_ne, op1, op2);\n }\n \n \n gfc_expr *\n-gfc_gt (gfc_expr * op1, gfc_expr * op2)\n+gfc_gt (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_GT, gfc_arith_gt, op1, op2);\n }\n \n \n gfc_expr *\n-gfc_ge (gfc_expr * op1, gfc_expr * op2)\n+gfc_ge (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_GE, gfc_arith_ge, op1, op2);\n }\n \n \n gfc_expr *\n-gfc_lt (gfc_expr * op1, gfc_expr * op2)\n+gfc_lt (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_LT, gfc_arith_lt, op1, op2);\n }\n \n \n gfc_expr *\n-gfc_le (gfc_expr * op1, gfc_expr * op2)\n+gfc_le (gfc_expr *op1, gfc_expr *op2)\n {\n   return eval_intrinsic_f3 (INTRINSIC_LE, gfc_arith_le, op1, op2);\n }\n@@ -1850,7 +1838,7 @@ gfc_le (gfc_expr * op1, gfc_expr * op2)\n /* Convert an integer string to an expression node.  */\n \n gfc_expr *\n-gfc_convert_integer (const char * buffer, int kind, int radix, locus * where)\n+gfc_convert_integer (const char *buffer, int kind, int radix, locus *where)\n {\n   gfc_expr *e;\n   const char *t;\n@@ -1870,7 +1858,7 @@ gfc_convert_integer (const char * buffer, int kind, int radix, locus * where)\n /* Convert a real string to an expression node.  */\n \n gfc_expr *\n-gfc_convert_real (const char * buffer, int kind, locus * where)\n+gfc_convert_real (const char *buffer, int kind, locus *where)\n {\n   gfc_expr *e;\n \n@@ -1885,7 +1873,7 @@ gfc_convert_real (const char * buffer, int kind, locus * where)\n    complex expression node.  */\n \n gfc_expr *\n-gfc_convert_complex (gfc_expr * real, gfc_expr * imag, int kind)\n+gfc_convert_complex (gfc_expr *real, gfc_expr *imag, int kind)\n {\n   gfc_expr *e;\n \n@@ -1903,7 +1891,7 @@ gfc_convert_complex (gfc_expr * real, gfc_expr * imag, int kind)\n /* Deal with an arithmetic error.  */\n \n static void\n-arith_error (arith rc, gfc_typespec * from, gfc_typespec * to, locus * where)\n+arith_error (arith rc, gfc_typespec *from, gfc_typespec *to, locus *where)\n {\n   switch (rc)\n     {\n@@ -1948,7 +1936,7 @@ arith_error (arith rc, gfc_typespec * from, gfc_typespec * to, locus * where)\n /* Convert integers to integers.  */\n \n gfc_expr *\n-gfc_int2int (gfc_expr * src, int kind)\n+gfc_int2int (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   arith rc;\n@@ -1957,19 +1945,18 @@ gfc_int2int (gfc_expr * src, int kind)\n \n   mpz_set (result->value.integer, src->value.integer);\n \n-  if ((rc = gfc_check_integer_range (result->value.integer, kind))\n-      != ARITH_OK)\n+  if ((rc = gfc_check_integer_range (result->value.integer, kind)) != ARITH_OK)\n     {\n       if (rc == ARITH_ASYMMETRIC)\n-        {\n-          gfc_warning (gfc_arith_error (rc), &src->where);\n-        }\n+\t{\n+\t  gfc_warning (gfc_arith_error (rc), &src->where);\n+\t}\n       else\n-        {\n-          arith_error (rc, &src->ts, &result->ts, &src->where);\n-          gfc_free_expr (result);\n-          return NULL;\n-        }\n+\t{\n+\t  arith_error (rc, &src->ts, &result->ts, &src->where);\n+\t  gfc_free_expr (result);\n+\t  return NULL;\n+\t}\n     }\n \n   return result;\n@@ -1979,7 +1966,7 @@ gfc_int2int (gfc_expr * src, int kind)\n /* Convert integers to reals.  */\n \n gfc_expr *\n-gfc_int2real (gfc_expr * src, int kind)\n+gfc_int2real (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   arith rc;\n@@ -2002,7 +1989,7 @@ gfc_int2real (gfc_expr * src, int kind)\n /* Convert default integer to default complex.  */\n \n gfc_expr *\n-gfc_int2complex (gfc_expr * src, int kind)\n+gfc_int2complex (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   arith rc;\n@@ -2026,7 +2013,7 @@ gfc_int2complex (gfc_expr * src, int kind)\n /* Convert default real to default integer.  */\n \n gfc_expr *\n-gfc_real2int (gfc_expr * src, int kind)\n+gfc_real2int (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   arith rc;\n@@ -2035,8 +2022,7 @@ gfc_real2int (gfc_expr * src, int kind)\n \n   gfc_mpfr_to_mpz (result->value.integer, src->value.real);\n \n-  if ((rc = gfc_check_integer_range (result->value.integer, kind))\n-      != ARITH_OK)\n+  if ((rc = gfc_check_integer_range (result->value.integer, kind)) != ARITH_OK)\n     {\n       arith_error (rc, &src->ts, &result->ts, &src->where);\n       gfc_free_expr (result);\n@@ -2050,7 +2036,7 @@ gfc_real2int (gfc_expr * src, int kind)\n /* Convert real to real.  */\n \n gfc_expr *\n-gfc_real2real (gfc_expr * src, int kind)\n+gfc_real2real (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   arith rc;\n@@ -2064,7 +2050,7 @@ gfc_real2real (gfc_expr * src, int kind)\n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n-        gfc_warning (gfc_arith_error (rc), &src->where);\n+\tgfc_warning (gfc_arith_error (rc), &src->where);\n       mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n     }\n   else if (rc != ARITH_OK)\n@@ -2081,7 +2067,7 @@ gfc_real2real (gfc_expr * src, int kind)\n /* Convert real to complex.  */\n \n gfc_expr *\n-gfc_real2complex (gfc_expr * src, int kind)\n+gfc_real2complex (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   arith rc;\n@@ -2096,7 +2082,7 @@ gfc_real2complex (gfc_expr * src, int kind)\n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n-        gfc_warning (gfc_arith_error (rc), &src->where);\n+\tgfc_warning (gfc_arith_error (rc), &src->where);\n       mpfr_set_ui (result->value.complex.r, 0, GFC_RND_MODE);\n     }\n   else if (rc != ARITH_OK)\n@@ -2113,7 +2099,7 @@ gfc_real2complex (gfc_expr * src, int kind)\n /* Convert complex to integer.  */\n \n gfc_expr *\n-gfc_complex2int (gfc_expr * src, int kind)\n+gfc_complex2int (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   arith rc;\n@@ -2122,8 +2108,7 @@ gfc_complex2int (gfc_expr * src, int kind)\n \n   gfc_mpfr_to_mpz (result->value.integer, src->value.complex.r);\n \n-  if ((rc = gfc_check_integer_range (result->value.integer, kind))\n-      != ARITH_OK)\n+  if ((rc = gfc_check_integer_range (result->value.integer, kind)) != ARITH_OK)\n     {\n       arith_error (rc, &src->ts, &result->ts, &src->where);\n       gfc_free_expr (result);\n@@ -2137,7 +2122,7 @@ gfc_complex2int (gfc_expr * src, int kind)\n /* Convert complex to real.  */\n \n gfc_expr *\n-gfc_complex2real (gfc_expr * src, int kind)\n+gfc_complex2real (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   arith rc;\n@@ -2151,7 +2136,7 @@ gfc_complex2real (gfc_expr * src, int kind)\n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n-        gfc_warning (gfc_arith_error (rc), &src->where);\n+\tgfc_warning (gfc_arith_error (rc), &src->where);\n       mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n     }\n   if (rc != ARITH_OK)\n@@ -2168,7 +2153,7 @@ gfc_complex2real (gfc_expr * src, int kind)\n /* Convert complex to complex.  */\n \n gfc_expr *\n-gfc_complex2complex (gfc_expr * src, int kind)\n+gfc_complex2complex (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   arith rc;\n@@ -2183,7 +2168,7 @@ gfc_complex2complex (gfc_expr * src, int kind)\n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n-        gfc_warning (gfc_arith_error (rc), &src->where);\n+\tgfc_warning (gfc_arith_error (rc), &src->where);\n       mpfr_set_ui (result->value.complex.r, 0, GFC_RND_MODE);\n     }\n   else if (rc != ARITH_OK)\n@@ -2198,7 +2183,7 @@ gfc_complex2complex (gfc_expr * src, int kind)\n   if (rc == ARITH_UNDERFLOW)\n     {\n       if (gfc_option.warn_underflow)\n-        gfc_warning (gfc_arith_error (rc), &src->where);\n+\tgfc_warning (gfc_arith_error (rc), &src->where);\n       mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n     }\n   else if (rc != ARITH_OK)\n@@ -2215,7 +2200,7 @@ gfc_complex2complex (gfc_expr * src, int kind)\n /* Logical kind conversion.  */\n \n gfc_expr *\n-gfc_log2log (gfc_expr * src, int kind)\n+gfc_log2log (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n \n@@ -2257,7 +2242,7 @@ gfc_int2log (gfc_expr *src, int kind)\n /* Convert Hollerith to integer. The constant will be padded or truncated.  */\n \n gfc_expr *\n-gfc_hollerith2int (gfc_expr * src, int kind)\n+gfc_hollerith2int (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   int len;\n@@ -2274,7 +2259,7 @@ gfc_hollerith2int (gfc_expr * src, int kind)\n   if (len > kind)\n     {\n       gfc_warning (\"The Hollerith constant at %L is too long to convert to %s\",\n-\t\t&src->where, gfc_typename(&result->ts));\n+\t\t   &src->where, gfc_typename(&result->ts));\n     }\n   result->value.character.string = gfc_getmem (kind + 1);\n   memcpy (result->value.character.string, src->value.character.string,\n@@ -2293,7 +2278,7 @@ gfc_hollerith2int (gfc_expr * src, int kind)\n /* Convert Hollerith to real. The constant will be padded or truncated.  */\n \n gfc_expr *\n-gfc_hollerith2real (gfc_expr * src, int kind)\n+gfc_hollerith2real (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   int len;\n@@ -2310,7 +2295,7 @@ gfc_hollerith2real (gfc_expr * src, int kind)\n   if (len > kind)\n     {\n       gfc_warning (\"The Hollerith constant at %L is too long to convert to %s\",\n-\t\t&src->where, gfc_typename(&result->ts));\n+\t\t   &src->where, gfc_typename(&result->ts));\n     }\n   result->value.character.string = gfc_getmem (kind + 1);\n   memcpy (result->value.character.string, src->value.character.string,\n@@ -2329,7 +2314,7 @@ gfc_hollerith2real (gfc_expr * src, int kind)\n /* Convert Hollerith to complex. The constant will be padded or truncated.  */\n \n gfc_expr *\n-gfc_hollerith2complex (gfc_expr * src, int kind)\n+gfc_hollerith2complex (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   int len;\n@@ -2348,11 +2333,11 @@ gfc_hollerith2complex (gfc_expr * src, int kind)\n   if (len > kind)\n     {\n       gfc_warning (\"The Hollerith constant at %L is too long to convert to %s\",\n-\t\t&src->where, gfc_typename(&result->ts));\n+\t\t   &src->where, gfc_typename(&result->ts));\n     }\n   result->value.character.string = gfc_getmem (kind + 1);\n   memcpy (result->value.character.string, src->value.character.string,\n-\tMIN (kind, len));\n+\t  MIN (kind, len));\n \n   if (len < kind)\n     memset (&result->value.character.string[len], ' ', kind - len);\n@@ -2367,7 +2352,7 @@ gfc_hollerith2complex (gfc_expr * src, int kind)\n /* Convert Hollerith to character. */\n \n gfc_expr *\n-gfc_hollerith2character (gfc_expr * src, int kind)\n+gfc_hollerith2character (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n \n@@ -2383,7 +2368,7 @@ gfc_hollerith2character (gfc_expr * src, int kind)\n /* Convert Hollerith to logical. The constant will be padded or truncated.  */\n \n gfc_expr *\n-gfc_hollerith2logical (gfc_expr * src, int kind)\n+gfc_hollerith2logical (gfc_expr *src, int kind)\n {\n   gfc_expr *result;\n   int len;\n@@ -2400,7 +2385,7 @@ gfc_hollerith2logical (gfc_expr * src, int kind)\n   if (len > kind)\n     {\n       gfc_warning (\"The Hollerith constant at %L is too long to convert to %s\",\n-\t\t&src->where, gfc_typename(&result->ts));\n+\t\t   &src->where, gfc_typename(&result->ts));\n     }\n   result->value.character.string = gfc_getmem (kind + 1);\n   memcpy (result->value.character.string, src->value.character.string,\n@@ -2426,7 +2411,7 @@ gfc_hollerith2logical (gfc_expr * src, int kind)\n    here if an initializer exceeds gfc_c_int_kind.  */\n \n gfc_expr *\n-gfc_enum_initializer (gfc_expr * last_initializer, locus where)\n+gfc_enum_initializer (gfc_expr *last_initializer, locus where)\n {\n   gfc_expr *result;\n \n@@ -2444,16 +2429,16 @@ gfc_enum_initializer (gfc_expr * last_initializer, locus where)\n       result->where = last_initializer->where;\n \n       if (gfc_check_integer_range (result->value.integer,\n-             gfc_c_int_kind) != ARITH_OK)\n-        {\n-          gfc_error (\"Enumerator exceeds the C integer type at %C\");\n-          return NULL;\n-        }\n+\t     gfc_c_int_kind) != ARITH_OK)\n+\t{\n+\t  gfc_error (\"Enumerator exceeds the C integer type at %C\");\n+\t  return NULL;\n+\t}\n     }\n   else\n     {\n       /* Control comes here, if it's the very first enumerator and no\n-         initializer has been given.  It will be initialized to zero.  */\n+\t initializer has been given.  It will be initialized to zero.  */\n       mpz_set_si (result->value.integer, 0);\n     }\n "}]}