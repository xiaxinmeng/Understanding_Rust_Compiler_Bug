{"sha": "9b56ec1111632f4e9a47ba5388d7a65c19593f71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI1NmVjMTExMTYzMmY0ZTlhNDdiYTUzODhkN2E2NWMxOTU5M2Y3MQ==", "commit": {"author": {"name": "Jackson Woodruff", "email": "jackson.woodruff@arm.com", "date": "2018-05-22T15:37:11Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2018-05-22T15:37:11Z"}, "message": "[AArch64, patch] Refactor of aarch64-ldpstp\n\nThis patch removes a lot of duplicated code in aarch64-ldpstp.md.\n\nThe patterns that did not previously generate a base register now\ndo not check for aarch64_mem_pair_operand in the pattern. This has\nbeen extracted to a check in aarch64_operands_ok_for_ldpstp.\n\nAll patterns in the file used to have explicit switching code to\nswap loads and stores that were in the wrong order.\n\nThis has been extracted into aarch64_operands_ok_for_ldpstp\nas a final operation after all the checks have been performed. \n\n2018-05-22  Jackson Woodruff  <jackson.woodruff@arm.com>\n            Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\n\t* config/aarch64/aarch64-ldpstp.md: Replace uses of\n\taarch64_mem_pair_operand with memory_operand and delete operand swapping\n\tcode.\n\t* config/aarch64/aarch64.c (aarch64_operands_ok_for_ldpstp):\n\tAdd check for legitimate_address.\n\t(aarch64_gen_adjusted_ldpstp): Swap operands where appropriate.\n\t(aarch64_swap_ldrstr_operands): New.\n\t* config/aarch64/aarch64-protos.h (aarch64_swap_ldrstr_operands):\n\tDefine prototype.\n\nCo-Authored-By: Kyrylo Tkachov <kyrylo.tkachov@arm.com>\n\nFrom-SVN: r260539", "tree": {"sha": "8c93422e81794ccaa08bf457f8cc40d08cd542a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c93422e81794ccaa08bf457f8cc40d08cd542a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b56ec1111632f4e9a47ba5388d7a65c19593f71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b56ec1111632f4e9a47ba5388d7a65c19593f71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b56ec1111632f4e9a47ba5388d7a65c19593f71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b56ec1111632f4e9a47ba5388d7a65c19593f71/comments", "author": null, "committer": null, "parents": [{"sha": "dfe1da2381373d3b905053166d49fbaf8b0082e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfe1da2381373d3b905053166d49fbaf8b0082e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfe1da2381373d3b905053166d49fbaf8b0082e6"}], "stats": {"total": 270, "additions": 103, "deletions": 167}, "files": [{"sha": "12a305ce13b65941051a6ee3fe87dfd124f3bb8c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b56ec1111632f4e9a47ba5388d7a65c19593f71/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b56ec1111632f4e9a47ba5388d7a65c19593f71/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b56ec1111632f4e9a47ba5388d7a65c19593f71", "patch": "@@ -1,3 +1,16 @@\n+2018-05-22  Jackson Woodruff  <jackson.woodruff@arm.com>\n+            Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/aarch64/aarch64-ldpstp.md: Replace uses of\n+\taarch64_mem_pair_operand with memory_operand and delete operand swapping\n+\tcode.\n+\t* config/aarch64/aarch64.c (aarch64_operands_ok_for_ldpstp):\n+\tAdd check for legitimate_address.\n+\t(aarch64_gen_adjusted_ldpstp): Swap operands where appropriate.\n+\t(aarch64_swap_ldrstr_operands): New.\n+\t* config/aarch64/aarch64-protos.h (aarch64_swap_ldrstr_operands):\n+\tDefine prototype.\n+\n 2018-05-22  Jackson Woodruff  <jackson.woodruff@arm.com>\n             Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n "}, {"sha": "7f1031dc80fab31f691c0b03d6a485c1b6fd7e53", "filename": "gcc/config/aarch64/aarch64-ldpstp.md", "status": "modified", "additions": 18, "deletions": 162, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b56ec1111632f4e9a47ba5388d7a65c19593f71/gcc%2Fconfig%2Faarch64%2Faarch64-ldpstp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b56ec1111632f4e9a47ba5388d7a65c19593f71/gcc%2Fconfig%2Faarch64%2Faarch64-ldpstp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-ldpstp.md?ref=9b56ec1111632f4e9a47ba5388d7a65c19593f71", "patch": "@@ -20,106 +20,66 @@\n \n (define_peephole2\n   [(set (match_operand:GPI 0 \"register_operand\" \"\")\n-\t(match_operand:GPI 1 \"aarch64_mem_pair_operand\" \"\"))\n+\t(match_operand:GPI 1 \"memory_operand\" \"\"))\n    (set (match_operand:GPI 2 \"register_operand\" \"\")\n \t(match_operand:GPI 3 \"memory_operand\" \"\"))]\n   \"aarch64_operands_ok_for_ldpstp (operands, true, <MODE>mode)\"\n   [(parallel [(set (match_dup 0) (match_dup 1))\n \t      (set (match_dup 2) (match_dup 3))])]\n {\n-  rtx base, offset_1, offset_2;\n-\n-  extract_base_offset_in_addr (operands[1], &base, &offset_1);\n-  extract_base_offset_in_addr (operands[3], &base, &offset_2);\n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[2]);\n-      std::swap (operands[1], operands[3]);\n-    }\n+  aarch64_swap_ldrstr_operands (operands, true);\n })\n \n (define_peephole2\n-  [(set (match_operand:GPI 0 \"aarch64_mem_pair_operand\" \"\")\n+  [(set (match_operand:GPI 0 \"memory_operand\" \"\")\n \t(match_operand:GPI 1 \"aarch64_reg_or_zero\" \"\"))\n    (set (match_operand:GPI 2 \"memory_operand\" \"\")\n \t(match_operand:GPI 3 \"aarch64_reg_or_zero\" \"\"))]\n   \"aarch64_operands_ok_for_ldpstp (operands, false, <MODE>mode)\"\n   [(parallel [(set (match_dup 0) (match_dup 1))\n \t      (set (match_dup 2) (match_dup 3))])]\n {\n-  rtx base, offset_1, offset_2;\n-\n-  extract_base_offset_in_addr (operands[0], &base, &offset_1);\n-  extract_base_offset_in_addr (operands[2], &base, &offset_2);\n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[2]);\n-      std::swap (operands[1], operands[3]);\n-    }\n+  aarch64_swap_ldrstr_operands (operands, false);\n })\n \n (define_peephole2\n   [(set (match_operand:GPF 0 \"register_operand\" \"\")\n-\t(match_operand:GPF 1 \"aarch64_mem_pair_operand\" \"\"))\n+\t(match_operand:GPF 1 \"memory_operand\" \"\"))\n    (set (match_operand:GPF 2 \"register_operand\" \"\")\n \t(match_operand:GPF 3 \"memory_operand\" \"\"))]\n   \"aarch64_operands_ok_for_ldpstp (operands, true, <MODE>mode)\"\n   [(parallel [(set (match_dup 0) (match_dup 1))\n \t      (set (match_dup 2) (match_dup 3))])]\n {\n-  rtx base, offset_1, offset_2;\n-\n-  extract_base_offset_in_addr (operands[1], &base, &offset_1);\n-  extract_base_offset_in_addr (operands[3], &base, &offset_2);\n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[2]);\n-      std::swap (operands[1], operands[3]);\n-    }\n+  aarch64_swap_ldrstr_operands (operands, true);\n })\n \n (define_peephole2\n-  [(set (match_operand:GPF 0 \"aarch64_mem_pair_operand\" \"\")\n+  [(set (match_operand:GPF 0 \"memory_operand\" \"\")\n \t(match_operand:GPF 1 \"aarch64_reg_or_fp_zero\" \"\"))\n    (set (match_operand:GPF 2 \"memory_operand\" \"\")\n \t(match_operand:GPF 3 \"aarch64_reg_or_fp_zero\" \"\"))]\n   \"aarch64_operands_ok_for_ldpstp (operands, false, <MODE>mode)\"\n   [(parallel [(set (match_dup 0) (match_dup 1))\n \t      (set (match_dup 2) (match_dup 3))])]\n {\n-  rtx base, offset_1, offset_2;\n-\n-  extract_base_offset_in_addr (operands[0], &base, &offset_1);\n-  extract_base_offset_in_addr (operands[2], &base, &offset_2);\n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[2]);\n-      std::swap (operands[1], operands[3]);\n-    }\n+  aarch64_swap_ldrstr_operands (operands, false);\n })\n \n (define_peephole2\n   [(set (match_operand:DREG 0 \"register_operand\" \"\")\n-\t(match_operand:DREG 1 \"aarch64_mem_pair_operand\" \"\"))\n+\t(match_operand:DREG 1 \"memory_operand\" \"\"))\n    (set (match_operand:DREG2 2 \"register_operand\" \"\")\n \t(match_operand:DREG2 3 \"memory_operand\" \"\"))]\n   \"aarch64_operands_ok_for_ldpstp (operands, true, <DREG:MODE>mode)\"\n   [(parallel [(set (match_dup 0) (match_dup 1))\n \t      (set (match_dup 2) (match_dup 3))])]\n {\n-  rtx base, offset_1, offset_2;\n-\n-  extract_base_offset_in_addr (operands[1], &base, &offset_1);\n-  extract_base_offset_in_addr (operands[3], &base, &offset_2);\n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[2]);\n-      std::swap (operands[1], operands[3]);\n-    }\n+  aarch64_swap_ldrstr_operands (operands, true);\n })\n \n (define_peephole2\n-  [(set (match_operand:DREG 0 \"aarch64_mem_pair_operand\" \"\")\n+  [(set (match_operand:DREG 0 \"memory_operand\" \"\")\n \t(match_operand:DREG 1 \"register_operand\" \"\"))\n    (set (match_operand:DREG2 2 \"memory_operand\" \"\")\n \t(match_operand:DREG2 3 \"register_operand\" \"\"))]\n@@ -128,57 +88,33 @@\n   [(parallel [(set (match_dup 0) (match_dup 1))\n \t      (set (match_dup 2) (match_dup 3))])]\n {\n-  rtx base, offset_1, offset_2;\n-\n-  extract_base_offset_in_addr (operands[0], &base, &offset_1);\n-  extract_base_offset_in_addr (operands[2], &base, &offset_2);\n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[2]);\n-      std::swap (operands[1], operands[3]);\n-    }\n+  aarch64_swap_ldrstr_operands (operands, false);\n })\n \n ;; Handle sign/zero extended consecutive load/store.\n \n (define_peephole2\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(sign_extend:DI (match_operand:SI 1 \"aarch64_mem_pair_operand\" \"\")))\n+\t(sign_extend:DI (match_operand:SI 1 \"memory_operand\" \"\")))\n    (set (match_operand:DI 2 \"register_operand\" \"\")\n \t(sign_extend:DI (match_operand:SI 3 \"memory_operand\" \"\")))]\n   \"aarch64_operands_ok_for_ldpstp (operands, true, SImode)\"\n   [(parallel [(set (match_dup 0) (sign_extend:DI (match_dup 1)))\n \t      (set (match_dup 2) (sign_extend:DI (match_dup 3)))])]\n {\n-  rtx base, offset_1, offset_2;\n-\n-  extract_base_offset_in_addr (operands[1], &base, &offset_1);\n-  extract_base_offset_in_addr (operands[3], &base, &offset_2);\n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[2]);\n-      std::swap (operands[1], operands[3]);\n-    }\n+  aarch64_swap_ldrstr_operands (operands, true);\n })\n \n (define_peephole2\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(zero_extend:DI (match_operand:SI 1 \"aarch64_mem_pair_operand\" \"\")))\n+\t(zero_extend:DI (match_operand:SI 1 \"memory_operand\" \"\")))\n    (set (match_operand:DI 2 \"register_operand\" \"\")\n \t(zero_extend:DI (match_operand:SI 3 \"memory_operand\" \"\")))]\n   \"aarch64_operands_ok_for_ldpstp (operands, true, SImode)\"\n   [(parallel [(set (match_dup 0) (zero_extend:DI (match_dup 1)))\n \t      (set (match_dup 2) (zero_extend:DI (match_dup 3)))])]\n {\n-  rtx base, offset_1, offset_2;\n-\n-  extract_base_offset_in_addr (operands[1], &base, &offset_1);\n-  extract_base_offset_in_addr (operands[3], &base, &offset_2);\n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[2]);\n-      std::swap (operands[1], operands[3]);\n-    }\n+  aarch64_swap_ldrstr_operands (operands, true);\n })\n \n ;; Handle storing of a floating point zero with integer data.\n@@ -192,23 +128,15 @@\n ;; as aarch64_operands_ok_for_ldpstp checks that the modes are\n ;; compatible.\n (define_peephole2\n-  [(set (match_operand:DSX 0 \"aarch64_mem_pair_operand\" \"\")\n+  [(set (match_operand:DSX 0 \"memory_operand\" \"\")\n \t(match_operand:DSX 1 \"aarch64_reg_zero_or_fp_zero\" \"\"))\n    (set (match_operand:<FCVT_TARGET> 2 \"memory_operand\" \"\")\n \t(match_operand:<FCVT_TARGET> 3 \"aarch64_reg_zero_or_fp_zero\" \"\"))]\n   \"aarch64_operands_ok_for_ldpstp (operands, false, <V_INT_EQUIV>mode)\"\n   [(parallel [(set (match_dup 0) (match_dup 1))\n \t      (set (match_dup 2) (match_dup 3))])]\n {\n-  rtx base, offset_1, offset_2;\n-\n-  extract_base_offset_in_addr (operands[0], &base, &offset_1);\n-  extract_base_offset_in_addr (operands[2], &base, &offset_2);\n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[2]);\n-      std::swap (operands[1], operands[3]);\n-    }\n+  aarch64_swap_ldrstr_operands (operands, false);\n })\n \n ;; Handle consecutive load/store whose offset is out of the range\n@@ -230,18 +158,6 @@\n   \"aarch64_operands_adjust_ok_for_ldpstp (operands, true, <MODE>mode)\"\n   [(const_int 0)]\n {\n-  rtx base, offset_1, offset_2;\n-\n-  extract_base_offset_in_addr (operands[1], &base, &offset_1);\n-  extract_base_offset_in_addr (operands[3], &base, &offset_2);\n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[6]);\n-      std::swap (operands[1], operands[7]);\n-      std::swap (operands[2], operands[4]);\n-      std::swap (operands[3], operands[5]);\n-    }\n-\n   if (aarch64_gen_adjusted_ldpstp (operands, true, <MODE>mode, UNKNOWN))\n     DONE;\n   else\n@@ -262,18 +178,6 @@\n   \"aarch64_operands_adjust_ok_for_ldpstp (operands, true, <MODE>mode)\"\n   [(const_int 0)]\n {\n-  rtx base, offset_1, offset_2;\n-\n-  extract_base_offset_in_addr (operands[1], &base, &offset_1);\n-  extract_base_offset_in_addr (operands[3], &base, &offset_2);\n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[6]);\n-      std::swap (operands[1], operands[7]);\n-      std::swap (operands[2], operands[4]);\n-      std::swap (operands[3], operands[5]);\n-    }\n-\n   if (aarch64_gen_adjusted_ldpstp (operands, true, <MODE>mode, UNKNOWN))\n     DONE;\n   else\n@@ -294,18 +198,6 @@\n   \"aarch64_operands_adjust_ok_for_ldpstp (operands, true, SImode)\"\n   [(const_int 0)]\n {\n-  rtx base, offset_1, offset_2;\n-\n-  extract_base_offset_in_addr (operands[1], &base, &offset_1);\n-  extract_base_offset_in_addr (operands[3], &base, &offset_2);\n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[6]);\n-      std::swap (operands[1], operands[7]);\n-      std::swap (operands[2], operands[4]);\n-      std::swap (operands[3], operands[5]);\n-    }\n-\n   if (aarch64_gen_adjusted_ldpstp (operands, true, SImode, SIGN_EXTEND))\n     DONE;\n   else\n@@ -326,18 +218,6 @@\n   \"aarch64_operands_adjust_ok_for_ldpstp (operands, true, SImode)\"\n   [(const_int 0)]\n {\n-  rtx base, offset_1, offset_2;\n-\n-  extract_base_offset_in_addr (operands[1], &base, &offset_1);\n-  extract_base_offset_in_addr (operands[3], &base, &offset_2);\n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[6]);\n-      std::swap (operands[1], operands[7]);\n-      std::swap (operands[2], operands[4]);\n-      std::swap (operands[3], operands[5]);\n-    }\n-\n   if (aarch64_gen_adjusted_ldpstp (operands, true, SImode, ZERO_EXTEND))\n     DONE;\n   else\n@@ -358,18 +238,6 @@\n   \"aarch64_operands_adjust_ok_for_ldpstp (operands, false, <MODE>mode)\"\n   [(const_int 0)]\n {\n-  rtx base, offset_1, offset_2;\n-\n-  extract_base_offset_in_addr (operands[0], &base, &offset_1);\n-  extract_base_offset_in_addr (operands[2], &base, &offset_2);\n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[6]);\n-      std::swap (operands[1], operands[7]);\n-      std::swap (operands[2], operands[4]);\n-      std::swap (operands[3], operands[5]);\n-    }\n-\n   if (aarch64_gen_adjusted_ldpstp (operands, false, <MODE>mode, UNKNOWN))\n     DONE;\n   else\n@@ -390,18 +258,6 @@\n   \"aarch64_operands_adjust_ok_for_ldpstp (operands, false, <MODE>mode)\"\n   [(const_int 0)]\n {\n-  rtx base, offset_1, offset_2;\n-\n-  extract_base_offset_in_addr (operands[0], &base, &offset_1);\n-  extract_base_offset_in_addr (operands[2], &base, &offset_2);\n-  if (INTVAL (offset_1) > INTVAL (offset_2))\n-    {\n-      std::swap (operands[0], operands[6]);\n-      std::swap (operands[1], operands[7]);\n-      std::swap (operands[2], operands[4]);\n-      std::swap (operands[3], operands[5]);\n-    }\n-\n   if (aarch64_gen_adjusted_ldpstp (operands, false, <MODE>mode, UNKNOWN))\n     DONE;\n   else"}, {"sha": "4ab68110eb4602939582fa4498cca686468bebb6", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b56ec1111632f4e9a47ba5388d7a65c19593f71/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b56ec1111632f4e9a47ba5388d7a65c19593f71/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=9b56ec1111632f4e9a47ba5388d7a65c19593f71", "patch": "@@ -534,6 +534,7 @@ int aarch64_ccmp_mode_to_code (machine_mode mode);\n bool extract_base_offset_in_addr (rtx mem, rtx *base, rtx *offset);\n bool aarch64_operands_ok_for_ldpstp (rtx *, bool, machine_mode);\n bool aarch64_operands_adjust_ok_for_ldpstp (rtx *, bool, scalar_mode);\n+void aarch64_swap_ldrstr_operands (rtx *, bool);\n \n extern void aarch64_asm_output_pool_epilogue (FILE *, const char *,\n \t\t\t\t\t      tree, HOST_WIDE_INT);"}, {"sha": "f60e0ad37565b044b3ffe446eebcc0f40f9d99db", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 71, "deletions": 5, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b56ec1111632f4e9a47ba5388d7a65c19593f71/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b56ec1111632f4e9a47ba5388d7a65c19593f71/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=9b56ec1111632f4e9a47ba5388d7a65c19593f71", "patch": "@@ -16874,9 +16874,16 @@ aarch64_operands_ok_for_ldpstp (rtx *operands, bool load,\n \n       /* In increasing order, the last load can clobber the address.  */\n       if (offval_1 > offval_2 && reg_mentioned_p (reg_2, mem_2))\n-      return false;\n+\treturn false;\n     }\n \n+  /* One of the memory accesses must be a mempair operand.\n+     If it is not the first one, they need to be swapped by the\n+     peephole.  */\n+  if (!aarch64_mem_pair_operand (mem_1, GET_MODE (mem_1))\n+       && !aarch64_mem_pair_operand (mem_2, GET_MODE (mem_2)))\n+    return false;\n+\n   if (REG_P (reg_1) && FP_REGNUM_P (REGNO (reg_1)))\n     rclass_1 = FP_REGS;\n   else\n@@ -16894,6 +16901,40 @@ aarch64_operands_ok_for_ldpstp (rtx *operands, bool load,\n   return true;\n }\n \n+/* Given OPERANDS of consecutive load/store that can be merged,\n+   swap them if they are not in ascending order.  */\n+void\n+aarch64_swap_ldrstr_operands (rtx* operands, bool load)\n+{\n+  rtx mem_1, mem_2, base_1, base_2, offset_1, offset_2;\n+  HOST_WIDE_INT offval_1, offval_2;\n+\n+  if (load)\n+    {\n+      mem_1 = operands[1];\n+      mem_2 = operands[3];\n+    }\n+  else\n+    {\n+      mem_1 = operands[0];\n+      mem_2 = operands[2];\n+    }\n+\n+  extract_base_offset_in_addr (mem_1, &base_1, &offset_1);\n+  extract_base_offset_in_addr (mem_2, &base_2, &offset_2);\n+\n+  offval_1 = INTVAL (offset_1);\n+  offval_2 = INTVAL (offset_2);\n+\n+  if (offval_1 > offval_2)\n+    {\n+      /* Irrespective of whether this is a load or a store,\n+\t we do the same swap.  */\n+      std::swap (operands[0], operands[2]);\n+      std::swap (operands[1], operands[3]);\n+    }\n+}\n+\n /* Given OPERANDS of consecutive load/store, check if we can merge\n    them into ldp/stp by adjusting the offset.  LOAD is true if they\n    are load instructions.  MODE is the mode of memory operands.\n@@ -17053,10 +17094,34 @@ bool\n aarch64_gen_adjusted_ldpstp (rtx *operands, bool load,\n \t\t\t     scalar_mode mode, RTX_CODE code)\n {\n-  rtx base, offset, t1, t2;\n+  rtx base, offset_1, offset_2, t1, t2;\n   rtx mem_1, mem_2, mem_3, mem_4;\n   HOST_WIDE_INT off_val, abs_off, adj_off, new_off, stp_off_limit, msize;\n \n+  if (load)\n+    {\n+      mem_1 = operands[1];\n+      mem_2 = operands[3];\n+    }\n+  else\n+    {\n+      mem_1 = operands[0];\n+      mem_2 = operands[2];\n+    }\n+\n+  extract_base_offset_in_addr (mem_1, &base, &offset_1);\n+  extract_base_offset_in_addr (mem_2, &base, &offset_2);\n+  gcc_assert (base != NULL_RTX && offset_1 != NULL_RTX\n+\t      && offset_2 != NULL_RTX);\n+\n+  if (INTVAL (offset_1) > INTVAL (offset_2))\n+    {\n+      std::swap (operands[0], operands[6]);\n+      std::swap (operands[1], operands[7]);\n+      std::swap (operands[2], operands[4]);\n+      std::swap (operands[3], operands[5]);\n+    }\n+\n   if (load)\n     {\n       mem_1 = operands[1];\n@@ -17073,13 +17138,14 @@ aarch64_gen_adjusted_ldpstp (rtx *operands, bool load,\n       gcc_assert (code == UNKNOWN);\n     }\n \n-  extract_base_offset_in_addr (mem_1, &base, &offset);\n-  gcc_assert (base != NULL_RTX && offset != NULL_RTX);\n+  /* Extract the offset of the new first address.  */\n+  extract_base_offset_in_addr (mem_1, &base, &offset_1);\n+  extract_base_offset_in_addr (mem_2, &base, &offset_2);\n \n   /* Adjust offset thus it can fit in ldp/stp instruction.  */\n   msize = GET_MODE_SIZE (mode);\n   stp_off_limit = msize * 0x40;\n-  off_val = INTVAL (offset);\n+  off_val = INTVAL (offset_1);\n   abs_off = (off_val < 0) ? -off_val : off_val;\n   new_off = abs_off % stp_off_limit;\n   adj_off = abs_off - new_off;"}]}