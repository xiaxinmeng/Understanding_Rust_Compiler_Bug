{"sha": "725dc051cada61aca8127f1062ec97a31acf79f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI1ZGMwNTFjYWRhNjFhY2E4MTI3ZjEwNjJlYzk3YTMxYWNmNzlmMQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-10-05T11:27:02Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-10-05T11:27:02Z"}, "message": "include: New directory.\n\n\n2000-10-05  Benjamin Kosnik  <bkoz@cygnus.com>\n\n\t* include: New directory.\n\t* include/backward: New directory.\n\t* include/bits: New directory.\n\t* include/ext: New directory.\n\t* include/std: New directory.\n\t* include/*/*: Populate.\n\n\t* src/complex.cc: Adjust include of mathconf.\n\n\t* mkc++config (BASE_H): Add include.\n\n\t* src/Makefile.am: Support for topleve sources include directory.\n\t(INCLUDES): Add LIBMATH_INCLUDE.\n\t* src/Makefile.in: Regenerate.\n\t* math/Makefile.am (INCLUDES): Append /include.\n\t* math/Makefile.in: Regenerate.\n\t* libio/Makefile.am (INCLUDES): Add glibcpp_includedir.\n\t* libio/Makefile.in: Regenerate.\n\nFrom-SVN: r36723", "tree": {"sha": "bc187d782ab1e9dceb01b0464aef31982b570007", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc187d782ab1e9dceb01b0464aef31982b570007"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/725dc051cada61aca8127f1062ec97a31acf79f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/725dc051cada61aca8127f1062ec97a31acf79f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/725dc051cada61aca8127f1062ec97a31acf79f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/725dc051cada61aca8127f1062ec97a31acf79f1/comments", "author": null, "committer": null, "parents": [{"sha": "509fc2779a4604d1d715b4c41008d98b3f963a26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/509fc2779a4604d1d715b4c41008d98b3f963a26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/509fc2779a4604d1d715b4c41008d98b3f963a26"}], "stats": {"total": 51297, "additions": 51297, "deletions": 0}, "files": [{"sha": "b46d3242309fedea7e34b4fd0fc00b19272cc489", "filename": "libstdc++-v3/include/backward/algo.h", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgo.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,114 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_ALGO_H\n+#define _CPP_BACKWARD_ALGO_H 1\n+\n+#include \"algobase.h\"\n+#include \"tempbuf.h\"\n+#include <bits/stl_algo.h>\n+#include <bits/stl_numeric.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+// Names from <stl_algo.h>\n+using __STD::for_each; \n+using __STD::find; \n+using __STD::find_if; \n+using __STD::adjacent_find; \n+using __STD::count; \n+using __STD::count_if; \n+using __STD::search; \n+using __STD::search_n; \n+using __STD::swap_ranges; \n+using __STD::transform; \n+using __STD::replace; \n+using __STD::replace_if; \n+using __STD::replace_copy; \n+using __STD::replace_copy_if; \n+using __STD::generate; \n+using __STD::generate_n; \n+using __STD::remove; \n+using __STD::remove_if; \n+using __STD::remove_copy; \n+using __STD::remove_copy_if; \n+using __STD::unique; \n+using __STD::unique_copy; \n+using __STD::reverse; \n+using __STD::reverse_copy; \n+using __STD::rotate; \n+using __STD::rotate_copy; \n+using __STD::random_shuffle; \n+using __STD::random_sample; \n+using __STD::random_sample_n; \n+using __STD::partition; \n+using __STD::stable_partition; \n+using __STD::sort; \n+using __STD::stable_sort; \n+using __STD::partial_sort; \n+using __STD::partial_sort_copy; \n+using __STD::nth_element; \n+using __STD::lower_bound; \n+using __STD::upper_bound; \n+using __STD::equal_range; \n+using __STD::binary_search; \n+using __STD::merge; \n+using __STD::inplace_merge; \n+using __STD::includes; \n+using __STD::set_union; \n+using __STD::set_intersection; \n+using __STD::set_difference; \n+using __STD::set_symmetric_difference; \n+using __STD::min_element; \n+using __STD::max_element; \n+using __STD::next_permutation; \n+using __STD::prev_permutation; \n+using __STD::find_first_of; \n+using __STD::find_end; \n+using __STD::is_sorted; \n+using __STD::is_heap; \n+\n+// Names from stl_heap.h\n+using __STD::push_heap;\n+using __STD::pop_heap;\n+using __STD::make_heap;\n+using __STD::sort_heap;\n+\n+// Names from stl_numeric.h\n+using __STD::accumulate; \n+using __STD::inner_product; \n+using __STD::partial_sum; \n+using __STD::adjacent_difference; \n+using __STD::power; \n+using __STD::iota; \n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_ALGO_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "b5c807a882fbb586af238b9320e68e6d989c7752", "filename": "libstdc++-v3/include/backward/algobase.h", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falgobase.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,71 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_ALGOBASE_H\n+#define _CPP_BACKWARD_ALGOBASE_H 1\n+\n+#ifndef _CPP_BACKWARD_PAIR_H\n+#include \"pair.h\"\n+#endif\n+#ifndef _CPP_BACKWARD_ITERATOR_H\n+#include \"iterator.h\"\n+#endif\n+#ifndef _CPP_BITS_STL__ALGOBASE_H\n+#include <bits/stl_algobase.h>\n+#endif\n+#ifndef _CPP_BITS_STL_UNINITIALIZED_H\n+#include <bits/stl_uninitialized.h>\n+#endif\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+// Names from stl_algobase.h\n+using __STD::iter_swap; \n+using __STD::swap; \n+using __STD::min; \n+using __STD::max; \n+using __STD::copy; \n+using __STD::copy_backward; \n+using __STD::copy_n; \n+using __STD::fill; \n+using __STD::fill_n; \n+using __STD::mismatch; \n+using __STD::equal; \n+using __STD::lexicographical_compare; \n+using __STD::lexicographical_compare_3way; \n+\n+// Names from stl_uninitialized.h\n+using __STD::uninitialized_copy;\n+using __STD::uninitialized_copy_n;\n+using __STD::uninitialized_fill;\n+using __STD::uninitialized_fill_n;\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_ALGOBASE_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "3ec1304a8e7510306461acd9799e856175aa806b", "filename": "libstdc++-v3/include/backward/alloc.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright (c) 1996-1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_ALLOC_H\n+#define _CPP_BACKWARD_ALLOC_H 1\n+\n+#ifndef _CPP_BITS_STL_CONFIG_H\n+#include <bits/stl_config.h>\n+#endif\n+#ifndef _CPP_BITS_STL_ALLOC_H\n+#include <bits/stl_alloc.h>\n+#endif\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+using __STD::__malloc_alloc_template; \n+using __STD::malloc_alloc; \n+using __STD::simple_alloc; \n+using __STD::debug_alloc; \n+#ifndef __USE_MALLOC\n+using __STD::__default_alloc_template; \n+#endif\n+using __STD::alloc; \n+using __STD::single_client_alloc; \n+#ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG\n+using __STD::__malloc_alloc_oom_handler; \n+#endif /* __STL_STATIC_TEMPLATE_MEMBER_BUG */\n+#ifdef __STL_USE_STD_ALLOCATORS \n+using __STD::allocator;\n+#endif /* __STL_USE_STD_ALLOCATORS */\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_ALLOC_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "ed9225404858ba8e8d210252f4532a63680c073b", "filename": "libstdc++-v3/include/backward/bvector.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fbvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fbvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fbvector.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,51 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_BVECTOR_H\n+#define _CPP_BACKWARD_BVECTOR_H 1\n+\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+#include \"vector.h\"\n+#else\n+#include \"algobase.h\"\n+#include \"alloc.h\"\n+#endif \n+\n+#include <bits/stl_bvector.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+using __STD::bit_vector;\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_BVECTOR_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:\n+\n+"}, {"sha": "97e0852068ba0bb092af794bd3248fe9a3420a40", "filename": "libstdc++-v3/include/backward/complex.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fcomplex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fcomplex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fcomplex.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,47 @@\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_BACKWARD_COMPLEX_H\n+#define _CPP_BACKWARD_COMPLEX_H 1\n+\n+#include <bits/stl_config.h>\n+#include <bits/std_complex.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::complex;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+typedef complex<float> float_complex;\n+typedef complex<double> double_complex;\n+typedef complex<long double> long_double_complex;\n+\n+#endif /* _CPP_BACKWARD_COMPLEX_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "8edee690bc6f98dad2ad0a9d81aac04fd1055cf7", "filename": "libstdc++-v3/include/backward/defalloc.h", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fdefalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fdefalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fdefalloc.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,87 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+// Inclusion of this file is DEPRECATED.  This is the original HP\n+// default allocator.  It is provided only for backward compatibility.\n+// This file WILL BE REMOVED in a future release.\n+//\n+// DO NOT USE THIS FILE unless you have an old container implementation\n+// that requires an allocator with the HP-style interface.  \n+//\n+// Standard-conforming allocators have a very different interface.  The\n+// standard default allocator is declared in the header <memory>.\n+\n+#ifndef _CPP_BACKWARD_DEFALLOC_H\n+#define _CPP_BACKWARD_DEFALLOC_H 1\n+\n+#include \"new.h\"\n+#include <stddef.h>\n+#include <stdlib.h>\n+#include <limits.h> \n+#include \"iostream.h\" \n+#include \"algobase.h\"\n+\n+\n+template <class _Tp>\n+inline _Tp* allocate(ptrdiff_t __size, _Tp*) {\n+    set_new_handler(0);\n+    _Tp* __tmp = (_Tp*)(::operator new((size_t)(__size * sizeof(_Tp))));\n+    if (__tmp == 0) {\n+\tcerr << \"out of memory\" << endl; \n+\texit(1);\n+    }\n+    return __tmp;\n+}\n+\n+\n+template <class _Tp>\n+inline void deallocate(_Tp* __buffer) {\n+    ::operator delete(__buffer);\n+}\n+\n+template <class _Tp>\n+class allocator {\n+public:\n+    typedef _Tp value_type;\n+    typedef _Tp* pointer;\n+    typedef const _Tp* const_pointer;\n+    typedef _Tp& reference;\n+    typedef const _Tp& const_reference;\n+    typedef size_t size_type;\n+    typedef ptrdiff_t difference_type;\n+    pointer allocate(size_type __n) { \n+\treturn ::allocate((difference_type)__n, (pointer)0);\n+    }\n+    void deallocate(pointer __p) { ::deallocate(__p); }\n+    pointer address(reference __x) { return (pointer)&__x; }\n+    const_pointer const_address(const_reference __x) { \n+\treturn (const_pointer)&__x; \n+    }\n+    size_type init_page_size() { \n+\treturn max(size_type(1), size_type(4096/sizeof(_Tp))); \n+    }\n+    size_type max_size() const { \n+\treturn max(size_type(1), size_type(UINT_MAX/sizeof(_Tp))); \n+    }\n+};\n+\n+class allocator<void> {\n+public:\n+    typedef void* pointer;\n+};\n+\n+\n+\n+#endif /* _CPP_BACKWARD_DEFALLOC_H */"}, {"sha": "fc47056c5ee4a5e6aa1b7c41c6c5f34813654d1d", "filename": "libstdc++-v3/include/backward/deque.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fdeque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fdeque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fdeque.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,42 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_DEQUE_H\n+#define _CPP_BACKWARD_DEQUE_H 1\n+\n+#include \"algobase.h\"\n+#include \"alloc.h\"\n+#include <bits/std_deque.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::deque;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_DEQUE_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "a346faf994c0bb01ad2088a87345dca14630e8ca", "filename": "libstdc++-v3/include/backward/fstream.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffstream.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_BACKWARD_FSTREAM_H\n+#define _CPP_BACKWARD_FSTREAM_H 1\n+\n+#include <bits/std_fstream.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::ifstream;\n+using __STD::ofstream;\n+using __STD::fstream;\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+using __STD::wifstream;\n+using __STD::wofstream;\n+using __STD::wfstream;\n+#endif\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_FSTREAM_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "7988ae99c2b2fce0a408598b2cc7a437744214bb", "filename": "libstdc++-v3/include/backward/function.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ffunction.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,118 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_FUNCTION_H\n+#define _CPP_BACKWARD_FUNCTION_H 1\n+\n+#ifndef _CPP_BITS_STL_CONFIG_H\n+#include <bits/stl_config.h>\n+#endif\n+#ifndef _CPP_BITS_STL_RELOPS\n+#include <bits/stl_relops.h>\n+#endif\n+#include <stddef.h>\n+#ifndef _CPP_BITS_STL_FUNCTION_H\n+#include <bits/stl_function.h>\n+#endif\n+\n+#ifdef __STL_USE_NAMESPACE_FOR_RELOPS\n+\n+// Names from stl_relops.h\n+using __STD_RELOPS::operator!=;\n+using __STD_RELOPS::operator>;\n+using __STD_RELOPS::operator<=;\n+using __STD_RELOPS::operator>=;\n+\n+#endif /* __STL_USE_NAMESPACE_FOR_RELOPS */\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+// Names from stl_function.h\n+using __STD::unary_function; \n+using __STD::binary_function; \n+using __STD::plus; \n+using __STD::minus; \n+using __STD::multiplies; \n+using __STD::divides; \n+using __STD::identity_element; \n+using __STD::modulus; \n+using __STD::negate; \n+using __STD::equal_to; \n+using __STD::not_equal_to; \n+using __STD::greater; \n+using __STD::less; \n+using __STD::greater_equal; \n+using __STD::less_equal; \n+using __STD::logical_and; \n+using __STD::logical_or; \n+using __STD::logical_not; \n+using __STD::unary_negate; \n+using __STD::binary_negate; \n+using __STD::not1; \n+using __STD::not2; \n+using __STD::binder1st; \n+using __STD::binder2nd; \n+using __STD::bind1st; \n+using __STD::bind2nd; \n+using __STD::unary_compose; \n+using __STD::binary_compose; \n+using __STD::compose1; \n+using __STD::compose2; \n+using __STD::pointer_to_unary_function; \n+using __STD::pointer_to_binary_function; \n+using __STD::ptr_fun; \n+using __STD::identity; \n+using __STD::select1st; \n+using __STD::select2nd; \n+using __STD::project1st; \n+using __STD::project2nd; \n+using __STD::constant_void_fun; \n+using __STD::constant_unary_fun; \n+using __STD::constant_binary_fun; \n+using __STD::constant0; \n+using __STD::constant1; \n+using __STD::constant2; \n+using __STD::subtractive_rng; \n+using __STD::mem_fun_t; \n+using __STD::const_mem_fun_t; \n+using __STD::mem_fun_ref_t; \n+using __STD::const_mem_fun_ref_t; \n+using __STD::mem_fun1_t; \n+using __STD::const_mem_fun1_t; \n+using __STD::mem_fun1_ref_t; \n+using __STD::const_mem_fun1_ref_t; \n+using __STD::mem_fun; \n+using __STD::mem_fun_ref; \n+using __STD::mem_fun1; \n+using __STD::mem_fun1_ref; \n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_FUNCTION_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "ebf0cb8f84be3c9c0dc9a78f98abc4b62bf16955", "filename": "libstdc++-v3/include/backward/hash_map.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_map.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+#ifndef _CPP_BACKWARD_HASH_MAP_H\n+#define _CPP_BACKWARD_HASH_MAP_H 1\n+\n+#ifndef _CPP_BITS_STL_HASHTABLE_H\n+#include <bits/stl_hashtable.h>\n+#endif \n+\n+#include \"algobase.h\"\n+#include <bits/stl_hash_map.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::hash;\n+using __STD::hashtable;\n+using __STD::hash_map;\n+using __STD::hash_multimap;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+\n+#endif /* _CPP_BACKWARD_HASH_MAP_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "140ce6048c6d1a64943453ef9bb81f30af641413", "filename": "libstdc++-v3/include/backward/hash_set.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhash_set.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+#ifndef _CPP_BACKWARD_HASH_SET_H\n+#define _CPP_BACKWARD_HASH_SET_H 1\n+\n+#ifndef _CPP_BITS_STL_HASHTABLE_H\n+#include <bits/stl_hashtable.h>\n+#endif \n+\n+#include \"algobase.h\"\n+#include <bits/stl_hash_set.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::hash;\n+using __STD::hashtable;\n+using __STD::hash_set;\n+using __STD::hash_multiset;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_HASH_SET_H */"}, {"sha": "bd0f4f47433f3c3d2f72c5b733b0f84f16c9d48e", "filename": "libstdc++-v3/include/backward/hashtable.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fhashtable.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+/* NOTE: This is an internal header file, included by other STL headers.\n+ *   You should not attempt to use it directly.\n+ */\n+\n+#ifndef _CPP_BACKWARD_HASHTABLE_H\n+#define _CPP_BACKWARD_HASHTABLE_H 1\n+\n+#include <bits/stl_hashtable.h>\n+#include \"algo.h\"\n+#include \"alloc.h\"\n+#include \"vector.h\"\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::hash;\n+using __STD::hashtable;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_HASHTABLE_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "0256fc62e7ed7b4fa06ef717491f88d68aa78212", "filename": "libstdc++-v3/include/backward/heap.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fheap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fheap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fheap.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,46 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_HEAP_H\n+#define _CPP_BACKWARD_HEAP_H 1\n+\n+#include <bits/stl_config.h>\n+#include <bits/stl_heap.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+using __STD::push_heap;\n+using __STD::pop_heap;\n+using __STD::make_heap;\n+using __STD::sort_heap;\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+\n+#endif /* _CPP_BACKWARD_HEAP_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "206a3880b66b07f8d65970ea17e14d2e18f53581", "filename": "libstdc++-v3/include/backward/iomanip.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiomanip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiomanip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiomanip.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,48 @@\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_BACKWARD_IOMANIP_H\n+#define _CPP_BACKWARD_IOMANIP_H 1\n+\n+#include <backward/iostream.h>\n+#include <bits/std_iomanip.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::resetiosflags;\n+using __STD::setiosflags;\n+using __STD::setbase;\n+using __STD::setfill;\n+using __STD::setprecision;\n+using __STD::setw;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_IOMANIP_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "2caee39adc4be1129aadeae84ad4a73786f55d2d", "filename": "libstdc++-v3/include/backward/iostream.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiostream.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,60 @@\n+\n+// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_BACKWARD_IOSTREAM_H\n+#define _CPP_BACKWARD_IOSTREAM_H 1\n+\n+#include <bits/std_iostream.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::iostream;\n+using __STD::ostream;\n+using __STD::istream;\n+using __STD::ios;\n+using __STD::streambuf;\n+\n+using __STD::cout;\n+using __STD::cin;\n+using __STD::cerr;\n+using __STD::clog;\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+using __STD::wcout;\n+using __STD::wcin;\n+using __STD::wcerr;\n+using __STD::wclog;\n+#endif\n+\n+using __STD::endl;\n+using __STD::ends;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_IOSTREAM_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "f45709267eb7d3bffdeb8e408782ccde900a1a7d", "filename": "libstdc++-v3/include/backward/istream.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fistream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fistream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fistream.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,37 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_BACKWARD_ISTREAM_H\n+#define _CPP_BACKWARD_ISTREAM_H 1\n+\n+#include <backward/iostream.h>\n+\n+#endif /* _CPP_BACKWARD_ISTREAM_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "40185036b3be9f1d2804c25bb0adef66db00af2b", "filename": "libstdc++-v3/include/backward/iterator.h", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiterator.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,104 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_ITERATOR_H\n+#define _CPP_BACKWARD_ITERATOR_H 1\n+\n+#ifndef _CPP_BACKWARD_FUNCTION_H\n+#include \"function.h\"\n+#endif\n+#include <stddef.h>\n+#include \"iostream.h\"\n+#ifndef _CPP_BITS_STL_ITERATOR_H\n+#include <bits/stl_iterator.h>\n+#endif\n+#ifndef _CPP_BITS_TYPE_TRAITS_H\n+#include <bits/type_traits.h>\n+#endif\n+#ifndef _CPP_BITS_STL_CONSTRUCT_H\n+#include <bits/stl_construct.h>\n+#endif\n+#ifndef _CPP_BITS_STL_RAW_STORAGE_ITERATOR_H\n+#include <bits/stl_raw_storage_iter.h>\n+#endif\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+// Names from stl_iterator.h\n+\n+using __STD::input_iterator_tag;\n+using __STD::output_iterator_tag;\n+using __STD::forward_iterator_tag;\n+using __STD::bidirectional_iterator_tag;\n+using __STD::random_access_iterator_tag;\n+\n+#if 0\n+using __STD::iterator;\n+#endif\n+using __STD::input_iterator;\n+using __STD::output_iterator;\n+using __STD::forward_iterator;\n+using __STD::bidirectional_iterator;\n+using __STD::random_access_iterator;\n+\n+#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n+using __STD::iterator_traits;\n+#endif\n+\n+using __STD::iterator_category;\n+using __STD::distance_type;\n+using __STD::value_type;\n+\n+using __STD::distance; \n+using __STD::advance; \n+\n+using __STD::insert_iterator;\n+using __STD::front_insert_iterator;\n+using __STD::back_insert_iterator;\n+using __STD::inserter;\n+using __STD::front_inserter;\n+using __STD::back_inserter;\n+\n+using __STD::reverse_iterator;\n+using __STD::reverse_bidirectional_iterator;\n+\n+using __STD::istream_iterator;\n+using __STD::ostream_iterator;\n+\n+// Names from stl_construct.h\n+using __STD::construct;\n+using __STD::destroy;\n+\n+// Names from stl_raw_storage_iter.h\n+using __STD::raw_storage_iterator;\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_ITERATOR_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "9a719ff95941d08332a9832d1d7099ac755d24d2", "filename": "libstdc++-v3/include/backward/list.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Flist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Flist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Flist.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,42 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_LIST_H\n+#define _CPP_BACKWARD_LIST_H 1\n+\n+#include <bits/stl_algobase.h>\n+#include \"alloc.h\"\n+#include <bits/std_list.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::list;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_LIST_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "cf0fe2bc638876955a44180f212e281e98111795", "filename": "libstdc++-v3/include/backward/map.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmap.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,41 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_MAP_H\n+#define _CPP_BACKWARD_MAP_H 1\n+\n+#include \"tree.h\"\n+#include <bits/stl_map.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::map;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_MAP_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "157e3331aa90d4562d3f6177fffa5eea480c4e91", "filename": "libstdc++-v3/include/backward/multimap.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultimap.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,41 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_MULTIMAP_H\n+#define _CPP_BACKWARD_MULTIMAP_H 1\n+\n+#include \"tree.h\"\n+#include <bits/stl_multimap.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::multimap;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_MULTIMAP_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "270a5da8ca348f3c6aa91159041e4beb4c0bfae7", "filename": "libstdc++-v3/include/backward/multiset.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fmultiset.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,41 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_MULTISET_H\n+#define _CPP_BACKWARD_MULTISET_H 1\n+\n+#include \"tree.h\"\n+#include <bits/stl_multiset.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::multiset;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_MULTISET_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "20e57dee8de66c364ff9e63479fabf9b833302d9", "filename": "libstdc++-v3/include/backward/new.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fnew.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fnew.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fnew.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,46 @@\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_BACKWARD_NEW_H\n+#define _CPP_BACKWARD_NEW_H 1\n+\n+#include <bits/std_new.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::bad_alloc;\n+using __STD::nothrow_t;\n+using __STD::nothrow;\n+using __STD::new_handler;\n+using __STD::set_new_handler;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_NEW_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "740588a277b8ec89af4cbea5cd9cb2b5eeb2308e", "filename": "libstdc++-v3/include/backward/ostream.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fostream.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,37 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_BACKWARD_OSTREAM_H\n+#define _CPP_BACKWARD_OSTREAM_H 1\n+\n+#include <backward/iostream.h>\n+\n+#endif /* _CPP_BACKWARD_OSTREAM_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "275a205bb6ea935bcff263070e11815ce3c3bab7", "filename": "libstdc++-v3/include/backward/pair.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fpair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fpair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fpair.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,51 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_PAIR_H\n+#define _CPP_BACKWARD_PAIR_H 1\n+\n+#ifndef _CPP_BITS_STL_CONFIG_H\n+#include <bits/stl_config.h>\n+#endif\n+#ifndef _CPP_BITS_STL_RELOPS_H\n+#include <bits/stl_relops.h>\n+#endif\n+#ifndef _CPP_BITS_STL_PAIR_H\n+#include <bits/stl_pair.h>\n+#endif\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+using __STD::pair;\n+using __STD::make_pair;\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_PAIR_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "7d32f87497ed88f298e09a32cf8c77625cfd0896", "filename": "libstdc++-v3/include/backward/rope.h", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Frope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Frope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Frope.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_ROPE_H\n+#define _CPP_BACKWARD_ROPE_H 1\n+\n+#include \"hashtable.h\"   \n+#include <bits/stl_rope.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+using __STD::char_producer; \n+using __STD::sequence_buffer; \n+using __STD::rope; \n+using __STD::crope; \n+using __STD::wrope; \n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_ROPE_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "e05890e046efda61860ff70467ae9ac277f89a82", "filename": "libstdc++-v3/include/backward/set.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fset.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,41 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_SET_H\n+#define _CPP_BACKWARD_SET_H 1\n+\n+#include \"tree.h\"\n+#include <bits/stl_set.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::set;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_SET_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "8c63282d1ca06fb1306a65da2bcdab76e7d53f5a", "filename": "libstdc++-v3/include/backward/slist.h", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fslist.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fslist.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fslist.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+#ifndef _CPP_BACKWARD_SLIST_H\n+#define _CPP_BACKWARD_SLIST_H 1\n+\n+#include <ext/slist>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::slist;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_SLIST_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "4140f409970ced8132af43be08c24cd9aaef287c", "filename": "libstdc++-v3/include/backward/stack.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstack.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,46 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_STACK_H\n+#define _CPP_BACKWARD_STACK_H 1\n+\n+#include \"vector.h\"\n+#include \"deque.h\"\n+#include \"heap.h\"\n+#include <bits/stl_stack.h>\n+#include <bits/stl_queue.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::stack;\n+using __STD::queue;\n+using __STD::priority_queue;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_STACK_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "f829b0dd577a3d47235ff336fe8ab0b17e5182a8", "filename": "libstdc++-v3/include/backward/stream.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstream.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,37 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_BACKWARD_STREAM_H\n+#define _CPP_BACKWARD_STREAM_H 1\n+\n+#include <backward/iostream.h>\n+\n+#endif /* _CPP_BACKWARD_STREAM_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "f693fcd54dee5363a49fd289e372c7007b583ad3", "filename": "libstdc++-v3/include/backward/strstream.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,44 @@\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_BACKWARD_STRSTREAM_H\n+#define _CPP_BACKWARD_STRSTREAM_H 1\n+\n+#include <bits/std_strstream.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::strstreambuf;\n+using __STD::istrstream;\n+using __STD::ostrstream;\n+using __STD::strstream;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_STRSTREAM_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "82e5c8e811b17927f3551f29bc53ec159966758d", "filename": "libstdc++-v3/include/backward/tempbuf.h", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftempbuf.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,62 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_TEMPBUF_H\n+#define _CPP_BACKWARD_TEMPBUF_H 1\n+\n+#ifndef _CPP_BACKWARD_PAIR_H\n+#include \"pair.h\"\n+#endif\n+#include <iterator.h>\n+#include <limits.h>\n+#include <stddef.h> \n+#include <stdlib.h> \n+#ifndef _CPP_BITS_TYPE_TRAITS_H\n+#include <bits/type_traits.h>  \n+#endif\n+#ifndef _CPP_BITS_STL_CONSTRUCT_H\n+#include <bits/stl_construct.h>\n+#endif\n+#ifndef _CPP_BITS_STL_UNINITIALIZED_H\n+#include <bits/stl_uninitialized.h>\n+#endif\n+#ifndef _CPP_BITS_STL_TEMPBUF_H\n+#include <bits/stl_tempbuf.h>\n+#endif\n+\n+#ifdef __STL_USE_NAMESPACES\n+\n+using __STD::get_temporary_buffer;\n+using __STD::return_temporary_buffer;\n+using __STD::_Temporary_buffer;\n+\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_TEMPBUF_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "64e89ad36fe880c71645008e08549d0e7c95cbd9", "filename": "libstdc++-v3/include/backward/tree.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Ftree.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,46 @@\n+/*\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ */\n+\n+#ifndef _CPP_BACKWARD_TREE_H\n+#define _CPP_BACKWARD_TREE_H 1\n+\n+#ifndef _CPP_BITS_STL_TREE_H\n+#include <bits/stl_tree.h>\n+#endif\n+#include \"algobase.h\" \n+#include \"alloc.h\"\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::rb_tree;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_TREE_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "8a7e8f940401a653ea03ad82747a6c29a2d2808c", "filename": "libstdc++-v3/include/backward/vector.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fvector.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,42 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BACKWARD_VECTOR_H\n+#define _CPP_BACKWARD_VECTOR_H 1\n+\n+#include \"algobase.h\"\n+#include \"alloc.h\"  \n+#include <bits/stl_vector.h>\n+\n+#ifdef __STL_USE_NAMESPACES\n+using __STD::vector;\n+#endif /* __STL_USE_NAMESPACES */\n+\n+#endif /* _CPP_BACKWARD_VECTOR_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "3c8430b326482eff27a212c7d25fc7a4204a2226", "filename": "libstdc++-v3/include/bits/basic_file.h", "status": "added", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_file.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_file.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_file.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,340 @@\n+// Wrapper of C-language FILE struct -*- C++ -*-\n+\n+// Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.8  File-based streams\n+//\n+\n+#ifndef _CPP_BASIC_FILE\n+#define _CPP_BASIC_FILE\t\t1\n+\n+#include <bits/c++config.h>\n+#include <bits/std_ios.h>\n+\n+namespace std {\n+\n+  // Ulrich is going to make some detailed comment here, explaining\n+  // all this unpleasantness, providing detailed performance analysis\n+  // as to why we have to do all this lame vtable hacking instead of a\n+  // sane, function-based approach. This verbage will provide a clear\n+  // and detailed description of the whole object-layout,\n+  // vtable-swapping, sordid history of this hack.\n+  template<typename _CharT>\n+  struct __basic_file_base: public __c_file_type\n+  {\n+    virtual \n+    ~__basic_file_base() { };\n+\n+    virtual int \n+    overflow(int __c = EOF) = 0;\n+\n+    virtual int \n+    underflow() = 0;\n+\n+    virtual int \n+    uflow() = 0;\n+\n+    virtual int \n+    pbackfail(int __c) = 0;\n+\n+    virtual streamsize \n+    xsputn(const _CharT* __s, streamsize __n) = 0;\n+\n+    virtual streamsize \n+    xsgetn(_CharT* __s, streamsize __n) = 0;\n+\n+    virtual streamoff\n+    seekoff(streamoff __off, ios_base::seekdir __way,\n+\t    ios_base::openmode __mode = ios_base::in | ios_base::out) = 0;\n+\n+    virtual streamoff\n+    seekpos(streamoff __pos, \n+\t    ios_base::openmode __mode = ios_base::in | ios_base::out) = 0;\n+\n+    virtual streambuf* \n+    setbuf(_CharT* __b, int __len) = 0;\n+\n+    virtual int \n+    sync() = 0;\n+\n+    virtual int \n+    doallocate() = 0;\n+\n+    virtual streamsize \n+    sys_read(_CharT* __s, streamsize __n) = 0;\n+\n+    virtual streamsize \n+    sys_write(const _CharT* __s, streamsize __n) = 0;\n+\n+    virtual streamoff\n+    sys_seek(streamoff __off, ios_base::seekdir __way) = 0;\n+\n+    virtual int \n+    sys_close() = 0;\n+\n+    virtual int \n+    sys_stat(void* __v) = 0;\n+\n+    virtual int \n+    showmanyc() = 0;\n+\n+    virtual void \n+    imbue(void* __v) = 0;\n+  };\n+\n+  // Some of these member functions are based on libio/filebuf.cc.\n+  // Also note that the order and number of virtual functions has to precisely\n+  // match the order and number in the _IO_jump_t struct defined in libioP.h.\n+  template<typename _CharT>\n+#if _GLIBCPP_BASIC_FILE_INHERITANCE\n+    class __basic_file: public __basic_file_base<_CharT>\n+#else\n+    class __basic_file\n+#endif\n+    {\n+#if _GLIBCPP_BASIC_FILE_ENCAPSULATION\n+      int \t\t_M_fileno;\n+      __c_file_type* \t_M_cfile;\n+#endif\n+      __c_wfile_type\t_M_wfile;\n+\n+    public:\n+      __basic_file(__c_lock* __lock = 0);\n+      \n+      void \n+      _M_open_mode(ios_base::openmode __mode, int& __p_mode, int& __rw_mode);\n+      \n+      // Eqivalent to the normal fopen function.\n+      __basic_file* \n+      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);\n+\n+      // Used for opening the standard streams, cin, cout, cerr, clog,\n+      // and their wide-stream equivalents. Instead of calling open, it\n+      // just sets __c_file_type->_fileno and the respective _flags bits, and\n+      // returns.\n+      __basic_file*\n+      sys_open(int __fd, ios_base::openmode __mode);\n+\n+      __basic_file* \n+      close(); \n+\n+      bool \n+      is_open();\n+\n+      // Needed by ios_base::sync_with_stdio.\n+      int get_fileno(void);\n+\n+      // NB: Must match FILE specific jump table starting here--this\n+      // means all virtual functions starting with the dtor must match,\n+      // slot by slot. For glibc-based dystems, this means the _IO_FILE\n+      // as the FILE struct and _IO_jump_t as the jump table.\n+      virtual \n+      ~__basic_file(); // Takes the place of __finish.\n+\n+      virtual int \n+      overflow(int __c = EOF);\n+\n+      virtual int \n+      underflow();\n+\n+      virtual int \n+      uflow();\n+\n+      virtual int \n+      pbackfail(int __c);\n+\n+      // A complex \"write\" function that sets all of __c_file_type's\n+      // ponters and associated data members correctly and manages it's\n+      // relation to the external byte sequence.\n+      virtual streamsize \n+      xsputn(const _CharT* __s, streamsize __n);\n+\n+      // A complex \"read\" function that sets all of __c_file_type's\n+      // ponters and associated data members correctly and manages it's\n+      // relation to the external byte sequence.\n+      virtual streamsize \n+      xsgetn(_CharT* __s, streamsize __n);\n+\n+      // A complex \"seekoff\" function that sets all of __c_file_type's\n+      // ponters and associated data members correctly and manages it's\n+      // relation to the external byte sequence.\n+      virtual streamoff\n+      seekoff(streamoff __off, ios_base::seekdir __way,\n+\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n+\n+      // A complex \"seekpos\" function that sets all of __c_file_type's\n+      // pointers and associated data members correctly and manages it's\n+      // relation to the external byte sequence.\n+      virtual streamoff\n+      seekpos(streamoff __pos, \n+\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n+\n+      virtual streambuf* \n+      setbuf(_CharT* __b, int __len);\n+\n+      virtual int \n+      sync();\n+\n+      virtual int \n+      doallocate();\n+\n+      // A simple read function for the external byte sequence, that\n+      // does no mucking around with or setting of the pointers or flags\n+      // in __c_file_type.\n+      virtual streamsize \n+      sys_read(_CharT* __s, streamsize __n);\n+\n+      // A simple write function for the external byte sequence, that\n+      // does no mucking around with or setting of the pointers or flags\n+      // in __c_file_type.\n+      virtual streamsize \n+      sys_write(const _CharT* __s, streamsize __n);\n+\n+      // A simple seek function for the external byte sequence, that\n+      // does no mucking around with or setting of the pointers or flags\n+      // in __c_file_type.\n+      virtual streamoff\n+      sys_seek(streamoff __off, ios_base::seekdir __way);\n+\n+      virtual int \n+      sys_close();\n+\n+      virtual int \n+      sys_stat(void* __v);\n+\n+      virtual int \n+      showmanyc();\n+\n+      virtual void \n+      imbue(void* __v);\n+    };\n+\n+  // __basic_file<char> specializations\n+  template<>\n+    __basic_file<char>::__basic_file(__c_lock* __lock);\n+\n+  template<>\n+    int \n+    __basic_file<char>::overflow(int __c);\n+\n+  template<>\n+    int \n+    __basic_file<char>::underflow();\n+\n+  template<>\n+    int \n+    __basic_file<char>::uflow();\n+\n+  template<>\n+    int \n+    __basic_file<char>::pbackfail(int __c);\n+\n+  template<>\n+    streamsize \n+    __basic_file<char>::xsputn(const char* __s, streamsize __n);\n+\n+  template<>\n+    streamoff\n+    __basic_file<char>::seekoff(streamoff __off, ios_base::seekdir __way, \n+\t\t\t\tios_base::openmode __mode);\n+\n+  template<>\n+    streamoff\n+    __basic_file<char>::seekpos(streamoff __pos, ios_base::openmode __mode);\n+\n+  template<>\n+    streambuf* \n+    __basic_file<char>::setbuf(char* __b, int __len);\n+\n+  template<>\n+    int \n+    __basic_file<char>::sync();\n+\n+  template<>\n+    int \n+    __basic_file<char>::doallocate();\n+\n+  // __basic_file<wchar_t> specializations\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    __basic_file<wchar_t>::__basic_file(__c_lock* __lock);\n+\n+  template<>\n+    int \n+    __basic_file<wchar_t>::overflow(int __c);\n+\n+  template<>\n+    int \n+    __basic_file<wchar_t>::underflow();\n+\n+  template<>\n+    int \n+    __basic_file<wchar_t>::uflow();\n+\n+  template<>\n+    int \n+    __basic_file<wchar_t>::pbackfail(int __c);\n+\n+  template<>\n+    streamsize \n+    __basic_file<wchar_t>::xsputn(const wchar_t* __s, streamsize __n);\n+\n+  template<>\n+    streamoff\n+    __basic_file<wchar_t>::seekoff(streamoff __off, ios_base::seekdir __way, \n+\t\t\t\tios_base::openmode __mode);\n+\n+  template<>\n+    streamoff\n+    __basic_file<wchar_t>::seekpos(streamoff __pos, ios_base::openmode __mode);\n+\n+  template<>\n+    streambuf* \n+    __basic_file<wchar_t>::setbuf(wchar_t* __b, int __len);\n+\n+  template<>\n+    int \n+    __basic_file<wchar_t>::sync();\n+\n+  template<>\n+    int \n+    __basic_file<wchar_t>::doallocate();\n+#endif\n+\n+} // namespace std\n+\n+#endif\t/* _CPP_BASIC_FILE */\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "7cac68b74c29006fa092221c55b93e524fb025fc", "filename": "libstdc++-v3/include/bits/basic_ios.h", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,216 @@\n+// Iostreams base classes -*- C++ -*-\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_BITS_BASICIOS_H\n+#define _CPP_BITS_BASICIOS_H 1\n+\n+#include <bits/sbuf_iter.h>\n+\n+namespace std {\n+\n+  // 27.4.5  Template class basic_ios\n+  template<typename _CharT, typename _Traits>\n+    class basic_ios : public ios_base\n+    {\n+    public:\n+\n+      // Types:\n+      typedef _CharT \t\t\t\tchar_type;\n+      typedef typename _Traits::int_type \tint_type;\n+      typedef typename _Traits::pos_type \tpos_type;\n+      typedef typename _Traits::off_type \toff_type;\n+      typedef _Traits \t\t\t\ttraits_type;\n+\n+      // Non-standard Types:\n+      typedef ctype<_CharT>           \t\t__ctype_type;\n+      // From ostream\n+      typedef ostreambuf_iterator<_CharT>\t\t__ostreambuf_iter;\n+      typedef num_put<_CharT, __ostreambuf_iter>        __numput_type;\n+      typedef istreambuf_iterator<_CharT>\t\t__istreambuf_iter;\n+      typedef num_get<_CharT, __istreambuf_iter>        __numget_type;\n+      \n+      // Data members:\n+    private:\n+      basic_ostream<_CharT, _Traits>* \t_M_tie;\n+      char_type \t\t\t_M_fill;\n+      iostate \t\t\t\t_M_exception;\n+\n+    protected:\n+      basic_streambuf<_CharT, _Traits>* _M_streambuf;\n+      iostate \t\t\t\t_M_streambuf_state;\n+\n+      // Cached use_facet<ctype>, which is based on the current locale info.\n+      const __ctype_type*\t\t_M_ios_fctype;      \n+      // From ostream.\n+      const __numput_type* \t\t_M_fnumput;\n+      // From istream.\n+      const __numget_type* \t\t_M_fnumget;\n+\n+    public:\n+\n+      inline const __ctype_type*\t\n+      _M_get_fctype_ios(void)\n+      { return _M_ios_fctype; }\n+\n+      inline const __numget_type* \n+      _M_get_fnumget(void)\n+      { return _M_fnumget; }\n+\n+      inline const __numput_type* \n+      _M_get_fnumput(void)\n+      { return _M_fnumput; }\n+\n+      operator void*() const \n+      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }\n+\n+      inline bool \n+      operator!() const \n+      { return this->fail(); }\n+\n+      inline iostate \n+      rdstate() const \n+      { return _M_streambuf_state; }\n+\n+      inline void \n+      clear(iostate __state = goodbit)\n+      { \n+\tif (this->rdbuf())\n+\t  _M_streambuf_state = __state;\n+\telse\n+\t  _M_streambuf_state = __state | badbit;\n+\tif ((this->rdstate() & this->exceptions()))\n+\t  throw failure(\"basic_ios::clear(iostate) caused exception\");\n+      }\n+\n+      inline void \n+      setstate(iostate __state) \n+      { this->clear(this->rdstate() | __state); }\n+\n+      inline bool \n+      good() const \n+      { return this->rdstate() == 0; }\n+\n+      inline bool \n+      eof() const \n+      { return (this->rdstate() & eofbit) != 0; }\n+\n+      inline bool \n+      fail() const \n+      { return (this->rdstate() & (badbit | failbit)) != 0; }\n+\n+      inline bool \n+      bad() const \n+      { return (this->rdstate() & badbit) != 0; }\n+\n+      inline iostate \n+      exceptions() const \n+      { return _M_exception; }\n+\n+      inline void \n+      exceptions(iostate __except) \n+      { \n+\t_M_exception = __except; \n+\tthis->clear(_M_streambuf_state); \n+      }\n+\n+      // Constructor/destructor:\n+      explicit \n+      basic_ios(basic_streambuf<_CharT, _Traits>* __sb) : ios_base() \n+      { this->init(__sb); }\n+\n+      virtual \n+      ~basic_ios() { }\n+      \n+      // Members:\n+      inline basic_ostream<_CharT, _Traits>*\n+      tie() const      \n+      { return _M_tie; }\n+\n+      inline basic_ostream<_CharT, _Traits>*\n+      tie(basic_ostream<_CharT, _Traits>* __tiestr)\n+      {\n+\tbasic_ostream<_CharT, _Traits>* __old = _M_tie;\n+\t_M_tie = __tiestr;\n+\treturn __old;\n+      }\n+\n+      inline basic_streambuf<_CharT, _Traits>*\n+      rdbuf() const    \n+      { return _M_streambuf; }\n+\n+      basic_streambuf<_CharT, _Traits>* \n+      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);\n+\n+      basic_ios&\n+      copyfmt(const basic_ios& __rhs);\n+\n+      inline char_type \n+      fill() const \n+      { return _M_fill; }\n+\n+      inline char_type \n+      fill(char_type __ch)\n+      {\n+\tchar_type __old = _M_fill;\n+\t_M_fill = __ch;\n+\treturn __old;\n+      }\n+\n+      // Locales:\n+      locale \n+      imbue(const locale& __loc);\n+\n+      char \n+      narrow(char_type __c, char __dfault) const;\n+\n+      char_type \n+      widen(char __c) const;\n+     \n+    protected:\n+      // 27.4.5.1  basic_ios constructors\n+      basic_ios() : ios_base() \n+      { }\n+\n+      void \n+      init(basic_streambuf<_CharT, _Traits>* __sb);\n+    };\n+  \n+} // namespace std\n+\n+#ifdef _GLIBCPP_NO_TEMPLATE_EXPORT\n+# define export\n+//#include <bits/basic_ios.tcc>\n+#endif\n+\n+#endif /* _CPP_BITS_BASICIOS_H */\n+\n+\n+\n+\n+"}, {"sha": "54d5efd19bc8277c08c2fc222de12512250620a0", "filename": "libstdc++-v3/include/bits/basic_ios.tcc", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.tcc?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,142 @@\n+// basic_ios locale and locale-related member functions -*- C++ -*-\n+\n+// Copyright (C) 1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_BITS_BASICIOS_TCC\n+#define _CPP_BITS_BASICIOS_TCC 1\n+\n+namespace std {\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_streambuf<_CharT, _Traits>* \n+    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)\n+    {\n+      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;\n+      _M_streambuf = __sb;\n+      this->clear();\n+      return __old;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ios<_CharT, _Traits>&\n+    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n+    {\n+      // Per 27.1.1.1, do not call imbue, yet must trash all caches\n+      // associated with imbue()\n+\n+      // Alloc any new word array first, so if it fails we have \"rollback\".\n+      _Words* __words = (__rhs._M_word_limit <= _S_local_words) ?\n+\t_M_word_array : new _Words[__rhs._M_word_limit];\n+\n+      // XXX This is the only reason _Callback_list was defined\n+      // inline. The suspicion is that this increased compilation\n+      // times dramatically for functions that use this member\n+      // function (inserters_extractors, ios_manip_fmtflags). FIX ME,\n+      // clean this stuff up. Callbacks are broken right now, anyway.\n+\n+      // Bump refs before doing callbacks, for safety.\n+      _Callback_list* __cb = __rhs._M_callbacks;\n+      if (__cb) \n+\t__cb->_M_add_reference();\n+      _M_call_callbacks(erase_event);\n+      if (_M_words != _M_word_array) \n+\tdelete [] _M_words;\n+      _M_dispose_callbacks();\n+\n+      _M_callbacks = __cb;  // NB: Don't want any added during above.\n+      for (int __i = 0; __i < __rhs._M_word_limit; ++__i)\n+\t__words[__i] = __rhs._M_words[__i];\n+      if (_M_words != _M_word_array) \n+\tdelete [] _M_words;\n+      _M_words = __words;\n+      _M_word_limit = __rhs._M_word_limit;\n+\n+      this->flags(__rhs.flags());\n+      this->width(__rhs.width());\n+      this->precision(__rhs.precision());\n+      this->tie(__rhs.tie());\n+      this->fill(__rhs.fill());\n+      // The next is required to be the last assignment.\n+      this->exceptions(__rhs.exceptions());\n+      \n+      _M_call_callbacks(copyfmt_event);\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    char\n+    basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const\n+    { return _M_ios_fctype->narrow(__c, __dfault); }\n+\n+  template<typename _CharT, typename _Traits>\n+    _CharT\n+    basic_ios<_CharT, _Traits>::widen(char __c) const\n+    { return _M_ios_fctype->widen(__c); }\n+\n+  // Locales:\n+  template<typename _CharT, typename _Traits>\n+    locale\n+    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n+    {\n+      locale __old(this->getloc());\n+      ios_base::imbue(__loc);\n+      _M_ios_fctype = &use_facet<__ctype_type>(__loc);\n+      _M_fnumput = &use_facet<__numput_type>(__loc); \n+      _M_fnumget = &use_facet<__numget_type>(__loc); \n+      if (this->rdbuf() != 0)\n+\tthis->rdbuf()->pubimbue(__loc);\n+      return __old;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    void\n+    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)\n+    {\n+      // NB: This may be called more than once on the same object.\n+      ios_base::_M_init();\n+      locale __loc = this->getloc();\n+      _M_ios_fctype = &use_facet<__ctype_type>(__loc);\n+      // Should be filled in by ostream and istream, respectively.\n+      _M_fnumput = &use_facet<__numput_type>(__loc); \n+      _M_fnumget = &use_facet<__numget_type>(__loc); \n+      _M_tie = 0;\n+      _M_fill = this->widen(' ');\n+      _M_exception = goodbit;\n+      _M_streambuf = __sb;\n+      iostate __state = __sb ? goodbit : badbit;\n+      _M_streambuf_state = __state;\n+    }\n+\n+} // namespace std\n+\n+#endif /* _CPP_BITS_BASICIOS_TCC */\n+\n+\n+\n+\n+"}, {"sha": "60795f7b72e5354bfbe232009a5b36aae093d201", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "added", "additions": 1038, "deletions": 0, "changes": 1038, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,1038 @@\n+// Components for manipulating sequences of characters -*- C++ -*-\n+\n+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 21 Strings library\n+//\n+\n+#ifndef _CPP_BITS_STRING_H\n+#define _CPP_BITS_STRING_H\t1\n+\n+#include <bits/exception_support.h>\n+#include <bits/atomicity.h>\n+\n+namespace std {\n+\n+  // Documentation?  What's that? \n+  // Nathan Myers <ncm@cantrip.org>.\n+  //\n+  // A string looks like this:\n+  //\n+  //                               \t[_Rep]\n+  //                               \t_M_length\n+  //  [basic_string<char_type>]\t\t_M_capacity\n+  //  _M_dataplus                \t_M_state\n+  //  _M_p ---------------->   \t\tunnamed array of char_type\n+  \n+  // Where the _M_p points to the first character in the string, and\n+  // you cast it to a pointer-to-_Rep and subtract 1 to get a\n+  // pointer to the header.\n+  \n+  // This approach has the enormous advantage that a string object\n+  // requires only one allocation.  All the ugliness is confined\n+  // within a single pair of inline functions, which each compile to\n+  // a single \"add\" instruction: _Rep::_M_data(), and\n+  // string::_M_rep(); and the allocation function which gets a\n+  // block of raw bytes and with room enough and constructs a _Rep\n+  // object at the front.\n+  \n+  // The reason you want _M_data pointing to the character array and\n+  // not the _Rep is so that the debugger can see the string\n+  // contents. (Probably we should add a non-inline member to get\n+  // the _Rep for the debugger to use, so users can check the actual\n+  // string length.)\n+  \n+  // Note that the _Rep object is a POD so that you can have a\n+  // static \"empty string\" _Rep object already \"constructed\" before\n+  // static constructors have run.  The reference-count encoding is\n+  // chosen so that a 0 indicates one reference, so you never try to\n+  // destroy the empty-string _Rep object.\n+  \n+  // All but the last paragraph is considered pretty conventional\n+  // for a C++ string implementation.\n+  \n+  // 21.3  Template class basic_string\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    class basic_string\n+    {\n+      // Types:\n+    public:\n+      typedef _Traits \t\t\t\t\t    traits_type;\n+      typedef typename _Traits::char_type \t\t    value_type;\n+      typedef _Alloc \t\t\t\t\t    allocator_type;\n+      typedef typename _Alloc::size_type \t\t    size_type;\n+      typedef typename _Alloc::difference_type \t\t    difference_type;\n+      typedef typename _Alloc::reference \t\t    reference;\n+      typedef typename _Alloc::const_reference \t\t    const_reference;\n+      typedef typename _Alloc::pointer \t\t\t    pointer;\n+      typedef typename _Alloc::const_pointer \t   \t    const_pointer;\n+      typedef __normal_iterator<pointer, basic_string> \t    iterator;\n+      typedef __normal_iterator<const_pointer, basic_string> const_iterator;\n+      typedef reverse_iterator<const_iterator> \tconst_reverse_iterator;\n+      typedef reverse_iterator<iterator> \t\t    reverse_iterator;\n+    \n+    private:\n+      // _Rep: string representation\n+      //   Invariants:\n+      //   1. String really contains _M_length + 1 characters; last is set\n+      //      to 0 only on call to c_str().  We avoid instantiating\n+      //      _CharT() where the interface does not require it.\n+      //   2. _M_capacity >= _M_length\n+      //      Allocated memory is always _M_capacity + (1 * sizeof(_CharT)).\n+      //   3. _M_references has three states:\n+      //      -1: leaked, one reference, no ref-copies allowed, non-const.\n+      //       0: one reference, non-const.\n+      //     n>0: n + 1 references, operations require a lock, const.\n+      //   4. All fields==0 is an empty string, given the extra storage\n+      //      beyond-the-end for a null terminator; thus, the shared\n+      //      empty string representation needs no constructor.\n+\n+      struct _Rep\n+      {\n+\t// Types:\n+\ttypedef typename _Alloc::rebind<char>::other _Raw_bytes_alloc;\n+\n+\t// (Public) Data members: \n+\n+\t// The maximum number of individual char_type elements of an\n+\t// individual string is determined by _S_max_size. This is the\n+\t// value that will be returned by max_size().  (Whereas npos\n+\t// is the maximum number of bytes the allocator can allocate.)\n+\t// If one was to divvy up the theoretical largest size string,\n+\t// with a terminating character and m _CharT elements, it'd\n+\t// look like this: \n+\t// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)\n+\t// Solving for m:\n+\t// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1 \n+\t// In addition, this implementation quarters this ammount.\n+\tstatic size_type \t_S_max_size;\n+\tstatic _CharT \t\t_S_terminal;\n+\n+\tsize_type \t\t_M_length;\n+\tsize_type \t\t_M_capacity;\n+\t_Atomic_word\t\t_M_references;\n+\t\n+        bool\n+\t_M_is_leaked() const\n+        { return _M_references < 0; }\n+\n+        bool\n+\t_M_is_shared() const\n+        { return _M_references > 0; }\n+\n+        void\n+\t_M_set_leaked() \n+        { _M_references = -1; }\n+\n+        void\n+\t_M_set_sharable() \n+        { _M_references = 0; }\n+\n+\t_CharT* \n+\t_M_refdata() throw()\n+\t{ return reinterpret_cast<_CharT*> (this + 1); }\n+\n+\t_CharT& \n+\toperator[](size_t __s) throw()\n+\t{ return _M_refdata() [__s]; }\n+\n+\t_CharT* \n+\t_M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)\n+\t{ return (!_M_is_leaked() && __alloc1 == __alloc2) ?\n+\t    _M_refcopy() : _M_clone(__alloc1);  }\n+\n+\t// Create & Destroy\n+\tstatic _Rep* \n+\t_S_create(size_t, const _Alloc&);\n+\n+\tvoid \n+\t_M_dispose(const _Alloc& __a)\n+\t{ \n+\t  if (__exchange_and_add(&_M_references, -1) <= 0)  \n+\t    _M_destroy(__a); \n+\t}  // XXX MT\n+\n+\tvoid \n+\t_M_destroy(const _Alloc&) throw();\n+\n+\t_CharT* \n+\t_M_refcopy() throw()\n+\t{ \n+\t  __atomic_add(&_M_references, 1); \n+\t  return _M_refdata(); \n+\t}  // XXX MT\n+\n+\t_CharT* \n+\t_M_clone(const _Alloc&, size_type __res = 0);\n+\n+#if _GLIBCPP_ALLOC_CONTROL\n+\t// These function pointers allow you to modify the allocation\n+\t// policy used by the string classes.  By default they expand by\n+\t// powers of two, but this may be excessive for space-critical\n+\t// applications.\n+\t\n+\t// Returns true if ALLOCATED is too much larger than LENGTH\n+\tstatic bool (*_S_excess_slop) (size_t __length, size_t __allocated);\n+\n+\tinline static bool \n+\t__default_excess(size_t, size_t);\n+#else\n+\tinline static bool \n+\t_S_excess_slop(size_t, size_t);\n+#endif\n+      };\n+\n+      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html\n+      struct _Alloc_hider : _Alloc\n+      {\n+\t_Alloc_hider(_CharT* __dat, const _Alloc& __a)\n+\t: _Alloc(__a), _M_p(__dat) { }\n+\n+\t_CharT* _M_p; // The actual data.\n+      };\n+\n+    public:\n+      // Data Members (public):\n+      // NB: This is an unsigned type, and thus represents the maximum\n+      // size that the allocator can hold.\n+      static const size_type \tnpos = static_cast<size_type>(-1);\n+\n+    private:\n+      // Data Members (private):\n+      mutable _Alloc_hider \t_M_dataplus;\n+\n+      // The following storage is init'd to 0 by the linker, resulting\n+      // (carefully) in an empty string with one reference.\n+      static size_type _S_empty_rep_storage[(sizeof(_Rep) + sizeof(_CharT) + sizeof(size_type) - 1)/sizeof(size_type)];\n+\n+      _CharT* \n+      _M_data() const \n+      { return  _M_dataplus._M_p; }\n+\n+      _CharT* \n+      _M_data(_CharT* __p) \n+      { return (_M_dataplus._M_p = __p); }\n+\n+      _Rep* \n+      _M_rep() const\n+      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }\n+\n+      // For the internal use we have functions similar to `begin'/`end'\n+      // but they do not call _M_leak.\n+      iterator \n+      _M_ibegin() const { return iterator(_M_data()); }\n+\n+      iterator \n+      _M_iend() const { return iterator(_M_data() + this->size()); }\n+\n+      void \n+      _M_leak()    // for use in begin() & non-const op[]\n+      { \n+\tif (!_M_rep()->_M_is_leaked()) \n+\t  _M_leak_hard(); \n+      }\n+\n+      iterator \n+      _M_check(size_type __pos) const\n+      { \n+\t__OUTOFRANGE(__pos > this->size()); \n+\treturn _M_ibegin() + __pos; \n+      }\n+\n+      // NB: _M_fold doesn't check for a bad __pos1 value.\n+      iterator \n+      _M_fold(size_type __pos, size_type __off) const\n+      { \n+\tbool __testoff =  __off < this->size() - __pos;\n+\tsize_type __newoff = __testoff ? __off : this->size() - __pos;\n+\treturn (_M_ibegin() + __pos + __newoff);\n+      }\n+\n+      // _S_copy_chars is a separate template to permit specialization\n+      // to optimize for the common case of pointers as iterators.\n+      template<class _Iterator>\n+        static void\n+        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)\n+        { \n+\t  for (; __k1 != __k2; ++__k1, ++__p) \n+\t    traits_type::assign(*__p, *__k1); //these types are off\n+\t}\n+\n+      static void\n+      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)\n+      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n+\n+      static void\n+      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)\n+      { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n+ \n+      static void\n+      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)\n+      { traits_type::copy(__p, __k1, __k2 - __k1); }\n+\n+      static void\n+      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)\n+      { traits_type::copy(__p, __k1, __k2 - __k1); }\n+\n+      void \n+      _M_mutate(size_type __pos, size_type __len1, size_type __len2);\n+\n+      void \n+      _M_leak_hard();\n+\n+      static _Rep& \n+      _S_empty_rep()\n+      { return *reinterpret_cast<_Rep*>(&_S_empty_rep_storage); }\n+\n+    public:\n+      // Construct/copy/destroy:\n+      // NB: We overload ctors in some cases instead of using default\n+      // arguments, per 17.4.4.4 para. 2 item 2.\n+\n+      inline \n+      basic_string();\n+\n+      explicit \n+      basic_string(const _Alloc& __a);\n+\n+      // NB: per LWG issue 42, semantics different from IS:\n+      basic_string(const basic_string& __str);\n+      basic_string(const basic_string& __str, size_type __pos,\n+\t\t   size_type __n = npos);\n+      basic_string(const basic_string& __str, size_type __pos,\n+\t\t   size_type __n, const _Alloc& __a);\n+\n+      basic_string(const _CharT* __s, size_type __n,\n+\t\t   const _Alloc& __a = _Alloc());\n+      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());\n+      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());\n+\n+      template<class _InputIterator>\n+        basic_string(_InputIterator __begin, _InputIterator __end,\n+\t\t     const _Alloc& __a = _Alloc());\n+\n+      ~basic_string() \n+      { _M_rep()->_M_dispose(this->get_allocator()); }\n+\n+      basic_string& \n+      operator=(const basic_string& __str) { return this->assign(__str); }\n+\n+      basic_string& \n+      operator=(const _CharT* __s) { return this->assign(__s); }\n+\n+      basic_string& \n+      operator=(_CharT __c) { return this->assign(1, __c); }\n+\n+      // Iterators:\n+      iterator \n+      begin() \n+      { \n+\t_M_leak(); \n+\treturn iterator(_M_data());\n+      }\n+\n+      const_iterator \n+      begin() const \n+      { return const_iterator(_M_data()); }\n+\n+      iterator \n+      end()\n+      {\n+         _M_leak();\n+\t return iterator(_M_data() + this->size());\n+      }\n+\n+      const_iterator \n+      end() const\n+      { return const_iterator(_M_data() + this->size()); }\n+\n+      reverse_iterator \n+      rbegin() \n+      { return reverse_iterator(this->end()); }\n+\n+      const_reverse_iterator \n+      rbegin() const \n+      { return const_reverse_iterator(this->end()); }\n+\n+      reverse_iterator \n+      rend() \n+      { return reverse_iterator(this->begin()); }\n+\n+      const_reverse_iterator \n+      rend() const \n+      { return const_reverse_iterator(this->begin()); }\n+\n+    public:\n+      // Capacity:\n+      size_type \n+      size() const { return _M_rep()->_M_length; }\n+\n+      size_type \n+      length() const { return _M_rep()->_M_length; }\n+\n+      size_type \n+      max_size() const { return _Rep::_S_max_size; }\n+\n+      void \n+      resize(size_type __n, _CharT __c);\n+\n+      void \n+      resize(size_type __n) { this->resize(__n, _CharT()); }\n+\n+      size_type \n+      capacity() const { return _M_rep()->_M_capacity; }\n+\n+      void \n+      reserve(size_type __res_arg = 0);\n+\n+      void \n+      clear() { _M_mutate(0, this->size(), 0); }\n+\n+      bool \n+      empty() const { return this->size() == 0; }\n+\n+      // Element access:\n+      const_reference \n+      operator[] (size_type __pos) const \n+      { return _M_data()[__pos]; }\n+\n+      reference \n+      operator[](size_type __pos) \n+      { \n+\t_M_leak(); \n+\treturn _M_data()[__pos]; \n+      }\n+\n+      const_reference \n+      at(size_type __n) const\n+      {\n+\t__OUTOFRANGE(__n >= this->size());\n+\treturn _M_data()[__n]; \n+      }\n+\n+      reference \n+      at(size_type __n)\n+      {\n+\t__OUTOFRANGE(__n >= size());\n+\t_M_leak(); \n+\treturn _M_data()[__n]; \n+      }\n+\n+      // Modifiers:\n+      basic_string& \n+      operator+=(const basic_string& __str) { return this->append(__str); }\n+\n+      basic_string& \n+      operator+=(const _CharT* __s) { return this->append(__s); }\n+\n+      basic_string& \n+      operator+=(_CharT __c) { return this->append(size_type(1), __c); }\n+\n+      basic_string& \n+      append(const basic_string& __str);\n+\n+      basic_string& \n+      append(const basic_string& __str, size_type __pos, size_type __n);\n+\n+      basic_string& \n+      append(const _CharT* __s, size_type __n);\n+\n+      basic_string& \n+      append(const _CharT* __s)\n+      { return this->append(__s, traits_type::length(__s)); }\n+\n+      basic_string& \n+      append(size_type __n, _CharT __c);\n+\n+      template<class _InputIterator>\n+        basic_string& \n+        append(_InputIterator __first, _InputIterator __last)\n+        { return this->replace(_M_iend(), _M_iend(), __first, __last); }\n+\n+      void \n+      push_back(_CharT __c)\n+      { this->replace(_M_iend(), _M_iend(), 1, __c); }\n+\n+      basic_string& \n+      assign(const basic_string& __str);\n+\n+      basic_string& \n+      assign(const basic_string& __str, size_type __pos, size_type __n)\n+      { \n+\treturn this->assign(__str._M_check(__pos), __str._M_fold(__pos, __n)); \n+      }\n+\n+      basic_string& \n+      assign(const _CharT* __s, size_type __n)\n+      { return this->assign(__s, __s + __n); }\n+\n+      basic_string& \n+      assign(const _CharT* __s)\n+      { return this->assign(__s, __s + traits_type::length(__s)); }\n+\n+      basic_string& \n+      assign(size_type __n, _CharT __c)\n+      { return this->replace(_M_ibegin(), _M_iend(), __n, __c); }\n+\n+      template<class _InputIterator>\n+        basic_string& \n+        assign(_InputIterator __first, _InputIterator __last)\n+        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }\n+\n+      void \n+      insert(iterator __p, size_type __n, _CharT __c)\n+      {\tthis->replace(__p, __p, __n, __c);  }\n+\n+      template<class _InputIterator>\n+        void insert(iterator __p, _InputIterator __beg, _InputIterator __end)\n+        { this->replace(__p, __p, __beg, __end); }\n+\n+      basic_string& \n+      insert(size_type __pos1, const basic_string& __str)\n+      { \n+\titerator __p = _M_check(__pos1);\n+\tthis->replace(__p, __p, __str._M_ibegin(), __str._M_iend());\n+        return *this; \n+      }\n+\n+      basic_string& \n+      insert(size_type __pos1, const basic_string& __str,\n+\t     size_type __pos2, size_type __n)\n+      { \n+\titerator __p = _M_check(__pos1);\n+\tthis->replace(__p, __p, __str._M_check(__pos2), \n+\t\t      __str._M_fold(__pos2, __n));\n+        return *this; \n+      }\n+\n+      basic_string& \n+      insert(size_type __pos, const _CharT* __s, size_type __n)\n+      { \n+\titerator __p = _M_check(__pos);\n+\tthis->replace(__p, __p, __s, __s + __n);\n+        return *this; \n+      }\n+\n+      basic_string&  \n+      insert(size_type __pos, const _CharT* __s)\n+      { return this->insert(__pos, __s, traits_type::length(__s)); }\n+\n+      basic_string& \n+      insert(size_type __pos, size_type __n, _CharT __c)\n+      { \n+\tthis->insert(_M_check(__pos), __n, __c); \n+\treturn *this; \n+      }\n+\n+      iterator \n+      insert(iterator __p, _CharT __c = _CharT())\n+      {\n+\tsize_type __pos = __p - _M_ibegin();\n+\tthis->insert(_M_check(__pos), size_type(1), __c);\n+\t_M_rep()->_M_set_leaked(); \n+ \treturn this->_M_ibegin() + __pos; \n+      }\n+\n+      basic_string& \n+      erase(size_type __pos = 0, size_type __n = npos)\n+      { \n+\treturn this->replace(_M_check(__pos), _M_fold(__pos, __n),\n+\t\t\t     _M_data(), _M_data()); \n+      }\n+\n+      iterator \n+      erase(iterator __position)\n+      {\n+\tsize_type __i = __position - _M_ibegin();\n+        this->replace(__position, __position + 1, _M_data(), _M_data());\n+\t_M_rep()->_M_set_leaked(); \n+\treturn _M_ibegin() + __i;\n+      }\n+\n+      iterator \n+      erase(iterator __first, iterator __last)\n+      {\n+        size_type __i = __first - _M_ibegin();\n+\tthis->replace(__first, __last, _M_data(), _M_data());\n+\t_M_rep()->_M_set_leaked();\n+       return _M_ibegin() + __i;\n+      }\n+\n+      basic_string& \n+      replace(size_type __pos, size_type __n, const basic_string& __str)\n+      { \n+\treturn this->replace(_M_check(__pos), _M_fold(__pos, __n),\n+\t\t\t      __str.begin(), __str.end()); \n+      }\n+\n+      basic_string& \n+      replace(size_type __pos1, size_type __n1, const basic_string& __str,\n+\t      size_type __pos2, size_type __n2);\n+\n+      basic_string& \n+      replace(size_type __pos, size_type __n1, const _CharT* __s,\n+\t      size_type __n2)\n+      { \n+\treturn this->replace(_M_check(__pos), _M_fold(__pos, __n1),\n+\t\t\t     __s, __s + __n2); \n+      }\n+\n+      basic_string& \n+      replace(size_type __pos, size_type __n1, const _CharT* __s)\n+      { \n+\treturn this->replace(_M_check(__pos), _M_fold(__pos, __n1),\n+\t\t\t     __s, __s + traits_type::length(__s)); \n+      }\n+\n+      basic_string& \n+      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)\n+      { \n+\treturn this->replace(_M_check(__pos), _M_fold(__pos, __n1), __n2, __c);\n+      }\n+\n+      basic_string& \n+      replace(iterator __i1, iterator __i2, const basic_string& __str)\n+      { return this->replace(__i1, __i2, __str.begin(), __str.end()); }\n+\n+      basic_string& \n+      replace(iterator __i1, iterator __i2,\n+                           const _CharT* __s, size_type __n)\n+      { return this->replace(__i1, __i2, __s, __s + __n); }\n+\n+      basic_string& \n+      replace(iterator __i1, iterator __i2, const _CharT* __s)\n+      { return this->replace(__i1, __i2, __s, \n+\t\t\t     __s + traits_type::length(__s)); }\n+\n+      basic_string& \n+      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c);\n+\n+      template<class _InputIterator>\n+        basic_string& \n+        replace(iterator __i1, iterator __i2,\n+\t\t_InputIterator __k1, _InputIterator __k2)\n+        { return _M_replace(__i1, __i2, __k1, __k2,\n+\t     typename iterator_traits<_InputIterator>::iterator_category()); }\n+\n+    private:\n+      template<class _InputIterator>\n+        basic_string& \n+        _M_replace(iterator __i1, iterator __i2, _InputIterator __k1, \n+\t\t   _InputIterator __k2, input_iterator_tag);\n+\n+      template<class _FwdIterator>\n+        basic_string& \n+        _M_replace(iterator __i1, iterator __i2, _FwdIterator __k1, \n+\t\t   _FwdIterator __k2, forward_iterator_tag);\n+\n+      // _S_construct_aux is used to implement the 21.3.1 para 15 which\n+      // requires special behaviour if _InIter is an integral type\n+      template<class _InIter>\n+        static _CharT*\n+        _S_construct_aux(_InIter __beg, _InIter __end, const _Alloc& __a,\n+\t\t\t __false_type)\n+\t{\n+          typedef typename iterator_traits<_InIter>::iterator_category _Tag;\n+          return _S_construct(__beg, __end, __a, _Tag());\n+\t}\n+ \n+      template<class _InIter>\n+        static _CharT*\n+        _S_construct_aux(_InIter __beg, _InIter __end, const _Alloc& __a,\n+\t\t\t __true_type)\n+\t{\n+\t  return _S_construct(static_cast<size_type>(__beg),\n+\t\t\t      static_cast<value_type>(__end), __a);\n+\t}\n+ \n+      template<class _InIter>\n+        static _CharT*\n+        _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a)\n+\t{\n+\t  typedef typename _Is_integer<_InIter>::_Integral _Integral;\n+\t  return _S_construct_aux(__beg, __end, __a, _Integral());\n+        }\n+\n+      // For Input Iterators, used in istreambuf_iterators, etc.\n+      template<class _InIter>\n+        static _CharT*\n+         _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a,\n+\t\t      input_iterator_tag);\n+      \n+      // For forward_iterators up to random_access_iterators, used for\n+      // string::iterator, _CharT*, etc.\n+      template<class _FwdIter>\n+        static _CharT*\n+        _S_construct(_FwdIter __end, _FwdIter __beg, const _Alloc& __a,\n+\t\t     forward_iterator_tag);\n+\n+      static _CharT* \n+      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);\n+\n+    public:\n+\n+      size_type \n+      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;\n+\n+      void \n+      swap(basic_string<_CharT, _Traits, _Alloc>& __s);\n+\n+      // String operations:\n+      const _CharT* \n+      c_str() const\n+      {\n+\t// MT: This assumes concurrent writes are OK.\n+\tsize_type __n = this->size();\n+\ttraits_type::assign(_M_data()[__n], _Rep::_S_terminal);\n+        return _M_data();\n+      }\n+\n+      const _CharT* \n+      data() const { return _M_data(); }\n+\n+      allocator_type \n+      get_allocator() const { return _M_dataplus; }\n+\n+      size_type \n+      find(const _CharT* __s, size_type __pos, size_type __n) const;\n+\n+      size_type \n+      find(const basic_string& __str, size_type __pos = 0) const\n+      { return this->find(__str.data(), __pos, __str.size()); }\n+\n+      size_type \n+      find(const _CharT* __s, size_type __pos = 0) const\n+      { return this->find(__s, __pos, traits_type::length(__s)); }\n+\n+      size_type \n+      find(_CharT __c, size_type __pos = 0) const;\n+\n+      size_type \n+      rfind(const basic_string& __str, size_type __pos = npos) const\n+      { return this->rfind(__str.data(), __pos, __str.size()); }\n+\n+      size_type \n+      rfind(const _CharT* __s, size_type __pos, size_type __n) const;\n+\n+      size_type \n+      rfind(const _CharT* __s, size_type __pos = npos) const\n+      { return this->rfind(__s, __pos, traits_type::length(__s)); }\n+\n+      size_type \n+      rfind(_CharT __c, size_type __pos = npos) const;\n+\n+      size_type \n+      find_first_of(const basic_string& __str, size_type __pos = 0) const\n+      { return this->find_first_of(__str.data(), __pos, __str.size()); }\n+\n+      size_type \n+      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;\n+\n+      size_type \n+      find_first_of(const _CharT* __s, size_type __pos = 0) const\n+      { return this->find_first_of(__s, __pos, traits_type::length(__s)); }\n+\n+      size_type \n+      find_first_of(_CharT __c, size_type __pos = 0) const\n+      { return this->find(__c, __pos); }\n+\n+      size_type \n+      find_last_of(const basic_string& __str, size_type __pos = npos) const\n+      { return this->find_last_of(__str.data(), __pos, __str.size()); }\n+\n+      size_type \n+      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;\n+\n+      size_type \n+      find_last_of(const _CharT* __s, size_type __pos = npos) const\n+      { return this->find_last_of(__s, __pos, traits_type::length(__s)); }\n+\n+      size_type \n+      find_last_of(_CharT __c, size_type __pos = npos) const\n+      { return this->rfind(__c, __pos); }\n+\n+      size_type \n+      find_first_not_of(const basic_string& __str, size_type __pos = 0) const\n+      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }\n+\n+      size_type \n+      find_first_not_of(const _CharT* __s, size_type __pos, \n+\t\t\tsize_type __n) const;\n+\n+      size_type \n+      find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n+      { return this->find_first_not_of(__s, __pos, traits_type::length(__s)); }\n+\n+      size_type \n+      find_first_not_of(_CharT __c, size_type __pos = 0) const;\n+\n+      size_type \n+      find_last_not_of(const basic_string& __str, size_type __pos = npos) const\n+      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }\n+\n+      size_type \n+      find_last_not_of(const _CharT* __s, size_type __pos, \n+\t\t       size_type __n) const;\n+      size_type \n+      find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n+      { return this->find_last_not_of(__s, __pos, traits_type::length(__s)); }\n+\n+      size_type \n+      find_last_not_of(_CharT __c, size_type __pos = npos) const;\n+\n+      basic_string \n+      substr(size_type __pos = 0, size_type __n = npos) const\n+      { \n+\t__OUTOFRANGE(__pos > this->size());\n+\treturn basic_string(*this, __pos, __n); \n+      }\n+\n+      int \n+      compare(const basic_string& __str) const\n+      {\n+\tsize_type __size = this->size();\n+\tsize_type __osize = __str.size();\n+\tsize_type __len = min(__size, __osize);\n+      \n+\tint __r = traits_type::compare(_M_data(), __str.data(), __len);\n+\tif (!__r)\n+\t  __r =  __size - __osize;\n+\treturn __r;\n+      }\n+\n+      int \n+      compare(size_type __pos, size_type __n, const basic_string& __str) const;\n+\n+      int \n+      compare(size_type __pos1, size_type __n1, const basic_string& __str,\n+\t      size_type __pos2, size_type __n2) const;\n+\n+      int \n+      compare(const _CharT* __s) const;\n+\n+      int \n+      compare(size_type __pos, size_type __n1, const _CharT* __s, \n+\t      size_type __n2 = npos) const;\n+ \n+    private:\n+      static const _CharT* \n+      _S_find(const _CharT* __beg, const _CharT* __end, _CharT __c);\n+  };\n+\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline basic_string<_CharT, _Traits, _Alloc>::\n+    basic_string()\n+    : _M_dataplus(_S_empty_rep()._M_refcopy(), _Alloc()) { }\n+\n+  // operator+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_string<_CharT, _Traits, _Alloc>\n+    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    {\n+      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n+      __str.append(__rhs);\n+      return __str;\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_string<_CharT,_Traits,_Alloc>\n+    operator+(const _CharT* __lhs,\n+\t      const basic_string<_CharT,_Traits,_Alloc>& __rhs);\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_string<_CharT,_Traits,_Alloc>\n+    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline basic_string<_CharT, _Traits, _Alloc>\n+    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t     const _CharT* __rhs)\n+    {\n+      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n+      __str.append(__rhs);\n+      return __str;\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline basic_string<_CharT, _Traits, _Alloc>\n+    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)\n+    {\n+      typedef basic_string<_CharT, _Traits, _Alloc> \t__string_type;\n+      typedef typename __string_type::size_type\t\t__size_type;\n+      __string_type __str(__lhs);\n+      __str.append(__size_type(1), __rhs);\n+      return __str;\n+    }\n+\n+  // operator ==\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __lhs.compare(__rhs) == 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator==(const _CharT* __lhs,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __rhs.compare(__lhs) == 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const _CharT* __rhs)\n+    { return __lhs.compare(__rhs) == 0; }\n+\n+  // operator !=\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __rhs.compare(__lhs) != 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator!=(const _CharT* __lhs,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __rhs.compare(__lhs) != 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const _CharT* __rhs)\n+    { return __lhs.compare(__rhs) != 0; }\n+\n+  // operator <\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __lhs.compare(__rhs) < 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t      const _CharT* __rhs)\n+    { return __lhs.compare(__rhs) < 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator<(const _CharT* __lhs,\n+\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __rhs.compare(__lhs) > 0; }\n+\n+  // operator >\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __lhs.compare(__rhs) > 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t      const _CharT* __rhs)\n+    { return __lhs.compare(__rhs) > 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator>(const _CharT* __lhs,\n+\t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __rhs.compare(__lhs) < 0; }\n+\n+  // operator <=\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __lhs.compare(__rhs) <= 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const _CharT* __rhs)\n+    { return __lhs.compare(__rhs) <= 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator<=(const _CharT* __lhs,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+  { return __rhs.compare(__lhs) >= 0; }\n+\n+  // operator >=\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __lhs.compare(__rhs) >= 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t       const _CharT* __rhs)\n+    { return __lhs.compare(__rhs) >= 0; }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline bool\n+    operator>=(const _CharT* __lhs,\n+\t     const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { return __rhs.compare(__lhs) <= 0; }\n+\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline void\n+    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,\n+\t basic_string<_CharT, _Traits, _Alloc>& __rhs)\n+    { __lhs.swap(__rhs); }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_istream<_CharT, _Traits>&\n+    operator>>(basic_istream<_CharT, _Traits>& __is,\n+\t       basic_string<_CharT, _Traits, _Alloc>& __str);\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __os,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __str);\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_istream<_CharT,_Traits>&\n+    getline(basic_istream<_CharT, _Traits>& __is,\n+\t    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    inline basic_istream<_CharT,_Traits>&\n+    getline(basic_istream<_CharT, _Traits>& __is,\n+\t    basic_string<_CharT, _Traits, _Alloc>& __str);\n+\n+} // namespace std\n+\n+#endif /* _CPP_BITS_STRING_H */"}, {"sha": "07667353a0441e78cc20e8ce023eaf6aabe2220e", "filename": "libstdc++-v3/include/bits/c++config", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,72 @@\n+// Predefined symbols and macros -*- C++ -*-\n+\n+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_CPPCONFIG\n+#define _CPP_CPPCONFIG 1\n+\n+// The current version of the C++ library in compressed ISO date format.\n+#define __GLIBCPP__ 20000911\n+\n+// By enabling this, all GNU extensions are enabled.\n+#define _GNU_SOURCE 1\n+\n+// By enabling this, all ISO C99, ISO C9X functionality is enabled.\n+#define _ISOC99_SOURCE 1\n+\n+// This flag controls the error handling in string, and perhaps other\n+// bits as time goes on: check out bits/basic_string.h for more\n+// info. It also helps alleviate the circular dependency between\n+// string and exception.\n+# define _GLIBCPP_USE_EXCEPTIONS 1 \n+\n+// This is necessary until Egcs supports separate template\n+// compilation.  \n+#define _GLIBCPP_NO_TEMPLATE_EXPORT 1\n+\n+// This is a hack around not having either pre-compiled headers or\n+// export compilation. If defined, the io, string, and valarray\n+// headers will include all the necessary bits. If not defined, the\n+// implementation optimizes the headers for the most commonly-used\n+// types. For the io library, this means that larger, out-of-line\n+// member functions are only declared, and definitions are not parsed\n+// by the compiler, but instead instantiated into the library binary.\n+//#define _GLIBCPP_FULLY_COMPLIANT_HEADERS 1\n+\n+// To enable older, ARM-style iostreams and other anachronisms use this.\n+//#define _GLIBCPP_DEPRICATED 1\n+\n+// Use corrected code from the committee library group's issues list.\n+# define _GLIBCPP_RESOLVE_LIB_DEFECTS 1\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "baab72293c345405b098544d3f4cb12c8c043926", "filename": "libstdc++-v3/include/bits/char_traits.h", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,307 @@\n+// Character Traits for use by standard string and iostream -*- C++ -*-\n+\n+// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 21  Strings library\n+//\n+\n+#ifndef _CPP_BITS_CHAR_TRAITS_H\n+#define _CPP_BITS_CHAR_TRAITS_H 1\n+\n+#include <bits/std_cwchar.h> \t// For mbstate_t.\n+#include <bits/std_cstring.h> \t// For memmove, memset, memchr\n+#include <bits/fpos.h> \t\t// For streamoff, streamsize\n+\n+namespace std {\n+\n+  // Same as iosfwd\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+  // Can't have self-recursive types for streampos. \n+  // 21.1.3.1 char_traits sets size_type to streampos\n+  // 27.4.1 \n+  // And here, where streampos is typedefed to fpos<traits::state_type>\n+    typedef fpos<mbstate_t> \tstreampos;\n+#  ifdef _GLIBCPP_USE_WCHAR_T\n+    typedef fpos<mbstate_t> \twstreampos;\n+#  endif\n+#endif\n+\n+  // 21.1.2 Basis for explicit _Traits specialization \n+  // NB: That for any given actual character type this definition is\n+  // probably wrong.\n+\n+  template<class _CharT>\n+    struct char_traits\n+    {\n+      typedef _CharT \t\tchar_type;\n+      // Unsigned as wint_t in unsigned.\n+      typedef unsigned long  \tint_type;\n+      typedef streampos \tpos_type;\n+      typedef streamoff \toff_type;\n+      typedef mbstate_t \tstate_type;\n+      \n+      static void \n+      assign(char_type& __c1, const char_type& __c2)\n+      { __c1 = __c2; }\n+\n+      static bool \n+      eq(const char_type& __c1, const char_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static bool \n+      lt(const char_type& __c1, const char_type& __c2)\n+      { return __c1 < __c2; }\n+\n+      static int \n+      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n+      { \n+\tfor (size_t __i = 0; __i < __n; ++__i)\n+\t  if (!eq(__s1[__i], __s2[__i]))\n+\t    return lt(__s1[__i], __s2[__i]) ? -1 : 1;\n+\treturn 0; \n+      }\n+\n+      static size_t\n+      length(const char_type* __s)\n+      { \n+\tconst char_type* __p = __s; \n+\twhile (*__p) ++__p; \n+\treturn (__p - __s); \n+      }\n+\n+      static const char_type* \n+      find(const char_type* __s, size_t __n, const char_type& __a)\n+      { \n+\tfor (const char_type* __p = __s; size_t(__p - __s) < __n; ++__p)\n+\t  if (*__p == __a) return __p;\n+\treturn 0;\n+      }\n+\n+      static char_type* \n+      move(char_type* __s1, const char_type* __s2, size_t __n)\n+      { return (char_type*) memmove(__s1, __s2, __n * sizeof(char_type)); }\n+\n+      static char_type* \n+      copy(char_type* __s1, const char_type* __s2, size_t __n)\n+      { return (char_type*) memcpy(__s1, __s2, __n * sizeof(char_type)); }\n+\n+      static char_type* \n+      assign(char_type* __s, size_t __n, char_type __a)\n+      { \n+\tfor (char_type* __p = __s; __p < __s + __n; ++__p) \n+\t  assign(*__p, __a);\n+        return __s; \n+      }\n+\n+      static char_type \n+      to_char_type(const int_type& __c)\n+      { return char_type(__c); }\n+\n+      static int_type \n+      to_int_type(const char_type& __c) { return int_type(__c); }\n+\n+      static bool \n+      eq_int_type(const int_type& __c1, const int_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static state_type \n+      _S_get_state(const pos_type& __pos) { return __pos.state(); }\n+\n+      static int_type \n+      eof() { return static_cast<int_type>(-1); }\n+\n+      static int_type \n+      _S_eos() { return char_type(); }\n+\n+      static int_type \n+      not_eof(const int_type& __c)\n+      { return eq_int_type(__c, eof()) ? int_type(0) : __c; }\n+    };\n+\n+  // 21.1.4  char_traits specializations\n+  template<>\n+    struct char_traits<char>\n+    {\n+      typedef char \t\tchar_type;\n+      typedef unsigned int \tint_type;\n+      typedef streampos \tpos_type;\n+      typedef streamoff \toff_type;\n+      typedef mbstate_t \tstate_type;\n+\n+      static void \n+      assign(char_type& __c1, const char_type& __c2)\n+      { __c1 = __c2; }\n+\n+      static bool \n+      eq(const char_type& __c1, const char_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static bool \n+      lt(const char_type& __c1, const char_type& __c2)\n+      { return __c1 < __c2; }\n+\n+      static int \n+      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n+      { return memcmp(__s1, __s2, __n); }\n+\n+      static size_t\n+      length(const char_type* __s)\n+      { return strlen(__s); }\n+\n+      static const char_type* \n+      find(const char_type* __s, size_t __n, const char_type& __a)\n+      { return static_cast<const char_type*>(memchr(__s, __a, __n)); }\n+\n+      static char_type* \n+      move(char_type* __s1, const char_type* __s2, size_t __n)\n+      { return static_cast<char_type*>(memmove(__s1, __s2, __n)); }\n+\n+      static char_type* \n+      copy(char_type* __s1, const char_type* __s2, size_t __n)\n+      {  return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }\n+\n+      static char_type* \n+      assign(char_type* __s, size_t __n, char_type __a)\n+      { return static_cast<char_type*>(memset(__s, __a, __n)); }\n+\n+      static char_type \n+      to_char_type(const int_type& __c)\n+      { return static_cast<char_type>(__c); }\n+\n+      // To keep both the byte 0xff and the eof symbol 0xffffffff\n+      // from ending up as 0xffffffff.\n+      static int_type \n+      to_int_type(const char_type& __c)\n+      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }\n+\n+      static bool \n+      eq_int_type(const int_type& __c1, const int_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static state_type \n+      _S_get_state(const pos_type& __pos) { return __pos.state(); }\n+\n+      static int_type \n+      eof() { return static_cast<int_type>(EOF); }\n+\n+      static int_type \n+      _S_eos() { return char_type(); }\n+\n+      static int_type \n+      not_eof(const int_type& __c)\n+      { return (__c == eof()) ? 0 : __c; }\n+  };\n+\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    struct char_traits<wchar_t>\n+    {\n+      typedef wchar_t \t\tchar_type;\n+      typedef wint_t \t\tint_type;\n+      typedef wstreamoff \toff_type;\n+      typedef wstreampos \tpos_type;\n+      typedef mbstate_t \tstate_type;\n+      \n+      static void \n+      assign(char_type& __c1, const char_type& __c2)\n+      { __c1 = __c2; }\n+\n+      static bool \n+      eq(const char_type& __c1, const char_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static bool \n+      lt(const char_type& __c1, const char_type& __c2)\n+      { return __c1 < __c2; }\n+\n+      static int \n+      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n+      { return wmemcmp(__s1, __s2, __n); }\n+\n+      static size_t\n+      length(const char_type* __s)\n+      { return wcslen(__s); }\n+\n+      static const char_type* \n+      find(const char_type* __s, size_t __n, const char_type& __a)\n+      { return wmemchr(__s, __a, __n); }\n+\n+      static char_type* \n+      move(char_type* __s1, const char_type* __s2, int_type __n)\n+      { return wmemmove(__s1, __s2, __n); }\n+\n+      static char_type* \n+      copy(char_type* __s1, const char_type* __s2, size_t __n)\n+      { return wmemcpy(__s1, __s2, __n); }\n+\n+      static char_type* \n+      assign(char_type* __s, size_t __n, char_type __a)\n+      { return wmemset(__s, __a, __n); }\n+\n+      static char_type \n+      to_char_type(const int_type& __c) { return char_type(__c); }\n+\n+      static int_type \n+      to_int_type(const char_type& __c) { return int_type(__c); }\n+\n+      static bool \n+      eq_int_type(const int_type& __c1, const int_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static state_type \n+      _S_get_state(const pos_type& __pos) { return __pos.state(); }\n+\n+      static int_type \n+      eof() { return static_cast<int_type>(WEOF); }\n+\n+      static int_type \n+      _S_eos() { return char_type(); }\n+\n+      static int_type \n+      not_eof(const int_type& __c)\n+      { return eq_int_type(__c, eof()) ? 0 : __c; }\n+  };\n+#endif //_GLIBCPP_USE_WCHAR_T\n+\n+  template<typename _CharT, typename _Traits>\n+    struct _Char_traits_match\n+    {\n+      _CharT _M_c;\n+      _Char_traits_match(_CharT const& __c) : _M_c(__c) { }\n+\n+      bool \n+      operator()(_CharT const& __a) { return _Traits::eq(_M_c,__a); }\n+    };\n+\n+} // namespace std\n+\n+\n+#endif /* _CPP_BITS_CHAR_TRAITS_H */\n+"}, {"sha": "1306434a18c7526ec115639725d552d2bfc6da90", "filename": "libstdc++-v3/include/bits/codecvt.h", "status": "added", "additions": 662, "deletions": 0, "changes": 662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,662 @@\n+// Locale support (codecvt) -*- C++ -*-\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 22.2.1.5 Template class codecvt\n+//\n+\n+// Warning: this file is not meant for user inclusion.  Use <locale>.\n+\n+// Written by Benjamin Kosnik <bkoz@cygnus.com>\n+\n+#ifndef _CPP_BITS_CODECVT_H\n+#define _CPP_BITS_CODECVT_H\t1\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+#include <iconv.h>\t\t// For iconv, iconv_t\n+#include <langinfo.h>\n+#endif\n+\n+namespace std\n+{\n+  // XXX __enc_traits may need to move up the locale header hierarchy,\n+  // depending on if ctype ends up using it.\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  // Extensions to use icov for dealing with character encodings,\n+  // including conversions and comparisons between various character\n+  // sets.  This object encapsulates data that may need to be shared between\n+  // char_traits, codecvt and ctype.\n+  class __enc_traits\n+  {\n+  public:\n+    // Types: \n+    // NB: A conversion descriptor subsumes and enhances the\n+    // functionality of a simple state type such as mbstate_t.\n+    typedef iconv_t\t__desc_type;\n+    \n+  protected:\n+    // Data Members:\n+    // Max size of charset encoding name\n+    static const int \t_S_max_size = 32;\n+    // Name of internal character set encoding.\n+    char\t       \t_M_intc_enc[_S_max_size];\n+    // Name of external character set encoding.\n+    char  \t       \t_M_extc_enc[_S_max_size];\n+\n+    // Conversion descriptor between external encoding to internal encoding.\n+    __desc_type\t\t_M_in_desc;\n+    // Conversion descriptor between internal encoding to external encoding.\n+    __desc_type\t\t_M_out_desc;\n+\n+  public:\n+    __enc_traits() : _M_in_desc(0), _M_out_desc(0)\n+    {\n+      // __intc_end = whatever we are using internally, which is\n+      // UCS4 (linux) \n+      // UCS2 == UNICODE  (microsoft, java, aix, whatever...)\n+      // XXX Currently don't know how to get this data from target system...\n+      strcpy(_M_intc_enc, \"UCS4\");\n+\n+      // __extc_end = external codeset in current locale\n+      strcpy(_M_extc_enc, nl_langinfo(CODESET));\n+    }\n+\n+    __enc_traits(const char* __int, const char* __ext)\n+    : _M_in_desc(0), _M_out_desc(0)\n+    {\n+      strncpy(_M_intc_enc, __int, _S_max_size);\n+      strncpy(_M_extc_enc, __ext, _S_max_size);\n+    }\n+\n+    // 21.1.2 traits typedefs\n+    // p4\n+    // typedef STATE_T state_type\n+    // requires: state_type shall meet the requirements of\n+    // CopyConstructible types (20.1.3)\n+    __enc_traits(const __enc_traits& __obj)\n+    {\n+      strncpy(_M_intc_enc, __obj._M_intc_enc, _S_max_size);\n+      strncpy(_M_extc_enc, __obj._M_extc_enc, _S_max_size);\n+    }\n+\n+    ~__enc_traits()\n+    {\n+      iconv_close(_M_in_desc);\n+      iconv_close(_M_out_desc);\n+    } \n+\n+    // Initializes\n+    void\n+    _M_init()\n+    {\n+      _M_in_desc = iconv_open(_M_intc_enc, _M_extc_enc);\n+      _M_out_desc = iconv_open(_M_extc_enc, _M_intc_enc);\n+      if (_M_out_desc == iconv_t(-1) || _M_in_desc == iconv_t(-1))\n+\t{\n+\t  // XXX Extended error checking.\n+\t}\n+    }\n+\n+    bool\n+    _M_good()\n+    { \n+      return _M_out_desc && _M_in_desc \n+\t     && _M_out_desc != iconv_t(-1) && _M_in_desc != iconv_t(-1);\n+    }\n+\n+    const __desc_type* \n+    _M_get_in_descriptor()\n+    { return &_M_in_desc; }\n+\n+    const __desc_type* \n+    _M_get_out_descriptor()\n+    { return &_M_out_desc; }\n+\n+   const char* \n+    _M_get_internal_enc()\n+    { return _M_intc_enc; }\n+\n+    const char* \n+    _M_get_external_enc()\n+    { return _M_extc_enc; }\n+  };\n+#endif //_GLIBCPP_USE_WCHAR_T\n+\n+\n+  //  22.2.1.5  Template class codecvt\n+  class codecvt_base\n+  {\n+  public:\n+    enum result\n+    {\n+      ok,\n+      partial,\n+      error,\n+      noconv\n+    };\n+  };\n+\n+  // Template class __codecvt_abstract_base\n+  // NB: An abstract base class that fills in the public inlines, so\n+  // that the specializations don't have to re-copy the public\n+  // interface.\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    class __codecvt_abstract_base \n+    : public locale::facet, public codecvt_base\n+    {\n+    public:\n+      // Types:\n+      typedef codecvt_base::result\t\t\tresult;\n+      typedef _InternT \t\t\t\t\tintern_type;\n+      typedef _ExternT \t\t\t\t\textern_type;\n+      typedef _StateT  \t\t\t\t\tstate_type;\n+      \n+      // 22.2.1.5.1 codecvt members\n+      result\n+      out(state_type& __state, const intern_type* __from, \n+\t  const intern_type* __from_end, const intern_type*& __from_next,\n+\t  extern_type* __to, extern_type* __to_end, \n+\t  extern_type*& __to_next) const\n+      { \n+\treturn this->do_out(__state, __from, __from_end, __from_next, \n+\t\t\t    __to, __to_end, __to_next); \n+      }\n+\n+      result\n+      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,\n+\t      extern_type*& __to_next) const\n+      { return this->do_unshift(__state, __to,__to_end,__to_next); }\n+\n+      result\n+      in(state_type& __state, const extern_type* __from, \n+\t const extern_type* __from_end, const extern_type*& __from_next,\n+\t intern_type* __to, intern_type* __to_end, \n+\t intern_type*& __to_next) const\n+      { \n+\treturn this->do_in(__state, __from, __from_end, __from_next,\n+\t\t\t   __to, __to_end, __to_next); \n+      }\n+\n+      int \n+      encoding() const throw()\n+      { return this->do_encoding(); }\n+\n+      bool \n+      always_noconv() const throw()\n+      { return this->do_always_noconv(); }\n+\n+      int\n+      length(const state_type& __state, const extern_type* __from,\n+\t     const extern_type* __end, size_t __max) const\n+      { return this->do_length(__state, __from, __end, __max); }\n+\n+      int \n+      max_length() const throw()\n+      { return this->do_max_length(); }\n+\n+    protected:\n+      explicit \n+      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      virtual \n+      ~__codecvt_abstract_base() { }\n+\n+      virtual result\n+      do_out(state_type& __state, const intern_type* __from, \n+\t     const intern_type* __from_end, const intern_type*& __from_next,\n+\t     extern_type* __to, extern_type* __to_end,\n+\t     extern_type*& __to_next) const = 0;\n+\n+      virtual result\n+      do_unshift(state_type& __state, extern_type* __to, \n+\t\t extern_type* __to_end, extern_type*& __to_next) const = 0;\n+      \n+      virtual result\n+      do_in(state_type& __state, const extern_type* __from, \n+\t    const extern_type* __from_end, const extern_type*& __from_next, \n+\t    intern_type* __to, intern_type* __to_end, \n+\t    intern_type*& __to_next) const = 0;\n+      \n+      virtual int \n+      do_encoding() const throw() = 0;\n+\n+      virtual bool \n+      do_always_noconv() const throw() = 0;\n+\n+      virtual int \n+      do_length(const state_type&, const extern_type* __from, \n+\t\tconst extern_type* __end, size_t __max) const = 0;\n+\n+      virtual int \n+      do_max_length() const throw() = 0;\n+    };\n+\n+  // 22.2.1.5 Template class codecvt\n+  // NB: Generic, mostly useless implementation.\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    class codecvt \n+    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>\n+    {\n+    public:      \n+      // Types:\n+      typedef codecvt_base::result\t\t\tresult;\n+      typedef _InternT intern_type;\n+      typedef _ExternT extern_type;\n+      typedef _StateT  state_type;\n+\n+      // Data Members:\n+      static locale::id id;\n+\n+      explicit \n+      codecvt(size_t __refs = 0) \n+      : __codecvt_abstract_base<_InternT,_ExternT,_StateT> (__refs) { }\n+\n+    protected:\n+      virtual \n+      ~codecvt() { }\n+    };\n+\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    locale::id codecvt<_InternT, _ExternT, _StateT>::id;\n+\n+  // partial specialization\n+  // This specialization takes advantage of iconv to provide code\n+  // conversions between a large number of character encodings.\n+  template<typename _InternT, typename _ExternT>\n+    class codecvt<_InternT, _ExternT, __enc_traits>\n+    : public __codecvt_abstract_base<_InternT, _ExternT, __enc_traits>\n+    {\n+    public:      \n+      // Types:\n+      typedef codecvt_base::result\t\t\tresult;\n+      typedef _InternT \t\t\t\t\tintern_type;\n+      typedef _ExternT \t\t\t\t\textern_type;\n+      typedef __enc_traits \t\t\t\tstate_type;\n+      typedef __enc_traits::__desc_type \t\t__desc_type;\n+      typedef __enc_traits\t\t\t\t__enc_type;\n+\n+      // Data Members:\n+      static locale::id \t\tid;\n+\n+      explicit \n+      codecvt(size_t __refs = 0)\n+      : __codecvt_abstract_base<intern_type, extern_type, state_type>(__refs)\n+      { }\n+\n+      explicit \n+      codecvt(__enc_type* __enc, size_t __refs = 0)\n+      : __codecvt_abstract_base<intern_type, extern_type, state_type>(__refs)\n+      { }\n+\n+    protected:\n+      virtual \n+      ~codecvt() { }\n+\n+      virtual result\n+      do_out(state_type& __state, const intern_type* __from, \n+\t     const intern_type* __from_end, const intern_type*& __from_next,\n+\t     extern_type* __to, extern_type* __to_end,\n+\t     extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_unshift(state_type& __state, extern_type* __to, \n+\t\t extern_type* __to_end, extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_in(state_type& __state, const extern_type* __from, \n+\t    const extern_type* __from_end, const extern_type*& __from_next,\n+\t    intern_type* __to, intern_type* __to_end, \n+\t    intern_type*& __to_next) const;\n+\n+      virtual int \n+      do_encoding() const throw();\n+\n+      virtual bool \n+      do_always_noconv() const throw();\n+\n+      virtual int \n+      do_length(const state_type&, const extern_type* __from, \n+\t\tconst extern_type* __end, size_t __max) const;\n+\n+      virtual int \n+      do_max_length() const throw();\n+    };\n+\n+  template<typename _InternT, typename _ExternT>\n+    locale::id \n+    codecvt<_InternT, _ExternT, __enc_traits>::id;\n+\n+  template<typename _InternT, typename _ExternT>\n+    codecvt_base::result\n+    codecvt<_InternT, _ExternT, __enc_traits>::\n+    do_out(state_type& __state, const intern_type* __from, \n+\t   const intern_type* __from_end, const intern_type*& __from_next,\n+\t   extern_type* __to, extern_type* __to_end,\n+\t   extern_type*& __to_next) const\n+    {\n+      result __ret = error;\n+      if (__state._M_good())\n+\t{\n+\t  typedef state_type::__desc_type\t__desc_type;\n+\t  const __desc_type* __desc = __state._M_get_out_descriptor();\n+\t  const size_t __fmultiple = sizeof(intern_type) / sizeof(char);\n+\t  size_t __flen = __fmultiple * (__from_end - __from);\n+\t  const size_t __tmultiple = sizeof(extern_type) / sizeof(char);\n+\t  size_t __tlen = __tmultiple * (__to_end - __to); \n+\t  \n+\t  // Argument list for iconv specifies a byte sequence. Thus,\n+\t  // all to/from arrays must be brutally casted to char*.\n+\t  char* __cfrom = reinterpret_cast<char*>(const_cast<intern_type*>(__from));\n+\t  char* __cto = reinterpret_cast<char*>(__to);\n+\t  size_t __conv = iconv(*__desc, &__cfrom, &__flen, &__cto, &__tlen); \n+\t  \n+\t  if (__conv != size_t(-1))\n+\t    {\n+\t      __from_next = reinterpret_cast<const intern_type*>(__cfrom);\n+\t      __to_next = reinterpret_cast<extern_type*>(__cto);\n+\t      __ret = ok;\n+\t    }\n+\t  else \n+\t    {\n+\t      if (__flen < __from_end - __from)\n+\t\t{\n+\t\t  __from_next = reinterpret_cast<const intern_type*>(__cfrom);\n+\t\t  __to_next = reinterpret_cast<extern_type*>(__cto);\n+\t\t  __ret = partial;\n+\t\t}\n+\t      else\n+\t\t__ret = error;\n+\t    }\n+\t}\n+      return __ret; \n+    }\n+\n+  template<typename _InternT, typename _ExternT>\n+    codecvt_base::result\n+    codecvt<_InternT, _ExternT, __enc_traits>::\n+    do_unshift(state_type& __state, extern_type* __to, \n+\t       extern_type* __to_end, extern_type*& __to_next) const\n+    {\n+      result __ret = error;\n+      if (__state._M_good())\n+\t{\n+\t  typedef state_type::__desc_type\t__desc_type;\n+\t  const __desc_type* __desc = __state._M_get_in_descriptor();\n+\t  const size_t __tmultiple = sizeof(intern_type) / sizeof(char);\n+\t  size_t __tlen = __tmultiple * (__to_end - __to); \n+\t  \n+\t  // Argument list for iconv specifies a byte sequence. Thus,\n+\t  // all to/from arrays must be brutally casted to char*.\n+\t  char* __cto = reinterpret_cast<char*>(__to);\n+\t  size_t __conv = iconv(*__desc, NULL, NULL, &__cto, &__tlen); \n+\t  \n+\t  if (__conv != size_t(-1))\n+\t    {\n+\t      __to_next = reinterpret_cast<extern_type*>(__cto);\n+\t      if (__tlen == __tmultiple * (__to_end - __to))\n+\t\t__ret = noconv;\n+\t      else if (__tlen == 0)\n+\t\t__ret = ok;\n+\t      else\n+\t\t__ret = partial;\n+\t    }\n+\t  else \n+\t    __ret = error;\n+\t}\n+      return __ret; \n+    }\n+   \n+  template<typename _InternT, typename _ExternT>\n+    codecvt_base::result\n+    codecvt<_InternT, _ExternT, __enc_traits>::\n+    do_in(state_type& __state, const extern_type* __from, \n+\t  const extern_type* __from_end, const extern_type*& __from_next,\n+\t  intern_type* __to, intern_type* __to_end, \n+\t  intern_type*& __to_next) const\n+    { \n+      result __ret = error;\n+      if (__state._M_good())\n+\t{\n+\t  typedef state_type::__desc_type\t__desc_type;\n+\t  const __desc_type* __desc = __state._M_get_in_descriptor();\n+\t  const size_t __fmultiple = sizeof(extern_type) / sizeof(char);\n+\t  size_t __flen = __fmultiple * (__from_end - __from);\n+\t  const size_t __tmultiple = sizeof(intern_type) / sizeof(char);\n+\t  size_t __tlen = __tmultiple * (__to_end - __to); \n+\t  \n+\t  // Argument list for iconv specifies a byte sequence. Thus,\n+\t  // all to/from arrays must be brutally casted to char*.\n+\t  char* __cfrom = reinterpret_cast<char*>(const_cast<extern_type*>(__from));\n+\t  char* __cto = reinterpret_cast<char*>(__to);\n+\t  size_t __conv = iconv(*__desc, &__cfrom, &__flen, &__cto, &__tlen); \n+\t  \n+\t  if (__conv != size_t(-1))\n+\t    {\n+\t      __from_next = reinterpret_cast<const extern_type*>(__cfrom);\n+\t      __to_next = reinterpret_cast<intern_type*>(__cto);\n+\t      __ret = ok;\n+\t    }\n+\t  else \n+\t    {\n+\t      if (__flen < __from_end - __from)\n+\t\t{\n+\t\t  __from_next = reinterpret_cast<const extern_type*>(__cfrom);\n+\t\t  __to_next = reinterpret_cast<intern_type*>(__cto);\n+\t\t  __ret = partial;\n+\t\t}\n+\t      else\n+\t\t__ret = error;\n+\t    }\n+\t}\n+      return __ret; \n+    }\n+  \n+  template<typename _InternT, typename _ExternT>\n+    int \n+    codecvt<_InternT, _ExternT, __enc_traits>::\n+    do_encoding() const throw()\n+    { return 0; }\n+  \n+  template<typename _InternT, typename _ExternT>\n+    bool \n+    codecvt<_InternT, _ExternT, __enc_traits>::\n+    do_always_noconv() const throw()\n+    { return false; }\n+  \n+  template<typename _InternT, typename _ExternT>\n+    int \n+    codecvt<_InternT, _ExternT, __enc_traits>::\n+    do_length(const state_type& __state, const extern_type* __from, \n+\t      const extern_type* __end, size_t __max) const\n+    { return min(__max, static_cast<size_t>(__end - __from)); }\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+// 74.  Garbled text for codecvt::do_max_length\n+  template<typename _InternT, typename _ExternT>\n+    int \n+    codecvt<_InternT, _ExternT, __enc_traits>::\n+    do_max_length() const throw()\n+    { return 1; }\n+#endif\n+\n+  // codecvt<char, char, mbstate_t> required specialization\n+  template<>\n+    class codecvt<char, char, mbstate_t> \n+    : public __codecvt_abstract_base<char, char, mbstate_t>\n+    {\n+    public:      \n+      // Types:\n+      typedef char \tintern_type;\n+      typedef char \textern_type;\n+      typedef mbstate_t state_type;\n+\n+      // Data Members:\n+      static locale::id id;\n+\n+      explicit \n+      codecvt(size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~codecvt();\n+\n+      virtual result\n+      do_out(state_type& __state, const intern_type* __from, \n+\t     const intern_type* __from_end, const intern_type*& __from_next,\n+\t     extern_type* __to, extern_type* __to_end,\n+\t     extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_unshift(state_type& __state, extern_type* __to, \n+\t\t extern_type* __to_end, extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_in(state_type& __state, const extern_type* __from, \n+\t    const extern_type* __from_end, const extern_type*& __from_next,\n+\t    intern_type* __to, intern_type* __to_end, \n+\t    intern_type*& __to_next) const;\n+\n+      virtual int \n+      do_encoding() const throw();\n+\n+      virtual bool \n+      do_always_noconv() const throw();\n+\n+      virtual int \n+      do_length(const state_type&, const extern_type* __from, \n+\t\tconst extern_type* __end, size_t __max) const;\n+\n+      virtual int \n+      do_max_length() const throw();\n+  };\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  // codecvt<wchar_t, char, mbstate_t> required specialization\n+  template<>\n+    class codecvt<wchar_t, char, mbstate_t> \n+    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>\n+    {\n+    public:\n+      // Types:\n+      typedef wchar_t \tintern_type;\n+      typedef char \textern_type;\n+      typedef mbstate_t state_type;\n+\n+      // Data Members:\n+      static locale::id id;\n+\n+      explicit \n+      codecvt(size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~codecvt();\n+\n+      virtual result\n+      do_out(state_type& __state, const intern_type* __from, \n+\t     const intern_type* __from_end, const intern_type*& __from_next,\n+\t     extern_type* __to, extern_type* __to_end,\n+\t     extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_unshift(state_type& __state,\n+\t\t extern_type* __to, extern_type* __to_end,\n+\t\t extern_type*& __to_next) const;\n+\n+      virtual result\n+      do_in(state_type& __state,\n+\t     const extern_type* __from, const extern_type* __from_end,\n+\t     const extern_type*& __from_next,\n+\t     intern_type* __to, intern_type* __to_end,\n+\t     intern_type*& __to_next) const;\n+\n+      virtual \n+      int do_encoding() const throw();\n+\n+      virtual \n+      bool do_always_noconv() const throw();\n+\n+      virtual \n+      int do_length(const state_type&, const extern_type* __from,\n+\t\t    const extern_type* __end, size_t __max) const;\n+\n+      virtual int \n+      do_max_length() const throw();\n+    };\n+#endif //_GLIBCPP_USE_WCHAR_T\n+\n+  // 22.2.1.6  Template class codecvt_byname\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>\n+    {\n+    public:\n+      explicit \n+      codecvt_byname(const char*, size_t __refs = 0) \n+      : codecvt<_InternT,_ExternT,_StateT> (__refs) { }\n+    protected:\n+      virtual \n+      ~codecvt_byname() { }\n+    };\n+\n+  template<>\n+    class codecvt_byname<char, char, mbstate_t>\n+    : public codecvt<char, char, mbstate_t>\n+    {\n+    public:\n+      explicit \n+      codecvt_byname(const char*, size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~codecvt_byname();\n+    };\n+  \n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    class codecvt_byname<wchar_t, char, mbstate_t>\n+      : public codecvt<wchar_t, char, mbstate_t>\n+    {\n+    public:\n+      explicit \n+      codecvt_byname(const char*, size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~codecvt_byname();\n+    };\n+#endif\n+\n+} // namespace std\n+\n+#endif // _CPP_BITS_CODECVT_H\n+\n+// Local Variables:\n+// mode:c++\n+// End:\n+"}, {"sha": "4a0e2d55703b7a8a290f3858e4aee589ac18343e", "filename": "libstdc++-v3/include/bits/concept_checks.h", "status": "added", "additions": 811, "deletions": 0, "changes": 811, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcept_checks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcept_checks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcept_checks.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,811 @@\n+/*\n+ * Copyright (c) 1999\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef __CONCEPT_CHECKS_H\n+#define __CONCEPT_CHECKS_H\n+\n+/*\n+  Use these macro like assertions, but they assert properties\n+  on types (usually template arguments). In technical terms they\n+  verify whether a type \"models\" a \"concept\".\n+\n+  This set of requirements and the terminology used here is derived\n+  from the book \"Generic Programming and the STL\" by Matt Austern\n+  (Addison Wesley). For further information please consult that\n+  book. The requirements also are intended to match the ANSI/ISO C++\n+  standard.\n+\n+  This file covers the basic concepts and the iterator concepts.\n+  There are several other files that provide the requirements\n+  for the STL containers:\n+    container_concepts.h\n+    sequence_concepts.h\n+    assoc_container_concepts.h\n+\n+  Jeremy Siek, 1999\n+\n+  TO DO:\n+    - some issues with regards to concept classification and mutability\n+      including AssociativeContianer -> ForwardContainer\n+      and SortedAssociativeContainer -> ReversibleContainer\n+    - HashedAssociativeContainer\n+    - Allocator\n+    - Function Object Concepts\n+\n+  */\n+\n+#ifndef __STL_USE_CONCEPT_CHECKS\n+\n+// Some compilers lack the features that are necessary for concept checks.\n+// On those compilers we define the concept check macros to do nothing.\n+#define __STL_REQUIRES(__type_var, __concept) do {} while(0)\n+#define __STL_CLASS_REQUIRES(__type_var, __concept) \\\n+  static int  __##__type_var##_##__concept\n+#define __STL_CONVERTIBLE(__type_x, __type_y) do {} while(0)\n+#define __STL_REQUIRES_SAME_TYPE(__type_x, __type_y) do {} while(0)\n+#define __STL_CLASS_REQUIRES_SAME_TYPE(__type_x, __type_y) \\\n+  static int  __##__type_x##__type_y##_require_same_type\n+#define __STL_GENERATOR_CHECK(__func, __ret) do {} while(0)\n+#define __STL_CLASS_GENERATOR_CHECK(__func, __ret) \\\n+  static int  __##__func##__ret##_generator_check\n+#define __STL_UNARY_FUNCTION_CHECK(__func, __ret, __arg) do {} while(0)\n+#define __STL_CLASS_UNARY_FUNCTION_CHECK(__func, __ret, __arg) \\\n+  static int  __##__func##__ret##__arg##_unary_function_check\n+#define __STL_BINARY_FUNCTION_CHECK(__func, __ret, __first, __second) \\\n+  do {} while(0)\n+#define __STL_CLASS_BINARY_FUNCTION_CHECK(__func, __ret, __first, __second) \\\n+  static int  __##__func##__ret##__first##__second##_binary_function_check\n+#define __STL_REQUIRES_BINARY_OP(__opname, __ret, __first, __second) \\\n+  do {} while(0)\n+#define __STL_CLASS_REQUIRES_BINARY_OP(__opname, __ret, __first, __second) \\\n+  static int __##__opname##__ret##__first##__second##_require_binary_op\n+\n+#else /* __STL_USE_CONCEPT_CHECKS */\n+\n+// This macro tests whether the template argument \"__type_var\"\n+// satisfies the requirements of \"__concept\".  Here is a list of concepts\n+// that we know how to check:\n+//       _Allocator\n+//       _Assignable\n+//       _DefaultConstructible\n+//       _EqualityComparable\n+//       _LessThanComparable\n+//       _TrivialIterator\n+//       _InputIterator\n+//       _OutputIterator\n+//       _ForwardIterator\n+//       _BidirectionalIterator\n+//       _RandomAccessIterator\n+//       _Mutable_TrivialIterator\n+//       _Mutable_ForwardIterator\n+//       _Mutable_BidirectionalIterator\n+//       _Mutable_RandomAccessIterator\n+\n+#define __STL_REQUIRES(__type_var, __concept) \\\n+do { \\\n+  void (*__x)( __type_var ) = __concept##_concept_specification< __type_var >\\\n+    ::__concept##_requirement_violation; __x = __x; } while (0)\n+\n+// Use this to check whether type X is convertible to type Y\n+#define __STL_CONVERTIBLE(__type_x, __type_y) \\\n+do { \\\n+  void (*__x)( __type_x , __type_y ) = _STL_CONVERT_ERROR< __type_x , \\\n+  __type_y >::__type_X_is_not_convertible_to_type_Y; \\\n+  __x = __x; } while (0)\n+\n+// Use this to test whether two template arguments are the same type\n+#define __STL_REQUIRES_SAME_TYPE(__type_x, __type_y) \\\n+do { \\\n+  void (*__x)( __type_x , __type_y ) = _STL_SAME_TYPE_ERROR< __type_x, \\\n+    __type_y  >::__type_X_not_same_as_type_Y; \\\n+  __x = __x; } while (0)\n+\n+\n+// function object checks\n+#define __STL_GENERATOR_CHECK(__func, __ret) \\\n+do { \\\n+  __ret (*__x)( __func&) = \\\n+     _STL_GENERATOR_ERROR< \\\n+  __func, __ret>::__generator_requirement_violation; \\\n+  __x = __x; } while (0)\n+\n+\n+#define __STL_UNARY_FUNCTION_CHECK(__func, __ret, __arg) \\\n+do { \\\n+  __ret (*__x)( __func&, const __arg& ) = \\\n+     _STL_UNARY_FUNCTION_ERROR< \\\n+  __func, __ret, __arg>::__unary_function_requirement_violation; \\\n+  __x = __x; } while (0)\n+\n+\n+#define __STL_BINARY_FUNCTION_CHECK(__func, __ret, __first, __second) \\\n+do { \\\n+  __ret (*__x)( __func&, const __first&, const __second& ) = \\\n+     _STL_BINARY_FUNCTION_ERROR< \\\n+  __func, __ret, __first, __second>::__binary_function_requirement_violation; \\\n+  __x = __x; } while (0)\n+\n+\n+#define __STL_REQUIRES_BINARY_OP(__opname, __ret, __first, __second) \\\n+    do { \\\n+  __ret (*__x)( __first&, __second& ) = _STL_BINARY##__opname##_ERROR< \\\n+    __ret, __first, __second>::__binary_operator_requirement_violation; \\\n+  __ret (*__y)( const __first&, const __second& ) = \\\n+    _STL_BINARY##__opname##_ERROR< __ret, __first, __second>:: \\\n+      __const_binary_operator_requirement_violation; \\\n+  __y = __y; __x = __x; } while (0)\n+\n+\n+#ifdef __STL_NO_FUNCTION_PTR_IN_CLASS_TEMPLATE\n+\n+#define __STL_CLASS_REQUIRES(__type_var, __concept)\n+#define __STL_CLASS_REQUIRES_SAME_TYPE(__type_x, __type_y)\n+#define __STL_CLASS_GENERATOR_CHECK(__func, __ret)\n+#define __STL_CLASS_UNARY_FUNCTION_CHECK(__func, __ret, __arg)\n+#define __STL_CLASS_BINARY_FUNCTION_CHECK(__func, __ret, __first, __second)\n+#define __STL_CLASS_REQUIRES_BINARY_OP(__opname, __ret, __first, __second)\n+\n+#else\n+\n+// Use this macro inside of template classes, where you would\n+// like to place requirements on the template arguments to the class\n+// Warning: do not pass pointers and such (e.g. T*) in as the __type_var,\n+// since the type_var is used to construct identifiers. Instead typedef\n+// the pointer type, then use the typedef name for the __type_var.\n+#define __STL_CLASS_REQUIRES(__type_var, __concept) \\\n+  typedef void (* __func##__type_var##__concept)( __type_var ); \\\n+  template <__func##__type_var##__concept _Tp1> \\\n+  struct __dummy_struct_##__type_var##__concept { }; \\\n+  static __dummy_struct_##__type_var##__concept< \\\n+    __concept##_concept_specification< \\\n+      __type_var>::__concept##_requirement_violation>  \\\n+  __dummy_ptr_##__type_var##__concept\n+\n+\n+#define __STL_CLASS_REQUIRES_SAME_TYPE(__type_x, __type_y) \\\n+  typedef void (* __func_##__type_x##__type_y##same_type)( __type_x, \\\n+                                                            __type_y ); \\\n+  template < __func_##__type_x##__type_y##same_type _Tp1> \\\n+  struct __dummy_struct_##__type_x##__type_y##_same_type { }; \\\n+  static __dummy_struct_##__type_x##__type_y##_same_type< \\\n+    _STL_SAME_TYPE_ERROR<__type_x, __type_y>::__type_X_not_same_as_type_Y>  \\\n+  __dummy_ptr_##__type_x##__type_y##_same_type\n+\n+\n+#define __STL_CLASS_GENERATOR_CHECK(__func, __ret) \\\n+  typedef __ret (* __f_##__func##__ret##_generator)( __func& ); \\\n+  template <__f_##__func##__ret##_generator _Tp1> \\\n+  struct __dummy_struct_##__func##__ret##_generator { }; \\\n+  static __dummy_struct_##__func##__ret##_generator< \\\n+    _STL_GENERATOR_ERROR< \\\n+      __func, __ret>::__generator_requirement_violation>  \\\n+  __dummy_ptr_##__func##__ret##_generator\n+\n+\n+#define __STL_CLASS_UNARY_FUNCTION_CHECK(__func, __ret, __arg) \\\n+  typedef __ret (* __f_##__func##__ret##__arg##_unary_check)( __func&, \\\n+                                                         const __arg& ); \\\n+  template <__f_##__func##__ret##__arg##_unary_check _Tp1> \\\n+  struct __dummy_struct_##__func##__ret##__arg##_unary_check { }; \\\n+  static __dummy_struct_##__func##__ret##__arg##_unary_check< \\\n+    _STL_UNARY_FUNCTION_ERROR< \\\n+      __func, __ret, __arg>::__unary_function_requirement_violation>  \\\n+  __dummy_ptr_##__func##__ret##__arg##_unary_check\n+\n+\n+#define __STL_CLASS_BINARY_FUNCTION_CHECK(__func, __ret, __first, __second) \\\n+  typedef __ret (* __f_##__func##__ret##__first##__second##_binary_check)( __func&, const __first&,\\\n+                                                    const __second& ); \\\n+  template <__f_##__func##__ret##__first##__second##_binary_check _Tp1> \\\n+  struct __dummy_struct_##__func##__ret##__first##__second##_binary_check { }; \\\n+  static __dummy_struct_##__func##__ret##__first##__second##_binary_check< \\\n+    _STL_BINARY_FUNCTION_ERROR<__func, __ret, __first, __second>:: \\\n+  __binary_function_requirement_violation>  \\\n+  __dummy_ptr_##__func##__ret##__first##__second##_binary_check\n+\n+\n+#define __STL_CLASS_REQUIRES_BINARY_OP(__opname, __ret, __first, __second) \\\n+  typedef __ret (* __f_##__func##__ret##__first##__second##_binary_op)(const __first&, \\\n+                                                    const __second& ); \\\n+  template <__f_##__func##__ret##__first##__second##_binary_op _Tp1> \\\n+  struct __dummy_struct_##__func##__ret##__first##__second##_binary_op { }; \\\n+  static __dummy_struct_##__func##__ret##__first##__second##_binary_op< \\\n+    _STL_BINARY##__opname##_ERROR<__ret, __first, __second>:: \\\n+  __binary_operator_requirement_violation>  \\\n+  __dummy_ptr_##__func##__ret##__first##__second##_binary_op\n+\n+#endif\n+\n+/* helper class for finding non-const version of a type. Need to have\n+   something to assign to etc. when testing constant iterators. */\n+\n+template <class _Tp>\n+struct _Mutable_trait {\n+  typedef _Tp _Type;\n+};\n+template <class _Tp>\n+struct _Mutable_trait<const _Tp> {\n+  typedef _Tp _Type;\n+};\n+\n+\n+/* helper function for avoiding compiler warnings about unused variables */\n+template <class _Type>\n+void __sink_unused_warning(_Type) { }\n+\n+template <class _TypeX, class _TypeY>\n+struct _STL_CONVERT_ERROR {\n+  static void\n+  __type_X_is_not_convertible_to_type_Y(_TypeX __x, _TypeY) {\n+    _TypeY __y = __x;\n+    __sink_unused_warning(__y);\n+  }\n+};\n+\n+\n+template <class _Type> struct __check_equal { };\n+\n+template <class _TypeX, class _TypeY>\n+struct _STL_SAME_TYPE_ERROR {\n+  static void\n+  __type_X_not_same_as_type_Y(_TypeX , _TypeY ) { \n+    __check_equal<_TypeX> t1 = __check_equal<_TypeY>();\n+  }\n+};\n+\n+\n+// Some Functon Object Checks\n+\n+template <class _Func, class _Ret>\n+struct _STL_GENERATOR_ERROR {\n+  static _Ret __generator_requirement_violation(_Func& __f) {\n+    return __f();\n+  }\n+};\n+\n+template <class _Func>\n+struct _STL_GENERATOR_ERROR<_Func, void> {\n+  static void __generator_requirement_violation(_Func& __f) {\n+    __f();\n+  }\n+};\n+\n+\n+template <class _Func, class _Ret, class _Arg>\n+struct _STL_UNARY_FUNCTION_ERROR {\n+  static _Ret\n+  __unary_function_requirement_violation(_Func& __f,\n+                                          const _Arg& __arg) {\n+    return __f(__arg);\n+  }\n+};\n+\n+template <class _Func, class _Arg>\n+struct _STL_UNARY_FUNCTION_ERROR<_Func, void, _Arg> {\n+  static void\n+  __unary_function_requirement_violation(_Func& __f,\n+                                          const _Arg& __arg) {\n+    __f(__arg);\n+  }\n+};\n+\n+template <class _Func, class _Ret, class _First, class _Second>\n+struct _STL_BINARY_FUNCTION_ERROR {\n+  static _Ret\n+  __binary_function_requirement_violation(_Func& __f,\n+                                          const _First& __first, \n+                                          const _Second& __second) {\n+    return __f(__first, __second);\n+  }\n+};\n+\n+template <class _Func, class _First, class _Second>\n+struct _STL_BINARY_FUNCTION_ERROR<_Func, void, _First, _Second> {\n+  static void\n+  __binary_function_requirement_violation(_Func& __f,\n+                                          const _First& __first, \n+                                          const _Second& __second) {\n+    __f(__first, __second);\n+  }\n+};\n+\n+\n+#define __STL_DEFINE_BINARY_OP_CHECK(_OP, _NAME) \\\n+template <class _Ret, class _First, class _Second> \\\n+struct _STL_BINARY##_NAME##_ERROR { \\\n+  static _Ret \\\n+  __const_binary_operator_requirement_violation(const _First& __first,  \\\n+                                                const _Second& __second) { \\\n+    return __first _OP __second; \\\n+  } \\\n+  static _Ret \\\n+  __binary_operator_requirement_violation(_First& __first,  \\\n+                                          _Second& __second) { \\\n+    return __first _OP __second; \\\n+  } \\\n+}\n+\n+__STL_DEFINE_BINARY_OP_CHECK(==, _OP_EQUAL);\n+__STL_DEFINE_BINARY_OP_CHECK(!=, _OP_NOT_EQUAL);\n+__STL_DEFINE_BINARY_OP_CHECK(<, _OP_LESS_THAN);\n+__STL_DEFINE_BINARY_OP_CHECK(<=, _OP_LESS_EQUAL);\n+__STL_DEFINE_BINARY_OP_CHECK(>, _OP_GREATER_THAN);\n+__STL_DEFINE_BINARY_OP_CHECK(>=, _OP_GREATER_EQUAL);\n+__STL_DEFINE_BINARY_OP_CHECK(+, _OP_PLUS);\n+__STL_DEFINE_BINARY_OP_CHECK(*, _OP_TIMES);\n+__STL_DEFINE_BINARY_OP_CHECK(/, _OP_DIVIDE);\n+__STL_DEFINE_BINARY_OP_CHECK(-, _OP_SUBTRACT);\n+__STL_DEFINE_BINARY_OP_CHECK(%, _OP_MOD);\n+// ...\n+\n+// TODO, add unary operators (prefix and postfix)\n+\n+/*\n+  The presence of this class is just to trick EDG into displaying\n+  these error messages before any other errors. Without the\n+  classes, the errors in the functions get reported after\n+  other class errors deep inside the library. The name\n+  choice just makes for an eye catching error message :)\n+ */\n+struct _STL_ERROR {\n+\n+  template <class _Type>\n+  static _Type\n+  __default_constructor_requirement_violation(_Type) {\n+    return _Type();\n+  }\n+  template <class _Type>\n+  static _Type\n+  __assignment_operator_requirement_violation(_Type __a) {\n+    __a = __a;\n+    return __a;\n+  }\n+  template <class _Type>\n+  static _Type\n+  __copy_constructor_requirement_violation(_Type __a) {\n+    _Type __c(__a);\n+    return __c;\n+  }\n+  template <class _Type>\n+  static _Type\n+  __const_parameter_required_for_copy_constructor(_Type /* __a */, \n+                                                  const _Type& __b) {\n+    _Type __c(__b);\n+    return __c;\n+  }\n+  template <class _Type>\n+  static _Type\n+  __const_parameter_required_for_assignment_operator(_Type __a, \n+                                                     const _Type& __b) {\n+    __a = __b;\n+    return __a;\n+  }\n+  template <class _Type>\n+  static _Type\n+  __less_than_comparable_requirement_violation(_Type __a, _Type __b) {\n+    if (__a < __b) return __a;\n+    return __b;\n+  }\n+  template <class _Type>\n+  static _Type\n+  __equality_comparable_requirement_violation(_Type __a, _Type __b) {\n+    if (__a == __b || __a != __b) return __a;\n+    return __b;\n+  }\n+  template <class _Iterator>\n+  static void\n+  __dereference_operator_requirement_violation(_Iterator __i) {\n+    __sink_unused_warning(*__i);\n+  }\n+  template <class _Iterator>\n+  static void\n+  __dereference_operator_and_assignment_requirement_violation(_Iterator __i) {\n+    *__i = *__i;\n+  }\n+  template <class _Iterator>\n+  static void\n+  __preincrement_operator_requirement_violation(_Iterator __i) {\n+    ++__i;\n+  }\n+  template <class _Iterator>\n+  static void\n+  __postincrement_operator_requirement_violation(_Iterator __i) {\n+    __i++;\n+  }\n+  template <class _Iterator>\n+  static void\n+  __predecrement_operator_requirement_violation(_Iterator __i) {\n+    --__i;\n+  }\n+  template <class _Iterator>\n+  static void\n+  __postdecrement_operator_requirement_violation(_Iterator __i) {\n+    __i--;\n+  }\n+  template <class _Iterator, class _Type>\n+  static void\n+  __postincrement_operator_and_assignment_requirement_violation(_Iterator __i,\n+                                                                _Type __t) {\n+    *__i++ = __t;\n+  }\n+  template <class _Iterator, class _Distance>\n+  static _Iterator\n+  __iterator_addition_assignment_requirement_violation(_Iterator __i, \n+                                                       _Distance __n) {\n+    __i += __n;\n+    return __i;\n+  }\n+  template <class _Iterator, class _Distance>\n+  static _Iterator\n+  __iterator_addition_requirement_violation(_Iterator __i, _Distance __n) {\n+    __i = __i + __n;\n+    __i = __n + __i;\n+    return __i;\n+  }\n+  template <class _Iterator, class _Distance>\n+  static _Iterator\n+  __iterator_subtraction_assignment_requirement_violation(_Iterator __i,\n+                                                          _Distance __n) {\n+    __i -= __n;\n+    return __i;\n+  }\n+  template <class _Iterator, class _Distance>\n+  static _Iterator\n+  __iterator_subtraction_requirement_violation(_Iterator __i, _Distance __n) {\n+    __i = __i - __n;\n+    return __i;\n+  }\n+  template <class _Iterator, class _Distance>\n+  static _Distance\n+  __difference_operator_requirement_violation(_Iterator __i, _Iterator __j,\n+                                              _Distance __n) {\n+    __n = __i - __j;\n+    return __n;\n+  }\n+  template <class _Exp, class _Type, class _Distance>\n+  static _Type\n+  __element_access_operator_requirement_violation(_Exp __x, _Type*,\n+                                                  _Distance __n) {\n+    return __x[__n];\n+  }\n+  template <class _Exp, class _Type, class _Distance>\n+  static void\n+  __element_assignment_operator_requirement_violation(_Exp __x,\n+                                                      _Type* __t,\n+                                                      _Distance __n) {\n+    __x[__n] = *__t;\n+  }\n+\n+}; /* _STL_ERROR */\n+\n+/* Associated Type Requirements */\n+\n+__STL_BEGIN_NAMESPACE\n+template <class _Iterator> struct iterator_traits;\n+__STL_END_NAMESPACE\n+\n+template <class _Iter> \n+struct __value_type_type_definition_requirement_violation {\n+  typedef typename __STD::iterator_traits<_Iter>::value_type value_type;\n+};\n+\n+template <class _Iter> \n+struct __difference_type_type_definition_requirement_violation {\n+  typedef typename __STD::iterator_traits<_Iter>::difference_type\n+          difference_type;\n+};\n+\n+template <class _Iter> \n+struct __reference_type_definition_requirement_violation {\n+  typedef typename __STD::iterator_traits<_Iter>::reference reference;\n+};\n+\n+template <class _Iter> \n+struct __pointer_type_definition_requirement_violation {\n+  typedef typename __STD::iterator_traits<_Iter>::pointer pointer;\n+};\n+\n+template <class _Iter> \n+struct __iterator_category_type_definition_requirement_violation {\n+  typedef typename __STD::iterator_traits<_Iter>::iterator_category \n+          iterator_category;\n+};\n+\n+/* Assignable Requirements */\n+\n+\n+template <class _Type>\n+struct _Assignable_concept_specification {\n+  static void _Assignable_requirement_violation(_Type __a) {\n+    _STL_ERROR::__assignment_operator_requirement_violation(__a);\n+    _STL_ERROR::__copy_constructor_requirement_violation(__a);\n+    _STL_ERROR::__const_parameter_required_for_copy_constructor(__a,__a);\n+    _STL_ERROR::__const_parameter_required_for_assignment_operator(__a,__a);\n+  }\n+};\n+\n+/* DefaultConstructible Requirements */\n+\n+\n+template <class _Type>\n+struct _DefaultConstructible_concept_specification {\n+  static void _DefaultConstructible_requirement_violation(_Type __a) {\n+    _STL_ERROR::__default_constructor_requirement_violation(__a);\n+  }\n+};\n+\n+/* EqualityComparable Requirements */\n+\n+template <class _Type>\n+struct _EqualityComparable_concept_specification {\n+  static void _EqualityComparable_requirement_violation(_Type __a) {\n+    _STL_ERROR::__equality_comparable_requirement_violation(__a, __a);\n+  }\n+};\n+\n+/* LessThanComparable Requirements */\n+template <class _Type>\n+struct _LessThanComparable_concept_specification {\n+  static void _LessThanComparable_requirement_violation(_Type __a) {\n+    _STL_ERROR::__less_than_comparable_requirement_violation(__a, __a);\n+  }\n+};\n+\n+/* TrivialIterator Requirements */\n+\n+template <class _TrivialIterator>\n+struct _TrivialIterator_concept_specification {\n+static void\n+_TrivialIterator_requirement_violation(_TrivialIterator __i) {\n+  typedef typename\n+    __value_type_type_definition_requirement_violation<_TrivialIterator>::\n+    value_type __T;\n+  // Refinement of Assignable\n+  _Assignable_concept_specification<_TrivialIterator>::\n+    _Assignable_requirement_violation(__i);\n+  // Refinement of DefaultConstructible\n+  _DefaultConstructible_concept_specification<_TrivialIterator>::\n+    _DefaultConstructible_requirement_violation(__i);\n+  // Refinement of EqualityComparable\n+  _EqualityComparable_concept_specification<_TrivialIterator>::\n+    _EqualityComparable_requirement_violation(__i);\n+  // Valid Expressions\n+  _STL_ERROR::__dereference_operator_requirement_violation(__i);\n+}\n+};\n+\n+template <class _TrivialIterator>\n+struct _Mutable_TrivialIterator_concept_specification {\n+static void\n+_Mutable_TrivialIterator_requirement_violation(_TrivialIterator __i) {\n+  _TrivialIterator_concept_specification<_TrivialIterator>::\n+    _TrivialIterator_requirement_violation(__i);\n+  // Valid Expressions\n+  _STL_ERROR::__dereference_operator_and_assignment_requirement_violation(__i);\n+}\n+};\n+\n+/* InputIterator Requirements */\n+\n+template <class _InputIterator>\n+struct _InputIterator_concept_specification {\n+static void\n+_InputIterator_requirement_violation(_InputIterator __i) {\n+  // Refinement of TrivialIterator\n+  _TrivialIterator_concept_specification<_InputIterator>::\n+    _TrivialIterator_requirement_violation(__i);\n+  // Associated Types\n+  __difference_type_type_definition_requirement_violation<_InputIterator>();\n+  __reference_type_definition_requirement_violation<_InputIterator>();\n+  __pointer_type_definition_requirement_violation<_InputIterator>();\n+  __iterator_category_type_definition_requirement_violation<_InputIterator>();\n+  // Valid Expressions\n+  _STL_ERROR::__preincrement_operator_requirement_violation(__i);\n+  _STL_ERROR::__postincrement_operator_requirement_violation(__i);\n+}\n+};\n+\n+/* OutputIterator Requirements */\n+\n+template <class _OutputIterator>\n+struct _OutputIterator_concept_specification {\n+static void\n+_OutputIterator_requirement_violation(_OutputIterator __i) {\n+  // Refinement of Assignable\n+  _Assignable_concept_specification<_OutputIterator>::\n+    _Assignable_requirement_violation(__i);\n+  // Associated Types\n+  __iterator_category_type_definition_requirement_violation<_OutputIterator>();\n+  // Valid Expressions\n+  _STL_ERROR::__dereference_operator_requirement_violation(__i);\n+  _STL_ERROR::__preincrement_operator_requirement_violation(__i);\n+  _STL_ERROR::__postincrement_operator_requirement_violation(__i);\n+  _STL_ERROR::\n+    __postincrement_operator_and_assignment_requirement_violation(__i, *__i);\n+}\n+};\n+\n+/* ForwardIterator Requirements */\n+\n+template <class _ForwardIterator>\n+struct _ForwardIterator_concept_specification {\n+static void\n+_ForwardIterator_requirement_violation(_ForwardIterator __i) {\n+  // Refinement of InputIterator\n+  _InputIterator_concept_specification<_ForwardIterator>::\n+    _InputIterator_requirement_violation(__i);\n+}\n+};\n+\n+template <class _ForwardIterator>\n+struct _Mutable_ForwardIterator_concept_specification {\n+static void\n+_Mutable_ForwardIterator_requirement_violation(_ForwardIterator __i) {\n+  _ForwardIterator_concept_specification<_ForwardIterator>::\n+    _ForwardIterator_requirement_violation(__i);\n+  // Refinement of OutputIterator\n+  _OutputIterator_concept_specification<_ForwardIterator>::\n+    _OutputIterator_requirement_violation(__i);\n+}\n+};\n+\n+/* BidirectionalIterator Requirements */\n+\n+template <class _BidirectionalIterator>\n+struct _BidirectionalIterator_concept_specification {\n+static void\n+_BidirectionalIterator_requirement_violation(_BidirectionalIterator __i) {\n+  // Refinement of ForwardIterator\n+  _ForwardIterator_concept_specification<_BidirectionalIterator>::\n+    _ForwardIterator_requirement_violation(__i);\n+  // Valid Expressions\n+  _STL_ERROR::__predecrement_operator_requirement_violation(__i);\n+  _STL_ERROR::__postdecrement_operator_requirement_violation(__i);\n+}\n+};\n+\n+template <class _BidirectionalIterator>\n+struct _Mutable_BidirectionalIterator_concept_specification {\n+static void\n+_Mutable_BidirectionalIterator_requirement_violation(\n+       _BidirectionalIterator __i)\n+{\n+  _BidirectionalIterator_concept_specification<_BidirectionalIterator>::\n+    _BidirectionalIterator_requirement_violation(__i);\n+  // Refinement of mutable_ForwardIterator\n+  _Mutable_ForwardIterator_concept_specification<_BidirectionalIterator>::\n+    _Mutable_ForwardIterator_requirement_violation(__i);\n+  typedef typename\n+    __value_type_type_definition_requirement_violation<\n+    _BidirectionalIterator>::value_type __T;\n+  typename _Mutable_trait<__T>::_Type* __tmp_ptr = 0;\n+  // Valid Expressions\n+  _STL_ERROR::\n+    __postincrement_operator_and_assignment_requirement_violation(__i,\n+                                                                  *__tmp_ptr);\n+}\n+};\n+\n+/* RandomAccessIterator Requirements */\n+\n+template <class _RandAccIter>\n+struct _RandomAccessIterator_concept_specification {\n+static void\n+_RandomAccessIterator_requirement_violation(_RandAccIter __i) {\n+  // Refinement of BidirectionalIterator\n+  _BidirectionalIterator_concept_specification<_RandAccIter>::\n+    _BidirectionalIterator_requirement_violation(__i);\n+  // Refinement of LessThanComparable\n+  _LessThanComparable_concept_specification<_RandAccIter>::\n+    _LessThanComparable_requirement_violation(__i);\n+  typedef typename \n+        __value_type_type_definition_requirement_violation<_RandAccIter>\n+        ::value_type\n+    value_type;\n+  typedef typename\n+        __difference_type_type_definition_requirement_violation<_RandAccIter>\n+        ::difference_type \n+    _Dist;\n+  typedef typename _Mutable_trait<_Dist>::_Type _MutDist;\n+\n+  // Valid Expressions\n+  _STL_ERROR::__iterator_addition_assignment_requirement_violation(__i,\n+                                                                   _MutDist());\n+  _STL_ERROR::__iterator_addition_requirement_violation(__i,\n+                                                        _MutDist());\n+  _STL_ERROR::\n+    __iterator_subtraction_assignment_requirement_violation(__i,\n+                                                            _MutDist());\n+  _STL_ERROR::__iterator_subtraction_requirement_violation(__i,\n+                                                           _MutDist());\n+  _STL_ERROR::__difference_operator_requirement_violation(__i, __i,\n+                                                          _MutDist());\n+  typename _Mutable_trait<value_type>::_Type* __dummy_ptr = 0;\n+  _STL_ERROR::__element_access_operator_requirement_violation(__i,\n+                                                              __dummy_ptr,\n+                                                              _MutDist());\n+}\n+};\n+\n+template <class _RandAccIter>\n+struct _Mutable_RandomAccessIterator_concept_specification {\n+static void\n+_Mutable_RandomAccessIterator_requirement_violation(_RandAccIter __i)\n+{\n+  _RandomAccessIterator_concept_specification<_RandAccIter>::\n+    _RandomAccessIterator_requirement_violation(__i);\n+  // Refinement of mutable_BidirectionalIterator\n+  _Mutable_BidirectionalIterator_concept_specification<_RandAccIter>::\n+    _Mutable_BidirectionalIterator_requirement_violation(__i);\n+  typedef typename\n+        __value_type_type_definition_requirement_violation<_RandAccIter>\n+        ::value_type\n+    value_type;\n+  typedef typename\n+        __difference_type_type_definition_requirement_violation<_RandAccIter>\n+        ::difference_type\n+    _Dist;\n+\n+  typename _Mutable_trait<value_type>::_Type* __tmp_ptr = 0;\n+  // Valid Expressions\n+  _STL_ERROR::__element_assignment_operator_requirement_violation(__i,\n+                  __tmp_ptr, _Dist());\n+}\n+};\n+\n+#define __STL_TYPEDEF_REQUIREMENT(__REQUIREMENT) \\\n+template <class Type> \\\n+struct __##__REQUIREMENT##__typedef_requirement_violation { \\\n+  typedef typename Type::__REQUIREMENT __REQUIREMENT; \\\n+}\n+\n+__STL_TYPEDEF_REQUIREMENT(value_type);\n+__STL_TYPEDEF_REQUIREMENT(difference_type);\n+__STL_TYPEDEF_REQUIREMENT(size_type);\n+__STL_TYPEDEF_REQUIREMENT(reference);\n+__STL_TYPEDEF_REQUIREMENT(const_reference);\n+__STL_TYPEDEF_REQUIREMENT(pointer);\n+__STL_TYPEDEF_REQUIREMENT(const_pointer);\n+\n+\n+template <class _Alloc>\n+struct _Allocator_concept_specification {\n+static void\n+_Allocator_requirement_violation(_Alloc __a) {\n+  // Refinement of DefaultConstructible\n+  _DefaultConstructible_concept_specification<_Alloc>::\n+    _DefaultConstructible_requirement_violation(__a);\n+  // Refinement of EqualityComparable\n+  _EqualityComparable_concept_specification<_Alloc>::\n+    _EqualityComparable_requirement_violation(__a);\n+  // Associated Types\n+  __value_type__typedef_requirement_violation<_Alloc>();\n+  __difference_type__typedef_requirement_violation<_Alloc>();\n+  __size_type__typedef_requirement_violation<_Alloc>();\n+  __reference__typedef_requirement_violation<_Alloc>();\n+  __const_reference__typedef_requirement_violation<_Alloc>();\n+  __pointer__typedef_requirement_violation<_Alloc>();\n+  __const_pointer__typedef_requirement_violation<_Alloc>();\n+  typedef typename _Alloc::value_type _Tp;\n+  //__STL_REQUIRES_SAME_TYPE(typename _Alloc::__STL_TEMPLATE rebind<_Tp>::other,\n+  //                         _Alloc);\n+}\n+};\n+\n+#endif /* __STL_USE_CONCEPT_CHECKS */\n+\n+#endif /* __CONCEPT_CHECKS_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "99aec1c4b62b5b580a0e6027d4ed3a81fb280dba", "filename": "libstdc++-v3/include/bits/container_concepts.h", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcontainer_concepts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcontainer_concepts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcontainer_concepts.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright (c) 1999\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef __STL_CONTAINER_CONCEPTS_H\n+#define __STL_CONTAINER_CONCEPTS_H\n+\n+\n+#include <bits/concept_checks.h>\n+\n+#ifdef __STL_USE_CONCEPT_CHECKS\n+\n+\n+// This file covers the following concepts:\n+//       _Container\n+//       _ForwardContainer\n+//       _ReversibleContainer\n+//       _const_ReversibleContainer\n+//       _RandomAccessContainer\n+//\n+\n+struct _ERROR_IN_STL_CONTAINER {\n+\n+  /* Container expresssions */\n+\n+  template <class _Container>\n+  static void\n+  __begin_iterator_accessor_requirement_violation(_Container __c) {\n+    __c.begin();\n+  }\n+  template <class _Container>\n+  static void\n+  __const_begin_iterator_accessor_requirement_violation(const _Container& __c) {\n+    __c.begin();\n+  }\n+  template <class _Container>\n+  static void\n+  __end_iterator_accessor_requirement_violation(_Container __c) {\n+    __c.end();\n+  }\n+  template <class _Container>\n+  static void\n+  __const_end_iterator_accessor_requirement_violation(const _Container& __c) {\n+    __c.end();\n+  }\n+\n+  template <class _Container>\n+  static void\n+  __rbegin_iterator_accessor_requirement_violation(_Container __c) {\n+    __c.rbegin();\n+  }\n+  template <class _Container>\n+  static void\n+  __const_rbegin_iterator_accessor_requirement_violation(const _Container& __c) {\n+    __c.rbegin();\n+  }\n+  template <class _Container>\n+  static void\n+  __rend_iterator_accessor_requirement_violation(_Container __c) {\n+    __c.rend();\n+  }\n+  template <class _Container>\n+  static void\n+  __const_rend_iterator_accessor_requirement_violation(const _Container& __c) {\n+    __c.rend();\n+  }\n+  template <class _Container>\n+  static void\n+  __size_function_must_be_const(const _Container& __c) {\n+    __c.size();\n+  }\n+  template <class _Container>\n+  static void\n+  __size_function_requirement_violation(_Container& __c) {\n+    __c.size();\n+    __size_function_must_be_const(__c);\n+  }\n+  template <class _Container>\n+  static void\n+  __max_size_function_must_be_const(const _Container& __c) {\n+    __c.max_size();\n+  }\n+  template <class _Container>\n+  static void\n+  __max_size_function_requirement_violation(_Container& __c) {\n+    __c.max_size();\n+    __max_size_function_must_be_const(__c);\n+  }\n+  template <class _Container>\n+  static void\n+  __empty_function_must_be_const(const _Container& __c) {\n+    __c.empty();\n+  }\n+  template <class _Container>\n+  static void\n+  __empty_function_requirement_violation(_Container& __c) {\n+    __c.empty();\n+    __empty_function_must_be_const(__c);\n+  }\n+  template <class _Container>\n+  static void\n+  __swap_function_requirement_violation(_Container& __c) {\n+    __c.swap(__c);\n+  }\n+\n+};\n+\n+\n+__STL_TYPEDEF_REQUIREMENT(iterator);\n+__STL_TYPEDEF_REQUIREMENT(const_iterator);\n+\n+/* Containers */\n+\n+template <class _Container>\n+struct _Container_concept_specification {\n+static void\n+_Container_requirement_violation(_Container __c) {\n+  // Refinement of Assignable\n+  _Assignable_concept_specification<_Container>::_Assignable_requirement_violation(__c);\n+  // Associated Types\n+  __value_type__typedef_requirement_violation<_Container>();\n+  __difference_type__typedef_requirement_violation<_Container>();\n+  __size_type__typedef_requirement_violation<_Container>();\n+  __reference__typedef_requirement_violation<_Container>();\n+  __const_reference__typedef_requirement_violation<_Container>();\n+  __pointer__typedef_requirement_violation<_Container>();\n+  __const_pointer__typedef_requirement_violation<_Container>();\n+  __iterator__typedef_requirement_violation<_Container>();\n+  __const_iterator__typedef_requirement_violation<_Container>();\n+  // Valid Expressions\n+  _ERROR_IN_STL_CONTAINER::__const_begin_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__const_end_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__begin_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__end_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__size_function_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__max_size_function_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__empty_function_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__swap_function_requirement_violation(__c);\n+  // Requirements on Iterators\n+  typedef typename _Container::iterator iter;\n+  typedef typename _Container::const_iterator const_iter;\n+  _InputIterator_concept_specification<const_iter>::_InputIterator_requirement_violation(const_iter());\n+  _InputIterator_concept_specification<iter>::_InputIterator_requirement_violation(iter());\n+}\n+};\n+\n+template <class _ForwardContainer>\n+struct _ForwardContainer_concept_specification {\n+static void\n+_ForwardContainer_requirement_violation(_ForwardContainer __c) {\n+  // Refinement of Container\n+  _Container_concept_specification<_ForwardContainer>::_Container_requirement_violation(__c);\n+  // Requirements on Iterators\n+  typedef typename _ForwardContainer::iterator iter;\n+  typedef typename _ForwardContainer::const_iterator const_iter;\n+  _ForwardIterator_concept_specification<const_iter>::_ForwardIterator_requirement_violation(const_iter());\n+  _Mutable_ForwardIterator_concept_specification<iter>::_Mutable_ForwardIterator_requirement_violation(iter());\n+}\n+};\n+\n+\n+__STL_TYPEDEF_REQUIREMENT(reverse_iterator);\n+__STL_TYPEDEF_REQUIREMENT(const_reverse_iterator);\n+\n+template <class _ReversibleContainer>\n+struct _ReversibleContainer_concept_specification {\n+static void\n+_ReversibleContainer_requirement_violation(_ReversibleContainer __c) {\n+  // Refinement of ForwardContainer\n+  _ForwardContainer_concept_specification<_ReversibleContainer>::_ForwardContainer_requirement_violation(__c);\n+  // Associated types\n+  __reverse_iterator__typedef_requirement_violation<_ReversibleContainer>();\n+  __const_reverse_iterator__typedef_requirement_violation<_ReversibleContainer>();\n+  // Valid Expressions\n+  _ERROR_IN_STL_CONTAINER::__const_rbegin_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__const_rend_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__rbegin_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__rend_iterator_accessor_requirement_violation(__c);\n+  // Requirements on Iterators\n+  typedef typename _ReversibleContainer::iterator iter;\n+  typedef typename _ReversibleContainer::const_iterator const_iter;\n+  _BidirectionalIterator_concept_specification<const_iter>::_BidirectionalIterator_requirement_violation(const_iter());\n+  _Mutable_BidirectionalIterator_concept_specification<iter>::_Mutable_BidirectionalIterator_requirement_violation(iter());\n+}\n+};\n+\n+template <class _ReversibleContainer>\n+struct _const_ReversibleContainer_concept_specification {\n+static void\n+_const_ReversibleContainer_requirement_violation(_ReversibleContainer __c) {\n+  // Refinement of Container (JGS, not ForwardContainer)\n+  _Container_concept_specification<_ReversibleContainer>::_Container_requirement_violation(__c);\n+  // Associated types\n+  __reverse_iterator__typedef_requirement_violation<_ReversibleContainer>();\n+  __const_reverse_iterator__typedef_requirement_violation<_ReversibleContainer>();\n+  // Valid Expressions\n+  _ERROR_IN_STL_CONTAINER::__const_rbegin_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__const_rend_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__rbegin_iterator_accessor_requirement_violation(__c);\n+  _ERROR_IN_STL_CONTAINER::__rend_iterator_accessor_requirement_violation(__c);\n+  // Requirements on Iterators\n+  typedef typename _ReversibleContainer::iterator iter;\n+  typedef typename _ReversibleContainer::const_iterator const_iter;\n+  \n+  _BidirectionalIterator_concept_specification<const_iter>::_BidirectionalIterator_requirement_violation(const_iter());\n+}\n+};\n+\n+\n+template <class _RandomAccessContainer>\n+struct _RandomAccessContainer_concept_specification {\n+static void\n+_RandomAccessContainer_requirement_violation(_RandomAccessContainer __c) {\n+  // Refinement of ReversibleContainer\n+  _ReversibleContainer_concept_specification<_RandomAccessContainer>::_ReversibleContainer_requirement_violation(__c);\n+  // Valid Expressions\n+  typedef typename _RandomAccessContainer::value_type __T;\n+  typedef typename _RandomAccessContainer::difference_type _Dist;\n+  typedef typename _Mutable_trait<__T>::_Type Type;\n+  typedef Type* _TypePtr;\n+  typedef typename _Mutable_trait<_Dist>::_Type Dist;\n+  _STL_ERROR::__element_access_operator_requirement_violation(__c,\n+\t\t\t\t\t\t\t      _TypePtr(), \n+\t\t\t\t\t\t\t      Dist());\n+  // Requirements on Iterators\n+  typedef typename _RandomAccessContainer::iterator iter;\n+  typedef typename _RandomAccessContainer::const_iterator const_iter;\n+  _RandomAccessIterator_concept_specification<const_iter>::_RandomAccessIterator_requirement_violation(const_iter());\n+  _Mutable_RandomAccessIterator_concept_specification<iter>::_Mutable_RandomAccessIterator_requirement_violation(iter());\n+}\n+};\n+\n+#endif /* if __STL_USE_CONCEPT_CHECKS */\n+\n+#endif /* __STL_CONTAINER_CONCEPTS_H */"}, {"sha": "2b62ee8926e29a77fee3d3575d697b4311e47322", "filename": "libstdc++-v3/include/bits/cpp_type_traits.h", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,301 @@\n+// The  -*- C++ -*- type traits classes for internal use in libstdc++\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>\n+\n+#ifndef _CPP_BITS_CPP_TYPE_TRAITS_H\n+#define _CPP_BITS_CPP_TYPE_TRAITS_H 1\n+\n+//\n+// This file provides some compile-time information about various types.\n+// These informations were designed, on purpose, to be constant-expressions\n+// and not types as found in <stl/bits/type_traits.h>.  In particular, they\n+// can be used in control structures and the optimizer hopefully will do\n+// the obvious thing.\n+//\n+// Why integral expressions, and not functions nor types?\n+// Firstly, these compile-time information entities are used as\n+// template-arguments so function return values won't work.  We\n+// need compile-time entities.  We're left with types and constant\n+// integral expressions.\n+// Secondly, from the point of view of ease of use type-based compile-time\n+// information is -not- *that* convenient.  On has to write lots of\n+// overloaded functions and to hope that the compiler will select the right\n+// one. As a net effect, the overall structure isn't very clear at first\n+// glance.\n+// Thirdly, partial ordering and overload resolution (of template functions)\n+// is very costly in terms of compiler-resource.  It is a Good Thing to\n+// keep these resource consumption as least as possible.\n+//\n+// -- Gaby (dosreis@cmla.ens-cachan.fr) 2000-03-06.\n+//\n+\n+namespace std {\n+\n+  template<typename _Tp>\n+  struct __is_void\n+  {\n+    enum\n+    {\n+      _M_type = 0\n+    };\n+  };\n+\n+  template<>\n+  struct __is_void<void>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  //\n+  // Integer types\n+  //\n+  template<typename _Tp>\n+    struct __is_integer\n+    {\n+      enum\n+      {\n+\t_M_type = 0\n+      };\n+    };\n+\n+  // Thirteen specializations (yes there are eleven standard integer\n+  // types; 'long long' and 'unsigned long long' are supported as\n+  // extensions)\n+  template<>\n+    struct __is_integer<bool>\n+    {\n+      enum\n+      {\n+\t_M_type = 1\n+      };\n+    };\n+  \n+  template<>\n+    struct __is_integer<char>\n+    {\n+      enum\n+      {\n+\t_M_type = 1\n+      };\n+    };\n+\n+  template<>\n+    struct __is_integer<signed char>\n+    {\n+      enum\n+      {\n+\t_M_type = 1\n+      };\n+    };\n+  \n+  template<>\n+  struct __is_integer<unsigned char>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+# ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+  struct __is_integer<wchar_t>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+# endif\n+  \n+  template<>\n+  struct __is_integer<short>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_integer<unsigned short>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_integer<int>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_integer<unsigned int>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_integer<long>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_integer<unsigned long>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+# ifdef _GLIBCPP_USE_LONG_LONG\n+  template<>\n+  struct __is_integer<long long>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_integer<unsigned long long>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+# endif\n+\n+  //\n+  // Floating point types\n+  //\n+  template<typename _Tp>\n+  struct __is_floating\n+  {\n+    enum\n+    {\n+      _M_type = 0\n+    };\n+  };\n+\n+  // three specializations (float, double and 'long double')\n+  template<>\n+  struct __is_floating<float>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_floating<double>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  template<>\n+  struct __is_floating<long double>\n+  {\n+    enum\n+    {\n+      _M_type = 1\n+    };\n+  };\n+\n+  //\n+  // An arithmetic type is an integer type or a floating point type\n+  //\n+  template<typename _Tp>\n+  struct __is_arithmetic\n+  {\n+    enum\n+    {\n+      _M_type = __is_integer<_Tp>::_M_type || __is_floating<_Tp>::_M_type\n+    };\n+  };\n+\n+  //\n+  // A fundamental type is `void' or and arithmetic type\n+  //\n+  template<typename _Tp>\n+  struct __is_fundamental\n+  {\n+    enum\n+    {\n+      _M_type = __is_void<_Tp>::_M_type || __is_arithmetic<_Tp>::_M_type\n+    };\n+  };\n+\n+  //\n+  // For the immediate use, the following is a good approximation\n+  //\n+  template<typename _Tp>\n+  struct __is_pod\n+  {\n+    enum\n+    {\n+      _M_type = __is_fundamental<_Tp>::_M_type\n+    };\n+  };\n+\n+} // namespace std\n+\n+\n+#endif //_CPP_BITS_CPP_TYPE_TRAITS_H\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "e4d033c9ada8900e55545e674721ce8006dce78f", "filename": "libstdc++-v3/include/bits/exception_support.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fexception_support.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fexception_support.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fexception_support.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,79 @@\n+// Methods and support infrastructure for exceptions -*- C++ -*-\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 15 Exception handling\n+//\n+\n+// This file declares functions whose only purpose is to throw an\n+// exception. They help break a circularity between <string> and\n+// <stdexcept>. See src/stdexcept.cc, where these functions are\n+// defined.\n+\n+// XXX: These functions serve a similar purpose to those in\n+// stl/bits/stl_range_errors.h . Eventually the two approaches should\n+// be merged. \n+\n+#ifndef _CPP_EXCEPTION_SUPPORT_H\n+#define _CPP_EXCEPTION_SUPPORT_H\t1\n+\n+namespace std {\n+\n+#if _GLIBCPP_USE_EXCEPTIONS\n+  // Internal functions for string implementation.\n+  extern void __out_of_range(const char *__str);\n+  extern void __length_error(const char *__str);\n+  \n+# define __OUTOFRANGE(__cond) \\\n+  do { if (__cond) __out_of_range(#__cond); } while (0)\n+# define __LENGTHERROR(__cond) \\\n+  do { if (__cond) __length_error(#__cond); } while (0)\n+#else\n+# include <bits/std_cassert.h>\n+# define __OUTOFRANGE(__cond) assert(!(__cond))\n+# define __LENGTHERROR(__cond) assert(!(__cond))\n+#endif\n+\n+} // namespace std\n+\n+#endif\t/* _CPP_EXCEPTION_SUPPORT_H */\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "27792b04a847fab0ac25f9860da780f331a9ca7e", "filename": "libstdc++-v3/include/bits/fpos.h", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffpos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffpos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffpos.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,121 @@\n+// File position object and stream types\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27 Input/output library\n+//\n+\n+#ifndef _CPP_BITS_FPOS_H\n+#define _CPP_BITS_FPOS_H 1\n+\n+// Need this here as well as in std_ios because fpos is used in\n+// char_traits, and char_traits is used by string, which may or may\n+// not have included the std_ios file.\n+#include <bits/c++io.h>\n+\n+namespace std {\n+\n+  // 27.4.1  Types\n+\n+  // 27.4.3  Template class fpos\n+  template<typename _StateT>\n+    class fpos\n+    {\n+    public:\n+\n+      // Types:\n+      typedef _StateT __state_type;\n+\n+      __state_type\n+      state() const  { return _M_st; }\n+\n+      void \n+      state(__state_type __st)  { _M_st = __st; }\n+\n+      // NB: The standard defines only the implicit copy ctor and the\n+      // previous two members.  The rest is a \"conforming extension\".\n+      fpos(): _M_st(__state_type()), _M_pos(streamoff()) { }\n+\n+      fpos(streamoff __pos, __state_type __st)\n+      : _M_st(__st), _M_pos(__pos) { }\n+\n+      fpos(streamoff __pos)\n+      : _M_st(), _M_pos(__pos) { }\n+\n+      operator streamoff() const { return _M_pos; }\n+\n+      fpos& \n+      operator+=(streamoff __off) { _M_pos += __off; return *this; }\n+\n+      fpos& \n+      operator-=(streamoff __off) { _M_pos -= __off; return *this; }\n+\n+      bool  \n+      operator==(const fpos& __pos2) const { return _M_pos == __pos2._M_pos; }\n+\n+      bool  \n+      operator!=(const fpos& __pos2) const { return _M_pos != __pos2._M_pos; }\n+      \n+      streamoff \n+      _M_position() const { return _M_pos; }\n+\n+      void\n+      _M_position(streamoff __pos)  { _M_pos = __pos; }\n+\n+    private:\n+      __state_type _M_st;\n+      streamoff _M_pos;\n+    };\n+\n+  template<typename _State>\n+    inline fpos<_State> \n+    operator+(const fpos<_State>& __pos, streamoff __off)\n+    { \n+      fpos<_State> t(__pos); \n+      return t += __off; \n+    }\n+\n+  template<typename _State>\n+    inline fpos<_State>\n+    operator-(const fpos<_State>& __pos, streamoff __off)\n+    { \n+      fpos<_State> t(__pos); \n+      return t -= __off; \n+    }\n+\n+  template<typename _State>\n+    inline streamoff \n+    operator-(const fpos<_State>& __pos1, const fpos<_State>& __pos2)\n+    { return __pos1._M_position() - __pos2._M_position(); }\n+\n+}  // namespace std\n+\n+#endif /* _CPP_BITS_FPOS_H */\n+\n+"}, {"sha": "d3a57501097415b8b7c4aa72bb4d6a995674fee4", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "added", "additions": 586, "deletions": 0, "changes": 586, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,586 @@\n+// File based streams -*- C++ -*-\n+\n+// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.8  File-based streams\n+//\n+\n+#ifndef _CPP_BITS_FSTREAM_TCC\n+#define _CPP_BITS_FSTREAM_TCC 1\n+\n+namespace std\n+{\n+  template<typename _CharT, typename _Traits>\n+    void\n+    basic_filebuf<_CharT, _Traits>::\n+    _M_filebuf_init()\n+    {\n+      _M_buf_unified = true; // Tie input to output for basic_filebuf.\n+      _M_buf_size = _M_buf_size_opt;\n+      try {\n+\t_M_file = new __file_type(&_M_lock);\n+      }\n+      catch(...) {\n+\tdelete _M_file;\n+\tthrow;\n+      }\n+     }\n+\n+  template<typename _CharT, typename _Traits>\n+    void\n+    basic_filebuf<_CharT, _Traits>::\n+    _M_allocate_buffers()\n+    {\n+      // Allocate internal buffer.\n+      try {\n+\t_M_buf = new char_type[_M_buf_size];\n+      }\n+      catch(...) {\n+\tdelete [] _M_buf;\n+\tthrow;\n+      }\n+      \n+      // Allocate pback buffer.\n+      try {\n+\t_M_pback = new char_type[_M_pback_size];\n+      }\n+      catch(...) {\n+\tdelete [] _M_pback;\n+\tthrow;\n+      }\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::\n+    basic_filebuf() \n+    : __streambuf_type(), _M_file(NULL), _M_state_cur(), _M_state_beg(), \n+    _M_last_overflowed(false)\n+    { _M_fcvt = &use_facet<__codecvt_type>(this->getloc()); }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::\n+    basic_filebuf(int __fd, const char* /*__name*/, ios_base::openmode __mode)\n+    : __streambuf_type(), _M_state_cur(), _M_state_beg(),\n+    _M_last_overflowed(false)\n+    {\n+      _M_fcvt = &use_facet<__codecvt_type>(this->getloc());\n+      _M_filebuf_init();\n+      _M_file->sys_open(__fd, __mode);\n+      if (this->is_open() && _M_buf_size)\n+\t{\n+\t  _M_allocate_buffers();\n+\t  _M_mode = __mode;\n+\n+\t  // XXX So that istream::getc() will only need to get 1 char,\n+\t  // as opposed to BUF_SIZE.\n+\t  if (__fd == 0)\n+\t    _M_buf_size = 1;\n+\n+\t  this->_M_set_indeterminate();\n+\t}\n+   }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::__filebuf_type* \n+    basic_filebuf<_CharT, _Traits>::\n+    open(const char* __s, ios_base::openmode __mode)\n+    {\n+      __filebuf_type *__ret = NULL;\n+      if (!this->is_open())\n+\t{\n+\t  _M_filebuf_init();\n+\t  _M_file->open(__s, __mode);\n+\t  if (this->is_open() && _M_buf_size)\n+\t    {\n+\t      _M_allocate_buffers();\n+\t      _M_mode = __mode;\n+\t      \n+\t      // For time being, set both (in/out) sets  of pointers.\n+\t      _M_set_indeterminate();\n+\t      if (__mode & ios_base::ate\n+\t\t  && this->seekoff(0, ios_base::end, __mode) < 0)\n+\t\tthis->close();\n+\t      __ret = this;\n+\t    }\n+\t}\n+      return __ret;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::__filebuf_type* \n+    basic_filebuf<_CharT, _Traits>::\n+    close()\n+    {\n+      __filebuf_type *__ret = NULL;\n+      if (this->is_open())\n+\t{\n+\t  bool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n+\t  if (__testput)\n+\t    _M_really_overflow(traits_type::eof());\n+\n+\t  // NB: Do this here so that re-opened filebufs will be cool...\n+\t  _M_pback_destroy();\n+\n+#if 0\n+\t  // XXX not done\n+\t  if (_M_last_overflowed)\n+\t    {\n+\t      _M_output_unshift();\n+\t      _M_really_overflow(traits_type::eof());\n+\t    }\n+#endif\n+\n+\t  _M_mode = ios_base::openmode(0);\n+\t  if (_M_buf_size)\n+\t    delete [] _M_buf;\n+\t  _M_buf = NULL;\n+\t  delete [] _M_pback;\n+\t  _M_pback = NULL;\n+\t  this->setg(NULL, NULL, NULL);\n+\t  this->setp(NULL, NULL);\n+\t  __ret = this;\n+\t}\n+\n+      // Can actually allocate this file as part of an open and never\n+      // have it be opened.....\n+      if (_M_file)\n+\t{\n+\t  delete _M_file;\n+\t  _M_file = NULL;\n+\t}\n+      _M_last_overflowed = false;\t\n+      return __ret;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    streamsize \n+    basic_filebuf<_CharT, _Traits>::\n+    showmanyc()\n+    {\n+      streamsize __ret = -1;\n+      bool __testin = _M_mode & ios_base::in;\n+\n+      if (__testin)\n+\t{\n+\t  bool __testeof = false;\n+\t  if (_M_in_cur >= _M_in_end)\n+\t    __testeof = this->underflow() == traits_type::eof();\n+\t  if (!__testeof)\n+\t    __ret = _M_in_end - _M_in_cur;\n+\t}\n+      _M_last_overflowed = false;\t\n+      return __ret;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::int_type \n+    basic_filebuf<_CharT, _Traits>::\n+    underflow()\n+    {\n+      int_type __ret = traits_type::eof();\n+      bool __testin = _M_mode & ios_base::in;\n+      \n+      if (__testin)\n+\t{\n+\t  // Check for pback madness, and if so swich back to the\n+\t  // normal buffers and jet outta here before expensive\n+\t  // fileops happen...\n+\t  if (_M_pback_init)\n+\t    {\n+\t      _M_pback_destroy();\n+\t      if (_M_in_cur < _M_in_end)\n+\t\treturn traits_type::to_int_type(*_M_in_cur);\n+\t    }\n+\n+\t  bool __testget = _M_in_cur && _M_in_beg < _M_in_cur;\n+\t  bool __testinit = _M_is_indeterminate();\n+\t  bool __testout = _M_mode & ios_base::out;\n+\n+\t  // Sync internal and external buffers.\n+\t  // NB: __testget -> __testput as _M_buf_unified here.\n+\t  if (__testget)\n+\t    {\n+\t      if (__testout)\n+\t\t_M_really_overflow();\n+\t      else \n+\t\t_M_file->seekoff(_M_in_cur - _M_in_beg, \n+\t\t\t\t ios_base::cur, ios_base::in);\n+\t    }\n+\n+\t  if (__testinit || __testget)\n+\t    {\n+#if 1\n+\t      streamsize __size = _M_file->xsgetn(_M_in_beg, _M_buf_size);\n+\t      if (0 < __size)\n+\t\t{\n+\t\t  _M_set_determinate(__size);\n+\t\t  streamoff __p = _M_file->seekoff(0 - __size, ios_base::cur, \n+\t\t\t\t\t\t   ios_base::in);\n+\t\t  if (__p == -1)\n+\t\t    {\n+\t\t      // XXX Something is wrong, do error checking.\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (__testout)\n+\t\t\t_M_out_cur = _M_in_cur;\n+\t\t      __ret = traits_type::to_int_type(*_M_in_cur);\n+\t\t    }\n+\t\t}\n+#else\n+\t      // 2000-08-04 bkoz disable\n+\t      // Part one: (Re)fill external buf (_M_file->_IO_*) from\n+\t      // external byte sequence (whatever physical byte sink or\n+\t      // FILE actually is.)\n+\t      char_type __conv_buf[_M_buf_size];\n+\t      streamsize __size = _M_file->xsgetn(__conv_buf, _M_buf_size);\n+\t      \n+\t      // Part two: (Re)fill internal buf contents from external buf.\n+\t      if (0 < __size)\n+\t\t{\n+\t\t  _M_set_determinate(__size);\n+\t\t  \n+\t\t  char* __conv_cur = __conv_buf;\n+\t\t  _M_state_beg = _M_state_cur;\n+\t\t  __res_type __r = _M_fcvt->in(_M_state_cur, \n+\t\t\t\t\t       __conv_buf,\n+\t\t\t\t\t       __conv_buf + __size,\n+\t\t\t\t\t const_cast<const char*&>(__conv_cur), \n+\t\t\t\t\t      _M_in_beg, _M_in_end, _M_in_cur);\n+\t      \n+\t\t  if (__r == codecvt_base::partial)\n+\t\t    {\n+\t\t      // XXX Retry with larger _M_buf size.\n+\t\t    }\n+\t\t  \n+\t\t  // Set pointers to internal and external buffers\n+\t\t  // correctly. . .\n+\t\t  if (__r != codecvt_base::error)\n+\t\t    {\n+\t\t      if (__testout)\n+\t\t\t_M_out_cur = _M_in_cur;\n+\t\t      __ret = traits_type::to_int_type(*_M_in_cur);\n+\t\t    }\n+\n+\t\t  // Part three: Sync the current internal buffer\n+\t\t  // position with the (now overshot) external buffer\n+\t\t  // position.  \n+\t\t  streamoff __p = _M_file->seekoff(0 - __size, ios_base::cur, \n+\t\t\t\t\t\t  ios_base::in);\n+\t\t  if (__p == -1)\n+\t\t    {\n+\t\t      // XXX Something is wrong, do error checking.\n+\t\t    }\n+\t\t}\n+#endif\t      \n+\t    }\n+\t}\n+      _M_last_overflowed = false;\t\n+      return __ret;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::int_type \n+    basic_filebuf<_CharT, _Traits>::\n+    pbackfail(int_type __i)\n+    {\n+      int_type __ret = traits_type::eof();\n+      bool __testin = _M_mode & ios_base::in;\n+\n+      if (__testin)\n+\t{\n+\t  bool __testpb = _M_in_beg < _M_in_cur;\n+\t  char_type __c = traits_type::to_char_type(__i);\n+\t  bool __testeof = traits_type::eq_int_type(__i, __ret);\n+\n+\t  if (__testpb)\n+\t    {\n+\t      bool __testout = _M_mode & ios_base::out;\n+\t      bool __testeq = traits_type::eq(__c, this->gptr()[-1]);\n+\n+\t      // Try to put back __c into input sequence in one of three ways.\n+\t      // Order these tests done in is unspecified by the standard.\n+\t      if (!__testeof && __testeq)\n+\t\t{\n+\t\t  --_M_in_cur;\n+\t\t  if (__testout)\n+\t\t    --_M_out_cur;\n+\t\t  __ret = __i;\n+\t\t}\n+\t      else if (__testeof)\n+\t\t{\n+\t\t  --_M_in_cur;\n+\t\t  if (__testout)\n+\t\t    --_M_out_cur;\n+\t\t  __ret = traits_type::not_eof(__i);\n+\t\t}\n+\t      else if (!__testeof)\n+\t\t{\n+\t\t  --_M_in_cur;\n+\t\t  if (__testout)\n+\t\t    --_M_out_cur;\n+\t\t  _M_pback_create();\n+\t\t  *_M_in_cur = __c; \n+\t\t  __ret = __i;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\t \n+ \t      // At the beginning of the buffer, need to make a\n+\t      // putback position available.\n+\t      this->seekoff(-1, ios_base::cur);\n+\t      this->underflow();\n+ \t      if (!__testeof)\n+ \t\t{\n+\t\t  if (!traits_type::eq(__c, *_M_in_cur))\n+\t\t    {\n+\t\t      _M_pback_create();\n+\t\t      *_M_in_cur = __c;\n+\t\t    }\n+ \t\t  __ret = __i;\n+ \t\t}\n+ \t      else\n+ \t\t__ret = traits_type::not_eof(__i);\n+ \t    }\n+\t}\n+      _M_last_overflowed = false;\t\n+      return __ret;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::int_type \n+    basic_filebuf<_CharT, _Traits>::\n+    overflow(int_type __c)\n+    {\n+      int_type __ret = traits_type::eof();\n+      bool __testpos = _M_out_cur && _M_out_cur >= _M_buf + _M_buf_size;\n+      bool __testout = _M_mode & ios_base::out;\n+      \n+      if (__testout)\n+\t{\n+\t  if (!__testpos)\n+\t    {\n+\t      *_M_out_cur = traits_type::to_char_type(__c);\n+\t      _M_out_cur_move(1);\n+\t      __ret = traits_type::not_eof(__c);\n+\t    }\n+\t  else \n+\t    __ret = this->_M_really_overflow(__c);\n+\t}\n+\n+      _M_last_overflowed = false;    // Set in _M_really_overflow, below.\n+      return __ret;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::int_type \n+    basic_filebuf<_CharT, _Traits>::\n+    _M_really_overflow(int_type __c)\n+    {\n+      int_type __ret = traits_type::eof();\n+      bool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n+      \n+      if (__testput)\n+\t{\n+\t  bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());\n+#if 1\n+\t  int __plen = _M_out_end - _M_out_beg;\n+\t  streamsize __len = _M_file->xsputn(_M_out_beg, __plen);\n+\t  if (!__testeof)\n+\t    {\n+\t      char_type __pending = traits_type::to_char_type(__c);\n+\t      __len += _M_file->xsputn(&__pending, 1);\n+\t      ++__plen;\n+\t    }\n+\t  traits_type::to_char_type(__c);\n+\t  // NB: Need this so that external byte sequence reflects\n+\t  // internal buffer.\n+\t  _M_file->sync();\n+\t  if (__len == __plen)\n+\t    {\n+\t      _M_set_indeterminate();\n+\t      __ret = traits_type::not_eof(__c);\n+\t    }\n+#else\n+\t  // Part one: Allocate temporary conversion buffer on\n+\t  // stack. Convert internal buffer plus __c (ie,\n+\t  // \"pending sequence\") to temporary conversion buffer.\n+\t  int __plen = _M_out_end - _M_out_beg;\n+\t  char_type __pbuf[__plen + 1];\t      \n+\t  traits_type::copy(__pbuf, this->pbase(), __plen);\n+\t  if (!__testeof)\n+\t    {\n+\t      __pbuf[__plen] = traits_type::to_char_type(__c);\n+\t      ++__plen;\n+\t    }\n+\n+\t  char_type* __pend;\n+\t  char __conv_buf[__plen];\n+\t  char* __conv_end;\n+\t  _M_state_beg = _M_state_cur;\n+\n+\t  __res_type __r = _M_fcvt->out(_M_state_cur, \n+\t\t\t\t\t__pbuf, __pbuf + __plen,\n+\t\t\t\t\tconst_cast<const char_type*&>(__pend),\n+\t\t\t\t\t__conv_buf, __conv_buf + __plen,\n+\t\t\t\t\t__conv_end);\n+\t  \n+\t  // Part two: (Re)spill converted \"pending sequence\"\n+\t  // contents (now in temporary conversion buffer) to\n+\t  // external buffer (_M_file->_IO_*) using\n+\t  // _M_file->sys_write(), and do error (minimal) checking.\n+\t  if (__r != codecvt_base::error)\n+\t    {\n+\t      streamsize __len = _M_file->xsputn(__conv_buf, __plen);\n+\t      // NB: Need this so that external byte sequence reflects\n+\t      // internal buffer.\n+\t      _M_file->sync();\n+\t      if (__len == __plen)\n+\t\t{\n+\t\t  _M_set_indeterminate();\n+\t\t  __ret = traits_type::not_eof(__c);\n+\t\t}\n+\t    }\n+#endif\n+\t}\t      \n+      _M_last_overflowed = true;\t\n+      return __ret;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::pos_type\n+    basic_filebuf<_CharT, _Traits>::\n+    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)\n+    {\n+      pos_type __ret =  pos_type(off_type(-1)); \n+      bool __testopen = this->is_open();\n+      bool __testin = __mode & ios_base::in && _M_mode & ios_base::in;\n+      bool __testout = __mode & ios_base::out && _M_mode & ios_base::out;\n+      int __width = _M_fcvt->encoding();\n+      if (__width < 0)\n+\t__width = 0;\n+      bool __testfail = __off != 0  && __width <= 0;\n+      \n+      if (__testopen && !__testfail && (__testin || __testout))\n+\t{\n+\t  // Ditch any pback buffers to avoid confusion.\n+\t  _M_pback_destroy();\n+\n+\t  if (__way != ios_base::cur || __off != 0)\n+\t    { \n+\t      off_type __computed_off = __width * __off;\n+\t      \n+\t      bool __testget = _M_in_cur && _M_in_beg < _M_in_end;\n+\t      bool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n+\t      // Sync the internal and external streams.\n+\t      // out\n+\t      if (__testput || _M_last_overflowed)\n+\t\t{\n+\t\t  // Part one: update the output sequence.\n+\t\t  this->sync();\n+\t\t  // Part two: output unshift sequence.\n+\t\t  _M_output_unshift();\n+\t\t}\n+\t      //in\n+\t      // NB: underflow() rewinds the external buffer.\n+\t      else if (__testget && __way == ios_base::cur)\n+\t\t__computed_off += _M_in_cur - _M_in_beg;\n+\t  \n+\t      __ret = _M_file->seekoff(__computed_off, __way, __mode);\n+\t      _M_set_indeterminate();\n+\t    }\n+\t  // NB: Need to do this in case _M_file in indeterminate\n+\t  // state, ie _M_file->_offset == -1\n+\t  else\n+\t    {\n+\t      __ret = _M_file->seekoff(__off, ios_base::cur, __mode);\n+\t      __ret += max(_M_out_cur, _M_in_cur) - _M_buf;\n+\t    }\n+\t}\n+      _M_last_overflowed = false;\t\n+      return __ret;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_filebuf<_CharT, _Traits>::pos_type\n+    basic_filebuf<_CharT, _Traits>::\n+    seekpos(pos_type __pos, ios_base::openmode __mode)\n+    {\n+      pos_type __ret;\n+      off_type __off = __pos;\n+\n+      __ret = this->seekoff(__off, ios_base::beg, __mode); \n+\n+      _M_last_overflowed = false;\t\n+      return __ret;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    void \n+    basic_filebuf<_CharT, _Traits>::\n+    _M_output_unshift()\n+    { }\n+\n+  template<typename _CharT, typename _Traits>\n+    void\n+    basic_filebuf<_CharT, _Traits>::\n+    imbue(const locale& __loc)\n+    {\n+      bool __testbeg = gptr() == eback() && pptr() == pbase();\n+      bool __teststate = _M_fcvt->encoding() == -1;\n+      \n+      _M_buf_locale_init = true;\n+      if (__testbeg && !__teststate && _M_buf_locale != __loc)\n+\t{\n+\t  // XXX Will need to save these older values.\n+\t  _M_buf_locale = __loc;\n+\t  _M_fcvt = &use_facet<__codecvt_type>(_M_buf_locale);\n+\t  // XXX Necessary?\n+\t  _M_buf_fctype = &use_facet<__ctype_type>(_M_buf_locale); \n+\t}\n+      // NB this may require the reconversion of previously\n+      // converted chars. This in turn may cause the reconstruction\n+      // of the original file. YIKES!!\n+      // XXX The part in the above comment is not done.\n+      _M_last_overflowed = false;\t\n+    }\n+  \n+} // namespace std\n+\n+#endif // _CPP_BITS_FSTREAM_TCC\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "b2a554f89eee64075bca0b1fda7ab3cd6b75212f", "filename": "libstdc++-v3/include/bits/generic_shadow.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgeneric_shadow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgeneric_shadow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgeneric_shadow.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,59 @@\n+// generic C header shadow file -*- C++ -*-\n+\n+// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This file is included by all the standard C <foo.h> headers\n+// after defining _SHADOW_NAME.\n+\n+#ifdef _IN_C_LEGACY_  /* sub-included by a C header */\n+\n+      // Get out of the \"swamp.\"\n+    } // Close extern \"C\"\n+  }   // Close namespace _C_legacy::\n+\n+# undef _IN_C_LEGACY_\n+# include _SHADOW_NAME\n+\n+  // Dive back into the \"swamp.\"\n+  namespace _C_legacy {\n+    extern \"C\" {\n+#     define _IN_C_LEGACY_\n+  \n+#else /* not _IN_C_LEGACY_:  directly included by user program */\n+  \n+# include _SHADOW_NAME\n+  \n+  // Expose global C names, including non-standard ones, but shadow\n+  // some names and types with the std:: C++ version.\n+\n+  using namespace ::_C_legacy::_C_shadow;\n+  \n+#endif /* _IN_C_LEGACY_ */\n+    \n+\n+"}, {"sha": "737254c9da7c388d069bfc35bf348d650714d79c", "filename": "libstdc++-v3/include/bits/gslice.h", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,117 @@\n+// The template and inlines for the -*- C++ -*- gslice class.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef _CPP_BITS_GSLICE_H\n+#define _CPP_BITS_GSLICE_H\n+\n+namespace std {\n+    \n+    class gslice\n+    {\n+    public:\n+        gslice ();\n+        gslice (size_t, const valarray<size_t>&, const valarray<size_t>&);\n+        // XXX: the IS says the copy-ctor and copy-assignment operators are\n+        //      synthetized by the compiler but they are just unsuitable\n+        //      for a ref-counted semantic\n+        gslice(const gslice&);\n+        ~gslice();\n+\n+        // XXX: See the note above.\n+        gslice& operator= (const gslice&);\n+        \n+        size_t           start () const;\n+        valarray<size_t> size () const;\n+        valarray<size_t> stride () const;\n+        \n+    private:\n+        struct _Indexer {\n+            size_t _M_count;\n+            size_t _M_start;\n+            valarray<size_t> _M_size;\n+            valarray<size_t> _M_stride;\n+            valarray<size_t> _M_index;\n+            _Indexer(size_t, const valarray<size_t>&,\n+                     const valarray<size_t>&);\n+            void _M_increment_use() { ++_M_count; }\n+            size_t _M_decrement_use() { return --_M_count; }\n+        };\n+\n+        _Indexer* _M_index;\n+        \n+        template<typename _Tp> friend class valarray;\n+    };\n+    \n+    inline size_t\n+    gslice::start () const\n+    { return _M_index ? _M_index->_M_start : 0; }\n+    \n+    inline valarray<size_t>\n+    gslice::size () const\n+    { return _M_index ? _M_index->_M_size : valarray<size_t>(); }\n+    \n+    inline valarray<size_t>\n+    gslice::stride () const\n+    { return _M_index ? _M_index->_M_stride : valarray<size_t>(); }\n+    \n+    inline gslice::gslice () : _M_index(0) {}\n+\n+    inline\n+    gslice::gslice(size_t __o, const valarray<size_t>& __l,\n+                   const valarray<size_t>& __s)\n+            : _M_index(new gslice::_Indexer(__o, __l, __s)) {}\n+\n+    inline\n+    gslice::gslice(const gslice& __g) : _M_index(__g._M_index)\n+    { if (_M_index) _M_index->_M_increment_use(); }\n+    \n+    inline\n+    gslice::~gslice()\n+    { if (_M_index && _M_index->_M_decrement_use() == 0) delete _M_index; }\n+\n+    inline gslice&\n+    gslice::operator= (const gslice& __g)\n+    {\n+        if (__g._M_index) __g._M_index->_M_increment_use();\n+        if (_M_index && _M_index->_M_decrement_use() == 0) delete _M_index;\n+        _M_index = __g._M_index;\n+        return *this;\n+    }\n+            \n+    \n+} // std::\n+\n+\n+#endif /* _CPP_BITS_GSLICE_H */\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "23a1f6d438bb2bd1d8eb8e134f6c020b32e7cc42", "filename": "libstdc++-v3/include/bits/gslice_array.h", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice_array.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,169 @@\n+// The template and inlines for the -*- C++ -*- gslice_array class.\n+\n+// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef _CPP_BITS_GSLICE_ARRAY\n+#define _CPP_BITS_GSLICE_ARRAY 1\n+\n+namespace std {\n+\n+    template<typename _Tp> class gslice_array\n+    {\n+    public:\n+        typedef _Tp value_type;\n+\n+        void operator=  (const valarray<_Tp>&) const;\n+        void operator*= (const valarray<_Tp>&) const;\n+        void operator/= (const valarray<_Tp>&) const;\n+        void operator%= (const valarray<_Tp>&) const;\n+        void operator+= (const valarray<_Tp>&) const;\n+        void operator-= (const valarray<_Tp>&) const;\n+        void operator^= (const valarray<_Tp>&) const;\n+        void operator&= (const valarray<_Tp>&) const;\n+        void operator|= (const valarray<_Tp>&) const;\n+        void operator<<=(const valarray<_Tp>&) const;\n+        void operator>>=(const valarray<_Tp>&) const;\n+        void operator=(const _Tp&);\n+\n+        template<class _Dom>\n+        void operator= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator*= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator/= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator%= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator+= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator-= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator^= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator&= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator|= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator<<= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator>>= (const _Expr<_Dom,_Tp>&) const;\n+        \n+    private:\n+        _Array<_Tp>    _M_array;\n+        const valarray<size_t>& _M_index;\n+        \n+        friend class valarray<_Tp>;\n+        \n+        gslice_array (_Array<_Tp>, const valarray<size_t>&);\n+\n+        // this constructor needs to be implemented.\n+        gslice_array (const gslice_array&);\n+\n+        // not implemented\n+        gslice_array();\n+        gslice_array& operator= (const gslice_array&);\n+    };\n+\n+    template<typename _Tp>\n+    inline\n+    gslice_array<_Tp>::gslice_array (_Array<_Tp> __a,\n+                                     const valarray<size_t>& __i)\n+            : _M_array (__a), _M_index (__i) {}\n+\n+\n+    template<typename _Tp>\n+    inline\n+    gslice_array<_Tp>::gslice_array (const gslice_array<_Tp>& __a)\n+            : _M_array (__a._M_array), _M_index (__a._M_index) {}\n+\n+    \n+    template<typename _Tp>\n+    inline void\n+    gslice_array<_Tp>::operator= (const _Tp& __t) \n+    { \n+        __valarray_fill (_M_array, _Array<size_t>(_M_index),\n+                         _M_index.size(), __t); \n+    }\n+\n+    template<typename _Tp>\n+    inline void\n+    gslice_array<_Tp>::operator= (const valarray<_Tp>& __v) const\n+    {\n+        __valarray_copy (_Array<_Tp> (__v), __v.size (),\n+                         _M_array, _Array<size_t>(_M_index));\n+    }\n+\n+    template<typename _Tp>\n+    template<class E>\n+    inline void\n+    gslice_array<_Tp>::operator= (const _Expr<E, _Tp>& __e) const\n+    {\n+        __valarray_copy (__e, _M_index.size(), _M_array,\n+                         _Array<size_t>(_M_index));\n+    }\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+#define _DEFINE_VALARRAY_OPERATOR(op, name)\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+gslice_array<_Tp>::operator op##= (const valarray<_Tp>& __v) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##name (_M_array, _Array<size_t>(_M_index),\t\\\n+                              _Array<_Tp> (__v), __v.size ());\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp> template<class E>        \t\t\t\\\n+inline void \t\t\t\t\t\t\t\t\\\n+gslice_array<_Tp>::operator op##= (const _Expr<E, _Tp>& __e) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##name (_M_array, _Array<size_t>(_M_index), __e,\t\\\n+                              _M_index.size());\t\t\t\t\\\n+}\n+\n+_DEFINE_VALARRAY_OPERATOR(*, multiplies)\n+_DEFINE_VALARRAY_OPERATOR(/, divides)    \n+_DEFINE_VALARRAY_OPERATOR(%, modulus)\n+_DEFINE_VALARRAY_OPERATOR(+, plus)    \n+_DEFINE_VALARRAY_OPERATOR(-, minus)\n+_DEFINE_VALARRAY_OPERATOR(^, xor)\n+_DEFINE_VALARRAY_OPERATOR(&, and)\n+_DEFINE_VALARRAY_OPERATOR(|, or)\n+_DEFINE_VALARRAY_OPERATOR(<<, shift_left)\n+_DEFINE_VALARRAY_OPERATOR(>>, shift_right)\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+\n+} // std::\n+\n+#endif /* _CPP_BITS_GSLICE_ARRAY */\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "1ad3b911f6b83cee08810153fdf756b8bfbe461c", "filename": "libstdc++-v3/include/bits/indirect_array.h", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,160 @@\n+// The template and inlines for the -*- C++ -*- indirect_array class.\n+\n+// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef _CPP_BITS_INDIRECT_ARRAY_H\n+#define _CPP_BITS_INDIRECT_ARRAY_H\n+\n+namespace std {\n+\n+    template <class _Tp> class indirect_array\n+    {\n+    public:\n+        typedef _Tp value_type;\n+    \n+        void operator=  (const valarray<_Tp>&) const;\n+        void operator*= (const valarray<_Tp>&) const;\n+        void operator/= (const valarray<_Tp>&) const;\n+        void operator%= (const valarray<_Tp>&) const; \n+        void operator+= (const valarray<_Tp>&) const;\n+        void operator-= (const valarray<_Tp>&) const;  \n+        void operator^= (const valarray<_Tp>&) const;\n+        void operator&= (const valarray<_Tp>&) const;\n+        void operator|= (const valarray<_Tp>&) const;\n+        void operator<<= (const valarray<_Tp>&) const;\n+        void operator>>= (const valarray<_Tp>&) const; \n+        void operator= (const _Tp&);\n+        //    ~indirect_array();\n+\n+        template<class _Dom>\n+        void operator=  (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator*= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator/= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator%= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator+= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator-= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator^= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator&= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator|= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator<<= (const _Expr<_Dom, _Tp>&) const;\n+        template<class _Dom>\n+        void operator>>= (const _Expr<_Dom, _Tp>&) const; \n+\n+    private:\n+    indirect_array (const indirect_array&);\n+    indirect_array (_Array<_Tp>, size_t, _Array<size_t>);\n+\n+    friend class valarray<_Tp>;\n+    friend class gslice_array<_Tp>;\n+\n+    const size_t \t _M_sz;\n+    const _Array<size_t> _M_index;\n+    const _Array<_Tp> \t _M_array;\n+\n+        // not implemented\n+        indirect_array ();\n+        indirect_array& operator= (const indirect_array&);\n+    };\n+\n+    template<typename _Tp>\n+    inline indirect_array<_Tp>::indirect_array(const indirect_array<_Tp>& __a)\n+            : _M_sz (__a._M_sz), _M_index (__a._M_index),\n+              _M_array (__a._M_array) {}\n+    \n+    template<typename _Tp>\n+    inline\n+    indirect_array<_Tp>::indirect_array (_Array<_Tp> __a, size_t __s, \n+                                         _Array<size_t> __i)\n+            : _M_sz (__s), _M_index (__i), _M_array (__a) {}\n+    \n+    // template<typename _Tp>\n+    // inline indirect_array<_Tp>::~indirect_array() {}\n+\n+    template<typename _Tp>\n+    inline void\n+    indirect_array<_Tp>::operator= (const _Tp& __t)\n+    { __valarray_fill(_M_array, _M_index, _M_sz, __t); }\n+\n+    template<typename _Tp>\n+    inline void\n+    indirect_array<_Tp>::operator= (const valarray<_Tp>& __v) const\n+    { __valarray_copy (_Array<_Tp> (__v), _M_sz, _M_array, _M_index); }\n+\n+    template<typename _Tp>\n+    template<class _Dom>\n+    inline void\n+    indirect_array<_Tp>::operator= (const _Expr<_Dom,_Tp>& __e) const\n+    { __valarray_copy (__e, _M_sz, _M_array, _M_index); }\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+#define _DEFINE_VALARRAY_OPERATOR(op, name)\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+indirect_array<_Tp>::operator op##= (const valarray<_Tp>& __v) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _Array_augmented_##name (_M_array, _M_index, _Array<_Tp> (__v), _M_sz); \\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp> template<class _Dom>\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+indirect_array<_Tp>::operator op##= (const _Expr<_Dom,_Tp>& __e) const \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _Array_augmented_##name (_M_array, _M_index, __e, _M_sz);\t\t\\\n+}\n+\n+_DEFINE_VALARRAY_OPERATOR(*, multiplies)\n+_DEFINE_VALARRAY_OPERATOR(/, divides)\n+_DEFINE_VALARRAY_OPERATOR(%, modulus)\n+_DEFINE_VALARRAY_OPERATOR(+, plus)\n+_DEFINE_VALARRAY_OPERATOR(-, minus)\n+_DEFINE_VALARRAY_OPERATOR(^, xor)\n+_DEFINE_VALARRAY_OPERATOR(&, and)\n+_DEFINE_VALARRAY_OPERATOR(|, or)\n+_DEFINE_VALARRAY_OPERATOR(<<, shift_left)\n+_DEFINE_VALARRAY_OPERATOR(>>, shift_right)\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+\n+} // std::\n+\n+#endif /* _CPP_BITS_INDIRECT_ARRAY_H */\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "594621455220bbbf6b33adf89cb39260f871e75c", "filename": "libstdc++-v3/include/bits/ios_base.h", "status": "added", "additions": 576, "deletions": 0, "changes": 576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,576 @@\n+// Iostreams base classes -*- C++ -*-\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.8  File-based streams\n+//\n+\n+#ifndef _CPP_BITS_IOSBASE_H\n+#define _CPP_BITS_IOSBASE_H 1\n+\n+namespace std {\n+\n+  // The following definitions of bitmask types are enums, not ints,\n+  // as permitted (but not required) in the standard, in order to provide\n+  // better type safety in iostream calls.  A side effect is that\n+  // expressions involving them are no longer compile-time constants.\n+  enum _Ios_Fmtflags { _S_ios_fmtflags_end = 1<<16 };\n+\n+  inline _Ios_Fmtflags \n+  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n+  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }\n+\n+  inline _Ios_Fmtflags \n+  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n+  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }\n+\n+  inline _Ios_Fmtflags \n+  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)\n+  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n+\n+  inline _Ios_Fmtflags \n+  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n+  { return __a = __a | __b; }\n+\n+  inline _Ios_Fmtflags \n+  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n+  { return __a = __a & __b; }\n+\n+  inline _Ios_Fmtflags \n+  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)\n+  { return __a = __a ^ __b; }\n+\n+  inline _Ios_Fmtflags \n+  operator~(_Ios_Fmtflags __a)\n+  { return _Ios_Fmtflags(~static_cast<int>(__a)); }\n+\n+\n+  enum _Ios_Openmode { _S_ios_openmode_end = 1<<16 };\n+\n+  inline _Ios_Openmode \n+  operator&(_Ios_Openmode __a, _Ios_Openmode __b)\n+  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }\n+\n+  inline _Ios_Openmode \n+  operator|(_Ios_Openmode __a, _Ios_Openmode __b)\n+  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }\n+\n+  inline _Ios_Openmode \n+  operator^(_Ios_Openmode __a, _Ios_Openmode __b)\n+  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n+\n+  inline _Ios_Openmode \n+  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)\n+  { return __a = __a | __b; }\n+\n+  inline _Ios_Openmode \n+  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)\n+  { return __a = __a & __b; }\n+\n+  inline _Ios_Openmode \n+  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)\n+  { return __a = __a ^ __b; }\n+\n+  inline _Ios_Openmode \n+  operator~(_Ios_Openmode __a)\n+  { return _Ios_Openmode(~static_cast<int>(__a)); }\n+\n+\n+  enum _Ios_Iostate { _S_ios_iostate_end = 1<<16 };\n+\n+  inline _Ios_Iostate \n+  operator&(_Ios_Iostate __a, _Ios_Iostate __b)\n+  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }\n+\n+  inline _Ios_Iostate \n+  operator|(_Ios_Iostate __a, _Ios_Iostate __b)\n+  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }\n+\n+  inline _Ios_Iostate \n+  operator^(_Ios_Iostate __a, _Ios_Iostate __b)\n+  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }\n+\n+  inline _Ios_Iostate \n+  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)\n+  { return __a = __a | __b; }\n+\n+  inline _Ios_Iostate \n+  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)\n+  { return __a = __a & __b; }\n+\n+  inline _Ios_Iostate \n+  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)\n+  { return __a = __a ^ __b; }\n+\n+  inline _Ios_Iostate \n+  operator~(_Ios_Iostate __a)\n+  { return _Ios_Iostate(~static_cast<int>(__a)); }\n+\n+  enum _Ios_Seekdir { _S_ios_Seekdir_end = 1<<16 };\n+\n+  // 27.4.2  Class ios_base\n+  class ios_base\n+  {\n+  public:\n+\n+    // 27.4.2.1.1  Class ios_base::failure\n+    class failure : public exception\n+    {\n+    public:\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+      // Can't do exception(_msg) as defined in 27.4.2.1.1\n+      explicit \n+      failure(const string& __str);\n+\n+      virtual \n+      ~failure() { };\n+\n+      virtual const \n+      char* what() const throw() { return _M_name; }\n+      \n+    private:\n+      enum { _M_bufsize = 256 };\n+      char _M_name[_M_bufsize];\n+#endif\n+    };\n+\n+    // 27.4.2.1.2  Type ios_base::fmtflags\n+    typedef _Ios_Fmtflags fmtflags;\n+    // 27.4.2.1.2  Type fmtflags\n+    static const fmtflags boolalpha =   fmtflags(__ios_flags::_S_boolalpha);\n+    static const fmtflags dec =         fmtflags(__ios_flags::_S_dec);\n+    static const fmtflags fixed =       fmtflags(__ios_flags::_S_fixed);\n+    static const fmtflags hex =         fmtflags(__ios_flags::_S_hex);\n+    static const fmtflags internal =    fmtflags(__ios_flags::_S_internal);\n+    static const fmtflags left =        fmtflags(__ios_flags::_S_left);\n+    static const fmtflags oct =         fmtflags(__ios_flags::_S_oct);\n+    static const fmtflags right =       fmtflags(__ios_flags::_S_right);\n+    static const fmtflags scientific =  fmtflags(__ios_flags::_S_scientific);\n+    static const fmtflags showbase =    fmtflags(__ios_flags::_S_showbase);\n+    static const fmtflags showpoint =   fmtflags(__ios_flags::_S_showpoint);\n+    static const fmtflags showpos =     fmtflags(__ios_flags::_S_showpos);\n+    static const fmtflags skipws =      fmtflags(__ios_flags::_S_skipws);\n+    static const fmtflags unitbuf =     fmtflags(__ios_flags::_S_unitbuf);\n+    static const fmtflags uppercase =   fmtflags(__ios_flags::_S_uppercase);\n+    static const fmtflags adjustfield = fmtflags(__ios_flags::_S_adjustfield);\n+    static const fmtflags basefield =   fmtflags(__ios_flags::_S_basefield);\n+    static const fmtflags floatfield =  fmtflags(__ios_flags::_S_floatfield);\n+\n+    // 27.4.2.1.3  Type ios_base::iostate\n+    typedef _Ios_Iostate iostate;\n+    static const iostate badbit =  \tiostate(__ios_flags::_S_badbit);\n+    static const iostate eofbit =  \tiostate(__ios_flags::_S_eofbit);\n+    static const iostate failbit = \tiostate(__ios_flags::_S_failbit);\n+    static const iostate goodbit = \tiostate(0);\n+\n+    // 27.4.2.1.4  Type openmode\n+    typedef _Ios_Openmode openmode;\n+    static const openmode app =    \topenmode(__ios_flags::_S_app);\n+    static const openmode ate =    \topenmode(__ios_flags::_S_ate);\n+    static const openmode binary = \topenmode(__ios_flags::_S_bin);\n+    static const openmode in =     \topenmode(__ios_flags::_S_in);\n+    static const openmode out =    \topenmode(__ios_flags::_S_out);\n+    static const openmode trunc =  \topenmode(__ios_flags::_S_trunc);\n+\n+    // 27.4.2.1.5  Type seekdir\n+    typedef _Ios_Seekdir seekdir;\n+    static const seekdir beg = \t\tseekdir(0);\n+    static const seekdir cur = \t\tseekdir(SEEK_CUR);\n+    static const seekdir end = \t\tseekdir(SEEK_END);\n+\n+#ifdef _GLIBCPP_DEPRICATED\n+    typedef int io_state;\n+    typedef int open_mode;\n+    typedef int seek_dir;\n+#endif\n+\n+    // Callbacks;\n+    enum event\n+    {\n+      erase_event,\n+      imbue_event,\n+      copyfmt_event\n+    };\n+\n+    typedef void (*event_callback) (event, ios_base&, int);\n+\n+    void \n+    register_callback(event_callback __fn, int __index);\n+\n+  protected:\n+    // Data Members\n+    streamsize \t\t_M_precision;\n+    streamsize \t\t_M_width;\n+    fmtflags \t\t_M_flags;\n+\n+     // 27.4.2.6  Members for callbacks\n+    // 27.4.2.6  ios_base callbacks\n+\n+    struct _Callback_list\n+    {\n+      // Data Members\n+      _Callback_list* \t\t_M_next;\n+      ios_base::event_callback \t_M_fn;\n+      int \t\t\t_M_index;\n+      int \t\t\t_M_refcount;  // 0 means one reference.\n+    \n+      _Callback_list(ios_base::event_callback __fn, int __index, \n+\t\t     _Callback_list* __cb)\n+      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }\n+      \n+      void \n+      _M_add_reference() { ++_M_refcount; } // XXX MT\n+      \n+      int \n+      _M_remove_reference() { return _M_refcount--; }  // 0 => OK to delete\n+    };\n+\n+     _Callback_list*  \t_M_callbacks;\n+\n+    void \n+    _M_call_callbacks(event __ev) throw();\n+\n+    void \n+    _M_dispose_callbacks(void);\n+\n+   // 27.4.2.5  Members for iword/pword storage\n+    struct _Words \n+    { \n+      void* \t_M_pword; \n+      long \t_M_iword; \n+    };\n+\n+    static const int \t_S_local_words = 8;\n+    _Words  \t\t_M_word_array[_S_local_words];  // Guaranteed storage\n+    _Words  \t\t_M_dummy;    // Only for failed iword/pword calls.\n+    _Words* \t\t_M_words;\n+    int     \t\t_M_word_limit;\n+ \n+    _Words& \n+    _M_grow_words(int __index);\n+\n+    // Members for locale and locale caching.\n+    locale \t\t_M_ios_locale;\n+\n+    void \n+    _M_init();\n+\n+  public:\n+    // 27.4.2.1.6  Class ios_base::Init\n+    // Used to initialize standard streams. In theory, g++ could use\n+    // -finit-priority to order this stuff correctly without going\n+    // through these machinations. \n+\n+    class Init \n+    {\n+      friend class ios_base;\n+    public:\n+      Init();\n+      ~Init();\n+    private:\n+      static int \t_S_ios_base_init;\n+      filebuf* \t\t_M_cout;\n+      filebuf* \t\t_M_cin;\n+      filebuf* \t\t_M_cerr;\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+      wfilebuf* \t_M_wcout;\n+      wfilebuf*        \t_M_wcin;\n+      wfilebuf* \t_M_wcerr;\n+#endif\n+    };\n+\n+    // Fmtflags state:\n+    inline fmtflags \n+    flags() const { return _M_flags; }\n+\n+    inline fmtflags \n+    flags(fmtflags __fmtfl)\n+    { \n+      fmtflags __old = _M_flags; \n+      _M_flags = __fmtfl; \n+      return __old; \n+    }\n+\n+    inline fmtflags \n+    setf(fmtflags __fmtfl)\n+    { \n+      fmtflags __old = _M_flags; \n+      _M_flags |= __fmtfl; \n+      return __old; \n+    }\n+\n+    inline fmtflags \n+    setf(fmtflags __fmtfl, fmtflags __mask)\n+    {\n+      fmtflags __old = _M_flags;\n+      _M_flags &= ~__mask;\n+      _M_flags |= (__fmtfl & __mask);\n+      return __old;\n+    }\n+\n+    inline void \n+    unsetf(fmtflags __mask) { _M_flags &= ~__mask; }\n+\n+    inline streamsize \n+    precision() const { return _M_precision; }\n+\n+    inline streamsize \n+    precision(streamsize __prec)\n+    { \n+      streamsize __old = _M_precision; \n+      _M_precision = __prec; \n+      return __old; \n+    }\n+\n+    inline streamsize \n+    width() const { return _M_width; }\n+\n+    inline streamsize \n+    width(streamsize __wide)\n+    { \n+      streamsize __old = _M_width; \n+      _M_width = __wide; \n+      return __old; \n+    }\n+\n+    static bool \n+    sync_with_stdio(bool __sync = true);\n+\n+   // Locales:\n+    locale \n+    imbue(const locale& __loc);\n+\n+    inline locale \n+    getloc() const { return _M_ios_locale; }\n+\n+    // Storage:\n+    static int \n+    xalloc() throw();\n+\n+    inline long& \n+    iword(int __ix)\n+    {\n+      _Words& __word = (__ix < _M_word_limit) \n+\t\t\t? _M_words[__ix] : _M_grow_words(__ix);\n+      return __word._M_iword;\n+    }\n+\n+    inline void*& \n+    pword(int __ix)\n+    {\n+      _Words& __word = (__ix < _M_word_limit) \n+\t\t\t? _M_words[__ix] : _M_grow_words(__ix);\n+      return __word._M_pword;\n+    }\n+\n+    // Destructor\n+    ~ios_base();\n+\n+  protected:\n+    ios_base();\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+  private:\n+    ios_base(const ios_base&);\n+\n+    ios_base& \n+    operator=(const ios_base&);\n+#endif\n+  };\n+ \n+  // 27.4.5.1 fmtflags manipulators:\n+  inline ios_base& \n+  boolalpha(ios_base& __base)\n+  {\n+    __base.setf(ios_base::boolalpha);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  noboolalpha(ios_base& __base)\n+  {\n+    __base.unsetf(ios_base::boolalpha);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  showbase(ios_base& __base)\n+  {\n+    __base.setf(ios_base::showbase);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  noshowbase(ios_base& __base)\n+  {\n+    __base.unsetf(ios_base::showbase);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  showpoint(ios_base& __base)\n+  {\n+    __base.setf(ios_base::showpoint);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  noshowpoint(ios_base& __base)\n+  {\n+    __base.unsetf(ios_base::showpoint);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  showpos(ios_base& __base)\n+  {\n+    __base.setf(ios_base::showpos);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  noshowpos(ios_base& __base)\n+  {\n+    __base.unsetf(ios_base::showpos);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  skipws(ios_base& __base)\n+  {\n+    __base.setf(ios_base::skipws);\n+    return __base;\n+  }\n+  \n+  inline ios_base& \n+  noskipws(ios_base& __base)\n+  {\n+    __base.unsetf(ios_base::skipws);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  uppercase(ios_base& __base)\n+  {\n+    __base.setf(ios_base::uppercase);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  nouppercase(ios_base& __base)\n+  {\n+    __base.unsetf(ios_base::uppercase);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  unitbuf(ios_base& __base)\n+  {\n+     __base.setf(ios_base::unitbuf);      \n+     return __base;\n+  }\n+\n+  inline ios_base& \n+  nounitbuf(ios_base& __base)\n+  {\n+     __base.unsetf(ios_base::unitbuf);\n+     return __base;    \n+  }\n+\n+  // 27.4.5.2 adjustfield anipulators:\n+  inline ios_base& \n+  internal(ios_base& __base)\n+  {\n+     __base.setf(ios_base::internal, ios_base::adjustfield);\n+     return __base;    \n+  }\n+\n+  inline ios_base& \n+  left(ios_base& __base)\n+  {\n+    __base.setf(ios_base::left, ios_base::adjustfield);\n+    return __base;\n+  }\n+  \n+  inline ios_base& \n+  right(ios_base& __base)\n+  {\n+    __base.setf(ios_base::right, ios_base::adjustfield);\n+    return __base;\n+  }\n+  \n+  // 27.4.5.3 basefield anipulators:\n+  inline ios_base& \n+  dec(ios_base& __base)\n+  {\n+    __base.setf(ios_base::dec, ios_base::basefield);\n+    return __base;\n+  }\n+  \n+  inline ios_base& \n+  hex(ios_base& __base)\n+  {\n+    __base.setf(ios_base::hex, ios_base::basefield);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  oct(ios_base& __base)\n+  {\n+    __base.setf(ios_base::oct, ios_base::basefield);\n+    return __base;\n+  }\n+  \n+  // 27.4.5.4 floatfield anipulators:\n+  inline ios_base& \n+  fixed(ios_base& __base)\n+  {\n+    __base.setf(ios_base::fixed, ios_base::floatfield);\n+    return __base;\n+  }\n+\n+  inline ios_base& \n+  scientific(ios_base& __base)\n+  {\n+    __base.setf(ios_base::scientific, ios_base::floatfield);\n+    return __base;\n+  }\n+\n+} // namespace std\n+\n+#endif /* _CPP_BITS_IOSBASE_H */\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "8ad2de04862bd9b1b0819af63e6114a39d41088b", "filename": "libstdc++-v3/include/bits/istream.tcc", "status": "added", "additions": 1216, "deletions": 0, "changes": 1216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,1216 @@\n+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.6.2  Output streams\n+//\n+\n+#include <bits/std_locale.h>\n+\n+namespace std {\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>::sentry::\n+    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskipws)\n+    {\n+      if (__in.good()) \n+\t{\n+\t  if (__in.tie())\n+\t    __in.tie()->flush();\n+\t  if (!__noskipws && (__in.flags() & ios_base::skipws))\n+\t    {\t  \n+\t      const __int_type __eof = traits_type::eof();\n+\t      __int_type __c = __int_type(0);\n+\t      __streambuf_type* __sb = __in.rdbuf();\n+\t      const __ctype_type* __ctype = __in._M_get_fctype_ios();\n+\t      bool __testsp = true;\n+\t      bool __testeof = false;\n+\t      \n+\t      while (!__testeof && __testsp)\n+\t\t{\n+\t\t  __c = __sb->sbumpc();\n+\t\t  __testeof = __c == __eof;\n+\t\t  __testsp = __ctype->is(ctype_base::space, __c);\n+\t\t}\n+\t      \n+\t      if (!__testeof && !__testsp)\n+\t\t__sb->sputbackc(__c);\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+//195.  Should basic_istream::sentry's constructor ever set eofbit? \n+\t      else\n+\t\t__in.setstate(ios_base::eofbit);\n+#endif\n+\t    }\n+\t}\n+      _M_ok = __in.good();\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(__istream_type& (*__pf)(__istream_type&))\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    __pf(*this);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(__ios_type& (*__pf)(__ios_type&))\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    __pf(*this);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(ios_base& (*__pf)(ios_base&))\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    __pf(*this);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(bool& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(short& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(unsigned short& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(int& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(unsigned int& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(long& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(unsigned long& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(long long& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(unsigned long long& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+#endif\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(float& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(double& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(long double& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(void*& __n)\n+    {\n+      sentry __cerb(*this, false);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    iostate __err = iostate(ios_base::goodbit);\n+\t    _M_fnumget->get(*this, 0, *this, __err, __n);\n+\t    this->setstate(__err);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>& \n+    basic_istream<_CharT, _Traits>::\n+    operator>>(__streambuf_type* __sbout)\n+    {\n+      streamsize __xtrct = 0;\n+      __streambuf_type* __sbin = this->rdbuf();\n+      sentry __cerb(*this, false);\n+      if (__sbout && __cerb)\n+\t__xtrct = _S_copy_streambufs(*this, __sbin, __sbout);\n+      if (!__sbout || !__xtrct)\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>::int_type\n+    basic_istream<_CharT, _Traits>::\n+    get(void)\n+    {\n+      const int_type __eof = traits_type::eof();\n+      int_type __c = __eof;\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    __c = this->rdbuf()->sbumpc();\n+\t    // 27.6.1.1 paragraph 3\n+\t    if (__c != __eof)\n+\t      _M_gcount = 1;\n+\t    else\n+\t      this->setstate(ios_base::eofbit | ios_base::failbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return __c;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    get(char_type& __c)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+ \t  try {\n+\t    const int_type __eof = traits_type::eof();\n+\t    int_type __bufval = this->rdbuf()->sbumpc();\n+\t    // 27.6.1.1 paragraph 3\n+\t    if (__bufval != __eof)\n+\t      {\n+\t\t_M_gcount = 1;\n+\t\t__c = traits_type::to_char_type(__bufval);\n+\t      }\n+\t    else\n+\t      this->setstate(ios_base::eofbit | ios_base::failbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    get(char_type* __s, streamsize __n, char_type __delim)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb && __n > 1) \n+\t{\n+\t  try {\n+\t    const int_type __idelim = traits_type::to_int_type(__delim);\n+\t    const int_type __eof = traits_type::eof();\n+\t    __streambuf_type* __sb = this->rdbuf();\n+\t    int_type __c = __sb->sbumpc();\t\n+\t    bool __testdelim = __c == __idelim;\n+\t    bool __testeof =  __c == __eof;\n+\t    \n+\t    while (_M_gcount < __n - 1 && !__testeof && !__testdelim)\n+\t      {\n+\t\t*__s++ = traits_type::to_char_type(__c);\n+\t\t++_M_gcount;\n+\t\t__c = __sb->sbumpc();\n+\t\t__testeof = __c == __eof;\n+\t\t__testdelim = __c == __idelim;\n+\t      }\n+\t    if (__testdelim || _M_gcount == __n - 1)\n+\t      __sb->sputbackc(__c);\n+\t    if (__testeof)\n+\t      this->setstate(ios_base::eofbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      *__s = char_type(NULL);\n+      if (!_M_gcount)\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    get(__streambuf_type& __sb, char_type __delim)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  int_type __c;\n+\t  __streambuf_type* __this_sb = this->rdbuf();\n+\t  try {\n+\t    const int_type __idelim = traits_type::to_int_type(__delim);\n+\t    const int_type __eof = traits_type::eof();\t      \n+\t    __c = __this_sb->sbumpc();\n+\t    bool __testdelim = __c == __idelim;\n+\t    bool __testeof =  __c == __eof;\n+\t    bool __testput = true;\n+\t    streamsize __n = __this_sb->in_avail();\n+\n+\t    while (_M_gcount <= __n && !__testeof && !__testdelim \n+\t\t   && (__testput = __sb.sputc(traits_type::to_char_type(__c)) \n+\t\t                   != __eof))\n+\t      {\n+\t\t++_M_gcount;\n+\t\t__c = __this_sb->sbumpc();\n+\t\t__testeof = __c == __eof;\n+\t\t__testdelim = __c == __idelim;\n+\t      }\n+\t    if (__testdelim || !__testput)\n+\t      __this_sb->sputbackc(traits_type::to_char_type(__c));\n+\t    if (__testeof)\n+\t      this->setstate(ios_base::eofbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // Exception may result from sputc->overflow.\n+\t    __this_sb->sputbackc(traits_type::to_char_type(__c));\n+\t  }\n+\t}\n+      if (!_M_gcount)\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    getline(char_type* __s, streamsize __n, char_type __delim)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+          try {\n+\t    __streambuf_type* __sb = this->rdbuf();\n+\t    int_type __c = __sb->sbumpc();\n+\t    ++_M_gcount;\n+            const int_type __idelim = traits_type::to_int_type(__delim);\n+            const int_type __eof = traits_type::eof();\n+\t    bool __testdelim = __c == __idelim;\n+\t    bool __testeof =  __c == __eof;\n+\t    \n+\t    while (_M_gcount < __n && !__testeof && !__testdelim)\n+\t      {\n+\t\t*__s++ = traits_type::to_char_type(__c);\n+\t\t__c = __sb->sbumpc();\n+\t\t++_M_gcount;\n+\t\t__testeof = __c == __eof;\n+\t\t__testdelim = __c == __idelim;\n+\t      }\n+\t    \n+\t    if (__testeof)\n+\t      {\n+\t\t--_M_gcount;\n+\t\tthis->setstate(ios_base::eofbit);\n+\t      }\n+\t    else if (!__testdelim)\n+\t      {\n+\t\t--_M_gcount;\n+\t\t__sb->sputbackc(traits_type::to_char_type(__c));\n+\t\tthis->setstate(ios_base::failbit);\n+\t      }\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      *__s = char_type(NULL);\n+      if (!_M_gcount)\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    ignore(streamsize __n, int_type __delim)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb && __n > 0) \n+\t{\n+\t  try {\n+\t    const int_type __idelim = traits_type::to_int_type(__delim);\n+\t    const int_type __eof = traits_type::eof();\n+\t    __streambuf_type* __sb = this->rdbuf();\n+\t    int_type __c = __sb->sbumpc();\t\n+\t    bool __testdelim = __c == __idelim;\n+\t    bool __testeof =  __c == __eof;\n+\t    \t\t\n+\t    __n = min(__n, numeric_limits<streamsize>::max());\n+\t    while (_M_gcount < __n - 1 && !__testeof && !__testdelim)\n+\t      {\n+\t\t++_M_gcount;\n+\t\t__c = __sb->sbumpc();\n+\t\t__testeof = __c == __eof;\n+\t\t__testdelim = __c == __idelim;\n+\t      }\n+\t    if ((_M_gcount == __n - 1 && !__testeof) || __testdelim)\n+\t      ++_M_gcount;\n+\t    if (__testeof)\n+\t      this->setstate(ios_base::eofbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>::int_type\n+    basic_istream<_CharT, _Traits>::\n+    peek(void)\n+    {\n+      int_type __c = traits_type::eof();\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb)\n+\t{\n+\t  try {\n+\t    __c = this->rdbuf()->sgetc();\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t} \n+      return __c;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    read(char_type* __s, streamsize __n)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  if (__n > 0)\n+\t    {\n+\t      try {\n+\t\tconst int_type __eof = traits_type::eof();\n+\t\t__streambuf_type* __sb = this->rdbuf();\n+\t\tint_type __c = __sb->sbumpc();\t\n+\t\tbool __testeof =  __c == __eof;\n+\t\t\n+\t\twhile (_M_gcount < __n - 1 && !__testeof)\n+\t\t  {\n+\t\t    *__s++ = traits_type::to_char_type(__c);\n+\t\t    ++_M_gcount;\n+\t\t    __c = __sb->sbumpc();\n+\t\t    __testeof = __c == __eof;\n+\t\t  }\n+\t\tif (__testeof)\n+\t\t  this->setstate(ios_base::eofbit | ios_base::failbit);\n+\t\telse\n+\t\t  {\n+\t\t    // _M_gcount == __n - 1\n+\t\t    *__s++ = traits_type::to_char_type(__c);\n+\t\t    ++_M_gcount;\n+\t\t  }\t    \n+\t      }\n+\t      catch(exception& __fail){\n+\t\t// 27.6.1.3 paragraph 1\n+\t\t// Turn this on without causing an ios::failure to be thrown.\n+\t\tthis->setstate(ios_base::badbit);\n+\t\tif ((this->exceptions() & ios_base::badbit) != 0)\n+\t\t  throw;\n+\t      }\n+\t    }\n+\t}\n+      else\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    streamsize \n+    basic_istream<_CharT, _Traits>::\n+    readsome(char_type* __s, streamsize __n)\n+    {\n+      const int_type __eof = traits_type::eof();\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  if (__n > 0)\n+\t    {\n+\t      try {\n+\t\tstreamsize __num = this->rdbuf()->in_avail();\n+\t\tif (__num != static_cast<streamsize>(__eof))\n+\t\t  {\n+\t\t    __num = min(__num, __n);\n+\t\t    _M_gcount = this->rdbuf()->sgetn(__s, __num);\n+\t\t  }\n+\t\telse\n+\t\t  this->setstate(ios_base::eofbit);\t\t    \n+\t      }\n+\n+\t      catch(exception& __fail){\n+\t\t// 27.6.1.3 paragraph 1\n+\t\t// Turn this on without causing an ios::failure to be thrown.\n+\t\tthis->setstate(ios_base::badbit);\n+\t\tif ((this->exceptions() & ios_base::badbit) != 0)\n+\t\t  throw;\n+\t      }\n+\t    }\n+\t}\n+      else\n+\tthis->setstate(ios_base::failbit);\n+      return _M_gcount;\n+    }\n+      \n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    putback(char_type __c)\n+    {\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    const int_type __eof = traits_type::eof();\n+\t    __streambuf_type* __sb = this->rdbuf();\n+\t    if (!__sb || __sb->sputbackc(__c) == __eof) \n+\t      this->setstate(ios_base::badbit);\t\t    \n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      else\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    unget(void)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    const int_type __eof = traits_type::eof();\n+\t    __streambuf_type* __sb = this->rdbuf();\n+\t    if (!__sb || __eof == __sb->sungetc())\n+\t      this->setstate(ios_base::badbit);\t\t    \n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      else\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    int\n+    basic_istream<_CharT, _Traits>::\n+    sync(void)\n+    {\n+      int __ret = traits_type::eof();\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    __streambuf_type* __sb = this->rdbuf();\n+\t    if (!__sb || __ret == __sb->pubsync())\n+\t      this->setstate(ios_base::badbit);\t\t    \n+\t    else \n+\t      __ret = 0;\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return __ret;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    typename basic_istream<_CharT, _Traits>::pos_type\n+    basic_istream<_CharT, _Traits>::\n+    tellg(void)\n+    {\n+      pos_type __ret = pos_type(-1);\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return __ret;\n+    }\n+\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    seekg(pos_type __pos)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  try {\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+// 136.  seekp, seekg setting wrong streams?\n+\t    this->rdbuf()->pubseekpos(__pos, ios_base::in);\n+#endif\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    basic_istream<_CharT, _Traits>::\n+    seekg(off_type __off, ios_base::seekdir __dir)\n+    {\n+      _M_gcount = 0;\n+      sentry __cerb(*this, true);\n+      if (__cerb) \n+\t{\n+\t  try {\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+// 136.  seekp, seekg setting wrong streams?\n+\t    this->rdbuf()->pubseekoff(__off, __dir, ios_base::in);\n+#endif\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.3 paragraph 1\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  // 27.6.1.2.3 Character extraction templates\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)\n+    {\n+      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n+      __istream_type::sentry __cerb(__in, false);\n+      if (__cerb)\n+\t{\n+\t  try {\n+\t    __in.get(__c);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    __in.setstate(ios_base::badbit);\n+\t    if ((__in.exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      else\n+\t__in.setstate(ios_base::failbit);\n+      return __in;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)\n+    {\n+      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n+      typedef typename __istream_type::__streambuf_type __streambuf_type;\n+      typedef typename _Traits::int_type \t\tint_type;\n+      typedef _CharT                     \t\tchar_type;\n+      typedef ctype<_CharT>     \t\t\t__ctype_type;\n+      int_type __extracted = 0;\n+\n+      __istream_type::sentry __cerb(__in, false);\n+      if (__cerb)\n+\t{\n+\t  try {\n+\t    // Figure out how many characters to extract.\n+\t    int_type __num = static_cast<int_type>(__in.width());\n+\t    if (__num <= 0)\n+\t      __num = basic_string<_CharT, _Traits>::npos;\n+\n+\t    __streambuf_type* __sb = __in.rdbuf();\n+\t    const __ctype_type* __ctype = __in._M_get_fctype_ios();\n+\t    int_type __c = __sb->sbumpc();\n+\t    const int_type __eof = _Traits::eof();\n+\t    bool __testsp = __ctype->is(ctype_base::space, __c);\n+\t    bool __testeof =  __c == __eof;\n+\t    \n+\t    while (__extracted < __num - 1 && !__testeof && !__testsp)\n+\t      {\n+\t\t*__s++ = __c;\n+\t\t++__extracted;\n+\t\t__c = __sb->sbumpc();\n+\t\t__testeof = __c == __eof;\n+\t\t__testsp = __ctype->is(ctype_base::space, __c);\n+\t      }\n+\t    \n+\t    if (!__testeof)\n+\t      __sb->sputbackc(__c);\n+\t    else\n+\t      __in.setstate(ios_base::eofbit);\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+//68.  Extractors for char* should store null at end\n+\t    *__s = char_type();\n+#endif\n+\t    __in.width(0);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    __in.setstate(ios_base::badbit);\n+\t    if ((__in.exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      if (!__extracted)\n+\t__in.setstate(ios_base::failbit);\n+      return __in;\n+    }\n+\n+  // 27.6.1.4 Standard basic_istream manipulators\n+  template<typename _CharT, typename _Traits>\n+    basic_istream<_CharT,_Traits>& \n+    ws(basic_istream<_CharT,_Traits>& __in)\n+    {\n+      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n+      typedef typename __istream_type::__streambuf_type __streambuf_type;\n+      typedef typename __istream_type::__ctype_type \t__ctype_type;\n+      typedef typename __istream_type::int_type \t__int_type;\n+      typedef typename __istream_type::char_type \t__char_type;\n+\n+      __streambuf_type* __sb = __in.rdbuf();\n+      const __ctype_type* __ctype = __in._M_get_fctype_ios();\n+      const __int_type __eof = _Traits::eof();\t      \n+      __int_type __c;\n+      bool __testeof;\n+      bool __testsp;\n+\n+      do \n+\t{\n+\t  __c = __sb->sbumpc();\n+\t  __testeof = __c == __eof;\n+\t  __testsp = __ctype->is(ctype_base::space, __c);\n+\t}\n+      while (!__testeof && __testsp);\n+\n+      if (!__testeof && !__testsp)\n+\t__sb->sputbackc(__c);\n+      else\n+\t__in.setstate(ios_base::eofbit);\n+\n+      return __in;\n+    }\n+\n+  // 21.3.7.8 basic_string::getline and operators\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_istream<_CharT, _Traits>&\n+    operator>>(basic_istream<_CharT, _Traits>& __in,\n+\t       basic_string<_CharT, _Traits, _Alloc>& __str)\n+    {\n+      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n+      typedef typename __istream_type::int_type \t__int_type;\n+      typedef typename __istream_type::__streambuf_type __streambuf_type;\n+      typedef typename __istream_type::__ctype_type \t__ctype_type;\n+      typedef basic_string<_CharT, _Traits, _Alloc> \t__string_type;\n+      typedef typename __string_type::size_type\t\t__size_type;\n+      __int_type __extracted = 0;\n+\n+      __istream_type::sentry __cerb(__in, false);\n+      if (__cerb) \n+\t{\n+\t  __str.erase();\n+\t  streamsize __w = __in.width();\n+\t  __size_type __n;\n+\t  __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();\n+\n+\t  __streambuf_type* __sb = __in.rdbuf();\n+\t  const __ctype_type* __ctype = __in._M_get_fctype_ios();\n+\t  __int_type __c = __sb->sbumpc();\n+\t  const __int_type __eof = _Traits::eof();\n+\t  bool __testsp = __ctype->is(ctype_base::space, __c);\n+\t  bool __testeof =  __c == __eof;\n+\n+\t  while (__extracted <= __n && !__testeof && !__testsp)\n+\t    {\n+\t      __str += _Traits::to_char_type(__c);\n+\t      ++__extracted;\n+\t      __c = __sb->sbumpc();\n+\t      __testeof = __c == __eof;\n+\t      __testsp = __ctype->is(ctype_base::space, __c);\n+\t    }\n+\t  if (!__testeof)\n+\t    __sb->sputbackc(__c);\n+\t  else\n+\t    __in.setstate(ios_base::eofbit);\n+\t  __in.width(0);\n+\t}\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+// 2000-02-01 Number to be determined\n+      if (!__extracted)\n+\t__in.setstate (ios_base::failbit);\n+#endif\n+      return __in;\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_istream<_CharT, _Traits>&\n+    getline(basic_istream<_CharT, _Traits>& __in,\n+\t    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)\n+    {\n+      typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n+      typedef typename __istream_type::int_type \t__int_type;\n+      typedef typename __istream_type::__streambuf_type __streambuf_type;\n+      typedef typename __istream_type::__ctype_type \t__ctype_type;\n+      typedef basic_string<_CharT, _Traits, _Alloc> \t__string_type;\n+      typedef typename __string_type::size_type\t\t__size_type;\n+\n+      __size_type __extracted = 0;\n+      bool __testdelim = false;\n+      __istream_type::sentry __cerb(__in, true);\n+      if (__cerb) \n+\t{\n+\t  __str.erase();\n+\t  __size_type __n = __str.max_size();\n+\n+\t  __int_type __idelim = _Traits::to_int_type(__delim);\n+\t  __streambuf_type* __sb = __in.rdbuf();\n+\t  __int_type __c = __sb->sbumpc();\n+\t  const __int_type __eof = _Traits::eof();\n+\t  __testdelim = __c ==  __idelim;\n+\t  bool __testeof =  __c == __eof;\n+\n+\t  while (__extracted <= __n && !__testeof && !__testdelim)\n+\t    {\n+\t      __str += _Traits::to_char_type(__c);\n+\t      ++__extracted;\n+\t      __c = __sb->sbumpc();\n+\t      __testeof = __c == __eof;\n+\t      __testdelim = __c == __idelim;\n+\t    }\n+\t  if (__testeof)\n+\t    __in.setstate(ios_base::eofbit);\n+\t}\n+      if (!__extracted && !__testdelim)\n+\t__in.setstate(ios_base::failbit);\n+      return __in;\n+    }\n+\n+  template<class _CharT, class _Traits, class _Alloc>\n+    inline basic_istream<_CharT,_Traits>&\n+    getline(basic_istream<_CharT, _Traits>& __in, \n+\t    basic_string<_CharT,_Traits,_Alloc>& __str)\n+    { return getline(__in, __str, __in.widen('\\n')); }\n+\n+} // namespace std\n+\n+// Local Variables:\n+// mode:C++\n+// End:\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "45fcccb12dc2478acf2fec3c089d6484fef64550", "filename": "libstdc++-v3/include/bits/limits_generic.h", "status": "added", "additions": 786, "deletions": 0, "changes": 786, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flimits_generic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flimits_generic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flimits_generic.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,786 @@\n+// The template and inlines for the -*- C++ -*- numeric_limits classes.\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Note: this is not a conforming implementation.\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@cmla.ens-cachan.fr>\n+\n+//\n+// ISO 14882:1998\n+// 18.2.1\n+//\n+\n+#ifndef _CPP_NUMERIC_LIMITS\n+#define _CPP_NUMERIC_LIMITS 1\n+\n+#include <bits/c++config.h>\n+#include <bits/std_cfloat.h>\n+#include <bits/std_climits.h>\n+#if defined( _GLIBCPP_USE_WCHAR_T) \n+#include <bits/std_cwchar.h>\n+#endif\n+\n+namespace std {\n+\n+    enum float_round_style {\n+        round_indeterminate       = -1,\n+        round_toward_zero         = 0,\n+        round_to_nearest          = 1,\n+        round_toward_infinity     = 2,\n+        round_toward_neg_infinity = 3\n+    };\n+\n+    enum float_denorm_style {\n+        denorm_indeterminate = -1,\n+        denorm_absent        = 0,\n+        denorm_present       = 1\n+    };\n+\n+    template<typename _T> struct numeric_limits {\n+        static const bool is_specialized = false;\n+\n+        static _T min() throw() { return static_cast<_T>(0); }\n+        static _T max() throw() { return static_cast<_T>(0); }\n+\n+        static const int digits = 0;\n+        static const int digits10 = 0;\n+        static const bool is_signed = false;\n+        static const bool is_integer = false;\n+        static const bool is_exact = false;\n+        static const int radix = 0;\n+\n+        static _T epsilon() throw() { return static_cast<_T>(0); }\n+        static _T round_error() throw() { return static_cast<_T>(0); }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static _T infinity() throw()  { return static_cast<_T>(0); }\n+        static _T quiet_NaN() throw() { return static_cast<_T>(0); }\n+        static _T signaling_NaN() throw() { return static_cast<_T>(0); }\n+        static _T denorm_min() throw() { return static_cast<_T>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = false;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<typename _T> _T __limits_infinity();\n+    template<typename _T> _T __limits_quiet_NaN();\n+    template<typename _T> _T __limits_signaling_NaN();\n+    template<typename _T> _T __limits_denorm_min();\n+\n+    template<> struct numeric_limits<bool> {\n+        static const bool is_specialized = true;\n+\n+        static bool min() throw()\n+        { return false; }\n+        static bool max() throw()\n+        { return true; }\n+\n+        static const int digits = 8;\n+        static const int digits10 = 2;\n+        static const bool is_signed = false;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static bool epsilon() throw()\n+        { return 0; }\n+        static bool round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static bool infinity() throw()\n+        { return static_cast<bool>(0); }\n+        static bool quiet_NaN() throw()\n+        { return static_cast<bool>(0); }\n+        static bool signaling_NaN() throw()\n+        { return static_cast<bool>(0); }\n+        static bool denorm_min() throw()\n+        { return static_cast<bool>(0); }\n+\n+        static const bool is_iec559 = true;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = true;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<char> {\n+        static const bool is_specialized = true;\n+\n+        static char min() throw()\n+        { return CHAR_MIN; }\n+        static char max() throw()\n+        { return CHAR_MAX; }\n+\n+        static const int digits = 7;\n+        static const int digits10 = 2;\n+        static const bool is_signed = true;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static char epsilon() throw()\n+        { return 0; }\n+        static char round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static char infinity() throw()\n+        { return static_cast<char>(0); }\n+        static char quiet_NaN() throw()\n+        { return static_cast<char>(0); }\n+        static char signaling_NaN() throw()\n+        { return static_cast<char>(0); }\n+        static char denorm_min() throw()\n+        { return static_cast<char>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<signed char> {\n+        static const bool is_specialized = true;\n+\n+        static signed char min() throw()\n+        { return SCHAR_MIN; }\n+        static signed char max() throw()\n+        { return SCHAR_MAX; }\n+\n+        static const int digits = 7;\n+        static const int digits10 = 2;\n+        static const bool is_signed = true;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static signed char epsilon() throw()\n+        { return 0; }\n+        static signed char round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static signed char infinity() throw()\n+        { return static_cast<signed char>(0); }\n+        static signed char quiet_NaN() throw()\n+        { return static_cast<signed char>(0); }\n+        static signed char signaling_NaN() throw()\n+        { return static_cast<signed char>(0); }\n+        static signed char denorm_min() throw()\n+        { return static_cast<signed char>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<unsigned char> {\n+        static const bool is_specialized = true;\n+\n+        static unsigned char min() throw()\n+        { return 0; }\n+        static unsigned char max() throw()\n+        { return UCHAR_MAX; }\n+\n+        static const int digits = 8;\n+        static const int digits10 = 2;\n+        static const bool is_signed = false;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static unsigned char epsilon() throw()\n+        { return 0; }\n+        static unsigned char round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static unsigned char infinity() throw()\n+        { return static_cast<unsigned char>(0); }\n+        static unsigned char quiet_NaN() throw()\n+        { return static_cast<unsigned char>(0); }\n+        static unsigned char signaling_NaN() throw()\n+        { return static_cast<unsigned char>(0); }\n+        static unsigned char denorm_min() throw()\n+        { return static_cast<unsigned char>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = true;\n+\n+        static const bool traps = true;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+#if defined( _GLIBCPP_USE_WCHAR_T) \n+    template<> struct numeric_limits<wchar_t> {\n+        static const bool is_specialized = true;\n+\n+        static wchar_t min() throw()\n+        { return WCHAR_MIN; }\n+        static wchar_t max() throw()\n+        { return WCHAR_MAX; }\n+\n+        static const int digits = 31;\n+        static const int digits10 = 9;\n+        static const bool is_signed = true;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static wchar_t epsilon() throw()\n+        { return 0; }\n+        static wchar_t round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static wchar_t infinity() throw()\n+        { return static_cast<wchar_t>(0); }\n+        static wchar_t quiet_NaN() throw()\n+        { return static_cast<wchar_t>(0); }\n+        static wchar_t signaling_NaN() throw()\n+        { return static_cast<wchar_t>(0); }\n+        static wchar_t denorm_min() throw()\n+        { return static_cast<wchar_t>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+#endif\n+\n+    template<> struct numeric_limits<short> {\n+        static const bool is_specialized = true;\n+\n+        static short min() throw()\n+        { return SHRT_MIN; }\n+        static short max() throw()\n+        { return SHRT_MAX; }\n+\n+        static const int digits = 15;\n+        static const int digits10 = 4;\n+        static const bool is_signed = true;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static short epsilon() throw()\n+        { return 0; }\n+        static short round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static short infinity() throw()\n+        { return static_cast<short>(0); }\n+        static short quiet_NaN() throw()\n+        { return static_cast<short>(0); }\n+        static short signaling_NaN() throw()\n+        { return static_cast<short>(0); }\n+        static short denorm_min() throw()\n+        { return static_cast<short>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<unsigned short> {\n+        static const bool is_specialized = true;\n+\n+        static unsigned short min() throw()\n+        { return 0; }\n+        static unsigned short max() throw()\n+        { return USHRT_MAX; }\n+\n+        static const int digits = 16;\n+        static const int digits10 = 4;\n+        static const bool is_signed = false;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static unsigned short epsilon() throw()\n+        { return 0; }\n+        static unsigned short round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static unsigned short infinity() throw()\n+        { return static_cast<unsigned short>(0); }\n+        static unsigned short quiet_NaN() throw()\n+        { return static_cast<unsigned short>(0); }\n+        static unsigned short signaling_NaN() throw()\n+        { return static_cast<unsigned short>(0); }\n+        static unsigned short denorm_min() throw()\n+        { return static_cast<unsigned short>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = true;\n+\n+        static const bool traps = true;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<int> {\n+        static const bool is_specialized = true;\n+\n+        static int min() throw()\n+        { return INT_MIN; }\n+        static int max() throw()\n+        { return INT_MAX; }\n+\n+        static const int digits = 31;\n+        static const int digits10 = 9;\n+        static const bool is_signed = true;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static int epsilon() throw()\n+        { return 0; }\n+        static int round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static int infinity() throw()\n+        { return static_cast<int>(0); }\n+        static int quiet_NaN() throw()\n+        { return static_cast<int>(0); }\n+        static int signaling_NaN() throw()\n+        { return static_cast<int>(0); }\n+        static int denorm_min() throw()\n+        { return static_cast<int>(0); }\n+\n+        static const bool is_iec559 = true;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<unsigned int> {\n+        static const bool is_specialized = true;\n+\n+        static unsigned int min() throw()\n+        { return 0; }\n+        static unsigned int max() throw()\n+        { return UINT_MAX; }\n+\n+        static const int digits = 32;\n+        static const int digits10 = 9;\n+        static const bool is_signed = false;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static unsigned int epsilon() throw()\n+        { return 0; }\n+        static unsigned int round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static unsigned int infinity() throw()\n+        { return static_cast<unsigned int>(0); }\n+        static unsigned int quiet_NaN() throw()\n+        { return static_cast<unsigned int>(0); }\n+        static unsigned int signaling_NaN() throw()\n+        { return static_cast<unsigned int>(0); }\n+        static unsigned int denorm_min() throw()\n+        { return static_cast<unsigned int>(0); }\n+\n+        static const bool is_iec559 = true;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = true;\n+\n+        static const bool traps = true;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<long> {\n+        static const bool is_specialized = true;\n+\n+        static long min() throw()\n+        { return LONG_MIN; }\n+        static long max() throw()\n+        { return LONG_MAX; }\n+\n+        static const int digits = 31;\n+        static const int digits10 = 9;\n+        static const bool is_signed = true;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static long epsilon() throw()\n+        { return 0; }\n+        static long round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static long infinity() throw()\n+        { return static_cast<long>(0); }\n+        static long quiet_NaN() throw()\n+        { return static_cast<long>(0); }\n+        static long signaling_NaN() throw()\n+        { return static_cast<long>(0); }\n+        static long denorm_min() throw()\n+        { return static_cast<long>(0); }\n+\n+        static const bool is_iec559 = true;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<unsigned long> {\n+        static const bool is_specialized = true;\n+\n+        static unsigned long min() throw()\n+        { return 0; }\n+        static unsigned long max() throw()\n+        { return ULONG_MAX; }\n+\n+        static const int digits = 32;\n+        static const int digits10 = 9;\n+        static const bool is_signed = false;\n+        static const bool is_integer = true;\n+        static const bool is_exact = true;\n+        static const int radix = 2;\n+        static unsigned long epsilon() throw()\n+        { return 0; }\n+        static unsigned long round_error() throw()\n+        { return 0; }\n+\n+        static const int min_exponent = 0;\n+        static const int min_exponent10 = 0;\n+        static const int max_exponent = 0;\n+        static const int max_exponent10 = 0;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static unsigned long infinity() throw()\n+        { return static_cast<unsigned long>(0); }\n+        static unsigned long quiet_NaN() throw()\n+        { return static_cast<unsigned long>(0); }\n+        static unsigned long signaling_NaN() throw()\n+        { return static_cast<unsigned long>(0); }\n+        static unsigned long denorm_min() throw()\n+        { return static_cast<unsigned long>(0); }\n+\n+        static const bool is_iec559 = true;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = true;\n+\n+        static const bool traps = true;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<float> {\n+        static const bool is_specialized = true;\n+\n+        static float min() throw()\n+        { return FLT_MIN; }\n+        static float max() throw()\n+        { return FLT_MAX; }\n+\n+        static const int digits = FLT_MANT_DIG;\n+        static const int digits10 = FLT_DIG;\n+        static const bool is_signed = true;\n+        static const bool is_integer = false;\n+        static const bool is_exact = false;\n+        static const int radix = FLT_RADIX;\n+        static float epsilon() throw()\n+        { return FLT_EPSILON; }\n+        static float round_error() throw()\n+        { return FLT_ROUNDS; }\n+\n+        static const int min_exponent = FLT_MIN_EXP;\n+        static const int min_exponent10 = FLT_MIN_10_EXP;\n+        static const int max_exponent = FLT_MAX_EXP;\n+        static const int max_exponent10 = FLT_MAX_10_EXP;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static float infinity() throw()\n+        { return static_cast<float>(0); }\n+        static float quiet_NaN() throw()\n+        { return static_cast<float>(0); }\n+        static float signaling_NaN() throw()\n+        { return static_cast<float>(0); }\n+        static float denorm_min() throw()\n+        { return static_cast<float>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<double> {\n+        static const bool is_specialized = true;\n+\n+        static double min() throw()\n+        { return DBL_MIN; }\n+        static double max() throw()\n+        { return DBL_MAX; }\n+\n+        static const int digits = DBL_MANT_DIG;\n+        static const int digits10 = DBL_DIG;\n+        static const bool is_signed = true;\n+        static const bool is_integer = false;\n+        static const bool is_exact = false;\n+        static const int radix = 2;\n+        static double epsilon() throw()\n+        { return DBL_EPSILON; }\n+        static double round_error() throw()\n+        { return 1.0; }\n+\n+        static const int min_exponent = DBL_MIN_EXP;\n+        static const int min_exponent10 = DBL_MIN_10_EXP;\n+        static const int max_exponent = DBL_MAX_EXP;\n+        static const int max_exponent10 = DBL_MAX_10_EXP;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static double infinity() throw()\n+        { return static_cast<double>(0); }\n+        static double quiet_NaN() throw()\n+        { return static_cast<double>(0); }\n+        static double signaling_NaN() throw()\n+        { return static_cast<double>(0); }\n+        static double denorm_min() throw()\n+        { return static_cast<double>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+    template<> struct numeric_limits<long double> {\n+        static const bool is_specialized = true;\n+\n+        static double min() throw()\n+        { return LDBL_MIN; }\n+        static double max() throw()\n+        { return LDBL_MAX; }\n+\n+        static const int digits = LDBL_MANT_DIG;\n+        static const int digits10 = LDBL_DIG;\n+        static const bool is_signed = true;\n+        static const bool is_integer = false;\n+        static const bool is_exact = false;\n+        static const int radix = 2;\n+        static double epsilon() throw()\n+        { return LDBL_EPSILON; }\n+        static double round_error() throw()\n+        { return 1.0L; }\n+\n+        static const int min_exponent = LDBL_MIN_EXP;\n+        static const int min_exponent10 = LDBL_MIN_10_EXP;\n+        static const int max_exponent = LDBL_MAX_EXP;\n+        static const int max_exponent10 = LDBL_MAX_10_EXP;\n+\n+        static const bool has_infinity = false;\n+        static const bool has_quiet_NaN = false;\n+        static const bool has_signaling_NaN = false;\n+        static const float_denorm_style has_denorm = denorm_absent;\n+        static const bool has_denorm_loss = false;\n+\n+        static double infinity() throw()\n+        { return static_cast<double>(0); }\n+        static double quiet_NaN() throw()\n+        { return static_cast<double>(0); }\n+        static double signaling_NaN() throw()\n+        { return static_cast<double>(0); }\n+        static double denorm_min() throw()\n+        { return static_cast<double>(0); }\n+\n+        static const bool is_iec559 = false;\n+        static const bool is_bounded = true;\n+        static const bool is_modulo = false;\n+\n+        static const bool traps = false;\n+        static const bool tinyness_before = false;\n+        static const float_round_style round_style = round_toward_zero;\n+    };\n+\n+} // namespace std\n+\n+#endif // _CPP_NUMERIC_LIMITS"}, {"sha": "732eafce4cad1682f968e245ee854102362fcd73", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "added", "additions": 1733, "deletions": 0, "changes": 1733, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,1733 @@\n+// Locale support -*- C++ -*-\n+\n+// Copyright (C) 1997-2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 22.1  Locales\n+//\n+\n+// Warning: this file is not meant for user inclusion.  Use <locale>.\n+\n+#ifndef _CPP_BITS_LOCFACETS_H\n+#define _CPP_BITS_LOCFACETS_H\t1\n+\n+#include <bits/std_ctime.h>\t// For struct tm\n+#include <bits/std_typeinfo.h> \t// For bad_cast, which shouldn't be here.\n+#include <bits/std_ios.h>\t// For ios_base\n+#include <bits/std_cwctype.h>\t// For wctype_t\n+\n+namespace std\n+{\n+  // XXX This function is to be specialized for the \"required\" facets to \n+  // be constructed lazily.   The specializations must be declared after \n+  // the definitions of the facets themselves; but they shouldn't be \n+  // inline.  Corresponding new's in locale::classic() should then be \n+  // eliminated.  Note that ctype<> should not get this treatment; \n+  // see the use_facet<> specializations below.\n+  //\n+  struct _Bad_use_facet : public bad_cast \n+  {\n+    _Bad_use_facet() throw() {}\n+\n+    _Bad_use_facet(_Bad_use_facet const&  __b) throw() \n+    : bad_cast(__b) { }\n+\n+    _Bad_use_facet& \n+    operator=(_Bad_use_facet const& __b) throw() \n+    { \n+      static_cast<bad_cast*>(this)->operator=(__b); \n+      return *this; \n+    }\n+\n+    virtual char const* \n+    what() const throw();\n+\n+    virtual \n+    ~_Bad_use_facet() throw();\n+  };\n+\n+  template<typename _Facet>\n+    const _Facet& \n+    _Use_facet_failure_handler(const locale&)\n+    { throw _Bad_use_facet(); }\n+\n+  // 22.2.1  The ctype category\n+  // Include host-specific ctype enums for ctype_base.\n+  #include <bits/ctype_base.h>\n+\n+  // 22.2.1.1  Template class ctype\n+  // _Ctype_nois is the common base for ctype<char>.  It lacks \"do_is\"\n+  // and related virtuals.  These are filled in by _Ctype, below.\n+  template<typename _CharT>\n+    class _Ctype_nois : public locale::facet, public ctype_base\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT char_type;\n+\n+      char_type \n+      toupper(char_type __c) const\n+      { return this->do_toupper(__c); }\n+\n+      const char_type*\n+      toupper(char_type *__low, const char_type* __high) const\n+      { return this->do_toupper(__low, __high); }\n+\n+      char_type \n+      tolower(char_type __c) const\n+      { return this->do_tolower(__c); }\n+\n+      const char_type*\n+      tolower(char_type* __low, const char_type* __high) const\n+      { return this->do_tolower(__low, __high); }\n+\n+      char_type \n+      widen(char __c) const\n+      { return this->do_widen(__c); }\n+\n+      const char*\n+      widen(const char* __low, const char* __high, char_type* __to) const\n+      { return this->do_widen(__low, __high, __to); }\n+\n+      char \n+      narrow(char_type __c, char __dfault) const\n+      { return this->do_narrow(__c, __dfault); }\n+\n+      const char_type*\n+      narrow(const char_type* __low, const char_type* __high,\n+\t      char __dfault, char *__to) const\n+      { return this->do_narrow(__low, __high, __dfault, __to); }\n+\n+    protected:\n+      explicit \n+      _Ctype_nois(size_t __refs = 0): locale::facet(__refs) { }\n+\n+      virtual \n+      ~_Ctype_nois() { }\n+      \n+      virtual char_type \n+      do_toupper(char_type) const = 0;\n+\n+      virtual const char_type*\n+      do_toupper(char_type* __low, const char_type* __high) const = 0;\n+\n+      virtual char_type \n+      do_tolower(char_type) const = 0;\n+\n+      virtual const char_type*\n+      do_tolower(char_type* __low, const char_type* __high) const = 0;\n+      \n+      virtual char_type \n+      do_widen(char) const = 0;\n+\n+      virtual const char*\n+      do_widen(const char* __low, const char* __high,\n+\t       char_type* __dest) const = 0;\n+\n+      virtual char \n+      do_narrow(char_type, char __dfault) const = 0;\n+\n+      virtual const char_type*\n+      do_narrow(const char_type* __low, const char_type* __high,\n+\t\t char __dfault, char* __dest) const = 0;\n+    };\n+\n+\n+  template<typename _CharT>\n+    class _Ctype : public _Ctype_nois<_CharT>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT \t\t\t\t\tchar_type;\n+      typedef typename _Ctype_nois<_CharT>::mask \tmask;\n+\n+      bool \n+      is(mask __m, char_type __c) const\n+      { return this->do_is(__m, __c); }\n+\n+      const char_type*\n+      is(const char_type *__lo, const char_type *__hi, mask *__vec) const   \n+      { return this->do_is(__lo, __hi, __vec); }\n+\n+      const char_type*\n+      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const\n+      { return this->do_scan_is(__m, __lo, __hi); }\n+\n+      const char_type*\n+      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const\n+      { return this->do_scan_not(__m, __lo, __hi); }\n+\n+    protected:\n+      explicit \n+      _Ctype(size_t __refs = 0) : _Ctype_nois<_CharT>(__refs) { }\n+\n+      virtual \n+      ~_Ctype() { }\n+\n+      virtual bool \n+      do_is(mask __m, char_type __c) const = 0;\n+\n+      virtual const char_type*\n+      do_is(const char_type* __lo, const char_type* __hi, \n+\t    mask* __vec) const = 0;\n+\n+      virtual const char_type*\n+      do_scan_is(mask __m, const char_type* __lo, \n+\t\t const char_type* __hi) const = 0;\n+\n+      virtual const char_type*\n+      do_scan_not(mask __m, const char_type* __lo, \n+\t\t  const char_type* __hi) const = 0;\n+    };\n+\n+  template<typename _CharT>\n+    class ctype : public _Ctype<_CharT>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT \t\t\t\t\tchar_type;\n+      typedef typename ctype::mask \t\t\tmask;\n+\n+      explicit \n+      ctype(size_t __refs = 0) : _Ctype<_CharT>(__refs) { }\n+\n+      static locale::id id;\n+\n+   protected:\n+      virtual \n+      ~ctype() { }\n+\n+      virtual bool \n+      do_is(mask, char_type) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+\treturn true;\n+      }\n+\n+      virtual const char_type*\n+      do_is(const char_type*  __lo, const char_type*, mask*) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+\treturn __lo;\n+      }\n+\n+      virtual const char_type*\n+      do_scan_is(mask, const char_type* __lo, const char_type*) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+\treturn __lo;\n+      }\n+\n+      virtual const char_type*\n+      do_scan_not(mask, const char_type* __lo, const char_type*) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+\treturn __lo;\n+      }\n+\n+      virtual char_type \n+      do_toupper(char_type __c) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+\treturn __c;\n+      }\n+\n+      virtual const char_type*\n+      do_toupper(char_type* __lo, const char_type*) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+\treturn __lo;\n+      }\n+\n+      virtual char_type \n+      do_tolower(char_type __c) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+\treturn __c;\n+      }\n+\n+      virtual const char_type*\n+      do_tolower(char_type* __lo, const char_type*) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+\treturn __lo;\n+      }\n+      \n+      virtual char_type \n+      do_widen(char __c) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+\treturn __c;\n+      }\n+\n+      virtual const char*\n+      do_widen(const char* __lo, const char*, char_type*) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+\treturn __lo;\n+      }\n+\n+      virtual char \n+      do_narrow(char_type, char __c) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+\treturn __c;\n+      }\n+\n+      virtual const char_type*\n+      do_narrow(const char_type* __lo, const char_type*, char, char*) const\n+      {\n+\t// XXX Need definitions for these abstract mf's.\n+\treturn __lo;\n+      }\n+    };\n+\n+\n+  // 22.2.1.3  ctype specializations\n+  // NB: Can use _Ctype_nois to actually implement the \"is\"\n+  // functionality in the non-virtual (thus inline-able) member\n+  // fuctions.\n+  template<>\n+    class ctype<char> : public _Ctype_nois<char>\n+    {\n+    public:\n+      // Types:\n+      typedef char \t       char_type;\n+      typedef ctype::mask      mask;\n+\n+    private:\n+      // Data Members:\n+      bool \t\t       _M_del;\n+      __to_type const& \t       _M_toupper;\n+      __to_type const& \t       _M_tolower;\n+      const mask* const&       _M_ctable;\n+      const mask*       _M_table;\n+      \n+    public:\n+      static locale::id        id;\n+      static const size_t      table_size = 1 + static_cast<unsigned char>(-1);\n+\n+      explicit \n+      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);\n+\n+      inline bool \n+      is(mask __m, char __c) const throw();\n+ \n+      inline const char*\n+      is(const char* __low, const char* __high, mask* __vec) const throw();\n+ \n+      inline const char*\n+      scan_is(mask __m, const char* __low, const char* __high) const throw();\n+\n+      inline const char*\n+      scan_not(mask __m, const char* __low, const char* __high) const throw();\n+     \n+    protected:\n+      virtual \n+      ~ctype();\n+\n+      // XXX\n+      const mask* \n+      table() const throw()\n+      { return _M_table; }\n+\n+      // XXX\n+      const mask* \n+      classic_table() throw()\n+      { return _M_ctable; }\n+\n+      virtual char_type \n+      do_toupper(char_type) const;\n+\n+      virtual const char_type*\n+      do_toupper(char_type* __low, const char_type* __high) const;\n+\n+      virtual char_type \n+      do_tolower(char_type) const;\n+\n+      virtual const char_type*\n+      do_tolower(char_type* __low, const char_type* __high) const;\n+      \n+      virtual char_type \n+      do_widen(char) const;\n+\n+      virtual const char*\n+      do_widen(const char* __low, const char* __high,\n+\t       char_type* __dest) const;\n+\n+      virtual char \n+      do_narrow(char_type, char __dfault) const;\n+\n+      virtual const char_type*\n+      do_narrow(const char_type* __low, const char_type* __high,\n+\t\t char __dfault, char* __dest) const;\n+    };\n+ \n+  template<>\n+    const ctype<char>&\n+    use_facet<const ctype<char> >(const locale& __loc);\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  // ctype<wchar_t> specialization\n+  template<>\n+    class ctype<wchar_t> : public _Ctype<wchar_t>\n+    {\n+    public:\n+      // Types:\n+      typedef wchar_t \t       char_type;\n+      typedef ctype::mask      mask;\n+      typedef wctype_t\t       __wmask_type;\n+\n+      // Data Members:\n+      static locale::id        id;\n+\n+      explicit \n+      ctype(size_t __refs = 0);\n+\n+    protected:\n+      __wmask_type\n+      _M_convert_to_wmask(const mask __m) const\n+      {\n+\t__wmask_type __ret;\n+\tswitch (__m)\n+\t  {\n+\t  case space:\n+\t    __ret = wctype(\"space\");\n+\t    break;\n+\t  case print:\n+\t    __ret = wctype(\"print\");\n+\t    break;\n+\t  case cntrl:\n+\t    __ret = wctype(\"cntrl\");\n+\t    break;\n+\t  case upper:\n+\t    __ret = wctype(\"upper\");\n+\t    break;\n+\t  case lower:\n+\t    __ret = wctype(\"lower\");\n+\t    break;\n+\t  case alpha:\n+\t    __ret = wctype(\"alpha\");\n+\t    break;\n+\t  case digit:\n+\t    __ret = wctype(\"digit\");\n+\t    break;\n+\t  case punct:\n+\t    __ret = wctype(\"punct\");\n+\t    break;\n+\t  case xdigit:\n+\t    __ret = wctype(\"xdigit\");\n+\t    break;\n+\t  case alnum:\n+\t    __ret = wctype(\"alnum\");\n+\t    break;\n+\t  case graph:\n+\t    __ret = wctype(\"graph\");\n+\t    break;\n+\t  default:\n+\t    __ret = 0;\n+\t  }\n+\treturn __ret;\n+      };\n+\n+      virtual \n+      ~ctype();\n+\n+      virtual bool \n+      do_is(mask __m, char_type __c) const;\n+\n+      virtual const char_type*\n+      do_is(const char_type* __lo, const char_type* __hi, \n+\t    mask* __vec) const;\n+\n+      virtual const char_type*\n+      do_scan_is(mask __m, const char_type* __lo, \n+\t\t const char_type* __hi) const;\n+\n+      virtual const char_type*\n+      do_scan_not(mask __m, const char_type* __lo, \n+\t\t  const char_type* __hi) const;\n+\n+      virtual char_type \n+      do_toupper(char_type) const;\n+\n+      virtual const char_type*\n+      do_toupper(char_type* __low, const char_type* __high) const;\n+\n+      virtual char_type \n+      do_tolower(char_type) const;\n+\n+      virtual const char_type*\n+      do_tolower(char_type* __low, const char_type* __high) const;\n+      \n+      virtual char_type \n+      do_widen(char) const;\n+\n+      virtual const char*\n+      do_widen(const char* __low, const char* __high,\n+\t       char_type* __dest) const;\n+\n+      virtual char \n+      do_narrow(char_type, char __dfault) const;\n+\n+      virtual const char_type*\n+      do_narrow(const char_type* __low, const char_type* __high,\n+\t\t char __dfault, char* __dest) const;\n+\n+    };\n+\n+  template<>\n+    const ctype<wchar_t>&\n+    use_facet< const ctype<wchar_t> >(const locale& __loc);\n+#endif //_GLIBCPP_USE_WCHAR_T\n+\n+  // Include host-specific ctype specializations.\n+  #include <bits/ctype_specializations.h>\n+\n+  // 22.2.1.2  Template class ctype_byname\n+  template<typename _CharT>\n+    class ctype_byname : public ctype<_CharT>\n+    {\n+    public:\n+      typedef _CharT \t\tchar_type;\n+\n+      explicit \n+      ctype_byname(const char*, size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~ctype_byname() { }\n+    };\n+\n+  //  22.2.1.4  Class ctype_byname specializations\n+  template<>\n+    ctype_byname<char>::ctype_byname(const char*, size_t refs);\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    ctype_byname<wchar_t>::ctype_byname(const char*, size_t refs);\n+#endif\n+\n+\n+  template<typename _CharT, typename _InIter>\n+    class _Numeric_get;  // forward\n+\n+  // _Format_cache holds the information extracted from the numpunct<>\n+  // and moneypunct<> facets in a form optimized for parsing and\n+  // formatting.  It is stored via a void* pointer in the pword()\n+  // array of an iosbase object passed to the _get and _put facets.\n+  // NB: contains no user-serviceable parts.\n+  template<typename _CharT>\n+    class _Format_cache\n+    {\n+    public: \n+      // Types:\n+      typedef _CharT \t\t\t\tchar_type;\n+      typedef char_traits<_CharT> \t\ttraits_type;\n+      typedef basic_string<_CharT>\t\tstring_type;\n+      typedef typename string_type::size_type\tsize_type;\n+\n+      // Forward decls and Friends:\n+      friend class locale;\n+      template<typename _Char, typename _InIter>\n+        friend class _Numeric_get;\n+      friend class num_get<_CharT>;\n+      friend class num_put<_CharT>;\n+      friend class time_get<_CharT>;\n+      friend class money_get<_CharT>;\n+      friend class time_put<_CharT>;\n+      friend class money_put<_CharT>;\n+\n+      // Data Members:\n+\n+      // ios_base::pword() reserved cell\n+      static int \t\t_S_pword_ix; \n+\n+      // True iff data members are consistent with the current locale,\n+      // ie imbue sets this to false.\n+      bool \t\t\t_M_valid;\n+\n+      // A list of valid numeric literals: for the standard \"C\" locale,\n+      // this would usually be: \"-+xX0123456789abcdef0123456789ABCDEF\"\n+      static const char \t_S_literals[];\n+\n+      // NB: Code depends on the order of definitions of the names\n+      // these are indices into _S_literals, above.\n+      // This string is formatted for putting, not getting. (output, not input)\n+      enum \n+      {  \n+\t_S_minus, \n+\t_S_plus, \n+\t_S_x, \n+\t_S_X, \n+\t_S_digits,\n+\t_S_digits_end = _S_digits + 16,\n+\t_S_udigits = _S_digits_end,  \n+\t_S_udigits_end = _S_udigits + 16,\n+\t_S_ee = _S_digits + 14, // For scientific notation, 'E'\n+\t_S_Ee = _S_udigits + 14 // For scientific notation, 'e'\n+      };\n+\n+      // The sign used to separate decimal values: for standard US\n+      // locales, this would usually be: \".\"\n+      // Abstracted from numpunct::decimal_point().\n+      char_type \t\t_M_decimal_point;\n+\n+      // The sign used to separate groups of digits into smaller\n+      // strings that the eye can parse with less difficulty: for\n+      // standard US locales, this would usually be: \",\"\n+      // Abstracted from numpunct::thousands_sep().\n+      char_type\t\t\t_M_thousands_sep;\n+\n+      // However the US's \"false\" and \"true\" are translated.\n+      // From numpunct::truename() and numpunct::falsename(), respectively.\n+      string_type \t\t_M_truename;\n+      string_type \t\t_M_falsename;\n+\n+      // If we are checking groupings. This should be equivalent to \n+      // numpunct::groupings().size() != 0\n+      bool \t\t\t_M_use_grouping;\n+\n+      // If we are using numpunct's groupings, this is the current\n+      // grouping string in effect (from numpunct::grouping()).\n+      string \t\t\t_M_grouping;\n+\n+      _Format_cache();\n+\n+      ~_Format_cache() throw() { }\n+\n+      // Given a member of the ios heirarchy as an argument, extract\n+      // out all the current formatting information into a\n+      // _Format_cache object and return a pointer to it.\n+      static _Format_cache<_CharT>* \n+      _S_get(ios_base& __ios);\n+\n+      void \n+      _M_populate(ios_base&);\n+\n+      static void \n+      _S_callback(ios_base::event __event, ios_base& __ios, int __ix) throw();\n+    };\n+\n+   template<> _Format_cache<char>::_Format_cache();\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+   template<> _Format_cache<wchar_t>::_Format_cache();\n+#endif\n+\n+  // _Numeric_get is used by num_get, money_get, and time_get to help\n+  // in parsing out numbers.\n+  template<typename _CharT, typename _InIter>\n+    class _Numeric_get\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT     char_type;\n+      typedef _InIter    iter_type;\n+\n+      // Forward decls and Friends:\n+      template<typename _Char, typename _InIterT>\n+      friend class num_get;\n+      template<typename _Char, typename _InIterT>\n+      friend class time_get;\n+      template<typename _Char, typename _InIterT>\n+      friend class money_get;\n+      template<typename _Char, typename _InIterT>\n+      friend class num_put;\n+      template<typename _Char, typename _InIterT>\n+      friend class time_put;\n+      template<typename _Char, typename _InIterT>\n+      friend class money_put;\n+\n+    private:\n+      explicit \n+      _Numeric_get() { }\n+\n+      virtual \n+      ~_Numeric_get() { }\n+\n+      iter_type \n+      _M_get_digits(iter_type __in, iter_type __end) const;\n+    };\n+\n+  template<typename _CharT, typename _InIter>\n+    class num_get : public locale::facet\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT   \t\t\tchar_type;\n+      typedef _InIter  \t\t\titer_type;\n+      typedef char_traits<_CharT> \t__traits_type;\n+\n+      static locale::id id;\n+\n+      explicit \n+      num_get(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, bool& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, short& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, int& __v)   const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+#endif\n+\n+      iter_type\n+      get(iter_type __in, iter_type __end, ios_base& __io, \n+\t  ios_base::iostate& __err, long& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, long long& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+#endif\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, unsigned short& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, unsigned int& __v)   const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, unsigned long& __v)  const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, unsigned long long& __v)  const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+#endif\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, float& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, double& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, long double& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }\n+\n+      iter_type \n+      get(iter_type __in, iter_type __end, ios_base& __io,\n+\t  ios_base::iostate& __err, void*& __v) const\n+      { return do_get(__in, __end, __io, __err, __v); }      \n+\n+    protected:\n+      virtual ~num_get() { }\n+\n+      // This consolidates the extraction, storage and\n+      // error-processing parts of the do_get(...) overloaded member\n+      // functions. \n+      // NB: This is specialized for char.\n+      void \n+      _M_extract(iter_type __beg, iter_type __end, ios_base& __io, \n+\t\t ios_base::iostate& __err, char* __xtrc, \n+\t\t int& __base, bool __fp = true) const;\n+\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, short&) const;\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, int&) const;\n+#endif\n+      virtual iter_type \n+      do_get (iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;\n+#ifdef _GLIBCPP_USE_LONG_LONG \n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+\t     long long&) const;\n+#endif\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+\t      unsigned short&) const;\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&,\n+\t      ios_base::iostate& __err, unsigned int&) const;\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&,\n+\t      ios_base::iostate& __err, unsigned long&) const;\n+#ifdef _GLIBCPP_USE_LONG_LONG \n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&,\n+\t     ios_base::iostate& __err, unsigned long long&) const;\n+#endif\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+\t     float&) const;\n+\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+\t     double&) const;\n+\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, \n+\t     ios_base::iostate& __err, long double&) const;\n+\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err, \n+\t     void*&) const;\n+    };\n+\n+  // Declare specialized extraction member function.\n+  template<>\n+    void\n+    num_get<char, istreambuf_iterator<char> >::    \n+    _M_extract(istreambuf_iterator<char> __beg, \n+\t       istreambuf_iterator<char> __end, ios_base& __io, \n+\t       ios_base::iostate& __err, char* __xtrc, \n+\t       int& __base, bool __fp) const;\n+\n+  // _Numeric_put is used by num_put, money_put, and time_put\n+  //   to help in formatting out numbers.\n+  template<typename _CharT, typename _OutIter>\n+    class _Numeric_put\n+    {\n+    public:\n+      typedef _CharT      char_type;\n+      typedef _OutIter    iter_type;\n+    protected:\n+      explicit \n+      _Numeric_put() { }\n+\n+      virtual \n+      ~_Numeric_put() { }\n+    };\n+\n+  template<typename _CharT, typename _OutIter>\n+    class num_put : public locale::facet\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT       char_type;\n+      typedef _OutIter     iter_type;\n+\n+      static locale::id id;\n+\n+      explicit \n+      num_put(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, \n+\t  unsigned long __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG \n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, \n+\t  unsigned long long __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+#endif\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, \n+\t  long double __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill, \n+\t  const void* __v) const\n+      { return do_put(__s, __f, __fill, __v); }\n+\n+    protected:\n+      virtual \n+      ~num_put() { };\n+\n+      virtual iter_type \n+      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;\n+\n+      virtual iter_type \n+      do_put(iter_type, ios_base&, char_type __fill, long __v) const;\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG \n+      virtual iter_type \n+      do_put(iter_type, ios_base&, char_type __fill, long long __v) const;\n+#endif\n+\n+      virtual iter_type \n+      do_put(iter_type, ios_base&, char_type __fill, unsigned long) const;\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+      virtual iter_type\n+      do_put(iter_type, ios_base&, char_type __fill, unsigned long long) const;\n+#endif\n+\n+      virtual iter_type \n+      do_put(iter_type, ios_base&, char_type __fill, double __v) const;\n+\n+      virtual iter_type \n+      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;\n+\n+      virtual iter_type \n+      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;\n+    };\n+\n+  template<typename _CharT>\n+    class _Punct : public locale::facet\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT               char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      char_type    \n+      decimal_point() const\n+      { return do_decimal_point(); }\n+\n+      char_type    \n+      thousands_sep() const\n+      { return do_thousands_sep(); }\n+\n+      string       \n+      grouping() const\n+      { return do_grouping(); }\n+    protected:\n+\n+      explicit \n+      _Punct(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      virtual \n+      ~_Punct() { }\n+\n+      virtual char_type    \n+      do_decimal_point() const\n+      { return _M_decimal_point; }\n+\n+      virtual char_type    \n+      do_thousands_sep() const\n+      { return _M_thousands_sep; }\n+\n+      virtual string       \n+      do_grouping() const\n+      { return _M_grouping; }\n+\n+    private:\n+      char_type _M_decimal_point;\n+      char_type _M_thousands_sep;\n+      string    _M_grouping;\n+      \n+    protected:\n+      // for use at construction time only:\n+      void \n+      _M_init(char_type __d, char_type __t, const string& __g)\n+      {\n+\t_M_decimal_point = __d;\n+\t_M_thousands_sep = __t;\n+\t_M_grouping = __g;\n+      }\n+\n+    };\n+\n+  template<typename _CharT>\n+    class _Numpunct : public _Punct<_CharT>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT               char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      string_type  \n+      truename() const\n+      { return do_truename(); }\n+\n+      string_type  \n+      falsename() const\n+      { return do_falsename(); }\n+\n+    protected:\n+      explicit \n+      _Numpunct(size_t __refs = 0) : _Punct<_CharT> (__refs) { }\n+\n+      virtual \n+      ~_Numpunct() { }\n+\n+      virtual string_type  \n+      do_truename() const\n+      { return _M_truename; }\n+\n+      virtual string_type  \n+      do_falsename() const\n+      { return _M_falsename; }\n+\n+    private:\n+      string_type _M_truename;\n+      string_type _M_falsename;\n+      \n+    protected:\n+      // For use only during construction\n+      void \n+      _M_boolnames_init(const string_type& __t, const string_type& __f)\n+      {\n+\t_M_truename = __t;\n+\t_M_falsename = __f;\n+      }\n+\t\n+    };\n+\n+  template<typename _CharT>\n+    class numpunct : public _Numpunct<_CharT>\n+    {\n+    public:\n+      typedef _CharT               char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      static locale::id id;\n+\n+      explicit \n+      numpunct(size_t __refs = 0) : _Numpunct<_CharT>(__refs) { }\n+    protected:\n+\n+      virtual \n+      ~numpunct() { }\n+    };\n+\n+  template<> \n+    numpunct<char>::numpunct(size_t __refs): _Numpunct<char>(__refs)\n+    {\n+      _M_init('.', ',', \"\");\n+      _M_boolnames_init(\"true\", \"false\");\n+    }\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> \n+    numpunct<wchar_t>::numpunct(size_t __refs): _Numpunct<wchar_t>(__refs)\n+    {\n+      _M_init(L'.', L',', \"\");\n+      _M_boolnames_init(L\"true\", L\"false\");\n+    }\n+#endif\n+\n+  template<typename _CharT>\n+    class numpunct_byname : public numpunct<_CharT>\n+    {\n+    public:\n+      typedef _CharT               char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      explicit \n+      numpunct_byname(const char*, size_t __refs = 0);\n+      \n+    protected:\n+      virtual \n+      ~numpunct_byname() { }\n+    };\n+\n+  template<>\n+    numpunct_byname<char>::numpunct_byname(const char*, size_t __refs);\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    numpunct_byname<wchar_t>::numpunct_byname(const char*, size_t __refs);\n+#endif\n+\n+  template<typename _CharT>\n+    class _Collate : public locale::facet\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT               char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      int \n+      compare(const _CharT* __lo1, const _CharT* __hi1,\n+\t      const _CharT* __lo2, const _CharT* __hi2) const\n+      { return do_compare(__lo1, __hi1, __lo2, __hi2); }\n+\n+      string_type \n+      transform(const _CharT* __lo, const _CharT* __hi) const\n+      { return do_transform(__lo, __hi); }\n+\n+      long \n+      hash(const _CharT* __lo, const _CharT* __hi) const\n+      { return do_hash(__lo, __hi); }\n+      \n+  protected:\n+      explicit \n+      _Collate(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      ~_Collate() { } // virtual\n+\n+      virtual int  \n+      do_compare(const _CharT* __lo1, const _CharT* __hi1,\n+\t\t const _CharT* __lo2, const _CharT* __hi2) const = 0;\n+\n+      virtual string_type \n+      do_transform(const _CharT* __lo, const _CharT* __hi) const = 0;\n+\n+      virtual long   \n+      do_hash(const _CharT* __lo, const _CharT* __hi) const = 0;\n+    };\n+\n+  template<typename _CharT>\n+    class collate : public _Collate<_CharT>\n+    {\n+    public:      \n+      // Types:\n+      typedef _CharT               char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      explicit \n+      collate(size_t __refs = 0) : _Collate<_CharT> (__refs) { }\n+\n+      static locale::id id;\n+      \n+    protected:\n+      virtual \n+      ~collate() { }\n+    };\n+\n+  template<>\n+    class collate<char> : public _Collate<char>\n+    {\n+    public:      \n+      // Types:\n+      typedef char               char_type;\n+      typedef basic_string<char> string_type;\n+\n+      explicit \n+      collate(size_t __refs = 0);\n+\n+      static locale::id id;\n+      \n+    protected:\n+      virtual \n+      ~collate();\n+\n+      virtual int  \n+      do_compare(const char* __lo1, const char* __hi1,\n+\t\t const char* __lo2, const char* __hi2) const;\n+\n+      virtual string_type \n+      do_transform(const char* __lo, const char* __hi) const;\n+\n+      virtual long   \n+      do_hash(const char* __lo, const char* __hi) const;\n+    };\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    class collate<wchar_t> : public _Collate<wchar_t>\n+    {\n+    public:\n+      // Types:\n+      typedef wchar_t               char_type;\n+      typedef basic_string<wchar_t> string_type;\n+      \n+      explicit \n+      collate(size_t __refs = 0);\n+\n+      static locale::id id;\n+      \n+    protected:\n+      virtual \n+      ~collate();\n+\n+      virtual int   \n+      do_compare(const wchar_t* __lo1, const wchar_t* __hi1,\n+\t\t const wchar_t* __lo2, const wchar_t* __hi2) const;\n+\n+      virtual string_type \n+      do_transform(const wchar_t* __lo, const wchar_t* __hi) const;\n+\n+      virtual long   \n+      do_hash(const wchar_t* __lo, const wchar_t* __hi) const;\n+    };\n+#endif\n+\n+  template<typename _CharT>\n+    class collate_byname : public collate<_CharT>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT               char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      explicit \n+      collate_byname(const char*, size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~collate_byname() { }\n+    };\n+\n+  template<>\n+    collate_byname<char>::collate_byname(const char*, size_t __refs);\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    collate_byname<wchar_t>::collate_byname(const char*, size_t __refs);\n+#endif\n+\n+  class time_base\n+  {\n+  public:\n+    enum dateorder { no_order, dmy, mdy, ymd, ydm };\n+  };\n+\n+  template<typename _CharT, typename _InIter>\n+    class time_get : public locale::facet, public time_base\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT     char_type;\n+      typedef _InIter    iter_type;\n+\n+      static locale::id id;\n+\n+      explicit \n+      time_get(size_t __refs = 0) \n+      : locale::facet (__refs), _M_daynames(0), _M_monthnames(0) { }\n+\n+      dateorder \n+      date_order()  const\n+      { return do_date_order(); }\n+\n+      iter_type \n+      get_time(iter_type __s, iter_type __end, ios_base& __f, \n+\t       ios_base::iostate& __err, tm* __t)  const\n+      { return do_get_time(__s, __end, __f, __err, __t); }\n+\n+      iter_type \n+      get_date(iter_type __s, iter_type __end, ios_base& __f,\n+\t       ios_base::iostate& __err, tm* __t)  const\n+      { return do_get_date(__s, __end, __f, __err, __t); }\n+\n+      iter_type \n+      get_weekday(iter_type __s, iter_type __end, ios_base& __f,\n+\t\t  ios_base::iostate& __err, tm* __t) const\n+      { return do_get_weekday(__s,__end,__f,__err,__t); }\n+\n+      iter_type \n+      get_monthname(iter_type __s, iter_type __end, ios_base& __f, \n+\t\t    ios_base::iostate& __err, tm* __t) const\n+      { return do_get_monthname(__s,__end,__f,__err,__t); }\n+\n+      iter_type \n+      get_year(iter_type __s, iter_type __end, ios_base& __f,\n+\t       ios_base::iostate& __err, tm* __t) const\n+      { return do_get_year(__s,__end,__f,__err,__t); }\n+\n+    protected:\n+      virtual \n+      ~time_get() \n+      {      \n+\tdelete [] _M_monthnames; \n+\tdelete [] _M_daynames; \n+      }\n+\n+      virtual dateorder \n+      do_date_order()  const\n+      { return time_base::ymd; }\n+\n+      virtual iter_type \n+      do_get_time(iter_type __s, iter_type /*__end*/, ios_base&,\n+\t\t  ios_base::iostate& /*__err*/, tm* /*__t*/) const\n+      { return __s; }\n+\n+      virtual iter_type \n+      do_get_date(iter_type __s, iter_type /*__end*/, ios_base&,\n+\t\t  ios_base::iostate& /*__err*/, tm* /*__t*/) const\n+      { return __s; }\n+\n+      virtual iter_type \n+      do_get_weekday(iter_type __s, iter_type __end, ios_base&,\n+\t\t     ios_base::iostate& __err, tm* __t) const;\n+\n+      virtual iter_type \n+      do_get_monthname(iter_type __s, iter_type __end, ios_base&, \n+\t\t       ios_base::iostate& __err, tm* __t) const;\n+\n+      virtual iter_type \n+      do_get_year(iter_type __s, iter_type /*__end*/, ios_base&,\n+\t\t   ios_base::iostate& /*__err*/, tm* /*__t*/) const\n+      { return __s; }\n+\n+      mutable basic_string<_CharT>* _M_daynames;\n+      mutable basic_string<_CharT>* _M_monthnames;\n+    };\n+\n+  template<typename _CharT, typename _InIter>\n+    class time_get_byname : public time_get<_CharT, _InIter>\n+    {\n+    public:\n+      typedef _CharT     char_type;\n+      typedef _InIter    iter_type;\n+\n+      explicit \n+      time_get_byname(const char*, size_t __refs = 0) \n+      : time_get<_CharT, _InIter>(__refs) { }\n+    protected:\n+      virtual \n+      ~time_get_byname() { }\n+    };\n+\n+  template<typename _CharT, typename _OutIter>\n+    class time_put : public locale::facet, public time_base\n+    {\n+    public:\n+      typedef _CharT     char_type;\n+      typedef _OutIter   iter_type;\n+\n+      static locale::id id;\n+\n+      explicit \n+      time_put(size_t __refs = 0) : locale::facet (__refs) { }\n+\n+      // NB: this is a nonvirtual, calls do_put in a loop.\n+      iter_type \n+      put(iter_type __s, ios_base& /*__f*/, char_type /*__fill*/,\n+          const tm* /*__tmb*/, const _CharT* /*__pattern*/,\n+          const _CharT* /*__pat_end*/) const\n+      { return __s; }\n+\n+      iter_type \n+      put(iter_type __s, ios_base& __f, char_type __fill,\n+\t  const tm* __tmb, char __format, char __modifier = 0) const\n+      { return do_put(__s, __f, __fill, __tmb, __format, __modifier); }\n+\n+    protected:\n+      virtual \n+      ~time_put() { }\n+\n+      virtual iter_type \n+      do_put(iter_type __s, ios_base&, char_type, const tm* /*__t*/, \n+\t     char /*__format*/, char /*__mod*/) const\n+      { return __s; }\n+    };\n+\n+  template<typename _CharT, typename _OutIter>\n+    class time_put_byname : public time_put<_CharT, _OutIter>\n+    {\n+    public:\n+      typedef _CharT     char_type;\n+      typedef _OutIter   iter_type;\n+\n+      explicit \n+      time_put_byname(const char*, size_t __refs = 0) \n+      : time_put<_CharT, _OutIter> (__refs) { }\n+\n+    protected:\n+      virtual \n+      ~time_put_byname() { }\n+    };\n+\n+\n+  template<typename _CharT, typename _InIter>\n+    class money_get : public locale::facet\n+    {\n+    public:\n+      typedef _CharT        char_type;\n+      typedef _InIter       iter_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      static locale::id id;\n+\n+      explicit \n+      money_get(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      iter_type \n+      get(iter_type __s, iter_type __end, bool __intl,\n+\t  ios_base& __f, ios_base::iostate& __err, long double& __units) const\n+      { return do_get(__s, __end, __intl, __f, __err, __units); }\n+\n+      iter_type \n+      get(iter_type __s, iter_type __end, bool __intl, ios_base& __f, \n+\t   ios_base::iostate& __err, string_type& __digits) const\n+      { return do_get(__s, __end, __intl, __f, __err, __digits); }\n+\n+    protected:\n+      virtual \n+      ~money_get() { }\n+\n+      virtual iter_type \n+      do_get(iter_type __s, iter_type /*__end*/, bool /*__intl*/,\n+             ios_base& /*__io*/, ios_base::iostate& /*__err*/,\n+             long double& /*__units*/) const\n+      { return __s; }\n+\n+      virtual iter_type \n+      do_get(iter_type __s, iter_type /*__end*/, bool /*__intl*/,\n+             ios_base& /*__io*/, ios_base::iostate& /*__err*/,\n+             string_type& /*__digits*/) const\n+      { return __s; }\n+    };\n+\n+  template<typename _CharT, typename _OutIter>\n+    class money_put : public locale::facet\n+    {\n+    public:\n+      typedef _CharT              char_type;\n+      typedef _OutIter            iter_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      static locale::id id;\n+\n+      explicit \n+      money_put(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      iter_type \n+      put(iter_type __s, bool __intl, ios_base& __f,\n+\t  char_type __fill, long double __units) const\n+      { return do_put(__s, __intl, __f, __fill, __units); }\n+\n+      iter_type \n+      put(iter_type __s, bool __intl, ios_base& __f,\n+\t  char_type __fill, const string_type& __digits) const\n+      { return do_put(__s, __intl, __f, __fill, __digits); }\n+\n+    protected:\n+      virtual \n+      ~money_put() { }\n+\n+      virtual iter_type\n+      do_put(iter_type __s, bool, ios_base& /*__io*/, char_type /*__fill*/,\n+\t     long double /*__units*/) const\n+      { return __s; }\n+\n+      virtual iter_type\n+      do_put(iter_type __s, bool, ios_base& /*__io*/, char_type /*__fill*/,\n+\t     const string_type& /*__digits*/) const\n+      { return __s; }\n+    };\n+\n+  struct money_base\n+  {\n+    enum part { none, space, symbol, sign, value };\n+    struct pattern { char field[4]; };\n+\n+    static const pattern _S_default_pattern;\n+  };\n+\n+  template<typename _CharT>\n+    class _Moneypunct : public _Punct<_CharT>, public money_base\n+    {\n+    public:\n+      typedef _CharT char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      string_type  \n+      curr_symbol()   const\n+      { return do_curr_symbol(); }\n+\n+      string_type  \n+      positive_sign() const\n+      { return do_positive_sign(); }\n+\n+      string_type  \n+      negative_sign() const\n+      { return do_negative_sign(); }\n+\n+      int          \n+      frac_digits()   const\n+      { return do_frac_digits(); }\n+\n+      pattern      \n+      pos_format()    const\n+      { return do_pos_format(); }\n+\n+      pattern      \n+      neg_format()    const\n+      { return do_neg_format(); }\n+\n+    protected:\n+      explicit \n+      _Moneypunct(size_t __refs = 0) : _Punct<_CharT> (__refs) { }\n+\n+      virtual \n+      ~_Moneypunct() { }\n+\n+      virtual string_type  \n+      do_curr_symbol()   const\n+      { return basic_string<_CharT>(); }\n+\n+      virtual string_type  \n+      do_positive_sign() const\n+      { return basic_string<_CharT>(); }\n+\n+      virtual string_type  \n+      do_negative_sign() const\n+      { return basic_string<_CharT>(); }\n+\n+      virtual int          \n+      do_frac_digits() const\n+      { return 0; }\n+\n+      virtual pattern      \n+      do_pos_format() const\n+      { return money_base::_S_default_pattern; }\n+\n+      virtual pattern      \n+      do_neg_format() const\n+      { return money_base::_S_default_pattern; }\n+    };\n+\n+  template<typename _CharT, bool _Intl>\n+    class moneypunct : public _Moneypunct<_CharT>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT \t\t\tchar_type;\n+      typedef basic_string<_CharT> \tstring_type;\n+\n+      static const bool intl = _Intl;\n+      static locale::id id;\n+\n+      explicit \n+      moneypunct(size_t __refs = 0) : _Moneypunct<_CharT> (__refs) { }\n+\n+    protected:\n+      virtual \n+      ~moneypunct() { }\n+    };\n+\n+  template<typename _CharT, bool _Intl>\n+    class moneypunct_byname : public moneypunct<_CharT,_Intl>\n+    {\n+    public:\n+      typedef _CharT char_type;\n+      typedef basic_string<_CharT> string_type;\n+      static const bool intl = _Intl;\n+\n+      explicit \n+      moneypunct_byname(const char*, size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~moneypunct_byname() { }\n+    };\n+\n+  template<>\n+    moneypunct_byname<char, false>::\n+    moneypunct_byname(const char*, size_t __refs);\n+  template<>\n+    moneypunct_byname<char, true>::\n+    moneypunct_byname(const char*, size_t __refs);\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    moneypunct_byname<wchar_t,false>::\n+    moneypunct_byname(const char*, size_t __refs);\n+  template<>\n+    moneypunct_byname<wchar_t,true>::\n+    moneypunct_byname (const char*, size_t __refs);\n+#endif\n+\n+  struct messages_base\n+  {\n+    typedef int catalog;\n+  };\n+\n+  template<typename _CharT>\n+    class _Messages : public locale::facet, public messages_base\n+    {\n+    public:\n+      typedef _CharT char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      catalog \n+      open(const basic_string<char>& __s, const locale& __loc) const\n+      { return do_open(__s, __loc); }\n+\n+      string_type  \n+      get(catalog __c, int __set, int __msgid, const string_type& __s) const\n+      { return do_get(__c,__set,__msgid,__s); }\n+\n+      void \n+      close(catalog __c) const\n+      { return do_close(__c); }\n+\n+    protected:\n+      explicit \n+      _Messages(size_t __refs = 0) : locale::facet(__refs) { }\n+\n+      virtual \n+      ~_Messages() { }\n+\n+      // NB: Probably these should be pure, and implemented only in\n+      //  specializations of messages<>.  But for now...\n+      virtual catalog \n+      do_open(const basic_string<char>&, const locale&) const\n+      { return 0; }\n+\n+      virtual string_type  \n+      do_get(catalog, int, int /*__msgid*/, const string_type& __dfault) const\n+      { return __dfault; }\n+\n+      virtual void    \n+      do_close (catalog) const { }\n+    };\n+\n+  template<typename _CharT>\n+    class messages : public _Messages<_CharT>\n+    {\n+    public:\n+      typedef _CharT char_type;\n+      typedef basic_string<_CharT> string_type;\n+      static locale::id id;\n+\n+      explicit \n+      messages(size_t __refs = 0) : _Messages<_CharT> (__refs) { }\n+    protected:\n+      virtual \n+      ~messages() { }\n+    };\n+\n+  template<typename _CharT>\n+    class messages_byname : public messages<_CharT>\n+    {\n+    public:\n+      typedef _CharT char_type;\n+      typedef basic_string<_CharT> string_type;\n+\n+      explicit \n+      messages_byname(const char*, size_t __refs = 0);\n+\n+    protected:\n+      virtual \n+      ~messages_byname() { }\n+    };\n+\n+  template<>\n+    messages_byname<char>::messages_byname(const char*, size_t __refs);\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<>\n+    messages_byname<wchar_t>::messages_byname(const char*, size_t __refs);\n+#endif\n+\n+  // Subclause convenience interfaces, inlines \n+  // NB: these are inline\n+  // because, when used in a loop, some compilers can hoist the body\n+  // out of the loop; then it's just as fast as the C is*() function.\n+  template<typename _CharT>\n+    inline bool \n+    isspace(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    isprint(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    iscntrl(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    isupper(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }\n+\n+  template<typename _CharT>\n+    inline bool islower(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    isalpha(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    isdigit(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    ispunct(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    isxdigit(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    isalnum(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }\n+\n+  template<typename _CharT>\n+    inline bool \n+    isgraph(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }\n+\n+  template<typename _CharT>\n+    inline _CharT \n+    toupper(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }\n+\n+  template<typename _CharT>\n+    inline _CharT \n+    tolower(_CharT __c, const locale& __loc)\n+    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }\n+\n+} // namespace std\n+\n+#endif\t/* _CPP_BITS_LOCFACETS_H */\n+\n+// Local Variables:\n+// mode:c++\n+// End:\n+"}, {"sha": "594e6047a31700e0425bf811c75115e26998a436", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "added", "additions": 1277, "deletions": 0, "changes": 1277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,1277 @@\n+// Locale support -*- C++ -*-\n+\n+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Warning: this file is not meant for user inclusion.  Use <locale>.\n+\n+#ifndef _CPP_BITS_LOCFACETS_TCC\n+#define _CPP_BITS_LOCFACETS_TCC 1\n+\n+#include <bits/std_cerrno.h>\n+#include <bits/std_cstdlib.h>   // For strof, strtold\n+#include <bits/std_limits.h>    // For numeric_limits\n+#include <bits/std_memory.h>    // For auto_ptr\n+#include <bits/sbuf_iter.h>     // For streambuf_iterators\n+#include <bits/std_cctype.h>    // For isspace\n+#include <bits/std_vector.h>\t\n+\n+namespace std\n+{\n+  template<typename _Facet>\n+    locale\n+    locale::combine(const locale& __other)\n+    {\n+      locale __copy(*this);\n+      __copy._M_impl->_M_replace_facet(__other._M_impl, &_Facet::id);\n+      __copy._M_impl->_M_has_name = false;\n+      return __copy;\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    bool\n+    locale::operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,\n+                       const basic_string<_CharT, _Traits, _Alloc>& __s2) const\n+    {\n+      // XXX should not need to qualify here.\n+      // typedef collate<_CharT> __collate_type;\n+      typedef std::collate<_CharT> __collate_type;\n+      const __collate_type* __fcoll = &use_facet<__collate_type>(*this);\n+      return (__fcoll->compare(__s1.data(), __s1.data() + __s1.length(),\n+                               __s2.data(), __s2.data() + __s2.length()) < 0);\n+    }\n+\n+  template<typename _Facet>\n+    const _Facet&\n+    use_facet(const locale& __loc)\n+    {\n+      typedef locale::_Impl::__vec_facet        __vec_facet;\n+      const locale::facet* __fp = (const _Facet*)0;    // check derivation\n+      locale::id& __id = _Facet::id;         // check member id\n+      size_t __i = __id._M_index;\n+      __vec_facet* __facet = __loc._M_impl->_M_facets;\n+      if (__i >= __facet->size() || (__fp = (*(__facet))[__i]) == 0)\n+        return _Use_facet_failure_handler<_Facet>(__loc);\n+      return static_cast<const _Facet&>(*__fp);\n+    }\n+\n+  template<typename _Facet>\n+    bool\n+    has_facet(const locale& __loc) throw()\n+    {\n+      typedef locale::_Impl::__vec_facet        __vec_facet;\n+      locale::id& __id = _Facet::id;         // check member id\n+      size_t __i = __id._M_index;\n+      __vec_facet* __facet = __loc._M_impl->_M_facets;\n+      return (__i < __facet->size() && (*__facet)[__i] != 0);\n+    }\n+\n+  // __match_parallel\n+  // matches input __s against a set of __ntargs strings in __targets,\n+  // placing in __matches a vector of indices into __targets which\n+  // match, and in __remain the number of such matches. If it hits\n+  // end of sequence before it minimizes the set, sets __eof.\n+  // Empty strings are never matched.\n+  template<typename _InIter, typename _CharT>\n+    _InIter\n+    __match_parallel(_InIter __s, _InIter __end, int __ntargs,\n+                     const basic_string<_CharT>* __targets,\n+                     int* __matches, int& __remain, bool& __eof)\n+    {\n+      typedef basic_string<_CharT> __string_type;\n+      __eof = false;\n+      for (int __ti = 0; __ti < __ntargs; ++__ti)\n+        __matches[__ti] = __ti;\n+      __remain = __ntargs;\n+      size_t __pos = 0;\n+      do\n+        {\n+          {\n+            int __ti = 0;\n+            for (;__ti < __remain &&\n+                   __pos == __targets[__matches[__ti]].size(); ++__ti)\n+              { }\n+            if (__ti == __remain)\n+              {\n+                if (__pos == 0) __remain = 0;\n+                return __s;\n+              }\n+          }\n+          if (__s == __end)\n+            __eof = true;\n+          bool __matched = false;\n+          for (int __ti = 0; __ti < __remain; )\n+            {\n+              const __string_type& __target = __targets[__matches[__ti]];\n+              if (__pos < __target.size())\n+                {\n+                  if (__eof || __target[__pos] != *__s)\n+                    {\n+                      __matches[__ti] = __matches[--__remain];\n+                      continue;\n+                    }\n+                  __matched = true;\n+                }\n+              ++__ti;\n+            }\n+          if (__matched)\n+            {\n+              ++__s;\n+              ++__pos;\n+            }\n+          for (int __ti = 0; __ti < __remain;)\n+            {\n+              if (__pos > __targets[__matches[__ti]].size())\n+                {\n+                  __matches[__ti] = __matches[--__remain];\n+                  continue;\n+                }\n+              ++__ti;\n+            }\n+        }\n+      while (__remain);\n+      return __s;\n+    }\n+\n+  template<typename _CharT>\n+    locale::id ctype<_CharT>::id;\n+\n+  template<typename _CharT>\n+    int _Format_cache<_CharT>::_S_pword_ix;\n+\n+  template<typename _CharT>\n+    const char _Format_cache<_CharT>::\n+    _S_literals[] = \"-+xX0123456789abcdef0123456789ABCDEF\";\n+\n+  template<typename _CharT>\n+    _Format_cache<_CharT>::_Format_cache()\n+    : _M_valid(true), _M_use_grouping(false)\n+    { }\n+\n+  template<>\n+    _Format_cache<char>::_Format_cache();\n+\n+  template<>\n+    _Format_cache<wchar_t>::_Format_cache();\n+\n+  template<typename _CharT>\n+    void\n+    _Format_cache<_CharT>::_M_populate(ios_base& __io)\n+    {\n+      locale __loc = __io.getloc ();\n+      numpunct<_CharT> const& __np = use_facet<numpunct<_CharT> >(__loc);\n+      _M_truename = __np.truename();\n+      _M_falsename = __np.falsename();\n+      _M_thousands_sep = __np.thousands_sep();\n+      _M_decimal_point = __np.decimal_point();\n+      _M_grouping = __np.grouping();\n+      _M_use_grouping = _M_grouping.size() != 0 && _M_grouping.data()[0] != 0;\n+      _M_valid = true;\n+    }\n+\n+  // This function is always called via a pointer installed in\n+  // an ios_base by ios_base::register_callback.\n+  template<typename _CharT>\n+    void\n+    _Format_cache<_CharT>::\n+    _S_callback(ios_base::event __ev, ios_base& __ios, int __ix) throw()\n+    {\n+      void*& __p = __ios.pword(__ix);\n+      switch (__ev)\n+        {\n+        case ios_base::erase_event:\n+          delete static_cast<_Format_cache<_CharT>*> (__p); __p = 0;\n+          break;\n+        case ios_base::copyfmt_event:\n+          // If just stored zero, the callback would get registered again.\n+          try {\n+            __p = new _Format_cache<_CharT>;\n+          }\n+          catch(...) {\n+          }\n+          break;\n+        case ios_base::imbue_event:\n+          static_cast<_Format_cache<_CharT>*>(__p)->_M_valid = false;\n+          break;\n+        }\n+    }\n+\n+  template<typename _CharT>\n+    _Format_cache<_CharT>*\n+    _Format_cache<_CharT>::_S_get(ios_base& __ios)\n+    {\n+      if (!_S_pword_ix)\n+        _S_pword_ix = ios_base::xalloc();  // XXX MT\n+      void*& __p = __ios.pword(_S_pword_ix);\n+\n+      // XXX What if pword fails? must check failbit, throw.\n+      if (__p == 0)  // XXX MT?  maybe sentry takes care of it\n+        {\n+          auto_ptr<_Format_cache<_CharT> > __ap(new _Format_cache<_CharT>);\n+          __ios.register_callback(&_Format_cache<_CharT>::_S_callback,\n+                                  _S_pword_ix);\n+          __p = __ap.release();\n+        }\n+      _Format_cache<_CharT>* __ncp = static_cast<_Format_cache<_CharT>*>(__p);\n+      if (!__ncp->_M_valid)\n+        __ncp->_M_populate(__ios);\n+\n+      return __ncp;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    locale::id num_get<_CharT, _InIter>::id;\n+\n+  // This member function takes an (w)istreambuf_iterator object and\n+  // parses it into a generic char array suitable for parsing with\n+  // strto[l,ll,f,d]. The thought was to encapsulate the conversion\n+  // into this one function, and thus the num_get::do_get member\n+  // functions can just adjust for the type of the overloaded\n+  // argument and process the char array returned from _M_extract.\n+  // Other things were also considered, including a fused\n+  // multiply-add loop that would obviate the need for any call to\n+  // strto... at all: however, it would b e a bit of a pain, because\n+  // you'd have to be able to return either floating or integral\n+  // types, etc etc. The current approach seems to be smack dab in\n+  // the middle between an unoptimized approach using sscanf, and\n+  // some kind of hyper-optimized approach alluded to above.\n+\n+  // XXX\n+  // Need to do partial specialization to account for differences\n+  // between character sets. For char, this is pretty\n+  // straightforward, but for wchar_t, the conversion to a plain-jane\n+  // char type is a bit more involved.\n+  template<typename _CharT, typename _InIter>\n+    void\n+    num_get<_CharT, _InIter>::\n+    _M_extract(_InIter /*__beg*/, _InIter /*__end*/, ios_base& /*__io*/,\n+               ios_base::iostate& /*__err*/, char* /*__xtrc*/,\n+               int& /*__base*/, bool /*__fp*/) const\n+    {\n+      // XXX Not currently done: need to expand upon char version below.\n+    }\n+\n+  template<>\n+    void\n+    num_get<char, istreambuf_iterator<char> >::\n+    _M_extract(istreambuf_iterator<char> __beg, \n+\t       istreambuf_iterator<char> __end, ios_base& __io, \n+\t       ios_base::iostate& __err, char* __xtrc, int& __base, \n+\t       bool __fp) const;\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+  // NB: This is an unresolved library defect #17\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, bool& __v) const\n+    {\n+      // Parse bool values as long\n+      if (!(__io.flags() & ios_base::boolalpha))\n+        {\n+          // NB: We can't just call do_get(long) here, as it might\n+          // refer to a derived class.\n+\n+          // Stage 1: extract and determine the conversion specifier.\n+          // Assuming leading zeros eliminated, thus the size of 32 for\n+          // integral types.\n+          char __xtrc[32] = {'\\0'};\n+          int __base;\n+          _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+\n+          // Stage 2: convert and store results.\n+          char* __sanity;\n+          errno = 0;\n+          long __l = strtol(__xtrc, &__sanity, __base);\n+          if (!(__err & ios_base::failbit)\n+              && __l <= 1\n+              && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+            __v = __l;\n+          else\n+            __err |= ios_base::failbit;\n+        }\n+\n+      // Parse bool values as alphanumeric\n+      else\n+        {\n+          typedef _Format_cache<char_type> __fcache_type;\n+          __fcache_type* __fmt = __fcache_type::_S_get(__io);\n+          const char_type* __true = __fmt->_M_truename.c_str();\n+          const char_type* __false = __fmt->_M_falsename.c_str();\n+          const size_t __truelen =  __traits_type::length(__true) - 1;\n+          const size_t __falselen =  __traits_type::length(__false) - 1;\n+\n+          for (size_t __pos = 0; __beg != __end; ++__pos)\n+            {\n+              char_type __c = *__beg++;\n+              bool __testf = __c == __false[__pos];\n+              bool __testt = __c == __true[__pos];\n+              if (!(__testf || __testt))\n+                {\n+                  __err |= ios_base::failbit;\n+                  break;\n+                }\n+              else if (__testf && __pos == __falselen)\n+                {\n+                  __v = 0;\n+                  break;\n+                }\n+              else if (__testt && __pos == __truelen)\n+                {\n+                  __v = 1;\n+                  break;\n+                }\n+            }\n+          if (__beg == __end)\n+            __err |= ios_base::eofbit;\n+        }\n+\n+      return __beg;\n+    }\n+#endif\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, short& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+\n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      long __l = strtol(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n+          && __l >= SHRT_MIN && __l <= SHRT_MAX)\n+        __v = static_cast<short>(__l);\n+      else\n+        __err |= ios_base::failbit;\n+\n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, int& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32] = {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+\n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      long __l = strtol(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n+          && __l >= INT_MIN && __l <= INT_MAX)\n+        __v = static_cast<int>(__l);\n+      else\n+        __err |= ios_base::failbit;\n+\n+      return __beg;\n+    }\n+#endif\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, long& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+\n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      long __l = strtol(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __l;\n+      else\n+        __err |= ios_base::failbit;\n+\n+      return __beg;\n+    }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, long long& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+\n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      long long __ll = strtoll(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __ll;\n+      else\n+        __err |= ios_base::failbit;\n+\n+      return __beg;\n+    }\n+#endif\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, unsigned short& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+\n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      unsigned long __ul = strtoul(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n+          && __ul <= USHRT_MAX)\n+        __v = static_cast<unsigned short>(__ul);\n+      else\n+        __err |= ios_base::failbit;\n+\n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, unsigned int& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+\n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      unsigned long __ul = strtoul(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0\n+          && __ul <= UINT_MAX)\n+        __v = static_cast<unsigned int>(__ul);\n+      else\n+        __err |= ios_base::failbit;\n+\n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, unsigned long& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32] = {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+\n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      unsigned long __ul = strtoul(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __ul;\n+      else\n+        __err |= ios_base::failbit;\n+\n+      return __beg;\n+    }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, unsigned long long& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+\n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      unsigned long long __ull = strtoull(__xtrc, &__sanity, __base);\n+      if (!(__err & ios_base::failbit)\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __ull;\n+      else\n+        __err |= ios_base::failbit;\n+\n+      return __beg;\n+    }\n+#endif\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, float& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 256 for\n+      // floating-point types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, true);\n+\n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+#ifdef _GLIBCPP_HAVE_STRTOF\n+      float __f = strtof(__xtrc, &__sanity);\n+#else\n+      float __f = static_cast<float>(strtod(__xtrc, &__sanity));\n+#endif\n+      if (!(__err & ios_base::failbit)\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __f;\n+      else\n+        __err |= ios_base::failbit;\n+\n+      return __beg;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, double& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 256 for\n+      // floating-point types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, true);\n+\n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      double __d = strtod(__xtrc, &__sanity);\n+      if (!(__err & ios_base::failbit)\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __d;\n+      else\n+        __err |= ios_base::failbit;\n+\n+      return __beg;\n+    }\n+\n+#if defined(_GLIBCPP_HAVE_STRTOLD) && !defined(__hpux)\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, long double& __v) const\n+    {\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 256 for\n+      // floating-point types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, true);\n+\n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      long double __ld = strtold(__xtrc, &__sanity);\n+      if (!(__err & ios_base::failbit)\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __ld;\n+      else\n+        __err |= ios_base::failbit;\n+\n+      return __beg;\n+    }\n+#else\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, long double& __v) const\n+    {\n+      // Stage 1: extract\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, true);\n+\n+      // Stage 2: determine a conversion specifier.\n+      ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;\n+      const char* __conv;\n+      if (__basefield == ios_base::oct)\n+        __conv = \"%Lo\";\n+      else if (__basefield == ios_base::hex)\n+        __conv = \"%LX\";\n+      else if (__basefield == 0)\n+        __conv = \"%Li\";\n+      else\n+        __conv = \"%Lg\";\n+\n+      // Stage 3: store results.\n+      long double __ld;\n+      int __p = sscanf(__xtrc, __conv, &__ld);\n+      if (__p\n+          && static_cast<__traits_type::int_type>(__p) != __traits_type::eof())\n+        __v = __ld;\n+      else\n+        __err |= ios_base::failbit;\n+\n+      return __beg;\n+    }\n+#endif\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    num_get<_CharT, _InIter>::\n+    do_get(iter_type __beg, iter_type __end, ios_base& __io,\n+           ios_base::iostate& __err, void*& __v) const\n+    {\n+      // Prepare for hex formatted input\n+      typedef ios_base::fmtflags        fmtflags;\n+      fmtflags __fmt = __io.flags();\n+      fmtflags __fmtmask = ~(ios_base::showpos | ios_base::basefield\n+                             | ios_base::uppercase | ios_base::internal);\n+      __io.flags(__fmt & __fmtmask | (ios_base::hex | ios_base::showbase));\n+\n+      // Stage 1: extract and determine the conversion specifier.\n+      // Assuming leading zeros eliminated, thus the size of 32 for\n+      // integral types.\n+      char __xtrc[32]= {'\\0'};\n+      int __base;\n+      _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n+\n+      // Stage 2: convert and store results.\n+      char* __sanity;\n+      errno = 0;\n+      void* __vp = reinterpret_cast<void*>(strtoul(__xtrc, &__sanity, __base));\n+      if (!(__err & ios_base::failbit)\n+          && __sanity != __xtrc && *__sanity == '\\0' && errno == 0)\n+        __v = __vp;\n+      else\n+        __err |= ios_base::failbit;\n+\n+      // Reset from hex formatted input\n+      __io.flags(__fmt);\n+      return __beg;\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    locale::id num_put<_CharT, _OutIter>::id;\n+\n+  // _S_fill is specialized for ostreambuf_iterator, random access iterator.\n+  template <typename _CharT, typename _OutIter>\n+    inline _OutIter\n+    _S_fill(_OutIter __s, _CharT __fill, int __padding);\n+\n+  template <typename _CharT, typename _RaIter>\n+    _RaIter\n+    _S_fill(_RaIter __s, _CharT __fill, int __padding,\n+            random_access_iterator_tag)\n+    {\n+      fill_n(__s, __fill);\n+      return __s + __padding;\n+    }\n+\n+  template <typename _CharT, typename _OutIter, typename _Tag>\n+    _OutIter\n+    _S_fill(_OutIter __s, _CharT __fill, int __padding, _Tag)\n+    {\n+      while (--__padding >= 0) { *__s = __fill; ++__s; }\n+      return __s;\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    inline _OutIter\n+    _S_fill(_OutIter __s, _CharT __fill, int __padding)\n+    {\n+      return _S_fill(__s, __fill, __padding,\n+                     iterator_traits<_OutIter>::iterator_category());\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter\n+    _S_pad_numeric(_OutIter __s, ios_base::fmtflags /*__flags*/,\n+                   _CharT /*__fill*/, int /*__width*/, \n+\t\t   _CharT const* /*__first*/, _CharT const* /*__middle*/, \n+\t\t   _CharT const* /*__last*/)\n+    {\n+      // XXX Not currently done: non streambuf_iterator\n+      return __s;\n+    }\n+\n+  // Partial specialization for ostreambuf_iterator.\n+  template <typename _CharT>   \n+    ostreambuf_iterator<_CharT>\n+    _S_pad_numeric(ostreambuf_iterator<_CharT> __s, ios_base::fmtflags __flags,\n+                   _CharT __fill, int __width, _CharT const* __first,\n+                   _CharT const* __middle, _CharT const* __last)\n+    {\n+      typedef ostreambuf_iterator<_CharT> \t__out_iter;\n+      int __padding = __width - (__last - __first);\n+      if (__padding < 0)\n+        __padding = 0;\n+      ios_base::fmtflags __aflags = __flags & ios_base::adjustfield;\n+      bool __testfield = __padding == 0 || __aflags == ios_base::left\n+                         || __aflags == ios_base::internal;\n+\n+      // This was needlessly complicated.\n+      if (__first != __middle)\n+        {\n+          if (!__testfield)\n+            {\n+              _S_fill(__s, __fill, __padding);\n+              __padding = 0;\n+            }\n+          copy(__first, __middle, __s);\n+        }\n+      __out_iter __s2 = __s;\n+\n+      if (__padding && __aflags != ios_base::left)\n+        {\n+          _S_fill(__s2, __fill, __padding);\n+          __padding = 0;\n+        }\n+      __out_iter __s3 = copy(__middle, __last, __s2);\n+      if (__padding)\n+        _S_fill(__s3, __fill, __padding);\n+      return __s3;\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter\n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const\n+    {\n+      const _Format_cache<_CharT>* __fmt = _Format_cache<_CharT>::_S_get(__io);\n+      ios_base::fmtflags __flags = __io.flags();\n+\n+      if ((__flags & ios_base::boolalpha) == 0)\n+        {\n+          unsigned long __uv = __v;\n+          return _S_format(__s, __io, __fill, false, __uv);\n+        }\n+      else\n+        {\n+          const char_type* __first;\n+          const char_type* __last;\n+          if (__v)\n+            {\n+              __first = __fmt->_M_truename.data();\n+              __last = __first + __fmt->_M_truename.size();\n+            }\n+          else\n+            {\n+              __first = __fmt->_M_falsename.data();\n+              __last = __first + __fmt->_M_falsename.size();\n+            }\n+          copy(__first, __last, __s);\n+        }\n+      return __s;\n+    }\n+\n+  // _S_group_digits inserts \"group separator\" characters into an array\n+  // of characters.  It's recursive, one iteration per group.  It moves\n+  // the characters in the buffer this way: \"xxxx12345\" -> \"12,345xxx\".\n+  // Call this only with __grouping != __grend.\n+  template <typename _CharT>\n+    _CharT*\n+    _S_group_digits(_CharT* __s, _CharT __grsep,  char const* __grouping,\n+                    char const* __grend, _CharT const* __first,\n+                    _CharT const* __last)\n+    {\n+      if (__last - __first > *__grouping)\n+        {\n+          __s = _S_group_digits(__s,  __grsep,\n+              (__grouping + 1 == __grend ? __grouping : __grouping + 1),\n+              __grend, __first, __last - *__grouping);\n+          __first = __last - *__grouping;\n+          *__s++ = __grsep;\n+        }\n+      do\n+        {\n+          *__s++ = *__first++;\n+        }\n+      while (__first != __last);\n+      return __s;\n+    }\n+\n+  template <typename _CharT, typename _OutIter, typename _ValueT>\n+    _OutIter\n+    _S_format(_OutIter __s, ios_base& __io, _CharT __fill, bool __neg,\n+              _ValueT __v)\n+    {\n+      // Leave room for \"+/-,\" \"0x,\" and commas.\n+      const long _M_room = numeric_limits<_ValueT>::digits10 * 2 + 4;\n+      _CharT __digits[_M_room];\n+      _CharT* __front = __digits + _M_room;\n+      ios_base::fmtflags __flags = __io.flags();\n+      const _Format_cache<_CharT>* __fmt = _Format_cache<_CharT>::_S_get(__io);\n+      char const* __table = __fmt->_S_literals + __fmt->_S_digits;\n+\n+      ios_base::fmtflags __basefield = (__flags & __io.basefield);\n+      _CharT* __sign_end = __front;\n+      if (__basefield == ios_base::hex)\n+        {\n+          if (__flags & ios_base::uppercase)\n+            __table += 16;  // use ABCDEF\n+          do\n+            *--__front = __table[__v & 15];\n+          while ((__v >>= 4) != 0);\n+          __sign_end = __front;\n+          if (__flags & ios_base::showbase)\n+            {\n+              *--__front = __fmt->_S_literals[__fmt->_S_x +\n+                       ((__flags & ios_base::uppercase) ? 1 : 0)];\n+              *--__front = __table[0];\n+            }\n+        }\n+      else if (__basefield == ios_base::oct)\n+        {\n+          do\n+            *--__front = __table[__v & 7];\n+          while ((__v >>= 3) != 0);\n+          if (__flags & ios_base::showbase\n+              && static_cast<char>(*__front) != __table[0])\n+            *--__front = __table[0];\n+          __sign_end = __front;\n+        }\n+      else\n+        {\n+          // NB: This is _lots_ faster than using ldiv.\n+          do\n+            *--__front = __table[__v % 10];\n+          while ((__v /= 10) != 0);\n+          __sign_end = __front;\n+          // NB: ios_base:hex || ios_base::oct assumed to be unsigned.\n+          if (__neg || (__flags & ios_base::showpos))\n+            *--__front = __fmt->_S_literals[__fmt->_S_plus - __neg];\n+        }\n+\n+      // XXX should specialize!\n+      if (!__fmt->_M_use_grouping && !__io.width())\n+        return copy(__front, __digits + _M_room, __s);\n+\n+      if (!__fmt->_M_use_grouping)\n+        return _S_pad_numeric(__s, __flags, __fill, __io.width(0),\n+                              __front, __sign_end, __digits + _M_room);\n+\n+      _CharT* __p = __digits;\n+      while (__front < __sign_end)\n+        *__p++ = *__front++;\n+      const char* __gr = __fmt->_M_grouping.data();\n+      __front = _S_group_digits(__p, __fmt->_M_thousands_sep, __gr,\n+        __gr + __fmt->_M_grouping.size(), __sign_end, __digits + _M_room);\n+      return _S_pad_numeric(__s, __flags, __fill, __io.width(0),\n+                            __digits, __p, __front);\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter\n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const\n+    {\n+      unsigned long __uv = __v;\n+      bool __neg = false;\n+      if (__v < 0)\n+        {\n+          __neg = true;\n+          __uv = -__uv;\n+        }\n+      return _S_format(__s, __io, __fill, __neg, __uv);\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter\n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type __fill,\n+           unsigned long __v) const\n+    { return _S_format(__s, __io, __fill, false, __v); }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter\n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __b, char_type __fill, long long __v) const\n+    {\n+      unsigned long long __uv = __v;\n+      bool __neg = false;\n+      if (__v < 0)\n+        {\n+          __neg = true;\n+          __uv = -__uv;\n+        }\n+      return _S_format(__s, __b, __fill, __neg, __uv);\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter\n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type __fill,\n+           unsigned long long __v) const\n+    { return _S_format(__s, __io, __fill, false, __v); }\n+#endif\n+\n+  // Generic helper function\n+  template<typename _CharT, typename _OutIter>\n+    static _OutIter\n+    _S_output_float(_OutIter __s, ios_base& __io, _CharT __fill,\n+                    const char* __sptr, size_t __slen)\n+    {\n+      // XXX Not currently done: non streambuf_iterator\n+      return __s;\n+    }\n+\n+  // Partial specialization for ostreambuf_iterator.\n+  template<typename _CharT>\n+    static ostreambuf_iterator<_CharT>\n+    _S_output_float(ostreambuf_iterator<_CharT> __s, ios_base& __io, \n+\t\t    _CharT __fill, const char* __sptr, size_t __slen)\n+    {\n+      size_t __padding = __io.width() > streamsize(__slen) ?\n+                         __io.width() -__slen : 0;\n+      locale __loc = __io.getloc();\n+      ctype<_CharT> const& __ct = use_facet<ctype<_CharT> >(__loc);\n+      ios_base::fmtflags __adjfield = __io.flags() & ios_base::adjustfield;\n+      const char* const __eptr = __sptr + __slen;\n+      // [22.2.2.2.2.19] Table 61\n+      if (__adjfield == ios_base::internal)\n+       {\n+         // [22.2.2.2.2.14]; widen()\n+         if (__sptr < __eptr && (*__sptr == '+' || *__sptr == '-'))\n+           {\n+             __s = __ct.widen(*__sptr);\n+             ++__s;\n+             ++__sptr;\n+           }\n+         __s = _S_fill(__s, __fill, __padding);\n+         __padding = 0;\n+       }\n+      else if (__adjfield != ios_base::left)\n+        {\n+          __s = _S_fill(__s, __fill, __padding);\n+          __padding = 0;\n+        }\n+      // the \"C\" locale decimal character\n+      char __decimal_point = *(localeconv()->decimal_point);\n+      const _Format_cache<_CharT>* __fmt = _Format_cache<_CharT>::_S_get(__io);\n+      for (; __sptr != __eptr; ++__s, ++__sptr)\n+       {\n+         // [22.2.2.2.2.17]; decimal point conversion\n+         if (*__sptr == __decimal_point)\n+           __s = __fmt->_M_decimal_point;\n+         // [22.2.2.2.2.14]; widen()\n+         else\n+           __s = __ct.widen(*__sptr);\n+       }\n+      // [22.2.2.2.2.19] Table 61\n+      if (__padding)\n+        _S_fill(__s, __fill, __padding);\n+      __io.width(0);\n+      return __s;\n+    }\n+\n+  bool\n+  _S_build_float_format(ios_base& __io, char* __fptr, char __modifier,\n+                        streamsize __prec);\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter\n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const\n+    {\n+      const streamsize __max_prec = numeric_limits<double>::digits10 + 3;\n+      streamsize __prec = __io.precision();\n+      // Protect against sprintf() buffer overflows.\n+      if (__prec > __max_prec)\n+        __prec = __max_prec;\n+      // The *2 provides for signs, exp, 'E', and pad.\n+      char __sbuf[__max_prec*2];\n+      size_t __slen;\n+      // Long enough for the max format spec.\n+      char __fbuf[16];\n+      if (_S_build_float_format(__io, __fbuf, 0, __prec))\n+        __slen = sprintf(__sbuf, __fbuf, __prec, __v);\n+      else\n+        __slen = sprintf(__sbuf, __fbuf, __v);\n+      // [22.2.2.2.2] Stages 2-4.\n+      return _S_output_float(__s, __io, __fill, __sbuf, __slen);\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter\n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type __fill,\n+           long double __v) const\n+    {\n+      const streamsize __max_prec = numeric_limits<long double>::digits10 + 3;\n+      streamsize __prec = __io.precision();\n+      // Protect against sprintf() buffer overflows.\n+      if (__prec > __max_prec)\n+        __prec = __max_prec;\n+      // The *2 provides for signs, exp, 'E', and pad.\n+      char __sbuf[__max_prec*2];\n+      size_t __slen;\n+      // Long enough for the max format spec.\n+      char __fbuf[16];\n+      // 'L' as per [22.2.2.2.2] Table 59\n+      if ( _S_build_float_format(__io, __fbuf, 'L', __prec))\n+        __slen = sprintf(__sbuf, __fbuf, __prec, __v);\n+      else\n+        __slen = sprintf(__sbuf, __fbuf, __v);\n+      // [22.2.2.2.2] Stages 2-4\n+      return _S_output_float(__s, __io, __fill, __sbuf, __slen);\n+    }\n+\n+  template <typename _CharT, typename _OutIter>\n+    _OutIter\n+    num_put<_CharT, _OutIter>::\n+    do_put(iter_type __s, ios_base& __io, char_type __fill,\n+           const void* __v) const\n+    {\n+      typedef ios_base::fmtflags        fmtflags;\n+      fmtflags __fmt = __io.flags();\n+      fmtflags __fmtmask = ~(ios_base::showpos | ios_base::basefield\n+                             | ios_base::uppercase | ios_base::internal);\n+      __io.flags(__fmt & __fmtmask | (ios_base::hex | ios_base::showbase));\n+      try {\n+        _OutIter __s2 = _S_format(__s, __io, __fill, false,\n+                                  reinterpret_cast<unsigned long>(__v));\n+        __io.flags(__fmt);\n+        return __s2;\n+      }\n+      catch (...) {\n+        __io.flags(__fmt);\n+        throw;\n+      }\n+    }\n+\n+  template<typename _CharT>\n+    locale::id numpunct<_CharT>::id;\n+\n+  template<typename _CharT>\n+    locale::id collate<_CharT>::id;\n+\n+  // Support for time_get:\n+  // Note that these partial specializations could, and maybe should,\n+  // be changed to full specializations (by eliminating the _Dummy\n+  // argument) and moved to a .cc file.\n+  template<typename _CharT, typename _Dummy = int>\n+    struct _Weekdaynames;\n+\n+  template<typename _Dummy>\n+    struct _Weekdaynames<char, _Dummy>\n+    { static const char* const _S_names[14]; };\n+\n+  template<typename _Dummy>\n+    const char* const\n+    _Weekdaynames<char, _Dummy>::_S_names[14] =\n+    {\n+      \"Sun\", \"Sunday\",\n+      \"Mon\", \"Monday\",   \"Tue\", \"Tuesday\", \"Wed\", \"Wednesday\",\n+      \"Thu\", \"Thursday\", \"Fri\", \"Friday\",  \"Sat\", \"Saturday\"\n+    };\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<typename _Dummy>\n+    struct _Weekdaynames<wchar_t, _Dummy>\n+    { static const wchar_t* const _S_names[14]; };\n+\n+  template<typename _Dummy>\n+    const wchar_t* const\n+    _Weekdaynames<wchar_t, _Dummy>::_S_names[14] =\n+    {\n+      L\"Sun\", L\"Sunday\",\n+      L\"Mon\", L\"Monday\",   L\"Tue\", L\"Tuesday\", L\"Wed\", L\"Wednesday\",\n+      L\"Thu\", L\"Thursday\", L\"Fri\", L\"Friday\",  L\"Sat\", L\"Saturday\"\n+    };\n+#endif\n+\n+  template<typename _CharT, typename _Dummy = int>\n+    struct _Monthnames;\n+\n+  template<typename _Dummy>\n+    struct _Monthnames<char,_Dummy>\n+    { static const char* const _S_names[24]; };\n+\n+  template<typename _Dummy>\n+    const char* const\n+    _Monthnames<char,_Dummy>::_S_names[24] =\n+    {\n+      \"Jan\", \"January\", \"Feb\", \"February\", \"Mar\", \"March\",\n+      \"Apr\", \"April\",   \"May\", \"May\",      \"Jun\", \"June\",\n+      \"Jul\", \"July\",    \"Aug\", \"August\",   \"Sep\", \"September\",\n+      \"Oct\", \"October\", \"Nov\", \"November\", \"Dec\", \"December\"\n+    };\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<typename _Dummy>\n+    struct _Monthnames<wchar_t, _Dummy>\n+    { static const wchar_t* const _S_names[24]; };\n+\n+  template<typename _Dummy>\n+    const wchar_t* const\n+    _Monthnames<wchar_t,_Dummy>::_S_names[24] =\n+    {\n+      L\"Jan\", L\"January\", L\"Feb\", L\"February\", L\"Mar\", L\"March\",\n+      L\"Apr\", L\"April\",   L\"May\", L\"May\",      L\"Jun\", L\"June\",\n+      L\"Jul\", L\"July\",    L\"Aug\", L\"August\",   L\"Sep\", L\"September\",\n+      L\"Oct\", L\"October\", L\"Nov\", L\"November\", L\"Dec\", L\"December\"\n+    };\n+#endif\n+\n+  template<typename _CharT, typename _InIter>\n+    locale::id time_get<_CharT, _InIter>::id;\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    time_get<_CharT, _InIter>::\n+    do_get_weekday(iter_type __s, iter_type __end,\n+                   ios_base& __io, ios_base::iostate& __err, tm* __t) const\n+    {\n+      if (!_M_daynames)\n+        {\n+          _M_daynames = new basic_string<_CharT>[14];\n+          for (int __i = 0; __i < 14; ++__i)\n+            _M_daynames[__i] = _Weekdaynames<_CharT>::_S_names[__i];\n+        }\n+      bool __at_eof = false;\n+      int __remain = 0;\n+      int __matches[14];\n+      iter_type __out = __match_parallel(__s, __end, 14, _M_daynames,\n+                                         __matches, __remain, __at_eof);\n+      __err = ios_base::iostate(0);\n+      if (__at_eof) __err |= __io.eofbit;\n+      if (__remain == 1 ||\n+          __remain == 2 && (__matches[0]>>1) == (__matches[1]>>1))\n+        __t->tm_wday = (__matches[0]>>1);\n+      else\n+        __err |= __io.failbit;\n+      return __out;\n+    }\n+\n+  template<typename _CharT, typename _InIter>\n+    _InIter\n+    time_get<_CharT, _InIter>::\n+    do_get_monthname(iter_type __s, iter_type __end,\n+                     ios_base& __io, ios_base::iostate& __err, tm* __t) const\n+    {\n+      if (!_M_monthnames)\n+        {\n+          _M_monthnames = new basic_string<_CharT>[24];\n+          for (int __i = 0; __i < 24; ++__i)\n+            _M_monthnames[__i] = _Monthnames<_CharT>::_S_names[__i];\n+        }\n+      bool __at_eof = false;\n+      int __remain = 0;\n+      int __matches[24];\n+      iter_type __out = __match_parallel( __s, __end, 24, _M_monthnames,\n+                                          __matches, __remain, __at_eof);\n+      __err = ios_base::iostate(0);\n+      if (__at_eof) __err |= __io.eofbit;\n+      if (__remain == 1 ||\n+          __remain == 2 && (__matches[0]>>1) == (__matches[1]>>1))\n+        __t->tm_mon = (__matches[0]>>1);\n+      else\n+        __err |= __io.failbit;\n+      return __out;\n+    }\n+\n+  template<typename _CharT, typename _OutIter>\n+    locale::id time_put<_CharT, _OutIter>::id;\n+\n+  template<typename _CharT, typename _InIter>\n+    locale::id money_get<_CharT, _InIter>::id;\n+\n+  template<typename _CharT, typename _OutIter>\n+    locale::id money_put<_CharT, _OutIter>::id;\n+\n+  template<typename _CharT, bool _Intl>\n+    locale::id moneypunct<_CharT, _Intl>::id;\n+\n+  template<typename _CharT, bool _Intl>\n+    const bool moneypunct<_CharT, _Intl>::intl;\n+\n+  template<typename _CharT, bool _Intl>\n+    const bool moneypunct_byname<_CharT, _Intl>::intl;\n+\n+  template<typename _CharT>\n+    locale::id messages<_CharT>::id;\n+} // std::\n+\n+#endif /* _CPP_BITS_LOCFACETS_TCC */\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "44e85604bdb62bd4414b75844eebd5871294b3a3", "filename": "libstdc++-v3/include/bits/localefwd.h", "status": "added", "additions": 508, "deletions": 0, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocalefwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocalefwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocalefwd.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,508 @@\n+// Locale support -*- C++ -*-\n+\n+// Copyright (C) 1997-2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 22.1  Locales\n+//\n+\n+#ifndef _CPP_BITS_LOCCORE_H\n+#define _CPP_BITS_LOCCORE_H\t1\n+\n+#include <bits/c++config.h>\n+#include <bits/std_climits.h>\t// For CHAR_BIT\n+#include <bits/std_string.h> \t// For string\n+#include <bits/std_cctype.h>\t// For isspace, etc.\n+\n+namespace std\n+{\n+\n+  // _Count_ones: compile-time computation of number of 1-bits in a value N\n+  // This takes only 5 (or 6) instantiations, doing recursive descent\n+  // in parallel -- ncm\n+  template<unsigned int _Num, int _Shift = (sizeof(unsigned) * CHAR_BIT)/2,\n+           unsigned int _Mask = (~0u >> _Shift) >\n+    struct _Count_ones;\n+\n+  template<unsigned int _Num, unsigned int _Mask>\n+    struct _Count_ones<_Num, 0, _Mask> \n+    { static const unsigned int _S_count = _Num; };\n+\n+  template<unsigned int _Num, unsigned int _Mask>\n+    const unsigned int _Count_ones<_Num, 0, _Mask>::_S_count;\n+\n+  template<unsigned int _Num, int _Shift, unsigned int _Mask>\n+    struct _Count_ones \n+    {\n+      static const unsigned int _S_halfcount =\n+        _Count_ones<_Num, _Shift/2, (_Mask^((~_Mask)>>(_Shift/2))) >::_S_count;\n+      static const unsigned int _S_count\n+      = (_S_halfcount&_Mask) + ((_S_halfcount>>_Shift)&_Mask);\n+    };\n+\n+  template<unsigned int _Num, int _Shift, unsigned int _Mask>\n+    const unsigned int _Count_ones<_Num, _Shift, _Mask>::_S_count;\n+\n+  template<unsigned int _Num, int _Shift, unsigned int _Mask>\n+    const unsigned int _Count_ones<_Num, _Shift, _Mask>::_S_halfcount;\n+\n+  // 22.1.1 Locale\n+  template<typename _Tp> class allocator;\n+  template<typename _Tp, typename _Alloc> class vector;\n+  class locale;\n+\n+  // 22.1.3 Convenience interfaces\n+  template<typename _CharT> \n+    inline bool \n+    isspace(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    isprint(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    iscntrl(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    isupper(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    islower(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    isalpha(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    isdigit(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    ispunct(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    isxdigit(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    isalnum(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline bool \n+    isgraph(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline _CharT \n+    toupper(_CharT, const locale&);\n+\n+  template<typename _CharT> \n+    inline _CharT \n+    tolower(_CharT, const locale&);\n+\n+\n+  // 22.2.1 and 22.2.1.3 ctype\n+  class ctype_base;\n+  template<typename _CharT> \n+    class ctype;\n+  template<> class ctype<char>;\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> class ctype<wchar_t>;\n+#endif\n+\n+  template<typename _CharT> \n+    class ctype_byname;\n+  // NB: Specialized for char and wchar_t in locfacets.h.\n+\n+  class codecvt_base;\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    class codecvt;\n+  template<> class codecvt<char, char, mbstate_t>;\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> class codecvt<wchar_t, char, mbstate_t>;\n+#endif\n+\n+  template<typename _InternT, typename _ExternT, typename _StateT>\n+    class codecvt_byname;\n+  template<> class codecvt_byname<char, char, mbstate_t>;\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> class codecvt_byname<wchar_t, char, mbstate_t>;\n+#endif\n+\n+  // 22.2.2 and 22.2.3 numeric\n+  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >\n+    class num_get;\n+  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >\n+    class num_put;\n+  template<typename _CharT> class numpunct;\n+  template<typename _CharT> class numpunct_byname;\n+\n+  // 22.2.4 collation\n+  template<typename _CharT> \n+    class collate;\n+  template<> class collate<char>;\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> class collate<wchar_t>;\n+#endif\n+  template<typename _CharT> class \n+    collate_byname;\n+\n+  // 22.2.5 date and time\n+  class time_base;\n+  template<typename _CharT, typename _InIter =  istreambuf_iterator<_CharT> >\n+    class time_get;\n+  template<typename _CharT, typename _InIter =  istreambuf_iterator<_CharT> >\n+    class time_get_byname;\n+  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >\n+    class time_put;\n+  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >\n+    class time_put_byname;\n+\n+  // 22.2.6 money\n+  class money_base;\n+  template<typename _CharT, typename _InIter =  istreambuf_iterator<_CharT> >\n+    class money_get;\n+  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >\n+    class money_put;\n+  template<typename _CharT, bool _Intl = false> \n+    class moneypunct;\n+  template<typename _CharT, bool _Intl = false> \n+    class moneypunct_byname;\n+\n+  // 22.2.7 message retrieval\n+  class messages_base;\n+  template<typename _CharT> \n+    class messages;\n+  template<typename _CharT> \n+    class messages_byname;\n+\n+\n+  // 22.1.1 Class locale\n+  class locale\n+  {\n+  public:\n+    // Types:\n+    typedef int category;\n+\n+    // Forward decls and friends:\n+    class facet;\n+    class id;\n+    class _Impl;\n+\n+    friend class _Impl;\n+\n+    template<typename _Facet>\n+      friend const _Facet& \n+      use_facet(const locale&);\n+    \n+    template<typename _Facet>\n+      friend bool \n+      has_facet(const locale&) throw();\n+ \n+    // Category values:\n+    // NB much depends on the order in which these appear:\n+    static const category none\t\t= 0;\n+    static const category collate  \t= 0x0100;\n+    static const category ctype \t= 0x0200;\n+    static const category monetary \t= 0x0400;\n+    static const category numeric \t= 0x0800;\n+    static const category time \t\t= 0x1000;\n+    static const category messages \t= 0x2000;\n+    static const category all \t\t= (collate | ctype | monetary |\n+\t\t\t\t \t   numeric | time  | messages);\n+\n+    // Construct/copy/destroy:\n+    inline  \n+    locale() throw();\n+\n+    inline  \n+    locale(const locale& __other) throw();\n+\n+    explicit  \n+    locale(const char* __std_name);\n+\n+    locale(const locale& __other, const char* __std_name, category __cat);\n+\n+    locale(const locale& __other, const locale& __one, category __cat);\n+\n+    template<typename _Facet>\n+      locale(const locale& __other, _Facet* __f);\n+\n+    inline  \n+    ~locale() throw();\n+\n+    const locale&  \n+    operator=(const locale& __other) throw();\n+\n+    template<typename _Facet>\n+      locale  \n+      combine(const locale& __other);\n+\n+    // Locale operations:\n+    string \n+    name() const;\n+\n+    bool \n+    operator==(const locale& __other) const throw ();\n+\n+    inline bool  \n+    operator!=(const locale& __other) const throw ()\n+    { return !(operator==(__other));  }\n+\n+    template<typename _Char, typename _Traits, typename _Alloc>\n+      bool  \n+      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,\n+\t\t const basic_string<_Char, _Traits, _Alloc>& __s2) const;\n+\n+    // Global locale objects:\n+    static locale \n+    global(const locale&);\n+\n+    static const locale& \n+    classic();\n+\n+  private:\n+    // The (shared) implementation\n+    _Impl* \t\t_M_impl;  \n+\n+    // The \"C\" reference locale\n+    static _Impl* \t_S_classic; \n+\n+    // Current global reference locale\n+    static _Impl* \t_S_global;  \n+\n+    static const int \t_S_categories_num = _Count_ones<all>::_S_count;\n+    static const int \t_S_facets_num = 26;\n+\n+    explicit \n+    locale(_Impl*) throw();\n+\n+    static inline void  \n+    _S_initialize()\n+    { if (!_S_classic) classic();  }\n+\n+    static int  \n+    _S_normalize_category(int);\n+  };\n+\n+\n+  // locale implementation object\n+  class locale::_Impl\n+  {\n+  public:\n+    // Types.\n+    typedef vector<facet*, allocator<facet*> > __vec_facet;\n+    typedef vector<string, allocator<string> > __vec_string;\n+\n+    // Friends.\n+    friend class locale;\n+    friend class locale::facet;\n+\n+    template<typename _Facet>\n+      friend const _Facet&  \n+      use_facet(const locale&);\n+\n+    template<typename _Facet>\n+      friend bool  \n+      has_facet(const locale&) throw();\n+\n+  private:\n+    // Data Members.\n+    size_t \t\t\t\t_M_references;\n+    __vec_facet* \t\t\t_M_facets;\n+    __vec_string* \t\t\t_M_category_names;\n+    bool \t\t\t\t_M_has_name;\n+    string \t\t\t\t_M_name;\n+    static const locale::id* const \t_S_id_collate[];\n+    static const locale::id* const \t_S_id_ctype[];\n+    static const locale::id* const \t_S_id_monetary[];\n+    static const locale::id* const \t_S_id_numeric[];\n+    static const locale::id* const \t_S_id_time[];\n+    static const locale::id* const \t_S_id_messages[];\n+    static const locale::id* const* const _S_facet_categories[];\n+\n+    inline void \n+    _M_add_reference() throw()\n+    { ++_M_references; }  // XXX MT\n+\n+    inline void \n+    _M_remove_reference() throw()\n+    {\n+      if (_M_references-- == 0)  // XXX MT\n+\t{\n+\t  try { \n+\t    delete this; \n+\t  } \n+\t  catch(...) { \n+\t  }\n+\t}\n+    }\n+\n+    _Impl(const _Impl&, size_t __refs);\n+    _Impl(const _Impl&, const string&, category, size_t __refs);\n+    _Impl(size_t __facets, size_t __refs, bool __has_name, string __name);\n+   ~_Impl() throw();\n+\n+    void \n+    _M_replace_categories(const _Impl*, category);\n+\n+    void \n+    _M_replace_category(const _Impl*, const locale::id* const*);\n+\n+    void \n+    _M_replace_facet(const _Impl*, const locale::id*);\n+\n+    void \n+    _M_install_facet(const locale::id*, facet*);\n+\n+    template<typename _Facet>\n+      inline void \n+      _M_facet_init(_Facet* __facet)\n+      { _M_install_facet(&_Facet::id, __facet);  }\n+\n+    void \n+    _M_construct_collate(const char*);\n+\n+    void \n+    _M_construct_ctype(const char*);\n+\n+    void \n+    _M_construct_monetary(const char*);\n+\n+    void \n+    _M_construct_numeric(const char*);\n+\n+    void \n+    _M_construct_time(const char*);\n+\n+    void \n+    _M_construct_messages(const char*);\n+\n+    category \n+    _M_normalize_category_names(const string&, category __cat);\n+  };\n+\n+  // class locale inlines, that need declaration of locale::_Imp\n+  locale::locale() throw()\n+  { \n+    _S_initialize(); \n+    (_M_impl = _S_global)->_M_add_reference(); \n+  } // XXX MT\n+\n+  locale::locale(const locale& __other) throw()\n+  { (_M_impl = __other._M_impl)->_M_add_reference(); }\n+\n+  template<typename _Facet>\n+    locale::locale(const locale& __other, _Facet* __f)\n+    {\n+      _M_impl = new _Impl(*__other._M_impl, 1);\n+      _M_impl->_M_install_facet(&_Facet::id, __f);\n+      _M_impl->_M_has_name = false;\n+      _M_impl->_M_name = \"*\";\n+    }\n+\n+  locale::~locale() throw()\n+  { _M_impl->_M_remove_reference(); }\n+\n+  // 22.1.1.1.2  Class locale::facet\n+  class locale::facet\n+  {\n+    friend class locale;\n+    friend class locale::_Impl;\n+\n+  protected:\n+    explicit \n+    facet(size_t __refs = 0) throw();\n+\n+    virtual \n+    ~facet() { };\n+\n+  private:\n+    size_t _M_references;\n+\n+    void \n+    _M_add_reference() throw();\n+\n+    void \n+    _M_remove_reference() throw();\n+\n+    facet(const facet&);  // not defined\n+\n+    void \n+    operator=(const facet&);  // not defined\n+  };\n+\n+\n+  // 22.1.1.1.3 Class locale::id\n+  class locale::id\n+  {\n+    friend class locale;\n+    friend class locale::_Impl;\n+    template<typename _Facet>\n+      friend const _Facet&  \n+      use_facet(const locale&);\n+    template<typename _Facet>\n+      friend bool           \n+      has_facet(const locale&) throw ();\n+  public:\n+    id() {};\n+  private:\n+    // NB: There is no accessor for _M_index because it may be used\n+    // before the constructor is run; the effect of calling a member\n+    // function (even an inline) would be undefined.\n+    mutable size_t \t_M_index;\n+\n+    // Last id number assigned\n+    static size_t \t_S_highwater;   \n+\n+    void \n+    operator=(const id&);  // not defined\n+\n+    id(const id&);  // not defined\n+  };\n+\n+  template<typename _Facet>\n+    const _Facet&\n+    use_facet(const locale& __loc);\n+\n+  template<typename _Facet>\n+    bool\n+    has_facet(const locale& __loc) throw();\n+\n+} // namespace std\n+\n+#endif\t/* _CPP_BITS_LOCCORE_H */\n+\n+// Local Variables:\n+// mode:c++\n+// End:\n+"}, {"sha": "5a15f7a5e9760698b426ffaf424d0e28869d06db", "filename": "libstdc++-v3/include/bits/mask_array.h", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmask_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmask_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmask_array.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,160 @@\n+// The template and inlines for the -*- C++ -*- mask_array class.\n+\n+// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef _CPP_BITS_MASK_ARRAY_H\n+#define _CPP_BITS_MASK_ARRAY_H 1\n+\n+namespace std {\n+\n+    template <class _Tp> class mask_array\n+    { \n+    public:\n+        typedef _Tp value_type;\n+    \n+        void operator=  (const valarray<_Tp>&) const;\n+        void operator*= (const valarray<_Tp>&) const;\n+        void operator/= (const valarray<_Tp>&) const;\n+        void operator%= (const valarray<_Tp>&) const;\n+        void operator+= (const valarray<_Tp>&) const; \n+        void operator-= (const valarray<_Tp>&) const;\n+        void operator^= (const valarray<_Tp>&) const;  \n+        void operator&= (const valarray<_Tp>&) const;\n+        void operator|= (const valarray<_Tp>&) const;\n+        void operator<<=(const valarray<_Tp>&) const;  \n+        void operator>>=(const valarray<_Tp>&) const; \n+        void operator= (const _Tp&);\n+    \n+        //        ~mask_array ();\n+        \n+        template<class _Dom>\n+        void operator=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator*= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator/= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator%= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator+= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator-= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator^= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator&= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator|= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator<<=(const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator>>=(const _Expr<_Dom,_Tp>&) const; \n+\n+    private:\n+        mask_array (_Array<_Tp>, size_t, _Array<bool>);\n+        friend class valarray<_Tp>;\n+        \n+        const size_t       _M_sz;\n+        const _Array<bool> _M_mask;\n+        const _Array<_Tp>   _M_array;\n+        \n+        mask_array (const mask_array&);\n+        \n+        // not implemented\n+        mask_array ();\n+        mask_array& operator= (const mask_array&);\n+    };\n+\n+\n+    template<typename _Tp>\n+    inline mask_array<_Tp>::mask_array (const mask_array<_Tp>& a)\n+            : _M_sz (a._M_sz), _M_mask (a._M_mask), _M_array (a._M_array) {}\n+\n+    template<typename _Tp>\n+    inline \n+    mask_array<_Tp>::mask_array (_Array<_Tp> __a, size_t __s, _Array<bool> __m)\n+            : _M_sz (__s), _M_mask (__m), _M_array (__a) {}\n+    \n+    //    template<typename _Tp>\n+    //    inline mask_array<_Tp>::~mask_array () {}\n+    \n+    template<typename _Tp>\n+    inline void\n+    mask_array<_Tp>::operator= (const _Tp& __t)\n+    { __valarray_fill (_M_array, _M_sz, _M_mask, __t); }\n+    \n+    template<typename _Tp>\n+    inline void\n+    mask_array<_Tp>::operator= (const valarray<_Tp>& __v) const\n+    { __valarray_copy (_Array<_Tp> (__v), __v.size (), _M_array, _M_mask); }\n+\n+    template<typename _Tp>\n+    template<class E>\n+    inline void\n+    mask_array<_Tp>::operator= (const _Expr<E, _Tp>& __e) const\n+    { __valarray_copy (__e, __e.size (), _M_array, _M_mask); }\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+#define _DEFINE_VALARRAY_OPERATOR(op, name)\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+mask_array<_Tp>::operator op##= (const valarray<_Tp>& __v) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _Array_augmented_##name (_M_array, _M_mask, \t\t\t\t\\\n+                           _Array<_Tp> (__v), __v.size ());\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp> template<class E>\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+mask_array<_Tp>::operator op##= (const _Expr<E, _Tp>& __e) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _Array_augmented_##name (_M_array, _M_mask, __e, __e.size ());\t\\\n+}\n+\n+_DEFINE_VALARRAY_OPERATOR(*, multiplies)\n+_DEFINE_VALARRAY_OPERATOR(/, divides)\n+_DEFINE_VALARRAY_OPERATOR(%, modulus)\n+_DEFINE_VALARRAY_OPERATOR(+, plus)\n+_DEFINE_VALARRAY_OPERATOR(-, minus)\n+_DEFINE_VALARRAY_OPERATOR(^, xor)\n+_DEFINE_VALARRAY_OPERATOR(&, and)\n+_DEFINE_VALARRAY_OPERATOR(|, or)\n+_DEFINE_VALARRAY_OPERATOR(<<, shift_left)\n+_DEFINE_VALARRAY_OPERATOR(>>, shift_right)\n+\n+#undef _DEFINE_VALARRAY_OPERATOR    \n+    \n+} // std::\n+\n+#endif /* _CPP_BITS_MASK_ARRAY_H */\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "7f76b0d0e80693cae0cdda107300d481a1d9802e", "filename": "libstdc++-v3/include/bits/ostream.tcc", "status": "added", "additions": 683, "deletions": 0, "changes": 683, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,683 @@\n+// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.6.2  Output streams\n+//\n+\n+#include <bits/std_locale.h>\n+\n+namespace std {\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>::sentry::\n+    sentry(basic_ostream<_CharT,_Traits>& __os)\n+    : _M_ok(__os.good()), _M_os(__os)\n+    {\n+      // XXX MT \n+      if (_M_ok && __os.tie())\n+\t__os.tie()->flush();  \n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::\n+    operator<<(__ostream_type& (*__pf)(__ostream_type&))\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb)\n+\t{ \n+\t  try {\n+\t      __pf(*this);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.2.5.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\tthrow;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::\n+    operator<<(__ios_type& (*__pf)(__ios_type&))\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb)\n+\t{ \n+\t  try {\n+\t      __pf(*this);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.2.5.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\tthrow;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::\n+    operator<<(ios_base& (*__pf)(ios_base&))\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb)\n+\t{ \n+\t  try {\n+\t      __pf(*this);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.2.5.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t\tthrow;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(bool __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      this->setstate(ios_base::badbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(long __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    bool __f;\n+\t    ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;\n+\t    if (__fmt & ios_base::oct || __fmt & ios_base::hex)\n+\t      __f = _M_fnumput->put(*this, *this, this->fill(), \n+\t\t\t\t    static_cast<unsigned long>(__n)).failed();\n+\t    else\n+\t      __f = _M_fnumput->put(*this, *this, this->fill(), __n).failed();\n+\n+\t    if (__f)  \n+\t      this->setstate(ios_base::badbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      this->setstate(ios_base::badbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(long long __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    bool __f;\n+\t    ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;\n+\t    if (__fmt & ios_base::oct || __fmt & ios_base::hex)\n+\t      __f = _M_fnumput->put(*this, *this, this->fill(), \n+\t\t\t       static_cast<unsigned long long>(__n)).failed();\n+\t    else\n+\t      __f = _M_fnumput->put(*this, *this, this->fill(), __n).failed();\n+\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      this->setstate(ios_base::badbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+#endif\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(double __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      this->setstate(ios_base::badbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(long double __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      this->setstate(ios_base::badbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(const void* __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  try {\n+\t    if (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      this->setstate(ios_base::badbit);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    this->setstate(ios_base::badbit);\n+\t    if ((this->exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>& \n+    basic_ostream<_CharT, _Traits>::operator<<(__streambuf_type* __sbin)\n+    {\n+      streamsize __xtrct = 0;\n+      __streambuf_type* __sbout = this->rdbuf();\n+      sentry __cerb(*this);\n+      if (__sbin && __cerb)\n+\t__xtrct = _S_copy_streambufs(*this, __sbin, __sbout);\n+      if (!__sbin || !__xtrct)\n+\tthis->setstate(ios_base::failbit);\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    basic_ostream<_CharT, _Traits>::put(char_type __c)\n+    { \n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  int_type __put = rdbuf()->sputc(__c); \n+\t  if (__put != traits_type::to_int_type(__c))\n+\t    this->setstate(ios_base::badbit);\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    basic_ostream<_CharT, _Traits>::write(const _CharT* __s, streamsize __n)\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb)\n+\t{\n+\t  streamsize __put = this->rdbuf()->sputn(__s, __n);\n+\t  if ( __put != __n)\n+\t    this->setstate(ios_base::badbit);\n+\t}\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    basic_ostream<_CharT, _Traits>::flush()\n+    {\n+      sentry __cerb(*this);\n+      if (__cerb) \n+\t{\n+\t  if (this->rdbuf() && this->rdbuf()->pubsync() == -1)\n+\t    this->setstate(ios_base::badbit);\n+\t}\n+      return *this;\n+    }\n+  \n+  template<typename _CharT, typename _Traits>\n+    typename basic_ostream<_CharT, _Traits>::pos_type\n+    basic_ostream<_CharT, _Traits>::tellp()\n+    {\n+      pos_type __ret = pos_type(-1);\n+      bool __testok = this->fail() != true;\n+      \n+      if (__testok)\n+\t__ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n+      return __ret;\n+    }\n+\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    basic_ostream<_CharT, _Traits>::seekp(pos_type __pos)\n+    {\n+      bool __testok = this->fail() != true;\n+      \n+      if (__testok)\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+// 136.  seekp, seekg setting wrong streams?\n+\tthis->rdbuf()->pubseekpos(__pos, ios_base::out);\n+#endif\n+      return *this;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    basic_ostream<_CharT, _Traits>::\n+    seekp(off_type __off, ios_base::seekdir __d)\n+    {\n+      bool __testok = this->fail() != true;\n+      \n+      if (__testok)\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+// 136.  seekp, seekg setting wrong streams?\n+\trdbuf()->pubseekoff(__off, __d, ios_base::out);\n+#endif\n+      return *this;\n+    }\n+\n+  // 27.6.2.5.4 Character inserters\n+\n+  // Construct correctly padded string, as per 22.2.2.2.2\n+  // Similar in theory to _S_pad_numeric, from num_put, but it doesn't\n+  // use _S_fill: perhaps it should.\n+  // Assumes \n+  // __newlen > __oldlen\n+  // __news is allocated for __newlen size\n+  template<typename _CharT, typename _Traits>\n+    void\n+    _S_pad_char(basic_ios<_CharT, _Traits>& __ios, \n+\t\t_CharT* __news, const _CharT* __olds,\n+\t\tconst streamsize __newlen, const streamsize __oldlen)\n+    {\n+      typedef _CharT\tchar_type;\n+      typedef _Traits\ttraits_type;\n+      typedef typename traits_type::int_type int_type;\n+      \n+      int_type __plen = static_cast<size_t>(__newlen - __oldlen); \n+      char_type __pads[__plen];\n+      traits_type::assign(__pads, __plen, __ios.fill()); \n+\n+      char_type* __beg;\n+      char_type* __end;\n+      size_t __mod = 0;\n+      size_t __beglen; //either __plen or __oldlen\n+      ios_base::fmtflags __fmt = __ios.flags() & ios_base::adjustfield;\n+\n+      if (__fmt == ios_base::left)\n+\t{\n+\t  // Padding last.\n+\t  __beg = const_cast<char_type*>(__olds);\n+\t  __beglen = __oldlen;\n+\t  __end = __pads;\n+\t}\n+      else if (__fmt == ios_base::internal)\n+\t{\n+\t  // Pad after the sign, if there is one.\n+\t  // Pad after 0[xX], if there is one.\n+\t  // Who came up with these rules, anyway? Jeeze.\n+\t  typedef _Format_cache<_CharT> __cache_type;\n+\t  __cache_type const* __fmt = __cache_type::_S_get(__ios);\n+\t  const char_type* __minus = traits_type::find(__olds, __oldlen, \n+\t\t\t\t\t\t       __fmt->_S_minus);\n+\t  const char_type* __plus = traits_type::find(__olds, __oldlen, \n+\t\t\t\t\t\t      __fmt->_S_plus);\n+\t  bool __testsign = __minus || __plus;\n+\t  bool __testhex = __olds[0] == '0' \n+\t    \t\t   && (__olds[1] == 'x' || __olds[1] == 'X');\n+\n+\t  if (__testhex)\n+\t    {\n+\t      __news[0] = __olds[0]; \n+\t      __news[1] = __olds[1];\n+\t      __mod += 2;\n+\t      __beg = const_cast<char_type*>(__olds + __mod);\n+\t      __beglen = __oldlen - __mod;\n+\t      __end = __pads;\n+\t    }\n+\t  else if (__testsign)\n+\t    {\n+\t      __mod += __plen;\n+\t      const char_type* __sign = __minus ? __minus + 1: __plus + 1;\n+\t      __beg = const_cast<char_type*>(__olds);\n+\t      __beglen = __sign - __olds;\n+\t      __end = const_cast<char_type*>(__sign + __plen);\n+\t      traits_type::copy(__news + __beglen, __pads, __plen);\n+\t    }\n+\t  else\n+\t    {\n+\t      // Padding first.\n+\t      __beg = __pads;\n+\t      __beglen = __plen;\n+\t      __end = const_cast<char_type*>(__olds);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  // Padding first.\n+\t  __beg = __pads;\n+\t  __beglen = __plen;\n+\t  __end = const_cast<char_type*>(__olds);\n+\t}\n+\n+      traits_type::copy(__news, __beg, __beglen);\n+      traits_type::copy(__news + __beglen, __end, __newlen - __beglen - __mod);\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)\n+    {\n+      typedef basic_ostream<_CharT, _Traits> __ostream_type;\n+      __ostream_type::sentry __cerb(__out);\n+      if (__cerb)\n+\t{\n+\t  try {\n+\t    streamsize __w = __out.width();\n+\t    _CharT __pads[__w];\n+\t    __pads[0] = __c;\n+\t    streamsize __len = 1;\n+\t    if (__w > __len)\n+\t      {\n+\t\t_S_pad_char(__out, __pads, &__c, __w, __len);\n+\t\t__len = __w;\n+\t      }\n+\t    __out.write(__pads, __len);\n+\t    __out.width(0);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    __out.setstate(ios_base::badbit);\n+\t    if ((__out.exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return __out;\n+    }\n+\n+  // Specialization\n+  template <class _Traits> \n+    basic_ostream<char, _Traits>&\n+    operator<<(basic_ostream<char, _Traits>& __out, char __c)\n+    {\n+      typedef basic_ostream<char, _Traits> __ostream_type;\n+      __ostream_type::sentry __cerb(__out);\n+      if (__cerb)\n+\t{\n+\t  try {\n+\t    streamsize __w = __out.width();\n+\t    char __pads[__w + 1];\n+\t    __pads[0] = __c;\n+\t    streamsize __len = 1;\n+\t    if (__w > __len)\n+\t      {\n+\t\t_S_pad_char(__out, __pads, &__c, __w, __len);\n+\t\t__len = __w;\n+\t      }\n+\t    __out.write(__pads, __len);\n+\t    __out.width(0);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    __out.setstate(ios_base::badbit);\n+\t    if ((__out.exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return __out;\n+     }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)\n+    {\n+      typedef basic_ostream<_CharT, _Traits> __ostream_type;\n+      __ostream_type::sentry __cerb(__out);\n+      if (__cerb)\n+\t{\n+\t  try {\n+\t    streamsize __w = __out.width();\n+\t    _CharT __pads[__w];\n+\t    streamsize __len = static_cast<streamsize>(_Traits::length(__s));\n+\t    if (__w > __len)\n+\t      {\n+\t\t_S_pad_char(__out, __pads, __s, __w, __len);\n+\t\t__s = __pads;\n+\t\t__len = __w;\n+\t      }\n+\t    __out.write(__s, __len);\n+\t    __out.width(0);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    __out.setstate(ios_base::badbit);\n+\t    if ((__out.exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return __out;\n+    }\n+\n+  template<typename _CharT, typename _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)\n+    {\n+      typedef basic_ostream<_CharT, _Traits> __ostream_type;\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+// 167.  Improper use of traits_type::length()\n+      typedef char_traits<char>\t\t     __ctraits_type;\n+#endif\n+      __ostream_type::sentry __cerb(__out);\n+      if (__cerb)\n+\t{\n+\t  size_t __clen = __ctraits_type::length(__s);\n+\t  _CharT __ws[__clen + 1];\n+\t  for (size_t  __i = 0; __i <= __clen; ++__i)\n+\t    __ws[__i] = __out.widen(__s[__i]);\n+\t  _CharT* __str = __ws;\n+\t  \n+\t  try {\n+\t    streamsize __len = static_cast<streamsize>(__clen);\n+\t    streamsize __w = __out.width();\n+\t    _CharT __pads[__w];\n+\n+\t    if (__w > __len)\n+\t      {\n+\t\t_S_pad_char(__out, __pads, __ws, __w, __len);\n+\t\t__str = __pads;\n+\t\t__len = __w;\n+\t      }\n+\t    __out.write(__str, __len);\n+\t    __out.width(0);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    __out.setstate(ios_base::badbit);\n+\t    if ((__out.exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return __out;\n+    }\n+\n+  // Partial specializationss\n+  template<class _Traits>\n+    basic_ostream<char, _Traits>&\n+    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)\n+    {\n+      typedef basic_ostream<char, _Traits> __ostream_type;\n+      __ostream_type::sentry __cerb(__out);\n+      if (__cerb)\n+\t{\n+\t  try {\n+\t    streamsize __w = __out.width();\n+\t    char __pads[__w];\n+\t    streamsize __len = static_cast<streamsize>(_Traits::length(__s));\n+\t    if (__w > __len)\n+\t      {\n+\t\t_S_pad_char(__out, __pads, __s, __w, __len);\n+\t\t__s = __pads;\n+\t\t__len = __w;\n+\t      }\n+\t    __out.write(__s, __len);\n+\t    __out.width(0);\n+\t  }\n+\t  catch(exception& __fail){\n+\t    // 27.6.1.2.1 Common requirements.\n+\t    // Turn this on without causing an ios::failure to be thrown.\n+\t    __out.setstate(ios_base::badbit);\n+\t    if ((__out.exceptions() & ios_base::badbit) != 0)\n+\t      throw;\n+\t  }\n+\t}\n+      return __out;\n+    }\n+\n+  // 21.3.7.8 basic_string::operator<<\n+  template<typename _CharT, typename _Traits, typename _Alloc>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>& __out,\n+\t       const basic_string<_CharT, _Traits, _Alloc>& __s)\n+    { return (__out << __s.c_str()); }\n+\n+} // namespace std\n+ \n+// Local Variables:\n+// mode:C++\n+// End:\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "3b63127ced7f3e483fba550d9dee51e66302ab27", "filename": "libstdc++-v3/include/bits/pthread_allocimpl.h", "status": "added", "additions": 495, "deletions": 0, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpthread_allocimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpthread_allocimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpthread_allocimpl.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,495 @@\n+/*\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_BITS_PTHREAD_ALLOCIMPL_H\n+#define _CPP_BITS_PTHREAD_ALLOCIMPL_H 1\n+\n+// Pthread-specific node allocator.\n+// This is similar to the default allocator, except that free-list\n+// information is kept separately for each thread, avoiding locking.\n+// This should be reasonably fast even in the presence of threads.\n+// The down side is that storage may not be well-utilized.\n+// It is not an error to allocate memory in thread A and deallocate\n+// it in thread B.  But this effectively transfers ownership of the memory,\n+// so that it can only be reallocated by thread B.  Thus this can effectively\n+// result in a storage leak if it's done on a regular basis.\n+// It can also result in frequent sharing of\n+// cache lines among processors, with potentially serious performance\n+// consequences.\n+\n+#include <bits/std_cerrno.h>\n+#include <bits/stl_config.h>\n+#include <bits/stl_alloc.h>\n+#ifndef __RESTRICT\n+#  define __RESTRICT\n+#endif\n+\n+#ifndef __STL_NO_BAD_ALLOC\n+#  include <bits/std_new.h>\n+#endif\n+\n+__STL_BEGIN_NAMESPACE\n+\n+#define __STL_DATA_ALIGNMENT 8\n+\n+union _Pthread_alloc_obj {\n+    union _Pthread_alloc_obj * __free_list_link;\n+    char __client_data[__STL_DATA_ALIGNMENT];    /* The client sees this.    */\n+};\n+\n+// Pthread allocators don't appear to the client to have meaningful\n+// instances.  We do in fact need to associate some state with each\n+// thread.  That state is represented by\n+// _Pthread_alloc_per_thread_state<_Max_size>.\n+\n+template<size_t _Max_size>\n+struct _Pthread_alloc_per_thread_state {\n+  typedef _Pthread_alloc_obj __obj;\n+  enum { _S_NFREELISTS = _Max_size/__STL_DATA_ALIGNMENT };\n+  _Pthread_alloc_obj* volatile __free_list[_S_NFREELISTS]; \n+  _Pthread_alloc_per_thread_state<_Max_size> * __next; \n+\t// Free list link for list of available per thread structures.\n+  \t// When one of these becomes available for reuse due to thread\n+\t// termination, any objects in its free list remain associated\n+\t// with it.  The whole structure may then be used by a newly\n+\t// created thread.\n+  _Pthread_alloc_per_thread_state() : __next(0)\n+  {\n+    memset((void *)__free_list, 0, (size_t) _S_NFREELISTS * sizeof(__obj *));\n+  }\n+  // Returns an object of size __n, and possibly adds to size n free list.\n+  void *_M_refill(size_t __n);\n+};\n+\n+// Pthread-specific allocator.\n+// The argument specifies the largest object size allocated from per-thread\n+// free lists.  Larger objects are allocated using malloc_alloc.\n+// Max_size must be a power of 2.\n+template <size_t _Max_size = 128>\n+class _Pthread_alloc_template {\n+\n+public: // but only for internal use:\n+\n+  typedef _Pthread_alloc_obj __obj;\n+\n+  // Allocates a chunk for nobjs of size size.  nobjs may be reduced\n+  // if it is inconvenient to allocate the requested number.\n+  static char *_S_chunk_alloc(size_t __size, int &__nobjs);\n+\n+  enum {_S_ALIGN = __STL_DATA_ALIGNMENT};\n+\n+  static size_t _S_round_up(size_t __bytes) {\n+    return (((__bytes) + (int) _S_ALIGN-1) & ~((int) _S_ALIGN - 1));\n+  }\n+  static size_t _S_freelist_index(size_t __bytes) {\n+    return (((__bytes) + (int) _S_ALIGN-1)/(int)_S_ALIGN - 1);\n+  }\n+\n+private:\n+  // Chunk allocation state. And other shared state.\n+  // Protected by _S_chunk_allocator_lock.\n+  static pthread_mutex_t _S_chunk_allocator_lock;\n+  static char *_S_start_free;\n+  static char *_S_end_free;\n+  static size_t _S_heap_size;\n+  static _Pthread_alloc_per_thread_state<_Max_size>* _S_free_per_thread_states;\n+  static pthread_key_t _S_key;\n+  static bool _S_key_initialized;\n+        // Pthread key under which per thread state is stored. \n+        // Allocator instances that are currently unclaimed by any thread.\n+  static void _S_destructor(void *instance);\n+        // Function to be called on thread exit to reclaim per thread\n+        // state.\n+  static _Pthread_alloc_per_thread_state<_Max_size> *_S_new_per_thread_state();\n+        // Return a recycled or new per thread state.\n+  static _Pthread_alloc_per_thread_state<_Max_size> *_S_get_per_thread_state();\n+        // ensure that the current thread has an associated\n+        // per thread state.\n+  class _M_lock;\n+  friend class _M_lock;\n+  class _M_lock {\n+      public:\n+        _M_lock () { pthread_mutex_lock(&_S_chunk_allocator_lock); }\n+        ~_M_lock () { pthread_mutex_unlock(&_S_chunk_allocator_lock); }\n+  };\n+\n+public:\n+\n+  /* n must be > 0      */\n+  static void * allocate(size_t __n)\n+  {\n+    __obj * volatile * __my_free_list;\n+    __obj * __RESTRICT __result;\n+    _Pthread_alloc_per_thread_state<_Max_size>* __a;\n+\n+    if (__n > _Max_size) {\n+        return(malloc_alloc::allocate(__n));\n+    }\n+    if (!_S_key_initialized ||\n+        !(__a = (_Pthread_alloc_per_thread_state<_Max_size>*)\n+                                 pthread_getspecific(_S_key))) {\n+        __a = _S_get_per_thread_state();\n+    }\n+    __my_free_list = __a -> __free_list + _S_freelist_index(__n);\n+    __result = *__my_free_list;\n+    if (__result == 0) {\n+        void *__r = __a -> _M_refill(_S_round_up(__n));\n+        return __r;\n+    }\n+    *__my_free_list = __result -> __free_list_link;\n+    return (__result);\n+  };\n+\n+  /* p may not be 0 */\n+  static void deallocate(void *__p, size_t __n)\n+  {\n+    __obj *__q = (__obj *)__p;\n+    __obj * volatile * __my_free_list;\n+    _Pthread_alloc_per_thread_state<_Max_size>* __a;\n+\n+    if (__n > _Max_size) {\n+        malloc_alloc::deallocate(__p, __n);\n+        return;\n+    }\n+    if (!_S_key_initialized ||\n+        !(__a = (_Pthread_alloc_per_thread_state<_Max_size> *)\n+                pthread_getspecific(_S_key))) {\n+        __a = _S_get_per_thread_state();\n+    }\n+    __my_free_list = __a->__free_list + _S_freelist_index(__n);\n+    __q -> __free_list_link = *__my_free_list;\n+    *__my_free_list = __q;\n+  }\n+\n+  static void * reallocate(void *__p, size_t __old_sz, size_t __new_sz);\n+\n+} ;\n+\n+typedef _Pthread_alloc_template<> pthread_alloc;\n+\n+\n+template <size_t _Max_size>\n+void _Pthread_alloc_template<_Max_size>::_S_destructor(void * __instance)\n+{\n+    _M_lock __lock_instance;\t// Need to acquire lock here.\n+    _Pthread_alloc_per_thread_state<_Max_size>* __s =\n+        (_Pthread_alloc_per_thread_state<_Max_size> *)__instance;\n+    __s -> __next = _S_free_per_thread_states;\n+    _S_free_per_thread_states = __s;\n+}\n+\n+template <size_t _Max_size>\n+_Pthread_alloc_per_thread_state<_Max_size> *\n+_Pthread_alloc_template<_Max_size>::_S_new_per_thread_state()\n+{    \n+    /* lock already held here.\t*/\n+    if (0 != _S_free_per_thread_states) {\n+        _Pthread_alloc_per_thread_state<_Max_size> *__result =\n+\t\t\t\t\t_S_free_per_thread_states;\n+        _S_free_per_thread_states = _S_free_per_thread_states -> __next;\n+        return __result;\n+    } else {\n+        return new _Pthread_alloc_per_thread_state<_Max_size>;\n+    }\n+}\n+\n+template <size_t _Max_size>\n+_Pthread_alloc_per_thread_state<_Max_size> *\n+_Pthread_alloc_template<_Max_size>::_S_get_per_thread_state()\n+{\n+    /*REFERENCED*/\n+    _M_lock __lock_instance;\t// Need to acquire lock here.\n+    int __ret_code;\n+    _Pthread_alloc_per_thread_state<_Max_size> * __result;\n+    if (!_S_key_initialized) {\n+        if (pthread_key_create(&_S_key, _S_destructor)) {\n+\t    __THROW_BAD_ALLOC;  // defined in stl_alloc.h\n+        }\n+        _S_key_initialized = true;\n+    }\n+    __result = _S_new_per_thread_state();\n+    __ret_code = pthread_setspecific(_S_key, __result);\n+    if (__ret_code) {\n+      if (__ret_code == ENOMEM) {\n+\t__THROW_BAD_ALLOC;\n+      } else {\n+\t// EINVAL\n+\tabort();\n+      }\n+    }\n+    return __result;\n+}\n+\n+/* We allocate memory in large chunks in order to avoid fragmenting     */\n+/* the malloc heap too much.                                            */\n+/* We assume that size is properly aligned.                             */\n+template <size_t _Max_size>\n+char *_Pthread_alloc_template<_Max_size>\n+::_S_chunk_alloc(size_t __size, int &__nobjs)\n+{\n+  {\n+    char * __result;\n+    size_t __total_bytes;\n+    size_t __bytes_left;\n+    /*REFERENCED*/\n+    _M_lock __lock_instance;         // Acquire lock for this routine\n+\n+    __total_bytes = __size * __nobjs;\n+    __bytes_left = _S_end_free - _S_start_free;\n+    if (__bytes_left >= __total_bytes) {\n+        __result = _S_start_free;\n+        _S_start_free += __total_bytes;\n+        return(__result);\n+    } else if (__bytes_left >= __size) {\n+        __nobjs = __bytes_left/__size;\n+        __total_bytes = __size * __nobjs;\n+        __result = _S_start_free;\n+        _S_start_free += __total_bytes;\n+        return(__result);\n+    } else {\n+        size_t __bytes_to_get =\n+\t\t2 * __total_bytes + _S_round_up(_S_heap_size >> 4);\n+        // Try to make use of the left-over piece.\n+        if (__bytes_left > 0) {\n+            _Pthread_alloc_per_thread_state<_Max_size>* __a = \n+                (_Pthread_alloc_per_thread_state<_Max_size>*)\n+\t\t\tpthread_getspecific(_S_key);\n+            __obj * volatile * __my_free_list =\n+                        __a->__free_list + _S_freelist_index(__bytes_left);\n+\n+            ((__obj *)_S_start_free) -> __free_list_link = *__my_free_list;\n+            *__my_free_list = (__obj *)_S_start_free;\n+        }\n+#       ifdef _SGI_SOURCE\n+          // Try to get memory that's aligned on something like a\n+          // cache line boundary, so as to avoid parceling out\n+          // parts of the same line to different threads and thus\n+          // possibly different processors.\n+          {\n+            const int __cache_line_size = 128;  // probable upper bound\n+            __bytes_to_get &= ~(__cache_line_size-1);\n+            _S_start_free = (char *)memalign(__cache_line_size, __bytes_to_get); \n+            if (0 == _S_start_free) {\n+              _S_start_free = (char *)malloc_alloc::allocate(__bytes_to_get);\n+            }\n+          }\n+#       else  /* !SGI_SOURCE */\n+          _S_start_free = (char *)malloc_alloc::allocate(__bytes_to_get);\n+#       endif\n+        _S_heap_size += __bytes_to_get;\n+        _S_end_free = _S_start_free + __bytes_to_get;\n+    }\n+  }\n+  // lock is released here\n+  return(_S_chunk_alloc(__size, __nobjs));\n+}\n+\n+\n+/* Returns an object of size n, and optionally adds to size n free list.*/\n+/* We assume that n is properly aligned.                                */\n+/* We hold the allocation lock.                                         */\n+template <size_t _Max_size>\n+void *_Pthread_alloc_per_thread_state<_Max_size>\n+::_M_refill(size_t __n)\n+{\n+    int __nobjs = 128;\n+    char * __chunk =\n+\t_Pthread_alloc_template<_Max_size>::_S_chunk_alloc(__n, __nobjs);\n+    __obj * volatile * __my_free_list;\n+    __obj * __result;\n+    __obj * __current_obj, * __next_obj;\n+    int __i;\n+\n+    if (1 == __nobjs)  {\n+        return(__chunk);\n+    }\n+    __my_free_list = __free_list\n+\t\t + _Pthread_alloc_template<_Max_size>::_S_freelist_index(__n);\n+\n+    /* Build free list in chunk */\n+      __result = (__obj *)__chunk;\n+      *__my_free_list = __next_obj = (__obj *)(__chunk + __n);\n+      for (__i = 1; ; __i++) {\n+        __current_obj = __next_obj;\n+        __next_obj = (__obj *)((char *)__next_obj + __n);\n+        if (__nobjs - 1 == __i) {\n+            __current_obj -> __free_list_link = 0;\n+            break;\n+        } else {\n+            __current_obj -> __free_list_link = __next_obj;\n+        }\n+      }\n+    return(__result);\n+}\n+\n+template <size_t _Max_size>\n+void *_Pthread_alloc_template<_Max_size>\n+::reallocate(void *__p, size_t __old_sz, size_t __new_sz)\n+{\n+    void * __result;\n+    size_t __copy_sz;\n+\n+    if (__old_sz > _Max_size\n+\t&& __new_sz > _Max_size) {\n+        return(realloc(__p, __new_sz));\n+    }\n+    if (_S_round_up(__old_sz) == _S_round_up(__new_sz)) return(__p);\n+    __result = allocate(__new_sz);\n+    __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz;\n+    memcpy(__result, __p, __copy_sz);\n+    deallocate(__p, __old_sz);\n+    return(__result);\n+}\n+\n+template <size_t _Max_size>\n+_Pthread_alloc_per_thread_state<_Max_size> *\n+_Pthread_alloc_template<_Max_size>::_S_free_per_thread_states = 0;\n+\n+template <size_t _Max_size>\n+pthread_key_t _Pthread_alloc_template<_Max_size>::_S_key;\n+\n+template <size_t _Max_size>\n+bool _Pthread_alloc_template<_Max_size>::_S_key_initialized = false;\n+\n+template <size_t _Max_size>\n+pthread_mutex_t _Pthread_alloc_template<_Max_size>::_S_chunk_allocator_lock\n+= PTHREAD_MUTEX_INITIALIZER;\n+\n+template <size_t _Max_size>\n+char *_Pthread_alloc_template<_Max_size>\n+::_S_start_free = 0;\n+\n+template <size_t _Max_size>\n+char *_Pthread_alloc_template<_Max_size>\n+::_S_end_free = 0;\n+\n+template <size_t _Max_size>\n+size_t _Pthread_alloc_template<_Max_size>\n+::_S_heap_size = 0;\n+\n+#ifdef __STL_USE_STD_ALLOCATORS\n+\n+template <class _Tp>\n+class pthread_allocator {\n+  typedef pthread_alloc _S_Alloc;          // The underlying allocator.\n+public:\n+  typedef size_t     size_type;\n+  typedef ptrdiff_t  difference_type;\n+  typedef _Tp*       pointer;\n+  typedef const _Tp* const_pointer;\n+  typedef _Tp&       reference;\n+  typedef const _Tp& const_reference;\n+  typedef _Tp        value_type;\n+\n+  template <class _NewType> struct rebind {\n+    typedef pthread_allocator<_NewType> other;\n+  };\n+\n+  pthread_allocator() __STL_NOTHROW {}\n+  pthread_allocator(const pthread_allocator& a) __STL_NOTHROW {}\n+  template <class _OtherType>\n+\tpthread_allocator(const pthread_allocator<_OtherType>&)\n+\t\t__STL_NOTHROW {}\n+  ~pthread_allocator() __STL_NOTHROW {}\n+\n+  pointer address(reference __x) const { return &__x; }\n+  const_pointer address(const_reference __x) const { return &__x; }\n+\n+  // __n is permitted to be 0.  The C++ standard says nothing about what\n+  // the return value is when __n == 0.\n+  _Tp* allocate(size_type __n, const void* = 0) {\n+    return __n != 0 ? static_cast<_Tp*>(_S_Alloc::allocate(__n * sizeof(_Tp)))\n+                    : 0;\n+  }\n+\n+  // p is not permitted to be a null pointer.\n+  void deallocate(pointer __p, size_type __n)\n+    { _S_Alloc::deallocate(__p, __n * sizeof(_Tp)); }\n+\n+  size_type max_size() const __STL_NOTHROW \n+    { return size_t(-1) / sizeof(_Tp); }\n+\n+  void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n+  void destroy(pointer _p) { _p->~_Tp(); }\n+};\n+\n+template<>\n+class pthread_allocator<void> {\n+public:\n+  typedef size_t      size_type;\n+  typedef ptrdiff_t   difference_type;\n+  typedef void*       pointer;\n+  typedef const void* const_pointer;\n+  typedef void        value_type;\n+\n+  template <class _NewType> struct rebind {\n+    typedef pthread_allocator<_NewType> other;\n+  };\n+};\n+\n+template <size_t _Max_size>\n+inline bool operator==(const _Pthread_alloc_template<_Max_size>&,\n+                       const _Pthread_alloc_template<_Max_size>&)\n+{\n+  return true;\n+}\n+\n+template <class _T1, class _T2>\n+inline bool operator==(const pthread_allocator<_T1>&,\n+                       const pthread_allocator<_T2>& a2) \n+{\n+  return true;\n+}\n+\n+template <class _T1, class _T2>\n+inline bool operator!=(const pthread_allocator<_T1>&,\n+                       const pthread_allocator<_T2>&)\n+{\n+  return false;\n+}\n+\n+template <class _Tp, size_t _Max_size>\n+struct _Alloc_traits<_Tp, _Pthread_alloc_template<_Max_size> >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, _Pthread_alloc_template<_Max_size> > _Alloc_type;\n+  typedef __allocator<_Tp, _Pthread_alloc_template<_Max_size> > \n+          allocator_type;\n+};\n+\n+template <class _Tp, class _Atype, size_t _Max>\n+struct _Alloc_traits<_Tp, __allocator<_Atype, _Pthread_alloc_template<_Max> > >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, _Pthread_alloc_template<_Max> > _Alloc_type;\n+  typedef __allocator<_Tp, _Pthread_alloc_template<_Max> > allocator_type;\n+};\n+\n+template <class _Tp, class _Atype>\n+struct _Alloc_traits<_Tp, pthread_allocator<_Atype> >\n+{\n+  static const bool _S_instanceless = true;\n+  typedef simple_alloc<_Tp, _Pthread_alloc_template<> > _Alloc_type;\n+  typedef pthread_allocator<_Tp> allocator_type;\n+};\n+\n+\n+#endif /* __STL_USE_STD_ALLOCATORS */\n+\n+__STL_END_NAMESPACE\n+\n+#endif /* _CPP_BITS_PTHREAD_ALLOCIMPL_H */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "7a0e1d5db22a577ac2a38b6d852958e39a4aac44", "filename": "libstdc++-v3/include/bits/sbuf_iter.h", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsbuf_iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsbuf_iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsbuf_iter.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,264 @@\n+// Streambuf iterators\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// XXX Should specialize copy, find algorithms for streambuf iterators.\n+\n+#ifndef _CPP_BITS_SBUF_ITER_H\n+#define _CPP_BITS_SBUF_ITER_H 1\n+\n+namespace std\n+{\n+\n+  template<typename _CharT, typename _Traits>\n+    class ostreambuf_iterator\n+#if 0      // XXX this is standard:\n+    : public iterator<output_iterator_tag, _CharT, void, void, void>\n+#else\n+    : public output_iterator\n+#endif\n+    {\n+    public:\n+\n+      // Types:\n+      typedef _CharT                       \t char_type;\n+      typedef _Traits                          traits_type;\n+      typedef basic_streambuf<_CharT, _Traits> streambuf_type;\n+      typedef basic_ostream<_CharT, _Traits>   ostream_type;\n+      \n+      inline \n+      ostreambuf_iterator(ostream_type& __s) throw ()\n+      : _M_sbuf(__s.rdbuf()), _M_failed(false) { }\n+      \n+      ostreambuf_iterator(streambuf_type* __s) throw ()\n+      : _M_sbuf(__s), _M_failed(false) { }\n+\n+      ostreambuf_iterator& \n+      operator=(_CharT __c);\n+\n+      ostreambuf_iterator& \n+      operator*() throw()\n+      { return *this; }\n+\n+      ostreambuf_iterator& \n+      operator++(int) throw()\n+      { return *this; }\n+\n+      ostreambuf_iterator& \n+      operator++() throw()\n+      { return *this; }\n+\n+      bool \n+      failed() const throw()\n+      { return _M_failed; }\n+\n+    private:\n+      streambuf_type* \t_M_sbuf;\n+      bool \t\t_M_failed;\n+\n+#if 0\n+      template<>\n+        friend char const*\n+        copy(char const* __first, char const* __last,\n+             ostreambuf_iterator<char,char_traits<char> > __to);\n+      template<>\n+        friend wchar_t const*\n+        copy(wchar_t const* __first, wchar_t const* __last,\n+             ostreambuf_iterator<wchar_t,char_traits<wchar_t> > __to);\n+#endif\n+    };\n+\n+  template<typename _CharT, typename _Traits>\n+    inline ostreambuf_iterator<_CharT, _Traits>&\n+    ostreambuf_iterator<_CharT, _Traits>::operator=(_CharT __c)\n+    {\n+      if (!_M_failed &&\n+          _Traits::eq_int_type(_M_sbuf->sputc(__c),_Traits::eof()))\n+      _M_failed = true;\n+      return *this;\n+    }\n+\n+\n+#if 0\n+  // Optimized specializations of standard algorithms\n+  // These are specialized only for standard types\n+  // (with no unbound arguments) to avoid creating\n+  // overload problems with user specializations.\n+\n+  template<>\n+    char const*\n+    copy(char const* __first, char const* __last,\n+\t ostreambuf_iterator<char,char_traits<char> > __to)\n+    {\n+      if (!__to._M_failed)\n+\t__to._M_sbuf->sputn(__first, __last-__first);\n+      return __last;\n+    }\n+\n+  template<>\n+    wchar_t const*\n+    copy(wchar_t const* __first, wchar_t const* __last,\n+\t ostreambuf_iterator<whar_t,char_traits<wchar_t> > __to)\n+    {\n+      if (!__to._M_failed)\n+\t__to._M_sbuf->sputn(__first, __last-__first);\n+      return __last;\n+    }\n+#endif\n+\n+  // 24.5.3 Template class istreambuf_iterator\n+  template<class _CharT, class _Traits>\n+    class istreambuf_iterator\n+    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,\n+    \t\t      _CharT*, _CharT&>\n+    {\n+    public:\n+\n+      // Types:\n+      typedef _CharT                         \t\tchar_type;\n+      typedef _Traits                        \t\ttraits_type;\n+      typedef typename _Traits::int_type     \t\tint_type;\n+      typedef basic_streambuf<_CharT, _Traits> \t\tstreambuf_type;\n+      typedef basic_istream<_CharT, _Traits>         \tistream_type;\n+      // Non-standard Types:\n+      typedef istreambuf_iterator<_CharT, _Traits>\t__istreambufiter_type;\n+\n+      istreambuf_iterator() throw() \n+      : _M_istreambuf(NULL), _M_c(-2) { }\n+      \n+      istreambuf_iterator(istream_type& __s) throw()\n+      : _M_istreambuf(__s.rdbuf()), _M_c(-2) { }\n+\n+      istreambuf_iterator(streambuf_type* __s) throw()\n+      : _M_istreambuf(__s), _M_c(-2) { }\n+       \n+      // NB: This should really have an int_type return\n+      // value, so \"end of stream\" postion can be checked without\n+      // hacking.\n+      char_type \n+      operator*() const\n+      { \n+\t// The result of operator*() on an end of stream is undefined.\n+\tchar_type __ret;\n+\tif (_M_istreambuf && _M_c != static_cast<int_type>(-2))\n+\t  __ret = _M_c;\n+\telse if (_M_istreambuf)\n+\t  __ret = traits_type::to_char_type(_M_istreambuf->sgetc()); \n+\telse\n+\t  __ret = static_cast<char_type>(traits_type::eof());\n+\treturn __ret;\n+      }\n+\t\n+      __istreambufiter_type& \n+      operator++()\n+      { \n+\tif (_M_istreambuf)\n+\t  _M_istreambuf->sbumpc();\n+\t_M_c = -2;\n+\treturn *this; \n+      }\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+      // 14882 says return a proxy object. It should be a const\n+      // proxy object, but since this class is not mandated, it\n+      // should allow this signature:\n+      const __istreambufiter_type\n+      operator++(int)\n+      {\n+\tif (_M_istreambuf)\n+\t  _M_c = _M_istreambuf->sbumpc();\n+\treturn *this; \n+      }\n+#endif\n+\n+      bool \n+      equal(const __istreambufiter_type& __b)\n+      { \n+\tint_type __eof = traits_type::eof();\n+\tbool __thiseof = !_M_istreambuf || _M_istreambuf->sgetc() == __eof;\n+\tbool __beof = !__b._M_istreambuf \n+\t  \t      || __b._M_istreambuf->sgetc() == __eof;\n+\treturn (__thiseof && __beof || (!__thiseof && !__beof));\n+      }\n+\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+      // 110 istreambuf_iterator::equal not const\n+      // NB: there is also number 111 pending on this function.\n+      bool \n+      equal(const __istreambufiter_type& __b) const\n+      {\n+\tint_type __eof = traits_type::eof();\n+\tbool __thiseof = !_M_istreambuf || _M_istreambuf->sgetc() == __eof;\n+\tbool __beof = !__b._M_istreambuf \n+\t  \t      || __b._M_istreambuf->sgetc() == __eof;\n+\treturn (__thiseof && __beof || (!__thiseof && !__beof));\n+      }\n+#endif\n+\n+    private:\n+      // 24.5.3 istreambuf_iterator \n+      // p 1 \n+      // If the end of stream is reached (streambuf_type::sgetc()\n+      // returns traits_type::eof()), the iterator becomes equal to\n+      // the \"end of stream\" iterator value.\n+      // NB: This implementation assumes the \"end of stream\" value\n+      // is EOF, or -1.\n+      streambuf_type* \t\t_M_istreambuf;  \n+      int_type \t\t\t_M_c;\n+    };\n+\n+  template<typename _CharT, typename _Traits>\n+    inline bool \n+    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,\n+\t       const istreambuf_iterator<_CharT, _Traits>& __b)\n+    { return __a.equal(__b); }\n+\n+  template<typename _CharT, typename _Traits>\n+    inline bool \n+    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,\n+\t       const istreambuf_iterator<_CharT, _Traits>& __b)\n+    { return !__a.equal(__b); }\n+\n+} // std::\n+\n+#endif /* _CPP_BITS_SBUF_ITER_H */\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "af582fb33452a2ecd7b4ae1782d9720d51f43404", "filename": "libstdc++-v3/include/bits/sequence_concepts.h", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsequence_concepts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsequence_concepts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsequence_concepts.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright (c) 1999\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef STL_SEQUENCE_CONCEPTS_H\n+#define STL_SEQUENCE_CONCEPTS_H\n+\n+#include <bits/container_concepts.h>\n+\n+#ifdef __STL_USE_CONCEPT_CHECKS\n+\n+// This file covers the following concepts:\n+//       _Sequence\n+//       _FrontInsertionSequence\n+//       _BackInsertionSequence\n+\n+struct _ERROR_IN_STL_SEQ {\n+\n+  template <class _XX>\n+  static void\n+  __fill_constructor_requirement_violation(_XX& __s) {\n+    typename _XX::value_type __t = typename _XX::value_type();\n+    typename _XX::difference_type __n = typename _XX::difference_type();\n+    _XX __x(__n, __t);\n+    __sink_unused_warning(__x);\n+  }\n+  template <class _XX>\n+  static void\n+  __fill_default_constructor_requirement_violation(_XX& __s) {\n+    _STL_ERROR::__default_constructor_requirement_violation(*__s.begin());\n+    typename _XX::difference_type __n = typename _XX::difference_type();\n+    _XX __x(__n);\n+    __sink_unused_warning(__x);\n+  }  \n+  template <class _XX>\n+  static void\n+  __range_constructor_requirement_violation(_XX& __s) {\n+    _XX __x(__s.begin(), __s.end());\n+    __sink_unused_warning(__x);\n+  }\n+  template <class _XX>\n+  static void\n+  __insert_function_requirement_violation(_XX& __s) {\n+    typename _XX::value_type __t = typename _XX::value_type();\n+    typename _XX::iterator __p = typename _XX::iterator();\n+    __p = __s.insert(__p, __t);\n+  }\n+  template <class _XX>\n+  static void\n+  __fill_insert_function_requirement_violation(_XX& __s) {\n+    typename _XX::value_type __t = typename _XX::value_type();\n+    typename _XX::iterator __p = typename _XX::iterator();\n+    typename _XX::difference_type __n = typename _XX::difference_type();\n+    __s.insert(__p, __n, __t);\n+  }\n+  template <class _XX>\n+  static void\n+  __range_insert_function_requirement_violation(_XX& __s) {\n+    typename _XX::iterator __p = typename _XX::iterator();\n+    typename _XX::iterator __i = typename _XX::iterator();\n+    typename _XX::iterator __j = typename _XX::iterator();\n+    __s.insert(__p, __i, __j);\n+  }\n+  template <class _XX>\n+  static void\n+  __insert_element_function_requirement_violation(_XX& __s) {\n+    typename _XX::value_type __t = typename _XX::value_type();\n+    std::pair<typename _XX::iterator, bool> __r;\n+    __r = __s.insert(__t);\n+    __sink_unused_warning(__r);\n+  }\n+  template <class _XX>\n+  static void\n+  __unconditional_insert_element_function_requirement_violation(_XX& __s) {\n+    typename _XX::value_type __t = typename _XX::value_type();\n+    typename _XX::iterator __p;\n+    __p = __s.insert(__t);\n+    __sink_unused_warning(__p);\n+  }\n+  template <class _XX>\n+  static void\n+  __erase_function_requirement_violation(_XX& __s) {\n+    typename _XX::iterator __p = typename _XX::iterator();\n+    __p = __s.erase(__p);\n+  }\n+  template <class _XX>\n+  static void\n+  __range_erase_function_requirement_violation(_XX& __s) {\n+    typename _XX::iterator __p = typename _XX::iterator();\n+    typename _XX::iterator __q = typename _XX::iterator();\n+    __p = __s.erase(__p, __q);\n+  }\n+  template <class _XX>\n+  static void\n+  __const_front_function_requirement_violation(const _XX& __s) {\n+    typename _XX::const_reference __t = __s.front();\n+    __sink_unused_warning(__t);\n+  }\n+  template <class _XX>\n+  static void\n+  __front_function_requirement_violation(_XX& __s) {\n+    typename _XX::reference __t = __s.front();\n+    __const_front_function_requirement_violation(__s);\n+    __sink_unused_warning(__t);\n+  }\n+  template <class _XX>\n+  static void\n+  __const_back_function_requirement_violation(const _XX& __s) {\n+    typename _XX::const_reference __t = __s.back();\n+    __sink_unused_warning(__t);\n+  }\n+  template <class _XX>\n+  static void\n+  __back_function_requirement_violation(_XX& __s) {\n+    typename _XX::reference __t = __s.back();\n+    __const_back_function_requirement_violation(__s);\n+    __sink_unused_warning(__t);\n+  }\n+  template <class _XX>\n+  static void\n+  __push_front_function_requirement_violation(_XX& __s) {\n+    typename _XX::value_type __t = typename _XX::value_type();\n+    __s.push_front(__t);\n+  }\n+  template <class _XX>\n+  static void\n+  __pop_front_function_requirement_violation(_XX& __s) {\n+    __s.pop_front();\n+  }\n+  template <class _XX>\n+  static void\n+  __push_back_function_requirement_violation(_XX& __s) {\n+    typename _XX::value_type __t = typename _XX::value_type();\n+    __s.push_back(__t);\n+  }\n+  template <class _XX>\n+  static void\n+  __pop_back_function_requirement_violation(_XX& __s) {\n+    __s.pop_back();\n+  }\n+\n+};\n+\n+/* Sequence Containers */\n+\n+template <class _Sequence>\n+struct _Sequence_concept_specification {\n+static void\n+_Sequence_requirement_violation(_Sequence __s) {\n+  // Refinement of ForwardContainer\n+  _ForwardContainer_concept_specification<_Sequence>::_ForwardContainer_requirement_violation(__s);\n+  // Refinement of DefaultConstructible\n+  _DefaultConstructible_concept_specification<_Sequence>::_DefaultConstructible_requirement_violation(__s);\n+  // Valid Expressions\n+  _ERROR_IN_STL_SEQ::__fill_constructor_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__fill_default_constructor_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__range_constructor_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__insert_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__fill_insert_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__range_insert_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__erase_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__range_erase_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__front_function_requirement_violation(__s);\n+}\n+};\n+\n+template <class _FrontInsertionSequence>\n+struct _FrontInsertionSequence_concept_specification {\n+static void\n+_FrontInsertionSequence_requirement_violation(_FrontInsertionSequence __s) {\n+  // Refinement of Sequence\n+  _Sequence_concept_specification<_FrontInsertionSequence>::_Sequence_requirement_violation(__s);\n+  // Valid Expressions\n+  _ERROR_IN_STL_SEQ::__push_front_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__pop_front_function_requirement_violation(__s);\n+}\n+};\n+\n+template <class _BackInsertionSequence>\n+struct _BackInsertionSequence_concept_specification {\n+static void\n+_BackInsertionSequence_requirement_violation(_BackInsertionSequence __s) {\n+  // Refinement of Sequence\n+  _Sequence_concept_specification<_BackInsertionSequence>::_Sequence_requirement_violation(__s);\n+  // Valid Expressions\n+  _ERROR_IN_STL_SEQ::__back_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__push_back_function_requirement_violation(__s);\n+  _ERROR_IN_STL_SEQ::__pop_back_function_requirement_violation(__s);\n+}\n+};\n+\n+#endif /* if __STL_USE_CONCEPT_CHECKS */\n+\n+\n+#endif /* STL_SEQUENCE_CONCEPTS_H */"}, {"sha": "3e4f7a743f6dcd851c60b713d40a083d57bf6694", "filename": "libstdc++-v3/include/bits/slice.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,77 @@\n+// The template and inlines for the -*- C++ -*- slice class.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef _CPP_BITS_SLICE_H\n+#define _CPP_BITS_SLICE_H\n+\n+namespace std {\n+\n+class slice\n+{\n+public:\n+    slice ();\n+    slice (size_t, size_t, size_t);\n+\n+    size_t start () const;\n+    size_t size () const;\n+    size_t stride () const;\n+\n+private:\n+    size_t _M_off;                      // offset\n+    size_t _M_sz;\t\t\t// size\n+    size_t _M_st;\t\t\t// stride unit\n+};\n+\n+inline slice::slice () {}\n+\n+inline slice::slice (size_t __o, size_t __d, size_t __s)\n+        : _M_off (__o), _M_sz (__d), _M_st (__s) {}\n+\n+inline size_t\n+slice::start () const\n+  { return _M_off; }\n+\n+inline size_t\n+slice::size () const\n+  { return _M_sz; }\n+\n+inline size_t\n+slice::stride () const\n+  { return _M_st; }\n+\n+} // std::\n+\n+\n+#endif /* _CPP_BITS_SLICE_H */\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "4681cb590dc8539ce39bd68b1d5aaca096feca19", "filename": "libstdc++-v3/include/bits/slice_array.h", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice_array.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,161 @@\n+// The template and inlines for the -*- C++ -*- slice_array class.\n+\n+// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// Written by Gabriel Dos Reis <Gabriel.Dos-Reis@DPTMaths.ENS-Cachan.Fr>\n+\n+#ifndef _CPP_BITS_SLICE_ARRAY_H\n+#define _CPP_BITS_SLICE_ARRAY_H 1\n+\n+namespace std {\n+    \n+    template<typename _Tp>\n+    class slice_array\n+    {\n+    public:\n+        typedef _Tp value_type;\n+        \n+        void operator=   (const valarray<_Tp>&) const;\n+        void operator*=  (const valarray<_Tp>&) const;\n+        void operator/=  (const valarray<_Tp>&) const;\n+        void operator%=  (const valarray<_Tp>&) const;\n+        void operator+=  (const valarray<_Tp>&) const;\n+        void operator-=  (const valarray<_Tp>&) const;\n+        void operator^=  (const valarray<_Tp>&) const;\n+        void operator&=  (const valarray<_Tp>&) const;\n+        void operator|=  (const valarray<_Tp>&) const;\n+        void operator<<= (const valarray<_Tp>&) const;\n+        void operator>>= (const valarray<_Tp>&) const;\n+        void operator= (const _Tp &);\n+        //        ~slice_array ();\n+        \n+        template<class _Dom>\n+        void operator=   (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator*=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator/=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator%=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator+=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator-=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator^=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator&=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator|=  (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator<<= (const _Expr<_Dom,_Tp>&) const;\n+        template<class _Dom>\n+        void operator>>= (const _Expr<_Dom,_Tp>&) const;\n+        \n+    private:\n+        friend class valarray<_Tp>;\n+        slice_array(_Array<_Tp>, const slice&);\n+        \n+        const size_t     _M_sz;\n+        const size_t     _M_stride;\n+        const _Array<_Tp> _M_array;\n+        \n+        // this constructor is implemented since we need to return a value.\n+        slice_array (const slice_array&);\n+\n+        // not implemented\n+        slice_array ();\n+        slice_array& operator= (const slice_array&);\n+    };\n+\n+    template<typename _Tp>\n+    inline slice_array<_Tp>::slice_array (_Array<_Tp> __a, const slice& __s)\n+            : _M_sz (__s.size ()), _M_stride (__s.stride ()),\n+              _M_array (__a.begin () + __s.start ()) {}\n+\n+    \n+    template<typename _Tp>\n+    inline slice_array<_Tp>::slice_array(const slice_array<_Tp>& a)\n+            : _M_sz(a._M_sz), _M_stride(a._M_stride), _M_array(a._M_array) {}\n+    \n+    //    template<typename _Tp>\n+    //    inline slice_array<_Tp>::~slice_array () {}\n+\n+    template<typename _Tp>\n+    inline void\n+    slice_array<_Tp>::operator= (const _Tp& __t) \n+    { __valarray_fill (_M_array, _M_sz, _M_stride, __t); }\n+    \n+    template<typename _Tp>\n+    inline void\n+    slice_array<_Tp>::operator= (const valarray<_Tp>& __v) const\n+    { __valarray_copy (_Array<_Tp> (__v), _M_array, _M_sz, _M_stride); }\n+    \n+    template<typename _Tp>\n+    template<class _Dom>\n+    inline void\n+    slice_array<_Tp>::operator= (const _Expr<_Dom,_Tp>& __e) const\n+    { __valarray_copy (__e, _M_sz, _M_array, _M_stride); }\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+#define _DEFINE_VALARRAY_OPERATOR(op, name)\t\t\t\t\\\n+template<typename _Tp>\t\t\t\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+slice_array<_Tp>::operator op##= (const valarray<_Tp>& __v) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  _Array_augmented_##name (_M_array, _M_sz, _M_stride, _Array<_Tp> (__v));\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename _Tp> template<class _Dom>\t\t\t\t\\\n+inline void\t\t\t\t\t\t\t\t\\\n+slice_array<_Tp>::operator op##= (const _Expr<_Dom,_Tp>& __e) const\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+    _Array_augmented_##name (_M_array, _M_stride, __e, _M_sz);\t\t\\\n+}\n+        \n+\n+_DEFINE_VALARRAY_OPERATOR(*, multiplies)\n+_DEFINE_VALARRAY_OPERATOR(/, divides)\n+_DEFINE_VALARRAY_OPERATOR(%, modulus)\n+_DEFINE_VALARRAY_OPERATOR(+, plus)\n+_DEFINE_VALARRAY_OPERATOR(-, minus)\n+_DEFINE_VALARRAY_OPERATOR(^, xor)\n+_DEFINE_VALARRAY_OPERATOR(&, and)\n+_DEFINE_VALARRAY_OPERATOR(|, or)\n+_DEFINE_VALARRAY_OPERATOR(<<, shift_left)\n+_DEFINE_VALARRAY_OPERATOR(>>, shift_right)\n+\n+#undef _DEFINE_VALARRAY_OPERATOR\n+\n+} // std::\n+\n+#endif /* _CPP_BITS_SLICE_ARRAY_H */\n+\n+// Local Variables:\n+// mode:c++\n+// End:"}, {"sha": "5c737b4fa2e5888c20b96f8fcc6b7bc50dd587e7", "filename": "libstdc++-v3/include/bits/sstream.tcc", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,220 @@\n+// String based streams -*- C++ -*-\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.7  String-based streams\n+//\n+\n+#ifndef _CPP_BITS_SSTREAM_TCC\n+#define _CPP_BITS_SSTREAM_TCC\t1\n+\n+#include <bits/std_sstream.h>\n+\n+namespace std {\n+\n+  template <class _CharT, class _Traits, class _Alloc>\n+    basic_stringbuf<_CharT, _Traits, _Alloc>::int_type \n+    basic_stringbuf<_CharT, _Traits, _Alloc>::\n+    pbackfail(int_type __c)\n+    {\n+      int_type __ret = traits_type::eof();\n+      bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());\n+      bool __testpos = _M_in_cur && _M_in_beg < _M_in_cur; \n+      \n+      // Try to put back __c into input sequence in one of three ways.\n+      // Order these tests done in is unspecified by the standard.\n+      if (__testpos)\n+\t{\n+\t  if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1])\n+\t      && !__testeof)\n+\t    {\n+\t      --_M_in_cur;\n+\t      __ret = __c;\n+\t    }\n+\t  else if (!__testeof)\n+\t    {\n+\t      --_M_in_cur;\n+\t      *_M_in_cur = traits_type::to_char_type(__c);\n+\t      __ret = __c;\n+\t    }\n+\t  else if (__testeof)\n+\t    {\n+\t      --_M_in_cur;\n+\t      __ret = traits_type::not_eof(__c);\n+\t    }\n+\t}\n+      return __ret;\n+    }\n+  \n+  template <class _CharT, class _Traits, class _Alloc>\n+    basic_stringbuf<_CharT, _Traits, _Alloc>::int_type \n+    basic_stringbuf<_CharT, _Traits, _Alloc>::\n+    overflow(int_type __c)\n+    {\n+      int_type __ret = traits_type::eof();\n+      bool __testeof = traits_type::eq_int_type(__c, __ret);\n+      bool __testwrite = _M_out_cur < _M_buf + _M_buf_size;\n+      bool __testout = _M_mode & ios_base::out;\n+\n+      // Try to append __c into output sequence in one of two ways.\n+      // Order these tests done in is unspecified by the standard.\n+      if (__testout)\n+\t{\n+\t  if (!__testeof)\n+\t    {\n+\t      __size_type __len = max(_M_buf_size, _M_buf_size_opt);\n+\t      __len *= 2;\n+\n+\t      if (__testwrite)\n+\t\t__ret = this->sputc(__c);\n+\t      else if (__len <= _M_string.max_size())\n+\t\t{\n+\t\t  // Force-allocate, re-sync.\n+\t\t  _M_string = this->str();\n+\t\t  _M_string.reserve(__len);\n+\t\t  _M_buf_size = static_cast<int_type>(__len);\n+\t\t  _M_really_sync(_M_in_cur - _M_in_beg, \n+\t\t\t\t _M_out_cur - _M_out_beg);\n+\t\t  *_M_out_cur = traits_type::to_char_type(__c);\n+\t\t  _M_out_cur_move(1);\n+\t\t  __ret = __c;\n+\t\t}\n+\t    }\n+\t  else\n+\t    __ret = traits_type::not_eof(__c);\n+\t}\n+      return __ret;\n+    }\n+\n+  template <class _CharT, class _Traits, class _Alloc>\n+    basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type\n+    basic_stringbuf<_CharT, _Traits, _Alloc>::\n+    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)\n+    {\n+      pos_type __ret =  pos_type(off_type(-1)); \n+      bool __testin = __mode & ios_base::in && _M_mode & ios_base::in;\n+      bool __testout = __mode & ios_base::out && _M_mode & ios_base::out;\n+      bool __testboth = __testin && __testout && __way != ios_base::cur;\n+      \n+      if (_M_buf_size && ((__testin != __testout) || __testboth))\n+\t{\n+\t  char_type* __beg = _M_buf;\n+\t  char_type* __curi = NULL;\n+\t  char_type* __curo = NULL;\n+\t  char_type* __endi = NULL;\n+\t  char_type* __endo = NULL;\n+\n+\t  if (__testin)\n+\t    {\n+\t      __curi = this->gptr();\n+\t      __endi = this->egptr();\n+\t    }\n+\t  if (__testout)\n+\t    {\n+\t      __curo = this->pptr();\n+\t      __endo = this->epptr();\n+\t    }\n+\n+\t  off_type __newoffi = 0;\n+\t  off_type __newoffo = 0;\n+\t  if (__way == ios_base::cur)\n+\t    {\n+\t      __newoffi = __curi - __beg;\n+\t      __newoffo = __curo - __beg;\n+\t    }\n+\t  else if (__way == ios_base::end)\n+\t    {\n+\t      __newoffi = __endi - __beg;\n+\t      __newoffo = __endo - __beg;\n+\t    }\n+\n+\t  if (__testin\n+\t      && __newoffi + __off >= 0 && __endi - __beg >= __newoffi + __off)\n+\t    {\n+\t      _M_in_cur = __beg + __newoffi + __off;\n+\t      __ret = pos_type(__newoffi);\n+\t    }\n+\t  if (__testout\n+\t      && __newoffo + __off >= 0 && __endo - __beg >= __newoffo + __off)\n+\t    {\n+\t      _M_out_cur_move(__newoffo + __off - (_M_out_cur - __beg));\n+\t      __ret = pos_type(__newoffo);\n+\t    }\n+\t}\n+      return __ret;\n+    }\n+\n+  template <class _CharT, class _Traits, class _Alloc>\n+    basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type\n+    basic_stringbuf<_CharT, _Traits, _Alloc>::\n+    seekpos(pos_type __sp, ios_base::openmode __mode)\n+    {\n+      pos_type __ret =  pos_type(off_type(-1)); \n+      off_type __pos = __sp._M_position();\n+      char_type* __beg = NULL;\n+      char_type* __end = NULL;\n+      bool __testin = __mode & ios_base::in && _M_mode & ios_base::in;\n+      bool __testout = __mode & ios_base::out && _M_mode & ios_base::out;\n+      \n+      if (__testin)\n+\t{\n+\t  __beg = this->eback();\n+\t  __end = this->egptr();\n+\t}\n+      if (__testout)\n+\t{\n+\t  __beg = this->pbase();\n+\t  __end = _M_buf + _M_buf_size;\n+\t}\n+ \n+      if (0 <= __pos && __pos <= __end - __beg)\n+\t{\n+\t  // Need to set both of these if applicable\n+\t  if (__testin)\n+\t    _M_in_cur = _M_in_beg + __pos;\n+\t  if (__testout)\n+\t    _M_out_cur_move((__pos) - (_M_out_cur - __beg));\n+\t  __ret = pos_type(off_type(__pos));\n+\t}\n+      \n+      return __ret;\n+    }\n+\n+} // namespace std\n+\n+#endif\t/* _CPP_BITS_SSTREAM_TCC */\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "3f0842655066ffc6521da34a1ae93e9a323539dd", "filename": "libstdc++-v3/include/bits/std_algorithm.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_algorithm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_algorithm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_algorithm.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,40 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_ALGORITHM\n+#define _CPP_ALGORITHM 1\n+\n+#include <bits/stl_algobase.h>\n+#include <bits/stl_construct.h>\n+#include <bits/stl_uninitialized.h>\n+#include <bits/stl_tempbuf.h>\n+#include <bits/stl_algo.h>\n+\n+#endif /* _CPP_ALGORITHM */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "52f567854cb30efa7dc2ef676df7ee0d01eafcb2", "filename": "libstdc++-v3/include/bits/std_bitset.h", "status": "added", "additions": 1076, "deletions": 0, "changes": 1076, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_bitset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_bitset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_bitset.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,1076 @@\n+/*\n+ * Copyright (c) 1998\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */ \n+\n+#ifndef __SGI_STL_BITSET\n+#define __SGI_STL_BITSET\n+\n+// A bitset of size N has N % (sizeof(unsigned long) * CHAR_BIT) unused \n+// bits.  (They are the high- order bits in the highest word.)  It is\n+// a class invariant of class bitset<> that those unused bits are\n+// always zero.\n+\n+// Most of the actual code isn't contained in bitset<> itself, but in the \n+// base class _Base_bitset.  The base class works with whole words, not with\n+// individual bits.  This allows us to specialize _Base_bitset for the\n+// important special case where the bitset is only a single word.\n+\n+// The C++ standard does not define the precise semantics of operator[].\n+// In this implementation the const version of operator[] is equivalent\n+// to test(), except that it does no range checking.  The non-const version\n+// returns a reference to a bit, again without doing any range checking.\n+\n+\n+#include <bits/std_cstddef.h>     // for size_t\n+#include <bits/std_cstring.h>     // for memset\n+#include <bits/std_string.h>\n+#include <bits/std_stdexcept.h>   // for invalid_argument, out_of_range, \n+\t\t\t\t  // overflow_error\n+\n+#ifdef __STL_USE_NEW_IOSTREAMS \n+#include <iostream>\n+#else\n+#include <bits/std_iostream.h>   // for istream, ostream\n+#endif\n+\n+#define __BITS_PER_WORD (CHAR_BIT*sizeof(unsigned long))\n+#define __BITSET_WORDS(__n) \\\n+ ((__n) < 1 ? 1 : ((__n) + __BITS_PER_WORD - 1)/__BITS_PER_WORD)\n+\n+__STL_BEGIN_NAMESPACE\n+\n+#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n+#pragma set woff 1209\n+#endif\n+\n+// structure to aid in counting bits\n+template<bool __dummy> \n+struct _Bit_count {\n+  static unsigned char _S_bit_count[256];\n+};\n+\n+// Mapping from 8 bit unsigned integers to the index of the first one\n+// bit:\n+template<bool __dummy> \n+struct _First_one {\n+  static unsigned char _S_first_one[256];\n+};\n+\n+//\n+// Base class: general case.\n+//\n+\n+template<size_t _Nw>\n+struct _Base_bitset {\n+  typedef unsigned long _WordT;\n+\n+  _WordT _M_w[_Nw];                // 0 is the least significant word.\n+\n+  _Base_bitset( void ) { _M_do_reset(); }\n+  _Base_bitset(unsigned long __val) {\n+    _M_do_reset();\n+    _M_w[0] = __val;\n+  }\n+\n+  static size_t _S_whichword( size_t __pos )\n+    { return __pos / __BITS_PER_WORD; }\n+  static size_t _S_whichbyte( size_t __pos )\n+    { return (__pos % __BITS_PER_WORD) / CHAR_BIT; }\n+  static size_t _S_whichbit( size_t __pos )\n+    { return __pos % __BITS_PER_WORD; }\n+  static _WordT _S_maskbit( size_t __pos )\n+    { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n+\n+  _WordT& _M_getword(size_t __pos)       { return _M_w[_S_whichword(__pos)]; }\n+  _WordT  _M_getword(size_t __pos) const { return _M_w[_S_whichword(__pos)]; }\n+\n+  _WordT& _M_hiword()       { return _M_w[_Nw - 1]; }\n+  _WordT  _M_hiword() const { return _M_w[_Nw - 1]; }\n+\n+  void _M_do_and(const _Base_bitset<_Nw>& __x) {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] &= __x._M_w[__i];\n+    }\n+  }\n+\n+  void _M_do_or(const _Base_bitset<_Nw>& __x) {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] |= __x._M_w[__i];\n+    }\n+  }\n+\n+  void _M_do_xor(const _Base_bitset<_Nw>& __x) {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] ^= __x._M_w[__i];\n+    }\n+  }\n+\n+  void _M_do_left_shift(size_t __shift);\n+  void _M_do_right_shift(size_t __shift);\n+\n+  void _M_do_flip() {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] = ~_M_w[__i];\n+    }\n+  }\n+\n+  void _M_do_set() {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      _M_w[__i] = ~static_cast<_WordT>(0);\n+    }\n+  }\n+\n+  void _M_do_reset() { memset(_M_w, 0, _Nw * sizeof(_WordT)); }\n+\n+  bool _M_is_equal(const _Base_bitset<_Nw>& __x) const {\n+    for (size_t __i = 0; __i < _Nw; ++__i) {\n+      if (_M_w[__i] != __x._M_w[__i])\n+        return false;\n+    }\n+    return true;\n+  }\n+\n+  bool _M_is_any() const {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+      if ( _M_w[__i] != static_cast<_WordT>(0) )\n+        return true;\n+    }\n+    return false;\n+  }\n+\n+  size_t _M_do_count() const {\n+    size_t __result = 0;\n+    const unsigned char* __byte_ptr = (const unsigned char*)_M_w;\n+    const unsigned char* __end_ptr = (const unsigned char*)(_M_w+_Nw);\n+\n+    while ( __byte_ptr < __end_ptr ) {\n+      __result += _Bit_count<true>::_S_bit_count[*__byte_ptr];\n+      __byte_ptr++;\n+    }\n+    return __result;\n+  }\n+\n+  unsigned long _M_do_to_ulong() const; \n+\n+  // find first \"on\" bit\n+  size_t _M_do_find_first(size_t __not_found) const;\n+\n+  // find the next \"on\" bit that follows \"prev\"\n+  size_t _M_do_find_next(size_t __prev, size_t __not_found) const;\n+};\n+\n+//\n+// Definitions of non-inline functions from _Base_bitset.\n+// \n+\n+template<size_t _Nw>\n+void _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift) \n+{\n+  if (__shift != 0) {\n+    const size_t __wshift = __shift / __BITS_PER_WORD;\n+    const size_t __offset = __shift % __BITS_PER_WORD;\n+\n+    if (__offset == 0)\n+      for (size_t __n = _Nw - 1; __n >= __wshift; --__n)\n+        _M_w[__n] = _M_w[__n - __wshift];\n+\n+    else {\n+      const size_t __sub_offset = __BITS_PER_WORD - __offset;\n+      for (size_t __n = _Nw - 1; __n > __wshift; --__n)\n+        _M_w[__n] = (_M_w[__n - __wshift] << __offset) | \n+                    (_M_w[__n - __wshift - 1] >> __sub_offset);\n+      _M_w[__wshift] = _M_w[0] << __offset;\n+    }\n+\n+    fill(_M_w + 0, _M_w + __wshift, static_cast<_WordT>(0));\n+  }\n+}\n+\n+template<size_t _Nw>\n+void _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift) \n+{\n+  if (__shift != 0) {\n+    const size_t __wshift = __shift / __BITS_PER_WORD;\n+    const size_t __offset = __shift % __BITS_PER_WORD;\n+    const size_t __limit = _Nw - __wshift - 1;\n+\n+    if (__offset == 0)\n+      for (size_t __n = 0; __n <= __limit; ++__n)\n+        _M_w[__n] = _M_w[__n + __wshift];\n+\n+    else {\n+      const size_t __sub_offset = __BITS_PER_WORD - __offset;\n+      for (size_t __n = 0; __n < __limit; ++__n)\n+        _M_w[__n] = (_M_w[__n + __wshift] >> __offset) |\n+                    (_M_w[__n + __wshift + 1] << __sub_offset);\n+      _M_w[__limit] = _M_w[_Nw-1] >> __offset;\n+    }\n+\n+    fill(_M_w + __limit + 1, _M_w + _Nw, static_cast<_WordT>(0));\n+  }\n+}\n+\n+template<size_t _Nw>\n+unsigned long _Base_bitset<_Nw>::_M_do_to_ulong() const\n+{\n+  for (size_t __i = 1; __i < _Nw; ++__i) \n+    if (_M_w[__i]) \n+      __STL_THROW(overflow_error(\"bitset\"));\n+  \n+  return _M_w[0];\n+}\n+\n+template<size_t _Nw>\n+size_t _Base_bitset<_Nw>::_M_do_find_first(size_t __not_found) const \n+{\n+  for ( size_t __i = 0; __i < _Nw; __i++ ) {\n+    _WordT __thisword = _M_w[__i];\n+    if ( __thisword != static_cast<_WordT>(0) ) {\n+      // find byte within word\n+      for ( size_t __j = 0; __j < sizeof(_WordT); __j++ ) {\n+        unsigned char __this_byte\n+          = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+        if ( __this_byte )\n+          return __i*__BITS_PER_WORD + __j*CHAR_BIT +\n+            _First_one<true>::_S_first_one[__this_byte];\n+\n+        __thisword >>= CHAR_BIT;\n+      }\n+    }\n+  }\n+  // not found, so return an indication of failure.\n+  return __not_found;\n+}\n+\n+template<size_t _Nw>\n+size_t\n+_Base_bitset<_Nw>::_M_do_find_next(size_t __prev, size_t __not_found) const\n+{\n+  // make bound inclusive\n+  ++__prev;\n+\n+  // check out of bounds\n+  if ( __prev >= _Nw * __BITS_PER_WORD )\n+    return __not_found;\n+\n+    // search first word\n+  size_t __i = _S_whichword(__prev);\n+  _WordT __thisword = _M_w[__i];\n+\n+    // mask off bits below bound\n+  __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);\n+\n+  if ( __thisword != static_cast<_WordT>(0) ) {\n+    // find byte within word\n+    // get first byte into place\n+    __thisword >>= _S_whichbyte(__prev) * CHAR_BIT;\n+    for ( size_t __j = _S_whichbyte(__prev); __j < sizeof(_WordT); __j++ ) {\n+      unsigned char __this_byte\n+        = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+      if ( __this_byte )\n+        return __i*__BITS_PER_WORD + __j*CHAR_BIT +\n+          _First_one<true>::_S_first_one[__this_byte];\n+\n+      __thisword >>= CHAR_BIT;\n+    }\n+  }\n+\n+  // check subsequent words\n+  __i++;\n+  for ( ; __i < _Nw; __i++ ) {\n+    _WordT __thisword = _M_w[__i];\n+    if ( __thisword != static_cast<_WordT>(0) ) {\n+      // find byte within word\n+      for ( size_t __j = 0; __j < sizeof(_WordT); __j++ ) {\n+        unsigned char __this_byte\n+          = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+        if ( __this_byte )\n+          return __i*__BITS_PER_WORD + __j*CHAR_BIT +\n+            _First_one<true>::_S_first_one[__this_byte];\n+\n+        __thisword >>= CHAR_BIT;\n+      }\n+    }\n+  }\n+\n+  // not found, so return an indication of failure.\n+  return __not_found;\n+} // end _M_do_find_next\n+\n+\n+// ------------------------------------------------------------\n+\n+//\n+// Base class: specialization for a single word.\n+//\n+\n+__STL_TEMPLATE_NULL struct _Base_bitset<1> {\n+  typedef unsigned long _WordT;\n+  _WordT _M_w;\n+\n+  _Base_bitset( void ) : _M_w(0) {}\n+  _Base_bitset(unsigned long __val) : _M_w(__val) {}\n+\n+  static size_t _S_whichword( size_t __pos )\n+    { return __pos / __BITS_PER_WORD; }\n+  static size_t _S_whichbyte( size_t __pos )\n+    { return (__pos % __BITS_PER_WORD) / CHAR_BIT; }\n+  static size_t _S_whichbit( size_t __pos )\n+    {  return __pos % __BITS_PER_WORD; }\n+  static _WordT _S_maskbit( size_t __pos )\n+    { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n+\n+  _WordT& _M_getword(size_t)       { return _M_w; }\n+  _WordT  _M_getword(size_t) const { return _M_w; }\n+\n+  _WordT& _M_hiword()       { return _M_w; }\n+  _WordT  _M_hiword() const { return _M_w; }\n+\n+  void _M_do_and(const _Base_bitset<1>& __x) { _M_w &= __x._M_w; }\n+  void _M_do_or(const _Base_bitset<1>& __x)  { _M_w |= __x._M_w; }\n+  void _M_do_xor(const _Base_bitset<1>& __x) { _M_w ^= __x._M_w; }\n+  void _M_do_left_shift(size_t __shift)     { _M_w <<= __shift; }\n+  void _M_do_right_shift(size_t __shift)    { _M_w >>= __shift; }\n+  void _M_do_flip()                       { _M_w = ~_M_w; }\n+  void _M_do_set()                        { _M_w = ~static_cast<_WordT>(0); }\n+  void _M_do_reset()                      { _M_w = 0; }\n+\n+  bool _M_is_equal(const _Base_bitset<1>& __x) const\n+    { return _M_w == __x._M_w; }\n+  bool _M_is_any() const\n+    { return _M_w != 0; }\n+\n+  size_t _M_do_count() const {\n+    size_t __result = 0;\n+    const unsigned char* __byte_ptr = (const unsigned char*)&_M_w;\n+    const unsigned char* __end_ptr\n+      = ((const unsigned char*)&_M_w)+sizeof(_M_w);\n+    while ( __byte_ptr < __end_ptr ) {\n+      __result += _Bit_count<true>::_S_bit_count[*__byte_ptr];\n+      __byte_ptr++;\n+    }\n+    return __result;\n+  }\n+\n+  unsigned long _M_do_to_ulong() const { return _M_w; }\n+\n+  size_t _M_do_find_first(size_t __not_found) const;\n+\n+  // find the next \"on\" bit that follows \"prev\"\n+  size_t _M_do_find_next(size_t __prev, size_t __not_found) const; \n+\n+};\n+\n+//\n+// Definitions of non-inline functions from the single-word version of\n+//  _Base_bitset.\n+//\n+\n+size_t _Base_bitset<1>::_M_do_find_first(size_t __not_found) const\n+{\n+  _WordT __thisword = _M_w;\n+\n+  if ( __thisword != static_cast<_WordT>(0) ) {\n+    // find byte within word\n+    for ( size_t __j = 0; __j < sizeof(_WordT); __j++ ) {\n+      unsigned char __this_byte\n+        = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+      if ( __this_byte )\n+        return __j*CHAR_BIT + _First_one<true>::_S_first_one[__this_byte];\n+\n+      __thisword >>= CHAR_BIT;\n+    }\n+  }\n+  // not found, so return a value that indicates failure.\n+  return __not_found;\n+}\n+\n+size_t _Base_bitset<1>::_M_do_find_next(size_t __prev, size_t __not_found ) const\n+{\n+  // make bound inclusive\n+  ++__prev;\n+\n+  // check out of bounds\n+  if ( __prev >= __BITS_PER_WORD )\n+    return __not_found;\n+\n+    // search first (and only) word\n+  _WordT __thisword = _M_w;\n+\n+  // mask off bits below bound\n+  __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);\n+\n+  if ( __thisword != static_cast<_WordT>(0) ) {\n+    // find byte within word\n+    // get first byte into place\n+    __thisword >>= _S_whichbyte(__prev) * CHAR_BIT;\n+    for ( size_t __j = _S_whichbyte(__prev); __j < sizeof(_WordT); __j++ ) {\n+      unsigned char __this_byte\n+        = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n+      if ( __this_byte )\n+        return __j*CHAR_BIT + _First_one<true>::_S_first_one[__this_byte];\n+\n+      __thisword >>= CHAR_BIT;\n+    }\n+  }\n+\n+  // not found, so return a value that indicates failure.\n+  return __not_found;\n+} // end _M_do_find_next\n+\n+\n+// ------------------------------------------------------------\n+// Helper class to zero out the unused high-order bits in the highest word.\n+\n+template <size_t _Extrabits> struct _Sanitize {\n+  static void _M_do_sanitize(unsigned long& __val)\n+    { __val &= ~((~static_cast<unsigned long>(0)) << _Extrabits); }\n+};\n+\n+__STL_TEMPLATE_NULL struct _Sanitize<0> {\n+  static void _M_do_sanitize(unsigned long) {}\n+};\n+\n+\n+\n+// ------------------------------------------------------------\n+// Class bitset.\n+//   _Nb may be any nonzero number of type size_t.\n+\n+template<size_t _Nb>\n+class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>\n+{\n+private:\n+  typedef _Base_bitset<__BITSET_WORDS(_Nb)> _Base;\n+  typedef unsigned long _WordT;\n+\n+private:\n+  void _M_do_sanitize() {\n+    _Sanitize<_Nb%__BITS_PER_WORD>::_M_do_sanitize(this->_M_hiword());\n+  }\n+\n+public:\n+\n+  // bit reference:\n+  class reference;\n+  friend class reference;\n+\n+  class reference {\n+    friend class bitset;\n+\n+    _WordT *_M_wp;\n+    size_t _M_bpos;\n+\n+    // left undefined\n+    reference();\n+\n+  public:\n+    reference( bitset& __b, size_t __pos ) {\n+      _M_wp = &__b._M_getword(__pos);\n+      _M_bpos = _Base::_S_whichbit(__pos);\n+    }\n+\n+    ~reference() {}\n+\n+    // for b[i] = __x;\n+    reference& operator=(bool __x) {\n+      if ( __x )\n+        *_M_wp |= _Base::_S_maskbit(_M_bpos);\n+      else\n+        *_M_wp &= ~_Base::_S_maskbit(_M_bpos);\n+\n+      return *this;\n+    }\n+\n+    // for b[i] = b[__j];\n+    reference& operator=(const reference& __j) {\n+      if ( (*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)) )\n+        *_M_wp |= _Base::_S_maskbit(_M_bpos);\n+      else\n+        *_M_wp &= ~_Base::_S_maskbit(_M_bpos);\n+\n+      return *this;\n+    }\n+\n+    // flips the bit\n+    bool operator~() const\n+      { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }\n+\n+    // for __x = b[i];\n+    operator bool() const\n+      { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }\n+\n+    // for b[i].flip();\n+    reference& flip() {\n+      *_M_wp ^= _Base::_S_maskbit(_M_bpos);\n+      return *this;\n+    }\n+  };\n+\n+  // 23.3.5.1 constructors:\n+  bitset() {}\n+  bitset(unsigned long __val) : _Base_bitset<__BITSET_WORDS(_Nb)>(__val) \n+    { _M_do_sanitize(); }\n+\n+#ifdef __STL_MEMBER_TEMPLATES\n+  template<class _CharT, class _Traits, class _Alloc>\n+  explicit bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n+                  size_t __pos = 0)\n+    : _Base() \n+  {\n+    if (__pos > __s.size()) \n+      __STL_THROW(out_of_range(\"bitset\"));\n+    _M_copy_from_string(__s, __pos,\n+                        basic_string<_CharT, _Traits, _Alloc>::npos);\n+  }\n+  template<class _CharT, class _Traits, class _Alloc>\n+  bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n+         size_t __pos,\n+         size_t __n)\n+    : _Base() \n+  {\n+    if (__pos > __s.size()) \n+      __STL_THROW(out_of_range(\"bitset\"));\n+    _M_copy_from_string(__s, __pos, __n);\n+  }\n+#else /* __STL_MEMBER_TEMPLATES */\n+  explicit bitset(const basic_string<char>& __s,\n+                  size_t __pos = 0,\n+                  size_t __n = basic_string<char>::npos) \n+    : _Base() \n+  {\n+    if (__pos > __s.size()) \n+      __STL_THROW(out_of_range(\"bitset\"));\n+    _M_copy_from_string(__s, __pos, __n);\n+  }\n+#endif /* __STL_MEMBER_TEMPLATES */\n+\n+  // 23.3.5.2 bitset operations:\n+  bitset<_Nb>& operator&=(const bitset<_Nb>& __rhs) {\n+    this->_M_do_and(__rhs);\n+    return *this;\n+  }\n+\n+  bitset<_Nb>& operator|=(const bitset<_Nb>& __rhs) {\n+    this->_M_do_or(__rhs);\n+    return *this;\n+  }\n+\n+  bitset<_Nb>& operator^=(const bitset<_Nb>& __rhs) {\n+    this->_M_do_xor(__rhs);\n+    return *this;\n+  }\n+\n+  bitset<_Nb>& operator<<=(size_t __pos) {\n+    this->_M_do_left_shift(__pos);\n+    this->_M_do_sanitize();\n+    return *this;\n+  }\n+\n+  bitset<_Nb>& operator>>=(size_t __pos) {\n+    this->_M_do_right_shift(__pos);\n+    this->_M_do_sanitize();\n+    return *this;\n+  }\n+\n+  //\n+  // Extension:\n+  // Versions of single-bit set, reset, flip, test with no range checking.\n+  //\n+\n+  bitset<_Nb>& _Unchecked_set(size_t __pos) {\n+    this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n+    return *this;\n+  }\n+\n+  bitset<_Nb>& _Unchecked_set(size_t __pos, int __val) {\n+    if (__val)\n+      this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n+    else\n+      this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n+\n+    return *this;\n+  }\n+\n+  bitset<_Nb>& _Unchecked_reset(size_t __pos) {\n+    this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n+    return *this;\n+  }\n+\n+  bitset<_Nb>& _Unchecked_flip(size_t __pos) {\n+    this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);\n+    return *this;\n+  }\n+\n+  bool _Unchecked_test(size_t __pos) const {\n+    return (this->_M_getword(__pos) & _Base::_S_maskbit(__pos))\n+      != static_cast<_WordT>(0);\n+  }\n+\n+  // Set, reset, and flip.\n+\n+  bitset<_Nb>& set() {\n+    this->_M_do_set();\n+    this->_M_do_sanitize();\n+    return *this;\n+  }\n+\n+  bitset<_Nb>& set(size_t __pos) {\n+    if (__pos >= _Nb)\n+      __STL_THROW(out_of_range(\"bitset\"));\n+\n+    return _Unchecked_set(__pos);\n+  }\n+\n+  bitset<_Nb>& set(size_t __pos, int __val) {\n+    if (__pos >= _Nb)\n+      __STL_THROW(out_of_range(\"bitset\"));\n+\n+    return _Unchecked_set(__pos, __val);\n+  }\n+\n+  bitset<_Nb>& reset() {\n+    this->_M_do_reset();\n+    return *this;\n+  }\n+\n+  bitset<_Nb>& reset(size_t __pos) {\n+    if (__pos >= _Nb)\n+      __STL_THROW(out_of_range(\"bitset\"));\n+\n+    return _Unchecked_reset(__pos);\n+  }\n+\n+  bitset<_Nb>& flip() {\n+    this->_M_do_flip();\n+    this->_M_do_sanitize();\n+    return *this;\n+  }\n+\n+  bitset<_Nb>& flip(size_t __pos) {\n+    if (__pos >= _Nb)\n+      __STL_THROW(out_of_range(\"bitset\"));\n+\n+    return _Unchecked_flip(__pos);\n+  }\n+\n+  bitset<_Nb> operator~() const { \n+    return bitset<_Nb>(*this).flip();\n+  }\n+\n+  // element access:\n+  //for b[i];\n+  reference operator[](size_t __pos) { return reference(*this,__pos); }\n+  bool operator[](size_t __pos) const { return _Unchecked_test(__pos); }\n+\n+  unsigned long to_ulong() const { return this->_M_do_to_ulong(); }\n+\n+#if defined(__STL_MEMBER_TEMPLATES) && \\\n+    defined(__STL_EXPLICIT_FUNCTION_TMPL_ARGS)\n+  template <class _CharT, class _Traits, class _Alloc>\n+  basic_string<_CharT, _Traits, _Alloc> to_string() const {\n+    basic_string<_CharT, _Traits, _Alloc> __result;\n+    _M_copy_to_string(__result);\n+    return __result;\n+  }\n+#endif /* member templates and explicit function template args */\n+\n+  // Helper functions for string operations.\n+#ifdef __STL_MEMBER_TEMPLATES\n+  template<class _CharT, class _Traits, class _Alloc>\n+  void _M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,\n+                          size_t,\n+                          size_t);\n+\n+  template<class _CharT, class _Traits, class _Alloc>\n+  void _M_copy_to_string(basic_string<_CharT,_Traits,_Alloc>&) const;\n+#else /* __STL_MEMBER_TEMPLATES */\n+  void _M_copy_from_string(const basic_string<char>&, size_t, size_t);\n+  void _M_copy_to_string(basic_string<char>&) const;\n+#endif /* __STL_MEMBER_TEMPLATES */\n+\n+  size_t count() const { return this->_M_do_count(); }\n+\n+  size_t size() const { return _Nb; }\n+\n+  bool operator==(const bitset<_Nb>& __rhs) const {\n+    return this->_M_is_equal(__rhs);\n+  }\n+  bool operator!=(const bitset<_Nb>& __rhs) const {\n+    return !this->_M_is_equal(__rhs);\n+  }\n+\n+  bool test(size_t __pos) const {\n+    if (__pos > _Nb)\n+      __STL_THROW(out_of_range(\"bitset\"));\n+\n+    return _Unchecked_test(__pos);\n+  }\n+\n+  bool any() const { return this->_M_is_any(); }\n+  bool none() const { return !this->_M_is_any(); }\n+\n+  bitset<_Nb> operator<<(size_t __pos) const\n+    { return bitset<_Nb>(*this) <<= __pos; }\n+  bitset<_Nb> operator>>(size_t __pos) const\n+    { return bitset<_Nb>(*this) >>= __pos; }\n+\n+  //\n+  // EXTENSIONS: bit-find operations.  These operations are\n+  // experimental, and are subject to change or removal in future\n+  // versions.\n+  // \n+\n+  // find the index of the first \"on\" bit\n+  size_t _Find_first() const \n+    { return this->_M_do_find_first(_Nb); }\n+\n+  // find the index of the next \"on\" bit after prev\n+  size_t _Find_next( size_t __prev ) const \n+    { return this->_M_do_find_next(__prev, _Nb); }\n+\n+};\n+\n+//\n+// Definitions of non-inline member functions.\n+//\n+\n+#ifdef __STL_MEMBER_TEMPLATES\n+\n+template <size_t _Nb>\n+template<class _CharT, class _Traits, class _Alloc>\n+void bitset<_Nb>\n+  ::_M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,\n+                        size_t __pos,\n+                        size_t __n)\n+{\n+  reset();\n+  const size_t __nbits = min(_Nb, min(__n, __s.size() - __pos));\n+  for (size_t __i = 0; __i < __nbits; ++__i) {\n+    switch(__s[__pos + __nbits - __i - 1]) {\n+    case '0':\n+      break;\n+    case '1':\n+      set(__i);\n+      break;\n+    default:\n+      __STL_THROW(invalid_argument(\"bitset\"));\n+    }\n+  }\n+}\n+\n+template <size_t _Nb>\n+template <class _CharT, class _Traits, class _Alloc>\n+void bitset<_Nb>\n+  ::_M_copy_to_string(basic_string<_CharT, _Traits, _Alloc>& __s) const\n+{\n+  __s.assign(_Nb, '0');\n+  \n+  for (size_t __i = 0; __i < _Nb; ++__i) \n+    if (_Unchecked_test(__i))\n+      __s[_Nb - 1 - __i] = '1';\n+}\n+\n+#else /* __STL_MEMBER_TEMPLATES */\n+\n+template <size_t _Nb>\n+void bitset<_Nb>::_M_copy_from_string(const basic_string<char>& __s,\n+                                      size_t __pos, size_t __n)\n+{\n+  reset();\n+  size_t __tmp = _Nb;\n+  const size_t __nbits = min(__tmp, min(__n, __s.size() - __pos));\n+  for (size_t __i = 0; __i < __nbits; ++__i) {\n+    switch(__s[__pos + __nbits - __i - 1]) {\n+    case '0':\n+      break;\n+    case '1':\n+      set(__i);\n+      break;\n+    default:\n+      __STL_THROW(invalid_argument(\"bitset\"));\n+    }\n+  }\n+}\n+\n+template <size_t _Nb>\n+void bitset<_Nb>::_M_copy_to_string(basic_string<char>& __s) const\n+{\n+  __s.assign(_Nb, '0');\n+  \n+  for (size_t __i = 0; __i < _Nb; ++__i) \n+    if (_Unchecked_test(__i))\n+      __s[_Nb - 1 - __i] = '1';\n+}\n+\n+#endif /* __STL_MEMBER_TEMPLATES */\n+\n+// ------------------------------------------------------------\n+\n+//\n+// 23.3.5.3 bitset operations:\n+//\n+\n+template <size_t _Nb>\n+inline bitset<_Nb> operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y) {\n+  bitset<_Nb> __result(__x);\n+  __result &= __y;\n+  return __result;\n+}\n+\n+\n+template <size_t _Nb>\n+inline bitset<_Nb> operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y) {\n+  bitset<_Nb> __result(__x);\n+  __result |= __y;\n+  return __result;\n+}\n+\n+template <size_t _Nb>\n+inline bitset<_Nb> operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y) {\n+  bitset<_Nb> __result(__x);\n+  __result ^= __y;\n+  return __result;\n+}\n+\n+#ifdef __STL_USE_NEW_IOSTREAMS\n+\n+template <class _CharT, class _Traits, size_t _Nb>\n+basic_istream<_CharT, _Traits>&\n+operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)\n+{\n+  typedef typename _Traits::char_type char_type;\n+  basic_string<_CharT, _Traits> __tmp;\n+  __tmp.reserve(_Nb);\n+\n+  // Skip whitespace\n+  typename basic_istream<_CharT, _Traits>::sentry __sentry(__is);\n+  if (__sentry) {\n+    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();\n+    for (size_t __i = 0; __i < _Nb; ++__i) {\n+      static _Traits::int_type __eof = _Traits::eof();\n+\n+      typename _Traits::int_type __c1 = __buf->sbumpc();\n+      if (_Traits::eq_int_type(__c1, __eof)) {\n+        __is.setstate(ios_base::eofbit);\n+        break;\n+      }\n+      else {\n+        char_type __c2 = _Traits::to_char_type(__c1);\n+        char_type __c  = __is.narrow(__c2, '*');\n+\n+        if (__c == '0' || __c == '1')\n+          __tmp.push_back(__c);\n+        else if (_Traits::eq_int_type(__buf->sputbackc(__c2), __eof)) {\n+          __is.setstate(ios_base::failbit);\n+          break;\n+        }\n+      }\n+    }\n+\n+    if (__tmp.empty())\n+      __is.setstate(ios_base::failbit);\n+    else\n+      __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb);\n+  }\n+\n+  return __is;\n+}\n+\n+template <class _CharT, class _Traits, size_t _Nb>\n+basic_ostream<_CharT, _Traits>&\n+operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Nb>& __x)\n+{\n+  basic_string<_CharT, _Traits> __tmp;\n+  __x._M_copy_to_string(__tmp);\n+  return __os << __tmp;\n+}\n+\n+#else /* __STL_USE_NEW_IOSTREAMS */\n+\n+template <size_t _Nb>\n+istream& operator>>(istream& __is, bitset<_Nb>& __x) {\n+  string __tmp;\n+  __tmp.reserve(_Nb);\n+\n+  if (__is.flags() & ios::skipws) {\n+    char __c;\n+    do \n+      __is.get(__c);\n+    while (__is && isspace(__c));\n+    if (__is)\n+      __is.putback(__c);\n+  }\n+\n+  for (size_t __i = 0; __i < _Nb; ++__i) {\n+    char __c;\n+    __is.get(__c);\n+\n+    if (!__is)\n+      break;\n+    else if (__c != '0' && __c != '1') {\n+      __is.putback(__c);\n+      break;\n+    }\n+    else\n+      __tmp.push_back(__c);\n+  }\n+\n+  if (__tmp.empty()) \n+    __is.clear(__is.rdstate() | ios::failbit);\n+  else\n+    __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb);\n+\n+  return __is;\n+}\n+\n+template <size_t _Nb>\n+ostream& operator<<(ostream& __os, const bitset<_Nb>& __x) {\n+  string __tmp;\n+  __x._M_copy_to_string(__tmp);\n+  return __os << __tmp;\n+}\n+\n+#endif /* __STL_USE_NEW_IOSTREAMS */\n+\n+// ------------------------------------------------------------\n+// Lookup tables for find and count operations.\n+\n+template<bool __dummy>\n+unsigned char _Bit_count<__dummy>::_S_bit_count[] = {\n+  0, /*   0 */ 1, /*   1 */ 1, /*   2 */ 2, /*   3 */ 1, /*   4 */\n+  2, /*   5 */ 2, /*   6 */ 3, /*   7 */ 1, /*   8 */ 2, /*   9 */\n+  2, /*  10 */ 3, /*  11 */ 2, /*  12 */ 3, /*  13 */ 3, /*  14 */\n+  4, /*  15 */ 1, /*  16 */ 2, /*  17 */ 2, /*  18 */ 3, /*  19 */\n+  2, /*  20 */ 3, /*  21 */ 3, /*  22 */ 4, /*  23 */ 2, /*  24 */\n+  3, /*  25 */ 3, /*  26 */ 4, /*  27 */ 3, /*  28 */ 4, /*  29 */\n+  4, /*  30 */ 5, /*  31 */ 1, /*  32 */ 2, /*  33 */ 2, /*  34 */\n+  3, /*  35 */ 2, /*  36 */ 3, /*  37 */ 3, /*  38 */ 4, /*  39 */\n+  2, /*  40 */ 3, /*  41 */ 3, /*  42 */ 4, /*  43 */ 3, /*  44 */\n+  4, /*  45 */ 4, /*  46 */ 5, /*  47 */ 2, /*  48 */ 3, /*  49 */\n+  3, /*  50 */ 4, /*  51 */ 3, /*  52 */ 4, /*  53 */ 4, /*  54 */\n+  5, /*  55 */ 3, /*  56 */ 4, /*  57 */ 4, /*  58 */ 5, /*  59 */\n+  4, /*  60 */ 5, /*  61 */ 5, /*  62 */ 6, /*  63 */ 1, /*  64 */\n+  2, /*  65 */ 2, /*  66 */ 3, /*  67 */ 2, /*  68 */ 3, /*  69 */\n+  3, /*  70 */ 4, /*  71 */ 2, /*  72 */ 3, /*  73 */ 3, /*  74 */\n+  4, /*  75 */ 3, /*  76 */ 4, /*  77 */ 4, /*  78 */ 5, /*  79 */\n+  2, /*  80 */ 3, /*  81 */ 3, /*  82 */ 4, /*  83 */ 3, /*  84 */\n+  4, /*  85 */ 4, /*  86 */ 5, /*  87 */ 3, /*  88 */ 4, /*  89 */\n+  4, /*  90 */ 5, /*  91 */ 4, /*  92 */ 5, /*  93 */ 5, /*  94 */\n+  6, /*  95 */ 2, /*  96 */ 3, /*  97 */ 3, /*  98 */ 4, /*  99 */\n+  3, /* 100 */ 4, /* 101 */ 4, /* 102 */ 5, /* 103 */ 3, /* 104 */\n+  4, /* 105 */ 4, /* 106 */ 5, /* 107 */ 4, /* 108 */ 5, /* 109 */\n+  5, /* 110 */ 6, /* 111 */ 3, /* 112 */ 4, /* 113 */ 4, /* 114 */\n+  5, /* 115 */ 4, /* 116 */ 5, /* 117 */ 5, /* 118 */ 6, /* 119 */\n+  4, /* 120 */ 5, /* 121 */ 5, /* 122 */ 6, /* 123 */ 5, /* 124 */\n+  6, /* 125 */ 6, /* 126 */ 7, /* 127 */ 1, /* 128 */ 2, /* 129 */\n+  2, /* 130 */ 3, /* 131 */ 2, /* 132 */ 3, /* 133 */ 3, /* 134 */\n+  4, /* 135 */ 2, /* 136 */ 3, /* 137 */ 3, /* 138 */ 4, /* 139 */\n+  3, /* 140 */ 4, /* 141 */ 4, /* 142 */ 5, /* 143 */ 2, /* 144 */\n+  3, /* 145 */ 3, /* 146 */ 4, /* 147 */ 3, /* 148 */ 4, /* 149 */\n+  4, /* 150 */ 5, /* 151 */ 3, /* 152 */ 4, /* 153 */ 4, /* 154 */\n+  5, /* 155 */ 4, /* 156 */ 5, /* 157 */ 5, /* 158 */ 6, /* 159 */\n+  2, /* 160 */ 3, /* 161 */ 3, /* 162 */ 4, /* 163 */ 3, /* 164 */\n+  4, /* 165 */ 4, /* 166 */ 5, /* 167 */ 3, /* 168 */ 4, /* 169 */\n+  4, /* 170 */ 5, /* 171 */ 4, /* 172 */ 5, /* 173 */ 5, /* 174 */\n+  6, /* 175 */ 3, /* 176 */ 4, /* 177 */ 4, /* 178 */ 5, /* 179 */\n+  4, /* 180 */ 5, /* 181 */ 5, /* 182 */ 6, /* 183 */ 4, /* 184 */\n+  5, /* 185 */ 5, /* 186 */ 6, /* 187 */ 5, /* 188 */ 6, /* 189 */\n+  6, /* 190 */ 7, /* 191 */ 2, /* 192 */ 3, /* 193 */ 3, /* 194 */\n+  4, /* 195 */ 3, /* 196 */ 4, /* 197 */ 4, /* 198 */ 5, /* 199 */\n+  3, /* 200 */ 4, /* 201 */ 4, /* 202 */ 5, /* 203 */ 4, /* 204 */\n+  5, /* 205 */ 5, /* 206 */ 6, /* 207 */ 3, /* 208 */ 4, /* 209 */\n+  4, /* 210 */ 5, /* 211 */ 4, /* 212 */ 5, /* 213 */ 5, /* 214 */\n+  6, /* 215 */ 4, /* 216 */ 5, /* 217 */ 5, /* 218 */ 6, /* 219 */\n+  5, /* 220 */ 6, /* 221 */ 6, /* 222 */ 7, /* 223 */ 3, /* 224 */\n+  4, /* 225 */ 4, /* 226 */ 5, /* 227 */ 4, /* 228 */ 5, /* 229 */\n+  5, /* 230 */ 6, /* 231 */ 4, /* 232 */ 5, /* 233 */ 5, /* 234 */\n+  6, /* 235 */ 5, /* 236 */ 6, /* 237 */ 6, /* 238 */ 7, /* 239 */\n+  4, /* 240 */ 5, /* 241 */ 5, /* 242 */ 6, /* 243 */ 5, /* 244 */\n+  6, /* 245 */ 6, /* 246 */ 7, /* 247 */ 5, /* 248 */ 6, /* 249 */\n+  6, /* 250 */ 7, /* 251 */ 6, /* 252 */ 7, /* 253 */ 7, /* 254 */\n+  8  /* 255 */\n+}; // end _Bit_count\n+\n+template<bool __dummy>\n+unsigned char _First_one<__dummy>::_S_first_one[] = {\n+  0, /*   0 */ 0, /*   1 */ 1, /*   2 */ 0, /*   3 */ 2, /*   4 */\n+  0, /*   5 */ 1, /*   6 */ 0, /*   7 */ 3, /*   8 */ 0, /*   9 */\n+  1, /*  10 */ 0, /*  11 */ 2, /*  12 */ 0, /*  13 */ 1, /*  14 */\n+  0, /*  15 */ 4, /*  16 */ 0, /*  17 */ 1, /*  18 */ 0, /*  19 */\n+  2, /*  20 */ 0, /*  21 */ 1, /*  22 */ 0, /*  23 */ 3, /*  24 */\n+  0, /*  25 */ 1, /*  26 */ 0, /*  27 */ 2, /*  28 */ 0, /*  29 */\n+  1, /*  30 */ 0, /*  31 */ 5, /*  32 */ 0, /*  33 */ 1, /*  34 */\n+  0, /*  35 */ 2, /*  36 */ 0, /*  37 */ 1, /*  38 */ 0, /*  39 */\n+  3, /*  40 */ 0, /*  41 */ 1, /*  42 */ 0, /*  43 */ 2, /*  44 */\n+  0, /*  45 */ 1, /*  46 */ 0, /*  47 */ 4, /*  48 */ 0, /*  49 */\n+  1, /*  50 */ 0, /*  51 */ 2, /*  52 */ 0, /*  53 */ 1, /*  54 */\n+  0, /*  55 */ 3, /*  56 */ 0, /*  57 */ 1, /*  58 */ 0, /*  59 */\n+  2, /*  60 */ 0, /*  61 */ 1, /*  62 */ 0, /*  63 */ 6, /*  64 */\n+  0, /*  65 */ 1, /*  66 */ 0, /*  67 */ 2, /*  68 */ 0, /*  69 */\n+  1, /*  70 */ 0, /*  71 */ 3, /*  72 */ 0, /*  73 */ 1, /*  74 */\n+  0, /*  75 */ 2, /*  76 */ 0, /*  77 */ 1, /*  78 */ 0, /*  79 */\n+  4, /*  80 */ 0, /*  81 */ 1, /*  82 */ 0, /*  83 */ 2, /*  84 */\n+  0, /*  85 */ 1, /*  86 */ 0, /*  87 */ 3, /*  88 */ 0, /*  89 */\n+  1, /*  90 */ 0, /*  91 */ 2, /*  92 */ 0, /*  93 */ 1, /*  94 */\n+  0, /*  95 */ 5, /*  96 */ 0, /*  97 */ 1, /*  98 */ 0, /*  99 */\n+  2, /* 100 */ 0, /* 101 */ 1, /* 102 */ 0, /* 103 */ 3, /* 104 */\n+  0, /* 105 */ 1, /* 106 */ 0, /* 107 */ 2, /* 108 */ 0, /* 109 */\n+  1, /* 110 */ 0, /* 111 */ 4, /* 112 */ 0, /* 113 */ 1, /* 114 */\n+  0, /* 115 */ 2, /* 116 */ 0, /* 117 */ 1, /* 118 */ 0, /* 119 */\n+  3, /* 120 */ 0, /* 121 */ 1, /* 122 */ 0, /* 123 */ 2, /* 124 */\n+  0, /* 125 */ 1, /* 126 */ 0, /* 127 */ 7, /* 128 */ 0, /* 129 */\n+  1, /* 130 */ 0, /* 131 */ 2, /* 132 */ 0, /* 133 */ 1, /* 134 */\n+  0, /* 135 */ 3, /* 136 */ 0, /* 137 */ 1, /* 138 */ 0, /* 139 */\n+  2, /* 140 */ 0, /* 141 */ 1, /* 142 */ 0, /* 143 */ 4, /* 144 */\n+  0, /* 145 */ 1, /* 146 */ 0, /* 147 */ 2, /* 148 */ 0, /* 149 */\n+  1, /* 150 */ 0, /* 151 */ 3, /* 152 */ 0, /* 153 */ 1, /* 154 */\n+  0, /* 155 */ 2, /* 156 */ 0, /* 157 */ 1, /* 158 */ 0, /* 159 */\n+  5, /* 160 */ 0, /* 161 */ 1, /* 162 */ 0, /* 163 */ 2, /* 164 */\n+  0, /* 165 */ 1, /* 166 */ 0, /* 167 */ 3, /* 168 */ 0, /* 169 */\n+  1, /* 170 */ 0, /* 171 */ 2, /* 172 */ 0, /* 173 */ 1, /* 174 */\n+  0, /* 175 */ 4, /* 176 */ 0, /* 177 */ 1, /* 178 */ 0, /* 179 */\n+  2, /* 180 */ 0, /* 181 */ 1, /* 182 */ 0, /* 183 */ 3, /* 184 */\n+  0, /* 185 */ 1, /* 186 */ 0, /* 187 */ 2, /* 188 */ 0, /* 189 */\n+  1, /* 190 */ 0, /* 191 */ 6, /* 192 */ 0, /* 193 */ 1, /* 194 */\n+  0, /* 195 */ 2, /* 196 */ 0, /* 197 */ 1, /* 198 */ 0, /* 199 */\n+  3, /* 200 */ 0, /* 201 */ 1, /* 202 */ 0, /* 203 */ 2, /* 204 */\n+  0, /* 205 */ 1, /* 206 */ 0, /* 207 */ 4, /* 208 */ 0, /* 209 */\n+  1, /* 210 */ 0, /* 211 */ 2, /* 212 */ 0, /* 213 */ 1, /* 214 */\n+  0, /* 215 */ 3, /* 216 */ 0, /* 217 */ 1, /* 218 */ 0, /* 219 */\n+  2, /* 220 */ 0, /* 221 */ 1, /* 222 */ 0, /* 223 */ 5, /* 224 */\n+  0, /* 225 */ 1, /* 226 */ 0, /* 227 */ 2, /* 228 */ 0, /* 229 */\n+  1, /* 230 */ 0, /* 231 */ 3, /* 232 */ 0, /* 233 */ 1, /* 234 */\n+  0, /* 235 */ 2, /* 236 */ 0, /* 237 */ 1, /* 238 */ 0, /* 239 */\n+  4, /* 240 */ 0, /* 241 */ 1, /* 242 */ 0, /* 243 */ 2, /* 244 */\n+  0, /* 245 */ 1, /* 246 */ 0, /* 247 */ 3, /* 248 */ 0, /* 249 */\n+  1, /* 250 */ 0, /* 251 */ 2, /* 252 */ 0, /* 253 */ 1, /* 254 */\n+  0, /* 255 */\n+}; // end _First_one\n+\n+#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n+#pragma reset woff 1209\n+#endif\n+\n+__STL_END_NAMESPACE\n+\n+\n+#undef __BITS_PER_WORD\n+#undef __BITSET_WORDS\n+\n+#endif /* __SGI_STL_BITSET */\n+\n+\n+// Local Variables:\n+// mode:C++\n+// End:\n+"}, {"sha": "5d9d18445f91a1bc2690e7b96fe06d452f8a2cfb", "filename": "libstdc++-v3/include/bits/std_cassert.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cassert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cassert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cassert.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,39 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 19.2  Assertions\n+//\n+\n+// Note: This is not a conforming implementation.\n+\n+// No include guards on this header...\n+\n+# pragma GCC system_header\n+# include_next <assert.h>"}, {"sha": "1c1e69c6c5dadb2b5590d621e1dc4de2665a6595", "filename": "libstdc++-v3/include/bits/std_cctype.h", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cctype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cctype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cctype.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,211 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: <ccytpe>\n+//\n+\n+#ifndef _CPP_CCTYPE\n+#define _CPP_CCTYPE 1\n+\n+// This keeps isanum, et al from being propagated as macros.\n+#if __linux__\n+#define __NO_CTYPE 1\n+#endif\n+\n+# pragma GCC system_header\n+# include_next <ctype.h>\n+\n+// Sequester the C non-inline implementations in the _C_Swamp::\n+// namespace, and provide C++ inlines for them in the std:: namespace\n+// where they belong.\n+\n+namespace std \n+{\n+  // NB: If not using namespaces, can't have any of these definitions,\n+  // as they will duplicate what's in the global namespace. \n+\n+#ifdef toupper\n+  inline int \n+  _S_toupper_helper(int __c) { return toupper(__c); }\n+# undef toupper\n+  inline int \n+  toupper(int __c) { return _S_toupper_helper(__c); }\n+#else\n+  inline int \n+  toupper(int __c) { return ::toupper(__c); }\n+#endif\n+\n+#ifdef tolower\n+  inline int \n+  _S_tolower_helper(int __c) { return tolower(__c); }\n+# undef tolower\n+  inline int \n+  tolower(int __c) { return _S_tolower_helper(__c); }\n+#else\n+  inline int \n+  tolower(int __c) { return ::tolower(__c); }\n+#endif\n+\n+#ifdef isspace\n+  inline int \n+  _S_isspace_helper(int __c) { return isspace(__c); }\n+# undef isspace\n+  inline int \n+  isspace(int __c) { return _S_isspace_helper(__c); }\n+#else\n+  inline int \n+  isspace(int __c) { return ::isspace(__c); }\n+#endif\n+\n+#ifdef isprint\n+  inline int \n+  _S_isprint_helper(int __c) { return isprint(__c); }\n+# undef isprint\n+  inline int \n+  isprint(int __c) { return _S_isprint_helper(__c); }\n+#else\n+  inline int \n+  isprint(int __c) { return ::isprint(__c); }\n+#endif\n+\n+#ifdef iscntrl\n+  inline int \n+  _S_iscntrl_helper(int __c) { return iscntrl(__c); }\n+# undef iscntrl\n+  inline int \n+  iscntrl(int __c) { return _S_iscntrl_helper(__c); }\n+#else\n+  inline int \n+  iscntrl(int __c) { return ::iscntrl(__c); }\n+#endif\n+\n+#ifdef isupper\n+  inline int \n+  _S_isupper_helper(int __c) { return isupper(__c); }\n+# undef isupper\n+  inline int \n+  isupper(int __c) { return _S_isupper_helper(__c); }\n+#else\n+  inline int \n+  isupper(int __c) { return ::isupper(__c); }\n+#endif\n+\n+#ifdef islower\n+  inline int \n+  _S_islower_helper(int __c) { return islower(__c); }\n+# undef islower\n+  inline int \n+  islower(int __c) { return _S_islower_helper(__c); }\n+#else\n+  inline int \n+  islower(int __c) { return ::islower(__c); }\n+#endif\n+\n+#ifdef isalpha\n+  inline int \n+  _S_isalpha_helper(int __c) { return isalpha(__c); }\n+# undef isalpha\n+  inline int \n+  isalpha(int __c) { return _S_isalpha_helper(__c); }\n+#else\n+  inline int \n+  isalpha(int __c) { return ::isalpha(__c); }\n+#endif\n+\n+#ifdef isdigit\n+  inline int \n+  _S_isdigit_helper(int __c) { return isdigit(__c); }\n+# undef isdigit\n+  inline int \n+  isdigit(int __c) { return _S_isdigit_helper(__c); }\n+#else\n+  inline int \n+  isdigit(int __c) { return ::isdigit(__c); }\n+#endif\n+\n+#ifdef ispunct\n+  inline int \n+  _S_ispunct_helper(int __c) { return ispunct(__c); }\n+# undef ispunct\n+  inline int \n+  ispunct(int __c) { return _S_ispunct_helper(__c); }\n+#else\n+  inline int \n+  ispunct(int __c) { return ::ispunct(__c); }\n+#endif\n+\n+#ifdef isxdigit\n+  inline int \n+  _S_isxdigit_helper(int __c) { return isxdigit(__c); }\n+# undef isxdigit\n+  inline int \n+  isxdigit(int __c) { return _S_isxdigit_helper(__c); }\n+#else\n+  inline int \n+  isxdigit(int __c) { return ::isxdigit(__c); }\n+#endif\n+\n+#ifdef isalnum\n+  inline int \n+  _S_isalnum_helper(int __c) { return isalnum(__c); }\n+# undef isalnum\n+  inline int \n+  isalnum(int __c) { return _S_isalnum_helper(__c); }\n+#else\n+  inline int \n+  isalnum(int __c) { return ::isalnum(__c); }\n+#endif\n+\n+#ifdef isgraph\n+  inline int \n+  _S_isgraph_helper(int __c) { return isgraph(__c); }\n+# undef isgraph\n+  inline int \n+  isgraph(int __c) { return _S_isgraph_helper(__c); }\n+#else\n+  inline int \n+  isgraph(int __c) { return ::isgraph(__c); }\n+#endif\n+\n+} // namespace std\n+\n+#endif // _CPP_CCTYPE\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "abd28d560d8ff29e02fa57a605af7c888b87cff3", "filename": "libstdc++-v3/include/bits/std_cerrno.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cerrno.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cerrno.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cerrno.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,40 @@\n+// The -*- C++ -*- error number header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 19.3  Error numbers\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CERRNO\n+#define _CPP_CERRNO 1\n+# pragma GCC system_header\n+# include_next <errno.h>\n+#endif"}, {"sha": "8a317fcb49041a17b4924ad36d461b2437fcf362", "filename": "libstdc++-v3/include/bits/std_cfloat.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cfloat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cfloat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cfloat.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,47 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 18.2.2  Implementation properties: C library\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CFLOAT\n+#define _CPP_CFLOAT 1\n+# pragma GCC system_header\n+# include_next <float.h>\n+\n+#if 0\n+# ifdef __GLIBC__\n+// For GNU libc we must also include this one:\n+#  include <fenv.h>\n+# endif\n+#endif\n+#endif"}, {"sha": "ddd6bd8b40fd26ab2292b4bac9b54c39b295cefa", "filename": "libstdc++-v3/include/bits/std_climits.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_climits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_climits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_climits.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,42 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 18.2.2  Implementation properties: C library\n+//\n+\n+// Note: This is not a conforming implementation.\n+\n+#ifndef _CPP_CLIMITS\n+#define _CPP_CLIMITS\t1\n+# pragma GCC system_header\n+# include_next <limits.h>\n+#endif\n+\n+"}, {"sha": "a8a44b8571acd97842fe3c0a749bf5a6b4dc1196", "filename": "libstdc++-v3/include/bits/std_clocale.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_clocale.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_clocale.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_clocale.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,41 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 18.2.2  Implementation properties: C library\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CLOCALE\n+#define _CPP_CLOCALE     1\n+# pragma GCC system_header\n+# include_next <locale.h>\n+#endif\n+"}, {"sha": "d7df14b2198f840b8bf3f216963dd8c86b2ae10d", "filename": "libstdc++-v3/include/bits/std_cmath.h", "status": "added", "additions": 506, "deletions": 0, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cmath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cmath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cmath.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,506 @@\n+// -*- C++ -*- C math library.\n+\n+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 26.5  C library\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CMATH\n+#define _CPP_CMATH 1\n+# pragma GCC system_header\n+# include_next <math.h>\n+# include_next <stdlib.h>\n+\n+# include <bits/c++config.h>\n+\n+namespace std {\n+\n+  //\n+  // int\n+  //\n+\n+  inline int abs(int i)\n+  { return i > 0 ? i : -i; }\n+\n+  inline long abs(long i)\n+  { return i > 0 ? i : -i; }\n+  \n+    //\n+    // float\n+    //\n+\n+#if _GLIBCPP_HAVE___BUILTIN_FABSF\n+    inline float abs(float __x)\n+      { return __builtin_fabsf(__x); }\n+#elif _GLIBCPP_HAVE_FABSF\n+    inline float abs(float __x)\n+      { return ::fabsf(__x); }\n+#else\n+    inline float abs(float __x)\n+      { return ::fabs(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_ACOSF\n+    inline float acos(float __x)\n+      { return ::acosf(__x); }\n+#else\n+    inline float acos(float __x)\n+      { return ::acos(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_ASINF\n+    inline float asin(float __x)\n+      { return ::asinf(__x); }\n+#else\n+    inline float asin(float __x)\n+      { return ::asin(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_ATANF\n+    inline float atan(float __x)\n+      { return ::atanf(__x); }\n+#else\n+    inline float atan(float __x)\n+      { return ::atan(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_ATAN2F\n+    inline float atan2(float __y, float __x)\n+      { return ::atan2f(__y, __x); }\n+#else\n+    inline float atan2(float __y, float __x)\n+      { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_CEILF\n+    inline float ceil(float __x)\n+      { return ::ceilf(__x); }\n+#else\n+    inline float ceil(float __x)\n+      { return ::ceil(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE___BUILTIN_COSF\n+    inline float cos(float __x)\n+      { return __builtin_cosf(__x); }\n+#elif _GLIBCPP_HAVE_COSF\n+    inline float cos(float __x)\n+      { return ::cosf(__x); }\n+#else\n+    inline float cos(float __x)\n+      { return ::cos(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_COSHF\n+    inline float cosh(float __x)\n+      { return ::coshf(__x); }\n+#else\n+    inline float cosh(float __x)\n+      { return ::cosh(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_EXPF\n+    inline float exp(float __x)\n+      { return ::expf(__x); }\n+#else\n+    inline float exp(float __x)\n+      { return ::exp(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE___BUILTIN_FABSF\n+    inline float fabs(float __x)\n+      { return __builtin_fabsf(__x); }\n+#elif _GLIBCPP_HAVE_FABSF\n+    inline float fabs(float __x)\n+      { return ::fabsf(__x); }\n+#else\n+    inline float fabs(float __x)\n+      { return ::fabs(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_FLOORF\n+    inline float floor(float __x)\n+      { return ::floorf(__x); }\n+#else\n+    inline float floor(float __x)\n+      { return ::floor(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_FMODF\n+    inline float fmod(float __x, float __y)\n+      { return ::fmodf(__x, __y); }\n+#else\n+    inline float fmod(float __x, float __y)\n+      { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_FREXPF\n+    inline float frexp(float __x, int* __exp)\n+      { return ::frexpf(__x, __exp); }\n+#else\n+    inline float frexp(float __x, int* __exp)\n+      { return ::frexp(__x, __exp); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_LDEXPF\n+    inline float ldexp(float __x, int __exp)\n+      { return ::ldexpf(__x, __exp); }\n+#else\n+    inline float ldexp(float __x, int __exp)\n+      { return ::ldexp(static_cast<double>(__x), __exp); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_LOGF\n+    inline float log(float __x)\n+      { return ::logf(__x); }\n+#else\n+    inline float log(float __x)\n+      { return ::log(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_LOG10F\n+    inline float log10(float __x)\n+      { return ::log10f(__x); }\n+#else\n+    inline float log10(float __x)\n+      { return ::log10(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_MODFF\n+    inline float modf(float __x, float* __iptr)\n+      { return ::modff(__x, __iptr); }\n+#else\n+    inline float modf(float __x, float* __iptr)\n+    {\n+       double __tmp;\n+       double __res = ::modf(static_cast<double>(__x), &__tmp);\n+       *__iptr = static_cast<float> (__tmp);\n+       return __res;\n+    }\n+#endif\n+\n+#if _GLIBCPP_HAVE_POWF\n+    inline float pow(float __x, float __y)\n+      { return ::powf(__x, __y); }\n+#else\n+    inline float pow(float __x, float __y)\n+      { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }\n+#endif\n+\n+    float pow(float, int);\n+\n+#if _GLIBCPP_HAVE___BUILTIN_SINF\n+    inline float sin(float __x)\n+      { return __builtin_sinf(__x); }\n+#elif _GLIBCPP_HAVE_SINF\n+    inline float sin(float __x)\n+      { return ::sinf(__x); }\n+#else\n+    inline float sin(float __x)\n+      { return ::sin(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_SINHF\n+    inline float sinh(float __x)\n+      { return ::sinhf(__x); }\n+#else\n+    inline float sinh(float __x)\n+      { return ::sinh(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE___BUILTIN_SQRTF\n+    inline float sqrt(float __x)\n+      { return __builtin_sqrtf(__x); }\n+#elif _GLIBCPP_HAVE_SQRTF\n+    inline float sqrt(float __x)\n+      { return ::sqrtf(__x); }\n+#else\n+    inline float sqrt(float __x)\n+      { return ::sqrt(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_TANF\n+    inline float tan(float __x)\n+      { return ::tanf(__x); }\n+#else\n+    inline float tan(float __x)\n+      { return ::tan(static_cast<double>(__x)); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_TANHF\n+    inline float tanh(float __x)\n+      { return ::tanhf(__x); }\n+#else\n+    inline float tanh(float __x)\n+      { return ::tanh(static_cast<double>(__x)); }\n+#endif\n+\n+    //\n+    // double\n+    //\n+\n+#if _GLIBCPP_HAVE___BUILTIN_FABS\n+    inline double abs(double __x)\n+      { return __builtin_fabs(__x); }\n+#else\n+    inline double abs(double __x)\n+      { return ::fabs(__x); }\n+#endif\n+\n+    inline double acos(double __x)\n+      { return ::acos(__x); }\n+\n+    inline double asin(double __x)\n+      { return ::asin(__x); }\n+\n+    inline double atan(double __x)\n+      { return ::atan(__x); }\n+\n+    inline double atan2(double __y, double __x)\n+      { return ::atan2(__y, __x); }\n+\n+    inline double ceil(double __x)\n+      { return ::ceil(__x); }\n+\n+#if _GLIBCPP_HAVE___BUILTIN_COS\n+    inline double cos(double __x)\n+      { return __builtin_cos(__x); }\n+#else\n+    inline double cos(double __x)\n+      { return ::cos(__x); }\n+#endif\n+\n+    inline double cosh(double __x)\n+      { return ::cosh(__x); }\n+\n+    inline double exp(double __x)\n+      { return ::exp(__x); }\n+\n+\n+#if _GLIBCPP_HAVE___BUILTIN_FABS\n+    inline double fabs(double __x)\n+      { return __builtin_fabs(__x); }\n+#else\n+    inline double fabs(double __x)\n+      { return ::fabs(__x); }\n+#endif\n+\n+    inline double floor(double __x)\n+      { return ::floor(__x); }\n+\n+    inline double fmod(double __x, double __y)\n+      { return ::fmod(__x, __y); }\n+\n+    inline double frexp(double __x, int* __exp)\n+      { return ::frexp(__x, __exp); }\n+\n+    inline double ldexp(double __x, int __exp)\n+      { return ::ldexp(__x, __exp); }\n+\n+    inline double log(double __x)\n+      { return ::log(__x); }\n+\n+    inline double log10(double __x)\n+      { return ::log10(__x); }\n+\n+    inline double modf(double __x, double* __iptr)\n+      { return ::modf(__x, __iptr); }\n+\n+    inline double pow(double __x, double __y)\n+      { return ::pow(__x, __y); }\n+\n+    double pow (double, int);\n+\n+#if _GLIBCPP_HAVE___BUILTIN_SIN\n+    inline double sin(double __x)\n+      { return __builtin_sin(__x); }\n+#else\n+    inline double sin(double __x)\n+      { return ::sin(__x); }\n+#endif\n+\n+    inline double sinh(double __x)\n+      { return ::sinh(__x); }\n+\n+#if _GLIBCPP_HAVE___BUILTIN_SQRT\n+    inline double sqrt(double __x)\n+      { return __builtin_fsqrt(__x); }\n+#else\n+    inline double sqrt(double __x)\n+      { return ::sqrt(__x); }\n+#endif\n+\n+    inline double tan(double __x)\n+      { return ::tan(__x); }\n+\n+    inline double tanh(double __x)\n+      { return ::tanh(__x); }\n+\n+    //\n+    // long double\n+    //\n+#if _GLIBCPP_HAVE___BUILTIN_FABSL\n+    inline long double abs(long double __x)\n+      { return __builtin_fabsl(__x); }\n+#elif _GLIBCPP_HAVE_FABSL\n+    inline long double abs(long double __x)\n+      { return ::fabsl(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_ACOSL\n+    inline long double acos(long double __x)\n+      { return ::acosl(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_ASINL\n+    inline long double asin(long double __x)\n+      { return ::asinl(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_ATANL\n+    inline long double atan(long double __x)\n+      { return ::atanl(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_ATAN2L\n+    inline long double atan2(long double __y, long double __x)\n+      { return ::atan2l(__y, __x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_CEILL\n+    inline long double ceil(long double __x)\n+      { return ::ceill(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE___BUILTIN_COSL\n+    inline long double cos(long double __x)\n+      { return __builtin_cosl(__x); }\n+#elif _GLIBCPP_HAVE_COSL\n+    inline long double cos(long double __x)\n+      { return ::cosl(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_COSHL\n+    inline long double cosh(long double __x)\n+      { return ::coshl(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_EXPL\n+    inline long double exp(long double __x)\n+      { return ::expl(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE___BUILTIN_FABSL\n+    inline long double fabs(long double __x)\n+      { return __builtin_fabsl(__x); }\n+#elif _GLIBCPP_HAVE_FABSL\n+    inline long double fabs(long double __x)\n+      { return ::fabsl(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_FLOORL\n+    inline long double floor(long double __x)\n+      { return ::floorl(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_FMODL\n+    inline long double fmod(long double __x, long double __y)\n+      { return ::fmodl(__x, __y); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_FREXPL\n+    inline long double frexp(long double __x, int* __exp)\n+      { return ::frexpl(__x, __exp); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_LDEXPL\n+    inline long double ldexp(long double __x, int __exp)\n+      { return ::ldexpl(__x, __exp); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_LOGL\n+    inline long double log(long double __x)\n+      { return ::logl(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_LOG10L\n+    inline long double log10(long double __x)\n+      { return ::log10l(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_MODFL\n+    inline long double modf(long double __x, long double* __iptr)\n+      { return ::modfl(__x, __iptr); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_POWL\n+    inline long double pow(long double __x, long double __y)\n+      { return ::powl(__x, __y); }\n+#endif\n+\n+    long double pow(long double, int);\n+\n+#if _GLIBCPP_HAVE___BUILTIN_SINL\n+    inline long double sin(long double __x)\n+      { return __builtin_sinl(__x); }\n+#elif _GLIBCPP_HAVE_SINL\n+    inline long double sin(long double __x)\n+      { return ::sinl(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_SINHL\n+    inline long double sinh(long double __x)\n+      { return ::sinhl(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE___BUILTIN_SQRTL\n+    inline long double sqrt(long double __x)\n+      { return __builtin_sqrtl(__x); }\n+#elif _GLIBCPP_HAVE_SQRTL\n+    inline long double sqrt(long double __x)\n+      { return ::sqrtl(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_TANL\n+    inline long double tan(long double __x)\n+      { return ::tanl(__x); }\n+#endif\n+\n+#if _GLIBCPP_HAVE_TANHL\n+    inline long double tanh(long double __x)\n+      { return ::tanhl(__x); }\n+#endif\n+\n+} // std\n+\n+#endif // _CPP_CMATH\n+\n+"}, {"sha": "63f735181daf8ba6496b5f46aec024a87f33db55", "filename": "libstdc++-v3/include/bits/std_complex.h", "status": "added", "additions": 961, "deletions": 0, "changes": 961, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_complex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_complex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_complex.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,961 @@\n+// The template and inlines for the -*- C++ -*- complex number classes.\n+\n+// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO 14882/26.2.1\n+// Note: this is not a conforming implementation.\n+// Initially implemented by Ulrich Drepper <drepper@cygnus.com>\n+// Improved by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>\n+//\n+\n+#ifndef _CPP_COMPLEX\n+#define _CPP_COMPLEX\t1\n+\n+#include <bits/c++config.h>\n+#include <bits/std_iosfwd.h>\n+\n+namespace std\n+{\n+\n+  // Forward declarations\n+  template<typename _Tp> class complex;\n+  template<> class complex<float>;\n+  template<> class complex<double>;\n+  template<> class complex<long double>;\n+\n+  template<typename _Tp> _Tp abs(const complex<_Tp>&);\n+  template<typename _Tp>  _Tp arg(const complex<_Tp>&);\n+\n+  template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp&);\n+\n+    // Transcendentals:\n+  template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);\n+  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);\n+  template<typename _Tp> complex<_Tp> pow (const complex<_Tp>&,\n+\t\t\t\t\t   const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);\n+  template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);\n+    \n+    \n+  //\n+  // 26.2.2  Primary template class complex\n+  //\n+  template <typename _Tp>\n+    class complex\n+    {\n+    public:\n+      typedef _Tp value_type;\n+      \n+      complex(const _Tp& = _Tp(), const _Tp & = _Tp());\n+\n+      // Let's the compiler synthetize the copy constructor   \n+      // complex (const complex<_Tp>&);\n+      template <typename _Up>\n+        complex(const complex<_Up>&);\n+        \n+      _Tp real() const;\n+      _Tp imag() const;\n+\n+      complex<_Tp>& operator=(const _Tp&);\n+      complex<_Tp>& operator+=(const _Tp&);\n+      complex<_Tp>& operator-=(const _Tp&);\n+      complex<_Tp>& operator*=(const _Tp&);\n+      complex<_Tp>& operator/=(const _Tp&);\n+\n+      // Let's the compiler synthetize the\n+      // copy and assignment operator\n+      // complex<_Tp>& operator= (const complex<_Tp>&);\n+      template <typename _Up>\n+        complex<_Tp>& operator=(const complex<_Up>&);\n+      template <typename _Up>\n+        complex<_Tp>& operator+=(const complex<_Up>&);\n+      template <typename _Up>\n+        complex<_Tp>& operator-=(const complex<_Up>&);\n+      template <typename _Up>\n+        complex<_Tp>& operator*=(const complex<_Up>&);\n+      template <typename _Up>\n+        complex<_Tp>& operator/=(const complex<_Up>&);\n+\n+    private:\n+      _Tp _M_real, _M_imag;\n+    };\n+\n+  template<typename _Tp>\n+    inline _Tp\n+    complex<_Tp>::real() const { return _M_real; }\n+\n+  template<typename _Tp>\n+    inline _Tp\n+    complex<_Tp>::imag() const { return _M_imag; }\n+\n+    \n+  //\n+  // 26.2.3  complex specializations\n+  //\n+\n+  //\n+  // complex<float> specialization\n+  //\n+  template<> class complex<float>\n+  {\n+  public:\n+    typedef float value_type;\n+    \n+    complex(float = 0.0f, float = 0.0f);\n+#ifdef _GLIBCPP_BUGGY_COMPLEX\n+    complex(const complex& __z) : _M_value(__z._M_value) { }\n+#endif\n+    explicit complex(const complex<double>&);\n+    explicit complex(const complex<long double>&);\n+\n+    float real() const;\n+    float imag() const;\n+\n+    complex<float>& operator=(float);\n+    complex<float>& operator+=(float);\n+    complex<float>& operator-=(float);\n+    complex<float>& operator*=(float);\n+    complex<float>& operator/=(float);\n+        \n+    // Let's the compiler synthetize the copy and assignment\n+    // operator.  It always does a pretty good job.\n+    // complex& operator= (const complex&);\n+    template <typename _Tp>\n+      complex<float>&operator=(const complex<_Tp>&);\n+    template <typename _Tp>\n+      complex<float>& operator+=(const complex<_Tp>&);\n+    template <class _Tp>\n+      complex<float>& operator-=(const complex<_Tp>&);\n+    template <class _Tp>\n+      complex<float>& operator*=(const complex<_Tp>&);\n+    template <class _Tp>\n+      complex<float>&operator/=(const complex<_Tp>&);\n+\n+  private:\n+    typedef __complex__ float _ComplexT;\n+    _ComplexT _M_value;\n+\n+    complex(_ComplexT __z) : _M_value(__z) { }\n+        \n+    friend class complex<double>;\n+    friend class complex<long double>;\n+\n+    friend float abs<>(const complex<float>&);\n+    friend float arg<>(const complex<float>&);\n+\n+    friend complex<float> conj<>(const complex<float>&);\n+\n+    friend complex<float> cos<>(const complex<float>&);\n+    friend complex<float> cosh<>(const complex<float>&);\n+    friend complex<float> exp<>(const complex<float>&);\n+    friend complex<float> log<>(const complex<float>&);\n+    friend complex<float> log10<>(const complex<float>&);\n+    friend complex<float> pow<>(const complex<float>&, int);\n+    friend complex<float> pow<>(const complex<float>&, const float&);\n+    friend complex<float> pow<>(const complex<float>&,\n+\t\t\t\tconst complex<float>&);\n+    friend complex<float> pow<>(const float&, const complex<float>&);\n+    friend complex<float> sin<>(const complex<float>&);\n+    friend complex<float> sinh<>(const complex<float>&);\n+    friend complex<float> sqrt<>(const complex<float>&);\n+    friend complex<float> tan<>(const complex<float>&);\n+    friend complex<float> tanh<>(const complex<float>&);\n+  };\n+\n+  inline float\n+  complex<float>::real() const\n+  { return __real__ _M_value; }\n+\n+  inline float\n+  complex<float>::imag() const\n+  { return __imag__ _M_value; }\n+\n+\n+  //\n+  // complex<double> specialization\n+  //\n+  template<> class complex<double>\n+  {\n+  public:\n+    typedef double value_type;\n+\n+    complex(double  =0.0, double =0.0);\n+#ifdef _GLIBCPP_BUGGY_COMPLEX\n+    complex(const complex& __z) : _M_value(__z._M_value) { }\n+#endif\n+    complex(const complex<float>&);\n+    explicit complex(const complex<long double>&);\n+        \n+    double real() const;\n+    double imag() const;\n+        \n+    complex<double>& operator=(double);\n+    complex<double>& operator+=(double);\n+    complex<double>& operator-=(double);\n+    complex<double>& operator*=(double);\n+    complex<double>& operator/=(double);\n+\n+    // The compiler will synthetize this, efficiently.\n+    // complex& operator= (const complex&);\n+    template <typename _Tp>\n+      complex<double>& operator=(const complex<_Tp>&);\n+    template <typename _Tp>\n+      complex<double>& operator+=(const complex<_Tp>&);\n+    template <typename _Tp>\n+      complex<double>& operator-=(const complex<_Tp>&);\n+    template <typename _Tp>\n+      complex<double>& operator*=(const complex<_Tp>&);\n+    template <typename _Tp>\n+      complex<double>& operator/=(const complex<_Tp>&);\n+\n+  private:\n+    typedef __complex__ double _ComplexT;\n+    _ComplexT _M_value;\n+\n+    complex(_ComplexT __z) : _M_value(__z) { }\n+        \n+    friend class complex<float>;\n+    friend class complex<long double>;\n+\n+    friend double abs<>(const complex<double>&);\n+    friend double arg<>(const complex<double>&);\n+\n+    friend complex<double> conj<>(const complex<double>&);\n+    friend complex<double> cos<>(const complex<double>&);\n+    friend complex<double> cosh<>(const complex<double>&);\n+    friend complex<double> exp<>(const complex<double>&);\n+    friend complex<double> log<>(const complex<double>&);\n+    friend complex<double> log10<>(const complex<double>&);\n+    friend complex<double> pow<>(const complex<double>&, int);\n+    friend complex<double> pow<>(const complex<double>&, const double&);\n+    friend complex<double> pow<>(const complex<double>&,\n+\t\t\t\t const complex<double>&);\n+    friend complex<double> pow<>(const double&, const complex<double>&);\n+    friend complex<double> sin<>(const complex<double>&);\n+    friend complex<double> sinh<>(const complex<double>&);\n+    friend complex<double> sqrt<>(const complex<double>&);\n+    friend complex<double> tan<>(const complex<double>&);\n+    friend complex<double> tanh<>(const complex<double>&);\n+  };\n+\n+  inline double\n+  complex<double>::real() const\n+  { return __real__ _M_value; }\n+\n+  inline double\n+  complex<double>::imag() const\n+  { return __imag__ _M_value; }\n+\n+\n+  //\n+  // complex<long double> specialization\n+  //\n+  template<> class complex<long double>\n+  {\n+  public:\n+    typedef long double value_type;\n+\n+    complex(long double = 0.0L, long double = 0.0L);\n+#ifdef _GLIBCPP_BUGGY_COMPLEX\n+    complex(const complex& __z) : _M_value(__z._M_value) { }\n+#endif\n+    complex(const complex<float>&);\n+    complex(const complex<double>&);\n+\n+    long double real() const;\n+    long double imag() const;\n+\n+    complex<long double>& operator= (long double);\n+    complex<long double>& operator+= (long double);\n+    complex<long double>& operator-= (long double);\n+    complex<long double>& operator*= (long double);\n+    complex<long double>& operator/= (long double);\n+\n+    // The compiler knows how to do this efficiently\n+    // complex& operator= (const complex&);\n+\n+    template<typename _Tp>\n+      complex<long double>& operator=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<long double>& operator+=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<long double>& operator-=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<long double>& operator*=(const complex<_Tp>&);\n+    template<typename _Tp>\n+      complex<long double>& operator/=(const complex<_Tp>&);\n+\n+  private:\n+    typedef __complex__ long double _ComplexT;\n+    _ComplexT _M_value;\n+\n+    complex(_ComplexT __z) : _M_value(__z) { }\n+\n+    friend class complex<float>;\n+    friend class complex<double>;\n+\n+    friend long double abs<>(const complex<long double>&);\n+    friend long double arg<>(const complex<long double>&);\n+\n+    friend complex<long double> conj<>(const complex<long double>&);\n+    friend complex<long double> cos<>(const complex<long double>&);\n+    friend complex<long double> cosh<>(const complex<long double>&);\n+    friend complex<long double> exp<>(const complex<long double>&);\n+    friend complex<long double> log<>(const complex<long double>&);\n+    friend complex<long double> log10<>(const complex<long double>&);\n+    friend complex<long double> pow<>(const complex<long double>&, int);\n+    friend complex<long double> pow<>(const complex<long double>&,\n+\t\t\t\t      const long double&);\n+    friend complex<long double> pow<>(const complex<long double>&,\n+\t\t\t\t      const complex<long double>&);\n+    friend complex<long double> pow<>(const long double&,\n+\t\t\t\t      const complex<long double>&);\n+    friend complex<long double> sin<>(const complex<long double>&);\n+    friend complex<long double> sinh<>(const complex<long double>&);\n+    friend complex<long double> sqrt<>(const complex<long double>&);\n+    friend complex<long double> tan<>(const complex<long double>&);\n+    friend complex<long double> tanh<>(const complex<long double>&);\n+  };\n+\n+  inline\n+  complex<long double>::complex(long double __r, long double __i)\n+  {\n+    __real__ _M_value = __r;\n+    __imag__ _M_value = __i;\n+  }\n+\n+  inline\n+  complex<long double>::complex(const complex<float>& __z)\n+  : _M_value(_ComplexT(__z._M_value)) { }\n+\n+  inline\n+  complex<long double>::complex(const complex<double>& __z)\n+  : _M_value(_ComplexT(__z._M_value)) { }\n+\n+  inline long double\n+  complex<long double>::real() const\n+  { return __real__ _M_value; }\n+\n+  inline long double\n+  complex<long double>::imag() const\n+  { return __imag__ _M_value; }\n+\n+  inline complex<long double>&   \n+  complex<long double>::operator=(long double __r)\n+  {\n+    __real__ _M_value = __r;\n+    __imag__ _M_value = 0.0L;\n+    return *this;\n+  }\n+\n+  inline complex<long double>&\n+  complex<long double>::operator+=(long double __r)\n+  {\n+    __real__ _M_value += __r;\n+    return *this;\n+  }\n+\n+  inline complex<long double>&\n+  complex<long double>::operator-=(long double __r)\n+  {\n+    __real__ _M_value -= __r;\n+    return *this;\n+  }\n+\n+  inline complex<long double>&\n+  complex<long double>::operator*=(long double __r)\n+  {\n+    __real__ _M_value *= __r;\n+    return *this;\n+  }\n+\n+  inline complex<long double>&\n+  complex<long double>::operator/=(long double __r)\n+  {\n+    __real__ _M_value /= __r;\n+    return *this;\n+  }\n+\n+  template<typename _Tp>\n+    inline complex<long double>&\n+    complex<long double>::operator=(const complex<_Tp>& __z)\n+    {\n+      __real__ _M_value = __z.real();\n+      __imag__ _M_value = __z.imag();\n+      return *this;\n+    }\n+\n+  template<typename _Tp>\n+    inline complex<long double>&\n+    complex<long double>::operator+=(const complex<_Tp>& __z)\n+    {\n+      __real__ _M_value += __z.real();\n+      __imag__ _M_value += __z.imag();\n+      return *this;\n+    }\n+\n+  template<typename _Tp>\n+    inline complex<long double>&\n+    complex<long double>::operator-=(const complex<_Tp>& __z)\n+    {\n+      __real__ _M_value -= __z.real();\n+      __imag__ _M_value -= __z.imag();\n+      return *this;\n+    }\n+    \n+  template<typename _Tp>\n+    inline complex<long double>&\n+    complex<long double>::operator*=(const complex<_Tp>& __z)\n+    {\n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value *= __t;\n+      return *this;\n+    }\n+\n+  template<typename _Tp>\n+    inline complex<long double>&\n+    complex<long double>::operator/=(const complex<_Tp>& __z)\n+    {\n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value /= __t;\n+      return *this;\n+    }\n+\n+  //\n+  // complex<float> continued.\n+  //\n+  inline\n+  complex<float>::complex(float r, float i)\n+  {\n+    __real__ _M_value = r;\n+    __imag__ _M_value = i;\n+  }\n+\n+  inline\n+  complex<float>::complex(const complex<double>& __z)\n+  : _M_value(_ComplexT(__z._M_value)) { }\n+\n+  inline\n+  complex<float>::complex(const complex<long double>& __z)\n+  : _M_value(_ComplexT(__z._M_value)) { }\n+\n+  inline complex<float>&\n+  complex<float>::operator=(float __f)\n+  {\n+    __real__ _M_value = __f;\n+    __imag__ _M_value = 0.0f;\n+    return *this;\n+  }\n+\n+  inline complex<float>&\n+  complex<float>::operator+=(float __f)\n+  {\n+    __real__ _M_value += __f;\n+    return *this;\n+  }\n+\n+  inline complex<float>&\n+  complex<float>::operator-=(float __f)\n+  {\n+    __real__ _M_value -= __f;\n+    return *this;\n+  }\n+\n+  inline complex<float>&\n+  complex<float>::operator*=(float __f)\n+  {\n+    _M_value *= __f;\n+    return *this;\n+  }\n+\n+  inline complex<float>&\n+  complex<float>::operator/=(float __f)\n+  {\n+    _M_value /= __f;\n+    return *this;\n+  }\n+\n+  template<typename _Tp>\n+  inline complex<float>&\n+  complex<float>::operator=(const complex<_Tp>& __z)\n+  {\n+    __real__ _M_value = __z.real();\n+    __imag__ _M_value = __z.imag();\n+    return *this;\n+  }\n+\n+  template<typename _Tp>\n+  inline complex<float>&\n+  complex<float>::operator+=(const complex<_Tp>& __z)\n+  {\n+    __real__ _M_value += __z.real();\n+    __imag__ _M_value += __z.imag();\n+    return *this;\n+  }\n+    \n+  template<typename _Tp>\n+    inline complex<float>&\n+    complex<float>::operator-=(const complex<_Tp>& __z)\n+    {\n+     __real__ _M_value -= __z.real();\n+     __imag__ _M_value -= __z.real();\n+     return *this;\n+    } \n+\n+  template<typename _Tp>\n+    inline complex<float>&\n+    complex<float>::operator*=(const complex<_Tp>& __z)\n+    {\n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value *= __t;\n+      return *this;\n+    }\n+\n+  template<typename _Tp>\n+    inline complex<float>&\n+    complex<float>::operator/=(const complex<_Tp>& __z)\n+    {\n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value /= __t;\n+      return *this;\n+    }\n+\n+\n+  //\n+  // complex<double> continued.\n+  //\n+  inline\n+  complex<double>::complex(double __r, double __i)\n+  {\n+    __real__ _M_value = __r;\n+    __imag__ _M_value = __i;\n+  }\n+\n+  inline\n+  complex<double>::complex(const complex<float>& __z) \n+  : _M_value(_ComplexT(__z._M_value)) { }\n+\n+  inline\n+  complex<double>::complex(const complex<long double>& __z)\n+  {\n+    __real__ _M_value = __z.real();\n+    __imag__ _M_value = __z.imag();\n+  }\n+\n+  inline complex<double>&\n+  complex<double>::operator=(double __d)\n+  {\n+    __real__ _M_value = __d;\n+    __imag__ _M_value = 0.0;\n+    return *this;\n+  }\n+\n+  inline complex<double>&\n+  complex<double>::operator+=(double __d)\n+  {\n+    __real__ _M_value += __d;\n+    return *this;\n+  }\n+\n+  inline complex<double>&\n+  complex<double>::operator-=(double __d)\n+  {\n+    __real__ _M_value -= __d;\n+    return *this;\n+  }\n+\n+  inline complex<double>&\n+  complex<double>::operator*=(double __d)\n+  {\n+    _M_value *= __d;\n+    return *this;\n+  }\n+\n+  inline complex<double>&\n+  complex<double>::operator/=(double __d)\n+  {\n+    _M_value /= __d;\n+    return *this;\n+  }\n+\n+  template<typename _Tp>\n+    inline complex<double>&\n+    complex<double>::operator=(const complex<_Tp>& __z)\n+    {\n+      __real__ _M_value = __z.real();\n+      __imag__ _M_value = __z.imag();\n+      return *this;\n+    }\n+    \n+  template<typename _Tp>\n+    inline complex<double>&\n+    complex<double>::operator+=(const complex<_Tp>& __z)\n+    {\n+      __real__ _M_value += __z.real();\n+      __imag__ _M_value += __z.imag();\n+      return *this;\n+    }\n+\n+  template<typename _Tp>\n+    inline complex<double>&\n+    complex<double>::operator-=(const complex<_Tp>& __z)\n+    {\n+      __real__ _M_value -= __z.real();\n+      __imag__ _M_value -= __z.imag();\n+      return *this;\n+    }\n+\n+  template<typename _Tp>\n+    inline complex<double>&\n+    complex<double>::operator*=(const complex<_Tp>& __z)\n+    {\n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value *= __t;\n+      return *this;\n+    }\n+\n+  template<typename _Tp>\n+    inline complex<double>&\n+    complex<double>::operator/=(const complex<_Tp>& __z)\n+    {\n+      _ComplexT __t;\n+      __real__ __t = __z.real();\n+      __imag__ __t = __z.imag();\n+      _M_value /= __t;\n+      return *this;\n+    }\n+\n+  //\n+  // Primary template class complex continued.\n+  //\n+  // 26.2.4\n+  template<typename _Tp>\n+    inline \n+    complex<_Tp>::complex(const _Tp& __r, const _Tp& __i)\n+    : _M_real(__r), _M_imag(__i) { }\n+\n+  template<typename _Tp>\n+    template<typename _Up>\n+    inline \n+    complex<_Tp>::complex(const complex<_Up>& __z)\n+    : _M_real(__z.real()), _M_imag(__z.imag()) { }\n+\n+  // 26.2.7/6\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    conj(const complex<_Tp>& __z)\n+    { return complex<_Tp>(__z.real(), -__z.imag()); }\n+\n+  // 26.2.7/4\n+  template<typename _Tp>\n+    inline _Tp\n+    norm(const complex<_Tp>& __z)\n+    {\n+      // XXX: Grammar school computation\n+      return __z.real() * __z.real() + __z.imag() * __z.imag();\n+    }\n+        \n+  template<typename _Tp>\n+    complex<_Tp>&\n+    complex<_Tp>::operator=(const _Tp& __t)\n+    {\n+     _M_real = __t;\n+     _M_imag = _Tp();\n+     return *this;\n+    } \n+\n+  // 26.2.5/1\n+  template<typename _Tp>\n+    inline complex<_Tp>&\n+    complex<_Tp>::operator+=(const _Tp& __t)\n+    {\n+      _M_real += __t;\n+      return *this;\n+    }\n+\n+  // 26.2.5/3\n+  template<typename _Tp>\n+    inline complex<_Tp>&\n+    complex<_Tp>::operator-=(const _Tp& __t)\n+    {\n+      _M_real -= __t;\n+      return *this;\n+    }\n+\n+  // 26.2.5/5\n+  template<typename _Tp>\n+    complex<_Tp>&\n+    complex<_Tp>::operator*=(const _Tp& __t)\n+    {\n+      _M_real *= __t;\n+      _M_imag *= __t;\n+      return *this;\n+    }\n+\n+  // 26.2.5/7\n+  template<typename _Tp>\n+    complex<_Tp>&\n+    complex<_Tp>::operator/=(const _Tp& __t)\n+    {\n+      _M_real /= __t;\n+      _M_imag /= __t;\n+      return *this;\n+    }\n+\n+  template<typename _Tp>\n+    template<typename _Up>\n+    complex<_Tp>&\n+    complex<_Tp>::operator=(const complex<_Up>& __z)\n+    {\n+      _M_real = __z.real();\n+      _M_imag = __z.imag();\n+      return *this;\n+    }\n+\n+  // 26.2.5/9\n+  template<typename _Tp>\n+    template<typename _Up>\n+    complex<_Tp>&\n+    complex<_Tp>::operator+=(const complex<_Up>& __z)\n+    {\n+      _M_real += __z.real();\n+      _M_imag += __z.imag();\n+      return *this;\n+    }\n+\n+  // 26.2.5/11\n+  template<typename _Tp>\n+    template<typename _Up>\n+    complex<_Tp>&\n+    complex<_Tp>::operator-=(const complex<_Up>& __z)\n+    {\n+      _M_real -= __z.real();\n+      _M_imag -= __z.imag();\n+      return *this;\n+    }\n+\n+  // 26.2.5/13\n+  // XXX: this is a grammar school implementation.\n+  template<typename _Tp>\n+    template<typename _Up>\n+    complex<_Tp>&\n+    complex<_Tp>::operator*=(const complex<_Up>& __z)\n+    {\n+      _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();\n+      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();\n+      _M_real = __r;\n+      return *this;\n+    }\n+\n+  // 26.2.5/15\n+  // XXX: this is a grammar school implementation.\n+  template<typename _Tp>\n+    template<typename _Up>\n+    complex<_Tp>&\n+    complex<_Tp>::operator/=(const complex<_Up>& __z)\n+    {\n+      _Tp __r =  _M_real * __z.real() + _M_imag * __z.imag();\n+      _Tp __n = norm(__z);\n+      _M_imag = (_M_real * __z.imag() - _M_imag * __z.real()) / __n;\n+      _M_real = __r / __n;\n+      return *this;\n+    }\n+    \n+  // Operators:\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) += __y; }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator+(const complex<_Tp>& __x, const _Tp& __y)\n+    { return complex<_Tp> (__x) += __y; }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator+(const _Tp& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__y) += __x; }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) -= __y; }\n+    \n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator-(const complex<_Tp>& __x, const _Tp& __y)\n+    { return complex<_Tp> (__x) -= __y; }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator-(const _Tp& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) -= __y; }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) *= __y; }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator*(const complex<_Tp>& __x, const _Tp& __y)\n+    { return complex<_Tp> (__x) *= __y; }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator*(const _Tp& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__y) *= __x; }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) /= __y; }\n+    \n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator/(const complex<_Tp>& __x, const _Tp& __y)\n+    { return complex<_Tp> (__x) /= __y; }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator/(const _Tp& __x, const complex<_Tp>& __y)\n+    { return complex<_Tp> (__x) /= __y; }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator+(const complex<_Tp>& __x)\n+    { return __x; }\n+\n+  template<typename _Tp>\n+    inline complex<_Tp>\n+    operator-(const complex<_Tp>& __x)\n+    {  return complex<_Tp>(-__x.real(), -__x.imag()); }\n+\n+  template<typename _Tp>\n+    inline bool\n+    operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return __x.real() == __y.real() && __x.imag() == __y.imag(); }\n+\n+  template<typename _Tp>\n+    inline bool\n+    operator==(const complex<_Tp>& __x, const _Tp& __y)\n+    { return __x.real() == __y && __x.imag() == 0; }\n+\n+  template<typename _Tp>\n+    inline bool\n+    operator==(const _Tp& __x, const complex<_Tp>& __y)\n+    { return __x == __y.real() && 0 == __y.imag(); }\n+\n+  template<typename _Tp>\n+    inline bool\n+    operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)\n+    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }\n+\n+  template<typename _Tp>\n+    inline bool\n+    operator!=(const complex<_Tp>& __x, const _Tp& __y)\n+    { return __x.real() != __y || __x.imag() != 0; }\n+\n+  template<typename _Tp>\n+    inline bool\n+    operator!=(const _Tp& __x, const complex<_Tp>& __y)\n+    { return __x != __y.real() || 0 != __y.imag(); }\n+\n+  template<typename _Tp, typename _CharT, class _Traits>\n+    basic_istream<_CharT, _Traits>&\n+    operator>>(basic_istream<_CharT, _Traits>&, complex<_Tp>&);\n+\n+  template<typename _Tp, typename _CharT, class _Traits>\n+    basic_ostream<_CharT, _Traits>&\n+    operator<<(basic_ostream<_CharT, _Traits>&, const complex<_Tp>&);\n+\n+\n+  // Values:\n+  template <typename _Tp>\n+    inline _Tp\n+    real(const complex<_Tp>& __z)\n+    { return __z.real(); }\n+    \n+  template <typename _Tp>\n+    inline _Tp\n+    imag(const complex<_Tp>& __z)\n+    { return __z.imag(); }\n+    \n+\n+  // We use here a few more specializations.\n+  template<>\n+    inline complex<float>\n+    conj(const complex<float> &__x)\n+#ifdef _GLIBCPP_BUGGY_FLOAT_COMPLEX\n+    {\n+      complex<float> __tmpf(~__x._M_value);\n+      return __tmpf;\n+    }\n+#else\n+  { return complex<float>(~__x._M_value); }\n+#endif\n+\n+  template<>\n+    inline complex<double>\n+    conj(const complex<double> &__x)\n+    {  return complex<double> (~__x._M_value); }\n+\n+  template<>\n+    inline complex<long double>\n+    conj(const complex<long double> &__x)\n+    { return complex<long double> (~__x._M_value); }\n+\n+} // namespace std\n+\n+#endif\t/* _CPP_COMPLEX */\n+\n+\n+\n+"}, {"sha": "fc5b339036a2f0460ecbde8c48a279bf7a2c9870", "filename": "libstdc++-v3/include/bits/std_csetjmp.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_csetjmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_csetjmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_csetjmp.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,40 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 20.4.6  C library\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CSETJMP\n+#define _CPP_CSETJMP 1\n+# pragma GCC system_header\n+# include_next <setjmp.h>\n+#endif"}, {"sha": "34c03eb3df10f414337c0d5dffdfe2d20dc2d5f1", "filename": "libstdc++-v3/include/bits/std_csignal.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_csignal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_csignal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_csignal.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,40 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 20.4.6  C library\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CSIGNAL\n+#define _CPP_CSIGNAL 1\n+# pragma GCC system_header\n+# include_next <signal.h>\n+#endif"}, {"sha": "f7f4235a29060808a33fb8d66374b18005a5ae4a", "filename": "libstdc++-v3/include/bits/std_cstdarg.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cstdarg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cstdarg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cstdarg.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,40 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 20.4.6  C library\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CSTDARG\n+#define _CPP_CSTDARG 1\n+# pragma GCC system_header\n+# include_next <stdarg.h>\n+#endif"}, {"sha": "5557c759571ca212f2c60db25a1c67b013ac7705", "filename": "libstdc++-v3/include/bits/std_cstddef.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cstddef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cstddef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cstddef.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,40 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 18.1  Types\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CSTDDEF\n+#define _CPP_CSTDDEF 1\n+# pragma GCC system_header\n+# include_next <stddef.h>\n+#endif"}, {"sha": "919a03ca4c7297a6f71afcba6755d1d106644dc0", "filename": "libstdc++-v3/include/bits/std_cstdio.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cstdio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cstdio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cstdio.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,61 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.8.2  C Library files\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CSTDIO\n+#define _CPP_CSTDIO 1\n+# pragma GCC system_header\n+# include_next <stdio.h>\n+\n+#ifndef SEEK_CUR\n+#define SEEK_CUR 1\n+#endif\n+\n+#ifndef SEEK_END\n+#define SEEK_END 2\n+#endif\n+\n+#ifndef SEEK_SET\n+#define SEEK_SET 4\n+#endif\n+\n+#endif\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "ee5435739adb147c0be850f5b191b6456c14de12", "filename": "libstdc++-v3/include/bits/std_cstdlib.h", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cstdlib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cstdlib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cstdlib.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,54 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 20.4.6  C library\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CSTDLIB\n+#define _CPP_CSTDLIB 1\n+\n+// This keeps isanum, et al from being propagated as macros.\n+#if __linux__\n+#define __USE_ISOC9X 1\n+#endif\n+\n+# pragma GCC system_header\n+# include_next <stdlib.h>\n+\n+#endif // _CPP_CSTDLIB\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "06bcdda6535ebdd49881b87071b0932ba4c88ef1", "filename": "libstdc++-v3/include/bits/std_cstring.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cstring.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cstring.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cstring.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,44 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 20.4.6  C library\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CSTRING\n+#define _CPP_CSTRING 1\n+# if defined __GLIBC__ && __GLIBC__ >= 2\n+// We must not see the optimized string functions GNU libc defines.\n+#  define __NO_STRING_INLINES\n+# endif\n+# pragma GCC system_header\n+# include_next <string.h>\n+#endif"}, {"sha": "b30b318f595673d3420dc2d8321e0fa8594342e8", "filename": "libstdc++-v3/include/bits/std_ctime.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_ctime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_ctime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_ctime.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,40 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 20.5  Date and time\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CTIME\n+#define _CPP_CTIME 1\n+# pragma GCC system_header\n+# include_next <time.h>\n+#endif"}, {"sha": "77349f9d318468731bcd3156bd8726085df5946e", "filename": "libstdc++-v3/include/bits/std_cwchar.h", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cwchar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cwchar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cwchar.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,78 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: ???\n+//\n+\n+// Note: this is not a conforming implementation.\n+\n+#ifndef _CPP_CWCHAR\n+#define _CPP_CWCHAR 1\n+\n+#include <bits/c++config.h>\n+\n+#if _GLIBCPP_USE_WCHAR_T\n+ # pragma GCC system_header\n+ # include_next <wchar.h>\n+#else\n+# ifdef __cplusplus\n+extern \"C\" \n+{\n+#endif\n+  typedef struct \n+  {\n+    int __fill[6];\n+  } mbstate_t;\n+# ifdef __cplusplus\n+}\n+# endif\n+#endif //_GLIBCPP_USE_WCHAR_T\n+\n+#endif // _CPP_CWCHAR\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "c67f2ba9720d2fab86da62b303cfc45324e831f2", "filename": "libstdc++-v3/include/bits/std_cwctype.h", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cwctype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cwctype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_cwctype.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,160 @@\n+// -*- C++ -*- forwarding header.\n+\n+// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: <cwctype>\n+//\n+\n+#ifndef _CPP_CWCTYPE\n+#define _CPP_CWCTYPE 1\n+\n+# pragma GCC system_header\n+# include_next <wctype.h>\n+\n+// Sequester the C non-inline implementations in the _C_Swamp::\n+// namespace, and provide C++ inlines for them in the std:: namespace\n+// where they belong.\n+\n+namespace std \n+{\n+\n+#ifdef towupper\n+  inline wint_t \n+  _S_towupper_helper(wint_t __wc) { return towupper(__wc); }\n+# undef towupper\n+  inline wint_t \n+  towupper(wint_t __wc) { return _S_towupper_helper(__wc); }\n+#endif\n+\n+#ifdef towlower\n+  inline wint_t \n+  _S_towlower_helper(wint_t __wc) { return towlower(__wc); }\n+# undef towlower\n+  inline wint_t \n+  towlower(wint_t __wc) { return _S_towlower_helper(__wc); }\n+#endif\n+\n+#ifdef iswspace\n+  inline int \n+  _S_iswspace_helper(wint_t __wc) { return iswspace(__wc); }\n+# undef iswspace\n+  inline int \n+  iswspace(wint_t __wc) { return _S_iswspace_helper(__wc); }\n+#endif\n+\n+#ifdef iswprint\n+  inline int \n+  _S_iswprint_helper(wint_t __wc) { return iswprint(__wc); }\n+# undef iswprint\n+  inline int \n+  iswprint(wint_t __wc) { return _S_iswprint_helper(__wc); }\n+#endif\n+\n+#ifdef iswcntrl\n+  inline int \n+  _S_iswcntrl_helper(wint_t __wc) { return iswcntrl(__wc); }\n+# undef iswcntrl\n+  inline int \n+  iswcntrl(wint_t __wc) { return _S_iswcntrl_helper(__wc); }\n+#endif\n+\n+#ifdef iswupper\n+  inline int \n+  _S_iswupper_helper(wint_t __wc) { return iswupper(__wc); }\n+# undef iswupper\n+  inline int \n+  iswupper(wint_t __wc) { return _S_iswupper_helper(__wc); }\n+#endif\n+\n+#ifdef iswlower\n+  inline int \n+  _S_iswlower_helper(wint_t __wc) { return iswlower(__wc); }\n+# undef iswlower\n+  inline int \n+  iswlower(wint_t __wc) { return _S_iswlower_helper(__wc); }\n+#endif\n+\n+#ifdef iswalpha\n+  inline int \n+  _S_iswalpha_helper(wint_t __wc) { return iswalpha(__wc); }\n+# undef iswalpha\n+  inline int \n+  iswalpha(wint_t __wc) { return _S_iswalpha_helper(__wc); }\n+#endif\n+\n+#ifdef iswdigit\n+  inline int \n+  _S_iswdigit_helper(wint_t __wc) { return iswdigit(__wc); }\n+# undef iswdigit\n+  inline int \n+  iswdigit(wint_t __wc) { return _S_iswdigit_helper(__wc); }\n+#endif\n+\n+#ifdef iswpunct\n+  inline int \n+  _S_iswpunct_helper(wint_t __wc) { return iswpunct(__wc); }\n+# undef iswpunct\n+  inline int \n+  iswpunct(wint_t __wc) { return _S_iswpunct_helper(__wc); }\n+#endif\n+\n+#ifdef iswxdigit\n+  inline int \n+  _S_iswxdigit_helper (wint_t __wc) { return iswxdigit(__wc); }\n+# undef iswxdigit\n+  inline int \n+  iswxdigit(wint_t __wc) { return _S_iswxdigit_helper(__wc); }\n+#endif\n+\n+#ifdef iswalnum\n+  inline int \n+  _S_iswalnum_helper(wint_t __wc) { return iswalnum(__wc); }\n+# undef iswalnum\n+  inline int \n+  iswalnum(wint_t __wc) { return _S_iswalnum_helper(__wc); }\n+#endif\n+\n+#ifdef iswgraph\n+  inline int \n+  _S_iswgraph_helper(wint_t __wc) { return iswgraph(__wc); }\n+# undef iswgraph\n+  inline int \n+  iswgraph(wint_t __wc) { return _S_iswgraph_helper(__wc); }\n+#endif\n+\n+} // namespace std\n+\n+#endif // _CPP_CWCTYPE\n+\n+\n+\n+\n+\n+\n+"}, {"sha": "574ab313755455e8685dec8f90abff02bcd1ea99", "filename": "libstdc++-v3/include/bits/std_deque.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_deque.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,41 @@\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _CPP_DEQUE\n+#define _CPP_DEQUE 1\n+\n+#include <bits/stl_range_errors.h>\n+#include <bits/stl_algobase.h>\n+#include <bits/stl_alloc.h>\n+#include <bits/stl_construct.h>\n+#include <bits/stl_uninitialized.h>\n+#include <bits/stl_deque.h>\n+\n+#endif /* _CPP_DEQUE */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "0735601891f3db3dfe1ed8781ff659f42e216380", "filename": "libstdc++-v3/include/bits/std_exception.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_exception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_exception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_exception.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,81 @@\n+\n+// Copyright (C) 1997-1999 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _CPP_EXCEPTION\n+#define _CPP_EXCEPTION 1\n+\n+#ifdef __GNUG__\n+#pragma GCC system_header\n+#include_next <exception>\n+#else\n+\n+#include <bits/stl_config.h>\n+\n+__STL_BEGIN_NAMESPACE\n+\n+    // 18.6  Exception handling\n+    class exception;\n+    class bad_exception;\n+     \n+    typedef void (*unexpected_handler)();\n+    unexpected_handler set_unexpected(unexpected_handler) throw();\n+    void unexpected();\n+    typedef void (*terminate_handler)();\n+    terminate_handler set_terminate(terminate_handler) throw();\n+    void terminate();\n+    bool uncaught_exception();\n+\n+    // 18.6.1  Class exception \n+    class exception {\n+    public:\n+      exception() throw();\n+      exception(const exception&) throw();\n+      exception& operator=(const exception&) throw();\n+      virtual ~exception() throw();\n+      virtual const char* what() const throw();\n+    };\n+\n+    // 18.6.2.1  Class bad_exception \n+    class bad_exception : public exception {\n+    public:\n+      bad_exception() throw();\n+      bad_exception(const bad_exception&) throw();\n+      bad_exception& operator=(const bad_exception&) throw();\n+      virtual ~bad_exception() throw();\n+      virtual const char* what() const throw();\n+    };\n+\n+__STL_END_NAMESPACE\n+\n+#endif /* __GNUG__ */\n+\n+#endif /* _CPP_EXCEPTION */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}, {"sha": "4cafb2d9ee38150ddf25b53ddaec265bc6e4a1c4", "filename": "libstdc++-v3/include/bits/std_fstream.h", "status": "added", "additions": 420, "deletions": 0, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_fstream.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,420 @@\n+// File based streams -*- C++ -*-\n+\n+// Copyright (C) 1997-1999, 2000 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882: 27.8  File-based streams\n+//\n+\n+#ifndef _CPP_FSTREAM\n+#define _CPP_FSTREAM\t1\n+\n+#include <bits/std_istream.h>\n+#include <bits/std_ostream.h>\n+#include <bits/basic_file.h>\n+#include <bits/std_locale.h>\t// For codecvt\n+#include <bits/c++threads.h>\t// For __mutext_type\n+\n+namespace std {\n+\n+  template<typename _CharT, typename _Traits>\n+    class basic_filebuf : public basic_streambuf<_CharT, _Traits>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT                     \t        char_type;\n+      typedef _Traits                    \t        traits_type;\n+      typedef typename traits_type::int_type \t\tint_type;\n+      typedef typename traits_type::pos_type \t\tpos_type;\n+      typedef typename traits_type::off_type \t\toff_type;\n+      \n+      // Non-standard Types:\n+      typedef basic_streambuf<char_type, traits_type>  \t__streambuf_type;\n+      typedef basic_filebuf<char_type, traits_type>     __filebuf_type;\n+      typedef __basic_file<char_type>\t\t        __file_type;\n+      typedef typename traits_type::state_type          __state_type;\n+      typedef codecvt<char_type, char, __state_type>    __codecvt_type;\n+      typedef typename __codecvt_type::result \t        __res_type;\n+      \n+      friend class ios_base; // For sync_with_stdio.\n+\n+    private:\n+      // Data Members:\n+      // External buffer.\n+      __file_type* \t\t_M_file;\n+\n+      // Current and beginning state type for codecvt.\n+      __state_type\t\t_M_state_cur;\n+      __state_type \t\t_M_state_beg; \t\n+\n+      // Cached value from use_facet.\n+      const __codecvt_type*\t_M_fcvt;       \n+      \n+      // MT lock inherited from libio or other low-level io library.\n+      __c_lock          \t_M_lock;\n+\n+      // XXX Needed? \n+      bool\t\t\t_M_last_overflowed;  \n+  \n+    public:\n+      // Constructors/destructor:\n+      basic_filebuf();\n+\n+      // Non-standard ctor:\n+      basic_filebuf(int __fd, const char* __name, ios_base::openmode __mode);\n+\n+      virtual \n+      ~basic_filebuf() \n+      { \n+\tthis->close();\n+\t_M_fcvt = NULL;\n+\t_M_last_overflowed = false;\n+      }\n+\n+      // Members:\n+      bool \n+      is_open(void) const { return _M_file ? _M_file->is_open() : false; }\n+    \n+      __filebuf_type* \n+      open(const char* __s, ios_base::openmode __mode);\n+    \n+      __filebuf_type* \n+      close(void);\n+\n+    protected:\n+      // Allocate up pback and internal buffers.\n+      void \n+      _M_allocate_buffers();\n+\n+      // Create __file_type object and initialize it properly.\n+      void\n+      _M_filebuf_init();\n+\n+      // Overridden virtual functions:\n+      virtual streamsize \n+      showmanyc(void);\n+   \n+      // Stroustrup, 1998, p. 628 \n+      // underflow() and uflow() functions are called to get the next\n+      // charater from the real input source when the buffer is empty.\n+      // Buffered input uses underflow()\n+      virtual int_type \n+      underflow(void);\n+\n+      virtual int_type \n+      pbackfail(int_type __c = _Traits::eof());\n+\n+      // NB: For what the standard expects of the overflow function,\n+      // see _M_really_overflow(), below. Because basic_streambuf's\n+      // sputc/sputn call overflow directly, and the complications of\n+      // this implementation's setting of the initial pointers all\n+      // equal to _M_buf when initializing, it seems essential to have\n+      // this in actuality be a helper function that checks for the\n+      // eccentricities of this implementation, and then call\n+      // overflow() if indeed the buffer is full.\n+      virtual int_type \n+      overflow(int_type __c = _Traits::eof());\n+\n+      // Stroustrup, 1998, p 648\n+      // The overflow() function is called to transfer characters to the\n+      // real output destination when the buffer is full. A call to\n+      // overflow(c) outputs the contents of the buffer plus the\n+      // character c.\n+      // 27.5.2.4.5 \n+      // Consume some sequence of the characters in the pending sequence.\n+      int_type \n+      _M_really_overflow(int_type __c = _Traits::eof());\n+    \n+      virtual __streambuf_type* \n+      setbuf(char_type* __s, streamsize __n)\n+      {\n+\tif (!this->is_open() && __s == 0 && __n == 0)\n+\t  {\n+\t    _M_buf_size = 0;\n+\t    _M_buf_size_opt = 0;\n+\t  }\n+\t_M_last_overflowed = false;\t\n+\treturn this; \n+      }\n+    \n+      virtual pos_type \n+      seekoff(off_type __off, ios_base::seekdir __way,\n+\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n+\n+      virtual pos_type \n+      seekpos(pos_type __pos,\n+\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n+\n+      virtual int \n+      sync(void)\n+      {\n+\tbool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n+\tif (__testput)\n+\t  {\n+            // Make sure that libio resyncs its idea of the file position\n+            // with the external file.\n+            _M_file->sync();\n+\n+\t    // Need to restore current position. This interpreted as\n+\t    // the position of the external byte sequence (_M_file)\n+\t    // plus the offset in the current internal buffer\n+\t    // (_M_out_beg - _M_out_cur)\n+\t    streamoff __cur = _M_file->seekoff(0, ios_base::cur);\n+\t    off_type __off = _M_out_cur - _M_out_beg;\n+\t    _M_really_overflow();\n+\t    _M_file->seekpos(__cur + __off);\n+\t  }\n+\t_M_last_overflowed = false;\t\n+\treturn 0;\n+      }\n+      \n+      virtual void \n+      imbue(const locale& __loc);\n+\n+      virtual streamsize \n+      xsgetn(char_type* __s, streamsize __n)\n+      {\n+\tstreamsize __ret = 0;\n+\t// Clear out pback buffer before going on to the real deal...\n+\tif (_M_pback_init)\n+\t  {\n+\t    while (__ret < __n && _M_in_cur < _M_in_end)\n+\t      {\n+\t\t*__s = *_M_in_cur;\n+\t\t++__ret;\n+\t\t++__s;\n+\t\t++_M_in_cur;\n+\t      }\n+\t    _M_pback_destroy();\n+\t  }\n+\tif (__ret < __n)\n+\t  __ret += __streambuf_type::xsgetn(__s, __n - __ret);\n+\treturn __ret;\n+      }\n+ \n+      virtual streamsize \n+      xsputn(const char_type* __s, streamsize __n)\n+      {\n+\t_M_pback_destroy();\n+\treturn __streambuf_type::xsputn(__s, __n);\n+      }\n+       \n+      void\n+      _M_output_unshift();\n+    };\n+\n+\n+  // 27.8.1.5  Template class basic_ifstream\n+  template<typename _CharT, typename _Traits>\n+    class basic_ifstream : public basic_istream<_CharT, _Traits>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT \t\t\t\t\tchar_type;\n+      typedef _Traits \t\t\t\t\ttraits_type;\n+      typedef typename traits_type::int_type \t\tint_type;\n+      typedef typename traits_type::pos_type \t\tpos_type;\n+      typedef typename traits_type::off_type \t\toff_type;\n+\n+      // Non-standard types:\n+      typedef basic_filebuf<char_type, traits_type> \t__filebuf_type;\n+      typedef basic_istream<char_type, traits_type>\t__istream_type;\n+    \n+      // Constructors/Destructors:\n+      basic_ifstream()\n+      : __istream_type(new __filebuf_type())\n+      { }\n+\n+      explicit \n+      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)\n+      : __istream_type(new __filebuf_type())\n+      { this->open(__s, __mode); }\n+    \n+      ~basic_ifstream()\n+      { \n+\tdelete _M_streambuf; \n+\t_M_streambuf = NULL;\n+      }\n+\n+      // Members:\n+      __filebuf_type* \n+      rdbuf() const \n+      { return static_cast<__filebuf_type*>(_M_streambuf); }\n+\n+      bool \n+      is_open(void) { return rdbuf()->is_open(); }\n+\n+      void \n+      open(const char* __s, ios_base::openmode __mode = ios_base::in)\n+      { \n+\tif (rdbuf()->open(__s, __mode | ios_base::in) == NULL)\n+\t  this->setstate(ios_base::failbit); \n+      }\n+\n+      void \n+      close(void)\n+      { \n+\tif (!rdbuf()->close())\n+\t  this->setstate(ios_base::failbit);\t\n+      }\n+    };\n+\n+  \n+  // 27.8.1.8  Template class basic_ofstream\n+  template<typename _CharT, typename _Traits>\n+    class basic_ofstream : public basic_ostream<_CharT,_Traits>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT \t\t\t\t\tchar_type;\n+      typedef _Traits \t\t\t\t\ttraits_type;\n+      typedef typename traits_type::int_type \t\tint_type;\n+      typedef typename traits_type::pos_type \t\tpos_type;\n+      typedef typename traits_type::off_type \t\toff_type;\n+\n+      // Non-standard types:\n+      typedef basic_filebuf<char_type, traits_type> \t__filebuf_type;\n+      typedef basic_ostream<char_type, traits_type>\t__ostream_type;\n+      \n+      // Constructors:\n+      basic_ofstream()\n+      : __ostream_type(new __filebuf_type())\n+      { }\n+      \n+      explicit \n+      basic_ofstream(const char* __s, \n+\t\t     ios_base::openmode __mode = ios_base::out|ios_base::trunc)\n+      : __ostream_type(new __filebuf_type())\n+      { this->open(__s, __mode); }\n+\n+      ~basic_ofstream()\n+      { \n+\tdelete _M_streambuf; \n+\t_M_streambuf = NULL;\n+      }\n+\n+      // Members:\n+      __filebuf_type* \n+      rdbuf(void) const\n+      { return static_cast<__filebuf_type*>(_M_streambuf); }\n+ \n+      bool \n+      is_open(void) { return rdbuf()->is_open(); }\n+\n+      void \n+      open(const char* __s, \n+\t   ios_base::openmode __mode = ios_base::out | ios_base::trunc)\n+      { \n+\tif (!rdbuf()->open(__s, __mode | ios_base::out))\n+\t  this->setstate(ios_base::failbit); \n+      }\n+\n+      void \n+      close(void)\n+      { \n+\tif (!rdbuf()->close())\n+\t  setstate(ios_base::failbit); \n+      }\n+    };\n+\n+\n+  // 27.8.1.11  Template class basic_fstream\n+  template<typename _CharT, typename _Traits>\n+    class basic_fstream : public basic_iostream<_CharT, _Traits>\n+    {\n+    public:\n+      // Types:\n+      typedef _CharT \t\t\t\t\tchar_type;\n+      typedef _Traits \t\t\t\t\ttraits_type;\n+      typedef typename traits_type::int_type \t\tint_type;\n+      typedef typename traits_type::pos_type \t\tpos_type;\n+      typedef typename traits_type::off_type \t\toff_type;\n+\n+      // Non-standard types:\n+      typedef basic_filebuf<char_type, traits_type> \t__filebuf_type;\n+      typedef basic_ios<char_type, traits_type>\t\t__ios_type;\n+      typedef basic_iostream<char_type, traits_type>\t__iostream_type;\n+\n+      // Constructors/destructor:\n+      basic_fstream()\n+      : __iostream_type(new __filebuf_type())\n+      { }\n+\n+      explicit \n+      basic_fstream(const char* __s,\n+\t\t    ios_base::openmode __mode = ios_base::in | ios_base::out)\n+      : __iostream_type(new __filebuf_type())\n+      { this->open(__s, __mode); }\n+\n+      ~basic_fstream()\n+      { \n+\tdelete _M_streambuf; \n+\t_M_streambuf = NULL;\n+      }\n+    \n+      // Members:\n+      __filebuf_type* \n+      rdbuf(void) const \n+      { return static_cast<__filebuf_type*>(_M_streambuf); }\n+\n+      bool \n+      is_open(void) { return rdbuf()->is_open(); }\n+\n+      void \n+      open(const char* __s, \n+\t   ios_base::openmode __mode = ios_base::in | ios_base::out)\n+      { \n+\tif (!rdbuf()->open(__s, __mode))\n+\t  setstate (ios_base::failbit); \n+      }\n+\n+      void \n+      close(void)\n+      { \n+\tif (!rdbuf()->close())\n+\t  setstate (ios_base::failbit); \n+      }\n+    };\n+\n+} // namespace std\n+\n+\n+#ifdef _GLIBCPP_NO_TEMPLATE_EXPORT\n+# define export\n+#ifdef  _GLIBCPP_FULLY_COMPLIANT_HEADERS\n+# include <bits/fstream.tcc>\n+#endif\n+#endif\n+\n+#endif\t/* _CPP_FSTREAM */\n+\n+\n+\n+\n+\n+"}, {"sha": "0336c2aedab14e9732aa1f151b6a9f9e169127f8", "filename": "libstdc++-v3/include/bits/std_functional.h", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_functional.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_functional.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_functional.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1", "patch": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ */\n+\n+#ifndef _CPP_FUNCTIONAL\n+#define _CPP_FUNCTIONAL\n+\n+#include <bits/stl_config.h>\n+#include <bits/std_cstddef.h>\n+#include <bits/stl_function.h>\n+\n+#endif /* _CPP_FUNCTIONAL */\n+\n+// Local Variables:\n+// mode:C++\n+// End:\n+"}, {"sha": "6fa49386b6729eb97635018317cdd2acffb46957", "filename": "libstdc++-v3/include/bits/std_iomanip.h", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iomanip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iomanip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iomanip.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "5c61547bff9e76e291dc90b67f1d6b9a3739914f", "filename": "libstdc++-v3/include/bits/std_ios.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_ios.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_ios.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_ios.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "8f198800a0161f549ab1707909468f1fdf4b5464", "filename": "libstdc++-v3/include/bits/std_iosfwd.h", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iosfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iosfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iosfwd.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "b08d038046d3e525cee3cb51839ac8fdfdebce06", "filename": "libstdc++-v3/include/bits/std_iostream.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iostream.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "baddea47f8a2cf7ee4138407dfcd2f9e08d3310b", "filename": "libstdc++-v3/include/bits/std_istream.h", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_istream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_istream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_istream.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "643cff99cb8fa320b99226290fdff1efe5c926d2", "filename": "libstdc++-v3/include/bits/std_iterator.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iterator.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "eaf1258cca6873407507a78e2fe0fc8430db6ec4", "filename": "libstdc++-v3/include/bits/std_list.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_list.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "7eaba90e7eab884139cd67bd74a7d3f2a7b943a0", "filename": "libstdc++-v3/include/bits/std_locale.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_locale.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_locale.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_locale.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "d7fe92d3ee03f9fda2459340559c2eaf9495be2a", "filename": "libstdc++-v3/include/bits/std_map.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_map.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "5ee126bd8e9808b9ee43ca2e3c05c5bcc527e19d", "filename": "libstdc++-v3/include/bits/std_memory.h", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_memory.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "2e019a9562d7a6394ef6b2e3ca882ec8596848c4", "filename": "libstdc++-v3/include/bits/std_new.h", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_new.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_new.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_new.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "8b7c6fd96669b6e6d92257e5a2b892365f600ccb", "filename": "libstdc++-v3/include/bits/std_numeric.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_numeric.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "eb63e93623a116ad19aaf8a6e7e9158df76e94ea", "filename": "libstdc++-v3/include/bits/std_ostream.h", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_ostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_ostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_ostream.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "198b2c03508a2e19e46e94aac82f7a6b834b8107", "filename": "libstdc++-v3/include/bits/std_queue.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_queue.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "7a5f5c5b4ecedeeaef2a1ee7281523de1a72e83b", "filename": "libstdc++-v3/include/bits/std_set.h", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_set.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "f3207110d2d42ce88dfcd6035d46873173893d31", "filename": "libstdc++-v3/include/bits/std_sstream.h", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_sstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_sstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_sstream.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "53e7e21f0ecb1fc16afafc2a0e2aef2a6c8e57f7", "filename": "libstdc++-v3/include/bits/std_stack.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_stack.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "691b9b5825e9ade7311b0c972ba8c7046611cd25", "filename": "libstdc++-v3/include/bits/std_stdexcept.h", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_stdexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_stdexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_stdexcept.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "774046b666625dab7feef9d7cc025cdddbb37185", "filename": "libstdc++-v3/include/bits/std_streambuf.h", "status": "added", "additions": 528, "deletions": 0, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_streambuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_streambuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_streambuf.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "6008eca2862b6a71bcca26a7d2d7b62798211b29", "filename": "libstdc++-v3/include/bits/std_string.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_string.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "2f784b36fcee5ee11e466e6ba838a069fa1855db", "filename": "libstdc++-v3/include/bits/std_strstream.h", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_strstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_strstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_strstream.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "b0590121631dbf99ef1fe7d8a67344b3e599c9de", "filename": "libstdc++-v3/include/bits/std_typeinfo.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_typeinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_typeinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_typeinfo.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "e10dae35b6a87a5bde7fe9180187f8e2104fbd5a", "filename": "libstdc++-v3/include/bits/std_utility.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_utility.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_utility.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_utility.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "fa43c6dca0c0a31a54a77419b0d3f91944b688f6", "filename": "libstdc++-v3/include/bits/std_valarray.h", "status": "added", "additions": 728, "deletions": 0, "changes": 728, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_valarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_valarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_valarray.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "08ac4bd69de37ed2adc4ed9a66ff0ce2c750f527", "filename": "libstdc++-v3/include/bits/std_vector.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_vector.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "c432d3d3ebcd01fa485d14f678f5353ff0dd79c4", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "added", "additions": 3297, "deletions": 0, "changes": 3297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "71889e0853f1dbc41326e131b83e23cf48f1e903", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "added", "additions": 756, "deletions": 0, "changes": 756, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "ca22b90699f6db991984700a6471b71d6c452690", "filename": "libstdc++-v3/include/bits/stl_alloc.h", "status": "added", "additions": 900, "deletions": 0, "changes": 900, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "8a6e15c25de5c129ea9c2cadc0b8e4690c9c9cb7", "filename": "libstdc++-v3/include/bits/stl_config.h", "status": "added", "additions": 568, "deletions": 0, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_config.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "7841f8dc75e73a435b13dc8337a4bcbdb16a3df4", "filename": "libstdc++-v3/include/bits/stl_construct.h", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "0ad596eb3b9793c9a9211ea772fe9902597c97b2", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "added", "additions": 1652, "deletions": 0, "changes": 1652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "fcaafac56685df4b43e43d7f1e1e7c0621248472", "filename": "libstdc++-v3/include/bits/stl_function.h", "status": "added", "additions": 732, "deletions": 0, "changes": 732, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_function.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "3e7eaa456e517443bfd8daf98634fdb4835f3e95", "filename": "libstdc++-v3/include/bits/stl_heap.h", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "ae8b088665373da527df2a15d4b2e5fab2a6b39c", "filename": "libstdc++-v3/include/bits/stl_iterator.h", "status": "added", "additions": 1086, "deletions": 0, "changes": 1086, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "44a6f8fbfb079891a6e8bf76c0aa7455c7556c57", "filename": "libstdc++-v3/include/bits/stl_iterator_base.h", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "1967a7a933d4685afe1ed982e550f28bd0bfb175", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "added", "additions": 885, "deletions": 0, "changes": 885, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "0b7a06d4b8bf84e56966407e35b66ed1c4cf806b", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "1c5401b378aafa09748051b67ac3c7fcb96d2231", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "7e75ec3cd0aafe6237cce916a25010deb56168e1", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "0b1742bc9d9f4be687c7d5ea30b0cb3c37ec81bf", "filename": "libstdc++-v3/include/bits/stl_numeric.h", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "a6155a698e1c7d3a35b7e8f9f6a0de497c8883d0", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "c1488b1ef6a277f307e94994fc9d8725a7c0108e", "filename": "libstdc++-v3/include/bits/stl_pthread_alloc.h", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pthread_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pthread_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pthread_alloc.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "e42666e5662de91a1f7e04f812da0ffcd0508c1e", "filename": "libstdc++-v3/include/bits/stl_queue.h", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "c5ddfe63cbb8f5d9ea4bcaa3c5a855c900757180", "filename": "libstdc++-v3/include/bits/stl_range_errors.h", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_range_errors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_range_errors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_range_errors.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "007acd032edb8f4812ac918a43e2613d8c934abb", "filename": "libstdc++-v3/include/bits/stl_raw_storage_iter.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_raw_storage_iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_raw_storage_iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_raw_storage_iter.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "f0cabdfd54446f68d8fcab327e657bb762e6a9b1", "filename": "libstdc++-v3/include/bits/stl_relops.h", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_relops.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_relops.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_relops.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "435ca38b16e979e5f207f7f45069bdb66898b4af", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "aa80f8730eeb61893e7978f3e6cc18a66efc4279", "filename": "libstdc++-v3/include/bits/stl_stack.h", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "46845b9870c56fd49a8549eec6bc9f77c44980f1", "filename": "libstdc++-v3/include/bits/stl_string_fwd.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_string_fwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_string_fwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_string_fwd.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "cdc0dd27df0e57c8b60f973de9feaf24ebf064ff", "filename": "libstdc++-v3/include/bits/stl_tempbuf.h", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "5f5b451e3d1cc71c0af724d2402e0664ec63345d", "filename": "libstdc++-v3/include/bits/stl_threads.h", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "1c78fd2aa45eb3067d1991b08ab37a51d85ca72a", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "added", "additions": 1370, "deletions": 0, "changes": 1370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "a9b196be347fd207e7fc1207ed5ac09db884f805", "filename": "libstdc++-v3/include/bits/stl_uninitialized.h", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "0727df6fac155393ee085ec0f8b5195f14cd196d", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "added", "additions": 879, "deletions": 0, "changes": 879, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "d03b7bca104ee88ba6d51ce9921d6e37524b67dd", "filename": "libstdc++-v3/include/bits/streambuf.tcc", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf.tcc?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "82a5a7af8ffe3750f20d9f10eb44d4b57aa52783", "filename": "libstdc++-v3/include/bits/string.tcc", "status": "added", "additions": 856, "deletions": 0, "changes": 856, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstring.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstring.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstring.tcc?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "dbcaa2a619fee2e2b7d6cd236cdece36ee9045c1", "filename": "libstdc++-v3/include/bits/type_traits.h", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ftype_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ftype_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ftype_traits.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "2c88877bd28721a849f6e660b25bfba0023508a3", "filename": "libstdc++-v3/include/bits/valarray_array.h", "status": "added", "additions": 575, "deletions": 0, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "ab77f4aca1eb7074179062fc75835cca2a39dca0", "filename": "libstdc++-v3/include/bits/valarray_array.tcc", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_array.tcc?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "e2e65de9c6794ebce7947795813130c677db39e3", "filename": "libstdc++-v3/include/bits/valarray_meta.h", "status": "added", "additions": 1067, "deletions": 0, "changes": 1067, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_meta.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_meta.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvalarray_meta.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "2ece99c7160547eb7b079ab5d57cc5191e3da362", "filename": "libstdc++-v3/include/ext/bvector", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbvector?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "ae3cf2672bc484d699dbf7b182f2dbde0f4d5489", "filename": "libstdc++-v3/include/ext/hash_map", "status": "added", "additions": 524, "deletions": 0, "changes": 524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "24869cd030c8aacb397122b13fa40ec36ca110c1", "filename": "libstdc++-v3/include/ext/hash_set", "status": "added", "additions": 516, "deletions": 0, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "3779defea2be4c49ed9d265be1577c5c2d16d789", "filename": "libstdc++-v3/include/ext/rope", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "cc4d7bc679e445c99c01f42dbb05190c4f4ef0f8", "filename": "libstdc++-v3/include/ext/ropeimpl.h", "status": "added", "additions": 1587, "deletions": 0, "changes": 1587, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "ef0906279a9781f8433f9bab738c9cfff086dc1d", "filename": "libstdc++-v3/include/ext/slist", "status": "added", "additions": 1048, "deletions": 0, "changes": 1048, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "5e64f3889c85eb0ca1f0a5e875d3410bf146b35e", "filename": "libstdc++-v3/include/ext/stl_bvector.h", "status": "added", "additions": 896, "deletions": 0, "changes": 896, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_bvector.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "3144e6a07f181912a307d7eb18d13cd86fd795dc", "filename": "libstdc++-v3/include/ext/stl_hash_fun.h", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hash_fun.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hash_fun.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hash_fun.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "ab5cf5203b1c26ad0471cdea2d1a1710f4b48899", "filename": "libstdc++-v3/include/ext/stl_hashtable.h", "status": "added", "additions": 1054, "deletions": 0, "changes": 1054, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hashtable.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "f317f3a6fbcc77f08769edfa8e25e537e48387f2", "filename": "libstdc++-v3/include/ext/stl_rope.h", "status": "added", "additions": 2714, "deletions": 0, "changes": 2714, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "f6faf976e34fe58d324d1d83cb86962a814722c8", "filename": "libstdc++-v3/include/ext/tree", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Ftree", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fext%2Ftree", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Ftree?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "eebcdf22977cfb892a8e1c602a274313e06bfaf8", "filename": "libstdc++-v3/include/std/algorithm", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Falgorithm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Falgorithm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Falgorithm?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "e334ec964516db9ba8986476b2066e20412839dd", "filename": "libstdc++-v3/include/std/bitset", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbitset?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "bee254d55f17f6ccf96bf86409c021c7f7d2f51a", "filename": "libstdc++-v3/include/std/cassert", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcassert", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcassert", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcassert?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "d888a3f80edd32fe6df5e0371c465bb9f6f1468c", "filename": "libstdc++-v3/include/std/cctype", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcctype?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "5d2cf1f61a497ef689998528046299db70b6f8b1", "filename": "libstdc++-v3/include/std/cerrno", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcerrno", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcerrno", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcerrno?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "c6cb35731a8581a15ce622b3bd583dc75f6faba2", "filename": "libstdc++-v3/include/std/cfloat", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcfloat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcfloat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcfloat?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libstdc++-v3/include/std/ciso646", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fciso646", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fciso646", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fciso646?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "b7614847bbec5a662b47a1998c5ab4a63db013e5", "filename": "libstdc++-v3/include/std/climits", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fclimits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fclimits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fclimits?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "6ac636f87861ed009643860659fff12bb96c95ec", "filename": "libstdc++-v3/include/std/clocale", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fclocale", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fclocale", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fclocale?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "783e76af1c5af73dbefe9ed875d5e28607c2111d", "filename": "libstdc++-v3/include/std/cmath", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcmath?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "2cc52f5531d4a2c89c5eb3018771e99282460c83", "filename": "libstdc++-v3/include/std/complex", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "79531e3607a1daaa315069327619e0dcb8c9a41d", "filename": "libstdc++-v3/include/std/csetjmp", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcsetjmp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcsetjmp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcsetjmp?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "e5c1837a4a50b09185b328a192ec4079d68c2fc4", "filename": "libstdc++-v3/include/std/csignal", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcsignal", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcsignal", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcsignal?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "37b2459f6a5669d565e5f8b2bc7347eab4490727", "filename": "libstdc++-v3/include/std/cstdarg", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcstdarg", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcstdarg", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcstdarg?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "fab421423ba1f9464714845824fbe53eed143da0", "filename": "libstdc++-v3/include/std/cstddef", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcstddef", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcstddef", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcstddef?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "f2a0135e65a4ab674b2eef95b0d9a11930d29b35", "filename": "libstdc++-v3/include/std/cstdio", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcstdio", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcstdio", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcstdio?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "98230261186bcf6585b9244d8a1ee00dc915491a", "filename": "libstdc++-v3/include/std/cstdlib", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcstdlib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcstdlib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcstdlib?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "b6a3bd9b53fc62507d9b0ec4e76e65f401a33a03", "filename": "libstdc++-v3/include/std/cstring", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcstring", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcstring", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcstring?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "838fd4360ef5d8ef03c034395f8875eaeeb223aa", "filename": "libstdc++-v3/include/std/ctime", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fctime", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fctime", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fctime?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "2cfc330637c289e1307baa05cfb2cec47b26ef1b", "filename": "libstdc++-v3/include/std/cwchar", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcwchar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcwchar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcwchar?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "ccd490869015ddd3a9c701269e5321267d5435ad", "filename": "libstdc++-v3/include/std/cwctype", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcwctype", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcwctype", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcwctype?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "2215fd02de14566551ac9d9c99c6ce44ad4fe3dd", "filename": "libstdc++-v3/include/std/deque", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fdeque", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fdeque", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fdeque?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "06653d17e7e8708ebc02a438da316cd6ca44bad2", "filename": "libstdc++-v3/include/std/exception", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fexception", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fexception", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fexception?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "afe99e98da9641236db3549e0955e05ce17bb3ea", "filename": "libstdc++-v3/include/std/fstream", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffstream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffstream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffstream?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "700c211ba2322f74250d9f98fcc0d5dadd255738", "filename": "libstdc++-v3/include/std/functional", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "d3c2aa84177cd2fd77d192128ab9e58e2a1c0b3d", "filename": "libstdc++-v3/include/std/iomanip", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiomanip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiomanip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiomanip?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "7132eadfa33b8aae6871355f17aa2b4acad0682a", "filename": "libstdc++-v3/include/std/ios", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fios", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fios", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fios?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "6a97d3d2d322feef977b970f6b91fe27a2e46087", "filename": "libstdc++-v3/include/std/iosfwd", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiosfwd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiosfwd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiosfwd?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "f94fd058a55a4bfea2566a83dbd42b0831c4b911", "filename": "libstdc++-v3/include/std/iostream", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiostream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiostream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiostream?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "9594261aa61a858ce9671c3a3bbada9e3c53226e", "filename": "libstdc++-v3/include/std/istream", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fistream?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "eb22c69746c91fc04c409038fec719113cc3a1dd", "filename": "libstdc++-v3/include/std/iterator", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiterator", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiterator", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fiterator?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "ba86fe0cba74ac0a855618ec0a7afd57057fab4d", "filename": "libstdc++-v3/include/std/limits", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flimits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flimits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flimits?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "ea1883639faaa35e639013ab8484733db1b8215b", "filename": "libstdc++-v3/include/std/list", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flist?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "5452ae81040e12b8a1386a40f448f05bfb9eff91", "filename": "libstdc++-v3/include/std/locale", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flocale", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flocale", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Flocale?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "16d24f8ee61e1d48428bfe88c4eea5416b8f299c", "filename": "libstdc++-v3/include/std/map", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmap", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmap", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmap?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "f905b4d1d5199de03287faef65e42de471bb1677", "filename": "libstdc++-v3/include/std/memory", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "dac53f8e7fc18a3b85d8581f0fdfffcc73715e61", "filename": "libstdc++-v3/include/std/new", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnew", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnew", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnew?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "b3817a838cba4607bcfdbeb8e8b76ad97d64c002", "filename": "libstdc++-v3/include/std/numeric", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fnumeric?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "beed8c58a3d42b52cd715d64ab354bb4baf73a54", "filename": "libstdc++-v3/include/std/ostream", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fostream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fostream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fostream?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "278270cfdff4017698de3c7e80ba7874fbe7cdc2", "filename": "libstdc++-v3/include/std/queue", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fqueue", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fqueue", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fqueue?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "7aa6a388d411ee1905f638df0b5f545f7d287809", "filename": "libstdc++-v3/include/std/set", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fset?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "92c57cb46bfbdc55c9cd12792bf4172568a337d0", "filename": "libstdc++-v3/include/std/sstream", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsstream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsstream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsstream?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "db3771e7adb1e398b5e9641fa07bdcf59a6cf919", "filename": "libstdc++-v3/include/std/stack", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstack", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstack", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstack?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "da75270e68219f12d786b1e64cb2ce83c054e452", "filename": "libstdc++-v3/include/std/stdexcept", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstdexcept", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstdexcept", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstdexcept?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "0a58fbdd8fff3fe1d105d9e86a0cb8955fa2e84e", "filename": "libstdc++-v3/include/std/streambuf", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstreambuf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstreambuf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstreambuf?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "8e3cd42715e3963ac0c0f0f5aaaf7e468a550dca", "filename": "libstdc++-v3/include/std/string", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstring?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "53267144434a9199a36c4db6527db6bba7fa1635", "filename": "libstdc++-v3/include/std/strstream", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstrstream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstrstream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstrstream?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "26526f33693dc5f7711eaf32d8a7bc25dae26594", "filename": "libstdc++-v3/include/std/typeinfo", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftypeinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftypeinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftypeinfo?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "924a85398cbfa5b2b80422c15802c3232a9485dd", "filename": "libstdc++-v3/include/std/utility", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Futility", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Futility", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Futility?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "e98bbcef168251d14e6d5026ea074b004925d99e", "filename": "libstdc++-v3/include/std/valarray", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvalarray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvalarray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvalarray?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}, {"sha": "c074b77a886dae121a8731cbdcf2c10379a875dc", "filename": "libstdc++-v3/include/std/vector", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/725dc051cada61aca8127f1062ec97a31acf79f1/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvector?ref=725dc051cada61aca8127f1062ec97a31acf79f1"}]}