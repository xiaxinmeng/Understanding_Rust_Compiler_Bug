{"sha": "e6b89e8bf27c932835b54313cc7e3a78bf07d0ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZiODllOGJmMjdjOTMyODM1YjU0MzEzY2M3ZTNhNzhiZjA3ZDBjZQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-12-31T22:44:22Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-12-31T22:44:22Z"}, "message": "(sched_analyze_1, sched_analyze_2): If before reloading,\n\nrecord dependences that may be introduced by reload substituting\nequivalents for pseudo registers.\n\nFrom-SVN: r3036", "tree": {"sha": "03ead9b6eb6f5f1aabd997d26ed33ae234ed1fe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03ead9b6eb6f5f1aabd997d26ed33ae234ed1fe9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6b89e8bf27c932835b54313cc7e3a78bf07d0ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6b89e8bf27c932835b54313cc7e3a78bf07d0ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6b89e8bf27c932835b54313cc7e3a78bf07d0ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6b89e8bf27c932835b54313cc7e3a78bf07d0ce/comments", "author": null, "committer": null, "parents": [{"sha": "b7d9fc385d6d5acf26f8c36d8cab92e44db3b56a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d9fc385d6d5acf26f8c36d8cab92e44db3b56a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7d9fc385d6d5acf26f8c36d8cab92e44db3b56a"}], "stats": {"total": 14, "additions": 14, "deletions": 0}, "files": [{"sha": "7df147ac42b8c111ed2b8044d21a967894c8fe22", "filename": "gcc/sched.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6b89e8bf27c932835b54313cc7e3a78bf07d0ce/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6b89e8bf27c932835b54313cc7e3a78bf07d0ce/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=e6b89e8bf27c932835b54313cc7e3a78bf07d0ce", "patch": "@@ -1610,6 +1610,14 @@ sched_analyze_1 (x, insn)\n \t    add_dependence (insn, reg_last_sets[regno], REG_DEP_OUTPUT);\n \t  reg_last_sets[regno] = insn;\n \n+\t  /* Pseudos that are REG_EQUIV to something may be replaced\n+\t     by that during reloading, so we can potentially read\n+\t     quantities mentioned in those addresses. */\n+\t  if (! reload_completed)\n+\t    if (reg_known_value[regno] != regno_reg_rtx[regno])\n+\t      if (GET_CODE (reg_known_value[regno]) == MEM)\n+\t\tsched_analyze_2 (XEXP (reg_known_value[regno], 0), insn);\n+\n \t  /* Don't let it cross a call after scheduling if it doesn't\n \t     already cross one.  */\n \t  if (reg_n_calls_crossed[regno] == 0 && last_function_call)\n@@ -1762,6 +1770,12 @@ sched_analyze_2 (x, insn)\n \t    if (reg_last_sets[regno])\n \t      add_dependence (insn, reg_last_sets[regno], 0);\n \n+\t    /* Pseudos that are REG_EQUIV to something may be replaced\n+\t       by that, so we depend on anything mentioned there too. */\n+\t    if (! reload_completed)\n+\t      if (reg_known_value[regno] != regno_reg_rtx[regno])\n+\t\tsched_analyze_2 (reg_known_value[regno], insn);\n+\n \t    /* If the register does not already cross any calls, then add this\n \t       insn to the sched_before_next_call list so that it will still\n \t       not cross calls after scheduling.  */"}]}