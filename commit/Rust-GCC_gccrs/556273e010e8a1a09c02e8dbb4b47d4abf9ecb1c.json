{"sha": "556273e010e8a1a09c02e8dbb4b47d4abf9ecb1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU2MjczZTAxMGU4YTFhMDljMDJlOGRiYjRiNDdkNGFiZjllY2IxYw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-06T17:55:22Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-06T17:55:22Z"}, "message": "* tm.texi (FUNCTION_ARG_PARTIAL_NREGS): Fix a typo.\n\nFrom-SVN: r35525", "tree": {"sha": "42d934b822992dceea63578ef7fe1ef63634f1b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42d934b822992dceea63578ef7fe1ef63634f1b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/556273e010e8a1a09c02e8dbb4b47d4abf9ecb1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/556273e010e8a1a09c02e8dbb4b47d4abf9ecb1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/556273e010e8a1a09c02e8dbb4b47d4abf9ecb1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/556273e010e8a1a09c02e8dbb4b47d4abf9ecb1c/comments", "author": null, "committer": null, "parents": [{"sha": "f899e262850ba7e6e8ccddf5a64297a50b54d09b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f899e262850ba7e6e8ccddf5a64297a50b54d09b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f899e262850ba7e6e8ccddf5a64297a50b54d09b"}], "stats": {"total": 399, "additions": 198, "deletions": 201}, "files": [{"sha": "400befdfaff0cb941477f6b4e40ad17d5f5adb97", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/556273e010e8a1a09c02e8dbb4b47d4abf9ecb1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/556273e010e8a1a09c02e8dbb4b47d4abf9ecb1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=556273e010e8a1a09c02e8dbb4b47d4abf9ecb1c", "patch": "@@ -1,5 +1,7 @@\n 2000-08-06  Kazu Hirata  <kazu@hxi.com>\n \n+\t* dwarf2out.c: Fix formatting.\n+\n \t* tm.texi (FUNCTION_ARG_PARTIAL_NREGS): Fix a typo.\n \n \t* expr.c: Fix formatting."}, {"sha": "40b241568a5ad9d47bcf52fa96a53a345a032966", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 196, "deletions": 201, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/556273e010e8a1a09c02e8dbb4b47d4abf9ecb1c/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/556273e010e8a1a09c02e8dbb4b47d4abf9ecb1c/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=556273e010e8a1a09c02e8dbb4b47d4abf9ecb1c", "patch": "@@ -66,7 +66,7 @@ dwarf2out_do_frame ()\n {\n   return (write_symbols == DWARF2_DEBUG\n #ifdef DWARF2_FRAME_INFO\n-          || DWARF2_FRAME_INFO\n+\t  || DWARF2_FRAME_INFO\n #endif\n #ifdef DWARF2_UNWIND_INFO\n \t  || flag_unwind_tables\n@@ -112,11 +112,11 @@ dw_cfi_node;\n /* This is how we define the location of the CFA. We use to handle it\n    as REG + OFFSET all the time,  but now it can be more complex.\n    It can now be either REG + CFA_OFFSET or *(REG + BASE_OFFSET) + CFA_OFFSET.\n-   Instead of passing around REG and OFFSET, we pass a copy \n+   Instead of passing around REG and OFFSET, we pass a copy\n    of this structure.  */\n typedef struct cfa_loc\n {\n-  unsigned long reg;  \n+  unsigned long reg;\n   long offset;\n   long base_offset;\n   int indirect;            /* 1 if CFA is accessed via a dereference.  */\n@@ -212,7 +212,7 @@ static unsigned current_funcdef_number = 0;\n \n /* Some DWARF extensions (e.g., MIPS/SGI) implement a subprogram\n    attribute that accelerates the lookup of the FDE associated\n-   with the subprogram.  This variable holds the table index of the FDE \n+   with the subprogram.  This variable holds the table index of the FDE\n    associated with the current function (body) definition.  */\n static unsigned current_funcdef_fde;\n \n@@ -239,7 +239,7 @@ static void dwarf2out_frame_debug_expr\tPARAMS ((rtx, const char *));\n \n /* Support for complex CFA locations.  */\n static void output_cfa_loc \t\tPARAMS ((dw_cfi_ref));\n-static void get_cfa_from_loc_descr \tPARAMS ((dw_cfa_location *, \n+static void get_cfa_from_loc_descr \tPARAMS ((dw_cfa_location *,\n \t\t\t\t\t        struct dw_loc_descr_struct *));\n static struct dw_loc_descr_struct *build_cfa_loc\n \t\t\t\t\tPARAMS ((dw_cfa_location *));\n@@ -485,7 +485,7 @@ static void def_cfa_1\t\t \tPARAMS ((const char *, dw_cfa_location *));\n \t\t\t\t   gen_rtx_SYMBOL_REF (Pmode, LABEL2)),\t\\\n \t\t    2, 1)\n #endif\n-  \n+\n #ifndef ASM_OUTPUT_DWARF_DELTA4\n #define ASM_OUTPUT_DWARF_DELTA4(FILE,LABEL1,LABEL2)\t\t\t\\\n   assemble_integer (gen_rtx_MINUS (SImode,\t\t\t      \t\\\n@@ -736,7 +736,7 @@ dwarf2out_cfi_label ()\n {\n   static char label[20];\n   static unsigned long label_num = 0;\n-  \n+\n   ASM_GENERATE_INTERNAL_LABEL (label, \"LCFI\", label_num++);\n   ASM_OUTPUT_LABEL (asm_out_file, label);\n \n@@ -913,7 +913,7 @@ def_cfa_1 (label, loc_p)\n     }\n   else\n     {\n-      struct dw_loc_descr_struct * loc_list;\n+      struct dw_loc_descr_struct *loc_list;\n       cfi->dw_cfi_opc = DW_CFA_def_cfa_expression;\n       loc_list = build_cfa_loc (&loc);\n       cfi->dw_cfi_oprnd1.dw_cfi_loc = loc_list;\n@@ -972,7 +972,7 @@ reg_save (label, reg, sreg, offset)\n /* Add the CFI for saving a register window.  LABEL is passed to reg_save.\n    This CFI tells the unwinder that it needs to restore the window registers\n    from the previous frame's window save area.\n-   \n+\n    ??? Perhaps we should note in the CIE where windows are saved (instead of\n    assuming 0(cfa)) and what registers are in the window.  */\n \n@@ -1204,7 +1204,7 @@ static long cfa_temp_value;\n \n /* Record call frame debugging information for an expression, which either\n    sets SP or FP (adjusting how we calculate the frame address) or saves a\n-   register to the stack. */\n+   register to the stack.  */\n \n static void\n dwarf2out_frame_debug_expr (expr, label)\n@@ -1213,30 +1213,30 @@ dwarf2out_frame_debug_expr (expr, label)\n {\n   rtx src, dest;\n   long offset;\n-    \n-  /* If RTX_FRAME_RELATED_P is set on a PARALLEL, process each member of \n-     the PARALLEL independently. The first element is always processed if \n-     it is a SET. This is for backward compatability.   Other elements \n-     are processed only if they are SETs and the RTX_FRAME_RELATED_P \n-     flag is set in them. */\n+\n+  /* If RTX_FRAME_RELATED_P is set on a PARALLEL, process each member of\n+     the PARALLEL independently. The first element is always processed if\n+     it is a SET. This is for backward compatability.   Other elements\n+     are processed only if they are SETs and the RTX_FRAME_RELATED_P\n+     flag is set in them.  */\n \n   if (GET_CODE (expr) == PARALLEL\n       || GET_CODE (expr) == SEQUENCE)\n-    { \n+    {\n       int par_index;\n       int limit = XVECLEN (expr, 0);\n \n       for (par_index = 0; par_index < limit; par_index++)\n-        {\n-          rtx x = XVECEXP (expr, 0, par_index);\n-          \n-          if (GET_CODE (x) == SET &&\n+\t{\n+\t  rtx x = XVECEXP (expr, 0, par_index);\n+\n+\t  if (GET_CODE (x) == SET &&\n \t      (RTX_FRAME_RELATED_P (x) || par_index == 0))\n \t    dwarf2out_frame_debug_expr (x, label);\n-        }\n+\t}\n       return;\n     }\n-  \n+\n   if (GET_CODE (expr) != SET)\n     abort ();\n \n@@ -1249,25 +1249,26 @@ dwarf2out_frame_debug_expr (expr, label)\n       /* Update the CFA rule wrt SP or FP.  Make sure src is\n          relative to the current CFA register.  */\n       switch (GET_CODE (src))\n-        {\n-          /* Setting FP from SP.  */\n-        case REG:\n-          if (cfa.reg == (unsigned) REGNO (src))\n-\t    /* OK */;\n+\t{\n+\t  /* Setting FP from SP.  */\n+\tcase REG:\n+\t  if (cfa.reg == (unsigned) REGNO (src))\n+\t    /* OK.  */\n+\t    ;\n \t  else\n-            abort ();\n+\t    abort ();\n \n \t  /* We used to require that dest be either SP or FP, but the\n \t     ARM copies SP to a temporary register, and from there to\n \t     FP.  So we just rely on the backends to only set\n \t     RTX_FRAME_RELATED_P on appropriate insns.  */\n-          cfa.reg = REGNO (dest);\n-          break;\n+\t  cfa.reg = REGNO (dest);\n+\t  break;\n \n-        case PLUS:\n-        case MINUS:\n-          if (dest == stack_pointer_rtx)\n-            {\n+\tcase PLUS:\n+\tcase MINUS:\n+\t  if (dest == stack_pointer_rtx)\n+\t    {\n \t      /* Adjusting SP.  */\n \t      switch (GET_CODE (XEXP (src, 1)))\n \t\t{\n@@ -1299,9 +1300,9 @@ dwarf2out_frame_debug_expr (expr, label)\n \t\tcfa.offset += offset;\n \t      if (cfa_store.reg == STACK_POINTER_REGNUM)\n \t\tcfa_store.offset += offset;\n-            }\n-          else if (dest == hard_frame_pointer_rtx)\n-            {\n+\t    }\n+\t  else if (dest == hard_frame_pointer_rtx)\n+\t    {\n \t      /* Either setting the FP from an offset of the SP,\n \t\t or adjusting the FP */\n \t      if (! frame_pointer_needed)\n@@ -1317,11 +1318,11 @@ dwarf2out_frame_debug_expr (expr, label)\n \t\t  cfa.offset += offset;\n \t\t  cfa.reg = HARD_FRAME_POINTER_REGNUM;\n \t\t}\n-\t      else \n-\t\tabort();\n-            }\n-          else\n-            {\n+\t      else\n+\t\tabort ();\n+\t    }\n+\t  else\n+\t    {\n \t      if (GET_CODE (src) != PLUS\n \t\t  || XEXP (src, 1) != stack_pointer_rtx)\n \t\tabort ();\n@@ -1332,26 +1333,26 @@ dwarf2out_frame_debug_expr (expr, label)\n \t\tabort ();\n \t      cfa_store.reg = REGNO (dest);\n \t      cfa_store.offset = cfa.offset - cfa_temp_value;\n-            }\n-          break;\n+\t    }\n+\t  break;\n \n-        case CONST_INT:\n-          cfa_temp_reg = REGNO (dest);\n-          cfa_temp_value = INTVAL (src);\n-          break;\n+\tcase CONST_INT:\n+\t  cfa_temp_reg = REGNO (dest);\n+\t  cfa_temp_value = INTVAL (src);\n+\t  break;\n \n-        case IOR:\n-          if (GET_CODE (XEXP (src, 0)) != REG\n+\tcase IOR:\n+\t  if (GET_CODE (XEXP (src, 0)) != REG\n \t      || (unsigned) REGNO (XEXP (src, 0)) != cfa_temp_reg\n \t      || (unsigned) REGNO (dest) != cfa_temp_reg\n \t      || GET_CODE (XEXP (src, 1)) != CONST_INT)\n-            abort ();\n-          cfa_temp_value |= INTVAL (XEXP (src, 1));\n-          break;\n+\t    abort ();\n+\t  cfa_temp_value |= INTVAL (XEXP (src, 1));\n+\t  break;\n \n-        default:\n-          abort ();\n-        }\n+\tdefault:\n+\t  abort ();\n+\t}\n       def_cfa_1 (label, &cfa);\n       break;\n \n@@ -1405,15 +1406,15 @@ dwarf2out_frame_debug_expr (expr, label)\n \t  /* Without an offset.  */\n \tcase REG:\n \t  if (cfa_store.reg != (unsigned) REGNO (XEXP (dest, 0)))\n-\t    abort();\n+\t    abort ();\n \t  offset = -cfa_store.offset;\n \t  break;\n \n \tdefault:\n \t  abort ();\n \t}\n \n-      if (REGNO (src) != STACK_POINTER_REGNUM \n+      if (REGNO (src) != STACK_POINTER_REGNUM\n \t  && REGNO (src) != HARD_FRAME_POINTER_REGNUM\n \t  && (unsigned) REGNO (src) == cfa.reg)\n \t{\n@@ -1456,7 +1457,6 @@ dwarf2out_frame_debug_expr (expr, label)\n     }\n }\n \n-\n /* Record call frame debugging information for INSN, which either\n    sets SP or FP (adjusting how we calculate the frame address) or saves a\n    register to the stack.  If INSN is NULL_RTX, initialize our state.  */\n@@ -1488,11 +1488,11 @@ dwarf2out_frame_debug (insn)\n     }\n \n   label = dwarf2out_cfi_label ();\n-    \n+\n   src = find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX);\n   if (src)\n     insn = XEXP (src, 0);\n-  else \n+  else\n     insn = PATTERN (insn);\n \n   dwarf2out_frame_debug_expr (insn, label);\n@@ -1650,8 +1650,8 @@ output_cfi (cfi, fde)\n       switch (cfi->dw_cfi_opc)\n \t{\n \tcase DW_CFA_set_loc:\n-          ASM_OUTPUT_DWARF_ADDR (asm_out_file, cfi->dw_cfi_oprnd1.dw_cfi_addr);\n-          fputc ('\\n', asm_out_file);\n+\t  ASM_OUTPUT_DWARF_ADDR (asm_out_file, cfi->dw_cfi_oprnd1.dw_cfi_addr);\n+\t  fputc ('\\n', asm_out_file);\n \t  break;\n \tcase DW_CFA_advance_loc1:\n \t  ASM_OUTPUT_DWARF_DELTA1 (asm_out_file,\n@@ -1661,17 +1661,17 @@ output_cfi (cfi, fde)\n \t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n \t  break;\n \tcase DW_CFA_advance_loc2:\n-          ASM_OUTPUT_DWARF_DELTA2 (asm_out_file,\n+\t  ASM_OUTPUT_DWARF_DELTA2 (asm_out_file,\n \t\t\t\t   cfi->dw_cfi_oprnd1.dw_cfi_addr,\n \t\t\t\t   fde->dw_fde_current_label);\n           fputc ('\\n', asm_out_file);\n \t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n \t  break;\n \tcase DW_CFA_advance_loc4:\n-          ASM_OUTPUT_DWARF_DELTA4 (asm_out_file,\n+\t  ASM_OUTPUT_DWARF_DELTA4 (asm_out_file,\n \t\t\t\t   cfi->dw_cfi_oprnd1.dw_cfi_addr,\n \t\t\t\t   fde->dw_fde_current_label);\n-          fputc ('\\n', asm_out_file);\n+\t  fputc ('\\n', asm_out_file);\n \t  fde->dw_fde_current_label = cfi->dw_cfi_oprnd1.dw_cfi_addr;\n \t  break;\n #ifdef MIPS_DEBUGGING_INFO\n@@ -1684,43 +1684,43 @@ output_cfi (cfi, fde)\n \tcase DW_CFA_GNU_negative_offset_extended:\n \tcase DW_CFA_def_cfa:\n \t  output_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n-          fputc ('\\n', asm_out_file);\n+\t  fputc ('\\n', asm_out_file);\n \t  output_uleb128 (cfi->dw_cfi_oprnd2.dw_cfi_offset);\n-          fputc ('\\n', asm_out_file);\n+\t  fputc ('\\n', asm_out_file);\n \t  break;\n \tcase DW_CFA_restore_extended:\n \tcase DW_CFA_undefined:\n \t  output_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n-          fputc ('\\n', asm_out_file);\n+\t  fputc ('\\n', asm_out_file);\n \t  break;\n \tcase DW_CFA_same_value:\n \tcase DW_CFA_def_cfa_register:\n \t  output_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n-          fputc ('\\n', asm_out_file);\n+\t  fputc ('\\n', asm_out_file);\n \t  break;\n \tcase DW_CFA_register:\n \t  output_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_reg_num);\n-          fputc ('\\n', asm_out_file);\n+\t  fputc ('\\n', asm_out_file);\n \t  output_uleb128 (cfi->dw_cfi_oprnd2.dw_cfi_reg_num);\n-          fputc ('\\n', asm_out_file);\n+\t  fputc ('\\n', asm_out_file);\n \t  break;\n \tcase DW_CFA_def_cfa_offset:\n \t  output_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_offset);\n-          fputc ('\\n', asm_out_file);\n+\t  fputc ('\\n', asm_out_file);\n \t  break;\n \tcase DW_CFA_GNU_window_save:\n \t  break;\n \tcase DW_CFA_GNU_args_size:\n \t  output_uleb128 (cfi->dw_cfi_oprnd1.dw_cfi_offset);\n-          fputc ('\\n', asm_out_file);\n+\t  fputc ('\\n', asm_out_file);\n \t  break;\n \tcase DW_CFA_def_cfa_expression:\n \t  output_cfa_loc (cfi);\n \t  break;\n \tdefault:\n \t  break;\n \t}\n-     }\n+    }\n }\n \n /* Output the call frame information used to used to record information\n@@ -1776,7 +1776,7 @@ output_call_frame_info (for_eh)\n   else\n     ASM_OUTPUT_SECTION (asm_out_file, FRAME_SECTION);\n \n-  /* Output the CIE. */\n+  /* Output the CIE.  */\n   ASM_GENERATE_INTERNAL_LABEL (l1, CIE_AFTER_SIZE_LABEL, for_eh);\n   ASM_GENERATE_INTERNAL_LABEL (l2, CIE_END_LABEL, for_eh);\n #ifdef ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL\n@@ -1889,10 +1889,10 @@ output_call_frame_info (for_eh)\n       if (for_eh && fde->nothrow)\n \tcontinue;\n \n-      ASM_GENERATE_INTERNAL_LABEL (l1, FDE_AFTER_SIZE_LABEL, for_eh + i*2);\n-      ASM_GENERATE_INTERNAL_LABEL (l2, FDE_END_LABEL, for_eh + i*2);\n+      ASM_GENERATE_INTERNAL_LABEL (l1, FDE_AFTER_SIZE_LABEL, for_eh + i * 2);\n+      ASM_GENERATE_INTERNAL_LABEL (l2, FDE_END_LABEL, for_eh + i * 2);\n #ifdef ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL\n-      ASM_GENERATE_INTERNAL_LABEL (ld, FDE_LENGTH_LABEL, for_eh + i*2);\n+      ASM_GENERATE_INTERNAL_LABEL (ld, FDE_LENGTH_LABEL, for_eh + i * 2);\n       if (for_eh)\n \tASM_OUTPUT_DWARF_OFFSET4 (asm_out_file, ld);\n       else\n@@ -2059,9 +2059,9 @@ dwarf2out_frame_finish ()\n #else\n   if (write_symbols == DWARF2_DEBUG\n       || flag_unwind_tables || (flag_exceptions && ! exceptions_via_longjmp))\n-    output_call_frame_info (1);  \n+    output_call_frame_info (1);\n #endif\n-}  \n+}\n \f\n /* And now, the subset of the debugging information support code necessary\n    for emitting location expressions.  */\n@@ -2460,7 +2460,6 @@ dwarf_stack_op_name (op)\n     }\n }\n \n-\n /* Return a pointer to a newly allocated location description.  Location\n    descriptions are simple expression terms that can be strung\n    together to form more complicated location (address) descriptions.  */\n@@ -2795,8 +2794,8 @@ output_cfa_loc (cfi)\n   output_loc_sequence (loc);\n }\n \n-/* This function builds a dwarf location descriptor seqeunce from \n-   a dw_cfa_location. */\n+/* This function builds a dwarf location descriptor seqeunce from\n+   a dw_cfa_location.  */\n \n static struct dw_loc_descr_struct *\n build_cfa_loc (cfa)\n@@ -2822,15 +2821,15 @@ build_cfa_loc (cfa)\n   return head;\n }\n \n-/* This function fills in aa dw_cfa_location structure from a \n+/* This function fills in aa dw_cfa_location structure from a\n    dwarf location descriptor sequence.  */\n \n static void\n get_cfa_from_loc_descr (cfa, loc)\n      dw_cfa_location *cfa;\n-     struct dw_loc_descr_struct * loc;\n+     struct dw_loc_descr_struct *loc;\n {\n-  struct dw_loc_descr_struct * ptr;\n+  struct dw_loc_descr_struct *ptr;\n   cfa->offset = 0;\n   cfa->base_offset = 0;\n   cfa->indirect = 0;\n@@ -2840,7 +2839,7 @@ get_cfa_from_loc_descr (cfa, loc)\n     {\n       enum dwarf_location_atom op = ptr->dw_loc_opc;\n       switch (op)\n-        {\n+\t{\n \tcase DW_OP_reg0:\n \tcase DW_OP_reg1:\n \tcase DW_OP_reg2:\n@@ -2921,7 +2920,7 @@ get_cfa_from_loc_descr (cfa, loc)\n \t  cfa->indirect = 1;\n \t  break;\n \tcase DW_OP_plus_uconst:\n-\t  cfa->offset =  ptr->dw_loc_oprnd1.v.val_unsigned;\n+\t  cfa->offset = ptr->dw_loc_oprnd1.v.val_unsigned;\n \t  break;\n \tdefault:\n \t  fatal (\"DW_LOC_OP %s not implememnted yet.\\n\",\n@@ -3009,7 +3008,7 @@ die_node;\n typedef struct pubname_struct\n {\n   dw_die_ref die;\n-  char * name;\n+  char *name;\n }\n pubname_entry;\n \n@@ -3481,7 +3480,7 @@ static void reverse_die_lists\t\tPARAMS ((dw_die_ref));\n #endif\n \n /* Labels we insert at beginning sections we can reference instead of\n-   the section names themselves. */\n+   the section names themselves.  */\n \n #ifndef TEXT_SECTION_LABEL\n #define TEXT_SECTION_LABEL\t \"Ltext\"\n@@ -3496,7 +3495,6 @@ static void reverse_die_lists\t\tPARAMS ((dw_die_ref));\n #define ABBREV_SECTION_LABEL     \"Ldebug_abbrev\"\n #endif\n \n-\n /* Definitions of defaults for formats and names of various special\n    (artificial) labels which may be generated within this file (when the -g\n    options is used and DWARF_DEBUGGING_INFO is in effect.\n@@ -3593,7 +3591,7 @@ type_main_variant (type)\n {\n   type = TYPE_MAIN_VARIANT (type);\n \n-  /* There really should be only one main variant among any group of variants \n+  /* There really should be only one main variant among any group of variants\n      of a given type (and all of the MAIN_VARIANT values for all members of\n      the group should point to that one type) but sometimes the C front-end\n      messes this up for array types, so we work around that bug here.  */\n@@ -4009,7 +4007,7 @@ decl_ultimate_origin (decl)\n   if (DECL_ABSTRACT (decl) && DECL_ABSTRACT_ORIGIN (decl) == decl)\n     return NULL_TREE;\n \n-#ifdef ENABLE_CHECKING \n+#ifdef ENABLE_CHECKING\n   if (DECL_FROM_INLINE (DECL_ORIGIN (decl)))\n     /* Since the DECL_ABSTRACT_ORIGIN for a DECL is supposed to be the\n        most distant ancestor, this should never happen.  */\n@@ -4385,7 +4383,6 @@ add_AT_lbl_offset (die, attr_kind, label)\n   attr->dw_attr_val.val_class = dw_val_class_lbl_offset;\n   attr->dw_attr_val.v.val_lbl_id = xstrdup (label);\n   add_dwarf_attr (die, attr);\n-  \n }\n \n static inline const char *AT_lbl PARAMS ((dw_attr_ref));\n@@ -4409,7 +4406,7 @@ get_AT (die, attr_kind)\n {\n   register dw_attr_ref a;\n   register dw_die_ref spec = NULL;\n-  \n+\n   if (die != NULL)\n     {\n       for (a = die->die_attr; a != NULL; a = a->dw_attr_next)\n@@ -4507,15 +4504,15 @@ is_c_family ()\n \n   return (lang == DW_LANG_C || lang == DW_LANG_C89\n \t  || lang == DW_LANG_C_plus_plus);\n-} \n+}\n \n static inline int\n is_fortran ()\n {\n   register unsigned lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n \n   return (lang == DW_LANG_Fortran77 || lang == DW_LANG_Fortran90);\n-} \n+}\n \n static inline int\n is_java ()\n@@ -4545,7 +4542,7 @@ free_AT (a)\n     }\n \n   free (a);\n-}  \n+}\n \n /* Remove the specified attribute if present.  */\n \n@@ -4599,8 +4596,8 @@ remove_children (die)\n       register dw_attr_ref a;\n \n       child_die = child_die->die_sib;\n-      \n-      for (a = tmp_die->die_attr; a != NULL; )\n+\n+      for (a = tmp_die->die_attr; a != NULL;)\n \t{\n \t  register dw_attr_ref tmp_a = a;\n \n@@ -4813,8 +4810,8 @@ print_die (die, outfile)\n \t  break;\n \tcase dw_val_class_long_long:\n \t  fprintf (outfile, \"constant (%lu,%lu)\",\n-\t\t  a->dw_attr_val.v.val_long_long.hi,\n-\t\t  a->dw_attr_val.v.val_long_long.low);\n+\t\t   a->dw_attr_val.v.val_long_long.hi,\n+\t\t   a->dw_attr_val.v.val_long_long.low);\n \t  break;\n \tcase dw_val_class_float:\n \t  fprintf (outfile, \"floating-point constant\");\n@@ -4994,7 +4991,7 @@ build_abbrev_table (die)\n       if (abbrev_die_table_in_use >= abbrev_die_table_allocated)\n \t{\n \t  n_alloc = abbrev_die_table_allocated + ABBREV_DIE_TABLE_INCREMENT;\n-\t  abbrev_die_table \n+\t  abbrev_die_table\n \t    = (dw_die_ref *) xrealloc (abbrev_die_table,\n \t\t\t\t       sizeof (dw_die_ref) * n_alloc);\n \n@@ -5417,7 +5414,7 @@ output_die (die)\n \t  ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 8);\n \t  if (flag_debug_asm)\n \t    fprintf (asm_out_file, \"\\t%s %s\",\n-\t\t   ASM_COMMENT_START, dwarf_attr_name (a->dw_attr));\n+\t\t     ASM_COMMENT_START, dwarf_attr_name (a->dw_attr));\n \n \t  fputc ('\\n', asm_out_file);\n \t  ASM_OUTPUT_DWARF_CONST_DOUBLE (asm_out_file,\n@@ -5427,7 +5424,7 @@ output_die (die)\n \t  if (flag_debug_asm)\n \t    fprintf (asm_out_file,\n \t\t     \"\\t%s long long constant\", ASM_COMMENT_START);\n-\t  \n+\n \t  fputc ('\\n', asm_out_file);\n \t  break;\n \n@@ -5451,7 +5448,7 @@ output_die (die)\n \n \t\tfputc ('\\n', asm_out_file);\n \t      }\n-\t  break;\n+\t    break;\n \t  }\n \n \tcase dw_val_class_flag:\n@@ -5509,7 +5506,7 @@ output_die (die)\n \n   if (die->die_child != NULL)\n     {\n-      /* Add null byte to terminate sibling list. */\n+      /* Add null byte to terminate sibling list.  */\n       ASM_OUTPUT_DWARF_DATA1 (asm_out_file, 0);\n       if (flag_debug_asm)\n \tfprintf (asm_out_file, \"\\t%s end of children of DIE 0x%lx\",\n@@ -5715,10 +5712,10 @@ output_aranges ()\n          for any pointer size.  */\n       ASM_OUTPUT_DWARF_DATA2 (asm_out_file, 0);\n       for (i = 2; i < DWARF_ARANGES_PAD_SIZE; i += 2)\n-        fprintf (asm_out_file, \",0\");\n+\tfprintf (asm_out_file, \",0\");\n       if (flag_debug_asm)\n-        fprintf (asm_out_file, \"\\t%s Pad to %d byte boundary\",\n-                 ASM_COMMENT_START, 2 * DWARF2_ADDR_SIZE);\n+\tfprintf (asm_out_file, \"\\t%s Pad to %d byte boundary\",\n+\t\t ASM_COMMENT_START, 2 * DWARF2_ADDR_SIZE);\n     }\n \n   fputc ('\\n', asm_out_file);\n@@ -6082,7 +6079,7 @@ output_line_info ()\n   function = 0;\n   current_file = 1;\n   current_line = 1;\n-  for (lt_index = 0; lt_index < separate_line_info_table_in_use; )\n+  for (lt_index = 0; lt_index < separate_line_info_table_in_use;)\n     {\n       register dw_separate_line_info_ref line_info\n \t= &separate_line_info_table[lt_index];\n@@ -6302,7 +6299,7 @@ base_type_die (type)\n     case INTEGER_TYPE:\n       /* Carefully distinguish the C character types, without messing\n          up if the language is not C. Note that we check only for the names\n-         that contain spaces; other names might occur by coincidence in other \n+         that contain spaces; other names might occur by coincidence in other\n          languages.  */\n       if (! (TYPE_PRECISION (type) == CHAR_TYPE_SIZE\n \t     && (type == char_type_node\n@@ -6315,7 +6312,7 @@ base_type_die (type)\n \t    encoding = DW_ATE_signed;\n \t  break;\n \t}\n-      /* else fall through */\n+      /* else fall through.  */\n \n     case CHAR_TYPE:\n       /* GNU Pascal/Ada CHAR type.  Not used in C.  */\n@@ -6452,7 +6449,7 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n       if (mod_type_die)\n \treturn mod_type_die;\n \n-      /* Handle C typedef types. */\n+      /* Handle C typedef types.  */\n       if (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t  && DECL_ORIGINAL_TYPE (TYPE_NAME (type)))\n \t{\n@@ -6476,7 +6473,8 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \t}\n \n       if (mod_type_die)\n-\t/* OK */;\n+\t/* OK.  */\n+\t;\n       else if (is_const_type)\n \t{\n \t  mod_type_die = new_die (DW_TAG_const_type, comp_unit_die);\n@@ -6502,7 +6500,7 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \t  add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);\n #if 0\n \t  add_AT_unsigned (mod_type_die, DW_AT_address_class, 0);\n-#endif \n+#endif\n \t  item_type = TREE_TYPE (type);\n \t}\n       else if (is_base_type (type))\n@@ -6640,7 +6638,7 @@ mem_loc_descriptor (rtl, mode)\n      enum machine_mode mode;\n {\n   dw_loc_descr_ref mem_loc_result = NULL;\n-  /* Note that for a dynamically sized array, the location we will generate a \n+  /* Note that for a dynamically sized array, the location we will generate a\n      description of here will be the lowest numbered location which is\n      actually within the array.  That's *not* necessarily the same as the\n      zeroth element of the array.  */\n@@ -6656,7 +6654,7 @@ mem_loc_descriptor (rtl, mode)\n       /* POST_INC and POST_DEC can be handled just like a SUBREG.  So we\n \t just fall into the SUBREG code.  */\n \n-      /* ... fall through ... */\n+      /* Fall through.  */\n \n     case SUBREG:\n       /* The case of a subreg may arise when we have a local (register)\n@@ -6666,12 +6664,12 @@ mem_loc_descriptor (rtl, mode)\n          contains the given subreg.  */\n       rtl = XEXP (rtl, 0);\n \n-      /* ... fall through ... */\n+      /* Fall through.  */\n \n     case REG:\n       /* Whenever a register number forms a part of the description of the\n          method for calculating the (dynamic) address of a memory resident\n-         object, DWARF rules require the register number be referred to as \n+         object, DWARF rules require the register number be referred to as\n          a \"base register\".  This distinction is not based in any way upon\n          what category of register the hardware believes the given register\n          belongs to.  This is strictly DWARF terminology we're dealing with\n@@ -6707,10 +6705,10 @@ mem_loc_descriptor (rtl, mode)\n \t below.  */\n       rtl = gen_rtx_PLUS (word_mode, XEXP (rtl, 0),\n \t\t\t  GEN_INT (GET_CODE (rtl) == PRE_INC\n-\t\t\t\t   ? GET_MODE_UNIT_SIZE (mode) \n-\t\t\t\t   : - GET_MODE_UNIT_SIZE (mode)));\n-\t\t\t  \n-      /* ... fall through ... */\n+\t\t\t\t   ? GET_MODE_UNIT_SIZE (mode)\n+\t\t\t\t   : -GET_MODE_UNIT_SIZE (mode)));\n+\n+      /* Fall through.  */\n \n     case PLUS:\n       if (is_based_loc (rtl))\n@@ -6790,7 +6788,7 @@ loc_descriptor (rtl)\n          contains the given subreg.  */\n       rtl = XEXP (rtl, 0);\n \n-      /* ... fall through ... */\n+      /* Fall through.  */\n \n     case REG:\n       loc_result = reg_loc_descriptor (rtl);\n@@ -6919,7 +6917,7 @@ field_byte_offset (decl)\n       abort ();\n     }\n \n-  /* We cannot yet cope with fields whose positions are variable, so \n+  /* We cannot yet cope with fields whose positions are variable, so\n      for now, when we see such things, we simply return 0.  Someday, we may\n      be able to handle such cases, but it will be damn difficult.  */\n   if (! host_integerp (bit_position (decl), 0))\n@@ -6941,7 +6939,7 @@ field_byte_offset (decl)\n      the starting bit offset (relative to the start of the containing\n      structure type) of the hypothetical \"containing object\" for a bit-\n      field.  Thus, when computing the byte offset value for the start of the\n-     \"containing object\" of a bit-field, we must deduce this information on \n+     \"containing object\" of a bit-field, we must deduce this information on\n      our own. This can be rather tricky to do in some cases.  For example,\n      handling the following structure type definition when compiling for an\n      i386/i486 target (which only aligns long long's to 32-bit boundaries)\n@@ -6951,7 +6949,7 @@ field_byte_offset (decl)\n \n      Fortunately, there is a simple rule-of-thumb which can be\n      used in such cases.  When compiling for an i386/i486, GCC will allocate\n-     8 bytes for the structure shown above.  It decides to do this based upon \n+     8 bytes for the structure shown above.  It decides to do this based upon\n      one simple rule for bit-field allocation.  Quite simply, GCC allocates\n      each \"containing object\" for each bit-field at the first (i.e. lowest\n      addressed) legitimate alignment boundary (based upon the required\n@@ -6969,10 +6967,10 @@ field_byte_offset (decl)\n      (As it turns out, for the example above, the compiler finds that it is\n      OK to allocate the \"containing object\" 64-bit field at bit-offset zero\n      within the structure type.) Here we attempt to work backwards from the\n-     limited set of facts we're given, and we try to deduce from those facts, \n+     limited set of facts we're given, and we try to deduce from those facts,\n      where GCC must have believed that the containing object started (within\n-     the structure type). The value we deduce is then used (by the callers of \n-     this routine) to generate DW_AT_location and DW_AT_bit_offset attributes \n+     the structure type). The value we deduce is then used (by the callers of\n+     this routine) to generate DW_AT_location and DW_AT_bit_offset attributes\n      for fields (both bit-fields and, in the case of DW_AT_location, regular\n      fields as well).  */\n \n@@ -7015,13 +7013,13 @@ add_AT_location_description (die, attr_kind, rtl)\n      of existence will have a DECL_RTL value which denotes a pseudo-reg.\n      Currently, in some rare cases, variables can have DECL_RTL values which\n      look like (MEM (REG pseudo-reg#)).  These cases are due to bugs\n-     elsewhere in the compiler.  We treat such cases as if the variable(s) in \n+     elsewhere in the compiler.  We treat such cases as if the variable(s) in\n      question had been optimized out of existence.  */\n \n   if (is_pseudo_reg (rtl)\n       || (GET_CODE (rtl) == MEM\n \t  && is_pseudo_reg (XEXP (rtl, 0)))\n-      /* This can happen for a PARM_DECL with a DECL_INCOMING_RTL which \n+      /* This can happen for a PARM_DECL with a DECL_INCOMING_RTL which\n \t references the internal argument pointer (a pseudo) in a function\n \t where all references to the internal argument pointer were\n \t eliminated via the optimizers.  */\n@@ -7166,10 +7164,10 @@ add_const_value_attribute (die, rtl)\n          variable (for the inlining) which acts as a stand-in for the\n          corresponding formal parameter (of the inline function) will look\n          like (plus:SI (reg:SI FRAME_PTR) (const_int ...)).  This is not\n-         exactly a compile-time constant expression, but it isn't the address \n-         of the (artificial) local variable either.  Rather, it represents the \n+         exactly a compile-time constant expression, but it isn't the address\n+         of the (artificial) local variable either.  Rather, it represents the\n          *value* which the artificial local variable always has during its\n-         lifetime.  We currently have no way to represent such quasi-constant \n+         lifetime.  We currently have no way to represent such quasi-constant\n          values in Dwarf, so for now we just punt and generate nothing.  */\n       break;\n \n@@ -7210,9 +7208,9 @@ add_location_or_const_value_attribute (die, decl)\n      (as far as the debugger is concerned).  We only have a couple of\n      choices.  GCC provides us with DECL_RTL and with DECL_INCOMING_RTL.\n \n-     DECL_RTL normally indicates where the parameter lives during most of the \n+     DECL_RTL normally indicates where the parameter lives during most of the\n      activation of the function.  If optimization is enabled however, this\n-     could be either NULL or else a pseudo-reg.  Both of those cases indicate \n+     could be either NULL or else a pseudo-reg.  Both of those cases indicate\n      that the parameter doesn't really live anywhere (as far as the code\n      generation parts of GCC are concerned) during most of the function's\n      activation.  That will happen (for example) if the parameter is never\n@@ -7300,7 +7298,7 @@ add_location_or_const_value_attribute (die, decl)\n \t\t   && TREE_CODE (declared_type) == INTEGER_TYPE\n \t\t   && (GET_MODE_SIZE (TYPE_MODE (declared_type))\n \t\t       <= GET_MODE_SIZE (TYPE_MODE (passed_type))))\n-\t\trtl = DECL_INCOMING_RTL (decl);\n+\t    rtl = DECL_INCOMING_RTL (decl);\n \t}\n \n       /* If the parm was passed in registers, but lives on the stack, then\n@@ -7429,7 +7427,7 @@ add_bound_info (subrange_die, bound_attr, bound)\n     case NON_LVALUE_EXPR:\n       add_bound_info (subrange_die, bound_attr, TREE_OPERAND (bound, 0));\n       break;\n-      \n+\n     case SAVE_EXPR:\n       /* If optimization is turned on, the SAVE_EXPRs that describe how to\n          access the upper bound values may be bogus.  If they refer to a\n@@ -7506,13 +7504,13 @@ add_subscript_info (type_die, type)\n   register tree lower, upper;\n   register dw_die_ref subrange_die;\n \n-  /* The GNU compilers represent multidimensional array types as sequences of \n+  /* The GNU compilers represent multidimensional array types as sequences of\n      one dimensional array types whose element types are themselves array\n      types.  Here we squish that down, so that each multidimensional array\n-     type gets only one array_type DIE in the Dwarf debugging info. The draft \n+     type gets only one array_type DIE in the Dwarf debugging info. The draft\n      Dwarf specification say that we are allowed to do this kind of\n      compression in C (because there is no difference between an array or\n-     arrays and a multidimensional array in C) but for other source languages \n+     arrays and a multidimensional array in C) but for other source languages\n      (e.g. Ada) we probably shouldn't do this.  */\n \n   /* ??? The SGI dwarf reader fails for multidimensional arrays with a\n@@ -7528,7 +7526,7 @@ add_subscript_info (type_die, type)\n       register tree domain = TYPE_DOMAIN (type);\n \n       /* Arrays come in three flavors: Unspecified bounds, fixed bounds,\n-\t and (in GNU C only) variable bounds.  Handle all three forms \n+\t and (in GNU C only) variable bounds.  Handle all three forms\n          here.  */\n       subrange_die = new_die (DW_TAG_subrange_type, type_die);\n       if (domain)\n@@ -7547,7 +7545,7 @@ add_subscript_info (type_die, type)\n \t\t  && TYPE_NAME (domain) == NULL_TREE\n \t\t  && TREE_CODE (TREE_TYPE (domain)) == INTEGER_TYPE\n \t\t  && TYPE_NAME (TREE_TYPE (domain)) == NULL_TREE)\n-\t\t;\t\n+\t\t;\n \t      else\n \t\tadd_type_attribute (subrange_die, TREE_TYPE (domain), 0, 0,\n \t\t\t\t    type_die);\n@@ -7568,8 +7566,7 @@ add_subscript_info (type_die, type)\n \t/* We have an array type with an unspecified length.  The DWARF-2\n \t     spec does not say how to handle this; let's just leave out the\n \t     bounds.  */\n-\t{;}\n-      \n+\t;\n \n #ifndef MIPS_DEBUGGING_INFO\n     }\n@@ -7657,8 +7654,8 @@ add_bit_offset_attribute (die, decl)\n   bitpos_int = int_bit_position (decl);\n \n   /* Note that the bit offset is always the distance (in bits) from the\n-     highest-order bit of the \"containing object\" to the highest-order bit of \n-     the bit-field itself.  Since the \"high-order end\" of any object or field \n+     highest-order bit of the \"containing object\" to the highest-order bit of\n+     the bit-field itself.  Since the \"high-order end\" of any object or field\n      is different on big-endian and little-endian machines, the computation\n      below must take account of these differences.  */\n   highest_order_object_bit_offset = object_offset_in_bytes * BITS_PER_UNIT;\n@@ -7708,7 +7705,6 @@ add_prototyped_attribute (die, func_type)\n     add_AT_flag (die, DW_AT_prototyped, 1);\n }\n \n-\n /* Add an 'abstract_origin' attribute below a given DIE.  The DIE is found\n    by looking in either the type declaration or object declaration\n    equate table.  */\n@@ -7743,7 +7739,7 @@ add_abstract_origin_attribute (die, origin)\n \n   if (origin_die == NULL)\n     abort ();\n-  \n+\n   add_AT_die_ref (die, DW_AT_abstract_origin, origin_die);\n }\n \n@@ -7794,7 +7790,7 @@ add_name_and_src_coords_attributes (die, decl)\n {\n   register tree decl_name;\n \n-  decl_name = DECL_NAME (decl); \n+  decl_name = DECL_NAME (decl);\n   if (decl_name != NULL && IDENTIFIER_POINTER (decl_name) != NULL)\n     {\n       add_name_attribute (die, dwarf2_name (decl, 0));\n@@ -7809,7 +7805,7 @@ add_name_and_src_coords_attributes (die, decl)\n     }\n }\n \n-/* Push a new declaration scope. */\n+/* Push a new declaration scope.  */\n \n static void\n push_decl_scope (scope)\n@@ -7845,8 +7841,8 @@ pop_decl_scope ()\n \n static dw_die_ref\n scope_die_for (t, context_die)\n-    register tree t; \n-    register dw_die_ref context_die;\n+     register tree t;\n+     register dw_die_ref context_die;\n {\n   register dw_die_ref scope_die = NULL;\n   register tree containing_scope;\n@@ -7982,7 +7978,7 @@ type_tag (type)\n       if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n \tt = TYPE_NAME (type);\n \n-      /* The g++ front end makes the TYPE_NAME of *each* tagged type point to \n+      /* The g++ front end makes the TYPE_NAME of *each* tagged type point to\n          a TYPE_DECL node, regardless of whether or not a `typedef' was\n          involved.  */\n       else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n@@ -8269,7 +8265,6 @@ gen_enumeration_type_die (type, context_die)\n     add_AT_flag (type_die, DW_AT_declaration, 1);\n }\n \n-\n /* Generate a DIE to represent either a real live formal parameter decl or to\n    represent just the type of some formal parameter position in some function\n    type.\n@@ -8357,20 +8352,20 @@ gen_formal_types_die (function_or_method_type, context_die)\n      non-static member function type, skip over the first thing on the\n      TYPE_ARG_TYPES list because it only represents the type of the hidden\n      `this pointer'.  The debugger should be able to figure out (without\n-     being explicitly told) that this non-static member function type takes a \n-     `this pointer' and should be able to figure what the type of that hidden \n+     being explicitly told) that this non-static member function type takes a\n+     `this pointer' and should be able to figure what the type of that hidden\n      parameter is from the DW_AT_member attribute of the parent\n      DW_TAG_subroutine_type DIE.  */\n   if (TREE_CODE (function_or_method_type) == METHOD_TYPE)\n     first_parm_type = TREE_CHAIN (first_parm_type);\n #endif\n \n-  /* Make our first pass over the list of formal parameter types and output a \n+  /* Make our first pass over the list of formal parameter types and output a\n      DW_TAG_formal_parameter DIE for each one.  */\n   for (link = first_parm_type; link; link = TREE_CHAIN (link))\n     {\n       register dw_die_ref parm_die;\n-      \n+\n       formal_type = TREE_VALUE (link);\n       if (formal_type == void_type_node)\n \tbreak;\n@@ -8387,7 +8382,7 @@ gen_formal_types_die (function_or_method_type, context_die)\n   if (formal_type != void_type_node)\n     gen_unspecified_parameters_die (function_or_method_type, context_die);\n \n-  /* Make our second (and final) pass over the list of formal parameter types \n+  /* Make our second (and final) pass over the list of formal parameter types\n      and output DIEs to represent those types (as necessary).  */\n   for (link = TYPE_ARG_TYPES (function_or_method_type);\n        link;\n@@ -8542,7 +8537,7 @@ gen_subprogram_die (decl, context_die)\n \t  && (DECL_ARTIFICIAL (decl)\n \t      || (get_AT_unsigned (old_die, DW_AT_decl_file) == file_index\n \t\t  && (get_AT_unsigned (old_die, DW_AT_decl_line)\n-\t\t      == (unsigned)DECL_SOURCE_LINE (decl)))))\n+\t\t      == (unsigned) DECL_SOURCE_LINE (decl)))))\n \t{\n \t  subr_die = old_die;\n \n@@ -8557,15 +8552,15 @@ gen_subprogram_die (decl, context_die)\n \t  if (get_AT_unsigned (old_die, DW_AT_decl_file) != file_index)\n \t    add_AT_unsigned (subr_die, DW_AT_decl_file, file_index);\n \t  if (get_AT_unsigned (old_die, DW_AT_decl_line)\n-\t      != (unsigned)DECL_SOURCE_LINE (decl))\n+\t      != (unsigned) DECL_SOURCE_LINE (decl))\n \t    add_AT_unsigned\n \t      (subr_die, DW_AT_decl_line, DECL_SOURCE_LINE (decl));\n \t}\n     }\n   else\n     {\n       subr_die = new_die (DW_TAG_subprogram, context_die);\n-\t\t\t \n+\n       if (TREE_PUBLIC (decl))\n \tadd_AT_flag (subr_die, DW_AT_external, 1);\n \n@@ -8655,17 +8650,17 @@ gen_subprogram_die (decl, context_die)\n     }\n \n   /* Now output descriptions of the arguments for this function. This gets\n-     (unnecessarily?) complex because of the fact that the DECL_ARGUMENT list \n+     (unnecessarily?) complex because of the fact that the DECL_ARGUMENT list\n      for a FUNCTION_DECL doesn't indicate cases where there was a trailing\n      `...' at the end of the formal parameter list.  In order to find out if\n      there was a trailing ellipsis or not, we must instead look at the type\n      associated with the FUNCTION_DECL.  This will be a node of type\n      FUNCTION_TYPE. If the chain of type nodes hanging off of this\n-     FUNCTION_TYPE node ends with a void_type_node then there should *not* be \n+     FUNCTION_TYPE node ends with a void_type_node then there should *not* be\n      an ellipsis at the end.  */\n \n   /* In the case where we are describing a mere function declaration, all we\n-     need to do here (and all we *can* do here) is to describe the *types* of \n+     need to do here (and all we *can* do here) is to describe the *types* of\n      its formal parameters.  */\n   if (debug_info_level <= DINFO_LEVEL_TERSE)\n     ;\n@@ -8691,7 +8686,7 @@ gen_subprogram_die (decl, context_die)\n \t  }\n \n       /* Decide whether we need a unspecified_parameters DIE at the end.\n-         There are 2 more cases to do this for: 1) the ansi ... declaration - \n+         There are 2 more cases to do this for: 1) the ansi ... declaration -\n          this is detectable when the end of the arg list is not a\n          void_type_node 2) an unprototyped function declaration (not a\n          definition).  This just means that we have no info about the\n@@ -8779,7 +8774,7 @@ gen_variable_die (decl, context_die)\n \t    add_AT_unsigned (var_die, DW_AT_decl_file, file_index);\n \n \t  if (get_AT_unsigned (old_die, DW_AT_decl_line)\n-\t      != (unsigned)DECL_SOURCE_LINE (decl))\n+\t      != (unsigned) DECL_SOURCE_LINE (decl))\n \n \t    add_AT_unsigned (var_die, DW_AT_decl_line,\n \t\t\t     DECL_SOURCE_LINE (decl));\n@@ -8807,7 +8802,7 @@ gen_variable_die (decl, context_die)\n \n   if (declaration)\n     add_AT_flag (var_die, DW_AT_declaration, 1);\n-  \n+\n   if (class_scope_p (context_die) || DECL_ABSTRACT (decl))\n     equate_decl_number_to_die (decl, var_die);\n \n@@ -8849,8 +8844,8 @@ gen_label_die (decl, context_die)\n \t  || ((GET_CODE (insn) == NOTE\n \t       && NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED_LABEL)))\n \t{\n-\t  /* When optimization is enabled (via -O) some parts of the compiler \n-\t     (e.g. jump.c and cse.c) may try to delete CODE_LABEL insns which \n+\t  /* When optimization is enabled (via -O) some parts of the compiler\n+\t     (e.g. jump.c and cse.c) may try to delete CODE_LABEL insns which\n \t     represent source-level labels which were explicitly declared by\n \t     the user.  This really shouldn't be happening though, so catch\n \t     it if it ever does happen.  */\n@@ -9070,7 +9065,7 @@ gen_string_type_die (type, context_die)\n   equate_type_number_to_die (type, type_die);\n \n   /* Fudge the string length attribute for now.  */\n-  \n+\n   /* TODO: add string length info.\n    string_length_attribute (TYPE_MAX_VALUE (TYPE_DOMAIN (type)));\n \t\t\t      bound_representation (upper_bound, 0, 'u'); */\n@@ -9110,12 +9105,12 @@ gen_member_die (type, context_die)\n      members. Note that as we output the DIEs necessary to represent the\n      members of this record or union type, we will also be trying to output\n      DIEs to represent the *types* of those members. However the `type'\n-     function (above) will specifically avoid generating type DIEs for member \n-     types *within* the list of member DIEs for this (containing) type execpt \n+     function (above) will specifically avoid generating type DIEs for member\n+     types *within* the list of member DIEs for this (containing) type execpt\n      for those types (of members) which are explicitly marked as also being\n      members of this (containing) type themselves.  The g++ front- end can\n      force any given type to be treated as a member of some other\n-     (containing) type by setting the TYPE_CONTEXT of the given (member) type \n+     (containing) type by setting the TYPE_CONTEXT of the given (member) type\n      to point to the TREE node representing the appropriate (containing)\n      type.  */\n \n@@ -9201,7 +9196,7 @@ gen_struct_or_union_type_die (type, context_die)\n      then give a list of members.  */\n   if (complete)\n     {\n-      /* Prevent infinite recursion in cases where the type of some member of \n+      /* Prevent infinite recursion in cases where the type of some member of\n          this type is expressed in terms of this type itself.  */\n       TREE_ASM_WRITTEN (type) = 1;\n       add_byte_size_attribute (type_die, type);\n@@ -9317,7 +9312,7 @@ gen_type_die (type, context_die)\n \n   if (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n       && DECL_ORIGINAL_TYPE (TYPE_NAME (type)))\n-    { \n+    {\n       TREE_ASM_WRITTEN (type) = 1;\n       gen_decl_die (TYPE_NAME (type), context_die);\n       return;\n@@ -9343,7 +9338,7 @@ gen_type_die (type, context_die)\n       break;\n \n     case OFFSET_TYPE:\n-      /* This code is used for C++ pointer-to-data-member types. \n+      /* This code is used for C++ pointer-to-data-member types.\n \t Output a description of the relevant class type.  */\n       gen_type_die (TYPE_OFFSET_BASETYPE (type), context_die);\n \n@@ -9471,7 +9466,7 @@ gen_tagged_type_instantiation_die (type, context_die)\n \n   /* Do not check TREE_ASM_WRITTEN (type) as it may not be set if this is\n      an instance of an unresolved type.  */\n-  \n+\n   switch (TREE_CODE (type))\n     {\n     case ERROR_MARK:\n@@ -9532,7 +9527,7 @@ gen_block_die (stmt, context_die, depth)\n   else\n     {\n       /* In the case where the current block represents an inlining of the\n-         \"body block\" of an inline function, we must *NOT* output any DIE for \n+         \"body block\" of an inline function, we must *NOT* output any DIE for\n          this block because we have already output a DIE to represent the\n          whole inlined function scope and the \"body block\" of any function\n          doesn't really represent a different scope according to ANSI C\n@@ -9664,7 +9659,7 @@ gen_decl_die (decl, context_die)\n   switch (TREE_CODE (decl))\n     {\n     case CONST_DECL:\n-      /* The individual enumerators of an enum type get output when we output \n+      /* The individual enumerators of an enum type get output when we output\n          the Dwarf representation of the relevant enum type itself.  */\n       break;\n \n@@ -9714,12 +9709,12 @@ gen_decl_die (decl, context_die)\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n \tbreak;\n \n-      /* In the special case of a TYPE_DECL node representing the \n+      /* In the special case of a TYPE_DECL node representing the\n          declaration of some type tag, if the given TYPE_DECL is marked as\n          having been instantiated from some other (original) TYPE_DECL node\n          (e.g. one which was generated within the original definition of an\n          inline function) we have to generate a special (abbreviated)\n-         DW_TAG_structure_type, DW_TAG_union_type, or DW_TAG_enumeration_type \n+         DW_TAG_structure_type, DW_TAG_union_type, or DW_TAG_enumeration_type\n          DIE here.  */\n       if (TYPE_DECL_IS_STUB (decl) && decl_ultimate_origin (decl) != NULL_TREE)\n \t{\n@@ -9802,7 +9797,7 @@ dwarf2out_add_library_unit_info (filename, context_list)\n   if (filename != NULL)\n     {\n       dw_die_ref unit_die = new_die (DW_TAG_module, comp_unit_die);\n-      tree context_list_decl \n+      tree context_list_decl\n \t= build_decl (LABEL_DECL, get_identifier (context_list),\n \t\t      void_type_node);\n \n@@ -9832,7 +9827,7 @@ dwarf2out_decl (decl)\n   switch (TREE_CODE (decl))\n     {\n     case FUNCTION_DECL:\n-      /* Ignore this FUNCTION_DECL if it refers to a builtin declaration of a \n+      /* Ignore this FUNCTION_DECL if it refers to a builtin declaration of a\n          builtin function.  Explicit programmer-supplied declarations of\n          these same functions should NOT be ignored however.  */\n       if (DECL_EXTERNAL (decl) && DECL_BUILT_IN (decl))\n@@ -9841,12 +9836,12 @@ dwarf2out_decl (decl)\n       /* What we would really like to do here is to filter out all mere\n          file-scope declarations of file-scope functions which are never\n          referenced later within this translation unit (and keep all of ones\n-         that *are* referenced later on) but we aren't clairvoyant, so we have \n-         no idea which functions will be referenced in the future (i.e. later \n+         that *are* referenced later on) but we aren't clairvoyant, so we have\n+         no idea which functions will be referenced in the future (i.e. later\n          on within the current translation unit). So here we just ignore all\n-         file-scope function declarations which are not also definitions.  If \n+         file-scope function declarations which are not also definitions.  If\n          and when the debugger needs to know something about these functions,\n-         it will have to hunt around and find the DWARF information associated \n+         it will have to hunt around and find the DWARF information associated\n          with the definition of the function.  Note that we can't just check\n          `DECL_EXTERNAL' to find out which FUNCTION_DECL nodes represent\n          definitions and which ones represent mere declarations.  We have to\n@@ -9855,13 +9850,13 @@ dwarf2out_decl (decl)\n          definitions.  These can get inlined within the current translation\n          unit (an thus, we need to generate DWARF info for their abstract\n          instances so that the DWARF info for the concrete inlined instances\n-         can have something to refer to) but the compiler never generates any \n+         can have something to refer to) but the compiler never generates any\n          out-of-lines instances of such things (despite the fact that they\n          *are* definitions).  The important point is that the C front-end\n          marks these \"extern inline\" functions as DECL_EXTERNAL, but we need\n          to generate DWARF for them anyway. Note that the C++ front-end also\n          plays some similar games for inline function definitions appearing\n-         within include files which also contain \n+         within include files which also contain\n \t `#pragma interface' pragmas.  */\n       if (DECL_INITIAL (decl) == NULL_TREE)\n \treturn;\n@@ -9875,7 +9870,7 @@ dwarf2out_decl (decl)\n       break;\n \n     case VAR_DECL:\n-      /* Ignore this VAR_DECL if it refers to a file-scope extern data object \n+      /* Ignore this VAR_DECL if it refers to a file-scope extern data object\n          declaration and if the declaration was never even referenced from\n          within this entire compilation unit.  We suppress these DIEs in\n          order to save space in the .debug section (by eliminating entries\n@@ -10020,7 +10015,7 @@ lookup_filename (file_name)\n \treturn i;\n       }\n \n-  /* Prepare to add a new table entry by making sure there is enough space in \n+  /* Prepare to add a new table entry by making sure there is enough space in\n      the table to do so.  If not, expand the current table.  */\n   if (file_table_in_use == file_table_allocated)\n     {\n@@ -10220,9 +10215,9 @@ dwarf2out_init (asm_out_file, main_input_filename)\n   /* Zero-th entry is allocated, but unused */\n   line_info_table_in_use = 1;\n \n-  /* Generate the initial DIE for the .debug section.  Note that the (string) \n+  /* Generate the initial DIE for the .debug section.  Note that the (string)\n      value given in the DW_AT_name attribute of the DW_TAG_compile_unit DIE\n-     will (typically) be a relative pathname and that this pathname should be \n+     will (typically) be a relative pathname and that this pathname should be\n      taken as being relative to the directory from which the compiler was\n      invoked when the given (base) source file was compiled.  */\n   comp_unit_die = gen_compile_unit_die (main_input_filename);\n@@ -10239,9 +10234,9 @@ dwarf2out_init (asm_out_file, main_input_filename)\n     ASM_GENERATE_INTERNAL_LABEL (text_section_label, TEXT_SECTION_LABEL, 0);\n   else\n     strcpy (text_section_label, stripattributes (TEXT_SECTION));\n-  ASM_GENERATE_INTERNAL_LABEL (debug_info_section_label, \n+  ASM_GENERATE_INTERNAL_LABEL (debug_info_section_label,\n \t\t\t       DEBUG_INFO_SECTION_LABEL, 0);\n-  ASM_GENERATE_INTERNAL_LABEL (debug_line_section_label, \n+  ASM_GENERATE_INTERNAL_LABEL (debug_line_section_label,\n \t\t\t       DEBUG_LINE_SECTION_LABEL, 0);\n \n   ASM_OUTPUT_SECTION (asm_out_file, ABBREV_SECTION);"}]}