{"sha": "6e8c65f6621fb00e9008056c7e81860f2e96284c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU4YzY1ZjY2MjFmYjAwZTkwMDgwNTZjN2U4MTg2MGYyZTk2Mjg0Yw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "ook@ucw.cz", "date": "2008-01-26T22:44:19Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2008-01-26T22:44:19Z"}, "message": "re PR target/34711 (g++.dg/tree-ssa/ivopts-1.C fails for power and arm)\n\n\tPR target/34711\n\t* tree-ssa-loop-ivopts.c (comp_cost): New type.\n\t(zero_cost, infinite_cost): New constants.\n\t(struct cost_pair): Change type of cost to comp_cost.\n\t(struct iv_ca): Change type of cand_use_cost and cost to comp_cost.\n\t(new_cost, add_costs, sub_costs, compare_costs, infinite_cost_p):\n\tNew functions.\n\t(set_use_iv_cost, force_expr_to_var_cost, force_var_cost,\n\tsplit_address_cost, ptr_difference_cost, difference_cost,\n\tget_computation_cost_at, get_computation_cost,\n\tdetermine_use_iv_cost_generic, determine_use_iv_cost_address,\n\tdetermine_use_iv_cost_condition, determine_use_iv_costs,\n\tcheaper_cost_pair, iv_ca_recount_cost, iv_ca_set_no_cp,\n\tiv_ca_set_cp, iv_ca_cost, iv_ca_new, iv_ca_dump, iv_ca_extend,\n\tiv_ca_narrow, iv_ca_prune, try_improve_iv_set, find_optimal_iv_set):\n\tChange type of cost to comp_cost.\n\t(determine_iv_cost): Increase cost of non-original ivs, instead\n\tof decreasing the cost of original ones.\n\t(get_address_cost): Indicate the complexity of the addressing mode \n\tin comp_cost.\n\t(try_add_cand_for): Prefer using ivs not specific to some object.\n\t* tree-flow.h (force_expr_to_var_cost): Declaration removed.\n\nFrom-SVN: r131877", "tree": {"sha": "30387dd4a3df50203ec75e44d117a5789e7adce1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30387dd4a3df50203ec75e44d117a5789e7adce1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e8c65f6621fb00e9008056c7e81860f2e96284c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e8c65f6621fb00e9008056c7e81860f2e96284c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e8c65f6621fb00e9008056c7e81860f2e96284c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e8c65f6621fb00e9008056c7e81860f2e96284c/comments", "author": {"login": "rakdver", "id": 20416833, "node_id": "MDQ6VXNlcjIwNDE2ODMz", "avatar_url": "https://avatars.githubusercontent.com/u/20416833?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakdver", "html_url": "https://github.com/rakdver", "followers_url": "https://api.github.com/users/rakdver/followers", "following_url": "https://api.github.com/users/rakdver/following{/other_user}", "gists_url": "https://api.github.com/users/rakdver/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakdver/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakdver/subscriptions", "organizations_url": "https://api.github.com/users/rakdver/orgs", "repos_url": "https://api.github.com/users/rakdver/repos", "events_url": "https://api.github.com/users/rakdver/events{/privacy}", "received_events_url": "https://api.github.com/users/rakdver/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2c80cb0ef7df9e250a0a7826a4414d0895c65027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c80cb0ef7df9e250a0a7826a4414d0895c65027", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c80cb0ef7df9e250a0a7826a4414d0895c65027"}], "stats": {"total": 392, "additions": 256, "deletions": 136}, "files": [{"sha": "d4123ba79eeaf185bd61a072a62ed69de4256b98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e8c65f6621fb00e9008056c7e81860f2e96284c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e8c65f6621fb00e9008056c7e81860f2e96284c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e8c65f6621fb00e9008056c7e81860f2e96284c", "patch": "@@ -1,3 +1,28 @@\n+2008-01-26  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\tPR target/34711\n+\t* tree-ssa-loop-ivopts.c (comp_cost): New type.\n+\t(zero_cost, infinite_cost): New constants.\n+\t(struct cost_pair): Change type of cost to comp_cost.\n+\t(struct iv_ca): Change type of cand_use_cost and cost to comp_cost.\n+\t(new_cost, add_costs, sub_costs, compare_costs, infinite_cost_p):\n+\tNew functions.\n+\t(set_use_iv_cost, force_expr_to_var_cost, force_var_cost,\n+\tsplit_address_cost, ptr_difference_cost, difference_cost,\n+\tget_computation_cost_at, get_computation_cost,\n+\tdetermine_use_iv_cost_generic, determine_use_iv_cost_address,\n+\tdetermine_use_iv_cost_condition, determine_use_iv_costs,\n+\tcheaper_cost_pair, iv_ca_recount_cost, iv_ca_set_no_cp,\n+\tiv_ca_set_cp, iv_ca_cost, iv_ca_new, iv_ca_dump, iv_ca_extend,\n+\tiv_ca_narrow, iv_ca_prune, try_improve_iv_set, find_optimal_iv_set):\n+\tChange type of cost to comp_cost.\n+\t(determine_iv_cost): Increase cost of non-original ivs, instead\n+\tof decreasing the cost of original ones.\n+\t(get_address_cost): Indicate the complexity of the addressing mode \n+\tin comp_cost.\n+\t(try_add_cand_for): Prefer using ivs not specific to some object.\n+\t* tree-flow.h (force_expr_to_var_cost): Declaration removed.\n+\n 2007-01-26  Peter Bergner  <bergner@vnet.ibm.com>\n \t    Janis Johnson  <janis187@us.ibm.com>\n "}, {"sha": "adc2508b1c1904e60573863803e5e5d99854ec5b", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e8c65f6621fb00e9008056c7e81860f2e96284c/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e8c65f6621fb00e9008056c7e81860f2e96284c/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=6e8c65f6621fb00e9008056c7e81860f2e96284c", "patch": "@@ -1013,7 +1013,6 @@ bool for_each_index (tree *, bool (*) (tree, tree *, void *), void *);\n void create_iv (tree, tree, tree, struct loop *, block_stmt_iterator *, bool,\n \t\ttree *, tree *);\n basic_block split_loop_exit_edge (edge);\n-unsigned force_expr_to_var_cost (tree);\n void standard_iv_increment_position (struct loop *, block_stmt_iterator *,\n \t\t\t\t     bool *);\n basic_block ip_end_pos (struct loop *);"}, {"sha": "ef7d64a268d207ed84862d7fc62e9bdbf8a80e2d", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 231, "deletions": 135, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e8c65f6621fb00e9008056c7e81860f2e96284c/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e8c65f6621fb00e9008056c7e81860f2e96284c/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=6e8c65f6621fb00e9008056c7e81860f2e96284c", "patch": "@@ -131,11 +131,24 @@ enum use_type\n   USE_COMPARE\t\t/* Use is a compare.  */\n };\n \n+/* Cost of a computation.  */\n+typedef struct\n+{\n+  unsigned cost;\t/* The runtime cost.  */\n+  unsigned complexity;\t/* The estimate of the complexity of the code for\n+\t\t\t   the computation (in no concrete units --\n+\t\t\t   complexity field should be larger for more\n+\t\t\t   complex expressions and addressing modes).  */\n+} comp_cost;\n+\n+static const comp_cost zero_cost = {0, 0};\n+static const comp_cost infinite_cost = {INFTY, INFTY};\n+\n /* The candidate - cost pair.  */\n struct cost_pair\n {\n   struct iv_cand *cand;\t/* The candidate.  */\n-  unsigned cost;\t/* The cost.  */\n+  comp_cost cost;\t/* The cost.  */\n   bitmap depends_on;\t/* The list of invariants that have to be\n \t\t\t   preserved.  */\n   tree value;\t\t/* For final value elimination, the expression for\n@@ -263,7 +276,7 @@ struct iv_ca\n   unsigned n_regs;\n \n   /* Total cost of expressing uses.  */\n-  unsigned cand_use_cost;\n+  comp_cost cand_use_cost;\n \n   /* Total cost of candidates.  */\n   unsigned cand_cost;\n@@ -272,7 +285,7 @@ struct iv_ca\n   unsigned *n_invariant_uses;\n \n   /* Total cost of the assignment.  */\n-  unsigned cost;\n+  comp_cost cost;\n };\n \n /* Difference of two iv candidate assignments.  */\n@@ -2266,18 +2279,73 @@ alloc_use_cost_map (struct ivopts_data *data)\n     }\n }\n \n+/* Returns description of computation cost of expression whose runtime\n+   cost is RUNTIME and complexity corresponds to COMPLEXITY.  */\n+\n+static comp_cost\n+new_cost (unsigned runtime, unsigned complexity)\n+{\n+  comp_cost cost;\n+\n+  cost.cost = runtime;\n+  cost.complexity = complexity;\n+\n+  return cost;\n+}\n+\n+/* Adds costs COST1 and COST2.  */\n+\n+static comp_cost\n+add_costs (comp_cost cost1, comp_cost cost2)\n+{\n+  cost1.cost += cost2.cost;\n+  cost1.complexity += cost2.complexity;\n+\n+  return cost1;\n+}\n+/* Subtracts costs COST1 and COST2.  */\n+\n+static comp_cost\n+sub_costs (comp_cost cost1, comp_cost cost2)\n+{\n+  cost1.cost -= cost2.cost;\n+  cost1.complexity -= cost2.complexity;\n+\n+  return cost1;\n+}\n+\n+/* Returns a negative number if COST1 < COST2, a positive number if\n+   COST1 > COST2, and 0 if COST1 = COST2.  */\n+\n+static int\n+compare_costs (comp_cost cost1, comp_cost cost2)\n+{\n+  if (cost1.cost == cost2.cost)\n+    return cost1.complexity - cost2.complexity;\n+\n+  return cost1.cost - cost2.cost;\n+}\n+\n+/* Returns true if COST is infinite.  */\n+\n+static bool\n+infinite_cost_p (comp_cost cost)\n+{\n+  return cost.cost == INFTY;\n+}\n+\n /* Sets cost of (USE, CANDIDATE) pair to COST and record that it depends\n    on invariants DEPENDS_ON and that the value used in expressing it\n    is VALUE.*/\n \n static void\n set_use_iv_cost (struct ivopts_data *data,\n-\t\t struct iv_use *use, struct iv_cand *cand, unsigned cost,\n-\t\t bitmap depends_on, tree value)\n+\t\t struct iv_use *use, struct iv_cand *cand,\n+\t\t comp_cost cost, bitmap depends_on, tree value)\n {\n   unsigned i, s;\n \n-  if (cost == INFTY)\n+  if (infinite_cost_p (cost))\n     {\n       BITMAP_FREE (depends_on);\n       return;\n@@ -2856,7 +2924,7 @@ multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode)\n \n    TODO -- there must be some better way.  This all is quite crude.  */\n \n-static unsigned\n+static comp_cost\n get_address_cost (bool symbol_present, bool var_present,\n \t\t  unsigned HOST_WIDE_INT offset, HOST_WIDE_INT ratio,\n \t\t  enum machine_mode mem_mode)\n@@ -2865,7 +2933,7 @@ get_address_cost (bool symbol_present, bool var_present,\n   static HOST_WIDE_INT rat[MAX_MACHINE_MODE], off[MAX_MACHINE_MODE];\n   static HOST_WIDE_INT min_offset[MAX_MACHINE_MODE], max_offset[MAX_MACHINE_MODE];\n   static unsigned costs[MAX_MACHINE_MODE][2][2][2][2];\n-  unsigned cost, acost;\n+  unsigned cost, acost, complexity;\n   bool offset_p, ratio_p;\n   HOST_WIDE_INT s_offset;\n   unsigned HOST_WIDE_INT mask;\n@@ -3059,20 +3127,21 @@ get_address_cost (bool symbol_present, bool var_present,\n     cost += add_cost (Pmode);\n \n   acost = costs[mem_mode][symbol_present][var_present][offset_p][ratio_p];\n-  return cost + acost;\n+  complexity = (symbol_present != 0) + (var_present != 0) + offset_p + ratio_p;\n+  return new_cost (cost + acost, complexity);\n }\n \n /* Estimates cost of forcing expression EXPR into a variable.  */\n \n-unsigned\n+static comp_cost\n force_expr_to_var_cost (tree expr)\n {\n   static bool costs_initialized = false;\n   static unsigned integer_cost;\n   static unsigned symbol_cost;\n   static unsigned address_cost;\n   tree op0, op1;\n-  unsigned cost0, cost1, cost;\n+  comp_cost cost0, cost1, cost;\n   enum machine_mode mode;\n \n   if (!costs_initialized)\n@@ -3112,12 +3181,12 @@ force_expr_to_var_cost (tree expr)\n   STRIP_NOPS (expr);\n \n   if (SSA_VAR_P (expr))\n-    return 0;\n+    return zero_cost;\n \n   if (TREE_INVARIANT (expr))\n     {\n       if (TREE_CODE (expr) == INTEGER_CST)\n-\treturn integer_cost;\n+\treturn new_cost (integer_cost, 0);\n \n       if (TREE_CODE (expr) == ADDR_EXPR)\n \t{\n@@ -3126,10 +3195,10 @@ force_expr_to_var_cost (tree expr)\n \t  if (TREE_CODE (obj) == VAR_DECL\n \t      || TREE_CODE (obj) == PARM_DECL\n \t      || TREE_CODE (obj) == RESULT_DECL)\n-\t    return symbol_cost;\n+\t    return new_cost (symbol_cost, 0);\n \t}\n \n-      return address_cost;\n+      return new_cost (address_cost, 0);\n     }\n \n   switch (TREE_CODE (expr))\n@@ -3144,20 +3213,20 @@ force_expr_to_var_cost (tree expr)\n       STRIP_NOPS (op1);\n \n       if (is_gimple_val (op0))\n-\tcost0 = 0;\n+\tcost0 = zero_cost;\n       else\n \tcost0 = force_expr_to_var_cost (op0);\n \n       if (is_gimple_val (op1))\n-\tcost1 = 0;\n+\tcost1 = zero_cost;\n       else\n \tcost1 = force_expr_to_var_cost (op1);\n \n       break;\n \n     default:\n       /* Just an arbitrary value, FIXME.  */\n-      return target_spill_cost;\n+      return new_cost (target_spill_cost, 0);\n     }\n \n   mode = TYPE_MODE (TREE_TYPE (expr));\n@@ -3166,36 +3235,39 @@ force_expr_to_var_cost (tree expr)\n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      cost = add_cost (mode);\n+      cost = new_cost (add_cost (mode), 0);\n       break;\n \n     case MULT_EXPR:\n       if (cst_and_fits_in_hwi (op0))\n-\tcost = multiply_by_cost (int_cst_value (op0), mode);\n+\tcost = new_cost (multiply_by_cost (int_cst_value (op0), mode), 0);\n       else if (cst_and_fits_in_hwi (op1))\n-\tcost = multiply_by_cost (int_cst_value (op1), mode);\n+\tcost = new_cost (multiply_by_cost (int_cst_value (op1), mode), 0);\n       else\n-\treturn target_spill_cost;\n+\treturn new_cost (target_spill_cost, 0);\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n-  cost += cost0;\n-  cost += cost1;\n+  cost = add_costs (cost, cost0);\n+  cost = add_costs (cost, cost1);\n \n   /* Bound the cost by target_spill_cost.  The parts of complicated\n      computations often are either loop invariant or at least can\n      be shared between several iv uses, so letting this grow without\n      limits would not give reasonable results.  */\n-  return cost < target_spill_cost ? cost : target_spill_cost;\n+  if (cost.cost > target_spill_cost)\n+    cost.cost = target_spill_cost;\n+\n+  return cost;\n }\n \n /* Estimates cost of forcing EXPR into a variable.  DEPENDS_ON is a set of the\n    invariants the computation depends on.  */\n \n-static unsigned\n+static comp_cost\n force_var_cost (struct ivopts_data *data,\n \t\ttree expr, bitmap *depends_on)\n {\n@@ -3213,7 +3285,7 @@ force_var_cost (struct ivopts_data *data,\n    to false if the corresponding part is missing.  DEPENDS_ON is a set of the\n    invariants the computation depends on.  */\n \n-static unsigned\n+static comp_cost\n split_address_cost (struct ivopts_data *data,\n \t\t    tree addr, bool *symbol_present, bool *var_present,\n \t\t    unsigned HOST_WIDE_INT *offset, bitmap *depends_on)\n@@ -3236,7 +3308,7 @@ split_address_cost (struct ivopts_data *data,\n       *var_present = true;\n       fd_ivopts_data = data;\n       walk_tree (&addr, find_depends, depends_on, NULL);\n-      return target_spill_cost;\n+      return new_cost (target_spill_cost, 0);\n     }\n \n   *offset += bitpos / BITS_PER_UNIT;\n@@ -3245,12 +3317,12 @@ split_address_cost (struct ivopts_data *data,\n     {\n       *symbol_present = true;\n       *var_present = false;\n-      return 0;\n+      return zero_cost;\n     }\n       \n   *symbol_present = false;\n   *var_present = true;\n-  return 0;\n+  return zero_cost;\n }\n \n /* Estimates cost of expressing difference of addresses E1 - E2 as\n@@ -3259,13 +3331,13 @@ split_address_cost (struct ivopts_data *data,\n    part is missing.  DEPENDS_ON is a set of the invariants the computation\n    depends on.  */\n \n-static unsigned\n+static comp_cost\n ptr_difference_cost (struct ivopts_data *data,\n \t\t     tree e1, tree e2, bool *symbol_present, bool *var_present,\n \t\t     unsigned HOST_WIDE_INT *offset, bitmap *depends_on)\n {\n   HOST_WIDE_INT diff = 0;\n-  unsigned cost;\n+  comp_cost cost;\n \n   gcc_assert (TREE_CODE (e1) == ADDR_EXPR);\n \n@@ -3274,19 +3346,19 @@ ptr_difference_cost (struct ivopts_data *data,\n       *offset += diff;\n       *symbol_present = false;\n       *var_present = false;\n-      return 0;\n+      return zero_cost;\n     }\n \n-  if (e2 == integer_zero_node)\n+  if (integer_zerop (e2))\n     return split_address_cost (data, TREE_OPERAND (e1, 0),\n \t\t\t       symbol_present, var_present, offset, depends_on);\n \n   *symbol_present = false;\n   *var_present = true;\n   \n   cost = force_var_cost (data, e1, depends_on);\n-  cost += force_var_cost (data, e2, depends_on);\n-  cost += add_cost (Pmode);\n+  cost = add_costs (cost, force_var_cost (data, e2, depends_on));\n+  cost.cost += add_cost (Pmode);\n \n   return cost;\n }\n@@ -3297,12 +3369,12 @@ ptr_difference_cost (struct ivopts_data *data,\n    part is missing.  DEPENDS_ON is a set of the invariants the computation\n    depends on.  */\n \n-static unsigned\n+static comp_cost\n difference_cost (struct ivopts_data *data,\n \t\t tree e1, tree e2, bool *symbol_present, bool *var_present,\n \t\t unsigned HOST_WIDE_INT *offset, bitmap *depends_on)\n {\n-  unsigned cost;\n+  comp_cost cost;\n   enum machine_mode mode = TYPE_MODE (TREE_TYPE (e1));\n   unsigned HOST_WIDE_INT off1, off2;\n \n@@ -3321,7 +3393,7 @@ difference_cost (struct ivopts_data *data,\n   if (operand_equal_p (e1, e2, 0))\n     {\n       *var_present = false;\n-      return 0;\n+      return zero_cost;\n     }\n   *var_present = true;\n   if (integer_zerop (e2))\n@@ -3330,14 +3402,14 @@ difference_cost (struct ivopts_data *data,\n   if (integer_zerop (e1))\n     {\n       cost = force_var_cost (data, e2, depends_on);\n-      cost += multiply_by_cost (-1, mode);\n+      cost.cost += multiply_by_cost (-1, mode);\n \n       return cost;\n     }\n \n   cost = force_var_cost (data, e1, depends_on);\n-  cost += force_var_cost (data, e2, depends_on);\n-  cost += add_cost (mode);\n+  cost = add_costs (cost, force_var_cost (data, e2, depends_on));\n+  cost.cost += add_cost (mode);\n \n   return cost;\n }\n@@ -3348,7 +3420,7 @@ difference_cost (struct ivopts_data *data,\n    register.  A set of invariants we depend on is stored in\n    DEPENDS_ON.  AT is the statement at that the value is computed.  */\n \n-static unsigned\n+static comp_cost\n get_computation_cost_at (struct ivopts_data *data,\n \t\t\t struct iv_use *use, struct iv_cand *cand,\n \t\t\t bool address_p, bitmap *depends_on, tree at)\n@@ -3359,14 +3431,15 @@ get_computation_cost_at (struct ivopts_data *data,\n   unsigned HOST_WIDE_INT cstepi, offset = 0;\n   HOST_WIDE_INT ratio, aratio;\n   bool var_present, symbol_present;\n-  unsigned cost = 0, n_sums;\n+  comp_cost cost;\n+  unsigned n_sums;\n   double_int rat;\n \n   *depends_on = NULL;\n \n   /* Only consider real candidates.  */\n   if (!cand->iv)\n-    return INFTY;\n+    return infinite_cost;\n \n   cbase = cand->iv->base;\n   cstep = cand->iv->step;\n@@ -3375,7 +3448,7 @@ get_computation_cost_at (struct ivopts_data *data,\n   if (TYPE_PRECISION (utype) > TYPE_PRECISION (ctype))\n     {\n       /* We do not have a precision to express the values of use.  */\n-      return INFTY;\n+      return infinite_cost;\n     }\n \n   if (address_p)\n@@ -3388,7 +3461,7 @@ get_computation_cost_at (struct ivopts_data *data,\n       if (use->iv->base_object\n \t  && cand->iv->base_object\n \t  && !operand_equal_p (use->iv->base_object, cand->iv->base_object, 0))\n-\treturn INFTY;\n+\treturn infinite_cost;\n     }\n \n   if (TYPE_PRECISION (utype) != TYPE_PRECISION (ctype))\n@@ -3409,12 +3482,12 @@ get_computation_cost_at (struct ivopts_data *data,\n     cstepi = 0;\n \n   if (!constant_multiple_of (ustep, cstep, &rat))\n-    return INFTY;\n+    return infinite_cost;\n     \n   if (double_int_fits_in_shwi_p (rat))\n     ratio = double_int_to_shwi (rat);\n   else\n-    return INFTY;\n+    return infinite_cost;\n \n   /* use = ubase + ratio * (var - cbase).  If either cbase is a constant\n      or ratio == 1, it is better to handle this like\n@@ -3426,26 +3499,27 @@ get_computation_cost_at (struct ivopts_data *data,\n   if (cst_and_fits_in_hwi (cbase))\n     {\n       offset = - ratio * int_cst_value (cbase); \n-      cost += difference_cost (data,\n-\t\t\t       ubase, integer_zero_node,\n-\t\t\t       &symbol_present, &var_present, &offset,\n-\t\t\t       depends_on);\n+      cost = difference_cost (data,\n+\t\t\t      ubase, build_int_cst (utype, 0),\n+\t\t\t      &symbol_present, &var_present, &offset,\n+\t\t\t      depends_on);\n     }\n   else if (ratio == 1)\n     {\n-      cost += difference_cost (data,\n-\t\t\t       ubase, cbase,\n-\t\t\t       &symbol_present, &var_present, &offset,\n-\t\t\t       depends_on);\n+      cost = difference_cost (data,\n+\t\t\t      ubase, cbase,\n+\t\t\t      &symbol_present, &var_present, &offset,\n+\t\t\t      depends_on);\n     }\n   else\n     {\n-      cost += force_var_cost (data, cbase, depends_on);\n-      cost += add_cost (TYPE_MODE (ctype));\n-      cost += difference_cost (data,\n-\t\t\t       ubase, integer_zero_node,\n-\t\t\t       &symbol_present, &var_present, &offset,\n-\t\t\t       depends_on);\n+      cost = force_var_cost (data, cbase, depends_on);\n+      cost.cost += add_cost (TYPE_MODE (ctype));\n+      cost = add_costs (cost,\n+\t\t\tdifference_cost (data,\n+\t\t\t\t\t ubase, build_int_cst (utype, 0),\n+\t\t\t\t\t &symbol_present, &var_present,\n+\t\t\t\t\t &offset, depends_on));\n     }\n \n   /* If we are after the increment, the value of the candidate is higher by\n@@ -3457,42 +3531,49 @@ get_computation_cost_at (struct ivopts_data *data,\n      (symbol/var/const parts may be omitted).  If we are looking for an address,\n      find the cost of addressing this.  */\n   if (address_p)\n-    return cost + get_address_cost (symbol_present, var_present, offset, ratio,\n-\t\t\t\t    TYPE_MODE (TREE_TYPE (*use->op_p)));\n+    return add_costs (cost, get_address_cost (symbol_present, var_present,\n+\t\t\t\toffset, ratio,\n+\t\t\t\tTYPE_MODE (TREE_TYPE (*use->op_p))));\n \n   /* Otherwise estimate the costs for computing the expression.  */\n   aratio = ratio > 0 ? ratio : -ratio;\n   if (!symbol_present && !var_present && !offset)\n     {\n       if (ratio != 1)\n-\tcost += multiply_by_cost (ratio, TYPE_MODE (ctype));\n+\tcost.cost += multiply_by_cost (ratio, TYPE_MODE (ctype));\n \n       return cost;\n     }\n \n   if (aratio != 1)\n-    cost += multiply_by_cost (aratio, TYPE_MODE (ctype));\n+    cost.cost += multiply_by_cost (aratio, TYPE_MODE (ctype));\n \n   n_sums = 1;\n   if (var_present\n       /* Symbol + offset should be compile-time computable.  */\n       && (symbol_present || offset))\n     n_sums++;\n \n-  return cost + n_sums * add_cost (TYPE_MODE (ctype));\n+  /* Having offset does not affect runtime cost in case it is added to\n+     symbol, but it increases complexity.  */\n+  if (offset)\n+    cost.complexity++;\n+\n+  cost.cost += n_sums * add_cost (TYPE_MODE (ctype));\n+  return cost;\n \n fallback:\n   {\n     /* Just get the expression, expand it and measure the cost.  */\n     tree comp = get_computation_at (data->current_loop, use, cand, at);\n \n     if (!comp)\n-      return INFTY;\n+      return infinite_cost;\n \n     if (address_p)\n       comp = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (comp)), comp);\n \n-    return computation_cost (comp);\n+    return new_cost (computation_cost (comp), 0);\n   }\n }\n \n@@ -3502,7 +3583,7 @@ get_computation_cost_at (struct ivopts_data *data,\n    register.  A set of invariants we depend on is stored in\n    DEPENDS_ON.  */\n \n-static unsigned\n+static comp_cost\n get_computation_cost (struct ivopts_data *data,\n \t\t      struct iv_use *use, struct iv_cand *cand,\n \t\t      bool address_p, bitmap *depends_on)\n@@ -3519,7 +3600,7 @@ determine_use_iv_cost_generic (struct ivopts_data *data,\n \t\t\t       struct iv_use *use, struct iv_cand *cand)\n {\n   bitmap depends_on;\n-  unsigned cost;\n+  comp_cost cost;\n \n   /* The simple case first -- if we need to express value of the preserved\n      original biv, the cost is 0.  This also prevents us from counting the\n@@ -3528,14 +3609,14 @@ determine_use_iv_cost_generic (struct ivopts_data *data,\n   if (cand->pos == IP_ORIGINAL\n       && cand->incremented_at == use->stmt)\n     {\n-      set_use_iv_cost (data, use, cand, 0, NULL, NULL_TREE);\n+      set_use_iv_cost (data, use, cand, zero_cost, NULL, NULL_TREE);\n       return true;\n     }\n \n   cost = get_computation_cost (data, use, cand, false, &depends_on);\n   set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE);\n \n-  return cost != INFTY;\n+  return !infinite_cost_p (cost);\n }\n \n /* Determines cost of basing replacement of USE on CAND in an address.  */\n@@ -3545,11 +3626,11 @@ determine_use_iv_cost_address (struct ivopts_data *data,\n \t\t\t       struct iv_use *use, struct iv_cand *cand)\n {\n   bitmap depends_on;\n-  unsigned cost = get_computation_cost (data, use, cand, true, &depends_on);\n+  comp_cost cost = get_computation_cost (data, use, cand, true, &depends_on);\n \n   set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE);\n \n-  return cost != INFTY;\n+  return !infinite_cost_p (cost);\n }\n \n /* Computes value of candidate CAND at position AT in iteration NITER, and\n@@ -3679,13 +3760,13 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n   tree bound = NULL_TREE;\n   struct iv *cmp_iv;\n   bitmap depends_on_elim = NULL, depends_on_express = NULL, depends_on;\n-  unsigned elim_cost, express_cost, cost;\n+  comp_cost elim_cost, express_cost, cost;\n   bool ok;\n \n   /* Only consider real candidates.  */\n   if (!cand->iv)\n     {\n-      set_use_iv_cost (data, use, cand, INFTY, NULL, NULL_TREE);\n+      set_use_iv_cost (data, use, cand, infinite_cost, NULL, NULL_TREE);\n       return false;\n     }\n \n@@ -3695,10 +3776,10 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n       elim_cost = force_var_cost (data, bound, &depends_on_elim);\n       /* The bound is a loop invariant, so it will be only computed\n \t once.  */\n-      elim_cost /= AVG_LOOP_NITER (data->current_loop);\n+      elim_cost.cost /= AVG_LOOP_NITER (data->current_loop);\n     }\n   else\n-    elim_cost = INFTY;\n+    elim_cost = infinite_cost;\n \n   /* Try expressing the original giv.  If it is compared with an invariant,\n      note that we cannot get rid of it.  */\n@@ -3711,7 +3792,7 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n   walk_tree (&cmp_iv->base, find_depends, &depends_on_express, NULL);\n \n   /* Choose the better approach.  */\n-  if (elim_cost < express_cost)\n+  if (compare_costs (elim_cost, express_cost) < 0)\n     {\n       cost = elim_cost;\n       depends_on = depends_on_elim;\n@@ -3732,7 +3813,7 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n   if (depends_on_express)\n     BITMAP_FREE (depends_on_express);\n \n-  return cost != INFTY;\n+  return !infinite_cost_p (cost);\n }\n \n /* Determines cost of basing replacement of USE on CAND.  Returns false\n@@ -3811,16 +3892,17 @@ determine_use_iv_costs (struct ivopts_data *data)\n \t  use = iv_use (data, i);\n \n \t  fprintf (dump_file, \"Use %d:\\n\", i);\n-\t  fprintf (dump_file, \"  cand\\tcost\\tdepends on\\n\");\n+\t  fprintf (dump_file, \"  cand\\tcost\\tcompl.\\tdepends on\\n\");\n \t  for (j = 0; j < use->n_map_members; j++)\n \t    {\n \t      if (!use->cost_map[j].cand\n-\t\t  || use->cost_map[j].cost == INFTY)\n+\t\t  || infinite_cost_p (use->cost_map[j].cost))\n \t\tcontinue;\n \n-\t      fprintf (dump_file, \"  %d\\t%d\\t\",\n+\t      fprintf (dump_file, \"  %d\\t%d\\t%d\\t\",\n \t\t       use->cost_map[j].cand->id,\n-\t\t       use->cost_map[j].cost);\n+\t\t       use->cost_map[j].cost.cost,\n+\t\t       use->cost_map[j].cost.complexity);\n \t      if (use->cost_map[j].depends_on)\n \t\tbitmap_print (dump_file,\n \t\t\t      use->cost_map[j].depends_on, \"\",\"\");\n@@ -3838,7 +3920,8 @@ determine_use_iv_costs (struct ivopts_data *data)\n static void\n determine_iv_cost (struct ivopts_data *data, struct iv_cand *cand)\n {\n-  unsigned cost_base, cost_step;\n+  comp_cost cost_base;\n+  unsigned cost, cost_step;\n   tree base;\n \n   if (!cand->iv)\n@@ -3855,20 +3938,22 @@ determine_iv_cost (struct ivopts_data *data, struct iv_cand *cand)\n   cost_base = force_var_cost (data, base, NULL);\n   cost_step = add_cost (TYPE_MODE (TREE_TYPE (base)));\n \n-  cand->cost = cost_step + cost_base / AVG_LOOP_NITER (current_loop);\n+  cost = cost_step + cost_base.cost / AVG_LOOP_NITER (current_loop);\n \n-  /* Prefer the original iv unless we may gain something by replacing it;\n-     this is not really relevant for artificial ivs created by other\n-     passes.  */\n-  if (cand->pos == IP_ORIGINAL\n-      && !DECL_ARTIFICIAL (SSA_NAME_VAR (cand->var_before)))\n-    cand->cost--;\n+  /* Prefer the original ivs unless we may gain something by replacing it.\n+     The reason is to makee debugging simpler; so this is not relevant for\n+     artificial ivs created by other optimization passes.  */\n+  if (cand->pos != IP_ORIGINAL\n+      || DECL_ARTIFICIAL (SSA_NAME_VAR (cand->var_before)))\n+    cost++;\n   \n   /* Prefer not to insert statements into latch unless there are some\n      already (so that we do not create unnecessary jumps).  */\n   if (cand->pos == IP_END\n       && empty_block_p (ip_end_pos (data->current_loop)))\n-    cand->cost++;\n+    cost++;\n+\n+  cand->cost = cost;\n }\n \n /* Determines costs of computation of the candidates.  */\n@@ -3988,16 +4073,19 @@ determine_set_costs (struct ivopts_data *data)\n static bool\n cheaper_cost_pair (struct cost_pair *a, struct cost_pair *b)\n {\n+  int cmp;\n+\n   if (!a)\n     return false;\n \n   if (!b)\n     return true;\n \n-  if (a->cost < b->cost)\n+  cmp = compare_costs (a->cost, b->cost);\n+  if (cmp < 0)\n     return true;\n \n-  if (a->cost > b->cost)\n+  if (cmp > 0)\n     return false;\n \n   /* In case the costs are the same, prefer the cheaper candidate.  */\n@@ -4012,11 +4100,9 @@ cheaper_cost_pair (struct cost_pair *a, struct cost_pair *b)\n static void\n iv_ca_recount_cost (struct ivopts_data *data, struct iv_ca *ivs)\n {\n-  unsigned cost = 0;\n-\n-  cost += ivs->cand_use_cost;\n-  cost += ivs->cand_cost;\n-  cost += ivopts_global_cost_for_size (data, ivs->n_regs);\n+  comp_cost cost = ivs->cand_use_cost;\n+  cost.cost += ivs->cand_cost;\n+  cost.cost += ivopts_global_cost_for_size (data, ivs->n_regs);\n \n   ivs->cost = cost;\n }\n@@ -4070,7 +4156,7 @@ iv_ca_set_no_cp (struct ivopts_data *data, struct iv_ca *ivs,\n       iv_ca_set_remove_invariants (ivs, cp->cand->depends_on);\n     }\n \n-  ivs->cand_use_cost -= cp->cost;\n+  ivs->cand_use_cost = sub_costs (ivs->cand_use_cost, cp->cost);\n \n   iv_ca_set_remove_invariants (ivs, cp->depends_on);\n   iv_ca_recount_cost (data, ivs);\n@@ -4128,7 +4214,7 @@ iv_ca_set_cp (struct ivopts_data *data, struct iv_ca *ivs,\n \t  iv_ca_set_add_invariants (ivs, cp->cand->depends_on);\n \t}\n \n-      ivs->cand_use_cost += cp->cost;\n+      ivs->cand_use_cost = add_costs (ivs->cand_use_cost, cp->cost);\n       iv_ca_set_add_invariants (ivs, cp->depends_on);\n       iv_ca_recount_cost (data, ivs);\n     }\n@@ -4166,10 +4252,10 @@ iv_ca_add_use (struct ivopts_data *data, struct iv_ca *ivs,\n \n /* Get cost for assignment IVS.  */\n \n-static unsigned\n+static comp_cost\n iv_ca_cost (struct iv_ca *ivs)\n {\n-  return (ivs->bad_uses ? INFTY : ivs->cost);\n+  return (ivs->bad_uses ? infinite_cost : ivs->cost);\n }\n \n /* Returns true if all dependences of CP are among invariants in IVS.  */\n@@ -4331,10 +4417,10 @@ iv_ca_new (struct ivopts_data *data)\n   nw->cands = BITMAP_ALLOC (NULL);\n   nw->n_cands = 0;\n   nw->n_regs = 0;\n-  nw->cand_use_cost = 0;\n+  nw->cand_use_cost = zero_cost;\n   nw->cand_cost = 0;\n   nw->n_invariant_uses = XCNEWVEC (unsigned, data->max_inv_id + 1);\n-  nw->cost = 0;\n+  nw->cost = zero_cost;\n \n   return nw;\n }\n@@ -4359,8 +4445,9 @@ iv_ca_dump (struct ivopts_data *data, FILE *file, struct iv_ca *ivs)\n {\n   const char *pref = \"  invariants \";\n   unsigned i;\n+  comp_cost cost = iv_ca_cost (ivs);\n \n-  fprintf (file, \"  cost %d\\n\", iv_ca_cost (ivs));\n+  fprintf (file, \"  cost %d (complexity %d)\\n\", cost.cost, cost.complexity);\n   bitmap_print (file, ivs->cands, \"  candidates \",\"\\n\");\n \n   for (i = 1; i <= data->max_inv_id; i++)\n@@ -4376,12 +4463,13 @@ iv_ca_dump (struct ivopts_data *data, FILE *file, struct iv_ca *ivs)\n    new set, and store differences in DELTA.  Number of induction variables\n    in the new set is stored to N_IVS.  */\n \n-static unsigned\n+static comp_cost\n iv_ca_extend (struct ivopts_data *data, struct iv_ca *ivs,\n \t      struct iv_cand *cand, struct iv_ca_delta **delta,\n \t      unsigned *n_ivs)\n {\n-  unsigned i, cost;\n+  unsigned i;\n+  comp_cost cost;\n   struct iv_use *use;\n   struct cost_pair *old_cp, *new_cp;\n \n@@ -4420,7 +4508,7 @@ iv_ca_extend (struct ivopts_data *data, struct iv_ca *ivs,\n /* Try narrowing set IVS by removing CAND.  Return the cost of\n    the new set and store the differences in DELTA.  */\n \n-static unsigned\n+static comp_cost\n iv_ca_narrow (struct ivopts_data *data, struct iv_ca *ivs,\n \t      struct iv_cand *cand, struct iv_ca_delta **delta)\n {\n@@ -4429,7 +4517,7 @@ iv_ca_narrow (struct ivopts_data *data, struct iv_ca *ivs,\n   struct cost_pair *old_cp, *new_cp, *cp;\n   bitmap_iterator bi;\n   struct iv_cand *cnd;\n-  unsigned cost;\n+  comp_cost cost;\n \n   *delta = NULL;\n   for (i = 0; i < n_iv_uses (data); i++)\n@@ -4488,7 +4576,7 @@ iv_ca_narrow (struct ivopts_data *data, struct iv_ca *ivs,\n       if (!new_cp)\n \t{\n \t  iv_ca_delta_free (delta);\n-\t  return INFTY;\n+\t  return infinite_cost;\n \t}\n \n       *delta = iv_ca_delta_add (use, old_cp, new_cp, *delta);\n@@ -4505,13 +4593,14 @@ iv_ca_narrow (struct ivopts_data *data, struct iv_ca *ivs,\n    from to EXCEPT_CAND from it.  Return cost of the new set, and store\n    differences in DELTA.  */\n \n-static unsigned\n+static comp_cost\n iv_ca_prune (struct ivopts_data *data, struct iv_ca *ivs,\n \t     struct iv_cand *except_cand, struct iv_ca_delta **delta)\n {\n   bitmap_iterator bi;\n   struct iv_ca_delta *act_delta, *best_delta;\n-  unsigned i, best_cost, acost;\n+  unsigned i;\n+  comp_cost best_cost, acost;\n   struct iv_cand *cand;\n \n   best_delta = NULL;\n@@ -4526,7 +4615,7 @@ iv_ca_prune (struct ivopts_data *data, struct iv_ca *ivs,\n \n       acost = iv_ca_narrow (data, ivs, cand, &act_delta);\n \n-      if (acost < best_cost)\n+      if (compare_costs (acost, best_cost) < 0)\n \t{\n \t  best_cost = acost;\n \t  iv_ca_delta_free (&best_delta);\n@@ -4557,7 +4646,7 @@ static bool\n try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \t\t  struct iv_use *use)\n {\n-  unsigned best_cost, act_cost;\n+  comp_cost best_cost, act_cost;\n   unsigned i;\n   bitmap_iterator bi;\n   struct iv_cand *cand;\n@@ -4574,18 +4663,21 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n       iv_ca_set_no_cp (data, ivs, use);\n     }\n \n-  /* First try important candidates.  Only if it fails, try the specific ones.\n-     Rationale -- in loops with many variables the best choice often is to use\n-     just one generic biv.  If we added here many ivs specific to the uses,\n-     the optimization algorithm later would be likely to get stuck in a local\n-     minimum, thus causing us to create too many ivs.  The approach from\n-     few ivs to more seems more likely to be successful -- starting from few\n-     ivs, replacing an expensive use by a specific iv should always be a\n-     win.  */\n+  /* First try important candidates not based on any memory object.  Only if\n+     this fails, try the specific ones.  Rationale -- in loops with many\n+     variables the best choice often is to use just one generic biv.  If we\n+     added here many ivs specific to the uses, the optimization algorithm later\n+     would be likely to get stuck in a local minimum, thus causing us to create\n+     too many ivs.  The approach from few ivs to more seems more likely to be\n+     successful -- starting from few ivs, replacing an expensive use by a\n+     specific iv should always be a win.  */\n   EXECUTE_IF_SET_IN_BITMAP (data->important_candidates, 0, i, bi)\n     {\n       cand = iv_cand (data, i);\n \n+      if (cand->iv->base_object != NULL_TREE)\n+\tcontinue;\n+\n       if (iv_ca_cand_used_p (ivs, cand))\n \tcontinue;\n \n@@ -4598,7 +4690,7 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n       iv_ca_set_no_cp (data, ivs, use);\n       act_delta = iv_ca_delta_add (use, NULL, cp, act_delta);\n \n-      if (act_cost < best_cost)\n+      if (compare_costs (act_cost, best_cost) < 0)\n \t{\n \t  best_cost = act_cost;\n \n@@ -4609,7 +4701,7 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \tiv_ca_delta_free (&act_delta);\n     }\n \n-  if (best_cost == INFTY)\n+  if (infinite_cost_p (best_cost))\n     {\n       for (i = 0; i < use->n_map_members; i++)\n \t{\n@@ -4619,7 +4711,7 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \t    continue;\n \n \t  /* Already tried this.  */\n-\t  if (cand->important)\n+\t  if (cand->important && cand->iv->base_object == NULL_TREE)\n \t    continue;\n       \n \t  if (iv_ca_cand_used_p (ivs, cand))\n@@ -4632,7 +4724,7 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \t  act_delta = iv_ca_delta_add (use, iv_ca_cand_for_use (ivs, use),\n \t\t\t\t       cp, act_delta);\n \n-\t  if (act_cost < best_cost)\n+\t  if (compare_costs (act_cost, best_cost) < 0)\n \t    {\n \t      best_cost = act_cost;\n \n@@ -4648,7 +4740,7 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n   iv_ca_delta_commit (data, ivs, best_delta, true);\n   iv_ca_delta_free (&best_delta);\n \n-  return (best_cost != INFTY);\n+  return !infinite_cost_p (best_cost);\n }\n \n /* Finds an initial assignment of candidates to uses.  */\n@@ -4674,7 +4766,8 @@ get_initial_solution (struct ivopts_data *data)\n static bool\n try_improve_iv_set (struct ivopts_data *data, struct iv_ca *ivs)\n {\n-  unsigned i, acost, best_cost = iv_ca_cost (ivs), n_ivs;\n+  unsigned i, n_ivs;\n+  comp_cost acost, best_cost = iv_ca_cost (ivs);\n   struct iv_ca_delta *best_delta = NULL, *act_delta, *tmp_delta;\n   struct iv_cand *cand;\n \n@@ -4700,7 +4793,7 @@ try_improve_iv_set (struct ivopts_data *data, struct iv_ca *ivs)\n \t  act_delta = iv_ca_delta_join (act_delta, tmp_delta);\n \t}\n \n-      if (acost < best_cost)\n+      if (compare_costs (acost, best_cost) < 0)\n \t{\n \t  best_cost = acost;\n \t  iv_ca_delta_free (&best_delta);\n@@ -4721,7 +4814,7 @@ try_improve_iv_set (struct ivopts_data *data, struct iv_ca *ivs)\n     }\n \n   iv_ca_delta_commit (data, ivs, best_delta, true);\n-  gcc_assert (best_cost == iv_ca_cost (ivs));\n+  gcc_assert (compare_costs (best_cost, iv_ca_cost (ivs)) == 0);\n   iv_ca_delta_free (&best_delta);\n   return true;\n }\n@@ -4762,7 +4855,10 @@ find_optimal_iv_set (struct ivopts_data *data)\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Final cost %d\\n\\n\", iv_ca_cost (set));\n+    {\n+      comp_cost cost = iv_ca_cost (set);\n+      fprintf (dump_file, \"Final cost %d (complexity %d)\\n\\n\", cost.cost, cost.complexity);\n+    }\n \n   for (i = 0; i < n_iv_uses (data); i++)\n     {"}]}