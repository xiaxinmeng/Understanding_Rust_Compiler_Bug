{"sha": "dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM2YjliYTJkMThlY2M0YjIyZTFhMjMwMDJjZWE3NjgxZDg3ODZiYw==", "commit": {"author": {"name": "Matthew Heaney", "email": "heaney@adacore.com", "date": "2006-02-17T16:08:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-17T16:08:48Z"}, "message": "a-convec.ads, [...]: (operator \"&\"): handle potential overflow for large index types\n\n2006-02-17  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-convec.ads, a-convec.adb: \n\t(operator \"&\"): handle potential overflow for large index types\n\t(Insert): removed Contraint_Error when using large index types\n\t(Insert_Space): removed Constraint_Error for large index types\n\t(Length): moved constraint check from Length to Insert\n\n\t* a-coinve.ads, a-coinve.adb: Stream attribute procedures are declared\n\tas not null access.\n\tExplicit raise statements now include an exception message.\n\t(operator \"&\"): handle potential overflow for large index types\n\t(Insert): removed Contraint_Error when using large index types\n\t(Insert_Space): removed Constraint_Error for large index types\n\t(Length): moved constraint check from Length to Insert\n\nFrom-SVN: r111197", "tree": {"sha": "e3840316266dbd9e7ac56d6ad9624ab50cdb8b7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3840316266dbd9e7ac56d6ad9624ab50cdb8b7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc/comments", "author": null, "committer": null, "parents": [{"sha": "35ecbe09de2198eca10cc6a7e6349969007309c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35ecbe09de2198eca10cc6a7e6349969007309c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35ecbe09de2198eca10cc6a7e6349969007309c3"}], "stats": {"total": 839, "additions": 522, "deletions": 317}, "files": [{"sha": "121ee3f97888e8342ada1d605421b2e690fac252", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 241, "deletions": 150, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc", "patch": "@@ -40,6 +40,7 @@ with System;  use type System.Address;\n package body Ada.Containers.Indefinite_Vectors is\n \n    type Int is range System.Min_Int .. System.Max_Int;\n+   type UInt is mod System.Max_Binary_Modulus;\n \n    procedure Free is\n      new Ada.Unchecked_Deallocation (Elements_Type, Elements_Access);\n@@ -120,12 +121,18 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       declare\n-         Last_As_Int : constant Int'Base :=  -- TODO: handle overflow\n-                         Int (Index_Type'First) + Int (LN) + Int (RN) - 1;\n+         N           : constant Int'Base := Int (LN) + Int (RN);\n+         Last_As_Int : Int'Base;\n \n       begin\n-         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+         if Int (No_Index) > Int'Last - N then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         Last_As_Int := Int (No_Index) + N;\n+\n+         if Last_As_Int > Int (Index_Type'Last) then\n+            raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n          declare\n@@ -209,12 +216,17 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       declare\n-         Last_As_Int : constant Int'Base :=\n-                         Int (Index_Type'First) + Int (LN);\n+         Last_As_Int : Int'Base;\n \n       begin\n-         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+         if Int (Index_Type'First) > Int'Last - Int (LN) then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         Last_As_Int := Int (Index_Type'First) + Int (LN);\n+\n+         if Last_As_Int > Int (Index_Type'Last) then\n+            raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n          declare\n@@ -285,12 +297,17 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       declare\n-         Last_As_Int : constant Int'Base :=\n-                         Int (Index_Type'First) + Int (RN);\n+         Last_As_Int : Int'Base;\n \n       begin\n-         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+         if Int (Index_Type'First) > Int'Last - Int (RN) then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         Last_As_Int := Int (Index_Type'First) + Int (RN);\n+\n+         if Last_As_Int > Int (Index_Type'Last) then\n+            raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n          declare\n@@ -339,7 +356,7 @@ package body Ada.Containers.Indefinite_Vectors is\n    function \"&\" (Left, Right : Element_Type) return Vector is\n    begin\n       if Index_Type'First >= Index_Type'Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"new length is out of range\";\n       end if;\n \n       declare\n@@ -348,6 +365,7 @@ package body Ada.Containers.Indefinite_Vectors is\n          subtype ET is Elements_Type (Index_Type'First .. Last);\n \n          Elements : Elements_Access := new ET;\n+\n       begin\n          begin\n             Elements (Elements'First) := new Element_Type'(Left);\n@@ -445,7 +463,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Container.Last = Index_Type'Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"vector is already at its maximum length\";\n       end if;\n \n       Insert\n@@ -465,7 +483,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Container.Last = Index_Type'Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"vector is already at its maximum length\";\n       end if;\n \n       Insert\n@@ -495,7 +513,8 @@ package body Ada.Containers.Indefinite_Vectors is\n    procedure Clear (Container : in out Vector) is\n    begin\n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       while Container.Last >= Index_Type'First loop\n@@ -532,12 +551,12 @@ package body Ada.Containers.Indefinite_Vectors is\n    is\n    begin\n       if Index < Index_Type'First then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Index is out of range (too small)\";\n       end if;\n \n       if Index > Container.Last then\n          if Index > Container.Last + 1 then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"Index is out of range (too large)\";\n          end if;\n \n          return;\n@@ -548,14 +567,14 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       declare\n          Index_As_Int    : constant Int := Int (Index);\n          Old_Last_As_Int : constant Int := Int (Container.Last);\n \n-         --  TODO: somewhat vestigial...fix ???\n          Count1 : constant Int'Base := Int (Count);\n          Count2 : constant Int'Base := Old_Last_As_Int - Index_As_Int + 1;\n          N      : constant Int'Base := Int'Min (Count1, Count2);\n@@ -609,13 +628,15 @@ package body Ada.Containers.Indefinite_Vectors is\n    is\n    begin\n       if Position.Container = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unchecked_Access\n-        or else Position.Index > Container.Last\n-      then\n-         raise Program_Error;\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n+      end if;\n+\n+      if Position.Index > Container.Last then\n+         raise Program_Error with \"Position index is out of range\";\n       end if;\n \n       Delete (Container, Position.Index, Count);\n@@ -662,7 +683,8 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       declare\n@@ -693,15 +715,15 @@ package body Ada.Containers.Indefinite_Vectors is\n    is\n    begin\n       if Index > Container.Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n       declare\n          EA : constant Element_Access := Container.Elements (Index);\n \n       begin\n          if EA = null then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"element is empty\";\n          end if;\n \n          return EA.all;\n@@ -711,7 +733,7 @@ package body Ada.Containers.Indefinite_Vectors is\n    function Element (Position : Cursor) return Element_Type is\n    begin\n       if Position.Container = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       return Element (Position.Container.all, Position.Index);\n@@ -723,7 +745,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    procedure Finalize (Container : in out Vector) is\n    begin\n-      Clear (Container);\n+      Clear (Container);  --  Checks busy-bit\n \n       declare\n          X : Elements_Access := Container.Elements;\n@@ -743,11 +765,14 @@ package body Ada.Containers.Indefinite_Vectors is\n       Position  : Cursor := No_Element) return Cursor\n    is\n    begin\n-      if Position.Container /= null\n-        and then (Position.Container /= Container'Unchecked_Access\n-                    or else Position.Index > Container.Last)\n-      then\n-         raise Program_Error;\n+      if Position.Container /= null then\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Position cursor denotes wrong container\";\n+         end if;\n+\n+         if Position.Index > Container.Last then\n+            raise Program_Error with \"Position index is out of range\";\n+         end if;\n       end if;\n \n       for J in Position.Index .. Container.Last loop\n@@ -888,7 +913,8 @@ package body Ada.Containers.Indefinite_Vectors is\n          end if;\n \n          if Source.Busy > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with elements (vector is busy)\";\n          end if;\n \n          Target.Set_Length (Length (Target) + Length (Source));\n@@ -963,7 +989,8 @@ package body Ada.Containers.Indefinite_Vectors is\n          end if;\n \n          if Container.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (vector is locked)\";\n          end if;\n \n          Sort (Container.Elements (Index_Type'First .. Container.Last));\n@@ -996,20 +1023,25 @@ package body Ada.Containers.Indefinite_Vectors is\n    is\n       N : constant Int := Int (Count);\n \n+      First           : constant Int := Int (Index_Type'First);\n       New_Last_As_Int : Int'Base;\n       New_Last        : Index_Type;\n+      New_Length      : UInt;\n+      Max_Length      : constant UInt := UInt (Count_Type'Last);\n \n       Dst : Elements_Access;\n \n    begin\n       if Before < Index_Type'First then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Before index is out of range (too small)\";\n       end if;\n \n       if Before > Container.Last\n         and then Before > Container.Last + 1\n       then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Before index is out of range (too large)\";\n       end if;\n \n       if Count = 0 then\n@@ -1020,17 +1052,28 @@ package body Ada.Containers.Indefinite_Vectors is\n          Old_Last_As_Int : constant Int := Int (Container.Last);\n \n       begin\n+         if Old_Last_As_Int > Int'Last - N then  -- see a-convec.adb  ???\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n          New_Last_As_Int := Old_Last_As_Int + N;\n \n-         if New_Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+         if New_Last_As_Int > Int (Index_Type'Last) then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         New_Length := UInt (New_Last_As_Int - First + 1);\n+\n+         if New_Length > Max_Length then\n+            raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n          New_Last := Index_Type (New_Last_As_Int);\n       end;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       if Container.Elements = null then\n@@ -1050,6 +1093,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       if New_Last <= Container.Elements'Last then\n          declare\n             E : Elements_Type renames Container.Elements.all;\n+\n          begin\n             if Before <= Container.Last then\n                declare\n@@ -1058,16 +1102,18 @@ package body Ada.Containers.Indefinite_Vectors is\n \n                   Index : constant Index_Type := Index_Type (Index_As_Int);\n \n-                  J : Index_Type'Base := Before;\n+                  J : Index_Type'Base;\n \n                begin\n                   E (Index .. New_Last) := E (Before .. Container.Last);\n                   Container.Last := New_Last;\n \n+                  J := Before;\n                   while J < Index loop\n                      E (J) := new Element_Type'(New_Item);\n                      J := J + 1;\n                   end loop;\n+\n                exception\n                   when others =>\n                      E (J .. Index - 1) := (others => null);\n@@ -1086,35 +1132,40 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       declare\n-         First    : constant Int := Int (Index_Type'First);\n-         New_Size : constant Int'Base := New_Last_As_Int - First + 1;\n-         Size     : Int'Base := Int'Max (1, Container.Elements'Length);\n+         C, CC : UInt;\n \n       begin\n-         while Size < New_Size loop\n-            if Size > Int'Last / 2 then\n-               Size := Int'Last;\n+         C := UInt'Max (1, Container.Elements'Length);\n+         while C < New_Length loop\n+            if C > UInt'Last / 2 then\n+               C := UInt'Last;\n                exit;\n             end if;\n \n-            Size := 2 * Size;\n+            C := 2 * C;\n          end loop;\n \n-         --  TODO: The following calculations aren't quite right, since\n-         --  there will be overflow if Index_Type'Range is very large\n-         --  (e.g. this package is instantiated with a 64-bit integer).\n-         --  END TODO.\n+         if C > Max_Length then\n+            C := Max_Length;\n+         end if;\n \n-         declare\n-            Max_Size : constant Int'Base := Int (Index_Type'Last) - First + 1;\n-         begin\n-            if Size > Max_Size then\n-               Size := Max_Size;\n-            end if;\n-         end;\n+         if Index_Type'First <= 0\n+           and then Index_Type'Last >= 0\n+         then\n+            CC := UInt (Index_Type'Last) + UInt (-Index_Type'First) + 1;\n+\n+         else\n+            CC := UInt (Int (Index_Type'Last) - First + 1);\n+         end if;\n+\n+         if C > CC then\n+            C := CC;\n+         end if;\n \n          declare\n-            Dst_Last : constant Index_Type := Index_Type (First + Size - 1);\n+            Dst_Last : constant Index_Type :=\n+                         Index_Type (First + UInt'Pos (C) - Int'(1));\n+\n          begin\n             Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n          end;\n@@ -1172,13 +1223,15 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    begin\n       if Before < Index_Type'First then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Before index is out of range (too small)\";\n       end if;\n \n       if Before > Container.Last\n         and then Before > Container.Last + 1\n       then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Before index is out of range (too large)\";\n       end if;\n \n       if N = 0 then\n@@ -1268,7 +1321,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       if Before.Container /= null\n         and then Before.Container /= Container'Unchecked_Access\n       then\n-         raise Program_Error;\n+         raise Program_Error with \"Before cursor denotes wrong container\";\n       end if;\n \n       if Is_Empty (New_Item) then\n@@ -1279,7 +1332,8 @@ package body Ada.Containers.Indefinite_Vectors is\n         or else Before.Index > Container.Last\n       then\n          if Container.Last = Index_Type'Last then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n          end if;\n \n          Index := Container.Last + 1;\n@@ -1303,7 +1357,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       if Before.Container /= null\n         and then Before.Container /= Vector_Access'(Container'Unchecked_Access)\n       then\n-         raise Program_Error;\n+         raise Program_Error with \"Before cursor denotes wrong container\";\n       end if;\n \n       if Is_Empty (New_Item) then\n@@ -1322,7 +1376,8 @@ package body Ada.Containers.Indefinite_Vectors is\n         or else Before.Index > Container.Last\n       then\n          if Container.Last = Index_Type'Last then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n          end if;\n \n          Index := Container.Last + 1;\n@@ -1346,9 +1401,9 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    begin\n       if Before.Container /= null\n-        and then Before.Container /= Vector_Access'(Container'Unchecked_Access)\n+        and then Before.Container /= Container'Unchecked_Access\n       then\n-         raise Program_Error;\n+         raise Program_Error with \"Before cursor denotes wrong container\";\n       end if;\n \n       if Count = 0 then\n@@ -1359,7 +1414,8 @@ package body Ada.Containers.Indefinite_Vectors is\n         or else Before.Index > Container.Last\n       then\n          if Container.Last = Index_Type'Last then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n          end if;\n \n          Index := Container.Last + 1;\n@@ -1382,9 +1438,9 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    begin\n       if Before.Container /= null\n-        and then Before.Container /= Vector_Access'(Container'Unchecked_Access)\n+        and then Before.Container /= Container'Unchecked_Access\n       then\n-         raise Program_Error;\n+         raise Program_Error with \"Before cursor denotes wrong container\";\n       end if;\n \n       if Count = 0 then\n@@ -1403,7 +1459,8 @@ package body Ada.Containers.Indefinite_Vectors is\n         or else Before.Index > Container.Last\n       then\n          if Container.Last = Index_Type'Last then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n          end if;\n \n          Index := Container.Last + 1;\n@@ -1428,20 +1485,25 @@ package body Ada.Containers.Indefinite_Vectors is\n    is\n       N : constant Int := Int (Count);\n \n+      First           : constant Int := Int (Index_Type'First);\n       New_Last_As_Int : Int'Base;\n       New_Last        : Index_Type;\n+      New_Length      : UInt;\n+      Max_Length      : constant UInt := UInt (Count_Type'Last);\n \n       Dst : Elements_Access;\n \n    begin\n       if Before < Index_Type'First then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Before index is out of range (too small)\";\n       end if;\n \n       if Before > Container.Last\n         and then Before > Container.Last + 1\n       then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Before index is out of range (too large)\";\n       end if;\n \n       if Count = 0 then\n@@ -1452,17 +1514,28 @@ package body Ada.Containers.Indefinite_Vectors is\n          Old_Last_As_Int : constant Int := Int (Container.Last);\n \n       begin\n+         if Old_Last_As_Int > Int'Last - N then  -- see a-convec.adb  ???\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n          New_Last_As_Int := Old_Last_As_Int + N;\n \n-         if New_Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+         if New_Last_As_Int > Int (Index_Type'Last) then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         New_Length := UInt (New_Last_As_Int - First + 1);\n+\n+         if New_Length > Max_Length then\n+            raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n          New_Last := Index_Type (New_Last_As_Int);\n       end;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       if Container.Elements = null then\n@@ -1497,35 +1570,40 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       declare\n-         First    : constant Int := Int (Index_Type'First);\n-         New_Size : constant Int'Base := New_Last_As_Int - First + 1;\n-         Size     : Int'Base := Int'Max (1, Container.Elements'Length);\n+         C, CC : UInt;\n \n       begin\n-         while Size < New_Size loop\n-            if Size > Int'Last / 2 then\n-               Size := Int'Last;\n+         C := UInt'Max (1, Container.Elements'Length);\n+         while C < New_Length loop\n+            if C > UInt'Last / 2 then\n+               C := UInt'Last;\n                exit;\n             end if;\n \n-            Size := 2 * Size;\n+            C := 2 * C;\n          end loop;\n \n-         --  TODO: The following calculations aren't quite right, since\n-         --  there will be overflow if Index_Type'Range is very large\n-         --  (e.g. this package is instantiated with a 64-bit integer).\n-         --  END TODO.\n+         if C > Max_Length then\n+            C := Max_Length;\n+         end if;\n \n-         declare\n-            Max_Size : constant Int'Base := Int (Index_Type'Last) - First + 1;\n-         begin\n-            if Size > Max_Size then\n-               Size := Max_Size;\n-            end if;\n-         end;\n+         if Index_Type'First <= 0\n+           and then Index_Type'Last >= 0\n+         then\n+            CC := UInt (Index_Type'Last) + UInt (-Index_Type'First) + 1;\n+\n+         else\n+            CC := UInt (Int (Index_Type'Last) - First + 1);\n+         end if;\n+\n+         if C > CC then\n+            C := CC;\n+         end if;\n \n          declare\n-            Dst_Last : constant Index_Type := Index_Type (First + Size - 1);\n+            Dst_Last : constant Index_Type :=\n+                         Index_Type (First + UInt'Pos (C) - 1);\n+\n          begin\n             Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n          end;\n@@ -1570,9 +1648,9 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    begin\n       if Before.Container /= null\n-        and then Before.Container /= Vector_Access'(Container'Unchecked_Access)\n+        and then Before.Container /= Container'Unchecked_Access\n       then\n-         raise Program_Error;\n+         raise Program_Error with \"Before cursor denotes wrong container\";\n       end if;\n \n       if Count = 0 then\n@@ -1591,7 +1669,8 @@ package body Ada.Containers.Indefinite_Vectors is\n         or else Before.Index > Container.Last\n       then\n          if Container.Last = Index_Type'Last then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n          end if;\n \n          Index := Container.Last + 1;\n@@ -1682,10 +1761,6 @@ package body Ada.Containers.Indefinite_Vectors is\n       N : constant Int'Base := L - F + 1;\n \n    begin\n-      if N > Count_Type'Pos (Count_Type'Last) then\n-         raise Constraint_Error;\n-      end if;\n-\n       return Count_Type (N);\n    end Length;\n \n@@ -1703,10 +1778,11 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Source.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (Source is busy)\";\n       end if;\n \n-      Clear (Target);\n+      Clear (Target);  --  Checks busy-bit\n \n       declare\n          Target_Elements : constant Elements_Access := Target.Elements;\n@@ -1819,11 +1895,11 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    begin\n       if Index > Container.Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n       if V.Elements (Index) = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"element is null\";\n       end if;\n \n       B := B + 1;\n@@ -1848,7 +1924,7 @@ package body Ada.Containers.Indefinite_Vectors is\n    is\n    begin\n       if Position.Container = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       Query_Element (Position.Container.all, Position.Index, Process);\n@@ -1859,7 +1935,7 @@ package body Ada.Containers.Indefinite_Vectors is\n    ----------\n \n    procedure Read\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : out Vector)\n    is\n       Length : Count_Type'Base;\n@@ -1891,11 +1967,11 @@ package body Ada.Containers.Indefinite_Vectors is\n    end Read;\n \n    procedure Read\n-     (Stream   : access Root_Stream_Type'Class;\n+     (Stream   : not null access Root_Stream_Type'Class;\n       Position : out Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream vector cursor\";\n    end Read;\n \n    ---------------------\n@@ -1909,11 +1985,12 @@ package body Ada.Containers.Indefinite_Vectors is\n    is\n    begin\n       if Index > Container.Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n       if Container.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is locked)\";\n       end if;\n \n       declare\n@@ -1931,11 +2008,11 @@ package body Ada.Containers.Indefinite_Vectors is\n    is\n    begin\n       if Position.Container = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n \n       Replace_Element (Container, Position.Index, New_Item);\n@@ -1963,7 +2040,8 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          elsif N < Container.Elements'Length then\n             if Container.Busy > 0 then\n-               raise Program_Error;\n+               raise Program_Error with\n+                 \"attempt to tamper with elements (vector is busy)\";\n             end if;\n \n             declare\n@@ -1994,7 +2072,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          begin\n             if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-               raise Constraint_Error;\n+               raise Constraint_Error with \"new length is out of range\";\n             end if;\n \n             declare\n@@ -2014,7 +2092,8 @@ package body Ada.Containers.Indefinite_Vectors is\n       if Capacity <= N then\n          if N < Container.Elements'Length then\n             if Container.Busy > 0 then\n-               raise Program_Error;\n+               raise Program_Error with\n+                 \"attempt to tamper with elements (vector is busy)\";\n             end if;\n \n             declare\n@@ -2043,7 +2122,8 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       declare\n@@ -2052,7 +2132,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       begin\n          if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n          declare\n@@ -2093,15 +2173,18 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Container.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is locked)\";\n       end if;\n \n       declare\n-         I : Index_Type := Index_Type'First;\n-         J : Index_Type := Container.Last;\n+         I : Index_Type;\n+         J : Index_Type;\n          E : Elements_Type renames Container.Elements.all;\n \n       begin\n+         I := Index_Type'First;\n+         J := Container.Last;\n          while I < J loop\n             declare\n                EI : constant Element_Access := E (I);\n@@ -2132,7 +2215,7 @@ package body Ada.Containers.Indefinite_Vectors is\n       if Position.Container /= null\n         and then Position.Container /= Container'Unchecked_Access\n       then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n \n       if Position.Container = null\n@@ -2226,7 +2309,8 @@ package body Ada.Containers.Indefinite_Vectors is\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       if Length < N then\n@@ -2267,18 +2351,21 @@ package body Ada.Containers.Indefinite_Vectors is\n       I, J      : Index_Type)\n    is\n    begin\n-      if I > Container.Last\n-        or else J > Container.Last\n-      then\n-         raise Constraint_Error;\n+      if I > Container.Last then\n+         raise Constraint_Error with \"I index is out of range\";\n+      end if;\n+\n+      if J > Container.Last then\n+         raise Constraint_Error with \"J index is out of range\";\n       end if;\n \n       if I = J then\n          return;\n       end if;\n \n       if Container.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is locked)\";\n       end if;\n \n       declare\n@@ -2298,16 +2385,20 @@ package body Ada.Containers.Indefinite_Vectors is\n       I, J      : Cursor)\n    is\n    begin\n-      if I.Container = null\n-        or else J.Container = null\n-      then\n-         raise Constraint_Error;\n+      if I.Container = null then\n+         raise Constraint_Error with \"I cursor has no element\";\n       end if;\n \n-      if I.Container /= Container'Unrestricted_Access\n-        or else J.Container /= Container'Unrestricted_Access\n-      then\n-         raise Program_Error;\n+      if J.Container = null then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      if I.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"I cursor denotes wrong container\";\n+      end if;\n+\n+      if J.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"J cursor denotes wrong container\";\n       end if;\n \n       Swap (Container, I.Index, J.Index);\n@@ -2364,7 +2455,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       begin\n          if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n          Last := Index_Type (Last_As_Int);\n@@ -2391,7 +2482,7 @@ package body Ada.Containers.Indefinite_Vectors is\n \n       begin\n          if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n          Last := Index_Type (Last_As_Int);\n@@ -2433,11 +2524,11 @@ package body Ada.Containers.Indefinite_Vectors is\n \n    begin\n       if Index > Container.Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n       if Container.Elements (Index) = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"element is null\";\n       end if;\n \n       B := B + 1;\n@@ -2463,11 +2554,11 @@ package body Ada.Containers.Indefinite_Vectors is\n    is\n    begin\n       if Position.Container = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n \n       Update_Element (Container, Position.Index, Process);\n@@ -2478,7 +2569,7 @@ package body Ada.Containers.Indefinite_Vectors is\n    -----------\n \n    procedure Write\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : Vector)\n    is\n       N : constant Count_Type := Length (Container);\n@@ -2499,7 +2590,7 @@ package body Ada.Containers.Indefinite_Vectors is\n             --  There's another way to do this.  Instead a separate\n             --  Boolean for each element, you could write a Boolean\n             --  followed by a count of how many nulls or non-nulls\n-            --  follow in the array.\n+            --  follow in the array.  ???\n \n             if E (Indx) = null then\n                Boolean'Write (Stream, False);\n@@ -2512,11 +2603,11 @@ package body Ada.Containers.Indefinite_Vectors is\n    end Write;\n \n    procedure Write\n-     (Stream   : access Root_Stream_Type'Class;\n+     (Stream   : not null access Root_Stream_Type'Class;\n       Position : Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream vector cursor\";\n    end Write;\n \n end Ada.Containers.Indefinite_Vectors;"}, {"sha": "e5587f14625da369a4a876bb86c42983f43e5e7e", "filename": "gcc/ada/a-coinve.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc/gcc%2Fada%2Fa-coinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc/gcc%2Fada%2Fa-coinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.ads?ref=dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc", "patch": "@@ -324,13 +324,13 @@ private\n    use Ada.Streams;\n \n    procedure Write\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : Vector);\n \n    for Vector'Write use Write;\n \n    procedure Read\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : out Vector);\n \n    for Vector'Read use Read;\n@@ -346,13 +346,13 @@ private\n    end record;\n \n    procedure Write\n-     (Stream   : access Root_Stream_Type'Class;\n+     (Stream   : not null access Root_Stream_Type'Class;\n       Position : Cursor);\n \n    for Cursor'Write use Write;\n \n    procedure Read\n-     (Stream   : access Root_Stream_Type'Class;\n+     (Stream   : not null access Root_Stream_Type'Class;\n       Position : out Cursor);\n \n    for Cursor'Read use Read;"}, {"sha": "ecffd32b90c24088684e3c5c6ebc72dacf31d883", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 273, "deletions": 159, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2005 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2004-2006 Free Software Foundation, Inc.          --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -41,6 +41,7 @@ with System; use type System.Address;\n package body Ada.Containers.Vectors is\n \n    type Int is range System.Min_Int .. System.Max_Int;\n+   type UInt is mod System.Max_Binary_Modulus;\n \n    procedure Free is\n      new Ada.Unchecked_Deallocation (Elements_Type, Elements_Access);\n@@ -86,12 +87,18 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       declare\n-         Last_As_Int : constant Int'Base :=  -- TODO: handle overflow\n-                         Int (Index_Type'First) + Int (LN) + Int (RN) - 1;\n+         N           : constant Int'Base := Int (LN) + Int (RN);\n+         Last_As_Int : Int'Base;\n \n       begin\n-         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+         if Int (No_Index) > Int'Last - N then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         Last_As_Int := Int (No_Index) + N;\n+\n+         if Last_As_Int > Int (Index_Type'Last) then\n+            raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n          declare\n@@ -130,12 +137,17 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       declare\n-         Last_As_Int : constant Int'Base :=  -- TODO: handle overflow\n-                         Int (Index_Type'First) + Int (LN);\n+         Last_As_Int : Int'Base;\n \n       begin\n-         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+         if Int (Index_Type'First) > Int'Last - Int (LN) then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         Last_As_Int := Int (Index_Type'First) + Int (LN);\n+\n+         if Last_As_Int > Int (Index_Type'Last) then\n+            raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n          declare\n@@ -172,12 +184,17 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       declare\n-         Last_As_Int : constant Int'Base :=  -- TODO: handle overflow\n-                         Int (Index_Type'First) + Int (RN);\n+         Last_As_Int : Int'Base;\n \n       begin\n-         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+         if Int (Index_Type'First) > Int'Last - Int (RN) then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         Last_As_Int := Int (Index_Type'First) + Int (RN);\n+\n+         if Last_As_Int > Int (Index_Type'Last) then\n+            raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n          declare\n@@ -196,10 +213,10 @@ package body Ada.Containers.Vectors is\n       end;\n    end \"&\";\n \n-   function \"&\" (Left, Right  : Element_Type) return Vector is\n+   function \"&\" (Left, Right : Element_Type) return Vector is\n    begin\n       if Index_Type'First >= Index_Type'Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"new length is out of range\";\n       end if;\n \n       declare\n@@ -273,7 +290,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Container.Last = Index_Type'Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"vector is already at its maximum length\";\n       end if;\n \n       Insert\n@@ -293,7 +310,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Container.Last = Index_Type'Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"vector is already at its maximum length\";\n       end if;\n \n       Insert\n@@ -323,7 +340,8 @@ package body Ada.Containers.Vectors is\n    procedure Clear (Container : in out Vector) is\n    begin\n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       Container.Last := No_Index;\n@@ -352,12 +370,12 @@ package body Ada.Containers.Vectors is\n    is\n    begin\n       if Index < Index_Type'First then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Index is out of range (too small)\";\n       end if;\n \n       if Index > Container.Last then\n          if Index > Container.Last + 1 then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"Index is out of range (too large)\";\n          end if;\n \n          return;\n@@ -368,7 +386,8 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       declare\n@@ -409,13 +428,15 @@ package body Ada.Containers.Vectors is\n    is\n    begin\n       if Position.Container = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n-      if Position.Container /= Container'Unrestricted_Access\n-        or else Position.Index > Container.Last\n-      then\n-         raise Program_Error;\n+      if Position.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n+      end if;\n+\n+      if Position.Index > Container.Last then\n+         raise Program_Error with \"Position index is out of range\";\n       end if;\n \n       Delete (Container, Position.Index, Count);\n@@ -470,7 +491,8 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       Index := Int'Base (Container.Last) - Int'Base (Count);\n@@ -492,7 +514,7 @@ package body Ada.Containers.Vectors is\n    is\n    begin\n       if Index > Container.Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n       return Container.Elements (Index);\n@@ -501,7 +523,7 @@ package body Ada.Containers.Vectors is\n    function Element (Position : Cursor) return Element_Type is\n    begin\n       if Position.Container = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       return Element (Position.Container.all, Position.Index);\n@@ -516,7 +538,8 @@ package body Ada.Containers.Vectors is\n \n    begin\n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       Container.Elements := null;\n@@ -534,11 +557,14 @@ package body Ada.Containers.Vectors is\n       Position  : Cursor := No_Element) return Cursor\n    is\n    begin\n-      if Position.Container /= null\n-        and then (Position.Container /= Container'Unrestricted_Access\n-                    or else Position.Index > Container.Last)\n-      then\n-         raise Program_Error;\n+      if Position.Container /= null then\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Position cursor denotes wrong container\";\n+         end if;\n+\n+         if Position.Index > Container.Last then\n+            raise Program_Error with \"Position index is out of range\";\n+         end if;\n       end if;\n \n       for J in Position.Index .. Container.Last loop\n@@ -653,7 +679,8 @@ package body Ada.Containers.Vectors is\n          end if;\n \n          if Source.Busy > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with elements (vector is busy)\";\n          end if;\n \n          Target.Set_Length (Length (Target) + Length (Source));\n@@ -708,7 +735,8 @@ package body Ada.Containers.Vectors is\n          end if;\n \n          if Container.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (vector is locked)\";\n          end if;\n \n          Sort (Container.Elements (Index_Type'First .. Container.Last));\n@@ -741,43 +769,85 @@ package body Ada.Containers.Vectors is\n    is\n       N : constant Int := Count_Type'Pos (Count);\n \n+      First           : constant Int := Int (Index_Type'First);\n       New_Last_As_Int : Int'Base;\n       New_Last        : Index_Type;\n+      New_Length      : UInt;\n+      Max_Length      : constant UInt := UInt (Count_Type'Last);\n \n       Dst : Elements_Access;\n \n    begin\n       if Before < Index_Type'First then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Before index is out of range (too small)\";\n       end if;\n \n       if Before > Container.Last\n         and then Before > Container.Last + 1\n       then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Before index is out of range (too large)\";\n       end if;\n \n       if Count = 0 then\n          return;\n       end if;\n \n       declare\n-         Old_Last : constant Extended_Index := Container.Last;\n-\n-         Old_Last_As_Int : constant Int := Index_Type'Pos (Old_Last);\n+         Old_Last_As_Int : constant Int := Int (Container.Last);\n \n       begin\n+         if Old_Last_As_Int > Int'Last - N then\n+\n+            --  ???\n+\n+            --  The purpose of this test is to ensure that the calculation of\n+            --  New_Last_As_Int (see below) doesn't overflow.\n+\n+            --  This isn't quite right, since the only requirements are:\n+            --    V.Last <= Index_Type'Last\n+            --    V.Length <= Count_Type'Last\n+\n+            --  To be strictly correct there's no (explicit) requirement that\n+            --    Old_Last + N <= Int'Last\n+\n+            --  However, there might indeed be an implied requirement, since\n+            --  machine constraints dictate that\n+            --    Index_Type'Last <= Int'Last\n+            --  and so this check is perhaps proper after all.\n+\n+            --  This shouldn't be an issue in practice, since it can only\n+            --  happen when N is very large, or V.Last is near Int'Last.\n+\n+            --  N isn't likely to be large, since there's probably not enough\n+            --  storage.\n+\n+            --  V.Last would only be large if IT'First is very large (and\n+            --  V.Length has some \"normal\" size).  But typically IT'First is\n+            --  either 0 or 1.\n+\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n          New_Last_As_Int := Old_Last_As_Int + N;\n \n-         if New_Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+         if New_Last_As_Int > Int (Index_Type'Last) then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         New_Length := UInt (New_Last_As_Int - First + Int'(1));\n+\n+         if New_Length > Max_Length then\n+            raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n          New_Last := Index_Type (New_Last_As_Int);\n       end;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       if Container.Elements = null then\n@@ -795,6 +865,7 @@ package body Ada.Containers.Vectors is\n       if New_Last <= Container.Elements'Last then\n          declare\n             E : Elements_Type renames Container.Elements.all;\n+\n          begin\n             if Before <= Container.Last then\n                declare\n@@ -820,35 +891,40 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       declare\n-         First    : constant Int := Int (Index_Type'First);\n-         New_Size : constant Int'Base := New_Last_As_Int - First + 1;\n-         Size     : Int'Base := Int'Max (1, Container.Elements'Length);\n+         C, CC : UInt;\n \n       begin\n-         while Size < New_Size loop\n-            if Size > Int'Last / 2 then\n-               Size := Int'Last;\n+         C := UInt'Max (1, Container.Elements'Length);\n+         while C < New_Length loop\n+            if C > UInt'Last / 2 then\n+               C := UInt'Last;\n                exit;\n             end if;\n \n-            Size := 2 * Size;\n+            C := 2 * C;\n          end loop;\n \n-         --  TODO: The following calculations aren't quite right, since\n-         --  there will be overflow if Index_Type'Range is very large\n-         --  (e.g. this package is instantiated with a 64-bit integer).\n-         --  END TODO.\n+         if C > Max_Length then\n+            C := Max_Length;\n+         end if;\n \n-         declare\n-            Max_Size : constant Int'Base := Int (Index_Type'Last) - First + 1;\n-         begin\n-            if Size > Max_Size then\n-               Size := Max_Size;\n-            end if;\n-         end;\n+         if Index_Type'First <= 0\n+           and then Index_Type'Last >= 0\n+         then\n+            CC := UInt (Index_Type'Last) + UInt (-Index_Type'First) + 1;\n+\n+         else\n+            CC := UInt (Int (Index_Type'Last) - First + 1);\n+         end if;\n+\n+         if C > CC then\n+            C := CC;\n+         end if;\n \n          declare\n-            Dst_Last : constant Index_Type := Index_Type (First + Size - 1);\n+            Dst_Last : constant Index_Type :=\n+                         Index_Type (First + UInt'Pos (C) - 1);\n+\n          begin\n             Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n          end;\n@@ -900,13 +976,15 @@ package body Ada.Containers.Vectors is\n \n    begin\n       if Before < Index_Type'First then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Before index is out of range (too small)\";\n       end if;\n \n       if Before > Container.Last\n         and then Before > Container.Last + 1\n       then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Before index is out of range (too large)\";\n       end if;\n \n       if N = 0 then\n@@ -984,9 +1062,9 @@ package body Ada.Containers.Vectors is\n \n    begin\n       if Before.Container /= null\n-        and then Before.Container /= Vector_Access'(Container'Unchecked_Access)\n+        and then Before.Container /= Container'Unchecked_Access\n       then\n-         raise Program_Error;\n+         raise Program_Error with \"Before cursor denotes wrong container\";\n       end if;\n \n       if Is_Empty (New_Item) then\n@@ -997,7 +1075,8 @@ package body Ada.Containers.Vectors is\n         or else Before.Index > Container.Last\n       then\n          if Container.Last = Index_Type'Last then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n          end if;\n \n          Index := Container.Last + 1;\n@@ -1019,9 +1098,9 @@ package body Ada.Containers.Vectors is\n \n    begin\n       if Before.Container /= null\n-        and then Before.Container /= Vector_Access'(Container'Unchecked_Access)\n+        and then Before.Container /= Container'Unchecked_Access\n       then\n-         raise Program_Error;\n+         raise Program_Error with \"Before cursor denotes wrong container\";\n       end if;\n \n       if Is_Empty (New_Item) then\n@@ -1040,7 +1119,8 @@ package body Ada.Containers.Vectors is\n         or else Before.Index > Container.Last\n       then\n          if Container.Last = Index_Type'Last then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n          end if;\n \n          Index := Container.Last + 1;\n@@ -1064,9 +1144,9 @@ package body Ada.Containers.Vectors is\n \n    begin\n       if Before.Container /= null\n-        and then Before.Container /= Vector_Access'(Container'Unchecked_Access)\n+        and then Before.Container /= Container'Unchecked_Access\n       then\n-         raise Program_Error;\n+         raise Program_Error with \"Before cursor denotes wrong container\";\n       end if;\n \n       if Count = 0 then\n@@ -1077,7 +1157,8 @@ package body Ada.Containers.Vectors is\n         or else Before.Index > Container.Last\n       then\n          if Container.Last = Index_Type'Last then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n          end if;\n \n          Index := Container.Last + 1;\n@@ -1100,9 +1181,9 @@ package body Ada.Containers.Vectors is\n \n    begin\n       if Before.Container /= null\n-        and then Before.Container /= Vector_Access'(Container'Unchecked_Access)\n+        and then Before.Container /= Container'Unchecked_Access\n       then\n-         raise Program_Error;\n+         raise Program_Error with \"Before cursor denotes wrong container\";\n       end if;\n \n       if Count = 0 then\n@@ -1121,7 +1202,8 @@ package body Ada.Containers.Vectors is\n         or else Before.Index > Container.Last\n       then\n          if Container.Last = Index_Type'Last then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n          end if;\n \n          Index := Container.Last + 1;\n@@ -1171,43 +1253,57 @@ package body Ada.Containers.Vectors is\n    is\n       N : constant Int := Count_Type'Pos (Count);\n \n+      First           : constant Int := Int (Index_Type'First);\n       New_Last_As_Int : Int'Base;\n       New_Last        : Index_Type;\n+      New_Length      : UInt;\n+      Max_Length      : constant UInt := UInt (Count_Type'Last);\n \n       Dst : Elements_Access;\n \n    begin\n       if Before < Index_Type'First then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Before index is out of range (too small)\";\n       end if;\n \n       if Before > Container.Last\n         and then Before > Container.Last + 1\n       then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Before index is out of range (too large)\";\n       end if;\n \n       if Count = 0 then\n          return;\n       end if;\n \n       declare\n-         Old_Last : constant Extended_Index := Container.Last;\n-\n-         Old_Last_As_Int : constant Int := Index_Type'Pos (Old_Last);\n+         Old_Last_As_Int : constant Int := Int (Container.Last);\n \n       begin\n+         if Old_Last_As_Int > Int'Last - N then  -- see Insert ???\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n          New_Last_As_Int := Old_Last_As_Int + N;\n \n-         if New_Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+         if New_Last_As_Int > Int (Index_Type'Last) then\n+            raise Constraint_Error with \"new length is out of range\";\n+         end if;\n+\n+         New_Length := UInt (New_Last_As_Int - First + Int'(1));\n+\n+         if New_Length > Max_Length then\n+            raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n          New_Last := Index_Type (New_Last_As_Int);\n       end;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       if Container.Elements = null then\n@@ -1240,35 +1336,40 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       declare\n-         First    : constant Int := Int (Index_Type'First);\n-         New_Size : constant Int'Base := New_Last_As_Int - First + 1;\n-         Size     : Int'Base := Int'Max (1, Container.Elements'Length);\n+         C, CC : UInt;\n \n       begin\n-         while Size < New_Size loop\n-            if Size > Int'Last / 2 then\n-               Size := Int'Last;\n+         C := UInt'Max (1, Container.Elements'Length);\n+         while C < New_Length loop\n+            if C > UInt'Last / 2 then\n+               C := UInt'Last;\n                exit;\n             end if;\n \n-            Size := 2 * Size;\n+            C := 2 * C;\n          end loop;\n \n-         --  TODO: The following calculations aren't quite right, since\n-         --  there will be overflow if Index_Type'Range is very large\n-         --  (e.g. this package is instantiated with a 64-bit integer).\n-         --  END TODO.\n+         if C > Max_Length then\n+            C := Max_Length;\n+         end if;\n \n-         declare\n-            Max_Size : constant Int'Base := Int (Index_Type'Last) - First + 1;\n-         begin\n-            if Size > Max_Size then\n-               Size := Max_Size;\n-            end if;\n-         end;\n+         if Index_Type'First <= 0\n+           and then Index_Type'Last >= 0\n+         then\n+            CC := UInt (Index_Type'Last) + UInt (-Index_Type'First) + 1;\n+\n+         else\n+            CC := UInt (Int (Index_Type'Last) - First + 1);\n+         end if;\n+\n+         if C > CC then\n+            C := CC;\n+         end if;\n \n          declare\n-            Dst_Last : constant Index_Type := Index_Type (First + Size - 1);\n+            Dst_Last : constant Index_Type :=\n+                         Index_Type (First + UInt'Pos (C) - 1);\n+\n          begin\n             Dst := new Elements_Type (Index_Type'First .. Dst_Last);\n          end;\n@@ -1317,9 +1418,9 @@ package body Ada.Containers.Vectors is\n \n    begin\n       if Before.Container /= null\n-        and then Before.Container /= Vector_Access'(Container'Unchecked_Access)\n+        and then Before.Container /= Container'Unchecked_Access\n       then\n-         raise Program_Error;\n+         raise Program_Error with \"Before cursor denotes wrong container\";\n       end if;\n \n       if Count = 0 then\n@@ -1338,7 +1439,8 @@ package body Ada.Containers.Vectors is\n         or else Before.Index > Container.Last\n       then\n          if Container.Last = Index_Type'Last then\n-            raise Constraint_Error;\n+            raise Constraint_Error with\n+              \"vector is already at its maximum length\";\n          end if;\n \n          Index := Container.Last + 1;\n@@ -1429,10 +1531,6 @@ package body Ada.Containers.Vectors is\n       N : constant Int'Base := L - F + 1;\n \n    begin\n-      if N > Count_Type'Pos (Count_Type'Last) then\n-         raise Constraint_Error;\n-      end if;\n-\n       return Count_Type (N);\n    end Length;\n \n@@ -1450,11 +1548,13 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Target.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (Target is busy)\";\n       end if;\n \n       if Source.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (Source is busy)\";\n       end if;\n \n       declare\n@@ -1568,7 +1668,7 @@ package body Ada.Containers.Vectors is\n \n    begin\n       if Index > Container.Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n       B := B + 1;\n@@ -1593,7 +1693,7 @@ package body Ada.Containers.Vectors is\n    is\n    begin\n       if Position.Container = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       Query_Element (Position.Container.all, Position.Index, Process);\n@@ -1604,7 +1704,7 @@ package body Ada.Containers.Vectors is\n    ----------\n \n    procedure Read\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : out Vector)\n    is\n       Length : Count_Type'Base;\n@@ -1627,11 +1727,11 @@ package body Ada.Containers.Vectors is\n    end Read;\n \n    procedure Read\n-     (Stream   : access Root_Stream_Type'Class;\n+     (Stream   : not null access Root_Stream_Type'Class;\n       Position : out Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream vector cursor\";\n    end Read;\n \n    ---------------------\n@@ -1645,11 +1745,12 @@ package body Ada.Containers.Vectors is\n    is\n    begin\n       if Index > Container.Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n       if Container.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is locked)\";\n       end if;\n \n       Container.Elements (Index) := New_Item;\n@@ -1662,11 +1763,11 @@ package body Ada.Containers.Vectors is\n    is\n    begin\n       if Position.Container = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n \n       Replace_Element (Container, Position.Index, New_Item);\n@@ -1694,7 +1795,8 @@ package body Ada.Containers.Vectors is\n \n          elsif N < Container.Elements'Length then\n             if Container.Busy > 0 then\n-               raise Program_Error;\n+               raise Program_Error with\n+                 \"attempt to tamper with elements (vector is busy)\";\n             end if;\n \n             declare\n@@ -1725,14 +1827,15 @@ package body Ada.Containers.Vectors is\n \n          begin\n             if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-               raise Constraint_Error;\n+               raise Constraint_Error with \"new length is out of range\";\n             end if;\n \n             declare\n                Last : constant Index_Type := Index_Type (Last_As_Int);\n \n                subtype Array_Subtype is\n                  Elements_Type (Index_Type'First .. Last);\n+\n             begin\n                Container.Elements := new Array_Subtype;\n             end;\n@@ -1744,7 +1847,8 @@ package body Ada.Containers.Vectors is\n       if Capacity <= N then\n          if N < Container.Elements'Length then\n             if Container.Busy > 0 then\n-               raise Program_Error;\n+               raise Program_Error with\n+                 \"attempt to tamper with elements (vector is busy)\";\n             end if;\n \n             declare\n@@ -1774,7 +1878,8 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       declare\n@@ -1783,7 +1888,7 @@ package body Ada.Containers.Vectors is\n \n       begin\n          if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"new length is out of range\";\n          end if;\n \n          declare\n@@ -1832,15 +1937,17 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Container.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is locked)\";\n       end if;\n \n       declare\n-         I : Index_Type := Index_Type'First;\n-         J : Index_Type := Container.Last;\n-         E : Elements_Type renames Container.Elements.all;\n+         I, J : Index_Type;\n+         E    : Elements_Type renames Container.Elements.all;\n \n       begin\n+         I := Index_Type'First;\n+         J := Container.Last;\n          while I < J loop\n             declare\n                EI : constant Element_Type := E (I);\n@@ -1869,10 +1976,9 @@ package body Ada.Containers.Vectors is\n \n    begin\n       if Position.Container /= null\n-        and then Position.Container /=\n-                   Vector_Access'(Container'Unchecked_Access)\n+        and then Position.Container /= Container'Unchecked_Access\n       then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n \n       if Position.Container = null\n@@ -1957,7 +2063,8 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Container.Busy > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with elements (vector is busy)\";\n       end if;\n \n       if Length > Capacity (Container) then\n@@ -1978,18 +2085,21 @@ package body Ada.Containers.Vectors is\n \n    procedure Swap (Container : in out Vector; I, J : Index_Type) is\n    begin\n-      if I > Container.Last\n-        or else J > Container.Last\n-      then\n-         raise Constraint_Error;\n+      if I > Container.Last then\n+         raise Constraint_Error with \"I index is out of range\";\n+      end if;\n+\n+      if J > Container.Last then\n+         raise Constraint_Error with \"J index is out of range\";\n       end if;\n \n       if I = J then\n          return;\n       end if;\n \n       if Container.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (vector is locked)\";\n       end if;\n \n       declare\n@@ -2006,16 +2116,20 @@ package body Ada.Containers.Vectors is\n \n    procedure Swap (Container : in out Vector; I, J : Cursor) is\n    begin\n-      if I.Container = null\n-        or else J.Container = null\n-      then\n-         raise Constraint_Error;\n+      if I.Container = null then\n+         raise Constraint_Error with \"I cursor has no element\";\n       end if;\n \n-      if I.Container /= Container'Unrestricted_Access\n-        or else J.Container /= Container'Unrestricted_Access\n-      then\n-         raise Program_Error;\n+      if J.Container = null then\n+         raise Constraint_Error with \"J cursor has no element\";\n+      end if;\n+\n+      if I.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"I cursor denotes wrong container\";\n+      end if;\n+\n+      if J.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with \"J cursor denotes wrong container\";\n       end if;\n \n       Swap (Container, I.Index, J.Index);\n@@ -2072,13 +2186,13 @@ package body Ada.Containers.Vectors is\n \n       begin\n          if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n          Last := Index_Type (Last_As_Int);\n          Elements := new Elements_Type (Index_Type'First .. Last);\n \n-         return (Controlled with Elements, Last, 0, 0);\n+         return Vector'(Controlled with Elements, Last, 0, 0);\n       end;\n    end To_Vector;\n \n@@ -2099,13 +2213,13 @@ package body Ada.Containers.Vectors is\n \n       begin\n          if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error;\n+            raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n          Last := Index_Type (Last_As_Int);\n          Elements := new Elements_Type'(Index_Type'First .. Last => New_Item);\n \n-         return (Controlled with Elements, Last, 0, 0);\n+         return Vector'(Controlled with Elements, Last, 0, 0);\n       end;\n    end To_Vector;\n \n@@ -2123,7 +2237,7 @@ package body Ada.Containers.Vectors is\n \n    begin\n       if Index > Container.Last then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n       B := B + 1;\n@@ -2149,11 +2263,11 @@ package body Ada.Containers.Vectors is\n    is\n    begin\n       if Position.Container = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor denotes wrong container\";\n       end if;\n \n       Update_Element (Container, Position.Index, Process);\n@@ -2164,7 +2278,7 @@ package body Ada.Containers.Vectors is\n    -----------\n \n    procedure Write\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : Vector)\n    is\n    begin\n@@ -2176,11 +2290,11 @@ package body Ada.Containers.Vectors is\n    end Write;\n \n    procedure Write\n-     (Stream   : access Root_Stream_Type'Class;\n+     (Stream   : not null access Root_Stream_Type'Class;\n       Position : Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream vector cursor\";\n    end Write;\n \n end Ada.Containers.Vectors;"}, {"sha": "4fa0281d41c72d7d4e91bd29c1587073a8c25cd4", "filename": "gcc/ada/a-convec.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc/gcc%2Fada%2Fa-convec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc/gcc%2Fada%2Fa-convec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.ads?ref=dc6b9ba2d18ecc4b22e1a23002cea7681d8786bc", "patch": "@@ -332,13 +332,13 @@ private\n    use Ada.Streams;\n \n    procedure Write\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : Vector);\n \n    for Vector'Write use Write;\n \n    procedure Read\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : out Vector);\n \n    for Vector'Read use Read;\n@@ -354,13 +354,13 @@ private\n    end record;\n \n    procedure Write\n-     (Stream   : access Root_Stream_Type'Class;\n+     (Stream   : not null access Root_Stream_Type'Class;\n       Position : Cursor);\n \n    for Cursor'Write use Write;\n \n    procedure Read\n-     (Stream   : access Root_Stream_Type'Class;\n+     (Stream   : not null access Root_Stream_Type'Class;\n       Position : out Cursor);\n \n    for Cursor'Read use Read;"}]}