{"sha": "95fe7b4862dd3250e4d6b3e2c592b440b79613df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVmZTdiNDg2MmRkMzI1MGU0ZDZiM2UyYzU5MmI0NDBiNzk2MTNkZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:18:58Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:18:58Z"}, "message": "poly_int: load_register_parameters\n\nThis patch makes load_register_parameters cope with polynomial sizes.\nThe requirement here is that any register parameters with non-constant\nsizes must either have a specific mode (e.g. a variable-length vector\nmode) or must be represented with a PARALLEL.  This is in practice\nalready a requirement for parameters passed in vector registers,\nsince the default behaviour of splitting parameters into words doesn't\nmake sense for them.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* calls.c (load_register_parameters): Cope with polynomial\n\tmode sizes.  Require a constant size for BLKmode parameters\n\tthat aren't described by a PARALLEL.  If BLOCK_REG_PADDING\n\tforces a parameter to be padded at the lsb end in order to\n\tfill a complete number of words, require the parameter size\n\tto be ordered wrt UNITS_PER_WORD.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256161", "tree": {"sha": "db778275dcf12ad7f9ab92a142ef391730b0c51d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db778275dcf12ad7f9ab92a142ef391730b0c51d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95fe7b4862dd3250e4d6b3e2c592b440b79613df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95fe7b4862dd3250e4d6b3e2c592b440b79613df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95fe7b4862dd3250e4d6b3e2c592b440b79613df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95fe7b4862dd3250e4d6b3e2c592b440b79613df/comments", "author": null, "committer": null, "parents": [{"sha": "cff7107a97be6b32efc4c100ed85957c7e0b331e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cff7107a97be6b32efc4c100ed85957c7e0b331e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cff7107a97be6b32efc4c100ed85957c7e0b331e"}], "stats": {"total": 71, "additions": 48, "deletions": 23}, "files": [{"sha": "4fb5f441662a0a9e62a7dc260cf585d9446c43ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95fe7b4862dd3250e4d6b3e2c592b440b79613df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95fe7b4862dd3250e4d6b3e2c592b440b79613df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95fe7b4862dd3250e4d6b3e2c592b440b79613df", "patch": "@@ -1,3 +1,14 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* calls.c (load_register_parameters): Cope with polynomial\n+\tmode sizes.  Require a constant size for BLKmode parameters\n+\tthat aren't described by a PARALLEL.  If BLOCK_REG_PADDING\n+\tforces a parameter to be padded at the lsb end in order to\n+\tfill a complete number of words, require the parameter size\n+\tto be ordered wrt UNITS_PER_WORD.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "916ef745ba2face633c9bc7973fdc6276ffe7b2e", "filename": "gcc/calls.c", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95fe7b4862dd3250e4d6b3e2c592b440b79613df/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95fe7b4862dd3250e4d6b3e2c592b440b79613df/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=95fe7b4862dd3250e4d6b3e2c592b440b79613df", "patch": "@@ -2709,7 +2709,8 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t{\n \t  int partial = args[i].partial;\n \t  int nregs;\n-\t  int size = 0;\n+\t  poly_int64 size = 0;\n+\t  HOST_WIDE_INT const_size = 0;\n \t  rtx_insn *before_arg = get_last_insn ();\n \t  /* Set non-negative if we must move a word at a time, even if\n \t     just one word (e.g, partial == 4 && mode == DFmode).  Set\n@@ -2725,8 +2726,12 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t    }\n \t  else if (TYPE_MODE (TREE_TYPE (args[i].tree_value)) == BLKmode)\n \t    {\n-\t      size = int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n-\t      nregs = (size + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n+\t      /* Variable-sized parameters should be described by a\n+\t\t PARALLEL instead.  */\n+\t      const_size = int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n+\t      gcc_assert (const_size >= 0);\n+\t      nregs = (const_size + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n+\t      size = const_size;\n \t    }\n \t  else\n \t    size = GET_MODE_SIZE (args[i].mode);\n@@ -2748,21 +2753,27 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t      /* Handle case where we have a value that needs shifting\n \t\t up to the msb.  eg. a QImode value and we're padding\n \t\t upward on a BYTES_BIG_ENDIAN machine.  */\n-\t      if (size < UNITS_PER_WORD\n-\t\t  && (args[i].locate.where_pad\n-\t\t      == (BYTES_BIG_ENDIAN ? PAD_UPWARD : PAD_DOWNWARD)))\n+\t      if (args[i].locate.where_pad\n+\t\t  == (BYTES_BIG_ENDIAN ? PAD_UPWARD : PAD_DOWNWARD))\n \t\t{\n-\t\t  rtx x;\n-\t\t  int shift = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n-\n-\t\t  /* Assigning REG here rather than a temp makes CALL_FUSAGE\n-\t\t     report the whole reg as used.  Strictly speaking, the\n-\t\t     call only uses SIZE bytes at the msb end, but it doesn't\n-\t\t     seem worth generating rtl to say that.  */\n-\t\t  reg = gen_rtx_REG (word_mode, REGNO (reg));\n-\t\t  x = expand_shift (LSHIFT_EXPR, word_mode, reg, shift, reg, 1);\n-\t\t  if (x != reg)\n-\t\t    emit_move_insn (reg, x);\n+\t\t  gcc_checking_assert (ordered_p (size, UNITS_PER_WORD));\n+\t\t  if (maybe_lt (size, UNITS_PER_WORD))\n+\t\t    {\n+\t\t      rtx x;\n+\t\t      poly_int64 shift\n+\t\t\t= (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n+\n+\t\t      /* Assigning REG here rather than a temp makes\n+\t\t\t CALL_FUSAGE report the whole reg as used.\n+\t\t\t Strictly speaking, the call only uses SIZE\n+\t\t\t bytes at the msb end, but it doesn't seem worth\n+\t\t\t generating rtl to say that.  */\n+\t\t      reg = gen_rtx_REG (word_mode, REGNO (reg));\n+\t\t      x = expand_shift (LSHIFT_EXPR, word_mode,\n+\t\t\t\t\treg, shift, reg, 1);\n+\t\t      if (x != reg)\n+\t\t\temit_move_insn (reg, x);\n+\t\t    }\n \t\t}\n #endif\n \t    }\n@@ -2777,17 +2788,20 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \n \t  else if (partial == 0 || args[i].pass_on_stack)\n \t    {\n+\t      /* SIZE and CONST_SIZE are 0 for partial arguments and\n+\t\t the size of a BLKmode type otherwise.  */\n+\t      gcc_checking_assert (known_eq (size, const_size));\n \t      rtx mem = validize_mem (copy_rtx (args[i].value));\n \n \t      /* Check for overlap with already clobbered argument area,\n \t         providing that this has non-zero size.  */\n \t      if (is_sibcall\n-\t\t  && size != 0\n+\t\t  && const_size != 0\n \t\t  && (mem_might_overlap_already_clobbered_arg_p\n-\t\t      (XEXP (args[i].value, 0), size)))\n+\t\t      (XEXP (args[i].value, 0), const_size)))\n \t\t*sibcall_failure = 1;\n \n-\t      if (size % UNITS_PER_WORD == 0\n+\t      if (const_size % UNITS_PER_WORD == 0\n \t\t  || MEM_ALIGN (mem) % BITS_PER_WORD == 0)\n \t\tmove_block_to_reg (REGNO (reg), mem, nregs, args[i].mode);\n \t      else\n@@ -2797,7 +2811,7 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t\t\t\t       args[i].mode);\n \t\t  rtx dest = gen_rtx_REG (word_mode, REGNO (reg) + nregs - 1);\n \t\t  unsigned int bitoff = (nregs - 1) * BITS_PER_WORD;\n-\t\t  unsigned int bitsize = size * BITS_PER_UNIT - bitoff;\n+\t\t  unsigned int bitsize = const_size * BITS_PER_UNIT - bitoff;\n \t\t  rtx x = extract_bit_field (mem, bitsize, bitoff, 1, dest,\n \t\t\t\t\t     word_mode, word_mode, false,\n \t\t\t\t\t     NULL);\n@@ -2809,7 +2823,7 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t\t}\n \n \t      /* Handle a BLKmode that needs shifting.  */\n-\t      if (nregs == 1 && size < UNITS_PER_WORD\n+\t      if (nregs == 1 && const_size < UNITS_PER_WORD\n #ifdef BLOCK_REG_PADDING\n \t\t  && args[i].locate.where_pad == PAD_DOWNWARD\n #else\n@@ -2818,7 +2832,7 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t\t  )\n \t\t{\n \t\t  rtx dest = gen_rtx_REG (word_mode, REGNO (reg));\n-\t\t  int shift = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n+\t\t  int shift = (UNITS_PER_WORD - const_size) * BITS_PER_UNIT;\n \t\t  enum tree_code dir = (BYTES_BIG_ENDIAN\n \t\t\t\t\t? RSHIFT_EXPR : LSHIFT_EXPR);\n \t\t  rtx x;"}]}