{"sha": "f7e94dfb68d48b936044f7a631540e83b4a8b163", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdlOTRkZmI2OGQ0OGI5MzYwNDRmN2E2MzE1NDBlODNiNGE4YjE2Mw==", "commit": {"author": {"name": "Aaron Sawdey", "email": "acsawdey@linux.ibm.com", "date": "2018-06-19T21:23:39Z"}, "committer": {"name": "Aaron Sawdey", "email": "acsawdey@gcc.gnu.org", "date": "2018-06-19T21:23:39Z"}, "message": "rs6000-string.c (select_block_compare_mode): Check TARGET_EFFICIENT_OVERLAPPING_UNALIGNED here instead of in caller.\n\n2018-06-19  Aaron Sawdey  <acsawdey@linux.ibm.com>\n\n\t* config/rs6000/rs6000-string.c (select_block_compare_mode): Check\n\tTARGET_EFFICIENT_OVERLAPPING_UNALIGNED here instead of in caller.\n\t(do_and3, do_and3_mask, do_compb3, do_rotl3): New functions.\n\t(expand_block_compare): Change select_block_compare_mode call.\n\t(expand_strncmp_align_check): Use new functions, fix comment.\n\t(emit_final_str_compare_gpr): New function.\n\t(expand_strn_compare): Refactor and clean up code.\n\t* config/rs6000/vsx.md (vsx_mov<mode>_64bit): Remove *.\n\nFrom-SVN: r261769", "tree": {"sha": "b696a4b46aa5ccc48d9ff9da5f3daabee1b357e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b696a4b46aa5ccc48d9ff9da5f3daabee1b357e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7e94dfb68d48b936044f7a631540e83b4a8b163", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7e94dfb68d48b936044f7a631540e83b4a8b163", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7e94dfb68d48b936044f7a631540e83b4a8b163", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7e94dfb68d48b936044f7a631540e83b4a8b163/comments", "author": {"login": "acsawdey", "id": 41373646, "node_id": "MDQ6VXNlcjQxMzczNjQ2", "avatar_url": "https://avatars.githubusercontent.com/u/41373646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/acsawdey", "html_url": "https://github.com/acsawdey", "followers_url": "https://api.github.com/users/acsawdey/followers", "following_url": "https://api.github.com/users/acsawdey/following{/other_user}", "gists_url": "https://api.github.com/users/acsawdey/gists{/gist_id}", "starred_url": "https://api.github.com/users/acsawdey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/acsawdey/subscriptions", "organizations_url": "https://api.github.com/users/acsawdey/orgs", "repos_url": "https://api.github.com/users/acsawdey/repos", "events_url": "https://api.github.com/users/acsawdey/events{/privacy}", "received_events_url": "https://api.github.com/users/acsawdey/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a513e2a1b446a2aa7accec36ac055935e9d6491", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a513e2a1b446a2aa7accec36ac055935e9d6491", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a513e2a1b446a2aa7accec36ac055935e9d6491"}], "stats": {"total": 375, "additions": 185, "deletions": 190}, "files": [{"sha": "cc607eb9700777087912bae3b743c5986897377c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e94dfb68d48b936044f7a631540e83b4a8b163/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e94dfb68d48b936044f7a631540e83b4a8b163/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7e94dfb68d48b936044f7a631540e83b4a8b163", "patch": "@@ -1,3 +1,14 @@\n+2018-06-19  Aaron Sawdey  <acsawdey@linux.ibm.com>\n+\n+\t* config/rs6000/rs6000-string.c (select_block_compare_mode): Check\n+\tTARGET_EFFICIENT_OVERLAPPING_UNALIGNED here instead of in caller.\n+\t(do_and3, do_and3_mask, do_compb3, do_rotl3): New functions.\n+\t(expand_block_compare): Change select_block_compare_mode call.\n+\t(expand_strncmp_align_check): Use new functions, fix comment.\n+\t(emit_final_str_compare_gpr): New function.\n+\t(expand_strn_compare): Refactor and clean up code.\n+\t* config/rs6000/vsx.md (vsx_mov<mode>_64bit): Remove *.\n+\n 2018-06-19  Tony Reix  <tony.reix@atos.com>\n \t    Damien Bergamini  <damien.bergamini@atos.com>\n \t    David Edelsohn  <dje.gcc@gmail.com>"}, {"sha": "8d9afc41b8f48108f84f04d5994b6bf902e935df", "filename": "gcc/config/rs6000/rs6000-string.c", "status": "modified", "additions": 173, "deletions": 189, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e94dfb68d48b936044f7a631540e83b4a8b163/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e94dfb68d48b936044f7a631540e83b4a8b163/gcc%2Fconfig%2Frs6000%2Frs6000-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-string.c?ref=f7e94dfb68d48b936044f7a631540e83b4a8b163", "patch": "@@ -264,13 +264,15 @@ select_block_compare_mode (unsigned HOST_WIDE_INT offset,\n   else if (bytes == GET_MODE_SIZE (QImode))\n     return QImode;\n   else if (bytes < GET_MODE_SIZE (SImode)\n+\t   && TARGET_EFFICIENT_OVERLAPPING_UNALIGNED\n \t   && offset >= GET_MODE_SIZE (SImode) - bytes)\n     /* This matches the case were we have SImode and 3 bytes\n        and offset >= 1 and permits us to move back one and overlap\n        with the previous read, thus avoiding having to shift\n        unwanted bytes off of the input.  */\n     return SImode;\n   else if (word_mode_ok && bytes < UNITS_PER_WORD\n+\t   && TARGET_EFFICIENT_OVERLAPPING_UNALIGNED\n \t   && offset >= UNITS_PER_WORD-bytes)\n     /* Similarly, if we can use DImode it will get matched here and\n        can do an overlapping read that ends at the end of the block.  */\n@@ -406,6 +408,54 @@ do_add3 (rtx dest, rtx src1, rtx src2)\n     emit_insn (gen_addsi3 (dest, src1, src2));\n }\n \n+/* Emit an and of the proper mode for DEST.\n+\n+   DEST is the destination register for the and.\n+   SRC1 is the first and input.\n+   SRC2 is the second and input.\n+\n+   Computes DEST = SRC1&SRC2.  */\n+static void\n+do_and3 (rtx dest, rtx src1, rtx src2)\n+{\n+  if (GET_MODE (dest) == DImode)\n+    emit_insn (gen_anddi3 (dest, src1, src2));\n+  else\n+    emit_insn (gen_andsi3 (dest, src1, src2));\n+}\n+\n+/* Emit an cmpb of the proper mode for DEST.\n+\n+   DEST is the destination register for the cmpb.\n+   SRC1 is the first input.\n+   SRC2 is the second input.\n+\n+   Computes cmpb of SRC1, SRC2.  */\n+static void\n+do_cmpb3 (rtx dest, rtx src1, rtx src2)\n+{\n+  if (GET_MODE (dest) == DImode)\n+    emit_insn (gen_cmpbdi3 (dest, src1, src2));\n+  else\n+    emit_insn (gen_cmpbsi3 (dest, src1, src2));\n+}\n+\n+/* Emit a rotl of the proper mode for DEST.\n+\n+   DEST is the destination register for the and.\n+   SRC1 is the first and input.\n+   SRC2 is the second and input.\n+\n+   Computes DEST = SRC1 rotated left by SRC2.  */\n+static void\n+do_rotl3 (rtx dest, rtx src1, rtx src2)\n+{\n+  if (GET_MODE (dest) == DImode)\n+    emit_insn (gen_rotldi3 (dest, src1, src2));\n+  else\n+    emit_insn (gen_rotlsi3 (dest, src1, src2));\n+}\n+\n /* Generate rtl for a load, shift, and compare of less than a full word.\n \n    LOAD_MODE is the machine mode for the loads.\n@@ -1393,11 +1443,8 @@ expand_block_compare (rtx operands[])\n   while (bytes > 0)\n     {\n       unsigned int align = compute_current_alignment (base_align, offset);\n-      if (TARGET_EFFICIENT_OVERLAPPING_UNALIGNED)\n-\tload_mode = select_block_compare_mode (offset, bytes, align,\n-\t\t\t\t\t       word_mode_ok);\n-      else\n-\tload_mode = select_block_compare_mode (0, bytes, align, word_mode_ok);\n+      load_mode = select_block_compare_mode (offset, bytes,\n+\t\t\t\t\t     align, word_mode_ok);\n       load_mode_size = GET_MODE_SIZE (load_mode);\n       if (bytes >= load_mode_size)\n \tcmp_bytes = load_mode_size;\n@@ -1625,22 +1672,19 @@ expand_block_compare (rtx operands[])\n   return true;\n }\n \n-/* Generate alignment check and branch code to set up for\n+/* Generate page crossing check and branch code to set up for\n    strncmp when we don't have DI alignment.\n    STRNCMP_LABEL is the label to branch if there is a page crossing.\n-   SRC is the string pointer to be examined.\n+   SRC_ADDR is the string address to be examined.\n    BYTES is the max number of bytes to compare.  */\n static void\n-expand_strncmp_align_check (rtx strncmp_label, rtx src, HOST_WIDE_INT bytes)\n+expand_strncmp_align_check (rtx strncmp_label, rtx src_addr, HOST_WIDE_INT bytes)\n {\n   rtx lab_ref = gen_rtx_LABEL_REF (VOIDmode, strncmp_label);\n-  rtx src_check = copy_addr_to_reg (XEXP (src, 0));\n-  if (GET_MODE (src_check) == SImode)\n-    emit_insn (gen_andsi3 (src_check, src_check, GEN_INT (0xfff)));\n-  else\n-    emit_insn (gen_anddi3 (src_check, src_check, GEN_INT (0xfff)));\n+  rtx src_pgoff = gen_reg_rtx (GET_MODE (src_addr));\n+  do_and3 (src_pgoff, src_addr, GEN_INT (0xfff));\n   rtx cond = gen_reg_rtx (CCmode);\n-  emit_move_insn (cond, gen_rtx_COMPARE (CCmode, src_check,\n+  emit_move_insn (cond, gen_rtx_COMPARE (CCmode, src_pgoff,\n \t\t\t\t\t GEN_INT (4096 - bytes)));\n \n   rtx cmp_rtx = gen_rtx_GE (VOIDmode, cond, const0_rtx);\n@@ -1652,6 +1696,76 @@ expand_strncmp_align_check (rtx strncmp_label, rtx src, HOST_WIDE_INT bytes)\n   LABEL_NUSES (strncmp_label) += 1;\n }\n \n+/* Generate the final sequence that identifies the differing\n+   byte and generates the final result, taking into account\n+   zero bytes:\n+   \n+   cmpb              cmpb_result1, src1, src2\n+   cmpb              cmpb_result2, src1, zero\n+   orc               cmpb_result1, cmp_result1, cmpb_result2\n+   cntlzd            get bit of first zero/diff byte\n+   addi              convert for rldcl use\n+   rldcl rldcl       extract diff/zero byte\n+   subf              subtract for final result\n+\n+   STR1 is the reg rtx for data from string 1.\n+   STR2 is the reg rtx for data from string 2.\n+   RESULT is the reg rtx for the comparison result.  */\n+\n+static void\n+emit_final_str_compare_gpr (rtx str1, rtx str2, rtx result)\n+{\n+  machine_mode m = GET_MODE (str1);\n+  rtx cmpb_diff = gen_reg_rtx (m);\n+  rtx cmpb_zero = gen_reg_rtx (m);\n+  rtx rot_amt = gen_reg_rtx (m);\n+  rtx zero_reg = gen_reg_rtx (m);\n+\n+  rtx rot1_1 = gen_reg_rtx (m);\n+  rtx rot1_2 = gen_reg_rtx (m);\n+  rtx rot2_1 = gen_reg_rtx (m);\n+  rtx rot2_2 = gen_reg_rtx (m);\n+\n+  if (m == SImode)\n+    {\n+      emit_insn (gen_cmpbsi3 (cmpb_diff, str1, str2));\n+      emit_insn (gen_movsi (zero_reg, GEN_INT (0)));\n+      emit_insn (gen_cmpbsi3 (cmpb_zero, str1, zero_reg));\n+      emit_insn (gen_one_cmplsi2 (cmpb_diff,cmpb_diff));\n+      emit_insn (gen_iorsi3 (cmpb_diff, cmpb_diff, cmpb_zero));\n+      emit_insn (gen_clzsi2 (rot_amt, cmpb_diff));\n+      emit_insn (gen_addsi3 (rot_amt, rot_amt, GEN_INT (8)));\n+      emit_insn (gen_rotlsi3 (rot1_1, str1,\n+\t\t\t      gen_lowpart (SImode, rot_amt)));\n+      emit_insn (gen_andsi3_mask (rot1_2, rot1_1, GEN_INT (0xff)));\n+      emit_insn (gen_rotlsi3 (rot2_1, str2,\n+\t\t\t      gen_lowpart (SImode, rot_amt)));\n+      emit_insn (gen_andsi3_mask (rot2_2, rot2_1, GEN_INT (0xff)));\n+      emit_insn (gen_subsi3 (result, rot1_2, rot2_2));\n+    }\n+  else if (m == DImode)\n+    {\n+      emit_insn (gen_cmpbdi3 (cmpb_diff, str1, str2));\n+      emit_insn (gen_movdi (zero_reg, GEN_INT (0)));\n+      emit_insn (gen_cmpbdi3 (cmpb_zero, str1, zero_reg));\n+      emit_insn (gen_one_cmpldi2 (cmpb_diff,cmpb_diff));\n+      emit_insn (gen_iordi3 (cmpb_diff, cmpb_diff, cmpb_zero));\n+      emit_insn (gen_clzdi2 (rot_amt, cmpb_diff));\n+      emit_insn (gen_adddi3 (rot_amt, rot_amt, GEN_INT (8)));\n+      emit_insn (gen_rotldi3 (rot1_1, str1,\n+\t\t\t      gen_lowpart (SImode, rot_amt)));\n+      emit_insn (gen_anddi3_mask (rot1_2, rot1_1, GEN_INT (0xff)));\n+      emit_insn (gen_rotldi3 (rot2_1, str2,\n+\t\t\t      gen_lowpart (SImode, rot_amt)));\n+      emit_insn (gen_anddi3_mask (rot2_2, rot2_1, GEN_INT (0xff)));\n+      emit_insn (gen_subdi3 (result, rot1_2, rot2_2));\n+    }\n+  else\n+    gcc_unreachable ();\n+    \n+  return;\n+}\n+\n /* Expand a string compare operation with length, and return\n    true if successful. Return false if we should let the\n    compiler generate normal code, probably a strncmp call.\n@@ -1682,8 +1796,8 @@ expand_strn_compare (rtx operands[], int no_length)\n       align_rtx = operands[4];\n     }\n   unsigned HOST_WIDE_INT cmp_bytes = 0;\n-  rtx src1 = orig_src1;\n-  rtx src2 = orig_src2;\n+  rtx src1_addr = force_reg (Pmode, XEXP (orig_src1, 0));\n+  rtx src2_addr = force_reg (Pmode, XEXP (orig_src2, 0));\n \n   /* If we have a length, it must be constant. This simplifies things\n      a bit as we don't have to generate code to check if we've exceeded\n@@ -1696,8 +1810,8 @@ expand_strn_compare (rtx operands[], int no_length)\n     return false;\n \n   unsigned int base_align = UINTVAL (align_rtx);\n-  int align1 = MEM_ALIGN (orig_src1) / BITS_PER_UNIT;\n-  int align2 = MEM_ALIGN (orig_src2) / BITS_PER_UNIT;\n+  unsigned int align1 = MEM_ALIGN (orig_src1) / BITS_PER_UNIT;\n+  unsigned int align2 = MEM_ALIGN (orig_src2) / BITS_PER_UNIT;\n \n   /* targetm.slow_unaligned_access -- don't do unaligned stuff.  */\n   if (targetm.slow_unaligned_access (word_mode, align1)\n@@ -1749,8 +1863,9 @@ expand_strn_compare (rtx operands[], int no_length)\n   rtx final_move_label = gen_label_rtx ();\n   rtx final_label = gen_label_rtx ();\n   rtx begin_compare_label = NULL;\n+  unsigned int required_align = 8;\n \n-  if (base_align < 8)\n+  if (base_align < required_align)\n     {\n       /* Generate code that checks distance to 4k boundary for this case.  */\n       begin_compare_label = gen_label_rtx ();\n@@ -1773,14 +1888,14 @@ expand_strn_compare (rtx operands[], int no_length)\n         }\n       else\n         {\n-          align_test = ROUND_UP (align_test, 8);\n-          base_align = 8;\n+          align_test = ROUND_UP (align_test, required_align);\n+          base_align = required_align;\n         }\n \n-      if (align1 < 8)\n-        expand_strncmp_align_check (strncmp_label, src1, align_test);\n-      if (align2 < 8)\n-        expand_strncmp_align_check (strncmp_label, src2, align_test);\n+      if (align1 < required_align)\n+        expand_strncmp_align_check (strncmp_label, src1_addr, align_test);\n+      if (align2 < required_align)\n+        expand_strncmp_align_check (strncmp_label, src2_addr, align_test);\n \n       /* Now generate the following sequence:\n \t - branch to begin_compare\n@@ -1797,25 +1912,13 @@ expand_strn_compare (rtx operands[], int no_length)\n \n       emit_label (strncmp_label);\n \n-      if (!REG_P (XEXP (src1, 0)))\n-\t{\n-\t  rtx src1_reg = copy_addr_to_reg (XEXP (src1, 0));\n-\t  src1 = replace_equiv_address (src1, src1_reg);\n-\t}\n-\n-      if (!REG_P (XEXP (src2, 0)))\n-\t{\n-\t  rtx src2_reg = copy_addr_to_reg (XEXP (src2, 0));\n-\t  src2 = replace_equiv_address (src2, src2_reg);\n-\t}\n-\n       if (no_length)\n \t{\n \t  tree fun = builtin_decl_explicit (BUILT_IN_STRCMP);\n \t  emit_library_call_value (XEXP (DECL_RTL (fun), 0),\n \t\t\t\t   target, LCT_NORMAL, GET_MODE (target),\n-\t\t\t\t   force_reg (Pmode, XEXP (src1, 0)), Pmode,\n-\t\t\t\t   force_reg (Pmode, XEXP (src2, 0)), Pmode);\n+\t\t\t\t   force_reg (Pmode, src1_addr), Pmode,\n+\t\t\t\t   force_reg (Pmode, src2_addr), Pmode);\n \t}\n       else\n \t{\n@@ -1833,8 +1936,8 @@ expand_strn_compare (rtx operands[], int no_length)\n \t  tree fun = builtin_decl_explicit (BUILT_IN_STRNCMP);\n \t  emit_library_call_value (XEXP (DECL_RTL (fun), 0),\n \t\t\t\t   target, LCT_NORMAL, GET_MODE (target),\n-\t\t\t\t   force_reg (Pmode, XEXP (src1, 0)), Pmode,\n-\t\t\t\t   force_reg (Pmode, XEXP (src2, 0)), Pmode,\n+\t\t\t\t   force_reg (Pmode, src1_addr), Pmode,\n+\t\t\t\t   force_reg (Pmode, src2_addr), Pmode,\n \t\t\t\t   len_rtx, GET_MODE (len_rtx));\n \t}\n \n@@ -1850,12 +1953,12 @@ expand_strn_compare (rtx operands[], int no_length)\n   rtx tmp_reg_src1 = gen_reg_rtx (word_mode);\n   rtx tmp_reg_src2 = gen_reg_rtx (word_mode);\n \n-  /* Generate sequence of ld/ldbrx, cmpb to compare out\n+  /* Generate a sequence of GPR or VEC/VSX instructions to compare out\n      to the length specified.  */\n   unsigned HOST_WIDE_INT bytes_to_compare = compare_length;\n   while (bytes_to_compare > 0)\n     {\n-      /* Compare sequence:\n+      /* GPR compare sequence:\n          check each 8B with: ld/ld cmpd bne\n \t If equal, use rldicr/cmpb to check for zero byte.\n          cleanup code at end:\n@@ -1869,13 +1972,10 @@ expand_strn_compare (rtx operands[], int no_length)\n \n          The last compare can branch around the cleanup code if the\n          result is zero because the strings are exactly equal.  */\n+      \n       unsigned int align = compute_current_alignment (base_align, offset);\n-      if (TARGET_EFFICIENT_OVERLAPPING_UNALIGNED)\n-\tload_mode = select_block_compare_mode (offset, bytes_to_compare, align,\n-\t\t\t\t\t       word_mode_ok);\n-      else\n-\tload_mode = select_block_compare_mode (0, bytes_to_compare, align,\n-\t\t\t\t\t       word_mode_ok);\n+      load_mode = select_block_compare_mode (offset, bytes_to_compare,\n+\t\t\t\t\t     align, word_mode_ok);\n       load_mode_size = GET_MODE_SIZE (load_mode);\n       if (bytes_to_compare >= load_mode_size)\n \tcmp_bytes = load_mode_size;\n@@ -1898,25 +1998,10 @@ expand_strn_compare (rtx operands[], int no_length)\n \t   rid of the extra bytes.  */\n \tcmp_bytes = bytes_to_compare;\n \n-      src1 = adjust_address (orig_src1, load_mode, offset);\n-      src2 = adjust_address (orig_src2, load_mode, offset);\n-\n-      if (!REG_P (XEXP (src1, 0)))\n-\t{\n-\t  rtx src1_reg = copy_addr_to_reg (XEXP (src1, 0));\n-\t  src1 = replace_equiv_address (src1, src1_reg);\n-\t}\n-      set_mem_size (src1, load_mode_size);\n-\n-      if (!REG_P (XEXP (src2, 0)))\n-\t{\n-\t  rtx src2_reg = copy_addr_to_reg (XEXP (src2, 0));\n-\t  src2 = replace_equiv_address (src2, src2_reg);\n-\t}\n-      set_mem_size (src2, load_mode_size);\n-\n-      do_load_for_compare (tmp_reg_src1, src1, load_mode);\n-      do_load_for_compare (tmp_reg_src2, src2, load_mode);\n+      rtx addr1 = gen_rtx_PLUS (Pmode, src1_addr, GEN_INT (offset));\n+      do_load_for_compare_from_addr (load_mode, tmp_reg_src1, addr1, orig_src1);\n+      rtx addr2 = gen_rtx_PLUS (Pmode, src2_addr, GEN_INT (offset));\n+      do_load_for_compare_from_addr (load_mode, tmp_reg_src2, addr2, orig_src2);\n \n       /* We must always left-align the data we read, and\n \t clear any bytes to the right that are beyond the string.\n@@ -1929,16 +2014,8 @@ expand_strn_compare (rtx operands[], int no_length)\n \t{\n \t  /* Rotate left first. */\n \t  rtx sh = GEN_INT (BITS_PER_UNIT * (word_mode_size - load_mode_size));\n-\t  if (word_mode == DImode)\n-\t    {\n-\t      emit_insn (gen_rotldi3 (tmp_reg_src1, tmp_reg_src1, sh));\n-\t      emit_insn (gen_rotldi3 (tmp_reg_src2, tmp_reg_src2, sh));\n-\t    }\n-\t  else\n-\t    {\n-\t      emit_insn (gen_rotlsi3 (tmp_reg_src1, tmp_reg_src1, sh));\n-\t      emit_insn (gen_rotlsi3 (tmp_reg_src2, tmp_reg_src2, sh));\n-\t    }\n+\t  do_rotl3 (tmp_reg_src1, tmp_reg_src1, sh);\n+\t  do_rotl3 (tmp_reg_src2, tmp_reg_src2, sh);\n \t}\n \n       if (cmp_bytes < word_mode_size)\n@@ -1947,16 +2024,8 @@ expand_strn_compare (rtx operands[], int no_length)\n \t     turned into a rldicr instruction. */\n \t  HOST_WIDE_INT mb = BITS_PER_UNIT * (word_mode_size - cmp_bytes);\n \t  rtx mask = GEN_INT (HOST_WIDE_INT_M1U << mb);\n-\t  if (word_mode == DImode)\n-\t    {\n-\t      emit_insn (gen_anddi3_mask (tmp_reg_src1, tmp_reg_src1, mask));\n-\t      emit_insn (gen_anddi3_mask (tmp_reg_src2, tmp_reg_src2, mask));\n-\t    }\n-\t  else\n-\t    {\n-\t      emit_insn (gen_andsi3_mask (tmp_reg_src1, tmp_reg_src1, mask));\n-\t      emit_insn (gen_andsi3_mask (tmp_reg_src2, tmp_reg_src2, mask));\n-\t    }\n+\t  do_and3 (tmp_reg_src1, tmp_reg_src1, mask);\n+\t  do_and3 (tmp_reg_src2, tmp_reg_src2, mask);\n \t}\n \n       /* Cases to handle.  A and B are chunks of the two strings.\n@@ -2013,31 +2082,16 @@ expand_strn_compare (rtx operands[], int no_length)\n \t  rtx lab_ref_fin = gen_rtx_LABEL_REF (VOIDmode, final_move_label);\n \t  rtx condz = gen_reg_rtx (CCmode);\n \t  rtx zero_reg = gen_reg_rtx (word_mode);\n-\t  if (word_mode == SImode)\n-\t    {\n-\t      emit_insn (gen_movsi (zero_reg, GEN_INT (0)));\n-\t      emit_insn (gen_cmpbsi3 (cmpb_zero, tmp_reg_src1, zero_reg));\n-\t      if (cmp_bytes < word_mode_size)\n-\t\t{\n-\t\t  /* Don't want to look at zero bytes past end.  */\n-\t\t  HOST_WIDE_INT mb =\n-\t\t    BITS_PER_UNIT * (word_mode_size - cmp_bytes);\n-\t\t  rtx mask = GEN_INT (HOST_WIDE_INT_M1U << mb);\n-\t\t  emit_insn (gen_andsi3_mask (cmpb_zero, cmpb_zero, mask));\n-\t\t}\n-\t    }\n-\t  else\n+\t  emit_move_insn (zero_reg, GEN_INT (0));\n+\t  do_cmpb3 (cmpb_zero, tmp_reg_src1, zero_reg);\n+\n+\t  if (cmp_bytes < word_mode_size)\n \t    {\n-\t      emit_insn (gen_movdi (zero_reg, GEN_INT (0)));\n-\t      emit_insn (gen_cmpbdi3 (cmpb_zero, tmp_reg_src1, zero_reg));\n-\t      if (cmp_bytes < word_mode_size)\n-\t\t{\n-\t\t  /* Don't want to look at zero bytes past end.  */\n-\t\t  HOST_WIDE_INT mb =\n-\t\t    BITS_PER_UNIT * (word_mode_size - cmp_bytes);\n-\t\t  rtx mask = GEN_INT (HOST_WIDE_INT_M1U << mb);\n-\t\t  emit_insn (gen_anddi3_mask (cmpb_zero, cmpb_zero, mask));\n-\t\t}\n+\t      /* Don't want to look at zero bytes past end.  */\n+\t      HOST_WIDE_INT mb =\n+\t\tBITS_PER_UNIT * (word_mode_size - cmp_bytes);\n+\t      rtx mask = GEN_INT (HOST_WIDE_INT_M1U << mb);\n+\t      do_and3 (cmpb_zero, cmpb_zero, mask);\n \t    }\n \n \t  emit_move_insn (condz, gen_rtx_COMPARE (CCmode, cmpb_zero, zero_reg));\n@@ -2057,31 +2111,18 @@ expand_strn_compare (rtx operands[], int no_length)\n   if (equality_compare_rest)\n     {\n       /* Update pointers past what has been compared already.  */\n-      src1 = adjust_address (orig_src1, load_mode, offset);\n-      src2 = adjust_address (orig_src2, load_mode, offset);\n-\n-      if (!REG_P (XEXP (src1, 0)))\n-\t{\n-\t  rtx src1_reg = copy_addr_to_reg (XEXP (src1, 0));\n-\t  src1 = replace_equiv_address (src1, src1_reg);\n-\t}\n-      set_mem_size (src1, load_mode_size);\n-\n-      if (!REG_P (XEXP (src2, 0)))\n-\t{\n-\t  rtx src2_reg = copy_addr_to_reg (XEXP (src2, 0));\n-\t  src2 = replace_equiv_address (src2, src2_reg);\n-\t}\n-      set_mem_size (src2, load_mode_size);\n+      rtx src1 = force_reg (Pmode,\n+\t\t\t    gen_rtx_PLUS (Pmode, src1_addr, GEN_INT (offset)));\n+      rtx src2 = force_reg (Pmode,\n+\t\t\t    gen_rtx_PLUS (Pmode, src2_addr, GEN_INT (offset)));\n \n       /* Construct call to strcmp/strncmp to compare the rest of the string.  */\n       if (no_length)\n \t{\n \t  tree fun = builtin_decl_explicit (BUILT_IN_STRCMP);\n \t  emit_library_call_value (XEXP (DECL_RTL (fun), 0),\n \t\t\t\t   target, LCT_NORMAL, GET_MODE (target),\n-\t\t\t\t   force_reg (Pmode, XEXP (src1, 0)), Pmode,\n-\t\t\t\t   force_reg (Pmode, XEXP (src2, 0)), Pmode);\n+\t\t\t\t   src1, Pmode, src2, Pmode);\n \t}\n       else\n \t{\n@@ -2095,8 +2136,7 @@ expand_strn_compare (rtx operands[], int no_length)\n \t  tree fun = builtin_decl_explicit (BUILT_IN_STRNCMP);\n \t  emit_library_call_value (XEXP (DECL_RTL (fun), 0),\n \t\t\t\t   target, LCT_NORMAL, GET_MODE (target),\n-\t\t\t\t   force_reg (Pmode, XEXP (src1, 0)), Pmode,\n-\t\t\t\t   force_reg (Pmode, XEXP (src2, 0)), Pmode,\n+\t\t\t\t   src1, Pmode, src2, Pmode,\n \t\t\t\t   len_rtx, GET_MODE (len_rtx));\n \t}\n \n@@ -2110,63 +2150,7 @@ expand_strn_compare (rtx operands[], int no_length)\n   if (cleanup_label)\n     emit_label (cleanup_label);\n \n-  /* Generate the final sequence that identifies the differing\n-     byte and generates the final result, taking into account\n-     zero bytes:\n-\n-     cmpb              cmpb_result1, src1, src2\n-     cmpb              cmpb_result2, src1, zero\n-     orc               cmpb_result1, cmp_result1, cmpb_result2\n-     cntlzd            get bit of first zero/diff byte\n-     addi              convert for rldcl use\n-     rldcl rldcl       extract diff/zero byte\n-     subf              subtract for final result\n-  */\n-\n-  rtx cmpb_diff = gen_reg_rtx (word_mode);\n-  rtx cmpb_zero = gen_reg_rtx (word_mode);\n-  rtx rot_amt = gen_reg_rtx (word_mode);\n-  rtx zero_reg = gen_reg_rtx (word_mode);\n-\n-  rtx rot1_1 = gen_reg_rtx (word_mode);\n-  rtx rot1_2 = gen_reg_rtx (word_mode);\n-  rtx rot2_1 = gen_reg_rtx (word_mode);\n-  rtx rot2_2 = gen_reg_rtx (word_mode);\n-\n-  if (word_mode == SImode)\n-    {\n-      emit_insn (gen_cmpbsi3 (cmpb_diff, tmp_reg_src1, tmp_reg_src2));\n-      emit_insn (gen_movsi (zero_reg, GEN_INT (0)));\n-      emit_insn (gen_cmpbsi3 (cmpb_zero, tmp_reg_src1, zero_reg));\n-      emit_insn (gen_one_cmplsi2 (cmpb_diff,cmpb_diff));\n-      emit_insn (gen_iorsi3 (cmpb_diff, cmpb_diff, cmpb_zero));\n-      emit_insn (gen_clzsi2 (rot_amt, cmpb_diff));\n-      emit_insn (gen_addsi3 (rot_amt, rot_amt, GEN_INT (8)));\n-      emit_insn (gen_rotlsi3 (rot1_1, tmp_reg_src1,\n-\t\t\t      gen_lowpart (SImode, rot_amt)));\n-      emit_insn (gen_andsi3_mask (rot1_2, rot1_1, GEN_INT (0xff)));\n-      emit_insn (gen_rotlsi3 (rot2_1, tmp_reg_src2,\n-\t\t\t      gen_lowpart (SImode, rot_amt)));\n-      emit_insn (gen_andsi3_mask (rot2_2, rot2_1, GEN_INT (0xff)));\n-      emit_insn (gen_subsi3 (result_reg, rot1_2, rot2_2));\n-    }\n-  else\n-    {\n-      emit_insn (gen_cmpbdi3 (cmpb_diff, tmp_reg_src1, tmp_reg_src2));\n-      emit_insn (gen_movdi (zero_reg, GEN_INT (0)));\n-      emit_insn (gen_cmpbdi3 (cmpb_zero, tmp_reg_src1, zero_reg));\n-      emit_insn (gen_one_cmpldi2 (cmpb_diff,cmpb_diff));\n-      emit_insn (gen_iordi3 (cmpb_diff, cmpb_diff, cmpb_zero));\n-      emit_insn (gen_clzdi2 (rot_amt, cmpb_diff));\n-      emit_insn (gen_adddi3 (rot_amt, rot_amt, GEN_INT (8)));\n-      emit_insn (gen_rotldi3 (rot1_1, tmp_reg_src1,\n-\t\t\t      gen_lowpart (SImode, rot_amt)));\n-      emit_insn (gen_anddi3_mask (rot1_2, rot1_1, GEN_INT (0xff)));\n-      emit_insn (gen_rotldi3 (rot2_1, tmp_reg_src2,\n-\t\t\t      gen_lowpart (SImode, rot_amt)));\n-      emit_insn (gen_anddi3_mask (rot2_2, rot2_1, GEN_INT (0xff)));\n-      emit_insn (gen_subdi3 (result_reg, rot1_2, rot2_2));\n-    }\n+  emit_final_str_compare_gpr (tmp_reg_src1, tmp_reg_src2, result_reg);\n \n   emit_label (final_move_label);\n   emit_insn (gen_movsi (target,"}, {"sha": "6fe18c3a947873f332845902124e9487518b3316", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e94dfb68d48b936044f7a631540e83b4a8b163/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e94dfb68d48b936044f7a631540e83b4a8b163/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=f7e94dfb68d48b936044f7a631540e83b4a8b163", "patch": "@@ -1194,7 +1194,7 @@\n ;;              VSX store  VSX load   VSX move  VSX->GPR   GPR->VSX    LQ (GPR)\n ;;              STQ (GPR)  GPR load   GPR store GPR move   XXSPLTIB    VSPLTISW\n ;;              VSX 0/-1   GPR 0/-1   VMX const GPR const  LVX (VMX)   STVX (VMX)\n-(define_insn \"*vsx_mov<mode>_64bit\"\n+(define_insn \"vsx_mov<mode>_64bit\"\n   [(set (match_operand:VSX_M 0 \"nonimmediate_operand\"\n                \"=ZwO,      <VSa>,     <VSa>,     r,         we,        ?wQ,\n                 ?&r,       ??r,       ??Y,       <??r>,     wo,        v,"}]}