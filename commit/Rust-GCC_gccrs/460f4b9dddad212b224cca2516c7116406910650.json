{"sha": "460f4b9dddad212b224cca2516c7116406910650", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYwZjRiOWRkZGFkMjEyYjIyNGNjYTI1MTZjNzExNjQwNjkxMDY1MA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-04-14T20:59:44Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-04-14T20:59:44Z"}, "message": "mn10300.c (can_use_return_insn): Include outgoing argument area in size computation.\n\n        * mn10300.c (can_use_return_insn): Include outgoing argument\n        area in size computation.\n        (expand_prologue): Likewise.  No longer diddle with sequences.\n        Put register saves just before outgoing argument area.\n        (expand_epilogue): Similarly.\n        (impossible_plus_operand): New function.\n        * mn10300.h (FRAME_POINTER_REQUIRED): Never require a frame pointer.\n        (ACCUMULATE_OUTGOING_ARGS, OUTGOING_REG_PARM_STACK_SPACE): Define.\n        (impossible_plus_operand): Declare.\n        * mn10300.md (reload_insi): New expander to handle pathological\n        reload cases.\n        (addsi3): Fix CC status.\n\n        * mn10300.h (FUNCTION_VALUE): Return addresses in $a0.\n        (FUNCTION_VALUE_REGNO_P): Corresponding changes.\n        * mn10300.md (call_value_internal): Allow output to be in an\n        address register.\n\nFrom-SVN: r13903", "tree": {"sha": "9c02115a5fab37fecb33b292a41ee8321de14ddc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c02115a5fab37fecb33b292a41ee8321de14ddc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/460f4b9dddad212b224cca2516c7116406910650", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/460f4b9dddad212b224cca2516c7116406910650", "html_url": "https://github.com/Rust-GCC/gccrs/commit/460f4b9dddad212b224cca2516c7116406910650", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/460f4b9dddad212b224cca2516c7116406910650/comments", "author": null, "committer": null, "parents": [{"sha": "f046b3cc2319a9fbd7470b024b424bee137a0f5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f046b3cc2319a9fbd7470b024b424bee137a0f5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f046b3cc2319a9fbd7470b024b424bee137a0f5f"}], "stats": {"total": 126, "additions": 73, "deletions": 53}, "files": [{"sha": "f2161024dc07e1f3faaf3cbc41a4b88ccafbfa3d", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/460f4b9dddad212b224cca2516c7116406910650/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/460f4b9dddad212b224cca2516c7116406910650/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=460f4b9dddad212b224cca2516c7116406910650", "patch": "@@ -347,8 +347,11 @@ print_operand_address (file, addr)\n int\n can_use_return_insn ()\n {\n-  /* SIZE includes the fixed stack space needed for function calls.  */\n-  int size = get_frame_size () + (!leaf_function_p () ? 12 : 0);\n+  /* size includes the fixed stack space needed for function calls.  */\n+  int size = get_frame_size () + current_function_outgoing_args_size;\n+\n+  /* And space for the return pointer.  */\n+  size += current_function_outgoing_args_size ? 4 : 0;\n \n   return (reload_completed\n \t  && size == 0\n@@ -416,11 +419,6 @@ expand_prologue ()\n {\n   unsigned int size;\n \n-  /* We have to end the current sequence so leaf_function_p and\n-     count_tst_insns will work.  We then start a new sequence to\n-     hold the prologue/epilogue.  */\n-  end_sequence ();\n-\n   /* Determine if it is profitable to put the value zero into a register\n      for the entire function.  If so, set ZERO_DREG and ZERO_AREG.  */\n   if (regs_ever_live[2] || regs_ever_live[3]\n@@ -478,10 +476,8 @@ expand_prologue ()\n     }\n \n   /* SIZE includes the fixed stack space needed for function calls.  */\n-  size = get_frame_size () + (!leaf_function_p () ? 12 : 0);\n-\n-  /* Start a new sequence for the prologue/epilogue.  */\n-  start_sequence ();\n+  size = get_frame_size () + current_function_outgoing_args_size;\n+  size += (current_function_outgoing_args_size ? 4 : 0);\n \n   /* If this is an old-style varargs function, then its arguments\n      need to be flushed back to the stack.  */\n@@ -527,15 +523,9 @@ expand_epilogue ()\n {\n   unsigned int size;\n \n-  /* We have to end the current sequence so leaf_function_p will\n-     work.  We then start a new sequence to hold the prologue/epilogue.  */\n-  end_sequence ();\n-\n   /* SIZE includes the fixed stack space needed for function calls.  */\n-  size = get_frame_size () + (!leaf_function_p () ? 12 : 0);\n-\n-  /* Start a new sequence for the prologue/epilogue.  */\n-  start_sequence ();\n+  size = get_frame_size () + current_function_outgoing_args_size;\n+  size += (current_function_outgoing_args_size ? 4 : 0);\n \n   /* Cut back the stack.  */\n   if (frame_pointer_needed)\n@@ -705,16 +695,22 @@ initial_offset (from, to)\n       if (regs_ever_live[2] || regs_ever_live[3]\n \t  || regs_ever_live[6] || regs_ever_live[7]\n \t  || frame_pointer_needed)\n-\treturn (get_frame_size () + 16 + (!leaf_function_p () ? 12 : 0));\n+\treturn (get_frame_size () + 16 \n+\t\t+ (current_function_outgoing_args_size\n+\t\t   ? current_function_outgoing_args_size + 4 : 0)); \n       else\n-\treturn (get_frame_size () + (!leaf_function_p () ? 12 : 0));\n+\treturn (get_frame_size ()\n+\t\t+ (current_function_outgoing_args_size\n+\t\t   ? current_function_outgoing_args_size + 4 : 0)); \n     }\n \n   /* The difference between the frame pointer and stack pointer is the sum\n      of the size of this function's frame and the fixed stack space needed\n      for function calls (if any).  */\n   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return get_frame_size () + (!leaf_function_p () ? 12 : 0);\n+    return (get_frame_size ()\n+\t    + (current_function_outgoing_args_size\n+\t       ? current_function_outgoing_args_size + 4 : 0)); \n \n   abort ();\n }\n@@ -934,3 +930,28 @@ output_tst (operand, insn)\n     }\n   return \"cmp 0,%0\";\n }\n+\n+int\n+impossible_plus_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  extern rtx *reg_equiv_mem;\n+  rtx reg1, reg2;\n+  \n+  if (GET_CODE (op) != PLUS)\n+    return 0;\n+\n+  if ((XEXP (op, 0) == stack_pointer_rtx)\n+      && ((REG_P (XEXP (op, 1)) && reg_equiv_mem [REGNO (XEXP (op, 1))])\n+\t  || (GET_CODE (XEXP (op, 1)) == SUBREG\n+\t      && GET_CODE (SUBREG_REG (XEXP (op, 1))) == MEM)))\n+    return 1;\n+\n+  if ((XEXP (op, 1) == stack_pointer_rtx)\n+      && ((REG_P (XEXP (op, 0)) && reg_equiv_mem [REGNO (XEXP (op, 0))])\n+\t  || (GET_CODE (XEXP (op, 0)) == SUBREG\n+\t      && GET_CODE (SUBREG_REG (XEXP (op, 0))) == MEM)))\n+    return 1;\n+  return 0;\n+}"}, {"sha": "d7ac6af3e9918eb655e11f09a07074253d9e10d8", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/460f4b9dddad212b224cca2516c7116406910650/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/460f4b9dddad212b224cca2516c7116406910650/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=460f4b9dddad212b224cca2516c7116406910650", "patch": "@@ -374,29 +374,6 @@ enum reg_class {\n /* Register in which static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM 5\n \n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.\n-\n-   We allow frame pointers to be eliminated when not having one will\n-   not interfere with debugging.\n-\n-     * If this is a leaf function, then we can keep the stack pointer\n-     constant throughout the function, and therefore gdb can easily\n-     find the base of the current frame.\n-\n-     * If this function never allocates stack space for outgoing\n-     args (ie calls functions with either no args, or args only\n-     in registers), then the stack pointer will be constant and\n-     gdb can easily find the base of the current frame.\n-\n-     We'd really like to define ACCUMULATE_OUTGOING_ARGS and eliminate\n-     all frame pointer, but currently we can't.\n-\n-     We probably also want a -m option to eliminate frame pointer, even\n-     if the resulting executable can not be debugged.  */\n-\n #define ELIMINABLE_REGS\t\t\t\t\\\n {{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n  { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\\\n@@ -407,8 +384,9 @@ enum reg_class {\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n   OFFSET = initial_offset (FROM, TO)\n \n-#define FRAME_POINTER_REQUIRED \\\n-  !(leaf_function_p () || current_function_outgoing_args_size == 0)\n+/* We can debug without frame pointers on the mn10300, so eliminate\n+   them whenever possible.  */\n+#define FRAME_POINTER_REQUIRED 0\n #define CAN_DEBUG_WITHOUT_FP\n \n /* A guess for the MN10300.  */\n@@ -426,6 +404,8 @@ enum reg_class {\n /* We use d0/d1 for passing parameters, so allocate 8 bytes of space\n    for a register flushback area.  */\n #define REG_PARM_STACK_SPACE(DECL) 8\n+#define OUTGOING_REG_PARM_STACK_SPACE\n+#define ACCUMULATE_OUTGOING_ARGS\n \n /* So we can allocate space for return pointers once for the function\n    instead of around every call.  */\n@@ -500,8 +480,9 @@ extern struct rtx_def *function_arg ();\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.   */\n-   \n-#define FUNCTION_VALUE(VALTYPE, FUNC) gen_rtx (REG, TYPE_MODE (VALTYPE), 0)\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), POINTER_TYPE_P (VALTYPE) ? 4 : 0)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n@@ -510,7 +491,7 @@ extern struct rtx_def *function_arg ();\n \n /* 1 if N is a possible register number for a function value.  */\n \n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0 || (N) == 4)\n \n /* Return values > 8 bytes in length in memory.  */\n #define DEFAULT_PCC_STRUCT_RETURN 0\n@@ -1014,6 +995,7 @@ extern void expand_prologue ();\n extern void expand_epilogue ();\n extern void notice_update_cc ();\n extern int call_address_operand ();\n+extern int impossible_plus_operand ();\n extern enum reg_class secondary_reload_class ();\n extern int initial_offset ();\n extern char *output_tst ();"}, {"sha": "d936a02df12b27808f918299f8eb0a8755c624f4", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/460f4b9dddad212b224cca2516c7116406910650/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/460f4b9dddad212b224cca2516c7116406910650/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=460f4b9dddad212b224cca2516c7116406910650", "patch": "@@ -156,6 +156,22 @@\n \n ;; movsi and helpers\n \n+;; We use this to handle addition of two values when one operand is the\n+;; stack pointer and the other is a memory reference of some kind.  Reload\n+;; does not handle them correctly without this expander.\n+(define_expand \"reload_insi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(match_operand:SI 1 \"impossible_plus_operand\" \"\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=&a\"))]\n+  \"\"\n+  \"\n+{\n+  emit_move_insn (operands[0], XEXP (operands[1], 0));\n+  emit_move_insn (operands[2], XEXP (operands[1], 1));\n+  emit_insn (gen_addsi3 (operands[0], operands[0], operands[2]));\n+  DONE;\n+}\")\n+\n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n \t(match_operand:SI 1 \"general_operand\" \"\"))]\n@@ -646,7 +662,7 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,a,a,da,x,!&da\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,a,a,da,x,&!da\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,da\")\n \t\t (match_operand:SI 2 \"nonmemory_operand\" \"J,J,L,dai,i,da\")))]\n   \"\"\n@@ -657,7 +673,7 @@\n   add %2,%0\n   add %2,%0\n   mov %2,%0\\;add %1,%0\"\n-  [(set_attr \"cc\" \"set_zn_c0,none_0hit,none_0hit,set_zn_c0,none_0hit,none_0hit\")])\n+  [(set_attr \"cc\" \"set_zn_c0,none_0hit,none_0hit,set_zn_c0,none_0hit,set_zn_c0\")])\n \n (define_expand \"adddi3\"\n   [(set (reg:DI 0) (match_operand:DI 1 \"register_operand\" \"\"))\n@@ -1211,7 +1227,7 @@\n }\")\n \n (define_insn \"call_value_internal\"\n-  [(set (match_operand 0 \"\" \"=d\")\n+  [(set (match_operand 0 \"\" \"=da\")\n \t(call (mem:QI (match_operand:SI 1 \"call_address_operand\" \"aS\"))\n \t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n   \"\"\n@@ -1424,3 +1440,4 @@\n   \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n   \"add %0,%0\\;bcc %1\"\n   [(set_attr \"cc\" \"clobber\")])\n+"}]}