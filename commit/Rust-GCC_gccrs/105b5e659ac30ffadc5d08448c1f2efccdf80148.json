{"sha": "105b5e659ac30ffadc5d08448c1f2efccdf80148", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA1YjVlNjU5YWMzMGZmYWRjNWQwODQ0OGMxZjJlZmNjZGY4MDE0OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-08T10:51:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-08T10:51:09Z"}, "message": "[multiple changes]\n\n2010-10-08  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch6.adb: Minor reformatting.\n\n2010-10-08  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat1drv.adb: Add call to Validate_Independence.\n\t* par-prag.adb: Add dummy entries for Independent,\n\tIndependent_Componentsa.\n\t* sem_ch13.adb (Validate_Independence): New procedure\n\t(Initialize): Initialize address clause and independence check tables\n\t* sem_ch13.ads (Independence_Checks): New table\n\t(Validate_Independence): New procedure\n\t* sem_prag.adb: Add processing for pragma Independent[_Components]\n\t* snames.ads-tmpl: Add entries for pragma Independent[_Components]\n\n2010-10-08  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_aggr.adb (Propagate_Discriminants): When expanding an aggregate\n\tcomponent with box initialization, if the component is a variant record\n\tuse the values of the discriminants to select the proper variant for\n\tfurther box initialization.\n\nFrom-SVN: r165162", "tree": {"sha": "60f102f8f0b02f960f1bcbd4b1514e0230d5465c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60f102f8f0b02f960f1bcbd4b1514e0230d5465c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/105b5e659ac30ffadc5d08448c1f2efccdf80148", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/105b5e659ac30ffadc5d08448c1f2efccdf80148", "html_url": "https://github.com/Rust-GCC/gccrs/commit/105b5e659ac30ffadc5d08448c1f2efccdf80148", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/105b5e659ac30ffadc5d08448c1f2efccdf80148/comments", "author": null, "committer": null, "parents": [{"sha": "fd02e833d86d0e4d34cf59eb3c9c6846b859753a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd02e833d86d0e4d34cf59eb3c9c6846b859753a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd02e833d86d0e4d34cf59eb3c9c6846b859753a"}], "stats": {"total": 592, "additions": 556, "deletions": 36}, "files": [{"sha": "38a15be4ac44cef97ac7e0525b466aa06d1733d2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=105b5e659ac30ffadc5d08448c1f2efccdf80148", "patch": "@@ -1,3 +1,26 @@\n+2010-10-08  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch6.adb: Minor reformatting.\n+\n+2010-10-08  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat1drv.adb: Add call to Validate_Independence.\n+\t* par-prag.adb: Add dummy entries for Independent,\n+\tIndependent_Componentsa.\n+\t* sem_ch13.adb (Validate_Independence): New procedure\n+\t(Initialize): Initialize address clause and independence check tables\n+\t* sem_ch13.ads (Independence_Checks): New table\n+\t(Validate_Independence): New procedure\n+\t* sem_prag.adb: Add processing for pragma Independent[_Components]\n+\t* snames.ads-tmpl: Add entries for pragma Independent[_Components]\n+\n+2010-10-08  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_aggr.adb (Propagate_Discriminants): When expanding an aggregate\n+\tcomponent with box initialization, if the component is a variant record\n+\tuse the values of the discriminants to select the proper variant for\n+\tfurther box initialization.\n+\n 2010-10-08  Thomas Quinot  <quinot@adacore.com>\n \n \t* xsnames.adb: Remove obsolete file."}, {"sha": "04b26c58fa5a4a926bd1c1b30b1fc219f3763965", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=105b5e659ac30ffadc5d08448c1f2efccdf80148", "patch": "@@ -704,6 +704,7 @@ begin\n          Treepr.Tree_Dump;\n          Sem_Ch13.Validate_Unchecked_Conversions;\n          Sem_Ch13.Validate_Address_Clauses;\n+         Sem_Ch13.Validate_Independence;\n          Errout.Output_Messages;\n          Namet.Finalize;\n \n@@ -880,6 +881,7 @@ begin\n \n          Sem_Ch13.Validate_Unchecked_Conversions;\n          Sem_Ch13.Validate_Address_Clauses;\n+         Sem_Ch13.Validate_Independence;\n          Errout.Finalize (Last_Call => True);\n          Errout.Output_Messages;\n          Treepr.Tree_Dump;\n@@ -913,6 +915,7 @@ begin\n       then\n          Sem_Ch13.Validate_Unchecked_Conversions;\n          Sem_Ch13.Validate_Address_Clauses;\n+         Sem_Ch13.Validate_Independence;\n          Errout.Finalize (Last_Call => True);\n          Errout.Output_Messages;\n          Write_ALI (Object => False);\n@@ -980,6 +983,11 @@ begin\n \n       Sem_Ch13.Validate_Address_Clauses;\n \n+      --  Validate independence pragmas (again using values annotated by\n+      --  the back end for component layout etc.)\n+\n+      Sem_Ch13.Validate_Independence;\n+\n       --  Now we complete output of errors, rep info and the tree info. These\n       --  are delayed till now, since it is perfectly possible for gigi to\n       --  generate errors, modify the tree (in particular by setting flags"}, {"sha": "a21ed69d5077244f7eb1f0ac1bb422bb2f887a36", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=105b5e659ac30ffadc5d08448c1f2efccdf80148", "patch": "@@ -1131,6 +1131,8 @@ begin\n            Pragma_Import_Object                 |\n            Pragma_Import_Procedure              |\n            Pragma_Import_Valued_Procedure       |\n+           Pragma_Independent                   |\n+           Pragma_Independent_Components        |\n            Pragma_Initialize_Scalars            |\n            Pragma_Inline                        |\n            Pragma_Inline_Always                 |"}, {"sha": "5a0219918838373f1a4ac43d55131a2c419cb7cf", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 75, "deletions": 22, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=105b5e659ac30ffadc5d08448c1f2efccdf80148", "patch": "@@ -3570,8 +3570,7 @@ package body Sem_Aggr is\n \n                         procedure Propagate_Discriminants\n                           (Aggr       : Node_Id;\n-                           Assoc_List : List_Id;\n-                           Comp       : Entity_Id);\n+                           Assoc_List : List_Id);\n                         --  Nested components may themselves be discriminated\n                         --  types constrained by outer discriminants, whose\n                         --  values must be captured before the aggregate is\n@@ -3653,42 +3652,95 @@ package body Sem_Aggr is\n \n                         procedure Propagate_Discriminants\n                           (Aggr       : Node_Id;\n-                           Assoc_List : List_Id;\n-                           Comp       : Entity_Id)\n+                           Assoc_List : List_Id)\n                         is\n-                           Inner_Comp : Entity_Id;\n-                           Comp_Type  : Entity_Id;\n+                           Aggr_Type  : constant Entity_Id :=\n+                             Base_Type (Etype (Aggr));\n+                           Def_Node   : constant Node_Id :=\n+                             Type_Definition (Declaration_Node (Aggr_Type));\n+\n+                           Comp       : Node_Id;\n+                           Comp_Elmt  : Elmt_Id;\n+                           Components : constant Elist_Id := New_Elmt_List;\n                            Needs_Box  : Boolean := False;\n-                           New_Aggr   : Node_Id;\n+                           Errors     : Boolean;\n \n-                        begin\n-                           Inner_Comp := First_Component (Etype (Comp));\n-                           while Present (Inner_Comp) loop\n-                              Comp_Type := Etype (Inner_Comp);\n+                           procedure Process_Component (Comp : Entity_Id);\n+                           --  Add one component with a box association  to the\n+                           --  inner aggregate, and recurse if component is\n+                           --  itself composite.\n \n-                              if Is_Record_Type (Comp_Type)\n-                                and then Has_Discriminants (Comp_Type)\n+                           ------------------------\n+                           --  Process_Component --\n+                           ------------------------\n+\n+                           procedure Process_Component (Comp : Entity_Id) is\n+                              T : constant Entity_Id := Etype (Comp);\n+                              New_Aggr   : Node_Id;\n+\n+                           begin\n+                              if Is_Record_Type (T)\n+                                and then Has_Discriminants (T)\n                               then\n                                  New_Aggr :=\n                                    Make_Aggregate (Loc, New_List, New_List);\n-                                 Set_Etype (New_Aggr, Comp_Type);\n+                                 Set_Etype (New_Aggr, T);\n                                  Add_Association\n-                                   (Inner_Comp, New_Aggr,\n-                                    Component_Associations (Aggr));\n+                                   (Comp, New_Aggr,\n+                                     Component_Associations (Aggr));\n \n                                  --  Collect discriminant values and recurse\n \n                                  Add_Discriminant_Values\n                                    (New_Aggr, Assoc_List);\n                                  Propagate_Discriminants\n-                                   (New_Aggr, Assoc_List, Inner_Comp);\n+                                   (New_Aggr, Assoc_List);\n \n                               else\n                                  Needs_Box := True;\n                               end if;\n+                           end Process_Component;\n \n-                              Next_Component (Inner_Comp);\n-                           end loop;\n+                        begin\n+\n+                           --  The component type may be a variant type, so\n+                           --  collect the components that are ruled by the\n+                           --  known values of the discriminants.\n+\n+                           if Nkind (Def_Node) =  N_Record_Definition\n+                             and then\n+                               Present (Component_List (Def_Node))\n+                             and then\n+                               Present\n+                                 (Variant_Part (Component_List (Def_Node)))\n+                           then\n+                              Gather_Components (Aggr_Type,\n+                                Component_List (Def_Node),\n+                                Governed_By   => Assoc_List,\n+                                Into          => Components,\n+                                Report_Errors => Errors);\n+\n+                              Comp_Elmt := First_Elmt (Components);\n+                              while Present (Comp_Elmt) loop\n+                                 if\n+                                   Ekind (Node (Comp_Elmt)) /= E_Discriminant\n+                                 then\n+                                    Process_Component (Node (Comp_Elmt));\n+                                 end if;\n+\n+                                 Next_Elmt (Comp_Elmt);\n+                              end loop;\n+\n+                           --  No variant part, iterate over all components\n+\n+                           else\n+\n+                              Comp := First_Component (Etype (Aggr));\n+                              while Present (Comp) loop\n+                                 Process_Component (Comp);\n+                                 Next_Component (Comp);\n+                              end loop;\n+                           end if;\n \n                            if Needs_Box then\n                               Append\n@@ -3701,6 +3753,8 @@ package body Sem_Aggr is\n                            end if;\n                         end Propagate_Discriminants;\n \n+                        --  Start of processing for Capture_Discriminants\n+\n                      begin\n                         Expr := Make_Aggregate (Loc, New_List, New_List);\n                         Set_Etype (Expr, Ctyp);\n@@ -3713,14 +3767,13 @@ package body Sem_Aggr is\n \n                         if Has_Discriminants (Typ) then\n                            Add_Discriminant_Values (Expr, New_Assoc_List);\n-                           Propagate_Discriminants\n-                              (Expr, New_Assoc_List, Component);\n+                           Propagate_Discriminants (Expr, New_Assoc_List);\n \n                         elsif Has_Discriminants (Ctyp) then\n                            Add_Discriminant_Values\n                               (Expr,  Component_Associations (Expr));\n                            Propagate_Discriminants\n-                              (Expr, Component_Associations (Expr), Component);\n+                              (Expr, Component_Associations (Expr));\n \n                         else\n                            declare"}, {"sha": "6a4d514958cb7755c39cf994f34b334a1aff3fce", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 288, "deletions": 1, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=105b5e659ac30ffadc5d08448c1f2efccdf80148", "patch": "@@ -52,7 +52,6 @@ with Sem_Warn; use Sem_Warn;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n-with Table;\n with Targparm; use Targparm;\n with Ttypes;   use Ttypes;\n with Tbuild;   use Tbuild;\n@@ -4174,6 +4173,8 @@ package body Sem_Ch13 is\n \n    procedure Initialize is\n    begin\n+      Address_Clause_Checks.Init;\n+      Independence_Checks.Init;\n       Unchecked_Conversions.Init;\n    end Initialize;\n \n@@ -5069,6 +5070,292 @@ package body Sem_Ch13 is\n       end loop;\n    end Validate_Address_Clauses;\n \n+   ---------------------------\n+   -- Validate_Independence --\n+   ---------------------------\n+\n+   procedure Validate_Independence is\n+      SU   : constant Uint := UI_From_Int (System_Storage_Unit);\n+      N    : Node_Id;\n+      E    : Entity_Id;\n+      IC   : Boolean;\n+      Comp : Entity_Id;\n+      Addr : Node_Id;\n+      P    : Node_Id;\n+\n+      procedure Check_Array_Type (Atyp : Entity_Id);\n+      --  Checks if the array type Atyp has independent components, and\n+      --  if not, outputs an appropriate set of error messages.\n+\n+      procedure No_Independence;\n+      --  Output message that independence cannot be guaranteed\n+\n+      function OK_Component (C : Entity_Id) return Boolean;\n+      --  Checks one component to see if it is independently accessible, and\n+      --  if so yields True, otherwise yields False if independent access\n+      --  cannot be guaranteed. This is a conservative routine, it only\n+      --  returns True if it knows for sure, it returns False if it knows\n+      --  there is a problem, or it cannot be sure there is no problem.\n+\n+      procedure Reason_Bad_Component (C : Entity_Id);\n+      --  Outputs continuation message if a reason can be determined for\n+      --  the component C being bad.\n+\n+      ----------------------\n+      -- Check_Array_Type --\n+      ----------------------\n+\n+      procedure Check_Array_Type (Atyp : Entity_Id) is\n+         Ctyp : constant Entity_Id := Component_Type (Atyp);\n+\n+      begin\n+         --  OK if no alignment clause, no pack, and no component size\n+\n+         if not Has_Component_Size_Clause (Atyp)\n+           and then not Has_Alignment_Clause (Atyp)\n+           and then not Is_Packed (Atyp)\n+         then\n+            return;\n+         end if;\n+\n+         --  Check actual component size\n+\n+         if not Known_Component_Size (Atyp)\n+           or else not (Addressable (Component_Size (Atyp))\n+                          and then Component_Size (Atyp) < 64)\n+           or else Component_Size (Atyp) mod Esize (Ctyp) /= 0\n+         then\n+            No_Independence;\n+\n+            --  Bad component size, check reason\n+\n+            if Has_Component_Size_Clause (Atyp) then\n+               P :=\n+                 Get_Attribute_Definition_Clause\n+                   (Atyp, Attribute_Component_Size);\n+\n+               if Present (P) then\n+                  Error_Msg_Sloc := Sloc (P);\n+                  Error_Msg_N (\"\\because of Component_Size clause#\", N);\n+                  return;\n+               end if;\n+            end if;\n+\n+            if Is_Packed (Atyp) then\n+               P := Get_Rep_Pragma (Atyp, Name_Pack);\n+\n+               if Present (P) then\n+                  Error_Msg_Sloc := Sloc (P);\n+                  Error_Msg_N (\"\\because of pragma Pack#\", N);\n+                  return;\n+               end if;\n+            end if;\n+\n+            --  No reason found, just return\n+\n+            return;\n+         end if;\n+\n+         --  Array type is OK independence-wise\n+\n+         return;\n+      end Check_Array_Type;\n+\n+      ---------------------\n+      -- No_Independence --\n+      ---------------------\n+\n+      procedure No_Independence is\n+      begin\n+         if Pragma_Name (N) = Name_Independent then\n+            Error_Msg_NE\n+              (\"independence cannot be guaranteed for&\", N, E);\n+         else\n+            Error_Msg_NE\n+              (\"independent components cannot be guaranteed for&\", N, E);\n+         end if;\n+      end No_Independence;\n+\n+      ------------------\n+      -- OK_Component --\n+      ------------------\n+\n+      function OK_Component (C : Entity_Id) return Boolean is\n+         Rec  : constant Entity_Id := Scope (C);\n+         Ctyp : constant Entity_Id := Etype (C);\n+\n+      begin\n+         --  OK if no component clause, no Pack, and no alignment clause\n+\n+         if No (Component_Clause (C))\n+           and then not Is_Packed (Rec)\n+           and then not Has_Alignment_Clause (Rec)\n+         then\n+            return True;\n+         end if;\n+\n+         --  Here we look at the actual component layout. A component is\n+         --  addressable if its size is a multiple of the Esize of the\n+         --  component type, and its starting position in the record has\n+         --  appropriate alignment, and the record itself has appropriate\n+         --  alignment to guarantee the component alignment.\n+\n+         --  Make sure sizes are static, always assume the worst for any\n+         --  cases where we cannot check static values.\n+\n+         if not (Known_Static_Esize (C)\n+                  and then Known_Static_Esize (Ctyp))\n+         then\n+            return False;\n+         end if;\n+\n+         --  Size of component must be addressable or greater than 64 bits\n+         --  and a multiple of bytes.\n+\n+         if not Addressable (Esize (C))\n+           and then Esize (C) < Uint_64\n+         then\n+            return False;\n+         end if;\n+\n+         --  Check size is proper multiple\n+\n+         if Esize (C) mod Esize (Ctyp) /= 0 then\n+            return False;\n+         end if;\n+\n+         --  Check alignment of component is OK\n+\n+         if not Known_Component_Bit_Offset (C)\n+           or else Component_Bit_Offset (C) < Uint_0\n+           or else Component_Bit_Offset (C) mod Esize (Ctyp) /= 0\n+         then\n+            return False;\n+         end if;\n+\n+         --  Check alignment of record type is OK\n+\n+         if not Known_Alignment (Rec)\n+           or else (Alignment (Rec) * SU) mod Esize (Ctyp) /= 0\n+         then\n+            return False;\n+         end if;\n+\n+         --  All tests passed, component is addressable\n+\n+         return True;\n+      end OK_Component;\n+\n+      --------------------------\n+      -- Reason_Bad_Component --\n+      --------------------------\n+\n+      procedure Reason_Bad_Component (C : Entity_Id) is\n+         Rec  : constant Entity_Id := Scope (C);\n+         Ctyp : constant Entity_Id := Etype (C);\n+\n+      begin\n+         --  If component clause present assume that's the problem\n+\n+         if Present (Component_Clause (C)) then\n+            Error_Msg_Sloc := Sloc (Component_Clause (C));\n+            Error_Msg_N (\"\\because of Component_Clause#\", N);\n+            return;\n+         end if;\n+\n+         --  If pragma Pack clause present, assume that's the problem\n+\n+         if Is_Packed (Rec) then\n+            P := Get_Rep_Pragma (Rec, Name_Pack);\n+\n+            if Present (P) then\n+               Error_Msg_Sloc := Sloc (P);\n+               Error_Msg_N (\"\\because of pragma Pack#\", N);\n+               return;\n+            end if;\n+         end if;\n+\n+         --  See if record has bad alignment clause\n+\n+         if Has_Alignment_Clause (Rec)\n+           and then Known_Alignment (Rec)\n+           and then (Alignment (Rec) * SU) mod Esize (Ctyp) /= 0\n+         then\n+            P := Get_Attribute_Definition_Clause (Rec, Attribute_Alignment);\n+\n+            if Present (P) then\n+               Error_Msg_Sloc := Sloc (P);\n+               Error_Msg_N (\"\\because of Alignment clause#\", N);\n+            end if;\n+         end if;\n+\n+         --  Couldn't find a reason, so return without a message\n+\n+         return;\n+      end Reason_Bad_Component;\n+\n+   --  Start of processing for Validate_Independence\n+\n+   begin\n+      for J in Independence_Checks.First .. Independence_Checks.Last loop\n+         N  := Independence_Checks.Table (J).N;\n+         E  := Independence_Checks.Table (J).E;\n+         IC := Pragma_Name (N) = Name_Independent_Components;\n+\n+         --  Deal with component case\n+\n+         if Ekind (E) = E_Discriminant or else Ekind (E) = E_Component then\n+            if not OK_Component (E) then\n+               No_Independence;\n+               Reason_Bad_Component (E);\n+               goto Continue;\n+            end if;\n+         end if;\n+\n+         --  Deal with record with Independent_Components\n+\n+         if IC and then Is_Record_Type (E) then\n+            Comp := First_Component_Or_Discriminant (E);\n+            while Present (Comp) loop\n+               if not OK_Component (Comp) then\n+                  No_Independence;\n+                  Reason_Bad_Component (Comp);\n+                  goto Continue;\n+               end if;\n+\n+               Next_Component_Or_Discriminant (Comp);\n+            end loop;\n+         end if;\n+\n+         --  Deal with address clause case\n+\n+         if Is_Object (E) then\n+            Addr := Address_Clause (E);\n+\n+            if Present (Addr) then\n+               No_Independence;\n+               Error_Msg_Sloc := Sloc (Addr);\n+               Error_Msg_N (\"\\because of Address clause#\", N);\n+               goto Continue;\n+            end if;\n+         end if;\n+\n+         --  Deal with independent components for array type\n+\n+         if IC and then Is_Array_Type (E) then\n+            Check_Array_Type (E);\n+         end if;\n+\n+         --  Deal with independent components for array object\n+\n+         if IC and then Is_Object (E) and then Is_Array_Type (Etype (E)) then\n+            Check_Array_Type (Etype (E));\n+         end if;\n+\n+      <<Continue>> null;\n+      end loop;\n+   end Validate_Independence;\n+\n    -----------------------------------\n    -- Validate_Unchecked_Conversion --\n    -----------------------------------"}, {"sha": "5c960d7765e6406da47af1d1a85ac5a728c4b91d", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=105b5e659ac30ffadc5d08448c1f2efccdf80148", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Table;\n with Types; use Types;\n with Uintp; use Uintp;\n \n@@ -167,15 +168,45 @@ package Sem_Ch13 is\n    --  back end as required.\n \n    procedure Validate_Unchecked_Conversions;\n-   --  This routine is called after calling the backend to validate\n-   --  unchecked conversions for size and alignment appropriateness.\n-   --  The reason it is called that late is to take advantage of any\n-   --  back-annotation of size and alignment performed by the backend.\n+   --  This routine is called after calling the backend to validate unchecked\n+   --  conversions for size and alignment appropriateness. The reason it is\n+   --  called that late is to take advantage of any back-annotation of size\n+   --  and alignment performed by the backend.\n \n    procedure Validate_Address_Clauses;\n    --  This is called after the back end has been called (and thus after the\n    --  alignments of objects have been back annotated). It goes through the\n    --  table of saved address clauses checking for suspicious alignments and\n    --  if necessary issuing warnings.\n \n+   procedure Validate_Independence;\n+   --  This is called after the back end has been called (and thus after the\n+   --  layout of components has been back annotated). It goes through the\n+   --  table of saved pragma Independent[_Component] entries, checking that\n+   --  independence can be achieved, and if necessary issuing error mssags.\n+\n+   -------------------------------------\n+   -- Table for Validate_Independence --\n+   -------------------------------------\n+\n+   --  If a legal pragma Independent or Independent_Components is given for\n+   --  an entity, then an entry is made in this table, to be checked by a\n+   --  call to Validate_Independence after back annotation of layout is done.\n+\n+   type Independence_Check_Record is record\n+      N : Node_Id;\n+      --  The pragma Independent or Independent_Components\n+\n+      E : Entity_Id;\n+      --  The entity to which it applies\n+   end record;\n+\n+   package Independence_Checks is new Table.Table (\n+     Table_Component_Type => Independence_Check_Record,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 20,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Independence_Checks\");\n+\n end Sem_Ch13;"}, {"sha": "90e81f98b9a58236443330f1d958c2c85c693f3d", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=105b5e659ac30ffadc5d08448c1f2efccdf80148", "patch": "@@ -620,8 +620,7 @@ package body Sem_Ch6 is\n                   Subtype_Ind);\n             end if;\n \n-            --  AI05-103 : for elementary types, subtypes must statically\n-            --  match.\n+            --  AI05-103: for elementary types, subtypes must statically match\n \n             if Is_Constrained (R_Type)\n               or else Is_Access_Type (R_Type)"}, {"sha": "8c89ea02c9609c841e13adfd8863bb5ca9a4ef05", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=105b5e659ac30ffadc5d08448c1f2efccdf80148", "patch": "@@ -8378,6 +8378,113 @@ package body Sem_Prag is\n               Arg_First_Optional_Parameter => First_Optional_Parameter);\n          end Import_Valued_Procedure;\n \n+         -----------------\n+         -- Independent --\n+         -----------------\n+\n+         --  pragma Independent (LOCAL_NAME);\n+\n+         when Pragma_Independent => Independent : declare\n+            E_Id : Node_Id;\n+            E    : Entity_Id;\n+            D    : Node_Id;\n+            K    : Node_Kind;\n+\n+         begin\n+            Check_Ada_83_Warning;\n+            Ada_2012_Pragma;\n+            Check_No_Identifiers;\n+            Check_Arg_Count (1);\n+            Check_Arg_Is_Local_Name (Arg1);\n+            E_Id := Expression (Arg1);\n+\n+            if Etype (E_Id) = Any_Type then\n+               return;\n+            end if;\n+\n+            E := Entity (E_Id);\n+            D := Declaration_Node (E);\n+            K := Nkind (D);\n+\n+            if Is_Type (E) then\n+               if Rep_Item_Too_Early (E, N)\n+                    or else\n+                  Rep_Item_Too_Late (E, N)\n+               then\n+                  return;\n+               else\n+                  Check_First_Subtype (Arg1);\n+               end if;\n+\n+            elsif K = N_Object_Declaration\n+              or else (K = N_Component_Declaration\n+                       and then Original_Record_Component (E) = E)\n+            then\n+               if Rep_Item_Too_Late (E, N) then\n+                  return;\n+               end if;\n+\n+            else\n+               Error_Pragma_Arg\n+                 (\"inappropriate entity for pragma%\", Arg1);\n+            end if;\n+\n+            Independence_Checks.Append ((N, E));\n+         end Independent;\n+\n+         ----------------------------\n+         -- Independent_Components --\n+         ----------------------------\n+\n+         --  pragma Atomic_Components (array_LOCAL_NAME);\n+\n+         --  This processing is shared by Volatile_Components\n+\n+         when Pragma_Independent_Components => Independent_Components : declare\n+            E_Id : Node_Id;\n+            E    : Entity_Id;\n+            D    : Node_Id;\n+            K    : Node_Kind;\n+\n+         begin\n+            Check_Ada_83_Warning;\n+            Ada_2012_Pragma;\n+            Check_No_Identifiers;\n+            Check_Arg_Count (1);\n+            Check_Arg_Is_Local_Name (Arg1);\n+            E_Id := Expression (Arg1);\n+\n+            if Etype (E_Id) = Any_Type then\n+               return;\n+            end if;\n+\n+            E := Entity (E_Id);\n+\n+            if Rep_Item_Too_Early (E, N)\n+                 or else\n+               Rep_Item_Too_Late (E, N)\n+            then\n+               return;\n+            end if;\n+\n+            D := Declaration_Node (E);\n+            K := Nkind (D);\n+\n+            if (K = N_Full_Type_Declaration\n+                 and then (Is_Array_Type (E) or else Is_Record_Type (E)))\n+              or else\n+                ((Ekind (E) = E_Constant or else Ekind (E) = E_Variable)\n+                   and then Nkind (D) = N_Object_Declaration\n+                   and then Nkind (Object_Definition (D)) =\n+                                       N_Constrained_Array_Definition)\n+            then\n+               Independence_Checks.Append ((N, E));\n+\n+            else\n+               Error_Pragma_Arg (\"inappropriate entity for pragma%\", Arg1);\n+            end if;\n+         end Independent_Components;\n+\n          ------------------------\n          -- Initialize_Scalars --\n          ------------------------\n@@ -12971,6 +13078,8 @@ package body Sem_Prag is\n       Pragma_Import_Object                 =>  0,\n       Pragma_Import_Procedure              =>  0,\n       Pragma_Import_Valued_Procedure       =>  0,\n+      Pragma_Independent                   =>  0,\n+      Pragma_Independent_Components        =>  0,\n       Pragma_Initialize_Scalars            => -1,\n       Pragma_Inline                        =>  0,\n       Pragma_Inline_Always                 =>  0,"}, {"sha": "0c94966961eff261276e1294baf5d07db0eece9a", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105b5e659ac30ffadc5d08448c1f2efccdf80148/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=105b5e659ac30ffadc5d08448c1f2efccdf80148", "patch": "@@ -312,9 +312,13 @@ package Snames is\n    --  may be found in the appropriate section in unit Sem_Prag in file\n    --  sem-prag.adb, and they are documented in the GNAT reference manual.\n \n-   --  The entries marked Ada05 are Ada 2005 pragmas. They are implemented in\n-   --  Ada 83 and Ada 95 mode as well, where they are technically considered to\n-   --  be implementation dependent pragmas.\n+   --  The entries marked Ada 05 are Ada 2005 pragmas. They are implemented\n+   --  in Ada 83 and Ada 95 mode as well, where they are technically considered\n+   --  to be implementation dependent pragmas.\n+\n+   --  The entries marked Ada 12 are Ada 2012 pragmas. They are implemented\n+   --  in Ada 83, Ada 95, and Ada 2005 mode as well, where they are technically\n+   --  considered to be implementation dependent pragmas.\n \n    --  The entries marked VMS are VMS specific pragmas that are recognized\n    --  only in OpenVMS versions of GNAT. They are ignored in other versions\n@@ -407,7 +411,7 @@ package Snames is\n    Name_All_Calls_Remote               : constant Name_Id := N + $;\n    Name_Annotate                       : constant Name_Id := N + $; -- GNAT\n \n-   --  Note: AST_Entry is not in this list because its name matches   -- VMS\n+   --  Note: AST_Entry is not in this list because its name matches -- VMS\n    --  the name of the corresponding attribute. However, it is\n    --  included in the definition of the type Pragma_Id, and the\n    --  functions Get_Pragma_Id and Is_Pragma_Id correctly recognize\n@@ -452,13 +456,15 @@ package Snames is\n    Name_Import_Object                  : constant Name_Id := N + $; -- GNAT\n    Name_Import_Procedure               : constant Name_Id := N + $; -- GNAT\n    Name_Import_Valued_Procedure        : constant Name_Id := N + $; -- GNAT\n+   Name_Independent                    : constant Name_Id := N + $; -- Ada 12\n+   Name_Independent_Components         : constant Name_Id := N + $; -- Ada 12\n    Name_Inline                         : constant Name_Id := N + $;\n    Name_Inline_Always                  : constant Name_Id := N + $; -- GNAT\n    Name_Inline_Generic                 : constant Name_Id := N + $; -- GNAT\n    Name_Inspection_Point               : constant Name_Id := N + $;\n \n    --  Note: Interface is not in this list because its name         -- GNAT\n-   --  matches an Ada 2005 keyword. However it is included in\n+   --  matches an Ada 05 keyword. However it is included in\n    --  the definition of the type Attribute_Id, and the functions\n    --  Get_Pragma_Id and Is_Pragma_Id correctly recognize and\n    --  process Name_Storage_Size.\n@@ -1172,7 +1178,7 @@ package Snames is\n \n    Name_Unaligned_Valid                  : constant Name_Id := N + $;\n \n-   --  Ada 2005 reserved words\n+   --  Ada 05 reserved words\n \n    First_2005_Reserved_Word              : constant Name_Id := N + $;\n    Name_Interface                        : constant Name_Id := N + $;\n@@ -1531,6 +1537,8 @@ package Snames is\n       Pragma_Import_Object,\n       Pragma_Import_Procedure,\n       Pragma_Import_Valued_Procedure,\n+      Pragma_Independent,\n+      Pragma_Independent_Components,\n       Pragma_Inline,\n       Pragma_Inline_Always,\n       Pragma_Inline_Generic,"}]}