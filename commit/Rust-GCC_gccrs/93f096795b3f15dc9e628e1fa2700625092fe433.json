{"sha": "93f096795b3f15dc9e628e1fa2700625092fe433", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNmMDk2Nzk1YjNmMTVkYzllNjI4ZTFmYTI3MDA2MjUwOTJmZTQzMw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-05-30T17:49:31Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2019-05-30T17:49:31Z"}, "message": "gfc-internals.texi (Translating to GENERIC): New chapter.\n\n2019-05-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n    * gfc-internals.texi (Translating to GENERIC): New chapter.\n\nFrom-SVN: r271786", "tree": {"sha": "1d0cd7e9a769e8f91eb7784507cd97763662fa06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d0cd7e9a769e8f91eb7784507cd97763662fa06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93f096795b3f15dc9e628e1fa2700625092fe433", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93f096795b3f15dc9e628e1fa2700625092fe433", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93f096795b3f15dc9e628e1fa2700625092fe433", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93f096795b3f15dc9e628e1fa2700625092fe433/comments", "author": null, "committer": null, "parents": [{"sha": "3db85990dbde7f9c8212fe0fb8a241c5d2993198", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3db85990dbde7f9c8212fe0fb8a241c5d2993198", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3db85990dbde7f9c8212fe0fb8a241c5d2993198"}], "stats": {"total": 147, "additions": 147, "deletions": 0}, "files": [{"sha": "16cc7e9cfaf237b04a8539aff800c6b2bfc73534", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f096795b3f15dc9e628e1fa2700625092fe433/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f096795b3f15dc9e628e1fa2700625092fe433/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=93f096795b3f15dc9e628e1fa2700625092fe433", "patch": "@@ -1,3 +1,7 @@\n+2019-05-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+    * gfc-internals.texi (Translating to GENERIC): New chapter.\n+\n 2019-05-30  Marek Polacek  <polacek@redhat.com>\n \n \t* lang.opt (ftail-call-workaround): Fix a typo."}, {"sha": "2c30aa60d4cd7b9365960fc0dab33f8d8c0461a4", "filename": "gcc/fortran/gfc-internals.texi", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93f096795b3f15dc9e628e1fa2700625092fe433/gcc%2Ffortran%2Fgfc-internals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93f096795b3f15dc9e628e1fa2700625092fe433/gcc%2Ffortran%2Fgfc-internals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfc-internals.texi?ref=93f096795b3f15dc9e628e1fa2700625092fe433", "patch": "@@ -119,6 +119,8 @@ not accurately reflect the status of the most recent GNU Fortran compiler.\n * Frontend Data Structures::\n                            Data structures used by the frontend\n * Object Orientation::     Internals of Fortran 2003 OOP features.\n+* Translating to GENERIC::\n+                           Generating the intermediate language for later stages.\n * LibGFortran::            The LibGFortran Runtime Library.\n * GNU Free Documentation License::\n                            How you can copy and share this manual.\n@@ -724,6 +726,147 @@ operator call is replaced with an internally generated @code{GENERIC}\n type-bound procedure call to the respective definition and that call is\n further processed.\n \n+@c ---------------------------------------------------------------------\n+@c - Translating to GENERIC\n+@c ---------------------------------------------------------------------\n+\n+@node Translating to GENERIC\n+@chapter Generating the intermediate language for later stages.\n+\n+This chapter deals with the transformation of gfortran's frontend data\n+structures to the intermediate language used by the later stages of\n+the compiler, the so-called middle end.\n+\n+Data structures relating to this are found in the source files\n+@file{trans*.h} and @file{trans-*.c}.\n+\n+@menu\n+* Basic Data Structures::       Basic data structures.\n+* Converting Expressions::      Converting expressions to tree.\n+* Translating Statements::      Translating statements.\n+* Accessing Declarations::      Accessing declarations.\n+@end menu\n+\n+@node Basic Data Structures\n+@section Basic data structures\n+\n+Gfortran creates GENERIC as an intermediate language for the\n+middle-end. Details about GENERIC can be found in the GCC manual.\n+\n+The basic data structure of GENERIC is a @code{tree}. Everything in\n+GENERIC is a @code{tree}, including types and statements.  Fortunately\n+for the gfortran programmer, @code{tree} variables are\n+garbage-collected, so doing memory management for them is not\n+necessary.\n+\n+@code{tree} expressions are built using functions such as, for\n+example, @code{fold_build2_loc}.  For two tree variables @code{a} and\n+@code{b}, both of which have the type @code{gfc_arry_index_type},\n+calculation @code{c = a * b} would be done by\n+\n+@smallexample\n+c = fold_build2_loc (input_location, MULT_EXPR,\n+                     gfc_array_index_type, a, b);\n+@end smallexample\n+\n+The types have to agree, otherwise internal compiler errors will occur\n+at a later stage.  Expressions can be converted to a different type\n+using @code{fold_convert}.\n+\n+Accessing individual members in the @code{tree} structures should not\n+be done. Rather, access should be done via macros.\n+\n+One basic data structure is the @code{stmtblock_t} struct. This is\n+used for holding a list of statements, expressed as @code{tree}\n+expressions.  If a block is created using @code{gfc_start_block}, it\n+has its own scope for variables; if it is created using\n+@code{gfc_init_block}, it does not have its own scope.\n+\n+It is possible to\n+@itemize @bullet\n+@item Add an expression to the end of a block using\n+      @code{gfc_add_expr_to_block}\n+@item Add an expression to the beginning of a block using\n+      @code{void gfc_prepend_expr_to_block}\n+@item Make a block into a single @code{tree} using\n+      @code{gfc_finish_block}.  For example, this is needed to put the\n+      contents of a block into the @code{if} or @code{else} branch of\n+      a @code{COND_EXPR}.\n+@end itemize\n+\n+Variables are also @code{tree} expressions, they can be created using\n+@code{gfc_create_var}. Assigning to a variable can be done with\n+@code{gfc_add_modify}.\n+\n+An example: Creating a default integer type variable in the current\n+scope with the prefix ``everything'' in the @code{stmt_block}\n+@code{block} and assigning the value 42 would be\n+\n+@smallexample\n+tree var, *block;\n+/* Initialize block somewhere here.  */\n+var = gfc_create_var (integer_type_node, \"everything\");\n+gfc_add_modify (block, var, build_int_cst (integer_type_node, 42));\n+@end smallexample\n+\n+@node Converting Expressions\n+@section Converting Expressons to tree\n+\n+Converting expressions to @code{tree} is done by functions called\n+@code{gfc_conv_*}.\n+\n+The central data structure for a GENERIC expression is the\n+@code{gfc_se} structure.  Its @code{expr} member is a @code{tree} that\n+holds the value of the expression.  A @code{gfc_se} structure is\n+initialized using @code{gfc_init_se}; it needs to be embedded in an\n+outer @code{gfc_se}.\n+\n+Evaluating Fortran expressions often require things to be done before\n+and after evaluation of the expression, for example code for the\n+allocation of a temporary variable and its subsequent deallocation.\n+Therefore, @code{gfc_se} contains the members @code{pre} and\n+@code{post}, which point to @code{stmt_block} blocks for code that\n+needs to be executed before and after evaluation of the expression.\n+\n+When using a local @code{gfc_se} to convert some expression, it is\n+often necessary to add the generated @code{pre} and @code{post} blocks\n+to the @code{pre} or @code{post} blocks of the outer @code{gfc_se}.\n+Code like this (lifted from @file{trans-expr.c}) is fairly common:\n+\n+@smallexample\n+gfc_se cont_se;\n+tree cont_var;\n+\n+/* cont_var = is_contiguous (expr); .  */\n+gfc_init_se (&cont_se, parmse);\n+gfc_conv_is_contiguous_expr (&cont_se, expr);\n+gfc_add_block_to_block (&se->pre, &(&cont_se)->pre);\n+gfc_add_modify (&se->pre, cont_var, cont_se.expr);\n+gfc_add_block_to_block (&se->pre, &(&cont_se)->post);\n+@end smallexample\n+\n+Conversion functions which need a @code{gfc_se} structure will have a\n+corresponding argument.\n+\n+@code{gfc_se} also contains pointers to a @code{gfc_ss} and a\n+@code{gfc_loopinfo} structure.  These are needed by the scalarizer.\n+\n+@node Translating Statements\n+@section Translating statements\n+Translating statements to @code{tree} is done by functions called\n+@code{gfc_trans_*}.  These functions usually get passed a\n+@code{gfc_code} structure, evaluate any expressions and then\n+return a @code{tree} structure.\n+\n+@node Accessing Declarations\n+@section Accessing declarations\n+\n+@code{gfc_symbol}, @code{gfc_charlen} and other front-end structures\n+contain a @code{backend_decl} variable, which contains the @code{tree}\n+used for accessing that entity in the middle-end.\n+\n+Accessing declarations is usually done by functions called\n+@code{gfc_get*}.\n \n @c ---------------------------------------------------------------------\n @c LibGFortran"}]}