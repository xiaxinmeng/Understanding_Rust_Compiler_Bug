{"sha": "47d13acbda9a5d8eb57ff169ba74857cd54108e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdkMTNhY2JkYTlhNWQ4ZWI1N2ZmMTY5YmE3NDg1N2NkNTQxMDhlNA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2020-10-25T12:16:16Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2020-10-25T12:17:06Z"}, "message": "Correct decls for functions which do not pass actual arguments.\n\nA wrong decl for findloc caused segfaults at runtime on\nDarwin for ARM; however, this is only a symptom of a larger\ndisease: The declarations for our library functions are often\ninconsistent.  This patch solves that problem for the functions\nspecifically for the functions for which we do not pass optional\narguments, i.e. findloc and (min|max)loc.\n\nIt works by saving the symbols of the specific functions in\ngfc_intrinsic_namespace and by generating the formal argument\nlists from the actual argument lists.  Because symbols are\nre-used, so are the backend decls.\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/97454\n\t* gfortran.h (gfc_symbol): Add pass_as_value flag.\n\t(gfc_copy_formal_args_intr): Add optional argument\n\tcopy_type.\n\t(gfc_get_intrinsic_function_symbol): Add prototype.\n\t(gfc_find_intrinsic_symbol): Add prototype.\n\t* intrinsic.c (gfc_get_intrinsic_function_symbol): New function.\n\t(gfc_find_intrinsic_symbol): New function.\n\t* symbol.c (gfc_copy_formal_args_intr): Add argument. Handle case\n\twhere the type needs to be copied from the actual argument.\n\t* trans-intrinsic.c (remove_empty_actual_arguments): New function.\n\t(specific_intrinsic_symbol): New function.\n\t(gfc_conv_intrinsic_funcall): Use it.\n\t(strip_kind_from_actual): Adjust so that the expression pointer\n\tis set to NULL.\n\t(gfc_conv_intrinsic_minmaxloc): Likewise.\n\t(gfc_conv_intrinsic_minmaxval): Adjust removal of dim.\n\t* trans-types.c (gfc_sym_type): If sym->pass_as_value is set, do\n\tnot pass by reference.", "tree": {"sha": "9f8172cd70724fd0abd232cfc3679e8448a8db7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f8172cd70724fd0abd232cfc3679e8448a8db7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47d13acbda9a5d8eb57ff169ba74857cd54108e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d13acbda9a5d8eb57ff169ba74857cd54108e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47d13acbda9a5d8eb57ff169ba74857cd54108e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47d13acbda9a5d8eb57ff169ba74857cd54108e4/comments", "author": null, "committer": null, "parents": [{"sha": "d7ddd287ca76e87f431f43687de6d8cc48e52543", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7ddd287ca76e87f431f43687de6d8cc48e52543", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7ddd287ca76e87f431f43687de6d8cc48e52543"}], "stats": {"total": 195, "additions": 155, "deletions": 40}, "files": [{"sha": "73b6ffd870c05ef76206caa76674079377cfaec1", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d13acbda9a5d8eb57ff169ba74857cd54108e4/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d13acbda9a5d8eb57ff169ba74857cd54108e4/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=47d13acbda9a5d8eb57ff169ba74857cd54108e4", "patch": "@@ -1673,6 +1673,9 @@ typedef struct gfc_symbol\n   /* Set if the dummy argument of a procedure could be an array despite\n      being called with a scalar actual argument. */\n   unsigned maybe_array:1;\n+  /* Set if this should be passed by value, but is not a VALUE argument\n+     according to the Fortran standard.  */\n+  unsigned pass_as_value:1;\n \n   int refs;\n   struct gfc_namespace *ns;\t/* namespace containing this symbol */\n@@ -3248,7 +3251,7 @@ bool gfc_type_is_extension_of (gfc_symbol *, gfc_symbol *);\n bool gfc_type_compatible (gfc_typespec *, gfc_typespec *);\n \n void gfc_copy_formal_args_intr (gfc_symbol *, gfc_intrinsic_sym *,\n-\t\t\t\tgfc_actual_arglist *);\n+\t\t\t\tgfc_actual_arglist *, bool copy_type = false);\n \n void gfc_free_finalizer (gfc_finalizer *el); /* Needed in resolve.c, too  */\n \n@@ -3273,6 +3276,8 @@ void gfc_intrinsic_done_1 (void);\n \n char gfc_type_letter (bt, bool logical_equals_int = false);\n gfc_symbol * gfc_get_intrinsic_sub_symbol (const char *);\n+gfc_symbol *gfc_get_intrinsic_function_symbol (gfc_expr *);\n+gfc_symbol *gfc_find_intrinsic_symbol (gfc_expr *);\n bool gfc_convert_type (gfc_expr *, gfc_typespec *, int);\n bool gfc_convert_type_warn (gfc_expr *, gfc_typespec *, int, int,\n \t\t\t    bool array = false);"}, {"sha": "07b953abfc868e086bfc89615272296c0942dfa4", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d13acbda9a5d8eb57ff169ba74857cd54108e4/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d13acbda9a5d8eb57ff169ba74857cd54108e4/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=47d13acbda9a5d8eb57ff169ba74857cd54108e4", "patch": "@@ -122,6 +122,43 @@ gfc_get_intrinsic_sub_symbol (const char *name)\n   return sym;\n }\n \n+/* Get a symbol for a resolved function, with its special name.  The\n+   actual argument list needs to be set by the caller.  */\n+\n+gfc_symbol *\n+gfc_get_intrinsic_function_symbol (gfc_expr *expr)\n+{\n+  gfc_symbol *sym;\n+\n+  gfc_get_symbol (expr->value.function.name, gfc_intrinsic_namespace, &sym);\n+  sym->attr.external = 1;\n+  sym->attr.function = 1;\n+  sym->attr.always_explicit = 1;\n+  sym->attr.proc = PROC_INTRINSIC;\n+  sym->attr.flavor = FL_PROCEDURE;\n+  sym->result = sym;\n+  if (expr->rank > 0)\n+    {\n+      sym->attr.dimension = 1;\n+      sym->as = gfc_get_array_spec ();\n+      sym->as->type = AS_ASSUMED_SHAPE;\n+      sym->as->rank = expr->rank;\n+    }\n+  return sym;\n+}\n+\n+/* Find a symbol for a resolved intrinsic procedure, return NULL if\n+   not found.  */\n+\n+gfc_symbol *\n+gfc_find_intrinsic_symbol (gfc_expr *expr)\n+{\n+  gfc_symbol *sym;\n+  gfc_find_symbol (expr->value.function.name, gfc_intrinsic_namespace,\n+\t\t   0, &sym);\n+  return sym;\n+}\n+\n \n /* Return a pointer to the name of a conversion function given two\n    typespecs.  */"}, {"sha": "a112c813124a3bad2c3aae73a0d756c2830f780d", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d13acbda9a5d8eb57ff169ba74857cd54108e4/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d13acbda9a5d8eb57ff169ba74857cd54108e4/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=47d13acbda9a5d8eb57ff169ba74857cd54108e4", "patch": "@@ -4645,12 +4645,13 @@ add_proc_interface (gfc_symbol *sym, ifsrc source, gfc_formal_arglist *formal)\n    declaration statement (see match_proc_decl()) to create the formal\n    args based on the args of a given named interface.\n \n-   When an actual argument list is provided, skip the absent arguments.\n+   When an actual argument list is provided, skip the absent arguments\n+   unless copy_type is true.\n    To be used together with gfc_se->ignore_optional.  */\n \n void\n gfc_copy_formal_args_intr (gfc_symbol *dest, gfc_intrinsic_sym *src,\n-\t\t\t   gfc_actual_arglist *actual)\n+\t\t\t   gfc_actual_arglist *actual, bool copy_type)\n {\n   gfc_formal_arglist *head = NULL;\n   gfc_formal_arglist *tail = NULL;\n@@ -4677,13 +4678,27 @@ gfc_copy_formal_args_intr (gfc_symbol *dest, gfc_intrinsic_sym *src,\n \t      act_arg = act_arg->next;\n \t      continue;\n \t    }\n-\t  act_arg = act_arg->next;\n \t}\n       formal_arg = gfc_get_formal_arglist ();\n       gfc_get_symbol (curr_arg->name, gfc_current_ns, &(formal_arg->sym));\n \n       /* May need to copy more info for the symbol.  */\n-      formal_arg->sym->ts = curr_arg->ts;\n+      if (copy_type && act_arg->expr != NULL)\n+\t{\n+\t  formal_arg->sym->ts = act_arg->expr->ts;\n+\t  if (act_arg->expr->rank > 0)\n+\t    {\n+\t      formal_arg->sym->attr.dimension = 1;\n+\t      formal_arg->sym->as = gfc_get_array_spec();\n+\t      formal_arg->sym->as->rank = -1;\n+\t      formal_arg->sym->as->type = AS_ASSUMED_RANK;\n+\t    }\n+\t  if (act_arg->name && strcmp (act_arg->name, \"%VAL\") == 0)\n+\t    formal_arg->sym->pass_as_value = 1;\n+\t}\n+      else\n+\tformal_arg->sym->ts = curr_arg->ts;\n+\n       formal_arg->sym->attr.optional = curr_arg->optional;\n       formal_arg->sym->attr.value = curr_arg->value;\n       formal_arg->sym->attr.intent = curr_arg->intent;\n@@ -4708,6 +4723,8 @@ gfc_copy_formal_args_intr (gfc_symbol *dest, gfc_intrinsic_sym *src,\n \n       /* Validate changes.  */\n       gfc_commit_symbol (formal_arg->sym);\n+      if (actual)\n+\tact_arg = act_arg->next;\n     }\n \n   /* Add the interface to the symbol.  */"}, {"sha": "e0afc10d105def27698522999d13c13d58e55520", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 89, "deletions": 34, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d13acbda9a5d8eb57ff169ba74857cd54108e4/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d13acbda9a5d8eb57ff169ba74857cd54108e4/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=47d13acbda9a5d8eb57ff169ba74857cd54108e4", "patch": "@@ -4238,12 +4238,60 @@ gfc_get_symbol_for_expr (gfc_expr * expr, bool ignore_optional)\n   return sym;\n }\n \n+/* Remove empty actual arguments.  */\n+\n+static void\n+remove_empty_actual_arguments (gfc_actual_arglist **ap)\n+{\n+  while (*ap)\n+    {\n+      if ((*ap)->expr == NULL)\n+\t{\n+\t  gfc_actual_arglist *r = *ap;\n+\t  *ap = r->next;\n+\t  r->next = NULL;\n+\t  gfc_free_actual_arglist (r);\n+\t}\n+      else\n+\tap = &((*ap)->next);\n+    }\n+}\n+\n+/* Generate the right symbol for the specific intrinsic function and\n+ modify the expr accordingly.  This assumes that absent optional\n+ arguments should be removed.  FIXME: This should be extended for\n+ procedures which do not ignore optional arguments (PR 97454).  */\n+\n+gfc_symbol *\n+specific_intrinsic_symbol (gfc_expr *expr)\n+{\n+  gfc_symbol *sym;\n+\n+  sym = gfc_find_intrinsic_symbol (expr);\n+  if (sym == NULL)\n+    {\n+      sym = gfc_get_intrinsic_function_symbol (expr);\n+      sym->ts = expr->ts;\n+      if (sym->ts.type == BT_CHARACTER && sym->ts.u.cl)\n+\tsym->ts.u.cl = gfc_new_charlen (sym->ns, NULL);\n+\n+      gfc_copy_formal_args_intr (sym, expr->value.function.isym,\n+\t\t\t\t expr->value.function.actual, true);\n+      sym->backend_decl\n+\t= gfc_get_extern_function_decl (sym, expr->value.function.actual);\n+    }\n+  remove_empty_actual_arguments (&(expr->value.function.actual));\n+\n+  return sym;\n+}\n+\n /* Generate a call to an external intrinsic function.  */\n static void\n gfc_conv_intrinsic_funcall (gfc_se * se, gfc_expr * expr)\n {\n   gfc_symbol *sym;\n   vec<tree, va_gc> *append_args;\n+  bool specific_symbol;\n \n   gcc_assert (!se->ss || se->ss->info->expr == expr);\n \n@@ -4252,7 +4300,28 @@ gfc_conv_intrinsic_funcall (gfc_se * se, gfc_expr * expr)\n   else\n     gcc_assert (expr->rank == 0);\n \n-  sym = gfc_get_symbol_for_expr (expr, se->ignore_optional);\n+  switch (expr->value.function.isym->id)\n+    {\n+    case GFC_ISYM_FINDLOC:\n+    case GFC_ISYM_MAXLOC:\n+    case GFC_ISYM_MINLOC:\n+    case GFC_ISYM_MAXVAL:\n+    case GFC_ISYM_MINVAL:\n+      specific_symbol = true;\n+      break;\n+    default:\n+      specific_symbol = false;\n+    }\n+\n+  if (specific_symbol)\n+    {\n+      /* Need to copy here because specific_intrinsic_symbol modifies\n+\t expr to omit the absent optional arguments.  */\n+      expr = gfc_copy_expr (expr);\n+      sym = specific_intrinsic_symbol (expr);\n+    }\n+  else\n+    sym = gfc_get_symbol_for_expr (expr, se->ignore_optional);\n \n   /* Calls to libgfortran_matmul need to be appended special arguments,\n      to be able to call the BLAS ?gemm functions if required and possible.  */\n@@ -4302,7 +4371,11 @@ gfc_conv_intrinsic_funcall (gfc_se * se, gfc_expr * expr)\n \n   gfc_conv_procedure_call (se, sym, expr->value.function.actual, expr,\n \t\t\t  append_args);\n-  gfc_free_symbol (sym);\n+\n+  if (specific_symbol)\n+    gfc_free_expr (expr);\n+  else\n+    gfc_free_symbol (sym);\n }\n \n /* ANY and ALL intrinsics. ANY->op == NE_EXPR, ALL->op == EQ_EXPR.\n@@ -5081,12 +5154,10 @@ strip_kind_from_actual (gfc_actual_arglist * actual)\n {\n   for (gfc_actual_arglist *a = actual; a; a = a->next)\n     {\n-      gfc_actual_arglist *b = a->next;\n-      if (b && b->name && strcmp (b->name, \"kind\") == 0)\n+      if (a && a->name && strcmp (a->name, \"kind\") == 0)\n \t{\n-\t  a->next = b->next;\n-\t  b->next = NULL;\n-\t  gfc_free_actual_arglist (b);\n+\t  gfc_free_expr (a->expr);\n+\t  a->expr = NULL;\n \t}\n     }\n }\n@@ -5224,20 +5295,17 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   if (arrayexpr->ts.type == BT_CHARACTER)\n     {\n-      gfc_actual_arglist *a, *b;\n+      gfc_actual_arglist *a;\n       a = actual;\n       strip_kind_from_actual (a);\n-      while (a->next)\n+      while (a)\n \t{\n-\t  b = a->next;\n-\t  if (b->expr == NULL || strcmp (b->name, \"dim\") == 0)\n+\t  if (a->name && strcmp (a->name, \"dim\") == 0)\n \t    {\n-\t      a->next = b->next;\n-\t      b->next = NULL;\n-\t      gfc_free_actual_arglist (b);\n+\t      gfc_free_expr (a->expr);\n+\t      a->expr = NULL;\n \t    }\n-\t  else\n-\t    a = b;\n+\t  a = a->next;\n \t}\n       gfc_conv_intrinsic_funcall (se, expr);\n       return;\n@@ -5996,29 +6064,16 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   if (arrayexpr->ts.type == BT_CHARACTER)\n     {\n-      gfc_actual_arglist *a2, *a3;\n-      a2 = actual->next;  /* dim */\n-      a3 = a2->next;      /* mask */\n-      if (a2->expr == NULL || expr->rank == 0)\n+      gfc_actual_arglist *dim = actual->next;\n+      if (expr->rank == 0 && dim->expr != 0)\n \t{\n-\t  if (a3->expr == NULL)\n-\t    actual->next = NULL;\n-\t  else\n-\t    {\n-\t      actual->next = a3;\n-\t      a2->next = NULL;\n-\t    }\n-\t  gfc_free_actual_arglist (a2);\n+\t  gfc_free_expr (dim->expr);\n+\t  dim->expr = NULL;\n \t}\n-      else\n-\tif (a3->expr == NULL)\n-\t  {\n-\t    a2->next = NULL;\n-\t    gfc_free_actual_arglist (a3);\n-\t  }\n       gfc_conv_intrinsic_funcall (se, expr);\n       return;\n     }\n+\n   type = gfc_typenode_for_spec (&expr->ts);\n   /* Initialize the result.  */\n   limit = gfc_create_var (type, \"limit\");"}, {"sha": "b15ea6674113dcfd5eef40b7f5bb22d2d185d3f4", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47d13acbda9a5d8eb57ff169ba74857cd54108e4/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47d13acbda9a5d8eb57ff169ba74857cd54108e4/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=47d13acbda9a5d8eb57ff169ba74857cd54108e4", "patch": "@@ -2246,7 +2246,8 @@ gfc_sym_type (gfc_symbol * sym)\n   else\n     type = gfc_typenode_for_spec (&sym->ts, sym->attr.codimension);\n \n-  if (sym->attr.dummy && !sym->attr.function && !sym->attr.value)\n+  if (sym->attr.dummy && !sym->attr.function && !sym->attr.value\n+      && !sym->pass_as_value)\n     byref = 1;\n   else\n     byref = 0;"}]}