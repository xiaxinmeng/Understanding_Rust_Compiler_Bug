{"sha": "08703ee42389bed934a8529f4a16f56b061f36c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg3MDNlZTQyMzg5YmVkOTM0YTg1MjlmNGExNmY1NmIwNjFmMzZjNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-13T10:34:08Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-13T10:34:08Z"}, "message": "(QUAL_UNION_TYPE): New tree code.\n\nFrom-SVN: r4115", "tree": {"sha": "e2d0cde5f04a31c752255f1723590dd9a5486327", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2d0cde5f04a31c752255f1723590dd9a5486327"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08703ee42389bed934a8529f4a16f56b061f36c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08703ee42389bed934a8529f4a16f56b061f36c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08703ee42389bed934a8529f4a16f56b061f36c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08703ee42389bed934a8529f4a16f56b061f36c6/comments", "author": null, "committer": null, "parents": [{"sha": "88ee26514d0e02c39cd37fa568fdfbad6724c57f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88ee26514d0e02c39cd37fa568fdfbad6724c57f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88ee26514d0e02c39cd37fa568fdfbad6724c57f"}], "stats": {"total": 28, "additions": 19, "deletions": 9}, "files": [{"sha": "9bc81e7ad44c7f80c2bba2905727bae73f21ed35", "filename": "gcc/tree.def", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08703ee42389bed934a8529f4a16f56b061f36c6/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08703ee42389bed934a8529f4a16f56b061f36c6/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=08703ee42389bed934a8529f4a16f56b061f36c6", "patch": "@@ -111,13 +111,15 @@ DEFTREECODE (BLOCK, \"block\", \"b\", 0)\n     will point to a BLOCK node or a FUNCTION_DECL node, but it could also\n     point to a FUNCTION_TYPE node (for types whose scope is limited to the\n     formal parameter list of some function type specification) or it\n-    could point to a RECORD_TYPE or UNION_TYPE node (for C++ \"member\" types).\n+    could point to a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE node\n+    (for C++ \"member\" types).\n     For non-tagged-types, TYPE_CONTEXT need not be set to anything in\n     particular, since any type which is of some type category  (e.g.\n     an array type or a function type) which cannot either have a name\n-    itself or have named members doesn't really have a \"scope\" per se.  */\n-/* TREE_CHAIN is used for ENUMERAL_TYPE, RECORD_TYPE and UNION_TYPE\n-   nodes used as forward-references to names; see below.  */\n+    itself or have named members doesn't really have a \"scope\" per se.\n+  The TREE_CHAIN field is used as a forward-references to names for\n+    ENUMERAL_TYPE, RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE nodes;\n+    see below.  */\n \n DEFTREECODE (VOID_TYPE, \"void_type\", \"t\", 0)\t/* The void type in C */\n \n@@ -148,7 +150,8 @@ DEFTREECODE (COMPLEX_TYPE, \"complex_type\", \"t\", 0)\n    has zero (a null pointer) in its TYPE_SIZE.  The tag name is in\n    the TYPE_NAME field.  If the type is later defined, the normal\n    fields are filled in.\n-   RECORD_TYPE and UNION_TYPE forward refs are treated similarly.  */\n+   RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE forward refs are\n+   treated similarly.  */\n DEFTREECODE (ENUMERAL_TYPE, \"enumeral_type\", \"t\", 0)\n \n /* Pascal's boolean type (true or false are the only values);\n@@ -216,6 +219,12 @@ DEFTREECODE (RECORD_TYPE, \"record_type\", \"t\", 0)\n    forward references to union tags are handled in C.  */\n DEFTREECODE (UNION_TYPE, \"union_type\", \"t\", 0)\t/* C union type */\n \n+/* Similar to UNION_TYPE, except that the expressions in DECL_QUALIFIER\n+   in each FIELD_DECL determine what the union contains.  The first\n+   field whose DECL_QUALIFIER expression is true is deemed to occupy\n+   the union.  */\n+DEFTREECODE (QUAL_UNION_TYPE, \"qual_union_type\", \"t\", 0)\n+\n /* Type of functions.  Special fields:\n    TREE_TYPE\t\t    type of value returned.\n    TYPE_ARG_TYPES      list of types of arguments expected.\n@@ -259,10 +268,11 @@ DEFTREECODE (STRING_CST, \"string_cst\", \"c\", 3)\n     (Some decls, most often labels, may have zero as the DECL_NAME).\n    DECL_CONTEXT points to the node representing the context in which\n     this declaration has its scope.  For FIELD_DECLs, this is the\n-    RECORD_TYPE or UNION_TYPE node that the field is a member of.  For\n-    VAR_DECL, PARM_DECL, FUNCTION_DECL, LABEL_DECL, and CONST_DECL nodes,\n-    this points to the FUNCTION_DECL for the containing function, or else\n-    yields NULL_TREE if the given decl has \"file scope\".\n+    RECORD_TYPE, UNION_TYPE, or QUAL_UNION_TYPE node that the field\n+    is a member of.  For VAR_DECL, PARM_DECL, FUNCTION_DECL, LABEL_DECL,\n+    and CONST_DECL nodes, this points to the FUNCTION_DECL for the\n+    containing function, or else yields NULL_TREE if the given decl\n+    has \"file scope\".\n    DECL_ABSTRACT_ORIGIN, if non-NULL, points to the original (abstract)\n     ..._DECL node of which this decl is an (inlined or template expanded)\n     instance."}]}