{"sha": "abe08b7d909d27884e9f5f2cb879739e2c909106", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJlMDhiN2Q5MDlkMjc4ODRlOWY1ZjJjYjg3OTczOWUyYzkwOTEwNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-11T00:08:35Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-11T00:08:35Z"}, "message": "Accidentally failed to commit these earlier, as part of:\n\n    Update the compiler to use the new names.  Add calls to printlock and\n    printunlock around print statements.  Move expression evaluation before\n    the call to printlock.  Update g's writebuf field to a slice, and adjust\n    C code accordingly.\n\n    Reviewed-on: https://go-review.googlesource.com/30717\n\nFrom-SVN: r240958", "tree": {"sha": "4bf60096697ceb0808430d2f207d7b3220b44460", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4bf60096697ceb0808430d2f207d7b3220b44460"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abe08b7d909d27884e9f5f2cb879739e2c909106", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe08b7d909d27884e9f5f2cb879739e2c909106", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abe08b7d909d27884e9f5f2cb879739e2c909106", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe08b7d909d27884e9f5f2cb879739e2c909106/comments", "author": null, "committer": null, "parents": [{"sha": "5b69c5e55df08ca91989f746ed2b459e0658d6dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b69c5e55df08ca91989f746ed2b459e0658d6dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b69c5e55df08ca91989f746ed2b459e0658d6dd"}], "stats": {"total": 209, "additions": 173, "deletions": 36}, "files": [{"sha": "6b1467b1c48aefe65671e7354262cdec2b853780", "filename": "libgo/go/runtime/write_err.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe08b7d909d27884e9f5f2cb879739e2c909106/libgo%2Fgo%2Fruntime%2Fwrite_err.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe08b7d909d27884e9f5f2cb879739e2c909106/libgo%2Fgo%2Fruntime%2Fwrite_err.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fwrite_err.go?ref=abe08b7d909d27884e9f5f2cb879739e2c909106", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !android\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+func writeErr(b []byte) {\n+\twrite(2, unsafe.Pointer(&b[0]), int32(len(b)))\n+}"}, {"sha": "4411a1475548994e4cf2e990fb5bf90bb3c1456b", "filename": "libgo/go/runtime/write_err_android.go", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe08b7d909d27884e9f5f2cb879739e2c909106/libgo%2Fgo%2Fruntime%2Fwrite_err_android.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe08b7d909d27884e9f5f2cb879739e2c909106/libgo%2Fgo%2Fruntime%2Fwrite_err_android.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fwrite_err_android.go?ref=abe08b7d909d27884e9f5f2cb879739e2c909106", "patch": "@@ -0,0 +1,160 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+var (\n+\twriteHeader = []byte{6 /* ANDROID_LOG_ERROR */, 'G', 'o', 0}\n+\twritePath   = []byte(\"/dev/log/main\\x00\")\n+\twriteLogd   = []byte(\"/dev/socket/logdw\\x00\")\n+\n+\t// guarded by printlock/printunlock.\n+\twriteFD  uintptr\n+\twriteBuf [1024]byte\n+\twritePos int\n+)\n+\n+// Prior to Android-L, logging was done through writes to /dev/log files implemented\n+// in kernel ring buffers. In Android-L, those /dev/log files are no longer\n+// accessible and logging is done through a centralized user-mode logger, logd.\n+//\n+// https://android.googlesource.com/platform/system/core/+/master/liblog/logd_write.c\n+type loggerType int32\n+\n+const (\n+\tunknown loggerType = iota\n+\tlegacy\n+\tlogd\n+\t// TODO(hakim): logging for emulator?\n+)\n+\n+var logger loggerType\n+\n+func writeErr(b []byte) {\n+\tif logger == unknown {\n+\t\t// Use logd if /dev/socket/logdw is available.\n+\t\tif v := uintptr(access(&writeLogd[0], 0x02 /* W_OK */)); v == 0 {\n+\t\t\tlogger = logd\n+\t\t\tinitLogd()\n+\t\t} else {\n+\t\t\tlogger = legacy\n+\t\t\tinitLegacy()\n+\t\t}\n+\t}\n+\n+\t// Write to stderr for command-line programs.\n+\twrite(2, unsafe.Pointer(&b[0]), int32(len(b)))\n+\n+\t// Log format: \"<header>\\x00<message m bytes>\\x00\"\n+\t//\n+\t// <header>\n+\t//   In legacy mode: \"<priority 1 byte><tag n bytes>\".\n+\t//   In logd mode: \"<android_log_header_t 11 bytes><priority 1 byte><tag n bytes>\"\n+\t//\n+\t// The entire log needs to be delivered in a single syscall (the NDK\n+\t// does this with writev). Each log is its own line, so we need to\n+\t// buffer writes until we see a newline.\n+\tvar hlen int\n+\tswitch logger {\n+\tcase logd:\n+\t\thlen = writeLogdHeader()\n+\tcase legacy:\n+\t\thlen = len(writeHeader)\n+\t}\n+\n+\tdst := writeBuf[hlen:]\n+\tfor _, v := range b {\n+\t\tif v == 0 { // android logging won't print a zero byte\n+\t\t\tv = '0'\n+\t\t}\n+\t\tdst[writePos] = v\n+\t\twritePos++\n+\t\tif v == '\\n' || writePos == len(dst)-1 {\n+\t\t\tdst[writePos] = 0\n+\t\t\twrite(writeFD, unsafe.Pointer(&writeBuf[0]), int32(hlen+writePos))\n+\t\t\tmemclrBytes(dst)\n+\t\t\twritePos = 0\n+\t\t}\n+\t}\n+}\n+\n+func initLegacy() {\n+\t// In legacy mode, logs are written to /dev/log/main\n+\twriteFD = uintptr(open(&writePath[0], 0x1 /* O_WRONLY */, 0))\n+\tif writeFD == 0 {\n+\t\t// It is hard to do anything here. Write to stderr just\n+\t\t// in case user has root on device and has run\n+\t\t//\tadb shell setprop log.redirect-stdio true\n+\t\tmsg := []byte(\"runtime: cannot open /dev/log/main\\x00\")\n+\t\twrite(2, unsafe.Pointer(&msg[0]), int32(len(msg)))\n+\t\texit(2)\n+\t}\n+\n+\t// Prepopulate the invariant header part.\n+\tcopy(writeBuf[:len(writeHeader)], writeHeader)\n+}\n+\n+// used in initLogdWrite but defined here to avoid heap allocation.\n+var logdAddr sockaddr_un\n+\n+func initLogd() {\n+\t// In logd mode, logs are sent to the logd via a unix domain socket.\n+\tlogdAddr.family = _AF_UNIX\n+\tcopy(logdAddr.path[:], writeLogd)\n+\n+\t// We are not using non-blocking I/O because writes taking this path\n+\t// are most likely triggered by panic, we cannot think of the advantage of\n+\t// non-blocking I/O for panic but see disadvantage (dropping panic message),\n+\t// and blocking I/O simplifies the code a lot.\n+\tfd := socket(_AF_UNIX, _SOCK_DGRAM|_O_CLOEXEC, 0)\n+\tif fd < 0 {\n+\t\tmsg := []byte(\"runtime: cannot create a socket for logging\\x00\")\n+\t\twrite(2, unsafe.Pointer(&msg[0]), int32(len(msg)))\n+\t\texit(2)\n+\t}\n+\n+\terrno := connect(fd, unsafe.Pointer(&logdAddr), int32(unsafe.Sizeof(logdAddr)))\n+\tif errno < 0 {\n+\t\tmsg := []byte(\"runtime: cannot connect to /dev/socket/logdw\\x00\")\n+\t\twrite(2, unsafe.Pointer(&msg[0]), int32(len(msg)))\n+\t\t// TODO(hakim): or should we just close fd and hope for better luck next time?\n+\t\texit(2)\n+\t}\n+\twriteFD = uintptr(fd)\n+\n+\t// Prepopulate invariant part of the header.\n+\t// The first 11 bytes will be populated later in writeLogdHeader.\n+\tcopy(writeBuf[11:11+len(writeHeader)], writeHeader)\n+}\n+\n+// writeLogdHeader populates the header and returns the length of the payload.\n+func writeLogdHeader() int {\n+\thdr := writeBuf[:11]\n+\n+\t// The first 11 bytes of the header corresponds to android_log_header_t\n+\t// as defined in system/core/include/private/android_logger.h\n+\t//   hdr[0] log type id (unsigned char), defined in <log/log.h>\n+\t//   hdr[1:2] tid (uint16_t)\n+\t//   hdr[3:11] log_time defined in <log/log_read.h>\n+\t//      hdr[3:7] sec unsigned uint32, little endian.\n+\t//      hdr[7:11] nsec unsigned uint32, little endian.\n+\thdr[0] = 0 // LOG_ID_MAIN\n+\tsec, nsec := time_now()\n+\tpackUint32(hdr[3:7], uint32(sec))\n+\tpackUint32(hdr[7:11], uint32(nsec))\n+\n+\t// TODO(hakim):  hdr[1:2] = gettid?\n+\n+\treturn 11 + len(writeHeader)\n+}\n+\n+func packUint32(b []byte, v uint32) {\n+\t// little-endian.\n+\tb[0] = byte(v)\n+\tb[1] = byte(v >> 8)\n+\tb[2] = byte(v >> 16)\n+\tb[3] = byte(v >> 24)\n+}"}, {"sha": "4c520de3ce5eb23bcd30f954ec95463664654cfa", "filename": "libgo/runtime/go-print.c", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b69c5e55df08ca91989f746ed2b459e0658d6dd/libgo%2Fruntime%2Fgo-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b69c5e55df08ca91989f746ed2b459e0658d6dd/libgo%2Fruntime%2Fgo-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-print.c?ref=5b69c5e55df08ca91989f746ed2b459e0658d6dd", "patch": "@@ -1,36 +0,0 @@\n-/* go-print.c -- support for the go print statement.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <math.h>\n-#include <stdint.h>\n-#include <stdio.h>\n-\n-#include \"runtime.h\"\n-#include \"array.h\"\n-#include \"go-panic.h\"\n-#include \"interface.h\"\n-\n-/* This implements the various little functions which are called by\n-   the predeclared functions print/println/panic/panicln.  */\n-\n-void\n-__go_print_empty_interface (struct __go_empty_interface e)\n-{\n-  runtime_printf (\"(%p,%p)\", e.__type_descriptor, e.__object);\n-}\n-\n-void\n-__go_print_interface (struct __go_interface i)\n-{\n-  runtime_printf (\"(%p,%p)\", i.__methods, i.__object);\n-}\n-\n-void\n-__go_print_slice (struct __go_open_array val)\n-{\n-  runtime_printf (\"[%d/%d]\", val.__count, val.__capacity);\n-  runtime_printpointer (val.__values);\n-}"}]}