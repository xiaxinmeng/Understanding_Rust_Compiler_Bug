{"sha": "7805417a5d2a9a79a3858b82d60169178f59c6f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgwNTQxN2E1ZDJhOWE3OWEzODU4YjgyZDYwMTY5MTc4ZjU5YzZmMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-06-25T16:52:32Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-06-25T16:52:32Z"}, "message": "predict.c (predict_paths_leading_to, [...]): Add in_loop parameter.\n\n\n\t* predict.c (predict_paths_leading_to, predict_paths_leading_to_edge):\n\tAdd in_loop parameter.\n\t(predict_loops): Add loop guard heuristics.\n\t* predict.def (PRED_LOOP_GUARD): New heuristics.\n\n\t* gcc.dg/predict-11.c: New testcase.\n\t* gfortran.dg/predict-2.f90: New testcase.\n\nFrom-SVN: r237781", "tree": {"sha": "1b33d23bbcb416fae09c690f99e78c7b06c92985", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b33d23bbcb416fae09c690f99e78c7b06c92985"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7805417a5d2a9a79a3858b82d60169178f59c6f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7805417a5d2a9a79a3858b82d60169178f59c6f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7805417a5d2a9a79a3858b82d60169178f59c6f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7805417a5d2a9a79a3858b82d60169178f59c6f1/comments", "author": null, "committer": null, "parents": [{"sha": "888ed1a39a46d55a7c1f2357d31eb4b59e4dc721", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/888ed1a39a46d55a7c1f2357d31eb4b59e4dc721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/888ed1a39a46d55a7c1f2357d31eb4b59e4dc721"}], "stats": {"total": 151, "additions": 140, "deletions": 11}, "files": [{"sha": "48a2291889d88fd87395bd1968475ee2279bb969", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7805417a5d2a9a79a3858b82d60169178f59c6f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7805417a5d2a9a79a3858b82d60169178f59c6f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7805417a5d2a9a79a3858b82d60169178f59c6f1", "patch": "@@ -1,3 +1,10 @@\n+2016-06-24  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* predict.c (predict_paths_leading_to, predict_paths_leading_to_edge):\n+\tAdd in_loop parameter.\n+\t(predict_loops): Add loop guard heuristics.\n+\t* predict.def (PRED_LOOP_GUARD): New heuristics.\n+\n 2016-06-24  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* predict.c: Include ipa-utils.h"}, {"sha": "5a841dd044e4c6c9d47a580aa87d6e0837dabace", "filename": "gcc/predict.c", "status": "modified", "additions": 91, "deletions": 11, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7805417a5d2a9a79a3858b82d60169178f59c6f1/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7805417a5d2a9a79a3858b82d60169178f59c6f1/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=7805417a5d2a9a79a3858b82d60169178f59c6f1", "patch": "@@ -79,8 +79,12 @@ static sreal real_almost_one, real_br_prob_base,\n static void combine_predictions_for_insn (rtx_insn *, basic_block);\n static void dump_prediction (FILE *, enum br_predictor, int, basic_block,\n \t\t\t     enum predictor_reason, edge);\n-static void predict_paths_leading_to (basic_block, enum br_predictor, enum prediction);\n-static void predict_paths_leading_to_edge (edge, enum br_predictor, enum prediction);\n+static void predict_paths_leading_to (basic_block, enum br_predictor,\n+\t\t\t\t      enum prediction,\n+\t\t\t\t      struct loop *in_loop = NULL);\n+static void predict_paths_leading_to_edge (edge, enum br_predictor,\n+\t\t\t\t\t   enum prediction,\n+\t\t\t\t\t   struct loop *in_loop = NULL);\n static bool can_predict_insn_p (const rtx_insn *);\n \n /* Information we hold about each branch predictor.\n@@ -1853,6 +1857,74 @@ predict_loops (void)\n \t\t\t\t   tree_to_shwi (loop_bound_step));\n \t}\n \n+      /* In the following code\n+\t for (loop1)\n+\t   if (cond)\n+\t     for (loop2)\n+\t       body;\n+\t guess that cond is unlikely.  */\n+      if (loop_outer (loop)->num)\n+\t{\n+\t  basic_block bb = NULL;\n+\t  edge preheader_edge = loop_preheader_edge (loop);\n+\n+\t  if (single_pred_p (preheader_edge->src)\n+\t      && single_succ_p (preheader_edge->src))\n+\t    preheader_edge = single_pred_edge (preheader_edge->src);\n+\n+\t  gimple *stmt = last_stmt (preheader_edge->src);\n+\t  /* Pattern match fortran loop preheader:\n+\t     _16 = BUILTIN_EXPECT (_15, 1, PRED_FORTRAN_LOOP_PREHEADER);\n+\t     _17 = (logical(kind=4)) _16;\n+\t     if (_17 != 0)\n+\t       goto <bb 11>;\n+\t     else\n+\t       goto <bb 13>;\n+\n+\t     Loop guard branch prediction says nothing about duplicated loop\n+\t     headers produced by fortran frontend and in this case we want\n+\t     to predict paths leading to this preheader.  */\n+\n+\t  if (stmt\n+\t      && gimple_code (stmt) == GIMPLE_COND\n+\t      && gimple_cond_code (stmt) == NE_EXPR\n+\t      && TREE_CODE (gimple_cond_lhs (stmt)) == SSA_NAME\n+\t      && integer_zerop (gimple_cond_rhs (stmt)))\n+\t     {\n+\t       gimple *call_stmt = SSA_NAME_DEF_STMT (gimple_cond_lhs (stmt));\n+\t       if (gimple_code (call_stmt) == GIMPLE_ASSIGN\n+\t\t   && gimple_expr_code (call_stmt) == NOP_EXPR\n+\t\t   && TREE_CODE (gimple_assign_rhs1 (call_stmt)) == SSA_NAME)\n+\t\t call_stmt = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (call_stmt));\n+\t       if (gimple_code (call_stmt) == GIMPLE_CALL\n+\t\t   && gimple_call_internal_p (call_stmt)\n+\t\t   && gimple_call_internal_fn (call_stmt) == IFN_BUILTIN_EXPECT\n+\t\t   && TREE_CODE (gimple_call_arg (call_stmt, 2)) == INTEGER_CST\n+\t\t   && tree_fits_uhwi_p (gimple_call_arg (call_stmt, 2))\n+\t\t   && tree_to_uhwi (gimple_call_arg (call_stmt, 2))\n+\t\t\t== PRED_FORTRAN_LOOP_PREHEADER)\n+\t\t bb = preheader_edge->src;\n+\t     }\n+\t  if (!bb)\n+\t    {\n+\t      if (!dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t   loop_outer (loop)->latch, loop->header))\n+\t\tpredict_paths_leading_to_edge (loop_preheader_edge (loop),\n+\t\t\t\t\t       PRED_LOOP_GUARD,\n+\t\t\t\t\t       NOT_TAKEN,\n+\t\t\t\t\t       loop_outer (loop));\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t   loop_outer (loop)->latch, bb))\n+\t\tpredict_paths_leading_to (bb,\n+\t\t\t\t\t  PRED_LOOP_GUARD,\n+\t\t\t\t\t  NOT_TAKEN,\n+\t\t\t\t\t  loop_outer (loop));\n+\t    }\n+\t}\n+\n       /* Free basic blocks from get_loop_body.  */\n       free (bbs);\n     }\n@@ -2606,12 +2678,19 @@ static void\n predict_paths_for_bb (basic_block cur, basic_block bb,\n \t\t      enum br_predictor pred,\n \t\t      enum prediction taken,\n-\t\t      bitmap visited)\n+\t\t      bitmap visited, struct loop *in_loop = NULL)\n {\n   edge e;\n   edge_iterator ei;\n   basic_block son;\n \n+  /* If we exited the loop or CUR is unconditional in the loop, there is\n+     nothing to do.  */\n+  if (in_loop\n+      && (!flow_bb_inside_loop_p (in_loop, cur)\n+\t  || dominated_by_p (CDI_DOMINATORS, in_loop->latch, cur)))\n+    return;\n+\n   /* We are looking for all edges forming edge cut induced by\n      set of all blocks postdominated by BB.  */\n   FOR_EACH_EDGE (e, ei, cur->preds)\n@@ -2628,11 +2707,12 @@ predict_paths_for_bb (basic_block cur, basic_block bb,\n       gcc_assert (bb == cur || dominated_by_p (CDI_POST_DOMINATORS, cur, bb));\n \n       /* See if there is an edge from e->src that is not abnormal\n-\t and does not lead to BB.  */\n+\t and does not lead to BB and does not exit the loop.  */\n       FOR_EACH_EDGE (e2, ei2, e->src->succs)\n \tif (e2 != e\n \t    && !(e2->flags & (EDGE_EH | EDGE_FAKE))\n-\t    && !dominated_by_p (CDI_POST_DOMINATORS, e2->dest, bb))\n+\t    && !dominated_by_p (CDI_POST_DOMINATORS, e2->dest, bb)\n+\t    && (!in_loop || !loop_exit_edge_p (in_loop, e2)))\n \t  {\n \t    found = true;\n \t    break;\n@@ -2651,31 +2731,31 @@ predict_paths_for_bb (basic_block cur, basic_block bb,\n             predict_edge_def (e, pred, taken);\n \t}\n       else if (bitmap_set_bit (visited, e->src->index))\n-\tpredict_paths_for_bb (e->src, e->src, pred, taken, visited);\n+\tpredict_paths_for_bb (e->src, e->src, pred, taken, visited, in_loop);\n     }\n   for (son = first_dom_son (CDI_POST_DOMINATORS, cur);\n        son;\n        son = next_dom_son (CDI_POST_DOMINATORS, son))\n-    predict_paths_for_bb (son, bb, pred, taken, visited);\n+    predict_paths_for_bb (son, bb, pred, taken, visited, in_loop);\n }\n \n /* Sets branch probabilities according to PREDiction and\n    FLAGS.  */\n \n static void\n predict_paths_leading_to (basic_block bb, enum br_predictor pred,\n-\t\t\t  enum prediction taken)\n+\t\t\t  enum prediction taken, struct loop *in_loop)\n {\n   bitmap visited = BITMAP_ALLOC (NULL);\n-  predict_paths_for_bb (bb, bb, pred, taken, visited);\n+  predict_paths_for_bb (bb, bb, pred, taken, visited, in_loop);\n   BITMAP_FREE (visited);\n }\n \n /* Like predict_paths_leading_to but take edge instead of basic block.  */\n \n static void\n predict_paths_leading_to_edge (edge e, enum br_predictor pred,\n-\t\t\t       enum prediction taken)\n+\t\t\t       enum prediction taken, struct loop *in_loop)\n {\n   bool has_nonloop_edge = false;\n   edge_iterator ei;\n@@ -2693,7 +2773,7 @@ predict_paths_leading_to_edge (edge e, enum br_predictor pred,\n   if (!has_nonloop_edge)\n     {\n       bitmap visited = BITMAP_ALLOC (NULL);\n-      predict_paths_for_bb (bb, bb, pred, taken, visited);\n+      predict_paths_for_bb (bb, bb, pred, taken, visited, in_loop);\n       BITMAP_FREE (visited);\n     }\n   else"}, {"sha": "7feb8c30ec4e9fba903d986f0f25479d90578bb5", "filename": "gcc/predict.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7805417a5d2a9a79a3858b82d60169178f59c6f1/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7805417a5d2a9a79a3858b82d60169178f59c6f1/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=7805417a5d2a9a79a3858b82d60169178f59c6f1", "patch": "@@ -151,6 +151,14 @@ DEF_PREDICTOR (PRED_LOOP_IV_COMPARE_GUESS, \"guess loop iv compare\",\n DEF_PREDICTOR (PRED_LOOP_IV_COMPARE, \"loop iv compare\", PROB_VERY_LIKELY,\n \t       PRED_FLAG_FIRST_MATCH)\n \n+/* In the following code\n+   for (loop1)\n+     if (cond)\n+       for (loop2)\n+\t body;\n+   guess that cond is unlikely.  */\n+DEF_PREDICTOR (PRED_LOOP_GUARD, \"loop guard\", HITRATE (66), 0)\n+\n /* Branches to hot labels are likely.  */\n DEF_PREDICTOR (PRED_HOT_LABEL, \"hot label\", HITRATE (85), 0)\n "}, {"sha": "4a10bf410092bca7cf0db5b89fa5e4c017e623c3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7805417a5d2a9a79a3858b82d60169178f59c6f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7805417a5d2a9a79a3858b82d60169178f59c6f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7805417a5d2a9a79a3858b82d60169178f59c6f1", "patch": "@@ -1,3 +1,8 @@\n+2016-06-24  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/predict-11.c: New testcase.\n+\t* gfortran.dg/predict-2.f90: New testcase.\n+\n 2016-06-24  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* gcc.dg/predict-10.c: New test."}, {"sha": "b2ac8cc6f460c8c8892b69aa4d34ed663bace3ec", "filename": "gcc/testsuite/gcc.dg/predict-11.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7805417a5d2a9a79a3858b82d60169178f59c6f1/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7805417a5d2a9a79a3858b82d60169178f59c6f1/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpredict-11.c?ref=7805417a5d2a9a79a3858b82d60169178f59c6f1", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-profile_estimate\" } */\n+int *a,n,m;\n+void test(void);\n+void\n+t(void)\n+{\n+  int i,j;\n+  for (i=0;i<n;i++)\n+    if (a[i])\n+      for (j=0;j<m;j++)\n+\ttest();\n+}\n+/* { dg-final { scan-tree-dump-times \"loop guard\" 1 \"profile_estimate\"} } */"}, {"sha": "4ae5c3a298ee312f989ede695bd260d35816d112", "filename": "gcc/testsuite/gfortran.dg/predict-2.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7805417a5d2a9a79a3858b82d60169178f59c6f1/gcc%2Ftestsuite%2Fgfortran.dg%2Fpredict-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7805417a5d2a9a79a3858b82d60169178f59c6f1/gcc%2Ftestsuite%2Fgfortran.dg%2Fpredict-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpredict-2.f90?ref=7805417a5d2a9a79a3858b82d60169178f59c6f1", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -fdump-tree-profile_estimate\" }\n+\n+subroutine test(block, array)\n+integer :: i,j, block(9), array(2)\n+\n+do i = array(1), array(2)\n+    do j = array(1), array(2)\n+       block(i) = j\n+    end do\n+end do\n+end subroutine test\n+\n+! { dg-final { scan-tree-dump-times \"Fortran loop preheader heuristics of edge\" 2 \"profile_estimate\" } }\n+! { dg-final { scan-tree-dump-times \"loop gueard\" 0 \"profile_estimate\" } }"}]}