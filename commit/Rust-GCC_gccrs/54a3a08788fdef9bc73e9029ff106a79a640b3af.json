{"sha": "54a3a08788fdef9bc73e9029ff106a79a640b3af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRhM2EwODc4OGZkZWY5YmM3M2U5MDI5ZmYxMDZhNzlhNjQwYjNhZg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@purist.soma.redhat.com", "date": "2000-06-27T20:57:11Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-06-27T20:57:11Z"}, "message": "Update to SGI STL 3.3\n\n\n2000-06-27  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n\n\tUpdate to SGI STL 3.3\n\t* ext/hash_map, ext/hash_set, ext/slist, ext/stl_bvector.h,\n\text/stl_rope.h, ext/ropeimpl.h: Update.\n\t* bits/std_bitset.h, bits/std_map, bits/std_memory.h,\n\tbits/stl_algo.h, bits/stl_algobase.h, bits/stl_alloc.h,\n\tbits/stl_config.h, bits/stl_construct.h, bits/stl_deque.h,\n\tbits/stl_function.h, bits/stl_heap.h, bits/stl_iterator.h,\n\tbits/stl_iterator_base.h, bits/stl_list.h, bits/stl_map.h,\n\tbits/stl_multimap.h, bits/stl_multiset.h, bits/stl_numeric.h,\n\tbits/stl_queue.h, bits/stl_set.h, bits/stl_stack.h,\n\tbits/stl_string_fwd.h, bits/stl_threads.h, bits/stl_three.h,\n\tbits/stl_uninitialized.h, bits/stl_vectory.h: Update.\n\n\t* src/Makefile.am (headers): Add new files.\n\t* src/Makefile.in: Regenerate.\n\t* src/stl-inst.cc (std): Add instantiation for __sink_unused_warning.\n\t* bits/concept_checks.h: New file.\n\t* bits/container_concepts.h: New file.\n\t* bits/sequence_concepts.h: New file.\n\nFrom-SVN: r34743", "tree": {"sha": "cb306ee5a8cb85f104985be3326f616120f65caf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb306ee5a8cb85f104985be3326f616120f65caf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54a3a08788fdef9bc73e9029ff106a79a640b3af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54a3a08788fdef9bc73e9029ff106a79a640b3af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54a3a08788fdef9bc73e9029ff106a79a640b3af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54a3a08788fdef9bc73e9029ff106a79a640b3af/comments", "author": null, "committer": null, "parents": [{"sha": "adae082f2a7afabdde0038349f53731537070f8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adae082f2a7afabdde0038349f53731537070f8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adae082f2a7afabdde0038349f53731537070f8d"}], "stats": {"total": 3009, "additions": 1784, "deletions": 1225}, "files": [{"sha": "2eb0351d0dd8dc9e084e4df59d1609a6db69b7a2", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -1,17 +1,24 @@\n-2000-06-26  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n+2000-06-27  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n \n \tUpdate to SGI STL 3.3\n-\t* bits/stl_algo.h: Update.\n-\t* ext/ropeimpl.h: Update.\n-\t* bits/std_memory.h: Update.\n-\t* bits/std_bitset.h: Update.\n+\t* ext/hash_map, ext/hash_set, ext/slist, ext/stl_bvector.h,\n+\text/stl_rope.h, ext/ropeimpl.h: Update.\n+\t* bits/std_bitset.h, bits/std_map, bits/std_memory.h,\n+\tbits/stl_algo.h, bits/stl_algobase.h, bits/stl_alloc.h,\n+\tbits/stl_config.h, bits/stl_construct.h, bits/stl_deque.h,\n+\tbits/stl_function.h, bits/stl_heap.h, bits/stl_iterator.h,\n+\tbits/stl_iterator_base.h, bits/stl_list.h, bits/stl_map.h,\n+\tbits/stl_multimap.h, bits/stl_multiset.h, bits/stl_numeric.h,\n+\tbits/stl_queue.h, bits/stl_set.h, bits/stl_stack.h,\n+\tbits/stl_string_fwd.h, bits/stl_threads.h, bits/stl_three.h,\n+\tbits/stl_uninitialized.h, bits/stl_vectory.h: Update.\n \n \t* src/Makefile.am (headers): Add new files.\n \t* src/Makefile.in: Regenerate.\n+\t* src/stl-inst.cc (std): Add instantiation for __sink_unused_warning.\n \t* bits/concept_checks.h: New file.\n \t* bits/container_concepts.h: New file.\n \t* bits/sequence_concepts.h: New file.\n-\t* src/stl-inst.cc (std): Add instantiation for __sink_unused_warning.\n \t\n 2000-06-27  H.J. Lu  <hjl@gnu.org>\n             Loren J. Rittle  <ljrittle@acm.org>"}, {"sha": "6556ee39806b325e98e7817579a52eeea5e48ada", "filename": "libstdc++-v3/bits/std_bitset.h", "status": "modified", "additions": 256, "deletions": 397, "changes": 653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstd_bitset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstd_bitset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_bitset.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -9,22 +9,17 @@\n  * in supporting documentation.  Silicon Graphics makes no\n  * representations about the suitability of this software for any\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n+ */ \n \n-#ifndef _CPP_BITSET\n-#define _CPP_BITSET 1\n+#ifndef __SGI_STL_BITSET\n+#define __SGI_STL_BITSET\n \n-// This implementation of bitset<> has a second template parameter,\n-// _WordT, which defaults to unsigned long.  *YOU SHOULD NOT USE\n-// THIS FEATURE*.  It is experimental, and it may be removed in\n-// future releases.\n+// A bitset of size N has N % (sizeof(unsigned long) * CHAR_BIT) unused \n+// bits.  (They are the high- order bits in the highest word.)  It is\n+// a class invariant of class bitset<> that those unused bits are\n+// always zero.\n \n-// A bitset of size N, using words of type _WordT, will have\n-// N % (sizeof(_WordT) * CHAR_BIT) unused bits.  (They are the high-\n-// order bits in the highest word.)  It is a class invariant\n-// of class bitset<> that those unused bits are always zero.\n-\n-// Most of the actual code isn't contained in bitset<> itself, but in the\n+// Most of the actual code isn't contained in bitset<> itself, but in the \n // base class _Base_bitset.  The base class works with whole words, not with\n // individual bits.  This allows us to specialize _Base_bitset for the\n // important special case where the bitset is only a single word.\n@@ -36,15 +31,20 @@\n \n \n #include <bits/std_cstddef.h>     // for size_t\n+#include <bits/std_cstring.h>     // for memset\n #include <bits/std_string.h>\n-#include <bits/std_stdexcept.h>\n-#include <bits/std_istream.h>\n-#include <bits/std_ostream.h>\n-#include <bits/std_algorithm.h>\n+#include <bits/std_stdexcept.h>   // for invalid_argument, out_of_range, \n+\t\t\t\t  // overflow_error\n+\n+#ifdef __STL_USE_NEW_IOSTREAMS \n+#include <iostream>\n+#else\n+#include <bits/std_iostream.h>   // for istream, ostream\n+#endif\n \n-#define __BITS_PER_WORDT(__wt) (CHAR_BIT*sizeof(__wt))\n-#define __BITSET_WORDS(__n,__wt) \\\n- ((__n) < 1 ? 1 : ((__n) + __BITS_PER_WORDT(__wt) - 1)/__BITS_PER_WORDT(__wt))\n+#define __BITS_PER_WORD (CHAR_BIT*sizeof(unsigned long))\n+#define __BITSET_WORDS(__n) \\\n+ ((__n) < 1 ? 1 : ((__n) + __BITS_PER_WORD - 1)/__BITS_PER_WORD)\n \n __STL_BEGIN_NAMESPACE\n \n@@ -53,14 +53,14 @@ __STL_BEGIN_NAMESPACE\n #endif\n \n // structure to aid in counting bits\n-template<bool __dummy>\n+template<bool __dummy> \n struct _Bit_count {\n   static unsigned char _S_bit_count[256];\n };\n \n // Mapping from 8 bit unsigned integers to the index of the first one\n // bit:\n-template<bool __dummy>\n+template<bool __dummy> \n struct _First_one {\n   static unsigned char _S_first_one[256];\n };\n@@ -69,53 +69,52 @@ struct _First_one {\n // Base class: general case.\n //\n \n-template<size_t _Nw, class _WordT>\n+template<size_t _Nw>\n struct _Base_bitset {\n+  typedef unsigned long _WordT;\n+\n   _WordT _M_w[_Nw];                // 0 is the least significant word.\n \n   _Base_bitset( void ) { _M_do_reset(); }\n-\n-  _Base_bitset(unsigned long __val);\n-\n-  static size_t _S_whichword( size_t __pos ) {\n-    return __pos / __BITS_PER_WORDT(_WordT);\n-  }\n-  static size_t _S_whichbyte( size_t __pos ) {\n-    return (__pos % __BITS_PER_WORDT(_WordT)) / CHAR_BIT;\n-  }\n-  static size_t _S_whichbit( size_t __pos ) {\n-    return __pos % __BITS_PER_WORDT(_WordT);\n-  }\n-  static _WordT _S_maskbit( size_t __pos ) {\n-    return (static_cast<_WordT>(1)) << _S_whichbit(__pos);\n+  _Base_bitset(unsigned long __val) {\n+    _M_do_reset();\n+    _M_w[0] = __val;\n   }\n \n+  static size_t _S_whichword( size_t __pos )\n+    { return __pos / __BITS_PER_WORD; }\n+  static size_t _S_whichbyte( size_t __pos )\n+    { return (__pos % __BITS_PER_WORD) / CHAR_BIT; }\n+  static size_t _S_whichbit( size_t __pos )\n+    { return __pos % __BITS_PER_WORD; }\n+  static _WordT _S_maskbit( size_t __pos )\n+    { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n+\n   _WordT& _M_getword(size_t __pos)       { return _M_w[_S_whichword(__pos)]; }\n   _WordT  _M_getword(size_t __pos) const { return _M_w[_S_whichword(__pos)]; }\n \n   _WordT& _M_hiword()       { return _M_w[_Nw - 1]; }\n   _WordT  _M_hiword() const { return _M_w[_Nw - 1]; }\n \n-  void _M_do_and(const _Base_bitset<_Nw,_WordT>& __x) {\n+  void _M_do_and(const _Base_bitset<_Nw>& __x) {\n     for ( size_t __i = 0; __i < _Nw; __i++ ) {\n       _M_w[__i] &= __x._M_w[__i];\n     }\n   }\n \n-  void _M_do_or(const _Base_bitset<_Nw,_WordT>& __x) {\n+  void _M_do_or(const _Base_bitset<_Nw>& __x) {\n     for ( size_t __i = 0; __i < _Nw; __i++ ) {\n       _M_w[__i] |= __x._M_w[__i];\n     }\n   }\n \n-  void _M_do_xor(const _Base_bitset<_Nw,_WordT>& __x) {\n+  void _M_do_xor(const _Base_bitset<_Nw>& __x) {\n     for ( size_t __i = 0; __i < _Nw; __i++ ) {\n       _M_w[__i] ^= __x._M_w[__i];\n     }\n   }\n \n   void _M_do_left_shift(size_t __shift);\n-\n   void _M_do_right_shift(size_t __shift);\n \n   void _M_do_flip() {\n@@ -130,13 +129,9 @@ struct _Base_bitset {\n     }\n   }\n \n-  void _M_do_reset() {\n-    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n-      _M_w[__i] = 0;\n-    }\n-  }\n+  void _M_do_reset() { memset(_M_w, 0, _Nw * sizeof(_WordT)); }\n \n-  bool _M_is_equal(const _Base_bitset<_Nw,_WordT>& __x) const {\n+  bool _M_is_equal(const _Base_bitset<_Nw>& __x) const {\n     for (size_t __i = 0; __i < _Nw; ++__i) {\n       if (_M_w[__i] != __x._M_w[__i])\n         return false;\n@@ -145,7 +140,7 @@ struct _Base_bitset {\n   }\n \n   bool _M_is_any() const {\n-    for ( size_t __i = 0; __i < __BITSET_WORDS(_Nw,_WordT); __i++ ) {\n+    for ( size_t __i = 0; __i < _Nw; __i++ ) {\n       if ( _M_w[__i] != static_cast<_WordT>(0) )\n         return true;\n     }\n@@ -164,7 +159,7 @@ struct _Base_bitset {\n     return __result;\n   }\n \n-  unsigned long _M_do_to_ulong() const;\n+  unsigned long _M_do_to_ulong() const; \n \n   // find first \"on\" bit\n   size_t _M_do_find_first(size_t __not_found) const;\n@@ -175,107 +170,67 @@ struct _Base_bitset {\n \n //\n // Definitions of non-inline functions from _Base_bitset.\n-//\n+// \n \n-template<size_t _Nw, class _WordT>\n-_Base_bitset<_Nw, _WordT>::_Base_bitset(unsigned long __val)\n-{\n-  _M_do_reset();\n-  const size_t __n = min(sizeof(unsigned long)*CHAR_BIT,\n-                         __BITS_PER_WORDT(_WordT)*_Nw);\n-  for(size_t __i = 0; __i < __n; ++__i, __val >>= 1)\n-    if ( __val & 0x1 )\n-      _M_getword(__i) |= _S_maskbit(__i);\n-}\n-\n-template<size_t _Nw, class _WordT>\n-void _Base_bitset<_Nw, _WordT>::_M_do_left_shift(size_t __shift)\n+template<size_t _Nw>\n+void _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift) \n {\n   if (__shift != 0) {\n-    const size_t __wshift = __shift / __BITS_PER_WORDT(_WordT);\n-    const size_t __offset = __shift % __BITS_PER_WORDT(_WordT);\n-    const size_t __sub_offset = __BITS_PER_WORDT(_WordT) - __offset;\n-    const _WordT __mask = __offset == static_cast<size_t>(0) ?\n-\t\t\t  static_cast<_WordT>(0) :\n-\t\t\t  ~static_cast<_WordT>(0);\n-    size_t __n = _Nw - 1;\n-    for ( ; __n > __wshift; --__n)\n-      _M_w[__n] = (_M_w[__n - __wshift] << __offset) |\n-\t\t((_M_w[__n - __wshift - 1] >> __sub_offset) & __mask);\n-    if (__n == __wshift)\n-      _M_w[__n] = _M_w[0] << __offset;\n-    for (size_t __n1 = 0; __n1 < __n; ++__n1)\n-      _M_w[__n1] = static_cast<_WordT>(0);\n+    const size_t __wshift = __shift / __BITS_PER_WORD;\n+    const size_t __offset = __shift % __BITS_PER_WORD;\n+\n+    if (__offset == 0)\n+      for (size_t __n = _Nw - 1; __n >= __wshift; --__n)\n+        _M_w[__n] = _M_w[__n - __wshift];\n+\n+    else {\n+      const size_t __sub_offset = __BITS_PER_WORD - __offset;\n+      for (size_t __n = _Nw - 1; __n > __wshift; --__n)\n+        _M_w[__n] = (_M_w[__n - __wshift] << __offset) | \n+                    (_M_w[__n - __wshift - 1] >> __sub_offset);\n+      _M_w[__wshift] = _M_w[0] << __offset;\n+    }\n+\n+    fill(_M_w + 0, _M_w + __wshift, static_cast<_WordT>(0));\n   }\n }\n \n-template<size_t _Nw, class _WordT>\n-void _Base_bitset<_Nw, _WordT>::_M_do_right_shift(size_t __shift)\n+template<size_t _Nw>\n+void _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift) \n {\n   if (__shift != 0) {\n-    const size_t __wshift = __shift / __BITS_PER_WORDT(_WordT);\n-    const size_t __offset = __shift % __BITS_PER_WORDT(_WordT);\n-    const size_t __sub_offset = __BITS_PER_WORDT(_WordT) - __offset;\n-    const _WordT __mask = __offset == static_cast<size_t>(0) ?\n-\t\t\t  static_cast<_WordT>(0) :\n-\t\t\t  ~static_cast<_WordT>(0);\n+    const size_t __wshift = __shift / __BITS_PER_WORD;\n+    const size_t __offset = __shift % __BITS_PER_WORD;\n     const size_t __limit = _Nw - __wshift - 1;\n-    size_t __n = 0;\n-    for ( ; __n < __limit; ++__n)\n-      _M_w[__n] = (_M_w[__n + __wshift] >> __offset) |\n-\t\t  ((_M_w[__n + __wshift + 1] << __sub_offset) & __mask);\n-    _M_w[__limit] = _M_w[_Nw-1] >> __offset;\n-    for (size_t __n1 = __limit + 1; __n1 < _Nw; ++__n1)\n-      _M_w[__n1] = static_cast<_WordT>(0);\n-  }\n-}\n \n-template<size_t _Nw, class _WordT>\n-unsigned long _Base_bitset<_Nw, _WordT>::_M_do_to_ulong() const\n-{\n-  if (sizeof(_WordT) >= sizeof(unsigned long)) {\n-    for (size_t __i = 1; __i < _Nw; ++__i)\n-      if (_M_w[__i])\n-        __STL_THROW(overflow_error(\"bitset\"));\n-\n-    const _WordT __mask = static_cast<_WordT>(static_cast<unsigned long>(-1));\n-    if (_M_w[0] & ~__mask)\n-      __STL_THROW(overflow_error(\"bitset\"));\n+    if (__offset == 0)\n+      for (size_t __n = 0; __n <= __limit; ++__n)\n+        _M_w[__n] = _M_w[__n + __wshift];\n \n-    return static_cast<unsigned long>(_M_w[0] & __mask);\n-  }\n-  else {                      // sizeof(_WordT) < sizeof(unsigned long).\n-    const size_t __nwords =\n-      (sizeof(unsigned long) + sizeof(_WordT) - 1) / sizeof(_WordT);\n-\n-    size_t __min_nwords = __nwords;\n-    if (_Nw > __nwords) {\n-      for (size_t __i = __nwords; __i < _Nw; ++__i)\n-        if (_M_w[__i])\n-          __STL_THROW(overflow_error(\"bitset\"));\n+    else {\n+      const size_t __sub_offset = __BITS_PER_WORD - __offset;\n+      for (size_t __n = 0; __n < __limit; ++__n)\n+        _M_w[__n] = (_M_w[__n + __wshift] >> __offset) |\n+                    (_M_w[__n + __wshift + 1] << __sub_offset);\n+      _M_w[__limit] = _M_w[_Nw-1] >> __offset;\n     }\n-    else\n-      __min_nwords = _Nw;\n \n-    // If unsigned long is 8 bytes and _WordT is 6 bytes, then an unsigned\n-    // long consists of all of one word plus 2 bytes from another word.\n-    const size_t __part = sizeof(unsigned long) % sizeof(_WordT);\n+    fill(_M_w + __limit + 1, _M_w + _Nw, static_cast<_WordT>(0));\n+  }\n+}\n \n-    if (__part != 0 && __nwords <= _Nw &&\n-        (_M_w[__min_nwords - 1] >> ((sizeof(_WordT) - __part) * CHAR_BIT)) != 0)\n+template<size_t _Nw>\n+unsigned long _Base_bitset<_Nw>::_M_do_to_ulong() const\n+{\n+  for (size_t __i = 1; __i < _Nw; ++__i) \n+    if (_M_w[__i]) \n       __STL_THROW(overflow_error(\"bitset\"));\n+  \n+  return _M_w[0];\n+}\n \n-    unsigned long __result = 0;\n-    for (size_t __i = 0; __i < __min_nwords; ++__i) {\n-      __result |= static_cast<unsigned long>(\n-         _M_w[__i]) << (__i * sizeof(_WordT) * CHAR_BIT);\n-    }\n-    return __result;\n-  }\n-} // End _M_do_to_ulong\n-\n-template<size_t _Nw, class _WordT>\n-size_t _Base_bitset<_Nw, _WordT>::_M_do_find_first(size_t __not_found) const\n+template<size_t _Nw>\n+size_t _Base_bitset<_Nw>::_M_do_find_first(size_t __not_found) const \n {\n   for ( size_t __i = 0; __i < _Nw; __i++ ) {\n     _WordT __thisword = _M_w[__i];\n@@ -285,7 +240,7 @@ size_t _Base_bitset<_Nw, _WordT>::_M_do_find_first(size_t __not_found) const\n         unsigned char __this_byte\n           = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n         if ( __this_byte )\n-          return __i*__BITS_PER_WORDT(_WordT) + __j*CHAR_BIT +\n+          return __i*__BITS_PER_WORD + __j*CHAR_BIT +\n             _First_one<true>::_S_first_one[__this_byte];\n \n         __thisword >>= CHAR_BIT;\n@@ -296,16 +251,15 @@ size_t _Base_bitset<_Nw, _WordT>::_M_do_find_first(size_t __not_found) const\n   return __not_found;\n }\n \n-template<size_t _Nw, class _WordT>\n+template<size_t _Nw>\n size_t\n-_Base_bitset<_Nw, _WordT>::_M_do_find_next(size_t __prev,\n-                                           size_t __not_found) const\n+_Base_bitset<_Nw>::_M_do_find_next(size_t __prev, size_t __not_found) const\n {\n   // make bound inclusive\n   ++__prev;\n \n   // check out of bounds\n-  if ( __prev >= _Nw * __BITS_PER_WORDT(_WordT) )\n+  if ( __prev >= _Nw * __BITS_PER_WORD )\n     return __not_found;\n \n     // search first word\n@@ -323,7 +277,7 @@ _Base_bitset<_Nw, _WordT>::_M_do_find_next(size_t __prev,\n       unsigned char __this_byte\n         = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n       if ( __this_byte )\n-        return __i*__BITS_PER_WORDT(_WordT) + __j*CHAR_BIT +\n+        return __i*__BITS_PER_WORD + __j*CHAR_BIT +\n           _First_one<true>::_S_first_one[__this_byte];\n \n       __thisword >>= CHAR_BIT;\n@@ -340,7 +294,7 @@ _Base_bitset<_Nw, _WordT>::_M_do_find_next(size_t __prev,\n         unsigned char __this_byte\n           = static_cast<unsigned char>(__thisword & (~(unsigned char)0));\n         if ( __this_byte )\n-          return __i*__BITS_PER_WORDT(_WordT) + __j*CHAR_BIT +\n+          return __i*__BITS_PER_WORD + __j*CHAR_BIT +\n             _First_one<true>::_S_first_one[__this_byte];\n \n         __thisword >>= CHAR_BIT;\n@@ -359,77 +313,60 @@ _Base_bitset<_Nw, _WordT>::_M_do_find_next(size_t __prev,\n // Base class: specialization for a single word.\n //\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template<class _WordT>\n-struct _Base_bitset<1, _WordT> {\n+__STL_TEMPLATE_NULL struct _Base_bitset<1> {\n+  typedef unsigned long _WordT;\n   _WordT _M_w;\n \n-  _Base_bitset( void ) { _M_do_reset(); }\n+  _Base_bitset( void ) : _M_w(0) {}\n+  _Base_bitset(unsigned long __val) : _M_w(__val) {}\n \n-  _Base_bitset(unsigned long __val);\n-\n-  static size_t _S_whichword( size_t __pos ) {\n-    return __pos / __BITS_PER_WORDT(_WordT);\n-  }\n-  static size_t _S_whichbyte( size_t __pos ) {\n-    return (__pos % __BITS_PER_WORDT(_WordT)) / CHAR_BIT;\n-  }\n-  static size_t _S_whichbit( size_t __pos ) {\n-    return __pos % __BITS_PER_WORDT(_WordT);\n-  }\n-  static _WordT _S_maskbit( size_t __pos ) {\n-    return (static_cast<_WordT>(1)) << _S_whichbit(__pos);\n-  }\n+  static size_t _S_whichword( size_t __pos )\n+    { return __pos / __BITS_PER_WORD; }\n+  static size_t _S_whichbyte( size_t __pos )\n+    { return (__pos % __BITS_PER_WORD) / CHAR_BIT; }\n+  static size_t _S_whichbit( size_t __pos )\n+    {  return __pos % __BITS_PER_WORD; }\n+  static _WordT _S_maskbit( size_t __pos )\n+    { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n \n   _WordT& _M_getword(size_t)       { return _M_w; }\n   _WordT  _M_getword(size_t) const { return _M_w; }\n \n   _WordT& _M_hiword()       { return _M_w; }\n   _WordT  _M_hiword() const { return _M_w; }\n \n-  void _M_do_and(const _Base_bitset<1,_WordT>& __x) { _M_w &= __x._M_w; }\n-  void _M_do_or(const _Base_bitset<1,_WordT>& __x)  { _M_w |= __x._M_w; }\n-  void _M_do_xor(const _Base_bitset<1,_WordT>& __x) { _M_w ^= __x._M_w; }\n+  void _M_do_and(const _Base_bitset<1>& __x) { _M_w &= __x._M_w; }\n+  void _M_do_or(const _Base_bitset<1>& __x)  { _M_w |= __x._M_w; }\n+  void _M_do_xor(const _Base_bitset<1>& __x) { _M_w ^= __x._M_w; }\n   void _M_do_left_shift(size_t __shift)     { _M_w <<= __shift; }\n   void _M_do_right_shift(size_t __shift)    { _M_w >>= __shift; }\n   void _M_do_flip()                       { _M_w = ~_M_w; }\n   void _M_do_set()                        { _M_w = ~static_cast<_WordT>(0); }\n   void _M_do_reset()                      { _M_w = 0; }\n \n-  bool _M_is_equal(const _Base_bitset<1,_WordT>& __x) const {\n-    return _M_w == __x._M_w;\n-  }\n-  bool _M_is_any() const {\n-    return _M_w != 0;\n-  }\n+  bool _M_is_equal(const _Base_bitset<1>& __x) const\n+    { return _M_w == __x._M_w; }\n+  bool _M_is_any() const\n+    { return _M_w != 0; }\n \n   size_t _M_do_count() const {\n     size_t __result = 0;\n     const unsigned char* __byte_ptr = (const unsigned char*)&_M_w;\n-    const unsigned char* __end_ptr = ((const unsigned char*)&_M_w)+sizeof(_M_w);\n+    const unsigned char* __end_ptr\n+      = ((const unsigned char*)&_M_w)+sizeof(_M_w);\n     while ( __byte_ptr < __end_ptr ) {\n       __result += _Bit_count<true>::_S_bit_count[*__byte_ptr];\n       __byte_ptr++;\n     }\n     return __result;\n   }\n \n-  unsigned long _M_do_to_ulong() const {\n-    if (sizeof(_WordT) <= sizeof(unsigned long))\n-        return static_cast<unsigned long>(_M_w);\n-    else {\n-      const _WordT __mask = static_cast<_WordT>(static_cast<unsigned long>(-1));\n-      if (_M_w & ~__mask)\n-        __STL_THROW(overflow_error(\"bitset\"));\n-      return static_cast<unsigned long>(_M_w);\n-    }\n-  }\n+  unsigned long _M_do_to_ulong() const { return _M_w; }\n \n   size_t _M_do_find_first(size_t __not_found) const;\n \n   // find the next \"on\" bit that follows \"prev\"\n-  size_t _M_do_find_next(size_t __prev, size_t __not_found) const;\n+  size_t _M_do_find_next(size_t __prev, size_t __not_found) const; \n \n };\n \n@@ -438,19 +375,7 @@ struct _Base_bitset<1, _WordT> {\n //  _Base_bitset.\n //\n \n-template <class _WordT>\n-_Base_bitset<1, _WordT>::_Base_bitset(unsigned long __val)\n-{\n-  _M_do_reset();\n-  const size_t __n = min(sizeof(unsigned long)*CHAR_BIT,\n-                         __BITS_PER_WORDT(_WordT)*_Nw);\n-  for(size_t __i = 0; __i < __n; ++__i, __val >>= 1)\n-    if ( __val & 0x1 )\n-      _M_w |= _S_maskbit(__i);\n-}\n-\n-template <class _WordT>\n-size_t _Base_bitset<1, _WordT>::_M_do_find_first(size_t __not_found) const\n+size_t _Base_bitset<1>::_M_do_find_first(size_t __not_found) const\n {\n   _WordT __thisword = _M_w;\n \n@@ -469,16 +394,13 @@ size_t _Base_bitset<1, _WordT>::_M_do_find_first(size_t __not_found) const\n   return __not_found;\n }\n \n-template <class _WordT>\n-size_t\n-_Base_bitset<1, _WordT>::_M_do_find_next(size_t __prev,\n-                                         size_t __not_found ) const\n+size_t _Base_bitset<1>::_M_do_find_next(size_t __prev, size_t __not_found ) const\n {\n   // make bound inclusive\n   ++__prev;\n \n   // check out of bounds\n-  if ( __prev >= __BITS_PER_WORDT(_WordT) )\n+  if ( __prev >= __BITS_PER_WORD )\n     return __not_found;\n \n     // search first (and only) word\n@@ -505,97 +427,43 @@ _Base_bitset<1, _WordT>::_M_do_find_next(size_t __prev,\n   return __not_found;\n } // end _M_do_find_next\n \n-//\n-// One last specialization: _M_do_to_ulong() and the constructor from\n-// unsigned long are very simple if the bitset consists of a single\n-// word of type unsigned long.\n-//\n-\n-__STL_TEMPLATE_NULL\n-inline unsigned long\n-_Base_bitset<1, unsigned long>::_M_do_to_ulong() const { return _M_w; }\n-\n-__STL_TEMPLATE_NULL\n-inline _Base_bitset<1, unsigned long>::_Base_bitset(unsigned long __val) {\n-  _M_w = __val;\n-}\n-\n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n // ------------------------------------------------------------\n // Helper class to zero out the unused high-order bits in the highest word.\n \n-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-template <class _WordT, size_t _Extrabits> struct _Sanitize {\n-  static void _M_do_sanitize(_WordT& __val)\n-    { __val &= ~((~static_cast<_WordT>(0)) << _Extrabits); }\n+template <size_t _Extrabits> struct _Sanitize {\n+  static void _M_do_sanitize(unsigned long& __val)\n+    { __val &= ~((~static_cast<unsigned long>(0)) << _Extrabits); }\n };\n \n-template <class _WordT> struct _Sanitize<_WordT, 0> {\n-  static void _M_do_sanitize(_WordT) {}\n+__STL_TEMPLATE_NULL struct _Sanitize<0> {\n+  static void _M_do_sanitize(unsigned long) {}\n };\n \n-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n- \n-template <class _WordT, size_t _Extrabits> struct _Sanitize {\n-  static void _M_do_sanitize(_WordT& __val) {\n-    if (_Extrabits != 0)\n-      __val &= ~((~static_cast<_WordT>(0)) << _Extrabits);\n-  }\n-};\n- \n-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n+\n \n // ------------------------------------------------------------\n // Class bitset.\n //   _Nb may be any nonzero number of type size_t.\n-//   Type _WordT may be any unsigned integral type.\n \n-template<size_t _Nb, class _WordT = unsigned long>\n-class bitset : private _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT>\n+template<size_t _Nb>\n+class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>\n {\n private:\n-  typedef _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT> _Base;\n-\n-  // Import base's protected interface.  Necessary because of new template\n-  // name resolution rules.\n-\n-#ifdef __STL_HAS_NAMESPACES\n-  using _Base::_S_whichword;\n-  using _Base::_S_whichbyte;\n-  using _Base::_S_whichbit;\n-  using _Base::_S_maskbit;\n-  using _Base::_M_getword;\n-  using _Base::_M_hiword;\n-  using _Base::_M_do_and;\n-  using _Base::_M_do_or;\n-  using _Base::_M_do_xor;\n-  using _Base::_M_do_left_shift;\n-  using _Base::_M_do_right_shift;\n-  using _Base::_M_do_flip;\n-  using _Base::_M_do_set;\n-  using _Base::_M_do_reset;\n-  using _Base::_M_is_equal;\n-  using _Base::_M_is_any;\n-  using _Base::_M_do_count;\n-  using _Base::_M_do_to_ulong;\n-  using _Base::_M_do_find_first;\n-  using _Base::_M_do_find_next;\n-#endif /* __STL_HAS_NAMESPACES */\n+  typedef _Base_bitset<__BITSET_WORDS(_Nb)> _Base;\n+  typedef unsigned long _WordT;\n \n private:\n   void _M_do_sanitize() {\n-    _Sanitize<_WordT,_Nb%__BITS_PER_WORDT(_WordT) >\n-      ::_M_do_sanitize(_M_hiword());\n+    _Sanitize<_Nb%__BITS_PER_WORD>::_M_do_sanitize(this->_M_hiword());\n   }\n \n public:\n \n   // bit reference:\n   class reference;\n   friend class reference;\n-  \n+\n   class reference {\n     friend class bitset;\n \n@@ -608,109 +476,109 @@ class bitset : private _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT>\n   public:\n     reference( bitset& __b, size_t __pos ) {\n       _M_wp = &__b._M_getword(__pos);\n-      _M_bpos = _S_whichbit(__pos);\n+      _M_bpos = _Base::_S_whichbit(__pos);\n     }\n \n     ~reference() {}\n \n     // for b[i] = __x;\n     reference& operator=(bool __x) {\n       if ( __x )\n-        *_M_wp |= _S_maskbit(_M_bpos);\n+        *_M_wp |= _Base::_S_maskbit(_M_bpos);\n       else\n-        *_M_wp &= ~_S_maskbit(_M_bpos);\n+        *_M_wp &= ~_Base::_S_maskbit(_M_bpos);\n \n       return *this;\n     }\n \n     // for b[i] = b[__j];\n     reference& operator=(const reference& __j) {\n-      if ( (*(__j._M_wp) & _S_maskbit(__j._M_bpos)) )\n-        *_M_wp |= _S_maskbit(_M_bpos);\n+      if ( (*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)) )\n+        *_M_wp |= _Base::_S_maskbit(_M_bpos);\n       else\n-        *_M_wp &= ~_S_maskbit(_M_bpos);\n+        *_M_wp &= ~_Base::_S_maskbit(_M_bpos);\n \n       return *this;\n     }\n \n     // flips the bit\n-    bool operator~() const { return (*(_M_wp) & _S_maskbit(_M_bpos)) == 0; }\n+    bool operator~() const\n+      { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }\n \n     // for __x = b[i];\n-    operator bool() const { return (*(_M_wp) & _S_maskbit(_M_bpos)) != 0; }\n+    operator bool() const\n+      { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }\n \n     // for b[i].flip();\n     reference& flip() {\n-      *_M_wp ^= _S_maskbit(_M_bpos);\n+      *_M_wp ^= _Base::_S_maskbit(_M_bpos);\n       return *this;\n     }\n   };\n \n   // 23.3.5.1 constructors:\n   bitset() {}\n-  bitset(unsigned long __val) :\n-    _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT>(__val) {}\n+  bitset(unsigned long __val) : _Base_bitset<__BITSET_WORDS(_Nb)>(__val) \n+    { _M_do_sanitize(); }\n \n #ifdef __STL_MEMBER_TEMPLATES\n   template<class _CharT, class _Traits, class _Alloc>\n-  explicit bitset(const basic_string<_CharT,_Traits,_Alloc>& __s,\n+  explicit bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n                   size_t __pos = 0)\n-    : _Base()\n+    : _Base() \n   {\n-    if (__pos > __s.size())\n+    if (__pos > __s.size()) \n       __STL_THROW(out_of_range(\"bitset\"));\n-    _M_copy_from_string(__s, __pos, \n-\t\t        basic_string<_CharT,_Traits,_Alloc>::npos);\n+    _M_copy_from_string(__s, __pos,\n+                        basic_string<_CharT, _Traits, _Alloc>::npos);\n   }\n-\n   template<class _CharT, class _Traits, class _Alloc>\n-    bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n-\t   size_t __pos,\n-\t   size_t __n)\n+  bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n+         size_t __pos,\n+         size_t __n)\n     : _Base() \n-    {\n-      if (__pos > __s.size()) \n-\t__STL_THROW(out_of_range(\"bitset\"));\n-      _M_copy_from_string(__s, __pos, __n);\n-    }\n-#else \n+  {\n+    if (__pos > __s.size()) \n+      __STL_THROW(out_of_range(\"bitset\"));\n+    _M_copy_from_string(__s, __pos, __n);\n+  }\n+#else /* __STL_MEMBER_TEMPLATES */\n   explicit bitset(const basic_string<char>& __s,\n-\t\t  size_t __pos = 0,\n-\t\t  size_t __n = basic_string<char>::npos) \n+                  size_t __pos = 0,\n+                  size_t __n = basic_string<char>::npos) \n     : _Base() \n-    {\n-      if (__pos > __s.size()) \n-        __STL_THROW(out_of_range(\"bitset\"));\n-      _M_copy_from_string(__s, __pos, __n);\n-    }\n-\n+  {\n+    if (__pos > __s.size()) \n+      __STL_THROW(out_of_range(\"bitset\"));\n+    _M_copy_from_string(__s, __pos, __n);\n+  }\n #endif /* __STL_MEMBER_TEMPLATES */\n \n   // 23.3.5.2 bitset operations:\n-  bitset<_Nb,_WordT>& operator&=(const bitset<_Nb,_WordT>& __rhs) {\n-    _M_do_and(__rhs);\n+  bitset<_Nb>& operator&=(const bitset<_Nb>& __rhs) {\n+    this->_M_do_and(__rhs);\n     return *this;\n   }\n \n-  bitset<_Nb,_WordT>& operator|=(const bitset<_Nb,_WordT>& __rhs) {\n-    _M_do_or(__rhs);\n+  bitset<_Nb>& operator|=(const bitset<_Nb>& __rhs) {\n+    this->_M_do_or(__rhs);\n     return *this;\n   }\n \n-  bitset<_Nb,_WordT>& operator^=(const bitset<_Nb,_WordT>& __rhs) {\n-    _M_do_xor(__rhs);\n+  bitset<_Nb>& operator^=(const bitset<_Nb>& __rhs) {\n+    this->_M_do_xor(__rhs);\n     return *this;\n   }\n \n-  bitset<_Nb,_WordT>& operator<<=(size_t __pos) {\n-    _M_do_left_shift(__pos);\n-    _M_do_sanitize();\n+  bitset<_Nb>& operator<<=(size_t __pos) {\n+    this->_M_do_left_shift(__pos);\n+    this->_M_do_sanitize();\n     return *this;\n   }\n \n-  bitset<_Nb,_WordT>& operator>>=(size_t __pos) {\n-    _M_do_right_shift(__pos);\n-    _M_do_sanitize();\n+  bitset<_Nb>& operator>>=(size_t __pos) {\n+    this->_M_do_right_shift(__pos);\n+    this->_M_do_sanitize();\n     return *this;\n   }\n \n@@ -719,131 +587,126 @@ class bitset : private _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT>\n   // Versions of single-bit set, reset, flip, test with no range checking.\n   //\n \n-  bitset<_Nb,_WordT>& _Unchecked_set(size_t __pos) {\n-    _M_getword(__pos) |= _S_maskbit(__pos);\n+  bitset<_Nb>& _Unchecked_set(size_t __pos) {\n+    this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n     return *this;\n   }\n \n-  bitset<_Nb,_WordT>& _Unchecked_set(size_t __pos, int __val) {\n+  bitset<_Nb>& _Unchecked_set(size_t __pos, int __val) {\n     if (__val)\n-      _M_getword(__pos) |= _S_maskbit(__pos);\n+      this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n     else\n-      _M_getword(__pos) &= ~_S_maskbit(__pos);\n+      this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n \n     return *this;\n   }\n \n-  bitset<_Nb,_WordT>& _Unchecked_reset(size_t __pos) {\n-    _M_getword(__pos) &= ~_S_maskbit(__pos);\n+  bitset<_Nb>& _Unchecked_reset(size_t __pos) {\n+    this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n     return *this;\n   }\n \n-  bitset<_Nb,_WordT>& _Unchecked_flip(size_t __pos) {\n-    _M_getword(__pos) ^= _S_maskbit(__pos);\n+  bitset<_Nb>& _Unchecked_flip(size_t __pos) {\n+    this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);\n     return *this;\n   }\n \n   bool _Unchecked_test(size_t __pos) const {\n-    return (_M_getword(__pos) & _S_maskbit(__pos)) != static_cast<_WordT>(0);\n+    return (this->_M_getword(__pos) & _Base::_S_maskbit(__pos))\n+      != static_cast<_WordT>(0);\n   }\n \n   // Set, reset, and flip.\n \n-  bitset<_Nb,_WordT>& set() {\n-    _M_do_set();\n-    _M_do_sanitize();\n+  bitset<_Nb>& set() {\n+    this->_M_do_set();\n+    this->_M_do_sanitize();\n     return *this;\n   }\n \n-  bitset<_Nb,_WordT>& set(size_t __pos) {\n+  bitset<_Nb>& set(size_t __pos) {\n     if (__pos >= _Nb)\n       __STL_THROW(out_of_range(\"bitset\"));\n \n     return _Unchecked_set(__pos);\n   }\n \n-  bitset<_Nb,_WordT>& set(size_t __pos, int __val) {\n+  bitset<_Nb>& set(size_t __pos, int __val) {\n     if (__pos >= _Nb)\n       __STL_THROW(out_of_range(\"bitset\"));\n \n     return _Unchecked_set(__pos, __val);\n   }\n \n-  bitset<_Nb,_WordT>& reset() {\n-    _M_do_reset();\n+  bitset<_Nb>& reset() {\n+    this->_M_do_reset();\n     return *this;\n   }\n \n-  bitset<_Nb,_WordT>& reset(size_t __pos) {\n+  bitset<_Nb>& reset(size_t __pos) {\n     if (__pos >= _Nb)\n       __STL_THROW(out_of_range(\"bitset\"));\n \n     return _Unchecked_reset(__pos);\n   }\n \n-  bitset<_Nb,_WordT>& flip() {\n-    _M_do_flip();\n-    _M_do_sanitize();\n+  bitset<_Nb>& flip() {\n+    this->_M_do_flip();\n+    this->_M_do_sanitize();\n     return *this;\n   }\n \n-  bitset<_Nb,_WordT>& flip(size_t __pos) {\n+  bitset<_Nb>& flip(size_t __pos) {\n     if (__pos >= _Nb)\n       __STL_THROW(out_of_range(\"bitset\"));\n \n     return _Unchecked_flip(__pos);\n   }\n \n-  bitset<_Nb,_WordT> operator~() const {\n-    return bitset<_Nb,_WordT>(*this).flip();\n+  bitset<_Nb> operator~() const { \n+    return bitset<_Nb>(*this).flip();\n   }\n \n   // element access:\n   //for b[i];\n   reference operator[](size_t __pos) { return reference(*this,__pos); }\n   bool operator[](size_t __pos) const { return _Unchecked_test(__pos); }\n \n-  unsigned long to_ulong() const { return _M_do_to_ulong(); }\n-\n-#if  defined(__STL_MEMBER_TEMPLATES) && \\\n-     defined(__STL_EXPLICIT_FUNCTION_TMPL_ARGS)\n+  unsigned long to_ulong() const { return this->_M_do_to_ulong(); }\n \n+#if defined(__STL_MEMBER_TEMPLATES) && \\\n+    defined(__STL_EXPLICIT_FUNCTION_TMPL_ARGS)\n   template <class _CharT, class _Traits, class _Alloc>\n   basic_string<_CharT, _Traits, _Alloc> to_string() const {\n     basic_string<_CharT, _Traits, _Alloc> __result;\n     _M_copy_to_string(__result);\n     return __result;\n   }\n-\n #endif /* member templates and explicit function template args */\n \n   // Helper functions for string operations.\n #ifdef __STL_MEMBER_TEMPLATES\n-\n   template<class _CharT, class _Traits, class _Alloc>\n   void _M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,\n                           size_t,\n                           size_t);\n \n   template<class _CharT, class _Traits, class _Alloc>\n   void _M_copy_to_string(basic_string<_CharT,_Traits,_Alloc>&) const;\n-\n #else /* __STL_MEMBER_TEMPLATES */\n-\n   void _M_copy_from_string(const basic_string<char>&, size_t, size_t);\n   void _M_copy_to_string(basic_string<char>&) const;\n-\n #endif /* __STL_MEMBER_TEMPLATES */\n \n-  size_t count() const { return _M_do_count(); }\n+  size_t count() const { return this->_M_do_count(); }\n \n   size_t size() const { return _Nb; }\n \n-  bool operator==(const bitset<_Nb,_WordT>& __rhs) const {\n-    return _M_is_equal(__rhs);\n+  bool operator==(const bitset<_Nb>& __rhs) const {\n+    return this->_M_is_equal(__rhs);\n   }\n-  bool operator!=(const bitset<_Nb,_WordT>& __rhs) const {\n-    return !_M_is_equal(__rhs);\n+  bool operator!=(const bitset<_Nb>& __rhs) const {\n+    return !this->_M_is_equal(__rhs);\n   }\n \n   bool test(size_t __pos) const {\n@@ -853,27 +716,27 @@ class bitset : private _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT>\n     return _Unchecked_test(__pos);\n   }\n \n-  bool any() const { return _M_is_any(); }\n-  bool none() const { return !_M_is_any(); }\n+  bool any() const { return this->_M_is_any(); }\n+  bool none() const { return !this->_M_is_any(); }\n \n-  bitset<_Nb,_WordT> operator<<(size_t __pos) const\n-    { return bitset<_Nb,_WordT>(*this) <<= __pos; }\n-  bitset<_Nb,_WordT> operator>>(size_t __pos) const\n-    { return bitset<_Nb,_WordT>(*this) >>= __pos; }\n+  bitset<_Nb> operator<<(size_t __pos) const\n+    { return bitset<_Nb>(*this) <<= __pos; }\n+  bitset<_Nb> operator>>(size_t __pos) const\n+    { return bitset<_Nb>(*this) >>= __pos; }\n \n   //\n   // EXTENSIONS: bit-find operations.  These operations are\n   // experimental, and are subject to change or removal in future\n   // versions.\n-  //\n+  // \n \n   // find the index of the first \"on\" bit\n-  size_t _Find_first() const\n-    { return _M_do_find_first(_Nb); }\n+  size_t _Find_first() const \n+    { return this->_M_do_find_first(_Nb); }\n \n   // find the index of the next \"on\" bit after prev\n-  size_t _Find_next( size_t __prev ) const\n-    { return _M_do_find_next(__prev, _Nb); }\n+  size_t _Find_next( size_t __prev ) const \n+    { return this->_M_do_find_next(__prev, _Nb); }\n \n };\n \n@@ -883,9 +746,9 @@ class bitset : private _Base_bitset<__BITSET_WORDS(_Nb,_WordT), _WordT>\n \n #ifdef __STL_MEMBER_TEMPLATES\n \n-template <size_t _Nb, class _WordT>\n+template <size_t _Nb>\n template<class _CharT, class _Traits, class _Alloc>\n-void bitset<_Nb, _WordT>\n+void bitset<_Nb>\n   ::_M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,\n                         size_t __pos,\n                         size_t __n)\n@@ -905,23 +768,23 @@ void bitset<_Nb, _WordT>\n   }\n }\n \n-template <size_t _Nb, class _WordT>\n+template <size_t _Nb>\n template <class _CharT, class _Traits, class _Alloc>\n-void bitset<_Nb, _WordT>\n+void bitset<_Nb>\n   ::_M_copy_to_string(basic_string<_CharT, _Traits, _Alloc>& __s) const\n {\n   __s.assign(_Nb, '0');\n-\n-  for (size_t __i = 0; __i < _Nb; ++__i)\n+  \n+  for (size_t __i = 0; __i < _Nb; ++__i) \n     if (_Unchecked_test(__i))\n       __s[_Nb - 1 - __i] = '1';\n }\n \n #else /* __STL_MEMBER_TEMPLATES */\n- \n-template <size_t _Nb, class _WordT>\n-void bitset<_Nb, _WordT>::_M_copy_from_string(const basic_string<char>& __s,\n-\t\t\t\t\t      size_t __pos, size_t __n)\n+\n+template <size_t _Nb>\n+void bitset<_Nb>::_M_copy_from_string(const basic_string<char>& __s,\n+                                      size_t __pos, size_t __n)\n {\n   reset();\n   size_t __tmp = _Nb;\n@@ -939,8 +802,8 @@ void bitset<_Nb, _WordT>::_M_copy_from_string(const basic_string<char>& __s,\n   }\n }\n \n-template <size_t _Nb, class _WordT>\n-void bitset<_Nb, _WordT>::_M_copy_to_string(basic_string<char>& __s) const\n+template <size_t _Nb>\n+void bitset<_Nb>::_M_copy_to_string(basic_string<char>& __s) const\n {\n   __s.assign(_Nb, '0');\n   \n@@ -957,36 +820,33 @@ void bitset<_Nb, _WordT>::_M_copy_to_string(basic_string<char>& __s) const\n // 23.3.5.3 bitset operations:\n //\n \n-template <size_t _Nb, class _WordT>\n-inline bitset<_Nb,_WordT> operator&(const bitset<_Nb,_WordT>& __x,\n-                                    const bitset<_Nb,_WordT>& __y) {\n-  bitset<_Nb,_WordT> __result(__x);\n+template <size_t _Nb>\n+inline bitset<_Nb> operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y) {\n+  bitset<_Nb> __result(__x);\n   __result &= __y;\n   return __result;\n }\n \n \n-template <size_t _Nb, class _WordT>\n-inline bitset<_Nb,_WordT> operator|(const bitset<_Nb,_WordT>& __x,\n-                                    const bitset<_Nb,_WordT>& __y) {\n-  bitset<_Nb,_WordT> __result(__x);\n+template <size_t _Nb>\n+inline bitset<_Nb> operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y) {\n+  bitset<_Nb> __result(__x);\n   __result |= __y;\n   return __result;\n }\n \n-template <size_t _Nb, class _WordT>\n-inline bitset<_Nb,_WordT> operator^(const bitset<_Nb,_WordT>& __x,\n-                                    const bitset<_Nb,_WordT>& __y) {\n-  bitset<_Nb,_WordT> __result(__x);\n+template <size_t _Nb>\n+inline bitset<_Nb> operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y) {\n+  bitset<_Nb> __result(__x);\n   __result ^= __y;\n   return __result;\n }\n \n #ifdef __STL_USE_NEW_IOSTREAMS\n \n-template <class _CharT, class _Traits, size_t _Nb, class _WordT>\n+template <class _CharT, class _Traits, size_t _Nb>\n basic_istream<_CharT, _Traits>&\n-operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Nb,_WordT>& __x)\n+operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)\n {\n   basic_string<_CharT, _Traits> __tmp;\n   __tmp.reserve(_Nb);\n@@ -1025,10 +885,9 @@ operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Nb,_WordT>& __x)\n   return __is;\n }\n \n-template <class _CharT, class _Traits, size_t _Nb, class _WordT>\n+template <class _CharT, class _Traits, size_t _Nb>\n basic_ostream<_CharT, _Traits>&\n-operator<<(basic_ostream<_CharT, _Traits>& __os,\n-           const bitset<_Nb,_WordT>& __x)\n+operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Nb>& __x)\n {\n   basic_string<_CharT, _Traits> __tmp;\n   __x._M_copy_to_string(__tmp);\n@@ -1037,9 +896,8 @@ operator<<(basic_ostream<_CharT, _Traits>& __os,\n \n #else /* __STL_USE_NEW_IOSTREAMS */\n \n-template <size_t _Nb, class _WordT>\n-istream&\n-operator>>(istream& __is, bitset<_Nb,_WordT>& __x) {\n+template <size_t _Nb>\n+istream& operator>>(istream& __is, bitset<_Nb>& __x) {\n   string __tmp;\n   __tmp.reserve(_Nb);\n \n@@ -1074,8 +932,8 @@ operator>>(istream& __is, bitset<_Nb,_WordT>& __x) {\n   return __is;\n }\n \n-template <size_t _Nb, class _WordT>\n-ostream& operator<<(ostream& __os, const bitset<_Nb,_WordT>& __x) {\n+template <size_t _Nb>\n+ostream& operator<<(ostream& __os, const bitset<_Nb>& __x) {\n   string __tmp;\n   __x._M_copy_to_string(__tmp);\n   return __os << __tmp;\n@@ -1140,7 +998,7 @@ unsigned char _Bit_count<__dummy>::_S_bit_count[] = {\n   6, /* 245 */ 6, /* 246 */ 7, /* 247 */ 5, /* 248 */ 6, /* 249 */\n   6, /* 250 */ 7, /* 251 */ 6, /* 252 */ 7, /* 253 */ 7, /* 254 */\n   8  /* 255 */\n-}; // end _S_bit_count\n+}; // end _Bit_count\n \n template<bool __dummy>\n unsigned char _First_one<__dummy>::_S_first_one[] = {\n@@ -1205,12 +1063,13 @@ unsigned char _First_one<__dummy>::_S_first_one[] = {\n __STL_END_NAMESPACE\n \n \n-#undef __BITS_PER_WORDT\n+#undef __BITS_PER_WORD\n #undef __BITSET_WORDS\n \n-#endif /* _CPP_BITSET */\n+#endif /* __SGI_STL_BITSET */\n \n \n // Local Variables:\n // mode:C++\n // End:\n+"}, {"sha": "d7fe92d3ee03f9fda2459340559c2eaf9495be2a", "filename": "libstdc++-v3/bits/std_map.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstd_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstd_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_map.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -27,7 +27,7 @@\n #ifndef _CPP_MAP\n #define _CPP_MAP 1\n \n-#ifndef _CPP_BITS_STL_TREE_H  /* XXX is this guard necessary? */\n+#ifndef _CPP_BITS_STL_TREE_H  \n #include <bits/stl_tree.h>\n #endif\n #include <bits/stl_map.h>"}, {"sha": "5ee126bd8e9808b9ee43ca2e3c05c5bcc527e19d", "filename": "libstdc++-v3/bits/std_memory.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstd_memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstd_memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_memory.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -62,9 +62,13 @@ template <class _Tp> class auto_ptr {\n     return *this;\n   }\n #endif /* __STL_MEMBER_TEMPLATES */\n-\n-  ~auto_ptr() __STL_NOTHROW { delete _M_ptr; }\n-\n+  \n+  // Note: The C++ standard says there is supposed to be an empty throw\n+  // specification here, but omitting it is standard conforming.  Its \n+  // presence can be detected only if _Tp::~_Tp() throws, but (17.4.3.6/2)\n+  // this is prohibited.\n+  ~auto_ptr() { delete _M_ptr; }\n+ \n   _Tp& operator*() const __STL_NOTHROW {\n     return *_M_ptr;\n   }"}, {"sha": "c432d3d3ebcd01fa485d14f678f5353ff0dd79c4", "filename": "libstdc++-v3/bits/stl_algo.h", "status": "modified", "additions": 415, "deletions": 18, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_algo.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -33,6 +33,10 @@\n \n #include <bits/stl_heap.h>\n \n+// See concept_checks.h for the concept-checking macros \n+// __STL_REQUIRES, __STL_CONVERTIBLE, etc.\n+\n+\n __STL_BEGIN_NAMESPACE\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n@@ -43,6 +47,7 @@ __STL_BEGIN_NAMESPACE\n \n template <class _Tp>\n inline const _Tp& __median(const _Tp& __a, const _Tp& __b, const _Tp& __c) {\n+  __STL_REQUIRES(_Tp, _LessThanComparable);\n   if (__a < __b)\n     if (__b < __c)\n       return __b;\n@@ -61,6 +66,7 @@ inline const _Tp& __median(const _Tp& __a, const _Tp& __b, const _Tp& __c) {\n template <class _Tp, class _Compare>\n inline const _Tp&\n __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp) {\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool, _Tp, _Tp);\n   if (__comp(__a, __b))\n     if (__comp(__b, __c))\n       return __b;\n@@ -79,6 +85,7 @@ __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp) {\n // for_each.  Apply a function to every element of a range.\n template <class _InputIter, class _Function>\n _Function for_each(_InputIter __first, _InputIter __last, _Function __f) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n   for ( ; __first != __last; ++__first)\n     __f(*__first);\n   return __f;\n@@ -91,7 +98,7 @@ inline _InputIter find(_InputIter __first, _InputIter __last,\n                        const _Tp& __val,\n                        input_iterator_tag)\n {\n-  while (__first != __last && *__first != __val)\n+  while (__first != __last && !(*__first == __val))\n     ++__first;\n   return __first;\n }\n@@ -190,19 +197,28 @@ template <class _InputIter, class _Tp>\n inline _InputIter find(_InputIter __first, _InputIter __last,\n                        const _Tp& __val)\n {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool, \n+            typename iterator_traits<_InputIter>::value_type, _Tp);\n   return find(__first, __last, __val, __ITERATOR_CATEGORY(__first));\n }\n \n template <class _InputIter, class _Predicate>\n inline _InputIter find_if(_InputIter __first, _InputIter __last,\n                           _Predicate __pred) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool,\n+          typename iterator_traits<_InputIter>::value_type);\n   return find_if(__first, __last, __pred, __ITERATOR_CATEGORY(__first));\n }\n \n // adjacent_find.\n \n template <class _ForwardIter>\n _ForwardIter adjacent_find(_ForwardIter __first, _ForwardIter __last) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES(typename iterator_traits<_ForwardIter>::value_type,\n+                 _EqualityComparable);\n   if (__first == __last)\n     return __last;\n   _ForwardIter __next = __first;\n@@ -217,6 +233,10 @@ _ForwardIter adjacent_find(_ForwardIter __first, _ForwardIter __last) {\n template <class _ForwardIter, class _BinaryPredicate>\n _ForwardIter adjacent_find(_ForwardIter __first, _ForwardIter __last,\n                            _BinaryPredicate __binary_pred) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, bool,\n+          typename iterator_traits<_ForwardIter>::value_type,\n+          typename iterator_traits<_ForwardIter>::value_type);\n   if (__first == __last)\n     return __last;\n   _ForwardIter __next = __first;\n@@ -237,6 +257,10 @@ _ForwardIter adjacent_find(_ForwardIter __first, _ForwardIter __last,\n template <class _InputIter, class _Tp, class _Size>\n void count(_InputIter __first, _InputIter __last, const _Tp& __value,\n            _Size& __n) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter>::value_type,\n+                 _EqualityComparable);\n+  __STL_REQUIRES(_Tp, _EqualityComparable);\n   for ( ; __first != __last; ++__first)\n     if (*__first == __value)\n       ++__n;\n@@ -245,6 +269,9 @@ void count(_InputIter __first, _InputIter __last, const _Tp& __value,\n template <class _InputIter, class _Predicate, class _Size>\n void count_if(_InputIter __first, _InputIter __last, _Predicate __pred,\n               _Size& __n) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool, \n+                  typename iterator_traits<_InputIter>::value_type);\n   for ( ; __first != __last; ++__first)\n     if (__pred(*__first))\n       ++__n;\n@@ -255,6 +282,10 @@ void count_if(_InputIter __first, _InputIter __last, _Predicate __pred,\n template <class _InputIter, class _Tp>\n typename iterator_traits<_InputIter>::difference_type\n count(_InputIter __first, _InputIter __last, const _Tp& __value) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter>::value_type,\n+                 _EqualityComparable);\n+  __STL_REQUIRES(_Tp, _EqualityComparable);\n   typename iterator_traits<_InputIter>::difference_type __n = 0;\n   for ( ; __first != __last; ++__first)\n     if (*__first == __value)\n@@ -265,6 +296,9 @@ count(_InputIter __first, _InputIter __last, const _Tp& __value) {\n template <class _InputIter, class _Predicate>\n typename iterator_traits<_InputIter>::difference_type\n count_if(_InputIter __first, _InputIter __last, _Predicate __pred) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool, \n+                  typename iterator_traits<_InputIter>::value_type);\n   typename iterator_traits<_InputIter>::difference_type __n = 0;\n   for ( ; __first != __last; ++__first)\n     if (__pred(*__first))\n@@ -281,6 +315,12 @@ template <class _ForwardIter1, class _ForwardIter2>\n _ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,\n                      _ForwardIter2 __first2, _ForwardIter2 __last2) \n {\n+  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);\n+  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);\n+  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool,\n+   typename iterator_traits<_ForwardIter1>::value_type,\n+   typename iterator_traits<_ForwardIter2>::value_type);\n+\n   // Test for empty ranges\n   if (__first1 == __last1 || __first2 == __last2)\n     return __first1;\n@@ -326,6 +366,12 @@ _ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,\n                      _ForwardIter2 __first2, _ForwardIter2 __last2,\n                      _BinaryPred  __predicate) \n {\n+  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);\n+  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_BinaryPred, bool,\n+   typename iterator_traits<_ForwardIter1>::value_type,\n+   typename iterator_traits<_ForwardIter2>::value_type);\n+\n   // Test for empty ranges\n   if (__first1 == __last1 || __first2 == __last2)\n     return __first1;\n@@ -379,6 +425,11 @@ _ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,\n template <class _ForwardIter, class _Integer, class _Tp>\n _ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,\n                       _Integer __count, const _Tp& __val) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES(typename iterator_traits<_ForwardIter>::value_type,\n+                 _EqualityComparable);\n+  __STL_REQUIRES(_Tp, _EqualityComparable);\n+\n   if (__count <= 0)\n     return __first;\n   else {\n@@ -404,6 +455,9 @@ template <class _ForwardIter, class _Integer, class _Tp, class _BinaryPred>\n _ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,\n                       _Integer __count, const _Tp& __val,\n                       _BinaryPred __binary_pred) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_BinaryPred, bool, \n+             typename iterator_traits<_ForwardIter>::value_type, _Tp);\n   if (__count <= 0)\n     return __first;\n   else {\n@@ -440,6 +494,12 @@ _ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,\n template <class _ForwardIter1, class _ForwardIter2>\n _ForwardIter2 swap_ranges(_ForwardIter1 __first1, _ForwardIter1 __last1,\n                           _ForwardIter2 __first2) {\n+  __STL_REQUIRES(_ForwardIter1, _Mutable_ForwardIterator);\n+  __STL_REQUIRES(_ForwardIter2, _Mutable_ForwardIterator);\n+  __STL_CONVERTIBLE(typename iterator_traits<_ForwardIter1>::value_type,\n+                    typename iterator_traits<_ForwardIter2>::value_type);\n+  __STL_CONVERTIBLE(typename iterator_traits<_ForwardIter2>::value_type,\n+                    typename iterator_traits<_ForwardIter1>::value_type);\n   for ( ; __first1 != __last1; ++__first1, ++__first2)\n     iter_swap(__first1, __first2);\n   return __first2;\n@@ -450,6 +510,9 @@ _ForwardIter2 swap_ranges(_ForwardIter1 __first1, _ForwardIter1 __last1,\n template <class _InputIter, class _OutputIter, class _UnaryOperation>\n _OutputIter transform(_InputIter __first, _InputIter __last,\n                       _OutputIter __result, _UnaryOperation __unary_op) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+\n   for ( ; __first != __last; ++__first, ++__result)\n     *__result = __unary_op(*__first);\n   return __result;\n@@ -460,6 +523,9 @@ template <class _InputIter1, class _InputIter2, class _OutputIter,\n _OutputIter transform(_InputIter1 __first1, _InputIter1 __last1,\n                       _InputIter2 __first2, _OutputIter __result,\n                       _BinaryOperation __binary_op) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n   for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)\n     *__result = __binary_op(*__first1, *__first2);\n   return __result;\n@@ -470,6 +536,10 @@ _OutputIter transform(_InputIter1 __first1, _InputIter1 __last1,\n template <class _ForwardIter, class _Tp>\n void replace(_ForwardIter __first, _ForwardIter __last,\n              const _Tp& __old_value, const _Tp& __new_value) {\n+  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);\n+  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool,\n+         typename iterator_traits<_ForwardIter>::value_type, _Tp);\n+  __STL_CONVERTIBLE(_Tp, typename iterator_traits<_ForwardIter>::value_type);\n   for ( ; __first != __last; ++__first)\n     if (*__first == __old_value)\n       *__first = __new_value;\n@@ -478,6 +548,10 @@ void replace(_ForwardIter __first, _ForwardIter __last,\n template <class _ForwardIter, class _Predicate, class _Tp>\n void replace_if(_ForwardIter __first, _ForwardIter __last,\n                 _Predicate __pred, const _Tp& __new_value) {\n+  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);\n+  __STL_CONVERTIBLE(_Tp, typename iterator_traits<_ForwardIter>::value_type);\n+  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool,\n+             typename iterator_traits<_ForwardIter>::value_type);\n   for ( ; __first != __last; ++__first)\n     if (__pred(*__first))\n       *__first = __new_value;\n@@ -487,15 +561,23 @@ template <class _InputIter, class _OutputIter, class _Tp>\n _OutputIter replace_copy(_InputIter __first, _InputIter __last,\n                          _OutputIter __result,\n                          const _Tp& __old_value, const _Tp& __new_value) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool,\n+         typename iterator_traits<_InputIter>::value_type, _Tp);\n   for ( ; __first != __last; ++__first, ++__result)\n     *__result = *__first == __old_value ? __new_value : *__first;\n   return __result;\n }\n \n-template <class Iterator, class _OutputIter, class _Predicate, class _Tp>\n-_OutputIter replace_copy_if(Iterator __first, Iterator __last,\n+template <class _InputIter, class _OutputIter, class _Predicate, class _Tp>\n+_OutputIter replace_copy_if(_InputIter __first, _InputIter __last,\n                             _OutputIter __result,\n                             _Predicate __pred, const _Tp& __new_value) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool,\n+                typename iterator_traits<_InputIter>::value_type);\n   for ( ; __first != __last; ++__first, ++__result)\n     *__result = __pred(*__first) ? __new_value : *__first;\n   return __result;\n@@ -505,12 +587,16 @@ _OutputIter replace_copy_if(Iterator __first, Iterator __last,\n \n template <class _ForwardIter, class _Generator>\n void generate(_ForwardIter __first, _ForwardIter __last, _Generator __gen) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_GENERATOR_CHECK(_Generator, \n+          typename iterator_traits<_ForwardIter>::value_type);\n   for ( ; __first != __last; ++__first)\n     *__first = __gen();\n }\n \n template <class _OutputIter, class _Size, class _Generator>\n _OutputIter generate_n(_OutputIter __first, _Size __n, _Generator __gen) {\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n   for ( ; __n > 0; --__n, ++__first)\n     *__first = __gen();\n   return __first;\n@@ -521,8 +607,12 @@ _OutputIter generate_n(_OutputIter __first, _Size __n, _Generator __gen) {\n template <class _InputIter, class _OutputIter, class _Tp>\n _OutputIter remove_copy(_InputIter __first, _InputIter __last,\n                         _OutputIter __result, const _Tp& __value) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool,\n+       typename iterator_traits<_InputIter>::value_type, _Tp);\n   for ( ; __first != __last; ++__first)\n-    if (*__first != __value) {\n+    if (!(*__first == __value)) {\n       *__result = *__first;\n       ++__result;\n     }\n@@ -532,6 +622,10 @@ _OutputIter remove_copy(_InputIter __first, _InputIter __last,\n template <class _InputIter, class _OutputIter, class _Predicate>\n _OutputIter remove_copy_if(_InputIter __first, _InputIter __last,\n                            _OutputIter __result, _Predicate __pred) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool,\n+             typename iterator_traits<_InputIter>::value_type);\n   for ( ; __first != __last; ++__first)\n     if (!__pred(*__first)) {\n       *__result = *__first;\n@@ -543,6 +637,10 @@ _OutputIter remove_copy_if(_InputIter __first, _InputIter __last,\n template <class _ForwardIter, class _Tp>\n _ForwardIter remove(_ForwardIter __first, _ForwardIter __last,\n                     const _Tp& __value) {\n+  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);\n+  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool,\n+       typename iterator_traits<_ForwardIter>::value_type, _Tp);\n+  __STL_CONVERTIBLE(_Tp, typename iterator_traits<_ForwardIter>::value_type);\n   __first = find(__first, __last, __value);\n   _ForwardIter __i = __first;\n   return __first == __last ? __first \n@@ -552,6 +650,9 @@ _ForwardIter remove(_ForwardIter __first, _ForwardIter __last,\n template <class _ForwardIter, class _Predicate>\n _ForwardIter remove_if(_ForwardIter __first, _ForwardIter __last,\n                        _Predicate __pred) {\n+  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);\n+  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool,\n+               typename iterator_traits<_ForwardIter>::value_type);\n   __first = find_if(__first, __last, __pred);\n   _ForwardIter __i = __first;\n   return __first == __last ? __first \n@@ -566,7 +667,7 @@ _OutputIter __unique_copy(_InputIter __first, _InputIter __last,\n   _Tp __value = *__first;\n   *__result = __value;\n   while (++__first != __last)\n-    if (__value != *__first) {\n+    if (!(__value == *__first)) {\n       __value = *__first;\n       *++__result = __value;\n     }\n@@ -585,13 +686,18 @@ _ForwardIter __unique_copy(_InputIter __first, _InputIter __last,\n                            _ForwardIter __result, forward_iterator_tag) {\n   *__result = *__first;\n   while (++__first != __last)\n-    if (*__result != *__first) *++__result = *__first;\n+    if (!(*__result == *__first))\n+      *++__result = *__first;\n   return ++__result;\n }\n \n template <class _InputIter, class _OutputIter>\n inline _OutputIter unique_copy(_InputIter __first, _InputIter __last,\n                                _OutputIter __result) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter>::value_type,\n+                 _EqualityComparable);\n   if (__first == __last) return __result;\n   return __unique_copy(__first, __last, __result,\n                        __ITERATOR_CATEGORY(__result));\n@@ -602,6 +708,7 @@ template <class _InputIter, class _OutputIter, class _BinaryPredicate,\n _OutputIter __unique_copy(_InputIter __first, _InputIter __last,\n                           _OutputIter __result,\n                           _BinaryPredicate __binary_pred, _Tp*) {\n+  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, bool, _Tp, _Tp);\n   _Tp __value = *__first;\n   *__result = __value;\n   while (++__first != __last)\n@@ -626,6 +733,9 @@ _ForwardIter __unique_copy(_InputIter __first, _InputIter __last,\n                            _ForwardIter __result, \n                            _BinaryPredicate __binary_pred,\n                            forward_iterator_tag) {\n+  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, bool,\n+     typename iterator_traits<_ForwardIter>::value_type,\n+     typename iterator_traits<_InputIter>::value_type);\n   *__result = *__first;\n   while (++__first != __last)\n     if (!__binary_pred(*__result, *__first)) *++__result = *__first;\n@@ -636,20 +746,29 @@ template <class _InputIter, class _OutputIter, class _BinaryPredicate>\n inline _OutputIter unique_copy(_InputIter __first, _InputIter __last,\n                                _OutputIter __result,\n                                _BinaryPredicate __binary_pred) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n   if (__first == __last) return __result;\n   return __unique_copy(__first, __last, __result, __binary_pred,\n                        __ITERATOR_CATEGORY(__result));\n }\n \n template <class _ForwardIter>\n _ForwardIter unique(_ForwardIter __first, _ForwardIter __last) {\n+  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);\n+  __STL_REQUIRES(typename iterator_traits<_ForwardIter>::value_type,\n+                 _EqualityComparable);\n   __first = adjacent_find(__first, __last);\n   return unique_copy(__first, __last, __first);\n }\n \n template <class _ForwardIter, class _BinaryPredicate>\n _ForwardIter unique(_ForwardIter __first, _ForwardIter __last,\n                     _BinaryPredicate __binary_pred) {\n+  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, bool, \n+      typename iterator_traits<_ForwardIter>::value_type,\n+      typename iterator_traits<_ForwardIter>::value_type);\n   __first = adjacent_find(__first, __last, __binary_pred);\n   return unique_copy(__first, __last, __first, __binary_pred);\n }\n@@ -675,13 +794,16 @@ void __reverse(_RandomAccessIter __first, _RandomAccessIter __last,\n \n template <class _BidirectionalIter>\n inline void reverse(_BidirectionalIter __first, _BidirectionalIter __last) {\n+  __STL_REQUIRES(_BidirectionalIter, _Mutable_BidirectionalIterator);\n   __reverse(__first, __last, __ITERATOR_CATEGORY(__first));\n }\n \n template <class _BidirectionalIter, class _OutputIter>\n _OutputIter reverse_copy(_BidirectionalIter __first,\n-                            _BidirectionalIter __last,\n-                            _OutputIter __result) {\n+                         _BidirectionalIter __last,\n+                         _OutputIter __result) {\n+  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n   while (__first != __last) {\n     --__last;\n     *__result = *__last;\n@@ -744,6 +866,7 @@ _BidirectionalIter __rotate(_BidirectionalIter __first,\n                             _BidirectionalIter __last,\n                             _Distance*,\n                             bidirectional_iterator_tag) {\n+  __STL_REQUIRES(_BidirectionalIter, _Mutable_BidirectionalIterator);\n   if (__first == __middle)\n     return __last;\n   if (__last  == __middle)\n@@ -770,7 +893,7 @@ _RandomAccessIter __rotate(_RandomAccessIter __first,\n                            _RandomAccessIter __middle,\n                            _RandomAccessIter __last,\n                            _Distance *, _Tp *) {\n-\n+  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);\n   _Distance __n = __last   - __first;\n   _Distance __k = __middle - __first;\n   _Distance __l = __n - __k;\n@@ -824,14 +947,17 @@ _RandomAccessIter __rotate(_RandomAccessIter __first,\n template <class _ForwardIter>\n inline _ForwardIter rotate(_ForwardIter __first, _ForwardIter __middle,\n                            _ForwardIter __last) {\n+  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);\n   return __rotate(__first, __middle, __last,\n                   __DISTANCE_TYPE(__first),\n                   __ITERATOR_CATEGORY(__first));\n }\n \n template <class _ForwardIter, class _OutputIter>\n _OutputIter rotate_copy(_ForwardIter __first, _ForwardIter __middle,\n-                            _ForwardIter __last, _OutputIter __result) {\n+                        _ForwardIter __last, _OutputIter __result) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n   return copy(__first, __middle, copy(__middle, __last, __result));\n }\n \n@@ -853,6 +979,7 @@ inline _Distance __random_number(_Distance __n) {\n template <class _RandomAccessIter>\n inline void random_shuffle(_RandomAccessIter __first,\n                            _RandomAccessIter __last) {\n+  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);\n   if (__first == __last) return;\n   for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)\n     iter_swap(__i, __first + __random_number((__i - __first) + 1));\n@@ -861,6 +988,7 @@ inline void random_shuffle(_RandomAccessIter __first,\n template <class _RandomAccessIter, class _RandomNumberGenerator>\n void random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last,\n                     _RandomNumberGenerator& __rand) {\n+  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);\n   if (__first == __last) return;\n   for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)\n     iter_swap(__i, __first + __rand((__i - __first) + 1));\n@@ -872,6 +1000,8 @@ template <class _ForwardIter, class _OutputIter, class _Distance>\n _OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,\n                             _OutputIter __out, const _Distance __n)\n {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n   _Distance __remaining = 0;\n   distance(__first, __last, __remaining);\n   _Distance __m = min(__n, __remaining);\n@@ -895,6 +1025,9 @@ _OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,\n                             _OutputIter __out, const _Distance __n,\n                             _RandomNumberGenerator& __rand)\n {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_UNARY_FUNCTION_CHECK(_RandomNumberGenerator, _Distance, _Distance);\n   _Distance __remaining = 0;\n   distance(__first, __last, __remaining);\n   _Distance __m = min(__n, __remaining);\n@@ -940,6 +1073,7 @@ _RandomAccessIter __random_sample(_InputIter __first, _InputIter __last,\n                                   _RandomNumberGenerator& __rand,\n                                   const _Distance __n)\n {\n+  __STL_UNARY_FUNCTION_CHECK(_RandomNumberGenerator, _Distance, _Distance);\n   _Distance __m = 0;\n   _Distance __t = __n;\n   for ( ; __first != __last && __m < __n; ++__m, ++__first)\n@@ -961,6 +1095,8 @@ inline _RandomAccessIter\n random_sample(_InputIter __first, _InputIter __last,\n               _RandomAccessIter __out_first, _RandomAccessIter __out_last) \n {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);\n   return __random_sample(__first, __last,\n                          __out_first, __out_last - __out_first);\n }\n@@ -973,6 +1109,8 @@ random_sample(_InputIter __first, _InputIter __last,\n               _RandomAccessIter __out_first, _RandomAccessIter __out_last,\n               _RandomNumberGenerator& __rand) \n {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);\n   return __random_sample(__first, __last,\n                          __out_first, __rand,\n                          __out_last - __out_first);\n@@ -1031,6 +1169,9 @@ template <class _ForwardIter, class _Predicate>\n inline _ForwardIter partition(_ForwardIter __first,\n    \t\t\t      _ForwardIter __last,\n \t\t\t      _Predicate   __pred) {\n+  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);\n+  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool, \n+        typename iterator_traits<_ForwardIter>::value_type);\n   return __partition(__first, __last, __pred, __ITERATOR_CATEGORY(__first));\n }\n \n@@ -1105,6 +1246,9 @@ template <class _ForwardIter, class _Predicate>\n inline _ForwardIter stable_partition(_ForwardIter __first,\n                                      _ForwardIter __last, \n                                      _Predicate __pred) {\n+  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);\n+  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool,\n+      typename iterator_traits<_ForwardIter>::value_type);\n   if (__first == __last)\n     return __first;\n   else\n@@ -1320,6 +1464,9 @@ void __introsort_loop(_RandomAccessIter __first,\n \n template <class _RandomAccessIter>\n inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) {\n+  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);\n+  __STL_REQUIRES(typename iterator_traits<_RandomAccessIter>::value_type,\n+                 _LessThanComparable);\n   if (__first != __last) {\n     __introsort_loop(__first, __last,\n                      __VALUE_TYPE(__first),\n@@ -1331,6 +1478,10 @@ inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) {\n template <class _RandomAccessIter, class _Compare>\n inline void sort(_RandomAccessIter __first, _RandomAccessIter __last,\n                  _Compare __comp) {\n+  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,\n+       typename iterator_traits<_RandomAccessIter>::value_type,\n+       typename iterator_traits<_RandomAccessIter>::value_type);\n   if (__first != __last) {\n     __introsort_loop(__first, __last,\n                      __VALUE_TYPE(__first),\n@@ -1546,6 +1697,9 @@ inline void __stable_sort_aux(_RandomAccessIter __first,\n template <class _RandomAccessIter>\n inline void stable_sort(_RandomAccessIter __first,\n                         _RandomAccessIter __last) {\n+  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);\n+  __STL_REQUIRES(typename iterator_traits<_RandomAccessIter>::value_type,\n+                 _LessThanComparable);\n   __stable_sort_aux(__first, __last,\n                     __VALUE_TYPE(__first),\n                     __DISTANCE_TYPE(__first));\n@@ -1554,6 +1708,10 @@ inline void stable_sort(_RandomAccessIter __first,\n template <class _RandomAccessIter, class _Compare>\n inline void stable_sort(_RandomAccessIter __first,\n                         _RandomAccessIter __last, _Compare __comp) {\n+  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,\n+       typename iterator_traits<_RandomAccessIter>::value_type,\n+       typename iterator_traits<_RandomAccessIter>::value_type);\n   __stable_sort_aux(__first, __last,\n                     __VALUE_TYPE(__first),\n                     __DISTANCE_TYPE(__first), \n@@ -1577,6 +1735,9 @@ template <class _RandomAccessIter>\n inline void partial_sort(_RandomAccessIter __first,\n                          _RandomAccessIter __middle,\n                          _RandomAccessIter __last) {\n+  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);\n+  __STL_REQUIRES(typename iterator_traits<_RandomAccessIter>::value_type,\n+                 _LessThanComparable);\n   __partial_sort(__first, __middle, __last, __VALUE_TYPE(__first));\n }\n \n@@ -1595,16 +1756,20 @@ template <class _RandomAccessIter, class _Compare>\n inline void partial_sort(_RandomAccessIter __first,\n                          _RandomAccessIter __middle,\n                          _RandomAccessIter __last, _Compare __comp) {\n+  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool, \n+      typename iterator_traits<_RandomAccessIter>::value_type,\n+      typename iterator_traits<_RandomAccessIter>::value_type);\n   __partial_sort(__first, __middle, __last, __VALUE_TYPE(__first), __comp);\n }\n \n template <class _InputIter, class _RandomAccessIter, class _Distance,\n           class _Tp>\n _RandomAccessIter __partial_sort_copy(_InputIter __first,\n-                                         _InputIter __last,\n-                                         _RandomAccessIter __result_first,\n-                                         _RandomAccessIter __result_last, \n-                                         _Distance*, _Tp*) {\n+                                      _InputIter __last,\n+                                      _RandomAccessIter __result_first,\n+                                      _RandomAccessIter __result_last, \n+                                      _Distance*, _Tp*) {\n   if (__result_first == __result_last) return __result_last;\n   _RandomAccessIter __result_real_last = __result_first;\n   while(__first != __last && __result_real_last != __result_last) {\n@@ -1629,6 +1794,14 @@ inline _RandomAccessIter\n partial_sort_copy(_InputIter __first, _InputIter __last,\n                   _RandomAccessIter __result_first,\n                   _RandomAccessIter __result_last) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);\n+  __STL_CONVERTIBLE(typename iterator_traits<_InputIter>::value_type,\n+                    typename iterator_traits<_RandomAccessIter>::value_type);\n+  __STL_REQUIRES(typename iterator_traits<_RandomAccessIter>::value_type,\n+                 _LessThanComparable);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter>::value_type,\n+                 _LessThanComparable);\n   return __partial_sort_copy(__first, __last, __result_first, __result_last, \n                              __DISTANCE_TYPE(__result_first),\n                              __VALUE_TYPE(__first));\n@@ -1666,6 +1839,13 @@ inline _RandomAccessIter\n partial_sort_copy(_InputIter __first, _InputIter __last,\n                   _RandomAccessIter __result_first,\n                   _RandomAccessIter __result_last, _Compare __comp) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);\n+  __STL_CONVERTIBLE(typename iterator_traits<_InputIter>::value_type,\n+                    typename iterator_traits<_RandomAccessIter>::value_type);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,\n+     typename iterator_traits<_RandomAccessIter>::value_type,\n+     typename iterator_traits<_RandomAccessIter>::value_type);  \n   return __partial_sort_copy(__first, __last, __result_first, __result_last,\n                              __comp,\n                              __DISTANCE_TYPE(__result_first),\n@@ -1694,6 +1874,9 @@ void __nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,\n template <class _RandomAccessIter>\n inline void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,\n                         _RandomAccessIter __last) {\n+  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);\n+  __STL_REQUIRES(typename iterator_traits<_RandomAccessIter>::value_type,\n+                 _LessThanComparable);\n   __nth_element(__first, __nth, __last, __VALUE_TYPE(__first));\n }\n \n@@ -1718,7 +1901,11 @@ void __nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,\n \n template <class _RandomAccessIter, class _Compare>\n inline void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,\n-                 _RandomAccessIter __last, _Compare __comp) {\n+                        _RandomAccessIter __last, _Compare __comp) {\n+  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,\n+     typename iterator_traits<_RandomAccessIter>::value_type,\n+     typename iterator_traits<_RandomAccessIter>::value_type);\n   __nth_element(__first, __nth, __last, __VALUE_TYPE(__first), __comp);\n }\n \n@@ -1751,7 +1938,11 @@ _ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,\n \n template <class _ForwardIter, class _Tp>\n inline _ForwardIter lower_bound(_ForwardIter __first, _ForwardIter __last,\n-                                   const _Tp& __val) {\n+\t\t\t\tconst _Tp& __val) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES_SAME_TYPE(_Tp,\n+      typename iterator_traits<_ForwardIter>::value_type);\n+  __STL_REQUIRES(_Tp, _LessThanComparable);\n   return __lower_bound(__first, __last, __val,\n                        __DISTANCE_TYPE(__first));\n }\n@@ -1783,6 +1974,10 @@ _ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,\n template <class _ForwardIter, class _Tp, class _Compare>\n inline _ForwardIter lower_bound(_ForwardIter __first, _ForwardIter __last,\n                                 const _Tp& __val, _Compare __comp) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES_SAME_TYPE(_Tp,\n+      typename iterator_traits<_ForwardIter>::value_type);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool, _Tp, _Tp);\n   return __lower_bound(__first, __last, __val, __comp,\n                        __DISTANCE_TYPE(__first));\n }\n@@ -1814,6 +2009,10 @@ _ForwardIter __upper_bound(_ForwardIter __first, _ForwardIter __last,\n template <class _ForwardIter, class _Tp>\n inline _ForwardIter upper_bound(_ForwardIter __first, _ForwardIter __last,\n                                 const _Tp& __val) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES_SAME_TYPE(_Tp,\n+      typename iterator_traits<_ForwardIter>::value_type);\n+  __STL_REQUIRES(_Tp, _LessThanComparable);\n   return __upper_bound(__first, __last, __val,\n                        __DISTANCE_TYPE(__first));\n }\n@@ -1845,6 +2044,10 @@ _ForwardIter __upper_bound(_ForwardIter __first, _ForwardIter __last,\n template <class _ForwardIter, class _Tp, class _Compare>\n inline _ForwardIter upper_bound(_ForwardIter __first, _ForwardIter __last,\n                                 const _Tp& __val, _Compare __comp) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES_SAME_TYPE(_Tp,\n+      typename iterator_traits<_ForwardIter>::value_type);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool, _Tp, _Tp);\n   return __upper_bound(__first, __last, __val, __comp,\n                        __DISTANCE_TYPE(__first));\n }\n@@ -1883,6 +2086,10 @@ __equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,\n template <class _ForwardIter, class _Tp>\n inline pair<_ForwardIter, _ForwardIter>\n equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES_SAME_TYPE(_Tp, \n+       typename iterator_traits<_ForwardIter>::value_type);\n+  __STL_REQUIRES(_Tp, _LessThanComparable);\n   return __equal_range(__first, __last, __val,\n                        __DISTANCE_TYPE(__first));\n }\n@@ -1922,13 +2129,21 @@ template <class _ForwardIter, class _Tp, class _Compare>\n inline pair<_ForwardIter, _ForwardIter>\n equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,\n             _Compare __comp) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES_SAME_TYPE(_Tp, \n+       typename iterator_traits<_ForwardIter>::value_type);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool, _Tp, _Tp);\n   return __equal_range(__first, __last, __val, __comp,\n                        __DISTANCE_TYPE(__first));\n } \n \n template <class _ForwardIter, class _Tp>\n bool binary_search(_ForwardIter __first, _ForwardIter __last,\n                    const _Tp& __val) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES_SAME_TYPE(_Tp,\n+        typename iterator_traits<_ForwardIter>::value_type);\n+  __STL_REQUIRES(_Tp, _LessThanComparable);\n   _ForwardIter __i = lower_bound(__first, __last, __val);\n   return __i != __last && !(__val < *__i);\n }\n@@ -1937,6 +2152,10 @@ template <class _ForwardIter, class _Tp, class _Compare>\n bool binary_search(_ForwardIter __first, _ForwardIter __last,\n                    const _Tp& __val,\n                    _Compare __comp) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES_SAME_TYPE(_Tp,\n+        typename iterator_traits<_ForwardIter>::value_type);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool, _Tp, _Tp);\n   _ForwardIter __i = lower_bound(__first, __last, __val, __comp);\n   return __i != __last && !__comp(__val, *__i);\n }\n@@ -1947,6 +2166,14 @@ template <class _InputIter1, class _InputIter2, class _OutputIter>\n _OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,\n                   _InputIter2 __first2, _InputIter2 __last2,\n                   _OutputIter __result) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_REQUIRES_SAME_TYPE(\n+          typename iterator_traits<_InputIter1>::value_type,\n+          typename iterator_traits<_InputIter2>::value_type);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,\n+                 _LessThanComparable);\n   while (__first1 != __last1 && __first2 != __last2) {\n     if (*__first2 < *__first1) {\n       *__result = *__first2;\n@@ -1966,6 +2193,15 @@ template <class _InputIter1, class _InputIter2, class _OutputIter,\n _OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,\n                   _InputIter2 __first2, _InputIter2 __last2,\n                   _OutputIter __result, _Compare __comp) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES_SAME_TYPE(\n+          typename iterator_traits<_InputIter1>::value_type,\n+          typename iterator_traits<_InputIter2>::value_type);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,\n+          typename iterator_traits<_InputIter1>::value_type,\n+          typename iterator_traits<_InputIter1>::value_type);\n   while (__first1 != __last1 && __first2 != __last2) {\n     if (__comp(*__first2, *__first1)) {\n       *__result = *__first2;\n@@ -2263,6 +2499,9 @@ template <class _BidirectionalIter>\n inline void inplace_merge(_BidirectionalIter __first,\n                           _BidirectionalIter __middle,\n                           _BidirectionalIter __last) {\n+  __STL_REQUIRES(_BidirectionalIter, _Mutable_BidirectionalIterator);\n+  __STL_REQUIRES(typename iterator_traits<_BidirectionalIter>::value_type,\n+                 _LessThanComparable);\n   if (__first == __middle || __middle == __last)\n     return;\n   __inplace_merge_aux(__first, __middle, __last,\n@@ -2273,6 +2512,10 @@ template <class _BidirectionalIter, class _Compare>\n inline void inplace_merge(_BidirectionalIter __first,\n                           _BidirectionalIter __middle,\n                           _BidirectionalIter __last, _Compare __comp) {\n+  __STL_REQUIRES(_BidirectionalIter, _Mutable_BidirectionalIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,\n+           typename iterator_traits<_BidirectionalIter>::value_type,\n+           typename iterator_traits<_BidirectionalIter>::value_type);\n   if (__first == __middle || __middle == __last)\n     return;\n   __inplace_merge_aux(__first, __middle, __last,\n@@ -2288,6 +2531,13 @@ inline void inplace_merge(_BidirectionalIter __first,\n template <class _InputIter1, class _InputIter2>\n bool includes(_InputIter1 __first1, _InputIter1 __last1,\n               _InputIter2 __first2, _InputIter2 __last2) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES_SAME_TYPE(\n+       typename iterator_traits<_InputIter1>::value_type,\n+       typename iterator_traits<_InputIter2>::value_type);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,\n+                 _LessThanComparable);\n   while (__first1 != __last1 && __first2 != __last2)\n     if (*__first2 < *__first1)\n       return false;\n@@ -2302,6 +2552,14 @@ bool includes(_InputIter1 __first1, _InputIter1 __last1,\n template <class _InputIter1, class _InputIter2, class _Compare>\n bool includes(_InputIter1 __first1, _InputIter1 __last1,\n               _InputIter2 __first2, _InputIter2 __last2, _Compare __comp) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES_SAME_TYPE(\n+       typename iterator_traits<_InputIter1>::value_type,\n+       typename iterator_traits<_InputIter2>::value_type);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,\n+       typename iterator_traits<_InputIter1>::value_type,\n+       typename iterator_traits<_InputIter2>::value_type);\n   while (__first1 != __last1 && __first2 != __last2)\n     if (__comp(*__first2, *__first1))\n       return false;\n@@ -2317,6 +2575,14 @@ template <class _InputIter1, class _InputIter2, class _OutputIter>\n _OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,\n                       _InputIter2 __first2, _InputIter2 __last2,\n                       _OutputIter __result) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_REQUIRES_SAME_TYPE(\n+       typename iterator_traits<_InputIter1>::value_type,\n+       typename iterator_traits<_InputIter2>::value_type);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,\n+                 _LessThanComparable);\n   while (__first1 != __last1 && __first2 != __last2) {\n     if (*__first1 < *__first2) {\n       *__result = *__first1;\n@@ -2341,6 +2607,15 @@ template <class _InputIter1, class _InputIter2, class _OutputIter,\n _OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,\n                       _InputIter2 __first2, _InputIter2 __last2,\n                       _OutputIter __result, _Compare __comp) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_REQUIRES_SAME_TYPE(\n+       typename iterator_traits<_InputIter1>::value_type,\n+       typename iterator_traits<_InputIter2>::value_type);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,\n+       typename iterator_traits<_InputIter1>::value_type,\n+       typename iterator_traits<_InputIter2>::value_type);\n   while (__first1 != __last1 && __first2 != __last2) {\n     if (__comp(*__first1, *__first2)) {\n       *__result = *__first1;\n@@ -2364,6 +2639,14 @@ template <class _InputIter1, class _InputIter2, class _OutputIter>\n _OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,\n                              _InputIter2 __first2, _InputIter2 __last2,\n                              _OutputIter __result) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_REQUIRES_SAME_TYPE(\n+       typename iterator_traits<_InputIter1>::value_type,\n+       typename iterator_traits<_InputIter2>::value_type);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,\n+                 _LessThanComparable);\n   while (__first1 != __last1 && __first2 != __last2) \n     if (*__first1 < *__first2) \n       ++__first1;\n@@ -2383,6 +2666,16 @@ template <class _InputIter1, class _InputIter2, class _OutputIter,\n _OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,\n                              _InputIter2 __first2, _InputIter2 __last2,\n                              _OutputIter __result, _Compare __comp) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_REQUIRES_SAME_TYPE(\n+       typename iterator_traits<_InputIter1>::value_type,\n+       typename iterator_traits<_InputIter2>::value_type);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,\n+       typename iterator_traits<_InputIter1>::value_type,\n+       typename iterator_traits<_InputIter2>::value_type);\n+\n   while (__first1 != __last1 && __first2 != __last2)\n     if (__comp(*__first1, *__first2))\n       ++__first1;\n@@ -2401,6 +2694,14 @@ template <class _InputIter1, class _InputIter2, class _OutputIter>\n _OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,\n                            _InputIter2 __first2, _InputIter2 __last2,\n                            _OutputIter __result) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_REQUIRES_SAME_TYPE(\n+       typename iterator_traits<_InputIter1>::value_type,\n+       typename iterator_traits<_InputIter2>::value_type);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,\n+                 _LessThanComparable);\n   while (__first1 != __last1 && __first2 != __last2)\n     if (*__first1 < *__first2) {\n       *__result = *__first1;\n@@ -2421,6 +2722,16 @@ template <class _InputIter1, class _InputIter2, class _OutputIter,\n _OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,\n                            _InputIter2 __first2, _InputIter2 __last2, \n                            _OutputIter __result, _Compare __comp) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_REQUIRES_SAME_TYPE(\n+       typename iterator_traits<_InputIter1>::value_type,\n+       typename iterator_traits<_InputIter2>::value_type);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,\n+       typename iterator_traits<_InputIter1>::value_type,\n+       typename iterator_traits<_InputIter2>::value_type);\n+\n   while (__first1 != __last1 && __first2 != __last2)\n     if (__comp(*__first1, *__first2)) {\n       *__result = *__first1;\n@@ -2441,6 +2752,14 @@ _OutputIter\n set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,\n                          _InputIter2 __first2, _InputIter2 __last2,\n                          _OutputIter __result) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_REQUIRES_SAME_TYPE(\n+       typename iterator_traits<_InputIter1>::value_type,\n+       typename iterator_traits<_InputIter2>::value_type);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,\n+                 _LessThanComparable);\n   while (__first1 != __last1 && __first2 != __last2)\n     if (*__first1 < *__first2) {\n       *__result = *__first1;\n@@ -2466,6 +2785,15 @@ set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,\n                          _InputIter2 __first2, _InputIter2 __last2,\n                          _OutputIter __result,\n                          _Compare __comp) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n+  __STL_REQUIRES_SAME_TYPE(\n+       typename iterator_traits<_InputIter1>::value_type,\n+       typename iterator_traits<_InputIter2>::value_type);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,\n+       typename iterator_traits<_InputIter1>::value_type,\n+       typename iterator_traits<_InputIter2>::value_type);\n   while (__first1 != __last1 && __first2 != __last2)\n     if (__comp(*__first1, *__first2)) {\n       *__result = *__first1;\n@@ -2489,6 +2817,9 @@ set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,\n \n template <class _ForwardIter>\n _ForwardIter max_element(_ForwardIter __first, _ForwardIter __last) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES(typename iterator_traits<_ForwardIter>::value_type,\n+                 _LessThanComparable);\n   if (__first == __last) return __first;\n   _ForwardIter __result = __first;\n   while (++__first != __last) \n@@ -2499,7 +2830,11 @@ _ForwardIter max_element(_ForwardIter __first, _ForwardIter __last) {\n \n template <class _ForwardIter, class _Compare>\n _ForwardIter max_element(_ForwardIter __first, _ForwardIter __last,\n-                            _Compare __comp) {\n+\t\t\t _Compare __comp) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,\n+    typename iterator_traits<_ForwardIter>::value_type,\n+    typename iterator_traits<_ForwardIter>::value_type);\n   if (__first == __last) return __first;\n   _ForwardIter __result = __first;\n   while (++__first != __last) \n@@ -2509,6 +2844,9 @@ _ForwardIter max_element(_ForwardIter __first, _ForwardIter __last,\n \n template <class _ForwardIter>\n _ForwardIter min_element(_ForwardIter __first, _ForwardIter __last) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES(typename iterator_traits<_ForwardIter>::value_type,\n+                 _LessThanComparable);\n   if (__first == __last) return __first;\n   _ForwardIter __result = __first;\n   while (++__first != __last) \n@@ -2519,7 +2857,11 @@ _ForwardIter min_element(_ForwardIter __first, _ForwardIter __last) {\n \n template <class _ForwardIter, class _Compare>\n _ForwardIter min_element(_ForwardIter __first, _ForwardIter __last,\n-                            _Compare __comp) {\n+\t\t\t _Compare __comp) {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,\n+    typename iterator_traits<_ForwardIter>::value_type,\n+    typename iterator_traits<_ForwardIter>::value_type);\n   if (__first == __last) return __first;\n   _ForwardIter __result = __first;\n   while (++__first != __last) \n@@ -2533,6 +2875,9 @@ _ForwardIter min_element(_ForwardIter __first, _ForwardIter __last,\n \n template <class _BidirectionalIter>\n bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last) {\n+  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);\n+  __STL_REQUIRES(typename iterator_traits<_BidirectionalIter>::value_type,\n+                 _LessThanComparable);\n   if (__first == __last)\n     return false;\n   _BidirectionalIter __i = __first;\n@@ -2563,6 +2908,10 @@ bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last) {\n template <class _BidirectionalIter, class _Compare>\n bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,\n                       _Compare __comp) {\n+  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,\n+    typename iterator_traits<_BidirectionalIter>::value_type,\n+    typename iterator_traits<_BidirectionalIter>::value_type);\n   if (__first == __last)\n     return false;\n   _BidirectionalIter __i = __first;\n@@ -2592,6 +2941,9 @@ bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,\n \n template <class _BidirectionalIter>\n bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last) {\n+  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);\n+  __STL_REQUIRES(typename iterator_traits<_BidirectionalIter>::value_type,\n+                 _LessThanComparable);\n   if (__first == __last)\n     return false;\n   _BidirectionalIter __i = __first;\n@@ -2622,6 +2974,10 @@ bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last) {\n template <class _BidirectionalIter, class _Compare>\n bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,\n                       _Compare __comp) {\n+  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,\n+    typename iterator_traits<_BidirectionalIter>::value_type,\n+    typename iterator_traits<_BidirectionalIter>::value_type);\n   if (__first == __last)\n     return false;\n   _BidirectionalIter __i = __first;\n@@ -2655,6 +3011,12 @@ template <class _InputIter, class _ForwardIter>\n _InputIter find_first_of(_InputIter __first1, _InputIter __last1,\n                          _ForwardIter __first2, _ForwardIter __last2)\n {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool, \n+     typename iterator_traits<_InputIter>::value_type,\n+     typename iterator_traits<_ForwardIter>::value_type);\n+\n   for ( ; __first1 != __last1; ++__first1) \n     for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)\n       if (*__first1 == *__iter)\n@@ -2667,6 +3029,12 @@ _InputIter find_first_of(_InputIter __first1, _InputIter __last1,\n                          _ForwardIter __first2, _ForwardIter __last2,\n                          _BinaryPredicate __comp)\n {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, bool,\n+     typename iterator_traits<_InputIter>::value_type,\n+     typename iterator_traits<_ForwardIter>::value_type);\n+\n   for ( ; __first1 != __last1; ++__first1) \n     for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)\n       if (__comp(*__first1, *__iter))\n@@ -2738,6 +3106,8 @@ __find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,\n            _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,\n            bidirectional_iterator_tag, bidirectional_iterator_tag)\n {\n+  __STL_REQUIRES(_BidirectionalIter1, _BidirectionalIterator);\n+  __STL_REQUIRES(_BidirectionalIter2, _BidirectionalIterator);\n   typedef reverse_iterator<_BidirectionalIter1> _RevIter1;\n   typedef reverse_iterator<_BidirectionalIter2> _RevIter2;\n \n@@ -2763,6 +3133,8 @@ __find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,\n            bidirectional_iterator_tag, bidirectional_iterator_tag, \n            _BinaryPredicate __comp)\n {\n+  __STL_REQUIRES(_BidirectionalIter1, _BidirectionalIterator);\n+  __STL_REQUIRES(_BidirectionalIter2, _BidirectionalIterator);\n   typedef reverse_iterator<_BidirectionalIter1> _RevIter1;\n   typedef reverse_iterator<_BidirectionalIter2> _RevIter2;\n \n@@ -2789,6 +3161,11 @@ inline _ForwardIter1\n find_end(_ForwardIter1 __first1, _ForwardIter1 __last1, \n          _ForwardIter2 __first2, _ForwardIter2 __last2)\n {\n+  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);\n+  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);\n+  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool,\n+   typename iterator_traits<_ForwardIter1>::value_type,\n+   typename iterator_traits<_ForwardIter2>::value_type);\n   return __find_end(__first1, __last1, __first2, __last2,\n                     __ITERATOR_CATEGORY(__first1),\n                     __ITERATOR_CATEGORY(__first2));\n@@ -2801,6 +3178,12 @@ find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,\n          _ForwardIter2 __first2, _ForwardIter2 __last2,\n          _BinaryPredicate __comp)\n {\n+  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);\n+  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, bool,\n+   typename iterator_traits<_ForwardIter1>::value_type,\n+   typename iterator_traits<_ForwardIter2>::value_type);\n+\n   return __find_end(__first1, __last1, __first2, __last2,\n                     __ITERATOR_CATEGORY(__first1),\n                     __ITERATOR_CATEGORY(__first2),\n@@ -2841,6 +3224,9 @@ bool __is_heap(_RandomAccessIter __first, _StrictWeakOrdering __comp,\n template <class _RandomAccessIter>\n inline bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last)\n {\n+  __STL_REQUIRES(_RandomAccessIter, _RandomAccessIterator);\n+  __STL_REQUIRES(typename iterator_traits<_RandomAccessIter>::value_type,\n+                 _LessThanComparable);\n   return __is_heap(__first, __last - __first);\n }\n \n@@ -2849,6 +3235,10 @@ template <class _RandomAccessIter, class _StrictWeakOrdering>\n inline bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last,\n                     _StrictWeakOrdering __comp)\n {\n+  __STL_REQUIRES(_RandomAccessIter, _RandomAccessIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_StrictWeakOrdering, bool, \n+         typename iterator_traits<_RandomAccessIter>::value_type, \n+         typename iterator_traits<_RandomAccessIter>::value_type);\n   return __is_heap(__first, __comp, __last - __first);\n }\n \n@@ -2859,6 +3249,9 @@ inline bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last,\n template <class _ForwardIter>\n bool is_sorted(_ForwardIter __first, _ForwardIter __last)\n {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_REQUIRES(typename iterator_traits<_ForwardIter>::value_type,\n+                 _LessThanComparable);\n   if (__first == __last)\n     return true;\n \n@@ -2875,6 +3268,10 @@ template <class _ForwardIter, class _StrictWeakOrdering>\n bool is_sorted(_ForwardIter __first, _ForwardIter __last,\n                _StrictWeakOrdering __comp)\n {\n+  __STL_REQUIRES(_ForwardIter, _ForwardIterator);\n+  __STL_BINARY_FUNCTION_CHECK(_StrictWeakOrdering, bool, \n+        typename iterator_traits<_ForwardIter>::value_type,\n+        typename iterator_traits<_ForwardIter>::value_type);\n   if (__first == __last)\n     return true;\n "}, {"sha": "71889e0853f1dbc41326e131b83e23cf48f1e903", "filename": "libstdc++-v3/bits/stl_algobase.h", "status": "modified", "additions": 107, "deletions": 3, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_algobase.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -34,9 +34,12 @@\n \n #include <bits/stl_config.h>\n #include <bits/stl_relops.h>\n+#ifndef __SGI_STL_INTERNAL_PAIR_H\n #include <bits/stl_pair.h>\n+#endif\n+#ifndef _CPP_BITS_TYPE_TRAITS_H\n #include <bits/type_traits.h>\n-\n+#endif\n #include <bits/std_cstring.h>\n #include <bits/std_climits.h>\n #include <bits/std_cstdlib.h>\n@@ -52,6 +55,8 @@\n #include <bits/stl_iterator_base.h>\n #include <bits/stl_iterator.h>\n \n+// We pick up concept_checks.h from stl_iterator_base.h.\n+\n __STL_BEGIN_NAMESPACE\n \n // swap and iter_swap\n@@ -65,11 +70,18 @@ inline void __iter_swap(_ForwardIter1 __a, _ForwardIter2 __b, _Tp*) {\n \n template <class _ForwardIter1, class _ForwardIter2>\n inline void iter_swap(_ForwardIter1 __a, _ForwardIter2 __b) {\n+  __STL_REQUIRES(_ForwardIter1, _Mutable_ForwardIterator);\n+  __STL_REQUIRES(_ForwardIter2, _Mutable_ForwardIterator);\n+  __STL_CONVERTIBLE(typename iterator_traits<_ForwardIter1>::value_type,\n+                    typename iterator_traits<_ForwardIter2>::value_type);\n+  __STL_CONVERTIBLE(typename iterator_traits<_ForwardIter2>::value_type,\n+                    typename iterator_traits<_ForwardIter1>::value_type);\n   __iter_swap(__a, __b, __VALUE_TYPE(__a));\n }\n \n template <class _Tp>\n inline void swap(_Tp& __a, _Tp& __b) {\n+  __STL_REQUIRES(_Tp, _Assignable);\n   _Tp __tmp = __a;\n   __a = __b;\n   __b = __tmp;\n@@ -78,19 +90,21 @@ inline void swap(_Tp& __a, _Tp& __b) {\n //--------------------------------------------------\n // min and max\n \n-#ifndef __BORLANDC__\n+#if !defined(__BORLANDC__) || __BORLANDC__ >= 0x540 /* C++ Builder 4.0 */\n \n #undef min\n #undef max\n \n template <class _Tp>\n inline const _Tp& min(const _Tp& __a, const _Tp& __b) {\n+  __STL_REQUIRES(_Tp, _LessThanComparable);\n   //return __b < __a ? __b : __a;\n   if (__b < __a) return __b; return __a;\n }\n \n template <class _Tp>\n inline const _Tp& max(const _Tp& __a, const _Tp& __b) {\n+  __STL_REQUIRES(_Tp, _LessThanComparable);\n   //return  __a < __b ? __b : __a;\n   if (__a < __b) return __b; return __a;\n }\n@@ -166,12 +180,16 @@ inline _OutputIter __copy_aux2(_InputIter __first, _InputIter __last,\n                 __DISTANCE_TYPE(__first));\n }\n \n+#ifndef __USLC__\n+\n template <class _Tp>\n inline _Tp* __copy_aux2(_Tp* __first, _Tp* __last, _Tp* __result,\n                         __true_type) {\n   return __copy_trivial(__first, __last, __result);\n }\n \n+#endif /* __USLC__ */\n+\n template <class _Tp>\n inline _Tp* __copy_aux2(const _Tp* __first, const _Tp* __last, _Tp* __result,\n                         __true_type) {\n@@ -217,6 +235,8 @@ inline _OutputIter __copy_ni1(_InputIter __first, _InputIter __last,\n template <class _InputIter, class _OutputIter>\n inline _OutputIter copy(_InputIter __first, _InputIter __last,\n                         _OutputIter __result) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n    typedef typename _Is_normal_iterator<_InputIter>::_Normal __Normal;\n    return __copy_ni1(__first, __last, __result, __Normal());\n }\n@@ -254,6 +274,8 @@ struct __copy_dispatch<const _Tp*, _Tp*, __true_type>\n template <class _InputIter, class _OutputIter>\n inline _OutputIter copy(_InputIter __first, _InputIter __last,\n                         _OutputIter __result) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n   typedef typename iterator_traits<_InputIter>::value_type _Tp;\n   typedef typename __type_traits<_Tp>::has_trivial_assignment_operator\n           _Trivial;\n@@ -277,7 +299,8 @@ inline _OutputIter copy(_InputIter __first, _InputIter __last,\n \n #define __SGI_STL_DECLARE_COPY_TRIVIAL(_Tp)                                \\\n   inline _Tp* copy(const _Tp* __first, const _Tp* __last, _Tp* __result) { \\\n-    return __copy_trivial(__first, __last, __result);                      \\\n+    memmove(__result, __first, sizeof(_Tp) * (__last - __first));          \\\n+    return __result + (__last - __first);                                  \\\n   }\n \n __SGI_STL_DECLARE_COPY_TRIVIAL(char)\n@@ -412,6 +435,10 @@ inline _BI2 __copy_backward_input_normal_iterator(_BI1 __first, _BI1 __last,\n \n template <typename _BI1, typename _BI2>\n inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result) {\n+  __STL_REQUIRES(_BI1, _BidirectionalIterator);\n+  __STL_REQUIRES(_BI2, _Mutable_BidirectionalIterator);\n+  __STL_CONVERTIBLE(typename iterator_traits<_BI1>::value_type,\n+                    typename iterator_traits<_BI2>::value_type);\n   typedef typename _Is_normal_iterator<_BI1>::_Normal __Normal;\n   return __copy_backward_input_normal_iterator(__first, __last, __result,\n                                                __Normal());\n@@ -462,6 +489,8 @@ __copy_n(_InputIter __first, _Size __count, _OutputIter __result) {\n template <class _InputIter, class _Size, class _OutputIter>\n inline pair<_InputIter, _OutputIter>\n copy_n(_InputIter __first, _Size __count, _OutputIter __result) {\n+  __STL_REQUIRES(_InputIter, _InputIterator);\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n   return __copy_n(__first, __count, __result);\n }\n \n@@ -471,24 +500,75 @@ copy_n(_InputIter __first, _Size __count, _OutputIter __result) {\n \n template <class _ForwardIter, class _Tp>\n void fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __value) {\n+  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);\n   for ( ; __first != __last; ++__first)\n     *__first = __value;\n }\n \n template <class _OutputIter, class _Size, class _Tp>\n _OutputIter fill_n(_OutputIter __first, _Size __n, const _Tp& __value) {\n+  __STL_REQUIRES(_OutputIter, _OutputIterator);\n   for ( ; __n > 0; --__n, ++__first)\n     *__first = __value;\n   return __first;\n }\n \n+// Specialization: for one-byte types we can use memset.\n+\n+inline void fill(unsigned char* __first, unsigned char* __last,\n+                 const unsigned char& __c) {\n+  unsigned char __tmp = __c;\n+  memset(__first, __tmp, __last - __first);\n+}\n+\n+inline void fill(signed char* __first, signed char* __last,\n+                 const signed char& __c) {\n+  signed char __tmp = __c;\n+  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);\n+}\n+\n+inline void fill(char* __first, char* __last, const char& __c) {\n+  char __tmp = __c;\n+  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);\n+}\n+\n+#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n+\n+template <class _Size>\n+inline unsigned char* fill_n(unsigned char* __first, _Size __n,\n+                             const unsigned char& __c) {\n+  fill(__first, __first + __n, __c);\n+  return __first + __n;\n+}\n+\n+template <class _Size>\n+inline signed char* fill_n(char* __first, _Size __n,\n+                           const signed char& __c) {\n+  fill(__first, __first + __n, __c);\n+  return __first + __n;\n+}\n+\n+template <class _Size>\n+inline char* fill_n(char* __first, _Size __n, const char& __c) {\n+  fill(__first, __first + __n, __c);\n+  return __first + __n;\n+}\n+\n+#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n+\n //--------------------------------------------------\n // equal and mismatch\n \n template <class _InputIter1, class _InputIter2>\n pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,\n                                         _InputIter1 __last1,\n                                         _InputIter2 __first2) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,\n+                 _EqualityComparable);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter2>::value_type,\n+                 _EqualityComparable);\n   while (__first1 != __last1 && *__first1 == *__first2) {\n     ++__first1;\n     ++__first2;\n@@ -501,6 +581,8 @@ pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,\n                                         _InputIter1 __last1,\n                                         _InputIter2 __first2,\n                                         _BinaryPredicate __binary_pred) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n   while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {\n     ++__first1;\n     ++__first2;\n@@ -511,6 +593,12 @@ pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,\n template <class _InputIter1, class _InputIter2>\n inline bool equal(_InputIter1 __first1, _InputIter1 __last1,\n                   _InputIter2 __first2) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,\n+                 _EqualityComparable);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter2>::value_type,\n+                 _EqualityComparable);\n   for ( ; __first1 != __last1; ++__first1, ++__first2)\n     if (*__first1 != *__first2)\n       return false;\n@@ -520,6 +608,8 @@ inline bool equal(_InputIter1 __first1, _InputIter1 __last1,\n template <class _InputIter1, class _InputIter2, class _BinaryPredicate>\n inline bool equal(_InputIter1 __first1, _InputIter1 __last1,\n                   _InputIter2 __first2, _BinaryPredicate __binary_pred) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n   for ( ; __first1 != __last1; ++__first1, ++__first2)\n     if (!__binary_pred(*__first1, *__first2))\n       return false;\n@@ -533,6 +623,12 @@ inline bool equal(_InputIter1 __first1, _InputIter1 __last1,\n template <class _InputIter1, class _InputIter2>\n bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,\n                              _InputIter2 __first2, _InputIter2 __last2) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,\n+                 _LessThanComparable);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter2>::value_type,\n+                 _LessThanComparable);\n   for ( ; __first1 != __last1 && __first2 != __last2\n         ; ++__first1, ++__first2) {\n     if (*__first1 < *__first2)\n@@ -547,6 +643,8 @@ template <class _InputIter1, class _InputIter2, class _Compare>\n bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,\n                              _InputIter2 __first2, _InputIter2 __last2,\n                              _Compare __comp) {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n   for ( ; __first1 != __last1 && __first2 != __last2\n         ; ++__first1, ++__first2) {\n     if (__comp(*__first1, *__first2))\n@@ -640,6 +738,12 @@ template <class _InputIter1, class _InputIter2>\n int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,\n                                  _InputIter2 __first2, _InputIter2 __last2)\n {\n+  __STL_REQUIRES(_InputIter1, _InputIterator);\n+  __STL_REQUIRES(_InputIter2, _InputIterator);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,\n+                 _LessThanComparable);\n+  __STL_REQUIRES(typename iterator_traits<_InputIter2>::value_type,\n+                 _LessThanComparable);\n   return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);\n }\n "}, {"sha": "ca22b90699f6db991984700a6471b71d6c452690", "filename": "libstdc++-v3/bits/stl_alloc.h", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_alloc.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -49,10 +49,6 @@\n #  endif\n #endif\n \n-#ifdef __STL_WIN32THREADS\n-#   include <windows.h>\n-#endif\n-\n #include <bits/std_cstddef.h>\n #include <bits/std_cstdlib.h>\n #include <bits/std_cstring.h>\n@@ -281,7 +277,8 @@ typedef malloc_alloc single_client_alloc;\n // creation of multiple default_alloc instances.\n // Node that containers built on different allocator instances have\n // different types, limiting the utility of this approach.\n-#ifdef __SUNPRO_CC\n+\n+#if defined(__SUNPRO_CC) || defined(__GNUC__)\n // breaks if we make these template class members:\n   enum {_ALIGN = 8};\n   enum {_MAX_BYTES = 128};\n@@ -294,7 +291,7 @@ class __default_alloc_template {\n private:\n   // Really we should use static const int x = N\n   // instead of enum { x = N }, but few compilers accept the former.\n-# ifndef __SUNPRO_CC\n+#if ! (defined(__SUNPRO_CC) || defined(__GNUC__))\n     enum {_ALIGN = 8};\n     enum {_MAX_BYTES = 128};\n     enum {_NFREELISTS = 16}; // _MAX_BYTES/_ALIGN\n@@ -309,7 +306,7 @@ class __default_alloc_template {\n         char _M_client_data[1];    /* The client sees this.        */\n   };\n private:\n-# ifdef __SUNPRO_CC\n+# if defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)\n     static _Obj* __STL_VOLATILE _S_free_list[]; \n         // Specifying a size results in duplicate def for 4.1\n # else\n@@ -405,6 +402,22 @@ class __default_alloc_template {\n typedef __default_alloc_template<__NODE_ALLOCATOR_THREADS, 0> alloc;\n typedef __default_alloc_template<false, 0> single_client_alloc;\n \n+template <bool __threads, int __inst>\n+inline bool operator==(const __default_alloc_template<__threads, __inst>&,\n+                       const __default_alloc_template<__threads, __inst>&)\n+{\n+  return true;\n+}\n+\n+# ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n+template <bool __threads, int __inst>\n+inline bool operator!=(const __default_alloc_template<__threads, __inst>&,\n+                       const __default_alloc_template<__threads, __inst>&)\n+{\n+  return false;\n+}\n+# endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n+\n \n \n /* We allocate memory in large chunks in order to avoid fragmenting     */\n@@ -548,9 +561,9 @@ template <bool __threads, int __inst>\n size_t __default_alloc_template<__threads, __inst>::_S_heap_size = 0;\n \n template <bool __threads, int __inst>\n-__default_alloc_template<__threads, __inst>::_Obj* __STL_VOLATILE\n+typename __default_alloc_template<__threads, __inst>::_Obj* __STL_VOLATILE\n __default_alloc_template<__threads, __inst> ::_S_free_list[\n-# ifdef __SUNPRO_CC\n+# if defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)\n     _NFREELISTS\n # else\n     __default_alloc_template<__threads, __inst>::_NFREELISTS\n@@ -742,24 +755,6 @@ inline bool operator!=(const __malloc_alloc_template<__inst>&,\n }\n #endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n-#ifndef __USE_MALLOC\n-template <bool __threads, int __inst>\n-inline bool operator==(const __default_alloc_template<__threads, __inst>&,\n-                       const __default_alloc_template<__threads, __inst>&)\n-{\n-  return true;\n-}\n-\n-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n-template <bool __threads, int __inst>\n-inline bool operator!=(const __default_alloc_template<__threads, __inst>&,\n-                       const __default_alloc_template<__threads, __inst>&)\n-{\n-  return false;\n-}\n-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-#endif\n-\n template <class _Alloc>\n inline bool operator==(const debug_alloc<_Alloc>&,\n                        const debug_alloc<_Alloc>&) {"}, {"sha": "df13a063c99a2a178a39a147007859caf7a9b064", "filename": "libstdc++-v3/bits/stl_config.h", "status": "modified", "additions": 91, "deletions": 14, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_config.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -51,6 +51,8 @@\n //   member functions of classes.\n // * __STL_MEMBER_TEMPLATE_CLASSES: defined if the compiler supports \n //   nested classes that are member templates of other classes.\n+// * __STL_TEMPLATE_FRIENDS: defined if the compiler supports templatized\n+//   friend declarations.\n // * __STL_EXPLICIT_FUNCTION_TMPL_ARGS: defined if the compiler \n //   supports calling a function template by providing its template\n //   arguments explicitly.\n@@ -86,8 +88,23 @@\n //   types.  (They're not in the C++ standard, but they are expected to be \n //   included in the forthcoming C9X standard.)\n // * __STL_THREADS is defined if thread safety is needed.\n-// * __STL_VOLATILE is deifined to be \"volatile\" if threads are being\n+// * __STL_VOLATILE is defined to be \"volatile\" if threads are being\n //   used, and the empty string otherwise.\n+// * __STL_USE_CONCEPT_CHECKS enables some extra compile-time error\n+//   checking to make sure that user-defined template arguments satisfy\n+//   all of the appropriate requirements.  This may result in more\n+//   comprehensible error messages.  It incurs no runtime overhead.  This \n+//   feature requires member templates and partial specialization.\n+// * __STL_NO_USING_CLAUSE_IN_CLASS: The compiler does not handle \"using\"\n+//   clauses inside of class definitions.\n+// * __STL_NO_FRIEND_TEMPLATE_CLASS: The compiler does not handle friend\n+//   declaractions where the friend is a template class.\n+// * __STL_NO_FUNCTION_PTR_IN_CLASS_TEMPLATE: The compiler does not\n+//   support the use of a function pointer type as the argument\n+//   for a template.\n+// * __STL_MEMBER_TEMPLATE_KEYWORD: standard C++ requires the template\n+//   keyword in a few new places (14.2.4).  This flag is set for\n+//   compilers that support (and require) this usage.\n \n \n // User-settable macros that control compilation:\n@@ -107,6 +124,8 @@\n // * _UITHREADS:if defined, use SCO/Solaris/UI threads for multithreading \n //   support\n // * _NOTHREADS: if defined, don't use any multithreading support.  \n+// * _STL_NO_CONCEPT_CHECKS: if defined, disables the error checking that\n+//   we get from __STL_USE_CONCEPT_CHECKS.\n // * __STL_USE_NEW_IOSTREAMS: if defined, then the STL will use new,\n //   standard-conforming iostreams (e.g. the <iosfwd> header).  If not\n //   defined, the STL will use old cfront-style iostreams (e.g. the\n@@ -152,6 +171,7 @@\n #   endif\n #   ifdef _MEMBER_TEMPLATES\n #     define __STL_MEMBER_TEMPLATES\n+#     define __STL_TEMPLATE_FRIENDS\n #     define __STL_MEMBER_TEMPLATE_CLASSES\n #   endif\n #   if defined(_MEMBER_TEMPLATE_KEYWORD)\n@@ -163,7 +183,7 @@\n #   if (_COMPILER_VERSION >= 730) && defined(_MIPS_SIM) && _MIPS_SIM != _ABIO32\n #     define __STL_MEMBER_TEMPLATE_KEYWORD\n #   endif\n-#   if defined(_MIPS_SIM) && _MIPS_SIM == _ABIO32\n+#   if COMPILER_VERSION < 720 || (defined(_MIPS_SIM) && _MIPS_SIM == _ABIO32)\n #     define __STL_DEFAULT_CONSTRUCTOR_BUG\n #   endif\n #   if !defined(_EXPLICIT_IS_KEYWORD)\n@@ -175,7 +195,8 @@\n #   if (_COMPILER_VERSION >= 721) && defined(_NAMESPACES)\n #     define __STL_HAS_NAMESPACES\n #   endif \n-#   if (_COMPILER_VERSION < 721)\n+#   if (_COMPILER_VERSION < 721) || \\\n+    !defined(__STL_HAS_NAMESPACES) || defined(__STL_NO_NAMESPACES)\n #     define __STL_NO_EXCEPTION_HEADER\n #   endif\n #   if _COMPILER_VERSION < 730 || !defined(_STANDARD_C_PLUS_PLUS) || \\\n@@ -236,6 +257,7 @@\n #   define __STL_HAS_WCHAR_T\n #   define __STL_MEMBER_TEMPLATES\n #   define __STL_MEMBER_TEMPLATE_CLASSES\n+#   define __STL_TEMPLATE_FRIENDS\n #   define __STL_CLASS_PARTIAL_SPECIALIZATION \n #   define __STL_PARTIAL_SPECIALIZATION_SYNTAX \n #   define __STL_FUNCTION_TMPL_PARTIAL_ORDER\n@@ -257,6 +279,9 @@\n #   ifndef __STRICT_ANSI__\n #     define __STL_LONG_LONG\n #   endif\n+#   if (__GNUC__ < 2) || (__GNUC__ == 2 && __GNUC_MINOR__ < 95)\n+#     define __STL_NO_FUNCTION_PTR_IN_CLASS_TEMPLATE\n+#   endif\n # endif\n \n # if defined(__SUNPRO_CC) \n@@ -276,6 +301,7 @@\n # if defined(__COMO__)\n #   define __STL_MEMBER_TEMPLATES\n #   define __STL_MEMBER_TEMPLATE_CLASSES\n+#   define __STL_TEMPLATE_FRIENDS\n #   define __STL_CLASS_PARTIAL_SPECIALIZATION\n #   define __STL_USE_EXCEPTIONS\n #   define __STL_HAS_NAMESPACES\n@@ -286,6 +312,7 @@\n #   define __STL_LONG_LONG \n #   define __STL_MEMBER_TEMPLATES\n #   define __STL_MEMBER_TEMPLATE_CLASSES\n+#   define __STL_TEMPLATE_FRIENDS\n #   define __STL_FUNCTION_TMPL_PARTIAL_ORDER\n #   define __STL_CLASS_PARTIAL_SPECIALIZATION\n #   define __STL_NO_DRAND48\n@@ -300,19 +327,32 @@\n #   endif\n # endif\n \n-// Mingw32, EGCS compiler using the Microsoft C runtime\n+// Mingw32, egcs compiler using the Microsoft C runtime\n # if defined(__MINGW32__)\n #   define __STL_NO_DRAND48\n+#   ifdef _MT\n+#     define __STL_WIN32THREADS\n+#   endif\n # endif\n \n+// Cygwin32, egcs compiler on MS Windows\n+# if defined(__CYGWIN__)\n+#   define __STL_NO_DRAND48\n+# endif\n+\n+\n+\n // Microsoft compiler.\n-# if defined(_MSC_VER) && !defined(__ICL)\n+# if defined(_MSC_VER) && !defined(__ICL) && !defined(__MWERKS__)\n #   define __STL_NO_DRAND48\n #   define __STL_STATIC_CONST_INIT_BUG\n #   define __STL_NEED_TYPENAME\n+#   define __STL_NO_USING_CLAUSE_IN_CLASS\n+#   define __STL_NO_FRIEND_TEMPLATE_CLASS\n #   if _MSC_VER < 1100  /* 1000 is version 4.0, 1100 is 5.0, 1200 is 6.0. */\n #     define __STL_NEED_EXPLICIT\n #     define __STL_NO_BOOL\n+#     define __STL_NO_BAD_ALLOC\n #   endif\n #   if _MSC_VER > 1000\n #     include <yvals.h>\n@@ -330,8 +370,16 @@\n #   if _MSC_VER >= 1200\n #     define __STL_PARTIAL_SPECIALIZATION_SYNTAX\n #     define __STL_HAS_NAMESPACES\n-#     define __STL_NO_NAMESPACES\n #     define __STL_CAN_THROW_RANGE_ERRORS\n+#     define NOMINMAX\n+#     undef min\n+#     undef max\n+// disable warning 'initializers put in unrecognized initialization area'\n+#     pragma warning ( disable : 4075 )\n+// disable warning 'empty controlled statement found'\n+#     pragma warning ( disable : 4390 )\n+// disable warning 'debug symbol greater than 255 chars'\n+#     pragma warning ( disable : 4786 )\n #   endif\n #   if _MSC_VER < 1100\n #     define __STL_NO_EXCEPTION_HEADER\n@@ -343,13 +391,21 @@\n # endif\n \n # if defined(__BORLANDC__)\n-#   define __STL_NO_BAD_ALLOC\n-#   define __STL_NO_DRAND48\n-#   define __STL_NEED_TYPENAME\n-#   define __STL_LIMITED_DEFAULT_TEMPLATES\n-#   define __SGI_STL_NO_ARROW_OPERATOR\n-#   define __STL_DEFAULT_CONSTRUCTOR_BUG\n-#   define __STL_NON_TYPE_TMPL_PARAM_BUG\n+#     define __STL_NO_BAD_ALLOC\n+#     define __STL_NO_DRAND48\n+#     define __STL_DEFAULT_CONSTRUCTOR_BUG\n+#   if __BORLANDC__ >= 0x540 /* C++ Builder 4.0 */\n+#     define __STL_CLASS_PARTIAL_SPECIALIZATION\n+#     define __STL_FUNCTION_TMPL_PARTIAL_ORDER\n+#     define __STL_EXPLICIT_FUNCTION_TMPL_ARGS\n+#     define __STL_MEMBER_TEMPLATES\n+#     define __STL_TEMPLATE_FRIENDS\n+#   else\n+#     define __STL_NEED_TYPENAME\n+#     define __STL_LIMITED_DEFAULT_TEMPLATES\n+#     define __SGI_STL_NO_ARROW_OPERATOR\n+#     define __STL_NON_TYPE_TMPL_PARAM_BUG\n+#   endif\n #   ifdef _CPPUNWIND\n #     define __STL_USE_EXCEPTIONS\n #   endif\n@@ -368,6 +424,12 @@\n #   define typename\n # endif\n \n+# ifdef __STL_LIMITED_DEFAULT_TEMPLATES\n+#   define __STL_DEPENDENT_DEFAULT_TMPL(_Tp)\n+# else\n+#   define __STL_DEPENDENT_DEFAULT_TMPL(_Tp) = _Tp\n+# endif\n+\n # ifdef __STL_MEMBER_TEMPLATE_KEYWORD\n #   define __STL_TEMPLATE template\n # else\n@@ -405,6 +467,14 @@\n #   define __STL_USE_STD_ALLOCATORS\n # endif\n \n+# ifndef __STL_DEFAULT_ALLOCATOR\n+#   ifdef __STL_USE_STD_ALLOCATORS\n+#     define __STL_DEFAULT_ALLOCATOR(T) allocator< T >\n+#   else\n+#     define __STL_DEFAULT_ALLOCATOR(T) alloc\n+#   endif\n+# endif\n+\n // __STL_NO_NAMESPACES is a hook so that users can disable namespaces\n // without having to edit library headers.  __STL_NO_RELOPS_NAMESPACE is\n // a hook so that users can disable the std::rel_ops namespace, keeping \n@@ -475,14 +545,21 @@\n # define __stl_assert(expr)\n #endif\n \n-#if defined(__STL_WIN32THREADS) || defined(STL_SGI_THREADS) \\\n+#if defined(__STL_WIN32THREADS) || defined(__STL_SGI_THREADS) \\\n     || defined(__STL_PTHREADS)  || defined(__STL_UITHREADS)\n #   define __STL_THREADS\n #   define __STL_VOLATILE volatile\n #else\n #   define __STL_VOLATILE\n #endif\n \n+#if defined(__STL_CLASS_PARTIAL_SPECIALIZATION) \\\n+    && defined(__STL_MEMBER_TEMPLATES) \\\n+    && !defined(_STL_NO_CONCEPT_CHECKS)\n+#  define __STL_USE_CONCEPT_CHECKS\n+#endif\n+\n+\n #endif /* __STL_CONFIG_H */\n \n // Local Variables:"}, {"sha": "7841f8dc75e73a435b13dc8337a4bcbdb16a3df4", "filename": "libstdc++-v3/bits/stl_construct.h", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_construct.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_construct.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_construct.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -36,23 +36,28 @@\n __STL_BEGIN_NAMESPACE\n \n // construct and destroy.  These functions are not part of the C++ standard,\n-// and are provided for backward compatibility with the HP STL.\n+// and are provided for backward compatibility with the HP STL. We also\n+// provide internal names _Construct and _Destroy that can be used within\n+// the library, so that standard-conforming pieces don't have to rely on\n+// non-standard extensions.\n \n-template <class _Tp>\n-inline void destroy(_Tp* __pointer) {\n-  __pointer->_Tp::~_Tp();\n-}\n+// Internal names\n \n-template <class _Tp1, class _Tp2>\n-inline void construct(_Tp1* __p, const _Tp2& __value) {\n-  new (__p) _Tp1(__value);\n+template <class _T1, class _T2>\n+inline void _Construct(_T1* __p, const _T2& __value) {\n+new ((void*) __p) _T1(__value);\n }\n-\n-template <class _Tp1>\n-inline void construct(_Tp1* __p) {\n-  new (__p) _Tp1();\n+  \n+template <class _T1>\n+inline void _Construct(_T1* __p) {\n+  new ((void*) __p) _T1();\n }\n \n+template <class _Tp>\n+inline void _Destroy(_Tp* __pointer) {\n+  __pointer->~_Tp();\n+}\n+  \n template <class _ForwardIterator>\n void\n __destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)\n@@ -74,12 +79,41 @@ __destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*)\n }\n \n template <class _ForwardIterator>\n-inline void destroy(_ForwardIterator __first, _ForwardIterator __last) {\n+inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {\n   __destroy(__first, __last, __VALUE_TYPE(__first));\n }\n \n-inline void destroy(char*, char*) {}\n-inline void destroy(wchar_t*, wchar_t*) {}\n+inline void _Destroy(char*, char*) {}\n+inline void _Destroy(int*, int*) {}\n+inline void _Destroy(long*, long*) {}\n+inline void _Destroy(float*, float*) {}\n+inline void _Destroy(double*, double*) {}\n+#ifdef __STL_HAS_WCHAR_T\n+inline void _Destroy(wchar_t*, wchar_t*) {}\n+#endif /* __STL_HAS_WCHAR_T */\n+\n+// --------------------------------------------------\n+// Old names from the HP STL.\n+\n+template <class _T1, class _T2>\n+inline void construct(_T1* __p, const _T2& __value) {\n+  _Construct(__p, __value);\n+}\n+\n+template <class _T1>\n+inline void construct(_T1* __p) {\n+  _Construct(__p);\n+}\n+\n+template <class _Tp>\n+inline void destroy(_Tp* __pointer) {\n+  _Destroy(__pointer);\n+}\n+\n+template <class _ForwardIterator>\n+inline void destroy(_ForwardIterator __first, _ForwardIterator __last) {\n+  _Destroy(__first, __last);\n+}\n \n __STL_END_NAMESPACE\n "}, {"sha": "0ad596eb3b9793c9a9211ea772fe9902597c97b2", "filename": "libstdc++-v3/bits/stl_deque.h", "status": "modified", "additions": 159, "deletions": 275, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_deque.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -28,6 +28,8 @@\n  *   You should not attempt to use it directly.\n  */\n \n+#include <bits/concept_checks.h>\n+\n #ifndef __SGI_STL_INTERNAL_DEQUE_H\n #define __SGI_STL_INTERNAL_DEQUE_H\n \n@@ -59,24 +61,10 @@\n \n \n /*\n- * In previous versions of deque, node_size was fixed by the \n- * implementation.  In this version, however, users can select\n- * the node size.  Deque has three template parameters; the third,\n- * a number of type size_t, is the number of elements per node.\n- * If the third template parameter is 0 (which is the default), \n- * then deque will use a default node size.\n- *\n- * The only reason for using an alternate node size is if your application\n- * requires a different performance tradeoff than the default.  If,\n- * for example, your program contains many deques each of which contains\n- * only a few elements, then you might want to save memory (possibly\n- * by sacrificing some speed) by using smaller nodes.\n- *\n- * Unfortunately, some compilers have trouble with non-type template \n- * parameters; stl_config.h defines __STL_NON_TYPE_TMPL_PARAM_BUG if\n- * that is the case.  If your compiler is one of them, then you will\n- * not be able to use alternate node sizes; you will have to use the\n- * default value.\n+ * In previous versions of deque, there was an extra template \n+ * parameter so users could control the node size.  This extension\n+ * turns out to violate the C++ standard (it can be detected using\n+ * template template parameters), and it has been removed.\n  */\n \n __STL_BEGIN_NAMESPACE \n@@ -88,27 +76,15 @@ __STL_BEGIN_NAMESPACE\n \n // Note: this function is simply a kludge to work around several compilers'\n //  bugs in handling constant expressions.\n-inline size_t\n-__deque_buf_size(size_t __n, size_t __size)\n-{\n-  return __n != 0 ? __n : (__size < 512 ? size_t(512 / __size) : size_t(1));\n+inline size_t __deque_buf_size(size_t __size) {\n+  return __size < 512 ? size_t(512 / __size) : size_t(1);\n }\n \n-#ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n-template <class _Tp, class _Ref, class _Ptr, size_t __bufsiz>\n-struct _Deque_iterator {\n-  typedef _Deque_iterator<_Tp,_Tp&,_Tp*,__bufsiz>             iterator;\n-  typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*,__bufsiz> const_iterator;\n-  static size_t \n-    _S_buffer_size() { return __deque_buf_size(__bufsiz, sizeof(_Tp)); }\n-#else /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n template <class _Tp, class _Ref, class _Ptr>\n struct _Deque_iterator {\n   typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;\n   typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n-  static size_t \n-    _S_buffer_size() { return __deque_buf_size(0, sizeof(_Tp)); }\n-#endif\n+  static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }\n \n   typedef random_access_iterator_tag iterator_category;\n   typedef _Tp value_type;\n@@ -219,29 +195,14 @@ struct _Deque_iterator {\n   }\n };\n \n-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n-\n-#ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n-\n-template <class _Tp, class _Ref, class _Ptr, size_t __bufsiz>\n-inline random_access_iterator_tag\n-iterator_category(const _Deque_iterator<_Tp,_Ref,_Ptr,__bufsiz>&) {\n-  return random_access_iterator_tag();\n-}\n-\n-template <class _Tp, class _Ref, class _Ptr, size_t __bufsiz>\n-inline _Tp*\n-value_type(const _Deque_iterator<_Tp,_Ref,_Ptr,__bufsiz>&) {\n-  return 0;\n-}\n-\n-template <class _Tp, class _Ref, class _Ptr, size_t __bufsiz>\n-inline ptrdiff_t*\n-distance_type(const _Deque_iterator<_Tp,_Ref,_Ptr,__bufsiz>&) {\n-  return 0;\n+template <class _Tp, class _Ref, class _Ptr>\n+inline _Deque_iterator<_Tp, _Ref, _Ptr>\n+operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)\n+{\n+  return __x + __n;\n }\n \n-#else /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n+#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n template <class _Tp, class _Ref, class _Ptr>\n inline random_access_iterator_tag\n@@ -251,17 +212,13 @@ iterator_category(const _Deque_iterator<_Tp,_Ref,_Ptr>&)\n }\n \n template <class _Tp, class _Ref, class _Ptr>\n-inline _Tp*\n-value_type(const _Deque_iterator<_Tp,_Ref,_Ptr>&) { return 0; }\n+inline _Tp* value_type(const _Deque_iterator<_Tp,_Ref,_Ptr>&) { return 0; }\n \n template <class _Tp, class _Ref, class _Ptr>\n-inline ptrdiff_t*\n-distance_type(const _Deque_iterator<_Tp,_Ref,_Ptr>&) {\n+inline ptrdiff_t* distance_type(const _Deque_iterator<_Tp,_Ref,_Ptr>&) {\n   return 0;\n }\n \n-#endif /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n-\n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n // Deque base class.  It has two purposes.  First, its constructor\n@@ -273,7 +230,7 @@ distance_type(const _Deque_iterator<_Tp,_Ref,_Ptr>&) {\n #ifdef __STL_USE_STD_ALLOCATORS\n \n // Base class for ordinary allocators.\n-template <class _Tp, class _Alloc, size_t __bufsiz, bool __is_static>\n+template <class _Tp, class _Alloc, bool __is_static>\n class _Deque_alloc_base {\n public:\n   typedef typename _Alloc_traits<_Tp,_Alloc>::allocator_type allocator_type;\n@@ -292,10 +249,10 @@ class _Deque_alloc_base {\n   _Map_allocator_type _M_map_allocator;\n \n   _Tp* _M_allocate_node() {\n-    return _M_node_allocator.allocate(__deque_buf_size(__bufsiz,sizeof(_Tp)));\n+    return _M_node_allocator.allocate(__deque_buf_size(sizeof(_Tp)));\n   }\n   void _M_deallocate_node(_Tp* __p) {\n-    _M_node_allocator.deallocate(__p, __deque_buf_size(__bufsiz,sizeof(_Tp)));\n+    _M_node_allocator.deallocate(__p, __deque_buf_size(sizeof(_Tp)));\n   }\n   _Tp** _M_allocate_map(size_t __n) \n     { return _M_map_allocator.allocate(__n); }\n@@ -307,8 +264,8 @@ class _Deque_alloc_base {\n };\n \n // Specialization for instanceless allocators.\n-template <class _Tp, class _Alloc, size_t __bufsiz>\n-class _Deque_alloc_base<_Tp, _Alloc, __bufsiz, true>\n+template <class _Tp, class _Alloc>\n+class _Deque_alloc_base<_Tp, _Alloc, true>\n {\n public:\n   typedef typename _Alloc_traits<_Tp,_Alloc>::allocator_type allocator_type;\n@@ -321,12 +278,10 @@ class _Deque_alloc_base<_Tp, _Alloc, __bufsiz, true>\n   typedef typename _Alloc_traits<_Tp*, _Alloc>::_Alloc_type _Map_alloc_type;\n \n   _Tp* _M_allocate_node() {\n-    return _Node_alloc_type::allocate(__deque_buf_size(__bufsiz,\n-                                                       sizeof(_Tp)));\n+    return _Node_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));\n   }\n   void _M_deallocate_node(_Tp* __p) {\n-    _Node_alloc_type::deallocate(__p, __deque_buf_size(__bufsiz, \n-                                                       sizeof(_Tp)));\n+    _Node_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));\n   }\n   _Tp** _M_allocate_map(size_t __n) \n     { return _Map_alloc_type::allocate(__n); }\n@@ -337,18 +292,18 @@ class _Deque_alloc_base<_Tp, _Alloc, __bufsiz, true>\n   size_t _M_map_size;\n };\n \n-template <class _Tp, class _Alloc, size_t __bufsiz>\n+template <class _Tp, class _Alloc>\n class _Deque_base\n-  : public _Deque_alloc_base<_Tp,_Alloc,__bufsiz, \n+  : public _Deque_alloc_base<_Tp,_Alloc,\n                               _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n {\n public:\n-  typedef _Deque_alloc_base<_Tp,_Alloc,__bufsiz,\n+  typedef _Deque_alloc_base<_Tp,_Alloc,\n                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n           _Base;\n   typedef typename _Base::allocator_type allocator_type;\n-  typedef _Deque_iterator<_Tp,_Tp&,_Tp*,__bufsiz>              iterator;\n-  typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*, __bufsiz> const_iterator;\n+  typedef _Deque_iterator<_Tp,_Tp&,_Tp*>             iterator;\n+  typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n \n   _Deque_base(const allocator_type& __a, size_t __num_elements)\n     : _Base(__a), _M_start(), _M_finish()\n@@ -370,16 +325,11 @@ class _Deque_base\n \n #else /* __STL_USE_STD_ALLOCATORS */\n \n-template <class _Tp, class _Alloc, size_t __bufsiz>\n+template <class _Tp, class _Alloc>\n class _Deque_base {\n public:\n-#ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n-  typedef _Deque_iterator<_Tp,_Tp&,_Tp*,__bufsiz>              iterator;\n-  typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*, __bufsiz> const_iterator;\n-#else /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n-  typedef _Deque_iterator<_Tp,_Tp&,_Tp*>                       iterator;\n-  typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*>           const_iterator;\n-#endif /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n+  typedef _Deque_iterator<_Tp,_Tp&,_Tp*>             iterator;\n+  typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n \n   typedef _Alloc allocator_type;\n   allocator_type get_allocator() const { return allocator_type(); }\n@@ -408,11 +358,9 @@ class _Deque_base {\n   typedef simple_alloc<_Tp*, _Alloc> _Map_alloc_type;\n \n   _Tp* _M_allocate_node()\n-    { return _Node_alloc_type::allocate(__deque_buf_size(__bufsiz, \n-                                                         sizeof(_Tp))); }\n+    { return _Node_alloc_type::allocate(__deque_buf_size(sizeof(_Tp))); }\n   void _M_deallocate_node(_Tp* __p)\n-    { _Node_alloc_type::deallocate(__p, __deque_buf_size(__bufsiz, \n-                                                         sizeof(_Tp))); }\n+    { _Node_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp))); }\n   _Tp** _M_allocate_map(size_t __n) \n     { return _Map_alloc_type::allocate(__n); }\n   void _M_deallocate_map(_Tp** __p, size_t __n) \n@@ -423,20 +371,20 @@ class _Deque_base {\n \n // Non-inline member functions from _Deque_base.\n \n-template <class _Tp, class _Alloc, size_t __bufsiz>\n-_Deque_base<_Tp,_Alloc,__bufsiz>::~_Deque_base() {\n+template <class _Tp, class _Alloc>\n+_Deque_base<_Tp,_Alloc>::~_Deque_base() {\n   if (_M_map) {\n     _M_destroy_nodes(_M_start._M_node, _M_finish._M_node + 1);\n     _M_deallocate_map(_M_map, _M_map_size);\n   }\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsiz>\n+template <class _Tp, class _Alloc>\n void\n-_Deque_base<_Tp,_Alloc,__bufsiz>::_M_initialize_map(size_t __num_elements)\n+_Deque_base<_Tp,_Alloc>::_M_initialize_map(size_t __num_elements)\n {\n   size_t __num_nodes = \n-    __num_elements / __deque_buf_size(__bufsiz, sizeof(_Tp)) + 1;\n+    __num_elements / __deque_buf_size(sizeof(_Tp)) + 1;\n \n   _M_map_size = max((size_t) _S_initial_map_size, __num_nodes + 2);\n   _M_map = _M_allocate_map(_M_map_size);\n@@ -453,13 +401,11 @@ _Deque_base<_Tp,_Alloc,__bufsiz>::_M_initialize_map(size_t __num_elements)\n   _M_finish._M_set_node(__nfinish - 1);\n   _M_start._M_cur = _M_start._M_first;\n   _M_finish._M_cur = _M_finish._M_first +\n-               __num_elements % __deque_buf_size(__bufsiz, sizeof(_Tp));\n+               __num_elements % __deque_buf_size(sizeof(_Tp));\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsiz>\n-void\n-_Deque_base<_Tp,_Alloc,__bufsiz>::_M_create_nodes(_Tp** __nstart,\n-                                                  _Tp** __nfinish)\n+template <class _Tp, class _Alloc>\n+void _Deque_base<_Tp,_Alloc>::_M_create_nodes(_Tp** __nstart, _Tp** __nfinish)\n {\n   _Tp** __cur;\n   __STL_TRY {\n@@ -469,22 +415,22 @@ _Deque_base<_Tp,_Alloc,__bufsiz>::_M_create_nodes(_Tp** __nstart,\n   __STL_UNWIND(_M_destroy_nodes(__nstart, __cur));\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsiz>\n-void \n-_Deque_base<_Tp,_Alloc,__bufsiz>::_M_destroy_nodes(_Tp** __nstart,\n-                                                   _Tp** __nfinish)\n+template <class _Tp, class _Alloc>\n+void\n+_Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n {\n   for (_Tp** __n = __nstart; __n < __nfinish; ++__n)\n     _M_deallocate_node(*__n);\n }\n \n-// See __deque_buf_size().  The only reason that the default value is 0\n-//  is as a workaround for bugs in the way that some compilers handle\n-//  constant expressions.\n-template <class _Tp, class _Alloc = allocator<_Tp>,\n-          size_t __bufsiz = 0> \n-class deque : protected _Deque_base<_Tp, _Alloc, __bufsiz> {\n-  typedef _Deque_base<_Tp, _Alloc, __bufsiz> _Base;\n+template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n+class deque : protected _Deque_base<_Tp, _Alloc> {\n+\n+  // requirements:\n+\n+  __STL_CLASS_REQUIRES(_Tp, _Assignable);\n+\n+  typedef _Deque_base<_Tp, _Alloc> _Base;\n public:                         // Basic types\n   typedef _Tp value_type;\n   typedef value_type* pointer;\n@@ -514,8 +460,7 @@ class deque : protected _Deque_base<_Tp, _Alloc, __bufsiz> {\n \n protected:                      // Internal typedefs\n   typedef pointer* _Map_pointer;\n-  static size_t _S_buffer_size()\n-    { return __deque_buf_size(__bufsiz, sizeof(_Tp)); }\n+  static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }\n \n protected:\n #ifdef __STL_USE_NAMESPACES\n@@ -951,37 +896,15 @@ class deque : protected _Deque_base<_Tp, _Alloc, __bufsiz> {\n   }\n \n   void _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);\n- \n-#ifdef __STL_NON_TYPE_TMPL_PARAM_BUG\n-public:\n-  bool operator==(const deque<_Tp,_Alloc,0>& __x) const {\n-    return size() == __x.size() && equal(begin(), end(), __x.begin());\n-  }\n-  bool operator!=(const deque<_Tp,_Alloc,0>& __x) const {\n-    return size() != __x.size() || !equal(begin(), end(), __x.begin());\n-  }\n-  bool operator<(const deque<_Tp,_Alloc,0>& __x) const {\n-    return lexicographical_compare(begin(), end(), __x.begin(), __x.end());\n-  }\n-  bool operator>(const deque<_Tp,_Alloc,0>& __x) const {\n-    return __x < *this;\n-  }\n-  bool operator<=(const deque<_Tp,_Alloc,0>& __x) const {\n-    return !(__x < *this);\n-  }\n-  bool operator>=(const deque<_Tp,_Alloc,0>& __x) const {\n-    return !(*this < __x);\n-  }\n-#endif /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n };\n \n // Non-inline member functions\n \n #ifdef __STL_MEMBER_TEMPLATES\n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n+template <class _Tp, class _Alloc>\n template <class _InputIter>\n-void deque<_Tp, _Alloc, __bufsize>\n+void deque<_Tp, _Alloc>\n   ::_M_assign_aux(_InputIter __first, _InputIter __last, input_iterator_tag)\n {\n   iterator __cur = begin();\n@@ -995,11 +918,9 @@ void deque<_Tp, _Alloc, __bufsize>\n \n #endif /* __STL_MEMBER_TEMPLATES */\n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void \n-deque<_Tp, _Alloc, __bufsize>::_M_fill_insert(iterator __pos,\n-                                              size_type __n,\n-                                              const value_type& __x)\n+template <class _Tp, class _Alloc>\n+void deque<_Tp, _Alloc>::_M_fill_insert(iterator __pos,\n+                                        size_type __n, const value_type& __x)\n {\n   if (__pos._M_cur == _M_start._M_cur) {\n     iterator __new_start = _M_reserve_elements_at_front(__n);\n@@ -1024,10 +945,10 @@ deque<_Tp, _Alloc, __bufsize>::_M_fill_insert(iterator __pos,\n \n #ifndef __STL_MEMBER_TEMPLATES  \n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void deque<_Tp, _Alloc, __bufsize>::insert(iterator __pos,\n-                                           const value_type* __first,\n-                                           const value_type* __last) {\n+template <class _Tp, class _Alloc>\n+void deque<_Tp, _Alloc>::insert(iterator __pos,\n+                                const value_type* __first,\n+                                const value_type* __last) {\n   size_type __n = __last - __first;\n   if (__pos._M_cur == _M_start._M_cur) {\n     iterator __new_start = _M_reserve_elements_at_front(__n);\n@@ -1050,10 +971,9 @@ void deque<_Tp, _Alloc, __bufsize>::insert(iterator __pos,\n     _M_insert_aux(__pos, __first, __last, __n);\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void deque<_Tp,_Alloc,__bufsize>::insert(iterator __pos,\n-                                         const_iterator __first,\n-                                         const_iterator __last)\n+template <class _Tp, class _Alloc>\n+void deque<_Tp,_Alloc>::insert(iterator __pos,\n+                               const_iterator __first, const_iterator __last)\n {\n   size_type __n = __last - __first;\n   if (__pos._M_cur == _M_start._M_cur) {\n@@ -1079,9 +999,9 @@ void deque<_Tp,_Alloc,__bufsize>::insert(iterator __pos,\n \n #endif /* __STL_MEMBER_TEMPLATES */\n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-deque<_Tp,_Alloc,__bufsize>::iterator \n-deque<_Tp,_Alloc,__bufsize>::erase(iterator __first, iterator __last)\n+template <class _Tp, class _Alloc>\n+typename deque<_Tp,_Alloc>::iterator \n+deque<_Tp,_Alloc>::erase(iterator __first, iterator __last)\n {\n   if (__first == _M_start && __last == _M_finish) {\n     clear();\n@@ -1108,8 +1028,8 @@ deque<_Tp,_Alloc,__bufsize>::erase(iterator __first, iterator __last)\n   }\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void deque<_Tp,_Alloc,__bufsize>::clear()\n+template <class _Tp, class _Alloc> \n+void deque<_Tp,_Alloc>::clear()\n {\n   for (_Map_pointer __node = _M_start._M_node + 1;\n        __node < _M_finish._M_node;\n@@ -1131,9 +1051,8 @@ void deque<_Tp,_Alloc,__bufsize>::clear()\n \n // Precondition: _M_start and _M_finish have already been initialized,\n // but none of the deque's elements have yet been constructed.\n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void \n-deque<_Tp,_Alloc,__bufsize>::_M_fill_initialize(const value_type& __value) {\n+template <class _Tp, class _Alloc>\n+void deque<_Tp,_Alloc>::_M_fill_initialize(const value_type& __value) {\n   _Map_pointer __cur;\n   __STL_TRY {\n     for (__cur = _M_start._M_node; __cur < _M_finish._M_node; ++__cur)\n@@ -1145,12 +1064,10 @@ deque<_Tp,_Alloc,__bufsize>::_M_fill_initialize(const value_type& __value) {\n \n #ifdef __STL_MEMBER_TEMPLATES  \n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-template <class _InputIterator>\n-void\n-deque<_Tp,_Alloc,__bufsize>::_M_range_initialize(_InputIterator __first,\n-                                                 _InputIterator __last,\n-                                                 input_iterator_tag)\n+template <class _Tp, class _Alloc> template <class _InputIterator>\n+void deque<_Tp,_Alloc>::_M_range_initialize(_InputIterator __first,\n+                                            _InputIterator __last,\n+                                            input_iterator_tag)\n {\n   _M_initialize_map(0);\n   __STL_TRY {\n@@ -1160,12 +1077,10 @@ deque<_Tp,_Alloc,__bufsize>::_M_range_initialize(_InputIterator __first,\n   __STL_UNWIND(clear());\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-template <class _ForwardIterator>\n-void\n-deque<_Tp,_Alloc,__bufsize>::_M_range_initialize(_ForwardIterator __first,\n-                                                 _ForwardIterator __last,\n-                                                 forward_iterator_tag)\n+template <class _Tp, class _Alloc> template <class _ForwardIterator>\n+void deque<_Tp,_Alloc>::_M_range_initialize(_ForwardIterator __first,\n+                                            _ForwardIterator __last,\n+                                            forward_iterator_tag)\n {\n   size_type __n = 0;\n   distance(__first, __last, __n);\n@@ -1175,7 +1090,7 @@ deque<_Tp,_Alloc,__bufsize>::_M_range_initialize(_ForwardIterator __first,\n   __STL_TRY {\n     for (__cur_node = _M_start._M_node; \n          __cur_node < _M_finish._M_node; \n-\t ++__cur_node) {\n+         ++__cur_node) {\n       _ForwardIterator __mid = __first;\n       advance(__mid, _S_buffer_size());\n       uninitialized_copy(__first, __mid, *__cur_node);\n@@ -1189,9 +1104,8 @@ deque<_Tp,_Alloc,__bufsize>::_M_range_initialize(_ForwardIterator __first,\n #endif /* __STL_MEMBER_TEMPLATES */\n \n // Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void\n-deque<_Tp,_Alloc,__bufsize>::_M_push_back_aux(const value_type& __t)\n+template <class _Tp, class _Alloc>\n+void deque<_Tp,_Alloc>::_M_push_back_aux(const value_type& __t)\n {\n   value_type __t_copy = __t;\n   _M_reserve_map_at_back();\n@@ -1205,9 +1119,8 @@ deque<_Tp,_Alloc,__bufsize>::_M_push_back_aux(const value_type& __t)\n }\n \n // Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void\n-deque<_Tp,_Alloc,__bufsize>::_M_push_back_aux()\n+template <class _Tp, class _Alloc>\n+void deque<_Tp,_Alloc>::_M_push_back_aux()\n {\n   _M_reserve_map_at_back();\n   *(_M_finish._M_node + 1) = _M_allocate_node();\n@@ -1220,9 +1133,8 @@ deque<_Tp,_Alloc,__bufsize>::_M_push_back_aux()\n }\n \n // Called only if _M_start._M_cur == _M_start._M_first.\n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void \n-deque<_Tp,_Alloc,__bufsize>::_M_push_front_aux(const value_type& __t)\n+template <class _Tp, class _Alloc>\n+void  deque<_Tp,_Alloc>::_M_push_front_aux(const value_type& __t)\n {\n   value_type __t_copy = __t;\n   _M_reserve_map_at_front();\n@@ -1236,9 +1148,8 @@ deque<_Tp,_Alloc,__bufsize>::_M_push_front_aux(const value_type& __t)\n } \n \n // Called only if _M_start._M_cur == _M_start._M_first.\n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void \n-deque<_Tp,_Alloc,__bufsize>::_M_push_front_aux()\n+template <class _Tp, class _Alloc>\n+void deque<_Tp,_Alloc>::_M_push_front_aux()\n {\n   _M_reserve_map_at_front();\n   *(_M_start._M_node - 1) = _M_allocate_node();\n@@ -1251,9 +1162,8 @@ deque<_Tp,_Alloc,__bufsize>::_M_push_front_aux()\n } \n \n // Called only if _M_finish._M_cur == _M_finish._M_first.\n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void \n-deque<_Tp,_Alloc,__bufsize>::_M_pop_back_aux()\n+template <class _Tp, class _Alloc>\n+void deque<_Tp,_Alloc>::_M_pop_back_aux()\n {\n   _M_deallocate_node(_M_finish._M_first);\n   _M_finish._M_set_node(_M_finish._M_node - 1);\n@@ -1265,9 +1175,8 @@ deque<_Tp,_Alloc,__bufsize>::_M_pop_back_aux()\n // if the deque has at least one element (a precondition for this member \n // function), and if _M_start._M_cur == _M_start._M_last, then the deque \n // must have at least two nodes.\n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void \n-deque<_Tp,_Alloc,__bufsize>::_M_pop_front_aux()\n+template <class _Tp, class _Alloc>\n+void deque<_Tp,_Alloc>::_M_pop_front_aux()\n {\n   destroy(_M_start._M_cur);\n   _M_deallocate_node(_M_start._M_first);\n@@ -1277,24 +1186,19 @@ deque<_Tp,_Alloc,__bufsize>::_M_pop_front_aux()\n \n #ifdef __STL_MEMBER_TEMPLATES  \n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-template <class _InputIterator>\n-void \n-deque<_Tp,_Alloc,__bufsize>::insert(iterator __pos,\n-                                    _InputIterator __first,\n-                                    _InputIterator __last,\n-                                    input_iterator_tag)\n+template <class _Tp, class _Alloc> template <class _InputIterator>\n+void deque<_Tp,_Alloc>::insert(iterator __pos,\n+                               _InputIterator __first, _InputIterator __last,\n+                               input_iterator_tag)\n {\n   copy(__first, __last, inserter(*this, __pos));\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-template <class _ForwardIterator>\n-void \n-deque<_Tp,_Alloc,__bufsize>::insert(iterator __pos,\n-                                    _ForwardIterator __first,\n-                                    _ForwardIterator __last,\n-                                    forward_iterator_tag) {\n+template <class _Tp, class _Alloc> template <class _ForwardIterator>\n+void\n+deque<_Tp,_Alloc>::insert(iterator __pos,\n+                          _ForwardIterator __first, _ForwardIterator __last,\n+                          forward_iterator_tag) {\n   size_type __n = 0;\n   distance(__first, __last, __n);\n   if (__pos._M_cur == _M_start._M_cur) {\n@@ -1320,10 +1224,9 @@ deque<_Tp,_Alloc,__bufsize>::insert(iterator __pos,\n \n #endif /* __STL_MEMBER_TEMPLATES */\n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-typename deque<_Tp, _Alloc, __bufsize>::iterator\n-deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n-                                           const value_type& __x)\n+template <class _Tp, class _Alloc>\n+typename deque<_Tp, _Alloc>::iterator\n+deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos, const value_type& __x)\n {\n   difference_type __index = __pos - _M_start;\n   value_type __x_copy = __x;\n@@ -1351,9 +1254,9 @@ deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n   return __pos;\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-typename deque<_Tp,_Alloc,__bufsize>::iterator\n-deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos)\n+template <class _Tp, class _Alloc>\n+typename deque<_Tp,_Alloc>::iterator \n+deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos)\n {\n   difference_type __index = __pos - _M_start;\n   if (static_cast<size_type>(__index) < size() / 2) {\n@@ -1380,16 +1283,15 @@ deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos)\n   return __pos;\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void\n-deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n-                                           size_type __n,\n-                                           const value_type& __x)\n+template <class _Tp, class _Alloc>\n+void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n+                                      size_type __n,\n+                                      const value_type& __x)\n {\n   const difference_type __elems_before = __pos - _M_start;\n-  size_type __length = size();\n+  size_type __length = this->size();\n   value_type __x_copy = __x;\n-  if (static_cast<size_type>(__elems_before) < __length / 2) {\n+  if (__elems_before < difference_type(__length / 2)) {\n     iterator __new_start = _M_reserve_elements_at_front(__n);\n     iterator __old_start = _M_start;\n     __pos = _M_start + __elems_before;\n@@ -1403,7 +1305,7 @@ deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n       }\n       else {\n         __uninitialized_copy_fill(_M_start, __pos, __new_start, \n-\t                          _M_start, __x_copy);\n+                                  _M_start, __x_copy);\n         _M_start = __new_start;\n         fill(__old_start, __pos, __x_copy);\n       }\n@@ -1438,13 +1340,11 @@ deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n \n #ifdef __STL_MEMBER_TEMPLATES  \n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-template <class _ForwardIterator>\n-void\n-deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n-                                           _ForwardIterator __first,\n-                                           _ForwardIterator __last,\n-                                           size_type __n)\n+template <class _Tp, class _Alloc> template <class _ForwardIterator>\n+void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n+                                      _ForwardIterator __first,\n+                                      _ForwardIterator __last,\n+                                      size_type __n)\n {\n   const difference_type __elemsbefore = __pos - _M_start;\n   size_type __length = size();\n@@ -1500,12 +1400,11 @@ deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n \n #else /* __STL_MEMBER_TEMPLATES */\n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void \n-deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n-                                           const value_type* __first,\n-                                           const value_type* __last,\n-                                           size_type __n)\n+template <class _Tp, class _Alloc>\n+void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n+                                      const value_type* __first,\n+                                      const value_type* __last,\n+                                      size_type __n)\n {\n   const difference_type __elemsbefore = __pos - _M_start;\n   size_type __length = size();\n@@ -1523,7 +1422,7 @@ deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n       }\n       else {\n         const value_type* __mid = \n-\t  __first + (difference_type(__n) - __elemsbefore);\n+          __first + (difference_type(__n) - __elemsbefore);\n         __uninitialized_copy_copy(_M_start, __pos, __first, __mid,\n                                   __new_start);\n         _M_start = __new_start;\n@@ -1558,12 +1457,11 @@ deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n   }\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void\n-deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n-                                           const_iterator __first,\n-                                           const_iterator __last,\n-                                           size_type __n)\n+template <class _Tp, class _Alloc>\n+void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n+                                      const_iterator __first,\n+                                      const_iterator __last,\n+                                      size_type __n)\n {\n   const difference_type __elemsbefore = __pos - _M_start;\n   size_type __length = size();\n@@ -1616,9 +1514,8 @@ deque<_Tp,_Alloc,__bufsize>::_M_insert_aux(iterator __pos,\n \n #endif /* __STL_MEMBER_TEMPLATES */\n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void \n-deque<_Tp,_Alloc,__bufsize>::_M_new_elements_at_front(size_type __new_elems)\n+template <class _Tp, class _Alloc>\n+void deque<_Tp,_Alloc>::_M_new_elements_at_front(size_type __new_elems)\n {\n   size_type __new_nodes\n       = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n@@ -1637,9 +1534,8 @@ deque<_Tp,_Alloc,__bufsize>::_M_new_elements_at_front(size_type __new_elems)\n #       endif /* __STL_USE_EXCEPTIONS */\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void \n-deque<_Tp,_Alloc,__bufsize>::_M_new_elements_at_back(size_type __new_elems)\n+template <class _Tp, class _Alloc>\n+void deque<_Tp,_Alloc>::_M_new_elements_at_back(size_type __new_elems)\n {\n   size_type __new_nodes\n       = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n@@ -1658,10 +1554,9 @@ deque<_Tp,_Alloc,__bufsize>::_M_new_elements_at_back(size_type __new_elems)\n #       endif /* __STL_USE_EXCEPTIONS */\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsize>\n-void \n-deque<_Tp,_Alloc,__bufsize>::_M_reallocate_map(size_type __nodes_to_add,\n-                                              bool __add_at_front)\n+template <class _Tp, class _Alloc>\n+void deque<_Tp,_Alloc>::_M_reallocate_map(size_type __nodes_to_add,\n+                                          bool __add_at_front)\n {\n   size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + 1;\n   size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;\n@@ -1697,62 +1592,51 @@ deque<_Tp,_Alloc,__bufsize>::_M_reallocate_map(size_type __nodes_to_add,\n \n // Nonmember functions.\n \n-#ifndef __STL_NON_TYPE_TMPL_PARAM_BUG\n-\n-template <class _Tp, class _Alloc, size_t __bufsiz>\n-inline bool operator==(const deque<_Tp, _Alloc, __bufsiz>& __x,\n-                       const deque<_Tp, _Alloc, __bufsiz>& __y)\n-{\n+template <class _Tp, class _Alloc>\n+inline bool operator==(const deque<_Tp, _Alloc>& __x,\n+                       const deque<_Tp, _Alloc>& __y) {\n   return __x.size() == __y.size() &&\n          equal(__x.begin(), __x.end(), __y.begin());\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsiz>\n-inline bool operator<(const deque<_Tp, _Alloc, __bufsiz>& __x,\n-                      const deque<_Tp, _Alloc, __bufsiz>& __y)\n-{\n+template <class _Tp, class _Alloc>\n+inline bool operator<(const deque<_Tp, _Alloc>& __x,\n+                      const deque<_Tp, _Alloc>& __y) {\n   return lexicographical_compare(__x.begin(), __x.end(), \n                                  __y.begin(), __y.end());\n }\n \n #ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n \n-template <class _Tp, class _Alloc, size_t __bufsiz>\n-inline bool operator!=(const deque<_Tp, _Alloc, __bufsiz>& __x,\n-                       const deque<_Tp, _Alloc, __bufsiz>& __y)\n-{\n+template <class _Tp, class _Alloc>\n+inline bool operator!=(const deque<_Tp, _Alloc>& __x,\n+                       const deque<_Tp, _Alloc>& __y) {\n   return !(__x == __y);\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsiz>\n-inline bool operator>(const deque<_Tp, _Alloc, __bufsiz>& __x,\n-                      const deque<_Tp, _Alloc, __bufsiz>& __y)\n-{\n+template <class _Tp, class _Alloc>\n+inline bool operator>(const deque<_Tp, _Alloc>& __x,\n+                      const deque<_Tp, _Alloc>& __y) {\n   return __y < __x;\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsiz>\n-inline bool operator<=(const deque<_Tp, _Alloc, __bufsiz>& __x,\n-                       const deque<_Tp, _Alloc, __bufsiz>& __y)\n-{\n+template <class _Tp, class _Alloc>\n+inline bool operator<=(const deque<_Tp, _Alloc>& __x,\n+                       const deque<_Tp, _Alloc>& __y) {\n   return !(__y < __x);\n }\n-template <class _Tp, class _Alloc, size_t __bufsiz>\n-inline bool operator>=(const deque<_Tp, _Alloc, __bufsiz>& __x,\n-                       const deque<_Tp, _Alloc, __bufsiz>& __y)\n-{\n+template <class _Tp, class _Alloc>\n+inline bool operator>=(const deque<_Tp, _Alloc>& __x,\n+                       const deque<_Tp, _Alloc>& __y) {\n   return !(__x < __y);\n }\n \n-template <class _Tp, class _Alloc, size_t __bufsiz>\n-inline void \n-swap(deque<_Tp,_Alloc,__bufsiz>& __x, deque<_Tp,_Alloc,__bufsiz>& __y)\n-{\n+template <class _Tp, class _Alloc>\n+inline void swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y) {\n   __x.swap(__y);\n }\n \n #endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n-#endif /* __STL_NON_TYPE_TMPL_PARAM_BUG */\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma reset woff 1174"}, {"sha": "fcaafac56685df4b43e43d7f1e1e7c0621248472", "filename": "libstdc++-v3/bits/stl_function.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_function.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -411,7 +411,7 @@ struct _Constant_binary_fun {\n \n template <class _Result>\n struct constant_void_fun : public _Constant_void_fun<_Result> {\n-  constant_void_fun(const _Result& __v) : _Constant_void_fun<_Result>(_v) {}\n+  constant_void_fun(const _Result& __v) : _Constant_void_fun<_Result>(__v) {}\n };  \n \n "}, {"sha": "3e7eaa456e517443bfd8daf98634fdb4835f3e95", "filename": "libstdc++-v3/bits/stl_heap.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_heap.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -65,6 +65,9 @@ template <class _RandomAccessIterator>\n inline void \n push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n {\n+  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);\n+  __STL_REQUIRES(typename iterator_traits<_RandomAccessIterator>::value_type,\n+                 _LessThanComparable);\n   __push_heap_aux(__first, __last,\n                   __DISTANCE_TYPE(__first), __VALUE_TYPE(__first));\n }\n@@ -100,6 +103,7 @@ inline void\n push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Compare __comp)\n {\n+  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);\n   __push_heap_aux(__first, __last, __comp,\n                   __DISTANCE_TYPE(__first), __VALUE_TYPE(__first));\n }\n@@ -147,6 +151,9 @@ template <class _RandomAccessIterator>\n inline void pop_heap(_RandomAccessIterator __first, \n                      _RandomAccessIterator __last)\n {\n+  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);\n+  __STL_REQUIRES(typename iterator_traits<_RandomAccessIterator>::value_type,\n+                 _LessThanComparable);\n   __pop_heap_aux(__first, __last, __VALUE_TYPE(__first));\n }\n \n@@ -198,7 +205,8 @@ inline void\n pop_heap(_RandomAccessIterator __first,\n          _RandomAccessIterator __last, _Compare __comp)\n {\n-    __pop_heap_aux(__first, __last, __VALUE_TYPE(__first), __comp);\n+  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);\n+  __pop_heap_aux(__first, __last, __VALUE_TYPE(__first), __comp);\n }\n \n template <class _RandomAccessIterator, class _Tp, class _Distance>\n@@ -221,6 +229,9 @@ template <class _RandomAccessIterator>\n inline void \n make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n {\n+  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);\n+  __STL_REQUIRES(typename iterator_traits<_RandomAccessIterator>::value_type,\n+                 _LessThanComparable);\n   __make_heap(__first, __last,\n               __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));\n }\n@@ -248,13 +259,17 @@ inline void\n make_heap(_RandomAccessIterator __first, \n           _RandomAccessIterator __last, _Compare __comp)\n {\n+  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);\n   __make_heap(__first, __last, __comp,\n               __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));\n }\n \n template <class _RandomAccessIterator>\n void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n {\n+  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);\n+  __STL_REQUIRES(typename iterator_traits<_RandomAccessIterator>::value_type,\n+                 _LessThanComparable);\n   while (__last - __first > 1)\n     pop_heap(__first, __last--);\n }\n@@ -264,6 +279,7 @@ void\n sort_heap(_RandomAccessIterator __first,\n           _RandomAccessIterator __last, _Compare __comp)\n {\n+  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);\n   while (__last - __first > 1)\n     pop_heap(__first, __last--, __comp);\n }"}, {"sha": "ae8b088665373da527df2a15d4b2e5fab2a6b39c", "filename": "libstdc++-v3/bits/stl_iterator.h", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_iterator.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -513,7 +513,7 @@ operator!=(const reverse_iterator<_RandomAccessIterator, _Tp,\n                                   _Reference, _Distance>& __x, \n            const reverse_iterator<_RandomAccessIterator, _Tp,\n                                   _Reference, _Distance>& __y) {\n-  return !(__x == __y); }\n+  return !(__x == __y);\n }\n \n template <class _RandomAccessIterator, class _Tp,\n@@ -679,6 +679,8 @@ class ostream_iterator {\n // operator* or operator++ has been called, _M_is_initialized is false.\n template<class _CharT, class _Traits>\n class istreambuf_iterator\n+  : public iterator<input_iterator_tag, _CharT,\n+                    typename _Traits::off_type, _CharT*, _CharT&>\n {\n public:\n   typedef _CharT                           char_type;\n@@ -687,12 +689,6 @@ class istreambuf_iterator\n   typedef basic_streambuf<_CharT, _Traits> streambuf_type;\n   typedef basic_istream<_CharT, _Traits>   istream_type;\n \n-  typedef input_iterator_tag               iterator_category;\n-  typedef _CharT                           value_type;\n-  typedef typename _Traits::off_type       difference_type;\n-  typedef const _CharT*                    pointer;\n-  typedef const _CharT&                    reference;\n-\n public:\n   istreambuf_iterator(streambuf_type* __p = 0) { this->_M_init(__p); }\n   istreambuf_iterator(istream_type& __is) { this->_M_init(__is.rdbuf()); }\n@@ -791,6 +787,7 @@ inline bool operator!=(const istreambuf_iterator<_CharT, _Traits>& __x,\n // The default template argument is declared in iosfwd\n template<class _CharT, class _Traits>\n class ostreambuf_iterator\n+  : public iterator<output_iterator_tag, void, void, void, void>\n {\n public:\n   typedef _CharT                           char_type;\n@@ -799,16 +796,10 @@ class ostreambuf_iterator\n   typedef basic_streambuf<_CharT, _Traits> streambuf_type;\n   typedef basic_ostream<_CharT, _Traits>   ostream_type;\n \n-  typedef output_iterator_tag              iterator_category;\n-  typedef void                             value_type;\n-  typedef void                             difference_type;\n-  typedef void                             pointer;\n-  typedef void                             reference;\n-\n public:\n   ostreambuf_iterator(streambuf_type* __buf) : _M_buf(__buf), _M_ok(__buf) {}\n   ostreambuf_iterator(ostream_type& __o)\n-    : _M_buf(__o.rdbuf()), _M_ok(__o.rdbuf()) {}\n+    : _M_buf(__o.rdbuf()), _M_ok(__o.rdbuf() != 0) {}\n \n   ostreambuf_iterator& operator=(char_type __c) {\n     _M_ok = _M_ok && !traits_type::eq_int_type(_M_buf->sputc(__c),\n@@ -837,15 +828,15 @@ inline bool operator==(const istream_iterator<_Tp, _Dist>&,\n \n template <class _Tp, class _Dist>\n class istream_iterator {\n-#ifdef __STL_MEMBER_TEMPLATES\n+#ifdef __STL_TEMPLATE_FRIENDS\n   template <class _T1, class _D1>\n   friend bool operator==(const istream_iterator<_T1, _D1>&,\n                          const istream_iterator<_T1, _D1>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n+#else /* __STL_TEMPLATE_FRIENDS */\n   friend bool __STD_QUALIFIER\n   operator== __STL_NULL_TMPL_ARGS (const istream_iterator&,\n                                    const istream_iterator&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n+#endif /* __STL_TEMPLATE_FRIENDS */\n \n protected:\n   istream* _M_stream;"}, {"sha": "44a6f8fbfb079891a6e8bf76c0aa7455c7556c57", "filename": "libstdc++-v3/bits/stl_iterator_base.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_iterator_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_iterator_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_iterator_base.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -35,6 +35,8 @@\n // The internal file stl_iterator.h contains predefined iterators, \n // such as front_insert_iterator and istream_iterator.\n \n+#include <bits/concept_checks.h>\n+\n __STL_BEGIN_NAMESPACE\n \n struct input_iterator_tag {};\n@@ -274,13 +276,15 @@ inline void __distance(_RandomAccessIterator __first,\n                        _RandomAccessIterator __last, \n                        _Distance& __n, random_access_iterator_tag)\n {\n+  __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);\n   __n += __last - __first;\n }\n \n template <class _InputIterator, class _Distance>\n inline void distance(_InputIterator __first, \n                      _InputIterator __last, _Distance& __n)\n {\n+  __STL_REQUIRES(_InputIterator, _InputIterator);\n   __distance(__first, __last, __n, iterator_category(__first));\n }\n \n@@ -301,6 +305,7 @@ template <class _RandomAccessIterator>\n inline typename iterator_traits<_RandomAccessIterator>::difference_type\n __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,\n            random_access_iterator_tag) {\n+  __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);\n   return __last - __first;\n }\n \n@@ -309,6 +314,7 @@ inline typename iterator_traits<_InputIterator>::difference_type\n distance(_InputIterator __first, _InputIterator __last) {\n   typedef typename iterator_traits<_InputIterator>::iterator_category \n     _Category;\n+  __STL_REQUIRES(_InputIterator, _InputIterator);\n   return __distance(__first, __last, _Category());\n }\n \n@@ -326,6 +332,7 @@ inline void __advance(_InputIter& __i, _Distance __n, input_iterator_tag) {\n template <class _BidirectionalIterator, class _Distance>\n inline void __advance(_BidirectionalIterator& __i, _Distance __n, \n                       bidirectional_iterator_tag) {\n+  __STL_REQUIRES(_BidirectionalIterator, _BidirectionalIterator);\n   if (__n >= 0)\n     while (__n--) ++__i;\n   else\n@@ -339,11 +346,13 @@ inline void __advance(_BidirectionalIterator& __i, _Distance __n,\n template <class _RandomAccessIterator, class _Distance>\n inline void __advance(_RandomAccessIterator& __i, _Distance __n, \n                       random_access_iterator_tag) {\n+  __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);\n   __i += __n;\n }\n \n template <class _InputIterator, class _Distance>\n inline void advance(_InputIterator& __i, _Distance __n) {\n+  __STL_REQUIRES(_InputIterator, _InputIterator);\n   __advance(__i, __n, iterator_category(__i));\n }\n "}, {"sha": "1967a7a933d4685afe1ed982e550f28bd0bfb175", "filename": "libstdc++-v3/bits/stl_list.h", "status": "modified", "additions": 79, "deletions": 61, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_list.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -31,74 +31,91 @@\n #ifndef __SGI_STL_INTERNAL_LIST_H\n #define __SGI_STL_INTERNAL_LIST_H\n \n+#include <bits/concept_checks.h>\n+\n __STL_BEGIN_NAMESPACE\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma set woff 1174\n #pragma set woff 1375\n #endif\n \n+struct _List_node_base {\n+  _List_node_base* _M_next;\n+  _List_node_base* _M_prev;\n+};\n+\n template <class _Tp>\n-struct _List_node {\n-  typedef void* _Void_pointer;\n-  _Void_pointer _M_next;\n-  _Void_pointer _M_prev;\n+struct _List_node : public _List_node_base {\n   _Tp _M_data;\n };\n \n+struct _List_iterator_base {\n+  typedef size_t                     size_type;\n+  typedef ptrdiff_t                  difference_type;\n+  typedef bidirectional_iterator_tag iterator_category;\n+\n+  _List_node_base* _M_node;\n+\n+  _List_iterator_base(_List_node_base* __x) : _M_node(__x) {}\n+  _List_iterator_base() {}\n+\n+  void _M_incr() { _M_node = _M_node->_M_next; }\n+  void _M_decr() { _M_node = _M_node->_M_prev; }\n+\n+  bool operator==(const _List_iterator_base& __x) const {\n+    return _M_node == __x._M_node;\n+  }\n+  bool operator!=(const _List_iterator_base& __x) const {\n+    return _M_node != __x._M_node;\n+  }\n+};  \n+\n template<class _Tp, class _Ref, class _Ptr>\n-struct _List_iterator {\n+struct _List_iterator : public _List_iterator_base {\n   typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n   typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n   typedef _List_iterator<_Tp,_Ref,_Ptr>             _Self;\n \n-  typedef bidirectional_iterator_tag iterator_category;\n   typedef _Tp value_type;\n   typedef _Ptr pointer;\n   typedef _Ref reference;\n   typedef _List_node<_Tp> _Node;\n-  typedef size_t size_type;\n-  typedef ptrdiff_t difference_type;\n-\n-  _Node* _M_node;\n \n-  _List_iterator(_Node* __x) : _M_node(__x) {}\n+  _List_iterator(_Node* __x) : _List_iterator_base(__x) {}\n   _List_iterator() {}\n-  _List_iterator(const iterator& __x) : _M_node(__x._M_node) {}\n+  _List_iterator(const iterator& __x) : _List_iterator_base(__x._M_node) {}\n \n-  bool operator==(const _Self& __x) const { return _M_node == __x._M_node; }\n-  bool operator!=(const _Self& __x) const { return _M_node != __x._M_node; }\n-  reference operator*() const { return (*_M_node)._M_data; }\n+  reference operator*() const { return ((_Node*) _M_node)->_M_data; }\n \n #ifndef __SGI_STL_NO_ARROW_OPERATOR\n   pointer operator->() const { return &(operator*()); }\n #endif /* __SGI_STL_NO_ARROW_OPERATOR */\n \n   _Self& operator++() { \n-    _M_node = (_Node*)(_M_node->_M_next);\n+    this->_M_incr();\n     return *this;\n   }\n   _Self operator++(int) { \n     _Self __tmp = *this;\n-    ++*this;\n+    this->_M_incr();\n     return __tmp;\n   }\n   _Self& operator--() { \n-    _M_node = (_Node*)(_M_node->_M_prev);\n+    this->_M_decr();\n     return *this;\n   }\n   _Self operator--(int) { \n     _Self __tmp = *this;\n-    --*this;\n+    this->_M_decr();\n     return __tmp;\n   }\n };\n \n #ifndef __STL_CLASS_PARTIAL_SPECIALIZATION\n \n-template <class _Tp, class _Ref, class _Ptr>\n inline bidirectional_iterator_tag\n-iterator_category(const _List_iterator<_Tp, _Ref, _Ptr>&)\n+iterator_category(const _List_iterator_base&)\n {\n   return bidirectional_iterator_tag();\n }\n@@ -110,9 +127,8 @@ value_type(const _List_iterator<_Tp, _Ref, _Ptr>&)\n   return 0;\n }\n \n-template <class _Tp, class _Ref, class _Ptr>\n inline ptrdiff_t*\n-distance_type(const _List_iterator<_Tp, _Ref, _Ptr>&)\n+distance_type(const _List_iterator_base&)\n {\n   return 0;\n }\n@@ -236,7 +252,7 @@ _List_base<_Tp,_Alloc>::clear()\n   while (__cur != _M_node) {\n     _List_node<_Tp>* __tmp = __cur;\n     __cur = (_List_node<_Tp>*) __cur->_M_next;\n-    destroy(&__tmp->_M_data);\n+    _Destroy(&__tmp->_M_data);\n     _M_put_node(__tmp);\n   }\n   _M_node->_M_next = _M_node;\n@@ -245,6 +261,10 @@ _List_base<_Tp,_Alloc>::clear()\n \n template <class _Tp, class _Alloc = allocator<_Tp> >\n class list : protected _List_base<_Tp, _Alloc> {\n+  // requirements:\n+\n+  __STL_CLASS_REQUIRES(_Tp, _Assignable);\n+\n   typedef _List_base<_Tp, _Alloc> _Base;\n protected:\n   typedef void* _Void_pointer;\n@@ -290,7 +310,7 @@ class list : protected _List_base<_Tp, _Alloc> {\n   {\n     _Node* __p = _M_get_node();\n     __STL_TRY {\n-      construct(&__p->_M_data, __x);\n+      _Construct(&__p->_M_data, __x);\n     }\n     __STL_UNWIND(_M_put_node(__p));\n     return __p;\n@@ -300,7 +320,7 @@ class list : protected _List_base<_Tp, _Alloc> {\n   {\n     _Node* __p = _M_get_node();\n     __STL_TRY {\n-      construct(&__p->_M_data);\n+      _Construct(&__p->_M_data);\n     }\n     __STL_UNWIND(_M_put_node(__p));\n     return __p;\n@@ -344,7 +364,7 @@ class list : protected _List_base<_Tp, _Alloc> {\n     _Node* __tmp = _M_create_node(__x);\n     __tmp->_M_next = __position._M_node;\n     __tmp->_M_prev = __position._M_node->_M_prev;\n-    ((_Node*) (__position._M_node->_M_prev))->_M_next = __tmp;\n+    __position._M_node->_M_prev->_M_next = __tmp;\n     __position._M_node->_M_prev = __tmp;\n     return __tmp;\n   }\n@@ -384,19 +404,20 @@ class list : protected _List_base<_Tp, _Alloc> {\n   void push_back() {insert(end());}\n \n   iterator erase(iterator __position) {\n-    _Node* __next_node = (_Node*) (__position._M_node->_M_next);\n-    _Node* __prev_node = (_Node*) (__position._M_node->_M_prev);\n+    _List_node_base* __next_node = __position._M_node->_M_next;\n+    _List_node_base* __prev_node = __position._M_node->_M_prev;\n+    _Node* __n = (_Node*) __position._M_node;\n     __prev_node->_M_next = __next_node;\n     __next_node->_M_prev = __prev_node;\n-    destroy(&__position._M_node->_M_data);\n-    _M_put_node(__position._M_node);\n-    return iterator(__next_node);\n+    _Destroy(&__n->_M_data);\n+    _M_put_node(__n);\n+    return iterator((_Node*) __next_node);\n   }\n   iterator erase(iterator __first, iterator __last);\n   void clear() { _Base::clear(); }\n \n   void resize(size_type __new_size, const _Tp& __x);\n-  void resize(size_type __new_size) { resize(__new_size, _Tp()); }\n+  void resize(size_type __new_size) { this->resize(__new_size, _Tp()); }\n \n   void pop_front() { erase(begin()); }\n   void pop_back() { \n@@ -426,11 +447,11 @@ class list : protected _List_base<_Tp, _Alloc> {\n   list(const _Tp* __first, const _Tp* __last,\n        const allocator_type& __a = allocator_type())\n     : _Base(__a)\n-    { insert(begin(), __first, __last); }\n+    { this->insert(begin(), __first, __last); }\n   list(const_iterator __first, const_iterator __last,\n        const allocator_type& __a = allocator_type())\n     : _Base(__a)\n-    { insert(begin(), __first, __last); }\n+    { this->insert(begin(), __first, __last); }\n \n #endif /* __STL_MEMBER_TEMPLATES */\n   list(const list<_Tp, _Alloc>& __x) : _Base(__x.get_allocator())\n@@ -472,32 +493,32 @@ class list : protected _List_base<_Tp, _Alloc> {\n   void transfer(iterator __position, iterator __first, iterator __last) {\n     if (__position != __last) {\n       // Remove [first, last) from its old position.\n-      ((_Node*) (__last._M_node->_M_prev))->_M_next     = __position._M_node;\n-      ((_Node*) (__first._M_node->_M_prev))->_M_next    = __last._M_node;\n-      ((_Node*) (__position._M_node->_M_prev))->_M_next = __first._M_node; \n+      __last._M_node->_M_prev->_M_next     = __position._M_node;\n+      __first._M_node->_M_prev->_M_next    = __last._M_node;\n+      __position._M_node->_M_prev->_M_next = __first._M_node; \n \n       // Splice [first, last) into its new position.\n-      _Node* __tmp = (_Node*) (__position._M_node->_M_prev);\n+      _List_node_base* __tmp      = __position._M_node->_M_prev;\n       __position._M_node->_M_prev = __last._M_node->_M_prev;\n-      __last._M_node->_M_prev      = __first._M_node->_M_prev; \n+      __last._M_node->_M_prev     = __first._M_node->_M_prev; \n       __first._M_node->_M_prev    = __tmp;\n     }\n   }\n \n public:\n   void splice(iterator __position, list& __x) {\n     if (!__x.empty()) \n-      transfer(__position, __x.begin(), __x.end());\n+      this->transfer(__position, __x.begin(), __x.end());\n   }\n   void splice(iterator __position, list&, iterator __i) {\n     iterator __j = __i;\n     ++__j;\n     if (__position == __i || __position == __j) return;\n-    transfer(__position, __i, __j);\n+    this->transfer(__position, __i, __j);\n   }\n   void splice(iterator __position, list&, iterator __first, iterator __last) {\n     if (__first != __last) \n-      transfer(__position, __first, __last);\n+      this->transfer(__position, __first, __last);\n   }\n   void remove(const _Tp& __value);\n   void unique();\n@@ -617,8 +638,8 @@ list<_Tp, _Alloc>::_M_fill_insert(iterator __position,\n }\n \n template <class _Tp, class _Alloc>\n-list<_Tp,_Alloc>::iterator list<_Tp, _Alloc>::erase(iterator __first, \n-                                                    iterator __last)\n+typename list<_Tp,_Alloc>::iterator list<_Tp, _Alloc>::erase(iterator __first, \n+                                                             iterator __last)\n {\n   while (__first != __last)\n     erase(__first++);\n@@ -733,28 +754,26 @@ void list<_Tp, _Alloc>::merge(list<_Tp, _Alloc>& __x)\n   if (__first2 != __last2) transfer(__last1, __first2, __last2);\n }\n \n+inline void __List_base_reverse(_List_node_base* __p)\n+{\n+  _List_node_base* __tmp = __p;\n+  do {\n+    __STD::swap(__tmp->_M_next, __tmp->_M_prev);\n+    __tmp = __tmp->_M_prev;     // Old next node is now prev.\n+  } while (__tmp != __p);\n+}\n+\n template <class _Tp, class _Alloc>\n-void list<_Tp, _Alloc>::reverse() \n+inline void list<_Tp, _Alloc>::reverse() \n {\n-  // Do nothing if the list has length 0 or 1.\n-  if (_M_node->_M_next != _M_node &&\n-      ((_Node*) (_M_node->_M_next))->_M_next != _M_node) {\n-    iterator __first = begin();\n-    ++__first;\n-    while (__first != end()) {\n-      iterator __old = __first;\n-      ++__first;\n-      transfer(begin(), __old, __first);\n-    }\n-  }\n+  __List_base_reverse(this->_M_node);\n }    \n \n template <class _Tp, class _Alloc>\n void list<_Tp, _Alloc>::sort()\n {\n   // Do nothing if the list has length 0 or 1.\n-  if (_M_node->_M_next != _M_node &&\n-      ((_Node*) (_M_node->_M_next))->_M_next != _M_node) {\n+  if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node) {\n     list<_Tp, _Alloc> __carry;\n     list<_Tp, _Alloc> __counter[64];\n     int __fill = 0;\n@@ -829,8 +848,7 @@ template <class _Tp, class _Alloc> template <class _StrictWeakOrdering>\n void list<_Tp, _Alloc>::sort(_StrictWeakOrdering __comp)\n {\n   // Do nothing if the list has length 0 or 1.\n-  if (_M_node->_M_next != _M_node &&\n-      ((_Node*) (_M_node->_M_next))->_M_next != _M_node) {\n+  if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node) {\n     list<_Tp, _Alloc> __carry;\n     list<_Tp, _Alloc> __counter[64];\n     int __fill = 0;"}, {"sha": "0b7a06d4b8bf84e56966407e35b66ed1c4cf806b", "filename": "libstdc++-v3/bits/stl_map.h", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_map.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -31,6 +31,8 @@\n #ifndef _CPP_BITS_STL_MAP_H\n #define _CPP_BITS_STL_MAP_H 1\n \n+#include <bits/concept_checks.h>\n+\n __STL_BEGIN_NAMESPACE\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n@@ -43,6 +45,11 @@ template <class _Key, class _Tp, class _Compare = less<_Key>,\n class map {\n public:\n \n+// requirements:\n+\n+  __STL_CLASS_REQUIRES(_Tp, _Assignable);\n+  __STL_CLASS_BINARY_FUNCTION_CHECK(_Compare, bool, _Key, _Key);\n+\n // typedefs:\n \n   typedef _Key                 key_type;\n@@ -181,7 +188,9 @@ class map {\n \n   iterator find(const key_type& __x) { return _M_t.find(__x); }\n   const_iterator find(const key_type& __x) const { return _M_t.find(__x); }\n-  size_type count(const key_type& __x) const { return _M_t.count(__x); }\n+  size_type count(const key_type& __x) const {\n+    return _M_t.find(__x) == _M_t.end() ? 0 : 1; \n+  }\n   iterator lower_bound(const key_type& __x) {return _M_t.lower_bound(__x); }\n   const_iterator lower_bound(const key_type& __x) const {\n     return _M_t.lower_bound(__x); \n@@ -198,19 +207,19 @@ class map {\n     return _M_t.equal_range(__x);\n   }\n \n-#ifdef __STL_MEMBER_TEMPLATES \n+#ifdef __STL_TEMPLATE_FRIENDS \n   template <class _K1, class _T1, class _C1, class _A1>\n   friend bool operator== (const map<_K1, _T1, _C1, _A1>&,\n                           const map<_K1, _T1, _C1, _A1>&);\n   template <class _K1, class _T1, class _C1, class _A1>\n   friend bool operator< (const map<_K1, _T1, _C1, _A1>&,\n                          const map<_K1, _T1, _C1, _A1>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n+#else /* __STL_TEMPLATE_FRIENDS */\n   friend bool __STD_QUALIFIER\n   operator== __STL_NULL_TMPL_ARGS (const map&, const map&);\n   friend bool __STD_QUALIFIER\n   operator< __STL_NULL_TMPL_ARGS (const map&, const map&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n+#endif /* __STL_TEMPLATE_FRIENDS */\n };\n \n template <class _Key, class _Tp, class _Compare, class _Alloc>"}, {"sha": "1c5401b378aafa09748051b67ac3c7fcb96d2231", "filename": "libstdc++-v3/bits/stl_multimap.h", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_multimap.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -31,6 +31,8 @@\n #ifndef __SGI_STL_INTERNAL_MULTIMAP_H\n #define __SGI_STL_INTERNAL_MULTIMAP_H\n \n+#include <bits/concept_checks.h>\n+\n __STL_BEGIN_NAMESPACE\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n@@ -55,6 +57,11 @@ inline bool operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n \n template <class _Key, class _Tp, class _Compare, class _Alloc>\n class multimap {\n+  // requirements:\n+\n+  __STL_CLASS_REQUIRES(_Tp, _Assignable);\n+  __STL_CLASS_BINARY_FUNCTION_CHECK(_Compare, bool, _Key, _Key);\n+\n public:\n \n // typedefs:\n@@ -200,19 +207,19 @@ class multimap {\n     return _M_t.equal_range(__x);\n   }\n \n-#ifdef __STL_MEMBER_TEMPLATES \n+#ifdef __STL_TEMPLATE_FRIENDS \n   template <class _K1, class _T1, class _C1, class _A1>\n   friend bool operator== (const multimap<_K1, _T1, _C1, _A1>&,\n                           const multimap<_K1, _T1, _C1, _A1>&);\n   template <class _K1, class _T1, class _C1, class _A1>\n   friend bool operator< (const multimap<_K1, _T1, _C1, _A1>&,\n                          const multimap<_K1, _T1, _C1, _A1>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n+#else /* __STL_TEMPLATE_FRIENDS */\n   friend bool __STD_QUALIFIER\n   operator== __STL_NULL_TMPL_ARGS (const multimap&, const multimap&);\n   friend bool __STD_QUALIFIER\n   operator< __STL_NULL_TMPL_ARGS (const multimap&, const multimap&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n+#endif /* __STL_TEMPLATE_FRIENDS */\n };\n \n template <class _Key, class _Tp, class _Compare, class _Alloc>"}, {"sha": "7e75ec3cd0aafe6237cce916a25010deb56168e1", "filename": "libstdc++-v3/bits/stl_multiset.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_multiset.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -31,6 +31,8 @@\n #ifndef __SGI_STL_INTERNAL_MULTISET_H\n #define __SGI_STL_INTERNAL_MULTISET_H\n \n+#include <bits/concept_checks.h>\n+\n __STL_BEGIN_NAMESPACE\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n@@ -54,7 +56,13 @@ inline bool operator<(const multiset<_Key,_Compare,_Alloc>& __x,\n \n template <class _Key, class _Compare, class _Alloc>\n class multiset {\n+  // requirements:\n+  \n+  __STL_CLASS_REQUIRES(_Key, _Assignable);\n+  __STL_CLASS_BINARY_FUNCTION_CHECK(_Compare, bool, _Key, _Key);\n+\n public:\n+\n   // typedefs:\n \n   typedef _Key     key_type;\n@@ -191,19 +199,19 @@ class multiset {\n     return _M_t.equal_range(__x);\n   }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n+#ifdef __STL_TEMPLATE_FRIENDS\n   template <class _K1, class _C1, class _A1>\n   friend bool operator== (const multiset<_K1,_C1,_A1>&,\n                           const multiset<_K1,_C1,_A1>&);\n   template <class _K1, class _C1, class _A1>\n   friend bool operator< (const multiset<_K1,_C1,_A1>&,\n                          const multiset<_K1,_C1,_A1>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n+#else /* __STL_TEMPLATE_FRIENDS */\n   friend bool __STD_QUALIFIER\n   operator== __STL_NULL_TMPL_ARGS (const multiset&, const multiset&);\n   friend bool __STD_QUALIFIER\n   operator< __STL_NULL_TMPL_ARGS (const multiset&, const multiset&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n+#endif /* __STL_TEMPLATE_FRIENDS */\n };\n \n template <class _Key, class _Compare, class _Alloc>"}, {"sha": "0b1742bc9d9f4be687c7d5ea30b0cb3c37ec81bf", "filename": "libstdc++-v3/bits/stl_numeric.h", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_numeric.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -37,6 +37,7 @@ __STL_BEGIN_NAMESPACE\n template <class _InputIterator, class _Tp>\n _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)\n {\n+  __STL_REQUIRES(_InputIterator, _InputIterator);\n   for ( ; __first != __last; ++__first)\n     __init = __init + *__first;\n   return __init;\n@@ -46,6 +47,7 @@ template <class _InputIterator, class _Tp, class _BinaryOperation>\n _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,\n               _BinaryOperation __binary_op)\n {\n+  __STL_REQUIRES(_InputIterator, _InputIterator);\n   for ( ; __first != __last; ++__first)\n     __init = __binary_op(__init, *__first);\n   return __init;\n@@ -55,6 +57,8 @@ template <class _InputIterator1, class _InputIterator2, class _Tp>\n _Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1,\n                  _InputIterator2 __first2, _Tp __init)\n {\n+  __STL_REQUIRES(_InputIterator2, _InputIterator);\n+  __STL_REQUIRES(_InputIterator2, _InputIterator);\n   for ( ; __first1 != __last1; ++__first1, ++__first2)\n     __init = __init + (*__first1 * *__first2);\n   return __init;\n@@ -67,6 +71,8 @@ _Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1,\n                  _BinaryOperation1 __binary_op1,\n                  _BinaryOperation2 __binary_op2)\n {\n+  __STL_REQUIRES(_InputIterator2, _InputIterator);\n+  __STL_REQUIRES(_InputIterator2, _InputIterator);\n   for ( ; __first1 != __last1; ++__first1, ++__first2)\n     __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));\n   return __init;\n@@ -90,6 +96,8 @@ _OutputIterator\n partial_sum(_InputIterator __first, _InputIterator __last,\n             _OutputIterator __result)\n {\n+  __STL_REQUIRES(_InputIterator, _InputIterator);\n+  __STL_REQUIRES(_OutputIterator, _OutputIterator);\n   if (__first == __last) return __result;\n   *__result = *__first;\n   return __partial_sum(__first, __last, __result, __VALUE_TYPE(__first));\n@@ -114,6 +122,8 @@ _OutputIterator\n partial_sum(_InputIterator __first, _InputIterator __last,\n             _OutputIterator __result, _BinaryOperation __binary_op)\n {\n+  __STL_REQUIRES(_InputIterator, _InputIterator);\n+  __STL_REQUIRES(_OutputIterator, _OutputIterator);\n   if (__first == __last) return __result;\n   *__result = *__first;\n   return __partial_sum(__first, __last, __result, __VALUE_TYPE(__first), \n@@ -139,6 +149,8 @@ _OutputIterator\n adjacent_difference(_InputIterator __first,\n                     _InputIterator __last, _OutputIterator __result)\n {\n+  __STL_REQUIRES(_InputIterator, _InputIterator);\n+  __STL_REQUIRES(_OutputIterator, _OutputIterator);\n   if (__first == __last) return __result;\n   *__result = *__first;\n   return __adjacent_difference(__first, __last, __result,\n@@ -165,6 +177,8 @@ _OutputIterator\n adjacent_difference(_InputIterator __first, _InputIterator __last,\n                     _OutputIterator __result, _BinaryOperation __binary_op)\n {\n+  __STL_REQUIRES(_InputIterator, _InputIterator);\n+  __STL_REQUIRES(_OutputIterator, _OutputIterator);\n   if (__first == __last) return __result;\n   *__result = *__first;\n   return __adjacent_difference(__first, __last, __result,\n@@ -222,10 +236,12 @@ inline _Tp power(_Tp __x, _Integer __n)\n \n // iota is not part of the C++ standard.  It is an extension.\n \n-template <class _ForwardIterator, class _Tp>\n+template <class _ForwardIter, class _Tp>\n void \n-iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value)\n+iota(_ForwardIter __first, _ForwardIter __last, _Tp __value)\n {\n+  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);\n+  __STL_CONVERTIBLE(_Tp, typename iterator_traits<_ForwardIter>::value_type);\n   while (__first != __last)\n     *__first++ = __value++;\n }"}, {"sha": "e42666e5662de91a1f7e04f812da0ffcd0508c1e", "filename": "libstdc++-v3/bits/stl_queue.h", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_queue.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -31,6 +31,8 @@\n #ifndef __SGI_STL_INTERNAL_QUEUE_H\n #define __SGI_STL_INTERNAL_QUEUE_H\n \n+#include <bits/sequence_concepts.h>\n+\n __STL_BEGIN_NAMESPACE\n \n // Forward declarations of operators < and ==, needed for friend declaration.\n@@ -49,6 +51,15 @@ inline bool operator<(const queue<_Tp, _Seq>&, const queue<_Tp, _Seq>&);\n template <class _Tp, class _Sequence>\n class queue {\n \n+  // requirements:\n+\n+  __STL_CLASS_REQUIRES(_Tp, _Assignable);\n+  __STL_CLASS_REQUIRES(_Sequence, _FrontInsertionSequence);\n+  __STL_CLASS_REQUIRES(_Sequence, _BackInsertionSequence);\n+  typedef typename _Sequence::value_type _Sequence_value_type;\n+  __STL_CLASS_REQUIRES_SAME_TYPE(_Tp, _Sequence_value_type);\n+\n+\n #ifdef __STL_MEMBER_TEMPLATES \n   template <class _Tp1, class _Seq1>\n   friend bool operator== (const queue<_Tp1, _Seq1>&,\n@@ -133,10 +144,20 @@ operator>=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n #endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n template <class _Tp, \n-          class _Sequence = vector<_Tp>,\n-          class _Compare = less<typename _Sequence::value_type> >\n+          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(vector<_Tp>),\n+          class _Compare  \n+\t  __STL_DEPENDENT_DEFAULT_TMPL(less<typename _Sequence::value_type>) >\n class priority_queue {\n public:\n+\n+  // requirements:\n+  __STL_CLASS_REQUIRES(_Tp, _Assignable);\n+  __STL_CLASS_REQUIRES(_Sequence, _Sequence);\n+  __STL_CLASS_REQUIRES(_Sequence, _RandomAccessContainer);\n+  typedef typename _Sequence::value_type _Sequence_value_type;\n+  __STL_CLASS_REQUIRES_SAME_TYPE(_Tp, _Sequence_value_type);\n+  __STL_CLASS_BINARY_FUNCTION_CHECK(_Compare, bool, _Tp, _Tp);\n+\n   typedef typename _Sequence::value_type      value_type;\n   typedef typename _Sequence::size_type       size_type;\n   typedef          _Sequence                  container_type;"}, {"sha": "435ca38b16e979e5f207f7f45069bdb66898b4af", "filename": "libstdc++-v3/bits/stl_set.h", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_set.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -31,6 +31,8 @@\n #ifndef __SGI_STL_INTERNAL_SET_H\n #define __SGI_STL_INTERNAL_SET_H\n \n+#include <bits/concept_checks.h>\n+\n __STL_BEGIN_NAMESPACE\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n@@ -55,6 +57,11 @@ inline bool operator<(const set<_Key,_Compare,_Alloc>& __x,\n \n template <class _Key, class _Compare, class _Alloc>\n class set {\n+  // requirements:\n+\n+  __STL_CLASS_REQUIRES(_Key, _Assignable);\n+  __STL_CLASS_BINARY_FUNCTION_CHECK(_Compare, bool, _Key, _Key);\n+\n public:\n   // typedefs:\n \n@@ -175,7 +182,9 @@ class set {\n   // set operations:\n \n   iterator find(const key_type& __x) const { return _M_t.find(__x); }\n-  size_type count(const key_type& __x) const { return _M_t.count(__x); }\n+  size_type count(const key_type& __x) const {\n+    return _M_t.find(__x) == _M_t.end() ? 0 : 1;\n+  }\n   iterator lower_bound(const key_type& __x) const {\n     return _M_t.lower_bound(__x);\n   }\n@@ -186,17 +195,17 @@ class set {\n     return _M_t.equal_range(__x);\n   }\n \n-#ifdef __STL_MEMBER_TEMPLATES\n+#ifdef __STL_TEMPLATE_FRIENDS\n   template <class _K1, class _C1, class _A1>\n   friend bool operator== (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n   template <class _K1, class _C1, class _A1>\n   friend bool operator< (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n-#else /* __STL_MEMBER_TEMPLATES */\n+#else /* __STL_TEMPLATE_FRIENDS */\n   friend bool __STD_QUALIFIER\n   operator== __STL_NULL_TMPL_ARGS (const set&, const set&);\n   friend bool __STD_QUALIFIER\n   operator<  __STL_NULL_TMPL_ARGS (const set&, const set&);\n-#endif /* __STL_MEMBER_TEMPLATES */\n+#endif /* __STL_TEMPLATE_FRIENDS */\n };\n \n template <class _Key, class _Compare, class _Alloc>"}, {"sha": "aa80f8730eeb61893e7978f3e6cc18a66efc4279", "filename": "libstdc++-v3/bits/stl_stack.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_stack.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -31,6 +31,8 @@\n #ifndef __SGI_STL_INTERNAL_STACK_H\n #define __SGI_STL_INTERNAL_STACK_H\n \n+#include <bits/sequence_concepts.h>\n+\n __STL_BEGIN_NAMESPACE\n \n // Forward declarations of operators == and <, needed for friend declaration.\n@@ -49,6 +51,14 @@ bool operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);\n template <class _Tp, class _Sequence>\n class stack {\n \n+  // requirements:\n+\n+  __STL_CLASS_REQUIRES(_Tp, _Assignable);\n+  __STL_CLASS_REQUIRES(_Sequence, _BackInsertionSequence);\n+  typedef typename _Sequence::value_type _Sequence_value_type;\n+  __STL_CLASS_REQUIRES_SAME_TYPE(_Tp, _Sequence_value_type);\n+\n+\n #ifdef __STL_MEMBER_TEMPLATES\n   template <class _Tp1, class _Seq1>\n   friend bool operator== (const stack<_Tp1, _Seq1>&,"}, {"sha": "46845b9870c56fd49a8549eec6bc9f77c44980f1", "filename": "libstdc++-v3/bits/stl_string_fwd.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_string_fwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_string_fwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_string_fwd.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -15,12 +15,11 @@\n #define __SGI_STL_STRING_FWD_H\n \n #include <bits/stl_config.h>\n-//#include <bits/std_cstddef.h>\n #include <bits/stl_alloc.h>\n+#include <bits/char_traits.h>\n \n __STL_BEGIN_NAMESPACE\n \n-template <class _CharT> struct char_traits;\n template <class _CharT, \n           class _Traits = char_traits<_CharT>, \n           class _Alloc = allocator<_CharT> >"}, {"sha": "5f5b451e3d1cc71c0af724d2402e0664ec63345d", "filename": "libstdc++-v3/bits/stl_threads.h", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_threads.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -119,7 +119,7 @@ struct _Refcount_Base\n // In some cases the operation is emulated with a lock.\n # ifdef __STL_SGI_THREADS\n     inline unsigned long _Atomic_swap(unsigned long * __p, unsigned long __q) {\n-#   \tif __mips < 3 || !(defined (_ABIN32) || defined(_ABI64))\n+#       if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64))\n             return test_and_set(__p, __q);\n #       else\n             return __test_and_set(__p, (unsigned long)__q);\n@@ -133,7 +133,7 @@ struct _Refcount_Base\n     // We use a template here only to get a unique initialized instance.\n     template<int __dummy>\n     struct _Swap_lock_struct {\n-\tstatic pthread_mutex_t _S_swap_lock;\n+        static pthread_mutex_t _S_swap_lock;\n     };\n \n     template<int __dummy>\n@@ -154,7 +154,7 @@ struct _Refcount_Base\n     // We use a template here only to get a unique initialized instance.\n     template<int __dummy>\n     struct _Swap_lock_struct {\n-\tstatic mutex_t _S_swap_lock;\n+        static mutex_t _S_swap_lock;\n     };\n \n     template<int __dummy>\n@@ -176,7 +176,7 @@ struct _Refcount_Base\n     // We use a template here only to get a unique initialized instance.\n     template<int __dummy>\n     struct _Swap_lock_struct {\n-\tstatic mutex_t _S_swap_lock;\n+        static mutex_t _S_swap_lock;\n     };\n \n # if ( __STL_STATIC_TEMPLATE_DATA > 0 )\n@@ -185,7 +185,7 @@ struct _Refcount_Base\n     _Swap_lock_struct<__dummy>::_S_swap_lock = DEFAULTMUTEX;\n #  else\n     __DECLARE_INSTANCE(mutex_t, _Swap_lock_struct<__dummy>::_S_swap_lock, \n-\t\t       =DEFAULTMUTEX);\n+                       =DEFAULTMUTEX);\n # endif /* ( __STL_STATIC_TEMPLATE_DATA > 0 ) */\n \n     // This should be portable, but performance is expected\n@@ -218,6 +218,23 @@ struct _Refcount_Base\n // constructors, no base classes, no virtual functions, and no private or\n // protected members.\n \n+// Helper struct.  This is a workaround for various compilers that don't\n+// handle static variables in inline functions properly.\n+template <int __inst>\n+struct _STL_mutex_spin {\n+  enum { __low_max = 30, __high_max = 1000 };\n+  // Low if we suspect uniprocessor, high for multiprocessor.\n+\n+  static unsigned __max;\n+  static unsigned __last;\n+};\n+\n+template <int __inst>\n+unsigned _STL_mutex_spin<__inst>::__max = _STL_mutex_spin<__inst>::__low_max;\n+\n+template <int __inst>\n+unsigned _STL_mutex_spin<__inst>::__last = 0;\n+\n struct _STL_mutex_lock\n {\n #if defined(__STL_SGI_THREADS) || defined(__STL_WIN32THREADS)\n@@ -232,32 +249,25 @@ struct _STL_mutex_lock\n           __ts.tv_nsec = 1 << __log_nsec;\n           nanosleep(&__ts, 0);\n #     elif defined(__STL_WIN32THREADS)\n-\t  if (__log_nsec <= 20) {\n-\t      Sleep(0);\n-\t  } else {\n-\t      Sleep(1 << (__log_nsec - 20));\n-\t  }\n+          if (__log_nsec <= 20) {\n+              Sleep(0);\n+          } else {\n+              Sleep(1 << (__log_nsec - 20));\n+          }\n #     else\n-#\terror unimplemented\n+#       error unimplemented\n #     endif\n   }\n   void _M_acquire_lock() {\n-    const unsigned __low_spin_max = 30;  // spins if we suspect uniprocessor\n-    const unsigned __high_spin_max = 1000; // spins for multiprocessor\n-    static unsigned __spin_max = __low_spin_max;\n-    unsigned __my_spin_max;\n-    static unsigned __last_spins = 0;\n-    unsigned __my_last_spins;\n-    volatile unsigned __junk;\n-    int __i;\n     volatile unsigned long* __lock = &this->_M_lock;\n \n     if (!_Atomic_swap((unsigned long*)__lock, 1)) {\n       return;\n     }\n-    __my_spin_max = __spin_max;\n-    __my_last_spins = __last_spins;\n-    __junk = 17;\t// Value doesn't matter.\n+    unsigned __my_spin_max = _STL_mutex_spin<0>::__max;\n+    unsigned __my_last_spins = _STL_mutex_spin<0>::__last;\n+    volatile unsigned __junk = 17;      // Value doesn't matter.\n+    unsigned __i;\n     for (__i = 0; __i < __my_spin_max; __i++) {\n       if (__i < __my_last_spins/2 || *__lock) {\n         __junk *= __junk; __junk *= __junk;\n@@ -269,13 +279,13 @@ struct _STL_mutex_lock\n         // Spinning worked.  Thus we're probably not being scheduled\n         // against the other process with which we were contending.\n         // Thus it makes sense to spin longer the next time.\n-        __last_spins = __i;\n-        __spin_max = __high_spin_max;\n+        _STL_mutex_spin<0>::__last = __i;\n+        _STL_mutex_spin<0>::__max = _STL_mutex_spin<0>::__high_max;\n         return;\n       }\n     }\n     // We are probably being scheduled against the other process.  Sleep.\n-    __spin_max = __low_spin_max;\n+    _STL_mutex_spin<0>::__max = _STL_mutex_spin<0>::__low_max;\n     for (__i = 0 ;; ++__i) {\n       int __log_nsec = __i + 6;\n \n@@ -292,7 +302,7 @@ struct _STL_mutex_lock\n         asm(\"sync\");\n         *__lock = 0;\n #   elif defined(__STL_SGI_THREADS) && __mips >= 3 \\\n-\t && (defined (_ABIN32) || defined(_ABI64))\n+         && (defined (_ABIN32) || defined(_ABI64))\n         __lock_release(__lock);\n #   else \n         *__lock = 0;"}, {"sha": "9ab9dafcbeb1d96f1245fef2fbd2133b9380b689", "filename": "libstdc++-v3/bits/stl_tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_tree.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -970,7 +970,7 @@ _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>\n {\n   if (__position._M_node == _M_header->_M_left) { // begin()\n     if (size() > 0 && \n-       ! _M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__v)))\n+\t!_M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__v)))\n       return _M_insert(__position._M_node, __position._M_node, __v);\n     // first argument just needs to be non-null \n     else"}, {"sha": "a9b196be347fd207e7fc1207ed5ac09db884f805", "filename": "libstdc++-v3/bits/stl_uninitialized.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_uninitialized.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -57,10 +57,10 @@ __uninitialized_copy_aux(_InputIter __first, _InputIter __last,\n   _ForwardIter __cur = __result;\n   __STL_TRY {\n     for ( ; __first != __last; ++__first, ++__cur)\n-      construct(&*__cur, *__first);\n+      _Construct(&*__cur, *__first);\n     return __cur;\n   }\n-  __STL_UNWIND(destroy(__result, __cur));\n+  __STL_UNWIND(_Destroy(__result, __cur));\n }\n \n \n@@ -107,10 +107,10 @@ __uninitialized_copy_n(_InputIter __first, _Size __count,\n   _ForwardIter __cur = __result;\n   __STL_TRY {\n     for ( ; __count > 0 ; --__count, ++__first, ++__cur) \n-      construct(&*__cur, *__first);\n+      _Construct(&*__cur, *__first);\n     return pair<_InputIter, _ForwardIter>(__first, __cur);\n   }\n-  __STL_UNWIND(destroy(__result, __cur));\n+  __STL_UNWIND(_Destroy(__result, __cur));\n }\n \n template <class _RandomAccessIter, class _Size, class _ForwardIter>\n@@ -158,9 +158,9 @@ __uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last,\n   _ForwardIter __cur = __first;\n   __STL_TRY {\n     for ( ; __cur != __last; ++__cur)\n-      construct(&*__cur, __x);\n+      _Construct(&*__cur, __x);\n   }\n-  __STL_UNWIND(destroy(__first, __cur));\n+  __STL_UNWIND(_Destroy(__first, __cur));\n }\n \n template <class _ForwardIter, class _Tp, class _Tp1>\n@@ -198,10 +198,10 @@ __uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,\n   _ForwardIter __cur = __first;\n   __STL_TRY {\n     for ( ; __n > 0; --__n, ++__cur)\n-      construct(&*__cur, __x);\n+      _Construct(&*__cur, __x);\n     return __cur;\n   }\n-  __STL_UNWIND(destroy(__first, __cur));\n+  __STL_UNWIND(_Destroy(__first, __cur));\n }\n \n template <class _ForwardIter, class _Size, class _Tp, class _Tp1>\n@@ -237,7 +237,7 @@ __uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,\n   __STL_TRY {\n     return uninitialized_copy(__first2, __last2, __mid);\n   }\n-  __STL_UNWIND(destroy(__result, __mid));\n+  __STL_UNWIND(_Destroy(__result, __mid));\n }\n \n // __uninitialized_fill_copy\n@@ -253,7 +253,7 @@ __uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid,\n   __STL_TRY {\n     return uninitialized_copy(__first, __last, __mid);\n   }\n-  __STL_UNWIND(destroy(__result, __mid));\n+  __STL_UNWIND(_Destroy(__result, __mid));\n }\n \n // __uninitialized_copy_fill\n@@ -269,7 +269,7 @@ __uninitialized_copy_fill(_InputIter __first1, _InputIter __last1,\n   __STL_TRY {\n     uninitialized_fill(__mid2, __last2, __x);\n   }\n-  __STL_UNWIND(destroy(__first2, __mid2));\n+  __STL_UNWIND(_Destroy(__first2, __mid2));\n }\n \n __STL_END_NAMESPACE"}, {"sha": "0727df6fac155393ee085ec0f8b5195f14cd196d", "filename": "libstdc++-v3/bits/stl_vector.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstl_vector.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -33,6 +33,8 @@\n \n #include <bits/exception_support.h>\n \n+#include <bits/concept_checks.h>\n+\n __STL_BEGIN_NAMESPACE \n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n@@ -154,6 +156,10 @@ class _Vector_base {\n template <class _Tp, class _Alloc = allocator<_Tp> >\n class vector : protected _Vector_base<_Tp, _Alloc> \n {\n+  // requirements:\n+\n+  __STL_CLASS_REQUIRES(_Tp, _Assignable);\n+\n private:\n   typedef _Vector_base<_Tp, _Alloc> _Base;\n   typedef vector<_Tp, _Alloc> vector_type;"}, {"sha": "015d803509d7a1112d75efdcbee5a3547d2cd47a", "filename": "libstdc++-v3/ext/hash_map", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fext%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fext%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fhash_map?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -165,6 +165,7 @@ public:\n   operator== __STL_NULL_TMPL_ARGS (const hash_map&, const hash_map&);\n #endif /* __STL_MEMBER_TEMPLATES */\n \n+#include <bits/concept_checks.h>\n \n   iterator begin() { return _M_ht.begin(); }\n   iterator end() { return _M_ht.end(); }\n@@ -260,6 +261,20 @@ template <class _Key, class _Tp, class _HashFcn, class _EqualKey,\n           class _Alloc>\n class hash_multimap\n {\n+  // requirements:\n+\n+  __STL_CLASS_REQUIRES(_Key, _Assignable);\n+  __STL_CLASS_REQUIRES(_Tp, _Assignable);\n+  __STL_CLASS_UNARY_FUNCTION_CHECK(_HashFcn, size_t, _Key);\n+  __STL_CLASS_BINARY_FUNCTION_CHECK(_EqualKey, bool, _Key, _Key);\n+\n+  // requirements:\n+\n+  __STL_CLASS_REQUIRES(_Key, _Assignable);\n+  __STL_CLASS_REQUIRES(_Tp, _Assignable);\n+  __STL_CLASS_UNARY_FUNCTION_CHECK(_HashFcn, size_t, _Key);\n+  __STL_CLASS_BINARY_FUNCTION_CHECK(_EqualKey, bool, _Key, _Key);\n+\n private:\n   typedef hashtable<pair<const _Key, _Tp>, _Key, _HashFcn,\n                     _Select1st<pair<const _Key, _Tp> >, _EqualKey, _Alloc> "}, {"sha": "24869cd030c8aacb397122b13fa40ec36ca110c1", "filename": "libstdc++-v3/ext/hash_set", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fext%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fext%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fhash_set?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -33,6 +33,8 @@\n \n #include <ext/stl_hashtable.h>\n \n+#include <bits/concept_checks.h>\n+\n __STL_BEGIN_NAMESPACE\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n@@ -56,6 +58,12 @@ operator==(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,\n template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n class hash_set\n {\n+  // requirements:\n+\n+  __STL_CLASS_REQUIRES(_Value, _Assignable);\n+  __STL_CLASS_UNARY_FUNCTION_CHECK(_HashFcn, size_t, _Value);\n+  __STL_CLASS_BINARY_FUNCTION_CHECK(_EqualKey, bool, _Value, _Value);\n+\n private:\n   typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>, \n                     _EqualKey, _Alloc> _Ht;\n@@ -254,6 +262,12 @@ operator==(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,\n template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n class hash_multiset\n {\n+  // requirements:\n+\n+  __STL_CLASS_REQUIRES(_Value, _Assignable);\n+  __STL_CLASS_UNARY_FUNCTION_CHECK(_HashFcn, size_t, _Value);\n+  __STL_CLASS_BINARY_FUNCTION_CHECK(_EqualKey, bool, _Value, _Value);\n+\n private:\n   typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>, \n                     _EqualKey, _Alloc> _Ht;"}, {"sha": "cc4d7bc679e445c99c01f42dbb05190c4f4ef0f8", "filename": "libstdc++-v3/ext/ropeimpl.h", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fext%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fext%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fropeimpl.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -1525,35 +1525,36 @@ const _CharT* rope<_CharT,_Alloc>::replace_with_c_str() {\n \n // Algorithm specializations.  More should be added.\n \n-#ifndef _MSC_VER\n-// I couldn't get this to work with VC++\n-template<class _CharT,class _Alloc>\n-void\n-_Rope_rotate(_Rope_iterator<_CharT,_Alloc> __first,\n-              _Rope_iterator<_CharT,_Alloc> __middle,\n-              _Rope_iterator<_CharT,_Alloc> __last)\n+template<class _Rope_iterator>  // was templated on CharT and Alloc\n+void\t\t\t\t// VC++ workaround\n+_Rope_rotate(_Rope_iterator __first,\n+             _Rope_iterator __middle,\n+             _Rope_iterator __last)\n {\n-    __stl_assert(__first.container() == __middle.container()\n-                 && __middle.container() == __last.container());\n-    rope<_CharT,_Alloc>& __r(__first.container());\n-    rope<_CharT,_Alloc> __prefix = __r.substr(0, __first.index());\n-    rope<_CharT,_Alloc> __suffix = \n-      __r.substr(__last.index(), __r.size() - __last.index());\n-    rope<_CharT,_Alloc> __part1 = \n-      __r.substr(__middle.index(), __last.index() - __middle.index());\n-    rope<_CharT,_Alloc> __part2 = \n-      __r.substr(__first.index(), __middle.index() - __first.index());\n-    __r = __prefix;\n-    __r += __part1;\n-    __r += __part2;\n-    __r += __suffix;\n+  typedef typename _Rope_iterator::value_type _CharT;\n+  typedef typename _Rope_iterator::_allocator_type _Alloc;\n+  \n+  __stl_assert(__first.container() == __middle.container()\n+                           && __middle.container() == __last.container());\n+  rope<_CharT,_Alloc>& __r(__first.container());\n+  rope<_CharT,_Alloc> __prefix = __r.substr(0, __first.index());\n+  rope<_CharT,_Alloc> __suffix = \n+    __r.substr(__last.index(), __r.size() - __last.index());\n+  rope<_CharT,_Alloc> __part1 = \n+    __r.substr(__middle.index(), __last.index() - __middle.index());\n+  rope<_CharT,_Alloc> __part2 = \n+    __r.substr(__first.index(), __middle.index() - __first.index());\n+  __r = __prefix;\n+  __r += __part1;\n+  __r += __part2;\n+  __r += __suffix;\n }\n \n #if !defined(__GNUC__)\n // Appears to confuse g++\n-inline void rotate(_Rope_iterator<char,allocator<char> > __first,\n-                   _Rope_iterator<char,allocator<char> > __middle,\n-                   _Rope_iterator<char,allocator<char> > __last) {\n+inline void rotate(_Rope_iterator<char,__STL_DEFAULT_ALLOCATOR(char)> __first,\n+                   _Rope_iterator<char,__STL_DEFAULT_ALLOCATOR(char)> __middle,\n+                   _Rope_iterator<char,__STL_DEFAULT_ALLOCATOR(char)> __last) {\n     _Rope_rotate(__first, __middle, __last);\n }\n #endif\n@@ -1567,13 +1568,13 @@ inline void rotate(_Rope_iterator<char,allocator<char> > __first,\n //   for unicode strings.  Unsigned short may be a better character\n //   type.\n inline void rotate(\n-\t\t_Rope_iterator<wchar_t, allocator<char> > __first,\n-                _Rope_iterator<wchar_t, allocator<char> > __middle,\n-                _Rope_iterator<wchar_t, allocator<char> > __last) {\n+\t\t_Rope_iterator<wchar_t,__STL_DEFAULT_ALLOCATOR(char)> __first,\n+                _Rope_iterator<wchar_t,__STL_DEFAULT_ALLOCATOR(char)> __middle,\n+                _Rope_iterator<wchar_t,__STL_DEFAULT_ALLOCATOR(char)> __last) {\n     _Rope_rotate(__first, __middle, __last);\n }\n # endif\n-#endif /* _MSC_VER */\n+\n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma reset woff 1174"}, {"sha": "ef0906279a9781f8433f9bab738c9cfff086dc1d", "filename": "libstdc++-v3/ext/slist", "status": "modified", "additions": 135, "deletions": 110, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fext%2Fslist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fext%2Fslist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fslist?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -16,13 +16,10 @@\n  *   You should not attempt to use it directly.\n  */\n \n-#ifndef _CPP_BITS_STL_SLIST_H\n-#define _CPP_BITS_STL_SLIST_H 1\n+#ifndef __SGI_STL_INTERNAL_SLIST_H\n+#define __SGI_STL_INTERNAL_SLIST_H\n \n-#include <bits/stl_algobase.h>\n-#include <bits/stl_alloc.h>\n-#include <bits/stl_construct.h>\n-#include <bits/stl_uninitialized.h>\n+#include <bits/concept_checks.h>\n \n __STL_BEGIN_NAMESPACE \n \n@@ -140,11 +137,11 @@ struct _Slist_iterator : public _Slist_iterator_base\n {\n   typedef _Slist_iterator<_Tp, _Tp&, _Tp*>             iterator;\n   typedef _Slist_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n-  typedef _Slist_iterator<_Tp, _Ref, _Ptr>           _Self;\n+  typedef _Slist_iterator<_Tp, _Ref, _Ptr>             _Self;\n \n   typedef _Tp              value_type;\n-  typedef _Ptr            pointer;\n-  typedef _Ref            reference;\n+  typedef _Ptr             pointer;\n+  typedef _Ref             reference;\n   typedef _Slist_node<_Tp> _Node;\n \n   _Slist_iterator(_Node* __x) : _Slist_iterator_base(__x) {}\n@@ -248,8 +245,9 @@ struct _Slist_base\n           _Base;\n   typedef typename _Base::allocator_type allocator_type;\n \n-  _Slist_base(const allocator_type& __a) : _Base(__a) { _M_head._M_next = 0; }\n-  ~_Slist_base() { _M_erase_after(&_M_head, 0); }\n+  _Slist_base(const allocator_type& __a)\n+    : _Base(__a) { this->_M_head._M_next = 0; }\n+  ~_Slist_base() { _M_erase_after(&this->_M_head, 0); }\n \n protected:\n \n@@ -300,7 +298,7 @@ protected:\n template <class _Tp, class _Alloc> \n _Slist_node_base*\n _Slist_base<_Tp,_Alloc>::_M_erase_after(_Slist_node_base* __before_first,\n-                                       _Slist_node_base* __last_node) {\n+                                        _Slist_node_base* __last_node) {\n   _Slist_node<_Tp>* __cur = (_Slist_node<_Tp>*) (__before_first->_M_next);\n   while (__cur != __last_node) {\n     _Slist_node<_Tp>* __tmp = __cur;\n@@ -312,9 +310,13 @@ _Slist_base<_Tp,_Alloc>::_M_erase_after(_Slist_node_base* __before_first,\n   return __last_node;\n }\n \n-template <class _Tp, class _Alloc = allocator<_Tp> >\n+template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >\n class slist : private _Slist_base<_Tp,_Alloc>\n {\n+  // requirements:\n+\n+  __STL_CLASS_REQUIRES(_Tp, _Assignable);\n+\n private:\n   typedef _Slist_base<_Tp,_Alloc> _Base;\n public:\n@@ -334,66 +336,58 @@ public:\n \n private:\n   typedef _Slist_node<_Tp>      _Node;\n-  typedef _Slist_node_base     _Node_base;\n-  typedef _Slist_iterator_base _Iterator_base;\n+  typedef _Slist_node_base      _Node_base;\n+  typedef _Slist_iterator_base  _Iterator_base;\n \n   _Node* _M_create_node(const value_type& __x) {\n-    _Node* __node = _M_get_node();\n+    _Node* __node = this->_M_get_node();\n     __STL_TRY {\n       construct(&__node->_M_data, __x);\n       __node->_M_next = 0;\n     }\n-    __STL_UNWIND(_M_put_node(__node));\n+    __STL_UNWIND(this->_M_put_node(__node));\n     return __node;\n   }\n   \n   _Node* _M_create_node() {\n-    _Node* __node = _M_get_node();\n+    _Node* __node = this->_M_get_node();\n     __STL_TRY {\n       construct(&__node->_M_data);\n       __node->_M_next = 0;\n     }\n-    __STL_UNWIND(_M_put_node(__node));\n+    __STL_UNWIND(this->_M_put_node(__node));\n     return __node;\n   }\n \n-private:\n-#ifdef __STL_USE_NAMESPACES  \n-  using _Base::_M_get_node;\n-  using _Base::_M_put_node;\n-  using _Base::_M_erase_after;\n-  using _Base::_M_head;\n-#endif /* __STL_USE_NAMESPACES */\n-\n public:\n   explicit slist(const allocator_type& __a = allocator_type()) : _Base(__a) {}\n \n   slist(size_type __n, const value_type& __x,\n         const allocator_type& __a =  allocator_type()) : _Base(__a)\n-    { _M_insert_after_fill(&_M_head, __n, __x); }\n+    { _M_insert_after_fill(&this->_M_head, __n, __x); }\n \n   explicit slist(size_type __n) : _Base(allocator_type())\n-    { _M_insert_after_fill(&_M_head, __n, value_type()); }\n+    { _M_insert_after_fill(&this->_M_head, __n, value_type()); }\n \n #ifdef __STL_MEMBER_TEMPLATES\n   // We don't need any dispatching tricks here, because _M_insert_after_range\n   // already does them.\n   template <class _InputIterator>\n   slist(_InputIterator __first, _InputIterator __last,\n         const allocator_type& __a =  allocator_type()) : _Base(__a)\n-    { _M_insert_after_range(&_M_head, __first, __last); }\n+    { _M_insert_after_range(&this->_M_head, __first, __last); }\n \n #else /* __STL_MEMBER_TEMPLATES */\n   slist(const_iterator __first, const_iterator __last,\n         const allocator_type& __a =  allocator_type()) : _Base(__a)\n-    { _M_insert_after_range(&_M_head, __first, __last); }\n+    { _M_insert_after_range(&this->_M_head, __first, __last); }\n   slist(const value_type* __first, const value_type* __last,\n         const allocator_type& __a =  allocator_type()) : _Base(__a)\n-    { _M_insert_after_range(&_M_head, __first, __last); }\n+    { _M_insert_after_range(&this->_M_head, __first, __last); }\n #endif /* __STL_MEMBER_TEMPLATES */\n \n   slist(const slist& __x) : _Base(__x.get_allocator())\n-    { _M_insert_after_range(&_M_head, __x.begin(), __x.end()); }\n+    { _M_insert_after_range(&this->_M_head, __x.begin(), __x.end()); }\n \n   slist& operator= (const slist& __x);\n \n@@ -431,9 +425,9 @@ public:\n \n public:\n \n-  iterator begin() { return iterator((_Node*)_M_head._M_next); }\n+  iterator begin() { return iterator((_Node*)this->_M_head._M_next); }\n   const_iterator begin() const \n-    { return const_iterator((_Node*)_M_head._M_next);}\n+    { return const_iterator((_Node*)this->_M_head._M_next);}\n \n   iterator end() { return iterator(0); }\n   const_iterator end() const { return const_iterator(0); }\n@@ -445,43 +439,41 @@ public:\n   // slist, before_begin() is not the same iterator as end().  It \n   // is always necessary to increment before_begin() at least once to\n   // obtain end().\n-  iterator before_begin() { return iterator((_Node*) &_M_head); }\n+  iterator before_begin() { return iterator((_Node*) &this->_M_head); }\n   const_iterator before_begin() const\n-    { return const_iterator((_Node*) &_M_head); }\n+    { return const_iterator((_Node*) &this->_M_head); }\n \n-  size_type size() const { return __slist_size(_M_head._M_next); }\n+  size_type size() const { return __slist_size(this->_M_head._M_next); }\n   \n   size_type max_size() const { return size_type(-1); }\n \n-  bool empty() const { return _M_head._M_next == 0; }\n-\n-  void swap(slist& __x) { __STD::swap(_M_head._M_next, __x._M_head._M_next); }\n+  bool empty() const { return this->_M_head._M_next == 0; }\n \n-public:\n-  friend bool operator== __STL_NULL_TMPL_ARGS (const slist<_Tp,_Alloc>& _SL1,\n-                                               const slist<_Tp,_Alloc>& _SL2);\n+  void swap(slist& __x)\n+    { __STD::swap(this->_M_head._M_next, __x._M_head._M_next); }\n \n public:\n \n-  reference front() { return ((_Node*) _M_head._M_next)->_M_data; }\n+  reference front() { return ((_Node*) this->_M_head._M_next)->_M_data; }\n   const_reference front() const \n-    { return ((_Node*) _M_head._M_next)->_M_data; }\n+    { return ((_Node*) this->_M_head._M_next)->_M_data; }\n   void push_front(const value_type& __x)   {\n-    __slist_make_link(&_M_head, _M_create_node(__x));\n+    __slist_make_link(&this->_M_head, _M_create_node(__x));\n   }\n-  void push_front() { __slist_make_link(&_M_head, _M_create_node());}\n+  void push_front() { __slist_make_link(&this->_M_head, _M_create_node()); }\n   void pop_front() {\n-    _Node* __node = (_Node*) _M_head._M_next;\n-    _M_head._M_next = __node->_M_next;\n+    _Node* __node = (_Node*) this->_M_head._M_next;\n+    this->_M_head._M_next = __node->_M_next;\n     destroy(&__node->_M_data);\n-    _M_put_node(__node);\n+    this->_M_put_node(__node);\n   }\n \n   iterator previous(const_iterator __pos) {\n-    return iterator((_Node*) __slist_previous(&_M_head, __pos._M_node));\n+    return iterator((_Node*) __slist_previous(&this->_M_head, __pos._M_node));\n   }\n   const_iterator previous(const_iterator __pos) const {\n-    return const_iterator((_Node*) __slist_previous(&_M_head, __pos._M_node));\n+    return const_iterator((_Node*) __slist_previous(&this->_M_head,\n+                                                    __pos._M_node));\n   }\n \n private:\n@@ -582,17 +574,20 @@ public:\n #endif /* __STL_MEMBER_TEMPLATES */\n \n   iterator insert(iterator __pos, const value_type& __x) {\n-    return iterator(_M_insert_after(__slist_previous(&_M_head, __pos._M_node),\n+    return iterator(_M_insert_after(__slist_previous(&this->_M_head,\n+                                                     __pos._M_node),\n                     __x));\n   }\n \n   iterator insert(iterator __pos) {\n-    return iterator(_M_insert_after(__slist_previous(&_M_head, __pos._M_node),\n+    return iterator(_M_insert_after(__slist_previous(&this->_M_head,\n+                                                     __pos._M_node),\n                                     value_type()));\n   }\n \n   void insert(iterator __pos, size_type __n, const value_type& __x) {\n-    _M_insert_after_fill(__slist_previous(&_M_head, __pos._M_node), __n, __x);\n+    _M_insert_after_fill(__slist_previous(&this->_M_head, __pos._M_node),\n+                         __n, __x);\n   } \n     \n #ifdef __STL_MEMBER_TEMPLATES\n@@ -601,19 +596,19 @@ public:\n   // already does them.\n   template <class _InIter>\n   void insert(iterator __pos, _InIter __first, _InIter __last) {\n-    _M_insert_after_range(__slist_previous(&_M_head, __pos._M_node), \n+    _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node), \n                           __first, __last);\n   }\n \n #else /* __STL_MEMBER_TEMPLATES */\n \n   void insert(iterator __pos, const_iterator __first, const_iterator __last) {\n-    _M_insert_after_range(__slist_previous(&_M_head, __pos._M_node), \n+    _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node), \n                           __first, __last);\n   }\n   void insert(iterator __pos, const value_type* __first, \n                               const value_type* __last) {\n-    _M_insert_after_range(__slist_previous(&_M_head, __pos._M_node), \n+    _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node), \n                           __first, __last);\n   }\n \n@@ -622,25 +617,25 @@ public:\n \n public:\n   iterator erase_after(iterator __pos) {\n-    return iterator((_Node*) _M_erase_after(__pos._M_node));\n+    return iterator((_Node*) this->_M_erase_after(__pos._M_node));\n   }\n   iterator erase_after(iterator __before_first, iterator __last) {\n-    return iterator((_Node*) _M_erase_after(__before_first._M_node, \n-                                            __last._M_node));\n+    return iterator((_Node*) this->_M_erase_after(__before_first._M_node, \n+                                                  __last._M_node));\n   } \n \n   iterator erase(iterator __pos) {\n-    return (_Node*) _M_erase_after(__slist_previous(&_M_head, \n-                                                    __pos._M_node));\n+    return (_Node*) this->_M_erase_after(__slist_previous(&this->_M_head, \n+                                                          __pos._M_node));\n   }\n   iterator erase(iterator __first, iterator __last) {\n-    return (_Node*) _M_erase_after(\n-      __slist_previous(&_M_head, __first._M_node), __last._M_node);\n+    return (_Node*) this->_M_erase_after(\n+      __slist_previous(&this->_M_head, __first._M_node), __last._M_node);\n   }\n \n   void resize(size_type new_size, const _Tp& __x);\n   void resize(size_type new_size) { resize(new_size, _Tp()); }\n-  void clear() { _M_erase_after(&_M_head, 0); }\n+  void clear() { this->_M_erase_after(&this->_M_head, 0); }\n \n public:\n   // Moves the range [__before_first + 1, __before_last + 1) to *this,\n@@ -673,13 +668,13 @@ public:\n   // Linear in distance(begin(), __pos), and linear in __x.size().\n   void splice(iterator __pos, slist& __x) {\n     if (__x._M_head._M_next)\n-      __slist_splice_after(__slist_previous(&_M_head, __pos._M_node),\n+      __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),\n                            &__x._M_head, __slist_previous(&__x._M_head, 0));\n   }\n \n   // Linear in distance(begin(), __pos), and in distance(__x.begin(), __i).\n   void splice(iterator __pos, slist& __x, iterator __i) {\n-    __slist_splice_after(__slist_previous(&_M_head, __pos._M_node),\n+    __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),\n                          __slist_previous(&__x._M_head, __i._M_node),\n                          __i._M_node);\n   }\n@@ -689,15 +684,15 @@ public:\n   void splice(iterator __pos, slist& __x, iterator __first, iterator __last)\n   {\n     if (__first != __last)\n-      __slist_splice_after(__slist_previous(&_M_head, __pos._M_node),\n+      __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),\n                            __slist_previous(&__x._M_head, __first._M_node),\n                            __slist_previous(__first._M_node, __last._M_node));\n   }\n \n public:\n   void reverse() { \n-    if (_M_head._M_next)\n-      _M_head._M_next = __slist_reverse(_M_head._M_next);\n+    if (this->_M_head._M_next)\n+      this->_M_head._M_next = __slist_reverse(this->_M_head._M_next);\n   }\n \n   void remove(const _Tp& __val); \n@@ -724,8 +719,8 @@ template <class _Tp, class _Alloc>\n slist<_Tp,_Alloc>& slist<_Tp,_Alloc>::operator=(const slist<_Tp,_Alloc>& __x)\n {\n   if (&__x != this) {\n-    _Node_base* __p1 = &_M_head;\n-    _Node* __n1 = (_Node*) _M_head._M_next;\n+    _Node_base* __p1 = &this->_M_head;\n+    _Node* __n1 = (_Node*) this->_M_head._M_next;\n     const _Node* __n2 = (const _Node*) __x._M_head._M_next;\n     while (__n1 && __n2) {\n       __n1->_M_data = __n2->_M_data;\n@@ -734,7 +729,7 @@ slist<_Tp,_Alloc>& slist<_Tp,_Alloc>::operator=(const slist<_Tp,_Alloc>& __x)\n       __n2 = (const _Node*) __n2->_M_next;\n     }\n     if (__n2 == 0)\n-      _M_erase_after(__p1, 0);\n+      this->_M_erase_after(__p1, 0);\n     else\n       _M_insert_after_range(__p1, const_iterator((_Node*)__n2), \n                                   const_iterator(0));\n@@ -744,8 +739,8 @@ slist<_Tp,_Alloc>& slist<_Tp,_Alloc>::operator=(const slist<_Tp,_Alloc>& __x)\n \n template <class _Tp, class _Alloc>\n void slist<_Tp, _Alloc>::_M_fill_assign(size_type __n, const _Tp& __val) {\n-  _Node_base* __prev = &_M_head;\n-  _Node* __node = (_Node*) _M_head._M_next;\n+  _Node_base* __prev = &this->_M_head;\n+  _Node* __node = (_Node*) this->_M_head._M_next;\n   for ( ; __node != 0 && __n > 0 ; --__n) {\n     __node->_M_data = __val;\n     __prev = __node;\n@@ -754,18 +749,18 @@ void slist<_Tp, _Alloc>::_M_fill_assign(size_type __n, const _Tp& __val) {\n   if (__n > 0)\n     _M_insert_after_fill(__prev, __n, __val);\n   else\n-    _M_erase_after(__prev, 0);\n+    this->_M_erase_after(__prev, 0);\n }\n \n #ifdef __STL_MEMBER_TEMPLATES\n \n template <class _Tp, class _Alloc> template <class _InputIter>\n void\n slist<_Tp, _Alloc>::_M_assign_dispatch(_InputIter __first, _InputIter __last,\n-                                      __false_type)\n+                                       __false_type)\n {\n-  _Node_base* __prev = &_M_head;\n-  _Node* __node = (_Node*) _M_head._M_next;\n+  _Node_base* __prev = &this->_M_head;\n+  _Node* __node = (_Node*) this->_M_head._M_next;\n   while (__node != 0 && __first != __last) {\n     __node->_M_data = *__first;\n     __prev = __node;\n@@ -775,7 +770,7 @@ slist<_Tp, _Alloc>::_M_assign_dispatch(_InputIter __first, _InputIter __last,\n   if (__first != __last)\n     _M_insert_after_range(__prev, __first, __last);\n   else\n-    _M_erase_after(__prev, 0);\n+    this->_M_erase_after(__prev, 0);\n }\n \n #endif /* __STL_MEMBER_TEMPLATES */\n@@ -784,26 +779,54 @@ template <class _Tp, class _Alloc>\n inline bool \n operator==(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2)\n {\n-  typedef typename slist<_Tp,_Alloc>::_Node _Node;\n-  _Node* __n1 = (_Node*) _SL1._M_head._M_next;\n-  _Node* __n2 = (_Node*) _SL2._M_head._M_next;\n-  while (__n1 && __n2 && __n1->_M_data == __n2->_M_data) {\n-    __n1 = (_Node*) __n1->_M_next;\n-    __n2 = (_Node*) __n2->_M_next;\n-  }\n-  return __n1 == 0 && __n2 == 0;\n+  typedef typename slist<_Tp,_Alloc>::const_iterator const_iterator;\n+  const_iterator __end1 = _SL1.end();\n+  const_iterator __end2 = _SL2.end();\n+\n+  const_iterator __i1 = _SL1.begin();\n+  const_iterator __i2 = _SL2.begin();\n+  while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) {\n+    ++__i1;\n+    ++__i2;\n+  }\n+  return __i1 == __end1 && __i2 == __end2;\n }\n \n+\n template <class _Tp, class _Alloc>\n-inline bool operator<(const slist<_Tp,_Alloc>& _SL1,\n-                      const slist<_Tp,_Alloc>& _SL2)\n+inline bool\n+operator<(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2)\n {\n   return lexicographical_compare(_SL1.begin(), _SL1.end(), \n                                  _SL2.begin(), _SL2.end());\n }\n \n #ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER\n \n+template <class _Tp, class _Alloc>\n+inline bool \n+operator!=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n+  return !(_SL1 == _SL2);\n+}\n+\n+template <class _Tp, class _Alloc>\n+inline bool \n+operator>(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n+  return _SL2 < _SL1;\n+}\n+\n+template <class _Tp, class _Alloc>\n+inline bool \n+operator<=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n+  return !(_SL2 < _SL1);\n+}\n+\n+template <class _Tp, class _Alloc>\n+inline bool \n+operator>=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {\n+  return !(_SL1 < _SL2);\n+}\n+\n template <class _Tp, class _Alloc>\n inline void swap(slist<_Tp,_Alloc>& __x, slist<_Tp,_Alloc>& __y) {\n   __x.swap(__y);\n@@ -815,24 +838,24 @@ inline void swap(slist<_Tp,_Alloc>& __x, slist<_Tp,_Alloc>& __y) {\n template <class _Tp, class _Alloc>\n void slist<_Tp,_Alloc>::resize(size_type __len, const _Tp& __x)\n {\n-  _Node_base* __cur = &_M_head;\n+  _Node_base* __cur = &this->_M_head;\n   while (__cur->_M_next != 0 && __len > 0) {\n     --__len;\n     __cur = __cur->_M_next;\n   }\n   if (__cur->_M_next) \n-    _M_erase_after(__cur, 0);\n+    this->_M_erase_after(__cur, 0);\n   else\n     _M_insert_after_fill(__cur, __len, __x);\n }\n \n template <class _Tp, class _Alloc>\n void slist<_Tp,_Alloc>::remove(const _Tp& __val)\n {\n-  _Node_base* __cur = &_M_head;\n+  _Node_base* __cur = &this->_M_head;\n   while (__cur && __cur->_M_next) {\n     if (((_Node*) __cur->_M_next)->_M_data == __val)\n-      _M_erase_after(__cur);\n+      this->_M_erase_after(__cur);\n     else\n       __cur = __cur->_M_next;\n   }\n@@ -841,12 +864,12 @@ void slist<_Tp,_Alloc>::remove(const _Tp& __val)\n template <class _Tp, class _Alloc> \n void slist<_Tp,_Alloc>::unique()\n {\n-  _Node_base* __cur = _M_head._M_next;\n+  _Node_base* __cur = this->_M_head._M_next;\n   if (__cur) {\n     while (__cur->_M_next) {\n       if (((_Node*)__cur)->_M_data == \n           ((_Node*)(__cur->_M_next))->_M_data)\n-        _M_erase_after(__cur);\n+        this->_M_erase_after(__cur);\n       else\n         __cur = __cur->_M_next;\n     }\n@@ -856,7 +879,7 @@ void slist<_Tp,_Alloc>::unique()\n template <class _Tp, class _Alloc>\n void slist<_Tp,_Alloc>::merge(slist<_Tp,_Alloc>& __x)\n {\n-  _Node_base* __n1 = &_M_head;\n+  _Node_base* __n1 = &this->_M_head;\n   while (__n1->_M_next && __x._M_head._M_next) {\n     if (((_Node*) __x._M_head._M_next)->_M_data < \n         ((_Node*)       __n1->_M_next)->_M_data) \n@@ -872,12 +895,13 @@ void slist<_Tp,_Alloc>::merge(slist<_Tp,_Alloc>& __x)\n template <class _Tp, class _Alloc>\n void slist<_Tp,_Alloc>::sort()\n {\n-  if (_M_head._M_next && _M_head._M_next->_M_next) {\n+  if (this->_M_head._M_next && this->_M_head._M_next->_M_next) {\n     slist __carry;\n     slist __counter[64];\n     int __fill = 0;\n     while (!empty()) {\n-      __slist_splice_after(&__carry._M_head, &_M_head, _M_head._M_next);\n+      __slist_splice_after(&__carry._M_head,\n+                           &this->_M_head, this->_M_head._M_next);\n       int __i = 0;\n       while (__i < __fill && !__counter[__i].empty()) {\n         __counter[__i].merge(__carry);\n@@ -901,10 +925,10 @@ template <class _Tp, class _Alloc>\n template <class _Predicate>\n void slist<_Tp,_Alloc>::remove_if(_Predicate __pred)\n {\n-  _Node_base* __cur = &_M_head;\n+  _Node_base* __cur = &this->_M_head;\n   while (__cur->_M_next) {\n     if (__pred(((_Node*) __cur->_M_next)->_M_data))\n-      _M_erase_after(__cur);\n+      this->_M_erase_after(__cur);\n     else\n       __cur = __cur->_M_next;\n   }\n@@ -913,12 +937,12 @@ void slist<_Tp,_Alloc>::remove_if(_Predicate __pred)\n template <class _Tp, class _Alloc> template <class _BinaryPredicate> \n void slist<_Tp,_Alloc>::unique(_BinaryPredicate __pred)\n {\n-  _Node* __cur = (_Node*) _M_head._M_next;\n+  _Node* __cur = (_Node*) this->_M_head._M_next;\n   if (__cur) {\n     while (__cur->_M_next) {\n       if (__pred(((_Node*)__cur)->_M_data, \n                  ((_Node*)(__cur->_M_next))->_M_data))\n-        _M_erase_after(__cur);\n+        this->_M_erase_after(__cur);\n       else\n         __cur = (_Node*) __cur->_M_next;\n     }\n@@ -927,9 +951,9 @@ void slist<_Tp,_Alloc>::unique(_BinaryPredicate __pred)\n \n template <class _Tp, class _Alloc> template <class _StrictWeakOrdering>\n void slist<_Tp,_Alloc>::merge(slist<_Tp,_Alloc>& __x,\n-                             _StrictWeakOrdering __comp)\n+                              _StrictWeakOrdering __comp)\n {\n-  _Node_base* __n1 = &_M_head;\n+  _Node_base* __n1 = &this->_M_head;\n   while (__n1->_M_next && __x._M_head._M_next) {\n     if (__comp(((_Node*) __x._M_head._M_next)->_M_data,\n                ((_Node*)       __n1->_M_next)->_M_data))\n@@ -945,12 +969,13 @@ void slist<_Tp,_Alloc>::merge(slist<_Tp,_Alloc>& __x,\n template <class _Tp, class _Alloc> template <class _StrictWeakOrdering> \n void slist<_Tp,_Alloc>::sort(_StrictWeakOrdering __comp)\n {\n-  if (_M_head._M_next && _M_head._M_next->_M_next) {\n+  if (this->_M_head._M_next && this->_M_head._M_next->_M_next) {\n     slist __carry;\n     slist __counter[64];\n     int __fill = 0;\n     while (!empty()) {\n-      __slist_splice_after(&__carry._M_head, &_M_head, _M_head._M_next);\n+      __slist_splice_after(&__carry._M_head,\n+                           &this->_M_head, this->_M_head._M_next);\n       int __i = 0;\n       while (__i < __fill && !__counter[__i].empty()) {\n         __counter[__i].merge(__carry, __comp);\n@@ -1016,7 +1041,7 @@ public:\n \n __STL_END_NAMESPACE \n \n-#endif /* _CPP_BITS_STL_SLIST_H */\n+#endif /* __SGI_STL_INTERNAL_SLIST_H */\n \n // Local Variables:\n // mode:C++"}, {"sha": "5e64f3889c85eb0ca1f0a5e875d3410bf146b35e", "filename": "libstdc++-v3/ext/stl_bvector.h", "status": "modified", "additions": 149, "deletions": 145, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fext%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fext%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fstl_bvector.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -12,7 +12,7 @@\n  * purpose.  It is provided \"as is\" without express or implied warranty.\n  *\n  *\n- * Copyright (c) 1996,1997\n+ * Copyright (c) 1996-1999\n  * Silicon Graphics Computer Systems, Inc.\n  *\n  * Permission to use, copy, modify, distribute and sell this software\n@@ -72,57 +72,95 @@ inline void swap(_Bit_reference __x, _Bit_reference __y)\n   __y = __tmp;\n }\n \n-struct _Bit_iterator : public random_access_iterator<bool, ptrdiff_t> {\n-  typedef _Bit_reference  reference;\n-  typedef _Bit_reference* pointer;\n-  typedef _Bit_iterator   iterator;\n-\n+struct _Bit_iterator_base : public random_access_iterator<bool, ptrdiff_t> \n+{\n   unsigned int* _M_p;\n   unsigned int _M_offset;\n-  void bump_up() {\n+\n+  _Bit_iterator_base(unsigned int* __x, unsigned int __y)\n+    : _M_p(__x), _M_offset(__y) {}\n+\n+  void _M_bump_up() {\n     if (_M_offset++ == __WORD_BIT - 1) {\n       _M_offset = 0;\n       ++_M_p;\n     }\n   }\n-  void bump_down() {\n+  void _M_bump_down() {\n     if (_M_offset-- == 0) {\n       _M_offset = __WORD_BIT - 1;\n       --_M_p;\n     }\n   }\n \n-  _Bit_iterator() : _M_p(0), _M_offset(0) {}\n+  void _M_incr(ptrdiff_t __i) {\n+    difference_type __n = __i + _M_offset;\n+    _M_p += __n / __WORD_BIT;\n+    __n = __n % __WORD_BIT;\n+    if (__n < 0) {\n+      _M_offset = (unsigned int) __n + __WORD_BIT;\n+      --_M_p;\n+    } else\n+      _M_offset = (unsigned int) __n;\n+  }\n+\n+  bool operator==(const _Bit_iterator_base& __i) const {\n+    return _M_p == __i._M_p && _M_offset == __i._M_offset;\n+  }\n+  bool operator<(const _Bit_iterator_base& __i) const {\n+    return _M_p < __i._M_p || (_M_p == __i._M_p && _M_offset < __i._M_offset);\n+  }\n+  bool operator!=(const _Bit_iterator_base& __i) const {\n+    return !(*this == __i);\n+  }\n+  bool operator>(const _Bit_iterator_base& __i) const {\n+    return __i < *this;\n+  }\n+  bool operator<=(const _Bit_iterator_base& __i) const {\n+    return !(__i < *this); \n+  }\n+  bool operator>=(const _Bit_iterator_base& __i) const {\n+    return !(*this < __i);\n+  }\n+};\n+\n+inline ptrdiff_t\n+operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {\n+  return __WORD_BIT * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset;\n+}\n+\n+\n+struct _Bit_iterator : public _Bit_iterator_base\n+{\n+  typedef _Bit_reference  reference;\n+  typedef _Bit_reference* pointer;\n+  typedef _Bit_iterator   iterator;\n+\n+  _Bit_iterator() : _Bit_iterator_base(0, 0) {}\n   _Bit_iterator(unsigned int* __x, unsigned int __y) \n-    : _M_p(__x), _M_offset(__y) {}\n+    : _Bit_iterator_base(__x, __y) {}\n+\n   reference operator*() const { return reference(_M_p, 1U << _M_offset); }\n   iterator& operator++() {\n-    bump_up();\n+    _M_bump_up();\n     return *this;\n   }\n   iterator operator++(int) {\n     iterator __tmp = *this;\n-    bump_up();\n+    _M_bump_up();\n     return __tmp;\n   }\n   iterator& operator--() {\n-    bump_down();\n+    _M_bump_down();\n     return *this;\n   }\n   iterator operator--(int) {\n     iterator __tmp = *this;\n-    bump_down();\n+    _M_bump_down();\n     return __tmp;\n   }\n   iterator& operator+=(difference_type __i) {\n-    difference_type __n = __i + _M_offset;\n-    _M_p += __n / __WORD_BIT;\n-    __n = __n % __WORD_BIT;\n-    if (__n < 0) {\n-      _M_offset = (unsigned int) __n + __WORD_BIT;\n-      --_M_p;\n-    } else\n-      _M_offset = (unsigned int) __n;\n+    _M_incr(__i);\n     return *this;\n   }\n   iterator& operator-=(difference_type __i) {\n@@ -137,82 +175,50 @@ struct _Bit_iterator : public random_access_iterator<bool, ptrdiff_t> {\n     iterator __tmp = *this;\n     return __tmp -= __i;\n   }\n-  difference_type operator-(iterator __x) const {\n-    return __WORD_BIT * (_M_p - __x._M_p) + _M_offset - __x._M_offset;\n-  }\n+\n   reference operator[](difference_type __i) { return *(*this + __i); }\n-  bool operator==(const iterator& __x) const {\n-    return _M_p == __x._M_p && _M_offset == __x._M_offset;\n-  }\n-  bool operator!=(const iterator& __x) const {\n-    return _M_p != __x._M_p || _M_offset != __x._M_offset;\n-  }\n-  bool operator<(iterator __x) const {\n-    return _M_p < __x._M_p || (_M_p == __x._M_p && _M_offset < __x._M_offset);\n-  }\n-  bool operator>(const iterator& __x) const  { return __x < *this; }\n-  bool operator<=(const iterator& __x) const { return !(__x < *this); }\n-  bool operator>=(const iterator& __x) const { return !(*this < __x); }\n };\n \n-struct _Bit_const_iterator\n-  : public random_access_iterator<bool, ptrdiff_t>\n+inline _Bit_iterator \n+operator+(ptrdiff_t __n, const _Bit_iterator& __x) { return __x + __n; }\n+\n+\n+struct _Bit_const_iterator : public _Bit_iterator_base\n {\n   typedef bool                 reference;\n   typedef bool                 const_reference;\n   typedef const bool*          pointer;\n   typedef _Bit_const_iterator  const_iterator;\n \n-  unsigned int* _M_p;\n-  unsigned int _M_offset;\n-  void bump_up() {\n-    if (_M_offset++ == __WORD_BIT - 1) {\n-      _M_offset = 0;\n-      ++_M_p;\n-    }\n-  }\n-  void bump_down() {\n-    if (_M_offset-- == 0) {\n-      _M_offset = __WORD_BIT - 1;\n-      --_M_p;\n-    }\n-  }\n-\n-  _Bit_const_iterator() : _M_p(0), _M_offset(0) {}\n+  _Bit_const_iterator() : _Bit_iterator_base(0, 0) {}\n   _Bit_const_iterator(unsigned int* __x, unsigned int __y) \n-    : _M_p(__x), _M_offset(__y) {}\n+    : _Bit_iterator_base(__x, __y) {}\n   _Bit_const_iterator(const _Bit_iterator& __x) \n-    : _M_p(__x._M_p), _M_offset(__x._M_offset) {}\n+    : _Bit_iterator_base(__x._M_p, __x._M_offset) {}\n+\n   const_reference operator*() const {\n     return _Bit_reference(_M_p, 1U << _M_offset);\n   }\n   const_iterator& operator++() {\n-    bump_up();\n+    _M_bump_up();\n     return *this;\n   }\n   const_iterator operator++(int) {\n     const_iterator __tmp = *this;\n-    bump_up();\n+    _M_bump_up();\n     return __tmp;\n   }\n   const_iterator& operator--() {\n-    bump_down();\n+    _M_bump_down();\n     return *this;\n   }\n   const_iterator operator--(int) {\n     const_iterator __tmp = *this;\n-    bump_down();\n+    _M_bump_down();\n     return __tmp;\n   }\n   const_iterator& operator+=(difference_type __i) {\n-    difference_type __n = __i + _M_offset;\n-    _M_p += __n / __WORD_BIT;\n-    __n = __n % __WORD_BIT;\n-    if (__n < 0) {\n-      _M_offset = (unsigned int) __n + __WORD_BIT;\n-      --_M_p;\n-    } else\n-      _M_offset = (unsigned int) __n;\n+    _M_incr(__i);\n     return *this;\n   }\n   const_iterator& operator-=(difference_type __i) {\n@@ -227,28 +233,17 @@ struct _Bit_const_iterator\n     const_iterator __tmp = *this;\n     return __tmp -= __i;\n   }\n-  difference_type operator-(const_iterator __x) const {\n-    return __WORD_BIT * (_M_p - __x._M_p) + _M_offset - __x._M_offset;\n-  }\n   const_reference operator[](difference_type __i) { \n     return *(*this + __i); \n   }\n-  bool operator==(const const_iterator& __x) const {\n-    return _M_p == __x._M_p && _M_offset == __x._M_offset;\n-  }\n-  bool operator!=(const const_iterator& __x) const {\n-    return _M_p != __x._M_p || _M_offset != __x._M_offset;\n-  }\n-  bool operator<(const_iterator __x) const {\n-    return _M_p < __x._M_p || (_M_p == __x._M_p && _M_offset < __x._M_offset);\n-  }\n-  bool operator>(const const_iterator& __x) const  { return __x < *this; }\n-  bool operator<=(const const_iterator& __x) const { return !(__x < *this); }\n-  bool operator>=(const const_iterator& __x) const { return !(*this < __x); }\n };\n \n+inline _Bit_const_iterator \n+operator+(ptrdiff_t __n, const _Bit_const_iterator& __x) { return __x + __n; }\n+\n+\n // Bit-vector base class, which encapsulates the difference between\n-//  old SGI-style allocators and standard-conforming allocators.\n+// old SGI-style allocators and standard-conforming allocators.\n \n #ifdef __STL_USE_STD_ALLOCATORS\n \n@@ -359,29 +354,26 @@ class _Bvector_base\n //  the default allocator. \n \n #if defined(__STL_CLASS_PARTIAL_SPECIALIZATION) && !defined(__STL_NO_BOOL)\n-#define __SGI_STL_VECBOOL_TEMPLATE\n-#define __BVECTOR vector\n-#else\n-#undef __SGI_STL_VECBOOL_TEMPLATE\n-#define __BVECTOR bit_vector\n-#endif\n-\n-#      ifdef __SGI_STL_VECBOOL_TEMPLATE\n-       __STL_END_NAMESPACE\n-#      include <bits/stl_vector.h>\n-       __STL_BEGIN_NAMESPACE\n-template<class _Alloc> class vector<bool,_Alloc>\n-  : public _Bvector_base<_Alloc>\n-#      else /* __SGI_STL_VECBOOL_TEMPLATE */\n-class bit_vector\n-  : public _Bvector_base<allocator<bool> >\n-#      endif /* __SGI_STL_VECBOOL_TEMPLATE */\n+#  define __SGI_STL_VECBOOL_TEMPLATE\n+#  define __BVECTOR           vector<bool, _Alloc>\n+#  define __VECTOR            vector\n+#  define __BVECTOR_BASE      _Bvector_base<_Alloc>\n+#  define __BVECTOR_TMPL_LIST template <class _Alloc>\n+   __STL_END_NAMESPACE\n+#  include <bits/stl_vector.h>\n+   __STL_BEGIN_NAMESPACE\n+#else  /* __STL_CLASS_PARTIAL_SPECIALIZATION && !__STL_NO_BOOL */\n+#  undef  __SGI_STL_VECBOOL_TEMPLATE\n+#  define __BVECTOR           bit_vector\n+#  define __VECTOR            bit_vector\n+#  define __BVECTOR_BASE      _Bvector_base<__STL_DEFAULT_ALLOCATOR(bool) >\n+#  define __BVECTOR_TMPL_LIST\n+#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION && !__STL_NO_BOOL */\n+\n+\n+__BVECTOR_TMPL_LIST \n+class __BVECTOR : public __BVECTOR_BASE \n {\n-#      ifdef __SGI_STL_VECBOOL_TEMPLATE\n-  typedef _Bvector_base<_Alloc> _Base;\n-#      else /* __SGI_STL_VECBOOL_TEMPLATE */\n-  typedef _Bvector_base<allocator<bool> > _Base;\n-#      endif /* __SGI_STL_VECBOOL_TEMPLATE */\n public:\n   typedef bool value_type;\n   typedef size_t size_type;\n@@ -404,16 +396,18 @@ class bit_vector\n           reverse_iterator;\n #endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */\n \n-  typedef typename _Base::allocator_type allocator_type;\n-  allocator_type get_allocator() const { return _Base::get_allocator(); }\n+  typedef typename __BVECTOR_BASE::allocator_type allocator_type;\n+  allocator_type get_allocator() const {\n+    return __BVECTOR_BASE::get_allocator();\n+  }\n \n protected:\n #ifdef __STL_USE_NAMESPACES  \n-  using _Base::_M_bit_alloc;\n-  using _Base::_M_deallocate;\n-  using _Base::_M_start;\n-  using _Base::_M_finish;\n-  using _Base::_M_end_of_storage;\n+  using __BVECTOR_BASE::_M_bit_alloc;\n+  using __BVECTOR_BASE::_M_deallocate;\n+  using __BVECTOR_BASE::_M_start;\n+  using __BVECTOR_BASE::_M_finish;\n+  using __BVECTOR_BASE::_M_end_of_storage;\n #endif /* __STL_USE_NAMESPACES */\n \n protected:\n@@ -537,75 +531,80 @@ class bit_vector\n     { _M_range_check(__n); return (*this)[__n]; }\n #endif /* __STL_THROW_RANGE_ERRORS */\n \n-  explicit __BVECTOR(const allocator_type& __a = allocator_type())\n-    : _Base(__a) {}\n+  explicit __VECTOR(const allocator_type& __a = allocator_type())\n+    : __BVECTOR_BASE(__a) {}\n \n-  __BVECTOR(size_type __n, bool __value,\n+  __VECTOR(size_type __n, bool __value,\n             const allocator_type& __a = allocator_type())\n-    : _Base(__a)\n+    : __BVECTOR_BASE(__a)\n   {\n     _M_initialize(__n);\n     fill(_M_start._M_p, _M_end_of_storage, __value ? ~0 : 0);\n   }\n \n-  explicit __BVECTOR(size_type __n)\n-    : _Base(allocator_type())\n+  explicit __VECTOR(size_type __n)\n+    : __BVECTOR_BASE(allocator_type())\n   {\n     _M_initialize(__n);\n     fill(_M_start._M_p, _M_end_of_storage, 0);\n   }\n \n-  __BVECTOR(const __BVECTOR& __x) : _Base(__x.get_allocator()) {\n+  __VECTOR(const __VECTOR& __x) : __BVECTOR_BASE(__x.get_allocator()) {\n     _M_initialize(__x.size());\n     copy(__x.begin(), __x.end(), _M_start);\n   }\n \n #ifdef __STL_MEMBER_TEMPLATES\n+\n   // Check whether it's an integral type.  If so, it's not an iterator.\n-  template <class _InputIterator>\n-  __BVECTOR(_InputIterator __first, _InputIterator __last,\n-            const allocator_type& __a = allocator_type())\n-    : _Base(__a)\n-  {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_initialize_dispatch(__first, __last, _Integral());\n-  }\n-    \n+\n   template <class _Integer>\n   void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) {\n     _M_initialize(__n);\n     fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n   }\n-    \n+\n   template <class _InputIterator>\n   void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n                               __false_type) {\n     _M_initialize_range(__first, __last, __ITERATOR_CATEGORY(__first));\n   }\n+\n+  template <class _InputIterator>\n+  __VECTOR(_InputIterator __first, _InputIterator __last,\n+           const allocator_type& __a = allocator_type())\n+    : __BVECTOR_BASE(__a)\n+  {\n+    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+    _M_initialize_dispatch(__first, __last, _Integral());\n+  }\n+    \n #else /* __STL_MEMBER_TEMPLATES */\n-  __BVECTOR(const_iterator __first, const_iterator __last,\n-            const allocator_type& __a = allocator_type())\n-    : _Base(__a)\n+\n+  __VECTOR(const_iterator __first, const_iterator __last,\n+           const allocator_type& __a = allocator_type())\n+    : __BVECTOR_BASE(__a)\n   {\n     size_type __n = 0;\n     distance(__first, __last, __n);\n     _M_initialize(__n);\n     copy(__first, __last, _M_start);\n   }\n-  __BVECTOR(const bool* __first, const bool* __last,\n-            const allocator_type& __a = allocator_type())\n-    : _Base(__a)\n+  __VECTOR(const bool* __first, const bool* __last,\n+           const allocator_type& __a = allocator_type())\n+    : __BVECTOR_BASE(__a)\n   {\n     size_type __n = 0;\n     distance(__first, __last, __n);\n     _M_initialize(__n);\n     copy(__first, __last, _M_start);\n   }\n+\n #endif /* __STL_MEMBER_TEMPLATES */\n \n-  ~__BVECTOR() { }\n+  ~__VECTOR() { }\n \n-  __BVECTOR& operator=(const __BVECTOR& __x) {\n+  __VECTOR& operator=(const __VECTOR& __x) {\n     if (&__x == this) return *this;\n     if (__x.size() > capacity()) {\n       _M_deallocate();\n@@ -715,12 +714,6 @@ class bit_vector\n \n #ifdef __STL_MEMBER_TEMPLATES\n   // Check whether it's an integral type.  If so, it's not an iterator.\n-  template <class _InputIterator>\n-  void insert(iterator __position,\n-              _InputIterator __first, _InputIterator __last) {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_insert_dispatch(__position, __first, __last, _Integral());\n-  }\n \n   template <class _Integer>\n   void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n@@ -734,6 +727,14 @@ class bit_vector\n                           __false_type) {\n     _M_insert_range(__pos, __first, __last, __ITERATOR_CATEGORY(__first));\n   }\n+\n+  template <class _InputIterator>\n+  void insert(iterator __position,\n+              _InputIterator __first, _InputIterator __last) {\n+    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+    _M_insert_dispatch(__position, __first, __last, _Integral());\n+  }\n+\n #else /* __STL_MEMBER_TEMPLATES */\n   void insert(iterator __position,\n               const_iterator __first, const_iterator __last) {\n@@ -877,6 +878,9 @@ inline bool operator>=(const bit_vector& __x, const bit_vector& __y)\n \n #undef __SGI_STL_VECBOOL_TEMPLATE\n #undef __BVECTOR\n+#undef __VECTOR\n+#undef __BVECTOR_BASE\n+#undef __BVECTOR_TMPL_LIST \n \n #if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)\n #pragma reset woff 1174"}, {"sha": "f317f3a6fbcc77f08769edfa8e25e537e48387f2", "filename": "libstdc++-v3/ext/stl_rope.h", "status": "modified", "additions": 47, "deletions": 43, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fext%2Fstl_rope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fext%2Fstl_rope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fext%2Fstl_rope.h?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -208,7 +208,7 @@ class _Rope_char_consumer {\n // First a lot of forward declarations.  The standard seems to require\n // much stricter \"declaration before use\" than many of the implementations\n // that preceded it.\n-template<class _CharT, class _Alloc=allocator<_CharT> > class rope;\n+template<class _CharT, class _Alloc=__STL_DEFAULT_ALLOCATOR(_CharT)> class rope;\n template<class _CharT, class _Alloc> struct _Rope_RopeConcatenation;\n template<class _CharT, class _Alloc> struct _Rope_RopeLeaf;\n template<class _CharT, class _Alloc> struct _Rope_RopeFunction;\n@@ -304,7 +304,7 @@ struct _Rope_Concat_fn\n        : public binary_function<rope<_CharT,_Alloc>, rope<_CharT,_Alloc>,\n                                      rope<_CharT,_Alloc> > {\n         rope<_CharT,_Alloc> operator() (const rope<_CharT,_Alloc>& __x,\n-\t\t\t\tconst rope<_CharT,_Alloc>& __y) {\n+                                const rope<_CharT,_Alloc>& __y) {\n                     return __x + __y;\n         }\n };\n@@ -492,14 +492,14 @@ struct _Rope_RopeRep : public _Rope_rep_base<_CharT,_Alloc>\n                         /* In the case of a leaf, this may point to */\n                         /* the same memory as the data field.       */\n     typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n-\t\t\tallocator_type;\n+                        allocator_type;\n     _Rope_RopeRep(_Tag __t, int __d, bool __b, size_t __size,\n                   allocator_type __a)\n-        : _Rope_rep_base<_CharT,_Alloc>(__size, __a)\n+        : _Rope_rep_base<_CharT,_Alloc>(__size, __a),\n #         ifndef __GC\n-\t  , _Refcount_Base(1),\n-#\t  endif\n-\t    _M_tag(__t), _M_depth(__d), _M_is_balanced(__b), _M_c_string(0)\n+          _Refcount_Base(1),\n+#         endif\n+          _M_tag(__t), _M_is_balanced(__b), _M_depth(__d), _M_c_string(0)\n     { }\n #   ifdef __GC\n         void _M_incr () {}\n@@ -584,10 +584,10 @@ struct _Rope_RopeLeaf : public _Rope_RopeRep<_CharT,_Alloc> {\n                                 /* in the GC case, in which it   */\n                                 /* doesn't matter.               */\n     typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n-\t\t\tallocator_type;\n+                        allocator_type;\n     _Rope_RopeLeaf(__GC_CONST _CharT* __d, size_t __size, allocator_type __a)\n         : _Rope_RopeRep<_CharT,_Alloc>(_S_leaf, 0, true, __size, __a),\n-\t  _M_data(__d)\n+          _M_data(__d)\n         {\n         __stl_assert(__size > 0);\n         if (_S_is_basic_char_type((_CharT *)0)) {\n@@ -614,14 +614,16 @@ struct _Rope_RopeConcatenation : public _Rope_RopeRep<_CharT,_Alloc> {\n     _Rope_RopeRep<_CharT,_Alloc>* _M_left;\n     _Rope_RopeRep<_CharT,_Alloc>* _M_right;\n     typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n-\t\t\tallocator_type;\n+                        allocator_type;\n     _Rope_RopeConcatenation(_Rope_RopeRep<_CharT,_Alloc>* __l,\n                              _Rope_RopeRep<_CharT,_Alloc>* __r,\n                              allocator_type __a)\n-      : _Rope_RopeRep<_CharT,_Alloc>(\n-          _S_concat, max(__l->_M_depth, __r->_M_depth) + 1, false,\n-          __l->_M_size + __r->_M_size, __a),\n-      _M_left(__l), _M_right(__r)\n+\n+      : _Rope_RopeRep<_CharT,_Alloc>(_S_concat,\n+                                     max(__l->_M_depth, __r->_M_depth) + 1,\n+                                     false,\n+                                     __l->_M_size + __r->_M_size, __a),\n+        _M_left(__l), _M_right(__r)\n       {}\n # ifndef __GC\n     ~_Rope_RopeConcatenation() {\n@@ -652,15 +654,15 @@ struct _Rope_RopeFunction : public _Rope_RopeRep<_CharT,_Alloc> {\n       }\n #   endif\n     typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n-\t\t\t\t\tallocator_type;\n+                                        allocator_type;\n     _Rope_RopeFunction(char_producer<_CharT>* __f, size_t __size,\n                         bool __d, allocator_type __a)\n-      :_Rope_RopeRep<_CharT,_Alloc>(_S_function, 0, true, __size, __a), \n-       _M_fn(__f)\n+      : _Rope_RopeRep<_CharT,_Alloc>(_S_function, 0, true, __size, __a)\n+      , _M_fn(__f)\n #       ifndef __GC\n       , _M_delete_when_done(__d)\n #       endif\n-          {\n+    {\n         __stl_assert(__size > 0);\n #       ifdef __GC\n             if (__d) {\n@@ -718,11 +720,13 @@ struct _Rope_RopeSubstring : public _Rope_RopeFunction<_CharT,_Alloc>,\n         }\n     }\n     typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n-\tallocator_type;\n+        allocator_type;\n     _Rope_RopeSubstring(_Rope_RopeRep<_CharT,_Alloc>* __b, size_t __s,\n                           size_t __l, allocator_type __a)\n-      : _Rope_RopeFunction<_CharT,_Alloc>(this, __l, false, __a), _M_base(__b)\n-      , _M_start(__s)\n+      : _Rope_RopeFunction<_CharT,_Alloc>(this, __l, false, __a),\n+        char_producer<_CharT>(),\n+        _M_base(__b),\n+        _M_start(__s)\n     {\n         __stl_assert(__l > 0);\n         __stl_assert(__s + __l <= __b->_M_size);\n@@ -792,17 +796,16 @@ class _Rope_char_ref_proxy {\n     bool _M_current_valid;\n     _My_rope* _M_root;     // The whole rope.\n   public:\n-    _Rope_char_ref_proxy(_My_rope* __r, size_t __p) :\n-        _M_pos(__p), _M_current_valid(false), _M_root(__r) {}\n-    _Rope_char_ref_proxy(const _Rope_char_ref_proxy& __x) :\n-        _M_pos(__x._M_pos), _M_current_valid(false), _M_root(__x._M_root) {}\n+    _Rope_char_ref_proxy(_My_rope* __r, size_t __p)\n+      :  _M_pos(__p), _M_current_valid(false), _M_root(__r) {}\n+    _Rope_char_ref_proxy(const _Rope_char_ref_proxy& __x)\n+      : _M_pos(__x._M_pos), _M_current_valid(false), _M_root(__x._M_root) {}\n         // Don't preserve cache if the reference can outlive the\n         // expression.  We claim that's not possible without calling\n         // a copy constructor or generating reference to a proxy\n         // reference.  We declare the latter to have undefined semantics.\n-    _Rope_char_ref_proxy(_My_rope* __r, size_t __p,\n-                    _CharT __c) :\n-        _M_pos(__p), _M_current(__c), _M_current_valid(true), _M_root(__r) {}\n+    _Rope_char_ref_proxy(_My_rope* __r, size_t __p, _CharT __c)\n+      : _M_pos(__p), _M_current(__c), _M_current_valid(true), _M_root(__r) {}\n     inline operator _CharT () const;\n     _Rope_char_ref_proxy& operator= (_CharT __c);\n     _Rope_char_ptr_proxy<_CharT,_Alloc> operator& () const;\n@@ -834,7 +837,7 @@ class _Rope_char_ref_proxy {\n         __b = __tmp; \\\n     }\n \n-_ROPE_SWAP_SPECIALIZATION(char,allocator<char>)\n+_ROPE_SWAP_SPECIALIZATION(char,__STL_DEFAULT_ALLOCATOR(char))\n \n #endif /* !__STL_FUNCTION_TMPL_PARTIAL_ORDER */\n \n@@ -892,6 +895,7 @@ class _Rope_iterator_base\n   : public random_access_iterator<_CharT, ptrdiff_t> {\n     friend class rope<_CharT,_Alloc>;\n   public:\n+    typedef _Alloc _allocator_type; // used in _Rope_rotate, VC++ workaround\n     typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;\n         // Borland doesnt want this to be protected.\n   protected:\n@@ -940,7 +944,7 @@ class _Rope_iterator_base\n                                         // cache is valid for previous posn.\n     _Rope_iterator_base() {}\n     _Rope_iterator_base(_RopeRep* __root, size_t __pos)\n-      : _M_root(__root), _M_current_pos(__pos), _M_buf_ptr(0) {}\n+      : _M_current_pos(__pos), _M_root(__root), _M_buf_ptr(0) {}\n     void _M_incr(size_t __n);\n     void _M_decr(size_t __n);\n   public:\n@@ -1111,7 +1115,7 @@ class _Rope_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n     _Rope_iterator(rope<_CharT,_Alloc>* __r, size_t __pos)\n       : _Rope_iterator_base<_CharT,_Alloc>(__r->_M_tree_ptr, __pos),\n         _M_root_rope(__r) \n-      { _RopeRep::_S_ref(_M_root); }\n+       { _RopeRep::_S_ref(_M_root); if (!(__r -> empty()))_S_setcache(*this); }\n \n     void _M_check();\n   public:\n@@ -1323,7 +1327,7 @@ struct _Rope_base\n           _Base;\n   typedef typename _Base::allocator_type allocator_type;\n   typedef _Rope_RopeRep<_CharT,_Alloc> _RopeRep;\n-\t// The one in _Base may not be visible due to template rules.\n+        // The one in _Base may not be visible due to template rules.\n   _Rope_base(_RopeRep* __t, const allocator_type& __a) : _Base(__t, __a) {}\n   _Rope_base(const allocator_type& __a) : _Base(__a) {}\n };    \n@@ -1586,7 +1590,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n           // A version that potentially clobbers __r if __r->_M_ref_count == 1.\n #       endif\n \n-\tprivate:\n+        private:\n \n         static size_t _S_char_ptr_len(const _CharT* __s);\n                         // slightly generalized strlen\n@@ -1740,10 +1744,10 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         }\n \n         void clear()\n-\t{\n-\t    _S_unref(_M_tree_ptr);\n-\t    _M_tree_ptr = 0;\n-\t}\n+        {\n+            _S_unref(_M_tree_ptr);\n+            _M_tree_ptr = 0;\n+        }\n \n         void push_back(_CharT __x)\n         {\n@@ -2060,9 +2064,9 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n             _Self_destruct_ptr __right(_S_substring(_M_tree_ptr, __p, size()));\n             _Self_destruct_ptr __left_result(\n               _S_concat_char_iter(__left, __i, __n));\n-\t\t// _S_ destr_concat_char_iter should be safe here.\n-\t\t// But as it stands it's probably not a win, since __left\n-\t\t// is likely to have additional references.\n+                // _S_ destr_concat_char_iter should be safe here.\n+                // But as it stands it's probably not a win, since __left\n+                // is likely to have additional references.\n             _RopeRep* __result = _S_concat(__left_result, __right);\n             _S_unref(_M_tree_ptr);\n             _M_tree_ptr = __result;\n@@ -2378,7 +2382,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n \n template <class _CharT, class _Alloc>\n const rope<_CharT, _Alloc>::size_type rope<_CharT, _Alloc>::npos =\n-\t\t\t(size_type)(-1);\n+                        (size_type)(-1);\n \n template <class _CharT, class _Alloc>\n inline bool operator== (const _Rope_const_iterator<_CharT,_Alloc>& __x,\n@@ -2637,8 +2641,8 @@ inline bool operator!= (const _Rope_char_ptr_proxy<_CharT,_Alloc>& __x,\n #ifdef __STL_USE_NEW_IOSTREAMS\n   template<class _CharT, class _Traits, class _Alloc>\n   basic_ostream<_CharT, _Traits>& operator<<\n-\t\t\t\t\t(basic_ostream<_CharT, _Traits>& __o,\n-\t\t\t\t\t const rope<_CharT, _Alloc>& __r);\n+                                        (basic_ostream<_CharT, _Traits>& __o,\n+                                         const rope<_CharT, _Alloc>& __r);\n #else\n   template<class _CharT, class _Alloc>\n   ostream& operator<< (ostream& __o, const rope<_CharT, _Alloc>& __r);"}, {"sha": "a6b7d5bf97d54af55a7cef397ba21538b0259af0", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -140,7 +140,8 @@ headers = \\\n \tbits/stl_stack.h bits/stl_string_fwd.h bits/stl_tempbuf.h \\\n \tbits/stl_tree.h bits/stl_uninitialized.h bits/stl_vector.h \\\n \tbits/type_traits.h bits/stl_range_errors.h bits/std_algorithm.h \\\n-\tbits/std_strstream.h \\\n+\tbits/concept_checks.h bits/container_concepts.h \\\n+\tbits/sequence_concepts.h bits/std_strstream.h \\\n \text/ropeimpl.h ext/stl_rope.h \\\n \text/stl_bvector.h bits/stl_config.h bits/stl_construct.h \\\n \text/stl_hashtable.h ext/stl_hash_fun.h \\"}, {"sha": "4b4a4b796ac253f8bf6c03c954ae7be8aa15831f", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -220,7 +220,8 @@ headers = \\\n \tbits/stl_stack.h bits/stl_string_fwd.h bits/stl_tempbuf.h \\\n \tbits/stl_tree.h bits/stl_uninitialized.h bits/stl_vector.h \\\n \tbits/type_traits.h bits/stl_range_errors.h bits/std_algorithm.h \\\n-\tbits/std_strstream.h \\\n+\tbits/concept_checks.h bits/container_concepts.h \\\n+\tbits/sequence_concepts.h bits/std_strstream.h \\\n \text/ropeimpl.h ext/stl_rope.h \\\n \text/stl_bvector.h bits/stl_config.h bits/stl_construct.h \\\n \text/stl_hashtable.h ext/stl_hash_fun.h \\"}, {"sha": "5e13a964685a33b760bca1e3cc891e563a12d5b1", "filename": "libstdc++-v3/src/stl-inst.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54a3a08788fdef9bc73e9029ff106a79a640b3af/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc?ref=54a3a08788fdef9bc73e9029ff106a79a640b3af", "patch": "@@ -49,4 +49,8 @@ namespace std {\n     vector<unsigned int>::\n     _M_insert_aux(vector<unsigned int>::iterator, unsigned int const &);\n \n+  template\n+    void\n+    __sink_unused_warning<size_t>(size_t);\n+\n } //std"}]}