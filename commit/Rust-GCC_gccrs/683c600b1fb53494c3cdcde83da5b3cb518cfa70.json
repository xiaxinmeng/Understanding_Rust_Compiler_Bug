{"sha": "683c600b1fb53494c3cdcde83da5b3cb518cfa70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgzYzYwMGIxZmI1MzQ5NGMzY2RjZGU4M2RhNWIzY2I1MThjZmE3MA==", "commit": {"author": {"name": "Andrew Pinski", "email": "apinski@cavium.com", "date": "2012-05-04T21:03:27Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2012-05-04T21:03:27Z"}, "message": "expr.c (get_def_for_expr_class): New function.\n\n2012-05-04  Andrew Pinski  <apinski@cavium.com>\n\n\t* expr.c (get_def_for_expr_class): New function.\n\t(convert_tree_comp_to_rtx): New function.\n\t(expand_cond_expr_using_cmove): New function.\n\t(expand_expr_real_2 <case COND_EXPR>): Call\n\texpand_cond_expr_using_cmove first and return if it succeeds.\n\tRemove the check for HAVE_conditional_move since we should have\n\talready converted it to a conditional move.\n\t* config/i386/i386.c (ix86_expand_int_movcc): Disallow comparison\n\tmodes of DImode for 32bits and TImode.\n\nFrom-SVN: r187183", "tree": {"sha": "3514748acd1c941bb75eb1e8f2c7717dee5d2b64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3514748acd1c941bb75eb1e8f2c7717dee5d2b64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/683c600b1fb53494c3cdcde83da5b3cb518cfa70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683c600b1fb53494c3cdcde83da5b3cb518cfa70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/683c600b1fb53494c3cdcde83da5b3cb518cfa70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683c600b1fb53494c3cdcde83da5b3cb518cfa70/comments", "author": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "417232534c60b32da5f064631974dbcb9c70bf05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/417232534c60b32da5f064631974dbcb9c70bf05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/417232534c60b32da5f064631974dbcb9c70bf05"}], "stats": {"total": 196, "additions": 192, "deletions": 4}, "files": [{"sha": "bd2e1351cf929bb8de1a8c19e93906772de257af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683c600b1fb53494c3cdcde83da5b3cb518cfa70/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683c600b1fb53494c3cdcde83da5b3cb518cfa70/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=683c600b1fb53494c3cdcde83da5b3cb518cfa70", "patch": "@@ -1,3 +1,15 @@\n+2012-05-04  Andrew Pinski  <apinski@cavium.com>\n+\n+\t* expr.c (get_def_for_expr_class): New function.\n+\t(convert_tree_comp_to_rtx): New function.\n+\t(expand_cond_expr_using_cmove): New function.\n+\t(expand_expr_real_2 <case COND_EXPR>): Call\n+\texpand_cond_expr_using_cmove first and return if it succeeds.\n+\tRemove the check for HAVE_conditional_move since we should have\n+\talready converted it to a conditional move.\n+\t* config/i386/i386.c (ix86_expand_int_movcc): Disallow comparison\n+\tmodes of DImode for 32bits and TImode.\n+\n 2012-05-04  Steven Bosscher  <steven@gcc.gnu.org>\n \n \tPR other/29442"}, {"sha": "1b8d07486d9196e7b7fb8c47fd4bf17c0f822b59", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683c600b1fb53494c3cdcde83da5b3cb518cfa70/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683c600b1fb53494c3cdcde83da5b3cb518cfa70/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=683c600b1fb53494c3cdcde83da5b3cb518cfa70", "patch": "@@ -18826,6 +18826,11 @@ ix86_expand_int_movcc (rtx operands[])\n   rtx op0 = XEXP (operands[1], 0);\n   rtx op1 = XEXP (operands[1], 1);\n \n+  if (GET_MODE (op0) == TImode\n+      || (GET_MODE (op0) == DImode\n+\t  && !TARGET_64BIT))\n+    return false;\n+\n   start_sequence ();\n   compare_op = ix86_expand_compare (code, op0, op1);\n   compare_seq = get_insns ();"}, {"sha": "1e0e96aa636173a52874a1cb3b96d95a8d848fcb", "filename": "gcc/expr.c", "status": "modified", "additions": 175, "deletions": 4, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683c600b1fb53494c3cdcde83da5b3cb518cfa70/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683c600b1fb53494c3cdcde83da5b3cb518cfa70/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=683c600b1fb53494c3cdcde83da5b3cb518cfa70", "patch": "@@ -2346,6 +2346,26 @@ get_def_for_expr (tree name, enum tree_code code)\n \n   return def_stmt;\n }\n+\n+/* Return the defining gimple statement for SSA_NAME NAME if it is an\n+   assigment and the class of the expresion on the RHS is CLASS.  Return\n+   NULL otherwise.  */\n+\n+static gimple\n+get_def_for_expr_class (tree name, enum tree_code_class tclass)\n+{\n+  gimple def_stmt;\n+\n+  if (TREE_CODE (name) != SSA_NAME)\n+    return NULL;\n+\n+  def_stmt = get_gimple_for_ssa_name (name);\n+  if (!def_stmt\n+      || TREE_CODE_CLASS (gimple_assign_rhs_code (def_stmt)) != tclass)\n+    return NULL;\n+\n+  return def_stmt;\n+}\n \f\n \n /* Determine whether the LEN bytes generated by CONSTFUN can be\n@@ -7344,6 +7364,64 @@ highest_pow2_factor_for_target (const_tree target, const_tree exp)\n   return MAX (factor, talign);\n }\n \f\n+/* Convert the tree comparision code TCODE to the rtl one where the\n+   signedness is UNSIGNEDP.  */\n+\n+static enum rtx_code\n+convert_tree_comp_to_rtx (enum tree_code tcode, int unsignedp)\n+{\n+  enum rtx_code code;\n+  switch (tcode)\n+    {\n+    case EQ_EXPR:\n+      code = EQ;\n+      break;\n+    case NE_EXPR:\n+      code = NE;\n+      break;\n+    case LT_EXPR:\n+      code = unsignedp ? LTU : LT;\n+      break;\n+    case LE_EXPR:\n+      code = unsignedp ? LEU : LE;\n+      break;\n+    case GT_EXPR:\n+      code = unsignedp ? GTU : GT;\n+      break;\n+    case GE_EXPR:\n+      code = unsignedp ? GEU : GE;\n+      break;\n+    case UNORDERED_EXPR:\n+      code = UNORDERED;\n+      break;\n+    case ORDERED_EXPR:\n+      code = ORDERED;\n+      break;\n+    case UNLT_EXPR:\n+      code = UNLT;\n+      break;\n+    case UNLE_EXPR:\n+      code = UNLE;\n+      break;\n+    case UNGT_EXPR:\n+      code = UNGT;\n+      break;\n+    case UNGE_EXPR:\n+      code = UNGE;\n+      break;\n+    case UNEQ_EXPR:\n+      code = UNEQ;\n+      break;\n+    case LTGT_EXPR:\n+      code = LTGT;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return code;\n+}\n+\n /* Subroutine of expand_expr.  Expand the two operands of a binary\n    expression EXP0 and EXP1 placing the results in OP0 and OP1.\n    The value may be stored in TARGET if TARGET is nonzero.  The\n@@ -7782,6 +7860,99 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n   return ret;\n }\n \n+/* Try to expand the conditional expression which is represented by\n+   TREEOP0 ? TREEOP1 : TREEOP2 using conditonal moves.  If succeseds\n+   return the rtl reg which repsents the result.  Otherwise return\n+   NULL_RTL.  */\n+\n+static rtx\n+expand_cond_expr_using_cmove (tree treeop0 ATTRIBUTE_UNUSED,\n+\t\t\t      tree treeop1 ATTRIBUTE_UNUSED,\n+\t\t\t      tree treeop2 ATTRIBUTE_UNUSED)\n+{\n+#ifdef HAVE_conditional_move\n+  rtx insn;\n+  rtx op00, op01, op1, op2;\n+  enum rtx_code comparison_code;\n+  enum machine_mode comparison_mode;\n+  gimple srcstmt;\n+  rtx temp;\n+  tree type = TREE_TYPE (treeop1);\n+  int unsignedp = TYPE_UNSIGNED (type);\n+  enum machine_mode mode = TYPE_MODE (type);\n+\n+  temp = assign_temp (type, 0, 0, 1);\n+\n+  /* If we cannot do a conditional move on the mode, try doing it\n+     with the promoted mode. */\n+  if (!can_conditionally_move_p (mode))\n+    mode = promote_mode (type, mode, &unsignedp);\n+\n+  if (!can_conditionally_move_p (mode))\n+    return NULL_RTX;\n+\n+  start_sequence ();\n+  expand_operands (treeop1, treeop2,\n+\t\t   temp, &op1, &op2, EXPAND_NORMAL);\n+\n+  if (TREE_CODE (treeop0) == SSA_NAME\n+      && (srcstmt = get_def_for_expr_class (treeop0, tcc_comparison)))\n+    {\n+      tree type = TREE_TYPE (gimple_assign_rhs1 (srcstmt));\n+      enum tree_code cmpcode = gimple_assign_rhs_code (srcstmt);\n+      op00 = expand_normal (gimple_assign_rhs1 (srcstmt));\n+      op01 = expand_normal (gimple_assign_rhs2 (srcstmt));\n+      comparison_mode = TYPE_MODE (type);\n+      unsignedp = TYPE_UNSIGNED (type);\n+      comparison_code = convert_tree_comp_to_rtx (cmpcode, unsignedp);\n+    }\n+  else if (TREE_CODE_CLASS (TREE_CODE (treeop0)) == tcc_comparison)\n+    {\n+      tree type = TREE_TYPE (TREE_OPERAND (treeop0, 0));\n+      enum tree_code cmpcode = TREE_CODE (treeop0);\n+      op00 = expand_normal (TREE_OPERAND (treeop0, 0));\n+      op01 = expand_normal (TREE_OPERAND (treeop0, 1));\n+      unsignedp = TYPE_UNSIGNED (type);\n+      comparison_mode = TYPE_MODE (type);\n+      comparison_code = convert_tree_comp_to_rtx (cmpcode, unsignedp);\n+    }\n+  else\n+    {\n+      op00 = expand_normal (treeop0);\n+      op01 = const0_rtx;\n+      comparison_code = NE;\n+      comparison_mode = TYPE_MODE (TREE_TYPE (treeop0));\n+    }\n+\n+  if (GET_MODE (op1) != mode)\n+    op1 = gen_lowpart (mode, op1);\n+\n+  if (GET_MODE (op2) != mode)\n+    op2 = gen_lowpart (mode, op2);\n+\n+  /* Try to emit the conditional move.  */\n+  insn = emit_conditional_move (temp, comparison_code,\n+\t\t\t\top00, op01, comparison_mode,\n+\t\t\t\top1, op2, mode,\n+\t\t\t\tunsignedp);\n+\n+  /* If we could do the conditional move, emit the sequence,\n+     and return.  */\n+  if (insn)\n+    {\n+      rtx seq = get_insns ();\n+      end_sequence ();\n+      emit_insn (seq);\n+      return temp;\n+    }\n+\n+  /* Otherwise discard the sequence and fall back to code with\n+     branches.  */\n+  end_sequence ();\n+#endif\n+  return NULL_RTX;\n+}\n+\n rtx\n expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t\t    enum expand_modifier modifier)\n@@ -8841,6 +9012,10 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t\t  && TREE_TYPE (treeop1) != void_type_node\n \t\t  && TREE_TYPE (treeop2) != void_type_node);\n \n+      temp = expand_cond_expr_using_cmove (treeop0, treeop1, treeop2);\n+      if (temp)\n+\treturn temp;\n+\n       /* If we are not to produce a result, we have no target.  Otherwise,\n \t if a target was specified use it; it will not be used as an\n \t intermediate target unless it is safe.  If no target, use a\n@@ -8850,10 +9025,6 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \t  && original_target\n \t  && safe_from_p (original_target, treeop0, 1)\n \t  && GET_MODE (original_target) == mode\n-#ifdef HAVE_conditional_move\n-\t  && (! can_conditionally_move_p (mode)\n-\t      || REG_P (original_target))\n-#endif\n \t  && !MEM_P (original_target))\n \ttemp = original_target;\n       else"}]}