{"sha": "7b3710184f03cf25de8a517b692be564382f18e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IzNzEwMTg0ZjAzY2YyNWRlOGE1MTdiNjkyYmU1NjQzODJmMThlNw==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-02-06T15:07:08Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-02-06T15:07:08Z"}, "message": "Initial revision\n\nFrom-SVN: r283", "tree": {"sha": "29ef01b6383df29be8cc252c0d6662d00be3d49c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29ef01b6383df29be8cc252c0d6662d00be3d49c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b3710184f03cf25de8a517b692be564382f18e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b3710184f03cf25de8a517b692be564382f18e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b3710184f03cf25de8a517b692be564382f18e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b3710184f03cf25de8a517b692be564382f18e7/comments", "author": null, "committer": null, "parents": [{"sha": "7a7688141da7ee692469abe43c9066557653c269", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a7688141da7ee692469abe43c9066557653c269", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a7688141da7ee692469abe43c9066557653c269"}], "stats": {"total": 2880, "additions": 2880, "deletions": 0}, "files": [{"sha": "e3cc2054e2dd7a0898fc95d4ea37b719d16e31c6", "filename": "gcc/config/m88k/m88k.c", "status": "added", "additions": 2880, "deletions": 0, "changes": 2880, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b3710184f03cf25de8a517b692be564382f18e7/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b3710184f03cf25de8a517b692be564382f18e7/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=7b3710184f03cf25de8a517b692be564382f18e7", "patch": "@@ -0,0 +1,2880 @@\n+/* Subroutines for insn-output.c for Motorola 88000.\n+   Copyright (C) 1988, 1989, 1990, 1991 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@mcc.com)\n+   Enhanced by Michael Meissner (meissner@osf.org)\n+   Currently supported by Tom Wood (wood@dg-rtp.dg.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include <sys/types.h>\n+#include <time.h>\n+#include <ctype.h>\n+\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"tree.h\"\n+#include \"c-tree.h\"\n+#include \"expr.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+\n+extern char *version_string;\n+extern time_t time ();\n+extern char *ctime ();\n+extern int flag_traditional;\n+extern FILE *asm_out_file;\n+\n+static char out_sccs_id[] = \"@(#)m88k.c\t1.96.5.2 06 Feb 1992 10:02:20\";\n+static char tm_sccs_id [] = TM_SCCS_ID;\n+\n+char *m88k_pound_sign = \"\";\t/* Either # for SVR4 or empty for SVR3 */\n+char *m88k_short_data;\n+\n+int m88k_gp_threshold;\n+int m88k_prologue_done\t= 0;\t/* Ln directives can now be emitted */\n+int m88k_function_number = 0;\t/* Counter unique to each function */\n+int m88k_fp_offset\t= 0;\t/* offset of frame pointer if used */\n+int m88k_stack_size\t= 0;\t/* size of allocated stack (including frame) */\n+int m88k_case_index;\n+\n+rtx m88k_compare_reg;\t\t/* cmp output pseudo register */\n+rtx m88k_compare_op0;\t\t/* cmpsi operand 0 */\n+rtx m88k_compare_op1;\t\t/* cmpsi operand 1 */\n+\f\n+/* Determine what instructions are needed to manufacture the integer VALUE\n+   in the given MODE.  */\n+\n+enum m88k_instruction\n+classify_integer (mode, value)\n+     enum machine_mode mode;\n+     register int value;\n+{\n+  register int mask;\n+\n+  if (value == 0)\n+    return m88k_zero;\n+  else if (SMALL_INTVAL (value))\n+    return m88k_or;\n+  else if (SMALL_INTVAL (-value))\n+    return m88k_subu;\n+  else if (mode == HImode)\n+    return m88k_or_lo16;\n+  else if (mode == QImode)\n+    return m88k_or_lo8;\n+  else if ((value & 0xffff) == 0)\n+    return m88k_oru_hi16;\n+  else if (integer_ok_for_set (value))\n+    return m88k_set;\n+  else\n+    return m88k_oru_or;\n+}\n+\n+int\n+integer_ok_for_set (value)\n+     register unsigned value;\n+{\n+  /* All the \"one\" bits must be contiguous.  If so, MASK + 1 will be\n+     a power of two or zero.  */\n+  register unsigned mask = (value | (value - 1));\n+  return (value && POWER_OF_2_or_0 (mask + 1));\n+}\n+\n+char *\n+output_load_const_int (mode, operands)\n+     enum machine_mode mode;\n+     rtx *operands;\n+{\n+  static char *patterns[] =\n+    { \"or %0,%#r0,0\",\n+      \"or %0,%#r0,%1\",\n+      \"subu %0,%#r0,%n1\",\n+      \"or %0,%#r0,%h1\",\n+      \"or %0,%#r0,%q1\",\n+      \"set %0,%#r0,%s1\",\n+      \"or.u %0,%#r0,%X1\",\n+      \"or.u %0,%#r0,%X1\\n\\tor %0,%0,%x1\",\n+    };\n+\n+  if (! REG_P (operands[0])\n+      || GET_CODE (operands[1]) != CONST_INT)\n+    abort ();\n+  return patterns[classify_integer (mode, INTVAL (operands[1]))];\n+}\n+\n+/* These next two routines assume that floating point numbers are represented\n+   in a manner which is consistent between host and target machines.  */\n+\n+char *\n+output_load_const_float (operands)\n+     rtx *operands;\n+{\n+  /* These can return 0 under some circumstances when cross-compiling.  */\n+  operands[0] = operand_subword (operands[0], 0, 0, SFmode);\n+  operands[1] = operand_subword (operands[1], 0, 0, SFmode);\n+\n+  return output_load_const_int (SImode, operands);\n+}\n+\n+char *\n+output_load_const_double (operands)\n+     rtx *operands;\n+{\n+  rtx latehalf[2];\n+\n+  /* These can return zero on some cross-compilers, but there's nothing\n+     we can do about it.  */\n+  latehalf[0] = operand_subword (operands[0], 1, 0, DFmode);\n+  latehalf[1] = operand_subword (operands[1], 1, 0, DFmode);\n+\n+  operands[0] = operand_subword (operands[0], 0, 0, DFmode);\n+  operands[1] = operand_subword (operands[1], 0, 0, DFmode);\n+\n+  output_asm_insn (output_load_const_int (SImode, operands), operands);\n+\n+  operands[0] = latehalf[0];\n+  operands[1] = latehalf[1];\n+\n+  return output_load_const_int (SImode, operands);\n+}\n+\n+char *\n+output_load_const_dimode (operands)\n+     rtx *operands;\n+{\n+  rtx latehalf[2];\n+\n+  latehalf[0] = operand_subword (operands[0], 1, 0, DImode);\n+  latehalf[1] = operand_subword (operands[1], 1, 0, DImode);\n+\n+  operands[0] = operand_subword (operands[0], 0, 0, DImode);\n+  operands[1] = operand_subword (operands[1], 0, 0, DImode);\n+\n+  output_asm_insn (output_load_const_int (SImode, operands), operands);\n+\n+  operands[0] = latehalf[0];\n+  operands[1] = latehalf[1];\n+\n+  return output_load_const_int (SImode, operands);\n+}\n+\f\n+/* Emit insns to move operands[1] into operands[0].\n+\n+   Return 1 if we have written out everything that needs to be done to\n+   do the move.  Otherwise, return 0 and the caller will emit the move\n+   normally.  */\n+\n+int\n+emit_move_sequence (operands, mode)\n+     rtx *operands;\n+     enum machine_mode mode;\n+{\n+  register rtx operand0 = operands[0];\n+  register rtx operand1 = operands[1];\n+\n+  /* Handle most common case first: storing into a register.  */\n+  if (register_operand (operand0, mode))\n+    {\n+      if (register_operand (operand1, mode)\n+\t  || (GET_CODE (operand1) == CONST_INT && SMALL_INT (operand1))\n+\t  || GET_CODE (operand1) == HIGH\n+\t  /* Only `general_operands' can come here, so MEM is ok.  */\n+\t  || GET_CODE (operand1) == MEM)\n+\t{\n+\t  /* Run this case quickly.  */\n+\t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operand1));\n+\t  return 1;\n+\t}\n+    }\n+  else if (GET_CODE (operand0) == MEM)\n+    {\n+      if (register_operand (operand1, mode) || operand1 == const0_rtx)\n+\t{\n+\t  /* Run this case quickly.  */\n+\t  emit_insn (gen_rtx (SET, VOIDmode, operand0, operand1));\n+\t  return 1;\n+\t}\n+      if (! reload_in_progress)\n+\t{\n+\t  operands[0] = validize_mem (operand0);\n+\t  operands[1] = operand1 = force_reg (mode, operand1);\n+\t}\n+    }\n+\n+  /* Simplify the source if we need to.  */\n+  if (GET_CODE (operand1) != HIGH && immediate_operand (operand1, mode))\n+    {\n+\tif (GET_CODE (operand1) != CONST_INT\n+\t    && GET_CODE (operand1) != CONST_DOUBLE)\n+\t  {\n+\t    rtx temp = reload_in_progress ? operand0 : gen_reg_rtx (Pmode);\n+\t    operands[1] = legitimize_address (flag_pic\n+\t\t\t\t\t      && symbolic_address_p (operand1),\n+\t\t\t\t\t      operand1, temp);\n+\t    if (mode != SImode)\n+\t      operands[1] = gen_rtx (SUBREG, mode, operands[1], 0);\n+\t  }\n+    }\n+\n+  /* Now have insn-emit do whatever it normally does.  */\n+  return 0;\n+}\n+\n+/* Return a legitimate reference for ORIG (either an address or a MEM) using\n+   the register REG.  If PIC and the address is already position-independent,\n+   use ORIG.  */\n+\n+struct rtx_def *\n+legitimize_address (pic, orig, reg)\n+     int pic;\n+     rtx orig;\n+     rtx reg;\n+{\n+  rtx addr = (GET_CODE (orig) == MEM ? XEXP (orig, 0) : orig);\n+  rtx new = orig;\n+  rtx temp;\n+\n+  if (pic)\n+    {\n+      if (GET_CODE (addr) == SYMBOL_REF\n+\t  || GET_CODE (addr) == LABEL_REF)\n+\t{\n+\t  if (reg == 0) abort ();\n+\n+\t  if (flag_pic == 2)\n+\t    {\n+\t      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t\t  reg, gen_rtx (HIGH, SImode, addr)));\n+\t      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t\t  reg, gen_rtx (LO_SUM, SImode, reg, addr)));\n+\t      addr = reg;\n+\t    }\n+\t  new = gen_rtx (MEM, Pmode,\n+\t\t\t gen_rtx (PLUS, SImode,\n+\t\t\t\t  pic_offset_table_rtx, addr));\n+\t  current_function_uses_pic_offset_table = 1;\n+\t  RTX_UNCHANGING_P (new) = 1;\n+\t  {\n+\t    rtx insn = emit_move_insn (reg, new);\n+\t    /* Put a REG_EQUAL note on this insn, so that it can be optimized\n+\t       by loop.  */\n+\t    REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL, orig,\n+\t\t\t\t\tREG_NOTES (insn));\n+\t  }\n+\t  new = reg;\n+\t}\n+      else if (GET_CODE (addr) == CONST)\n+\t{\n+\t  rtx base, offset;\n+\n+\t  if (GET_CODE (XEXP (addr, 0)) == PLUS\n+\t      && XEXP (XEXP (addr, 0), 0) == pic_offset_table_rtx)\n+\t    return orig;\n+\n+\t  if (reg == 0)\n+\t    abort ();\n+\n+\t  if (GET_CODE (XEXP (addr, 0)) != PLUS) abort ();\n+\n+\t  base = legitimize_address (1, XEXP (XEXP (addr, 0), 0), reg);\n+\t  addr = legitimize_address (1, XEXP (XEXP (addr, 0), 1),\n+\t\t\t\t     base == reg ? 0 : reg);\n+\n+\t  if (GET_CODE (addr) == CONST_INT)\n+\t    new = plus_constant_for_output (base, INTVAL (addr));\n+\t  else\n+\t    new = gen_rtx (PLUS, SImode, base, addr);\n+\t  /* Should we set special REG_NOTEs here?  */\n+\t}\n+    }\n+  else if (! SHORT_ADDRESS_P (addr, temp))\n+    {\n+      emit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t  reg, gen_rtx (HIGH, SImode, addr)));\n+      new = gen_rtx (LO_SUM, SImode, reg, addr);\n+    }\n+\n+  if (new != orig\n+      && GET_CODE (orig) == MEM)\n+    {\n+      new = gen_rtx (MEM, GET_MODE (orig), new);\n+      RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (orig);\n+      MEM_VOLATILE_P (new) = MEM_VOLATILE_P (orig);\n+      MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (orig);\n+    }\n+  return new;\n+}\n+\f\n+/* Support functions for code to emit a block move.  There are four methods\n+   used to perform the block move:\n+   + call memcpy\n+   + call the looping library function, e.g. __movstrSI64n8\n+   + call a non-looping library function, e.g. __movstrHI15x11\n+   + produce an inline sequence of ld/st instructions\n+\n+   The parameters below describe the library functions produced by\n+   movstr-m88k.sh.  */\n+\n+#define MOVSTR_LOOP\t64 /* __movstrSI64n68 .. __movstrSI64n8 */\n+#define MOVSTR_QI\t16 /* __movstrQI16x16 .. __movstrQI16x2 */\n+#define MOVSTR_HI\t48 /* __movstrHI48x48 .. __movstrHI48x4 */\n+#define MOVSTR_SI\t96 /* __movstrSI96x96 .. __movstrSI96x8 */\n+#define MOVSTR_ODD_SI\t48 /* __movstrSI47x47 .. __movstrSI47x11,\n+\t\t\t      __movstrSI46x46 .. __movstrSI46x10,\n+\t\t\t      __movstrSI45x45 .. __movstrSI45x9 */\n+#define MOVSTR_ODD_HI\t16 /* __movstrHI15x15 .. __movstrHI15x5 */\n+\n+/* Break even points where memcpy will do just as well.  */\n+#define MOVSTR_QI_LIMIT\t13\n+#define MOVSTR_HI_LIMIT\t38\n+#define MOVSTR_SI_LIMIT\tMOVSTR_SI\n+\n+static enum machine_mode mode_from_bytes[] =\n+\t\t\t      {VOIDmode, QImode, HImode, VOIDmode, SImode};\n+static int max_from_bytes[] = {0, MOVSTR_QI, MOVSTR_HI, 0, MOVSTR_SI};\n+static int all_from_bytes[] = {0, MOVSTR_QI, MOVSTR_ODD_HI, 0, MOVSTR_ODD_SI};\n+static int best_from_bytes[] =\n+\t\t{0, MOVSTR_QI_LIMIT, MOVSTR_HI_LIMIT, 0, MOVSTR_SI_LIMIT};\n+\n+static void block_move_loop ();\n+static void block_move_no_loop ();\n+static void block_move_sequence ();\n+\n+/* Emit code to perform a block move.  Choose the best method.\n+\n+   OPERANDS[0] is the destination.\n+   OPERANDS[1] is the source.\n+   OPERANDS[2] is the size.\n+   OPERANDS[3] is the alignment safe to use.  */\n+\n+void\n+expand_block_move (dest_mem, src_mem, operands)\n+     rtx dest_mem;\n+     rtx src_mem;\n+     rtx *operands;\n+{\n+  int align = INTVAL (operands[3]);\n+  int constp = (GET_CODE (operands[2]) == CONST_INT);\n+  int bytes = (constp ? INTVAL (operands[2]) : 0);\n+\n+  if (constp && bytes <= 0)\n+    return;\n+\n+  /* Determine machine mode to do move with.  */\n+  if (align > 4)\n+    align = 4;\n+  else if (align <= 0 || align == 3)\n+    abort ();\t/* block move invalid alignment.  */\n+\n+  if (constp && bytes <= 3 * align)\n+    block_move_sequence (operands[0], dest_mem, operands[1], src_mem,\n+\t\t\t bytes, align, 0);\n+\n+  else if (constp && bytes <= best_from_bytes[align])\n+    block_move_no_loop (operands[0], dest_mem, operands[1], src_mem,\n+\t\t\tbytes, align);\n+\n+  else if (constp && align == 4)\n+    block_move_loop (operands[0], dest_mem, operands[1], src_mem,\n+\t\t     bytes, align);\n+\n+  else\n+    {\n+#ifdef TARGET_MEM_FUNCTIONS\n+      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"memcpy\"), 0,\n+\t\t\t VOIDmode, 3,\n+\t\t\t operands[0], Pmode,\n+\t\t\t operands[1], Pmode,\n+\t\t\t operands[2], SImode);\n+#else\n+      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"bcopy\"), 0,\n+\t\t\t VOIDmode, 3,\n+\t\t\t operands[1], Pmode,\n+\t\t\t operands[0], Pmode,\n+\t\t\t operands[2], SImode);\n+#endif\n+    }\n+}\n+\n+/* Emit code to perform a block move by calling a looping movstr library\n+   function.  SIZE and ALIGN are known constants.  DEST and SRC are\n+   registers.  */\n+\n+static void\n+block_move_loop (dest, dest_mem, src, src_mem, size, align)\n+     rtx dest, dest_mem;\n+     rtx src, src_mem;\n+     int size;\n+     int align;\n+{\n+  enum machine_mode mode;\n+  int count;\n+  int units;\n+  int remainder;\n+  rtx offset_rtx;\n+  rtx value_rtx;\n+  char entry[30];\n+  tree entry_name;\n+\n+  /* Determine machine mode to do move with.  */\n+  if (align != 4)\n+    abort ();\n+\n+  /* Determine the structure of the loop.  */\n+  count = size / MOVSTR_LOOP;\n+  units = (size - count * MOVSTR_LOOP) / align;\n+\n+  if (units < 2)\n+    {\n+      count--;\n+      units += MOVSTR_LOOP / align;\n+    }\n+\n+  if (count <= 0)\n+    {\n+      block_move_no_loop (dest, dest_mem, src, src_mem, size, align);\n+      return;\n+    }\n+\n+  remainder = size - count * MOVSTR_LOOP - units * align;\n+\n+  mode = mode_from_bytes[align];\n+  sprintf (entry, \"__movstr%s%dn%d\",\n+\t   GET_MODE_NAME (mode), MOVSTR_LOOP, units * align);\n+  entry_name = get_identifier (entry);\n+\n+  offset_rtx = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\tMOVSTR_LOOP + (1 - units) * align);\n+\n+  value_rtx = gen_rtx (MEM, mode,\n+\t\t       gen_rtx (PLUS, Pmode,\n+\t\t\t\tgen_rtx (REG, Pmode, 3),\n+\t\t\t\toffset_rtx));\n+  RTX_UNCHANGING_P (value_rtx) = RTX_UNCHANGING_P (src_mem);\n+  MEM_VOLATILE_P (value_rtx) = MEM_VOLATILE_P (src_mem);\n+  MEM_IN_STRUCT_P (value_rtx) = MEM_IN_STRUCT_P (src_mem);\n+\n+  emit_insn (gen_call_block_move_loop\n+\t     (gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (entry_name)),\n+\t      dest, src, offset_rtx, value_rtx,\n+\t      gen_rtx (REG, GET_MODE (value_rtx), ((units & 1) ? 4 : 5)),\n+\t      gen_rtx (CONST_INT, VOIDmode, count)));\n+\n+  if (remainder)\n+    block_move_sequence (gen_rtx (REG, Pmode, 2), dest_mem,\n+\t\t\t gen_rtx (REG, Pmode, 3), src_mem,\n+\t\t\t remainder, align, MOVSTR_LOOP + align);\n+}\n+\n+/* Emit code to perform a block move by calling a non-looping library\n+   function.  SIZE and ALIGN are known constants.  DEST and SRC are\n+   registers.  OFFSET is the known starting point for the output pattern.  */\n+\n+static void\n+block_move_no_loop (dest, dest_mem, src, src_mem, size, align)\n+     rtx dest, dest_mem;\n+     rtx src, src_mem;\n+     int size;\n+     int align;\n+{\n+  enum machine_mode mode = mode_from_bytes[align];\n+  int units = size / align;\n+  int remainder = size - units * align;\n+  int most;\n+  int evenp;\n+  rtx offset_rtx;\n+  rtx value_rtx;\n+  char entry[30];\n+  tree entry_name;\n+\n+  if (remainder && size <= all_from_bytes[align])\n+    {\n+      most = all_from_bytes[align] - (align - remainder);\n+      remainder = 0;\n+    }\n+  else\n+    {\n+      most = max_from_bytes[align];\n+    }\n+\n+  sprintf (entry, \"__movstr%s%dx%d\",\n+\t   GET_MODE_NAME (mode), most, size - remainder);\n+  entry_name = get_identifier (entry);\n+\n+  offset_rtx = gen_rtx (CONST_INT, VOIDmode, most - (size - remainder));\n+\n+  value_rtx = gen_rtx (MEM, mode,\n+\t\t       gen_rtx (PLUS, Pmode,\n+\t\t\t\tgen_rtx (REG, Pmode, 3),\n+\t\t\t\toffset_rtx));\n+  RTX_UNCHANGING_P (value_rtx) = RTX_UNCHANGING_P (src_mem);\n+  MEM_VOLATILE_P (value_rtx) = MEM_VOLATILE_P (src_mem);\n+  MEM_IN_STRUCT_P (value_rtx) = MEM_IN_STRUCT_P (src_mem);\n+\n+  evenp = ((most - (size - remainder)) / align) & 1;\n+\n+  emit_insn (gen_call_block_move\n+\t     (gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (entry_name)),\n+\t      dest, src, offset_rtx, value_rtx,\n+\t      gen_rtx (REG, GET_MODE (value_rtx), (evenp ? 4 : 5))));\n+\n+  if (remainder)\n+    block_move_sequence (gen_rtx (REG, Pmode, 2), dest_mem,\n+\t\t\t gen_rtx (REG, Pmode, 3), src_mem,\n+\t\t\t remainder, align, most);\n+}\n+\n+/* Emit code to perform a block move with an offset sequence of ld/st\n+   instructions (..., ld 0, st 1, ld 1, st 0, ...).  SIZE and ALIGN are\n+   known constants.  DEST and SRC are registers.  OFFSET is the known\n+   starting point for the output pattern.  */\n+\n+static void\n+block_move_sequence (dest, dest_mem, src, src_mem, size, align, offset)\n+     rtx dest, dest_mem;\n+     rtx src, src_mem;\n+     int size;\n+     int align;\n+     int offset;\n+{\n+  rtx temp[2];\n+  enum machine_mode mode[2];\n+  int amount[2];\n+  int active[2];\n+  int phase = 0;\n+  int next;\n+  int offset_ld = offset;\n+  int offset_st = offset;\n+\n+  active[0] = active[1] = FALSE;\n+\n+  /* Establish parameters for the first load and for the second load if\n+     it is known to be the same mode as the first.  */\n+  amount[0] = amount[1] = align;\n+  mode[0] = mode_from_bytes[align];\n+  temp[0] = gen_reg_rtx (mode[0]);\n+  if (size >= 2 * align)\n+    {\n+      mode[1] = mode[0];\n+      temp[1] = gen_reg_rtx (mode[1]);\n+    }\n+\n+  do\n+    {\n+      rtx srcp, dstp;\n+      next = phase;\n+      phase = !phase;\n+\n+      if (size > 0)\n+\t{\n+\t  /* Change modes as the sequence tails off.  */\n+\t  if (size < amount[next])\n+\t    {\n+\t      amount[next] = (size >= 2 ? 2 : 1);\n+\t      mode[next] = mode_from_bytes[amount[next]];\n+\t      temp[next] = gen_reg_rtx (mode[next]);\n+\t    }\n+\t  size -= amount[next];\n+\t  srcp = gen_rtx (MEM, mode[next],\n+\t\t\t  gen_rtx (PLUS, Pmode, src,\n+\t\t\t\t   gen_rtx (CONST_INT, SImode, offset_ld)));\n+\t  RTX_UNCHANGING_P (srcp) = RTX_UNCHANGING_P (src_mem);\n+\t  MEM_VOLATILE_P (srcp) = MEM_VOLATILE_P (src_mem);\n+\t  MEM_IN_STRUCT_P (srcp) = MEM_IN_STRUCT_P (src_mem);\n+\t  emit_move_insn (temp[next], srcp);\n+\t  offset_ld += amount[next];\n+\t  active[next] = TRUE;\n+\t}\n+\n+      if (active[phase])\n+\t{\n+\t  active[phase] = FALSE;\n+\t  dstp = gen_rtx (MEM, mode[phase],\n+\t\t\t  gen_rtx (PLUS, Pmode, dest,\n+\t\t\t\t   gen_rtx (CONST_INT, SImode, offset_st)));\n+\t  RTX_UNCHANGING_P (dstp) = RTX_UNCHANGING_P (dest_mem);\n+\t  MEM_VOLATILE_P (dstp) = MEM_VOLATILE_P (dest_mem);\n+\t  MEM_IN_STRUCT_P (dstp) = MEM_IN_STRUCT_P (dest_mem);\n+\t  emit_move_insn (dstp, temp[phase]);\n+\t  offset_st += amount[phase];\n+\t}\n+    }\n+  while (active[next]);\n+}\n+\f\n+/* Emit the code to do an AND operation.  */\n+\n+char *\n+output_and (operands)\n+     rtx operands[];\n+{\n+  unsigned int value;\n+\n+  if (REG_P (operands[2]))\n+    return \"and %0,%1,%2\";\n+\n+  value = INTVAL (operands[2]);\n+  if (SMALL_INTVAL (value))\n+    return \"mask %0,%1,%2\";\n+  else if ((value & 0xffff0000) == 0xffff0000)\n+    return \"and %0,%1,%x2\";\n+  else if ((value & 0xffff) == 0xffff)\n+    return \"and.u %0,%1,%X2\";\n+  else if ((value & 0xffff) == 0)\n+    return \"mask.u %0,%1,%X2\";\n+  else if (integer_ok_for_set (~value))\n+    return \"clr %0,%1,%S2\";\n+  else\n+    return \"and.u %0,%1,%X2\\n\\tand %0,%0,%x2\";\n+}\n+\n+/* Emit the code to do an inclusive OR operation.  */\n+\n+char *\n+output_ior (operands)\n+     rtx operands[];\n+{\n+  unsigned int value;\n+\n+  if (REG_P (operands[2]))\n+    return \"or %0,%1,%2\";\n+\n+  value = INTVAL (operands[2]);\n+  if (SMALL_INTVAL (value))\n+    return \"or %0,%1,%2\";\n+  else if ((value & 0xffff) == 0)\n+    return \"or.u %0,%1,%X2\";\n+  else if (integer_ok_for_set (value))\n+    return \"set %0,%1,%s2\";\n+  else\n+    return \"or.u %0,%1,%X2\\n\\tor %0,%0,%x2\";\n+}\n+\n+/* Emit the instructions for doing an XOR.  */\n+\n+char *\n+output_xor (operands)\n+     rtx operands[];\n+{\n+  unsigned int value;\n+\n+  if (REG_P (operands[2]))\n+    return \"xor %0,%1,%2\";\n+\n+  value = INTVAL (operands[2]);\n+  if (SMALL_INTVAL (value))\n+    return \"xor %0,%1,%2\";\n+  else if ((value & 0xffff) == 0)\n+    return \"xor.u %0,%1,%X2\";\n+  else\n+    return \"xor.u %0,%1,%X2\\n\\txor %0,%0,%x2\";\n+}\n+\f\n+/* Output a call.  Normally this is just bsr or jsr, but this also deals with\n+   accomplishing a branch after the call by incrementing r1.  This requires\n+   that various assembler bugs be accomodated.  The 4.30 DG/UX assembler\n+   requires that forward references not occur when computing the difference of\n+   two labels.  The [version?] Motorola assembler computes a word difference.\n+   No doubt there's more to come!\n+\n+   It would seem the same idea could be used to tail call, but in this case,\n+   the epilogue will be non-null.  */\n+\n+static rtx sb_name = 0;\n+static rtx sb_high = 0;\n+static rtx sb_low = 0;\n+\n+char *\n+output_call (operands, addr)\n+     rtx operands[];\n+     rtx addr;\n+{\n+  operands[0] = addr;\n+  if (final_sequence)\n+    {\n+      rtx jump;\n+\n+      /* This can be generalized, but there is currently no need.  */\n+      if (XVECLEN (final_sequence, 0) != 2)\n+\tabort ();\n+\n+      jump = XVECEXP (final_sequence, 0, 1);\n+      if (GET_CODE (jump) == JUMP_INSN)\n+\t{\n+\t  rtx low, high;\n+\t  char *last;\n+\t  rtx dest = XEXP (SET_SRC (PATTERN (jump)), 0);\n+\t  int delta = 4 * (insn_addresses[INSN_UID (dest)]\n+\t\t\t   - insn_addresses[INSN_UID (jump)]);\n+#if (MONITOR_GCC & 0x2) /* How often do long branches happen?  */\n+\t  if ((unsigned) (delta + 0x8000) >= 0x10000)\n+\t    warning (\"Internal gcc monitor: short-branch(%x)\", delta);\n+#endif\n+\n+\t  /* Delete the jump.  */\n+\t  PUT_CODE (jump, NOTE);\n+\t  NOTE_LINE_NUMBER (jump) = NOTE_INSN_DELETED;\n+\t  NOTE_SOURCE_FILE (jump) = 0;\n+\n+\t  /* If we loose, we must use the non-delay form.  This is unlikely\n+\t     to ever happen.  If it becomes a problem, claim that a call\n+\t     has two delay slots and only the second can be filled with\n+\t     a jump.  */\n+#ifdef AS_BUG_IMMEDIATE_LABEL /* The assembler restricts immediate values.  */\n+\t  if (! ADD_INTVAL (delta * 2))\n+#else\n+\t  if (! ADD_INTVAL (delta))\n+#endif\n+\t    {\n+\t      operands[1] = dest;\n+\t      return (REG_P (addr)\n+\t\t      ? \"jsr %0\\n\\tbr %l1\"\n+\t\t      : (flag_pic\n+\t\t\t ? \"bsr %0#plt\\n\\tbr %l1\"\n+\t\t\t : \"bsr %0\\n\\tbr %l1\"));\n+\t    }\n+\n+\t  /* Output the short branch form.  */\n+\t  output_asm_insn ((REG_P (addr)\n+\t\t\t    ? \"jsr.n %0\"\n+\t\t\t    : (flag_pic ? \"bsr.n %0#plt\" : \"bsr.n %0\")),\n+\t\t\t   operands);\n+\n+\t  operands[0] = gen_label_rtx ();\n+\t  operands[1] = gen_label_rtx ();\n+\t  if (delta < 0)\n+\t    {\n+\t      low = dest;\n+\t      high = operands[1];\n+\t      last = \"subu %#r1,%#r1,%l0\\n%l1:\";\n+\t    }\n+\t  else\n+\t    {\n+\t      low = operands[1];\n+\t      high = dest;\n+\t      last = \"addu %#r1,%#r1,%l0\\n%l1:\";\n+\t    }\n+\n+\t  /* Record the values to be computed later as \"def name,high-low\".  */\n+\t  sb_name = gen_rtx (EXPR_LIST, VOIDmode, operands[0], sb_name);\n+\t  sb_high = gen_rtx (EXPR_LIST, VOIDmode, high, sb_high);\n+\t  sb_low = gen_rtx (EXPR_LIST, VOIDmode, low, sb_low);\n+\n+\t  return last;\n+\t}\n+    }\n+  return (REG_P (addr)\n+\t  ? \"jsr%. %0\"\n+\t  : (flag_pic ? \"bsr%. %0#plt\" : \"bsr%. %0\"));\n+}\n+\n+static void\n+output_short_branch_defs (stream)\n+     FILE *stream;\n+{\n+  char name[256], high[256], low[256];\n+\n+  for (; sb_name && sb_high && sb_low;\n+       sb_name = XEXP (sb_name, 1),\n+       sb_high = XEXP (sb_high, 1),\n+       sb_low = XEXP (sb_low, 1))\n+    {\n+      ASM_GENERATE_INTERNAL_LABEL\n+\t(name, \"L\", CODE_LABEL_NUMBER (XEXP (sb_name, 0)));\n+      ASM_GENERATE_INTERNAL_LABEL\n+\t(high, \"L\", CODE_LABEL_NUMBER (XEXP (sb_high, 0)));\n+      ASM_GENERATE_INTERNAL_LABEL\n+\t(low, \"L\", CODE_LABEL_NUMBER (XEXP (sb_low, 0)));\n+      /* This will change as the assembler requirements become known.  */\n+      fprintf (stream, \"%s\\t %s,%s-%s\\n\",\n+\t       DEF_ASM_OP, &name[1], &high[1], &low[1]);\n+    }\n+  if (sb_name || sb_high || sb_low)\n+    abort ();\n+}\n+\f\n+/* Report errors on floating point, if we are given NaN's, or such.  Leave\n+   the number as is, though, since we output the number in hex, and the\n+   assemble won't choak on it.  */\n+\n+void\n+check_float_value (mode, value)\n+     enum machine_mode mode;\n+     REAL_VALUE_TYPE value;\n+{\n+  union {\n+    REAL_VALUE_TYPE d;\n+    struct {\n+      unsigned sign\t    :  1;\n+      unsigned exponent  : 11;\n+      unsigned mantissa1 : 20;\n+      unsigned mantissa2;\n+    } s;\n+  } u;\n+\n+  if (mode == DFmode)\n+    {\n+      u.d = value;\n+      if (u.s.mantissa1 != 0 || u.s.mantissa2 != 0)\n+\t{\n+\t  if (u.s.exponent == 0x7ff)\t/* Not a Number */\n+\t    warning (\"floating point number is not valid for IEEE double precision\");\n+\t  else if (u.s.exponent == 0)\n+\t    warning (\"denormalized double precision floating point number\");\n+\t}\n+    }\n+  else if (mode == SFmode)\n+    {\n+      u.d = REAL_VALUE_TRUNCATE (mode, value);\n+      if (u.s.mantissa1 != 0 || u.s.mantissa2 != 0)\n+\t{\n+\t  if (u.s.exponent == 0x7ff)\t/* Not a Number */\n+\t    warning (\"floating point number is not valid for IEEE double precision\");\n+\t  else if (u.s.exponent == 0)\n+\t    warning (\"denormalized single precision floating point number\");\n+\t}\n+      else if (u.s.exponent == 0x7ff)\t/* Infinity */\n+\twarning (\"floating point number exceeds range of `float'\");\n+    }\n+}\n+\f\n+/* Return true if the operand is a power of two and is a floating\n+   point type (to optimize division by power of two into multiplication).  */\n+\n+int\n+real_power_of_2_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  union {\n+    REAL_VALUE_TYPE d;\n+    int i[sizeof (REAL_VALUE_TYPE) / sizeof (int)];\n+    struct {\t\t\t\t/* IEEE double precision format */\n+      unsigned sign\t :  1;\n+      unsigned exponent  : 11;\n+      unsigned mantissa1 : 20;\n+      unsigned mantissa2;\n+    } s;\n+    struct {\t\t\t\t/* IEEE double format to quick check */\n+      unsigned sign\t :  1;\t\t/* if it fits in a float */\n+      unsigned exponent1 :  4;\n+      unsigned exponent2 :  7;\n+      unsigned mantissa1 : 20;\n+      unsigned mantissa2;\n+    } s2;\n+  } u;\n+\n+  if (GET_MODE (op) != DFmode && GET_MODE (op) != SFmode)\n+    return 0;\n+\n+  if (GET_CODE (op) != CONST_DOUBLE)\n+    return 0;\n+\n+  u.i[0] = CONST_DOUBLE_LOW  (op);\n+  u.i[1] = CONST_DOUBLE_HIGH (op);\n+\n+  if (u.s.mantissa1 != 0 || u.s.mantissa2 != 0\t/* not a power of two */\n+      || u.s.exponent == 0\t\t\t/* constant 0.0 */\n+      || u.s.exponent == 0x7ff\t\t\t/* NAN */\n+      || (u.s2.exponent1 != 0x8 && u.s2.exponent1 != 0x7))\n+    return 0;\t\t\t\t\t/* const won't fit in float */\n+\n+  return 1;\n+}\n+\f\n+/* Make OP legitimate for mode MODE.  Currently this only deals with DFmode\n+   operands, putting them in registers and making CONST_DOUBLE values\n+   SFmode where possible.  */\n+\n+struct rtx_def *\n+legitimize_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  rtx temp;\n+  union {\n+    union real_extract r;\n+    struct {\t\t\t\t/* IEEE double precision format */\n+      unsigned sign\t :  1;\n+      unsigned exponent  : 11;\n+      unsigned mantissa1 : 20;\n+      unsigned mantissa2;\n+    } d;\n+    struct {\t\t\t\t/* IEEE double format to quick check */\n+      unsigned sign\t :  1;\t\t/* if it fits in a float */\n+      unsigned exponent1 :  4;\n+      unsigned exponent2 :  7;\n+      unsigned mantissa1 : 20;\n+      unsigned mantissa2;\n+    } s;\n+  } u;\n+\n+  if (GET_CODE (op) == REG || mode != DFmode)\n+    return op;\n+\n+  if (GET_CODE (op) == CONST_DOUBLE)\n+    {\n+      bcopy (&CONST_DOUBLE_LOW (op), &u.r, sizeof u);\n+      if (u.d.exponent != 0x7ff /* NaN */\n+\t  && u.d.mantissa2 == 0 /* Mantissa fits */\n+\t  && (u.s.exponent1 == 0x8 || u.s.exponent1 == 0x7) /* Exponent fits */\n+\t  && (temp = simplify_unary_operation (FLOAT_TRUNCATE, SFmode,\n+\t\t\t\t\t       op, mode)) != 0)\n+\treturn gen_rtx (FLOAT_EXTEND, mode, force_reg (SFmode, temp));\n+    }\n+  else if (register_operand (op, mode))\n+    return op;\n+\n+  return force_reg (mode, op);\n+}\n+\f\n+/* Return true if OP is a suitable input for a move insn.  */\n+\n+int\n+move_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+  if (GET_CODE (op) == CONST_INT)\n+    return (classify_integer (mode, INTVAL (op)) < m88k_oru_hi16);\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+  if (GET_CODE (op) == LO_SUM)\n+    return (REG_P (XEXP (op, 0))\n+\t    && symbolic_address_p (XEXP (op, 1)));\n+  return memory_address_p (mode, op);\n+}\n+\n+/* Return true if OP is suitable for a call insn.  */\n+\n+int\n+call_address_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (REG_P (op) || symbolic_address_p (op));\n+}\n+\n+/* Returns true if OP is either a symbol reference or a sum of a symbol\n+   reference and a constant.  */\n+\n+int\n+symbolic_address_p (op)\n+     register rtx op;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 1;\n+\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return true if OP is a register or const0_rtx.  */\n+\n+int\n+reg_or_0_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (op == const0_rtx || register_operand (op, mode));\n+}\n+\n+/* Nonzero if OP is a valid second operand for an arithmetic insn.  */\n+\n+int\n+arith_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op)));\n+}\n+\n+/* Return true if OP is a  register or 5 bit integer.  */\n+\n+int\n+arith5_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && (unsigned) INTVAL (op) < 32));\n+}\n+\n+int\n+arith32_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode) || GET_CODE (op) == CONST_INT);\n+}\n+\n+int\n+arith64_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || GET_CODE (op) == CONST_INT\n+\t  || (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == DImode));\n+}\n+\n+int\n+int5_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT && (unsigned) INTVAL (op) < 32);\n+}\n+\n+int\n+int32_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT);\n+}\n+\n+/* Return true if OP is a register or a valid immediate operand for\n+   addu or subu.  */\n+\n+int\n+add_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_INT && ADD_INT (op)));\n+}\n+\n+/* Nonzero if this is a bitmask filling the bottom bits, for optimizing and +\n+   shift left combinations into a single mak instruction.  */\n+\n+int\n+mak_mask_p (value)\n+     int value;\n+{\n+  return (value && POWER_OF_2_or_0 (value + 1));\n+}\n+\n+int\n+reg_or_bbx_mask_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  int value;\n+  if (register_operand (op, mode))\n+    return 1;\n+  if (GET_CODE (op) != CONST_INT)\n+    return 0;\n+\n+  value = INTVAL (op);\n+  if (POWER_OF_2 (value))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return true if OP is valid to use in the context of a floating\n+   point operation.  Special case 0.0, since we can use r0.  */\n+\n+int\n+real_or_0_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (mode != SFmode && mode != DFmode)\n+    return 0;\n+\n+  return (register_operand (op, mode)\n+\t  || (GET_CODE (op) == CONST_DOUBLE\n+\t      && op == CONST0_RTX (mode)));\n+}\n+\n+/* Return true if OP is a relational operator.  */\n+\n+int\n+relop (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case EQ:\n+    case NE:\n+    case LT:\n+    case LE:\n+    case GE:\n+    case GT:\n+    case LTU:\n+    case LEU:\n+    case GEU:\n+    case GTU:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return true if OP is a relational operator, and is not an unsigned\n+   relational operator.  */\n+\n+int\n+relop_no_unsigned (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case EQ:\n+    case NE:\n+    case LT:\n+    case LE:\n+    case GE:\n+    case GT:\n+      /* @@ What is this test doing?  Why not use `mode'?  */\n+      if (GET_MODE_CLASS (GET_MODE (op)) == MODE_FLOAT\n+\t  || GET_MODE (op) == DImode\n+\t  || GET_MODE_CLASS (GET_MODE (XEXP (op, 0))) == MODE_FLOAT\n+\t  || GET_MODE (XEXP (op, 0)) == DImode\n+\t  || GET_MODE_CLASS (GET_MODE (XEXP (op, 1))) == MODE_FLOAT\n+\t  || GET_MODE (XEXP (op, 1)) == DImode)\n+\treturn 0;\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return true if the code of this rtx pattern is EQ or NE.  */\n+\n+int\n+equality_op (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n+}\n+\n+/* Return true if the code of this rtx pattern is pc or label_ref.  */\n+\n+int\n+pc_or_label_ref (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == PC || GET_CODE (op) == LABEL_REF);\n+}\n+\f\n+/* Output to FILE the start of the assembler file.  */\n+\n+struct option\n+{\n+  char *string;\n+  int *variable;\n+  int on_value;\n+};\n+\n+static int\n+output_option (file, sep, type, name, indent, pos, max)\n+     FILE *file;\n+     char *sep;\n+     char *type;\n+     char *name;\n+     char *indent;\n+     int pos;\n+     int max;\n+{\n+  if (strlen (sep) + strlen (type) + strlen (name) + pos > max)\n+    {\n+      fprintf (file, indent);\n+      return fprintf (file, \"%s%s\", type, name);\n+    }\n+  return pos + fprintf (file, \"%s%s%s\", sep, type, name);\n+}\n+\n+static struct { char *name; int value; } m_options[] = TARGET_SWITCHES;\n+\n+static void\n+output_options (file, f_options, f_len, W_options, W_len,\n+\t\tpos, max, sep, indent, term)\n+     FILE *file;\n+     struct option *f_options;\n+     struct option *W_options;\n+     int f_len, W_len;\n+     int pos;\n+     int max;\n+     char *indent;\n+     char *term;\n+{\n+  register int j;\n+\n+  if (optimize)\n+    pos = output_option (file, sep, \"-O\", \"\", indent, pos, max);\n+  if (write_symbols != NO_DEBUG)\n+    pos = output_option (file, sep, \"-g\", \"\", indent, pos, max);\n+  if (flag_traditional)\n+    pos = output_option (file, sep, \"-traditional\", \"\", indent, pos, max);\n+  if (profile_flag)\n+    pos = output_option (file, sep, \"-p\", \"\", indent, pos, max);\n+\n+  for (j = 0; j < f_len; j++)\n+    if (*f_options[j].variable == f_options[j].on_value)\n+      pos = output_option (file, sep, \"-f\", f_options[j].string,\n+\t\t\t   indent, pos, max);\n+\n+  for (j = 0; j < W_len; j++)\n+    if (*W_options[j].variable == W_options[j].on_value)\n+      pos = output_option (file, sep, \"-W\", W_options[j].string,\n+\t\t\t   indent, pos, max);\n+\n+  for (j = 0; j < sizeof m_options / sizeof m_options[0]; j++)\n+    if (m_options[j].name[0] != '\\0'\n+\t&& m_options[j].value > 0\n+\t&& ((m_options[j].value & target_flags)\n+\t    == m_options[j].value))\n+      pos = output_option (file, sep, \"-m\", m_options[j].name,\n+\t\t\t   indent, pos, max);\n+\n+  if (m88k_short_data)\n+    pos = output_option (file, sep, \"-mshort-data-\", m88k_short_data,\n+\t\t\t indent, pos, max);\n+\n+  fprintf (file, term);\n+}\n+\n+void\n+output_file_start (file, f_options, f_len, W_options, W_len)\n+     FILE *file;\n+     struct option *f_options;\n+     struct option *W_options;\n+     int f_len, W_len;\n+{\n+  register int pos;\n+\n+  ASM_FIRST_LINE (file);\n+  output_file_directive (file, main_input_filename);\n+  /* Switch to the data section so that the coffsem symbol and the\n+     gcc2_compiled. symbol aren't in the text section.  */\n+  data_section ();\n+  ASM_COFFSEM (file);\n+\n+  pos = fprintf (file, \"\\n; cc1 (%s) arguments:\", VERSION_STRING);\n+  output_options (file, f_options, f_len, W_options, W_len,\n+\t\t  pos, 75, \" \", \"\\n; \", \"\\n\\n\");\n+\n+  if (TARGET_IDENTIFY_REVISION)\n+    {\n+      char indent[256];\n+\n+      time_t now = time ((time_t *)0);\n+      sprintf (indent, \"]\\\"\\n%s\\t \\\"@(#)%s [\", IDENT_ASM_OP, main_input_filename);\n+      fprintf (file, indent+3);\n+      pos = fprintf (file, \"gcc %s, %.24s,\", VERSION_STRING, ctime (&now));\n+      output_options (file, f_options, f_len, W_options, W_len,\n+\t\t      pos, 150 - strlen (indent), \" \", indent, \"]\\\"\\n\\n\");\n+    }\n+}\n+\f\n+/* Output an ascii string.  */\n+\n+void\n+output_ascii (file, p, size)\n+     FILE *file;\n+     unsigned char *p;\n+     int size;\n+{\n+  int i;\n+\n+  register int num = 0;\n+\n+  fprintf (file, \"%s\\t \\\"\", ASCII_DATA_ASM_OP);\n+  for (i = 0; i < size; i++)\n+    {\n+      register int c = p[i];\n+\n+      if (num > 48)\n+\t{\n+\t  fprintf (file, \"\\\"\\n%s\\t \\\"\", ASCII_DATA_ASM_OP);\n+\t  num = 0;\n+\t}\n+\n+      if (c == '\\\"' || c == '\\\\')\n+\t{\n+\t  putc ('\\\\', file);\n+\t  num++;\n+\t}\n+\n+      if (c >= ' ' && c < 0177)\n+\t{\n+\t  putc (c, file);\n+\t  num++;\n+\t}\n+      else\n+\t{\n+\t  fprintf (file, \"\\\\%03o\", c);\n+\t  num += 4;\n+\t  /* After an octal-escape, if a digit follows,\n+\t     terminate one string constant and start another.\n+\t     The Vax assembler fails to stop reading the escape\n+\t     after three digits, so this is the only way we\n+\t     can get it to parse the data properly.  */\n+\t  if (i < size - 1 && p[i + 1] >= '0' && p[i + 1] <= '9')\n+\t    num = 32767;\t/* next pass will start a new string */\n+\t}\n+    }\n+  fprintf (file, \"\\\"\\n\");\n+}\n+\f\n+/* Output a label (allows insn-output.c to be compiled without including\n+   m88k.c or needing to include stdio.h).  */\n+\n+void\n+output_label (label_number)\n+     int label_number;\n+{\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", label_number);\n+}\n+\n+/* Handle a pragma directive.  HANDLE_PRAGMA conspires to parse the input\n+   following #pragma into tokens based on yylex.  */\n+\n+void\n+m88k_handle_pragma_token (string, token)\n+     char *string;\n+     tree token;\n+{\n+  static enum pragma_state\n+    {\n+      ps_start,\n+      ps_done,\n+      ps_bad,\n+      ps_weak,\n+      ps_name,\n+      ps_equals,\n+      ps_value\n+    } state;\n+  static char *name;\n+  static char *value;\n+\n+  if (HANDLE_PRAGMA_WEAK)\n+    {\n+      if (string == 0)\n+\t{\n+\t  if (state == ps_name || state == ps_value)\n+\t    {\n+\t      fprintf (asm_out_file, \"%s\\t \", WEAK_ASM_OP);\n+\t      ASM_OUTPUT_LABELREF (asm_out_file, name);\n+\t      fputc ('\\n', asm_out_file);\n+\t      if (state == ps_value)\n+\t\t{\n+\t\t  fprintf (asm_out_file, \"%s\\t \", DEF_ASM_OP);\n+\t\t  ASM_OUTPUT_LABELREF (asm_out_file, name);\n+\t\t  fputc (',', asm_out_file);\n+\t\t  ASM_OUTPUT_LABELREF (asm_out_file, value);\n+\t\t  fputc ('\\n', asm_out_file);\n+\t\t}\n+\t    }\n+\t  else if (! (state == ps_done || state == ps_start))\n+\t    warning (\"ignoring malformed #pragma weak symbol [=value]\");\n+\t  state = ps_start;\n+\t}\n+      else\n+\tswitch (state)\n+\t  {\n+\t  case ps_start:\n+\t    if (token\n+\t\t&& TREE_CODE (token) == IDENTIFIER_NODE\n+\t\t&& !strcmp (IDENTIFIER_POINTER (token), \"weak\"))\n+\t      state = ps_weak;\n+\t    else\n+\t      state = ps_done;\n+\t    break;\n+\n+\t  case ps_weak:\n+\t    if (token\n+\t\t&& TREE_CODE (token) == IDENTIFIER_NODE)\n+\t      {\n+\t\tname = IDENTIFIER_POINTER (token);\n+\t\tstate = ps_name;\n+\t      }\n+\t    else\n+\t      state = ps_bad;\n+\t    break;\n+\n+\t  case ps_name:\n+\t    state = (strcmp (string, \"=\") ? ps_bad : ps_equals);\n+\t    break;\n+\n+\t  case ps_equals:\n+\t    if (token\n+\t\t&& TREE_CODE (token) == IDENTIFIER_NODE)\n+\t      {\n+\t\tvalue = IDENTIFIER_POINTER (token);\n+\t\tstate = ps_value;\n+\t      }\n+\t    else\n+\t      state = ps_bad;\n+\t    break;\n+\n+\t  case ps_value:\n+\t    state = ps_bad;\n+\t  case ps_bad:\n+\t  case ps_done:\n+\t    break;\n+\n+\t  default:\n+\t    abort ();\n+\t  }\n+    }\n+}\n+\f\n+/* Generate the assembly code for function entry.\n+\n+   The prologue is responsible for setting up the stack frame,\n+   initializing the frame pointer register, saving registers that must be\n+   saved, and allocating SIZE additional bytes of storage for the\n+   local variables.  SIZE is an integer.  FILE is a stdio\n+   stream to which the assembler code should be output.\n+\n+   The label for the beginning of the function need not be output by this\n+   macro.  That has already been done when the macro is run.\n+\n+   To determine which registers to save, the macro can refer to the array\n+   `regs_ever_live': element R is nonzero if hard register\n+   R is used anywhere within the function.  This implies the\n+   function prologue should save register R, but not if it is one\n+   of the call-used registers.\n+\n+   On machines where functions may or may not have frame-pointers, the\n+   function entry code must vary accordingly; it must set up the frame\n+   pointer if one is wanted, and not otherwise.  To determine whether a\n+   frame pointer is in wanted, the macro can refer to the variable\n+   `frame_pointer_needed'.  The variable's value will be 1 at run\n+   time in a function that needs a frame pointer.\n+\n+   On machines where an argument may be passed partly in registers and\n+   partly in memory, this macro must examine the variable\n+   `current_function_pretend_args_size', and allocate that many bytes\n+   of uninitialized space on the stack just underneath the first argument\n+   arriving on the stack.  (This may not be at the very end of the stack,\n+   if the calling sequence has pushed anything else since pushing the stack\n+   arguments.  But usually, on such machines, nothing else has been pushed\n+   yet, because the function prologue itself does all the pushing.)\n+\n+   If `ACCUMULATE_OUTGOING_ARGS' is defined, the variable\n+   `current_function_outgoing_args_size' contains the size in bytes\n+   required for the outgoing arguments.  This macro must add that\n+   amount of uninitialized space to very bottom of the stack.\n+\n+   The stack frame we use looks like this:\n+\n+ caller                                                  callee\n+        |==============================================|\n+        |                caller's frame                |\n+        |==============================================|\n+        |     [caller's outgoing memory arguments]     |\n+        |==============================================|\n+        |  caller's outgoing argument area (32 bytes)  |\n+  sp -> |==============================================| <- ap\n+        |            [local variable space]            |\n+        |----------------------------------------------|\n+        |            [return address (r1)]             |\n+        |----------------------------------------------|\n+        |        [previous frame pointer (r30)]        |\n+        |==============================================| <- fp\n+        |       [preserved registers (r25..r14)]       |\n+        |==============================================|\n+        |    [dynamically allocated space (alloca)]    |\n+        |==============================================|\n+        |     [callee's outgoing memory arguments]     |\n+        |==============================================|\n+        | [callee's outgoing argument area (32 bytes)] |\n+        |==============================================| <- sp\n+\n+  Notes:\n+\n+  r1 and r30 must be saved if debugging.\n+\n+  fp (if present) is located two words down from the local\n+  variable space.\n+  */\n+\n+static void output_reg_adjust ();\n+static void preserve_registers ();\n+static void output_tdesc ();\n+\n+static int  nregs;\n+static char save_regs[FIRST_PSEUDO_REGISTER];\n+static int  frame_laid_out;\n+static int  frame_size;\n+static int  variable_args_p;\n+\n+extern char call_used_regs[];\n+extern int  current_function_pretend_args_size;\n+extern int  current_function_outgoing_args_size;\n+extern int  frame_pointer_needed;\n+\n+#define FIRST_OCS_PRESERVE_REGISTER\t14\n+#define LAST_OCS_PRESERVE_REGISTER\t30\n+\n+#define STACK_UNIT_BOUNDARY (STACK_BOUNDARY / BITS_PER_UNIT)\n+#define ROUND_CALL_BLOCK_SIZE(BYTES) \\\n+  (((BYTES) + (STACK_UNIT_BOUNDARY - 1)) & ~(STACK_UNIT_BOUNDARY - 1))\n+\f\n+/* Establish the position of the FP relative to the SP.  This is done\n+   either during FUNCTION_PROLOGUE or by INITIAL_ELIMINATION_OFFSET.  */\n+\n+void\n+m88k_layout_frame ()\n+{\n+  int regno, sp_size;\n+\n+  frame_laid_out++;\n+\n+  bzero ((char *) &save_regs[0], sizeof (save_regs));\n+  sp_size = nregs = 0;\n+  frame_size = get_frame_size ();\n+\n+  /* Since profiling requires a call, make sure r1 is saved.  */\n+  if (profile_flag)\n+    save_regs[1] = 1;\n+\n+  /* If we are producing debug information, store r1 and r30 where the\n+     debugger wants to find them (r30 at r30+0, r1 at r30+4).  Space has\n+     already been reserved for r1/r30 in STARTING_FRAME_OFFSET.  */\n+  if (write_symbols != NO_DEBUG && !TARGET_OCS_FRAME_POSITION)\n+    save_regs[1] = 1;\n+\n+  /* If there is a call, alloca is used, __builtin_alloca is used, or\n+     a dynamic-sized object is defined, add the 8 additional words\n+     for the callee's argument area.  The common denominator is that the\n+     FP is required.  may_call_alloca only gets calls to alloca;\n+     current_function_calls_alloca gets alloca and __builtin_alloca.  */\n+  if (regs_ever_live[1] || frame_pointer_needed)\n+    {\n+      save_regs[1] = 1;\n+      sp_size += REG_PARM_STACK_SPACE (0);\n+    }\n+\n+  /* If we are producing PIC, save the addressing base register and r1.  */\n+  if (flag_pic && current_function_uses_pic_offset_table)\n+    {\n+      save_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n+      nregs++;\n+    }\n+\n+  /* If a frame is requested, save the previous FP, and the return\n+     address (r1), so that a traceback can be done without using tdesc\n+     information.  */\n+  if (frame_pointer_needed)\n+    save_regs[FRAME_POINTER_REGNUM] = save_regs[1] = 1;\n+\n+  /* Figure out which normal register(s) needs to be saved.  */\n+  for (regno = 2; regno < FRAME_POINTER_REGNUM; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      {\n+\tsave_regs[regno] = 1;\n+\tnregs++;\n+      }\n+\n+  /* Achieve greatest use of double memory ops.  Either we end up saving\n+     r30 or we use that slot to align the regsters we do save.  */\n+  if (nregs >= 2 && save_regs[1] && !save_regs[FRAME_POINTER_REGNUM])\n+    sp_size += 4;\n+\n+  nregs += save_regs[1] + save_regs[FRAME_POINTER_REGNUM];\n+  sp_size += 4 * nregs;\n+  sp_size += current_function_outgoing_args_size;\n+\n+  /* The first two saved registers are placed above the new frame pointer\n+     if any.  In the only case this matters, they are r1 and r30. */\n+  if (frame_pointer_needed || sp_size)\n+    {\n+      m88k_fp_offset = ROUND_CALL_BLOCK_SIZE (sp_size - STARTING_FRAME_OFFSET);\n+      m88k_stack_size = m88k_fp_offset + STARTING_FRAME_OFFSET;\n+    }\n+  else\n+    {\n+      m88k_stack_size = m88k_fp_offset = 0;\n+    }\n+\n+  /* First, combine m88k_stack_size and size.  If m88k_stack_size is\n+     non-zero, align the frame size to 8 mod 16; otherwise align the\n+     frame size to 0 mod 16.  (If stacks are 8 byte aligned, this ends\n+     up as a NOP.  */\n+  {\n+    int need\n+      = ((m88k_stack_size ? STACK_UNIT_BOUNDARY - STARTING_FRAME_OFFSET : 0)\n+\t - (frame_size % STACK_UNIT_BOUNDARY));\n+    if (need)\n+      {\n+\tif (need < 0)\n+\t  need += STACK_UNIT_BOUNDARY;\n+\t(void) assign_stack_local (BLKmode, need, BITS_PER_UNIT);\n+\tframe_size = get_frame_size ();\n+      }\n+    m88k_stack_size\n+      = ROUND_CALL_BLOCK_SIZE (m88k_stack_size + frame_size\n+\t\t\t       + current_function_pretend_args_size);\n+  }\n+}\n+\n+/* Return true if this function is known to have a null epilogue.  */\n+\n+int\n+null_epilogue ()\n+{\n+  if (! reload_completed)\n+    return 0;\n+  if (! frame_laid_out)\n+    m88k_layout_frame ();\n+  return (! frame_pointer_needed\n+\t  && nregs == 0\n+\t  && m88k_stack_size == 0);\n+}\n+\n+/* Determine the number of instructions needed for the function epilogue.  */\n+\n+#define MAX_EPILOGUE_DELAY_INSNS 4\n+\n+static char epilogue_dead_regs[FIRST_PSEUDO_REGISTER];\n+\n+delay_slots_for_epilogue ()\n+{\n+  register int insns = save_regs[1] + save_regs[FRAME_POINTER_REGNUM];\n+  register int regs = nregs - insns;\n+\n+  if (regs > 3)\n+    insns += 1 + (regs & 1);\n+  else if (nregs == 4)\n+    /* This is a special cases of ld/ld/ld.d which has no start-up delay.  */\n+    return 0;\n+\n+  if (insns)\n+    {\n+      bzero ((char *) &epilogue_dead_regs[0], sizeof (epilogue_dead_regs));\n+      epilogue_dead_regs[1] = save_regs[1];\n+      epilogue_dead_regs[STACK_POINTER_REGNUM] = frame_pointer_needed;\n+      epilogue_dead_regs[TEMP_REGNUM] = ! ADD_INTVAL (m88k_fp_offset);\n+    }\n+\n+  return insns;\n+}\n+\n+/* Return 1 if X is safe to use as an epilogue insn.  */\n+\n+int\n+ok_for_epilogue_p (x)\n+     rtx x;\n+{\n+  register char *fmt;\n+  register int i, j;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case REG:\n+      for (i = REGNO (x), j = i + HARD_REGNO_NREGS (i, GET_MODE (x));\n+\t   i < j;\n+\t   i++)\n+\tif (epilogue_dead_regs[i])\n+\t  return 0;\n+\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case CONST:\n+    case PC:\n+    case CC0:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CODE_LABEL:\n+      return 1;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (!ok_for_epilogue_p (XEXP (x, i)))\n+\t    return 0;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    if (!ok_for_epilogue_p (XVECEXP (x, i, j)))\n+\t      return 0;\n+\t}\n+    }\n+  return 1;\n+}\n+\n+int\n+eligible_for_epilogue_delay (insn)\n+     rtx insn;\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_STORE:\n+    case TYPE_LOADA:\n+    case TYPE_ARITH:\n+    case TYPE_MARITH:\n+    case TYPE_MSTORE:\n+      return ok_for_epilogue_p (PATTERN (insn));\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Determine if the current function has any references to the arg pointer.\n+   This is done indirectly by examining the DECL_ARGUMENTS' DECL_RTL.\n+   It is OK to return TRUE if there are no references, but FALSE must be\n+   correct.  */\n+\n+static int\n+uses_arg_area_p ()\n+{\n+  register tree parm;\n+\n+  if (current_function_decl == 0\n+      || current_function_varargs\n+      || variable_args_p)\n+    return 1;\n+\n+  for (parm = DECL_ARGUMENTS (current_function_decl);\n+       parm;\n+       parm = TREE_CHAIN (parm))\n+    {\n+      if (DECL_RTL (parm) == 0\n+\t  || GET_CODE (DECL_RTL (parm)) == MEM)\n+\treturn 1;\n+\n+      if (DECL_INCOMING_RTL (parm) == 0\n+\t  || GET_CODE (DECL_INCOMING_RTL (parm)) == MEM)\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\f\n+void\n+m88k_output_prologue (stream, size)\n+     FILE *stream;\n+     int size;\n+{\n+  int old_fp_offset = m88k_fp_offset;\n+  int old_stack_size = m88k_stack_size;\n+\n+  m88k_layout_frame ();\n+#if (MONITOR_GCC & 0x8) /* Watch for suspicious register elimination changes.  */\n+  if (frame_laid_out > 1)\n+    {\n+      if (old_fp_offset != m88k_fp_offset)\n+\twarning (\"Internal gcc error: FP offset has changed by %d bytes\",\n+\t\t m88k_fp_offset - old_fp_offset);\n+      if (old_stack_size != m88k_stack_size)\n+\twarning (\"Internal gcc error: stack size has changed by %d bytes\",\n+\t\t m88k_stack_size - old_stack_size);\n+    }\n+#endif\n+  frame_laid_out = 0;\n+\n+  if (TARGET_OPTIMIZE_ARG_AREA\n+      && m88k_stack_size\n+      && ! uses_arg_area_p ())\n+    {\n+      /* The incoming argument area is used for stack space if it is not\n+\t used (or if -mno-use-arg-area is given).  */\n+      if ((m88k_stack_size -= REG_PARM_STACK_SPACE (0)) < 0)\n+\tm88k_stack_size = 0;\n+    }\n+\n+  if (m88k_stack_size)\n+    output_reg_adjust (stream, 31, 31, -m88k_stack_size, 0);\n+\n+  if (nregs)\n+    preserve_registers (stream, m88k_fp_offset + 4, 1);\n+\n+  if (frame_pointer_needed)\n+    output_reg_adjust (stream, 30, 31, m88k_fp_offset, 0);\n+\n+  if (TARGET_OCS_DEBUG_INFO)\n+    PUT_OCS_FUNCTION_START (stream);\n+\n+  if (flag_pic && save_regs[PIC_OFFSET_TABLE_REGNUM])\n+    {\n+      char label[256];\n+\n+      if (! save_regs[1])\n+\tfprintf (stream, \"\\tor\\t %s,%s,0\\n\",\n+\t\t reg_names[TEMP_REGNUM], reg_names[1]);\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"Lab\", m88k_function_number);\n+      fprintf (stream, \"\\tbsr.n\\t %s\\n\", &label[1]);\n+      fprintf (stream, \"\\tor.u\\t %s,%s,%shi16(%s#abdiff)\\n\",\n+\t       reg_names[PIC_OFFSET_TABLE_REGNUM], reg_names[0],\n+\t       m88k_pound_sign, &label[1]);\n+      ASM_OUTPUT_INTERNAL_LABEL (stream, \"Lab\", m88k_function_number);\n+      fprintf (stream, \"\\tor\\t %s,%s,%slo16(%s#abdiff)\\n\",\n+\t       reg_names[PIC_OFFSET_TABLE_REGNUM],\n+\t       reg_names[PIC_OFFSET_TABLE_REGNUM],\n+\t       m88k_pound_sign, &label[1]);\n+      fprintf (stream, \"\\taddu\\t %s,%s,%s\\n\",\n+\t       reg_names[PIC_OFFSET_TABLE_REGNUM],\n+\t       reg_names[PIC_OFFSET_TABLE_REGNUM], reg_names[1]);\n+      if (! save_regs[1])\n+\tfprintf (stream, \"\\tor\\t %s,%s,0\\n\",\n+\t\t reg_names[1], reg_names[TEMP_REGNUM]);\n+    }\n+\n+  m88k_prologue_done = 1;\t/* it's ok now to put out ln directives */\n+}\n+\f\n+/* This function generates the assembly code for function exit,\n+   on machines that need it.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only, if there is a frame pointer.\n+   This is mandatory because of alloca; we also take advantage of it to\n+   omit stack adjustments before returning.  */\n+\n+void\n+m88k_output_epilogue (stream, size)\n+     FILE *stream;\n+     int size;\n+{\n+  rtx insn = get_last_insn ();\n+#if (MONITOR_GCC & 0x4) /* What are interesting prologue/epiloge values?  */\n+  fprintf (stream, \"; size = %d, m88k_fp_offset = %d, m88k_stack_size = %d\\n\",\n+\t   size, m88k_fp_offset, m88k_stack_size);\n+#endif\n+\n+  output_short_branch_defs (stream);\n+\n+  if (TARGET_OCS_DEBUG_INFO)\n+    PUT_OCS_FUNCTION_END (stream);\n+\n+  /* If the last insn was a BARRIER, we don't have to write any code.  */\n+  if (GET_CODE (insn) == NOTE)\n+    insn = prev_nonnote_insn (insn);\n+  if (insn && GET_CODE (insn) == BARRIER)\n+    {\n+      if (current_function_epilogue_delay_list)\n+\tabort ();\n+    }\n+  else\n+    {\n+      if (frame_pointer_needed)\n+\toutput_reg_adjust (stream, 31, 30, -m88k_fp_offset, 0);\n+\n+      if (nregs)\n+\tpreserve_registers (stream, m88k_fp_offset + 4, 0);\n+\n+      output_reg_adjust (stream, 31, 31, m88k_stack_size, 1);\n+    }\n+\n+  fprintf (stream, \"\\n\");\n+\n+  if (TARGET_OCS_DEBUG_INFO)\n+    output_tdesc (stream, m88k_fp_offset + 4);\n+\n+  m88k_function_number++;\n+  m88k_prologue_done\t= 0;\t\t/* don't put out ln directives */\n+  variable_args_p\t= 0;\t\t/* has variable args */\n+}\n+\f\n+/* Output code to STREAM to set DSTREG to SRCREG + AMOUNT.  Issue\n+   a return instruction and use it's delay slot based on RETURN_P.  */\n+\n+static void\n+output_reg_adjust (stream, dstreg, srcreg, amount, return_p)\n+     FILE *stream;\n+     int dstreg, srcreg, amount, return_p;\n+{\n+  char *opname;\n+  char incr[256];\n+\n+  if (amount < 0)\n+    {\n+      opname = \"subu\";\n+      amount = -amount;\n+    }\n+  else\n+    opname = \"addu\";\n+\n+  if (amount == 0 && dstreg == srcreg)\n+    {\n+      if (return_p)\n+\tfprintf (stream, \"\\tjmp\\t %s\\n\", reg_names[1]);\n+      return;\n+    }\n+  else if (SMALL_INTVAL (amount))\n+    sprintf (incr, \"\\t%s\\t %s,%s,%d\", opname,\n+\t     reg_names[dstreg], reg_names[srcreg], amount);\n+  else\n+    {\n+      rtx operands[2];\n+\n+      operands[0] = gen_rtx (REG, SImode, TEMP_REGNUM);\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, amount);\n+      output_asm_insn (output_load_const_int (SImode, operands),\n+\t\t       operands);\n+      sprintf (incr, \"\\t%s\\t %s,%s,%s\", opname,\n+\t       reg_names[dstreg], reg_names[srcreg], reg_names[TEMP_REGNUM]);\n+    }\n+\n+  if (!return_p)\n+    fprintf (stream, \"%s\\n\", incr);\n+  else if (flag_delayed_branch)\n+    fprintf (stream, \"\\tjmp.n\\t %s\\n%s\\n\", reg_names[1], incr);\n+  else\n+    fprintf (stream, \"%s\\n\\tjmp\\t %s\\n\", incr, reg_names[1]);\n+}\n+\n+/* Save/restore the preserve registers.  base is the highest offset from\n+   r31 at which a register is stored.  store_p is true if stores are to\n+   be done; otherwise loads.  When loading, output the epilogue delay\n+   insns.  */\n+\n+static void\n+preserve_registers (stream, base, store_p)\n+     FILE *stream;\n+     int base;\n+     int store_p;\n+{\n+  int regno, offset;\n+  char *fmt = (store_p ? \"\\tst%s\\t %s,%s,%d\\n\" : \"\\tld%s\\t %s,%s,%d\\n\");\n+  struct mem_op {\n+    int regno;\n+    int nregs;\n+    int offset;\n+  } mem_op[FIRST_PSEUDO_REGISTER];\n+  struct mem_op *mo_ptr = mem_op;\n+\n+  /* The 88open OCS mandates that preserved registers be stored in\n+     increasing order.  For compatibility with current practice,\n+     the order is r1, r30, then the preserve registers.  */\n+\n+  offset = base;\n+  if (save_regs[1])\n+    {\n+      /* An extra word is given in this case to make best use of double\n+\t memory ops.  */\n+      if (nregs > 2 && !save_regs[FRAME_POINTER_REGNUM])\n+\toffset -= 4;\n+      fprintf (stream, fmt, \"\", reg_names[1], reg_names[31], offset);\n+      offset -= 4;\n+      base = offset;\n+    }\n+\n+  /* Walk the registers to save recording all single memory operations.  */\n+  for (regno = FRAME_POINTER_REGNUM; regno > 1; regno--)\n+    if (save_regs[regno])\n+      {\n+\tif ((offset & 7) != 4 || (regno & 1) != 1 || !save_regs[regno-1])\n+\t  {\n+\t    mo_ptr->nregs = 1;\n+\t    mo_ptr->regno = regno;\n+\t    mo_ptr->offset = offset;\n+\t    mo_ptr++;\n+\t    offset -= 4;\n+\t  }\n+        else\n+\t  {\n+\t    regno--;\n+\t    offset -= 2*4;\n+\t  }\n+      }\n+\n+  /* Walk the registers to save recording all double memory operations.\n+     This avoids a delay in the epilogue (ld.d/ld).  */\n+  offset = base;\n+  for (regno = FRAME_POINTER_REGNUM; regno > 1; regno--)\n+    if (save_regs[regno])\n+      {\n+\tif ((offset & 7) != 4 || (regno & 1) != 1 || !save_regs[regno-1])\n+\t  {\n+\t    offset -= 4;\n+\t  }\n+        else\n+\t  {\n+\t    mo_ptr->nregs = 2;\n+\t    mo_ptr->regno = regno-1;\n+\t    mo_ptr->offset = offset-4;\n+\t    mo_ptr++;\n+\t    regno--;\n+\t    offset -= 2*4;\n+\t  }\n+      }\n+  mo_ptr->regno = 0;\n+\n+  /* Output the delay insns interleaved with the memory operations.  */\n+  if (! store_p && current_function_epilogue_delay_list)\n+    {\n+      rtx delay_insns = current_function_epilogue_delay_list;\n+      rtx insn;\n+\n+      /* The first delay insn goes after the restore of r1.  */\n+      if (save_regs[1])\n+\t{\n+\t  final_scan_insn (XEXP (delay_insns, 0), stream, 1, 0, 1);\n+\t  delay_insns = XEXP (delay_insns, 1);\n+\t}\n+\n+      while (delay_insns)\n+\t{\n+\t  /* Find a memory operation that doesn't conflict with this insn.  */\n+\t  for (mo_ptr = mem_op; mo_ptr->regno != 0; mo_ptr++)\n+\t    {\n+\t      if (mo_ptr->nregs)\n+\t\t{\n+\t\t  rtx ok_insns = delay_insns;\n+\t\t  int i;\n+\n+\t\t  for (i = 0; i < mo_ptr->nregs; i++)\n+\t\t    epilogue_dead_regs[mo_ptr->regno + i] = 1;\n+\n+\t\t  while (ok_insns)\n+\t\t    {\n+\t\t      insn = XEXP (ok_insns, 0);\n+\t\t      ok_insns = XEXP (ok_insns, 1);\n+\n+\t\t      if (! ok_for_epilogue_p (PATTERN (insn)))\n+\t\t\t{\n+\t\t\t  for (i = 0; i < mo_ptr->nregs; i++)\n+\t\t\t    epilogue_dead_regs[mo_ptr->regno + i] = 0;\n+\t\t\t  insn = 0;\n+\t\t\t  break; /* foreach delay insn */\n+\t\t\t}\n+\t\t    }\n+\t\t  if (insn)\n+\t\t    {\n+\t\t      fprintf (stream, fmt, mo_ptr->nregs > 1 ? \".d\" : \"\",\n+\t\t\t       reg_names[mo_ptr->regno], reg_names[31],\n+\t\t\t       mo_ptr->offset);\n+\t\t      mo_ptr->nregs = 0;\n+\t\t      break; /* foreach memory operation */\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  final_scan_insn (XEXP (delay_insns, 0), stream, 1, 0, 1);\n+\t  delay_insns = XEXP (delay_insns, 1);\n+\t}\n+    }\n+\n+  /* Output the memory operations.  */\n+  for (mo_ptr = mem_op; mo_ptr->regno; mo_ptr++)\n+    {\n+      if (mo_ptr->nregs)\n+\tfprintf (stream, fmt, mo_ptr->nregs > 1 ? \".d\" : \"\",\n+\t\t reg_names[mo_ptr->regno], reg_names[31], mo_ptr->offset);\n+    }\n+}\n+\n+/* Convert the address expression REG to a CFA offset.  */\n+\n+int\n+m88k_debugger_offset (reg, offset)\n+     register rtx reg;\n+     register int offset;\n+{\n+  if (GET_CODE (reg) == PLUS)\n+    {\n+      offset = INTVAL (XEXP (reg, 1));\n+      reg = XEXP (reg, 0);\n+    }\n+\n+  /* Put the offset in terms of the CFA (arg pointer).  */\n+  if (reg == frame_pointer_rtx)\n+    offset += m88k_fp_offset - m88k_stack_size;\n+  else if (reg == stack_pointer_rtx)\n+    offset -= m88k_stack_size;\n+  else if (reg != arg_pointer_rtx)\n+    {\n+      if (! (GET_CODE (reg) == REG\n+\t     && REGNO (reg) >= FIRST_PSEUDO_REGISTER))\n+\t/* @@ For now, I'd like to know if this happens.  */\n+\twarning (\"Internal gcc error: Can't express symbolic location\");\n+      return 0;\n+    }\n+\n+  return offset;\n+}\n+\n+/* Output the 88open OCS proscribed text description information.\n+   The information is:\n+        0  8: zero\n+\t0 22: info-byte-length (16 bytes)\n+\t0  2: info-alignment (word 2)\n+\t1 32: info-protocol (version 1)\n+\t2 32: starting-address (inclusive, not counting prologue)\n+\t3 32: ending-address (exclusive, not counting epilog)\n+\t4  8: info-variant (version 1)\n+\t4 17: register-save-mask (from register 14 to 30)\n+\t4  1: zero\n+\t4  1: return-address-info-discriminant\n+\t4  5: frame-address-register\n+\t5 32: frame-address-offset\n+\t6 32: return-address-info\n+\t7 32: register-save-offset */\n+\n+static void\n+output_tdesc (file, offset)\n+     FILE *file;\n+     int offset;\n+{\n+  int regno, i;\n+  long mask, return_address_info, register_save_offset;\n+  char buf[256];\n+\n+  for (mask = 0, i = 0, regno = FIRST_OCS_PRESERVE_REGISTER;\n+       regno <= LAST_OCS_PRESERVE_REGISTER;\n+       regno++)\n+    {\n+      mask <<= 1;\n+      if (save_regs[regno])\n+\t{\n+\t  mask |= 1;\n+\t  i++;\n+\t}\n+    }\n+\n+  if (save_regs[1])\n+    {\n+      if (nregs > 2 && !save_regs[FRAME_POINTER_REGNUM])\n+\toffset -= 4;\n+      return_address_info = - m88k_stack_size + offset;\n+      register_save_offset = return_address_info - i*4;\n+    }\n+  else\n+    {\n+      return_address_info = 1;\n+      register_save_offset = - m88k_stack_size + offset + 4 - i*4;\n+    }\n+\n+  tdesc_section ();\n+\n+  fprintf (file, \"%s\\t %d\", INT_ASM_OP, (16 << 2) | 2 /* 8:0,22:16,2:2 */);\n+  fprintf (file, \",%d\", flag_pic ? 2 : 1);\n+\n+  ASM_GENERATE_INTERNAL_LABEL (buf, OCS_START_PREFIX, m88k_function_number);\n+  fprintf (file, \",%s%s\", buf+1, flag_pic ? \"#rel\" : \"\");\n+  ASM_GENERATE_INTERNAL_LABEL (buf, OCS_END_PREFIX, m88k_function_number);\n+  fprintf (file, \",%s%s\", buf+1, flag_pic ? \"#rel\" : \"\");\n+\n+  fprintf (file, \",0x%x\", /* 8:1,17:0x%.3x,1:0,1:%d,5:%d */\n+\t   (1 << (17+1+1+5)) |\n+\t   (mask << (1+1+5)) |\n+\t   ((!!save_regs[1]) << 5) |\n+\t   ((frame_pointer_needed\n+\t      ? FRAME_POINTER_REGNUM\n+\t      : STACK_POINTER_REGNUM)));\n+\n+  fprintf (file, \",0x%x\", (m88k_stack_size\n+\t\t\t   - (frame_pointer_needed ? m88k_fp_offset : 0)));\n+  fprintf (file, \",0x%x\", return_address_info);\n+  fprintf (file, \",0x%x\\n\", register_save_offset);\n+\n+  text_section ();\n+}\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  NAME is the mcount function name\n+   (varies), SAVEP indicates whether the parameter registers need to\n+   be saved and restored.  */\n+\n+void\n+output_function_profiler (file, labelno, name, savep)\n+     FILE *file;\n+     int labelno;\n+     char *name;\n+     int savep;\n+{\n+  char label[256];\n+  char dbi[256];\n+  char *temp = (savep ? reg_names[2] : reg_names[10]);\n+\n+  if (savep)\n+    {\n+      fprintf (file, \"\\tsubu\\t %s,%s,64\\n\", reg_names[31], reg_names[31]);\n+      fprintf (file, \"\\tst.d\\t %s,%s,32\\n\", reg_names[2], reg_names[31]);\n+      fprintf (file, \"\\tst.d\\t %s,%s,40\\n\", reg_names[4], reg_names[31]);\n+      fprintf (file, \"\\tst.d\\t %s,%s,48\\n\", reg_names[6], reg_names[31]);\n+      fprintf (file, \"\\tst.d\\t %s,%s,56\\n\", reg_names[8], reg_names[31]);\n+    }\n+\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"LP\", labelno);\n+  if (flag_pic == 2)\n+    {\n+      fprintf (file, \"\\tor.u\\t %s,%s,%shi16(%s#got_rel)\\n\",\n+\t       temp, reg_names[0], m88k_pound_sign, &label[1]);\n+      fprintf (file, \"\\tor\\t %s,%s,%slo16(%s#got_rel)\\n\",\n+\t       temp, temp, m88k_pound_sign, &label[1]);\n+      sprintf (dbi, \"\\tld\\t %s,%s,%s\\n\", temp,\n+\t       reg_names[PIC_OFFSET_TABLE_REGNUM], temp);\n+    }\n+  else if (flag_pic)\n+    {\n+      sprintf (dbi, \"\\tld\\t %s,%s,%s#got_rel\\n\", temp,\n+\t       reg_names[PIC_OFFSET_TABLE_REGNUM], &label[1]);\n+    }\n+  else\n+    {\n+      fprintf (file, \"\\tor.u\\t %s,%s,%shi16(%s)\\n\",\n+\t       temp, reg_names[0], m88k_pound_sign, &label[1]);\n+      sprintf (dbi, \"\\tor\\t %s,%s,%slo16(%s)\\n\",\n+\t       temp, temp, m88k_pound_sign, &label[1]);\n+    }\n+\n+  if (flag_pic)\n+    fprintf (file, \"\\tbsr.n\\t %s#plt\\n\", name);\n+  else\n+    fprintf (file, \"\\tbsr.n\\t %s\\n\", name);\n+  fputs (dbi, file);\n+\n+  if (savep)\n+    {\n+      fprintf (file, \"\\tld.d\\t %s,%s,32\\n\", reg_names[2], reg_names[31]);\n+      fprintf (file, \"\\tld.d\\t %s,%s,40\\n\", reg_names[4], reg_names[31]);\n+      fprintf (file, \"\\tld.d\\t %s,%s,48\\n\", reg_names[6], reg_names[31]);\n+      fprintf (file, \"\\tld.d\\t %s,%s,56\\n\", reg_names[8], reg_names[31]);\n+      fprintf (file, \"\\taddu\\t %s,%s,64\\n\", reg_names[31], reg_names[31]);\n+    }\n+}\n+\n+/* Output assembler code to FILE to initialize basic-block profiling for\n+   the current module.  LABELNO is unique to each instance.  */\n+\n+void\n+output_function_block_profiler (file, labelno)\n+     FILE *file;\n+     int labelno;\n+{\n+  char block[256];\n+  char label[256];\n+\n+  ASM_GENERATE_INTERNAL_LABEL (block, \"LPBX\", 0);\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"LPY\", labelno);\n+\n+  /* @@ Need to deal with PIC.  I'm not sure what the requirements are on\n+     register usage, so I used r26/r27 to be safe.  */\n+  fprintf (file, \"\\tor.u\\t %s,%s,%shi16(%s)\\n\", reg_names[27], reg_names[0],\n+\t\t m88k_pound_sign, &block[1]);\n+  fprintf (file, \"\\tld\\t %s,%s,%slo16(%s)\\n\", reg_names[26], reg_names[27],\n+\t\t m88k_pound_sign, &block[1]);\n+  fprintf (file, \"\\tbcnd\\t %sne0,%s,%s\\n\",\n+\t\t m88k_pound_sign, reg_names[26], &label[1]);\n+  fputs (\"\\tbsr.n\\t \", file);\n+  ASM_OUTPUT_LABELREF (file, \"__bb_init_func\");\n+  putc ('\\n', file);\n+  fprintf (file, \"\\tor\\t %s,%s,%slo16(%s)\\n\", reg_names[2], reg_names[27],\n+\t\t m88k_pound_sign, &block[1]);\n+  ASM_OUTPUT_INTERNAL_LABEL (file, \"LPY\", labelno);\n+}\n+\n+/* Output assembler code to FILE to increment the count associated with\n+   the basic block number BLOCKNO.  */\n+\n+void\n+output_block_profiler (file, blockno)\n+     FILE *file;\n+     int blockno;\n+{\n+  char block[256];\n+\n+  ASM_GENERATE_INTERNAL_LABEL (block, \"LPBX\", 0);\n+\n+  /* @@ Need to deal with PIC.  I'm not sure what the requirements are on\n+     register usage, so I used r26/r27 to be safe.  */\n+  fprintf (file, \"\\tor.u\\t %s,%s,%shi16(%s+%d)\\n\", reg_names[27], reg_names[0],\n+\t\t m88k_pound_sign, &block[1], 4 * blockno);\n+  fprintf (file, \"\\tld\\t %s,%s,%slo16(%s+%d)\\n\", reg_names[26], reg_names[27],\n+\t\t m88k_pound_sign, &block[1], 4 * blockno);\n+  fprintf (file, \"\\taddu\\t %s,%s,1\\n\", reg_names[26], reg_names[26]);\n+  fprintf (file, \"\\tst\\t %s,%s,%slo16(%s+%d)\\n\", reg_names[26], reg_names[27],\n+\t\t m88k_pound_sign, &block[1], 4 * blockno);\n+}\n+\f\n+/* Determine whether a function argument is passed in a register, and\n+   which register.\n+\n+   The arguments are CUM, which summarizes all the previous\n+   arguments; MODE, the machine mode of the argument; TYPE,\n+   the data type of the argument as a tree node or 0 if that is not known\n+   (which happens for C support library functions); and NAMED,\n+   which is 1 for an ordinary argument and 0 for nameless arguments that\n+   correspond to `...' in the called function's prototype.\n+\n+   The value of the expression should either be a `reg' RTX for the\n+   hard register in which to pass the argument, or zero to pass the\n+   argument on the stack.\n+\n+   On the m88000 the first eight words of args are normally in registers\n+   and the rest are pushed.  Double precision floating point must be\n+   double word aligned (and if in a register, starting on an even\n+   register). Structures and unions which are not 4 byte, and word\n+   aligned are passed in memory rather than registers, even if they\n+   would fit completely in the registers under OCS rules.\n+\n+   Note that FUNCTION_ARG and FUNCTION_INCOMING_ARG were different.\n+   For structures that are passed in memory, but could have been\n+   passed in registers, we first load the structure into the\n+   register, and then when the last argument is passed, we store\n+   the registers into the stack locations.  This fixes some bugs\n+   where GCC did not expect to have register arguments, followed\n+   by stack arguments, followed by register arguments.  */\n+\n+struct rtx_def *\n+m88k_function_arg (args_so_far, mode, type, named)\n+     CUMULATIVE_ARGS args_so_far;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  int bytes, words;\n+\n+  if (type != 0\t\t\t/* undo putting struct in register */\n+      && (TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE))\n+    mode = BLKmode;\n+\n+  if (mode == BLKmode && TARGET_WARN_PASS_STRUCT)\n+    warning (\"argument #%d is a structure\", args_so_far + 1);\n+\n+  if ((args_so_far & 1) != 0\n+      && (mode == DImode || mode == DFmode\n+\t  || (type != 0 && TYPE_ALIGN (type) > 32)))\n+    args_so_far++;\n+\n+#ifdef ESKIT\n+  if (no_reg_params)\n+    return (rtx) 0;             /* don't put args in registers */\n+#endif\n+\n+  if (type == 0 && mode == BLKmode)\n+    abort ();\t/* m88k_function_arg argument `type' is NULL for BLKmode. */\n+\n+  bytes = (mode != BLKmode) ? GET_MODE_SIZE (mode) : int_size_in_bytes (type);\n+  words = (bytes + 3) / 4;\n+\n+  if (args_so_far + words > 8)\n+    return (rtx) 0;             /* args have exhausted registers */\n+\n+  else if (mode == BLKmode\n+\t   && (TYPE_ALIGN (type) != BITS_PER_WORD\n+\t       || bytes != UNITS_PER_WORD))\n+    return (rtx) 0;\n+\n+  return gen_rtx (REG,\n+\t\t  ((mode == BLKmode) ? TYPE_MODE (type) : mode),\n+\t\t  2 + args_so_far);\n+}\n+\f\n+/* Do what is necessary for `va_start'.  The argument is ignored;\n+   We look at the current function to determine if stdargs or varargs\n+   is used and fill in an initial va_list.  A pointer to this constructor\n+   is returned.  */\n+\n+struct rtx_def *\n+m88k_builtin_saveregs (arglist)\n+     tree arglist;\n+{\n+  rtx block, addr, argsize;\n+  tree fntype = TREE_TYPE (current_function_decl);\n+  int argadj = ((!(TYPE_ARG_TYPES (fntype) != 0\n+\t\t   && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n+\t\t       != void_type_node)))\n+\t\t? -UNITS_PER_WORD : 0) + UNITS_PER_WORD - 1;\n+  int fixed;\n+  variable_args_p = 1;\n+\n+  if (CONSTANT_P (current_function_arg_offset_rtx))\n+    {\n+      fixed = (XINT (current_function_arg_offset_rtx, 0)\n+\t       + argadj) / UNITS_PER_WORD;\n+      argsize = gen_rtx (CONST_INT, VOIDmode, fixed);\n+    }\n+  else\n+    {\n+      fixed = 0;\n+      argsize = plus_constant (current_function_arg_offset_rtx, argadj);\n+      argsize = expand_shift (RSHIFT_EXPR, Pmode, argsize,\n+\t\t\t      build_int_2 (2, 0), argsize, 0);\n+    }\n+\n+  /* Allocate the va_list constructor */\n+  block = assign_stack_local (BLKmode, 3 * UNITS_PER_WORD, BITS_PER_UNIT);\n+  RTX_UNCHANGING_P (block) = 1;\n+  RTX_UNCHANGING_P (XEXP (block, 0)) = 1;\n+\n+  /* Store the argsize as the __va_arg member.  */\n+  emit_move_insn (change_address (block, SImode, XEXP (block, 0)),\n+\t\t  argsize);\n+\n+  /* Store the arg pointer in the __va_stk member.  */\n+  emit_move_insn (change_address (block, Pmode,\n+\t\t\t\t  plus_constant (XEXP (block, 0),\n+\t\t\t\t\t\t UNITS_PER_WORD)),\n+\t\t  copy_to_reg (virtual_incoming_args_rtx));\n+\n+  /* Allocate the register space, and store it as the __va_reg member.  */\n+  addr = assign_stack_local (BLKmode, 8 * UNITS_PER_WORD, -1);\n+  MEM_IN_STRUCT_P (addr) = 1;\n+  RTX_UNCHANGING_P (addr) = 1;\n+  RTX_UNCHANGING_P (XEXP (addr, 0)) = 1;\n+  emit_move_insn (change_address (block, Pmode,\n+\t\t\t\t  plus_constant (XEXP (block, 0),\n+\t\t\t\t\t\t 2 * UNITS_PER_WORD)),\n+\t\t  copy_to_reg (XEXP (addr, 0)));\n+\n+  /* Now store the incoming registers and return the address of the\n+     va_list constructor.  */\n+  if (fixed < 8)\n+      move_block_from_reg\n+\t(2 + fixed,\n+\t change_address (addr, Pmode,\n+\t\t\t plus_constant (XEXP (addr, 0),\n+\t\t\t\t\tfixed * UNITS_PER_WORD)),\n+\t 8 - fixed);\n+\n+  return copy_to_reg (XEXP (block, 0));\n+}\n+\f\n+/* If cmpsi has not been generated, emit code to do the test.  Return the\n+   expression describing the test of operator OP.  */\n+\n+rtx\n+emit_test (op, mode)\n+     enum rtx_code op;\n+     enum machine_mode mode;\n+{\n+  if (m88k_compare_reg == 0)\n+    emit_insn (gen_test (m88k_compare_op0, m88k_compare_op1));\n+  return (gen_rtx (op, mode, m88k_compare_reg, const0_rtx));\n+}\n+\n+/* Determine how to best perform cmpsi/bxx, where cmpsi has a constant\n+   operand.  All tests with zero (albeit swapped) and all equality tests\n+   with a constant are done with bcnd.  The remaining cases are swapped\n+   as needed.  */\n+\n+void\n+emit_bcnd (op, label)\n+     enum rtx_code op;\n+     rtx label;\n+{\n+  if (m88k_compare_op1 == const0_rtx)\n+    emit_jump_insn (optimize\n+\t\t    ? gen_bxx (emit_test (op, VOIDmode), label)\n+\t\t    : gen_bcnd (gen_rtx (op, VOIDmode,\n+\t\t\t\t\t m88k_compare_op0, const0_rtx),\n+\t\t\t\tlabel));\n+  else if (m88k_compare_op0 == const0_rtx)\n+    emit_jump_insn (optimize\n+\t\t    ? gen_bxx (emit_test (op, VOIDmode), label)\n+\t\t    : gen_bcnd (gen_rtx (swap_condition (op), VOIDmode,\n+\t\t\t\t\t m88k_compare_op1, const0_rtx),\n+\t\t\t\tlabel));\n+  else if (op != EQ && op != NE)\n+    emit_jump_insn (gen_bxx (emit_test (op, VOIDmode), label));\n+  else\n+    {\n+      rtx zero = gen_reg_rtx (SImode);\n+      rtx reg, constant;\n+      int value;\n+\n+      if (GET_CODE (m88k_compare_op1) == CONST_INT)\n+\t{\n+\t  reg = force_reg (SImode, m88k_compare_op0);\n+\t  constant = m88k_compare_op1;\n+\t}\n+      else\n+\t{\n+\t  reg = force_reg (SImode, m88k_compare_op1);\n+\t  constant = m88k_compare_op0;\n+\t}\n+      value = INTVAL (constant);\n+\n+      /* Perform an arithmetic computation to make the compared-to value\n+\t zero, but avoid loosing if the bcnd is later changed into sxx.  */\n+      if (SMALL_INTVAL (value))\n+\temit_jump_insn (gen_bxx (emit_test (op, VOIDmode), label));\n+      else\n+\t{\n+\t  if (SMALL_INTVAL (-value))\n+\t    emit_insn (gen_addsi3 (zero, reg,\n+\t\t\t\t   gen_rtx (CONST_INT, VOIDmode, -value)));\n+\t  else\n+\t    emit_insn (gen_xorsi3 (zero, reg, constant));\n+\n+\t  emit_jump_insn (gen_bcnd (gen_rtx (op, VOIDmode,\n+\t\t\t\t\t     zero, const0_rtx),\n+\t\t\t\t    label));\n+\t}\n+    }\n+}\n+\f\n+/* Print an operand.  Recognize special options, documented below.  */\n+\n+void\n+print_operand (file, x, code)\n+    FILE *file;\n+    rtx x;\n+    char code;\n+{\n+  enum rtx_code xc = (x ? GET_CODE (x) : UNKNOWN);\n+  register int value = (xc == CONST_INT ? INTVAL (x) : 0);\n+  static int sequencep;\n+  static int reversep;\n+\n+  if (sequencep)\n+    {\n+      if (code < 'B' || code > 'E')\n+\toutput_operand_lossage (\"%R not followed by %B/C/D/E\");\n+      if (reversep)\n+\txc = reverse_condition (xc);\n+      sequencep = 0;\n+    }\n+\n+  switch (code)\n+    {\n+    case '*': /* addressing base register for PIC */\n+      fputs (reg_names[PIC_OFFSET_TABLE_REGNUM], file); return;\n+\n+    case '#': /* SVR4 pound-sign syntax character (empty if SVR3) */\n+      fputs (m88k_pound_sign, file); return;\n+\n+    case 'X': /* print the upper 16 bits... */\n+      value >>= 16;\n+    case 'x': /* print the lower 16 bits of the integer constant in hex */\n+      if (xc != CONST_INT)\n+\toutput_operand_lossage (\"invalid %x/X value\");\n+      fprintf (file, \"0x%x\", value & 0xffff); return;\n+\n+    case 'H': /* print the low 16 bits of the negated integer constant */\n+      if (xc != CONST_INT)\n+\toutput_operand_lossage (\"invalid %H value\");\n+      value = -value;\n+    case 'h': /* print the register or low 16 bits of the integer constant */\n+      if (xc == REG)\n+\tgoto reg;\n+      if (xc != CONST_INT)\n+\toutput_operand_lossage (\"invalid %h value\");\n+      fprintf (file, \"%d\", value & 0xffff);\n+      return;\n+\n+    case 'Q': /* print the low 8 bits of the negated integer constant */\n+      if (xc != CONST_INT)\n+\toutput_operand_lossage (\"invalid %Q value\");\n+      value = -value;\n+    case 'q': /* print the register or low 8 bits of the integer constant */\n+      if (xc == REG)\n+\tgoto reg;\n+      if (xc != CONST_INT)\n+\toutput_operand_lossage (\"invalid %q value\");\n+      fprintf (file, \"%d\", value & 0xff);\n+      return;\n+\n+    case 'w': /* print the integer constant (X == 32 ? 0 : 32 - X) */\n+      if (xc != CONST_INT)\n+\toutput_operand_lossage (\"invalid %o value\");\n+      fprintf (file, \"%d\", value == 32 ? 0 : 32 - value);\n+      return;\n+\n+    case 'p': /* print the logarithm of the integer constant */\n+      if (xc != CONST_INT\n+\t  || (value = exact_log2 (value)) < 0)\n+\toutput_operand_lossage (\"invalid %p value\");\n+      fprintf (file, \"%d\", value);\n+      return;\n+\n+    case 'S': /* compliment the value and then... */\n+      value = ~value;\n+    case 's': /* print the width and offset values forming the integer\n+\t\t constant with a SET instruction.  See integer_ok_for_set. */\n+      {\n+\tregister unsigned mask, uval = value;\n+\tregister int top, bottom;\n+\n+\tif (xc != CONST_INT)\n+\t  output_operand_lossage (\"invalid %s/S value\");\n+\t/* All the \"one\" bits must be contiguous.  If so, MASK will be\n+\t   a power of two or zero.  */\n+\tmask = (uval | (uval - 1)) + 1;\n+\tif (!(uval && POWER_OF_2_or_0 (mask)))\n+\t  output_operand_lossage (\"invalid %s/S value\");\n+\ttop = mask ? exact_log2 (mask) : 32;\n+\tbottom = exact_log2 (uval & ~(uval - 1));\n+\tfprintf (file,\"%d<%d>\", top - bottom, bottom);\n+\treturn;\n+      }\n+\n+    case 'P': /* print nothing if pc_rtx; output label_ref */\n+      if (xc == LABEL_REF)\n+\toutput_addr_const (file, x);\n+      else if (xc != PC)\n+\toutput_operand_lossage (\"invalid %P operand\");\n+      return;\n+\n+    case 'L': /* print 0 or 1 if operand is label_ref and then...  */\n+      fputc (xc == LABEL_REF ? '1' : '0', file);\n+    case '.': /* print .n if delay slot is used */\n+      fputs ((final_sequence\n+\t      && ! INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0)))\n+\t     ? \".n\\t\" : \"\\t\", file);\n+      return;\n+\n+    case 'R': /* reverse the condition of the next print_operand\n+\t\t if operand is a label_ref.  */\n+      sequencep++;\n+      reversep = (xc == LABEL_REF);\n+      return;\n+\n+    case 'B': /* bcnd branch values */\n+      fputs (m88k_pound_sign, file);\n+      switch (xc)\n+\t{\n+\tcase EQ: fputs (\"eq0\", file); return;\n+\tcase NE: fputs (\"ne0\", file); return;\n+\tcase GT: fputs (\"gt0\", file); return;\n+\tcase LE: fputs (\"le0\", file); return;\n+\tcase LT: fputs (\"lt0\", file); return;\n+\tcase GE: fputs (\"ge0\", file); return;\n+\tdefault: output_operand_lossage (\"invalid %B value\");\n+\t}\n+\n+    case 'C': /* bb0/bb1 branch values for comparisons */\n+      fputs (m88k_pound_sign, file);\n+      switch (xc)\n+\t{\n+\tcase EQ:  fputs (\"eq\", file); return;\n+\tcase NE:  fputs (\"ne\", file); return;\n+\tcase GT:  fputs (\"gt\", file); return;\n+\tcase LE:  fputs (\"le\", file); return;\n+\tcase LT:  fputs (\"lt\", file); return;\n+\tcase GE:  fputs (\"ge\", file); return;\n+\tcase GTU: fputs (\"hi\", file); return;\n+\tcase LEU: fputs (\"ls\", file); return;\n+\tcase LTU: fputs (\"lo\", file); return;\n+\tcase GEU: fputs (\"hs\", file); return;\n+\tdefault:  output_operand_lossage (\"invalid %C value\");\n+\t}\n+\n+    case 'D': /* bcnd branch values for float comparisons */\n+      switch (xc)\n+\t{\n+\tcase EQ: fputs (\"0xa\", file); return;\n+\tcase NE: fputs (\"0x5\", file); return;\n+\tcase GT: fputs (m88k_pound_sign, file);\n+\t  fputs (\"gt0\", file); return;\n+\tcase LE: fputs (\"0xe\", file); return;\n+\tcase LT: fputs (\"0x4\", file); return;\n+\tcase GE: fputs (\"0xb\", file); return;\n+\tdefault: output_operand_lossage (\"invalid %D value\");\n+\t}\n+\n+    case 'E': /* bcnd branch values for special integers */\n+      switch (xc)\n+\t{\n+\tcase EQ: fputs (\"0x8\", file); return;\n+\tcase NE: fputs (\"0x7\", file); return;\n+\tdefault: output_operand_lossage (\"invalid %E value\");\n+\t}\n+\n+    case 'd': /* second register of a two register pair */\n+      if (xc != REG)\n+\toutput_operand_lossage (\"`%d' operand isn't a register\");\n+      fputs (reg_names[REGNO (x) + 1], file);\n+      return;\n+\n+    case 'r': /* an immediate 0 should be repesented as `r0' */\n+      if (x == const0_rtx)\n+\t{\n+\t  fputs (reg_names[0], file);\n+\t  return;\n+\t}\n+      else if (xc != REG)\n+\toutput_operand_lossage (\"invalid %r value\");\n+    case 0:\n+    name:\n+      if (xc == REG)\n+\t{\n+\treg:\n+\t  if (REGNO (x) == ARG_POINTER_REGNUM)\n+\t    output_operand_lossage (\"operand is r0\");\n+\t  else\n+\t    fputs (reg_names[REGNO (x)], file);\n+\t}\n+      else if (xc == PLUS)\n+\toutput_address (x);\n+      else if (xc == MEM)\n+\toutput_address (XEXP (x, 0));\n+      else if (xc == CONST_DOUBLE)\n+\toutput_operand_lossage (\"operand is const_double\");\n+      else\n+\toutput_addr_const (file, x);\n+      return;\n+\n+    case 'g': /* append #got_rel as needed */\n+      if (flag_pic && (xc == SYMBOL_REF || xc == LABEL_REF))\n+\t{\n+\t  output_addr_const (file, x);\n+\t  fputs (\"#got_rel\", file);\n+\t  return;\n+\t}\n+      goto name;\n+\n+    case 'a': /* (standard), assume operand is an address */\n+    case 'c': /* (standard), assume operand is an immediate value */\n+    case 'l': /* (standard), assume operand is a label_ref */\n+    case 'n': /* (standard), like %c, except negate first */\n+    default:\n+      output_operand_lossage (\"invalid code\");\n+    }\n+}\n+\n+void\n+print_operand_address (file, addr)\n+    FILE *file;\n+    rtx addr;\n+{\n+  register rtx reg0, reg1, temp;\n+\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      if (REGNO (addr) == ARG_POINTER_REGNUM)\n+\tabort ();\n+      else\n+\tfprintf (file, \"%s,%s\", reg_names[0], reg_names [REGNO (addr)]);\n+      break;\n+\n+    case LO_SUM:\n+      fprintf (file, \"%s,%slo16(\",\n+\t       reg_names[REGNO (XEXP (addr, 0))], m88k_pound_sign);\n+      output_addr_const (file, XEXP (addr, 1));\n+      fputc (')', file);\n+      break;\n+\n+    case PLUS:\n+      reg0 = XEXP (addr, 0);\n+      reg1 = XEXP (addr, 1);\n+      if (GET_CODE (reg0) == MULT || GET_CODE (reg0) == CONST_INT)\n+\t{\n+\t  rtx tmp = reg0;\n+\t  reg0 = reg1;\n+\t  reg1 = tmp;\n+\t}\n+\n+      if ((REG_P (reg0) && REGNO (reg0) == ARG_POINTER_REGNUM)\n+\t  || (REG_P (reg1) && REGNO (reg1) == ARG_POINTER_REGNUM))\n+\tabort ();\n+\n+      else if (REG_P (reg0))\n+\t{\n+\t  if (REG_P (reg1))\n+\t    fprintf (file, \"%s,%s\",\n+\t\t     reg_names [REGNO (reg0)], reg_names [REGNO (reg1)]);\n+\n+\t  else if (GET_CODE (reg1) == CONST_INT)\n+\t    fprintf (file, \"%s,%d\",\n+\t\t     reg_names [REGNO (reg0)], INTVAL (reg1));\n+\n+\t  else if (GET_CODE (reg1) == MULT)\n+\t    {\n+\t      rtx mreg = XEXP (reg1, 0);\n+\t      if (REGNO (mreg) == ARG_POINTER_REGNUM)\n+\t\tabort ();\n+\n+\t      fprintf (file, \"%s[%s]\", reg_names[REGNO (reg0)],\n+\t\t       reg_names[REGNO (mreg)]);\n+\t    }\n+\n+\t  else if (GET_CODE (reg1) == ZERO_EXTRACT)\n+\t    {\n+\t      fprintf (file, \"%s,%slo16(\",\n+\t\t       reg_names[REGNO (reg0)], m88k_pound_sign);\n+\t      output_addr_const (file, XEXP (reg1, 0));\n+\t      fputc (')', file);\n+\t    }\n+\n+\t  else if (flag_pic)\n+\t    {\n+\t      fprintf (file, \"%s,\", reg_names[REGNO (reg0)]);\n+\t      output_addr_const (file, reg1);\n+\t      fputs (\"#got_rel\", file);\n+\t    }\n+\t  else abort ();\n+\t}\n+\n+      else\n+\tabort ();\n+      break;\n+\n+    case MULT:\n+      if (REGNO (XEXP (addr, 0)) == ARG_POINTER_REGNUM)\n+\tabort ();\n+\n+      fprintf (file, \"%s[%s]\",\n+\t       reg_names[0], reg_names[REGNO (XEXP (addr, 0))]);\n+      break;\n+\n+    case LSHIFT:\n+      fprintf (file, \"%s,%shi16(\", reg_names[0], m88k_pound_sign);\n+      output_addr_const (file, XEXP (addr, 0));\n+      fputc (')', file);\n+      break;\n+\n+    case CONST_INT:\n+      fprintf (file, \"%s,%d\", reg_names[0], INTVAL (addr));\n+      break;\n+\n+    default:\n+      fprintf (file, \"%s,\", reg_names[0]);\n+      if (SHORT_ADDRESS_P (addr, temp))\n+\t{\n+\t  fprintf (file, \"%siw16(\", m88k_pound_sign);\n+\t  output_addr_const (file, addr);\n+\t  fputc (')', file);\n+\t}\n+      else\n+\t  output_addr_const (file, addr);\n+    }\n+}"}]}