{"sha": "abd418d31ff128278eefebb5bdfa39aba68b42c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJkNDE4ZDMxZmYxMjgyNzhlZWZlYmI1YmRmYTM5YWJhNjhiNDJjNA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-11-25T18:04:15Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-11-25T18:04:15Z"}, "message": "(expand_binop, expand_twoval_binop): If we are going to fail, remove any load from MEM we did due to -fforce-mem...\n\n(expand_binop, expand_twoval_binop): If we are going\nto fail, remove any load from MEM we did due to -fforce-mem;\nif the MEM was volatile, this will cause an extra load.\n\n(expand_complex_abs): Likewise.\nCorrect use of variable LAST so it doesn't include the load\nfrom MEM (to fix unrelated bug).\n\nFrom-SVN: r2797", "tree": {"sha": "216feb6fbcaabc29da41aceaf3e3a617063263d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/216feb6fbcaabc29da41aceaf3e3a617063263d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abd418d31ff128278eefebb5bdfa39aba68b42c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abd418d31ff128278eefebb5bdfa39aba68b42c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abd418d31ff128278eefebb5bdfa39aba68b42c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abd418d31ff128278eefebb5bdfa39aba68b42c4/comments", "author": null, "committer": null, "parents": [{"sha": "2ad701bad01f7a0a6ba0ace0c0c33fcacd835d30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ad701bad01f7a0a6ba0ace0c0c33fcacd835d30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ad701bad01f7a0a6ba0ace0c0c33fcacd835d30"}], "stats": {"total": 16, "additions": 14, "deletions": 2}, "files": [{"sha": "1dd2e26264d8655ecaf059206bff2157cbf080aa", "filename": "gcc/optabs.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abd418d31ff128278eefebb5bdfa39aba68b42c4/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abd418d31ff128278eefebb5bdfa39aba68b42c4/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=abd418d31ff128278eefebb5bdfa39aba68b42c4", "patch": "@@ -280,6 +280,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t\t  || binoptab->code == LSHIFTRT\n \t\t  || binoptab->code == ROTATE\n \t\t  || binoptab->code == ROTATERT);\n+  rtx entry_last = get_last_insn ();\n   rtx last;\n \n   class = GET_MODE_CLASS (mode);\n@@ -1093,7 +1094,11 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n   if (! (methods == OPTAB_WIDEN || methods == OPTAB_LIB_WIDEN\n \t || methods == OPTAB_MUST_WIDEN))\n-    return 0;\t\t\t/* Caller says, don't even try.  */\n+    {\n+      /* Caller says, don't even try.  */\n+      delete_insns_since (entry_last);\n+      return 0;\n+    }\n \n   /* Compute the value of METHODS to pass to recursive calls.\n      Don't allow widening to be tried recursively.  */\n@@ -1172,6 +1177,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t}\n     }\n \n+  delete_insns_since (entry_last);\n   return 0;\n }\n \f\n@@ -1254,6 +1260,7 @@ expand_twoval_binop (binoptab, op0, op1, targ0, targ1, unsignedp)\n   enum machine_mode mode = GET_MODE (targ0 ? targ0 : targ1);\n   enum mode_class class;\n   enum machine_mode wider_mode;\n+  rtx entry_last = get_last_insn ();\n   rtx last;\n \n   class = GET_MODE_CLASS (mode);\n@@ -1358,6 +1365,7 @@ expand_twoval_binop (binoptab, op0, op1, targ0, targ1, unsignedp)\n \t}\n     }\n \n+  delete_insns_since (entry_last);\n   return 0;\n }\n \f\n@@ -1651,7 +1659,8 @@ expand_complex_abs (mode, op0, target, unsignedp)\n   enum mode_class class = GET_MODE_CLASS (mode);\n   enum machine_mode wider_mode;\n   register rtx temp;\n-  rtx last = get_last_insn ();\n+  rtx entry_last = get_last_insn ();\n+  rtx last;\n   rtx pat;\n \n   /* Find the correct mode for the real and imaginary parts.  */\n@@ -1670,6 +1679,8 @@ expand_complex_abs (mode, op0, target, unsignedp)\n       op0 = force_not_mem (op0);\n     }\n \n+  last = get_last_insn ();\n+\n   if (target)\n     target = protect_from_queue (target, 1);\n \n@@ -1819,6 +1830,7 @@ expand_complex_abs (mode, op0, target, unsignedp)\n \t}\n     }\n \n+  delete_insns_since (entry_last);\n   return 0;\n }\n \f"}]}