{"sha": "d1d01a66012a93cc8cb7dafbe1b5ec453ec96b59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFkMDFhNjYwMTJhOTNjYzhjYjdkYWZiZTFiNWVjNDUzZWM5NmI1OQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-04-13T08:12:03Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-04-27T09:06:33Z"}, "message": "tree-optimization/100051 - disambiguate access size vs decl\n\nThis adds disambiguation of the access size vs. the decl size\nin the pointer based vs. decl based disambiguator.  We have\na TBAA based check like this already but that's fend off when\nseeing alias-sets of zero or when -fno-strict-aliasing is in\neffect.  Also the perceived dynamic type could be smaller than\nthe actual access.\n\n2021-04-13  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/100051\n\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Add\n\tdisambiguator based on access size vs. decl size.\n\n\t* gcc.dg/tree-ssa/ssa-fre-92.c: New testcase.", "tree": {"sha": "4439a797fdaa7981d36b092f7383c582267d4b90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4439a797fdaa7981d36b092f7383c582267d4b90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1d01a66012a93cc8cb7dafbe1b5ec453ec96b59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1d01a66012a93cc8cb7dafbe1b5ec453ec96b59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1d01a66012a93cc8cb7dafbe1b5ec453ec96b59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1d01a66012a93cc8cb7dafbe1b5ec453ec96b59/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfdc02bf29670c1c7f5f2820b6db11c66c258716", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfdc02bf29670c1c7f5f2820b6db11c66c258716", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfdc02bf29670c1c7f5f2820b6db11c66c258716"}], "stats": {"total": 32, "additions": 32, "deletions": 0}, "files": [{"sha": "c67fcea5e930cf731f895662b1835b1184991ee6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-92.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d01a66012a93cc8cb7dafbe1b5ec453ec96b59/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-92.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d01a66012a93cc8cb7dafbe1b5ec453ec96b59/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-92.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-92.c?ref=d1d01a66012a93cc8cb7dafbe1b5ec453ec96b59", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-fre1\" } */\n+\n+extern void foo(void);\n+int a, c, *f, **d = &f;\n+char b;\n+int main()\n+{\n+  if (a) {\n+    b = 0;\n+    int *g = &c;\n+    *g = 0;\n+    f = *d;\n+    *d = f;\n+    if ((2 ^ b) == 0)\n+      foo();\n+  }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"foo\" \"fre1\" } } */"}, {"sha": "6c7d2f1b7e02d42475e791bf7d936245e81c5c0f", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1d01a66012a93cc8cb7dafbe1b5ec453ec96b59/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1d01a66012a93cc8cb7dafbe1b5ec453ec96b59/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=d1d01a66012a93cc8cb7dafbe1b5ec453ec96b59", "patch": "@@ -2034,6 +2034,17 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   if (TREE_CODE (base1) != TARGET_MEM_REF\n       && !ranges_maybe_overlap_p (offset1 + moff, -1, offset2, max_size2))\n     return false;\n+\n+  /* If the pointer based access is bigger than the variable they cannot\n+     alias.  This is similar to the check below where we use TBAA to\n+     increase the size of the pointer based access based on the dynamic\n+     type of a containing object we can infer from it.  */\n+  poly_int64 dsize2;\n+  if (known_size_p (size1)\n+      && poly_int_tree_p (DECL_SIZE (base2), &dsize2)\n+      && known_lt (dsize2, size1))\n+    return false;\n+\n   /* They also cannot alias if the pointer may not point to the decl.  */\n   if (!ptr_deref_may_alias_decl_p (ptr1, base2))\n     return false;"}]}