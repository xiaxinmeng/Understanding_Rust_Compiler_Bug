{"sha": "ab3b0e51e9f71696232c49745bc6b7c027f39d73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIzYjBlNTFlOWY3MTY5NjIzMmM0OTc0NWJjNmI3YzAyN2YzOWQ3Mw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-05-02T18:44:28Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-05-02T18:44:28Z"}, "message": "Initial revision\n\nFrom-SVN: r19", "tree": {"sha": "e8ccd4aff8b6e1d3a62088e5f51aa83444b7948a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8ccd4aff8b6e1d3a62088e5f51aa83444b7948a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab3b0e51e9f71696232c49745bc6b7c027f39d73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab3b0e51e9f71696232c49745bc6b7c027f39d73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab3b0e51e9f71696232c49745bc6b7c027f39d73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab3b0e51e9f71696232c49745bc6b7c027f39d73/comments", "author": null, "committer": null, "parents": [{"sha": "d5c335d796a32c8a3bdaf86e7e4ce1eb90f0a741", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c335d796a32c8a3bdaf86e7e4ce1eb90f0a741", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5c335d796a32c8a3bdaf86e7e4ce1eb90f0a741"}], "stats": {"total": 482, "additions": 482, "deletions": 0}, "files": [{"sha": "e51cdf8c51168cfa866609c7e8dcdf862c529d00", "filename": "gcc/ginclude/math-68881.h", "status": "added", "additions": 482, "deletions": 0, "changes": 482, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab3b0e51e9f71696232c49745bc6b7c027f39d73/gcc%2Fginclude%2Fmath-68881.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab3b0e51e9f71696232c49745bc6b7c027f39d73/gcc%2Fginclude%2Fmath-68881.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fmath-68881.h?ref=ab3b0e51e9f71696232c49745bc6b7c027f39d73", "patch": "@@ -0,0 +1,482 @@\n+/******************************************************************\\\n+*\t\t\t\t\t\t\t\t   *\n+*  <math-68881.h>\t\tlast modified: 18 May 1989.\t   *\n+*\t\t\t\t\t\t\t\t   *\n+*  Copyright (C) 1989 by Matthew Self.\t\t\t\t   *\n+*  You may freely distribute verbatim copies of this software\t   *\n+*  provided that this copyright notice is retained in all copies.  *\n+*  You may distribute modifications to this software under the     *\n+*  conditions above if you also clearly note such modifications    *\n+*  with their author and date.\t\t\t   \t     \t   *\n+*\t\t\t\t\t\t\t\t   *\n+*  Note:  errno is not set to EDOM when domain errors occur for    *\n+*  most of these functions.  Rather, it is assumed that the\t   *\n+*  68881's OPERR exception will be enabled and handled\t\t   *\n+*  appropriately by the\toperating system.  Similarly, overflow\t   *\n+*  and underflow do not set errno to ERANGE.\t\t\t   *\n+*\t\t\t\t\t\t\t\t   *\n+*  Send bugs to Matthew Self (self@bayes.arc.nasa.gov).\t\t   *\n+*\t\t\t\t\t\t\t\t   *\n+\\******************************************************************/\n+\n+/* Changed by Richard Stallman: % inserted before a #.\n+   New function `hypot' added.\n+   Nans written in hex to avoid 0rnan.\n+   December 1989, add parens around `&' in pow.\n+   November 1990, added alternate definition of HUGE_VAL for Sun.  */\n+\n+#include <errno.h>\n+\n+#ifndef HUGE_VAL\n+#ifdef __sun__\n+/* The Sun assembler fails to handle the hex constant in the usual defn.  */\n+#define HUGE_VAL\t\t\t\t\t\t\t\\\n+({\t\t\t\t\t\t\t\t\t\\\n+  static union { int i[2]; double d; } u = { {0x7ff00000, 0} };\t\t\\\n+  u.d;\t\t\t\t\t\t\t\t\t\\\n+})\n+#else\n+#define HUGE_VAL\t\t\t\t\t\t\t\\\n+({\t\t\t\t\t\t\t\t\t\\\n+  double huge_val;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  __asm (\"fmove%.d %#0x7ff0000000000000,%0\"\t/* Infinity */\t\t\\\n+\t : \"=f\" (huge_val)\t\t\t\t\t\t\\\n+\t : /* no inputs */);\t\t\t\t\t\t\\\n+  huge_val;\t\t\t\t\t\t\t\t\\\n+})\n+#endif\n+#endif\n+\n+__inline static const double sin (double x)\n+{\n+  double value;\n+\n+  __asm (\"fsin%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double cos (double x)\n+{\n+  double value;\n+\n+  __asm (\"fcos%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double tan (double x)\n+{\n+  double value;\n+\n+  __asm (\"ftan%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double asin (double x)\n+{\n+  double value;\n+\n+  __asm (\"fasin%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double acos (double x)\n+{\n+  double value;\n+\n+  __asm (\"facos%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double atan (double x)\n+{\n+  double value;\n+\n+  __asm (\"fatan%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double atan2 (double y, double x)\n+{\n+  double pi, pi_over_2;\n+\n+  __asm (\"fmovecr%.x %#0,%0\"\t\t/* extended precision pi */\n+\t : \"=f\" (pi)\n+\t : /* no inputs */ );\n+  __asm (\"fscale%.b %#-1,%0\"\t\t/* no loss of accuracy */\n+\t : \"=f\" (pi_over_2)\n+\t : \"0\" (pi));\n+  if (x > 0)\n+    {\n+      if (y > 0)\n+\t{\n+\t  if (x > y)\n+\t    return atan (y / x);\n+\t  else\n+\t    return pi_over_2 - atan (x / y);\n+\t}\n+      else\n+\t{\n+\t  if (x > -y)\n+\t    return atan (y / x);\n+\t  else\n+\t    return - pi_over_2 - atan (x / y);\n+\t}\n+    }\n+  else\n+    {\n+      if (y > 0)\n+\t{\n+\t  if (-x > y)\n+\t    return pi + atan (y / x);\n+\t  else\n+\t    return pi_over_2 - atan (x / y);\n+\t}\n+      else\n+\t{\n+\t  if (-x > -y)\n+\t    return - pi + atan (y / x);\n+\t  else if (y < 0)\n+\t    return - pi_over_2 - atan (x / y);\n+\t  else\n+\t    {\n+\t      double value;\n+\n+\t      errno = EDOM;\n+\t      __asm (\"fmove%.d %#0x7fffffffffffffff,%0\" \t/* quiet NaN */\n+\t\t     : \"=f\" (value)\n+\t\t     : /* no inputs */);\n+\t      return value;\n+\t    }\n+\t}\n+    }\n+}\n+\n+__inline static const double sinh (double x)\n+{\n+  double value;\n+\n+  __asm (\"fsinh%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double cosh (double x)\n+{\n+  double value;\n+\n+  __asm (\"fcosh%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double tanh (double x)\n+{\n+  double value;\n+\n+  __asm (\"ftanh%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double atanh (double x)\n+{\n+  double value;\n+\n+  __asm (\"fatanh%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double exp (double x)\n+{\n+  double value;\n+\n+  __asm (\"fetox%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double expm1 (double x)\n+{\n+  double value;\n+\n+  __asm (\"fetoxm1%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double log (double x)\n+{\n+  double value;\n+\n+  __asm (\"flogn%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double log1p (double x)\n+{\n+  double value;\n+\n+  __asm (\"flognp1%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double log10 (double x)\n+{\n+  double value;\n+\n+  __asm (\"flog10%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double sqrt (double x)\n+{\n+  double value;\n+\n+  __asm (\"fsqrt%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double hypot (const double x, const double y)\n+{\n+  return sqrt (x*x + y*y);\n+}\n+\n+__inline static const double pow (const double x, const double y)\n+{\n+  if (x > 0)\n+    return exp (y * log (x));\n+  else if (x == 0)\n+    {\n+      if (y > 0)\n+\treturn 0.0;\n+      else\n+\t{\n+\t  double value;\n+\n+\t  errno = EDOM;\n+\t  __asm (\"fmove%.d %#07fffffffffffffff,%0\"\t\t/* quiet NaN */\n+\t\t : \"=f\" (value)\n+\t\t : /* no inputs */);\n+\t  return value;\n+\t}\n+    }\n+  else\n+    {\n+      double temp;\n+\n+      __asm (\"fintrz%.x %1,%0\"\n+\t     : \"=f\" (temp)\t\t\t/* integer-valued float */\n+\t     : \"f\" (y));\n+      if (y == temp)\n+        {\n+\t  int i = (int) y;\n+\t  \n+\t  if (i & 1 == 0)\t\t\t/* even */\n+\t    return exp (y * log (-x));\n+\t  else\n+\t    return - exp (y * log (-x));\n+        }\n+      else\n+        {\n+\t  double value;\n+\n+\t  errno = EDOM;\n+\t  __asm (\"fmove%.d %#0x7fffffffffffffff,%0\"\t\t/* quiet NaN */\n+\t\t : \"=f\" (value)\n+\t\t : /* no inputs */);\n+\t  return value;\n+        }\n+    }\n+}\n+\n+__inline static const double fabs (double x)\n+{\n+  double value;\n+\n+  __asm (\"fabs%.x %1,%0\"\n+\t : \"=f\" (value)\n+\t : \"f\" (x));\n+  return value;\n+}\n+\n+__inline static const double ceil (double x)\n+{\n+  int rounding_mode, round_up;\n+  double value;\n+\n+  __asm volatile (\"fmove%.l fpcr,%0\"\n+\t\t  : \"=dm\" (rounding_mode)\n+\t\t  : /* no inputs */ );\n+  round_up = rounding_mode | 0x30;\n+  __asm volatile (\"fmove%.l %0,fpcr\"\n+\t\t  : /* no outputs */\n+\t\t  : \"dmi\" (round_up));\n+  __asm volatile (\"fint%.x %1,%0\"\n+\t\t  : \"=f\" (value)\n+\t\t  : \"f\" (x));\n+  __asm volatile (\"fmove%.l %0,fpcr\"\n+\t\t  : /* no outputs */\n+\t\t  : \"dmi\" (rounding_mode));\n+  return value;\n+}\n+\n+__inline static const double floor (double x)\n+{\n+  int rounding_mode, round_down;\n+  double value;\n+\n+  __asm volatile (\"fmove%.l fpcr,%0\"\n+\t\t  : \"=dm\" (rounding_mode)\n+\t\t  : /* no inputs */ );\n+  round_down = (rounding_mode & ~0x10)\n+\t\t| 0x20;\n+  __asm volatile (\"fmove%.l %0,fpcr\"\n+\t\t  : /* no outputs */\n+\t\t  : \"dmi\" (round_down));\n+  __asm volatile (\"fint%.x %1,%0\"\n+\t\t  : \"=f\" (value)\n+\t\t  : \"f\" (x));\n+  __asm volatile (\"fmove%.l %0,fpcr\"\n+\t\t  : /* no outputs */\n+\t\t  : \"dmi\" (rounding_mode));\n+  return value;\n+}\n+\n+__inline static const double rint (double x)\n+{\n+  int rounding_mode, round_nearest;\n+  double value;\n+\n+  __asm volatile (\"fmove%.l fpcr,%0\"\n+\t\t  : \"=dm\" (rounding_mode)\n+\t\t  : /* no inputs */ );\n+  round_nearest = rounding_mode & ~0x30;\n+  __asm volatile (\"fmove%.l %0,fpcr\"\n+\t\t  : /* no outputs */\n+\t\t  : \"dmi\" (round_nearest));\n+  __asm volatile (\"fint%.x %1,%0\"\n+\t\t  : \"=f\" (value)\n+\t\t  : \"f\" (x));\n+  __asm volatile (\"fmove%.l %0,fpcr\"\n+\t\t  : /* no outputs */\n+\t\t  : \"dmi\" (rounding_mode));\n+  return value;\n+}\n+\n+__inline static const double fmod (double x, double y)\n+{\n+  double value;\n+\n+  __asm (\"fmod%.x %2,%0\"\n+\t : \"=f\" (value)\n+\t : \"0\" (x),\n+\t   \"f\" (y));\n+  return value;\n+}\n+\n+__inline static const double drem (double x, double y)\n+{\n+  double value;\n+\n+  __asm (\"frem%.x %2,%0\"\n+\t : \"=f\" (value)\n+\t : \"0\" (x),\n+\t   \"f\" (y));\n+  return value;\n+}\n+\n+__inline static const double scalb (double x, int n)\n+{\n+  double value;\n+\n+  __asm (\"fscale%.l %2,%0\"\n+\t : \"=f\" (value)\n+\t : \"0\" (x),\n+\t   \"dmi\" (n));\n+  return value;\n+}\n+\n+__inline static double logb (double x)\n+{\n+  double exponent;\n+\n+  __asm (\"fgetexp%.x %1,%0\"\n+\t : \"=f\" (exponent)\n+\t : \"f\" (x));\n+  return exponent;\n+}\n+\n+__inline static const double ldexp (double x, int n)\n+{\n+  double value;\n+\n+  __asm (\"fscale%.l %2,%0\"\n+\t : \"=f\" (value)\n+\t : \"0\" (x),\n+\t   \"dmi\" (n));\n+  return value;\n+}\n+\n+__inline static double frexp (double x, int *exp)\n+{\n+  double float_exponent;\n+  int int_exponent;\n+  double mantissa;\n+\n+  __asm (\"fgetexp%.x %1,%0\"\n+\t : \"=f\" (float_exponent) \t/* integer-valued float */\n+\t : \"f\" (x));\n+  int_exponent = (int) float_exponent;\n+  __asm (\"fgetman%.x %1,%0\"\n+\t : \"=f\" (mantissa)\t\t/* 1.0 <= mantissa < 2.0 */\n+\t : \"f\" (x));\n+  if (mantissa != 0)\n+    {\n+      __asm (\"fscale%.b %#-1,%0\"\n+\t     : \"=f\" (mantissa)\t\t/* mantissa /= 2.0 */\n+\t     : \"0\" (mantissa));\n+      int_exponent += 1;\n+    }\n+  *exp = int_exponent;\n+  return mantissa;\n+}\n+\n+__inline static double modf (double x, double *ip)\n+{\n+  double temp;\n+\n+  __asm (\"fintrz%.x %1,%0\"\n+\t : \"=f\" (temp)\t\t\t/* integer-valued float */\n+\t : \"f\" (x));\n+  *ip = temp;\n+  return x - temp;\n+}\n+"}]}