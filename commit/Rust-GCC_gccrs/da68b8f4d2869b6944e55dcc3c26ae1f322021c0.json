{"sha": "da68b8f4d2869b6944e55dcc3c26ae1f322021c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE2OGI4ZjRkMjg2OWI2OTQ0ZTU1ZGNjM2MyNmFlMWYzMjIwMjFjMA==", "commit": {"author": {"name": "Sebastian Pop", "email": "s.pop@samsung.com", "date": "2015-09-29T16:33:45Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-09-29T16:33:45Z"}, "message": "remove dead code of commutative_reductions\n\nThis code is not used anymore after we removed the previous loop optimizer (not\nbased on the ISL scheduler.)  We will add back the detection of commutative\nreductions after we improve the code generation of scalar dependences (by not\ngoing out of SSA for scalar dependences just to expose them to the data\ndependence graph.)\n\nPatch passed bootstrap and check on x86_64-linux with ISL-0.15.\n\n2015-09-29  Sebastian Pop  <s.pop@samsung.com>\n            Aditya Kumar  <aditya.k7@samsung.com>\n\n            * graphite-sese-to-poly.c (gsi_for_phi_node): Remove.\n            (nb_data_writes_in_bb): Remove.\n            (split_pbb): Remove.\n            (split_reduction_stmt): Remove.\n            (is_reduction_operation_p): Remove.\n            (phi_contains_arg): Remove.\n            (follow_ssa_with_commutative_ops): Remove.\n            (detect_commutative_reduction_arg): Remove.\n            (detect_commutative_reduction_assign): Remove.\n            (follow_inital_value_to_phi): Remove.\n            (edge_initial_value_for_loop_phi): Remove.\n            (initial_value_for_loop_phi): Remove.\n            (used_outside_reduction): Remove.\n            (detect_commutative_reduction): Remove.\n            (translate_scalar_reduction_to_array_for_stmt): Remove.\n            (remove_phi): Remove.\n            (dr_indices_valid_in_loop): Remove.\n            (close_phi_written_to_memory): Remove.\n            (translate_scalar_reduction_to_array): Remove.\n            (rewrite_commutative_reductions_out_of_ssa_close_phi): Remove.\n            (rewrite_commutative_reductions_out_of_ssa_loop): Remove.\n            (rewrite_commutative_reductions_out_of_ssa): Remove.\n            (build_poly_scop): Remove call to rewrite_commutative_reductions_out_of_ssa.\n\nCo-Authored-By: Aditya Kumar <aditya.k7@samsung.com>\n\nFrom-SVN: r228255", "tree": {"sha": "c2ec2dbc1e2550ac1dce3b3d290acd70d0286c42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2ec2dbc1e2550ac1dce3b3d290acd70d0286c42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da68b8f4d2869b6944e55dcc3c26ae1f322021c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da68b8f4d2869b6944e55dcc3c26ae1f322021c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da68b8f4d2869b6944e55dcc3c26ae1f322021c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da68b8f4d2869b6944e55dcc3c26ae1f322021c0/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a53378d25f1661271ce304c86be04a250c9fcdeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a53378d25f1661271ce304c86be04a250c9fcdeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a53378d25f1661271ce304c86be04a250c9fcdeb"}], "stats": {"total": 629, "additions": 27, "deletions": 602}, "files": [{"sha": "49932412919b7f56cb5214070abdf1b1fad5ce5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da68b8f4d2869b6944e55dcc3c26ae1f322021c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da68b8f4d2869b6944e55dcc3c26ae1f322021c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da68b8f4d2869b6944e55dcc3c26ae1f322021c0", "patch": "@@ -1,3 +1,30 @@\n+2015-09-29  Sebastian Pop  <s.pop@samsung.com>\n+            Aditya Kumar  <aditya.k7@samsung.com>\n+\n+            * graphite-sese-to-poly.c (gsi_for_phi_node): Remove.\n+            (nb_data_writes_in_bb): Remove.\n+            (split_pbb): Remove.\n+            (split_reduction_stmt): Remove.\n+            (is_reduction_operation_p): Remove.\n+            (phi_contains_arg): Remove.\n+            (follow_ssa_with_commutative_ops): Remove.\n+            (detect_commutative_reduction_arg): Remove.\n+            (detect_commutative_reduction_assign): Remove.\n+            (follow_inital_value_to_phi): Remove.\n+            (edge_initial_value_for_loop_phi): Remove.\n+            (initial_value_for_loop_phi): Remove.\n+            (used_outside_reduction): Remove.\n+            (detect_commutative_reduction): Remove.\n+            (translate_scalar_reduction_to_array_for_stmt): Remove.\n+            (remove_phi): Remove.\n+            (dr_indices_valid_in_loop): Remove.\n+            (close_phi_written_to_memory): Remove.\n+            (translate_scalar_reduction_to_array): Remove.\n+            (rewrite_commutative_reductions_out_of_ssa_close_phi): Remove.\n+            (rewrite_commutative_reductions_out_of_ssa_loop): Remove.\n+            (rewrite_commutative_reductions_out_of_ssa): Remove.\n+            (build_poly_scop): Remove call to rewrite_commutative_reductions_out_of_ssa.\n+\n 2015-09-29  Evandro Menezes  <e.menezes@samsung.com>\n \n \t* config/arm/types.md (neon_ldp, neon_ldp_q, neon_stp, neon_stp_q):"}, {"sha": "26f75e991211fbf3eae744368ec491f6203514d9", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 0, "deletions": 602, "changes": 602, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da68b8f4d2869b6944e55dcc3c26ae1f322021c0/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da68b8f4d2869b6944e55dcc3c26ae1f322021c0/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=da68b8f4d2869b6944e55dcc3c26ae1f322021c0", "patch": "@@ -1919,22 +1919,6 @@ build_scop_drs (scop_p scop)\n     build_pbb_drs (pbb);\n }\n \n-/* Return a gsi at the position of the phi node STMT.  */\n-\n-static gphi_iterator\n-gsi_for_phi_node (gphi *stmt)\n-{\n-  gphi_iterator psi;\n-  basic_block bb = gimple_bb (stmt);\n-\n-  for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n-    if (stmt == psi.phi ())\n-      return psi;\n-\n-  gcc_unreachable ();\n-  return psi;\n-}\n-\n /* Analyze all the data references of STMTS and add them to the\n    GBB_DATA_REFS vector of BB.  */\n \n@@ -2515,590 +2499,6 @@ nb_pbbs_in_loops (scop_p scop)\n   return res;\n }\n \n-/* Return the number of data references in BB that write in\n-   memory.  */\n-\n-static int\n-nb_data_writes_in_bb (basic_block bb)\n-{\n-  int res = 0;\n-  gimple_stmt_iterator gsi;\n-\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    if (gimple_vdef (gsi_stmt (gsi)))\n-      res++;\n-\n-  return res;\n-}\n-\n-/* Splits at STMT the basic block BB represented as PBB in the\n-   polyhedral form.  */\n-\n-static edge\n-split_pbb (scop_p scop, poly_bb_p pbb, basic_block bb, gimple *stmt)\n-{\n-  edge e1 = split_block (bb, stmt);\n-  new_pbb_from_pbb (scop, pbb, e1->dest);\n-  return e1;\n-}\n-\n-/* Splits STMT out of its current BB.  This is done for reduction\n-   statements for which we want to ignore data dependences.  */\n-\n-static basic_block\n-split_reduction_stmt (scop_p scop, gimple *stmt)\n-{\n-  basic_block bb = gimple_bb (stmt);\n-  poly_bb_p pbb = pbb_from_bb (bb);\n-  gimple_bb_p gbb = gbb_from_bb (bb);\n-  edge e1;\n-  int i;\n-  data_reference_p dr;\n-\n-  /* Do not split basic blocks with no writes to memory: the reduction\n-     will be the only write to memory.  */\n-  if (nb_data_writes_in_bb (bb) == 0\n-      /* Or if we have already marked BB as a reduction.  */\n-      || PBB_IS_REDUCTION (pbb_from_bb (bb)))\n-    return bb;\n-\n-  e1 = split_pbb (scop, pbb, bb, stmt);\n-\n-  /* Split once more only when the reduction stmt is not the only one\n-     left in the original BB.  */\n-  if (!gsi_one_before_end_p (gsi_start_nondebug_bb (bb)))\n-    {\n-      gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-      gsi_prev (&gsi);\n-      e1 = split_pbb (scop, pbb, bb, gsi_stmt (gsi));\n-    }\n-\n-  /* A part of the data references will end in a different basic block\n-     after the split: move the DRs from the original GBB to the newly\n-     created GBB1.  */\n-  FOR_EACH_VEC_ELT (GBB_DATA_REFS (gbb), i, dr)\n-    {\n-      basic_block bb1 = gimple_bb (DR_STMT (dr));\n-\n-      if (bb1 != bb)\n-\t{\n-\t  gimple_bb_p gbb1 = gbb_from_bb (bb1);\n-\t  GBB_DATA_REFS (gbb1).safe_push (dr);\n-\t  GBB_DATA_REFS (gbb).ordered_remove (i);\n-\t  i--;\n-\t}\n-    }\n-\n-  return e1->dest;\n-}\n-\n-/* Return true when stmt is a reduction operation.  */\n-\n-static inline bool\n-is_reduction_operation_p (gimple *stmt)\n-{\n-  enum tree_code code;\n-\n-  gcc_assert (is_gimple_assign (stmt));\n-  code = gimple_assign_rhs_code (stmt);\n-\n-  if (!commutative_tree_code (code)\n-      || !associative_tree_code (code))\n-    return false;\n-\n-  tree type = TREE_TYPE (gimple_assign_lhs (stmt));\n-\n-  if (FLOAT_TYPE_P (type))\n-    return flag_associative_math;\n-\n-  if (ANY_INTEGRAL_TYPE_P (type))\n-    return (TYPE_OVERFLOW_WRAPS (type)\n-\t    || !operation_can_overflow (code));\n-\n-  return false;\n-}\n-\n-/* Returns true when PHI contains an argument ARG.  */\n-\n-static bool\n-phi_contains_arg (gphi *phi, tree arg)\n-{\n-  size_t i;\n-\n-  for (i = 0; i < gimple_phi_num_args (phi); i++)\n-    if (operand_equal_p (arg, gimple_phi_arg_def (phi, i), 0))\n-      return true;\n-\n-  return false;\n-}\n-\n-/* Return a loop phi node that corresponds to a reduction containing LHS.  */\n-\n-static gphi *\n-follow_ssa_with_commutative_ops (tree arg, tree lhs)\n-{\n-  gimple *stmt;\n-\n-  if (TREE_CODE (arg) != SSA_NAME)\n-    return NULL;\n-\n-  stmt = SSA_NAME_DEF_STMT (arg);\n-\n-  if (gimple_code (stmt) == GIMPLE_NOP\n-      || gimple_code (stmt) == GIMPLE_CALL)\n-    return NULL;\n-\n-  if (gphi *phi = dyn_cast <gphi *> (stmt))\n-    {\n-      if (phi_contains_arg (phi, lhs))\n-\treturn phi;\n-      return NULL;\n-    }\n-\n-  if (!is_gimple_assign (stmt))\n-    return NULL;\n-\n-  if (gimple_num_ops (stmt) == 2)\n-    return follow_ssa_with_commutative_ops (gimple_assign_rhs1 (stmt), lhs);\n-\n-  if (is_reduction_operation_p (stmt))\n-    {\n-      gphi *res\n-\t= follow_ssa_with_commutative_ops (gimple_assign_rhs1 (stmt), lhs);\n-\n-      return res ? res :\n-\tfollow_ssa_with_commutative_ops (gimple_assign_rhs2 (stmt), lhs);\n-    }\n-\n-  return NULL;\n-}\n-\n-/* Detect commutative and associative scalar reductions starting at\n-   the STMT.  Return the phi node of the reduction cycle, or NULL.  */\n-\n-static gphi *\n-detect_commutative_reduction_arg (tree lhs, gimple *stmt, tree arg,\n-\t\t\t\t  vec<gimple *> *in,\n-\t\t\t\t  vec<gimple *> *out)\n-{\n-  gphi *phi = follow_ssa_with_commutative_ops (arg, lhs);\n-\n-  if (!phi)\n-    return NULL;\n-\n-  in->safe_push (stmt);\n-  out->safe_push (stmt);\n-  return phi;\n-}\n-\n-/* Detect commutative and associative scalar reductions starting at\n-   STMT.  Return the phi node of the reduction cycle, or NULL.  */\n-\n-static gphi *\n-detect_commutative_reduction_assign (gimple *stmt, vec<gimple *> *in,\n-\t\t\t\t     vec<gimple *> *out)\n-{\n-  tree lhs = gimple_assign_lhs (stmt);\n-\n-  if (gimple_num_ops (stmt) == 2)\n-    return detect_commutative_reduction_arg (lhs, stmt,\n-\t\t\t\t\t     gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t     in, out);\n-\n-  if (is_reduction_operation_p (stmt))\n-    {\n-      gphi *res = detect_commutative_reduction_arg (lhs, stmt,\n-\t\t\t\t\t\t    gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t\t    in, out);\n-      return res ? res\n-\t: detect_commutative_reduction_arg (lhs, stmt,\n-\t\t\t\t\t    gimple_assign_rhs2 (stmt),\n-\t\t\t\t\t    in, out);\n-    }\n-\n-  return NULL;\n-}\n-\n-/* Return a loop phi node that corresponds to a reduction containing LHS.  */\n-\n-static gphi *\n-follow_inital_value_to_phi (tree arg, tree lhs)\n-{\n-  gimple *stmt;\n-\n-  if (!arg || TREE_CODE (arg) != SSA_NAME)\n-    return NULL;\n-\n-  stmt = SSA_NAME_DEF_STMT (arg);\n-\n-  if (gphi *phi = dyn_cast <gphi *> (stmt))\n-    if (phi_contains_arg (phi, lhs))\n-      return phi;\n-\n-  return NULL;\n-}\n-\n-\n-/* Return the argument of the loop PHI that is the initial value coming\n-   from outside the loop.  */\n-\n-static edge\n-edge_initial_value_for_loop_phi (gphi *phi)\n-{\n-  size_t i;\n-\n-  for (i = 0; i < gimple_phi_num_args (phi); i++)\n-    {\n-      edge e = gimple_phi_arg_edge (phi, i);\n-\n-      if (loop_depth (e->src->loop_father)\n-\t  < loop_depth (e->dest->loop_father))\n-\treturn e;\n-    }\n-\n-  return NULL;\n-}\n-\n-/* Return the argument of the loop PHI that is the initial value coming\n-   from outside the loop.  */\n-\n-static tree\n-initial_value_for_loop_phi (gphi *phi)\n-{\n-  size_t i;\n-\n-  for (i = 0; i < gimple_phi_num_args (phi); i++)\n-    {\n-      edge e = gimple_phi_arg_edge (phi, i);\n-\n-      if (loop_depth (e->src->loop_father)\n-\t  < loop_depth (e->dest->loop_father))\n-\treturn gimple_phi_arg_def (phi, i);\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Returns true when DEF is used outside the reduction cycle of\n-   LOOP_PHI.  */\n-\n-static bool\n-used_outside_reduction (tree def, gimple *loop_phi)\n-{\n-  use_operand_p use_p;\n-  imm_use_iterator imm_iter;\n-  loop_p loop = loop_containing_stmt (loop_phi);\n-\n-  /* In LOOP, DEF should be used only in LOOP_PHI.  */\n-  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, def)\n-    {\n-      gimple *stmt = USE_STMT (use_p);\n-\n-      if (stmt != loop_phi\n-\t  && !is_gimple_debug (stmt)\n-\t  && flow_bb_inside_loop_p (loop, gimple_bb (stmt)))\n-\treturn true;\n-    }\n-\n-  return false;\n-}\n-\n-/* Detect commutative and associative scalar reductions belonging to\n-   the SCOP starting at the loop closed phi node STMT.  Return the phi\n-   node of the reduction cycle, or NULL.  */\n-\n-static gphi *\n-detect_commutative_reduction (scop_p scop, gimple *stmt, vec<gimple *> *in,\n-\t\t\t      vec<gimple *> *out)\n-{\n-  if (scalar_close_phi_node_p (stmt))\n-    {\n-      gimple *def;\n-      gphi *loop_phi, *phi, *close_phi = as_a <gphi *> (stmt);\n-      tree init, lhs, arg = gimple_phi_arg_def (close_phi, 0);\n-\n-      if (TREE_CODE (arg) != SSA_NAME)\n-\treturn NULL;\n-\n-      /* Note that loop close phi nodes should have a single argument\n-\t because we translated the representation into a canonical form\n-\t before Graphite: see canonicalize_loop_closed_ssa_form.  */\n-      gcc_assert (gimple_phi_num_args (close_phi) == 1);\n-\n-      def = SSA_NAME_DEF_STMT (arg);\n-      if (!stmt_in_sese_p (def, SCOP_REGION (scop))\n-\t  || !(loop_phi = detect_commutative_reduction (scop, def, in, out)))\n-\treturn NULL;\n-\n-      lhs = gimple_phi_result (close_phi);\n-      init = initial_value_for_loop_phi (loop_phi);\n-      phi = follow_inital_value_to_phi (init, lhs);\n-\n-      if (phi && (used_outside_reduction (lhs, phi)\n-\t\t  || !has_single_use (gimple_phi_result (phi))))\n-\treturn NULL;\n-\n-      in->safe_push (loop_phi);\n-      out->safe_push (close_phi);\n-      return phi;\n-    }\n-\n-  if (gimple_code (stmt) == GIMPLE_ASSIGN)\n-    return detect_commutative_reduction_assign (stmt, in, out);\n-\n-  return NULL;\n-}\n-\n-/* Translate the scalar reduction statement STMT to an array RED\n-   knowing that its recursive phi node is LOOP_PHI.  */\n-\n-static void\n-translate_scalar_reduction_to_array_for_stmt (scop_p scop, tree red,\n-\t\t\t\t\t      gimple *stmt, gphi *loop_phi)\n-{\n-  tree res = gimple_phi_result (loop_phi);\n-  gassign *assign = gimple_build_assign (res, unshare_expr (red));\n-  gimple_stmt_iterator gsi;\n-\n-  insert_stmts (scop, assign, NULL, gsi_after_labels (gimple_bb (loop_phi)));\n-\n-  assign = gimple_build_assign (unshare_expr (red), gimple_assign_lhs (stmt));\n-  gsi = gsi_for_stmt (stmt);\n-  gsi_next (&gsi);\n-  insert_stmts (scop, assign, NULL, gsi);\n-}\n-\n-/* Removes the PHI node and resets all the debug stmts that are using\n-   the PHI_RESULT.  */\n-\n-static void\n-remove_phi (gphi *phi)\n-{\n-  imm_use_iterator imm_iter;\n-  tree def;\n-  use_operand_p use_p;\n-  gimple_stmt_iterator gsi;\n-  auto_vec<gimple *, 3> update;\n-  unsigned int i;\n-  gimple *stmt;\n-\n-  def = PHI_RESULT (phi);\n-  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, def)\n-    {\n-      stmt = USE_STMT (use_p);\n-\n-      if (is_gimple_debug (stmt))\n-\t{\n-\t  gimple_debug_bind_reset_value (stmt);\n-\t  update.safe_push (stmt);\n-\t}\n-    }\n-\n-  FOR_EACH_VEC_ELT (update, i, stmt)\n-    update_stmt (stmt);\n-\n-  gsi = gsi_for_phi_node (phi);\n-  remove_phi_node (&gsi, false);\n-}\n-\n-/* Helper function for for_each_index.  For each INDEX of the data\n-   reference REF, returns true when its indices are valid in the loop\n-   nest LOOP passed in as DATA.  */\n-\n-static bool\n-dr_indices_valid_in_loop (tree ref ATTRIBUTE_UNUSED, tree *index, void *data)\n-{\n-  loop_p loop;\n-  basic_block header, def_bb;\n-  gimple *stmt;\n-\n-  if (TREE_CODE (*index) != SSA_NAME)\n-    return true;\n-\n-  loop = *((loop_p *) data);\n-  header = loop->header;\n-  stmt = SSA_NAME_DEF_STMT (*index);\n-\n-  if (!stmt)\n-    return true;\n-\n-  def_bb = gimple_bb (stmt);\n-\n-  if (!def_bb)\n-    return true;\n-\n-  return dominated_by_p (CDI_DOMINATORS, header, def_bb);\n-}\n-\n-/* When the result of a CLOSE_PHI is written to a memory location,\n-   return a pointer to that memory reference, otherwise return\n-   NULL_TREE.  */\n-\n-static tree\n-close_phi_written_to_memory (gphi *close_phi)\n-{\n-  imm_use_iterator imm_iter;\n-  use_operand_p use_p;\n-  gimple *stmt;\n-  tree res, def = gimple_phi_result (close_phi);\n-\n-  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, def)\n-    if ((stmt = USE_STMT (use_p))\n-\t&& gimple_code (stmt) == GIMPLE_ASSIGN\n-\t&& (res = gimple_assign_lhs (stmt)))\n-      {\n-\tswitch (TREE_CODE (res))\n-\t  {\n-\t  case VAR_DECL:\n-\t  case PARM_DECL:\n-\t  case RESULT_DECL:\n-\t    return res;\n-\n-\t  case ARRAY_REF:\n-\t  case MEM_REF:\n-\t    {\n-\t      tree arg = gimple_phi_arg_def (close_phi, 0);\n-\t      loop_p nest = loop_containing_stmt (SSA_NAME_DEF_STMT (arg));\n-\n-\t      /* FIXME: this restriction is for id-{24,25}.f and\n-\t\t could be handled by duplicating the computation of\n-\t\t array indices before the loop of the close_phi.  */\n-\t      if (for_each_index (&res, dr_indices_valid_in_loop, &nest))\n-\t\treturn res;\n-\t    }\n-\t    /* Fallthru.  */\n-\n-\t  default:\n-\t    continue;\n-\t  }\n-      }\n-  return NULL_TREE;\n-}\n-\n-/* Rewrite out of SSA the reduction described by the loop phi nodes\n-   IN, and the close phi nodes OUT.  IN and OUT are structured by loop\n-   levels like this:\n-\n-   IN: stmt, loop_n, ..., loop_0\n-   OUT: stmt, close_n, ..., close_0\n-\n-   the first element is the reduction statement, and the next elements\n-   are the loop and close phi nodes of each of the outer loops.  */\n-\n-static void\n-translate_scalar_reduction_to_array (scop_p scop,\n-\t\t\t\t     vec<gimple *> in,\n-\t\t\t\t     vec<gimple *> out)\n-{\n-  gimple *loop_stmt;\n-  unsigned int i = out.length () - 1;\n-  tree red = close_phi_written_to_memory (as_a <gphi *> (out[i]));\n-\n-  FOR_EACH_VEC_ELT (in, i, loop_stmt)\n-    {\n-      gimple *close_stmt = out[i];\n-\n-      if (i == 0)\n-\t{\n-\t  basic_block bb = split_reduction_stmt (scop, loop_stmt);\n-\t  poly_bb_p pbb = pbb_from_bb (bb);\n-\t  PBB_IS_REDUCTION (pbb) = true;\n-\t  gcc_assert (close_stmt == loop_stmt);\n-\n-\t  if (!red)\n-\t    red = create_zero_dim_array\n-\t      (gimple_assign_lhs (loop_stmt), \"Commutative_Associative_Reduction\");\n-\n-\t  translate_scalar_reduction_to_array_for_stmt (scop, red, loop_stmt,\n-\t\t\t\t\t\t\tas_a <gphi *> (in[1]));\n-\t  continue;\n-\t}\n-\n-      gphi *loop_phi = as_a <gphi *> (loop_stmt);\n-      gphi *close_phi = as_a <gphi *> (close_stmt);\n-\n-      if (i == in.length () - 1)\n-\t{\n-\t  insert_out_of_ssa_copy (scop, gimple_phi_result (close_phi),\n-\t\t\t\t  unshare_expr (red), close_phi);\n-\t  insert_out_of_ssa_copy_on_edge\n-\t    (scop, edge_initial_value_for_loop_phi (loop_phi),\n-\t     unshare_expr (red), initial_value_for_loop_phi (loop_phi));\n-\t}\n-\n-      remove_phi (loop_phi);\n-      remove_phi (close_phi);\n-    }\n-}\n-\n-/* Rewrites out of SSA a commutative reduction at CLOSE_PHI.  Returns\n-   true when something has been changed.  */\n-\n-static bool\n-rewrite_commutative_reductions_out_of_ssa_close_phi (scop_p scop,\n-\t\t\t\t\t\t     gphi *close_phi)\n-{\n-  bool res;\n-  auto_vec<gimple *, 10> in;\n-  auto_vec<gimple *, 10> out;\n-\n-  detect_commutative_reduction (scop, close_phi, &in, &out);\n-  res = in.length () > 1;\n-  if (res)\n-    translate_scalar_reduction_to_array (scop, in, out);\n-\n-  return res;\n-}\n-\n-/* Rewrites all the commutative reductions from LOOP out of SSA.\n-   Returns true when something has been changed.  */\n-\n-static bool\n-rewrite_commutative_reductions_out_of_ssa_loop (scop_p scop,\n-\t\t\t\t\t\tloop_p loop)\n-{\n-  gphi_iterator gsi;\n-  edge exit = single_exit (loop);\n-  tree res;\n-  bool changed = false;\n-\n-  if (!exit)\n-    return false;\n-\n-  for (gsi = gsi_start_phis (exit->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n-    if ((res = gimple_phi_result (gsi.phi ()))\n-\t&& !virtual_operand_p (res)\n-\t&& !scev_analyzable_p (res, SCOP_REGION (scop)))\n-      changed |= rewrite_commutative_reductions_out_of_ssa_close_phi\n-\t(scop, gsi.phi ());\n-\n-  return changed;\n-}\n-\n-/* Rewrites all the commutative reductions from SCOP out of SSA.  */\n-\n-static void\n-rewrite_commutative_reductions_out_of_ssa (scop_p scop)\n-{\n-  loop_p loop;\n-  bool changed = false;\n-  sese region = SCOP_REGION (scop);\n-\n-  FOR_EACH_LOOP (loop, 0)\n-    if (loop_in_sese_p (loop, region))\n-      changed |= rewrite_commutative_reductions_out_of_ssa_loop (scop, loop);\n-\n-  if (changed)\n-    {\n-      scev_reset_htab ();\n-      gsi_commit_edge_inserts ();\n-      update_ssa (TODO_update_ssa);\n-#ifdef ENABLE_CHECKING\n-      verify_loop_closed_ssa (true);\n-#endif\n-    }\n-}\n-\n /* Can all ivs be represented by a signed integer?\n    As ISL might generate negative values in its expressions, signed loop ivs\n    are required in the backend. */\n@@ -3154,8 +2554,6 @@ build_poly_scop (scop_p scop)\n   if (!scop_ivs_can_be_represented (scop))\n     return;\n \n-  rewrite_commutative_reductions_out_of_ssa (scop);\n-\n   build_sese_loop_nests (region);\n   /* Record all conditions in REGION.  */\n   sese_dom_walker (CDI_DOMINATORS, region).walk (cfun->cfg->x_entry_block_ptr);"}]}