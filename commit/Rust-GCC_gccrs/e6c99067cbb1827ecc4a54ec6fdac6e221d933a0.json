{"sha": "e6c99067cbb1827ecc4a54ec6fdac6e221d933a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZjOTkwNjdjYmIxODI3ZWNjNGE1NGVjNmZkYWM2ZTIyMWQ5MzNhMA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2008-09-21T15:05:14Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2008-09-21T15:05:14Z"}, "message": "gccint.texi: Include generic.texi and gimple.texi.\n\n2008-09-21  Diego Novillo  <dnovillo@google.com>\n\n\t* doc/gccint.texi: Include generic.texi and gimple.texi.\n\tRe-order index.\n\t* doc/tree-ssa.texi (GENERIC): Move to generic.texi.\n\t(GIMPLE): Move to gimple.texi.\n\t(Annotations): Remove references to to stmt_ann_t and\n\tssa_name_ann_t.\n\t(SSA Operands): Rename from 'Statement Operands'.\n\t* doc/generic.texi: New.\n\t* doc/gimple.texi: New.\n\t* Makefile.in (TEXI_GCCINT_FILES): Add generic.texi and\n\tgimple.texi.\n\t* Makefile.in (TEXI_GCCINT_FILES):\n\t* gimple.c (gimple_copy_call_skip_args): Rename from\n\tgiple_copy_call_skip_args.  Update all users.\n\t* doc/gimple.texi (gimple_copy_call_skip_args): Document.\n\nFrom-SVN: r140527", "tree": {"sha": "d3d059f4def91a8519e23abe08d73f66f1403d8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3d059f4def91a8519e23abe08d73f66f1403d8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9453804343a2e9dd2db33d6f845746175198bdb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9453804343a2e9dd2db33d6f845746175198bdb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9453804343a2e9dd2db33d6f845746175198bdb3"}], "stats": {"total": 3438, "additions": 2720, "deletions": 718}, "files": [{"sha": "ebb887500e57022b81496aaddea60a34d3f4f7e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6c99067cbb1827ecc4a54ec6fdac6e221d933a0", "patch": "@@ -1,3 +1,21 @@\n+2008-09-21  Diego Novillo  <dnovillo@google.com>\n+\n+\t* doc/gccint.texi: Include generic.texi and gimple.texi.\n+\tRe-order index.\n+\t* doc/tree-ssa.texi (GENERIC): Move to generic.texi.\n+\t(GIMPLE): Move to gimple.texi.\n+\t(Annotations): Remove references to to stmt_ann_t and\n+\tssa_name_ann_t.\n+\t(SSA Operands): Rename from 'Statement Operands'.\n+\t* doc/generic.texi: New.\n+\t* doc/gimple.texi: New.\n+\t* Makefile.in (TEXI_GCCINT_FILES): Add generic.texi and\n+\tgimple.texi.\n+\t* Makefile.in (TEXI_GCCINT_FILES):\n+\t* gimple.c (gimple_copy_call_skip_args): Rename from\n+\tgiple_copy_call_skip_args.  Update all users.\n+\t* doc/gimple.texi (gimple_copy_call_skip_args): Document.\n+\n 2008-09-21  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/37539"}, {"sha": "f067a910a2673bc8e17e3ac933223d04b5cf2560", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e6c99067cbb1827ecc4a54ec6fdac6e221d933a0", "patch": "@@ -3844,7 +3844,7 @@ TEXI_GCCINT_FILES = gccint.texi gcc-common.texi gcc-vers.texi\t\t\\\n \t configfiles.texi collect2.texi headerdirs.texi funding.texi\t\\\n \t gnu.texi gpl_v3.texi fdl.texi contrib.texi languages.texi\t\\\n \t sourcebuild.texi gty.texi libgcc.texi cfg.texi tree-ssa.texi\t\\\n-\t loop.texi\n+\t loop.texi generic.texi gimple.texi\n \n TEXI_GCCINSTALL_FILES = install.texi install-old.texi fdl.texi\t\t\\\n \t gcc-common.texi gcc-vers.texi"}, {"sha": "b4b559ec418e4b5dcb880847f0fd772fa258f7f6", "filename": "gcc/doc/gccint.texi", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2Fdoc%2Fgccint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2Fdoc%2Fgccint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint.texi?ref=e6c99067cbb1827ecc4a54ec6fdac6e221d933a0", "patch": "@@ -110,8 +110,10 @@ Additional tutorial information is linked to from\n * Passes::          Order of passes, what they do, and what each file is for.\n * Trees::           The source representation used by the C and C++ front ends.\n * RTL::             The intermediate representation that most passes work on.\n+* GENERIC::         Language-independent representation generated by Front Ends\n+* GIMPLE::          Tuple representation used by Tree SSA optimizers\n+* Tree SSA::        Analysis and optimization of GIMPLE\n * Control Flow::    Maintaining and manipulating the control flow graph.\n-* Tree SSA::        Analysis and optimization of the tree representation.\n * Loop Analysis and Representation:: Analysis and representation of loops\n * Machine Desc::    How to write machine description instruction patterns.\n * Target Macros::   How to write the machine description C macros and functions.\n@@ -142,9 +144,11 @@ Additional tutorial information is linked to from\n @include options.texi\n @include passes.texi\n @include c-tree.texi\n+@include rtl.texi\n+@include generic.texi\n+@include gimple.texi\n @include tree-ssa.texi\n @include loop.texi\n-@include rtl.texi\n @include cfg.texi\n @include md.texi\n @include tm.texi"}, {"sha": "14284cc397eac0306cb7e5fa59db8d239a668c2a", "filename": "gcc/doc/generic.texi", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=e6c99067cbb1827ecc4a54ec6fdac6e221d933a0", "patch": "@@ -0,0 +1,179 @@\n+@c Copyright (c) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n+@c Free Software Foundation, Inc.\n+@c This is part of the GCC manual.\n+@c For copying conditions, see the file gcc.texi.\n+\n+@c ---------------------------------------------------------------------\n+@c GENERIC\n+@c ---------------------------------------------------------------------\n+\n+@node GENERIC\n+@chapter GENERIC\n+@cindex GENERIC\n+\n+The purpose of GENERIC is simply to provide a\n+language-independent way of representing an entire function in\n+trees.  To this end, it was necessary to add a few new tree codes\n+to the back end, but most everything was already there.  If you\n+can express it with the codes in @code{gcc/tree.def}, it's\n+GENERIC@.\n+\n+Early on, there was a great deal of debate about how to think\n+about statements in a tree IL@.  In GENERIC, a statement is\n+defined as any expression whose value, if any, is ignored.  A\n+statement will always have @code{TREE_SIDE_EFFECTS} set (or it\n+will be discarded), but a non-statement expression may also have\n+side effects.  A @code{CALL_EXPR}, for instance.\n+\n+It would be possible for some local optimizations to work on the\n+GENERIC form of a function; indeed, the adapted tree inliner\n+works fine on GENERIC, but the current compiler performs inlining\n+after lowering to GIMPLE (a restricted form described in the next\n+section). Indeed, currently the frontends perform this lowering\n+before handing off to @code{tree_rest_of_compilation}, but this\n+seems inelegant.\n+\n+If necessary, a front end can use some language-dependent tree\n+codes in its GENERIC representation, so long as it provides a\n+hook for converting them to GIMPLE and doesn't expect them to\n+work with any (hypothetical) optimizers that run before the\n+conversion to GIMPLE@. The intermediate representation used while\n+parsing C and C++ looks very little like GENERIC, but the C and\n+C++ gimplifier hooks are perfectly happy to take it as input and\n+spit out GIMPLE@.\n+\n+@menu\n+* Statements::\n+@end menu\n+\n+@node Statements\n+@section Statements\n+@cindex Statements\n+\n+Most statements in GIMPLE are assignment statements, represented by\n+@code{GIMPLE_ASSIGN}.  No other C expressions can appear at statement level;\n+a reference to a volatile object is converted into a\n+@code{GIMPLE_ASSIGN}.\n+\n+There are also several varieties of complex statements.\n+\n+@menu\n+* Blocks::\n+* Statement Sequences::\n+* Empty Statements::\n+* Jumps::\n+* Cleanups::\n+@end menu\n+\n+@node Blocks\n+@subsection Blocks\n+@cindex Blocks\n+\n+Block scopes and the variables they declare in GENERIC are\n+expressed using the @code{BIND_EXPR} code, which in previous\n+versions of GCC was primarily used for the C statement-expression\n+extension.\n+\n+Variables in a block are collected into @code{BIND_EXPR_VARS} in\n+declaration order.  Any runtime initialization is moved out of\n+@code{DECL_INITIAL} and into a statement in the controlled block.\n+When gimplifying from C or C++, this initialization replaces the\n+@code{DECL_STMT}.\n+\n+Variable-length arrays (VLAs) complicate this process, as their\n+size often refers to variables initialized earlier in the block.\n+To handle this, we currently split the block at that point, and\n+move the VLA into a new, inner @code{BIND_EXPR}.  This strategy\n+may change in the future.\n+\n+A C++ program will usually contain more @code{BIND_EXPR}s than\n+there are syntactic blocks in the source code, since several C++\n+constructs have implicit scopes associated with them.  On the\n+other hand, although the C++ front end uses pseudo-scopes to\n+handle cleanups for objects with destructors, these don't\n+translate into the GIMPLE form; multiple declarations at the same\n+level use the same @code{BIND_EXPR}.\n+\n+@node Statement Sequences\n+@subsection Statement Sequences\n+@cindex Statement Sequences\n+\n+Multiple statements at the same nesting level are collected into\n+a @code{STATEMENT_LIST}.  Statement lists are modified and\n+traversed using the interface in @samp{tree-iterator.h}.\n+\n+@node Empty Statements\n+@subsection Empty Statements\n+@cindex Empty Statements\n+\n+Whenever possible, statements with no effect are discarded.  But\n+if they are nested within another construct which cannot be\n+discarded for some reason, they are instead replaced with an\n+empty statement, generated by @code{build_empty_stmt}.\n+Initially, all empty statements were shared, after the pattern of\n+the Java front end, but this caused a lot of trouble in practice.\n+\n+An empty statement is represented as @code{(void)0}.\n+\n+@node Jumps\n+@subsection Jumps\n+@cindex Jumps\n+\n+Other jumps are expressed by either @code{GOTO_EXPR} or\n+@code{RETURN_EXPR}.\n+\n+The operand of a @code{GOTO_EXPR} must be either a label or a\n+variable containing the address to jump to.\n+\n+The operand of a @code{RETURN_EXPR} is either @code{NULL_TREE},\n+@code{RESULT_DECL}, or a @code{MODIFY_EXPR} which sets the return\n+value.  It would be nice to move the @code{MODIFY_EXPR} into a\n+separate statement, but the special return semantics in\n+@code{expand_return} make that difficult.  It may still happen in\n+the future, perhaps by moving most of that logic into\n+@code{expand_assignment}.\n+\n+@node Cleanups\n+@subsection Cleanups\n+@cindex Cleanups\n+\n+Destructors for local C++ objects and similar dynamic cleanups are\n+represented in GIMPLE by a @code{TRY_FINALLY_EXPR}.\n+@code{TRY_FINALLY_EXPR} has two operands, both of which are a sequence\n+of statements to execute.  The first sequence is executed.  When it\n+completes the second sequence is executed.\n+\n+The first sequence may complete in the following ways:\n+\n+@enumerate\n+\n+@item Execute the last statement in the sequence and fall off the\n+end.\n+\n+@item Execute a goto statement (@code{GOTO_EXPR}) to an ordinary\n+label outside the sequence.\n+\n+@item Execute a return statement (@code{RETURN_EXPR}).\n+\n+@item Throw an exception.  This is currently not explicitly represented in\n+GIMPLE.\n+\n+@end enumerate\n+\n+The second sequence is not executed if the first sequence completes by\n+calling @code{setjmp} or @code{exit} or any other function that does\n+not return.  The second sequence is also not executed if the first\n+sequence completes via a non-local goto or a computed goto (in general\n+the compiler does not know whether such a goto statement exits the\n+first sequence or not, so we assume that it doesn't).\n+\n+After the second sequence is executed, if it completes normally by\n+falling off the end, execution continues wherever the first sequence\n+would have continued, by falling off the end, or doing a goto, etc.\n+\n+@code{TRY_FINALLY_EXPR} complicates the flow graph, since the cleanup\n+needs to appear on every edge out of the controlled block; this\n+reduces the freedom to move code across these edges.  Therefore, the\n+EH lowering pass which runs before most of the optimization passes\n+eliminates these expressions by explicitly adding the cleanup to each\n+edge.  Rethrowing the exception is represented using @code{RESX_EXPR}."}, {"sha": "8277a8ca715b3e840828866f300dc75686d8b68a", "filename": "gcc/doc/gimple.texi", "status": "added", "additions": 2498, "deletions": 0, "changes": 2498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2Fdoc%2Fgimple.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2Fdoc%2Fgimple.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgimple.texi?ref=e6c99067cbb1827ecc4a54ec6fdac6e221d933a0", "patch": "@@ -0,0 +1,2498 @@\n+@c Copyright (c) 2008 Free Software Foundation, Inc.\n+@c Free Software Foundation, Inc.\n+@c This is part of the GCC manual.\n+@c For copying conditions, see the file gcc.texi.\n+\n+@node GIMPLE\n+@chapter GIMPLE\n+@cindex GIMPLE\n+\n+GIMPLE is a three-address representation derived from GENERIC by\n+breaking down GENERIC expressions into tuples of no more than 3\n+operands (with some exceptions like function calls).  GIMPLE was\n+heavily influenced by the SIMPLE IL used by the McCAT compiler\n+project at McGill University, though we have made some different\n+choices.  For one thing, SIMPLE doesn't support @code{goto}.\n+\n+Temporaries are introduced to hold intermediate values needed to\n+compute complex expressions. Additionally, all the control\n+structures used in GENERIC are lowered into conditional jumps,\n+lexical scopes are removed and exception regions are converted\n+into an on the side exception region tree.\n+\n+The compiler pass which converts GENERIC into GIMPLE is referred to as\n+the @samp{gimplifier}.  The gimplifier works recursively, generating\n+GIMPLE tuples out of the original GENERIC expressions.\n+\n+One of the early implementation strategies used for the GIMPLE\n+representation was to use the same internal data structures used\n+by front ends to represent parse trees. This simplified\n+implementation because we could leverage existing functionality\n+and interfaces. However, GIMPLE is a much more restrictive\n+representation than abstract syntax trees (AST), therefore it\n+does not require the full structural complexity provided by the\n+main tree data structure.\n+\n+The GENERIC representation of a function is stored in the\n+@code{DECL_SAVED_TREE} field of the associated @code{FUNCTION_DECL}\n+tree node.  It is converted to GIMPLE by a call to\n+@code{gimplify_function_tree}.\n+\n+If a front end wants to include language-specific tree codes in the tree\n+representation which it provides to the back end, it must provide a\n+definition of @code{LANG_HOOKS_GIMPLIFY_EXPR} which knows how to\n+convert the front end trees to GIMPLE@.  Usually such a hook will involve\n+much of the same code for expanding front end trees to RTL@.  This function\n+can return fully lowered GIMPLE, or it can return GENERIC trees and let the\n+main gimplifier lower them the rest of the way; this is often simpler.\n+GIMPLE that is not fully lowered is known as ``High GIMPLE'' and\n+consists of the IL before the pass @code{pass_lower_cf}.  High GIMPLE\n+contains some container statements like lexical scopes\n+(represented by @code{GIMPLE_BIND}) and nested expressions (e.g.,\n+@code{GIMPLE_TRY}), while ``Low GIMPLE'' exposes all of the\n+implicit jumps for control and exception expressions directly in\n+the IL and EH region trees.\n+\n+The C and C++ front ends currently convert directly from front end\n+trees to GIMPLE, and hand that off to the back end rather than first\n+converting to GENERIC@.  Their gimplifier hooks know about all the\n+@code{_STMT} nodes and how to convert them to GENERIC forms.  There\n+was some work done on a genericization pass which would run first, but\n+the existence of @code{STMT_EXPR} meant that in order to convert all\n+of the C statements into GENERIC equivalents would involve walking the\n+entire tree anyway, so it was simpler to lower all the way.  This\n+might change in the future if someone writes an optimization pass\n+which would work better with higher-level trees, but currently the\n+optimizers all expect GIMPLE@.\n+\n+You can request to dump a C-like representation of the GIMPLE form\n+with the flag @option{-fdump-tree-gimple}.\n+\n+@menu\n+* Tuple representation::\n+* GIMPLE instruction set::\n+* GIMPLE Exception Handling::\n+* Temporaries::\n+* Operands::\n+* Manipulating GIMPLE statements::\n+* Tuple specific accessors::\n+* GIMPLE sequences::\n+* Sequence iterators::\n+* Adding a new GIMPLE statement code::\n+* Statement and operand traversals::\n+@end menu\n+\n+@node Tuple representation\n+@section Tuple representation\n+@cindex tuples\n+\n+GIMPLE instructions are tuples of variable size divided in two\n+groups: a header describing the instruction and its locations,\n+and a variable length body with all the operands. Tuples are\n+organized into a hierarchy with 3 main classes of tuples.\n+\n+@subsection @code{gimple_statement_base} (gsbase)\n+@cindex gimple_statement_base\n+\n+This is the root of the hierarchy, it holds basic information\n+needed by most GIMPLE statements. There are some fields that\n+may not be relevant to every GIMPLE statement, but those were\n+moved into the base structure to take advantage of holes left by\n+other fields (thus making the structure more compact).  The\n+structure takes 4 words (32 bytes) on 64 bit hosts:\n+\n+@multitable {@code{references_memory_p}} {Size (bits)}\n+@item Field\t\t\t\t@tab Size (bits)\n+@item @code{code}\t\t\t@tab 8\n+@item @code{subcode}\t\t\t@tab 16\n+@item @code{no_warning}\t\t\t@tab 1\n+@item @code{visited}\t\t\t@tab 1\n+@item @code{nontemporal_move}\t\t@tab 1\n+@item @code{plf}\t\t\t@tab 2\n+@item @code{modifed}\t\t\t@tab 1\n+@item @code{has_volatile_ops}\t\t@tab 1\n+@item @code{references_memory_p}\t@tab 1\n+@item @code{uid}\t\t\t@tab 32\n+@item @code{location}\t\t\t@tab 32\n+@item @code{num_ops}\t\t\t@tab 32\n+@item @code{bb}\t\t\t\t@tab 64\n+@item @code{block}\t\t\t@tab 63\n+@item Total size\t\t\t@tab 32 bytes\t\n+@end multitable\n+\n+@itemize @bullet\n+@item @code{code}\n+Main identifier for a GIMPLE instruction. \n+\n+@item @code{subcode}\n+Used to distinguish different variants of the same basic\n+instruction or provide flags applicable to a given code. The\n+@code{subcode} flags field has different uses depending on the code of\n+the instruction, but mostly it distinguishes instructions of the\n+same family. The most prominent use of this field is in\n+assignments, where subcode indicates the operation done on the\n+RHS of the assignment. For example, a = b + c is encoded as\n+@code{GIMPLE_ASSIGN <PLUS_EXPR, a, b, c>}.\n+\n+@item @code{no_warning}\n+Bitflag to indicate whether a warning has already been issued on\n+this statement.\n+\n+@item @code{visited}\n+General purpose ``visited'' marker. Set and cleared by each pass\n+when needed.\n+\n+@item @code{nontemporal_move}\n+Bitflag used in assignments that represent non-temporal moves.\n+Although this bitflag is only used in assignments, it was moved\n+into the base to take advantage of the bit holes left by the\n+previous fields.\n+\n+@item @code{plf}\n+Pass Local Flags. This 2-bit mask can be used as general purpose\n+markers by any pass. Passes are responsible for clearing and\n+setting these two flags accordingly.\n+\n+@item @code{modified}\n+Bitflag to indicate whether the statement has been modified.\n+Used mainly by the operand scanner to determine when to re-scan a\n+statement for operands.\n+\n+@item @code{has_volatile_ops}\n+Bitflag to indicate whether this statement contains operands that\n+have been marked volatile.\n+\n+@item @code{references_memory_p}\n+Bitflag to indicate whether this statement contains memory\n+references (i.e., its operands are either global variables, or\n+pointer dereferences or anything that must reside in memory).\n+\n+@item @code{uid}\n+This is an unsigned integer used by passes that want to assign\n+IDs to every statement. These IDs must be assigned and used by\n+each pass.\n+\n+@item @code{location}\n+This is a @code{location_t} identifier to specify source code\n+location for this statement. It is inherited from the front\n+end.\n+\n+@item @code{num_ops}\n+Number of operands that this statement has. This specifies the\n+size of the operand vector embedded in the tuple. Only used in\n+some tuples, but it is declared in the base tuple to take\n+advantage of the 32-bit hole left by the previous fields.\n+\n+@item @code{bb}\n+Basic block holding the instruction.\n+ \n+@item @code{block}\n+Lexical block holding this statement.  Also used for debug\n+information generation.\n+@end itemize\n+\n+@subsection @code{gimple_statement_with_ops}\n+@cindex gimple_statement_with_ops\n+\n+This tuple is actually split in two:\n+@code{gimple_statement_with_ops_base} and\n+@code{gimple_statement_with_ops}. This is needed to accommodate the\n+way the operand vector is allocated. The operand vector is\n+defined to be an array of 1 element. So, to allocate a dynamic\n+number of operands, the memory allocator (@code{gimple_alloc}) simply\n+allocates enough memory to hold the structure itself plus @code{N\n+- 1} operands which run ``off the end'' of the structure. For\n+example, to allocate space for a tuple with 3 operands,\n+@code{gimple_alloc} reserves @code{sizeof (struct\n+gimple_statement_with_ops) + 2 * sizeof (tree)} bytes.\n+\n+On the other hand, several fields in this tuple need to be shared\n+with the @code{gimple_statement_with_memory_ops} tuple. So, these\n+common fields are placed in @code{gimple_statement_with_ops_base} which\n+is then inherited from the other two tuples.\n+\n+\n+@multitable {@code{addresses_taken}}\t{56 + 8 * @code{num_ops} bytes}\n+@item\t@code{gsbase}\t\t@tab 256\t\n+@item\t@code{addresses_taken}\t@tab 64\t\n+@item\t@code{def_ops}\t\t@tab 64\t\n+@item\t@code{use_ops}\t\t@tab 64\t\n+@item\t@code{op}\t\t@tab @code{num_ops} * 64\t\n+@item\tTotal size\t\t@tab 56 + 8 * @code{num_ops} bytes\n+@end multitable\n+\n+@itemize @bullet\n+@item @code{gsbase}\n+Inherited from @code{struct gimple_statement_base}.\n+\n+@item @code{addresses_taken}\n+Bitmap holding the UIDs of all the @code{VAR_DECL}s whose addresses are\n+taken by this statement. For example, a statement of the form\n+@code{p = &b} will have the UID for symbol @code{b} in this set.\n+\n+@item @code{def_ops}\n+Array of pointers into the operand array indicating all the slots that\n+contain a variable written-to by the statement. This array is\n+also used for immediate use chaining. Note that it would be\n+possible to not rely on this array, but the changes required to\n+implement this are pretty invasive.\n+\n+@item @code{use_ops}\n+Similar to @code{def_ops} but for variables read by the statement.\n+\n+@item @code{op}\n+Array of trees with @code{num_ops} slots.\n+@end itemize\n+\n+@subsection @code{gimple_statement_with_memory_ops}\n+\n+This tuple is essentially identical to @code{gimple_statement_with_ops},\n+except that it contains 4 additional fields to hold vectors\n+related memory stores and loads.  Similar to the previous case,\n+the structure is split in two to accomodate for the operand\n+vector (@code{gimple_statement_with_memory_ops_base} and\n+@code{gimple_statement_with_memory_ops}).\n+\n+\n+@multitable {@code{addresses_taken}}\t{88 + 8 * @code{num_ops} bytes}\n+@item Field\t\t\t\t@tab Size (bits)\n+@item @code{gsbase}\t\t\t@tab 256\n+@item @code{addresses_taken}\t\t@tab 64\n+@item @code{def_ops}\t\t\t@tab 64\n+@item @code{use_ops}\t\t\t@tab 64\n+@item @code{vdef_ops}\t\t\t@tab 64\n+@item @code{vuse_ops}\t\t\t@tab 64\n+@item @code{stores}\t\t\t@tab 64\t\n+@item @code{loads}\t\t\t@tab 64\t\n+@item @code{op}\t\t\t\t@tab @code{num_ops} * 64\t\n+@item Total size\t\t\t@tab 88 + 8 * @code{num_ops} bytes\n+@end multitable\n+\n+@itemize @bullet\n+@item @code{vdef_ops}\n+Similar to @code{def_ops} but for @code{VDEF} operators. There is\n+one entry per memory symbol written by this statement. This is\n+used to maintain the memory SSA use-def and def-def chains.\n+\n+@item @code{vuse_ops}\n+Similar to @code{use_ops} but for @code{VUSE} operators. There is\n+one entry per memory symbol loaded by this statement. This is\n+used to maintain the memory SSA use-def chains.\n+\n+@item @code{stores}\n+Bitset with all the UIDs for the symbols written-to by the\n+statement.  This is different than @code{vdef_ops} in that all the\n+affected symbols are mentioned in this set.  If memory\n+partitioning is enabled, the @code{vdef_ops} vector will refer to memory\n+partitions. Furthermore, no SSA information is stored in this\n+set.\n+\n+@item @code{loads}\n+Similar to @code{stores}, but for memory loads. (Note that there\n+is some amount of redundancy here, it should be possible to\n+reduce memory utilization further by removing these sets).\n+@end itemize\n+\n+All the other tuples are defined in terms of these three basic\n+ones. Each tuple will add some fields. The main gimple type\n+is defined to be the union of all these structures (@code{GTY} markers\n+elided for clarity):\n+\n+@smallexample\n+union gimple_statement_d\n+@{\n+  struct gimple_statement_base gsbase;\n+  struct gimple_statement_with_ops gsops;\n+  struct gimple_statement_with_memory_ops gsmem;\n+  struct gimple_statement_omp omp;\n+  struct gimple_statement_bind gimple_bind;\n+  struct gimple_statement_catch gimple_catch;\n+  struct gimple_statement_eh_filter gimple_eh_filter;\n+  struct gimple_statement_phi gimple_phi;\n+  struct gimple_statement_resx gimple_resx;\n+  struct gimple_statement_try gimple_try;\n+  struct gimple_statement_wce gimple_wce;\n+  struct gimple_statement_asm gimple_asm;\n+  struct gimple_statement_omp_critical gimple_omp_critical;\n+  struct gimple_statement_omp_for gimple_omp_for;\n+  struct gimple_statement_omp_parallel gimple_omp_parallel;\n+  struct gimple_statement_omp_task gimple_omp_task;\n+  struct gimple_statement_omp_sections gimple_omp_sections;\n+  struct gimple_statement_omp_single gimple_omp_single;\n+  struct gimple_statement_omp_continue gimple_omp_continue;\n+  struct gimple_statement_omp_atomic_load gimple_omp_atomic_load;\n+  struct gimple_statement_omp_atomic_store gimple_omp_atomic_store;\n+@};\n+@end smallexample\n+\n+ \n+@node GIMPLE instruction set\n+@section GIMPLE instruction set\n+@cindex GIMPLE instruction set\n+\n+The following table briefly describes the GIMPLE instruction set.\n+\n+@multitable {@code{GIMPLE_CHANGE_DYNAMIC_TYPE}} {High GIMPLE} {Low GIMPLE}\n+@item Instruction\t\t\t@tab High GIMPLE\t@tab Low GIMPLE\n+@item @code{GIMPLE_ASM}\t\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_ASSIGN}\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_BIND}\t\t@tab x\t\t\t@tab\n+@item @code{GIMPLE_CALL}\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_CATCH}\t\t@tab x\t\t\t@tab\n+@item @code{GIMPLE_CHANGE_DYNAMIC_TYPE}\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_COND}\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_EH_FILTER}\t\t@tab x\t\t\t@tab\n+@item @code{GIMPLE_GOTO}\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_LABEL}\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_NOP}\t\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_OMP_ATOMIC_LOAD}\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_OMP_ATOMIC_STORE}\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_OMP_CONTINUE}\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_OMP_CRITICAL}\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_OMP_FOR}\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_OMP_MASTER}\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_OMP_ORDERED}\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_OMP_PARALLEL}\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_OMP_RETURN}\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_OMP_SECTION}\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_OMP_SECTIONS}\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_OMP_SECTIONS_SWITCH}\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_OMP_SINGLE}\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_PHI}\t\t\t@tab \t\t\t@tab x\n+@item @code{GIMPLE_RESX}\t\t@tab\t\t\t@tab x\n+@item @code{GIMPLE_RETURN}\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_SWITCH}\t\t@tab x\t\t\t@tab x\n+@item @code{GIMPLE_TRY}\t\t\t@tab x\t\t\t@tab\n+@end multitable\n+\n+@node GIMPLE Exception Handling\n+@section Exception Handling\n+@cindex GIMPLE Exception Handling\n+\n+Other exception handling constructs are represented using\n+@code{GIMPLE_TRY_CATCH}.  @code{GIMPLE_TRY_CATCH} has two operands.  The\n+first operand is a sequence of statements to execute.  If executing\n+these statements does not throw an exception, then the second operand\n+is ignored.  Otherwise, if an exception is thrown, then the second\n+operand of the @code{GIMPLE_TRY_CATCH} is checked.  The second\n+operand may have the following forms:\n+\n+@enumerate\n+\n+@item A sequence of statements to execute.  When an exception occurs,\n+these statements are executed, and then the exception is rethrown.\n+\n+@item A sequence of @code{GIMPLE_CATCH} statements.  Each\n+@code{GIMPLE_CATCH} has a list of applicable exception types and\n+handler code.  If the thrown exception matches one of the caught\n+types, the associated handler code is executed.  If the handler\n+code falls off the bottom, execution continues after the original\n+@code{GIMPLE_TRY_CATCH}.\n+\n+@item An @code{GIMPLE_EH_FILTER} statement.  This has a list of\n+permitted exception types, and code to handle a match failure.  If the\n+thrown exception does not match one of the allowed types, the\n+associated match failure code is executed.  If the thrown exception\n+does match, it continues unwinding the stack looking for the next\n+handler.\n+\n+@end enumerate\n+\n+Currently throwing an exception is not directly represented in\n+GIMPLE, since it is implemented by calling a function.  At some\n+point in the future we will want to add some way to express that\n+the call will throw an exception of a known type.\n+\n+Just before running the optimizers, the compiler lowers the\n+high-level EH constructs above into a set of @samp{goto}s, magic\n+labels, and EH regions.  Continuing to unwind at the end of a\n+cleanup is represented with a @code{GIMPLE_RESX}.\n+\n+\n+@node Temporaries\n+@section Temporaries\n+@cindex Temporaries\n+\n+When gimplification encounters a subexpression that is too\n+complex, it creates a new temporary variable to hold the value of\n+the subexpression, and adds a new statement to initialize it\n+before the current statement. These special temporaries are known\n+as @samp{expression temporaries}, and are allocated using\n+@code{get_formal_tmp_var}.  The compiler tries to always evaluate\n+identical expressions into the same temporary, to simplify\n+elimination of redundant calculations.\n+\n+We can only use expression temporaries when we know that it will\n+not be reevaluated before its value is used, and that it will not\n+be otherwise modified@footnote{These restrictions are derived\n+from those in Morgan 4.8.}. Other temporaries can be allocated\n+using @code{get_initialized_tmp_var} or @code{create_tmp_var}.\n+\n+Currently, an expression like @code{a = b + 5} is not reduced any\n+further.  We tried converting it to something like\n+@smallexample\n+  T1 = b + 5;\n+  a = T1;\n+@end smallexample\n+but this bloated the representation for minimal benefit.  However, a\n+variable which must live in memory cannot appear in an expression; its\n+value is explicitly loaded into a temporary first.  Similarly, storing\n+the value of an expression to a memory variable goes through a\n+temporary.\n+\n+@node Operands\n+@section Operands\n+@cindex Operands\n+\n+In general, expressions in GIMPLE consist of an operation and the\n+appropriate number of simple operands; these operands must either be a\n+GIMPLE rvalue (@code{is_gimple_val}), i.e.@: a constant or a register\n+variable.  More complex operands are factored out into temporaries, so\n+that\n+@smallexample\n+  a = b + c + d\n+@end smallexample\n+becomes\n+@smallexample\n+  T1 = b + c;\n+  a = T1 + d;\n+@end smallexample\n+\n+The same rule holds for arguments to a @code{GIMPLE_CALL}.\n+\n+The target of an assignment is usually a variable, but can also be an\n+@code{INDIRECT_REF} or a compound lvalue as described below.\n+\n+@menu\n+* Compound Expressions::\n+* Compound Lvalues::\n+* Conditional Expressions::\n+* Logical Operators::\n+@end menu\n+\n+@node Compound Expressions\n+@subsection Compound Expressions\n+@cindex Compound Expressions\n+\n+The left-hand side of a C comma expression is simply moved into a separate\n+statement.\n+\n+@node Compound Lvalues\n+@subsection Compound Lvalues\n+@cindex Compound Lvalues\n+\n+Currently compound lvalues involving array and structure field references\n+are not broken down; an expression like @code{a.b[2] = 42} is not reduced\n+any further (though complex array subscripts are).  This restriction is a\n+workaround for limitations in later optimizers; if we were to convert this\n+to\n+\n+@smallexample\n+  T1 = &a.b;\n+  T1[2] = 42;\n+@end smallexample\n+\n+alias analysis would not remember that the reference to @code{T1[2]} came\n+by way of @code{a.b}, so it would think that the assignment could alias\n+another member of @code{a}; this broke @code{struct-alias-1.c}.  Future\n+optimizer improvements may make this limitation unnecessary.\n+\n+@node Conditional Expressions\n+@subsection Conditional Expressions\n+@cindex Conditional Expressions\n+\n+A C @code{?:} expression is converted into an @code{if} statement with\n+each branch assigning to the same temporary.  So,\n+\n+@smallexample\n+  a = b ? c : d;\n+@end smallexample\n+becomes\n+@smallexample\n+  if (b == 1)\n+    T1 = c;\n+  else\n+    T1 = d;\n+  a = T1;\n+@end smallexample\n+\n+The GIMPLE level if-conversion pass re-introduces @code{?:}\n+expression, if appropriate. It is used to vectorize loops with\n+conditions using vector conditional operations.\n+\n+Note that in GIMPLE, @code{if} statements are represented using\n+@code{GIMPLE_COND}, as described below.\n+\n+@node Logical Operators\n+@subsection Logical Operators\n+@cindex Logical Operators\n+\n+Except when they appear in the condition operand of a\n+@code{GIMPLE_COND}, logical `and' and `or' operators are simplified\n+as follows: @code{a = b && c} becomes\n+\n+@smallexample\n+  T1 = (bool)b;\n+  if (T1 == true)\n+    T1 = (bool)c;\n+  a = T1;\n+@end smallexample\n+\n+Note that @code{T1} in this example cannot be an expression temporary,\n+because it has two different assignments.\n+\n+@subsection Manipulating operands\n+\n+All gimple operands are of type @code{tree}.  But only certain\n+types of trees are allowed to be used as operand tuples.  Basic\n+validation is controlled by the function\n+@code{get_gimple_rhs_class}, which given a tree code, returns an\n+@code{enum} with the following values of type @code{enum\n+gimple_rhs_class}\n+\n+@itemize @bullet\n+@item @code{GIMPLE_INVALID_RHS}\n+The tree cannot be used as a GIMPLE operand.\n+\n+@item @code{GIMPLE_BINARY_RHS}\n+The tree is a valid GIMPLE binary operation.\n+\n+@item @code{GIMPLE_UNARY_RHS}\n+The tree is a valid GIMPLE unary operation.\n+\n+@item @code{GIMPLE_SINGLE_RHS}\n+The tree is a single object, that cannot be split into simpler\n+operands (for instance, @code{SSA_NAME}, @code{VAR_DECL}, @code{COMPONENT_REF}, etc).\n+\n+This operand class also acts as an escape hatch for tree nodes\n+that may be flattened out into the operand vector, but would need\n+more than two slots on the RHS.  For instance, a @code{COND_EXPR}\n+expression of the form @code{(a op b) ? x : y} could be flattened\n+out on the operand vector using 4 slots, but it would also\n+require additional processing to distinguish @code{c = a op b}\n+from @code{c = a op b ? x : y}.  Something similar occurs with\n+@code{ASSERT_EXPR}.   In time, these special case tree\n+expressions should be flattened into the operand vector.\n+@end itemize\n+\n+For tree nodes in the categories @code{GIMPLE_BINARY_RHS} and\n+@code{GIMPLE_UNARY_RHS}, they cannot be stored inside tuples directly.\n+They first need to be flattened and separated into individual\n+components.  For instance, given the GENERIC expression\n+\n+@smallexample\n+a = b + c\n+@end smallexample\n+\n+its tree representation is:\n+\n+@smallexample\n+MODIFY_EXPR <VAR_DECL  <a>, PLUS_EXPR <VAR_DECL <b>, VAR_DECL <c>>>\n+@end smallexample\n+\n+In this case, the GIMPLE form for this statement is logically\n+identical to its GENERIC form but in GIMPLE, the @code{PLUS_EXPR}\n+on the RHS of the assignment is not represented as a tree,\n+instead the two operands are taken out of the @code{PLUS_EXPR} sub-tree\n+and flattened into the GIMPLE tuple as follows:\n+\n+@smallexample\n+GIMPLE_ASSIGN <PLUS_EXPR, VAR_DECL <a>, VAR_DECL <b>, VAR_DECL <c>>\n+@end smallexample\n+\n+@subsection Operand vector allocation\n+\n+The operand vector is stored at the bottom of the three tuple\n+structures that accept operands. This means, that depending on\n+the code of a given statement, its operand vector will be at\n+different offsets from the base of the structure.  To access\n+tuple operands use the following accessors\n+\n+@deftypefn {GIMPLE function} unsigned gimple_num_ops (gimple g)\n+Returns the number of operands in statement G.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_op (gimple g, unsigned i)\n+Returns operand @code{I} from statement @code{G}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_ops (gimple g)\n+Returns a pointer into the operand vector for statement @code{G}.  This\n+is computed using an internal table called @code{gimple_ops_offset_}[].\n+This table is indexed by the gimple code of @code{G}.\n+\n+When the compiler is built, this table is filled-in using the\n+sizes of the structures used by each statement code defined in\n+gimple.def.  Since the operand vector is at the bottom of the\n+structure, for a gimple code @code{C} the offset is computed as sizeof\n+(struct-of @code{C}) - sizeof (tree).\n+\n+This mechanism adds one memory indirection to every access when\n+using @code{gimple_op}(), if this becomes a bottleneck, a pass can\n+choose to memoize the result from @code{gimple_ops}() and use that to\n+access the operands.\n+@end deftypefn\n+\n+@subsection Operand validation\n+\n+When adding a new operand to a gimple statement, the operand will\n+be validated according to what each tuple accepts in its operand\n+vector.  These predicates are called by the\n+@code{gimple_<name>_set_...()}.  Each tuple will use one of the\n+following predicates (Note, this list is not exhaustive):\n+\n+@deftypefn {GIMPLE function} is_gimple_operand (tree t)\n+This is the most permissive of the predicates.  It essentially\n+checks whether t has a @code{gimple_rhs_class} of @code{GIMPLE_SINGLE_RHS}.\n+@end deftypefn\n+\n+\n+@deftypefn {GIMPLE function} is_gimple_val (tree t)\n+Returns true if t is a \"GIMPLE value\", which are all the\n+non-addressable stack variables (variables for which\n+@code{is_gimple_reg} returns true) and constants (expressions for which\n+@code{is_gimple_min_invariant} returns true).\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} is_gimple_addressable (tree t)\n+Returns true if t is a symbol or memory reference whose address\n+can be taken.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} is_gimple_asm_val (tree t)\n+Similar to @code{is_gimple_val} but it also accepts hard registers.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} is_gimple_call_addr (tree t)\n+Return true if t is a valid expression to use as the function\n+called by a @code{GIMPLE_CALL}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} is_gimple_constant (tree t)\n+Return true if t is a valid gimple constant.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} is_gimple_min_invariant (tree t)\n+Return true if t is a valid minimal invariant.  This is different\n+from constants, in that the specific value of t may not be known\n+at compile time, but it is known that it doesn't change (e.g.,\n+the address of a function local variable).\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} is_gimple_min_invariant_address (tree t)\n+Return true if t is an @code{ADDR_EXPR} that does not change once the\n+program is running.\n+@end deftypefn\n+\n+\n+@subsection Statement validation\n+\n+@deftypefn {GIMPLE function} is_gimple_assign (gimple g)\n+Return true if the code of g is @code{GIMPLE_ASSIGN}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} is_gimple_call (gimple g)\n+Return true if the code of g is @code{GIMPLE_CALL}\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} gimple_assign_cast_p (gimple g)\n+Return true if g is a @code{GIMPLE_ASSIGN} that performs a type cast\n+operation\n+@end deftypefn\n+\n+@node Manipulating GIMPLE statements\n+@section Manipulating GIMPLE statements\n+@cindex Manipulating GIMPLE statements\n+\n+This section documents all the functions available to handle each\n+of the GIMPLE instructions.\n+\n+@subsection Common accessors \n+The following are common accessors for gimple statements.\n+\n+@deftypefn {GIMPLE function} enum gimple_code gimple_code (gimple g)\n+Return the code for statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} basic_block gimple_bb (gimple g)\n+Return the basic block to which statement @code{G} belongs to.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_block (gimple g)\n+Return the lexical scope block holding statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_expr_type (gimple stmt)\n+Return the type of the main expression computed by @code{STMT}. Return\n+@code{void_type_node} if @code{STMT} computes nothing. This will only return\n+something meaningful for @code{GIMPLE_ASSIGN}, @code{GIMPLE_COND} and\n+@code{GIMPLE_CALL}.  For all other tuple codes, it will return\n+@code{void_type_node}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} enum tree_code gimple_expr_code (gimple stmt)\n+Return the tree code for the expression computed by @code{STMT}.  This\n+is only meaningful for @code{GIMPLE_CALL}, @code{GIMPLE_ASSIGN} and\n+@code{GIMPLE_COND}.  If @code{STMT} is @code{GIMPLE_CALL}, it will return @code{CALL_EXPR}.\n+For @code{GIMPLE_COND}, it returns the code of the comparison predicate.\n+For @code{GIMPLE_ASSIGN} it returns the code of the operation performed\n+by the @code{RHS} of the assignment.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_set_block (gimple g, tree block)\n+Set the lexical scope block of @code{G} to @code{BLOCK}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} location_t gimple_locus (gimple g)\n+Return locus information for statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_set_locus (gimple g, location_t locus)\n+Set locus information for statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} bool gimple_locus_empty_p (gimple g)\n+Return true if @code{G} does not have locus information.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} bool gimple_no_warning_p (gimple stmt)\n+Return true if no warnings should be emitted for statement @code{STMT}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_set_visited (gimple stmt, bool visited_p)\n+Set the visited status on statement @code{STMT} to @code{VISITED_P}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} bool gimple_visited_p (gimple stmt)\n+Return the visited status on statement @code{STMT}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_set_plf (gimple stmt, enum plf_mask plf, bool val_p)\n+Set pass local flag @code{PLF} on statement @code{STMT} to @code{VAL_P}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} unsigned int gimple_plf (gimple stmt, enum plf_mask plf)\n+Return the value of pass local flag @code{PLF} on statement @code{STMT}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} bool gimple_has_ops (gimple g)\n+Return true if statement @code{G} has register or memory operands.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} bool gimple_has_mem_ops (gimple g)\n+Return true if statement @code{G} has memory operands.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} unsigned gimple_num_ops (gimple g)\n+Return the number of operands for statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree *gimple_ops (gimple g)\n+Return the array of operands for statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_op (gimple g, unsigned i)\n+Return operand @code{I} for statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree *gimple_op_ptr (gimple g, unsigned i)\n+Return a pointer to operand @code{I} for statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_set_op (gimple g, unsigned i, tree op)\n+Set operand @code{I} of statement @code{G} to @code{OP}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} bitmap gimple_addresses_taken (gimple stmt)\n+Return the set of symbols that have had their address taken by\n+@code{STMT}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} struct def_optype_d *gimple_def_ops (gimple g)\n+Return the set of @code{DEF} operands for statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_set_def_ops (gimple g, struct def_optype_d *def)\n+Set @code{DEF} to be the set of @code{DEF} operands for statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} struct use_optype_d *gimple_use_ops (gimple g)\n+Return the set of @code{USE} operands for statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_set_use_ops (gimple g, struct use_optype_d *use)\n+Set @code{USE} to be the set of @code{USE} operands for statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} struct voptype_d *gimple_vuse_ops (gimple g)\n+Return the set of @code{VUSE} operands for statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_set_vuse_ops (gimple g, struct voptype_d *ops)\n+Set @code{OPS} to be the set of @code{VUSE} operands for statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} struct voptype_d *gimple_vdef_ops (gimple g)\n+Return the set of @code{VDEF} operands for statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_set_vdef_ops (gimple g, struct voptype_d *ops)\n+Set @code{OPS} to be the set of @code{VDEF} operands for statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} bitmap gimple_loaded_syms (gimple g)\n+Return the set of symbols loaded by statement @code{G}.  Each element of\n+the set is the @code{DECL_UID} of the corresponding symbol.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} bitmap gimple_stored_syms (gimple g)\n+Return the set of symbols stored by statement @code{G}.  Each element of\n+the set is the @code{DECL_UID} of the corresponding symbol.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} bool gimple_modified_p (gimple g)\n+Return true if statement @code{G} has operands and the modified field\n+has been set.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} bool gimple_has_volatile_ops (gimple stmt)\n+Return true if statement @code{STMT} contains volatile operands.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_set_has_volatile_ops (gimple stmt, bool volatilep)\n+Return true if statement @code{STMT} contains volatile operands.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void update_stmt (gimple s)\n+Mark statement @code{S} as modified, and update it.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void update_stmt_if_modified (gimple s)\n+Update statement @code{S} if it has been marked modified.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} gimple gimple_copy (gimple stmt)\n+Return a deep copy of statement @code{STMT}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple gimple_copy_call_skip_args (gimple stmt, bitmap args_to_skip)\n+Build a @code{GIMPLE_CALL} identical to @code{STMT} but skipping the arguments\n+in the positions marked by the set @code{ARGS_TO_SKIP}.\n+@end deftypefn\n+\n+@node Tuple specific accessors\n+@section Tuple specific accessors\n+@cindex Tuple specific accessors\n+\n+@menu\n+* @code{GIMPLE_ASM}::\n+* @code{GIMPLE_ASSIGN}::\n+* @code{GIMPLE_BIND}::\n+* @code{GIMPLE_CALL}::\n+* @code{GIMPLE_CATCH}::\n+* @code{GIMPLE_CHANGE_DYNAMIC_TYPE}::\n+* @code{GIMPLE_COND}::\n+* @code{GIMPLE_EH_FILTER}::\n+* @code{GIMPLE_LABEL}::\n+* @code{GIMPLE_NOP}::\n+* @code{GIMPLE_OMP_ATOMIC_LOAD}::\n+* @code{GIMPLE_OMP_ATOMIC_STORE}::\n+* @code{GIMPLE_OMP_CONTINUE}::\n+* @code{GIMPLE_OMP_CRITICAL}::\n+* @code{GIMPLE_OMP_FOR}::\n+* @code{GIMPLE_OMP_MASTER}::\n+* @code{GIMPLE_OMP_ORDERED}::\n+* @code{GIMPLE_OMP_PARALLEL}::\n+* @code{GIMPLE_OMP_RETURN}::\n+* @code{GIMPLE_OMP_SECTION}::\n+* @code{GIMPLE_OMP_SECTIONS}::\n+* @code{GIMPLE_OMP_SINGLE}::\n+* @code{GIMPLE_PHI}::\n+* @code{GIMPLE_RESX}::\n+* @code{GIMPLE_RETURN}::\n+* @code{GIMPLE_SWITCH}::\n+* @code{GIMPLE_TRY}::\n+* @code{GIMPLE_WITH_CLEANUP_EXPR}::\n+@end menu\n+\n+\n+@node @code{GIMPLE_ASM}\n+@subsection @code{GIMPLE_ASM}\n+@cindex @code{GIMPLE_ASM}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_asm (const char *string, ninputs, noutputs, nclobbers, ...)\n+Build a @code{GIMPLE_ASM} statement.  This statement is used for\n+building in-line assembly constructs.  @code{STRING} is the assembly\n+code.  @code{NINPUT} is the number of register inputs.  @code{NOUTPUT} is the\n+number of register outputs.  @code{NCLOBBERS} is the number of clobbered\n+registers.  The rest of the arguments trees for each input,\n+output, and clobbered registers.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_asm_vec (const char *, VEC(tree,gc) *, VEC(tree,gc) *, VEC(tree,gc) *)\n+Identical to gimple_build_asm, but the arguments are passed in\n+VECs.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_asm_ninputs (gimple g)\n+Return the number of input operands for @code{GIMPLE_ASM} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_asm_noutputs (gimple g)\n+Return the number of output operands for @code{GIMPLE_ASM} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_asm_nclobbers (gimple g)\n+Return the number of clobber operands for @code{GIMPLE_ASM} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_asm_input_op (gimple g, unsigned index)\n+Return input operand @code{INDEX} of @code{GIMPLE_ASM} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_asm_set_input_op (gimple g, unsigned index, tree in_op)\n+Set @code{IN_OP} to be input operand @code{INDEX} in @code{GIMPLE_ASM} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_asm_output_op (gimple g, unsigned index)\n+Return output operand @code{INDEX} of @code{GIMPLE_ASM} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_asm_set_output_op (gimple g, unsigne\n+index, tree out_op)\n+Set @code{OUT_OP} to be output operand @code{INDEX} in @code{GIMPLE_ASM} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_asm_clobber_op (gimple g, unsigned index)\n+Return clobber operand @code{INDEX} of @code{GIMPLE_ASM} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_asm_set_clobber_op (gimple g, unsigned index, tree clobber_op)\n+Set @code{CLOBBER_OP} to be clobber operand @code{INDEX} in @code{GIMPLE_ASM} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} const char *gimple_asm_string (gimple g)\n+Return the string representing the assembly instruction in\n+@code{GIMPLE_ASM} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} bool gimple_asm_volatile_p (gimple g)\n+Return true if @code{G} is an asm statement marked volatile. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_asm_set_volatile (gimple g)\n+Mark asm statement @code{G} as volatile. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_asm_clear_volatile (gimple g)\n+Remove volatile marker from asm statement @code{G}. \n+@end deftypefn\n+\n+@node @code{GIMPLE_ASSIGN}\n+@subsection @code{GIMPLE_ASSIGN}\n+@cindex @code{GIMPLE_ASSIGN}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_assign (tree lhs, tree rhs)\n+Build a @code{GIMPLE_ASSIGN} statement.  The left-hand side is an lvalue\n+passed in lhs.  The right-hand side can be either a unary or\n+binary tree expression.  The expression tree rhs will be\n+flattened and its operands assigned to the corresponding operand\n+slots in the new statement.  This function is useful when you\n+already have a tree expression that you want to convert into a\n+tuple.  However, try to avoid building expression trees for the\n+sole purpose of calling this function.  If you already have the\n+operands in separate trees, it is better to use\n+@code{gimple_build_assign_with_ops}.\n+@end deftypefn\n+\n+\n+@deftypefn {GIMPLE function} gimple gimplify_assign (tree dst, tree src, gimple_seq *seq_p)\n+Build a new @code{GIMPLE_ASSIGN} tuple and append it to the end of\n+@code{*SEQ_P}.\n+@end deftypefn\n+\n+@code{DST}/@code{SRC} are the destination and source respectively.  You can\n+pass ungimplified trees in @code{DST} or @code{SRC}, in which\n+case they will be converted to a gimple operand if necessary.\n+\n+This function returns the newly created @code{GIMPLE_ASSIGN} tuple.\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_assign_with_ops (enum tree_code subcode, tree lhs, tree op1, tree op2)\n+This function is similar to @code{gimple_build_assign}, but is used to\n+build a @code{GIMPLE_ASSIGN} statement when the operands of the\n+right-hand side of the assignment are already split into\n+different operands.\n+\n+The left-hand side is an lvalue passed in lhs.  Subcode is the\n+@code{tree_code} for the right-hand side of the assignment.  Op1 and op2\n+are the operands.  If op2 is null, subcode must be a @code{tree_code}\n+for a unary expression.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} enum tree_code gimple_assign_rhs_code (gimple g)\n+Return the code of the expression computed on the @code{RHS} of\n+assignment statement @code{G}.\n+@end deftypefn\n+ \n+\n+@deftypefn {GIMPLE function} enum gimple_rhs_class gimple_assign_rhs_class (gimple g)\n+Return the gimple rhs class of the code fo the expression\n+computed on the rhs of assignment statment @code{G}.  This will never\n+return @code{GIMPLE_INVALID_RHS}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_assign_lhs (gimple g)\n+Return the @code{LHS} of assignment statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree *gimple_assign_lhs_ptr (gimple g)\n+Return a pointer to the @code{LHS} of assignment statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_assign_rhs1 (gimple g)\n+Return the first operand on the @code{RHS} of assignment statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree *gimple_assign_rhs1_ptr (gimple g)\n+Return the address of the first operand on the @code{RHS} of assignment\n+statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_assign_rhs2 (gimple g)\n+Return the second operand on the @code{RHS} of assignment statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree *gimple_assign_rhs2_ptr (gimple g)\n+Return the address of the second operand on the @code{RHS} of assignment\n+statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_assign_set_lhs (gimple g, tree lhs)\n+Set @code{LHS} to be the @code{LHS} operand of assignment statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_assign_set_rhs1 (gimple g, tree rhs)\n+Set @code{RHS} to be the first operand on the @code{RHS} of assignment\n+statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_assign_rhs2 (gimple g)\n+Return the second operand on the @code{RHS} of assignment statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree *gimple_assign_rhs2_ptr (gimple g)\n+Return a pointer to the second operand on the @code{RHS} of assignment\n+statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_assign_set_rhs2 (gimple g, tree rhs)\n+Set @code{RHS} to be the second operand on the @code{RHS} of assignment\n+statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} bool gimple_assign_cast_p (gimple s)\n+Return true if @code{S} is an type-cast assignment.\n+@end deftypefn\n+\n+\n+@node @code{GIMPLE_BIND}\n+@subsection @code{GIMPLE_BIND}\n+@cindex @code{GIMPLE_BIND}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_bind (tree vars, gimple_seq body)\n+Build a @code{GIMPLE_BIND} statement with a list of variables in @code{VARS}\n+and a body of statements in sequence @code{BODY}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_bind_vars (gimple g)\n+Return the variables declared in the @code{GIMPLE_BIND} statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_bind_set_vars (gimple g, tree vars)\n+Set @code{VARS} to be the set of variables declared in the @code{GIMPLE_BIND}\n+statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_bind_append_vars (gimple g, tree vars)\n+Append @code{VARS} to the set of variables declared in the @code{GIMPLE_BIND}\n+statement @code{G}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_seq gimple_bind_body (gimple g)\n+Return the GIMPLE sequence contained in the @code{GIMPLE_BIND} statement\n+@code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_bind_set_body (gimple g, gimple_seq seq)\n+Set @code{SEQ} to be sequence contained in the @code{GIMPLE_BIND} statement @code{G}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_bind_add_stmt (gimple gs, gimple stmt)\n+Append a statement to the end of a @code{GIMPLE_BIND}'s body. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_bind_add_seq (gimple gs, gimple_seq seq)\n+Append a sequence of statements to the end of a @code{GIMPLE_BIND}'s\n+body.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_bind_block (gimple g)\n+Return the @code{TREE_BLOCK} node associated with @code{GIMPLE_BIND} statement\n+@code{G}. This is analogous to the @code{BIND_EXPR_BLOCK} field in trees. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_bind_set_block (gimple g, tree block)\n+Set @code{BLOCK} to be the @code{TREE_BLOCK} node associated with @code{GIMPLE_BIND}\n+statement @code{G}. \n+@end deftypefn\n+\n+\n+@node @code{GIMPLE_CALL}\n+@subsection @code{GIMPLE_CALL}\n+@cindex @code{GIMPLE_CALL}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_call (tree fn, unsigned nargs, ...)\n+Build a @code{GIMPLE_CALL} statement to function @code{FN}.  The argument @code{FN}\n+must be either a @code{FUNCTION_DECL} or a gimple call address as\n+determined by @code{is_gimple_call_addr}.  @code{NARGS} are the number of\n+arguments.  The rest of the arguments follow the argument @code{NARGS},\n+and must be trees that are valid as rvalues in gimple (i.e., each\n+operand is validated with @code{is_gimple_operand}).\n+@end deftypefn\n+\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_call_from_tree (tree call_expr)\n+Build a @code{GIMPLE_CALL} from a @code{CALL_EXPR} node.  The arguments and the\n+function are taken from the expression directly.  This routine\n+assumes that @code{call_expr} is already in GIMPLE form.  That is, its\n+operands are GIMPLE values and the function call needs no further\n+simplification.  All the call flags in @code{call_expr} are copied over\n+to the new @code{GIMPLE_CALL}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_call_vec (tree fn, @code{VEC}(tree, heap) *args)\n+Identical to @code{gimple_build_call} but the arguments are stored in a\n+@code{VEC}().\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_call_lhs (gimple g)\n+Return the @code{LHS} of call statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree *gimple_call_lhs_ptr (gimple g)\n+Return a pointer to the @code{LHS} of call statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_call_set_lhs (gimple g, tree lhs)\n+Set @code{LHS} to be the @code{LHS} operand of call statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_call_fn (gimple g)\n+Return the tree node representing the function called by call\n+statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_call_set_fn (gimple g, tree fn)\n+Set @code{FN} to be the function called by call statement @code{G}.  This has\n+to be a gimple value specifying the address of the called\n+function.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_call_fndecl (gimple g)\n+If a given @code{GIMPLE_CALL}'s callee is a @code{FUNCTION_DECL}, return it.\n+Otherwise return @code{NULL}.  This function is analogous to\n+@code{get_callee_fndecl} in @code{GENERIC}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_call_set_fndecl (gimple g, tree fndecl)\n+Set the called function to @code{FNDECL}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_call_return_type (gimple g)\n+Return the type returned by call statement @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_call_chain (gimple g)\n+Return the static chain for call statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_call_set_chain (gimple g, tree chain)\n+Set @code{CHAIN} to be the static chain for call statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_call_num_args (gimple g)\n+Return the number of arguments used by call statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_call_arg (gimple g, unsigned index)\n+Return the argument at position @code{INDEX} for call statement @code{G}.  The\n+first argument is 0.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree *gimple_call_arg_ptr (gimple g, unsigned index)\n+Return a pointer to the argument at position @code{INDEX} for call\n+statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_call_set_arg (gimple g, unsigned index, tree arg)\n+Set @code{ARG} to be the argument at position @code{INDEX} for call statement\n+@code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_call_set_tail (gimple s)\n+Mark call statement @code{S} as being a tail call (i.e., a call just\n+before the exit of a function). These calls are candidate for\n+tail call optimization. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} bool gimple_call_tail_p (gimple s)\n+Return true if @code{GIMPLE_CALL} @code{S} is marked as a tail call. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_call_mark_uninlinable (gimple s)\n+Mark @code{GIMPLE_CALL} @code{S} as being uninlinable. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} bool gimple_call_cannot_inline_p (gimple s)\n+Return true if @code{GIMPLE_CALL} @code{S} cannot be inlined. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} bool gimple_call_noreturn_p (gimple s)\n+Return true if @code{S} is a noreturn call. \n+@end deftypefn\n+\n+\n+@node @code{GIMPLE_CATCH}\n+@subsection @code{GIMPLE_CATCH}\n+@cindex @code{GIMPLE_CATCH}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_catch (tree types, gimple_seq handler)\n+Build a @code{GIMPLE_CATCH} statement.  @code{TYPES} are the tree types this\n+catch handles.  @code{HANDLER} is a sequence of statements with the code\n+for the handler.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_catch_types (gimple g)\n+Return the types handled by @code{GIMPLE_CATCH} statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_catch_types_ptr (gimple g)\n+Return a pointer to the types handled by @code{GIMPLE_CATCH} statement\n+@code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_seq gimple_catch_handler (gimple g)\n+Return the GIMPLE sequence representing the body of the handler\n+of @code{GIMPLE_CATCH} statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_catch_set_types (gimple g, tree t)\n+Set @code{T} to be the set of types handled by @code{GIMPLE_CATCH} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_catch_set_handler (gimple g, gimple_seq handler)\n+Set @code{HANDLER} to be the body of @code{GIMPLE_CATCH} @code{G}. \n+@end deftypefn\n+\n+@node @code{GIMPLE_CHANGE_DYNAMIC_TYPE}\n+@subsection @code{GIMPLE_CHANGE_DYNAMIC_TYPE}\n+@cindex @code{GIMPLE_CHANGE_DYNAMIC_TYPE}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_cdt (tree type, tree ptr)\n+Build a @code{GIMPLE_CHANGE_DYNAMIC_TYPE} statement.  @code{TYPE} is the new\n+type for the location @code{PTR}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_cdt_new_type (gimple g)\n+Return the new type set by @code{GIMPLE_CHANGE_DYNAMIC_TYPE} statement\n+@code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_cdt_new_type_ptr (gimple g)\n+Return a pointer to the new type set by\n+@code{GIMPLE_CHANGE_DYNAMIC_TYPE} statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_cdt_set_new_type (gimple g, tree new_type)\n+Set @code{NEW_TYPE} to be the type returned by\n+@code{GIMPLE_CHANGE_DYNAMIC_TYPE} statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_cdt_location (gimple g)\n+Return the location affected by @code{GIMPLE_CHANGE_DYNAMIC_TYPE}\n+statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_cdt_location_ptr (gimple g)\n+Return a pointer to the location affected by\n+@code{GIMPLE_CHANGE_DYNAMIC_TYPE} statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_cdt_set_location (gimple g, tree ptr)\n+Set @code{PTR} to be the location affected by @code{GIMPLE_CHANGE_DYNAMIC_TYPE}\n+statement @code{G}. \n+@end deftypefn\n+\n+\n+@node @code{GIMPLE_COND}\n+@subsection @code{GIMPLE_COND}\n+@cindex @code{GIMPLE_COND}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_cond (enum tree_code pred_code, tree lhs, tree rhs, tree t_label, tree f_label)\n+Build a @code{GIMPLE_COND} statement.  @code{A} @code{GIMPLE_COND} statement compares\n+@code{LHS} and @code{RHS} and if the condition in @code{PRED_CODE} is true, jump to\n+the label in @code{t_label}, otherwise jump to the label in @code{f_label}.\n+@code{PRED_CODE} are relational operator tree codes like @code{EQ_EXPR},\n+@code{LT_EXPR}, @code{LE_EXPR}, @code{NE_EXPR}, etc.\n+@end deftypefn\n+\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_cond_from_tree (tree cond, tree t_label, tree f_label)\n+Build a @code{GIMPLE_COND} statement from the conditional expression\n+tree @code{COND}.  @code{T_LABEL} and @code{F_LABEL} are as in @code{gimple_build_cond}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} enum tree_code gimple_cond_code (gimple g)\n+Return the code of the predicate computed by conditional\n+statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_cond_set_code (gimple g, enum tree_code code)\n+Set @code{CODE} to be the predicate code for the conditional statement\n+@code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_cond_lhs (gimple g)\n+Return the @code{LHS} of the predicate computed by conditional statement\n+@code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_cond_set_lhs (gimple g, tree lhs)\n+Set @code{LHS} to be the @code{LHS} operand of the predicate computed by\n+conditional statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_cond_rhs (gimple g)\n+Return the @code{RHS} operand of the predicate computed by conditional\n+@code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_cond_set_rhs (gimple g, tree rhs)\n+Set @code{RHS} to be the @code{RHS} operand of the predicate computed by\n+conditional statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_cond_true_label (gimple g)\n+Return the label used by conditional statement @code{G} when its\n+predicate evaluates to true. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_cond_set_true_label (gimple g, tree label)\n+Set @code{LABEL} to be the label used by conditional statement @code{G} when\n+its predicate evaluates to true. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_cond_set_false_label (gimple g, tree label)\n+Set @code{LABEL} to be the label used by conditional statement @code{G} when\n+its predicate evaluates to false. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_cond_false_label (gimple g)\n+Return the label used by conditional statement @code{G} when its\n+predicate evaluates to false. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_cond_make_false (gimple g)\n+Set the conditional @code{COND_STMT} to be of the form 'if (1 == 0)'. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_cond_make_true (gimple g)\n+Set the conditional @code{COND_STMT} to be of the form 'if (1 == 1)'. \n+@end deftypefn\n+\n+@node @code{GIMPLE_EH_FILTER}\n+@subsection @code{GIMPLE_EH_FILTER}\n+@cindex @code{GIMPLE_EH_FILTER}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_eh_filter (tree types, gimple_seq failure)\n+Build a @code{GIMPLE_EH_FILTER} statement.  @code{TYPES} are the filter's\n+types.  @code{FAILURE} is a sequence with the filter's failure action.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_eh_filter_types (gimple g)\n+Return the types handled by @code{GIMPLE_EH_FILTER} statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_eh_filter_types_ptr (gimple g)\n+Return a pointer to the types handled by @code{GIMPLE_EH_FILTER}\n+statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_seq gimple_eh_filter_failure (gimple g)\n+Return the sequence of statement to execute when @code{GIMPLE_EH_FILTER}\n+statement fails. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_eh_filter_set_types (gimple g, tree types)\n+Set @code{TYPES} to be the set of types handled by @code{GIMPLE_EH_FILTER} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_eh_filter_set_failure (gimple g, gimple_seq failure)\n+Set @code{FAILURE} to be the sequence of statements to execute on\n+failure for @code{GIMPLE_EH_FILTER} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} bool gimple_eh_filter_must_not_throw (gimple g)\n+Return the @code{EH_FILTER_MUST_NOT_THROW} flag. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_eh_filter_set_must_not_throw (gimple g, bool mntp)\n+Set the @code{EH_FILTER_MUST_NOT_THROW} flag. \n+@end deftypefn\n+\n+\n+@node @code{GIMPLE_LABEL}\n+@subsection @code{GIMPLE_LABEL}\n+@cindex @code{GIMPLE_LABEL}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_label (tree label)\n+Build a @code{GIMPLE_LABEL} statement with corresponding to the tree\n+label, @code{LABEL}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_label_label (gimple g)\n+Return the @code{LABEL_DECL} node used by @code{GIMPLE_LABEL} statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_label_set_label (gimple g, tree label)\n+Set @code{LABEL} to be the @code{LABEL_DECL} node used by @code{GIMPLE_LABEL}\n+statement @code{G}. \n+@end deftypefn\n+\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_goto (tree dest)\n+Build a @code{GIMPLE_GOTO} statement to label @code{DEST}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_goto_dest (gimple g)\n+Return the destination of the unconditional jump @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_goto_set_dest (gimple g, tree dest)\n+Set @code{DEST} to be the destination of the unconditonal jump @code{G}. \n+@end deftypefn\n+\n+\n+@node @code{GIMPLE_NOP}\n+@subsection @code{GIMPLE_NOP}\n+@cindex @code{GIMPLE_NOP}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_nop (void)\n+Build a @code{GIMPLE_NOP} statement.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} bool gimple_nop_p (gimple g)\n+Returns @code{TRUE} if statement @code{G} is a @code{GIMPLE_NOP}. \n+@end deftypefn\n+\n+@node @code{GIMPLE_OMP_ATOMIC_LOAD}\n+@subsection @code{GIMPLE_OMP_ATOMIC_LOAD}\n+@cindex @code{GIMPLE_OMP_ATOMIC_LOAD}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_omp_atomic_load (tree lhs, tree rhs)\n+Build a @code{GIMPLE_OMP_ATOMIC_LOAD} statement.  @code{LHS} is the left-hand\n+side of the assignment.  @code{RHS} is the right-hand side of the\n+assignment.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_atomic_load_set_lhs (gimple g, tree lhs)\n+Set the @code{LHS} of an atomic load. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_omp_atomic_load_lhs (gimple g)\n+Get the @code{LHS} of an atomic load. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_atomic_load_set_rhs (gimple g, tree rhs)\n+Set the @code{RHS} of an atomic set. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_omp_atomic_load_rhs (gimple g)\n+Get the @code{RHS} of an atomic set. \n+@end deftypefn\n+\n+\n+@node @code{GIMPLE_OMP_ATOMIC_STORE}\n+@subsection @code{GIMPLE_OMP_ATOMIC_STORE}\n+@cindex @code{GIMPLE_OMP_ATOMIC_STORE}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_omp_atomic_store (tree val)\n+Build a @code{GIMPLE_OMP_ATOMIC_STORE} statement. @code{VAL} is the value to be\n+stored.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_atomic_store_set_val (gimple g, tree val)\n+Set the value being stored in an atomic store. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_omp_atomic_store_val (gimple g)\n+Return the value being stored in an atomic store. \n+@end deftypefn\n+\n+@node @code{GIMPLE_OMP_CONTINUE}\n+@subsection @code{GIMPLE_OMP_CONTINUE}\n+@cindex @code{GIMPLE_OMP_CONTINUE}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_omp_continue (tree control_def, tree control_use)\n+Build a @code{GIMPLE_OMP_CONTINUE} statement.  @code{CONTROL_DEF} is the\n+definition of the control variable.  @code{CONTROL_USE} is the use of\n+the control variable.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_omp_continue_control_def (gimple s)\n+Return the definition of the control variable on a\n+@code{GIMPLE_OMP_CONTINUE} in @code{S}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_omp_continue_control_def_ptr (gimple s)\n+Same as above, but return the pointer.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_omp_continue_set_control_def (gimple s)\n+Set the control variable definition for a @code{GIMPLE_OMP_CONTINUE}\n+statement in @code{S}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_omp_continue_control_use (gimple s)\n+Return the use of the control variable on a @code{GIMPLE_OMP_CONTINUE}\n+in @code{S}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_omp_continue_control_use_ptr (gimple s)\n+Same as above, but return the pointer.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_omp_continue_set_control_use (gimple s)\n+Set the control variable use for a @code{GIMPLE_OMP_CONTINUE} statement\n+in @code{S}.\n+@end deftypefn\n+\n+\n+@node @code{GIMPLE_OMP_CRITICAL}\n+@subsection @code{GIMPLE_OMP_CRITICAL}\n+@cindex @code{GIMPLE_OMP_CRITICAL}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_omp_critical (gimple_seq body, tree name)\n+Build a @code{GIMPLE_OMP_CRITICAL} statement. @code{BODY} is the sequence of\n+statements for which only one thread can execute.  @code{NAME} is an\n+optional identifier for this critical block.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_omp_critical_name (gimple g)\n+Return the name associated with @code{OMP_CRITICAL} statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_omp_critical_name_ptr (gimple g)\n+Return a pointer to the name associated with @code{OMP} critical\n+statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_critical_set_name (gimple g, tree name)\n+Set @code{NAME} to be the name associated with @code{OMP} critical statement @code{G}. \n+@end deftypefn\n+\n+@node @code{GIMPLE_OMP_FOR}\n+@subsection @code{GIMPLE_OMP_FOR}\n+@cindex @code{GIMPLE_OMP_FOR}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_omp_for (gimple_seq body, tre\n+clauses, tree index, tree initial, tree final, tree incr,\n+gimple_seq pre_body, enum tree_code omp_for_cond)\n+Build a @code{GIMPLE_OMP_FOR} statement. @code{BODY} is sequence of statements\n+inside the for loop.  @code{CLAUSES}, are any of the @code{OMP} loop\n+construct's clauses: private, firstprivate,  lastprivate,\n+reductions, ordered, schedule, and nowait.  @code{PRE_BODY} is the\n+sequence of statements that are loop invariant.  @code{INDEX} is the\n+index variable.  @code{INITIAL} is the initial value of @code{INDEX}.  @code{FINAL} is\n+final value of @code{INDEX}.  OMP_FOR_COND is the predicate used to\n+compare @code{INDEX} and @code{FINAL}.  @code{INCR} is the increment expression.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_omp_for_clauses (gimple g)\n+Return the clauses associated with @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_omp_for_clauses_ptr (gimple g)\n+Return a pointer to the @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_for_set_clauses (gimple g, tree clauses)\n+Set @code{CLAUSES} to be the list of clauses associated with @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_omp_for_index (gimple g)\n+Return the index variable for @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_omp_for_index_ptr (gimple g)\n+Return a pointer to the index variable for @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_for_set_index (gimple g, tree index)\n+Set @code{INDEX} to be the index variable for @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_omp_for_initial (gimple g)\n+Return the initial value for @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_omp_for_initial_ptr (gimple g)\n+Return a pointer to the initial value for @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_for_set_initial (gimple g, tree initial)\n+Set @code{INTIAL} to be the initial value for @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_omp_for_final (gimple g)\n+Return the final value for @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_omp_for_final_ptr (gimple g)\n+turn a pointer to the final value for @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_for_set_final (gimple g, tree final)\n+Set @code{FINAL} to be the final value for @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_omp_for_incr (gimple g)\n+Return the increment value for @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_omp_for_incr_ptr (gimple g)\n+Return a pointer to the increment value for @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_for_set_incr (gimple g, tree incr)\n+Set @code{INCR} to be the increment value for @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_seq gimple_omp_for_pre_body (gimple g)\n+Return the sequence of statements to execute before the @code{OMP_FOR}\n+statement @code{G} starts. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_for_set_pre_body (gimple g, gimple_seq pre_body)\n+Set @code{PRE_BODY} to be the sequence of statements to execute before\n+the @code{OMP_FOR} statement @code{G} starts.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_omp_for_set_cond (gimple g, enum tree_code cond)\n+Set @code{COND} to be the condition code for @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} enum tree_code gimple_omp_for_cond (gimple g)\n+Return the condition code associated with @code{OMP_FOR} @code{G}. \n+@end deftypefn\n+\n+\n+@node @code{GIMPLE_OMP_MASTER}\n+@subsection @code{GIMPLE_OMP_MASTER}\n+@cindex @code{GIMPLE_OMP_MASTER}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_omp_master (gimple_seq body)\n+Build a @code{GIMPLE_OMP_MASTER} statement. @code{BODY} is the sequence of\n+statements to be executed by just the master.\n+@end deftypefn\n+\n+\n+@node @code{GIMPLE_OMP_ORDERED}\n+@subsection @code{GIMPLE_OMP_ORDERED}\n+@cindex @code{GIMPLE_OMP_ORDERED}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_omp_ordered (gimple_seq body)\n+Build a @code{GIMPLE_OMP_ORDERED} statement.\n+@end deftypefn\n+\n+@code{BODY} is the sequence of statements inside a loop that will\n+executed in sequence.\n+\n+\n+@node @code{GIMPLE_OMP_PARALLEL}\n+@subsection @code{GIMPLE_OMP_PARALLEL}\n+@cindex @code{GIMPLE_OMP_PARALLEL}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_omp_parallel (gimple_seq body, tree clauses, tree child_fn, tree data_arg)\n+Build a @code{GIMPLE_OMP_PARALLEL} statement.\n+@end deftypefn\n+\n+@code{BODY} is sequence of statements which are executed in parallel.\n+@code{CLAUSES}, are the @code{OMP} parallel construct's clauses.  @code{CHILD_FN} is\n+the function created for the parallel threads to execute.\n+@code{DATA_ARG} are the shared data argument(s).\n+\n+@deftypefn {GIMPLE function} bool gimple_omp_parallel_combined_p (gimple g)\n+Return true if @code{OMP} parallel statement @code{G} has the\n+@code{GF_OMP_PARALLEL_COMBINED} flag set.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_omp_parallel_set_combined_p (gimple g)\n+Set the @code{GF_OMP_PARALLEL_COMBINED} field in @code{OMP} parallel statement\n+@code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} gimple_seq gimple_omp_body (gimple g)\n+Return the body for the @code{OMP} statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_set_body (gimple g, gimple_seq body)\n+Set @code{BODY} to be the body for the @code{OMP} statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_omp_parallel_clauses (gimple g)\n+Return the clauses associated with @code{OMP_PARALLEL} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_omp_parallel_clauses_ptr (gimple g)\n+Return a pointer to the clauses associated with @code{OMP_PARALLEL} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_parallel_set_clauses (gimple g, tree clauses)\n+Set @code{CLAUSES} to be the list of clauses associated with\n+@code{OMP_PARALLEL} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_omp_parallel_child_fn (gimple g)\n+Return the child function used to hold the body of @code{OMP_PARALLEL}\n+@code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_omp_parallel_child_fn_ptr (gimple g)\n+Return a pointer to the child function used to hold the body of\n+@code{OMP_PARALLEL} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_parallel_set_child_fn (gimple g, tree child_fn)\n+Set @code{CHILD_FN} to be the child function for @code{OMP_PARALLEL} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_omp_parallel_data_arg (gimple g)\n+Return the artificial argument used to send variables and values\n+from the parent to the children threads in @code{OMP_PARALLEL} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_omp_parallel_data_arg_ptr (gimple g)\n+Return a pointer to the data argument for @code{OMP_PARALLEL} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_parallel_set_data_arg (gimple g, tree data_arg)\n+Set @code{DATA_ARG} to be the data argument for @code{OMP_PARALLEL} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} bool is_gimple_omp (gimple stmt)\n+Returns true when the gimple statment @code{STMT} is any of the OpenMP\n+types. \n+@end deftypefn\n+\n+\n+@node @code{GIMPLE_OMP_RETURN}\n+@subsection @code{GIMPLE_OMP_RETURN}\n+@cindex @code{GIMPLE_OMP_RETURN}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_omp_return (bool wait_p)\n+Build a @code{GIMPLE_OMP_RETURN} statement. @code{WAIT_P} is true if this is a\n+non-waiting return.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_return_set_nowait (gimple s)\n+Set the nowait flag on @code{GIMPLE_OMP_RETURN} statement @code{S}.\n+@end deftypefn\n+ \n+\n+@deftypefn {GIMPLE function} bool gimple_omp_return_nowait_p (gimple g)\n+Return true if @code{OMP} return statement @code{G} has the\n+@code{GF_OMP_RETURN_NOWAIT} flag set.\n+@end deftypefn\n+\n+@node @code{GIMPLE_OMP_SECTION}\n+@subsection @code{GIMPLE_OMP_SECTION}\n+@cindex @code{GIMPLE_OMP_SECTION}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_omp_section (gimple_seq body)\n+Build a @code{GIMPLE_OMP_SECTION} statement for a sections statement.\n+@end deftypefn\n+\n+@code{BODY} is the sequence of statements in the section.\n+\n+@deftypefn {GIMPLE function} bool gimple_omp_section_last_p (gimple g)\n+Return true if @code{OMP} section statement @code{G} has the\n+@code{GF_OMP_SECTION_LAST} flag set.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_omp_section_set_last (gimple g)\n+Set the @code{GF_OMP_SECTION_LAST} flag on @code{G}.\n+@end deftypefn\n+\n+@node @code{GIMPLE_OMP_SECTIONS}\n+@subsection @code{GIMPLE_OMP_SECTIONS}\n+@cindex @code{GIMPLE_OMP_SECTIONS}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_omp_sections (gimple_seq body, tree clauses)\n+Build a @code{GIMPLE_OMP_SECTIONS} statement. @code{BODY} is a sequence of\n+section statements.  @code{CLAUSES} are any of the @code{OMP} sections\n+contsruct's clauses: private, firstprivate, lastprivate,\n+reduction, and nowait.\n+@end deftypefn\n+\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_omp_sections_switch (void)\n+Build a @code{GIMPLE_OMP_SECTIONS_SWITCH} statement.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_omp_sections_control (gimple g)\n+Return the control variable associated with the\n+@code{GIMPLE_OMP_SECTIONS} in @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree *gimple_omp_sections_control_ptr (gimple g)\n+Return a pointer to the clauses associated with the\n+@code{GIMPLE_OMP_SECTIONS} in @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} void gimple_omp_sections_set_control (gimple g, tree control)\n+Set @code{CONTROL} to be the set of clauses associated with the\n+@code{GIMPLE_OMP_SECTIONS} in @code{G}.\n+@end deftypefn\n+ \n+@deftypefn {GIMPLE function} tree gimple_omp_sections_clauses (gimple g)\n+Return the clauses associated with @code{OMP_SECTIONS} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_omp_sections_clauses_ptr (gimple g)\n+Return a pointer to the clauses associated with @code{OMP_SECTIONS} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_sections_set_clauses (gimple g, tree clauses)\n+Set @code{CLAUSES} to be the set of clauses associated with @code{OMP_SECTIONS}\n+@code{G}. \n+@end deftypefn\n+\n+\n+@node @code{GIMPLE_OMP_SINGLE}\n+@subsection @code{GIMPLE_OMP_SINGLE}\n+@cindex @code{GIMPLE_OMP_SINGLE}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_omp_single (gimple_seq body, tree clauses)\n+Build a @code{GIMPLE_OMP_SINGLE} statement. @code{BODY} is the sequence of\n+statements that will be executed once.  @code{CLAUSES} are any of the\n+@code{OMP} single construct's clauses: private, firstprivate,\n+copyprivate, nowait.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_omp_single_clauses (gimple g)\n+Return the clauses associated with @code{OMP_SINGLE} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_omp_single_clauses_ptr (gimple g)\n+Return a pointer to the clauses associated with @code{OMP_SINGLE} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_omp_single_set_clauses (gimple g, tree clauses)\n+Set @code{CLAUSES} to be the clauses associated with @code{OMP_SINGLE} @code{G}. \n+@end deftypefn\n+\n+\n+@node @code{GIMPLE_PHI}\n+@subsection @code{GIMPLE_PHI}\n+@cindex @code{GIMPLE_PHI}\n+\n+@deftypefn {GIMPLE function} gimple make_phi_node (tree var, int len)\n+Build a @code{PHI} node with len argument slots for variable var.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} unsigned gimple_phi_capacity (gimple g)\n+Return the maximum number of arguments supported by @code{GIMPLE_PHI} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} unsigned gimple_phi_num_args (gimple g)\n+Return the number of arguments in @code{GIMPLE_PHI} @code{G}. This must always\n+be exactly the number of incoming edges for the basic block\n+holding @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_phi_result (gimple g)\n+Return the @code{SSA} name created by @code{GIMPLE_PHI} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree *gimple_phi_result_ptr (gimple g)\n+Return a pointer to the @code{SSA} name created by @code{GIMPLE_PHI} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_phi_set_result (gimple g, tree result)\n+Set @code{RESULT} to be the @code{SSA} name created by @code{GIMPLE_PHI} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} struct phi_arg_d *gimple_phi_arg (gimple g, index)\n+Return the @code{PHI} argument corresponding to incoming edge @code{INDEX} for\n+@code{GIMPLE_PHI} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_phi_set_arg (gimple g, index, struct phi_arg_d * phiarg)\n+Set @code{PHIARG} to be the argument corresponding to incoming edge\n+@code{INDEX} for @code{GIMPLE_PHI} @code{G}. \n+@end deftypefn\n+\n+@node @code{GIMPLE_RESX}\n+@subsection @code{GIMPLE_RESX}\n+@cindex @code{GIMPLE_RESX}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_resx (int region)\n+Build a @code{GIMPLE_RESX} statement which is a statement.  This\n+statement is a placeholder for _Unwind_Resume before we know if a\n+function call or a branch is needed.  @code{REGION} is the exception\n+region from which control is flowing.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} int gimple_resx_region (gimple g)\n+Return the region number for @code{GIMPLE_RESX} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_resx_set_region (gimple g, int region)\n+Set @code{REGION} to be the region number for @code{GIMPLE_RESX} @code{G}. \n+@end deftypefn\n+\n+@node @code{GIMPLE_RETURN}\n+@subsection @code{GIMPLE_RETURN}\n+@cindex @code{GIMPLE_RETURN}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_return (tree retval)\n+Build a @code{GIMPLE_RETURN} statement whose return value is retval.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_return_retval (gimple g)\n+Return the return value for @code{GIMPLE_RETURN} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_return_set_retval (gimple g, tree retval)\n+Set @code{RETVAL} to be the return value for @code{GIMPLE_RETURN} @code{G}. \n+@end deftypefn\n+\n+@node @code{GIMPLE_SWITCH}\n+@subsection @code{GIMPLE_SWITCH}\n+@cindex @code{GIMPLE_SWITCH}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_switch ( nlabels, tree index, tree default_label, ...)\n+Build a @code{GIMPLE_SWITCH} statement.  @code{NLABELS} are the number of\n+labels excluding the default label.  The default label is passed\n+in @code{DEFAULT_LABEL}.  The rest of the arguments are trees\n+representing the labels.  Each label is a tree of code\n+@code{CASE_LABEL_EXPR}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_switch_vec (tree index, tree default_label, @code{VEC}(tree,heap) *args)\n+This function is an alternate way of building @code{GIMPLE_SWITCH}\n+statements.  @code{INDEX} and @code{DEFAULT_LABEL} are as in\n+gimple_build_switch.  @code{ARGS} is a vector of @code{CASE_LABEL_EXPR} trees\n+that contain the labels.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} unsigned gimple_switch_num_labels (gimple g)\n+Return the number of labels associated with the switch statement\n+@code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_switch_set_num_labels (gimple g, unsigned nlabels)\n+Set @code{NLABELS} to be the number of labels for the switch statement\n+@code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_switch_index (gimple g)\n+Return the index variable used by the switch statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_switch_set_index (gimple g, tree index)\n+Set @code{INDEX} to be the index variable for switch statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_switch_label (gimple g, unsigned index)\n+Return the label numbered @code{INDEX}. The default label is 0, followed\n+by any labels in a switch statement. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_switch_set_label (gimple g, unsigned index, tree label)\n+Set the label number @code{INDEX} to @code{LABEL}. 0 is always the default\n+label. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} tree gimple_switch_default_label (gimple g)\n+Return the default label for a switch statement. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_switch_set_default_label (gimple g, tree label)\n+Set the default label for a switch statement. \n+@end deftypefn\n+\n+\n+@node @code{GIMPLE_TRY}\n+@subsection @code{GIMPLE_TRY}\n+@cindex @code{GIMPLE_TRY}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_try (gimple_seq eval, gimple_seq cleanup, unsigned int kind)\n+Build a @code{GIMPLE_TRY} statement.  @code{EVAL} is a sequence with the\n+expression to evaluate.  @code{CLEANUP} is a sequence of statements to\n+run at clean-up time.  @code{KIND} is the enumeration value\n+@code{GIMPLE_TRY_CATCH} if this statement denotes a try/catch construct\n+or @code{GIMPLE_TRY_FINALLY} if this statement denotes a try/finally\n+construct.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} enum gimple_try_flags gimple_try_kind (gimple g)\n+Return the kind of try block represented by @code{GIMPLE_TRY} @code{G}. This is\n+either @code{GIMPLE_TRY_CATCH} or @code{GIMPLE_TRY_FINALLY}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} bool gimple_try_catch_is_cleanup (gimple g)\n+Return the @code{GIMPLE_TRY_CATCH_IS_CLEANUP} flag. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_seq gimple_try_eval (gimple g)\n+Return the sequence of statements used as the body for @code{GIMPLE_TRY}\n+@code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_seq gimple_try_cleanup (gimple g)\n+Return the sequence of statements used as the cleanup body for\n+@code{GIMPLE_TRY} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_try_set_catch_is_cleanup (gimple g, bool catch_is_cleanup)\n+Set the @code{GIMPLE_TRY_CATCH_IS_CLEANUP} flag. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_try_set_eval (gimple g, gimple_seq eval)\n+Set @code{EVAL} to be the sequence of statements to use as the body for\n+@code{GIMPLE_TRY} @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_try_set_cleanup (gimple g, gimple_seq cleanup)\n+Set @code{CLEANUP} to be the sequence of statements to use as the\n+cleanup body for @code{GIMPLE_TRY} @code{G}. \n+@end deftypefn\n+\n+@node @code{GIMPLE_WITH_CLEANUP_EXPR}\n+@subsection @code{GIMPLE_WITH_CLEANUP_EXPR}\n+@cindex @code{GIMPLE_WITH_CLEANUP_EXPR}\n+\n+@deftypefn {GIMPLE function} gimple gimple_build_wce (gimple_seq cleanup)\n+Build a @code{GIMPLE_WITH_CLEANUP_EXPR} statement.  @code{CLEANUP} is the\n+clean-up expression.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_seq gimple_wce_cleanup (gimple g)\n+Return the cleanup sequence for cleanup statement @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_wce_set_canup (gimple g, gimple_seq cleanup)\n+Set @code{CLEANUP} to be the cleanup sequence for @code{G}. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} bool gimple_wce_cleanup_eh_only (gimple g)\n+Return the @code{CLEANUP_EH_ONLY} flag for a @code{WCE} tuple. \n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_wce_set_cleanup_eh_only (gimple g, bool eh_only_p)\n+Set the @code{CLEANUP_EH_ONLY} flag for a @code{WCE} tuple. \n+@end deftypefn\n+\n+\n+@node GIMPLE sequences \n+@section GIMPLE sequences \n+@cindex GIMPLE sequences \n+\n+GIMPLE sequences are the tuple equivalent of @code{STATEMENT_LIST}'s\n+used in @code{GENERIC}.  They are used to chain statements together, and\n+when used in conjunction with sequence iterators, provide a\n+framework for iterating through statements.\n+\n+GIMPLE sequences are of type struct @code{gimple_sequence}, but are more\n+commonly passed by reference to functions dealing with sequences.\n+The type for a sequence pointer is @code{gimple_seq} which is the same\n+as struct @code{gimple_sequence} *.  When declaring a local sequence,\n+you can define a local variable of type struct @code{gimple_sequence}.\n+When declaring a sequence allocated on the garbage collected\n+heap, use the function @code{gimple_seq_alloc} documented below.\n+\n+There are convenience functions for iterating through sequences\n+in the section entitled Sequence Iterators.\n+\n+Below is a list of functions to manipulate and query sequences.\n+\n+@deftypefn {GIMPLE function} void gimple_seq_add_stmt (gimple_seq *seq, gimple g)\n+Link a gimple statement to the end of the sequence *@code{SEQ} if @code{G} is\n+not @code{NULL}.  If *@code{SEQ} is @code{NULL}, allocate a sequence before linking.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_seq_add_seq (gimple_seq *dest, gimple_seq src)\n+Append sequence @code{SRC} to the end of sequence *@code{DEST} if @code{SRC} is not\n+@code{NULL}.  If *@code{DEST} is @code{NULL}, allocate a new sequence before\n+appending.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_seq gimple_seq_deep_copy (gimple_seq src)\n+Perform a deep copy of sequence @code{SRC} and return the result.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_seq gimple_seq_reverse (gimple_seq seq)\n+Reverse the order of the statements in the sequence @code{SEQ}.  Return\n+@code{SEQ}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple gimple_seq_first (gimple_seq s)\n+Return the first statement in sequence @code{S}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple gimple_seq_last (gimple_seq s)\n+Return the last statement in sequence @code{S}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_seq_set_last (gimple_seq s, gimple last)\n+Set the last statement in sequence @code{S} to the statement in @code{LAST}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_seq_set_first (gimple_seq s, gimple first)\n+Set the first statement in sequence @code{S} to the statement in @code{FIRST}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_seq_init (gimple_seq s)\n+Initialize sequence @code{S} to an empty sequence.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_seq gimple_seq_alloc (void)\n+Allocate a new sequence in the garbage collected store and return\n+it.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gimple_seq_copy (gimple_seq dest, gimple_seq src)\n+Copy the sequence @code{SRC} into the sequence @code{DEST}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} bool gimple_seq_empty_p (gimple_seq s)\n+Return true if the sequence @code{S} is empty.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_seq bb_seq (basic_block bb)\n+Returns the sequence of statements in @code{BB}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void set_bb_seq (basic_block bb, gimple_seq seq)\n+Sets the sequence of statements in @code{BB} to @code{SEQ}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} bool gimple_seq_singleton_p (gimple_seq seq)\n+Determine whether @code{SEQ} contains exactly one statement.\n+@end deftypefn\n+\n+@node Sequence iterators \n+@section Sequence iterators \n+@cindex Sequence iterators \n+\n+Sequence iterators are convenience constructs for iterating\n+through statements in a sequence.  Given a sequence @code{SEQ}, here is\n+a typical use of gimple sequence iterators:\n+\n+@smallexample\n+gimple_stmt_iterator gsi;\n+\n+for (gsi = gsi_start (seq); !gsi_end_p (gsi); gsi_next (&gsi))\n+  @{\n+    gimple g = gsi_stmt (gsi);\n+    /* Do something with gimple statement @code{G}.  */\n+  @}\n+@end smallexample\n+\n+Backward iterations are possible:\n+\n+@smallexample\n+        for (gsi = gsi_last (seq); !gsi_end_p (gsi); gsi_prev (&gsi))\n+@end smallexample\n+\n+Forward and backward iterations on basic blocks are possible with\n+@code{gsi_start_bb} and @code{gsi_last_bb}.\n+\n+In the documentation below we sometimes refer to enum\n+@code{gsi_iterator_update}.  The valid options for this enumeration are:\n+\n+@itemize @bullet\n+@item @code{GSI_NEW_STMT}\n+Only valid when a single statement is added.  Move the iterator to it.\n+\n+@item @code{GSI_SAME_STMT}\n+Leave the iterator at the same statement.\n+\n+@item @code{GSI_CONTINUE_LINKING}\n+Move iterator to whatever position is suitable for linking other\n+statements in the same direction.\n+@end itemize\n+\n+Below is a list of the functions used to manipulate and use\n+statement iterators.\n+\n+@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_start (gimple_seq seq)\n+Return a new iterator pointing to the sequence @code{SEQ}'s first\n+statement.  If @code{SEQ} is empty, the iterator's basic block is @code{NULL}.\n+Use @code{gsi_start_bb} instead when the iterator needs to always have\n+the correct basic block set.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_start_bb (basic_block bb)\n+Return a new iterator pointing to the first statement in basic\n+block @code{BB}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_last (gimple_seq seq)\n+Return a new iterator initially pointing to the last statement of\n+sequence @code{SEQ}.  If @code{SEQ} is empty, the iterator's basic block is\n+@code{NULL}.  Use @code{gsi_last_bb} instead when the iterator needs to always\n+have the correct basic block set.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_last_bb (basic_block bb)\n+Return a new iterator pointing to the last statement in basic\n+block @code{BB}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} bool gsi_end_p (gimple_stmt_iterator i)\n+Return @code{TRUE} if at the end of @code{I}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} bool gsi_one_before_end_p (gimple_stmt_iterator i)\n+Return @code{TRUE} if we're one statement before the end of @code{I}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_next (gimple_stmt_iterator *i)\n+Advance the iterator to the next gimple statement.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_prev (gimple_stmt_iterator *i)\n+Advance the iterator to the previous gimple statement.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple gsi_stmt (gimple_stmt_iterator i)\n+Return the current stmt.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_after_labels (basic_block bb)\n+Return a block statement iterator that points to the first\n+non-label statement in block @code{BB}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple *gsi_stmt_ptr (gimple_stmt_iterator *i)\n+Return a pointer to the current stmt.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} basic_block gsi_bb (gimple_stmt_iterator i)\n+Return the basic block associated with this iterator.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_seq gsi_seq (gimple_stmt_iterator i)\n+Return the sequence associated with this iterator.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_remove (gimple_stmt_iterator *i, bool remove_eh_info)\n+Remove the current stmt from the sequence.  The iterator is\n+updated to point to the next statement.  When @code{REMOVE_EH_INFO} is\n+true we remove the statement pointed to by iterator @code{I} from the @code{EH}\n+tables.  Otherwise we do not modify the @code{EH} tables.  Generally,\n+@code{REMOVE_EH_INFO} should be true when the statement is going to be\n+removed from the @code{IL} and not reinserted elsewhere.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_link_seq_before (gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode)\n+Links the sequence of statements @code{SEQ} before the statement pointed\n+by iterator @code{I}.  @code{MODE} indicates what to do with the iterator\n+after insertion (see @code{enum gsi_iterator_update} above).\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_link_before (gimple_stmt_iterator *i, gimple g, enum gsi_iterator_update mode)\n+Links statement @code{G} before the statement pointed-to by iterator @code{I}.\n+Updates iterator @code{I} according to @code{MODE}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_link_seq_after (gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode)\n+Links sequence @code{SEQ} after the statement pointed-to by iterator @code{I}.\n+@code{MODE} is as in @code{gsi_insert_after}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_link_after (gimple_stmt_iterator *i, gimple g, enum gsi_iterator_update mode)\n+Links statement @code{G} after the statement pointed-to by iterator @code{I}.\n+@code{MODE} is as in @code{gsi_insert_after}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_seq gsi_split_seq_after (gimple_stmt_iterator i)\n+Move all statements in the sequence after @code{I} to a new sequence.\n+Return this new sequence.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_seq gsi_split_seq_before (gimple_stmt_iterator *i)\n+Move all statements in the sequence before @code{I} to a new sequence.\n+Return this new sequence.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_replace (gimple_stmt_iterator *i, gimple stmt, bool update_eh_info)\n+Replace the statement pointed-to by @code{I} to @code{STMT}.  If @code{UPDATE_EH_INFO}\n+is true, the exception handling information of the original\n+statement is moved to the new statement.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_insert_before (gimple_stmt_iterator *i, gimple stmt, enum gsi_iterator_update mode)\n+Insert statement @code{STMT} before the statement pointed-to by iterator\n+@code{I}, update @code{STMT}'s basic block and scan it for new operands.  @code{MODE}\n+specifies how to update iterator @code{I} after insertion (see enum\n+@code{gsi_iterator_update}).\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_insert_seq_before (gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode)\n+Like @code{gsi_insert_before}, but for all the statements in @code{SEQ}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_insert_after (gimple_stmt_iterator *i, gimple stmt, enum gsi_iterator_update mode)\n+Insert statement @code{STMT} after the statement pointed-to by iterator\n+@code{I}, update @code{STMT}'s basic block and scan it for new operands.  @code{MODE}\n+specifies how to update iterator @code{I} after insertion (see enum\n+@code{gsi_iterator_update}).\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_insert_seq_after (gimple_stmt_iterator *i, gimple_seq seq, enum gsi_iterator_update mode)\n+Like @code{gsi_insert_after}, but for all the statements in @code{SEQ}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_stmt_iterator gsi_for_stmt (gimple stmt)\n+Finds iterator for @code{STMT}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_move_after (gimple_stmt_iterator *from, gimple_stmt_iterator *to)\n+Move the statement at @code{FROM} so it comes right after the statement\n+at @code{TO}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_move_before (gimple_stmt_iterator *from, gimple_stmt_iterator *to)\n+Move the statement at @code{FROM} so it comes right before the statement\n+at @code{TO}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_move_to_bb_end (gimple_stmt_iterator *from, basic_block bb)\n+Move the statement at @code{FROM} to the end of basic block @code{BB}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_insert_on_edge (edge e, gimple stmt)\n+Add @code{STMT} to the pending list of edge @code{E}.  No actual insertion is\n+made until a call to @code{gsi_commit_edge_inserts}() is made.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_insert_seq_on_edge (edge e, gimple_seq seq)\n+Add the sequence of statements in @code{SEQ} to the pending list of edge\n+@code{E}.  No actual insertion is made until a call to\n+@code{gsi_commit_edge_inserts}() is made.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} basic_block gsi_insert_on_edge_immediate (edge e, gimple stmt)\n+Similar to @code{gsi_insert_on_edge}+@code{gsi_commit_edge_inserts}.  If a new\n+block has to be created, it is returned.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_commit_one_edge_insert (edge e, basic_block *new_bb)\n+Commit insertions pending at edge @code{E}.  If a new block is created,\n+set @code{NEW_BB} to this block, otherwise set it to @code{NULL}.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} void gsi_commit_edge_inserts (void)\n+This routine will commit all pending edge insertions, creating\n+any new basic blocks which are necessary.\n+@end deftypefn\n+\n+\n+@node Adding a new GIMPLE statement code\n+@section Adding a new GIMPLE statement code\n+@cindex Adding a new GIMPLE statement code\n+\n+The first step in adding a new GIMPLE statement code, is\n+modifying the file @code{gimple.def}, which contains all the GIMPLE\n+codes.  Then you must add a corresponding structure, and an entry\n+in @code{union gimple_statement_d}, both of which are located in\n+@code{gimple.h}.  This in turn, will require you to add a corresponding\n+@code{GTY} tag in @code{gsstruct.def}, and code to handle this tag in\n+@code{gss_for_code} which is located in @code{gimple.c}.\n+\n+In order for the garbage collector to know the size of the\n+structure you created in @code{gimple.h}, you need to add a case to\n+handle your new GIMPLE statement in @code{gimple_size} which is located\n+in @code{gimple.c}.\n+\n+You will probably want to create a function to build the new\n+gimple statement in @code{gimple.c}.  The function should be called\n+@code{gimple_build_<@code{NEW_TUPLE_NAME}>}, and should return the new tuple\n+of type gimple.\n+\n+If your new statement requires accessors for any members or\n+operands it may have, put simple inline accessors in\n+@code{gimple.h} and any non-trivial accessors in @code{gimple.c} with a\n+corresponding prototype in @code{gimple.h}.\n+\n+\n+@node Statement and operand traversals\n+@section Statement and operand traversals\n+@cindex Statement and operand traversals\n+ \n+There are two functions available for walking statements and\n+sequences: @code{walk_gimple_stmt} and @code{walk_gimple_seq},\n+accordingly, and a third function for walking the operands in a\n+statement: @code{walk_gimple_op}.\n+\n+@deftypefn {GIMPLE function} tree walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt, walk_tree_fn callback_op, struct walk_stmt_info *wi)\n+This function is used to walk the current statement in @code{GSI},\n+optionally using traversal state stored in @code{WI}.  If @code{WI} is @code{NULL}, no\n+state is kept during the traversal.\n+\n+The callback @code{CALLBACK_STMT} is called.  If @code{CALLBACK_STMT} returns\n+true, it means that the callback function has handled all the\n+operands of the statement and it is not necessary to walk its\n+operands.\n+\n+If @code{CALLBACK_STMT} is @code{NULL} or it returns false, @code{CALLBACK_OP} is\n+called on each operand of the statement via @code{walk_gimple_op}.  If\n+@code{walk_gimple_op} returns non-@code{NULL} for any operand, the remaining\n+operands are not scanned.\n+\n+The return value is that returned by the last call to\n+@code{walk_gimple_op}, or @code{NULL_TREE} if no @code{CALLBACK_OP} is specified.\n+@end deftypefn\n+\n+\n+@deftypefn {GIMPLE function} tree walk_gimple_op (gimple stmt, walk_tree_fn callback_op, struct walk_stmt_info *wi)\n+Use this function to walk the operands of statement @code{STMT}.  Every\n+operand is walked via @code{walk_tree} with optional state information\n+in @code{WI}.\n+\n+@code{CALLBACK_OP} is called on each operand of @code{STMT} via @code{walk_tree}.\n+Additional parameters to @code{walk_tree} must be stored in @code{WI}.  For\n+each operand @code{OP}, @code{walk_tree} is called as:\n+\n+@smallexample\n+    walk_tree (&@code{OP}, @code{CALLBACK_OP}, @code{WI}, @code{WI}- @code{PSET})\n+@end smallexample\n+\n+If @code{CALLBACK_OP} returns non-@code{NULL} for an operand, the remaining\n+operands are not scanned.  The return value is that returned by\n+the last call to @code{walk_tree}, or @code{NULL_TREE} if no @code{CALLBACK_OP} is\n+specified.\n+@end deftypefn\n+\n+\n+@deftypefn {GIMPLE function} tree walk_gimple_seq (gimple_seq seq, walk_stmt_fn callback_stmt, walk_tree_fn callback_op, struct walk_stmt_info *wi)\n+This function walks all the statements in the sequence @code{SEQ}\n+calling @code{walk_gimple_stmt} on each one.  @code{WI} is as in\n+@code{walk_gimple_stmt}.  If @code{walk_gimple_stmt} returns non-@code{NULL}, the walk\n+is stopped and the value returned.  Otherwise, all the statements\n+are walked and @code{NULL_TREE} returned.\n+@end deftypefn"}, {"sha": "bd0edc442265e23868343b24a4cb65735d63c29d", "filename": "gcc/doc/tree-ssa.texi", "status": "modified", "additions": 11, "deletions": 711, "changes": 722, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=e6c99067cbb1827ecc4a54ec6fdac6e221d933a0", "patch": "@@ -8,7 +8,7 @@\n @c ---------------------------------------------------------------------\n \n @node Tree SSA\n-@chapter Analysis and Optimization of GIMPLE Trees\n+@chapter Analysis and Optimization of GIMPLE tuples\n @cindex Tree SSA\n @cindex Optimization infrastructure for GIMPLE\n \n@@ -37,728 +37,28 @@ functions and programming constructs needed to implement optimization\n passes for GIMPLE@.\n \n @menu\n-* GENERIC::             A high-level language-independent representation.\n-* GIMPLE::              A lower-level factored tree representation.\n-* Annotations::         Attributes for statements and variables.\n-* Statement Operands::  Variables referenced by GIMPLE statements.\n+* Annotations::         Attributes for variables.\n+* SSA Operands::  \tSSA names referenced by GIMPLE statements.\n * SSA::                 Static Single Assignment representation.\n * Alias analysis::      Representing aliased loads and stores.\n @end menu\n \n-@node GENERIC\n-@section GENERIC\n-@cindex GENERIC\n-\n-The purpose of GENERIC is simply to provide a language-independent way of\n-representing an entire function in trees.  To this end, it was necessary to\n-add a few new tree codes to the back end, but most everything was already\n-there.  If you can express it with the codes in @code{gcc/tree.def}, it's\n-GENERIC@.\n-\n-Early on, there was a great deal of debate about how to think about\n-statements in a tree IL@.  In GENERIC, a statement is defined as any\n-expression whose value, if any, is ignored.  A statement will always\n-have @code{TREE_SIDE_EFFECTS} set (or it will be discarded), but a\n-non-statement expression may also have side effects.  A\n-@code{CALL_EXPR}, for instance.\n-\n-It would be possible for some local optimizations to work on the\n-GENERIC form of a function; indeed, the adapted tree inliner works\n-fine on GENERIC, but the current compiler performs inlining after\n-lowering to GIMPLE (a restricted form described in the next section).\n-Indeed, currently the frontends perform this lowering before handing\n-off to @code{tree_rest_of_compilation}, but this seems inelegant.\n-\n-If necessary, a front end can use some language-dependent tree codes\n-in its GENERIC representation, so long as it provides a hook for\n-converting them to GIMPLE and doesn't expect them to work with any\n-(hypothetical) optimizers that run before the conversion to GIMPLE@.\n-The intermediate representation used while parsing C and C++ looks\n-very little like GENERIC, but the C and C++ gimplifier hooks are\n-perfectly happy to take it as input and spit out GIMPLE@.\n-\n-@node GIMPLE\n-@section GIMPLE\n-@cindex GIMPLE\n-\n-GIMPLE is a simplified subset of GENERIC for use in optimization.  The\n-particular subset chosen (and the name) was heavily influenced by the\n-SIMPLE IL used by the McCAT compiler project at McGill University,\n-though we have made some different choices.  For one thing, SIMPLE\n-doesn't support @code{goto}; a production compiler can't afford that\n-kind of restriction.\n-\n-GIMPLE retains much of the structure of the parse trees: lexical\n-scopes are represented as containers, rather than markers.  However,\n-expressions are broken down into a 3-address form, using temporary\n-variables to hold intermediate values.  Also, control structures are\n-lowered to gotos.\n-\n-In GIMPLE no container node is ever used for its value; if a\n-@code{COND_EXPR} or @code{BIND_EXPR} has a value, it is stored into a\n-temporary within the controlled blocks, and that temporary is used in\n-place of the container.\n-\n-The compiler pass which lowers GENERIC to GIMPLE is referred to as the\n-@samp{gimplifier}.  The gimplifier works recursively, replacing complex\n-statements with sequences of simple statements.\n-\n-@c Currently, the only way to\n-@c tell whether or not an expression is in GIMPLE form is by recursively\n-@c examining it; in the future there will probably be a flag to help avoid\n-@c redundant work.  FIXME FIXME\n-\n-@menu\n-* Interfaces::\n-* Temporaries::\n-* GIMPLE Expressions::\n-* Statements::\n-* GIMPLE Example::\n-* Rough GIMPLE Grammar::\n-@end menu\n-\n-@node Interfaces\n-@subsection Interfaces\n-@cindex gimplification\n-\n-The tree representation of a function is stored in\n-@code{DECL_SAVED_TREE}.  It is lowered to GIMPLE by a call to\n-@code{gimplify_function_tree}.\n-\n-If a front end wants to include language-specific tree codes in the tree\n-representation which it provides to the back end, it must provide a\n-definition of @code{LANG_HOOKS_GIMPLIFY_EXPR} which knows how to\n-convert the front end trees to GIMPLE@.  Usually such a hook will involve\n-much of the same code for expanding front end trees to RTL@.  This function\n-can return fully lowered GIMPLE, or it can return GENERIC trees and let the\n-main gimplifier lower them the rest of the way; this is often simpler.\n-GIMPLE that is not fully lowered is known as ``high GIMPLE'' and\n-consists of the IL before the pass @code{pass_lower_cf}.  High GIMPLE\n-still contains lexical scopes and nested expressions, while low GIMPLE\n-exposes all of the implicit jumps for control expressions like\n-@code{COND_EXPR}.\n-\n-The C and C++ front ends currently convert directly from front end\n-trees to GIMPLE, and hand that off to the back end rather than first\n-converting to GENERIC@.  Their gimplifier hooks know about all the\n-@code{_STMT} nodes and how to convert them to GENERIC forms.  There\n-was some work done on a genericization pass which would run first, but\n-the existence of @code{STMT_EXPR} meant that in order to convert all\n-of the C statements into GENERIC equivalents would involve walking the\n-entire tree anyway, so it was simpler to lower all the way.  This\n-might change in the future if someone writes an optimization pass\n-which would work better with higher-level trees, but currently the\n-optimizers all expect GIMPLE@.\n-\n-A front end which wants to use the tree optimizers (and already has\n-some sort of whole-function tree representation) only needs to provide\n-a definition of @code{LANG_HOOKS_GIMPLIFY_EXPR}, call\n-@code{gimplify_function_tree} to lower to GIMPLE, and then hand off to\n-@code{tree_rest_of_compilation} to compile and output the function.\n-\n-You can tell the compiler to dump a C-like representation of the GIMPLE\n-form with the flag @option{-fdump-tree-gimple}.\n-\n-@node Temporaries\n-@subsection Temporaries\n-@cindex Temporaries\n-\n-When gimplification encounters a subexpression which is too complex, it\n-creates a new temporary variable to hold the value of the subexpression,\n-and adds a new statement to initialize it before the current statement.\n-These special temporaries are known as @samp{expression temporaries}, and are\n-allocated using @code{get_formal_tmp_var}.  The compiler tries to\n-always evaluate identical expressions into the same temporary, to simplify\n-elimination of redundant calculations.\n-\n-We can only use expression temporaries when we know that it will not be\n-reevaluated before its value is used, and that it will not be otherwise\n-modified@footnote{These restrictions are derived from those in Morgan 4.8.}.\n-Other temporaries can be allocated using\n-@code{get_initialized_tmp_var} or @code{create_tmp_var}.\n-\n-Currently, an expression like @code{a = b + 5} is not reduced any\n-further.  We tried converting it to something like\n-@smallexample\n-  T1 = b + 5;\n-  a = T1;\n-@end smallexample\n-but this bloated the representation for minimal benefit.  However, a\n-variable which must live in memory cannot appear in an expression; its\n-value is explicitly loaded into a temporary first.  Similarly, storing\n-the value of an expression to a memory variable goes through a\n-temporary.\n-\n-@node GIMPLE Expressions\n-@subsection Expressions\n-@cindex GIMPLE Expressions\n-\n-In general, expressions in GIMPLE consist of an operation and the\n-appropriate number of simple operands; these operands must either be a\n-GIMPLE rvalue (@code{is_gimple_val}), i.e.@: a constant or a register\n-variable.  More complex operands are factored out into temporaries, so\n-that\n-@smallexample\n-  a = b + c + d\n-@end smallexample\n-becomes\n-@smallexample\n-  T1 = b + c;\n-  a = T1 + d;\n-@end smallexample\n-\n-The same rule holds for arguments to a @code{CALL_EXPR}.\n-\n-The target of an assignment is usually a variable, but can also be an\n-@code{INDIRECT_REF} or a compound lvalue as described below.\n-\n-@menu\n-* Compound Expressions::\n-* Compound Lvalues::\n-* Conditional Expressions::\n-* Logical Operators::\n-@end menu\n-\n-@node Compound Expressions\n-@subsubsection Compound Expressions\n-@cindex Compound Expressions\n-\n-The left-hand side of a C comma expression is simply moved into a separate\n-statement.\n-\n-@node Compound Lvalues\n-@subsubsection Compound Lvalues\n-@cindex Compound Lvalues\n-\n-Currently compound lvalues involving array and structure field references\n-are not broken down; an expression like @code{a.b[2] = 42} is not reduced\n-any further (though complex array subscripts are).  This restriction is a\n-workaround for limitations in later optimizers; if we were to convert this\n-to\n-\n-@smallexample\n-  T1 = &a.b;\n-  T1[2] = 42;\n-@end smallexample\n-\n-alias analysis would not remember that the reference to @code{T1[2]} came\n-by way of @code{a.b}, so it would think that the assignment could alias\n-another member of @code{a}; this broke @code{struct-alias-1.c}.  Future\n-optimizer improvements may make this limitation unnecessary.\n-\n-@node Conditional Expressions\n-@subsubsection Conditional Expressions\n-@cindex Conditional Expressions\n-\n-A C @code{?:} expression is converted into an @code{if} statement with\n-each branch assigning to the same temporary.  So,\n-\n-@smallexample\n-  a = b ? c : d;\n-@end smallexample\n-becomes\n-@smallexample\n-  if (b)\n-    T1 = c;\n-  else\n-    T1 = d;\n-  a = T1;\n-@end smallexample\n-\n-Tree level if-conversion pass re-introduces @code{?:} expression, if appropriate.\n-It is used to vectorize loops with conditions using vector conditional operations.\n-\n-Note that in GIMPLE, @code{if} statements are also represented using\n-@code{COND_EXPR}, as described below.\n-\n-@node Logical Operators\n-@subsubsection Logical Operators\n-@cindex Logical Operators\n-\n-Except when they appear in the condition operand of a @code{COND_EXPR},\n-logical `and' and `or' operators are simplified as follows:\n-@code{a = b && c} becomes\n-\n-@smallexample\n-  T1 = (bool)b;\n-  if (T1)\n-    T1 = (bool)c;\n-  a = T1;\n-@end smallexample\n-\n-Note that @code{T1} in this example cannot be an expression temporary,\n-because it has two different assignments.\n-\n-@node Statements\n-@subsection Statements\n-@cindex Statements\n-\n-Most statements will be assignment statements, represented by\n-@code{MODIFY_EXPR}.  A @code{CALL_EXPR} whose value is ignored can\n-also be a statement.  No other C expressions can appear at statement level;\n-a reference to a volatile object is converted into a @code{MODIFY_EXPR}.\n-In GIMPLE form, type of @code{MODIFY_EXPR} is not meaningful.  Instead, use type\n-of LHS or RHS@.\n-\n-There are also several varieties of complex statements.\n-\n-@menu\n-* Blocks::\n-* Statement Sequences::\n-* Empty Statements::\n-* Loops::\n-* Selection Statements::\n-* Jumps::\n-* Cleanups::\n-* GIMPLE Exception Handling::\n-@end menu\n-\n-@node Blocks\n-@subsubsection Blocks\n-@cindex Blocks\n-\n-Block scopes and the variables they declare in GENERIC and GIMPLE are\n-expressed using the @code{BIND_EXPR} code, which in previous versions of\n-GCC was primarily used for the C statement-expression extension.\n-\n-Variables in a block are collected into @code{BIND_EXPR_VARS} in\n-declaration order.  Any runtime initialization is moved out of\n-@code{DECL_INITIAL} and into a statement in the controlled block.  When\n-gimplifying from C or C++, this initialization replaces the\n-@code{DECL_STMT}.\n-\n-Variable-length arrays (VLAs) complicate this process, as their size often\n-refers to variables initialized earlier in the block.  To handle this, we\n-currently split the block at that point, and move the VLA into a new, inner\n-@code{BIND_EXPR}.  This strategy may change in the future.\n-\n-@code{DECL_SAVED_TREE} for a GIMPLE function will always be a\n-@code{BIND_EXPR} which contains declarations for the temporary variables\n-used in the function.\n-\n-A C++ program will usually contain more @code{BIND_EXPR}s than there are\n-syntactic blocks in the source code, since several C++ constructs have\n-implicit scopes associated with them.  On the other hand, although the C++\n-front end uses pseudo-scopes to handle cleanups for objects with\n-destructors, these don't translate into the GIMPLE form; multiple\n-declarations at the same level use the same @code{BIND_EXPR}.\n-\n-@node Statement Sequences\n-@subsubsection Statement Sequences\n-@cindex Statement Sequences\n-\n-Multiple statements at the same nesting level are collected into a\n-@code{STATEMENT_LIST}.  Statement lists are modified and traversed\n-using the interface in @samp{tree-iterator.h}.\n-\n-@node Empty Statements\n-@subsubsection Empty Statements\n-@cindex Empty Statements\n-\n-Whenever possible, statements with no effect are discarded.  But if they\n-are nested within another construct which cannot be discarded for some\n-reason, they are instead replaced with an empty statement, generated by\n-@code{build_empty_stmt}.  Initially, all empty statements were shared,\n-after the pattern of the Java front end, but this caused a lot of trouble in\n-practice.\n-\n-An empty statement is represented as @code{(void)0}.\n-\n-@node Loops\n-@subsubsection Loops\n-@cindex Loops\n-\n-At one time loops were expressed in GIMPLE using @code{LOOP_EXPR}, but\n-now they are lowered to explicit gotos.\n-\n-@node Selection Statements\n-@subsubsection Selection Statements\n-@cindex Selection Statements\n-\n-A simple selection statement, such as the C @code{if} statement, is\n-expressed in GIMPLE using a void @code{COND_EXPR}.  If only one branch is\n-used, the other is filled with an empty statement.\n-\n-Normally, the condition expression is reduced to a simple comparison.  If\n-it is a shortcut (@code{&&} or @code{||}) expression, however, we try to\n-break up the @code{if} into multiple @code{if}s so that the implied shortcut\n-is taken directly, much like the transformation done by @code{do_jump} in\n-the RTL expander.\n-\n-A @code{SWITCH_EXPR} in GIMPLE contains the condition and a\n-@code{TREE_VEC} of @code{CASE_LABEL_EXPR}s describing the case values\n-and corresponding @code{LABEL_DECL}s to jump to.  The body of the\n-@code{switch} is moved after the @code{SWITCH_EXPR}.\n-\n-@node Jumps\n-@subsubsection Jumps\n-@cindex Jumps\n-\n-Other jumps are expressed by either @code{GOTO_EXPR} or @code{RETURN_EXPR}.\n-\n-The operand of a @code{GOTO_EXPR} must be either a label or a variable\n-containing the address to jump to.\n-\n-The operand of a @code{RETURN_EXPR} is either @code{NULL_TREE},\n-@code{RESULT_DECL}, or a @code{MODIFY_EXPR} which sets the return value.  It\n-would be nice to move the @code{MODIFY_EXPR} into a separate statement, but the\n-special return semantics in @code{expand_return} make that difficult.  It may\n-still happen in the future, perhaps by moving most of that logic into\n-@code{expand_assignment}.\n-\n-@node Cleanups\n-@subsubsection Cleanups\n-@cindex Cleanups\n-\n-Destructors for local C++ objects and similar dynamic cleanups are\n-represented in GIMPLE by a @code{TRY_FINALLY_EXPR}.\n-@code{TRY_FINALLY_EXPR} has two operands, both of which are a sequence\n-of statements to execute.  The first sequence is executed.  When it\n-completes the second sequence is executed.\n-\n-The first sequence may complete in the following ways:\n-\n-@enumerate\n-\n-@item Execute the last statement in the sequence and fall off the\n-end.\n-\n-@item Execute a goto statement (@code{GOTO_EXPR}) to an ordinary\n-label outside the sequence.\n-\n-@item Execute a return statement (@code{RETURN_EXPR}).\n-\n-@item Throw an exception.  This is currently not explicitly represented in\n-GIMPLE.\n-\n-@end enumerate\n-\n-The second sequence is not executed if the first sequence completes by\n-calling @code{setjmp} or @code{exit} or any other function that does\n-not return.  The second sequence is also not executed if the first\n-sequence completes via a non-local goto or a computed goto (in general\n-the compiler does not know whether such a goto statement exits the\n-first sequence or not, so we assume that it doesn't).\n-\n-After the second sequence is executed, if it completes normally by\n-falling off the end, execution continues wherever the first sequence\n-would have continued, by falling off the end, or doing a goto, etc.\n-\n-@code{TRY_FINALLY_EXPR} complicates the flow graph, since the cleanup\n-needs to appear on every edge out of the controlled block; this\n-reduces the freedom to move code across these edges.  Therefore, the\n-EH lowering pass which runs before most of the optimization passes\n-eliminates these expressions by explicitly adding the cleanup to each\n-edge.  Rethrowing the exception is represented using @code{RESX_EXPR}.\n-\n-\n-@node GIMPLE Exception Handling\n-@subsubsection Exception Handling\n-@cindex GIMPLE Exception Handling\n-\n-Other exception handling constructs are represented using\n-@code{TRY_CATCH_EXPR}.  @code{TRY_CATCH_EXPR} has two operands.  The\n-first operand is a sequence of statements to execute.  If executing\n-these statements does not throw an exception, then the second operand\n-is ignored.  Otherwise, if an exception is thrown, then the second\n-operand of the @code{TRY_CATCH_EXPR} is checked.  The second operand\n-may have the following forms:\n-\n-@enumerate\n-\n-@item A sequence of statements to execute.  When an exception occurs,\n-these statements are executed, and then the exception is rethrown.\n-\n-@item A sequence of @code{CATCH_EXPR} expressions.  Each @code{CATCH_EXPR}\n-has a list of applicable exception types and handler code.  If the\n-thrown exception matches one of the caught types, the associated\n-handler code is executed.  If the handler code falls off the bottom,\n-execution continues after the original @code{TRY_CATCH_EXPR}.\n-\n-@item An @code{EH_FILTER_EXPR} expression.  This has a list of\n-permitted exception types, and code to handle a match failure.  If the\n-thrown exception does not match one of the allowed types, the\n-associated match failure code is executed.  If the thrown exception\n-does match, it continues unwinding the stack looking for the next\n-handler.\n-\n-@end enumerate\n-\n-Currently throwing an exception is not directly represented in GIMPLE,\n-since it is implemented by calling a function.  At some point in the future\n-we will want to add some way to express that the call will throw an\n-exception of a known type.\n-\n-Just before running the optimizers, the compiler lowers the high-level\n-EH constructs above into a set of @samp{goto}s, magic labels, and EH\n-regions.  Continuing to unwind at the end of a cleanup is represented\n-with a @code{RESX_EXPR}.\n-\n-@node GIMPLE Example\n-@subsection GIMPLE Example\n-@cindex GIMPLE Example\n-\n-@smallexample\n-struct A @{ A(); ~A(); @};\n-\n-int i;\n-int g();\n-void f()\n-@{\n-  A a;\n-  int j = (--i, i ? 0 : 1);\n-\n-  for (int x = 42; x > 0; --x)\n-    @{\n-      i += g()*4 + 32;\n-    @}\n-@}\n-@end smallexample\n-\n-becomes\n-\n-@smallexample\n-void f()\n-@{\n-  int i.0;\n-  int T.1;\n-  int iftmp.2;\n-  int T.3;\n-  int T.4;\n-  int T.5;\n-  int T.6;\n-\n-  @{\n-    struct A a;\n-    int j;\n-\n-    __comp_ctor (&a);\n-    try\n-      @{\n-        i.0 = i;\n-        T.1 = i.0 - 1;\n-        i = T.1;\n-        i.0 = i;\n-        if (i.0 == 0)\n-          iftmp.2 = 1;\n-        else\n-          iftmp.2 = 0;\n-        j = iftmp.2;\n-        @{\n-          int x;\n-\n-          x = 42;\n-          goto test;\n-          loop:;\n-\n-          T.3 = g ();\n-          T.4 = T.3 * 4;\n-          i.0 = i;\n-          T.5 = T.4 + i.0;\n-          T.6 = T.5 + 32;\n-          i = T.6;\n-          x = x - 1;\n-\n-          test:;\n-          if (x > 0)\n-            goto loop;\n-          else\n-            goto break_;\n-          break_:;\n-        @}\n-      @}\n-    finally\n-      @{\n-        __comp_dtor (&a);\n-      @}\n-  @}\n-@}\n-@end smallexample\n-\n-@node Rough GIMPLE Grammar\n-@subsection Rough GIMPLE Grammar\n-@cindex Rough GIMPLE Grammar\n-\n-@smallexample\n-   function     : FUNCTION_DECL\n-                        DECL_SAVED_TREE -> compound-stmt\n-\n-   compound-stmt: STATEMENT_LIST\n-                        members -> stmt\n-\n-   stmt         : block\n-                | if-stmt\n-                | switch-stmt\n-                | goto-stmt\n-                | return-stmt\n-                | resx-stmt\n-                | label-stmt\n-                | try-stmt\n-                | modify-stmt\n-                | call-stmt\n-\n-   block        : BIND_EXPR\n-                        BIND_EXPR_VARS -> chain of DECLs\n-                        BIND_EXPR_BLOCK -> BLOCK\n-                        BIND_EXPR_BODY -> compound-stmt\n-\n-   if-stmt      : COND_EXPR\n-                        op0 -> condition\n-                        op1 -> compound-stmt\n-                        op2 -> compound-stmt\n-\n-   switch-stmt  : SWITCH_EXPR\n-                        op0 -> val\n-                        op1 -> NULL\n-                        op2 -> TREE_VEC of CASE_LABEL_EXPRs\n-                            The CASE_LABEL_EXPRs are sorted by CASE_LOW,\n-                            and default is last.\n-\n-   goto-stmt    : GOTO_EXPR\n-                        op0 -> LABEL_DECL | val\n-\n-   return-stmt  : RETURN_EXPR\n-                        op0 -> return-value\n-\n-   return-value : NULL\n-                | RESULT_DECL\n-                | MODIFY_EXPR\n-                        op0 -> RESULT_DECL\n-                        op1 -> lhs\n-\n-   resx-stmt    : RESX_EXPR\n-\n-   label-stmt   : LABEL_EXPR\n-                        op0 -> LABEL_DECL\n-\n-   try-stmt     : TRY_CATCH_EXPR\n-                        op0 -> compound-stmt\n-                        op1 -> handler\n-                | TRY_FINALLY_EXPR\n-                        op0 -> compound-stmt\n-                        op1 -> compound-stmt\n-\n-   handler      : catch-seq\n-                | EH_FILTER_EXPR\n-                | compound-stmt\n-\n-   catch-seq    : STATEMENT_LIST\n-                        members -> CATCH_EXPR\n-\n-   modify-stmt  : MODIFY_EXPR\n-                        op0 -> lhs\n-                        op1 -> rhs\n-\n-   call-stmt    : CALL_EXPR\n-                        op0 -> val | OBJ_TYPE_REF\n-                        op1 -> call-arg-list\n-\n-   call-arg-list: TREE_LIST\n-                        members -> lhs | CONST\n-\n-   addr-expr-arg: ID\n-                | compref\n-\n-   addressable  : addr-expr-arg\n-                | indirectref\n-\n-   with-size-arg: addressable\n-                | call-stmt\n-\n-   indirectref  : INDIRECT_REF\n-                        op0 -> val\n-\n-   lhs          : addressable\n-                | bitfieldref\n-                | WITH_SIZE_EXPR\n-                        op0 -> with-size-arg\n-                        op1 -> val\n-\n-   min-lval     : ID\n-                | indirectref\n-\n-   bitfieldref  : BIT_FIELD_REF\n-                        op0 -> inner-compref\n-                        op1 -> CONST\n-                        op2 -> val\n-\n-   compref      : inner-compref\n-                | TARGET_MEM_REF\n-                        op0 -> ID\n-                        op1 -> val\n-                        op2 -> val\n-                        op3 -> CONST\n-                        op4 -> CONST\n-                | REALPART_EXPR\n-                        op0 -> inner-compref\n-                | IMAGPART_EXPR\n-                        op0 -> inner-compref\n-\n-   inner-compref: min-lval\n-                | COMPONENT_REF\n-                        op0 -> inner-compref\n-                        op1 -> FIELD_DECL\n-                        op2 -> val\n-                | ARRAY_REF\n-                        op0 -> inner-compref\n-                        op1 -> val\n-                        op2 -> val\n-                        op3 -> val\n-                | ARRAY_RANGE_REF\n-                        op0 -> inner-compref\n-                        op1 -> val\n-                        op2 -> val\n-                        op3 -> val\n-                | VIEW_CONVERT_EXPR\n-                        op0 -> inner-compref\n-\n-   condition    : val\n-                | RELOP\n-                        op0 -> val\n-                        op1 -> val\n-\n-   val          : ID\n-                | invariant ADDR_EXPR\n-                        op0 -> addr-expr-arg\n-                | CONST\n-\n-   rhs          : lhs\n-                | CONST\n-                | call-stmt\n-                | ADDR_EXPR\n-                        op0 -> addr-expr-arg\n-                | UNOP\n-                        op0 -> val\n-                | BINOP\n-                        op0 -> val\n-                        op1 -> val\n-                | RELOP\n-                        op0 -> val\n-                        op1 -> val\n-                | COND_EXPR\n-                        op0 -> condition\n-                        op1 -> val\n-                        op2 -> val\n-@end smallexample\n-\n @node Annotations\n @section Annotations\n @cindex annotations\n \n-The optimizers need to associate attributes with statements and\n-variables during the optimization process.  For instance, we need to\n-know what basic block a statement belongs to or whether a variable\n-has aliases.  All these attributes are stored in data structures\n-called annotations which are then linked to the field @code{ann} in\n-@code{struct tree_common}.\n+The optimizers need to associate attributes with variables during the\n+optimization process.  For instance, we need to know whether a\n+variable has aliases.  All these attributes are stored in data\n+structures called annotations which are then linked to the field\n+@code{ann} in @code{struct tree_common}.\n \n-Presently, we define annotations for statements (@code{stmt_ann_t}),\n-variables (@code{var_ann_t}) and SSA names (@code{ssa_name_ann_t}).\n+Presently, we define annotations for variables (@code{var_ann_t}).\n Annotations are defined and documented in @file{tree-flow.h}.\n \n \n-@node Statement Operands\n-@section Statement Operands\n+@node SSA Operands\n+@section SSA Operands\n @cindex operands\n @cindex virtual operands\n @cindex real operands"}, {"sha": "f6a14505658499c455c1b2df3b9c5c5784aa96d6", "filename": "gcc/gimple.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=e6c99067cbb1827ecc4a54ec6fdac6e221d933a0", "patch": "@@ -3188,9 +3188,11 @@ canonicalize_cond_expr_cond (tree t)\n   return NULL_TREE;\n }\n \n-/* Build call same as STMT but skipping arguments ARGS_TO_SKIP.  */\n+/* Build a GIMPLE_CALL identical to STMT but skipping the arguments in\n+   the positions marked by the set ARGS_TO_SKIP.  */\n+\n gimple\n-giple_copy_call_skip_args (gimple stmt, bitmap args_to_skip)\n+gimple_copy_call_skip_args (gimple stmt, bitmap args_to_skip)\n {\n   int i;\n   tree fn = gimple_call_fn (stmt);"}, {"sha": "85fc75e0a522b3c65f40111e1c42c8b2d5de8fc3", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=e6c99067cbb1827ecc4a54ec6fdac6e221d933a0", "patch": "@@ -4479,7 +4479,7 @@ basic_block gsi_insert_on_edge_immediate (edge, gimple);\n basic_block gsi_insert_seq_on_edge_immediate (edge, gimple_seq);\n void gsi_commit_one_edge_insert (edge, basic_block *);\n void gsi_commit_edge_inserts (void);\n-gimple giple_copy_call_skip_args (gimple, bitmap);\n+gimple gimple_copy_call_skip_args (gimple, bitmap);\n \n \n /* Convenience routines to walk all statements of a gimple function."}, {"sha": "87c724503f66b4498075bab9dda88d719152f101", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6c99067cbb1827ecc4a54ec6fdac6e221d933a0/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=e6c99067cbb1827ecc4a54ec6fdac6e221d933a0", "patch": "@@ -967,7 +967,8 @@ ipcp_update_callgraph (void)\n \t\tcurrent_function_decl = cs->caller->decl;\n \t        push_cfun (DECL_STRUCT_FUNCTION (cs->caller->decl));\n \t\t\n-\t\tnew_stmt = giple_copy_call_skip_args (cs->call_stmt, args_to_skip);\n+\t\tnew_stmt = gimple_copy_call_skip_args (cs->call_stmt,\n+\t\t\t\t\t\t       args_to_skip);\n \t\tgsi = gsi_for_stmt (cs->call_stmt);\n \t\tgsi_replace (&gsi, new_stmt, true);\n \t\tcgraph_set_call_stmt (cs, new_stmt);"}]}