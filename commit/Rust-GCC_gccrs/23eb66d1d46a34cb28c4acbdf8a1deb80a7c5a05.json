{"sha": "23eb66d1d46a34cb28c4acbdf8a1deb80a7c5a05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNlYjY2ZDFkNDZhMzRjYjI4YzRhY2JkZjhhMWRlYjgwYTdjNWEwNQ==", "commit": {"author": {"name": "marxin", "email": "mliska@suse.cz", "date": "2020-11-18T15:13:23Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-05-13T08:59:36Z"}, "message": "gcov: Use system IO buffering\n\ngcc/ChangeLog:\n\n\t* gcov-io.c (gcov_write_block): Remove.\n\t(gcov_write_words): Likewise.\n\t(gcov_read_words): Re-implement using gcov_read_bytes.\n\t(gcov_allocate): Remove.\n\t(GCOV_BLOCK_SIZE): Likewise.\n\t(struct gcov_var): Remove most of the fields.\n\t(gcov_position): Implement with ftell.\n\t(gcov_rewrite): Remove setting of start and offset fields.\n\t(from_file): Re-format.\n\t(gcov_open): Remove setbuf call. It should not be needed.\n\t(gcov_close): Remove internal buffer handling.\n\t(gcov_magic): Use __builtin_bswap32.\n\t(gcov_write_counter): Use directly gcov_write_unsigned.\n\t(gcov_write_string): Use direct fwrite and do not round\n\tto 4 bytes.\n\t(gcov_seek): Use directly fseek.\n\t(gcov_write_tag): Use gcov_write_unsigned directly.\n\t(gcov_write_length): Likewise.\n\t(gcov_write_tag_length): Likewise.\n\t(gcov_read_bytes): Use directly fread.\n\t(gcov_read_unsigned): Use gcov_read_words.\n\t(gcov_read_counter): Likewise.\n\t(gcov_read_string): Use gcov_read_bytes.\n\t* gcov-io.h (GCOV_WORD_SIZE): Adjust to reflect\n\tthat size is not in bytes, but words (4B).\n\t(GCOV_TAG_FUNCTION_LENGTH): Likewise.\n\t(GCOV_TAG_ARCS_LENGTH): Likewise.\n\t(GCOV_TAG_ARCS_NUM): Likewise.\n\t(GCOV_TAG_COUNTER_LENGTH): Likewise.\n\t(GCOV_TAG_COUNTER_NUM): Likewise.\n\t(GCOV_TAG_SUMMARY_LENGTH): Likewise.\n\nlibgcc/ChangeLog:\n\n\t* libgcov-driver.c: Fix GNU coding style.", "tree": {"sha": "f85d88f4907c66988173541d8229a1d334d7d811", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f85d88f4907c66988173541d8229a1d334d7d811"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23eb66d1d46a34cb28c4acbdf8a1deb80a7c5a05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23eb66d1d46a34cb28c4acbdf8a1deb80a7c5a05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23eb66d1d46a34cb28c4acbdf8a1deb80a7c5a05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23eb66d1d46a34cb28c4acbdf8a1deb80a7c5a05/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3e02c2e442e6b0c298dbe769e0e3b120b5201b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3e02c2e442e6b0c298dbe769e0e3b120b5201b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3e02c2e442e6b0c298dbe769e0e3b120b5201b2"}], "stats": {"total": 305, "additions": 76, "deletions": 229}, "files": [{"sha": "4b1e11d45305590bd1b36afb2651a97e00de47fc", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 64, "deletions": 218, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23eb66d1d46a34cb28c4acbdf8a1deb80a7c5a05/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23eb66d1d46a34cb28c4acbdf8a1deb80a7c5a05/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=23eb66d1d46a34cb28c4acbdf8a1deb80a7c5a05", "patch": "@@ -27,40 +27,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n /* Routines declared in gcov-io.h.  This file should be #included by\n    another source file, after having #included gcov-io.h.  */\n \n-#if !IN_GCOV\n-static void gcov_write_block (unsigned);\n-static gcov_unsigned_t *gcov_write_words (unsigned);\n-#endif\n-static const gcov_unsigned_t *gcov_read_words (unsigned);\n-#if !IN_LIBGCOV\n-static void gcov_allocate (unsigned);\n-#endif\n-\n-/* Optimum number of gcov_unsigned_t's read from or written to disk.  */\n-#define GCOV_BLOCK_SIZE (1 << 10)\n+static gcov_unsigned_t *gcov_read_words (void *buffer, unsigned);\n \n struct gcov_var\n {\n   FILE *file;\n-  gcov_position_t start;\t/* Position of first byte of block */\n-  unsigned offset;\t\t/* Read/write position within the block.  */\n-  unsigned length;\t\t/* Read limit in the block.  */\n-  unsigned overread;\t\t/* Number of words overread.  */\n   int error;\t\t\t/* < 0 overflow, > 0 disk error.  */\n-  int mode;\t                /* < 0 writing, > 0 reading */\n+  int mode;\t\t\t/* < 0 writing, > 0 reading.  */\n   int endian;\t\t\t/* Swap endianness.  */\n-#if IN_LIBGCOV\n-  /* Holds one block plus 4 bytes, thus all coverage reads & writes\n-     fit within this buffer and we always can transfer GCOV_BLOCK_SIZE\n-     to and from the disk. libgcov never backtracks and only writes 4\n-     or 8 byte objects.  */\n-  gcov_unsigned_t buffer[GCOV_BLOCK_SIZE + 1];\n-#else\n-  /* Holds a variable length block, as the compiler can write\n-     strings and needs to backtrack.  */\n-  size_t alloc;\n-  gcov_unsigned_t *buffer;\n-#endif\n } gcov_var;\n \n /* Save the current position in the gcov file.  */\n@@ -71,8 +45,7 @@ static inline\n gcov_position_t\n gcov_position (void)\n {\n-  gcov_nonruntime_assert (gcov_var.mode > 0); \n-  return gcov_var.start + gcov_var.offset;\n+  return ftell (gcov_var.file);\n }\n \n /* Return nonzero if the error flag is set.  */\n@@ -92,20 +65,16 @@ GCOV_LINKAGE inline void\n gcov_rewrite (void)\n {\n   gcov_var.mode = -1; \n-  gcov_var.start = 0;\n-  gcov_var.offset = 0;\n   fseek (gcov_var.file, 0L, SEEK_SET);\n }\n #endif\n \n-static inline gcov_unsigned_t from_file (gcov_unsigned_t value)\n+static inline gcov_unsigned_t\n+from_file (gcov_unsigned_t value)\n {\n #if !IN_LIBGCOV || defined (IN_GCOV_TOOL)\n   if (gcov_var.endian)\n-    {\n-      value = (value >> 16) | (value << 16);\n-      value = ((value & 0xff00ff) << 8) | ((value >> 8) & 0xff00ff);\n-    }\n+    return __builtin_bswap32 (value);\n #endif\n   return value;\n }\n@@ -142,9 +111,6 @@ gcov_open (const char *name, int mode)\n #endif\n \n   gcov_nonruntime_assert (!gcov_var.file);\n-  gcov_var.start = 0;\n-  gcov_var.offset = gcov_var.length = 0;\n-  gcov_var.overread = -1u;\n   gcov_var.error = 0;\n #if !IN_LIBGCOV || defined (IN_GCOV_TOOL)\n   gcov_var.endian = 0;\n@@ -222,8 +188,6 @@ gcov_open (const char *name, int mode)\n \n   gcov_var.mode = mode ? mode : 1;\n \n-  setbuf (gcov_var.file, (char *)0);\n-\n   return 1;\n }\n \n@@ -235,19 +199,9 @@ gcov_close (void)\n {\n   if (gcov_var.file)\n     {\n-#if !IN_GCOV\n-      if (gcov_var.offset && gcov_var.mode < 0)\n-\tgcov_write_block (gcov_var.offset);\n-#endif\n       fclose (gcov_var.file);\n       gcov_var.file = 0;\n-      gcov_var.length = 0;\n     }\n-#if !IN_LIBGCOV\n-  free (gcov_var.buffer);\n-  gcov_var.alloc = 0;\n-  gcov_var.buffer = 0;\n-#endif\n   gcov_var.mode = 0;\n   return gcov_var.error;\n }\n@@ -262,9 +216,8 @@ gcov_magic (gcov_unsigned_t magic, gcov_unsigned_t expected)\n {\n   if (magic == expected)\n     return 1;\n-  magic = (magic >> 16) | (magic << 16);\n-  magic = ((magic & 0xff00ff) << 8) | ((magic >> 8) & 0xff00ff);\n-  if (magic == expected)\n+\n+  if (__builtin_bswap32 (magic) == expected)\n     {\n       gcov_var.endian = 1;\n       return -1;\n@@ -273,71 +226,15 @@ gcov_magic (gcov_unsigned_t magic, gcov_unsigned_t expected)\n }\n #endif\n \n-#if !IN_LIBGCOV\n-static void\n-gcov_allocate (unsigned length)\n-{\n-  size_t new_size = gcov_var.alloc;\n-\n-  if (!new_size)\n-    new_size = GCOV_BLOCK_SIZE;\n-  new_size += length;\n-  new_size *= 2;\n-\n-  gcov_var.alloc = new_size;\n-  gcov_var.buffer = XRESIZEVAR (gcov_unsigned_t, gcov_var.buffer, new_size << 2);\n-}\n-#endif\n-\n #if !IN_GCOV\n-/* Write out the current block, if needs be.  */\n-\n-static void\n-gcov_write_block (unsigned size)\n-{\n-  if (fwrite (gcov_var.buffer, size << 2, 1, gcov_var.file) != 1)\n-    gcov_var.error = 1;\n-  gcov_var.start += size;\n-  gcov_var.offset -= size;\n-}\n-\n-/* Allocate space to write BYTES bytes to the gcov file. Return a\n-   pointer to those bytes, or NULL on failure.  */\n-\n-static gcov_unsigned_t *\n-gcov_write_words (unsigned words)\n-{\n-  gcov_unsigned_t *result;\n-\n-  gcov_nonruntime_assert (gcov_var.mode < 0);\n-#if IN_LIBGCOV\n-  if (gcov_var.offset >= GCOV_BLOCK_SIZE)\n-    {\n-      gcov_write_block (GCOV_BLOCK_SIZE);\n-      if (gcov_var.offset)\n-\t{\n-\t  memcpy (gcov_var.buffer, gcov_var.buffer + GCOV_BLOCK_SIZE, 4);\n-\t}\n-    }\n-#else\n-  if (gcov_var.offset + words > gcov_var.alloc)\n-    gcov_allocate (gcov_var.offset + words);\n-#endif\n-  result = &gcov_var.buffer[gcov_var.offset];\n-  gcov_var.offset += words;\n-\n-  return result;\n-}\n-\n-/* Write unsigned VALUE to coverage file.  Sets error flag\n-   appropriately.  */\n+/* Write unsigned VALUE to coverage file.  */\n \n GCOV_LINKAGE void\n gcov_write_unsigned (gcov_unsigned_t value)\n {\n-  gcov_unsigned_t *buffer = gcov_write_words (1);\n-\n-  buffer[0] = value;\n+  gcov_unsigned_t r = fwrite (&value, sizeof (value), 1, gcov_var.file);\n+  if (r != 1)\n+    gcov_var.error = 1;\n }\n \n /* Write counter VALUE to coverage file.  Sets error flag\n@@ -347,13 +244,11 @@ gcov_write_unsigned (gcov_unsigned_t value)\n GCOV_LINKAGE void\n gcov_write_counter (gcov_type value)\n {\n-  gcov_unsigned_t *buffer = gcov_write_words (2);\n-\n-  buffer[0] = (gcov_unsigned_t) value;\n+  gcov_write_unsigned ((gcov_unsigned_t) value);\n   if (sizeof (value) > sizeof (gcov_unsigned_t))\n-    buffer[1] = (gcov_unsigned_t) (value >> 32);\n+    gcov_write_unsigned ((gcov_unsigned_t) (value >> 32));\n   else\n-    buffer[1] = 0;\n+    gcov_write_unsigned (0);\n }\n #endif /* IN_LIBGCOV */\n \n@@ -365,23 +260,16 @@ GCOV_LINKAGE void\n gcov_write_string (const char *string)\n {\n   unsigned length = 0;\n-  unsigned alloc = 0;\n-  gcov_unsigned_t *buffer;\n \n   if (string)\n-    {\n-      length = strlen (string);\n-      alloc = (length + 4) >> 2;\n-    }\n-\n-  buffer = gcov_write_words (1 + alloc);\n+    length = strlen (string) + 1;\n \n-  buffer[0] = alloc;\n-\n-  if (alloc > 0)\n+  gcov_write_unsigned (length);\n+  if (length > 0)\n     {\n-      buffer[alloc] = 0; /* place nul terminators.  */\n-      memcpy (&buffer[1], string, length);\n+      gcov_unsigned_t r = fwrite (string, length, 1, gcov_var.file);\n+      if (r != 1)\n+\tgcov_var.error = 1;\n     }\n }\n #endif\n@@ -418,18 +306,24 @@ gcov_write_filename (const char *filename)\n }\n #endif\n \n+/* Move to a given position in a gcov file.  */\n+\n+GCOV_LINKAGE void\n+gcov_seek (gcov_position_t base)\n+{\n+  fseek (gcov_var.file, base, SEEK_SET);\n+}\n+\n #if !IN_LIBGCOV\n /* Write a tag TAG and reserve space for the record length. Return a\n    value to be used for gcov_write_length.  */\n \n GCOV_LINKAGE gcov_position_t\n gcov_write_tag (gcov_unsigned_t tag)\n {\n-  gcov_position_t result = gcov_var.start + gcov_var.offset;\n-  gcov_unsigned_t *buffer = gcov_write_words (2);\n-\n-  buffer[0] = tag;\n-  buffer[1] = 0;\n+  gcov_position_t result = gcov_position ();\n+  gcov_write_unsigned (tag);\n+  gcov_write_unsigned (0);\n \n   return result;\n }\n@@ -442,19 +336,13 @@ gcov_write_tag (gcov_unsigned_t tag)\n GCOV_LINKAGE void\n gcov_write_length (gcov_position_t position)\n {\n-  unsigned offset;\n-  gcov_unsigned_t length;\n-  gcov_unsigned_t *buffer;\n-\n+  gcov_position_t current_position = gcov_position ();\n   gcov_nonruntime_assert (gcov_var.mode < 0);\n-  gcov_nonruntime_assert (position + 2 <= gcov_var.start + gcov_var.offset);\n-  gcov_nonruntime_assert (position >= gcov_var.start);\n-  offset = position - gcov_var.start;\n-  length = gcov_var.offset - offset - 2;\n-  buffer = (gcov_unsigned_t *) &gcov_var.buffer[offset];\n-  buffer[1] = length;\n-  if (gcov_var.offset >= GCOV_BLOCK_SIZE)\n-    gcov_write_block (gcov_var.offset);\n+  gcov_nonruntime_assert (current_position >= position + 2 * GCOV_WORD_SIZE);\n+\n+  gcov_seek (position + GCOV_WORD_SIZE);\n+  gcov_write_unsigned (current_position - position - 2 * GCOV_WORD_SIZE);\n+  gcov_seek (current_position);\n }\n \n #else /* IN_LIBGCOV */\n@@ -464,10 +352,8 @@ gcov_write_length (gcov_position_t position)\n GCOV_LINKAGE void\n gcov_write_tag_length (gcov_unsigned_t tag, gcov_unsigned_t length)\n {\n-  gcov_unsigned_t *buffer = gcov_write_words (2);\n-\n-  buffer[0] = tag;\n-  buffer[1] = length;\n+  gcov_write_unsigned (tag);\n+  gcov_write_unsigned (length);\n }\n \n /* Write a summary structure to the gcov file.  Return nonzero on\n@@ -485,52 +371,28 @@ gcov_write_summary (gcov_unsigned_t tag, const struct gcov_summary *summary)\n \n #endif /*!IN_GCOV */\n \n-/* Return a pointer to read BYTES bytes from the gcov file. Returns\n+/* Return a pointer to read COUNT bytes from the gcov file.  Returns\n    NULL on failure (read past EOF).  */\n \n-static const gcov_unsigned_t *\n-gcov_read_words (unsigned words)\n+static void *\n+gcov_read_bytes (void *buffer, unsigned count)\n {\n-  const gcov_unsigned_t *result;\n-  unsigned excess = gcov_var.length - gcov_var.offset;\n-\n   if (gcov_var.mode <= 0)\n     return NULL;\n \n-  if (excess < words)\n-    {\n-      gcov_var.start += gcov_var.offset;\n-      if (excess)\n-\t{\n-#if IN_LIBGCOV\n-\t  memcpy (gcov_var.buffer, gcov_var.buffer + gcov_var.offset, 4);\n-#else\n-\t  memmove (gcov_var.buffer, gcov_var.buffer + gcov_var.offset,\n-\t\t   excess * 4);\n-#endif\n-\t}\n-      gcov_var.offset = 0;\n-      gcov_var.length = excess;\n-#if IN_LIBGCOV\n-      excess = GCOV_BLOCK_SIZE;\n-#else\n-      if (gcov_var.length + words > gcov_var.alloc)\n-\tgcov_allocate (gcov_var.length + words);\n-      excess = gcov_var.alloc - gcov_var.length;\n-#endif\n-      excess = fread (gcov_var.buffer + gcov_var.length,\n-\t\t      1, excess << 2, gcov_var.file) >> 2;\n-      gcov_var.length += excess;\n-      if (gcov_var.length < words)\n-\t{\n-\t  gcov_var.overread += words - gcov_var.length;\n-\t  gcov_var.length = 0;\n-\t  return 0;\n-\t}\n-    }\n-  result = &gcov_var.buffer[gcov_var.offset];\n-  gcov_var.offset += words;\n-  return result;\n+  unsigned read = fread (buffer, count, 1, gcov_var.file);\n+  if (read != 1)\n+    return NULL;\n+\n+  return buffer;\n+}\n+\n+/* Read WORDS gcov_unsigned_t values from gcov file.  */\n+\n+static gcov_unsigned_t *\n+gcov_read_words (void *buffer, unsigned words)\n+{\n+  return (gcov_unsigned_t *)gcov_read_bytes (buffer, GCOV_WORD_SIZE * words);\n }\n \n /* Read unsigned value from a coverage file. Sets error flag on file\n@@ -540,10 +402,12 @@ GCOV_LINKAGE gcov_unsigned_t\n gcov_read_unsigned (void)\n {\n   gcov_unsigned_t value;\n-  const gcov_unsigned_t *buffer = gcov_read_words (1);\n+  gcov_unsigned_t allocated_buffer[1];\n+  gcov_unsigned_t *buffer = gcov_read_words (&allocated_buffer, 1);\n \n   if (!buffer)\n     return 0;\n+\n   value = from_file (buffer[0]);\n   return value;\n }\n@@ -555,7 +419,8 @@ GCOV_LINKAGE gcov_type\n gcov_read_counter (void)\n {\n   gcov_type value;\n-  const gcov_unsigned_t *buffer = gcov_read_words (2);\n+  gcov_unsigned_t allocated_buffer[2];\n+  gcov_unsigned_t *buffer = gcov_read_words (&allocated_buffer, 2);\n \n   if (!buffer)\n     return 0;\n@@ -632,7 +497,8 @@ gcov_read_string (void)\n   if (!length)\n     return 0;\n \n-  return (const char *) gcov_read_words (length);\n+  void *buffer = XNEWVEC (char *, length);\n+  return (const char *) gcov_read_bytes (buffer, length);\n }\n #endif\n \n@@ -654,27 +520,7 @@ gcov_sync (gcov_position_t base, gcov_unsigned_t length)\n {\n   gcov_nonruntime_assert (gcov_var.mode > 0);\n   base += length;\n-  if (base - gcov_var.start <= gcov_var.length)\n-    gcov_var.offset = base - gcov_var.start;\n-  else\n-    {\n-      gcov_var.offset = gcov_var.length = 0;\n-      fseek (gcov_var.file, base << 2, SEEK_SET);\n-      gcov_var.start = ftell (gcov_var.file) >> 2;\n-    }\n-}\n-#endif\n-\n-#if IN_LIBGCOV\n-/* Move to a given position in a gcov file.  */\n-\n-GCOV_LINKAGE void\n-gcov_seek (gcov_position_t base)\n-{\n-  if (gcov_var.offset)\n-    gcov_write_block (gcov_var.offset);\n-  fseek (gcov_var.file, base << 2, SEEK_SET);\n-  gcov_var.start = ftell (gcov_var.file) >> 2;\n+  fseek (gcov_var.file, base, SEEK_SET);\n }\n #endif\n "}, {"sha": "f7584eb9679c2ef8cc4fd19961b45bf79d5df8ec", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23eb66d1d46a34cb28c4acbdf8a1deb80a7c5a05/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23eb66d1d46a34cb28c4acbdf8a1deb80a7c5a05/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=23eb66d1d46a34cb28c4acbdf8a1deb80a7c5a05", "patch": "@@ -243,22 +243,25 @@ typedef uint64_t gcov_type_unsigned;\n /* The record tags.  Values [1..3f] are for tags which may be in either\n    file.  Values [41..9f] for those in the note file and [a1..ff] for\n    the data file.  The tag value zero is used as an explicit end of\n-   file marker -- it is not required to be present.  */\n+   file marker -- it is not required to be present.\n+   All length values are in bytes.  */\n+\n+#define GCOV_WORD_SIZE\t\t4\n \n #define GCOV_TAG_FUNCTION\t ((gcov_unsigned_t)0x01000000)\n-#define GCOV_TAG_FUNCTION_LENGTH (3)\n+#define GCOV_TAG_FUNCTION_LENGTH (3 * GCOV_WORD_SIZE)\n #define GCOV_TAG_BLOCKS\t\t ((gcov_unsigned_t)0x01410000)\n #define GCOV_TAG_BLOCKS_LENGTH(NUM) (NUM)\n #define GCOV_TAG_ARCS\t\t ((gcov_unsigned_t)0x01430000)\n-#define GCOV_TAG_ARCS_LENGTH(NUM)  (1 + (NUM) * 2)\n-#define GCOV_TAG_ARCS_NUM(LENGTH)  (((LENGTH) - 1) / 2)\n+#define GCOV_TAG_ARCS_LENGTH(NUM)  (1 + (NUM) * 2 * GCOV_WORD_SIZE)\n+#define GCOV_TAG_ARCS_NUM(LENGTH)  (((LENGTH / GCOV_WORD_SIZE) - 1) / 2)\n #define GCOV_TAG_LINES\t\t ((gcov_unsigned_t)0x01450000)\n #define GCOV_TAG_COUNTER_BASE \t ((gcov_unsigned_t)0x01a10000)\n-#define GCOV_TAG_COUNTER_LENGTH(NUM) ((NUM) * 2)\n-#define GCOV_TAG_COUNTER_NUM(LENGTH) ((LENGTH) / 2)\n+#define GCOV_TAG_COUNTER_LENGTH(NUM) ((NUM) * 2 * GCOV_WORD_SIZE)\n+#define GCOV_TAG_COUNTER_NUM(LENGTH) ((LENGTH / GCOV_WORD_SIZE) / 2)\n #define GCOV_TAG_OBJECT_SUMMARY  ((gcov_unsigned_t)0xa1000000)\n #define GCOV_TAG_PROGRAM_SUMMARY ((gcov_unsigned_t)0xa3000000) /* Obsolete */\n-#define GCOV_TAG_SUMMARY_LENGTH (2)\n+#define GCOV_TAG_SUMMARY_LENGTH (2 * GCOV_WORD_SIZE)\n #define GCOV_TAG_AFDO_FILE_NAMES ((gcov_unsigned_t)0xaa000000)\n #define GCOV_TAG_AFDO_FUNCTION ((gcov_unsigned_t)0xac000000)\n #define GCOV_TAG_AFDO_WORKING_SET ((gcov_unsigned_t)0xaf000000)"}, {"sha": "df7ccb235677d96fe4fd61c3b4cc6b8141810812", "filename": "libgcc/libgcov-driver.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23eb66d1d46a34cb28c4acbdf8a1deb80a7c5a05/libgcc%2Flibgcov-driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23eb66d1d46a34cb28c4acbdf8a1deb80a7c5a05/libgcc%2Flibgcov-driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver.c?ref=23eb66d1d46a34cb28c4acbdf8a1deb80a7c5a05", "patch": "@@ -558,10 +558,8 @@ read_fatal:;\n     fn_buffer = free_fn_data (gi_ptr, fn_buffer, GCOV_COUNTERS);\n \n   if ((error = gcov_close ()))\n-    gcov_error (error  < 0 ?\n-\t\tGCOV_PROF_PREFIX \"Overflow writing\\n\" :\n-\t\tGCOV_PROF_PREFIX \"Error writing\\n\",\n-                gf->filename);\n+    gcov_error ((error < 0 ? GCOV_PROF_PREFIX \"Overflow writing\\n\"\n+\t\t : GCOV_PROF_PREFIX \"Error writing\\n\"), gf->filename);\n }\n \n "}]}