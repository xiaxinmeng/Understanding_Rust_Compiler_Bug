{"sha": "9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIxZGU3ZTJlOGU5OWVhYmYyYjhkMWVmNzRlYjU3ZmJkNDFiYzczMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-01T09:41:48Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-01T09:41:48Z"}, "message": "Add more vec_duplicate simplifications\n\nThis patch adds a vec_duplicate_p helper that tests for constant\nor non-constant vector duplicates.  Together with the existing\nconst_vec_duplicate_p, this complements the gen_vec_duplicate\nand gen_const_vec_duplicate added by a previous patch.\n\nThe patch uses the new routines to add more rtx simplifications\ninvolving vector duplicates.  These mirror simplifications that\nwe already do for CONST_VECTOR broadcasts and are needed for\nvariable-length SVE, which uses:\n\n  (const:M (vec_duplicate:M X))\n\nto represent constant broadcasts instead.  The simplifications do\ntrigger on the testsuite for variable duplicates too, and in each\ncase I saw the change was an improvement.\n\nThe best way of testing the new simplifications seemed to be\nvia selftests.  The patch cribs part of David's patch here:\nhttps://gcc.gnu.org/ml/gcc-patches/2016-07/msg00270.html .\n\n2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    David Malcolm  <dmalcolm@redhat.com>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* rtl.h (vec_duplicate_p): New function.\n\t* selftest-rtl.c (assert_rtx_eq_at): New function.\n\t* selftest-rtl.h (ASSERT_RTX_EQ): New macro.\n\t(assert_rtx_eq_at): Declare.\n\t* selftest.h (selftest::simplify_rtx_c_tests): Declare.\n\t* selftest-run-tests.c (selftest::run_tests): Call it.\n\t* simplify-rtx.c: Include selftest.h and selftest-rtl.h.\n\t(simplify_unary_operation_1): Recursively handle vector duplicates.\n\t(simplify_binary_operation_1): Likewise.  Handle VEC_SELECTs of\n\tvector duplicates.\n\t(simplify_subreg): Handle subregs of vector duplicates.\n\t(make_test_reg, test_vector_ops_duplicate, test_vector_ops)\n\t(selftest::simplify_rtx_c_tests): New functions.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Malcolm <dmalcolm@redhat.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254294", "tree": {"sha": "a1caf2e58025d69aaf22ee8231dc382401c0e68a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1caf2e58025d69aaf22ee8231dc382401c0e68a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730/comments", "author": null, "committer": null, "parents": [{"sha": "59d06c050373919ed36a13b37103b6e069d8ebd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59d06c050373919ed36a13b37103b6e069d8ebd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59d06c050373919ed36a13b37103b6e069d8ebd3"}], "stats": {"total": 269, "additions": 264, "deletions": 5}, "files": [{"sha": "0dde53bfa5ff471a00ff29ea28ea0007f015bc7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730", "patch": "@@ -1,3 +1,22 @@\n+2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    David Malcolm  <dmalcolm@redhat.com>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* rtl.h (vec_duplicate_p): New function.\n+\t* selftest-rtl.c (assert_rtx_eq_at): New function.\n+\t* selftest-rtl.h (ASSERT_RTX_EQ): New macro.\n+\t(assert_rtx_eq_at): Declare.\n+\t* selftest.h (selftest::simplify_rtx_c_tests): Declare.\n+\t* selftest-run-tests.c (selftest::run_tests): Call it.\n+\t* simplify-rtx.c: Include selftest.h and selftest-rtl.h.\n+\t(simplify_unary_operation_1): Recursively handle vector duplicates.\n+\t(simplify_binary_operation_1): Likewise.  Handle VEC_SELECTs of\n+\tvector duplicates.\n+\t(simplify_subreg): Handle subregs of vector duplicates.\n+\t(make_test_reg, test_vector_ops_duplicate, test_vector_ops)\n+\t(selftest::simplify_rtx_c_tests): New functions.\n+\n 2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "b01e306c395844a4c366c6fed66d7d5db9ae69ed", "filename": "gcc/rtl.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730", "patch": "@@ -2772,6 +2772,21 @@ const_vec_duplicate_p (T x, T *elt)\n   return false;\n }\n \n+/* Return true if X is a vector with a duplicated element value, either\n+   constant or nonconstant.  Store the duplicated element in *ELT if so.  */\n+\n+template <typename T>\n+inline bool\n+vec_duplicate_p (T x, T *elt)\n+{\n+  if (GET_CODE (x) == VEC_DUPLICATE)\n+    {\n+      *elt = XEXP (x, 0);\n+      return true;\n+    }\n+  return const_vec_duplicate_p (x, elt);\n+}\n+\n /* If X is a vector constant with a duplicated element value, return that\n    element value, otherwise return X.  */\n "}, {"sha": "7e7485758250e25a18e9bf5a67ce53c533d50bd6", "filename": "gcc/selftest-rtl.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730/gcc%2Fselftest-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730/gcc%2Fselftest-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-rtl.c?ref=9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730", "patch": "@@ -35,6 +35,29 @@ along with GCC; see the file COPYING3.  If not see\n \n namespace selftest {\n \n+/* Compare rtx EXPECTED and ACTUAL using rtx_equal_p, calling\n+   ::selftest::pass if they are equal, aborting if they are non-equal.\n+   LOC is the effective location of the assertion, MSG describes it.  */\n+\n+void\n+assert_rtx_eq_at (const location &loc, const char *msg,\n+\t\t  rtx expected, rtx actual)\n+{\n+  if (rtx_equal_p (expected, actual))\n+    ::selftest::pass (loc, msg);\n+  else\n+    {\n+      fprintf (stderr, \"%s:%i: %s: FAIL: %s\\n\", loc.m_file, loc.m_line,\n+\t       loc.m_function, msg);\n+      fprintf (stderr, \"  expected: \");\n+      print_rtl (stderr, expected);\n+      fprintf (stderr, \"\\n  actual: \");\n+      print_rtl (stderr, actual);\n+      fprintf (stderr, \"\\n\");\n+      abort ();\n+    }\n+}\n+\n /* Compare rtx EXPECTED and ACTUAL by pointer equality, calling\n    ::selftest::pass if they are equal, aborting if they are non-equal.\n    LOC is the effective location of the assertion, MSG describes it.  */"}, {"sha": "fe928e78da8eb8592b89d349b7c26421d7376df5", "filename": "gcc/selftest-rtl.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730/gcc%2Fselftest-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730/gcc%2Fselftest-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-rtl.h?ref=9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730", "patch": "@@ -47,6 +47,15 @@ assert_rtl_dump_eq (const location &loc, const char *expected_dump, rtx x,\n   assert_rtl_dump_eq (SELFTEST_LOCATION, (EXPECTED_DUMP), (RTX), \\\n \t\t      (REUSE_MANAGER))\n \n+#define ASSERT_RTX_EQ(EXPECTED, ACTUAL) \t\t\t\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+  const char *desc = \"ASSERT_RTX_EQ (\" #EXPECTED \", \" #ACTUAL \")\";\t\\\n+  ::selftest::assert_rtx_eq_at (SELFTEST_LOCATION, desc, (EXPECTED),\t\\\n+\t\t\t\t(ACTUAL));\t\t\t\t\\\n+  SELFTEST_END_STMT\n+\n+extern void assert_rtx_eq_at (const location &, const char *, rtx, rtx);\n+\n /* Evaluate rtx EXPECTED and ACTUAL and compare them with ==\n    (i.e. pointer equality), calling ::selftest::pass if they are\n    equal, aborting if they are non-equal.  */"}, {"sha": "6030d3b22e7d1fda2603c5cb0a63fff2562c7e8e", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730", "patch": "@@ -95,6 +95,7 @@ selftest::run_tests ()\n \n   store_merging_c_tests ();\n   predict_c_tests ();\n+  simplify_rtx_c_tests ();\n \n   /* Run any lang-specific selftests.  */\n   lang_hooks.run_lang_selftests ();"}, {"sha": "cdad939ce68c9c30c09ebe90d84e2063bdf1fbcf", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730", "patch": "@@ -199,6 +199,7 @@ extern void unique_ptr_tests_cc_tests ();\n extern void vec_c_tests ();\n extern void wide_int_cc_tests ();\n extern void predict_c_tests ();\n+extern void simplify_rtx_c_tests ();\n \n extern int num_passes;\n "}, {"sha": "fea5a8ad17b29650950b07b799ffb81dcfc905be", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 196, "deletions": 5, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=9b1de7e2e8e99eabf2b8d1ef74eb57fbd41bc730", "patch": "@@ -33,6 +33,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"varasm.h\"\n #include \"flags.h\"\n+#include \"selftest.h\"\n+#include \"selftest-rtl.h\"\n \n /* Simplification and canonicalization of RTL.  */\n \n@@ -925,7 +927,7 @@ static rtx\n simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n {\n   enum rtx_code reversed;\n-  rtx temp;\n+  rtx temp, elt;\n   scalar_int_mode inner, int_mode, op_mode, op0_mode;\n \n   switch (code)\n@@ -1684,6 +1686,28 @@ simplify_unary_operation_1 (enum rtx_code code, machine_mode mode, rtx op)\n       break;\n     }\n \n+  if (VECTOR_MODE_P (mode) && vec_duplicate_p (op, &elt))\n+    {\n+      /* Try applying the operator to ELT and see if that simplifies.\n+\t We can duplicate the result if so.\n+\n+\t The reason we don't use simplify_gen_unary is that it isn't\n+\t necessarily a win to convert things like:\n+\n+\t   (neg:V (vec_duplicate:V (reg:S R)))\n+\n+\t to:\n+\n+\t   (vec_duplicate:V (neg:S (reg:S R)))\n+\n+\t The first might be done entirely in vector registers while the\n+\t second might need a move between register files.  */\n+      temp = simplify_unary_operation (code, GET_MODE_INNER (mode),\n+\t\t\t\t       elt, GET_MODE_INNER (GET_MODE (op)));\n+      if (temp)\n+\treturn gen_vec_duplicate (mode, temp);\n+    }\n+\n   return 0;\n }\n \n@@ -2141,7 +2165,7 @@ static rtx\n simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t\t\t     rtx op0, rtx op1, rtx trueop0, rtx trueop1)\n {\n-  rtx tem, reversed, opleft, opright;\n+  rtx tem, reversed, opleft, opright, elt0, elt1;\n   HOST_WIDE_INT val;\n   scalar_int_mode int_mode, inner_mode;\n \n@@ -3484,6 +3508,9 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t  gcc_assert (XVECLEN (trueop1, 0) == 1);\n \t  gcc_assert (CONST_INT_P (XVECEXP (trueop1, 0, 0)));\n \n+\t  if (vec_duplicate_p (trueop0, &elt0))\n+\t    return elt0;\n+\n \t  if (GET_CODE (trueop0) == CONST_VECTOR)\n \t    return CONST_VECTOR_ELT (trueop0, INTVAL (XVECEXP\n \t\t\t\t\t\t      (trueop1, 0, 0)));\n@@ -3566,9 +3593,6 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t\t\t\t    tmp_op, gen_rtx_PARALLEL (VOIDmode, vec));\n \t      return tmp;\n \t    }\n-\t  if (GET_CODE (trueop0) == VEC_DUPLICATE\n-\t      && GET_MODE (XEXP (trueop0, 0)) == mode)\n-\t    return XEXP (trueop0, 0);\n \t}\n       else\n \t{\n@@ -3577,6 +3601,11 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t\t      == GET_MODE_INNER (GET_MODE (trueop0)));\n \t  gcc_assert (GET_CODE (trueop1) == PARALLEL);\n \n+\t  if (vec_duplicate_p (trueop0, &elt0))\n+\t    /* It doesn't matter which elements are selected by trueop1,\n+\t       because they are all the same.  */\n+\t    return gen_vec_duplicate (mode, elt0);\n+\n \t  if (GET_CODE (trueop0) == CONST_VECTOR)\n \t    {\n \t      int elt_size = GET_MODE_UNIT_SIZE (mode);\n@@ -3877,6 +3906,32 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n       gcc_unreachable ();\n     }\n \n+  if (mode == GET_MODE (op0)\n+      && mode == GET_MODE (op1)\n+      && vec_duplicate_p (op0, &elt0)\n+      && vec_duplicate_p (op1, &elt1))\n+    {\n+      /* Try applying the operator to ELT and see if that simplifies.\n+\t We can duplicate the result if so.\n+\n+\t The reason we don't use simplify_gen_binary is that it isn't\n+\t necessarily a win to convert things like:\n+\n+\t   (plus:V (vec_duplicate:V (reg:S R1))\n+\t\t   (vec_duplicate:V (reg:S R2)))\n+\n+\t to:\n+\n+\t   (vec_duplicate:V (plus:S (reg:S R1) (reg:S R2)))\n+\n+\t The first might be done entirely in vector registers while the\n+\t second might need a move between register files.  */\n+      tem = simplify_binary_operation (code, GET_MODE_INNER (mode),\n+\t\t\t\t       elt0, elt1);\n+      if (tem)\n+\treturn gen_vec_duplicate (mode, tem);\n+    }\n+\n   return 0;\n }\n \n@@ -6025,6 +6080,20 @@ simplify_subreg (machine_mode outermode, rtx op,\n   if (outermode == innermode && !byte)\n     return op;\n \n+  if (byte % GET_MODE_UNIT_SIZE (innermode) == 0)\n+    {\n+      rtx elt;\n+\n+      if (VECTOR_MODE_P (outermode)\n+\t  && GET_MODE_INNER (outermode) == GET_MODE_INNER (innermode)\n+\t  && vec_duplicate_p (op, &elt))\n+\treturn gen_vec_duplicate (outermode, elt);\n+\n+      if (outermode == GET_MODE_INNER (innermode)\n+\t  && vec_duplicate_p (op, &elt))\n+\treturn elt;\n+    }\n+\n   if (CONST_SCALAR_INT_P (op)\n       || CONST_DOUBLE_AS_FLOAT_P (op)\n       || GET_CODE (op) == CONST_FIXED\n@@ -6330,3 +6399,125 @@ simplify_rtx (const_rtx x)\n     }\n   return NULL;\n }\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Make a unique pseudo REG of mode MODE for use by selftests.  */\n+\n+static rtx\n+make_test_reg (machine_mode mode)\n+{\n+  static int test_reg_num = LAST_VIRTUAL_REGISTER + 1;\n+\n+  return gen_rtx_REG (mode, test_reg_num++);\n+}\n+\n+/* Test vector simplifications involving VEC_DUPLICATE in which the\n+   operands and result have vector mode MODE.  SCALAR_REG is a pseudo\n+   register that holds one element of MODE.  */\n+\n+static void\n+test_vector_ops_duplicate (machine_mode mode, rtx scalar_reg)\n+{\n+  scalar_mode inner_mode = GET_MODE_INNER (mode);\n+  rtx duplicate = gen_rtx_VEC_DUPLICATE (mode, scalar_reg);\n+  unsigned int nunits = GET_MODE_NUNITS (mode);\n+  if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+    {\n+      /* Test some simple unary cases with VEC_DUPLICATE arguments.  */\n+      rtx not_scalar_reg = gen_rtx_NOT (inner_mode, scalar_reg);\n+      rtx duplicate_not = gen_rtx_VEC_DUPLICATE (mode, not_scalar_reg);\n+      ASSERT_RTX_EQ (duplicate,\n+\t\t     simplify_unary_operation (NOT, mode,\n+\t\t\t\t\t       duplicate_not, mode));\n+\n+      rtx neg_scalar_reg = gen_rtx_NEG (inner_mode, scalar_reg);\n+      rtx duplicate_neg = gen_rtx_VEC_DUPLICATE (mode, neg_scalar_reg);\n+      ASSERT_RTX_EQ (duplicate,\n+\t\t     simplify_unary_operation (NEG, mode,\n+\t\t\t\t\t       duplicate_neg, mode));\n+\n+      /* Test some simple binary cases with VEC_DUPLICATE arguments.  */\n+      ASSERT_RTX_EQ (duplicate,\n+\t\t     simplify_binary_operation (PLUS, mode, duplicate,\n+\t\t\t\t\t\tCONST0_RTX (mode)));\n+\n+      ASSERT_RTX_EQ (duplicate,\n+\t\t     simplify_binary_operation (MINUS, mode, duplicate,\n+\t\t\t\t\t\tCONST0_RTX (mode)));\n+\n+      ASSERT_RTX_PTR_EQ (CONST0_RTX (mode),\n+\t\t\t simplify_binary_operation (MINUS, mode, duplicate,\n+\t\t\t\t\t\t    duplicate));\n+    }\n+\n+  /* Test a scalar VEC_SELECT of a VEC_DUPLICATE.  */\n+  rtx zero_par = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (1, const0_rtx));\n+  ASSERT_RTX_PTR_EQ (scalar_reg,\n+\t\t     simplify_binary_operation (VEC_SELECT, inner_mode,\n+\t\t\t\t\t\tduplicate, zero_par));\n+\n+  /* And again with the final element.  */\n+  rtx last_index = gen_int_mode (GET_MODE_NUNITS (mode) - 1, word_mode);\n+  rtx last_par = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (1, last_index));\n+  ASSERT_RTX_PTR_EQ (scalar_reg,\n+\t\t     simplify_binary_operation (VEC_SELECT, inner_mode,\n+\t\t\t\t\t\tduplicate, last_par));\n+\n+  /* Test a scalar subreg of a VEC_DUPLICATE.  */\n+  unsigned int offset = subreg_lowpart_offset (inner_mode, mode);\n+  ASSERT_RTX_EQ (scalar_reg,\n+\t\t simplify_gen_subreg (inner_mode, duplicate,\n+\t\t\t\t      mode, offset));\n+\n+  machine_mode narrower_mode;\n+  if (nunits > 2\n+      && mode_for_vector (inner_mode, 2).exists (&narrower_mode)\n+      && VECTOR_MODE_P (narrower_mode))\n+    {\n+      /* Test VEC_SELECT of a vector.  */\n+      rtx vec_par\n+\t= gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, const1_rtx, const0_rtx));\n+      rtx narrower_duplicate\n+\t= gen_rtx_VEC_DUPLICATE (narrower_mode, scalar_reg);\n+      ASSERT_RTX_EQ (narrower_duplicate,\n+\t\t     simplify_binary_operation (VEC_SELECT, narrower_mode,\n+\t\t\t\t\t\tduplicate, vec_par));\n+\n+      /* Test a vector subreg of a VEC_DUPLICATE.  */\n+      unsigned int offset = subreg_lowpart_offset (narrower_mode, mode);\n+      ASSERT_RTX_EQ (narrower_duplicate,\n+\t\t     simplify_gen_subreg (narrower_mode, duplicate,\n+\t\t\t\t\t  mode, offset));\n+    }\n+}\n+\n+/* Verify some simplifications involving vectors.  */\n+\n+static void\n+test_vector_ops ()\n+{\n+  for (unsigned int i = 0; i < NUM_MACHINE_MODES; ++i)\n+    {\n+      machine_mode mode = (machine_mode) i;\n+      if (VECTOR_MODE_P (mode))\n+\t{\n+\t  rtx scalar_reg = make_test_reg (GET_MODE_INNER (mode));\n+\t  test_vector_ops_duplicate (mode, scalar_reg);\n+\t}\n+    }\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+simplify_rtx_c_tests ()\n+{\n+  test_vector_ops ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */"}]}