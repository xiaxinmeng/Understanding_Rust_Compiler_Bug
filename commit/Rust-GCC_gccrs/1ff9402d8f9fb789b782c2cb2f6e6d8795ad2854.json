{"sha": "1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZmOTQwMmQ4ZjlmYjc4OWI3ODJjMmNiMmY2ZTZkODc5NWFkMjg1NA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-06-11T15:52:11Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-06-11T15:52:11Z"}, "message": "[multiple changes]\n\n\n2003-06-11  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/bits/stl_alloc.h (__debug_alloc): Move out.\n\t(__malloc_alloc): Same.\n\t(__pool_alloc): Same.\n\t(__new_alloc): Same.\n\tRename to..\n\t* include/bits/allocator.h: ...this.\n\t* include/bits/stl_deque.h: Modify comment.\n\t* include/bits/stl_tree.h: Modify include.\n\t* include/std/std_memory.h: Same.\n\t* include/ext/rope: Same.\n\t* include/ext/slist: Same.\n\t* include/std/std_vector.h: Same.\n\t* include/std/std_stack.h: Same.\n\t* include/std/std_queue.h: Same.\n\t* include/std/std_list.h: Same.\n\t* include/std/std_deque.h: Same.\n\t* include/backward/alloc.h: Same.\n\t* include/ext/debug_allocator.h: New.\n\t* include/ext/malloc_allocator.h: New.\n\t* include/ext/pool_allocator.h: New.\n\t* include/ext/new_allocator.h: New.\n\t* include/bits/pthread_allocimpl.h: Remove.\n\t* include/bits/stl_pthread_alloc.h: Remove.\n\t* include/Makefile.am (ext_headers): Add.\n\t* include/Makefile.in: Regenerate.\n\t* src/stl-inst.cc: Use __gnu_cxx namespace.\n\t* src/stl-inst.cc: Move to...\n\t* src/allocator-inst.cc: Here.\n\t* src/Makefile.am (sources): Update.\n\t* src/Makefile.in: Regenerate.\n\t* config/linker-map.gnu: Remove __pool_alloc bits.\n\t* testsuite/ext/headers.cc: Add.\n\t* testsuite/ext/allocators.cc: Fixup.\n\n2003-06-11  Stefan Olsson  <stefan@snon.net>\n            Ola R\ufffdnnerup  <fnolis@home.se>\n\n\t* include/Makefile.am (ext_headers): Add.\n\t* include/Makefile.in: Regenerate.\n\t* include/ext/mt_allocator.h: New file.\n\nFrom-SVN: r67777", "tree": {"sha": "61989852861e8690ab5a873c759b5218e2280ca7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61989852861e8690ab5a873c759b5218e2280ca7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/comments", "author": null, "committer": null, "parents": [{"sha": "1d5d594da51480a769adb947a5d2baa339892df0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d5d594da51480a769adb947a5d2baa339892df0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d5d594da51480a769adb947a5d2baa339892df0"}], "stats": {"total": 3722, "additions": 2190, "deletions": 1532}, "files": [{"sha": "ad3c2d65ab93910297930849675ba7afdb38a27f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -1,3 +1,46 @@\n+2003-06-11  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/bits/stl_alloc.h (__debug_alloc): Move out.\n+\t(__malloc_alloc): Same.\n+\t(__pool_alloc): Same.\n+\t(__new_alloc): Same.\n+\tRename to..\n+\t* include/bits/allocator.h: ...this.\n+\t* include/bits/stl_deque.h: Modify comment.\n+\t* include/bits/stl_tree.h: Modify include.\n+\t* include/std/std_memory.h: Same.\n+\t* include/ext/rope: Same.\n+\t* include/ext/slist: Same.\t\n+\t* include/std/std_vector.h: Same.\n+\t* include/std/std_stack.h: Same.\n+\t* include/std/std_queue.h: Same.\n+\t* include/std/std_list.h: Same.\n+\t* include/std/std_deque.h: Same.\n+\t* include/backward/alloc.h: Same.\n+\t* include/ext/debug_allocator.h: New.\n+\t* include/ext/malloc_allocator.h: New.\t\n+\t* include/ext/pool_allocator.h: New.\t\t\n+\t* include/ext/new_allocator.h: New.\n+\t* include/bits/pthread_allocimpl.h: Remove.\n+\t* include/bits/stl_pthread_alloc.h: Remove.\t\n+\t* include/Makefile.am (ext_headers): Add.\n+\t* include/Makefile.in: Regenerate.\n+\t* src/stl-inst.cc: Use __gnu_cxx namespace.\n+\t* src/stl-inst.cc: Move to...\n+\t* src/allocator-inst.cc: Here.\n+\t* src/Makefile.am (sources): Update.\n+\t* src/Makefile.in: Regenerate.\n+\t* config/linker-map.gnu: Remove __pool_alloc bits.\n+\t* testsuite/ext/headers.cc: Add.\n+\t* testsuite/ext/allocators.cc: Fixup.\n+\t\n+2003-06-11  Stefan Olsson  <stefan@snon.net>\n+            Ola R\ufffdnnerup  <fnolis@home.se>\n+\t\n+\t* include/Makefile.am (ext_headers): Add.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/ext/mt_allocator.h: New file.\n+\n 2003-06-10  Paolo Carlini  <pcarlini@unitus.it>\n \n \t* include/bits/fstream.tcc (close): Clean up a bit."}, {"sha": "6723a057e079e596b6097b165f05c7b4e5c9e724", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -78,15 +78,6 @@ GLIBCPP_3.4 {\n     # bool has_facet \n     _ZSt9has_facet*;\n \n-    # std::__pool_alloc\n-    _ZNSt12__pool_allocILb1ELi0EE10deallocateEPv[jm]*;\n-    _ZNSt12__pool_allocILb1ELi0EE8allocateE[jm]*;\n-    _ZNSt12__pool_allocILb1ELi0EE5_Lock*;\n-    _ZNSt12__pool_allocILb1ELi0EE12_S_force_newE;\n-    _ZNSt12__pool_allocILb1ELi0EE12_S_free_listE;\n-    _ZNSt12__pool_allocILb1ELi0EE7_S_lockE;\n-    _ZNSt12__pool_allocILb1ELi0EE9_S_refillE[jm];\n-\n     # operator new(size_t)\n     _Znw[jm];\n     # operator new(size_t, std::nothrow_t const&)"}, {"sha": "760e85ba4e88418e20acda4e8c6dd092bdfedc48", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -103,6 +103,8 @@ std_headers_rename = \\\n bits_srcdir = ${glibcpp_srcdir}/include/bits\n bits_builddir = ./bits\n bits_headers = \\\n+\t${bits_srcdir}/allocator.h \\\n+\t${bits_srcdir}/allocator_traits.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\\n@@ -129,14 +131,12 @@ bits_headers = \\\n \t${bits_srcdir}/localefwd.h \\\n \t${bits_srcdir}/mask_array.h \\\n \t${bits_srcdir}/ostream.tcc \\\n-\t${bits_srcdir}/pthread_allocimpl.h \\\n \t${bits_srcdir}/stream_iterator.h \\\n \t${bits_srcdir}/streambuf_iterator.h \\\n \t${bits_srcdir}/slice_array.h \\\n \t${bits_srcdir}/sstream.tcc \\\n \t${bits_srcdir}/stl_algo.h \\\n \t${bits_srcdir}/stl_algobase.h \\\n-\t${bits_srcdir}/stl_alloc.h \\\n \t${bits_srcdir}/stl_bvector.h \\\n \t${bits_srcdir}/stl_construct.h \\\n \t${bits_srcdir}/stl_deque.h \\\n@@ -151,7 +151,6 @@ bits_headers = \\\n \t${bits_srcdir}/stl_multiset.h \\\n \t${bits_srcdir}/stl_numeric.h \\\n \t${bits_srcdir}/stl_pair.h \\\n-\t${bits_srcdir}/stl_pthread_alloc.h \\\n \t${bits_srcdir}/stl_queue.h \\\n \t${bits_srcdir}/stl_raw_storage_iter.h \\\n \t${bits_srcdir}/stl_relops.h \\\n@@ -215,15 +214,20 @@ ext_srcdir = ${glibcpp_srcdir}/include/ext\n ext_builddir = ./ext\n ext_headers = \\\n \t${ext_srcdir}/algorithm \\\n+\t${ext_srcdir}/debug_allocator.h \\\n \t${ext_srcdir}/enc_filebuf.h \\\n \t${ext_srcdir}/stdio_filebuf.h \\\n \t${ext_srcdir}/stdio_sync_filebuf.h \\\n \t${ext_srcdir}/functional \\\n \t${ext_srcdir}/hash_map \\\n \t${ext_srcdir}/hash_set \\\n \t${ext_srcdir}/iterator \\\n+\t${ext_srcdir}/malloc_allocator.h \\\n \t${ext_srcdir}/memory \\\n+\t${ext_srcdir}/mt_allocator.h \\\n+\t${ext_srcdir}/new_allocator.h \\\n \t${ext_srcdir}/numeric \\\n+\t${ext_srcdir}/pool_allocator.h \\\n \t${ext_srcdir}/rb_tree \\\n \t${ext_srcdir}/rope \\\n \t${ext_srcdir}/ropeimpl.h \\"}, {"sha": "33d5a81846ce9418c4fe1551f2bc61ce20dbf126", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -222,6 +222,8 @@ std_headers_rename = \\\n bits_srcdir = ${glibcpp_srcdir}/include/bits\n bits_builddir = ./bits\n bits_headers = \\\n+\t${bits_srcdir}/allocator.h \\\n+\t${bits_srcdir}/allocator_traits.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\\n@@ -248,14 +250,12 @@ bits_headers = \\\n \t${bits_srcdir}/localefwd.h \\\n \t${bits_srcdir}/mask_array.h \\\n \t${bits_srcdir}/ostream.tcc \\\n-\t${bits_srcdir}/pthread_allocimpl.h \\\n \t${bits_srcdir}/stream_iterator.h \\\n \t${bits_srcdir}/streambuf_iterator.h \\\n \t${bits_srcdir}/slice_array.h \\\n \t${bits_srcdir}/sstream.tcc \\\n \t${bits_srcdir}/stl_algo.h \\\n \t${bits_srcdir}/stl_algobase.h \\\n-\t${bits_srcdir}/stl_alloc.h \\\n \t${bits_srcdir}/stl_bvector.h \\\n \t${bits_srcdir}/stl_construct.h \\\n \t${bits_srcdir}/stl_deque.h \\\n@@ -270,7 +270,6 @@ bits_headers = \\\n \t${bits_srcdir}/stl_multiset.h \\\n \t${bits_srcdir}/stl_numeric.h \\\n \t${bits_srcdir}/stl_pair.h \\\n-\t${bits_srcdir}/stl_pthread_alloc.h \\\n \t${bits_srcdir}/stl_queue.h \\\n \t${bits_srcdir}/stl_raw_storage_iter.h \\\n \t${bits_srcdir}/stl_relops.h \\\n@@ -336,15 +335,20 @@ ext_srcdir = ${glibcpp_srcdir}/include/ext\n ext_builddir = ./ext\n ext_headers = \\\n \t${ext_srcdir}/algorithm \\\n+\t${ext_srcdir}/debug_allocator.h \\\n \t${ext_srcdir}/enc_filebuf.h \\\n \t${ext_srcdir}/stdio_filebuf.h \\\n \t${ext_srcdir}/stdio_sync_filebuf.h \\\n \t${ext_srcdir}/functional \\\n \t${ext_srcdir}/hash_map \\\n \t${ext_srcdir}/hash_set \\\n \t${ext_srcdir}/iterator \\\n+\t${ext_srcdir}/malloc_allocator.h \\\n \t${ext_srcdir}/memory \\\n+\t${ext_srcdir}/mt_allocator.h \\\n+\t${ext_srcdir}/new_allocator.h \\\n \t${ext_srcdir}/numeric \\\n+\t${ext_srcdir}/pool_allocator.h \\\n \t${ext_srcdir}/rb_tree \\\n \t${ext_srcdir}/rope \\\n \t${ext_srcdir}/ropeimpl.h \\"}, {"sha": "b748ef26c01d4e1d0ad538345a326029c354de2b", "filename": "libstdc++-v3/include/backward/alloc.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -45,15 +45,15 @@\n \n #include \"backward_warning.h\"\n #include <bits/c++config.h>\n-#include <bits/stl_alloc.h>\n+#include <bits/allocator.h>\n+#include <ext/debug_allocator.h>\n+#include <ext/malloc_allocator.h>\n \n-using std::__malloc_alloc; \n-using std::__simple_alloc; \n-using std::__debug_alloc; \n+using __gnu_cxx::__malloc_alloc; \n+using __gnu_cxx::__debug_alloc; \n+using __gnu_cxx::__pool_alloc; \n using std::__alloc; \n-using std::__single_client_alloc; \n-using std::__pool_alloc; \n+using std::__simple_alloc; \n using std::allocator;\n \n-\n #endif "}, {"sha": "b6dec02572aa030d5ba3506f24397e20d2ae47a8", "filename": "libstdc++-v3/include/bits/allocator.h", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -0,0 +1,215 @@\n+// Allocators -*- C++ -*-\n+\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ * Copyright (c) 1996-1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+/** @file allocator.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+/**\n+ *  @defgroup Allocators Memory Allocators\n+ *  @if maint\n+ *  allocator.h implements some node allocators.  These are NOT the same as\n+ *  allocators in the C++ standard, nor in the original H-P STL.  They do not\n+ *  encapsulate different pointer types; we assume that there is only one\n+ *  pointer type.  The C++ standard allocators are intended to allocate\n+ *  individual objects, not pools or arenas.\n+ *\n+ *  In this file allocators are of two different styles:  \"standard\" and\n+ *  \"SGI\" (quotes included).  \"Standard\" allocators conform to 20.4.  \"SGI\"\n+ *  allocators differ in AT LEAST the following ways (add to this list as you\n+ *  discover them):\n+ *\n+ *   - \"Standard\" allocate() takes two parameters (n_count,hint=0) but \"SGI\"\n+ *     allocate() takes one paramter (n_size).\n+ *   - Likewise, \"standard\" deallocate()'s argument is a count, but in \"SGI\"\n+ *     is a byte size.\n+ *   - max_size(), construct(), and destroy() are missing in \"SGI\" allocators.\n+ *   - reallocate(p,oldsz,newsz) is added in \"SGI\", and behaves as\n+ *     if p=realloc(p,newsz).\n+ *\n+ *  \"SGI\" allocators may be wrapped in __allocator to convert the interface\n+ *  into a \"standard\" one.\n+ *  @endif\n+ *\n+ *  The canonical description of these classes is in docs/html/ext/howto.html\n+ *  or online at http://gcc.gnu.org/onlinedocs/libstdc++/ext/howto.html#3\n+*/\n+\n+#ifndef _ALLOCATOR_H\n+#define _ALLOCATOR_H 1\n+\n+#include <bits/functexcept.h>   // For __throw_bad_alloc\n+#include <bits/allocator_traits.h>\n+\n+// Pick a default underlying allocator.\n+#include <ext/pool_allocator.h>\n+\n+namespace std\n+{\n+  typedef __gnu_cxx::__pool_alloc<true, 0>    __alloc;\n+\n+  /// The version for the default allocator.\n+  template<typename _Tp, typename _Tp1>\n+    struct _Alloc_traits<_Tp, allocator<_Tp1> >\n+    {\n+      static const bool _S_instanceless = true;\n+      typedef __simple_alloc<_Tp, __alloc> _Alloc_type;\n+      typedef allocator<_Tp> allocator_type;\n+    };\n+  //@}\n+}\n+\n+namespace std\n+{\n+  /**\n+   *  @brief  The \"standard\" allocator, as per [20.4].\n+   *\n+   *  The private _Alloc is \"SGI\" style.  (See comments at the top\n+   *  of allocator.h.)\n+   *\n+   *  The underlying allocator behaves as follows.\n+   *    - __pool_alloc is used via two typedefs\n+   *    - \"__alloc\" typedef is threadsafe via the locks\n+   *    - __new_alloc is used for memory requests\n+   *\n+   *  (See @link Allocators allocators info @endlink for more.)\n+   */\n+  template<typename _Tp>\n+    class allocator\n+    {\n+      // The underlying allocator.\n+      typedef __alloc _Alloc;     \n+     \n+    public:\n+      typedef size_t     size_type;\n+      typedef ptrdiff_t  difference_type;\n+      typedef _Tp*       pointer;\n+      typedef const _Tp* const_pointer;\n+      typedef _Tp&       reference;\n+      typedef const _Tp& const_reference;\n+      typedef _Tp        value_type;\n+\n+      template<typename _Tp1>\n+        struct rebind\n+        { typedef allocator<_Tp1> other; };\n+\n+      allocator() throw() { }\n+\n+      allocator(const allocator&) throw() { }\n+\n+      template<typename _Tp1>\n+        allocator(const allocator<_Tp1>&) throw() { }\n+\n+      ~allocator() throw() { }\n+\n+      pointer\n+      address(reference __x) const { return &__x; }\n+\n+      const_pointer\n+      address(const_reference __x) const { return &__x; }\n+\n+      // NB: __n is permitted to be 0.  The C++ standard says nothing\n+      // about what the return value is when __n == 0.\n+      _Tp*\n+      allocate(size_type __n, const void* = 0)\n+      {\n+\t_Tp* __ret = 0;\n+\tif (__n)\n+\t  {\n+\t    if (__n <= this->max_size())\n+\t      __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));\n+\t    else\n+\t      __throw_bad_alloc();\n+\t  }\n+\treturn __ret;\n+      }\n+\n+      // __p is not permitted to be a null pointer.\n+      void\n+      deallocate(pointer __p, size_type __n)\n+      { _Alloc::deallocate(__p, __n * sizeof(_Tp)); }\n+\n+      size_type\n+      max_size() const throw() { return size_t(-1) / sizeof(_Tp); }\n+\n+      void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n+\n+      void destroy(pointer __p) { __p->~_Tp(); }\n+    };\n+\n+  template<>\n+    class allocator<void>\n+    {\n+    public:\n+      typedef size_t      size_type;\n+      typedef ptrdiff_t   difference_type;\n+      typedef void*       pointer;\n+      typedef const void* const_pointer;\n+      typedef void        value_type;\n+\n+      template<typename _Tp1>\n+        struct rebind\n+        { typedef allocator<_Tp1> other; };\n+    };\n+\n+\n+  template<typename _T1, typename _T2>\n+    inline bool\n+    operator==(const allocator<_T1>&, const allocator<_T2>&)\n+    { return true; }\n+\n+  template<typename _T1, typename _T2>\n+    inline bool\n+    operator!=(const allocator<_T1>&, const allocator<_T2>&)\n+    { return false; }\n+\n+  // Inhibit implicit instantiations for required instantiations,\n+  // which are defined via explicit instantiations elsewhere.\n+  // NB: This syntax is a GNU extension.\n+#if _GLIBCPP_EXTERN_TEMPLATE\n+  extern template class allocator<char>;\n+  extern template class allocator<wchar_t>;\n+#endif\n+} // namespace std\n+\n+#endif"}, {"sha": "be9a352fdd9f42c940c3e67daa866d8934a624f0", "filename": "libstdc++-v3/include/bits/allocator_traits.h", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator_traits.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -0,0 +1,236 @@\n+// Allocators -*- C++ -*-\n+\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ * Copyright (c) 1996-1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#ifndef _ALLOCATOR_TRAITS_H\n+#define _ALLOCATOR_TRAITS_H 1\n+\n+#include <cstddef>\n+\n+namespace std\n+{\n+  /**\n+   *  @if maint\n+   *  This is used primarily (only?) in _Alloc_traits and other places to\n+   *  help provide the _Alloc_type typedef.  All it does is forward the\n+   *  requests after some minimal checking.\n+   *\n+   *  This is neither \"standard\"-conforming nor \"SGI\".  The _Alloc parameter\n+   *  must be \"SGI\" style.\n+   *  @endif\n+   *  (See @link Allocators allocators info @endlink for more.)\n+   */\n+  template<typename _Tp, typename _Alloc>\n+    class __simple_alloc\n+    {\n+    public:\n+      static _Tp*\n+      allocate(size_t __n)\n+      {\n+\t_Tp* __ret = 0;\n+\tif (__n)\n+\t  __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));\n+\treturn __ret;\n+      }\n+  \n+      static _Tp*\n+      allocate()\n+      { return (_Tp*) _Alloc::allocate(sizeof (_Tp)); }\n+  \n+      static void\n+      deallocate(_Tp* __p, size_t __n)\n+      { if (0 != __n) _Alloc::deallocate(__p, __n * sizeof (_Tp)); }\n+  \n+      static void\n+      deallocate(_Tp* __p)\n+      { _Alloc::deallocate(__p, sizeof (_Tp)); }\n+    };\n+\n+\n+  /**\n+   *  @if maint\n+   *  Allocator adaptor to turn an \"SGI\" style allocator (e.g.,\n+   *  __alloc, __malloc_alloc) into a \"standard\" conforming\n+   *  allocator.  Note that this adaptor does *not* assume that all\n+   *  objects of the underlying alloc class are identical, nor does it\n+   *  assume that all of the underlying alloc's member functions are\n+   *  static member functions.  Note, also, that __allocator<_Tp,\n+   *  __alloc> is essentially the same thing as allocator<_Tp>.\n+   *  @endif\n+   *  (See @link Allocators allocators info @endlink for more.)\n+   */\n+  template<typename _Tp, typename _Alloc>\n+    struct __allocator\n+    {\n+      _Alloc __underlying_alloc;\n+      \n+      typedef size_t    size_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef _Tp*       pointer;\n+      typedef const _Tp* const_pointer;\n+      typedef _Tp&       reference;\n+      typedef const _Tp& const_reference;\n+      typedef _Tp        value_type;\n+\n+      template<typename _Tp1>\n+        struct rebind\n+        { typedef __allocator<_Tp1, _Alloc> other; };\n+\n+      __allocator() throw() { }\n+\n+      __allocator(const __allocator& __a) throw()\n+      : __underlying_alloc(__a.__underlying_alloc) { }\n+\n+      template<typename _Tp1>\n+        __allocator(const __allocator<_Tp1, _Alloc>& __a) throw()\n+        : __underlying_alloc(__a.__underlying_alloc) { }\n+\n+      ~__allocator() throw() { }\n+\n+      pointer\n+      address(reference __x) const { return &__x; }\n+\n+      const_pointer\n+      address(const_reference __x) const { return &__x; }\n+\n+      // NB: __n is permitted to be 0.  The C++ standard says nothing\n+      // about what the return value is when __n == 0.\n+      _Tp*\n+      allocate(size_type __n, const void* = 0)\n+      {\n+\t_Tp* __ret = 0;\n+\tif (__n)\n+\t  __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));\n+\treturn __ret;\n+      }\n+\n+      // __p is not permitted to be a null pointer.\n+      void\n+      deallocate(pointer __p, size_type __n)\n+      { __underlying_alloc.deallocate(__p, __n * sizeof(_Tp)); }\n+      \n+      size_type\n+      max_size() const throw() { return size_t(-1) / sizeof(_Tp); }\n+      \n+      void\n+      construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n+      \n+      void\n+      destroy(pointer __p) { __p->~_Tp(); }\n+    };\n+\n+  template<typename _Alloc>\n+    struct __allocator<void, _Alloc>\n+    {\n+      typedef size_t      size_type;\n+      typedef ptrdiff_t   difference_type;\n+      typedef void*       pointer;\n+      typedef const void* const_pointer;\n+      typedef void        value_type;\n+\n+      template<typename _Tp1>\n+        struct rebind\n+        { typedef __allocator<_Tp1, _Alloc> other; };\n+    };\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator==(const __allocator<_Tp,_Alloc>& __a1, \n+\t       const __allocator<_Tp,_Alloc>& __a2)\n+    { return __a1.__underlying_alloc == __a2.__underlying_alloc; }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator!=(const __allocator<_Tp, _Alloc>& __a1,\n+               const __allocator<_Tp, _Alloc>& __a2)\n+    { return __a1.__underlying_alloc != __a2.__underlying_alloc; }\n+\n+\n+  /**\n+   *  @if maint\n+   *  Another allocator adaptor:  _Alloc_traits.  This serves two purposes.\n+   *  First, make it possible to write containers that can use either \"SGI\"\n+   *  style allocators or \"standard\" allocators.  Second, provide a mechanism\n+   *  so that containers can query whether or not the allocator has distinct\n+   *  instances.  If not, the container can avoid wasting a word of memory to\n+   *  store an empty object.  For examples of use, see stl_vector.h, etc, or\n+   *  any of the other classes derived from this one.\n+   *\n+   *  This adaptor uses partial specialization.  The general case of\n+   *  _Alloc_traits<_Tp, _Alloc> assumes that _Alloc is a\n+   *  standard-conforming allocator, possibly with non-equal instances and\n+   *  non-static members.  (It still behaves correctly even if _Alloc has\n+   *  static member and if all instances are equal.  Refinements affect\n+   *  performance, not correctness.)\n+   *\n+   *  There are always two members:  allocator_type, which is a standard-\n+   *  conforming allocator type for allocating objects of type _Tp, and\n+   *  _S_instanceless, a static const member of type bool.  If\n+   *  _S_instanceless is true, this means that there is no difference\n+   *  between any two instances of type allocator_type.  Furthermore, if\n+   *  _S_instanceless is true, then _Alloc_traits has one additional\n+   *  member:  _Alloc_type.  This type encapsulates allocation and\n+   *  deallocation of objects of type _Tp through a static interface; it\n+   *  has two member functions, whose signatures are\n+   *\n+   *  -  static _Tp* allocate(size_t)\n+   *  -  static void deallocate(_Tp*, size_t)\n+   *\n+   *  The size_t parameters are \"standard\" style (see top of\n+   *  allocator.h) in that they take counts, not sizes.\n+   *\n+   *  @endif\n+   *  (See @link Allocators allocators info @endlink for more.)\n+   */\n+  //@{\n+  // The fully general version.\n+  template<typename _Tp, typename _Allocator>\n+    struct _Alloc_traits\n+    {\n+      static const bool _S_instanceless = false;\n+      typedef typename _Allocator::template rebind<_Tp>::other allocator_type;\n+    };\n+\n+  template<typename _Tp, typename _Allocator>\n+    const bool _Alloc_traits<_Tp, _Allocator>::_S_instanceless;\n+} // namespace std\n+\n+#endif"}, {"sha": "050b2060fc459ce65a30a5a2d17b6c17c533f0cd", "filename": "libstdc++-v3/include/bits/pthread_allocimpl.h", "status": "removed", "additions": 0, "deletions": 525, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5d594da51480a769adb947a5d2baa339892df0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpthread_allocimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5d594da51480a769adb947a5d2baa339892df0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpthread_allocimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpthread_allocimpl.h?ref=1d5d594da51480a769adb947a5d2baa339892df0", "patch": "@@ -1,525 +0,0 @@\n-// POSIX thread-related memory allocation -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- * Copyright (c) 1996\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-/** @file pthread_allocimpl.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#ifndef _CPP_BITS_PTHREAD_ALLOCIMPL_H\n-#define _CPP_BITS_PTHREAD_ALLOCIMPL_H 1\n-\n-// Pthread-specific node allocator.\n-// This is similar to the default allocator, except that free-list\n-// information is kept separately for each thread, avoiding locking.\n-// This should be reasonably fast even in the presence of threads.\n-// The down side is that storage may not be well-utilized.\n-// It is not an error to allocate memory in thread A and deallocate\n-// it in thread B.  But this effectively transfers ownership of the memory,\n-// so that it can only be reallocated by thread B.  Thus this can effectively\n-// result in a storage leak if it's done on a regular basis.\n-// It can also result in frequent sharing of\n-// cache lines among processors, with potentially serious performance\n-// consequences.\n-\n-#include <bits/c++config.h>\n-#include <cerrno>\n-#include <bits/stl_alloc.h>\n-#ifndef __RESTRICT\n-#  define __RESTRICT\n-#endif\n-\n-#include <new>\n-\n-namespace std\n-{\n-\n-#define __STL_DATA_ALIGNMENT 8\n-\n-union _Pthread_alloc_obj {\n-    union _Pthread_alloc_obj * __free_list_link;\n-    char __client_data[__STL_DATA_ALIGNMENT];    /* The client sees this.    */\n-};\n-\n-// Pthread allocators don't appear to the client to have meaningful\n-// instances.  We do in fact need to associate some state with each\n-// thread.  That state is represented by\n-// _Pthread_alloc_per_thread_state<_Max_size>.\n-\n-template<size_t _Max_size>\n-struct _Pthread_alloc_per_thread_state {\n-  typedef _Pthread_alloc_obj __obj;\n-  enum { _S_NFREELISTS = _Max_size/__STL_DATA_ALIGNMENT };\n-  _Pthread_alloc_obj* volatile __free_list[_S_NFREELISTS]; \n-  _Pthread_alloc_per_thread_state<_Max_size> * __next; \n-\t// Free list link for list of available per thread structures.\n-  \t// When one of these becomes available for reuse due to thread\n-\t// termination, any objects in its free list remain associated\n-\t// with it.  The whole structure may then be used by a newly\n-\t// created thread.\n-  _Pthread_alloc_per_thread_state() : __next(0)\n-  {\n-    memset((void *)__free_list, 0, (size_t) _S_NFREELISTS * sizeof(__obj *));\n-  }\n-  // Returns an object of size __n, and possibly adds to size n free list.\n-  void *_M_refill(size_t __n);\n-};\n-\n-// Pthread-specific allocator.\n-// The argument specifies the largest object size allocated from per-thread\n-// free lists.  Larger objects are allocated using malloc_alloc.\n-// Max_size must be a power of 2.\n-template <size_t _Max_size = 128>\n-class _Pthread_alloc_template {\n-\n-public: // but only for internal use:\n-\n-  typedef _Pthread_alloc_obj __obj;\n-\n-  // Allocates a chunk for nobjs of size size.  nobjs may be reduced\n-  // if it is inconvenient to allocate the requested number.\n-  static char *_S_chunk_alloc(size_t __size, int &__nobjs);\n-\n-  enum {_S_ALIGN = __STL_DATA_ALIGNMENT};\n-\n-  static size_t _S_round_up(size_t __bytes) {\n-    return (((__bytes) + (int) _S_ALIGN-1) & ~((int) _S_ALIGN - 1));\n-  }\n-  static size_t _S_freelist_index(size_t __bytes) {\n-    return (((__bytes) + (int) _S_ALIGN-1)/(int)_S_ALIGN - 1);\n-  }\n-\n-private:\n-  // Chunk allocation state. And other shared state.\n-  // Protected by _S_chunk_allocator_lock.\n-  static pthread_mutex_t _S_chunk_allocator_lock;\n-  static char *_S_start_free;\n-  static char *_S_end_free;\n-  static size_t _S_heap_size;\n-  static _Pthread_alloc_per_thread_state<_Max_size>* _S_free_per_thread_states;\n-  static pthread_key_t _S_key;\n-  static bool _S_key_initialized;\n-        // Pthread key under which per thread state is stored. \n-        // Allocator instances that are currently unclaimed by any thread.\n-  static void _S_destructor(void *instance);\n-        // Function to be called on thread exit to reclaim per thread\n-        // state.\n-  static _Pthread_alloc_per_thread_state<_Max_size> *_S_new_per_thread_state();\n-        // Return a recycled or new per thread state.\n-  static _Pthread_alloc_per_thread_state<_Max_size> *_S_get_per_thread_state();\n-        // ensure that the current thread has an associated\n-        // per thread state.\n-  class _M_lock;\n-  friend class _M_lock;\n-  class _M_lock {\n-      public:\n-        _M_lock () { pthread_mutex_lock(&_S_chunk_allocator_lock); }\n-        ~_M_lock () { pthread_mutex_unlock(&_S_chunk_allocator_lock); }\n-  };\n-\n-public:\n-\n-  /* n must be > 0      */\n-  static void * allocate(size_t __n)\n-  {\n-    __obj * volatile * __my_free_list;\n-    __obj * __RESTRICT __result;\n-    _Pthread_alloc_per_thread_state<_Max_size>* __a;\n-\n-    if (__n > _Max_size) {\n-        return(malloc_alloc::allocate(__n));\n-    }\n-    if (!_S_key_initialized ||\n-        !(__a = (_Pthread_alloc_per_thread_state<_Max_size>*)\n-                                 pthread_getspecific(_S_key))) {\n-        __a = _S_get_per_thread_state();\n-    }\n-    __my_free_list = __a -> __free_list + _S_freelist_index(__n);\n-    __result = *__my_free_list;\n-    if (__result == 0) {\n-        void *__r = __a -> _M_refill(_S_round_up(__n));\n-        return __r;\n-    }\n-    *__my_free_list = __result -> __free_list_link;\n-    return (__result);\n-  };\n-\n-  /* p may not be 0 */\n-  static void deallocate(void *__p, size_t __n)\n-  {\n-    __obj *__q = (__obj *)__p;\n-    __obj * volatile * __my_free_list;\n-    _Pthread_alloc_per_thread_state<_Max_size>* __a;\n-\n-    if (__n > _Max_size) {\n-        malloc_alloc::deallocate(__p, __n);\n-        return;\n-    }\n-    if (!_S_key_initialized ||\n-        !(__a = (_Pthread_alloc_per_thread_state<_Max_size> *)\n-                pthread_getspecific(_S_key))) {\n-        __a = _S_get_per_thread_state();\n-    }\n-    __my_free_list = __a->__free_list + _S_freelist_index(__n);\n-    __q -> __free_list_link = *__my_free_list;\n-    *__my_free_list = __q;\n-  }\n-\n-  static void * reallocate(void *__p, size_t __old_sz, size_t __new_sz);\n-\n-} ;\n-\n-typedef _Pthread_alloc_template<> pthread_alloc;\n-\n-\n-template <size_t _Max_size>\n-void _Pthread_alloc_template<_Max_size>::_S_destructor(void * __instance)\n-{\n-    _M_lock __lock_instance;\t// Need to acquire lock here.\n-    _Pthread_alloc_per_thread_state<_Max_size>* __s =\n-        (_Pthread_alloc_per_thread_state<_Max_size> *)__instance;\n-    __s -> __next = _S_free_per_thread_states;\n-    _S_free_per_thread_states = __s;\n-}\n-\n-template <size_t _Max_size>\n-_Pthread_alloc_per_thread_state<_Max_size> *\n-_Pthread_alloc_template<_Max_size>::_S_new_per_thread_state()\n-{    \n-    /* lock already held here.\t*/\n-    if (0 != _S_free_per_thread_states) {\n-        _Pthread_alloc_per_thread_state<_Max_size> *__result =\n-\t\t\t\t\t_S_free_per_thread_states;\n-        _S_free_per_thread_states = _S_free_per_thread_states -> __next;\n-        return __result;\n-    } else {\n-        return new _Pthread_alloc_per_thread_state<_Max_size>;\n-    }\n-}\n-\n-template <size_t _Max_size>\n-_Pthread_alloc_per_thread_state<_Max_size> *\n-_Pthread_alloc_template<_Max_size>::_S_get_per_thread_state()\n-{\n-    /*REFERENCED*/\n-    _M_lock __lock_instance;\t// Need to acquire lock here.\n-    int __ret_code;\n-    _Pthread_alloc_per_thread_state<_Max_size> * __result;\n-    if (!_S_key_initialized) {\n-        if (pthread_key_create(&_S_key, _S_destructor)) {\n-\t    std::__throw_bad_alloc();  // defined in funcexcept.h\n-        }\n-        _S_key_initialized = true;\n-    }\n-    __result = _S_new_per_thread_state();\n-    __ret_code = pthread_setspecific(_S_key, __result);\n-    if (__ret_code) {\n-      if (__ret_code == ENOMEM) {\n-\tstd::__throw_bad_alloc();\n-      } else {\n-\t// EINVAL\n-\tabort();\n-      }\n-    }\n-    return __result;\n-}\n-\n-/* We allocate memory in large chunks in order to avoid fragmenting     */\n-/* the malloc heap too much.                                            */\n-/* We assume that size is properly aligned.                             */\n-template <size_t _Max_size>\n-char *_Pthread_alloc_template<_Max_size>\n-::_S_chunk_alloc(size_t __size, int &__nobjs)\n-{\n-  {\n-    char * __result;\n-    size_t __total_bytes;\n-    size_t __bytes_left;\n-    /*REFERENCED*/\n-    _M_lock __lock_instance;         // Acquire lock for this routine\n-\n-    __total_bytes = __size * __nobjs;\n-    __bytes_left = _S_end_free - _S_start_free;\n-    if (__bytes_left >= __total_bytes) {\n-        __result = _S_start_free;\n-        _S_start_free += __total_bytes;\n-        return(__result);\n-    } else if (__bytes_left >= __size) {\n-        __nobjs = __bytes_left/__size;\n-        __total_bytes = __size * __nobjs;\n-        __result = _S_start_free;\n-        _S_start_free += __total_bytes;\n-        return(__result);\n-    } else {\n-        size_t __bytes_to_get =\n-\t\t2 * __total_bytes + _S_round_up(_S_heap_size >> 4);\n-        // Try to make use of the left-over piece.\n-        if (__bytes_left > 0) {\n-            _Pthread_alloc_per_thread_state<_Max_size>* __a = \n-                (_Pthread_alloc_per_thread_state<_Max_size>*)\n-\t\t\tpthread_getspecific(_S_key);\n-            __obj * volatile * __my_free_list =\n-                        __a->__free_list + _S_freelist_index(__bytes_left);\n-\n-            ((__obj *)_S_start_free) -> __free_list_link = *__my_free_list;\n-            *__my_free_list = (__obj *)_S_start_free;\n-        }\n-#       ifdef _SGI_SOURCE\n-          // Try to get memory that's aligned on something like a\n-          // cache line boundary, so as to avoid parceling out\n-          // parts of the same line to different threads and thus\n-          // possibly different processors.\n-          {\n-            const int __cache_line_size = 128;  // probable upper bound\n-            __bytes_to_get &= ~(__cache_line_size-1);\n-            _S_start_free = (char *)memalign(__cache_line_size, __bytes_to_get); \n-            if (0 == _S_start_free) {\n-              _S_start_free = (char *)malloc_alloc::allocate(__bytes_to_get);\n-            }\n-          }\n-#       else  /* !SGI_SOURCE */\n-          _S_start_free = (char *)malloc_alloc::allocate(__bytes_to_get);\n-#       endif\n-        _S_heap_size += __bytes_to_get;\n-        _S_end_free = _S_start_free + __bytes_to_get;\n-    }\n-  }\n-  // lock is released here\n-  return(_S_chunk_alloc(__size, __nobjs));\n-}\n-\n-\n-/* Returns an object of size n, and optionally adds to size n free list.*/\n-/* We assume that n is properly aligned.                                */\n-/* We hold the allocation lock.                                         */\n-template <size_t _Max_size>\n-void *_Pthread_alloc_per_thread_state<_Max_size>\n-::_M_refill(size_t __n)\n-{\n-    int __nobjs = 128;\n-    char * __chunk =\n-\t_Pthread_alloc_template<_Max_size>::_S_chunk_alloc(__n, __nobjs);\n-    __obj * volatile * __my_free_list;\n-    __obj * __result;\n-    __obj * __current_obj, * __next_obj;\n-    int __i;\n-\n-    if (1 == __nobjs)  {\n-        return(__chunk);\n-    }\n-    __my_free_list = __free_list\n-\t\t + _Pthread_alloc_template<_Max_size>::_S_freelist_index(__n);\n-\n-    /* Build free list in chunk */\n-      __result = (__obj *)__chunk;\n-      *__my_free_list = __next_obj = (__obj *)(__chunk + __n);\n-      for (__i = 1; ; __i++) {\n-        __current_obj = __next_obj;\n-        __next_obj = (__obj *)((char *)__next_obj + __n);\n-        if (__nobjs - 1 == __i) {\n-            __current_obj -> __free_list_link = 0;\n-            break;\n-        } else {\n-            __current_obj -> __free_list_link = __next_obj;\n-        }\n-      }\n-    return(__result);\n-}\n-\n-template <size_t _Max_size>\n-void *_Pthread_alloc_template<_Max_size>\n-::reallocate(void *__p, size_t __old_sz, size_t __new_sz)\n-{\n-    void * __result;\n-    size_t __copy_sz;\n-\n-    if (__old_sz > _Max_size\n-\t&& __new_sz > _Max_size) {\n-        return(realloc(__p, __new_sz));\n-    }\n-    if (_S_round_up(__old_sz) == _S_round_up(__new_sz)) return(__p);\n-    __result = allocate(__new_sz);\n-    __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz;\n-    memcpy(__result, __p, __copy_sz);\n-    deallocate(__p, __old_sz);\n-    return(__result);\n-}\n-\n-template <size_t _Max_size>\n-_Pthread_alloc_per_thread_state<_Max_size> *\n-_Pthread_alloc_template<_Max_size>::_S_free_per_thread_states = 0;\n-\n-template <size_t _Max_size>\n-pthread_key_t _Pthread_alloc_template<_Max_size>::_S_key;\n-\n-template <size_t _Max_size>\n-bool _Pthread_alloc_template<_Max_size>::_S_key_initialized = false;\n-\n-template <size_t _Max_size>\n-pthread_mutex_t _Pthread_alloc_template<_Max_size>::_S_chunk_allocator_lock\n-= PTHREAD_MUTEX_INITIALIZER;\n-\n-template <size_t _Max_size>\n-char *_Pthread_alloc_template<_Max_size>\n-::_S_start_free = 0;\n-\n-template <size_t _Max_size>\n-char *_Pthread_alloc_template<_Max_size>\n-::_S_end_free = 0;\n-\n-template <size_t _Max_size>\n-size_t _Pthread_alloc_template<_Max_size>\n-::_S_heap_size = 0;\n-\n-\n-template <class _Tp>\n-class pthread_allocator {\n-  typedef pthread_alloc _S_Alloc;          // The underlying allocator.\n-public:\n-  typedef size_t     size_type;\n-  typedef ptrdiff_t  difference_type;\n-  typedef _Tp*       pointer;\n-  typedef const _Tp* const_pointer;\n-  typedef _Tp&       reference;\n-  typedef const _Tp& const_reference;\n-  typedef _Tp        value_type;\n-\n-  template <class _NewType> struct rebind {\n-    typedef pthread_allocator<_NewType> other;\n-  };\n-\n-  pthread_allocator() throw() {}\n-  pthread_allocator(const pthread_allocator& a) throw() {}\n-  template <class _OtherType>\n-\tpthread_allocator(const pthread_allocator<_OtherType>&)\n-\t\tthrow() {}\n-  ~pthread_allocator() throw() {}\n-\n-  pointer address(reference __x) const { return &__x; }\n-  const_pointer address(const_reference __x) const { return &__x; }\n-\n-  // __n is permitted to be 0.  The C++ standard says nothing about what\n-  // the return value is when __n == 0.\n-  _Tp* allocate(size_type __n, const void* = 0) {\n-    return __n != 0 ? static_cast<_Tp*>(_S_Alloc::allocate(__n * sizeof(_Tp)))\n-                    : 0;\n-  }\n-\n-  // p is not permitted to be a null pointer.\n-  void deallocate(pointer __p, size_type __n)\n-    { _S_Alloc::deallocate(__p, __n * sizeof(_Tp)); }\n-\n-  size_type max_size() const throw() \n-    { return size_t(-1) / sizeof(_Tp); }\n-\n-  void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n-  void destroy(pointer _p) { _p->~_Tp(); }\n-};\n-\n-template<>\n-class pthread_allocator<void> {\n-public:\n-  typedef size_t      size_type;\n-  typedef ptrdiff_t   difference_type;\n-  typedef void*       pointer;\n-  typedef const void* const_pointer;\n-  typedef void        value_type;\n-\n-  template <class _NewType> struct rebind {\n-    typedef pthread_allocator<_NewType> other;\n-  };\n-};\n-\n-template <size_t _Max_size>\n-inline bool operator==(const _Pthread_alloc_template<_Max_size>&,\n-                       const _Pthread_alloc_template<_Max_size>&)\n-{\n-  return true;\n-}\n-\n-template <class _T1, class _T2>\n-inline bool operator==(const pthread_allocator<_T1>&,\n-                       const pthread_allocator<_T2>& a2) \n-{\n-  return true;\n-}\n-\n-template <class _T1, class _T2>\n-inline bool operator!=(const pthread_allocator<_T1>&,\n-                       const pthread_allocator<_T2>&)\n-{\n-  return false;\n-}\n-\n-template <class _Tp, size_t _Max_size>\n-struct _Alloc_traits<_Tp, _Pthread_alloc_template<_Max_size> >\n-{\n-  static const bool _S_instanceless = true;\n-  typedef simple_alloc<_Tp, _Pthread_alloc_template<_Max_size> > _Alloc_type;\n-  typedef __allocator<_Tp, _Pthread_alloc_template<_Max_size> > \n-          allocator_type;\n-};\n-\n-template <class _Tp, class _Atype, size_t _Max>\n-struct _Alloc_traits<_Tp, __allocator<_Atype, _Pthread_alloc_template<_Max> > >\n-{\n-  static const bool _S_instanceless = true;\n-  typedef simple_alloc<_Tp, _Pthread_alloc_template<_Max> > _Alloc_type;\n-  typedef __allocator<_Tp, _Pthread_alloc_template<_Max> > allocator_type;\n-};\n-\n-template <class _Tp, class _Atype>\n-struct _Alloc_traits<_Tp, pthread_allocator<_Atype> >\n-{\n-  static const bool _S_instanceless = true;\n-  typedef simple_alloc<_Tp, _Pthread_alloc_template<> > _Alloc_type;\n-  typedef pthread_allocator<_Tp> allocator_type;\n-};\n-\n-\n-} // namespace std\n-\n-#endif /* _CPP_BITS_PTHREAD_ALLOCIMPL_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "3d26d6d645dc113cf9e1d70f1b7e654ab461d752", "filename": "libstdc++-v3/include/bits/stl_alloc.h", "status": "removed", "additions": 0, "deletions": 900, "changes": 900, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5d594da51480a769adb947a5d2baa339892df0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5d594da51480a769adb947a5d2baa339892df0/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h?ref=1d5d594da51480a769adb947a5d2baa339892df0", "patch": "@@ -1,900 +0,0 @@\n-// Allocators -*- C++ -*-\n-\n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- * Copyright (c) 1996-1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-/** @file stl_alloc.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#ifndef __GLIBCPP_INTERNAL_ALLOC_H\n-#define __GLIBCPP_INTERNAL_ALLOC_H\n-\n-/**\n- *  @defgroup Allocators Memory Allocators\n- *  @if maint\n- *  stl_alloc.h implements some node allocators.  These are NOT the same as\n- *  allocators in the C++ standard, nor in the original H-P STL.  They do not\n- *  encapsulate different pointer types; we assume that there is only one\n- *  pointer type.  The C++ standard allocators are intended to allocate\n- *  individual objects, not pools or arenas.\n- *\n- *  In this file allocators are of two different styles:  \"standard\" and\n- *  \"SGI\" (quotes included).  \"Standard\" allocators conform to 20.4.  \"SGI\"\n- *  allocators differ in AT LEAST the following ways (add to this list as you\n- *  discover them):\n- *\n- *   - \"Standard\" allocate() takes two parameters (n_count,hint=0) but \"SGI\"\n- *     allocate() takes one paramter (n_size).\n- *   - Likewise, \"standard\" deallocate()'s argument is a count, but in \"SGI\"\n- *     is a byte size.\n- *   - max_size(), construct(), and destroy() are missing in \"SGI\" allocators.\n- *   - reallocate(p,oldsz,newsz) is added in \"SGI\", and behaves as\n- *     if p=realloc(p,newsz).\n- *\n- *  \"SGI\" allocators may be wrapped in __allocator to convert the interface\n- *  into a \"standard\" one.\n- *  @endif\n- *\n- *  The canonical description of these classes is in docs/html/ext/howto.html\n- *  or online at http://gcc.gnu.org/onlinedocs/libstdc++/ext/howto.html#3\n-*/\n-\n-#include <cstddef>\n-#include <cstdlib>\n-#include <cstring>\n-#include <bits/functexcept.h>   // For __throw_bad_alloc\n-#include <bits/stl_threads.h>\n-#include <bits/atomicity.h>\n-\n-namespace std\n-{\n-  /**\n-   *  @if maint\n-   *  A new-based allocator, as required by the standard.  Allocation and\n-   *  deallocation forward to global new and delete.  \"SGI\" style, minus\n-   *  reallocate().\n-   *  @endif\n-   *  (See @link Allocators allocators info @endlink for more.)\n-   */\n-  class __new_alloc\n-  {\n-  public:\n-    static void*\n-    allocate(size_t __n)\n-    { return ::operator new(__n); }\n-\n-    static void\n-    deallocate(void* __p, size_t)\n-    { ::operator delete(__p); }\n-  };\n-\n-\n-  /**\n-   *  @if maint\n-   *  A malloc-based allocator.  Typically slower than the\n-   *  __pool_alloc (below).  Typically thread-safe and more\n-   *  storage efficient.  The template argument is unused and is only present\n-   *  to permit multiple instantiations (but see __pool_alloc\n-   *  for caveats).  \"SGI\" style, plus __set_malloc_handler for OOM conditions.\n-   *  @endif\n-   *  (See @link Allocators allocators info @endlink for more.)\n-   */\n-  template<int __inst>\n-    class __malloc_alloc\n-    {\n-    private:\n-      static void* _S_oom_malloc(size_t);\n-      static void (* __malloc_alloc_oom_handler)();\n-\n-    public:\n-      static void*\n-      allocate(size_t __n)\n-      {\n-        void* __result = malloc(__n);\n-        if (__builtin_expect(__result == 0, 0))\n-\t  __result = _S_oom_malloc(__n);\n-        return __result;\n-      }\n-\n-      static void\n-      deallocate(void* __p, size_t /* __n */)\n-      { free(__p); }\n-\n-      static void (* __set_malloc_handler(void (*__f)()))()\n-      {\n-        void (* __old)() = __malloc_alloc_oom_handler;\n-        __malloc_alloc_oom_handler = __f;\n-        return __old;\n-      }\n-    };\n-\n-  // malloc_alloc out-of-memory handling\n-  template<int __inst>\n-    void (* __malloc_alloc<__inst>::__malloc_alloc_oom_handler)() = 0;\n-\n-  template<int __inst>\n-    void*\n-    __malloc_alloc<__inst>::\n-    _S_oom_malloc(size_t __n)\n-    {\n-      void (* __my_malloc_handler)();\n-      void* __result;\n-\n-      for (;;)\n-        {\n-          __my_malloc_handler = __malloc_alloc_oom_handler;\n-          if (__builtin_expect(__my_malloc_handler == 0, 0))\n-            __throw_bad_alloc();\n-          (*__my_malloc_handler)();\n-          __result = malloc(__n);\n-          if (__result)\n-            return __result;\n-        }\n-    }\n-\n-\n-  /**\n-   *  @if maint\n-   *  This is used primarily (only?) in _Alloc_traits and other places to\n-   *  help provide the _Alloc_type typedef.  All it does is forward the\n-   *  requests after some minimal checking.\n-   *\n-   *  This is neither \"standard\"-conforming nor \"SGI\".  The _Alloc parameter\n-   *  must be \"SGI\" style.\n-   *  @endif\n-   *  (See @link Allocators allocators info @endlink for more.)\n-   */\n-  template<typename _Tp, typename _Alloc>\n-    class __simple_alloc\n-    {\n-    public:\n-      static _Tp*\n-      allocate(size_t __n)\n-      {\n-\t_Tp* __ret = 0;\n-\tif (__n)\n-\t  __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));\n-\treturn __ret;\n-      }\n-  \n-      static _Tp*\n-      allocate()\n-      { return (_Tp*) _Alloc::allocate(sizeof (_Tp)); }\n-  \n-      static void\n-      deallocate(_Tp* __p, size_t __n)\n-      { if (0 != __n) _Alloc::deallocate(__p, __n * sizeof (_Tp)); }\n-  \n-      static void\n-      deallocate(_Tp* __p)\n-      { _Alloc::deallocate(__p, sizeof (_Tp)); }\n-    };\n-\n-\n-  /**\n-   *  @if maint\n-   *  An adaptor for an underlying allocator (_Alloc) to check the size\n-   *  arguments for debugging.\n-   *\n-   *  \"There is some evidence that this can confuse Purify.\" - SGI comment\n-   *\n-   *  This adaptor is \"SGI\" style.  The _Alloc parameter must also be \"SGI\".\n-   *  @endif\n-   *  (See @link Allocators allocators info @endlink for more.)\n-   */\n-  template<typename _Alloc>\n-    class __debug_alloc\n-    {\n-    private:\n-      // Size of space used to store size.  Note that this must be\n-      // large enough to preserve alignment.\n-      enum {_S_extra = 8};\n-\n-    public:\n-      static void*\n-      allocate(size_t __n)\n-      {\n-        char* __result = (char*)_Alloc::allocate(__n + (int) _S_extra);\n-        *(size_t*)__result = __n;\n-        return __result + (int) _S_extra;\n-      }\n-\n-      static void\n-      deallocate(void* __p, size_t __n)\n-      {\n-        char* __real_p = (char*)__p - (int) _S_extra;\n-        if (*(size_t*)__real_p != __n)\n-          abort();\n-        _Alloc::deallocate(__real_p, __n + (int) _S_extra);\n-      }\n-    };\n-\n-\n-  /**\n-   *  @if maint\n-   *  Default node allocator.  \"SGI\" style.  Uses various allocators to\n-   *  fulfill underlying requests (and makes as few requests as possible\n-   *  when in default high-speed pool mode).\n-   *\n-   *  Important implementation properties:\n-   *  0. If globally mandated, then allocate objects from __new_alloc\n-   *  1. If the clients request an object of size > _S_max_bytes, the resulting\n-   *     object will be obtained directly from __new_alloc\n-   *  2. In all other cases, we allocate an object of size exactly\n-   *     _S_round_up(requested_size).  Thus the client has enough size\n-   *     information that we can return the object to the proper free list\n-   *     without permanently losing part of the object.\n-   *\n-   *  The first template parameter specifies whether more than one thread may\n-   *  use this allocator.  It is safe to allocate an object from one instance\n-   *  of a default_alloc and deallocate it with another one.  This effectively\n-   *  transfers its ownership to the second one.  This may have undesirable\n-   *  effects on reference locality.\n-   *\n-   *  The second parameter is unused and serves only to allow the creation of\n-   *  multiple default_alloc instances.  Note that containers built on different\n-   *  allocator instances have different types, limiting the utility of this\n-   *  approach.  If you do not wish to share the free lists with the main\n-   *  default_alloc instance, instantiate this with a non-zero __inst.\n-   *\n-   *  @endif\n-   *  (See @link Allocators allocators info @endlink for more.)\n-   */\n-  template<bool __threads, int __inst>\n-    class __pool_alloc\n-    {\n-    private:\n-      enum {_S_align = 8};\n-      enum {_S_max_bytes = 128};\n-      enum {_S_freelists = _S_max_bytes / _S_align};\n-\n-      union _Obj\n-      {\n-        union _Obj* _M_free_list_link;\n-        char        _M_client_data[1];    // The client sees this.\n-      };\n-\n-      static _Obj* volatile         _S_free_list[_S_freelists];\n-\n-      // Chunk allocation state.\n-      static char*                  _S_start_free;\n-      static char*                  _S_end_free;\n-      static size_t                 _S_heap_size;\n-\n-      static _STL_mutex_lock        _S_lock;\n-      static _Atomic_word \t    _S_force_new;\n-\n-      static size_t\n-      _S_round_up(size_t __bytes)\n-      { return (((__bytes) + (size_t) _S_align-1) & ~((size_t) _S_align - 1)); }\n-\n-      static size_t\n-      _S_freelist_index(size_t __bytes)\n-      { return (((__bytes) + (size_t)_S_align - 1)/(size_t)_S_align - 1); }\n-\n-      // Returns an object of size __n, and optionally adds to size __n\n-      // free list.\n-      static void*\n-      _S_refill(size_t __n);\n-\n-      // Allocates a chunk for nobjs of size size.  nobjs may be reduced\n-      // if it is inconvenient to allocate the requested number.\n-      static char*\n-      _S_chunk_alloc(size_t __size, int& __nobjs);\n-\n-      // It would be nice to use _STL_auto_lock here.  But we need a\n-      // test whether threads are in use.\n-      struct _Lock\n-      {\n-        _Lock() { if (__threads) _S_lock._M_acquire_lock(); }\n-        ~_Lock() { if (__threads) _S_lock._M_release_lock(); }\n-      } __attribute__ ((__unused__));\n-      friend struct _Lock;\n-\n-    public:\n-      // __n must be > 0\n-      static void*\n-      allocate(size_t __n)\n-      {\n-\tvoid* __ret = 0;\n-\n-\t// If there is a race through here, assume answer from getenv\n-\t// will resolve in same direction.  Inspired by techniques\n-\t// to efficiently support threading found in basic_string.h.\n-\tif (_S_force_new == 0)\n-\t  {\n-\t    if (getenv(\"GLIBCPP_FORCE_NEW\"))\n-\t      __atomic_add(&_S_force_new, 1);\n-\t    else\n-\t      __atomic_add(&_S_force_new, -1);\n-\t  }\n-\n-\tif ((__n > (size_t) _S_max_bytes) || (_S_force_new > 0))\n-\t  __ret = __new_alloc::allocate(__n);\n-\telse\n-\t  {\n-\t    _Obj* volatile* __my_free_list = _S_free_list\n-\t      + _S_freelist_index(__n);\n-\t    // Acquire the lock here with a constructor call.  This\n-\t    // ensures that it is released in exit or during stack\n-\t    // unwinding.\n-\t    _Lock __lock_instance;\n-\t    _Obj* __restrict__ __result = *__my_free_list;\n-\t    if (__builtin_expect(__result == 0, 0))\n-\t      __ret = _S_refill(_S_round_up(__n));\n-\t    else\n-\t      {\n-\t\t*__my_free_list = __result -> _M_free_list_link;\n-\t\t__ret = __result;\n-\t      }\t    \n-\t    if (__builtin_expect(__ret == 0, 0))\n-\t      __throw_bad_alloc();\n-\t  }\n-\treturn __ret;\n-      }\n-\n-      // __p may not be 0\n-      static void\n-      deallocate(void* __p, size_t __n)\n-      {\n-\tif ((__n > (size_t) _S_max_bytes) || (_S_force_new > 0))\n-\t  __new_alloc::deallocate(__p, __n);\n-\telse\n-\t  {\n-\t    _Obj* volatile*  __my_free_list = _S_free_list\n-\t      + _S_freelist_index(__n);\n-\t    _Obj* __q = (_Obj*)__p;\n-\n-\t    // Acquire the lock here with a constructor call.  This\n-\t    // ensures that it is released in exit or during stack\n-\t    // unwinding.\n-\t    _Lock __lock_instance;\n-\t    __q -> _M_free_list_link = *__my_free_list;\n-\t    *__my_free_list = __q;\n-\t  }\n-      }\n-    };\n-\n-  template<bool __threads, int __inst> _Atomic_word\n-  __pool_alloc<__threads, __inst>::_S_force_new = 0;\n-\n-  template<bool __threads, int __inst>\n-    inline bool\n-    operator==(const __pool_alloc<__threads,__inst>&, \n-\t       const __pool_alloc<__threads,__inst>&)\n-    { return true; }\n-\n-  template<bool __threads, int __inst>\n-    inline bool\n-    operator!=(const __pool_alloc<__threads,__inst>&,\n-               const __pool_alloc<__threads,__inst>&)\n-    { return false; }\n-\n-\n-  // We allocate memory in large chunks in order to avoid fragmenting the\n-  // heap too much.  We assume that __size is properly aligned.  We hold\n-  // the allocation lock.\n-  template<bool __threads, int __inst>\n-    char*\n-    __pool_alloc<__threads, __inst>::\n-    _S_chunk_alloc(size_t __size, int& __nobjs)\n-    {\n-      char* __result;\n-      size_t __total_bytes = __size * __nobjs;\n-      size_t __bytes_left = _S_end_free - _S_start_free;\n-\n-      if (__bytes_left >= __total_bytes)\n-        {\n-          __result = _S_start_free;\n-          _S_start_free += __total_bytes;\n-          return __result ;\n-        }\n-      else if (__bytes_left >= __size)\n-        {\n-          __nobjs = (int)(__bytes_left/__size);\n-          __total_bytes = __size * __nobjs;\n-          __result = _S_start_free;\n-          _S_start_free += __total_bytes;\n-          return __result;\n-        }\n-      else\n-        {\n-          size_t __bytes_to_get =\n-            2 * __total_bytes + _S_round_up(_S_heap_size >> 4);\n-          // Try to make use of the left-over piece.\n-          if (__bytes_left > 0)\n-            {\n-              _Obj* volatile* __my_free_list =\n-                _S_free_list + _S_freelist_index(__bytes_left);\n-\n-              ((_Obj*)(void*)_S_start_free) -> _M_free_list_link = *__my_free_list;\n-              *__my_free_list = (_Obj*)(void*)_S_start_free;\n-            }\n-          _S_start_free = (char*) __new_alloc::allocate(__bytes_to_get);\n-          if (_S_start_free == 0)\n-            {\n-              size_t __i;\n-              _Obj* volatile* __my_free_list;\n-              _Obj* __p;\n-              // Try to make do with what we have.  That can't hurt.  We\n-              // do not try smaller requests, since that tends to result\n-              // in disaster on multi-process machines.\n-              __i = __size;\n-              for (; __i <= (size_t) _S_max_bytes; __i += (size_t) _S_align)\n-                {\n-                  __my_free_list = _S_free_list + _S_freelist_index(__i);\n-                  __p = *__my_free_list;\n-                  if (__p != 0)\n-                    {\n-                      *__my_free_list = __p -> _M_free_list_link;\n-                      _S_start_free = (char*)__p;\n-                      _S_end_free = _S_start_free + __i;\n-                      return _S_chunk_alloc(__size, __nobjs);\n-                      // Any leftover piece will eventually make it to the\n-                      // right free list.\n-                    }\n-                }\n-              _S_end_free = 0;        // In case of exception.\n-              _S_start_free = (char*)__new_alloc::allocate(__bytes_to_get);\n-              // This should either throw an exception or remedy the situation.\n-              // Thus we assume it succeeded.\n-            }\n-          _S_heap_size += __bytes_to_get;\n-          _S_end_free = _S_start_free + __bytes_to_get;\n-          return _S_chunk_alloc(__size, __nobjs);\n-        }\n-    }\n-\n-\n-  // Returns an object of size __n, and optionally adds to \"size\n-  // __n\"'s free list.  We assume that __n is properly aligned.  We\n-  // hold the allocation lock.\n-  template<bool __threads, int __inst>\n-    void*\n-    __pool_alloc<__threads, __inst>::_S_refill(size_t __n)\n-    {\n-      int __nobjs = 20;\n-      char* __chunk = _S_chunk_alloc(__n, __nobjs);\n-      _Obj* volatile* __my_free_list;\n-      _Obj* __result;\n-      _Obj* __current_obj;\n-      _Obj* __next_obj;\n-      int __i;\n-\n-      if (1 == __nobjs)\n-        return __chunk;\n-      __my_free_list = _S_free_list + _S_freelist_index(__n);\n-\n-      // Build free list in chunk.\n-      __result = (_Obj*)(void*)__chunk;\n-      *__my_free_list = __next_obj = (_Obj*)(void*)(__chunk + __n);\n-      for (__i = 1; ; __i++)\n-        {\n-\t  __current_obj = __next_obj;\n-          __next_obj = (_Obj*)(void*)((char*)__next_obj + __n);\n-\t  if (__nobjs - 1 == __i)\n-\t    {\n-\t      __current_obj -> _M_free_list_link = 0;\n-\t      break;\n-\t    }\n-\t  else\n-\t    __current_obj -> _M_free_list_link = __next_obj;\n-\t}\n-      return __result;\n-    }\n-\n-\n-  template<bool __threads, int __inst>\n-    _STL_mutex_lock\n-    __pool_alloc<__threads,__inst>::_S_lock __STL_MUTEX_INITIALIZER;\n-\n-  template<bool __threads, int __inst>\n-    char* __pool_alloc<__threads,__inst>::_S_start_free = 0;\n-\n-  template<bool __threads, int __inst>\n-    char* __pool_alloc<__threads,__inst>::_S_end_free = 0;\n-\n-  template<bool __threads, int __inst>\n-    size_t __pool_alloc<__threads,__inst>::_S_heap_size = 0;\n-\n-  template<bool __threads, int __inst>\n-    typename __pool_alloc<__threads,__inst>::_Obj* volatile\n-    __pool_alloc<__threads,__inst>::_S_free_list[_S_freelists];\n-\n-  typedef __pool_alloc<true,0>    __alloc;\n-  typedef __pool_alloc<false,0>   __single_client_alloc;\n-\n-\n-  /**\n-   *  @brief  The \"standard\" allocator, as per [20.4].\n-   *\n-   *  The private _Alloc is \"SGI\" style.  (See comments at the top\n-   *  of stl_alloc.h.)\n-   *\n-   *  The underlying allocator behaves as follows.\n-   *    - __pool_alloc is used via two typedefs\n-   *    - \"__single_client_alloc\" typedef does no locking for threads\n-   *    - \"__alloc\" typedef is threadsafe via the locks\n-   *    - __new_alloc is used for memory requests\n-   *\n-   *  (See @link Allocators allocators info @endlink for more.)\n-   */\n-  template<typename _Tp>\n-    class allocator\n-    {\n-      typedef __alloc _Alloc;          // The underlying allocator.\n-    public:\n-      typedef size_t     size_type;\n-      typedef ptrdiff_t  difference_type;\n-      typedef _Tp*       pointer;\n-      typedef const _Tp* const_pointer;\n-      typedef _Tp&       reference;\n-      typedef const _Tp& const_reference;\n-      typedef _Tp        value_type;\n-\n-      template<typename _Tp1>\n-        struct rebind\n-        { typedef allocator<_Tp1> other; };\n-\n-      allocator() throw() {}\n-      allocator(const allocator&) throw() {}\n-      template<typename _Tp1>\n-        allocator(const allocator<_Tp1>&) throw() {}\n-      ~allocator() throw() {}\n-\n-      pointer\n-      address(reference __x) const { return &__x; }\n-\n-      const_pointer\n-      address(const_reference __x) const { return &__x; }\n-\n-      // NB: __n is permitted to be 0.  The C++ standard says nothing\n-      // about what the return value is when __n == 0.\n-      _Tp*\n-      allocate(size_type __n, const void* = 0)\n-      {\n-\t_Tp* __ret = 0;\n-\tif (__n)\n-\t  {\n-\t    if (__n <= this->max_size())\n-\t      __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));\n-\t    else\n-\t      __throw_bad_alloc();\n-\t  }\n-\treturn __ret;\n-      }\n-\n-      // __p is not permitted to be a null pointer.\n-      void\n-      deallocate(pointer __p, size_type __n)\n-      { _Alloc::deallocate(__p, __n * sizeof(_Tp)); }\n-\n-      size_type\n-      max_size() const throw() { return size_t(-1) / sizeof(_Tp); }\n-\n-      void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n-      void destroy(pointer __p) { __p->~_Tp(); }\n-    };\n-\n-  template<>\n-    class allocator<void>\n-    {\n-    public:\n-      typedef size_t      size_type;\n-      typedef ptrdiff_t   difference_type;\n-      typedef void*       pointer;\n-      typedef const void* const_pointer;\n-      typedef void        value_type;\n-\n-      template<typename _Tp1>\n-        struct rebind\n-        { typedef allocator<_Tp1> other; };\n-    };\n-\n-\n-  template<typename _T1, typename _T2>\n-    inline bool\n-    operator==(const allocator<_T1>&, const allocator<_T2>&)\n-    { return true; }\n-\n-  template<typename _T1, typename _T2>\n-    inline bool\n-    operator!=(const allocator<_T1>&, const allocator<_T2>&)\n-    { return false; }\n-\n-\n-  /**\n-   *  @if maint\n-   *  Allocator adaptor to turn an \"SGI\" style allocator (e.g.,\n-   *  __alloc, __malloc_alloc) into a \"standard\" conforming\n-   *  allocator.  Note that this adaptor does *not* assume that all\n-   *  objects of the underlying alloc class are identical, nor does it\n-   *  assume that all of the underlying alloc's member functions are\n-   *  static member functions.  Note, also, that __allocator<_Tp,\n-   *  __alloc> is essentially the same thing as allocator<_Tp>.\n-   *  @endif\n-   *  (See @link Allocators allocators info @endlink for more.)\n-   */\n-  template<typename _Tp, typename _Alloc>\n-    struct __allocator\n-    {\n-      _Alloc __underlying_alloc;\n-      \n-      typedef size_t    size_type;\n-      typedef ptrdiff_t difference_type;\n-      typedef _Tp*       pointer;\n-      typedef const _Tp* const_pointer;\n-      typedef _Tp&       reference;\n-      typedef const _Tp& const_reference;\n-      typedef _Tp        value_type;\n-\n-      template<typename _Tp1>\n-        struct rebind\n-        { typedef __allocator<_Tp1, _Alloc> other; };\n-\n-      __allocator() throw() {}\n-      __allocator(const __allocator& __a) throw()\n-      : __underlying_alloc(__a.__underlying_alloc) {}\n-\n-      template<typename _Tp1>\n-        __allocator(const __allocator<_Tp1, _Alloc>& __a) throw()\n-        : __underlying_alloc(__a.__underlying_alloc) {}\n-\n-      ~__allocator() throw() {}\n-\n-      pointer\n-      address(reference __x) const { return &__x; }\n-\n-      const_pointer\n-      address(const_reference __x) const { return &__x; }\n-\n-      // NB: __n is permitted to be 0.  The C++ standard says nothing\n-      // about what the return value is when __n == 0.\n-      _Tp*\n-      allocate(size_type __n, const void* = 0)\n-      {\n-\t_Tp* __ret = 0;\n-\tif (__n)\n-\t  __ret = static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp)));\n-\treturn __ret;\n-      }\n-\n-      // __p is not permitted to be a null pointer.\n-      void\n-      deallocate(pointer __p, size_type __n)\n-      { __underlying_alloc.deallocate(__p, __n * sizeof(_Tp)); }\n-      \n-      size_type\n-      max_size() const throw() { return size_t(-1) / sizeof(_Tp); }\n-      \n-      void\n-      construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }\n-      \n-      void\n-      destroy(pointer __p) { __p->~_Tp(); }\n-    };\n-\n-  template<typename _Alloc>\n-    struct __allocator<void, _Alloc>\n-    {\n-      typedef size_t      size_type;\n-      typedef ptrdiff_t   difference_type;\n-      typedef void*       pointer;\n-      typedef const void* const_pointer;\n-      typedef void        value_type;\n-\n-      template<typename _Tp1>\n-        struct rebind\n-        { typedef __allocator<_Tp1, _Alloc> other; };\n-    };\n-\n-  template<typename _Tp, typename _Alloc>\n-    inline bool\n-    operator==(const __allocator<_Tp,_Alloc>& __a1,\n-               const __allocator<_Tp,_Alloc>& __a2)\n-    { return __a1.__underlying_alloc == __a2.__underlying_alloc; }\n-\n-  template<typename _Tp, typename _Alloc>\n-    inline bool\n-    operator!=(const __allocator<_Tp, _Alloc>& __a1,\n-               const __allocator<_Tp, _Alloc>& __a2)\n-    { return __a1.__underlying_alloc != __a2.__underlying_alloc; }\n-\n-\n-  //@{\n-  /** Comparison operators for all of the predifined SGI-style allocators.\n-   *  This ensures that __allocator<malloc_alloc> (for example) will work\n-   *  correctly.  As required, all allocators compare equal.\n-   */\n-  template<int inst>\n-    inline bool\n-    operator==(const __malloc_alloc<inst>&,\n-               const __malloc_alloc<inst>&)\n-    { return true; }\n-\n-  template<int __inst>\n-    inline bool\n-    operator!=(const __malloc_alloc<__inst>&,\n-               const __malloc_alloc<__inst>&)\n-    { return false; }\n-\n-  template<typename _Alloc>\n-    inline bool\n-    operator==(const __debug_alloc<_Alloc>&, const __debug_alloc<_Alloc>&)\n-    { return true; }\n-\n-  template<typename _Alloc>\n-    inline bool\n-    operator!=(const __debug_alloc<_Alloc>&, const __debug_alloc<_Alloc>&)\n-    { return false; }\n-  //@}\n-\n-\n-  /**\n-   *  @if maint\n-   *  Another allocator adaptor:  _Alloc_traits.  This serves two purposes.\n-   *  First, make it possible to write containers that can use either \"SGI\"\n-   *  style allocators or \"standard\" allocators.  Second, provide a mechanism\n-   *  so that containers can query whether or not the allocator has distinct\n-   *  instances.  If not, the container can avoid wasting a word of memory to\n-   *  store an empty object.  For examples of use, see stl_vector.h, etc, or\n-   *  any of the other classes derived from this one.\n-   *\n-   *  This adaptor uses partial specialization.  The general case of\n-   *  _Alloc_traits<_Tp, _Alloc> assumes that _Alloc is a\n-   *  standard-conforming allocator, possibly with non-equal instances and\n-   *  non-static members.  (It still behaves correctly even if _Alloc has\n-   *  static member and if all instances are equal.  Refinements affect\n-   *  performance, not correctness.)\n-   *\n-   *  There are always two members:  allocator_type, which is a standard-\n-   *  conforming allocator type for allocating objects of type _Tp, and\n-   *  _S_instanceless, a static const member of type bool.  If\n-   *  _S_instanceless is true, this means that there is no difference\n-   *  between any two instances of type allocator_type.  Furthermore, if\n-   *  _S_instanceless is true, then _Alloc_traits has one additional\n-   *  member:  _Alloc_type.  This type encapsulates allocation and\n-   *  deallocation of objects of type _Tp through a static interface; it\n-   *  has two member functions, whose signatures are\n-   *\n-   *  -  static _Tp* allocate(size_t)\n-   *  -  static void deallocate(_Tp*, size_t)\n-   *\n-   *  The size_t parameters are \"standard\" style (see top of stl_alloc.h) in\n-   *  that they take counts, not sizes.\n-   *\n-   *  @endif\n-   *  (See @link Allocators allocators info @endlink for more.)\n-   */\n-  //@{\n-  // The fully general version.\n-  template<typename _Tp, typename _Allocator>\n-    struct _Alloc_traits\n-    {\n-      static const bool _S_instanceless = false;\n-      typedef typename _Allocator::template rebind<_Tp>::other allocator_type;\n-    };\n-\n-  template<typename _Tp, typename _Allocator>\n-    const bool _Alloc_traits<_Tp, _Allocator>::_S_instanceless;\n-\n-  /// The version for the default allocator.\n-  template<typename _Tp, typename _Tp1>\n-    struct _Alloc_traits<_Tp, allocator<_Tp1> >\n-    {\n-      static const bool _S_instanceless = true;\n-      typedef __simple_alloc<_Tp, __alloc> _Alloc_type;\n-      typedef allocator<_Tp> allocator_type;\n-    };\n-  //@}\n-\n-  //@{\n-  /// Versions for the predefined \"SGI\" style allocators.\n-  template<typename _Tp, int __inst>\n-    struct _Alloc_traits<_Tp, __malloc_alloc<__inst> >\n-    {\n-      static const bool _S_instanceless = true;\n-      typedef __simple_alloc<_Tp, __malloc_alloc<__inst> > _Alloc_type;\n-      typedef __allocator<_Tp, __malloc_alloc<__inst> > allocator_type;\n-    };\n-\n-  template<typename _Tp, bool __threads, int __inst>\n-    struct _Alloc_traits<_Tp, __pool_alloc<__threads, __inst> >\n-    {\n-      static const bool _S_instanceless = true;\n-      typedef __simple_alloc<_Tp, __pool_alloc<__threads, __inst> >\n-      _Alloc_type;\n-      typedef __allocator<_Tp, __pool_alloc<__threads, __inst> >\n-      allocator_type;\n-    };\n-\n-  template<typename _Tp, typename _Alloc>\n-    struct _Alloc_traits<_Tp, __debug_alloc<_Alloc> >\n-    {\n-      static const bool _S_instanceless = true;\n-      typedef __simple_alloc<_Tp, __debug_alloc<_Alloc> > _Alloc_type;\n-      typedef __allocator<_Tp, __debug_alloc<_Alloc> > allocator_type;\n-    };\n-  //@}\n-\n-  //@{\n-  /// Versions for the __allocator adaptor used with the predefined\n-  /// \"SGI\" style allocators.\n-  template<typename _Tp, typename _Tp1, int __inst>\n-    struct _Alloc_traits<_Tp,\n-                         __allocator<_Tp1, __malloc_alloc<__inst> > >\n-    {\n-      static const bool _S_instanceless = true;\n-      typedef __simple_alloc<_Tp, __malloc_alloc<__inst> > _Alloc_type;\n-      typedef __allocator<_Tp, __malloc_alloc<__inst> > allocator_type;\n-    };\n-\n-  template<typename _Tp, typename _Tp1, bool __thr, int __inst>\n-    struct _Alloc_traits<_Tp, __allocator<_Tp1, __pool_alloc<__thr, __inst> > >\n-    {\n-      static const bool _S_instanceless = true;\n-      typedef __simple_alloc<_Tp, __pool_alloc<__thr,__inst> >\n-      _Alloc_type;\n-      typedef __allocator<_Tp, __pool_alloc<__thr,__inst> >\n-      allocator_type;\n-    };\n-\n-  template<typename _Tp, typename _Tp1, typename _Alloc>\n-    struct _Alloc_traits<_Tp, __allocator<_Tp1, __debug_alloc<_Alloc> > >\n-    {\n-      static const bool _S_instanceless = true;\n-      typedef __simple_alloc<_Tp, __debug_alloc<_Alloc> > _Alloc_type;\n-      typedef __allocator<_Tp, __debug_alloc<_Alloc> > allocator_type;\n-    };\n-  //@}\n-\n-  // Inhibit implicit instantiations for required instantiations,\n-  // which are defined via explicit instantiations elsewhere.\n-  // NB: This syntax is a GNU extension.\n-#if _GLIBCPP_EXTERN_TEMPLATE\n-  extern template class allocator<char>;\n-  extern template class allocator<wchar_t>;\n-  extern template class __pool_alloc<true,0>;\n-#endif\n-} // namespace std\n-\n-#endif"}, {"sha": "5863af55a35664788a795997e9e3daa6de37fd6f", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -340,7 +340,7 @@ namespace std\n    *  and destructor allocate (but don't initialize) storage.  This makes\n    *  %exception safety easier.  Second, the base class encapsulates all of\n    *  the differences between SGI-style allocators and standard-conforming\n-   *  allocators.  (See stl_alloc.h for more on this topic.)  There are two\n+   *  allocators.  (See allocator.h for more on this topic.)  There are two\n    *  versions:  this ordinary one, and the space-saving specialization for\n    *  instanceless allocators.\n    *  @endif"}, {"sha": "1fb68f01e5f594ec25532b7495ed627eb012541f", "filename": "libstdc++-v3/include/bits/stl_threads.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -48,6 +48,8 @@\n #ifndef __SGI_STL_INTERNAL_THREADS_H\n #define __SGI_STL_INTERNAL_THREADS_H\n \n+#include <cstddef>\n+\n // The only supported threading model is GCC's own gthr.h abstraction layer.\n #include \"bits/gthr.h\"\n \n@@ -209,7 +211,6 @@ namespace std\n     void operator=(const _STL_auto_lock&);\n     _STL_auto_lock(const _STL_auto_lock&);\n   } __attribute__ ((__unused__));\n-  \n } // namespace std\n \n #endif "}, {"sha": "895b98a6a527f4cf05bc471de314c058ce30cc13", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -84,7 +84,7 @@ iterators invalidated are those referring to the deleted node.\n */\n \n #include <bits/stl_algobase.h>\n-#include <bits/stl_alloc.h>\n+#include <bits/allocator.h>\n #include <bits/stl_construct.h>\n #include <bits/stl_function.h>\n "}, {"sha": "0f7eb0c653ddfb201c7accff4a8133e64ad3b089", "filename": "libstdc++-v3/include/ext/debug_allocator.h", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fext%2Fdebug_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fext%2Fdebug_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fdebug_allocator.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -0,0 +1,139 @@\n+// Allocators -*- C++ -*-\n+\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ * Copyright (c) 1996-1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+/** @file ext/debug_allocator.h\n+ *  This file is a GNU extension to the Standard C++ Library. \n+ *  You should only include this header if you are using GCC 3 or later.\n+ */\n+\n+#ifndef _DEBUG_ALLOCATOR_H\n+#define _DEBUG_ALLOCATOR_H 1\n+\n+#include <bits/allocator_traits.h>\n+\n+namespace __gnu_cxx\n+{\n+  /**\n+   *  @if maint\n+   *  An adaptor for an underlying allocator (_Alloc) to check the size\n+   *  arguments for debugging.\n+   *\n+   *  \"There is some evidence that this can confuse Purify.\" - SGI comment\n+   *\n+   *  This adaptor is \"SGI\" style.  The _Alloc parameter must also be \"SGI\".\n+   *  @endif\n+   *  (See @link Allocators allocators info @endlink for more.)\n+   */\n+  template<typename _Alloc>\n+    class __debug_alloc\n+    {\n+    private:\n+      // Size of space used to store size.  Note that this must be\n+      // large enough to preserve alignment.\n+      enum {_S_extra = 8};\n+\n+    public:\n+      static void*\n+      allocate(size_t __n)\n+      {\n+        char* __result = (char*)_Alloc::allocate(__n + (int) _S_extra);\n+        *(size_t*)__result = __n;\n+        return __result + (int) _S_extra;\n+      }\n+\n+      static void\n+      deallocate(void* __p, size_t __n)\n+      {\n+        char* __real_p = (char*)__p - (int) _S_extra;\n+        if (*(size_t*)__real_p != __n)\n+          abort();\n+        _Alloc::deallocate(__real_p, __n + (int) _S_extra);\n+      }\n+    };\n+\n+  //@{\n+  /** Comparison operators for all of the predifined SGI-style allocators.\n+   *  This ensures that __allocator<malloc_alloc> (for example) will work\n+   *  correctly.  As required, all allocators compare equal.\n+   */\n+  template<typename _Alloc>\n+    inline bool\n+    operator==(const __debug_alloc<_Alloc>&, const __debug_alloc<_Alloc>&)\n+    { return true; }\n+\n+  template<typename _Alloc>\n+    inline bool\n+    operator!=(const __debug_alloc<_Alloc>&, const __debug_alloc<_Alloc>&)\n+    { return false; }\n+  //@}\n+} // namespace __gnu_cxx\n+\n+namespace std\n+{\n+  //@{\n+  /// Versions for the predefined \"SGI\" style allocators.\n+  template<typename _Tp, typename _Alloc>\n+    struct _Alloc_traits<_Tp, __gnu_cxx::__debug_alloc<_Alloc> >\n+    {\n+      static const bool _S_instanceless = true;\n+      typedef __gnu_cxx::__debug_alloc<_Alloc>\t\tbase_alloc_type;\n+      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n+      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n+    };\n+  //@}\n+\n+  //@{\n+  /// Versions for the __allocator adaptor used with the predefined\n+  /// \"SGI\" style allocators.\n+  template<typename _Tp, typename _Tp1, typename _Alloc>\n+    struct _Alloc_traits<_Tp, __allocator<_Tp1, \n+\t\t\t\t\t  __gnu_cxx::__debug_alloc<_Alloc> > >\n+    {\n+      static const bool _S_instanceless = true;\n+      typedef __gnu_cxx::__debug_alloc<_Alloc>\t\tbase_alloc_type;\n+      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n+      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n+    };\n+  //@}\n+} // namespace std\n+\n+#endif"}, {"sha": "410b296e09d0cc9b7cf96e7b9207c13390e82128", "filename": "libstdc++-v3/include/ext/malloc_allocator.h", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmalloc_allocator.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -0,0 +1,163 @@\n+// Allocators -*- C++ -*-\n+\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ * Copyright (c) 1996-1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+/** @file ext/debug_allocator.h\n+ *  This file is a GNU extension to the Standard C++ Library. \n+ *  You should only include this header if you are using GCC 3 or later.\n+ */\n+\n+#ifndef _MALLOC_ALLOCATOR_H\n+#define _MALLOC_ALLOCATOR_H 1\n+\n+#include <bits/allocator_traits.h>\n+\n+namespace __gnu_cxx\n+{\n+  /**\n+   *  @if maint\n+   *  A malloc-based allocator.  Typically slower than the\n+   *  __pool_alloc (below).  Typically thread-safe and more\n+   *  storage efficient.  The template argument is unused and is only present\n+   *  to permit multiple instantiations (but see __pool_alloc\n+   *  for caveats).  \"SGI\" style, plus __set_malloc_handler for OOM conditions.\n+   *  @endif\n+   *  (See @link Allocators allocators info @endlink for more.)\n+   */\n+  template<int __inst>\n+    class __malloc_alloc\n+    {\n+    private:\n+      static void* _S_oom_malloc(size_t);\n+      static void (* __malloc_alloc_oom_handler)();\n+\n+    public:\n+      static void*\n+      allocate(size_t __n)\n+      {\n+        void* __result = malloc(__n);\n+        if (__builtin_expect(__result == 0, 0))\n+\t  __result = _S_oom_malloc(__n);\n+        return __result;\n+      }\n+\n+      static void\n+      deallocate(void* __p, size_t /* __n */)\n+      { free(__p); }\n+\n+      static void (* __set_malloc_handler(void (*__f)()))()\n+      {\n+        void (* __old)() = __malloc_alloc_oom_handler;\n+        __malloc_alloc_oom_handler = __f;\n+        return __old;\n+      }\n+    };\n+\n+  // malloc_alloc out-of-memory handling\n+  template<int __inst>\n+    void (* __malloc_alloc<__inst>::__malloc_alloc_oom_handler)() = 0;\n+\n+  template<int __inst>\n+    void*\n+    __malloc_alloc<__inst>::\n+    _S_oom_malloc(size_t __n)\n+    {\n+      void (* __my_malloc_handler)();\n+      void* __result;\n+\n+      for (;;)\n+        {\n+          __my_malloc_handler = __malloc_alloc_oom_handler;\n+          if (__builtin_expect(__my_malloc_handler == 0, 0))\n+            __throw_bad_alloc();\n+          (*__my_malloc_handler)();\n+          __result = malloc(__n);\n+          if (__result)\n+            return __result;\n+        }\n+    }\n+  //@{\n+  /** Comparison operators for all of the predifined SGI-style allocators.\n+   *  This ensures that __allocator<malloc_alloc> (for example) will work\n+   *  correctly.  As required, all allocators compare equal.\n+   */\n+  template<int inst>\n+    inline bool\n+    operator==(const __malloc_alloc<inst>&, const __malloc_alloc<inst>&)\n+    { return true; }\n+\n+  template<int __inst>\n+    inline bool\n+    operator!=(const __malloc_alloc<__inst>&, const __malloc_alloc<__inst>&)\n+    { return false; }\n+  //@}\n+} // namespace __gnu_cxx\n+\n+namespace std\n+{\n+  //@{\n+  /// Versions for the predefined \"SGI\" style allocators.\n+  template<typename _Tp, int __inst>\n+    struct _Alloc_traits<_Tp, __gnu_cxx::__malloc_alloc<__inst> >\n+    {\n+      static const bool _S_instanceless = true;\n+      typedef __gnu_cxx:: __malloc_alloc<__inst>\tbase_alloc_type;\n+      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n+      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n+    };\n+  //@}\n+\n+  //@{\n+  /// Versions for the __allocator adaptor used with the predefined\n+  /// \"SGI\" style allocators.\n+  template<typename _Tp, typename _Tp1, int __inst>\n+    struct _Alloc_traits<_Tp, __allocator<_Tp1, \n+\t\t\t\t\t  __gnu_cxx::__malloc_alloc<__inst> > >\n+    {\n+      static const bool _S_instanceless = true;\n+      typedef __gnu_cxx:: __malloc_alloc<__inst>\tbase_alloc_type;\n+      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n+      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n+    };\n+  //@}\n+} // namespace std\n+\n+#endif"}, {"sha": "1e95b55f467dcdf56bb593e22623401ddf802c85", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "added", "additions": 861, "deletions": 0, "changes": 861, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -0,0 +1,861 @@\n+// MT-optimized allocator -*- C++ -*-\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file ext/mt_allocator.h\n+ *  This file is a GNU extension to the Standard C++ Library. \n+ *  You should only include this header if you are using GCC 3 or later.\n+ */\n+\n+#ifndef _MT_ALLOCATOR_H\n+#define _MT_ALLOCATOR_H 1\n+\n+#include <cstdlib>\n+#include <bits/functexcept.h> \n+#include <bits/stl_threads.h>\n+#include <bits/atomicity.h>\n+#include <bits/allocator_traits.h>\n+\n+/**\n+ *  This is a fixed size (power of 2) allocator which - when compiled\n+ *  with thread support - will maintain one freelist per size per thread\n+ *  plus a \"global\" one. Steps are taken to limit the per thread freelist\n+ *  sizes (by returning excess back to \"global\").\n+ *\n+ *  Usage examples:\n+ *    vector<int, __gnu_cxx::__mt_alloc<0> > v1;\n+ *\n+ *    typedef std::__allocator<char, __gnu_cxx::__mt_alloc<0> > string_alloc;\n+ *    std::basic_string<char, std::char_traits<char>, string_alloc> s1;\n+ */\n+\n+namespace __gnu_cxx\n+{\n+  template<int __inst>\n+    class __mt_alloc\n+    {\n+    private:\n+      /*\n+       * We need to create the initial lists and set up some variables\n+       * before we can answer to the first request for memory. \n+       * The initialization of these variables is done at file scope \n+       * below class declaration.\n+       */\n+#ifdef __GTHREADS\n+      static __gthread_once_t _S_once_mt;\n+#endif\n+      static bool _S_initialized;\n+\n+      /*\n+       * Using short int as type for the binmap implies we are never caching\n+       * blocks larger than 65535 with this allocator\n+       */\n+      typedef unsigned short int binmap_type;\n+      static binmap_type* _S_binmap;\n+\n+      static void _S_init();\n+\n+      /*\n+       * Variables used to \"tune\" the behavior of the allocator, assigned\n+       * and explained in detail below.\n+       */\n+      static size_t _S_max_bytes;\n+      static size_t _S_chunk_size;\n+      static size_t _S_max_threads;\n+      static size_t _S_no_of_bins;\n+      static size_t _S_freelist_headroom;\n+\n+      /*\n+       * Each requesting thread is assigned an id ranging from 1 to \n+       * _S_max_threads. Thread id 0 is used as a global memory pool.\n+       * In order to get constant performance on the thread assignment\n+       * routine, we keep a list of free ids. When a thread first requests\n+       * memory we remove the first record in this list and stores the address\n+       * in a __gthread_key. When initializing the __gthread_key\n+       * we specify a destructor. When this destructor (i.e. the thread dies)\n+       * is called, we return the thread id to the back of this list.\n+       */\n+#ifdef __GTHREADS\n+      struct thread_record\n+      {\n+        /*\n+         * Points to next free thread id record. NULL if last record in list.\n+         */\n+        thread_record* next;\n+\n+        /*\n+         * Thread id ranging from 1 to _S_max_threads.\n+         */\n+        size_t id;\n+      };\n+\n+      static thread_record* _S_thread_freelist_first;\n+      static thread_record* _S_thread_freelist_last;\n+      static __gthread_mutex_t _S_thread_freelist_mutex;\n+      static void _S_thread_key_destr(void* freelist_pos);\n+      static __gthread_key_t _S_thread_key;\n+      static size_t _S_get_thread_id();\n+#endif\n+\n+      struct block_record\n+      {\n+        /*\n+         * Points to the next block_record for its thread_id.\n+         */\n+        block_record* next;\n+\n+        /*\n+         * The thread id of the thread which has requested this block.\n+         * All blocks are initially \"owned\" by global pool thread id 0.\n+         */\n+        size_t thread_id;\n+      };\n+\n+      struct bin_record\n+      {\n+        /*\n+         * An \"array\" of pointers to the first/last free block for each \n+         * thread id. Memory to these \"arrays\" is allocated in _S_init() \n+         * for _S_max_threads + global pool 0.\n+         */\n+        block_record** first;\n+        block_record** last;\n+\n+        /*\n+         * An \"array\" of counters used to keep track of the amount of blocks\n+         * that are on the freelist/used for each thread id.\n+         * Memory to these \"arrays\" is allocated in _S_init() \n+         * for _S_max_threads + global pool 0.\n+         */\n+        size_t* free;\n+        size_t* used;\n+\n+        /*\n+         * Each bin has its own mutex which is used to ensure data integrity \n+         * while changing \"ownership\" on a block.\n+         * The mutex is initialized in _S_init().\n+         */\n+#ifdef __GTHREADS\n+        __gthread_mutex_t* mutex; \n+#endif\n+      };\n+\n+      /*\n+       * An \"array\" of bin_records each of which represents a specific \n+       * power of 2 size. Memory to this \"array\" is allocated in _S_init().\n+       */\n+      static bin_record* _S_bin;\n+\n+    public:\n+      static void*\n+      allocate(size_t __n)\n+      {\n+\n+        /*\n+         * Requests larger than _S_max_bytes are handled by\n+         * malloc/free directly\n+         */\n+        if (__n > _S_max_bytes)\n+          {\n+            void* __ret = malloc(__n);\n+            if (!__ret) \n+              __throw_bad_alloc();\n+\n+            return __ret;\n+          }\n+\n+        /*\n+         * Although the test in __gthread_once() would suffice, we\n+         * wrap test of the once condition in our own unlocked\n+         * check. This saves one function call to pthread_once()\n+         * (which itself only tests for the once value unlocked anyway\n+         * and immediately returns if set)\n+         */\n+        if (!_S_initialized)\n+          {\n+#ifdef __GTHREADS\n+            if (__gthread_active_p())\n+              __gthread_once(&_S_once_mt, _S_init);\n+            else\n+#endif\n+              {\n+                _S_max_threads = 0;\n+                _S_init();\n+              }\n+          }\n+\n+        /*\n+         * Round up to power of 2 and figure out which bin to use\n+         */\n+        size_t bin = _S_binmap[__n];\n+\n+#ifdef __GTHREADS\n+        size_t thread_id = _S_get_thread_id();\n+#else\n+        size_t thread_id = 0;\n+#endif\n+\n+        block_record* block;\n+\n+        /*\n+         * Find out if we have blocks on our freelist.\n+         * If so, go ahead and use them directly without\n+         * having to lock anything.\n+         */\n+        if (_S_bin[bin].first[thread_id] == NULL)\n+          {\n+            /*\n+             * Are we using threads?\n+             * - Yes, lock and check if there are free blocks on the global \n+             *   list (and if not add new ones), get the first one \n+             *   and change owner.\n+             * - No, all operations are made directly to global pool 0 \n+             *   no need to lock or change ownership but check for free \n+             *   blocks on global list (and if not add new ones) and \n+             *   get the first one.\n+             */\n+#ifdef __GTHREADS\n+            if (__gthread_active_p())\n+              {\n+                __gthread_mutex_lock(_S_bin[bin].mutex);\n+\n+                if (_S_bin[bin].first[0] == NULL)\n+                  {\n+                    _S_bin[bin].first[0] = \n+                      (block_record*)malloc(_S_chunk_size);\n+\n+                    if (!_S_bin[bin].first[0])\n+                      {\n+                        __gthread_mutex_unlock(_S_bin[bin].mutex);\n+                        __throw_bad_alloc();\n+                      }\n+\n+                    size_t bin_t = 1 << bin;\n+                    size_t block_count = \n+                      _S_chunk_size /(bin_t + sizeof(block_record));\n+\n+                    _S_bin[bin].free[0] = block_count;\n+\n+                    block_count--;\n+                    block = _S_bin[bin].first[0];\n+\n+                    while (block_count > 0)\n+                      {\n+                        block->next = (block_record*)((char*)block + \n+                                      (bin_t + sizeof(block_record)));\n+                        block = block->next;\n+                        block_count--;\n+                      }\n+\n+                    block->next = NULL;\n+                    _S_bin[bin].last[0] = block;\n+                  }\n+\n+                block = _S_bin[bin].first[0];\n+\n+                /*\n+                 * Remove from list and count down the available counter on\n+                 * global pool 0.\n+                 */\n+                _S_bin[bin].first[0] = _S_bin[bin].first[0]->next;\n+                _S_bin[bin].free[0]--;\n+\n+                __gthread_mutex_unlock(_S_bin[bin].mutex);\n+\n+                /*\n+                 * Now that we have removed the block from the global\n+                 * freelist we can change owner and update the used\n+                 * counter for this thread without locking.\n+                 */\n+                block->thread_id = thread_id;\n+                _S_bin[bin].used[thread_id]++;\n+              }\n+            else\n+#endif\n+              {\n+                _S_bin[bin].first[0] = (block_record*)malloc(_S_chunk_size);\n+\n+                if (!_S_bin[bin].first[0]) \n+                  __throw_bad_alloc();\n+\n+                size_t bin_t = 1 << bin;\n+                size_t block_count = \n+                  _S_chunk_size / (bin_t + sizeof(block_record));\n+\n+                _S_bin[bin].free[0] = block_count;\n+\n+                block_count--;\n+                block = _S_bin[bin].first[0];\n+\n+                while (block_count > 0)\n+                  {\n+                    block->next = (block_record*)((char*)block + \n+                                  (bin_t + sizeof(block_record)));\n+                    block = block->next;\n+                    block_count--;\n+                  }\n+\n+                block->next = NULL;\n+                _S_bin[bin].last[0] = block;\n+\n+                block = _S_bin[bin].first[0];\n+\n+                /*\n+                 * Remove from list and count down the available counter on\n+                 * global pool 0 and increase it's used counter.\n+                 */\n+                _S_bin[bin].first[0] = _S_bin[bin].first[0]->next;\n+                _S_bin[bin].free[0]--;\n+                _S_bin[bin].used[0]++;\n+              }\n+          }  \n+        else\n+          {\n+            /*\n+             * \"Default\" operation - we have blocks on our own freelist\n+             * grab the first record and update the counters.\n+             */\n+            block = _S_bin[bin].first[thread_id];\n+\n+            _S_bin[bin].first[thread_id] = _S_bin[bin].first[thread_id]->next;\n+            _S_bin[bin].free[thread_id]--;\n+            _S_bin[bin].used[thread_id]++;\n+          }\n+\n+        return (void*)((char*)block + sizeof(block_record));\n+      }\n+\n+      static void\n+      deallocate(void* __p, size_t __n)\n+      {\n+        /*\n+         * Requests larger than _S_max_bytes are handled by\n+         * malloc/free directly\n+         */\n+        if (__n > _S_max_bytes)\n+          {\n+            free(__p);\n+            return;\n+          }\n+\n+        /*\n+         * Round up to power of 2 and figure out which bin to use\n+         */\n+        size_t bin = _S_binmap[__n];\n+\n+#ifdef __GTHREADS\n+        size_t thread_id = _S_get_thread_id();\n+#else\n+        size_t thread_id = 0;\n+#endif\n+\n+        block_record* block = (block_record*)((char*)__p \n+\t\t\t\t\t      - sizeof(block_record));\n+\n+        /*\n+         * This block will always be at the back of a list and thus\n+         * we set its next pointer to NULL.\n+         */\n+        block->next = NULL;\n+\n+#ifdef __GTHREADS\n+        if (__gthread_active_p())\n+          {\n+            /*\n+             * Calculate the number of records to remove from our freelist\n+             */\n+            int remove = _S_bin[bin].free[thread_id] - \n+                         (_S_bin[bin].used[thread_id] / _S_freelist_headroom);\n+\n+            /*\n+             * The calculation above will almost always tell us to\n+             * remove one or two records at a time, but this creates\n+             * too much contention when locking and therefore we\n+             * wait until the number of records is \"high enough\".\n+             */\n+            if (remove > (int)(100 * (_S_no_of_bins - bin)) && \n+                remove > (int)(_S_bin[bin].free[thread_id] / \n+                               _S_freelist_headroom))\n+              {\n+                __gthread_mutex_lock(_S_bin[bin].mutex);\n+\n+                while (remove > 0)\n+                  {\n+                    if (_S_bin[bin].first[0] == NULL)\n+                      _S_bin[bin].first[0] = _S_bin[bin].first[thread_id];\n+                    else\n+                      _S_bin[bin].last[0]->next = _S_bin[bin].first[thread_id];\n+\n+                    _S_bin[bin].last[0] = _S_bin[bin].first[thread_id];\n+\n+                    _S_bin[bin].first[thread_id] = \n+                      _S_bin[bin].first[thread_id]->next;\n+\n+                    _S_bin[bin].free[0]++;\n+                    _S_bin[bin].free[thread_id]--;\n+\n+                    remove--;\n+                  }\n+\n+                _S_bin[bin].last[0]->next = NULL;\n+\n+                __gthread_mutex_unlock(_S_bin[bin].mutex);\n+              }\n+\n+            /*\n+             * Did we allocate this block?\n+             * - Yes, return it to our freelist\n+             * - No, return it to global pool\n+             */\n+            if (thread_id == block->thread_id)\n+              {\n+                if (_S_bin[bin].first[thread_id] == NULL)\n+                  _S_bin[bin].first[thread_id] = block;\n+                else\n+                  _S_bin[bin].last[thread_id]->next = block;\n+\n+                _S_bin[bin].last[thread_id] = block;\n+\n+                _S_bin[bin].free[thread_id]++;\n+                _S_bin[bin].used[thread_id]--;\n+              }\n+            else\n+              {\n+                __gthread_mutex_lock(_S_bin[bin].mutex);\n+\n+                if (_S_bin[bin].first[0] == NULL)\n+                  _S_bin[bin].first[0] = block;\n+                else\n+                  _S_bin[bin].last[0]->next = block;\n+\n+                _S_bin[bin].last[0] = block;\n+\n+                _S_bin[bin].free[0]++;\n+                _S_bin[bin].used[block->thread_id]--;\n+\n+                __gthread_mutex_unlock(_S_bin[bin].mutex);\n+              }\n+          }\n+        else\n+#endif\n+          {\n+            /*\n+             * Single threaded application - return to global pool\n+             */\n+            if (_S_bin[bin].first[0] == NULL)\n+              _S_bin[bin].first[0] = block;\n+            else\n+              _S_bin[bin].last[0]->next = block;\n+\n+            _S_bin[bin].last[0] = block;\n+\n+            _S_bin[bin].free[0]++;\n+            _S_bin[bin].used[0]--;\n+          }\n+      }\n+    };\n+\n+  template<int __inst>\n+    void\n+    __mt_alloc<__inst>::\n+    _S_init()\n+    {\n+      /*\n+       * Calculate the number of bins required based on _S_max_bytes,\n+       * _S_no_of_bins is initialized to 1 below.\n+       */\n+      {\n+        size_t bin_t = 1;\n+        while (_S_max_bytes > bin_t)\n+          {\n+            bin_t = bin_t << 1;\n+            _S_no_of_bins++;\n+          }\n+      }\n+\n+      /*\n+       * Setup the bin map for quick lookup of the relevant bin\n+       */\n+      _S_binmap = (binmap_type*)\n+        malloc ((_S_max_bytes + 1) * sizeof(binmap_type));\n+\n+      if (!_S_binmap) \n+        __throw_bad_alloc();\n+\n+      binmap_type* bp_t = _S_binmap;\n+      binmap_type bin_max_t = 1;\n+      binmap_type bin_t = 0;\n+      for (binmap_type ct = 0; ct <= _S_max_bytes; ct++)\n+        {\n+          if (ct > bin_max_t)\n+            {\n+              bin_max_t <<= 1;\n+              bin_t++;\n+            }\n+          *bp_t++ = bin_t;\n+        }\n+\n+      /*\n+       * If __gthread_active_p() create and initialize the list of\n+       * free thread ids. Single threaded applications use thread id 0\n+       * directly and have no need for this.\n+       */\n+#ifdef __GTHREADS\n+      if (__gthread_active_p())\n+        {\n+          _S_thread_freelist_first = \n+            (thread_record*)malloc(sizeof(thread_record) * _S_max_threads);\n+\n+          if (!_S_thread_freelist_first) \n+            __throw_bad_alloc();\n+\n+          /*\n+           * NOTE! The first assignable thread id is 1 since the global \n+           * pool uses id 0\n+           */\n+          size_t i;\n+          for (i = 1; i < _S_max_threads; i++)\n+            {\n+              _S_thread_freelist_first[i - 1].next = \n+                &_S_thread_freelist_first[i];\n+\n+              _S_thread_freelist_first[i - 1].id = i;\n+            }\n+\n+          /*\n+           * Set last record and pointer to this\n+           */\n+          _S_thread_freelist_first[i - 1].next = NULL;\n+          _S_thread_freelist_first[i - 1].id = i;\n+          _S_thread_freelist_last = &_S_thread_freelist_first[i - 1];\n+\n+          /*\n+           * Initialize per thread key to hold pointer to\n+           * _S_thread_freelist NOTE! Here's an ugly workaround - if\n+           * _S_thread_key_destr is not explicitly called at least\n+           * once it won't be linked into the application. This is the\n+           * behavior of template methods and __gthread_key_create()\n+           * takes only a pointer to the function and does not cause\n+           * the compiler to create an instance.\n+           */\n+          _S_thread_key_destr(NULL);\n+          __gthread_key_create(&_S_thread_key, _S_thread_key_destr);\n+        }\n+#endif\n+\n+      /*\n+       * Initialize _S_bin and its members\n+       */\n+      _S_bin = (bin_record*)malloc(sizeof(bin_record) * _S_no_of_bins);\n+\n+      if (!_S_bin) \n+        __throw_bad_alloc();\n+\n+      for (size_t bin = 0; bin < _S_no_of_bins; bin++)\n+        {\n+          _S_bin[bin].first = (block_record**)\n+            malloc(sizeof(block_record*) * (_S_max_threads + 1));\n+\n+          if (!_S_bin[bin].first) \n+            __throw_bad_alloc();\n+\n+          _S_bin[bin].last = (block_record**)\n+            malloc(sizeof(block_record*) * (_S_max_threads + 1));\n+\n+          if (!_S_bin[bin].last) \n+            __throw_bad_alloc();\n+\n+          _S_bin[bin].free = (size_t*)\n+            malloc(sizeof(size_t) * (_S_max_threads + 1));\n+\n+          if (!_S_bin[bin].free) \n+            __throw_bad_alloc();\n+\n+          _S_bin[bin].used = (size_t*)\n+            malloc(sizeof(size_t) * (_S_max_threads + 1));\n+\n+          if (!_S_bin[bin].used) \n+            __throw_bad_alloc();\n+\n+          /*\n+           * Ugly workaround of what at the time of writing seems to be\n+           * a parser problem - see PR c++/9779 for more info.\n+           */\n+#ifdef __GTHREADS\n+          size_t s = sizeof(__gthread_mutex_t); \n+          _S_bin[bin].mutex = (__gthread_mutex_t*)malloc(s);\n+\n+          if (!_S_bin[bin].mutex) \n+            __throw_bad_alloc();\n+\n+          /*\n+           * This is not only ugly - it's extremly non-portable!\n+           * However gthr.h does not currently provide a\n+           * __gthread_mutex_init() call. The correct solution to\n+           * this problem needs to be discussed.\n+           */\n+          pthread_mutex_init(_S_bin[bin].mutex, NULL);\n+#endif\n+\n+          for (size_t thread = 0; thread <= _S_max_threads; thread++)\n+            {\n+              _S_bin[bin].first[thread] = NULL;\n+              _S_bin[bin].last[thread] = NULL;\n+              _S_bin[bin].free[thread] = 0;\n+              _S_bin[bin].used[thread] = 0;\n+            }\n+        }\n+\n+        _S_initialized = true;\n+    }\n+\n+#ifdef __GTHREADS\n+  template<int __inst>\n+    void\n+    __mt_alloc<__inst>::\n+    _S_thread_key_destr(void* freelist_pos)\n+    {\n+      /*\n+       * This is due to the ugly workaround mentioned in _S_init()\n+       */\n+      if (freelist_pos == NULL)\n+        return;\n+\n+      /*\n+       * If the thread - when it dies - still have records on its\n+       * freelist we return them to the global pool here.\n+       */\n+      for (size_t bin = 0; bin < _S_no_of_bins; bin++)\n+        {\n+          block_record* block = \n+            _S_bin[bin].first[((thread_record*)freelist_pos)->id];\n+\n+          if (block != NULL)\n+            {\n+              __gthread_mutex_lock(_S_bin[bin].mutex);\n+\n+              while (block != NULL)\n+                {\n+                  if (_S_bin[bin].first[0] == NULL)\n+                    _S_bin[bin].first[0] = block;\n+                  else\n+                    _S_bin[bin].last[0]->next = block;\n+\n+                  _S_bin[bin].last[0] = block;\n+\n+                  block = block->next;\n+\n+                  _S_bin[bin].free[0]++;\n+                }\n+\n+              _S_bin[bin].last[0]->next = NULL;\n+\n+              __gthread_mutex_unlock(_S_bin[bin].mutex);\n+            }\n+        }\n+\n+      /*\n+       * Return this thread id record to thread_freelist\n+       */\n+      __gthread_mutex_lock(&_S_thread_freelist_mutex);\n+\n+      _S_thread_freelist_last->next = (thread_record*)freelist_pos;\n+      _S_thread_freelist_last = (thread_record*)freelist_pos;\n+      _S_thread_freelist_last->next = NULL;\n+\n+      __gthread_mutex_unlock(&_S_thread_freelist_mutex);\n+\n+    }\n+\n+  template<int __inst>\n+    size_t\n+    __mt_alloc<__inst>::\n+    _S_get_thread_id()\n+    {\n+      /*\n+       * If we have thread support and it's active we check the thread\n+       * key value and return it's id or if it's not set we take the\n+       * first record from _S_thread_freelist and sets the key and\n+       * returns it's id.\n+       */\n+      if (__gthread_active_p())\n+        {\n+          thread_record* freelist_pos;\n+\n+          if ((freelist_pos = \n+              (thread_record*)__gthread_getspecific(_S_thread_key)) == NULL)\n+            {\n+              __gthread_mutex_lock(&_S_thread_freelist_mutex);\n+\n+              /*\n+               * Since _S_max_threads must be larger than the\n+               * theoretical max number of threads of the OS the list\n+               * can never be empty.\n+               */\n+              freelist_pos = _S_thread_freelist_first;\n+              _S_thread_freelist_first = _S_thread_freelist_first->next;\n+\n+              __gthread_mutex_unlock(&_S_thread_freelist_mutex);\n+\n+              __gthread_setspecific(_S_thread_key, (void*)freelist_pos);\n+\n+              /*\n+               * Since thread_ids may/will be reused (espcially in\n+               * producer/consumer applications) we make sure that the\n+               * list pointers and free counter is reset BUT as the\n+               * \"old\" thread may still be owner of some memory (which\n+               * is referred to by other threads and thus not freed)\n+               * we don't reset the used counter.\n+               */\n+              for (size_t bin = 0; bin < _S_no_of_bins; bin++)\n+                {\n+                  _S_bin[bin].first[freelist_pos->id] = NULL;\n+                  _S_bin[bin].last[freelist_pos->id] = NULL;\n+                  _S_bin[bin].free[freelist_pos->id] = 0;\n+                }\n+            } \n+\n+          return freelist_pos->id;\n+        }\n+\n+      /*\n+       * Otherwise (no thread support or inactive) all requests are\n+       * served from the global pool 0.\n+       */\n+      return 0;\n+    }\n+\n+  template<int __inst> __gthread_once_t\n+  __mt_alloc<__inst>::_S_once_mt = __GTHREAD_ONCE_INIT;\n+#endif\n+\n+  template<int __inst> bool\n+  __mt_alloc<__inst>::_S_initialized = false;\n+\n+  template<int __inst> typename __mt_alloc<__inst>::binmap_type*\n+  __mt_alloc<__inst>::_S_binmap = NULL;\n+\n+  /*\n+   * Allocation requests (after round-up to power of 2) below this\n+   * value will be handled by the allocator. A raw malloc/free() call\n+   * will be used for requests larger than this value.\n+   */\n+  template<int __inst> size_t\n+  __mt_alloc<__inst>::_S_max_bytes = 128;\n+\n+  /*\n+   * In order to avoid fragmenting and minimize the number of malloc()\n+   * calls we always request new memory using this value. Based on\n+   * previous discussions on the libstdc++ mailing list we have\n+   * choosen the value below. See\n+   * http://gcc.gnu.org/ml/libstdc++/2001-07/msg00077.html\n+   */\n+  template<int __inst> size_t\n+  __mt_alloc<__inst>::_S_chunk_size = 4096 - 4 * sizeof(void*);\n+\n+  /*\n+   * The maximum number of supported threads. Our Linux 2.4.18 reports\n+   * 4070 in /proc/sys/kernel/threads-max\n+   */\n+  template<int __inst> size_t\n+  __mt_alloc<__inst>::_S_max_threads = 4096;\n+\n+  /*\n+   * Actual value calculated in _S_init()\n+   */\n+  template<int __inst> size_t\n+  __mt_alloc<__inst>::_S_no_of_bins = 1;\n+\n+  /*\n+   * Each time a deallocation occurs in a threaded application we make\n+   * sure that there are no more than _S_freelist_headroom % of used\n+   * memory on the freelist. If the number of additional records is\n+   * more than _S_freelist_headroom % of the freelist, we move these\n+   * records back to the global pool.\n+   */\n+  template<int __inst> size_t\n+  __mt_alloc<__inst>::_S_freelist_headroom = 10;\n+\n+  /*\n+   * Actual initialization in _S_init()\n+   */\n+#ifdef __GTHREADS\n+  template<int __inst> typename __mt_alloc<__inst>::thread_record*\n+  __mt_alloc<__inst>::_S_thread_freelist_first = NULL;\n+\n+  template<int __inst> typename __mt_alloc<__inst>::thread_record*\n+  __mt_alloc<__inst>::_S_thread_freelist_last = NULL;\n+\n+  template<int __inst> __gthread_mutex_t\n+  __mt_alloc<__inst>::_S_thread_freelist_mutex = __GTHREAD_MUTEX_INIT;\n+\n+  /*\n+   * Actual initialization in _S_init()\n+   */\n+  template<int __inst> __gthread_key_t\n+  __mt_alloc<__inst>::_S_thread_key;\n+#endif\n+\n+  template<int __inst> typename __mt_alloc<__inst>::bin_record*\n+  __mt_alloc<__inst>::_S_bin = NULL;\n+\n+  template<int __inst>\n+    inline bool\n+    operator==(const __mt_alloc<__inst>&, const __mt_alloc<__inst>&)\n+    { return true; }\n+\n+  template<int __inst>\n+    inline bool\n+    operator!=(const __mt_alloc<__inst>&, const __mt_alloc<__inst>&)\n+    { return false; }\n+} // namespace __gnu_cxx\n+\n+namespace std\n+{\n+  template<typename _Tp, int __inst>\n+    struct _Alloc_traits<_Tp, __gnu_cxx::__mt_alloc<__inst> >\n+    {\n+      static const bool _S_instanceless = true;\n+      typedef __gnu_cxx:: __mt_alloc<__inst>\t\tbase_alloc_type;\n+      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n+      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n+    };\n+\n+  template<typename _Tp, typename _Tp1, int __inst>\n+    struct _Alloc_traits<_Tp, \n+                         __allocator<_Tp1, __gnu_cxx::__mt_alloc<__inst> > >\n+    {\n+      static const bool _S_instanceless = true;\n+      typedef __gnu_cxx:: __mt_alloc<__inst>\t\tbase_alloc_type;\n+      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n+      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n+    };\n+} // namespace std\n+\n+#endif\n+"}, {"sha": "794751d3c13ef0aca9610c82909386ed911decc2", "filename": "libstdc++-v3/include/ext/new_allocator.h", "status": "renamed", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fnew_allocator.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -1,6 +1,6 @@\n-// Wrapper of pthread allocation header -*- C++ -*-\n+// Allocators -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -27,34 +27,32 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-/*\n- * Copyright (c) 1996-1997\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-/** @file stl_pthread_alloc.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#ifndef _CPP_BITS_STL_PTHREAD_ALLOC_H\n-#define _CPP_BITS_STL_PTHREAD_ALLOC_H 1\n-\n-#include <bits/pthread_allocimpl.h>\n-\n-using std::_Pthread_alloc_template;\n-using std::pthread_alloc;\n-\n-#endif /* _CPP_BITS_STL_PTHREAD_ALLOC_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:\n+#ifndef _NEW_ALLOCATOR_H\n+#define _NEW_ALLOCATOR_H 1\n+\n+#include <new>\n+\n+namespace __gnu_cxx\n+{\n+  /**\n+   *  @if maint\n+   *  A new-based allocator, as required by the standard.  Allocation and\n+   *  deallocation forward to global new and delete.  \"SGI\" style, minus\n+   *  reallocate().\n+   *  @endif\n+   *  (See @link Allocators allocators info @endlink for more.)\n+   */\n+  class __new_alloc\n+  {\n+  public:\n+    static void*\n+    allocate(size_t __n)\n+    { return ::operator new(__n); }\n+\n+    static void\n+    deallocate(void* __p, size_t)\n+    { ::operator delete(__p); }\n+  };\n+} // namespace __gnu_cxx\n+\n+#endif", "previous_filename": "libstdc++-v3/include/bits/stl_pthread_alloc.h"}, {"sha": "77d354faabb5ded9cdb4671f718d0da285f347fa", "filename": "libstdc++-v3/include/ext/pool_allocator.h", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -0,0 +1,383 @@\n+// Allocators -*- C++ -*-\n+\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ * Copyright (c) 1996-1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+/** @file ext/debug_allocator.h\n+ *  This file is a GNU extension to the Standard C++ Library. \n+ *  You should only include this header if you are using GCC 3 or later.\n+ */\n+\n+#ifndef _POOL_ALLOCATOR_H\n+#define _POOL_ALLOCATOR_H 1\n+\n+#include <bits/functexcept.h> \n+#include <bits/stl_threads.h>\n+#include <bits/atomicity.h>\n+#include <bits/allocator_traits.h>\n+#include <ext/new_allocator.h>\n+\n+namespace __gnu_cxx\n+{\n+  using std::_STL_mutex_lock;\n+  using std::__throw_bad_alloc;\n+\n+  /**\n+   *  @if maint\n+   *  Default node allocator.  \"SGI\" style.  Uses various allocators to\n+   *  fulfill underlying requests (and makes as few requests as possible\n+   *  when in default high-speed pool mode).\n+   *\n+   *  Important implementation properties:\n+   *  0. If globally mandated, then allocate objects from __new_alloc\n+   *  1. If the clients request an object of size > _S_max_bytes, the resulting\n+   *     object will be obtained directly from __new_alloc\n+   *  2. In all other cases, we allocate an object of size exactly\n+   *     _S_round_up(requested_size).  Thus the client has enough size\n+   *     information that we can return the object to the proper free list\n+   *     without permanently losing part of the object.\n+   *\n+   *  The first template parameter specifies whether more than one thread may\n+   *  use this allocator.  It is safe to allocate an object from one instance\n+   *  of a default_alloc and deallocate it with another one.  This effectively\n+   *  transfers its ownership to the second one.  This may have undesirable\n+   *  effects on reference locality.\n+   *\n+   *  The second parameter is unused and serves only to allow the creation of\n+   *  multiple default_alloc instances.  Note that containers built on different\n+   *  allocator instances have different types, limiting the utility of this\n+   *  approach.  If you do not wish to share the free lists with the main\n+   *  default_alloc instance, instantiate this with a non-zero __inst.\n+   *\n+   *  @endif\n+   *  (See @link Allocators allocators info @endlink for more.)\n+   */\n+  template<bool __threads, int __inst>\n+    class __pool_alloc\n+    {\n+    private:\n+      enum {_S_align = 8};\n+      enum {_S_max_bytes = 128};\n+      enum {_S_freelists = _S_max_bytes / _S_align};\n+\n+      union _Obj\n+      {\n+        union _Obj* _M_free_list_link;\n+        char        _M_client_data[1];    // The client sees this.\n+      };\n+\n+      static _Obj* volatile         _S_free_list[_S_freelists];\n+\n+      // Chunk allocation state.\n+      static char*                  _S_start_free;\n+      static char*                  _S_end_free;\n+      static size_t                 _S_heap_size;\n+\n+      static _STL_mutex_lock        _S_lock;\n+      static _Atomic_word \t    _S_force_new;\n+\n+      static size_t\n+      _S_round_up(size_t __bytes)\n+      { return ((__bytes + (size_t)_S_align - 1) & ~((size_t)_S_align - 1)); }\n+\n+      static size_t\n+      _S_freelist_index(size_t __bytes)\n+      { return ((__bytes + (size_t)_S_align - 1)/(size_t)_S_align - 1); }\n+\n+      // Returns an object of size __n, and optionally adds to size __n\n+      // free list.\n+      static void*\n+      _S_refill(size_t __n);\n+\n+      // Allocates a chunk for nobjs of size size.  nobjs may be reduced\n+      // if it is inconvenient to allocate the requested number.\n+      static char*\n+      _S_chunk_alloc(size_t __size, int& __nobjs);\n+\n+      // It would be nice to use _STL_auto_lock here.  But we need a\n+      // test whether threads are in use.\n+      struct _Lock\n+      {\n+        _Lock() { if (__threads) _S_lock._M_acquire_lock(); }\n+        ~_Lock() { if (__threads) _S_lock._M_release_lock(); }\n+      } __attribute__ ((__unused__));\n+      friend struct _Lock;\n+\n+    public:\n+      // __n must be > 0\n+      static void*\n+      allocate(size_t __n)\n+      {\n+\tvoid* __ret = 0;\n+\n+\t// If there is a race through here, assume answer from getenv\n+\t// will resolve in same direction.  Inspired by techniques\n+\t// to efficiently support threading found in basic_string.h.\n+\tif (_S_force_new == 0)\n+\t  {\n+\t    if (getenv(\"GLIBCPP_FORCE_NEW\"))\n+\t      __atomic_add(&_S_force_new, 1);\n+\t    else\n+\t      __atomic_add(&_S_force_new, -1);\n+\t  }\n+\n+\tif ((__n > (size_t) _S_max_bytes) || (_S_force_new > 0))\n+\t  __ret = __new_alloc::allocate(__n);\n+\telse\n+\t  {\n+\t    _Obj* volatile* __my_free_list = _S_free_list\n+\t      + _S_freelist_index(__n);\n+\t    // Acquire the lock here with a constructor call.  This\n+\t    // ensures that it is released in exit or during stack\n+\t    // unwinding.\n+\t    _Lock __lock_instance;\n+\t    _Obj* __restrict__ __result = *__my_free_list;\n+\t    if (__builtin_expect(__result == 0, 0))\n+\t      __ret = _S_refill(_S_round_up(__n));\n+\t    else\n+\t      {\n+\t\t*__my_free_list = __result -> _M_free_list_link;\n+\t\t__ret = __result;\n+\t      }\t    \n+\t    if (__builtin_expect(__ret == 0, 0))\n+\t      __throw_bad_alloc();\n+\t  }\n+\treturn __ret;\n+      }\n+\n+      // __p may not be 0\n+      static void\n+      deallocate(void* __p, size_t __n)\n+      {\n+\tif ((__n > (size_t) _S_max_bytes) || (_S_force_new > 0))\n+\t  __new_alloc::deallocate(__p, __n);\n+\telse\n+\t  {\n+\t    _Obj* volatile*  __my_free_list = _S_free_list\n+\t      + _S_freelist_index(__n);\n+\t    _Obj* __q = (_Obj*)__p;\n+\n+\t    // Acquire the lock here with a constructor call.  This\n+\t    // ensures that it is released in exit or during stack\n+\t    // unwinding.\n+\t    _Lock __lock_instance;\n+\t    __q -> _M_free_list_link = *__my_free_list;\n+\t    *__my_free_list = __q;\n+\t  }\n+      }\n+    };\n+\n+  template<bool __threads, int __inst> _Atomic_word\n+  __pool_alloc<__threads, __inst>::_S_force_new = 0;\n+\n+  template<bool __threads, int __inst>\n+    inline bool\n+    operator==(const __pool_alloc<__threads,__inst>&, \n+\t       const __pool_alloc<__threads,__inst>&)\n+    { return true; }\n+\n+  template<bool __threads, int __inst>\n+    inline bool\n+    operator!=(const __pool_alloc<__threads,__inst>&,\n+               const __pool_alloc<__threads,__inst>&)\n+    { return false; }\n+\n+\n+  // We allocate memory in large chunks in order to avoid fragmenting the\n+  // heap too much.  We assume that __size is properly aligned.  We hold\n+  // the allocation lock.\n+  template<bool __threads, int __inst>\n+    char*\n+    __pool_alloc<__threads, __inst>::\n+    _S_chunk_alloc(size_t __size, int& __nobjs)\n+    {\n+      char* __result;\n+      size_t __total_bytes = __size * __nobjs;\n+      size_t __bytes_left = _S_end_free - _S_start_free;\n+\n+      if (__bytes_left >= __total_bytes)\n+        {\n+          __result = _S_start_free;\n+          _S_start_free += __total_bytes;\n+          return __result ;\n+        }\n+      else if (__bytes_left >= __size)\n+        {\n+          __nobjs = (int)(__bytes_left/__size);\n+          __total_bytes = __size * __nobjs;\n+          __result = _S_start_free;\n+          _S_start_free += __total_bytes;\n+          return __result;\n+        }\n+      else\n+        {\n+          size_t __bytes_to_get =\n+            2 * __total_bytes + _S_round_up(_S_heap_size >> 4);\n+          // Try to make use of the left-over piece.\n+          if (__bytes_left > 0)\n+            {\n+              _Obj* volatile* __my_free_list =\n+                _S_free_list + _S_freelist_index(__bytes_left);\n+\n+              ((_Obj*)(void*)_S_start_free) -> _M_free_list_link = *__my_free_list;\n+              *__my_free_list = (_Obj*)(void*)_S_start_free;\n+            }\n+          _S_start_free = (char*) __new_alloc::allocate(__bytes_to_get);\n+          if (_S_start_free == 0)\n+            {\n+              size_t __i;\n+              _Obj* volatile* __my_free_list;\n+              _Obj* __p;\n+              // Try to make do with what we have.  That can't hurt.  We\n+              // do not try smaller requests, since that tends to result\n+              // in disaster on multi-process machines.\n+              __i = __size;\n+              for (; __i <= (size_t) _S_max_bytes; __i += (size_t) _S_align)\n+                {\n+                  __my_free_list = _S_free_list + _S_freelist_index(__i);\n+                  __p = *__my_free_list;\n+                  if (__p != 0)\n+                    {\n+                      *__my_free_list = __p -> _M_free_list_link;\n+                      _S_start_free = (char*)__p;\n+                      _S_end_free = _S_start_free + __i;\n+                      return _S_chunk_alloc(__size, __nobjs);\n+                      // Any leftover piece will eventually make it to the\n+                      // right free list.\n+                    }\n+                }\n+              _S_end_free = 0;        // In case of exception.\n+              _S_start_free = (char*)__new_alloc::allocate(__bytes_to_get);\n+              // This should either throw an exception or remedy the situation.\n+              // Thus we assume it succeeded.\n+            }\n+          _S_heap_size += __bytes_to_get;\n+          _S_end_free = _S_start_free + __bytes_to_get;\n+          return _S_chunk_alloc(__size, __nobjs);\n+        }\n+    }\n+\n+\n+  // Returns an object of size __n, and optionally adds to \"size\n+  // __n\"'s free list.  We assume that __n is properly aligned.  We\n+  // hold the allocation lock.\n+  template<bool __threads, int __inst>\n+    void*\n+    __pool_alloc<__threads, __inst>::_S_refill(size_t __n)\n+    {\n+      int __nobjs = 20;\n+      char* __chunk = _S_chunk_alloc(__n, __nobjs);\n+      _Obj* volatile* __my_free_list;\n+      _Obj* __result;\n+      _Obj* __current_obj;\n+      _Obj* __next_obj;\n+      int __i;\n+\n+      if (1 == __nobjs)\n+        return __chunk;\n+      __my_free_list = _S_free_list + _S_freelist_index(__n);\n+\n+      // Build free list in chunk.\n+      __result = (_Obj*)(void*)__chunk;\n+      *__my_free_list = __next_obj = (_Obj*)(void*)(__chunk + __n);\n+      for (__i = 1; ; __i++)\n+        {\n+\t  __current_obj = __next_obj;\n+          __next_obj = (_Obj*)(void*)((char*)__next_obj + __n);\n+\t  if (__nobjs - 1 == __i)\n+\t    {\n+\t      __current_obj -> _M_free_list_link = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    __current_obj -> _M_free_list_link = __next_obj;\n+\t}\n+      return __result;\n+    }\n+\n+\n+  template<bool __threads, int __inst>\n+    _STL_mutex_lock\n+    __pool_alloc<__threads, __inst>::_S_lock __STL_MUTEX_INITIALIZER;\n+\n+  template<bool __threads, int __inst>\n+    char* __pool_alloc<__threads, __inst>::_S_start_free = 0;\n+\n+  template<bool __threads, int __inst>\n+    char* __pool_alloc<__threads, __inst>::_S_end_free = 0;\n+\n+  template<bool __threads, int __inst>\n+    size_t __pool_alloc<__threads, __inst>::_S_heap_size = 0;\n+\n+  template<bool __threads, int __inst>\n+    typename __pool_alloc<__threads, __inst>::_Obj* volatile\n+    __pool_alloc<__threads, __inst>::_S_free_list[_S_freelists];\n+} // namespace __gnu_cxx\n+\n+namespace std\n+{\n+  //@{\n+  /// Versions for the predefined \"SGI\" style allocators.\n+  template<typename _Tp, bool __thr, int __inst>\n+    struct _Alloc_traits<_Tp, __gnu_cxx::__pool_alloc<__thr, __inst> >\n+    {\n+      static const bool _S_instanceless = true;      \n+      typedef __gnu_cxx::__pool_alloc<__thr, __inst> \tbase_alloc_type;\n+      typedef __simple_alloc<_Tp, base_alloc_type>  \t_Alloc_type;\n+      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n+    };\n+  //@}\n+\n+  //@{\n+  /// Versions for the __allocator adaptor used with the predefined\n+  /// \"SGI\" style allocators.\n+  template<typename _Tp, typename _Tp1, bool __thr, int __inst>\n+    struct _Alloc_traits<_Tp, __allocator<_Tp1, \n+\t\t\t\t     __gnu_cxx::__pool_alloc<__thr, __inst> > >\n+    {\n+      static const bool _S_instanceless = true;\n+      typedef __gnu_cxx::__pool_alloc<__thr, __inst> \tbase_alloc_type;\n+      typedef __simple_alloc<_Tp, base_alloc_type>\t_Alloc_type;\n+      typedef __allocator<_Tp, base_alloc_type>\t\tallocator_type;\n+    };\n+  //@}\n+} // namespace std\n+\n+#endif"}, {"sha": "9ba261845b35738a78e27dcba0330d2e3cbd3f74", "filename": "libstdc++-v3/include/ext/rope", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frope?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -53,7 +53,7 @@\n #include <bits/stl_algo.h>\n #include <bits/stl_function.h>\n #include <bits/stl_numeric.h>\n-#include <bits/stl_alloc.h>\n+#include <bits/allocator.h>\n #include <bits/stl_construct.h>\n #include <bits/stl_uninitialized.h>\n #include <ext/hash_fun.h>"}, {"sha": "875f7604de57a5f85e6463f3446b2b08af5658e3", "filename": "libstdc++-v3/include/ext/slist", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -51,7 +51,7 @@\n #define _SLIST 1\n \n #include <bits/stl_algobase.h>\n-#include <bits/stl_alloc.h>\n+#include <bits/allocator.h>\n #include <bits/stl_construct.h>\n #include <bits/stl_uninitialized.h>\n #include <bits/concept_check.h>"}, {"sha": "774d334e8d7149e5e546a6b5318cfaa9439b6f54", "filename": "libstdc++-v3/include/std/std_deque.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_deque.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -65,7 +65,7 @@\n \n #include <bits/functexcept.h>\n #include <bits/stl_algobase.h>\n-#include <bits/stl_alloc.h>\n+#include <bits/allocator.h>\n #include <bits/stl_construct.h>\n #include <bits/stl_uninitialized.h>\n #include <bits/stl_deque.h>"}, {"sha": "61c6dfa88eb10b091010cd7e7e47d672997f8fd2", "filename": "libstdc++-v3/include/std/std_list.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_list.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -65,7 +65,7 @@\n \n #include <bits/functexcept.h>\n #include <bits/stl_algobase.h>\n-#include <bits/stl_alloc.h>\n+#include <bits/allocator.h>\n #include <bits/stl_construct.h>\n #include <bits/stl_uninitialized.h>\n #include <bits/stl_list.h>"}, {"sha": "b508351c8b5bbb9c6d007a76588f7b692a3e193c", "filename": "libstdc++-v3/include/std/std_memory.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_memory.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -52,7 +52,7 @@\n #pragma GCC system_header\n \n #include <bits/stl_algobase.h>\n-#include <bits/stl_alloc.h>\n+#include <bits/allocator.h>\n #include <bits/stl_construct.h>\n #include <bits/stl_iterator_base_types.h> //for iterator_traits\n #include <bits/stl_uninitialized.h>"}, {"sha": "33eb944972714da4b0dd34c3dadaff030bddbd58", "filename": "libstdc++-v3/include/std/std_queue.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_queue.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -65,7 +65,7 @@\n #include <bits/c++config.h>\n #include <bits/functexcept.h>\n #include <bits/stl_algobase.h>\n-#include <bits/stl_alloc.h>\n+#include <bits/allocator.h>\n #include <bits/stl_construct.h>\n #include <bits/stl_uninitialized.h>\n #include <bits/stl_vector.h>"}, {"sha": "fb111d4d4df89bc0dc010aaead7c931f6fc39f4a", "filename": "libstdc++-v3/include/std/std_stack.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_stack.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -64,7 +64,7 @@\n #pragma GCC system_header\n \n #include <bits/stl_algobase.h>\n-#include <bits/stl_alloc.h>\n+#include <bits/allocator.h>\n #include <bits/stl_construct.h>\n #include <bits/stl_uninitialized.h>\n #include <bits/stl_deque.h>"}, {"sha": "5f700495b4c39458d4706a55c284c13b5cc9291b", "filename": "libstdc++-v3/include/std/std_vector.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_vector.h?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -65,7 +65,7 @@\n \n #include <bits/functexcept.h>\n #include <bits/stl_algobase.h>\n-#include <bits/stl_alloc.h>\n+#include <bits/allocator.h>\n #include <bits/stl_construct.h>\n #include <bits/stl_uninitialized.h>\n #include <bits/stl_vector.h>"}, {"sha": "6876e288925aa344fc4415e142d487fa59ef8ee7", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -117,6 +117,7 @@ basic_file.cc: ${glibcpp_srcdir}/@BASIC_FILE_CC@\n \n # Sources present in the src directory.\n sources = \\\n+\tallocator-inst.cc \\\n \tcodecvt.cc \\\n \tcomplex_io.cc \\\n \tconcept-inst.cc \\\n@@ -137,7 +138,6 @@ sources = \\\n \tostream-inst.cc \\\n \tsstream-inst.cc \\\n \tstdexcept.cc \\\n-\tstl-inst.cc \\\n \tstreambuf-inst.cc \\\n \tstring-inst.cc \\\n \tstrstream.cc \\"}, {"sha": "5662b6c502fda872f16f5c5a22eee0a00c5e2e96", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -121,6 +121,7 @@ enable_shared = @enable_shared@\n enable_static = @enable_static@\n glibcpp_CXX = @glibcpp_CXX@\n glibcpp_MOFILES = @glibcpp_MOFILES@\n+glibcpp_PCHFLAGS = @glibcpp_PCHFLAGS@\n glibcpp_POFILES = @glibcpp_POFILES@\n glibcpp_basedir = @glibcpp_basedir@\n glibcpp_localedir = @glibcpp_localedir@\n@@ -199,6 +200,7 @@ target_sources_extra = \\\n \n # Sources present in the src directory.\n sources = \\\n+\tallocator-inst.cc \\\n \tcodecvt.cc \\\n \tcomplex_io.cc \\\n \tconcept-inst.cc \\\n@@ -219,7 +221,6 @@ sources = \\\n \tostream-inst.cc \\\n \tsstream-inst.cc \\\n \tstdexcept.cc \\\n-\tstl-inst.cc \\\n \tstreambuf-inst.cc \\\n \tstring-inst.cc \\\n \tstrstream.cc \\\n@@ -304,15 +305,15 @@ DEFS = @DEFS@ -I. -I$(srcdir) -I..\n CPPFLAGS = @CPPFLAGS@\n LDFLAGS = @LDFLAGS@\n LIBS = @LIBS@\n-libstdc___la_OBJECTS =  codecvt.lo complex_io.lo concept-inst.lo \\\n-ctype.lo demangle.lo ext-inst.lo fstream-inst.lo functexcept.lo \\\n-globals.lo io-inst.lo ios.lo istream-inst.lo limits.lo locale.lo \\\n-locale-inst.lo localename.lo misc-inst.lo ostream-inst.lo \\\n-sstream-inst.lo stdexcept.lo stl-inst.lo streambuf-inst.lo \\\n-string-inst.lo strstream.lo valarray-inst.lo wstring-inst.lo \\\n-codecvt_members.lo collate_members.lo ctype_members.lo \\\n-messages_members.lo monetary_members.lo numeric_members.lo \\\n-time_members.lo basic_file.lo c++locale.lo\n+libstdc___la_OBJECTS =  allocator-inst.lo codecvt.lo complex_io.lo \\\n+concept-inst.lo ctype.lo demangle.lo ext-inst.lo fstream-inst.lo \\\n+functexcept.lo globals.lo io-inst.lo ios.lo istream-inst.lo limits.lo \\\n+locale.lo locale-inst.lo localename.lo misc-inst.lo ostream-inst.lo \\\n+sstream-inst.lo stdexcept.lo streambuf-inst.lo string-inst.lo \\\n+strstream.lo valarray-inst.lo wstring-inst.lo codecvt_members.lo \\\n+collate_members.lo ctype_members.lo messages_members.lo \\\n+monetary_members.lo numeric_members.lo time_members.lo basic_file.lo \\\n+c++locale.lo\n CXXFLAGS = @CXXFLAGS@\n CXXCOMPILE = $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n CXXLD = $(CXX)"}, {"sha": "da8aeda2452d2961afe2918a729b58e41f3bbc45", "filename": "libstdc++-v3/src/allocator-inst.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Fsrc%2Fallocator-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Fsrc%2Fallocator-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fallocator-inst.cc?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -0,0 +1,41 @@\n+// Explicit instantiation file.\n+\n+// Copyright (C) 1999, 2001, 2002, 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882:\n+//\n+\n+#include <bits/c++config.h>\n+#include <memory>\n+\n+namespace std\n+{\n+  template class allocator<char>;\n+  template class allocator<wchar_t>;\n+} // namespace std"}, {"sha": "34188c47328a07b3658b4603bade80f9f1545ed6", "filename": "libstdc++-v3/testsuite/ext/allocators.cc", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fallocators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fallocators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fallocators.cc?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -1,6 +1,6 @@\n // 2001-11-25  Phil Edwards  <pme@gcc.gnu.org>\n //\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -20,27 +20,25 @@\n \n // 20.4.1.1 allocator members\n \n-#include <memory>\n #include <cstdlib>\n+#include <memory>\n+#include <ext/pool_allocator.h>\n+#include <ext/debug_allocator.h>\n+#include <ext/malloc_allocator.h>\n #include <testsuite_hooks.h>\n \n-typedef std::__malloc_alloc<3>             weird_alloc;\n-template class std::__malloc_alloc<3>;\n-\n-typedef std::__debug_alloc<weird_alloc>             debug_weird_alloc;\n-template class std::__debug_alloc<weird_alloc>;\n-\n-typedef std::__pool_alloc<true, 3>      unshared_normal_alloc;\n-template class std::__pool_alloc<true, 3>;\n-\n-typedef std::__pool_alloc<false, 3>     unshared_singlethreaded;\n-template class std::__pool_alloc<false, 3>;\n+using __gnu_cxx::__malloc_alloc;\n+using __gnu_cxx::__debug_alloc;\n+using __gnu_cxx::__pool_alloc;\n \n-//std::malloc_alloc test_malloc_alloc;\n+template class __malloc_alloc<3>;\n+template class __debug_alloc<__malloc_alloc<3> >;\n+template class __pool_alloc<true, 3>;\n+template class __pool_alloc<false, 3>;\n \n struct big\n {\n-    long f[15];\n+  long f[15];\n };\n \n \n@@ -63,40 +61,39 @@ operator delete(void *v) throw()\n   return std::free(v);\n }\n \n-\n-template <typename arbitrary_SGIstyle_allocator,\n-          bool uses_global_new_and_delete>\n-void test()\n+template<typename Alloc, bool uses_global_new_and_delete>\n+void check_allocator()\n {\n+  bool test = true;\n   new_called = false;\n   delete_called = false;\n   requested = 0;\n \n-  std::__allocator<big, arbitrary_SGIstyle_allocator>   a;\n+  std::__allocator<big, Alloc>   a;\n   big *p = a.allocate(10);\n-  if (uses_global_new_and_delete)  VERIFY (requested >= (10*15*sizeof(long)));\n+  if (uses_global_new_and_delete)  \n+    VERIFY( requested >= (10 * 15 * sizeof(long)) );\n+\n   // Touch the far end of supposedly-allocated memory to check that we got\n   // all of it.  Why \"3\"?  Because it's my favorite integer between e and pi.\n   p[9].f[14] = 3;\n-  VERIFY (new_called == uses_global_new_and_delete );\n+  VERIFY( new_called == uses_global_new_and_delete );\n   a.deallocate(p,10);\n-  VERIFY (delete_called == uses_global_new_and_delete );\n+  VERIFY( delete_called == uses_global_new_and_delete );\n }\n \n-\n // These just help tracking down error messages.\n-void test01() { test<weird_alloc,false>(); }\n-void test02() { test<debug_weird_alloc,false>(); }\n-void test03() { test<unshared_normal_alloc,true>(); }\n-void test04() { test<unshared_singlethreaded,true>(); }\n+void test01() { check_allocator<__malloc_alloc<3>, false>(); }\n+void test02() { check_allocator<__debug_alloc<__malloc_alloc<3> >, false>(); }\n+void test03() { check_allocator<__pool_alloc<true, 3>, true>(); }\n+void test04() { check_allocator<__pool_alloc<false, 3>, true>(); }\n \n int main()\n {\n   test01();\n   test02();\n   test03();\n   test04();\n-\n   return 0;\n }\n "}, {"sha": "52f6028bd123ff3257873ad83e412ce7b0421e7b", "filename": "libstdc++-v3/testsuite/ext/headers.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fheaders.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fheaders.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fheaders.cc?ref=1ff9402d8f9fb789b782c2cb2f6e6d8795ad2854", "patch": "@@ -1,6 +1,6 @@\n // 1999-06-23 bkoz \n \n-// Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2001, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -33,5 +33,11 @@\n #include <ext/rb_tree>\n #include <ext/rope>\n #include <ext/slist>\n+#include <ext/debug_allocator.h>\n+#include <ext/malloc_allocator.h>\n+#include <ext/mt_allocator.h>\n+#include <ext/pool_allocator.h>\n+#include <ext/stdio_filebuf.h>\n+#include <ext/stdio_sync_filebuf.h>\n \n int main() { }"}]}