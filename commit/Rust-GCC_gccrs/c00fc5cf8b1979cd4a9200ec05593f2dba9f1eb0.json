{"sha": "c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAwZmM1Y2Y4YjE5NzljZDRhOTIwMGVjMDU1OTNmMmRiYTlmMWViMA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2005-07-09T01:09:48Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2005-07-09T01:09:48Z"}, "message": "Rewrite PIC support to more closely model actual instructions.\n\n\t* config/cris/cris-protos.h (cris_gotless_symbol, cris_got_symbol)\n\t(cris_symbol): Remove prototypes for removed functions.\n\t(cris_pic_symbol_type_of, cris_valid_pic_const)\n\t(cris_expand_pic_call_address): Prototypes for new functions.\n\t* config/cris/cris/cris.c (cris_pic_sympart_only): Remove unused\n\tvariable.\n\t(cris_print_operand) <case 'v', 'P'>: Remove cases for unused\n\tmodifiers.\n\t<case ':'>: Add case for new punctuation character.\n\t<case 'd'>: Temporarily set flag_pic = 2 instead of incorrectly\n\temitting (extra) PIC modifier.\n\t<case UNSPEC>: Do not assert for PLT.\n\t(cris_initial_frame_pointer_offset, cris_simple_epilogue)\n\t(cris_expand_prologue, cris_expand_epilogue): Check\n\tfor pic_offset_table_rtx usage instead of taking\n\tcurrent_function_uses_pic_offset_table as the final word.\n\t(cris_rtx_costs, cris_address_cost, cris_side_effect_mode_ok):\n\tRemove flag_pic difference.\n\t(cris_valid_pic_const, cris_pic_symbol_type_of): New functions,\n\tthe moral equivalents of...\n\t(cris_symbol, cris_gotless_symbol, cris_got_symbol): Remove\n\tfunctions.\n\t(cris_legitimate_pic_operand): Just call cris_valid_pic_const.\n\t(cris_handle_option): Mark ARG as unused.\n\t(cris_expand_pic_call_address): New worker function for \"call\",\n\t\"call_value\".\n\t(cris_asm_output_symbol_ref, cris_asm_output_label_ref): Do not\n\toutput PIC constructs here.\n\t(cris_output_addr_const_extra): Changes for emitting PIC modifiers\n\tas symbol-specific modifers, not whole or part of operands.\n\t* config/cris/cris/cris.h (EXTRA_CONSTRAINT): Remove 'U' case.\n\t(EXTRA_CONSTRAINT_S): Changed semantics: allow only CONST-wrapped\n\tconstants and flag_pic.\n\t(CONSTANT_INDEX_P): Adjust for new functions.\n\t(enum cris_pic_symbol_type): New helper type.\n\t(PRINT_OPERAND_PUNCT_VALID_P): Add ':'.\n\t* config/cris/cris/cris.md (CRIS_UNSPEC_GOTREL)\n\t(CRIS_UNSPEC_GOTREAD, CRIS_UNSPEC_PLTGOTREAD): New\n\tdefine_constants.\n\t(\"movsi\"): Emit actual instructions for GOT and relative access.\n\t(\"*movsi_got_load\"): New pattern to set up the register holding\n\tthe GOT pointer.\n\t(\"*movsi_internal\"): Operand 1 is not a plain general_operand.\n\tAdjust FIXME for 'S'.\n\t<output for 'S' alternative>: Sanity-check UNSPEC types for PIC.\n\tUse \"movs\" for -fpic cases.\n\t(\"addsi3\"): Add alternative for 'S'; use adds.w when possible.\n\t(\"uminsi3\",\"*expanded_call_value\"): Remove 'S' alternative.\n\t(\"call\", \"call_value\"): Just call cris_expand_pic_call_address for\n\tPIC addresses.\n\t(\"*expanded_call_no_gotplt\", \"*expanded_call_value_no_gotplt\"):\n\tRemove special pattern.\n\t(\"*expanded_call_side\", \"*expanded_call_value_side\"): New\n\tpatterns.\n\t(gotplt-to-plt, gotplt-to-plt-side-call)\n\t(gotplt-to-plt-side-call-value, gotplt-to-plt-side): New\n\tpeephole2:s.\n\t* config/cris/cris/predicates.md\n\t(\"cris_general_operand_or_gotless_symbol\"): Remove unused\n\tpredicate.\n\t(\"cris_general_operand_or_symbol\"): Adjust for new functions.\n\nFrom-SVN: r101812", "tree": {"sha": "d8c11bf50d6e74488663bde1ef740cd1675b38b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8c11bf50d6e74488663bde1ef740cd1675b38b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "68ece23dbd7a5f58f5066b7ffcac73ceca1dbeae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ece23dbd7a5f58f5066b7ffcac73ceca1dbeae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ece23dbd7a5f58f5066b7ffcac73ceca1dbeae"}], "stats": {"total": 1090, "additions": 665, "deletions": 425}, "files": [{"sha": "6c5e2bb54e37a677e84c760fb83efac5096dd176", "filename": "gcc/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0", "patch": "@@ -1,3 +1,68 @@\n+2005-07-08  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\tRewrite PIC support to more closely model actual instructions.\n+\t* config/cris/cris-protos.h (cris_gotless_symbol, cris_got_symbol)\n+\t(cris_symbol): Remove prototypes for removed functions.\n+\t(cris_pic_symbol_type_of, cris_valid_pic_const)\n+\t(cris_expand_pic_call_address): Prototypes for new functions.\n+\t* config/cris/cris/cris.c (cris_pic_sympart_only): Remove unused\n+\tvariable.\n+\t(cris_print_operand) <case 'v', 'P'>: Remove cases for unused\n+\tmodifiers.\n+\t<case ':'>: Add case for new punctuation character.\n+\t<case 'd'>: Temporarily set flag_pic = 2 instead of incorrectly\n+\temitting (extra) PIC modifier.\n+\t<case UNSPEC>: Do not assert for PLT.\n+\t(cris_initial_frame_pointer_offset, cris_simple_epilogue)\n+\t(cris_expand_prologue, cris_expand_epilogue): Check\n+\tfor pic_offset_table_rtx usage instead of taking\n+\tcurrent_function_uses_pic_offset_table as the final word.\n+\t(cris_rtx_costs, cris_address_cost, cris_side_effect_mode_ok):\n+\tRemove flag_pic difference.\n+\t(cris_valid_pic_const, cris_pic_symbol_type_of): New functions,\n+\tthe moral equivalents of...\n+\t(cris_symbol, cris_gotless_symbol, cris_got_symbol): Remove\n+\tfunctions.\n+\t(cris_legitimate_pic_operand): Just call cris_valid_pic_const.\n+\t(cris_handle_option): Mark ARG as unused.\n+\t(cris_expand_pic_call_address): New worker function for \"call\",\n+\t\"call_value\".\n+\t(cris_asm_output_symbol_ref, cris_asm_output_label_ref): Do not\n+\toutput PIC constructs here.\n+\t(cris_output_addr_const_extra): Changes for emitting PIC modifiers\n+\tas symbol-specific modifers, not whole or part of operands.\n+\t* config/cris/cris/cris.h (EXTRA_CONSTRAINT): Remove 'U' case.\n+\t(EXTRA_CONSTRAINT_S): Changed semantics: allow only CONST-wrapped\n+\tconstants and flag_pic.\n+\t(CONSTANT_INDEX_P): Adjust for new functions.\n+\t(enum cris_pic_symbol_type): New helper type.\n+\t(PRINT_OPERAND_PUNCT_VALID_P): Add ':'.\n+\t* config/cris/cris/cris.md (CRIS_UNSPEC_GOTREL)\n+\t(CRIS_UNSPEC_GOTREAD, CRIS_UNSPEC_PLTGOTREAD): New\n+\tdefine_constants.\n+\t(\"movsi\"): Emit actual instructions for GOT and relative access.\n+\t(\"*movsi_got_load\"): New pattern to set up the register holding\n+\tthe GOT pointer.\n+\t(\"*movsi_internal\"): Operand 1 is not a plain general_operand.\n+\tAdjust FIXME for 'S'.\n+\t<output for 'S' alternative>: Sanity-check UNSPEC types for PIC.\n+\tUse \"movs\" for -fpic cases.\n+\t(\"addsi3\"): Add alternative for 'S'; use adds.w when possible.\n+\t(\"uminsi3\",\"*expanded_call_value\"): Remove 'S' alternative.\n+\t(\"call\", \"call_value\"): Just call cris_expand_pic_call_address for\n+\tPIC addresses.\n+\t(\"*expanded_call_no_gotplt\", \"*expanded_call_value_no_gotplt\"):\n+\tRemove special pattern.\n+\t(\"*expanded_call_side\", \"*expanded_call_value_side\"): New\n+\tpatterns.\n+\t(gotplt-to-plt, gotplt-to-plt-side-call)\n+\t(gotplt-to-plt-side-call-value, gotplt-to-plt-side): New\n+\tpeephole2:s.\n+\t* config/cris/cris/predicates.md\n+\t(\"cris_general_operand_or_gotless_symbol\"): Remove unused\n+\tpredicate.\n+\t(\"cris_general_operand_or_symbol\"): Adjust for new functions.\n+\n 2005-07-08  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* config/darwin.h (TARGET_C99_FUNCTIONS): Define to 1."}, {"sha": "f95a5d115cb735c6b7a592d67e36148d2b0a4c89", "filename": "gcc/config/cris/cris-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris-protos.h?ref=c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0", "patch": "@@ -38,16 +38,16 @@ extern int cris_side_effect_mode_ok (enum rtx_code, rtx *, int, int,\n extern rtx cris_return_addr_rtx (int, rtx);\n extern rtx cris_split_movdx (rtx *);\n extern int cris_legitimate_pic_operand (rtx);\n-extern int cris_gotless_symbol (rtx);\n-extern int cris_got_symbol (rtx);\n-extern int cris_symbol (rtx);\n+extern enum cris_pic_symbol_type cris_pic_symbol_type_of (rtx);\n+extern bool cris_valid_pic_const (rtx);\n extern bool cris_store_multiple_op_p (rtx);\n extern bool cris_movem_load_rest_p (rtx, int);\n extern void cris_asm_output_symbol_ref (FILE *, rtx);\n extern bool cris_output_addr_const_extra (FILE *, rtx);\n extern int cris_cfun_uses_pic_table (void);\n extern rtx cris_gen_movem_load (rtx, rtx, int);\n extern rtx cris_emit_movem_store (rtx, rtx, int, bool);\n+extern void cris_expand_pic_call_address (rtx *);\n #endif /* RTX_CODE */\n extern void cris_asm_output_label_ref (FILE *, char *);\n extern void cris_target_asm_named_section (const char *, unsigned int, tree);"}, {"sha": "4ce3c8bb9c68cd1902f220bdbe371adfc73d046f", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 249, "deletions": 222, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0", "patch": "@@ -82,12 +82,6 @@ struct machine_function GTY(())\n    pattern.  */\n static char cris_output_insn_is_bound = 0;\n \n-/* This one suppresses printing out the \"rPIC+\" in\n-   \"rPIC+sym:GOTOFF+offset\" when doing PIC.  For a PLT symbol, it\n-   suppresses outputting it as [rPIC+sym:GOTPLT] and outputs similarly\n-   just the \"sym:GOTOFF\" part.  */\n-static int cris_pic_sympart_only = 0;\n-\n /* In code for output macros, this is how we know whether e.g. constant\n    goes in code or in a static initializer.  */\n static int in_code = 0;\n@@ -686,15 +680,6 @@ cris_print_operand (FILE *file, rtx x, int code)\n       fprintf (file, \"%s\", cris_op_str (operand));\n       return;\n \n-    case 'v':\n-      /* Print the operand without the PIC register.  */\n-      if (! flag_pic || ! CONSTANT_P (x) || ! cris_gotless_symbol (x))\n-\tLOSE_AND_RETURN (\"invalid operand for 'v' modifier\", x);\n-      cris_pic_sympart_only++;\n-      cris_output_addr_const (file, x);\n-      cris_pic_sympart_only--;\n-      return;\n-\n     case 'o':\n       {\n \t/* A movem modifier working on a parallel; output the register\n@@ -751,14 +736,6 @@ cris_print_operand (FILE *file, rtx x, int code)\n       }\n       return;\n \n-    case 'P':\n-      /* Print the PIC register.  Applied to a GOT-less PIC symbol for\n-         sanity.  */\n-      if (! flag_pic || ! CONSTANT_P (x) || ! cris_gotless_symbol (x))\n-\tLOSE_AND_RETURN (\"invalid operand for 'P' modifier\", x);\n-      fprintf (file, \"$%s\", reg_names [PIC_OFFSET_TABLE_REGNUM]);\n-      return;\n-\n     case 'p':\n       /* Adjust a power of two to its log2.  */\n       if (GET_CODE (x) != CONST_INT || exact_log2 (INTVAL (x)) < 0 )\n@@ -829,6 +806,13 @@ cris_print_operand (FILE *file, rtx x, int code)\n \t       : \".p2alignw 5,0x050f,2\\n\\t\", file);\n       return;\n \n+    case ':':\n+      /* The PIC register.  */\n+      if (! flag_pic)\n+\tinternal_error (\"invalid use of ':' modifier\");\n+      fprintf (file, \"$%s\", reg_names [PIC_OFFSET_TABLE_REGNUM]);\n+      return;\n+\n     case 'H':\n       /* Print high (most significant) part of something.  */\n       switch (GET_CODE (operand))\n@@ -939,11 +923,16 @@ cris_print_operand (FILE *file, rtx x, int code)\n       return;\n \n     case 'd':\n-      /* If this is a GOT symbol, print it as :GOT regardless of -fpic.  */\n-      if (flag_pic && CONSTANT_P (operand) && cris_got_symbol (operand))\n+      /* If this is a GOT symbol, force it to be emitted as :GOT and\n+\t :GOTPLT regardless of -fpic (i.e. not as :GOT16, :GOTPLT16).\n+\t Avoid making this too much of a special case.  */\n+      if (flag_pic == 1 && CONSTANT_P (operand))\n \t{\n+\t  int flag_pic_save = flag_pic;\n+\n+\t  flag_pic = 2;\n \t  cris_output_addr_const (file, operand);\n-\t  fprintf (file, \":GOT\");\n+\t  flag_pic = flag_pic_save;\n \t  return;\n \t}\n       break;\n@@ -1015,9 +1004,7 @@ cris_print_operand (FILE *file, rtx x, int code)\n       return;\n \n     case UNSPEC:\n-      ASSERT_PLT_UNSPEC (operand);\n       /* Fall through.  */\n-\n     case CONST:\n       cris_output_addr_const (file, operand);\n       return;\n@@ -1153,7 +1140,16 @@ cris_initial_frame_pointer_offset (void)\n \n   /* Initial offset is 0 if we don't have a frame pointer.  */\n   int offs = 0;\n-  bool got_really_used = current_function_uses_pic_offset_table;\n+  bool got_really_used = false;\n+\n+  if (current_function_uses_pic_offset_table)\n+    {\n+      push_topmost_sequence ();\n+      got_really_used\n+\t= reg_used_between_p (pic_offset_table_rtx, get_insns (),\n+\t\t\t      NULL_RTX);\n+      pop_topmost_sequence ();\n+    }\n \n   /* And 4 for each register pushed.  */\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n@@ -1485,7 +1481,7 @@ cris_simple_epilogue (void)\n {\n   unsigned int regno;\n   unsigned int reglimit = STACK_POINTER_REGNUM;\n-  bool got_really_used = current_function_uses_pic_offset_table;\n+  bool got_really_used = false;\n \n   if (! reload_completed\n       || frame_pointer_needed\n@@ -1500,6 +1496,14 @@ cris_simple_epilogue (void)\n       || !TARGET_PROLOGUE_EPILOGUE)\n     return false;\n \n+  if (current_function_uses_pic_offset_table)\n+    {\n+      push_topmost_sequence ();\n+      got_really_used\n+\t= reg_used_between_p (pic_offset_table_rtx, get_insns (), NULL_RTX);\n+      pop_topmost_sequence ();\n+    }\n+\n   /* No simple epilogue if there are saved registers.  */\n   for (regno = 0; regno < reglimit; regno++)\n     if (cris_reg_saved_in_regsave_area (regno, got_really_used))\n@@ -1561,18 +1565,7 @@ cris_rtx_costs (rtx x, int code, int outer_code, int *total)\n \n     case CONST:\n     case SYMBOL_REF:\n-      /* For PIC, we need a prefix (if it isn't already there),\n-\t and the PIC register.  For a global PIC symbol, we also\n-\t need a read of the GOT.  */\n-      if (flag_pic)\n-\t{\n-\t  if (cris_got_symbol (x))\n-\t    *total = 2 + 4 + 6;\n-\t  else\n-\t    *total = 2 + 6;\n-\t}\n-      else\n-\t*total = 6;\n+      *total = 6;\n       return true;\n \n     case CONST_DOUBLE:\n@@ -1657,12 +1650,9 @@ cris_address_cost (rtx x)\n     return (2 + 4) / 2;\n \n   /* Assume (2 + 4) / 2 for a single constant; a dword, since it needs\n-     an extra DIP prefix and 4 bytes of constant in most cases.\n-     For PIC and a symbol with a GOT entry, we double the cost since we\n-     add a [rPIC+...] offset.  A GOT-less symbol uses a BDAP prefix\n-     equivalent to the DIP prefix for non-PIC, hence the same cost.  */\n+     an extra DIP prefix and 4 bytes of constant in most cases.  */\n   if (CONSTANT_P (x))\n-    return flag_pic && cris_got_symbol (x) ? 2 * (2 + 4) / 2 : (2 + 4) / 2;\n+    return (2 + 4) / 2;\n \n   /* Handle BIAP and BDAP prefixes.  */\n   if (GET_CODE (x) == PLUS)\n@@ -1789,10 +1779,9 @@ cris_side_effect_mode_ok (enum rtx_code code, rtx *ops,\n \t  && (INTVAL (val_rtx) <= 63 && INTVAL (val_rtx) >= -63))\n \treturn 0;\n \n-      /* Check allowed cases, like [r(+)?].[bwd] and const.\n-\t A symbol is not allowed with PIC.  */\n+      /* Check allowed cases, like [r(+)?].[bwd] and const.  */\n       if (CONSTANT_P (val_rtx))\n-\treturn flag_pic == 0 || cris_symbol (val_rtx) == 0;\n+\treturn 1;\n \n       if (GET_CODE (val_rtx) == MEM\n \t  && BASE_OR_AUTOINCR_P (XEXP (val_rtx, 0)))\n@@ -1861,170 +1850,113 @@ cris_target_asm_named_section (const char *name, unsigned int flags,\n     default_elf_asm_named_section (name, flags, decl);\n }\n \n-/* The LEGITIMATE_PIC_OPERAND_P worker.  */\n+/* Return TRUE iff X is a CONST valid for e.g. indexing.  */\n \n-int\n-cris_legitimate_pic_operand (rtx x)\n+bool\n+cris_valid_pic_const (rtx x)\n {\n-  /* The PIC representation of a symbol with a GOT entry will be (for\n-     example; relocations differ):\n-      sym => [rPIC+sym:GOT]\n-     and for a GOT-less symbol it will be (for example, relocation differ):\n-      sym => rPIC+sym:GOTOFF\n-     so only a symbol with a GOT is by itself a valid operand, and it\n-     can't be a sum of a symbol and an offset.  */\n-  return ! cris_symbol (x) || cris_got_symbol (x);\n-}\n-\n-/* Return nonzero if there's a SYMBOL_REF or LABEL_REF hiding inside this\n-   CONSTANT_P.  */\n+  gcc_assert (flag_pic);\n \n-int\n-cris_symbol (rtx x)\n-{\n   switch (GET_CODE (x))\n     {\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 1;\n-\n-    case UNSPEC:\n-      if (XINT (x, 1) == CRIS_UNSPEC_GOT || XINT (x, 1) != CRIS_UNSPEC_PLT)\n-\treturn 0;\n-      /* A PLT reference.  */\n-      ASSERT_PLT_UNSPEC (x);\n-      return 1;\n-\n-    case CONST:\n-      return cris_symbol (XEXP (x, 0));\n-\n-    case PLUS:\n-    case MINUS:\n-      return cris_symbol (XEXP (x, 0)) || cris_symbol (XEXP (x, 1));\n-\n     case CONST_INT:\n     case CONST_DOUBLE:\n-      return 0;\n-\n+      return true;\n     default:\n-      fatal_insn (\"unrecognized supposed constant\", x);\n+      ;\n     }\n \n-  return 1;\n+  if (GET_CODE (x) != CONST)\n+    return false;\n+\n+  x = XEXP (x, 0);\n+\n+  /* Handle (const (plus (unspec .. UNSPEC_GOTREL) (const_int ...))).  */\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == UNSPEC\n+      && XINT (XEXP (x, 0), 1) == CRIS_UNSPEC_GOTREL\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    x = XEXP (x, 0);\n+\n+  if (GET_CODE (x) == UNSPEC)\n+    switch (XINT (x, 1))\n+      {\n+      case CRIS_UNSPEC_PLT:\n+      case CRIS_UNSPEC_PLTGOTREAD:\n+      case CRIS_UNSPEC_GOTREAD:\n+      case CRIS_UNSPEC_GOTREL:\n+\treturn true;\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+  return cris_pic_symbol_type_of (x) == cris_no_symbol;\n }\n \n-/* Return nonzero if there's a SYMBOL_REF or LABEL_REF hiding inside this\n-   CONSTANT_P, and the symbol does not need a GOT entry.  Also set\n-   current_function_uses_pic_offset_table if we're generating PIC and ever\n-   see something that would need one.  */\n+/* Helper function to find the right PIC-type symbol to generate,\n+   given the original (non-PIC) representation.  */\n \n-int\n-cris_gotless_symbol (rtx x)\n+enum cris_pic_symbol_type\n+cris_pic_symbol_type_of (rtx x)\n {\n-  CRIS_ASSERT (flag_pic);\n-\n   switch (GET_CODE (x))\n     {\n-    case UNSPEC:\n-      if (XINT (x, 1) == CRIS_UNSPEC_GOT)\n-\treturn 1;\n-      if (XINT (x, 1) != CRIS_UNSPEC_PLT)\n-\treturn 0;\n-      ASSERT_PLT_UNSPEC (x);\n-      return 1;\n-\n     case SYMBOL_REF:\n-      if (cfun != NULL)\n-\tcurrent_function_uses_pic_offset_table = 1;\n-      return SYMBOL_REF_LOCAL_P (x);\n+      return SYMBOL_REF_LOCAL_P (x)\n+\t? cris_gotrel_symbol : cris_got_symbol;\n \n     case LABEL_REF:\n-      /* We don't set current_function_uses_pic_offset_table for\n-\t LABEL_REF:s in here, since they are almost always originating\n-\t from some branch.  The only time it does not come from a label is\n-\t when GCC does something like __builtin_setjmp.  Then we get the\n-\t LABEL_REF from the movsi expander, so we mark it there as a\n-\t special case.  */\n-      return 1;\n+      return cris_gotrel_symbol;\n \n     case CONST:\n-      return cris_gotless_symbol (XEXP (x, 0));\n+      return cris_pic_symbol_type_of (XEXP (x, 0));\n \n     case PLUS:\n     case MINUS:\n       {\n-\tint x0 = cris_gotless_symbol (XEXP (x, 0)) != 0;\n-\tint x1 = cris_gotless_symbol (XEXP (x, 1)) != 0;\n-\n-\t/* One and only one of them must be a local symbol.  Neither must\n-\t   be some other, more general kind of symbol.  */\n-\treturn\n-\t  (x0 ^ x1)\n-\t  && ! (x0 == 0 && cris_symbol (XEXP (x, 0)))\n-\t  && ! (x1 == 0 && cris_symbol (XEXP (x, 1)));\n+\tenum cris_pic_symbol_type t1 = cris_pic_symbol_type_of (XEXP (x, 0));\n+\tenum cris_pic_symbol_type t2 = cris_pic_symbol_type_of (XEXP (x, 1));\n+\n+\tgcc_assert (t1 == cris_no_symbol || t2 == cris_no_symbol);\n+\n+\tif (t1 == cris_got_symbol || t1 == cris_got_symbol)\n+\t  return cris_got_symbol_needing_fixup;\n+\n+\treturn t1 != cris_no_symbol ? t1 : t2;\n       }\n \n     case CONST_INT:\n     case CONST_DOUBLE:\n-      return 0;\n+      return cris_no_symbol;\n+\n+    case UNSPEC:\n+      /* Likely an offsettability-test attempting to add a constant to\n+\t a GOTREAD symbol, which can't be handled.  */\n+      return cris_invalid_pic_symbol;\n \n     default:\n       fatal_insn (\"unrecognized supposed constant\", x);\n     }\n \n-  return 1;\n+  gcc_unreachable ();\n }\n \n-/* Return nonzero if there's a SYMBOL_REF or LABEL_REF hiding inside this\n-   CONSTANT_P, and the symbol needs a GOT entry.  */\n+/* The LEGITIMATE_PIC_OPERAND_P worker.  */\n \n int\n-cris_got_symbol (rtx x)\n+cris_legitimate_pic_operand (rtx x)\n {\n-  CRIS_ASSERT (flag_pic);\n-\n-  switch (GET_CODE (x))\n-    {\n-    case UNSPEC:\n-      if (XINT (x, 1) == CRIS_UNSPEC_GOT)\n-\treturn 0;\n-      ASSERT_PLT_UNSPEC (x);\n-      return 0;\n-\n-    case SYMBOL_REF:\n-      if (cfun != NULL)\n-\tcurrent_function_uses_pic_offset_table = 1;\n-      return ! SYMBOL_REF_LOCAL_P (x);\n-\n-    case CONST:\n-      return cris_got_symbol (XEXP (x, 0));\n-\n-    case LABEL_REF:\n-      /* A LABEL_REF is never visible as a symbol outside the local\n-         function.  */\n-    case PLUS:\n-    case MINUS:\n-      /* Nope, can't access the GOT for \"symbol + offset\".  */\n-      return 0;\n-\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-      return 0;\n-\n-    default:\n-      fatal_insn (\"unrecognized supposed constant in cris_global_pic_symbol\",\n-\t\t  x);\n-    }\n-\n-  return 1;\n+  /* Symbols are not valid PIC operands as-is; just constants.  */\n+  return cris_valid_pic_const (x);\n }\n \n /* TARGET_HANDLE_OPTION worker.  We just store the values into local\n    variables here.  Checks for correct semantics are in\n    cris_override_options.  */\n \n static bool\n-cris_handle_option (size_t code, const char *arg, int value ATTRIBUTE_UNUSED)\n+cris_handle_option (size_t code, const char *arg ATTRIBUTE_UNUSED,\n+\t\t    int value ATTRIBUTE_UNUSED)\n {\n   switch (code)\n     {\n@@ -2441,7 +2373,7 @@ cris_expand_prologue (void)\n   int framesize = 0;\n   rtx mem, insn;\n   int return_address_on_stack = cris_return_address_on_stack ();\n-  int got_really_used = current_function_uses_pic_offset_table;\n+  int got_really_used = false;\n   int n_movem_regs = 0;\n   int pretend = current_function_pretend_args_size;\n \n@@ -2451,6 +2383,17 @@ cris_expand_prologue (void)\n \n   CRIS_ASSERT (size >= 0);\n \n+  if (current_function_uses_pic_offset_table)\n+    {\n+      /* A reference may have been optimized out (like the abort () in\n+\t fde_split in unwind-dw2-fde.c, at least 3.2.1) so check that\n+\t it's still used.  */\n+      push_topmost_sequence ();\n+      got_really_used\n+\t= reg_used_between_p (pic_offset_table_rtx, get_insns (), NULL_RTX);\n+      pop_topmost_sequence ();\n+    }\n+\n   /* Align the size to what's best for the CPU model.  */\n   if (TARGET_STACK_ALIGN)\n     size = TARGET_ALIGN_BY_32 ? (size + 3) & ~3 : (size + 1) & ~1;\n@@ -2713,12 +2656,23 @@ cris_expand_epilogue (void)\n   /* A reference may have been optimized out\n      (like the abort () in fde_split in unwind-dw2-fde.c, at least 3.2.1)\n      so check that it's still used.  */\n-  int got_really_used = current_function_uses_pic_offset_table;\n+  int got_really_used = false;\n   int n_movem_regs = 0;\n \n   if (!TARGET_PROLOGUE_EPILOGUE)\n     return;\n \n+  if (current_function_uses_pic_offset_table)\n+    {\n+      /* A reference may have been optimized out (like the abort () in\n+\t fde_split in unwind-dw2-fde.c, at least 3.2.1) so check that\n+\t it's still used.  */\n+      push_topmost_sequence ();\n+      got_really_used\n+\t= reg_used_between_p (pic_offset_table_rtx, get_insns (), NULL_RTX);\n+      pop_topmost_sequence ();\n+    }\n+\n   /* Align byte count of stack frame.  */\n   if (TARGET_STACK_ALIGN)\n     size = TARGET_ALIGN_BY_32 ? (size + 3) & ~3 : (size + 1) & ~1;\n@@ -3059,6 +3013,93 @@ cris_emit_movem_store (rtx dest, rtx nregs_rtx, int increment,\n   return insn;\n }\n \n+/* Worker function for expanding the address for PIC function calls.  */\n+\n+void\n+cris_expand_pic_call_address (rtx *opp)\n+{\n+  rtx op = *opp;\n+\n+  gcc_assert (MEM_P (op));\n+  op = XEXP (op, 0);\n+\n+  /* It might be that code can be generated that jumps to 0 (or to a\n+     specific address).  Don't die on that.  (There is a\n+     testcase.)  */\n+  if (CONSTANT_ADDRESS_P (op) && GET_CODE (op) != CONST_INT)\n+    {\n+      enum cris_pic_symbol_type t = cris_pic_symbol_type_of (op);\n+\n+      CRIS_ASSERT (!no_new_pseudos);\n+\n+      /* For local symbols (non-PLT), just get the plain symbol\n+\t reference into a register.  For symbols that can be PLT, make\n+\t them PLT.  */\n+      if (t == cris_gotrel_symbol)\n+\top = force_reg (Pmode, op);\n+      else if (t == cris_got_symbol)\n+\t{\n+\t  if (TARGET_AVOID_GOTPLT)\n+\t    {\n+\t      /* Change a \"jsr sym\" into (allocate register rM, rO)\n+\t\t \"move.d (const (unspec [sym] CRIS_UNSPEC_PLT)),rM\"\n+\t\t \"add.d rPIC,rM,rO\", \"jsr rO\".  */\n+\t      rtx tem, rm, ro;\n+\t      gcc_assert (! no_new_pseudos);\n+\t      current_function_uses_pic_offset_table = 1;\n+\t      tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op), CRIS_UNSPEC_PLT);\n+\t      rm = gen_reg_rtx (Pmode);\n+\t      emit_move_insn (rm, gen_rtx_CONST (Pmode, tem));\n+\t      ro = gen_reg_rtx (Pmode);\n+\t      if (expand_binop (Pmode, add_optab, rm,\n+\t\t\t\tpic_offset_table_rtx,\n+\t\t\t\tro, 0, OPTAB_LIB_WIDEN) != ro)\n+\t\tinternal_error (\"expand_binop failed in movsi got\");\n+\t      op = ro;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Change a \"jsr sym\" into (allocate register rM, rO)\n+\t\t \"move.d (const (unspec [sym] CRIS_UNSPEC_PLTGOT)),rM\"\n+\t\t \"add.d rPIC,rM,rO\" \"jsr [rO]\" with the memory access\n+\t\t marked as not trapping and not aliasing.  No \"move.d\n+\t\t [rO],rP\" as that would invite to re-use of a value\n+\t\t that should not be reused.  FIXME: Need a peephole2\n+\t\t for cases when this is cse:d from the call, to change\n+\t\t back to just get the PLT entry address, so we don't\n+\t\t resolve the same symbol over and over (the memory\n+\t\t access of the PLTGOT isn't constant).  */\n+\t      rtx tem, mem, rm, ro;\n+\n+\t      gcc_assert (! no_new_pseudos);\n+\t      current_function_uses_pic_offset_table = 1;\n+\t      tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op),\n+\t\t\t\t    CRIS_UNSPEC_PLTGOTREAD);\n+\t      rm = gen_reg_rtx (Pmode);\n+\t      emit_move_insn (rm, gen_rtx_CONST (Pmode, tem));\n+\t      ro = gen_reg_rtx (Pmode);\n+\t      if (expand_binop (Pmode, add_optab, rm,\n+\t\t\t\tpic_offset_table_rtx,\n+\t\t\t\tro, 0, OPTAB_LIB_WIDEN) != ro)\n+\t\tinternal_error (\"expand_binop failed in movsi got\");\n+\t      mem = gen_rtx_MEM (Pmode, ro);\n+\n+\t      /* This MEM doesn't alias anything.  Whether it aliases\n+\t\t other same symbols is unimportant.  */\n+\t      set_mem_alias_set (mem, new_alias_set ());\n+\t      MEM_NOTRAP_P (mem) = 1;\n+\t      op = mem;\n+\t    }\n+\t}\n+      else\n+\t/* Can't possibly get a GOT-needing-fixup for a function-call,\n+\t   right?  */\n+\tfatal_insn (\"Unidentifiable call op\", op);\n+\n+      *opp = replace_equiv_address (*opp, op);\n+    }\n+}\n+\n /* Use from within code, from e.g. PRINT_OPERAND and\n    PRINT_OPERAND_ADDRESS.  Macros used in output_addr_const need to emit\n    different things depending on whether code operand or constant is\n@@ -3077,38 +3118,18 @@ cris_output_addr_const (FILE *file, rtx x)\n void\n cris_asm_output_symbol_ref (FILE *file, rtx x)\n {\n+  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n+\n   if (flag_pic && in_code > 0)\n     {\n-      const char *origstr = XSTR (x, 0);\n-      const char *str;\n-\n-      str = (* targetm.strip_name_encoding) (origstr);\n-\n-      if (cris_gotless_symbol (x))\n-\t{\n-\t  if (! cris_pic_sympart_only)\n-\t    fprintf (file, \"$%s+\", reg_names [PIC_OFFSET_TABLE_REGNUM]);\n-\t  assemble_name (file, str);\n-\t  fprintf (file, \":GOTOFF\");\n-\t}\n-      else if (cris_got_symbol (x))\n-\t{\n-\t  CRIS_ASSERT (!cris_pic_sympart_only);\n-\n-\t  fprintf (file, \"[$%s+\", reg_names [PIC_OFFSET_TABLE_REGNUM]);\n-\t  assemble_name (file, XSTR (x, 0));\n-\n-\t  if (flag_pic == 1)\n-\t    fprintf (file, \":GOT16]\");\n-\t  else\n-\t    fprintf (file, \":GOT]\");\n-\t}\n-      else\n-\tLOSE_AND_RETURN (\"unexpected PIC symbol\", x);\n-\n-      /* Sanity check.  */\n-      if (! current_function_uses_pic_offset_table)\n-\toutput_operand_lossage (\"PIC register isn't set up\");\n+     const char *origstr = XSTR (x, 0);\n+     const char *str;\n+     str = (* targetm.strip_name_encoding) (origstr);\n+     assemble_name (file, str);\n+\n+     /* Sanity check.  */\n+     if (! current_function_uses_pic_offset_table)\n+       output_operand_lossage (\"PIC register isn't set up\");\n     }\n   else\n     assemble_name (file, XSTR (x, 0));\n@@ -3121,12 +3142,8 @@ cris_asm_output_label_ref (FILE *file, char *buf)\n {\n   if (flag_pic && in_code > 0)\n     {\n-      if (! cris_pic_sympart_only)\n-\tfprintf (file, \"$%s+\", reg_names [PIC_OFFSET_TABLE_REGNUM]);\n       assemble_name (file, buf);\n \n-      fprintf (file, \":GOTOFF\");\n-\n       /* Sanity check.  */\n       if (! current_function_uses_pic_offset_table)\n \tinternal_error (\"emitting PIC operand, but PIC register isn't set up\");\n@@ -3138,34 +3155,44 @@ cris_asm_output_label_ref (FILE *file, char *buf)\n /* Worker function for OUTPUT_ADDR_CONST_EXTRA.  */\n \n bool\n-cris_output_addr_const_extra (FILE *file, rtx x)\n+cris_output_addr_const_extra (FILE *file, rtx xconst)\n {\n-  switch (GET_CODE (x))\n+  switch (GET_CODE (xconst))\n     {\n-      const char *origstr;\n-      const char *str;\n+      rtx x;\n \n     case UNSPEC:\n-      ASSERT_PLT_UNSPEC (x);\n-      x = XVECEXP (x, 0, 0);\n-      origstr = XSTR (x, 0);\n-      str = (* targetm.strip_name_encoding) (origstr);\n-      if (cris_pic_sympart_only)\n+      x = XVECEXP (xconst, 0, 0);\n+      CRIS_ASSERT (GET_CODE (x) == SYMBOL_REF\n+\t\t   || GET_CODE (x) == LABEL_REF\n+\t\t   || GET_CODE (x) == CONST);\n+      output_addr_const (file, x);\n+      switch (XINT (xconst, 1))\n \t{\n-\t  assemble_name (file, str);\n+\tcase CRIS_UNSPEC_PLT:\n \t  fprintf (file, \":PLTG\");\n-\t}\n-      else\n-\t{\n-\t  CRIS_ASSERT (!TARGET_AVOID_GOTPLT);\n+\t  break;\n \n-\t  fprintf (file, \"[$%s+\", reg_names [PIC_OFFSET_TABLE_REGNUM]);\n-\t  assemble_name (file, XSTR (x, 0));\n+\tcase CRIS_UNSPEC_GOTREL:\n+\t  fprintf (file, \":GOTOFF\");\n+\t  break;\n \n+\tcase CRIS_UNSPEC_GOTREAD:\n \t  if (flag_pic == 1)\n-\t    fprintf (file, \":GOTPLT16]\");\n+\t    fprintf (file, \":GOT16\");\n \t  else\n-\t    fprintf (file, \":GOTPLT]\");\n+\t    fprintf (file, \":GOT\");\n+\t  break;\n+\n+\tcase CRIS_UNSPEC_PLTGOTREAD:\n+\t  if (flag_pic == 1)\n+\t    fprintf (file, CRIS_GOTPLT_SUFFIX \"16\");\n+\t  else\n+\t    fprintf (file, CRIS_GOTPLT_SUFFIX);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n       return true;\n "}, {"sha": "0ca52da54ebbbe3a1b16239bafd54c4a393f7cf8", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0", "patch": "@@ -634,8 +634,6 @@ enum reg_class\n   (C) == 'S' ? EXTRA_CONSTRAINT_S (X) :\t\t\\\n   /* A three-address addressing-mode?  */\t\\\n   (C) == 'T' ? EXTRA_CONSTRAINT_T (X) :\t\t\\\n-  /* A global PIC symbol?  */\t\t\t\\\n-  (C) == 'U' ? EXTRA_CONSTRAINT_U (X) :\t\t\\\n   0)\n \n #define EXTRA_MEMORY_CONSTRAINT(X, STR) ((X) == 'Q')\n@@ -685,16 +683,9 @@ enum reg_class\n \t\t  && BIAP_INDEX_P (XEXP (XEXP (X, 0), 0))))))\t\t\\\n  )\n \n-/* We're kind of out of constraints, so we use \"S\" for both gotless\n-   symbols and the GOT-address load.  Both must go in a general register\n-   only: for pre-V32, arithmetic is done on the destination.  */\n+/* PIC-constructs for symbols.  */\n #define EXTRA_CONSTRAINT_S(X)\t\t\t\t\t\t\\\n- (flag_pic\t\t\t\t\t\t\t\t\\\n-  && ((CONSTANT_P (X) && cris_gotless_symbol (X))\t\t\t\\\n-      || (GET_CODE (X) == UNSPEC && XINT ((X), 1) == CRIS_UNSPEC_GOT)))\n-\n-#define EXTRA_CONSTRAINT_U(X) \\\n- (flag_pic && CONSTANT_P (X) && cris_got_symbol (X))\n+ (flag_pic && GET_CODE (X) == CONST && cris_valid_pic_const (X))\n \n \n /* Node: Frame Layout */\n@@ -956,7 +947,7 @@ struct cum_args {int regs;};\n /* No symbol can be used as an index (or more correct, as a base) together\n    with a register with PIC; the PIC register must be there.  */\n #define CONSTANT_INDEX_P(X) \\\n- (CONSTANT_P (X) && !(flag_pic && cris_symbol (X)))\n+ (CONSTANT_P (X) && (!flag_pic || cris_valid_pic_const (X)))\n \n /* True if X is a valid base register.  */\n #define BASE_P(X) \\\n@@ -1003,10 +994,7 @@ struct cum_args {int regs;};\n    rtx x1, x2;\t\t\t\t\t\t\t\\\n    if (SIMPLE_ADDRESS_P (X))\t\t\t\t\t\\\n      goto ADDR;\t\t\t\t\t\t\t\\\n-   if (CONSTANT_P (X)\t\t\t\t\t\t\\\n-       && (! flag_pic\t\t\t\t\t\t\\\n-\t   || cris_gotless_symbol (X)\t\t\t\t\\\n-\t   || ! cris_symbol (X)))\t\t\t\t\\\n+   if (CONSTANT_INDEX_P (X))\t\t\t\t\t\\\n      goto ADDR;\t\t\t\t\t\t\t\\\n    /* Indexed?  */\t\t\t\t\t\t\\\n    if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n@@ -1150,6 +1138,17 @@ struct cum_args {int regs;};\n \n /* Node: PIC */\n \n+/* Helper type.  */\n+\n+enum cris_pic_symbol_type\n+  {\n+    cris_no_symbol = 0,\n+    cris_got_symbol = 1,\n+    cris_gotrel_symbol = 2,\n+    cris_got_symbol_needing_fixup = 3,\n+    cris_invalid_pic_symbol = 4\n+  };\n+\n #define PIC_OFFSET_TABLE_REGNUM (flag_pic ? CRIS_GOT_REGNUM : INVALID_REGNUM)\n \n #define LEGITIMATE_PIC_OPERAND_P(X) cris_legitimate_pic_operand (X)\n@@ -1276,7 +1275,7 @@ struct cum_args {int regs;};\n \n /* For delay-slot handling.  */\n #define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\\\n- ((CODE) == '#' || (CODE) == '!')\n+ ((CODE) == '#' || (CODE) == '!' || (CODE) == ':')\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\\\n    cris_print_operand_address (FILE, ADDR)"}, {"sha": "8d0ecaabaa6f1815263a7bd684432f719360ac68", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 328, "deletions": 170, "changes": 498, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0", "patch": "@@ -60,11 +60,17 @@\n ;;   the mode is VOIDmode.  Always wrapped in CONST.\n ;; 1 Stack frame deallocation barrier.\n ;; 2 The address of the global offset table as a source operand.\n+;; 3 The address of a global-offset-table-relative symbol + offset.\n+;; 4 The offset within GOT of a symbol.\n+;; 5 The offset within GOT of a symbol that has a PLT.\n \n-(define_constants\n+(define_constants ; FIXME: reorder sanely.\n   [(CRIS_UNSPEC_PLT 0)\n    (CRIS_UNSPEC_FRAME_DEALLOC 1)\n-   (CRIS_UNSPEC_GOT 2)])\n+   (CRIS_UNSPEC_GOT 2)\n+   (CRIS_UNSPEC_GOTREL 3)\n+   (CRIS_UNSPEC_GOTREAD 4)\n+   (CRIS_UNSPEC_PLTGOTREAD 5)])\n \n ;; Register numbers.\n (define_constants\n@@ -769,64 +775,114 @@\n      FIXME: Do we *have* to recognize anything that would normally be a\n      valid symbol?  Can we exclude global PIC addresses with an added\n      offset?  */\n-  if (flag_pic\n-      && CONSTANT_ADDRESS_P (operands[1])\n-      && cris_symbol (operands[1]))\n-    {\n-      /* We must have a register as destination for what we're about to\n-\t do, and for the patterns we generate.  */\n-      if (! REG_S_P (operands[0]))\n-\t{\n-\t  CRIS_ASSERT (!no_new_pseudos);\n-\t  operands[1] = force_reg (SImode, operands[1]);\n-\t}\n-      else\n-\t{\n-\t  /* Mark a needed PIC setup for a LABEL_REF:s coming in here:\n-\t     they are so rare not-being-branch-targets that we don't mark\n-\t     a function as needing PIC setup just because we have\n-\t     inspected LABEL_REF:s as operands.  It is only in\n-\t     __builtin_setjmp and such that we can get a LABEL_REF\n-\t     assigned to a register.  */\n-\t  if (GET_CODE (operands[1]) == LABEL_REF)\n+    if (flag_pic\n+\t&& CONSTANT_ADDRESS_P (operands[1])\n+\t&& !cris_valid_pic_const (operands[1]))\n+      {\n+\tenum cris_pic_symbol_type t = cris_pic_symbol_type_of (operands[1]);\n+\n+\tgcc_assert (t != cris_no_symbol);\n+\n+\tif (! REG_S_P (operands[0]))\n+\t  {\n+\t    /* We must have a register as destination for what we're about to\n+\t       do, and for the patterns we generate.  */\n+\t    CRIS_ASSERT (!no_new_pseudos);\n+\t    operands[1] = force_reg (SImode, operands[1]);\n+\t  }\n+\telse\n+\t  {\n+\t    /* FIXME: add a REG_EQUAL (or is it REG_EQUIV) note to the\n+\t       destination register for the symbol.  It might not be\n+\t       worth it.  Measure.  */\n \t    current_function_uses_pic_offset_table = 1;\n-\n-\t  /* We don't have to do anything for global PIC operands; they\n-\t     look just like ``[rPIC+sym]''.  */\n-\t  if (! cris_got_symbol (operands[1])\n-\t      /* We don't do anything for local PIC operands; we match\n-\t\t that with a special alternative.  */\n-\t      && ! cris_gotless_symbol (operands[1]))\n-\t    {\n-\t      /* We get here when we have to change something that would\n-\t\t be recognizable if it wasn't PIC.  A ``sym'' is ok for\n-\t\t PIC symbols both with and without a GOT entry.  And ``sym\n-\t\t + offset'' is ok for local symbols, so the only thing it\n-\t\t could be, is a global symbol with an offset.  Check and\n-\t\t abort if not.  */\n-\t      rtx sym = get_related_value (operands[1]);\n-\t      HOST_WIDE_INT offs = get_integer_term (operands[1]);\n-\n-\t      CRIS_ASSERT (sym != NULL_RTX && offs != 0);\n-\n-\t      emit_move_insn (operands[0], sym);\n-\t      if (expand_binop (SImode, add_optab, operands[0],\n-\t\t\t\tGEN_INT (offs), operands[0], 0,\n-\t\t\t\tOPTAB_LIB_WIDEN) != operands[0])\n-\t        internal_error (\"expand_binop failed in movsi\");\n-\t      DONE;\n-\t    }\n-\t}\n-    }\n+\t    if (t == cris_gotrel_symbol)\n+\t      {\n+\t\t/* Change a \"move.d sym(+offs),rN\" into (allocate register rM)\n+\t\t   \"move.d (const (plus (unspec [sym]\n+\t\t    CRIS_UNSPEC_GOTREL) offs)),rM\" \"add.d rPIC,rM,rN\"  */\n+\t\trtx tem, rm, rn = operands[0];\n+\t\trtx sym = GET_CODE (operands[1]) != CONST\n+\t\t  ? operands[1] : get_related_value (operands[1]);\n+\t\tHOST_WIDE_INT offs = get_integer_term (operands[1]);\n+\n+\t\tgcc_assert (! no_new_pseudos);\n+\t\ttem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym),\n+\t\t\t\t      CRIS_UNSPEC_GOTREL);\n+\t\tif (offs != 0)\n+\t\t  tem = plus_constant (tem, offs);\n+\t\trm = gen_reg_rtx (Pmode);\n+\t\temit_move_insn (rm, gen_rtx_CONST (Pmode, tem));\n+\t        if (expand_binop (Pmode, add_optab, rm, pic_offset_table_rtx,\n+\t\t\t\t  rn, 0, OPTAB_LIB_WIDEN) != rn)\n+\t\t  internal_error (\"expand_binop failed in movsi gotrel\");\n+\t\tDONE;\n+\t      }\n+\t    else if (t == cris_got_symbol)\n+\t      {\n+\t\t/* Change a \"move.d sym,rN\" into (allocate register rM, rO)\n+\t\t   \"move.d (const (unspec [sym] CRIS_UNSPEC_GOTREAD)),rM\"\n+\t\t   \"add.d rPIC,rM,rO\", \"move.d [rO],rN\" with\n+\t\t   the memory access marked as read-only.  */\n+\t\trtx tem, mem, rm, ro, rn = operands[0];\n+\t\tgcc_assert (! no_new_pseudos);\n+\t\ttem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, operands[1]),\n+\t\t\t\t      CRIS_UNSPEC_GOTREAD);\n+\t\trm = gen_reg_rtx (Pmode);\n+\t\temit_move_insn (rm, gen_rtx_CONST (Pmode, tem));\n+\t\tro = gen_reg_rtx (Pmode);\n+\t        if (expand_binop (Pmode, add_optab, rm, pic_offset_table_rtx,\n+\t\t\t\t  ro, 0, OPTAB_LIB_WIDEN) != ro)\n+\t\t  internal_error (\"expand_binop failed in movsi got\");\n+\t\tmem = gen_rtx_MEM (Pmode, ro);\n+\n+\t\t/* This MEM doesn't alias anything.  Whether it\n+\t\t   aliases other same symbols is unimportant.  */\n+\t\tset_mem_alias_set (mem, new_alias_set ());\n+\t\tMEM_NOTRAP_P (mem) = 1;\n+\t\tMEM_READONLY_P (mem) = 1;\n+\t\temit_move_insn (rn, mem);\n+\t\tDONE;\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* We get here when we have to change something that would\n+\t\t   be recognizable if it wasn't PIC.  A ``sym'' is ok for\n+\t\t   PIC symbols both with and without a GOT entry.  And ``sym\n+\t\t   + offset'' is ok for local symbols, so the only thing it\n+\t\t   could be, is a global symbol with an offset.  Check and\n+\t\t   abort if not.  */\n+\t\trtx reg = gen_reg_rtx (Pmode);\n+\t\trtx sym = get_related_value (operands[1]);\n+\t\tHOST_WIDE_INT offs = get_integer_term (operands[1]);\n+\n+\t\tgcc_assert (! no_new_pseudos\n+\t\t\t    && t == cris_got_symbol_needing_fixup\n+\t\t\t    && sym != NULL_RTX && offs != 0);\n+\n+\t\temit_move_insn (reg, sym);\n+\t\tif (expand_binop (SImode, add_optab, reg,\n+\t\t\t\t  GEN_INT (offs), operands[0], 0,\n+\t\t\t\t  OPTAB_LIB_WIDEN) != operands[0])\n+\t\t  internal_error (\"expand_binop failed in movsi got+offs\");\n+\t\tDONE;\n+\t      }\n+\t  }\n+      }\n })\n \n+(define_insn \"*movsi_got_load\"\n+  [(set (reg:SI CRIS_GOT_REGNUM) (unspec:SI [(const_int 0)] CRIS_UNSPEC_GOT))]\n+  \"flag_pic\"\n+  \"move.d $pc,%:\\;sub.d .:GOTOFF,%:\"\n+  [(set_attr \"cc\" \"clobber\")])\n+\n (define_insn \"*movsi_internal\"\n   [(set\n     (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r, r,Q>,r,Q>,g,r,r, r,g,rQ>,x,  m,x\")\n-    (match_operand:SI 1\n-    ;; FIXME: We want to put S last, but apparently g matches S.\n-    ;; It's a bug: an S is not a general_operand and shouldn't match g.\n-     \"cris_general_operand_or_gotless_symbol\"   \"r,Q>,M,M, I,r, M,n,!S,g,r,x,  rQ>,x,gi\"))]\n+    ;; Note that we prefer not to use the S alternative (if for some reason\n+    ;; it competes with others), but g matches S.\n+    (match_operand:SI 1 \"general_operand\"\t\"r,Q>,M,M, I,r, M,n,!S,g,r,x,  rQ>,x,gi\"))]\n   \"\"\n {\n   /* Better to have c-switch here; it is worth it to optimize the size of\n@@ -873,32 +929,32 @@\n       return \"move.d %1,%0\";\n \n     case 8:\n-      /* FIXME: Try and split this into pieces GCC makes better code of,\n-\t than this multi-insn pattern.  Synopsis: wrap the GOT-relative\n-\t symbol into an unspec, and when PIC, recognize the unspec\n-\t everywhere a symbol is normally recognized.  (The PIC register\n-\t should be recognized by GCC as pic_offset_table_rtx when needed\n-\t and similar for PC.)  Each component can then be optimized with\n-\t the rest of the code; it should be possible to have a constant\n-\t term added on an unspec.  Don't forget to add a REG_EQUAL (or\n-\t is it REG_EQUIV) note to the destination.  It might not be\n-\t worth it.  Measure.\n-\n-\t Note that the 'v' modifier makes PLT references be output as\n-\t sym:PLT rather than [rPIC+sym:GOTPLT].  */\n-      if (GET_CODE (operands[1]) == UNSPEC\n-\t  && XINT (operands[1], 1) == CRIS_UNSPEC_GOT)\n-\t{\n-\t  /* We clobber cc0 rather than set it to GOT.  Should not\n-             matter, though.  */\n-\t  CC_STATUS_INIT;\n-\t  CRIS_ASSERT (REGNO (operands[0]) == PIC_OFFSET_TABLE_REGNUM);\n-\n-\t  return \"move.d $pc,%0\\;sub.d .:GOTOFF,%0\";\n-\t}\n-\n-      return \"move.d %v1,%0\\;add.d %P1,%0\";\n-\n+      {\n+\trtx tem = operands[1];\n+\tgcc_assert (GET_CODE (tem) == CONST);\n+\ttem = XEXP (tem, 0);\n+\tif (GET_CODE (tem) == PLUS\n+\t    && GET_CODE (XEXP (tem, 0)) == UNSPEC\n+\t    && XINT (XEXP (tem, 0), 1) == CRIS_UNSPEC_GOTREL\n+\t    && GET_CODE (XEXP (tem, 1)) == CONST_INT)\n+\t  tem = XEXP (tem, 0);\n+\tgcc_assert (GET_CODE (tem) == UNSPEC);\n+\tswitch (XINT (tem, 1))\n+\t  {\n+\t  case CRIS_UNSPEC_GOTREAD:\n+\t  case CRIS_UNSPEC_PLTGOTREAD:\n+\t    /* Using sign-extend mostly to be consistent with the\n+\t       indexed addressing mode.  */\n+\t    if (flag_pic == 1)\n+\t      return \"movs.w %1,%0\";\n+\t  case CRIS_UNSPEC_GOTREL:\n+\t  case CRIS_UNSPEC_PLT:\n+\t    return \"move.d %1,%0\";\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+      }\n     default:\n       return \"BOGUS: %1 to %0\";\n     }\n@@ -1347,10 +1403,10 @@\n    add.d %M2,%M1,%M0\\;ax\\;add.d %H2,%H1,%H0\")\n \n (define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\"  \"=r,r, r,r,r,r,r,  r\")\n+  [(set (match_operand:SI 0 \"register_operand\"  \"=r,r, r,r,r,r, r,r,  r\")\n \t(plus:SI\n-\t (match_operand:SI 1 \"register_operand\" \"%0,0, 0,0,0,0,r,  r\")\n-\t (match_operand:SI 2 \"general_operand\"   \"r,Q>,J,N,n,g,!To,0\")))]\n+\t (match_operand:SI 1 \"register_operand\" \"%0,0, 0,0,0,0, 0,r,  r\")\n+\t (match_operand:SI 2 \"general_operand\"   \"r,Q>,J,N,n,!S,g,!To,0\")))]\n \n ;; The last constraint is due to that after reload, the '%' is not\n ;; honored, and canonicalization doesn't care about keeping the same\n@@ -1386,17 +1442,44 @@\n \t    return \"subu.w %n2,%0\";\n \t}\n       return \"add.d %2,%0\";\n-    case 6:\n-      return \"add.d %2,%1,%0\";\n     case 5:\n+      {\n+\trtx tem = operands[2];\n+\tgcc_assert (GET_CODE (tem) == CONST);\n+\ttem = XEXP (tem, 0);\n+\tif (GET_CODE (tem) == PLUS\n+\t    && GET_CODE (XEXP (tem, 0)) == UNSPEC\n+\t    && XINT (XEXP (tem, 0), 1) == CRIS_UNSPEC_GOTREL\n+\t    && GET_CODE (XEXP (tem, 1)) == CONST_INT)\n+\t  tem = XEXP (tem, 0);\n+\tgcc_assert (GET_CODE (tem) == UNSPEC);\n+\tswitch (XINT (tem, 1))\n+\t  {\n+\t  case CRIS_UNSPEC_GOTREAD:\n+\t  case CRIS_UNSPEC_PLTGOTREAD:\n+\t    /* Using sign-extend mostly to be consistent with the\n+\t       indexed addressing mode.  */\n+\t    if (flag_pic == 1)\n+\t      return \"adds.w %2,%0\";\n+\t    /* Fall through.  */\n+\t  case CRIS_UNSPEC_PLT:\n+\t  case CRIS_UNSPEC_GOTREL:\n+\t    return \"add.d %2,%0\";\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+      }\n+    case 6:\n       return \"add.d %2,%0\";\n     case 7:\n+      return \"add.d %2,%1,%0\";\n+    case 8:\n       return \"add.d %1,%0\";\n     default:\n       return \"BOGUS addsi %2+%1 to %0\";\n     }\n }\n- [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no,no,yes\")])\n+ [(set_attr \"slottable\" \"yes,yes,yes,yes,no,no,no,no,yes\")])\n \f\n (define_insn \"addhi3\"\n   [(set (match_operand:HI 0 \"register_operand\"\t\t\"=r,r, r,r,r,r\")\n@@ -2551,7 +2634,7 @@\n (define_insn \"uminsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"\t\t \"=r,r, r,r\")\n \t(umin:SI  (match_operand:SI 1 \"register_operand\" \"%0,0, 0,r\")\n-\t\t  (match_operand:SI 2 \"general_operand\"   \"r,Q>,g,!STo\")))]\n+\t\t  (match_operand:SI 2 \"general_operand\"   \"r,Q>,g,!To\")))]\n   \"\"\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n@@ -2762,100 +2845,50 @@\n \t      (clobber (reg:SI CRIS_SRP_REGNUM))])]\n   \"\"\n {\n-  rtx op0;\n-\n   gcc_assert (GET_CODE (operands[0]) == MEM);\n-\n   if (flag_pic)\n-    {\n-      op0 = XEXP (operands[0], 0);\n-\n-      /* It might be that code can be generated that jumps to 0 (or to a\n-\t specific address).  Don't die on that.  (There is a testcase.)  */\n-      if (CONSTANT_ADDRESS_P (op0) && GET_CODE (op0) != CONST_INT)\n-\t{\n-\t  CRIS_ASSERT (!no_new_pseudos);\n-\n-\t  /* For local symbols (non-PLT), get the plain symbol reference\n-\t     into a register.  For symbols that can be PLT, make them PLT.  */\n-\t  if (cris_gotless_symbol (op0) || GET_CODE (op0) != SYMBOL_REF)\n-\t    op0 = force_reg (Pmode, op0);\n-\t  else if (cris_symbol (op0))\n-\t    /* FIXME: Would hanging a REG_EQUIV/EQUAL on that register\n-\t       for the symbol cause bad recombinatorial effects?  */\n-\t    op0 = force_reg (Pmode,\n-\t\t\t     gen_rtx_CONST\n-\t\t\t     (Pmode,\n-\t\t\t      gen_rtx_UNSPEC (VOIDmode,\n-\t\t\t\t\t      gen_rtvec (1, op0),\n-\t\t\t\t\t      CRIS_UNSPEC_PLT)));\n-\t  else\n-\t    internal_error (\"Unidentifiable op0\");\n-\n-\t  operands[0] = replace_equiv_address (operands[0], op0);\n-\t}\n-    }\n+    cris_expand_pic_call_address (&operands[0]);\n })\n \n ;; Accept *anything* as operand 1.  Accept operands for operand 0 in\n ;; order of preference.\n \n (define_insn \"*expanded_call\"\n-  [(call (mem:QI (match_operand:SI\n-\t\t  0 \"cris_general_operand_or_plt_symbol\" \"r,Q>,g,S\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (clobber (reg:SI CRIS_SRP_REGNUM))]\n-  \"! TARGET_AVOID_GOTPLT\"\n-  \"jsr %0\")\n-\n-;; Same as above, since can't afford wasting a constraint letter to mean\n-;; \"S unless TARGET_AVOID_GOTPLT\".\n-(define_insn \"*expanded_call_no_gotplt\"\n   [(call (mem:QI (match_operand:SI\n \t\t  0 \"cris_general_operand_or_plt_symbol\" \"r,Q>,g\"))\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:SI CRIS_SRP_REGNUM))]\n-  \"TARGET_AVOID_GOTPLT\"\n+  \"\"\n   \"jsr %0\")\n \n+;; Parallel when calculating and reusing address of indirect pointer\n+;; with simple offset.  (Makes most sense with PIC.)  It looks a bit\n+;; wrong not to have the clobber last, but that's the way combine\n+;; generates it (except it doesn' look into the *inner* mem, so this\n+;; just matches a peephole2).  FIXME: investigate that.\n+(define_insn \"*expanded_call_side\"\n+  [(call (mem:QI\n+\t  (mem:SI\n+\t   (plus:SI (match_operand:SI 0 \"cris_bdap_operand\" \"%r,  r,r\")\n+\t\t    (match_operand:SI 1 \"cris_bdap_operand\" \"r>Rn,r,>Rn\"))))\n+\t (match_operand 2 \"\" \"\"))\n+   (clobber (reg:SI CRIS_SRP_REGNUM))\n+   (set (match_operand:SI 3 \"register_operand\" \"=*0,r,r\")\n+\t(plus:SI (match_dup 0)\n+\t\t (match_dup 1)))]\n+  \"! TARGET_AVOID_GOTPLT\"\n+  \"jsr [%3=%0%S1]\")\n+\n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n \t\t   (call (match_operand:QI 1 \"cris_mem_call_operand\" \"\")\n \t\t\t (match_operand 2 \"\" \"\")))\n \t      (clobber (reg:SI CRIS_SRP_REGNUM))])]\n   \"\"\n {\n-  rtx op1;\n-\n   gcc_assert (GET_CODE (operands[1]) == MEM);\n-\n   if (flag_pic)\n-    {\n-      op1 = XEXP (operands[1], 0);\n-\n-      /* It might be that code can be generated that jumps to 0 (or to a\n-\t specific address).  Don't die on that.  (There is a testcase.)  */\n-      if (CONSTANT_ADDRESS_P (op1) && GET_CODE (op1) != CONST_INT)\n-\t{\n-\t  CRIS_ASSERT (!no_new_pseudos);\n-\n-\t  if (cris_gotless_symbol (op1))\n-\t    op1 = force_reg (Pmode, op1);\n-\t  else if (cris_symbol (op1))\n-\t    /* FIXME: Would hanging a REG_EQUIV/EQUAL on that register\n-\t       for the symbol cause bad recombinatorial effects?  */\n-\t    op1 = force_reg (Pmode,\n-\t\t\t     gen_rtx_CONST\n-\t\t\t     (Pmode,\n-\t\t\t      gen_rtx_UNSPEC (VOIDmode,\n-\t\t\t\t\t      gen_rtvec (1, op1),\n-\t\t\t\t\t      CRIS_UNSPEC_PLT)));\n-\t  else\n-\t    internal_error (\"Unidentifiable op0\");\n-\n-\t  operands[1] = replace_equiv_address (operands[1], op1);\n-\t}\n-    }\n+    cris_expand_pic_call_address (&operands[1]);\n })\n \n ;; Accept *anything* as operand 2.  The validity other than \"general\" of\n@@ -2865,25 +2898,30 @@\n ;; than requiring getting rPIC + sym:PLT into a register.\n \n (define_insn \"*expanded_call_value\"\n-  [(set (match_operand 0 \"nonimmediate_operand\" \"=g,g,g,g\")\n+  [(set (match_operand 0 \"nonimmediate_operand\" \"=g,g,g\")\n \t(call (mem:QI (match_operand:SI\n-\t\t       1 \"cris_general_operand_or_plt_symbol\" \"r,Q>,g,S\"))\n+\t\t       1 \"cris_general_operand_or_plt_symbol\" \"r,Q>,g\"))\n \t      (match_operand 2 \"\" \"\")))\n    (clobber (reg:SI CRIS_SRP_REGNUM))]\n-  \"! TARGET_AVOID_GOTPLT\"\n+  \"\"\n   \"Jsr %1\"\n   [(set_attr \"cc\" \"clobber\")])\n \n-;; Same as above, since can't afford wasting a constraint letter to mean\n-;; \"S unless TARGET_AVOID_GOTPLT\".\n-(define_insn \"*expanded_call_value_no_gotplt\"\n+;; See similar call special-case.\n+(define_insn \"*expanded_call_value_side\"\n   [(set (match_operand 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(call (mem:QI (match_operand:SI\n-\t\t       1 \"cris_general_operand_or_plt_symbol\" \"r,Q>,g\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (clobber (reg:SI CRIS_SRP_REGNUM))]\n-  \"TARGET_AVOID_GOTPLT\"\n-  \"Jsr %1\"\n+\t(call\n+\t (mem:QI\n+\t  (mem:SI\n+\t   (plus:SI (match_operand:SI 1 \"cris_bdap_operand\" \"%r,  r,r\")\n+\t\t    (match_operand:SI 2 \"cris_bdap_operand\" \"r>Rn,r,>Rn\"))))\n+\t      (match_operand 3 \"\" \"\")))\n+   (clobber (reg:SI CRIS_SRP_REGNUM))\n+   (set (match_operand:SI 4 \"register_operand\" \"=*1,r,r\")\n+\t(plus:SI (match_dup 1)\n+\t\t (match_dup 2)))]\n+  \"! TARGET_AVOID_GOTPLT\"\n+  \"Jsr [%4=%1%S2]\"\n   [(set_attr \"cc\" \"clobber\")])\n \n ;; Used in debugging.  No use for the direct pattern; unfilled\n@@ -3961,6 +3999,126 @@\n \t\t\t\t\t\tamode == SImode\n \t\t\t\t\t\t? QImode : amode)));\n })\n+\n+;; Try and avoid GOTPLT reads escaping a call: transform them into\n+;; PLT.  Curiously (but thankfully), peepholes for instructions\n+;; *without side-effects* that just feed a call (or call_value) are\n+;; not matched neither in a build or test-suite, so those patterns are\n+;; omitted.\n+\n+;; A \"normal\" move where we don't check the consumer.\n+\n+(define_peephole2 ; gotplt-to-plt\n+  [(set\n+    (match_operand:SI 0 \"register_operand\" \"\")\n+    (match_operator:SI\n+     1 \"cris_mem_op\"\n+     [(plus:SI\n+       (reg:SI CRIS_GOT_REGNUM)\n+       (const:SI\n+\t(unspec:SI [(match_operand:SI 2 \"cris_general_operand_or_symbol\" \"\")]\n+\t\t   CRIS_UNSPEC_PLTGOTREAD)))]))]\n+  \"flag_pic\n+   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1))\n+   && REGNO_REG_CLASS (REGNO (operands[0])) == REGNO_REG_CLASS (0)\"\n+  [(set (match_dup 0) (const:SI (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLT)))\n+   (set (match_dup 0) (plus:SI (match_dup 0) (reg:SI CRIS_GOT_REGNUM)))]\n+  \"\")\n+\n+;; And one set with a side-effect getting the PLTGOT offset.\n+;; First call and call_value variants.\n+\n+(define_peephole2 ; gotplt-to-plt-side-call\n+  [(parallel\n+    [(set\n+      (match_operand:SI 0 \"register_operand\" \"\")\n+      (match_operator:SI\n+       1 \"cris_mem_op\"\n+       [(plus:SI\n+\t (reg:SI CRIS_GOT_REGNUM)\n+\t (const:SI\n+\t  (unspec:SI [(match_operand:SI\n+\t\t       2 \"cris_general_operand_or_symbol\" \"\")]\n+\t\t     CRIS_UNSPEC_PLTGOTREAD)))]))\n+     (set (match_operand:SI 3 \"register_operand\" \"\")\n+\t  (plus:SI (reg:SI CRIS_GOT_REGNUM)\n+\t\t   (const:SI\n+\t\t    (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLTGOTREAD))))])\n+  (parallel [(call (mem:QI (match_dup 0))\n+\t\t    (match_operand 4 \"\" \"\"))\n+\t      (clobber (reg:SI CRIS_SRP_REGNUM))])]\n+  \"flag_pic\n+   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1))\n+   && peep2_reg_dead_p (2, operands[0])\"\n+  [(parallel [(call (mem:QI (match_dup 1))\n+\t\t    (match_dup 4))\n+\t      (clobber (reg:SI CRIS_SRP_REGNUM))\n+\t      (set (match_dup 3)\n+\t\t   (plus:SI (reg:SI CRIS_GOT_REGNUM)\n+\t\t\t    (const:SI\n+\t\t\t     (unspec:SI [(match_dup 2)]\n+\t\t\t\t\tCRIS_UNSPEC_PLTGOTREAD))))])]\n+  \"\")\n+\n+(define_peephole2 ; gotplt-to-plt-side-call-value\n+  [(parallel\n+    [(set\n+      (match_operand:SI 0 \"register_operand\" \"\")\n+      (match_operator:SI\n+       1 \"cris_mem_op\"\n+       [(plus:SI\n+\t (reg:SI CRIS_GOT_REGNUM)\n+\t (const:SI\n+\t  (unspec:SI [(match_operand:SI\n+\t\t       2 \"cris_general_operand_or_symbol\" \"\")]\n+\t\t     CRIS_UNSPEC_PLTGOTREAD)))]))\n+     (set (match_operand:SI 3 \"register_operand\" \"\")\n+\t  (plus:SI (reg:SI CRIS_GOT_REGNUM)\n+\t\t   (const:SI\n+\t\t    (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLTGOTREAD))))])\n+   (parallel [(set (match_operand 5 \"\" \"\")\n+\t\t   (call (mem:QI (match_dup 0))\n+\t\t\t (match_operand 4 \"\" \"\")))\n+\t      (clobber (reg:SI CRIS_SRP_REGNUM))])]\n+  \"flag_pic\n+   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1))\n+   && peep2_reg_dead_p (2, operands[0])\"\n+  [(parallel [(set (match_dup 5)\n+\t\t   (call (mem:QI (match_dup 1))\n+\t\t\t (match_dup 4)))\n+\t      (clobber (reg:SI CRIS_SRP_REGNUM))\n+\t      (set (match_dup 3)\n+\t\t   (plus:SI (reg:SI CRIS_GOT_REGNUM)\n+\t\t\t    (const:SI\n+\t\t\t     (unspec:SI [(match_dup 2)]\n+\t\t\t\t\tCRIS_UNSPEC_PLTGOTREAD))))])]\n+  \"\")\n+\n+(define_peephole2 ; gotplt-to-plt-side\n+  [(parallel\n+    [(set\n+      (match_operand:SI 0 \"register_operand\" \"\")\n+      (match_operator:SI\n+       1 \"cris_mem_op\"\n+       [(plus:SI\n+\t (reg:SI CRIS_GOT_REGNUM)\n+\t (const:SI\n+\t  (unspec:SI [(match_operand:SI\n+\t\t       2 \"cris_general_operand_or_symbol\" \"\")]\n+\t\t     CRIS_UNSPEC_PLTGOTREAD)))]))\n+     (set (match_operand:SI 3 \"register_operand\" \"\")\n+\t  (plus:SI (reg:SI CRIS_GOT_REGNUM)\n+\t\t   (const:SI\n+\t\t    (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLTGOTREAD))))])]\n+  \"flag_pic\n+   && cris_valid_pic_const (XEXP (XEXP (operands[1], 0), 1))\n+   && REGNO_REG_CLASS (REGNO (operands[0])) == REGNO_REG_CLASS (0)\"\n+  [(set (match_dup 3)\n+\t(const:SI (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLTGOTREAD)))\n+   (set (match_dup 3) (plus:SI (match_dup 3) (reg:SI CRIS_GOT_REGNUM)))\n+   (set (match_dup 0) (const:SI (unspec:SI [(match_dup 2)] CRIS_UNSPEC_PLT)))\n+   (set (match_dup 0) (plus:SI (match_dup 0) (reg:SI CRIS_GOT_REGNUM)))]\n+  \"\")\n \f\n ;; Local variables:\n ;; mode:emacs-lisp"}, {"sha": "90fab8dd7d7a149c59c14e95d4b49383464c5dad", "filename": "gcc/config/cris/predicates.md", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0/gcc%2Fconfig%2Fcris%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0/gcc%2Fconfig%2Fcris%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fpredicates.md?ref=c00fc5cf8b1979cd4a9200ec05593f2dba9f1eb0", "patch": "@@ -63,8 +63,8 @@\n \n (define_predicate \"cris_bdap_const_operand\"\n   (and (match_code \"label_ref, symbol_ref, const_int, const_double, const\")\n-       (not (and (match_test \"flag_pic\")\n-\t\t (match_test \"cris_symbol (op)\")))))\n+       (ior (not (match_test \"flag_pic\"))\n+\t    (match_test \"cris_valid_pic_const (op)\"))))\n \n (define_predicate \"cris_simple_address_operand\"\n   (ior (match_operand:SI 0 \"register_operand\")\n@@ -127,16 +127,6 @@\n   (ior (match_operand 0 \"cris_bdap_operand\")\n        (match_operand 0 \"cris_biap_mult_operand\")))\n \n-;; Since a PIC symbol without a GOT entry is not a general_operand, we\n-;; have to have a predicate that matches it.  We use this in the expanded\n-;; \"movsi\" anonymous pattern.\n-;; FIXME: Can s/special_// when PR 20413 is fixed.\n-\n-(define_special_predicate \"cris_general_operand_or_gotless_symbol\"\n-  (ior (match_operand 0 \"general_operand\")\n-       (and (match_code \"const, symbol_ref, label_ref, unspec\")\n-\t    (match_test \"cris_gotless_symbol (op)\"))))\n-\n ;; Since with -fPIC, not all symbols are valid PIC symbols or indeed\n ;; general_operands, we have to have a predicate that matches it for the\n ;; \"movsi\" expander.\n@@ -145,7 +135,8 @@\n (define_special_predicate \"cris_general_operand_or_symbol\"\n   (ior (match_operand 0 \"general_operand\")\n        (and (match_code \"const, symbol_ref, label_ref\")\n-\t    (match_test \"cris_symbol (op)\"))))\n+       \t    ; The following test is actually just an assertion.\n+\t    (match_test \"cris_pic_symbol_type_of (op) != cris_no_symbol\"))))\n \n ;; Since a PLT symbol is not a general_operand, we have to have a\n ;; predicate that matches it when we need it.  We use this in the expanded"}]}