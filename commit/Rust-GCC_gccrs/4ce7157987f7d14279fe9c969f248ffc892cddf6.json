{"sha": "4ce7157987f7d14279fe9c969f248ffc892cddf6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNlNzE1Nzk4N2Y3ZDE0Mjc5ZmU5Yzk2OWYyNDhmZmM4OTJjZGRmNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-10-27T18:51:28Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-10-27T18:51:28Z"}, "message": "re PR middle-end/78025 (ICE in simd_clone_adjust, at omp-simd-clone.c:1126)\n\n\tPR middle-end/78025\n\t* omp-simd-clone.c (simd_clone_adjust): Handle noreturn declare simd\n\tfunctions.\n\n\t* g++.dg/gomp/declare-simd-7.C: New test.\n\nFrom-SVN: r241628", "tree": {"sha": "25181c138703f1c636c8a71bc66857d4cae3bf55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25181c138703f1c636c8a71bc66857d4cae3bf55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ce7157987f7d14279fe9c969f248ffc892cddf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce7157987f7d14279fe9c969f248ffc892cddf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ce7157987f7d14279fe9c969f248ffc892cddf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ce7157987f7d14279fe9c969f248ffc892cddf6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "015c776064d1ea93a71730ba4c3bad43675656ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/015c776064d1ea93a71730ba4c3bad43675656ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/015c776064d1ea93a71730ba4c3bad43675656ea"}], "stats": {"total": 287, "additions": 194, "deletions": 93}, "files": [{"sha": "4d0b993f4acb36b069ceb94d3d3fc19270ceec52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce7157987f7d14279fe9c969f248ffc892cddf6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce7157987f7d14279fe9c969f248ffc892cddf6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ce7157987f7d14279fe9c969f248ffc892cddf6", "patch": "@@ -1,3 +1,9 @@\n+2016-10-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/78025\n+\t* omp-simd-clone.c (simd_clone_adjust): Handle noreturn declare simd\n+\tfunctions.\n+\n 2016-10-27  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* builtins.c (expand_builtin_nonlocal_goto): Avoid evaluating"}, {"sha": "50bce671b994c5dc95ab8b4dec537ac3fb9026aa", "filename": "gcc/omp-simd-clone.c", "status": "modified", "additions": 133, "deletions": 93, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce7157987f7d14279fe9c969f248ffc892cddf6/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce7157987f7d14279fe9c969f248ffc892cddf6/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=4ce7157987f7d14279fe9c969f248ffc892cddf6", "patch": "@@ -1107,7 +1107,7 @@ simd_clone_adjust (struct cgraph_node *node)\n      return values accordingly.  */\n   tree iter = create_tmp_var (unsigned_type_node, \"iter\");\n   tree iter1 = make_ssa_name (iter);\n-  tree iter2 = make_ssa_name (iter);\n+  tree iter2 = NULL_TREE;\n   ipa_simd_modify_function_body (node, adjustments, retval, iter1);\n   adjustments.release ();\n \n@@ -1121,39 +1121,57 @@ simd_clone_adjust (struct cgraph_node *node)\n \n   pop_gimplify_context (NULL);\n \n+  gimple *g;\n+  basic_block incr_bb = NULL;\n+  struct loop *loop = NULL;\n+\n   /* Create a new BB right before the original exit BB, to hold the\n      iteration increment and the condition/branch.  */\n-  basic_block orig_exit = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), 0)->src;\n-  basic_block incr_bb = create_empty_bb (orig_exit);\n-  add_bb_to_loop (incr_bb, body_bb->loop_father);\n-  /* The succ of orig_exit was EXIT_BLOCK_PTR_FOR_FN (cfun), with an empty\n-     flag.  Set it now to be a FALLTHRU_EDGE.  */\n-  gcc_assert (EDGE_COUNT (orig_exit->succs) == 1);\n-  EDGE_SUCC (orig_exit, 0)->flags |= EDGE_FALLTHRU;\n-  for (unsigned i = 0;\n-       i < EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds); ++i)\n+  if (EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds))\n+    {\n+      basic_block orig_exit = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), 0)->src;\n+      incr_bb = create_empty_bb (orig_exit);\n+      add_bb_to_loop (incr_bb, body_bb->loop_father);\n+      /* The succ of orig_exit was EXIT_BLOCK_PTR_FOR_FN (cfun), with an empty\n+\t flag.  Set it now to be a FALLTHRU_EDGE.  */\n+      gcc_assert (EDGE_COUNT (orig_exit->succs) == 1);\n+      EDGE_SUCC (orig_exit, 0)->flags |= EDGE_FALLTHRU;\n+      for (unsigned i = 0;\n+\t   i < EDGE_COUNT (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds); ++i)\n+\t{\n+\t  edge e = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), i);\n+\t  redirect_edge_succ (e, incr_bb);\n+\t}\n+    }\n+  else if (node->simdclone->inbranch)\n+    {\n+      incr_bb = create_empty_bb (entry_bb);\n+      add_bb_to_loop (incr_bb, body_bb->loop_father);\n+    }\n+\n+  if (incr_bb)\n     {\n-      edge e = EDGE_PRED (EXIT_BLOCK_PTR_FOR_FN (cfun), i);\n-      redirect_edge_succ (e, incr_bb);\n+      edge e = make_edge (incr_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n+      e->probability = REG_BR_PROB_BASE;\n+      gsi = gsi_last_bb (incr_bb);\n+      iter2 = make_ssa_name (iter);\n+      g = gimple_build_assign (iter2, PLUS_EXPR, iter1,\n+\t\t\t       build_int_cst (unsigned_type_node, 1));\n+      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+\n+      /* Mostly annotate the loop for the vectorizer (the rest is done\n+\t below).  */\n+      loop = alloc_loop ();\n+      cfun->has_force_vectorize_loops = true;\n+      loop->safelen = node->simdclone->simdlen;\n+      loop->force_vectorize = true;\n+      loop->header = body_bb;\n     }\n-  edge e = make_edge (incr_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n-  e->probability = REG_BR_PROB_BASE;\n-  gsi = gsi_last_bb (incr_bb);\n-  gimple *g = gimple_build_assign (iter2, PLUS_EXPR, iter1,\n-\t\t\t\t   build_int_cst (unsigned_type_node, 1));\n-  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-\n-  /* Mostly annotate the loop for the vectorizer (the rest is done below).  */\n-  struct loop *loop = alloc_loop ();\n-  cfun->has_force_vectorize_loops = true;\n-  loop->safelen = node->simdclone->simdlen;\n-  loop->force_vectorize = true;\n-  loop->header = body_bb;\n \n   /* Branch around the body if the mask applies.  */\n   if (node->simdclone->inbranch)\n     {\n-      gimple_stmt_iterator gsi = gsi_last_bb (loop->header);\n+      gsi = gsi_last_bb (loop->header);\n       tree mask_array\n \t= node->simdclone->args[node->simdclone->nargs - 1].simd_array;\n       tree mask;\n@@ -1227,50 +1245,59 @@ simd_clone_adjust (struct cgraph_node *node)\n       FALLTHRU_EDGE (loop->header)->flags = EDGE_FALSE_VALUE;\n     }\n \n+  basic_block latch_bb = NULL;\n+  basic_block new_exit_bb = NULL;\n+\n   /* Generate the condition.  */\n-  g = gimple_build_cond (LT_EXPR,\n-\t\t\t iter2,\n-\t\t\t build_int_cst (unsigned_type_node,\n-\t\t\t\t\tnode->simdclone->simdlen),\n-\t\t\t NULL, NULL);\n-  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n-  e = split_block (incr_bb, gsi_stmt (gsi));\n-  basic_block latch_bb = e->dest;\n-  basic_block new_exit_bb;\n-  new_exit_bb = split_block_after_labels (latch_bb)->dest;\n-  loop->latch = latch_bb;\n-\n-  redirect_edge_succ (FALLTHRU_EDGE (latch_bb), body_bb);\n-\n-  make_edge (incr_bb, new_exit_bb, EDGE_FALSE_VALUE);\n-  /* The successor of incr_bb is already pointing to latch_bb; just\n-     change the flags.\n-     make_edge (incr_bb, latch_bb, EDGE_TRUE_VALUE);  */\n-  FALLTHRU_EDGE (incr_bb)->flags = EDGE_TRUE_VALUE;\n+  if (incr_bb)\n+    {\n+      gsi = gsi_last_bb (incr_bb);\n+      g = gimple_build_cond (LT_EXPR, iter2,\n+\t\t\t     build_int_cst (unsigned_type_node,\n+\t\t\t\t\t    node->simdclone->simdlen),\n+\t\t\t     NULL, NULL);\n+      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n+      edge e = split_block (incr_bb, gsi_stmt (gsi));\n+      latch_bb = e->dest;\n+      new_exit_bb = split_block_after_labels (latch_bb)->dest;\n+      loop->latch = latch_bb;\n+\n+      redirect_edge_succ (FALLTHRU_EDGE (latch_bb), body_bb);\n+\n+      make_edge (incr_bb, new_exit_bb, EDGE_FALSE_VALUE);\n+      /* The successor of incr_bb is already pointing to latch_bb; just\n+\t change the flags.\n+\t make_edge (incr_bb, latch_bb, EDGE_TRUE_VALUE);  */\n+      FALLTHRU_EDGE (incr_bb)->flags = EDGE_TRUE_VALUE;\n+    }\n \n   gphi *phi = create_phi_node (iter1, body_bb);\n   edge preheader_edge = find_edge (entry_bb, body_bb);\n-  edge latch_edge = single_succ_edge (latch_bb);\n+  edge latch_edge = NULL;\n   add_phi_arg (phi, build_zero_cst (unsigned_type_node), preheader_edge,\n \t       UNKNOWN_LOCATION);\n-  add_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);\n-\n-  /* Generate the new return.  */\n-  gsi = gsi_last_bb (new_exit_bb);\n-  if (retval\n-      && TREE_CODE (retval) == VIEW_CONVERT_EXPR\n-      && TREE_CODE (TREE_OPERAND (retval, 0)) == RESULT_DECL)\n-    retval = TREE_OPERAND (retval, 0);\n-  else if (retval)\n+  if (incr_bb)\n     {\n-      retval = build1 (VIEW_CONVERT_EXPR,\n-\t\t       TREE_TYPE (TREE_TYPE (node->decl)),\n-\t\t       retval);\n-      retval = force_gimple_operand_gsi (&gsi, retval, true, NULL,\n-\t\t\t\t\t false, GSI_CONTINUE_LINKING);\n+      latch_edge = single_succ_edge (latch_bb);\n+      add_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);\n+\n+      /* Generate the new return.  */\n+      gsi = gsi_last_bb (new_exit_bb);\n+      if (retval\n+\t  && TREE_CODE (retval) == VIEW_CONVERT_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (retval, 0)) == RESULT_DECL)\n+\tretval = TREE_OPERAND (retval, 0);\n+      else if (retval)\n+\t{\n+\t  retval = build1 (VIEW_CONVERT_EXPR,\n+\t\t\t   TREE_TYPE (TREE_TYPE (node->decl)),\n+\t\t\t   retval);\n+\t  retval = force_gimple_operand_gsi (&gsi, retval, true, NULL,\n+\t\t\t\t\t     false, GSI_CONTINUE_LINKING);\n+\t}\n+      g = gimple_build_return (retval);\n+      gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n     }\n-  g = gimple_build_return (retval);\n-  gsi_insert_after (&gsi, g, GSI_CONTINUE_LINKING);\n \n   /* Handle aligned clauses by replacing default defs of the aligned\n      uniform args with __builtin_assume_aligned (arg_N(D), alignment)\n@@ -1386,7 +1413,8 @@ simd_clone_adjust (struct cgraph_node *node)\n \t  {\n \t    def = make_ssa_name (TREE_TYPE (orig_arg));\n \t    iter1 = make_ssa_name (TREE_TYPE (orig_arg));\n-\t    iter2 = make_ssa_name (TREE_TYPE (orig_arg));\n+\t    if (incr_bb)\n+\t      iter2 = make_ssa_name (TREE_TYPE (orig_arg));\n \t    gsi = gsi_after_labels (entry_bb);\n \t    g = gimple_build_assign (def, orig_arg);\n \t    gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n@@ -1399,23 +1427,27 @@ simd_clone_adjust (struct cgraph_node *node)\n \t    else\n \t      {\n \t\titer1 = make_ssa_name (orig_arg);\n-\t\titer2 = make_ssa_name (orig_arg);\n+\t\tif (incr_bb)\n+\t\t  iter2 = make_ssa_name (orig_arg);\n \t      }\n \t  }\n \tif (def)\n \t  {\n \t    phi = create_phi_node (iter1, body_bb);\n \t    add_phi_arg (phi, def, preheader_edge, UNKNOWN_LOCATION);\n-\t    add_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);\n-\t    enum tree_code code = INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n-\t\t\t\t  ? PLUS_EXPR : POINTER_PLUS_EXPR;\n-\t    tree addtype = INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n-\t\t\t   ? TREE_TYPE (orig_arg) : sizetype;\n-\t    tree addcst = simd_clone_linear_addend (node, i, addtype,\n-\t\t\t\t\t\t    entry_bb);\n-\t    gsi = gsi_last_bb (incr_bb);\n-\t    g = gimple_build_assign (iter2, code, iter1, addcst);\n-\t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t    if (incr_bb)\n+\t      {\n+\t\tadd_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);\n+\t\tenum tree_code code = INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n+\t\t\t\t      ? PLUS_EXPR : POINTER_PLUS_EXPR;\n+\t\ttree addtype = INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n+\t\t\t       ? TREE_TYPE (orig_arg) : sizetype;\n+\t\ttree addcst = simd_clone_linear_addend (node, i, addtype,\n+\t\t\t\t\t\t\tentry_bb);\n+\t\tgsi = gsi_last_bb (incr_bb);\n+\t\tg = gimple_build_assign (iter2, code, iter1, addcst);\n+\t\tgsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t      }\n \n \t    imm_use_iterator iter;\n \t    use_operand_p use_p;\n@@ -1448,10 +1480,11 @@ simd_clone_adjust (struct cgraph_node *node)\n \t  {\n \t    tree rtype = TREE_TYPE (TREE_TYPE (orig_arg));\n \t    iter1 = make_ssa_name (orig_arg);\n-\t    iter2 = make_ssa_name (orig_arg);\n+\t    if (incr_bb)\n+\t      iter2 = make_ssa_name (orig_arg);\n \t    tree iter3 = make_ssa_name (rtype);\n \t    tree iter4 = make_ssa_name (rtype);\n-\t    tree iter5 = make_ssa_name (rtype);\n+\t    tree iter5 = incr_bb ? make_ssa_name (rtype) : NULL_TREE;\n \t    gsi = gsi_after_labels (entry_bb);\n \t    gimple *load\n \t      = gimple_build_assign (iter3, build_simple_mem_ref (def));\n@@ -1462,24 +1495,30 @@ simd_clone_adjust (struct cgraph_node *node)\n \t    tree ptr = build_fold_addr_expr (array);\n \t    phi = create_phi_node (iter1, body_bb);\n \t    add_phi_arg (phi, ptr, preheader_edge, UNKNOWN_LOCATION);\n-\t    add_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);\n-\t    g = gimple_build_assign (iter2, POINTER_PLUS_EXPR, iter1,\n-\t\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (iter3)));\n-\t    gsi = gsi_last_bb (incr_bb);\n-\t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t    if (incr_bb)\n+\t      {\n+\t\tadd_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);\n+\t\tg = gimple_build_assign (iter2, POINTER_PLUS_EXPR, iter1,\n+\t\t\t\t\t TYPE_SIZE_UNIT (TREE_TYPE (iter3)));\n+\t\tgsi = gsi_last_bb (incr_bb);\n+\t\tgsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t      }\n \n \t    phi = create_phi_node (iter4, body_bb);\n \t    add_phi_arg (phi, iter3, preheader_edge, UNKNOWN_LOCATION);\n-\t    add_phi_arg (phi, iter5, latch_edge, UNKNOWN_LOCATION);\n-\t    enum tree_code code = INTEGRAL_TYPE_P (TREE_TYPE (iter3))\n-\t\t\t\t  ? PLUS_EXPR : POINTER_PLUS_EXPR;\n-\t    tree addtype = INTEGRAL_TYPE_P (TREE_TYPE (iter3))\n-\t\t\t   ? TREE_TYPE (iter3) : sizetype;\n-\t    tree addcst = simd_clone_linear_addend (node, i, addtype,\n-\t\t\t\t\t\t    entry_bb);\n-\t    g = gimple_build_assign (iter5, code, iter4, addcst);\n-\t    gsi = gsi_last_bb (incr_bb);\n-\t    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t    if (incr_bb)\n+\t      {\n+\t\tadd_phi_arg (phi, iter5, latch_edge, UNKNOWN_LOCATION);\n+\t\tenum tree_code code = INTEGRAL_TYPE_P (TREE_TYPE (iter3))\n+\t\t\t\t      ? PLUS_EXPR : POINTER_PLUS_EXPR;\n+\t\ttree addtype = INTEGRAL_TYPE_P (TREE_TYPE (iter3))\n+\t\t\t       ? TREE_TYPE (iter3) : sizetype;\n+\t\ttree addcst = simd_clone_linear_addend (node, i, addtype,\n+\t\t\t\t\t\t\tentry_bb);\n+\t\tg = gimple_build_assign (iter5, code, iter4, addcst);\n+\t\tgsi = gsi_last_bb (incr_bb);\n+\t\tgsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t      }\n \n \t    g = gimple_build_assign (build_simple_mem_ref (iter1), iter4);\n \t    gsi = gsi_after_labels (body_bb);\n@@ -1495,7 +1534,7 @@ simd_clone_adjust (struct cgraph_node *node)\n \t\tFOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n \t\t  SET_USE (use_p, iter1);\n \n-\t    if (!TYPE_READONLY (rtype))\n+\t    if (!TYPE_READONLY (rtype) && incr_bb)\n \t      {\n \t\ttree v = make_ssa_name (rtype);\n \t\ttree aref = build4 (ARRAY_REF, rtype, array,\n@@ -1511,7 +1550,8 @@ simd_clone_adjust (struct cgraph_node *node)\n       }\n \n   calculate_dominance_info (CDI_DOMINATORS);\n-  add_loop (loop, loop->header->loop_father);\n+  if (loop)\n+    add_loop (loop, loop->header->loop_father);\n   update_ssa (TODO_update_ssa);\n \n   pop_cfun ();"}, {"sha": "9ce3f6416979dfdfceb24c5e24dc9c395af1be87", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce7157987f7d14279fe9c969f248ffc892cddf6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce7157987f7d14279fe9c969f248ffc892cddf6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4ce7157987f7d14279fe9c969f248ffc892cddf6", "patch": "@@ -1,3 +1,8 @@\n+2016-10-27  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/78025\n+\t* g++.dg/gomp/declare-simd-7.C: New test.\n+\n 2016-10-27  Fritz Reese <fritzoreese@gmail.com>\n \n \t* gfortran.dg/dec_init_1.f90: Remove -fdump-tree-original."}, {"sha": "52e9f182da35c920d78e64da8ee56cfdabaea541", "filename": "gcc/testsuite/g++.dg/gomp/declare-simd-7.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ce7157987f7d14279fe9c969f248ffc892cddf6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ce7157987f7d14279fe9c969f248ffc892cddf6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fdeclare-simd-7.C?ref=4ce7157987f7d14279fe9c969f248ffc892cddf6", "patch": "@@ -0,0 +1,50 @@\n+// PR middle-end/78025\n+// { dg-do compile }\n+// { dg-additional-options \"-O2\" }\n+\n+struct S { S (); ~S (); };\n+\n+int bar1 (int, int, float &, S &, int *, int, int &, int &, int &, int &, int &);\n+int bar2 (int, int, float &, S &, int *, int, int &, int &, int &, int &, int &);\n+int bar3 (int, int, float &, S &, int *, int, int &, int &, int &, int &, int &) __attribute__((noreturn));\n+int bar4 (int, int, float &, S &, int *, int, int &, int &, int &, int &, int &) __attribute__((noreturn));\n+\n+#pragma omp declare simd notinbranch uniform (b, c, d, e) aligned (e : 16) \\\n+\t\t    linear (f : 2) linear (ref (g) : 1) \\\n+\t\t    linear (val (h) : 1) linear (uval (i) : 1) \\\n+\t\t    linear (k : 4)\n+int\n+foo1 (int a, int b, float c, S d, int *e, int f, int &g, int &h, int &i, int j, int k)\n+{\n+  return bar1 (a, b, c, d, e, f, g, h, i, j, k);\n+}\n+\n+#pragma omp declare simd inbranch uniform (b, c, d, e) aligned (e : 16) \\\n+\t\t    linear (f : 2) linear (ref (g) : 1) \\\n+\t\t    linear (val (h) : 1) linear (uval (i) : 1) \\\n+\t\t    linear (k : 4)\n+int\n+foo2 (int a, int b, float c, S d, int *e, int f, int &g, int &h, int &i, int j, int k)\n+{\n+  return bar2 (a, b, c, d, e, f, g, h, i, j, k);\n+}\n+\n+#pragma omp declare simd notinbranch uniform (b, c, d, e) aligned (e : 16) \\\n+\t\t    linear (f : 2) linear (ref (g) : 1) \\\n+\t\t    linear (val (h) : 1) linear (uval (i) : 1) \\\n+\t\t    linear (k : 4)\n+int\n+foo3 (int a, int b, float c, S d, int *e, int f, int &g, int &h, int &i, int j, int k)\n+{\n+  return bar3 (a, b, c, d, e, f, g, h, i, j, k);\n+}\n+\n+#pragma omp declare simd inbranch uniform (b, c, d, e) aligned (e : 16) \\\n+\t\t    linear (f : 2) linear (ref (g) : 1) \\\n+\t\t    linear (val (h) : 1) linear (uval (i) : 1) \\\n+\t\t    linear (k : 4)\n+int\n+foo4 (int a, int b, float c, S d, int *e, int f, int &g, int &h, int &i, int j, int k)\n+{\n+  return bar4 (a, b, c, d, e, f, g, h, i, j, k);\n+}"}]}