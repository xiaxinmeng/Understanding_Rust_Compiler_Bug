{"sha": "9d926da5630b8a633a1d25d604f3fb6c9e0271f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ5MjZkYTU2MzBiOGE2MzNhMWQyNWQ2MDRmM2ZiNmM5ZTAyNzFmNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-17T19:51:48Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-17T19:51:48Z"}, "message": "(find_reloads): Properly account for cost when constant is forced to\nmemory to ensure same alternative chosen later.\n\nFrom-SVN: r7319", "tree": {"sha": "131f1a968a221c3f3c402905c548821db1f52d53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/131f1a968a221c3f3c402905c548821db1f52d53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d926da5630b8a633a1d25d604f3fb6c9e0271f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d926da5630b8a633a1d25d604f3fb6c9e0271f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d926da5630b8a633a1d25d604f3fb6c9e0271f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d926da5630b8a633a1d25d604f3fb6c9e0271f7/comments", "author": null, "committer": null, "parents": [{"sha": "a533969946ef38da61a5264d06faba0aedfed216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a533969946ef38da61a5264d06faba0aedfed216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a533969946ef38da61a5264d06faba0aedfed216"}], "stats": {"total": 22, "additions": 18, "deletions": 4}, "files": [{"sha": "afa1072283aee052ac73d5d36436bdf41dd5f00f", "filename": "gcc/reload.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d926da5630b8a633a1d25d604f3fb6c9e0271f7/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d926da5630b8a633a1d25d604f3fb6c9e0271f7/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=9d926da5630b8a633a1d25d604f3fb6c9e0271f7", "patch": "@@ -2530,6 +2530,9 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t     regardless of what the constraint says.  */\n \t  int force_reload = 0;\n \t  int offmemok = 0;\n+\t  /* Nonzero if a constant forced into memory would be OK for this\n+\t     operand.  */\n+\t  int constmemok = 0;\n \t  int earlyclobber = 0;\n \n \t  /* If the operand is a SUBREG, extract\n@@ -2718,6 +2721,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t  win = 1;\n \t\tif (CONSTANT_P (operand))\n \t\t  badop = 0;\n+\t\tconstmemok = 1;\n \t\tbreak;\n \n \t      case '<':\n@@ -2784,6 +2788,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t  win = 1;\n \t\tif (CONSTANT_P (operand) || GET_CODE (operand) == MEM)\n \t\t  badop = 0;\n+\t\tconstmemok = 1;\n \t\toffmemok = 1;\n \t\tbreak;\n \n@@ -2917,6 +2922,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    this_alternative_win[i] = 1;\n \t  else\n \t    {\n+\t      int const_to_mem = 0;\n+\n \t      this_alternative_offmemok[i] = offmemok;\n \t      losers++;\n \t      if (badop)\n@@ -2949,9 +2956,12 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t  && (PREFERRED_RELOAD_CLASS (operand,\n \t\t\t\t\t      (enum reg_class) this_alternative[i])\n \t\t      == NO_REGS)\n-\t\t  && this_alternative[i] != (int) NO_REGS\n \t\t  && operand_mode[i] != VOIDmode)\n-\t\tlosers++;\n+\t\t{\n+\t\t  const_to_mem = 1;\n+\t\t  if (this_alternative[i] != (int) NO_REGS)\n+\t\t    losers++;\n+\t\t}\n \n \t      /* If we can't reload this value at all, reject this\n \t\t alternative.  Note that we could also lose due to\n@@ -2968,10 +2978,14 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t since such reloads may be able to be eliminated later.\n \t\t If we are reloading a SCRATCH, we won't be generating any\n \t\t insns, just using a register, so it is also preferred. \n-\t\t So bump REJECT in other cases.  */\n+\t\t So bump REJECT in other cases.  Don't do this in the\n+\t\t case where we are forcing a constant into memory and\n+\t\t it will then win since we don't want to have a different\n+\t\t alternative match then.  */\n \t      if (! (GET_CODE (operand) == REG\n \t\t     && REGNO (operand) >= FIRST_PSEUDO_REGISTER)\n-\t\t  && GET_CODE (operand) != SCRATCH)\n+\t\t  && GET_CODE (operand) != SCRATCH\n+\t\t  && ! (const_to_mem && constmemok))\n \t\treject++;\n \t    }\n "}]}