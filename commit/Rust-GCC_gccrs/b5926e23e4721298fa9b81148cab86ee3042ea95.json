{"sha": "b5926e23e4721298fa9b81148cab86ee3042ea95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU5MjZlMjNlNDcyMTI5OGZhOWI4MTE0OGNhYjg2ZWUzMDQyZWE5NQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-11-02T13:05:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-11-02T13:05:07Z"}, "message": "gimple-ssa-store-merging.c (struct store_immediate_info): Remove redundant val and dest members.\n\n2016-11-02  Richard Biener  <rguenther@suse.de>\n\n\t* gimple-ssa-store-merging.c (struct store_immediate_info): Remove\n\tredundant val and dest members.\n\t(store_immediate_info::store_immediate_info): Adjust.\n\t(merged_store_group::merged_store_group): Adjust.\n\t(merged_store_group::apply_stores): Likewise.\n\t(struct imm_store_chain_info): Add base_addr field.\n\t(imm_store_chain_info::imm_store_chain_info): New constructor.\n\t(imm_store_chain_info::terminate_and_process_chain): Do not pass base.\n\t(imm_store_chain_info::output_merged_store): Likewise.  Use\n\taddr_base which is already the address.\n\t(imm_store_chain_info::output_merged_stores): Likewise.\n\t(pass_tree_store_merging::terminate_all_aliasing_chains): Take\n\timm_store_chain_info instead of base.  Fix alias check.\n\t(pass_tree_store_merging::terminate_and_release_chain): Likewise.\n\t(imm_store_chain_info::coalesce_immediate_stores): Adjust.\n\t(pass_store_merging::execute): Refuse to operate on TARGET_MEM_REF.\n\tuse the address of the base and adjust for other changes.\n\nFrom-SVN: r241789", "tree": {"sha": "7419a4fc5be4089c9eadb12a00cc32c478ae5116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7419a4fc5be4089c9eadb12a00cc32c478ae5116"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5926e23e4721298fa9b81148cab86ee3042ea95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5926e23e4721298fa9b81148cab86ee3042ea95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5926e23e4721298fa9b81148cab86ee3042ea95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5926e23e4721298fa9b81148cab86ee3042ea95/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4b69fb136e490326a1d7370c92c7d27d2482d253", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b69fb136e490326a1d7370c92c7d27d2482d253", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b69fb136e490326a1d7370c92c7d27d2482d253"}], "stats": {"total": 190, "additions": 103, "deletions": 87}, "files": [{"sha": "054ed535c20d3d8cc4bddec62e758002388a60c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5926e23e4721298fa9b81148cab86ee3042ea95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5926e23e4721298fa9b81148cab86ee3042ea95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5926e23e4721298fa9b81148cab86ee3042ea95", "patch": "@@ -1,3 +1,23 @@\n+2016-11-02  Richard Biener  <rguenther@suse.de>\n+\n+\t* gimple-ssa-store-merging.c (struct store_immediate_info): Remove\n+\tredundant val and dest members.\n+\t(store_immediate_info::store_immediate_info): Adjust.\n+\t(merged_store_group::merged_store_group): Adjust.\n+\t(merged_store_group::apply_stores): Likewise.\n+\t(struct imm_store_chain_info): Add base_addr field.\n+\t(imm_store_chain_info::imm_store_chain_info): New constructor.\n+\t(imm_store_chain_info::terminate_and_process_chain): Do not pass base.\n+\t(imm_store_chain_info::output_merged_store): Likewise.  Use\n+\taddr_base which is already the address.\n+\t(imm_store_chain_info::output_merged_stores): Likewise.\n+\t(pass_tree_store_merging::terminate_all_aliasing_chains): Take\n+\timm_store_chain_info instead of base.  Fix alias check.\n+\t(pass_tree_store_merging::terminate_and_release_chain): Likewise.\n+\t(imm_store_chain_info::coalesce_immediate_stores): Adjust.\n+\t(pass_store_merging::execute): Refuse to operate on TARGET_MEM_REF.\n+\tuse the address of the base and adjust for other changes.\n+\n 2016-11-02  Martin Liska  <mliska@suse.cz>\n \n \t* fold-const-call.c (host_size_t_cst_p): Test whether"}, {"sha": "081620e50f603e2de8ed962aec6c619890ce1e33", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 83, "deletions": 87, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5926e23e4721298fa9b81148cab86ee3042ea95/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5926e23e4721298fa9b81148cab86ee3042ea95/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=b5926e23e4721298fa9b81148cab86ee3042ea95", "patch": "@@ -140,19 +140,17 @@ struct store_immediate_info\n {\n   unsigned HOST_WIDE_INT bitsize;\n   unsigned HOST_WIDE_INT bitpos;\n-  tree val;\n-  tree dest;\n   gimple *stmt;\n   unsigned int order;\n-  store_immediate_info (unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT, tree,\n-\t\t\ttree, gimple *, unsigned int);\n+  store_immediate_info (unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n+\t\t\tgimple *, unsigned int);\n };\n \n store_immediate_info::store_immediate_info (unsigned HOST_WIDE_INT bs,\n-\t\t\t\t\t    unsigned HOST_WIDE_INT bp, tree v,\n-\t\t\t\t\t    tree d, gimple *st,\n+\t\t\t\t\t    unsigned HOST_WIDE_INT bp,\n+\t\t\t\t\t    gimple *st,\n \t\t\t\t\t    unsigned int ord)\n-  : bitsize (bs), bitpos (bp), val (v), dest (d), stmt (st), order (ord)\n+  : bitsize (bs), bitpos (bp), stmt (st), order (ord)\n {\n }\n \n@@ -557,7 +555,7 @@ merged_store_group::merged_store_group (store_immediate_info *info)\n   /* VAL has memory allocated for it in apply_stores once the group\n      width has been finalized.  */\n   val = NULL;\n-  align = get_object_alignment (info->dest);\n+  align = get_object_alignment (gimple_assign_lhs (info->stmt));\n   stores.create (1);\n   stores.safe_push (info);\n   last_stmt = info->stmt;\n@@ -654,14 +652,16 @@ merged_store_group::apply_stores ()\n   FOR_EACH_VEC_ELT (stores, i, info)\n     {\n       unsigned int pos_in_buffer = info->bitpos - start;\n-      bool ret = encode_tree_to_bitpos (info->val, val, info->bitsize,\n-\t\t\t\t\t pos_in_buffer, buf_size);\n+      bool ret = encode_tree_to_bitpos (gimple_assign_rhs1 (info->stmt),\n+\t\t\t\t\tval, info->bitsize,\n+\t\t\t\t\tpos_in_buffer, buf_size);\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  if (ret)\n \t    {\n \t      fprintf (dump_file, \"After writing \");\n-\t      print_generic_expr (dump_file, info->val, 0);\n+\t      print_generic_expr (dump_file,\n+\t\t\t\t  gimple_assign_rhs1 (info->stmt), 0);\n \t      fprintf (dump_file, \" of size \" HOST_WIDE_INT_PRINT_DEC\n \t\t\t\" at position %d the merged region contains:\\n\",\n \t\t\tinfo->bitsize, pos_in_buffer);\n@@ -680,13 +680,15 @@ merged_store_group::apply_stores ()\n \n struct imm_store_chain_info\n {\n+  tree base_addr;\n   auto_vec<struct store_immediate_info *> m_store_info;\n   auto_vec<merged_store_group *> m_merged_store_groups;\n \n-  bool terminate_and_process_chain (tree);\n+  imm_store_chain_info (tree b_a) : base_addr (b_a) {}\n+  bool terminate_and_process_chain ();\n   bool coalesce_immediate_stores ();\n-  bool output_merged_store (tree, merged_store_group *);\n-  bool output_merged_stores (tree);\n+  bool output_merged_store (merged_store_group *);\n+  bool output_merged_stores ();\n };\n \n const pass_data pass_data_tree_store_merging = {\n@@ -722,8 +724,9 @@ class pass_store_merging : public gimple_opt_pass\n   hash_map<tree_operand_hash, struct imm_store_chain_info *> m_stores;\n \n   bool terminate_and_process_all_chains ();\n-  bool terminate_all_aliasing_chains (tree, tree, bool, gimple *);\n-  bool terminate_and_release_chain (tree);\n+  bool terminate_all_aliasing_chains (tree, imm_store_chain_info **,\n+\t\t\t\t      bool, gimple *);\n+  bool terminate_and_release_chain (imm_store_chain_info *);\n }; // class pass_store_merging\n \n /* Terminate and process all recorded chains.  Return true if any changes\n@@ -736,7 +739,7 @@ pass_store_merging::terminate_and_process_all_chains ()\n     = m_stores.begin ();\n   bool ret = false;\n   for (; iter != m_stores.end (); ++iter)\n-    ret |= terminate_and_release_chain ((*iter).first);\n+    ret |= terminate_and_release_chain ((*iter).second);\n \n   return ret;\n }\n@@ -750,7 +753,9 @@ pass_store_merging::terminate_and_process_all_chains ()\n    If that is the case we have to terminate any chain anchored at BASE.  */\n \n bool\n-pass_store_merging::terminate_all_aliasing_chains (tree dest, tree base,\n+pass_store_merging::terminate_all_aliasing_chains (tree dest,\n+\t\t\t\t\t\t   imm_store_chain_info\n+\t\t\t\t\t\t     **chain_info,\n \t\t\t\t\t\t   bool var_offset_p,\n \t\t\t\t\t\t   gimple *stmt)\n {\n@@ -760,44 +765,38 @@ pass_store_merging::terminate_all_aliasing_chains (tree dest, tree base,\n   if (!gimple_vuse (stmt))\n     return false;\n \n-  struct imm_store_chain_info **chain_info = NULL;\n-\n   /* Check if the assignment destination (BASE) is part of a store chain.\n      This is to catch non-constant stores to destinations that may be part\n      of a chain.  */\n-  if (base)\n+  if (chain_info)\n     {\n-      chain_info = m_stores.get (base);\n-      if (chain_info)\n+      /* We have a chain at BASE and we're writing to [BASE + <variable>].\n+\t This can interfere with any of the stores so terminate\n+\t the chain.  */\n+      if (var_offset_p)\n \t{\n-\t  /* We have a chain at BASE and we're writing to [BASE + <variable>].\n-\t     This can interfere with any of the stores so terminate\n-\t     the chain.  */\n-\t  if (var_offset_p)\n-\t    {\n-\t      terminate_and_release_chain (base);\n-\t      ret = true;\n-\t    }\n-\t  /* Otherwise go through every store in the chain to see if it\n-\t     aliases with any of them.  */\n-\t  else\n+\t  terminate_and_release_chain (*chain_info);\n+\t  ret = true;\n+\t}\n+      /* Otherwise go through every store in the chain to see if it\n+\t aliases with any of them.  */\n+      else\n+\t{\n+\t  struct store_immediate_info *info;\n+\t  unsigned int i;\n+\t  FOR_EACH_VEC_ELT ((*chain_info)->m_store_info, i, info)\n \t    {\n-\t      struct store_immediate_info *info;\n-\t      unsigned int i;\n-\t      FOR_EACH_VEC_ELT ((*chain_info)->m_store_info, i, info)\n+\t      if (stmt_may_clobber_ref_p (info->stmt, dest))\n \t\t{\n-\t\t  if (refs_may_alias_p (info->dest, dest))\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t    {\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t{\n-\t\t\t  fprintf (dump_file,\n-\t\t\t\t   \"stmt causes chain termination:\\n\");\n-\t\t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t\t\t}\n-\t\t      terminate_and_release_chain (base);\n-\t\t      ret = true;\n-\t\t      break;\n+\t\t      fprintf (dump_file,\n+\t\t\t       \"stmt causes chain termination:\\n\");\n+\t\t      print_gimple_stmt (dump_file, stmt, 0, 0);\n \t\t    }\n+\t\t  terminate_and_release_chain (*chain_info);\n+\t\t  ret = true;\n+\t\t  break;\n \t\t}\n \t    }\n \t}\n@@ -814,11 +813,16 @@ pass_store_merging::terminate_all_aliasing_chains (tree dest, tree base,\n       if (chain_info && (*chain_info) == (*iter).second)\n \tcontinue;\n \n-      tree key = (*iter).first;\n-      if (ref_maybe_used_by_stmt_p (stmt, key)\n-\t  || stmt_may_clobber_ref_p (stmt, key))\n+      /* We can't use the base object here as that does not reliably exist.\n+\t Build a ao_ref from the base object address (if we know the\n+\t minimum and maximum offset and the maximum size we could improve\n+\t things here).  */\n+      ao_ref chain_ref;\n+      ao_ref_init_from_ptr_and_size (&chain_ref, (*iter).first, NULL_TREE);\n+      if (ref_maybe_used_by_stmt_p (stmt, &chain_ref)\n+\t  || stmt_may_clobber_ref_p_1 (stmt, &chain_ref))\n \t{\n-\t  terminate_and_release_chain (key);\n+\t  terminate_and_release_chain ((*iter).second);\n \t  ret = true;\n \t}\n     }\n@@ -831,19 +835,11 @@ pass_store_merging::terminate_all_aliasing_chains (tree dest, tree base,\n    entry is removed after the processing in any case.  */\n \n bool\n-pass_store_merging::terminate_and_release_chain (tree base)\n+pass_store_merging::terminate_and_release_chain (imm_store_chain_info *chain_info)\n {\n-  struct imm_store_chain_info **chain_info = m_stores.get (base);\n-\n-  if (!chain_info)\n-    return false;\n-\n-  gcc_assert (*chain_info);\n-\n-  bool ret = (*chain_info)->terminate_and_process_chain (base);\n-  delete *chain_info;\n-  m_stores.remove (base);\n-\n+  bool ret = chain_info->terminate_and_process_chain ();\n+  m_stores.remove (chain_info->base_addr);\n+  delete chain_info;\n   return ret;\n }\n \n@@ -880,7 +876,7 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t  fprintf (dump_file, \"Store %u:\\nbitsize:\" HOST_WIDE_INT_PRINT_DEC\n \t\t\t      \" bitpos:\" HOST_WIDE_INT_PRINT_DEC \" val:\\n\",\n \t\t   i, info->bitsize, info->bitpos);\n-\t  print_generic_expr (dump_file, info->val, 0);\n+\t  print_generic_expr (dump_file, gimple_assign_rhs1 (info->stmt), 0);\n \t  fprintf (dump_file, \"\\n------------\\n\");\n \t}\n \n@@ -1103,7 +1099,7 @@ split_group (merged_store_group *group,\n    return true.  */\n \n bool\n-imm_store_chain_info::output_merged_store (tree base, merged_store_group *group)\n+imm_store_chain_info::output_merged_store (merged_store_group *group)\n {\n   unsigned HOST_WIDE_INT start_byte_pos = group->start / BITS_PER_UNIT;\n \n@@ -1141,8 +1137,7 @@ imm_store_chain_info::output_merged_store (tree base, merged_store_group *group)\n \n       tree int_type = build_nonstandard_integer_type (try_size, UNSIGNED);\n       int_type = build_aligned_type (int_type, align);\n-      tree addr = build_fold_addr_expr (base);\n-      tree dest = fold_build2 (MEM_REF, int_type, addr,\n+      tree dest = fold_build2 (MEM_REF, int_type, base_addr,\n \t\t\t       build_int_cst (offset_type, try_pos));\n \n       tree src = native_interpret_expr (int_type,\n@@ -1213,14 +1208,14 @@ imm_store_chain_info::output_merged_store (tree base, merged_store_group *group)\n    successful.  Return true iff any changes were made.  */\n \n bool\n-imm_store_chain_info::output_merged_stores (tree base)\n+imm_store_chain_info::output_merged_stores ()\n {\n   unsigned int i;\n   merged_store_group *merged_store;\n   bool ret = false;\n   FOR_EACH_VEC_ELT (m_merged_store_groups, i, merged_store)\n     {\n-      if (output_merged_store (base, merged_store))\n+      if (output_merged_store (merged_store))\n \t{\n \t  unsigned int j;\n \t  store_immediate_info *store;\n@@ -1250,15 +1245,15 @@ imm_store_chain_info::output_merged_stores (tree base)\n    Return true if any changes were made.  */\n \n bool\n-imm_store_chain_info::terminate_and_process_chain (tree base)\n+imm_store_chain_info::terminate_and_process_chain ()\n {\n   /* Process store chain.  */\n   bool ret = false;\n   if (m_store_info.length () > 1)\n     {\n       ret = coalesce_immediate_stores ();\n       if (ret)\n-\tret = output_merged_stores (base);\n+\tret = output_merged_stores ();\n     }\n \n   /* Delete all the entries we allocated ourselves.  */\n@@ -1381,28 +1376,29 @@ pass_store_merging::execute (function *fun)\n \t\t   other so we can't track chains on them.  */\n \t\t\t     || TREE_THIS_VOLATILE (base_addr);\n \n+\t      /* We do not want to rewrite TARGET_MEM_REFs.  */\n+\t      if (TREE_CODE (base_addr) == TARGET_MEM_REF)\n+\t\tinvalid = true;\n \t      /* In some cases get_inner_reference may return a\n \t\t MEM_REF [ptr + byteoffset].  For the purposes of this pass\n \t\t canonicalize the base_addr to MEM_REF [ptr] and take\n \t\t byteoffset into account in the bitpos.  This occurs in\n \t\t PR 23684 and this way we can catch more chains.  */\n-\t      if (TREE_CODE (base_addr) == MEM_REF\n-\t\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (base_addr, 0))))\n+\t      else if (TREE_CODE (base_addr) == MEM_REF)\n \t\t{\n \t\t  offset_int bit_off, byte_off = mem_ref_offset (base_addr);\n \t\t  bit_off = byte_off << LOG2_BITS_PER_UNIT;\n \t\t  bit_off += bitpos;\n \t\t  if (!wi::neg_p (bit_off) && wi::fits_shwi_p (bit_off))\n-\t\t    {\n-\t\t      bitpos = bit_off.to_shwi ();\n-\t\t      base_addr = build2 (MEM_REF, TREE_TYPE (base_addr),\n-\t\t\t\t\t  TREE_OPERAND (base_addr, 0),\n-\t\t\t\t\t  build_zero_cst (TREE_TYPE (\n-\t\t\t\t\t  TREE_OPERAND (base_addr, 1))));\n-\t\t    }\n+\t\t    bitpos = bit_off.to_shwi ();\n \t\t  else\n \t\t    invalid = true;\n+\t\t  base_addr = TREE_OPERAND (base_addr, 0);\n \t\t}\n+\t      /* get_inner_reference returns the base object, get at its\n+\t         address now.  */\n+\t      else\n+\t\tbase_addr = build_fold_addr_expr (base_addr);\n \n \t      struct imm_store_chain_info **chain_info\n \t\t= m_stores.get (base_addr);\n@@ -1413,7 +1409,7 @@ pass_store_merging::execute (function *fun)\n \t\t  if (chain_info)\n \t\t    {\n \t\t      info = new store_immediate_info (\n-\t\t\tbitsize, bitpos, rhs, lhs, stmt,\n+\t\t\tbitsize, bitpos, stmt,\n \t\t\t(*chain_info)->m_store_info.length ());\n \t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\t{\n@@ -1432,17 +1428,17 @@ pass_store_merging::execute (function *fun)\n \t\t\t    fprintf (dump_file,\n \t\t\t\t \"Reached maximum number of statements\"\n \t\t\t\t \" to merge:\\n\");\n-\t\t\t  terminate_and_release_chain (base_addr);\n+\t\t\t  terminate_and_release_chain (*chain_info);\n \t\t\t}\n \t\t      continue;\n \t\t    }\n \n \t\t  /* Store aliases any existing chain?  */\n-\t\t  terminate_all_aliasing_chains (lhs, base_addr, false, stmt);\n+\t\t  terminate_all_aliasing_chains (lhs, chain_info, false, stmt);\n \t\t  /* Start a new chain.  */\n \t\t  struct imm_store_chain_info *new_chain\n-\t\t    = new imm_store_chain_info;\n-\t\t  info = new store_immediate_info (bitsize, bitpos, rhs, lhs,\n+\t\t    = new imm_store_chain_info (base_addr);\n+\t\t  info = new store_immediate_info (bitsize, bitpos,\n \t\t\t\t\t\t   stmt, 0);\n \t\t  new_chain->m_store_info.safe_push (info);\n \t\t  m_stores.put (base_addr, new_chain);\n@@ -1457,13 +1453,13 @@ pass_store_merging::execute (function *fun)\n \t\t    }\n \t\t}\n \t      else\n-\t\tterminate_all_aliasing_chains (lhs, base_addr,\n+\t\tterminate_all_aliasing_chains (lhs, chain_info,\n \t\t\t\t\t       offset != NULL_TREE, stmt);\n \n \t      continue;\n \t    }\n \n-\t  terminate_all_aliasing_chains (NULL_TREE, NULL_TREE, false, stmt);\n+\t  terminate_all_aliasing_chains (NULL_TREE, NULL, false, stmt);\n \t}\n       terminate_and_process_all_chains ();\n     }"}]}