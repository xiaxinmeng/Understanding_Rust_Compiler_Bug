{"sha": "d8e94f7997cfb8a83fe5e7efec9dc34153f327ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhlOTRmNzk5N2NmYjhhODNmZTVlN2VmZWM5ZGMzNDE1M2YzMjdlYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-10-29T18:28:49Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-10-29T18:28:49Z"}, "message": "decl.c (array_type_has_nonaliased_component): Swap parameters and rewrite comments.\n\n\t* gcc-interface/decl.c (array_type_has_nonaliased_component): Swap\n\tparameters and rewrite comments.  For a derived type, return the\n\tsetting of its parent type.\n\t(gnat_to_gnu_entity): Do an alias set copy for derived types if they\n\tare composite.  Adjust calls to above function.\n\nFrom-SVN: r153721", "tree": {"sha": "959628019096d3c772107a4c645dcf1479ca294a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/959628019096d3c772107a4c645dcf1479ca294a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8e94f7997cfb8a83fe5e7efec9dc34153f327ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8e94f7997cfb8a83fe5e7efec9dc34153f327ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8e94f7997cfb8a83fe5e7efec9dc34153f327ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8e94f7997cfb8a83fe5e7efec9dc34153f327ec/comments", "author": null, "committer": null, "parents": [{"sha": "6b1cce3ada17796f7d93403fa65a7e4bdce8173b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b1cce3ada17796f7d93403fa65a7e4bdce8173b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b1cce3ada17796f7d93403fa65a7e4bdce8173b"}], "stats": {"total": 72, "additions": 62, "deletions": 10}, "files": [{"sha": "f92adbc4769c7edb3c7b5a223e7245b80d42f332", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e94f7997cfb8a83fe5e7efec9dc34153f327ec/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e94f7997cfb8a83fe5e7efec9dc34153f327ec/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d8e94f7997cfb8a83fe5e7efec9dc34153f327ec", "patch": "@@ -1,3 +1,11 @@\n+2009-10-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (array_type_has_nonaliased_component): Swap\n+\tparameters and rewrite comments.  For a derived type, return the\n+\tsetting of its parent type.\n+\t(gnat_to_gnu_entity): Do an alias set copy for derived types if they\n+\tare composite.  Adjust calls to above function.\n+\n 2009-10-29  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Object_Size>: Do not"}, {"sha": "cd13e21710cf293fb56b52f56c7499623bc6440f", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 54, "deletions": 10, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8e94f7997cfb8a83fe5e7efec9dc34153f327ec/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8e94f7997cfb8a83fe5e7efec9dc34153f327ec/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=d8e94f7997cfb8a83fe5e7efec9dc34153f327ec", "patch": "@@ -135,7 +135,7 @@ static tree gnat_to_gnu_param (Entity_Id, Mechanism_Type, Entity_Id, bool,\n \t\t\t       bool *);\n static tree gnat_to_gnu_field (Entity_Id, tree, int, bool, bool);\n static bool same_discriminant_p (Entity_Id, Entity_Id);\n-static bool array_type_has_nonaliased_component (Entity_Id, tree);\n+static bool array_type_has_nonaliased_component (tree, Entity_Id);\n static bool compile_time_known_address_p (Node_Id);\n static bool cannot_be_superflat_p (Node_Id);\n static void components_to_record (tree, Node_Id, tree, int, bool, tree *,\n@@ -1963,7 +1963,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  {\n \t    tem = build_array_type (tem, gnu_index_types[index]);\n \t    TYPE_MULTI_ARRAY_P (tem) = (index > 0);\n-\t    if (array_type_has_nonaliased_component (gnat_entity, tem))\n+\t    if (array_type_has_nonaliased_component (tem, gnat_entity))\n \t      TYPE_NONALIASED_COMPONENT (tem) = 1;\n \t  }\n \n@@ -2312,7 +2312,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    {\n \t      gnu_type = build_array_type (gnu_type, gnu_index_types[index]);\n \t      TYPE_MULTI_ARRAY_P (gnu_type) = (index > 0);\n-\t      if (array_type_has_nonaliased_component (gnat_entity, gnu_type))\n+\t      if (array_type_has_nonaliased_component (gnu_type, gnat_entity))\n \t\tTYPE_NONALIASED_COMPONENT (gnu_type) = 1;\n \t    }\n \n@@ -2563,7 +2563,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tgnu_type\n \t  = build_array_type (gnat_to_gnu_type (Component_Type (gnat_entity)),\n \t\t\t      gnu_index_type);\n-\tif (array_type_has_nonaliased_component (gnat_entity, gnu_type))\n+\tif (array_type_has_nonaliased_component (gnu_type, gnat_entity))\n \t  TYPE_NONALIASED_COMPONENT (gnu_type) = 1;\n \trelate_alias_sets (gnu_type, gnu_string_type, ALIAS_SET_COPY);\n       }\n@@ -4602,11 +4602,38 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   superset      superset\n \t\tR ----------> D ----------> T\n \n+\t However, for composite types, conversions between derived types are\n+\t translated into VIEW_CONVERT_EXPRs so a sequence like:\n+\n+\t    type Comp1 is new Comp;\n+\t    type Comp2 is new Comp;\n+\t    procedure Proc (C : Comp1);\n+\n+\t    C : Comp2;\n+\t    Proc (Comp1 (C));\n+\n+\t is translated into:\n+\n+\t    C : Comp2;\n+\t    Proc ((Comp1 &) &VIEW_CONVERT_EXPR <Comp1> (C));\n+\n+\t and gimplified into:\n+\n+\t    C : Comp2;\n+\t    Comp1 *C.0;\n+\t    C.0 = (Comp1 *) &C;\n+\t    Proc (C.0);\n+\n+\t i.e. generates code involving type punning.  Therefore, Comp1 needs\n+\t to conflict with Comp2 and an alias set copy is required.\n+\n \t The language rules ensure the parent type is already frozen here.  */\n       if (Is_Derived_Type (gnat_entity))\n \t{\n \t  tree gnu_parent_type = gnat_to_gnu_type (Etype (gnat_entity));\n-\t  relate_alias_sets (gnu_type, gnu_parent_type, ALIAS_SET_SUPERSET);\n+\t  relate_alias_sets (gnu_type, gnu_parent_type,\n+\t\t\t     Is_Composite_Type (gnat_entity)\n+\t\t\t     ? ALIAS_SET_COPY : ALIAS_SET_SUPERSET);\n \t}\n \n       /* Back-annotate the Alignment of the type if not already in the\n@@ -5254,21 +5281,38 @@ same_discriminant_p (Entity_Id discr1, Entity_Id discr2)\n     Original_Record_Component (discr1) == Original_Record_Component (discr2);\n }\n \n-/* Return true if the array type specified by GNAT_TYPE and GNU_TYPE has\n-   a non-aliased component in the back-end sense.  */\n+/* Return true if the array type GNU_TYPE, which represents a dimension of\n+   GNAT_TYPE, has a non-aliased component in the back-end sense.  */\n \n static bool\n-array_type_has_nonaliased_component (Entity_Id gnat_type, tree gnu_type)\n+array_type_has_nonaliased_component (tree gnu_type, Entity_Id gnat_type)\n {\n-  /* If the type below this is a multi-array type, then\n-     this does not have aliased components.  */\n+  /* If the array type is not the innermost dimension of the GNAT type,\n+     then it has a non-aliased component.  */\n   if (TREE_CODE (TREE_TYPE (gnu_type)) == ARRAY_TYPE\n       && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_type)))\n     return true;\n \n+  /* If the array type has an aliased component in the front-end sense,\n+     then it also has an aliased component in the back-end sense.  */\n   if (Has_Aliased_Components (gnat_type))\n     return false;\n \n+  /* If this is a derived type, then it has a non-aliased component if\n+     and only if its parent type also has one.  */\n+  if (Is_Derived_Type (gnat_type))\n+    {\n+      tree gnu_parent_type = gnat_to_gnu_type (Etype (gnat_type));\n+      int index;\n+      if (TREE_CODE (gnu_parent_type) == UNCONSTRAINED_ARRAY_TYPE)\n+\tgnu_parent_type\n+\t  = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_parent_type))));\n+      for (index = Number_Dimensions (gnat_type) - 1; index > 0; index--)\n+\tgnu_parent_type = TREE_TYPE (gnu_parent_type);\n+      return TYPE_NONALIASED_COMPONENT (gnu_parent_type);\n+    }\n+\n+  /* Otherwise, rely exclusively on properties of the element type.  */\n   return type_for_nonaliased_component_p (TREE_TYPE (gnu_type));\n }\n "}]}