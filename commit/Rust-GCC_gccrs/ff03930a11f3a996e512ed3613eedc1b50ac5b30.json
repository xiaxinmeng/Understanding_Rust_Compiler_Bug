{"sha": "ff03930a11f3a996e512ed3613eedc1b50ac5b30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmYwMzkzMGExMWYzYTk5NmU1MTJlZDM2MTNlZWRjMWI1MGFjNWIzMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-08-01T08:26:14Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-08-01T08:26:14Z"}, "message": "re PR target/80846 (auto-vectorized AVX2 horizontal sum should narrow to 128b right away, to be more efficient for Ryzen and Intel)\n\n\tPR target/80846\n\t* optabs.def (vec_extract_optab, vec_init_optab): Change from\n\ta direct optab to conversion optab.\n\t* optabs.c (expand_vector_broadcast): Use convert_optab_handler\n\twith GET_MODE_INNER as last argument instead of optab_handler.\n\t* expmed.c (extract_bit_field_1): Likewise.  Use vector from\n\tvector extraction if possible and optab is available.\n\t* expr.c (store_constructor): Use convert_optab_handler instead\n\tof optab_handler.  Use vector initialization from smaller\n\tvectors if possible and optab is available.\n\t* tree-vect-stmts.c (vectorizable_load): Likewise.\n\t* doc/md.texi (vec_extract, vec_init): Document that the optabs\n\tnow have two modes.\n\t* config/i386/i386.c (ix86_expand_vector_init): Handle expansion\n\tof vec_init from half-sized vectors with the same element mode.\n\t* config/i386/sse.md (ssehalfvecmode): Add V4TI case.\n\t(ssehalfvecmodelower, ssescalarmodelower): New mode attributes.\n\t(reduc_plus_scal_v8df, reduc_plus_scal_v4df, reduc_plus_scal_v2df,\n\treduc_plus_scal_v16sf, reduc_plus_scal_v8sf, reduc_plus_scal_v4sf,\n\treduc_<code>_scal_<mode>, reduc_umin_scal_v8hi): Add element mode\n\tafter mode in gen_vec_extract* calls.\n\t(vec_extract<mode>): Renamed to ...\n\t(vec_extract<mode><ssescalarmodelower>): ... this.\n\t(vec_extract<mode><ssehalfvecmodelower>): New expander.\n\t(rotl<mode>3, rotr<mode>3, <shift_insn><mode>3, ashrv2di3): Add\n\telement mode after mode in gen_vec_init* calls.\n\t(VEC_INIT_HALF_MODE): New mode iterator.\n\t(vec_init<mode>): Renamed to ...\n\t(vec_init<mode><ssescalarmodelower>): ... this.\n\t(vec_init<mode><ssehalfvecmodelower>): New expander.\n\t* config/i386/mmx.md (vec_extractv2sf): Renamed to ...\n\t(vec_extractv2sfsf): ... this.\n\t(vec_initv2sf): Renamed to ...\n\t(vec_initv2sfsf): ... this.\n\t(vec_extractv2si): Renamed to ...\n\t(vec_extractv2sisi): ... this.\n\t(vec_initv2si): Renamed to ...\n\t(vec_initv2sisi): ... this.\n\t(vec_extractv4hi): Renamed to ...\n\t(vec_extractv4hihi): ... this.\n\t(vec_initv4hi): Renamed to ...\n\t(vec_initv4hihi): ... this.\n\t(vec_extractv8qi): Renamed to ...\n\t(vec_extractv8qiqi): ... this.\n\t(vec_initv8qi): Renamed to ...\n\t(vec_initv8qiqi): ... this.\n\t* config/rs6000/vector.md (VEC_base_l): New mode attribute.\n\t(vec_init<mode>): Renamed to ...\n\t(vec_init<mode><VEC_base_l>): ... this.\n\t(vec_extract<mode>): Renamed to ...\n\t(vec_extract<mode><VEC_base_l>): ... this.\n\t* config/rs6000/paired.md (vec_initv2sf): Renamed to ...\n\t(vec_initv2sfsf): ... this.\n\t* config/rs6000/altivec.md (splitter, altivec_copysign_v4sf3,\n\tvec_unpacku_hi_v16qi, vec_unpacku_hi_v8hi, vec_unpacku_lo_v16qi,\n\tvec_unpacku_lo_v8hi, mulv16qi3, altivec_vreve<mode>2): Add\n\telement mode after mode in gen_vec_init* calls.\n\t* config/aarch64/aarch64-simd.md (vec_init<mode>): Renamed to ...\n\t(vec_init<mode><Vel>): ... this.\n\t(vec_extract<mode>): Renamed to ...\n\t(vec_extract<mode><Vel>): ... this.\n\t* config/aarch64/iterators.md (Vel): New mode attribute.\n\t* config/s390/s390.c (s390_expand_vec_strlen, s390_expand_vec_movstr):\n\tAdd element mode after mode in gen_vec_extract* calls.\n\t* config/s390/vector.md (non_vec_l): New mode attribute.\n\t(vec_extract<mode>): Renamed to ...\n\t(vec_extract<mode><non_vec_l>): ... this.\n\t(vec_init<mode>): Renamed to ...\n\t(vec_init<mode><non_vec_l>): ... this.\n\t* config/s390/s390-builtins.def (s390_vlgvb, s390_vlgvh, s390_vlgvf,\n\ts390_vlgvf_flt, s390_vlgvg, s390_vlgvg_dbl): Add element mode after\n\tvec_extract mode.\n\t* config/arm/iterators.md (V_elem_l): New mode attribute.\n\t* config/arm/neon.md (vec_extract<mode>): Renamed to ...\n\t(vec_extract<mode><V_elem_l>): ... this.\n\t(vec_extractv2di): Renamed to ...\n\t(vec_extractv2didi): ... this.\n\t(vec_init<mode>): Renamed to ...\n\t(vec_init<mode><V_elem_l>): ... this.\n\t(reduc_plus_scal_<mode>, reduc_plus_scal_v2di, reduc_smin_scal_<mode>,\n\treduc_smax_scal_<mode>, reduc_umin_scal_<mode>,\n\treduc_umax_scal_<mode>, neon_vget_lane<mode>, neon_vget_laneu<mode>):\n\tAdd element mode after gen_vec_extract* calls.\n\t* config/mips/mips-msa.md (vec_init<mode>): Renamed to ...\n\t(vec_init<mode><unitmode>): ... this.\n\t(vec_extract<mode>): Renamed to ...\n\t(vec_extract<mode><unitmode>): ... this.\n\t* config/mips/loongson.md (vec_init<mode>): Renamed to ...\n\t(vec_init<mode><unitmode>): ... this.\n\t* config/mips/mips-ps-3d.md (vec_initv2sf): Renamed to ...\n\t(vec_initv2sfsf): ... this.\n\t(vec_extractv2sf): Renamed to ...\n\t(vec_extractv2sfsf): ... this.\n\t(reduc_plus_scal_v2sf, reduc_smin_scal_v2sf, reduc_smax_scal_v2sf):\n\tAdd element mode after gen_vec_extract* calls.\n\t* config/mips/mips.md (unitmode): New mode iterator.\n\t* config/spu/spu.c (spu_expand_prologue, spu_allocate_stack,\n\tspu_builtin_extract): Add element mode after gen_vec_extract* calls.\n\t* config/spu/spu.md (inner_l): New mode attribute.\n\t(vec_init<mode>): Renamed to ...\n\t(vec_init<mode><inner_l>): ... this.\n\t(vec_extract<mode>): Renamed to ...\n\t(vec_extract<mode><inner_l>): ... this.\n\t* config/sparc/sparc.md (veltmode): New mode iterator.\n\t(vec_init<VMALL:mode>): Renamed to ...\n\t(vec_init<VMALL:mode><VMALL:veltmode>): ... this.\n\t* config/ia64/vect.md (vec_initv2si): Renamed to ...\n\t(vec_initv2sisi): ... this.\n\t(vec_initv2sf): Renamed to ...\n\t(vec_initv2sfsf): ... this.\n\t(vec_extractv2sf): Renamed to ...\n\t(vec_extractv2sfsf): ... this.\n\t* config/powerpcspe/vector.md (VEC_base_l): New mode attribute.\n\t(vec_init<mode>): Renamed to ...\n\t(vec_init<mode><VEC_base_l>): ... this.\n\t(vec_extract<mode>): Renamed to ...\n\t(vec_extract<mode><VEC_base_l>): ... this.\n\t* config/powerpcspe/paired.md (vec_initv2sf): Renamed to ...\n\t(vec_initv2sfsf): ... this.\n\t* config/powerpcspe/altivec.md (splitter, altivec_copysign_v4sf3,\n\tvec_unpacku_hi_v16qi, vec_unpacku_hi_v8hi, vec_unpacku_lo_v16qi,\n\tvec_unpacku_lo_v8hi, mulv16qi3): Add element mode after mode in\n\tgen_vec_init* calls.\n\nFrom-SVN: r250759", "tree": {"sha": "af31b0e324512fbcd62de8f28468084fc6a23160", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af31b0e324512fbcd62de8f28468084fc6a23160"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ff03930a11f3a996e512ed3613eedc1b50ac5b30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff03930a11f3a996e512ed3613eedc1b50ac5b30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff03930a11f3a996e512ed3613eedc1b50ac5b30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff03930a11f3a996e512ed3613eedc1b50ac5b30/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5e8fe12fccb2edeb1b699101167b1c921a742bb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e8fe12fccb2edeb1b699101167b1c921a742bb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e8fe12fccb2edeb1b699101167b1c921a742bb7"}], "stats": {"total": 673, "additions": 514, "deletions": 159}, "files": [{"sha": "c811099037d0ef8909c5530d17c4f804d548a945", "filename": "gcc/ChangeLog", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -1,3 +1,129 @@\n+2017-08-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/80846\n+\t* optabs.def (vec_extract_optab, vec_init_optab): Change from\n+\ta direct optab to conversion optab.\n+\t* optabs.c (expand_vector_broadcast): Use convert_optab_handler\n+\twith GET_MODE_INNER as last argument instead of optab_handler.\n+\t* expmed.c (extract_bit_field_1): Likewise.  Use vector from\n+\tvector extraction if possible and optab is available.\n+\t* expr.c (store_constructor): Use convert_optab_handler instead\n+\tof optab_handler.  Use vector initialization from smaller\n+\tvectors if possible and optab is available.\n+\t* tree-vect-stmts.c (vectorizable_load): Likewise.\n+\t* doc/md.texi (vec_extract, vec_init): Document that the optabs\n+\tnow have two modes.\n+\t* config/i386/i386.c (ix86_expand_vector_init): Handle expansion\n+\tof vec_init from half-sized vectors with the same element mode.\n+\t* config/i386/sse.md (ssehalfvecmode): Add V4TI case.\n+\t(ssehalfvecmodelower, ssescalarmodelower): New mode attributes.\n+\t(reduc_plus_scal_v8df, reduc_plus_scal_v4df, reduc_plus_scal_v2df,\n+\treduc_plus_scal_v16sf, reduc_plus_scal_v8sf, reduc_plus_scal_v4sf,\n+\treduc_<code>_scal_<mode>, reduc_umin_scal_v8hi): Add element mode\n+\tafter mode in gen_vec_extract* calls.\n+\t(vec_extract<mode>): Renamed to ...\n+\t(vec_extract<mode><ssescalarmodelower>): ... this.\n+\t(vec_extract<mode><ssehalfvecmodelower>): New expander.\n+\t(rotl<mode>3, rotr<mode>3, <shift_insn><mode>3, ashrv2di3): Add\n+\telement mode after mode in gen_vec_init* calls.\n+\t(VEC_INIT_HALF_MODE): New mode iterator.\n+\t(vec_init<mode>): Renamed to ...\n+\t(vec_init<mode><ssescalarmodelower>): ... this.\n+\t(vec_init<mode><ssehalfvecmodelower>): New expander.\n+\t* config/i386/mmx.md (vec_extractv2sf): Renamed to ...\n+\t(vec_extractv2sfsf): ... this.\n+\t(vec_initv2sf): Renamed to ...\n+\t(vec_initv2sfsf): ... this.\n+\t(vec_extractv2si): Renamed to ...\n+\t(vec_extractv2sisi): ... this.\n+\t(vec_initv2si): Renamed to ...\n+\t(vec_initv2sisi): ... this.\n+\t(vec_extractv4hi): Renamed to ...\n+\t(vec_extractv4hihi): ... this.\n+\t(vec_initv4hi): Renamed to ...\n+\t(vec_initv4hihi): ... this.\n+\t(vec_extractv8qi): Renamed to ...\n+\t(vec_extractv8qiqi): ... this.\n+\t(vec_initv8qi): Renamed to ...\n+\t(vec_initv8qiqi): ... this.\n+\t* config/rs6000/vector.md (VEC_base_l): New mode attribute.\n+\t(vec_init<mode>): Renamed to ...\n+\t(vec_init<mode><VEC_base_l>): ... this.\n+\t(vec_extract<mode>): Renamed to ...\n+\t(vec_extract<mode><VEC_base_l>): ... this.\n+\t* config/rs6000/paired.md (vec_initv2sf): Renamed to ...\n+\t(vec_initv2sfsf): ... this.\n+\t* config/rs6000/altivec.md (splitter, altivec_copysign_v4sf3,\n+\tvec_unpacku_hi_v16qi, vec_unpacku_hi_v8hi, vec_unpacku_lo_v16qi,\n+\tvec_unpacku_lo_v8hi, mulv16qi3, altivec_vreve<mode>2): Add\n+\telement mode after mode in gen_vec_init* calls.\n+\t* config/aarch64/aarch64-simd.md (vec_init<mode>): Renamed to ...\n+\t(vec_init<mode><Vel>): ... this.\n+\t(vec_extract<mode>): Renamed to ...\n+\t(vec_extract<mode><Vel>): ... this.\n+\t* config/aarch64/iterators.md (Vel): New mode attribute.\n+\t* config/s390/s390.c (s390_expand_vec_strlen, s390_expand_vec_movstr):\n+\tAdd element mode after mode in gen_vec_extract* calls.\n+\t* config/s390/vector.md (non_vec_l): New mode attribute.\n+\t(vec_extract<mode>): Renamed to ...\n+\t(vec_extract<mode><non_vec_l>): ... this.\n+\t(vec_init<mode>): Renamed to ...\n+\t(vec_init<mode><non_vec_l>): ... this.\n+\t* config/s390/s390-builtins.def (s390_vlgvb, s390_vlgvh, s390_vlgvf,\n+\ts390_vlgvf_flt, s390_vlgvg, s390_vlgvg_dbl): Add element mode after\n+\tvec_extract mode.\n+\t* config/arm/iterators.md (V_elem_l): New mode attribute.\n+\t* config/arm/neon.md (vec_extract<mode>): Renamed to ...\n+\t(vec_extract<mode><V_elem_l>): ... this.\n+\t(vec_extractv2di): Renamed to ...\n+\t(vec_extractv2didi): ... this.\n+\t(vec_init<mode>): Renamed to ...\n+\t(vec_init<mode><V_elem_l>): ... this.\n+\t(reduc_plus_scal_<mode>, reduc_plus_scal_v2di, reduc_smin_scal_<mode>,\n+\treduc_smax_scal_<mode>, reduc_umin_scal_<mode>,\n+\treduc_umax_scal_<mode>, neon_vget_lane<mode>, neon_vget_laneu<mode>):\n+\tAdd element mode after gen_vec_extract* calls.\n+\t* config/mips/mips-msa.md (vec_init<mode>): Renamed to ...\n+\t(vec_init<mode><unitmode>): ... this.\n+\t(vec_extract<mode>): Renamed to ...\n+\t(vec_extract<mode><unitmode>): ... this.\n+\t* config/mips/loongson.md (vec_init<mode>): Renamed to ...\n+\t(vec_init<mode><unitmode>): ... this.\n+\t* config/mips/mips-ps-3d.md (vec_initv2sf): Renamed to ...\n+\t(vec_initv2sfsf): ... this.\n+\t(vec_extractv2sf): Renamed to ...\n+\t(vec_extractv2sfsf): ... this.\n+\t(reduc_plus_scal_v2sf, reduc_smin_scal_v2sf, reduc_smax_scal_v2sf):\n+\tAdd element mode after gen_vec_extract* calls.\n+\t* config/mips/mips.md (unitmode): New mode iterator.\n+\t* config/spu/spu.c (spu_expand_prologue, spu_allocate_stack,\n+\tspu_builtin_extract): Add element mode after gen_vec_extract* calls.\n+\t* config/spu/spu.md (inner_l): New mode attribute.\n+\t(vec_init<mode>): Renamed to ...\n+\t(vec_init<mode><inner_l>): ... this.\n+\t(vec_extract<mode>): Renamed to ...\n+\t(vec_extract<mode><inner_l>): ... this.\n+\t* config/sparc/sparc.md (veltmode): New mode iterator.\n+\t(vec_init<VMALL:mode>): Renamed to ...\n+\t(vec_init<VMALL:mode><VMALL:veltmode>): ... this.\n+\t* config/ia64/vect.md (vec_initv2si): Renamed to ...\n+\t(vec_initv2sisi): ... this.\n+\t(vec_initv2sf): Renamed to ...\n+\t(vec_initv2sfsf): ... this.\n+\t(vec_extractv2sf): Renamed to ...\n+\t(vec_extractv2sfsf): ... this.\n+\t* config/powerpcspe/vector.md (VEC_base_l): New mode attribute.\n+\t(vec_init<mode>): Renamed to ...\n+\t(vec_init<mode><VEC_base_l>): ... this.\n+\t(vec_extract<mode>): Renamed to ...\n+\t(vec_extract<mode><VEC_base_l>): ... this.\n+\t* config/powerpcspe/paired.md (vec_initv2sf): Renamed to ...\n+\t(vec_initv2sfsf): ... this.\n+\t* config/powerpcspe/altivec.md (splitter, altivec_copysign_v4sf3,\n+\tvec_unpacku_hi_v16qi, vec_unpacku_hi_v8hi, vec_unpacku_lo_v16qi,\n+\tvec_unpacku_lo_v8hi, mulv16qi3): Add element mode after mode in\n+\tgen_vec_init* calls.\n+\n 2017-08-01  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/81297"}, {"sha": "74de9b8c89dd5e4e3d87504594c969de0e0128ce", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -5617,9 +5617,9 @@\n   DONE;\n })\n \n-;; Standard pattern name vec_init<mode>.\n+;; Standard pattern name vec_init<mode><Vel>.\n \n-(define_expand \"vec_init<mode>\"\n+(define_expand \"vec_init<mode><Vel>\"\n   [(match_operand:VALL_F16 0 \"register_operand\" \"\")\n    (match_operand 1 \"\" \"\")]\n   \"TARGET_SIMD\"\n@@ -5674,9 +5674,9 @@\n  \"urecpe\\\\t%0.<Vtype>, %1.<Vtype>\"\n   [(set_attr \"type\" \"neon_fp_recpe_<Vetype><q>\")])\n \n-;; Standard pattern name vec_extract<mode>.\n+;; Standard pattern name vec_extract<mode><Vel>.\n \n-(define_expand \"vec_extract<mode>\"\n+(define_expand \"vec_extract<mode><Vel>\"\n   [(match_operand:<VEL> 0 \"aarch64_simd_nonimmediate_operand\" \"\")\n    (match_operand:VALL_F16 1 \"register_operand\" \"\")\n    (match_operand:SI 2 \"immediate_operand\" \"\")]"}, {"sha": "cceb57525c7aa44933419bd317b1f03a7b76f4c4", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -523,6 +523,17 @@\n \t\t\t(SI   \"SI\") (HI   \"HI\")\n \t\t\t(QI   \"QI\")])\n \n+;; Define element mode for each vector mode (lower case).\n+(define_mode_attr Vel [(V8QI \"qi\") (V16QI \"qi\")\n+\t\t\t(V4HI \"hi\") (V8HI \"hi\")\n+\t\t\t(V2SI \"si\") (V4SI \"si\")\n+\t\t\t(DI \"di\")   (V2DI \"di\")\n+\t\t\t(V4HF \"hf\") (V8HF \"hf\")\n+\t\t\t(V2SF \"sf\") (V4SF \"sf\")\n+\t\t\t(V2DF \"df\") (DF \"df\")\n+\t\t\t(SI   \"si\") (HI   \"hi\")\n+\t\t\t(QI   \"qi\")])\n+\n ;; 64-bit container modes the inner or scalar source mode.\n (define_mode_attr VCOND [(HI \"V4HI\") (SI \"V2SI\")\n \t\t\t (V4HI \"V4HI\") (V8HI \"V4HI\")"}, {"sha": "7acbaf1bb40a4f270e75968804546508f7839e49", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -444,6 +444,14 @@\n                           (V2SF \"SF\") (V4SF \"SF\")\n                           (DI \"DI\")   (V2DI \"DI\")])\n \n+;; As above but in lower case.\n+(define_mode_attr V_elem_l [(V8QI \"qi\") (V16QI \"qi\")\n+\t\t\t    (V4HI \"hi\") (V8HI \"hi\")\n+\t\t\t    (V4HF \"hf\") (V8HF \"hf\")\n+\t\t\t    (V2SI \"si\") (V4SI \"si\")\n+\t\t\t    (V2SF \"sf\") (V4SF \"sf\")\n+\t\t\t    (DI \"di\")   (V2DI \"di\")])\n+\n ;; Element modes for vector extraction, padded up to register size.\n \n (define_mode_attr V_ext [(V8QI \"SI\") (V16QI \"SI\")"}, {"sha": "45b3bd18052dd4a33e4b9c10f3ca2ea7e2eed5ce", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -412,7 +412,7 @@\n   DONE;\n })\n \n-(define_insn \"vec_extract<mode>\"\n+(define_insn \"vec_extract<mode><V_elem_l>\"\n   [(set (match_operand:<V_elem> 0 \"nonimmediate_operand\" \"=Um,r\")\n         (vec_select:<V_elem>\n           (match_operand:VD_LANE 1 \"s_register_operand\" \"w,w\")\n@@ -434,7 +434,7 @@\n   [(set_attr \"type\" \"neon_store1_one_lane<q>,neon_to_gp<q>\")]\n )\n \n-(define_insn \"vec_extract<mode>\"\n+(define_insn \"vec_extract<mode><V_elem_l>\"\n   [(set (match_operand:<V_elem> 0 \"nonimmediate_operand\" \"=Um,r\")\n \t(vec_select:<V_elem>\n           (match_operand:VQ2 1 \"s_register_operand\" \"w,w\")\n@@ -460,7 +460,7 @@\n   [(set_attr \"type\" \"neon_store1_one_lane<q>,neon_to_gp<q>\")]\n )\n \n-(define_insn \"vec_extractv2di\"\n+(define_insn \"vec_extractv2didi\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=Um,r\")\n \t(vec_select:DI\n           (match_operand:V2DI 1 \"s_register_operand\" \"w,w\")\n@@ -479,7 +479,7 @@\n   [(set_attr \"type\" \"neon_store1_one_lane_q,neon_to_gp_q\")]\n )\n \n-(define_expand \"vec_init<mode>\"\n+(define_expand \"vec_init<mode><V_elem_l>\"\n   [(match_operand:VDQ 0 \"s_register_operand\" \"\")\n    (match_operand 1 \"\" \"\")]\n   \"TARGET_NEON\"\n@@ -1581,7 +1581,7 @@\n   neon_pairwise_reduce (vec, operands[1], <MODE>mode,\n \t\t\t&gen_neon_vpadd_internal<mode>);\n   /* The same result is actually computed into every element.  */\n-  emit_insn (gen_vec_extract<mode> (operands[0], vec, const0_rtx));\n+  emit_insn (gen_vec_extract<mode><V_elem_l> (operands[0], vec, const0_rtx));\n   DONE;\n })\n \n@@ -1607,7 +1607,7 @@\n   rtx vec = gen_reg_rtx (V2DImode);\n \n   emit_insn (gen_arm_reduc_plus_internal_v2di (vec, operands[1]));\n-  emit_insn (gen_vec_extractv2di (operands[0], vec, const0_rtx));\n+  emit_insn (gen_vec_extractv2didi (operands[0], vec, const0_rtx));\n \n   DONE;\n })\n@@ -1631,7 +1631,7 @@\n   neon_pairwise_reduce (vec, operands[1], <MODE>mode,\n \t\t\t&gen_neon_vpsmin<mode>);\n   /* The result is computed into every element of the vector.  */\n-  emit_insn (gen_vec_extract<mode> (operands[0], vec, const0_rtx));\n+  emit_insn (gen_vec_extract<mode><V_elem_l> (operands[0], vec, const0_rtx));\n   DONE;\n })\n \n@@ -1658,7 +1658,7 @@\n   neon_pairwise_reduce (vec, operands[1], <MODE>mode,\n \t\t\t&gen_neon_vpsmax<mode>);\n   /* The result is computed into every element of the vector.  */\n-  emit_insn (gen_vec_extract<mode> (operands[0], vec, const0_rtx));\n+  emit_insn (gen_vec_extract<mode><V_elem_l> (operands[0], vec, const0_rtx));\n   DONE;\n })\n \n@@ -1685,7 +1685,7 @@\n   neon_pairwise_reduce (vec, operands[1], <MODE>mode,\n \t\t\t&gen_neon_vpumin<mode>);\n   /* The result is computed into every element of the vector.  */\n-  emit_insn (gen_vec_extract<mode> (operands[0], vec, const0_rtx));\n+  emit_insn (gen_vec_extract<mode><V_elem_l> (operands[0], vec, const0_rtx));\n   DONE;\n })\n \n@@ -1711,7 +1711,7 @@\n   neon_pairwise_reduce (vec, operands[1], <MODE>mode,\n \t\t\t&gen_neon_vpumax<mode>);\n   /* The result is computed into every element of the vector.  */\n-  emit_insn (gen_vec_extract<mode> (operands[0], vec, const0_rtx));\n+  emit_insn (gen_vec_extract<mode><V_elem_l> (operands[0], vec, const0_rtx));\n   DONE;\n })\n \n@@ -3272,7 +3272,8 @@\n     }\n \n   if (GET_MODE_UNIT_BITSIZE (<MODE>mode) == 32)\n-    emit_insn (gen_vec_extract<mode> (operands[0], operands[1], operands[2]));\n+    emit_insn (gen_vec_extract<mode><V_elem_l> (operands[0], operands[1],\n+\t\t\t\t\t\toperands[2]));\n   else\n     emit_insn (gen_neon_vget_lane<mode>_sext_internal (operands[0],\n \t\t\t\t\t\t       operands[1],\n@@ -3301,7 +3302,8 @@\n     }\n \n   if (GET_MODE_UNIT_BITSIZE (<MODE>mode) == 32)\n-    emit_insn (gen_vec_extract<mode> (operands[0], operands[1], operands[2]));\n+    emit_insn (gen_vec_extract<mode><V_elem_l> (operands[0], operands[1],\n+\t\t\t\t\t\toperands[2]));\n   else\n     emit_insn (gen_neon_vget_lane<mode>_zext_internal (operands[0],\n \t\t\t\t\t\t       operands[1],"}, {"sha": "a115c4cc31bdddc14ff45d2ce33db703149d9201", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -44318,6 +44318,34 @@ ix86_expand_vector_init (bool mmx_ok, rtx target, rtx vals)\n   int i;\n   rtx x;\n \n+  /* Handle first initialization from vector elts.  */\n+  if (n_elts != XVECLEN (vals, 0))\n+    {\n+      rtx subtarget = target;\n+      x = XVECEXP (vals, 0, 0);\n+      gcc_assert (GET_MODE_INNER (GET_MODE (x)) == inner_mode);\n+      if (GET_MODE_NUNITS (GET_MODE (x)) * 2 == n_elts)\n+\t{\n+\t  rtx ops[2] = { XVECEXP (vals, 0, 0), XVECEXP (vals, 0, 1) };\n+\t  if (inner_mode == QImode || inner_mode == HImode)\n+\t    {\n+\t      mode = mode_for_vector (SImode,\n+\t\t\t\t      n_elts * GET_MODE_SIZE (inner_mode) / 4);\n+\t      inner_mode\n+\t\t= mode_for_vector (SImode,\n+\t\t\t\t   n_elts * GET_MODE_SIZE (inner_mode) / 8);\n+\t      ops[0] = gen_lowpart (inner_mode, ops[0]);\n+\t      ops[1] = gen_lowpart (inner_mode, ops[1]);\n+\t      subtarget = gen_reg_rtx (mode);\n+\t    }\n+\t  ix86_expand_vector_init_concat (mode, subtarget, ops, 2);\n+\t  if (subtarget != target)\n+\t    emit_move_insn (target, gen_lowpart (GET_MODE (target), subtarget));\n+\t  return;\n+\t}\n+      gcc_unreachable ();\n+    }\n+\n   for (i = 0; i < n_elts; ++i)\n     {\n       x = XVECEXP (vals, 0, i);"}, {"sha": "b3f3633e96449ac221a60baa054bb60f89723249", "filename": "gcc/config/i386/mmx.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fi386%2Fmmx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fi386%2Fmmx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmx.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -641,7 +641,7 @@\n   [(set (match_dup 0) (match_dup 1))]\n   \"operands[1] = adjust_address (operands[1], SFmode, 4);\")\n \n-(define_expand \"vec_extractv2sf\"\n+(define_expand \"vec_extractv2sfsf\"\n   [(match_operand:SF 0 \"register_operand\")\n    (match_operand:V2SF 1 \"register_operand\")\n    (match_operand 2 \"const_int_operand\")]\n@@ -652,7 +652,7 @@\n   DONE;\n })\n \n-(define_expand \"vec_initv2sf\"\n+(define_expand \"vec_initv2sfsf\"\n   [(match_operand:V2SF 0 \"register_operand\")\n    (match_operand 1)]\n   \"TARGET_SSE\"\n@@ -1344,7 +1344,7 @@\n   operands[1] = adjust_address (operands[1], SImode, INTVAL (operands[2]) * 4);\n })\n \n-(define_expand \"vec_extractv2si\"\n+(define_expand \"vec_extractv2sisi\"\n   [(match_operand:SI 0 \"register_operand\")\n    (match_operand:V2SI 1 \"register_operand\")\n    (match_operand 2 \"const_int_operand\")]\n@@ -1355,7 +1355,7 @@\n   DONE;\n })\n \n-(define_expand \"vec_initv2si\"\n+(define_expand \"vec_initv2sisi\"\n   [(match_operand:V2SI 0 \"register_operand\")\n    (match_operand 1)]\n   \"TARGET_SSE\"\n@@ -1375,7 +1375,7 @@\n   DONE;\n })\n \n-(define_expand \"vec_extractv4hi\"\n+(define_expand \"vec_extractv4hihi\"\n   [(match_operand:HI 0 \"register_operand\")\n    (match_operand:V4HI 1 \"register_operand\")\n    (match_operand 2 \"const_int_operand\")]\n@@ -1386,7 +1386,7 @@\n   DONE;\n })\n \n-(define_expand \"vec_initv4hi\"\n+(define_expand \"vec_initv4hihi\"\n   [(match_operand:V4HI 0 \"register_operand\")\n    (match_operand 1)]\n   \"TARGET_SSE\"\n@@ -1406,7 +1406,7 @@\n   DONE;\n })\n \n-(define_expand \"vec_extractv8qi\"\n+(define_expand \"vec_extractv8qiqi\"\n   [(match_operand:QI 0 \"register_operand\")\n    (match_operand:V8QI 1 \"register_operand\")\n    (match_operand 2 \"const_int_operand\")]\n@@ -1417,7 +1417,7 @@\n   DONE;\n })\n \n-(define_expand \"vec_initv8qi\"\n+(define_expand \"vec_initv8qiqi\"\n   [(match_operand:V8QI 0 \"register_operand\")\n    (match_operand 1)]\n   \"TARGET_SSE\""}, {"sha": "253ff5d5a7d2ce51e4ca4b43fce26cbda77d01c2", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 72, "deletions": 18, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -658,13 +658,21 @@\n \n ;; Mapping of vector modes to a vector mode of half size\n (define_mode_attr ssehalfvecmode\n-  [(V64QI \"V32QI\") (V32HI \"V16HI\") (V16SI \"V8SI\") (V8DI \"V4DI\")\n+  [(V64QI \"V32QI\") (V32HI \"V16HI\") (V16SI \"V8SI\") (V8DI \"V4DI\") (V4TI \"V2TI\")\n    (V32QI \"V16QI\") (V16HI  \"V8HI\") (V8SI  \"V4SI\") (V4DI \"V2DI\")\n    (V16QI  \"V8QI\") (V8HI   \"V4HI\") (V4SI  \"V2SI\")\n    (V16SF \"V8SF\") (V8DF \"V4DF\")\n    (V8SF  \"V4SF\") (V4DF \"V2DF\")\n    (V4SF  \"V2SF\")])\n \n+(define_mode_attr ssehalfvecmodelower\n+  [(V64QI \"v32qi\") (V32HI \"v16hi\") (V16SI \"v8si\") (V8DI \"v4di\") (V4TI \"v2ti\")\n+   (V32QI \"v16qi\") (V16HI  \"v8hi\") (V8SI  \"v4si\") (V4DI \"v2di\")\n+   (V16QI  \"v8qi\") (V8HI   \"v4hi\") (V4SI  \"v2si\")\n+   (V16SF \"v8sf\") (V8DF \"v4df\")\n+   (V8SF  \"v4sf\") (V4DF \"v2df\")\n+   (V4SF  \"v2sf\")])\n+\n ;; Mapping of vector modes ti packed single mode of the same size\n (define_mode_attr ssePSmode\n   [(V16SI \"V16SF\") (V8DF \"V16SF\")\n@@ -690,6 +698,16 @@\n    (V8DF \"DF\")  (V4DF \"DF\")  (V2DF \"DF\")\n    (V4TI \"TI\")  (V2TI \"TI\")])\n \n+;; Mapping of vector modes back to the scalar modes\n+(define_mode_attr ssescalarmodelower\n+  [(V64QI \"qi\") (V32QI \"qi\") (V16QI \"qi\")\n+   (V32HI \"hi\") (V16HI \"hi\") (V8HI \"hi\")\n+   (V16SI \"si\") (V8SI \"si\")  (V4SI \"si\")\n+   (V8DI \"di\")  (V4DI \"di\")  (V2DI \"di\")\n+   (V16SF \"sf\") (V8SF \"sf\")  (V4SF \"sf\")\n+   (V8DF \"df\")  (V4DF \"df\")  (V2DF \"df\")\n+   (V4TI \"ti\")  (V2TI \"ti\")])\n+\n ;; Mapping of vector modes to the 128bit modes\n (define_mode_attr ssexmmmode\n   [(V64QI \"V16QI\") (V32QI \"V16QI\") (V16QI \"V16QI\")\n@@ -2356,7 +2374,7 @@\n {\n   rtx tmp = gen_reg_rtx (V8DFmode);\n   ix86_expand_reduc (gen_addv8df3, tmp, operands[1]);\n-  emit_insn (gen_vec_extractv8df (operands[0], tmp, const0_rtx));\n+  emit_insn (gen_vec_extractv8dfdf (operands[0], tmp, const0_rtx));\n   DONE;\n })\n \n@@ -2371,7 +2389,7 @@\n   emit_insn (gen_avx_haddv4df3 (tmp, operands[1], operands[1]));\n   emit_insn (gen_avx_vperm2f128v4df3 (tmp2, tmp, tmp, GEN_INT (1)));\n   emit_insn (gen_addv4df3 (vec_res, tmp, tmp2));\n-  emit_insn (gen_vec_extractv4df (operands[0], vec_res, const0_rtx));\n+  emit_insn (gen_vec_extractv4dfdf (operands[0], vec_res, const0_rtx));\n   DONE;\n })\n \n@@ -2382,7 +2400,7 @@\n {\n   rtx tmp = gen_reg_rtx (V2DFmode);\n   emit_insn (gen_sse3_haddv2df3 (tmp, operands[1], operands[1]));\n-  emit_insn (gen_vec_extractv2df (operands[0], tmp, const0_rtx));\n+  emit_insn (gen_vec_extractv2dfdf (operands[0], tmp, const0_rtx));\n   DONE;\n })\n \n@@ -2393,7 +2411,7 @@\n {\n   rtx tmp = gen_reg_rtx (V16SFmode);\n   ix86_expand_reduc (gen_addv16sf3, tmp, operands[1]);\n-  emit_insn (gen_vec_extractv16sf (operands[0], tmp, const0_rtx));\n+  emit_insn (gen_vec_extractv16sfsf (operands[0], tmp, const0_rtx));\n   DONE;\n })\n \n@@ -2409,7 +2427,7 @@\n   emit_insn (gen_avx_haddv8sf3 (tmp2, tmp, tmp));\n   emit_insn (gen_avx_vperm2f128v8sf3 (tmp, tmp2, tmp2, GEN_INT (1)));\n   emit_insn (gen_addv8sf3 (vec_res, tmp, tmp2));\n-  emit_insn (gen_vec_extractv8sf (operands[0], vec_res, const0_rtx));\n+  emit_insn (gen_vec_extractv8sfsf (operands[0], vec_res, const0_rtx));\n   DONE;\n })\n \n@@ -2427,7 +2445,7 @@\n     }\n   else\n     ix86_expand_reduc (gen_addv4sf3, vec_res, operands[1]);\n-  emit_insn (gen_vec_extractv4sf (operands[0], vec_res, const0_rtx));\n+  emit_insn (gen_vec_extractv4sfsf (operands[0], vec_res, const0_rtx));\n   DONE;\n })\n \n@@ -2449,7 +2467,8 @@\n {\n   rtx tmp = gen_reg_rtx (<MODE>mode);\n   ix86_expand_reduc (gen_<code><mode>3, tmp, operands[1]);\n-  emit_insn (gen_vec_extract<mode> (operands[0], tmp, const0_rtx));\n+  emit_insn (gen_vec_extract<mode><ssescalarmodelower> (operands[0], tmp,\n+\t\t\t\t\t\t\tconst0_rtx));\n   DONE;\n })\n \n@@ -2461,7 +2480,8 @@\n {\n   rtx tmp = gen_reg_rtx (<MODE>mode);\n   ix86_expand_reduc (gen_<code><mode>3, tmp, operands[1]);\n-  emit_insn (gen_vec_extract<mode> (operands[0], tmp, const0_rtx));\n+  emit_insn (gen_vec_extract<mode><ssescalarmodelower> (operands[0], tmp,\n+  \t\t\t\t\t\t\tconst0_rtx));\n   DONE;\n })\n \n@@ -2473,7 +2493,8 @@\n {\n   rtx tmp = gen_reg_rtx (<MODE>mode);\n   ix86_expand_reduc (gen_<code><mode>3, tmp, operands[1]);\n-  emit_insn (gen_vec_extract<mode> (operands[0], tmp, const0_rtx));\n+  emit_insn (gen_vec_extract<mode><ssescalarmodelower> (operands[0], tmp,\n+\t\t\t\t\t\t\tconst0_rtx));\n   DONE;\n })\n \n@@ -2485,7 +2506,7 @@\n {\n   rtx tmp = gen_reg_rtx (V8HImode);\n   ix86_expand_reduc (gen_uminv8hi3, tmp, operands[1]);\n-  emit_insn (gen_vec_extractv8hi (operands[0], tmp, const0_rtx));\n+  emit_insn (gen_vec_extractv8hihi (operands[0], tmp, const0_rtx));\n   DONE;\n })\n \n@@ -7881,7 +7902,7 @@\n    (V8DF \"TARGET_AVX512F\") (V4DF \"TARGET_AVX\") V2DF\n    (V4TI \"TARGET_AVX512F\") (V2TI \"TARGET_AVX\")])\n \n-(define_expand \"vec_extract<mode>\"\n+(define_expand \"vec_extract<mode><ssescalarmodelower>\"\n   [(match_operand:<ssescalarmode> 0 \"register_operand\")\n    (match_operand:VEC_EXTRACT_MODE 1 \"register_operand\")\n    (match_operand 2 \"const_int_operand\")]\n@@ -7892,6 +7913,19 @@\n   DONE;\n })\n \n+(define_expand \"vec_extract<mode><ssehalfvecmodelower>\"\n+  [(match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\")\n+   (match_operand:V_512 1 \"register_operand\")\n+   (match_operand 2 \"const_0_to_1_operand\")]\n+  \"TARGET_AVX512F\"\n+{\n+  if (INTVAL (operands[2]))\n+    emit_insn (gen_vec_extract_hi_<mode> (operands[0], operands[1]));\n+  else\n+    emit_insn (gen_vec_extract_lo_<mode> (operands[0], operands[1]));\n+  DONE;\n+})\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel double-precision floating point element swizzling\n@@ -16693,7 +16727,7 @@\n       for (i = 0; i < <ssescalarnum>; i++)\n \tRTVEC_ELT (vs, i) = op2;\n \n-      emit_insn (gen_vec_init<mode> (reg, par));\n+      emit_insn (gen_vec_init<mode><ssescalarmodelower> (reg, par));\n       emit_insn (gen_xop_vrotl<mode>3 (operands[0], operands[1], reg));\n       DONE;\n     }\n@@ -16725,7 +16759,7 @@\n       for (i = 0; i < <ssescalarnum>; i++)\n \tRTVEC_ELT (vs, i) = op2;\n \n-      emit_insn (gen_vec_init<mode> (reg, par));\n+      emit_insn (gen_vec_init<mode><ssescalarmodelower> (reg, par));\n       emit_insn (gen_neg<mode>2 (neg, reg));\n       emit_insn (gen_xop_vrotl<mode>3 (operands[0], operands[1], neg));\n       DONE;\n@@ -17019,7 +17053,7 @@\n         XVECEXP (par, 0, i) = operands[2];\n \n       tmp = gen_reg_rtx (V16QImode);\n-      emit_insn (gen_vec_initv16qi (tmp, par));\n+      emit_insn (gen_vec_initv16qiqi (tmp, par));\n \n       if (negate)\n \temit_insn (gen_negv16qi2 (tmp, tmp));\n@@ -17055,7 +17089,7 @@\n       for (i = 0; i < 2; i++)\n \tXVECEXP (par, 0, i) = operands[2];\n \n-      emit_insn (gen_vec_initv2di (reg, par));\n+      emit_insn (gen_vec_initv2didi (reg, par));\n \n       if (negate)\n \temit_insn (gen_negv2di2 (reg, reg));\n@@ -18775,7 +18809,7 @@\n \t\t\t\t  <ssehalfvecmode>mode);\n })\n \n-;; Modes handled by vec_init patterns.\n+;; Modes handled by vec_init expanders.\n (define_mode_iterator VEC_INIT_MODE\n   [(V64QI \"TARGET_AVX512F\") (V32QI \"TARGET_AVX\") V16QI\n    (V32HI \"TARGET_AVX512F\") (V16HI \"TARGET_AVX\") V8HI\n@@ -18785,7 +18819,18 @@\n    (V8DF \"TARGET_AVX512F\") (V4DF \"TARGET_AVX\") (V2DF \"TARGET_SSE2\")\n    (V4TI \"TARGET_AVX512F\") (V2TI \"TARGET_AVX\")])\n \n-(define_expand \"vec_init<mode>\"\n+;; Likewise, but for initialization from half sized vectors.\n+;; Thus, these are all VEC_INIT_MODE modes except V2??.\n+(define_mode_iterator VEC_INIT_HALF_MODE\n+  [(V64QI \"TARGET_AVX512F\") (V32QI \"TARGET_AVX\") V16QI\n+   (V32HI \"TARGET_AVX512F\") (V16HI \"TARGET_AVX\") V8HI\n+   (V16SI \"TARGET_AVX512F\") (V8SI \"TARGET_AVX\") V4SI\n+   (V8DI \"TARGET_AVX512F\") (V4DI \"TARGET_AVX\")\n+   (V16SF \"TARGET_AVX512F\") (V8SF \"TARGET_AVX\") V4SF\n+   (V8DF \"TARGET_AVX512F\") (V4DF \"TARGET_AVX\")\n+   (V4TI \"TARGET_AVX512F\")])\n+\n+(define_expand \"vec_init<mode><ssescalarmodelower>\"\n   [(match_operand:VEC_INIT_MODE 0 \"register_operand\")\n    (match_operand 1)]\n   \"TARGET_SSE\"\n@@ -18794,6 +18839,15 @@\n   DONE;\n })\n \n+(define_expand \"vec_init<mode><ssehalfvecmodelower>\"\n+  [(match_operand:VEC_INIT_HALF_MODE 0 \"register_operand\")\n+   (match_operand 1)]\n+  \"TARGET_SSE\"\n+{\n+  ix86_expand_vector_init (false, operands[0], operands[1]);\n+  DONE;\n+})\n+\n (define_insn \"<avx2_avx512>_ashrv<mode><mask_name>\"\n   [(set (match_operand:VI48_AVX512F_AVX512VL 0 \"register_operand\" \"=v\")\n \t(ashiftrt:VI48_AVX512F_AVX512VL"}, {"sha": "8e76864a77f12fcfc42cdc4f673dab45731fd5e9", "filename": "gcc/config/ia64/vect.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fia64%2Fvect.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fia64%2Fvect.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fvect.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -1015,7 +1015,7 @@\n }\n   [(set_attr \"itanium_class\" \"mmshf\")])\n \n-(define_expand \"vec_initv2si\"\n+(define_expand \"vec_initv2sisi\"\n   [(match_operand:V2SI 0 \"gr_register_operand\" \"\")\n    (match_operand 1 \"\" \"\")]\n   \"\"\n@@ -1299,7 +1299,7 @@\n   \"fselect %0 = %F2, %F3, %1\"\n   [(set_attr \"itanium_class\" \"fmisc\")])\n \n-(define_expand \"vec_initv2sf\"\n+(define_expand \"vec_initv2sfsf\"\n   [(match_operand:V2SF 0 \"fr_register_operand\" \"\")\n    (match_operand 1 \"\" \"\")]\n   \"\"\n@@ -1483,7 +1483,7 @@\n   operands[1] = gen_rtx_REG (SFmode, REGNO (operands[1]));\n })\n \n-(define_expand \"vec_extractv2sf\"\n+(define_expand \"vec_extractv2sfsf\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(unspec:SF [(match_operand:V2SF 1 \"register_operand\" \"\")\n \t\t    (match_operand:DI 2 \"const_int_operand\" \"\")]"}, {"sha": "b48dfa0dc713dc0b9ebf3c7b4eb8db6ab1735a3e", "filename": "gcc/config/mips/loongson.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fmips%2Floongson.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fmips%2Floongson.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Floongson.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -119,7 +119,7 @@\n \n ;; Initialization of a vector.\n \n-(define_expand \"vec_init<mode>\"\n+(define_expand \"vec_init<mode><unitmode>\"\n   [(set (match_operand:VWHB 0 \"register_operand\")\n \t(match_operand 1 \"\"))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\""}, {"sha": "87d889d72963209c16326e744b729b65ae860624", "filename": "gcc/config/mips/mips-msa.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fmips%2Fmips-msa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fmips%2Fmips-msa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-msa.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -231,7 +231,7 @@\n    (V4SI  \"uimm5\")\n    (V2DI  \"uimm6\")])\n \n-(define_expand \"vec_init<mode>\"\n+(define_expand \"vec_init<mode><unitmode>\"\n   [(match_operand:MSA 0 \"register_operand\")\n    (match_operand:MSA 1 \"\")]\n   \"ISA_HAS_MSA\"\n@@ -311,7 +311,7 @@\n   DONE;\n })\n \n-(define_expand \"vec_extract<mode>\"\n+(define_expand \"vec_extract<mode><unitmode>\"\n   [(match_operand:<UNITMODE> 0 \"register_operand\")\n    (match_operand:IMSA 1 \"register_operand\")\n    (match_operand 2 \"const_<indeximm>_operand\")]\n@@ -329,7 +329,7 @@\n   DONE;\n })\n \n-(define_expand \"vec_extract<mode>\"\n+(define_expand \"vec_extract<mode><unitmode>\"\n   [(match_operand:<UNITMODE> 0 \"register_operand\")\n    (match_operand:FMSA 1 \"register_operand\")\n    (match_operand 2 \"const_<indeximm>_operand\")]"}, {"sha": "81820b13b11c8ac003fbda4f00ae4672969737af", "filename": "gcc/config/mips/mips-ps-3d.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -254,7 +254,7 @@\n })\n \n ; vec_init\n-(define_expand \"vec_initv2sf\"\n+(define_expand \"vec_initv2sfsf\"\n   [(match_operand:V2SF 0 \"register_operand\")\n    (match_operand:V2SF 1 \"\")]\n   \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n@@ -282,7 +282,7 @@\n ;; emulated.  There is no other way to get a vector mode bitfield extract\n ;; currently.\n \n-(define_insn \"vec_extractv2sf\"\n+(define_insn \"vec_extractv2sfsf\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(vec_select:SF (match_operand:V2SF 1 \"register_operand\" \"f\")\n \t\t       (parallel\n@@ -379,7 +379,7 @@\n     rtx temp = gen_reg_rtx (V2SFmode);\n     emit_insn (gen_mips_addr_ps (temp, operands[1], operands[1]));\n     rtx lane = BYTES_BIG_ENDIAN ? const1_rtx : const0_rtx;\n-    emit_insn (gen_vec_extractv2sf (operands[0], temp, lane));\n+    emit_insn (gen_vec_extractv2sfsf (operands[0], temp, lane));\n     DONE;\n   })\n \n@@ -757,7 +757,7 @@\n   rtx temp = gen_reg_rtx (V2SFmode);\n   mips_expand_vec_reduc (temp, operands[1], gen_sminv2sf3);\n   rtx lane = BYTES_BIG_ENDIAN ? const1_rtx : const0_rtx;\n-  emit_insn (gen_vec_extractv2sf (operands[0], temp, lane));\n+  emit_insn (gen_vec_extractv2sfsf (operands[0], temp, lane));\n   DONE;\n })\n \n@@ -769,6 +769,6 @@\n   rtx temp = gen_reg_rtx (V2SFmode);\n   mips_expand_vec_reduc (temp, operands[1], gen_smaxv2sf3);\n   rtx lane = BYTES_BIG_ENDIAN ? const1_rtx : const0_rtx;\n-  emit_insn (gen_vec_extractv2sf (operands[0], temp, lane));\n+  emit_insn (gen_vec_extractv2sfsf (operands[0], temp, lane));\n   DONE;\n })"}, {"sha": "f45c3eb98ce1fa09b49b2f47ea6fd0cf0219542f", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -917,6 +917,11 @@\n \t\t\t    (V16QI \"QI\") (V8HI \"HI\") (V4SI \"SI\") (V2DI \"DI\")\n \t\t\t    (V2DF \"DF\")])\n \n+;; As above, but in lower case.\n+(define_mode_attr unitmode [(SF \"sf\") (DF \"df\") (V2SF \"sf\") (V4SF \"sf\")\n+\t\t\t    (V16QI \"qi\") (V8QI \"qi\") (V8HI \"hi\") (V4HI \"hi\")\n+\t\t\t    (V4SI \"si\") (V2SI \"si\") (V2DI \"di\") (V2DF \"df\")])\n+\n ;; This attribute gives the integer mode that has the same size as a\n ;; fixed-point mode.\n (define_mode_attr IMODE [(QQ \"QI\") (HQ \"HI\") (SQ \"SI\") (DQ \"DI\")"}, {"sha": "e98309a8ad416d6abee8020080272010936a08b7", "filename": "gcc/config/powerpcspe/altivec.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fpowerpcspe%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fpowerpcspe%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Faltivec.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -301,7 +301,7 @@\n   for (i = 0; i < num_elements; i++)\n     RTVEC_ELT (v, i) = constm1_rtx;\n \n-  emit_insn (gen_vec_initv4si (dest, gen_rtx_PARALLEL (mode, v)));\n+  emit_insn (gen_vec_initv4sisi (dest, gen_rtx_PARALLEL (mode, v)));\n   emit_insn (gen_rtx_SET (dest, gen_rtx_ASHIFT (mode, dest, dest)));\n   DONE;\n })\n@@ -2222,7 +2222,7 @@\n   RTVEC_ELT (v, 2) = GEN_INT (mask_val);\n   RTVEC_ELT (v, 3) = GEN_INT (mask_val);\n \n-  emit_insn (gen_vec_initv4si (mask, gen_rtx_PARALLEL (V4SImode, v)));\n+  emit_insn (gen_vec_initv4sisi (mask, gen_rtx_PARALLEL (V4SImode, v)));\n   emit_insn (gen_vector_select_v4sf (operands[0], operands[1], operands[2],\n \t\t\t\t     gen_lowpart (V4SFmode, mask)));\n   DONE;\n@@ -3014,7 +3014,7 @@\n   RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, be ? 16 :  0);\n   RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, be ?  7 : 16);\n \n-  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_vec_initv16qiqi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n   emit_insn (gen_vperm_v16qiv8hi (operands[0], operands[1], vzero, mask));\n   DONE;\n }\")\n@@ -3050,7 +3050,7 @@\n   RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, be ?  6 : 17);\n   RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, be ?  7 : 16);\n \n-  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_vec_initv16qiqi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n   emit_insn (gen_vperm_v8hiv4si (operands[0], operands[1], vzero, mask));\n   DONE;\n }\")\n@@ -3086,7 +3086,7 @@\n   RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, be ? 16 :  8);\n   RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, be ? 15 : 16);\n \n-  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_vec_initv16qiqi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n   emit_insn (gen_vperm_v16qiv8hi (operands[0], operands[1], vzero, mask));\n   DONE;\n }\")\n@@ -3122,7 +3122,7 @@\n   RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, be ? 14 : 17);\n   RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, be ? 15 : 16);\n \n-  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_vec_initv16qiqi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n   emit_insn (gen_vperm_v8hiv4si (operands[0], operands[1], vzero, mask));\n   DONE;\n }\")\n@@ -3363,7 +3363,7 @@\n      = gen_rtx_CONST_INT (QImode, BYTES_BIG_ENDIAN ? 2 * i + 17 : 15 - 2 * i);\n   }\n \n-  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_vec_initv16qiqi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n   emit_insn (gen_altivec_vmulesb (even, operands[1], operands[2]));\n   emit_insn (gen_altivec_vmulosb (odd, operands[1], operands[2]));\n   emit_insn (gen_altivec_vperm_v8hiv16qi (operands[0], even, odd, mask));"}, {"sha": "e12f07fc9b8a497cfb31890d1e3eb9a6b0354890", "filename": "gcc/config/powerpcspe/paired.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fpowerpcspe%2Fpaired.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fpowerpcspe%2Fpaired.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpaired.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -377,7 +377,7 @@\n   \"ps_muls1 %0, %1, %2\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"vec_initv2sf\"\n+(define_expand \"vec_initv2sfsf\"\n   [(match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n    (match_operand 1 \"\" \"\")]\n   \"TARGET_PAIRED_FLOAT\""}, {"sha": "6c43186f8aa62d28af8fca791349ce8df47b1c2a", "filename": "gcc/config/powerpcspe/vector.md", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fpowerpcspe%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fpowerpcspe%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fvector.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -74,6 +74,16 @@\n \t\t\t    (V1TI  \"TI\")\n \t\t\t    (TI    \"TI\")])\n \n+;; As above, but in lower case\n+(define_mode_attr VEC_base_l [(V16QI \"qi\")\n+\t\t\t      (V8HI  \"hi\")\n+\t\t\t      (V4SI  \"si\")\n+\t\t\t      (V2DI  \"di\")\n+\t\t\t      (V4SF  \"sf\")\n+\t\t\t      (V2DF  \"df\")\n+\t\t\t      (V1TI  \"ti\")\n+\t\t\t      (TI    \"ti\")])\n+\n ;; Same size integer type for floating point data\n (define_mode_attr VEC_int [(V4SF  \"v4si\")\n \t\t\t   (V2DF  \"v2di\")])\n@@ -1017,7 +1027,7 @@\n \n \f\n ;; Vector initialization, set, extract\n-(define_expand \"vec_init<mode>\"\n+(define_expand \"vec_init<mode><VEC_base_l>\"\n   [(match_operand:VEC_E 0 \"vlogical_operand\" \"\")\n    (match_operand:VEC_E 1 \"\" \"\")]\n   \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n@@ -1036,7 +1046,7 @@\n   DONE;\n })\n \n-(define_expand \"vec_extract<mode>\"\n+(define_expand \"vec_extract<mode><VEC_base_l>\"\n   [(match_operand:<VEC_base> 0 \"register_operand\" \"\")\n    (match_operand:VEC_E 1 \"vlogical_operand\" \"\")\n    (match_operand 2 \"const_int_operand\" \"\")]"}, {"sha": "4077afdadb62c2a52a6457663a9c20d0f737edd5", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -311,7 +311,7 @@\n   for (i = 0; i < num_elements; i++)\n     RTVEC_ELT (v, i) = constm1_rtx;\n \n-  emit_insn (gen_vec_initv4si (dest, gen_rtx_PARALLEL (mode, v)));\n+  emit_insn (gen_vec_initv4sisi (dest, gen_rtx_PARALLEL (mode, v)));\n   emit_insn (gen_rtx_SET (dest, gen_rtx_ASHIFT (mode, dest, dest)));\n   DONE;\n })\n@@ -2267,7 +2267,7 @@\n   RTVEC_ELT (v, 2) = GEN_INT (mask_val);\n   RTVEC_ELT (v, 3) = GEN_INT (mask_val);\n \n-  emit_insn (gen_vec_initv4si (mask, gen_rtx_PARALLEL (V4SImode, v)));\n+  emit_insn (gen_vec_initv4sisi (mask, gen_rtx_PARALLEL (V4SImode, v)));\n   emit_insn (gen_vector_select_v4sf (operands[0], operands[1], operands[2],\n \t\t\t\t     gen_lowpart (V4SFmode, mask)));\n   DONE;\n@@ -3409,7 +3409,7 @@\n   RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, be ? 16 :  0);\n   RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, be ?  7 : 16);\n \n-  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_vec_initv16qiqi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n   emit_insn (gen_vperm_v16qiv8hi (operands[0], operands[1], vzero, mask));\n   DONE;\n }\")\n@@ -3445,7 +3445,7 @@\n   RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, be ?  6 : 17);\n   RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, be ?  7 : 16);\n \n-  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_vec_initv16qiqi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n   emit_insn (gen_vperm_v8hiv4si (operands[0], operands[1], vzero, mask));\n   DONE;\n }\")\n@@ -3481,7 +3481,7 @@\n   RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, be ? 16 :  8);\n   RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, be ? 15 : 16);\n \n-  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_vec_initv16qiqi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n   emit_insn (gen_vperm_v16qiv8hi (operands[0], operands[1], vzero, mask));\n   DONE;\n }\")\n@@ -3517,7 +3517,7 @@\n   RTVEC_ELT (v, 14) = gen_rtx_CONST_INT (QImode, be ? 14 : 17);\n   RTVEC_ELT (v, 15) = gen_rtx_CONST_INT (QImode, be ? 15 : 16);\n \n-  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_vec_initv16qiqi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n   emit_insn (gen_vperm_v8hiv4si (operands[0], operands[1], vzero, mask));\n   DONE;\n }\")\n@@ -3758,7 +3758,7 @@\n      = gen_rtx_CONST_INT (QImode, BYTES_BIG_ENDIAN ? 2 * i + 17 : 15 - 2 * i);\n   }\n \n-  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_vec_initv16qiqi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n   emit_insn (gen_altivec_vmulesb (even, operands[1], operands[2]));\n   emit_insn (gen_altivec_vmulosb (odd, operands[1], operands[2]));\n   emit_insn (gen_altivec_vperm_v8hiv16qi (operands[0], even, odd, mask));\n@@ -3804,7 +3804,7 @@\n       RTVEC_ELT (v, i + j * size)\n \t= GEN_INT (i + (num_elements - 1 - j) * size);\n \n-  emit_insn (gen_vec_initv16qi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n+  emit_insn (gen_vec_initv16qiqi (mask, gen_rtx_PARALLEL (V16QImode, v)));\n   emit_insn (gen_altivec_vperm_<mode> (operands[0], operands[1],\n \t     operands[1], mask));\n   DONE;"}, {"sha": "b0aa329d7b844c6b1286597d4e110e8e2f17ba38", "filename": "gcc/config/rs6000/paired.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Frs6000%2Fpaired.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Frs6000%2Fpaired.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpaired.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -377,7 +377,7 @@\n   \"ps_muls1 %0, %1, %2\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"vec_initv2sf\"\n+(define_expand \"vec_initv2sfsf\"\n   [(match_operand:V2SF 0 \"gpc_reg_operand\" \"=f\")\n    (match_operand 1 \"\" \"\")]\n   \"TARGET_PAIRED_FLOAT\""}, {"sha": "d6f2fd13fcbd28c02d6f7b073e1d5876475fe09b", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -74,6 +74,16 @@\n \t\t\t    (V1TI  \"TI\")\n \t\t\t    (TI    \"TI\")])\n \n+;; As above, but in lower case\n+(define_mode_attr VEC_base_l [(V16QI \"qi\")\n+\t\t\t      (V8HI  \"hi\")\n+\t\t\t      (V4SI  \"si\")\n+\t\t\t      (V2DI  \"di\")\n+\t\t\t      (V4SF  \"sf\")\n+\t\t\t      (V2DF  \"df\")\n+\t\t\t      (V1TI  \"ti\")\n+\t\t\t      (TI    \"ti\")])\n+\n ;; Same size integer type for floating point data\n (define_mode_attr VEC_int [(V4SF  \"v4si\")\n \t\t\t   (V2DF  \"v2di\")])\n@@ -1016,7 +1026,7 @@\n \n \f\n ;; Vector initialization, set, extract\n-(define_expand \"vec_init<mode>\"\n+(define_expand \"vec_init<mode><VEC_base_l>\"\n   [(match_operand:VEC_E 0 \"vlogical_operand\" \"\")\n    (match_operand:VEC_E 1 \"\" \"\")]\n   \"VECTOR_MEM_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n@@ -1035,7 +1045,7 @@\n   DONE;\n })\n \n-(define_expand \"vec_extract<mode>\"\n+(define_expand \"vec_extract<mode><VEC_base_l>\"\n   [(match_operand:<VEC_base> 0 \"register_operand\" \"\")\n    (match_operand:VEC_E 1 \"vlogical_operand\" \"\")\n    (match_operand 2 \"const_int_operand\" \"\")]"}, {"sha": "ddcf370cb234d56e4447292afd63c5d2294e73b3", "filename": "gcc/config/s390/s390-builtins.def", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fs390%2Fs390-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fs390%2Fs390-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-builtins.def?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -450,12 +450,12 @@ OB_DEF_VAR (s390_vec_extract_u64,       s390_vlgvg,         0,\n OB_DEF_VAR (s390_vec_extract_b64,       s390_vlgvg,         0,                  O2_ELEM,            BT_OV_ULONGLONG_BV2DI_INT)\n OB_DEF_VAR (s390_vec_extract_dbl,       s390_vlgvg_dbl,     0,                  O2_ELEM,            BT_OV_DBL_V2DF_INT)                      /* vlgvg */\n \n-B_DEF      (s390_vlgvb,                 vec_extractv16qi,   0,                  B_VX,               O2_ELEM,            BT_FN_UCHAR_UV16QI_INT)\n-B_DEF      (s390_vlgvh,                 vec_extractv8hi,    0,                  B_VX,               O2_ELEM,            BT_FN_USHORT_UV8HI_INT)\n-B_DEF      (s390_vlgvf,                 vec_extractv4si,    0,                  B_VX,               O2_ELEM,            BT_FN_UINT_UV4SI_INT)\n-B_DEF      (s390_vlgvf_flt,             vec_extractv4sf,    0,                  B_INT | B_VXE,      O2_ELEM,            BT_FN_FLT_V4SF_INT)\n-B_DEF      (s390_vlgvg,                 vec_extractv2di,    0,                  B_VX,               O2_ELEM,            BT_FN_ULONGLONG_UV2DI_INT)\n-B_DEF      (s390_vlgvg_dbl,             vec_extractv2df,    0,                  B_INT | B_VX,       O2_ELEM,            BT_FN_DBL_V2DF_INT)\n+B_DEF      (s390_vlgvb,                 vec_extractv16qiqi, 0,                  B_VX,               O2_ELEM,            BT_FN_UCHAR_UV16QI_INT)\n+B_DEF      (s390_vlgvh,                 vec_extractv8hihi,  0,                  B_VX,               O2_ELEM,            BT_FN_USHORT_UV8HI_INT)\n+B_DEF      (s390_vlgvf,                 vec_extractv4sisi,  0,                  B_VX,               O2_ELEM,            BT_FN_UINT_UV4SI_INT)\n+B_DEF      (s390_vlgvf_flt,             vec_extractv4sfsf,  0,                  B_INT | B_VXE,      O2_ELEM,            BT_FN_FLT_V4SF_INT)\n+B_DEF      (s390_vlgvg,                 vec_extractv2didi,  0,                  B_VX,               O2_ELEM,            BT_FN_ULONGLONG_UV2DI_INT)\n+B_DEF      (s390_vlgvg_dbl,             vec_extractv2dfdf,  0,                  B_INT | B_VX,       O2_ELEM,            BT_FN_DBL_V2DF_INT)\n \n OB_DEF     (s390_vec_insert_and_zero,   s390_vec_insert_and_zero_s8,s390_vec_insert_and_zero_dbl,B_VX,BT_FN_OV4SI_INTCONSTPTR)\n OB_DEF_VAR (s390_vec_insert_and_zero_s8,s390_vllezb,        0,                  0,                  BT_OV_V16QI_SCHARCONSTPTR)"}, {"sha": "9f422c88a99a3218a1562a48b1fa46df69761fc4", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -5795,7 +5795,7 @@ s390_expand_vec_strlen (rtx target, rtx string, rtx alignment)\n   add_int_reg_note (s390_emit_ccraw_jump (8, NE, loop_start_label),\n \t\t    REG_BR_PROB,\n \t\t    profile_probability::very_likely ().to_reg_br_prob_note ());\n-  emit_insn (gen_vec_extractv16qi (len, result_reg, GEN_INT (7)));\n+  emit_insn (gen_vec_extractv16qiqi (len, result_reg, GEN_INT (7)));\n \n   /* If the string pointer wasn't aligned we have loaded less then 16\n      bytes and the remaining bytes got filled with zeros (by vll).\n@@ -5853,7 +5853,7 @@ s390_expand_vec_movstr (rtx result, rtx dst, rtx src)\n   emit_insn (gen_vlbb (vsrc, src, GEN_INT (6)));\n   emit_insn (gen_lcbb (loadlen, src_addr, GEN_INT (6)));\n   emit_insn (gen_vfenezv16qi (vpos, vsrc, vsrc));\n-  emit_insn (gen_vec_extractv16qi (gpos_qi, vpos, GEN_INT (7)));\n+  emit_insn (gen_vec_extractv16qiqi (gpos_qi, vpos, GEN_INT (7)));\n   emit_move_insn (gpos, gen_rtx_SUBREG (SImode, gpos_qi, 0));\n   /* gpos is the byte index if a zero was found and 16 otherwise.\n      So if it is lower than the loaded bytes we have a hit.  */\n@@ -5931,7 +5931,7 @@ s390_expand_vec_movstr (rtx result, rtx dst, rtx src)\n   force_expand_binop (Pmode, add_optab, dst_addr_reg, offset, dst_addr_reg,\n \t\t      1, OPTAB_DIRECT);\n \n-  emit_insn (gen_vec_extractv16qi (gpos_qi, vpos, GEN_INT (7)));\n+  emit_insn (gen_vec_extractv16qiqi (gpos_qi, vpos, GEN_INT (7)));\n   emit_move_insn (gpos, gen_rtx_SUBREG (SImode, gpos_qi, 0));\n \n   emit_insn (gen_vstlv16qi (vsrc, gpos, gen_rtx_MEM (BLKmode, dst_addr_reg)));"}, {"sha": "3cf79896720cba6eba831cf961ca3564a2317ed1", "filename": "gcc/config/s390/vector.md", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fs390%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fs390%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fvector.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -90,6 +90,17 @@\n \t\t\t  (V1DF \"DF\") (V2DF \"DF\")\n \t\t\t  (V1TF \"TF\") (TF \"TF\")])\n \n+; Like above, but in lower case.\n+(define_mode_attr non_vec_l[(V1QI \"qi\") (V2QI \"qi\") (V4QI \"qi\") (V8QI \"qi\")\n+\t\t\t    (V16QI \"qi\")\n+\t\t\t    (V1HI \"hi\") (V2HI \"hi\") (V4HI \"hi\") (V8HI \"hi\")\n+\t\t\t    (V1SI \"si\") (V2SI \"si\") (V4SI \"si\")\n+\t\t\t    (V1DI \"di\") (V2DI \"di\")\n+\t\t\t    (V1TI \"ti\") (TI \"ti\")\n+\t\t\t    (V1SF \"sf\") (V2SF \"sf\") (V4SF \"sf\")\n+\t\t\t    (V1DF \"df\") (V2DF \"df\")\n+\t\t\t    (V1TF \"tf\") (TF \"tf\")])\n+\n ; The instruction suffix for integer instructions and instructions\n ; which do not care about whether it is floating point or integer.\n (define_mode_attr bhfgq[(V1QI \"b\") (V2QI \"b\") (V4QI \"b\") (V8QI \"b\") (V16QI \"b\")\n@@ -453,7 +464,7 @@\n ; FIXME: Support also vector mode operands for 0\n ; FIXME: This should be (vec_select ..) or something but it does only allow constant selectors :(\n ; This is used via RTL standard name as well as for expanding the builtin\n-(define_expand \"vec_extract<mode>\"\n+(define_expand \"vec_extract<mode><non_vec_l>\"\n   [(set (match_operand:<non_vec> 0 \"nonimmediate_operand\" \"\")\n \t(unspec:<non_vec> [(match_operand:V  1 \"register_operand\" \"\")\n \t\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"\")]\n@@ -485,7 +496,7 @@\n   \"vlgv<bhfgq>\\t%0,%v1,%Y3(%2)\"\n   [(set_attr \"op_type\" \"VRS\")])\n \n-(define_expand \"vec_init<mode>\"\n+(define_expand \"vec_init<mode><non_vec_l>\"\n   [(match_operand:V_128 0 \"register_operand\" \"\")\n    (match_operand:V_128 1 \"nonmemory_operand\" \"\")]\n   \"TARGET_VX\""}, {"sha": "925b49e03949692d81c0bc6546ba93d29ee2cd6c", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -8621,6 +8621,8 @@ visl\")\n (define_mode_attr vfptype [(V1SI \"single\") (V2HI \"single\") (V4QI \"single\")\n \t\t\t   (V1DI \"double\") (V2SI \"double\") (V4HI \"double\")\n \t\t\t   (V8QI \"double\")])\n+(define_mode_attr veltmode [(V1SI \"si\") (V2HI \"hi\") (V4QI \"qi\") (V1DI \"di\")\n+\t\t\t    (V2SI \"si\") (V4HI \"hi\") (V8QI \"qi\")])\n \n (define_expand \"mov<VMALL:mode>\"\n   [(set (match_operand:VMALL 0 \"nonimmediate_operand\" \"\")\n@@ -8762,7 +8764,7 @@ visl\")\n   DONE;\n })\n \n-(define_expand \"vec_init<VMALL:mode>\"\n+(define_expand \"vec_init<VMALL:mode><VMALL:veltmode>\"\n   [(match_operand:VMALL 0 \"register_operand\" \"\")\n    (match_operand:VMALL 1 \"\" \"\")]\n   \"TARGET_VIS\""}, {"sha": "ec20bd60e67787dd449a8548ec7f81ab250927ef", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -1773,7 +1773,7 @@ spu_expand_prologue (void)\n \t      size_v4si = scratch_v4si;\n \t    }\n \t  emit_insn (gen_cgt_v4si (scratch_v4si, sp_v4si, size_v4si));\n-\t  emit_insn (gen_vec_extractv4si\n+\t  emit_insn (gen_vec_extractv4sisi\n \t\t     (scratch_reg_0, scratch_v4si, GEN_INT (1)));\n \t  emit_insn (gen_spu_heq (scratch_reg_0, GEN_INT (0)));\n \t}\n@@ -5368,7 +5368,7 @@ spu_allocate_stack (rtx op0, rtx op1)\n     {\n       rtx avail = gen_reg_rtx(SImode);\n       rtx result = gen_reg_rtx(SImode);\n-      emit_insn (gen_vec_extractv4si (avail, sp, GEN_INT (1)));\n+      emit_insn (gen_vec_extractv4sisi (avail, sp, GEN_INT (1)));\n       emit_insn (gen_cgt_si(result, avail, GEN_INT (-1)));\n       emit_insn (gen_spu_heq (result, GEN_INT(0) ));\n     }\n@@ -5684,22 +5684,22 @@ spu_builtin_extract (rtx ops[])\n       switch (mode)\n \t{\n \tcase V16QImode:\n-\t  emit_insn (gen_vec_extractv16qi (ops[0], ops[1], ops[2]));\n+\t  emit_insn (gen_vec_extractv16qiqi (ops[0], ops[1], ops[2]));\n \t  break;\n \tcase V8HImode:\n-\t  emit_insn (gen_vec_extractv8hi (ops[0], ops[1], ops[2]));\n+\t  emit_insn (gen_vec_extractv8hihi (ops[0], ops[1], ops[2]));\n \t  break;\n \tcase V4SFmode:\n-\t  emit_insn (gen_vec_extractv4sf (ops[0], ops[1], ops[2]));\n+\t  emit_insn (gen_vec_extractv4sfsf (ops[0], ops[1], ops[2]));\n \t  break;\n \tcase V4SImode:\n-\t  emit_insn (gen_vec_extractv4si (ops[0], ops[1], ops[2]));\n+\t  emit_insn (gen_vec_extractv4sisi (ops[0], ops[1], ops[2]));\n \t  break;\n \tcase V2DImode:\n-\t  emit_insn (gen_vec_extractv2di (ops[0], ops[1], ops[2]));\n+\t  emit_insn (gen_vec_extractv2didi (ops[0], ops[1], ops[2]));\n \t  break;\n \tcase V2DFmode:\n-\t  emit_insn (gen_vec_extractv2df (ops[0], ops[1], ops[2]));\n+\t  emit_insn (gen_vec_extractv2dfdf (ops[0], ops[1], ops[2]));\n \t  break;\n \tdefault:\n \t  abort ();"}, {"sha": "fd6d253378bb10b8d9b62a513526d8a2ebe76b09", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -256,6 +256,13 @@\n \t\t\t  (V2DI  \"DI\")\n \t\t\t  (V4SF  \"SF\")\n \t\t\t  (V2DF  \"DF\")])\n+;; Like above, but in lower case\n+(define_mode_attr inner_l [(V16QI \"qi\")\n+\t\t\t   (V8HI  \"hi\")\n+\t\t\t   (V4SI  \"si\")\n+\t\t\t   (V2DI  \"di\")\n+\t\t\t   (V4SF  \"sf\")\n+\t\t\t   (V2DF  \"df\")])\n (define_mode_attr vmult  [(V16QI \"1\")\n \t\t\t  (V8HI  \"2\")\n \t\t\t  (V4SI  \"4\")\n@@ -4318,7 +4325,7 @@ selb\\t%0,%4,%0,%3\"\n ;; vector patterns\n \n ;; Vector initialization\n-(define_expand \"vec_init<mode>\"\n+(define_expand \"vec_init<mode><inner_l>\"\n   [(match_operand:V 0 \"register_operand\" \"\")\n    (match_operand 1 \"\" \"\")]\n   \"\"\n@@ -4347,7 +4354,7 @@ selb\\t%0,%4,%0,%3\"\n     operands[6] = GEN_INT (size);\n   })\n \n-(define_expand \"vec_extract<mode>\"\n+(define_expand \"vec_extract<mode><inner_l>\"\n   [(set (match_operand:<inner> 0 \"spu_reg_operand\" \"=r\")\n \t(vec_select:<inner> (match_operand:V 1 \"spu_reg_operand\" \"r\")\n \t\t\t    (parallel [(match_operand 2 \"const_int_operand\" \"i\")])))]"}, {"sha": "ea959208c98b3f3852600548f5fedc46a93e8bd3", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -4871,15 +4871,22 @@ This pattern is not allowed to @code{FAIL}.\n Set given field in the vector value.  Operand 0 is the vector to modify,\n operand 1 is new value of field and operand 2 specify the field index.\n \n-@cindex @code{vec_extract@var{m}} instruction pattern\n-@item @samp{vec_extract@var{m}}\n+@cindex @code{vec_extract@var{m}@var{n}} instruction pattern\n+@item @samp{vec_extract@var{m}@var{n}}\n Extract given field from the vector value.  Operand 1 is the vector, operand 2\n-specify field index and operand 0 place to store value into.\n-\n-@cindex @code{vec_init@var{m}} instruction pattern\n-@item @samp{vec_init@var{m}}\n+specify field index and operand 0 place to store value into.  The\n+@var{n} mode is the mode of the field or vector of fields that should be\n+extracted, should be either element mode of the vector mode @var{m}, or\n+a vector mode with the same element mode and smaller number of elements.\n+If @var{n} is a vector mode, the index is counted in units of that mode.\n+\n+@cindex @code{vec_init@var{m}@var{n}} instruction pattern\n+@item @samp{vec_init@var{m}@var{n}}\n Initialize the vector to given values.  Operand 0 is the vector to initialize\n-and operand 1 is parallel containing values for individual fields.\n+and operand 1 is parallel containing values for individual fields.  The\n+@var{n} mode is the mode of the elements, should be either element mode of\n+the vector mode @var{m}, or a vector mode with the same element mode and\n+smaller number of elements.\n \n @cindex @code{vec_cmp@var{m}@var{n}} instruction pattern\n @item @samp{vec_cmp@var{m}@var{n}}"}, {"sha": "8da98f5dc79bc79b2edf1c7fb986a5ea5a2718df", "filename": "gcc/expmed.c", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -1566,6 +1566,55 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       return op0;\n     }\n \n+  /* First try to check for vector from vector extractions.  */\n+  if (VECTOR_MODE_P (GET_MODE (op0))\n+      && !MEM_P (op0)\n+      && VECTOR_MODE_P (tmode)\n+      && GET_MODE_SIZE (GET_MODE (op0)) > GET_MODE_SIZE (tmode))\n+    {\n+      machine_mode new_mode = GET_MODE (op0);\n+      if (GET_MODE_INNER (new_mode) != GET_MODE_INNER (tmode))\n+\t{\n+\t  new_mode = mode_for_vector (GET_MODE_INNER (tmode),\n+\t\t\t\t      GET_MODE_BITSIZE (GET_MODE (op0))\n+\t\t\t\t      / GET_MODE_UNIT_BITSIZE (tmode));\n+\t  if (!VECTOR_MODE_P (new_mode)\n+\t      || GET_MODE_SIZE (new_mode) != GET_MODE_SIZE (GET_MODE (op0))\n+\t      || GET_MODE_INNER (new_mode) != GET_MODE_INNER (tmode)\n+\t      || !targetm.vector_mode_supported_p (new_mode))\n+\t    new_mode = VOIDmode;\n+\t}\n+      if (new_mode != VOIDmode\n+\t  && (convert_optab_handler (vec_extract_optab, new_mode, tmode)\n+\t      != CODE_FOR_nothing)\n+\t  && ((bitnum + bitsize - 1) / GET_MODE_BITSIZE (tmode)\n+\t      == bitnum / GET_MODE_BITSIZE (tmode)))\n+\t{\n+\t  struct expand_operand ops[3];\n+\t  machine_mode outermode = new_mode;\n+\t  machine_mode innermode = tmode;\n+\t  enum insn_code icode\n+\t    = convert_optab_handler (vec_extract_optab, outermode, innermode);\n+\t  unsigned HOST_WIDE_INT pos = bitnum / GET_MODE_BITSIZE (innermode);\n+\n+\t  if (new_mode != GET_MODE (op0))\n+\t    op0 = gen_lowpart (new_mode, op0);\n+\t  create_output_operand (&ops[0], target, innermode);\n+\t  ops[0].target = 1;\n+\t  create_input_operand (&ops[1], op0, outermode);\n+\t  create_integer_operand (&ops[2], pos);\n+\t  if (maybe_expand_insn (icode, 3, ops))\n+\t    {\n+\t      if (alt_rtl && ops[0].target)\n+\t\t*alt_rtl = target;\n+\t      target = ops[0].value;\n+\t      if (GET_MODE (target) != mode)\n+\t\treturn gen_lowpart (tmode, target);\n+\t      return target;\n+\t    }\n+\t}\n+    }\n+\n   /* See if we can get a better vector mode before extracting.  */\n   if (VECTOR_MODE_P (GET_MODE (op0))\n       && !MEM_P (op0)\n@@ -1599,14 +1648,17 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      available.  */\n   if (VECTOR_MODE_P (GET_MODE (op0))\n       && !MEM_P (op0)\n-      && optab_handler (vec_extract_optab, GET_MODE (op0)) != CODE_FOR_nothing\n+      && (convert_optab_handler (vec_extract_optab, GET_MODE (op0),\n+\t\t\t\t GET_MODE_INNER (GET_MODE (op0)))\n+\t  != CODE_FOR_nothing)\n       && ((bitnum + bitsize - 1) / GET_MODE_UNIT_BITSIZE (GET_MODE (op0))\n \t  == bitnum / GET_MODE_UNIT_BITSIZE (GET_MODE (op0))))\n     {\n       struct expand_operand ops[3];\n       machine_mode outermode = GET_MODE (op0);\n       machine_mode innermode = GET_MODE_INNER (outermode);\n-      enum insn_code icode = optab_handler (vec_extract_optab, outermode);\n+      enum insn_code icode\n+\t= convert_optab_handler (vec_extract_optab, outermode, innermode);\n       unsigned HOST_WIDE_INT pos = bitnum / GET_MODE_BITSIZE (innermode);\n \n       create_output_operand (&ops[0], target, innermode);"}, {"sha": "b194866313d9d1751cc4d085225f8800cf48b385", "filename": "gcc/expr.c", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -6589,34 +6589,38 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size,\n \trtvec vector = NULL;\n \tunsigned n_elts;\n \talias_set_type alias;\n+\tbool vec_vec_init_p = false;\n \n \tgcc_assert (eltmode != BLKmode);\n \n \tn_elts = TYPE_VECTOR_SUBPARTS (type);\n \tif (REG_P (target) && VECTOR_MODE_P (GET_MODE (target)))\n \t  {\n \t    machine_mode mode = GET_MODE (target);\n+\t    machine_mode emode = eltmode;\n \n-\t    icode = (int) optab_handler (vec_init_optab, mode);\n-\t    /* Don't use vec_init<mode> if some elements have VECTOR_TYPE.  */\n-\t    if (icode != CODE_FOR_nothing)\n+\t    if (CONSTRUCTOR_NELTS (exp)\n+\t\t&& (TREE_CODE (TREE_TYPE (CONSTRUCTOR_ELT (exp, 0)->value))\n+\t\t    == VECTOR_TYPE))\n \t      {\n-\t\ttree value;\n-\n-\t\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), idx, value)\n-\t\t  if (TREE_CODE (TREE_TYPE (value)) == VECTOR_TYPE)\n-\t\t    {\n-\t\t      icode = CODE_FOR_nothing;\n-\t\t      break;\n-\t\t    }\n+\t\ttree etype = TREE_TYPE (CONSTRUCTOR_ELT (exp, 0)->value);\n+\t\tgcc_assert (CONSTRUCTOR_NELTS (exp) * TYPE_VECTOR_SUBPARTS (etype)\n+\t\t\t    == n_elts);\n+\t\temode = TYPE_MODE (etype);\n \t      }\n+\t    icode = (int) convert_optab_handler (vec_init_optab, mode, emode);\n \t    if (icode != CODE_FOR_nothing)\n \t      {\n-\t\tunsigned int i;\n+\t\tunsigned int i, n = n_elts;\n \n-\t\tvector = rtvec_alloc (n_elts);\n-\t\tfor (i = 0; i < n_elts; i++)\n-\t\t  RTVEC_ELT (vector, i) = CONST0_RTX (GET_MODE_INNER (mode));\n+\t\tif (emode != eltmode)\n+\t\t  {\n+\t\t    n = CONSTRUCTOR_NELTS (exp);\n+\t\t    vec_vec_init_p = true;\n+\t\t  }\n+\t\tvector = rtvec_alloc (n);\n+\t\tfor (i = 0; i < n; i++)\n+\t\t  RTVEC_ELT (vector, i) = CONST0_RTX (emode);\n \t      }\n \t  }\n \n@@ -6634,10 +6638,10 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size,\n \n \t    FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), idx, value)\n \t      {\n-\t\tint n_elts_here = tree_to_uhwi\n-\t\t  (int_const_binop (TRUNC_DIV_EXPR,\n-\t\t\t\t    TYPE_SIZE (TREE_TYPE (value)),\n-\t\t\t\t    TYPE_SIZE (elttype)));\n+\t\ttree sz = TYPE_SIZE (TREE_TYPE (value));\n+\t\tint n_elts_here\n+\t\t  = tree_to_uhwi (int_const_binop (TRUNC_DIV_EXPR, sz,\n+\t\t\t\t\t\t   TYPE_SIZE (elttype)));\n \n \t\tcount += n_elts_here;\n \t\tif (mostly_zeros_p (value))\n@@ -6687,18 +6691,21 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size,\n \n \t    if (vector)\n \t      {\n-\t\t/* vec_init<mode> should not be used if there are VECTOR_TYPE\n-\t\t   elements.  */\n-\t\tgcc_assert (TREE_CODE (TREE_TYPE (value)) != VECTOR_TYPE);\n-\t\tRTVEC_ELT (vector, eltpos)\n-\t\t  = expand_normal (value);\n+\t\tif (vec_vec_init_p)\n+\t\t  {\n+\t\t    gcc_assert (ce->index == NULL_TREE);\n+\t\t    gcc_assert (TREE_CODE (TREE_TYPE (value)) == VECTOR_TYPE);\n+\t\t    eltpos = idx;\n+\t\t  }\n+\t\telse\n+\t\t  gcc_assert (TREE_CODE (TREE_TYPE (value)) != VECTOR_TYPE);\n+\t\tRTVEC_ELT (vector, eltpos) = expand_normal (value);\n \t      }\n \t    else\n \t      {\n-\t\tmachine_mode value_mode =\n-\t\t  TREE_CODE (TREE_TYPE (value)) == VECTOR_TYPE\n-\t\t  ? TYPE_MODE (TREE_TYPE (value))\n-\t\t  : eltmode;\n+\t\tmachine_mode value_mode\n+\t\t  = (TREE_CODE (TREE_TYPE (value)) == VECTOR_TYPE\n+\t\t     ? TYPE_MODE (TREE_TYPE (value)) : eltmode);\n \t\tbitpos = eltpos * elt_size;\n \t\tstore_constructor_field (target, bitsize, bitpos, 0,\n \t\t\t\t\t bitregion_end, value_mode,\n@@ -6707,9 +6714,9 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size,\n \t  }\n \n \tif (vector)\n-\t  emit_insn (GEN_FCN (icode)\n-\t\t     (target,\n-\t\t      gen_rtx_PARALLEL (GET_MODE (target), vector)));\n+\t  emit_insn (GEN_FCN (icode) (target,\n+\t\t\t\t      gen_rtx_PARALLEL (GET_MODE (target),\n+\t\t\t\t\t\t\tvector)));\n \tbreak;\n       }\n "}, {"sha": "a9900657a586ea23b8bee000fdf277639510ccc8", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -386,7 +386,8 @@ expand_vector_broadcast (machine_mode vmode, rtx op)\n   /* ??? If the target doesn't have a vec_init, then we have no easy way\n      of performing this operation.  Most of this sort of generic support\n      is hidden away in the vector lowering support in gimple.  */\n-  icode = optab_handler (vec_init_optab, vmode);\n+  icode = convert_optab_handler (vec_init_optab, vmode,\n+\t\t\t\t GET_MODE_INNER (vmode));\n   if (icode == CODE_FOR_nothing)\n     return NULL;\n "}, {"sha": "f21f2267ec2118d5cd0e74b18721525a564d16f2", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -89,6 +89,8 @@ OPTAB_CD(vec_cmpu_optab, \"vec_cmpu$a$b\")\n OPTAB_CD(vec_cmpeq_optab, \"vec_cmpeq$a$b\")\n OPTAB_CD(maskload_optab, \"maskload$a$b\")\n OPTAB_CD(maskstore_optab, \"maskstore$a$b\")\n+OPTAB_CD(vec_extract_optab, \"vec_extract$a$b\")\n+OPTAB_CD(vec_init_optab, \"vec_init$a$b\")\n \n OPTAB_NL(add_optab, \"add$P$a3\", PLUS, \"add\", '3', gen_int_fp_fixed_libfunc)\n OPTAB_NX(add_optab, \"add$F$a3\")\n@@ -294,8 +296,6 @@ OPTAB_D (udot_prod_optab, \"udot_prod$I$a\")\n OPTAB_D (usum_widen_optab, \"widen_usum$I$a3\")\n OPTAB_D (usad_optab, \"usad$I$a\")\n OPTAB_D (ssad_optab, \"ssad$I$a\")\n-OPTAB_D (vec_extract_optab, \"vec_extract$a\")\n-OPTAB_D (vec_init_optab, \"vec_init$a\")\n OPTAB_D (vec_pack_sfix_trunc_optab, \"vec_pack_sfix_trunc_$a\")\n OPTAB_D (vec_pack_ssat_optab, \"vec_pack_ssat_$a\")\n OPTAB_D (vec_pack_trunc_optab, \"vec_pack_trunc_$a\")"}, {"sha": "eecc1a43bb35f0fa6895a1c07c952c2f6dd53e27", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ff03930a11f3a996e512ed3613eedc1b50ac5b30/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=ff03930a11f3a996e512ed3613eedc1b50ac5b30", "patch": "@@ -6998,29 +6998,43 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t{\n \t  if (group_size < nunits)\n \t    {\n-\t      /* Avoid emitting a constructor of vector elements by performing\n-\t\t the loads using an integer type of the same size,\n-\t\t constructing a vector of those and then re-interpreting it\n-\t\t as the original vector type.  This works around the fact\n-\t\t that the vec_init optab was only designed for scalar\n-\t\t element modes and thus expansion goes through memory.\n-\t\t This avoids a huge runtime penalty due to the general\n-\t\t inability to perform store forwarding from smaller stores\n-\t\t to a larger load.  */\n-\t      unsigned lsize\n-\t\t= group_size * TYPE_PRECISION (TREE_TYPE (vectype));\n-\t      machine_mode elmode = mode_for_size (lsize, MODE_INT, 0);\n-\t      machine_mode vmode = mode_for_vector (elmode,\n-\t\t\t\t\t\t    nunits / group_size);\n-\t      /* If we can't construct such a vector fall back to\n-\t\t element loads of the original vector type.  */\n+\t      /* First check if vec_init optab supports construction from\n+\t\t vector elts directly.  */\n+\t      machine_mode elmode = TYPE_MODE (TREE_TYPE (vectype));\n+\t      machine_mode vmode = mode_for_vector (elmode, group_size);\n \t      if (VECTOR_MODE_P (vmode)\n-\t\t  && optab_handler (vec_init_optab, vmode) != CODE_FOR_nothing)\n+\t\t  && (convert_optab_handler (vec_init_optab,\n+\t\t\t\t\t     TYPE_MODE (vectype), vmode)\n+\t\t      != CODE_FOR_nothing))\n \t\t{\n \t\t  nloads = nunits / group_size;\n \t\t  lnel = group_size;\n-\t\t  ltype = build_nonstandard_integer_type (lsize, 1);\n-\t\t  lvectype = build_vector_type (ltype, nloads);\n+\t\t  ltype = build_vector_type (TREE_TYPE (vectype), group_size);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Otherwise avoid emitting a constructor of vector elements\n+\t\t     by performing the loads using an integer type of the same\n+\t\t     size, constructing a vector of those and then\n+\t\t     re-interpreting it as the original vector type.\n+\t\t     This avoids a huge runtime penalty due to the general\n+\t\t     inability to perform store forwarding from smaller stores\n+\t\t     to a larger load.  */\n+\t\t  unsigned lsize\n+\t\t    = group_size * TYPE_PRECISION (TREE_TYPE (vectype));\n+\t\t  elmode = mode_for_size (lsize, MODE_INT, 0);\n+\t\t  vmode = mode_for_vector (elmode, nunits / group_size);\n+\t\t  /* If we can't construct such a vector fall back to\n+\t\t     element loads of the original vector type.  */\n+\t\t  if (VECTOR_MODE_P (vmode)\n+\t\t      && (convert_optab_handler (vec_init_optab, vmode, elmode)\n+\t\t\t  != CODE_FOR_nothing))\n+\t\t    {\n+\t\t      nloads = nunits / group_size;\n+\t\t      lnel = group_size;\n+\t\t      ltype = build_nonstandard_integer_type (lsize, 1);\n+\t\t      lvectype = build_vector_type (ltype, nloads);\n+\t\t    }\n \t\t}\n \t    }\n \t  else"}]}