{"sha": "59116212bfc41f5e8f02d95de68628a67a044fe0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkxMTYyMTJiZmM0MWY1ZThmMDJkOTVkZTY4NjI4YTY3YTA0NGZlMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-16T12:25:28Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-16T12:25:28Z"}, "message": "(finish_enum): Handle VALUES being an ERROR_MARK.\n\nFrom-SVN: r7303", "tree": {"sha": "1e27e8a02b40020049ec82efda52445a5176e2ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e27e8a02b40020049ec82efda52445a5176e2ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59116212bfc41f5e8f02d95de68628a67a044fe0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59116212bfc41f5e8f02d95de68628a67a044fe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59116212bfc41f5e8f02d95de68628a67a044fe0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59116212bfc41f5e8f02d95de68628a67a044fe0/comments", "author": null, "committer": null, "parents": [{"sha": "005a35b93fd29f017e572355ec4ea8298259e968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/005a35b93fd29f017e572355ec4ea8298259e968", "html_url": "https://github.com/Rust-GCC/gccrs/commit/005a35b93fd29f017e572355ec4ea8298259e968"}], "stats": {"total": 62, "additions": 34, "deletions": 28}, "files": [{"sha": "bdbbb5fd4f54e7678b508bf54d8a4ac13faa5678", "filename": "gcc/c-decl.c", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59116212bfc41f5e8f02d95de68628a67a044fe0/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59116212bfc41f5e8f02d95de68628a67a044fe0/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=59116212bfc41f5e8f02d95de68628a67a044fe0", "patch": "@@ -5642,19 +5642,22 @@ finish_enum (enumtype, values)\n \n   /* Calculate the maximum value of any enumerator in this type.  */\n \n-  for (pair = values; pair; pair = TREE_CHAIN (pair))\n-    {\n-      tree value = TREE_VALUE (pair);\n-      if (pair == values)\n-\tminnode = maxnode = TREE_VALUE (pair);\n-      else\n-\t{\n-\t  if (tree_int_cst_lt (maxnode, value))\n-\t    maxnode = value;\n-\t  if (tree_int_cst_lt (value, minnode))\n-\t    minnode = value;\n-\t}\n-    }\n+  if (values == error_mark_node)\n+    minnode = maxnode = integer_zero_node;\n+  else\n+    for (pair = values; pair; pair = TREE_CHAIN (pair))\n+      {\n+\ttree value = TREE_VALUE (pair);\n+\tif (pair == values)\n+\t  minnode = maxnode = TREE_VALUE (pair);\n+\telse\n+\t  {\n+\t    if (tree_int_cst_lt (maxnode, value))\n+\t      maxnode = value;\n+\t    if (tree_int_cst_lt (value, minnode))\n+\t      minnode = value;\n+\t  }\n+      }\n \n   TYPE_MIN_VALUE (enumtype) = minnode;\n   TYPE_MAX_VALUE (enumtype) = maxnode;\n@@ -5700,24 +5703,27 @@ finish_enum (enumtype, values)\n   /* An enum can have some negative values; then it is signed.  */\n   TREE_UNSIGNED (enumtype) = tree_int_cst_sgn (minnode) >= 0;\n \n-  /* Change the type of the enumerators to be the enum type.\n-     Formerly this was done only for enums that fit in an int,\n-     but the comment said it was done only for enums wider than int.\n-     It seems necessary to do this for wide enums,\n-     and best not to change what's done for ordinary narrower ones.  */\n-  for (pair = values; pair; pair = TREE_CHAIN (pair))\n+  if (values != error_mark_node)\n     {\n-      TREE_TYPE (TREE_PURPOSE (pair)) = enumtype;\n-      DECL_SIZE (TREE_PURPOSE (pair)) = TYPE_SIZE (enumtype);\n-      if (TREE_CODE (TREE_PURPOSE (pair)) != FUNCTION_DECL)\n-\tDECL_ALIGN (TREE_PURPOSE (pair)) = TYPE_ALIGN (enumtype);\n-    }\n+      /* Change the type of the enumerators to be the enum type.\n+\t Formerly this was done only for enums that fit in an int,\n+\t but the comment said it was done only for enums wider than int.\n+\t It seems necessary to do this for wide enums,\n+\t and best not to change what's done for ordinary narrower ones.  */\n+      for (pair = values; pair; pair = TREE_CHAIN (pair))\n+\t{\n+\t  TREE_TYPE (TREE_PURPOSE (pair)) = enumtype;\n+\t  DECL_SIZE (TREE_PURPOSE (pair)) = TYPE_SIZE (enumtype);\n+\t  if (TREE_CODE (TREE_PURPOSE (pair)) != FUNCTION_DECL)\n+\t    DECL_ALIGN (TREE_PURPOSE (pair)) = TYPE_ALIGN (enumtype);\n+\t}\n \n-  /* Replace the decl nodes in VALUES with their names.  */\n-  for (pair = values; pair; pair = TREE_CHAIN (pair))\n-    TREE_PURPOSE (pair) = DECL_NAME (TREE_PURPOSE (pair));\n+      /* Replace the decl nodes in VALUES with their names.  */\n+      for (pair = values; pair; pair = TREE_CHAIN (pair))\n+\tTREE_PURPOSE (pair) = DECL_NAME (TREE_PURPOSE (pair));\n \n-  TYPE_VALUES (enumtype) = values;\n+      TYPE_VALUES (enumtype) = values;\n+    }\n \n   /* Fix up all variant types of this enum type.  */\n   for (tem = TYPE_MAIN_VARIANT (enumtype); tem; tem = TYPE_NEXT_VARIANT (tem))"}]}