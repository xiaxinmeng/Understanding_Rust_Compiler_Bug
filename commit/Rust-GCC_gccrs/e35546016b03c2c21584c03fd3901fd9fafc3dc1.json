{"sha": "e35546016b03c2c21584c03fd3901fd9fafc3dc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM1NTQ2MDE2YjAzYzJjMjE1ODRjMDNmZDM5MDFmZDlmYWZjM2RjMQ==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-08-07T04:26:26Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-08-07T04:26:26Z"}, "message": "decl.c (subst_pair): Declare.\n\n\t* gcc-interface/decl.c (subst_pair): Declare.  Declare a VEC of it.\n\t(build_subst_list): Return a VEC instead of a tree.\n\t(build_variant_list): Take a VEC for subst_list.  Adjust\n\taccordingly.\n\t(create_field_decl_from): Likewise.\n\t(create_variant_part_from): Likewise.\n\t(copy_and_substitute_in_size): Likewise.\n\t(gnat_to_gnu_entity): Adjust for new interface to build_subst_list.\n\tFree the built vector.\n\nFrom-SVN: r162975", "tree": {"sha": "1b47a8369c14e2c0389953c3492445a99eaaac14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b47a8369c14e2c0389953c3492445a99eaaac14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e35546016b03c2c21584c03fd3901fd9fafc3dc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e35546016b03c2c21584c03fd3901fd9fafc3dc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e35546016b03c2c21584c03fd3901fd9fafc3dc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e35546016b03c2c21584c03fd3901fd9fafc3dc1/comments", "author": null, "committer": null, "parents": [{"sha": "c93cc12322e612d85252acfed9190a58bf46ecbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c93cc12322e612d85252acfed9190a58bf46ecbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c93cc12322e612d85252acfed9190a58bf46ecbf"}], "stats": {"total": 110, "additions": 70, "deletions": 40}, "files": [{"sha": "30c75b915a5e625b7f5b44837f7d2235addf2f7f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e35546016b03c2c21584c03fd3901fd9fafc3dc1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e35546016b03c2c21584c03fd3901fd9fafc3dc1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e35546016b03c2c21584c03fd3901fd9fafc3dc1", "patch": "@@ -1,3 +1,15 @@\n+2010-08-07  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* gcc-interface/decl.c (subst_pair): Declare.  Declare a VEC of it.\n+\t(build_subst_list): Return a VEC instead of a tree.\n+\t(build_variant_list): Take a VEC for subst_list.  Adjust\n+\taccordingly.\n+\t(create_field_decl_from): Likewise.\n+\t(create_variant_part_from): Likewise.\n+\t(copy_and_substitute_in_size): Likewise.\n+\t(gnat_to_gnu_entity): Adjust for new interface to build_subst_list.\n+\tFree the built vector.\n+\n 2010-08-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Do not build an"}, {"sha": "a9e3358a47888d1fd6a10e0f0b39ca326512c5d1", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 58, "deletions": 40, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e35546016b03c2c21584c03fd3901fd9fafc3dc1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e35546016b03c2c21584c03fd3901fd9fafc3dc1/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=e35546016b03c2c21584c03fd3901fd9fafc3dc1", "patch": "@@ -104,6 +104,14 @@ static struct incomplete *defer_limited_with;\n static int defer_finalize_level = 0;\n static VEC (tree,heap) *defer_finalize_list;\n \n+typedef struct GTY(()) subst_pair_d {\n+  tree discriminant;\n+  tree replacement;\n+} subst_pair;\n+\n+DEF_VEC_O(subst_pair);\n+DEF_VEC_ALLOC_O(subst_pair,heap);\n+\n /* A hash table used to cache the result of annotate_value.  */\n static GTY ((if_marked (\"tree_int_map_marked_p\"),\n \t     param_is (struct tree_int_map))) htab_t annotate_value_cache;\n@@ -141,19 +149,21 @@ static void components_to_record (tree, Node_Id, tree, int, bool, tree *,\n static Uint annotate_value (tree);\n static void annotate_rep (Entity_Id, tree);\n static tree build_position_list (tree, bool, tree, tree, unsigned int, tree);\n-static tree build_subst_list (Entity_Id, Entity_Id, bool);\n-static tree build_variant_list (tree, tree, tree);\n+static VEC(subst_pair,heap) *build_subst_list (Entity_Id, Entity_Id, bool);\n+static tree build_variant_list (tree, VEC(subst_pair,heap) *, tree);\n static tree validate_size (Uint, tree, Entity_Id, enum tree_code, bool, bool);\n static void set_rm_size (Uint, tree, Entity_Id);\n static tree make_type_from_size (tree, tree, bool);\n static unsigned int validate_alignment (Uint, Entity_Id, unsigned int);\n static unsigned int ceil_alignment (unsigned HOST_WIDE_INT);\n static void check_ok_for_atomic (tree, Entity_Id, bool);\n-static tree create_field_decl_from (tree, tree, tree, tree, tree, tree);\n+static tree create_field_decl_from (tree, tree, tree, tree, tree,\n+\t\t\t\t    VEC(subst_pair,heap) *);\n static tree get_rep_part (tree);\n static tree get_variant_part (tree);\n-static tree create_variant_part_from (tree, tree, tree, tree, tree);\n-static void copy_and_substitute_in_size (tree, tree, tree);\n+static tree create_variant_part_from (tree, tree, tree, tree,\n+\t\t\t\t      VEC(subst_pair,heap) *);\n+static void copy_and_substitute_in_size (tree, tree, VEC(subst_pair,heap) *);\n static void rest_of_type_decl_compilation_no_defer (tree);\n \n /* The relevant constituents of a subprogram binding to a GCC builtin.  Used\n@@ -3032,7 +3042,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      && Present (Discriminant_Constraint (gnat_entity))\n \t      && Stored_Constraint (gnat_entity) != No_Elist)\n \t    {\n-\t      tree gnu_subst_list\n+\t      VEC(subst_pair,heap) *gnu_subst_list\n \t\t= build_subst_list (gnat_entity, gnat_base_type, definition);\n \t      tree gnu_unpad_base_type, gnu_rep_part, gnu_variant_part, t;\n \t      tree gnu_variant_list, gnu_pos_list, gnu_field_list = NULL_TREE;\n@@ -3309,6 +3319,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t gnat_entity);\n \t\t}\n \n+\t      VEC_free (subst_pair, heap, gnu_subst_list);\n+\n \t      /* Now we can finalize it.  */\n \t      rest_of_record_type_compilation (gnu_type);\n \t    }\n@@ -7500,17 +7512,16 @@ build_position_list (tree gnu_type, bool do_not_flatten_variant, tree gnu_pos,\n   return gnu_list;\n }\n \n-/* Return a TREE_LIST describing the substitutions needed to reflect the\n+/* Return a VEC describing the substitutions needed to reflect the\n    discriminant substitutions from GNAT_TYPE to GNAT_SUBTYPE.  They can\n-   be in any order.  TREE_PURPOSE gives the tree for the discriminant and\n-   TREE_VALUE is the replacement value.  They are in the form of operands\n-   to SUBSTITUTE_IN_EXPR.  DEFINITION is true if this is for a definition\n-   of GNAT_SUBTYPE.  */\n+   be in any order.  The values in an element of the VEC are in the form\n+   of operands to SUBSTITUTE_IN_EXPR.  DEFINITION is true if this is for\n+   a definition of GNAT_SUBTYPE.  */\n \n-static tree\n+static VEC(subst_pair,heap) *\n build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n {\n-  tree gnu_list = NULL_TREE;\n+  VEC(subst_pair,heap) *gnu_vec = NULL;\n   Entity_Id gnat_discrim;\n   Node_Id gnat_value;\n \n@@ -7523,16 +7534,17 @@ build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n     if (!Is_Access_Type (Etype (Node (gnat_value))))\n       {\n \ttree gnu_field = gnat_to_gnu_field_decl (gnat_discrim);\n-\tgnu_list = tree_cons (gnu_field,\n-\t\t\t      convert (TREE_TYPE (gnu_field),\n-\t\t\t\t       elaborate_expression\n-\t\t\t\t       (Node (gnat_value), gnat_subtype,\n-\t\t\t\t\tget_entity_name (gnat_discrim),\n-\t\t\t\t\tdefinition, true, false)),\n-\t\t\t      gnu_list);\n+\ttree replacement = convert (TREE_TYPE (gnu_field),\n+\t\t\t\t    elaborate_expression\n+\t\t\t\t    (Node (gnat_value), gnat_subtype,\n+\t\t\t\t     get_entity_name (gnat_discrim),\n+\t\t\t\t     definition, true, false));\n+\tsubst_pair *s = VEC_safe_push (subst_pair, heap, gnu_vec, NULL);\n+\ts->discriminant = gnu_field;\n+\ts->replacement = replacement;\n       }\n \n-  return gnu_list;\n+  return gnu_vec;\n }\n \n /* Scan all fields in QUAL_UNION_TYPE and return a TREE_LIST describing the\n@@ -7543,18 +7555,21 @@ build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n    list to be chained to the newly created entries.  */\n \n static tree\n-build_variant_list (tree qual_union_type, tree subst_list, tree gnu_list)\n+build_variant_list (tree qual_union_type, VEC(subst_pair,heap) *subst_list,\n+\t\t    tree gnu_list)\n {\n   tree gnu_field;\n \n   for (gnu_field = TYPE_FIELDS (qual_union_type);\n        gnu_field;\n        gnu_field = DECL_CHAIN (gnu_field))\n     {\n-      tree t, qual = DECL_QUALIFIER (gnu_field);\n+      tree qual = DECL_QUALIFIER (gnu_field);\n+      unsigned ix;\n+      subst_pair *s;\n \n-      for (t = subst_list; t; t = TREE_CHAIN (t))\n-\tqual = SUBSTITUTE_IN_EXPR (qual, TREE_PURPOSE (t), TREE_VALUE (t));\n+      FOR_EACH_VEC_ELT_REVERSE (subst_pair, subst_list, ix, s)\n+\tqual = SUBSTITUTE_IN_EXPR (qual, s->discriminant, s->replacement);\n \n       /* If the new qualifier is not unconditionally false, its variant may\n \t still be accessed.  */\n@@ -8217,16 +8232,19 @@ intrin_profiles_compatible_p (intrin_binding_t * inb)\n \n static tree\n create_field_decl_from (tree old_field, tree field_type, tree record_type,\n-\t\t\ttree size, tree pos_list, tree subst_list)\n+\t\t\ttree size, tree pos_list,\n+\t\t\tVEC(subst_pair,heap) *subst_list)\n {\n   tree t = TREE_VALUE (purpose_member (old_field, pos_list));\n   tree pos = TREE_VEC_ELT (t, 0), bitpos = TREE_VEC_ELT (t, 2);\n   unsigned int offset_align = tree_low_cst (TREE_VEC_ELT (t, 1), 1);\n   tree new_pos, new_field;\n+  unsigned ix;\n+  subst_pair *s;\n \n   if (CONTAINS_PLACEHOLDER_P (pos))\n-    for (t = subst_list; t; t = TREE_CHAIN (t))\n-      pos = SUBSTITUTE_IN_EXPR (pos, TREE_PURPOSE (t), TREE_VALUE (t));\n+    FOR_EACH_VEC_ELT_REVERSE (subst_pair, subst_list, ix, s)\n+      pos = SUBSTITUTE_IN_EXPR (pos, s->discriminant, s->replacement);\n \n   /* If the position is now a constant, we can set it as the position of the\n      field when we make it.  Otherwise, we need to deal with it specially.  */\n@@ -8302,7 +8320,8 @@ get_variant_part (tree record_type)\n \n static tree\n create_variant_part_from (tree old_variant_part, tree variant_list,\n-\t\t\t  tree record_type, tree pos_list, tree subst_list)\n+\t\t\t  tree record_type, tree pos_list,\n+\t\t\t  VEC(subst_pair,heap) *subst_list)\n {\n   tree offset = DECL_FIELD_OFFSET (old_variant_part);\n   tree old_union_type = TREE_TYPE (old_variant_part);\n@@ -8415,9 +8434,11 @@ create_variant_part_from (tree old_variant_part, tree variant_list,\n    in SUBST_LIST.  */\n \n static void\n-copy_and_substitute_in_size (tree new_type, tree old_type, tree subst_list)\n+copy_and_substitute_in_size (tree new_type, tree old_type,\n+\t\t\t     VEC(subst_pair,heap) *subst_list)\n {\n-  tree t;\n+  unsigned ix;\n+  subst_pair *s;\n \n   TYPE_SIZE (new_type) = TYPE_SIZE (old_type);\n   TYPE_SIZE_UNIT (new_type) = TYPE_SIZE_UNIT (old_type);\n@@ -8426,25 +8447,22 @@ copy_and_substitute_in_size (tree new_type, tree old_type, tree subst_list)\n   relate_alias_sets (new_type, old_type, ALIAS_SET_COPY);\n \n   if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (new_type)))\n-    for (t = subst_list; t; t = TREE_CHAIN (t))\n+    FOR_EACH_VEC_ELT_REVERSE (subst_pair, subst_list, ix, s)\n       TYPE_SIZE (new_type)\n \t= SUBSTITUTE_IN_EXPR (TYPE_SIZE (new_type),\n-\t\t\t      TREE_PURPOSE (t),\n-\t\t\t      TREE_VALUE (t));\n+\t\t\t      s->discriminant, s->replacement);\n \n   if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE_UNIT (new_type)))\n-    for (t = subst_list; t; t = TREE_CHAIN (t))\n+    FOR_EACH_VEC_ELT_REVERSE (subst_pair, subst_list, ix, s)\n       TYPE_SIZE_UNIT (new_type)\n \t= SUBSTITUTE_IN_EXPR (TYPE_SIZE_UNIT (new_type),\n-\t\t\t      TREE_PURPOSE (t),\n-\t\t\t      TREE_VALUE (t));\n+\t\t\t      s->discriminant, s->replacement);\n \n   if (CONTAINS_PLACEHOLDER_P (TYPE_ADA_SIZE (new_type)))\n-    for (t = subst_list; t; t = TREE_CHAIN (t))\n+    FOR_EACH_VEC_ELT_REVERSE (subst_pair, subst_list, ix, s)\n       SET_TYPE_ADA_SIZE\n \t(new_type, SUBSTITUTE_IN_EXPR (TYPE_ADA_SIZE (new_type),\n-\t\t\t\t       TREE_PURPOSE (t),\n-\t\t\t\t       TREE_VALUE (t)));\n+\t\t\t\t       s->discriminant, s->replacement));\n \n   /* Finalize the size.  */\n   TYPE_SIZE (new_type) = variable_size (TYPE_SIZE (new_type));"}]}