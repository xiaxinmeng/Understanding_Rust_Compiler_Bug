{"sha": "c1cfb2ae9ba507a30f76b6d73bede24446e4d876", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFjZmIyYWU5YmE1MDdhMzBmNzZiNmQ3M2JlZGUyNDQ0NmU0ZDg3Ng==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-31T21:12:24Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-31T21:12:24Z"}, "message": "(standard_68881_constant_p): Initialize REAL_VALUE_TYPE binary constants from decimal values.\n\n(standard_68881_constant_p): Initialize REAL_VALUE_TYPE\nbinary constants from decimal values.  Use REAL_VALUE_... macros.\n(standard_sun_fpa_constant_p): Likewise.\n(print_operand, floating_exact_log2): Use REAL_VALUE_... macros.\n(init_68881_table): New function.\n\nFrom-SVN: r3971", "tree": {"sha": "cf310bce6d70efc98640072089227c7281aa3793", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf310bce6d70efc98640072089227c7281aa3793"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1cfb2ae9ba507a30f76b6d73bede24446e4d876", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1cfb2ae9ba507a30f76b6d73bede24446e4d876", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1cfb2ae9ba507a30f76b6d73bede24446e4d876", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1cfb2ae9ba507a30f76b6d73bede24446e4d876/comments", "author": null, "committer": null, "parents": [{"sha": "896102d0c667780bf95d2766b22ac29c365fd323", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/896102d0c667780bf95d2766b22ac29c365fd323", "html_url": "https://github.com/Rust-GCC/gccrs/commit/896102d0c667780bf95d2766b22ac29c365fd323"}], "stats": {"total": 378, "additions": 231, "deletions": 147}, "files": [{"sha": "8939e98535bccf8b87ecc3ae5cca83d936e89470", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 231, "deletions": 147, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1cfb2ae9ba507a30f76b6d73bede24446e4d876/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1cfb2ae9ba507a30f76b6d73bede24446e4d876/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=c1cfb2ae9ba507a30f76b6d73bede24446e4d876", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Motorola 68000 family.\n-   Copyright (C) 1987 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1246,43 +1246,89 @@ output_move_const_single (operands)\n    The value, anded with 0xff, gives the code to use in fmovecr\n    to get the desired constant.  */\n \n-/* ??? This code should be fixed for cross-compilation. */\n+/* This code has been fixed for cross-compilation. */\n+  \n+static int inited_68881_table = 0;\n+\n+char *strings_68881[7] = {\n+  \"0.0\",\n+  \"1.0\",\n+  \"10.0\",\n+  \"100.0\",\n+  \"10000.0\",\n+  \"1e8\",\n+  \"1e16\"\n+  };\n+\n+int codes_68881[7] = {\n+  0x0f,\n+  0x32,\n+  0x33,\n+  0x34,\n+  0x35,\n+  0x36,\n+  0x37\n+  };\n+\n+REAL_VALUE_TYPE values_68881[7];\n+\n+/* Set up values_68881 array by converting the decimal values\n+   strings_68881 to binary.   */\n+\n+void\n+init_68881_table ()\n+{\n+  int i;\n+  REAL_VALUE_TYPE r;\n+  enum machine_mode mode;\n+\n+  mode = DFmode;\n+  for (i = 0; i < 7; i++)\n+    {\n+      if (i == 6)\n+        mode = SFmode;\n+      r = REAL_VALUE_ATOF (strings_68881[i], mode);\n+      values_68881[i] = r;\n+    }\n+  inited_68881_table = 1;\n+}\n \n int\n standard_68881_constant_p (x)\n      rtx x;\n {\n-  register double d;\n+  REAL_VALUE_TYPE r;\n+  int i;\n+  enum machine_mode mode;\n \n   /* fmovecr must be emulated on the 68040, so it shouldn't be used at all. */\n   if (TARGET_68040)\n     return 0;\n \n+#ifndef REAL_ARITHMETIC\n #if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n   if (! flag_pretend_float)\n     return 0;\n+#endif\n #endif\n \n-  REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n-\n-  if (d == 0)\n-    return 0x0f;\n-  /* Note: there are various other constants available\n-     but it is a nuisance to put in their values here.  */\n-  if (d == 1)\n-    return 0x32;\n-  if (d == 10)\n-    return 0x33;\n-  if (d == 100)\n-    return 0x34;\n-  if (d == 10000)\n-    return 0x35;\n-  if (d == 1e8)\n-    return 0x36;\n+  if (! inited_68881_table)\n+    init_68881_table ();\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\n+  for (i = 0; i < 6; i++)\n+    {\n+      if (REAL_VALUES_EQUAL (r, values_68881[i]))\n+        return (codes_68881[i]);\n+    }\n+  \n   if (GET_MODE (x) == SFmode)\n     return 0;\n-  if (d == 1e16)\n-    return 0x37;\n+\n+  if (REAL_VALUES_EQUAL (r, values_68881[6]))\n+    return (codes_68881[6]);\n+\n   /* larger powers of ten in the constants ram are not used\n      because they are not equal to a `double' C constant.  */\n   return 0;\n@@ -1295,25 +1341,29 @@ int\n floating_exact_log2 (x)\n      rtx x;\n {\n-  register double d, d1;\n+  REAL_VALUE_TYPE r, r1;\n   int i;\n \n+#ifndef REAL_ARITHMETIC\n #if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n   if (! flag_pretend_float)\n     return 0;\n+#endif\n #endif\n \n-  REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n \n-  if (! (d > 0))\n+  if (REAL_VALUES_LESS (r, dconst0))\n     return 0;\n \n-  for (d1 = 1.0, i = 0; d1 < d; d1 *= 2.0, i++)\n-    ;\n-\n-  if (d == d1)\n-    return i;\n-\n+  i = 0;\n+  while (REAL_VALUES_LESS (r1, r))\n+    {\n+      r1 = REAL_VALUE_LDEXP (dconst1, i);\n+      if (REAL_VALUES_EQUAL (r1, r))\n+        return i;\n+      i = i + 1;\n+    }\n   return 0;\n }\n \f\n@@ -1322,131 +1372,161 @@ floating_exact_log2 (x)\n    from the Sun FPA's constant RAM.\n    The value returned, anded with 0x1ff, gives the code to use in fpmove\n    to get the desired constant. */\n-#define S_E (2.718281745910644531)\n-#define D_E (2.718281828459045091)\n-#define S_PI (3.141592741012573242)\n-#define D_PI (3.141592653589793116)\n-#define S_SQRT2 (1.414213538169860840)\n-#define D_SQRT2 (1.414213562373095145)\n-#define S_LOG2ofE (1.442695021629333496)\n-#define D_LOG2ofE (1.442695040888963387)\n-#define S_LOG2of10 (3.321928024291992188)\n-#define D_LOG2of10 (3.321928024887362182)\n-#define S_LOGEof2 (0.6931471824645996094)\n-#define D_LOGEof2 (0.6931471805599452862)\n-#define S_LOGEof10 (2.302585124969482442)\n-#define D_LOGEof10 (2.302585092994045901)\n-#define S_LOG10of2 (0.3010300099849700928)\n-#define D_LOG10of2 (0.3010299956639811980)\n-#define S_LOG10ofE (0.4342944920063018799)\n-#define D_LOG10ofE (0.4342944819032518167)\n-\n-/* This code should be fixed for cross-compilation. */\n+\n+static int inited_FPA_table = 0;\n+\n+char *strings_FPA[38] = {\n+/* small rationals */\n+  \"0.0\",\n+  \"1.0\",\n+  \"0.5\",\n+  \"-1.0\",\n+  \"2.0\",\n+  \"3.0\",\n+  \"4.0\",\n+  \"8.0\",\n+  \"0.25\",\n+  \"0.125\",\n+  \"10.0\",\n+  \"-0.5\",\n+/* Decimal equivalents of double precision values */\n+  \"2.718281828459045091\", /* D_E */\n+  \"6.283185307179586477\", /* 2 pi */\n+  \"3.141592653589793116\", /* D_PI */\n+  \"1.570796326794896619\", /* pi/2 */\n+  \"1.414213562373095145\", /* D_SQRT2 */\n+  \"0.7071067811865475244\", /* 1/sqrt(2) */\n+  \"-1.570796326794896619\", /* -pi/2 */\n+  \"1.442695040888963387\", /* D_LOG2ofE */\n+  \"3.321928024887362182\", /* D_LOG2of10 */\n+  \"0.6931471805599452862\", /* D_LOGEof2 */\n+  \"2.302585092994045901\", /* D_LOGEof10 */\n+  \"0.3010299956639811980\", /* D_LOG10of2 */\n+  \"0.4342944819032518167\", /* D_LOG10ofE */\n+/* Decimal equivalents of single precision values */\n+  \"2.718281745910644531\", /* S_E */\n+  \"6.283185307179586477\", /* 2 pi */\n+  \"3.141592741012573242\", /* S_PI */\n+  \"1.570796326794896619\", /* pi/2 */\n+  \"1.414213538169860840\", /* S_SQRT2 */\n+  \"0.7071067811865475244\", /* 1/sqrt(2) */\n+  \"-1.570796326794896619\", /* -pi/2 */\n+  \"1.442695021629333496\", /* S_LOG2ofE */\n+  \"3.321928024291992188\", /* S_LOG2of10 */\n+  \"0.6931471824645996094\", /* S_LOGEof2 */\n+  \"2.302585124969482442\", /* S_LOGEof10 */\n+  \"0.3010300099849700928\", /* S_LOG10of2 */\n+  \"0.4342944920063018799\", /* S_LOG10ofE */\n+};\n+\n+\n+int codes_FPA[38] = {\n+/* small rationals */\n+  0x200,\n+  0xe,\n+  0xf,\n+  0x10,\n+  0x11,\n+  0xb1,\n+  0x12,\n+  0x13,\n+  0x15,\n+  0x16,\n+  0x17,\n+  0x2e,\n+/* double precision */\n+  0x8,\n+  0x9,\n+  0xa,\n+  0xb,\n+  0xc,\n+  0xd,\n+  0x27,\n+  0x28,\n+  0x29,\n+  0x2a,\n+  0x2b,\n+  0x2c,\n+  0x2d,\n+/* single precision */\n+  0x8,\n+  0x9,\n+  0xa,\n+  0xb,\n+  0xc,\n+  0xd,\n+  0x27,\n+  0x28,\n+  0x29,\n+  0x2a,\n+  0x2b,\n+  0x2c,\n+  0x2d\n+  };\n+\n+REAL_VALUE_TYPE values_FPA[38];\n+\n+/* This code has been fixed for cross-compilation. */\n+\n+void\n+init_FPA_table ()\n+{\n+  enum machine_mode mode;\n+  int i;\n+  REAL_VALUE_TYPE r;\n+\n+  mode = DFmode;\n+  for (i = 0; i < 38; i++)\n+    {\n+      if (i == 25)\n+        mode = SFmode;\n+      r = REAL_VALUE_ATOF (strings_FPA[i], mode);\n+      values_FPA[i] = r;\n+    }\n+  inited_FPA_table = 1;\n+}\n+\n \n int\n standard_sun_fpa_constant_p (x)\n      rtx x;\n {\n-  register double d;\n+  REAL_VALUE_TYPE r;\n+  int i;\n \n+#ifndef REAL_ARITHMETIC\n #if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n   if (! flag_pretend_float)\n     return 0;\n #endif\n+#endif\n+\n+  if (! inited_FPA_table)\n+    init_FPA_table ();\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n+\n+  for (i=0; i<12; i++)\n+    {\n+      if (REAL_VALUES_EQUAL (r, values_FPA[i]))\n+        return (codes_FPA[i]);\n+    }\n \n-  REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n-\n-  if (d == 0.0)\n-    return 0x200;\t\t/* 0 once 0x1ff is anded with it */\n-  if (d == 1.0)\n-    return 0xe;\n-  if (d == 0.5)\n-    return 0xf;\n-  if (d == -1.0)\n-    return 0x10;\n-  if (d == 2.0)\n-    return 0x11;\n-  if (d == 3.0)\n-    return 0xB1;\n-  if (d == 4.0)\n-    return 0x12;\n-  if (d == 8.0)\n-    return 0x13;\n-  if (d == 0.25)\n-    return 0x15;\n-  if (d == 0.125)\n-    return 0x16;\n-  if (d == 10.0)\n-    return 0x17;\n-  if (d == -(1.0/2.0))\n-    return 0x2E;\n-\n-/*\n- * Stuff that looks different if it's single or double\n- */\n   if (GET_MODE (x) == SFmode)\n     {\n-      if (d == S_E)\n-\treturn 0x8;\n-      if (d == (2*S_PI))\n-\treturn 0x9;\n-      if (d == S_PI)\n-\treturn 0xA;\n-      if (d == (S_PI / 2.0))\n-\treturn 0xB;\n-      if (d == S_SQRT2)\n-\treturn 0xC;\n-      if (d == (1.0 / S_SQRT2))\n-\treturn 0xD;\n-      /* Large powers of 10 in the constant \n-\t ram are not used because they are\n-\t not equal to a C double constant  */\n-      if (d == -(S_PI / 2.0))\n-\treturn 0x27;\n-      if (d == S_LOG2ofE)\n-\treturn 0x28;\n-      if (d == S_LOG2of10)\n-\treturn 0x29;\n-      if (d == S_LOGEof2)\n-\treturn 0x2A;\n-      if (d == S_LOGEof10)\n-\treturn 0x2B;\n-      if (d == S_LOG10of2)\n-\treturn 0x2C;\n-      if (d == S_LOG10ofE)\n-\treturn 0x2D;\n+      for (i=25; i<38; i++)\n+        {\n+          if (REAL_VALUES_EQUAL (r, values_FPA[i]))\n+            return (codes_FPA[i]);\n+        }\n     }\n   else\n     {\n-      if (d == D_E)\n-\treturn 0x8;\n-      if (d == (2*D_PI))\n-\treturn 0x9;\n-      if (d == D_PI)\n-\treturn 0xA;\n-      if (d == (D_PI / 2.0))\n-\treturn 0xB;\n-      if (d == D_SQRT2)\n-\treturn 0xC;\n-      if (d == (1.0 / D_SQRT2))\n-\treturn 0xD;\n-      /* Large powers of 10 in the constant \n-\t ram are not used because they are\n-\t not equal to a C double constant  */\n-      if (d == -(D_PI / 2.0))\n-\treturn 0x27;\n-      if (d == D_LOG2ofE)\n-\treturn 0x28;\n-      if (d == D_LOG2of10)\n-\treturn 0x29;\n-      if (d == D_LOGEof2)\n-\treturn 0x2A;\n-      if (d == D_LOGEof10)\n-\treturn 0x2B;\n-      if (d == D_LOG10of2)\n-\treturn 0x2C;\n-      if (d == D_LOG10ofE)\n-\treturn 0x2D;\n+      for (i=12; i<25; i++)\n+        {\n+          if (REAL_VALUES_EQUAL (r, values_FPA[i]))\n+            return (codes_FPA[i]);\n+        }\n     }\n   return 0x0;\n }\n@@ -1601,17 +1681,21 @@ print_operand (file, op, letter)\n #endif\n   else if (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == SFmode)\n     {\n-      double d;\n-      union { float f; int i; } u1;\n-      REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n-      u1.f = d;\n-      PRINT_OPERAND_PRINT_FLOAT (letter, file);\n+      REAL_VALUE_TYPE r;\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+      ASM_OUTPUT_FLOAT_OPERAND (letter, file, r);\n+    }\n+  else if (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == XFmode)\n+    {\n+      REAL_VALUE_TYPE r;\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+      ASM_OUTPUT_LONG_DOUBLE_OPERAND (file, r);\n     }\n   else if (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) != DImode)\n     {\n-      double d;\n-      REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n-      ASM_OUTPUT_DOUBLE_OPERAND (file, d);\n+      REAL_VALUE_TYPE r;\n+      REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n+      ASM_OUTPUT_DOUBLE_OPERAND (file, r);\n     }\n   else\n     {"}]}