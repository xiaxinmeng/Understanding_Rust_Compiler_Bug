{"sha": "19d181423f031bfff7a4bed1d4190fbd8d1bffd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTlkMTgxNDIzZjAzMWJmZmY3YTRiZWQxZDQxOTBmYmQ4ZDFiZmZkNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-14T10:49:30Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-14T10:49:30Z"}, "message": "(*REG_SET): Delete old implementation; use bitmap.h.\n\n(regset_{size,bytes}): Delete.\n(regs_live_at_setjmp): Declare.\n(EXECUTE_IF_SET_AND_RESET_IN_REG_SET): Delete.\n\nFrom-SVN: r14421", "tree": {"sha": "ac0599fa43220f7ce1da93ce0cbfbb708c5f750d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac0599fa43220f7ce1da93ce0cbfbb708c5f750d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19d181423f031bfff7a4bed1d4190fbd8d1bffd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d181423f031bfff7a4bed1d4190fbd8d1bffd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19d181423f031bfff7a4bed1d4190fbd8d1bffd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d181423f031bfff7a4bed1d4190fbd8d1bffd4/comments", "author": null, "committer": null, "parents": [{"sha": "096ab9eaaf2daba6c9cc0bc29565565560f11941", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/096ab9eaaf2daba6c9cc0bc29565565560f11941", "html_url": "https://github.com/Rust-GCC/gccrs/commit/096ab9eaaf2daba6c9cc0bc29565565560f11941"}], "stats": {"total": 253, "additions": 45, "deletions": 208}, "files": [{"sha": "4614b700380820d9037271a03be4b69043d84492", "filename": "gcc/basic-block.h", "status": "modified", "additions": 45, "deletions": 208, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d181423f031bfff7a4bed1d4190fbd8d1bffd4/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d181423f031bfff7a4bed1d4190fbd8d1bffd4/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=19d181423f031bfff7a4bed1d4190fbd8d1bffd4", "patch": "@@ -19,98 +19,38 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n-/* Number of bits in each actual element of a regset.  We get slightly\n-   better code for reg%bits and reg/bits if bits is unsigned, assuming\n-   it is a power of 2.  */\n-\n-#define REGSET_ELT_BITS ((unsigned) HOST_BITS_PER_WIDE_INT)\n-\n-/* Type to use for a regset element.  Note that lots of code assumes\n-   that the initial part of a regset that contains information on the\n-   hard registers is the same format as a HARD_REG_SET.  */\n-\n-#define REGSET_ELT_TYPE unsigned HOST_WIDE_INT\n-\n-/* Define the type for a pointer to a set with a bit for each\n-   (hard or pseudo) register.  */\n-\n-typedef REGSET_ELT_TYPE *regset;\n-\n-/* Size of a regset for the current function,\n-   in (1) bytes and (2) elements.  */\n-\n-extern int regset_bytes;\n-extern int regset_size;\n-\n-/* clear a register set */\n-#define CLEAR_REG_SET(TO)\t\t\t\t\t\t\\\n-do { register REGSET_ELT_TYPE *scan_tp_ = (TO);\t\t\t\t\\\n-     register int i_;\t\t\t\t\t\t\t\\\n-     for (i_ = 0; i_ < regset_size; i_++)\t\t\t\t\\\n-       *scan_tp_++ = 0; } while (0)\n-\n-/* copy a register to another register */\n-#define COPY_REG_SET(TO, FROM)\t\t\t\t\t\t\\\n-do { register REGSET_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n-     register int i_;\t\t\t\t\t\t\t\\\n-     for (i_ = 0; i_ < regset_size; i_++)\t\t\t\t\\\n-       *scan_tp_++ = *scan_fp_++; } while (0)\n-\n-/* complent a register set, storing it in a second register set.  */\n-#define COMPL_REG_SET(TO, FROM)\t\t\t\t\t\t\\\n-do { register REGSET_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n-     register int i_;\t\t\t\t\t\t\t\\\n-     for (i_ = 0; i_ < regset_size; i_++)\t\t\t\t\\\n-       *scan_tp_++ = ~ *scan_fp_++; } while (0)\n-\n-/* and a register set with a second register set.  */\n-#define AND_REG_SET(TO, FROM)\t\t\t\t\t\t\\\n-do { register REGSET_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n-     register int i_;\t\t\t\t\t\t\t\\\n-     for (i_ = 0; i_ < regset_size; i_++)\t\t\t\t\\\n-       *scan_tp_++ &= *scan_fp_++; } while (0)\n-\n-/* and the complement of a register set to a register set.  */\n-#define AND_COMPL_REG_SET(TO, FROM)\t\t\t\t\t\\\n-do { register REGSET_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n-     register int i_;\t\t\t\t\t\t\t\\\n-     for (i_ = 0; i_ < regset_size; i_++)\t\t\t\t\\\n-       *scan_tp_++ &= ~ *scan_fp_++; } while (0)\n-\n-/* inclusive or a register set with a second register set.  */\n-#define IOR_REG_SET(TO, FROM)\t\t\t\t\t\t\\\n-do { register REGSET_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n-     register int i_;\t\t\t\t\t\t\t\\\n-     for (i_ = 0; i_ < regset_size; i_++)\t\t\t\t\\\n-       *scan_tp_++ |= *scan_fp_++; } while (0)\n-\n-/* complement two register sets and or in the result into a third.  */\n-#define IOR_AND_COMPL_REG_SET(TO, FROM1, FROM2)\t\t\t\t\\\n-do { register REGSET_ELT_TYPE *scan_tp_ = (TO);\t\t\t\t\\\n-     register REGSET_ELT_TYPE *scan_fp1_ = (FROM1);\t\t\t\\\n-     register REGSET_ELT_TYPE *scan_fp2_ = (FROM2);\t\t\t\\\n-     register int i_;\t\t\t\t\t\t\t\\\n-     for (i_ = 0; i_ < regset_size; i_++)\t\t\t\t\\\n-       *scan_tp_++ |= *scan_fp1_++ & ~ *scan_fp2_++; } while (0)\n+#include \"bitmap.h\"\n+\n+typedef bitmap regset;\t\t/* Head of register set linked list.  */\n+\n+/* Clear a register set by freeing up the linked list.  */\n+#define CLEAR_REG_SET(HEAD) bitmap_clear (HEAD)\n+\n+/* Copy a register set to another register set.  */\n+#define COPY_REG_SET(TO, FROM) bitmap_copy (TO, FROM)\n+\n+/* `and' a register set with a second register set.  */\n+#define AND_REG_SET(TO, FROM) bitmap_operation (TO, TO, FROM, BITMAP_AND)\n+\n+/* `and' the complement of a register set with a register set.  */\n+#define AND_COMPL_REG_SET(TO, FROM) \\\n+  bitmap_operation (TO, TO, FROM, BITMAP_AND_COMPL)\n+\n+/* Inclusive or a register set with a second register set.  */\n+#define IOR_REG_SET(TO, FROM) bitmap_operation (TO, TO, FROM, BITMAP_IOR)\n+\n+/* Or into TO the register set FROM1 `and'ed with the complement of FROM2.  */\n+#define IOR_AND_COMPL_REG_SET(TO, FROM1, FROM2) \\\n+  bitmap_ior_and_compl (TO, FROM1, FROM2)\n \n /* Clear a single register in a register set.  */\n-#define CLEAR_REGNO_REG_SET(TO, REG)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  register REGSET_ELT_TYPE *tp_ = (TO);\t\t\t\t\t\\\n-  tp_[ (REG) / REGSET_ELT_BITS ]\t\t\t\t\t\\\n-    &= ~ ((REGSET_ELT_TYPE) 1 << ((REG) % REGSET_ELT_BITS)); } while (0);\n+#define CLEAR_REGNO_REG_SET(HEAD, REG) bitmap_clear_bit (HEAD, REG)\n \n /* Set a single register in a register set.  */\n-#define SET_REGNO_REG_SET(TO, REG)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  register REGSET_ELT_TYPE *tp_ = (TO);\t\t\t\t\t\\\n-  tp_[ (REG) / REGSET_ELT_BITS ]\t\t\t\t\t\\\n-    |= ((REGSET_ELT_TYPE) 1 << ((REG) % REGSET_ELT_BITS)); } while (0);\n+#define SET_REGNO_REG_SET(HEAD, REG) bitmap_set_bit (HEAD, REG)\n \n /* Return true if a register is set in a register set.  */\n-#define REGNO_REG_SET_P(TO, REG)\t\t\t\t\t\\\n- (((TO)[ (REG) / REGSET_ELT_BITS ]\t\t\t\t\t\\\n-   & (((REGSET_ELT_TYPE)1) << (REG) % REGSET_ELT_BITS)) != 0)\n+#define REGNO_REG_SET_P(TO, REG) bitmap_bit_p (TO, REG)\n \n /* Copy the hard registers in a register set to the hard register set.  */\n #define REG_SET_TO_HARD_REG_SET(TO, FROM)\t\t\t\t\\\n@@ -125,137 +65,30 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Loop over all registers in REGSET, starting with MIN, setting REGNUM to the\n    register number and executing CODE for all registers that are set. */\n #define EXECUTE_IF_SET_IN_REG_SET(REGSET, MIN, REGNUM, CODE)\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  register int i_ = (MIN) / REGSET_ELT_BITS;\t\t\t\t\\\n-  register int shift_ = (MIN) % REGSET_ELT_BITS;\t\t\t\\\n-  register REGSET_ELT_TYPE *scan_rs_ = (REGSET) + i_;\t\t\t\\\n-  for ( ; i_ < regset_size; i_++)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      REGSET_ELT_TYPE word_ = *scan_rs_++;\t\t\t\t\\\n-      if (word_)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  REGSET_ELT_TYPE j_;\t\t\t\t\t\t\\\n-\t  REGNUM = (i_ * REGSET_ELT_BITS) + shift_;\t\t\t\\\n-\t  for (j_ = ((REGSET_ELT_TYPE)1) << shift_;\t\t\t\\\n-\t       j_ != 0;\t\t\t\t\t\t\t\\\n-\t       (j_ <<= 1), REGNUM++)\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (word_ & j_)\t\t\t\t\t\t\\\n-\t\t{\t\t\t\t\t\t\t\\\n-\t\t  CODE;\t\t\t\t\t\t\t\\\n-\t\t  word_ &= ~ j_;\t\t\t\t\t\\\n-\t\t  if (!word_)\t\t\t\t\t\t\\\n-\t\t    break;\t\t\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      shift_ = 0;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* Like EXECUTE_IF_SET_IN_REG_SET, but also clear the register set.  */\n-#define EXECUTE_IF_SET_AND_RESET_IN_REG_SET(REGSET, MIN, REGNUM, CODE)\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  register int i_ = (MIN) / REGSET_ELT_BITS;\t\t\t\t\\\n-  register int shift_ = (MIN) % REGSET_ELT_BITS;\t\t\t\\\n-  register REGSET_ELT_TYPE *scan_rs_ = (REGSET) + i_;\t\t\t\\\n-  for ( ; i_ < regset_size; i_++)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      REGSET_ELT_TYPE word_ = *scan_rs_++;\t\t\t\t\\\n-      if (word_)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  REGSET_ELT_TYPE j_;\t\t\t\t\t\t\\\n-\t  REGNUM = (i_ * REGSET_ELT_BITS) + shift_;\t\t\t\\\n-\t  scan_rs_[-1] = 0;\t\t\t\t\t\t\\\n-\t  for (j_ = ((REGSET_ELT_TYPE)1) << shift_;\t\t\t\\\n-\t       j_ != 0;\t\t\t\t\t\t\t\\\n-\t       (j_ <<= 1), REGNUM++)\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (word_ & j_)\t\t\t\t\t\t\\\n-\t\t{\t\t\t\t\t\t\t\\\n-\t\t  CODE;\t\t\t\t\t\t\t\\\n-\t\t  word_ &= ~ j_;\t\t\t\t\t\\\n-\t\t  if (!word_)\t\t\t\t\t\t\\\n-\t\t    break;\t\t\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      shift_ = 0;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* Loop over all registers in REGSET1 and REGSET2, starting with MIN, setting\n-   REGNUM to the register number and executing CODE for all registers that are\n-   set in both regsets. */\n-#define EXECUTE_IF_AND_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, CODE)\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  register int i_ = (MIN) / REGSET_ELT_BITS;\t\t\t\t\\\n-  register int shift_ = (MIN) % REGSET_ELT_BITS;\t\t\t\\\n-  register REGSET_ELT_TYPE *scan_rs1_ = (REGSET1) + i_;\t\t\t\\\n-  register REGSET_ELT_TYPE *scan_rs2_ = (REGSET2) + i_;\t\t\t\\\n-  for ( ; i_ < regset_size; i_++)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      REGSET_ELT_TYPE word_ = *scan_rs1_++ & *scan_rs2_++;\t\t\\\n-      if (word_)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  REGSET_ELT_TYPE j_;\t\t\t\t\t\t\\\n-\t  REGNUM = (i_ * REGSET_ELT_BITS) + shift_;\t\t\t\\\n-\t  for (j_ = ((REGSET_ELT_TYPE)1) << shift_;\t\t\t\\\n-\t       j_ != 0;\t\t\t\t\t\t\t\\\n-\t       (j_ <<= 1), REGNUM++)\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (word_ & j_)\t\t\t\t\t\t\\\n-\t\t{\t\t\t\t\t\t\t\\\n-\t\t  CODE;\t\t\t\t\t\t\t\\\n-\t\t  word_ &= ~ j_;\t\t\t\t\t\\\n-\t\t  if (!word_)\t\t\t\t\t\t\\\n-\t\t    break;\t\t\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      shift_ = 0;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n+  EXECUTE_IF_SET_IN_BITMAP (REGSET, MIN, REGNUM, CODE)\n \n /* Loop over all registers in REGSET1 and REGSET2, starting with MIN, setting\n    REGNUM to the register number and executing CODE for all registers that are\n    set in the first regset and not set in the second. */\n #define EXECUTE_IF_AND_COMPL_IN_REG_SET(REGSET1, REGSET2, MIN, REGNUM, CODE) \\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  register int i_ = (MIN) / REGSET_ELT_BITS;\t\t\t\t\\\n-  register int shift_ = (MIN) % REGSET_ELT_BITS;\t\t\t\\\n-  register REGSET_ELT_TYPE *scan_rs1_ = (REGSET1) + i_;\t\t\t\\\n-  register REGSET_ELT_TYPE *scan_rs2_ = (REGSET2) + i_;\t\t\t\\\n-  for ( ; i_ < regset_size; i_++)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      REGSET_ELT_TYPE word_ = *scan_rs1_++ & ~ *scan_rs2_++;\t\t\\\n-      if (word_)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  REGSET_ELT_TYPE j_;\t\t\t\t\t\t\\\n-\t  REGNUM = (i_ * REGSET_ELT_BITS) + shift_;\t\t\t\\\n-\t  for (j_ = ((REGSET_ELT_TYPE)1) << shift_;\t\t\t\\\n-\t       j_ != 0;\t\t\t\t\t\t\t\\\n-\t       (j_ <<= 1), REGNUM++)\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (word_ & j_)\t\t\t\t\t\t\\\n-\t\t{\t\t\t\t\t\t\t\\\n-\t\t  CODE;\t\t\t\t\t\t\t\\\n-\t\t  word_ &= ~ j_;\t\t\t\t\t\\\n-\t\t  if (!word_)\t\t\t\t\t\t\\\n-\t\t    break;\t\t\t\t\t\t\\\n-\t\t}\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      shift_ = 0;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n+  EXECUTE_IF_AND_COMPL_IN_BITMAP (REGSET1, REGSET2, MIN, REGNUM, CODE)\n \n /* Allocate a register set with oballoc.  */\n-#define OBSTACK_ALLOC_REG_SET(OBSTACK)\t\t\t\t\t\\\n-  ((regset) obstack_alloc (OBSTACK, regset_bytes))\n+#define OBSTACK_ALLOC_REG_SET(OBSTACK) BITMAP_OBSTACK_ALLOC (OBSTACK)\n \n /* Allocate a register set with alloca.  */\n-#define ALLOCA_REG_SET() ((regset) alloca (regset_bytes))\n+#define ALLOCA_REG_SET() BITMAP_ALLOCA ()\n+\n+/* Do any cleanup needed on a regset when it is no longer used.  */\n+#define FREE_REG_SET(REGSET) BITMAP_FREE(REGSET)\n+\n+/* Do any one-time initializations needed for regsets.  */\n+#define INIT_ONCE_REG_SET() BITMAP_INIT_ONCE ()\n+\n+/* Grow any tables needed when the number of registers is calculated\n+   or extended.  For the linked list allocation, nothing needs to\n+   be done, other than zero the statistics on the first allocation.  */\n+#define MAX_REGNO_REG_SET(NUM_REGS, NEW_P, RENUMBER_P)\n \n /* Number of basic blocks in the current function.  */\n \n@@ -274,6 +107,10 @@ extern rtx *basic_block_end;\n \n extern regset *basic_block_live_at_start;\n \n+/* What registers are live at the setjmp call.  */\n+\n+extern regset regs_live_at_setjmp;\n+\n /* Indexed by n, gives number of basic block that  (REG n) is used in.\n    If the value is REG_BLOCK_GLOBAL (-2),\n    it means (REG n) is used in more than one basic block."}]}