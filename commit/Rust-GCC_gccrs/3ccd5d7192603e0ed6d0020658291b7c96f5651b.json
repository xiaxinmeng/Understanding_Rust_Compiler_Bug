{"sha": "3ccd5d7192603e0ed6d0020658291b7c96f5651b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NjZDVkNzE5MjYwM2UwZWQ2ZDAwMjA2NTgyOTFiN2M5NmY1NjUxYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-04-27T19:18:12Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-07-12T12:50:57Z"}, "message": "[Ada] Implement support for unconstrained array types with FLB\n\ngcc/ada/\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Use a\n\tfixed lower bound if the index subtype is marked so, as well as a\n\tmore efficient formula for the upper bound if the array cannot be\n\tsuperflat.\n\t(flb_cannot_be_superflat): New predicate.\n\t(cannot_be_superflat): Rename into...\n\t(range_cannot_be_superfla): ...this.  Minor tweak.", "tree": {"sha": "945900f3b7702592feb4506b949f29d720e4d483", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/945900f3b7702592feb4506b949f29d720e4d483"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ccd5d7192603e0ed6d0020658291b7c96f5651b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ccd5d7192603e0ed6d0020658291b7c96f5651b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ccd5d7192603e0ed6d0020658291b7c96f5651b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ccd5d7192603e0ed6d0020658291b7c96f5651b/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c8ff35eb982a49882ed71b1b85e8436675adf88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c8ff35eb982a49882ed71b1b85e8436675adf88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c8ff35eb982a49882ed71b1b85e8436675adf88"}], "stats": {"total": 112, "additions": 88, "deletions": 24}, "files": [{"sha": "8eb1e30d447bd0a15a9da189df9661740bb734e3", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 88, "deletions": 24, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ccd5d7192603e0ed6d0020658291b7c96f5651b/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ccd5d7192603e0ed6d0020658291b7c96f5651b/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=3ccd5d7192603e0ed6d0020658291b7c96f5651b", "patch": "@@ -217,7 +217,8 @@ static void set_reverse_storage_order_on_array_type (tree);\n static bool same_discriminant_p (Entity_Id, Entity_Id);\n static bool array_type_has_nonaliased_component (tree, Entity_Id);\n static bool compile_time_known_address_p (Node_Id);\n-static bool cannot_be_superflat (Node_Id);\n+static bool flb_cannot_be_superflat (Node_Id);\n+static bool range_cannot_be_superflat (Node_Id);\n static bool constructor_address_p (tree);\n static bool allocatable_size_p (tree, bool);\n static bool initial_value_needs_conversion (tree, tree);\n@@ -2238,13 +2239,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t     index += (convention_fortran_p ? - 1 : 1),\n \t     gnat_index = Next_Index (gnat_index))\n \t  {\n-\t    char field_name[16];\n+\t    const bool is_flb\n+\t      = Is_Fixed_Lower_Bound_Index_Subtype (Etype (gnat_index));\n \t    tree gnu_index_type = get_unpadded_type (Etype (gnat_index));\n \t    tree gnu_orig_min = TYPE_MIN_VALUE (gnu_index_type);\n \t    tree gnu_orig_max = TYPE_MAX_VALUE (gnu_index_type);\n \t    tree gnu_index_base_type = get_base_type (gnu_index_type);\n \t    tree gnu_lb_field, gnu_hb_field;\n \t    tree gnu_min, gnu_max, gnu_high;\n+\t    char field_name[16];\n \n \t    /* Update the maximum size of the array in elements.  */\n \t    if (gnu_max_size)\n@@ -2278,25 +2281,38 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n \t    /* We can't use build_component_ref here since the template type\n \t       isn't complete yet.  */\n-\t    gnu_orig_min = build3 (COMPONENT_REF, TREE_TYPE (gnu_lb_field),\n-\t\t\t\t   gnu_template_reference, gnu_lb_field,\n-\t\t\t\t   NULL_TREE);\n+\t    if (!is_flb)\n+\t      {\n+\t\tgnu_orig_min = build3 (COMPONENT_REF, TREE_TYPE (gnu_lb_field),\n+\t\t\t\t       gnu_template_reference, gnu_lb_field,\n+\t\t\t\t       NULL_TREE);\n+\t\tTREE_READONLY (gnu_orig_min) = 1;\n+\t      }\n+\n \t    gnu_orig_max = build3 (COMPONENT_REF, TREE_TYPE (gnu_hb_field),\n \t\t\t\t   gnu_template_reference, gnu_hb_field,\n \t\t\t\t   NULL_TREE);\n-\t    TREE_READONLY (gnu_orig_min) = TREE_READONLY (gnu_orig_max) = 1;\n+\t    TREE_READONLY (gnu_orig_max) = 1;\n \n \t    gnu_min = convert (sizetype, gnu_orig_min);\n \t    gnu_max = convert (sizetype, gnu_orig_max);\n \n \t    /* Compute the size of this dimension.  See the E_Array_Subtype\n \t       case below for the rationale.  */\n-\t    gnu_high\n-\t      = build3 (COND_EXPR, sizetype,\n-\t\t\tbuild2 (GE_EXPR, boolean_type_node,\n-\t\t\t\tgnu_orig_max, gnu_orig_min),\n-\t\t\tgnu_max,\n-\t\t\tsize_binop (MINUS_EXPR, gnu_min, size_one_node));\n+\t    if (is_flb\n+\t\t&& Nkind (gnat_index) == N_Subtype_Indication\n+\t        && flb_cannot_be_superflat (gnat_index))\n+\t      gnu_high = gnu_max;\n+\n+\t    else\n+\t      gnu_high\n+\t\t= build3 (COND_EXPR, sizetype,\n+\t\t\t  build2 (GE_EXPR, boolean_type_node,\n+\t\t\t\t  gnu_orig_max, gnu_orig_min),\n+\t\t\t  gnu_max,\n+\t\t\t  TREE_CODE (gnu_min) == INTEGER_CST\n+\t\t\t  ? int_const_binop (MINUS_EXPR, gnu_min, size_one_node)\n+\t\t\t  : size_binop (MINUS_EXPR, gnu_min, size_one_node));\n \n \t    /* Make a range type with the new range in the Ada base type.\n \t       Then make an index type with the size range in sizetype.  */\n@@ -2595,7 +2611,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t this.  If we can prove that the array can never be superflat,\n \t\t we can just use the high bound of the index type.  */\n \t      else if ((Nkind (gnat_index) == N_Range\n-\t\t        && cannot_be_superflat (gnat_index))\n+\t\t        && range_cannot_be_superflat (gnat_index))\n \t\t       /* Bit-Packed Array Impl. Types are never superflat.  */\n \t\t       || (Is_Packed_Array_Impl_Type (gnat_entity)\n \t\t\t   && Is_Bit_Packed_Array\n@@ -6414,33 +6430,81 @@ compile_time_known_address_p (Node_Id gnat_address)\n   return Compile_Time_Known_Value (gnat_address);\n }\n \n+/* Return true if GNAT_INDIC, a N_Subtype_Indication node for the index of a\n+   FLB, cannot yield superflat objects, i.e. if the inequality HB >= LB - 1\n+   is true for these objects.  LB and HB are the low and high bounds.  */\n+\n+static bool\n+flb_cannot_be_superflat (Node_Id gnat_indic)\n+{\n+  const Entity_Id gnat_type = Entity (Subtype_Mark (gnat_indic));\n+  const Entity_Id gnat_subtype = Etype (gnat_indic);\n+  Node_Id gnat_scalar_range, gnat_lb, gnat_hb;\n+  tree gnu_lb, gnu_hb, gnu_lb_minus_one;\n+\n+  /* This is a FLB so LB is fixed.  */\n+  if ((Ekind (gnat_subtype) == E_Signed_Integer_Subtype\n+       || Ekind (gnat_subtype) == E_Modular_Integer_Subtype)\n+      && (gnat_scalar_range = Scalar_Range (gnat_subtype)))\n+    {\n+      gnat_lb = Low_Bound (gnat_scalar_range);\n+      gcc_assert (Nkind (gnat_lb) == N_Integer_Literal);\n+    }\n+  else\n+    return false;\n+\n+  /* The low bound of the type is a lower bound for HB.  */\n+  if ((Ekind (gnat_type) == E_Signed_Integer_Subtype\n+       || Ekind (gnat_type) == E_Modular_Integer_Subtype)\n+      && (gnat_scalar_range = Scalar_Range (gnat_type)))\n+    {\n+      gnat_hb = Low_Bound (gnat_scalar_range);\n+      gcc_assert (Nkind (gnat_hb) == N_Integer_Literal);\n+    }\n+  else\n+    return false;\n+\n+  /* We need at least a signed 64-bit type to catch most cases.  */\n+  gnu_lb = UI_To_gnu (Intval (gnat_lb), sbitsizetype);\n+  gnu_hb = UI_To_gnu (Intval (gnat_hb), sbitsizetype);\n+  if (TREE_OVERFLOW (gnu_lb) || TREE_OVERFLOW (gnu_hb))\n+    return false;\n+\n+  /* If the low bound is the smallest integer, nothing can be smaller.  */\n+  gnu_lb_minus_one = size_binop (MINUS_EXPR, gnu_lb, sbitsize_one_node);\n+  if (TREE_OVERFLOW (gnu_lb_minus_one))\n+    return true;\n+\n+  return !tree_int_cst_lt (gnu_hb, gnu_lb_minus_one);\n+}\n+\n /* Return true if GNAT_RANGE, a N_Range node, cannot be superflat, i.e. if the\n-   inequality HB >= LB-1 is true.  LB and HB are the low and high bounds.  */\n+   inequality HB >= LB - 1 is true.  LB and HB are the low and high bounds.  */\n \n static bool\n-cannot_be_superflat (Node_Id gnat_range)\n+range_cannot_be_superflat (Node_Id gnat_range)\n {\n   Node_Id gnat_lb = Low_Bound (gnat_range), gnat_hb = High_Bound (gnat_range);\n-  Node_Id scalar_range;\n+  Node_Id gnat_scalar_range;\n   tree gnu_lb, gnu_hb, gnu_lb_minus_one;\n \n   /* If the low bound is not constant, try to find an upper bound.  */\n   while (Nkind (gnat_lb) != N_Integer_Literal\n \t && (Ekind (Etype (gnat_lb)) == E_Signed_Integer_Subtype\n \t     || Ekind (Etype (gnat_lb)) == E_Modular_Integer_Subtype)\n-\t && (scalar_range = Scalar_Range (Etype (gnat_lb)))\n-\t && (Nkind (scalar_range) == N_Signed_Integer_Type_Definition\n-\t     || Nkind (scalar_range) == N_Range))\n-    gnat_lb = High_Bound (scalar_range);\n+\t && (gnat_scalar_range = Scalar_Range (Etype (gnat_lb)))\n+\t && (Nkind (gnat_scalar_range) == N_Signed_Integer_Type_Definition\n+\t     || Nkind (gnat_scalar_range) == N_Range))\n+    gnat_lb = High_Bound (gnat_scalar_range);\n \n   /* If the high bound is not constant, try to find a lower bound.  */\n   while (Nkind (gnat_hb) != N_Integer_Literal\n \t && (Ekind (Etype (gnat_hb)) == E_Signed_Integer_Subtype\n \t     || Ekind (Etype (gnat_hb)) == E_Modular_Integer_Subtype)\n-\t && (scalar_range = Scalar_Range (Etype (gnat_hb)))\n-\t && (Nkind (scalar_range) == N_Signed_Integer_Type_Definition\n-\t     || Nkind (scalar_range) == N_Range))\n-    gnat_hb = Low_Bound (scalar_range);\n+\t && (gnat_scalar_range = Scalar_Range (Etype (gnat_hb)))\n+\t && (Nkind (gnat_scalar_range) == N_Signed_Integer_Type_Definition\n+\t     || Nkind (gnat_scalar_range) == N_Range))\n+    gnat_hb = Low_Bound (gnat_scalar_range);\n \n   /* If we have failed to find constant bounds, punt.  */\n   if (Nkind (gnat_lb) != N_Integer_Literal"}]}