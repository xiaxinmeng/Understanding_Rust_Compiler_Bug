{"sha": "1e2afadbc0827357daf6d6b7322a9250aad3f4ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUyYWZhZGJjMDgyNzM1N2RhZjZkNmI3MzIyYTkyNTBhYWQzZjRhYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-02-19T03:23:22Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-02-19T03:23:22Z"}, "message": "Fix struct with array of struct with field that points to first struct.\n\nDon't crash converting an untyped complex constant to an integer type.\nDon't crash on unsafe.Sizeof of erroneous type.\nDon't crash on method expression of erroneous type.\nDon't crash when sink and global var are initialized from type guard.\nDon't crash initializing erroneous slice.\nDon't crash on erroneous method of type seen before definition.\n\nFrom-SVN: r170301", "tree": {"sha": "3b70cef5fc6d58babeb9aa28c756473914d6bfe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b70cef5fc6d58babeb9aa28c756473914d6bfe2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e2afadbc0827357daf6d6b7322a9250aad3f4ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e2afadbc0827357daf6d6b7322a9250aad3f4ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e2afadbc0827357daf6d6b7322a9250aad3f4ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e2afadbc0827357daf6d6b7322a9250aad3f4ab/comments", "author": null, "committer": null, "parents": [{"sha": "f84ae14c4eeb561868722929e229213348d81dc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f84ae14c4eeb561868722929e229213348d81dc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f84ae14c4eeb561868722929e229213348d81dc9"}], "stats": {"total": 48, "additions": 39, "deletions": 9}, "files": [{"sha": "e1d59bef798bb132a5fb25a15a8e0111ab173be8", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2afadbc0827357daf6d6b7322a9250aad3f4ab/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2afadbc0827357daf6d6b7322a9250aad3f4ab/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=1e2afadbc0827357daf6d6b7322a9250aad3f4ab", "patch": "@@ -716,7 +716,11 @@ Expression::float_constant_tree(mpfr_t val, tree type)\n tree\n Expression::complex_constant_tree(mpfr_t real, mpfr_t imag, tree type)\n {\n-  if (TREE_CODE(type) == COMPLEX_TYPE)\n+  if (type == error_mark_node)\n+    return error_mark_node;\n+  else if (TREE_CODE(type) == INTEGER_TYPE || TREE_CODE(type) == REAL_TYPE)\n+    return Expression::float_constant_tree(real, type);\n+  else if (TREE_CODE(type) == COMPLEX_TYPE)\n     {\n       REAL_VALUE_TYPE r1;\n       real_from_mpfr(&r1, real, TREE_TYPE(type), GMP_RNDN);\n@@ -6960,6 +6964,8 @@ Builtin_call_expression::do_integer_constant_value(bool iota_is_constant,\n       if (arg_type->is_abstract())\n \treturn false;\n       tree arg_type_tree = arg_type->get_tree(this->gogo_);\n+      if (arg_type_tree == error_mark_node)\n+\treturn false;\n       unsigned long val_long;\n       if (this->code_ == BUILTIN_SIZEOF)\n \t{\n@@ -10325,7 +10331,11 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n   gcc_assert(vno != NULL);\n   Expression* ve = Expression::make_var_reference(vno, location);\n   Expression* bm = Type::bind_field_or_method(gogo, nt, ve, name, location);\n-  gcc_assert(bm != NULL && !bm->is_error_expression());\n+\n+  // Even though we found the method above, if it has an error type we\n+  // may see an error here.\n+  if (bm->is_error_expression())\n+    return bm;\n \n   Expression_list* args;\n   if (method_parameters == NULL)"}, {"sha": "fc8771c639cb22bb6acbfb9b636d166876cd8648", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2afadbc0827357daf6d6b7322a9250aad3f4ab/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2afadbc0827357daf6d6b7322a9250aad3f4ab/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=1e2afadbc0827357daf6d6b7322a9250aad3f4ab", "patch": "@@ -1865,6 +1865,8 @@ Named_object*\n Parse::create_dummy_global(Type* type, Expression* init,\n \t\t\t   source_location location)\n {\n+  if (type == NULL && init == NULL)\n+    type = Type::lookup_bool_type();\n   Variable* var = new Variable(type, init, true, false, false, location);\n   static int count;\n   char buf[30];"}, {"sha": "2d7312b60940ad7e87c0e1e94e95c1b08ec65055", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e2afadbc0827357daf6d6b7322a9250aad3f4ab/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e2afadbc0827357daf6d6b7322a9250aad3f4ab/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=1e2afadbc0827357daf6d6b7322a9250aad3f4ab", "patch": "@@ -4473,6 +4473,8 @@ Array_type::fill_in_tree(Gogo* gogo, tree struct_type)\n   gcc_assert(this->length_ == NULL);\n \n   tree element_type_tree = this->element_type_->get_tree(gogo);\n+  if (element_type_tree == error_mark_node)\n+    return error_mark_node;\n   tree field = TYPE_FIELDS(struct_type);\n   gcc_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n   gcc_assert(POINTER_TYPE_P(TREE_TYPE(field))\n@@ -6923,12 +6925,12 @@ Named_type::do_verify()\n     }\n \n   // If this is a struct, then if any of the fields of the struct\n-  // themselves have struct type, then this struct must be converted\n-  // to the backend representation before the field's type is\n-  // converted.  That may seem backward, but it works because if the\n-  // field's type refers to this one, e.g., via a pointer, then the\n-  // conversion process will pick up the half-built struct and do the\n-  // right thing.\n+  // themselves have struct type, or array of struct type, then this\n+  // struct must be converted to the backend representation before the\n+  // field's type is converted.  That may seem backward, but it works\n+  // because if the field's type refers to this one, e.g., via a\n+  // pointer, then the conversion process will pick up the half-built\n+  // struct and do the right thing.\n   if (this->struct_type() != NULL)\n     {\n       const Struct_field_list* fields = this->struct_type()->fields();\n@@ -6939,6 +6941,16 @@ Named_type::do_verify()\n \t  Struct_type* st = p->type()->struct_type();\n \t  if (st != NULL)\n \t    st->add_prerequisite(this);\n+\t  else\n+\t    {\n+\t      Array_type* at = p->type()->array_type();\n+\t      if (at != NULL && !at->is_open_array_type())\n+\t\t{\n+\t\t  st = at->element_type()->struct_type();\n+\t\t  if (st != NULL)\n+\t\t    st->add_prerequisite(this);\n+\t\t}\n+\t    }\n \t}\n     }\n \n@@ -7488,7 +7500,13 @@ Type::add_interface_methods_for_type(const Type* type,\n        ++pm)\n     {\n       Function_type* fntype = pm->type()->function_type();\n-      gcc_assert(fntype != NULL && !fntype->is_method());\n+      if (fntype == NULL)\n+\t{\n+\t  // This is an error, but it should be reported elsewhere\n+\t  // when we look at the methods for IT.\n+\t  continue;\n+\t}\n+      gcc_assert(!fntype->is_method());\n       fntype = fntype->copy_with_receiver(const_cast<Type*>(type));\n       Method* m = new Interface_method(pm->name(), pm->location(), fntype,\n \t\t\t\t       field_indexes, depth);"}]}