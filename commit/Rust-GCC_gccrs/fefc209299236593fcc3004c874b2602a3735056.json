{"sha": "fefc209299236593fcc3004c874b2602a3735056", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVmYzIwOTI5OTIzNjU5M2ZjYzMwMDRjODc0YjI2MDJhMzczNTA1Ng==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-09-22T15:29:02Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-09-23T01:17:56Z"}, "message": "analyzer: use switch in exploded_node::on_stmt\n\nThis patch replaces a sequence of dyn_cast to different gimple stmt\ntypes in exploded_node::on_stmt with a switch on the gimple_code.  This\nmakes clearer which kinds of stmt are currently treated as no-ops, as a\nprecursor to handling them properly.\n\nNo functional change intended.\n\ngcc/analyzer/ChangeLog:\n\t* engine.cc (exploded_node::on_stmt): Replace sequence of dyn_cast\n\twith switch.", "tree": {"sha": "ca0eff05d593af72951103566c15d33b8b2ae08d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca0eff05d593af72951103566c15d33b8b2ae08d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fefc209299236593fcc3004c874b2602a3735056", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fefc209299236593fcc3004c874b2602a3735056", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fefc209299236593fcc3004c874b2602a3735056", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fefc209299236593fcc3004c874b2602a3735056/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63cd53d2f5da07856340bbea11ee09ab1125e8c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63cd53d2f5da07856340bbea11ee09ab1125e8c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63cd53d2f5da07856340bbea11ee09ab1125e8c0"}], "stats": {"total": 134, "additions": 80, "deletions": 54}, "files": [{"sha": "437429798f24159fe629ada5068828aecee5a38c", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 80, "deletions": 54, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fefc209299236593fcc3004c874b2602a3735056/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fefc209299236593fcc3004c874b2602a3735056/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=fefc209299236593fcc3004c874b2602a3735056", "patch": "@@ -1063,62 +1063,88 @@ exploded_node::on_stmt (exploded_graph &eg,\n \t\t\t\t  &old_state, state,\n \t\t\t\t  stmt);\n \n-  if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n-    state->m_region_model->on_assignment (assign, &ctxt);\n-\n-  if (const greturn *return_ = dyn_cast <const greturn *> (stmt))\n-    state->m_region_model->on_return (return_, &ctxt);\n-\n-  /* Track whether we have a gcall to a function that's not recognized by\n-     anything, for which we don't have a function body, or for which we\n-     don't know the fndecl.  */\n   bool unknown_side_effects = false;\n-  if (const gcall *call = dyn_cast <const gcall *> (stmt))\n+\n+  switch (gimple_code (stmt))\n     {\n-      /* Debugging/test support.  */\n-      if (is_special_named_call_p (call, \"__analyzer_describe\", 2))\n-\tstate->m_region_model->impl_call_analyzer_describe (call, &ctxt);\n-      else if (is_special_named_call_p (call, \"__analyzer_dump\", 0))\n-\t{\n-\t  /* Handle the builtin \"__analyzer_dump\" by dumping state\n-\t     to stderr.  */\n-\t  state->dump (eg.get_ext_state (), true);\n-\t}\n-      else if (is_special_named_call_p (call, \"__analyzer_dump_path\", 0))\n-\t{\n-\t  /* Handle the builtin \"__analyzer_dump_path\" by queuing a\n-\t     diagnostic at this exploded_node.  */\n-\t  ctxt.warn (new dump_path_diagnostic ());\n-\t}\n-      else if (is_special_named_call_p (call, \"__analyzer_dump_region_model\", 0))\n-\t{\n-\t  /* Handle the builtin \"__analyzer_dump_region_model\" by dumping\n-\t     the region model's state to stderr.  */\n-\t  state->m_region_model->dump (false);\n-\t}\n-      else if (is_special_named_call_p (call, \"__analyzer_eval\", 1))\n-\tstate->m_region_model->impl_call_analyzer_eval (call, &ctxt);\n-      else if (is_special_named_call_p (call, \"__analyzer_break\", 0))\n-\t{\n-\t  /* Handle the builtin \"__analyzer_break\" by triggering a\n-\t     breakpoint.  */\n-\t  /* TODO: is there a good cross-platform way to do this?  */\n-\t  raise (SIGINT);\n-\t}\n-      else if (is_special_named_call_p (call, \"__analyzer_dump_exploded_nodes\",\n-\t\t\t\t\t1))\n-\t{\n-\t  /* This is handled elsewhere.  */\n-\t}\n-      else if (is_setjmp_call_p (call))\n-\tstate->m_region_model->on_setjmp (call, this, &ctxt);\n-      else if (is_longjmp_call_p (call))\n-\t{\n-\t  on_longjmp (eg, call, state, &ctxt);\n-\t  return on_stmt_flags::terminate_path ();\n-\t}\n-      else\n-\tunknown_side_effects = state->m_region_model->on_call_pre (call, &ctxt);\n+    default:\n+      /* No-op for now.  */\n+      break;\n+\n+    case GIMPLE_ASSIGN:\n+      {\n+\tconst gassign *assign = as_a <const gassign *> (stmt);\n+\tstate->m_region_model->on_assignment (assign, &ctxt);\n+      }\n+      break;\n+\n+    case GIMPLE_ASM:\n+      /* No-op for now.  */\n+      break;\n+\n+    case GIMPLE_CALL:\n+      {\n+\t/* Track whether we have a gcall to a function that's not recognized by\n+\t   anything, for which we don't have a function body, or for which we\n+\t   don't know the fndecl.  */\n+\tconst gcall *call = as_a <const gcall *> (stmt);\n+\n+\t/* Debugging/test support.  */\n+\tif (is_special_named_call_p (call, \"__analyzer_describe\", 2))\n+\t  state->m_region_model->impl_call_analyzer_describe (call, &ctxt);\n+\telse if (is_special_named_call_p (call, \"__analyzer_dump\", 0))\n+\t  {\n+\t    /* Handle the builtin \"__analyzer_dump\" by dumping state\n+\t       to stderr.  */\n+\t    state->dump (eg.get_ext_state (), true);\n+\t  }\n+\telse if (is_special_named_call_p (call, \"__analyzer_dump_path\", 0))\n+\t  {\n+\t    /* Handle the builtin \"__analyzer_dump_path\" by queuing a\n+\t       diagnostic at this exploded_node.  */\n+\t    ctxt.warn (new dump_path_diagnostic ());\n+\t  }\n+\telse if (is_special_named_call_p (call, \"__analyzer_dump_region_model\",\n+\t\t\t\t\t  0))\n+\t  {\n+\t    /* Handle the builtin \"__analyzer_dump_region_model\" by dumping\n+\t       the region model's state to stderr.  */\n+\t    state->m_region_model->dump (false);\n+\t  }\n+\telse if (is_special_named_call_p (call, \"__analyzer_eval\", 1))\n+\t  state->m_region_model->impl_call_analyzer_eval (call, &ctxt);\n+\telse if (is_special_named_call_p (call, \"__analyzer_break\", 0))\n+\t  {\n+\t    /* Handle the builtin \"__analyzer_break\" by triggering a\n+\t       breakpoint.  */\n+\t    /* TODO: is there a good cross-platform way to do this?  */\n+\t    raise (SIGINT);\n+\t  }\n+\telse if (is_special_named_call_p (call,\n+\t\t\t\t\t  \"__analyzer_dump_exploded_nodes\",\n+\t\t\t\t\t  1))\n+\t  {\n+\t    /* This is handled elsewhere.  */\n+\t  }\n+\telse if (is_setjmp_call_p (call))\n+\t  state->m_region_model->on_setjmp (call, this, &ctxt);\n+\telse if (is_longjmp_call_p (call))\n+\t  {\n+\t    on_longjmp (eg, call, state, &ctxt);\n+\t    return on_stmt_flags::terminate_path ();\n+\t  }\n+\telse\n+\t  unknown_side_effects\n+\t    = state->m_region_model->on_call_pre (call, &ctxt);\n+      }\n+      break;\n+\n+    case GIMPLE_RETURN:\n+      {\n+\tconst greturn *return_ = as_a <const greturn *> (stmt);\n+\tstate->m_region_model->on_return (return_, &ctxt);\n+      }\n+      break;\n     }\n \n   bool any_sm_changes = false;"}]}