{"sha": "5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU4ZjAxZjQzNGU1NDdkMjFlNmJlM2Y0NGIyZjVkOTA5MGZkYzlkYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-08-18T12:37:27Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-08-18T12:37:27Z"}, "message": "rtl.h (set_src_cost, [...]): New functions.\n\ngcc/\n\t* rtl.h (set_src_cost, get_full_set_src_cost): New functions.\n\t* auto-inc-dec.c (attempt_change): Use set_src_cost instead of\n\trtx_cost.\n\t* calls.c (precompute_register_parameters): Likewise.\n\t* combine.c (expand_compound_operation, make_extraction): Likewise.\n\t(force_to_mode, distribute_and_simplify_rtx): Likewise.\n\t* dse.c (find_shift_sequence): Likewise.\n\t* expmed.c (init_expmed, expand_mult, expand_smod_pow2): Likewise.\n\t* expr.c (compress_float_constant): Likewise.\n\t* fwprop.c (should_replace_address, try_fwprop_subst): Likewise.\n\t* gcse.c (want_to_gcse_p): Likewise.\n\t* ifcvt.c (noce_try_sign_mask): Likewise.\n\t* loop-doloop.c (doloop_optimize): Likewise.\n\t* loop-invariant.c (create_new_invariant): Likewise.\n\t* optabs.c (avoid_expensive_constant): Likewise.\n\t* postreload.c (reload_cse_simplify_set, reload_cse_simplify_operands)\n\t(try_replace_in_use, reload_cse_move2add): Likewise.\n\t* reload1.c (calculate_elim_costs_all_insns): Likewise.\n\t(note_reg_elim_costly): Likewise.\n\t* rtlanal.c (insn_rtx_cost): Likewise.\n\t* simplify-rtx.c (simplify_binary_operation_1): Likewise.\n\t* stmt.c (lshift_cheap_p): Likewise.\n\t* tree-ssa-loop-ivopts.c (seq_cost, computation_cost): Likewise.\n\t* config/avr/avr.c (final_prescan_insn): Likewise.\n\t* config/bfin/bfin.c (bfin_rtx_costs): Likewise.\n\t* config/mips/mips.c (mips_binary_cost, mips_rtx_costs): Likewise.\n\nFrom-SVN: r177851", "tree": {"sha": "be86e26d9b32f132c267f39e263298c225c62ae9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be86e26d9b32f132c267f39e263298c225c62ae9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/comments", "author": null, "committer": null, "parents": [{"sha": "d51102f3e780e69e19c6d7eeb987647e4a8aff15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d51102f3e780e69e19c6d7eeb987647e4a8aff15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d51102f3e780e69e19c6d7eeb987647e4a8aff15"}], "stats": {"total": 227, "additions": 141, "deletions": 86}, "files": [{"sha": "a0fdc127e91310bf92b75a3a9ab7d8772e7c1c22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -1,3 +1,32 @@\n+2011-08-18  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* rtl.h (set_src_cost, get_full_set_src_cost): New functions.\n+\t* auto-inc-dec.c (attempt_change): Use set_src_cost instead of\n+\trtx_cost.\n+\t* calls.c (precompute_register_parameters): Likewise.\n+\t* combine.c (expand_compound_operation, make_extraction): Likewise.\n+\t(force_to_mode, distribute_and_simplify_rtx): Likewise.\n+\t* dse.c (find_shift_sequence): Likewise.\n+\t* expmed.c (init_expmed, expand_mult, expand_smod_pow2): Likewise.\n+\t* expr.c (compress_float_constant): Likewise.\n+\t* fwprop.c (should_replace_address, try_fwprop_subst): Likewise.\n+\t* gcse.c (want_to_gcse_p): Likewise.\n+\t* ifcvt.c (noce_try_sign_mask): Likewise.\n+\t* loop-doloop.c (doloop_optimize): Likewise.\n+\t* loop-invariant.c (create_new_invariant): Likewise.\n+\t* optabs.c (avoid_expensive_constant): Likewise.\n+\t* postreload.c (reload_cse_simplify_set, reload_cse_simplify_operands)\n+\t(try_replace_in_use, reload_cse_move2add): Likewise.\n+\t* reload1.c (calculate_elim_costs_all_insns): Likewise.\n+\t(note_reg_elim_costly): Likewise.\n+\t* rtlanal.c (insn_rtx_cost): Likewise.\n+\t* simplify-rtx.c (simplify_binary_operation_1): Likewise.\n+\t* stmt.c (lshift_cheap_p): Likewise.\n+\t* tree-ssa-loop-ivopts.c (seq_cost, computation_cost): Likewise.\n+\t* config/avr/avr.c (final_prescan_insn): Likewise.\n+\t* config/bfin/bfin.c (bfin_rtx_costs): Likewise.\n+\t* config/mips/mips.c (mips_binary_cost, mips_rtx_costs): Likewise.\n+\n 2011-08-18  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* rtl.h (set_rtx_cost, get_full_set_rtx_cost): New functions."}, {"sha": "1c9edf859250b9813df8b984da4d423eb6fb2916", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -483,9 +483,9 @@ attempt_change (rtx new_addr, rtx inc_reg)\n   PUT_MODE (mem_tmp, mode);\n   XEXP (mem_tmp, 0) = new_addr;\n \n-  old_cost = (rtx_cost (mem, SET, speed)\n+  old_cost = (set_src_cost (mem, speed)\n \t      + set_rtx_cost (PATTERN (inc_insn.insn), speed));\n-  new_cost = rtx_cost (mem_tmp, SET, speed);\n+  new_cost = set_src_cost (mem_tmp, speed);\n \n   /* The first item of business is to see if this is profitable.  */\n   if (old_cost < new_cost)"}, {"sha": "a6e96e48575bff52192ab2e530d43940a0387cca", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -742,7 +742,7 @@ precompute_register_parameters (int num_actuals, struct arg_data *args,\n \t\t     || (GET_CODE (args[i].value) == SUBREG\n \t\t\t && REG_P (SUBREG_REG (args[i].value)))))\n \t\t && args[i].mode != BLKmode\n-\t\t && rtx_cost (args[i].value, SET, optimize_insn_for_speed_p ())\n+\t\t && set_src_cost (args[i].value, optimize_insn_for_speed_p ())\n \t\t    > COSTS_N_INSNS (1)\n \t\t && ((*reg_parm_seen\n \t\t      && targetm.small_register_classes_for_mode_p (args[i].mode))"}, {"sha": "f355f016dfd6ddea7a275fa1b3b060b48fc295d5", "filename": "gcc/combine.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -6827,11 +6827,11 @@ expand_compound_operation (rtx x)\n       rtx temp2 = expand_compound_operation (temp);\n \n       /* Make sure this is a profitable operation.  */\n-      if (rtx_cost (x, SET, optimize_this_for_speed_p)\n-          > rtx_cost (temp2, SET, optimize_this_for_speed_p))\n+      if (set_src_cost (x, optimize_this_for_speed_p)\n+          > set_src_cost (temp2, optimize_this_for_speed_p))\n        return temp2;\n-      else if (rtx_cost (x, SET, optimize_this_for_speed_p)\n-               > rtx_cost (temp, SET, optimize_this_for_speed_p))\n+      else if (set_src_cost (x, optimize_this_for_speed_p)\n+               > set_src_cost (temp, optimize_this_for_speed_p))\n        return temp;\n       else\n        return x;\n@@ -7253,8 +7253,8 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \n \t  /* Prefer ZERO_EXTENSION, since it gives more information to\n \t     backends.  */\n-\t  if (rtx_cost (temp, SET, optimize_this_for_speed_p)\n-\t      <= rtx_cost (temp1, SET, optimize_this_for_speed_p))\n+\t  if (set_src_cost (temp, optimize_this_for_speed_p)\n+\t      <= set_src_cost (temp1, optimize_this_for_speed_p))\n \t    return temp;\n \t  return temp1;\n \t}\n@@ -7455,8 +7455,8 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \n \t  /* Prefer ZERO_EXTENSION, since it gives more information to\n \t     backends.  */\n-\t  if (rtx_cost (temp1, SET, optimize_this_for_speed_p)\n-\t      < rtx_cost (temp, SET, optimize_this_for_speed_p))\n+\t  if (set_src_cost (temp1, optimize_this_for_speed_p)\n+\t      < set_src_cost (temp, optimize_this_for_speed_p))\n \t    temp = temp1;\n \t}\n       pos_rtx = temp;\n@@ -8223,8 +8223,8 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n \n \t      y = simplify_gen_binary (AND, GET_MODE (x),\n \t\t\t\t       XEXP (x, 0), GEN_INT (cval));\n-\t      if (rtx_cost (y, SET, optimize_this_for_speed_p)\n-\t          < rtx_cost (x, SET, optimize_this_for_speed_p))\n+\t      if (set_src_cost (y, optimize_this_for_speed_p)\n+\t          < set_src_cost (x, optimize_this_for_speed_p))\n \t\tx = y;\n \t    }\n \n@@ -9377,8 +9377,8 @@ distribute_and_simplify_rtx (rtx x, int n)\n   tmp = apply_distributive_law (simplify_gen_binary (inner_code, mode,\n \t\t\t\t\t\t     new_op0, new_op1));\n   if (GET_CODE (tmp) != outer_code\n-      && rtx_cost (tmp, SET, optimize_this_for_speed_p)\n-         < rtx_cost (x, SET, optimize_this_for_speed_p))\n+      && (set_src_cost (tmp, optimize_this_for_speed_p)\n+\t  < set_src_cost (x, optimize_this_for_speed_p)))\n     return tmp;\n \n   return NULL_RTX;"}, {"sha": "79cf0a5bffdc9401eab9fecb3dd00fd37e358724", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -1637,7 +1637,7 @@ final_prescan_insn (rtx insn, rtx *operand ATTRIBUTE_UNUSED,\n \n       if (set)\n         fprintf (asm_out_file, \"/* DEBUG: cost = %d.  */\\n\",\n-                 rtx_cost (SET_SRC (set), SET, optimize_insn_for_speed_p()));\n+                 set_src_cost (SET_SRC (set), optimize_insn_for_speed_p ()));\n       else\n         fprintf (asm_out_file, \"/* DEBUG: pattern-cost = %d.  */\\n\",\n                  rtx_cost (PATTERN (insn), INSN, optimize_insn_for_speed_p()));"}, {"sha": "8cd315d9e76492d597aa5584b21c4ef647b0d554", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -2837,11 +2837,11 @@ bfin_rtx_costs (rtx x, int code_i, int outer_code_i, int *total, bool speed)\n \t  *total = cost2;\n \t  if (GET_CODE (op0) != REG\n \t      && (GET_CODE (op0) != SUBREG || GET_CODE (SUBREG_REG (op0)) != REG))\n-\t    *total += rtx_cost (op0, SET, speed);\n+\t    *total += set_src_cost (op0, speed);\n #if 0 /* We'd like to do this for accuracy, but it biases the loop optimizer\n \t towards creating too many induction variables.  */\n \t  if (!reg_or_7bit_operand (op1, SImode))\n-\t    *total += rtx_cost (op1, SET, speed);\n+\t    *total += set_src_cost (op1, speed);\n #endif\n \t}\n       else if (GET_MODE (x) == DImode)"}, {"sha": "88988b66ca26214dda047109b2074d02320a2ddd", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -3333,7 +3333,7 @@ mips_binary_cost (rtx x, int single_cost, int double_cost, bool speed)\n   else\n     cost = single_cost;\n   return (cost\n-\t  + rtx_cost (XEXP (x, 0), SET, speed)\n+\t  + set_src_cost (XEXP (x, 0), speed)\n \t  + rtx_cost (XEXP (x, 1), GET_CODE (x), speed));\n }\n \n@@ -3550,7 +3550,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed)\n \t  && UINTVAL (XEXP (x, 1)) == 0xffffffff)\n \t{\n \t  *total = (mips_zero_extend_cost (mode, XEXP (x, 0))\n-\t\t    + rtx_cost (XEXP (x, 0), SET, speed));\n+\t\t    + set_src_cost (XEXP (x, 0), speed));\n \t  return true;\n \t}\n       /* Fall through.  */\n@@ -3585,7 +3585,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed)\n     case LO_SUM:\n       /* Low-part immediates need an extended MIPS16 instruction.  */\n       *total = (COSTS_N_INSNS (TARGET_MIPS16 ? 2 : 1)\n-\t\t+ rtx_cost (XEXP (x, 0), SET, speed));\n+\t\t+ set_src_cost (XEXP (x, 0), speed));\n       return true;\n \n     case LT:\n@@ -3626,17 +3626,17 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed)\n \t  if (GET_CODE (op0) == MULT && GET_CODE (XEXP (op0, 0)) == NEG)\n \t    {\n \t      *total = (mips_fp_mult_cost (mode)\n-\t\t\t+ rtx_cost (XEXP (XEXP (op0, 0), 0), SET, speed)\n-\t\t\t+ rtx_cost (XEXP (op0, 1), SET, speed)\n-\t\t\t+ rtx_cost (op1, SET, speed));\n+\t\t\t+ set_src_cost (XEXP (XEXP (op0, 0), 0), speed)\n+\t\t\t+ set_src_cost (XEXP (op0, 1), speed)\n+\t\t\t+ set_src_cost (op1, speed));\n \t      return true;\n \t    }\n \t  if (GET_CODE (op1) == MULT)\n \t    {\n \t      *total = (mips_fp_mult_cost (mode)\n-\t\t\t+ rtx_cost (op0, SET, speed)\n-\t\t\t+ rtx_cost (XEXP (op1, 0), SET, speed)\n-\t\t\t+ rtx_cost (XEXP (op1, 1), SET, speed));\n+\t\t\t+ set_src_cost (op0, speed)\n+\t\t\t+ set_src_cost (XEXP (op1, 0), speed)\n+\t\t\t+ set_src_cost (XEXP (op1, 1), speed));\n \t      return true;\n \t    }\n \t}\n@@ -3678,9 +3678,9 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed)\n \t      && GET_CODE (XEXP (op, 0)) == MULT)\n \t    {\n \t      *total = (mips_fp_mult_cost (mode)\n-\t\t\t+ rtx_cost (XEXP (XEXP (op, 0), 0), SET, speed)\n-\t\t\t+ rtx_cost (XEXP (XEXP (op, 0), 1), SET, speed)\n-\t\t\t+ rtx_cost (XEXP (op, 1), SET, speed));\n+\t\t\t+ set_src_cost (XEXP (XEXP (op, 0), 0), speed)\n+\t\t\t+ set_src_cost (XEXP (XEXP (op, 0), 1), speed)\n+\t\t\t+ set_src_cost (XEXP (op, 1), speed));\n \t      return true;\n \t    }\n \t}\n@@ -3718,10 +3718,10 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed)\n \t  if (outer_code == SQRT || GET_CODE (XEXP (x, 1)) == SQRT)\n \t    /* An rsqrt<mode>a or rsqrt<mode>b pattern.  Count the\n \t       division as being free.  */\n-\t    *total = rtx_cost (XEXP (x, 1), SET, speed);\n+\t    *total = set_src_cost (XEXP (x, 1), speed);\n \t  else\n \t    *total = (mips_fp_div_cost (mode)\n-\t\t      + rtx_cost (XEXP (x, 1), SET, speed));\n+\t\t      + set_src_cost (XEXP (x, 1), speed));\n \t  return true;\n \t}\n       /* Fall through.  */\n@@ -3749,7 +3749,7 @@ mips_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed)\n \t      && CONST_INT_P (XEXP (x, 1))\n \t      && exact_log2 (INTVAL (XEXP (x, 1))) >= 0)\n \t    {\n-\t      *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), SET, speed);\n+\t      *total = COSTS_N_INSNS (2) + set_src_cost (XEXP (x, 0), speed);\n \t      return true;\n \t    }\n \t  *total = COSTS_N_INSNS (mips_idiv_insns ());"}, {"sha": "ef1b50c53151dd4c69da20471b6404183315801a", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -1709,7 +1709,7 @@ find_shift_sequence (int access_size,\n \t\t  byte = subreg_lowpart_offset (read_mode, new_mode);\n \t\t  ret = simplify_subreg (read_mode, ret, new_mode, byte);\n \t\t  if (ret && CONSTANT_P (ret)\n-\t\t      && rtx_cost (ret, SET, speed) <= COSTS_N_INSNS (1))\n+\t\t      && set_src_cost (ret, speed) <= COSTS_N_INSNS (1))\n \t\t    return ret;\n \t\t}\n \t    }"}, {"sha": "f75ea7acd6178f0e54895436fcc96285a0fcea74", "filename": "gcc/expmed.c", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -196,7 +196,7 @@ init_expmed (void)\n   for (speed = 0; speed < 2; speed++)\n     {\n       crtl->maybe_hot_insn_p = speed;\n-      zero_cost[speed] = rtx_cost (const0_rtx, SET, speed);\n+      zero_cost[speed] = set_src_cost (const0_rtx, speed);\n \n       for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n \t   mode != VOIDmode;\n@@ -217,15 +217,15 @@ init_expmed (void)\n \t  PUT_MODE (&all.shift_sub0, mode);\n \t  PUT_MODE (&all.shift_sub1, mode);\n \n-\t  add_cost[speed][mode] = rtx_cost (&all.plus, SET, speed);\n-\t  neg_cost[speed][mode] = rtx_cost (&all.neg, SET, speed);\n-\t  mul_cost[speed][mode] = rtx_cost (&all.mult, SET, speed);\n-\t  sdiv_cost[speed][mode] = rtx_cost (&all.sdiv, SET, speed);\n-\t  udiv_cost[speed][mode] = rtx_cost (&all.udiv, SET, speed);\n+\t  add_cost[speed][mode] = set_src_cost (&all.plus, speed);\n+\t  neg_cost[speed][mode] = set_src_cost (&all.neg, speed);\n+\t  mul_cost[speed][mode] = set_src_cost (&all.mult, speed);\n+\t  sdiv_cost[speed][mode] = set_src_cost (&all.sdiv, speed);\n+\t  udiv_cost[speed][mode] = set_src_cost (&all.udiv, speed);\n \n-\t  sdiv_pow2_cheap[speed][mode] = (rtx_cost (&all.sdiv_32, SET, speed)\n+\t  sdiv_pow2_cheap[speed][mode] = (set_src_cost (&all.sdiv_32, speed)\n \t\t\t\t          <= 2 * add_cost[speed][mode]);\n-\t  smod_pow2_cheap[speed][mode] = (rtx_cost (&all.smod_32, SET, speed)\n+\t  smod_pow2_cheap[speed][mode] = (set_src_cost (&all.smod_32, speed)\n \t\t\t\t          <= 4 * add_cost[speed][mode]);\n \n \t  wider_mode = GET_MODE_WIDER_MODE (mode);\n@@ -237,9 +237,9 @@ init_expmed (void)\n \t      XEXP (&all.wide_lshr, 1) = GEN_INT (GET_MODE_BITSIZE (mode));\n \n \t      mul_widen_cost[speed][wider_mode]\n-\t        = rtx_cost (&all.wide_mult, SET, speed);\n+\t        = set_src_cost (&all.wide_mult, speed);\n \t      mul_highpart_cost[speed][mode]\n-\t        = rtx_cost (&all.wide_trunc, SET, speed);\n+\t        = set_src_cost (&all.wide_trunc, speed);\n \t    }\n \n \t  shift_cost[speed][mode][0] = 0;\n@@ -252,10 +252,13 @@ init_expmed (void)\n \t      XEXP (&all.shift, 1) = cint[m];\n \t      XEXP (&all.shift_mult, 1) = pow2[m];\n \n-\t      shift_cost[speed][mode][m] = rtx_cost (&all.shift, SET, speed);\n-\t      shiftadd_cost[speed][mode][m] = rtx_cost (&all.shift_add, SET, speed);\n-\t      shiftsub0_cost[speed][mode][m] = rtx_cost (&all.shift_sub0, SET, speed);\n-\t      shiftsub1_cost[speed][mode][m] = rtx_cost (&all.shift_sub1, SET, speed);\n+\t      shift_cost[speed][mode][m] = set_src_cost (&all.shift, speed);\n+\t      shiftadd_cost[speed][mode][m] = set_src_cost (&all.shift_add,\n+\t\t\t\t\t\t\t    speed);\n+\t      shiftsub0_cost[speed][mode][m] = set_src_cost (&all.shift_sub0,\n+\t\t\t\t\t\t\t     speed);\n+\t      shiftsub1_cost[speed][mode][m] = set_src_cost (&all.shift_sub1,\n+\t\t\t\t\t\t\t     speed);\n \t    }\n \t}\n     }\n@@ -3077,8 +3080,9 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \t\t result is interpreted as an unsigned coefficient.\n \t\t Exclude cost of op0 from max_cost to match the cost\n \t\t calculation of the synth_mult.  */\n-\t      max_cost = rtx_cost (gen_rtx_MULT (mode, fake_reg, op1), SET, speed)\n-\t\t\t - neg_cost[speed][mode];\n+\t      max_cost = (set_src_cost (gen_rtx_MULT (mode, fake_reg, op1),\n+\t\t\t\t\tspeed)\n+\t\t\t  - neg_cost[speed][mode]);\n \t      if (max_cost > 0\n \t\t  && choose_mult_variant (mode, -INTVAL (op1), &algorithm,\n \t\t\t\t\t  &variant, max_cost))\n@@ -3121,7 +3125,7 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n \n \t  /* Exclude cost of op0 from max_cost to match the cost\n \t     calculation of the synth_mult.  */\n-\t  max_cost = rtx_cost (gen_rtx_MULT (mode, fake_reg, op1), SET, speed);\n+\t  max_cost = set_src_cost (gen_rtx_MULT (mode, fake_reg, op1), speed);\n \t  if (choose_mult_variant (mode, coeff, &algorithm, &variant,\n \t\t\t\t   max_cost))\n \t    return expand_mult_const (mode, op0, coeff, target,\n@@ -3610,7 +3614,8 @@ expand_smod_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \n \t  temp = gen_rtx_LSHIFTRT (mode, result, shift);\n \t  if (optab_handler (lshr_optab, mode) == CODE_FOR_nothing\n-\t      || rtx_cost (temp, SET, optimize_insn_for_speed_p ()) > COSTS_N_INSNS (2))\n+\t      || (set_src_cost (temp, optimize_insn_for_speed_p ())\n+\t\t  > COSTS_N_INSNS (2)))\n \t    {\n \t      temp = expand_binop (mode, xor_optab, op0, signmask,\n \t\t\t\t   NULL_RTX, 1, OPTAB_LIB_WIDEN);"}, {"sha": "7257c8bde160689caadedaa986001359d6a3e874", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -3398,9 +3398,9 @@ compress_float_constant (rtx x, rtx y)\n   REAL_VALUE_FROM_CONST_DOUBLE (r, y);\n \n   if (targetm.legitimate_constant_p (dstmode, y))\n-    oldcost = rtx_cost (y, SET, speed);\n+    oldcost = set_src_cost (y, speed);\n   else\n-    oldcost = rtx_cost (force_const_mem (dstmode, y), SET, speed);\n+    oldcost = set_src_cost (force_const_mem (dstmode, y), speed);\n \n   for (srcmode = GET_CLASS_NARROWEST_MODE (GET_MODE_CLASS (orig_srcmode));\n        srcmode != orig_srcmode;\n@@ -3427,15 +3427,17 @@ compress_float_constant (rtx x, rtx y)\n \t  if (!insn_operand_matches (ic, 1, trunc_y))\n \t    continue;\n \t  /* This is valid, but may not be cheaper than the original. */\n-\t  newcost = rtx_cost (gen_rtx_FLOAT_EXTEND (dstmode, trunc_y), SET, speed);\n+\t  newcost = set_src_cost (gen_rtx_FLOAT_EXTEND (dstmode, trunc_y),\n+\t\t\t\t  speed);\n \t  if (oldcost < newcost)\n \t    continue;\n \t}\n       else if (float_extend_from_mem[dstmode][srcmode])\n \t{\n \t  trunc_y = force_const_mem (srcmode, trunc_y);\n \t  /* This is valid, but may not be cheaper than the original. */\n-\t  newcost = rtx_cost (gen_rtx_FLOAT_EXTEND (dstmode, trunc_y), SET, speed);\n+\t  newcost = set_src_cost (gen_rtx_FLOAT_EXTEND (dstmode, trunc_y),\n+\t\t\t\t  speed);\n \t  if (oldcost < newcost)\n \t    continue;\n \t  trunc_y = validize_mem (trunc_y);"}, {"sha": "236dda2dea5180886f26086bd6b25bc2421f0f5b", "filename": "gcc/fwprop.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -409,11 +409,11 @@ should_replace_address (rtx old_rtx, rtx new_rtx, enum machine_mode mode,\n \t  - address_cost (new_rtx, mode, as, speed));\n \n   /* If the addresses have equivalent cost, prefer the new address\n-     if it has the highest `rtx_cost'.  That has the potential of\n+     if it has the highest `set_src_cost'.  That has the potential of\n      eliminating the most insns without additional costs, and it\n      is the same that cse.c used to do.  */\n   if (gain == 0)\n-    gain = rtx_cost (new_rtx, SET, speed) - rtx_cost (old_rtx, SET, speed);\n+    gain = set_src_cost (new_rtx, speed) - set_src_cost (old_rtx, speed);\n \n   return (gain > 0);\n }\n@@ -963,7 +963,7 @@ try_fwprop_subst (df_ref use, rtx *loc, rtx new_rtx, rtx def_insn, bool set_reg_\n      multiple sets.  If so, assume the cost of the new instruction is\n      not greater than the old one.  */\n   if (set)\n-    old_cost = rtx_cost (SET_SRC (set), SET, speed);\n+    old_cost = set_src_cost (SET_SRC (set), speed);\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nIn insn %d, replacing\\n \", INSN_UID (insn));\n@@ -984,7 +984,7 @@ try_fwprop_subst (df_ref use, rtx *loc, rtx new_rtx, rtx def_insn, bool set_reg_\n \n   else if (DF_REF_TYPE (use) == DF_REF_REG_USE\n \t   && set\n-\t   && rtx_cost (SET_SRC (set), SET, speed) > old_cost)\n+\t   && set_src_cost (SET_SRC (set), speed) > old_cost)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Changes to insn %d not profitable\\n\","}, {"sha": "8adbc38bc0bffb1350f562217620e2e691dac8e3", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -732,7 +732,7 @@ want_to_gcse_p (rtx x, int *max_distance_ptr)\n   /* GCSE'ing constants:\n \n      We do not specifically distinguish between constant and non-constant\n-     expressions in PRE and Hoist.  We use rtx_cost below to limit\n+     expressions in PRE and Hoist.  We use set_src_cost below to limit\n      the maximum distance simple expressions can travel.\n \n      Nevertheless, constants are much easier to GCSE, and, hence,\n@@ -773,7 +773,7 @@ want_to_gcse_p (rtx x, int *max_distance_ptr)\n \n \t  gcc_assert (!optimize_function_for_speed_p (cfun)\n \t\t      && optimize_function_for_size_p (cfun));\n-\t  cost = rtx_cost (x, SET, 0);\n+\t  cost = set_src_cost (x, 0);\n \n \t  if (cost < COSTS_N_INSNS (GCSE_UNRESTRICTED_COST))\n \t    {"}, {"sha": "cf3d245e707467374f556def9d7b8a9dfb1696b7", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -2126,7 +2126,7 @@ noce_try_sign_mask (struct noce_if_info *if_info)\n      && (if_info->insn_b == NULL_RTX\n \t || BLOCK_FOR_INSN (if_info->insn_b) == if_info->test_bb));\n   if (!(t_unconditional\n-\t|| (rtx_cost (t, SET, optimize_bb_for_speed_p (if_info->test_bb))\n+\t|| (set_src_cost (t, optimize_bb_for_speed_p (if_info->test_bb))\n \t    < COSTS_N_INSNS (2))))\n     return FALSE;\n "}, {"sha": "a7e264f2c8d938531cf50814e3ede03272ce749c", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -655,7 +655,7 @@ doloop_optimize (struct loop *loop)\n \n   max_cost\n     = COSTS_N_INSNS (PARAM_VALUE (PARAM_MAX_ITERATIONS_COMPUTATION_COST));\n-  if (rtx_cost (desc->niter_expr, SET, optimize_loop_for_speed_p (loop))\n+  if (set_src_cost (desc->niter_expr, optimize_loop_for_speed_p (loop))\n       > max_cost)\n     {\n       if (dump_file)"}, {"sha": "b69254b2daa2e0571072a5b64296276af27c4826", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -719,7 +719,7 @@ create_new_invariant (struct def *def, rtx insn, bitmap depends_on,\n     }\n   else\n     {\n-      inv->cost = rtx_cost (SET_SRC (set), SET, speed);\n+      inv->cost = set_src_cost (SET_SRC (set), speed);\n       inv->cheap_address = false;\n     }\n "}, {"sha": "195853401e5099c3d4c6b21ee4ac2c624d7d8d70", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -1218,7 +1218,7 @@ avoid_expensive_constant (enum machine_mode mode, optab binoptab,\n   if (mode != VOIDmode\n       && optimize\n       && CONSTANT_P (x)\n-      && rtx_cost (x, binoptab->code, speed) > rtx_cost (x, SET, speed))\n+      && rtx_cost (x, binoptab->code, speed) > set_src_cost (x, speed))\n     {\n       if (CONST_INT_P (x))\n \t{"}, {"sha": "0e50d85a13c6a65409232356e6e910f6416d077c", "filename": "gcc/postreload.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -275,7 +275,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n     old_cost = register_move_cost (GET_MODE (src),\n \t\t\t\t   REGNO_REG_CLASS (REGNO (src)), dclass);\n   else\n-    old_cost = rtx_cost (src, SET, speed);\n+    old_cost = set_src_cost (src, speed);\n \n   for (l = val->locs; l; l = l->next)\n     {\n@@ -310,15 +310,15 @@ reload_cse_simplify_set (rtx set, rtx insn)\n \t      this_rtx = GEN_INT (this_val);\n \t    }\n #endif\n-\t  this_cost = rtx_cost (this_rtx, SET, speed);\n+\t  this_cost = set_src_cost (this_rtx, speed);\n \t}\n       else if (REG_P (this_rtx))\n \t{\n #ifdef LOAD_EXTEND_OP\n \t  if (extend_op != UNKNOWN)\n \t    {\n \t      this_rtx = gen_rtx_fmt_e (extend_op, word_mode, this_rtx);\n-\t      this_cost = rtx_cost (this_rtx, SET, speed);\n+\t      this_cost = set_src_cost (this_rtx, speed);\n \t    }\n \t  else\n #endif\n@@ -579,10 +579,12 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \t\t      && recog_data.alternative_enabled_p[j]\n \t\t      && reg_fits_class_p (testreg, rclass, 0, mode)\n \t\t      && (!CONST_INT_P (recog_data.operand[i])\n-\t\t\t  || (rtx_cost (recog_data.operand[i], SET,\n-\t\t\t  \t\toptimize_bb_for_speed_p (BLOCK_FOR_INSN (insn)))\n-\t\t\t      > rtx_cost (testreg, SET,\n-\t\t\t  \t\toptimize_bb_for_speed_p (BLOCK_FOR_INSN (insn))))))\n+\t\t\t  || (set_src_cost (recog_data.operand[i],\n+\t\t\t\t\t    optimize_bb_for_speed_p\n+\t\t\t\t\t     (BLOCK_FOR_INSN (insn)))\n+\t\t\t      > set_src_cost (testreg,\n+\t\t\t\t\t      optimize_bb_for_speed_p\n+\t\t\t\t\t       (BLOCK_FOR_INSN (insn))))))\n \t\t    {\n \t\t      alternative_nregs[j]++;\n \t\t      op_alt_regno[i][j] = regno;\n@@ -916,12 +918,12 @@ try_replace_in_use (struct reg_use *use, rtx reg, rtx src)\n \t  && CONSTANT_P (XEXP (SET_SRC (new_set), 1)))\n \t{\n \t  rtx new_src;\n-\t  int old_cost = rtx_cost (SET_SRC (new_set), SET, speed);\n+\t  int old_cost = set_src_cost (SET_SRC (new_set), speed);\n \n \t  gcc_assert (rtx_equal_p (XEXP (SET_SRC (new_set), 0), reg));\n \t  new_src = simplify_replace_rtx (SET_SRC (new_set), reg, src);\n \n-\t  if (rtx_cost (new_src, SET, speed) <= old_cost\n+\t  if (set_src_cost (new_src, speed) <= old_cost\n \t      && validate_change (use_insn, &SET_SRC (new_set),\n \t\t\t\t  new_src, 0))\n \t    return true;\n@@ -1936,7 +1938,7 @@ reload_cse_move2add (rtx first)\n \n \t\t\t  get_full_set_rtx_cost (set, &oldcst);\n \t\t\t  SET_SRC (set) = tem;\n-\t\t\t  get_full_rtx_cost (tem, SET, &newcst);\n+\t\t\t  get_full_set_src_cost (tem, &newcst);\n \t\t\t  SET_SRC (set) = old_src;\n \t\t\t  costs_add_n_insns (&oldcst, 1);\n "}, {"sha": "7e4e092d46943b7f8458f5e655318f4886826be7", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -1646,8 +1646,7 @@ calculate_elim_costs_all_insns (void)\n \t\t    {\n \t\t      rtx t = eliminate_regs_1 (SET_SRC (set), VOIDmode, insn,\n \t\t\t\t\t\tfalse, true);\n-\t\t      int cost = rtx_cost (t, SET,\n-\t\t\t\t\t   optimize_bb_for_speed_p (bb));\n+\t\t      int cost = set_src_cost (t, optimize_bb_for_speed_p (bb));\n \t\t      int freq = REG_FREQ_FROM_BB (bb);\n \n \t\t      reg_equiv_init_cost[regno] = cost * freq;\n@@ -2505,7 +2504,7 @@ note_reg_elim_costly (rtx *px, void *data)\n     {\n       rtx t = reg_equiv_invariant (REGNO (x));\n       rtx new_rtx = eliminate_regs_1 (t, Pmode, insn, true, true);\n-      int cost = rtx_cost (new_rtx, SET, optimize_bb_for_speed_p (elim_bb));\n+      int cost = set_src_cost (new_rtx, optimize_bb_for_speed_p (elim_bb));\n       int freq = REG_FREQ_FROM_BB (elim_bb);\n \n       if (cost != 0)"}, {"sha": "4f126865dea9cc97e69927cd8df1a3f1d2ddb587", "filename": "gcc/rtl.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -1234,6 +1234,24 @@ get_full_set_rtx_cost (rtx x, struct full_rtx_costs *c)\n {\n   get_full_rtx_cost (x, INSN, c);\n }\n+\n+/* Return the cost of moving X into a register, relative to the cost\n+   of a register move.  SPEED_P is true if optimizing for speed rather\n+   than size.  */\n+\n+static inline int\n+set_src_cost (rtx x, bool speed_p)\n+{\n+  return rtx_cost (x, SET, speed_p);\n+}\n+\n+/* Like set_src_cost, but return both the speed and size costs in C.  */\n+\n+static inline void\n+get_full_set_src_cost (rtx x, struct full_rtx_costs *c)\n+{\n+  get_full_rtx_cost (x, SET, c);\n+}\n #endif\n \n /* 1 if RTX is a subreg containing a reg that is already known to be"}, {"sha": "348371d2ddbbd055b1f633b2d5124b5fc8df712e", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -4782,7 +4782,7 @@ insn_rtx_cost (rtx pat, bool speed)\n   else\n     return 0;\n \n-  cost = rtx_cost (SET_SRC (set), SET, speed);\n+  cost = set_src_cost (SET_SRC (set), speed);\n   return cost > 0 ? cost : COSTS_N_INSNS (1);\n }\n "}, {"sha": "eb328e521d4b23ea0f0a966fdd89ddf85610441d", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -2033,7 +2033,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t      coeff = immed_double_int_const (val, mode);\n \n \t      tem = simplify_gen_binary (MULT, mode, lhs, coeff);\n-\t      return rtx_cost (tem, SET, speed) <= rtx_cost (orig, SET, speed)\n+\t      return set_src_cost (tem, speed) <= set_src_cost (orig, speed)\n \t\t? tem : 0;\n \t    }\n \t}\n@@ -2214,7 +2214,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \t      coeff = immed_double_int_const (val, mode);\n \n \t      tem = simplify_gen_binary (MULT, mode, lhs, coeff);\n-\t      return rtx_cost (tem, SET, speed) <= rtx_cost (orig, SET, speed)\n+\t      return set_src_cost (tem, speed) <= set_src_cost (orig, speed)\n \t\t? tem : 0;\n \t    }\n \t}"}, {"sha": "06d607620112e2ad2e7605066d1f16a77fa6909d", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -2134,8 +2134,8 @@ bool lshift_cheap_p (void)\n   if (!init[speed_p])\n     {\n       rtx reg = gen_rtx_REG (word_mode, 10000);\n-      int cost = rtx_cost (gen_rtx_ASHIFT (word_mode, const1_rtx, reg), SET,\n-      \t\t\t   speed_p);\n+      int cost = set_src_cost (gen_rtx_ASHIFT (word_mode, const1_rtx, reg),\n+\t\t\t       speed_p);\n       cheap[speed_p] = cost < COSTS_N_INSNS (3);\n       init[speed_p] = true;\n     }"}, {"sha": "c9398270d28b9c3797b9b696f87a86056cc1e94d", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e8f01f434e547d21e6be3f44b2f5d9090fdc9db/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=5e8f01f434e547d21e6be3f44b2f5d9090fdc9db", "patch": "@@ -2754,7 +2754,7 @@ seq_cost (rtx seq, bool speed)\n     {\n       set = single_set (seq);\n       if (set)\n-\tcost += rtx_cost (SET_SRC (set), SET, speed);\n+\tcost += set_src_cost (SET_SRC (set), speed);\n       else\n \tcost++;\n     }\n@@ -2876,7 +2876,7 @@ computation_cost (tree expr, bool speed)\n     cost += address_cost (XEXP (rslt, 0), TYPE_MODE (type),\n \t\t\t  TYPE_ADDR_SPACE (type), speed);\n   else if (!REG_P (rslt))\n-    cost += rtx_cost (rslt, SET, speed);\n+    cost += set_src_cost (rslt, speed);\n \n   return cost;\n }"}]}