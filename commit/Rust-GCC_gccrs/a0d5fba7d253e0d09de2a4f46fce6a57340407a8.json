{"sha": "a0d5fba7d253e0d09de2a4f46fce6a57340407a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBkNWZiYTdkMjUzZTBkMDlkZTJhNGY0NmZjZTZhNTczNDA0MDdhOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-01-12T09:44:59Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-01-12T09:44:59Z"}, "message": "init.c (build_new_1): Split out from build_new.\n\n\t* init.c (build_new_1): Split out from build_new.\n\t(build_new): Just return a NEW_EXPR.\n\t* expr.c (cplus_expand_expr): Handle NEW_EXPR.\n\t* decl2.c (get_temp_regvar): Tweak.\n\t* cp-tree.h (TREE_CALLS_NEW): Comment out.\n\t* class.c (resolves_to_fixed_type_p): Remove use.\n\t* method.c (build_opfncall): Likewise.\n\t* call.c (build_new_op): Likewise.\nFix problem with 'new' in default argument.\n\nFrom-SVN: r17319", "tree": {"sha": "3f2aab433a227917dcd627e3bd67f21d6f2276d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f2aab433a227917dcd627e3bd67f21d6f2276d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0d5fba7d253e0d09de2a4f46fce6a57340407a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0d5fba7d253e0d09de2a4f46fce6a57340407a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0d5fba7d253e0d09de2a4f46fce6a57340407a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/comments", "author": null, "committer": null, "parents": [{"sha": "ef720b21fd6c767e3053a61f01d91fa7f1fc6410", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef720b21fd6c767e3053a61f01d91fa7f1fc6410", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef720b21fd6c767e3053a61f01d91fa7f1fc6410"}], "stats": {"total": 210, "additions": 86, "deletions": 124}, "files": [{"sha": "e4d93b14fce971ad3f6d28de8deee7eb6845b84e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a0d5fba7d253e0d09de2a4f46fce6a57340407a8", "patch": "@@ -1,3 +1,16 @@\n+Mon Jan 12 01:35:18 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* init.c (build_new_1): Split out from build_new.\n+\t(build_new): Just return a NEW_EXPR.\n+\t* expr.c (cplus_expand_expr): Handle NEW_EXPR.\n+\n+\t* decl2.c (get_temp_regvar): Tweak.\n+\n+\t* cp-tree.h (TREE_CALLS_NEW): Comment out.\n+\t* class.c (resolves_to_fixed_type_p): Remove use.\n+\t* method.c (build_opfncall): Likewise.\n+\t* call.c (build_new_op): Likewise.\n+\n Wed Jan  7 23:47:13 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* exception.cc (__eh_alloc, __eh_free): New fns."}, {"sha": "848a821ee953511b26c24f9ab56c29ca25a0abb0", "filename": "gcc/cp/call.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=a0d5fba7d253e0d09de2a4f46fce6a57340407a8", "patch": "@@ -4738,7 +4738,6 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t  return rval;\n \n \tTREE_TYPE (rval) = arg1;\n-\tTREE_CALLS_NEW (rval) = 1;\n \treturn rval;\n       }\n "}, {"sha": "87a0eeb06240cfcfa54f18ddd9204a6e7fe81a91", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a0d5fba7d253e0d09de2a4f46fce6a57340407a8", "patch": "@@ -4574,13 +4574,6 @@ resolves_to_fixed_type_p (instance, nonnull)\n       return resolves_to_fixed_type_p (TREE_OPERAND (instance, 0), nonnull);\n \n     case RTL_EXPR:\n-      /* This is a call to `new', hence it's never zero.  */\n-      if (TREE_CALLS_NEW (instance))\n-\t{\n-\t  if (nonnull)\n-\t    *nonnull = 1;\n-\t  return 1;\n-\t}\n       return 0;\n \n     case PLUS_EXPR:"}, {"sha": "e7856f00a77ea08dc6d1eddc70b1f876e377eec2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a0d5fba7d253e0d09de2a4f46fce6a57340407a8", "patch": "@@ -1116,10 +1116,12 @@ struct lang_decl\n    using a twos-complement negated operand.  */\n #define TREE_NEGATED_INT(NODE) (TREE_LANG_FLAG_0 (NODE))\n \n+#if 0\t\t\t\t/* UNUSED */\n /* Nonzero in any kind of _EXPR or _REF node means that it is a call\n    to a storage allocation routine.  If, later, alternate storage\n    is found to hold the object, this call can be ignored.  */\n #define TREE_CALLS_NEW(NODE) (TREE_LANG_FLAG_1 (NODE))\n+#endif\n \n /* Nonzero in any kind of _TYPE that uses multiple inheritance\n    or virtual baseclasses.  */\n@@ -2227,6 +2229,7 @@ extern tree build_offset_ref\t\t\tPROTO((tree, tree));\n extern tree resolve_offset_ref\t\t\tPROTO((tree));\n extern tree decl_constant_value\t\t\tPROTO((tree));\n extern tree build_new\t\t\t\tPROTO((tree, tree, tree, int));\n+extern tree build_new_1\t\t\t\tPROTO((tree));\n extern tree expand_vec_init\t\t\tPROTO((tree, tree, tree, tree, int));\n extern tree build_x_delete\t\t\tPROTO((tree, tree, int, tree));\n extern tree build_delete\t\t\tPROTO((tree, tree, tree, int, int));"}, {"sha": "971a3e4d27bce0a3cf00cf1e4a86b4f7becc7133", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=a0d5fba7d253e0d09de2a4f46fce6a57340407a8", "patch": "@@ -2148,21 +2148,18 @@ tree\n get_temp_regvar (type, init)\n      tree type, init;\n {\n-  static char buf[sizeof (AUTO_TEMP_FORMAT) + 20] = { '_' };\n   tree decl;\n \n-  sprintf (buf+1, AUTO_TEMP_FORMAT, temp_name_counter++);\n-  decl = build_decl (VAR_DECL, get_identifier (buf), type);\n+  decl = build_decl (VAR_DECL, NULL_TREE, type);\n   TREE_USED (decl) = 1;\n   DECL_REGISTER (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n \n-  if (init)\n-    store_init_value (decl, init);\n-\n+  DECL_RTL (decl) = assign_temp (type, 2, 0, 1);\n   /* We can expand these without fear, since they cannot need\n      constructors or destructors.  */\n-  expand_decl (decl);\n-  expand_decl_init (decl);\n+  expand_expr (build_modify_expr (decl, INIT_EXPR, init),\n+\t       NULL_RTX, VOIDmode, 0);\n \n   return decl;\n }"}, {"sha": "266da02e904f0d55bf4cf055b5621d265075202b", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=a0d5fba7d253e0d09de2a4f46fce6a57340407a8", "patch": "@@ -188,6 +188,9 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t\t\t   integer_one_node, 1),\n \t  TREE_OPERAND (exp, 1), 0), target, tmode, modifier);\n \n+    case NEW_EXPR:\n+      return expand_expr (build_new_1 (exp), target, tmode, modifier);\n+\n     default:\n       break;\n     }"}, {"sha": "53cb2007f7ea54928350d289333e3c2feeb4aa63", "filename": "gcc/cp/init.c", "status": "modified", "additions": 62, "deletions": 107, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a0d5fba7d253e0d09de2a4f46fce6a57340407a8", "patch": "@@ -2246,12 +2246,9 @@ build_new (placement, decl, init, use_global_new)\n      tree decl, init;\n      int use_global_new;\n {\n-  tree type, true_type, size, rval;\n-  tree nelts;\n-  tree alloc_expr, alloc_node;\n+  tree type, rval;\n+  tree nelts, t;\n   int has_array = 0;\n-  enum tree_code code = NEW_EXPR;\n-  int use_cookie, nothrow, check_new;\n \n   tree pending_sizes = NULL_TREE;\n \n@@ -2326,7 +2323,7 @@ build_new (placement, decl, init, use_global_new)\n       else\n \tTREE_VALUE (decl) = absdcl;\n \n-      type = true_type = groktypename (decl);\n+      type = groktypename (decl);\n       if (! type || type == error_mark_node)\n \t{\n \t  immediate_size_expand = old_immediate_size_expand;\n@@ -2355,23 +2352,19 @@ build_new (placement, decl, init, use_global_new)\n \t  my_friendly_assert (TREE_CODE (decl) == TYPE_DECL, 215);\n \t  type = TREE_TYPE (decl);\n \t}\n-      true_type = type;\n     }\n   else if (TREE_CODE (decl) == TYPE_DECL)\n     {\n       type = TREE_TYPE (decl);\n-      true_type = type;\n     }\n   else\n     {\n       type = decl;\n-      true_type = type;\n       decl = TYPE_MAIN_DECL (type);\n     }\n \n   if (processing_template_decl)\n     {\n-      tree t;\n       if (has_array)\n \tt = min_tree_cons (min_tree_cons (NULL_TREE, type, NULL_TREE),\n \t\t\t   build_min_nt (ARRAY_REF, NULL_TREE, nelts),\n@@ -2390,7 +2383,7 @@ build_new (placement, decl, init, use_global_new)\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n       error (\"new cannot be applied to a reference type\");\n-      type = true_type = TREE_TYPE (type);\n+      type = TREE_TYPE (type);\n     }\n \n   if (TREE_CODE (type) == FUNCTION_TYPE)\n@@ -2406,9 +2399,58 @@ build_new (placement, decl, init, use_global_new)\n     {\n       nelts = array_type_nelts_top (type);\n       has_array = 1;\n-      type = true_type = TREE_TYPE (type);\n+      type = TREE_TYPE (type);\n     }\n \n+  if (has_array)\n+    t = build_nt (ARRAY_REF, type, nelts);\n+  else\n+    t = type;\n+\n+  rval = build (NEW_EXPR, build_pointer_type (type), placement, t, init);\n+  NEW_EXPR_USE_GLOBAL (rval) = use_global_new;\n+  TREE_SIDE_EFFECTS (rval) = 1;\n+\n+  /* Wrap it in a NOP_EXPR so warn_if_unused_value doesn't complain.  */\n+  rval = build1 (NOP_EXPR, TREE_TYPE (rval), rval);\n+  TREE_NO_UNUSED_WARNING (rval) = 1;\n+\n+  if (pending_sizes)\n+    rval = build_compound_expr (chainon (pending_sizes,\n+\t\t\t\t\t build_expr_list (NULL_TREE, rval)));\n+\n+  return rval;\n+}\n+\n+/* Called from cplus_expand_expr when expanding a NEW_EXPR.  The return\n+   value is immediately handed to expand_expr.  */\n+\n+tree\n+build_new_1 (exp)\n+     tree exp;\n+{\n+  tree placement, init, t;\n+  tree type, true_type, size, rval;\n+  tree nelts;\n+  tree alloc_expr, alloc_node;\n+  int has_array = 0;\n+  enum tree_code code = NEW_EXPR;\n+  int use_cookie, nothrow, check_new;\n+  int use_global_new;\n+\n+  placement = TREE_OPERAND (exp, 0);\n+  type = TREE_OPERAND (exp, 1);\n+  init = TREE_OPERAND (exp, 2);\n+  use_global_new = NEW_EXPR_USE_GLOBAL (exp);\n+\n+  if (TREE_CODE (type) == ARRAY_REF)\n+    {\n+      has_array = 1;\n+      nelts = TREE_OPERAND (type, 1);\n+      type = TREE_OPERAND (type, 0);\n+    }\n+  true_type = type;\n+\n   if (TYPE_READONLY (type) || TYPE_VOLATILE (type))\n     type = TYPE_MAIN_VARIANT (type);\n \n@@ -2543,21 +2585,21 @@ build_new (placement, decl, init, use_global_new)\n     {\n       tree extra = BI_header_size;\n       tree cookie, exp1;\n-      rval = cp_convert (ptr_type_node, rval);    /* convert to void * first */\n-      rval = cp_convert (string_type_node, rval); /* lets not add void* and ints */\n+      rval = convert (string_type_node, rval); /* for ptr arithmetic */\n       rval = save_expr (build_binary_op (PLUS_EXPR, rval, extra, 1));\n       /* Store header info.  */\n-      cookie = build_indirect_ref (build (MINUS_EXPR, build_pointer_type (BI_header_type),\n+      cookie = build_indirect_ref (build (MINUS_EXPR,\n+\t\t\t\t\t  build_pointer_type (BI_header_type),\n \t\t\t\t\t  rval, extra), NULL_PTR);\n       exp1 = build (MODIFY_EXPR, void_type_node,\n-\t\t    build_component_ref (cookie, nc_nelts_field_id, NULL_TREE, 0),\n+\t\t    build_component_ref (cookie, nc_nelts_field_id,\n+\t\t\t\t\t NULL_TREE, 0),\n \t\t    nelts);\n       TREE_SIDE_EFFECTS (exp1) = 1;\n       rval = cp_convert (build_pointer_type (true_type), rval);\n-      TREE_CALLS_NEW (rval) = 1;\n-      TREE_SIDE_EFFECTS (rval) = 1;\n-      rval = build_compound_expr (expr_tree_cons (NULL_TREE, exp1,\n-\t\t\t\t\t     build_expr_list (NULL_TREE, rval)));\n+      rval = build_compound_expr\n+\t(expr_tree_cons (NULL_TREE, exp1,\n+\t\t\t build_expr_list (NULL_TREE, rval)));\n     }\n \n   if (rval == error_mark_node)\n@@ -2596,7 +2638,6 @@ build_new (placement, decl, init, use_global_new)\n \t\t\trval);\n \t  TREE_NO_UNUSED_WARNING (rval) = 1;\n \t  TREE_SIDE_EFFECTS (rval) = 1;\n-\t  TREE_CALLS_NEW (rval) = 1;\n \t}\n       else if (! has_array)\n \t{\n@@ -2631,88 +2672,6 @@ build_new (placement, decl, init, use_global_new)\n       else\n \trval = build (VEC_INIT_EXPR, TREE_TYPE (rval),\n \t\t      save_expr (rval), init, nelts);\n-#if 0\t\n-      else if (current_function_decl == NULL_TREE)\n-\t{\n-\t  extern tree static_aggregates;\n-\n-\t  /* In case of static initialization, SAVE_EXPR is good enough.  */\n-\t  rval = save_expr (rval);\n-\t  rval = copy_to_permanent (rval);\n-\t  init = copy_to_permanent (init);\n-\t  init = expand_vec_init (decl, rval,\n-\t\t\t\t  build_binary_op (MINUS_EXPR, nelts,\n-\t\t\t\t\t\t   integer_one_node, 1),\n-\t\t\t\t  init, 0);\n-\t  init = copy_to_permanent (init);\n-\t  static_aggregates = perm_tree_cons (init, rval, static_aggregates);\n-\t}\n-      else\n-\t{\n-\t  /* Have to wrap this in RTL_EXPR for two cases:\n-\t     in base or member initialization and if we\n-\t     are a branch of a ?: operator.  Since we\n-\t     can't easily know the latter, just do it always.  */\n-\t  tree xval = make_node (RTL_EXPR);\n-\n-\t  /* If we want to check the value of the allocation expression,\n-             and the number of elements in the array is not a constant, we\n-             *must* expand the SAVE_EXPR for nelts in alloc_expr before we\n-             expand it in the actual initialization.  So we need to build up\n-             an RTL_EXPR for alloc_expr.  Sigh.  */\n-\t  if (alloc_expr && ! TREE_CONSTANT (nelts))\n-\t    {\n-\t      tree xval = make_node (RTL_EXPR);\n-\t      rtx rtxval;\n-\t      TREE_TYPE (xval) = TREE_TYPE (alloc_expr);\n-\t      do_pending_stack_adjust ();\n-\t      start_sequence_for_rtl_expr (xval);\n-\t      emit_note (0, -1);\n-\t      rtxval = expand_expr (alloc_expr, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-\t      do_pending_stack_adjust ();\n-\t      TREE_SIDE_EFFECTS (xval) = 1;\n-\t      RTL_EXPR_SEQUENCE (xval) = get_insns ();\n-\t      end_sequence ();\n-\t      RTL_EXPR_RTL (xval) = rtxval;\n-\t      TREE_TYPE (xval) = TREE_TYPE (alloc_expr);\n-\t      alloc_expr = xval;\n-\t    }\n-\n-\t  TREE_TYPE (xval) = TREE_TYPE (rval);\n-\t  do_pending_stack_adjust ();\n-\t  start_sequence_for_rtl_expr (xval);\n-\n-\t  /* As a matter of principle, `start_sequence' should do this.  */\n-\t  emit_note (0, -1);\n-\n-\t  rval = save_expr (rval);\n-\t  rval = expand_vec_init (decl, rval,\n-\t\t\t\t  build_binary_op (MINUS_EXPR, nelts,\n-\t\t\t\t\t\t   integer_one_node, 1),\n-\t\t\t\t  init, 0);\n-\n-\t  do_pending_stack_adjust ();\n-\n-\t  TREE_SIDE_EFFECTS (xval) = 1;\n-\t  TREE_CALLS_NEW (xval) = 1;\n-\t  RTL_EXPR_SEQUENCE (xval) = get_insns ();\n-\t  end_sequence ();\n-\n-\t  if (TREE_CODE (rval) == SAVE_EXPR)\n-\t    {\n-\t      /* Errors may cause this to not get evaluated.  */\n-\t      if (SAVE_EXPR_RTL (rval) == 0)\n-\t\tSAVE_EXPR_RTL (rval) = const0_rtx;\n-\t      RTL_EXPR_RTL (xval) = SAVE_EXPR_RTL (rval);\n-\t    }\n-\t  else\n-\t    {\n-\t      my_friendly_assert (TREE_CODE (rval) == VAR_DECL, 217);\n-\t      RTL_EXPR_RTL (xval) = DECL_RTL (rval);\n-\t    }\n-\t  rval = xval;\n-\t}\n-#endif\n \n       /* If any part of the object initialization terminates by throwing\n \t an exception and the new-expression does not contain a\n@@ -2811,10 +2770,6 @@ build_new (placement, decl, init, use_global_new)\n       rval = build_c_cast (build_pointer_type (type), rval);\n     }\n \n-  if (pending_sizes)\n-    rval = build_compound_expr (chainon (pending_sizes,\n-\t\t\t\t\t build_expr_list (NULL_TREE, rval)));\n-\n   return rval;\n }\n \f"}, {"sha": "117fb02993645ffedc72cc413786b6ea87296b75", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0d5fba7d253e0d09de2a4f46fce6a57340407a8/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a0d5fba7d253e0d09de2a4f46fce6a57340407a8", "patch": "@@ -1396,7 +1396,6 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n \t  return rval;\n \n \tTREE_TYPE (rval) = xarg1;\n-\tTREE_CALLS_NEW (rval) = 1;\n \treturn rval;\n       }\n       break;"}]}