{"sha": "b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjcwYmIwNWJkMTg5YTgwYzc5MjI1ZjcwNTY0NDFkN2UzZTFjMGI2Yw==", "commit": {"author": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2017-07-14T20:16:57Z"}, "committer": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2017-07-14T20:16:57Z"}, "message": "rs6000-c.c (altivec_overloaded_builtins): Add array entries to represent __ieee128 versions of the scalar_test_data_class...\n\ngcc/ChangeLog:\n\n2017-07-14  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\t* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add\n\tarray entries to represent __ieee128 versions of the\n\tscalar_test_data_class, scalar_test_neg, scalar_extract_exp,\n\tscalar_extract_sig, and scalar_insert_exp built-in functions.\n\t(altivec_resolve_overloaded_builtin): Add special case handling\n\tfor the __builtin_scalar_insert_exp function, as represented by\n\tthe P9V_BUILTIN_VEC_VSIEDP constant.\n\t* config/rs6000/rs6000-builtin.def (VSEEQP): Add scalar extract\n\texponent support for __ieee128 argument.\n\t(VSESQP): Add scalar extract signature support for __ieee128\n\targument.\n\t(VSTDCNQP): Add scalar test negative support for __ieee128\n\targument.\n\t(VSIEQP): Add scalar insert exponent support for __int128 argument\n\twith __ieee128 result.\n\t(VSIEQPF): Add scalar insert exponent support for __ieee128\n\targument with __ieee128 result.\n\t(VSTDCQP): Add scalar test data class support for __ieee128\n\targument.\n\t(VSTDCNQP): Add overload support for scalar test negative with\n\t__ieee128 argument.\n\t(VSTDCQP): Add overload support for scalar test data class\n\t__ieee128 argument.\n\t* config/rs6000/vsx.md (UNSPEC_VSX_SXSIG) Replace\n\tUNSPEC_VSX_SXSIGDP.\n\t(UNSPEC_VSX_SIEXPQP): New constant.\n\t(xsxexpqp): New insn for VSX scalar extract exponent quad\n\tprecision.\n\t(xsxsigqp): New insn for VSX scalar extract significand quad\n\tprecision.\n\t(xsiexpqpf): New insn for VSX scalar insert exponent quad\n\tprecision with floating point argument.\n\t(xststdcqp): New expand for VSX scalar test data class quad\n\tprecision.\n\t(xststdcnegqp): New expand for VSX scalar test negative quad\n\tprecision.\n\t(xststdcqp): New insn to match expansions for VSX scalar test data\n\tclass quad precision and VSX scalar test negative quad precision.\n\t* config/rs6000/rs6000.c (rs6000_expand_binop_builtin): Add\n\tspecial case operand checking to enforce that second operand of\n\tVSX scalar test data class with quad precision argument is a 7-bit\n\tunsigned literal.\n\t* doc/extend.texi (PowerPC AltiVec Built-in Functions): Add\n\tprototypes and descriptions of __ieee128 versions of\n\tscalar_extract_exp, scalar_extract_sig, scalar_insert_exp,\n\tscalar_test_data_class, and scalar_test_neg built-in functions.\n\ngcc/testsuite/ChangeLog:\n\n2017-07-14  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-eq-3.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-eq-4.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-gt-3.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-gt-4.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-lt-3.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-lt-4.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-unordered-3.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-unordered-4.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-exp-3.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-exp-4.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-exp-5.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-exp-6.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-exp-7.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-sig-3.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-sig-4.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-sig-5.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-sig-6.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-sig-7.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-insert-exp-10.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-insert-exp-11.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-insert-exp-12.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-insert-exp-13.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-insert-exp-14.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-insert-exp-15.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-insert-exp-6.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-insert-exp-7.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-insert-exp-8.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-insert-exp-9.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-10.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-11.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-12.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-13.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-14.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-15.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-8.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-9.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-neg-4.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-neg-5.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-neg-6.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-neg-7.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-neg-8.c: New test.\n\t* gcc.target/powerpc/bfp/vec-extract-exp-4.c: New test.\n\t* gcc.target/powerpc/bfp/vec-extract-exp-5.c: New test.\n\t* gcc.target/powerpc/bfp/vec-extract-sig-4.c: New test.\n\t* gcc.target/powerpc/bfp/vec-extract-sig-5.c: New test.\n\t* gcc.target/powerpc/bfp/vec-insert-exp-10.c: New test.\n\t* gcc.target/powerpc/bfp/vec-insert-exp-11.c: New test.\n\t* gcc.target/powerpc/bfp/vec-insert-exp-8.c: New test.\n\t* gcc.target/powerpc/bfp/vec-insert-exp-9.c: New test.\n\t* gcc.target/powerpc/bfp/vec-test-data-class-8.c: New test.\n\t* gcc.target/powerpc/bfp/vec-test-data-class-9.c: New test.\n\nFrom-SVN: r250214", "tree": {"sha": "559859bcfcc7636338a0051283b8444cac02f314", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/559859bcfcc7636338a0051283b8444cac02f314"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/comments", "author": null, "committer": null, "parents": [{"sha": "20316b9b2ee5fd60e40a84e64e8715b55092beb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20316b9b2ee5fd60e40a84e64e8715b55092beb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20316b9b2ee5fd60e40a84e64e8715b55092beb6"}], "stats": {"total": 2027, "additions": 2015, "deletions": 12}, "files": [{"sha": "4cacc6c6fdba31e5f5ea2fd6b1b72a8705a18a87", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -1,3 +1,52 @@\n+2017-07-14  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\t* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add\n+\tarray entries to represent __ieee128 versions of the\n+\tscalar_test_data_class, scalar_test_neg, scalar_extract_exp,\n+\tscalar_extract_sig, and scalar_insert_exp built-in functions.\n+\t(altivec_resolve_overloaded_builtin): Add special case handling\n+\tfor the __builtin_scalar_insert_exp function, as represented by\n+\tthe P9V_BUILTIN_VEC_VSIEDP constant.\n+\t* config/rs6000/rs6000-builtin.def (VSEEQP): Add scalar extract\n+\texponent support for __ieee128 argument.\n+\t(VSESQP): Add scalar extract signature support for __ieee128\n+\targument.\n+\t(VSTDCNQP): Add scalar test negative support for __ieee128\n+\targument.\n+\t(VSIEQP): Add scalar insert exponent support for __int128 argument\n+\twith __ieee128 result.\n+\t(VSIEQPF): Add scalar insert exponent support for __ieee128\n+\targument with __ieee128 result.\n+\t(VSTDCQP): Add scalar test data class support for __ieee128\n+\targument.\n+\t(VSTDCNQP): Add overload support for scalar test negative with\n+\t__ieee128 argument.\n+\t(VSTDCQP): Add overload support for scalar test data class\n+\t__ieee128 argument.\n+\t* config/rs6000/vsx.md (UNSPEC_VSX_SXSIG) Replace\n+\tUNSPEC_VSX_SXSIGDP.\n+\t(UNSPEC_VSX_SIEXPQP): New constant.\n+\t(xsxexpqp): New insn for VSX scalar extract exponent quad\n+\tprecision.\n+\t(xsxsigqp): New insn for VSX scalar extract significand quad\n+\tprecision.\n+\t(xsiexpqpf): New insn for VSX scalar insert exponent quad\n+\tprecision with floating point argument.\n+\t(xststdcqp): New expand for VSX scalar test data class quad\n+\tprecision.\n+\t(xststdcnegqp): New expand for VSX scalar test negative quad\n+\tprecision.\n+\t(xststdcqp): New insn to match expansions for VSX scalar test data\n+\tclass quad precision and VSX scalar test negative quad precision.\n+\t* config/rs6000/rs6000.c (rs6000_expand_binop_builtin): Add\n+\tspecial case operand checking to enforce that second operand of\n+\tVSX scalar test data class with quad precision argument is a 7-bit\n+\tunsigned literal.\n+\t* doc/extend.texi (PowerPC AltiVec Built-in Functions): Add\n+\tprototypes and descriptions of __ieee128 versions of\n+\tscalar_extract_exp, scalar_extract_sig, scalar_insert_exp,\n+\tscalar_test_data_class, and scalar_test_neg built-in functions.\n+\n 2016-07-14  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR tree-optimization/81162"}, {"sha": "f2ff76b22f2b49f5fcac54b98791bfcc130ff6e4", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -2024,6 +2024,10 @@ BU_P9V_OVERLOAD_3 (RLMI,\t\"rlmi\")\n BU_P9V_64BIT_VSX_1 (VSEEDP,\t\"scalar_extract_exp\",\tCONST,\txsxexpdp)\n BU_P9V_64BIT_VSX_1 (VSESDP,\t\"scalar_extract_sig\",\tCONST,\txsxsigdp)\n \n+BU_P9V_64BIT_VSX_1 (VSEEQP,\t\"scalar_extract_expq\",\tCONST,\txsxexpqp)\n+BU_P9V_64BIT_VSX_1 (VSESQP,\t\"scalar_extract_sigq\",\tCONST,\txsxsigqp)\n+\n+BU_P9V_VSX_1 (VSTDCNQP,\t\"scalar_test_neg_qp\",\tCONST,\txststdcnegqp)\n BU_P9V_VSX_1 (VSTDCNDP,\t\"scalar_test_neg_dp\",\tCONST,\txststdcnegdp)\n BU_P9V_VSX_1 (VSTDCNSP,\t\"scalar_test_neg_sp\",\tCONST,\txststdcnegsp)\n \n@@ -2039,11 +2043,15 @@ BU_P9V_VSX_1 (XXBRH_V8HI,\t\"xxbrh_v8hi\",\tCONST,\tp9_xxbrh_v8hi)\n BU_P9V_64BIT_VSX_2 (VSIEDP,\t\"scalar_insert_exp\",\tCONST,\txsiexpdp)\n BU_P9V_64BIT_VSX_2 (VSIEDPF,\t\"scalar_insert_exp_dp\",\tCONST,\txsiexpdpf)\n \n+BU_P9V_64BIT_VSX_2 (VSIEQP,\t\"scalar_insert_exp_q\",\tCONST,\txsiexpqp)\n+BU_P9V_64BIT_VSX_2 (VSIEQPF,\t\"scalar_insert_exp_qp\",\tCONST,\txsiexpqpf)\n+\n BU_P9V_VSX_2 (VSCEDPGT,\t\"scalar_cmp_exp_dp_gt\",\tCONST,\txscmpexpdp_gt)\n BU_P9V_VSX_2 (VSCEDPLT,\t\"scalar_cmp_exp_dp_lt\",\tCONST,\txscmpexpdp_lt)\n BU_P9V_VSX_2 (VSCEDPEQ,\t\"scalar_cmp_exp_dp_eq\",\tCONST,\txscmpexpdp_eq)\n BU_P9V_VSX_2 (VSCEDPUO,\t\"scalar_cmp_exp_dp_unordered\",\tCONST,\txscmpexpdp_unordered)\n \n+BU_P9V_VSX_2 (VSTDCQP,\t\"scalar_test_data_class_qp\",\tCONST,\txststdcqp)\n BU_P9V_VSX_2 (VSTDCDP,\t\"scalar_test_data_class_dp\",\tCONST,\txststdcdp)\n BU_P9V_VSX_2 (VSTDCSP,\t\"scalar_test_data_class_sp\",\tCONST,\txststdcsp)\n \n@@ -2052,6 +2060,7 @@ BU_P9V_OVERLOAD_1 (VSEEDP,\t\"scalar_extract_exp\")\n BU_P9V_OVERLOAD_1 (VSESDP,\t\"scalar_extract_sig\")\n \n BU_P9V_OVERLOAD_1 (VSTDCN,\t\"scalar_test_neg\")\n+BU_P9V_OVERLOAD_1 (VSTDCNQP,\t\"scalar_test_neg_qp\")\n BU_P9V_OVERLOAD_1 (VSTDCNDP,\t\"scalar_test_neg_dp\")\n BU_P9V_OVERLOAD_1 (VSTDCNSP,\t\"scalar_test_neg_sp\")\n \n@@ -2061,6 +2070,7 @@ BU_P9V_OVERLOAD_1 (REVB,\t\"revb\")\n BU_P9V_OVERLOAD_2 (VSIEDP,\t\"scalar_insert_exp\")\n \n BU_P9V_OVERLOAD_2 (VSTDC,\t\"scalar_test_data_class\")\n+BU_P9V_OVERLOAD_2 (VSTDCQP,\t\"scalar_test_data_class_qp\")\n BU_P9V_OVERLOAD_2 (VSTDCDP,\t\"scalar_test_data_class_dp\")\n BU_P9V_OVERLOAD_2 (VSTDCSP,\t\"scalar_test_data_class_sp\")\n "}, {"sha": "937cda0aa2ae6838ad6c159d95507ebf030c844a", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -4749,33 +4749,50 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_bool_int, RS6000_BTI_float, RS6000_BTI_INTSI, 0 },\n   { P9V_BUILTIN_VEC_VSTDC, P9V_BUILTIN_VSTDCDP,\n     RS6000_BTI_bool_int, RS6000_BTI_double, RS6000_BTI_INTSI, 0 },\n+  { P9V_BUILTIN_VEC_VSTDC, P9V_BUILTIN_VSTDCQP,\n+    RS6000_BTI_bool_int, RS6000_BTI_ieee128_float, RS6000_BTI_INTSI, 0 },\n \n   { P9V_BUILTIN_VEC_VSTDCSP, P9V_BUILTIN_VSTDCSP,\n     RS6000_BTI_bool_int, RS6000_BTI_float, RS6000_BTI_INTSI, 0 },\n   { P9V_BUILTIN_VEC_VSTDCDP, P9V_BUILTIN_VSTDCDP,\n     RS6000_BTI_bool_int, RS6000_BTI_double, RS6000_BTI_INTSI, 0 },\n+  { P9V_BUILTIN_VEC_VSTDCQP, P9V_BUILTIN_VSTDCQP,\n+    RS6000_BTI_bool_int, RS6000_BTI_ieee128_float, RS6000_BTI_INTSI, 0 },\n \n   { P9V_BUILTIN_VEC_VSTDCN, P9V_BUILTIN_VSTDCNSP,\n     RS6000_BTI_bool_int, RS6000_BTI_float, 0, 0 },\n   { P9V_BUILTIN_VEC_VSTDCN, P9V_BUILTIN_VSTDCNDP,\n     RS6000_BTI_bool_int, RS6000_BTI_double, 0, 0 },\n+  { P9V_BUILTIN_VEC_VSTDCN, P9V_BUILTIN_VSTDCNQP,\n+    RS6000_BTI_bool_int, RS6000_BTI_ieee128_float, 0, 0 },\n \n   { P9V_BUILTIN_VEC_VSTDCNSP, P9V_BUILTIN_VSTDCNSP,\n     RS6000_BTI_bool_int, RS6000_BTI_float, 0, 0 },\n   { P9V_BUILTIN_VEC_VSTDCNDP, P9V_BUILTIN_VSTDCNDP,\n     RS6000_BTI_bool_int, RS6000_BTI_double, 0, 0 },\n+  { P9V_BUILTIN_VEC_VSTDCNQP, P9V_BUILTIN_VSTDCNQP,\n+    RS6000_BTI_bool_int, RS6000_BTI_ieee128_float, 0, 0 },\n \n   { P9V_BUILTIN_VEC_VSEEDP, P9V_BUILTIN_VSEEDP,\n     RS6000_BTI_UINTSI, RS6000_BTI_double, 0, 0 },\n+  { P9V_BUILTIN_VEC_VSEEDP, P9V_BUILTIN_VSEEQP,\n+    RS6000_BTI_UINTDI, RS6000_BTI_ieee128_float, 0, 0 },\n \n   { P9V_BUILTIN_VEC_VSESDP, P9V_BUILTIN_VSESDP,\n     RS6000_BTI_UINTDI, RS6000_BTI_double, 0, 0 },\n+  { P9V_BUILTIN_VEC_VSESDP, P9V_BUILTIN_VSESQP,\n+    RS6000_BTI_UINTTI, RS6000_BTI_ieee128_float, 0, 0 },\n \n   { P9V_BUILTIN_VEC_VSIEDP, P9V_BUILTIN_VSIEDP,\n     RS6000_BTI_double, RS6000_BTI_UINTDI, RS6000_BTI_UINTDI, 0 },\n   { P9V_BUILTIN_VEC_VSIEDP, P9V_BUILTIN_VSIEDPF,\n     RS6000_BTI_double, RS6000_BTI_double, RS6000_BTI_UINTDI, 0 },\n \n+  { P9V_BUILTIN_VEC_VSIEDP, P9V_BUILTIN_VSIEQP,\n+    RS6000_BTI_ieee128_float, RS6000_BTI_UINTTI, RS6000_BTI_UINTDI, 0 },\n+  { P9V_BUILTIN_VEC_VSIEDP, P9V_BUILTIN_VSIEQPF,\n+    RS6000_BTI_ieee128_float, RS6000_BTI_ieee128_float, RS6000_BTI_UINTDI, 0 },\n+\n   { P9V_BUILTIN_VEC_VSCEDPGT, P9V_BUILTIN_VSCEDPGT,\n     RS6000_BTI_INTSI, RS6000_BTI_double, RS6000_BTI_double, 0 },\n   { P9V_BUILTIN_VEC_VSCEDPLT, P9V_BUILTIN_VSCEDPLT,\n@@ -6720,6 +6737,52 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t      unsupported_builtin = true;\n \t  }\n       }\n+    else if (fcode == P9V_BUILTIN_VEC_VSIEDP)\n+      {\n+\tint overloaded_code;\n+\tint arg1_mode = TYPE_MODE (types[0]);\n+\n+\tif (nargs != 2)\n+\t  {\n+\t    error (\"scalar_insert_exp only accepts 2 arguments\");\n+\t    return error_mark_node;\n+\t  }\n+\n+\t/* If supplied first argument is wider than 64 bits, resolve to\n+\t   128-bit variant of built-in function.  */\n+\tif (GET_MODE_PRECISION (arg1_mode) > 64)\n+\t  {\n+\t    /* If first argument is of float variety, choose variant\n+\t       that expects __ieee128 argument.  Otherwise, expect\n+\t       __int128 argument.  */\n+\t    if (GET_MODE_CLASS (arg1_mode) == MODE_FLOAT)\n+\t      overloaded_code = P9V_BUILTIN_VSIEQPF;\n+\t    else\n+\t      overloaded_code = P9V_BUILTIN_VSIEQP;\n+\t  }\n+\telse\n+\t  {\n+\t    /* If first argument is of float variety, choose variant\n+\t       that expects double argument.  Otherwise, expect\n+\t       long long int argument.  */\n+\t    if (GET_MODE_CLASS (arg1_mode) == MODE_FLOAT)\n+\t      overloaded_code = P9V_BUILTIN_VSIEDPF;\n+\t    else\n+\t      overloaded_code = P9V_BUILTIN_VSIEDP;\n+\t  }\n+\twhile (desc->code && desc->code == fcode &&\n+\t       desc->overloaded_code != overloaded_code)\n+\t  desc++;\n+\tif (desc->code && (desc->code == fcode)\n+\t    && rs6000_builtin_type_compatible (types[0], desc->op1)\n+\t    && rs6000_builtin_type_compatible (types[1], desc->op2))\n+\t  {\n+\t    if (rs6000_builtin_decls[desc->overloaded_code] != NULL_TREE)\n+\t      return altivec_build_resolved_builtin (args, n, desc);\n+\t    else\n+\t      unsupported_builtin = true;\n+\t  }\n+      }\n     else\n       {\n \t/* For arguments after the last, we have RS6000_BTI_NOT_OPAQUE in"}, {"sha": "9bf6f370c4e9843f6426373d1ffffe566b9256d6", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -14354,7 +14354,8 @@ rs6000_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)\n \t  return CONST0_RTX (tmode);\n \t}\n     }\n-  else if (icode == CODE_FOR_xststdcdp\n+  else if (icode == CODE_FOR_xststdcqp\n+\t   || icode == CODE_FOR_xststdcdp\n \t   || icode == CODE_FOR_xststdcsp\n \t   || icode == CODE_FOR_xvtstdcdp\n \t   || icode == CODE_FOR_xvtstdcsp)"}, {"sha": "ff65caa35dc2592b38d0a16c0bf3c5d20264da3d", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 91, "deletions": 4, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -363,8 +363,9 @@\n    UNSPEC_VSX_VSLO\n    UNSPEC_VSX_EXTRACT\n    UNSPEC_VSX_SXEXPDP\n-   UNSPEC_VSX_SXSIGDP\n+   UNSPEC_VSX_SXSIG\n    UNSPEC_VSX_SIEXPDP\n+   UNSPEC_VSX_SIEXPQP\n    UNSPEC_VSX_SCMPEXPDP\n    UNSPEC_VSX_STSTDC\n    UNSPEC_VSX_VXEXP\n@@ -3934,6 +3935,15 @@\n \f\n ;; ISA 3.0 Binary Floating-Point Support\n \n+;; VSX Scalar Extract Exponent Quad-Precision\n+(define_insn \"xsxexpqp\"\n+  [(set (match_operand:DI 0 \"altivec_register_operand\" \"=v\")\n+\t(unspec:DI [(match_operand:KF 1 \"altivec_register_operand\" \"v\")]\n+\t UNSPEC_VSX_SXEXPDP))]\n+  \"TARGET_P9_VECTOR\"\n+  \"xsxexpqp %0,%1\"\n+  [(set_attr \"type\" \"vecmove\")])\n+\n ;; VSX Scalar Extract Exponent Double-Precision\n (define_insn \"xsxexpdp\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -3943,15 +3953,44 @@\n   \"xsxexpdp %0,%x1\"\n   [(set_attr \"type\" \"integer\")])\n \n+;; VSX Scalar Extract Significand Quad-Precision\n+(define_insn \"xsxsigqp\"\n+  [(set (match_operand:TI 0 \"altivec_register_operand\" \"=v\")\n+\t(unspec:TI [(match_operand:KF 1 \"altivec_register_operand\" \"v\")]\n+\t UNSPEC_VSX_SXSIG))]\n+  \"TARGET_P9_VECTOR\"\n+  \"xsxsigqp %0,%1\"\n+  [(set_attr \"type\" \"vecmove\")])\n+\n ;; VSX Scalar Extract Significand Double-Precision\n (define_insn \"xsxsigdp\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(unspec:DI [(match_operand:DF 1 \"vsx_register_operand\" \"wa\")]\n-\t UNSPEC_VSX_SXSIGDP))]\n+\t UNSPEC_VSX_SXSIG))]\n   \"TARGET_P9_VECTOR && TARGET_64BIT\"\n   \"xsxsigdp %0,%x1\"\n   [(set_attr \"type\" \"integer\")])\n \n+;; VSX Scalar Insert Exponent Quad-Precision Floating Point Argument\n+(define_insn \"xsiexpqpf\"\n+  [(set (match_operand:KF 0 \"altivec_register_operand\" \"=v\")\n+\t(unspec:KF [(match_operand:KF 1 \"altivec_register_operand\" \"v\")\n+\t\t    (match_operand:DI 2 \"altivec_register_operand\" \"v\")]\n+\t UNSPEC_VSX_SIEXPQP))]\n+  \"TARGET_P9_VECTOR\"\n+  \"xsiexpqp %0,%1,%2\"\n+  [(set_attr \"type\" \"vecmove\")])\n+\n+;; VSX Scalar Insert Exponent Quad-Precision\n+(define_insn \"xsiexpqp\"\n+  [(set (match_operand:KF 0 \"altivec_register_operand\" \"=v\")\n+\t(unspec:KF [(match_operand:TI 1 \"altivec_register_operand\" \"v\")\n+\t\t    (match_operand:DI 2 \"altivec_register_operand\" \"v\")]\n+\t UNSPEC_VSX_SIEXPQP))]\n+  \"TARGET_P9_VECTOR\"\n+  \"xsiexpqp %0,%1,%2\"\n+  [(set_attr \"type\" \"vecmove\")])\n+\n ;; VSX Scalar Insert Exponent Double-Precision\n (define_insn \"xsiexpdp\"\n   [(set (match_operand:DF 0 \"vsx_register_operand\" \"=wa\")\n@@ -4000,6 +4039,27 @@\n   \"xscmpexpdp %0,%x1,%x2\"\n   [(set_attr \"type\" \"fpcompare\")])\n \n+;; VSX Scalar Test Data Class Quad-Precision\n+;;  (Expansion for scalar_test_data_class (__ieee128, int))\n+;;   (Has side effect of setting the lt bit if operand 1 is negative,\n+;;    setting the eq bit if any of the conditions tested by operand 2\n+;;    are satisfied, and clearing the gt and undordered bits to zero.)\n+(define_expand \"xststdcqp\"\n+  [(set (match_dup 3)\n+\t(compare:CCFP\n+\t (unspec:KF\n+\t  [(match_operand:KF 1 \"altivec_register_operand\" \"v\")\n+\t   (match_operand:SI 2 \"u7bit_cint_operand\" \"n\")]\n+\t  UNSPEC_VSX_STSTDC)\n+\t (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(eq:SI (match_dup 3)\n+\t       (const_int 0)))]\n+  \"TARGET_P9_VECTOR\"\n+{\n+  operands[3] = gen_reg_rtx (CCFPmode);\n+})\n+\n ;; VSX Scalar Test Data Class Double- and Single-Precision\n ;;  (The lt bit is set if operand 1 is negative.  The eq bit is set\n ;;   if any of the conditions tested by operand 2 are satisfied.\n@@ -4021,8 +4081,24 @@\n   operands[4] = CONST0_RTX (SImode);\n })\n \n-;; The VSX Scalar Test Data Class Double- and Single-Precision\n-;; instruction may also be used to test for negative value.\n+;; The VSX Scalar Test Negative Quad-Precision\n+(define_expand \"xststdcnegqp\"\n+  [(set (match_dup 2)\n+\t(compare:CCFP\n+\t (unspec:KF\n+\t  [(match_operand:KF 1 \"altivec_register_operand\" \"v\")\n+\t   (const_int 0)]\n+\t  UNSPEC_VSX_STSTDC)\n+\t (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lt:SI (match_dup 2)\n+\t       (const_int 0)))]\n+  \"TARGET_P9_VECTOR\"\n+{\n+  operands[2] = gen_reg_rtx (CCFPmode);\n+})\n+\n+;; The VSX Scalar Test Negative Double- and Single-Precision\n (define_expand \"xststdcneg<Fvsx>\"\n   [(set (match_dup 2)\n \t(compare:CCFP\n@@ -4040,6 +4116,17 @@\n   operands[3] = CONST0_RTX (SImode);\n })\n \n+(define_insn \"*xststdcqp\"\n+  [(set (match_operand:CCFP 0 \"\" \"=y\")\n+\t(compare:CCFP\n+\t (unspec:KF [(match_operand:KF 1 \"altivec_register_operand\" \"v\")\n+\t\t     (match_operand:SI 2 \"u7bit_cint_operand\" \"n\")]\n+\t  UNSPEC_VSX_STSTDC)\n+\t (const_int 0)))]\n+  \"TARGET_P9_VECTOR\"\n+  \"xststdcqp %0,%1,%2\"\n+  [(set_attr \"type\" \"fpcompare\")])\n+\n (define_insn \"*xststdc<Fvsx>\"\n   [(set (match_operand:CCFP 0 \"\" \"=y\")\n \t(compare:CCFP"}, {"sha": "b6244a09d411466ebe1efa05ca92e45da4b20e75", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -1,4 +1,4 @@\n-@c Copyright (C) 1988-2017 Free Software Foundation, Inc.\n+c Copyright (C) 1988-2017 Free Software Foundation, Inc.\n \n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n@@ -15229,23 +15229,33 @@ long long __builtin_darn_raw (void);\n int __builtin_darn_32 (void);\n \n unsigned int scalar_extract_exp (double source);\n+unsigned long long int scalar_extract_exp (__ieee128 source);\n+\n unsigned long long int scalar_extract_sig (double source);\n+unsigned __int128 scalar_extract_sig (__ieee128 source);\n \n double\n scalar_insert_exp (unsigned long long int significand, unsigned long long int exponent);\n double\n scalar_insert_exp (double significand, unsigned long long int exponent);\n \n+ieee_128\n+scalar_insert_exp (unsigned __int128 significand, unsigned long long int exponent);\n+ieee_128\n+scalar_insert_exp (ieee_128 significand, unsigned long long int exponent);\n+\n int scalar_cmp_exp_gt (double arg1, double arg2);\n int scalar_cmp_exp_lt (double arg1, double arg2);\n int scalar_cmp_exp_eq (double arg1, double arg2);\n int scalar_cmp_exp_unordered (double arg1, double arg2);\n \n bool scalar_test_data_class (float source, const int condition);\n bool scalar_test_data_class (double source, const int condition);\n+bool scalar_test_data_class (__ieee128 source, const int condition);\n \n bool scalar_test_neg (float source);\n bool scalar_test_neg (double source);\n+bool scalar_test_neg (__ieee128 source);\n \n int __builtin_byte_in_set (unsigned char u, unsigned long long set);\n int __builtin_byte_in_range (unsigned char u, unsigned int range);\n@@ -15285,25 +15295,38 @@ functions require a 64-bit environment supporting ISA 3.0 or later.\n The @code{scalar_extract_exp} and @code{scalar_extract_sig} built-in\n functions return the significand and the biased exponent value\n respectively of their @code{source} arguments.\n-Within the result returned by @code{scalar_extract_sig},\n-the @code{0x10000000000000} bit is set if the\n+When supplied with a 64-bit @code{source} argument, the\n+result returned by @code{scalar_extract_sig} has\n+the @code{0x0010000000000000} bit set if the\n function's @code{source} argument is in normalized form.\n Otherwise, this bit is set to 0.\n+When supplied with a 128-bit @code{source} argument, the\n+@code{0x00010000000000000000000000000000} bit of the result is\n+treated similarly.\n Note that the sign of the significand is not represented in the result\n returned from the @code{scalar_extract_sig} function.  Use the\n @code{scalar_test_neg} function to test the sign of its @code{double}\n argument.\n \n-The @code{scalar_insert_exp} \n-function requires a 64-bit environment supporting ISA 3.0 or later.\n-The @code{scalar_insert_exp} built-in function returns a double-precision\n+The @code{scalar_insert_exp}\n+functions require a 64-bit environment supporting ISA 3.0 or later.\n+When supplied with a 64-bit first argument, the\n+@code{scalar_insert_exp} built-in function returns a double-precision\n floating point value that is constructed by assembling the values of its\n @code{significand} and @code{exponent} arguments.  The sign of the\n result is copied from the most significant bit of the\n @code{significand} argument.  The significand and exponent components\n of the result are composed of the least significant 11 bits of the\n @code{exponent} argument and the least significant 52 bits of the\n-@code{significand} argument.\n+@code{significand} argument respectively.\n+\n+When supplied with a 128-bit first argument, the\n+@code{scalar_insert_exp} built-in function returns a quad-precision\n+ieee floating point value.  The sign bit of the result is copied from\n+the most significant bit of the @code{significand} argument.\n+The significand and exponent components of the result are composed of\n+the least significant 15 bits of the @code{exponent} argument and the\n+least significant 112 bits of the @code{significand} argument respectively.\n \n The @code{scalar_cmp_exp_gt}, @code{scalar_cmp_exp_lt},\n @code{scalar_cmp_exp_eq}, and @code{scalar_cmp_exp_unordered} built-in"}, {"sha": "7474c662a76d3de496033f119b169d66745980a1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -1,3 +1,57 @@\n+2017-07-14  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-eq-3.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-eq-4.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-gt-3.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-gt-4.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-lt-3.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-lt-4.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-unordered-3.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-unordered-4.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-exp-3.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-exp-4.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-exp-5.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-exp-6.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-exp-7.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-sig-3.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-sig-4.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-sig-5.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-sig-6.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-sig-7.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-insert-exp-10.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-insert-exp-11.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-insert-exp-12.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-insert-exp-13.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-insert-exp-14.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-insert-exp-15.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-insert-exp-6.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-insert-exp-7.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-insert-exp-8.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-insert-exp-9.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-10.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-11.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-12.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-13.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-14.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-15.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-8.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-9.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-neg-4.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-neg-5.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-neg-6.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-neg-7.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-neg-8.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-extract-exp-4.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-extract-exp-5.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-extract-sig-4.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-extract-sig-5.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-insert-exp-10.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-insert-exp-11.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-insert-exp-8.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-insert-exp-9.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-test-data-class-8.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-test-data-class-9.c: New test.\n+\n 2016-07-14  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR tree-optimization/81162"}, {"sha": "e069fb49af960e8c460f0d0d1634139c5e9c9c74", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-eq-3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-eq-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-eq-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-eq-3.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+int\n+compare_exponents_eq (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  return scalar_cmp_exp_eq (exponent1, exponent2);\n+}\n+\n+int\n+main ()\n+{\n+  double x = (double) (0x1100LL << 50);\n+  double y = (double) (0x1101LL << 50);\n+  double z = (double) (0x1101LL << 37);\n+\n+  if (!compare_exponents_eq (&x, &y))\n+    abort ();\n+  if (compare_exponents_eq (&x, &z))\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "800c32c6e07fc307bfc2bd38cd45858c83cb09e8", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-eq-4.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-eq-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-eq-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-eq-4.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+char\n+compare_exponents_eq (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  if (scalar_cmp_exp_eq (exponent1, exponent2))\n+    return 't';\n+  else\n+    return 'f';\n+}\n+\n+int\n+main ()\n+{\n+  double x = (double) (0x1100LL << 50);\n+  double y = (double) (0x1101LL << 50);\n+  double z = (double) (0x1101LL << 37);\n+\n+  if (compare_exponents_eq (&x, &y) == 'f')\n+    abort ();\n+  if (compare_exponents_eq (&x, &z) == 't')\n+    abort ();\n+  return 0;\n+}"}, {"sha": "c0cedecaa7ffe446d0fe2d59260447279707b44c", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-gt-3.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-gt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-gt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-gt-3.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+int\n+compare_exponents_gt (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  return scalar_cmp_exp_gt (exponent1, exponent2);\n+}\n+\n+int\n+main ()\n+{\n+  double x = (double) (0x1100LL << 50);\n+  double y = (double) (0x1101LL << 50);\n+  double z = (double) (0x1101LL << 37);\n+\n+  if (compare_exponents_gt (&x, &y))\n+    abort ();\n+  if (!compare_exponents_gt (&x, &z))\n+    abort ();\n+  return 0;\n+}"}, {"sha": "1e24355d7f1cdb3e869bcdcc1293dd9321a6f517", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-gt-4.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-gt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-gt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-gt-4.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+char\n+compare_exponents_gt (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  if (scalar_cmp_exp_gt (exponent1, exponent2))\n+    return 't';\n+  else\n+    return 'f';\n+}\n+\n+int\n+main ()\n+{\n+  double x = (double) (0x1100LL << 50);\n+  double y = (double) (0x1101LL << 50);\n+  double z = (double) (0x1101LL << 37);\n+\n+  if (compare_exponents_gt (&x, &y) == 't')\n+    abort ();\n+  if (compare_exponents_gt (&x, &z) == 'f')\n+    abort ();\n+  return 0;\n+}"}, {"sha": "acc24b5658e5ce1ca01c81d38d8ee9dd7a1040ee", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-lt-3.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-lt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-lt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-lt-3.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+int\n+compare_exponents_lt (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  return scalar_cmp_exp_lt (exponent1, exponent2);\n+}\n+\n+int\n+main ()\n+{\n+  double x = (double) (0x1100LL << 50);\n+  double y = (double) (0x1101LL << 50);\n+  double z = (double) (0x1101LL << 37);\n+\n+  if (compare_exponents_lt (&x, &y))\n+    abort ();\n+  if (!compare_exponents_lt (&z, &x))\n+    abort ();\n+  return 0;\n+}"}, {"sha": "b8bd278dce55d11464a137ea249e8c64a5dad612", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-lt-4.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-lt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-lt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-lt-4.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run  { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+char\n+compare_exponents_lt (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  if (scalar_cmp_exp_lt (exponent1, exponent2))\n+    return 't';\n+  else\n+    return 'f';\n+}\n+\n+int\n+main ()\n+{\n+  double x = (double) (0x1100LL << 50);\n+  double y = (double) (0x1101LL << 50);\n+  double z = (double) (0x1101LL << 37);\n+\n+  if (compare_exponents_lt (&x, &y) == 't')\n+    abort ();\n+  if (compare_exponents_lt (&z, &x) == 'f')\n+    abort ();\n+  return 0;\n+}"}, {"sha": "79900c21b5a7769b82cecbbfda5eff8c1b6ca0f7", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-unordered-3.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-unordered-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-unordered-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-unordered-3.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+int\n+compare_exponents_unordered (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  /* This test succeeds if either exponent1 or exponent2 is NaN. */\n+  return scalar_cmp_exp_unordered (exponent1, exponent2);\n+}\n+\n+int\n+main ()\n+{\n+  /* NaN is denoted by exponent = 2047 and fraction != 0 */\n+  unsigned long long int nan_image = 0x7ff0000000000003LL;\n+  double *nan_ptr = (double *) &nan_image;\n+\n+  double x = (double) (0x1100LL << 50);\n+  double y = (double) (0x1101LL << 50);\n+  double z = (double) (0x1101LL << 37);\n+\n+  if (!compare_exponents_unordered (&x, nan_ptr))\n+    abort ();\n+  if (compare_exponents_unordered (&x, &z))\n+    abort ();\n+  return 0;\n+}"}, {"sha": "4371946a6d71d51aa7f0449e25942c1be21de080", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-unordered-4.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-unordered-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-unordered-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-unordered-4.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+char\n+compare_exponents_unordered (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  /* This test succeeds if either exponent1 or exponent2 is NaN. */\n+  if (scalar_cmp_exp_unordered (exponent1, exponent2))\n+    return 't';\n+  else\n+    return 'f';\n+}\n+\n+int\n+main ()\n+{\n+  /* NaN is denoted by exponent = 2047 and fraction != 0 */\n+  unsigned long long int nan_image = 0x7ff0000000000003LL;\n+  double *nan_ptr = (double *) &nan_image;\n+\n+  double x = (double) (0x1100LL << 50);\n+  double y = (double) (0x1101LL << 50);\n+  double z = (double) (0x1101LL << 37);\n+\n+  if (compare_exponents_unordered (&x, nan_ptr) == 'f')\n+    abort ();\n+  if (compare_exponents_unordered (&x, &z) == 't')\n+    abort ();\n+  return 0;\n+}"}, {"sha": "9e6fb085d475d4ebd8d74b50f9f86000f4fe129b", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-exp-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-3.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+\n+unsigned long long int\n+get_exponent (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  return scalar_extract_exp (source);\n+}\n+\n+/* { dg-final { scan-assembler \"xsxexpqp\" } } */"}, {"sha": "502241581d9fcd66a7562b7d255b690e3f95316e", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-exp-4.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-4.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+\n+unsigned long long int\n+get_exponent (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  return __builtin_vec_scalar_extract_exp (source); /* { dg-error \"Builtin function __builtin_vsx_scalar_extract_expq requires\" } */\n+}\n+\n+"}, {"sha": "07e0c1de7e3130a1aa12950ae9526473861d90b5", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-exp-5.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-5.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test only runs on 32-bit configurations, where a compiler error\n+   should be issued because this builtin is not available on\n+   32-bit configurations.  */\n+\n+#include <altivec.h>\n+\n+unsigned long long int\n+get_exponent (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  return scalar_extract_exp (source);\t/* { dg-error \"Builtin function __builtin_vec_scalar_extract_exp not supported in this compiler configuration\" } */\n+}\n+\n+"}, {"sha": "a5e31bf51ab943f72e8b49d0547c64dd24ddeda6", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-exp-6.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-6.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+unsigned int\n+get_unbiased_exponent (double *p)\n+{\n+  double source = *p;\n+\n+  return scalar_extract_exp (source) - 1023;\n+}\n+\n+int\n+main ()\n+{\n+  double x = (double) (0x1100LL << 50);\n+  double z = (double) (0x1101LL << 37);\n+\n+  if (get_unbiased_exponent (&x) != 62)\n+    abort ();\n+  if (get_unbiased_exponent (&z) != 49)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "3920594b65792b9a4b2501ca07aeaa61ff6ffe7c", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-exp-7.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-7.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+unsigned long long int\n+get_unbiased_exponent (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  return scalar_extract_exp (source) - 16383;\n+}\n+\n+int\n+main ()\n+{\n+  __ieee128 x = (__ieee128) (((__int128) 0x1100LL) << 114);\n+  __ieee128 z = (__ieee128) (((__int128) 0x1101LL) << 112);\n+\n+  if (get_unbiased_exponent (&x) != 126)\n+    abort ();\n+  if (get_unbiased_exponent (&z) != 124)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "093ba337785651fca765239ceb93d47b35934932", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-sig-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-3.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+\n+unsigned __int128\n+get_significand (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  return scalar_extract_sig (source);\n+}\n+\n+/* { dg-final { scan-assembler \"xsxsigqp\" } } */"}, {"sha": "0c2ec4739f56f557736f7427a253ef2c1c313460", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-sig-4.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-4.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+\n+unsigned __int128\n+get_significand (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  return __builtin_vec_scalar_extract_sig (source);\t/* { dg-error \"Builtin function __builtin_vsx_scalar_extract_sigq requires\" } */\n+}"}, {"sha": "19ca4c4a09ae216a8346252af59bf21c39d06bb3", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-sig-5.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-5.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test only runs on 32-bit configurations, producing a compiler\n+   error because the builtin requires 64 bits.  */\n+#include <altivec.h>\n+\n+unsigned __int128 /* { dg-error \"'__int128' is not supported on this target\" } */\n+get_significand (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  return __builtin_vec_scalar_extract_sig (source); /* { dg-error \"Builtin function __builtin_vec_scalar_extract_sig not supported in this compiler configuration\" } */\n+}"}, {"sha": "298268dadf42ceece89a065bdb8c038792a8f911", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-sig-6.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-6.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+unsigned long long int\n+get_significand (double *p)\n+{\n+  double source = *p;\n+\n+  return scalar_extract_sig (source);\n+}\n+\n+int\n+main ()\n+{\n+  double x = (double) (0x1100LL << 50);\n+  double z = (double) (0x1101LL << 37);\n+\n+  if (get_significand (&x) != 0x11000000000000ULL)\n+    abort ();\n+  if (get_significand (&z) != 0x11010000000000ULL)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "52081310ac502efa31fe26b23ee13a0abe2422dc", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-sig-7.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-7.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+unsigned __int128\n+get_significand (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  return scalar_extract_sig (source);\n+}\n+\n+int\n+main ()\n+{\n+  __ieee128 x = (__ieee128) (((__int128) 0x1100LL) << 114);\n+  __ieee128 z = (__ieee128) (((__int128) 0x1101LL) << 112);\n+\n+  /* 113 bits in the significand */\n+  /* our constant mantissas have 13 bits */\n+\n+  unsigned __int128 first_anticipated_result = ((__int128) 0x1100LL) << 100;\n+  unsigned __int128 second_anticipated_result = ((__int128) 0x1101LL) << 100;\n+\n+  if (get_significand (&x) != first_anticipated_result)\n+    abort ();\n+  if (get_significand (&z) != second_anticipated_result)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "e730556c5c913add30cc6cfc1d0eb1ab68d28707", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-insert-exp-10.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-10.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+\n+__ieee128\n+insert_exponent (__ieee128 *significand_p,\n+\t\t unsigned long long int *exponent_p)\n+{\n+  __ieee128 significand = *significand_p;\n+  unsigned long long int exponent = *exponent_p;\n+\n+  return __builtin_vec_scalar_insert_exp (significand, exponent); /* { dg-error \"Builtin function __builtin_vsx_scalar_insert_exp_qp requires\" } */\n+}"}, {"sha": "d44e6ccec5be3fbb7c6068ec678cc74850f451d0", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-insert-exp-11.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-11.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test only runs on 32-bit configurations, where a compiler error\n+   should be issued because this builtin is not available on\n+   32-bit configurations.  */\n+\n+#include <altivec.h>\n+\n+__ieee128\n+insert_exponent (__ieee128 *significand_p,\n+\t\t unsigned long long int *exponent_p)\n+{\n+  __ieee128 significand = *significand_p;\n+  unsigned long long int exponent = *exponent_p;\n+\n+  return scalar_insert_exp (significand, exponent); /* { dg-error \"Builtin function __builtin_vec_scalar_insert_exp not supported in this compiler configuration\" } */\n+}"}, {"sha": "b76c9c811450c20e3e82d0e62695b1abcd361c14", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-insert-exp-12.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-12.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+double\n+insert_exponent (unsigned long long int *significand_p,\n+\t\t unsigned long long int *exponent_p)\n+{\n+  unsigned long long int significand = *significand_p;\n+  unsigned long long int exponent = *exponent_p;\n+\n+  return scalar_insert_exp (significand, exponent);\n+}\n+\n+#define BIAS_FOR_DOUBLE_EXP 1023\n+\n+int\n+main ()\n+{\n+  unsigned long long int significand_1 = 0x18000000000000LL;\n+  unsigned long long int significand_2 = 0x1a000000000000LL;\n+  unsigned long long int exponent_1 = 62 + BIAS_FOR_DOUBLE_EXP;\n+  unsigned long long int exponent_2 = 49 + BIAS_FOR_DOUBLE_EXP;\n+\n+  double x = (double) (0x1800ULL << 50);\n+  double z = (double) (0x1a00ULL << 37);\n+\n+\n+  if (insert_exponent (&significand_1, &exponent_1) != x)\n+    abort ();\n+  if (insert_exponent (&significand_2, &exponent_2) != z)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "212563c84b1ca70d4a97333b3207eebbce7f2be8", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-insert-exp-13.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-13.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+double\n+insert_exponent (double *significand_p,\n+\t\t unsigned long long int *exponent_p)\n+{\n+  double significand = *significand_p;\n+  unsigned long long int exponent = *exponent_p;\n+\n+  return scalar_insert_exp (significand, exponent);\n+}\n+\n+#define BIAS_FOR_DOUBLE_EXP 1023\n+\n+int\n+main ()\n+{\n+  unsigned long long int significand_1 = 0x11000000000000LL;\n+  unsigned long long int significand_2 = 0x11010000000000LL;\n+  unsigned long long int exponent_1 = 62 + BIAS_FOR_DOUBLE_EXP;\n+  unsigned long long int exponent_2 = 49 + BIAS_FOR_DOUBLE_EXP;\n+\n+  double *significand_1_ptr = (double *) &significand_1;\n+  double *significand_2_ptr = (double *) &significand_2;\n+\n+\n+  double x = (double) (0x1100LL << 50);\n+  double z = (double) (0x1101LL << 37);\n+\n+  if (insert_exponent (significand_1_ptr, &exponent_1) != x)\n+    abort ();\n+  if (insert_exponent (significand_2_ptr, &exponent_2) != z)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "fc6c3817b98331bc35283618f1d55a6a9f81ecf6", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-insert-exp-14.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-14.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+__ieee128\n+insert_exponent (unsigned __int128 *significand_p,\n+\t\t unsigned long long int *exponent_p)\n+{\n+  unsigned __int128 significand = *significand_p;\n+  unsigned long long int exponent = *exponent_p;\n+\n+  return scalar_insert_exp (significand, exponent);\n+}\n+\n+#define BIAS_FOR_QUAD_EXP 16383\n+\n+int\n+main ()\n+{\n+  /* most-significant bit @13, shift it to position 113 */\n+  unsigned __int128 significand_1 = ((__int128) 0x1100) << 100;\n+  unsigned __int128 significand_2 = ((__int128) 0x1101) << 100;\n+  unsigned long long int exponent_1 = 126 + BIAS_FOR_QUAD_EXP;\n+  unsigned long long int exponent_2 = 124 + BIAS_FOR_QUAD_EXP;\n+\n+  __ieee128 x = (__ieee128) (((__int128) 0x1100LL) << 114);\n+  __ieee128 z = (__ieee128) (((__int128) 0x1101LL) << 112);\n+\n+  if (insert_exponent (&significand_1, &exponent_1) != x)\n+    abort ();\n+  if (insert_exponent (&significand_2, &exponent_2) != z)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "5843880d3822191aa0b2a8a8e3cb9089149f30dc", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-insert-exp-15.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-15.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+__ieee128\n+insert_exponent (__ieee128 *significand_p,\n+\t\t unsigned long long int *exponent_p)\n+{\n+  __ieee128 significand = *significand_p;\n+  unsigned long long int exponent = *exponent_p;\n+\n+  return scalar_insert_exp (significand, exponent);\n+}\n+\n+#define BIAS_FOR_QUAD_EXP 16383\n+\n+int\n+main ()\n+{\n+  /* most-significant bit @13, shift it to position 113 */\n+  unsigned __int128 significand_1 = ((unsigned __int128) 0x1100) << 100;\n+  unsigned __int128 significand_2 = ((unsigned __int128) 0x1101) << 100;\n+  unsigned long long int exponent_1 = 126 + BIAS_FOR_QUAD_EXP;\n+  unsigned long long int exponent_2 = 124 + BIAS_FOR_QUAD_EXP;\n+\n+  __ieee128 *significand_1_ptr = (__ieee128 *) &significand_1;\n+  __ieee128 *significand_2_ptr = (__ieee128 *) &significand_2;\n+\n+  __ieee128 x = (__ieee128) (((__int128) 0x1100LL) << 114);\n+  __ieee128 z = (__ieee128) (((__int128) 0x1101LL) << 112);\n+\n+  if (insert_exponent (significand_1_ptr, &exponent_1) != x)\n+    abort ();\n+  if (insert_exponent (significand_2_ptr, &exponent_2) != z)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "d896fa5d7b1945666993946f75ba2eede37c0d98", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-insert-exp-6.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-6.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+\n+__ieee128\n+insert_exponent (unsigned __int128 *significand_p,\n+\t\t unsigned long long int *exponent_p)\n+{\n+  unsigned __int128 significand = *significand_p;\n+  unsigned long long int exponent = *exponent_p;\n+\n+  return scalar_insert_exp (significand, exponent);\n+}\n+\n+/* { dg-final { scan-assembler \"xsiexpqp\" } } */"}, {"sha": "fe565c8f416ce2f40ea37345cf81e142c982d0e1", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-insert-exp-7.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-7.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+\n+__ieee128\n+insert_exponent (unsigned __int128 *significand_p,\n+\t\t unsigned long long int *exponent_p)\n+{\n+  unsigned __int128 significand = *significand_p;\n+  unsigned long long int exponent = *exponent_p;\n+\n+  return __builtin_vec_scalar_insert_exp (significand, exponent); /* { dg-error \"Builtin function __builtin_vsx_scalar_insert_exp_q requires\" } */\n+}"}, {"sha": "3a3f1c4aa8224daccde6f96aa39829b9d3716d72", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-insert-exp-8.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-8.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test only runs on 32-bit configurations, where a compiler error\n+   should be issued because this builtin is not available on\n+   32-bit configurations.  */\n+\n+#include <altivec.h>\n+\n+__ieee128\n+insert_exponent (unsigned __int128 *significand_p, /* { dg-error \"'__int128' is not supported on this target\" } */\n+\t\t unsigned long long int *exponent_p)\n+{\n+  unsigned __int128 significand = *significand_p;  /* { dg-error \"'__int128' is not supported on this target\" } */\n+  unsigned long long int exponent = *exponent_p;\n+\n+  return scalar_insert_exp (significand, exponent); /* { dg-error \"Builtin function __builtin_vec_scalar_insert_exp not supported in this compiler configuration\" } */\n+}"}, {"sha": "dca5c0ab5b7752c9fc4ed57f8cc01f5882f6585a", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-insert-exp-9.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-9.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+\n+__ieee128\n+insert_exponent (__ieee128 *significand_p,\n+\t\t unsigned long long int *exponent_p)\n+{\n+  __ieee128 significand = *significand_p;\n+  unsigned long long int exponent = *exponent_p;\n+\n+  return scalar_insert_exp (significand, exponent);\n+}\n+\n+/* { dg-final { scan-assembler \"xsiexpqp\" } } */"}, {"sha": "32fd8b1deeeff957c8613b6492d7133014d4c4fb", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-10.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-10.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdbool.h>\n+\n+bool\n+test_data_class (__ieee128 *p, const int condition_flag)\n+{\n+  __ieee128 source = *p;\n+\n+  return scalar_test_data_class (source, condition_flag); /* { dg-error \"argument 2 must be a 7-bit unsigned literal\" } */\n+}\n+"}, {"sha": "0065b77746a0517ea03060a0d107509941f69d42", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-11.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-11.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+#include <stdbool.h>\n+\n+bool\n+test_data_class (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  return __builtin_vec_scalar_test_data_class (source, 3); /* { dg-error \"Builtin function __builtin_vsx_scalar_test_data_class_qp requires\" } */\n+}"}, {"sha": "46c4fd2273531760142dcdc88be78b3c9b577d14", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-12.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-12.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+\n+bool\n+test_denormal (double *p)\n+{\n+  double source = *p;\n+\n+  /*\n+    0x40    Test for NaN\n+    0x20    Test for +Infinity\n+    0x10    Test for -Infinity\n+    0x08    Test for +Zero\n+    0x04    Test for -Zero\n+    0x02    Test for +Denormal\n+    0x01    Test for -Denormal\n+  */\n+  return scalar_test_data_class (source, 3);\n+}\n+\n+int\n+main ()\n+{\n+  /* A Denormal number has a biased exponent value of zero and a\n+   *   non-zero fraction value.  */\n+  double denormal_plus = scalar_insert_exp (0x0008000000000000ULL, 0x0ULL);\n+  double denormal_minus = scalar_insert_exp (0x8008000000000000ULL, 0x0ULL);\n+  double not_denormal = scalar_insert_exp (0x8000000000000000ULL, 1023ULL);\n+\n+  if (!test_denormal (&denormal_plus))\n+    abort ();\n+  if (!test_denormal (&denormal_minus))\n+    abort ();\n+  if (test_denormal (&not_denormal))\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "0beb66ae643c7e3b2b378081a1480902a2b64527", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-13.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-13.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+\n+bool\n+test_zero (float *p)\n+{\n+  float source = *p;\n+\n+  /*\n+    0x40    Test for NaN\n+    0x20    Test for +Infinity\n+    0x10    Test for -Infinity\n+    0x08    Test for +Zero\n+    0x04    Test for -Zero\n+    0x02    Test for +Denormal\n+    0x01    Test for -Denormal\n+  */\n+  return scalar_test_data_class (source, 12);\n+}\n+\n+int\n+main ()\n+{\n+  /* A Zero value has a biased exponent value of zero and a zero\n+   * fraction value.  The sign may be either positive or negative.  */\n+  unsigned int zero_plus_image = 0x0;\n+  unsigned int zero_minus_image = 0x80000000;\n+  unsigned int non_zero_image = 0x60000000;\n+\n+  float *zero_plus_p = (float *) &zero_plus_image;\n+  float *zero_minus_p = (float *) &zero_minus_image;\n+  float *not_zero_p = (float *) &non_zero_image;\n+\n+  if (!test_zero (zero_plus_p))\n+    abort ();\n+  if (!test_zero (zero_minus_p))\n+    abort ();\n+  if (test_zero (not_zero_p))\n+    abort ();\n+  return 0;\n+}"}, {"sha": "90dd64637c9ebf8b63037259e11eabc1dfcba4a4", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-14.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-14.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+\n+bool\n+test_nan (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  /*\n+    0x40    Test for NaN\n+    0x20    Test for +Infinity\n+    0x10    Test for -Infinity\n+    0x08    Test for +Zero\n+    0x04    Test for -Zero\n+    0x02    Test for +Denormal\n+    0x01    Test for -Denormal\n+  */\n+  return scalar_test_data_class (source, 0x40);\n+}\n+\n+int\n+main ()\n+{\n+  /* NaN is represented with the maximum biased exponent value and a\n+   *  non-zero fraction value. The sign bit ignored.  If the\n+   *  high-order bit of the fraction field is 0, then the NaN is a\n+   *  Signaling NaN.  Otherwise, it is a Quiet NaN.  */\n+  __int128 signal_significand = (__int128) 0xffffffff;\n+  __int128 quiet_significand = (((__int128) 0x1) << 112) | 0xffffffff;\n+  __int128 a_number_significand = (((__int128) 0x1) << 112);\n+  unsigned long long int nan_exponent = 0x7fff;\n+  unsigned long long int a_number_exponent = 16383;\n+\n+  __ieee128 signaling_nan =\n+    scalar_insert_exp (signal_significand, nan_exponent);\n+  __ieee128 quiet_nan =\n+    scalar_insert_exp (quiet_significand, nan_exponent);\n+  __ieee128 a_number =\n+    scalar_insert_exp (a_number_significand, a_number_exponent);\n+\n+  if (!test_nan (&signaling_nan))\n+    abort ();\n+  if (!test_nan (&quiet_nan))\n+    abort ();\n+  if (test_nan (&a_number))\n+    abort ();\n+  return 0;\n+}"}, {"sha": "5da7a3fe1b6b72b428898991a5f88ccf7682f4b2", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-15.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-15.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+\n+bool\n+test_infinity (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  /*\n+    0x40    Test for NaN\n+    0x20    Test for +Infinity\n+    0x10    Test for -Infinity\n+    0x08    Test for +Zero\n+    0x04    Test for -Zero\n+    0x02    Test for +Denormal\n+    0x01    Test for -Denormal\n+  */\n+  return scalar_test_data_class (source, 0x30);\n+}\n+\n+int\n+main ()\n+{\n+  /* Infinity is represented by a biased exponent value of:\n+   *   255 in single format\n+   *   2047 in double format\n+   *   32767 in ieee128 format\n+   * and a zero fraction value.  */\n+  __int128 plus_significand = (__int128) 0;\n+  __int128 minus_significand = ((__int128) 0x1) << 127;\n+  __int128 a_number_significand = (((__int128) 0x1) << 112);\n+\n+  unsigned long long int infinite_exponent = 0x7fff;\n+  unsigned long long int a_number_exponent = 16383;\n+\n+  __ieee128 plus_infinity =\n+    scalar_insert_exp (plus_significand, infinite_exponent);\n+  __ieee128 minus_infinity =\n+    scalar_insert_exp (minus_significand, infinite_exponent);\n+  __ieee128 a_number =\n+    scalar_insert_exp (a_number_significand, a_number_exponent);\n+\n+  if (!test_infinity (&plus_infinity))\n+    abort ();\n+  if (!test_infinity (&minus_infinity))\n+    abort ();\n+  if (test_infinity (&a_number))\n+    abort ();\n+  return 0;\n+}"}, {"sha": "25192506992c2ddb0413975796a397e04e4fa3b6", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-8.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-8.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdbool.h>\n+\n+bool\n+test_data_class (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  return scalar_test_data_class (source, 3);\n+}\n+\n+/* { dg-final { scan-assembler \"xststdcqp\" } } */"}, {"sha": "28c1e090ce5c3994df5c5e77252f1105f8e421f1", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-9.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-9.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdbool.h>\n+\n+bool\n+test_data_class (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  return scalar_test_data_class (source, 256);\t/* { dg-error \"argument 2 must be a 7-bit unsigned literal\" } */\n+}\n+"}, {"sha": "13fee32cdf8f120d747526fe2152b7b17c4299fa", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-neg-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-4.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdbool.h>\n+\n+bool\n+test_neg (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  return scalar_test_neg (source);\n+}\n+\n+/* { dg-final { scan-assembler \"xststdcqp\" } } */"}, {"sha": "041a4a1c820a594b656829aa9e6dd682c8cfa668", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-neg-5.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-5.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+#include <stdbool.h>\n+\n+bool\n+test_neg (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  return __builtin_vec_scalar_test_neg_qp (source); /* { dg-error \"Builtin function __builtin_vsx_scalar_test_neg_qp requires\" } */\n+}"}, {"sha": "497ac7b14aacc1b260d03b7a6afbf1a1c2ab78a2", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-neg-6.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-6.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+\n+bool\n+test_neg (double *p)\n+{\n+  double source = *p;\n+\n+  return scalar_test_neg (source);\n+}\n+\n+int\n+main ()\n+{\n+  double neg_number = (double) -1;\n+  double plus_number = (double) 1;\n+\n+  if (!test_neg (&neg_number))\n+    abort ();\n+  if (test_neg (&plus_number))\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "f7dfb5f9ed6c5d6fb6d4c237da19f0f859bc7782", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-neg-7.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-7.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+\n+bool\n+test_neg (float *p)\n+{\n+  float source = *p;\n+\n+  return scalar_test_neg (source);\n+}\n+\n+int\n+main ()\n+{\n+  float neg_number = (float) -1;\n+  float plus_number = (float) 1;\n+\n+  if (!test_neg (&neg_number))\n+    abort ();\n+  if (test_neg (&plus_number))\n+    abort ();\n+  return 0;\n+}"}, {"sha": "fff837ace706cd16df33ebe3708137ea50354289", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-neg-8.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-8.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+\n+bool\n+test_neg (__ieee128 *p)\n+{\n+  __ieee128 source = *p;\n+\n+  return scalar_test_neg (source);\n+}\n+\n+int\n+main ()\n+{\n+  __ieee128 neg_number = (__ieee128) -1;\n+  __ieee128 plus_number = (__ieee128) 1;\n+\n+  if (!test_neg (&neg_number))\n+    abort ();\n+  if (test_neg (&plus_number))\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "ab0e05e17c878234f2b8ee533c5d0950eb403f50", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-extract-exp-4.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-4.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+__vector unsigned int\n+get_exponents (__vector float *p)\n+{\n+  __vector float source = *p;\n+\n+  return vec_extract_exp (source);\n+}\n+\n+unsigned int bias_float_exp (int unbiased_exp)\n+{\n+  return (unsigned int) (unbiased_exp + 127);\n+}\n+\n+int\n+main ()\n+{\n+  __vector float argument;\n+  __vector unsigned int result;\n+\n+  argument[0] = (float) (0x1 << 10);\n+  argument[1] = (float) (0x1 << 9);\n+  argument[2] = (float) (0x1 << 8);\n+  argument[3] = (float) (0x1 << 7);\n+\n+  result = get_exponents (&argument);\n+  if ((result[0] != bias_float_exp (10)) ||\n+      (result[1] != bias_float_exp (9)) ||\n+      (result[2] != bias_float_exp (8)) || (result[3] != bias_float_exp (7)))\n+    abort();\n+  return 0;\n+}"}, {"sha": "1dabd6cf2c5b604ef2265c6f92a5f486471ed24a", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-extract-exp-5.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-5.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+__vector unsigned long long int\n+get_exponents (__vector double *p)\n+{\n+  __vector double source = *p;\n+\n+  return vec_extract_exp (source);\n+}\n+\n+unsigned long long int\n+bias_double_exp (long long int unbiased_exp)\n+{\n+  return (unsigned long long int) (unbiased_exp + 1023);\n+}\n+\n+int\n+main ()\n+{\n+  __vector double argument;\n+  __vector unsigned long long int result;\n+\n+  argument[0] = (double) (0x1 << 22);\n+  argument[1] = (double) (0x1 << 23);\n+\n+  result = get_exponents (&argument);\n+  if ((result[0] != bias_double_exp (22)) ||\n+      (result[1] != bias_double_exp (23)))\n+    abort();\n+  return 0;\n+}"}, {"sha": "6d4a9277f18691c1b55b9eeca0a2493c46e99e32", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-extract-sig-4.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-4.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+__vector unsigned int\n+get_significands (__vector float *p)\n+{\n+  __vector float source = *p;\n+\n+  return vec_extract_sig (source);\n+}\n+\n+int\n+main ()\n+{\n+  __vector float argument;\n+  __vector unsigned int result;\n+\n+  argument[0] = (float) (0x1234 << 10);\n+  argument[1] = (float) (0x4321 << 9);\n+  argument[2] = (float) (0xbabe << 8);\n+  argument[3] = (float) (0xcafe << 7);\n+\n+  result = get_significands (&argument);\n+  if ((result[0] != 0x91a000) || (result[1] != 0x864200) ||\n+      (result[2] != 0xbabe00) || (result[3] != 0xcafe00))\n+    abort();\n+  return 0;\n+}"}, {"sha": "ff2ca48798fff7016d41a11cd30c781d5adb12c2", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-extract-sig-5.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-5.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+__vector unsigned long long int\n+get_significands (__vector double *p)\n+{\n+  __vector double source = *p;\n+\n+  return vec_extract_sig (source);\n+}\n+\n+int\n+main ()\n+{\n+  __vector double argument;\n+  __vector unsigned long long int result;\n+\n+  argument[0] = (double) (0xbabeLL << 22);\n+  argument[1] = (double) (0xcafeLL << 23);\n+\n+  result = get_significands (&argument);\n+  if ((result[0] != (0xbabeULL << 37)) || (result[1] != (0xcafeULL << 37)))\n+    abort();\n+  return 0;\n+}\n+"}, {"sha": "020d09abe131825196e32e07af17615c974ce6f5", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-insert-exp-10.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-10.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+__vector float\n+make_floats (__vector float *significands_p,\n+\t     __vector unsigned int *exponents_p)\n+{\n+  __vector float significands = *significands_p;\n+  __vector unsigned int exponents = *exponents_p;\n+\n+  return vec_insert_exp (significands, exponents);\n+}\n+\n+int\n+main ()\n+{\n+  __vector unsigned int significands;\n+  __vector float *significands_p = (__vector float *) &significands;\n+  __vector unsigned int exponents;\n+  __vector float result;\n+\n+  /* 24 bits in significand, plus the sign bit: 0x80ffffff */\n+  significands[0] = 0x00800000;\t/*  1.0 */\n+  significands[1] = 0x00c00000;\t/*  1.5 */\n+  significands[2] = 0x80e00000;\t/* -1.75 */\n+  significands[3] = 0x80c00000;\t/* -1.5 */\n+\n+  exponents[0] = 127;\t\t/*  exp = 0: 1.0 */\n+  exponents[1] = 128;\t\t/*  exp = 1: 3.0 */\n+  exponents[2] = 129;\t\t/*  exp = 2: -7.0 */\n+  exponents[3] = 125;\t\t/* exp = -2: -0.375 */\n+\n+  result = make_floats (significands_p, &exponents);\n+  if ((result[0] != 1.0f) ||\n+      (result[1] != 3.0f) || (result[2] != -7.0f) || (result[3] != -0.375f))\n+    abort();\n+  return 0;\n+}\n+"}, {"sha": "5bf2c9cfdaa2f7209c7ed781da16e1400102baa7", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-insert-exp-11.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-11.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+__vector double\n+make_doubles (__vector double *significands_p,\n+\t      __vector unsigned long long int *exponents_p)\n+{\n+  __vector double significands = *significands_p;\n+  __vector unsigned long long int exponents = *exponents_p;\n+\n+  return vec_insert_exp (significands, exponents);\n+}\n+\n+int\n+main ()\n+{\n+  __vector unsigned long long int significands;\n+  __vector double *significands_p = (__vector double *) &significands;\n+  __vector unsigned long long int exponents;\n+  __vector double result;\n+\n+  /* 53 bits in significand, plus the sign bit: 0x8000_0000_0000_0000 */\n+  significands[0] = 0x0010000000000000;\t/*  1.0 */\n+  significands[1] = 0x801c000000000000;\t/* -1.75 */\n+\n+  exponents[0] = 1023;\t\t/*  exp = 0: 1.0 */\n+  exponents[1] = 1021;\t\t/* exp = -2: -0.4375 (7/16) */\n+\n+  result = make_doubles (significands_p, &exponents);\n+  if ((result[0] != 1.0) || (result[1] != -0.4375))\n+    abort();\n+  return 0;\n+}\n+"}, {"sha": "3f9bd988aade4233092209cfe0a9e1e9ee3af235", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-insert-exp-8.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-8.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+__vector float\n+make_floats (__vector unsigned int *significands_p,\n+\t     __vector unsigned int *exponents_p)\n+{\n+  __vector unsigned int significands = *significands_p;\n+  __vector unsigned int exponents = *exponents_p;\n+\n+  return vec_insert_exp (significands, exponents);\n+}\n+\n+int\n+main ()\n+{\n+  __vector unsigned int significands;\n+  __vector unsigned int exponents;\n+  __vector float result;\n+\n+  /* 24 bits in significand, plus the sign bit: 0x80ffffff */\n+  significands[0] = 0x00800000;\t/* 1.0 */\n+  significands[1] = 0x00c00000;\t/* 1.5 */\n+  significands[2] = 0x80e00000;\t/* -1.75 */\n+  significands[3] = 0x80c00000;\t/* -1.5 */\n+\n+  exponents[0] = 127;\t\t/*  exp = 0: 1.0 */\n+  exponents[1] = 128;\t\t/*  exp = 1: 3.0.0 */\n+  exponents[2] = 129;\t\t/*  exp = 2: -7.0 */\n+  exponents[3] = 125;\t\t/* exp = -2: -0.375 */\n+\n+  result = make_floats (&significands, &exponents);\n+  if ((result[0] != 1.0f) ||\n+      (result[1] != 3.0f) || (result[2] != -7.0f) || (result[3] != -0.375f))\n+    abort();\n+  return 0;\n+}\n+"}, {"sha": "5dc71951aeebbbf46b3a5c05c1d510c419d8ce3b", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-insert-exp-9.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-9.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+__vector double\n+make_doubles (__vector unsigned long long int *significands_p,\n+\t      __vector unsigned long long int *exponents_p)\n+{\n+  __vector unsigned long long int significands = *significands_p;\n+  __vector unsigned long long int exponents = *exponents_p;\n+\n+  return vec_insert_exp (significands, exponents);\n+}\n+\n+int\n+main ()\n+{\n+  __vector unsigned long long int significands;\n+  __vector unsigned long long int exponents;\n+  __vector double result;\n+\n+  /* 53 bits in significand, plus the sign bit: 0x8000_0000_0000_0000 */\n+  significands[0] = 0x0010000000000000;\t/*  1.0 */\n+  significands[1] = 0x801c000000000000;\t/* -1.75 */\n+\n+  exponents[0] = 1023;\t\t/*  exp = 0: 1.0 */\n+  exponents[1] = 1021;\t\t/* exp = -2: -0.4375 (7/16) */\n+\n+  result = make_doubles (&significands, &exponents);\n+  if ((result[0] != 1.0) || (result[1] != -0.4375))\n+    abort();\n+  return 0;\n+}\n+"}, {"sha": "636a30126126da6cb1e2c5f34fe03bd816f45f62", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-test-data-class-8.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-8.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,112 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+/* Flags to select tests:\n+    0x40    Test for NaN\n+    0x20    Test for +Infinity\n+    0x10    Test for -Infinity\n+    0x08    Test for +Zero\n+    0x04    Test for -Zero\n+    0x02    Test for +Denormal\n+    0x01    Test for -Denormal  */\n+\n+__vector bool int\n+test_nan (__vector float *p)\n+{\n+  __vector float source = *p;\n+\n+  return vec_test_data_class (source, 0x40);\n+}\n+\n+__vector bool int\n+test_infinity (__vector float *p)\n+{\n+  __vector float source = *p;\n+\n+  return vec_test_data_class (source, 0x30);\n+}\n+\n+__vector bool int\n+test_zero (__vector float *p)\n+{\n+  __vector float source = *p;\n+\n+  return vec_test_data_class (source, 0x0c);\n+}\n+\n+__vector bool int\n+test_denormal (__vector float *p)\n+{\n+  __vector float source = *p;\n+\n+  return vec_test_data_class (source, 0x03);\n+}\n+\n+float\n+float_scalar_insert_exp (unsigned int significand, unsigned int exponent)\n+{\n+  float result;\n+  unsigned int *result_as_uip = (unsigned int *) &result;\n+\n+  *result_as_uip = (significand & ~0x800000) | ((exponent & 0xff) << 23);\n+  return result;\n+}\n+\n+int\n+main ()\n+{\n+  __vector float argument;\n+  __vector bool result;\n+\n+  unsigned int signaling_significand = 0x00a00000;\n+  unsigned int quiet_significand = 0x00c00000;\n+  unsigned int one_significand = 0x00800000;\n+  unsigned int three_significand = 0x00c00000;\n+  unsigned int five_significand = 0x00a00000;\n+  unsigned int zero_significand = 0x00000000;\n+  unsigned int minus_zero_significand = 0x80000000;\n+\n+  /* A NaN is represented with the maximum biased exponent value and a\n+   *  non-zero fraction value. The sign bit ignored.  If the\n+   *  high-order bit of the fraction field is 0, then the NaN\n+   *  is a Signaling NaN.  Otherwise, it is a Quiet NaN.  */\n+  argument[0] = float_scalar_insert_exp (signaling_significand, 255);\n+  argument[1] = float_scalar_insert_exp (quiet_significand, 255);\n+  argument[2] = 1.0f;\n+  argument[3] = -0.07f;\n+  result = test_nan (&argument);\n+  if (!result[0] || !result[1] || result[2] || result[3])\n+    abort ();\n+\n+  /* Infinity is represented by a biased exponent value of:\n+   *   255 in single format\n+   *   2047 in double format\n+   * and a zero fraction value.  The difference between +infinity and\n+   * -infinity is the value of the sign bit.  */\n+  argument[2] = float_scalar_insert_exp (zero_significand, 255);\n+  argument[3] = float_scalar_insert_exp (minus_zero_significand, 255);\n+  result = test_infinity (&argument);\n+  if (result[0] || result[1] || !result[2] || !result[3])\n+    abort ();\n+\n+  /* A Zero value has a biased exponent value of zero and a zero\n+   *   fraction value.  The sign may be either positive or negative.  */\n+  argument[1] = float_scalar_insert_exp (minus_zero_significand, 0);\n+  argument[2] = float_scalar_insert_exp (zero_significand, 0);\n+  result = test_zero (&argument);\n+  if (result[0] || !result[1] || !result[2] || result[3])\n+    abort ();\n+\n+  /* A Denormal number has a biased exponent value of zero and a\n+   *   non-zero fraction value.  */\n+  argument[0] = float_scalar_insert_exp (five_significand, 0);\n+  argument[3] = float_scalar_insert_exp (three_significand, 0);\n+  result = test_denormal (&argument);\n+  if (!result[0] || result[1] || result[2] || !result[3])\n+    abort ();\n+}"}, {"sha": "5ccac12df8701777c534b5c31ed17c6a90e5b5b2", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-test-data-class-9.c", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b70bb05bd189a80c79225f7056441d7e3e1c0b6c/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-9.c?ref=b70bb05bd189a80c79225f7056441d7e3e1c0b6c", "patch": "@@ -0,0 +1,125 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+#include <stdlib.h>\n+\n+/* Flags to select tests:\n+    0x40    Test for NaN\n+    0x20    Test for +Infinity\n+    0x10    Test for -Infinity\n+    0x08    Test for +Zero\n+    0x04    Test for -Zero\n+    0x02    Test for +Denormal\n+    0x01    Test for -Denormal  */\n+\n+__vector bool long long int\n+test_nan (__vector double *p)\n+{\n+  __vector double source = *p;\n+\n+  return vec_test_data_class (source, 0x40);\n+}\n+\n+__vector bool long long int\n+test_infinity (__vector double *p)\n+{\n+  __vector double source = *p;\n+\n+  return vec_test_data_class (source, 0x30);\n+}\n+\n+__vector bool long long int\n+test_zero (__vector double *p)\n+{\n+  __vector double source = *p;\n+\n+  return vec_test_data_class (source, 0x0c);\n+}\n+\n+__vector bool long long int\n+test_denormal (__vector double *p)\n+{\n+  __vector double source = *p;\n+\n+  return vec_test_data_class (source, 0x03);\n+}\n+\n+int\n+main ()\n+{\n+  __vector double special_argument;\n+  __vector double nonspecial_argument;\n+  __vector bool long long int result;\n+\n+  unsigned long long int signaling_significand =\n+    0x0017000000000000ULL;\n+  unsigned long long int quiet_significand =\n+    0x001f000000000000ULL;\n+  unsigned long long int one_significand =\n+    0x0010000000000000ULL;\n+  unsigned long long int three_significand =\n+    0x0018000000000000ULL;\n+  unsigned long long int five_significand =\n+    0x0014000000000000ULL;\n+  unsigned long long int zero_significand =\n+    0x0000000000000000ULL;\n+  unsigned long long int minus_zero_significand =\n+    0x8000000000000000ULL;\n+\n+  nonspecial_argument[0] = -3.825;\n+  nonspecial_argument[1] = 3.14159;\n+\n+  /* A NaN is represented with the maximum biased exponent value and a\n+   *  non-zero fraction value. The sign bit ignored.  If the\n+   *  high-order bit of the fraction field is 0, then the NaN\n+   *  is a Signaling NaN.  Otherwise, it is a Quiet NaN.  */\n+  special_argument[0] = scalar_insert_exp (signaling_significand, 2047);\n+  special_argument[1] = scalar_insert_exp (quiet_significand, 2047);\n+  result = test_nan (&special_argument);\n+  if (!result[0] || !result[1])\n+    abort ();\n+  result = test_nan (&nonspecial_argument);\n+  if (result[0] || result[1])\n+    abort ();\n+\n+  /* Infinity is represented by a biased exponent value of:\n+   *   255 in single format\n+   *   2047 in double format\n+   * and a zero fraction value.  The difference between +infinity and\n+   * -infinity is the value of the sign bit.  */\n+  special_argument[0] = scalar_insert_exp (zero_significand, 2047);\n+  special_argument[1] = scalar_insert_exp (minus_zero_significand, 2047);\n+  result = test_infinity (&special_argument);\n+  if (!result[0] || !result[1])\n+    abort ();\n+  result = test_infinity (&nonspecial_argument);\n+  if (result[0] || result[1])\n+    abort ();\n+\n+  /* A Zero value has a biased exponent value of zero and a zero\n+   *   fraction value.  The sign may be either positive or negative.  */\n+  special_argument[0] = scalar_insert_exp (minus_zero_significand, 0);\n+  special_argument[1] = scalar_insert_exp (zero_significand, 0);\n+  result = test_zero (&special_argument);\n+  if (!result[0] || !result[1])\n+    abort ();\n+  result = test_zero (&nonspecial_argument);\n+  if (result[0] || result[1])\n+    abort ();\n+\n+  /* A Denormal number has a biased exponent value of zero and a\n+   *   non-zero fraction value.  */\n+  special_argument[0] = scalar_insert_exp (five_significand, 0);\n+  special_argument[1] = scalar_insert_exp (three_significand, 0);\n+  result = test_denormal (&special_argument);\n+  if (!result[0] || !result[1])\n+    abort ();\n+  result = test_denormal (&nonspecial_argument);\n+  if (result[0] || result[1])\n+    abort ();\n+  return 0;\n+}\n+"}]}