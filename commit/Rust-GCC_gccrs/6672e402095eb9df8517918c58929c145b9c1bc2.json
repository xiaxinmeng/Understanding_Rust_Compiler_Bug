{"sha": "6672e402095eb9df8517918c58929c145b9c1bc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY3MmU0MDIwOTVlYjlkZjg1MTc5MThjNTg5MjljMTQ1YjljMWJjMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-13T13:11:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-13T13:11:30Z"}, "message": "[multiple changes]\n\n2015-11-13  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch6.adb (Check_Private_Overriding): Change\n\tname of Parent_Is_Private to be Overrides_Private_Part_Op,\n\tand use Unit_Declaration_Node.\n\n2015-11-13  Bob Duff  <duff@adacore.com>\n\n\t* sinfo.ads: Minor comment fix.\n\t* sem_ch6.adb: Minor reformatting.\n\n2015-11-13  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* tracebak.c: Do not use the GCC Unwinder to retrieve traceback\n\tfor x86_64-vx7.\n\n2015-11-13  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* init.c [Darwin/arm64]: Fix typo.\n\t* sigtramp-armios.c: Remove.\n\t* sigtramp-ios.c: New file.\n\n2015-11-13  Doug Rupp  <rupp@adacore.com>\n\n\t* s-stchop-vxworks.adb (Set_Stack_Limit_For_Current_Task): Set stack\n\tlimit to 12000 decimal vice 12000 hexadecimal.\n\nFrom-SVN: r230315", "tree": {"sha": "b2c0b873dc782dd0985edac23610f821beb0f0c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2c0b873dc782dd0985edac23610f821beb0f0c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6672e402095eb9df8517918c58929c145b9c1bc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6672e402095eb9df8517918c58929c145b9c1bc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6672e402095eb9df8517918c58929c145b9c1bc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6672e402095eb9df8517918c58929c145b9c1bc2/comments", "author": null, "committer": null, "parents": [{"sha": "bc38dbb42271b6bdbc5e2e55200266aa5917f4bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc38dbb42271b6bdbc5e2e55200266aa5917f4bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc38dbb42271b6bdbc5e2e55200266aa5917f4bd"}], "stats": {"total": 439, "additions": 309, "deletions": 130}, "files": [{"sha": "1fa08b96111525c181c68d3149e3b5c903f3851a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6672e402095eb9df8517918c58929c145b9c1bc2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6672e402095eb9df8517918c58929c145b9c1bc2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6672e402095eb9df8517918c58929c145b9c1bc2", "patch": "@@ -1,3 +1,30 @@\n+2015-11-13  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch6.adb (Check_Private_Overriding): Change\n+\tname of Parent_Is_Private to be Overrides_Private_Part_Op,\n+\tand use Unit_Declaration_Node.\n+\n+2015-11-13  Bob Duff  <duff@adacore.com>\n+\n+\t* sinfo.ads: Minor comment fix.\n+\t* sem_ch6.adb: Minor reformatting.\n+\n+2015-11-13  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* tracebak.c: Do not use the GCC Unwinder to retrieve traceback\n+\tfor x86_64-vx7.\n+\n+2015-11-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* init.c [Darwin/arm64]: Fix typo.\n+\t* sigtramp-armios.c: Remove.\n+\t* sigtramp-ios.c: New file.\n+\n+2015-11-13  Doug Rupp  <rupp@adacore.com>\n+\n+\t* s-stchop-vxworks.adb (Set_Stack_Limit_For_Current_Task): Set stack\n+\tlimit to 12000 decimal vice 12000 hexadecimal.\n+\n 2015-11-13  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch9.adb, exp_fixd.adb, exp_util.adb, g-debpoo.adb,"}, {"sha": "4e95614a2f50e2b18e434e804c2fe2f0c6cde764", "filename": "gcc/ada/init.c", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6672e402095eb9df8517918c58929c145b9c1bc2/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6672e402095eb9df8517918c58929c145b9c1bc2/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=6672e402095eb9df8517918c58929c145b9c1bc2", "patch": "@@ -2381,13 +2381,14 @@ __gnat_adjust_context_for_raise (int signo ATTRIBUTE_UNUSED,\n       uc->uc_mcontext->__ss.__rdx = t;\n     }\n #elif defined(__arm64__)\n+  /* Even though the CFI is marked as a signal frame, we need this.  */\n   ucontext_t *uc = (ucontext_t *)ucontext;\n   uc->uc_mcontext->__ss.__pc++;\n #endif\n }\n \n static void\n-__gnat_map_signal (int sig, siginfo_t *si, void *ucontext ATTRIBUTE_UNUSED)\n+__gnat_map_signal (int sig, siginfo_t *si, void *mcontext ATTRIBUTE_UNUSED)\n {\n   struct Exception_Data *exception;\n   const char *msg;\n@@ -2398,6 +2399,17 @@ __gnat_map_signal (int sig, siginfo_t *si, void *ucontext ATTRIBUTE_UNUSED)\n     case SIGBUS:\n       if (__gnat_is_stack_guard ((unsigned long)si->si_addr))\n \t{\n+#ifdef __arm64__\n+\t  /* ??? This is a kludge to make stack checking work.  The problem is\n+\t     that the trampoline doesn't restore LR and, consequently, doesn't\n+\t     make it possible to unwind past an interrupted frame which hasn\"t\n+\t     saved LR on the stack yet.  Therefore, for probes in the prologue\n+\t     (32-bit probes as opposed to standard 64-bit probes), we make the\n+\t     unwinder skip the not-yet-established frame altogether.  */\n+\t  mcontext_t mc = (mcontext_t)mcontext;\n+\t  if (!(*(unsigned int *)(mc->__ss.__pc-1) & ((unsigned int)1 << 30)))\n+\t    mc->__ss.__pc = mc->__ss.__lr;\n+#endif\n \t  exception = &storage_error;\n \t  msg = \"stack overflow\";\n \t}\n@@ -2409,7 +2421,7 @@ __gnat_map_signal (int sig, siginfo_t *si, void *ucontext ATTRIBUTE_UNUSED)\n \n       /* Reset the use of alt stack, so that the alt stack will be used\n \t for the next signal delivery.\n-         The stack can't be used in case of stack checking.  */\n+\t The stack can't be used in case of stack checking.  */\n       syscall (SYS_sigreturn, NULL, UC_RESET_ALT_STACK);\n       break;\n \n@@ -2432,17 +2444,7 @@ __gnat_error_handler (int sig, siginfo_t *si, void *ucontext)\n   __gnat_adjust_context_for_raise (sig, ucontext);\n \n #ifdef __arm64__\n-  /* ??? Temporary kludge to make stack checking work.  The problem is\n-     that the trampoline doesn't restore LR and, consequently, doesn't\n-     make it possible to unwind past an interrupted frame which hasn\"t\n-     saved LR on the stack yet.  */\n-  if (__gnat_is_stack_guard ((unsigned long)si->si_addr))\n-    {\n-      ucontext_t *uc = (ucontext_t *)ucontext;\n-      uc->uc_mcontext->__ss.__pc = uc->uc_mcontext->__ss.__lr;\n-    }\n-\n-    /* Use a trampoline so that the unwinder won't see the signal frame.  */\n+  /* Use a trampoline so that the unwinder won't see the signal frame.  */\n   __gnat_sigtramp (sig, (void *)si, ucontext,\n \t\t   (__sigtramphandler_t *)&__gnat_map_signal);\n #else"}, {"sha": "24de94d91af5fb9bf2f7382adf64e858f9e99185", "filename": "gcc/ada/s-stchop-vxworks.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6672e402095eb9df8517918c58929c145b9c1bc2/gcc%2Fada%2Fs-stchop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6672e402095eb9df8517918c58929c145b9c1bc2/gcc%2Fada%2Fs-stchop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stchop-vxworks.adb?ref=6672e402095eb9df8517918c58929c145b9c1bc2", "patch": "@@ -133,11 +133,11 @@ package body System.Stack_Checking.Operations is\n       if Stack_Grows_Down then\n          Limit :=\n            Stack_Info.Base - Storage_Offset (Stack_Info.Size) +\n-             Storage_Offset'(16#12_000#);\n+             Storage_Offset'(12_000);\n       else\n          Limit :=\n            Stack_Info.Base + Storage_Offset (Stack_Info.Size) -\n-             Storage_Offset'(16#12_000#);\n+             Storage_Offset'(12_000);\n       end if;\n \n       Stack_Limit := Limit;"}, {"sha": "3eb22f67ee574d2ae03b8df29d7dc15976f9a6f4", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6672e402095eb9df8517918c58929c145b9c1bc2/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6672e402095eb9df8517918c58929c145b9c1bc2/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=6672e402095eb9df8517918c58929c145b9c1bc2", "patch": "@@ -8753,16 +8753,38 @@ package body Sem_Ch6 is\n          ------------------------------\n \n          procedure Check_Private_Overriding (T : Entity_Id) is\n+            function Overrides_Private_Part_Op return Boolean;\n+            --  This detects the special case where the overriding subprogram\n+            --  is overriding a subprogram that was declared in the same\n+            --  private part. That case is illegal by 3.9.3(10).\n \n             function Overrides_Visible_Function\n               (Partial_View : Entity_Id) return Boolean;\n             --  True if S overrides a function in the visible part. The\n             --  overridden function could be explicitly or implicitly declared.\n \n-            function Parent_Is_Private return Boolean;\n-            --  This detects the special case where the overriding subprogram\n-            --  is overriding a subprogram that was declared in the same\n-            --  private part. That case is illegal by 3.9.3(10).\n+            -------------------------------\n+            -- Overrides_Private_Part_Op --\n+            -------------------------------\n+\n+            function Overrides_Private_Part_Op return Boolean is\n+               Over_Decl : constant Node_Id :=\n+                             Unit_Declaration_Node (Overridden_Operation (S));\n+               Subp_Decl : constant Node_Id := Unit_Declaration_Node (S);\n+\n+            begin\n+               pragma Assert (Is_Overriding);\n+               pragma Assert\n+                 (Nkind (Over_Decl) = N_Abstract_Subprogram_Declaration);\n+               pragma Assert\n+                 (Nkind (Subp_Decl) = N_Abstract_Subprogram_Declaration);\n+\n+               return In_Same_List (Over_Decl, Subp_Decl);\n+            end Overrides_Private_Part_Op;\n+\n+            --------------------------------\n+            -- Overrides_Visible_Function --\n+            --------------------------------\n \n             function Overrides_Visible_Function\n               (Partial_View : Entity_Id) return Boolean\n@@ -8802,14 +8824,6 @@ package body Sem_Ch6 is\n                return False;\n             end Overrides_Visible_Function;\n \n-            function Parent_Is_Private return Boolean is\n-               S_Decl : constant Node_Id := Parent (Parent (S));\n-               Overridden_Decl : constant Node_Id :=\n-                 Parent (Parent (Overridden_Operation (S)));\n-            begin\n-               return In_Same_List (Overridden_Decl, S_Decl);\n-            end Parent_Is_Private;\n-\n          --  Start of processing for Check_Private_Overriding\n \n          begin\n@@ -8822,10 +8836,11 @@ package body Sem_Ch6 is\n                  and then Is_Abstract_Subprogram (S)\n                  and then (not Is_Overriding\n                              or else not Is_Abstract_Subprogram (E)\n-                             or else Parent_Is_Private)\n+                             or else Overrides_Private_Part_Op)\n                then\n-                  Error_Msg_N (\"abstract subprograms must be visible \"\n-                                 & \"(RM 3.9.3(10))!\", S);\n+                  Error_Msg_N\n+                    (\"abstract subprograms must be visible (RM 3.9.3(10))!\",\n+                     S);\n \n                elsif Ekind (S) = E_Function then\n                   declare"}, {"sha": "3206256ac595f20da85b24411d8debb7ef617e77", "filename": "gcc/ada/sigtramp-armios.c", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc38dbb42271b6bdbc5e2e55200266aa5917f4bd/gcc%2Fada%2Fsigtramp-armios.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc38dbb42271b6bdbc5e2e55200266aa5917f4bd/gcc%2Fada%2Fsigtramp-armios.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-armios.c?ref=bc38dbb42271b6bdbc5e2e55200266aa5917f4bd", "patch": "@@ -1,98 +0,0 @@\n-/****************************************************************************\n- *                                                                          *\n- *                         GNAT COMPILER COMPONENTS                         *\n- *                                                                          *\n- *                             S I G T R A M P                              *\n- *                                                                          *\n- *                         Asm Implementation File                          *\n- *                                                                          *\n- *           Copyright (C) 2015, Free Software Foundation, Inc.             *\n- *                                                                          *\n- * GNAT is free software;  you can  redistribute it  and/or modify it under *\n- * terms of the  GNU General Public License as published  by the Free Soft- *\n- * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n- * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n- * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n- * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n- *                                                                          *\n- * As a special exception under Section 7 of GPL version 3, you are granted *\n- * additional permissions described in the GCC Runtime Library Exception,   *\n- * version 3.1, as published by the Free Software Foundation.               *\n- *                                                                          *\n- * In particular,  you can freely  distribute your programs  built with the *\n- * GNAT Pro compiler, including any required library run-time units,  using *\n- * any licensing terms  of your choosing.  See the AdaCore Software License *\n- * for full details.                                                        *\n- *                                                                          *\n- * GNAT was originally developed  by the GNAT team at  New York University. *\n- * Extensive contributions were provided by Ada Core Technologies Inc.      *\n- *                                                                          *\n- ****************************************************************************/\n-\n-/**************************************************\n- * ARM-IOS version of the __gnat_sigtramp service *\n- **************************************************/\n-\n-#include <sys/ucontext.h>\n-\n-#include \"sigtramp.h\"\n-/* See sigtramp.h for a general explanation of functionality.  */\n-\n-/* -----------------------------------------\n-   -- Protypes for our internal asm stubs --\n-   -----------------------------------------\n-\n-   The registers are expected to be at SIGCONTEXT + OFFSET (reference to the\n-   machine context structure).  Even though our symbols will remain local, the\n-   prototype claims \"extern\" and not \"static\" to prevent compiler complaints\n-   about a symbol used but never defined.  */\n-\n-/* sigtramp stub providing unwind info for common registers.  */\n-\n-extern void __gnat_sigtramp_common\n-  (int signo, void *siginfo, void *sigcontext,\n-   __sigtramphandler_t * handler);\n-\n-void __gnat_sigtramp (int signo, void *si, void *ucontext,\n-                      __sigtramphandler_t * handler)\n-     __attribute__((optimize(2)));\n-\n-void __gnat_sigtramp (int signo, void *si, void *ucontext,\n-                      __sigtramphandler_t * handler)\n-{\n-  mcontext_t mcontext = ((ucontext_t *) ucontext)->uc_mcontext;\n-\n-  __gnat_sigtramp_common (signo, si, mcontext, handler);\n-}\n-\n-asm(\"\\n\"\n-\"\t.section\t__TEXT,__text,regular,pure_instructions\\n\"\n-\"\t.align  2\\n\"\n-\"___gnat_sigtramp_common:\\n\"\n-\"\t.cfi_startproc\\n\"\n-\t/* Restore callee saved registers.  */\n-\"\tldp\tx19, x20, [x2, #168]\\n\"\n-\"\tldp\tx21, x22, [x2, #184]\\n\"\n-\"\tldp\tx23, x24, [x2, #200]\\n\"\n-\"\tldp\tx25, x26, [x2, #216]\\n\"\n-\"\tldp\tx27, x28, [x2, #232]\\n\"\n-\"\tldp\tq8, q9, [x2, #416]\\n\"\n-\"\tldp\tq10, q11, [x2, #448]\\n\"\n-\"\tldp\tq12, q13, [x2, #480]\\n\"\n-\"\tldp\tq14, q15, [x2, #512]\\n\"\n-\t/* Read FP from mcontext.  */\n-\"\tldr\tfp, [x2, #248]\\n\"\n-\t/* Read SP and PC from mcontext.  */\n-\"\tldp\tx6, lr, [x2, #264]\\n\"\n-\"\tmov\tsp, x6\\n\"\n-\t/* Create a minimal frame.  */\n-\"\tstp\tfp, lr, [sp, #-16]!\\n\"\n-\"\t.cfi_def_cfa_offset 16\\n\"\n-\"\t.cfi_offset\t30, -8\\n\"\n-\"\t.cfi_offset\t29, -16\\n\"\n-\"\tblr\tx3\\n\"\n-\t/* Release our frame and return (should never get here!).  */\n-\"\tldp\tfp, lr, [sp, #16]\\n\"\n-\"\tret\\n\"\n-\"\t.cfi_endproc\\n\"\n-);"}, {"sha": "36c4f8717919bcd5bfea562eec28d33e640fb895", "filename": "gcc/ada/sigtramp-ios.c", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6672e402095eb9df8517918c58929c145b9c1bc2/gcc%2Fada%2Fsigtramp-ios.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6672e402095eb9df8517918c58929c145b9c1bc2/gcc%2Fada%2Fsigtramp-ios.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-ios.c?ref=6672e402095eb9df8517918c58929c145b9c1bc2", "patch": "@@ -0,0 +1,233 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                             S I G T R A M P                              *\n+ *                                                                          *\n+ *                         Asm Implementation File                          *\n+ *                                                                          *\n+ *           Copyright (C) 2015, Free Software Foundation, Inc.             *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n+ *                                                                          *\n+ * As a special exception under Section 7 of GPL version 3, you are granted *\n+ * additional permissions described in the GCC Runtime Library Exception,   *\n+ * version 3.1, as published by the Free Software Foundation.               *\n+ *                                                                          *\n+ * In particular,  you can freely  distribute your programs  built with the *\n+ * GNAT Pro compiler, including any required library run-time units,  using *\n+ * any licensing terms  of your choosing.  See the AdaCore Software License *\n+ * for full details.                                                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/****************************************************\n+ * ARM64/IOS version of the __gnat_sigtramp service *\n+ ****************************************************/\n+\n+#include <sys/ucontext.h>\n+\n+#include \"sigtramp.h\"\n+/* See sigtramp.h for a general explanation of functionality.  */\n+\n+/* ----------------------\n+   -- General comments --\n+   ----------------------\n+\n+   Unfortunately the libunwind library used on this platform comes with severe\n+   limitations that make the implementation convoluted:\n+\n+     1. At each step, the stack pointer register SP is restored with the CFA.\n+\tThis makes it impossible to set the CFA to an arbitrary value, for\n+\texample to the address of the context saved on the stack, which means\n+\tthat the simple CFI directives cannot be used for the registers.\n+\n+     2. For the ARM64 architecture (and only it), DWARF expressions are not\n+\tsupported to compute the CFA.  Only DW_CFA_def_cfa is supported, which\n+\tmeans that the CFA (modulo offset) must be loaded into a register.\n+\n+     3. The return column cannot be changed (30 for the ARM64 architecture).\n+\tSince column 30 is that of the LR register, this makes it impossible\n+\tto restore both the LR register and the PC.\n+\n+   Therefore we need 2 distinct call-saved registers in the trampoline and\n+   we resort to manual encoding of CFI byte sequences.  */\n+\n+/* -----------------------------------------\n+   -- Protypes for our internal asm stubs --\n+   -----------------------------------------\n+\n+   Even though our symbols will remain local, the prototype claims \"extern\"\n+   and not \"static\" to prevent compiler complaints about a symbol used but\n+   never defined.  */\n+\n+/* sigtramp stub providing unwind info for common registers.  */\n+\n+extern void __gnat_sigtramp_common\n+  (int signo, void *siginfo, void *sigcontext,\n+   __sigtramphandler_t * handler);\n+\n+void __gnat_sigtramp (int signo, void *si, void *ucontext,\n+                      __sigtramphandler_t * handler)\n+     __attribute__((optimize(2)));\n+\n+void __gnat_sigtramp (int signo, void *si, void *ucontext,\n+                      __sigtramphandler_t * handler)\n+{\n+  mcontext_t mcontext = ((ucontext_t *) ucontext)->uc_mcontext;\n+\n+  __gnat_sigtramp_common (signo, si, mcontext, handler);\n+}\n+\n+/* asm string construction helpers.  */\n+\n+#define STR(TEXT) #TEXT\n+/* stringify expanded TEXT, surrounding it with double quotes.  */\n+\n+#define S(E) STR(E)\n+/* stringify E, which will resolve as text but may contain macros\n+   still to be expanded.  */\n+\n+/* asm (TEXT) outputs <tab>TEXT. These facilitate the output of\n+   multiline contents:  */\n+#define TAB(S) \"\\t\" S\n+#define CR(S)  S \"\\n\"\n+\n+#undef TCR\n+#define TCR(S) TAB(CR(S))\n+\n+/* Offset in uc_mcontext of the __ss structure containing the registers.  */\n+#define UC_MCONTEXT_SS 16\n+\n+#define CFA_REG  19\n+#define BASE_REG 20\n+\n+#define DW_CFA_def_cfa    0x0c\n+#define DW_CFA_expression 0x10\n+\n+#define DW_OP_breg(n)     0x70+(n)\n+\n+#define REG_REGNO_GR(n)   n\n+#define REG_REGNO_PC      30\n+\n+/* The first byte of the SLEB128 value of the offset.  */\n+#define REG_OFFSET_GR(n)         (UC_MCONTEXT_SS + n * 8)\n+#define REG_OFFSET_LONG_GR(n)    (UC_MCONTEXT_SS + n * 8 + 128)\n+#define REG_OFFSET_LONG128_GR(n) (UC_MCONTEXT_SS + (n - 16) * 8 + 128)\n+#define REG_OFFSET_LONG256_GR(n) (UC_MCONTEXT_SS + (n - 32) * 8 + 128)\n+\n+#define REG_OFFSET_LONG256_PC    REG_OFFSET_LONG256_GR(32)\n+\n+#define CFI_DEF_CFA \\\n+  TCR(\".cfi_def_cfa \" S(CFA_REG) \", 0\")\n+\n+/* We need 4 variants depending on the offset: 0+, 64+, 128+, 256+.  */\n+#define COMMON_CFI(REG) \\\n+  \".cfi_escape \" S(DW_CFA_expression) \",\" S(REG_REGNO_##REG) \",2,\" \\\n+  S(DW_OP_breg(BASE_REG)) \",\" S(REG_OFFSET_##REG)\n+\n+#define COMMON_LONG_CFI(REG) \\\n+  \".cfi_escape \" S(DW_CFA_expression) \",\" S(REG_REGNO_##REG) \",3,\" \\\n+  S(DW_OP_breg(BASE_REG)) \",\" S(REG_OFFSET_LONG_##REG) \",0\"\n+\n+#define COMMON_LONG128_CFI(REG) \\\n+  \".cfi_escape \" S(DW_CFA_expression) \",\" S(REG_REGNO_##REG) \",3,\" \\\n+  S(DW_OP_breg(BASE_REG)) \",\" S(REG_OFFSET_LONG128_##REG) \",1\"\n+\n+#define COMMON_LONG256_CFI(REG) \\\n+  \".cfi_escape \" S(DW_CFA_expression) \",\" S(REG_REGNO_##REG) \",3,\" \\\n+  S(DW_OP_breg(BASE_REG)) \",\" S(REG_OFFSET_LONG256_##REG) \",2\"\n+\n+#define CFI_COMMON_REGS \\\n+  CR(\"# CFI for common registers\\n\") \\\n+  TCR(COMMON_CFI(GR(0)))  \\\n+  TCR(COMMON_CFI(GR(1)))  \\\n+  TCR(COMMON_CFI(GR(2)))  \\\n+  TCR(COMMON_CFI(GR(3)))  \\\n+  TCR(COMMON_CFI(GR(4)))  \\\n+  TCR(COMMON_CFI(GR(5)))  \\\n+  TCR(COMMON_LONG_CFI(GR(6)))  \\\n+  TCR(COMMON_LONG_CFI(GR(7)))  \\\n+  TCR(COMMON_LONG_CFI(GR(8)))  \\\n+  TCR(COMMON_LONG_CFI(GR(9)))  \\\n+  TCR(COMMON_LONG_CFI(GR(10))) \\\n+  TCR(COMMON_LONG_CFI(GR(11))) \\\n+  TCR(COMMON_LONG_CFI(GR(12))) \\\n+  TCR(COMMON_LONG_CFI(GR(13))) \\\n+  TCR(COMMON_LONG128_CFI(GR(14))) \\\n+  TCR(COMMON_LONG128_CFI(GR(15))) \\\n+  TCR(COMMON_LONG128_CFI(GR(16))) \\\n+  TCR(COMMON_LONG128_CFI(GR(17))) \\\n+  TCR(COMMON_LONG128_CFI(GR(18))) \\\n+  TCR(COMMON_LONG128_CFI(GR(19))) \\\n+  TCR(COMMON_LONG128_CFI(GR(20))) \\\n+  TCR(COMMON_LONG128_CFI(GR(21))) \\\n+  TCR(COMMON_LONG128_CFI(GR(22))) \\\n+  TCR(COMMON_LONG128_CFI(GR(23))) \\\n+  TCR(COMMON_LONG128_CFI(GR(24))) \\\n+  TCR(COMMON_LONG128_CFI(GR(25))) \\\n+  TCR(COMMON_LONG128_CFI(GR(26))) \\\n+  TCR(COMMON_LONG128_CFI(GR(27))) \\\n+  TCR(COMMON_LONG128_CFI(GR(28))) \\\n+  TCR(COMMON_LONG128_CFI(GR(29))) \\\n+  TCR(COMMON_LONG256_CFI(PC)) \\\n+\n+/* Trampoline body block\n+   ---------------------  */\n+\n+#define SIGTRAMP_BODY \\\n+  TCR(\"stp fp, lr, [sp, #-32]!\") \\\n+  TCR(\"stp x\" S(CFA_REG) \", x\" S(BASE_REG) \", [sp, #16]\") \\\n+  TCR(\"mov fp, sp\") \\\n+  TCR(\"# Load the saved value of the stack pointer as CFA\") \\\n+  TCR(\"ldr x\" S(CFA_REG) \", [x2, #\" S(REG_OFFSET_GR(31)) \"]\") \\\n+  TCR(\"# Use x\" S(BASE_REG) \" as base register for the CFI\") \\\n+  TCR(\"mov x\" S(BASE_REG) \", x2\") \\\n+  TCR(\"# Call the handler\") \\\n+  TCR(\"blr x3\") \\\n+  TCR(\"# Release our frame and return (should never get here!).\") \\\n+  TCR(\"ldp x\" S(CFA_REG) \", x\" S(BASE_REG)\" , [sp, #16]\") \\\n+  TCR(\"ldp fp, lr, [sp], 32\") \\\n+  TCR(\"ret\")\n+\n+/* -----------------------------\n+   -- Symbol definition block --\n+   ----------------------------- */\n+\n+#define SIGTRAMP_START(SYM) \\\n+  CR(\"# \" S(SYM) \" signal trampoline\") \\\n+  CR(S(SYM) \":\") \\\n+  TCR(\".cfi_startproc\") \\\n+  TCR(\".cfi_signal_frame\")\n+\n+/* ------------------------------\n+   -- Symbol termination block --\n+   ------------------------------ */\n+\n+#define SIGTRAMP_END(SYM) \\\n+  TCR(\".cfi_endproc\")\n+\n+/*----------------------------\n+  -- And now, the real code --\n+  ---------------------------- */\n+\n+asm(\".text\\n\"\n+    TCR(\".align 2\"));\n+\n+/* sigtramp stub for common registers.  */\n+\n+#define TRAMP_COMMON ___gnat_sigtramp_common\n+\n+asm (SIGTRAMP_START(TRAMP_COMMON));\n+asm (CFI_DEF_CFA);\n+asm (CFI_COMMON_REGS);\n+asm (SIGTRAMP_BODY);\n+asm (SIGTRAMP_END(TRAMP_COMMON));"}, {"sha": "4ef11a31e8eb71e9067f9c3fc87e9e565ae1f4b2", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6672e402095eb9df8517918c58929c145b9c1bc2/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6672e402095eb9df8517918c58929c145b9c1bc2/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=6672e402095eb9df8517918c58929c145b9c1bc2", "patch": "@@ -750,7 +750,7 @@ package Sinfo is\n    --    to be sure to raise an ABE. This is used to trigger special handling\n    --    of such cases, particularly in the instantiation case where we avoid\n    --    instantiating the body if this flag is set. This flag is also present\n-   --    in an N_Formal_Package_Declaration_Node since formal package\n+   --    in an N_Formal_Package_Declaration node since formal package\n    --    declarations are treated like instantiations, but it is always set to\n    --    False in this context.\n "}, {"sha": "3f40ae40c185cd5a75ea1eb127018062a79cabf4", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6672e402095eb9df8517918c58929c145b9c1bc2/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6672e402095eb9df8517918c58929c145b9c1bc2/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=6672e402095eb9df8517918c58929c145b9c1bc2", "patch": "@@ -433,7 +433,7 @@ struct layout\n    but our only alternative is the generic unwinder which requires\n    compilation forcing a frame pointer to be reliable.  */\n \n-#if (defined (__x86_64__) || defined (__linux__)) && !defined (__USING_SJLJ_EXCEPTIONS__)\n+#if (defined (__x86_64__) || defined (__linux__)) && !defined (__USING_SJLJ_EXCEPTIONS__) && !defined (__vxworks)\n #define USE_GCC_UNWINDER\n #else\n #define USE_GENERIC_UNWINDER"}]}