{"sha": "84fb43a1a4480e7a0a106fbe38144d1af50b476a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRmYjQzYTFhNDQ4MGU3YTBhMTA2ZmJlMzgxNDRkMWFmNTBiNDc2YQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-05-15T09:11:40Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-05-15T09:11:40Z"}, "message": "dbxout.c (dbxout_range_type): Add LOW and HIGH parameters.\n\n\t* dbxout.c (dbxout_range_type): Add LOW and HIGH parameters.  Use them\n\tfor bounds.\n\t(print_int_cst_bounds_in_octal_p): Likewise.\n\t(dbxout_type): Adjust calls to above functions.  Be prepared to deal\n\twith subtypes.\n\t* dwarf2out.c (base_type_die): Likewise.\n\t(is_subrange_type): Delete.\n\t(subrange_type_die): Add LOW and HIGH parameters.  Use them for bounds.\n\t(modified_type_die): Call subrange_type_for_debug_p on subtypes.\n\t* fold-const.c (fold_truth_not_expr) <CONVERT_EXPR>: Do not strip it if\n\tthe destination type is boolean.\n\t(build_range_check): Do not special-case subtypes.\n\t(fold_sign_changed_comparison): Likewise.\n\t(fold_unary): Likewise.\n\t* langhooks-def.h (LANG_HOOKS_GET_SUBRANGE_BOUNDS): Define.\n\t(LANG_HOOKS_FOR_TYPES_INITIALIZER): Add LANG_HOOKS_GET_SUBRANGE_BOUNDS.\n\t* langhooks.h (lang_hooks_for_types): Add get_subrange_bounds.\n\t* tree.c (subrange_type_for_debug_p): New predicate based on the former\n\tis_subrange_type.\n\t* tree.h (subrange_type_for_debug_p): Declare.\n\t* tree-chrec.c (avoid_arithmetics_in_type_p): Delete.\n\t(convert_affine_scev): Remove call to above function.\n\t(chrec_convert_aggressive): Likewise.\n\t* tree-ssa.c (useless_type_conversion_p_1): Do not specifically return\n\tfalse for conversions involving subtypes.\n\t* tree-vrp.c (vrp_val_max): Do not special-case subtypes.\n\t(vrp_val_min): Likewise.\n\t(needs_overflow_infinity): Likewise.\n\t(extract_range_from_unary_expr): Likewise.\nada/\n\t* gcc-interface/ada-tree.h (TYPE_GCC_MIN_VALUE, TYPE_GCC_MAX_VALUE):\n\tNew macros.\n\t(TYPE_RM_VALUES): Likewise.\n\t(TYPE_RM_SIZE): Rewrite in terms of TYPE_RM_VALUES.\n\t(SET_TYPE_RM_SIZE): New macro.\n\t(TYPE_RM_MIN_VALUE, TYPE_RM_MAX_VALUE): Likewise.\n\t(SET_TYPE_RM_SIZE, SET_TYPE_RM_MAX_VALUE): Likewise.\n\t(TYPE_MIN_VALUE, TYPE_MAX_VALUE): Redefine.\n\t* gcc-interface/gigi.h (create_range_type): Declare.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Modular_Integer_Type>\n\tUse SET_TYPE_RM_MAX_VALUE to set the upper bound on the UMT type.\n\t<E_Signed_Integer_Subtype>: Build a regular integer type first and\n\tthen set the RM bounds.  Use SET_TYPE_RM_SIZE to set the RM size.\n\t<E_Floating_Point_Subtype>: Build a regular floating-point type first\n\tand then set the RM bounds.\n\t<E_Array_Type>: Use create_range_type instead of build_range_type.\n\t<E_Array_Subtype>: Build a regular integer type first and then set\n\tthe RM bounds for the extra subtype.\n\t<E_String_Literal_Subtype>: Use create_range_type instead of\n\tbuild_range_type.\n\t<all>: Set the RM bounds for enumeration types and the GCC bounds for\n\tfloating-point types.\n\t(set_rm_size): Use SET_TYPE_RM_SIZE to set the RM size.\n\t(make_type_from_size) <INTEGER_TYPE>: Use SET_TYPE_RM_{MIN,MAX}_VALUE\n\tto set the bounds.  Use SET_TYPE_RM_SIZE to set the RM size.\n\t(substitute_in_type) <INTEGER_TYPE>: Deal with GCC bounds for domain\n\ttypes and with RM bounds for subtypes.\n\t* gcc-interface/misc.c (LANG_HOOKS_GET_SUBRANGE_BOUNDS): Define.\n\t(gnat_print_type) <REAL_TYPE>: New case.\n\t<ENUMERAL_TYPE>: Fall through to above case.\n\t(gnat_get_subrange_bounds): New function.\n\t* gcc-interface/trans.c (add_decl_expr): Mark the trees rooted as\n\tTYPE_RM_MIN_VALUE and TYPE_RM_MAX_VALUE, if any.\n\t* gcc-interface/utils.c (gnat_init_decl_processing): Use precision 8\n\tfor booleans.  Adjust and use SET_TYPE_RM_SIZE to set the RM size.\n\t(create_range_type): New function.\n\t(create_param_decl): Build a regular integer type first and then set\n\tthe RM bounds for the extra subtype.\n\t(unchecked_convert): Remove kludge for 'Valid.\n\t* gcc-interface/utils2.c (build_binary_op) <ARRAY_RANGE_REF>: Convert\n\tthe index to sizetype instead of TYPE_DOMAIN.\n\nFrom-SVN: r147563", "tree": {"sha": "faaa7bb6c0694f3f9cf8d8dbe54a58161ef0489f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/faaa7bb6c0694f3f9cf8d8dbe54a58161ef0489f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84fb43a1a4480e7a0a106fbe38144d1af50b476a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84fb43a1a4480e7a0a106fbe38144d1af50b476a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84fb43a1a4480e7a0a106fbe38144d1af50b476a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84fb43a1a4480e7a0a106fbe38144d1af50b476a/comments", "author": null, "committer": null, "parents": [{"sha": "331d91868977fe50f5d937a9c195b6418bfda5c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/331d91868977fe50f5d937a9c195b6418bfda5c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/331d91868977fe50f5d937a9c195b6418bfda5c3"}], "stats": {"total": 861, "additions": 500, "deletions": 361}, "files": [{"sha": "8caac7e09b2012813c86d7340f45b841819f9bb0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -1,3 +1,35 @@\n+2009-05-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* dbxout.c (dbxout_range_type): Add LOW and HIGH parameters.  Use them\n+\tfor bounds.\n+\t(print_int_cst_bounds_in_octal_p): Likewise.\n+\t(dbxout_type): Adjust calls to above functions.  Be prepared to deal\n+\twith subtypes.\n+\t* dwarf2out.c (base_type_die): Likewise.\n+\t(is_subrange_type): Delete.\n+\t(subrange_type_die): Add LOW and HIGH parameters.  Use them for bounds.\n+\t(modified_type_die): Call subrange_type_for_debug_p on subtypes.\n+\t* fold-const.c (fold_truth_not_expr) <CONVERT_EXPR>: Do not strip it if\n+\tthe destination type is boolean.\n+\t(build_range_check): Do not special-case subtypes.\n+\t(fold_sign_changed_comparison): Likewise.\n+\t(fold_unary): Likewise.\n+\t* langhooks-def.h (LANG_HOOKS_GET_SUBRANGE_BOUNDS): Define.\n+\t(LANG_HOOKS_FOR_TYPES_INITIALIZER): Add LANG_HOOKS_GET_SUBRANGE_BOUNDS.\n+\t* langhooks.h (lang_hooks_for_types): Add get_subrange_bounds.\n+\t* tree.c (subrange_type_for_debug_p): New predicate based on the former\n+\tis_subrange_type.\n+\t* tree.h (subrange_type_for_debug_p): Declare.\n+\t* tree-chrec.c (avoid_arithmetics_in_type_p): Delete.\n+\t(convert_affine_scev): Remove call to above function.\n+\t(chrec_convert_aggressive): Likewise.\n+\t* tree-ssa.c (useless_type_conversion_p_1): Do not specifically return\n+\tfalse for conversions involving subtypes.\n+\t* tree-vrp.c (vrp_val_max): Do not special-case subtypes.\n+\t(vrp_val_min): Likewise.\n+\t(needs_overflow_infinity): Likewise.\n+\t(extract_range_from_unary_expr): Likewise.\n+\n 2009-05-15  Paolo Bonzini  <bonzini@gnu.org>\n \n         * config/frv/frv.h: Clean up references to GO_IF_LEGITIMATE_ADDRESS."}, {"sha": "0548b21cbcf761aa794551a67f028181efbb30af", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -1,3 +1,47 @@\n+2009-05-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/ada-tree.h (TYPE_GCC_MIN_VALUE, TYPE_GCC_MAX_VALUE):\n+\tNew macros.\n+\t(TYPE_RM_VALUES): Likewise.\n+\t(TYPE_RM_SIZE): Rewrite in terms of TYPE_RM_VALUES.\n+\t(SET_TYPE_RM_SIZE): New macro.\n+\t(TYPE_RM_MIN_VALUE, TYPE_RM_MAX_VALUE): Likewise.\n+\t(SET_TYPE_RM_SIZE, SET_TYPE_RM_MAX_VALUE): Likewise.\n+\t(TYPE_MIN_VALUE, TYPE_MAX_VALUE): Redefine.\n+\t* gcc-interface/gigi.h (create_range_type): Declare.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Modular_Integer_Type>\n+\tUse SET_TYPE_RM_MAX_VALUE to set the upper bound on the UMT type.\n+\t<E_Signed_Integer_Subtype>: Build a regular integer type first and\n+\tthen set the RM bounds.  Use SET_TYPE_RM_SIZE to set the RM size.\n+\t<E_Floating_Point_Subtype>: Build a regular floating-point type first\n+\tand then set the RM bounds.\n+\t<E_Array_Type>: Use create_range_type instead of build_range_type.\n+\t<E_Array_Subtype>: Build a regular integer type first and then set\n+\tthe RM bounds for the extra subtype.\n+\t<E_String_Literal_Subtype>: Use create_range_type instead of\n+\tbuild_range_type.\n+\t<all>: Set the RM bounds for enumeration types and the GCC bounds for\n+\tfloating-point types.\n+\t(set_rm_size): Use SET_TYPE_RM_SIZE to set the RM size.\n+\t(make_type_from_size) <INTEGER_TYPE>: Use SET_TYPE_RM_{MIN,MAX}_VALUE\n+\tto set the bounds.  Use SET_TYPE_RM_SIZE to set the RM size.\n+\t(substitute_in_type) <INTEGER_TYPE>: Deal with GCC bounds for domain\n+\ttypes and with RM bounds for subtypes.\n+\t* gcc-interface/misc.c (LANG_HOOKS_GET_SUBRANGE_BOUNDS): Define.\n+\t(gnat_print_type) <REAL_TYPE>: New case.\n+\t<ENUMERAL_TYPE>: Fall through to above case.\n+\t(gnat_get_subrange_bounds): New function.\n+\t* gcc-interface/trans.c (add_decl_expr): Mark the trees rooted as\n+\tTYPE_RM_MIN_VALUE and TYPE_RM_MAX_VALUE, if any.\n+\t* gcc-interface/utils.c (gnat_init_decl_processing): Use precision 8\n+\tfor booleans.  Adjust and use SET_TYPE_RM_SIZE to set the RM size.\n+\t(create_range_type): New function.\n+\t(create_param_decl): Build a regular integer type first and then set\n+\tthe RM bounds for the extra subtype.\n+\t(unchecked_convert): Remove kludge for 'Valid.\n+\t* gcc-interface/utils2.c (build_binary_op) <ARRAY_RANGE_REF>: Convert\n+\tthe index to sizetype instead of TYPE_DOMAIN.\n+\n 2009-05-14  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (elaborate_expression_1): Remove GNAT_EXPR"}, {"sha": "38bc86208150d2682bff7f46ca41e50404d02f82", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 80, "deletions": 2, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -167,9 +167,87 @@ struct GTY(()) lang_decl { tree t; };\n    mechanism refer to the routine gnat_to_gnu_entity. */\n #define TYPE_CI_CO_LIST(NODE) TYPE_LANG_SLOT_1 (FUNCTION_TYPE_CHECK (NODE))\n \n-/* For integral types, this is the RM size of the type.  */\n+/* For numerical types, this is the GCC lower bound of the type.  The GCC\n+   type system is based on the invariant that an object X of a given type\n+   cannot hold at run time a value smaller than its lower bound; otherwise\n+   the behavior is undefined.  The optimizer takes advantage of this and\n+   considers that the assertion X >= LB is always true.  */\n+#define TYPE_GCC_MIN_VALUE(NODE) (NUMERICAL_TYPE_CHECK (NODE)->type.minval)\n+\n+/* For numerical types, this is the GCC upper bound of the type.  The GCC\n+   type system is based on the invariant that an object X of a given type\n+   cannot hold at run time a value larger than its upper bound; otherwise\n+   the behavior is undefined.  The optimizer takes advantage of this and\n+   considers that the assertion X <= UB is always true.  */\n+#define TYPE_GCC_MAX_VALUE(NODE) (NUMERICAL_TYPE_CHECK (NODE)->type.maxval)\n+\n+/* For numerical types, this holds various RM-defined values.  */\n+#define TYPE_RM_VALUES(NODE) TYPE_LANG_SLOT_1 (NUMERICAL_TYPE_CHECK (NODE))\n+\n+/* For numerical types, this is the RM size of the type, aka its precision.\n+   There is a discrepancy between what is called precision here (and more\n+   generally throughout gigi) and what is called precision in the GCC type\n+   system: in the former case it's TYPE_RM_SIZE whereas it's TYPE_PRECISION\n+   in the latter case.  They are not identical because of the need to support\n+   invalid values.\n+\n+   These values can be outside the range of values allowed by the RM size\n+   but they must nevertheless be valid in the GCC type system, otherwise\n+   the optimizer can pretend that they simply don't exist.  Therefore they\n+   must be within the range of values allowed by the precision in the GCC\n+   sense, hence TYPE_PRECISION be set to the Esize, not the RM size.  */\n #define TYPE_RM_SIZE(NODE) \\\n-  TYPE_LANG_SLOT_1 (TREE_CHECK3 (NODE, ENUMERAL_TYPE, BOOLEAN_TYPE, INTEGER_TYPE))\n+  (TYPE_RM_VALUES (NODE) ? TREE_VEC_ELT (TYPE_RM_VALUES (NODE), 0) : NULL_TREE)\n+#define SET_TYPE_RM_SIZE(NODE, X)\t\t\\\n+  TREE_VEC_ELT ((TYPE_RM_VALUES (NODE)\t\t\\\n+\t\t = (TYPE_RM_VALUES (NODE)\t\\\n+\t\t    ? TYPE_RM_VALUES (NODE) : make_tree_vec (3))), 0) = (X)\n+\n+/* For numerical types, this is the RM lower bound of the type.  There is\n+   again a discrepancy between this lower bound and the GCC lower bound,\n+   again because of the need to support invalid values.\n+\n+   These values can be outside the range of values allowed by the RM lower\n+   bound but they must nevertheless be valid in the GCC type system, otherwise\n+   the optimizer can pretend that they simply don't exist.  Therefore they\n+   must be within the range of values allowed by the lower bound in the GCC\n+   sense, hence the GCC lower bound be set to that of the base type.  */\n+#define TYPE_RM_MIN_VALUE(NODE) \\\n+  (TYPE_RM_VALUES (NODE) ? TREE_VEC_ELT (TYPE_RM_VALUES (NODE), 1) : NULL_TREE)\n+#define SET_TYPE_RM_MIN_VALUE(NODE, X)\t\t\\\n+  TREE_VEC_ELT ((TYPE_RM_VALUES (NODE)\t\t\\\n+\t\t = (TYPE_RM_VALUES (NODE)\t\\\n+\t\t    ? TYPE_RM_VALUES (NODE) : make_tree_vec (3))), 1) = (X)\n+\n+/* For numerical types, this is the RM upper bound of the type.  There is\n+   again a discrepancy between this upper bound and the GCC upper bound,\n+   again because of the need to support invalid values.\n+\n+   These values can be outside the range of values allowed by the RM upper\n+   bound but they must nevertheless be valid in the GCC type system, otherwise\n+   the optimizer can pretend that they simply don't exist.  Therefore they\n+   must be within the range of values allowed by the upper bound in the GCC\n+   sense, hence the GCC upper bound be set to that of the base type.  */\n+#define TYPE_RM_MAX_VALUE(NODE) \\\n+  (TYPE_RM_VALUES (NODE) ? TREE_VEC_ELT (TYPE_RM_VALUES (NODE), 2) : NULL_TREE)\n+#define SET_TYPE_RM_MAX_VALUE(NODE, X)\t\t\\\n+  TREE_VEC_ELT ((TYPE_RM_VALUES (NODE)\t\t\\\n+\t\t = (TYPE_RM_VALUES (NODE)\t\\\n+\t\t    ? TYPE_RM_VALUES (NODE) : make_tree_vec (3))), 2) = (X)\n+\n+/* For numerical types, this is the lower bound of the type, i.e. the RM lower\n+   bound for language-defined types and the GCC lower bound for others.  */\n+#undef TYPE_MIN_VALUE\n+#define TYPE_MIN_VALUE(NODE) \\\n+  (TYPE_RM_MIN_VALUE (NODE) \\\n+   ? TYPE_RM_MIN_VALUE (NODE) : TYPE_GCC_MIN_VALUE (NODE))\n+\n+/* For numerical types, this is the upper bound of the type, i.e. the RM upper\n+   bound for language-defined types and the GCC upper bound for others.  */\n+#undef TYPE_MAX_VALUE\n+#define TYPE_MAX_VALUE(NODE) \\\n+  (TYPE_RM_MAX_VALUE (NODE) \\\n+   ? TYPE_RM_MAX_VALUE (NODE) : TYPE_GCC_MAX_VALUE (NODE))\n \n /* In an UNCONSTRAINED_ARRAY_TYPE, points to the record containing both\n    the template and object."}, {"sha": "46215daf4c97a5dbbaa3a2d95c4943ec38e06b2a", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 113, "deletions": 87, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -1503,7 +1503,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    && !tree_int_cst_equal (gnu_high, TYPE_MAX_VALUE (gnu_type)))\n \t  {\n \t    tree gnu_subtype = make_unsigned_type (esize);\n-\t    TYPE_MAX_VALUE (gnu_subtype) = gnu_high;\n+\t    SET_TYPE_RM_MAX_VALUE (gnu_subtype, gnu_high);\n \t    TREE_TYPE (gnu_subtype) = gnu_type;\n \t    TYPE_EXTRA_SUBTYPE_P (gnu_subtype) = 1;\n \t    TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"UMT\");\n@@ -1519,7 +1519,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_Decimal_Fixed_Point_Subtype:\n \n       /* For integral subtypes, we make a new INTEGER_TYPE.  Note that we do\n-\t not want to call build_range_type since we would like each subtype\n+\t not want to call create_range_type since we would like each subtype\n \t node to be distinct.  ??? Historically this was in preparation for\n \t when memory aliasing is implemented, but that's obsolete now given\n \t the call to relate_alias_sets below.\n@@ -1539,39 +1539,37 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      || !Compile_Time_Known_Value (Type_High_Bound (gnat_entity))))\n \tgnat_to_gnu_entity (Ancestor_Subtype (gnat_entity), gnu_expr, 0);\n \n-      gnu_type = make_node (INTEGER_TYPE);\n-      TREE_TYPE (gnu_type) = get_unpadded_type (Etype (gnat_entity));\n-\n-      /* This should be an unsigned type if the base type is unsigned or\n-\t if the lower bound is constant and non-negative or if the type\n-\t is biased.  */\n-      TYPE_UNSIGNED (gnu_type) = (Is_Unsigned_Type (Etype (gnat_entity))\n-\t\t\t\t  || Is_Unsigned_Type (gnat_entity)\n-\t\t\t\t  || Has_Biased_Representation (gnat_entity));\n-\n-      /* Set the precision to the Esize except for bit-packed arrays and\n-\t subtypes of Standard.Boolean.  */\n+      /* Set the precision to the Esize except for bit-packed arrays.  */\n       if (Is_Packed_Array_Type (gnat_entity)\n \t  && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)))\n \tesize = UI_To_Int (RM_Size (gnat_entity));\n-      else if (Is_Boolean_Type (gnat_entity))\n-\tesize = 1;\n-\n-      TYPE_PRECISION (gnu_type) = esize;\n \n-      TYPE_MIN_VALUE (gnu_type)\n-\t= convert (TREE_TYPE (gnu_type),\n-\t\t   elaborate_expression (Type_Low_Bound (gnat_entity),\n-\t\t\t\t\t gnat_entity, get_identifier (\"L\"),\n-\t\t\t\t\t definition, true,\n-\t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n+      /* This should be an unsigned type if the base type is unsigned or\n+\t if the lower bound is constant and non-negative or if the type\n+\t is biased.  */\n+      if (Is_Unsigned_Type (Etype (gnat_entity))\n+\t  || Is_Unsigned_Type (gnat_entity)\n+\t  || Has_Biased_Representation (gnat_entity))\n+\tgnu_type = make_unsigned_type (esize);\n+      else\n+\tgnu_type = make_signed_type (esize);\n+      TREE_TYPE (gnu_type) = get_unpadded_type (Etype (gnat_entity));\n \n-      TYPE_MAX_VALUE (gnu_type)\n-\t= convert (TREE_TYPE (gnu_type),\n-\t\t   elaborate_expression (Type_High_Bound (gnat_entity),\n-\t\t\t\t\t gnat_entity, get_identifier (\"U\"),\n-\t\t\t\t\t definition, true,\n-\t\t\t\t\t Needs_Debug_Info (gnat_entity)));\n+      SET_TYPE_RM_MIN_VALUE\n+\t(gnu_type,\n+\t convert (TREE_TYPE (gnu_type),\n+\t\t  elaborate_expression (Type_Low_Bound (gnat_entity),\n+\t\t\t\t\tgnat_entity, get_identifier (\"L\"),\n+\t\t\t\t\tdefinition, true,\n+\t\t\t\t\tNeeds_Debug_Info (gnat_entity))));\n+\n+      SET_TYPE_RM_MAX_VALUE\n+\t(gnu_type,\n+\t convert (TREE_TYPE (gnu_type),\n+\t\t  elaborate_expression (Type_High_Bound (gnat_entity),\n+\t\t\t\t\tgnat_entity, get_identifier (\"U\"),\n+\t\t\t\t\tdefinition, true,\n+\t\t\t\t\tNeeds_Debug_Info (gnat_entity))));\n \n       /* One of the above calls might have caused us to be elaborated,\n \t so don't blow up if so.  */\n@@ -1584,8 +1582,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       TYPE_BIASED_REPRESENTATION_P (gnu_type)\n \t= Has_Biased_Representation (gnat_entity);\n \n-      layout_type (gnu_type);\n-\n       /* Attach the TYPE_STUB_DECL in case we have a parallel type.  */\n       TYPE_STUB_DECL (gnu_type)\n \t= create_type_stub_decl (gnu_entity_name, gnu_type);\n@@ -1616,8 +1612,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  tree gnu_field_type, gnu_field;\n \n \t  /* Set the RM size before wrapping up the type.  */\n-\t  TYPE_RM_SIZE (gnu_type)\n-\t    = UI_To_gnu (RM_Size (gnat_entity), bitsizetype);\n+\t  SET_TYPE_RM_SIZE (gnu_type,\n+\t\t\t    UI_To_gnu (RM_Size (gnat_entity), bitsizetype));\n \t  TYPE_PACKED_ARRAY_TYPE_P (gnu_type) = 1;\n \t  gnu_field_type = gnu_type;\n \n@@ -1669,8 +1665,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  tree gnu_field_type, gnu_field;\n \n \t  /* Set the RM size before wrapping up the type.  */\n-\t  TYPE_RM_SIZE (gnu_type)\n-\t    = UI_To_gnu (RM_Size (gnat_entity), bitsizetype);\n+\t  SET_TYPE_RM_SIZE (gnu_type,\n+\t\t\t    UI_To_gnu (RM_Size (gnat_entity), bitsizetype));\n \t  gnu_field_type = gnu_type;\n \n \t  gnu_type = make_node (RECORD_TYPE);\n@@ -1741,20 +1737,27 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tgnu_type = make_node (REAL_TYPE);\n \tTREE_TYPE (gnu_type) = get_unpadded_type (Etype (gnat_entity));\n \tTYPE_PRECISION (gnu_type) = fp_size_to_prec (esize);\n+\tTYPE_GCC_MIN_VALUE (gnu_type)\n+\t  = TYPE_GCC_MIN_VALUE (TREE_TYPE (gnu_type));\n+\tTYPE_GCC_MAX_VALUE (gnu_type)\n+\t  = TYPE_GCC_MAX_VALUE (TREE_TYPE (gnu_type));\n+\tlayout_type (gnu_type);\n \n-\tTYPE_MIN_VALUE (gnu_type)\n-\t  = convert (TREE_TYPE (gnu_type),\n-\t\t     elaborate_expression (Type_Low_Bound (gnat_entity),\n-\t\t\t\t\t   gnat_entity, get_identifier (\"L\"),\n-\t\t\t\t\t   definition, true,\n-\t\t\t\t\t   Needs_Debug_Info (gnat_entity)));\n-\n-\tTYPE_MAX_VALUE (gnu_type)\n-\t  = convert (TREE_TYPE (gnu_type),\n-\t\t     elaborate_expression (Type_High_Bound (gnat_entity),\n-\t\t\t\t\t   gnat_entity, get_identifier (\"U\"),\n-\t\t\t\t\t   definition, true,\n-\t\t\t\t\t   Needs_Debug_Info (gnat_entity)));\n+\tSET_TYPE_RM_MIN_VALUE\n+\t  (gnu_type,\n+\t   convert (TREE_TYPE (gnu_type),\n+\t\t    elaborate_expression (Type_Low_Bound (gnat_entity),\n+\t\t\t\t\t  gnat_entity, get_identifier (\"L\"),\n+\t\t\t\t\t  definition, true,\n+\t\t\t\t\t  Needs_Debug_Info (gnat_entity))));\n+\n+\tSET_TYPE_RM_MAX_VALUE\n+\t  (gnu_type,\n+\t   convert (TREE_TYPE (gnu_type),\n+\t\t    elaborate_expression (Type_High_Bound (gnat_entity),\n+\t\t\t\t\t  gnat_entity, get_identifier (\"U\"),\n+\t\t\t\t\t  definition, true,\n+\t\t\t\t\t  Needs_Debug_Info (gnat_entity))));\n \n \t/* One of the above calls might have caused us to be elaborated,\n \t   so don't blow up if so.  */\n@@ -1764,8 +1767,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    break;\n \t  }\n \n-\tlayout_type (gnu_type);\n-\n \t/* Inherit our alias set from what we're a subtype of, as for\n \t   integer subtypes.  */\n \trelate_alias_sets (gnu_type, TREE_TYPE (gnu_type), ALIAS_SET_COPY);\n@@ -1899,8 +1900,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    gnu_index_types[index]\n \t      = create_index_type (convert (sizetype, gnu_min),\n \t\t\t\t   convert (sizetype, gnu_max),\n-\t\t\t\t   build_range_type (gnu_ind_subtype,\n-\t\t\t\t\t\t     gnu_min, gnu_max),\n+\t\t\t\t   create_range_type (gnu_ind_subtype,\n+\t\t\t\t\t\t      gnu_min, gnu_max),\n \t\t\t\t   gnat_entity);\n \t    /* Update the maximum size of the array, in elements.  */\n \t    gnu_max_size\n@@ -2585,19 +2586,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     subtype if necessary.  */\n \t\t  if (TYPE_MODULAR_P (gnu_inner_type))\n \t\t    {\n-\t\t      tree gnu_subtype = make_node (INTEGER_TYPE);\n+\t\t      tree gnu_subtype\n+\t\t\t= make_unsigned_type (TYPE_PRECISION (gnu_inner_type));\n \t\t      TREE_TYPE (gnu_subtype) = gnu_inner_type;\n \t\t      TYPE_EXTRA_SUBTYPE_P (gnu_subtype) = 1;\n-\n-\t\t      TYPE_UNSIGNED (gnu_subtype) = 1;\n-\t\t      TYPE_PRECISION (gnu_subtype)\n-\t\t\t= TYPE_PRECISION (gnu_inner_type);\n-\t\t      TYPE_MIN_VALUE (gnu_subtype)\n-\t\t\t= TYPE_MIN_VALUE (gnu_inner_type);\n-\t\t      TYPE_MAX_VALUE (gnu_subtype)\n-\t\t\t= TYPE_MAX_VALUE (gnu_inner_type);\n-\t\t      layout_type (gnu_subtype);\n-\n+\t\t      SET_TYPE_RM_MIN_VALUE (gnu_subtype,\n+\t\t\t\t\t     TYPE_MIN_VALUE (gnu_inner_type));\n+\t\t      SET_TYPE_RM_MAX_VALUE (gnu_subtype,\n+\t\t\t\t\t     TYPE_MAX_VALUE (gnu_inner_type));\n \t\t      gnu_inner_type = gnu_subtype;\n \t\t    }\n \n@@ -2665,9 +2661,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \ttree gnu_index_type\n \t  = create_index_type (convert (sizetype, gnu_lower_bound),\n \t\t\t       convert (sizetype, gnu_upper_bound),\n-\t\t\t       build_range_type (gnu_string_index_type,\n-\t\t\t\t\t\t gnu_lower_bound,\n-\t\t\t\t\t\t gnu_upper_bound),\n+\t\t\t       create_range_type (gnu_string_index_type,\n+\t\t\t\t\t\t  gnu_lower_bound,\n+\t\t\t\t\t\t  gnu_upper_bound),\n \t\t\t       gnat_entity);\n \n \tgnu_type\n@@ -4743,6 +4739,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       || (kind == E_Floating_Point_Type && !Vax_Float (gnat_entity)))\n     {\n       tree gnu_scalar_type = gnu_type;\n+      tree gnu_low_bound, gnu_high_bound;\n \n       /* If this is a padded type, we need to use the underlying type.  */\n       if (TREE_CODE (gnu_scalar_type) == RECORD_TYPE\n@@ -4754,19 +4751,27 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       if (!longest_float_type_node && kind == E_Floating_Point_Type)\n \tlongest_float_type_node = gnu_scalar_type;\n \n-      TYPE_MIN_VALUE (gnu_scalar_type)\n-\t= gnat_to_gnu (Type_Low_Bound (gnat_entity));\n-      TYPE_MAX_VALUE (gnu_scalar_type)\n-\t= gnat_to_gnu (Type_High_Bound (gnat_entity));\n+      gnu_low_bound = gnat_to_gnu (Type_Low_Bound (gnat_entity));\n+      gnu_high_bound = gnat_to_gnu (Type_High_Bound (gnat_entity));\n \n-      /* For enumeration types, write full debugging information.  */\n       if (kind == E_Enumeration_Type)\n \t{\n-\t  /* Since this has both a typedef and a tag, avoid outputting\n-\t     the name twice.  */\n+\t  /* Enumeration types have specific RM bounds.  */\n+\t  SET_TYPE_RM_MIN_VALUE (gnu_scalar_type, gnu_low_bound);\n+\t  SET_TYPE_RM_MAX_VALUE (gnu_scalar_type, gnu_high_bound);\n+\n+\t  /* Write full debugging information.  Since this has both a\n+\t     typedef and a tag, avoid outputting the name twice.  */\n \t  DECL_ARTIFICIAL (gnu_decl) = 1;\n \t  rest_of_type_decl_compilation (gnu_decl);\n \t}\n+\n+      else\n+\t{\n+\t  /* Floating-point types don't have specific RM bounds.  */\n+\t  TYPE_GCC_MIN_VALUE (gnu_scalar_type) = gnu_low_bound;\n+\t  TYPE_GCC_MAX_VALUE (gnu_scalar_type) = gnu_high_bound;\n+\t}\n     }\n \n   /* If we deferred processing of incomplete types, re-enable it.  If there\n@@ -7391,7 +7396,7 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n        && Is_Discrete_Or_Fixed_Point_Type (gnat_entity))\n       || (TREE_CODE (gnu_type) == ENUMERAL_TYPE\n \t  || TREE_CODE (gnu_type) == BOOLEAN_TYPE))\n-    TYPE_RM_SIZE (gnu_type) = size;\n+    SET_TYPE_RM_SIZE (gnu_type, size);\n \n   /* ...or the Ada size for record and union types.  */\n   else if ((TREE_CODE (gnu_type) == RECORD_TYPE\n@@ -7443,10 +7448,12 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n       else\n \tnew_type = make_signed_type (size);\n       TREE_TYPE (new_type) = TREE_TYPE (type) ? TREE_TYPE (type) : type;\n-      TYPE_MIN_VALUE (new_type)\n-\t= convert (TREE_TYPE (new_type), TYPE_MIN_VALUE (type));\n-      TYPE_MAX_VALUE (new_type)\n-\t= convert (TREE_TYPE (new_type), TYPE_MAX_VALUE (type));\n+      SET_TYPE_RM_MIN_VALUE (new_type,\n+\t\t\t     convert (TREE_TYPE (new_type),\n+\t\t\t\t      TYPE_MIN_VALUE (type)));\n+      SET_TYPE_RM_MAX_VALUE (new_type,\n+\t\t\t     convert (TREE_TYPE (new_type),\n+\t\t\t\t      TYPE_MAX_VALUE (type)));\n       /* Propagate the name to avoid creating a fake subrange type.  */\n       if (TYPE_NAME (type))\n \t{\n@@ -7456,7 +7463,7 @@ make_type_from_size (tree type, tree size_tree, bool for_biased)\n \t    TYPE_NAME (new_type) = TYPE_NAME (type);\n \t}\n       TYPE_BIASED_REPRESENTATION_P (new_type) = biased_p;\n-      TYPE_RM_SIZE (new_type) = bitsize_int (size);\n+      SET_TYPE_RM_SIZE (new_type, bitsize_int (size));\n       return new_type;\n \n     case RECORD_TYPE:\n@@ -7703,18 +7710,20 @@ substitute_in_type (tree t, tree f, tree r)\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n     case REAL_TYPE:\n-      if (CONTAINS_PLACEHOLDER_P (TYPE_MIN_VALUE (t))\n-\t  || CONTAINS_PLACEHOLDER_P (TYPE_MAX_VALUE (t)))\n+\n+      /* First the domain types of arrays.  */\n+      if (CONTAINS_PLACEHOLDER_P (TYPE_GCC_MIN_VALUE (t))\n+\t  || CONTAINS_PLACEHOLDER_P (TYPE_GCC_MAX_VALUE (t)))\n \t{\n-\t  tree low = SUBSTITUTE_IN_EXPR (TYPE_MIN_VALUE (t), f, r);\n-\t  tree high = SUBSTITUTE_IN_EXPR (TYPE_MAX_VALUE (t), f, r);\n+\t  tree low = SUBSTITUTE_IN_EXPR (TYPE_GCC_MIN_VALUE (t), f, r);\n+\t  tree high = SUBSTITUTE_IN_EXPR (TYPE_GCC_MAX_VALUE (t), f, r);\n \n-\t  if (low == TYPE_MIN_VALUE (t) && high == TYPE_MAX_VALUE (t))\n+\t  if (low == TYPE_GCC_MIN_VALUE (t) && high == TYPE_GCC_MAX_VALUE (t))\n \t    return t;\n \n \t  new = copy_type (t);\n-\t  TYPE_MIN_VALUE (new) = low;\n-\t  TYPE_MAX_VALUE (new) = high;\n+\t  TYPE_GCC_MIN_VALUE (new) = low;\n+\t  TYPE_GCC_MAX_VALUE (new) = high;\n \n \t  if (TREE_CODE (t) == INTEGER_TYPE && TYPE_INDEX_TYPE (t))\n \t    SET_TYPE_INDEX_TYPE\n@@ -7723,6 +7732,23 @@ substitute_in_type (tree t, tree f, tree r)\n \t  return new;\n \t}\n \n+      /* Then the subtypes.  */\n+      if (CONTAINS_PLACEHOLDER_P (TYPE_RM_MIN_VALUE (t))\n+\t  || CONTAINS_PLACEHOLDER_P (TYPE_RM_MAX_VALUE (t)))\n+\t{\n+\t  tree low = SUBSTITUTE_IN_EXPR (TYPE_RM_MIN_VALUE (t), f, r);\n+\t  tree high = SUBSTITUTE_IN_EXPR (TYPE_RM_MAX_VALUE (t), f, r);\n+\n+\t  if (low == TYPE_RM_MIN_VALUE (t) && high == TYPE_RM_MAX_VALUE (t))\n+\t    return t;\n+\n+\t  new = copy_type (t);\n+\t  SET_TYPE_RM_MIN_VALUE (new, low);\n+\t  SET_TYPE_RM_MAX_VALUE (new, high);\n+\n+\t  return new;\n+\t}\n+\n       return t;\n \n     case COMPLEX_TYPE:"}, {"sha": "4d19b42e49123c911b0e4e2a6158824154c2e4bc", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -558,6 +558,10 @@ extern tree copy_type (tree type);\n extern tree create_index_type (tree min, tree max, tree index,\n \t\t\t       Node_Id gnat_node);\n \n+/* Return a subtype of TYPE with range MIN to MAX.  If TYPE is NULL,\n+   sizetype is used.  */\n+extern tree create_range_type (tree type, tree min, tree max);\n+\n /* Return a TYPE_DECL node suitable for the TYPE_STUB_DECL field of a type.\n    TYPE_NAME gives the name of the type and TYPE is a ..._TYPE node giving\n    its data type.  */"}, {"sha": "bd6b51af118be69485b0898799635396052c06a0", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -78,6 +78,7 @@ static int gnat_eh_type_covers\t\t(tree, tree);\n static void gnat_parse_file\t\t(int);\n static void internal_error_function\t(const char *, va_list *);\n static tree gnat_type_max_size\t\t(const_tree);\n+static void gnat_get_subrange_bounds\t(const_tree, tree *, tree *);\n \n /* Definitions for our language-specific hooks.  */\n \n@@ -125,6 +126,8 @@ static tree gnat_type_max_size\t\t(const_tree);\n #define LANG_HOOKS_TYPE_FOR_SIZE\tgnat_type_for_size\n #undef  LANG_HOOKS_TYPES_COMPATIBLE_P\n #define LANG_HOOKS_TYPES_COMPATIBLE_P\tgnat_types_compatible_p\n+#undef  LANG_HOOKS_GET_SUBRANGE_BOUNDS\n+#define LANG_HOOKS_GET_SUBRANGE_BOUNDS  gnat_get_subrange_bounds\n #undef  LANG_HOOKS_ATTRIBUTE_TABLE\n #define LANG_HOOKS_ATTRIBUTE_TABLE\tgnat_internal_attribute_table\n #undef  LANG_HOOKS_BUILTIN_FUNCTION\n@@ -513,6 +516,12 @@ gnat_print_type (FILE *file, tree node, int indent)\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n       print_node_brief (file, \"RM size\", TYPE_RM_SIZE (node), indent + 4);\n+\n+      /* ... fall through ... */\n+\n+    case REAL_TYPE:\n+      print_node_brief (file, \"RM min\", TYPE_RM_MIN_VALUE (node), indent + 4);\n+      print_node_brief (file, \"RM max\", TYPE_RM_MAX_VALUE (node), indent + 4);\n       break;\n \n     case ARRAY_TYPE:\n@@ -644,6 +653,18 @@ gnat_type_max_size (const_tree gnu_type)\n   return max_unitsize;\n }\n \n+/* GNU_TYPE is a subtype of an integral type.  Set LOWVAL to the low bound\n+   and HIGHVAL to the high bound, respectively.  */\n+\n+static void\n+gnat_get_subrange_bounds (const_tree gnu_type, tree *lowval, tree *highval)\n+{\n+  tree min = TYPE_MIN_VALUE (gnu_type);\n+  tree max = TYPE_MAX_VALUE (gnu_type);\n+  *lowval = TREE_CONSTANT (min) ? min : TYPE_GCC_MIN_VALUE (gnu_type);\n+  *highval = TREE_CONSTANT (max) ? max : TYPE_GCC_MAX_VALUE (gnu_type);\n+}\n+\n /* GNU_TYPE is a type. Determine if it should be passed by reference by\n    default.  */\n "}, {"sha": "2c471f1561f2a406213980339812e32ef820af67", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -5562,20 +5562,39 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n \t Note that walk_tree knows how to deal with TYPE_DECL, but neither\n \t VAR_DECL nor CONST_DECL.  This appears to be somewhat arbitrary.  */\n       mark_visited (&gnu_stmt);\n+\n       if (TREE_CODE (gnu_decl) == VAR_DECL\n \t  || TREE_CODE (gnu_decl) == CONST_DECL)\n \t{\n \t  mark_visited (&DECL_SIZE (gnu_decl));\n \t  mark_visited (&DECL_SIZE_UNIT (gnu_decl));\n \t  mark_visited (&DECL_INITIAL (gnu_decl));\n \t}\n-      /* In any case, we have to deal with our own TYPE_ADA_SIZE field.  */\n-      if (TREE_CODE (gnu_decl) == TYPE_DECL\n-\t  && (TREE_CODE (type) == RECORD_TYPE\n-\t      || TREE_CODE (type) == UNION_TYPE\n-\t      || TREE_CODE (type) == QUAL_UNION_TYPE)\n-\t  && (t = TYPE_ADA_SIZE (type)))\n-\tmark_visited (&t);\n+\n+      /* In any case, we have to deal with our own fields.  */\n+      else if (TREE_CODE (gnu_decl) == TYPE_DECL)\n+\tswitch (TREE_CODE (type))\n+\t  {\n+\t  case RECORD_TYPE:\n+\t  case UNION_TYPE:\n+\t  case QUAL_UNION_TYPE:\n+\t    if ((t = TYPE_ADA_SIZE (type)))\n+\t      mark_visited (&t);\n+\t    break;\n+\n+\t  case INTEGER_TYPE:\n+\t  case ENUMERAL_TYPE:\n+\t  case BOOLEAN_TYPE:\n+\t  case REAL_TYPE:\n+\t    if ((t = TYPE_RM_MIN_VALUE (type)))\n+\t      mark_visited (&t);\n+\t    if ((t = TYPE_RM_MAX_VALUE (type)))\n+\t      mark_visited (&t);\n+\t    break;\n+\n+\t  default:\n+\t    break;\n+\t  }\n     }\n   else\n     add_stmt_with_node (gnu_stmt, gnat_entity);"}, {"sha": "6dbd1e700e1cd39a62b18cb3f07edfa2327303f2", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 48, "deletions": 67, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -530,12 +530,14 @@ gnat_init_decl_processing (void)\n   set_sizetype (size_type_node);\n \n   /* In Ada, we use an unsigned 8-bit type for the default boolean type.  */\n-  boolean_type_node = make_node (BOOLEAN_TYPE);\n-  TYPE_PRECISION (boolean_type_node) = 1;\n-  fixup_unsigned_type (boolean_type_node);\n-  TYPE_RM_SIZE (boolean_type_node) = bitsize_int (1);\n+  boolean_type_node = make_unsigned_type (8);\n+  TREE_SET_CODE (boolean_type_node, BOOLEAN_TYPE);\n+  SET_TYPE_RM_MAX_VALUE (boolean_type_node,\n+\t\t\t build_int_cst (boolean_type_node, 1));\n+  SET_TYPE_RM_SIZE (boolean_type_node, bitsize_int (1));\n \n   build_common_tree_nodes_2 (0);\n+  boolean_true_node = TYPE_MAX_VALUE (boolean_type_node);\n \n   ptr_void_type_node = build_pointer_type (void_type_node);\n }\n@@ -1195,6 +1197,42 @@ create_index_type (tree min, tree max, tree index, Node_Id gnat_node)\n \n   return type;\n }\n+\n+/* Return a subtype of TYPE with range MIN to MAX.  If TYPE is NULL,\n+   sizetype is used.  */\n+\n+tree\n+create_range_type (tree type, tree min, tree max)\n+{\n+  tree range_type;\n+\n+  if (type == NULL_TREE)\n+    type = sizetype;\n+\n+  /* First build a type with the base range.  */\n+  range_type\n+    = build_range_type (type, TYPE_MIN_VALUE (type), TYPE_MAX_VALUE (type));\n+\n+  min = convert (type, min);\n+  max = convert (type, max);\n+\n+  /* If this type has the TYPE_RM_{MIN,MAX}_VALUE we want, return it.  */\n+  if (TYPE_RM_MIN_VALUE (range_type)\n+      && TYPE_RM_MAX_VALUE (range_type)\n+      && operand_equal_p (TYPE_RM_MIN_VALUE (range_type), min, 0)\n+      && operand_equal_p (TYPE_RM_MAX_VALUE (range_type), max, 0))\n+    return range_type;\n+\n+  /* Otherwise, if TYPE_RM_{MIN,MAX}_VALUE is set, make a copy.  */\n+  if (TYPE_RM_MIN_VALUE (range_type) || TYPE_RM_MAX_VALUE (range_type))\n+    range_type = copy_type (range_type);\n+\n+  /* Then set the actual range.  */\n+  SET_TYPE_RM_MIN_VALUE (range_type, min);\n+  SET_TYPE_RM_MAX_VALUE (range_type, max);\n+\n+  return range_type;\n+}\n \f\n /* Return a TYPE_DECL node suitable for the TYPE_STUB_DECL field of a type.\n    TYPE_NAME gives the name of the type and TYPE is a ..._TYPE node giving\n@@ -1581,16 +1619,12 @@ create_param_decl (tree param_name, tree param_type, bool readonly)\n       if (TREE_CODE (param_type) == INTEGER_TYPE\n \t  && TYPE_BIASED_REPRESENTATION_P (param_type))\n \t{\n-\t  tree subtype = make_node (INTEGER_TYPE);\n+\t  tree subtype\n+\t    = make_unsigned_type (TYPE_PRECISION (integer_type_node));\n \t  TREE_TYPE (subtype) = integer_type_node;\n \t  TYPE_BIASED_REPRESENTATION_P (subtype) = 1;\n-\n-\t  TYPE_UNSIGNED (subtype) = 1;\n-\t  TYPE_PRECISION (subtype) = TYPE_PRECISION (integer_type_node);\n-\t  TYPE_MIN_VALUE (subtype) = TYPE_MIN_VALUE (param_type);\n-\t  TYPE_MAX_VALUE (subtype) = TYPE_MAX_VALUE (param_type);\n-\t  layout_type (subtype);\n-\n+\t  SET_TYPE_RM_MIN_VALUE (subtype, TYPE_MIN_VALUE (param_type));\n+\t  SET_TYPE_RM_MAX_VALUE (subtype, TYPE_MAX_VALUE (param_type));\n \t  param_type = subtype;\n \t}\n       else\n@@ -4288,8 +4322,7 @@ maybe_unconstrained_array (tree exp)\n }\n \f\n /* Return true if EXPR is an expression that can be folded as an operand\n-   of a VIEW_CONVERT_EXPR.  See the head comment of unchecked_convert for\n-   the rationale.  */\n+   of a VIEW_CONVERT_EXPR.  See ada-tree.h for a complete rationale.  */\n \n static bool\n can_fold_for_view_convert_p (tree expr)\n@@ -4337,22 +4370,7 @@ can_fold_for_view_convert_p (tree expr)\n \n    we expect the 8 bits at Vbits'Address to always contain Value, while\n    their original location depends on the endianness, at Value'Address\n-   on a little-endian architecture but not on a big-endian one.\n-\n-   ??? There is a problematic discrepancy between what is called precision\n-   here (and more generally throughout gigi) for integral types and what is\n-   called precision in the middle-end.  In the former case it's the RM size\n-   as given by TYPE_RM_SIZE (or rm_size) whereas it's TYPE_PRECISION in the\n-   latter case, the hitch being that they are not equal when they matter,\n-   that is when the number of value bits is not equal to the type's size:\n-   TYPE_RM_SIZE does give the number of value bits but TYPE_PRECISION is set\n-   to the size.  The sole exception are BOOLEAN_TYPEs for which both are 1.\n-\n-   The consequence is that gigi must duplicate code bridging the gap between\n-   the type's size and its precision that exists for TYPE_PRECISION in the\n-   middle-end, because the latter knows nothing about TYPE_RM_SIZE, and be\n-   wary of transformations applied in the middle-end based on TYPE_PRECISION\n-   because this value doesn't reflect the actual precision for Ada.  */\n+   on a little-endian architecture but not on a big-endian one.  */\n \n tree\n unchecked_convert (tree type, tree expr, bool notrunc_p)\n@@ -4397,43 +4415,6 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t  expr = convert (rtype, expr);\n \t  expr = build1 (NOP_EXPR, type, expr);\n \t}\n-\n-      /* We have another special case: if we are unchecked converting either\n-\t a subtype or a type with limited range into a base type, we need to\n-\t ensure that VRP doesn't propagate range information because this\n-\t conversion may be done precisely to validate that the object is\n-\t within the range it is supposed to have.  */\n-      else if (TREE_CODE (expr) != INTEGER_CST\n-\t       && TREE_CODE (type) == INTEGER_TYPE && !TREE_TYPE (type)\n-\t       && ((TREE_CODE (etype) == INTEGER_TYPE && TREE_TYPE (etype))\n-\t\t   || TREE_CODE (etype) == ENUMERAL_TYPE\n-\t\t   || TREE_CODE (etype) == BOOLEAN_TYPE))\n-\t{\n-\t  /* The optimization barrier is a VIEW_CONVERT_EXPR node; moreover,\n-\t     in order not to be deemed an useless type conversion, it must\n-\t     be from subtype to base type.\n-\n-\t     Therefore we first do the bulk of the conversion to a subtype of\n-\t     the final type.  And this conversion must itself not be deemed\n-\t     useless if the source type is not a subtype because, otherwise,\n-\t     the final VIEW_CONVERT_EXPR will be deemed so as well.  That's\n-\t     why we toggle the unsigned flag in this conversion, which is\n-\t     harmless since the final conversion is only a reinterpretation\n-\t     of the bit pattern.\n-\n-\t     ??? This may raise addressability and/or aliasing issues because\n-\t     VIEW_CONVERT_EXPR gets gimplified as an lvalue, thus causing the\n-\t     address of its operand to be taken if it is deemed addressable\n-\t     and not already in GIMPLE form.  */\n-\t  tree rtype\n-\t    = gnat_type_for_mode (TYPE_MODE (type), !TYPE_UNSIGNED (etype));\n-\t  rtype = copy_type (rtype);\n-\t  TYPE_MAIN_VARIANT (rtype) = rtype;\n-\t  TREE_TYPE (rtype) = type;\n-\t  expr = convert (rtype, expr);\n-\t  expr = build1 (VIEW_CONVERT_EXPR, type, expr);\n-\t}\n-\n       else\n \texpr = convert (type, expr);\n     }"}, {"sha": "3fe85853879011260867ef935c32f479b2fd38ef", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -802,11 +802,10 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t  left_type = TREE_TYPE (left_operand);\n \t}\n \n-      /* Then convert the right operand to its base type.  This will\n-\t prevent unneeded signedness conversions when sizetype is wider than\n-\t integer.  */\n+      /* Then convert the right operand to its base type.  This will prevent\n+\t unneeded sign conversions when sizetype is wider than integer.  */\n       right_operand = convert (right_base_type, right_operand);\n-      right_operand = convert (TYPE_DOMAIN (left_type), right_operand);\n+      right_operand = convert (sizetype, right_operand);\n \n       if (!TREE_CONSTANT (right_operand)\n \t  || !TREE_CONSTANT (TYPE_MIN_VALUE (right_type)))"}, {"sha": "eb0fceee52b6b09b58c9de78a635e1b1cf5d5cfc", "filename": "gcc/dbxout.c", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -318,9 +318,9 @@ static void dbxout_args (tree);\n static void dbxout_type_fields (tree);\n static void dbxout_type_method_1 (tree);\n static void dbxout_type_methods (tree);\n-static void dbxout_range_type (tree);\n+static void dbxout_range_type (tree, tree, tree);\n static void dbxout_type (tree, int);\n-static bool print_int_cst_bounds_in_octal_p (tree);\n+static bool print_int_cst_bounds_in_octal_p (tree, tree, tree);\n static bool is_fortran (void);\n static void dbxout_type_name (tree);\n static void dbxout_class_name_qualifiers (tree);\n@@ -1593,10 +1593,10 @@ dbxout_type_methods (tree type)\n \n /* Emit a \"range\" type specification, which has the form:\n    \"r<index type>;<lower bound>;<upper bound>;\".\n-   TYPE is an INTEGER_TYPE.  */\n+   TYPE is an INTEGER_TYPE, LOW and HIGH are the bounds.  */\n \n static void\n-dbxout_range_type (tree type)\n+dbxout_range_type (tree type, tree low, tree high)\n {\n   stabstr_C ('r');\n   if (TREE_TYPE (type))\n@@ -1624,25 +1624,23 @@ dbxout_range_type (tree type)\n     }\n \n   stabstr_C (';');\n-  if (TYPE_MIN_VALUE (type) != 0\n-      && host_integerp (TYPE_MIN_VALUE (type), 0))\n+  if (low && host_integerp (low, 0))\n     {\n-      if (print_int_cst_bounds_in_octal_p (type))\n-        stabstr_O (TYPE_MIN_VALUE (type));\n+      if (print_int_cst_bounds_in_octal_p (type, low, high))\n+        stabstr_O (low);\n       else\n-        stabstr_D (tree_low_cst (TYPE_MIN_VALUE (type), 0));\n+        stabstr_D (tree_low_cst (low, 0));\n     }\n   else\n     stabstr_C ('0');\n \n   stabstr_C (';');\n-  if (TYPE_MAX_VALUE (type) != 0\n-      && host_integerp (TYPE_MAX_VALUE (type), 0))\n+  if (high && host_integerp (high, 0))\n     {\n-      if (print_int_cst_bounds_in_octal_p (type))\n-        stabstr_O (TYPE_MAX_VALUE (type));\n+      if (print_int_cst_bounds_in_octal_p (type, low, high))\n+        stabstr_O (high);\n       else\n-        stabstr_D (tree_low_cst (TYPE_MAX_VALUE (type), 0));\n+        stabstr_D (tree_low_cst (high, 0));\n       stabstr_C (';');\n     }\n   else\n@@ -1663,10 +1661,9 @@ dbxout_range_type (tree type)\n static void\n dbxout_type (tree type, int full)\n {\n-  tree tem;\n-  tree main_variant;\n   static int anonymous_type_number = 0;\n   bool vector_type = false;\n+  tree tem, main_variant, low, high;\n \n   if (TREE_CODE (type) == VECTOR_TYPE)\n     {\n@@ -1676,6 +1673,27 @@ dbxout_type (tree type, int full)\n       vector_type = true;\n     }\n \n+  if (TREE_CODE (type) == INTEGER_TYPE)\n+    {\n+      if (TREE_TYPE (type) == 0)\n+\t{\n+\t  low = TYPE_MIN_VALUE (type);\n+\t  high = TYPE_MAX_VALUE (type);\n+\t}\n+\n+      else if (subrange_type_for_debug_p (type, &low, &high))\n+\t;\n+\n+      /* If this is a subtype that should not be emitted as a subrange type,\n+\t use the base type.  */\n+      else\n+\t{\n+\t  type = TREE_TYPE (type);\n+\t  low = TYPE_MIN_VALUE (type);\n+\t  high = TYPE_MAX_VALUE (type);\n+\t}\n+    }\n+\n   /* If there was an input error and we don't really have a type,\n      avoid crashing and write something that is at least valid\n      by assuming `int'.  */\n@@ -1877,7 +1895,7 @@ dbxout_type (tree type, int full)\n \t      stabstr_C (';');\n \t    }\n \n-\t  dbxout_range_type (type);\n+\t  dbxout_range_type (type, low, high);\n \t}\n \n       else\n@@ -1893,7 +1911,7 @@ dbxout_type (tree type, int full)\n \t      stabstr_C (';');\n \t    }\n \n-\t  if (print_int_cst_bounds_in_octal_p (type))\n+\t  if (print_int_cst_bounds_in_octal_p (type, low, high))\n \t    {\n \t      stabstr_C ('r');\n \n@@ -1908,15 +1926,15 @@ dbxout_type (tree type, int full)\n                 dbxout_type_index (type);\n \n \t      stabstr_C (';');\n-\t      stabstr_O (TYPE_MIN_VALUE (type));\n+\t      stabstr_O (low);\n \t      stabstr_C (';');\n-\t      stabstr_O (TYPE_MAX_VALUE (type));\n+\t      stabstr_O (high);\n \t      stabstr_C (';');\n \t    }\n \n \t  else\n \t    /* Output other integer types as subranges of `int'.  */\n-\t    dbxout_range_type (type);\n+\t    dbxout_range_type (type, low, high);\n \t}\n \n       break;\n@@ -2010,7 +2028,7 @@ dbxout_type (tree type, int full)\n       else\n \t{\n \t  stabstr_C ('a');\n-\t  dbxout_range_type (tem);\n+\t  dbxout_range_type (tem, TYPE_MIN_VALUE (tem), TYPE_MAX_VALUE (tem));\n \t}\n \n       dbxout_type (TREE_TYPE (type), 0);\n@@ -2258,7 +2276,7 @@ dbxout_type (tree type, int full)\n    should be printed in octal format.  */\n \n static bool\n-print_int_cst_bounds_in_octal_p (tree type)\n+print_int_cst_bounds_in_octal_p (tree type, tree low, tree high)\n {\n   /* If we can use GDB extensions and the size is wider than a long\n      (the size used by GDB to read them) or we may have trouble writing\n@@ -2272,10 +2290,8 @@ print_int_cst_bounds_in_octal_p (tree type)\n      can't span same size unsigned types.  */\n \n   if (use_gnu_debug_info_extensions\n-      && TYPE_MIN_VALUE (type) != 0\n-      && TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST\n-      && TYPE_MAX_VALUE (type) != 0\n-      && TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST\n+      && low && TREE_CODE (low) == INTEGER_CST\n+      && high && TREE_CODE (high) == INTEGER_CST\n       && (TYPE_PRECISION (type) > TYPE_PRECISION (integer_type_node)\n \t  || ((TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node))\n \t      && TYPE_UNSIGNED (type))"}, {"sha": "157bdaf9574d53697a02034e45637f9dbfe61060", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 16, "deletions": 68, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -5095,8 +5095,7 @@ static void output_line_info (void);\n static void output_file_names (void);\n static dw_die_ref base_type_die (tree);\n static int is_base_type (tree);\n-static bool is_subrange_type (const_tree);\n-static dw_die_ref subrange_type_die (tree, dw_die_ref);\n+static dw_die_ref subrange_type_die (tree, tree, tree, dw_die_ref);\n static dw_die_ref modified_type_die (tree, int, int, dw_die_ref);\n static int type_is_enum (const_tree);\n static unsigned int dbx_reg_number (const_rtx);\n@@ -9273,6 +9272,11 @@ base_type_die (tree type)\n   if (TREE_CODE (type) == ERROR_MARK || TREE_CODE (type) == VOID_TYPE)\n     return 0;\n \n+  /* If this is a subtype that should not be emitted as a subrange type,\n+     use the base type.  See subrange_type_for_debug_p.  */\n+  if (TREE_CODE (type) == INTEGER_TYPE && TREE_TYPE (type) != NULL_TREE)\n+    type = TREE_TYPE (type);\n+\n   switch (TREE_CODE (type))\n     {\n     case INTEGER_TYPE:\n@@ -9392,67 +9396,11 @@ simple_type_size_in_bits (const_tree type)\n     return TYPE_ALIGN (type);\n }\n \n-/* Return true if the debug information for the given type should be\n-   emitted as a subrange type.  */\n-\n-static inline bool\n-is_subrange_type (const_tree type)\n-{\n-  tree subtype = TREE_TYPE (type);\n-\n-  /* Subrange types are identified by the fact that they are integer\n-     types, and that they have a subtype which is either an integer type\n-     or an enumeral type.  */\n-\n-  if (TREE_CODE (type) != INTEGER_TYPE\n-      || subtype == NULL_TREE)\n-    return false;\n-\n-  if (TREE_CODE (subtype) != INTEGER_TYPE\n-      && TREE_CODE (subtype) != ENUMERAL_TYPE\n-      && TREE_CODE (subtype) != BOOLEAN_TYPE)\n-    return false;\n-\n-  if (TREE_CODE (type) == TREE_CODE (subtype)\n-      && int_size_in_bytes (type) == int_size_in_bytes (subtype)\n-      && TYPE_MIN_VALUE (type) != NULL\n-      && TYPE_MIN_VALUE (subtype) != NULL\n-      && tree_int_cst_equal (TYPE_MIN_VALUE (type), TYPE_MIN_VALUE (subtype))\n-      && TYPE_MAX_VALUE (type) != NULL\n-      && TYPE_MAX_VALUE (subtype) != NULL\n-      && tree_int_cst_equal (TYPE_MAX_VALUE (type), TYPE_MAX_VALUE (subtype)))\n-    {\n-      /* The type and its subtype have the same representation.  If in\n-\t addition the two types also have the same name, then the given\n-\t type is not a subrange type, but rather a plain base type.  */\n-      /* FIXME: brobecker/2004-03-22:\n-\t Sizetype INTEGER_CSTs nodes are canonicalized.  It should\n-\t therefore be sufficient to check the TYPE_SIZE node pointers\n-\t rather than checking the actual size.  Unfortunately, we have\n-\t found some cases, such as in the Ada \"integer\" type, where\n-\t this is not the case.  Until this problem is solved, we need to\n-\t keep checking the actual size.  */\n-      tree type_name = TYPE_NAME (type);\n-      tree subtype_name = TYPE_NAME (subtype);\n-\n-      if (type_name != NULL && TREE_CODE (type_name) == TYPE_DECL)\n-\ttype_name = DECL_NAME (type_name);\n-\n-      if (subtype_name != NULL && TREE_CODE (subtype_name) == TYPE_DECL)\n-\tsubtype_name = DECL_NAME (subtype_name);\n-\n-      if (type_name == subtype_name)\n-\treturn false;\n-    }\n-\n-  return true;\n-}\n-\n /*  Given a pointer to a tree node for a subrange type, return a pointer\n     to a DIE that describes the given type.  */\n \n static dw_die_ref\n-subrange_type_die (tree type, dw_die_ref context_die)\n+subrange_type_die (tree type, tree low, tree high, dw_die_ref context_die)\n {\n   dw_die_ref subrange_die;\n   const HOST_WIDE_INT size_in_bytes = int_size_in_bytes (type);\n@@ -9469,12 +9417,10 @@ subrange_type_die (tree type, dw_die_ref context_die)\n       add_AT_unsigned (subrange_die, DW_AT_byte_size, size_in_bytes);\n     }\n \n-  if (TYPE_MIN_VALUE (type) != NULL)\n-    add_bound_info (subrange_die, DW_AT_lower_bound,\n-\t\t    TYPE_MIN_VALUE (type));\n-  if (TYPE_MAX_VALUE (type) != NULL)\n-    add_bound_info (subrange_die, DW_AT_upper_bound,\n-\t\t    TYPE_MAX_VALUE (type));\n+  if (low)\n+    add_bound_info (subrange_die, DW_AT_lower_bound, low);\n+  if (high)\n+    add_bound_info (subrange_die, DW_AT_upper_bound, high);\n \n   return subrange_die;\n }\n@@ -9491,7 +9437,7 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n   dw_die_ref sub_die = NULL;\n   tree item_type = NULL;\n   tree qualified_type;\n-  tree name;\n+  tree name, low, high;\n \n   if (code == ERROR_MARK)\n     return NULL;\n@@ -9561,9 +9507,11 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n \t\t       simple_type_size_in_bits (type) / BITS_PER_UNIT);\n       item_type = TREE_TYPE (type);\n     }\n-  else if (is_subrange_type (type))\n+  else if (code == INTEGER_TYPE\n+\t   && TREE_TYPE (type) != NULL_TREE\n+\t   && subrange_type_for_debug_p (type, &low, &high))\n     {\n-      mod_type_die = subrange_type_die (type, context_die);\n+      mod_type_die = subrange_type_die (type, low, high, context_die);\n       item_type = TREE_TYPE (type);\n     }\n   else if (is_base_type (type))"}, {"sha": "32de681e8da3c6f4a347ce6840116de36c506ead", "filename": "gcc/fold-const.c", "status": "modified", "additions": 10, "deletions": 44, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -3741,7 +3741,7 @@ fold_truth_not_expr (tree arg)\n     case NON_LVALUE_EXPR:\n       return invert_truthvalue (TREE_OPERAND (arg, 0));\n \n-    case NOP_EXPR:\n+    CASE_CONVERT:\n       if (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)\n \t{\n \t  t = build1 (TRUTH_NOT_EXPR, type, arg);\n@@ -3750,7 +3750,6 @@ fold_truth_not_expr (tree arg)\n \n       /* ... fall through ...  */\n \n-    case CONVERT_EXPR:\n     case FLOAT_EXPR:\n       t = build1 (TREE_CODE (arg), type,\n \t\t  invert_truthvalue (TREE_OPERAND (arg, 0)));\n@@ -4694,7 +4693,6 @@ static tree\n build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n {\n   tree etype = TREE_TYPE (exp), value;\n-  enum tree_code code;\n \n #ifdef HAVE_canonicalize_funcptr_for_compare\n   /* Disable this optimization for function pointer expressions\n@@ -4777,35 +4775,14 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n     }\n \n   /* Optimize (c>=low) && (c<=high) into (c-low>=0) && (c-low<=high-low).\n-     This requires wrap-around arithmetics for the type of the expression.  */\n-  code = TREE_CODE (etype);\n-  switch (code)\n-    {\n-    case INTEGER_TYPE:\n-    case ENUMERAL_TYPE:\n-    case BOOLEAN_TYPE:\n-      /* There is no requirement that LOW be within the range of ETYPE\n-\t if the latter is a subtype.  It must, however, be within the base\n-\t type of ETYPE.  So be sure we do the subtraction in that type.  */\n-      if (code == INTEGER_TYPE && TREE_TYPE (etype))\n-\t{\n-\t  etype = TREE_TYPE (etype);\n-\t  /* But not in an enumeral or boolean type though.  */\n-\t  code = TREE_CODE (etype);\n-\t}\n+     This requires wrap-around arithmetics for the type of the expression.\n+     First make sure that arithmetics in this type is valid, then make sure\n+     that it wraps around.  */\n+  if (TREE_CODE (etype) == ENUMERAL_TYPE || TREE_CODE (etype) == BOOLEAN_TYPE)\n+    etype = lang_hooks.types.type_for_size (TYPE_PRECISION (etype),\n+\t\t\t\t\t    TYPE_UNSIGNED (etype));\n \n-      if (code != INTEGER_TYPE)\n-\tetype = lang_hooks.types.type_for_size (TYPE_PRECISION (etype),\n-\t\t\t\t\t\tTYPE_UNSIGNED (etype));\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  /* If we don't have wrap-around arithmetics upfront, try to force it.  */\n-  if (TREE_CODE (etype) == INTEGER_TYPE\n-      && !TYPE_OVERFLOW_WRAPS (etype))\n+  if (TREE_CODE (etype) == INTEGER_TYPE && !TYPE_OVERFLOW_WRAPS (etype))\n     {\n       tree utype, minv, maxv;\n \n@@ -7229,11 +7206,6 @@ fold_sign_changed_comparison (enum tree_code code, tree type,\n   if (TYPE_PRECISION (inner_type) != TYPE_PRECISION (outer_type))\n     return NULL_TREE;\n \n-  /* If the conversion is from an integral subtype to its basetype\n-     leave it alone.  */\n-  if (TREE_TYPE (inner_type) == outer_type)\n-    return NULL_TREE;\n-\n   if (TREE_CODE (arg1) != INTEGER_CST\n       && !(CONVERT_EXPR_P (arg1)\n \t   && TREE_TYPE (TREE_OPERAND (arg1, 0)) == inner_type))\n@@ -8291,9 +8263,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t transformation effectively doesn't preserve non-maximal ranges.  */\n       if (TREE_CODE (type) == INTEGER_TYPE\n \t  && TREE_CODE (op0) == BIT_AND_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (op0, 1)) == INTEGER_CST\n-\t  /* Not if the conversion is to the sub-type.  */\n-\t  && TREE_TYPE (type) != TREE_TYPE (op0))\n+\t  && TREE_CODE (TREE_OPERAND (op0, 1)) == INTEGER_CST)\n \t{\n \t  tree and = op0;\n \t  tree and0 = TREE_OPERAND (and, 0), and1 = TREE_OPERAND (and, 1);\n@@ -8410,11 +8380,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t   || POINTER_TYPE_P (type))\n \t  && (INTEGRAL_TYPE_P (TREE_TYPE (op0))\n \t      || POINTER_TYPE_P (TREE_TYPE (op0)))\n-\t  && TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (op0))\n-\t  /* Do not muck with VIEW_CONVERT_EXPRs that convert from\n-\t     a sub-type to its base type as generated by the Ada FE.  */\n-\t  && !(INTEGRAL_TYPE_P (TREE_TYPE (op0))\n-\t       && TREE_TYPE (TREE_TYPE (op0))))\n+\t  && TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (op0)))\n \treturn fold_convert (type, op0);\n \n       /* Strip inner integral conversions that do not change the precision.  */"}, {"sha": "506b527a84453d8761d1614931c8e9b33688cf91", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -161,6 +161,7 @@ extern tree lhd_make_node (enum tree_code);\n   lhd_omp_firstprivatize_type_sizes\n #define LANG_HOOKS_TYPE_HASH_EQ\t\tNULL\n #define LANG_HOOKS_GET_ARRAY_DESCR_INFO\tNULL\n+#define LANG_HOOKS_GET_SUBRANGE_BOUNDS\tNULL\n #define LANG_HOOKS_RECONSTRUCT_COMPLEX_TYPE reconstruct_complex_type\n #define LANG_HOOKS_HASH_TYPES\t\ttrue\n \n@@ -177,6 +178,7 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES, \\\n   LANG_HOOKS_TYPE_HASH_EQ, \\\n   LANG_HOOKS_GET_ARRAY_DESCR_INFO, \\\n+  LANG_HOOKS_GET_SUBRANGE_BOUNDS, \\\n   LANG_HOOKS_RECONSTRUCT_COMPLEX_TYPE, \\\n   LANG_HOOKS_HASH_TYPES \\\n }"}, {"sha": "06ad6c1fc521c0454df68e107fb49040ec6bd944", "filename": "gcc/langhooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -130,6 +130,9 @@ struct lang_hooks_for_types\n      for the debugger about the array bounds, strides, etc.  */\n   bool (*get_array_descr_info) (const_tree, struct array_descr_info *);\n \n+  /* Fill in information for the debugger about the bounds of TYPE.  */\n+  void (*get_subrange_bounds) (const_tree, tree *, tree *);\n+\n   /* If we requested a pointer to a vector, build up the pointers that\n      we stripped off while looking for the inner type.  Similarly for\n      return values from functions.  The argument TYPE is the top of the"}, {"sha": "495f95a8be7ede91f95e39dc087854462b392e8e", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -1100,21 +1100,6 @@ nb_vars_in_chrec (tree chrec)\n     }\n }\n \n-/* Returns true if TYPE is a type in that we cannot directly perform\n-   arithmetics, even though it is a scalar type.  */\n-\n-static bool\n-avoid_arithmetics_in_type_p (const_tree type)\n-{\n-  /* Ada frontend uses subtypes -- an arithmetic cannot be directly performed\n-     in the subtype, but a base type must be used, and the result then can\n-     be casted to the subtype.  */\n-  if (TREE_CODE (type) == INTEGER_TYPE && TREE_TYPE (type) != NULL_TREE)\n-    return true;\n-\n-  return false;\n-}\n-\n static tree chrec_convert_1 (tree, tree, gimple, bool);\n \n /* Converts BASE and STEP of affine scev to TYPE.  LOOP is the loop whose iv\n@@ -1136,10 +1121,6 @@ convert_affine_scev (struct loop *loop, tree type,\n   tree new_base, new_step;\n   tree step_type = POINTER_TYPE_P (type) ? sizetype : type;\n \n-  /* If we cannot perform arithmetic in TYPE, avoid creating an scev.  */\n-  if (avoid_arithmetics_in_type_p (type))\n-    return false;\n-\n   /* In general,\n      (TYPE) (BASE + STEP * i) = (TYPE) BASE + (TYPE -- sign extend) STEP * i,\n      but we must check some assumptions.\n@@ -1342,10 +1323,6 @@ chrec_convert_aggressive (tree type, tree chrec)\n   if (TYPE_PRECISION (type) > TYPE_PRECISION (inner_type))\n     return NULL_TREE;\n \n-  /* If we cannot perform arithmetic in TYPE, avoid creating an scev.  */\n-  if (avoid_arithmetics_in_type_p (type))\n-    return NULL_TREE;\n-\n   rtype = POINTER_TYPE_P (type) ? sizetype : type;\n \n   left = CHREC_LEFT (chrec);"}, {"sha": "13a79dcf39a35bd00fee45101784a50ed4235cf1", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -923,19 +923,9 @@ useless_type_conversion_p_1 (tree outer_type, tree inner_type)\n \t  || TYPE_PRECISION (inner_type) != TYPE_PRECISION (outer_type))\n \treturn false;\n \n-      /* Conversions from a non-base to a base type are not useless.\n-\t This way we preserve the invariant to do arithmetic in\n-\t base types only.  */\n-      if (TREE_TYPE (inner_type)\n-\t  && TREE_TYPE (inner_type) != inner_type\n-\t  && (TREE_TYPE (outer_type) == outer_type\n-\t      || TREE_TYPE (outer_type) == NULL_TREE))\n-\treturn false;\n-\n       /* We don't need to preserve changes in the types minimum or\n \t maximum value in general as these do not generate code\n \t unless the types precisions are different.  */\n-\n       return true;\n     }\n "}, {"sha": "a0f4c3d2f3ada0ffa7818f321b0cf9f496825cea", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -121,33 +121,25 @@ DEF_VEC_ALLOC_O(switch_update, heap);\n static VEC (switch_update, heap) *to_update_switch_stmts;\n \n \n-/* Return the maximum value for TYPEs base type.  */\n+/* Return the maximum value for TYPE.  */\n \n static inline tree\n vrp_val_max (const_tree type)\n {\n   if (!INTEGRAL_TYPE_P (type))\n     return NULL_TREE;\n \n-  /* For integer sub-types the values for the base type are relevant.  */\n-  if (TREE_TYPE (type))\n-    type = TREE_TYPE (type);\n-\n   return TYPE_MAX_VALUE (type);\n }\n \n-/* Return the minimum value for TYPEs base type.  */\n+/* Return the minimum value for TYPE.  */\n \n static inline tree\n vrp_val_min (const_tree type)\n {\n   if (!INTEGRAL_TYPE_P (type))\n     return NULL_TREE;\n \n-  /* For integer sub-types the values for the base type are relevant.  */\n-  if (TREE_TYPE (type))\n-    type = TREE_TYPE (type);\n-\n   return TYPE_MIN_VALUE (type);\n }\n \n@@ -188,11 +180,7 @@ vrp_val_is_min (const_tree val)\n static inline bool\n needs_overflow_infinity (const_tree type)\n {\n-  return (INTEGRAL_TYPE_P (type)\n-\t  && !TYPE_OVERFLOW_WRAPS (type)\n-\t  /* Integer sub-types never overflow as they are never\n-\t     operands of arithmetic operators.  */\n-\t  && !(TREE_TYPE (type) && TREE_TYPE (type) != type));\n+  return INTEGRAL_TYPE_P (type) && !TYPE_OVERFLOW_WRAPS (type);\n }\n \n /* Return whether TYPE can support our overflow infinity\n@@ -2702,13 +2690,6 @@ extract_range_from_unary_expr (value_range_t *vr, enum tree_code code,\n       tree inner_type = TREE_TYPE (op0);\n       tree outer_type = type;\n \n-      /* Always use base-types here.  This is important for the\n-\t correct signedness.  */\n-      if (TREE_TYPE (inner_type))\n-\tinner_type = TREE_TYPE (inner_type);\n-      if (TREE_TYPE (outer_type))\n-\touter_type = TREE_TYPE (outer_type);\n-\n       /* If VR0 is varying and we increase the type precision, assume\n \t a full range for the following transformation.  */\n       if (vr0.type == VR_VARYING"}, {"sha": "92f16e7a88fef9e44e5a32e19075f2cdb58d7840", "filename": "gcc/tree.c", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -5696,6 +5696,57 @@ build_range_type (tree type, tree lowval, tree highval)\n     return itype;\n }\n \n+/* Return true if the debug information for TYPE, a subtype, should be emitted\n+   as a subrange type.  If so, set LOWVAL to the low bound and HIGHVAL to the\n+   high bound, respectively.  Sometimes doing so unnecessarily obfuscates the\n+   debug info and doesn't reflect the source code.  */\n+\n+bool\n+subrange_type_for_debug_p (const_tree type, tree *lowval, tree *highval)\n+{\n+  tree base_type = TREE_TYPE (type), low, high;\n+\n+  /* Subrange types have a base type which is an integral type.  */\n+  if (!INTEGRAL_TYPE_P (base_type))\n+    return false;\n+\n+  /* Get the real bounds of the subtype.  */\n+  if (lang_hooks.types.get_subrange_bounds)\n+    lang_hooks.types.get_subrange_bounds (type, &low, &high);\n+  else\n+    {\n+      low = TYPE_MIN_VALUE (type);\n+      high = TYPE_MAX_VALUE (type);\n+    }\n+\n+  /* If the type and its base type have the same representation and the same\n+     name, then the type is not a subrange but a copy of the base type.  */\n+  if ((TREE_CODE (base_type) == INTEGER_TYPE\n+       || TREE_CODE (base_type) == BOOLEAN_TYPE)\n+      && int_size_in_bytes (type) == int_size_in_bytes (base_type)\n+      && tree_int_cst_equal (low, TYPE_MIN_VALUE (base_type))\n+      && tree_int_cst_equal (high, TYPE_MAX_VALUE (base_type)))\n+    {\n+      tree type_name = TYPE_NAME (type);\n+      tree base_type_name = TYPE_NAME (base_type);\n+\n+      if (type_name && TREE_CODE (type_name) == TYPE_DECL)\n+\ttype_name = DECL_NAME (type_name);\n+\n+      if (base_type_name && TREE_CODE (base_type_name) == TYPE_DECL)\n+\tbase_type_name = DECL_NAME (base_type_name);\n+\n+      if (type_name == base_type_name)\n+\treturn false;\n+    }\n+\n+  if (lowval)\n+    *lowval = low;\n+  if (highval)\n+    *highval = high;\n+  return true;\n+}\n+\n /* Just like build_index_type, but takes lowval and highval instead\n    of just highval (maxval).  */\n "}, {"sha": "52c4fdf017ff0fb37ff4e00801a8ff64b2fb47db", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fb43a1a4480e7a0a106fbe38144d1af50b476a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=84fb43a1a4480e7a0a106fbe38144d1af50b476a", "patch": "@@ -4860,6 +4860,7 @@ extern void build_common_tree_nodes_2 (int);\n extern void build_common_builtin_nodes (void);\n extern tree build_nonstandard_integer_type (unsigned HOST_WIDE_INT, int);\n extern tree build_range_type (tree, tree, tree);\n+extern bool subrange_type_for_debug_p (const_tree, tree *, tree *);\n extern HOST_WIDE_INT int_cst_value (const_tree);\n \n extern bool fields_compatible_p (const_tree, const_tree);"}]}