{"sha": "4ebc46e969f2cdf0e59f04ce755dcf75411fc45e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGViYzQ2ZTk2OWYyY2RmMGU1OWYwNGNlNzU1ZGNmNzU0MTFmYzQ1ZQ==", "commit": {"author": {"name": "Florian Weimer", "email": "fweimer@redhat.com", "date": "2012-06-25T17:03:10Z"}, "committer": {"name": "Florian Weimer", "email": "fw@gcc.gnu.org", "date": "2012-06-25T17:03:10Z"}, "message": "C++: Reject variably modified types in operator new\n\nFrom-SVN: r188948", "tree": {"sha": "6bc99a9a98432fdbf6966014f5b49826eca80801", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bc99a9a98432fdbf6966014f5b49826eca80801"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/comments", "author": {"login": "fweimer-rh", "id": 75532728, "node_id": "MDQ6VXNlcjc1NTMyNzI4", "avatar_url": "https://avatars.githubusercontent.com/u/75532728?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fweimer-rh", "html_url": "https://github.com/fweimer-rh", "followers_url": "https://api.github.com/users/fweimer-rh/followers", "following_url": "https://api.github.com/users/fweimer-rh/following{/other_user}", "gists_url": "https://api.github.com/users/fweimer-rh/gists{/gist_id}", "starred_url": "https://api.github.com/users/fweimer-rh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fweimer-rh/subscriptions", "organizations_url": "https://api.github.com/users/fweimer-rh/orgs", "repos_url": "https://api.github.com/users/fweimer-rh/repos", "events_url": "https://api.github.com/users/fweimer-rh/events{/privacy}", "received_events_url": "https://api.github.com/users/fweimer-rh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9e94a7fc5ab770928b9e6a2b74e292d35b4c94da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e94a7fc5ab770928b9e6a2b74e292d35b4c94da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e94a7fc5ab770928b9e6a2b74e292d35b4c94da"}], "stats": {"total": 354, "additions": 317, "deletions": 37}, "files": [{"sha": "fbaca5106c25508a270979a8570edcdeee1f287e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4ebc46e969f2cdf0e59f04ce755dcf75411fc45e", "patch": "@@ -1,3 +1,11 @@\n+2012-06-25  Florian Weimer  <fweimer@redhat.com>\n+\n+\t* init.c (build_new_1): Warn about (T[N]) for variable N, and\n+\treject T[M][N].\n+\n+\t* parser.c (cp_parser_direct_new_declarator): Accept non-constant\n+\texpressions.  Handled now in build_new_1.\n+\n 2012-06-25  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/53202"}, {"sha": "5a81643b5d941a2ade026b77a7e7b17c5f753c74", "filename": "gcc/cp/init.c", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4ebc46e969f2cdf0e59f04ce755dcf75411fc45e", "patch": "@@ -2175,6 +2175,7 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n   tree pointer_type;\n   tree non_const_pointer_type;\n   tree outer_nelts = NULL_TREE;\n+  bool outer_nelts_from_type = false;\n   tree alloc_call, alloc_expr;\n   /* The address returned by the call to \"operator new\".  This node is\n      a VAR_DECL and is therefore reusable.  */\n@@ -2209,21 +2210,61 @@ build_new_1 (VEC(tree,gc) **placement, tree type, tree nelts,\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n+      /* Transforms new (T[N]) to new T[N].  The former is a GNU\n+\t extension for variable N.  (This also covers new T where T is\n+\t a VLA typedef.)  */\n       array_p = true;\n       nelts = array_type_nelts_top (type);\n       outer_nelts = nelts;\n       type = TREE_TYPE (type);\n+      outer_nelts_from_type = true;\n     }\n \n   /* If our base type is an array, then make sure we know how many elements\n      it has.  */\n   for (elt_type = type;\n        TREE_CODE (elt_type) == ARRAY_TYPE;\n        elt_type = TREE_TYPE (elt_type))\n-    nelts = cp_build_binary_op (input_location,\n-\t\t\t\tMULT_EXPR, nelts,\n-\t\t\t\tarray_type_nelts_top (elt_type),\n-\t\t\t\tcomplain);\n+    {\n+      tree inner_nelts = array_type_nelts_top (elt_type);\n+      tree inner_nelts_cst = maybe_constant_value (inner_nelts);\n+      if (!TREE_CONSTANT (inner_nelts_cst))\n+\t{\n+\t  if (complain & tf_error)\n+\t    {\n+\t      error_at (EXPR_LOC_OR_HERE (inner_nelts),\n+\t\t\t\"array size in operator new must be constant\");\n+\t      cxx_constant_value(inner_nelts);\n+\t    }\n+\t  nelts = error_mark_node;\n+\t}\n+      if (nelts != error_mark_node)\n+\tnelts = cp_build_binary_op (input_location,\n+\t\t\t\t    MULT_EXPR, nelts,\n+\t\t\t\t    inner_nelts_cst,\n+\t\t\t\t    complain);\n+    }\n+\n+  if (variably_modified_type_p (elt_type, NULL_TREE) && (complain & tf_error))\n+    {\n+      error (\"variably modified type not allowed in operator new\");\n+      return error_mark_node;\n+    }\n+\n+  if (nelts == error_mark_node)\n+    return error_mark_node;\n+\n+  /* Warn if we performed the (T[N]) to T[N] transformation and N is\n+     variable.  */\n+  if (outer_nelts_from_type\n+      && !TREE_CONSTANT (maybe_constant_value (outer_nelts)))\n+    {\n+      if (complain & tf_warning_or_error)\n+\tpedwarn(EXPR_LOC_OR_HERE (outer_nelts), OPT_Wvla,\n+\t\t\"ISO C++ does not support variable-length array types\");\n+      else\n+\treturn error_mark_node;\n+    }\n \n   if (TREE_CODE (elt_type) == VOID_TYPE)\n     {"}, {"sha": "46f1401b66fda5f8811eb94dc3e37140c393c3fc", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 21, "deletions": 28, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=4ebc46e969f2cdf0e59f04ce755dcf75411fc45e", "patch": "@@ -6883,41 +6883,34 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n   while (true)\n     {\n       tree expression;\n+      cp_token *token;\n \n       /* Look for the opening `['.  */\n       cp_parser_require (parser, CPP_OPEN_SQUARE, RT_OPEN_SQUARE);\n-      /* The first expression is not required to be constant.  */\n-      if (!declarator)\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+      expression = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+      /* The standard requires that the expression have integral\n+\t type.  DR 74 adds enumeration types.  We believe that the\n+\t real intent is that these expressions be handled like the\n+\t expression in a `switch' condition, which also allows\n+\t classes with a single conversion to integral or\n+\t enumeration type.  */\n+      if (!processing_template_decl)\n \t{\n-\t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\t  expression = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n-\t  /* The standard requires that the expression have integral\n-\t     type.  DR 74 adds enumeration types.  We believe that the\n-\t     real intent is that these expressions be handled like the\n-\t     expression in a `switch' condition, which also allows\n-\t     classes with a single conversion to integral or\n-\t     enumeration type.  */\n-\t  if (!processing_template_decl)\n+\t  expression\n+\t    = build_expr_type_conversion (WANT_INT | WANT_ENUM,\n+\t\t\t\t\t  expression,\n+\t\t\t\t\t  /*complain=*/true);\n+\t  if (!expression)\n \t    {\n-\t      expression\n-\t\t= build_expr_type_conversion (WANT_INT | WANT_ENUM,\n-\t\t\t\t\t      expression,\n-\t\t\t\t\t      /*complain=*/true);\n-\t      if (!expression)\n-\t\t{\n-\t\t  error_at (token->location,\n-\t\t\t    \"expression in new-declarator must have integral \"\n-\t\t\t    \"or enumeration type\");\n-\t\t  expression = error_mark_node;\n-\t\t}\n+\t      error_at (token->location,\n+\t\t\t\"expression in new-declarator must have integral \"\n+\t\t\t\"or enumeration type\");\n+\t      expression = error_mark_node;\n \t    }\n \t}\n-      /* But all the other expressions must be.  */\n-      else\n-\texpression\n-\t  = cp_parser_constant_expression (parser,\n-\t\t\t\t\t   /*allow_non_constant=*/false,\n-\t\t\t\t\t   NULL);\n+\n       /* Look for the closing `]'.  */\n       cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n "}, {"sha": "40547dc30320e1788e21c9ec5a83f12b09e14bbf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4ebc46e969f2cdf0e59f04ce755dcf75411fc45e", "patch": "@@ -1,3 +1,12 @@\n+2012-06-25  Florian Weimer  <fweimer@redhat.com>\n+\n+\t* g++.dg/init/new35.C: New.\n+\t* g++.dg/init/new36.C: New.\n+\t* g++.dg/init/new37.C: New.\n+\t* g++.dg/ext/vla5.C: New warning.\n+\t* g++.dg/ext/vla8.C: New warning.\n+\t* g++.dg/cpp0x/regress/debug-debug7.C: Update diagnostics.\n+\n 2012-06-25  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>\n             James Greenhalgh  <james.greenhalgh@arm.com>\n "}, {"sha": "d3f14f4e242813ff13fc942dea72b9cac3c6aa31", "filename": "gcc/testsuite/g++.dg/cpp0x/regress/debug-debug7.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fregress%2Fdebug-debug7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fregress%2Fdebug-debug7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fregress%2Fdebug-debug7.C?ref=4ebc46e969f2cdf0e59f04ce755dcf75411fc45e", "patch": "@@ -7,8 +7,8 @@ int\n main() {\n \n   int a = 4;\n-  int b = 5;\t\t\t// { dg-message \"not const\" }\n-  int (*x)[b] = new int[a][b];\t// { dg-error \"not usable\" }\n+  int b = 5;\n+  int (*x)[b] = new int[a][b]; // { dg-error \"array size.*must be constant|usable in a constant\" }\n \n   x[2][1] = 7;\n "}, {"sha": "2457e34f18336b7d81a52ed110ad5c8883a78f55", "filename": "gcc/testsuite/g++.dg/ext/vla5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla5.C?ref=4ebc46e969f2cdf0e59f04ce755dcf75411fc45e", "patch": "@@ -6,5 +6,5 @@\n void\n test (int a)\n {\n-  new (char[a]);\n+  new (char[a]); // { dg-warning \"variable-length array\" }\n }"}, {"sha": "1c6000fa3b786b3aa0e1b9a1c76f1d7697c39e8d", "filename": "gcc/testsuite/g++.dg/ext/vla8.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla8.C?ref=4ebc46e969f2cdf0e59f04ce755dcf75411fc45e", "patch": "@@ -8,8 +8,8 @@ struct AvlTreeIter\n \n   AvlTreeIter()\n   {\n-    new (void* [Num()]);\n+    new (void* [Num()]); // { dg-warning \"variable-length array\" }\n   }\n };\n \n-AvlTreeIter<int> a;\n+AvlTreeIter<int> a; // { dg-message \"from here\" }"}, {"sha": "c5f79aa2f802949d17618467b693adb9f34870a3", "filename": "gcc/testsuite/g++.dg/init/new35.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew35.C?ref=4ebc46e969f2cdf0e59f04ce755dcf75411fc45e", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile }\n+// { dg-options \"\" }\n+\n+int\n+main (int argc, char **argv)\n+{\n+  typedef char A[argc];\n+  new A; // { dg-warning \"variable-length array types|not a constant\" }\n+  new A[0]; // { dg-error \"must be constant|not a constant\" }\n+  new A[5]; // { dg-error \"must be constant|not a constant\" }\n+  new (A[0]); // { dg-error \"must be constant|not a constant\" }\n+  new (A[5]); // { dg-error \"must be constant|not a constant\" }\n+}"}, {"sha": "c9b7af2d8710f205832b065db1d0cbe0713fdab8", "filename": "gcc/testsuite/g++.dg/init/new36.C", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew36.C?ref=4ebc46e969f2cdf0e59f04ce755dcf75411fc45e", "patch": "@@ -0,0 +1,153 @@\n+// Testcase for invocation of constructors/destructors in operator new[].\n+// { dg-do run }\n+\n+#include <stdlib.h>\n+\n+struct E {\n+  virtual ~E() { }\n+};\n+\n+struct S {\n+  S();\n+  ~S();\n+};\n+\n+static int count;\n+static int max;\n+static int throwAfter = -1;\n+static S *pS;\n+\n+S::S()\n+{\n+  if (throwAfter >= 0 && count >= throwAfter)\n+    throw E();\n+  if (pS)\n+    {\n+      ++pS;\n+      if (this != pS)\n+\tabort();\n+    }\n+  else\n+    pS = this;\n+  ++count;\n+  max = count;\n+}\n+\n+S::~S()\n+{\n+  if (count > 1)\n+    {\n+      if (this != pS)\n+\tabort();\n+      --pS;\n+    }\n+  else\n+    pS = 0;\n+  --count;\n+}\n+\n+void __attribute__((noinline)) doit(int n)\n+{\n+  {\n+    S *s = new S[n];\n+    if (count != n)\n+      abort();\n+    if (pS != s + n - 1)\n+      abort();\n+    delete [] s;\n+    if (count != 0)\n+      abort();\n+  }\n+  throwAfter = 2;\n+  max = 0;\n+  try\n+    {\n+      new S[n];\n+      abort();\n+    }\n+  catch (E)\n+    {\n+      if (max != 2)\n+\tabort();\n+    }\n+  throwAfter = -1;\n+}\n+\n+int main()\n+{\n+  {\n+    S s;\n+    if (count != 1)\n+      abort();\n+    if (pS != &s)\n+      abort();\n+  }\n+  if (count != 0)\n+    abort();\n+  {\n+    S *s = new S;\n+    if (count != 1)\n+      abort();\n+    if (pS != s)\n+      abort();\n+    delete s;\n+    if (count != 0)\n+      abort();\n+  }\n+  {\n+    S *s = new S[1];\n+    if (count != 1)\n+      abort();\n+    if (pS != s)\n+      abort();\n+    delete [] s;\n+    if (count != 0)\n+      abort();\n+  }\n+  {\n+    S *s = new S[5];\n+    if (count != 5)\n+      abort();\n+    if (pS != s + 4)\n+      abort();\n+    delete [] s;\n+    if (count != 0)\n+      abort();\n+  }\n+  typedef S A[5];\n+  {\n+    S *s = new A;\n+    if (count != 5)\n+      abort();\n+    if (pS != s + 4)\n+      abort();\n+    delete [] s;\n+    if (count != 0)\n+      abort();\n+  }\n+  throwAfter = 2;\n+  max = 0;\n+  try\n+    {\n+      new S[5];\n+      abort();\n+    }\n+  catch (E)\n+    {\n+      if (max != 2)\n+\tabort();\n+    }\n+  max = 0;\n+  try\n+    {\n+      new A;\n+      abort();\n+    }\n+  catch (E)\n+    {\n+      if (max != 2)\n+\tabort();\n+    }\n+  throwAfter = -1;\n+  doit(5);\n+}"}, {"sha": "82ca18b7aeba21b2d601dca32801f695cc1f8048", "filename": "gcc/testsuite/g++.dg/init/new37.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew37.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ebc46e969f2cdf0e59f04ce755dcf75411fc45e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew37.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew37.C?ref=4ebc46e969f2cdf0e59f04ce755dcf75411fc45e", "patch": "@@ -0,0 +1,63 @@\n+// { dg-do compile }\n+\n+void\n+nonconst(int n)\n+{\n+  new (long[n][n]); // { dg-error \"variable length|array size|not a constant\" }\n+  new long[n][n]; // { dg-error \"variable length|array size|not a constant\" }\n+}\n+\n+template <typename T>\n+void *\n+callnew(int n)\n+{\n+  return new long[n][T::n];\n+}\n+\n+template <typename T>\n+void *\n+callnew_fail_1(int n)\n+{\n+  return new long[n][T::n]; // { dg-error \"variable length|array size|usable in a constant\" }\n+}\n+\n+template <typename T>\n+void *\n+callnew_fail_2()\n+{\n+  return new long[T::n]; // { dg-error \"size in array new\" }\n+}\n+\n+template <typename T>\n+void *\n+callnew_fail_3()\n+{\n+  return new T[2][T::n]; // { dg-error \"size of array has non-integral type\" }\n+}\n+\n+struct T1 {\n+  static int n;\n+};\n+\n+struct T2 {\n+  static const double n = 2; // { dg-error \"non-integral type\" }\n+};\n+\n+struct T3 {\n+  static const int n = 2;\n+};\n+\n+struct T4 {\n+  enum { n = 3 };\n+};\n+\n+void\n+test_callnew(int n)\n+{\n+  new long[0.2]; // { dg-error \"integral or enumeration type\" }\n+  callnew_fail_1<T1>(n);\n+  callnew_fail_2<T2>();\n+  callnew_fail_3<T2>();\n+  callnew<T3>(n);\n+  callnew<T4>(n);\n+}"}]}