{"sha": "bfcc4dd71b5e17488c85a42db86aef433ac712fd", "node_id": "C_kwDOANBUbNoAKGJmY2M0ZGQ3MWI1ZTE3NDg4Yzg1YTQyZGI4NmFlZjQzM2FjNzEyZmQ", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2021-11-30T10:43:40Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-01-05T11:32:36Z"}, "message": "[Ada] Add contracts for the proof of System.Arith_128\n\ngcc/ada/\n\n\t* libgnat/s-arit128.adb: Mark in SPARK.\n\t* libgnat/s-arit128.ads: Add functional contracts.", "tree": {"sha": "16efe02c8e8ef41b4fb9c77412c4fbe92e79fea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16efe02c8e8ef41b4fb9c77412c4fbe92e79fea5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfcc4dd71b5e17488c85a42db86aef433ac712fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfcc4dd71b5e17488c85a42db86aef433ac712fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfcc4dd71b5e17488c85a42db86aef433ac712fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfcc4dd71b5e17488c85a42db86aef433ac712fd/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c58372ad22f94d21b15ae2f2838e761b36b3486", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c58372ad22f94d21b15ae2f2838e761b36b3486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c58372ad22f94d21b15ae2f2838e761b36b3486"}], "stats": {"total": 104, "additions": 96, "deletions": 8}, "files": [{"sha": "d5f6c3d64cdb32ac058ffcad2f6d32fb855a2d59", "filename": "gcc/ada/libgnat/s-arit128.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfcc4dd71b5e17488c85a42db86aef433ac712fd/gcc%2Fada%2Flibgnat%2Fs-arit128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfcc4dd71b5e17488c85a42db86aef433ac712fd/gcc%2Fada%2Flibgnat%2Fs-arit128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit128.adb?ref=bfcc4dd71b5e17488c85a42db86aef433ac712fd", "patch": "@@ -31,7 +31,9 @@\n \n with System.Arith_Double;\n \n-package body System.Arith_128 is\n+package body System.Arith_128\n+  with SPARK_Mode\n+is\n \n    subtype Uns128 is Interfaces.Unsigned_128;\n    subtype Uns64  is Interfaces.Unsigned_64;"}, {"sha": "e712c3c9d624d7048290f2f0e525f11e5c24d0c5", "filename": "gcc/ada/libgnat/s-arit128.ads", "status": "modified", "additions": 93, "deletions": 7, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfcc4dd71b5e17488c85a42db86aef433ac712fd/gcc%2Fada%2Flibgnat%2Fs-arit128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfcc4dd71b5e17488c85a42db86aef433ac712fd/gcc%2Fada%2Flibgnat%2Fs-arit128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit128.ads?ref=bfcc4dd71b5e17488c85a42db86aef433ac712fd", "patch": "@@ -36,31 +36,102 @@\n pragma Restrictions (No_Elaboration_Code);\n --  Allow direct call from gigi generated code\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced\n+--  by setting the corresponding assertion policy to Ignore. Postconditions\n+--  and contract cases should not be executed at runtime as well, in order\n+--  not to slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Contract_Cases => Ignore,\n+                         Ghost          => Ignore);\n+\n+with Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n with Interfaces;\n \n-package System.Arith_128 is\n-   pragma Pure;\n+package System.Arith_128\n+  with Pure, SPARK_Mode\n+is\n+   use type Ada.Numerics.Big_Numbers.Big_Integers_Ghost.Big_Integer;\n+   use type Interfaces.Integer_128;\n \n    subtype Int128 is Interfaces.Integer_128;\n \n-   function Add_With_Ovflo_Check128 (X, Y : Int128) return Int128;\n+   subtype Big_Integer is\n+     Ada.Numerics.Big_Numbers.Big_Integers_Ghost.Big_Integer\n+   with Ghost;\n+\n+   package Signed_Conversion is new\n+     Ada.Numerics.Big_Numbers.Big_Integers_Ghost.Signed_Conversions\n+     (Int => Int128);\n+\n+   function Big (Arg : Int128) return Big_Integer is\n+     (Signed_Conversion.To_Big_Integer (Arg))\n+   with Ghost;\n+\n+   function In_Int128_Range (Arg : Big_Integer) return Boolean is\n+     (Ada.Numerics.Big_Numbers.Big_Integers_Ghost.In_Range\n+       (Arg, Big (Int128'First), Big (Int128'Last)))\n+   with Ghost;\n+\n+   function Add_With_Ovflo_Check128 (X, Y : Int128) return Int128\n+   with\n+     Pre  => In_Int128_Range (Big (X) + Big (Y)),\n+     Post => Add_With_Ovflo_Check128'Result = X + Y;\n    --  Raises Constraint_Error if sum of operands overflows 128 bits,\n    --  otherwise returns the 128-bit signed integer sum.\n \n-   function Subtract_With_Ovflo_Check128 (X, Y : Int128) return Int128;\n+   function Subtract_With_Ovflo_Check128 (X, Y : Int128) return Int128\n+   with\n+     Pre  => In_Int128_Range (Big (X) - Big (Y)),\n+     Post => Subtract_With_Ovflo_Check128'Result = X - Y;\n    --  Raises Constraint_Error if difference of operands overflows 128\n    --  bits, otherwise returns the 128-bit signed integer difference.\n \n-   function Multiply_With_Ovflo_Check128 (X, Y : Int128) return Int128;\n+   function Multiply_With_Ovflo_Check128 (X, Y : Int128) return Int128\n+   with\n+     Pre  => In_Int128_Range (Big (X) * Big (Y)),\n+     Post => Multiply_With_Ovflo_Check128'Result = X * Y;\n    pragma Export (C, Multiply_With_Ovflo_Check128, \"__gnat_mulv128\");\n    --  Raises Constraint_Error if product of operands overflows 128\n    --  bits, otherwise returns the 128-bit signed integer product.\n    --  Gigi may also call this routine directly.\n \n+   function Same_Sign (X, Y : Big_Integer) return Boolean is\n+     (X = Big (Int128'(0))\n+        or else Y = Big (Int128'(0))\n+        or else (X < Big (Int128'(0))) = (Y < Big (Int128'(0))))\n+   with Ghost;\n+\n+   function Round_Quotient (X, Y, Q, R : Big_Integer) return Big_Integer is\n+     (if abs R > (abs Y - Big (Int128'(1))) / Big (Int128'(2)) then\n+       (if Same_Sign (X, Y) then Q + Big (Int128'(1))\n+        else Q - Big (Int128'(1)))\n+      else\n+        Q)\n+   with\n+     Ghost,\n+     Pre => Y /= 0 and then Q = X / Y and then R = X rem Y;\n+\n    procedure Scaled_Divide128\n      (X, Y, Z : Int128;\n       Q, R    : out Int128;\n-      Round   : Boolean);\n+      Round   : Boolean)\n+   with\n+     Pre  => Z /= 0\n+       and then In_Int128_Range\n+         (if Round then Round_Quotient (Big (X) * Big (Y), Big (Z),\n+                                        Big (X) * Big (Y) / Big (Z),\n+                                        Big (X) * Big (Y) rem Big (Z))\n+          else Big (X) * Big (Y) / Big (Z)),\n+     Post => Big (R) = Big (X) * Big (Y) rem Big (Z)\n+       and then\n+         (if Round then\n+            Big (Q) = Round_Quotient (Big (X) * Big (Y), Big (Z),\n+                                      Big (X) * Big (Y) / Big (Z), Big (R))\n+          else\n+            Big (Q) = Big (X) * Big (Y) / Big (Z));\n    --  Performs the division of (X * Y) / Z, storing the quotient in Q\n    --  and the remainder in R. Constraint_Error is raised if Z is zero,\n    --  or if the quotient does not fit in 128 bits. Round indicates if\n@@ -72,7 +143,22 @@ package System.Arith_128 is\n    procedure Double_Divide128\n      (X, Y, Z : Int128;\n       Q, R    : out Int128;\n-      Round   : Boolean);\n+      Round   : Boolean)\n+   with\n+     Pre  => Y /= 0\n+       and then Z /= 0\n+       and then In_Int128_Range\n+         (if Round then Round_Quotient (Big (X), Big (Y) * Big (Z),\n+                                        Big (X) / (Big (Y) * Big (Z)),\n+                                        Big (X) rem (Big (Y) * Big (Z)))\n+          else Big (X) / (Big (Y) * Big (Z))),\n+     Post => Big (R) = Big (X) rem (Big (Y) * Big (Z))\n+       and then\n+         (if Round then\n+            Big (Q) = Round_Quotient (Big (X), Big (Y) * Big (Z),\n+                                      Big (X) / (Big (Y) * Big (Z)), Big (R))\n+          else\n+            Big (Q) = Big (X) / (Big (Y) * Big (Z)));\n    --  Performs the division X / (Y * Z), storing the quotient in Q and\n    --  the remainder in R. Constraint_Error is raised if Y or Z is zero,\n    --  or if the quotient does not fit in 128 bits. Round indicates if the"}]}