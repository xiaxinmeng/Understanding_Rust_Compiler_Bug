{"sha": "571d54deb6edc944f1e9f361302b2fa99b568d64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTcxZDU0ZGViNmVkYzk0NGYxZTlmMzYxMzAyYjJmYTk5YjU2OGQ2NA==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2010-08-17T08:20:03Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2010-08-17T08:20:03Z"}, "message": "re PR fortran/38936 ([F03] ASSOCIATE construct / improved SELECT TYPE (a=>expr))\n\n2010-08-17  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/38936\n\t* gfortran.h (struct gfc_association_list): New member `where'.\n\t(gfc_is_associate_pointer) New method.\n\t* match.c (gfc_match_associate): Remember locus for each associate\n\tname matched and do not try to set variable flag.\n\t* parse.c (parse_associate): Use remembered locus for symbols.\n\t* primary.c (match_variable): Instead of variable-flag check for\n\tassociate names set it for all such names used.\n\t* symbol.c (gfc_is_associate_pointer): New method.\n\t* resolve.c (resolve_block_construct): Don't generate assignments\n\tto give associate-names their values.\n\t(resolve_fl_var_and_proc): Allow associate-names to be deferred-shape.\n\t(resolve_symbol): Set some more attributes for associate variables,\n\tset variable flag here and check it and don't try to build an\n\texplicitely shaped array-spec for array associate variables.\n\t* trans-expr.c (gfc_conv_variable): Dereference in case of association\n\tto scalar variable.\n\t* trans-types.c (gfc_is_nodesc_array): Handle array association symbols.\n\t(gfc_sym_type): Return pointer type for association to scalar vars.\n\t* trans-decl.c (gfc_get_symbol_decl): Defer association symbols.\n\t(trans_associate_var): New method.\n\t(gfc_trans_deferred_vars): Handle association symbols.\n\n2010-08-17  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/38936\n\t* gfortran.dg/associate_1.f03: Extended to test newly supported\n\tfeatures like association to variables.\n\t* gfortran.dg/associate_3.f03: Removed check for illegal change\n\tof associate-name here...\n\t* gfortran.dg/associate_5.f03: ...and added it here.\n\t* gfortran.dg/associate_6.f03: No longer XFAIL'ed.\n\t* gfortran.dg/associate_7.f03: New test.\n\nFrom-SVN: r163295", "tree": {"sha": "c4e60dabb6b71164f854d91556581ddd4452d41a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4e60dabb6b71164f854d91556581ddd4452d41a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/571d54deb6edc944f1e9f361302b2fa99b568d64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/571d54deb6edc944f1e9f361302b2fa99b568d64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/571d54deb6edc944f1e9f361302b2fa99b568d64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/571d54deb6edc944f1e9f361302b2fa99b568d64/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3373692b59f62e6dfeaa6a3b2f19610bf6ea3886", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3373692b59f62e6dfeaa6a3b2f19610bf6ea3886", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3373692b59f62e6dfeaa6a3b2f19610bf6ea3886"}], "stats": {"total": 456, "additions": 346, "deletions": 110}, "files": [{"sha": "77560d10ae41f4388b46caa5311a03bee333637f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -1,3 +1,28 @@\n+2010-08-17  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/38936\n+\t* gfortran.h (struct gfc_association_list): New member `where'.\n+\t(gfc_is_associate_pointer) New method.\n+\t* match.c (gfc_match_associate): Remember locus for each associate\n+\tname matched and do not try to set variable flag.\n+\t* parse.c (parse_associate): Use remembered locus for symbols.\n+\t* primary.c (match_variable): Instead of variable-flag check for\n+\tassociate names set it for all such names used.\n+\t* symbol.c (gfc_is_associate_pointer): New method.\n+\t* resolve.c (resolve_block_construct): Don't generate assignments\n+\tto give associate-names their values.\n+\t(resolve_fl_var_and_proc): Allow associate-names to be deferred-shape.\n+\t(resolve_symbol): Set some more attributes for associate variables,\n+\tset variable flag here and check it and don't try to build an\n+\texplicitely shaped array-spec for array associate variables.\n+\t* trans-expr.c (gfc_conv_variable): Dereference in case of association\n+\tto scalar variable.\n+\t* trans-types.c (gfc_is_nodesc_array): Handle array association symbols.\n+\t(gfc_sym_type): Return pointer type for association to scalar vars.\n+\t* trans-decl.c (gfc_get_symbol_decl): Defer association symbols.\n+\t(trans_associate_var): New method.\n+\t(gfc_trans_deferred_vars): Handle association symbols.\n+\n 2010-08-16  Joseph Myers  <joseph@codesourcery.com>\n \n \t* lang.opt (MDX): Change back to MD.  Mark NoDriverArg instead of"}, {"sha": "c9634d3ee911b120f99b37551768961a87ac8cfb", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -2007,6 +2007,8 @@ typedef struct gfc_association_list\n \n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_symtree *st; /* Symtree corresponding to name.  */\n+  locus where;\n+\n   gfc_expr *target;\n }\n gfc_association_list;\n@@ -2579,6 +2581,8 @@ void gfc_free_finalizer (gfc_finalizer *el); /* Needed in resolve.c, too  */\n gfc_try gfc_check_symbol_typed (gfc_symbol*, gfc_namespace*, bool, locus);\n gfc_namespace* gfc_find_proc_namespace (gfc_namespace*);\n \n+bool gfc_is_associate_pointer (gfc_symbol*);\n+\n /* intrinsic.c -- true if working in an init-expr, false otherwise.  */\n extern bool gfc_init_expr_flag;\n "}, {"sha": "c1cef962248e5c5e165dfa54f78ffa463c8c954b", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -1827,6 +1827,7 @@ gfc_match_associate (void)\n \t  gfc_error (\"Expected association at %C\");\n \t  goto assocListError;\n \t}\n+      newAssoc->where = gfc_current_locus;\n \n       /* Check that the current name is not yet in the list.  */\n       for (a = new_st.ext.block.assoc; a; a = a->next)\n@@ -1844,10 +1845,11 @@ gfc_match_associate (void)\n \t  goto assocListError;\n \t}\n \n-      /* The target is a variable (and may be used as lvalue) if it's an\n-\t EXPR_VARIABLE and does not have vector-subscripts.  */\n-      newAssoc->variable = (newAssoc->target->expr_type == EXPR_VARIABLE\n-\t\t\t    && !gfc_has_vector_subscript (newAssoc->target));\n+      /* The `variable' field is left blank for now; because the target is not\n+\t yet resolved, we can't use gfc_has_vector_subscript to determine it\n+\t for now.  Instead, if the symbol is matched as variable, this field\n+\t is set -- and during resolution we check that.  */\n+      newAssoc->variable = 0;\n \n       /* Put it into the list.  */\n       newAssoc->next = new_st.ext.block.assoc;"}, {"sha": "cbb945aa9a597e68ff411fced9e0ce3ae8a34c33", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -3215,23 +3215,21 @@ parse_associate (void)\n   new_st.ext.block.ns = my_ns;\n   gcc_assert (new_st.ext.block.assoc);\n \n-  /* Add all associate-names as BLOCK variables.  There values will be assigned\n-     to them during resolution of the ASSOCIATE construct.  */\n+  /* Add all associate-names as BLOCK variables.  Creating them is enough\n+     for now, they'll get their values during trans-* phase.  */\n   gfc_current_ns = my_ns;\n   for (a = new_st.ext.block.assoc; a; a = a->next)\n     {\n-      if (a->variable)\n-\t{\n-\t  gfc_error (\"Association to variables is not yet supported at %C\");\n-\t  return;\n-\t}\n+      gfc_symbol* sym;\n \n       if (gfc_get_sym_tree (a->name, NULL, &a->st, false))\n \tgcc_unreachable ();\n \n-      a->st->n.sym->attr.flavor = FL_VARIABLE;\n-      a->st->n.sym->assoc = a;\n-      gfc_set_sym_referenced (a->st->n.sym);\n+      sym = a->st->n.sym;\n+      sym->attr.flavor = FL_VARIABLE;\n+      sym->assoc = a;\n+      sym->declared_at = a->where;\n+      gfc_set_sym_referenced (sym);\n     }\n \n   accept_statement (ST_ASSOCIATE);"}, {"sha": "8b5bc148c2a7d0a4ce8cee956929e7986fdd2565", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -2982,12 +2982,8 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \t  gfc_error (\"Assigning to PROTECTED variable at %C\");\n \t  return MATCH_ERROR;\n \t}\n-      if (sym->assoc && !sym->assoc->variable)\n-\t{\n-\t  gfc_error (\"'%s' associated to expression can't appear in a variable\"\n-\t\t     \" definition context at %C\", sym->name);\n-\t  return MATCH_ERROR;\n-\t}\n+      if (sym->assoc)\n+\tsym->assoc->variable = 1;\n       break;\n \n     case FL_UNKNOWN:"}, {"sha": "d6da043dcfb3a1d69eb02b90a528ec9488052169", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 46, "deletions": 68, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -8295,39 +8295,7 @@ resolve_block_construct (gfc_code* code)\n   gfc_resolve (code->ext.block.ns);\n \n   /* For an ASSOCIATE block, the associations (and their targets) are already\n-     resolved during gfc_resolve_symbol.  Here, we have to add code\n-     to assign expression values to the variables associated to expressions.  */\n-  if (code->ext.block.assoc)\n-    {\n-      gfc_association_list* a;     \n-      gfc_code* assignTail;\n-      gfc_code* assignHead;\n-\n-      assignHead = assignTail = NULL;\n-      for (a = code->ext.block.assoc; a; a = a->next)\n-\tif (!a->variable)\n-\t  {\n-\t    gfc_code* newAssign;\n-\n-\t    newAssign = gfc_get_code ();\n-\t    newAssign->op = EXEC_ASSIGN;\n-\t    newAssign->loc = gfc_current_locus;\n-\t    newAssign->expr1 = gfc_lval_expr_from_sym (a->st->n.sym);\n-\t    newAssign->expr2 = a->target;\n-\n-\t    if (!assignHead)\n-\t      assignHead = newAssign;\n-\t    else\n-\t      {\n-\t\tgcc_assert (assignTail);\n-\t\tassignTail->next = newAssign;\n-\t      }\n-\t    assignTail = newAssign;\n-\t  }\n-\n-      assignTail->next = code->ext.block.ns->code;\n-      code->ext.block.ns->code = assignHead;\n-    }\n+     resolved during gfc_resolve_symbol.  */\n }\n \n \n@@ -9523,12 +9491,11 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n \t\t     sym->name, &sym->declared_at);\n \t  return FAILURE;\n \t}\n-\n     }\n   else\n     {\n       if (!mp_flag && !sym->attr.allocatable && !sym->attr.pointer\n-\t  && !sym->attr.dummy && sym->ts.type != BT_CLASS)\n+\t  && !sym->attr.dummy && sym->ts.type != BT_CLASS && !sym->assoc)\n \t{\n \t  gfc_error (\"Array '%s' at %L cannot have a deferred shape\",\n \t\t     sym->name, &sym->declared_at);\n@@ -11692,59 +11659,70 @@ resolve_symbol (gfc_symbol *sym)\n      they get their type-spec set this way.  */\n   if (sym->assoc)\n     {\n+      gfc_expr* target;\n+      bool to_var;\n+\n       gcc_assert (sym->attr.flavor == FL_VARIABLE);\n-      if (gfc_resolve_expr (sym->assoc->target) != SUCCESS)\n+\n+      target = sym->assoc->target;\n+      if (gfc_resolve_expr (target) != SUCCESS)\n \treturn;\n \n-      sym->ts = sym->assoc->target->ts;\n+      /* For variable targets, we get some attributes from the target.  */\n+      if (target->expr_type == EXPR_VARIABLE)\n+\t{\n+\t  gfc_symbol* tsym;\n+\n+\t  gcc_assert (target->symtree);\n+\t  tsym = target->symtree->n.sym;\n+\n+\t  sym->attr.asynchronous = tsym->attr.asynchronous;\n+\t  sym->attr.volatile_ = tsym->attr.volatile_;\n+\n+\t  sym->attr.target = (tsym->attr.target || tsym->attr.pointer);\n+\t}\n+\n+      sym->ts = target->ts;\n       gcc_assert (sym->ts.type != BT_UNKNOWN);\n \n-      if (sym->attr.dimension && sym->assoc->target->rank == 0)\n+      /* See if this is a valid association-to-variable.  */\n+      to_var = (target->expr_type == EXPR_VARIABLE\n+\t\t&& !gfc_has_vector_subscript (target));\n+      if (sym->assoc->variable && !to_var)\n+\t{\n+\t  if (target->expr_type == EXPR_VARIABLE)\n+\t    gfc_error (\"'%s' at %L associated to vector-indexed target can not\"\n+\t\t       \" be used in a variable definition context\",\n+\t\t       sym->name, &sym->declared_at);\n+\t  else\n+\t    gfc_error (\"'%s' at %L associated to expression can not\"\n+\t\t       \" be used in a variable definition context\",\n+\t\t       sym->name, &sym->declared_at);\n+\n+\t  return;\n+\t}\n+      sym->assoc->variable = to_var;\n+\n+      /* Finally resolve if this is an array or not.  */\n+      if (sym->attr.dimension && target->rank == 0)\n \t{\n \t  gfc_error (\"Associate-name '%s' at %L is used as array\",\n \t\t     sym->name, &sym->declared_at);\n \t  sym->attr.dimension = 0;\n \t  return;\n \t}\n-      if (sym->assoc->target->rank > 0)\n+      if (target->rank > 0)\n \tsym->attr.dimension = 1;\n \n       if (sym->attr.dimension)\n \t{\n-\t  int dim;\n-\n \t  sym->as = gfc_get_array_spec ();\n-\t  sym->as->rank = sym->assoc->target->rank;\n-\t  sym->as->type = AS_EXPLICIT;\n+\t  sym->as->rank = target->rank;\n+\t  sym->as->type = AS_DEFERRED;\n \n \t  /* Target must not be coindexed, thus the associate-variable\n \t     has no corank.  */\n \t  sym->as->corank = 0;\n-\n-\t  for (dim = 0; dim < sym->assoc->target->rank; ++dim)\n-\t    {\n-\t      gfc_expr* dim_expr;\n-\t      gfc_expr* e;\n-\n-\t      dim_expr = gfc_get_constant_expr (BT_INTEGER,\n-\t\t\t\t\t\tgfc_default_integer_kind,\n-\t\t\t\t\t\t&sym->declared_at);\n-\t      mpz_set_si (dim_expr->value.integer, dim + 1);\n-\n-\t      e = gfc_build_intrinsic_call (\"lbound\", sym->declared_at, 3,\n-\t\t\t\t\t    gfc_copy_expr (sym->assoc->target),\n-\t\t\t\t\t    gfc_copy_expr (dim_expr), NULL);\n-\t      gfc_resolve_expr (e);\n-\t      sym->as->lower[dim] = e;\n-\n-\t      e = gfc_build_intrinsic_call (\"ubound\", sym->declared_at, 3,\n-\t\t\t\t\t    gfc_copy_expr (sym->assoc->target),\n-\t\t\t\t\t    gfc_copy_expr (dim_expr), NULL);\n-\t      gfc_resolve_expr (e);\n-\t      sym->as->upper[dim] = e;\n-\n-\t      gfc_free_expr (dim_expr);\n-\t    }\n \t}\n     }\n "}, {"sha": "0199ac421440db50d3933c158a26ec110051d55c", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -4758,3 +4758,23 @@ gfc_find_proc_namespace (gfc_namespace* ns)\n \n   return ns;\n }\n+\n+\n+/* Check if an associate-variable should be translated as an `implicit' pointer\n+   internally (if it is associated to a variable and not an array with\n+   descriptor).  */\n+\n+bool\n+gfc_is_associate_pointer (gfc_symbol* sym)\n+{\n+  if (!sym->assoc)\n+    return false;\n+\n+  if (!sym->assoc->variable)\n+    return false;\n+\n+  if (sym->attr.dimension && sym->as->type != AS_EXPLICIT)\n+    return false;\n+\n+  return true;\n+}"}, {"sha": "4fb0251054d81c4587e807710da45e3825680aad", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 117, "deletions": 2, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -1206,7 +1206,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n     }\n \n   /* Remember this variable for allocation/cleanup.  */\n-  if (sym->attr.dimension || sym->attr.allocatable\n+  if (sym->attr.dimension || sym->attr.allocatable || sym->assoc\n       || (sym->ts.type == BT_CLASS &&\n \t  (CLASS_DATA (sym)->attr.dimension\n \t   || CLASS_DATA (sym)->attr.allocatable))\n@@ -3095,12 +3095,125 @@ init_intent_out_dt (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n }\n \n \n+/* Do proper initialization for ASSOCIATE names.  */\n+\n+static void\n+trans_associate_var (gfc_symbol* sym, gfc_wrapped_block* block)\n+{\n+  gfc_expr* e;\n+  tree tmp;\n+\n+  gcc_assert (sym->assoc);\n+  e = sym->assoc->target;\n+\n+  /* Do a `pointer assignment' with updated descriptor (or assign descriptor\n+     to array temporary) for arrays with either unknown shape or if associating\n+     to a variable.  */\n+  if (sym->attr.dimension\n+      && (sym->as->type == AS_DEFERRED || sym->assoc->variable))\n+    {\n+      gfc_se se;\n+      gfc_ss* ss;\n+      tree desc;\n+\n+      desc = sym->backend_decl;\n+\n+      /* If association is to an expression, evaluate it and create temporary.\n+\t Otherwise, get descriptor of target for pointer assignment.  */\n+      gfc_init_se (&se, NULL);\n+      ss = gfc_walk_expr (e);\n+      if (sym->assoc->variable)\n+\t{\n+\t  se.direct_byref = 1;\n+\t  se.expr = desc;\n+\t}\n+      gfc_conv_expr_descriptor (&se, e, ss);\n+\n+      /* If we didn't already do the pointer assignment, set associate-name\n+\t descriptor to the one generated for the temporary.  */\n+      if (!sym->assoc->variable)\n+\t{\n+\t  tree offs;\n+\t  int dim;\n+\n+\t  gfc_add_modify (&se.pre, desc, se.expr);\n+\n+\t  /* The generated descriptor has lower bound zero (as array\n+\t     temporary), shift bounds so we get lower bounds of 1 all the time.\n+\t     The offset has to be corrected as well.\n+\t     Because the ubound shift and offset depends on the lower bounds, we\n+\t     first calculate those and set the lbound to one last.  */\n+\n+\t  offs = gfc_conv_descriptor_offset_get (desc);\n+\t  for (dim = 0; dim < e->rank; ++dim)\n+\t    {\n+\t      tree from, to;\n+\t      tree stride;\n+\n+\t      from = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[dim]);\n+\t      to = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[dim]);\n+\t      stride = gfc_conv_descriptor_stride_get (desc, gfc_rank_cst[dim]);\n+\n+\t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t gfc_index_one_node, from);\n+\t      to = fold_build2 (PLUS_EXPR, gfc_array_index_type, to, tmp);\n+\n+\t      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, tmp, stride);\n+\t      offs = fold_build2 (MINUS_EXPR, gfc_array_index_type, offs, tmp);\n+\n+\t      gfc_conv_descriptor_ubound_set (&se.pre, desc,\n+\t\t\t\t\t      gfc_rank_cst[dim], to);\n+\t    }\n+\t  gfc_conv_descriptor_offset_set (&se.pre, desc, offs);\n+\n+\t  for (dim = 0; dim < e->rank; ++dim)\n+\t    gfc_conv_descriptor_lbound_set (&se.pre, desc, gfc_rank_cst[dim],\n+\t\t\t\t\t    gfc_index_one_node);\n+\t}\n+\n+      /* Done, register stuff as init / cleanup code.  */\n+      gfc_add_init_cleanup (block, gfc_finish_block (&se.pre),\n+\t\t\t    gfc_finish_block (&se.post));\n+    }\n+\n+  /* Do a scalar pointer assignment; this is for scalar variable targets.  */\n+  else if (gfc_is_associate_pointer (sym))\n+    {\n+      gfc_se se;\n+\n+      gcc_assert (!sym->attr.dimension);\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, e);\n+\n+      tmp = TREE_TYPE (sym->backend_decl);\n+      tmp = gfc_build_addr_expr (tmp, se.expr);\n+      gfc_add_modify (&se.pre, sym->backend_decl, tmp);\n+      \n+      gfc_add_init_cleanup (block, gfc_finish_block( &se.pre),\n+\t\t\t    gfc_finish_block (&se.post));\n+    }\n+\n+  /* Do a simple assignment.  This is for scalar expressions, where we\n+     can simply use expression assignment.  */\n+  else\n+    {\n+      gfc_expr* lhs;\n+\n+      lhs = gfc_lval_expr_from_sym (sym);\n+      tmp = gfc_trans_assignment (lhs, e, false, true);\n+      gfc_add_init_cleanup (block, tmp, NULL_TREE);\n+    }\n+}\n+\n+\n /* Generate function entry and exit code, and add it to the function body.\n    This includes:\n     Allocation and initialization of array variables.\n     Allocation of character string variables.\n     Initialization and possibly repacking of dummy arrays.\n     Initialization of ASSIGN statement auxiliary variable.\n+    Initialization of ASSOCIATE names.\n     Automatic deallocation.  */\n \n void\n@@ -3159,7 +3272,9 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n     {\n       bool sym_has_alloc_comp = (sym->ts.type == BT_DERIVED)\n \t\t\t\t   && sym->ts.u.derived->attr.alloc_comp;\n-      if (sym->attr.dimension)\n+      if (sym->assoc)\n+\ttrans_associate_var (sym, block);\n+      else if (sym->attr.dimension)\n \t{\n \t  switch (sym->as->type)\n \t    {"}, {"sha": "4465832d847f8b2f56e15dd184fe7db6630275fc", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -672,9 +672,10 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t    se->expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\tse->expr);\n \n-          /* Dereference non-character pointer variables. \n+\t  /* Dereference non-character pointer variables. \n \t     These must be dummies, results, or scalars.  */\n-\t  if ((sym->attr.pointer || sym->attr.allocatable)\n+\t  if ((sym->attr.pointer || sym->attr.allocatable\n+\t       || gfc_is_associate_pointer (sym))\n \t      && (sym->attr.dummy\n \t\t  || sym->attr.function\n \t\t  || sym->attr.result"}, {"sha": "892a73ebd804a96b0697515426dd5e42b7131a7c", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -1183,13 +1183,13 @@ gfc_is_nodesc_array (gfc_symbol * sym)\n   if (sym->attr.pointer || sym->attr.allocatable)\n     return 0;\n \n+  /* We want a descriptor for associate-name arrays that do not have an\n+     explicitely known shape already.  */\n+  if (sym->assoc && sym->as->type != AS_EXPLICIT)\n+    return 0;\n+\n   if (sym->attr.dummy)\n-    {\n-      if (sym->as->type != AS_ASSUMED_SHAPE)\n-        return 1;\n-      else\n-        return 0;\n-    }\n+    return sym->as->type != AS_ASSUMED_SHAPE;\n \n   if (sym->attr.result || sym->attr.function)\n     return 0;\n@@ -1798,7 +1798,8 @@ gfc_sym_type (gfc_symbol * sym)\n     }\n   else\n     {\n-      if (sym->attr.allocatable || sym->attr.pointer)\n+      if (sym->attr.allocatable || sym->attr.pointer\n+\t  || gfc_is_associate_pointer (sym))\n \ttype = gfc_build_pointer_type (sym, type);\n       if (sym->attr.pointer || sym->attr.cray_pointee)\n \tGFC_POINTER_TYPE_P (type) = 1;"}, {"sha": "760b5f1259f90876cf524fd2de3194da8f67ebd7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -1,3 +1,14 @@\n+2010-08-17  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/38936\n+\t* gfortran.dg/associate_1.f03: Extended to test newly supported\n+\tfeatures like association to variables.\n+\t* gfortran.dg/associate_3.f03: Removed check for illegal change\n+\tof associate-name here...\n+\t* gfortran.dg/associate_5.f03: ...and added it here.\n+\t* gfortran.dg/associate_6.f03: No longer XFAIL'ed.\n+\t* gfortran.dg/associate_7.f03: New test.\n+\n 2010-08-15  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* gcc.dg/tree-ssa/pr42585.c: Skip dump scan on sh."}, {"sha": "4cb727f0b5a639e3465d79e9521409f9944a240a", "filename": "gcc/testsuite/gfortran.dg/associate_1.f03", "status": "modified", "additions": 58, "deletions": 4, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_1.f03?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do run }\n-! { dg-options \"-std=f2003 -fall-intrinsics\" }\n+! { dg-options \"-std=f2003 -fall-intrinsics -cpp\" }\n \n ! PR fortran/38936\n ! Check the basic semantics of the ASSOCIATE construct.\n@@ -8,6 +8,13 @@ PROGRAM main\n   IMPLICIT NONE\n   REAL :: a, b, c\n   INTEGER, ALLOCATABLE :: arr(:)\n+  INTEGER :: mat(3, 3)\n+\n+  TYPE :: myt\n+    INTEGER :: comp\n+  END TYPE myt\n+\n+  TYPE(myt) :: tp\n \n   a = -2.0\n   b = 3.0\n@@ -20,9 +27,6 @@ PROGRAM main\n     IF (ABS (t - a - b) > 1.0e-3) CALL abort ()\n   END ASSOCIATE\n \n-  ! TODO: Test association to variables when that is supported.\n-  ! TODO: Test association to derived types.\n-\n   ! Test association to arrays.\n   ALLOCATE (arr(3))\n   arr = (/ 1, 2, 3 /)\n@@ -34,6 +38,12 @@ PROGRAM main\n     IF (ANY (xyz /= (/ 1, 3, 5 /))) CALL abort ()\n   END ASSOCIATE\n \n+  ! Target is vector-indexed.\n+  ASSOCIATE (foo => arr((/ 3, 1 /)))\n+    IF (LBOUND (foo, 1) /= 1 .OR. UBOUND (foo, 1) /= 2) CALL abort ()\n+    IF (foo(1) /= 3 .OR. foo(2) /= 1) CALL abort ()\n+  END ASSOCIATE\n+\n   ! Named and nested associate.\n   myname: ASSOCIATE (x => a - b * c)\n     ASSOCIATE (y => 2.0 * x)\n@@ -49,11 +59,55 @@ PROGRAM main\n     END ASSOCIATE\n   END ASSOCIATE\n \n+  ! Association to variables.\n+  mat = 0\n+  mat(2, 2) = 5;\n+  ASSOCIATE (x => arr(2), y => mat(2:3, 1:2))\n+    IF (x /= 2) CALL abort ()\n+    IF (ANY (LBOUND (y) /= (/ 1, 1 /) .OR. UBOUND (y) /= (/ 2, 2 /))) &\n+      CALL abort ()\n+    IF (y(1, 2) /= 5) CALL abort ()\n+\n+    x = 7\n+    y = 8\n+  END ASSOCIATE\n+  IF (arr(2) /= 7 .OR. ANY (mat(2:3, 1:2) /= 8)) CALL abort ()\n+\n+  ! Association to derived type and component.\n+  tp = myt (1)\n+  ASSOCIATE (x => tp, y => tp%comp)\n+    ! FIXME: Parsing of derived-type associate names, tests with x.\n+    IF (y /= 1) CALL abort ()\n+    y = 5\n+  END ASSOCIATE\n+  IF (tp%comp /= 5) CALL abort ()\n+\n+  ! Association to character variables.\n+  ! FIXME: Enable character test, once this works.\n+  !CALL test_char (5)\n+\n CONTAINS\n \n   FUNCTION func ()\n     INTEGER :: func(3)\n     func = (/ 1, 3, 5 /)\n   END FUNCTION func\n \n+#if 0\n+  ! Test association to character variable with automatic length.\n+  SUBROUTINE test_char (n)\n+    INTEGER, INTENT(IN) :: n\n+\n+    CHARACTER(LEN=n) :: str\n+\n+    str = \"foobar\"\n+    ASSOCIATE (my => str)\n+      IF (LEN (my) /= n) CALL abort ()\n+      IF (my /= \"fooba\") CALL abort ()\n+      my = \"abcdef\"\n+    END ASSOCIATE\n+    IF (str /= \"abcde\") CALL abort ()\n+  END SUBROUTINE test_char\n+#endif\n+\n END PROGRAM main"}, {"sha": "20a375dcfd1c9405d14d5d21d9628b6bf7b1fee7", "filename": "gcc/testsuite/gfortran.dg/associate_3.f03", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_3.f03?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -30,10 +30,6 @@ PROGRAM main\n \n   ASSOCIATE (a => 1, b => 2, a => 3) ! { dg-error \"Duplicate name 'a'\" }\n \n-  ASSOCIATE (a => 5)\n-    a = 4 ! { dg-error \"variable definition context\" }\n-  ENd ASSOCIATE\n-\n   ASSOCIATE (a => 5)\n     INTEGER :: b ! { dg-error \"Unexpected data declaration statement\" }\n   END ASSOCIATE"}, {"sha": "31cc144d5a934f306a5047383151b4d71701c342", "filename": "gcc/testsuite/gfortran.dg/associate_5.f03", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_5.f03?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -6,8 +6,21 @@\n \n PROGRAM main\n   IMPLICIT NONE\n+  INTEGER :: nontarget\n+  INTEGER :: arr(3)\n+  INTEGER, POINTER :: ptr\n \n   ASSOCIATE (a => 5) ! { dg-error \"is used as array\" }\n     PRINT *, a(3)\n   END ASSOCIATE\n+\n+  ASSOCIATE (a => nontarget)\n+    ptr => a ! { dg-error \"neither TARGET nor POINTER\" }\n+  END ASSOCIATE\n+\n+  ASSOCIATE (a => 5, & ! { dg-error \"variable definition context\" }\n+             b => arr((/ 1, 3 /))) ! { dg-error \"variable definition context\" }\n+    a = 4\n+    b = 7\n+  END ASSOCIATE\n END PROGRAM main"}, {"sha": "ba0e5c098098ac0eec5dbc721b3f2ff4e73d5656", "filename": "gcc/testsuite/gfortran.dg/associate_6.f03", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_6.f03?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -7,8 +7,6 @@\n \n ! Contributed by Daniel Kraft, d@domob.eu.\n \n-! FIXME: XFAIL'ed because this is not yet implemented 'correctly'.\n-\n MODULE m\n   IMPLICIT NONE\n \n@@ -31,8 +29,11 @@ PROGRAM main\n \n   ASSOCIATE (arr => func (4))\n     ! func should only be called once here, not again for the bounds!\n+\n+    IF (LBOUND (arr, 1) /= 1 .OR. UBOUND (arr, 1) /= 4) CALL abort ()\n+    IF (arr(1) /= 1 .OR. arr(4) /= 4) CALL abort ()\n   END ASSOCIATE\n END PROGRAM main\n ! { dg-final { cleanup-modules \"m\" } }\n-! { dg-final { scan-tree-dump-times \"func\" 2 \"original\" { xfail *-*-* } } }\n+! { dg-final { scan-tree-dump-times \"func\" 2 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "6fd3f343d00eb2fbaeadc94070dd0e0e87cf0201", "filename": "gcc/testsuite/gfortran.dg/associate_7.f03", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_7.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/571d54deb6edc944f1e9f361302b2fa99b568d64/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_7.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_7.f03?ref=571d54deb6edc944f1e9f361302b2fa99b568d64", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+! { dg-options \"-std=f2003 -fall-intrinsics\" }\n+\n+! PR fortran/38936\n+! Check association and pointers.\n+\n+! Contributed by Daniel Kraft, d@domob.eu.\n+\n+PROGRAM main\n+  IMPLICIT NONE\n+  INTEGER, TARGET :: tgt\n+  INTEGER, POINTER :: ptr\n+\n+  tgt = 1\n+  ASSOCIATE (x => tgt)\n+    ptr => x\n+    IF (ptr /= 1) CALL abort ()\n+    ptr = 2\n+  END ASSOCIATE\n+  IF (tgt /= 2) CALL abort ()\n+END PROGRAM main"}]}