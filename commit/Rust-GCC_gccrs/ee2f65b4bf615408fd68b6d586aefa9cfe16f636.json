{"sha": "ee2f65b4bf615408fd68b6d586aefa9cfe16f636", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWUyZjY1YjRiZjYxNTQwOGZkNjhiNmQ1ODZhZWZhOWNmZTE2ZjYzNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2007-03-23T02:02:38Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2007-03-23T02:02:38Z"}, "message": "i386.c (ix86_function_regparm): Early exit for 64-bit...\n\n        * config/i386/i386.c (ix86_function_regparm): Early exit for 64-bit;\n        don't increase local_regparm with force_align_arg_pointer check.\n        (ix86_function_sseregparm): Assert 32-bit.\n        (type_has_variadic_args_p): New.\n        (ix86_return_pops_args): Early exit for 64-bit.  Reindent; use\n        type_has_variadic_args_p.\n        (ix86_function_arg_regno_p): Use == 0 instead of ! test for eax.\n        (init_cumulative_args): Remove TARGET_DEBUG_ARG.  Remove zero_cum;\n        use memset instead.  Do maybe_vaarg check first; skip attribute\n        tests if true; skip attribute tests for 64-bit.\n        (construct_container): Remove TARGET_DEBUG_ARG.\n        (function_arg_advance_32, function_arg_advance_64): Split out ...\n        (function_arg_advance): ... from here.\n        (function_arg_32, function_arg_64): Split out ...\n        (function_arg): ... from here.\n        (ix86_pass_by_reference): Tidy.\n        (ix86_function_value_regno_p): Rearrange w/ switch on regno.\n        (function_value_32): New, from parts of ix86_function_value\n        and ix86_value_regno.\n        (function_value_64): New, from parts of ix86_function_value\n        and ix86_libcall_value.\n        (ix86_function_value_1): New.\n        (ix86_function_value, ix86_libcall_value): Use it.\n        (return_in_memory_32, return_in_memory_64): Split out ...\n        (ix86_return_in_memory): ... from here. \n        (ix86_struct_value_rtx): Skip for 64-bit.\n        (ix86_libcall_value, ix86_value_regno): Remove.\n        (setup_incoming_varargs_64): Split out ...\n        (ix86_setup_incoming_varargs): ... from here. \n        (ix86_va_start): Remove TARGET_DEBUG_ARG.\n        (legitimate_address_p, legitimize_address): Remove TARGET_DEBUG_ADDR.\n        * config/i386/i386-protos.h (ix86_function_value): Remove.\n        * config/i386/i386.opt (TARGET_DEBUG_ADDR, TARGET_DEBUG_ARG): Remove.\n\nFrom-SVN: r123146", "tree": {"sha": "d4edd17f8f53559a09043d5ac00bea35eb522b87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4edd17f8f53559a09043d5ac00bea35eb522b87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee2f65b4bf615408fd68b6d586aefa9cfe16f636", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee2f65b4bf615408fd68b6d586aefa9cfe16f636", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee2f65b4bf615408fd68b6d586aefa9cfe16f636", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee2f65b4bf615408fd68b6d586aefa9cfe16f636/comments", "author": null, "committer": null, "parents": [{"sha": "424c5799148dc40db585f032ff13bb23ef5e1ae0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/424c5799148dc40db585f032ff13bb23ef5e1ae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/424c5799148dc40db585f032ff13bb23ef5e1ae0"}], "stats": {"total": 1127, "additions": 568, "deletions": 559}, "files": [{"sha": "6b56a446c312354656142e77406c6a48496d142c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee2f65b4bf615408fd68b6d586aefa9cfe16f636/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee2f65b4bf615408fd68b6d586aefa9cfe16f636/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee2f65b4bf615408fd68b6d586aefa9cfe16f636", "patch": "@@ -1,3 +1,39 @@\n+2007-03-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (ix86_function_regparm): Early exit for 64-bit;\n+\tdon't increase local_regparm with force_align_arg_pointer check.\n+\t(ix86_function_sseregparm): Assert 32-bit.\n+\t(type_has_variadic_args_p): New.\n+\t(ix86_return_pops_args): Early exit for 64-bit.  Reindent; use\n+\ttype_has_variadic_args_p.\n+\t(ix86_function_arg_regno_p): Use == 0 instead of ! test for eax.\n+\t(init_cumulative_args): Remove TARGET_DEBUG_ARG.  Remove zero_cum;\n+\tuse memset instead.  Do maybe_vaarg check first; skip attribute\n+\ttests if true; skip attribute tests for 64-bit.\n+\t(construct_container): Remove TARGET_DEBUG_ARG.\n+\t(function_arg_advance_32, function_arg_advance_64): Split out ...\n+\t(function_arg_advance): ... from here.\n+\t(function_arg_32, function_arg_64): Split out ...\n+\t(function_arg): ... from here.\n+\t(ix86_pass_by_reference): Tidy.\n+\t(ix86_function_value_regno_p): Rearrange w/ switch on regno.\n+\t(function_value_32): New, from parts of ix86_function_value\n+\tand ix86_value_regno.\n+\t(function_value_64): New, from parts of ix86_function_value\n+\tand ix86_libcall_value.\n+\t(ix86_function_value_1): New.\n+\t(ix86_function_value, ix86_libcall_value): Use it.\n+\t(return_in_memory_32, return_in_memory_64): Split out ...\n+\t(ix86_return_in_memory): ... from here.\n+\t(ix86_struct_value_rtx): Skip for 64-bit.\n+\t(ix86_libcall_value, ix86_value_regno): Remove.\n+\t(setup_incoming_varargs_64): Split out ...\n+\t(ix86_setup_incoming_varargs): ... from here.\n+\t(ix86_va_start): Remove TARGET_DEBUG_ARG.\n+\t(legitimate_address_p, legitimize_address): Remove TARGET_DEBUG_ADDR.\n+\t* config/i386/i386-protos.h (ix86_function_value): Remove.\n+\t* config/i386/i386.opt (TARGET_DEBUG_ADDR, TARGET_DEBUG_ARG): Remove.\n+\n 2007-03-22  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR other/23572"}, {"sha": "aad472439bd4ffa866f3a415a82251eccf3e230c", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee2f65b4bf615408fd68b6d586aefa9cfe16f636/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee2f65b4bf615408fd68b6d586aefa9cfe16f636/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=ee2f65b4bf615408fd68b6d586aefa9cfe16f636", "patch": "@@ -179,7 +179,6 @@ extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n extern rtx function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t  tree, int);\n-extern rtx ix86_function_value (tree, tree, bool);\n #endif\n \n #endif"}, {"sha": "70a1bb935ef2891e9483abd4f7d3c87810bf2c07", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 532, "deletions": 552, "changes": 1084, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee2f65b4bf615408fd68b6d586aefa9cfe16f636/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee2f65b4bf615408fd68b6d586aefa9cfe16f636/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ee2f65b4bf615408fd68b6d586aefa9cfe16f636", "patch": "@@ -1562,7 +1562,6 @@ static int ix86_function_regparm (tree, tree);\n const struct attribute_spec ix86_attribute_table[];\n static bool ix86_function_ok_for_sibcall (tree, tree);\n static tree ix86_handle_cconv_attribute (tree *, tree, tree, int, bool *);\n-static int ix86_value_regno (enum machine_mode, tree, tree);\n static bool contains_128bit_aligned_vector_p (tree);\n static rtx ix86_struct_value_rtx (tree, int);\n static bool ix86_ms_bitfield_layout_p (tree);\n@@ -1584,6 +1583,7 @@ static rtx ix86_internal_arg_pointer (void);\n static void ix86_dwarf_handle_frame_unspec (const char *, rtx, int);\n static bool ix86_expand_vector_init_one_nonzero (bool, enum machine_mode,\n \t\t\t\t\t\t rtx, rtx, int);\n+static rtx ix86_function_value (tree, tree, bool);\n \n /* This function is only used on Solaris.  */\n static void i386_solaris_elf_named_section (const char *, unsigned int, tree)\n@@ -2997,69 +2997,64 @@ ix86_function_regparm (tree type, tree decl)\n {\n   tree attr;\n   int regparm = ix86_regparm;\n-  bool user_convention = false;\n \n-  if (!TARGET_64BIT)\n-    {\n-      attr = lookup_attribute (\"regparm\", TYPE_ATTRIBUTES (type));\n-      if (attr)\n-\t{\n-\t  regparm = TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (attr)));\n-\t  user_convention = true;\n-\t}\n+  if (TARGET_64BIT)\n+    return regparm;\n \n-      if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (type)))\n-\t{\n-\t  regparm = 2;\n-\t  user_convention = true;\n-\t}\n+  attr = lookup_attribute (\"regparm\", TYPE_ATTRIBUTES (type));\n+  if (attr)\n+    return TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (attr)));\n+\n+  if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (type)))\n+    return 2;\n \n-      /* Use register calling convention for local functions when possible.  */\n-      if (!TARGET_64BIT && !user_convention && decl\n-\t  && flag_unit_at_a_time && !profile_flag)\n+  /* Use register calling convention for local functions when possible.  */\n+  if (decl && flag_unit_at_a_time && !profile_flag)\n+    {\n+      struct cgraph_local_info *i = cgraph_local_info (decl);\n+      if (i && i->local)\n \t{\n-\t  struct cgraph_local_info *i = cgraph_local_info (decl);\n-\t  if (i && i->local)\n-\t    {\n-\t      int local_regparm, globals = 0, regno;\n+\t  int local_regparm, globals = 0, regno;\n+\t  struct function *f;\n \n-\t      /* Make sure no regparm register is taken by a global register\n-\t\t variable.  */\n-\t      for (local_regparm = 0; local_regparm < 3; local_regparm++)\n-\t\tif (global_regs[local_regparm])\n-\t\t  break;\n-\t      /* We can't use regparm(3) for nested functions as these use\n-\t\t static chain pointer in third argument.  */\n-\t      if (local_regparm == 3\n-\t\t  && decl_function_context (decl)\n-\t\t  && !DECL_NO_STATIC_CHAIN (decl))\n-\t\tlocal_regparm = 2;\n-\t      /* If the function realigns its stackpointer, the\n-\t\t prologue will clobber %ecx.  If we've already\n-\t\t generated code for the callee, the callee\n-\t\t DECL_STRUCT_FUNCTION is gone, so we fall back to\n-\t\t scanning the attributes for the self-realigning\n-\t\t property.  */\n-\t      if ((DECL_STRUCT_FUNCTION (decl)\n-\t\t   && DECL_STRUCT_FUNCTION (decl)->machine->force_align_arg_pointer)\n-\t\t  || (!DECL_STRUCT_FUNCTION (decl)\n-\t\t      && lookup_attribute (ix86_force_align_arg_pointer_string,\n-\t\t\t\t\t   TYPE_ATTRIBUTES (TREE_TYPE (decl)))))\n-\t\tlocal_regparm = 2;\n-\t      /* Each global register variable increases register preassure,\n-\t\t so the more global reg vars there are, the smaller regparm\n-\t\t optimization use, unless requested by the user explicitly.  */\n-\t      for (regno = 0; regno < 6; regno++)\n-\t\tif (global_regs[regno])\n-\t\t  globals++;\n-\t      local_regparm\n-\t\t= globals < local_regparm ? local_regparm - globals : 0;\n-\n-\t      if (local_regparm > regparm)\n-\t\tregparm = local_regparm;\n-\t    }\n+\t  /* Make sure no regparm register is taken by a\n+\t     global register variable.  */\n+\t  for (local_regparm = 0; local_regparm < 3; local_regparm++)\n+\t    if (global_regs[local_regparm])\n+\t      break;\n+\n+\t  /* We can't use regparm(3) for nested functions as these use\n+\t     static chain pointer in third argument.  */\n+\t  if (local_regparm == 3\n+\t      && decl_function_context (decl)\n+\t      && !DECL_NO_STATIC_CHAIN (decl))\n+\t    local_regparm = 2;\n+\n+\t  /* If the function realigns its stackpointer, the prologue will\n+\t     clobber %ecx.  If we've already generated code for the callee,\n+\t     the callee DECL_STRUCT_FUNCTION is gone, so we fall back to\n+\t     scanning the attributes for the self-realigning property.  */\n+\t  f = DECL_STRUCT_FUNCTION (decl);\n+\t  if (local_regparm == 3\n+\t      && (f ? !!f->machine->force_align_arg_pointer\n+\t\t  : !!lookup_attribute (ix86_force_align_arg_pointer_string,\n+\t\t\t\t\tTYPE_ATTRIBUTES (TREE_TYPE (decl)))))\n+\t    local_regparm = 2;\n+\n+\t  /* Each global register variable increases register preassure,\n+\t     so the more global reg vars there are, the smaller regparm\n+\t     optimization use, unless requested by the user explicitly.  */\n+\t  for (regno = 0; regno < 6; regno++)\n+\t    if (global_regs[regno])\n+\t      globals++;\n+\t  local_regparm\n+\t    = globals < local_regparm ? local_regparm - globals : 0;\n+\n+\t  if (local_regparm > regparm)\n+\t    regparm = local_regparm;\n \t}\n     }\n+\n   return regparm;\n }\n \n@@ -3071,11 +3066,12 @@ ix86_function_regparm (tree type, tree decl)\n static int\n ix86_function_sseregparm (tree type, tree decl)\n {\n+  gcc_assert (!TARGET_64BIT);\n+\n   /* Use SSE registers to pass SFmode and DFmode arguments if requested\n      by the sseregparm attribute.  */\n   if (TARGET_SSEREGPARM\n-      || (type\n-\t  && lookup_attribute (\"sseregparm\", TYPE_ATTRIBUTES (type))))\n+      || (type && lookup_attribute (\"sseregparm\", TYPE_ATTRIBUTES (type))))\n     {\n       if (!TARGET_SSE)\n \t{\n@@ -3092,10 +3088,8 @@ ix86_function_sseregparm (tree type, tree decl)\n     }\n \n   /* For local functions, pass up to SSE_REGPARM_MAX SFmode\n-     (and DFmode for SSE2) arguments in SSE registers,\n-     even for 32-bit targets.  */\n-  if (!TARGET_64BIT && decl\n-      && TARGET_SSE_MATH && flag_unit_at_a_time && !profile_flag)\n+     (and DFmode for SSE2) arguments in SSE registers.  */\n+  if (decl && TARGET_SSE_MATH && flag_unit_at_a_time && !profile_flag)\n     {\n       struct cgraph_local_info *i = cgraph_local_info (decl);\n       if (i && i->local)\n@@ -3121,6 +3115,19 @@ ix86_eax_live_at_start_p (void)\n   return REGNO_REG_SET_P (ENTRY_BLOCK_PTR->il.rtl->global_live_at_end, 0);\n }\n \n+/* Return true if TYPE has a variable argument list.  */\n+\n+static bool\n+type_has_variadic_args_p (tree type)\n+{\n+  tree t;\n+\n+  for (t = TYPE_ARG_TYPES (type); t; t = TREE_CHAIN (t))\n+    if (t == void_list_node)\n+      return false;\n+  return true;\n+}\n+\n /* Value is the number of bytes of arguments automatically\n    popped when returning from a subroutine call.\n    FUNDECL is the declaration node of the function (as a tree),\n@@ -3141,32 +3148,33 @@ ix86_eax_live_at_start_p (void)\n int\n ix86_return_pops_args (tree fundecl, tree funtype, int size)\n {\n-  int rtd = TARGET_RTD && (!fundecl || TREE_CODE (fundecl) != IDENTIFIER_NODE);\n+  int rtd;\n+\n+  /* None of the 64-bit ABIs pop arguments.  */\n+  if (TARGET_64BIT)\n+    return 0;\n+\n+  rtd = TARGET_RTD && (!fundecl || TREE_CODE (fundecl) != IDENTIFIER_NODE);\n \n   /* Cdecl functions override -mrtd, and never pop the stack.  */\n-  if (! lookup_attribute (\"cdecl\", TYPE_ATTRIBUTES (funtype))) {\n-\n-    /* Stdcall and fastcall functions will pop the stack if not\n-       variable args.  */\n-    if (lookup_attribute (\"stdcall\", TYPE_ATTRIBUTES (funtype))\n-        || lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (funtype)))\n-      rtd = 1;\n-\n-    if (rtd\n-        && (TYPE_ARG_TYPES (funtype) == NULL_TREE\n-\t    || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (funtype)))\n-\t\t== void_type_node)))\n-      return size;\n-  }\n+  if (! lookup_attribute (\"cdecl\", TYPE_ATTRIBUTES (funtype)))\n+    {\n+      /* Stdcall and fastcall functions will pop the stack if not\n+         variable args.  */\n+      if (lookup_attribute (\"stdcall\", TYPE_ATTRIBUTES (funtype))\n+          || lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (funtype)))\n+\trtd = 1;\n+\n+      if (rtd && ! type_has_variadic_args_p (funtype))\n+\treturn size;\n+    }\n \n   /* Lose any fake structure return argument if it is passed on the stack.  */\n   if (aggregate_value_p (TREE_TYPE (funtype), fundecl)\n-      && !TARGET_64BIT\n       && !KEEP_AGGREGATE_RETURN_POINTER)\n     {\n       int nregs = ix86_function_regparm (funtype, fundecl);\n-\n-      if (!nregs)\n+      if (nregs == 0)\n \treturn GET_MODE_SIZE (Pmode);\n     }\n \n@@ -3180,6 +3188,7 @@ bool\n ix86_function_arg_regno_p (int regno)\n {\n   int i;\n+\n   if (!TARGET_64BIT)\n     {\n       if (TARGET_MACHO)\n@@ -3204,9 +3213,11 @@ ix86_function_arg_regno_p (int regno)\n           && (regno < FIRST_SSE_REG + SSE_REGPARM_MAX))\n         return true;\n     }\n+\n   /* RAX is used as hidden argument to va_arg functions.  */\n-  if (!regno)\n+  if (regno == 0)\n     return true;\n+\n   for (i = 0; i < REGPARM_MAX; i++)\n     if (regno == x86_64_int_parameter_registers[i])\n       return true;\n@@ -3238,24 +3249,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n \t\t      rtx libname,\t/* SYMBOL_REF of library name or 0 */\n \t\t      tree fndecl)\n {\n-  static CUMULATIVE_ARGS zero_cum;\n-  tree param, next_param;\n-\n-  if (TARGET_DEBUG_ARG)\n-    {\n-      fprintf (stderr, \"\\ninit_cumulative_args (\");\n-      if (fntype)\n-\tfprintf (stderr, \"fntype code = %s, ret code = %s\",\n-\t\t tree_code_name[(int) TREE_CODE (fntype)],\n-\t\t tree_code_name[(int) TREE_CODE (TREE_TYPE (fntype))]);\n-      else\n-\tfprintf (stderr, \"no fntype\");\n-\n-      if (libname)\n-\tfprintf (stderr, \", libname = %s\", XSTR (libname, 0));\n-    }\n-\n-  *cum = zero_cum;\n+  memset (cum, 0, sizeof (*cum));\n \n   /* Set up the number of registers to use for passing arguments.  */\n   cum->nregs = ix86_regparm;\n@@ -3265,60 +3259,39 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n     cum->mmx_nregs = MMX_REGPARM_MAX;\n   cum->warn_sse = true;\n   cum->warn_mmx = true;\n-  cum->maybe_vaarg = false;\n+  cum->maybe_vaarg = (fntype ? type_has_variadic_args_p (fntype) : !libname);\n \n-  /* Use ecx and edx registers if function has fastcall attribute,\n-     else look for regparm information.  */\n-  if (fntype && !TARGET_64BIT)\n+  if (!TARGET_64BIT)\n     {\n-      if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (fntype)))\n+      /* If there are variable arguments, then we won't pass anything\n+         in registers in 32-bit mode. */\n+      if (cum->maybe_vaarg)\n \t{\n-\t  cum->nregs = 2;\n-\t  cum->fastcall = 1;\n+\t  cum->nregs = 0;\n+\t  cum->sse_nregs = 0;\n+\t  cum->mmx_nregs = 0;\n+\t  cum->warn_sse = 0;\n+\t  cum->warn_mmx = 0;\n+\t  return;\n \t}\n-      else\n-\tcum->nregs = ix86_function_regparm (fntype, fndecl);\n-    }\n \n-  /* Set up the number of SSE registers used for passing SFmode\n-     and DFmode arguments.  Warn for mismatching ABI.  */\n-  cum->float_in_sse = ix86_function_sseregparm (fntype, fndecl);\n-\n-  /* Determine if this function has variable arguments.  This is\n-     indicated by the last argument being 'void_type_mode' if there\n-     are no variable arguments.  If there are variable arguments, then\n-     we won't pass anything in registers in 32-bit mode. */\n-\n-  if (cum->nregs || cum->mmx_nregs || cum->sse_nregs)\n-    {\n-      for (param = (fntype) ? TYPE_ARG_TYPES (fntype) : 0;\n-\t   param != 0; param = next_param)\n+      /* Use ecx and edx registers if function has fastcall attribute,\n+\t else look for regparm information.  */\n+      if (fntype)\n \t{\n-\t  next_param = TREE_CHAIN (param);\n-\t  if (next_param == 0 && TREE_VALUE (param) != void_type_node)\n+\t  if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (fntype)))\n \t    {\n-\t      if (!TARGET_64BIT)\n-\t\t{\n-\t\t  cum->nregs = 0;\n-\t\t  cum->sse_nregs = 0;\n-\t\t  cum->mmx_nregs = 0;\n-\t\t  cum->warn_sse = 0;\n-\t\t  cum->warn_mmx = 0;\n-\t\t  cum->fastcall = 0;\n-\t\t  cum->float_in_sse = 0;\n-\t\t}\n-\t      cum->maybe_vaarg = true;\n+\t      cum->nregs = 2;\n+\t      cum->fastcall = 1;\n \t    }\n+\t  else\n+\t    cum->nregs = ix86_function_regparm (fntype, fndecl);\n \t}\n-    }\n-  if ((!fntype && !libname)\n-      || (fntype && !TYPE_ARG_TYPES (fntype)))\n-    cum->maybe_vaarg = true;\n-\n-  if (TARGET_DEBUG_ARG)\n-    fprintf (stderr, \", nregs=%d )\\n\", cum->nregs);\n \n-  return;\n+      /* Set up the number of SSE registers used for passing SFmode\n+\t and DFmode arguments.  Warn for mismatching ABI.  */\n+      cum->float_in_sse = ix86_function_sseregparm (fntype, fndecl);\n+    }\n }\n \n /* Return the \"natural\" mode for TYPE.  In most cases, this is just TYPE_MODE.\n@@ -3781,20 +3754,6 @@ construct_container (enum machine_mode mode, enum machine_mode orig_mode,\n   rtx ret;\n \n   n = classify_argument (mode, type, class, 0);\n-  if (TARGET_DEBUG_ARG)\n-    {\n-      if (!n)\n-\tfprintf (stderr, \"Memory class\\n\");\n-      else\n-\t{\n-\t  fprintf (stderr, \"Classes:\");\n-\t  for (i = 0; i < n; i++)\n-\t    {\n-\t      fprintf (stderr, \" %s\", x86_64_reg_class_name[class[i]]);\n-\t    }\n-\t   fprintf (stderr, \"\\n\");\n-\t}\n-    }\n   if (!n)\n     return NULL;\n   if (!examine_argument (mode, type, in_return, &needed_intregs,\n@@ -3863,6 +3822,7 @@ construct_container (enum machine_mode mode, enum machine_mode orig_mode,\n   if (n == 2 && class[0] == X86_64_SSE_CLASS && class[1] == X86_64_SSEUP_CLASS\n       && mode != BLKmode)\n     return gen_rtx_REG (mode, SSE_REGNO (sse_regno));\n+\n   if (n == 2\n       && class[0] == X86_64_X87_CLASS && class[1] == X86_64_X87UP_CLASS)\n     return gen_rtx_REG (XFmode, FIRST_STACK_REG);\n@@ -3938,115 +3898,124 @@ construct_container (enum machine_mode mode, enum machine_mode orig_mode,\n   return ret;\n }\n \n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n+/* Update the data in CUM to advance over an argument of mode MODE\n+   and data type TYPE.  (TYPE is null for libcalls where that information\n+   may not be available.)  */\n \n-void\n-function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t      tree type, int named)\n+static void\n+function_arg_advance_32 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t tree type, HOST_WIDE_INT bytes, HOST_WIDE_INT words)\n {\n-  int bytes =\n-    (mode == BLKmode) ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode);\n-  int words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  switch (mode)\n+    {\n+    default:\n+      break;\n \n-  if (type)\n-    mode = type_natural_mode (type);\n+    case BLKmode:\n+      if (bytes < 0)\n+\tbreak;\n+      /* FALLTHRU */\n \n-  if (TARGET_DEBUG_ARG)\n-    fprintf (stderr, \"function_adv (sz=%d, wds=%2d, nregs=%d, ssenregs=%d, \"\n-\t     \"mode=%s, named=%d)\\n\\n\",\n-\t     words, cum->words, cum->nregs, cum->sse_nregs,\n-\t     GET_MODE_NAME (mode), named);\n+    case DImode:\n+    case SImode:\n+    case HImode:\n+    case QImode:\n+      cum->words += words;\n+      cum->nregs -= words;\n+      cum->regno += words;\n \n-  if (TARGET_64BIT)\n-    {\n-      int int_nregs, sse_nregs;\n-      if (!examine_argument (mode, type, 0, &int_nregs, &sse_nregs))\n-\tcum->words += words;\n-      else if (sse_nregs <= cum->sse_nregs && int_nregs <= cum->nregs)\n+      if (cum->nregs <= 0)\n \t{\n-\t  cum->nregs -= int_nregs;\n-\t  cum->sse_nregs -= sse_nregs;\n-\t  cum->regno += int_nregs;\n-\t  cum->sse_regno += sse_nregs;\n+\t  cum->nregs = 0;\n+\t  cum->regno = 0;\n \t}\n-      else\n-\tcum->words += words;\n-    }\n-  else\n-    {\n-      switch (mode)\n-\t{\n-\tdefault:\n-\t  break;\n-\n-\tcase BLKmode:\n-\t  if (bytes < 0)\n-\t    break;\n-\t  /* FALLTHRU */\n-\n-\tcase DImode:\n-\tcase SImode:\n-\tcase HImode:\n-\tcase QImode:\n-\t  cum->words += words;\n-\t  cum->nregs -= words;\n-\t  cum->regno += words;\n-\n-\t  if (cum->nregs <= 0)\n-\t    {\n-\t      cum->nregs = 0;\n-\t      cum->regno = 0;\n-\t    }\n-\t  break;\n+      break;\n \n-\tcase DFmode:\n-\t  if (cum->float_in_sse < 2)\n-\t    break;\n-\tcase SFmode:\n-\t  if (cum->float_in_sse < 1)\n-\t    break;\n-\t  /* FALLTHRU */\n+    case DFmode:\n+      if (cum->float_in_sse < 2)\n+\tbreak;\n+    case SFmode:\n+      if (cum->float_in_sse < 1)\n+\tbreak;\n+      /* FALLTHRU */\n \n-\tcase TImode:\n-\tcase V16QImode:\n-\tcase V8HImode:\n-\tcase V4SImode:\n-\tcase V2DImode:\n-\tcase V4SFmode:\n-\tcase V2DFmode:\n-\t  if (!type || !AGGREGATE_TYPE_P (type))\n+    case TImode:\n+    case V16QImode:\n+    case V8HImode:\n+    case V4SImode:\n+    case V2DImode:\n+    case V4SFmode:\n+    case V2DFmode:\n+      if (!type || !AGGREGATE_TYPE_P (type))\n+\t{\n+\t  cum->sse_words += words;\n+\t  cum->sse_nregs -= 1;\n+\t  cum->sse_regno += 1;\n+\t  if (cum->sse_nregs <= 0)\n \t    {\n-\t      cum->sse_words += words;\n-\t      cum->sse_nregs -= 1;\n-\t      cum->sse_regno += 1;\n-\t      if (cum->sse_nregs <= 0)\n-\t\t{\n-\t\t  cum->sse_nregs = 0;\n-\t\t  cum->sse_regno = 0;\n-\t\t}\n+\t      cum->sse_nregs = 0;\n+\t      cum->sse_regno = 0;\n \t    }\n-\t  break;\n+\t}\n+      break;\n \n-\tcase V8QImode:\n-\tcase V4HImode:\n-\tcase V2SImode:\n-\tcase V2SFmode:\n-\t  if (!type || !AGGREGATE_TYPE_P (type))\n+    case V8QImode:\n+    case V4HImode:\n+    case V2SImode:\n+    case V2SFmode:\n+      if (!type || !AGGREGATE_TYPE_P (type))\n+\t{\n+\t  cum->mmx_words += words;\n+\t  cum->mmx_nregs -= 1;\n+\t  cum->mmx_regno += 1;\n+\t  if (cum->mmx_nregs <= 0)\n \t    {\n-\t      cum->mmx_words += words;\n-\t      cum->mmx_nregs -= 1;\n-\t      cum->mmx_regno += 1;\n-\t      if (cum->mmx_nregs <= 0)\n-\t\t{\n-\t\t  cum->mmx_nregs = 0;\n-\t\t  cum->mmx_regno = 0;\n-\t\t}\n+\t      cum->mmx_nregs = 0;\n+\t      cum->mmx_regno = 0;\n \t    }\n-\t  break;\n \t}\n+      break;\n+    }\n+}\n+\n+static void\n+function_arg_advance_64 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t tree type, HOST_WIDE_INT words)\n+{\n+  int int_nregs, sse_nregs;\n+\n+  if (!examine_argument (mode, type, 0, &int_nregs, &sse_nregs))\n+    cum->words += words;\n+  else if (sse_nregs <= cum->sse_nregs && int_nregs <= cum->nregs)\n+    {\n+      cum->nregs -= int_nregs;\n+      cum->sse_nregs -= sse_nregs;\n+      cum->regno += int_nregs;\n+      cum->sse_regno += sse_nregs;\n     }\n+  else\n+    cum->words += words;\n+}\n+\n+void\n+function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t      tree type, int named ATTRIBUTE_UNUSED)\n+{\n+  HOST_WIDE_INT bytes, words;\n+\n+  if (mode == BLKmode)\n+    bytes = int_size_in_bytes (type);\n+  else\n+    bytes = GET_MODE_SIZE (mode);\n+  words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  if (type)\n+    mode = type_natural_mode (type);\n+\n+  if (TARGET_64BIT)\n+    function_arg_advance_64 (cum, mode, type, words);\n+  else\n+    function_arg_advance_32 (cum, mode, type, bytes, words);\n }\n \n /* Define where to put the arguments to a function.\n@@ -4062,135 +4031,140 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n-rtx\n-function_arg (CUMULATIVE_ARGS *cum, enum machine_mode orig_mode,\n-\t      tree type, int named)\n+static rtx\n+function_arg_32 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t enum machine_mode orig_mode, tree type,\n+\t\t HOST_WIDE_INT bytes, HOST_WIDE_INT words)\n {\n-  enum machine_mode mode = orig_mode;\n-  rtx ret = NULL_RTX;\n-  int bytes =\n-    (mode == BLKmode) ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode);\n-  int words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n   static bool warnedsse, warnedmmx;\n \n-  /* To simplify the code below, represent vector types with a vector mode\n-     even if MMX/SSE are not active.  */\n-  if (type && TREE_CODE (type) == VECTOR_TYPE)\n-    mode = type_natural_mode (type);\n-\n-  /* Handle a hidden AL argument containing number of registers for varargs\n-     x86-64 functions.  For i386 ABI just return constm1_rtx to avoid\n-     any AL settings.  */\n+  /* Avoid the AL settings for the Unix64 ABI.  */\n   if (mode == VOIDmode)\n+    return constm1_rtx;\n+\n+  switch (mode)\n     {\n-      if (TARGET_64BIT)\n-\treturn GEN_INT (cum->maybe_vaarg\n-\t\t\t? (cum->sse_nregs < 0\n-\t\t\t   ? SSE_REGPARM_MAX\n-\t\t\t   : cum->sse_regno)\n-\t\t\t: -1);\n-      else\n-\treturn constm1_rtx;\n-    }\n-  if (TARGET_64BIT)\n-    ret = construct_container (mode, orig_mode, type, 0, cum->nregs,\n-\t\t\t       cum->sse_nregs,\n-\t\t\t       &x86_64_int_parameter_registers [cum->regno],\n-\t\t\t       cum->sse_regno);\n-  else\n-    switch (mode)\n-      {\n-\t/* For now, pass fp/complex values on the stack.  */\n-      default:\n+    default:\n+      break;\n+\n+    case BLKmode:\n+      if (bytes < 0)\n \tbreak;\n+      /* FALLTHRU */\n+    case DImode:\n+    case SImode:\n+    case HImode:\n+    case QImode:\n+      if (words <= cum->nregs)\n+\t{\n+\t  int regno = cum->regno;\n \n-      case BLKmode:\n-\tif (bytes < 0)\n-\t  break;\n-\t/* FALLTHRU */\n-      case DImode:\n-      case SImode:\n-      case HImode:\n-      case QImode:\n-\tif (words <= cum->nregs)\n-\t  {\n-\t    int regno = cum->regno;\n+\t  /* Fastcall allocates the first two DWORD (SImode) or\n+\t     smaller arguments to ECX and EDX.  */\n+\t  if (cum->fastcall)\n+\t    {\n+\t      if (mode == BLKmode || mode == DImode)\n+\t        break;\n \n-\t    /* Fastcall allocates the first two DWORD (SImode) or\n-\t       smaller arguments to ECX and EDX.  */\n-\t    if (cum->fastcall)\n-\t      {\n-\t        if (mode == BLKmode || mode == DImode)\n-\t          break;\n+\t      /* ECX not EAX is the first allocated register.  */\n+\t      if (regno == 0)\n+\t\tregno = 2;\n+\t    }\n+\t  return gen_rtx_REG (mode, regno);\n+\t}\n+      break;\n \n-\t        /* ECX not EAX is the first allocated register.  */\n-\t        if (regno == 0)\n-\t\t  regno = 2;\n-\t      }\n-\t    ret = gen_rtx_REG (mode, regno);\n-\t  }\n-\tbreak;\n-      case DFmode:\n-\tif (cum->float_in_sse < 2)\n-\t  break;\n-      case SFmode:\n-\tif (cum->float_in_sse < 1)\n-\t  break;\n-\t/* FALLTHRU */\n-      case TImode:\n-      case V16QImode:\n-      case V8HImode:\n-      case V4SImode:\n-      case V2DImode:\n-      case V4SFmode:\n-      case V2DFmode:\n-\tif (!type || !AGGREGATE_TYPE_P (type))\n-\t  {\n-\t    if (!TARGET_SSE && !warnedsse && cum->warn_sse)\n-\t      {\n-\t\twarnedsse = true;\n-\t\twarning (0, \"SSE vector argument without SSE enabled \"\n-\t\t\t \"changes the ABI\");\n-\t      }\n-\t    if (cum->sse_nregs)\n-\t      ret = gen_reg_or_parallel (mode, orig_mode,\n-\t\t\t\t\t cum->sse_regno + FIRST_SSE_REG);\n-\t  }\n+    case DFmode:\n+      if (cum->float_in_sse < 2)\n \tbreak;\n-      case V8QImode:\n-      case V4HImode:\n-      case V2SImode:\n-      case V2SFmode:\n-\tif (!type || !AGGREGATE_TYPE_P (type))\n-\t  {\n-\t    if (!TARGET_MMX && !warnedmmx && cum->warn_mmx)\n-\t      {\n-\t\twarnedmmx = true;\n-\t\twarning (0, \"MMX vector argument without MMX enabled \"\n-\t\t\t \"changes the ABI\");\n-\t      }\n-\t    if (cum->mmx_nregs)\n-\t      ret = gen_reg_or_parallel (mode, orig_mode,\n-\t\t\t\t\t cum->mmx_regno + FIRST_MMX_REG);\n-\t  }\n+    case SFmode:\n+      if (cum->float_in_sse < 1)\n \tbreak;\n-      }\n+      /* FALLTHRU */\n+    case TImode:\n+    case V16QImode:\n+    case V8HImode:\n+    case V4SImode:\n+    case V2DImode:\n+    case V4SFmode:\n+    case V2DFmode:\n+      if (!type || !AGGREGATE_TYPE_P (type))\n+\t{\n+\t  if (!TARGET_SSE && !warnedsse && cum->warn_sse)\n+\t    {\n+\t      warnedsse = true;\n+\t      warning (0, \"SSE vector argument without SSE enabled \"\n+\t\t       \"changes the ABI\");\n+\t    }\n+\t  if (cum->sse_nregs)\n+\t    return gen_reg_or_parallel (mode, orig_mode,\n+\t\t\t\t        cum->sse_regno + FIRST_SSE_REG);\n+\t}\n+      break;\n \n-  if (TARGET_DEBUG_ARG)\n-    {\n-      fprintf (stderr,\n-\t       \"function_arg (size=%d, wds=%2d, nregs=%d, mode=%4s, named=%d, \",\n-\t       words, cum->words, cum->nregs, GET_MODE_NAME (mode), named);\n+    case V8QImode:\n+    case V4HImode:\n+    case V2SImode:\n+    case V2SFmode:\n+      if (!type || !AGGREGATE_TYPE_P (type))\n+\t{\n+\t  if (!TARGET_MMX && !warnedmmx && cum->warn_mmx)\n+\t    {\n+\t      warnedmmx = true;\n+\t      warning (0, \"MMX vector argument without MMX enabled \"\n+\t\t       \"changes the ABI\");\n+\t    }\n+\t  if (cum->mmx_nregs)\n+\t    return gen_reg_or_parallel (mode, orig_mode,\n+\t\t\t\t        cum->mmx_regno + FIRST_MMX_REG);\n+\t}\n+      break;\n+    }\n \n-      if (ret)\n-\tprint_simple_rtl (stderr, ret);\n-      else\n-\tfprintf (stderr, \", stack\");\n+  return NULL_RTX;\n+}\n \n-      fprintf (stderr, \" )\\n\");\n-    }\n+static rtx\n+function_arg_64 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t enum machine_mode orig_mode, tree type)\n+{\n+  /* Handle a hidden AL argument containing number of registers\n+     for varargs x86-64 functions.  */\n+  if (mode == VOIDmode)\n+    return GEN_INT (cum->maybe_vaarg\n+\t\t    ? (cum->sse_nregs < 0\n+\t\t       ? SSE_REGPARM_MAX\n+\t\t       : cum->sse_regno)\n+\t\t    : -1);\n \n-  return ret;\n+  return construct_container (mode, orig_mode, type, 0, cum->nregs,\n+\t\t\t      cum->sse_nregs,\n+\t\t\t      &x86_64_int_parameter_registers [cum->regno],\n+\t\t\t      cum->sse_regno);\n+}\n+\n+rtx\n+function_arg (CUMULATIVE_ARGS *cum, enum machine_mode omode,\n+\t      tree type, int named ATTRIBUTE_UNUSED)\n+{\n+  enum machine_mode mode = omode;\n+  HOST_WIDE_INT bytes, words;\n+\n+  if (mode == BLKmode)\n+    bytes = int_size_in_bytes (type);\n+  else\n+    bytes = GET_MODE_SIZE (mode);\n+  words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  /* To simplify the code below, represent vector types with a vector mode\n+     even if MMX/SSE are not active.  */\n+  if (type && TREE_CODE (type) == VECTOR_TYPE)\n+    mode = type_natural_mode (type);\n+\n+  if (TARGET_64BIT)\n+    return function_arg_64 (cum, mode, omode, type);\n+  else\n+    return function_arg_32 (cum, mode, omode, type, bytes, words);\n }\n \n /* A C expression that indicates when an argument must be passed by\n@@ -4204,15 +4178,8 @@ ix86_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n \t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n {\n-  if (!TARGET_64BIT)\n-    return 0;\n-\n-  if (type && int_size_in_bytes (type) == -1)\n-    {\n-      if (TARGET_DEBUG_ARG)\n-\tfprintf (stderr, \"function_arg_pass_by_reference\\n\");\n-      return 1;\n-    }\n+  if (TARGET_64BIT && type && int_size_in_bytes (type) == -1)\n+    return 1;\n \n   return 0;\n }\n@@ -4304,78 +4271,162 @@ ix86_function_arg_boundary (enum machine_mode mode, tree type)\n }\n \n /* Return true if N is a possible register number of function value.  */\n+\n bool\n ix86_function_value_regno_p (int regno)\n {\n-  if (TARGET_MACHO)\n-    {\n-      if (!TARGET_64BIT)\n-        {\n-          return ((regno) == 0\n-                  || ((regno) == FIRST_FLOAT_REG && TARGET_FLOAT_RETURNS_IN_80387)\n-                  || ((regno) == FIRST_SSE_REG && TARGET_SSE));\n-        }\n-      return ((regno) == 0 || (regno) == FIRST_FLOAT_REG\n-              || ((regno) == FIRST_SSE_REG && TARGET_SSE)\n-              || ((regno) == FIRST_FLOAT_REG && TARGET_FLOAT_RETURNS_IN_80387));\n-      }\n-  else\n+  switch (regno)\n     {\n-      if (regno == 0\n-          || (regno == FIRST_FLOAT_REG && TARGET_FLOAT_RETURNS_IN_80387)\n-          || (regno == FIRST_SSE_REG && TARGET_SSE))\n-        return true;\n+    case 0:\n+      return true;\n \n-      if (!TARGET_64BIT\n-          && (regno == FIRST_MMX_REG && TARGET_MMX))\n-\t    return true;\n+    case FIRST_FLOAT_REG:\n+      return TARGET_FLOAT_RETURNS_IN_80387;\n \n-      return false;\n+    case FIRST_SSE_REG:\n+      return TARGET_SSE;\n+\n+    case FIRST_MMX_REG:\n+      if (TARGET_MACHO || TARGET_64BIT)\n+\treturn false;\n+      return TARGET_MMX;\n     }\n+\n+  return false;\n }\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n-rtx\n-ix86_function_value (tree valtype, tree fntype_or_decl,\n-\t\t     bool outgoing ATTRIBUTE_UNUSED)\n+\n+static rtx\n+function_value_32 (enum machine_mode orig_mode, enum machine_mode mode,\n+\t\t   tree fntype, tree fn)\n {\n-  enum machine_mode natmode = type_natural_mode (valtype);\n+  unsigned int regno;\n \n-  if (TARGET_64BIT)\n+  /* 8-byte vector modes in %mm0. See ix86_return_in_memory for where\n+     we normally prevent this case when mmx is not available.  However\n+     some ABIs may require the result to be returned like DImode.  */\n+  if (VECTOR_MODE_P (mode) && GET_MODE_SIZE (mode) == 8)\n+    regno = TARGET_MMX ? FIRST_MMX_REG : 0;\n+\n+  /* 16-byte vector modes in %xmm0.  See ix86_return_in_memory for where\n+     we prevent this case when sse is not available.  However some ABIs\n+     may require the result to be returned like integer TImode.  */\n+  else if (mode == TImode\n+\t   || (VECTOR_MODE_P (mode) && GET_MODE_SIZE (mode) == 16))\n+    regno = TARGET_SSE ? FIRST_SSE_REG : 0;\n+\n+  /* Decimal floating point values can go in %eax, unlike other float modes.  */\n+  else if (DECIMAL_FLOAT_MODE_P (mode))\n+    regno = 0;\n+\n+  /* Most things go in %eax, except (unless -mno-fp-ret-in-387) fp values.  */\n+  else if (!SCALAR_FLOAT_MODE_P (mode) || !TARGET_FLOAT_RETURNS_IN_80387)\n+    regno = 0;\n+\n+  /* Floating point return values in %st(0), except for local functions when\n+     SSE math is enabled or for functions with sseregparm attribute.  */\n+  else\n     {\n-      rtx ret = construct_container (natmode, TYPE_MODE (valtype), valtype,\n-\t\t\t\t     1, REGPARM_MAX, SSE_REGPARM_MAX,\n-\t\t\t\t     x86_64_int_return_registers, 0);\n-      /* For zero sized structures, construct_container return NULL, but we\n-\t need to keep rest of compiler happy by returning meaningful value.  */\n-      if (!ret)\n-\tret = gen_rtx_REG (TYPE_MODE (valtype), 0);\n-      return ret;\n+      regno = FIRST_FLOAT_REG;\n+\n+      if ((fn || fntype) && (mode == SFmode || mode == DFmode))\n+\t{\n+\t  int sse_level = ix86_function_sseregparm (fntype, fn);\n+\t  if ((sse_level >= 1 && mode == SFmode)\n+\t      || (sse_level == 2 && mode == DFmode))\n+\t    regno = FIRST_SSE_REG;\n+\t}\n     }\n-  else\n+\n+  return gen_rtx_REG (orig_mode, regno);\n+}\n+\n+static rtx\n+function_value_64 (enum machine_mode orig_mode, enum machine_mode mode,\n+\t\t   tree valtype)\n+{\n+  rtx ret;\n+\n+  /* Handle libcalls, which don't provide a type node.  */\n+  if (valtype == NULL)\n     {\n-      tree fn = NULL_TREE, fntype;\n-      if (fntype_or_decl\n-\t  && DECL_P (fntype_or_decl))\n-        fn = fntype_or_decl;\n-      fntype = fn ? TREE_TYPE (fn) : fntype_or_decl;\n-      return gen_rtx_REG (TYPE_MODE (valtype),\n-\t\t\t  ix86_value_regno (natmode, fn, fntype));\n+      switch (mode)\n+\t{\n+\tcase SFmode:\n+\tcase SCmode:\n+\tcase DFmode:\n+\tcase DCmode:\n+\tcase TFmode:\n+\tcase SDmode:\n+\tcase DDmode:\n+\tcase TDmode:\n+\t  return gen_rtx_REG (mode, FIRST_SSE_REG);\n+\tcase XFmode:\n+\tcase XCmode:\n+\t  return gen_rtx_REG (mode, FIRST_FLOAT_REG);\n+\tcase TCmode:\n+\t  return NULL;\n+\tdefault:\n+\t  return gen_rtx_REG (mode, 0);\n+\t}\n     }\n+\n+  ret = construct_container (mode, orig_mode, valtype, 1,\n+\t\t\t     REGPARM_MAX, SSE_REGPARM_MAX,\n+\t\t\t     x86_64_int_return_registers, 0);\n+\n+  /* For zero sized structures, construct_container returns NULL, but we\n+     need to keep rest of compiler happy by returning meaningful value.  */\n+  if (!ret)\n+    ret = gen_rtx_REG (orig_mode, 0);\n+\n+  return ret;\n }\n \n-/* Return true iff type is returned in memory.  */\n-int\n-ix86_return_in_memory (tree type)\n+static rtx\n+ix86_function_value_1 (tree valtype, tree fntype_or_decl,\n+\t\t       enum machine_mode orig_mode, enum machine_mode mode)\n {\n-  int needed_intregs, needed_sseregs, size;\n-  enum machine_mode mode = type_natural_mode (type);\n+  tree fn, fntype;\n+\n+  fn = NULL_TREE;\n+  if (fntype_or_decl && DECL_P (fntype_or_decl))\n+    fn = fntype_or_decl;\n+  fntype = fn ? TREE_TYPE (fn) : fntype_or_decl;\n \n   if (TARGET_64BIT)\n-    return !examine_argument (mode, type, 1, &needed_intregs, &needed_sseregs);\n+    return function_value_64 (orig_mode, mode, valtype);\n+  else\n+    return function_value_32 (orig_mode, mode, fntype, fn);\n+}\n+\n+static rtx\n+ix86_function_value (tree valtype, tree fntype_or_decl,\n+\t\t     bool outgoing ATTRIBUTE_UNUSED)\n+{\n+  enum machine_mode mode, orig_mode;\n+\n+  orig_mode = TYPE_MODE (valtype);\n+  mode = type_natural_mode (valtype);\n+  return ix86_function_value_1 (valtype, fntype_or_decl, orig_mode, mode);\n+}\n+\n+rtx\n+ix86_libcall_value (enum machine_mode mode)\n+{\n+  return ix86_function_value_1 (NULL, NULL, mode, mode);\n+}\n+\n+/* Return true iff type is returned in memory.  */\n+\n+static int\n+return_in_memory_32 (tree type, enum machine_mode mode)\n+{\n+  HOST_WIDE_INT size;\n \n   if (mode == BLKmode)\n     return 1;\n@@ -4412,6 +4463,24 @@ ix86_return_in_memory (tree type)\n   return 0;\n }\n \n+static int\n+return_in_memory_64 (tree type, enum machine_mode mode)\n+{\n+  int needed_intregs, needed_sseregs;\n+  return !examine_argument (mode, type, 1, &needed_intregs, &needed_sseregs);\n+}\n+\n+int\n+ix86_return_in_memory (tree type)\n+{\n+  enum machine_mode mode = type_natural_mode (type);\n+\n+  if (TARGET_64BIT)\n+    return return_in_memory_64 (type, mode);\n+  else\n+    return return_in_memory_32 (type, mode);\n+}\n+\n /* When returning SSE vector types, we have a choice of either\n      (1) being abi incompatible with a -march switch, or\n      (2) generating an error.\n@@ -4428,7 +4497,7 @@ ix86_struct_value_rtx (tree type, int incoming ATTRIBUTE_UNUSED)\n {\n   static bool warnedsse, warnedmmx;\n \n-  if (type)\n+  if (!TARGET_64BIT && type)\n     {\n       /* Look at the return type of the function, not the function type.  */\n       enum machine_mode mode = TYPE_MODE (TREE_TYPE (type));\n@@ -4458,77 +4527,6 @@ ix86_struct_value_rtx (tree type, int incoming ATTRIBUTE_UNUSED)\n   return NULL;\n }\n \n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-rtx\n-ix86_libcall_value (enum machine_mode mode)\n-{\n-  if (TARGET_64BIT)\n-    {\n-      switch (mode)\n-\t{\n-\tcase SFmode:\n-\tcase SCmode:\n-\tcase DFmode:\n-\tcase DCmode:\n-\tcase TFmode:\n-\tcase SDmode:\n-\tcase DDmode:\n-\tcase TDmode:\n-\t  return gen_rtx_REG (mode, FIRST_SSE_REG);\n-\tcase XFmode:\n-\tcase XCmode:\n-\t  return gen_rtx_REG (mode, FIRST_FLOAT_REG);\n-\tcase TCmode:\n-\t  return NULL;\n-\tdefault:\n-\t  return gen_rtx_REG (mode, 0);\n-\t}\n-    }\n-  else\n-    return gen_rtx_REG (mode, ix86_value_regno (mode, NULL, NULL));\n-}\n-\n-/* Given a mode, return the register to use for a return value.  */\n-\n-static int\n-ix86_value_regno (enum machine_mode mode, tree func, tree fntype)\n-{\n-  gcc_assert (!TARGET_64BIT);\n-\n-  /* 8-byte vector modes in %mm0. See ix86_return_in_memory for where\n-     we normally prevent this case when mmx is not available.  However\n-     some ABIs may require the result to be returned like DImode.  */\n-  if (VECTOR_MODE_P (mode) && GET_MODE_SIZE (mode) == 8)\n-    return TARGET_MMX ? FIRST_MMX_REG : 0;\n-\n-  /* 16-byte vector modes in %xmm0.  See ix86_return_in_memory for where\n-     we prevent this case when sse is not available.  However some ABIs\n-     may require the result to be returned like integer TImode.  */\n-  if (mode == TImode || (VECTOR_MODE_P (mode) && GET_MODE_SIZE (mode) == 16))\n-    return TARGET_SSE ? FIRST_SSE_REG : 0;\n-\n-  /* Decimal floating point values can go in %eax, unlike other float modes.  */\n-  if (DECIMAL_FLOAT_MODE_P (mode))\n-    return 0;\n-\n-  /* Most things go in %eax, except (unless -mno-fp-ret-in-387) fp values.  */\n-  if (!SCALAR_FLOAT_MODE_P (mode) || !TARGET_FLOAT_RETURNS_IN_80387)\n-    return 0;\n-\n-  /* Floating point return values in %st(0), except for local functions when\n-     SSE math is enabled or for functions with sseregparm attribute.  */\n-  if ((func || fntype)\n-      && (mode == SFmode || mode == DFmode))\n-    {\n-      int sse_level = ix86_function_sseregparm (fntype, func);\n-      if ((sse_level >= 1 && mode == SFmode)\n-\t  || (sse_level == 2 && mode == DFmode))\n-        return FIRST_SSE_REG;\n-    }\n-\n-  return FIRST_FLOAT_REG;\n-}\n \f\n /* Create the va_list data type.  */\n \n@@ -4577,51 +4575,29 @@ ix86_build_builtin_va_list (void)\n /* Worker function for TARGET_SETUP_INCOMING_VARARGS.  */\n \n static void\n-ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t\t     tree type, int *pretend_size ATTRIBUTE_UNUSED,\n-\t\t\t     int no_rtl)\n+setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n {\n-  CUMULATIVE_ARGS next_cum;\n-  rtx save_area = NULL_RTX, mem;\n+  rtx save_area, mem;\n   rtx label;\n   rtx label_ref;\n   rtx tmp_reg;\n   rtx nsse_reg;\n   int set;\n-  tree fntype;\n-  int stdarg_p;\n   int i;\n \n-  if (!TARGET_64BIT)\n-    return;\n-\n   if (! cfun->va_list_gpr_size && ! cfun->va_list_fpr_size)\n     return;\n \n   /* Indicate to allocate space on the stack for varargs save area.  */\n   ix86_save_varrargs_registers = 1;\n-\n   cfun->stack_alignment_needed = 128;\n \n-  fntype = TREE_TYPE (current_function_decl);\n-  stdarg_p = (TYPE_ARG_TYPES (fntype) != 0\n-\t      && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n-\t\t  != void_type_node));\n-\n-  /* For varargs, we do not want to skip the dummy va_dcl argument.\n-     For stdargs, we do want to skip the last named argument.  */\n-  next_cum = *cum;\n-  if (stdarg_p)\n-    function_arg_advance (&next_cum, mode, type, 1);\n-\n-  if (!no_rtl)\n-    save_area = frame_pointer_rtx;\n-\n+  save_area = frame_pointer_rtx;\n   set = get_varargs_alias_set ();\n \n-  for (i = next_cum.regno;\n+  for (i = cum->regno;\n        i < ix86_regparm\n-       && i < next_cum.regno + cfun->va_list_gpr_size / UNITS_PER_WORD;\n+       && i < cum->regno + cfun->va_list_gpr_size / UNITS_PER_WORD;\n        i++)\n     {\n       mem = gen_rtx_MEM (Pmode,\n@@ -4632,7 +4608,7 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t\t\tx86_64_int_parameter_registers[i]));\n     }\n \n-  if (next_cum.sse_nregs && cfun->va_list_fpr_size)\n+  if (cum->sse_nregs && cfun->va_list_fpr_size)\n     {\n       /* Now emit code to save SSE registers.  The AX parameter contains number\n \t of SSE parameter registers used to call this function.  We use\n@@ -4650,13 +4626,13 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       emit_insn (gen_rtx_SET (VOIDmode, tmp_reg,\n \t\t\t      gen_rtx_MULT (Pmode, nsse_reg,\n \t\t\t\t\t    GEN_INT (4))));\n-      if (next_cum.sse_regno)\n+      if (cum->sse_regno)\n \temit_move_insn\n \t  (nsse_reg,\n \t   gen_rtx_CONST (DImode,\n \t\t\t  gen_rtx_PLUS (DImode,\n \t\t\t\t\tlabel_ref,\n-\t\t\t\t\tGEN_INT (next_cum.sse_regno * 4))));\n+\t\t\t\t\tGEN_INT (cum->sse_regno * 4))));\n       else\n \temit_move_insn (nsse_reg, label_ref);\n       emit_insn (gen_subdi3 (nsse_reg, nsse_reg, tmp_reg));\n@@ -4675,9 +4651,38 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n       /* And finally do the dirty job!  */\n       emit_insn (gen_sse_prologue_save (mem, nsse_reg,\n-\t\t\t\t\tGEN_INT (next_cum.sse_regno), label));\n+\t\t\t\t\tGEN_INT (cum->sse_regno), label));\n     }\n+}\n \n+static void\n+ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t\t     tree type, int *pretend_size ATTRIBUTE_UNUSED,\n+\t\t\t     int no_rtl)\n+{\n+  CUMULATIVE_ARGS next_cum;\n+  tree fntype;\n+  int stdarg_p;\n+\n+  /* This argument doesn't appear to be used anymore.  Which is good,\n+     because the old code here didn't suppress rtl generation.  */\n+  gcc_assert (!no_rtl);\n+\n+  if (!TARGET_64BIT)\n+    return;\n+\n+  fntype = TREE_TYPE (current_function_decl);\n+  stdarg_p = (TYPE_ARG_TYPES (fntype) != 0\n+\t      && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n+\t\t  != void_type_node));\n+\n+  /* For varargs, we do not want to skip the dummy va_dcl argument.\n+     For stdargs, we do want to skip the last named argument.  */\n+  next_cum = *cum;\n+  if (stdarg_p)\n+    function_arg_advance (&next_cum, mode, type, 1);\n+\n+  setup_incoming_varargs_64 (&next_cum);\n }\n \n /* Implement va_start.  */\n@@ -4713,10 +4718,6 @@ ix86_va_start (tree valist, rtx nextarg)\n   n_gpr = current_function_args_info.regno;\n   n_fpr = current_function_args_info.sse_regno;\n \n-  if (TARGET_DEBUG_ARG)\n-    fprintf (stderr, \"va_start: words = %d, n_gpr = %d, n_fpr = %d\\n\",\n-\t     (int) words, (int) n_gpr, (int) n_fpr);\n-\n   if (cfun->va_list_gpr_size)\n     {\n       type = TREE_TYPE (gpr);\n@@ -6851,22 +6852,15 @@ legitimate_pic_address_disp_p (rtx disp)\n    be recognized.  */\n \n int\n-legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n+legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t      rtx addr, int strict)\n {\n   struct ix86_address parts;\n   rtx base, index, disp;\n   HOST_WIDE_INT scale;\n   const char *reason = NULL;\n   rtx reason_rtx = NULL_RTX;\n \n-  if (TARGET_DEBUG_ADDR)\n-    {\n-      fprintf (stderr,\n-\t       \"\\n======\\nGO_IF_LEGITIMATE_ADDRESS, mode = %s, strict = %d\\n\",\n-\t       GET_MODE_NAME (mode), strict);\n-      debug_rtx (addr);\n-    }\n-\n   if (ix86_decompose_address (addr, &parts) <= 0)\n     {\n       reason = \"decomposition failed\";\n@@ -7077,16 +7071,9 @@ legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n     }\n \n   /* Everything looks valid.  */\n-  if (TARGET_DEBUG_ADDR)\n-    fprintf (stderr, \"Success.\\n\");\n   return TRUE;\n \n  report_error:\n-  if (TARGET_DEBUG_ADDR)\n-    {\n-      fprintf (stderr, \"Error: %s\\n\", reason);\n-      debug_rtx (reason_rtx);\n-    }\n   return FALSE;\n }\n \f\n@@ -7524,13 +7511,6 @@ legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED, enum machine_mode mode)\n   int changed = 0;\n   unsigned log;\n \n-  if (TARGET_DEBUG_ADDR)\n-    {\n-      fprintf (stderr, \"\\n==========\\nLEGITIMIZE_ADDRESS, mode = %s\\n\",\n-\t       GET_MODE_NAME (mode));\n-      debug_rtx (x);\n-    }\n-\n   log = GET_CODE (x) == SYMBOL_REF ? SYMBOL_REF_TLS_MODEL (x) : 0;\n   if (log)\n     return legitimize_tls_address (x, log, false);"}, {"sha": "7eafe4e65793ac67ba09fa24fd425a006f115105", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee2f65b4bf615408fd68b6d586aefa9cfe16f636/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee2f65b4bf615408fd68b6d586aefa9cfe16f636/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=ee2f65b4bf615408fd68b6d586aefa9cfe16f636", "patch": "@@ -95,12 +95,6 @@ mcmodel=\n Target RejectNegative Joined Var(ix86_cmodel_string)\n Use given x86-64 code model\n \n-mdebug-addr\n-Target RejectNegative Var(TARGET_DEBUG_ADDR) Undocumented\n-\n-mdebug-arg\n-Target RejectNegative Var(TARGET_DEBUG_ARG) Undocumented\n-\n mfancy-math-387\n Target RejectNegative Report InverseMask(NO_FANCY_MATH_387, USE_FANCY_MATH_387)\n Generate sin, cos, sqrt for FPU"}]}