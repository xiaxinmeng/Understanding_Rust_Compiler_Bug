{"sha": "42976354a68d594935dbadbc3af015302918dcd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI5NzYzNTRhNjhkNTk0OTM1ZGJhZGJjM2FmMDE1MzAyOTE4ZGNkOQ==", "commit": {"author": {"name": "Brendan Kehoe", "email": "brendan@gcc.gnu.org", "date": "1997-07-24T21:09:25Z"}, "committer": {"name": "Brendan Kehoe", "email": "brendan@gcc.gnu.org", "date": "1997-07-24T21:09:25Z"}, "message": "92th Cygnus<->FSF quick merge\n\nFrom-SVN: r14524", "tree": {"sha": "c2967cae1435a6157dcf53c88813635f16bf238d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2967cae1435a6157dcf53c88813635f16bf238d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42976354a68d594935dbadbc3af015302918dcd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42976354a68d594935dbadbc3af015302918dcd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42976354a68d594935dbadbc3af015302918dcd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42976354a68d594935dbadbc3af015302918dcd9/comments", "author": null, "committer": null, "parents": [{"sha": "067aea74e22271b432c7aff753eb1278b3ae29b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/067aea74e22271b432c7aff753eb1278b3ae29b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/067aea74e22271b432c7aff753eb1278b3ae29b4"}], "stats": {"total": 1112, "additions": 945, "deletions": 167}, "files": [{"sha": "164551b48a810f69f2a44d457442e64c42d63c99", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 128, "deletions": 4, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -1,3 +1,126 @@\n+Wed Jul 23 13:36:25 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (struct cp_function): Add static_labelno.\n+\t(push_cp_function_context): Save it.\n+\t(pop_cp_function_context): Restore it.\n+\n+Tue Jul 22 14:43:29 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (build_component_ref_1): Convert from reference.\n+\n+Tue Jul 22 11:06:23 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* parse.y (current_declspecs, prefix_attributes): Initialize to\n+\tNULL_TREE.\n+\n+\t* parse.y (initdcl0): Make sure CURRENT_DECLSPECS is non-nil\n+\tbefore we try to force it to be a TREE_LIST.\n+\t(decl): Make sure $1.t is non-nil.\n+\n+Sun Jul 20 11:53:07 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (uses_template_parms): Handle template first-parse codes.\n+\n+\t* decl.c (cp_finish_decl): Only warn about user-defined statics.\n+\n+Fri Jul 18 17:56:08 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (unify): Handle BOOLEAN_TYPE.\n+\n+\t* cp-tree.h: Lose PARM_DEFAULT_FROM_TEMPLATE.\n+\t* pt.c (tsubst): Don't set it.\n+\t* call.c (build_over_call): Use uses_template_parms.\n+\n+Thu Jul 17 18:06:30 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (build_overload_nested_name): Use static_labelno\n+ \tinstead of var_labelno.\n+\t(build_qualified_name): New fn.\n+\t(build_overload_name): Split out from here.\n+\t(build_static_name): Use build_qualified_name.\n+\t* decl.c (cp_finish_decl): Statics in extern inline functions \n+\thave comdat linkage.\n+\t(start_function): Initialize static_labelno.\n+\n+Thu Jul 17 11:20:17 1997  Benjamin Kosnik  <bkoz@rhino.cygnus.com>\n+\n+\t* class.c (finish_struct_methods): add check of warn_ctor_dtor_privacy\n+\tbefore \"all member functions in class [] are private\"\n+\n+Wed Jul 16 23:47:08 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* lex.c (do_scoped_id): convert_from_reference.\n+\t* init.c (build_offset_ref): Likewise.\n+\n+Wed Jul 16 15:57:42 1997  Benjamin Kosnik  <bkoz@rhino.cygnus.com>\n+\n+\t* parse.y (empty_parms): Only use VOID_LIST_NODE for the PARMS if\n+\twe're in a C++ struct/class, not if we're doing `extern \"C\"'.\n+\n+Wed Jul 16 12:34:29 1997  Benjamin Kosnik  <bkoz@lisa.cygnus.com>\n+\n+\t* error.c (dump_expr): Check TREE_OPERAND before dump_expr_list.\n+\n+Mon Jul 14 03:23:46 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (get_member_function_from_ptrfunc): Promote index\n+ \tbefore saving it.\n+\n+Sun Jul 13 00:11:52 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tree.c (layout_basetypes): Move non-virtual destructor warning.\n+\t* decl.c (xref_basetypes): Remove non-virtual destructor warning.\n+\n+Sat Jul 12 12:47:12 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (grokdeclarator): Call add_defarg_fn for the function\n+\ttype, too.\n+\t* lex.c (add_defarg_fn): Adjust.\n+\t(do_pending_defargs): Adjust.  Don't skip the first parm.\n+\n+Fri Jul 11 01:39:50 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (build_enumerator): Global enumerators are also readonly.\n+\n+\t* rtti.c (build_dynamic_cast_1): Renamed from build_dynamic_cast.\n+\t(build_dynamic_cast): Call it and convert_from_reference.\n+\n+\t* lex.c (add_defarg_fn): New fn.\n+\t(snarf_defarg): Don't add to defarg_types.\n+\t(do_pending_defargs): Lose defarg_types.  All fns we process now\n+\thave defargs.\n+\t* decl.c (grokfndecl): Call add_defarg_fn.\n+\n+\t* Makefile.in (CONFLICTS): Expect 18 s/r conflicts.\n+\t* cp-tree.def: Add DEFAULT_ARG.\n+\t* spew.c (yylex): Call snarf_defarg as appropriate.\n+\t* parse.y: New tokens DEFARG and DEFARG_MARKER.\n+\t(defarg_again, pending_defargs, defarg, defarg1): New rules.\n+\t(structsp): Use pending_defargs.\n+\t(parms, full_parm): Use defarg.\n+\t* lex.c (init_lex): Initialize inline_text_firstobj.\n+\t(do_pending_inlines): Never pass the obstack to feed_input.\n+\t(process_next_inline): Call end_input instead of restore_pending_input.\n+\t(clear_inline_text_obstack, reinit_parse_for_expr, do_pending_defargs,\n+\tfinish_defarg, feed_defarg, snarf_defarg, maybe_snarf_defarg): New fns.\n+\t* input.c (end_input): New fn.\n+\t(sub_getch): At the end of some fed input, just keep returning EOF\n+\tuntil someone calls end_input.\n+\tRemove 'obstack' field from struct input_source.\n+\t* decl.c (grokparms): Handle DEFAULT_ARG.\n+\t(replace_defarg): New fn.\n+\t* cp-tree.h (DEFARG_LENGTH, DEFARG_POINTER): New macros.\n+\n+Wed Jul  9 13:44:12 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (implicit_conversion): If nothing else works, try binding\n+\tan rvalue to a reference.\n+\n+Wed Jul  9 13:04:38 1997  Geoffrey Noer  <noer@cygnus.com>\n+\n+\t* decl.c (init_decl_processing): fix Jun 30 patch -- move\n+\tifndef for Cygwin32 to include SIGSEGV.\n+\n Thu Jul  3 01:44:05 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* class.c (finish_struct_1): Only complain about pointers without\n@@ -16,10 +139,11 @@ Thu Jul  3 01:44:05 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n Mon Jun 30 17:53:21 1997  Geoffrey Noer  <noer@cygnus.com>\n \n-        * decl.c: Stop trying to catch signals other than SIGABRT\n-        since the Cygwin32 library doesn't support them correctly\n-        yet.  This fixes a situation in which g++ causes a hang on\n-        SIGSEGVs and other such signals in our Win32-hosted tools.\n+        * decl.c (init_decl_processing): Stop trying to catch signals\n+\tother than SIGABRT since the Cygwin32 library doesn't support\n+\tthem correctly yet.  This fixes a situation in which g++ causes\n+\ta hang on SIGSEGVs and other such signals in our Win32-hosted\n+\ttools.\n \n Mon Jun 30 14:50:01 1997  Jason Merrill  <jason@yorick.cygnus.com>\n "}, {"sha": "b7f3826bdaba206c8e771d0c7598e118a9f6d516", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -195,7 +195,7 @@ parse.o : $(PARSE_C) $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(BIG_SWITCHFLAG) \\\n   `echo $(PARSE_C) | sed 's,^\\./,,'`\n \n-CONFLICTS = expect 16 shift/reduce conflicts and 39 reduce/reduce conflicts.\n+CONFLICTS = expect 18 shift/reduce conflicts and 39 reduce/reduce conflicts.\n $(PARSE_H) : $(PARSE_C)\n $(PARSE_C) : $(srcdir)/parse.y\n \t@echo $(CONFLICTS)"}, {"sha": "14f84084314ed2222e57062204b7e818d136d72f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -3281,14 +3281,19 @@ implicit_conversion (to, from, expr, flags)\n \tconv = cand->second_conv;\n       if ((! conv || ICS_BAD_FLAG (conv))\n \t  && TREE_CODE (to) == REFERENCE_TYPE\n-\t  && TYPE_READONLY (TREE_TYPE (to))\n-\t  && ! TYPE_VOLATILE (TREE_TYPE (to))\n \t  && (flags & LOOKUP_NO_TEMP_BIND) == 0)\n \t{\n \t  cand = build_user_type_conversion_1\n \t    (TYPE_MAIN_VARIANT (TREE_TYPE (to)), expr, LOOKUP_ONLYCONVERTING);\n \t  if (cand)\n-\t    conv = build_conv (REF_BIND, to, cand->second_conv);\n+\t    {\n+\t      if (! TYPE_READONLY (TREE_TYPE (to))\n+\t\t  || TYPE_VOLATILE (TREE_TYPE (to)))\n+\t\tICS_BAD_FLAG (cand->second_conv) = 1;\n+\t      if (!conv || (ICS_BAD_FLAG (conv)\n+\t\t\t    > ICS_BAD_FLAG (cand->second_conv)))\n+\t\tconv = build_conv (REF_BIND, to, cand->second_conv);\n+\t    }\n \t}\n     }\n \n@@ -5108,10 +5113,11 @@ build_over_call (fn, convs, args, flags)\n     {\n       tree arg = TREE_PURPOSE (parm);\n \n-      if (PARM_DEFAULT_FROM_TEMPLATE (parm))\n+      if (DECL_TEMPLATE_INFO (fn) && uses_template_parms (arg))\n \t/* This came from a template.  Instantiate the default arg here,\n \t   not in tsubst.  */\n-\targ = tsubst_expr (arg, &TREE_VEC_ELT (DECL_TI_ARGS (fn), 0),\n+\targ = tsubst_expr (arg,\n+\t\t\t   &TREE_VEC_ELT (DECL_TI_ARGS (fn), 0),\n \t\t\t   TREE_VEC_LENGTH (DECL_TI_ARGS (fn)), NULL_TREE);\n       converted_args = tree_cons\n \t(NULL_TREE, convert_default_arg (TREE_VALUE (parm), arg),"}, {"sha": "5ab16582b61dd255a0e699a210b6070bd9528740", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -2011,7 +2011,8 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \t    nonprivate_method = 1;\n \t    break;\n \t  }\n-      if (nonprivate_method == 0)\n+      if (nonprivate_method == 0 \n+\t  && warn_ctor_dtor_privacy)\n \tcp_warning (\"all member functions in class `%T' are private\", t);\n     }\n "}, {"sha": "a92bf8a6f112383b74e3933230c773cc9d58d769", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -110,6 +110,11 @@ DEFTREECODE (NAMESPACE_DECL, \"namespace_decl\", \"d\", 0)\n    This is not an alias, but is later expanded into multiple aliases.  */\n DEFTREECODE (USING_DECL, \"using_decl\", \"d\", 0)\n \n+/* An un-parsed default argument.  Looks like an IDENTIFIER_NODE.  */\n+DEFTREECODE (DEFAULT_ARG, \"default_arg\", \"c\", 2)\n+\n+/* A whole bunch of tree codes for the initial, superficial parsing of\n+   templates.  */\n DEFTREECODE (LOOKUP_EXPR, \"lookup_expr\", \"e\", 2)\n DEFTREECODE (MODOP_EXPR, \"modop_expr\", \"e\", 3)\n DEFTREECODE (CAST_EXPR, \"cast_expr\", \"1\", 1)"}, {"sha": "201db3e6e15e42ddced65e28cf9d80c9025db70b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -1094,10 +1094,6 @@ struct lang_decl\n #define DELETE_EXPR_USE_VEC(NODE)\tTREE_LANG_FLAG_1 (NODE)\n #define LOOKUP_EXPR_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n \n-/* For a TREE_LIST node representing a function parm type and its default arg,\n-   did the default arg come from a template?  */\n-#define PARM_DEFAULT_FROM_TEMPLATE(NODE) TREE_LANG_FLAG_0 (NODE)\n-\n /* Nonzero in INT_CST means that this int is negative by dint of\n    using a twos-complement negated operand.  */\n #define TREE_NEGATED_INT(NODE) (TREE_LANG_FLAG_0 (NODE))\n@@ -1418,6 +1414,10 @@ extern int flag_new_for_scope;\n #define UPT_TEMPLATE(NODE)      TREE_PURPOSE(TYPE_VALUES(NODE))\n #define UPT_PARMS(NODE)         TREE_VALUE(TYPE_VALUES(NODE))\n \n+/* An un-parsed default argument looks like an identifier.  */\n+#define DEFARG_LENGTH(NODE)\tIDENTIFIER_LENGTH(NODE)\n+#define DEFARG_POINTER(NODE)\tIDENTIFIER_POINTER(NODE)\n+\n #define builtin_function(NAME, TYPE, CODE, LIBNAME) \\\n   define_function (NAME, TYPE, CODE, (void (*)())pushdecl, LIBNAME)\n "}, {"sha": "a1aa9bbe7c19d78558dc63340183dfbf691182de", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 73, "deletions": 8, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -51,6 +51,8 @@ extern int current_class_depth;\n \n extern tree static_ctors, static_dtors;\n \n+extern int static_labelno;\n+\n /* Stack of places to restore the search obstack back to.  */\n    \n /* Obstack used for remembering local class declarations (like\n@@ -4672,12 +4674,12 @@ init_decl_processing ()\n   current_binding_level = NULL_BINDING_LEVEL;\n   free_binding_level = NULL_BINDING_LEVEL;\n \n+#ifndef __CYGWIN32__\n   /* Because most segmentation signals can be traced back into user\n      code, catch them and at least give the user a chance of working\n      around compiler bugs.  */\n   signal (SIGSEGV, signal_catch);\n \n-#ifndef __CYGWIN32__\n   /* We will also catch aborts in the back-end through signal_catch and\n      give the user a chance to see where the error might be, and to defeat\n      aborts in the back-end when there have been errors previously in their\n@@ -6532,6 +6534,32 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       if (was_temp)\n \tend_temporary_allocation ();\n \n+      /* Extern inline function static data has external linkage.  */\n+      if (TREE_CODE (decl) == VAR_DECL\n+\t  && TREE_STATIC (decl)\n+\t  && current_function_decl\n+\t  && DECL_CONTEXT (decl) == current_function_decl\n+\t  && DECL_THIS_INLINE (current_function_decl)\n+\t  && DECL_PUBLIC (current_function_decl))\n+\t{\n+\t  /* We can only do this if we can use common or weak, and we\n+\t     can't if it has been initialized and we don't support weak.  */\n+\t  if (DECL_INITIAL (decl) == NULL_TREE\n+\t      || DECL_INITIAL (decl) == error_mark_node)\n+\t    {\n+\t      TREE_PUBLIC (decl) = 1;\n+\t      DECL_COMMON (decl) = 1;\n+\t    }\n+\t  else if (flag_weak)\n+\t    make_decl_one_only (decl);\n+\n+\t  if (TREE_PUBLIC (decl))\n+\t    DECL_ASSEMBLER_NAME (decl)\n+\t      = build_static_name (current_function_decl, DECL_NAME (decl));\n+\t  else if (! DECL_ARTIFICIAL (decl))\n+\t    cp_warning_at (\"sorry: semantics of inline function static data `%#D' are wrong (you'll wind up with multiple copies)\", decl);\n+\t}\n+\n       if (TREE_CODE (decl) == VAR_DECL && DECL_VIRTUAL_P (decl))\n \tmake_decl_rtl (decl, NULL_PTR, toplev);\n       else if (TREE_CODE (decl) == VAR_DECL\n@@ -7067,6 +7095,7 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n {\n   tree cname, decl;\n   int staticp = ctype && TREE_CODE (type) == FUNCTION_TYPE;\n+  tree t;\n \n   if (ctype)\n     cname = TREE_CODE (TYPE_NAME (ctype)) == TYPE_DECL\n@@ -7128,6 +7157,14 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n   if (ctype && hack_decl_function_context (decl))\n       DECL_NO_STATIC_CHAIN (decl) = 1;\n \n+  for (t = TYPE_ARG_TYPES (TREE_TYPE (decl)); t; t = TREE_CHAIN (t))\n+    if (TREE_PURPOSE (t)\n+\t&& TREE_CODE (TREE_PURPOSE (t)) == DEFAULT_ARG)\n+      {\n+\tadd_defarg_fn (decl);\n+\tbreak;\n+      }\n+\n   /* Caller will do the rest of this.  */\n   if (check < 0)\n     return decl;\n@@ -8672,6 +8709,17 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    /* ANSI says that `const int foo ();'\n \t       does not make the function foo const.  */\n \t    type = build_function_type (type, arg_types);\n+\n+\t    {\n+\t      tree t;\n+\t      for (t = arg_types; t; t = TREE_CHAIN (t))\n+\t\tif (TREE_PURPOSE (t)\n+\t\t    && TREE_CODE (TREE_PURPOSE (t)) == DEFAULT_ARG)\n+\t\t  {\n+\t\t    add_defarg_fn (type);\n+\t\t    break;\n+\t\t  }\n+\t    }\n \t  }\n \t  break;\n \n@@ -9858,6 +9906,9 @@ grokparms (first_parm, funcdef_flag)\n \t\t\tPARM_DECL_EXPR (init) = 1;\n \t\t      else if (processing_template_decl)\n \t\t\t;\n+\t\t      /* Unparsed default arg from in-class decl.  */\n+\t\t      else if (TREE_CODE (init) == DEFAULT_ARG)\n+\t\t\t;\n \t\t      else if (TREE_CODE (init) == VAR_DECL\n \t\t\t       || TREE_CODE (init) == PARM_DECL)\n \t\t\t{\n@@ -9877,6 +9928,7 @@ grokparms (first_parm, funcdef_flag)\n \t\t      else\n \t\t\tinit = require_instantiated_type (type, init, integer_zero_node);\n \t\t      if (! processing_template_decl\n+\t\t\t  && TREE_CODE (init) != DEFAULT_ARG\n \t\t\t  && ! can_convert_arg (type, TREE_TYPE (init), init))\n \t\t\tcp_pedwarn (\"invalid type `%T' for default argument to `%#D'\",\n \t\t\t\t    TREE_TYPE (init), decl);\n@@ -9931,6 +9983,21 @@ grokparms (first_parm, funcdef_flag)\n \n   return result;\n }\n+\n+/* Called from the parser to update an element of TYPE_ARG_TYPES for some\n+   FUNCTION_TYPE with the newly parsed version of its default argument, which\n+   was previously digested as text.  See snarf_defarg et al in lex.c.  */\n+\n+void\n+replace_defarg (arg, init)\n+     tree arg, init;\n+{\n+  if (! processing_template_decl\n+      && ! can_convert_arg (TREE_VALUE (arg), TREE_TYPE (init), init))\n+    cp_pedwarn (\"invalid type `%T' for default argument to `%T'\",\n+\t\tTREE_TYPE (init), TREE_VALUE (arg));\n+  TREE_PURPOSE (arg) = init;\n+}\n \f\n int\n copy_args_p (d)\n@@ -10595,13 +10662,6 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t      continue;\n \t    }\n \n-\t  /* Effective C++ rule 14.  The case of virtual functions but\n-\t     non-virtual dtor is handled in finish_struct_1.  */\n-\t  if (warn_ecpp && ! TYPE_VIRTUAL_P (basetype)\n-\t      && TYPE_HAS_DESTRUCTOR (basetype))\n-\t    cp_warning (\"base class `%#T' has a non-virtual destructor\",\n-\t\t\tbasetype);\n-\n \t  /* Note that the BINFO records which describe individual\n \t     inheritances are *not* shared in the lattice!  They\n \t     cannot be shared because a given baseclass may be\n@@ -10891,6 +10951,7 @@ build_enumerator (name, value)\n \t a function could mean local to a class method.  */\n       decl = build_decl (CONST_DECL, name, integer_type_node);\n       DECL_INITIAL (decl) = value;\n+      TREE_READONLY (decl) = 1;\n \n       pushdecl (decl);\n       GNU_xref_decl (current_function_decl, decl);\n@@ -10988,6 +11049,7 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n   current_base_init_list = NULL_TREE;\n   current_member_init_list = NULL_TREE;\n   ctor_label = dtor_label = NULL_TREE;\n+  static_labelno = 0;\n \n   clear_temp_name ();\n \n@@ -12606,6 +12668,7 @@ struct cp_function\n   rtx result_rtx;\n   struct cp_function *next;\n   struct binding_level *binding_level;\n+  int static_labelno;\n };\n \n static struct cp_function *cp_function_chain;\n@@ -12647,6 +12710,7 @@ push_cp_function_context (context)\n   p->member_init_list = current_member_init_list;\n   p->current_class_ptr = current_class_ptr;\n   p->current_class_ref = current_class_ref;\n+  p->static_labelno = static_labelno;\n }\n \n /* Restore the variables used during compilation of a C++ function.  */\n@@ -12688,6 +12752,7 @@ pop_cp_function_context (context)\n   current_member_init_list = p->member_init_list;\n   current_class_ptr = p->current_class_ptr;\n   current_class_ref = p->current_class_ref;\n+  static_labelno = p->static_labelno;\n \n   free (p);\n }"}, {"sha": "98ca15f02aaee2a8b2c765144be0e2f59e45fe2c", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -1081,7 +1081,8 @@ dump_expr (t, nop)\n     case NEW_EXPR:\n       OB_PUTID (TYPE_IDENTIFIER (TREE_TYPE (t)));\n       OB_PUTC ('(');\n-      dump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)));\n+      if (TREE_OPERAND (t, 1))\n+\tdump_expr_list (TREE_CHAIN (TREE_OPERAND (t, 1)));\n       OB_PUTC (')');\n       break;\n "}, {"sha": "5fe34b0a6df513e24fdc829342948b21e41a3f0f", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 241, "deletions": 2, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -26,6 +26,7 @@ Questions and comments to Mike Stump @code{<mrs@@cygnus.com>}.\n * Copying Objects::             \n * Exception Handling::          \n * Free Store::                  \n+* Mangling::  Function name mangling for C++ and Java\n * Concept Index::               \n @end menu\n \n@@ -1472,7 +1473,7 @@ would do the hard work of fixing up the registers, adjusting the stack\n pointer, frame pointer, arg pointer and so on.\n \n \n-@node Free Store, Concept Index, Exception Handling, Top\n+@node Free Store, Mangling, Exception Handling, Top\n @section Free Store\n \n @code{operator new []} adds a magic cookie to the beginning of arrays\n@@ -1518,8 +1519,246 @@ The linkage code in g++ is horribly twisted in order to meet two design goals:\n To meet the first goal, we defer emission of inlines and vtables until\n the end of the translation unit, where we can decide whether or not they\n are needed, and how to emit them if they are.\n+        \n+@node Mangling, Concept Index, Free Store, Top\n+@section Function name mangling for C++ and Java\n+\n+Both C++ and Jave provide overloaded function and methods,\n+which are methods with the same types but different parameter lists.\n+Selecting the correct version is done at compile time.\n+Though the overloaded functions have the same name in the source code,\n+they need to be translated into different assembler-level names,\n+since typical assemblers and linkers cannot handle overloading.\n+This process of encoding the parameter types with the method name\n+into a unique name is called @dfn{name mangling}.  The inverse\n+process is called @dfn{demangling}.\n+\n+It is convenient that C++ and Java use compatible mangling schemes,\n+since the makes life easier for tools such as gdb, and it eases\n+integration between C++ and Java.\n+\n+Note there is also a standard \"Jave Native Interface\" (JNI) which\n+implements a different calling convention, and uses a different\n+mangling scheme.  The JNI is a rather abstract ABI so Java can call methods\n+written in C or C++; \n+we are concerned here about a lower-level interface primarily\n+intended for methods written in Java, but that can also be used for C++\n+(and less easily C).\n+\n+@subsection Method name mangling\n+\n+C++ mangles a method by emitting the function name, followed by @code{__},\n+followed by encodings of any method qualifiers (such as @code{const}),\n+followed by the mangling of the method's class,\n+followed by the mangling of the parameters, in order.\n+\n+For example @code{Foo::bar(int, long) const} is mangled\n+as @samp{bar__C3Fooil}.\n+\n+For a constructor, the method name is left out.\n+That is @code{Foo::Foo(int, long) const}  is mangled \n+as @samp{__C3Fooil}. \n+\n+GNU Java does the same.\n+\n+@subsection Primitive types\n+\n+The C++ types @code{int}, @code{long}, @code{short}, @code{char},\n+and @code{long long} are mangled as @samp{i}, @samp{l},\n+@samp{s}, @samp{c}, and @samp{x}, respectively.\n+The corresponding unsigned types have @samp{U} prefixed\n+to the mangling.  The type @code{signed char} is mangled @samp{Sc}.\n+\n+The C++ and Java floating-point types @code{float} and @code{double}\n+are mangled as @samp{f} and @samp{d} respectively.\n+\n+The C++ @code{bool} type and the Java @code{boolean} type are\n+mangled as @samp{b}.\n+\n+The C++ @code{wchar_t} and the Java @code{char} types are\n+mangled as @samp{w}.\n+\n+The Java integral types @code{byte}, @code{short}, @code{int}\n+and @code{long} are mangled as @samp{c}, @samp{s}, @samp{i},\n+and @samp{x}, respectively.\n+\n+C++ code that has included @code{javatypes.h} will mangle\n+the typedefs  @code{jbyte}, @code{jshort}, @code{jint}\n+and @code{jlong} as respectively @samp{c}, @samp{s}, @samp{i},\n+and @samp{x}.  (This has not been implemented yet.)\n+\n+@subsection Mangling of simple names\n+\n+A simple class, package, template, or namespace name is\n+encoded as the number of characters in the name, followed by\n+the actual characters.  Thus the class @code{Foo}\n+is encoded as @samp{3Foo}.\n+\n+If any of the characters in the name are not alphanumeric\n+(i.e not one of the standard ASCII letters, digits, or '_'),\n+or the initial character is a digit, then the name is\n+mangled as a sequence of encoded Unicode letters.\n+A Unicode encoding starts with a @samp{U} to indicate\n+that Unicode escapes are used, followed by the number of\n+bytes used by the Unicode encoding, followed by the bytes\n+representing the encoding.  ASSCI letters and\n+non-initial digits are encoded without change.  However, all\n+other characters (including underscore and initial digits) are\n+translated into a sequence starting with an underscore,\n+followed by the big-endian 4-hex-digit lower-case encoding of the character.\n+\n+If a method name contains Unicode-escaped characters, the\n+entire mangled method name is followed by a @samp{U}.\n+\n+For example, the method @code{X\\u0319::M\\u002B(int)} is encoded as\n+@samp{M_002b__U6X_0319iU}.\n+\n+@subsection Pointer and reference types\n+\n+A C++ pointer type is mangled as @samp{P} followed by the\n+mangling of the type pointed to.\n+\n+A C++ reference type as mangled as @samp{R} followed by the\n+mangling of the type referenced.\n+\n+A Java object reference type is equivalent\n+to a C++ pointer parameter, so we mangle such an parameter type\n+as @samp{P} followed by the mangling of the class name.\n+\n+@subsection Qualified names\n+\n+Both C++ and Java allow a class to be lexically nested inside another\n+class.  C++ also supports namespaces (not yet implemented by G++).\n+Java also supports packages.\n+\n+These are all mangled the same way:  First the letter @samp{Q}\n+indicates that we are emitting a qualified name.\n+That is followed by the number of parts in the qualified name.\n+If that number is 9 or less, it is emitted with no delimiters.\n+Otherwise, an underscore is written before and after the count.\n+Then follows each part of the qualified name, as described above.\n+\n+For example @code{Foo::\\u0319::Bar} is encoded as\n+@samp{Q33FooU5_03193Bar}.\n+\n+@subsection Templates\n+\n+A template instantiation is encoded as the letter @samp{t},\n+followed by the encoding of the template name, followed\n+the number of template parameters, followed by encoding of the template\n+parameters.  If a template parameter is a type, it is written\n+as a @samp{Z} followed by the encoding of the type.\n+\n+@subsection Arrays\n+\n+C++ array types are mangled by emitting @samp{A}, followed by\n+the length of the array, followed by an @samp{_}, followed by\n+the mangling of the element type.  Of course, normally\n+array parameter types decay into a pointer types, so you\n+don't see this.\n+\n+Java arrays are objects.  A Java type @code{T[]} is mangled\n+as if it were the C++ type @code{JArray<T>}.\n+For example @code{java.lang.String[]} is encoded as\n+@samp{Pt6JArray1ZPQ34java4lang6String}.\n+\n+@subsection Table of demangling code characters\n+\n+The following special characters are used in mangling:\n+\n+@table @samp\n+@item A\n+Indicates a C++ array type.\n+\n+@item b\n+Encodes the C++ @code{bool} type,\n+and the Java @code{boolean} type.\n+\n+@item c\n+Encodes the C++ @code{char} type, and the Java @code{byte} type.\n+\n+@item C\n+A modifier to indicate a @code{const} type.\n+Also used to indicate a @code{const} member function\n+(in which cases it precedes the encoding of the method's class).\n+\n+@item d\n+Encodes the C++ and Java @code{double} types.\n+\n+@item e\n+Indicates extra unknown arguments @code{...}.\n+\n+@item f\n+Encodes the C++ and Java @code{float} types.\n+\n+@item F\n+Used to indicate a function type.\n+\n+@item i\n+Encodes the C++ and Java @code{int} types.\n+\n+@item J\n+Indicates a complex type.\n+\n+@item l\n+Encodes the C++ @code{long} type.\n+\n+@item P\n+Indicates a pointer type.  Followed by the type pointed to.\n+\n+@item Q\n+Used to mangle qualified names, which arise from nested classes.\n+Should also be used for namespaces (?).\n+In Java used to mangle package-qualified names, and inner classes.\n+\n+@item r\n+Encodes the GNU C++ @code{long double} type.\n+\n+@item R\n+Indicates a reference type.  Followed by the referenced type.\n+\n+@item s\n+Encodes the C++ and java @code{short} types.\n+\n+@item S\n+A modifier that indicates that the following integer type is signed.\n+Only used with @code{char}.\n+\n+Also used as a modifier to indicate a static member function.\n+\n+@item t\n+Indicates a template instantiation.\n+\n+@item T\n+A back reference to a previously seen type.\n+\n+@item U\n+A modifier that indicates that the following integer type is unsigned.\n+Also used to indicate that the following class or namespace name\n+is encoded using Unicode-mangling.\n+\n+@item v\n+Encodes the C++ and Java @code{void} types.\n+\n+@item V\n+A modified for a @code{const} type or method.\n+\n+@item w\n+Encodes the C++ @code{wchar_t} type, and the Java @code{char} types.\n+\n+@item x\n+Encodes the GNU C++ @code{long long} type, and the Java @code{long} type.\n+\n+@item Z\n+Used for template type parameters. \n+\n+@end table\n+\n+The letters @samp{G}, @samp{M}, @samp{O}, and @samp{p}\n+also seem to be used for obscure purposes ...\n+\n+@node Concept Index,  , Mangling, Top\n \n-@node Concept Index,  , Free Store, Top\n @section Concept Index\n \n @printindex cp"}, {"sha": "19853396acc79d70f7239068e49a26581a6b9443", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -1963,7 +1963,7 @@ build_offset_ref (type, name)\n   if (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == CONST_DECL)\n     {\n       mark_used (t);\n-      return t;\n+      return convert_from_reference (t);\n     }\n \n   if (TREE_CODE (t) == FIELD_DECL && DECL_BIT_FIELD (t))"}, {"sha": "923f27c959165fc074e60d97960682c627d626b8", "filename": "gcc/cp/input.c", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finput.c?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -30,7 +30,6 @@ Boston, MA 02111-1307, USA.  */\n    inlining).  */\n \n #include <stdio.h>\n-#include \"obstack.h\"\n \n extern FILE *finput;\n \n@@ -43,8 +42,6 @@ struct input_source {\n   int length;\n   /* current position, when reading as input */\n   int offset;\n-  /* obstack to free this input string from when finished, if any */\n-  struct obstack *obstack;\n   /* linked list maintenance */\n   struct input_source *next;\n   /* values to restore after reading all of current string */\n@@ -78,17 +75,13 @@ allocate_input ()\n     }\n   inp = (struct input_source *) xmalloc (sizeof (struct input_source));\n   inp->next = 0;\n-  inp->obstack = 0;\n   return inp;\n }\n \n static inline void\n free_input (inp)\n      struct input_source *inp;\n {\n-  if (inp->obstack)\n-    obstack_free (inp->obstack, inp->str);\n-  inp->obstack = 0;\n   inp->str = 0;\n   inp->length = 0;\n   inp->next = free_inputs;\n@@ -102,10 +95,9 @@ static int putback_char = -1;\n \n inline\n void\n-feed_input (str, len, delete)\n+feed_input (str, len)\n      char *str;\n      int len;\n-     struct obstack *delete;\n {\n   struct input_source *inp = allocate_input ();\n \n@@ -115,7 +107,6 @@ feed_input (str, len, delete)\n \n   inp->str = str;\n   inp->length = len;\n-  inp->obstack = delete;\n   inp->offset = 0;\n   inp->next = input;\n   inp->filename = input_filename;\n@@ -129,6 +120,22 @@ feed_input (str, len, delete)\n struct pending_input *to_be_restored; /* XXX */\n extern int end_of_file;\n \n+static inline void\n+end_input ()\n+{\n+  struct input_source *inp = input;\n+\n+  end_of_file = 0;\n+  input = inp->next;\n+  input_filename = inp->filename;\n+  lineno = inp->lineno;\n+  /* Get interface/implementation back in sync.  */\n+  extract_interface_info ();\n+  putback_char = inp->putback_char;\n+  restore_pending_input (inp->input);\n+  free_input (inp);\n+}\n+\n static inline int\n sub_getch ()\n {\n@@ -140,30 +147,12 @@ sub_getch ()\n     }\n   if (input)\n     {\n-      if (input->offset == input->length)\n+      if (input->offset >= input->length)\n \t{\n-\t  struct input_source *inp = input;\n \t  my_friendly_assert (putback_char == -1, 223);\n-\t  to_be_restored = inp->input;\n-\t  input->offset++;\n \t  return EOF;\n \t}\n-      else if (input->offset > input->length)\n-\t{\n-\t  struct input_source *inp = input;\n-\n-\t  end_of_file = 0;\n-\t  input = inp->next;\n-\t  input_filename = inp->filename;\n-\t  lineno = inp->lineno;\n-\t  /* Get interface/implementation back in sync.  */\n-\t  extract_interface_info ();\n-\t  putback_char = inp->putback_char;\n-\t  free_input (inp);\n-\t  return getch ();\n-\t}\n-      if (input)\n-\treturn (unsigned char)input->str[input->offset++];\n+      return (unsigned char)input->str[input->offset++];\n     }\n   return getc (finput);\n }"}, {"sha": "0e5e13e2b26788e8aee1640ca6ef6e9de4e1355d", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 266, "deletions": 10, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -72,6 +72,7 @@ void yyerror ();\n /* This obstack is needed to hold text.  It is not safe to use\n    TOKEN_BUFFER because `check_newline' calls `yylex'.  */\n struct obstack inline_text_obstack;\n+char *inline_text_firstobj;\n \n int end_of_file;\n \n@@ -91,7 +92,7 @@ extern struct obstack token_obstack;\n #else\n extern void put_back (/* int */);\n extern int input_redirected ();\n-extern void feed_input (/* char *, int, struct obstack * */);\n+extern void feed_input (/* char *, int */);\n #endif\n \n /* Holds translations from TREE_CODEs to operator name strings,\n@@ -575,6 +576,7 @@ init_lex ()\n   init_method ();\n   init_error ();\n   gcc_obstack_init (&inline_text_obstack);\n+  inline_text_firstobj = (char *) obstack_alloc (&inline_text_obstack, 0);\n \n   /* Start it at 0, because check_newline is called at the very beginning\n      and will increment it to 1.  */\n@@ -1170,7 +1172,7 @@ do_pending_inlines ()\n     push_cp_function_context (context);\n   if (t->len > 0)\n     {\n-      feed_input (t->buf, t->len, t->can_free ? &inline_text_obstack : 0);\n+      feed_input (t->buf, t->len);\n       lineno = t->lineno;\n #if 0\n       if (input_filename != t->filename)\n@@ -1192,7 +1194,6 @@ do_pending_inlines ()\n   DECL_PENDING_INLINE_INFO (t->fndecl) = 0;\n }\n \n-extern struct pending_input *to_be_restored;\n static int nextchar = -1;\n \n /* Called from the fndecl rule in the parser when the function just parsed\n@@ -1222,16 +1223,13 @@ process_next_inline (t)\n       nextchar = -1;\n     }\n   yychar = YYEMPTY;\n-  if (to_be_restored == 0)\n-    my_friendly_abort (123);\n-  restore_pending_input (to_be_restored);\n-  to_be_restored = 0;\n+  end_input ();\n   if (i && i->fndecl != NULL_TREE)\n     {\n       context = hack_decl_function_context (i->fndecl);\n       if (context)\n \tpush_cp_function_context (context);\n-      feed_input (i->buf, i->len, i->can_free ? &inline_text_obstack : 0);\n+      feed_input (i->buf, i->len);\n       lineno = i->lineno;\n       input_filename = i->filename;\n       yychar = PRE_PARSED_FUNCTION_DECL;\n@@ -1392,6 +1390,12 @@ yyungetc (ch, rescan)\n     }\n }\n \n+void\n+clear_inline_text_obstack ()\n+{\n+  obstack_free (&inline_text_obstack, inline_text_firstobj);\n+}\n+\n /* This function stores away the text for an inline function that should\n    be processed later.  It decides how much later, and may need to move\n    the info between obstacks; therefore, the caller should not refer to\n@@ -1448,7 +1452,6 @@ reinit_parse_for_method (yychar, decl)\n       t->token_value = 0;\n       t->buf = buf;\n       t->len = len;\n-      t->can_free = 1;\n       t->deja_vu = 0;\n #if 0\n       if (interface_unknown && processing_template_defn && flag_external_templates && ! DECL_IN_SYSTEM_HEADER (decl))\n@@ -1625,6 +1628,259 @@ reinit_parse_for_block (pyychar, obstackp)\n   obstack_1grow (obstackp, '\\0');\n }\n \n+/* Consume a no-commas expression -- actually, a default argument -- and\n+   save it away on the specified obstack.  */\n+\n+static void\n+reinit_parse_for_expr (obstackp)\n+     struct obstack *obstackp;\n+{\n+  register int c = 0;\n+  int starting_lineno = lineno;\n+  char *starting_filename = input_filename;\n+  int len;\n+  int look_for_semicolon = 0;\n+  int look_for_lbrac = 0;\n+  int plev = 0;\n+\n+  if (nextchar != EOF)\n+    {\n+      c = nextchar;\n+      nextchar = EOF;\n+    }\n+  else\n+    c = getch ();\n+  \n+  while (c != EOF)\n+    {\n+      int this_lineno = lineno;\n+\n+      c = skip_white_space (c);\n+\n+      /* Don't lose our cool if there are lots of comments.  */\n+      if (lineno == this_lineno + 1)\n+\tobstack_1grow (obstackp, '\\n');\n+      else if (lineno == this_lineno)\n+\t;\n+      else if (lineno - this_lineno < 10)\n+\t{\n+\t  int i;\n+\t  for (i = lineno - this_lineno; i > 0; --i)\n+\t    obstack_1grow (obstackp, '\\n');\n+\t}\n+      else\n+\t{\n+\t  char buf[16];\n+\t  sprintf (buf, \"\\n# %d \\\"\", lineno);\n+\t  len = strlen (buf);\n+\t  obstack_grow (obstackp, buf, len);\n+\n+\t  len = strlen (input_filename);\n+\t  obstack_grow (obstackp, input_filename, len);\n+\t  obstack_1grow (obstackp, '\\\"');\n+\t  obstack_1grow (obstackp, '\\n');\n+\t}\n+\n+      while (c > ' ')\t\t/* ASCII dependent...  */\n+\t{\n+\t  if (plev <= 0 && (c == ')' || c == ','))\n+\t    {\n+\t      put_back (c);\n+\t      goto done;\n+\t    }\n+\t  obstack_1grow (obstackp, c);\n+\t  if (c == '(' || c == '[')\n+\t    ++plev;\n+\t  else if (c == ']' || c == ')')\n+\t    --plev;\n+\t  else if (c == '\\\\')\n+\t    {\n+\t      /* Don't act on the next character...e.g, doing an escaped\n+\t\t double-quote.  */\n+\t      c = getch ();\n+\t      if (c == EOF)\n+\t\t{\n+\t\t  error_with_file_and_line (starting_filename,\n+\t\t\t\t\t    starting_lineno,\n+\t\t\t\t\t    \"end of file read inside definition\");\n+\t\t  goto done;\n+\t\t}\n+\t      obstack_1grow (obstackp, c);\n+\t    }\n+\t  else if (c == '\\\"')\n+\t    consume_string (obstackp, c);\n+\t  else if (c == '\\'')\n+\t    consume_string (obstackp, c);\n+\t  c = getch ();\n+\t}\n+\n+      if (c == EOF)\n+\t{\n+\t  error_with_file_and_line (starting_filename,\n+\t\t\t\t    starting_lineno,\n+\t\t\t\t    \"end of file read inside definition\");\n+\t  goto done;\n+\t}\n+      else if (c != '\\n')\n+\t{\n+\t  obstack_1grow (obstackp, c);\n+\t  c = getch ();\n+\t}\n+    }\n+ done:\n+  obstack_1grow (obstackp, '\\0');\n+}\n+\n+int do_snarf_defarg;\n+\n+/* Decide whether the default argument we are about to see should be\n+   gobbled up as text for later parsing.  */\n+\n+void\n+maybe_snarf_defarg ()\n+{\n+  if (current_class_type && TYPE_BEING_DEFINED (current_class_type))\n+    do_snarf_defarg = 1;\n+}\n+\n+/* When we see a default argument in a method declaration, we snarf it as\n+   text using snarf_defarg.  When we get up to namespace scope, we then go\n+   through and parse all of them using do_pending_defargs.  Since yacc\n+   parsers are not reentrant, we retain defargs state in these two\n+   variables so that subsequent calls to do_pending_defargs can resume\n+   where the previous call left off.  */\n+\n+tree defarg_fns;\n+tree defarg_parm;\n+\n+tree\n+snarf_defarg ()\n+{\n+  int len;\n+  char *buf;\n+  tree arg;\n+  struct pending_inline *t;\n+\n+  reinit_parse_for_expr (&inline_text_obstack);\n+  len = obstack_object_size (&inline_text_obstack);\n+  buf = obstack_finish (&inline_text_obstack);\n+\n+  push_obstacks (&inline_text_obstack, &inline_text_obstack);\n+  arg = make_node (DEFAULT_ARG);\n+  DEFARG_LENGTH (arg) = len - 1;\n+  DEFARG_POINTER (arg) = buf;\n+  pop_obstacks ();\n+\n+  return arg;\n+}\n+\n+/* Called from grokfndecl to note a function decl with unparsed default\n+   arguments for later processing.  Also called from grokdeclarator\n+   for function types with unparsed defargs; the call from grokfndecl\n+   will always come second, so we can overwrite the entry from the type.  */\n+\n+void\n+add_defarg_fn (decl)\n+     tree decl;\n+{\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    TREE_VALUE (defarg_fns) = decl;\n+  else\n+    {\n+      push_obstacks (&inline_text_obstack, &inline_text_obstack);\n+      defarg_fns = tree_cons (current_class_type, decl, defarg_fns);  \n+      pop_obstacks ();\n+    }\n+}\n+\n+/* Helper for do_pending_defargs.  Starts the parsing of a default arg.  */\n+\n+static void\n+feed_defarg (f, p)\n+     tree f, p;\n+{\n+  tree d = TREE_PURPOSE (p);\n+  feed_input (DEFARG_POINTER (d), DEFARG_LENGTH (d));\n+  if (TREE_CODE (f) == FUNCTION_DECL)\n+    {\n+      lineno = DECL_SOURCE_LINE (f);\n+      input_filename = DECL_SOURCE_FILE (f);\n+    }\n+  yychar = DEFARG_MARKER;\n+  yylval.ttype = p;\n+}\n+\n+/* Helper for do_pending_defargs.  Ends the parsing of a default arg.  */\n+\n+static void\n+finish_defarg ()\n+{\n+  if (yychar == YYEMPTY)\n+    yychar = yylex ();\n+  if (yychar != END_OF_SAVED_INPUT)\n+    {\n+      error (\"parse error at end of saved function text\");\n+\n+      /* restore_pending_input will abort unless yychar is either\n+         END_OF_SAVED_INPUT or YYEMPTY; since we already know we're\n+         hosed, feed back YYEMPTY.  We also need to discard nextchar,\n+         since that may have gotten set as well.  */\n+      nextchar = -1;\n+    }\n+  yychar = YYEMPTY;\n+  end_input ();\n+}  \n+\n+/* Main function for deferred parsing of default arguments.  Called from\n+   the parser.  */\n+\n+void\n+do_pending_defargs ()\n+{\n+  if (defarg_parm)\n+    finish_defarg ();\n+\n+  for (; defarg_fns; defarg_fns = TREE_CHAIN (defarg_fns))\n+    {\n+      tree defarg_fn = TREE_VALUE (defarg_fns);\n+      if (defarg_parm == NULL_TREE)\n+\t{\n+\t  tree p;\n+\n+\t  push_nested_class (TREE_PURPOSE (defarg_fns), 1);\n+\t  pushlevel (0);\n+\n+\t  if (TREE_CODE (defarg_fn) == FUNCTION_DECL)\n+\t    {\n+#if 0\n+\t      for (p = DECL_ARGUMENTS (defarg_fn); p; p = TREE_CHAIN (p))\n+\t\tpushdecl (copy_node (p));\n+#endif\n+\t      defarg_parm = TYPE_ARG_TYPES (TREE_TYPE (defarg_fn));\n+\t    }\n+\t  else\n+\t    defarg_parm = TYPE_ARG_TYPES (defarg_fn);\n+\t}\n+      else\n+\tdefarg_parm = TREE_CHAIN (defarg_parm);\n+\n+      for (; defarg_parm; defarg_parm = TREE_CHAIN (defarg_parm))\n+\tif (TREE_PURPOSE (defarg_parm))\n+\t  {\n+\t    my_friendly_assert (TREE_CODE (TREE_PURPOSE (defarg_parm))\n+\t\t\t\t== DEFAULT_ARG, 2349);\n+\t    feed_defarg (defarg_fn, defarg_parm);\n+\n+\t    /* Return to the parser, which will process this defarg\n+\t       and call us again.  */\n+\t    return;\n+\t  }\n+\n+      poplevel (0, 0, 0);\n+      pop_nested_class (1);\n+    }\n+}\n+\n /* Build a default function named NAME for type TYPE.\n    KIND says what to build.\n \n@@ -2716,7 +2972,7 @@ do_scoped_id (token, parsing)\n \t}\n       /* else just use the decl */\n     }\n-  return id;\n+  return convert_from_reference (id);\n }\n \n tree"}, {"sha": "7a3a7228867dcf3148be2f59f2e9b349c1a262ca", "filename": "gcc/cp/method.c", "status": "modified", "additions": 76, "deletions": 48, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -43,6 +43,8 @@ Boston, MA 02111-1307, USA.  */\n    processed.  */\n struct pending_inline *pending_inlines;\n \n+int static_labelno;\n+\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n@@ -371,18 +373,15 @@ build_overload_nested_name (decl)\n     {\n       tree name = DECL_ASSEMBLER_NAME (decl);\n       char *label;\n-      extern int var_labelno;\n \n-      ASM_FORMAT_PRIVATE_NAME (label, IDENTIFIER_POINTER (name), var_labelno);\n-      var_labelno++;\n+      ASM_FORMAT_PRIVATE_NAME (label, IDENTIFIER_POINTER (name), static_labelno);\n+      static_labelno++;\n \n       if (numeric_output_need_bar)\n-\t{\n-\t  OB_PUTC ('_');\n-\t  numeric_output_need_bar = 0;\n-\t}\n+\tOB_PUTC ('_');\n       icat (strlen (label));\n       OB_PUTCP (label);\n+      numeric_output_need_bar = 1;\n     }\n   else\t\t\t\t/* TYPE_DECL */\n     build_overload_identifier (decl);\n@@ -669,6 +668,49 @@ build_overload_identifier (name)\n     }\n }\n \n+/* Given DECL, either a class TYPE, TYPE_DECL or FUNCTION_DECL, produce\n+   the mangling for it.  Used by build_overload_name and build_static_name.  */\n+\n+static void\n+build_qualified_name (decl)\n+     tree decl;\n+{\n+  tree context;\n+  int i = 1;\n+\n+  if (TREE_CODE_CLASS (TREE_CODE (decl)) == 't')\n+    decl = TYPE_NAME (decl);\n+\n+  /* If DECL_ASSEMBLER_NAME has been set properly, use it.  */\n+  if (TREE_CODE (decl) == TYPE_DECL\n+      && DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl))\n+    {\n+      OB_PUTID (DECL_ASSEMBLER_NAME (decl));\n+      return;\n+    }\n+\n+  context = decl;\n+  while (DECL_CONTEXT (context))\n+    {\n+      i += 1;\n+      context = DECL_CONTEXT (context);\n+      if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n+\tcontext = TYPE_NAME (context);\n+    }\n+\n+  if (i > 1)\n+    {\n+      OB_PUTC ('Q');\n+      if (i > 9)\n+\tOB_PUTC ('_');\n+      icat (i);\n+      if (i > 9)\n+\tOB_PUTC ('_');\n+      numeric_output_need_bar = 0;\n+    }\n+  build_overload_nested_name (decl);\n+}\n+\n /* Given a list of parameters in PARMTYPES, create an unambiguous\n    overload string. Should distinguish any type that C (or C++) can\n    distinguish. I.e., pointers to functions are treated correctly.\n@@ -931,41 +973,15 @@ build_overload_name (parmtypes, begin, end)\n \tcommon:\n \t  {\n \t    tree name = TYPE_NAME (parmtype);\n-\t    int i = 1;\n \n-\t    if (TREE_CODE (name) == TYPE_DECL)\n+\t    if (TREE_CODE (name) == IDENTIFIER_NODE)\n \t      {\n-\t\ttree context = name;\n-\n-\t\t/* If DECL_ASSEMBLER_NAME has been set properly, use it.  */\n-\t\tif (DECL_ASSEMBLER_NAME (context) != DECL_NAME (context))\n-\t\t  {\n-\t\t    OB_PUTID (DECL_ASSEMBLER_NAME (context));\n-\t\t    break;\n-\t\t  }\n-\t\twhile (DECL_CONTEXT (context))\n-\t\t  {\n-\t\t    i += 1;\n-\t\t    context = DECL_CONTEXT (context);\n-\t\t    if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n-\t\t      context = TYPE_NAME (context);\n-\t\t  }\n-\t\tname = DECL_NAME (name);\n+\t\tbuild_overload_identifier (TYPE_NAME (parmtype));\n+\t\tbreak;\n \t      }\n-\t    my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 248);\n-\t    if (i > 1)\n-\t      {\n-\t\tOB_PUTC ('Q');\n-\t\tif (i > 9)\n-\t\t  OB_PUTC ('_');\n-\t\ticat (i);\n-\t\tif (i > 9)\n-\t\t  OB_PUTC ('_');\n-\t\tnumeric_output_need_bar = 0;\n-\t\tbuild_overload_nested_name (TYPE_NAME (parmtype));\n-\t      }\n-\t    else\t      \n-\t      build_overload_identifier (TYPE_NAME (parmtype));\n+\t    my_friendly_assert (TREE_CODE (name) == TYPE_DECL, 248);\n+\n+\t    build_qualified_name (name);\n \t    break;\n \t  }\n \n@@ -1015,17 +1031,29 @@ build_overload_name (parmtypes, begin, end)\n   return (char *)obstack_base (&scratch_obstack);\n }\n \n+/* Produce the mangling for a variable named NAME in CONTEXT, which can\n+   be either a class TYPE or a FUNCTION_DECL.  */\n+\n tree\n-build_static_name (basetype, name)\n-  tree basetype, name;\n+build_static_name (context, name)\n+     tree context, name;\n {\n-  char *basename  = build_overload_name (basetype, 1, 1);\n-  char *buf = (char *) alloca (IDENTIFIER_LENGTH (name)\n-\t\t\t       + sizeof (STATIC_NAME_FORMAT)\n-\t\t\t       + strlen (basename));\n-  sprintf (buf, STATIC_NAME_FORMAT, basename, IDENTIFIER_POINTER (name));\n-  return get_identifier (buf);\n-}  \n+  OB_INIT ();\n+  numeric_output_need_bar = 0;\n+#ifdef JOINER\n+  OB_PUTC ('_');\n+  build_qualified_name (context);\n+  OB_PUTC (JOINER);\n+#else\n+  OB_PUTS (\"__static_\");\n+  build_qualified_name (context);\n+  OB_PUTC (' ');\n+#endif\n+  OB_PUTID (name);\n+  OB_FINISH ();\n+\n+  return get_identifier ((char *)obstack_base (&scratch_obstack));\n+}\n \f\n /* Change the name of a function definition so that it may be\n    overloaded. NAME is the name of the function to overload,"}, {"sha": "fe519b83e73ef39c5c6339ce2d6ca560dfb24b2a", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -89,7 +89,10 @@ empty_parms ()\n   tree parms;\n \n   if (strict_prototype\n-      || current_class_type != NULL)\n+      /* Only go ahead with using the void list node if we're actually\n+\t parsing a class in C++, not a struct in extern \"C\" mode.  */\n+      || (current_class_type != NULL\n+\t  && current_lang_name == lang_name_cplusplus))\n     parms = void_list_node;\n   else\n     parms = NULL_TREE;\n@@ -201,7 +204,7 @@ empty_parms ()\n %type <ttype> declmods \n %type <ttype> SCSPEC TYPESPEC CV_QUALIFIER maybe_cv_qualifier\n %type <itype> initdecls notype_initdecls initdcl\t/* C++ modification */\n-%type <ttype> init initlist maybeasm maybe_init\n+%type <ttype> init initlist maybeasm maybe_init defarg defarg1\n %type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers\n %type <ttype> maybe_attribute attributes attribute attribute_list attrib\n %type <ttype> any_word\n@@ -236,7 +239,7 @@ empty_parms ()\n /* C++ extensions */\n %token <ttype> TYPENAME_ELLIPSIS PTYPENAME\n %token <ttype> PRE_PARSED_FUNCTION_DECL EXTERN_LANG_STRING ALL\n-%token <ttype> PRE_PARSED_CLASS_DECL\n+%token <ttype> PRE_PARSED_CLASS_DECL DEFARG DEFARG_MARKER\n %type <ttype> fn.def1 /* Not really! */ component_constructor_declarator\n %type <ttype> fn.def2 return_id fn.defpen constructor_declarator\n %type <itype> ctor_initializer_opt\n@@ -284,13 +287,13 @@ empty_parms ()\n \f\n %{\n /* List of types and structure classes of the current declaration.  */\n-static tree current_declspecs;\n+static tree current_declspecs = NULL_TREE;\n /* List of prefix attributes in effect.\n    Prefix attributes are parsed by the reserved_declspecs and declmods\n    rules.  They create a list that contains *both* declspecs and attrs.  */\n /* ??? It is not clear yet that all cases where an attribute can now appear in\n    a declspec list have been updated.  */\n-static tree prefix_attributes;\n+static tree prefix_attributes = NULL_TREE;\n \n /* When defining an aggregate, this is the most recent one being defined.  */\n static tree current_aggr;\n@@ -1661,7 +1664,7 @@ decl:\n \t  typespec initdecls ';'\n \t\t{\n \t\t  resume_momentary ($2);\n-\t\t  if (IS_AGGR_TYPE_CODE (TREE_CODE ($1.t)))\n+\t\t  if ($1.t && IS_AGGR_TYPE_CODE (TREE_CODE ($1.t)))\n \t\t    note_got_semicolon ($1.t);\n \t\t}\n \t| typed_declspecs initdecls ';'\n@@ -1907,7 +1910,8 @@ initdcl0:\n \t  declarator maybeasm maybe_attribute '='\n \t\t{ split_specs_attrs ($<ttype>0, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n-\t\t  if (TREE_CODE (current_declspecs) != TREE_LIST)\n+\t\t  if (current_declspecs\n+\t\t      && TREE_CODE (current_declspecs) != TREE_LIST)\n \t\t    current_declspecs = get_decl_list (current_declspecs);\n \t\t  if (have_extern_spec && !used_extern_spec)\n \t\t    {\n@@ -1927,7 +1931,8 @@ initdcl0:\n \t\t{ tree d;\n \t\t  split_specs_attrs ($<ttype>0, &current_declspecs,\n \t\t\t\t     &prefix_attributes);\n-\t\t  if (TREE_CODE (current_declspecs) != TREE_LIST)\n+\t\t  if (current_declspecs\n+\t\t      && TREE_CODE (current_declspecs) != TREE_LIST)\n \t\t    current_declspecs = get_decl_list (current_declspecs);\n \t\t  if (have_extern_spec && !used_extern_spec)\n \t\t    {\n@@ -2119,6 +2124,20 @@ pending_inlines:\n \t  eat_saved_input\n \t;\n \n+/* A regurgitated default argument.  The value of DEFARG_MARKER will be\n+   the TREE_LIST node for the parameter in question.  */\n+defarg_again:\n+\tDEFARG_MARKER expr_no_commas END_OF_SAVED_INPUT\n+\t\t{ replace_defarg ($1, $2); }\n+\n+pending_defargs:\n+\t  /* empty */ %prec EMPTY\n+\t| pending_defargs defarg_again\n+\t\t{ do_pending_defargs (); }\n+\t| pending_defargs error\n+\t\t{ do_pending_defargs (); }\n+\t;\n+\n structsp:\n \t  ENUM identifier '{'\n \t\t{ $<itype>3 = suspend_momentary ();\n@@ -2188,13 +2207,22 @@ structsp:\n \n \t\t  if (! semi)\n \t\t    check_for_missing_semicolon ($1); \n+\t\t  if (current_scope () == current_function_decl)\n+\t\t    do_pending_defargs ($1);\n+\t\t}\n+\t  pending_defargs\n+\t\t{\n \t\t  if (pending_inlines \n \t\t      && current_scope () == current_function_decl)\n \t\t    do_pending_inlines ();\n \t\t}\n \t  pending_inlines\n-\t\t{ $$.t = $<ttype>6;\n-\t\t  $$.new_type_flag = 1; }\n+\t\t{ \n+\t\t  $$.t = $<ttype>6;\n+\t\t  $$.new_type_flag = 1; \n+\t\t  if (current_scope () == current_function_decl)\n+\t\t    clear_inline_text_obstack (); \n+\t\t}\n \t| class_head  %prec EMPTY\n \t\t{\n \t\t  $$.t = $1;\n@@ -3951,14 +3979,27 @@ complex_parmlist:\n \t\t}\n \t;\n \n+/* A default argument to a */\n+defarg:\n+\t  '='\n+\t\t{ maybe_snarf_defarg (); }\n+\t  defarg1\n+\t\t{ $$ = $3; }\n+\t;\n+\n+defarg1:\n+\t  DEFARG\n+\t| init\n+\t;\n+\n /* A nonempty list of parameter declarations or type names.  */\n parms:\n \t  named_parm\n \t\t{ check_for_new_type (\"in a parameter list\", $1);\n \t\t  $$ = build_tree_list (NULL_TREE, $1.t); }\n-\t| parm '=' init\n+\t| parm defarg\n \t\t{ check_for_new_type (\"in a parameter list\", $1);\n-\t\t  $$ = build_tree_list ($3, $1.t); }\n+\t\t  $$ = build_tree_list ($2, $1.t); }\n \t| parms_comma full_parm\n \t\t{ check_for_new_type (\"in a parameter list\", $2);\n \t\t  $$ = chainon ($$, $2.t); }\n@@ -4005,7 +4046,10 @@ named_parm:\n \t;\n \n full_parm:\n-\t  parm maybe_init\n+\t  parm\n+\t\t{ $$.t = build_tree_list (NULL_TREE, $1.t);\n+\t\t  $$.new_type_flag = $1.new_type_flag;  }\n+\t| parm defarg\n \t\t{ $$.t = build_tree_list ($2, $1.t);\n \t\t  $$.new_type_flag = $1.new_type_flag;  }\n \t;"}, {"sha": "f43488d62cfe24a1ac98bcc5f20c34e3ca2649a2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -962,6 +962,18 @@ uses_template_parms (t)\n \treturn uses_template_parms (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (t)));\n       return uses_template_parms (TREE_OPERAND (t, 1));\n \n+    case MODOP_EXPR:\n+    case CAST_EXPR:\n+    case REINTERPRET_CAST_EXPR:\n+    case CONST_CAST_EXPR:\n+    case STATIC_CAST_EXPR:\n+    case DYNAMIC_CAST_EXPR:\n+    case SIZEOF_EXPR:\n+    case ARROW_EXPR:\n+    case DOTSTAR_EXPR:\n+    case TYPEID_EXPR:\n+      return 1;\n+\n     default:\n       switch (TREE_CODE_CLASS (TREE_CODE (t)))\n \t{\n@@ -1849,9 +1861,6 @@ tsubst (t, args, nargs, in_decl)\n \t\ttree purpose = TREE_PURPOSE (values);\n \t\ttree x = build_tree_list (purpose, value);\n \n-\t\tif (purpose)\n-\t\t  PARM_DEFAULT_FROM_TEMPLATE (x) = 1;\n-\n \t\tif (first)\n \t\t  TREE_CHAIN (last) = x;\n \t\telse\n@@ -2828,6 +2837,7 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n     case REAL_TYPE:\n     case COMPLEX_TYPE:\n     case INTEGER_TYPE:\n+    case BOOLEAN_TYPE:\n       if (TREE_CODE (arg) != TREE_CODE (parm))\n \treturn 1;\n "}, {"sha": "929298cb33e2805f59249373937bf6562e2513bd", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -405,8 +405,8 @@ ifnonnull (test, result)\n /* Execute a dynamic cast, as described in section 5.2.6 of the 9/93 working\n    paper.  */\n \n-tree\n-build_dynamic_cast (type, expr)\n+static tree\n+build_dynamic_cast_1 (type, expr)\n      tree type, expr;\n {\n   enum tree_code tc = TREE_CODE (type);\n@@ -628,6 +628,13 @@ build_dynamic_cast (type, expr)\n \t    expr, exprtype, type);\n   return error_mark_node;\n }\n+\n+tree\n+build_dynamic_cast (type, expr)\n+     tree type, expr;\n+{\n+  return convert_from_reference (build_dynamic_cast_1 (type, expr));\n+}\n \f\n /* Build and initialize various sorts of descriptors.  Every descriptor\n    node has a name associated with it (the name created by mangling)."}, {"sha": "15a1aa9f1a740bf46ad60870ca895b01402f93f5", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -215,6 +215,7 @@ probe_obstack (h, obj, nlevels)\n    Value is 0 if we treat this name in a default fashion.  */\n extern int looking_for_typename;\n int looking_for_template;\n+extern int do_snarf_defarg;\n \n extern struct obstack *current_obstack, *saveable_obstack;\n tree got_scope;\n@@ -227,6 +228,8 @@ peekyylex ()\n   return nth_token (0)->yychar;\n }\n \n+extern tree snarf_defarg ();\n+\n int\n yylex ()\n {\n@@ -242,8 +245,18 @@ yylex ()\n   }\n #endif\n \n+  if (do_snarf_defarg)\n+    {\n+      my_friendly_assert (num_tokens () == 0, 2837);\n+      tmp_token.yychar = DEFARG;\n+      tmp_token.yylval.ttype = snarf_defarg ();\n+      tmp_token.end_of_file = 0;\n+      do_snarf_defarg = 0;\n+      add_token (&tmp_token);\n+    }\n+\n   /* if we've got tokens, send them */\n-  if (num_tokens ())\n+  else if (num_tokens ())\n     {\n       tmp_token= *nth_token (0);\n "}, {"sha": "d212bb223d4c076a0be7248d0ed068f61d5125fb", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -832,20 +832,18 @@ layout_basetypes (rec, binfos)\n \t  BINFO_VPTR_FIELD (base_binfo) = decl;\n \t  vbase_decls = decl;\n \n-\t  if (warn_nonvdtor && TYPE_HAS_DESTRUCTOR (basetype)\n-\t      && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 1)) == NULL_TREE)\n-\t    {\n-\t      warning_with_decl (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 1),\n-\t\t\t\t \"destructor `%s' non-virtual\");\n-\t      warning (\"in inheritance relationship `%s: virtual %s'\",\n-\t\t       TYPE_NAME_STRING (rec),\n-\t\t       TYPE_NAME_STRING (basetype));\n-\t    }\n \tgot_it:\n \t  /* The space this decl occupies has already been accounted for.  */\n \t  continue;\n \t}\n \n+      /* Effective C++ rule 14.  We only need to check TYPE_VIRTUAL_P\n+\t here because the case of virtual functions but non-virtual\n+\t dtor is handled in finish_struct_1.  */\n+      if (warn_ecpp && ! TYPE_VIRTUAL_P (basetype)\n+\t  && TYPE_HAS_DESTRUCTOR (basetype))\n+\tcp_warning (\"base class `%#T' has a non-virtual destructor\", basetype);\n+\n       if (const_size == 0)\n \toffset = integer_zero_node;\n       else\n@@ -854,22 +852,6 @@ layout_basetypes (rec, binfos)\n \t  const_size = CEIL (const_size, TYPE_ALIGN (basetype))\n \t    * TYPE_ALIGN (basetype);\n \t  offset = size_int ((const_size + BITS_PER_UNIT - 1) / BITS_PER_UNIT);\n-\n-#if 0\n-\t  /* bpk: Disabled this check until someone is willing to\n-\t     claim it as theirs and explain exactly what circumstances\n-\t     warrant the warning.  */ \n-\t  if (warn_nonvdtor && TYPE_HAS_DESTRUCTOR (basetype)\n-\t      && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 1)) == NULL_TREE)\n-\t    {\n-\t      warning_with_decl (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (basetype), 1),\n-\t\t\t\t \"destructor `%s' non-virtual\");\n-\t      warning (\"in inheritance relationship `%s:%s %s'\",\n-\t\t       TYPE_NAME_STRING (rec),\n-\t\t       TREE_VIA_VIRTUAL (base_binfo) ? \" virtual\" : \"\",\n-\t\t       TYPE_NAME_STRING (basetype));\n-\t    }\n-#endif\n \t}\n       BINFO_OFFSET (base_binfo) = offset;\n       if (CLASSTYPE_VSIZE (basetype))"}, {"sha": "0be5b08b9f50688262212bcaca054eb81c64bbb5", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42976354a68d594935dbadbc3af015302918dcd9/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=42976354a68d594935dbadbc3af015302918dcd9", "patch": "@@ -1652,15 +1652,17 @@ build_object_ref (datum, basetype, field)\n   return error_mark_node;\n }\n \n-/* Like `build_component_ref, but uses an already found field.\n-   Must compute access for current_class_ref.  Otherwise, ok.  */\n+/* Like `build_component_ref, but uses an already found field, and converts\n+   from a reference.  Must compute access for current_class_ref.\n+   Otherwise, ok.  */\n \n tree\n build_component_ref_1 (datum, field, protect)\n      tree datum, field;\n      int protect;\n {\n-  return build_component_ref (datum, field, NULL_TREE, protect);\n+  return convert_from_reference\n+    (build_component_ref (datum, field, NULL_TREE, protect));\n }\n \n /* Given a COND_EXPR in T, return it in a form that we can, for\n@@ -2484,11 +2486,17 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \tfunction = save_expr (function);\n \n       fntype = TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (function));\n-      idx = save_expr (build_component_ref (function,\n-\t\t\t\t\t    index_identifier,\n-\t\t\t\t\t    NULL_TREE, 0));\n-      e1 = fold (build (GT_EXPR, boolean_type_node, idx,\n-\t\t\tcp_convert (delta_type_node, integer_zero_node)));\n+\n+      /* Promoting idx before saving it improves performance on RISC\n+\t targets.  Without promoting, the first compare used\n+\t load-with-sign-extend, while the second used normal load then\n+\t shift to sign-extend.  An optimizer flaw, perhaps, but it's easier\n+\t to make this change.  */\n+      idx = save_expr (default_conversion\n+\t\t       (build_component_ref (function,\n+\t\t\t\t\t     index_identifier,\n+\t\t\t\t\t     NULL_TREE, 0)));\n+      e1 = build_binary_op (GT_EXPR, idx, integer_zero_node, 1);\n       delta = cp_convert (ptrdiff_type_node,\n \t\t\t  build_component_ref (function, delta_identifier, NULL_TREE, 0));\n       delta2 = DELTA2_FROM_PTRMEMFUNC (function);"}]}