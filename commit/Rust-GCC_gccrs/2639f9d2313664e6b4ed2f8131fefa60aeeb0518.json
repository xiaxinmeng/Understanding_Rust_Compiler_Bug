{"sha": "2639f9d2313664e6b4ed2f8131fefa60aeeb0518", "node_id": "C_kwDOANBUbNoAKDI2MzlmOWQyMzEzNjY0ZTZiNGVkMmY4MTMxZmVmYTYwYWVlYjA1MTg", "commit": {"author": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2023-03-02T21:29:05Z"}, "committer": {"name": "Vladimir N. Makarov", "email": "vmakarov@redhat.com", "date": "2023-03-02T21:39:13Z"}, "message": "IRA: Use minimal cost for hard register movement\n\nThis is the 2nd attempt to fix PR90706.  IRA calculates wrong AVR\ncosts for moving general hard regs of SFmode.  This was the reason for\nspilling a pseudo in the PR.  In this patch we use smaller move cost\nof hard reg in its natural and operand modes.\n\n        PR rtl-optimization/90706\n\ngcc/ChangeLog:\n\n\t* ira-costs.cc: Include print-rtl.h.\n\t(record_reg_classes, scan_one_insn): Add code to print debug info.\n\t(record_operand_costs): Find and use smaller cost for hard reg\n\tmove.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/avr/pr90706.c: New.", "tree": {"sha": "bf25a69e196cdb78727d2e8471e93d5f334d6ef3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf25a69e196cdb78727d2e8471e93d5f334d6ef3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2639f9d2313664e6b4ed2f8131fefa60aeeb0518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2639f9d2313664e6b4ed2f8131fefa60aeeb0518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2639f9d2313664e6b4ed2f8131fefa60aeeb0518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2639f9d2313664e6b4ed2f8131fefa60aeeb0518/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce9cd7258d0b2d34e14663f8d91be8d6a4731204", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce9cd7258d0b2d34e14663f8d91be8d6a4731204", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce9cd7258d0b2d34e14663f8d91be8d6a4731204"}], "stats": {"total": 165, "additions": 140, "deletions": 25}, "files": [{"sha": "c0fdef807dd6112a00829cb4fb97c51644a3fa5a", "filename": "gcc/ira-costs.cc", "status": "modified", "additions": 131, "deletions": 25, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2639f9d2313664e6b4ed2f8131fefa60aeeb0518/gcc%2Fira-costs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2639f9d2313664e6b4ed2f8131fefa60aeeb0518/gcc%2Fira-costs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.cc?ref=2639f9d2313664e6b4ed2f8131fefa60aeeb0518", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ira-int.h\"\n #include \"addresses.h\"\n #include \"reload.h\"\n+#include \"print-rtl.h\"\n \n /* The flags is set up every time when we calculate pseudo register\n    classes through function ira_set_pseudo_classes.  */\n@@ -503,6 +504,18 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n   int insn_allows_mem[MAX_RECOG_OPERANDS];\n   move_table *move_in_cost, *move_out_cost;\n   short (*mem_cost)[2];\n+  const char *p;\n+\n+  if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n+    {\n+      fprintf (ira_dump_file, \"    Processing insn %u\", INSN_UID (insn));\n+      if (INSN_CODE (insn) >= 0\n+\t  && (p = get_insn_name (INSN_CODE (insn))) != NULL)\n+\tfprintf (ira_dump_file, \" {%s}\", p);\n+      fprintf (ira_dump_file, \" (freq=%d)\\n\",\n+\t       REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn)));\n+      dump_insn_slim (ira_dump_file, insn);\n+  }\n \n   for (i = 0; i < n_ops; i++)\n     insn_allows_mem[i] = 0;\n@@ -526,6 +539,21 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t  continue;\n \t}\n \n+      if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n+\t{\n+\t  fprintf (ira_dump_file, \"      Alt %d:\", alt);\n+\t  for (i = 0; i < n_ops; i++)\n+\t    {\n+\t      p = constraints[i];\n+\t      if (*p == '\\0')\n+\t\tcontinue;\n+\t      fprintf (ira_dump_file, \"  (%d) \", i);\n+\t      for (; *p != '\\0' && *p != ',' && *p != '#'; p++)\n+\t\tfputc (*p, ira_dump_file);\n+\t    }\n+\t  fprintf (ira_dump_file, \"\\n\");\n+\t}\n+\n       for (i = 0; i < n_ops; i++)\n \t{\n \t  unsigned char c;\n@@ -593,12 +621,16 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t     register, this alternative can't be used.  */\n \n \t\t  if (classes[j] == NO_REGS)\n-\t\t    alt_fail = 1;\n-\t\t  /* Otherwise, add to the cost of this alternative\n-\t\t     the cost to copy the other operand to the hard\n-\t\t     register used for this operand.  */\n+\t\t    {\n+\t\t      alt_fail = 1;\n+\t\t    }\n \t\t  else\n-\t\t    alt_cost += copy_cost (ops[j], mode, classes[j], 1, NULL);\n+\t\t    /* Otherwise, add to the cost of this alternative the cost\n+\t\t       to copy the other operand to the hard register used for\n+\t\t       this operand.  */\n+\t\t    {\n+\t\t      alt_cost += copy_cost (ops[j], mode, classes[j], 1, NULL);\n+\t\t    }\n \t\t}\n \t      else\n \t\t{\n@@ -1021,18 +1053,45 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n       for (i = 0; i < n_ops; i++)\n \tif (REG_P (ops[i]) && REGNO (ops[i]) >= FIRST_PSEUDO_REGISTER)\n \t  {\n+\t    int old_cost;\n+\t    bool cost_change_p = false;\n \t    struct costs *pp = op_costs[i], *qq = this_op_costs[i];\n \t    int *pp_costs = pp->cost, *qq_costs = qq->cost;\n \t    int scale = 1 + (recog_data.operand_type[i] == OP_INOUT);\n \t    cost_classes_t cost_classes_ptr\n \t      = regno_cost_classes[REGNO (ops[i])];\n \n-\t    pp->mem_cost = MIN (pp->mem_cost,\n+\t    old_cost = pp->mem_cost;\n+\t    pp->mem_cost = MIN (old_cost,\n \t\t\t\t(qq->mem_cost + op_cost_add) * scale);\n \n+\t    if (ira_dump_file != NULL && internal_flag_ira_verbose > 5\n+\t\t&& pp->mem_cost < old_cost)\n+\t      {\n+\t\tcost_change_p = true;\n+\t\tfprintf (ira_dump_file, \"        op %d(r=%u) new costs MEM:%d\",\n+\t\t\t i, REGNO(ops[i]), pp->mem_cost);\n+\t      }\n \t    for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n-\t      pp_costs[k]\n-\t\t= MIN (pp_costs[k], (qq_costs[k] + op_cost_add) * scale);\n+\t      {\n+\t\told_cost = pp_costs[k];\n+\t\tpp_costs[k]\n+\t\t  = MIN (old_cost, (qq_costs[k] + op_cost_add) * scale);\n+\t\tif (ira_dump_file != NULL && internal_flag_ira_verbose > 5\n+\t\t    && pp_costs[k] < old_cost)\n+\t\t  {\n+\t\t    if (!cost_change_p)\n+\t\t      fprintf (ira_dump_file, \"        op %d(r=%u) new costs\",\n+\t\t\t       i, REGNO(ops[i]));\n+\t\t    cost_change_p = true;\n+\t\t    fprintf (ira_dump_file, \" %s:%d\",\n+\t\t\t     reg_class_names[cost_classes_ptr->classes[k]],\n+\t\t\t     pp_costs[k]);\n+\t\t  }\n+\t      }\n+\t    if (ira_dump_file != NULL && internal_flag_ira_verbose > 5\n+\t\t&& cost_change_p)\n+\t      fprintf (ira_dump_file, \"\\n\");\n \t  }\n     }\n \n@@ -1307,34 +1366,56 @@ record_operand_costs (rtx_insn *insn, enum reg_class *pref)\n \t      || ((regno = REGNO (dest)) >= FIRST_PSEUDO_REGISTER\n \t\t  && (other_regno = REGNO (src)) < FIRST_PSEUDO_REGISTER)))\n \t{\n-\t  machine_mode mode = GET_MODE (SET_SRC (set));\n+\t  machine_mode mode = GET_MODE (SET_SRC (set)), cost_mode = mode;\n+\t  machine_mode hard_reg_mode = GET_MODE(regno_reg_rtx[other_regno]);\n+\t  poly_int64 pmode_size = GET_MODE_SIZE (mode);\n+\t  poly_int64 phard_reg_mode_size = GET_MODE_SIZE (hard_reg_mode);\n+\t  HOST_WIDE_INT mode_size, hard_reg_mode_size;\n \t  cost_classes_t cost_classes_ptr = regno_cost_classes[regno];\n \t  enum reg_class *cost_classes = cost_classes_ptr->classes;\n \t  reg_class_t rclass, hard_reg_class, bigger_hard_reg_class;\n-\t  int cost, k;\n+\t  int cost_factor = 1, cost, k;\n \t  move_table *move_costs;\n \t  bool dead_p = find_regno_note (insn, REG_DEAD, REGNO (src));\n \n-\t  ira_init_register_move_cost_if_necessary (mode);\n-\t  move_costs = ira_register_move_cost[mode];\n \t  hard_reg_class = REGNO_REG_CLASS (other_regno);\n-\t  bigger_hard_reg_class = ira_pressure_class_translate[hard_reg_class];\n-\t  /* Target code may return any cost for mode which does not\n-\t     fit the hard reg class (e.g. DImode for AREG on\n-\t     i386).  Check this and use a bigger class to get the\n-\t     right cost.  */\n-\t  if (bigger_hard_reg_class != NO_REGS\n-\t      && ! ira_hard_reg_in_set_p (other_regno, mode,\n-\t\t\t\t\t  reg_class_contents[hard_reg_class]))\n-\t    hard_reg_class = bigger_hard_reg_class;\n+          bigger_hard_reg_class = ira_pressure_class_translate[hard_reg_class];\n+          /* Target code may return any cost for mode which does not fit the\n+             hard reg class (e.g. DImode for AREG on i386).  Check this and use\n+             a bigger class to get the right cost.  */\n+          if (bigger_hard_reg_class != NO_REGS\n+              && ! ira_hard_reg_in_set_p (other_regno, mode,\n+                                          reg_class_contents[hard_reg_class]))\n+            hard_reg_class = bigger_hard_reg_class;\n+          ira_init_register_move_cost_if_necessary (mode);\n+          ira_init_register_move_cost_if_necessary (hard_reg_mode);\n+\t  /* Use smaller movement cost for natural hard reg mode or its mode as\n+\t     operand.  */\n+          if (pmode_size.is_constant (&mode_size)\n+              && phard_reg_mode_size.is_constant (&hard_reg_mode_size))\n+            {\n+\t      /* Assume we are moving in the natural modes: */\n+              cost_factor = mode_size / hard_reg_mode_size;\n+              if (mode_size % hard_reg_mode_size != 0)\n+\t\tcost_factor++;\n+\t      if (cost_factor\n+\t\t  * (ira_register_move_cost\n+\t\t     [hard_reg_mode][hard_reg_class][hard_reg_class])\n+\t\t  < (ira_register_move_cost\n+\t\t     [mode][hard_reg_class][hard_reg_class]))\n+\t\tcost_mode = hard_reg_mode;\n+\t      else\n+\t\tcost_factor = 1;\n+            }\n+          move_costs = ira_register_move_cost[cost_mode];\n \t  i = regno == (int) REGNO (src) ? 1 : 0;\n \t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n \t    {\n \t      rclass = cost_classes[k];\n \t      cost = (i == 0\n \t\t      ? move_costs[hard_reg_class][rclass]\n \t\t      : move_costs[rclass][hard_reg_class]);\n-\t      \n+\t      cost *= cost_factor;\n \t      op_costs[i]->cost[k] = cost * frequency;\n \t      /* If this insn is a single set copying operand 1 to\n \t\t operand 0 and one operand is an allocno with the\n@@ -1506,12 +1587,24 @@ scan_one_insn (rtx_insn *insn)\n \n   record_operand_costs (insn, pref);\n \n+  if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n+    {\n+      const char *p;\n+      fprintf (ira_dump_file, \"    Final costs after insn %u\", INSN_UID (insn));\n+      if (INSN_CODE (insn) >= 0\n+\t  && (p = get_insn_name (INSN_CODE (insn))) != NULL)\n+\tfprintf (ira_dump_file, \" {%s}\", p);\n+      fprintf (ira_dump_file, \" (freq=%d)\\n\",\n+\t       REG_FREQ_FROM_BB (BLOCK_FOR_INSN (insn)));\n+      dump_insn_slim (ira_dump_file, insn);\n+    }\n+\n   /* Now add the cost for each operand to the total costs for its\n      allocno.  */\n   for (i = 0; i < recog_data.n_operands; i++)\n     {\n       rtx op = recog_data.operand[i];\n-      \n+\n       if (GET_CODE (op) == SUBREG)\n \top = SUBREG_REG (op);\n       if (REG_P (op) && REGNO (op) >= FIRST_PSEUDO_REGISTER)\n@@ -1521,8 +1614,8 @@ scan_one_insn (rtx_insn *insn)\n \t  struct costs *q = op_costs[i];\n \t  int *p_costs = p->cost, *q_costs = q->cost;\n \t  cost_classes_t cost_classes_ptr = regno_cost_classes[regno];\n-\t  int add_cost;\n-\t  \n+\t  int add_cost = 0;\n+\n \t  /* If the already accounted for the memory \"cost\" above, don't\n \t     do so again.  */\n \t  if (!counted_mem)\n@@ -1533,14 +1626,27 @@ scan_one_insn (rtx_insn *insn)\n \t      else\n \t\tp->mem_cost += add_cost;\n \t    }\n+\t  if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n+\t    {\n+\t      fprintf (ira_dump_file, \"        op %d(r=%u) MEM:%d(+%d)\",\n+\t\t       i, REGNO(op), p->mem_cost, add_cost);\n+\t    }\n \t  for (k = cost_classes_ptr->num - 1; k >= 0; k--)\n \t    {\n \t      add_cost = q_costs[k];\n \t      if (add_cost > 0 && INT_MAX - add_cost < p_costs[k])\n \t\tp_costs[k] = INT_MAX;\n \t      else\n \t\tp_costs[k] += add_cost;\n+\t      if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n+\t\t{\n+\t\t  fprintf (ira_dump_file, \" %s:%d(+%d)\",\n+\t\t\t   reg_class_names[cost_classes_ptr->classes[k]],\n+\t\t\t   p_costs[k], add_cost);\n+\t\t}\n \t    }\n+\t  if (ira_dump_file != NULL && internal_flag_ira_verbose > 5)\n+\t    fprintf (ira_dump_file, \"\\n\");\n \t}\n     }\n   return insn;"}, {"sha": "4b9bcbe115271bd084c0295cec6503912e31180b", "filename": "gcc/testsuite/gcc.target/avr/pr90706.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2639f9d2313664e6b4ed2f8131fefa60aeeb0518/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fpr90706.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2639f9d2313664e6b4ed2f8131fefa60aeeb0518/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fpr90706.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Fpr90706.c?ref=2639f9d2313664e6b4ed2f8131fefa60aeeb0518", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Os\" } */\n+ \n+unsigned char check(float x)\n+{\n+   return (0.0 < x);\n+}\n+ /* { dg-final { scan-assembler-not \"ldd\" } } */\n+ /* { dg-final { scan-assembler-not \"std\" } } */"}]}