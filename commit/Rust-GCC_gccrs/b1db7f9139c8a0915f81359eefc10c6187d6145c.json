{"sha": "b1db7f9139c8a0915f81359eefc10c6187d6145c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFkYjdmOTEzOWM4YTA5MTVmODEzNTllZWZjMTBjNjE4N2Q2MTQ1Yw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-10-08T14:45:12Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-10-08T14:45:12Z"}, "message": "Partial implementation of C++11 thread_local.\n\nc-family/\n\t* c-common.c (c_common_reswords): Add thread_local.\ncp/\n\t* decl.c (cp_finish_decl): Remove errors about non-trivial\n\tinitialization and destruction of TLS variables.\n\t(register_dtor_fn): Add sorry about TLS variables.\n\t(expand_static_init): Add sorry about non-local TLS variables,\n\tor error with __thread.\n\tDon't emit thread-safety guards for local TLS variables.\n\t(grokdeclarator): thread_local in a function implies static.\n\t* decl.h: Adjust prototype.\n\t* decl2.c (get_guard): Copy DECL_TLS_MODEL.\n\t* parser.c (cp_parser_set_storage_class, cp_parser_set_decl_spec_type)\n\t(set_and_check_decl_spec_loc): Take the token rather than the location.\n\tDistinguish between __thread and thread_local.\n\t(cp_parser_set_storage_class): Don't complain about thread_local before\n\textern/static.\n\t(token_is__thread): New.\n\t* call.c (make_temporary_var_for_ref_to_temp): Handle TLS.\n\t* cp-tree.h (DECL_GNU_TLS_P): New.\n\t(cp_decl_specifier_seq): Add gnu_thread_keyword_p.\n\nFrom-SVN: r192209", "tree": {"sha": "9d034ef53452ac43a609b044b8e683a39f49e1be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d034ef53452ac43a609b044b8e683a39f49e1be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1db7f9139c8a0915f81359eefc10c6187d6145c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1db7f9139c8a0915f81359eefc10c6187d6145c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1db7f9139c8a0915f81359eefc10c6187d6145c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1db7f9139c8a0915f81359eefc10c6187d6145c/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2991392b555fb18a312aef719f3ea379d7615fef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2991392b555fb18a312aef719f3ea379d7615fef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2991392b555fb18a312aef719f3ea379d7615fef"}], "stats": {"total": 329, "additions": 250, "deletions": 79}, "files": [{"sha": "36bab2ee23eabcdee28c8e5420191d4b8ec7ce8c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=b1db7f9139c8a0915f81359eefc10c6187d6145c", "patch": "@@ -1,3 +1,7 @@\n+2012-10-08  Jason Merrill  <jason@redhat.com>\n+\n+\t* c-common.c (c_common_reswords): Add thread_local.\n+\n 2012-10-08  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/53528 C++11 attribute support"}, {"sha": "bb18c39cd6ba1ba8c62ba14f2429525939b0f244", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=b1db7f9139c8a0915f81359eefc10c6187d6145c", "patch": "@@ -543,6 +543,7 @@ const struct c_common_resword c_common_reswords[] =\n   { \"switch\",\t\tRID_SWITCH,\t0 },\n   { \"template\",\t\tRID_TEMPLATE,\tD_CXXONLY | D_CXXWARN },\n   { \"this\",\t\tRID_THIS,\tD_CXXONLY | D_CXXWARN },\n+  { \"thread_local\",\tRID_THREAD,\tD_CXXONLY | D_CXX0X | D_CXXWARN },\n   { \"throw\",\t\tRID_THROW,\tD_CXX_OBJC | D_CXXWARN },\n   { \"true\",\t\tRID_TRUE,\tD_CXXONLY | D_CXXWARN },\n   { \"try\",\t\tRID_TRY,\tD_CXX_OBJC | D_CXXWARN },"}, {"sha": "871dbaa85300d2d173f1ba04edd636ff5d0187fa", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b1db7f9139c8a0915f81359eefc10c6187d6145c", "patch": "@@ -1,3 +1,25 @@\n+2012-10-08  Jason Merrill  <jason@redhat.com>\n+\n+\tPartial implementation of C++11 thread_local.\n+\t* decl.c (cp_finish_decl): Remove errors about non-trivial\n+\tinitialization and destruction of TLS variables.\n+\t(register_dtor_fn): Add sorry about TLS variables.\n+\t(expand_static_init): Add sorry about non-local TLS variables,\n+\tor error with __thread.\n+\tDon't emit thread-safety guards for local TLS variables.\n+\t(grokdeclarator): thread_local in a function implies static.\n+\t* decl.h: Adjust prototype.\n+\t* decl2.c (get_guard): Copy DECL_TLS_MODEL.\n+\t* parser.c (cp_parser_set_storage_class, cp_parser_set_decl_spec_type)\n+\t(set_and_check_decl_spec_loc): Take the token rather than the location.\n+\tDistinguish between __thread and thread_local.\n+\t(cp_parser_set_storage_class): Don't complain about thread_local before\n+\textern/static.\n+\t(token_is__thread): New.\n+\t* call.c (make_temporary_var_for_ref_to_temp): Handle TLS.\n+\t* cp-tree.h (DECL_GNU_TLS_P): New.\n+\t(cp_decl_specifier_seq): Add gnu_thread_keyword_p.\n+\n 2012-10-08  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/53528 C++11 attribute support"}, {"sha": "9c8de39e92deaac6816202154b0f2706db719220", "filename": "gcc/cp/call.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b1db7f9139c8a0915f81359eefc10c6187d6145c", "patch": "@@ -8719,9 +8719,9 @@ perform_direct_initialization_if_possible (tree type,\n \n   The next several functions are involved in this lifetime extension.  */\n \n-/* DECL is a VAR_DECL whose type is a REFERENCE_TYPE.  The reference\n-   is being bound to a temporary.  Create and return a new VAR_DECL\n-   with the indicated TYPE; this variable will store the value to\n+/* DECL is a VAR_DECL or FIELD_DECL whose type is a REFERENCE_TYPE.  The\n+   reference is being bound to a temporary.  Create and return a new\n+   VAR_DECL with the indicated TYPE; this variable will store the value to\n    which the reference is bound.  */\n \n tree\n@@ -8733,13 +8733,15 @@ make_temporary_var_for_ref_to_temp (tree decl, tree type)\n   var = create_temporary_var (type);\n \n   /* Register the variable.  */\n-  if (TREE_STATIC (decl))\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && (TREE_STATIC (decl) || DECL_THREAD_LOCAL_P (decl)))\n     {\n       /* Namespace-scope or local static; give it a mangled name.  */\n       /* FIXME share comdat with decl?  */\n       tree name;\n \n-      TREE_STATIC (var) = 1;\n+      TREE_STATIC (var) = TREE_STATIC (decl);\n+      DECL_TLS_MODEL (var) = DECL_TLS_MODEL (decl);\n       name = mangle_ref_init_variable (decl);\n       DECL_NAME (var) = name;\n       SET_DECL_ASSEMBLER_NAME (var, name);"}, {"sha": "51c8d566e90147a6f533ec91d815aad73dfed4e1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b1db7f9139c8a0915f81359eefc10c6187d6145c", "patch": "@@ -56,6 +56,7 @@ c-common.h, not after.\n       AGGR_INIT_VIA_CTOR_P (in AGGR_INIT_EXPR)\n       PTRMEM_OK_P (in ADDR_EXPR, OFFSET_REF, SCOPE_REF)\n       PAREN_STRING_LITERAL (in STRING_CST)\n+      DECL_GNU_TLS_P (in VAR_DECL)\n       KOENIG_LOOKUP_P (in CALL_EXPR)\n       STATEMENT_LIST_NO_SCOPE (in STATEMENT_LIST).\n       EXPR_STMT_STMT_EXPR_RESULT (in EXPR_STMT)\n@@ -2425,6 +2426,11 @@ struct GTY((variable_size)) lang_decl {\n   (DECL_NAME (NODE) \\\n    && !strcmp (IDENTIFIER_POINTER (DECL_NAME (NODE)), \"__PRETTY_FUNCTION__\"))\n \n+/* Nonzero if the thread-local variable was declared with __thread\n+   as opposed to thread_local.  */\n+#define DECL_GNU_TLS_P(NODE) \\\n+  (TREE_LANG_FLAG_0 (VAR_DECL_CHECK (NODE)))\n+\n /* The _TYPE context in which this _DECL appears.  This field holds the\n    class where a virtual function instance is actually defined.  */\n #define DECL_CLASS_CONTEXT(NODE) \\\n@@ -4732,6 +4738,8 @@ typedef struct cp_decl_specifier_seq {\n   BOOL_BITFIELD explicit_int128_p : 1;\n   /* True iff \"char\" was explicitly provided.  */\n   BOOL_BITFIELD explicit_char_p : 1;\n+  /* True iff ds_thread is set for __thread, not thread_local.  */\n+  BOOL_BITFIELD gnu_thread_keyword_p : 1;\n } cp_decl_specifier_seq;\n \n /* The various kinds of declarators.  */"}, {"sha": "b409c34eee1003d19e31799d6a242636305a73ea", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 66, "deletions": 24, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b1db7f9139c8a0915f81359eefc10c6187d6145c", "patch": "@@ -6227,13 +6227,6 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n-      /* Only variables with trivial initialization and destruction can\n-\t have thread-local storage.  */\n-      if (DECL_THREAD_LOCAL_P (decl)\n-\t  && (type_has_nontrivial_default_init (TREE_TYPE (decl))\n-\t      || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (decl))))\n-\terror (\"%qD cannot be thread-local because it has non-trivial \"\n-\t       \"type %qT\", decl, TREE_TYPE (decl));\n       /* If this is a local variable that will need a mangled name,\n \t register it now.  We must do this before processing the\n \t initializer for the variable, since the initialization might\n@@ -6279,13 +6272,6 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t    }\n \t  cleanups = make_tree_vector ();\n \t  init = check_initializer (decl, init, flags, &cleanups);\n-\t  /* Thread-local storage cannot be dynamically initialized.  */\n-\t  if (DECL_THREAD_LOCAL_P (decl) && init)\n-\t    {\n-\t      error (\"%qD is thread-local and so cannot be dynamically \"\n-\t\t     \"initialized\", decl);\n-\t      init = NULL_TREE;\n-\t    }\n \n \t  /* Check that the initializer for a static data member was a\n \t     constant.  Although we check in the parser that the\n@@ -6734,6 +6720,12 @@ register_dtor_fn (tree decl)\n       end_cleanup_fn ();\n     }\n \n+  if (DECL_THREAD_LOCAL_P (decl))\n+    /* We don't have a thread-local atexit yet.  FIXME write one using\n+       pthread_key_create and friends.  */\n+    sorry (\"thread-local variable %q#D with non-trivial \"\n+\t   \"destructor\", decl);\n+\n   /* Call atexit with the cleanup function.  */\n   mark_used (cleanup);\n   cleanup = build_address (cleanup);\n@@ -6797,13 +6789,46 @@ expand_static_init (tree decl, tree init)\n       && TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n     return;\n \n+  if (DECL_THREAD_LOCAL_P (decl) && DECL_GNU_TLS_P (decl)\n+      && !DECL_FUNCTION_SCOPE_P (decl))\n+    {\n+      if (init)\n+\terror (\"non-local variable %qD declared %<__thread%> \"\n+\t       \"needs dynamic initialization\", decl);\n+      else\n+\terror (\"non-local variable %qD declared %<__thread%> \"\n+\t       \"has a non-trivial destructor\", decl);\n+      static bool informed;\n+      if (!informed)\n+\t{\n+\t  inform (DECL_SOURCE_LOCATION (decl),\n+\t\t  \"C++11 %<thread_local%> allows dynamic initialization \"\n+\t\t  \"and destruction\");\n+\t  informed = true;\n+\t}\n+      return;\n+    }\n+\n+  if (DECL_THREAD_LOCAL_P (decl) && !DECL_FUNCTION_SCOPE_P (decl))\n+    {\n+      /* We haven't implemented dynamic initialization of non-local\n+\t thread-local storage yet.  FIXME transform to singleton\n+\t function.  */\n+      sorry (\"thread-local variable %qD with dynamic initialization outside \"\n+\t     \"function scope\", decl);\n+      return;\n+    }\n+\n   if (DECL_FUNCTION_SCOPE_P (decl))\n     {\n       /* Emit code to perform this initialization but once.  */\n       tree if_stmt = NULL_TREE, inner_if_stmt = NULL_TREE;\n       tree then_clause = NULL_TREE, inner_then_clause = NULL_TREE;\n       tree guard, guard_addr;\n       tree flag, begin;\n+      /* We don't need thread-safety code for thread-local vars.  */\n+      bool thread_guard = (flag_threadsafe_statics\n+\t\t\t   && !DECL_THREAD_LOCAL_P (decl));\n \n       /* Emit code to perform this initialization but once.  This code\n \t looks like:\n@@ -6842,15 +6867,15 @@ expand_static_init (tree decl, tree init)\n       /* This optimization isn't safe on targets with relaxed memory\n \t consistency.  On such targets we force synchronization in\n \t __cxa_guard_acquire.  */\n-      if (!targetm.relaxed_ordering || !flag_threadsafe_statics)\n+      if (!targetm.relaxed_ordering || !thread_guard)\n \t{\n \t  /* Begin the conditional initialization.  */\n \t  if_stmt = begin_if_stmt ();\n \t  finish_if_stmt_cond (get_guard_cond (guard), if_stmt);\n \t  then_clause = begin_compound_stmt (BCS_NO_SCOPE);\n \t}\n \n-      if (flag_threadsafe_statics)\n+      if (thread_guard)\n \t{\n \t  tree vfntype = NULL_TREE;\n \t  tree acquire_name, release_name, abort_name;\n@@ -6908,14 +6933,14 @@ expand_static_init (tree decl, tree init)\n \n       finish_expr_stmt (init);\n \n-      if (flag_threadsafe_statics)\n+      if (thread_guard)\n \t{\n \t  finish_compound_stmt (inner_then_clause);\n \t  finish_then_clause (inner_if_stmt);\n \t  finish_if_stmt (inner_if_stmt);\n \t}\n \n-      if (!targetm.relaxed_ordering || !flag_threadsafe_statics)\n+      if (!targetm.relaxed_ordering || !thread_guard)\n \t{\n \t  finish_compound_stmt (then_clause);\n \t  finish_then_clause (if_stmt);\n@@ -7732,7 +7757,11 @@ grokvardecl (tree type,\n     }\n \n   if (decl_spec_seq_has_spec_p (declspecs, ds_thread))\n-    DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n+    {\n+      DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n+      if (declspecs->gnu_thread_keyword_p)\n+\tDECL_GNU_TLS_P (decl) = true;\n+    }\n \n   /* If the type of the decl has no linkage, make sure that we'll\n      notice that in mark_used.  */\n@@ -8462,7 +8491,7 @@ check_var_type (tree identifier, tree type)\n \n tree\n grokdeclarator (const cp_declarator *declarator,\n-\t\tconst cp_decl_specifier_seq *declspecs,\n+\t\tcp_decl_specifier_seq *declspecs,\n \t\tenum decl_context decl_context,\n \t\tint initialized,\n \t\ttree* attrlist)\n@@ -9176,9 +9205,15 @@ grokdeclarator (const cp_declarator *declarator,\n \t   && storage_class != sc_extern\n \t   && storage_class != sc_static)\n     {\n-      error (\"function-scope %qs implicitly auto and declared %<__thread%>\",\n-\t     name);\n-      thread_p = false;\n+      if (declspecs->gnu_thread_keyword_p)\n+\tpedwarn (input_location, 0, \"function-scope %qs implicitly auto and \"\n+\t\t \"declared %<__thread%>\", name);\n+\n+      /* When thread_local is applied to a variable of block scope the\n+\t storage-class-specifier static is implied if it does not appear\n+\t explicitly.  */\n+      storage_class = declspecs->storage_class = sc_static;\n+      staticp = 1;\n     }\n \n   if (storage_class && friendp)\n@@ -10454,7 +10489,14 @@ grokdeclarator (const cp_declarator *declarator,\n \telse if (storage_class == sc_register)\n \t  error (\"storage class %<register%> invalid for function %qs\", name);\n \telse if (thread_p)\n-\t  error (\"storage class %<__thread%> invalid for function %qs\", name);\n+\t  {\n+\t    if (declspecs->gnu_thread_keyword_p)\n+\t      error (\"storage class %<__thread%> invalid for function %qs\",\n+\t\t     name);\n+\t    else\n+\t      error (\"storage class %<thread_local%> invalid for function %qs\",\n+\t\t     name);\n+\t  }\n \n         if (virt_specifiers)\n           error (\"virt-specifiers in %qs not allowed outside a class definition\", name);"}, {"sha": "193df27c2f8004a9bfec05d810bf06d04c993ae4", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=b1db7f9139c8a0915f81359eefc10c6187d6145c", "patch": "@@ -34,7 +34,7 @@ enum decl_context\n \n /* We need this in here to get the decl_context definition.  */\n extern tree grokdeclarator (const cp_declarator *,\n-\t\t\t    const cp_decl_specifier_seq *,\n+\t\t\t    cp_decl_specifier_seq *,\n \t\t\t    enum decl_context, int, tree*);\n \n /* States indicating how grokdeclarator() should handle declspecs marked"}, {"sha": "f7db1d81b5d905b1fd256a434407a87c0db8a8a6", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b1db7f9139c8a0915f81359eefc10c6187d6145c", "patch": "@@ -2696,6 +2696,7 @@ get_guard (tree decl)\n       TREE_STATIC (guard) = TREE_STATIC (decl);\n       DECL_COMMON (guard) = DECL_COMMON (decl);\n       DECL_COMDAT (guard) = DECL_COMDAT (decl);\n+      DECL_TLS_MODEL (guard) = DECL_TLS_MODEL (decl);\n       if (DECL_ONE_ONLY (decl))\n \tmake_decl_one_only (guard, cxx_comdat_group (guard));\n       if (TREE_PUBLIC (decl))"}, {"sha": "52a152d1925cdd69ba85e2727dc734836439f223", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 72, "deletions": 46, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b1db7f9139c8a0915f81359eefc10c6187d6145c", "patch": "@@ -2248,12 +2248,12 @@ static tree cp_parser_trait_expr\n static bool cp_parser_declares_only_class_p\n   (cp_parser *);\n static void cp_parser_set_storage_class\n-  (cp_parser *, cp_decl_specifier_seq *, enum rid, location_t);\n+  (cp_parser *, cp_decl_specifier_seq *, enum rid, cp_token *);\n static void cp_parser_set_decl_spec_type\n-  (cp_decl_specifier_seq *, tree, location_t, bool);\n+  (cp_decl_specifier_seq *, tree, cp_token *, bool);\n static void set_and_check_decl_spec_loc\n   (cp_decl_specifier_seq *decl_specs,\n-   cp_decl_spec ds, source_location location);\n+   cp_decl_spec ds, cp_token *);\n static bool cp_parser_friend_p\n   (const cp_decl_specifier_seq *);\n static void cp_parser_required_error\n@@ -10821,7 +10821,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \n               /* Set the storage class anyway.  */\n               cp_parser_set_storage_class (parser, decl_specs, RID_AUTO,\n-\t\t\t\t\t   token->location);\n+\t\t\t\t\t   token);\n             }\n           else\n \t    /* C++0x auto type-specifier.  */\n@@ -10835,7 +10835,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t  /* Consume the token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n           cp_parser_set_storage_class (parser, decl_specs, token->keyword,\n-\t\t\t\t       token->location);\n+\t\t\t\t       token);\n \t  break;\n \tcase RID_THREAD:\n \t  /* Consume the token.  */\n@@ -10855,7 +10855,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \terror (\"decl-specifier invalid in condition\");\n \n       if (ds != ds_last)\n-\tset_and_check_decl_spec_loc (decl_specs, ds, token->location);\n+\tset_and_check_decl_spec_loc (decl_specs, ds, token);\n \n       /* Constructors are a special case.  The `S' in `S()' is not a\n \t decl-specifier; it is the beginning of the declarator.  */\n@@ -11004,7 +11004,7 @@ cp_parser_function_specifier_opt (cp_parser* parser,\n   switch (token->keyword)\n     {\n     case RID_INLINE:\n-      set_and_check_decl_spec_loc (decl_specs, ds_inline, token->location);\n+      set_and_check_decl_spec_loc (decl_specs, ds_inline, token);\n       break;\n \n     case RID_VIRTUAL:\n@@ -11013,11 +11013,11 @@ cp_parser_function_specifier_opt (cp_parser* parser,\n \t A member function template shall not be virtual.  */\n       if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n \terror_at (token->location, \"templates may not be %<virtual%>\");\n-      set_and_check_decl_spec_loc (decl_specs, ds_virtual, token->location);\n+      set_and_check_decl_spec_loc (decl_specs, ds_virtual, token);\n       break;\n \n     case RID_EXPLICIT:\n-      set_and_check_decl_spec_loc (decl_specs, ds_explicit, token->location);\n+      set_and_check_decl_spec_loc (decl_specs, ds_explicit, token);\n       break;\n \n     default:\n@@ -13525,7 +13525,7 @@ cp_parser_type_specifier (cp_parser* parser,\n \t  if (decl_specs)\n \t    cp_parser_set_decl_spec_type (decl_specs,\n \t\t\t\t\t  type_spec,\n-\t\t\t\t\t  token->location,\n+\t\t\t\t\t  token,\n \t\t\t\t\t  /*type_definition_p=*/true);\n \t  return type_spec;\n \t}\n@@ -13554,7 +13554,7 @@ cp_parser_type_specifier (cp_parser* parser,\n \t  if (decl_specs)\n \t    cp_parser_set_decl_spec_type (decl_specs,\n \t\t\t\t\t  type_spec,\n-\t\t\t\t\t  token->location,\n+\t\t\t\t\t  token,\n \t\t\t\t\t  /*type_definition_p=*/true);\n \t  return type_spec;\n \t}\n@@ -13576,7 +13576,7 @@ cp_parser_type_specifier (cp_parser* parser,\n       if (decl_specs)\n \tcp_parser_set_decl_spec_type (decl_specs,\n \t\t\t\t      type_spec,\n-\t\t\t\t      token->location,\n+\t\t\t\t      token,\n \t\t\t\t      /*type_definition_p=*/false);\n       return type_spec;\n \n@@ -13612,7 +13612,7 @@ cp_parser_type_specifier (cp_parser* parser,\n     {\n       if (decl_specs)\n \t{\n-\t  set_and_check_decl_spec_loc (decl_specs, ds, token->location);\n+\t  set_and_check_decl_spec_loc (decl_specs, ds, token);\n \t  decl_specs->any_specifiers_p = true;\n \t}\n       return cp_lexer_consume_token (parser->lexer)->u.value;\n@@ -13703,7 +13703,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       type = boolean_type_node;\n       break;\n     case RID_SHORT:\n-      set_and_check_decl_spec_loc (decl_specs, ds_short, token->location);\n+      set_and_check_decl_spec_loc (decl_specs, ds_short, token);\n       type = short_integer_type_node;\n       break;\n     case RID_INT:\n@@ -13720,15 +13720,15 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       break;\n     case RID_LONG:\n       if (decl_specs)\n-\tset_and_check_decl_spec_loc (decl_specs, ds_long, token->location);\n+\tset_and_check_decl_spec_loc (decl_specs, ds_long, token);\n       type = long_integer_type_node;\n       break;\n     case RID_SIGNED:\n-      set_and_check_decl_spec_loc (decl_specs, ds_signed, token->location);\n+      set_and_check_decl_spec_loc (decl_specs, ds_signed, token);\n       type = integer_type_node;\n       break;\n     case RID_UNSIGNED:\n-      set_and_check_decl_spec_loc (decl_specs, ds_unsigned, token->location);\n+      set_and_check_decl_spec_loc (decl_specs, ds_unsigned, token);\n       type = unsigned_type_node;\n       break;\n     case RID_FLOAT:\n@@ -13766,7 +13766,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \n       if (decl_specs)\n \tcp_parser_set_decl_spec_type (decl_specs, type,\n-\t\t\t\t      token->location,\n+\t\t\t\t      token,\n \t\t\t\t      /*type_definition_p=*/false);\n \n       return type;\n@@ -13775,7 +13775,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       type = cp_parser_trait_expr (parser, RID_UNDERLYING_TYPE);\n       if (decl_specs)\n \tcp_parser_set_decl_spec_type (decl_specs, type,\n-\t\t\t\t      token->location,\n+\t\t\t\t      token,\n \t\t\t\t      /*type_definition_p=*/false);\n \n       return type;\n@@ -13785,7 +13785,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       type = cp_parser_trait_expr (parser, token->keyword);\n       if (decl_specs)\n        cp_parser_set_decl_spec_type (decl_specs, type,\n-                                     token->location,\n+                                     token,\n                                      /*type_definition_p=*/false);\n       return type;\n     default:\n@@ -13800,7 +13800,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       type = token->u.value;\n       if (decl_specs)\n \tcp_parser_set_decl_spec_type (decl_specs, type,\n-\t\t\t\t      token->location,\n+\t\t\t\t      token,\n \t\t\t\t      /*type_definition_p=*/false);\n       cp_lexer_consume_token (parser->lexer);\n       return type;\n@@ -13817,7 +13817,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t      && token->keyword != RID_LONG))\n \tcp_parser_set_decl_spec_type (decl_specs,\n \t\t\t\t      type,\n-\t\t\t\t      token->location,\n+\t\t\t\t      token,\n \t\t\t\t      /*type_definition_p=*/false);\n       if (decl_specs)\n \tdecl_specs->any_specifiers_p = true;\n@@ -13894,7 +13894,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \ttype = NULL_TREE;\n       if (type && decl_specs)\n \tcp_parser_set_decl_spec_type (decl_specs, type,\n-\t\t\t\t      token->location,\n+\t\t\t\t      token,\n \t\t\t\t      /*type_definition_p=*/false);\n     }\n \n@@ -15245,21 +15245,24 @@ static tree\n cp_parser_alias_declaration (cp_parser* parser)\n {\n   tree id, type, decl, pushed_scope = NULL_TREE, attributes;\n-  location_t id_location, using_location, attrs_location = 0;\n+  location_t id_location;\n   cp_declarator *declarator;\n   cp_decl_specifier_seq decl_specs;\n   bool member_p;\n   const char *saved_message = NULL;\n \n   /* Look for the `using' keyword.  */\n-  using_location = cp_lexer_peek_token (parser->lexer)->location;\n-  cp_parser_require_keyword (parser, RID_USING, RT_USING);\n+  cp_token *using_token\n+    = cp_parser_require_keyword (parser, RID_USING, RT_USING);\n+  if (using_token == NULL)\n+    return error_mark_node;\n+\n   id_location = cp_lexer_peek_token (parser->lexer)->location;\n   id = cp_parser_identifier (parser);\n   if (id == error_mark_node)\n     return error_mark_node;\n \n-  attrs_location = cp_lexer_peek_token (parser->lexer)->location;\n+  cp_token *attrs_token = cp_lexer_peek_token (parser->lexer);\n   attributes = cp_parser_attributes_opt (parser);\n   if (attributes == error_mark_node)\n     return error_mark_node;\n@@ -15316,14 +15319,14 @@ cp_parser_alias_declaration (cp_parser* parser)\n       decl_specs.attributes = attributes;\n       set_and_check_decl_spec_loc (&decl_specs,\n \t\t\t\t   ds_attribute,\n-\t\t\t\t   attrs_location);\n+\t\t\t\t   attrs_token);\n     }\n   set_and_check_decl_spec_loc (&decl_specs,\n \t\t\t       ds_typedef,\n-\t\t\t       using_location);\n+\t\t\t       using_token);\n   set_and_check_decl_spec_loc (&decl_specs,\n \t\t\t       ds_alias,\n-\t\t\t       using_location);\n+\t\t\t       using_token);\n \n   declarator = make_id_declarator (NULL_TREE, id, sfk_none);\n   declarator->id_loc = id_location;\n@@ -22585,13 +22588,13 @@ static void\n cp_parser_set_storage_class (cp_parser *parser,\n \t\t\t     cp_decl_specifier_seq *decl_specs,\n \t\t\t     enum rid keyword,\n-\t\t\t     location_t location)\n+\t\t\t     cp_token *token)\n {\n   cp_storage_class storage_class;\n \n   if (parser->in_unbraced_linkage_specification_p)\n     {\n-      error_at (location, \"invalid use of %qD in linkage specification\",\n+      error_at (token->location, \"invalid use of %qD in linkage specification\",\n \t\tridpointers[keyword]);\n       return;\n     }\n@@ -22602,11 +22605,11 @@ cp_parser_set_storage_class (cp_parser *parser,\n     }\n \n   if ((keyword == RID_EXTERN || keyword == RID_STATIC)\n-      && decl_spec_seq_has_spec_p (decl_specs, ds_thread))\n+      && decl_spec_seq_has_spec_p (decl_specs, ds_thread)\n+      && decl_specs->gnu_thread_keyword_p)\n     {\n-      error_at (decl_specs->locations[ds_thread],\n+      pedwarn (decl_specs->locations[ds_thread], 0,\n \t\t\"%<__thread%> before %qD\", ridpointers[keyword]);\n-      decl_specs->locations[ds_thread] = 0;\n     }\n \n   switch (keyword)\n@@ -22630,7 +22633,7 @@ cp_parser_set_storage_class (cp_parser *parser,\n       gcc_unreachable ();\n     }\n   decl_specs->storage_class = storage_class;\n-  set_and_check_decl_spec_loc (decl_specs, ds_storage_class, location);\n+  set_and_check_decl_spec_loc (decl_specs, ds_storage_class, token);\n \n   /* A storage class specifier cannot be applied alongside a typedef \n      specifier. If there is a typedef specifier present then set \n@@ -22646,7 +22649,7 @@ cp_parser_set_storage_class (cp_parser *parser,\n static void\n cp_parser_set_decl_spec_type (cp_decl_specifier_seq *decl_specs,\n \t\t\t      tree type_spec,\n-\t\t\t      location_t location,\n+\t\t\t      cp_token *token,\n \t\t\t      bool type_definition_p)\n {\n   decl_specs->any_specifiers_p = true;\n@@ -22671,12 +22674,12 @@ cp_parser_set_decl_spec_type (cp_decl_specifier_seq *decl_specs,\n       decl_specs->redefined_builtin_type = type_spec;\n       set_and_check_decl_spec_loc (decl_specs,\n \t\t\t\t   ds_redefined_builtin_type_spec,\n-\t\t\t\t   location);\n+\t\t\t\t   token);\n       if (!decl_specs->type)\n \t{\n \t  decl_specs->type = type_spec;\n \t  decl_specs->type_definition_p = false;\n-\t  set_and_check_decl_spec_loc (decl_specs,ds_type_spec, location);\n+\t  set_and_check_decl_spec_loc (decl_specs,ds_type_spec, token);\n \t}\n     }\n   else if (decl_specs->type)\n@@ -22686,10 +22689,19 @@ cp_parser_set_decl_spec_type (cp_decl_specifier_seq *decl_specs,\n       decl_specs->type = type_spec;\n       decl_specs->type_definition_p = type_definition_p;\n       decl_specs->redefined_builtin_type = NULL_TREE;\n-      set_and_check_decl_spec_loc (decl_specs, ds_type_spec, location);\n+      set_and_check_decl_spec_loc (decl_specs, ds_type_spec, token);\n     }\n }\n \n+/* True iff TOKEN is the GNU keyword __thread.  */\n+\n+static bool\n+token_is__thread (cp_token *token)\n+{\n+  gcc_assert (token->keyword == RID_THREAD);\n+  return !strcmp (IDENTIFIER_POINTER (token->u.value), \"__thread\");\n+}\n+\n /* Set the location for a declarator specifier and check if it is\n    duplicated.\n \n@@ -22704,15 +22716,21 @@ cp_parser_set_decl_spec_type (cp_decl_specifier_seq *decl_specs,\n \n static void\n set_and_check_decl_spec_loc (cp_decl_specifier_seq *decl_specs,\n-\t\t\t     cp_decl_spec ds, source_location location)\n+\t\t\t     cp_decl_spec ds, cp_token *token)\n {\n   gcc_assert (ds < ds_last);\n \n   if (decl_specs == NULL)\n     return;\n \n+  source_location location = token->location;\n+\n   if (decl_specs->locations[ds] == 0)\n-    decl_specs->locations[ds] = location;\n+    {\n+      decl_specs->locations[ds] = location;\n+      if (ds == ds_thread)\n+\tdecl_specs->gnu_thread_keyword_p = token_is__thread (token);\n+    }\n   else\n     {\n       if (ds == ds_long)\n@@ -22728,6 +22746,15 @@ set_and_check_decl_spec_loc (cp_decl_specifier_seq *decl_specs,\n \t\t\t     \"ISO C++ 1998 does not support %<long long%>\");\n \t    }\n \t}\n+      else if (ds == ds_thread)\n+\t{\n+\t  bool gnu = token_is__thread (token);\n+\t  if (gnu != decl_specs->gnu_thread_keyword_p)\n+\t    error_at (location,\n+\t\t      \"both %<__thread%> and %<thread_local%> specified\");\n+\t  else\n+\t    error_at (location, \"duplicate %qD\", token->u.value);\n+\t}\n       else\n \t{\n \t  static const char *const decl_spec_names[] = {\n@@ -22745,8 +22772,7 @@ set_and_check_decl_spec_loc (cp_decl_specifier_seq *decl_specs,\n \t    \"typedef\",\n \t    \"using\",\n             \"constexpr\",\n-\t    \"__complex\",\n-\t    \"__thread\"\n+\t    \"__complex\"\n \t  };\n \t  error_at (location,\n \t\t    \"duplicate %qs\", decl_spec_names[ds]);\n@@ -24587,7 +24613,7 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n \t  declspecs.storage_class = sc_none;\n \t}\n \n-      /* __thread.  */\n+      /* thread_local.  */\n       if (decl_spec_seq_has_spec_p (&declspecs, ds_thread))\n \t{\n \t  cp_parser_error (parser, \"invalid type for instance variable\");\n@@ -25166,7 +25192,7 @@ cp_parser_objc_struct_declaration (cp_parser *parser)\n       declspecs.storage_class = sc_none;\n     }\n   \n-  /* __thread.  */\n+  /* thread_local.  */\n   if (decl_spec_seq_has_spec_p (&declspecs, ds_thread))\n     {\n       cp_parser_error (parser, \"invalid type for property\");"}, {"sha": "76d0762e829ae11fd4979ba33deacd87589faa50", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b1db7f9139c8a0915f81359eefc10c6187d6145c", "patch": "@@ -1,3 +1,10 @@\n+2012-10-08  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/tls/init-2.C: Tweak errors.\n+\t* g++.dg/tls/thread_local1.C: New.\n+\t* g++.dg/tls/thread_local2.C: New.\n+\t* g++.dg/tls/thread_local7.C: New.\n+\n 2012-10-08  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/54685"}, {"sha": "327c309e98584e5b22a88fb63c026b8a2ab1f6bf", "filename": "gcc/testsuite/g++.dg/tls/init-2.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Finit-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Finit-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Finit-2.C?ref=b1db7f9139c8a0915f81359eefc10c6187d6145c", "patch": "@@ -2,13 +2,13 @@\n /* { dg-require-effective-target tls } */\n \n extern __thread int i;\n-__thread int *p = &i;\t/* { dg-error \"dynamically initialized\" } */\n+__thread int *p = &i;\t/* { dg-error \"dynamic initialization\" } */\n \n extern int f();\n-__thread int j = f();\t/* { dg-error \"dynamically initialized\" } */\n+__thread int j = f();\t/* { dg-error \"dynamic initialization\" } */\n \n struct S\n {\n   S();\n };\n-__thread S s;\t\t/* { dg-error \"\" } two errors here */\n+__thread S s;\t\t/* { dg-error \"dynamic initialization\" } */"}, {"sha": "e7734a0badf36ad1d2cbdb0cf2ea91309d9bb491", "filename": "gcc/testsuite/g++.dg/tls/thread_local1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local1.C?ref=b1db7f9139c8a0915f81359eefc10c6187d6145c", "patch": "@@ -0,0 +1,21 @@\n+// { dg-options \"-std=c++11\" }\n+// { dg-require-effective-target tls }\n+\n+// The variable should have a guard.\n+// { dg-final { scan-assembler \"_ZGVZ1fvE1a\" } }\n+// But since it's thread local we don't need to guard against\n+// simultaneous execution.\n+// { dg-final { scan-assembler-not \"cxa_guard\" } }\n+// The guard should be TLS, not local common.\n+// { dg-final { scan-assembler-not \"\\.comm\" } }\n+\n+struct A\n+{\n+  A();\n+};\n+\n+A &f()\n+{\n+  thread_local A a;\n+  return a;\n+}"}, {"sha": "4cbef155ead855eb5d8a7880e1f378ffeb7a63bf", "filename": "gcc/testsuite/g++.dg/tls/thread_local2.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local2.C?ref=b1db7f9139c8a0915f81359eefc10c6187d6145c", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++11\" }\n+// { dg-require-effective-target tls_runtime }\n+\n+extern \"C\" void abort();\n+\n+struct A\n+{\n+  A();\n+  int i;\n+};\n+\n+A &f()\n+{\n+  thread_local A a;\n+  return a;\n+}\n+\n+int j;\n+A::A(): i(j) { }\n+\n+int main()\n+{\n+  j = 42;\n+  if (f().i != 42)\n+    abort ();\n+}"}, {"sha": "77a1c05e44c5a406979066768c9aa1534b8d2052", "filename": "gcc/testsuite/g++.dg/tls/thread_local7.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1db7f9139c8a0915f81359eefc10c6187d6145c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local7.C?ref=b1db7f9139c8a0915f81359eefc10c6187d6145c", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options \"-std=c++11\" }\n+// { dg-require-effective-target tls }\n+\n+// The reference temp should be TLS, not normal data.\n+// { dg-final { scan-assembler-not \"\\\\.data\" } }\n+\n+void f()\n+{\n+  thread_local int&& ir = 42;\n+}"}]}