{"sha": "ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM2ZWQxODJlZGNhMmMxNWViMDUwOTMzNmI1ZmNjNDVmYjI1MGZlNw==", "commit": {"author": {"name": "Andreas Tobler", "email": "a.tobler@schweiz.ch", "date": "2006-04-22T21:17:35Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2006-04-22T21:17:35Z"}, "message": "README: Remove notice about 'Crazy Comments'.\n\n2006-04-22  Andreas Tobler  <a.tobler@schweiz.ch>\n\n\t* README: Remove notice about 'Crazy Comments'.\n\t* src/debug.c: Remove lint directives. Cleanup white spaces.\n\t* src/java_raw_api.c: Likewise.\n\t* src/prep_cif.c: Likewise.\n\t* src/raw_api.c: Likewise.\n\t* src/ffitest.c: Delete. No longer needed, all test cases migrated\n\tto the testsuite.\n\t* src/arm/ffi.c: Remove lint directives.\n\t* src/m32r/ffi.c: Likewise.\n\t* src/pa/ffi.c: Likewise.\n\t* src/powerpc/ffi.c: Likewise.\n\t* src/powerpc/ffi_darwin.c: Likewise.\n\t* src/sh/ffi.c: Likewise.\n\t* src/sh64/ffi.c: Likewise.\n\t* src/x86/ffi.c: Likewise.\n\t* testsuite/libffi.call/float2.c: Likewise.\n\t* testsuite/libffi.call/promotion.c: Likewise.\n\t* testsuite/libffi.call/struct1.c: Likewise.\n\nFrom-SVN: r113181", "tree": {"sha": "e5d1292ca0d5f15af38f6aa116392b799fd3e3a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5d1292ca0d5f15af38f6aa116392b799fd3e3a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/comments", "author": null, "committer": null, "parents": [{"sha": "9542abd3787272cf9a7054be5c5b70668c13ecb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9542abd3787272cf9a7054be5c5b70668c13ecb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9542abd3787272cf9a7054be5c5b70668c13ecb1"}], "stats": {"total": 1701, "additions": 110, "deletions": 1591}, "files": [{"sha": "f9319335b740d7af3bbfa0998c456fa06805a056", "filename": "libffi/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -1,3 +1,24 @@\n+2006-04-22  Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\t* README: Remove notice about 'Crazy Comments'.\n+\t* src/debug.c: Remove lint directives. Cleanup white spaces.\n+\t* src/java_raw_api.c: Likewise.\n+\t* src/prep_cif.c: Likewise.\n+\t* src/raw_api.c: Likewise.\n+\t* src/ffitest.c: Delete. No longer needed, all test cases migrated\n+\tto the testsuite.\n+\t* src/arm/ffi.c: Remove lint directives.\n+\t* src/m32r/ffi.c: Likewise.\n+\t* src/pa/ffi.c: Likewise.\n+\t* src/powerpc/ffi.c: Likewise.\n+\t* src/powerpc/ffi_darwin.c: Likewise.\n+\t* src/sh/ffi.c: Likewise.\n+\t* src/sh64/ffi.c: Likewise.\n+\t* src/x86/ffi.c: Likewise.\n+\t* testsuite/libffi.call/float2.c: Likewise.\n+\t* testsuite/libffi.call/promotion.c: Likewise.\n+\t* testsuite/libffi.call/struct1.c: Likewise.\n+\n 2006-04-13  Andreas Tobler  <a.tobler@schweiz.ch>\n \n \t* src/pa/hpux32.S: Correct unwind offset calculation for"}, {"sha": "471107700cafa8953c6d9d264f25e571f426a693", "filename": "libffi/README", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FREADME?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -372,15 +372,6 @@ single-precision anyway.  This causes one test to fail (the `many\n arguments' test).\n \n \n-What's With The Crazy Comments?\n-===============================\n-\n-You might notice a number of cryptic comments in the code, delimited\n-by /*@ and @*/. These are annotations read by the program LCLint, a\n-tool for statically checking C programs. You can read all about it at\n-<http://larch-www.lcs.mit.edu:8001/larch/lclint/index.html>.\n-\n-\n History\n =======\n "}, {"sha": "4a5edd3a560d6331a5b05e3ff472c28bb49fd9e7", "filename": "libffi/src/arm/ffi.c", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Farm%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Farm%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fffi.c?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -31,9 +31,7 @@\n /* ffi_prep_args is called by the assembly routine once stack space\n    has been allocated for the function's arguments */\n \n-/*@-exportheader@*/\n void ffi_prep_args(char *stack, extended_cif *ecif)\n-/*@=exportheader@*/\n {\n   register unsigned int i;\n   register void **p_argv;\n@@ -136,20 +134,10 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   return FFI_OK;\n }\n \n-/*@-declundef@*/\n-/*@-exportheader@*/\n-extern void ffi_call_SYSV(void (*)(char *, extended_cif *), \n-\t\t\t  /*@out@*/ extended_cif *, \n-\t\t\t  unsigned, unsigned, \n-\t\t\t  /*@out@*/ unsigned *, \n-\t\t\t  void (*fn)());\n-/*@=declundef@*/\n-/*@=exportheader@*/\n-\n-void ffi_call(/*@dependent@*/ ffi_cif *cif, \n-\t      void (*fn)(), \n-\t      /*@out@*/ void *rvalue, \n-\t      /*@dependent@*/ void **avalue)\n+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,\n+\t\t\t  unsigned, unsigned, unsigned *, void (*fn)());\n+\n+void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n {\n   extended_cif ecif;\n \n@@ -162,9 +150,7 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n   if ((rvalue == NULL) && \n       (cif->rtype->type == FFI_TYPE_STRUCT))\n     {\n-      /*@-sysunrecog@*/\n       ecif.rvalue = alloca(cif->rtype->size);\n-      /*@=sysunrecog@*/\n     }\n   else\n     ecif.rvalue = rvalue;\n@@ -173,10 +159,9 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n   switch (cif->abi) \n     {\n     case FFI_SYSV:\n-      /*@-usedef@*/\n-      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, \n-\t\t    cif->flags, ecif.rvalue, fn);\n-      /*@=usedef@*/\n+      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue,\n+\t\t    fn);\n+\n       break;\n     default:\n       FFI_ASSERT(0);"}, {"sha": "f15eb91abcb0ec62b94d7d1328e4ccd233a4b2e9", "filename": "libffi/src/debug.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fdebug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fdebug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fdebug.c?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -31,7 +31,7 @@\n void ffi_stop_here(void)\n {\n   /* This function is only useful for debugging purposes.\n-     Place a breakpoint on ffi_stop_here to be notified of \n+     Place a breakpoint on ffi_stop_here to be notified of\n      significant events. */\n }\n \n@@ -50,10 +50,9 @@ void ffi_type_test(ffi_type *a, char *file, int line)\n {\n   FFI_ASSERT_AT(a != NULL, file, line);\n \n-  /*@-usedef@*/\n   FFI_ASSERT_AT(a->type <= FFI_TYPE_LAST, file, line);\n   FFI_ASSERT_AT(a->type == FFI_TYPE_VOID || a->size > 0, file, line);\n   FFI_ASSERT_AT(a->type == FFI_TYPE_VOID || a->alignment > 0, file, line);\n   FFI_ASSERT_AT(a->type != FFI_TYPE_STRUCT || a->elements != NULL, file, line);\n-  /*@=usedef@*/\n+\n }"}, {"sha": "223b49c6dd81b25d1d782648fe4c4e2b9b1aac8b", "filename": "libffi/src/ffitest.c", "status": "removed", "additions": 0, "deletions": 1314, "changes": 1314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9542abd3787272cf9a7054be5c5b70668c13ecb1/libffi%2Fsrc%2Fffitest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9542abd3787272cf9a7054be5c5b70668c13ecb1/libffi%2Fsrc%2Fffitest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fffitest.c?ref=9542abd3787272cf9a7054be5c5b70668c13ecb1", "patch": "@@ -1,1314 +0,0 @@\n-/* -----------------------------------------------------------------------\n-   ffitest.c - Copyright (c) 1996, 1997, 1998, 2002, 2003  Red Hat, Inc.\n-\n-   Permission is hereby granted, free of charge, to any person obtaining\n-   a copy of this software and associated documentation files (the\n-   ``Software''), to deal in the Software without restriction, including\n-   without limitation the rights to use, copy, modify, merge, publish,\n-   distribute, sublicense, and/or sell copies of the Software, and to\n-   permit persons to whom the Software is furnished to do so, subject to\n-   the following conditions:\n-\n-   The above copyright notice and this permission notice shall be included\n-   in all copies or substantial portions of the Software.\n-\n-   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n-   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n-   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n-   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-   OTHER DEALINGS IN THE SOFTWARE.\n-   ----------------------------------------------------------------------- */\n-\n-#include <ffi.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <float.h>\n-\n-/* This is lame. Long double support is barely there under SunOS 4.x  */\n-#if defined(SPARC) && (SIZEOF_LONG_DOUBLE != 16)\n-#define BROKEN_LONG_DOUBLE\n-#endif\n-\n-#define CHECK(x) !(x) ? fail(__FILE__, __LINE__) : 0 \n-\n-static int fail(char *file, int line)\n-{\n-  fprintf(stderr, \"Test failure: %s line %d\\n\", file, line);\n-  exit(EXIT_FAILURE);\n-  /*@notreached@*/\n-  return 0;\n-}\n-\n-#define MAX_ARGS 256\n-\n-static size_t my_strlen(char *s)\n-{\n-  return (strlen(s));\n-}\n-\n-#ifdef X86_WIN32\n-static size_t __attribute__((stdcall)) my_stdcall_strlen(char *s)\n-{\n-  return (strlen(s));\n-}\n-#endif /* X86_WIN32 */\n-\n-static int promotion(signed char sc, signed short ss, \n-\t\t     unsigned char uc, unsigned short us)\n-{\n-  int r = (int) sc + (int) ss + (int) uc + (int) us;\n-\n-  return r;\n-}\n-\n-static signed char return_sc(signed char sc)\n-{\n-  return sc;\n-}\n-\n-static unsigned char return_uc(unsigned char uc)\n-{\n-  return uc;\n-}\n-\n-static long long return_ll(long long ll)\n-{\n-  return ll;\n-}\n-\n-static int floating(int a, float b, double c, long double d, int e)\n-{\n-  int i;\n-\n-#if 0\n-  /* This is ifdef'd out for now. long double support under SunOS/gcc\n-     is pretty much non-existent.  You'll get the odd bus error in library\n-     routines like printf().  */\n-  printf(\"%d %f %f %Lf %d\\n\", a, (double)b, c, d, e);\n-#endif\n-\n-  i = (int) ((float)a/b + ((float)c/(float)d));\n-\n-  return i;\n-}\n-\n-static float many(float f1,\n-\t\t  float f2,\n-\t\t  float f3,\n-\t\t  float f4,\n-\t\t  float f5,\n-\t\t  float f6,\n-\t\t  float f7,\n-\t\t  float f8,\n-\t\t  float f9,\n-\t\t  float f10,\n-\t\t  float f11,\n-\t\t  float f12,\n-\t\t  float f13)\n-{\n-#if 0\n-  printf(\"%f %f %f %f %f %f %f %f %f %f %f %f %f\\n\",\n-\t (double) f1, (double) f2, (double) f3, (double) f4, (double) f5, \n-\t (double) f6, (double) f7, (double) f8, (double) f9, (double) f10,\n-\t (double) f11, (double) f12, (double) f13);\n-#endif\n-\n-  return ((f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);\n-}\n-\n-#ifdef X86_WIN32\n-static float __attribute__((stdcall)) stdcall_many(float f1,\n-\t\t\t\t\t\t   float f2,\n-\t\t\t\t\t\t   float f3,\n-\t\t\t\t\t\t   float f4,\n-\t\t\t\t\t\t   float f5,\n-\t\t\t\t\t\t   float f6,\n-\t\t\t\t\t\t   float f7,\n-\t\t\t\t\t\t   float f8,\n-\t\t\t\t\t\t   float f9,\n-\t\t\t\t\t\t   float f10,\n-\t\t\t\t\t\t   float f11,\n-\t\t\t\t\t\t   float f12,\n-\t\t\t\t\t\t   float f13)\n-{\n-  return ((f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);\n-}\n-#endif /* X86_WIN32 */\n-\n-static double dblit(float f)\n-{\n-  return f/3.0;\n-}\n-\n-static long double ldblit(float f)\n-{\n-  return (long double) (((long double) f)/ (long double) 3.0);\n-}\n-\n-typedef struct\n-{\n-  unsigned char uc;\n-  double d;\n-  unsigned int ui;\n-} test_structure_1;\n-\n-typedef struct\n-{\n-  double d1;\n-  double d2;\n-} test_structure_2;\n-\n-typedef struct\n-{\n-  int si;\n-} test_structure_3;\n-\n-typedef struct\n-{\n-  unsigned ui1;\n-  unsigned ui2;\n-  unsigned ui3;\n-} test_structure_4;\n-\n-typedef struct\n-{\n-  char c1;\n-  char c2;\n-} test_structure_5;\n-\n-typedef struct\n-{\n-  float f;\n-  double d;\n-} test_structure_6;\n-\n-typedef struct\n-{\n-  float f1;\n-  float f2;\n-  double d;\n-} test_structure_7;\n-\n-typedef struct\n-{\n-  float f1;\n-  float f2;\n-  float f3;\n-  float f4;\n-} test_structure_8;\n-\n-typedef struct\n-{\n-  float f;\n-  int i;\n-} test_structure_9;\n-\n-static test_structure_1 struct1(test_structure_1 ts)\n-{\n-  /*@-type@*/\n-  ts.uc++;\n-  /*@=type@*/\n-  ts.d--;\n-  ts.ui++;\n-\n-  return ts;\n-}\n-\n-static test_structure_2 struct2(test_structure_2 ts)\n-{\n-  ts.d1--;\n-  ts.d2--;\n-\n-  return ts;\n-}\n-\n-static test_structure_3 struct3(test_structure_3 ts)\n-{\n-  ts.si = -(ts.si*2);\n-\n-  return ts;\n-}\n-\n-static test_structure_4 struct4(test_structure_4 ts)\n-{\n-  ts.ui3 = ts.ui1 * ts.ui2 * ts.ui3;\n-\n-  return ts;\n-}\n-\n-static test_structure_5 struct5(test_structure_5 ts1, test_structure_5 ts2)\n-{\n-  ts1.c1 += ts2.c1;\n-  ts1.c2 -= ts2.c2;\n-\n-  return ts1;\n-}\n-\n-static test_structure_6 struct6 (test_structure_6 ts)\n-{\n-  ts.f += 1;\n-  ts.d += 1;\n-\n-  return ts;\n-}\n-\n-static test_structure_7 struct7 (test_structure_7 ts)\n-{\n-  ts.f1 += 1;\n-  ts.f2 += 1;\n-  ts.d += 1;\n-\n-  return ts;\n-}\n-\n-static test_structure_8 struct8 (test_structure_8 ts)\n-{\n-  ts.f1 += 1;\n-  ts.f2 += 1;\n-  ts.f3 += 1;\n-  ts.f4 += 1;\n-\n-  return ts;\n-}\n-\n-static test_structure_9 struct9 (test_structure_9 ts)\n-{\n-  ts.f += 1;\n-  ts.i += 1;\n-\n-  return ts;\n-}\n-\n-/* Take an int and a float argument, together with int userdata, and \t*/\n-/* return the sum.\t\t\t\t\t\t\t*/\n-#if FFI_CLOSURES\n-static void\n-closure_test_fn(ffi_cif* cif,void* resp,void** args, void* userdata)\n-{\n-  *(ffi_arg*)resp =\n-    (int)*(unsigned long long *)args[0] + (int)(*(int *)args[1]) +\n-    (int)(*(unsigned long long *)args[2]) + (int)*(int *)args[3] +\n-    (int)(*(signed short *)args[4]) +\n-    (int)(*(unsigned long long *)args[5]) +\n-    (int)*(int *)args[6] + (int)(*(int *)args[7]) +\n-    (int)(*(double *)args[8]) + (int)*(int *)args[9] +\n-    (int)(*(int *)args[10]) + (int)(*(float *)args[11]) +\n-    (int)*(int *)args[12] + (int)(*(int *)args[13]) +\n-    (int)(*(int *)args[14]) +  *(int *)args[15] + (int)(long)userdata;\n-\n-    \tprintf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n-\t       (int)*(unsigned long long *)args[0], (int)(*(int *)args[1]), \n-\t       (int)(*(unsigned long long *)args[2]),\n-\t       (int)*(int *)args[3], (int)(*(signed short *)args[4]), \n-\t       (int)(*(unsigned long long *)args[5]),\n-\t       (int)*(int *)args[6], (int)(*(int *)args[7]), \n-\t       (int)(*(double *)args[8]), (int)*(int *)args[9],\n-\t       (int)(*(int *)args[10]), (int)(*(float *)args[11]),\n-\t       (int)*(int *)args[12], (int)(*(int *)args[13]), \n-\t       (int)(*(int *)args[14]),*(int *)args[15],\n-\t       (int)(long)userdata, (int)*(ffi_arg *)resp);\n-}\n-\n-typedef int (*closure_test_type)(unsigned long long, int, unsigned long long, \n-\t\t\t\t int, signed short, unsigned long long, int, \n-\t\t\t\t int, double, int, int, float, int, int, \n-\t\t\t\t int, int);\n-\n-static void closure_test_fn1(ffi_cif* cif,void* resp,void** args, \n-\t\t\t     void* userdata)\n- {\n-    *(ffi_arg*)resp =\n-      (int)*(float *)args[0] +(int)(*(float *)args[1]) + \n-      (int)(*(float *)args[2]) + (int)*(float *)args[3] +\n-      (int)(*(signed short *)args[4]) + (int)(*(float *)args[5]) +\n-      (int)*(float *)args[6] + (int)(*(int *)args[7]) + \n-      (int)(*(double*)args[8]) + (int)*(int *)args[9] + \n-      (int)(*(int *)args[10]) + (int)(*(float *)args[11]) + \n-      (int)*(int *)args[12] + (int)(*(int *)args[13]) + \n-      (int)(*(int *)args[14]) + *(int *)args[15] + (int)(long)userdata;\n-\n-    printf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n-\t   (int)*(float *)args[0], (int)(*(float *)args[1]), \n-\t   (int)(*(float *)args[2]), (int)*(float *)args[3], \n-\t   (int)(*(signed short *)args[4]), (int)(*(float *)args[5]),\n-\t   (int)*(float *)args[6], (int)(*(int *)args[7]),\n-\t   (int)(*(double *)args[8]), (int)*(int *)args[9],\n-\t   (int)(*(int *)args[10]), (int)(*(float *)args[11]),\n-\t   (int)*(int *)args[12], (int)(*(int *)args[13]),\n-\t   (int)(*(int *)args[14]), *(int *)args[15],\n-\t   (int)(long)userdata, (int)*(ffi_arg *)resp);\n-}\n-\n-typedef int (*closure_test_type1)(float, float, float, float, signed short, \n-\t\t\t\t  float, float, int, double, int, int, float,\n-\t\t\t\t  int, int, int, int);\n-\n-static void closure_test_fn2(ffi_cif* cif,void* resp,void** args, \n-\t\t\t     void* userdata)\n- {\n-    *(ffi_arg*)resp =\n-      (int)*(double *)args[0] +(int)(*(double *)args[1]) + \n-      (int)(*(double *)args[2]) + (int)*(double *)args[3] +\n-      (int)(*(signed short *)args[4]) + (int)(*(double *)args[5]) +\n-      (int)*(double *)args[6] + (int)(*(int *)args[7]) + \n-      (int)(*(double *)args[8]) + (int)*(int *)args[9] +\n-      (int)(*(int *)args[10]) + (int)(*(float *)args[11]) + \n-      (int)*(int *)args[12] + (int)(*(float *)args[13]) +\n-      (int)(*(int *)args[14]) + *(int *)args[15] + (int)(long)userdata;\n-\n-    printf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n-\t   (int)*(double *)args[0], (int)(*(double *)args[1]), \n-\t   (int)(*(double *)args[2]), (int)*(double *)args[3], \n-\t   (int)(*(signed short *)args[4]), (int)(*(double *)args[5]),\n-\t   (int)*(double *)args[6], (int)(*(int *)args[7]), \n-\t   (int)(*(double*)args[8]), (int)*(int *)args[9], \n-\t   (int)(*(int *)args[10]), (int)(*(float *)args[11]),\n-\t   (int)*(int *)args[12], (int)(*(float *)args[13]), \n-\t   (int)(*(int *)args[14]), *(int *)args[15], (int)(long)userdata, \n-\t   (int)*(ffi_arg *)resp);\n- }\n-\n-typedef int (*closure_test_type2)(double, double, double, double, signed short,\n-\t\t\t\t  double, double, int, double, int, int, float,\n-\t\t\t\t  int, float, int, int);\n-\n-static void closure_test_fn3(ffi_cif* cif,void* resp,void** args,\n-\t\t\t     void* userdata)\n- {\n-    *(ffi_arg*)resp =\n-      (int)*(float *)args[0] +(int)(*(float *)args[1]) + \n-      (int)(*(float *)args[2]) + (int)*(float *)args[3] +\n-      (int)(*(float *)args[4]) + (int)(*(float *)args[5]) +\n-      (int)*(float *)args[6] + (int)(*(float *)args[7]) + \n-      (int)(*(double *)args[8]) + (int)*(int *)args[9] +\n-      (int)(*(float *)args[10]) + (int)(*(float *)args[11]) + \n-      (int)*(int *)args[12] + (int)(*(float *)args[13]) +\n-      (int)(*(float *)args[14]) +  *(int *)args[15] + (int)(long)userdata;\n-\n-    printf(\"%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d: %d\\n\",\n-\t   (int)*(float *)args[0], (int)(*(float *)args[1]), \n-\t   (int)(*(float *)args[2]), (int)*(float *)args[3], \n-\t   (int)(*(float *)args[4]), (int)(*(float *)args[5]),\n-\t   (int)*(float *)args[6], (int)(*(float *)args[7]), \n-\t   (int)(*(double *)args[8]), (int)*(int *)args[9], \n-\t   (int)(*(float *)args[10]), (int)(*(float *)args[11]),\n-\t   (int)*(int *)args[12], (int)(*(float *)args[13]), \n-\t   (int)(*(float *)args[14]), *(int *)args[15], (int)(long)userdata,\n-\t   (int)*(ffi_arg *)resp);\n- }\n-\n-typedef int (*closure_test_type3)(float, float, float, float, float, float,\n-\t\t\t\t  float, float, double, int, float, float, int,\n-\t\t\t\t  float, float, int);\n-#endif\n-\n-int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n-{\n-  ffi_cif cif;\n-  ffi_type *args[MAX_ARGS];\n-  void *values[MAX_ARGS];\n-  char *s;\n-  signed char sc;\n-  unsigned char uc;\n-  signed short ss;\n-  unsigned short us;\n-  unsigned long ul;\n-  long long ll;\n-  float f;\n-  double d;\n-  long double ld;\n-  signed int si1;\n-  signed int si2;\n-\n-  ffi_arg rint;\n-  long long rlonglong;\n-\n-# if FFI_CLOSURES\n-  /* The closure must not be an automatic variable on\n-     platforms (Solaris) that forbid stack execution by default. */\n-  static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n-#endif\n-\n-  ffi_type * cl_arg_types[17];\n-\n-  ffi_type ts1_type;\n-  ffi_type ts2_type;\n-  ffi_type ts3_type;\n-  ffi_type ts4_type;  \n-  ffi_type ts5_type;\n-  ffi_type ts6_type;\n-  ffi_type ts7_type;\n-  ffi_type ts8_type;\n-  ffi_type ts9_type;\n-  ffi_type *ts1_type_elements[4];\n-  ffi_type *ts2_type_elements[3];\n-  ffi_type *ts3_type_elements[2];\n-  ffi_type *ts4_type_elements[4];\n-  ffi_type *ts5_type_elements[3];\n-  ffi_type *ts6_type_elements[3];\n-  ffi_type *ts7_type_elements[4];\n-  ffi_type *ts8_type_elements[5];\n-  ffi_type *ts9_type_elements[3];\n-\n-  ts1_type.size = 0;\n-  ts1_type.alignment = 0;\n-  ts1_type.type = FFI_TYPE_STRUCT;\n-\n-  ts2_type.size = 0;\n-  ts2_type.alignment = 0;\n-  ts2_type.type = FFI_TYPE_STRUCT;\n-\n-  ts3_type.size = 0;\n-  ts3_type.alignment = 0;\n-  ts3_type.type = FFI_TYPE_STRUCT;\n-\n-  ts4_type.size = 0;\n-  ts4_type.alignment = 0;\n-  ts4_type.type = FFI_TYPE_STRUCT;\n-\n-  ts5_type.size = 0;\n-  ts5_type.alignment = 0;\n-  ts5_type.type = FFI_TYPE_STRUCT;\n-\n-  ts6_type.size = 0;\n-  ts6_type.alignment = 0;\n-  ts6_type.type = FFI_TYPE_STRUCT;\n-\n-  ts7_type.size = 0;\n-  ts7_type.alignment = 0;\n-  ts7_type.type = FFI_TYPE_STRUCT;\n-\n-  ts8_type.size = 0;\n-  ts8_type.alignment = 0;\n-  ts8_type.type = FFI_TYPE_STRUCT;\n-\n-  ts9_type.size = 0;\n-  ts9_type.alignment = 0;\n-  ts9_type.type = FFI_TYPE_STRUCT;\n-\n-  /*@-immediatetrans@*/\n-  ts1_type.elements = ts1_type_elements;\n-  ts2_type.elements = ts2_type_elements;\n-  ts3_type.elements = ts3_type_elements;\n-  ts4_type.elements = ts4_type_elements;\n-  ts5_type.elements = ts5_type_elements;\n-  ts6_type.elements = ts6_type_elements;\n-  ts7_type.elements = ts7_type_elements;\n-  ts8_type.elements = ts8_type_elements;\n-  ts9_type.elements = ts9_type_elements;\n-  /*@=immediatetrans@*/\n-  \n-  ts1_type_elements[0] = &ffi_type_uchar;\n-  ts1_type_elements[1] = &ffi_type_double;\n-  ts1_type_elements[2] = &ffi_type_uint;\n-  ts1_type_elements[3] = NULL;\n-  \n-  ts2_type_elements[0] = &ffi_type_double;\n-  ts2_type_elements[1] = &ffi_type_double;\n-  ts2_type_elements[2] = NULL;\n-\n-  ts3_type_elements[0] = &ffi_type_sint;\n-  ts3_type_elements[1] = NULL;\n-\n-  ts4_type_elements[0] = &ffi_type_uint;\n-  ts4_type_elements[1] = &ffi_type_uint;\n-  ts4_type_elements[2] = &ffi_type_uint;\n-  ts4_type_elements[3] = NULL;\n-\n-  ts5_type_elements[0] = &ffi_type_schar;\n-  ts5_type_elements[1] = &ffi_type_schar;\n-  ts5_type_elements[2] = NULL;\n-\n-  ts6_type_elements[0] = &ffi_type_float;\n-  ts6_type_elements[1] = &ffi_type_double;\n-  ts6_type_elements[2] = NULL;\n-\n-  ts7_type_elements[0] = &ffi_type_float;\n-  ts7_type_elements[1] = &ffi_type_float;\n-  ts7_type_elements[2] = &ffi_type_double;\n-  ts7_type_elements[3] = NULL;\n-\n-  ts8_type_elements[0] = &ffi_type_float;\n-  ts8_type_elements[1] = &ffi_type_float;\n-  ts8_type_elements[2] = &ffi_type_float;\n-  ts8_type_elements[3] = &ffi_type_float;\n-  ts8_type_elements[4] = NULL;\n-\n-  ts9_type_elements[0] = &ffi_type_float;\n-  ts9_type_elements[1] = &ffi_type_sint;\n-  ts9_type_elements[2] = NULL;\n-\n-  ul = 0;\n-\n-  /* return value tests */\n-  {\n-#if defined(MIPS) /* || defined(ARM) */\n-    puts (\"long long tests not run. This is a known bug on this architecture.\");\n-#else\n-    args[0] = &ffi_type_sint64;\n-    values[0] = &ll;\n-    \n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n-\t\t       &ffi_type_sint64, args) == FFI_OK);\n-\n-    for (ll = 0LL; ll < 100LL; ll++)\n-      {\n-\tul++;\n-\tffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);\n-\tCHECK(rlonglong == ll);\n-      }\n-\n-    for (ll = 55555555555000LL; ll < 55555555555100LL; ll++)\n-      {\n-\tul++;\n-\tffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);\n-\tCHECK(rlonglong == ll);\n-      }\n-#endif\n-\n-    args[0] = &ffi_type_schar;\n-    values[0] = &sc;\n-    \n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n-\t\t       &ffi_type_schar, args) == FFI_OK);\n-\n-    for (sc = (signed char) -127; \n-\t sc < (signed char) 127; /*@-type@*/ sc++ /*@=type@*/)\n-      {\n-\tul++;\n-\tffi_call(&cif, FFI_FN(return_sc), &rint, values);\n-\tCHECK(rint == (ffi_arg) sc);\n-      }\n-\n-    args[0] = &ffi_type_uchar;\n-    values[0] = &uc;\n-    \n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n-\t\t       &ffi_type_uchar, args) == FFI_OK);\n-\n-    for (uc = (unsigned char) '\\x00'; \n-\t uc < (unsigned char) '\\xff'; /*@-type@*/ uc++ /*@=type@*/)\n-      {\n-\tul++;\n-\tffi_call(&cif, FFI_FN(return_uc), &rint, values);\n-\tCHECK(rint == (signed int) uc);\n-      }\n-\n-    printf(\"%lu return value tests run\\n\", ul);\n-  }\n-\n-#ifdef BROKEN_LONG_DOUBLE\n-  printf (\"This architecture has broken `long double' support. No floating point\\ntests have been run.\\n\");\n-#else\n-  /* float arg tests */\n-  {\n-    args[0] = &ffi_type_float;\n-    values[0] = &f;\n-\n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n-\t\t       &ffi_type_longdouble, args) == FFI_OK);\n-\n-    f = 3.14159;\n-\n-#if 0\n-  /* This is ifdef'd out for now. long double support under SunOS/gcc\n-     is pretty much non-existent.  You'll get the odd bus error in library\n-     routines like printf().  */\n-    printf (\"%Lf\\n\", ldblit(f));\n-#endif\n-    ld = 666;\n-    ffi_call(&cif, FFI_FN(ldblit), &ld, values);\n-\n-#if 0\n-  /* This is ifdef'd out for now. long double support under SunOS/gcc\n-     is pretty much non-existent.  You'll get the odd bus error in library\n-     routines like printf().  */\n-    printf (\"%Lf, %Lf, %Lf, %Lf\\n\", ld, ldblit(f), ld - ldblit(f), LDBL_EPSILON);\n-#endif\n-\n-    /* These are not always the same!! Check for a reasonable delta */\n-    /*@-realcompare@*/\n-    if (ld - ldblit(f) < LDBL_EPSILON)\n-    /*@=realcompare@*/\n-\tputs(\"long double return value tests ok!\");\n-    else\n-        CHECK(0);\n-  }\n-\n-  /* float arg tests */\n-  {\n-    args[0] = &ffi_type_sint;\n-    values[0] = &si1;\n-    args[1] = &ffi_type_float;\n-    values[1] = &f;\n-    args[2] = &ffi_type_double;\n-    values[2] = &d;\n-    args[3] = &ffi_type_longdouble;\n-    values[3] = &ld;\n-    args[4] = &ffi_type_sint;\n-    values[4] = &si2;\n-    \n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 5,\n-\t\t       &ffi_type_sint, args) == FFI_OK);\n-\n-    si1 = 6;\n-    f = 3.14159;\n-    d = (double)1.0/(double)3.0;\n-    ld = 2.71828182846L;\n-    si2 = 10;\n-\n-    floating (si1, f, d, ld, si2);\n-\n-    ffi_call(&cif, FFI_FN(floating), &rint, values);\n-\n-    printf (\"%d vs %d\\n\", (int)rint, floating (si1, f, d, ld, si2));\n-\n-    CHECK(rint == floating(si1, f, d, ld, si2));\n-\n-    printf(\"float arg tests ok!\\n\");\n-  }\n-#endif\n-\n-  /* strlen tests */\n-  {\n-    args[0] = &ffi_type_pointer;\n-    values[0] = (void*) &s;\n-    \n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n-\t\t       &ffi_type_sint, args) == FFI_OK);\n-\n-    s = \"a\";\n-    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);\n-    CHECK(rint == 1);\n-\n-    s = \"1234567\";\n-    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);\n-    CHECK(rint == 7);\n-\n-    s = \"1234567890123456789012345\";\n-    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);\n-    CHECK(rint == 25);\n-\n-    printf(\"strlen tests passed\\n\");\n-  }\n-\n-  /* float arg tests */\n-  {\n-    args[0] = &ffi_type_float;\n-    values[0] = &f;\n-    \n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n-\t\t       &ffi_type_double, args) == FFI_OK);\n-\n-    f = 3.14159;\n-\n-    ffi_call(&cif, FFI_FN(dblit), &d, values);\n-\n-    /* These are not always the same!! Check for a reasonable delta */\n-    /*@-realcompare@*/\n-    CHECK(d - dblit(f) < DBL_EPSILON);\n-    /*@=realcompare@*/\n-\n-    printf(\"double return value tests ok!\\n\");\n-  }\n-\n-  /* many arg tests */\n-  {\n-    float ff;\n-    float fa[13];\n-    \n-    for (ul = 0; ul < 13; ul++)\n-      {\n-\targs[ul] = &ffi_type_float;\n-\tvalues[ul] = &fa[ul];\n-\tfa[ul] = (float) ul;\n-      }\n-\n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 13, \n-\t\t       &ffi_type_float, args) == FFI_OK);\n-\n-    /*@-usedef@*/\n-    ff = many (fa[0], fa[1],\n-\t       fa[2], fa[3],\n-\t       fa[4], fa[5],\n-\t       fa[6], fa[7],\n-\t       fa[8], fa[9],\n-\t       fa[10],fa[11],fa[12]);\n-    /*@=usedef@*/\n-\n-    ffi_call(&cif, FFI_FN(many), &f, values);\n-\n-    /*@-realcompare@*/\n-    if (f - ff < FLT_EPSILON)\n-    /*@=realcompare@*/\n-\tprintf(\"many arg tests ok!\\n\");\n-    else\n-#ifdef POWERPC\n-\tprintf(\"many arg tests failed!  This is a gcc bug.\\n\");\n-#else\n-        CHECK(0);\n-#endif\n-  }\n-\n-  /* promotion tests */\n-  {\n-    args[0] = &ffi_type_schar;\n-    args[1] = &ffi_type_sshort;\n-    args[2] = &ffi_type_uchar;\n-    args[3] = &ffi_type_ushort;\n-    values[0] = &sc;\n-    values[1] = &ss;\n-    values[2] = &uc;\n-    values[3] = &us;\n-    \n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, \n-\t\t       &ffi_type_sint, args) == FFI_OK);\n-\n-    us = 0;\n-    ul = 0;\n-\n-    for (sc = (signed char) -127; \n-\t sc <= (signed char) 120; /*@-type@*/ sc += 1 /*@=type@*/)\n-      for (ss = -30000; ss <= 30000; ss += 10000)\n-\tfor (uc = (unsigned char) 0; \n-\t     uc <= (unsigned char) 200; /*@-type@*/ uc += 20 /*@=type@*/)\n-\t  for (us = 0; us <= 60000; us += 10000)\n-\t    {\n-\t      ul++;\n-\t      ffi_call(&cif, FFI_FN(promotion), &rint, values);\n-\t      CHECK((int)rint == (signed char) sc + (signed short) ss +\n-\t\t    (unsigned char) uc + (unsigned short) us);\n-\t    }\n-    printf(\"%lu promotion tests run\\n\", ul);\n-  }\n-\n-#ifndef X86_WIN32 /* Structures dont work on Win32 */\n-\n-  /* struct tests */\n-  {\n-    test_structure_1 ts1_arg;\n-    /* This is a hack to get a properly aligned result buffer */\n-    test_structure_1 *ts1_result = \n-      (test_structure_1 *) malloc (sizeof(test_structure_1));\n-\n-    args[0] = &ts1_type;\n-    values[0] = &ts1_arg;\n-    \n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n-\t\t       &ts1_type, args) == FFI_OK);\n-\n-    ts1_arg.uc = '\\x01';\n-    ts1_arg.d = 3.14159;\n-    ts1_arg.ui = 555;\n-\n-    ffi_call(&cif, FFI_FN(struct1), ts1_result, values);\n-\n-    CHECK(ts1_result->ui == 556);\n-    CHECK(ts1_result->d == 3.14159 - 1);\n-\n-    puts (\"structure test 1 ok!\\n\");\n-\n-    free (ts1_result);\n-  }\n-\n-  /* struct tests */\n-  {\n-    test_structure_2 ts2_arg;\n-\n-    /* This is a hack to get a properly aligned result buffer */\n-    test_structure_2 *ts2_result = \n-      (test_structure_2 *) malloc (sizeof(test_structure_2));\n-\n-    args[0] = &ts2_type;\n-    values[0] = &ts2_arg;\n-    \n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts2_type, args) == FFI_OK);\n-\n-    ts2_arg.d1 = 5.55;\n-    ts2_arg.d2 = 6.66;\n-\n-    printf (\"%g\\n\", ts2_arg.d1);\n-    printf (\"%g\\n\", ts2_arg.d2);\n-\n-    ffi_call(&cif, FFI_FN(struct2), ts2_result, values);\n-\n-    printf (\"%g\\n\", ts2_result->d1);\n-    printf (\"%g\\n\", ts2_result->d2);\n-    \n-    CHECK(ts2_result->d1 == 5.55 - 1);\n-    CHECK(ts2_result->d2 == 6.66 - 1);\n-\n-    printf(\"structure test 2 ok!\\n\");\n-\n-    free (ts2_result);\n-  }\n-\n-  /* struct tests */\n-  {\n-    int compare_value;\n-    test_structure_3 ts3_arg;\n-    test_structure_3 *ts3_result = \n-      (test_structure_3 *) malloc (sizeof(test_structure_3));\n-\n-    args[0] = &ts3_type;\n-    values[0] = &ts3_arg;\n-    \n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n-\t\t       &ts3_type, args) == FFI_OK);\n-\n-    ts3_arg.si = -123;\n-    compare_value = ts3_arg.si;\n-\n-    ffi_call(&cif, FFI_FN(struct3), ts3_result, values);\n-\n-    printf (\"%d %d\\n\", ts3_result->si, -(compare_value*2));\n-\n-    if (ts3_result->si == -(ts3_arg.si*2))\n-\tputs (\"structure test 3 ok!\");\n-    else\n-      {\n-\tputs (\"Structure test 3 found structure passing bug.\");\n-\tputs (\"  Current versions of GCC are not 100% compliant with the\");\n-\tputs (\"  n32 ABI.  There is a known problem related to passing\");\n-\tputs (\"  small structures.  Send a bug report to the gcc maintainers.\");\n-      }\n-\n-    free (ts3_result);\n-  }\n-\n-  /* struct tests */\n-  {\n-    test_structure_4 ts4_arg;\n-\n-    /* This is a hack to get a properly aligned result buffer */\n-    test_structure_4 *ts4_result = \n-      (test_structure_4 *) malloc (sizeof(test_structure_4));\n-\n-    args[0] = &ts4_type;\n-    values[0] = &ts4_arg;\n-    \n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts4_type, args) == FFI_OK);\n-\n-    ts4_arg.ui1 = 2;\n-    ts4_arg.ui2 = 3;\n-    ts4_arg.ui3 = 4;\n-\n-    ffi_call (&cif, FFI_FN(struct4), ts4_result, values);\n-    \n-    if (ts4_result->ui3 == 2U * 3U * 4U)\n-      puts (\"structure test 4 ok!\");\n-    else\n-      puts (\"Structure test 4 found GCC's structure passing bug.\");\n-\n-    free (ts4_result);\n-  }\n-\n-  /* struct tests */\n-  {\n-    test_structure_5 ts5_arg1, ts5_arg2;\n-\n-    /* This is a hack to get a properly aligned result buffer */\n-    test_structure_5 *ts5_result = \n-      (test_structure_5 *) malloc (sizeof(test_structure_5));\n-\n-    args[0] = &ts5_type;\n-    args[1] = &ts5_type;\n-    values[0] = &ts5_arg1;\n-    values[1] = &ts5_arg2;\n-    \n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &ts5_type, args) == FFI_OK);\n-\n-    ts5_arg1.c1 = 2;\n-    ts5_arg1.c2 = 6;\n-    ts5_arg2.c1 = 5;\n-    ts5_arg2.c2 = 3;\n-\n-    ffi_call (&cif, FFI_FN(struct5), ts5_result, values);\n-    \n-    if (ts5_result->c1 == 7 \n-\t&& ts5_result->c2 == 3)\n-      puts (\"structure test 5 ok!\");\n-    else\n-      puts (\"Structure test 5 found GCC's structure passing bug.\");\n-\n-    free (ts5_result);\n-  }\n-\n-  /* struct tests */\n-  {\n-    test_structure_6 ts6_arg;\n-\n-    /* This is a hack to get a properly aligned result buffer */\n-    test_structure_6 *ts6_result = \n-      (test_structure_6 *) malloc (sizeof(test_structure_6));\n-\n-    args[0] = &ts6_type;\n-    values[0] = &ts6_arg;\n-\n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts6_type, args) == FFI_OK);\n-\n-    ts6_arg.f = 5.55f;\n-    ts6_arg.d = 6.66;\n-\n-    printf (\"%g\\n\", ts6_arg.f);\n-    printf (\"%g\\n\", ts6_arg.d);\n-\n-    ffi_call(&cif, FFI_FN(struct6), ts6_result, values);\n-\n-    printf (\"%g\\n\", ts6_result->f);\n-    printf (\"%g\\n\", ts6_result->d);\n-\n-    CHECK(ts6_result->f == 5.55f + 1);\n-    CHECK(ts6_result->d == 6.66 + 1);\n-\n-    printf(\"structure test 6 ok!\\n\");\n-\n-    free (ts6_result);\n-  }\n-\n-  /* struct tests */\n-  {\n-    test_structure_7 ts7_arg;\n-\n-    /* This is a hack to get a properly aligned result buffer */\n-    test_structure_7 *ts7_result = \n-      (test_structure_7 *) malloc (sizeof(test_structure_7));\n-\n-    args[0] = &ts7_type;\n-    values[0] = &ts7_arg;\n-\n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts7_type, args) == FFI_OK);\n-\n-    ts7_arg.f1 = 5.55f;\n-    ts7_arg.f2 = 55.5f;\n-    ts7_arg.d = 6.66;\n-\n-    printf (\"%g\\n\", ts7_arg.f1);\n-    printf (\"%g\\n\", ts7_arg.f2);\n-    printf (\"%g\\n\", ts7_arg.d);\n-\n-    ffi_call(&cif, FFI_FN(struct7), ts7_result, values);\n-\n-    printf (\"%g\\n\", ts7_result->f1);\n-    printf (\"%g\\n\", ts7_result->f2);\n-    printf (\"%g\\n\", ts7_result->d);\n-\n-    CHECK(ts7_result->f1 == 5.55f + 1);\n-    CHECK(ts7_result->f2 == 55.5f + 1);\n-    CHECK(ts7_result->d == 6.66 + 1);\n-\n-    printf(\"structure test 7 ok!\\n\");\n-\n-    free (ts7_result);\n-  }\n-\n-  /* struct tests */\n-  {\n-    test_structure_8 ts8_arg;\n-\n-    /* This is a hack to get a properly aligned result buffer */\n-    test_structure_8 *ts8_result = \n-      (test_structure_8 *) malloc (sizeof(test_structure_8));\n-\n-    args[0] = &ts8_type;\n-    values[0] = &ts8_arg;\n-\n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts8_type, args) == FFI_OK);\n-\n-    ts8_arg.f1 = 5.55f;\n-    ts8_arg.f2 = 55.5f;\n-    ts8_arg.f3 = -5.55f;\n-    ts8_arg.f4 = -55.5f;\n-\n-    printf (\"%g\\n\", ts8_arg.f1);\n-    printf (\"%g\\n\", ts8_arg.f2);\n-    printf (\"%g\\n\", ts8_arg.f3);\n-    printf (\"%g\\n\", ts8_arg.f4);\n-\n-    ffi_call(&cif, FFI_FN(struct8), ts8_result, values);\n-\n-    printf (\"%g\\n\", ts8_result->f1);\n-    printf (\"%g\\n\", ts8_result->f2);\n-    printf (\"%g\\n\", ts8_result->f3);\n-    printf (\"%g\\n\", ts8_result->f4);\n-\n-    CHECK(ts8_result->f1 == 5.55f + 1);\n-    CHECK(ts8_result->f2 == 55.5f + 1);\n-    CHECK(ts8_result->f3 == -5.55f + 1);\n-    CHECK(ts8_result->f4 == -55.5f + 1);\n-\n-    printf(\"structure test 8 ok!\\n\");\n-\n-    free (ts8_result);\n-  }\n-\n-  /* struct tests */\n-  {\n-    test_structure_9 ts9_arg;\n-\n-    /* This is a hack to get a properly aligned result buffer */\n-    test_structure_9 *ts9_result = \n-      (test_structure_9 *) malloc (sizeof(test_structure_9));\n-\n-    args[0] = &ts9_type;\n-    values[0] = &ts9_arg;\n-\n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, &ts9_type, args) == FFI_OK);\n-\n-    ts9_arg.f = 5.55f;\n-    ts9_arg.i = 5;\n-\n-    printf (\"%g\\n\", ts9_arg.f);\n-    printf (\"%d\\n\", ts9_arg.i);\n-\n-    ffi_call(&cif, FFI_FN(struct9), ts9_result, values);\n-\n-    printf (\"%g\\n\", ts9_result->f);\n-    printf (\"%d\\n\", ts9_result->i);\n-\n-    CHECK(ts9_result->f == 5.55f + 1);\n-    CHECK(ts9_result->i == 5 + 1);\n-\n-    printf(\"structure test 9 ok!\\n\");\n-\n-    free (ts9_result);\n-  }\n-\n-#else\n-  printf(\"Structure passing doesn't work on Win32.\\n\");\n-#endif /* X86_WIN32 */\n-\n-#ifdef X86_WIN32\n-  /* stdcall strlen tests */\n-  {\n-    args[0] = &ffi_type_pointer;\n-    values[0] = (void*) &s;\n-\n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_STDCALL, 1,\n-\t\t       &ffi_type_sint, args) == FFI_OK);\n-\n-    s = \"a\";\n-    ffi_call(&cif, FFI_FN(my_stdcall_strlen), &rint, values);\n-    CHECK(rint == 1);\n-\n-    s = \"1234567\";\n-    ffi_call(&cif, FFI_FN(my_stdcall_strlen), &rint, values);\n-    CHECK(rint == 7);\n-\n-    s = \"1234567890123456789012345\";\n-    ffi_call(&cif, FFI_FN(my_stdcall_strlen), &rint, values);\n-    CHECK(rint == 25);\n-\n-    printf(\"stdcall strlen tests passed\\n\");\n-  }\n-\n-  /* stdcall many arg tests */\n-  {\n-    float ff;\n-    float fa[13];\n-\n-    for (ul = 0; ul < 13; ul++)\n-      {\n-\targs[ul] = &ffi_type_float;\n-\tvalues[ul] = &fa[ul];\n-\tfa[ul] = (float) ul;\n-      }\n-\n-    /* Initialize the cif */\n-    CHECK(ffi_prep_cif(&cif, FFI_STDCALL, 13,\n-\t\t       &ffi_type_float, args) == FFI_OK);\n-\n-    /*@-usedef@*/\n-    ff =  stdcall_many(fa[0], fa[1],\n-\t       fa[2], fa[3],\n-\t       fa[4], fa[5],\n-\t       fa[6], fa[7],\n-\t       fa[8], fa[9],\n-\t       fa[10],fa[11],fa[12]);\n-    /*@=usedef@*/\n-\n-    ffi_call(&cif, FFI_FN(stdcall_many), &f, values);\n-\n-    /*@-realcompare@*/\n-    if (f - ff < FLT_EPSILON)\n-    /*@=realcompare@*/\n-\tprintf(\"stdcall many arg tests ok!\\n\");\n-    else\n-        CHECK(0);\n-  }\n-#endif /* X86_WIN32 */\n-\n-# if FFI_CLOSURES\n-#  if __GNUC__ >= 2\n-   /* Hide before the compiler that pcl is &cl, since on\n-      some architectures it is not possible to call a data\n-      object using direct function call.  */\n-   asm (\"\" : \"=g\" (pcl) : \"0\" (pcl));\n-#  endif\n-\n-  /* A simple closure test */\n-    {\n-      (void) puts(\"\\nEnter FFI_CLOSURES\\n\");\n-\n-      cl_arg_types[0] = &ffi_type_uint64;\n-      cl_arg_types[1] = &ffi_type_uint;\n-      cl_arg_types[2] = &ffi_type_uint64;\n-      cl_arg_types[3] = &ffi_type_uint;\n-      cl_arg_types[4] = &ffi_type_sshort;\n-      cl_arg_types[5] = &ffi_type_uint64;\n-      cl_arg_types[6] = &ffi_type_uint;\n-      cl_arg_types[7] = &ffi_type_uint;\n-      cl_arg_types[8] = &ffi_type_double;\n-      cl_arg_types[9] = &ffi_type_uint;\n-      cl_arg_types[10] = &ffi_type_uint;\n-      cl_arg_types[11] = &ffi_type_float;\n-      cl_arg_types[12] = &ffi_type_uint;\n-      cl_arg_types[13] = &ffi_type_uint;\n-      cl_arg_types[14] = &ffi_type_uint;\n-      cl_arg_types[15] = &ffi_type_uint;\n-      cl_arg_types[16] = NULL;   \n-\n-      /* Initialize the cif */\n-      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n-\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n-\n-      CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn,\n-\t\t\t     (void *) 3 /* userdata */) == FFI_OK);\n-      \n-      CHECK((*((closure_test_type)pcl))\n-\t    (1LL, 2, 3LL, 4, 127, 429LL, 7, 8, 9.5, 10, 11, 12, 13, \n-\t     19, 21, 1) == 680);\n-    }\n-\n-    {\n-\n-      cl_arg_types[0] = &ffi_type_float;\n-      cl_arg_types[1] = &ffi_type_float;\n-      cl_arg_types[2] = &ffi_type_float;\n-      cl_arg_types[3] = &ffi_type_float;\n-      cl_arg_types[4] = &ffi_type_sshort;\n-      cl_arg_types[5] = &ffi_type_float;\n-      cl_arg_types[6] = &ffi_type_float;\n-      cl_arg_types[7] = &ffi_type_uint;\n-      cl_arg_types[8] = &ffi_type_double;\n-      cl_arg_types[9] = &ffi_type_uint;\n-      cl_arg_types[10] = &ffi_type_uint;\n-      cl_arg_types[11] = &ffi_type_float;\n-      cl_arg_types[12] = &ffi_type_uint;\n-      cl_arg_types[13] = &ffi_type_uint;\n-      cl_arg_types[14] = &ffi_type_uint;\n-      cl_arg_types[15] = &ffi_type_uint;\n-      cl_arg_types[16] = NULL;\n-      \n-      /* Initialize the cif */\n-      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n-\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n-\n-      CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn1,\n-\t\t\t     (void *) 3 /* userdata */)  == FFI_OK);\n-      \n-      CHECK((*((closure_test_type1)pcl))\n-\t    (1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,\n-\t     19, 21, 1) == 255);\n-    }\n-\n-    {\n-\n-      cl_arg_types[0] = &ffi_type_double;\n-      cl_arg_types[1] = &ffi_type_double;\n-      cl_arg_types[2] = &ffi_type_double;\n-      cl_arg_types[3] = &ffi_type_double;\n-      cl_arg_types[4] = &ffi_type_sshort;\n-      cl_arg_types[5] = &ffi_type_double;\n-      cl_arg_types[6] = &ffi_type_double;\n-      cl_arg_types[7] = &ffi_type_uint;\n-      cl_arg_types[8] = &ffi_type_double;\n-      cl_arg_types[9] = &ffi_type_uint;\n-      cl_arg_types[10] = &ffi_type_uint;\n-      cl_arg_types[11] = &ffi_type_float;\n-      cl_arg_types[12] = &ffi_type_uint;\n-      cl_arg_types[13] = &ffi_type_float;\n-      cl_arg_types[14] = &ffi_type_uint;\n-      cl_arg_types[15] = &ffi_type_uint;\n-      cl_arg_types[16] = NULL;\n-      \n-      /* Initialize the cif */\n-      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n-\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n-\n-      CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn2,\n-\t\t\t     (void *) 3 /* userdata */) == FFI_OK);\n-\n-      CHECK((*((closure_test_type2)pcl))\n-\t    (1, 2, 3, 4, 127, 5, 6, 8, 9, 10, 11, 12.0, 13,\n-\t     19.0, 21, 1) == 255);\n-\n-    }\n-\n-    {\n-\n-      cl_arg_types[0] = &ffi_type_float;\n-      cl_arg_types[1] = &ffi_type_float;\n-      cl_arg_types[2] = &ffi_type_float;\n-      cl_arg_types[3] = &ffi_type_float;\n-      cl_arg_types[4] = &ffi_type_float;\n-      cl_arg_types[5] = &ffi_type_float;\n-      cl_arg_types[6] = &ffi_type_float;\n-      cl_arg_types[7] = &ffi_type_float;\n-      cl_arg_types[8] = &ffi_type_double;\n-      cl_arg_types[9] = &ffi_type_uint;\n-      cl_arg_types[10] = &ffi_type_float;\n-      cl_arg_types[11] = &ffi_type_float;\n-      cl_arg_types[12] = &ffi_type_uint;\n-      cl_arg_types[13] = &ffi_type_float;\n-      cl_arg_types[14] = &ffi_type_float;\n-      cl_arg_types[15] = &ffi_type_uint;\n-      cl_arg_types[16] = NULL;\n-      \n-      /* Initialize the cif */\n-      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,\n-\t\t\t &ffi_type_sint, cl_arg_types) == FFI_OK);\n-\n-      CHECK(ffi_prep_closure(pcl, &cif, closure_test_fn3,\n-\t\t\t     (void *) 3 /* userdata */)  == FFI_OK);\n-      \n-      CHECK((*((closure_test_type3)pcl))\n-\t    (1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9, 10, 11.11, 12.0, 13,\n-\t     19.19, 21.21, 1) == 135);\n-    }\n-\n-    (void) puts(\"\\nFinished FFI_CLOSURES\\n\");\n-\n-# endif\n-\n-  /* If we arrived here, all is good */\n-  (void) puts(\"\\nLooks good. No surprises.\\n\");\n-\n-  /*@-compdestroy@*/\n-\n-  return 0;\n-}\n-"}, {"sha": "5f15a05c336151a52d2281650a469aa491944f7a", "filename": "libffi/src/java_raw_api.c", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fjava_raw_api.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fjava_raw_api.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fjava_raw_api.c?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -29,10 +29,10 @@\n    ----------------------------------------------------------------------- */\n \n /* This defines a Java- and 64-bit specific variant of the raw API.\t*/\n-/* It assumes that \"raw\" argument blocks look like Java stacks on a \t*/\n+/* It assumes that \"raw\" argument blocks look like Java stacks on a\t*/\n /* 64-bit machine.  Arguments that can be stored in a single stack\t*/\n /* stack slots (longs, doubles) occupy 128 bits, but only the first\t*/\n-/* 64 bits are actually used.  \t\t\t\t\t\t*/\n+/* 64 bits are actually used.\t\t\t\t\t\t*/\n \n #include <ffi.h>\n #include <ffi_common.h>\n@@ -77,20 +77,20 @@ ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)\n #if WORDS_BIGENDIAN\n \n   for (i = 0; i < cif->nargs; i++, tp++, args++)\n-    {\t  \n+    {\n       switch ((*tp)->type)\n \t{\n \tcase FFI_TYPE_UINT8:\n \tcase FFI_TYPE_SINT8:\n \t  *args = (void*) ((char*)(raw++) + 3);\n \t  break;\n-\t  \n+\n \tcase FFI_TYPE_UINT16:\n \tcase FFI_TYPE_SINT16:\n \t  *args = (void*) ((char*)(raw++) + 2);\n \t  break;\n \n-#if FFI_SIZEOF_ARG == 8\t  \n+#if FFI_SIZEOF_ARG == 8\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_DOUBLE:\n@@ -102,7 +102,7 @@ ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)\n \tcase FFI_TYPE_POINTER:\n \t  *args = (void*) &(raw++)->ptr;\n \t  break;\n-\t  \n+\n \tdefault:\n \t  *args = raw;\n \t  raw += ALIGN ((*tp)->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n@@ -147,7 +147,7 @@ ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw)\n   ffi_type **tp = cif->arg_types;\n \n   for (i = 0; i < cif->nargs; i++, tp++, args++)\n-    {\t  \n+    {\n       switch ((*tp)->type)\n \t{\n \tcase FFI_TYPE_UINT8:\n@@ -218,7 +218,7 @@ ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw)\n \tdefault:\n #if FFI_SIZEOF_ARG == 8\n \t  FFI_ASSERT(0);\t/* Should have covered all cases */\n-#else\t\n+#else\n \t  memcpy ((void*) raw->data, (void*)*args, (*tp)->size);\n \t  raw += ALIGN ((*tp)->size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;\n #endif\n@@ -285,10 +285,7 @@ ffi_java_raw_to_rvalue (ffi_cif *cif, void *rvalue)\n  * these following couple of functions will handle the translation forth\n  * and back automatically. */\n \n-void ffi_java_raw_call (/*@dependent@*/ ffi_cif *cif, \n-\t\t   void (*fn)(), \n-\t\t   /*@out@*/ void *rvalue, \n-\t\t   /*@dependent@*/ ffi_raw *raw)\n+void ffi_java_raw_call (ffi_cif *cif, void (*fn)(), void *rvalue, ffi_raw *raw)\n {\n   void **avalue = (void**) alloca (cif->nargs * sizeof (void*));\n   ffi_java_raw_to_ptrarray (cif, raw, avalue);\n@@ -298,7 +295,7 @@ void ffi_java_raw_call (/*@dependent@*/ ffi_cif *cif,\n \n #if FFI_CLOSURES\t\t/* base system provides closures */\n \n-static void \n+static void\n ffi_java_translate_args (ffi_cif *cif, void *rvalue,\n \t\t    void **avalue, void *user_data)\n {\n@@ -322,7 +319,7 @@ ffi_prep_java_raw_closure (ffi_raw_closure* cl,\n {\n   ffi_status status;\n \n-  status = ffi_prep_closure ((ffi_closure*) cl, \n+  status = ffi_prep_closure ((ffi_closure*) cl,\n \t\t\t     cif,\n \t\t\t     &ffi_java_translate_args,\n \t\t\t     (void*)cl);"}, {"sha": "c3e8204e84bf4f3831bbb71805dcc663c7abd900", "filename": "libffi/src/m32r/ffi.c", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fm32r%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fm32r%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm32r%2Fffi.c?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -31,9 +31,7 @@\n /* ffi_prep_args is called by the assembly routine once stack\n    space has been allocated for the function's arguments.  */\n \n-/*@-exportheader@*/\n void ffi_prep_args(char *stack, extended_cif *ecif)\n-/*@=exportheader@*/\n {\n   unsigned int i;\n   int tmp;\n@@ -173,20 +171,10 @@ ffi_prep_cif_machdep(ffi_cif *cif)\n   return FFI_OK;\n }\n \n-/*@-declundef@*/\n-/*@-exportheader@*/\n-extern void ffi_call_SYSV(void (*)(char *, extended_cif *), \n-\t\t\t  /*@out@*/ extended_cif *, \n-\t\t\t  unsigned, unsigned, \n-\t\t\t  /*@out@*/ unsigned *, \n-\t\t\t  void (*fn)());\n-/*@=declundef@*/\n-/*@=exportheader@*/\n-\n-void ffi_call(/*@dependent@*/ ffi_cif *cif, \n-\t      void (*fn)(), \n-\t      /*@out@*/ void *rvalue, \n-\t      /*@dependent@*/ void **avalue)\n+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,\n+\t\t\t  unsigned, unsigned, unsigned *, void (*fn)());\n+\n+void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n {\n   extended_cif ecif;\n \n@@ -198,17 +186,14 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n   if ((rvalue == NULL) && \n       (cif->rtype->type == FFI_TYPE_STRUCT))\n     {\n-      /*@-sysunrecog@*/\n       ecif.rvalue = alloca (cif->rtype->size);\n-      /*@=sysunrecog@*/\n     }\n   else\n     ecif.rvalue = rvalue;    \n   \n   switch (cif->abi) \n     {\n     case FFI_SYSV:\n-      /*@-usedef@*/\n       ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, \n \t\t    cif->flags, ecif.rvalue, fn);\n       if (cif->rtype->type == FFI_TYPE_STRUCT)\n@@ -237,7 +222,6 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n \t\t}\n \t    }\n \t}\n-      /*@=usedef@*/\n       break;\n \n     default:"}, {"sha": "92cc7f29a1fbe3e9be921b26abfd2312694c7c8f", "filename": "libffi/src/pa/ffi.c", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fpa%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fpa%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fffi.c?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -135,9 +135,7 @@ static inline int ffi_struct_type(ffi_type *t)\n    NOTE: We load floating point args in this function... that means we\n    assume gcc will not mess with fp regs in here.  */\n \n-/*@-exportheader@*/\n void ffi_prep_args_pa32(UINT32 *stack, extended_cif *ecif, unsigned bytes)\n-/*@=exportheader@*/\n {\n   register unsigned int i;\n   register ffi_type **p_arg;\n@@ -367,20 +365,11 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   return FFI_OK;\n }\n \n-/*@-declundef@*/\n-/*@-exportheader@*/\n extern void ffi_call_pa32(void (*)(UINT32 *, extended_cif *, unsigned),\n-\t\t\t   /*@out@*/ extended_cif *,\n-\t\t\t   unsigned, unsigned,\n-\t\t\t   /*@out@*/ unsigned *,\n-\t\t\t   void (*fn)());\n-/*@=declundef@*/\n-/*@=exportheader@*/\n-\n-void ffi_call(/*@dependent@*/ ffi_cif *cif,\n-\t      void (*fn)(),\n-\t      /*@out@*/ void *rvalue,\n-\t      /*@dependent@*/ void **avalue)\n+\t\t\t  extended_cif *, unsigned, unsigned, unsigned *,\n+\t\t\t  void (*fn)());\n+\n+void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n {\n   extended_cif ecif;\n \n@@ -398,9 +387,7 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n       && cif->rtype->type == FFI_TYPE_STRUCT)\n #endif\n     {\n-      /*@-sysunrecog@*/\n       ecif.rvalue = alloca(cif->rtype->size);\n-      /*@=sysunrecog@*/\n     }\n   else\n     ecif.rvalue = rvalue;\n@@ -409,11 +396,9 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n   switch (cif->abi)\n     {\n     case FFI_PA32:\n-      /*@-usedef@*/\n       debug(3, \"Calling ffi_call_pa32: ecif=%p, bytes=%u, flags=%u, rvalue=%p, fn=%p\\n\", &ecif, cif->bytes, cif->flags, ecif.rvalue, (void *)fn);\n       ffi_call_pa32(ffi_prep_args_pa32, &ecif, cif->bytes,\n \t\t     cif->flags, ecif.rvalue, fn);\n-      /*@=usedef@*/\n       break;\n \n     default:"}, {"sha": "57504a02f9396a40d5a462a0c29dc9f1d337837d", "filename": "libffi/src/powerpc/ffi.c", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi.c?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -80,10 +80,8 @@ enum { ASM_NEEDS_REGISTERS = 4 };\n \n */\n \n-/*@-exportheader@*/\n void\n ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n-/*@=exportheader@*/\n {\n   const unsigned bytes = ecif->cif->bytes;\n   const unsigned flags = ecif->cif->flags;\n@@ -354,10 +352,8 @@ enum { ASM_NEEDS_REGISTERS64 = 4 };\n \n */\n \n-/*@-exportheader@*/\n void FFI_HIDDEN\n ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n-/*@=exportheader@*/\n {\n   const unsigned long bytes = ecif->cif->bytes;\n   const unsigned long flags = ecif->cif->flags;\n@@ -789,24 +785,14 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n   return FFI_OK;\n }\n \n-/*@-declundef@*/\n-/*@-exportheader@*/\n-extern void ffi_call_SYSV(/*@out@*/ extended_cif *,\n-\t\t\t  unsigned, unsigned,\n-\t\t\t  /*@out@*/ unsigned *,\n+extern void ffi_call_SYSV(extended_cif *, unsigned, unsigned, unsigned *,\n \t\t\t  void (*fn)());\n-extern void FFI_HIDDEN ffi_call_LINUX64(/*@out@*/ extended_cif *,\n-\t\t\t\t\tunsigned long, unsigned long,\n-\t\t\t\t\t/*@out@*/ unsigned long *,\n+extern void FFI_HIDDEN ffi_call_LINUX64(extended_cif *, unsigned long,\n+\t\t\t\t\tunsigned long, unsigned long *,\n \t\t\t\t\tvoid (*fn)());\n-/*@=declundef@*/\n-/*@=exportheader@*/\n \n void\n-ffi_call(/*@dependent@*/ ffi_cif *cif,\n-\t void (*fn)(),\n-\t /*@out@*/ void *rvalue,\n-\t /*@dependent@*/ void **avalue)\n+ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n {\n   extended_cif ecif;\n \n@@ -818,9 +804,7 @@ ffi_call(/*@dependent@*/ ffi_cif *cif,\n \n   if ((rvalue == NULL) && (cif->rtype->type == FFI_TYPE_STRUCT))\n     {\n-      /*@-sysunrecog@*/\n       ecif.rvalue = alloca(cif->rtype->size);\n-      /*@=sysunrecog@*/\n     }\n   else\n     ecif.rvalue = rvalue;\n@@ -832,15 +816,11 @@ ffi_call(/*@dependent@*/ ffi_cif *cif,\n     case FFI_SYSV:\n     case FFI_GCC_SYSV:\n     case FFI_LINUX:\n-      /*@-usedef@*/\n       ffi_call_SYSV (&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn);\n-      /*@=usedef@*/\n       break;\n #else\n     case FFI_LINUX64:\n-      /*@-usedef@*/\n       ffi_call_LINUX64 (&ecif, -(long) cif->bytes, cif->flags, ecif.rvalue, fn);\n-      /*@=usedef@*/\n       break;\n #endif\n     default:"}, {"sha": "1d4fb34232abf652ea92ae329cd444d1de71b72f", "filename": "libffi/src/powerpc/ffi_darwin.c", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -79,9 +79,7 @@ enum { ASM_NEEDS_REGISTERS = 4 };\n \n    */\n \n-/*@-exportheader@*/\n void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n-/*@=exportheader@*/\n {\n   const unsigned bytes = ecif->cif->bytes;\n   const unsigned flags = ecif->cif->flags;\n@@ -375,25 +373,12 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   return FFI_OK;\n }\n \n-/*@-declundef@*/\n-/*@-exportheader@*/\n-extern void ffi_call_AIX(/*@out@*/ extended_cif *,\n-\t\t\t unsigned, unsigned,\n-\t\t\t /*@out@*/ unsigned *,\n-\t\t\t void (*fn)(),\n-\t\t\t void (*fn2)());\n-extern void ffi_call_DARWIN(/*@out@*/ extended_cif *,\n-\t\t\t    unsigned, unsigned,\n-\t\t\t    /*@out@*/ unsigned *,\n-\t\t\t    void (*fn)(),\n-\t\t\t    void (*fn2)());\n-/*@=declundef@*/\n-/*@=exportheader@*/\n-\n-void ffi_call(/*@dependent@*/ ffi_cif *cif,\n-\t      void (*fn)(),\n-\t      /*@out@*/ void *rvalue,\n-\t      /*@dependent@*/ void **avalue)\n+extern void ffi_call_AIX(extended_cif *, unsigned, unsigned, unsigned *,\n+\t\t\t void (*fn)(), void (*fn2)());\n+extern void ffi_call_DARWIN(extended_cif *, unsigned, unsigned, unsigned *,\n+\t\t\t    void (*fn)(), void (*fn2)());\n+\n+void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n {\n   extended_cif ecif;\n \n@@ -406,26 +391,20 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n   if ((rvalue == NULL) &&\n       (cif->rtype->type == FFI_TYPE_STRUCT))\n     {\n-      /*@-sysunrecog@*/\n       ecif.rvalue = alloca(cif->rtype->size);\n-      /*@=sysunrecog@*/\n     }\n   else\n     ecif.rvalue = rvalue;\n \n   switch (cif->abi)\n     {\n     case FFI_AIX:\n-      /*@-usedef@*/\n-      ffi_call_AIX(&ecif, -cif->bytes,\n-\t\t   cif->flags, ecif.rvalue, fn, ffi_prep_args);\n-      /*@=usedef@*/\n+      ffi_call_AIX(&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn,\n+\t\t   ffi_prep_args);\n       break;\n     case FFI_DARWIN:\n-      /*@-usedef@*/\n-      ffi_call_DARWIN(&ecif, -cif->bytes,\n-\t\t      cif->flags, ecif.rvalue, fn, ffi_prep_args);\n-      /*@=usedef@*/\n+      ffi_call_DARWIN(&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn,\n+\t\t      ffi_prep_args);\n       break;\n     default:\n       FFI_ASSERT(0);"}, {"sha": "6e69a0b4e72d46a306df6a43f596c79273e33779", "filename": "libffi/src/prep_cif.c", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fprep_cif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fprep_cif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fprep_cif.c?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -25,22 +25,19 @@\n #include <ffi_common.h>\n #include <stdlib.h>\n \n-\n /* Round up to FFI_SIZEOF_ARG. */\n \n #define STACK_ARG_SIZE(x) ALIGN(x, FFI_SIZEOF_ARG)\n \n /* Perform machine independent initialization of aggregate type\n    specifications. */\n \n-static ffi_status initialize_aggregate(/*@out@*/ ffi_type *arg)\n+static ffi_status initialize_aggregate(ffi_type *arg)\n {\n-  ffi_type **ptr; \n+  ffi_type **ptr;\n \n   FFI_ASSERT(arg != NULL);\n \n-  /*@-usedef@*/\n-\n   FFI_ASSERT(arg->elements != NULL);\n   FFI_ASSERT(arg->size == 0);\n   FFI_ASSERT(arg->alignment == 0);\n@@ -51,14 +48,14 @@ static ffi_status initialize_aggregate(/*@out@*/ ffi_type *arg)\n     {\n       if (((*ptr)->size == 0) && (initialize_aggregate((*ptr)) != FFI_OK))\n \treturn FFI_BAD_TYPEDEF;\n-      \n+\n       /* Perform a sanity check on the argument type */\n       FFI_ASSERT_VALID_TYPE(*ptr);\n \n       arg->size = ALIGN(arg->size, (*ptr)->alignment);\n       arg->size += (*ptr)->size;\n \n-      arg->alignment = (arg->alignment > (*ptr)->alignment) ? \n+      arg->alignment = (arg->alignment > (*ptr)->alignment) ?\n \targ->alignment : (*ptr)->alignment;\n \n       ptr++;\n@@ -77,8 +74,6 @@ static ffi_status initialize_aggregate(/*@out@*/ ffi_type *arg)\n     return FFI_BAD_TYPEDEF;\n   else\n     return FFI_OK;\n-\n-  /*@=usedef@*/\n }\n \n #ifndef __CRIS__\n@@ -89,10 +84,8 @@ static ffi_status initialize_aggregate(/*@out@*/ ffi_type *arg)\n /* Perform machine independent ffi_cif preparation, then call\n    machine dependent routine. */\n \n-ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif, \n-\t\t\tffi_abi abi, unsigned int nargs, \n-\t\t\t/*@dependent@*/ /*@out@*/ /*@partial@*/ ffi_type *rtype, \n-\t\t\t/*@dependent@*/ ffi_type **atypes)\n+ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi, unsigned int nargs,\n+\t\t\tffi_type *rtype, ffi_type **atypes)\n {\n   unsigned bytes = 0;\n   unsigned int i;\n@@ -109,10 +102,8 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,\n   cif->flags = 0;\n \n   /* Initialize the return type if necessary */\n-  /*@-usedef@*/\n   if ((cif->rtype->size == 0) && (initialize_aggregate(cif->rtype) != FFI_OK))\n     return FFI_BAD_TYPEDEF;\n-  /*@=usedef@*/\n \n   /* Perform a sanity check on the return type */\n   FFI_ASSERT_VALID_TYPE(cif->rtype);\n@@ -135,7 +126,7 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,\n       if (((*ptr)->size == 0) && (initialize_aggregate((*ptr)) != FFI_OK))\n \treturn FFI_BAD_TYPEDEF;\n \n-      /* Perform a sanity check on the argument type, do this \n+      /* Perform a sanity check on the argument type, do this\n \t check after the initialization.  */\n       FFI_ASSERT_VALID_TYPE(*ptr);\n \n@@ -152,7 +143,7 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,\n \t  /* Add any padding if necessary */\n \t  if (((*ptr)->alignment - 1) & bytes)\n \t    bytes = ALIGN(bytes, (*ptr)->alignment);\n-\t  \n+\n \t  bytes += STACK_ARG_SIZE((*ptr)->size);\n \t}\n #endif"}, {"sha": "c54127e6498a6e5726fcb38af625fb7e111f132b", "filename": "libffi/src/raw_api.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fraw_api.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fraw_api.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fraw_api.c?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -189,10 +189,7 @@ ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw)\n  * these following couple of functions will handle the translation forth\n  * and back automatically. */\n \n-void ffi_raw_call (/*@dependent@*/ ffi_cif *cif, \n-\t\t   void (*fn)(), \n-\t\t   /*@out@*/ void *rvalue, \n-\t\t   /*@dependent@*/ ffi_raw *raw)\n+void ffi_raw_call (ffi_cif *cif, void (*fn)(), void *rvalue, ffi_raw *raw)\n {\n   void **avalue = (void**) alloca (cif->nargs * sizeof (void*));\n   ffi_raw_to_ptrarray (cif, raw, avalue);\n@@ -201,7 +198,7 @@ void ffi_raw_call (/*@dependent@*/ ffi_cif *cif,\n \n #if FFI_CLOSURES\t\t/* base system provides closures */\n \n-static void \n+static void\n ffi_translate_args (ffi_cif *cif, void *rvalue,\n \t\t    void **avalue, void *user_data)\n {\n@@ -224,7 +221,7 @@ ffi_prep_raw_closure (ffi_raw_closure* cl,\n {\n   ffi_status status;\n \n-  status = ffi_prep_closure ((ffi_closure*) cl, \n+  status = ffi_prep_closure ((ffi_closure*) cl,\n \t\t\t     cif,\n \t\t\t     &ffi_translate_args,\n \t\t\t     (void*)cl);"}, {"sha": "f347b507f7b3b47d88270585fd908ade894afde6", "filename": "libffi/src/sh/ffi.c", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fsh%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fsh%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsh%2Fffi.c?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -106,9 +106,7 @@ return_type (ffi_type *arg)\n /* ffi_prep_args is called by the assembly routine once stack space\n    has been allocated for the function's arguments */\n \n-/*@-exportheader@*/\n void ffi_prep_args(char *stack, extended_cif *ecif)\n-/*@=exportheader@*/\n {\n   register unsigned int i;\n   register int tmp;\n@@ -406,20 +404,10 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   return FFI_OK;\n }\n \n-/*@-declundef@*/\n-/*@-exportheader@*/\n-extern void ffi_call_SYSV(void (*)(char *, extended_cif *), \n-\t\t\t  /*@out@*/ extended_cif *, \n-\t\t\t  unsigned, unsigned, \n-\t\t\t  /*@out@*/ unsigned *, \n-\t\t\t  void (*fn)());\n-/*@=declundef@*/\n-/*@=exportheader@*/\n-\n-void ffi_call(/*@dependent@*/ ffi_cif *cif, \n-\t      void (*fn)(), \n-\t      /*@out@*/ void *rvalue, \n-\t      /*@dependent@*/ void **avalue)\n+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,\n+\t\t\t  unsigned, unsigned, unsigned *, void (*fn)());\n+\n+void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n {\n   extended_cif ecif;\n   UINT64 trvalue;\n@@ -436,20 +424,16 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n   else if ((rvalue == NULL) && \n       (cif->rtype->type == FFI_TYPE_STRUCT))\n     {\n-      /*@-sysunrecog@*/\n       ecif.rvalue = alloca(cif->rtype->size);\n-      /*@=sysunrecog@*/\n     }\n   else\n     ecif.rvalue = rvalue;\n \n   switch (cif->abi) \n     {\n     case FFI_SYSV:\n-      /*@-usedef@*/\n-      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, \n-\t\t    cif->flags, ecif.rvalue, fn);\n-      /*@=usedef@*/\n+      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue,\n+\t\t    fn);\n       break;\n     default:\n       FFI_ASSERT(0);"}, {"sha": "caca436fc2de7d1f5665aeb23e416e874648c7cf", "filename": "libffi/src/sh64/ffi.c", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fsh64%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fsh64%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsh64%2Fffi.c?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -54,9 +54,7 @@ return_type (ffi_type *arg)\n /* ffi_prep_args is called by the assembly routine once stack space\n    has been allocated for the function's arguments */\n \n-/*@-exportheader@*/\n void ffi_prep_args(char *stack, extended_cif *ecif)\n-/*@=exportheader@*/\n {\n   register unsigned int i;\n   register unsigned int avn;\n@@ -238,20 +236,11 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   return FFI_OK;\n }\n \n-/*@-declundef@*/\n-/*@-exportheader@*/\n-extern void ffi_call_SYSV(void (*)(char *, extended_cif *), \n-\t\t\t  /*@out@*/ extended_cif *, \n-\t\t\t  unsigned, unsigned, long long,\n-\t\t\t  /*@out@*/ unsigned *, \n+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,\n+\t\t\t  unsigned, unsigned, long long, unsigned *,\n \t\t\t  void (*fn)());\n-/*@=declundef@*/\n-/*@=exportheader@*/\n \n-void ffi_call(/*@dependent@*/ ffi_cif *cif, \n-\t      void (*fn)(), \n-\t      /*@out@*/ void *rvalue, \n-\t      /*@dependent@*/ void **avalue)\n+void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n {\n   extended_cif ecif;\n   UINT64 trvalue;\n@@ -268,20 +257,16 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n   else if ((rvalue == NULL) && \n       (cif->rtype->type == FFI_TYPE_STRUCT))\n     {\n-      /*@-sysunrecog@*/\n       ecif.rvalue = alloca(cif->rtype->size);\n-      /*@=sysunrecog@*/\n     }\n   else\n     ecif.rvalue = rvalue;\n \n   switch (cif->abi) \n     {\n     case FFI_SYSV:\n-      /*@-usedef@*/\n-      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, \n-\t\t    cif->flags, cif->flags2, ecif.rvalue, fn);\n-      /*@=usedef@*/\n+      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, cif->flags2,\n+\t\t    ecif.rvalue, fn);\n       break;\n     default:\n       FFI_ASSERT(0);"}, {"sha": "e19902a4a2a48170b9e6830d0be782cb7db53a94", "filename": "libffi/src/x86/ffi.c", "status": "modified", "additions": 23, "deletions": 64, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fx86%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Fsrc%2Fx86%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi.c?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -36,9 +36,7 @@\n /* ffi_prep_args is called by the assembly routine once stack space\n    has been allocated for the function's arguments */\n \n-/*@-exportheader@*/\n void ffi_prep_args(char *stack, extended_cif *ecif)\n-/*@=exportheader@*/\n {\n   register unsigned int i;\n   register void **p_argv;\n@@ -168,32 +166,16 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   return FFI_OK;\n }\n \n-/*@-declundef@*/\n-/*@-exportheader@*/\n-extern void ffi_call_SYSV(void (*)(char *, extended_cif *), \n-\t\t\t  /*@out@*/ extended_cif *, \n-\t\t\t  unsigned, unsigned, \n-\t\t\t  /*@out@*/ unsigned *, \n-\t\t\t  void (*fn)());\n-/*@=declundef@*/\n-/*@=exportheader@*/\n+extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,\n+\t\t\t  unsigned, unsigned, unsigned *, void (*fn)());\n \n #ifdef X86_WIN32\n-/*@-declundef@*/\n-/*@-exportheader@*/\n-extern void ffi_call_STDCALL(void (*)(char *, extended_cif *),\n-\t\t\t  /*@out@*/ extended_cif *,\n-\t\t\t  unsigned, unsigned,\n-\t\t\t  /*@out@*/ unsigned *,\n-\t\t\t  void (*fn)());\n-/*@=declundef@*/\n-/*@=exportheader@*/\n+extern void ffi_call_STDCALL(void (*)(char *, extended_cif *), extended_cif *,\n+\t\t\t  unsigned, unsigned, unsigned *, void (*fn)());\n+\n #endif /* X86_WIN32 */\n \n-void ffi_call(/*@dependent@*/ ffi_cif *cif, \n-\t      void (*fn)(), \n-\t      /*@out@*/ void *rvalue, \n-\t      /*@dependent@*/ void **avalue)\n+void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n {\n   extended_cif ecif;\n \n@@ -206,9 +188,7 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n   if ((rvalue == NULL) && \n       (cif->flags == FFI_TYPE_STRUCT))\n     {\n-      /*@-sysunrecog@*/\n       ecif.rvalue = alloca(cif->rtype->size);\n-      /*@=sysunrecog@*/\n     }\n   else\n     ecif.rvalue = rvalue;\n@@ -217,17 +197,13 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n   switch (cif->abi) \n     {\n     case FFI_SYSV:\n-      /*@-usedef@*/\n-      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, \n-\t\t    cif->flags, ecif.rvalue, fn);\n-      /*@=usedef@*/\n+      ffi_call_SYSV(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue,\n+\t\t    fn);\n       break;\n #ifdef X86_WIN32\n     case FFI_STDCALL:\n-      /*@-usedef@*/\n-      ffi_call_STDCALL(ffi_prep_args, &ecif, cif->bytes,\n-\t\t    cif->flags, ecif.rvalue, fn);\n-      /*@=usedef@*/\n+      ffi_call_STDCALL(ffi_prep_args, &ecif, cif->bytes, cif->flags,\n+\t\t       ecif.rvalue, fn);\n       break;\n #endif /* X86_WIN32 */\n     default:\n@@ -276,11 +252,9 @@ ffi_closure_SYSV_inner (closure, respp, args)\n   return cif->flags;\n }\n \n-/*@-exportheader@*/\n-static void \n-ffi_prep_incoming_args_SYSV(char *stack, void **rvalue,\n-\t\t\t    void **avalue, ffi_cif *cif)\n-/*@=exportheader@*/\n+static void\n+ffi_prep_incoming_args_SYSV(char *stack, void **rvalue, void **avalue,\n+\t\t\t    ffi_cif *cif)\n {\n   register unsigned int i;\n   register void **p_argv;\n@@ -400,27 +374,18 @@ ffi_prep_args_raw(char *stack, extended_cif *ecif)\n  * libffi-1.20, this is not the case.)\n  */\n \n-extern void \n-ffi_call_SYSV(void (*)(char *, extended_cif *), \n-\t      /*@out@*/ extended_cif *, \n-\t      unsigned, unsigned, \n-\t      /*@out@*/ unsigned *, \n-\t      void (*fn)());\n+extern void\n+ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *, unsigned, \n+\t      unsigned, unsigned *, void (*fn)());\n \n #ifdef X86_WIN32\n extern void\n-ffi_call_STDCALL(void (*)(char *, extended_cif *),\n-\t      /*@out@*/ extended_cif *,\n-\t      unsigned, unsigned,\n-\t      /*@out@*/ unsigned *,\n-\t      void (*fn)());\n+ffi_call_STDCALL(void (*)(char *, extended_cif *), extended_cif *, unsigned,\n+\t\t unsigned, unsigned *, void (*fn)());\n #endif /* X86_WIN32 */\n \n void\n-ffi_raw_call(/*@dependent@*/ ffi_cif *cif, \n-\t     void (*fn)(), \n-\t     /*@out@*/ void *rvalue, \n-\t     /*@dependent@*/ ffi_raw *fake_avalue)\n+ffi_raw_call(ffi_cif *cif, void (*fn)(), void *rvalue, ffi_raw *fake_avalue)\n {\n   extended_cif ecif;\n   void **avalue = (void **)fake_avalue;\n@@ -434,9 +399,7 @@ ffi_raw_call(/*@dependent@*/ ffi_cif *cif,\n   if ((rvalue == NULL) && \n       (cif->rtype->type == FFI_TYPE_STRUCT))\n     {\n-      /*@-sysunrecog@*/\n       ecif.rvalue = alloca(cif->rtype->size);\n-      /*@=sysunrecog@*/\n     }\n   else\n     ecif.rvalue = rvalue;\n@@ -445,17 +408,13 @@ ffi_raw_call(/*@dependent@*/ ffi_cif *cif,\n   switch (cif->abi) \n     {\n     case FFI_SYSV:\n-      /*@-usedef@*/\n-      ffi_call_SYSV(ffi_prep_args_raw, &ecif, cif->bytes, \n-\t\t    cif->flags, ecif.rvalue, fn);\n-      /*@=usedef@*/\n+      ffi_call_SYSV(ffi_prep_args_raw, &ecif, cif->bytes, cif->flags,\n+\t\t    ecif.rvalue, fn);\n       break;\n #ifdef X86_WIN32\n     case FFI_STDCALL:\n-      /*@-usedef@*/\n-      ffi_call_STDCALL(ffi_prep_args_raw, &ecif, cif->bytes,\n-\t\t    cif->flags, ecif.rvalue, fn);\n-      /*@=usedef@*/\n+      ffi_call_STDCALL(ffi_prep_args_raw, &ecif, cif->bytes, cif->flags,\n+\t\t       ecif.rvalue, fn);\n       break;\n #endif /* X86_WIN32 */\n     default:"}, {"sha": "fa9dd311d69990fd0c9dccd4750ef3a89fcc8437", "filename": "libffi/testsuite/libffi.call/float2.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Ftestsuite%2Flibffi.call%2Ffloat2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Ftestsuite%2Flibffi.call%2Ffloat2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffloat2.c?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -48,9 +48,7 @@ int main (void)\n #endif\n \n   /* These are not always the same!! Check for a reasonable delta */\n-  /*@-realcompare@*/\n   if (ld - ldblit(f) < LDBL_EPSILON)\n-    /*@=realcompare@*/\n     puts(\"long double return value tests ok!\");\n   else\n     CHECK(0);"}, {"sha": "44561615dd42e63b11eca45da270e25eb688c954", "filename": "libffi/testsuite/libffi.call/promotion.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Ftestsuite%2Flibffi.call%2Fpromotion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Ftestsuite%2Flibffi.call%2Fpromotion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fpromotion.c?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -43,10 +43,10 @@ int main (void)\n   ul = 0;\n \n   for (sc = (signed char) -127;\n-       sc <= (signed char) 120; /*@-type@*/ sc += 1 /*@=type@*/)\n+       sc <= (signed char) 120; sc += 1)\n     for (ss = -30000; ss <= 30000; ss += 10000)\n       for (uc = (unsigned char) 0;\n-\t   uc <= (unsigned char) 200; /*@-type@*/ uc += 20 /*@=type@*/)\n+\t   uc <= (unsigned char) 200; uc += 20)\n \tfor (us = 0; us <= 60000; us += 10000)\n \t  {\n \t    ul++;"}, {"sha": "ea76c8544902f5fafdc5e4965b9229b123977d2c", "filename": "libffi/testsuite/libffi.call/struct1.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac6ed182edca2c15eb0509336b5fcc45fb250fe7/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1.c?ref=ac6ed182edca2c15eb0509336b5fcc45fb250fe7", "patch": "@@ -16,9 +16,7 @@ typedef struct\n \n static test_structure_1 struct1(test_structure_1 ts)\n {\n-  /*@-type@*/\n   ts.uc++;\n-  /*@=type@*/\n   ts.d--;\n   ts.ui++;\n "}]}