{"sha": "e021c122e50fdf3bc80e630e148b836c358a4dc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAyMWMxMjJlNTBmZGYzYmM4MGU2MzBlMTQ4YjgzNmMzNThhNGRjNQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-11-02T08:46:08Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-11-02T08:46:08Z"}, "message": "re PR middle-end/50890 (ICE in fold_convert_loc, at fold-const.c:1894)\n\n2010-11-02  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/50890\n\t* gimple.h (gimple_fold_call): Remove.\n\t* gimple-fold.c (fold_stmt_1): Move all call related code to ...\n\t(gimple_fold_call): ... here.  Make static.  Update the\n\tcannot-inline flag on direct calls.\n\t* ipa-inline.c (early_inliner): Copy the cannot-inline flag\n\tfrom the statements to the edges.\n\n\t* gcc.dg/torture/pr50890.c: New testcase.\n\nFrom-SVN: r180763", "tree": {"sha": "4bbfb4884a0e1cb82abe97bd185f21769f02380b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4bbfb4884a0e1cb82abe97bd185f21769f02380b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e021c122e50fdf3bc80e630e148b836c358a4dc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e021c122e50fdf3bc80e630e148b836c358a4dc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e021c122e50fdf3bc80e630e148b836c358a4dc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e021c122e50fdf3bc80e630e148b836c358a4dc5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5743331e9d1e1168cab132e2021cfef4d91c3c0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5743331e9d1e1168cab132e2021cfef4d91c3c0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5743331e9d1e1168cab132e2021cfef4d91c3c0f"}], "stats": {"total": 135, "additions": 93, "deletions": 42}, "files": [{"sha": "87e02408db2e54ae169f450128b8acb883a88206", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021c122e50fdf3bc80e630e148b836c358a4dc5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021c122e50fdf3bc80e630e148b836c358a4dc5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e021c122e50fdf3bc80e630e148b836c358a4dc5", "patch": "@@ -1,3 +1,13 @@\n+2010-11-02  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/50890\n+\t* gimple.h (gimple_fold_call): Remove.\n+\t* gimple-fold.c (fold_stmt_1): Move all call related code to ...\n+\t(gimple_fold_call): ... here.  Make static.  Update the\n+\tcannot-inline flag on direct calls.\n+\t* ipa-inline.c (early_inliner): Copy the cannot-inline flag\n+\tfrom the statements to the edges.\n+\n 2011-11-01  Ian Lance Taylor  <iant@google.com>\n \n \t* godump.c (struct macro_hash_value): Define."}, {"sha": "53bfb9641f884bba390493f0c77b0741aa9a7c1a", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 59, "deletions": 41, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021c122e50fdf3bc80e630e148b836c358a4dc5/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021c122e50fdf3bc80e630e148b836c358a4dc5/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=e021c122e50fdf3bc80e630e148b836c358a4dc5", "patch": "@@ -1057,53 +1057,82 @@ gimple_extract_devirt_binfo_from_cst (tree cst)\n    simplifies to a constant value. Return true if any changes were made.\n    It is assumed that the operands have been previously folded.  */\n \n-bool\n+static bool\n gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n {\n   gimple stmt = gsi_stmt (*gsi);\n   tree callee;\n+  bool changed = false;\n+  unsigned i;\n \n-  /* Check for builtins that CCP can handle using information not\n-     available in the generic fold routines.  */\n-  callee = gimple_call_fndecl (stmt);\n-  if (!inplace && callee && DECL_BUILT_IN (callee))\n-    {\n-      tree result = gimple_fold_builtin (stmt);\n-\n-      if (result)\n-\t{\n-          if (!update_call_from_tree (gsi, result))\n-\t    gimplify_and_update_call_from_tree (gsi, result);\n-\t  return true;\n-\t}\n-    }\n+  /* Fold *& in call arguments.  */\n+  for (i = 0; i < gimple_call_num_args (stmt); ++i)\n+    if (REFERENCE_CLASS_P (gimple_call_arg (stmt, i)))\n+      {\n+\ttree tmp = maybe_fold_reference (gimple_call_arg (stmt, i), false);\n+\tif (tmp)\n+\t  {\n+\t    gimple_call_set_arg (stmt, i, tmp);\n+\t    changed = true;\n+\t  }\n+      }\n \n   /* Check for virtual calls that became direct calls.  */\n   callee = gimple_call_fn (stmt);\n   if (callee && TREE_CODE (callee) == OBJ_TYPE_REF)\n     {\n-      tree binfo, fndecl, obj;\n-      HOST_WIDE_INT token;\n-\n       if (gimple_call_addr_fndecl (OBJ_TYPE_REF_EXPR (callee)) != NULL_TREE)\n \t{\n \t  gimple_call_set_fn (stmt, OBJ_TYPE_REF_EXPR (callee));\n-\t  return true;\n+\t  changed = true;\n \t}\n+      else\n+\t{\n+\t  tree obj = OBJ_TYPE_REF_OBJECT (callee);\n+\t  tree binfo = gimple_extract_devirt_binfo_from_cst (obj);\n+\t  if (binfo)\n+\t    {\n+\t      HOST_WIDE_INT token\n+\t\t= TREE_INT_CST_LOW (OBJ_TYPE_REF_TOKEN (callee));\n+\t      tree fndecl = gimple_get_virt_method_for_binfo (token, binfo);\n+\t      if (fndecl)\n+\t\t{\n+\t\t  gimple_call_set_fndecl (stmt, fndecl);\n+\t\t  changed = true;\n+\t\t}\n+\t    }\n+\t}\n+    }\n \n-      obj = OBJ_TYPE_REF_OBJECT (callee);\n-      binfo = gimple_extract_devirt_binfo_from_cst (obj);\n-      if (!binfo)\n-\treturn false;\n-      token = TREE_INT_CST_LOW (OBJ_TYPE_REF_TOKEN (callee));\n-      fndecl = gimple_get_virt_method_for_binfo (token, binfo);\n-      if (!fndecl)\n-\treturn false;\n-      gimple_call_set_fndecl (stmt, fndecl);\n-      return true;\n+  /* Check whether propagating into the function address made the\n+     call direct, and thus possibly non-inlineable.\n+     ???  This asks for a more conservative setting of the non-inlinable\n+     flag, namely true for all indirect calls.  But that would require\n+     that we can re-compute the flag conservatively, thus it isn't\n+     ever initialized from something else than return/argument type\n+     checks .  */\n+  callee = gimple_call_fndecl (stmt);\n+  if (callee\n+      && !gimple_check_call_matching_types (stmt, callee))\n+    gimple_call_set_cannot_inline (stmt, true);\n+\n+  if (inplace)\n+    return changed;\n+\n+  /* Check for builtins that CCP can handle using information not\n+     available in the generic fold routines.  */\n+  if (callee && DECL_BUILT_IN (callee))\n+    {\n+      tree result = gimple_fold_builtin (stmt);\n+      if (result)\n+\t{\n+          if (!update_call_from_tree (gsi, result))\n+\t    gimplify_and_update_call_from_tree (gsi, result);\n+\t  changed = true;\n+\t}\n     }\n \n-  return false;\n+  return changed;\n }\n \n /* Worker for both fold_stmt and fold_stmt_inplace.  The INPLACE argument\n@@ -1162,17 +1191,6 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace)\n       break;\n \n     case GIMPLE_CALL:\n-      /* Fold *& in call arguments.  */\n-      for (i = 0; i < gimple_call_num_args (stmt); ++i)\n-\tif (REFERENCE_CLASS_P (gimple_call_arg (stmt, i)))\n-\t  {\n-\t    tree tmp = maybe_fold_reference (gimple_call_arg (stmt, i), false);\n-\t    if (tmp)\n-\t      {\n-\t\tgimple_call_set_arg (stmt, i, tmp);\n-\t\tchanged = true;\n-\t      }\n-\t  }\n       changed |= gimple_fold_call (gsi, inplace);\n       break;\n "}, {"sha": "666c44c85911780d6e7d8bc6f81683782a5b276b", "filename": "gcc/gimple.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021c122e50fdf3bc80e630e148b836c358a4dc5/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021c122e50fdf3bc80e630e148b836c358a4dc5/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=e021c122e50fdf3bc80e630e148b836c358a4dc5", "patch": "@@ -909,7 +909,6 @@ unsigned get_gimple_rhs_num_ops (enum tree_code);\n #define gimple_alloc(c, n) gimple_alloc_stat (c, n MEM_STAT_INFO)\n gimple gimple_alloc_stat (enum gimple_code, unsigned MEM_STAT_DECL);\n const char *gimple_decl_printable_name (tree, int);\n-bool gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace);\n tree gimple_get_virt_method_for_binfo (HOST_WIDE_INT, tree);\n void gimple_adjust_this_by_delta (gimple_stmt_iterator *, tree);\n tree gimple_extract_devirt_binfo_from_cst (tree);"}, {"sha": "31c88e501e74383c38f193e19884bf7d9bb0a84f", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021c122e50fdf3bc80e630e148b836c358a4dc5/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021c122e50fdf3bc80e630e148b836c358a4dc5/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=e021c122e50fdf3bc80e630e148b836c358a4dc5", "patch": "@@ -1949,6 +1949,8 @@ early_inliner (void)\n \t\t= estimate_num_insns (edge->call_stmt, &eni_size_weights);\n \t      es->call_stmt_time\n \t\t= estimate_num_insns (edge->call_stmt, &eni_time_weights);\n+\t      edge->call_stmt_cannot_inline_p\n+\t\t= gimple_call_cannot_inline_p (edge->call_stmt);\n \t    }\n \t  timevar_pop (TV_INTEGRATION);\n \t  iterations++;"}, {"sha": "bf7c36611e93bc4370372a9c608b7552e79bc358", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021c122e50fdf3bc80e630e148b836c358a4dc5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021c122e50fdf3bc80e630e148b836c358a4dc5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e021c122e50fdf3bc80e630e148b836c358a4dc5", "patch": "@@ -1,3 +1,8 @@\n+2010-11-02  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/50890\n+\t* gcc.dg/torture/pr50890.c: New testcase.\n+\n 2011-11-01  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/44277"}, {"sha": "17240d4fb82344b62cd5f5817a3ff8b0d8da00a7", "filename": "gcc/testsuite/gcc.dg/torture/pr50890.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e021c122e50fdf3bc80e630e148b836c358a4dc5/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr50890.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e021c122e50fdf3bc80e630e148b836c358a4dc5/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr50890.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr50890.c?ref=e021c122e50fdf3bc80e630e148b836c358a4dc5", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+\n+static float make_insn_raw (void)\n+{\n+    return 0;\n+}\n+\n+static int emit_pattern_after_noloc (int (make_raw) ()) \n+{\n+    return make_raw ();\n+}\n+\n+void emit_insn_after_noloc (void) \n+{\n+    emit_pattern_after_noloc ((void *) make_insn_raw);\n+}\n+"}]}