{"sha": "07c0852e00d2b163f52cdc47828b4277ca7e4889", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdjMDg1MmUwMGQyYjE2M2Y1MmNkYzQ3ODI4YjQyNzdjYTdlNDg4OQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-04-06T09:24:46Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-04-06T09:24:46Z"}, "message": "i386.md (attribute isa): New.\n\n\t* config/i386/i386.md (attribute isa): New.\n\t(attribute enabled): New.\n\t(setcc_<mode>_sse): Merge from *{avx,sse}_setcc<mode>.\n\t(*fop_<mode>_comm_mixed): Merge with *fop_<mode>_comm_mixed_avx.\n\t(*fop_<mode>_comm_sse): Merge with *fop_<mode>_comm_avx.\n\t(*fop_<mode>_1_mixed): Merge with *fop_<mode>_1_mixed_avx.\n\t(*fop_<mode>_1_sse): Merge with *fop_<mode>_1_avx.\n\t(<smaxmin:code><mode>3): Merge with *avx_<smaxmin:code><mode>3.\n\t(*ieee_smin<mode>3): Merge with *avx_ieee_smin<mode>3.\n\t(*ieee_smax<mode>3): Merge with *avx_ieee_smax<mode>3.\n\n\t* config/i386/sse.md (VF): New mode iterator.\n\t(VF1): Ditto.\n\t(VF2): Ditto.\n\t(VF_128): Ditto.\n\t(SSEMODEF4): Remove.\n\t(attribute sse): Handle V8SF and V4DF modes.\n\t(<absneg:code><mode>2): Use VF mode iterator.\n\t(*absneg<mode>2): Merge from *{avx,sse}_absneg<mode>2.  Use VF\n\tmode iterator.\n\t(<plusminus_insn><mode>3): Use VF mode iterator.\n\t(*<plusminus_insn><mode>3): Merge with *avx_<plusminus_insn><mode>3.\n\tUse VF mode iterator.\n\t(<sse>_vm<plusminus_insn><mode>3): Merge with\n\t*avx_vm<plusminus_insn><mode>3.  Use VF_128 mode iterator.\n\t(mul<mode>3): Use VF mode iterator.\n\t(*mul<mode>3): Merge with *avx_mul<mode>3.  Use VF mode iterator.\n\t(<sse>_vmmul<mode>3): Merge with *avx_vmmul<mode>3.  Use VF_128\n\tmode iterator.\n\t(div<VF2:mode>3): Merge from divv2df3 and divv4df3.\n\t(div<VF1:mode>3): Merge from divv4sf3 and divv8sf3.\n\t(<sse>_div<mode>3): Merge with *avx_div<mode>3.  Use VF mode iterator.\n\t(<sse>_vmdiv<mode>3): Merge with *avx_vmdiv<mode>3.  Use VF_128\n\tmode iterator.\n\t(<sse>_rcp<mode>2): Merge from avx_rcpv8sf2 and sse_rcpv4sf2.\n\tUse VF1 mode iterator.\n\t(sse_vmrcpv4sf2): Merge with *avx_vmrcpv4sf2.\n\t(sqrt<VF2:mode>2): New expander.\n\t(sqrt<VF1:mode>2): Merge from sqrtv4sf2 and sqrtv8sf2.\n\t(<sse>_sqrt<mode>2): Merge from avx_sqrtv8sf2, sse_sqrtv4sf, sqrtv4df2\n\tand sqrtv2df2.  Use VF mode iterator.\n\t(<sse>_vmsqrt<mode>2): Merge with *avx_vmsqrt<mode>2.  Use VF_128\n\tmode iterator.\n\t(rsqrt<VF1:mode>2): Merge from rsqrtv4sf2 and rsqrtv8sf2.\n\t(<sse>_rsqrt<mode>2): Merge from avx_rsqrtv8sf2 and sse_rsqrt4sf2.\n\tUse VF1 mode iterator.\n\t(sse_vmrsqrtv4sf2): Merge with *avx_vmrsqrtv4sf2.\n\t(<smaxmin:code><mode>3): Use VF mode iterator.\n\t(*<smaxmin:code><mode>3_finite): Merge with\n\t*avx_<smaxmin:code><mode>3_finite.  Use VF mode iterator.\n\t(*<smaxmin:code><mode>3): Merge with *avx_<smaxmin:code><mode>3.\n\t(<sse>_vm<smaxmin:code><mode>2): Merge with\n\t*avx_vm<smaxmin:code><mode>2.  Use VF_128 mode iterator.\n\t(*ieee_smin<mode>3): Merge with *avx_ieee_smin<mode>3.  Use VF\n\tmode iterator.\n\t(*ieee_smax<mode>3): Merge with *avx_ieee_smax<mode>3.  Use VF\n\tmode iterator.\n\t(sse3_addsubv2df3): Merge with *avx_addsubv2df3.\n\t(sse3_addsubv4sf3): Merge with *avx_addsubv4sf3.\n\t(sse3_h<plusminus_insn>v2df3): Merge with *avx_h<plusminus_insn>v2df3.\n\t(sse3_h<plusminus_insn>v4sf3): Merge with *avx_h<plusminus_insn>v4sf3.\n\t(avx_cmp<mode>3): Rename from avx_cmp<ssemodesuffix><mode>3.  Use\n\tVF mode iterator.\n\t(avx_vmcmp<mode>3): Rename from avx_cmp<ssescalarmodesuffix><mode>3.\n\tUse VF_128 mode iterator.\n\t(<sse>_maskcmp<mode>3): Merge with *avx_maskcmp<mode>3.  Use VF\n\tmode iterator.\n\t(<sse>_vmmaskcmp<mode>3): Merge with *avx_vmmaskcmp<mode>3.  Use\n\tVF_128 mode iterator.\n\t(vcond<mode>): Use VF mode iterator.\n\t* config/i386/predicates.md (sse_comparison_operator): Merge with\n\tavx_comparison_float_operator.  Do not declare as special_predicate.\n\t* config/i386/i386.c (struct builtin_description): Update for renamed\n\tcompare patterns.\n\t(ix86_expand_args_builtin): Ditto.\n\t(ix86_expand_sse_compare_mask): Ditto.\n\nFrom-SVN: r172028", "tree": {"sha": "d4c6e85661a5206cbe30188b28a4d88819f2136c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4c6e85661a5206cbe30188b28a4d88819f2136c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07c0852e00d2b163f52cdc47828b4277ca7e4889", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07c0852e00d2b163f52cdc47828b4277ca7e4889", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07c0852e00d2b163f52cdc47828b4277ca7e4889", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07c0852e00d2b163f52cdc47828b4277ca7e4889/comments", "author": null, "committer": null, "parents": [{"sha": "ff5d142c9e5debaec4ebb8d1c61734bae42fd25e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff5d142c9e5debaec4ebb8d1c61734bae42fd25e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff5d142c9e5debaec4ebb8d1c61734bae42fd25e"}], "stats": {"total": 1484, "additions": 572, "deletions": 912}, "files": [{"sha": "74f210ffb191b2e9749aa62b69fbecba14ce772b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 81, "deletions": 2, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c0852e00d2b163f52cdc47828b4277ca7e4889/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c0852e00d2b163f52cdc47828b4277ca7e4889/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07c0852e00d2b163f52cdc47828b4277ca7e4889", "patch": "@@ -1,10 +1,89 @@\n+2011-04-06  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (attribute isa): New.\n+\t(attribute enabled): New.\n+\t(setcc_<mode>_sse): Merge from *{avx,sse}_setcc<mode>.\n+\t(*fop_<mode>_comm_mixed): Merge with *fop_<mode>_comm_mixed_avx.\n+\t(*fop_<mode>_comm_sse): Merge with *fop_<mode>_comm_avx.\n+\t(*fop_<mode>_1_mixed): Merge with *fop_<mode>_1_mixed_avx.\n+\t(*fop_<mode>_1_sse): Merge with *fop_<mode>_1_avx.\n+\t(<smaxmin:code><mode>3): Merge with *avx_<smaxmin:code><mode>3.\n+\t(*ieee_smin<mode>3): Merge with *avx_ieee_smin<mode>3.\n+\t(*ieee_smax<mode>3): Merge with *avx_ieee_smax<mode>3.\n+\n+\t* config/i386/sse.md (VF): New mode iterator.\n+\t(VF1): Ditto.\n+\t(VF2): Ditto.\n+\t(VF_128): Ditto.\n+\t(SSEMODEF4): Remove.\n+\t(attribute sse): Handle V8SF and V4DF modes.\n+\t(<absneg:code><mode>2): Use VF mode iterator.\n+\t(*absneg<mode>2): Merge from *{avx,sse}_absneg<mode>2.  Use VF\n+\tmode iterator.\n+\t(<plusminus_insn><mode>3): Use VF mode iterator.\n+\t(*<plusminus_insn><mode>3): Merge with *avx_<plusminus_insn><mode>3.\n+\tUse VF mode iterator.\n+\t(<sse>_vm<plusminus_insn><mode>3): Merge with\n+\t*avx_vm<plusminus_insn><mode>3.  Use VF_128 mode iterator.\n+\t(mul<mode>3): Use VF mode iterator.\n+\t(*mul<mode>3): Merge with *avx_mul<mode>3.  Use VF mode iterator.\n+\t(<sse>_vmmul<mode>3): Merge with *avx_vmmul<mode>3.  Use VF_128\n+\tmode iterator.\n+\t(div<VF2:mode>3): Merge from divv2df3 and divv4df3.\n+\t(div<VF1:mode>3): Merge from divv4sf3 and divv8sf3.\n+\t(<sse>_div<mode>3): Merge with *avx_div<mode>3.  Use VF mode iterator.\n+\t(<sse>_vmdiv<mode>3): Merge with *avx_vmdiv<mode>3.  Use VF_128\n+\tmode iterator.\n+\t(<sse>_rcp<mode>2): Merge from avx_rcpv8sf2 and sse_rcpv4sf2.\n+\tUse VF1 mode iterator.\n+\t(sse_vmrcpv4sf2): Merge with *avx_vmrcpv4sf2.\n+\t(sqrt<VF2:mode>2): New expander.\n+\t(sqrt<VF1:mode>2): Merge from sqrtv4sf2 and sqrtv8sf2.\n+\t(<sse>_sqrt<mode>2): Merge from avx_sqrtv8sf2, sse_sqrtv4sf, sqrtv4df2\n+\tand sqrtv2df2.  Use VF mode iterator.\n+\t(<sse>_vmsqrt<mode>2): Merge with *avx_vmsqrt<mode>2.  Use VF_128\n+\tmode iterator.\n+\t(rsqrt<VF1:mode>2): Merge from rsqrtv4sf2 and rsqrtv8sf2.\n+\t(<sse>_rsqrt<mode>2): Merge from avx_rsqrtv8sf2 and sse_rsqrt4sf2.\n+\tUse VF1 mode iterator.\n+\t(sse_vmrsqrtv4sf2): Merge with *avx_vmrsqrtv4sf2.\n+\t(<smaxmin:code><mode>3): Use VF mode iterator.\n+\t(*<smaxmin:code><mode>3_finite): Merge with\n+\t*avx_<smaxmin:code><mode>3_finite.  Use VF mode iterator.\n+\t(*<smaxmin:code><mode>3): Merge with *avx_<smaxmin:code><mode>3.\n+\t(<sse>_vm<smaxmin:code><mode>2): Merge with\n+\t*avx_vm<smaxmin:code><mode>2.  Use VF_128 mode iterator.\n+\t(*ieee_smin<mode>3): Merge with *avx_ieee_smin<mode>3.  Use VF\n+\tmode iterator.\n+\t(*ieee_smax<mode>3): Merge with *avx_ieee_smax<mode>3.  Use VF\n+\tmode iterator.\n+\t(sse3_addsubv2df3): Merge with *avx_addsubv2df3.\n+\t(sse3_addsubv4sf3): Merge with *avx_addsubv4sf3.\n+\t(sse3_h<plusminus_insn>v2df3): Merge with *avx_h<plusminus_insn>v2df3.\n+\t(sse3_h<plusminus_insn>v4sf3): Merge with *avx_h<plusminus_insn>v4sf3.\n+\t(avx_cmp<mode>3): Rename from avx_cmp<ssemodesuffix><mode>3.  Use\n+\tVF mode iterator.\n+\t(avx_vmcmp<mode>3): Rename from avx_cmp<ssescalarmodesuffix><mode>3.\n+\tUse VF_128 mode iterator.\n+\t(<sse>_maskcmp<mode>3): Merge with *avx_maskcmp<mode>3.  Use VF\n+\tmode iterator.\n+\t(<sse>_vmmaskcmp<mode>3): Merge with *avx_vmmaskcmp<mode>3.  Use\n+\tVF_128 mode iterator.\n+\t(vcond<mode>): Use VF mode iterator.\n+\t* config/i386/predicates.md (sse_comparison_operator): Merge with\n+\tavx_comparison_float_operator.  Do not declare as special_predicate.\n+\t* config/i386/i386.c (struct builtin_description): Update for renamed\n+\tcompare patterns.\n+\t(ix86_expand_args_builtin): Ditto.\n+\t(ix86_expand_sse_compare_mask): Ditto.\n+\n 2011-04-06  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-inline.c (estimate_num_insns): For calls simply account\n \tfor all passed arguments and a used return value.\n \n 2011-04-06  Richard Guenther  <rguenther@suse.de>\n- \n+\n \tPR tree-optimization/47663\n \t* cgraph.h (struct cgraph_edge): Add call_stmt_size and\n \tcall_stmt_time fields.\n@@ -618,7 +697,7 @@\n \n \t* config.gcc (*-*-mingw*): Allow as option the\n \tposix threading model.\n-\t* config/i386/mingw32.h ( SPEC_PTHREAD1,  SPEC_PTHREAD2):\n+\t* config/i386/mingw32.h (SPEC_PTHREAD1,  SPEC_PTHREAD2):\n \tNew macros defined dependent to TARGET_USE_PTHREAD_BY_DEFAULT\n \tdefinition.\n \t(CPP_SPEC): Add pthread/no-pthread handling."}, {"sha": "2e174710a75908c426076f420feaa14670b277cf", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c0852e00d2b163f52cdc47828b4277ca7e4889/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c0852e00d2b163f52cdc47828b4277ca7e4889/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=07c0852e00d2b163f52cdc47828b4277ca7e4889", "patch": "@@ -25342,12 +25342,12 @@ static const struct builtin_description bdesc_args[] =\n   { OPTION_MASK_ISA_AVX, CODE_FOR_avx_dpps256, \"__builtin_ia32_dpps256\", IX86_BUILTIN_DPPS256, UNKNOWN, (int) V8SF_FTYPE_V8SF_V8SF_INT },\n   { OPTION_MASK_ISA_AVX, CODE_FOR_avx_shufpd256, \"__builtin_ia32_shufpd256\", IX86_BUILTIN_SHUFPD256, UNKNOWN, (int) V4DF_FTYPE_V4DF_V4DF_INT },\n   { OPTION_MASK_ISA_AVX, CODE_FOR_avx_shufps256, \"__builtin_ia32_shufps256\", IX86_BUILTIN_SHUFPS256, UNKNOWN, (int) V8SF_FTYPE_V8SF_V8SF_INT },\n-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_cmpsdv2df3, \"__builtin_ia32_cmpsd\", IX86_BUILTIN_CMPSD, UNKNOWN, (int) V2DF_FTYPE_V2DF_V2DF_INT },\n-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_cmpssv4sf3, \"__builtin_ia32_cmpss\", IX86_BUILTIN_CMPSS, UNKNOWN, (int) V4SF_FTYPE_V4SF_V4SF_INT },\n-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_cmppdv2df3, \"__builtin_ia32_cmppd\", IX86_BUILTIN_CMPPD, UNKNOWN, (int) V2DF_FTYPE_V2DF_V2DF_INT },\n-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_cmppsv4sf3, \"__builtin_ia32_cmpps\", IX86_BUILTIN_CMPPS, UNKNOWN, (int) V4SF_FTYPE_V4SF_V4SF_INT },\n-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_cmppdv4df3, \"__builtin_ia32_cmppd256\", IX86_BUILTIN_CMPPD256, UNKNOWN, (int) V4DF_FTYPE_V4DF_V4DF_INT },\n-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_cmppsv8sf3, \"__builtin_ia32_cmpps256\", IX86_BUILTIN_CMPPS256, UNKNOWN, (int) V8SF_FTYPE_V8SF_V8SF_INT },\n+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_vmcmpv2df3, \"__builtin_ia32_cmpsd\", IX86_BUILTIN_CMPSD, UNKNOWN, (int) V2DF_FTYPE_V2DF_V2DF_INT },\n+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_vmcmpv4sf3, \"__builtin_ia32_cmpss\", IX86_BUILTIN_CMPSS, UNKNOWN, (int) V4SF_FTYPE_V4SF_V4SF_INT },\n+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_cmpv2df3, \"__builtin_ia32_cmppd\", IX86_BUILTIN_CMPPD, UNKNOWN, (int) V2DF_FTYPE_V2DF_V2DF_INT },\n+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_cmpv4sf3, \"__builtin_ia32_cmpps\", IX86_BUILTIN_CMPPS, UNKNOWN, (int) V4SF_FTYPE_V4SF_V4SF_INT },\n+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_cmpv4df3, \"__builtin_ia32_cmppd256\", IX86_BUILTIN_CMPPD256, UNKNOWN, (int) V4DF_FTYPE_V4DF_V4DF_INT },\n+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_cmpv8sf3, \"__builtin_ia32_cmpps256\", IX86_BUILTIN_CMPPS256, UNKNOWN, (int) V8SF_FTYPE_V8SF_V8SF_INT },\n   { OPTION_MASK_ISA_AVX, CODE_FOR_avx_vextractf128v4df, \"__builtin_ia32_vextractf128_pd256\", IX86_BUILTIN_EXTRACTF128PD256, UNKNOWN, (int) V2DF_FTYPE_V4DF_INT },\n   { OPTION_MASK_ISA_AVX, CODE_FOR_avx_vextractf128v8sf, \"__builtin_ia32_vextractf128_ps256\", IX86_BUILTIN_EXTRACTF128PS256, UNKNOWN, (int) V4SF_FTYPE_V8SF_INT },\n   { OPTION_MASK_ISA_AVX, CODE_FOR_avx_vextractf128v8si, \"__builtin_ia32_vextractf128_si256\", IX86_BUILTIN_EXTRACTF128SI256, UNKNOWN, (int) V4SI_FTYPE_V8SI_INT },\n@@ -26994,12 +26994,12 @@ ix86_expand_args_builtin (const struct builtin_description *d,\n \t\terror (\"the last argument must be a 1-bit immediate\");\n \t\treturn const0_rtx;\n \n-\t      case CODE_FOR_avx_cmpsdv2df3:\n-\t      case CODE_FOR_avx_cmpssv4sf3:\n-\t      case CODE_FOR_avx_cmppdv2df3:\n-\t      case CODE_FOR_avx_cmppsv4sf3:\n-\t      case CODE_FOR_avx_cmppdv4df3:\n-\t      case CODE_FOR_avx_cmppsv8sf3:\n+\t      case CODE_FOR_avx_vmcmpv2df3:\n+\t      case CODE_FOR_avx_vmcmpv4sf3:\n+\t      case CODE_FOR_avx_cmpv2df3:\n+\t      case CODE_FOR_avx_cmpv4sf3:\n+\t      case CODE_FOR_avx_cmpv4df3:\n+\t      case CODE_FOR_avx_cmpv8sf3:\n \t\terror (\"the last argument must be a 5-bit immediate\");\n \t\treturn const0_rtx;\n \n@@ -32359,6 +32359,7 @@ static rtx\n ix86_expand_sse_compare_mask (enum rtx_code code, rtx op0, rtx op1,\n \t\t\t      bool swap_operands)\n {\n+  rtx (*insn)(rtx, rtx, rtx, rtx);\n   enum machine_mode mode = GET_MODE (op0);\n   rtx mask = gen_reg_rtx (mode);\n \n@@ -32369,13 +32370,10 @@ ix86_expand_sse_compare_mask (enum rtx_code code, rtx op0, rtx op1,\n       op1 = tmp;\n     }\n \n-  if (mode == DFmode)\n-    emit_insn (gen_sse2_maskcmpdf3 (mask, op0, op1,\n-\t\t\t\t    gen_rtx_fmt_ee (code, mode, op0, op1)));\n-  else\n-    emit_insn (gen_sse_maskcmpsf3 (mask, op0, op1,\n-\t\t\t\t   gen_rtx_fmt_ee (code, mode, op0, op1)));\n+  insn = mode == DFmode ? gen_setcc_df_sse : gen_setcc_sf_sse;\n \n+  emit_insn (insn (mask, op0, op1,\n+\t\t   gen_rtx_fmt_ee (code, mode, op0, op1)));\n   return mask;\n }\n "}, {"sha": "f896bc9b9037719ea7100cccdd24b0a30677b7bc", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 72, "deletions": 166, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c0852e00d2b163f52cdc47828b4277ca7e4889/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c0852e00d2b163f52cdc47828b4277ca7e4889/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=07c0852e00d2b163f52cdc47828b4277ca7e4889", "patch": "@@ -698,6 +698,16 @@\n ;; Define attribute to indicate unaligned ssemov insns\n (define_attr \"movu\" \"0,1\" (const_string \"0\"))\n \n+;; Used to control the \"enabled\" attribute on a per-instruction basis.\n+(define_attr \"isa\" \"base,noavx,avx\"\n+  (const_string \"base\"))\n+\n+(define_attr \"enabled\" \"\"\n+  (cond [(eq_attr \"isa\" \"noavx\") (symbol_ref \"!TARGET_AVX\")\n+\t (eq_attr \"isa\" \"avx\") (symbol_ref \"TARGET_AVX\")\n+\t]\n+\t(const_int 1)))\n+\n ;; Describe a user's asm statement.\n (define_asm_attributes\n   [(set_attr \"length\" \"128\")\n@@ -10708,27 +10718,19 @@\n ;; 0xffffffff is NaN, but not in normalized form, so we can't represent\n ;; it directly.\n \n-(define_insn \"*avx_setcc<mode>\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n-\t(match_operator:MODEF 1 \"avx_comparison_float_operator\"\n-\t  [(match_operand:MODEF 2 \"register_operand\" \"x\")\n-\t   (match_operand:MODEF 3 \"nonimmediate_operand\" \"xm\")]))]\n-  \"TARGET_AVX\"\n-  \"vcmp%D1s<ssemodefsuffix>\\t{%3, %2, %0|%0, %2, %3}\"\n-  [(set_attr \"type\" \"ssecmp\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"length_immediate\" \"1\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn \"*sse_setcc<mode>\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n-\t(match_operator:MODEF 1 \"sse_comparison_operator\"\n-\t  [(match_operand:MODEF 2 \"register_operand\" \"0\")\n-\t   (match_operand:MODEF 3 \"nonimmediate_operand\" \"xm\")]))]\n+(define_insn \"setcc_<mode>_sse\"\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x\")\n+\t(match_operator:MODEF 3 \"sse_comparison_operator\"\n+\t  [(match_operand:MODEF 1 \"register_operand\" \"0,x\")\n+\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm,xm\")]))]\n   \"SSE_FLOAT_MODE_P (<MODE>mode)\"\n-  \"cmp%D1s<ssemodefsuffix>\\t{%3, %0|%0, %3}\"\n-  [(set_attr \"type\" \"ssecmp\")\n+  \"@\n+   cmp%D3s<ssemodefsuffix>\\t{%2, %0|%0, %2}\n+   vcmp%D3s<ssemodefsuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"ssecmp\")\n    (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \f\n ;; Basic conditional jump instructions.\n@@ -12865,66 +12867,32 @@\n ;; Gcc is slightly more smart about handling normal two address instructions\n ;; so use special patterns for add and mull.\n \n-(define_insn \"*fop_<mode>_comm_mixed_avx\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,x\")\n-\t(match_operator:MODEF 3 \"binary_fp_operator\"\n-\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"%0,x\")\n-\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"fm,xm\")]))]\n-  \"AVX_FLOAT_MODE_P (<MODE>mode) && TARGET_MIX_SSE_I387\n-   && COMMUTATIVE_ARITH_P (operands[3])\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"* return output_387_binary_op (insn, operands);\"\n-  [(set (attr \"type\")\n-\t(if_then_else (eq_attr \"alternative\" \"1\")\n-\t   (if_then_else (match_operand:MODEF 3 \"mult_operator\" \"\")\n-\t      (const_string \"ssemul\")\n-\t      (const_string \"sseadd\"))\n-\t   (if_then_else (match_operand:MODEF 3 \"mult_operator\" \"\")\n-\t      (const_string \"fmul\")\n-\t      (const_string \"fop\"))))\n-   (set_attr \"prefix\" \"orig,maybe_vex\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n (define_insn \"*fop_<mode>_comm_mixed\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,x\")\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,x,x\")\n \t(match_operator:MODEF 3 \"binary_fp_operator\"\n-\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"%0,0\")\n-\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"fm,xm\")]))]\n+\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"%0,0,x\")\n+\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"fm,xm,xm\")]))]\n   \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_MIX_SSE_I387\n    && COMMUTATIVE_ARITH_P (operands[3])\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n-\t(if_then_else (eq_attr \"alternative\" \"1\")\n+\t(if_then_else (eq_attr \"alternative\" \"1,2\")\n \t   (if_then_else (match_operand:MODEF 3 \"mult_operator\" \"\")\n \t      (const_string \"ssemul\")\n \t      (const_string \"sseadd\"))\n \t   (if_then_else (match_operand:MODEF 3 \"mult_operator\" \"\")\n \t      (const_string \"fmul\")\n \t      (const_string \"fop\"))))\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn \"*fop_<mode>_comm_avx\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n-\t(match_operator:MODEF 3 \"binary_fp_operator\"\n-\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"%x\")\n-\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm\")]))]\n-  \"AVX_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\n-   && COMMUTATIVE_ARITH_P (operands[3])\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"* return output_387_binary_op (insn, operands);\"\n-  [(set (attr \"type\")\n-        (if_then_else (match_operand:MODEF 3 \"mult_operator\" \"\")\n-\t   (const_string \"ssemul\")\n-\t   (const_string \"sseadd\")))\n-   (set_attr \"prefix\" \"vex\")\n+   (set_attr \"isa\" \"base,noavx,avx\")\n+   (set_attr \"prefix\" \"orig,orig,vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*fop_<mode>_comm_sse\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x\")\n \t(match_operator:MODEF 3 \"binary_fp_operator\"\n-\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"%0\")\n-\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm\")]))]\n+\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"%0,x\")\n+\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm,xm\")]))]\n   \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\n    && COMMUTATIVE_ARITH_P (operands[3])\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n@@ -12933,6 +12901,8 @@\n         (if_then_else (match_operand:MODEF 3 \"mult_operator\" \"\")\n \t   (const_string \"ssemul\")\n \t   (const_string \"sseadd\")))\n+   (set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*fop_<mode>_comm_i387\"\n@@ -12950,57 +12920,32 @@\n \t   (const_string \"fop\")))\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*fop_<mode>_1_mixed_avx\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,f,x\")\n-\t(match_operator:MODEF 3 \"binary_fp_operator\"\n-\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"0,fm,x\")\n-\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"fm,0,xm\")]))]\n-  \"AVX_FLOAT_MODE_P (<MODE>mode) && TARGET_MIX_SSE_I387\n-   && !COMMUTATIVE_ARITH_P (operands[3])\n-   && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n-  \"* return output_387_binary_op (insn, operands);\"\n-  [(set (attr \"type\")\n-        (cond [(and (eq_attr \"alternative\" \"2\")\n-\t            (match_operand:MODEF 3 \"mult_operator\" \"\"))\n-                 (const_string \"ssemul\")\n-\t       (and (eq_attr \"alternative\" \"2\")\n-\t            (match_operand:MODEF 3 \"div_operator\" \"\"))\n-                 (const_string \"ssediv\")\n-\t       (eq_attr \"alternative\" \"2\")\n-                 (const_string \"sseadd\")\n-\t       (match_operand:MODEF 3 \"mult_operator\" \"\")\n-                 (const_string \"fmul\")\n-               (match_operand:MODEF 3 \"div_operator\" \"\")\n-                 (const_string \"fdiv\")\n-              ]\n-              (const_string \"fop\")))\n-   (set_attr \"prefix\" \"orig,orig,maybe_vex\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n (define_insn \"*fop_<mode>_1_mixed\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,f,x\")\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=f,f,x,x\")\n \t(match_operator:MODEF 3 \"binary_fp_operator\"\n-\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"0,fm,0\")\n-\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"fm,0,xm\")]))]\n+\t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"0,fm,0,x\")\n+\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"fm,0,xm,xm\")]))]\n   \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_MIX_SSE_I387\n    && !COMMUTATIVE_ARITH_P (operands[3])\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n-        (cond [(and (eq_attr \"alternative\" \"2\")\n+        (cond [(and (eq_attr \"alternative\" \"2,3\")\n \t            (match_operand:MODEF 3 \"mult_operator\" \"\"))\n                  (const_string \"ssemul\")\n-\t       (and (eq_attr \"alternative\" \"2\")\n+\t       (and (eq_attr \"alternative\" \"2,3\")\n \t            (match_operand:MODEF 3 \"div_operator\" \"\"))\n                  (const_string \"ssediv\")\n-\t       (eq_attr \"alternative\" \"2\")\n+\t       (eq_attr \"alternative\" \"2,3\")\n                  (const_string \"sseadd\")\n \t       (match_operand:MODEF 3 \"mult_operator\" \"\")\n                  (const_string \"fmul\")\n                (match_operand:MODEF 3 \"div_operator\" \"\")\n                  (const_string \"fdiv\")\n               ]\n               (const_string \"fop\")))\n+   (set_attr \"isa\" \"base,base,noavx,avx\")\n+   (set_attr \"prefix\" \"orig,orig,orig,vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*rcpsf2_sse\"\n@@ -13014,29 +12959,11 @@\n    (set_attr \"prefix\" \"maybe_vex\")\n    (set_attr \"mode\" \"SF\")])\n \n-(define_insn \"*fop_<mode>_1_avx\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n-\t(match_operator:MODEF 3 \"binary_fp_operator\"\n-\t  [(match_operand:MODEF 1 \"register_operand\" \"x\")\n-\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm\")]))]\n-  \"AVX_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\n-   && !COMMUTATIVE_ARITH_P (operands[3])\"\n-  \"* return output_387_binary_op (insn, operands);\"\n-  [(set (attr \"type\")\n-        (cond [(match_operand:MODEF 3 \"mult_operator\" \"\")\n-                 (const_string \"ssemul\")\n-\t       (match_operand:MODEF 3 \"div_operator\" \"\")\n-                 (const_string \"ssediv\")\n-              ]\n-              (const_string \"sseadd\")))\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n (define_insn \"*fop_<mode>_1_sse\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x\")\n \t(match_operator:MODEF 3 \"binary_fp_operator\"\n-\t  [(match_operand:MODEF 1 \"register_operand\" \"0\")\n-\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm\")]))]\n+\t  [(match_operand:MODEF 1 \"register_operand\" \"0,x\")\n+\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm,xm\")]))]\n   \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\n    && !COMMUTATIVE_ARITH_P (operands[3])\"\n   \"* return output_387_binary_op (insn, operands);\"\n@@ -13047,6 +12974,8 @@\n                  (const_string \"ssediv\")\n               ]\n               (const_string \"sseadd\")))\n+   (set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; This pattern is not fully shadowed by the pattern above.\n@@ -16473,25 +16402,18 @@\n ;; Since both the tree-level MAX_EXPR and the rtl-level SMAX operator\n ;; are undefined in this condition, we're certain this is correct.\n \n-(define_insn \"*avx_<code><mode>3\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n-\t(smaxmin:MODEF\n-\t  (match_operand:MODEF 1 \"nonimmediate_operand\" \"%x\")\n-\t  (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"AVX_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\"\n-  \"v<maxmin_float>s<ssemodefsuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n (define_insn \"<code><mode>3\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x\")\n \t(smaxmin:MODEF\n-\t  (match_operand:MODEF 1 \"nonimmediate_operand\" \"%0\")\n-\t  (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm\")))]\n+\t  (match_operand:MODEF 1 \"nonimmediate_operand\" \"%0,x\")\n+\t  (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm,xm\")))]\n   \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\"\n-  \"<maxmin_float>s<ssemodefsuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n+  \"@\n+   <maxmin_float>s<ssemodefsuffix>\\t{%2, %0|%0, %2}\n+   v<maxmin_float>s<ssemodefsuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"prefix\" \"orig,vex\")\n+   (set_attr \"type\" \"sseadd\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; These versions of the min/max patterns implement exactly the operations\n@@ -16500,50 +16422,34 @@\n ;; Their operands are not commutative, and thus they may be used in the\n ;; presence of -0.0 and NaN.\n \n-(define_insn \"*avx_ieee_smin<mode>3\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n-\t(unspec:MODEF\n-\t  [(match_operand:MODEF 1 \"register_operand\" \"x\")\n-\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm\")]\n-\t UNSPEC_IEEE_MIN))]\n-  \"AVX_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\"\n-  \"vmins<ssemodefsuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n (define_insn \"*ieee_smin<mode>3\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x\")\n \t(unspec:MODEF\n-\t  [(match_operand:MODEF 1 \"register_operand\" \"0\")\n-\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm\")]\n+\t  [(match_operand:MODEF 1 \"register_operand\" \"0,x\")\n+\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm,xm\")]\n \t UNSPEC_IEEE_MIN))]\n   \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\"\n-  \"mins<ssemodefsuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn \"*avx_ieee_smax<mode>3\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n-\t(unspec:MODEF\n-\t  [(match_operand:MODEF 1 \"register_operand\" \"0\")\n-\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm\")]\n-\t UNSPEC_IEEE_MAX))]\n-  \"AVX_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\"\n-  \"vmaxs<ssemodefsuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"prefix\" \"vex\")\n+  \"@\n+   mins<ssemodefsuffix>\\t{%2, %0|%0, %2}\n+   vmins<ssemodefsuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"prefix\" \"orig,vex\")\n+   (set_attr \"type\" \"sseadd\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*ieee_smax<mode>3\"\n-  [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x\")\n \t(unspec:MODEF\n-\t  [(match_operand:MODEF 1 \"register_operand\" \"0\")\n-\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm\")]\n+\t  [(match_operand:MODEF 1 \"register_operand\" \"0,x\")\n+\t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"xm,xm\")]\n \t UNSPEC_IEEE_MAX))]\n   \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\"\n-  \"maxs<ssemodefsuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n+  \"@\n+   maxs<ssemodefsuffix>\\t{%2, %0|%0, %2}\n+   vmaxs<ssemodefsuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"prefix\" \"orig,vex\")\n+   (set_attr \"type\" \"sseadd\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; Make two stack loads independent:"}, {"sha": "03ec158e27476920e53f2bfe11ee73ae101a8ebf", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c0852e00d2b163f52cdc47828b4277ca7e4889/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c0852e00d2b163f52cdc47828b4277ca7e4889/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=07c0852e00d2b163f52cdc47828b4277ca7e4889", "patch": "@@ -969,19 +969,11 @@\n ;; Return true if OP is a comparison that can be used in the CMPSS/CMPPS insns.\n ;; The first set are supported directly; the second set can't be done with\n ;; full IEEE support, i.e. NaNs.\n-;;\n-;; ??? It would seem that we have a lot of uses of this predicate that pass\n-;; it the wrong mode.  We got away with this because the old function didn't\n-;; check the mode at all.  Mirror that for now by calling this a special\n-;; predicate.\n-\n-(define_special_predicate \"sse_comparison_operator\"\n-  (match_code \"eq,lt,le,unordered,ne,unge,ungt,ordered\"))\n-\n-;; Return true if OP is a comparison operator that can be issued by\n-;; avx predicate generation instructions\n-(define_predicate \"avx_comparison_float_operator\"\n-  (match_code \"ne,eq,ge,gt,le,lt,unordered,ordered,uneq,unge,ungt,unle,unlt,ltgt\"))\n+\n+(define_predicate \"sse_comparison_operator\"\n+  (ior (match_code \"eq,ne,lt,le,unordered,unge,ungt,ordered\")\n+       (and (match_code \"ge,gt,uneq,unle,unlt,ltgt\")\n+\t    (match_test \"TARGET_AVX\"))))\n \n (define_predicate \"ix86_comparison_int_operator\"\n   (match_code \"ne,eq,ge,gt,le,lt\"))"}, {"sha": "8c9a7b21ee24d40c560e6767c1d53981578116fc", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 398, "deletions": 713, "changes": 1111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c0852e00d2b163f52cdc47828b4277ca7e4889/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c0852e00d2b163f52cdc47828b4277ca7e4889/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=07c0852e00d2b163f52cdc47828b4277ca7e4889", "patch": "@@ -19,6 +19,25 @@\n ;; <http://www.gnu.org/licenses/>.\n \n \n+;; All vector float modes\n+(define_mode_iterator VF\n+  [(V4SF \"TARGET_SSE\") (V2DF \"TARGET_SSE2\")\n+   (V8SF \"TARGET_AVX\") (V4DF \"TARGET_AVX\")])\n+\n+;; All SFmode vector float modes\n+(define_mode_iterator VF1\n+  [(V4SF \"TARGET_SSE\") (V8SF \"TARGET_AVX\")])\n+\n+;; All DFmode vector float modes\n+(define_mode_iterator VF2\n+  [(V2DF \"TARGET_SSE2\") (V4DF \"TARGET_AVX\")])\n+\n+;; All 128bit vector float modes\n+(define_mode_iterator VF_128\n+  [(V4SF \"TARGET_SSE\") (V2DF \"TARGET_SSE2\")])\n+\n+\n+\n ;; Instruction suffix for sign and zero extensions.\n (define_code_attr extsuffix [(sign_extend \"sx\") (zero_extend \"zx\")])\n \n@@ -54,7 +73,6 @@\n (define_mode_iterator SSEMODE124 [V16QI V8HI V4SI])\n (define_mode_iterator SSEMODE248 [V8HI V4SI V2DI])\n (define_mode_iterator SSEMODE1248 [V16QI V8HI V4SI V2DI])\n-(define_mode_iterator SSEMODEF4 [SF DF V4SF V2DF])\n (define_mode_iterator SSEMODEF2P [V4SF V2DF])\n \n (define_mode_iterator AVX256MODEF2P [V8SF V4DF])\n@@ -107,7 +125,10 @@\n    (V4DF \"TARGET_AVX\") (V8SF \"TARGET_AVX\")])\n \n ;; Mapping from float mode to required SSE level\n-(define_mode_attr sse [(SF \"sse\") (DF \"sse2\") (V4SF \"sse\") (V2DF \"sse2\")])\n+(define_mode_attr sse\n+  [(SF \"sse\") (DF \"sse2\")\n+   (V4SF \"sse\") (V2DF \"sse2\")\n+   (V8SF \"avx\") (V4DF \"avx\")])\n \n ;; Mapping from integer vector mode to mnemonic suffix\n (define_mode_attr ssevecsize [(V16QI \"b\") (V8HI \"w\") (V4SI \"d\") (V2DI \"q\")])\n@@ -589,593 +610,352 @@\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \n (define_expand \"<code><mode>2\"\n-  [(set (match_operand:VEC_FLOAT_MODE 0 \"register_operand\" \"\")\n-\t(absneg:VEC_FLOAT_MODE\n-\t  (match_operand:VEC_FLOAT_MODE 1 \"register_operand\" \"\")))]\n+  [(set (match_operand:VF 0 \"register_operand\" \"\")\n+\t(absneg:VF\n+\t  (match_operand:VF 1 \"register_operand\" \"\")))]\n   \"\"\n   \"ix86_expand_fp_absneg_operator (<CODE>, <MODE>mode, operands); DONE;\")\n \n-(define_insn_and_split \"*avx_absneg<mode>2\"\n-  [(set (match_operand:AVXMODEF2P 0 \"register_operand\" \"=x,x\")\n-\t(match_operator:AVXMODEF2P 3 \"absneg_operator\"\n-\t  [(match_operand:AVXMODEF2P 1 \"nonimmediate_operand\" \"x,m\")]))\n-   (use (match_operand:AVXMODEF2P 2 \"nonimmediate_operand\" \"xm,x\"))]\n-  \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\"\n+(define_insn_and_split \"*absneg<mode>2\"\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,x,x,x\")\n+\t(match_operator:VF 3 \"absneg_operator\"\n+\t  [(match_operand:VF 1 \"nonimmediate_operand\" \"0, xm,x, m\")]))\n+   (use (match_operand:VF 2 \"nonimmediate_operand\"    \"xm,0, xm,x\"))]\n+  \"\"\n   \"#\"\n-  \"&& reload_completed\"\n+  \"reload_completed\"\n   [(const_int 0)]\n {\n+  enum rtx_code absneg_op;\n+  rtx op1, op2;\n   rtx t;\n \n-  if (MEM_P (operands[1]))\n-    t = gen_rtx_fmt_ee (GET_CODE (operands[3]) == NEG ? XOR : AND,\n-\t\t\t<MODE>mode, operands[2], operands[1]);\n+  if (TARGET_AVX)\n+    {\n+      if (MEM_P (operands[1]))\n+\top1 = operands[2], op2 = operands[1];\n+      else\n+\top1 = operands[1], op2 = operands[2];\n+    }\n   else\n-    t = gen_rtx_fmt_ee (GET_CODE (operands[3]) == NEG ? XOR : AND,\n-\t\t\t<MODE>mode, operands[1], operands[2]);\n-  t = gen_rtx_SET (VOIDmode, operands[0], t);\n-  emit_insn (t);\n-  DONE;\n-})\n-\n-(define_insn_and_split \"*sse_absneg<mode>2\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x,x\")\n-\t(match_operator:SSEMODEF2P 3 \"absneg_operator\"\n-\t  [(match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"0,xm\")]))\n-   (use (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm,0\"))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-{\n-  rtx t;\n+    {\n+      op1 = operands[0];\n+      if (rtx_equal_p (operands[0], operands[1]))\n+\top2 = operands[2];\n+      else\n+\top2 = operands[1];\n+    }\n \n-  t = operands[rtx_equal_p (operands[0], operands[1]) ? 2 : 1];\n-  t = gen_rtx_fmt_ee (GET_CODE (operands[3]) == NEG ? XOR : AND,\n-\t\t      <MODE>mode, operands[0], t);\n+  absneg_op = GET_CODE (operands[3]) == NEG ? XOR : AND;\n+  t = gen_rtx_fmt_ee (absneg_op, <MODE>mode, op1, op2);\n   t = gen_rtx_SET (VOIDmode, operands[0], t);\n   emit_insn (t);\n   DONE;\n-})\n-\n-(define_expand \"<plusminus_insn><mode>3\"\n-  [(set (match_operand:AVX256MODEF2P 0 \"register_operand\" \"\")\n-\t(plusminus:AVX256MODEF2P\n-\t  (match_operand:AVX256MODEF2P 1 \"nonimmediate_operand\" \"\")\n-\t  (match_operand:AVX256MODEF2P 2 \"nonimmediate_operand\" \"\")))]\n-  \"AVX256_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\")\n-\n-(define_insn \"*avx_<plusminus_insn><mode>3\"\n-  [(set (match_operand:AVXMODEF2P 0 \"register_operand\" \"=x\")\n-\t(plusminus:AVXMODEF2P\n-\t  (match_operand:AVXMODEF2P 1 \"nonimmediate_operand\" \"<comm>x\")\n-\t  (match_operand:AVXMODEF2P 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\n-   && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n-  \"v<plusminus_mnemonic><ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<avxvecmode>\")])\n+}\n+  [(set_attr \"isa\" \"noavx,noavx,avx,avx\")])\n \n (define_expand \"<plusminus_insn><mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"\")\n-\t(plusminus:SSEMODEF2P\n-\t  (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"\")\n-\t  (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"\")))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n+  [(set (match_operand:VF 0 \"register_operand\" \"\")\n+\t(plusminus:VF\n+\t  (match_operand:VF 1 \"nonimmediate_operand\" \"\")\n+\t  (match_operand:VF 2 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\")\n \n (define_insn \"*<plusminus_insn><mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(plusminus:SSEMODEF2P\n-\t  (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"<comm>0\")\n-\t  (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\n-   && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n-  \"<plusminus_mnemonic><ssemodesuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,x\")\n+\t(plusminus:VF\n+\t  (match_operand:VF 1 \"nonimmediate_operand\" \"<comm>0,x\")\n+\t  (match_operand:VF 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+  \"ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n+  \"@\n+   <plusminus_mnemonic><ssemodesuffix>\\t{%2, %0|%0, %2}\n+   v<plusminus_mnemonic><ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sseadd\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*avx_vm<plusminus_insn><mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(vec_merge:SSEMODEF2P\n-\t  (plusminus:SSEMODEF2P\n-\t    (match_operand:SSEMODEF2P 1 \"register_operand\" \"x\")\n-\t    (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\"))\n-\t  (match_dup 1)\n-\t  (const_int 1)))]\n-  \"AVX128_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"v<plusminus_mnemonic><ssescalarmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<ssescalarmode>\")])\n-\n (define_insn \"<sse>_vm<plusminus_insn><mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(vec_merge:SSEMODEF2P\n-\t  (plusminus:SSEMODEF2P\n-\t    (match_operand:SSEMODEF2P 1 \"register_operand\" \"0\")\n-\t    (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\"))\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:VF_128\n+\t  (plusminus:VF_128\n+\t    (match_operand:VF_128 1 \"register_operand\" \"0,x\")\n+\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm,xm\"))\n \t  (match_dup 1)\n \t  (const_int 1)))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"<plusminus_mnemonic><ssescalarmodesuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n+  \"\"\n+  \"@\n+   <plusminus_mnemonic><ssescalarmodesuffix>\\t{%2, %0|%0, %2}\n+   v<plusminus_mnemonic><ssescalarmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sseadd\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<ssescalarmode>\")])\n \n (define_expand \"mul<mode>3\"\n-  [(set (match_operand:AVX256MODEF2P 0 \"register_operand\" \"\")\n-\t(mult:AVX256MODEF2P\n-\t  (match_operand:AVX256MODEF2P 1 \"nonimmediate_operand\" \"\")\n-\t  (match_operand:AVX256MODEF2P 2 \"nonimmediate_operand\" \"\")))]\n-  \"AVX256_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"ix86_fixup_binary_operands_no_copy (MULT, <MODE>mode, operands);\")\n-\n-(define_insn \"*avx_mul<mode>3\"\n-  [(set (match_operand:AVXMODEF2P 0 \"register_operand\" \"=x\")\n-\t(mult:AVXMODEF2P\n-\t  (match_operand:AVXMODEF2P 1 \"nonimmediate_operand\" \"%x\")\n-\t  (match_operand:AVXMODEF2P 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\n-   && ix86_binary_operator_ok (MULT, <MODE>mode, operands)\"\n-  \"vmul<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"ssemul\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<avxvecmode>\")])\n-\n-(define_expand \"mul<mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"\")\n-\t(mult:SSEMODEF2P\n-\t  (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"\")\n-\t  (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"\")))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n+  [(set (match_operand:VF 0 \"register_operand\" \"\")\n+\t(mult:VF\n+\t  (match_operand:VF 1 \"nonimmediate_operand\" \"\")\n+\t  (match_operand:VF 2 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n   \"ix86_fixup_binary_operands_no_copy (MULT, <MODE>mode, operands);\")\n \n (define_insn \"*mul<mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(mult:SSEMODEF2P\n-\t  (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"%0\")\n-\t  (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\n-   && ix86_binary_operator_ok (MULT, <MODE>mode, operands)\"\n-  \"mul<ssemodesuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ssemul\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,x\")\n+\t(mult:VF\n+\t  (match_operand:VF 1 \"nonimmediate_operand\" \"%0,x\")\n+\t  (match_operand:VF 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+  \"ix86_binary_operator_ok (MULT, <MODE>mode, operands)\"\n+  \"@\n+   mul<ssemodesuffix>\\t{%2, %0|%0, %2}\n+   vmul<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"ssemul\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*avx_vmmul<mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(vec_merge:SSEMODEF2P\n-\t  (mult:SSEMODEF2P\n-\t    (match_operand:SSEMODEF2P 1 \"register_operand\" \"x\")\n-\t    (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\"))\n-\t  (match_dup 1)\n-\t  (const_int 1)))]\n-  \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"vmul<ssescalarmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"ssemul\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<ssescalarmode>\")])\n-\n (define_insn \"<sse>_vmmul<mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(vec_merge:SSEMODEF2P\n-\t  (mult:SSEMODEF2P\n-\t    (match_operand:SSEMODEF2P 1 \"register_operand\" \"0\")\n-\t    (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\"))\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:VF_128\n+\t  (mult:VF_128\n+\t    (match_operand:VF_128 1 \"register_operand\" \"0,x\")\n+\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm,xm\"))\n \t  (match_dup 1)\n \t  (const_int 1)))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"mul<ssescalarmodesuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ssemul\")\n+  \"\"\n+  \"@\n+   mul<ssescalarmodesuffix>\\t{%2, %0|%0, %2}\n+   vmul<ssescalarmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"ssemul\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<ssescalarmode>\")])\n \n-(define_expand \"divv8sf3\"\n-  [(set (match_operand:V8SF 0 \"register_operand\" \"\")\n-\t(div:V8SF (match_operand:V8SF 1 \"register_operand\" \"\")\n-\t\t  (match_operand:V8SF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_AVX\"\n+(define_expand \"div<mode>3\"\n+  [(set (match_operand:VF2 0 \"register_operand\" \"\")\n+\t(div:VF2 (match_operand:VF2 1 \"register_operand\" \"\")\n+\t\t (match_operand:VF2 2 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n+  \"ix86_fixup_binary_operands_no_copy (DIV, <MODE>mode, operands);\")\n+\n+(define_expand \"div<mode>3\"\n+  [(set (match_operand:VF1 0 \"register_operand\" \"\")\n+\t(div:VF1 (match_operand:VF1 1 \"register_operand\" \"\")\n+\t\t (match_operand:VF1 2 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n {\n-  ix86_fixup_binary_operands_no_copy (DIV, V8SFmode, operands);\n+  ix86_fixup_binary_operands_no_copy (DIV, <MODE>mode, operands);\n \n   if (TARGET_SSE_MATH && TARGET_RECIP && !optimize_insn_for_size_p ()\n       && flag_finite_math_only && !flag_trapping_math\n       && flag_unsafe_math_optimizations)\n     {\n-      ix86_emit_swdivsf (operands[0], operands[1],\n-\t\t\t operands[2], V8SFmode);\n-      DONE;\n-    }\n-})\n-\n-(define_expand \"divv4df3\"\n-  [(set (match_operand:V4DF 0 \"register_operand\" \"\")\n-\t(div:V4DF (match_operand:V4DF 1 \"register_operand\" \"\")\n-\t\t  (match_operand:V4DF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_AVX\"\n-  \"ix86_fixup_binary_operands_no_copy (DIV, V4DFmode, operands);\")\n-\n-(define_insn \"avx_div<mode>3\"\n-  [(set (match_operand:AVXMODEF2P 0 \"register_operand\" \"=x\")\n-\t(div:AVXMODEF2P\n-\t  (match_operand:AVXMODEF2P 1 \"register_operand\" \"x\")\n-\t  (match_operand:AVXMODEF2P 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"vdiv<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"ssediv\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_expand \"divv4sf3\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n-\t(div:V4SF (match_operand:V4SF 1 \"register_operand\" \"\")\n-\t\t  (match_operand:V4SF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_SSE\"\n-{\n-  if (TARGET_SSE_MATH && TARGET_RECIP && optimize_insn_for_speed_p ()\n-      && flag_finite_math_only && !flag_trapping_math\n-      && flag_unsafe_math_optimizations)\n-    {\n-      ix86_emit_swdivsf (operands[0], operands[1],\n-\t\t\t operands[2], V4SFmode);\n+      ix86_emit_swdivsf (operands[0], operands[1], operands[2], <MODE>mode);\n       DONE;\n     }\n })\n \n-(define_expand \"divv2df3\"\n-  [(set (match_operand:V2DF 0 \"register_operand\" \"\")\n-\t(div:V2DF (match_operand:V2DF 1 \"register_operand\" \"\")\n-\t\t  (match_operand:V2DF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_SSE2\")\n-\n-(define_insn \"*avx_div<mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(div:SSEMODEF2P\n-\t  (match_operand:SSEMODEF2P 1 \"register_operand\" \"x\")\n-\t  (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"AVX128_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"vdiv<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"ssediv\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n (define_insn \"<sse>_div<mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(div:SSEMODEF2P\n-\t  (match_operand:SSEMODEF2P 1 \"register_operand\" \"0\")\n-\t  (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"div<ssemodesuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ssediv\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,x\")\n+\t(div:VF\n+\t  (match_operand:VF 1 \"register_operand\" \"0,x\")\n+\t  (match_operand:VF 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+  \"\"\n+  \"@\n+   div<ssemodesuffix>\\t{%2, %0|%0, %2}\n+   vdiv<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"ssediv\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*avx_vmdiv<mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(vec_merge:SSEMODEF2P\n-\t  (div:SSEMODEF2P\n-\t    (match_operand:SSEMODEF2P 1 \"register_operand\" \"x\")\n-\t    (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\"))\n-\t  (match_dup 1)\n-\t  (const_int 1)))]\n-  \"AVX128_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"vdiv<ssescalarmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"ssediv\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<ssescalarmode>\")])\n-\n (define_insn \"<sse>_vmdiv<mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(vec_merge:SSEMODEF2P\n-\t  (div:SSEMODEF2P\n-\t    (match_operand:SSEMODEF2P 1 \"register_operand\" \"0\")\n-\t    (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\"))\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:VF_128\n+\t  (div:VF_128\n+\t    (match_operand:VF_128 1 \"register_operand\" \"0,x\")\n+\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm,xm\"))\n \t  (match_dup 1)\n \t  (const_int 1)))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"div<ssescalarmodesuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ssediv\")\n+  \"\"\n+  \"@\n+   div<ssescalarmodesuffix>\\t{%2, %0|%0, %2}\n+   vdiv<ssescalarmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"ssediv\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<ssescalarmode>\")])\n \n-(define_insn \"avx_rcpv8sf2\"\n-  [(set (match_operand:V8SF 0 \"register_operand\" \"=x\")\n-\t(unspec:V8SF\n-\t  [(match_operand:V8SF 1 \"nonimmediate_operand\" \"xm\")] UNSPEC_RCP))]\n-  \"TARGET_AVX\"\n-  \"vrcpps\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"sse\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"V8SF\")])\n-\n-(define_insn \"sse_rcpv4sf2\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n-\t(unspec:V4SF\n-\t  [(match_operand:V4SF 1 \"nonimmediate_operand\" \"xm\")] UNSPEC_RCP))]\n-  \"TARGET_SSE\"\n+(define_insn \"<sse>_rcp<mode>2\"\n+  [(set (match_operand:VF1 0 \"register_operand\" \"=x\")\n+\t(unspec:VF1\n+\t  [(match_operand:VF1 1 \"nonimmediate_operand\" \"xm\")] UNSPEC_RCP))]\n+  \"\"\n   \"%vrcpps\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sse\")\n    (set_attr \"atom_sse_attr\" \"rcp\")\n    (set_attr \"prefix\" \"maybe_vex\")\n-   (set_attr \"mode\" \"V4SF\")])\n-\n-(define_insn \"*avx_vmrcpv4sf2\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n-\t(vec_merge:V4SF\n-\t  (unspec:V4SF [(match_operand:V4SF 1 \"nonimmediate_operand\" \"xm\")]\n-\t\t       UNSPEC_RCP)\n-\t  (match_operand:V4SF 2 \"register_operand\" \"x\")\n-\t  (const_int 1)))]\n-  \"TARGET_AVX\"\n-  \"vrcpss\\t{%1, %2, %0|%0, %2, %1}\"\n-  [(set_attr \"type\" \"sse\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"SF\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"sse_vmrcpv4sf2\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x\")\n \t(vec_merge:V4SF\n-\t  (unspec:V4SF [(match_operand:V4SF 1 \"nonimmediate_operand\" \"xm\")]\n+\t  (unspec:V4SF [(match_operand:V4SF 1 \"nonimmediate_operand\" \"xm,xm\")]\n \t\t       UNSPEC_RCP)\n-\t  (match_operand:V4SF 2 \"register_operand\" \"0\")\n+\t  (match_operand:V4SF 2 \"register_operand\" \"0,x\")\n \t  (const_int 1)))]\n   \"TARGET_SSE\"\n-  \"rcpss\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"sse\")\n+  \"@\n+   rcpss\\t{%1, %0|%0, %1}\n+   vrcpss\\t{%1, %2, %0|%0, %2, %1}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sse\")\n    (set_attr \"atom_sse_attr\" \"rcp\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"SF\")])\n \n-(define_expand \"sqrtv8sf2\"\n-  [(set (match_operand:V8SF 0 \"register_operand\" \"\")\n-\t(sqrt:V8SF (match_operand:V8SF 1 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_AVX\"\n-{\n-  if (TARGET_SSE_MATH && TARGET_RECIP && !optimize_insn_for_size_p ()\n-      && flag_finite_math_only && !flag_trapping_math\n-      && flag_unsafe_math_optimizations)\n-    {\n-      ix86_emit_swsqrtsf (operands[0], operands[1], V8SFmode, 0);\n-      DONE;\n-    }\n-})\n-\n-(define_insn \"avx_sqrtv8sf2\"\n-  [(set (match_operand:V8SF 0 \"register_operand\" \"=x\")\n-\t(sqrt:V8SF (match_operand:V8SF 1 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_AVX\"\n-  \"vsqrtps\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"sse\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"V8SF\")])\n+(define_expand \"sqrt<mode>2\"\n+  [(set (match_operand:VF2 0 \"register_operand\" \"\")\n+\t(sqrt:VF2 (match_operand:VF2 1 \"nonimmediate_operand\" \"\")))])\n \n-(define_expand \"sqrtv4sf2\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n-\t(sqrt:V4SF (match_operand:V4SF 1 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_SSE\"\n+(define_expand \"sqrt<mode>2\"\n+  [(set (match_operand:VF1 0 \"register_operand\" \"\")\n+\t(sqrt:VF1 (match_operand:VF1 1 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n {\n-  if (TARGET_SSE_MATH && TARGET_RECIP && optimize_insn_for_speed_p ()\n+  if (TARGET_SSE_MATH && TARGET_RECIP && !optimize_insn_for_size_p ()\n       && flag_finite_math_only && !flag_trapping_math\n       && flag_unsafe_math_optimizations)\n     {\n-      ix86_emit_swsqrtsf (operands[0], operands[1], V4SFmode, 0);\n+      ix86_emit_swsqrtsf (operands[0], operands[1], <MODE>mode, false);\n       DONE;\n     }\n })\n \n-(define_insn \"sse_sqrtv4sf2\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n-\t(sqrt:V4SF (match_operand:V4SF 1 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE\"\n-  \"%vsqrtps\\t{%1, %0|%0, %1}\"\n+(define_insn \"<sse>_sqrt<mode>2\"\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x\")\n+\t(sqrt:VF (match_operand:VF 1 \"nonimmediate_operand\" \"xm\")))]\n+  \"\"\n+  \"%vsqrt<ssemodesuffix>\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sse\")\n    (set_attr \"atom_sse_attr\" \"sqrt\")\n    (set_attr \"prefix\" \"maybe_vex\")\n-   (set_attr \"mode\" \"V4SF\")])\n-\n-(define_insn \"sqrtv4df2\"\n-  [(set (match_operand:V4DF 0 \"register_operand\" \"=x\")\n-\t(sqrt:V4DF (match_operand:V4DF 1 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_AVX\"\n-  \"vsqrtpd\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"sse\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"V4DF\")])\n-\n-(define_insn \"sqrtv2df2\"\n-  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n-\t(sqrt:V2DF (match_operand:V2DF 1 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE2\"\n-  \"%vsqrtpd\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"sse\")\n-   (set_attr \"prefix\" \"maybe_vex\")\n-   (set_attr \"mode\" \"V2DF\")])\n-\n-(define_insn \"*avx_vmsqrt<mode>2\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(vec_merge:SSEMODEF2P\n-\t  (sqrt:SSEMODEF2P\n-\t    (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"xm\"))\n-\t  (match_operand:SSEMODEF2P 2 \"register_operand\" \"x\")\n-\t  (const_int 1)))]\n-  \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"vsqrt<ssescalarmodesuffix>\\t{%1, %2, %0|%0, %2, %1}\"\n-  [(set_attr \"type\" \"sse\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<ssescalarmode>\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"<sse>_vmsqrt<mode>2\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(vec_merge:SSEMODEF2P\n-\t  (sqrt:SSEMODEF2P\n-\t    (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"xm\"))\n-\t  (match_operand:SSEMODEF2P 2 \"register_operand\" \"0\")\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:VF_128\n+\t  (sqrt:VF_128\n+\t    (match_operand:VF_128 1 \"nonimmediate_operand\" \"xm,xm\"))\n+\t  (match_operand:VF_128 2 \"register_operand\" \"0,x\")\n \t  (const_int 1)))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"sqrt<ssescalarmodesuffix>\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"sse\")\n+  \"\"\n+  \"@\n+   sqrt<ssescalarmodesuffix>\\t{%1, %0|%0, %1}\n+   vsqrt<ssescalarmodesuffix>\\t{%1, %2, %0|%0, %2, %1}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sse\")\n    (set_attr \"atom_sse_attr\" \"sqrt\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<ssescalarmode>\")])\n \n-(define_expand \"rsqrtv8sf2\"\n-  [(set (match_operand:V8SF 0 \"register_operand\" \"\")\n-\t(unspec:V8SF\n-\t  [(match_operand:V8SF 1 \"nonimmediate_operand\" \"\")] UNSPEC_RSQRT))]\n-  \"TARGET_AVX && TARGET_SSE_MATH\"\n-{\n-  ix86_emit_swsqrtsf (operands[0], operands[1], V8SFmode, 1);\n-  DONE;\n-})\n-\n-(define_insn \"avx_rsqrtv8sf2\"\n-  [(set (match_operand:V8SF 0 \"register_operand\" \"=x\")\n-\t(unspec:V8SF\n-\t  [(match_operand:V8SF 1 \"nonimmediate_operand\" \"xm\")] UNSPEC_RSQRT))]\n-  \"TARGET_AVX\"\n-  \"vrsqrtps\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"sse\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"V8SF\")])\n-\n-(define_expand \"rsqrtv4sf2\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"\")\n-\t(unspec:V4SF\n-\t  [(match_operand:V4SF 1 \"nonimmediate_operand\" \"\")] UNSPEC_RSQRT))]\n+(define_expand \"rsqrt<mode>2\"\n+  [(set (match_operand:VF1 0 \"register_operand\" \"\")\n+\t(unspec:VF1\n+\t  [(match_operand:VF1 1 \"nonimmediate_operand\" \"\")] UNSPEC_RSQRT))]\n   \"TARGET_SSE_MATH\"\n {\n-  ix86_emit_swsqrtsf (operands[0], operands[1], V4SFmode, 1);\n+  ix86_emit_swsqrtsf (operands[0], operands[1], <MODE>mode, true);\n   DONE;\n })\n \n-(define_insn \"sse_rsqrtv4sf2\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n-\t(unspec:V4SF\n-\t  [(match_operand:V4SF 1 \"nonimmediate_operand\" \"xm\")] UNSPEC_RSQRT))]\n-  \"TARGET_SSE\"\n+(define_insn \"<sse>_rsqrt<mode>2\"\n+  [(set (match_operand:VF1 0 \"register_operand\" \"=x\")\n+\t(unspec:VF1\n+\t  [(match_operand:VF1 1 \"nonimmediate_operand\" \"xm\")] UNSPEC_RSQRT))]\n+  \"\"\n   \"%vrsqrtps\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sse\")\n    (set_attr \"prefix\" \"maybe_vex\")\n-   (set_attr \"mode\" \"V4SF\")])\n-\n-(define_insn \"*avx_vmrsqrtv4sf2\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n-\t(vec_merge:V4SF\n-\t  (unspec:V4SF [(match_operand:V4SF 1 \"nonimmediate_operand\" \"xm\")]\n-\t\t       UNSPEC_RSQRT)\n-\t  (match_operand:V4SF 2 \"register_operand\" \"x\")\n-\t  (const_int 1)))]\n-  \"TARGET_AVX\"\n-  \"vrsqrtss\\t{%1, %2, %0|%0, %2, %1}\"\n-  [(set_attr \"type\" \"sse\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"SF\")])\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"sse_vmrsqrtv4sf2\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x\")\n \t(vec_merge:V4SF\n-\t  (unspec:V4SF [(match_operand:V4SF 1 \"nonimmediate_operand\" \"xm\")]\n+\t  (unspec:V4SF [(match_operand:V4SF 1 \"nonimmediate_operand\" \"xm,xm\")]\n \t\t       UNSPEC_RSQRT)\n-\t  (match_operand:V4SF 2 \"register_operand\" \"0\")\n+\t  (match_operand:V4SF 2 \"register_operand\" \"0,x\")\n \t  (const_int 1)))]\n   \"TARGET_SSE\"\n-  \"rsqrtss\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"sse\")\n+  \"@\n+   rsqrtss\\t{%1, %0|%0, %1}\n+   vrsqrtss\\t{%1, %2, %0|%0, %2, %1}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sse\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"SF\")])\n \n ;; ??? For !flag_finite_math_only, the representation with SMIN/SMAX\n ;; isn't really correct, as those rtl operators aren't defined when\n ;; applied to NaNs.  Hopefully the optimizers won't get too smart on us.\n \n (define_expand \"<code><mode>3\"\n-  [(set (match_operand:AVX256MODEF2P 0 \"register_operand\" \"\")\n-\t(smaxmin:AVX256MODEF2P\n-\t  (match_operand:AVX256MODEF2P 1 \"nonimmediate_operand\" \"\")\n-\t  (match_operand:AVX256MODEF2P 2 \"nonimmediate_operand\" \"\")))]\n-  \"AVX256_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-{\n-  if (!flag_finite_math_only)\n-    operands[1] = force_reg (<MODE>mode, operands[1]);\n-  ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\n-})\n-\n-(define_expand \"<code><mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"\")\n-\t(smaxmin:SSEMODEF2P\n-\t  (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"\")\n-\t  (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"\")))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n+  [(set (match_operand:VF 0 \"register_operand\" \"\")\n+\t(smaxmin:VF\n+\t  (match_operand:VF 1 \"nonimmediate_operand\" \"\")\n+\t  (match_operand:VF 2 \"nonimmediate_operand\" \"\")))]\n+  \"\"\n {\n   if (!flag_finite_math_only)\n     operands[1] = force_reg (<MODE>mode, operands[1]);\n   ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\n })\n \n-(define_insn \"*avx_<code><mode>3_finite\"\n-  [(set (match_operand:AVXMODEF2P 0 \"register_operand\" \"=x\")\n-\t(smaxmin:AVXMODEF2P\n-\t  (match_operand:AVXMODEF2P 1 \"nonimmediate_operand\" \"%x\")\n-\t  (match_operand:AVXMODEF2P 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"AVX_VEC_FLOAT_MODE_P (<MODE>mode) && flag_finite_math_only\n-   && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n-  \"v<maxmin_float><ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n (define_insn \"*<code><mode>3_finite\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(smaxmin:SSEMODEF2P\n-\t  (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"%0\")\n-\t  (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode) && flag_finite_math_only\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,x\")\n+\t(smaxmin:VF\n+\t  (match_operand:VF 1 \"nonimmediate_operand\" \"%0,x\")\n+\t  (match_operand:VF 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+  \"flag_finite_math_only\n    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n-  \"<maxmin_float><ssemodesuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n+  \"@\n+   <maxmin_float><ssemodesuffix>\\t{%2, %0|%0, %2}\n+   v<maxmin_float><ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sseadd\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*avx_<code><mode>3\"\n-  [(set (match_operand:AVXMODEF2P 0 \"register_operand\" \"=x\")\n-\t(smaxmin:AVXMODEF2P\n-\t  (match_operand:AVXMODEF2P 1 \"nonimmediate_operand\" \"%x\")\n-\t  (match_operand:AVXMODEF2P 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"v<maxmin_float><ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<avxvecmode>\")])\n-\n (define_insn \"*<code><mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(smaxmin:SSEMODEF2P\n-\t  (match_operand:SSEMODEF2P 1 \"register_operand\" \"0\")\n-\t  (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"<maxmin_float><ssemodesuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,x\")\n+\t(smaxmin:VF\n+\t  (match_operand:VF 1 \"register_operand\" \"0,x\")\n+\t  (match_operand:VF 2 \"nonimmediate_operand\" \"xm,xm\")))]\n+  \"!flag_finite_math_only\"\n+  \"@\n+   <maxmin_float><ssemodesuffix>\\t{%2, %0|%0, %2}\n+   v<maxmin_float><ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sseadd\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*avx_vm<code><mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(vec_merge:SSEMODEF2P\n-\t  (smaxmin:SSEMODEF2P\n-\t    (match_operand:SSEMODEF2P 1 \"register_operand\" \"x\")\n-\t    (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\"))\n-\t (match_dup 1)\n-\t (const_int 1)))]\n-  \"AVX128_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"v<maxmin_float><ssescalarmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"sse\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<ssescalarmode>\")])\n-\n (define_insn \"<sse>_vm<code><mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(vec_merge:SSEMODEF2P\n-\t  (smaxmin:SSEMODEF2P\n-\t    (match_operand:SSEMODEF2P 1 \"register_operand\" \"0\")\n-\t    (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\"))\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:VF_128\n+\t  (smaxmin:VF_128\n+\t    (match_operand:VF_128 1 \"register_operand\" \"0,x\")\n+\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm,xm\"))\n \t (match_dup 1)\n \t (const_int 1)))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"<maxmin_float><ssescalarmodesuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n+  \"\"\n+  \"@\n+   <maxmin_float><ssescalarmodesuffix>\\t{%2, %0|%0, %2}\n+   v<maxmin_float><ssescalarmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sse\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<ssescalarmode>\")])\n \n ;; These versions of the min/max patterns implement exactly the operations\n@@ -1184,66 +964,36 @@\n ;; Their operands are not commutative, and thus they may be used in the\n ;; presence of -0.0 and NaN.\n \n-(define_insn \"*avx_ieee_smin<mode>3\"\n-  [(set (match_operand:AVXMODEF2P 0 \"register_operand\" \"=x\")\n-\t(unspec:AVXMODEF2P\n-\t  [(match_operand:AVXMODEF2P 1 \"register_operand\" \"x\")\n-\t   (match_operand:AVXMODEF2P 2 \"nonimmediate_operand\" \"xm\")]\n-\t UNSPEC_IEEE_MIN))]\n-  \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"vmin<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<avxvecmode>\")])\n-\n-(define_insn \"*avx_ieee_smax<mode>3\"\n-  [(set (match_operand:AVXMODEF2P 0 \"register_operand\" \"=x\")\n-\t(unspec:AVXMODEF2P\n-\t  [(match_operand:AVXMODEF2P 1 \"register_operand\" \"x\")\n-\t   (match_operand:AVXMODEF2P 2 \"nonimmediate_operand\" \"xm\")]\n-\t UNSPEC_IEEE_MAX))]\n-  \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"vmax<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<avxvecmode>\")])\n-\n (define_insn \"*ieee_smin<mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(unspec:SSEMODEF2P\n-\t  [(match_operand:SSEMODEF2P 1 \"register_operand\" \"0\")\n-\t   (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\")]\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,x\")\n+\t(unspec:VF\n+\t  [(match_operand:VF 1 \"register_operand\" \"0,x\")\n+\t   (match_operand:VF 2 \"nonimmediate_operand\" \"xm,xm\")]\n \t UNSPEC_IEEE_MIN))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"min<ssemodesuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n+  \"\"\n+  \"@\n+   vmin<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\n+   min<ssemodesuffix>\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sseadd\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*ieee_smax<mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(unspec:SSEMODEF2P\n-\t  [(match_operand:SSEMODEF2P 1 \"register_operand\" \"0\")\n-\t   (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\")]\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,x\")\n+\t(unspec:VF\n+\t  [(match_operand:VF 1 \"register_operand\" \"0,x\")\n+\t   (match_operand:VF 2 \"nonimmediate_operand\" \"xm,xm\")]\n \t UNSPEC_IEEE_MAX))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"max<ssemodesuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n+  \"\"\n+  \"@\n+   vmax<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\n+   max<ssemodesuffix>\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sseadd\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"avx_addsubv8sf3\"\n-  [(set (match_operand:V8SF 0 \"register_operand\" \"=x\")\n-\t(vec_merge:V8SF\n-\t  (plus:V8SF\n-\t    (match_operand:V8SF 1 \"register_operand\" \"x\")\n-\t    (match_operand:V8SF 2 \"nonimmediate_operand\" \"xm\"))\n-\t  (minus:V8SF (match_dup 1) (match_dup 2))\n-\t  (const_int 170)))]\n-  \"TARGET_AVX\"\n-  \"vaddsubps\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"V8SF\")])\n-\n (define_insn \"avx_addsubv4df3\"\n   [(set (match_operand:V4DF 0 \"register_operand\" \"=x\")\n \t(vec_merge:V4DF\n@@ -1258,62 +1008,56 @@\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"V4DF\")])\n \n-(define_insn \"*avx_addsubv4sf3\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n-\t(vec_merge:V4SF\n-\t  (plus:V4SF\n-\t    (match_operand:V4SF 1 \"register_operand\" \"x\")\n-\t    (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\"))\n-\t  (minus:V4SF (match_dup 1) (match_dup 2))\n-\t  (const_int 10)))]\n+(define_insn \"sse3_addsubv2df3\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:V2DF\n+\t  (plus:V2DF\n+\t    (match_operand:V2DF 1 \"register_operand\" \"0,x\")\n+\t    (match_operand:V2DF 2 \"nonimmediate_operand\" \"xm,xm\"))\n+\t  (minus:V2DF (match_dup 1) (match_dup 2))\n+\t  (const_int 2)))]\n+  \"TARGET_SSE3\"\n+  \"@\n+   addsubpd\\t{%2, %0|%0, %2}\n+   vaddsubpd\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sseadd\")\n+   (set_attr \"atom_unit\" \"complex\")\n+   (set_attr \"prefix\" \"orig,vex\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n+(define_insn \"avx_addsubv8sf3\"\n+  [(set (match_operand:V8SF 0 \"register_operand\" \"=x\")\n+\t(vec_merge:V8SF\n+\t  (plus:V8SF\n+\t    (match_operand:V8SF 1 \"register_operand\" \"x\")\n+\t    (match_operand:V8SF 2 \"nonimmediate_operand\" \"xm\"))\n+\t  (minus:V8SF (match_dup 1) (match_dup 2))\n+\t  (const_int 170)))]\n   \"TARGET_AVX\"\n   \"vaddsubps\\t{%2, %1, %0|%0, %1, %2}\"\n   [(set_attr \"type\" \"sseadd\")\n    (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"V4SF\")])\n+   (set_attr \"mode\" \"V8SF\")])\n \n (define_insn \"sse3_addsubv4sf3\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x\")\n \t(vec_merge:V4SF\n \t  (plus:V4SF\n-\t    (match_operand:V4SF 1 \"register_operand\" \"0\")\n-\t    (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\"))\n+\t    (match_operand:V4SF 1 \"register_operand\" \"0,x\")\n+\t    (match_operand:V4SF 2 \"nonimmediate_operand\" \"xm,xm\"))\n \t  (minus:V4SF (match_dup 1) (match_dup 2))\n \t  (const_int 10)))]\n   \"TARGET_SSE3\"\n-  \"addsubps\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"prefix_rep\" \"1\")\n+  \"@\n+   addsubps\\t{%2, %0|%0, %2}\n+   vaddsubps\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sseadd\")\n+   (set_attr \"prefix\" \"orig,vex\")\n+   (set_attr \"prefix_rep\" \"1,*\")\n    (set_attr \"mode\" \"V4SF\")])\n \n-(define_insn \"*avx_addsubv2df3\"\n-  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n-\t(vec_merge:V2DF\n-\t  (plus:V2DF\n-\t    (match_operand:V2DF 1 \"register_operand\" \"x\")\n-\t    (match_operand:V2DF 2 \"nonimmediate_operand\" \"xm\"))\n-\t  (minus:V2DF (match_dup 1) (match_dup 2))\n-\t  (const_int 2)))]\n-  \"TARGET_AVX\"\n-  \"vaddsubpd\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"V2DF\")])\n-\n-(define_insn \"sse3_addsubv2df3\"\n-  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n-\t(vec_merge:V2DF\n-\t  (plus:V2DF\n-\t    (match_operand:V2DF 1 \"register_operand\" \"0\")\n-\t    (match_operand:V2DF 2 \"nonimmediate_operand\" \"xm\"))\n-\t  (minus:V2DF (match_dup 1) (match_dup 2))\n-\t  (const_int 2)))]\n-  \"TARGET_SSE3\"\n-  \"addsubpd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"atom_unit\" \"complex\")\n-   (set_attr \"mode\" \"V2DF\")])\n-\n (define_insn \"avx_h<plusminus_insn>v4df3\"\n   [(set (match_operand:V4DF 0 \"register_operand\" \"=x\")\n \t(vec_concat:V4DF\n@@ -1341,6 +1085,28 @@\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"V4DF\")])\n \n+(define_insn \"sse3_h<plusminus_insn>v2df3\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=x,x\")\n+\t(vec_concat:V2DF\n+\t  (plusminus:DF\n+\t    (vec_select:DF\n+\t      (match_operand:V2DF 1 \"register_operand\" \"0,x\")\n+\t      (parallel [(const_int 0)]))\n+\t    (vec_select:DF (match_dup 1) (parallel [(const_int 1)])))\n+\t  (plusminus:DF\n+\t    (vec_select:DF\n+\t      (match_operand:V2DF 2 \"nonimmediate_operand\" \"xm,xm\")\n+\t      (parallel [(const_int 0)]))\n+\t    (vec_select:DF (match_dup 2) (parallel [(const_int 1)])))))]\n+  \"TARGET_SSE3\"\n+  \"@\n+   h<plusminus_mnemonic>pd\\t{%2, %0|%0, %2}\n+   vh<plusminus_mnemonic>pd\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sseadd\")\n+   (set_attr \"prefix\" \"orig,vex\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n (define_insn \"avx_h<plusminus_insn>v8sf3\"\n   [(set (match_operand:V8SF 0 \"register_operand\" \"=x\")\n \t(vec_concat:V8SF\n@@ -1384,40 +1150,13 @@\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"V8SF\")])\n \n-(define_insn \"*avx_h<plusminus_insn>v4sf3\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n-\t(vec_concat:V4SF\n-\t  (vec_concat:V2SF\n-\t    (plusminus:SF\n-\t      (vec_select:SF\n-\t\t(match_operand:V4SF 1 \"register_operand\" \"x\")\n-\t\t(parallel [(const_int 0)]))\n-\t      (vec_select:SF (match_dup 1) (parallel [(const_int 1)])))\n-\t    (plusminus:SF\n-\t      (vec_select:SF (match_dup 1) (parallel [(const_int 2)]))\n-\t      (vec_select:SF (match_dup 1) (parallel [(const_int 3)]))))\n-\t  (vec_concat:V2SF\n-\t    (plusminus:SF\n-\t      (vec_select:SF\n-\t\t(match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\")\n-\t\t(parallel [(const_int 0)]))\n-\t      (vec_select:SF (match_dup 2) (parallel [(const_int 1)])))\n-\t    (plusminus:SF\n-\t      (vec_select:SF (match_dup 2) (parallel [(const_int 2)]))\n-\t      (vec_select:SF (match_dup 2) (parallel [(const_int 3)]))))))]\n-  \"TARGET_AVX\"\n-  \"vh<plusminus_mnemonic>ps\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"V4SF\")])\n-\n (define_insn \"sse3_h<plusminus_insn>v4sf3\"\n-  [(set (match_operand:V4SF 0 \"register_operand\" \"=x\")\n+  [(set (match_operand:V4SF 0 \"register_operand\" \"=x,x\")\n \t(vec_concat:V4SF\n \t  (vec_concat:V2SF\n \t    (plusminus:SF\n \t      (vec_select:SF\n-\t\t(match_operand:V4SF 1 \"register_operand\" \"0\")\n+\t\t(match_operand:V4SF 1 \"register_operand\" \"0,x\")\n \t\t(parallel [(const_int 0)]))\n \t      (vec_select:SF (match_dup 1) (parallel [(const_int 1)])))\n \t    (plusminus:SF\n@@ -1426,55 +1165,44 @@\n \t  (vec_concat:V2SF\n \t    (plusminus:SF\n \t      (vec_select:SF\n-\t\t(match_operand:V4SF 2 \"nonimmediate_operand\" \"xm\")\n+\t\t(match_operand:V4SF 2 \"nonimmediate_operand\" \"xm,xm\")\n \t\t(parallel [(const_int 0)]))\n \t      (vec_select:SF (match_dup 2) (parallel [(const_int 1)])))\n \t    (plusminus:SF\n \t      (vec_select:SF (match_dup 2) (parallel [(const_int 2)]))\n \t      (vec_select:SF (match_dup 2) (parallel [(const_int 3)]))))))]\n   \"TARGET_SSE3\"\n-  \"h<plusminus_mnemonic>ps\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n+  \"@\n+   h<plusminus_mnemonic>ps\\t{%2, %0|%0, %2}\n+   vh<plusminus_mnemonic>ps\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"sseadd\")\n    (set_attr \"atom_unit\" \"complex\")\n-   (set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"prefix\" \"orig,vex\")\n+   (set_attr \"prefix_rep\" \"1,*\")\n    (set_attr \"mode\" \"V4SF\")])\n \n-(define_insn \"*avx_h<plusminus_insn>v2df3\"\n-  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n-\t(vec_concat:V2DF\n-\t  (plusminus:DF\n-\t    (vec_select:DF\n-\t      (match_operand:V2DF 1 \"register_operand\" \"x\")\n-\t      (parallel [(const_int 0)]))\n-\t    (vec_select:DF (match_dup 1) (parallel [(const_int 1)])))\n-\t  (plusminus:DF\n-\t    (vec_select:DF\n-\t      (match_operand:V2DF 2 \"nonimmediate_operand\" \"xm\")\n-\t      (parallel [(const_int 0)]))\n-\t    (vec_select:DF (match_dup 2) (parallel [(const_int 1)])))))]\n+(define_expand \"reduc_splus_v4df\"\n+  [(match_operand:V4DF 0 \"register_operand\" \"\")\n+   (match_operand:V4DF 1 \"register_operand\" \"\")]\n   \"TARGET_AVX\"\n-  \"vh<plusminus_mnemonic>pd\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"V2DF\")])\n+{\n+  rtx tmp = gen_reg_rtx (V4DFmode);\n+  rtx tmp2 = gen_reg_rtx (V4DFmode);\n+  emit_insn (gen_avx_haddv4df3 (tmp, operands[1], operands[1]));\n+  emit_insn (gen_avx_vperm2f128v4df3 (tmp2, tmp, tmp, GEN_INT (1)));\n+  emit_insn (gen_addv4df3 (operands[0], tmp, tmp2));\n+  DONE;\n+})\n \n-(define_insn \"sse3_h<plusminus_insn>v2df3\"\n-  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n-\t(vec_concat:V2DF\n-\t  (plusminus:DF\n-\t    (vec_select:DF\n-\t      (match_operand:V2DF 1 \"register_operand\" \"0\")\n-\t      (parallel [(const_int 0)]))\n-\t    (vec_select:DF (match_dup 1) (parallel [(const_int 1)])))\n-\t  (plusminus:DF\n-\t    (vec_select:DF\n-\t      (match_operand:V2DF 2 \"nonimmediate_operand\" \"xm\")\n-\t      (parallel [(const_int 0)]))\n-\t    (vec_select:DF (match_dup 2) (parallel [(const_int 1)])))))]\n+(define_expand \"reduc_splus_v2df\"\n+  [(match_operand:V2DF 0 \"register_operand\" \"\")\n+   (match_operand:V2DF 1 \"register_operand\" \"\")]\n   \"TARGET_SSE3\"\n-  \"h<plusminus_mnemonic>pd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"mode\" \"V2DF\")])\n+{\n+  emit_insn (gen_sse3_haddv2df3 (operands[0], operands[1], operands[1]));\n+  DONE;\n+})\n \n (define_expand \"reduc_splus_v8sf\"\n   [(match_operand:V8SF 0 \"register_operand\" \"\")\n@@ -1506,27 +1234,6 @@\n   DONE;\n })\n \n-(define_expand \"reduc_splus_v4df\"\n-  [(match_operand:V4DF 0 \"register_operand\" \"\")\n-   (match_operand:V4DF 1 \"register_operand\" \"\")]\n-  \"TARGET_AVX\"\n-{\n-  rtx tmp = gen_reg_rtx (V4DFmode);\n-  rtx tmp2 = gen_reg_rtx (V4DFmode);\n-  emit_insn (gen_avx_haddv4df3 (tmp, operands[1], operands[1]));\n-  emit_insn (gen_avx_vperm2f128v4df3 (tmp2, tmp, tmp, GEN_INT (1)));\n-  emit_insn (gen_addv4df3 (operands[0], tmp, tmp2));\n-  DONE;\n-})\n-\n-(define_expand \"reduc_splus_v2df\"\n-  [(match_operand:V2DF 0 \"register_operand\" \"\")\n-   (match_operand:V2DF 1 \"register_operand\" \"\")]\n-  \"TARGET_SSE3\"\n-{\n-  emit_insn (gen_sse3_haddv2df3 (operands[0], operands[1], operands[1]));\n-  DONE;\n-})\n \n (define_expand \"reduc_smax_v4sf\"\n   [(match_operand:V4SF 0 \"register_operand\" \"\")\n@@ -1552,11 +1259,11 @@\n ;;\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \n-(define_insn \"avx_cmp<ssemodesuffix><mode>3\"\n-  [(set (match_operand:AVXMODEF2P 0 \"register_operand\" \"=x\")\n-\t(unspec:AVXMODEF2P\n-\t  [(match_operand:AVXMODEF2P 1 \"register_operand\" \"x\")\n-\t   (match_operand:AVXMODEF2P 2 \"nonimmediate_operand\" \"xm\")\n+(define_insn \"avx_cmp<mode>3\"\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x\")\n+\t(unspec:VF\n+\t  [(match_operand:VF 1 \"register_operand\" \"x\")\n+\t   (match_operand:VF 2 \"nonimmediate_operand\" \"xm\")\n \t   (match_operand:SI 3 \"const_0_to_31_operand\" \"n\")]\n \t  UNSPEC_PCMP))]\n   \"TARGET_AVX\"\n@@ -1566,12 +1273,12 @@\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"avx_cmp<ssescalarmodesuffix><mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"\")\n-\t(vec_merge:SSEMODEF2P\n-\t  (unspec:SSEMODEF2P\n-\t    [(match_operand:SSEMODEF2P 1 \"register_operand\" \"x\")\n-\t     (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\")\n+(define_insn \"avx_vmcmp<mode>3\"\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=x\")\n+\t(vec_merge:VF_128\n+\t  (unspec:VF_128\n+\t    [(match_operand:VF_128 1 \"register_operand\" \"x\")\n+\t     (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm\")\n \t     (match_operand:SI 3 \"const_0_to_31_operand\" \"n\")]\n \t    UNSPEC_PCMP)\n \t (match_dup 1)\n@@ -1583,58 +1290,37 @@\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"<ssescalarmode>\")])\n \n-;; We don't promote 128bit vector compare intrinsics. But vectorizer\n-;; may generate 256bit vector compare instructions.\n-(define_insn \"*avx_maskcmp<mode>3\"\n-  [(set (match_operand:AVXMODEF2P 0 \"register_operand\" \"=x\")\n-\t(match_operator:AVXMODEF2P 3 \"avx_comparison_float_operator\"\n-\t\t[(match_operand:AVXMODEF2P 1 \"register_operand\" \"x\")\n-\t\t (match_operand:AVXMODEF2P 2 \"nonimmediate_operand\" \"xm\")]))]\n-  \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"vcmp%D3<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"ssecmp\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"length_immediate\" \"1\")\n-   (set_attr \"mode\" \"<avxvecmode>\")])\n-\n (define_insn \"<sse>_maskcmp<mode>3\"\n-  [(set (match_operand:SSEMODEF4 0 \"register_operand\" \"=x\")\n-\t(match_operator:SSEMODEF4 3 \"sse_comparison_operator\"\n-\t\t[(match_operand:SSEMODEF4 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SSEMODEF4 2 \"nonimmediate_operand\" \"xm\")]))]\n-  \"!TARGET_XOP \n-  && (SSE_FLOAT_MODE_P (<MODE>mode) || SSE_VEC_FLOAT_MODE_P (<MODE>mode))\"\n-  \"cmp%D3<ssemodesuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ssecmp\")\n+  [(set (match_operand:VF 0 \"register_operand\" \"=x,x\")\n+\t(match_operator:VF 3 \"sse_comparison_operator\"\n+\t  [(match_operand:VF 1 \"register_operand\" \"0,x\")\n+\t   (match_operand:VF 2 \"nonimmediate_operand\" \"xm,xm\")]))]\n+  \"\"\n+  \"@\n+   cmp%D3<ssemodesuffix>\\t{%2, %0|%0, %2}\n+   vcmp%D3<ssemodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"ssecmp\")\n    (set_attr \"length_immediate\" \"1\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*avx_vmmaskcmp<mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(vec_merge:SSEMODEF2P\n-\t (match_operator:SSEMODEF2P 3 \"sse_comparison_operator\"\n-\t\t[(match_operand:SSEMODEF2P 1 \"register_operand\" \"x\")\n-\t\t (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\")])\n-\t (match_dup 1)\n-\t (const_int 1)))]\n-  \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"vcmp%D3<ssescalarmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"ssecmp\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"<ssescalarmode>\")])\n-\n (define_insn \"<sse>_vmmaskcmp<mode>3\"\n-  [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(vec_merge:SSEMODEF2P\n-\t (match_operator:SSEMODEF2P 3 \"sse_comparison_operator\"\n-\t\t[(match_operand:SSEMODEF2P 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\")])\n+  [(set (match_operand:VF_128 0 \"register_operand\" \"=x,x\")\n+\t(vec_merge:VF_128\n+\t (match_operator:VF_128 3 \"sse_comparison_operator\"\n+\t   [(match_operand:VF_128 1 \"register_operand\" \"0,x\")\n+\t    (match_operand:VF_128 2 \"nonimmediate_operand\" \"xm,xm\")])\n \t (match_dup 1)\n \t (const_int 1)))]\n-  \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n-  \"cmp%D3<ssescalarmodesuffix>\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ssecmp\")\n-   (set_attr \"length_immediate\" \"1\")\n+  \"\"\n+  \"@\n+   cmp%D3<ssescalarmodesuffix>\\t{%2, %0|%0, %2}\n+   vcmp%D3<ssescalarmodesuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  [(set_attr \"isa\" \"noavx,avx\")\n+   (set_attr \"type\" \"ssecmp\")\n+   (set_attr \"length_immediate\" \"1,*\")\n+   (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<ssescalarmode>\")])\n \n (define_insn \"<sse>_comi\"\n@@ -1678,15 +1364,14 @@\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_expand \"vcond<mode>\"\n-  [(set (match_operand:AVXMODEF2P 0 \"register_operand\" \"\")\n-        (if_then_else:AVXMODEF2P\n+  [(set (match_operand:VF 0 \"register_operand\" \"\")\n+        (if_then_else:VF\n           (match_operator 3 \"\"\n-            [(match_operand:AVXMODEF2P 4 \"nonimmediate_operand\" \"\")\n-             (match_operand:AVXMODEF2P 5 \"nonimmediate_operand\" \"\")])\n-          (match_operand:AVXMODEF2P 1 \"general_operand\" \"\")\n-          (match_operand:AVXMODEF2P 2 \"general_operand\" \"\")))]\n-  \"(SSE_VEC_FLOAT_MODE_P (<MODE>mode)\n-    || AVX_VEC_FLOAT_MODE_P (<MODE>mode))\"\n+            [(match_operand:VF 4 \"nonimmediate_operand\" \"\")\n+             (match_operand:VF 5 \"nonimmediate_operand\" \"\")])\n+          (match_operand:VF 1 \"general_operand\" \"\")\n+          (match_operand:VF 2 \"general_operand\" \"\")))]\n+  \"\"\n {\n   bool ok = ix86_expand_fp_vcond (operands);\n   gcc_assert (ok);"}]}