{"sha": "0a52429609a9570149af903c231c25f17da79b15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE1MjQyOTYwOWE5NTcwMTQ5YWY5MDNjMjMxYzI1ZjE3ZGE3OWIxNQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-05-10T07:59:42Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-05-10T07:59:42Z"}, "message": "re PR fortran/90093 (Extended C interop: optional argument incorrectly identified as PRESENT)\n\n2019-05-10  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/90093\n\t* trans-decl.c (convert_CFI_desc): Test that the dummy is\n\tpresent before doing any of the conversions.\n\n\tPR fortran/90352\n\t* decl.c (gfc_verify_c_interop_param): Restore the error for\n\tcharlen > 1 actual arguments passed to bind(C) procs.\n\tClean up trailing white space.\n\n\tPR fortran/90355\n\t* trans-array.c (gfc_trans_create_temp_array): Set the 'span'\n\tfield to the element length for all types.\n\t(gfc_conv_expr_descriptor): The force_no_tmp flag is used to\n\tprevent temporary creation, especially for substrings.\n\t* trans-decl.c (gfc_trans_deferred_vars): Rather than assert\n\tthat the backend decl for the string length is non-null, use it\n\tas a condition before calling gfc_trans_vla_type_sizes.\n\t* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): 'force_no_tmp'\n\tis set before calling gfc_conv_expr_descriptor.\n\t* trans.c (get_array_span): Move the code for extracting 'span'\n\tfrom gfc_build_array_ref to this function. This is specific to\n\tdescriptors that are component and indirect references.\n\t* trans.h : Add the force_no_tmp flag bitfield to gfc_se.\n\n2019-05-10  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/90093\n\t* gfortran.dg/ISO_Fortran_binding_12.f90: New test.\n\t* gfortran.dg/ISO_Fortran_binding_12.c: Supplementary code.\n\n\tPR fortran/90352\n\t* gfortran.dg/iso_c_binding_char_1.f90: New test.\n\n\tPR fortran/90355\n\t* gfortran.dg/ISO_Fortran_binding_4.f90: Add 'substr' to test\n\tthe direct passing of substrings as descriptors to bind(C).\n\t* gfortran.dg/assign_10.f90: Increase the tree_dump count of\n\t'atmp' to account for the setting of the 'span' field.\n\t* gfortran.dg/transpose_optimization_2.f90: Ditto.\n\nFrom-SVN: r271057", "tree": {"sha": "5949919936e24cc45ea5df3794892250570d0ba2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5949919936e24cc45ea5df3794892250570d0ba2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a52429609a9570149af903c231c25f17da79b15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a52429609a9570149af903c231c25f17da79b15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a52429609a9570149af903c231c25f17da79b15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a52429609a9570149af903c231c25f17da79b15/comments", "author": null, "committer": null, "parents": [{"sha": "e965aaf6027f52020992279f59ed166805c33d55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e965aaf6027f52020992279f59ed166805c33d55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e965aaf6027f52020992279f59ed166805c33d55"}], "stats": {"total": 293, "additions": 238, "deletions": 55}, "files": [{"sha": "cd73dd2971c36633d7fb211b1557c928a5a5566c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0a52429609a9570149af903c231c25f17da79b15", "patch": "@@ -1,3 +1,29 @@\n+2019-05-10  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/90093\n+\t* trans-decl.c (convert_CFI_desc): Test that the dummy is\n+\tpresent before doing any of the conversions.\n+\n+\tPR fortran/90352\n+\t* decl.c (gfc_verify_c_interop_param): Restore the error for\n+\tcharlen > 1 actual arguments passed to bind(C) procs.\n+\tClean up trailing white space.\n+\n+\tPR fortran/90355\n+\t* trans-array.c (gfc_trans_create_temp_array): Set the 'span'\n+\tfield to the element length for all types.\n+\t(gfc_conv_expr_descriptor): The force_no_tmp flag is used to\n+\tprevent temporary creation, especially for substrings.\n+\t* trans-decl.c (gfc_trans_deferred_vars): Rather than assert\n+\tthat the backend decl for the string length is non-null, use it\n+\tas a condition before calling gfc_trans_vla_type_sizes.\n+\t* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): 'force_no_tmp'\n+\tis set before calling gfc_conv_expr_descriptor.\n+\t* trans.c (get_array_span): Move the code for extracting 'span'\n+\tfrom gfc_build_array_ref to this function. This is specific to\n+\tdescriptors that are component and indirect references.\n+\t* trans.h : Add the force_no_tmp flag bitfield to gfc_se.\n+\n 2019-05-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/90351"}, {"sha": "1c785a4f74c85d424d0928683f17f1b875fdfeeb", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=0a52429609a9570149af903c231c25f17da79b15", "patch": "@@ -406,7 +406,7 @@ match_data_constant (gfc_expr **result)\n \t contains the right constant expression.  Check here.  */\n       if ((*result)->symtree == NULL\n \t  && (*result)->expr_type == EXPR_CONSTANT\n-\t  && ((*result)->ts.type == BT_INTEGER \n+\t  && ((*result)->ts.type == BT_INTEGER\n \t      || (*result)->ts.type == BT_REAL))\n \treturn m;\n \n@@ -1493,19 +1493,18 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \n           /* Character strings are only C interoperable if they have a\n              length of 1.  */\n-          if (sym->ts.type == BT_CHARACTER)\n+          if (sym->ts.type == BT_CHARACTER && !sym->attr.dimension)\n \t    {\n \t      gfc_charlen *cl = sym->ts.u.cl;\n \t      if (!cl || !cl->length || cl->length->expr_type != EXPR_CONSTANT\n                   || mpz_cmp_si (cl->length->value.integer, 1) != 0)\n \t\t{\n-\t\t  if (!gfc_notify_std (GFC_STD_F2018,\n-\t\t\t\t       \"Character argument %qs at %L \"\n-\t\t\t\t       \"must be length 1 because \"\n-\t\t\t\t       \"procedure %qs is BIND(C)\",\n-\t\t\t\t       sym->name, &sym->declared_at,\n-\t\t\t\t       sym->ns->proc_name->name))\n-\t\t    retval = false;\n+\t\t  gfc_error (\"Character argument %qs at %L \"\n+\t\t\t     \"must be length 1 because \"\n+\t\t\t     \"procedure %qs is BIND(C)\",\n+\t\t\t     sym->name, &sym->declared_at,\n+\t\t\t     sym->ns->proc_name->name);\n+\t\t  retval = false;\n \t\t}\n \t    }\n \n@@ -6074,7 +6073,7 @@ static bool\n in_module_or_interface(void)\n {\n   if (gfc_current_state () == COMP_MODULE\n-      || gfc_current_state () == COMP_SUBMODULE \n+      || gfc_current_state () == COMP_SUBMODULE\n       || gfc_current_state () == COMP_INTERFACE)\n     return true;\n \n@@ -6085,7 +6084,7 @@ in_module_or_interface(void)\n       gfc_state_data *p;\n       for (p = gfc_state_stack->previous; p ; p = p->previous)\n \t{\n-\t  if (p->state == COMP_MODULE || p->state == COMP_SUBMODULE \n+\t  if (p->state == COMP_MODULE || p->state == COMP_SUBMODULE\n \t      || p->state == COMP_INTERFACE)\n \t    return true;\n \t}\n@@ -6304,7 +6303,7 @@ gfc_match_formal_arglist (gfc_symbol *progname, int st_flag,\n     }\n \n   if (gfc_match_char (')') == MATCH_YES)\n-  {        \n+  {\n     if (typeparam)\n       {\n \tgfc_error_now (\"A type parameter list is required at %C\");\n@@ -7489,7 +7488,7 @@ gfc_match_entry (void)\n \t  if (!gfc_add_is_bind_c (&(entry->attr), entry->name,\n \t\t\t\t  &(entry->declared_at), 1))\n \t    return MATCH_ERROR;\n-\t\n+\n \t}\n \n       if (!gfc_current_ns->parent"}, {"sha": "8a0de6140edab818cadef41d196d87816752ccda", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=0a52429609a9570149af903c231c25f17da79b15", "patch": "@@ -1239,6 +1239,7 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n   tree nelem;\n   tree cond;\n   tree or_expr;\n+  tree elemsize;\n   tree class_expr = NULL_TREE;\n   int n, dim, tmp_dim;\n   int total_dim = 0;\n@@ -1333,15 +1334,6 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n   tmp = gfc_conv_descriptor_dtype (desc);\n   gfc_add_modify (pre, tmp, gfc_get_dtype (TREE_TYPE (desc)));\n \n-  /* Also set the span for derived types, since they can be used in\n-     component references to arrays of this type.  */\n-  if (TREE_CODE (eltype) == RECORD_TYPE)\n-    {\n-      tmp = TYPE_SIZE_UNIT (eltype);\n-      tmp = fold_convert (gfc_array_index_type, tmp);\n-      gfc_conv_descriptor_span_set (pre, desc, tmp);\n-    }\n-\n   /*\n      Fill in the bounds and stride.  This is a packed array, so:\n \n@@ -1413,22 +1405,21 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n \t}\n     }\n \n+  if (class_expr == NULL_TREE)\n+    elemsize = fold_convert (gfc_array_index_type,\n+\t\t\t     TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n+  else\n+    elemsize = gfc_class_vtab_size_get (class_expr);\n+\n   /* Get the size of the array.  */\n   if (size && !callee_alloc)\n     {\n-      tree elemsize;\n       /* If or_expr is true, then the extent in at least one\n \t dimension is zero and the size is set to zero.  */\n       size = fold_build3_loc (input_location, COND_EXPR, gfc_array_index_type,\n \t\t\t      or_expr, gfc_index_zero_node, size);\n \n       nelem = size;\n-      if (class_expr == NULL_TREE)\n-\telemsize = fold_convert (gfc_array_index_type,\n-\t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n-      else\n-\telemsize = gfc_class_vtab_size_get (class_expr);\n-\n       size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n \t\t\t      size, elemsize);\n     }\n@@ -1438,6 +1429,10 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n       size = NULL_TREE;\n     }\n \n+  /* Set the span.  */\n+  tmp = fold_convert (gfc_array_index_type, elemsize);\n+  gfc_conv_descriptor_span_set (pre, desc, tmp);\n+\n   gfc_trans_allocate_array_storage (pre, post, info, size, nelem, initial,\n \t\t\t\t    dynamic, dealloc);\n \n@@ -7248,6 +7243,8 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \n       if (se->force_tmp)\n \tneed_tmp = 1;\n+      else if (se->force_no_tmp)\n+\tneed_tmp = 0;\n \n       if (need_tmp)\n \tfull = 0;"}, {"sha": "c010956a7efc98443bae0f70de6fb3b114321114", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=0a52429609a9570149af903c231c25f17da79b15", "patch": "@@ -4278,8 +4278,10 @@ convert_CFI_desc (gfc_wrapped_block * block, gfc_symbol *sym)\n   tree CFI_desc_ptr;\n   tree dummy_ptr;\n   tree tmp;\n+  tree present;\n   tree incoming;\n   tree outgoing;\n+  stmtblock_t outer_block;\n   stmtblock_t tmpblock;\n \n   /* dummy_ptr will be the pointer to the passed array descriptor,\n@@ -4303,6 +4305,12 @@ convert_CFI_desc (gfc_wrapped_block * block, gfc_symbol *sym)\n       gfc_desc_ptr = gfc_create_var (tmp, \"gfc_desc_ptr\");\n       CFI_desc_ptr = gfc_create_var (pvoid_type_node, \"CFI_desc_ptr\");\n \n+      /* Fix the condition for the presence of the argument.  */\n+      gfc_init_block (&outer_block);\n+      present = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t logical_type_node, dummy_ptr,\n+\t\t\t\t build_int_cst (TREE_TYPE (dummy_ptr), 0));\n+\n       gfc_init_block (&tmpblock);\n       /* Pointer to the gfc descriptor.  */\n       gfc_add_modify (&tmpblock, gfc_desc_ptr,\n@@ -4318,16 +4326,43 @@ convert_CFI_desc (gfc_wrapped_block * block, gfc_symbol *sym)\n       /* Set the dummy pointer to point to the gfc_descriptor.  */\n       gfc_add_modify (&tmpblock, dummy_ptr,\n \t\t      fold_convert (TREE_TYPE (dummy_ptr), gfc_desc_ptr));\n-      incoming = gfc_finish_block (&tmpblock);\n \n-      gfc_init_block (&tmpblock);\n+      /* The hidden string length is not passed to bind(C) procedures so set\n+\t it from the descriptor element length.  */\n+      if (sym->ts.type == BT_CHARACTER\n+\t  && sym->ts.u.cl->backend_decl\n+\t  && VAR_P (sym->ts.u.cl->backend_decl))\n+\t{\n+\t  tmp = build_fold_indirect_ref_loc (input_location, dummy_ptr);\n+\t  tmp = gfc_conv_descriptor_elem_len (tmp);\n+\t  gfc_add_modify (&tmpblock, sym->ts.u.cl->backend_decl,\n+\t\t\t  fold_convert (TREE_TYPE (sym->ts.u.cl->backend_decl),\n+\t\t\t\t        tmp));\n+\t}\n+\n+      /* Check that the argument is present before executing the above.  */\n+      incoming = build3_v (COND_EXPR, present,\n+\t\t\t   gfc_finish_block (&tmpblock),\n+\t\t\t   build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&outer_block, incoming);\n+      incoming = gfc_finish_block (&outer_block);\n+\n+\n       /* Convert the gfc descriptor back to the CFI type before going\n-\t out of scope.  */\n+\t out of scope, if the CFI type was present at entry.  */\n+      gfc_init_block (&outer_block);\n+      gfc_init_block (&tmpblock);\n+\n       tmp = gfc_build_addr_expr (ppvoid_type_node, CFI_desc_ptr);\n       outgoing = build_call_expr_loc (input_location,\n \t\t\tgfor_fndecl_gfc_to_cfi, 2, tmp, gfc_desc_ptr);\n       gfc_add_expr_to_block (&tmpblock, outgoing);\n-      outgoing = gfc_finish_block (&tmpblock);\n+\n+      outgoing = build3_v (COND_EXPR, present,\n+\t\t\t   gfc_finish_block (&tmpblock),\n+\t\t\t   build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&outer_block, outgoing);\n+      outgoing = gfc_finish_block (&outer_block);\n \n       /* Add the lot to the procedure init and finally blocks.  */\n       gfc_add_init_cleanup (block, incoming, outgoing);\n@@ -4923,9 +4958,9 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \n   for (f = gfc_sym_get_dummy_args (proc_sym); f; f = f->next)\n     {\n-      if (f->sym && f->sym->tlink == NULL && f->sym->ts.type == BT_CHARACTER)\n+      if (f->sym && f->sym->tlink == NULL && f->sym->ts.type == BT_CHARACTER\n+\t  && f->sym->ts.u.cl->backend_decl)\n \t{\n-\t  gcc_assert (f->sym->ts.u.cl->backend_decl != NULL);\n \t  if (TREE_CODE (f->sym->ts.u.cl->backend_decl) == PARM_DECL)\n \t    gfc_trans_vla_type_sizes (f->sym, &tmpblock);\n \t}"}, {"sha": "3711c38b2f237addd465870137920a254d775481", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=0a52429609a9570149af903c231c25f17da79b15", "patch": "@@ -5006,6 +5006,7 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n \n   if (e->rank != 0)\n     {\n+      parmse->force_no_tmp = 1;\n       if (fsym->attr.contiguous\n \t  && !gfc_is_simply_contiguous (e, false, true))\n \tgfc_conv_subref_array_arg (parmse, e, false, fsym->attr.intent,"}, {"sha": "e7844c9bf1f92fcd47630a553f4dc18ceb6d334a", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=0a52429609a9570149af903c231c25f17da79b15", "patch": "@@ -290,6 +290,16 @@ get_array_span (tree type, tree decl)\n {\n   tree span;\n \n+  /* Component references are guaranteed to have a reliable value for\n+     'span'. Likewise indirect references since they emerge from the\n+     conversion of a CFI descriptor or the hidden dummy descriptor.  */\n+  if (TREE_CODE (decl) == COMPONENT_REF\n+      && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+    return gfc_conv_descriptor_span_get (decl);\n+  else if (TREE_CODE (decl) == INDIRECT_REF\n+\t   && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+    return gfc_conv_descriptor_span_get (decl);\n+\n   /* Return the span for deferred character length array references.  */\n   if (type && TREE_CODE (type) == ARRAY_TYPE\n       && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != NULL_TREE\n@@ -352,9 +362,6 @@ get_array_span (tree type, tree decl)\n       else\n \tspan = NULL_TREE;\n     }\n-  else if (TREE_CODE (decl) == INDIRECT_REF\n-\t   && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n-    span = gfc_conv_descriptor_span_get (decl);\n   else\n     span = NULL_TREE;\n \n@@ -399,12 +406,7 @@ gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n   if (vptr)\n     span = gfc_vptr_size_get (vptr);\n   else if (decl)\n-    {\n-      if (TREE_CODE (decl) == COMPONENT_REF)\n-\tspan = gfc_conv_descriptor_span_get (decl);\n-      else\n-\tspan = get_array_span (type, decl);\n-    }\n+    span = get_array_span (type, decl);\n \n   /* If a non-null span has been generated reference the element with\n      pointer arithmetic.  */"}, {"sha": "273c75a422c071d65a2f19c35a3629243a8ede91", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=0a52429609a9570149af903c231c25f17da79b15", "patch": "@@ -91,6 +91,9 @@ typedef struct gfc_se\n      args alias.  */\n   unsigned force_tmp:1;\n \n+  /* If set, will pass subref descriptors without a temporary.  */\n+  unsigned force_no_tmp:1;\n+\n   /* Unconditionally calculate offset for array segments and constant\n      arrays in gfc_conv_expr_descriptor.  */\n   unsigned use_offset:1;"}, {"sha": "889c08dfce01b9ad97b293f5610587b1666ea9af", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0a52429609a9570149af903c231c25f17da79b15", "patch": "@@ -1,3 +1,19 @@\n+2019-05-10  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/90093\n+\t* gfortran.dg/ISO_Fortran_binding_12.f90: New test.\n+\t* gfortran.dg/ISO_Fortran_binding_12.c: Supplementary code.\n+\n+\tPR fortran/90352\n+\t* gfortran.dg/iso_c_binding_char_1.f90: New test.\n+\n+\tPR fortran/90355\n+\t* gfortran.dg/ISO_Fortran_binding_4.f90: Add 'substr' to test\n+\tthe direct passing of substrings as descriptors to bind(C).\n+\t* gfortran.dg/assign_10.f90: Increase the tree_dump count of\n+\t'atmp' to account for the setting of the 'span' field.\n+\t* gfortran.dg/transpose_optimization_2.f90: Ditto.\n+\n 2019-05-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/88709\n@@ -305,7 +321,7 @@\n \tPR fortran/60144\n \t* gfortran.dg/block_name_2.f90: Adjust dg-error.\n \t* gfortran.dg/dec_type_print_3.f90.f90: Likewise\n-\t* gfortran.dg/pr60144.f90: New test. \n+\t* gfortran.dg/pr60144.f90: New test.\n \n 2019-05-01  Jeff Law  <law@redhat.com>\n "}, {"sha": "279d9f6d0506fe6800be62e21c8899167f804e7a", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_12.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_12.c?ref=0a52429609a9570149af903c231c25f17da79b15", "patch": "@@ -0,0 +1,29 @@\n+/* Test the fix for PR90093.  */\n+\n+#include <stdio.h>\n+#include <math.h>\n+#include \"../../../libgfortran/ISO_Fortran_binding.h\"\n+\n+/* Contributed by Reinhold Bader  <Bader@lrz.de>  */\n+\n+void foo_opt(CFI_cdesc_t *, float *, int *, int);\n+void write_res();\n+\n+float x[34];\n+\n+int main() {\n+    CFI_CDESC_T(1) xd;\n+    CFI_index_t ext[] = {34};\n+    int sz;\n+\n+    CFI_establish((CFI_cdesc_t *) &xd, &x, CFI_attribute_other,\n+\t\t  CFI_type_float, 0, 1, ext);\n+\n+    foo_opt((CFI_cdesc_t *) &xd, NULL, NULL, 0);\n+    sz = 12;\n+    foo_opt(NULL, &x[11], &sz, 1);\n+\n+    write_res();\n+\n+    return 0;\n+}"}, {"sha": "d71c67749cef68371ef66ad31c17852e2ece73cd", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_12.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_12.f90?ref=0a52429609a9570149af903c231c25f17da79b15", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do run { target c99_runtime } }\n+! { dg-additional-sources ISO_Fortran_binding_12.c }\n+!\n+! Test the fix for PR90093. The additional source is the main program.\n+!\n+! Contributed by Reinhold Bader  <Bader@lrz.de>\n+!\n+module mod_optional\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+  integer :: status = 0\n+\n+contains\n+\n+  subroutine foo_opt(this, that, sz, flag) bind(c)\n+    real(c_float), optional :: this(:)\n+    real(c_float), optional :: that(*)\n+    integer(c_int), optional :: sz\n+    integer(c_int), value :: flag\n+    if (flag == 0) then\n+       if (.not. present(this) .or. present(that) .or. present(sz)) then\n+          write(*,*) 'FAIL 1', present(this), present(that), present(sz)\n+          status = status + 1\n+       end if\n+    else if (flag == 1) then\n+       if (present(this) .or. .not. present(that) .or. .not. present(sz)) then\n+          write(*,*) 'FAIL 2', present(this), present(that), present(sz)\n+          status = status + 1\n+       end if\n+       if (sz /= 12) then\n+          write(*,*) 'FAIL 3'\n+          status = status + 1\n+       end if\n+    else if (flag == 2) then\n+       if (present(this) .or. present(that) .or. present(sz)) then\n+          write(*,*) 'FAIL 4', present(this), present(that), present(sz)\n+          status = status + 1\n+       end if\n+    end if\n+  end subroutine foo_opt\n+\n+  subroutine write_res() BIND(C)\n+! Add a check that the fortran missing optional is accepted by the\n+! bind(C) procedure.\n+    call foo_opt (flag = 2)\n+    if (status == 0) then\n+       write(*,*) 'OK'\n+    else\n+       stop 1\n+    end if\n+  end subroutine\n+\n+end module mod_optional"}, {"sha": "7731d1a6c88adb65ad2c8d15a4e48465748ee0d7", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_4.f90", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_4.f90?ref=0a52429609a9570149af903c231c25f17da79b15", "patch": "@@ -1,29 +1,41 @@\n ! { dg-do  run }\n ! PR fortran/89384 - this used to give a wrong results\n ! with contiguous.\n+! The subroutine substr is a test to check a problem found while\n+! debugging PR90355.\n+!\n ! Test case by Reinhold Bader.\n+!\n module mod_ctg\n   implicit none\n+\n contains\n+\n   subroutine ctg(x) BIND(C)\n     real, contiguous :: x(:)\n-\n-    if (any(abs(x - [2.,4.,6.]) > 1.e-6)) then\n-       write(*,*) 'FAIL'\n-       stop 1\n-    else\n-       write(*,*) 'OK'\n-    end if\n+    if (any(abs(x - [2.,4.,6.]) > 1.e-6)) stop 1\n     x = [2.,4.,6.]*10.0\n   end subroutine\n+\n+  subroutine substr(str) BIND(C)\n+    character(*) :: str(:)\n+    if (str(2) .ne. \"ghi\") stop 2\n+    str = ['uvw','xyz']\n+  end subroutine\n+\n end module\n+\n program p\n   use mod_ctg\n   implicit none\n   real :: x(6)\n+  character(5) :: str(2) = ['abcde','fghij']\n   integer :: i\n \n   x = [ (real(i), i=1, size(x)) ]\n   call ctg(x(2::2))\n-  if (any (abs (x - [1.,20.,3.,40.,5.,60.]) > 1.e-6)) stop 2\n+  if (any (abs (x - [1.,20.,3.,40.,5.,60.]) > 1.e-6)) stop 3\n+\n+  call substr(str(:)(2:4))\n+  if (any (str .ne. ['auvwe','fxyzj'])) stop 4\n end program"}, {"sha": "c207f9e5e2b48b1a6d487b0ecf813e6c50e3661d", "filename": "gcc/testsuite/gfortran.dg/assign_10.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ftestsuite%2Fgfortran.dg%2Fassign_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ftestsuite%2Fgfortran.dg%2Fassign_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassign_10.f90?ref=0a52429609a9570149af903c231c25f17da79b15", "patch": "@@ -24,4 +24,4 @@\n ! Note that it is the kind conversion that generates the temp.\n !\n ! { dg-final { scan-tree-dump-times \"parm\" 20 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"atmp\" 18 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"atmp\" 20 \"original\" } }"}, {"sha": "ebf9a248dacc2bb97d04c3389c9e0801ca22d54c", "filename": "gcc/testsuite/gfortran.dg/iso_c_binding_char_1.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_char_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_char_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_char_1.f90?ref=0a52429609a9570149af903c231c25f17da79b15", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+!\n+! Test the fix for PR90352.\n+!\n+! Contributed by Thomas Koenig  <tkoenig@gcc.gnu.org>\n+!\n+subroutine bar(c,d) BIND(C) ! { dg-error \"must be length 1\" }\n+  character (len=*) c\n+  character (len=2) d\n+end"}, {"sha": "c49cd421058f2eb3516398072176d95aa72e211e", "filename": "gcc/testsuite/gfortran.dg/transpose_optimization_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_optimization_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a52429609a9570149af903c231c25f17da79b15/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_optimization_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_optimization_2.f90?ref=0a52429609a9570149af903c231c25f17da79b15", "patch": "@@ -61,4 +61,4 @@ end subroutine pure_sub\n ! The check below for temporaries gave 14 and 33 for \"parm\" and \"atmp\".\n !\n ! { dg-final { scan-tree-dump-times \"parm\" 72 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"atmp\" 12 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"atmp\" 13 \"original\" } }"}]}