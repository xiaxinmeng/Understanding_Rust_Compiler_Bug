{"sha": "feaa40602b7ecad36de8dcb6c387e686d04ce207", "node_id": "C_kwDOANBUbNoAKGZlYWE0MDYwMmI3ZWNhZDM2ZGU4ZGNiNmMzODdlNjg2ZDA0Y2UyMDc", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-18T12:21:40Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-10-20T15:10:08Z"}, "message": "Initial Type resolution for closures\n\nThis adds the type checking for a HIR::ClosureExpr which specifies a\nTyTy::ClosureType whih inherits the FnOnce trait by default. The\nspecialisation of the trait bound needs to be determined by the the\nmutability and argument capture and moveablity rules.\n\nThe CallExpr is amended here so that we support CallExpr's for all\nreceivers that implement any of the FnTraits. This means closures and\ngenerics that have the relevant type bound of FnTraits we get the same path\nof type checking.\n\nAddresses #195", "tree": {"sha": "895572249bbca638d4eb1ee5de8edbff61b7ae26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/895572249bbca638d4eb1ee5de8edbff61b7ae26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/feaa40602b7ecad36de8dcb6c387e686d04ce207", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feaa40602b7ecad36de8dcb6c387e686d04ce207", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feaa40602b7ecad36de8dcb6c387e686d04ce207", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feaa40602b7ecad36de8dcb6c387e686d04ce207/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e637c0445bc4633a1a6ab1d5c32e3ee82cf03152", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e637c0445bc4633a1a6ab1d5c32e3ee82cf03152", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e637c0445bc4633a1a6ab1d5c32e3ee82cf03152"}], "stats": {"total": 510, "additions": 479, "deletions": 31}, "files": [{"sha": "66d8509e818aae45ab7507ce20a1b976431629c3", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=feaa40602b7ecad36de8dcb6c387e686d04ce207", "patch": "@@ -2131,6 +2131,8 @@ class ClosureExpr : public ExprWithoutBlock\n   };\n   std::unique_ptr<Expr> &get_expr () { return expr; }\n \n+  std::vector<ClosureParam> &get_params () { return params; }\n+\n   void accept_vis (HIRFullVisitor &vis) override;\n   void accept_vis (HIRExpressionVisitor &vis) override;\n "}, {"sha": "8911a1d99f7da77625e8cb3fe6f192e27b565d5a", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 297, "deletions": 11, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=feaa40602b7ecad36de8dcb6c387e686d04ce207", "patch": "@@ -178,16 +178,6 @@ TypeCheckExpr::visit (HIR::CallExpr &expr)\n {\n   TyTy::BaseType *function_tyty = TypeCheckExpr::Resolve (expr.get_fnexpr ());\n \n-  bool valid_tyty = function_tyty->get_kind () == TyTy::TypeKind::ADT\n-\t\t    || function_tyty->get_kind () == TyTy::TypeKind::FNDEF\n-\t\t    || function_tyty->get_kind () == TyTy::TypeKind::FNPTR;\n-  if (!valid_tyty)\n-    {\n-      rust_error_at (expr.get_locus (),\n-\t\t     \"Failed to resolve expression of function call\");\n-      return;\n-    }\n-\n   rust_debug_loc (expr.get_locus (), \"resolved_call_expr to: {%s}\",\n \t\t  function_tyty->get_name ().c_str ());\n \n@@ -214,6 +204,24 @@ TypeCheckExpr::visit (HIR::CallExpr &expr)\n \t  rust_assert (adt->number_of_variants () == 1);\n \t  variant = *adt->get_variants ().at (0);\n \t}\n+\n+      infered\n+\t= TyTy::TypeCheckCallExpr::go (function_tyty, expr, variant, context);\n+      return;\n+    }\n+\n+  bool resolved_fn_trait_call\n+    = resolve_fn_trait_call (expr, function_tyty, &infered);\n+  if (resolved_fn_trait_call)\n+    return;\n+\n+  bool valid_tyty = function_tyty->get_kind () == TyTy::TypeKind::FNDEF\n+\t\t    || function_tyty->get_kind () == TyTy::TypeKind::FNPTR;\n+  if (!valid_tyty)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"Failed to resolve expression of function call\");\n+      return;\n     }\n \n   infered = TyTy::TypeCheckCallExpr::go (function_tyty, expr, variant, context);\n@@ -1422,7 +1430,123 @@ TypeCheckExpr::visit (HIR::MatchExpr &expr)\n void\n TypeCheckExpr::visit (HIR::ClosureExpr &expr)\n {\n-  gcc_unreachable ();\n+  TypeCheckContextItem &current_context = context->peek_context ();\n+  TyTy::FnType *current_context_fndecl = current_context.get_context_type ();\n+\n+  HirId ref = expr.get_mappings ().get_hirid ();\n+  DefId id = expr.get_mappings ().get_defid ();\n+  RustIdent ident{current_context_fndecl->get_ident ().path, expr.get_locus ()};\n+\n+  // get from parent context\n+  std::vector<TyTy::SubstitutionParamMapping> subst_refs\n+    = current_context_fndecl->clone_substs ();\n+\n+  std::vector<TyTy::TyVar> parameter_types;\n+  for (auto &p : expr.get_params ())\n+    {\n+      if (p.has_type_given ())\n+\t{\n+\t  TyTy::BaseType *param_tyty\n+\t    = TypeCheckType::Resolve (p.get_type ().get ());\n+\t  TyTy::TyVar param_ty (param_tyty->get_ref ());\n+\t  parameter_types.push_back (param_ty);\n+\n+\t  TypeCheckPattern::Resolve (p.get_pattern ().get (),\n+\t\t\t\t     param_ty.get_tyty ());\n+\t}\n+      else\n+\t{\n+\t  TyTy::TyVar param_ty\n+\t    = TyTy::TyVar::get_implicit_infer_var (p.get_locus ());\n+\t  parameter_types.push_back (param_ty);\n+\n+\t  TypeCheckPattern::Resolve (p.get_pattern ().get (),\n+\t\t\t\t     param_ty.get_tyty ());\n+\t}\n+    }\n+\n+  // we generate an implicit hirid for the closure args\n+  HirId implicit_args_id = mappings->get_next_hir_id ();\n+  TyTy::TupleType *closure_args\n+    = new TyTy::TupleType (implicit_args_id, expr.get_locus (),\n+\t\t\t   parameter_types);\n+  context->insert_implicit_type (closure_args);\n+\n+  Location result_type_locus = expr.has_return_type ()\n+\t\t\t\t ? expr.get_return_type ()->get_locus ()\n+\t\t\t\t : expr.get_locus ();\n+  TyTy::TyVar result_type\n+    = expr.has_return_type ()\n+\t? TyTy::TyVar (\n+\t  TypeCheckType::Resolve (expr.get_return_type ().get ())->get_ref ())\n+\t: TyTy::TyVar::get_implicit_infer_var (expr.get_locus ());\n+\n+  // resolve the block\n+  Location closure_expr_locus = expr.get_expr ()->get_locus ();\n+  TyTy::BaseType *closure_expr_ty\n+    = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n+  coercion_site (expr.get_mappings ().get_hirid (),\n+\t\t TyTy::TyWithLocation (result_type.get_tyty (),\n+\t\t\t\t       result_type_locus),\n+\t\t TyTy::TyWithLocation (closure_expr_ty, closure_expr_locus),\n+\t\t expr.get_locus ());\n+\n+  // generate the closure type\n+  infered = new TyTy::ClosureType (ref, id, ident, closure_args, result_type,\n+\t\t\t\t   subst_refs);\n+\n+  // FIXME\n+  // all closures automatically inherit the appropriate fn trait. Lets just\n+  // assume FnOnce for now. I think this is based on the return type of the\n+  // closure\n+\n+  Analysis::RustLangItem::ItemType lang_item_type\n+    = Analysis::RustLangItem::ItemType::FN_ONCE;\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+  if (!lang_item_defined)\n+    {\n+      // FIXME\n+      // we need to have a unified way or error'ing when we are missing lang\n+      // items that is useful\n+      rust_fatal_error (\n+\texpr.get_locus (), \"unable to find lang item: %<%s%>\",\n+\tAnalysis::RustLangItem::ToString (lang_item_type).c_str ());\n+    }\n+  rust_assert (lang_item_defined);\n+\n+  // these lang items are always traits\n+  HIR::Item *item = mappings->lookup_defid (respective_lang_item_id);\n+  rust_assert (item->get_item_kind () == HIR::Item::ItemKind::Trait);\n+  HIR::Trait *trait_item = static_cast<HIR::Trait *> (item);\n+\n+  TraitReference *trait = TraitResolver::Resolve (*trait_item);\n+  rust_assert (!trait->is_error ());\n+\n+  TyTy::TypeBoundPredicate predicate (*trait, expr.get_locus ());\n+\n+  // resolve the trait bound where the <(Args)> are the parameter tuple type\n+  HIR::GenericArgs args = HIR::GenericArgs::create_empty (expr.get_locus ());\n+\n+  // lets generate an implicit Type so that it resolves to the implict tuple\n+  // type we have created\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_mappings ().get_nodeid (),\n+\t\t\t\t implicit_args_id, UNKNOWN_LOCAL_DEFID);\n+  HIR::TupleType *implicit_tuple\n+    = new HIR::TupleType (mapping,\n+\t\t\t  {} // we dont need to fill this out because it will\n+\t\t\t     // auto resolve because the hir id's match\n+\t\t\t  ,\n+\t\t\t  expr.get_locus ());\n+  args.get_type_args ().push_back (std::unique_ptr<HIR::Type> (implicit_tuple));\n+\n+  // apply the arguments\n+  predicate.apply_generic_arguments (&args);\n+\n+  // finally inherit the trait bound\n+  infered->inherit_bounds ({predicate});\n }\n \n bool\n@@ -1630,6 +1754,168 @@ TypeCheckExpr::resolve_operator_overload (\n   return true;\n }\n \n+HIR::PathIdentSegment\n+TypeCheckExpr::resolve_possible_fn_trait_call_method_name (\n+  const TyTy::BaseType &receiver)\n+{\n+  // Question\n+  // do we need to probe possible bounds here? I think not, i think when we\n+  // support Fn traits they are explicitly specified\n+\n+  // FIXME\n+  // the logic to map the FnTrait to their respective call trait-item is\n+  // duplicated over in the backend/rust-compile-expr.cc\n+  for (const auto &bound : receiver.get_specified_bounds ())\n+    {\n+      bool found_fn = bound.get_name ().compare (\"Fn\") == 0;\n+      bool found_fn_mut = bound.get_name ().compare (\"FnMut\") == 0;\n+      bool found_fn_once = bound.get_name ().compare (\"FnOnce\") == 0;\n+\n+      if (found_fn)\n+\t{\n+\t  return HIR::PathIdentSegment (\"call\");\n+\t}\n+      else if (found_fn_mut)\n+\t{\n+\t  return HIR::PathIdentSegment (\"call_mut\");\n+\t}\n+      else if (found_fn_once)\n+\t{\n+\t  return HIR::PathIdentSegment (\"call_once\");\n+\t}\n+    }\n+\n+  // nothing\n+  return HIR::PathIdentSegment (\"\");\n+}\n+\n+bool\n+TypeCheckExpr::resolve_fn_trait_call (HIR::CallExpr &expr,\n+\t\t\t\t      TyTy::BaseType *receiver_tyty,\n+\t\t\t\t      TyTy::BaseType **result)\n+{\n+  // we turn this into a method call expr\n+  HIR::PathIdentSegment method_name\n+    = resolve_possible_fn_trait_call_method_name (*receiver_tyty);\n+  if (method_name.is_error ())\n+    return false;\n+\n+  auto candidates = MethodResolver::Probe (receiver_tyty, method_name);\n+  if (candidates.empty ())\n+    return false;\n+\n+  if (candidates.size () > 1)\n+    {\n+      RichLocation r (expr.get_locus ());\n+      for (auto &c : candidates)\n+\tr.add_range (c.candidate.locus);\n+\n+      rust_error_at (\n+\tr, \"multiple candidates found for function trait method call %<%s%>\",\n+\tmethod_name.as_string ().c_str ());\n+      return false;\n+    }\n+\n+  if (receiver_tyty->get_kind () == TyTy::TypeKind::CLOSURE)\n+    {\n+      const TyTy::ClosureType &closure\n+\t= static_cast<TyTy::ClosureType &> (*receiver_tyty);\n+      closure.setup_fn_once_output ();\n+    }\n+\n+  auto candidate = *candidates.begin ();\n+  rust_debug_loc (expr.get_locus (),\n+\t\t  \"resolved call-expr to fn trait: {%u} {%s}\",\n+\t\t  candidate.candidate.ty->get_ref (),\n+\t\t  candidate.candidate.ty->debug_str ().c_str ());\n+\n+  // Get the adjusted self\n+  Adjuster adj (receiver_tyty);\n+  TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n+\n+  // store the adjustments for code-generation to know what to do which must be\n+  // stored onto the receiver to so as we don't trigger duplicate deref mappings\n+  // ICE when an argument is a method call\n+  HirId autoderef_mappings_id = expr.get_mappings ().get_hirid ();\n+  context->insert_autoderef_mappings (autoderef_mappings_id,\n+\t\t\t\t      std::move (candidate.adjustments));\n+  context->insert_receiver (expr.get_mappings ().get_hirid (), receiver_tyty);\n+\n+  PathProbeCandidate &resolved_candidate = candidate.candidate;\n+  TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n+  NodeId resolved_node_id\n+    = resolved_candidate.is_impl_candidate ()\n+\t? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n+\t    .get_nodeid ()\n+\t: resolved_candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+  if (lookup_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n+    {\n+      RichLocation r (expr.get_locus ());\n+      r.add_range (resolved_candidate.locus);\n+      rust_error_at (r, \"associated impl item is not a method\");\n+      return false;\n+    }\n+\n+  TyTy::BaseType *lookup = lookup_tyty;\n+  TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+  if (!fn->is_method ())\n+    {\n+      RichLocation r (expr.get_locus ());\n+      r.add_range (resolved_candidate.locus);\n+      rust_error_at (r, \"associated function is not a method\");\n+      return false;\n+    }\n+\n+  // fn traits only support tuple argument passing so we need to implicitly set\n+  // this up to get the same type checking we get in the rest of the pipeline\n+\n+  std::vector<TyTy::TyVar> call_args;\n+  for (auto &arg : expr.get_arguments ())\n+    {\n+      TyTy::BaseType *a = TypeCheckExpr::Resolve (arg.get ());\n+      call_args.push_back (TyTy::TyVar (a->get_ref ()));\n+    }\n+\n+  // crate implicit tuple\n+  HirId implicit_arg_id = mappings->get_next_hir_id ();\n+  Analysis::NodeMapping mapping (mappings->get_current_crate (), UNKNOWN_NODEID,\n+\t\t\t\t implicit_arg_id, UNKNOWN_LOCAL_DEFID);\n+\n+  TyTy::TupleType *tuple\n+    = new TyTy::TupleType (implicit_arg_id, expr.get_locus (), call_args);\n+  context->insert_implicit_type (implicit_arg_id, tuple);\n+\n+  std::vector<TyTy::Argument> args;\n+  TyTy::Argument a (mapping, tuple,\n+\t\t    expr.get_locus () /*FIXME is there a better location*/);\n+  args.push_back (std::move (a));\n+\n+  TyTy::BaseType *function_ret_tyty\n+    = TyTy::TypeCheckMethodCallExpr::go (fn, expr.get_mappings (), args,\n+\t\t\t\t\t expr.get_locus (), expr.get_locus (),\n+\t\t\t\t\t adjusted_self, context);\n+  if (function_ret_tyty == nullptr\n+      || function_ret_tyty->get_kind () == TyTy::TypeKind::ERROR)\n+    {\n+      rust_error_at (expr.get_locus (),\n+\t\t     \"failed check fn trait call-expr MethodCallExpr\");\n+      return false;\n+    }\n+\n+  // store the expected fntype\n+  context->insert_operator_overload (expr.get_mappings ().get_hirid (), fn);\n+\n+  // set up the resolved name on the path\n+  resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t  resolved_node_id);\n+\n+  // return the result of the function back\n+  *result = function_ret_tyty;\n+\n+  return true;\n+}\n+\n bool\n TypeCheckExpr::validate_arithmetic_type (\n   const TyTy::BaseType *tyty, HIR::ArithmeticOrLogicalExpr::ExprType expr_type)"}, {"sha": "3ac8c4dfff81c7f1d3bc684c834ec7b7f846c325", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=feaa40602b7ecad36de8dcb6c387e686d04ce207", "patch": "@@ -103,6 +103,13 @@ class TypeCheckExpr : private TypeCheckBase, private HIR::HIRExpressionVisitor\n \t\t\t     HIR::OperatorExprMeta expr, TyTy::BaseType *lhs,\n \t\t\t     TyTy::BaseType *rhs);\n \n+  bool resolve_fn_trait_call (HIR::CallExpr &expr,\n+\t\t\t      TyTy::BaseType *function_tyty,\n+\t\t\t      TyTy::BaseType **result);\n+\n+  HIR::PathIdentSegment\n+  resolve_possible_fn_trait_call_method_name (const TyTy::BaseType &receiver);\n+\n private:\n   TypeCheckExpr ();\n "}, {"sha": "d785835f7c727e91197cc5c998a1ca92be099eaa", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=feaa40602b7ecad36de8dcb6c387e686d04ce207", "patch": "@@ -70,6 +70,8 @@ class TypeCheckContextItem\n     return item.trait_item;\n   }\n \n+  TyTy::FnType *get_context_type ();\n+\n private:\n   union Item\n   {"}, {"sha": "34b60b37644722db9f89afe28e44949c30419b1f", "filename": "gcc/rust/typecheck/rust-tyctx.cc", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc?ref=feaa40602b7ecad36de8dcb6c387e686d04ce207", "patch": "@@ -154,5 +154,37 @@ TypeCheckContext::peek_context ()\n   return return_type_stack.back ().first;\n }\n \n+// TypeCheckContextItem\n+\n+TyTy::FnType *\n+TypeCheckContextItem::get_context_type ()\n+{\n+  auto &context = *TypeCheckContext::get ();\n+\n+  HirId reference = UNKNOWN_HIRID;\n+  switch (get_type ())\n+    {\n+    case ITEM:\n+      reference = get_item ()->get_mappings ().get_hirid ();\n+      break;\n+\n+    case IMPL_ITEM:\n+      reference = get_impl_item ().second->get_mappings ().get_hirid ();\n+      break;\n+\n+    case TRAIT_ITEM:\n+      reference = get_trait_item ()->get_mappings ().get_hirid ();\n+      break;\n+    }\n+\n+  rust_assert (reference != UNKNOWN_HIRID);\n+\n+  TyTy::BaseType *lookup = nullptr;\n+  bool ok = context.lookup_type (reference, &lookup);\n+  rust_assert (ok);\n+  rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+  return static_cast<TyTy::FnType *> (lookup);\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "23e52d941662b0e7e2c493ba774ff13eab6c7b66", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=feaa40602b7ecad36de8dcb6c387e686d04ce207", "patch": "@@ -871,6 +871,29 @@ class ClosureCmp : public BaseCmp\n     ok = true;\n   }\n \n+  void visit (const ClosureType &type) override\n+  {\n+    if (base->get_def_id () != type.get_def_id ())\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (!base->get_parameters ().can_eq (&type.get_parameters (), false))\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    if (!base->get_result_type ().can_eq (&type.get_result_type (), false))\n+      {\n+\tBaseCmp::visit (type);\n+\treturn;\n+      }\n+\n+    ok = true;\n+  }\n+\n private:\n   const BaseType *get_base () const override { return base; }\n   const ClosureType *base;"}, {"sha": "fe654cad12920cde91c4e1628fb7f8c6fa8bbc31", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=feaa40602b7ecad36de8dcb6c387e686d04ce207", "patch": "@@ -624,7 +624,45 @@ class ClosureRules : public BaseRules\n public:\n   ClosureRules (ClosureType *base) : BaseRules (base), base (base) {}\n \n-  // TODO\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (ClosureType &type) override\n+  {\n+    if (base->get_def_id () != type.get_def_id ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    TyTy::BaseType *args_res\n+      = base->get_parameters ().unify (&type.get_parameters ());\n+    if (args_res == nullptr || args_res->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    TyTy::BaseType *res\n+      = base->get_result_type ().unify (&type.get_result_type ());\n+    if (res == nullptr || res->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n \n private:\n   BaseType *get_base () override { return base; }"}, {"sha": "342fa76ad82893259d56f5b5747d7d99b608cb8b", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 55, "deletions": 3, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=feaa40602b7ecad36de8dcb6c387e686d04ce207", "patch": "@@ -27,6 +27,7 @@\n #include \"rust-substitution-mapper.h\"\n #include \"rust-hir-trait-ref.h\"\n #include \"rust-hir-type-bounds.h\"\n+#include \"rust-hir-trait-resolve.h\"\n #include \"options.h\"\n \n namespace Rust {\n@@ -200,6 +201,7 @@ BaseType::bounds_compatible (const BaseType &other, Location locus,\n \t  rust_error_at (r,\n \t\t\t \"bounds not satisfied for %s %<%s%> is not satisfied\",\n \t\t\t other.get_name ().c_str (), missing_preds.c_str ());\n+\t  // rust_assert (!emit_error);\n \t}\n     }\n \n@@ -1672,7 +1674,9 @@ ClosureType::accept_vis (TyConstVisitor &vis) const\n std::string\n ClosureType::as_string () const\n {\n-  return \"TODO\";\n+  std::string params_buf = parameters->as_string ();\n+  return \"|\" + params_buf + \"| {\" + result_type.get_tyty ()->as_string ()\n+\t + \"} {\" + raw_bounds_as_string () + \"}\";\n }\n \n BaseType *\n@@ -1699,8 +1703,10 @@ ClosureType::is_equal (const BaseType &other) const\n BaseType *\n ClosureType::clone () const\n {\n-  return new ClosureType (get_ref (), get_ty_ref (), ident, id, parameter_types,\n-\t\t\t  result_type, clone_substs (), get_combined_refs ());\n+  return new ClosureType (get_ref (), get_ty_ref (), ident, id,\n+\t\t\t  (TyTy::TupleType *) parameters->clone (), result_type,\n+\t\t\t  clone_substs (), get_combined_refs (),\n+\t\t\t  specified_bounds);\n }\n \n BaseType *\n@@ -1716,6 +1722,52 @@ ClosureType::handle_substitions (SubstitutionArgumentMappings mappings)\n   return nullptr;\n }\n \n+void\n+ClosureType::setup_fn_once_output () const\n+{\n+  // lookup the lang items\n+  auto fn_once_lang_item = Analysis::RustLangItem::ItemType::FN_ONCE;\n+  auto fn_once_output_lang_item\n+    = Analysis::RustLangItem::ItemType::FN_ONCE_OUTPUT;\n+\n+  DefId trait_id = UNKNOWN_DEFID;\n+  bool trait_lang_item_defined\n+    = mappings->lookup_lang_item (fn_once_lang_item, &trait_id);\n+  rust_assert (trait_lang_item_defined);\n+\n+  DefId trait_item_id = UNKNOWN_DEFID;\n+  bool trait_item_lang_item_defined\n+    = mappings->lookup_lang_item (fn_once_output_lang_item, &trait_item_id);\n+  rust_assert (trait_item_lang_item_defined);\n+\n+  // resolve to the trait\n+  HIR::Item *item = mappings->lookup_defid (trait_id);\n+  rust_assert (item->get_item_kind () == HIR::Item::ItemKind::Trait);\n+  HIR::Trait *trait = static_cast<HIR::Trait *> (item);\n+\n+  Resolver::TraitReference *trait_ref\n+    = Resolver::TraitResolver::Resolve (*trait);\n+  rust_assert (!trait_ref->is_error ());\n+\n+  // resolve to trait item\n+  HIR::TraitItem *trait_item\n+    = mappings->lookup_trait_item_defid (trait_item_id);\n+  rust_assert (trait_item != nullptr);\n+  rust_assert (trait_item->get_item_kind ()\n+\t       == HIR::TraitItem::TraitItemKind::TYPE);\n+  std::string item_identifier = trait_item->trait_identifier ();\n+\n+  // setup associated types  #[lang = \"fn_once_output\"]\n+  Resolver::TraitItemReference *item_reference = nullptr;\n+  bool found = trait_ref->lookup_trait_item_by_type (\n+    item_identifier, Resolver::TraitItemReference::TraitItemType::TYPE,\n+    &item_reference);\n+  rust_assert (found);\n+\n+  // setup\n+  item_reference->associated_type_set (&get_result_type ());\n+}\n+\n void\n ArrayType::accept_vis (TyVisitor &vis)\n {"}, {"sha": "9a9f0aa915eeada43efc1937da0f50ab16a04bf3", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feaa40602b7ecad36de8dcb6c387e686d04ce207/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=feaa40602b7ecad36de8dcb6c387e686d04ce207", "patch": "@@ -1626,31 +1626,35 @@ class ClosureType : public BaseType, public SubstitutionRef\n {\n public:\n   ClosureType (HirId ref, DefId id, RustIdent ident,\n-\t       std::vector<TyVar> parameter_types, TyVar result_type,\n+\t       TyTy::TupleType *parameters, TyVar result_type,\n \t       std::vector<SubstitutionParamMapping> subst_refs,\n-\t       std::set<HirId> refs = std::set<HirId> ())\n+\t       std::set<HirId> refs = std::set<HirId> (),\n+\t       std::vector<TypeBoundPredicate> specified_bounds\n+\t       = std::vector<TypeBoundPredicate> ())\n     : BaseType (ref, ref, TypeKind::CLOSURE, ident, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n-      parameter_types (std::move (parameter_types)),\n-      result_type (std::move (result_type)), id (id)\n+      parameters (parameters), result_type (std::move (result_type)), id (id)\n   {\n     LocalDefId local_def_id = id.localDefId;\n     rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n+    inherit_bounds (specified_bounds);\n   }\n \n   ClosureType (HirId ref, HirId ty_ref, RustIdent ident, DefId id,\n-\t       std::vector<TyVar> parameter_types, TyVar result_type,\n+\t       TyTy::TupleType *parameters, TyVar result_type,\n \t       std::vector<SubstitutionParamMapping> subst_refs,\n-\t       std::set<HirId> refs = std::set<HirId> ())\n+\t       std::set<HirId> refs = std::set<HirId> (),\n+\t       std::vector<TypeBoundPredicate> specified_bounds\n+\t       = std::vector<TypeBoundPredicate> ())\n     : BaseType (ref, ty_ref, TypeKind::CLOSURE, ident, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n-      parameter_types (std::move (parameter_types)),\n-      result_type (std::move (result_type)), id (id)\n+      parameters (parameters), result_type (std::move (result_type)), id (id)\n   {\n     LocalDefId local_def_id = id.localDefId;\n     rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n+    inherit_bounds (specified_bounds);\n   }\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1669,13 +1673,8 @@ class ClosureType : public BaseType, public SubstitutionRef\n \n   bool is_concrete () const override final\n   {\n-    for (auto &param : parameter_types)\n-      {\n-\tauto p = param.get_tyty ();\n-\tif (!p->is_concrete ())\n-\t  return false;\n-      }\n-    return result_type.get_tyty ()->is_concrete ();\n+    return parameters->is_concrete ()\n+\t   && result_type.get_tyty ()->is_concrete ();\n   }\n \n   bool needs_generic_substitutions () const override final\n@@ -1693,8 +1692,15 @@ class ClosureType : public BaseType, public SubstitutionRef\n   ClosureType *\n   handle_substitions (SubstitutionArgumentMappings mappings) override final;\n \n+  TyTy::TupleType &get_parameters () const { return *parameters; }\n+  TyTy::BaseType &get_result_type () const { return *result_type.get_tyty (); }\n+\n+  DefId get_def_id () const { return id; }\n+\n+  void setup_fn_once_output () const;\n+\n private:\n-  std::vector<TyVar> parameter_types;\n+  TyTy::TupleType *parameters;\n   TyVar result_type;\n   DefId id;\n };"}]}