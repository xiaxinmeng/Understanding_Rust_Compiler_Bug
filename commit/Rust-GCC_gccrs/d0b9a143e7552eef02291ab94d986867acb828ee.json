{"sha": "d0b9a143e7552eef02291ab94d986867acb828ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBiOWExNDNlNzU1MmVlZjAyMjkxYWI5NGQ5ODY4NjdhY2I4MjhlZQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@wrs.com", "date": "1998-11-23T20:37:32Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-11-23T20:37:32Z"}, "message": "libgcc2.c (top_elt): Remove top_elt, it isn't thread safe.\n\n\t* libgcc2.c (top_elt): Remove top_elt, it isn't thread safe.\n\tThe strategy we now use is to pre allocate the top_elt along\n\twith the EH context so that each thread has its own top_elt.\n\tThis is necessary as the dynmanic cleanup chain is used on the\n\ttop element of the stack and each thread MUST have its own.\n\t(eh_context_static): Likewise.\n\t(new_eh_context): Likewise.\n\t(__sjthrow): Likewise.\n\nFrom-SVN: r23818", "tree": {"sha": "08c5c3cd1e8bdb4d696dd40cbaf8638a9b5cf655", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08c5c3cd1e8bdb4d696dd40cbaf8638a9b5cf655"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0b9a143e7552eef02291ab94d986867acb828ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0b9a143e7552eef02291ab94d986867acb828ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0b9a143e7552eef02291ab94d986867acb828ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0b9a143e7552eef02291ab94d986867acb828ee/comments", "author": null, "committer": null, "parents": [{"sha": "8c8a9717085130efbd17e89ab68aa25bc8e8ef0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c8a9717085130efbd17e89ab68aa25bc8e8ef0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c8a9717085130efbd17e89ab68aa25bc8e8ef0d"}], "stats": {"total": 40, "additions": 30, "deletions": 10}, "files": [{"sha": "19c73a15af0d28c2cd4777e826eea8ebf0339d43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b9a143e7552eef02291ab94d986867acb828ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b9a143e7552eef02291ab94d986867acb828ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0b9a143e7552eef02291ab94d986867acb828ee", "patch": "@@ -1,3 +1,14 @@\n+Mon Nov 23 20:28:02 1998  Mike Stump  <mrs@wrs.com>\n+\n+\t* libgcc2.c (top_elt): Remove top_elt, it isn't thread safe.\n+\tThe strategy we now use is to pre allocate the top_elt along\n+\twith the EH context so that each thread has its own top_elt.\n+\tThis is necessary as the dynmanic cleanup chain is used on the\n+\ttop element of the stack and each thread MUST have its own.\n+\t(eh_context_static): Likewise.\n+\t(new_eh_context): Likewise.\n+\t(__sjthrow): Likewise.\n+\n Mon Nov 23 20:25:03 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* i386/linux.h (ASM_OUTPUT_MAX_SKIP_ALIGN): Wrap in do...while."}, {"sha": "0b5bfa304b0375f31ca7666fbb676223772a0214", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0b9a143e7552eef02291ab94d986867acb828ee/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0b9a143e7552eef02291ab94d986867acb828ee/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=d0b9a143e7552eef02291ab94d986867acb828ee", "patch": "@@ -3067,26 +3067,33 @@ __empty ()\n #include <stdio.h>\n #endif\n \n-/* This is a safeguard for dynamic handler chain. */\n-\n-static void *top_elt[2];\n-\n /* Allocate and return a new EH context structure. */\n \n extern void __throw ();\n \n static void *\n new_eh_context ()\n {\n-  struct eh_context *eh = (struct eh_context *) malloc (sizeof *eh);\n-  if (! eh)\n+  struct eh_full_context {\n+    struct eh_context c;\n+    void *top_elt[2];\n+  } *ehfc = (struct eh_full_context *) malloc (sizeof *ehfc);\n+\n+  if (! ehfc)\n     __terminate ();\n \n-  memset (eh, 0, sizeof *eh);\n+  memset (ehfc, 0, sizeof *ehfc);\n \n-  eh->dynamic_handler_chain = top_elt;\n+  ehfc->c.dynamic_handler_chain = (void **) ehfc->top_elt;\n \n-  return eh;\n+  /* This should optimize out entirely.  This should always be true,\n+     but just in case it ever isn't, don't allow bogus code to be\n+     generated.  */\n+\n+  if ((void*)(&ehfc->c) != (void*)ehfc)\n+    __terminate ();\n+\n+  return &ehfc->c;\n }\n \n #if __GTHREADS\n@@ -3180,6 +3187,8 @@ eh_context_static ()\n {\n   static struct eh_context eh;\n   static int initialized;\n+  static void *top_elt[2];\n+\n   if (! initialized)\n     {\n       initialized = 1;\n@@ -3290,7 +3299,7 @@ __sjthrow ()\n   /* We must call terminate if we try and rethrow an exception, when\n      there is no exception currently active and when there are no\n      handlers left.  */\n-  if (! eh->info || (*dhc) == top_elt)\n+  if (! eh->info || (*dhc)[0] == 0)\n     __terminate ();\n     \n   /* Find the jmpbuf associated with the top element of the dynamic"}]}