{"sha": "2460f7cdef7ef9c971de79271afc0db73687a272", "node_id": "C_kwDOANBUbNoAKDI0NjBmN2NkZWY3ZWY5Yzk3MWRlNzkyNzFhZmMwZGI3MzY4N2EyNzI", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-23T17:47:33Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-26T14:39:29Z"}, "message": "Set ranges from unreachable edges for all known ranges.\n\nIn the conversion of DOM+evrp to DOM+ranger, we missed that evrp was\nexporting ranges for unreachable edges for all SSA names for which we\nhave ranges for.  Instead we have only been exporting ranges for the\nSSA name in the final conditional to the BB involving the unreachable\nedge.\n\nThis patch adjusts adjusts DOM to iterate over the exports, similarly\nto what evrp was doing.\n\nNote that I also noticed that we don't calculate the nonzero bit mask\nfor op1, when 0 = op1 & MASK.  This isn't needed for this PR,\nsince maybe_set_nonzero_bits() is chasing the definition and\nparsing the bitwise and on its own.  However, I'll be adding the\nfunctionality for completeness sake, plus we could probably drop the\nmaybe_set_nonzero_bits legacy call entirely.\n\n\tPR tree-optimization/107009\n\ngcc/ChangeLog:\n\n\t* tree-ssa-dom.cc\n\t(dom_opt_dom_walker::set_global_ranges_from_unreachable_edges):\n\tIterate over exports.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/pr107009.c: New test.", "tree": {"sha": "e7d32c60dcfffa2d34c713cb836269add5cdda3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7d32c60dcfffa2d34c713cb836269add5cdda3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2460f7cdef7ef9c971de79271afc0db73687a272", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2460f7cdef7ef9c971de79271afc0db73687a272", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2460f7cdef7ef9c971de79271afc0db73687a272", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2460f7cdef7ef9c971de79271afc0db73687a272/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9019085e17554c209ca8531022f116b2d7f94fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9019085e17554c209ca8531022f116b2d7f94fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9019085e17554c209ca8531022f116b2d7f94fe"}], "stats": {"total": 50, "additions": 33, "deletions": 17}, "files": [{"sha": "5010aed1723dc32d57075f91c87602018fb00c91", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr107009.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2460f7cdef7ef9c971de79271afc0db73687a272/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr107009.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2460f7cdef7ef9c971de79271afc0db73687a272/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr107009.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr107009.c?ref=2460f7cdef7ef9c971de79271afc0db73687a272", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fdump-tree-dom2-alias\" }\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void saxpy(size_t n)\n+{\n+  if (n == 0 || n % 8 != 0)\n+    __builtin_unreachable();\n+\n+  extern void foobar (size_t n);\n+  foobar (n);\n+}\n+\n+// { dg-final { scan-tree-dump \"NONZERO.*fff8\" \"dom2\" } }"}, {"sha": "84bef798f52daca4b4b46e6963d65f2f61f914bd", "filename": "gcc/tree-ssa-dom.cc", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2460f7cdef7ef9c971de79271afc0db73687a272/gcc%2Ftree-ssa-dom.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2460f7cdef7ef9c971de79271afc0db73687a272/gcc%2Ftree-ssa-dom.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.cc?ref=2460f7cdef7ef9c971de79271afc0db73687a272", "patch": "@@ -1227,29 +1227,30 @@ void\n dom_opt_dom_walker::set_global_ranges_from_unreachable_edges (basic_block bb)\n {\n   edge pred_e = single_pred_edge_ignoring_loop_edges (bb, false);\n-\n   if (!pred_e)\n     return;\n \n   gimple *stmt = last_stmt (pred_e->src);\n+  if (!stmt\n+      || gimple_code (stmt) != GIMPLE_COND\n+      || !assert_unreachable_fallthru_edge_p (pred_e))\n+    return;\n+\n   tree name;\n-  if (stmt\n-      && gimple_code (stmt) == GIMPLE_COND\n-      && (name = gimple_cond_lhs (stmt))\n-      && TREE_CODE (name) == SSA_NAME\n-      && assert_unreachable_fallthru_edge_p (pred_e)\n-      && all_uses_feed_or_dominated_by_stmt (name, stmt))\n-    {\n-      Value_Range r (TREE_TYPE (name));\n+  gori_compute &gori = m_ranger->gori ();\n+  FOR_EACH_GORI_EXPORT_NAME (gori, pred_e->src, name)\n+    if (all_uses_feed_or_dominated_by_stmt (name, stmt))\n+      {\n+\tValue_Range r (TREE_TYPE (name));\n \n-      if (m_ranger->range_on_edge (r, pred_e, name)\n-\t  && !r.varying_p ()\n-\t  && !r.undefined_p ())\n-\t{\n-\t  set_range_info (name, r);\n-\t  maybe_set_nonzero_bits (pred_e, name);\n-\t}\n-    }\n+\tif (m_ranger->range_on_edge (r, pred_e, name)\n+\t    && !r.varying_p ()\n+\t    && !r.undefined_p ())\n+\t  {\n+\t    set_range_info (name, r);\n+\t    maybe_set_nonzero_bits (pred_e, name);\n+\t  }\n+      }\n }\n \n /* Record any equivalences created by the incoming edge to BB into"}]}